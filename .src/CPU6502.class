' Gambas class file

'Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Public PC As Long = &H0000                ' Program counter
Public SP As Byte = &HFF                   ' Stack Pointer 0x100-0x1ff 256 bytes fifo

Public SR As Byte = (1 Shl 3)             ' Status Register start with irq disabled
Public Enum SR_Carry, SR_Zero, SR_Interrupt, SR_Decimal, SR_Break, SR_Ignored, SR_Overflow, SR_Negative

Public AC As Byte = &h0                  ' Acumulator
Public X As Byte = &h0                   ' X register
Public Y As Byte = &h0                   ' Y Register

Public DataBus As Integer = &h0          ' Data on databus
Public AddressBus As Long = &h0          ' Address Bus current address
Property BreakPoints As Boolean Use $BreakPoints  ' turn on breakpoint checking
Public BreakPointList As Long[]          ' an array of breakpoints
Public InstProfile As Profiler           ' when profiling is on then this counts cycles per instruction

'When the following Is False just Return $ff On a bad Memory Read Or Write
Property ChkBadMemAccess As Boolean Use $ChkBadMemAccess = True ' turn on or off catching bad read or writes

Public AddressMap As New Object[]        ' Address bus map object pointers
maphigh As New Long[]
maplow As New Long[]
Public SingleStep As Boolean             ' Turn On single step mode
Public DisplayStatus As Boolean          ' Turn On the status screen
Public DisplayInstruction As Boolean     ' Cause the instruction to be executed to be displayed to the trace screen
Public LastTraceInstruction As String    ' When trace is on this will contain the last data
Public TotalInstructions As Long = 0     ' Number of instructions executed
Property Read InstructionsPerSecond As Long Use $InstructionsPerSecond ' Number of instructions executed per second

Public CpuClock As Timer       ' will run at 1 millisecond intervals       will have to do some sort of multiplyer

Property Read CyclesPerSecond As Long Use $CyclesPerSecond               ' will track the actual number of cycles per second
Property Read TotalCycles As Long Use $TotalCycles                       ' Total Number of Cycles executed

Property SpeedScaler As Long Use $SpeedScaler                     ' use this as each cpu we run on may have a different clock
Property InteruptPending As Boolean Use $InteruptPending = False
Property IRQPending As Boolean Use $IRQPending = False
Property NMIPending As Boolean Use $NMIPending = False
Property ResetPending As Boolean Use $ResetPending = False
Property Halted As Boolean Use $Halted = False
Property Profiling As Boolean Use $Profiling = False
Property Read ProfileInfo As String[]
Property cpu65c02 As Boolean Use $cpu65c02 = False

Event StatusInfo(information As Cpustatus)
Event NextInst(Inst As String)
Event breakpoint(pc As Long)
Event BinaryLoaded(address As Long, BinName As String, info As String)
Event Abort(Reason As String)

Fast Unsafe Public Sub _new()

  Debug Disassembler.version
  $TotalCycles = 0
  $CyclesPerSecond = 0
  $InstructionsPerSecond = 0
  CpuClock = New Timer As "MyClock"
  CpuClock.Delay = 10
  CpuClock.enabled = True
  $SpeedScaler = 2
  $BreakPoints = False
  BreakPointList = New Long[]


End

Fast Unsafe Public Sub _free()

  CpuClock.enabled = False

End

Fast Unsafe Public Sub MyClock_Timer()                     ' the cpu psudotimer

  Static OneSecondTimer As Long = 0
  Static StartInstructionCount As Long = 0
  Static StartCycleCount As Long = 0

  If OneSecondTimer = 99 Then
    OneSecondTimer = 0
    $InstructionsPerSecond = TotalInstructions - StartInstructionCount
    StartInstructionCount = TotalInstructions
    $CyclesPerSecond = $TotalCycles - StartCycleCount
    StartCycleCount = $TotalCycles
  Else
    Inc OneSecondTimer
  Endif

End

Fast Unsafe Public Sub Halt()

  SingleStep = True
  $Halted = True
  Wait 0.001
  CpuClock.Enabled = False
  For Each o As Object In AddressMap
    If Object.Class(o).Exist("halt") Then
      o.halt()                                 ' tell each device to shutdown if needed
    Endif
  Next

End

Fast Unsafe Public Sub ReadBytes(address As Long, length As Integer) As Byte[]

  Dim result As New Byte[]
  Dim sdb As Byte = databus
  Dim sab As Long = AddressBus

  For i As Integer = 0 To length - 1

    AddressBus = address + i
    ReadByte()
    result.Add(DataBus)

  Next

  DataBus = sdb
  AddressBus = sab
  Return result

End

Fast Unsafe Public Sub WriteBytes(buffer As Byte[], address As Long, length As Integer)


  Dim sdb As Byte = databus
  Dim sab As Long = AddressBus

  For i As Integer = 0 To length - 1

    DataBus = buffer[i]
    AddressBus = address + i
    WriteByte()

  Next

  DataBus = sdb
  AddressBus = sab

End

Fast Unsafe Public Sub LoadMemory(FileName As String)

  Dim BinInfo As File
  Dim al, ah As Byte
  Dim buffer As Byte[]
  Dim address As Long = 0
  Dim BinName As String = File.BaseName(FileName)

  Try BinInfo = Open filename For Read
  If Error Then
    Raise BinaryLoaded(address, "", ("Fail:") & BinName & ":" & Error.text)
    Return
  Endif

  Read #BinInfo, al
  Read #BinInfo, ah

  Address = Address Or ah
  Address = ((Address Shl 8) Or al)
  Debug ("Loading Image to address "); Hex(address, 4)

  Dim Length As Integer = Lof(BinInfo) - 2
  buffer = New Byte[length]
  buffer.Read(bininfo)
  Try WriteBytes(buffer, address, length)
  If Error Then
    Raise BinaryLoaded(address, "", ("Fail Writing bytes:") & BinName & ":" & Error.text)
  Endif
  Raise BinaryLoaded(address, BinName, "$" & Hex(address, 4) & "-" & Hex(Address + Length - 1, 4) & " - " & BinName)

End

Fast Unsafe Public Sub Run()

  Dim counter As Long = 0

  While Not $halted
    If $BreakPoints Then
      If BreakPointList.ExistSorted(pc) Then
        SingleStep = True
        $Breakpoints = False
        Raise breakpoint(pc)
        StepInfo()
        Return
      Endif
    Endif

    If $InteruptPending Then
      $InteruptPending = False
      If $ResetPending Then
        Reset()
        CycleCount += 9
      Else If $NMIPending Then
        NMI()
        CycleCount += 5
      Else If $IRQPending Then
        IRQ()
        CycleCount += 5
      Endif
    Endif

    ExecuteInstruction()

    If DisplayStatus Then
      Dim pinfo As New CpuStatus(pc, sp, ac, X, Y, sr, DataBus, AddressBus, TotalInstructions, $InstructionsPerSecond, $TotalCycles, $CyclesPerSecond)
      Raise StatusInfo(pinfo)
    Endif

    If SingleStep Then
      StepInfo()
      Return
    Else If DisplayInstruction Then
      StepInfo()
    Endif

    If counter = $SpeedScaler Then
      Wait 0                           'This is used to check the GUI and throttle the cpu speed
      counter = 0
    Else
      Inc counter
    Endif

  Wend

End

'' Create an event with all the information needed to display the next Instruction with status
Fast Unsafe Sub StepInfo()

  LastTraceInstruction = Left(Disassembler.Inst(Me, pc) & Space(40), 40) & "->[" & SRText() & "] " & Hex(ac, 2) & " " & Hex(X, 2) & " " & Hex(Y, 2) & " " & "1" & Hex(sp, 2)
  Raise NextInst(LastTraceInstruction)

End

FlagsOn As String[] = ["C", "Z", "I", "D", "B", "-", "V", "N"]
FlagsOff As String[] = ["c", "z", "i", "d", "b", "-", "v", "n"]

Fast Unsafe Sub SRText() As String

  Dim flag As String = ""

  For i As Integer = 7 DownTo 0
    If BTst(sr, i) Then
      flag &= "\e[32m" & FlagsOn[i] & "\e[0m"
    Else
      flag &= FlagsOff[i]
    Endif

  Next
  Return flag

End

CycleCount As Integer

Fast Unsafe Public Sub ExecuteInstruction()

  Dim inst As Integer
  Dim addrMode, aaa, cc As Integer

  AddressBus = pc
  ReadByte()
  inst = DataBus

  CycleCount = Disassembler.InstructionCycles[inst]
  $TotalCycles += CycleCount

  If $Profiling Then
    InstProfile.count(pc, CycleCount)
  Endif

  Inc pc
  AddressBus = pc

  addrMode = Disassembler.AddrMode[inst]
  aaa = disassembler.aaa[inst]
  cc = disassembler.cc[inst]

  Select Case cc
    Case 0
      Group0(Me, aaa, addrMode)
    Case 1
      Group1(Me, aaa, AddrMode)
    Case 2
      Group2(Me, aaa, AddrMode)
  End Select

  Inc TotalInstructions

End

Fast Unsafe Public Sub Absolute()

  Dim addrTemp As Long

  ReadByte()
  addrTemp = DataBus
  Inc pc
  Inc AddressBus
  ReadByte()
  AddressBus = ((DataBus Shl 8) Or addrTemp)
  Inc PC

End

Fast Unsafe Public Sub AbsX()

  Absolute()
  AddressBus += X

End

Fast Unsafe Public Sub AbsY()

  Absolute()
  AddressBus += Y

End


Fast Unsafe Public Sub ZeroPage()

  ReadByte()
  AddressBus = DataBus
  Inc PC

End

Fast Unsafe Public Sub ZeroPageIndirect()

  Dim addrTemp As Long

  ZeroPage()
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  ReadByte()
  AddressBus = (DataBus Shl 8) Or addrTemp

End

Fast Unsafe Public Sub ZeroPageX()

  ZeroPage()
  AddressBus += X

End

Fast Unsafe Public Sub ZeroPageY()

  ZeroPage()
  AddressBus += Y

End


Fast Unsafe Public Sub Immediate()

  AddressBus = PC
  Inc pc

End

Fast Unsafe Public Sub IndirectX()

  Dim addrTemp As Long

  ReadByte()
  AddressBus = DataBus + x
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  ReadByte()
  AddressBus = (DataBus Shl 8) Or addrTemp
  Inc PC

End

Fast Unsafe Public Sub IndirectY()

  Dim addrTemp As Long

  ReadByte()
  AddressBus = DataBus
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  Try ReadByte()
  If Error Then
    Stop
  Endif
  AddressBus = (DataBus Shl 8) Or addrTemp
  AddressBus += Y
  Inc PC

End

Fast Unsafe Public Sub Indirect()

  Dim addrTemp As Long

  Absolute()
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  ReadByte()
  AddressBus = (DataBus Shl 8) Or addrTemp

End


Fast Unsafe Public Sub AddMap(Start As Long, Len As Long, Device As Class, Optional vParams As Variant = "") As Object

  Dim params As Variant[] = [Start, Len, vParams]

  Dim dev As Object = Device.New(params)

  If Device.Exist("TheCpu") Then
    dev.TheCpu = Me
  Endif

  object.attach(dev, Me, "MyDevice")

  AddressMap.Add(Dev)
  If len = 0 Then Return dev            ' allow devices which require no memory, such as buttons and switches

  mapLow.Add(Start)
  mapHigh.Add(Start + len - 1)
  ' now let the computer know what binary images were loaded when the device was created
  If Object.Class(dev).Exist("BinLoaded") Then
    Dim binImage As String[] = Split(dev.BinLoaded, ",")
    For Each s As String In BinImage
      Dim info As String[] = Split(s, ":")
      Dim address As Long = Eval("&H0" & info[1])
      Raise BinaryLoaded(address, File.BaseName(info[0]), "$" & info[1] & " - " & File.BaseName(info[0]))
    Next
  Endif

  Return dev

End

Fast Unsafe Public Sub GetDevice(Address As Long) As Object

  For i As Integer = 0 To AddressMap.Max
    If AddressMap[i]._InRange(Address) Then Return AddressMap[i]
  Next

  If $ChkBadMemAccess Then Error.Raise(("Invalid Memory Address") & " [" & Hex(Address, 4) & "]")

End

Fast Unsafe Public Sub ReadByte()

  Dim dev As Object = Null

  For i As Integer = 0 To maplow.Max
    If AddressBus >= maplow[i] And If AddressBus <= maphigh[i] Then
      dev = AddressMap[i]
    Endif
  Next

  If dev Then
    DataBus = dev[AddressBus]
  Else
    If $ChkBadMemAccess Then
      Error.Raise(("Invalid Read Memory Address") & " [" & Hex(AddressBus, 4) & "]")
    Else
      DataBus = &HFF
    Endif
  Endif

End

Fast Unsafe Public Sub WriteByte()

  Dim dev As Object = Null

  'dev = GetDevice(AddressBus)
  For i As Integer = 0 To maplow.Max
    If AddressBus >= maplow[i] And If AddressBus <= maphigh[i] Then
      dev = AddressMap[i]
    Endif
  Next

  If dev Then
    dev[AddressBus] = Databus
  Else
    If $ChkBadMemAccess Then
      Error.Raise(("Invalid Write Memory Address") & " [" & Hex(AddressBus, 4) & "]")
    Endif
  Endif

End


Fast Unsafe Public Sub Reset()

  $NMIPending = False
  $IRQPending = False
  $ResetPending = False

  SR = (1 Shl 2)                ' set the irq disabled bit
  ac = 0
  SetSR(AC)

  AddressBus = &H00FFFC
  ReadByte()                    ' load Databus with value
  PC = DataBus
  Inc AddressBus
  ReadByte()
  PC = (PC Or (DataBus Shl 8))

  If SingleStep Then
    Debug ("PC Reset");; Hex(pc)
    StepInfo()
  Endif

End

Fast Unsafe Public Sub DisplayCurrentInst()

  StepInfo()

End


Fast Unsafe Public Sub Branch()

  If BTst(databus, 7) Then
    Dim offset As Byte = &100 - databus
    pc -= offset
  Else
    pc += databus
  Endif

End


Fast Unsafe Public Sub Compare(Value As Byte)

  Dim RSLT As Byte = value - DATABUS

  If Value = DataBus Then
    Sr = BSet(Sr, 1)
    sr = BSet(sr, 0)
    sr = BClr(sr, 7)
  Else If Value < DataBus Then
    sr = BClr(sr, 0)
    sr = BClr(sr, 1)
  Else  ' greater than
    sr = BClr(sr, 1)
    sr = BSet(sr, 0)
  Endif
  If BTst(RSLT, 7) Then
    SR = BSet(SR, 7)
  Else
    SR = BClr(SR, 7)
  Endif

End


Fast Unsafe Public Sub Push(Optional Value As Byte = databus)

  databus = Value
  AddressBus = &h0100 + sp
  WriteByte()
  Dec sp

End


Fast Unsafe Public Sub Pop() As Byte

  Inc sp
  AddressBus = &h0100 + sp
  ReadByte()
  Return DataBus

End

Fast Unsafe Public Sub interupt(sVector As Long)

  Push(pc Shr 8)
  Push(pc And &h000ff)
  Push(SR)
  AddressBus = sVector
  Readbyte()
  pc = DataBus
  Inc AddressBus
  ReadByte()
  PC = (PC Or (CInt(DataBus) Shl 8))

End

Fast Unsafe Public Sub NMI()

  $NMIPending = False

  interupt(&H0FFFA)
  SR = BSet(sr, 2)                                                     ' disable the IRQ

End

Public Sub IRQ()

  $IRQPending = False
  If BTst(sr, 2) Then Return                          ' Ignore this if the irq is disabled

  interupt(&h0FFFE)
  SR = BSet(sr, 2)                                             ' Disable the IRQ, restored upon irq return

End

Fast Unsafe Public Sub BRK()

  sr = BSet(sr, 4)
  interupt(&H0FFFE)
  SR = BSet(sr, 2)                                                     ' disable the IRQ

End

Fast Unsafe Public Sub SetSR(reg As Byte)

  If reg = 0 Then sr = BSet(sr, 1) Else sr = BClr(sr, 1)       ' correctly set the zero flag
  If BTst(reg, 7) Then sr = BSet(sr, 7) Else sr = BClr(sr, 7)  ' correctly set the negative flag

End

Fast Unsafe Public Sub ShiftRight()

  If BTst(Databus, 0) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  Dim newvalue As Byte = (Databus Shr 1)
  SetSR(newvalue)
  DataBus = newvalue

End

Fast Unsafe Public Sub ShiftLeft()

  If BTst(Databus, 7) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  Dim newvalue As Byte = (DataBus Shl 1)
  SetSR(newvalue)
  DataBus = newvalue

End

Fast Unsafe Public Sub RotateRight()

  Dim newvalue As Byte = (DataBus Shr 1)

  If BTst(sr, 0) Then newvalue = BSet(newvalue, 7)
  If BTst(DataBus, 0) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  SetSR(newvalue)
  dataBus = newvalue

End

Fast Unsafe Public Sub RotateLeft()

  Dim newvalue As Byte = (DataBus Shl 1)

  If BTst(sr, 0) Then newvalue = BSet(newvalue, 0)
  If BTst(DataBus, 7) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  SetSR(newvalue)
  dataBus = newvalue

End

Fast Unsafe Public Sub AndAc()

  ac = (ac And DataBus)
  SetSR(ac)

End

Fast Unsafe Public Sub AdcDecMode()

  Dim carry As Integer = IIf(BTst(sr, 0), 1, 0)

  Dim dac As Integer = (AC And &h0F) + (((AC And &hf0) Shr 4) * 10)
  Dim ddc As Integer = (databus And &h0F) + (((databus And &hf0) Shr 4) * 10)

  dac += ddc + carry
  If dac > 99 Then sr = BSet(sr, 0) Else sr = BClr(sr, 0) ' set the carry bit
  SetBcd(dac)

End

Fast Unsafe Public Sub SbcDecMode()

  Dim carry As Integer = IIf(BTst(sr, 0), 1, 0)

  Dim dac As Integer = (AC And &h0F) + (((AC And &hf0) Shr 4) * 10)
  Dim ddc As Integer = (databus And &h0F) + (((databus And &hf0) Shr 4) * 10)

  dac -= ddc - carry
  If dac < -1 Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)  ' set the carry bit If above - 1
  If dac < 0 Then
    dac = 100 - Abs(dac)
    sr = BSet(sr, 7)
  Endif
  SetBcd(Dac)

End

Fast Unsafe Sub SetBcd(Value As Integer) ' ignore the extra 100's value

  Dim ones As Integer = Value Mod 10
  Dim tens As Integer = (value \ 10) Mod 10

  ac = (tens Shl 4) Or ones

End

Fast Unsafe Public Sub AdcAc()

  If BTst(SR, 3) Then
    AdcDecMode()
    Return
  Endif

  Dim addone As Integer = IIf(BTst(sr, 0), 1, 0)
  Dim tmp As Integer
  Dim result As Byte
  Dim v As Integer
  Dim tac, tdb As Integer

  tac = (0 Or ac)
  tdb = (0 Or Databus)

  tmp = tac + tdb + addone
  'Print "Result="; tmp, "AC="; ac, "Databus="; Databus, "Carry = "; addone
  If BTst(tmp, 8) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)           ' set the carry bit
  result = (tmp And &h00ff)                                             ' set the value
  If BTst(result, 7) Then sr = BSet(sr, 7) Else sr = BClr(sr, 7)        ' Set the negative
  If result = 0 Then sr = BSet(sr, 1) Else sr = BClr(sr, 1)             ' set the zero flag
  ' Print (ac Xor result), (databus Xor result), ((ac Xor result) And (databus Xor result))
  'Print (((ac Xor result) And (databus Xor result)) And &h080)
  'v = !!((a ^ result) & (val ^ result) & 0x80U);
  v = (((ac Xor result) And (databus Xor result)) And &h080)
  If v <> 0 Then sr = BSet(sr, 6) Else sr = BClr(sr, 6)
  'Print "Overflow= "; BTst(sr, 6)
  ac = result

End

Fast Unsafe Public Sub SbcAc()

  If BTst(SR, 3) Then
    SbcDecMode()
    Return
  Endif

  Dim tmp As Byte = (DataBus Xor &h0FF)

  DataBus = tmp
  AdcAc()

End

Fast Unsafe Public Sub EorAc()

  ac = (ac Xor databus)
  SetSR(ac)

End

Fast Unsafe Public Sub OraAc()

  ac = (ac Or databus)
  SetSR(ac)

End


Fast Unsafe Public Sub Peek(Addr As Long) As Byte

  Dim dev As Object

  Try dev = GetDevice(Addr)
  If Error Then Return &hFF
  Return dev[Addr]

End

Fast Unsafe Public Sub Poke(addr As Long, value As Integer)

  Dim dev As Object

  dev = GetDevice(Addr)
  dev[Addr] = CByte(value)

End

Fast Unsafe Private Function SpeedScaler_Read() As Long

  Return $SpeedScaler

End

Fast Unsafe Private Sub SpeedScaler_Write(Value As Long)

  $SpeedScaler = value

End

Fast Unsafe Public Sub MyDevice_halt(Reason As String)

  Halt()
  Print Reason

End

Fast Unsafe Public Sub MyDevice_IRQ()

  $IRQPending = True
  $InteruptPending = True

End

Fast Unsafe Public Sub MyDevice_NMI()

  $NMIPending = True
  $InteruptPending = True

End

Fast Unsafe Public Sub MyDevice_Reset()

  $ResetPending = True
  $InteruptPending = True

End


Fast Unsafe Private Function Profiling_Read() As Boolean

  Return $Profiling

End

Fast Unsafe Private Sub Profiling_Write(Value As Boolean)

  If Value = True Then
    InstProfile = New Profiler(Me)
    $Profiling = True
  Else
    $Profiling = False
  Endif

End

Fast Unsafe Private Function ProfileInfo_Read() As String[]

  If InstProfile Then
    Return InstProfile.report()
  Endif

End
