============================================================================





                                    MOS

                               MICROCOMPUTERS





                              KIM-1 USER MANUAL



============================================================================

                                               Publications Number 6500-15B

















                                   KIM-1


                            MICROCOMPUTER MODULE


                                USER MANUAL



                                AUGUST 1976


The information in this manual has been reviewed and is believed to be entirely
reliable. However, no responsibility is assumed for inaccuracies. The material
in this manual is for informational purposes only and is subject to change
without notice.

                               Second Edition
                      (C) MOS TECHNOLOGY, INC. 1976
                           "All Rights Reserved"







                            MOS TECHNOLOGY, INC
                            9S0 Rittenhouse Road
                            Norristown, PA 19401



============================================================================

                             TABLE OF CONTENTS



CHAPTER I   YOUR KIM-1 MICROCOMPUTER MODULE                           1

CHAPTER 2   GETTING STARTED                                           5

               2.1  Parts Complement                                  5
               2.2  A Few Words of Caution!                           6
               2.3  First Steps                                       6
               2.4  Let's Try a Simple Problem                        9
               2.5  Adding an Audio Tape Unit                         12
               2.6  Adding a Teleprinter                              17

CHAPTER 3   THE KIM-1 SYSTEM                                          21

               3.1  KIM-1 System Description                          21
               3.2  KIM-1 Memory Allocation                           34
               3.3  KIM-1 Operating Programs                          40

CHAPTER 4   OPERATING THE KIM-1 SYSTEM                                43

               4.1  Using the Keyboard and Display                    43
               4.2  Using the Audio Tape Unit                         47
               4.3  Using the Teleprinter                             50

CHAPTER 5   LET'S TRY A REAL APPLICATION                              55

               5.1  Defining the Interface                            55
               5.2  Writing the Program                               58
               5.3  Entering the Program                              65
               5.4  Executing the Program                             66
               5.5  Program Debugging and Modification                67



                                    ii

============================================================================

CHAPTER 6   EXPANDING YOUR SYSTEM                                     71

               6.1  Memory and I/O Expansion                          71
               6.2  Interrupt Vector Management                       75

CHAPTER 7   WARRANTY AND SERVICE                                      79

               7.1  In-Warranty Service                               79
               7.2  Out-of-Warranty Service                           80
               7.3  Policy on Changes                                 80
               7.4  Shipping Instructions                             80



                                   iii

============================================================================

                             LIST OF FIGURES


CHAPTER 2      2-1  KIM MODULE                                        7
               2-2  Power Supply Connections                          8
               2-3  Audio Tape Unit Connections                       13
               2-4  TTY Connections                                   18


CHAPTER 3      3-1  KIM-1 Block Diagram                               24
               3-2  Detailed Block Diagram                            25
               3-3  Control and Timing                                26
               3-4  1K x 8 RAM Memory                                 27
               3-5  Keyboard and Display                              28
               3-6  Keyboard Detail                                   29
               3-7  TTY Interface                                     30
               3-8  Audio Tape Interface                              31
               3-9  Application Connector                             32
               3-10 Expansion Connector                               33
               3-11 Memory Block Diagram                              37
               3-12 Memory Map                                        38
               3-13 Special Memory Addresses                          39
               3-14 Flow Chart                                        41


CHAPTER 5      5-1  Speaker Application                               57
               5-2  Assembly Language Listing                         60
               5-3  Square Wave Output                                62
               5-4  Machine Language Code Table                       63
               5-5  Key Sequence: Enter Program                       65


CHAPTER6       6-1  4K Expansion                                      73
               6-2  65K Expansion                                     74
               6-3  Vector Selection                                  78



                                   iv

============================================================================

               LIST OF APPENDICES



APPENDIX A          KIM-1 Parts List                                  A-1

APPENDIX B          KIM-1 Parts Location                              B-1

APPENDIX C          In Case of Trouble                                C-1

APPENDIX D          Suggested Power Supply                            D-1

APPENDIX E          Audio Tape Format                                 E-1

APPENDIX F          Paper Tape Format                                 F-1

APPENDIX G          6502 Characteristics                              G-1

APPENDIX H          6530 Characteristics                              H-1

APPENDIX I          KIM-1 Program Listings                            I-1



                                    v

============================================================================


                                CHAPTER 1


                    YOUR KIM-1 MICROCOMPUTER MODULE



     Congratulations and welcome to the exciting new world of micro-
computers!  As the owner of a KIM-1 Microcomputer Module, you now have at
your disposal a completely operational, fully tested, and very capable
digital computer which incorporates the latest in microprocessor tech-
nology offered by MOS Technology, Inc.  By selecting the KIM-1 module,
you have eliminated all of the problems of constructing and debugging a
microcomputer system.  Your time is now available for learning the opera-
tion of the system and beginning immediately to apply it to your specific
areas of interest.  In fact, if you will follow a few simple procedures
outlined in this manual, you should be able to achieve initial operation
of your KIM-1 module within a few minutes after unpacking the shipping
container.

      Your KIM-1 module has been designed to provide you with a choice of
operating features.  You may choose to operate the system using only the
keyboard and display included as part of the module.  Next, you may add
a low cost audio cassette tape recorder to allow storage and retrieval
of your programs.  Also, you may add a serial interfaced teleprinter to
the system to provide keyboard commands, hard-copy printing, and paper
tape read or punch capability.


                                    1

============================================================================

      At the heart of your KIM-1 system is an MCS 6502 Microprocessor
Array operating in conjunction with two MCS 6530 arrays.  Each MCS 6530
provides a total of 1024 bytes of Read-only Memory (ROM) , 64 bytes of
Random Access Memory (RAM), 15 Input/Output pins, and an Interval Timer.
Stored permanently in the ROM's of the MCS 6530 arrays are the monitor
and executive programs devised by MOS Technology, Inc. to control the
various operating modes of the KIM-1 system.

      The KIM-1 system is intended to provide you with a capable micro-
computer for use in your  real-world" application.  Accordingly, the
system includes a full 1024 bytes of RAM to provide data and program
storage for your application program.  In addition, you are provided
with 15 bidirectional input/output pins to allow interface control of
your specific application.  Finally, one of the interval timers included
in the system is available for generation of time base signals required
by your application.

      Your KIM-1 system comes to you complete with all components mounted
and tested as a system.  You need not worry about timing signals (we've
included a 1MHz crystal oscillator on the module), interface logic or
levels between system components, or interface circuitry to peripheral
devices.  In fact, you need only apply the indicated power supply voltages
to the designated pins to achieve full operation of your KIM-1 system.

      We recommend that you read all of this manual before applying power
to or attempting to operate your KIM-1 module.  In the order presented,
you will find:

          Chapter 2 - "hints and kinks" to help you achieve initial
                      system operation

          Chapter 3 - a more detailed description of the KIM-1 system
                      hardware and software

          Chapter 4 - operating procedures for all system modes

          Chapter 5 - an example of a typical application program
                      using all of the features of the KIM-1 system.


                                    2

============================================================================

      At some future time, you may find it desirable to expand the KIM-1
system to incorporate more memory, different types of memory, or addi-
tional input/output capability.  Again, we have tried to make system
expansion as simple as possible with all required interface signals
brought out to a special connector on the module.  Watch for:

          Chapter 6 - a guide to system expansion for increasing
                      both memory and input/output capability

      Despite our best efforts to provide you with a fully operable
and reliable system, you might encounter some difficulties with your
KIM-1 module.  If so, refer to:

          Chapter 7 - some guidance on warranty and service
                      procedures for your KIM-1 module

      Following the basic text of this manual, you will find a series of
Appendices intended to provide you with detailed information on certain
specialized subjects of interest to you in understanding the operation
of the KIM-1 system.

      Lastly, since this manual cannot presume to provide all of the
technical information on the hardware or programming aspects of the
MCS 6502 microprocessor array, we are including with your KIM-1 system
two additional manuals for your reference.  The Hardware Manual defines
the various elements of the system, their electrical and interface
characteristics, and the basic system architecture and timing.  The
Programming Manual provides the detailed information required to write
effective programs using the MCS 6502 instruction program set.

      So much for introductory comments!  Now lets get started and see
if we can get your KIM-1 Microcomputer Module doing some real work for you.
                                    3

============================================================================

                                  BLANK


                                    4

============================================================================

                                CHAPTER 2

                             GETTING STARTED


      This chapter is intended to guide you through the first important
steps in achieving initial operation of your KIM-1 Microcomputer Module.
We will ask you to perform certain operations without explanation at this
time as to why they are being done.  In later sections of this manual,
full explanations will be offered for every operating procedure.


2.1   PARTS COMPLEMENT

      After unpacking the shipping container for your KIM-1, you should
have located the following items:

          3 Books -   KIM-1 Users Manual
                      Hardware Manual
                      Programming Manual

          1 Programming Card

          1 System Schematic

          1 KIM-1 Module

          1 Connector (Already mounted on the Module)

          1 Hardware Packet

          1 Warranty Card

      You may wish to save the shipping container and packing material
should you need to return your KIM-1 module to us at some future date.


                                    5

============================================================================

2.2  A FEW WORDS OF CAUTION


                                 WARNING
                                 -------

Your KIM-1 module includes a number of MOS integrated circuits.  All such
circuits include protective devices to prevent damage resulting from
inadvertent application of high voltage potentials to the pins of the
device.  However, normal precautions should be taken to prevent the appli-
cation of high voltage static discharges to the pins of an MOS device.
Immediately before removal of the packing material from your KIM-1 module,
you should develop the following precautionary habits:

      1.  Discharge any static charge build up on your body by touching a
          ground connection before touching any part of your KIM-1 module.
          (This precaution is especially important if you are working in a
          carpeted area)

      2.  Be certain that soldering irons or test equipment used on the
          KIM-1 module are properly grounded and not the source of
          dangerously high voltage levels.

      On a different subject, after unpacking your KIM-1 module, you will
note the presence of a potentiometer.  This adjustment has been set at
the factory to insure correct operation of the audio cassette interface
circuits.  It should never be necessary for you to change the position of
this potentiometer.


2.3   FIRST STEPS

      After unpacking the KIM-1 module, locate the small hardware packet
and install the rubber pads provided.  The rubber pads are located at the
bottom of the module (see attached sketch) and act both to lift the card
off your work surface and to provide mechanical support for the module
while you depress keys.


                                    6

============================================================================

      Place the module such that the keyboard is to your lower right and
observe that two connector locations extend from the module to your left.
The connector area on the lower left is referred to as the Application
connector (A).  You will note that a 44 pin board edge connector is
already installed at this location.  The connector area to the upper
left is for use by you for future system expansion and is referred to
as the Expansion connector (E).

 --------------------------               ---------------------------
 |                        |               |                         |
 |                        ----         ----                         |
 |  ----            ----     |         |                            |
 |  |--|            |--|     |         |                            |
 |  |--|            |--|     |         |                            |
 |  ----            ----     |         |                            |
 |                           | <- E -> |                            |
 |                           |         |                            |
 |                           |         |                            |
 |                           |         |                            |
 |                           |         |                            |
 |                           |         |                            |
 |                        ----         ----              -+++--+-   |
 |                        |               |              ||||||||   |
 |   ----           ----  |               |              -+++--+-   |
 |   |--|           |--|  |               |             ----------  |
 |   |--|           |--|  |               |             |        |  |
 |   ----           ----  |               |             |------  |  |
 |                        |               |             |------  |  |
 |                        ----         ----             |--------|  |
 |                           |         |                |--------|  |
 |                           |         |                |--------|  |
 |                           |         |                |--------|  |
 |                           |         |                |--------|  |
 |                           |         |                |--------|  |
 |                           | <- A -> |                |--------|  |
 |   ----           ----     |         |                |--------|  |
 |   |--|           |--|     |         |                |--------|  |
 |   |--|           |--|     |         |                |--------|  |
 |   ----           ----     |         |                ----------  |
 |                        ----         ----                         |
 |                        |               |                         |
 --------------------------               ---------------------------

          BOTTOM                                     TOP
           VIEW                                      VIEW


                              KIM-1 Module
                               FIGURE 2.1


                                    6

============================================================================


7
      Remove the (A) connector from the module and connect the pins as
shown in the sketch.



                                +5 ----------
 ------                          --+        |
 |  A +<-------------------------+ |  +5V   |
 |    |                          --+        |
 |    |                            |  (~5%) |
 |    |                          --+        |
 |    |                 ---------+ |  1.2 A |
 |    |                 |        --+        |
 |    |                 |          ----------
 |    |                 |
 |    |                 |       +12----------
 |    |                 |        --+        |
 |  N +<----------------+--------+ |  +12V  |
 |    |                 |        --+        |
 |    |                 |          |  (~5%) |
 |    |                 |        --+        |
 |  1 +<--+-------------O--------+ |  0.1 A |
 |    |   |             |        --+        |
 |  K +<---             |          ----------
 ------                -+-
                        -


          Power Supply Connections
                  FIGURE 2.2


      Reinstall the (A) connector making certain that the orientation is
correct.

          Note 1: The +12 volt power supply is required only if you
                  will be using an audio cassette recorder in your system.

          Note 2: The jumper from pin A-K to Vss (Pin A-1) is essential
                  for system operation.  If you expand your system later,
                  this jumper will be removed and we'll tell you what to
                  do to pin A-K.

          Note 3. If you don't have the proper power supplies already
                  available, you may wish to construct the low cost
                  version shown with schematic and parts list in
                  Appendix D.  In any event, your power supply must
                  be regulated to insure correct system operation and
                  must be capable of supplying the required current
                  levels indicated in the sketch.


                                    8

============================================================================

      Now, recheck your connections, turn on your power supplies, and
depress [RS] (reset).  You should see the LED display digits light
as your first check that the system is operational.  If not, recheck
your hookup or refer to Appendix C (In Case of Trouble).


2.4   LETS TRY A SIMPLE PROGRAM

      Assuming that you have completed successfully all of the steps thus
far, a simple program now can be tried to demonstrate the operation of
the system and increase your confidence that everything works properly.
We'll be using only the keyboard and display on the module for this
example.  (In the next two sections we'll worry about the teleprinter
and the audio cassette).

      For our first example, we will add two 8 bit binary numbers together
and display the result.  We presume that you are familiar with the hex-
adecimal representation of numbers and the general rules for binary arith-
metic.

      First check and be sure that the slide switch in the upper right
corner of the keyboard is pushed to the left (SST Mode is OFF).  Now
proceed with the following key sequence:

      Press Keys          See On Display    Step #
      ----------          --------------    ------

      [AD]                    xxxx xx         1
      [0]  [0] [0] [2]        0002 xx         2
      [DA]                    0002 xx         3
               [1] [8]        0002 18         4
      [+]      [A] [5]        0003 A5         5
      [+]      [0] [0]        0004 00         6
      [+]      [6] [5]        0005 65         7
      [+]      [0] [1]        0006 01         8
      [+]      [8] [5]        0007 85         9
      [+]      [F] [A]        0008 FA         10
      [+]      [A] [9]        0009 A9         11
      [+]      [0] [0]        000A 00         12
      [+]      [8] [5]        000B 85         13
      [+]      [F] [B]        000C FB         14
      [+]      [4] [C]        000D 4C         15
      [+]      [4] [F]        000E 4F         16
      [+]      [1] [C]        000F 1C         17


                                    9

============================================================================

      What you have just done is entered a program and stored it in the
RAM at locations 0002 through 000F.  You should have noticed the purpose
of several special keys on your keyboard:

              [AD] -  selects the address entry mode

              [DA] -  selects the data entry mode

              [+]  -  increments the address without
                      changing the entry mode

       [0] to [F]  -  16 entry keys defining the hex
                      code for address or data entry

      You've noticed as well that your display contains 6 digits.  The
four on the left are used to display the hex code for an address.  The
two on the right show the hex code for the data stored at the address
shown.  Therefore, when you pressed  [AD]  (step 1) and [0] [0] [0] [2]
(step 2), you defined the address entry mode, selected the address 0002,
and displayed the address 0002 in the four left-most display digits.
Incidentally, when we show an "x" in the display chart, we mean that we
don't know what will be displayed and we "don't care."

      Next you pressed  [DA]  (step 3) followed by [1] [8] (step 4).  Here,
you have defined the data entry mode and entered the value 18 to be
stored at your selected address 0002.  Of course, the 18 then was dis-
played in the two right-most digits of your display.

      You remained in the data entry mode but began to press [+] followed
by a two digit number (steps 5 to 17).  Note that each depression of the
[+] key caused the address displayed to increase by one.  The hex keys
following the [+] key continued to enter the data field of the display.
This procedure is merely a convenience when a number of successive address
locations are to be filled.

     If you made any mistakes in pressing the keys, you should have noticed
that correcting an error is simply a matter of reentering the data until
the correct numbers show on the display.


                                   10

============================================================================

      The program you have entered is a simple loop to add two 8 bit
binary numbers together and present the result on the display.  For a
programmer, the listing of the program entered might appear as follows:

              POINTL              = $FA
              POINTH              = $FB
              START               = $1C4F
              0000                VALl
              0001                VAL2
              0002    18          PROG    CLC
              0003    A5 00               LDA VALl
              0005    65 01               ADC VAL2
              0007    85 FA               STA POINTL
              0009    A9 00               LDA #00
              000B    85 FB               STA POINTH
              000D    4C 4F 1C            JMP START

      Stated in simple terms, the program will clear the carry flag (CLC)
load VALl into the accumulator (LDA VALl), add with carry VAL2 to the
accumulator (ADC VAL2), and store the result in a location POINTL (STA
POINTL).  A zero value is stored in a location POINTH (LDA #00 and STA
POINTH) and the program jumps to a point labeled START (JMP START).
This pre-stored program will cause the display to be activated and will
cause the address field of your display to show the numbers stored in
locations POINTH and POINTL.  Note that the result of the addition has
already been stored in location POINTL.

      The hex codes appearing next to the address field of the listing are
exactly the numbers you entered to store the program.  We refer to these
as machine language codes.  For example, 4C is the hex code for the JMP
instruction of the microprocessor.  The next two bytes of the program
define 1C4F (START) as the jump address.

      As yet, you are not able to run the program because you have not yet
entered the two variables (VALl and VAL2).  Lets try an actual example:

      Press Keys          See On Display    Step #
      ----------          --------------    ------

      [AD]                    000F 1C         17A
      [0]  [0] [F] [1]        00F1 xx         17B
      [DA]     [0] [0]        00F1 00         18
      [AD]                    00F1 00         19
      [0]  [0] [0] [0]        0000 xx         20
      [DA]                    0000 02         21
      [+]      [0] [3]        0001 03         22
      [+]          [GO]       0002 18         23


                                   11

============================================================================

      Steps 17A, 17B, and 18 insure that the binary arithmetic mode is
selected.
      Steps 19 to 21 store the hex value 02 in location 0000 (VAL1).  Step
22 stores the hex value 03 in location 0001 (VAL2).  Now we are ready to
run the program.  In step 23, the [GO] key causes the program to execute
and the result, 05, appears in the right two digits of the address display.
Although the problem appears trivial, it illustrates the basic principles
of entering and executing any program as well as providing a fairly high
assurance level that your KIM-1 module is operating properly.

      You should try one more example using your stored program.  Repeat
steps 17A to 23 but substitute the value FF for VALl and VAL2 at locations
0000 and 0001.  Now when you press the  GO  key, your display should read:

                      00FE xx

      The answer is correct because:

                      FF = 1111 1111
                  +   FF = 1111 1111
                      --   ---------
                      FE   1111 1110

      Try some more examples if you wish and then let's move on to the rest
of the system.


2.5   ADDING A TAPE RECORDER

      In the previous section, you entered and executed a program.  If you
turn off the power supplies to the system, your program is lost since the
memory into which you stored your program is volatile.  If you require
the same program again, you would have to repower the system and reenter
the program as in the previous example.

      The KIM-1 system is designed to work with an audio cassette tape
recorder/player to provide you with a medium for permanent storage of your
programs or data.  The cassette with recorded data may be reread by the
system as often as you wish.  In this section, you will connect the audio
cassette unit to the system and verify its operation.


                                   12

============================================================================

      The recording technique used by the KIM-1 system and the interface
circuits provided have been selected to insure trouble-free operation
with virtually any type and any quality level audio cassette unit.  (We
have demonstrated correct operation with a tape unit purchased for less
than $20.00 from a local discount outlet).  In addition, tapes recorded
on one unit may be played back to the system on a different unit if
desired.  We recommend, of course, that you make use of the best equip-
ment and best quality tapes you have available.

      In selecting a tape unit for use with your KIM-1 system, you should
verify that it comes equipped with the following features:

          1.  An earphone jack to provide a source of recorded
              tape data to the KIM-1 system.

          2.  A microphone jack to allow recording of data from
              the KIM-1 system on the tape.

          3.  Standard controls for Play, Record, Rewind, and Stop.

      Note:  You should avoid certain miniaturized tape equipment intended
for dictating applications where the microphone and speaker are enclosed
within the unit and no connections are provided to external jacks.  If
such equipment is used, you will have to make internal modifications to
reach the desired connection points.

      To connect your tape unit to the KIM-1 module, turn off the power
supplies and remove the connector (A) from the module.  Add the wires
shown in the sketch:


                                                 ------------+-------------
                                                 |           |            |
  (A)                                            |    MIC    |            |
 -----                                           |   -----   |            |
 |   |            AUDIO DATA OUT (LO)            |   |   |   |            |
 | A +---------->--------------------------------+---+-o |   |            |
 |   |                                           |   |   |   |            |
 |   |                                           |   o----   |            |
 |   |                                           |  /        |            |
 |   |                                           | / REMOTE  |            |
 |   |                                           |/  -----   |            |
 |   |            VSS                            /   |   |   |    TAPE    |
 | 1 +----------+-------------------------------/|   | o |   |    UNIT    |
 |   |          |                                |   |   |   |            |
 |   |         -+-                               |   -----   |            |
 |   |          -                                |           |            |
 |   |                                           |  EARPHONE |            |
 |   |                                           |   -----   |            |
 |   |            AUDIO DATA IN                  |   |   |   |            |
 | L +<------------------------------------------+---+-o |   |            |
 |   |                                           |   |   |   |            |
 |   |                                           |   -----   |            |
 |   |                                           |           |            |
 |   |                                           ------------+            |
 |   |                                                       |            |
 | P +----------> AUDIO DATA OUT (HI)                        |            |
 |   |                                                       |            |
 -----                                                       |            |
                                                             --------------

                      Audio Tape Unit Connections
                              FIGURE 2.3


                                   13

============================================================================

      Keep the leads as short as possible and avoid running the leads near
sources of electrical interference.  The connections shown are for typical,
portable type units.  The Audio Data Out (LO) signal has a level of approx-
imately 15 mv. (peak) at pin M.  Should you desire to use more expensive
and elaborate audio tape equipment, you may prefer to connect the high
level (1 volt peak) audio signal available at pin P to the "LINE" input
of your equipment.
      Return the connector (A) to its correct position on the KIM-1 module
and turn on the power supplies.  To verify the operation of your audio
cassette equipment, try the following procedures:

          1.  Reenter the sample program following the procedures
              outlined in the previous section (2.4).  Try the
              sample problem again to be sure the system is
              working correctly.

          2.  Install a cassette in your tape equipment and REWIND
              to the limit position.

          3.  Define the starting and ending address of the program to
              be stored and assign an identification number (ID) to
              the program.

      Press Keys          See On Display    Step #
      ----------          --------------    ------

      [AD]                    xxxx xx         1
      [0]  [0] [F] [1]        00F1 xx         2
      [DA]     [0] [0]        00F1 00         3
      [AD]                    00F1 00         4
      [1]  [7] [F] [5]        17F5 xx         5
      [DA]     [0] [0]        17F5 00         6
      [+]      [0] [0]        17F6 00         7
      [+]      [1] [0]        17F7 10         8
      [+]      [0] [0]        17F8 00         9
      [+]      [0] [1]        17F9 01         10
      [AD]                    17F9 01         11
      [1]  [8] [0] [0]        1800 xx         12

      You will recall that the program we wish to store on tape was loaded
into locations 0000 to 000F of the memory.  Therefore, we define a start-
ing address for recording as 0000 and store this in locations 17F5 and
17F6 (Steps 4 to 7).  We define an ending address for recording as one
more than the last step of our program and stored the value 0010
(= 000F + 1) in locations 17F7 and 17F8 (Steps 8,9).  Finally we pick
an arbitrary ID as 01 and store this value at location 17F9 (Step 10).

Note that before we use the audio cassette unit for recording
or playing back, we must put 00 in location 00F1 (Steps 1,2 and 3).


                                   14

============================================================================

      The starting address of the tape recording program is 1800.  In Steps
11 and 12 we set this address value into the system.  If we were to press
[GO], the system would proceed to load data on to the magnetic tape.  But
first, we'd better start the tape!

          4.  Select the Record/Play mode of the tape recorder.  Wait a
              few seconds for the tape to start moving and now:

                      Press [GO]

          5.  The display will go dark for a short time and then will
              relight showing:

                      0000 xx

          6.  As soon as the display relights, the recording is finished
              and you should STOP the tape recorder.

      Now, you should verify that the recording has taken place correctly.
This can be proven by reading the tape you have just recorded.  Proceed
as follows:

          1.  Rewind the tape cassette to its starting position.


          2.  Turn off the system power supplies and then later,
              turn them back on.

      This has the effect of destroying your previously stored program
which you already have recorded on tape.

          3.  Prepare the system for reading the tape as follows:

      Press Keys          See On Display    Step #
      ----------          --------------    ------

      [RS]
      [AD]                    xxxx xx         1
      [0]  [0] [F] [1]        00F1 xx         2
      [DA]     [0] [0]        00F1 00         3
      [AD]                    00F1 00         4
      [1]  [7] [F] [9]        17F9 xx         5
      [DA]                    17F9 xx         6
               [0] [1]        17F9 01         7
      [AD]                    17F9 01         8
      [1]  [8] [7] [3]        1873 xx         9
      [GO]                    (Dark)          10


                                   15

============================================================================

      The KIM-1 system is now looking for tape input data with the ID
label 01.  Recall that this is the same ID label we assigned when we
recorded the program.

              4.  If your tape unit has a volume control, set the control
                  at approximately the half way point.

              5.  If your tape unit has a tone control, set the control
                  for maximum treble.

              6.  Now, turn on the tape using the PLAY mode.  The tape
                  will move forward and the system will accept the recorded
                  data.  As soon as the data record (ID=01) has been read,
                  the display should relight showing:

                              0000 xx

      You may now stop the tape unit.  If the display relights and shows;
                              FFFF xx

this means that the selected record has been located and read but that an
error has occurred during the reading of the data.  In this case, press
the [RS] key and repeat the read tape procedures from the beginning.  If
the FFFF still shows on the display, repeat the entire recording and play-
back procedures checking each step carefully.  If the problem persists,
refer to Appendix C, (In Case of Trouble).

      If the tape continues to run and the display does not relight, this
means that the system has been unsuccessful in reading any data back from
the tape.  In this case, repeat the entire recording and playback proce-
dures checking each step carefully.  If the problem persists, refer to
Appendix C, (In Case of Trouble).

              7.  Assuming that you have read the tape successfully, you
                  now may verify that the program has been restored to
                  memory by trying a sample problem.  (02 + 03 = 05)

          NOTE:   The KIM-1 interface circuits for the audio tape system
                  are designed so that you do not require special test
                  equipment to set up correct operating levels.  If you
                  have followed the procedures indicated, the tape system
                  should work without the need of any adjustments by you.


                                   16

============================================================================

2.6   ADDING A TELEPRINTER

      If you have access to a serial teleprinter, you may add such a unit
to the KIM-1 system with very little effort.  One of the more commonly
available units of this type is the Teletype Model 33ASR which we will
use for the purposes of illustration in this section.  However, if you
have available different equipment, you may use the information presented
here as a guide to connecting your specific unit.  In any case, we recom-
mend you follow the directions offered by the equipment manufacturer in
his instruction manual to effect the desired wiring and connection options.

      The KIM-1 provides for a 4 wire interface to the TTY.  Specifically,
the "20 mA loop" configuration should be used and you should check that
your TTY has been wired for this configuration.  If not, you may easily
change from "60 mA loop" to "20 mA loop" configurations following the
manufacturers directions.  The KIM-1 has been designed to work properly
only with a teleprinter operating in full duplex mode.  Check the
literature supplied with your teleprinter if you are unsure if your
unit is properly configured.  You are not restricted to units with specific
bit rates (10 CPS for TTY) since the KIM-1 system automatically adjusts
for a wide variety of data rates (10CPS, 15CPS, 30CPS, etc.).

      To connect the TTY to the system, proceed as follows:

          1.  Turn off system power and remove connector (A) from
              the module.

          2.  Add the wires shown in the sketch to connector (A) and
              to the appropriate connector on the TTY unit.


                                   17

============================================================================

                    -----
                        |
             +5V        |
              O        (A)
              |       -----                    ----+---+-----------------
              | ----- |   |S  PRINTER RETURN   |   |   |    ---------   |
              +-+   +-+-o |--------------------+-o | o +----|----   |   |
              | ----- |   |              ----- | 7 | 8 |    |   \   |   |
        |\    |  150  |   |            20 mA | |   |   |    |   /   |   |
 TTY    | \   |       |   |U  PRINTER    <---- | 6 | 7 |    |   \   |   |
 DATA --|  >--+-------+-o |--------------------+-o | o +----|----   |   |
 OUT    | /   |       |   |                    |   |   |    ---------   |
        |/    |       |   |                    |   |   | TTY ASR 33     |
              | ----- |   |R  KEYBOARD RETURN  |   |   |    ---------   |
              --+   +-+-o |--------------------+-o | o +----|---|   |   |
                ----- |   |             ------ | 3 | 5 |    |   \   |   |
          /|     150  |   |            20 mA | |   |   |    |    \  |   |
 TTY     / |          |   |T  KEYBOARD   <---- | 4 | 6 |    |     \ |   |
 DATA --<  |----------+-o |--------------------+-o | o +----|---|   |   |
 IN      \ |          |   |                    |   |   |    ---------   |
          \|          |   |                    ----+---+-----------------
                      |21 |    OR
                      | o |<---- <---|
                      |   |    |     \
                      |   |    |      \ KB
                      | V |    |  TTY  \
                      | o |<---- <---|
                      |   |  ^     ^
                      --+--  |     |
                        |    |     |
 <-------- KIM -------->|    |     ---EXTERNAL SWITCH TO SELECT
                        |    |        EITHER MODE
                    -----    |
                             |
                             |
                             ---JUMPER FOR TTY OPERATION

                              TTY Connections
                                FIGURE 2.4


          3.  The jumper wire from A-21 to A-V is used to define for the
              KIM-1 system that a teleprinter will be used as the only
              input/display device for the system.  If you expect to use
              both TTY and the KIM-1 keyboard/display, you should install
              the switch shown instead of the jumper.  Now, the switch,
              when open, will allow use of the keyboard and display on
              the KIM-1 module and, when closed, will select the tele-
              printer as the input/display device.  (of course, you may
              use a clip-lead instead of the switch if you desire).

          4.  Be sure pins A-21 and A-V are connected.  Reinstall con-
              nector (A) and return power to the system.  Turn-on the TTY.

          5.  Press the [RS] key on the KIM-1 module then press
              the [RUB OUT] key on the TTY.  This step is most important
              since the KIM-1 system adjusts automatically to the
              bit rate of the serial teleprinter and requires this
              first key depression to establish this rate.


                                   18

============================================================================

      If everything is working properly you should immediately observe a
message being typed as follows:

              KIM

This is a prompting message telling you that the TTY is on-line and the
KIM-1 system is ready to accept commands from the TTY keyboard.
      Should the prompting message not be typed press the [RS] key on the
KIM-1 keyboard and then the [RUB OUT] key on the TTY.  If the "KIM" message
still is not typed, recheck all connections and the TTY itself and try
again.  If the problem persists, refer to Appendix C, (In Case of Trouble).

          6.  Assuming that the TTY is operable, you may now try a simple
              group of operations to verify correct system operation:

      Press Keys          See On Display    Step #
      ----------          --------------    ------

                              KIM
                              xxxx xx         1
      0002                    0002            2
      [SPACE]                 0002 xx         3
      18.                             18.     4
                              0003 xx         5
      A5.                             A5.     6
                              0004 xx         7
      [LF]                    0003 A5         8
      [RUB OUT]               KIM
                              xxxx xx         9

      Step 1 shows the "KIM" prompting message.  In Step 2, an address
(0002) is selected followed by a space key in Step 3.  The address cell
0002 together with the data stored at that location (xx) is printed.
Step 4 shows the "modify cell" operation using the [.] key and the hex
data keys preceding.  Step 5 shows the incrementing to the next address
cell (0003) after the [.] key.  Note that the modification of cell 0002
also occurs.  Steps 6 and 7 show the modification of data in cell 0003
and the incrementing to cell 0004.  Step 8 shows the action of the [LF] key
in backing up one cell to 0003 where we can see from the printout that
the correct data (A5) has been stored at that location.  Step 9 shows the
reaction to the [RUB OUT] key in resetting the system and producing a new
"KIM" prompting message.  Note, by the way, that in this example you have
repeated a portion of the program entry exactly as you did in Section 2.4
but this time using the TTY.


                                   19

============================================================================

      So much for now!  If all of the operations have occurred properly,
you may be certain that your TTY and KIM-1 module are working together
correctly.  We will describe in detail all of the other operations pos-
sible with the TTY in a later section of the manual.

      If you have reached this point without problems, you now have
completed all of the required system tests and may be confident that
the KIM-1 module and your peripheral units are all working correctly.
Our next task is to learn more about the KIM-1 system and its operating
programs.


                                   20

============================================================================

                               CHAPTER 3

                           THE KIM-1 SYSTEM


      Up to this point you have been engaged in bringing up your KIM-1
system and verifying its correct operation.  Now it's time to learn more
about the various parts of the KIM-1, how the parts work together as a
system, and how the operating programs control the various activities of
the system.  The diagrams included in this section together with your
full sized system schematic will be helpful in understanding the elements
of your KIM-1 module.


3.1   KIM-1 SYSTEM DESCRIPTION

      Figure 3-1 shows a complete block diagram of the KIM-1 system.  You
should note first the presence of the MCS 6502 Microprocessor Array which
acts as the central control element for the system.  This unit is an 8
bit microprocessor which communicates with other system elements on three
separate buses.  First, a 16 bit address bus permits the 6502 to address
directly up to 65,536 memory locations in the system.  Next, an 8 bit,
bidirectional data bus carries data from the 6502 array to any memory
location or from any memory location back to the 6502 array.  Lastly, a
control bus carries various timing and control signals between the 6502
array and other system elements.


                                   21

============================================================================

      Associated with the 6502 array is a 1 MHz crystal which operates with
an oscillator circuit contained on the 6502 array.  This crystal control-
led oscillator is the basic timing source from which all other system
timing signals are derived.  In particular, the o2 signal generated by
the 6502 array and used either alone, or gated with other control signals,
is used as the system time base by all other system elements.

      The 6502 microprocessor is structured to work in conjunction with
various types of memory.  In the KIM-1 system, all memory may be consid-
ered to be of the Read-only (ROM) or Read/Write (RAM) variety.  The ROM
portion of the memory provides permanent storage for the operating programs
essential to the control of the KIM-1 system.  You will note the inclusion
of two devices, labelled 6530-002 and 6530-003.  Each of these devices
include a 1024 byte (8 bits per byte) ROM with different portions of the
operating program stored permanently in each ROM.

      RAM type memory is available at three locations in the system.
Again, each of the 6530 arrays include 64 bytes of RAM primarily used for
temporary data storage in support of the operating program.  In addition,
a separate 1024 byte RAM is included in the KIM-1 system and provides
memory storage for user defined application programs and data.

      Input/output controls for the system also are included within the
6530 arrays.  Each 6530 array provides 15 I/O pins with the microprocessor
and operating program defining whether each pin is an input pin or output
pin, what data is to appear on the output pins, and reading the data appear
ing on input pins.  The I/O pins provided on the 6530-002 are dedicated to
interfacing with specific elements of the KIM-1 system including the key-
board, display, TTY interface circuit, and audio tape interface circuit.
The 15 I/O pins on the 6530-003 are brought to a connector and are avail-
able for the user to control a specific application.


                                   22

============================================================================

      Finally, each 6530 array includes an interval timer capable of count-
ing a specific number of system clocks to generate precise timing gates.
The exact time interval is preset under program control.  The interval
timer on the 6530-003 array is available for a user defined application
program and is not required by the operating programs.

      Figure 3-1 shows a major block labelled Control Logic.  Included
under this category are an address decoder used for generation of chip
select signals for the 6530 arrays and the static RAM.  Also included is
the logic required to debounce the keys for system reset (RS key) and pro-
gram stop (ST key).  Lastly, special logic is included to allow operation
of the system in a "single instruction" mode to facilitate program de-
bugging.

      Figure 3-1 shows the keyboard/display logic interfacing with the I/O
pins of the 6530-002.  Also shown are the interface circuits for trans-
mission of data to and reception of data from the TTY and audio tape units.

      Figure 3-2 shows the detailed interconnections between the MCS 6502
and the two NCS 6530 arrays.

      Figure 3-3 shows detailed logic and schematics for the control logic.

      Figure 3-4 shows a detailed schematic of the static RAM.

      Figure 3-5 and 3-6 show the detailed schematic of the keyboard and
display logic and circuits.

      Figure 3-7 details the schematic of the TTY interface circuits.

      Figure 3-8 details the schematic of the audio tape cassette interface
circuits.

      Figures 3-9 and 3-10 provide a summary of all signals available on
either the Application connector or the Expansion Connector.

      The fold-out system schematic shows all of the elements of the system
connected together and all signals appearing on the module connectors.

      You may refer to the Hardware Manual included with your KIM-1 module
for additional details on the operating characteristics of the 6502 and
6530 arrays as well as detailed information on system timing.


                                   23

============================================================================

 --------------        -----------------
 |            |        |               |
 |    6502    |<======>|    CONTROL    |
 |    MPU     |        |     LOGIC     |
 |            |        |               |
 --------------        -----------------
    ^   ^                ^
    H   H                H
    H   H                H
    H   H   ----------   H       ------------------
    H   H   |        |   H       |                |
    H   H   |        |   H       |                |
    H   #==>|        |<==#       |                |
    H   H   |        |   H       |    KEYBOARD    |
    H   H   |6530-002|   H       |      AND       |
    H   H   |        |   H       |    DISPLAY     |
    #===H==>|        |<==H===#==>|                |   REMOTE   |
    H   H   |        |   H   H   |                |<==========>|
    H   H   |        |   H   H   |                |  KEYBOARD  |
    H   H   ----------   H   H   ------------------            |
    H   H                H   H                                 |
  A H   H                H   H                                 |
  D H   H                H   H   ------------                  | A
  D H   H D              H   H   |          | TTY KEYBOARD     | P
  R H   H A              H P H   |          +----------------->| P
  E H   H T              H E H   |          |                  | L
  S H   H A            C H R H   |          | TTY KEYBOARD RTN | I
  S H   H              O H I H   |          +------------------+ C
    H   H B            N H P H   |    TTY   |                  | A
  B H   H U            T H H #==>| INTERFACE| TTY PTR          | T
  U H   H S            R H E H   |          |<-----------------+ I
  S H   H              O H R H   |          |                  | O
    H   H D            L H A H   |          | TTY PTR RTN      | N
  A H   H B              H L H   |          +------------------+
  B H   H 0            B H   H   |          |                  | C
  0 H   H              U H B H   ------------                  | O
    H   H -            D H U H                                 | N
  - H   H                H S H                                 | N
    H   H D              H   H                                 | E
  A H   H B              H   H   ------------                  | C
  B H   H 7              H   H   |          | AUDIO OUT (HI)   | T
  1 H   H                H   H   |          +----------------->| O
  5 H   H                H   H   |          |                  | R
    H   H                H   H   |AUDIO TAPE| AUDIO OUT (LO)   |
    H   H                H   #==>| INTERFACE+----------------->|
    H   H   ----------   H       |          |                  |
    H   H   |        |   H       |          | AUDIO IN         |
    H   H   |        |   H       |          |<-----------------+
    H   #==>|        |<==#       |          |                  |
    H   H   |        |   H       ------------                  |
    H   H   |6530-002|   H                                     |
    H   H   |        |   H  APPLICATION I/O BUS (15 I/O LINES) |
    #===H==>|        |<==H====================================>|
    H   H   |        |   H                                     |
    H   H   |        |   H
    H   H   ----------   H
    H   H                H       -----------------
    H   H                H       |               |
    #===H================H======>|               |
    H   H                H       |    1Kx8 RAM   |
    H   #================H======>|     MEMORY    |
    H   H                H       |               |
    H   H                #======>|               |
    H   H                H       |               |
    H   H                H       -----------------
    H   H                H
    v   v                v
 ----------------------------
      EXPANSION CONNECTOR


                          KIM-1 Block Diagram
                              FIGURE 3.1


                                   24

============================================================================


                           (see schematics)


                        Detailed Block Diagram
                              FIGURE 3.2


                                   25

============================================================================


                           (see schematics)


                          Control and Timing
                              FIGURE 3.3


                                   26

============================================================================


                           (see schematics)


                           1K x 8 RAM Memory
                              FIGURE 3.4


                                   27

============================================================================


                           (see schematics)


                         Keyboard and Display
                              FIGURE 3.5


                                   28

============================================================================


    -------------------------
    |                       |
    |     o o o o o o o     |
    |    o o o o o o o o    |
    |    1  4  7  10 13     |      1 = R0
    |     2  5  8  11 12    |
    |      3  6  9  12 15   |      2 = PA5
    |                       |
    | -----+----+----- SST  |      3 = PA1
    | |    |    |    |-H--  |
    | | GO | ST | RS |-H--ON|      4 = PA4
    | |    |    |    |      |
    | +----+----+----+----- |      5 = PA0
    | |    |    |    |    | |
    | | AD | DA | PC | +  | |      6 = ST
    | |    |    |    |    | |
    | +----+----+----+----+ |      7 = Vcc
    | |    |    |    |    | |
    | | C  | D  | E  | F  | |      8 = RS
    | |    |    |    |    | |
    | +----+----+----+----+ |      9 = PA3
    | |    |    |    |    | |
    | | 8  | 9  | A  | B  | |     10 = 33GG
    | |    |    |    |    | |
    | +----+----+----+----+ |     11 = 25TT
    | |    |    |    |    | |
    | | 4  | 5  | 6  | 7  | |     12 = PA6
    | |    |    |    |    | |
    | +----+----+----+----+ |     13 = R2
    | |    |    |    |    | |
    | | 0  | 1  | 2  | 3  | |     14 = PA2
    | |    |    |    |    | |
    | -----+----+----+----- |     15 = R1
    -------------------------


                            Keyboard Detail
                              FIGURE 3.6


                                   29

============================================================================


                           (see schematics)


                             TTY Interface
                              FIGURE 3.7


                                   30

============================================================================


                           (see schematics)


                         Audio Tape Interface
                              FIGURE 3.8


                                   31

============================================================================

    -----+-------------     ----+---------------------
    | 22 | KB Col D   |     | 0 | KB Row 1           |
    | 21 | KB Col A   |     | Y | KB Col C           |
    | 20 | KB Col E   |     | X | KB Row 2           |
    | 19 | KB Col B   |     | W | KB Col G           |
    | 18 | KB Col F   |     | V | KB Row 3           |
    | 17 | KB Row 0   |     | U | TTY PTR            |
    | 16 | PB5        |     | T | TTY KYBD           |
    | 15 | PB7        |     | S | TTY PTR RTRN(+)    |
    | 14 | PA0        |     | R | TTY KYBD RTRN(+)   |
    | 13 | PB4        |     | p | AUDIO OUT HI       |
    | 12 | PB3        |     | N | +12v               |
    | 11 | PB2        |     | M | AUDIO OUT LO       |
    | 10 | PB1        |     | L | AUDIO IN           |
    | 9  | PB0        |     | K | DECODE ENAB        |
    | 8  | PA7        |     | J | K7                 |
    | 7  | PA6        |     | H | K5                 |
    | 6  | PA5        |     | F | K4                 |
    | 5  | PA4        |     | E | K3                 |
    | 4  | PA1        |     | D | K2                 |
    | 3  | PA2        |     | C | K1                 |
    | 2  | PA3        |     | B | K0                 |
    | 1  | VSS GND    |     | A | VCC +5v            |
    -----+-------------     ----+---------------------


                        Application Connector
                              FIGURE 3.9


                                   32

============================================================================

    -----+------------      ----+-------------
    | 22 | VSS GND   |      | Z | RAM/R/W    |
    | 21 | VCC +5    |      | Y | /o2        |
    | 20 |           |      | X | PLL TEST   |
    | 19 |           |      | W | /R/W       |
    | 18 |           |      | V | R/W        |
    | 17 | SST OUT   |      | U | o2         |
    | 16 | K6        |      | T | AB15       |
    | 15 | DB0       |      | S | AB14       |
    | 14 | DB1       |      | R | AB13       |
    | 13 | DB2       |      | P | AB12       |
    | 12 | DB3       |      | N | AB11       |
    | 11 | DB4       |      | N | AB10       |
    | 10 | DB5       |      | L | AB9        |
    | 9  | DB6       |      | K | AB8        |
    | 8  | DB7       |      | J | AB7        |
    | 7  | RST       |      | H | AB6        |
    | 6  | NMI       |      | F | AB5        |
    | 5  | R0        |      | E | AB4        |
    | 4  | IRQ       |      | D | AB3        |
    | 3  | o1        |      | C | AB2        |
    | 2  | RDY       |      | B | AB1        |
    | 1  | SYNC      |      | A | AB0        |
    -----+------------      ----+-------------


                          Expansion Connector
                              FIGURE 3.10


                                   33

============================================================================

3.2 KIM-1 MEMORY ALLOCATION

      It has been stated that the 6502 microprocessor array included in
the KIM-1 system is capable of addressing any of 65,536 memory locations.
Obviously, we have not included that much memory in your KIM-1 system and
this section is intended to detail for you exactly what memory locations
are included in the system and where they are located (their exact
addresses).

      Each byte of memory in the system is understood to include 8 bits.
Also, you should note that any addressable location in the system may be
performing any one of four functions:

          1.  A ROM byte - read-only memory in which we have stored the
              operating program.

          2.  A RAM byte - read/write memory for storage of variable data.

          3.  An I/O location - these locations include both direction
              registers which define the I/O pins to be either input pins
              or output pins, and the actual data buffer locations contain-
              ing the data to be transmitted on output pins or the data
              read from input pins.  Any I/O location may be viewed as a
              read/write memory location with a specific address.

          4.  An Interval Timer location - a series of addresses are
              reserved for each interval timer in the system.  Again, you
              may write to the timer to define its counting period or read
              from the timer to determine its exact state.

      Figure 3-11 shows a block diagram detailing all memory blocks in the
KIM-1 system.  Figure 3-12 provides a memory map showing all addressable
locations included in the system and their relationship to each other.
Note also the areas in the memory map indicated as available for expansion.
(Section 6 of the manual provides more detail on the subject of memory
expansion).  Finally, Figure 3-13 provides a complete listing of all impor-
tant memory locations and will be referenced frequently by you when writing
your application programs.


                                   34

============================================================================

      Referring to Figure 3-12, note that the memory map shows a block of
8192 address locations all existing in the lowest address space within
the possible 65,536 address locations.  This address space is further
divided into eight blocks of 1024 locations each.  Each 1024 block is
further divided into four pages of 256 locations each.  The "K"
reference defines a specific block of 1024 locations and refers to the
"K" number of the address decoder included within the system control
logic.  The "page" reference defines a specific group of 256 addresses.
A total of 32 pages (0 to 31) are included in the 8192 address locations.
The hex codes for certain addresses are shown at strategic locations in
the memory map.

      Beginning from the highest address location of the 8192, note that
the first 1024 block (K7) is assigned to the ROM of the 6530-002 and the
second 1024 block (K6) is assigned to the ROM of the 6530-003.  The entire
operating program of the KIM-1 system is included in these two blocks.

      Next in order, a portion of the K5 block is dedicated to the RAM,
I/O, and Timer locations of the two 6530 arrays.  An expanded view of
this address space is shown in Figure 3-12.  Note that the RAM addresses
for the 6530-002 (Hex 17EC to 17FF) are reserved for use by the operating
program and should not appear in a user generated application program.
The same is true for the I/O and Timer locations of the 6530-002 which
also are reserved for use by the operating programs.

      The next four blocks in order (K4, K3, K2, K1) are reserved for
additional memory in an expanded system.  In Section 6, the methods for
adding memory will be discussed.

      Finally, the lowest 1024 address locations (K0) are assigned to the
static RAM included within the KIM-1 system.  You should note that within
this block, Page 0 and Page 1 have special significance.  Page 1 is used
as the system stack onto which return addresses and machine status words
are pushed as the system responds to interrupts and subroutine commands.
Page 0 has significance for certain of the special addressing modes avail-
able when programming for the 6502 microprocessor array.


                                   35

============================================================================

      Figure 3-12 shows an expanded view of Page 0 and Page 1.  Note that
17 addresses (00EF to 00FF) are reserved for use by the operating program
and must never appear in the user generated application program.  Also,
note the comment that a maximum of eight locations may be required on the
stack (Page 1) to service operating program interrupts.

      In summary, the user generated application program may make use of
the following areas of memory:

          1.  All of Page 0 except 00EF to 00FF

          2.  All of Page 1 (remember that the stack will extend an
              extra 8 bytes deep to accommodate the operating program).

          3.  All of Page 2 and Page 3.

          4. In Page 23:
                  -   All I/O locations from 1700 to 173F
                  -   All 64 bytes of RAM from 1780 to l7BF
                  -   An additional 44 bytes of RAM from 17c0 to l7EB


                                   36

============================================================================

                                                                        |
  #=======#========#========#========#========#=========#=========#====>|
  H       H        H        H        H        H         H         H     |
--#-- ----#--- ----#--- ----#--- ----#--- ----#---- ----#---- ----#---  |
|   | | 1024 | | 1024 | |  64  | |  64  | | I/O 8 | | I/O 8 | | 1024 |  |
|   | |      | |      | |      | |      | |       | |       | |      |  | E
|   | | BYTE | | BYTE | | BYTE | | BYTE | | TIMER | | TIMER | | BYTE |  | X
|   | |      | |      | |      | |      | |       | |       | |      |  | P
|   | | ROM  | | ROM  | | RAM  | | RAM  | |       | |       | | RAM  |  | P
| 6 | +------+ +------+ +------+ +------+ +-------+ +-------+ +------+  | A
| 5 | | 1FFF | | 1BFF | | 17FF | | 17BF | | 177F  | | 173F  | | 03FF |  | N
| 0 | |      | |      | |      | |      | |       | |       | |      |  | S
| 2 | |  TO  | |  TO  | |  TO  | |  TO  | |  TO   | |  TO   | |  TO  |  | I
|   | |      | |      | |      | |      | |       | |       | |      |  | O
|   | | 1C00 | | 1800 | | 17C0 | | 1780 | | 1740  | | 1700  | | 0000 |  | N
|   | +------+ +------+ +------+ +------+ +-------+ +-------+ +------+  |
|   | | 6530 | | 6530 | | 6530 | | 6530 | | 6530  | | 6530  | |  8x  |  |
|   | | -002 | | -003 | | -002 | | -003 | | -002  | | -003  | | 6102 |  |
--#-- ----#--- ----#--- ----#--- ----#--- ----#---- ----#---- ----#---  |
  H       H        H        H        H        H         H         H     |
  #=======#========#========#========#========#=========#=========#====>|
                                                                        |

                          Memory Block Diagram
                              FIGURE 3.11


                                   37

============================================================================

             -----------  -----
             |         |  FFFF
             |AVAILABLE|
             |FOR      |
             |EXPANSION|
             |         |
             |         |
             |         |                  ----------  ---- \
             |         |                 /|64 BYTE |  17FF  > KIM RAM
             |         |                / |        |  17E7 /
             |         |               /  |RAM     |  ---- \
"K" | PAGE   |         |  2000 HEX    /   |        |  17E6  |
----+-----   +=========+  -----      |    |6530-002|  17C0  | APPLICATION
    | 31     |  KIM    |  1FFF       |    +--------+  ----   >
    | 30     |  ROM    |             |    |64 BYTE |  17BF  | RAM
K7  | 29     |6530-002 |             |    |RAM     |        |
    | 28     |         |  1C00       |    |6530-003|  1780 /
----+-----   +---------+  -----     /     +--------+  ----
    | 27     |  KIM    |  1BFF     /      |I/O 8   |  177F \
K6  | 26     |  ROM    |          /       |TIMER   |        > KIM I/O
    | 25     |6530-003 |         /        |6530-002|  1740 /
    | 24     |         |  1800  /         +--------+  ----
----+-----   +---------+  -----/          |I/O 8   |  173F \  APPLICATION
    | 23     |         |  17FF            |TIMER   |        > I/O
K5  | 22     |         |  1700            |6530-003|  1700 /
    | 21     |         |  --------------------------  ----
    | 20     |         |  1400
----+-----   +=========+  ------
    | 19     |         |  13FF ^
K4  | 18     |         |       |
    | 17     |         |       |
    | 16     |         |       |
----+-----   +---------+       |
    | 15     |         |       |
K3  | 14     |         |  DECODED
    | 13     |         |  FOR 4K
    | 12     |         |  EXPANSION
----+-----   +---------+       |
    | 11     |         |       |
K2  | 10     |         |       |
    | 9      |         |       |          ----------  ----  <----
    | 8      |         |       |         /|        |  01FF      |
----+-----   +---------+       |        / | STACK  |          STACK
    | 7      |         |       |       /  |        |          POINTER
K1  | 6      |         |       |      /   | PAGE 1 |          INITIALIZED
    | 5      |         |       |     /    |        |  0100
    | 4      |         |  0400 v    /     +--------+  ----
----+-----   +=========+  ------   /     /|////////|  00FF
    | 3      |         |  03FF    /     / |////////|        <------
    | 2      |         |  0200   /     /  |////////|  00EF        |
K0  |        |---------|  -------     /   +--------+  ----        |
    | 1      |  STACK  |  01FF       /    |        |  00EE    17 BYTES
    |        |---------|    ---------     | PAGE 0 |  RESERVED
    | 0      | PAGE 0  |  0000            |        |  0000    FOR KIM
----+-----   -----------  --------------------------  ----


                              FIGURE 3.12
                              Memory Map


                                  38

============================================================================

----------+----------------+-------+--------------------------------------
| ADDRESS |      AREA      | LABEL |              FUNCTION               |
|         |                |       |                                     |
|  00EF   |                | PCL   | Program Counter - Low Order Byte    |
|  00F0   |                | PGH   | Program Counter - High Order Byte   |
|  00F1   |     Machine    | P     | Status Register                     |
|  00F2   |     Register   | SF    | Stack Pointer                       |
|         |     Storage    |       |                                     |
|  00F3   |     Buffer     | A     | Accumulator                         |
|  00F4   |                | Y     | Y-Index Register                    |
|  00F5   |                | X     | X-Index Register                    |
+---------+----------------+-------+-------------------------------------+
|  1700   |                | PAD   | 6530-003 A Data Register            |
|  1701   |   Application  | PADD  | 6530-003 A Data Direction Register  |
|  1702   |        I/O     | PBD   | 6530-003 B Data Register            |
|  1703   |                | PBDD  | 6530-003 B Data Direction Register  |
+---------+----------------+-------+-------------------------------------+
|  1704   |                |       | 6530-003 Interval Timer             |
|         | Interval Timer |       |   (See Section 1.6 of               |
|         |                |       |    Hardware Manual)                 |
|  170F   |                |       |                                     |
+---------+----------------+-------+-------------------------------------+
|  17F5   |                | SAL   | Starting Address - Low Order Byte   |
|  17F6   |   Audio Tape   | SAH   | Starting Address - High Order Byte  |
|  17F7   |   Load & Dump  | EAL   | Ending Address - Low Order Byte     |
|  17F8   |                | EAH   | Ending Address - High Order Byte    |
|  17F9   |                | ID    | File Identification Number          |
+---------+----------------+-------+-------------------------------------+
|  l7FA   |                | NMIL  | NMI Vector - Low Order Byte         |
|  l7FB   |                | NMIH  | NMI Vector - High Order Byte        |
|  l7FC   |   Interrupt    | RSTL  | RST Vector - Low Order Byte         |
|         |    Vectors     |       |                                     |
|  17FD   |                | RSTH  | RST Vector - High Order Byte        |
|  l7FE   |                | IRQL  | IRQ Vector - Low Order Byte         |
|  17FF   |                | IRQH  | IRQ Vector - High Order Byte        |
+---------+----------------+-------+-------------------------------------+
|  1800   |                | DUMPT | Start Address - Audio Tape Dump     |
|         |  Audio Tape    |       |                                     |
|  1873   |                | LOADT | Start Address - Audio Tape Load     |
+---------+----------------+-------+-------------------------------------+
|  1C00   | STOP Key + SST |       | Start Address for NMI using KIM     |
|         |                |       | "Save Nachine" Routine (Load in     |
|         |                |       | 17FA & 17FB)                        |
+---------+----------------+-------+-------------------------------------+
|  17F7   |   Paper Tape   | EAL   | Ending Address - Low Order Byte     |
|  17F8   |    Dump (Q)    | EAH   | Ending Address - High Order Byte    |
----------+----------------+-------+--------------------------------------


                          Special Memory Addresses
                              FIGURE 3.13


                                   39

============================================================================

3.3   KIM-1 OPERATING PROGRAMS

      Figure 3-14 shows a simplified flow chart of the KIM-1 operating
programs.  This section provides a brief explanation of these programs
to assist you in understanding the various operating modes of the system.

      First, you should note that when power is first applied to your
KIM-1 module and the [RS] (reset) key is depressed, control of the system
automatically is assumed by the operating program.  This is true, as well,
for any succeeding depression of the reset key.

      For each depression of the reset key, the system is initialized.
At this time, stack pointer values are set, the I/O configuration is
established, and essential status flags are conditioned.  Next the
program determines whether the system is to respond to TTY inputs or
is to operate with the keyboard and display on the KIM-1 module.

      If the TTY mode has been selected, the program halts and awaits a
first key depression from the TTY (the RubOut Key).  Upon receipt of this
key depression, the program automatically performs a bit rate measurement
and stores the correct value for use in receiving and decoding succeeding
data transfers from the TTY.  Note that this bit rate measurement is per-
formed after each depression of the reset key.

      The program will proceed immediately to a routine causing the
prompting message ("KIM") to be typed on the TTY.  Now, the program halts
at the loop called "Get Character".  As each key is depressed on the TTY,
the coded data is accepted and analyzed in the routine called "Execute Key".
The various keys depressed will cause the program to branch to the appro-
priate subroutines required to perform the desired operation.  Upon com-
pletion of the individual key executions, the program returns to the "Get
Key" loop and awaits the next key depression.


                                   40

============================================================================
       ___                          ___                           ___
       NMI                          RST                           IRQ
       ---                          ---                           ---
       \ /                          \ /                           \ /
        V                            V                             V
        |                            |                             |
  ------+------               -------+------                       V
  | SAVE MPU  |               | INITIALIZE |                  USER OPTION
  | REGISTERS |               -------+------
  ------+------                      |
        |                            ^
        |                           / \
        |           ---------------< KB>                      1873 HEX
        |           |               \ /                          ---
        |           |                V                           \ /
        |           |                | TTY                        V
        |           |                |                            |
        |           |         -------+-------                     |
        |           |   RO--->|  BIT RATE   |              -------+------
        |           |         | MEASUREMENT |              |            |
        |           |         -------+-------              | AUDIO-TAPE |
        |           |                |                     | LOAD MEM   |
        |           |                v                     | FROM TAPE  |
        |           v             --------                 |            |
        ------------------------>( START  )<-------------  -------+------
                            ^     ---+----              |         |
                            |        |                  |         |
                            |        ^                  |<---------
                            |       / \  KB             |
                            |      < KB>------          |
                            |       \ /      |          |
                            |        V       |          |
                            v        |       |          |
          ----------------------------       |          |
          |                 ^                v          |
    ------+------           |           -----------     |     1800 HEX
    |   PRINT   |    -------|---------->| DISPLAY |     |        ---
    |    KIM    |    |      |           | CELL    |     |        \ /
    ------+------    |      |           -----+-----     |         V
          |          |      --------         |          |         |
    ------+------    |             |         ^          |         |
    |    GET    |    |             | NO KEY / \         |  -------+------
 -->| CHARACTER |    |             |<------< AK>        |  |            |
 |  ------+------    |             |        \ /         |  | AUDIO-TAPE |
 |        |          |             |         V          |  | DUMP MEM   |
 |        ^          |             |         |          |  | TO TAPE    |
 |       / \   KB    |             |    -----+-----     |  |            |
 |      < KB>---------             |    | DISPLAY |     |  -------+------
 |       \ /                       |    | CELL    |     |         |
 |        V TTY                    |    -----+-----     |         |
 |        |                        |         |          |<---------
 |  ------+------                  |         ^
 |  |           +----> HEX         | NO KEY / \
 |  |           |                  |<------< AK>
 |  |           +----> G-------    |        \ /
 |  |           |             |    |         V
 |  |           +----> SPACE  |    |         |
 |  |           |             |    |    -----+-----
 |  |  EXECUTE  +----> CR     |    |    | GET KEY |
 |  |  KEY      |             |    |    -----+-----
 |  |           +----> LF     |    |         |
 |  |           |             |    |    -----+-----
 |  |           +----> RO     |    |    |         +----> HEX (0-F)
 |  |           |             |    |    |         |
 |  |           +----> Q      |    |    |         +----> GO
 |  |           |             |    | RUN|         |
 |  |           +----> L      |<---|----+ EXECUTE +----> PC
 |  ------+------             |    |    | KEY     |
 |        |                   |    |    |         +----> AD
 |        |                   |    |    |         |
 ----------                   |    |    |         +----> DA
                              v    |    |         |
                   --------------  |    |         +----> +
                   | PROCESS    |  |    -----+-----
                   | G/RUN KEYS |  |         |
                   -------+------  |    -----+-----
                          |        |    | DISPLAY |
                          |        | -->| CELL    |
                          v        | |  -----+-----
                                   | |       |
                                   | |       ^
                                   | |      / \
                                   | ------< AK>
                                   |        \ /
                                   |         V
                                   |         |
                                   | NO KEY  |
                                   -----------


                              Flow Chart
                              FIGURE 3.14


                                   41

============================================================================

          Exit from the TTY processing loop will occur in response to:

              1.  A depression of the reset key,

              2.  A depression of the G key which initiates execution of
                  the application program, or

              3.  A change in the mode from TTY to Keyboard/Display.

      If, after system reset and initialization, the Keyboard/Display
mode (KB) is determined to be in effect, the program will proceed dir-
ectly to display, and keyboard scan routines.  The program will cause the
display scan to occur continuously ("Display Cell") until one of the keys
on the keyboard is depressed (AK?).  Key validation is performed during
an additional scan cycle.  If the key is truly depressed (not noise), the
program proceeds to the routine called "Get Key" in which the exact key
depressed is defined.  Next, the program moves to the "Execute Key"
routine where branches to appropriate execution routines will be per-
formed.  Finally, after key execution, the program returns to the "Display
Cell" routine and waits for the key to be released.  When no key is de-
pressed, the program returns to the normal "Display Cell" routine and
awaits the next key depression.

      In either the TTY or KB modes, the audio tape load or dump routines
may be executed using appropriate commands from the selected keyboards.
In either case, completion of the tape load or dump routine allows the
program to return to the "Start" position which will, as usual, activate
the KIM-1 display or cause the "KIM" prompting message on the TTY.

      You should note the use of the Stop key to activate the non-maskable
interrupt input (NMI) of the 6502 microprocessor array.  Depression of
this key causes an unconditional termination of program execution, a
saving of machine status registers on the stack, and a return to the
control of the operating program.

      A second interrupt input is available and referred to as IRQ.  This
interrupt may be defined by the user and will cause the program to jump to
any location defined by the user in his program.


                                   42

============================================================================

                              CHAPTER 4

                      OPERATING THE KIM-1 SYSTEM


      Now that you have a better idea of what is included in your KIM-1
system and how it operates, its time to provide you with detailed pro-
cedures for all of the operations you can perform with the system.  We
will separate our operating procedures into three areas giving specific
direction for the use of the KIM-1 keyboard and display, the audio tape
recorder, and the serial teleprinter (TTY).


4.1  USING THE KIM KEYBOARD AND DISPLAY

      A brief study of your keyboard shows a total of 23 keys and one
slide switch.  First, let's list the purpose of each key:

              [0] to [F]  -   Sixteen keys used to define the hex code
                              of address or data

                    [AD]  -   selects the address entry mode

                    [DA]  -   selects the data entry mode

                    [+]   -   increments the address by +1 but does
                              not change the entry mode

                    [PC]  -   recalls the address stored in the Program
                              Counter locations (PCH, PCL) to the display

                    [RS]  -   causes a total system reset and a return to
                              the control of the operating program

                    [GO]  -   causes program execution to begin starting
                              at the address shown on the display

                    [ST]  -   terminates the execution of a program and
                              causes a return to the control of the
                              operating program


                                   43

============================================================================

      You have seen in an earlier chapter that the six digit display in-
cludes a four digit display of an address (left four digits) and a two
digit display of data (right two digits).
      Using only the KIM-1 keyboard and display, you may perform any of
the following operations:

          1.  Select an Address

              Press  AD  followed by any four of the hex entry keys.
              The address selected will appear on the display.  If an
              entry error is made, just continue to enter the correct
              hex keys until the desired address shows on the display.
              Regardless of what address is selected, the data field of
              the display will show the data stored at that address.


          2.  Modify Data

              After selecting the proper address, press [DA] followed by
              two hex entry keys which correctly define the data to be
              stored at the selected address.  The data entered will
              appear in the data field of the display to indicate that
              the desired code has already been entered.

              Note that it is possible for you to select an address of
              a ROM memory cell or even the address of a memory cell that
              does not exist in your system.  In these cases, you will not
              be able to change the data display since it is clearly not
              possible for the system to write data to a ROM cell or a
              non-existent memory location.


          3.  Increment the Address

              By pressing the [+] key the address displayed is auto-
              matically increased by +1.  Of course, the data stored at
              the new address will appear on the display.  This operation
              is useful when a number of successive address locations must
              be read or modified.  Note that the use of the [+] key will
              not change the entry mode.  If you had previously pressed
              the [AD] key, you remain in the address entry mode and a
              previous depression of the [DA] means you remain in the
              data entry mode.


                                   44

============================================================================

          4.  Recall Program Counter

              Whenever the NMI interrupt pin of the 6502 microprocessor
              array is activated, the program execution in progress will
              halt and the internal registers of the 6502 are saved in
              special memory locations before the control of the system
              is returned to the operating program.  In the KIM-1 system,
              the NMI interrupt may occur in response to a depression of
              the [ST] key (stop) or, when operating in the Single Step
              mode, after each program instruction is executed following
              the depression of the  GO  key.

              The [PC] key allows you automatically to recall the value
              of the Program Counter at the time an interrupt occurred.
              You may have performed a variety of operations since the
              interrupt such as inspecting the contents of various
              machine registers stored at specific memory locations.
              However, when you press the [PC] key, the contents of the
              Program Counter at the time ot the interrupt are recalled
              to the address field of the display.  You now may continue
              program execution from that point by pressing the [GO] key.


          5.  Execute a Program

              Select the starting address of the desired program.  Now,
              press the [GO] key and program execution will commence
              starting with the address appearing on the display.


              6.  Terminate a Program

              The [ST] key is provided to allow termination of program
              execution.  As mentioned earlier, the [ST] key activates
              the NMI interrupt input of the 6502 microprocessor array.

              Note:  The [ST] key will operate correctly only if you
              store the correct interrupt vector at locations 17FA and
              17FB.  For most of your work with the KIM-1 system, you
              should store the address 1C00 in these locations as follows:



      Personal note: it seems a figure or text is missing at this place???



                                   45

============================================================================
                    ___
      Now, when the NMI interrupt occurs, the program will return to
location 1C00 and will proceed to save all machine registers before
returning control to the operating program.
      You should remember to define the NMI vector each time the power
to the system has been interrupted.  A failure of the system to react
to the [ST] key means you have forgotten to define the NMI vector.

          7.  Single Step Program Execution

              In the process of debugging a new program, you will find
              the single step execution mode helpful.  To operate in
              this mode, move the SST slide switch to the ON position
              (to your right).  Now, depress the [GO] key for each
              desired execution of a program step.  The display will
              show the address and data for the next instruction to
              be executed.  Note that in the course of stepping
              through a program, certain addresses will appear to
              be skipped.  A program instruction will occupy one, two,
              or three bytes of memory depending upon the type of
              instruction.  In single instruction mode, all of the
              bytes involved in the execution of the instruction are
              accessed and the program will halt only on the first
              byte of each successive instruction.

              Note: SST mode also makes use of the NMI interrupt of the
              6502 microprocessor array.  Again, the NMI vector must be
              defined as described in (6) above if the SST mode is to
              work correctly.

      This covers all of the standard operations you may perform from the
KIM-1 keyboard.  Using combinations of the operations described, you may
wish to perform certain specialized tasks as follows:

          1.  Define the IRQ Vector

              You will recall that a separate interrupt input labelled
              IRQ is available as an input to the 6502 microprocessor
              array.  If you wish to use this feature, you should enter
              the address to which the program will jump.  The IRQ
              vector is stored in locations 17FE and 17FF.


          2.  Interrogate Machine Status

              We have mentioned that after an NMI interrupt in response
              to the  ST  key or during the SST mode, the contents of
              various machine registers are stored in specific memory
              locations.  If you wish to inspect these locations, their
              addresses are:


                                   46

============================================================================

                  00EF = PCL
                  00F0 = PCH
                  00F1 = Status Register (P)
                  00F2 = Stack Pointer (SP)
                  00F3 = Accumulator (A)
                  00F4 = Y Index Register
                  00F5 = X Index Register

4.2 USING THE AUDIO TAPE RECORDER

      There are two basic operations possible when working with your audio
tape system.  You may transfer data from the KIM-1 memory and record it
on tape.  Or, you may read back a previously recorded tape, transferring
the data on tape into the KIM-1 memory.

          Recording on Audio Tape

          The procedure for recording on audio tape requires that you
perform the following steps:

              1.  Clear decimal mode by entering 00 in location 00F1.
                  Define an identification number (ID) for the data
                  block you are about to record.  This two digit number
                  is loaded into address 17F9.  Don't use ID = 00 or
                  ID = FF.

              2.  Define the starting address of the data block to be
                  transferred.  This address is to be loaded into
                  locations:

                      17F5 = Starting Address Low (SAL)
                      17F6 = Starting Address High (SAH)

              3.  Define the ending address as one greater than the
                  last address in the data block to be recorded.  The
                  ending address is to be loaded into locations:

                  17F7 = End Address Low (EAL)
                  17F8 - End Address High (EAH)

          As an example, assume you wish to record a data block from
address 0200 up to and including address 03FF.  (All of Pages 2 and 3).
You wish to assign an ID number of 06 to this block.  Using the KIM-1
keyboard, you should load the data shown into the addresses indicated
so that:
      00F1 = 00 (Clear Decimal Mode)
      17F5 = 00 (SAL)
      17F6 = 02 (SAH)
      17F7 = 00 (EAL) \
                       > = 03FF + 1
      17F8 = 04 (EAH) /
      17F9 = 06 (ID)


                                   47

============================================================================

      Note that the ending address must be greater than the starting
address for proper operation.

              4.  Assuming that you are using a new cassette on which
                  no data has been stored previously, insert the
                  cassette in the unit and rewind the tape to its
                  start position.


              5.  Select the starting address of the tape record program.
                  This address is 1800.

              6.  Select the Play/Record mode of the audio unit and allow
                  several seconds for the tape to begin to move.

              7.  Press the  GO  key and the recording process will begin.
                  The display will be blanked for a period and then will
                  relight showing 0000 xx.  This means that the data
                  block selected has been recorded.

              8.  You may now stop the tape or allow some additional
                  seconds of blank tape and then stop the unit.


          Loading Data From Audio Tape

          The procedure for loading data from an audio tape into the
KIM-1 memory requires that you perform the following steps:

              1.  Clear decimal mode by entering 00 in location 00F1.
                  Define the ID number of the data block to be loaded
                  from tape.  The ID number is loaded into address 17F9.

              2.  Select the starting address of the Tape Load program.
                  This address is l873 HEX.

              3.  Press the [GO] key.  The KIM-1 system is now waiting
                  for the appearance of data from the tape unit.

              4.  Load the cassette and, presuming you do not know where
                  on the tape the data block is recorded, rewind the tape
                  to its starting position.  Check the volume control
                  setting.

              5.  Start the audio tape unit in its Play mode and observe'
                  that the tape begins to move.

              6.  Wait for the KIM-1 display to relight showing 0000 xx.
                  This means the data block has been loaded successfully
                  from the tape into the KIM-1 memory.  If the display
                  relights with FFFF xx, the correct data block has been
                  found but there has been an error detected during the
                  read operation.  If the tape continues to run and the
                  display never relights, the system has not been
                  successful in finding the data block with the specific
                  ID number you requested.


                                   48

============================================================================

              7.  If in step (1), you had selected an ID = 00, the ID
                  number recorded on the tape will be ignored and the
                  system will read the first valid data block encountered
                  on the tape.  The data read from the tape will be
                  loaded into memory address as specified on the tape.


              8.  If, in step (1), you had selected an ID = FF, the ID
                  number recorded on the tape will be ignored and the sys-
                  tem will read the first valid data block encountered on
                  the tape.  In addition, the data block will be loaded
                  into successive memory locations beginning at the
                  address specified in locations 17F5 and 17F6 (SAL, SAH)
                  instead of the locations specified on the tape.


          Special Operations with Audio Tape

          The KIM-1 system causes data to be recorded on audio tape with
a specific format as detailed in Appendix E.  Each recorded data block is
preceeded by a group of synchronizing characters together with an identi-
fication code to define the specific block.  Data blocks may be of arbi-
trary length.

          With a little care, there is no reason for you not to include a
number of recorded data blocks on the same tape.  If you are recording
blocks in sequence and have not rewound the tape between blocks, you need
only specify the parameters of each new block (ID, SAL, SAH, EAH, EAL) and
proceed with recording the new block.

          If the tape has been rewound, you will need to know the ID
number of the last recorded data block.  Rewind the tape to its starting
point and set up the parameters required to read the last recorded data
block.  After reading this block, stop the tape and you may now proceed
to add a new block or blocks to the tape.

          If you wish, you may add voice messages between the recorded
data blocks on the tape.  The KIM-1 system will ignore these audio
messages when the tape is read back.  Of course, you will need to install
an earphone or speaker in parallel with the KIM-1 audio tape data input
pin in order to hear the voice messages.

          We do not recommend that you attempt to record data blocks in
areas of the tape which have been used previously for recorded data.
Variations in tape speed and block lengths can result in overlapping of
recorded data which may be read incorrectly by the KIM-1 system.


                                   49

============================================================================


4.3  USING A SERIAL TELEPRINTER

      The addition of a serial teleprinter (such as the Teletype Model
33ASR) to work with the KIM-1 system permits a variety of special opera-
tions to be performed.  In all cases, you define desired operations by
depressing the proper keys while simultaneously producing a hard-copy
printed record of each operation.  If your teleprinter is equipped
with a paper tape reader/punch, you may generate or read paper tapes
using the KIM-1 system.  Using the serial teleprinter, you may perform
the following operations:

          Select an Address

          Type four hex keys (0 to F) to define the desired address.
Next, press the [SPACE] bar.
          The printer will respond showing the address code selected
followed by a two digit hex code for data stored at the selected
address location:
              Type:               1234    [SPACE]
              Printer Responds:   1234    AF
showing that the data AF is stored at location 1234.


          Modify Data

          Select an address as in the previous section.  Now type two hex
characters to define the data to be stored at that address.  Next type
the [.] key to authorize the modification of data at the selected address:
              Type:               1234    [SPACE]
              Printer Responds:   1234    AF
              Type:                             6D    [.]
              Printer Responds:   1235    B7
Note that the selected address (1234) has been modified and the system
increments automatically to the next address (1235).

          Note:   Leading zero's need not be entered for either address
                  or data fields:  For example:
                      EF [SPACE] selects address 00EF
                       E [SPACE] selects address 000E
                       A [.] enters data 0A
                         [.] enters data 00 (etc.)


                                   50

============================================================================

      Step to Next Address

      Type [CR] to step to the next address without modifying the
current address:
              See Printed:        1234    AF
              Type:                               [CR]
              Printer Responds:   1235    B7
              Type:                               [CR]
              Printer Responds:   1236    C8              (etc.)


          Step to Preceding Address

          Type [LF] to step back to the preceding address:
              See Printed:        1234    AF
              Type:                               [LF]
              Printer Responds:   1233    9D
              Type:                               [LF]
              Printer Responds:   1232    8E              (etc.)


          Abort Current Operation

          Type [RUB OUT] to terminate the current operation.  The prompting
message will be printed ("KIM") indicating that a new operation may
proceed:
              Type:               1264            [RUB OUT]
              Printer Responds:   KIM
                                  xxxx    xx
              Type:               1234            [SPACE]
              Printer Responds:   1234    AF

          In the example, the [RUB OUT] key is used to correct an erroneous
address selection.
          Note:   The [RUB OUT] key must be depressed after each depression
                  of the KIM-1 reset key in order to allow the operating
                  program to define the serial bit rate for the tele-
                  printer.


                                   51

============================================================================

          Load Paper Tape

          Paper Tapes suitable for use with the KIM-1 system are generated
using the format shown in Appendix F.  To read such a tape into the KIM-1
system, proceed as follows:

              1.  Load the punched paper tape on to the tape mechanism

              2.  Type [L]

              3.  Activate the paper tape reader

          The paper tape will advance and data will be loaded into addresses
as specified on the tape.  A printed copy of the data read will be generated
simultaneously with the reading of the paper tape.

          Check-sums are generated during the reading of the paper tape
and are compared to check-sums already contained on the tape.  A check-
sum error will cause an error message to appear in the printed copy.


          Punch Paper Tape

          The KIM-1 system can be used to punch paper tapes having the
format described in Appendix F.  The procedures for generating these
tapes is as follows:

              1.  Define the starting address and ending address of the
                  data block to be punched on the paper tape.

              2.  Load blank paper tape on the punch unit and activate
                  the punch.

                      Type:                       [1] [7] [F] [7] [SPACE]
                      See Printed:    17F7    xx
                      Type:                       [F] [F] [.]
                      See Printed:    17F8    xx
                      Type:                       [0] [3] [.]
                      See Printed:    17F9    xx
                      Type:                       [2] [0] [0]     [SPACE]
                      See Printed:    0200    xx


                                   52

============================================================================

          You have now loaded the ending address (03FF) into address
locations 17F7 (EAL) and 17F8 (EAH).  The starting address (0200) is
selected as shown.

              3.  Now type [Q]

                  The paper tape will advance and punching of the data
                  will proceed.  Simultaneously, a printed record of
                  the data will be typed.


          List Program

          A printed record of the contents of the KIM-1 memory may be
typed.  The procedure is the same as for punching paper tape except that
the punch mechanism is not activated.


          Execute Program

          To initiate execution of a program using the TTY keyboard, the
following procedures should be followed:

              1.  Enter the starting address of the program

              2.  Type [G]
                  For example, to begin program execution from
                  address location 0200:
                      Type:           [2] [0] [0] [SPACE]
                      See Printed:    0200    xx
                      Type:           [G]

                  Program execution begins from location 0200 and will
                  continue until the [ST] or [RS] keys of the KIM-1
                  module are depressed.  The single step feature may
                  be employed while in the TTY mode.


                                   53

============================================================================

                                  BLANK


                                   54

============================================================================


                              CHAPTER 8

                  LET'S TRY A REAL APPLICATION


      It is not practical in this manual to describe every possible
application or Programming technique.  However, now that you have become
familiar with the basic elements and operating procedures of the KIM-1
system, this section will show you how to apply what you have learned in
a simple but realistic application example.

      Our example will involve the generation of a variable frequency
square wave which will be connected to a speaker to produce an audible
tone.  The frequency of the tone will be selected using a set of seven
toggle switches.  We will proceed through the example by defining the in-
terface, writing and entering the program, and executing the program.
Finally, we will study a series of program debugging techniques which
will be useful to you for any new program you may write.


5.1  DEFINING THE INTERFACE

      You will recall that a group of 15 I/O pins are brought to the
Application connector from the 6530-003 array.  The logic and circuit
details concerning these I/O pins are described in Appendix H and in
Section 1.6 of the Hardware Manual ("Peripheral Interface/Memory
Device - - MCS 6530").


                                   55

============================================================================

      For our application example we will use eight of these I/O pins.
One pin (PA0) will be used as an output line to supply a square wave to
a driver circuit and speaker.  The other seven I/O pins (PA1 to PA7) are
defined as input points with a SPST toggle switch connected to each.
Figure 5-1 shows the circuit configuration for this example.  Note that
the remaining seven I/O pins (the PB port) are not used for this problem.

      For the switches connected to the input pins, we would like the sense
of the switch to be defined as a logic "0" when open and a logic "1" when
closed.  By connecting the switches to ground, we are producing exactly
the opposite sense and must remember to complement the switch states with
software when we write our program.  Also, we must define now that the
switch at PA1 is to be the LSB (least significant bit) and the switch at
PA7 is to be the MSB (most significant bit) of the seven bit binary word
formed by all seven switches.  In this way, the state of the switches can
define a binary number from zero (all switches open) to 127 DEC (all switches
closed).


                                   56

============================================================================




                                                          APPLICATION
      A-8   A-7   A-6   A-5   A-2   A-3   A-4   A-14  <-- CONNECTOR
    ------+-----+-----+-----+-----+-----+-----+------
    |     |     |     |     |     |     |     |     |
    | PA7 | PA6 | PA5 | PA4 | PA3 | PA2 | PA1 | PA0 | <-- PORT A
    |     |     |     |     |     |     |     |     |
    ---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+---
       |     |     |     |     |     |     |     |             O +5V
       |     |     |     |     |     |     |     |             |
       O     O     O     O     O     O     O     |      -------+
         /     /     /     /     /     /     /   |      |      |
        /     /     /     /     /     /     /    |     -+-     |
       O     O     O     O     O     O     O     |     | |     |
       |     |     |     |     |     |     |     | 3.3K| |     |
       |     |     |     |     |     |     |     |     | |     |
       +-----+-----+-----+-----+-----+------     |     -+-    /
       |                                         |      |   |- NPN
       |                                         |      +---+
      -+-                                        |      |   |\
       -                                         |     -+-    \
                                                 |     | |     |
                                                 | 3.3K| |     |
                                                 |     | |    -+-
                                                 |     -+-    | |
                                                 |      |  27 | |
                                                 --------     | |
                                                              -+-
                                                               |
                                                       |\ ---  |
                                                 8 Ohm | \| +---
                                                Speaker|  | |
                                                       | /| +---
                                                       |/ ---  |
                                                               |
                                                              -+-
                                                               -


                                                          APPLICATION
      A-15        A-16  A-13  A-12  A-11  A-10  A-9   <-- CONNECTOR
    -------     ------+-----+-----+-----+-----+------
    |     |     |     |     |     |     |     |     |
    | PB7 |     | PB5 | PB4 | PB3 | PB2 | PB1 | PB0 | <-- PORT B
    |     |     |     |     |     |     |     |     |
    -------     ------+-----+-----+-----+-----+------

      (THE B PORT IS NOT USED IN THIS EXAMPLE APPLICATION)


                          Speaker Application
                              FIGURE 5.1


                                   57

============================================================================

5.2   WRITING THE PROGRAM

Having defined the interface for our application, we may proceed now to
write our program.  The effort proceeds in four stages:

          1.  Generate a flow chart

          2.  Generate assembly language code

          3.  Analyze the program

          4.  Generate machine language code


                                  START
          FLOW CHART                |
                                    |
                                    v
                        -------------------------
                        |                       |
                        |     Initialization    |
                        |                       |
                        |      (Define I/O)     |
                        |                       |
                        ------------+------------
                                    |
                                    |
                                    v
                        -------------------------
                        |                       |
                        |       Toggle PA0      |
               -------->|                       |
               |        |    (Speaker Output)   |
               |        |                       |
               |        ------------+------------
               |                    |
               |                    |
               |                    v
               |        -------------------------
               |        |                       |
               |        |  Read Seven Switches  |
               |        |                       |
               |        |      & Complement     |
               |        |                       |
               |        ------------+------------
               |                    |
               |                    |
               |                    v
               |        -------------------------
               |        |                       |
               |        |         Delay         |
               |        |                       |
               |        |    Delay Defined by   |
               |        |    Switch 5ettings    |
               |        |                       |
               |        ------------+------------
               |                    |
               |                    |
               ----------------------


                                   58

============================================================================

      Briefly, our flow chart shows a first step of system initialization.
During this step, we must define the I/O configuration of the system in
that pin PA0 becomes the output to the speaker and that pins PA1 to PA7
become inputs from the seven switches.

      After initialization, a loop is set up which begins by inverting the
state of PA0 (Toggle PA0).  Next, the state of the switches is read and
the data is complemented to produce the correct "sense" from the switches.
The value so read is used to define a delay before returning to the start
of the loop and again toggling the state of PA0.  A little thought will
show that this loop will produce a square wave with a frequency determined
by the setting of the seven switches.


          Assembly Language Program

          Our next task is to convert the simple flow chart into a
program.  The program is first written in "Assembly Language".  You should
refer to your Programming Manual to become familiar with all of the pos-
sible 6502 instructions (especially see Appendix B; Instruction Summary).
Figure 5-2 shows the application example programmed in assembly language.


                                   59

============================================================================

 --------+-----------+---------+---------+------------------------------------
 |       |           |         | MACHINE |                                   |
 | LABEL | OPCODE    | OPERAND | CYCLES  |             COMMENTS              |
 +-------+-----------+---------+---------+-----------------------------------+
 | INIT  |  LDA      |  #$01   |   2     | Define I/O  0=Input  1=Output     |
 |       |  STA      |  PADD   |   4     | PADD   PORT A DATA DIRECTION REG. |
 | START |  INC      |  PAD    |   6     | Toggle PA0, PA1-PA7 Inputs        |
 |       |           |         |         | not affected                      |
 | READ  |  LDA      |  PAD    |   4     | READ switches into accumulator    |
 |       |  EOR      |  #$FF   |   2     | Complement switch value           |
 |       |  LSR      |  A      |   2     | Shift Accumulator 1 bit to right  |
 |       |  TAX      |         |   2     | Transfer final count into X-Index |
 | DELAY |  DEX      |         |   2     | Delay by an amount specified      |
 |       |  BPL      |  DELAY  |   3,2   | By the count in the X-Index       |
 |       |  BMI      |  START  |   3     | Go To START                       |
 | PADD  |  =$1701   |         |         | Define absolute address of        |
 |       |           |         |         | Data Direction Reg. A             |
 | PAD   |  =$1700   |         |         | Define absolute address of        |
 |       |           |         |         | Data Reg. A                       |
 --------+-----------+---------+---------+------------------------------------


                      Assembly Language Listing
                              FIGURE 5.2


                                   60

============================================================================

      You will note that each line of the program is broken into
several fields:
                - A label field permitting you to assign a "name" to
                  a specific location in the program.

                - An Operation Code field (Op Code) in which the exact
                  instruction to be executed is defined.

                - An Operand Field where the exact data required by the
                  instruction is defined together with certain symbols
                  defining addressing modes or data formats.  Symbols
                  encountered generally in MOS Technology, Inc. manuals
                  are:
                              #   Immediate Addressing
                              $   Hex Code
                              @   Octal Code
                              %   Binary Code
                              '   ASCII literal
                              =   Equates a label to a value

                - A Machine Cycle field defining the total number of
                  machine cycles required to execute an instruction.
                  (This information is derived from Appendix B of
                  the Programming Manual).

                - A Comment Field where the programmer may define the
                  intent of specific program steps.


          Program Analysis

          The inclusion of the "machine cycle" information of the program
chart (Figure 5-2) allows us to analyze the exact timing relationships
involved in our program example.  Note that the KIM-1 system operates
from a fixed frequency (1 MHz) oscillator with each machine cycle being
1us.  Therefore, an instruction like "INC PAD" which requires 6 machine
cycles will be executed in a 6us period.


                                   61

============================================================================

          By counting the total machine cycles occurring between each
toggle of PA0, an equation for the square wave frequency can be developed.
The actual frequency is determined by the position of the seven switches,
the number of machine cycles between each toggle of PA0, and the basic
clock rate (1 MHz) of the KIM-1 system.  Figure 5-3 shows the waveform
of the PA0 square wave and the derived equations for computing the
exact frequency.

              --------------------                  -------
              |                  |                  |
      PA0     |                  |                  |
              |                  |                  |
         ------                  --------------------
              |                  |                  |
              |                  |                  |
              |                  |                  |
              | T=23+(CNT.5)USEC |                  |
              |<---------------->|                  |
              |                  |                  |
              |                                     |
              |    t=2[23+(CNT.5]USEC               |
              |<----------------------------------->|
              |                                     |


                              6
                     1      10
              FREQ = - = --------- CPScps
                     T   46+10.CNT


              NOTE:   CNT EQUALS THE VALUE IN X-INDEX
                      WHICH WAS CALCULATED FROM THE
                      SEVEN SWITCHES  O <= CNT <= 127


                          Square Wave Output
                              FIGURE 5.3


                                   62

============================================================================

          Machine Language Coding

          Our next problem is to convert our assembly language program
into a program written in "machine language".  The quickest and most
foolproof method for accomplishing this conversion is by using the
MOS Technology, Inc. Assembler (available for use on the time share
services of United Computing Systems, Inc.).   If you choose not to
use this method, you will need to convert your source program to
machine code using "paper-and-pencil" techniques.

          You should proceed by constructing a table similar to that
shown in Figure 5-4.



    ----------+--------------------------#----------------------------
    |         |       INSTRUCTION        H        SOURCE CODE        |
    |         +--------+--------+--------#---------------------------+
    | ADDRESS | BYTE 1 | BYTE 2 | BYTE 3 H LABEL   OP CODE   OPERAND |
    +---------+--------+--------+--------#---------------------------+
    |  0200   |   A9   |   01   |        H INIT     LDA       #$01   |
    |  0202   |   8D   |   01   |   17   H          STA       PADD   |
    |  0205   |   EE   |   17   |        H START    INC       PAD    |
    |  0208   |   AD   |   17   |        H READ     LDA       PAD    |
    |  020B   |   49   |   FF   |        H          EOR       #$FF   |
    |  020D   |   4A   |        |        H          LSR       A      |
    |  020E   |   AA   |        |        H          TAX              |
    |  020F   |   CA   |        |        H DELAY    DEX              |
    |  0210   |   10   |   F0   |        H          BPL       DELAY  |
    |  0212   |   30   |   F1   |        H          BMI       START  |
    |  0214   |        |        |        H                           |
    |         |        |        |        H                           |
    ----------+--------+--------+--------#----------------------------

                      Machine Language Code Table
                              FIGURE 5.4


      The source code contained in your assembly language program
(Figure 5-2) is entered into the table first.  A column is provided to
allow you to define the specific address at which an instruction is
located.  The Instruction column provides space for defining one, two,
or three byte instructions.  (Please refer to Appendix B of the Program-
ming Manual or to your Programming Card for specific Op Codes).


                                   63

============================================================================

          As an example, the first source instruction is LDA #$01 which,
when translated, means load the accumulator with the byte stored in the
next program location (hex 01).  This is the "immediate" addressing
mode defined by the "#" symbol.  The Op Code for LDA# is A9.  This
value is entered in the first column under the heading, Instruction.
The next column contains the hex 01 value defined by the source state-
ment.  The initial address for the program is inserted in the "Address"
column as 0200 (an arbitrary selection).  The total instruction LDA #$01
now occupies address locations 0200 and 0201.

          The next available address is 0202 which is inserted in the
"Address" column for the next source instruction.  In this manner, you
will proceed through all of the source statements decoding each and
entering one, two, or three bytes of machine code as required in the
"Instruction" column.  The "Address" column will contain the address of
the first byte of machine code (the Op Code) for each source statement.

          In cases where the operand of the source statement is a symbol,
the address to which the symbol has been equated should be filled in as
the proper machine code.  For example, the source statement "INC PAD"
requires the incrementing of data stored at a location "PAD" defined in
our assembly programs to have the address: PAD = 1700.  Therefore, the
address 1700 is entered as the second and third bytes of the source
statement "INC PAD".  (See Figure 5-4).  Note also that when entering
an address, such as 1700, the low order byte (00) is entered first and
immediately after the Op Code and the high order byte (17) is entered
next as the third byte of the instruction.

          When dealing with branch instructions (BPL, BMI, etc.), you
will need to calculate the exact value of the offset which may be either
positive (branch forward) or negative (branch backward).  You should refer
to Section 4.1.1 of the Programming Manual to explore "Basic Concept of
Relative Branching."  As an example, the source statement "BMI START" (See
Figures 5-2 and 5-4) requires a branch backward by (-15) locations to the
address labelled "START" (from address 0213 backward to 0205 inclusive).


                                   64

============================================================================

(The 2's complement of the -15 displacement is F1 HEX which you should
insert at location 0212).  Had the branch been to a forward location
the positive value of the offset would be inserted rather than the 2's
complement value.


5.3   ENTERING THE PROGRAM

      With the program now reduced to machine language code, you may enter
the program address and data codes listed in Figure 5-4 following the
procedures detailed in Section 2.4.  The procedure for entering the program
is as follows:


              Press Keys              See On Display
              ----------              --------------

              [AD] [0] [2] [0] [0]        0200 xx
              [DA]     [A] [9]            0200 A9
              [+]      [0] [1]            0201 01
              [+]      [8] [D]            0202 8D
              [+]      [0] [1]            0203 01
              [+]      [1] [7]            0204 17
              [+]      [E] [E]            0205 EE
              [+]      [0] [0]            0206 00
              [+]      [1] [7]            0207 17
              [+]      [A] [D]            0208 AD
              [+]      [0] [0]            0209 00
              [+]      [1] [7]            020A 17
              [+]      [4] [9]            020B 49
              [+]      [F] [F]            020C FF
              [+]      [4] [A]            020D 4A
              [+]      [A] [A]            020E AA
              [+]      [C] [A]            020F CA
              [+]      [1] [C]            0210 1C
              [+]      [F] [D]            0211 FD
              [+]      [3] [0]            0212 30
              [+]      [F] [1]            0213 F1


                      Key Sequences: Enter Program
                              FIGURE 5.5


                                   65

============================================================================


5.4  EXECUTING THE PROGRAM

      With the program entered, you may proceed to program execution.
First, if the NMI vector has not been defined previously, enter the
vector as follows:

              Press Keys              See On Display
              ----------              --------------

              [AD] [1] [7] [F] [A]        17FA xx
              [DA]         [0] [0]        17FA 00
              [+]          [1] [C]        17fb 1C

      This procedure insures that the [ST] key will be effective in
tenninating the program.  Now, select the starting address of your
program (0200) and begin execution as follows:

              Press Keys              See On Display
              ----------              --------------

              [AD] [0] [2] [0] [0]        0200 xx
              [GO]                         (DARK)

      The program will now execute.  If your seven selector switches all
are open, you will probably hear no sound from the speaker because the
square wave frequency is too high.  If all selector switches are closed,
you will hear in the speaker the lowest frequency that can be generated
with the program as currently written.  You may experiment with other
combinations of switch settings to hear a variety of tones from the
speaker.

      Depression of the [ST] key will cause the program execution to stop
(the tone will terminate) and the KIM-1 display will relight.  The display
will show the address and data for the next instruction to be executed
(probably 020F or 0210 since this is the delay loop where the program
spends most of its running time).


                                   66

============================================================================

5.5  PROGRAM DEBUGGING AND MODIFICATION

      If your program did not execute correctly, you would follow a
debugging procedure involving the following steps:

          Step 1: List the Program

                  First make sure you have entered the program steps
          correctly.  Select the starting address ([AD] [0] [2] [0] [0])
          and observe that the correct data (A9) is displayed.  Now, using
          the [+] key, step through the remaining program locations check-
          ing for the correct data stored in each location.


          Step 2: Single Step the Program

                  Follow the procedures listed in Section 5-4 for program
          execution but before depressing the [GO] key, place the SST
          slide switch in the ON position.  Now, press the [GO] key and
          the first instruction will be executed.  The display will
          relight indicating that the operating program is again in
          control of the system.  The address displayed will be the
          address of the first byte of the next instruction to be
          executed.  You may press the [GO] key again to execute the
          next instruction or you may choose to investigate changes in
          the contents of machine registers stored in selected memory
          locations (See Figure 3-13).  The procedure detailed in Figure 5-6
          gives a good indication of the various operations you may wish
          to perform in the SST mode.


          Step 3: check the I/O Operations

                  If program entry has been verified and program execution
          in the SST mode appears to be normal, you may wish to verify the
          correct operation of your specific I/O configuration.

                  You should recall that writing to or reading from any
          I/O port is the same as reading from or writing to any other
          memory location in the system.  Therefore, if you select the
          address of an I/O port, the KIM-1 display will show you the hex
          code for the data being read from that address and thus, directly
          indicate the state of each I/O pin in the port.  For example, the


                                   67

============================================================================

          address of the I/O port used for your sample program is 1700.
          Press [AD] [1] [7] [0] [0] and the display will show the hex
          code corresponding to the settings of your selector switches.
          If you change the positions of your selector switches, you will
          see the hex code change in the data field of the display.

                  Now, leave the same address (1700) selected and press
          the [DA] key.  If you press any of the hex keys [0] to [F]
          you will write the data to the I/O port (1700).  Since seven
          of the pins of this I/O port are defined as inputs, only one
          (PA0) will act as an output and will respond to the data
          entered by you from the keyboard.  Try alternating rapidly
          between the [0] and [1] keys and you should hear clicking in
          the speaker indicating that you are successfully toggling
          the PA0 pin.

                  This concept of using the KIM-1 keyboard and display
          to exercise and verify the operation of I/O ports is a
          generally useful technique for debugging the hardware
          portions of most specific applications.


                                   68

============================================================================


      Press Keys              See On Display              Comments
      ----------              --------------              ---------

      [AD] [0] [2] [0] [0]        0200 A9     Select first instruction address
           ----------#-#--
           |   SST   HXH |ON      0200 A9     Set SST to ON; All selector
           ----------#-#--                    switches open
      [GO]                        0202 8D     Accumulator now loaded with $01
      [GO]                        0205 EE     PADD now loaded
      [GO]                        0208 AD     PA0 now toggled
      [GO]                        020B 49     Switch values (PA1-PA7) now
      [GO]                                    loaded
      [GO]                        020D 4A     Accumulator now complemented
      [GO]                        020E AA     Accumulator now right shifted
                                              1 Bit
      [AD] [0] [0] [F] [3]        00F3 xx     Display Accu
      [+]                         00F4 xx     Display Y - INDEX
      [+]                         00F5 00     Display X - INDEX
      [PC]                        020E AA     Restore PC (TAX will
                                              execute next)
      [GO]                        020F CA     Accumulator now loaded in
                                              X-INDEX
      [AD] [0] [0] [F] [3]        00F3 00     Display Accumulator
      [+]                         00F4 xx     Display Y-INDEX
      [+]                         00F5 00     Display X-INDEX (A=0->X)
      [PC]                        020F CA     Restore PC
      [GO]                        0210 10     DEX now completed
      [AD] [0] [0] [F] [5]        00F5 FF     Display X-INDEX (X<0)
      [PC]                        0210 10     Restore PC
      [GO]                        0212 30     No branch (Result of DEX
                                              not positive)
      [GO]                        0205 EE     Branch (Result of DEX is
                                              negative).


                      SST Mode: Sample Operation
                              FIGURE 5.6


                                   69

============================================================================

                                  BLANK


                                   70

============================================================================

                                CHAPTER 6

                          EXPANDING YOUR SYSTEM


      In earlier sections you have learned that the MCS 6502 Microprocessor
Array is capable of directly addressing up to 65,536 locations (bytes) of
memory.  (Usually abbreviated to 65K where "1K" for the remainder of this
section is to mean 1024 memory locations).  In this section, we will
discuss first the techniques for adding memory or I/O locations to the
system and next, the proper handling of interrupt vectors in an expanded
system.


6.1  MEMORY AND I/O EXPANSION

      In the KIM-1 system, the management of input/output data is handled
exactly the same as transfers to or from any other memory location in the
system.  There are no instructions dealing specifically with input/output
transfers.  Instead, transfer of data is accomplished by reading from or
writing to registers connected to the data bus and to I/O pins in specific
I/O interface devices (such as the 6530 array).  These registers have a
specific address in the system just as does any other memory location.
Therefore, when we speak of expanding the memory of the KIM-1 system, we
are defining the methods for expanding both the real memory (RAM, ROM,
PROM, etc.) as well as the I/O ports since they are both treated exactly
alike as far as address assignments are concerned.


                                   71

============================================================================

      The first and most easily implemented memory expansion is the
addition of up to 4K of memory space.  You will recall that
the lowest 8K memory locations are defined by an address decoder included
on the KIM-1 module, (Device U4 on the schematic).  The eight outputs
of this decoder (K0 to K7) each define a 1K block of addresses in the
lowest 8K of the memory map.  Three of the outputs (K5, K6, K7) are
used to select ROM, RAM, I/O and Timer locations on the two 6530 arrays
while a fourth (K0) is used to select the 1024 locations of the static
RAM memory.  The remaining four outputs (K1, K2, K3, K4) are not used
on the KIM-1 module but instead, are brought out to the Expansion connector
for use as chip selects for memory or I/O additions.

      Figure 6-1 shows the proper method for deriving the four chip select
signals for the additional 4K of memory.  Note that one of input pins of
the decoder (D) was brought out to the Application Connector.  It was
this pin which we asked you to connect to ground in Chapter 2 of this
manual.  As long as this point remains connected to ground, the decoder
will always select the lowest 8K addresses of the memory field regardless
of the state of AB13, AB14, and AB15.

      If you wish to expand the memory and I/O address space beyond the
lower 8K addresses, you must arrange to de-select the lower 8K memory
block while selecting some other 8K block.  One suggested method for
expanding beyond the lower 8K space is shown in Figure 6-2.

      Note that the three high order address bits (AB13, AB14, AB15) are
connected to a decoder.  The eight outputs of the decoder act to divide
the total 65K memory space into eight blocks of 8K each (8K0, 8K1, etc.).
Now, the 8K0 output may be returned as the fourth inpur (D) to the de-
coder (U4) on the KIM-1 module causing the proper selection and de-selec-
tion of this block within the total address space.  The remaining seven
outputs (8K1 to 8K7) may be used to select and de-select the additional
decoders shown in Figure 6-2.  You need add only as many decoders (one
for each 8K block of memory) as you need for your desired memory expansion.


                                   72

============================================================================

      A word of caution is in order when you decide to add memory to your
system.  You have noticed the inclusion of the line receivers for the
AB10, AB11, and AB12 signals, (See Figure 6-2).  These devices are
included because of loading limitations placed on the address bus lines
of the 6502 array (Each such line is capable of driving one standard
TTL load and l30pf of capacity. See Appendix C).


                            VCC O--+----+----+-----
                                   |    |    |    |
                                  -+-  -+-  -+-  -+-
                                  | |  | |  | |  | |
                                  | |  | |  | |  | |
                                  | |  | |  | |  | |
                                  -+-  -+-  -+-  -+-
     -------------K0               |    |    |    |
     | U4       0+-----------------o----+----+----+----- 1K X 8  RAM ON
     |           |                 |    |    |    |      KIM-1 BOARD
     |           |K1               |    |    |    |
     | 74LS145  1+---------------- |    |    |    |
     |           |               | |    |    |    |
     |           |K2             | |    |    |    |
     |          2+-------------- | |    |    |    |
     |           |             | | |    |    |    |
     |           |K3           | | |    |    |    |
     |          3+------------ | | |    |    |    |
     |           |           | | | |    |    |    |
AB10 |           |K4         | | | |    |    |    |
-----+A         4+---------- | | | |    |    |    |
     |           |         | | | | |    |    |    |
AB11 |           |K5       | | | | |    |    |    |
-----+B         5+-------o-+-+-+-+-+----o----+----+-----\
     |           |       | | | | | |         |    |      |
AB12 |           |K6     | | | | | |         |    |      |  2-6530 DEVICES
-----+C         6+-------+-+-+-+-+-+---------o----+-----  >
     |           |       | | | | | |              |      |  ON KIM-1 BOARD
     |           |K7     | | | | | |              |      |
  ---+D         7+-----o-+-+-+-+-+-+--------------o-----/
  |  -------------     | | | | | | |
  |                    | | | | | | |
  -------------------- | | | | | | |
                     | | | | | | | |
                    -+++++++++++++++-
                    |K|J|H|F|E|D|C|B|<--- APPLICATION CONNECTOR
                    -++-+-+++++++++--
                     |     | | | |
                    -+-    v v v v
                     -     K K K K
                           4 3 2 1
                           AVAILABLE FOR 4K
                           EXPANSION (PULL-UP REQ'D)


                             4K Expansion
                              FIGURE 6.1


                                   73

============================================================================

                                        VCC O-+--+--+---
                                              |  |  |  |
                                             -+--+--+--+-
                                             | || || || |
                                             | || || || |   1K RAM ON
                                             | || || || |   KIM-1
                                             -+--+--+--+-     |
                             -------------K0  |  |  |  |      |
                    AB12     | U4       0+----+--+--+--o------+-------------
                    | AB11   |           |K1  |  |  |                      |
                    | | AB10 | 74LS145  1+----+--+--+--------------------- |
                    | | |    |           |K2  |  |  |                    | |
                    | | |    |          2+----+--+--+------------------- | |
                    | | |    |           |K3  |  |  |                  | | |
                    | | |    |          3+----+--+--+----------------- | | |
                    | | |    |           |K4  |  |  |                | | | |
                    +-+-+----+A         4+----+--+--+--------------- | | | |
                    | | |    |           |K5  |  |  |              | | | | |
    AB15            | +-+----+B         5+----o--+--+-- \          | | | | |
    | AB14          | | |    |           |K6     |  |   |  2-6530  | | | | |
    | | AB13        | | +----+C         6+-------o--+--  >         | | | | |
    | | |           | | |    |           |K7        |   |  DEVICES | | | | |
    | | |           | | | ---+D         7+----------o-- /          | | | | |
    | | |           | | | |  -------------                         | | | | |
    | | |           | | | |                                        | | | | |
    | | |           | | | ---------------------------------------- | | | | |
    | | |           | | |                                        | | | | | |
----+-+-+-----------+-+-+--                                     -+++++++++++-
|   T S R           P N M |                                  (A)|K|F|E|D|C|B|
----+-+-+-----------+-+-+--                                     -++++++++++--
    | | |           | | |                                        |(4K MEMORY
    | | |           | | |  --------------------------------------- OR I/O)
    | | |           | | |  |
    | | |           | | ---+--------------------
    | | |           | |    |                   |
    | | |           | -----+-------------      |
    | | |           |      |            |      |
    | | |           -------+------      |      |
    | | |                  |     |      |      |
    | | |                  |   --+--  --+--  --+--   (3 LINE RECEIVERS
    | | |                  |   \   /  \   /  \   /    TYPE 8795 SUGGESTED)
    | | |                  |    \ /O-- \ /O-- \ /O--
    | | |                  |     o   |  o   |  o   |
    | | |                  |     |   |  |   |  |   |
    | | |                  |     |   ---+---+--+---+
    | | |                  |     |      |      |   |
    | | |                  |     |      |      |  -+-
    | | |                  |     |      |      |   -
    | | | -------------8K0 |     |      |      |      -------------K8
    | | +-+A         0+-----     |      |      +------+A         0+--->\
    | | | |           |8K1       |      |      |      |           |K9   |
    | +-+-+B         1+--------- |      +------+------+B         1+---> |
    | | | |           |8K2     | |      |      |      |           |K10  |
    +-+-+-+C         2+--------| +------+------+------+C         2+---> |
    | | | |           |8K3    || |      |      |      |           |K11  |
 ---+-+-+-+D         3+--     |--+------+------+------+D         3+---> |
 |  | | | |           |8K4    |  |      |      |      |           |K12   > *
-+- | | | |          4+--     |  |      |      |      |          4+---> |
 -  | | | |           |8K5    |  |      |      |      |           |K13  |
    | | | |          5+-------|  |      |      |      |          5+---> |
    | | | |           |8K6   ||  |      |      |      |           |K14  |
    | | | | 74142    6+------||  |      |      |      | 74145    6+---> |
    | | | |           |8K7  |||  |      |      |      |           |K15  |
    | | | |          7+---- |||  |      |      |      |          7+--->/
    | | | -------------   | |||  |      |      |      -------------
                          | |||  |      |      |
                          | ||   |      |      |
                          | |    |      |      |
                          |      |      |      |
                          |      |      |      |      -------------K58
                          |      |      |      +------+A         0+--->\
                          |      |      |      |      |           |K59  |
                          |      |      +------+------+B         1+---> |
  NOTE:                   |      |      |      |      |           |K60  |
  PULL UPP RESISTOR IS    |      +------+------+------+C         2+---> |
  REQ'D IF 74145'S        |      |      |      |      |           |K61  |
  ARE USED.               -------+------+------+------+D         3+--->  > *
                                 |      |      |      |           |K62  |
                                 |      |      |      |          4+---> |
                                 |      |      |      |           |K63  |
                                 |      |      |      |          5+---> |
                                 |      |      |      |           |K64  |
                                 |      |      |      | 74145    6+--->/
                                 |      |      |      |           |K65
                                 |      |      |      |          7+-------->
                                 |      |      |      -------------(SEE 6.2)
                                                               VECTOR SELECT
* = 8K MEMORY OR I/O


                                   74

============================================================================


Before deciding how to expand your system, we recommend a careful study
of all of the loading limitations of the KIM-1 signals since almost
certainly you will require additional buffering circuits if correct
operation is to be achieved.


6.2  INTERRUPT VECTOR MANAGEMENT

      We have referred several times in earlier sections to the interrupt
features of the 6502 Microprocessor Array.  We suggest now a careful
reading of Section 9 of the Programming Manual for the subject "Reset
and Interrupt Considerations".

      In summary, there are three possible types of interrupt: Reset, NMI,
and IRQ.  Each will occur in response to an activation of one of the three
pins of the 6502 array (RST, NMI, IRQ).  In response to these inputs, the
6502 array will fetch the data stored at a specific pair of addresses and
load the data fetched into the program counter.  The addresses are hardware
determined and not under the control of the programmer.  The specific
addresses for each type of interrupt are:

              FFFA, FFFB - NMI Vector
              FFFC, FFFD - RST Vector
              FFFE, FFFF - IRQ Vector

You will note that these addresses define the highest six locations in
the 65K memory map.

      In the KIM-1 system, three address bits (AB13, AB14, ABl5) are not
decoded at all.  Therefore, when the 6502 array generates a fetch from
FFFC and FFFD in response to a RST input, these addresses will be read
as 1FFC and 1FFD and the reset vector will be fetched from these locations.
You now see that all interrupt vectors will be fetched from the top 6
locations of the lowest 8K block of memory which is the only memory block
decoded for the unexpanded KIM-1 system.


                                   75

============================================================================

      It is typical in any system to store the interrupt vectors in ROM
so that they are immediately available after power-on.  However, it is
desirable that for the NMI and IRQ interrupts, the programmer be allowed
to define as a variable the exact vector to which these interrupts will
direct the system.  Accordingly, the NMI and IRQ vector locations contain
an indirect jump instruction referencing a RAM location into which the
programmer will store the specific vector for the two types of interrupt.
In the KIM-1 system, locations 17FA and 17FB contain the actual NMI vector
and 17FE with 17FF contain the actual 0 vector.  The RST vector is not
handled in this manner and always directs the system to the first step
of the power-on initialization routine.

      But what happens if we expand our memory above the lowest 8K block
included in the KIM-1 system?  Recall that we now must use ABl3, ABT4,
and AB15 to decode the additional address locations of the memory.  By so
doing, the interrupt vector locations are no longer located in the K7 memory
block since the decoder (U4) is de-selected in response to the addresses
generated by the 6502 array in fetching the interrupt vectors (FFFA for
example).  We would have the same problem even in an unexpanded system
if we wished to use a RST vector and initialization routine different
than what the KIM-1 system provides and if the RST vector was to be
located in a 1K block lower than K7 (K0 for instance).

      The solution to this dilemma is to generate logically a special
signal for interrupt select.  Referring to Figure 6-2, a special signal
called "Vector Select" is created to define the highest 1K memory black
(K65).  The fetch of any interrupt vector will cause this signal to
go low "Select".  Assuming that the K65 state is not used to select RAM,
this signal may be "wire-or'd" with any one of the other "K" signals
(K0 to K64) to define exactly which 1K block is to contain the interrupt
vectors.


                                   76

============================================================================

      As an example, assume that you have connected the K65 "Vector Select"
line to the K0 line.  When a RST occurs, the 6502 array generates a fetch
from locations FFFC and FFFD.  These addresses cause K65 to be selected
which, in turn, accesses the K0 field of the memory and causes the actual
fetch of the RST vector from locations 03FC and 03FD.  (Had you chosen to
connect K65 to K7, the fetch of the reset vectors would occur from
locations 1FFC and 1FFD).

      In this way, the highest six addresses of any 1K block of memory may
be used to supply the interrupt vectors for the system.  If desired, a
switch could be installed to allow you to select different areas of memory
as the source locations for the interrupt vectors.  (By the way, we
selected the 75145 type decoders in Figure 6-2 specifically to allow the
"wire-or" of K65 with any other K.  This is possible because the 75145
decoder is provided with open-collector outputs which allows "wire-or"
of several states using an external load resistor.)

      An even simpler arrangement using the "Vector Select" approach is
shown in Figure 6-3.  Here, the KIM-1 system is assumed to have only the
lower 8K of memory in place.  The address decoder (U4) is de-selected
using the AB15 signal which becomes "true" whenever an interrupt vector
fetch is initiated by the system.  The same signal (AB15) is inverted and
"wire-or'd" through a switch to the K0 or the K7 chip select lines.  Now,
depending upon the position of the switch, interrupt vectors will be
fetched from the top 6 addresses of either block K0 or K7.  K0 in the
KIM-1 system is the RAM and K7 is the ROM in the 6530-002 array (the
operating program).  In this way, you may have two different sets of inter-
rupt vectors in your system and may select which set is to be used with a
simple switch.


                                   77

============================================================================

                               +5V O--+------
                                      |     |
                                     -+-   -+-
                                     | |   | |
                                     | |   | |
                                     | |   | |
                                     -+-   -+-
                   -------------K0    |     |
                   | U4       0+------o-----+-----> 1K RAM IN PAGE 0-3
                   |           |      |     |
                   |           |K1    |     |
                   | 74LS145  1+---   |     |
                   |           |      |     |
                   |           |K2    |     |
                   |          2+---   |     |
                   |           |      |     |
                   |           |K3    |     |
                   |          3+---   |     |
                   |           |      |     |
 AB15         AB10 |           |K4    |     |
  |           -----+A         4+---   |     |
  |                |           |      |     |
  |           AB11 |           |K5    |     |
  |           -----+B         5+---   |     |
  |                |           |      |     |
  |           AB12 |           |K6    |     |
  |           -----+C         6+---   |     |
  |                |           |      |     |
  |                |           |K7    |     |
  |             ---+D         7+------+-----o-----> 6530-002 (ROM) WHICH
  |             |  -------------      |     |       CONTAINS KIM-1 MONITOR
  |    KIM-1    |                     |     |
 -|-------------|---------------------|-----|-----
  |             |                     |     |
  |             -----------           O    /O
  |                       |               /   Switch
  |                       |              O
  |                  1K   |              |
  |                ------ |              |
  |           +5V--+    +-+              |
  |            |   ------ |              |
  |            |          |              |
  |           -+-         |              |
  |           | |         |              |
  |           | |1K       |              |
  |           | |         |              |
  |   |\      -+- |\      |    |\        |
  |   | \      |  | \     |    | \       |
  ----+  >O----+--+  >O---+----+  >O------
      | /         | /          | /   VECTOR SELECT
      |/          |/           |/

            7405 OR 7406

                            Vector Selection
                               FIGURE 6.3
                                   78

============================================================================

                                CHAPTER 7

                          WARRANTY AND SERVICE


      Should you experience difficulty with your KIM-1 module and
be unable to diagnose or correct the problem, you may return the unit
to MOS Technology, Inc. for repair.


7.1  IN-WARRANTY SERVICE

      All KIM-1 series Microcomputer Modules are warranted by
MOS Technology, Inc. against defects in workmanship and materials
for a period of ninety (90) days from date of delivery.  During the
warranty period, MOS Technology, Inc. will repair or, at its option,
replace at no charge components that prove to be defective provided
that the module is returned, shipping prepaid, to:

              KIM Customer Service Department
              MOS Technology, Inc.
              950 Rittenhouse Road
              Norristown, Pennsylvania  19401

This warranty does not apply if the module has been damaged by accident
or misuse, or as a result of repairs or modifications made by other than
authorized personnel at the above captioned service facility

      No other warranty is expressed or implied.  MOS Technology, Inc. is
not liable for consequential damages.


                                   79

============================================================================

7.2  OUT-OF-WARRANTY SERVICE

      Beyond the ninety (90) day warranty period, KIM modules will be
repaired for a reasonable service fee.  All service work performed by
MOS Technology, Inc. beyond the warranty period is warranted for an
additional ninety (90) day period after shipment of the repaired module.


7.3 POLICY ON CHANGES

      All KIM series modules are sold on the basis of descriptive
specifications in effect at the time of sale.  MOS Technology, Inc.
shall have no obligation to modify or update products once sold.
MOS Technology, Inc. reserves the right to make periodic changes or
improvements to any KIM series module.


7.4 SHIPPING INSTRUCTIONS

      It is the customer's responsibility to return the KIM series
module with shipping charges prepaid to the above captioned service
facility.

      For in-warranty service, the KIM module will be returned to the
customer, shipping prepaid, by the fastest economical carrier.

      For out-of-warranty service, the customer will pay for shipping
charges both ways.  The repaired KIM module will be returned to the
customer C.O.D. unless the repairs and shipping charges are prepaid
by the customer.

      Please be certain that your KIM module is safely packaged when
returning it to the above captioned service facility.


                                   80

============================================================================

                               APPENDIX A


 --------+-------------------+------+---------------------------------------
 | ITEM  | PART              | QTY. | DESCRIPTION                          |
 +-------+-------------------+------+--------------------------------------+
 |  1.   | Ul                | 1    | 6502 Microprocessor                  |
 |  2.   | U2                | 1    | 6530 ROM RAM I/O Chip-02             |
 |  3.   | U3                | 1    | 6530 ROM RAM I/O Chip-03             |
 |  4.   | U5 through U12    | 8    | 6102 RAM 500ns Acc,0ns               |
 |  5.   | U18 through U23   | 6    | 7 SEG .3" Red Display                |
 |  6.   | U25               | 1    | 556 Timer IC                         |
 |  7.   | U27               | 1    | 565 Phase Lock Loop                  |
 |  8.   | U28               | 1    | 311 Comparator                       |
 |  9.   | U24               | 1    | 74145 BCD Decoder IC                 |
 |  10.  | U13 & U14         | 2    | 74125 TRI STATE Buffer               |
 |  11.  | u15               | 1    | 7400 Quad NAND IC                    |
 |  12.  | U16               | 1    | 7404 Hex Inverter IC                 |
 |  13.  | U17               | 1    | 7406 Hex Inv. O/C IC                 |
 |  14.  | U26               | 1    | 7438 Quad NAND O/C IC                |
 |  15.  | CR1,2,3,4,&8      | 5    | 20 mA. 50v Diode - 1N914             |
 |  16.  | CR5, CR6          | 2    | 1A 50v Diode - 1N4001                |
 |  17.  | CR7               | 1    | 6.2v 1/2W Z. Diode - 1N4735          |
 |  18.  | Q7                | 1    | NPN Transistor B>20, VCE>12 - 2N5371 |
 |  19.  | Q1 through Q6     | 6    | PNP Transistor B>20, VCE>6  - 2N5375 |
 |  20.  | 04 & 05           | 2    | 47Ko ~10% 1/4w Resistor              |
 |  21.  | R1,2,3,4, & 6     | 5    | 3.3Ko ~10% 1/4w Resistor             |
 |  22.  | R34 & P50         | 2    | 2.2Ko ~10% 1/4w Resistor             |
 |  23.  | Rl2-R17, R41-R46  | 12   | l.0Ko ~10% 1/4w Resistor             |
 |  24.  | R35 through R40   | 6    | 560o ~10% 1/4w Resistor              |
 |  25.  | R18-R23, R47      | 7    | 220o ~10% 1/4w Resistor              |
 |  26.  | R33               | 1    | 47o ~l0% 1/4w Resistor               |
 |  27.  | R52               | 1    | 5 Meg. ~10% 1/4w Resistor            |
 |  28.  | R51               | 1    | 30Ko ~5% 1/4w Resistor               |
 |  29.  | R7,R8,R9,R10&R1l  | 5    | l0Ko ~5% 1/4w Resistor               |
 |  30.  | R48, R49          | 2    | 150o ~5% 0                           |
 |  31.  | R26 through R32   | 7    | 82o ~05% 0                           |
 |  32.  | VR1               | 1    | 5Ko Potentiometer                    |
 |  33.  | C2, C3, C6        | 3    | .22~10% uf.>12 wv. cap               |
 |  34.  | C1, C4            | 2    | 1uf+80-l0%>12WV Cap                  |
 |  35.  | CS                | 1    | .33 uf~l0%>12WV Cap                  |
 |  36.  | C7,C8,C15,C16,C17 | 5    | .1uf+80-l0%>12WV Cap                 |
 |  37   | C9, C10, C11      | 3    | .0068uf~l0%>l2WV                     |
 |  38.  | C12               | 1    | .047uf~10%>l2WV                      |
 |  39.  | C13               | 1    | .022uf~10%>l2WV                      |
 |  40.  | C14               | 1    | .001uf~l0%>l2WV                      |
 |  41.  |                   | 1    | 44 Pin Edge Conn. (Vector #R644)     |
 |  42.  | X1                | 1    | 1 MHz XTAL                           |
 |  43.  |                   | 1    | PCB.                                 |
 |  44.  |                   | 1    | 24 Key KBD                           |
 |  45.  |                   | 6    | Rubber Pads                          |
 |  46.  |                   | 1    | Shipping Bag (Static Free)           |
 |  47.  |                   | 1    | Shipping Box                         |
 |  48.  |                   | 1    | Hardware Manual                      |
 |  49.  |                   | 1    | Software Manual                      |
 |  50.  |                   | 1    | KIM Manual                           |
 |  51.  |                   | 1    | Warranty Card                        |
 |  52.  |                   | 1    | Wall Chart                           |
 |  53.  |                   | 2    | #2 x 1/4 SS Screws (Keyboard)        |
 |  54.  |                   | 1    | Program Card                         |
 |  55.  | C18               | 1    | 10pf CAP                             |
 |  56.  | R53               | 1    | 330K 1/4w Resistor                   |
 |  57.  | U4                | 1    | 74L5145 BCD Decoder lC               |
 --------+-------------------+------+---------------------------------------


                                  A-1

============================================================================

                              APPENDIX B


                      Sorry, too complex to draw.


                                  12

============================================================================

                              APPENDIX C


                          IN CASE OF TROUBLE



SYMPTOM:  Display Not Lit

          1.  Test +5 volt power supply.  Using a VOM check for +5
              volts between Pin E-21 and E-22.  Also check for +5
              volts between Pin A-A and Pin A-1.  KIM-1 power supply
              should be set at +5v ~5%.

          2.  Test KB/TTY option wiring (Figure 2-4).  Pin A-21 should
              not be connected to Pin A-V.

          3.  Make sure decoder is enabled.  See Figure 2-2 and insure
              that Pin A-K is connected to ground.

          4.  Depress the reset key and check all other keys to insure
              that no key is stuck.

          5.  Place a VOM between Pin E-21 (+5v) and Pin E-7 (Reset).
              Alternately depress and release the reset key checking to
              see if the voltage swings from (>4v) to (<1v).

          6.  Test Pin E-V (P2) with an oscilloscope and insure 1 MHz
              operation.


SYMPTOM:  Cannot Dump to Audio Tape
          Cannot Load From Audio Tape

          1.  Test +12 volt power supply.  Using a VOM check for +12
              volts between Pin A-N (+12v) and Pin A-1 (GND).  Set
              power supply to +12v ~5%.  (See Figure 2-2).

          2.  Check volume control on the tape recorder (Set at half
              way point).


                                  C-1

============================================================================

          3.  Make sure that you are using the proper tape output pin.
              See Figure 2-3.

          4.  Check the tape interface circuit by disconnecting the
              tape recorder and shorting Pin A-P (Audio Out High) to
              Pin A-L (Audio In).  Set up KIM-1 monitor to dump a
              section of memory.  Using an oscilloscope observe data
              at Pin E-X (PLL TEST).  See Appendix E for correct data
              format and calibration procedure.

          5.  Record voice on a section of tape and play it back to insure
              that the tape recorder is working.  Connect another tape
              recorder to the system or try another cassette.

          6.  Make sure Status Register (Location 00F1) has been loaded
              with data value "00".

          7.  Make sure Tone Control is set to High.


SYMPTOM:  TTY Interface Problems

          1.  Make sure that Pin A-21 is connected to Pin A-V (Figure 2-4)
              to allow TTY operation.

          2.  Compare the connections on Figure 2-4 with interface
              schematics in your TTY manual ( or any other serial
              teleprinter ).

          3.  Depress the reset key on the KIM-1 keyboard followed by
              a rub out character from the TTY.


                                   C-2

============================================================================

                                APPENDIX D



   Simple power supply using a LM309 5V 1A and a 78L12 12V 100mA regulator.



                          Suggested Power Supply


                                   D-1

============================================================================

                                APPENDIX E

                             AUDIO TAPE FORMAT


      Data is stored out onto your audio cassette recorder in a specific
format designed to insure an error free recovery.  In the unlikely event
that a playback error does occur, several "ERROR DETECTION" methods are
incorporated to warn you of this condition.

      Data is transmitted to the tape recorder in the form of serial
"ASCII" encoded characters (seven data bits plus Parity bit).  Data
retrieved from the memory is converted into this form by separating each
byte into two half bytes.  The half bytes are then converted into their
ASCII equivalents.

      Each record transmitted begins with a leader of one hundred "SYN"
characters (ASCII 16) followed by a * character (ASCII 2A).  During
playback, this pattern allows your micro-computer to detect the start of
a valid data record and synchronize to the serial data stream.  Following
the *, the record identification number (ID), and starting address low
(SAL) and the starting address high (SAH) are transmitted.  The data
specified by the starting (SAL, SAH) and ending limits (EAL, EAH) is
transmitted next followed by a "/" character (ASCII 2F) to indicate the
end of the data portion of the record.  Following the "/" two "CHECK-SUM"
bytes are transmitted for comparison with a calculated check-sum number
during playback to further insure that a proper data retrieval has taken
place.  Two "EOT" characters (ASCII 04) mark the end of record transmission.


                                   E-1

============================================================================

      Each transmitted bit begins with a 3700 hertz tone and ends with
a 2400 hertz tone.  "Ones" have the high to low frequency transition
at one-third of the bit period.  "Zeros" have the transition at two-
thirds of the period.  During playback the 565 phase locked loop locks
to, and tracks these two frequencies producing (through the 311
comparator) a logic "1" pulse of one-third the bit period for a "One".
A pulse two thirds the bit period is likewise produced for a "Zero".
Your microcomputer uses a software controlled algorithm for converting
this signal into eight bit data words.

      The frequency shift keyed phase lock loop method of data recovery
is relatively insensitive to amplitude and phase variations.  The "FREE
RUNNING" frequency of the phase lock loop has been adjusted at the factory
to a frequency half way between the two data frequencies (called the Center
Frequency).  This adjustment is accomplished by strapping Pin A-P (Audio
Out High) to Pin A-L (Audio In).  A program starting at address 1A6B HEX
provides the center frequency reference that allows the loop to be
adjusted by potentiometer VR1.  Pin E-X (PLL TEST) is monitored with a
voltmeter while the pot is rotated until the voltmeter reading is at the
transition point between a logical "1" (+5v) and "0" (GND).


THIS ADJUSTMENT HAS BEEN FACTORY PRESET AND SHOULD ONLY REQUIRE
ADJUSTMENT DUE TO COMPONENT REPLACEMENT.'


                                   E2

============================================================================

   |                                                           |
   |                                                           |
   |<------------------- 7.452 Msec -------------------------->|
   |                                                           |
   |                 |                 |                       |
   |   2.484 Msec    |   2,484 Msec    |      2.484 Msec       |
   |<--           -->|<--           -->|<--                 -->|
   |    9 PULSES     |    9 PULSES     |       6 PULSES        |
   |                 |                 |                       |
 ----------------------------------------- --- --- --- --- --- ----
 ||||||||||||||||||||||||||||||||||||||| | | | | | | | | | | | ||||
 --------------------------------------- --- --- --- --- --- ------


   -------------------------------------                       ----  LOGIC
   |                                   |                       |      (0)
 ---                                   -------------------------
                                        \                       \
                                         \                       \
                                          \                       \
                                           \                       \
                                            \                       \
   |                 |                       |                       |
   |                 |                       |                       |
   |<-- 9 PULSES  -->|<--    6 PULSES     -->|<--     6 PULSES    -->|
   |                 |                       |                       |
   |                 |                       |                       |
 ----------------------- --- --- --- --- --- --- --- --- --- --- --- ----
 ||||||||||||||||||||| | | | | | | | | | | | | | | | | | | | | | | | ||||
 --------------------- --- --- --- --- --- --- --- --- --- --- --- ------
                                             |
                                             |
   -------------------                       |                       ----
                     |                       |                       | LOGIC
   |                 -------------------------------------------------  (1)
   |                 |                       |                       |
   |                 |                       |                       |
   |                                                                 |
   |<----------------------  1 BIT  -------------------------------->|
   |                                                                 |




 -----+-------------+-+--+---+---+--------------+-+---+---+---+---+------
      |<-- 100 "SYN"|*|ID|SAL|SAH|<--  DATA  -->|/|CKL|CKH|EOT|EOT|
   ---+-------------+-+--+---+---+--------------+-+---+---+---+---+--------


                            Audio Tape Format
                                FIGURE E-1


                                   E-3

============================================================================

                                APPENDIX F

                            PAPER TAPE FORMAT


      The paper tape LOAD and DUMP routines store and retrieve data in
a specific format designed to insure error free recovery.  Each byte
of data to be stored is converted to two half bytes.  The half bytes
(whose possible values are 0 to F HEX) are translated into their ASCII
equivalents and written out onto paper tape in this form.

      Each record outputted begins with a ";" character (ASCII 3B) to
mark the start of a valid record.  The next byte transmitted (18 HEX) or
(24 10) is the number of data bytes contained in the record.  The record's
starting address High (1 byte, 2 characters), starting address Lo (1 byte,
2 characters), and data (24 bytes, 48 characters) follow.  Each record is
terminated by the record's check-sum (2 bytes, 4 characters), a carriage
return (ASCII OD), line feed (ASCII 0A), and six "NULL" characters
(ASCII 00).

      The last record transmitted has zero data bytes (indicated by ;00)
The starting address field is replaced by a four digit Hex number repre-
senting the total number of data records contained in the transmission,
followed by the records usual check-sum digits.  A "XOFF" character ends
the transmission.


180000FFEEDDCCBBAA0099887766554433221122334455667788990AFC
--    --  --  --  --  --  --  --  --  --  --  --  --  ----
;0000010001
---    ----


                                   F-1

============================================================================

      During a "LOAD" all incoming data is ignored until a ";" character
is received.  The receipt of non ASCII data or a mismatch between a
records calculated check-sum and the check-sum read from tape will cause
an error condition to be recognized by KIM.  The check-sum is calculated
by adding all data in the record except the ";" character.

      The paper tape format described is compatible with all other
MOS Technology, Inc. software support programs.


                                   F-2

============================================================================

                                APPENDIX G


                          6502 CHARACTERISTICS


Clocks (o1, o2)

      The MCS 6502 is supplied with an internal clock generator.  The
      frequency of this clock is crystal controlled.


Address Bus (A0-A15)

      These outputs are TTL compatible, capable of driving one standard
      TTL load and 130pf.


Data Bus (D0-D7)

      Eight pins are used for the data bus.  This is a bi-directional bus,
      transferring data to and from the device and peripherals.  The
      outputs are tri-state buffers capable of driving one standard
      TTL load and 130pf.


Ready (RDY)

      This input signal allows the user to single cycle the microprocessor
      on all cycles except write cycles.  A negative transition to the low
      state during or coincident with phase one (o1) will halt the micro-
      processor with the output address lines reflecting the current
      address being fetched.  This condition will remain through a
      subsequent phase two (o2) in which the Ready signal is high.  This
      feature allows microprocessor interfacing with low speed PROMS as
      well as fast (max  2 cycle) Direct Memory Access (DMA).  If Ready
      is low during a write cycle, it is ignored until the following
      read operation.


                                   G-1

============================================================================

Interrupt Request (IRQ)

      This TTL level input requests that an interrupt sequence begin
      within the microprocessor.  The microprocessor will complete the
      current instruction being executed before recognizing the request.
      At that time, the interrupt mask bit in the Status Code Register
      will be examined.  If the interrupt mask flag is not set, the
      microprocessor will begin an interrupt sequence.  The Program
      Counter and Processor Status Register are stored in the stack.
      The microprocessor will then set the interrupt mask flag high
      so that no further interrupts may occur.  At the end of this
      cycle, the program counter low will be loaded from address FFFE,
      and program counter high from location FFFF, therefore trans-
      ferring program control to the memory vector located at these
      addresses.  The RDY signal must be in the high state(for control
      to the memory vector) located at these addresses.  The RDY signal
      must be in the high state for any interrupt to be recognized.
      A 3Ko external register should be used for proper wire-OR operation.


Non-Maskable Interrupt (NMI)

      A negative going edge on this input requests that a non-maskable
      interrupt sequence be generated within the microprocessor.

      NMI is an unconditional interrupt.  Following completion of the
      current instruction, the sequence of operations defined for IRQ
      will be performed, regardless of the state of the interrupt mask flag.
      The vector address loaded into the program counter, low and high,
      are locations FFFA and FFFB respectively.  The instructions
      loaded at these locations causes the microprocessor to branch to
      a non-maskable interrupt routine in memory.

      NMI also requires an external 3Ko resistor to Vcc for proper
      wire-OR operations.


                                   G-2

============================================================================

      Inputs IRQ and NMI are hardware interrupts lines that are sampled
      during o2 (phase 2) and will begin the appropriate interrupt
routine on the o1 (phase 1) following the completion of the
current instruction.


Set Overflow Flag (s.o.)

      This TTL level input signal allows external control of the
      overflow bit in the Status Code Register.


SYNC

      This output line is provided to identify those cycles in which
      the microprocessor is doing an Op Code fetch.  The SYNC line
      goes high during o1 of an Op Code fetch and stays high for the
      remainder of that cycle.  If the RDY line is pulled low during
      the o1 clock pulse in which SYNC went high, the processor will
      stop in its current state and will remain in the state until
      the RDY line goes high.  In this manner, the SYNC signal can be
      used to control RDY to cause single instruction execution.


RESET

      This input is used to reset or start the microprocessor from a
      power down condition.  During the time that this line is held
      low, writing to or from the microprocessor is inhibited.  When
      a positive edge is detected on the input, the microprocessor
      will immediately begin the reset sequence.

      After a system initialization time of six clock cycles, the mask
      interrupt flag will be set and the microprocessor will load the
      program counter from the memory vector locations FFFC and FFFD.
      This is the start location for program control.

      After Vcc reaches 4.75 volts in a power up routine, reset must
      be held low for at least two clock cycles.

      When the reset signal goes high following these two clock cycles,
      the microprocessor will proceed with the normal reset procedure
      detailed above.


                                   G-3

============================================================================

                               APPENDIX H

                          6530 CHARACTERISTICS


The MCS 6530 is designed to operate in conjunction with the MCS 650X
Microprocessor Family.  It is comprised of a mask programmable 1024 x 8
ROM, a 64 x 8 static RAM, two software controlled 8 bit bi-directional
data ports allowing direct interfacing between the microprocessor unit
and peripheral devices, and a software programmable interval timer
with interrupt, capable of timing in various intervals from 1 to 262,144
clock periods.










                         MCS 6530 Block Diagram
                                FIGURE H.1


                                   H-1

============================================================================

Reset (RES)

      During system initialization a Logic "0" on the RES input will
      cause a zeroing of all four I/O registers.  This in turn will
      cause all I/O buses to act as inputs thus protecting external
      components from possible damage and erroneous data while the
      system is being configured under software control.  The Data
      Bus Buffers are put into an OFF-STATE during Reset.  Interrupt
      capability is disabled with the RES signal.  The RES signal must
      be held low for at least one clock period when reset is required.


Input Clock

      The input clock is a system Phase Two clock which can be either
      a low level clock (VIL < 0.4, VIH > 2.4) or high level clock
      (VIL < 0.2, VIH = Vcc +.3 / -.2)


Read/Write (R/W)

      The R/W signal is supplied by the microprocessor array and is used
      to control the transfer of data to and from the microprocessor array
      and the MCS 6530.  A high on the R/W pin allows the processor to
      read (with proper addressing) the data supplied by the MCS 6530.
      A low on the R/W pin allows a write (with proper addressing) to
      the MCS 6530.


Interrupt Request (IRQ)

      The IRQ pin is an interrupt pin from the interval timer.  This
      same pin, if not used as an interrupt, can be used as a peripheral
      I/O pin (PB7).  Then used as an interrupt, the pin should be set
      up as an input by the data direction register.  The pin will be
      normally high with a low indicating an interrupt from the MCS 6530.


                                   H-2

============================================================================

Data Bus (D0-D7)

      The MCS 6530 has eight bi-directional data pins (D0-D7).  These
      pins connect to the system's data lines to allow transfer of data
      to and from the microprocessor array.  The output buffers remain
      in the off state except when a Read operation occurs.


Peripheral Data Ports

      The MCS 6530-002, MCS 6530-003 both have 15 pins available for
      peripheral I/O operations.  Each pin is individually software
      programmable to act as either an input or an output.  The 15
      pins are divided into 2 8-bit ports, PA0-PA7 and PB0-PB7.  PB6
      was used as a chip select and is not available to the user.  The
      pins are set up as an input by writing a "0" into the corresponding
      bit of the data direction register.  A "1" into the data direction
      register will cause its corresponding bit to be an output.  When in
      the input mode, the peripheral output buffers are in the "1" state
      and a pull-up device acts as less than one TTL load to the peripheral
      data lines.  On a Read operation, the microprocessor unit reads the
      peripheral pin.  When the peripheral device gets information from
      the MCS 6530 it receives data stored in the data register.  The
      microprocessor will read correct information if the peripheral lines
      are greater than 2.0 volts for a "1" and less than 0.8 volts for a
      "0" as the peripheral pins are all TTL compatible.  Pins PA0 and PB0
      are also capable of sourcing 3 ma at 1.5v, thus making them capable
      of Darlington drive.  Pin PB7 has no internal pull-up (to allow
      collector-oring with other devices).


Address Lines (A0-A9)

      There are 10 address pins.  In addition to these 10, there is the
      ROM SELECT pin.  The above pins, A0-A9 and ROM SELECT, are always
      used as addressing pins.  There are 2 additional pins which are mask
      programmable and can be used either individually or together as
      CHIP SELECTS.  They are pins PB5 and PB6.  When used as peripheral
      data pins they cannot be used as chip selects.  PB5 was used as a
      data pin while PB6 was used as a chip select and is not available
      to the user.


                                   H-3

============================================================================

      A block diagram of the internal architecture is shown in Figure H-1
The NCS 6530 is divided into four basic sections, RAM, ROM, I/O and TIMER.
The RAM and ROM interface directly with the microprocessor through the
system data bus and address lines.  The I/O section consists of 2 8-bit
halves.  Each half contains a Data Direction Register (DDR) and an I/O
Register.


ROM 1K Byte (8K Bits)

      The 8K ROM is in a 1024 x 8 configuration.  Address lines A0-A9,
      as well as RS0 are needed to address the entire ROM.  With the
      addition of CS1 and CS2, seven NCS 6530's may be addressed, giving
      7168 x 8 bits of contiguous ROM.


RAM 64 Bytes (512 Bits)

      A 64 x 8 static RAM is contained on the MCS 6530.  It is addressed
      by A0-A5 (Byte Select), RS0, A6, A7, A8, A9 and CS1.


Internal Peripheral Registers

      There are four internal registers, two data direction registers
      and two peripheral I/O data registers.  The two data direction
      registers (A side and B side) control the direction of the data
      into and out of the peripheral pins.  A "1" written into the Data
      Direction Register sets up the corresponding peripheral buffer pin
      as an output.  Therefore, anything then written into the I/O Register
      will appear on that corresponding peripheral pin.  A "0" written into
      the DDR inhibits the output buffer from transmitting data to or from
      the I/O Register.  For example, a "1" loaded into data direction
      register A, position 3, sets up peripheral pin PA3 as an output.
      If a "0" had been loaded, PA3 would be configured as an input and
      remain in the high state.  The two data I/O registers are used to
      latch data from the Data Bus during a Write operation until the
      peripheral device can read the data supplied by the microprocessor
      array.


                                   H-4

============================================================================

      During a read operation the microprocessor is not reading the I/O
      Registers but in fact is reading the peripheral data pins.  For
      the peripheral data pins which are programmed as outputs the
      microprocessor will read the corresponding data bits of the I/O
      Register.  The only way the I/O Register data can be changed is by
      a microprocessor Write operation.  The I/O Register is not affected
      by a Read of the data on the peripheral pins.


Interval Timer

      1.  Capabilities

          The KIM-1 Interval Timer allows the user to specify a preset count
      of up to 256 10 and a clock divide rate of 1, 8, 64 or 1024 by writing
      to a memory location.  As soon as the write occurs, counting at the
      specified rate begins.  The timer counts down at the clock frequency
      divided by the divide rate.  The current timer count may be read at
      any time.  At the user's option, the timer may be programmed to generate
      an interrupt when the counter counts down past zero.  When a count of
      zero is passed, the divide rate is automatically set to 1 and the
      counter continues to count down at the clock rate starting at a count
      of FF (-1 in two's complement arithmetic).  This allows the user to
      determine how many clock cycles have passed since the timer reached
      a count of zero.  Since the counter never stops, continued counting
      down will reach 00 again, then FF, and the count will continue.

      2.  Operation

          a.  Loading the timer

          The divide rate and interrupt option enable/disable are programmed
      by decoding the least significant address bits.  The starting count for
      the timer is determined by the value written to that address.


                                   H-5

============================================================================

      Writing to Address  Sets Divide Ratio To    Interrupt Capability Is

          1704                    1                       Disabled
          1705                    8                       Disabled
          1706                    64                      Disabled
          1707                    1024                    Disabled
          170C                    1                       Enabled
          170D                    8                       Enabled
          170E                    64                      Enabled
          170F                    1024                    Enabled


      b.  Determining the timer status

          After timing has begun, reading address location 1707 will provide
      the timer status.  If the counter has passed the count of zero, bit 7
      will be set to 1, otherwise, bit 7 (and all other bits in location 1707)
      will be zero.  This allows a program to "watch" location 1707 and
      determine when the timer has timed out.

      c.  Reading the count in the timer

          If the timer has not counted past zero, reading location 1706 will
      provide the current timer count and disable the interrupt option;
      reading location 170E will provide the current timer count and enable
      the interrupt option.  Thus the interrupt option can be changed while
      the timer is counting down.
          If the timer has counted past zero, reading either memory location
      1706 or 170E will restore the divide ratio to its previously programmed
      value, disable the interrupt option and leave the timer with its current
      count (not the count originally written to the timer). Because the timer
      never stops counting, the timer will continue to decrement, pass zero,
      set the divide rate to 1, and continue to count down at the clock
      frequency, unless new information is written to the timer.


                                   H-6

============================================================================

      d.  Using the interrupt option

          In order to use the interrupt option described above, line PB7
      (application connector, pin 15) should be connected to either the
      (Expansion Connector, pin 4) or NNI (Expansion Connector, pin 6)
      pin depending on the desired interrupt function.  PB7 should be
      programmed as in input line (it's normal state after a RESET).

          NOTE:   If the programmer desires to use PB7 as a normal I/O line,
                  the programmer is responsible for disabling the timer
                  interrupt option (by writing or reading address 1706)
                  so that it does not interfere with normal operation
                  of PB7.  Also, PB7 was designed to be wire-ORed with
                  other possible interrupt sources; if this is not desired,
                  a 5.1K resistor should be used as a pull-up from PB7 to
                  +5v.  (The pull-up should NOT be used if PB7 is connected
                  to NMI or IRQ.)


                                   H-7

============================================================================

                                APPENDIX I



                          KIM-1 PROGRAM LISTINGS



============================================================================

The original listings were printed in a "9 needle matrix printer" letter type.
The scanner was unable to recognize this letter type and most of the time
produced garbage. So the following listing is the source code I made by hand
some month before I could lay my hand to this scanner.


;
; Last update: 19 October 1997
;
;
; I have checked the SRC line by line and added some comment of my own. At
; this moment it does not mean that it is without faults. I only will be
; sure about that until I have compiled the SRC and found no differences
; with the original BIN.
;
;
; The SRC can be assembled with my own programmed assembler. This assembler
; for the PC is available as freeware, including source code for Turbo Pascal.
;
;
; Source code of the KIM-1
;
.eq PCL           = $EF                 ; programcounter low
.eq PCH           = $F0                 ; programcounter high
.eq PREG          = $F1                 ; statusregister
.eq SPUSER        = $F2                 ; stackpointer

.eq ACC           = $F3
.eq YREG          = $F4
.eq XREG          = $F5
.eq CHKHI         = $F6
.eq CHKSUM        = $F7

.eq INL           = $F8                 ; inputbuffer low
.eq INH           = $F9                 ; inputbuffer high
.eq POINTL        = $FA                 ; addressL on display
.eq POINTH        = $FB                 ; addressH on display
.eq TEMP          = $FC
.eq TMPX          = $FD
.eq CHAR          = $FE
.eq MODE          = $FF

.eq INL_A         = $00F8               ; INL as absolute address
;
.eq CHKL          = $17E7
.eq CHKH          = CHKL+1
.eq SAVX          = CHKL+2
.eq VEB           = CHKL+5
.eq CNTL30        = CHKL+11
.eq CNTH30        = CHKL+12
.eq TIMH          = CHKL+13
.eq SAL           = CHKL+14
.eq SAH           = CHKL+15
.eq EAL           = CHKL+16
.eq EAH           = CHKL+17
.eq ID            = CHKL+18
.eq NMIV          = CHKL+19             ; NMI-vector
.eq RSTV          = CHKL+21             ; RESET-vector
.eq IRQV          = CHKL+23             ; IRQ-vector
;
.eq SAD           = $1740
.eq PADD          = SAD+1
.eq SBD           = SAD+2
.eq PBDD          = SAD+3
.eq CLK1T         = SAD+4
.eq CLK8T         = SAD+5
.eq CLK64T        = SAD+6
.eq CLKRDT        = SAD+7               ; Read time
.eq CLKKT         = SAD+7
.eq CLKRDI        = SAD+7               ; Read time out bit

;
;
.ba $1800
;
; Dump memory on tape
DUMPT             lda  #$AD             ; load absolute inst
                  sta  VEB
                  jsr  INTVEB
;
                  lda  #$27             ; turn off datainput PB5
                  sta  SBD
                  lda  #$BF             ; PB7 := output
                  sta  PBDD
;
                  ldx  #100             ; 100 characters
DUMPT1            lda  #$16             ; sync chars
                  jsr  OUTCHT
                  dex
                  bne  DUMPT1
;
                  lda  #$2A             ; start char
                  jsr  OUTCHT
;
                  lda  ID               ; output ID
                  jsr  OUTBT
;
                  lda  SAL              ; output start address
                  jsr  OUTBTC
                  lda  SAH
                  jsr  OUTBTC
;
DUMPT2            lda  VEB+1            ; compare for last data byte
                  cmp  EAL
                  lda  VEB+2
                  sbc  EAH
                  bcc  DUMPT4
;
                  lda  #$2F             ; output EndOfData-char
                  jsr  OUTCHT
                  lda  CHKL             ; output checksum
                  jsr  OUTBT
                  lda  CHKH
                  jsr  OUTBT
;
                  ldx  #2               ; 2 chars
DUMPT3            lda  #4               ; EOT-char
                  jsr  OUTCHT
                  dex
                  bne  DUMPT3
;
                  lda  #0               ; display 0000
                  sta  POINTL
                  sta  POINTH
                  jmp  START
;
DUMPT4            jsr  VEB              ; output data byte
                  jsr  OUTBTC
                  jsr  INCVEB
                  jmp  DUMPT2
;
; Load from tape into memory
TAB               .wo  LOAD12
LOADT             lda  #$8D             ; initialise volatile execution
                  sta  VEB              ; block with sta abs
                  jsr  INTVEB
;
                  lda  #$4C             ; code for JMP
                  sta  VEB+3
                  lda  TAB
                  sta  VEB+4
                  lda  TAB+1
                  sta  VEB+5
;
; result: jmp LOAD12 (= $190F)
;
                  lda  #7               ; reset PB5
                  sta  SBD
;
SYNC              lda  #$FF             ; clear SAVX for SYNC-area
                  sta  SAVX
;
SYNC1             jsr  RDBIT            ; get a bit
                  lsr  SAVX
                  ora  SAVX
                  sta  SAVX
                  lda  SAVX             ; get new char
                  cmp  #$16             ; SYNC-char?
                  bne  SYNC1
;
                  ldx  #10              ; test for 10 SYNC-char
SYNC2             jsr  RDCHT
                  cmp  #$16             ; SYNC-char?
                  bne  SYNC

                  dex
                  bne  SYNC2

LOADT4            jsr  RDCHT            ; look for start of
                  cmp  #$2A             ;  start char
                  beq  LOAD11           ; yes ->

                  cmp  #$16             ; SYNC-char?
                  bne  SYNC             ; no ->

                  beq  LOADT4           ; always ->
;
LOAD11            jsr  RDBYT            ; read ID
                  cmp  ID               ; requested ID?
                  beq  LOADT5           ; yes ->

                  lda  ID
                  cmp  #0               ; ignore ID?
                  beq  LOADT5           ; yes ->

                  cmp  #$FF             ; ignore start address?
                  beq  LOADT6           ; yes ->

                  bne  LOADT            ; next program, always ->
;
LOADT5            jsr  RDBYT            ; get SA from tape
                  jsr  CHKT
                  sta  VEB+1
                  jsr  RDBYT
                  jsr  CHKT
                  sta  VEB+2
                  jmp  LOADT7
;
LOADT6            jsr  RDBYT            ; get SA from tape
                  jsr  CHKT             ;  but ignore
                  jsr  RDBYT
                  jsr  CHKT
;
LOADT7            ldx  #2
LOAD13            jsr  RDCHT
                  cmp  #$2F             ; last char?
                  beq  LOADT5           ; yes ->

                  jsr  PACKT            ; convert to hex
                  bne  LOADT9           ; Y=1, non-hex char

                  dex                   ; 2 chars?
                  bne  LOAD13           ; no -> next one

                  jsr  CHKT             ; compute checksum
                  jmp  VEB
;
LOAD12            jsr  INCVEB           ; increment datapointer
                  jmp  LOADT7
;
LOADT8            jsr  RDBYT            ; EOD compare checksum
                  cmp  CHKL
                  bne  LOADT9

                  jsr  RDBYT
                  cmp  CHKH
                  bne  LOADT9

                  lda  #0
                  beq  LOAD10           ; normal exit, always ->
;
LOADT9            lda  #$FF             ; error exit
LOAD10            sta  POINTL
                  sta  POINTH
                  jmp  START            ; display values
;
; Move start address to VEB+1,2
INTVEB            lda  SAL
                  sta  VEB+1
                  lda  SAH
                  sta  VEB+2
                  lda  #$60             ; code for RTS
                  sta  VEB+3
                  lda  #0
                  sta  CHKL
                  sta  CHKH
                  rts
;
; Compute checksum for tape load
CHKT              tay
                  clc
                  adc  CHKL
                  sta  CHKL
                  lda  CHKH
                  adc  #0
                  sta  CHKH
                  tya
                  rts
;
; Output one byte
OUTBTC            jsr  CHKT
OUTBT             tay
                  lsr
                  lsr
                  lsr
                  lsr
                  jsr  HEXOUT           ; output MSD
                  tya
                  jsr  HEXOUT           ; output LSD
                  tya
                  rts
;
; Convert LSD of A to ASCII
HEXOUT            and  #$0F
                  cmp  #10
                  clc
                  bmi  HEX1

                  adc  #7
HEX1              adc  #$30
;
; Output to tape 1 ASCII
OUTCHT            stx  SAVX
                  sty  SAVX+1
                  ldy  #8               ; startbit
CHT1              jsr  ONE
                  lsr                   ; get data bit
                  bcs  CHT2

                  jsr  ONE
                  jmp  CHT3

CHT2              jsr  ZRO
CHT3              jsr  ZRO
                  dey                   ; all bits?
                  bne  CHT1             ; no ->
                  ldx  SAVX
                  ldy  SAVX+1
                  rts
;
; Output a 1 to tape: 9 pulses of 138 us each
ONE               ldx  #9
                  pha
ONE1              bit  CLKRDI           ; wait for timeout
                  bpl  ONE1

                  lda  #126
                  sta  CLK1T
                  lda  #$A7
                  sta  SBD              ; PB7 := 1
ONE2              bit  CLKRDI           ; wait for timeout
                  bpl  ONE2

                  lda  #126
                  sta  CLK1T
                  lda  #$27
                  sta  SBD              ; PB7 := 0
                  dex                   ; all pulses?
                  bne  ONE1             ; no ->

                  pla
                  rts
;
; Output a 0 to tape: 6 pulses of 207 us each
ZRO               ldx  #6
                  pha
ZRO1              bit  CLKRDI           ; wait for timeout
                  bpl  ZRO1

                  lda  #195
                  sta  CLK1T
                  lda  #$A7
                  sta  SBD              ; PB7 := 1
ZRO2              bit  CLKRDI           ; wait for timeout
                  bpl  ZRO2

                  lda  #195
                  sta  CLK1T
                  lda  #$27
                  sta  SBD              ; PB7 := 0
                  dex                   ; all pulses?
                  bne  ZRO1             ; no ->

                  pla
                  rts
;
; Increment VEB+1,2
INCVEB            inc  VEB+1
                  bne  INCVE1

                  inc  VEB+2
INCVE1            rts
;
; Read byte from tape
RDBYT             jsr  RDCHT
                  jsr  PACKT
RDBYT2            jsr  RDCHT
                  jsr  PACKT
                  rts
;
; Pack ASCII in A as hex data
PACKT             cmp  #$30             ; ASCII ?
                  bmi  PACKT3           ; no ->

                  cmp  #$47
                  bpl  PACKT3           ; no ->

                  cmp  #$40             ; > '9' ?
                  bmi  PACKT1           ; no ->

                  clc
                  adc  #9
PACKT1            rol
                  rol
                  rol
                  rol
                  ldy  #4
PACKT2            rol
                  rol  SAVX
                  dey
                  bne  PACKT2

                  lda  SAVX
;
; At this point Y already is 0 (= valid hex char)
                  ldy  #0               ; set the zero-flag
                  rts
;
; Y=0 at this point, done in label RDBIT4
PACKT3            iny                   ; Y:=1 = invalid hex char
                  rts
;
; Get 1 char from tape in A
RDCHT             stx  SAVX+2
                  ldx  #8               ; read 8 bits
RDCHT1            jsr  RDBIT
                  lsr  SAVX+1
                  ora  SAVX+1
                  sta  SAVX+1
                  dex
                  bne  RDCHT1
;
                  lda  SAVX+1
                  rol
                  lsr
                  ldx  SAVX+2
                  rts
;
; Get 1 bit from tape and return it in bit 7 of A
RDBIT             bit  SBD              ; wait for end of startbit
                  bpl  RDBIT

                  lda  CLKRDT           ; get start bit time
                  ldy  #$FF             ; A := 256 - T1
                  sty  CLK64T
;
                  ldy  #$14
RDBIT3            dey                   ; delay 100 us
                  bne  RDBIT3

RDBIT2            bit  SBD
                  bmi  RDBIT2           ; wait for next start bit
;
                  sec
                  sbc  CLKRDT
                  ldy  #$FF
                  sty  CLK64T
;
                  ldy  #7
RDBIT4            dey                   ; delay 50 us
                  bne  RDBIT4
;
                  eor  #$FF             ; complement sign
                  and  #$80             ; mask sign
                  rts
;
; output 166 us pulse string for testing purposes
;  No documentation found about this. I think it is used to
;  calibrate the 565
PLLCALL           lda  #$27
                  sta  SBD              ; turn off datin PB5=1
                  lda  #$BF
                  sta  PBDD
;
PLL1              bit  CLKRDI
                  bpl  PLL1

                  lda  #154             ; wait 166 us
                  sta  CLK1T
                  lda  #$A7             ; output PB7=1
                  sta  SBD
;
PLL2              bit  CLKRDI
                  bpl  PLL2
                  lda  #154
                  sta  CLK1T
                  lda  #$27             ; output PB7=0
                  sta  SBD
                  jmp  PLL1
;
.ba $1BFA
NMIP27            .wo  PLLCALL
RSTP27            .wo  PLLCALL
IRQP27            .wo  PLLCALL
;
;
;
; KIM-entry via NMI or IRQ
SAVE              sta  ACC
                  pla
                  sta  PREG
;
; KIM-entry via JSR
SAVEA             pla
                  sta  PCL
                  sta  POINTL
                  pla
                  sta  PCH
                  sta  POINTH
;
SAVEB             sty  YREG
                  stx  XREG
                  tsx
                  stx  SPUSER
                  jsr  INITS
                  jmp  START
;
; NMI and IRQ are called via RAM-vector. This enables the programmer
; to insert his own routines.
; Comment: is not initialised anywhere, so any accidental NMI or IRQ
;  can lead to disaster !
NMIT              jmp  (NMIV)
IRQT              jmp  (IRQV)
;
; The KIM starts here after a reset
RESET             ldx  #$FF
                  txs                   ; set stack
                  stx  SPUSER
                  jsr  INITS
;
; Determine characters per second
DETCPS            lda  #$FF             ; count startbit
                  sta  CNTH30           ; zero CNTH30
;
; Test first keyboard or teleprinter
                  lda  #1               ; mask bit 0
DET1              bit  SAD              ; test for teleprinter
                  bne  START            ; no ->

                  bmi  DET1             ; no startbit, wait for it ->

                  lda  #$FC
DET3              clc                   ; this loop counts startbit time
                  adc  #1               ; A=0 ?
                  bcc  DET2             ; no ->

                  inc  CNTH30

DET2              ldy  SAD              ; check for end of startbit
                  bpl  DET3             ; no ->

                  sta  CNTL30
                  ldx  #8
                  jsr  GET5             ; get rest of char
;
; Make TTY/KB selection
START             jsr  INIT1
                  lda  #1               ; read jumper
                  bit  SAD              ; TTY ?
                  bne  TTYKB            ; no -> keyboard/display-routine

                  jsr  CRLF             ; print return/linefeed
                  ldx  #$0A
                  jsr  PRTST            ; print 'KIM'
                  jmp  SHOW1
;
;
CLEAR             lda  #0
                  sta  INL              ; clear inputbuffer
                  sta  INH
;
READ              jsr  GETCH            ; get char from TTY
                  cmp  #1               ; 1 has no meaning for TTY
                  beq  TTYKB            ; 1 = KB-mode ->

                  jsr  PACK
                  jmp  SCAN
;
; Main routine for keyboard and display
TTYKB             jsr  SCAND            ; wait until NO key pressed
                  bne  START            ; if pressed, wait again ->
TTYKB1            lda  #1               ; check KB/TTY mode
                  bit  SAD              ; TTY?
                  beq  START            ; yes ->

                  jsr  SCAND            ; Wait for key...
                  beq  TTYKB1           ; no key ->

                  jsr  SCAND            ; debounce key
                  beq  TTYKB1           ; no key ->
;
GETK              jsr  GETKEY
                  cmp  #$15             ; >= $15 = illegal
                  bpl  START            ; yes ->

                  cmp  #$14
                  beq  PCCMD            ; display Program Counter

                  cmp  #$10
                  beq  ADDRM            ; addresmode

                  cmp  #$11
                  beq  DATAM            ; datamode

                  cmp  #$12
                  beq  STEP             ; step

                  cmp  #$13
                  beq  GOV              ; execute program
;
; One of the hexidecimal buttons has been pushed
DATA              asl                   ; move LSB key number to MSB
                  asl
                  asl
                  asl
                  sta  TEMP             ; store for datamode
                  ldx  #4

DATA1             ldy  MODE             ; part of address?
                  bne  ADDR             ; yes ->

                  lda  (POINTL),Y       ; get data
                  asl  TEMP
                  rol                   ; MSB-TEMP = MSB-key -> A
                  sta  (POINTL),Y       ; store new data
                  jmp  DATA2

ADDR              asl                   ; TEMP not needed here
                  rol  POINTL           ; MSB-key -> POINTL
                  rol  POINTH           ; POINTL -> POINTH

DATA2             dex                   ; 4 times = complete nibble?
                  bne  DATA1            ; no ->

                  beq  DATAM2           ; -> always
;
; Switch to address mode
ADDRM             lda  #1
                  bne  DATAM1           ; -> always
;
; Switch to data mode
DATAM             lda  #0
DATAM1            sta  MODE
DATAM2            jmp  START
;
; Increment address on display
STEP              jsr  INCPT
                  jmp  START
;
GOV               jmp  GOEXEC
;
; Display PC by moving it to POINT
PCCMD             lda  PCL
                  sta  POINTL
                  lda  PCH
                  sta  POINTH
                  jmp  START
;
; Load papertape from TTY
LOAD              jsr  GETCH
                  cmp  #$3B             ; ":", semicolon?
                  bne  LOAD             ; No -> again

LOADS             lda  #0
                  sta  CHKSUM
                  sta  CHKHI
;
                  jsr  GETBYT           ; get byte CNT
                  tax
                  jsr  CHK              ; Compute checksum
;
                  jsr  GETBYT           ; get address HI
                  sta  POINTH
                  jsr  CHK              ; Compute checksum
;
                  jsr  GETBYT           ; get address LO
                  sta  POINTL
                  jsr  CHK              ; Compute checksum
;
                  txa                   ; CNT = 0 ?
                  beq  LOAD3
;
LOAD2             jsr  GETBYT           ; get DATA
                  sta  (POINTL),y       ; store data
                  jsr  CHK
                  jsr  INCPT
                  dex
                  bne  LOAD2

                  inx                   ; X=1 = data record
                                        ; X=0 = last record
;
LOAD3             jsr  GETBYT           ; compare checksum
                  cmp  CHKHI
                  bne  LOADE1

                  jsr  GETBYT
                  cmp  CHKSUM
                  bne  LOADER
;
                  txa                   ; X=0 = last record
                  bne  LOAD
;
LOAD7             ldx  #$0C             ; X-OFF KIM
LOAD8             lda  #$27
                  sta  SBD              ; disable data in
                  jsr  PRTST
                  jmp  START
;
LOADE1            jsr  GETBYT           ; dummy
LOADER            ldx  #$11             ; X-OFF error KIM
                  bne  LOAD8            ; always ->
;
; Dump to TTY from open cell address to LIMHL, LIMHH
DUMP              lda  #0
                  sta  INL
                  sta  INH              ; clear record count
DUMP0             lda  #0
                  sta  CHKHI            ; clear checksum
                  sta  CHKSUM
;
DUMP1             jsr  CRLF
                  lda  #$3B             ; ":"
                  jsr  OUTCH
;
; Check if POINTL/H >= EAL/H
                  lda  POINTL
                  cmp  EAL
;
                  lda  POINTH
                  sbc  EAH
                  bcc  DUMP4            ; no ->
;
                  lda  #0               ; print last record
                  jsr  PRTBYT           ; 0 bytes
                  jsr  OPEN
                  jsr  PRTPNT
;
                  lda  CHKHI            ; print checksum
                  jsr  PRTPNT           ;  for last record
                  lda  CHKSUM
                  jsr  PRTBYT
                  jsr  CHK
                  jmp  CLEAR
;
DUMP4             lda  #$18             ; print 24 bytes
                  tax                   ; save as index
                  jsr  PRTBYT
                  jsr  CHK
                  jsr  PRTPNT
;
DUMP2             ldy  #0
                  lda  (POINTL),y
                  jsr  PRTBYT           ; print data
                  jsr  CHK
                  jsr  INCPT
                  dex                   ; Printed everything?
                  bne  DUMP2            ; No ->
;
                  lda  CHKHI
                  jsr  PRTBYT           ; print checksum
                  lda  CHKSUM
                  jsr  PRTBYT
                  inc  INL              ; increment recourd counter
                  bne  DUMP3

                  inc  INH
DUMP3             jmp  DUMP0
;
SPACE             jsr  OPEN             ; open new cell
SHOW              jsr  CRLF
SHOW1             jsr  PRTPNT
                  jsr  OUTSP            ; print space
                  ldy  #0
                  lda  (POINTL),y       ; print data
                  jsr  PRTBYT
                  jsr  OUTSP            ; print space
                  jmp  CLEAR
;
RTRN              jsr  INCPT            ; next address
                  jmp  SHOW

; Start a program at displayed address. RTI is used as a comfortable
;  way to define all flags in one move.
GOEXEC            ldx  SPUSER           ; user user defined stack
                  txs
                  lda  POINTH           ; program runs from
                  pha                   ;  displayed address
                  lda  POINTL
                  pha
                  lda  PREG             ; user defined Flag register
                  pha
                  ldx  XREG
                  ldy  YREG
                  lda  ACC
                  rti                   ; start program
;
; Take care if TTY-input
SCAN              cmp  #$20             ; open new cell
                  beq  SPACE

                  cmp  #$7F             ; rub out, restart KIM
                  beq  STV

                  cmp  #$0D             ; next cell
                  beq  RTRN

                  cmp  #$0A             ; prev cell
                  beq  FEED

                  cmp  #$2E             ; "." = modify cell
                  beq  MODIFY

                  cmp  #$47             ; "G" = exec program
                  beq  GOEXEC

                  cmp  #$51             ; "Q" = dump from open cell
                  beq  DUMPV            ;  to HI limit

                  cmp  #$4C             ; "L" = load tape
                  beq  LOADV

                  jmp  READ             ; ignore illegal CHAR
;
STV               jmp  START
DUMPV             jmp  DUMP
LOADV             jmp  LOAD
;
FEED              sec
                  lda  POINTL           ; decrement POINTL/H
                  sbc  #1
                  sta  POINTL
                  bcs  FEED1

                  dec  POINTH
FEED1             jmp  SHOW
;
MODIFY            ldy  #0               ; get contents of input buffer
                  lda  INL              ;  INL and store in location
                  sta  (POINTL),y       ;  specified by POINT
                  jmp  RTRN
;
; Subroutine to print POINT = address
PRTPNT            lda  POINTH
                  jsr  PRTBYT
                  jsr  CHK
                  lda  POINTL
                  jsr  PRTBYT
                  jsr  CHK
                  rts
;
; Print ASCII-string from TOP+X to TOP
CRLF              ldx  #7               ; output <RETURN> and <LF>
PRTST             lda  TOP,x
                  jsr  OUTCH
                  dex                   ; everything?
                  bpl  PRTST            ; no ->

PRT1              rts
;
; Print 1 hex byte as 2 ASCII chars
PRTBYT            sta  TEMP             ; save A
                  lsr                   ; shift A 4 times
                  lsr
                  lsr
                  lsr
                  jsr  HEXTA            ; convert bit 4..7 to HEX and print
                  lda  TEMP
                  jsr  HEXTA            ; convert bit 0..7 to HEX and print
                  lda  TEMP             ; restore A
                  rts
;
HEXTA             and  #$0F             ; mask bit 0..4
                  cmp  #$0A             ; > 10 ?
                  clc
                  bmi  HEXTA1           ; no ->

                  adc  #7               ; A..F
HEXTA1            adc  #$30             ; convert to ASCII-char...
                  jmp  OUTCH            ;  ...and print it
;
; Get char from TTY in A
GETCH             stx  TMPX
                  ldx  #8               ; count 8 bits
                  lda  #1
GET1              bit  SAD              ; check if TTY-mode
                  bne  GET6             ; no ->

; PA7 is input TTY
                  bmi  GET1             ; wait for startbit

                  jsr  DELAY            ; delay 1bit
;
; By delaying another half bit time, you read the bit in the middle
; of every bit.
GET5              jsr  DEHALF           ; delay 1/2 bittime
GET2              lda  SAD
                  and  #$80             ; mask bit 7
                  lsr  CHAR             ; shift last result
                  ora  CHAR             ; OR it with new bit
                  sta  CHAR             ; and store it again
                  jsr  DELAY
                  dex
                  bne  GET2             ; next bit

                  jsr  DEHALF           ; why ????
;
                  ldx  TMPX
                  lda  CHAR
                  rol  ; shift off stopbit
                  lsr
GET6              rts
;
; Initialization 6530  $1E88
INITS             ldx  #1               ; set display to address mode
                  stx  MODE
;
INIT1             ldX  #0
                  stx  PADD             ; PA0..PA7 = input
                  ldX  #$3F
                  stx  PBDD             ; PB0..PB5 = output
                                        ; PB6, PB7 = input
                  ldx  #7               ; enable 74145 output 3 to
                  stx  SBD              ;  check KB/TTY-mode
                  cld
                  sei
                  rts
;
; Output char in A to TTY               $1E9E
OUTSP             lda  #" "             ; print space
OUTCH             sta  CHAR
                  stx  TMPX
                  jsr  DELAY
                  lda  SBD
                  and  #$FE             ; send startbit
                  sta  SBD              ; PB0 = 0 -> TTY := (H)
                  jsr  DELAY
;
                  ldx  #8               ; send character
OUT1              lda  SBD
                  and  #$FE             ; clear bit 0
                  lsr  CHAR             ; shift byte
                  adc  #0               ; add Carry = former bit 0
                  sta  SBD              ; output bit
                  jsr  DELAY
                  dex                   ; all bits?
                  bne  OUT1             ; no ->

                  lda  SBD
                  ora  #1
                  sta  SBD              ; stop bit
                  jsr  DELAY
                  ldx  TMPX
                  rts
;
; Delay 1 bit time as determined by DETCPS
DELAY             lda  CNTH30
                  sta  TIMH
                  lda  CNTL30
DE2               sec
DE4               sbc  #1
                  bcs  DE3              ; A<>$FF ->

                  dec  TIMH
DE3               ldy  TIMH             ; TIMH > 0 ?
                  bpl  DE2              ; yes ->

                  rts
;
; Delay half a bit time
DEHALF            lda  CNTH30
                  sta  TIMH
                  lda  CNTL30
                  lsr
                  lsr  TIMH
                  bcc  DE2

                  ora  #$80
                  bcs  DE4              ; always ->
; Why not:
;  lsr            TIMH
;  ror
;  jmp            DE2
; ????
;
;
; Determine if key is depressed: NO -> A=0, YES -> A>0
AK                ldy  #3               ; 3 rows
                  ldX  #1               ; select 74145 output 0

ONEKEY            lda  #$FF             ; initial value
;
AKA               stx  SBD              ; enable output = select row
                  inx
                  inx                   ; prepare for next row
                  and  SAD              ; A := A && (PA0..PA7)
                  dey                   ; all rows?
                  bne  AKA              ; no ->

                  ldy  #7
                  sty  SBD              ; select 74145 output 3 (not used)
;
                  ora  #$80             ; mask bit 7 of A
                  eor  #$FF             ; if A still is $FF -> A := 0
                  rts
;
; Output to 7-segment-display
SCAND             ldy  #0               ; POINTL/POINTH = address on display
                  lda  (POINTL),Y       ; get data from this address
                  sta  INH              ; store in INH =
SCANDS            lda  #$7F             ; PA0..PA6 := output
                  sta  PADD

                  ldX  #9               ; Start with display at output 4
                  ldy  #3               ; 3 bytes to be shown
;
SCAND1            lda  INL_A,y          ; get byte
                  lsr                   ; get MSD by shifting A
                  lsr
                  lsr
                  lsr
                  jsr  CONVD
                  lda  INL_A,y          ; get byte again
                  and  #$0F             ; get LSD
                  jsr  CONVD
                  dey                   ; all ?
                  bne  SCAND1           ; no ->

                  sty  SBD              ; all digits off
                  lda  #0
                  sta  PADD             ; PA0..PA7 := input
                  jmp  AK
;
; Convert digit into 7-segment-value
CONVD             sty  TEMP
                  tay
                  lda  TABLE,Y
                  ldy  #0
                  sty  SAD              ; turn off segments
                  stx  SBD              ; select 7-s-display
                  sta  SAD              ; output code on display

                  ldy  #$7F             ; delay ~500 cycles
CONVD1            dey
                  bne  CONVD1

                  inx                   ; next display
                  inx
                  ldy  TEMP
                  rts
;
; Increment POINT = address on display
INCPT             inc  POINTL
                  bne  INCPT2

                  inc  POINTH
INCPT2            rts
;
; Get key from keyboard in A
GETKEY            ldx  #$21             ; row 0 / disable input TTY
GETKE5            ldy  #1               ; only one row in the time
                  jsr  ONEKEY           ; key?
                  bne  KEYIN            ; yes ->

                  cpx  #$27             ; last row?
                  bne  GETKE5           ; no, next one ->

                  lda  #$15             ; 15 = no key
                  rts
;
KEYIN             ldy  #$FF             ; Y := key number
KEYIN1            asl                   ; shift A until
                  bcs  KEYIN2           ;  bit = 1 ->
;
; Comment: bit 7 is always 0 so Carry is always 0 the first time
;  and allowing Y to become 0 (key $FF does not exist)
                  iny
                  bpl  KEYIN1           ; always ->

KEYIN2            txa
                  and  #$0F             ; strip bit4..7
                  lsr                   ; A := row+1
                  tax                   ; X := actual row+1
                  tya
                  bpl  KEYIN4           ; always, because Y<7 ->

;
; Add 7 to A for every row above 0 to get actual key number
KEYIN3            clc
                  adc  #7               ; add (X-1) times 7 to A
KEYIN4            dex                   ; countdown to 0
                  bne  KEYIN3

                  rts                   ; A is always < 21 eg. < $15
;
; Compute checksum
CHK               clc
                  adc  CHKSUM
                  sta  CHKSUM
                  lda  CHKHI
                  adc  #0
                  sta  CHKHI
                  rts
;
; Get 2 hex-chars and pack into INL and INH
;  Non hex char will be loaded as nearsest hex equivalent
GETBYT            jsr  GETCH
                  jsr  PACK
                  lsr  GETCH
                  jsr  PACK
                  lda  INL
                  rts
;
; Shift char in A into INL and INH
PACK              cmp  #$30             ; is hex?
                  bmi  UPDAT2           ; < = no->

                  cmp  #$47
                  bpl  UPDAT2           ; > = no ->

HEXNUM            cmp  #$40             ; A..F ?
                  bmi  UPDATE           ; no ->

HEXALP            clc
                  adc  #9
UPDATE            rol  ; shift to bit 4..7
                  rol
                  rol
                  rol
                  ldy  #4               ; shift into INL/INH
UPDAT1            rol
                  rol  INL
                  rol  INH
                  dey  ; 4 times?
                  bne  UPDAT1           ; no ->

                  lda  #0               ; if hex number -> A := 0
UPDAT2            rts
;
OPEN              lda  INL              ; move I/O-buffer to POINT
                  sta  POINTL
                  lda  INH
                  sta  POINTH
                  rts
;
; Tabels
TOP               .by  0, 0, 0, 0, 0, 0, 10, 13
                  .tx  "MIK"
                  .by  " ", $13
                  .tx  "RRE "
                  .by  $13

; Hex -> 7-segment     0    1    2    3    4    5    6    7
TABLE             .by  $BF, $86, $DB, $CF, $E6, $ED, $FD, $87
;                      8    9    A    B    C    D    E    F
                  .by  $FF, $EF, $F7, $FC, $B9, $DE, $F9, $F1
;
; Comment: if everything is compiled right, next vectors should
;  start at $FFFA
NMIENT            .wo  NMIT
RSTENT            .wo  RESET
IRQENT            .wo  IRQT
.en

