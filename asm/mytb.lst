------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2c38				   input      processor	6502
      2 U2c38 ????						;=====================================================
      3 U2c38 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2c38 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2c38 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2c38 ????						;
      7 U2c38 ????						; While working on the Corsham Technologies KIM Clone
      8 U2c38 ????						; project, I wanted to include a TINY BASIC since that
      9 U2c38 ????						; was a highly desirable feature of early computers.
     10 U2c38 ????						;
     11 U2c38 ????						; Rather than negotiating copyright issues for
     12 U2c38 ????						; existing BASICs, I decided to just write one from
     13 U2c38 ????						; scratch.
     14 U2c38 ????						;
     15 U2c38 ????						; 10/07/2017
     16 U2c38 ????						;
     17 U2c38 ????						; This implements a stripped down Tiny BASIC
     18 U2c38 ????						; interpreter using the Interpretive Language (IL)
     19 U2c38 ????						; method as described in the first few issues of
     20 U2c38 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2c38 ????						; to write various languages simply by changing the
     22 U2c38 ????						; IL code rather than the interpreter itself.
     23 U2c38 ????						;
     24 U2c38 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2c38 ????						;		* Fixed major bug in findLine that
     26 U2c38 ????						;		  caused corrupted lines, crashes, etc.
     27 U2c38 ????						;		* If no parameter given to RND, assume
     28 U2c38 ????						;		  32766.
     29 U2c38 ????						;		* No more error 5 when a program
     30 U2c38 ????						;		  reaches the end without an END.
     31 U2c38 ????						;
     32 U2c38 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2c38 ????						;		 * Unexpanded version to play with everything
     34 U2c38 ????						;		 * Add some usefull system level functions
     35 U2c38 ????						;		 * allow a larger number of tiny basic formats
     36 U2c38 ????						;		 * Add byte at start of line holding length
     37 U2c38 ????						;		   for faster execution of goto and gosub
     38 U2c38 ????						;		 * Re-added gosub
     39 U2c38 ????						;		 * allow ; or , at end if print stmt
     40 U2c38 ????						;		   without CRLF being added.
     41 U2c38 ????						;		 * Added extended function erase to
     42 U2c38 ????						;		   use the extended ctmon65 rm file
     43 U2c38 ????						;		 * Fix quoted text to not have to backtrack
     44 U2c38 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2c38 ????						;		 * Add concurrency features
     46 U2c38 ????						;
     47 U2c38 ????						; www.corshamtech.com
     48 U2c38 ????						; bob@corshamtech.com
     49 U2c38 ????						; JustLostInTime@gmail.com
     50 U2c38 ????						;
     51 U2c38 ????						;=====================================================
     52 U2c38 ????						;
     53 U2c38 ????						; Create TRUE and FALSE values for conditionals.
     54 U2c38 ????						;
     55 U2c38 ????
     56 U2c38 ????	       00 00	   FALSE      equ	0
     57 U2c38 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2c38 ????						;
     59 U2c38 ????						;---------------------------------------------------------
     60 U2c38 ????						; One of these must be set to indicate which environment
     61 U2c38 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2c38 ????						; environments:
     63 U2c38 ????						;
     64 U2c38 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2c38 ????						; more K of RAM.
     66 U2c38 ????						;
     67 U2c38 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2c38 ????						; which enhances, without replacing, the standard KIM
     69 U2c38 ????						; monitor.  It gives access to routines to save/load files
     70 U2c38 ????						; to a micro SD card.
     71 U2c38 ????						;
     72 U2c38 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2c38 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2c38 ????						; easily be ported to other systems.  It has support for
     75 U2c38 ????						; using a micro SD card for file storage/retrieval.
     76 U2c38 ????						;
     77 U2c38 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2c38 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2c38 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2c38 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2c38 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2c38 ????						;
     83 U2c38 ????						;   Need to define some macros for the dasm assembler
     84 U2c38 ????						;
     85 U2c38 ????				      MACRO	dw
     86 U2c38 ????				      .word	{0}
     87 U2c38 ????				      ENDM
     88 U2c38 ????
     89 U2c38 ????				      MACRO	db
     90 U2c38 ????				      .byte	{0}
     91 U2c38 ????				      ENDM
     92 U2c38 ????
     93 U2c38 ????						;
     94 U2c38 ????						; If set, include disk functions.
     95 U2c38 ????						;
     96 U2c38 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2c38 ????						;
     98 U2c38 ????						; If ILTRACE is set then dump out the address of every
     99 U2c38 ????						; IL opcode before executing it.
    100 U2c38 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2c38 ????						;
    102 U2c38 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2c38 ????						;
    104 U2c38 ????						; If FIXED is set, put the IL code and the user
    105 U2c38 ????						; program space at fixed locations in memory.	This is
    106 U2c38 ????						; meant only for debugging.
    107 U2c38 ????						;
    108 U2c38 ????	       00 00	   FIXED      equ	FALSE
    109 U2c38 ????						;
    110 U2c38 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2c38 ????						; BASIC, so keep this small!
    112 U2c38 ????						;
    113 U2c38 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2c38 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2c38 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2c38 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2c38 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2c38 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2c38 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2c38 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2c38 ????						;
    122 U2c38 ????						; Gosub entry types
    123 U2c38 ????
    124 U2c38 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2c38 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2c38 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2c38 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2c38 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2c38 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2c38 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2c38 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2c38 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2c38 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2c38 ????						;
    135 U2c38 ????						; Common ASCII constants
    136 U2c38 ????						;
    137 U2c38 ????	       00 07	   BEL	      equ	$07
    138 U2c38 ????	       00 08	   BS	      equ	$08
    139 U2c38 ????	       00 09	   TAB	      equ	$09
    140 U2c38 ????	       00 0a	   LF	      equ	$0A
    141 U2c38 ????	       00 0d	   CR	      equ	$0D
    142 U2c38 ????	       00 22	   quote      equ	$22
    143 U2c38 ????	       00 20	   SPACE      equ	$20
    144 U2c38 ????	       00 2c	   COMMA      equ	',
    145 U2c38 ????	       00 3b	   SEMICOLON  equ	';
    146 U2c38 ????	       00 3a	   COLON      equ	':
    147 U2c38 ????	       00 24	   DOLLAR     equ	'$
    148 U2c38 ????						;
    149 U2c38 ????						; These are error codes
    150 U2c38 ????						;
    151 U2c38 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2c38 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2c38 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2c38 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2c38 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2c38 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2c38 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2c38 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2c38 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2c38 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2c38 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2c38 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2c38 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2c38 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2c38 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2c38 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2c38 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2c38 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2c38 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2c38 ????						;
    171 U2c38 ????						;=====================================================
    172 U2c38 ????						; Zero page storage.
    173 U2c38 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  22c0 ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       1c 0c	   CRLF       equ	tbcrlf
    307  0206		       13 65	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       13 82	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 3b 1d    cold2      jsr	SetOutConsole
    314  0209		       20 48 1d 	      jsr	SetInConsole
    315  020c		       20 82 13 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    319  0243							;
    320  0243		       20 17 14 	      jsr	MemInit	;setup the free space available
    321  0246
    322  0246		       a9 01	   calcstack  lda	#1
    323  0248		       8d d4 23 	      sta	taskCounter	; Initialize number of tasks to 1
    324  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  024d		       8d d6 22 	      sta	taskTable	; mark the main task as active
    326  0250		       20 04 15 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  0253		       a9 dc		      lda	#IL&$ff
    328  0255		       85 43		      sta	ILPC
    329  0257		       a9 1e		      lda	#IL>>8
    330  0259		       85 44		      sta	ILPC+1
    331  025b							;
    332  025b							;		  lda	  ProgramStart		     ; user prog
    333  025b							;		  sta	  ProgramEnd
    334  025b							;		  lda	  ProgramStart+1
    335  025b							;		  sta	  ProgramEnd+1
    336  025b							;
    337  025b							;  Init time slices defaults
    338  025b		       a9 02		      lda	#TASKCYCLESHIGH
    339  025d		       8d d3 23 	      sta	taskResetValue+1
    340  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  0262		       8d d2 23 	      sta	taskResetValue
    342  0265							;
    343  0265							; Initialize the pseudo-random number sequence...
    344  0265							;
    345  0265		       a9 5a		      lda	#$5a
    346  0267		       8d 1e 2c 	      sta	rtemp1
    347  026a		       a9 9d		      lda	#%10011101
    348  026c		       8d 20 2c 	      sta	random
    349  026f		       a9 5b		      lda	#%01011011
    350  0271		       8d 21 2c 	      sta	random+1
    351  0274							;
    352  0274							;   Insert a Basic irq handler for the basic Language
    353  0274		       a9 81		      lda	#ServiceIrq&$ff
    354  0276		       8d 00 df 	      sta	IRQvec
    355  0279		       a9 02		      lda	#ServiceIrq>>8
    356  027b		       8d 01 df 	      sta	IRQvec+1
    357  027e		       4c a6 02 	      jmp	coldtwo
    358  0281
    359  0281							;
    360  0281							; This is the Basic IRQ handler
    361  0281		       48	   ServiceIrq pha
    362  0282		       ad d1 22 	      lda	IRQStatus
    363  0285		       f0 0a		      BEQ	RetIrq
    364  0287		       ad d2 22 	      lda	IRQPending
    365  028a		       d0 05		      bne	RetIrq
    366  028c		       a9 01		      lda	#1
    367  028e		       8d d2 22 	      sta	IRQPending
    368  0291		       68	   RetIrq     pla
    369  0292		       40		      rti
    370  0293							;
    371  0293							;
    372  0293							; This is the warm start entry point
    373  0293							;
    374  0293		       20 3b 1d    warm2      jsr	SetOutConsole
    375  0296		       20 48 1d 	      jsr	SetInConsole
    376  0299		       20 0c 1c 	      jsr	CRLF
    377  029c		       ad 1b 2c 	      lda	errGoto
    378  029f		       85 43		      sta	ILPC
    379  02a1		       ad 1c 2c 	      lda	errGoto+1
    380  02a4		       85 44		      sta	ILPC+1
    381  02a6							;
    382  02a6							; And continue with both starts here
    383  02a6							;
    384  02a6				   coldtwo
    385  02a6							;
    386  02a6							; The ILTrace flag is now run-time settable.
    387  02a6							;
    388  02a6		       a9 00		      lda	#ILTRACE&$ff
    389  02a8		       85 40		      sta	ILTrace
    390  02aa							;
    391  02aa
    392  02aa		       a9 00		      lda	#0
    393  02ac		       85 5b		      sta	RunMode
    394  02ae		       8d 91 2b 	      sta	LINBUF
    395  02b1
    396  02b1							; Clear everything from the stacks
    397  02b1
    398  02b1		       8d 2c 2c 	      sta	taskIOPending	; No one waiting for io
    399  02b4		       8d 2d 2c 	      sta	taskRDPending	; No one waiting for bg io
    400  02b7
    401  02b7		       20 77 15 	      jsr	taskReset
    402  02ba							;
    403  02ba		       a9 91		      lda	#LINBUF&$ff
    404  02bc		       85 4f		      sta	CURPTR
    405  02be		       a9 2b		      lda	#LINBUF>>8
    406  02c0		       85 50		      sta	CURPTR+1	;fall through...
    407  02c2
    408  02c2							;=====================================================
    409  02c2							; This is the top of the IL interpreter.  This fetches
    410  02c2							; and executes the instruction currently pointed to
    411  02c2							; by ILPC and adjusts ILPC to point to the next
    412  02c2							; instruction to execute.
    413  02c2							;
    414  02c2		       ce d0 23    NextIL     dec	taskCurrentCycles
    415  02c5		       d0 03		      bne	NextIlNow
    416  02c7		       20 a0 15 	      jsr	iTaskSwitch	;check for a task switch
    417  02ca		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02cc		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02ce
    420  02ce		       20 98 1c 	      jsr	dbgLine	;Print the IL trace information
    421  02d1
    422  02d1		       a4 51	   NextIL2    ldy	CUROFF
    423  02d3							;		  jsr	  SkipSpaces
    424  02d3							;		  sty	  CUROFF
    425  02d3							;Task IO Management
    426  02d3		       ad 2d 2c 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d6		       f0 08		      beq	NextILStr
    428  02d8		       20 53 1a 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02db		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02dd		       ce 2d 2c 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02e0							;
    432  02e0		       20 d6 18    NextILStr  jsr	getILByte
    433  02e3							;
    434  02e3							; When the handler is called, these are the conditions
    435  02e3							; of several important items:
    436  02e3							;
    437  02e3							;    (ILPC) will point to the byte AFTER the IL
    438  02e3							;    opcode being executed.
    439  02e3							;
    440  02e3							;    (CURPTR),CUROFF will point to the start of the
    441  02e3							;    next word in the input buffer.  Ie, the next word
    442  02e3							;    in the user program.
    443  02e3							;
    444  02e3		       0a		      asl
    445  02e4		       c9 d0		      cmp	#ILTBLend-ILTBL+2
    446  02e6		       90 33		      bcc	ILgood
    447  02e8							;
    448  02e8							; This handles an illegal IL opcode.  This is serious
    449  02e8							; and there's no way to recover.
    450  02e8							;
    451  02e8		       20 82 13    ILbad      jsr	puts
      0  02eb					      db	CR,LF
      1  02eb		       0d 0a		      .byte.b	CR,LF
      0  02ed					      db	"Illegal IL "
      1  02ed		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f8					      db	0
      1  02f8		       00		      .byte.b	0
    455  02f9							;
    456  02f9							; Well this is awkward, we need to back up the IL
    457  02f9							; by one since it no longer points to the current
    458  02f9							; opcode.
    459  02f9							;
    460  02f9		       20 e3 18 	      jsr	decIL
    461  02fc							;
    462  02fc		       a0 00		      ldy	#0
    463  02fe		       b1 43		      lda	(ILPC),y
    464  0300		       20 65 13 	      jsr	OUTHEX
    465  0303		       20 82 13 	      jsr	puts
      0  0306					      db	" at ",0
      1  0306		       20 61 74 20*	      .byte.b	" at ",0
    467  030b		       a5 44		      lda	ILPC+1
    468  030d		       20 65 13 	      jsr	OUTHEX
    469  0310		       a5 43		      lda	ILPC
    470  0312		       20 65 13 	      jsr	OUTHEX
    471  0315		       20 0c 1c 	      jsr	CRLF
    472  0318		       4c 03 f0 	      jmp	MONITOR
    473  031b							;
    474  031b							; Just jump to the address (ILPC),y.  Have to do
    475  031b							; some goofy stuff.
    476  031b							;
    477  031b		       a8	   ILgood     tay		;move index into Y
    478  031c		       b9 29 03 	      lda	ILTBL,y
    479  031f		       85 59		      sta	dpl
    480  0321		       b9 2a 03 	      lda	ILTBL+1,y
    481  0324		       85 5a		      sta	dpl+1
    482  0326		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0329							;
    484  0329							;=====================================================
    485  0329							; This is the IL jump table.  The IL opcode is
    486  0329							; mulitplied by two, then looked-up in this table.
    487  0329							; There is absolutely nothing special about the order
    488  0329							; of entries here... they all decode at exactly the
    489  0329							; same speed.	However the entry number must match the
    490  0329							; values in IL.inc.
    491  0329							;
    492  0329				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0329					      include	"ilvectortable.asm"
      1  0329					      seg	Code
      2  0329
      0  0329					      dw	iXINIT	;0
      1  0329		       2f 04		      .word.w	iXINIT
      0  032b					      dw	iDONE	;1
      1  032b		       4a 04		      .word.w	iDONE
      0  032d					      dw	iPRS	;2
      1  032d		       63 04		      .word.w	iPRS
      0  032f					      dw	iPRN	;3
      1  032f		       6b 04		      .word.w	iPRN
      0  0331					      dw	iSPC	;4
      1  0331		       74 04		      .word.w	iSPC
      0  0333					      dw	iNLINE	;5
      1  0333		       ea 08		      .word.w	iNLINE
      0  0335					      dw	iNXT	;6
      1  0335		       7c 04		      .word.w	iNXT
      0  0337					      dw	iXFER	;7
      1  0337		       a2 04		      .word.w	iXFER
      0  0339					      dw	iSAV	;8
      1  0339		       cf 04		      .word.w	iSAV
      0  033b					      dw	iRSTR	;9
      1  033b		       12 05		      .word.w	iRSTR
      0  033d					      dw	iCMPR	;10
      1  033d		       47 05		      .word.w	iCMPR
      0  033f					      dw	iINNUM	;11
      1  033f		       c8 05		      .word.w	iINNUM
      0  0341					      dw	iFIN	;12
      1  0341		       fc 05		      .word.w	iFIN
      0  0343					      dw	iERR	;13
      1  0343		       10 06		      .word.w	iERR
      0  0345					      dw	iADD	;14
      1  0345		       80 06		      .word.w	iADD
      0  0347					      dw	iSUB	;15
      1  0347		       96 06		      .word.w	iSUB
      0  0349					      dw	iNEG	;16
      1  0349		       ac 06		      .word.w	iNEG
      0  034b					      dw	iMUL	;17
      1  034b		       c4 06		      .word.w	iMUL
      0  034d					      dw	iDIV	;18
      1  034d		       04 07		      .word.w	iDIV
      0  034f					      dw	iSTORE	;19
      1  034f		       5a 07		      .word.w	iSTORE
      0  0351					      dw	iIND	;20
      1  0351		       72 07		      .word.w	iIND
      0  0353					      dw	iLST	;21
      1  0353		       e0 07		      .word.w	iLST
      0  0355					      dw	iINIT	;22
      1  0355		       f7 03		      .word.w	iINIT
      0  0357					      dw	iGETLINE	;23
      1  0357		       16 08		      .word.w	iGETLINE
      0  0359					      dw	iINSRT	;24
      1  0359		       33 08		      .word.w	iINSRT
      0  035b					      dw	iRTN	;25
      1  035b		       e4 08		      .word.w	iRTN
      0  035d					      dw	MONITOR	;26
      1  035d		       03 f0		      .word.w	MONITOR
      0  035f					      dw	iLIT	;27
      1  035f		       0a 09		      .word.w	iLIT
      0  0361					      dw	iCALL	;28
      1  0361		       f0 08		      .word.w	iCALL
      0  0363					      dw	iJMP	;29
      1  0363		       f8 08		      .word.w	iJMP
      0  0365					      dw	iVINIT	;30
      1  0365		       27 09		      .word.w	iVINIT
      0  0367					      dw	iERRGOTO	;31
      1  0367		       2d 09		      .word.w	iERRGOTO
      0  0369					      dw	iTST	;32
      1  0369		       39 09		      .word.w	iTST
      0  036b					      dw	iTSTV	;33
      1  036b		       58 0a		      .word.w	iTSTV
      0  036d					      dw	iTSTL	;34
      1  036d		       cf 0a		      .word.w	iTSTL
      0  036f					      dw	iTSTN	;35
      1  036f		       e2 0a		      .word.w	iTSTN
      0  0371					      dw	iFREE	;36
      1  0371		       91 0b		      .word.w	iFREE
      0  0373					      dw	iRANDOM	;37
      1  0373		       9a 0b		      .word.w	iRANDOM
      0  0375					      dw	iABS	;38
      1  0375		       6b 0c		      .word.w	iABS
     42  0377							;
     43  0377							; Disk functions.  There must be pointers
     44  0377							; to functions even if no disk is supported.
     45  0377							; Makes things easier in IL.inc.
     46  0377							;
     47  0377					      if	DISK_ACCESS
      0  0377					      dw	iOPENREAD	;39
      1  0377		       b4 1d		      .word.w	iOPENREAD
      0  0379					      dw	iOPENWRITE	;40
      1  0379		       08 1e		      .word.w	iOPENWRITE
      0  037b					      dw	iDCLOSE	;41
      1  037b		       8f 1e		      .word.w	iDCLOSE
      0  037d					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037d		       27 1e		      .word.w	iDGETLINE
      0  037f					      dw	iDLIST	;43 Did you remeber your towel?
      1  037f		       89 1e		      .word.w	iDLIST
      0  0381					      dw	iDDIR	;44
      1  0381		       64 1e		      .word.w	iDDIR
      0  0383					      dw	iRMFILE	;45
      1  0383		       e2 1d		      .word.w	iRMFILE
     55  0385				  -	      else
     56  0385				  -	      dw	NextIL	;39
     57  0385				  -	      dw	NextIL	;40
     58  0385				  -	      dw	NextIL	;41
     59  0385				  -	      dw	NextIL	;42
     60  0385				  -	      dw	NextIL	;43
     61  0385				  -	      dw	NextIL	;44
     62  0385				  -	      dw	NextIL	;45
     63  0385					      endif
     64  0385							;
      0  0385					      dw	iCLEARSCREEN	;46
      1  0385		       5b 1d		      .word.w	iCLEARSCREEN
      0  0387					      dw	iPOKEMEMORY	;47
      1  0387		       f8 0b		      .word.w	iPOKEMEMORY
      0  0389					      dw	iPEEKMEMORY	;48
      1  0389		       0d 0c		      .word.w	iPEEKMEMORY
      0  038b					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  038b		       80 09		      .word.w	iTSTLET
      0  038d					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038d		       ff 09		      .word.w	iTSTDONE
      0  038f					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038f		       3a 0c		      .word.w	iGETCHAR
      0  0391					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0391		       4e 0c		      .word.w	iPUTCHAR
      0  0393					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0393		       23 0c		      .word.w	iCallFunc
      0  0395					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0395		       98 05		      .word.w	iBranch
      0  0397					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0397		       63 09		      .word.w	iTSTStr
      0  0399					      dw	iSetIrq	;56	   sets the irq handler
      1  0399		       e8 0c		      .word.w	iSetIrq
      0  039b					      dw	iTstIrq	;57	   test if irq is pending
      1  039b		       59 0b		      .word.w	iTstIrq
      0  039d					      dw	iRET	;58	   return from interupt
      1  039d		       00 05		      .word.w	iRET
      0  039f					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039f		       df 05		      .word.w	iINSTR
      0  03a1					      dw	iMOD	;60	   returns remainder of division
      1  03a1		       0d 07		      .word.w	iMOD
      0  03a3					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a3		       f4 15		      .word.w	iTaskSet
      0  03a5					      dw	iETask	;62	   Terminates a task
      1  03a5		       1f 17		      .word.w	iETask
      0  03a7					      dw	iNTask	;63	   goto next task
      1  03a7		       d2 16		      .word.w	iNTask
      0  03a9					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a9		       87 07		      .word.w	iArray
      0  03ab					      dw	iTaskKill	;65	   kill a running task
      1  03ab		       ca 16		      .word.w	iTaskKill
      0  03ad					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ad		       9e 16		      .word.w	iTaskStat
      0  03af					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03af		       59 0c		      .word.w	iHexOut
      0  03b1					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b1		       b4 05		      .word.w	iReadComplete
      0  03b3					      dw	iReadStart	;69	   Called to start a background read request
      1  03b3		       aa 05		      .word.w	iReadStart
      0  03b5					      dw	iStartIO	;70	   Lock task until io complete
      1  03b5		       02 17		      .word.w	iStartIO
      0  03b7					      dw	iEndIO	;71	   release task lock for io
      1  03b7		       08 17		      .word.w	iEndIO
      0  03b9					      dw	iLogNot	;72	   Logical not
      1  03b9		       c4 0c		      .word.w	iLogNot
      0  03bb					      dw	iLogOr	;73	   Logical Or
      1  03bb		       9a 0c		      .word.w	iLogOr
      0  03bd					      dw	iLogAnd	;74	   Logical And
      1  03bd		       85 0c		      .word.w	iLogAnd
      0  03bf					      dw	iLogXor	;75	   Logical Xor
      1  03bf		       af 0c		      .word.w	iLogXor
      0  03c1					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c1		       dd 16		      .word.w	iWTASK
      0  03c3					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c3		       13 17		      .word.w	iTASKPID
      0  03c5					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c5		       24 0d		      .word.w	iTRACEPROG
      0  03c7					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c7		       19 1c		      .word.w	idbgBasic
      0  03c9					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c9		       d5 17		      .word.w	iIPCS
      0  03cb					      dw	iIPCR	;81	   Recieve a message from a task
      1  03cb		       ec 17		      .word.w	iIPCR
      0  03cd					      dw	iIPCC	;82	   Check if any message available for task
      1  03cd		       00 18		      .word.w	iIPCC
      0  03cf					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cf		       0d 18		      .word.w	iIPCIO
      0  03d1					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d1		       6c 14		      .word.w	iPushMathStack
      0  03d3					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d3		       9c 14		      .word.w	iPopMathStack
      0  03d5					      dw	iSaveMathStack	;86	   Save all math info
      1  03d5		       b9 14		      .word.w	iSaveMathStack
      0  03d7					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d7		       d8 14		      .word.w	iRestoreMathStack
      0  03d9					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d9		       89 14		      .word.w	iIncParmCount
      0  03db					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03db		       3f 17		      .word.w	iTaskGetMathStack
      0  03dd					      dw	iTaskEnable	;90	   enable a suspended task
      1  03dd		       6c 16		      .word.w	iTaskEnable
      0  03df					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03df		       86 16		      .word.w	iTaskSuspend
      0  03e1					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e1		       59 17		      .word.w	iTaskPutMathPtr
      0  03e3					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e3		       4f 0a		      .word.w	iTSTVT
      0  03e5					      dw	iSetR2	;94
      1  03e5		       02 09		      .word.w	iSetR2
      0  03e7					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e7		       de 04		      .word.w	iStk2Tmp
      0  03e9					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e9		       ef 04		      .word.w	iTmp2Stk
      0  03eb					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03eb		       a1 09		      .word.w	iTSTBYTE
      0  03ed					      dw	iINCVAR	;98	   Increment variable
      1  03ed		       21 0a		      .word.w	iINCVAR
      0  03ef					      dw	iDECVAR	;99	   Decrement variable
      1  03ef		       39 0a		      .word.w	iDECVAR
      0  03f1					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f1		       68 17		      .word.w	iSLICE
      0  03f3					      dw	iTSTB	;101	   Test if byte equals
      1  03f3		       c0 09		      .word.w	iTSTB
      0  03f5					      dw	iTSTW	;102	   Test If word equals
      1  03f5		       d8 09		      .word.w	iTSTW
    122  03f7
------- FILE mytb.asm
    494  03f7		       03 f7	   ILTBLend   equ	*
    495  03f7							;
    496  03f7							;=====================================================
    497  03f7							;=====================================================
    498  03f7							;=====================================================
    499  03f7							; This marks the start of the handlers for IL opcodes.
    500  03f7							;=====================================================
    501  03f7							;=====================================================
    502  03f7							;=====================================================
    503  03f7							;
    504  03f7							;
    505  03f7		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03f9		       85 47		      sta	ILSTACKPTR
    507  03fb		       85 4a		      sta	MATHSTACKPTR
    508  03fd		       85 4d		      sta	GOSUBSTACKPTR
    509  03ff		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  0401		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  0403							;
    512  0403		       ad 2e 2c 	      lda	ProgramStart	;user prog
    513  0406		       85 4f		      sta	CURPTR
    514  0408		       8d d7 22 	      sta	taskTable+1
    515  040b		       8d 30 2c 	      sta	ProgramEnd
    516  040e		       ad 2f 2c 	      lda	ProgramStart+1
    517  0411		       85 50		      sta	CURPTR+1
    518  0413		       8d d8 22 	      sta	taskTable+2
    519  0416		       8d 31 2c 	      sta	ProgramEnd+1
    520  0419		       a9 80		      lda	#TASKACTIVE
    521  041b		       8d d6 22 	      sta	taskTable	;Mark the first slot as active
    522  041e		       a9 01		      lda	#1
    523  0420		       8d d4 23 	      sta	taskCounter	;there is always one task / Main task
    524  0423		       ad d2 23 	      lda	taskResetValue
    525  0426		       8d d0 23 	      sta	taskCurrentCycles	; set up the task switch counts
    526  0429		       ad d3 23 	      lda	taskResetValue+1
    527  042c		       8d d1 23 	      sta	taskCurrentCycles+1
    528  042f							;
    529  042f							; fall into XINIT...
    530  042f							;
    531  042f							;=====================================================
    532  042f							; This initializes for the start of the next line of
    533  042f							; BASIC text.
    534  042f							;
    535  042f		       78	   iXINIT     sei		;ensure interupts are off
    536  0430		       20 77 15 	      jsr	taskReset	;Clear the task table
    537  0433		       8d d2 22 	      sta	IRQPending	; reset the irq pending
    538  0436		       8d d1 22 	      sta	IRQStatus	; Make sure irqs are off
    539  0439
    540  0439		       4c c2 02    goodExit   jmp	NextIL
    541  043c							;
    542  043c							;=====================================================
    543  043c							; This check if the escape key has been entered
    544  043c							; then changes out of run mode. z Set if esc found
    545  043c				   BreakSet
    546  043c		       20 0f f0 	      jsr	ISCHAR
    547  043f		       f0 06		      beq	BreakNo
    548  0441		       20 58 1d 	      jsr	VGETCH
    549  0444		       c9 1b		      cmp	#$1B
    550  0446		       60		      rts
    551  0447				   BreakNo
    552  0447		       a9 01		      lda	#1
    553  0449		       60		      rts
    554  044a
    555  044a							;
    556  044a
    557  044a							;=====================================================
    558  044a							; Verify there is nothing else on this input line.
    559  044a							; If there is, generate an error.
    560  044a							;
    561  044a		       a4 51	   iDONE      ldy	CUROFF
    562  044c		       b1 4f		      lda	(CURPTR),y
    563  044e		       f0 10		      beq	doneadv
    564  0450		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    565  0452		       d0 05		      bne	idoneErr
    566  0454		       84 51		      sty	CUROFF
    567  0456		       4c c2 02 	      jmp	NextIL	; continue on this line
    568  0459
    569  0459				   idoneErr
    570  0459		       a2 04		      ldx	#ERR_EXTRA_STUFF
    571  045b		       a9 00		      lda	#0
    572  045d		       4c 13 06 	      jmp	iErr2
    573  0460							;
    574  0460							; Advance to the next line
    575  0460							;
    576  0460				   doneadv
    577  0460		       4c c2 02 	      jmp	NextIL
    578  0463							;
    579  0463							;=====================================================
    580  0463							; Print the string until a closing quote
    581  0463							;
    582  0463				   iPRS
    583  0463		       20 ac 13 	      jsr	PrtQuoted
    584  0466		       84 51		      sty	CUROFF
    585  0468		       4c c2 02 	      jmp	NextIL
    586  046b							;
    587  046b							;=====================================================
    588  046b							; Pop the top off the stack and print it as a signed
    589  046b							; decimal number.
    590  046b							;
    591  046b				   iPRN
    592  046b		       20 53 1b 	      jsr	popR0
    593  046e		       20 b3 12 	      jsr	PrintDecimal
    594  0471		       4c c2 02 	      jmp	NextIL
    595  0474							;
    596  0474							;=====================================================
    597  0474							; Space to next zone.	Currently the code does not
    598  0474							; keep track of which column the output is on, so
    599  0474							; just print a tab.
    600  0474							;
    601  0474				   iSPC
    602  0474		       a9 09		      lda	#TAB
    603  0476		       20 55 1d 	      jsr	VOUTCH
    604  0479		       4c c2 02 	      jmp	NextIL
    605  047c							;
    606  047c							;=====================================================
    607  047c							; If in immediate mode, jump to the address following
    608  047c							; the NXT instruction.  Else move to the next line of
    609  047c							; user code and continue.
    610  047c							;
    611  047c		       a5 5b	   iNXT       lda	RunMode
    612  047e		       d0 03		      bne	iNxtRun	;in run mode
    613  0480							;
    614  0480							; Get address and jump to it.
    615  0480							;
    616  0480		       4c f8 08 	      jmp	iJMP
    617  0483							;
    618  0483				   iNxtRun
    619  0483		       a4 51		      ldy	CUROFF
    620  0485		       b1 4f		      lda	(CURPTR),y
    621  0487		       c9 e6		      cmp	#oColon
    622  0489		       d0 06		      bne	iNxtRunGo
    623  048b		       c8		      iny
    624  048c		       84 51		      sty	CUROFF
    625  048e		       4c 9c 04 	      jmp	iNxtRun2
    626  0491
    627  0491				   iNxtRunGo
    628  0491		       20 60 19 	      jsr	FindNextLine
    629  0494		       20 74 19 	      jsr	AtEnd
    630  0497		       d0 03		      bne	iNxtRun2	;not at end
    631  0499							;
    632  0499							; At the end of the program.  Pretend an END statement
    633  0499							; was found.
    634  0499							;
    635  0499		       4c fc 05    iFINv      jmp	iFIN
    636  049c							;
    637  049c		       20 d2 18    iNxtRun2   jsr	getILWord	;ignore next word
    638  049f		       4c c2 02 	      jmp	NextIL
    639  04a2							;
    640  04a2							;=====================================================
    641  04a2							; XFER takes the number on top of the stack and looks
    642  04a2							; for that line in the program, or the next line
    643  04a2							; higher.  Ie, if it's 1 but there is no line 1, then
    644  04a2							; find the next one after that.
    645  04a2							;
    646  04a2		       20 53 1b    iXFER      jsr	popR0
    647  04a5		       20 1b 19 	      jsr	findLine
    648  04a8		       20 74 19    iXFER2     jsr	AtEnd	;at end of user program?
    649  04ab		       f0 ec		      beq	iFINv
    650  04ad		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    651  04af		       84 51		      sty	CUROFF
    652  04b1		       a9 ff		      lda	#$ff
    653  04b3		       85 5b		      sta	RunMode
    654  04b5							;
    655  04b5							; Transfer IL to STMT.  I don't like having this
    656  04b5							; hard-coded; fix it.
    657  04b5							;
    658  04b5		       a9 ea		      lda	#STMT&$ff
    659  04b7		       85 43		      sta	ILPC
    660  04b9		       a9 1e		      lda	#STMT>>8
    661  04bb		       85 44		      sta	ILPC+1
    662  04bd		       4c c2 02 	      jmp	NextIL
    663  04c0							;
    664  04c0							; Run
    665  04c0							;
    666  04c0				   iXferok
    667  04c0		       a9 ff		      lda	#$ff
    668  04c2		       85 5b		      sta	RunMode	;we're running
    669  04c4							;
    670  04c4							; Need a more elegant way to do this
    671  04c4							;
    672  04c4		       a9 ea		      lda	#STMT&$ff
    673  04c6		       85 43		      sta	ILPC
    674  04c8		       a9 1e		      lda	#STMT>>8
    675  04ca		       85 44		      sta	ILPC+1
    676  04cc		       4c c2 02 	      jmp	NextIL
    677  04cf							;
    678  04cf							;=====================================================
    679  04cf							; Save the pointer to the next line to the call stack.
    680  04cf							;
    681  04cf		       20 e9 1a    iSAV       jsr	pushLN
    682  04d2		       b0 03		      bcs	iSAVErr
    683  04d4		       4c c2 02 	      jmp	NextIL
    684  04d7
    685  04d7		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    686  04d9		       a9 00	   iSAVErr2   lda	#0
    687  04db		       4c 13 06 	      jmp	iErr2
    688  04de							;====================================================
    689  04de							; Move stack top to and from temp area
    690  04de				   iStk2Tmp
    691  04de		       20 53 1b 	      jsr	popR0
    692  04e1		       a5 52		      lda	R0
    693  04e3		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    694  04e5		       91 41		      sta	(VARIABLES),y
    695  04e7		       c8		      iny
    696  04e8		       a5 53		      lda	R0+1
    697  04ea		       91 41		      sta	(VARIABLES),y
    698  04ec		       4c c2 02 	      jmp	NextIL
    699  04ef
    700  04ef		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    701  04f1		       b1 41		      lda	(VARIABLES),y
    702  04f3		       85 52		      sta	R0
    703  04f5		       c8		      iny
    704  04f6		       b1 41		      lda	(VARIABLES),y
    705  04f8		       85 53		      sta	R0+1
    706  04fa		       20 cf 1a 	      jsr	pushR0
    707  04fd		       4c c2 02 	      jmp	NextIL
    708  0500							;
    709  0500							;=====================================================
    710  0500							; Pop the next line from the call stack.
    711  0500							;
    712  0500		       20 0e 1b    iRET       jsr	popLN
    713  0503		       b0 d2		      bcs	iSAVErr
    714  0505		       a0 03		      ldy	#3
    715  0507		       84 51		      sty	CUROFF
    716  0509		       a9 00		      lda	#0
    717  050b		       8d d2 22 	      sta	IRQPending
    718  050e		       58		      cli
    719  050f		       4c c2 02 	      jmp	NextIL
    720  0512							;
    721  0512							;=====================================================
    722  0512							; Return from GOSUB function
    723  0512							;
    724  0512		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    725  0514		       f0 0f		      beq	iRSTRNoValue
    726  0516		       a5 58		      lda	R2
    727  0518		       85 56		      sta	MQ
    728  051a		       88		      dey
    729  051b		       b1 4b		      lda	(GOSUBSTACK),y
    730  051d		       c9 81		      cmp	#GOSUB_RTN_VALUE
    731  051f		       d0 04		      bne	iRSTRNoValue
    732  0521		       a9 01		      lda	#1
    733  0523		       d0 02		      bne	iRSTRExit
    734  0525				   iRSTRNoValue
    735  0525		       a9 00		      lda	#0
    736  0527				   iRSTRExit
    737  0527		       85 58		      sta	R2
    738  0529		       20 0e 1b 	      jsr	popLN
    739  052c		       b0 06		      bcs	iRSTRErr
    740  052e		       20 a2 14 	      jsr	PopMathStackNow
    741  0531		       4c c2 02 	      jmp	NextIL
    742  0534
    743  0534		       ad d5 22    iRSTRErr   lda	taskPtr	; Check if this is task zero
    744  0537		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    745  0539		       a5 56		      lda	MQ
    746  053b		       d0 03		      bne	taskRet
    747  053d		       20 70 1d 	      jsr	pushFalse	; the result code by default is 0
    748  0540				   taskRet
    749  0540		       4c 1f 17 	      jmp	iETask	; not task zero then do a task end instead
    750  0543				   taskZeroEnd
    751  0543		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    752  0545		       d0 92		      bne	iSAVErr2
    753  0547							;
    754  0547							;=====================================================
    755  0547							; Compare items on stack.  Okay, so on input there are
    756  0547							; three things on the stack
    757  0547							;
    758  0547							;    EXPR2 <- Top of stack
    759  0547							;    OP    <- relational operator, next on stack
    760  0547							;    EXPR1 <- last item on stack
    761  0547							;
    762  0547							; Comparison is: EXPR1 <operator> EXPR2
    763  0547							;
    764  0547							; Operator is one of...
    765  0547							;
    766  0547							;    2 is =
    767  0547							;    1 is <
    768  0547							;    3 is <=
    769  0547							;    5 is <>
    770  0547							;    4 is >
    771  0547							;    6 is >=
    772  0547							;
    773  0547							; Those are bit-mapped:
    774  0547							;
    775  0547							;    xxxxxGEL
    776  0547							;
    777  0547							;    G = Greater than
    778  0547							;    E = Equal
    779  0547							;    L = Less than
    780  0547							;
    781  0547							; If the comparison is false, do a NXT, ie, move to the
    782  0547							; next line and continue.  If true, continue executing
    783  0547							; on this line.
    784  0547							;
    785  0547		       00 01	   REL_LT     equ	%001
    786  0547		       00 02	   REL_EQUAL  equ	%010
    787  0547		       00 04	   REL_GT     equ	%100
    788  0547							;
    789  0547		       20 6b 1b    iCMPR      jsr	popR1
    790  054a		       20 82 1b 	      jsr	popMQ	;operator in MQ
    791  054d		       20 53 1b 	      jsr	popR0
    792  0550		       20 59 05 	      jsr	iCMPRsub
    793  0553		       20 cf 1a 	      jsr	pushR0
    794  0556		       4c c2 02 	      jmp	NextIL
    795  0559							;
    796  0559							; See if they are equal or not
    797  0559							;
    798  0559				   iCMPRsub		; Called by internal functions
    799  0559
    800  0559		       a5 52		      lda	R0
    801  055b		       c5 54		      cmp	R1
    802  055d		       d0 0a		      bne	iCMPRnoteq	;try not equal
    803  055f		       a5 53		      lda	R0+1
    804  0561		       c5 55		      cmp	R1+1
    805  0563		       d0 04		      bne	iCMPRnoteq
    806  0565							;
    807  0565							; Equal, set the flag in MQ+1
    808  0565							;
    809  0565		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    810  0567		       d0 14		      bne	iCMPcom	;Exit it is equal
    811  0569							;
    812  0569							; See if EXPR1 (R0) < EXPR2 (R1)
    813  0569							; See www.6502.org/tutorials/compare_beyond.html
    814  0569							;
    815  0569				   iCMPRnoteq
    816  0569		       a5 52		      lda	R0
    817  056b		       c5 54		      cmp	R1
    818  056d		       a5 53		      lda	R0+1
    819  056f		       e5 55		      sbc	R1+1
    820  0571		       50 02		      bvc	iCMPR_2
    821  0573		       49 80		      eor	#$80
    822  0575		       30 04	   iCMPR_2    bmi	iCMPlt
    823  0577		       a9 04		      lda	#REL_GT
    824  0579		       d0 02		      bne	iCMPcom
    825  057b		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    826  057d
    827  057d		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    828  057f							;
    829  057f							; Now compare the end result with what the caller
    830  057f							; was looking for.
    831  057f							;
    832  057f		       25 56		      and	MQ
    833  0581		       f0 0c		      beq	iCMPno	; no match
    834  0583		       a9 ff		      lda	#$FF	; true is $ffff
    835  0585		       85 52		      sta	R0
    836  0587		       85 53		      sta	R0+1
    837  0589		       d0 0c		      bne	iCMPDone
    838  058b							;
    839  058b							; R0 > R1
    840  058b							;
    841  058b		       a9 04	   iCMPgt     lda	#REL_GT
    842  058d		       d0 ee		      bne	iCMPcom
    843  058f				   iCMPno
    844  058f		       a9 00		      lda	#0
    845  0591		       85 52		      sta	R0
    846  0593		       a9 00		      lda	#0
    847  0595		       85 53		      sta	R0+1
    848  0597
    849  0597				   iCMPDone
    850  0597		       60		      rts
    851  0598
    852  0598							;
    853  0598							; if Not a match, so jump to the next line of code.
    854  0598							; Branches based upon value on top of the stack
    855  0598				   iBranch
    856  0598		       20 53 1b 	      jsr	popR0
    857  059b		       a5 52		      lda	R0
    858  059d		       05 53		      ora	R0+1
    859  059f		       f0 03		      beq	iBranchFalse	; not true
    860  05a1		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    861  05a4							;
    862  05a4				   iBranchFalse
    863  05a4		       20 60 19 	      jsr	FindNextLine
    864  05a7		       4c a8 04 	      jmp	iXFER2
    865  05aa							;
    866  05aa							;=====================================================
    867  05aa							; Start a read of data in background
    868  05aa				   iReadStart
    869  05aa		       a9 3f		      lda	#'?	; Prompt with question mark
    870  05ac		       a6 01		      ldx	1	; Indicate to start read in background
    871  05ae		       20 ec 19 	      jsr	GetLine	; Call the getline to start read
    872  05b1		       4c c2 02 	      jmp	NextIL	; next instruction
    873  05b4							;
    874  05b4							;=====================================================
    875  05b4							; Complete the read and return the curptr, curoff pointing to data
    876  05b4				   iReadComplete
    877  05b4		       20 e9 1a 	      jsr	pushLN
    878  05b7		       90 03		      bcc	iReadOk
    879  05b9		       4c 8a 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    880  05bc				   iReadOk
    881  05bc		       20 0c 1a 	      jsr	ReadComplete
    882  05bf		       4c c2 02 	      jmp	NextIL
    883  05c2		       20 0e 1b 	      jsr	popLN
    884  05c5		       4c c2 02 	      jmp	NextIL
    885  05c8							;=====================================================
    886  05c8							; Get a line of text from the user, convert to a
    887  05c8							; number, leave on top of stack.
    888  05c8							;
    889  05c8				   iINNUM
    890  05c8		       20 e9 1a 	      jsr	pushLN
    891  05cb		       b0 ec		      bcs	iReadErr	; Stack over flow error
    892  05cd							;
    893  05cd		       a9 3f		      lda	#'?
    894  05cf		       a2 00		      ldx	#0	;Wait for complete
    895  05d1		       20 ec 19 	      jsr	GetLine
    896  05d4		       20 81 19 	      jsr	getDecimal
    897  05d7		       20 cf 1a 	      jsr	pushR0	;put onto stack
    898  05da		       b0 dd		      bcs	iReadErr	;StackOverflow error
    899  05dc							;
    900  05dc		       4c f6 05 	      jmp	ExitIn
    901  05df							;
    902  05df							;=====================================================
    903  05df							; Get a line of text from the user, convert to a
    904  05df							; character value , leave on top of stack. up to 2 characters
    905  05df							;
    906  05df				   iINSTR
    907  05df		       20 e9 1a 	      jsr	pushLN
    908  05e2		       b0 d5		      bcs	iReadErr	; Stack overflow error
    909  05e4		       a9 3f		      lda	#'?
    910  05e6		       a2 00		      ldx	#0	;wait for read complete
    911  05e8		       20 ec 19 	      jsr	GetLine
    912  05eb		       b1 4f		      lda	(CURPTR),y
    913  05ed		       85 52		      sta	R0
    914  05ef		       a9 00		      lda	#0
    915  05f1		       85 53		      sta	R0+1
    916  05f3		       20 cf 1a 	      jsr	pushR0	;put onto stack
    917  05f6				   ExitIn
    918  05f6		       20 0e 1b 	      jsr	popLN
    919  05f9		       4c c2 02 	      jmp	NextIL
    920  05fc							;
    921  05fc							;
    922  05fc							;=====================================================
    923  05fc							; Stop the currently running program.	Actually very
    924  05fc							; simple to do... clear the RunMode flag, then set the
    925  05fc							; ILPC to the standard handler and continue running.
    926  05fc							;
    927  05fc		       a9 00	   iFIN       lda	#0
    928  05fe		       85 5b		      sta	RunMode
    929  0600		       20 77 15 	      jsr	taskReset
    930  0603							;
    931  0603		       ad 1b 2c 	      lda	errGoto
    932  0606		       85 43		      sta	ILPC
    933  0608		       ad 1c 2c 	      lda	errGoto+1
    934  060b		       85 44		      sta	ILPC+1
    935  060d		       4c c2 02 	      jmp	NextIL
    936  0610							;
    937  0610							;=====================================================
    938  0610							; Handle the ERR opcode.  Following the instruction is
    939  0610							; a 16 bit error number.  Print an error message, and
    940  0610							; if we're in run mode, print the line number.  Stop
    941  0610							; program execution and return to the initial state.
    942  0610							;
    943  0610		       20 d2 18    iERR       jsr	getILWord	;get err code
    944  0613							;
    945  0613							; Enter here with the error code in X (LSB) and A (MSB).
    946  0613							;
    947  0613		       86 52	   iErr2      stx	R0
    948  0615		       85 53		      sta	R0+1
    949  0617							;
    950  0617		       20 82 13 	      jsr	puts
      0  061a					      db	CR,LF,"Error ",0
      1  061a		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    952  0623		       20 b3 12 	      jsr	PrintDecimal
    953  0626							;
    954  0626		       a5 5b		      lda	RunMode	;running?
    955  0628		       f0 3b		      beq	iERR3	;nope
    956  062a		       20 82 13 	      jsr	puts
      0  062d					      db	" at line ",0
      1  062d		       20 61 74 20*	      .byte.b	" at line ",0
    958  0637		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    959  0639				   iErr2a
    960  0639		       b1 4f		      lda	(CURPTR),y
    961  063b		       85 52		      sta	R0
    962  063d		       c8		      iny
    963  063e		       b1 4f		      lda	(CURPTR),y
    964  0640		       85 53		      sta	R0+1
    965  0642		       20 b3 12 	      jsr	PrintDecimal
    966  0645		       20 82 13 	      jsr	puts
      0  0648					      db	":",0
      1  0648		       3a 00		      .byte.b	":",0
    968  064a		       a9 00		      lda	#0
    969  064c		       85 53		      sta	R0+1
    970  064e		       a5 51		      lda	CUROFF
    971  0650		       18		      clc
    972  0651		       e9 03		      sbc	#3
    973  0653		       85 52		      sta	R0
    974  0655		       20 b3 12 	      jsr	PrintDecimal
    975  0658		       20 82 13 	      jsr	puts
      0  065b					      db	":",0
      1  065b		       3a 00		      .byte.b	":",0
    977  065d		       ad d5 22 	      lda	taskPtr
    978  0660		       85 52		      sta	R0
    979  0662		       20 b3 12 	      jsr	PrintDecimal
    980  0665							;
    981  0665		       20 0c 1c    iERR3      jsr	CRLF
    982  0668		       20 6f 15 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    983  066b		       a9 00		      lda	#0
    984  066d		       85 5b		      sta	RunMode	;fall through...
    985  066f							;
    986  066f							;=====================================================
    987  066f							; Reset the IL to be back at the idle loop.  Does not
    988  066f							; clear variables so the user can see what state
    989  066f							; the program is in.
    990  066f							;
    991  066f		       a9 00	   ResetIL    lda	#0
    992  0671		       85 47		      sta	ILSTACKPTR
    993  0673		       ad 1b 2c 	      lda	errGoto
    994  0676		       85 43		      sta	ILPC
    995  0678		       ad 1c 2c 	      lda	errGoto+1
    996  067b		       85 44		      sta	ILPC+1
    997  067d		       4c c2 02 	      jmp	NextIL
    998  0680
    999  0680							;
   1000  0680							;=====================================================
   1001  0680							; Pop two items off stack, add them, then place the
   1002  0680							; result back onto the stack.
   1003  0680							;
   1004  0680		       20 53 1b    iADD       jsr	popR0
   1005  0683		       20 6b 1b 	      jsr	popR1
   1006  0686				   iADDfast
   1007  0686		       18		      clc
   1008  0687		       a5 52		      lda	R0
   1009  0689		       65 54		      adc	R1
   1010  068b		       85 52		      sta	R0
   1011  068d		       a5 53		      lda	R0+1
   1012  068f		       65 55		      adc	R1+1
   1013  0691		       85 53		      sta	R0+1
   1014  0693		       4c fe 06 	      jmp	pushR0nextIl
   1015  0696							;
   1016  0696							;=====================================================
   1017  0696							; Pop two items off the stack.  Subtract the top of
   1018  0696							; stack from the lower entry.
   1019  0696							;
   1020  0696		       20 6b 1b    iSUB       jsr	popR1
   1021  0699		       20 53 1b 	      jsr	popR0
   1022  069c		       38		      sec
   1023  069d		       a5 52		      lda	R0
   1024  069f		       e5 54		      sbc	R1
   1025  06a1		       85 52		      sta	R0
   1026  06a3		       a5 53		      lda	R0+1
   1027  06a5		       e5 55		      sbc	R1+1
   1028  06a7		       85 53		      sta	R0+1
   1029  06a9		       4c fe 06 	      jmp	pushR0nextIl
   1030  06ac							;
   1031  06ac							;=====================================================
   1032  06ac							; Negate the top of stack.
   1033  06ac							;
   1034  06ac		       20 53 1b    iNEG       jsr	popR0
   1035  06af		       a5 52		      lda	R0
   1036  06b1		       49 ff		      eor	#$ff
   1037  06b3		       85 52		      sta	R0
   1038  06b5		       a5 53		      lda	R0+1
   1039  06b7		       49 ff		      eor	#$ff
   1040  06b9		       85 53		      sta	R0+1
   1041  06bb		       e6 52		      inc	R0
   1042  06bd		       d0 02		      bne	iNEG2
   1043  06bf		       e6 53		      inc	R0+1
   1044  06c1		       4c fe 06    iNEG2      jmp	pushR0nextIl
   1045  06c4							;
   1046  06c4							;=====================================================
   1047  06c4							; Multiply top two items on the stack, put the results
   1048  06c4							; on top.  This uses the algorithm documented on page
   1049  06c4							; 115 of "Microprocessor Programming for Computer
   1050  06c4							; Hobbyists" by Neill Graham.
   1051  06c4							;
   1052  06c4		       20 ca 06    iMUL       jsr	iMultiply
   1053  06c7		       4c c2 02 	      jmp	NextIL
   1054  06ca
   1055  06ca				   iMultiply
   1056  06ca		       20 53 1b 	      jsr	popR0	;AC
   1057  06cd		       20 6b 1b 	      jsr	popR1	;OP
   1058  06d0							;
   1059  06d0		       a5 52		      lda	R0
   1060  06d2		       85 56		      sta	MQ
   1061  06d4		       a5 53		      lda	R0+1
   1062  06d6		       85 57		      sta	MQ+1
   1063  06d8		       a9 00		      lda	#0	;clear result
   1064  06da		       85 52		      sta	R0
   1065  06dc		       85 53		      sta	R0+1
   1066  06de							;
   1067  06de		       a2 10		      ldx	#16	;number of bits in value
   1068  06e0		       06 52	   multloop   asl	R0
   1069  06e2		       26 53		      rol	R0+1
   1070  06e4		       06 56		      asl	MQ
   1071  06e6		       26 57		      rol	MQ+1
   1072  06e8		       90 0d		      bcc	multno	;skip add if no carry
   1073  06ea							;
   1074  06ea							; Add R1 back into R0
   1075  06ea							;
   1076  06ea		       18		      clc
   1077  06eb		       a5 52		      lda	R0
   1078  06ed		       65 54		      adc	R1
   1079  06ef		       85 52		      sta	R0
   1080  06f1		       a5 53		      lda	R0+1
   1081  06f3		       65 55		      adc	R1+1
   1082  06f5		       85 53		      sta	R0+1
   1083  06f7							;
   1084  06f7		       ca	   multno     dex		;did all bits yet?
   1085  06f8		       d0 e6		      bne	multloop
   1086  06fa		       20 cf 1a 	      jsr	pushR0	;OP
   1087  06fd		       60		      rts
   1088  06fe							;
   1089  06fe				   pushR0nextIl
   1090  06fe		       20 cf 1a 	      jsr	pushR0	;OP
   1091  0701		       4c c2 02 	      jmp	NextIL
   1092  0704							;
   1093  0704							;=====================================================
   1094  0704							; Divide the top of stack into the next to top item.
   1095  0704							; Leave results on stack.  Taken from:
   1096  0704							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1097  0704							;
   1098  0704							; R0 = R0 / R1
   1099  0704							; Remainder is in MQ
   1100  0704							;
   1101  0704		       20 1e 07    iDIV       jsr	iDoDiv
   1102  0707		       20 d4 1b 	      jsr	RestoreSigns
   1103  070a		       4c fe 06 	      jmp	pushR0nextIl
   1104  070d
   1105  070d		       20 1e 07    iMOD       jsr	iDoDiv
   1106  0710		       20 d4 1b 	      jsr	RestoreSigns
   1107  0713		       a5 56		      lda	MQ
   1108  0715		       85 52		      sta	R0
   1109  0717		       a5 57		      lda	MQ+1
   1110  0719		       85 53		      sta	R0+1
   1111  071b		       4c fe 06 	      jmp	pushR0nextIl
   1112  071e
   1113  071e				   iDoDiv
   1114  071e		       20 6b 1b 	      jsr	popR1
   1115  0721		       20 53 1b 	      jsr	popR0
   1116  0724							;
   1117  0724							; Check for divide by zero
   1118  0724							;
   1119  0724
   1120  0724				   iDivNoPop
   1121  0724		       a5 54		      lda	R1
   1122  0726		       05 55		      ora	R1+1
   1123  0728		       f0 29		      beq	divby0
   1124  072a							;
   1125  072a		       20 99 1b 	      jsr	SaveSigns
   1126  072d		       a9 00		      lda	#0	;preset remainder to 0
   1127  072f		       85 56		      sta	MQ
   1128  0731		       85 57		      sta	MQ+1
   1129  0733		       a2 10		      ldx	#16	;repeat for each bit: ...
   1130  0735				   divloop
   1131  0735		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1132  0737		       26 53		      rol	R0+1
   1133  0739		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1134  073b		       26 57		      rol	MQ+1
   1135  073d		       a5 56		      lda	MQ
   1136  073f		       38		      sec
   1137  0740		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1138  0742		       a8		      tay		;lb result -> Y, for we may need it later
   1139  0743		       a5 57		      lda	MQ+1
   1140  0745		       e5 55		      sbc	R1+1
   1141  0747		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1142  0749
   1143  0749		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1144  074b		       84 56		      sty	MQ
   1145  074d		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1146  074f
   1147  074f		       ca	   skip       dex
   1148  0750		       d0 e3		      bne	divloop
   1149  0752		       60		      rts
   1150  0753							;
   1151  0753							; Indicate divide-by-zero error
   1152  0753							;
   1153  0753		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1154  0755		       a9 00		      lda	#0
   1155  0757		       4c 13 06 	      jmp	iErr2
   1156  075a							;
   1157  075a							;=====================================================
   1158  075a							; This pops the top two items off the stack.  The top
   1159  075a							; item is a data value and the other is an ABSOLUTE address.
   1160  075a							;Save the value into that address.
   1161  075a							;
   1162  075a		       98	   iSTORE     tya
   1163  075b		       48		      pha
   1164  075c		       20 53 1b 	      jsr	popR0	;data
   1165  075f		       20 6b 1b 	      jsr	popR1	;Storage location
   1166  0762		       a0 00		      ldy	#0
   1167  0764		       a5 52		      lda	R0
   1168  0766		       91 54		      sta	(R1),y
   1169  0768		       a5 53		      lda	R0+1
   1170  076a		       c8		      iny
   1171  076b		       91 54		      sta	(R1),y
   1172  076d		       68		      pla
   1173  076e		       a8		      tay
   1174  076f		       4c c2 02 	      jmp	NextIL
   1175  0772							;
   1176  0772							;=====================================================
   1177  0772							; Replaces the top of stack with the variable whose
   1178  0772							; absolute address it represents.
   1179  0772							;
   1180  0772		       98	   iIND       tya
   1181  0773		       48		      pha
   1182  0774		       20 6b 1b 	      jsr	popR1
   1183  0777		       a0 00		      ldy	#0
   1184  0779		       b1 54		      lda	(R1),y
   1185  077b		       85 52		      sta	R0
   1186  077d		       c8		      iny
   1187  077e		       b1 54		      lda	(R1),y
   1188  0780		       85 53		      sta	R0+1
   1189  0782		       68		      pla
   1190  0783		       a8		      tay
   1191  0784		       4c fe 06 	      jmp	pushR0nextIl
   1192  0787							;
   1193  0787							;=====================================================
   1194  0787							; Get the array index from top of stack get Current variable
   1195  0787							; address from next on stack, add the offset
   1196  0787							; push the result back onto the stack
   1197  0787				   iArray
   1198  0787		       20 53 1b 	      jsr	popR0	; Get the array index
   1199  078a		       20 6b 1b 	      jsr	popR1	; Get the Variable address
   1200  078d
   1201  078d		       18		      clc		; Multiplythe value by 2
   1202  078e		       26 52		      rol	R0	; Do the multiply
   1203  0790		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1204  0792		       18		      clc
   1205  0793		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1206  0795		       65 52		      adc	R0
   1207  0797		       85 52		      sta	R0
   1208  0799		       a5 55		      lda	R1+1
   1209  079b		       65 53		      adc	R0+1
   1210  079d		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1211  079f		       20 cf 1a 	      jsr	pushR0	; Push R0 assume it is correct
   1212  07a2
   1213  07a2		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1214  07a4		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1215  07a6		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1216  07a8		       a5 55		      lda	R1+1
   1217  07aa		       c5 42		      cmp	VARIABLES+1
   1218  07ac		       d0 1c		      bne	iArrayAtTest
   1219  07ae		       18		      clc
   1220  07af		       a9 34		      lda	#52	; add the max offset that is valid
   1221  07b1		       65 54		      adc	R1	; update to be the largest offset that is valid
   1222  07b3		       85 54		      sta	R1
   1223  07b5		       a9 00		      lda	#0
   1224  07b7		       65 55		      adc	R1+1
   1225  07b9		       85 55		      sta	R1+1
   1226  07bb				   iArrayVerify 		; try to enforce some sanity to using arrays
   1227  07bb		       a5 53		      lda	R0+1
   1228  07bd		       c5 55		      cmp	R1+1
   1229  07bf		       d0 04		      bne	iArrayDecide
   1230  07c1		       a5 52		      lda	R0
   1231  07c3		       c5 54		      cmp	R1
   1232  07c5				   iArrayDecide
   1233  07c5		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1234  07c7		       4c c2 02 	      jmp	NextIL
   1235  07ca
   1236  07ca				   iArrayAtTest
   1237  07ca		       ad 32 2c 	      lda	HighMem
   1238  07cd		       85 54		      sta	R1
   1239  07cf		       ad 33 2c 	      lda	HighMem+1
   1240  07d2		       85 55		      sta	R1+1
   1241  07d4		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1242  07d6
   1243  07d6							; Get here if array index is out of range
   1244  07d6		       20 53 1b    iArrayError jsr	popR0
   1245  07d9		       a9 00		      lda	#0
   1246  07db		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1247  07dd		       4c 13 06 	      jmp	iErr2
   1248  07e0							;
   1249  07e0							;=====================================================
   1250  07e0							; List the current BASIC program in memory.  Uses R0,
   1251  07e0							; tempIly, and dpl.
   1252  07e0							;
   1253  07e0		       20 3b 1d    iLST       jsr	SetOutConsole
   1254  07e3		       ad 2e 2c    iLST2      lda	ProgramStart
   1255  07e6		       85 59		      sta	dpl
   1256  07e8		       ad 2f 2c 	      lda	ProgramStart+1
   1257  07eb		       85 5a		      sta	dpl+1
   1258  07ed							;
   1259  07ed							; dpl/dph point to the current line.  See if we're at
   1260  07ed							; the end of the program.
   1261  07ed							;
   1262  07ed		       a5 59	   iLSTloop   lda	dpl
   1263  07ef		       cd 30 2c 	      cmp	ProgramEnd
   1264  07f2		       d0 07		      bne	iLstNotEnd
   1265  07f4		       a5 5a		      lda	dpl+1
   1266  07f6		       cd 31 2c 	      cmp	ProgramEnd+1
   1267  07f9		       f0 15		      beq	iLstdone
   1268  07fb							;
   1269  07fb		       20 8c 11    iLstNotEnd jsr	PrintProgramLine
   1270  07fe							;		  ldy	  #1		  ;Change:  Skip first byte length
   1271  07fe							;		  lda	  (dpl),y	  ;line number LSB
   1272  07fe							;		  sta	  R0
   1273  07fe							;		  iny
   1274  07fe							;		  lda	  (dpl),y		 ;line number MSB
   1275  07fe							;		  sta	  R0+1
   1276  07fe							;		  iny
   1277  07fe							;		  sty	  tempIlY
   1278  07fe							;		  jsr	  PrintDecimal
   1279  07fe							;		  lda	  #SPACE
   1280  07fe							;		  jsr	  VOUTCH
   1281  07fe							;		  ldy	  tempIlY
   1282  07fe							;iLSTl2	  lda	  (dpl),y
   1283  07fe							;		  beq	  iLST3 	  ;end of this line 0 value
   1284  07fe							;		  sty	  tempIlY
   1285  07fe							;		  jsr	  VOUTCH
   1286  07fe							;		  ldy	  tempIlY
   1287  07fe							;		  iny
   1288  07fe							;		  bne	  iLSTl2	  ;do next char
   1289  07fe							;
   1290  07fe							; End of this line.  Print CR/LF, then move to the
   1291  07fe							; next line.
   1292  07fe							;
   1293  07fe		       a0 00	   iLST3      ldy	#0	;Move to next line
   1294  0800		       b1 59		      lda	(dpl),y	;Current line length
   1295  0802		       18		      clc		;Clear the carry flag
   1296  0803							;		  tya
   1297  0803		       65 59		      adc	dpl	;Add the offset to the pointer
   1298  0805		       85 59		      sta	dpl	;Save the new value
   1299  0807		       a5 5a		      lda	dpl+1	;Next byte
   1300  0809		       69 00		      adc	#0	;ad in the carry if any
   1301  080b		       85 5a		      sta	dpl+1	;Save it
   1302  080d							;
   1303  080d							; Have to manually do CR/LF so it uses the vectored
   1304  080d							; output function.
   1305  080d							;
   1306  080d							;		  lda	  #CR
   1307  080d							;		  jsr	  VOUTCH
   1308  080d							;		  lda	  #LF
   1309  080d							;		  jsr	  VOUTCH
   1310  080d		       4c ed 07 	      jmp	iLSTloop	;do next line
   1311  0810							;
   1312  0810		       20 3b 1d    iLstdone   jsr	SetOutConsole
   1313  0813		       4c c2 02 	      jmp	NextIL
   1314  0816							;
   1315  0816							;=====================================================
   1316  0816							; Get a line of text into LINBUF.  Terminate with a
   1317  0816							; null byte.
   1318  0816							;
   1319  0816				   iGETLINE
   1320  0816		       a9 3e		      lda	#'>	;prompt character
   1321  0818		       a6 00		      ldx	0	;Wait for read to complete
   1322  081a		       20 ec 19 	      jsr	GetLine
   1323  081d							;
   1324  081d		       a9 00		      lda	#0
   1325  081f		       85 5b		      sta	RunMode
   1326  0821				   iGetParseLine
   1327  0821							; lda	   CUROFF
   1328  0821							; pha
   1329  0821		       20 38 0f 	      jsr	ParseInputLine
   1330  0824							; pla
   1331  0824							;  sta     CUROFF
   1332  0824		       a9 35		      lda	#TOKENBUFFER&$FF
   1333  0826		       85 4f		      sta	CURPTR
   1334  0828		       a9 0e		      lda	#TOKENBUFFER>>8
   1335  082a		       85 50		      sta	CURPTR+1
   1336  082c		       a9 01		      lda	#1
   1337  082e		       85 51		      sta	CUROFF
   1338  0830		       4c c2 02 	      jmp	NextIL
   1339  0833							;
   1340  0833							;=====================================================
   1341  0833							; This is called when the input buffer contains a line
   1342  0833							; typed in by the user that starts with a line number.
   1343  0833							; Insert the line into the program or delete the line
   1344  0833							; if there is nothing after the line number,
   1345  0833							;
   1346  0833				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1347  0833		       ad 36 0e 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1348  0836		       85 52		      sta	R0	; place the number into R0
   1349  0838		       ad 37 0e 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1350  083b		       85 53		      STA	R0+1	; Place it into
   1351  083d							;
   1352  083d							; Now find the line OR the next higher line OR the
   1353  083d							; end of the program.
   1354  083d							;
   1355  083d		       20 1b 19 	      jsr	findLine	; Look for the line number in the current program
   1356  0840							; Returns Z and curptr point to the line if found
   1357  0840							; Returns C and curptr at next higher line if not found and there is a higher line
   1358  0840							; Returns ZC clear and curptr to end of program if higher than all other lines
   1359  0840							;
   1360  0840							; If the line exists, it needs to be removed.
   1361  0840							;
   1362  0840		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1363  0842							;
   1364  0842							; Get length of line to be removed, we fall thru to here if we find a matching line
   1365  0842							;
   1366  0842							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1367  0842		       a0 00		      ldy	#0
   1368  0844		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1369  0846		       a8		      tay
   1370  0847							;If it is equal we delete the line and replace it, get length
   1371  0847							;then adjust all program line after up or down depending on len of line
   1372  0847							;If next higher then just move everythimg down by length bytes
   1373  0847							;This call will return how many bytes in the line we found
   1374  0847		       8c 2b 2c 	      sty	lineLength	;Save the length of the line we found
   1375  084a							;
   1376  084a							; Compute the new end of the program first.
   1377  084a							;
   1378  084a		       38		      sec		;Set the carry bit
   1379  084b		       ad 30 2c 	      lda	ProgramEnd	;Get low byte of program end
   1380  084e		       ed 2b 2c 	      sbc	lineLength	;Subtract the length of the current line
   1381  0851		       8d 30 2c 	      sta	ProgramEnd	;save it
   1382  0854		       ad 31 2c 	      lda	ProgramEnd+1
   1383  0857		       e9 00		      sbc	#0	;Process the carry
   1384  0859		       8d 31 2c 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1385  085c							;
   1386  085c							; Copy CURPTR into R1 for working
   1387  085c							;
   1388  085c		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1389  085e		       85 54		      sta	R1
   1390  0860		       a5 50		      lda	CURPTR+1
   1391  0862		       85 55		      sta	R1+1
   1392  0864							;
   1393  0864							; See if we're at the end.
   1394  0864							;
   1395  0864		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1396  0866		       cd 30 2c 	      cmp	ProgramEnd
   1397  0869		       d0 07		      bne	InsDelLoop
   1398  086b		       a5 55		      lda	R1+1
   1399  086d		       cd 31 2c 	      cmp	ProgramEnd+1
   1400  0870		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1401  0872							;
   1402  0872							; Move one byte, move to next location.
   1403  0872							;
   1404  0872		       ac 2b 2c    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1405  0875		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1406  0877		       b1 54		      lda	(R1),y
   1407  0879		       a0 00		      ldy	#0
   1408  087b		       91 54		      sta	(R1),y
   1409  087d		       e6 54		      inc	R1
   1410  087f		       d0 e3		      bne	InsDelChk
   1411  0881		       e6 55		      inc	R1+1
   1412  0883		       4c 64 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1413  0886							;
   1414  0886							; Deletion is done.
   1415  0886							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1416  0886							;
   1417  0886				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1418  0886		       ad 35 0e 	      lda	TOKENBUFFER	; Get the length
   1419  0889		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1420  088b							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1421  088b		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1422  088d							;
   1423  088d							; CURPTR points to where the line will be inserted.
   1424  088d							;
   1425  088d							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1426  088d		       ae 35 0e 	      ldx	TOKENBUFFER
   1427  0890		       8e 2b 2c 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1428  0893							;
   1429  0893		       ad 30 2c 	      lda	ProgramEnd	;Load the start address for the copy
   1430  0896							;At this point curptr still contains the location we will insert data
   1431  0896		       85 5c		      sta	FROM
   1432  0898		       ad 31 2c 	      lda	ProgramEnd+1
   1433  089b		       85 5d		      sta	FROM+1
   1434  089d							;
   1435  089d		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1436  089f		       b1 5c		      lda	(FROM),y
   1437  08a1		       ac 2b 2c 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1438  08a4		       91 5c		      sta	(FROM),y	;Save the new byte
   1439  08a6							;
   1440  08a6		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1441  08a8		       c5 4f		      cmp	CURPTR
   1442  08aa		       d0 06		      bne	mvUpMore
   1443  08ac		       a5 5d		      lda	FROM+1
   1444  08ae		       c5 50		      cmp	CURPTR+1
   1445  08b0		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1446  08b2							;
   1447  08b2							; Not done yet
   1448  08b2							;
   1449  08b2		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1450  08b4		       d0 02		      bne	mvUpMore2
   1451  08b6		       c6 5d		      dec	FROM+1
   1452  08b8		       c6 5c	   mvUpMore2  dec	FROM
   1453  08ba		       4c 9d 08 	      jmp	mvup1	;Loop until everything is moved
   1454  08bd							;
   1455  08bd							; All done with copy.
   1456  08bd							;
   1457  08bd				   mvUpDone
   1458  08bd		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1459  08be		       ad 2b 2c 	      lda	lineLength	;Number of bytes to copy from line buff
   1460  08c1		       6d 30 2c 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1461  08c4		       8d 30 2c 	      sta	ProgramEnd
   1462  08c7		       ad 31 2c 	      lda	ProgramEnd+1
   1463  08ca		       69 00		      adc	#0
   1464  08cc		       8d 31 2c 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1465  08cf							;
   1466  08cf							;===================jlit use length before line newline
   1467  08cf
   1468  08cf		       a0 00		      ldy	#0	;Set offset of copy
   1469  08d1							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1470  08d1							;		  sta	  (CURPTR),y	  ;Store the length
   1471  08d1							;		  iny
   1472  08d1							;		  lda	  R0		  ;Store the line number next
   1473  08d1							;		  sta	  (CURPTR),y
   1474  08d1							;		  iny
   1475  08d1							;		  lda	  R0+1
   1476  08d1							;		  sta	  (CURPTR),y
   1477  08d1							;		  iny
   1478  08d1							;
   1479  08d1							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1480  08d1		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1481  08d3				   mvUpLoop2
   1482  08d3							;		  lda	  LINBUF,x	 ;get a byte
   1483  08d3		       bd 35 0e 	      lda	TOKENBUFFER,x	;get a byte
   1484  08d6		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1485  08d8
   1486  08d8		       e8		      inx
   1487  08d9		       ec 35 0e 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1488  08dc		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1489  08de		       c8		      iny
   1490  08df		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1491  08e1							;
   1492  08e1		       4c c2 02    mvUpFini   jmp	NextIL
   1493  08e4							;
   1494  08e4							;=====================================================
   1495  08e4							; Pops the top value of the ILPC stack and stores it
   1496  08e4							; in ILPC.  Ie, return from an IL subroutine.
   1497  08e4							;
   1498  08e4		       20 09 19    iRTN       jsr	popILPC
   1499  08e7		       4c c2 02 	      jmp	NextIL
   1500  08ea							;
   1501  08ea							;=====================================================
   1502  08ea							; NLINE print a newline
   1503  08ea							;
   1504  08ea		       20 0c 1c    iNLINE     jsr	CRLF	;user supplied sub
   1505  08ed		       4c c2 02 	      jmp	NextIL
   1506  08f0							;
   1507  08f0							;=====================================================
   1508  08f0							; This saves the current ILPC value on the stack, then
   1509  08f0							; jumps to the address specified by the next two bytes.
   1510  08f0							;
   1511  08f0		       20 ec 18    iCALL      jsr	pushILPC	;save ILPC
   1512  08f3		       90 03		      bcc	iJMP
   1513  08f5		       4c 8a 0b 	      jmp	ErrStkOver	; Check if there was an error
   1514  08f8							;
   1515  08f8							; Jmp to a specific location in the IL code.  The new
   1516  08f8							; address immediately follows the opcode.
   1517  08f8							;
   1518  08f8		       20 d2 18    iJMP       jsr	getILWord
   1519  08fb		       86 43		      stx	ILPC
   1520  08fd		       85 44		      sta	ILPC+1
   1521  08ff		       4c c2 02 	      jmp	NextIL
   1522  0902
   1523  0902
   1524  0902							;
   1525  0902							;=====================================================
   1526  0902							; Push the next two bytes onto the arithmetic stack.
   1527  0902							;
   1528  0902		       20 d6 18    iSetR2     jsr	getILByte
   1529  0905		       85 58		      sta	R2
   1530  0907		       4c c2 02 	      jmp	NextIL
   1531  090a							;
   1532  090a							;=====================================================
   1533  090a							; Push the next two bytes onto the arithmetic stack.
   1534  090a							;
   1535  090a		       20 d2 18    iLIT       jsr	getILWord
   1536  090d		       86 52		      stx	R0
   1537  090f		       85 53		      sta	R0+1
   1538  0911		       20 cf 1a 	      jsr	pushR0
   1539  0914		       4c c2 02 	      jmp	NextIL
   1540  0917							;
   1541  0917							;=====================================================
   1542  0917							; Initialize all variables for a single task.	Ie, set to zero.
   1543  0917							;
   1544  0917		       98	   subVINIT   tya
   1545  0918		       48		      pha
   1546  0919
   1547  0919		       a9 00		      lda	#0
   1548  091b		       a0 00		      ldy	#0
   1549  091d		       91 41	   Vinit2     sta	(VARIABLES),y
   1550  091f		       c8		      iny
   1551  0920		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1552  0922		       90 f9		      bcc	Vinit2
   1553  0924
   1554  0924		       68		      pla
   1555  0925		       a8		      tay
   1556  0926		       60		      rts
   1557  0927
   1558  0927		       20 17 09    iVINIT     jsr	subVINIT
   1559  092a		       4c c2 02 	      jmp	NextIL
   1560  092d							;
   1561  092d							;=====================================================
   1562  092d							; Set the address of the error handler.  After any
   1563  092d							; error, set to the ILPC to the specified location.
   1564  092d							;
   1565  092d		       20 d2 18    iERRGOTO   jsr	getILWord
   1566  0930		       8e 1b 2c 	      stx	errGoto
   1567  0933		       8d 1c 2c 	      sta	errGoto+1
   1568  0936		       4c c2 02 	      jmp	NextIL
   1569  0939							;
   1570  0939							;=====================================================
   1571  0939							; TST is followed by an 8 bit signed offset, then a
   1572  0939							; null terminated string.  Compare the string against
   1573  0939							; the string starting at (CURPTR),CUROFF.  If the
   1574  0939							; strings match, continue executing the next IL
   1575  0939							; opcode.  Else, add the offset to ILPC.
   1576  0939							;
   1577  0939		       20 d6 18    iTST       jsr	getILByte	;Get the relative jump address
   1578  093c		       8d 2a 2c 	      sta	offset	;save it to use if test faile
   1579  093f		       20 b9 1a 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1580  0942
   1581  0942		       a4 51		      ldy	CUROFF
   1582  0944		       84 59		      sty	dpl	;save for later
   1583  0946							;
   1584  0946		       20 d6 18    iTSTloop   jsr	getILByte	;get next char
   1585  0949		       f0 11		      beq	iTSTm	;match!
   1586  094b		       a4 59		      ldy	dpl
   1587  094d		       d1 4f		      cmp	(CURPTR),y
   1588  094f		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1589  0951		       09 20		      ora	#$20	; lets allow lowercase as well
   1590  0953		       d1 4f		      cmp	(CURPTR),y
   1591  0955		       d0 23		      bne	iTSTfail	;mismatch
   1592  0957		       c8	   iTSTUpper  iny
   1593  0958		       84 59		      sty	dpl
   1594  095a		       d0 ea		      bne	iTSTloop
   1595  095c							;
   1596  095c							; It's a match!  Clean up a bit.
   1597  095c							;
   1598  095c		       a4 59	   iTSTm      ldy	dpl
   1599  095e		       84 51		      sty	CUROFF
   1600  0960		       4c c2 02 	      jmp	NextIL
   1601  0963
   1602  0963							; Test for a single quote string
   1603  0963		       20 d6 18    iTSTStr    jsr	getILByte
   1604  0966		       8d 2a 2c 	      sta	offset
   1605  0969		       20 b9 1a 	      jsr	saveIL
   1606  096c		       a4 51		      ldy	CUROFF
   1607  096e		       a9 22		      lda	#'"
   1608  0970		       d1 4f		      cmp	(CURPTR),y
   1609  0972		       d0 06		      bne	iTSTfail
   1610  0974		       c8		      iny
   1611  0975		       84 51		      sty	CUROFF
   1612  0977		       4c e0 02 	      jmp	NextILStr
   1613  097a							;
   1614  097a							; Not a match, reset ILPC and then move to the
   1615  097a							; offset.
   1616  097a							;
   1617  097a		       20 c4 1a    iTSTfail   jsr	restoreIL
   1618  097d		       4c 3a 0b 	      jmp	tstBranch
   1619  0980							;
   1620  0980							;=================================================JLIT=
   1621  0980							; Test if we have a let statement without the let keyword
   1622  0980		       20 d6 18    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1623  0983		       8d 2a 2c 	      sta	offset	; Save the jump offset for fails
   1624  0986		       20 b9 1a 	      jsr	saveIL	; save to restore when done if fail
   1625  0989
   1626  0989		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1627  098b		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1628  098d		       c9 01		      cmp	#kLet	; Is it a let keyword
   1629  098f		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1630  0991		       c9 80		      cmp	#tVa	; lets check for a variable
   1631  0993		       90 e5		      bcc	iTSTfail	; Less than variable range
   1632  0995		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1633  0997		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1634  0999		       b0 df		      bcs	iTSTfail	; return it failed
   1635  099b
   1636  099b				   iTSTLETGOOD
   1637  099b		       c8		      iny
   1638  099c		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1639  099e				   iTSTGOODVAR
   1640  099e		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1641  09a1
   1642  09a1							;=================================================JLIT=
   1643  09a1							; Test a byte at an indirect address
   1644  09a1							; fails if byte is not equal to the value at the address
   1645  09a1							; The tests an indirect byte and branches if true
   1646  09a1		       20 d6 18    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1647  09a4		       8d 2a 2c 	      sta	offset	; Save the jump offset for fails
   1648  09a7		       20 b9 1a 	      jsr	saveIL	; save to restore when done if fail
   1649  09aa		       20 d2 18 	      jsr	getILWord	; Get a word into RO
   1650  09ad		       86 52		      stx	R0
   1651  09af		       85 53		      sta	R0+1
   1652  09b1		       20 d6 18 	      jsr	getILByte	; Get byte into A
   1653  09b4		       a0 00		      ldy	#0
   1654  09b6		       d1 52		      cmp	(R0),y
   1655  09b8		       d0 03		      bne	iTSTByteNotEqual
   1656  09ba		       4c 7a 09 	      jmp	iTSTfail
   1657  09bd
   1658  09bd				   iTSTByteNotEqual
   1659  09bd		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1660  09c0
   1661  09c0							;=================================================JLIT=
   1662  09c0							; Test a byte	branch if it fails
   1663  09c0		       20 d6 18    iTSTB      jsr	getILByte	; Get the relative offset byte
   1664  09c3		       8d 2a 2c 	      sta	offset	; Save the jump offset for fails
   1665  09c6		       20 b9 1a 	      jsr	saveIL	; save to restore when done if fail
   1666  09c9		       20 d6 18 	      jsr	getILByte	; Get a word into RO
   1667  09cc		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1668  09ce		       d1 4f		      cmp	(CURPTR),y
   1669  09d0		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1670  09d2		       4c 7a 09 	      jmp	iTSTfail	; REcover and move on to next test
   1671  09d5
   1672  09d5				   iTSTBMatch
   1673  09d5		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1674  09d8
   1675  09d8							;=================================================JLIT=
   1676  09d8							; Test a byte	branch if it fails
   1677  09d8		       20 d6 18    iTSTW      jsr	getILByte	; Get the relative offset byte
   1678  09db		       8d 2a 2c 	      sta	offset	; Save the jump offset for fails
   1679  09de		       20 b9 1a 	      jsr	saveIL	; save to restore when done if fail
   1680  09e1		       20 d2 18 	      jsr	getILWord	; Get a word into RO
   1681  09e4		       86 52		      stx	R0
   1682  09e6		       85 53		      sta	R0+1
   1683  09e8		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1684  09ea		       8a		      txa
   1685  09eb		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1686  09ed		       f0 e6		      beq	iTSTBMatch	; Yes it matched move on
   1687  09ef		       4c 7a 09 	      jmp	iTSTfail	; REcover and move on to next test
   1688  09f2		       c8	   iTSTWM1    iny
   1689  09f3		       a5 53		      lda	R0+1
   1690  09f5		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1691  09f7		       f0 03		      beq	iTSTWMatch
   1692  09f9		       4c 7a 09 	      jmp	iTSTfail
   1693  09fc
   1694  09fc				   iTSTWMatch
   1695  09fc		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1696  09ff
   1697  09ff							;================================================jLIT=
   1698  09ff							;Test for end of line
   1699  09ff							;
   1700  09ff				   iTSTDONE
   1701  09ff		       20 d6 18 	      jsr	getILByte
   1702  0a02		       8d 2a 2c 	      sta	offset
   1703  0a05		       20 b9 1a 	      jsr	saveIL
   1704  0a08		       a4 51		      ldy	CUROFF
   1705  0a0a		       84 59		      sty	dpl
   1706  0a0c		       b1 4f		      lda	(CURPTR),y
   1707  0a0e		       f0 0b		      beq	iTSTDONEtrue
   1708  0a10		       c9 e6		      cmp	#oColon
   1709  0a12		       f0 07		      beq	iTSTDONEtrue
   1710  0a14		       a4 59		      ldy	dpl
   1711  0a16		       84 51		      sty	CUROFF
   1712  0a18		       4c 7a 09 	      jmp	iTSTfail
   1713  0a1b							;
   1714  0a1b							; Advance to the next line
   1715  0a1b							;
   1716  0a1b				   iTSTDONEtrue
   1717  0a1b		       4c c2 02 	      jmp	NextIL
   1718  0a1e
   1719  0a1e		       4c 3a 0b    tstBranchLink jmp	tstBranch
   1720  0a21							;
   1721  0a21							;=====================================================
   1722  0a21							; Inc and dec a variable , faster than a = a + 1
   1723  0a21				   iINCVAR
   1724  0a21		       20 53 1b 	      jsr	popR0
   1725  0a24		       a0 00		      ldy	#0
   1726  0a26		       18		      clc
   1727  0a27		       a9 01		      lda	#1
   1728  0a29		       71 52		      adc	(R0),y
   1729  0a2b		       91 52		      sta	(R0),y
   1730  0a2d		       90 07		      bcc	iINCDONE
   1731  0a2f		       c8		      iny
   1732  0a30		       a9 00		      lda	#0
   1733  0a32		       71 52		      adc	(R0),y
   1734  0a34		       91 52		      sta	(R0),y
   1735  0a36				   iINCDONE
   1736  0a36		       4c c2 02 	      jmp	NextIL
   1737  0a39				   iDECVAR
   1738  0a39		       20 53 1b 	      jsr	popR0
   1739  0a3c		       a0 00		      ldy	#0
   1740  0a3e		       38		      sec
   1741  0a3f		       b1 52		      lda	(R0),y
   1742  0a41		       e9 01		      sbc	#1
   1743  0a43		       91 52		      sta	(R0),y
   1744  0a45		       c8		      iny
   1745  0a46		       b1 52		      lda	(R0),y
   1746  0a48		       69 00		      adc	#0
   1747  0a4a		       91 52		      sta	(R0),y
   1748  0a4c		       4c c2 02 	      jmp	NextIL
   1749  0a4f
   1750  0a4f
   1751  0a4f							;
   1752  0a4f							;=====================================================
   1753  0a4f							; TSTV is followed by an 8 bit signed offset.	If the
   1754  0a4f							; value at (CURPTR),CUROFF appears to be a variable
   1755  0a4f							; name, move to the next IL statement.  Else, add the
   1756  0a4f							; offset to ILPC. Converted to use actual absolute memory addresses
   1757  0a4f							; TSTVT Looks for the task context
   1758  0a4f							;
   1759  0a4f		       20 6b 1b    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1760  0a52		       a9 00		      lda	#0
   1761  0a54		       85 58		      sta	R2
   1762  0a56		       f0 04		      beq	iTSTVV
   1763  0a58
   1764  0a58		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1765  0a5a		       85 58		      sta	R2
   1766  0a5c
   1767  0a5c		       20 d6 18    iTSTVV     jsr	getILByte	;offset
   1768  0a5f		       8d 2a 2c 	      sta	offset
   1769  0a62							;
   1770  0a62		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1771  0a64		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1772  0a66		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1773  0a68		       4c 1e 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1774  0a6b							;
   1775  0a6b				   iTSTVnext
   1776  0a6b		       c9 9d		      cmp	#tVat	;allow access to all unused memory as an array or integers
   1777  0a6d		       f0 42		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1778  0a6f
   1779  0a6f		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1780  0a71		       f0 4e		      beq	iTSTVParm
   1781  0a73
   1782  0a73		       c9 9b		      cmp	#tVhat	; task exit code
   1783  0a75		       d0 04		      bne	iTSTV_A2Z
   1784  0a77		       a9 19		      lda	#TASKEXITCODE
   1785  0a79		       d0 0b		      bne	iTSTVContinue
   1786  0a7b
   1787  0a7b				   iTSTV_A2Z
   1788  0a7b
   1789  0a7b		       c9 80		      cmp	#tVa
   1790  0a7d		       90 9f		      bcc	tstBranchLink
   1791  0a7f		       c9 9a		      cmp	#tVz+1
   1792  0a81		       b0 9b		      bcs	tstBranchLink
   1793  0a83
   1794  0a83
   1795  0a83							;
   1796  0a83							; The condition is true, so convert to an index, push
   1797  0a83							; it onto the stack and continue running.
   1798  0a83							;
   1799  0a83		       29 7f		      and	#%01111111	;Mask off the high bit
   1800  0a85		       0a		      asl		;multiply by two
   1801  0a86
   1802  0a86				   iTSTVContinue
   1803  0a86		       c8		      iny
   1804  0a87		       84 51		      sty	CUROFF	;it is a valid variable
   1805  0a89		       48		      pha
   1806  0a8a		       a5 58		      lda	R2
   1807  0a8c		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1808  0a8e
   1809  0a8e		       20 b9 18 	      jsr	ipc_getcontext	; Get the other tasks variables
   1810  0a91		       a0 01		      ldy	#VARIABLEPOS
   1811  0a93		       b1 56		      lda	(MQ),y
   1812  0a95		       85 52		      sta	R0
   1813  0a97		       c8		      iny
   1814  0a98		       b1 56		      lda	(MQ),y
   1815  0a9a		       85 53		      sta	R0+1
   1816  0a9c		       4c a7 0a 	      jmp	iTSTVAddOffset
   1817  0a9f
   1818  0a9f				   iTSTVLocalValue
   1819  0a9f		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1820  0aa1		       85 52		      sta	R0
   1821  0aa3		       a5 42		      lda	VARIABLES+1
   1822  0aa5		       85 53		      sta	R0+1
   1823  0aa7
   1824  0aa7				   iTSTVAddOffset
   1825  0aa7		       68		      pla
   1826  0aa8		       85 54		      sta	R1
   1827  0aaa		       a9 00		      lda	#0
   1828  0aac		       85 55		      sta	R1+1
   1829  0aae
   1830  0aae				   iTSTVcontinue
   1831  0aae
   1832  0aae		       4c 86 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1833  0ab1
   1834  0ab1							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1835  0ab1							; an array of integer values
   1836  0ab1				   iTSTVat
   1837  0ab1		       c8		      iny
   1838  0ab2		       84 51		      sty	CUROFF	;it is a valid variable
   1839  0ab4		       ad 30 2c 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1840  0ab7		       85 52		      sta	R0
   1841  0ab9		       ad 31 2c 	      lda	ProgramEnd+1
   1842  0abc		       85 53		      sta	R0+1
   1843  0abe		       4c fe 06 	      jmp	pushR0nextIl	;place this onto the stack
   1844  0ac1
   1845  0ac1							; When we get parameters passed we can access them using the # variable with[]
   1846  0ac1							; example #[0] #[1] etc, we dont check yet if there is too many
   1847  0ac1				   iTSTVParm
   1848  0ac1		       c8		      iny
   1849  0ac2		       84 51		      sty	CUROFF	;it is a valid variable
   1850  0ac4		       a5 48		      lda	MATHSTACK
   1851  0ac6		       85 52		      sta	R0
   1852  0ac8		       a5 49		      lda	MATHSTACK+1
   1853  0aca		       85 53		      sta	R0+1
   1854  0acc		       4c fe 06 	      jmp	pushR0nextIl
   1855  0acf
   1856  0acf							;
   1857  0acf							;=====================================================
   1858  0acf							; TSTL seems basically the same as TSTN, but leave the
   1859  0acf							; value in R0 instead of pushing onto stack.
   1860  0acf							; This tests for a valid line number
   1861  0acf							;
   1862  0acf		       20 d6 18    iTSTL      jsr	getILByte
   1863  0ad2		       8d 2a 2c 	      sta	offset
   1864  0ad5							;
   1865  0ad5		       a4 51		      ldy	CUROFF
   1866  0ad7		       b1 4f		      lda	(CURPTR),y
   1867  0ad9							;
   1868  0ad9		       c8		      iny
   1869  0ada		       11 4f		      ora	(CURPTR),y
   1870  0adc		       f0 5c		      beq	tstBranch
   1871  0ade
   1872  0ade		       c8		      iny
   1873  0adf							; It's a digit, so convert to a number.
   1874  0adf							;
   1875  0adf		       4c c2 02 	      jmp	NextIL
   1876  0ae2							;
   1877  0ae2							;=====================================================
   1878  0ae2							; TSTN checks for a number.  This is very simplistic;
   1879  0ae2							; if the character is a digit, assume it's a number.
   1880  0ae2							; Convert to a number and push it onto the stack.
   1881  0ae2							;
   1882  0ae2		       20 d6 18    iTSTN      jsr	getILByte
   1883  0ae5		       8d 2a 2c 	      sta	offset
   1884  0ae8							;
   1885  0ae8		       a4 51		      ldy	CUROFF
   1886  0aea		       a9 00		      lda	#0
   1887  0aec		       85 59		      sta	dpl
   1888  0aee		       b1 4f		      lda	(CURPTR),y
   1889  0af0		       c9 f7		      cmp	#oMinus
   1890  0af2		       d0 02		      bne	chkByte
   1891  0af4		       e6 59		      inc	dpl
   1892  0af6
   1893  0af6				   chkByte
   1894  0af6		       c5 a2		      cmp	tByte
   1895  0af8		       d0 0d		      bne	chkInteger
   1896  0afa		       a9 00		      lda	#0
   1897  0afc		       85 53		      sta	R0+1
   1898  0afe		       c8		      iny
   1899  0aff		       b1 4f		      lda	(CURPTR),y
   1900  0b01		       85 52		      sta	R0
   1901  0b03		       c8		      iny
   1902  0b04		       4c 16 0b 	      jmp	iTSTN_1
   1903  0b07
   1904  0b07				   chkInteger
   1905  0b07		       c5 a1		      cmp	tInteger
   1906  0b09		       d0 2f		      bne	tstBranch
   1907  0b0b		       c8		      iny
   1908  0b0c		       b1 4f		      lda	(CURPTR),y
   1909  0b0e		       85 52		      sta	R0
   1910  0b10		       c8		      iny
   1911  0b11		       b1 4f		      lda	(CURPTR),y
   1912  0b13		       85 53		      sta	R0+1
   1913  0b15		       c8		      iny
   1914  0b16							;
   1915  0b16							; Check if it is negative and make it so
   1916  0b16							;
   1917  0b16				   iTSTN_1
   1918  0b16		       84 51		      sty	CUROFF
   1919  0b18
   1920  0b18		       a5 59		      lda	dpl
   1921  0b1a		       f0 18		      beq	iTSTN_2	;positive
   1922  0b1c							;
   1923  0b1c		       a5 52		      lda	R0
   1924  0b1e		       05 53		      ora	R0+1
   1925  0b20		       f0 12		      beq	iTSTN_2	;zero
   1926  0b22
   1927  0b22							; Invert all the bits, then add one.
   1928  0b22							;
   1929  0b22		       a5 52		      lda	R0
   1930  0b24		       49 ff		      eor	#$ff
   1931  0b26		       85 52		      sta	R0
   1932  0b28		       a5 53		      lda	R0+1
   1933  0b2a		       49 ff		      eor	#$ff
   1934  0b2c		       85 53		      sta	R0+1
   1935  0b2e							;
   1936  0b2e		       e6 52		      inc	R0
   1937  0b30		       d0 02		      bne	iTSTN_2
   1938  0b32		       e6 53		      inc	R0+1
   1939  0b34				   iTSTN_2
   1940  0b34		       20 cf 1a 	      jsr	pushR0	;save onto stack
   1941  0b37		       4c c2 02 	      jmp	NextIL
   1942  0b3a							;
   1943  0b3a							; Common jump point for all TSTx instructions that
   1944  0b3a							; fail to meet the requirements.  This takes the
   1945  0b3a							; offset and adds/subtracts to/from ILPC.
   1946  0b3a							;
   1947  0b3a		       ad 2a 2c    tstBranch  lda	offset	;get signed offset
   1948  0b3d		       10 0e		      bpl	tstPositive
   1949  0b3f							;
   1950  0b3f							; Do negative branch.	Do sign extension.
   1951  0b3f							;
   1952  0b3f		       18	   tstNegative clc
   1953  0b40		       65 43		      adc	ILPC
   1954  0b42		       85 43		      sta	ILPC
   1955  0b44							;		  bcc	  tstBothDone
   1956  0b44							;		  dec	  ILPC+1
   1957  0b44							;		  jmp	  NextIL
   1958  0b44
   1959  0b44		       a5 44		      lda	ILPC+1
   1960  0b46		       69 ff		      adc	#$ff
   1961  0b48		       85 44		      sta	ILPC+1
   1962  0b4a		       4c c2 02 	      jmp	NextIL	;keep going
   1963  0b4d							;
   1964  0b4d		       18	   tstPositive clc
   1965  0b4e		       65 43		      adc	ILPC
   1966  0b50		       85 43		      sta	ILPC
   1967  0b52		       90 02		      bcc	tstBothDone
   1968  0b54		       e6 44		      inc	ILPC+1
   1969  0b56				   tstBothDone
   1970  0b56		       4c c2 02 	      jmp	NextIL
   1971  0b59
   1972  0b59							;
   1973  0b59							;====================================================
   1974  0b59							; Test for IRQ pending, and test if a break key pressed
   1975  0b59							; Yes I know but this handles all sorts of irq/break issues
   1976  0b59							;
   1977  0b59		       20 d6 18    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1978  0b5c		       8d 2a 2c 	      sta	offset	; Store the not true jump address offset
   1979  0b5f		       20 3c 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1980  0b62		       d0 03		      bne	irqNo	; z not set of no break found
   1981  0b64		       4c fc 05 	      jmp	iFIN	; Exit out of run mode
   1982  0b67		       ad d2 22    irqNo      lda	IRQPending
   1983  0b6a		       f0 ce		      beq	tstBranch
   1984  0b6c		       c9 01		      cmp	#1	; only do this if set to first time
   1985  0b6e		       d0 ca		      bne	tstBranch
   1986  0b70		       78		      sei		; disable the interupt until ireturn resets it
   1987  0b71		       ee d2 22    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1988  0b74		       20 e9 1a 	      jsr	pushLN	; Push the next line to be executed
   1989  0b77		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1990  0b79		       ad d3 22 	      lda	IRQEntry	; Get the line number to branch to
   1991  0b7c		       85 4f		      sta	CURPTR	; put line number into r0
   1992  0b7e		       ad d4 22 	      lda	IRQEntry+1
   1993  0b81		       85 50		      sta	CURPTR+1
   1994  0b83		       a9 03		      lda	#3	; Point to first byte of program text
   1995  0b85		       85 51		      sta	CUROFF
   1996  0b87		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1997  0b8a
   1998  0b8a		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1999  0b8c		       a9 00		      lda	#0	; stop the execution
   2000  0b8e		       4c 13 06 	      jmp	iErr2
   2001  0b91							;
   2002  0b91
   2003  0b91							;=====================================================
   2004  0b91							; This places the number of free bytes on top of the
   2005  0b91							; stack.
   2006  0b91							;
   2007  0b91		       20 3c 14    iFREE      jsr	MemFree
   2008  0b94		       20 cf 1a 	      jsr	pushR0
   2009  0b97		       4c c2 02 	      jmp	NextIL
   2010  0b9a							;
   2011  0b9a							;=====================================================
   2012  0b9a							; Generate a random number from 0-FFFF and then MOD
   2013  0b9a							; it with the value on top of stack.  Leaves number on
   2014  0b9a							; stack
   2015  0b9a							;
   2016  0b9a		       20 6b 1b    iRANDOM    jsr	popR1	;mod value
   2017  0b9d							;
   2018  0b9d							; If the value is zero, just return a one.
   2019  0b9d							;
   2020  0b9d		       a5 54		      lda	R1
   2021  0b9f		       05 55		      ora	R1+1
   2022  0ba1		       f0 4a		      beq	irandom1
   2023  0ba3							;
   2024  0ba3		       ad 21 2c 	      lda	random+1
   2025  0ba6		       8d 1e 2c 	      sta	rtemp1
   2026  0ba9		       ad 20 2c 	      lda	random
   2027  0bac		       0a		      asl
   2028  0bad		       2e 1e 2c 	      rol	rtemp1
   2029  0bb0		       0a		      asl
   2030  0bb1		       2e 1e 2c 	      rol	rtemp1
   2031  0bb4		       18		      clc
   2032  0bb5		       6d 20 2c 	      adc	random
   2033  0bb8
   2034  0bb8		       48		      pha
   2035  0bb9
   2036  0bb9		       ad 1e 2c 	      lda	rtemp1
   2037  0bbc		       6d 21 2c 	      adc	random+1
   2038  0bbf		       8d 21 2c 	      sta	random+1
   2039  0bc2
   2040  0bc2		       68		      pla
   2041  0bc3
   2042  0bc3		       69 11		      adc	#$11
   2043  0bc5		       8d 20 2c 	      sta	random
   2044  0bc8		       ad 21 2c 	      lda	random+1
   2045  0bcb		       69 36		      adc	#$36
   2046  0bcd		       8d 21 2c 	      sta	random+1
   2047  0bd0
   2048  0bd0		       ad 20 2c 	      lda	random
   2049  0bd3		       85 52		      sta	R0
   2050  0bd5		       ad 21 2c 	      lda	random+1
   2051  0bd8		       29 7f		      and	#$7f	;make positive
   2052  0bda		       85 53		      sta	R0+1
   2053  0bdc							;
   2054  0bdc							; R0 contains the number and R1 contains the max value.
   2055  0bdc							;
   2056  0bdc		       20 24 07 	      jsr	iDivNoPop
   2057  0bdf		       20 d4 1b 	      jsr	RestoreSigns
   2058  0be2		       a5 56		      lda	MQ
   2059  0be4		       85 52		      sta	R0
   2060  0be6		       a5 57		      lda	MQ+1
   2061  0be8		       85 53		      sta	R0+1
   2062  0bea		       4c fe 06 	      jmp	pushR0nextIl
   2063  0bed				   irandom1
   2064  0bed		       a9 00		      lda	#0
   2065  0bef		       85 53		      sta	R0+1
   2066  0bf1		       a9 01		      lda	#1
   2067  0bf3		       85 52		      sta	R0
   2068  0bf5		       4c fe 06 	      jmp	pushR0nextIl
   2069  0bf8
   2070  0bf8							; The following replaced by call to division/modulo
   2071  0bf8							;iRANDOM_2	lda	R0
   2072  0bf8							;		cmp	R1
   2073  0bf8							;		bne	iRANDOM_1
   2074  0bf8							;		lda	R0+1
   2075  0bf8							;		cmp	R1+1
   2076  0bf8							;		bne	iRANDOM_1	;need to subtract
   2077  0bf8							;
   2078  0bf8							; Subtract R1 from R0
   2079  0bf8							;
   2080  0bf8							;iRANDOM_sub	sec
   2081  0bf8							;		lda	R0
   2082  0bf8							;		sbc	R1
   2083  0bf8							;		sta	R0
   2084  0bf8							;		lda	R0+1
   2085  0bf8							;		sbc	R1+1
   2086  0bf8							;		sta	R0+1
   2087  0bf8							;		jmp	iRANDOM_2
   2088  0bf8							;
   2089  0bf8							; See if R1 > R0.  If so, branch to subtract.
   2090  0bf8							;
   2091  0bf8							;iRANDOM_1	lda	R0
   2092  0bf8							;		cmp	R1
   2093  0bf8							;		lda	R0+1
   2094  0bf8							;		sbc	R1+1
   2095  0bf8							;		bvc	iRANDOM_4
   2096  0bf8							;		eor	#$80
   2097  0bf8							;iRANDOM_4	bpl	iRANDOM_sub
   2098  0bf8							;
   2099  0bf8							; All done.  Almost.  Add one, then push the result.
   2100  0bf8							;
   2101  0bf8							;irandom1	inc	R0
   2102  0bf8							;		bne	iRANDOM_3
   2103  0bf8							;		inc	R0+1
   2104  0bf8							;iRANDOM_3
   2105  0bf8							;		  jsr	pushR0	;return value
   2106  0bf8							;		jmp	NextIL
   2107  0bf8							;
   2108  0bf8							; Poke a value into a memory location
   2109  0bf8		       8c 26 2c    iPOKEMEMORY sty	tempy
   2110  0bfb		       20 53 1b 	      jsr	popR0
   2111  0bfe		       20 6b 1b 	      jsr	popR1
   2112  0c01		       a0 00		      ldy	#0
   2113  0c03		       a5 52		      lda	R0
   2114  0c05		       91 54		      sta	(R1),y
   2115  0c07		       ac 26 2c 	      ldy	tempy
   2116  0c0a		       4c c2 02 	      jmp	NextIL
   2117  0c0d							;
   2118  0c0d							; Get a value from a memory location
   2119  0c0d							;
   2120  0c0d		       8c 26 2c    iPEEKMEMORY sty	tempy
   2121  0c10		       20 53 1b 	      jsr	popR0
   2122  0c13		       a0 00		      ldy	#0
   2123  0c15		       b1 52		      lda	(R0),y
   2124  0c17		       ac 26 2c 	      ldy	tempy
   2125  0c1a		       85 52		      sta	R0
   2126  0c1c		       a9 00		      lda	#0
   2127  0c1e		       85 53		      sta	R0+1
   2128  0c20		       4c fe 06 	      jmp	pushR0nextIl
   2129  0c23							;
   2130  0c23							; Call to address return what ever is in a to the stack
   2131  0c23							; func2 will load a value into a before the call
   2132  0c23		       20 6b 1b    iCallFunc  jsr	popR1
   2133  0c26		       a5 54		      lda	R1
   2134  0c28		       20 34 0c 	      jsr	iCallRtn
   2135  0c2b		       85 52		      sta	R0
   2136  0c2d		       a9 00		      lda	#0
   2137  0c2f		       85 53		      sta	R0+1
   2138  0c31		       20 fe 06 	      jsr	pushR0nextIl
   2139  0c34				   iCallRtn
   2140  0c34		       20 53 1b 	      jsr	popR0
   2141  0c37		       6c 52 00 	      jmp	(R0)
   2142  0c3a
   2143  0c3a
   2144  0c3a							;===========================================jlit======
   2145  0c3a							;Get a character from the terminal convert to value
   2146  0c3a							;leave the number on top of the stack
   2147  0c3a							;
   2148  0c3a				   iGETCHAR
   2149  0c3a		       20 58 1d 	      jsr	VGETCH
   2150  0c3d					      if	CTMON65
   2151  0c3d		       48		      pha
   2152  0c3e		       20 55 1d 	      jsr	VOUTCH	;echo echo echo
   2153  0c41		       68		      pla
   2154  0c42					      endif
   2155  0c42		       85 52		      sta	R0
   2156  0c44		       a9 00		      lda	#0
   2157  0c46		       85 53		      sta	R0+1
   2158  0c48		       20 cf 1a 	      jsr	pushR0
   2159  0c4b							;
   2160  0c4b		       4c c2 02 	      jmp	NextIL
   2161  0c4e							;===========================================jusilostintim======
   2162  0c4e							;Put a character to the terminal convert to
   2163  0c4e							;
   2164  0c4e		       20 53 1b    iPUTCHAR   jsr	popR0
   2165  0c51		       a5 52		      lda	R0
   2166  0c53		       20 55 1d 	      jsr	VOUTCH
   2167  0c56		       4c c2 02 	      jmp	NextIL
   2168  0c59							;=====================================================
   2169  0c59							; Put the number on the stack out as hex, suppress leading 0
   2170  0c59				   iHexOut
   2171  0c59		       20 53 1b 	      jsr	popR0
   2172  0c5c		       a5 53		      lda	R0+1
   2173  0c5e		       f0 03		      beq	iHexSecondByte
   2174  0c60		       20 65 13 	      jsr	OUTHEX
   2175  0c63				   iHexSecondByte
   2176  0c63		       a5 52		      lda	R0
   2177  0c65		       20 65 13 	      jsr	OUTHEX
   2178  0c68		       4c c2 02 	      jmp	NextIL
   2179  0c6b							;
   2180  0c6b							;=====================================================
   2181  0c6b							; Replace TOS with its absolute value.
   2182  0c6b							;
   2183  0c6b		       20 53 1b    iABS       jsr	popR0
   2184  0c6e		       a5 53		      lda	R0+1
   2185  0c70		       10 10		      bpl	iABS_1	;already positive
   2186  0c72		       49 ff		      eor	#$ff
   2187  0c74		       85 53		      sta	R0+1
   2188  0c76		       a5 52		      lda	R0
   2189  0c78		       49 ff		      eor	#$ff
   2190  0c7a		       85 52		      sta	R0
   2191  0c7c		       e6 52		      inc	R0
   2192  0c7e		       d0 02		      bne	iABS_1
   2193  0c80		       e6 53		      inc	R0+1
   2194  0c82		       4c fe 06    iABS_1     jmp	pushR0nextIl
   2195  0c85
   2196  0c85							;
   2197  0c85							;================================================================
   2198  0c85							; The set of logical operators
   2199  0c85				   iLogAnd
   2200  0c85		       20 53 1b 	      jsr	popR0
   2201  0c88		       20 6b 1b 	      jsr	popR1
   2202  0c8b		       a5 52		      lda	R0
   2203  0c8d		       25 54		      and	R1
   2204  0c8f		       85 52		      sta	R0
   2205  0c91		       a5 53		      lda	R0+1
   2206  0c93		       25 55		      and	R1+1
   2207  0c95		       85 53		      sta	R0+1
   2208  0c97		       4c fe 06 	      jmp	pushR0nextIl
   2209  0c9a				   iLogOr
   2210  0c9a		       20 53 1b 	      jsr	popR0
   2211  0c9d		       20 6b 1b 	      jsr	popR1
   2212  0ca0		       a5 52		      lda	R0
   2213  0ca2		       05 54		      ora	R1
   2214  0ca4		       85 52		      sta	R0
   2215  0ca6		       a5 53		      lda	R0+1
   2216  0ca8		       05 55		      ora	R1+1
   2217  0caa		       85 53		      sta	R0+1
   2218  0cac		       4c fe 06 	      jmp	pushR0nextIl
   2219  0caf				   iLogXor
   2220  0caf		       20 53 1b 	      jsr	popR0
   2221  0cb2		       20 6b 1b 	      jsr	popR1
   2222  0cb5		       a5 52		      lda	R0
   2223  0cb7		       45 54		      eor	R1
   2224  0cb9		       85 52		      sta	R0
   2225  0cbb		       a5 53		      lda	R0+1
   2226  0cbd		       45 55		      eor	R1+1
   2227  0cbf		       85 53		      sta	R0+1
   2228  0cc1		       4c fe 06 	      jmp	pushR0nextIl
   2229  0cc4				   iLogNot
   2230  0cc4		       20 53 1b 	      jsr	popR0
   2231  0cc7		       a5 52		      lda	R0
   2232  0cc9		       49 ff		      eor	#$FF
   2233  0ccb		       85 52		      sta	R0
   2234  0ccd		       a5 53		      lda	R0+1
   2235  0ccf		       49 ff		      eor	#$FF
   2236  0cd1		       85 53		      sta	R0+1
   2237  0cd3		       4c fe 06 	      jmp	pushR0nextIl
   2238  0cd6
   2239  0cd6				   iTruth
   2240  0cd6		       a9 ff		      lda	#$FF
   2241  0cd8		       85 52		      sta	R0
   2242  0cda		       85 53		      sta	R0+1
   2243  0cdc		       4c fe 06 	      jmp	pushR0nextIl
   2244  0cdf				   iFalse
   2245  0cdf		       a9 00		      lda	#$00
   2246  0ce1		       85 52		      sta	R0
   2247  0ce3		       85 53		      sta	R0+1
   2248  0ce5		       4c fe 06 	      jmp	pushR0nextIl
   2249  0ce8
   2250  0ce8							;================================================================
   2251  0ce8							;Set the IRQ service rtn line number
   2252  0ce8							;
   2253  0ce8		       78	   iSetIrq    sei		; disable the interupts
   2254  0ce9		       a9 00		      lda	#0	; Zero the Status flag
   2255  0ceb		       8d d1 22 	      sta	IRQStatus
   2256  0cee		       20 53 1b 	      jsr	popR0	; get the line number
   2257  0cf1		       a5 52		      lda	R0
   2258  0cf3		       05 53		      ora	R0+1
   2259  0cf5		       f0 20		      beq	iSetExt	; if it is zero disable all
   2260  0cf7		       20 e9 1a 	      jsr	pushLN	; Save the current line pointer
   2261  0cfa		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2262  0cfc		       4c 8a 0b 	      jmp	ErrStkOver	; Check if there was an error
   2263  0cff				   iSetIrqOk
   2264  0cff		       20 1b 19 	      jsr	findLine	; Find the IRQ func Line Pointer
   2265  0d02		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2266  0d04		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2267  0d06		       8d d4 22 	      sta	IRQEntry+1
   2268  0d09		       a5 4f		      lda	CURPTR
   2269  0d0b		       8d d3 22 	      sta	IRQEntry
   2270  0d0e		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2271  0d10		       8d d1 22 	      sta	IRQStatus
   2272  0d13		       20 0e 1b 	      jsr	popLN	; Restore the old line number
   2273  0d16		       58		      cli		; Enable the interupts
   2274  0d17		       4c c2 02    iSetExt    jmp	NextIL
   2275  0d1a
   2276  0d1a		       20 0e 1b    iSetIrqErr jsr	popLN
   2277  0d1d		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2278  0d1f		       a9 00		      lda	#0
   2279  0d21		       4c 13 06 	      jmp	iErr2
   2280  0d24							;
   2281  0d24		       20 53 1b    iTRACEPROG jsr	popR0
   2282  0d27		       a5 52		      lda	R0
   2283  0d29		       85 40		      sta	ILTrace
   2284  0d2b		       4c c2 02 	      jmp	NextIL
   2285  0d2e
   2286  0d2e							;=====================================================
   2287  0d2e							; Define start of non page zero data
   2288 U2c38 ????				      seg.u	TBData
   2289 U22c0					      org	PROGEND
   2290 U22c0							;=================================================================
   2291 U22c0							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U22c0					      include	"tokenizer.asm"
      1  0d2e					      seg	Code
      2  0d2e		       ff ff ff ff DEBUGPARSER equ	TRUE	; Print debugging information
      3  0d2e
      4  0d2e							; Define the types of tokens found, and identifiers
      5  0d2e		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0d2e		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0d2e		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0d2e		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0d2e
     10  0d2e		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0d2e		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0d2e		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0d2e
     14  0d2e
     15  0d2e		       00 a0	   tString    equ	$A0	; String all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0d2e		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0d2e		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0d2e		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0d2e							; Arrays of string are arrays of pointers 2 bytes
     20  0d2e		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0d2e		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0d2e
     23  0d2e		       3c 3e 3c 3d*Operators  BYTE.b	"<>","<=",">=",'+,0,'<,0,'=,0,">",0,"-",0,"/",0,"%",0,"*",0,"(",0,")",0,",",0,";",0,"[",0,"]",0,":",0,"$",0,"!",0
     24  0d2e		       00 28	   OperatorLen equ	*-Operators
     25  0d56
     26  0d56		       f5 f3 f6 f0*OperValues BYTE.b	$F5,$F3,$F6,$F0,$F1,$F2,$F4,$F7,$F8,$F9,$FA,$E0,$E1,$E2,$E3,$E4,$E5,$E6,$E7,$E8
     27  0d6a
     28  0d6a		       00 f5	   oNotEqual  equ	$F5
     29  0d6a		       00 f3	   oLessEqual equ	$F3
     30  0d6a		       00 f6	   oGreaterEqual equ	$F6
     31  0d6a		       00 f0	   oPlus      equ	$F0
     32  0d6a		       00 f1	   oLess      equ	$F1
     33  0d6a		       00 f2	   oEqual     equ	$F2
     34  0d6a		       00 f4	   oGreater   equ	$F4
     35  0d6a		       00 f7	   oMinus     equ	$F7
     36  0d6a		       00 f8	   oDivide    equ	$F8
     37  0d6a		       00 f9	   oModulo    equ	$F9
     38  0d6a		       00 f9	   oPercent   equ	oModulo
     39  0d6a		       00 fa	   oMultiply  equ	$FA
     40  0d6a		       00 e0	   oLeftBracket equ	$E0
     41  0d6a		       00 e1	   oRightBracket equ	$E1
     42  0d6a		       00 e2	   oComma     equ	$E2
     43  0d6a		       00 e3	   oSemiColon equ	$E3
     44  0d6a		       00 e4	   oLeftSQBracket equ	$E4
     45  0d6a		       00 e5	   oRightSQBracket equ	$E5
     46  0d6a		       00 e6	   oColon     equ	$E6
     47  0d6a		       00 e7	   oDollar    equ	$E7
     48  0d6a		       00 e8	   oBang      equ	$E8
     49  0d6a
     50  0d6a		       00 14	   OPCount    equ	* - OperValues
     51  0d6a
     52  0d6a		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     53  0d6a
     54  0d6a		       00 ff	   tError     equ	$FF	; Error should never happen
     55  0d6a							;
     56  0d6a							; Keyword table contains 49 keywords
     57  0d6a				   KeyWordTable
      0  0d6a					      db	"leT"	; 1, we only have 0 at end of program or line
      1  0d6a		       6c 65 54 	      .byte.b	"leT"
     59  0d6a		       00 01	   kLet       equ	1
      0  0d6d					      db	"inC"
      1  0d6d		       69 6e 43 	      .byte.b	"inC"
     61  0d6d		       00 02	   kInc       equ	2
      0  0d70					      db	"deC"
      1  0d70		       64 65 43 	      .byte.b	"deC"
     63  0d70		       00 03	   kDec       equ	3
      0  0d73					      db	"ireturN"
      1  0d73		       69 72 65 74*	      .byte.b	"ireturN"
     65  0d73		       00 04	   kIreturn   equ	4
      0  0d7a					      db	"iF"
      1  0d7a		       69 46		      .byte.b	"iF"
     67  0d7a		       00 05	   kIf	      equ	5
      0  0d7c					      db	"theN"
      1  0d7c		       74 68 65 4e	      .byte.b	"theN"
     69  0d7c		       00 06	   kThen      equ	6
      0  0d80					      db	"gotO"
      1  0d80		       67 6f 74 4f	      .byte.b	"gotO"
     71  0d80		       00 07	   kGoto      equ	7
      0  0d84					      db	"gosuB"
      1  0d84		       67 6f 73 75*	      .byte.b	"gosuB"
     73  0d84		       00 08	   kGosub     equ	8
      0  0d89					      db	"returN"
      1  0d89		       72 65 74 75*	      .byte.b	"returN"
     75  0d89		       00 09	   kReturn    equ	9
      0  0d8f					      db	"reM"
      1  0d8f		       72 65 4d 	      .byte.b	"reM"
     77  0d8f		       00 0a	   kRem       equ	10
      0  0d92					      db	"prinT"
      1  0d92		       70 72 69 6e*	      .byte.b	"prinT"
     79  0d92		       00 0b	   kPrint     equ	11	; should be entry for print
      0  0d97					      db	"taskE"
      1  0d97		       74 61 73 6b*	      .byte.b	"taskE"
     81  0d97		       00 0c	   kTaske     equ	12
      0  0d9c					      db	"taskN"
      1  0d9c		       74 61 73 6b*	      .byte.b	"taskN"
     83  0d9c		       00 0d	   kTaskn     equ	13
      0  0da1					      db	"taskW"
      1  0da1		       74 61 73 6b*	      .byte.b	"taskW"
     85  0da1		       00 0e	   kTaskw     equ	14
      0  0da6					      db	"pokE"
      1  0da6		       70 6f 6b 45	      .byte.b	"pokE"
     87  0da6		       00 0f	   kPoke      equ	15
      0  0daa					      db	"putcH"
      1  0daa		       70 75 74 63*	      .byte.b	"putcH"
     89  0daa		       00 10	   kPutch     equ	16
      0  0daf					      db	"clS"
      1  0daf		       63 6c 53 	      .byte.b	"clS"
     91  0daf		       00 11	   kCls       equ	17
      0  0db2					      db	"inpuT"
      1  0db2		       69 6e 70 75*	      .byte.b	"inpuT"
     93  0db2		       00 12	   kInput     equ	18
      0  0db7					      db	"enD"
      1  0db7		       65 6e 44 	      .byte.b	"enD"
     95  0db7		       00 13	   kEnd       equ	19
      0  0dba					      db	"irQ"
      1  0dba		       69 72 51 	      .byte.b	"irQ"
     97  0dba		       00 14	   kIrq       equ	20
      0  0dbd					      db	"kilL"
      1  0dbd		       6b 69 6c 4c	      .byte.b	"kilL"
     99  0dbd		       00 15	   kKill      equ	21
      0  0dc1					      db	"lisT"
      1  0dc1		       6c 69 73 54	      .byte.b	"lisT"
    101  0dc1		       00 16	   kList      equ	22
      0  0dc5					      db	"ruN"
      1  0dc5		       72 75 4e 	      .byte.b	"ruN"
    103  0dc5		       00 17	   kRun       equ	23
      0  0dc8					      db	"neW"
      1  0dc8		       6e 65 57 	      .byte.b	"neW"
    105  0dc8		       00 18	   kNew       equ	24
      0  0dcb					      db	"slicE"
      1  0dcb		       73 6c 69 63*	      .byte.b	"slicE"
    107  0dcb		       00 19	   kSlice     equ	25
      0  0dd0					      db	"tracE"
      1  0dd0		       74 72 61 63*	      .byte.b	"tracE"
    109  0dd0		       00 1a	   kTrace     equ	26
      0  0dd5					      db	"exiT"
      1  0dd5		       65 78 69 54	      .byte.b	"exiT"
    111  0dd5		       00 1b	   kExit      equ	27
      0  0dd9					      db	"savE"
      1  0dd9		       73 61 76 45	      .byte.b	"savE"
    113  0dd9		       00 1c	   kSave      equ	28
      0  0ddd					      db	"loaD"
      1  0ddd		       6c 6f 61 44	      .byte.b	"loaD"
    115  0ddd		       00 1d	   kLoad      equ	29
      0  0de1					      db	"erasE"
      1  0de1		       65 72 61 73*	      .byte.b	"erasE"
    117  0de1		       00 1e	   kErase     equ	30
      0  0de6					      db	"noT"
      1  0de6		       6e 6f 54 	      .byte.b	"noT"
    119  0de6		       00 1f	   kNot       equ	31
      0  0de9					      db	"oR"
      1  0de9		       6f 52		      .byte.b	"oR"
    121  0de9		       00 20	   kOr	      equ	32
      0  0deb					      db	"xoR"
      1  0deb		       78 6f 52 	      .byte.b	"xoR"
    123  0deb		       00 21	   kXor       equ	33
      0  0dee					      db	"anD"
      1  0dee		       61 6e 44 	      .byte.b	"anD"
    125  0dee		       00 22	   kAnd       equ	34
      0  0df1					      db	"truE"
      1  0df1		       74 72 75 45	      .byte.b	"truE"
    127  0df1		       00 23	   kTrue      equ	35
      0  0df5					      db	"falsE"
      1  0df5		       66 61 6c 73*	      .byte.b	"falsE"
    129  0df5		       00 24	   kFalse     equ	36
      0  0dfa					      db	"diR"
      1  0dfa		       64 69 52 	      .byte.b	"diR"
    131  0dfa		       00 25	   kDir       equ	37
    132  0dfd							;functions returning values
      0  0dfd					      db	"freE"
      1  0dfd		       66 72 65 45	      .byte.b	"freE"
    134  0dfd		       00 26	   kFree      equ	38
      0  0e01					      db	"getcH"
      1  0e01		       67 65 74 63*	      .byte.b	"getcH"
    136  0e01		       00 27	   kGetch     equ	39
      0  0e06					      db	"peeK"
      1  0e06		       70 65 65 4b	      .byte.b	"peeK"
    138  0e06		       00 28	   kPeek      equ	40
      0  0e0a					      db	"tasK"
      1  0e0a		       74 61 73 4b	      .byte.b	"tasK"
    140  0e0a		       00 29	   kTask      equ	41
      0  0e0e					      db	"ipcc"
      1  0e0e		       69 70 63 63	      .byte.b	"ipcc"
    142  0e0e		       00 2a	   kIpcc      equ	42
      0  0e12					      db	"ipcS"
      1  0e12		       69 70 63 53	      .byte.b	"ipcS"
    144  0e12		       00 2b	   kIpcs      equ	43
      0  0e16					      db	"ipcR"
      1  0e16		       69 70 63 52	      .byte.b	"ipcR"
    146  0e16		       00 2c	   kIpcr      equ	44
      0  0e1a					      db	"rnD"
      1  0e1a		       72 6e 44 	      .byte.b	"rnD"
    148  0e1a		       00 2d	   kRnd       equ	45
      0  0e1d					      db	"staT"
      1  0e1d		       73 74 61 54	      .byte.b	"staT"
    150  0e1d		       00 2e	   kStat      equ	46
      0  0e21					      db	"abS"
      1  0e21		       61 62 53 	      .byte.b	"abS"
    152  0e21		       00 2f	   kAbs       equ	47
      0  0e24					      db	"calL"
      1  0e24		       63 61 6c 4c	      .byte.b	"calL"
    154  0e24		       00 30	   kCall      equ	48
      0  0e28					      db	"gofN"
      1  0e28		       67 6f 66 4e	      .byte.b	"gofN"
    156  0e28		       00 31	   kGofn      equ	49
      0  0e2c					      db	"ireT"
      1  0e2c		       69 72 65 54	      .byte.b	"ireT"
    158  0e2c		       00 32	   kIret      equ	50
      0  0e30					      db	"piD"
      1  0e30		       70 69 44 	      .byte.b	"piD"
    160  0e30		       00 33	   kPid       equ	51
      0  0e33					      db	0,0
      1  0e33		       00 00		      .byte.b	0,0
    162  0e33		       0e 35	   KeyWordTableEnd equ	*
    163  0e33		       00 cb	   KeyWordTableLength equ	* - KeyWordTable
    164  0e35		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    165  0f35		       00 00 00    printStorage ds	3
    166  0f38							;==================================================================================================================
    167  0f38							; Read accross the inputline and output to TOKENBUFFER
    168  0f38							; Format   byte      Description
    169  0f38							;	     0	      length of line 1-255
    170  0f38							;	    0-1       Line Number
    171  0f38							;	    Tokens and litteral values encoded into the line
    172  0f38							;
    173  0f38							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    174  0f38							;  if fails then test for keywords
    175  0f38							;  if fails then test for variables and arrays
    176  0f38							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    177  0f38				   ParseInputLine
    178  0f38					      if	DEBUGPARSER
    179  0f38		       20 85 1d 	      jsr	SetOutDebug
    180  0f3b		       20 e1 10 	      jsr	DebugClearBuffer
    181  0f3e					      endif
    182  0f3e		       a5 51		      lda	CUROFF
    183  0f40		       48		      pha
    184  0f41		       8a		      txa
    185  0f42		       48		      pha
    186  0f43		       98		      tya
    187  0f44		       48		      pha
    188  0f45		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    189  0f47		       20 81 19 	      jsr	getDecimal	; Check for a line number, none is ok too
    190  0f4a		       84 51		      sty	CUROFF
    191  0f4c		       20 58 11 	      jsr	R02TOKEN	; Move R0 to token buffer
    192  0f4f
    193  0f4f				   ParseInputLoop
    194  0f4f		       a4 51		      ldy	CUROFF
    195  0f51		       20 03 1c 	      jsr	SkipSpaces	; Skip any spaces
    196  0f54		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    197  0f56		       b9 91 2b 	      lda	LINBUF,y	; Check for end of line
    198  0f59		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    199  0f5b
    200  0f5b				   ParseForNumber
    201  0f5b		       20 40 10 	      jsr	ParseNumeric	; Check for a numeric value
    202  0f5e		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    203  0f60
    204  0f60				   ParseForString
    205  0f60		       20 16 10 	      jsr	ParseString	; Check for a string
    206  0f63		       90 ea		      bcc	ParseInputLoop	; It was a string
    207  0f65
    208  0f65				   ParseForOp
    209  0f65		       20 7e 10 	      jsr	ParseForOperator	; Check for operator or punctuation
    210  0f68		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    211  0f6a
    212  0f6a				   ParseForKey
    213  0f6a		       20 9a 0f 	      jsr	ParseLookupKey	; Check for a keyword value
    214  0f6d		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    215  0f6f
    216  0f6f				   ParseForVar
    217  0f6f		       20 21 11 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    218  0f72		       90 db		      bcc	ParseInputLoop
    219  0f74
    220  0f74				   ParseKeepChar		; if it does not parse just keep it safe
    221  0f74		       b9 91 2b 	      lda	LINBUF,y
    222  0f77		       9d 35 0e 	      sta	TOKENBUFFER,x
    223  0f7a		       e8		      inx
    224  0f7b		       c8		      iny
    225  0f7c		       84 51		      sty	CUROFF
    226  0f7e		       d0 cf		      bne	ParseInputLoop
    227  0f80
    228  0f80				   ParseComplete
    229  0f80		       a9 00		      lda	#0
    230  0f82		       9d 35 0e 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    231  0f85		       e8		      inx
    232  0f86		       8e 35 0e 	      stx	TOKENBUFFER	; Place size including null into buffer start
    233  0f89
    234  0f89		       68		      pla
    235  0f8a		       a8		      tay
    236  0f8b		       68		      pla
    237  0f8c		       aa		      tax
    238  0f8d		       68		      pla
    239  0f8e		       85 51		      sta	CUROFF
    240  0f90
    241  0f90					      if	DEBUGPARSER
    242  0f90
    243  0f90		       20 f3 10 	      jsr	printTokenBuffer
    244  0f93		       20 82 11 	      jsr	DebugPrintProgramLine
    245  0f96		       20 3b 1d 	      jsr	SetOutConsole
    246  0f99
    247  0f99					      endif
    248  0f99		       60		      rts
    249  0f9a
    250  0f9a							;==================================================================================================================
    251  0f9a							; Look at curptr, curpos and check for a valid KeyWord
    252  0f9a							; A contains the index value. c is clear
    253  0f9a							;		     not found c set  A undefined
    254  0f9a							; X is prerserved
    255  0f9a							;
    256  0f9a				   ParseLookupKey
    257  0f9a		       86 58		      stx	R2
    258  0f9c		       a4 51		      ldy	CUROFF
    259  0f9e		       a2 00		      ldx	#0
    260  0fa0		       a9 01		      lda	#1
    261  0fa2		       85 52		      sta	R0	; at the end this will contain the index of the keyword
    262  0fa4					      if	DEBUGPARSER
    263  0fa4							;  jsr DebugKeyword
    264  0fa4					      endif
    265  0fa4		       a9 3f		      lda	#'?	; check for fast form of print
    266  0fa6		       d9 91 2b 	      cmp	LINBUF,y
    267  0fa9		       d0 04		      bne	ParseLookupLoop	; Skip to loop if not ?
    268  0fab		       a9 0b		      lda	#kPrint	; Number for print
    269  0fad		       d0 29		      bne	ParseKeySpecial	; Get out with the special case
    270  0faf
    271  0faf				   ParseLookupLoop
    272  0faf		       bd 6a 0d 	      lda	KeyWordTable,x	; Check both upper and lower characters
    273  0fb2		       29 df		      and	#%11011111	; Force Keyword to upper case
    274  0fb4		       d9 91 2b 	      cmp	LINBUF,y
    275  0fb7		       f0 07		      beq	ParseNextLetter
    276  0fb9		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    277  0fbb		       d9 91 2b 	      cmp	LINBUF,y
    278  0fbe		       d0 23		      bne	ParseNextEntry
    279  0fc0
    280  0fc0				   ParseNextLetter
    281  0fc0		       bd 6a 0d 	      lda	KeyWordTable,x	; Check if we just processed the last letter
    282  0fc3		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    283  0fc5		       f0 0b		      beq	ParseKeyFound
    284  0fc7		       e8		      inx
    285  0fc8		       c8		      iny
    286  0fc9		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    287  0fcb		       d9 91 2b 	      cmp	LINBUF,y
    288  0fce		       f0 13		      beq	ParseNextEntry	; End of buffer but no keyword
    289  0fd0		       d0 dd		      bne	ParseLookupLoop
    290  0fd2
    291  0fd2				   ParseKeyFound
    292  0fd2		       a5 52		      lda	R0	; get the keyword index
    293  0fd4		       c9 0a		      cmp	#kRem	; remark statement
    294  0fd6		       f0 25		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    295  0fd8
    296  0fd8				   ParseKeySpecial
    297  0fd8		       c8		      iny		; point past the last character
    298  0fd9		       84 51		      sty	CUROFF
    299  0fdb		       a6 58		      ldx	R2	; preserved the X pointer
    300  0fdd		       9d 35 0e 	      sta	TOKENBUFFER,x
    301  0fe0		       e8		      inx
    302  0fe1		       18		      clc
    303  0fe2		       60		      rts
    304  0fe3
    305  0fe3							; Move forward to the next entry in table
    306  0fe3				   ParseNextEntry
    307  0fe3		       bd 6a 0d 	      lda	KeyWordTable,x
    308  0fe6		       29 20		      and	#%00100000
    309  0fe8		       f0 03		      beq	ParseEndOfEntry
    310  0fea		       e8		      inx
    311  0feb		       d0 f6		      bne	ParseNextEntry
    312  0fed
    313  0fed				   ParseEndOfEntry
    314  0fed		       e8		      inx
    315  0fee					      if	DEBUGPARSER
    316  0fee							;    jsr DebugKeyword
    317  0fee					      endif
    318  0fee		       e6 52		      inc	R0	; Point to next index
    319  0ff0		       a4 51		      ldy	CUROFF	; Restore Y to start of the parse
    320  0ff2		       bd 6a 0d 	      lda	KeyWordTable,x
    321  0ff5		       f0 02		      beq	ParseNoneFound
    322  0ff7		       d0 b6		      bne	ParseLookupLoop
    323  0ff9
    324  0ff9				   ParseNoneFound
    325  0ff9		       a6 58		      ldx	R2
    326  0ffb		       38		      sec
    327  0ffc		       60		      rts
    328  0ffd
    329  0ffd							;===============================================================================
    330  0ffd							; Move everything from current position until the end of line into the token buffer
    331  0ffd							;
    332  0ffd		       c8	   ParseMoveLine iny		; next byte to parse
    333  0ffe		       a6 58		      ldx	R2	; where to place in the buffer
    334  1000		       a5 52		      lda	R0
    335  1002		       9d 35 0e 	      sta	TOKENBUFFER,x	;Put the rem into the buffer
    336  1005		       e8		      inx		;Skip to next byte after the reM
    337  1006				   ParseMoveLoop
    338  1006		       b9 91 2b 	      lda	LINBUF,y	; get the next byte
    339  1009		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    340  100b		       9d 35 0e 	      sta	TOKENBUFFER,x	; save the byte
    341  100e		       c8		      iny
    342  100f		       e8		      inx
    343  1010		       d0 f4		      bne	ParseMoveLoop
    344  1012				   ParseMoveDone
    345  1012		       84 51		      sty	CUROFF
    346  1014		       18		      clc
    347  1015		       60		      rts
    348  1016
    349  1016							;=========================================================================================================
    350  1016							;ParseString Parse a quotes string
    351  1016							; on input X = outbuf position
    352  1016							; y = inbuf position
    353  1016							; Copies string to output buffer, updates x and y
    354  1016				   ParseString
    355  1016		       a4 51		      ldy	CUROFF
    356  1018		       a9 a0		      lda	#tString
    357  101a		       9d 35 0e 	      sta	TOKENBUFFER,X
    358  101d		       b9 91 2b 	      lda	LINBUF,y
    359  1020		       c9 22		      cmp	#'"
    360  1022		       d0 1a		      bne	ParseStringInvalid
    361  1024		       e8		      inx
    362  1025		       9d 35 0e 	      sta	TOKENBUFFER,x
    363  1028		       e8		      inx
    364  1029		       c8		      iny
    365  102a
    366  102a				   ParseStringLoop
    367  102a		       b9 91 2b 	      lda	LINBUF,y
    368  102d		       9d 35 0e 	      sta	TOKENBUFFER,x
    369  1030		       c9 22		      cmp	#'"
    370  1032		       f0 04		      beq	ParseStringDone
    371  1034		       c8		      iny
    372  1035		       e8		      inx
    373  1036		       d0 f2		      bne	ParseStringLoop
    374  1038
    375  1038				   ParseStringDone
    376  1038		       e8		      inx
    377  1039		       c8		      iny
    378  103a		       84 51		      sty	CUROFF
    379  103c		       18		      clc
    380  103d		       60		      rts
    381  103e
    382  103e				   ParseStringInvalid
    383  103e		       38		      sec
    384  103f		       60		      rts
    385  1040
    386  1040							;=========================================================================================================
    387  1040							; Get numeric values and return value in RO and type in a
    388  1040							;
    389  1040				   ParseNumeric
    390  1040		       a4 51		      ldy	CUROFF
    391  1042		       b9 91 2b 	      lda	LINBUF,y
    392  1045		       c9 30		      cmp	#'0
    393  1047		       90 33		      bcc	ParseNumInvalid
    394  1049		       c9 3a		      cmp	#'9+1
    395  104b		       b0 2f		      bcs	ParseNumInvalid
    396  104d		       86 58		      stx	R2
    397  104f		       20 81 19 	      jsr	getDecimal
    398  1052		       a6 58		      ldx	R2
    399  1054		       84 51		      sty	CUROFF
    400  1056		       a5 53		      lda	R0+1
    401  1058		       f0 14		      beq	ParseByteValue
    402  105a
    403  105a				   ParseIntegerValue
    404  105a		       a9 a1		      lda	#tInteger
    405  105c		       9d 35 0e 	      sta	TOKENBUFFER,x
    406  105f		       e8		      inx
    407  1060		       a5 52		      lda	R0
    408  1062		       9d 35 0e 	      sta	TOKENBUFFER,x
    409  1065		       e8		      inx
    410  1066		       a5 53		      lda	R0+1
    411  1068		       9d 35 0e 	      sta	TOKENBUFFER,X
    412  106b		       e8		      inx
    413  106c		       18		      clc
    414  106d		       60		      rts
    415  106e
    416  106e				   ParseByteValue
    417  106e		       a9 a2		      lda	#tByte
    418  1070		       9d 35 0e 	      sta	TOKENBUFFER,x
    419  1073		       e8		      inx
    420  1074		       a5 52		      lda	R0
    421  1076		       9d 35 0e 	      sta	TOKENBUFFER,x
    422  1079		       e8		      inx
    423  107a		       18		      clc
    424  107b		       60		      rts
    425  107c
    426  107c				   ParseNumInvalid		;Not a valid Numeric
    427  107c		       38		      sec
    428  107d		       60		      rts
    429  107e
    430  107e							;=========================================================================================================
    431  107e							;Parse for operators
    432  107e							; +($F0), <($F1),=($F2),<=($F3), >($F4), <>($F5), >=($F6), -($F7), /($F8), %($F9), *($FA), (($FB), )($FC)
    433  107e							; on exit the A has the oper code, c is clear
    434  107e							;		 not found then c is set
    435  107e							;	x is preserved
    436  107e							;
    437  107e							;Operators: BYTE "<>","<=",">=",'+,0,'<,0,'=,0,">",0,"-",0,"/",0,"%",0,"*",0,"(",0,")",0,",",0,";",0,"[",0,"]",0,":",0
    438  107e							;OperatorLen equ *-Operators
    439  107e							;
    440  107e							;OperValues BYTE  $F5,$F3,$F6,$F0,$F1,$F2,$F4,$F7,$F8,$F9,$FA,$E0,$E1,$E2,$E3,$E4,$E5,$E6
    441  107e							;OPCount    equ   * - OperValues
    442  107e
    443  107e				   ParseForOperator
    444  107e		       86 58		      stx	R2
    445  1080		       a4 51		      ldy	CUROFF
    446  1082		       a6 00		      ldx	0
    447  1084					      if	DEBUGPARSER
    448  1084							; jsr	  DebugPrintOP
    449  1084					      endif
    450  1084				   ParseOpLoop
    451  1084		       bd 2e 0d 	      lda	Operators,x
    452  1087		       d9 91 2b 	      cmp	LINBUF,y
    453  108a		       d0 1c		      bne	ParseOpNext
    454  108c		       c8		      iny
    455  108d		       bd 2f 0d 	      lda	Operators+1,x
    456  1090		       f0 06		      beq	ParseOpFoundSingle
    457  1092		       d9 91 2b 	      cmp	LINBUF,y
    458  1095		       d0 11		      bne	ParseOpNext
    459  1097
    460  1097				   ParseOpFound
    461  1097		       c8		      iny
    462  1098
    463  1098				   ParseOpFoundSingle
    464  1098		       84 51		      sty	CUROFF
    465  109a
    466  109a		       8a		      txa
    467  109b		       4a		      lsr
    468  109c		       aa		      tax
    469  109d		       bd 56 0d 	      lda	OperValues,x
    470  10a0		       a6 58		      ldx	R2
    471  10a2		       9d 35 0e 	      sta	TOKENBUFFER,x
    472  10a5		       e8		      inx
    473  10a6		       18		      clc
    474  10a7		       60		      rts
    475  10a8
    476  10a8				   ParseOpNext
    477  10a8		       e8		      inx
    478  10a9		       e8		      inx
    479  10aa		       e0 28		      cpx	#OperatorLen
    480  10ac		       b0 04		      bcs	ParseOpNotFound
    481  10ae					      if	DEBUGPARSER
    482  10ae							;   jsr    DebugPrintOP
    483  10ae					      endif
    484  10ae		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    485  10b0		       d0 d2		      bne	ParseOpLoop
    486  10b2
    487  10b2				   ParseOpNotFound
    488  10b2		       a6 58		      ldx	R2
    489  10b4		       38		      sec
    490  10b5		       60		      rts
    491  10b6							;=========================================================================================================
    492  10b6					      if	DEBUGPARSER
    493  10b6							;Print the text of a keyword
    494  10b6							;Input x = offset into table
    495  10b6				   DebugKeyword
    496  10b6		       48		      pha
    497  10b7		       8a		      txa
    498  10b8		       48		      pha
    499  10b9				   DebugKeyLoop
    500  10b9		       bd 6a 0d 	      lda	KeyWordTable,x
    501  10bc		       20 55 1d 	      jsr	VOUTCH
    502  10bf		       29 20		      and	#%00100000
    503  10c1		       f0 03		      beq	DebugKeyDone
    504  10c3		       e8		      inx
    505  10c4		       d0 f3		      bne	DebugKeyLoop
    506  10c6
    507  10c6				   DebugKeyDone
    508  10c6		       20 0c 1c 	      jsr	CRLF
    509  10c9		       68		      pla
    510  10ca		       aa		      tax
    511  10cb		       68		      pla
    512  10cc		       60		      rts
    513  10cd							;========================================
    514  10cd				   DebugPrintOP
    515  10cd		       48		      pha
    516  10ce		       bd 2e 0d 	      lda	Operators,x
    517  10d1		       20 55 1d 	      jsr	VOUTCH
    518  10d4		       bd 2f 0d 	      lda	Operators+1,x
    519  10d7		       f0 03		      beq	DbgPrtOpDone
    520  10d9		       20 55 1d 	      jsr	VOUTCH
    521  10dc
    522  10dc				   DbgPrtOpDone
    523  10dc		       20 0c 1c 	      jsr	CRLF
    524  10df		       68		      pla
    525  10e0		       60		      rts
    526  10e1							;=======================================
    527  10e1				   DebugClearBuffer
    528  10e1		       8a		      txa
    529  10e2		       48		      pha
    530  10e3		       a2 ff		      ldx	#$FF
    531  10e5		       a9 00		      lda	#0
    532  10e7				   DebugClrLoop
    533  10e7		       9d 35 0e 	      sta	TOKENBUFFER,x
    534  10ea		       ca		      dex
    535  10eb		       d0 fa		      bne	DebugClrLoop
    536  10ed		       9d 35 0e 	      sta	TOKENBUFFER,x
    537  10f0		       68		      pla
    538  10f1		       aa		      tax
    539  10f2		       60		      rts
    540  10f3
    541  10f3							;=====================================================
    542  10f3							; Print the parser buffer as hex values
    543  10f3				   printTokenBuffer
    544  10f3		       8e 35 0f 	      stx	printStorage
    545  10f6		       8c 36 0f 	      sty	printStorage+1
    546  10f9		       8d 37 0f 	      sta	printStorage+2
    547  10fc
    548  10fc		       ae 35 0e 	      ldx	TOKENBUFFER	; get the length of the buffer
    549  10ff		       e8		      inx		; we want to show the last zero byte
    550  1100		       a0 00		      ldy	#0
    551  1102
    552  1102				   printHexLoop
    553  1102		       b9 35 0e 	      lda	TOKENBUFFER,y	; get the character
    554  1105		       20 65 13 	      jsr	HexToOut	; print it
    555  1108		       a9 20		      lda	#$20
    556  110a		       20 55 1d 	      jsr	VOUTCH
    557  110d		       c8		      iny
    558  110e		       ca		      dex
    559  110f		       e0 00		      cpx	#0
    560  1111		       d0 ef		      bne	printHexLoop
    561  1113		       20 0c 1c 	      jsr	CRLF
    562  1116
    563  1116		       ac 36 0f 	      ldy	printStorage+1
    564  1119		       ae 35 0f 	      ldx	printStorage
    565  111c		       ad 37 0f 	      lda	printStorage+2
    566  111f				   printHexDone
    567  111f		       18		      clc
    568  1120		       60		      rts
    569  1121					      endif
    570  1121
    571  1121
    572  1121							;=========================================================================================================
    573  1121							; Parse for variables A-Z @, ^  x!x x[op]
    574  1121				   ParseForVariable
    575  1121		       a4 51		      ldy	CUROFF
    576  1123		       b9 91 2b 	      lda	LINBUF,y
    577  1126		       c9 5e		      cmp	#'^	; is it an exit code
    578  1128		       d0 04		      bne	ParseVarMem
    579  112a		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    580  112c		       d0 1f		      bne	ParseVarSpecial
    581  112e
    582  112e				   ParseVarMem
    583  112e		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    584  1130		       d0 04		      bne	ParseVarStack
    585  1132		       a9 9d		      lda	#tVat
    586  1134		       d0 17		      bne	ParseVarSpecial
    587  1136
    588  1136				   ParseVarStack
    589  1136		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    590  1138		       d0 04		      bne	ParseVarLetters
    591  113a		       a9 9c		      lda	#tVhash
    592  113c		       d0 0f		      bne	ParseVarSpecial
    593  113e
    594  113e				   ParseVarLetters
    595  113e		       29 df		      and	#%11011111	; Force upper case
    596  1140		       c9 41		      cmp	#'A
    597  1142		       90 12		      bcc	ParseVarInvalid
    598  1144		       c9 5b		      cmp	#'Z+1
    599  1146		       b0 0e		      bcs	ParseVarInvalid
    600  1148							;
    601  1148							; The condition is true, so convert to an index, push
    602  1148							; it onto the stack and continue running.
    603  1148							;
    604  1148		       38		      sec
    605  1149		       e9 41		      sbc	#'A	;index is zero based
    606  114b		       09 80		      ora	#$80
    607  114d
    608  114d				   ParseVarSpecial
    609  114d		       9d 35 0e 	      sta	TOKENBUFFER,x
    610  1150		       e8		      inx
    611  1151		       c8		      iny
    612  1152		       84 51		      sty	CUROFF
    613  1154		       18		      clc
    614  1155		       60		      rts
    615  1156
    616  1156				   ParseVarInvalid
    617  1156		       38		      sec
    618  1157		       60		      rts
    619  1158
    620  1158
    621  1158							;=========================================================================================================
    622  1158							; Transfer R0 to the TOKENBUFFER
    623  1158							;
    624  1158				   R02TOKEN
    625  1158		       a5 52		      lda	R0
    626  115a		       9d 35 0e 	      sta	TOKENBUFFER,x
    627  115d		       e8		      inx
    628  115e		       a5 53		      lda	R0+1
    629  1160		       9d 35 0e 	      sta	TOKENBUFFER,x
    630  1163		       e8		      inx
    631  1164		       18		      clc
    632  1165		       60		      rts
    633  1166				   TOKEN2R0
    634  1166		       b9 35 0e 	      lda	TOKENBUFFER,y
    635  1169		       85 52		      sta	R0
    636  116b		       c8		      iny
    637  116c		       ca		      dex
    638  116d		       b9 35 0e 	      lda	TOKENBUFFER,y
    639  1170		       c8		      iny
    640  1171		       ca		      dex
    641  1172		       85 53		      sta	R0+1
    642  1174		       60		      rts
    643  1175				   DPL2R0
    644  1175		       b1 59		      lda	(dpl),y
    645  1177		       85 52		      sta	R0
    646  1179		       c8		      iny
    647  117a		       ca		      dex
    648  117b		       b1 59		      lda	(dpl),y
    649  117d		       c8		      iny
    650  117e		       ca		      dex
    651  117f		       85 53		      sta	R0+1
    652  1181		       60		      rts
    653  1182
    654  1182							;==========================================================================================================
    655  1182							;Debug   Print a Program Line from compile buffer
    656  1182							;
    657  1182				   DebugPrintProgramLine
    658  1182		       48		      pha
    659  1183		       a9 35		      lda	#TOKENBUFFER&$FF
    660  1185		       85 59		      sta	dpl
    661  1187		       a9 0e		      lda	#TOKENBUFFER>>8
    662  1189		       85 5a		      sta	dpl+1
    663  118b		       68		      pla
    664  118c
    665  118c							; Decode and print a line of program text
    666  118c							; on entry	 dpl points to line of code to print
    667  118c							; on exit	 no change in reg of dpl
    668  118c							;
    669  118c				   PrintProgramLine
    670  118c
    671  118c		       8e 35 0f 	      stx	printStorage
    672  118f		       8c 36 0f 	      sty	printStorage+1
    673  1192		       48		      pha
    674  1193
    675  1193		       a0 01		      ldy	#1	; index into the token buffer
    676  1195		       84 58		      sty	R2	; print unsigned decimal
    677  1197		       a0 00		      ldy	#0
    678  1199		       b1 59		      lda	(dpl),y	; get number of bytes
    679  119b		       aa		      tax		; place pointer into x
    680  119c		       c8		      iny
    681  119d		       ca		      dex		; Deduct the length byte
    682  119e		       20 75 11 	      jsr	DPL2R0	; Print the line number
    683  11a1		       20 b3 12 	      jsr	PrintDecimal
    684  11a4		       a9 20		      lda	#$20
    685  11a6		       20 55 1d 	      jsr	VOUTCH
    686  11a9
    687  11a9				   PrintProgLoop
    688  11a9		       b1 59		      lda	(dpl),y	; Get a character
    689  11ab		       f0 3c		      beq	PrintProgramComplete
    690  11ad		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    691  11af		       f0 67		      beq	PrintKeyword	; It uses the index in a to find a keyword
    692  11b1
    693  11b1				   PrintProgVars
    694  11b1		       b1 59		      lda	(dpl),y
    695  11b3		       29 e0		      and	#$E0	; Check for operators and punctuation
    696  11b5		       c9 e0		      cmp	#$E0
    697  11b7		       f0 5c		      beq	PrintProgOperatorVect
    698  11b9		       b1 59		      lda	(dpl),y
    699  11bb		       c9 9e		      cmp	#$9D+1
    700  11bd		       90 54		      bcc	PrintProgVariableVec
    701  11bf		       c9 a0		      cmp	#tString
    702  11c1		       f0 31		      beq	PrintStringVariable
    703  11c3		       c8		      iny		; we have a numerical value
    704  11c4		       ca		      dex
    705  11c5		       48		      pha
    706  11c6		       a9 00		      lda	#0
    707  11c8		       85 53		      sta	R0+1
    708  11ca		       85 58		      sta	R2	; Set to print signed number
    709  11cc		       b1 59		      lda	(dpl),y
    710  11ce		       85 52		      sta	R0
    711  11d0		       68		      pla
    712  11d1		       c9 a1		      cmp	#tInteger
    713  11d3		       d0 06		      bne	PrintProgNumDone
    714  11d5		       c8		      iny
    715  11d6		       ca		      dex
    716  11d7		       b1 59		      lda	(dpl),y
    717  11d9		       85 53		      sta	R0+1
    718  11db
    719  11db				   PrintProgNumDone
    720  11db		       c8		      iny
    721  11dc		       ca		      dex
    722  11dd		       20 b3 12 	      jsr	PrintDecimal
    723  11e0
    724  11e0				   PrintProgNext
    725  11e0		       a9 20		      lda	#$20
    726  11e2		       20 55 1d 	      jsr	VOUTCH
    727  11e5				   PrintProgSkipSpace
    728  11e5		       e0 00		      cpx	#0
    729  11e7		       d0 c0		      bne	PrintProgLoop
    730  11e9				   PrintProgramComplete
    731  11e9		       20 0c 1c 	      jsr	CRLF
    732  11ec
    733  11ec		       ae 35 0f 	      ldx	printStorage
    734  11ef		       ac 36 0f 	      ldy	printStorage+1
    735  11f2		       68		      pla
    736  11f3
    737  11f3		       60		      rts
    738  11f4							;=================================================================================================================
    739  11f4							; Print a string variable including the quotes
    740  11f4							; On Input	 y is offset into buffer
    741  11f4							; On Exit	 y is updated to new offset
    742  11f4
    743  11f4				   PrintStringVariable
    744  11f4		       c8		      iny
    745  11f5		       a9 22		      lda	#'"
    746  11f7		       20 55 1d 	      jsr	VOUTCH
    747  11fa		       c8		      iny
    748  11fb		       a5 59		      lda	dpl
    749  11fd		       85 5e		      sta	PrtFrom
    750  11ff		       a5 5a		      lda	dpl+1
    751  1201		       85 5f		      sta	PrtFrom+1
    752  1203		       a9 22		      lda	#'"
    753  1205		       8d 26 2c 	      sta	PrtTerm
    754  1208		       20 d0 13 	      jsr	PrtLoop
    755  120b		       a9 22		      lda	#'"
    756  120d		       20 55 1d 	      jsr	VOUTCH
    757  1210		       4c e0 11 	      jmp	PrintProgNext
    758  1213
    759  1213				   PrintProgVariableVec
    760  1213		       90 77		      bcc	PrintProgVariable
    761  1215				   PrintProgOperatorVect
    762  1215		       4c 63 12 	      jmp	PrintProgOperator
    763  1218							;===============================================================================================================
    764  1218				   PrintKeyword
    765  1218
    766  1218		       b1 59		      lda	(dpl),y
    767  121a		       ca		      dex
    768  121b		       c8		      iny
    769  121c		       85 52		      sta	R0	; the counter save area
    770  121e		       85 53		      sta	R0+1	; to refer to later if needed
    771  1220		       8e 37 0f 	      stx	printStorage+2
    772  1223
    773  1223		       a2 00		      ldx	#0
    774  1225				   PrintKeyLoop
    775  1225		       c6 52		      dec	R0	; Keyword indexes are 1 relative, adjust to zero relative
    776  1227		       a9 00		      lda	#0
    777  1229		       c5 52		      cmp	R0
    778  122b		       f0 0a		      Beq	PrintKeyFound	; We have the correct index, now print it
    779  122d				   PrintKeyNext
    780  122d		       bd 6a 0d 	      lda	KeyWordTable,x
    781  1230		       e8		      inx		; Point to next byte always
    782  1231		       29 20		      and	#%00100000
    783  1233		       f0 f0		      beq	PrintKeyLoop
    784  1235		       d0 f6		      bne	PrintKeyNext
    785  1237
    786  1237				   PrintKeyFound
    787  1237		       bd 6a 0d 	      lda	KeyWordTable,x
    788  123a		       48		      pha
    789  123b		       09 20		      ora	#%00100000
    790  123d		       20 55 1d 	      jsr	VOUTCH
    791  1240		       e8		      inx
    792  1241		       68		      pla
    793  1242		       29 20		      and	#%00100000
    794  1244		       d0 f1		      bne	PrintKeyFound
    795  1246		       ae 37 0f 	      ldx	printStorage+2
    796  1249				   PrintChkRem
    797  1249		       a9 0a		      lda	#kRem
    798  124b		       c5 53		      cmp	R0+1
    799  124d		       d0 11		      bne	PrintKeyDone
    800  124f				   PrintKeyRem
    801  124f		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    802  1251		       85 5e		      sta	PrtFrom
    803  1253		       a5 5a		      lda	dpl+1
    804  1255		       85 5f		      sta	PrtFrom+1
    805  1257		       a9 00		      lda	#0
    806  1259		       8d 26 2c 	      sta	PrtTerm
    807  125c		       20 d0 13 	      jsr	PrtLoop
    808  125f		       88		      dey		; point back to the terminating null value
    809  1260				   PrintKeyDone
    810  1260		       4c e0 11 	      jmp	PrintProgNext
    811  1263							;==================================================================================================================
    812  1263							;Print Variable, number or operator
    813  1263				   PrintProgOperator
    814  1263		       b1 59		      lda	(dpl),y
    815  1265		       c8		      iny
    816  1266		       ca		      dex
    817  1267		       8e 37 0f 	      stx	printStorage+2
    818  126a		       a2 00		      ldx	#0
    819  126c				   PrintOprLoop
    820  126c		       dd 56 0d 	      cmp	OperValues,x
    821  126f		       f0 03		      beq	PrintOprFound
    822  1271		       e8		      inx
    823  1272		       d0 f8		      bne	PrintOprLoop
    824  1274				   PrintOprFound
    825  1274		       8a		      txa
    826  1275		       0a		      asl
    827  1276		       aa		      tax
    828  1277		       bd 2e 0d 	      lda	Operators,x
    829  127a		       20 55 1d 	      jsr	VOUTCH
    830  127d		       e8		      inx
    831  127e		       bd 2e 0d 	      lda	Operators,x
    832  1281		       f0 03		      beq	PrintOprDone
    833  1283		       20 55 1d 	      jsr	VOUTCH
    834  1286				   PrintOprDone
    835  1286		       ae 37 0f 	      ldx	printStorage+2
    836  1289		       4c e0 11 	      jmp	PrintProgNext
    837  128c
    838  128c							;=================================================================================================================
    839  128c							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    840  128c							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    841  128c							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    842  128c							;tVhat 	    equ     155 		   ; Variable ^
    843  128c							;tVhash	    equ     156 		   ; Variable #
    844  128c							;tVat		    equ     157 		   ; Variable @ = 0
    845  128c				   PrintProgVariable
    846  128c		       b1 59		      lda	(dpl),y
    847  128e		       c8		      iny
    848  128f		       ca		      dex
    849  1290		       c5 9b		      cmp	tVhat
    850  1292		       d0 04		      bne	PrintProgChkHash
    851  1294		       a9 5e		      lda	#'^
    852  1296		       d0 15		      bne	PrintTheVar
    853  1298				   PrintProgChkHash
    854  1298		       c5 9c		      cmp	tVhash
    855  129a		       d0 04		      bne	PrintProgChkAt
    856  129c		       a9 23		      lda	#'#
    857  129e		       d0 0d		      bne	PrintTheVar
    858  12a0				   PrintProgChkAt
    859  12a0		       c5 9d		      cmp	tVat
    860  12a2		       d0 04		      bne	PrintProgVarLetter
    861  12a4		       a9 40		      lda	#'@
    862  12a6		       d0 05		      bne	PrintTheVar
    863  12a8				   PrintProgVarLetter
    864  12a8		       29 7f		      and	#%01111111
    865  12aa		       18		      clc
    866  12ab		       69 41		      adc	#'A
    867  12ad				   PrintTheVar
    868  12ad		       20 55 1d 	      jsr	VOUTCH
    869  12b0		       4c e0 11 	      jmp	PrintProgNext
    870  12b3
    871  12b3
    872  12b3
    873  12b3
    874  12b3
    875  12b3
    876  12b3
    877  12b3
    878  12b3
    879  12b3
    880  12b3
    881  12b3
    882  12b3
    883  12b3
    884  12b3
    885  12b3
    886  12b3
    887  12b3
    888  12b3
    889  12b3
    890  12b3
    891  12b3
    892  12b3
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  12b3					      include	"print.asm"
      1  12b3					      Seg	Code
      2  12b3							;---------------------------
      3  12b3							; Print 24-bit decimal number or  16bit unsigned
      4  12b3							; ---------------------------
      5  12b3							; On entry, R0=number to print
      6  12b3							;	     Defaults to pad=0 , y=21 default
      7  12b3							;	     R2 = 1 unsigned 16 bit
      8  12b3							;	     R2 = 0 Signed   16 bit
      9  12b3
     10  12b3							; On entry at PrintDecPadded:
     11  12b3							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  12b3
     13  12b3							; On exit,  A,X,Y,num,pad corrupted
     14  12b3							; Size      129 bytes, Table 24 bytes	--- total 153
     15  12b3							; -----------------------------------------------------------------
     16  12b3
     17  12b3				   PrintDecimal
     18  12b3		       8a		      TXA
     19  12b4		       48		      pha
     20  12b5		       98		      tya
     21  12b6		       48		      pha
     22  12b7		       a9 00		      lda	#0
     23  12b9		       8d 4c 13 	      sta	pad
     24  12bc		       a0 15		      LDY	#21	; Offset to powers of ten
     25  12be		       4c c4 12 	      JMP	PrintDo
     26  12c1
     27  12c1				   PrintDecPadded
     28  12c1		       8e 4c 13 	      stx	pad
     29  12c4
     30  12c4				   PrintDo
     31  12c4		       a9 00		      lda	#0
     32  12c6		       85 54		      sta	R1
     33  12c8
     34  12c8		       a5 58		      lda	R2
     35  12ca		       d0 29		      bne	PrintPos
     36  12cc
     37  12cc		       a5 53		      lda	R0+1	;MSB has sign
     38  12ce		       10 25		      bpl	PrintPos	;it's a positive number;
     39  12d0
     40  12d0
     41  12d0							; Negative numbers need more work.  Invert all the bits,
     42  12d0							; then add one.
     43  12d0
     44  12d0		       a9 2d		      lda	#'-
     45  12d2		       20 55 1d 	      jsr	VOUTCH	;print the negative sign
     46  12d5
     47  12d5		       a9 ff		      lda	#$FF
     48  12d7		       85 54		      sta	R1
     49  12d9		       a5 52		      lda	R0	;invert bits
     50  12db		       49 ff		      eor	#$ff
     51  12dd		       85 52		      sta	R0
     52  12df		       a5 53		      lda	R0+1
     53  12e1		       49 ff		      eor	#$ff
     54  12e3		       85 53		      sta	R0+1
     55  12e5		       a5 54		      lda	R1
     56  12e7		       49 ff		      eor	#$ff
     57  12e9		       85 54		      sta	R1
     58  12eb		       e6 52		      inc	R0	;add one
     59  12ed		       d0 06		      bne	PrintPos
     60  12ef		       e6 53		      inc	R0+1
     61  12f1		       d0 02		      bne	PrintPos
     62  12f3		       e6 54		      inc	R1
     63  12f5				   PrintPos
     64  12f5
     65  12f5				   PrDec24Lp1
     66  12f5		       a2 ff		      LDX	#$FF
     67  12f7		       38		      SEC		; Start with digit=-1
     68  12f8				   PrDec24Lp2
     69  12f8		       a5 52		      LDA	R0+0
     70  12fa		       f9 4d 13 	      SBC	PrDec24Tens+0,Y
     71  12fd		       85 52		      STA	R0+0	; Subtract current tens
     72  12ff		       a5 53		      LDA	R0+1
     73  1301		       f9 4e 13 	      SBC	PrDec24Tens+1,Y
     74  1304		       85 53		      STA	R0+1
     75  1306		       a5 54		      LDA	R0+2
     76  1308		       f9 4f 13 	      SBC	PrDec24Tens+2,Y
     77  130b		       85 54		      STA	R0+2
     78  130d		       e8		      INX
     79  130e		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  1310		       a5 52		      LDA	R0+0
     81  1312		       79 4d 13 	      ADC	PrDec24Tens+0,Y
     82  1315		       85 52		      STA	R0+0	; Add current tens back in
     83  1317		       a5 53		      LDA	R0+1
     84  1319		       79 4e 13 	      ADC	PrDec24Tens+1,Y
     85  131c		       85 53		      STA	R0+1
     86  131e		       a5 54		      LDA	R0+2
     87  1320		       79 4f 13 	      ADC	PrDec24Tens+2,Y
     88  1323		       85 54		      STA	R0+2
     89  1325		       8a		      TXA
     90  1326		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  1328		       ad 4c 13 	      LDA	pad
     92  132b		       d0 09		      BNE	PrDec24Print
     93  132d		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  132f				   PrDec24Digit
     95  132f		       a2 30		      LDX	#'0
     96  1331		       8e 4c 13 	      STX	pad	; No more zero padding
     97  1334		       09 30		      ORA	#'0	; Print this digit
     98  1336				   PrDec24Print
     99  1336		       20 55 1d 	      JSR	VOUTCH
    100  1339				   PrDec24Next
    101  1339		       88		      DEY
    102  133a		       88		      DEY
    103  133b		       88		      DEY
    104  133c		       f0 07		      beq	PrDec24LastDigit
    105  133e		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  1340		       68		      pla
    107  1341		       a8		      tay
    108  1342		       68		      pla
    109  1343		       aa		      tax
    110  1344		       60		      RTS
    111  1345				   PrDec24LastDigit
    112  1345		       a2 30		      LDX	#'0
    113  1347		       8e 4c 13 	      STX	pad	; No more zero padding
    114  134a		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  134c
      0  134c				   pad	      db	0
      1  134c		       00		      .byte.b	0
    117  134d				   PrDec24Tens
      0  134d					      dw	1
      1  134d		       01 00		      .word.w	1
      0  134f					      db	1 / 65536
      1  134f		       00		      .byte.b	1 / 65536
      0  1350					      dw	10
      1  1350		       0a 00		      .word.w	10
      0  1352					      db	10 / 65536
      1  1352		       00		      .byte.b	10 / 65536
      0  1353					      dw	100
      1  1353		       64 00		      .word.w	100
      0  1355					      db	100 / 65536
      1  1355		       00		      .byte.b	100 / 65536
      0  1356					      dw	1000
      1  1356		       e8 03		      .word.w	1000
      0  1358					      db	1000 / 65536
      1  1358		       00		      .byte.b	1000 / 65536
      0  1359					      dw	10000
      1  1359		       10 27		      .word.w	10000
      0  135b					      db	10000 / 65536
      1  135b		       00		      .byte.b	10000 / 65536
      0  135c					      dw	100000
      1  135c		       a0 86		      .word.w	100000
      0  135e					      db	100000 / 65536
      1  135e		       01		      .byte.b	100000 / 65536
      0  135f					      dw	1000000
      1  135f		       40 42		      .word.w	1000000
      0  1361					      db	1000000 / 65536
      1  1361		       0f		      .byte.b	1000000 / 65536
      0  1362					      dw	10000000
      1  1362		       80 96		      .word.w	10000000
      0  1364					      db	10000000 / 65536
      1  1364		       98		      .byte.b	10000000 / 65536
    134  1365							;=====================================================
    135  1365							; Print character in A as two hex digits to the
    136  1365
    137  1365		       48	   HexToOut   pha		;save return value
    138  1366		       48		      pha
    139  1367		       4a		      lsr		;a  ;move top nibble to bottom
    140  1368		       4a		      lsr		;a
    141  1369		       4a		      lsr		;a
    142  136a		       4a		      lsr		;a
    143  136b		       20 74 13 	      jsr	hexta	;output nibble
    144  136e		       68		      pla
    145  136f		       20 74 13 	      jsr	hexta
    146  1372		       68		      pla		;restore
    147  1373		       60		      rts
    148  1374							;
    149  1374		       29 0f	   hexta      and	#%0001111
    150  1376		       c9 0a		      cmp	#$0a
    151  1378		       18		      clc
    152  1379		       30 02		      bmi	hexta1
    153  137b		       69 07		      adc	#7
    154  137d		       69 30	   hexta1     adc	#'0	;then fall into...
    155  137f		       4c 55 1d 	      jmp	VOUTCH
    156  1382							;
    157  1382							;=====================================================
    158  1382							; Print the string that immediately follows the JSR to
    159  1382							; this function.  Stops when a null byte is found,
    160  1382							; then returns to the instruction immediately
    161  1382							; following the null.
    162  1382							;
    163  1382							; Thanks to Ross Archer for this code.
    164  1382							; http://www.6502.org/source/io/primm.htm
    165  1382							;
    166  1382
    167  1382		       68	   tbputs     pla		;Get the low part of "return" address
    168  1383							;(data start address)
    169  1383		       85 5e		      sta	PrtFrom
    170  1385		       68		      pla
    171  1386		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    172  1388							;(data start address)
    173  1388							;Note: actually we're pointing one short
    174  1388		       a0 01	   PSINB      ldy	#1
    175  138a		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    176  138c		       e6 5e		      inc	PrtFrom	;update the pointer
    177  138e		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    178  1390		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    179  1392		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    180  1394							;   Accumulator
    181  1394		       f0 06		      beq	PSIX1	;don't print the final NULL
    182  1396		       20 55 1d 	      jsr	VOUTCH	;write it out
    183  1399		       4c 88 13 	      jmp	PSINB	;back around
    184  139c		       e6 5e	   PSIX1      inc	PrtFrom
    185  139e		       d0 02		      bne	PSIX2
    186  13a0		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    187  13a2		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    188  13a5
    189  13a5							;+
    190  13a5							;====================================================
    191  13a5		       2c 26	   PrtTerm    equ	tempy
    192  13a5
    193  13a5							; on exit Print Y has the offset to use
    194  13a5							; input y =	 addr low
    195  13a5							;	 x =	 addr high
    196  13a5							;	 a =	 termination string
    197  13a5
    198  13a5				   PrtPrgLine
    199  13a5		       a9 00		      lda	#0
    200  13a7		       8d 26 2c 	      sta	PrtTerm
    201  13aa		       f0 0e		      beq	PrtPrgText
    202  13ac
    203  13ac				   PrtQuoted
    204  13ac		       a9 22		      lda	#'"
    205  13ae		       a4 51		      ldy	CUROFF
    206  13b0		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    207  13b2		       d0 03		      bne	PrtNoInc
    208  13b4		       c8		      iny
    209  13b5		       84 51		      sty	CUROFF
    210  13b7				   PrtNoInc
    211  13b7		       8d 26 2c 	      sta	PrtTerm
    212  13ba
    213  13ba		       a4 51	   PrtPrgText ldy	CUROFF
    214  13bc		       a5 4f		      lda	CURPTR
    215  13be		       85 5e		      sta	PrtFrom
    216  13c0		       a5 50		      lda	CURPTR+1
    217  13c2		       85 5f		      sta	PrtFrom+1
    218  13c4		       4c d0 13 	      jmp	PrtLoop
    219  13c7
    220  13c7							; Print a string pointed to by x= h, y=l terminated by a
    221  13c7							; Return y as the length
    222  13c7
    223  13c7		       86 5f	   PrtStr     stx	PrtFrom+1
    224  13c9		       84 5e		      sty	PrtFrom
    225  13cb		       8d 26 2c 	      sta	PrtTerm
    226  13ce		       a0 00		      ldy	#0
    227  13d0							;
    228  13d0							; On entry here ptrfrom and prtterm point to area to print
    229  13d0							;
    230  13d0		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    231  13d2		       cd 26 2c 	      cmp	PrtTerm
    232  13d5		       f0 0b		      beq	PrtEnd
    233  13d7		       c9 00		      cmp	#0	; always end if 0 is found
    234  13d9		       f0 07		      beq	PrtEnd
    235  13db		       20 55 1d 	      jsr	VOUTCH
    236  13de		       c8		      iny
    237  13df		       4c d0 13 	      jmp	PrtLoop
    238  13e2		       c8	   PrtEnd     iny		;return byte after the copy
    239  13e3		       60		      rts
    240  13e4
    241  13e4							;
    242  13e4							;=======================================================
    243  13e4							; Print all Variables
    244  13e4				   PrintAllVars
    245  13e4		       a0 00		      ldy	#0
    246  13e6		       a9 41		      lda	#'A
    247  13e8				   PrintAllVarsLoop
    248  13e8		       48		      pha
    249  13e9		       b1 41		      lda	(VARIABLES),y
    250  13eb		       85 52		      sta	R0
    251  13ed		       c8		      iny
    252  13ee		       b1 41		      lda	(VARIABLES),y
    253  13f0		       85 53		      sta	R0+1
    254  13f2
    255  13f2		       68		      pla		;get the current letter
    256  13f3		       48		      pha
    257  13f4		       20 55 1d 	      jsr	VOUTCH
    258  13f7		       20 82 13 	      jsr	puts
      0  13fa					      db	"=",0
      1  13fa		       3d 00		      .byte.b	"=",0
    260  13fc		       68		      pla
    261  13fd		       aa		      tax
    262  13fe		       e8		      inx
    263  13ff		       8a		      txa
    264  1400		       48		      pha		;
    265  1401
    266  1401		       98		      tya
    267  1402		       48		      pha
    268  1403		       20 b3 12 	      jsr	PrintDecimal
    269  1406		       20 82 13 	      jsr	puts
      0  1409					      db	" ",0
      1  1409		       20 00		      .byte.b	" ",0
    271  140b		       68		      pla
    272  140c		       a8		      tay
    273  140d		       c8		      iny
    274  140e		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    275  1410		       90 d6		      bcc	PrintAllVarsLoop
    276  1412		       20 0c 1c 	      jsr	CRLF
    277  1415
    278  1415		       68		      pla
    279  1416		       60		      rts
    280  1417
    281  1417							;==================================================================================================
    282  1417							; Size of print functions
    283  1417		       01 64	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  1417					      include	"mem.asm"
      1  1417							;===================================================================
      2  1417							;This file contains the memory allocation and free functions
      3  1417							;in herant in this is the management of free memory in the system
      4  1417							; the interface to these functions
      5  1417							; a,x returns or provides the low hi bytes of the managed addresses
      6  1417							; This uses the programend, to memory end as the area to manage
      7  1417							;===================================================================
      8  1417					      Seg	Code
      9  1417							;=====================================================
     10  1417							;Pointers for memory Management
     11  1417							;Allocated block are not chained but can be followed for all memory by the associated length
     12  1417							; Mem block format is
     13  1417							;	 0-1   pointer to next block for free blocks
     14  1417							;	 0-1   for allocated blocks
     15  1417							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  1417							;	   1   refrence counter ... lol only up to 256 but it is something
     17  1417							;	 2-3   length constant for exevy type of memory block
     18  1417							; Memory is recombined as it is released
     19  1417							; The memory manager is not interupted durring allocation
     20  1417							; or freeing of memory
     21  1417							; Memory is allocated from the highest memory address towards
     22  1417							; the lowest memory address. meeting the Basic program end.
     23  1417							;====================================================
     24  1417							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  1417							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  1417							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  1417							;=====================================================
     28  1417				   MemInit
     29  1417		       a9 38		      lda	#FreeMemStart&$FF
     30  1419		       8d 2e 2c 	      sta	ProgramStart
     31  141c		       8d 30 2c 	      sta	ProgramEnd
     32  141f		       a9 2c		      lda	#FreeMemStart>>8
     33  1421		       8d 2f 2c 	      sta	ProgramStart+1
     34  1424		       8d 31 2c 	      sta	ProgramEnd+1
     35  1427
     36  1427		       20 31 14 	      jsr	GetSizes
     37  142a		       20 3c 14 	      jsr	MemFree
     38  142d		       20 54 14 	      jsr	MemUsed
     39  1430				   MemInitEnd
     40  1430		       60		      rts
     41  1431
     42  1431
     43  1431							;
     44  1431							;=====================================================
     45  1431							; This function might go away eventually, but was
     46  1431							; added to provide data for other pieces of code.
     47  1431							; It has some ties to the operating environment that
     48  1431							; will need to be customized for the target system.
     49  1431							;
     50  1431				   GetSizes
     51  1431							;
     52  1431							; Here is machine specific code to get the highest
     53  1431							; memory location that can be used by BASIC.
     54  1431							;
     55  1431				  -	      if	ProgramStart < $2000
     56  1431				  -	      lda	#$ff
     57  1431				  -	      sta	HighMem	;$13ff for KIM-1
     58  1431				  -	      sta	MemFreeList
     59  1431				  -	      lda	#$DE	;#$13
     60  1431				  -	      sta	HighMem+1
     61  1431				  -	      sta	MemFreeList+1
     62  1431					      else
     63  1431		       a9 ff		      lda	#$ff
     64  1433		       8d 32 2c 	      sta	HighMem	;$CFFF otherwise
     65  1436		       a9 cf		      lda	#$cf
     66  1438		       8d 33 2c 	      sta	HighMem+1
     67  143b					      endif
     68  143b		       60		      rts
     69  143c							;
     70  143c							; This computes the available memory remaining.
     71  143c							;
     72  143c				   MemFree
     73  143c		       38		      sec
     74  143d		       ad 32 2c 	      lda	HighMem
     75  1440		       ed 30 2c 	      sbc	ProgramEnd
     76  1443		       8d 36 2c 	      sta	FreeMem
     77  1446		       85 52		      sta	R0
     78  1448		       ad 33 2c 	      lda	HighMem+1
     79  144b		       ed 31 2c 	      sbc	ProgramEnd+1
     80  144e		       8d 37 2c 	      sta	FreeMem+1
     81  1451		       85 53		      sta	R0+1
     82  1453		       60		      rts
     83  1454							;
     84  1454							; This computes the size of the current user program.
     85  1454							;
     86  1454				   MemUsed
     87  1454		       38		      sec
     88  1455		       ad 30 2c 	      lda	ProgramEnd
     89  1458		       ed 2e 2c 	      sbc	ProgramStart
     90  145b		       8d 34 2c 	      sta	UsedMem
     91  145e		       85 52		      sta	R0
     92  1460		       ad 31 2c 	      lda	ProgramEnd+1
     93  1463		       ed 2f 2c 	      sbc	ProgramStart+1
     94  1466		       8d 35 2c 	      sta	UsedMem+1
     95  1469		       85 53		      sta	R0+1
     96  146b							;
     97  146b		       60		      rts
     98  146c
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  146c					      include	"gosub.asm"
      1  146c					      seg	Code
      2  146c
      3  146c							; Gosub and return related functions
      4  146c							;==========================================================
      5  146c							; Push the current math stack frame onto the gosub stack
      6  146c				   iPushMathStack
      7  146c		       98		      tya
      8  146d		       48		      pha
      9  146e		       a4 4d		      ldy	GOSUBSTACKPTR
     10  1470		       a5 4a		      lda	MATHSTACKPTR
     11  1472		       91 4b		      sta	(GOSUBSTACK),y
     12  1474		       a9 00		      lda	#0
     13  1476		       c8		      iny
     14  1477		       91 4b		      sta	(GOSUBSTACK),y
     15  1479		       c8		      iny
     16  147a		       91 4b		      sta	(GOSUBSTACK),y
     17  147c		       c8		      iny
     18  147d		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  147f		       91 4b		      sta	(GOSUBSTACK),y
     20  1481		       c8		      iny
     21  1482		       84 4d		      sty	GOSUBSTACKPTR
     22  1484		       68		      pla
     23  1485		       a8		      tay
     24  1486		       4c c2 02 	      jmp	NextIL
     25  1489							;
     26  1489							;==========================================================
     27  1489							; Increment parameter count. Assume Stack frame is top of stack
     28  1489				   iIncParmCount
     29  1489		       98		      tya
     30  148a		       48		      pha
     31  148b		       a4 4d		      ldy	GOSUBSTACKPTR
     32  148d		       88		      dey
     33  148e		       88		      dey
     34  148f		       88		      dey
     35  1490		       b1 4b		      lda	(GOSUBSTACK),y
     36  1492		       aa		      tax
     37  1493		       e8		      inx
     38  1494		       8a		      txa
     39  1495		       91 4b		      sta	(GOSUBSTACK),y
     40  1497		       68		      pla
     41  1498		       a8		      tay
     42  1499		       4c c2 02 	      jmp	NextIL
     43  149c							;
     44  149c							;==========================================================
     45  149c							;Restore the math stack frame
     46  149c		       20 a2 14    iPopMathStack jsr	PopMathStackNow
     47  149f		       4c c2 02 	      jmp	NextIL
     48  14a2
     49  14a2				   PopMathStackNow
     50  14a2		       98		      tya
     51  14a3		       48		      pha
     52  14a4
     53  14a4		       a4 4d		      ldy	GOSUBSTACKPTR
     54  14a6		       88		      dey
     55  14a7		       b1 4b		      lda	(GOSUBSTACK),y
     56  14a9		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  14ab		       d0 09		      bne	iPopMathStackNoFrame
     58  14ad		       88		      dey
     59  14ae		       88		      dey
     60  14af		       88		      dey
     61  14b0		       b1 4b		      lda	(GOSUBSTACK),y
     62  14b2		       85 4a		      sta	MATHSTACKPTR
     63  14b4		       84 4d		      sty	GOSUBSTACKPTR
     64  14b6
     65  14b6				   iPopMathStackNoFrame
     66  14b6
     67  14b6		       68		      pla
     68  14b7		       a8		      tay
     69  14b8		       60		      rts
     70  14b9
     71  14b9
     72  14b9							;==========================================================
     73  14b9							; Push the current math stack information onto the gosub stack
     74  14b9				   iSaveMathStack
     75  14b9		       98		      tya
     76  14ba		       48		      pha
     77  14bb		       a4 4d		      ldy	GOSUBSTACKPTR
     78  14bd		       a5 4a		      lda	MATHSTACKPTR
     79  14bf		       91 4b		      sta	(GOSUBSTACK),y
     80  14c1		       a5 48		      lda	MATHSTACK
     81  14c3		       c8		      iny
     82  14c4
     83  14c4		       91 4b		      sta	(GOSUBSTACK),y
     84  14c6		       c8		      iny
     85  14c7
     86  14c7		       a5 49		      lda	MATHSTACK+1
     87  14c9		       91 4b		      sta	(GOSUBSTACK),y
     88  14cb		       c8		      iny
     89  14cc
     90  14cc		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  14ce		       91 4b		      sta	(GOSUBSTACK),y
     92  14d0		       c8		      iny
     93  14d1
     94  14d1		       84 4d		      sty	GOSUBSTACKPTR
     95  14d3		       68		      pla
     96  14d4		       a8		      tay
     97  14d5		       4c c2 02 	      jmp	NextIL
     98  14d8							;
     99  14d8							;==========================================================
    100  14d8							;Restore the math stack information from the gosub stack
    101  14d8				   iRestoreMathStack
    102  14d8		       98		      tya
    103  14d9		       48		      pha
    104  14da
    105  14da		       a5 4a		      lda	MATHSTACKPTR
    106  14dc		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  14de
    108  14de		       a4 4d		      ldy	GOSUBSTACKPTR
    109  14e0		       88		      dey
    110  14e1		       b1 4b		      lda	(GOSUBSTACK),y
    111  14e3		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  14e5		       d0 16		      bne	iPopMathStack_Err
    113  14e7		       88		      dey
    114  14e8		       b1 4b		      lda	(GOSUBSTACK),y
    115  14ea		       85 49		      sta	MATHSTACK+1
    116  14ec		       88		      dey
    117  14ed		       b1 4b		      lda	(GOSUBSTACK),y
    118  14ef		       85 48		      sta	MATHSTACK
    119  14f1		       88		      dey
    120  14f2		       b1 4b		      lda	(GOSUBSTACK),y
    121  14f4		       85 4a		      sta	MATHSTACKPTR
    122  14f6		       84 4d		      sty	GOSUBSTACKPTR
    123  14f8		       68		      pla
    124  14f9		       a8		      tay
    125  14fa		       4c c2 02 	      jmp	NextIL
    126  14fd
    127  14fd				   iPopMathStack_Err
    128  14fd		       a9 00		      lda	#0
    129  14ff		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  1501		       4c 13 06 	      jmp	iErr2
    131  1504							;=========================================
    132  1504							; For functions and tasks the variable address of # means
    133  1504							; a passed parameter so #[0] is the first parameter etc
    134  1504							; will try for a better way later
    135  1504
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  1504					      include	"tasks.asm"
      1  1504							;=====================================================
      2  1504							; Tiny Basic IL task management
      3  1504							; Data required by task management
      4  1504							; currently each context is about 30 bytes and is swapped
      5  1504							; into and out of page zero on each task switch....
      6  1504							; LOL yes it is slow, but works for this iteration.
      7  1504							;
      8  1504
      9  1504					      Seg	Code
     10  1504							;=====================================================
     11  1504							; Sets the pointers to the math,IL and gosub stacks
     12  1504							; Creates the initial Context for each task slot
     13  1504				   taskSetStacks
     14  1504		       a9 d5		      lda	#mathStack&$FF
     15  1506		       85 48		      sta	MATHSTACK
     16  1508		       a9 23		      lda	#mathStack>>8
     17  150a		       85 49		      sta	MATHSTACK+1
     18  150c
     19  150c		       a9 65		      lda	#ilStack&$ff
     20  150e		       85 45		      sta	ILSTACK
     21  1510		       a9 25		      lda	#ilStack>>8
     22  1512		       85 46		      sta	ILSTACK+1
     23  1514
     24  1514		       a9 f5		      lda	#gosubStack&$FF
     25  1516		       85 4b		      sta	GOSUBSTACK
     26  1518		       a9 26		      lda	#gosubStack>>8
     27  151a		       85 4c		      sta	GOSUBSTACK+1
     28  151c
     29  151c		       a9 75		      lda	#variableStack&$FF
     30  151e		       85 41		      sta	VARIABLES
     31  1520		       a9 29		      lda	#variableStack>>8
     32  1522		       85 42		      sta	VARIABLES+1
     33  1524		       a2 0a		      ldx	#TASKCOUNT
     34  1526		       a0 00		      ldy	#0
     35  1528		       20 b3 17 	      jsr	ContextSave
     36  152b
     37  152b		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  152d		       b0 3a		      bcs	taskSetDone
     39  152f
     40  152f		       a5 4b		      lda	GOSUBSTACK
     41  1531		       18		      clc
     42  1532		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  1534		       85 4b		      sta	GOSUBSTACK
     44  1536		       a5 4c		      lda	GOSUBSTACK+1
     45  1538		       69 00		      adc	#0
     46  153a		       85 4c		      sta	GOSUBSTACK+1
     47  153c
     48  153c		       a5 45		      lda	ILSTACK	; must be less than 256
     49  153e		       18		      clc
     50  153f		       69 28		      adc	#ILSTACKSIZE*2
     51  1541		       85 45		      sta	ILSTACK
     52  1543		       a5 46		      lda	ILSTACK+1
     53  1545		       69 00		      adc	#0
     54  1547		       85 46		      sta	ILSTACK+1
     55  1549
     56  1549		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  154b		       18		      clc
     58  154c		       69 28		      adc	#MATHSTACKSIZE*2
     59  154e		       85 48		      sta	MATHSTACK
     60  1550		       a5 49		      lda	MATHSTACK+1
     61  1552		       69 00		      adc	#0
     62  1554		       85 49		      sta	MATHSTACK+1
     63  1556
     64  1556		       a5 41		      lda	VARIABLES	; must be less than 256
     65  1558		       18		      clc
     66  1559		       69 36		      adc	#VARIABLESSIZE*2
     67  155b		       85 41		      sta	VARIABLES
     68  155d		       a5 42		      lda	VARIABLES+1
     69  155f		       69 00		      adc	#0
     70  1561		       85 42		      sta	VARIABLES+1
     71  1563
     72  1563		       20 b3 17 	      jsr	ContextSave
     73  1566		       4c 2b 15 	      jmp	taskSetLoop
     74  1569
     75  1569				   taskSetDone
     76  1569		       a0 00		      ldy	#0	; reload the main loop context
     77  156b		       20 c2 17 	      jsr	ContextLoad
     78  156e		       60		      rts
     79  156f							;
     80  156f							;=====================================================
     81  156f							; In some error cases the math stacks may be left pointing to the wrong stack
     82  156f							; This function will reset those stack addresses but not the actual pointer
     83  156f				   taskResetStacks
     84  156f		       a0 00		      ldy	#0
     85  1571		       20 c2 17 	      jsr	ContextLoad
     86  1574		       4c 04 15 	      jmp	taskSetStacks
     87  1577							;
     88  1577							;=====================================================
     89  1577							; Clear all task entries and task stacks
     90  1577		       98	   taskReset  tya		; Save Y
     91  1578		       48		      pha
     92  1579		       a9 01		      lda	#1
     93  157b		       8d d4 23 	      sta	taskCounter	; Set number of active tasks to 1
     94  157e		       ac d5 22 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  1581		       c0 00		      cpy	#0	; check if we are the main context
     96  1583		       f0 08		      beq	taskResetCont	; if we are just continue
     97  1585
     98  1585		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  1587		       8c d5 22 	      sty	taskPtr
    100  158a		       20 c2 17 	      jsr	ContextLoad	; load the System Task context
    101  158d				   taskResetCont
    102  158d		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  158f
    104  158f				   taskResetLoop
    105  158f		       a9 00		      lda	#TASKINACTIVE
    106  1591		       99 d6 22 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  1594		       18		      clc
    108  1595		       98		      tya
    109  1596		       69 19		      adc	#CONTEXTLEN+1
    110  1598		       a8		      tay
    111  1599		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  159b		       90 f2		      bcc	taskResetLoop	; Go for more
    113  159d
    114  159d				   taskResetComplete
    115  159d
    116  159d		       68		      pla		; Restore y
    117  159e		       a8		      tay
    118  159f		       60		      rts
    119  15a0
    120  15a0							;
    121  15a0							;======================================================
    122  15a0							; iTaskSwitch	 switch to new task if not interrupt and
    123  15a0							;		 count is exceded for task time slice gets here
    124  15a0							;		 when time slice has reached zero
    125  15a0							;
    126  15a0		       98	   iTaskSwitch tya
    127  15a1		       48		      pha
    128  15a2
    129  15a2		       ad d2 23 	      lda	taskResetValue	; Always reset the counter value
    130  15a5		       8d d0 23 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  15a8		       ce d1 23 	      dec	taskCurrentCycles+1	; dec high order byte
    132  15ab		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  15ad
    134  15ad		       ad d3 23 	      lda	taskResetValue+1
    135  15b0		       8d d1 23 	      sta	taskCurrentCycles+1
    136  15b3
    137  15b3		       ad d2 22 	      lda	IRQPending	; Skip this if we are processing an irq
    138  15b6		       0d 2c 2c 	      ora	taskIOPending	; If set then don't switch
    139  15b9		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  15bb
    141  15bb		       ad d4 23    iTaskMain  lda	taskCounter	; Number of tasks
    142  15be		       c9 01		      cmp	#1	; if there is only one task must be main
    143  15c0		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  15c2
    145  15c2		       ac d5 22 	      ldy	taskPtr	; check if we have not just ended some other task
    146  15c5		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  15c7		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  15c9							;
    149  15c9							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  15c9							;
    151  15c9				   itasknext
    152  15c9		       ac d5 22 	      ldy	taskPtr
    153  15cc		       20 b3 17 	      jsr	ContextSave	; Save the current context, y points to next context
    154  15cf				   itaskLoop
    155  15cf		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  15d1		       90 04		      bcc	iTaskNextChk
    157  15d3
    158  15d3		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  15d5		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  15d7
    161  15d7				   iTaskNextChk
    162  15d7		       b9 d6 22 	      lda	taskTable,y	; there is always at least one entry in table
    163  15da		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  15dc		       18	   iTaskNext  clc
    165  15dd		       98		      tya
    166  15de		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  15e0		       a8		      tay
    168  15e1		       4c cf 15 	      jmp	itaskLoop	; Check for busy entry
    169  15e4
    170  15e4		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  15e6		       59 d6 22 	      eor	taskTable,y	; Check for anything waiting io
    172  15e9		       d0 f1		      bne	iTaskNext
    173  15eb		       20 c2 17 	      jsr	ContextLoad	; load the next context
    174  15ee		       8c d5 22 	      sty	taskPtr	; update the task pointer
    175  15f1
    176  15f1				   iTaskSwitchDone
    177  15f1		       68		      pla
    178  15f2		       a8		      tay
    179  15f3		       60		      rts
    180  15f4							;
    181  15f4							;================================================================
    182  15f4							; Task Set task number to line number to start
    183  15f4							; Task Table structure:
    184  15f4							;    byte 0	-   Active inactive
    185  15f4							;    byte 1-2	-   Basic code line pointer
    186  15f4							;    byte 3	-   Offset on current line
    187  15f4		       98	   iTaskSet   tya		;preserve Y
    188  15f5		       48		      pha		; push a
    189  15f6
    190  15f6		       20 53 1b 	      jsr	popR0	; Get the line number to be saved
    191  15f9
    192  15f9		       ac d5 22 	      ldy	taskPtr	; find out where we are
    193  15fc		       20 b3 17 	      jsr	ContextSave	; Save the current context
    194  15ff
    195  15ff							;Find the pointer to the line we need to start at
    196  15ff		       20 1b 19 	      jsr	findLine	; Get the offset of the line to start task at
    197  1602		       f0 0b		      beq	iTaskCont
    198  1604
    199  1604		       ac d5 22 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  1607		       20 c2 17 	      jsr	ContextLoad
    201  160a
    202  160a		       68		      pla		; pop a - exit
    203  160b		       a8		      tay
    204  160c		       4c 1a 0d 	      jmp	iSetIrqErr	; Bad line number provided
    205  160f
    206  160f				   iTaskCont
    207  160f		       20 85 17 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  1612		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  1614
    210  1614		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  1616		       99 d6 22 	      sta	taskTable,y	; new task as active
    212  1619
    213  1619		       a5 4f		      lda	CURPTR
    214  161b		       48		      pha		; push a
    215  161c		       a5 50		      lda	CURPTR+1
    216  161e		       48		      pha		; push a
    217  161f
    218  161f		       20 c2 17 	      jsr	ContextLoad	; load the context of the new task
    219  1622
    220  1622		       68		      pla		; pop a
    221  1623		       85 50		      sta	CURPTR+1
    222  1625		       68		      pla		; pop a
    223  1626		       85 4f		      sta	CURPTR
    224  1628		       a9 03		      lda	#3	; Offset to first instruction
    225  162a		       85 51		      sta	CUROFF
    226  162c
    227  162c		       a9 00		      lda	#0
    228  162e		       85 47		      sta	ILSTACKPTR
    229  1630		       85 4a		      sta	MATHSTACKPTR
    230  1632		       85 4d		      sta	GOSUBSTACKPTR
    231  1634		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  1636		       85 4e		      sta	MESSAGEPTR
    233  1638
    234  1638		       20 17 09 	      jsr	subVINIT	; Clear the variables
    235  163b
    236  163b		       a9 ea		      lda	#STMT&$FF
    237  163d		       85 43		      sta	ILPC
    238  163f		       a9 1e		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  1641		       85 44		      sta	ILPC+1
    240  1643
    241  1643		       98		      tya		; Save the new context offset to return to user
    242  1644		       48		      pha		; push a
    243  1645
    244  1645		       20 b3 17    itaskSetSave jsr	ContextSave	; save the updated context
    245  1648		       ee d4 23 	      inc	taskCounter	; Update the number of Tasks running
    246  164b
    247  164b		       ac d5 22 	      ldy	taskPtr
    248  164e		       20 c2 17 	      jsr	ContextLoad	; restore the original context
    249  1651
    250  1651		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  1653		       85 53		      sta	R0+1
    252  1655		       68		      pla		; Get the task pid we stored				 ; pop a
    253  1656		       85 52		      sta	R0	; Get the table entry value
    254  1658
    255  1658		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  1659		       a8		      tay
    257  165a
    258  165a		       4c fe 06 	      jmp	pushR0nextIl	; Push R0 and continue
    259  165d				   iTaskNoEmpty
    260  165d		       ac d5 22 	      ldy	taskPtr
    261  1660		       20 c2 17 	      jsr	ContextLoad
    262  1663
    263  1663		       68		      pla		; pop a    -- exit
    264  1664		       a8		      tay
    265  1665
    266  1665		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  1667		       a9 00		      lda	#0
    268  1669		       4c 13 06 	      jmp	iErr2
    269  166c							;
    270  166c							;===============================================================
    271  166c							; Run the task whos PID is on the stack, preserve the stack
    272  166c							;
    273  166c				   iTaskEnable
    274  166c		       98		      tya
    275  166d		       48		      pha
    276  166e		       20 6b 1b 	      jsr	popR1
    277  1671		       20 39 1b 	      jsr	pushR1
    278  1674		       20 b9 18 	      jsr	ipc_getcontext	; get context pointer into mq
    279  1677		       a0 00		      ldy	#0
    280  1679		       b1 56		      lda	(MQ),y
    281  167b		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  167d		       09 80		      ora	#TASKACTIVE
    283  167f		       91 56		      sta	(MQ),y
    284  1681		       68		      pla
    285  1682		       a8		      tay
    286  1683		       4c c2 02 	      jmp	NextIL
    287  1686
    288  1686							;
    289  1686							;===============================================================
    290  1686							; Suspend the task whos PID  is on the stack, preserve the stack
    291  1686							;
    292  1686				   iTaskSuspend
    293  1686		       98		      tya
    294  1687		       48		      pha
    295  1688		       20 6b 1b 	      jsr	popR1
    296  168b		       20 39 1b 	      jsr	pushR1
    297  168e		       20 b9 18 	      jsr	ipc_getcontext	; get context pointer into mq
    298  1691		       a0 00		      ldy	#0
    299  1693		       b1 56		      lda	(MQ),y
    300  1695		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  1697		       09 80		      ora	#TASKACTIVE
    302  1699		       68		      pla
    303  169a		       a8		      tay
    304  169b		       4c c2 02 	      jmp	NextIL
    305  169e
    306  169e							;================================================================
    307  169e							; Returns task Status
    308  169e				   iTaskStat
    309  169e		       98		      tya
    310  169f		       48		      pha
    311  16a0		       20 b2 16 	      jsr	iTaskValid	; returns pointer to task entry
    312  16a3		       b9 d6 22 	      lda	taskTable,y
    313  16a6		       f0 05		      beq	iTaskStatExit
    314  16a8		       68		      pla
    315  16a9		       a8		      tay
    316  16aa		       4c d6 0c 	      jmp	iTruth
    317  16ad				   iTaskStatExit
    318  16ad		       68		      pla
    319  16ae		       a8		      tay
    320  16af		       4c df 0c 	      jmp	iFalse
    321  16b2
    322  16b2							;
    323  16b2							;================================================================
    324  16b2							; Validate the task number on top of the stack
    325  16b2							; on exit y points to the requested task entry
    326  16b2							;
    327  16b2		       20 53 1b    iTaskValid jsr	popR0	; get result of the multiply
    328  16b5		       a5 53		      lda	R0+1
    329  16b7		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  16b9		       a5 52		      lda	R0
    331  16bb		       c9 fa		      cmp	#TASKTABLELEN
    332  16bd		       90 09		      bcc	iTaskIsValid
    333  16bf
    334  16bf		       68	   iTaskValidErr pla		;remove return address
    335  16c0		       68		      pla
    336  16c1		       a2 10		      ldx	#ERR_INVALID_PID
    337  16c3		       a9 00		      lda	#0
    338  16c5		       4c 13 06 	      jmp	iErr2
    339  16c8
    340  16c8		       a8	   iTaskIsValid tay
    341  16c9		       60		      rts
    342  16ca							;
    343  16ca							;================================================================
    344  16ca							; Kill a running task, do nothing if already stopped
    345  16ca		       20 b2 16    iTaskKill  jsr	iTaskValid
    346  16cd		       a9 00		      lda	#0
    347  16cf		       99 d6 22 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  16d2							;
    349  16d2							;================================================================
    350  16d2							;Skip to next task
    351  16d2				   iNTask
    352  16d2		       a9 01		      lda	#1
    353  16d4		       8d d0 23 	      sta	taskCurrentCycles
    354  16d7		       8d d1 23 	      sta	taskCurrentCycles+1
    355  16da		       4c c2 02 	      jmp	NextIL
    356  16dd							;
    357  16dd							;=======================================================
    358  16dd							; Wait for a task to complete
    359  16dd				   iWTASK
    360  16dd		       20 d6 18 	      jsr	getILByte
    361  16e0		       8d 2a 2c 	      sta	offset
    362  16e3							;
    363  16e3		       20 b9 1a 	      jsr	saveIL	;in case of failure
    364  16e6
    365  16e6		       20 b2 16 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  16e9		       b9 d6 22 	      lda	taskTable,y
    367  16ec		       d0 03		      bne	iWTASKWAIT
    368  16ee				   iWTASKEXITED
    369  16ee		       4c c2 02 	      jmp	NextIL
    370  16f1				   iWTASKWAIT
    371  16f1		       20 cf 1a 	      jsr	pushR0	; Push R0 back onto the stack
    372  16f4		       a9 01		      lda	#1
    373  16f6		       8d d0 23 	      sta	taskCurrentCycles	; Give up the cycles
    374  16f9		       8d d1 23 	      sta	taskCurrentCycles+1
    375  16fc		       20 c4 1a 	      jsr	restoreIL
    376  16ff		       4c 3a 0b 	      jmp	tstBranch
    377  1702							;
    378  1702							;=======================================================
    379  1702							; Set task io lock
    380  1702		       ee 2c 2c    iStartIO   inc	taskIOPending
    381  1705		       4c c2 02 	      jmp	NextIL
    382  1708							;
    383  1708							;=======================================================
    384  1708							; Release the io lock
    385  1708		       ad 2c 2c    iEndIO     lda	taskIOPending
    386  170b		       f0 03		      beq	iEndIOExit
    387  170d		       ce 2c 2c 	      dec	taskIOPending
    388  1710		       4c c2 02    iEndIOExit jmp	NextIL
    389  1713							;
    390  1713							;===============================================================
    391  1713							; Return the task PID
    392  1713				   iTASKPID
    393  1713		       a9 00		      lda	#0
    394  1715		       85 53		      sta	R0+1
    395  1717		       ad d5 22 	      lda	taskPtr
    396  171a		       85 52		      sta	R0
    397  171c		       4c fe 06 	      jmp	pushR0nextIl
    398  171f							;
    399  171f							;================================================================
    400  171f							; Terminate a task
    401  171f		       ac d5 22    iETask     ldy	taskPtr
    402  1722		       c0 00		      cpy	#0
    403  1724		       d0 03		      bne	iETaskCont
    404  1726		       4c fc 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  1729				   iETaskCont
    406  1729		       a9 00		      lda	#TASKINACTIVE
    407  172b		       99 d6 22 	      sta	taskTable,y	; mark entry as free
    408  172e		       ce d4 23 	      dec	taskCounter	; reduce the number of active tasks
    409  1731		       a9 01		      lda	#1
    410  1733		       8d d0 23 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  1736		       8d d1 23 	      sta	taskCurrentCycles+1
    412  1739		       20 a0 17 	      jsr	TaskSetExitCode
    413  173c				   iETaskExit
    414  173c		       4c c2 02 	      jmp	NextIL
    415  173f							;================================================================
    416  173f							; make the current tasks math stack equal another tasks stack
    417  173f							; The task to get is stored on the math stack
    418  173f
    419  173f				   iTaskGetMathStack
    420  173f		       20 74 1d 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  1742		       20 b9 18 	      jsr	ipc_getcontext	; MQ now has the context address
    422  1745		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  1747		       b1 56		      lda	(MQ),y
    424  1749		       85 4a		      sta	MATHSTACKPTR
    425  174b		       a0 08		      ldy	#MATHSTACKPOS
    426  174d		       b1 56		      lda	(MQ),y
    427  174f		       85 48		      sta	MATHSTACK
    428  1751		       c8		      iny
    429  1752		       b1 56		      lda	(MQ),y
    430  1754		       85 49		      sta	MATHSTACK+1
    431  1756		       4c c2 02 	      jmp	NextIL
    432  1759							;==================================================================
    433  1759							; Updates the tasks math stack pointer with contents of R2
    434  1759							; PID is on top of the stack
    435  1759				   iTaskPutMathPtr
    436  1759		       20 74 1d 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  175c		       20 b9 18 	      jsr	ipc_getcontext	; MQ now has the context address
    438  175f		       a5 58		      lda	R2
    439  1761		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  1763		       91 56		      sta	(MQ),y
    441  1765		       4c c2 02 	      jmp	NextIL
    442  1768							;
    443  1768							;================================================================
    444  1768							; Set the time slice for each task
    445  1768				   iSLICE
    446  1768		       20 53 1b 	      jsr	popR0
    447  176b		       a5 52		      lda	R0
    448  176d		       8d d2 23 	      sta	taskResetValue
    449  1770		       a5 53		      lda	R0+1
    450  1772		       8d d3 23 	      sta	taskResetValue+1
    451  1775		       d0 0b		      bne	iSliceSet
    452  1777		       ee d3 23 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  177a		       a9 01		      lda	#1
    454  177c		       8d d0 23 	      sta	taskCurrentCycles
    455  177f		       8d d1 23 	      sta	taskCurrentCycles+1
    456  1782				   iSliceSet
    457  1782		       4c c2 02 	      jmp	NextIL
    458  1785							;================================================================
    459  1785							; Find an empty slot in the taskTable
    460  1785							; Return the index in y
    461  1785							; on exit   c set if an empty slot is found
    462  1785							;	     c clear if not found
    463  1785							;================================================================
    464  1785							;
    465  1785		       ad d4 23    TaskEmpty  lda	taskCounter
    466  1788		       c9 0a		      cmp	#TASKCOUNT
    467  178a		       b0 10		      bcs	TaskNoSlot
    468  178c		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  178e				   TaskLoop
    470  178e		       b9 d6 22 	      lda	taskTable,y
    471  1791		       f0 0b		      beq	TaskEmptyFnd
    472  1793		       98		      tya
    473  1794		       18		      clc
    474  1795		       69 19		      adc	#CONTEXTLEN+1
    475  1797		       a8		      tay
    476  1798		       c0 fa		      cpy	#TASKTABLELEN
    477  179a		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  179c				   TaskNoSlot
    479  179c		       18		      clc
    480  179d		       60		      rts
    481  179e				   TaskEmptyFnd
    482  179e		       38		      sec
    483  179f		       60		      rts
    484  17a0							;====================================================
    485  17a0							; Set the task exit code called from the return command
    486  17a0							; on entry stack top hold exit value
    487  17a0				   TaskSetExitCode
    488  17a0		       98		      tya
    489  17a1		       48		      pha
    490  17a2		       20 53 1b 	      jsr	popR0
    491  17a5		       a0 19		      ldy	#TASKEXITCODE
    492  17a7		       a5 52		      lda	R0
    493  17a9		       91 41		      sta	(VARIABLES),y
    494  17ab		       c8		      iny
    495  17ac		       a5 53		      lda	R0+1
    496  17ae		       91 41		      sta	(VARIABLES),y
    497  17b0		       68		      pla
    498  17b1		       98		      tya
    499  17b2		       60		      rts
    500  17b3
    501  17b3							;
    502  17b3							;=====================================================
    503  17b3							; Save Context Store the context to the TASK Table
    504  17b3							; on entry y contains the task table entry to save to
    505  17b3							; on exit y points to next task table entry
    506  17b3							;	   x contains the number of bytes copied
    507  17b3		       a2 00	   ContextSave ldx	#0
    508  17b5		       c8		      iny		;inc past the task flags
    509  17b6		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  17b8		       99 d6 22 	      sta	taskTable,y
    511  17bb		       c8		      iny
    512  17bc		       e8		      inx
    513  17bd		       e0 18		      cpx	#CONTEXTLEN
    514  17bf		       90 f5		      bcc	ContextSvLoop
    515  17c1		       60		      rts
    516  17c2							;
    517  17c2							; Load Context transfer context from task table to the Current Context
    518  17c2							; on entry y contains the task table entry to transfer
    519  17c2							; on exit y points to the original task table entry
    520  17c2							;	   x contains the number of byts copied
    521  17c2		       98	   ContextLoad tya
    522  17c3		       48		      pha
    523  17c4		       a2 00		      ldx	#0
    524  17c6		       c8		      iny		;inc past the task flags
    525  17c7		       b9 d6 22    ContextLDLoop lda	taskTable,y
    526  17ca		       95 41		      sta	CONTEXT,x
    527  17cc		       c8		      iny
    528  17cd		       e8		      inx
    529  17ce		       e0 18		      cpx	#CONTEXTLEN
    530  17d0		       90 f5		      bcc	ContextLDLoop
    531  17d2		       68		      pla
    532  17d3		       a8		      tay
    533  17d4		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  17d5					      include	"ipc.asm"
      1  17d5							;======================================================
      2  17d5							; Inter process communications.
      3  17d5							; Tasks may write/read integer messages among
      4  17d5							; them selves.
      5  17d5							; This uses each tasks gosub stack as a message queue
      6  17d5							; Gosub calls start at the highest address and the
      7  17d5							; msg queue starts at the highest address.
      8  17d5							;
      9  17d5							;======================================================
     10  17d5							; ipcs   - Send msg to another task or many tasks
     11  17d5							; on entry  math stack contains the  top PID
     12  17d5							;				      2ND Message value
     13  17d5							; on exit   math stack contain top True-good or False-failed
     14  17d5							;
     15  17d5							; it may not be sent if queue is full
     16  17d5							;
     17  17d5							; a = ipcs(<message-expression>,<task PID-expression>)
     18  17d5							;
     19  17d5				   iIPCS
     20  17d5		       98		      tya
     21  17d6		       48		      pha
     22  17d7		       20 3e 18 	      jsr	ipc_enqueue
     23  17da		       b0 08		      bcs	iIPC_BAD
     24  17dc		       20 66 1d 	      jsr	pushTrue
     25  17df		       68		      pla
     26  17e0		       a8		      tay
     27  17e1		       4c c2 02 	      jmp	NextIL
     28  17e4				   iIPC_BAD
     29  17e4		       68		      pla
     30  17e5		       a8		      tay
     31  17e6		       20 70 1d 	      jsr	pushFalse
     32  17e9		       4c c2 02 	      jmp	NextIL
     33  17ec
     34  17ec							;======================================================
     35  17ec							; ipcr   - Recieve msg from task
     36  17ec							; on exit  the message value is returned from message queue
     37  17ec							;	    message -1	is reserved meaning no entry found
     38  17ec							; The provided variable contains the pid of the sending
     39  17ec							; task. This is optional. This always waits for a message
     40  17ec							; before returning.
     41  17ec							;
     42  17ec							; a = ipcr(<variable name>)
     43  17ec							;
     44  17ec				   iIPCR
     45  17ec		       98		      tya
     46  17ed		       48		      pha
     47  17ee		       20 80 18 	      jsr	ipc_dequeue
     48  17f1		       b0 05		      bcs	iIPCR_Q_Empty
     49  17f3		       68		      pla
     50  17f4		       a8		      tay
     51  17f5		       4c c2 02 	      jmp	NextIL
     52  17f8				   iIPCR_Q_Empty
     53  17f8		       68		      pla
     54  17f9		       a8		      tay
     55  17fa		       20 66 1d 	      jsr	pushTrue	; puts -1 on the stack
     56  17fd		       4c c2 02 	      jmp	NextIL
     57  1800
     58  1800							;=======================================================
     59  1800							; ipcc   - Check if message available
     60  1800							; on exit  Stack contains number of messages
     61  1800							;
     62  1800							; a = ipcc()
     63  1800							;
     64  1800				   iIPCC
     65  1800		       98		      tya
     66  1801		       48		      pha
     67  1802		       20 2b 18 	      jsr	ipc_queue_count
     68  1805		       20 cf 1a 	      jsr	pushR0	; return the count
     69  1808		       68		      pla
     70  1809		       a8		      tay
     71  180a		       4c c2 02 	      jmp	NextIL
     72  180d
     73  180d							;=======================================================
     74  180d							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  180d				   iIPCIO
     76  180d		       98		      tya
     77  180e		       48		      pha
     78  180f		       20 2b 18 	      jsr	ipc_queue_count
     79  1812		       a5 52		      lda	R0
     80  1814		       d0 10		      bne	iIPCIO_No_Halt
     81  1816		       a9 01		      lda	#1
     82  1818		       8d d0 23 	      sta	taskCurrentCycles	; force a task switch
     83  181b		       a9 01		      lda	#TASKWAITIPC
     84  181d		       ac d5 22 	      ldy	taskPtr
     85  1820		       19 d6 22 	      ora	taskTable,y
     86  1823		       99 d6 22 	      sta	taskTable,y
     87  1826
     88  1826				   iIPCIO_No_Halt
     89  1826		       68		      pla
     90  1827		       a8		      tay
     91  1828		       4c c2 02 	      jmp	NextIL
     92  182b							;======================================================
     93  182b							;ipc_queue_count
     94  182b				   ipc_queue_count
     95  182b		       a5 4e		      lda	MESSAGEPTR
     96  182d		       18		      clc
     97  182e		       4a		      lsr		; divide by 4
     98  182f		       4a		      lsr
     99  1830		       85 52		      sta	R0	; store into R0
    100  1832		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1834		       38		      sec
    102  1835		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1837		       85 52		      sta	R0
    104  1839		       a9 00		      lda	#0
    105  183b		       85 53		      sta	R0+1
    106  183d		       60		      rts
    107  183e							;=======================================================
    108  183e							; Support functions for messaging
    109  183e							;
    110  183e							; Enqueue message -> onto PID's MSG Q
    111  183e							; on entry top of stack contains the PID
    112  183e							;	    second contains the Message of the task
    113  183e							; on exit contains c set if failed
    114  183e							;		    c cleared if success
    115  183e							;		    PID's MSG Q PTR points to the message
    116  183e							;
    117  183e				   ipc_enqueue
    118  183e		       20 6b 1b 	      jsr	popR1	; Get the pid
    119  1841		       20 b9 18 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1844
    121  1844		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1846		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1848		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  184a		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  184c		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  184e
    127  184e
    128  184e							; Get the PID'S stack address into R0
    129  184e		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1850		       b1 56		      lda	(MQ),y
    131  1852		       85 52		      sta	R0
    132  1854		       c8		      iny
    133  1855		       b1 56		      lda	(MQ),y
    134  1857		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1859
    136  1859							; Set y to point to the msg q entry
    137  1859		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  185b		       b1 56		      lda	(MQ),y	; Get the index
    139  185d		       a8		      tay		; Set y to queue offset
    140  185e
    141  185e							; enqueue the message
    142  185e		       88		      dey		; First byte to save to
    143  185f		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1861		       91 52		      sta	(R0),y	; Set the entry type
    145  1863
    146  1863		       88		      dey
    147  1864		       ad d5 22 	      lda	taskPtr	; Store the PID into queue
    148  1867		       91 52		      sta	(R0),y
    149  1869		       20 6b 1b 	      jsr	popR1	; Get the actual message value
    150  186c		       20 c7 18 	      jsr	ipc_pushR1	; Store Message value into queue
    151  186f
    152  186f		       98		      tya		; Save the new q ptr
    153  1870		       a0 0e		      ldy	#MSGPTRPOS
    154  1872		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1874		       a0 00		      ldy	#0	; points to context root
    156  1876		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1878		       51 56		      eor	(MQ),y	; Turn off the bit
    158  187a		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  187c		       18		      clc
    160  187d		       60		      rts
    161  187e				   ipc_enq_full
    162  187e		       38		      sec
    163  187f		       60		      rts
    164  1880							;=============================================================
    165  1880							; De-queue for message stack -> local tasks msg q
    166  1880							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1880							;  message into
    168  1880							;  on exit   math stack contains value of message
    169  1880							;				  Variable if provided is pid
    170  1880				   ipc_dequeue
    171  1880		       20 82 1b 	      jsr	popMQ	; Variable address to put PID into
    172  1883
    173  1883		       a4 4e		      ldy	MESSAGEPTR
    174  1885		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1887		       b0 2e		      bcs	ipc_deq_empty
    176  1889		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  188b		       85 52		      sta	R0
    178  188d		       c8		      iny
    179  188e		       b1 4b		      lda	(GOSUBSTACK),y
    180  1890		       85 53		      sta	R0+1
    181  1892		       c8		      iny
    182  1893		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1895		       85 54		      sta	R1
    184  1897		       c8		      iny
    185  1898		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  189a		       c8		      iny
    187  189b		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  189d
    189  189d		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  189f		       d0 16		      bne	ipc_deq_empty
    191  18a1
    192  18a1		       20 cf 1a 	      jsr	pushR0	; place value on stack
    193  18a4
    194  18a4		       a5 56		      lda	MQ
    195  18a6		       05 57		      ora	MQ+1
    196  18a8		       f0 0b		      beq	ipc_deq_done
    197  18aa		       a5 54		      lda	R1
    198  18ac		       a0 00		      ldy	#0
    199  18ae		       91 56		      sta	(MQ),y
    200  18b0		       c8		      iny
    201  18b1		       a9 00		      lda	#0
    202  18b3		       91 56		      sta	(MQ),y
    203  18b5				   ipc_deq_done
    204  18b5		       18		      clc
    205  18b6		       60		      rts
    206  18b7
    207  18b7				   ipc_deq_empty
    208  18b7		       38		      sec
    209  18b8		       60		      rts
    210  18b9
    211  18b9							;=============================================
    212  18b9							;  Get the context address into MQ from R1 with
    213  18b9							;  context/index/pid
    214  18b9				   ipc_getcontext
    215  18b9		       18		      clc		; Get pointer to Task context
    216  18ba		       a9 d6		      lda	#taskTable&$FF	; change ptr to address
    217  18bc		       65 54		      adc	R1
    218  18be		       85 56		      sta	MQ
    219  18c0		       a9 22		      lda	#taskTable>>8
    220  18c2		       65 55		      adc	R1+1
    221  18c4		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  18c6		       60		      rts
    223  18c7							;
    224  18c7							;==============================================
    225  18c7							;Push R1 onto the stack
    226  18c7							;on entry y = next entry
    227  18c7							;R0 points to the stack space
    228  18c7							;on exit y points to next free byte
    229  18c7				   ipc_pushR1
    230  18c7		       88		      dey
    231  18c8		       a5 55		      lda	R1+1	; PID first
    232  18ca		       91 52		      sta	(R0),y
    233  18cc		       88		      dey
    234  18cd		       a5 54		      lda	R1
    235  18cf		       91 52		      sta	(R0),y
    236  18d1		       60		      rts
    237  18d2
    238  18d2
    239  18d2
    240  18d2
    241  18d2
    242  18d2
    243  18d2
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  18d2					      include	"support.asm"
      1  18d2							;
      2  18d2							;=====================================================
      3  18d2							;=====================================================
      4  18d2							;=====================================================
      5  18d2							; This marks the start of support functions used by
      6  18d2							; the IL opcodes.  These are support functions, NOT
      7  18d2							; the IL code.
      8  18d2							;=====================================================
      9  18d2							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  18d2							;=====================================================
     11  18d2					      Seg	Code
     12  18d2							;=====================================================
     13  18d2							; This gets the next two bytes pointed to by ILPC and
     14  18d2							; returns them; X contains LSB, A contains MSB.  ILPC
     15  18d2							; is advanced by two, and Y contains 0 on return.
     16  18d2
     17  18d2							;
     18  18d2		       20 d6 18    getILWord  jsr	getILByte	;LSB
     19  18d5		       aa		      tax
     20  18d6							;
     21  18d6							;=====================================================
     22  18d6							; This gets the next byte pointed to by ILPC and
     23  18d6							; returns it in A.  On return, X is unchanged but Y
     24  18d6							; contains 0.
     25  18d6							;
     26  18d6		       a0 00	   getILByte  ldy	#0
     27  18d8		       b1 43		      lda	(ILPC),y	;get byte
     28  18da		       08		      php		;save status
     29  18db		       e6 43		      inc	ILPC	;inc LSB
     30  18dd		       d0 02		      bne	getILb2	;branch if no overflow
     31  18df		       e6 44		      inc	ILPC+1	;inc MSB
     32  18e1		       28	   getILb2    plp		;restore status
     33  18e2		       60		      rts
     34  18e3							;
     35  18e3							;=====================================================
     36  18e3							; Decrement ILPC by one.
     37  18e3							;
     38  18e3		       a5 43	   decIL      lda	ILPC
     39  18e5		       d0 02		      bne	decIL2
     40  18e7		       c6 44		      dec	ILPC+1
     41  18e9		       c6 43	   decIL2     dec	ILPC
     42  18eb		       60		      rts
     43  18ec							;
     44  18ec							;=====================================================
     45  18ec							; Push the ILPC onto the return stack.  Actually, this
     46  18ec							; pushes the address of ILPC+2 since that's the next
     47  18ec							; address to execute.
     48  18ec							;
     49  18ec		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  18ee		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  18f0		       b0 15		      bcs	pushErr
     52  18f2		       a5 43		      lda	ILPC
     53  18f4		       18		      clc
     54  18f5		       69 02		      adc	#2
     55  18f7		       91 45		      sta	(ILSTACK),y
     56  18f9		       08		      php		;save C bit
     57  18fa		       c8		      iny
     58  18fb		       a5 44		      lda	ILPC+1
     59  18fd		       28		      plp		;restore C
     60  18fe		       69 00		      adc	#0
     61  1900		       91 45		      sta	(ILSTACK),y
     62  1902		       c8		      iny
     63  1903		       84 47		      sty	ILSTACKPTR
     64  1905		       18		      clc
     65  1906		       60		      rts
     66  1907				   pushErr
     67  1907		       38		      sec
     68  1908		       60		      rts
     69  1909							;
     70  1909							;=====================================================
     71  1909							; Pull the top entry from return stack and put into
     72  1909							; ILPC.
     73  1909							;
     74  1909		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  190b		       f0 fa		      beq	pushErr
     76  190d		       88		      dey
     77  190e		       b1 45		      lda	(ILSTACK),y
     78  1910		       85 44		      sta	ILPC+1
     79  1912		       88		      dey
     80  1913		       b1 45		      lda	(ILSTACK),y
     81  1915		       85 43		      sta	ILPC
     82  1917		       84 47		      sty	ILSTACKPTR
     83  1919		       18		      clc
     84  191a		       60		      rts
     85  191b							;
     86  191b							;=====================================================
     87  191b							; This searches for a specific line number that is in
     88  191b							; R0.	There are three possible return conditions:
     89  191b							; Line numbers are now the third byte, the first byte is now **************
     90  191b							; a pointer to the next line, of course no longer that 53 byte
     91  191b							; per line.
     92  191b							;
     93  191b							; Exact match was found:
     94  191b							;    * Z set
     95  191b							;    * CURPTR points to two-byte line number for that
     96  191b							;	line.
     97  191b							;
     98  191b							; Next highest line found:
     99  191b							;    * Z cleared
    100  191b							;    * C set
    101  191b							;    * CURPTR points to two-byte line number for that
    102  191b							;	line.
    103  191b							;
    104  191b							; End of program reached:
    105  191b							;    * Z cleared
    106  191b							;    * C cleared
    107  191b							;    * CURPTR points to first free byte at end of
    108  191b							;	program.  Ie, it has save value as PROGRAMEND.
    109  191b							;
    110  191b							; A, X, and Y are all undefined on return.
    111  191b							;
    112  191b
    113  191b				   findLine
    114  191b		       ad 2e 2c 	      lda	ProgramStart	;Start of program -> CURPTR
    115  191e		       85 4f		      sta	CURPTR
    116  1920		       ad 2f 2c 	      lda	ProgramStart+1
    117  1923		       85 50		      sta	CURPTR+1
    118  1925							;
    119  1925							; At end of code?
    120  1925							;
    121  1925				   iXFER1
    122  1925		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1927		       cd 30 2c 	      cmp	ProgramEnd	; at end of program then stop run
    124  192a		       d0 0b		      bne	xfer2	; not end
    125  192c		       a5 50		      lda	CURPTR+1
    126  192e		       cd 31 2c 	      cmp	ProgramEnd+1
    127  1931		       d0 04		      bne	xfer2	;Not at end
    128  1933							;
    129  1933							; Line not found and the end of the program was
    130  1933							; reached.  Return Z and C both clear.
    131  1933							;
    132  1933		       a9 01		      lda	#1	;clear Z
    133  1935		       18		      clc		;clear C
    134  1936		       60		      rts
    135  1937							;
    136  1937							; Check for an exact line number match
    137  1937							;
    138  1937		       a5 52	   xfer2      lda	R0
    139  1939		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  193b		       d1 4f		      cmp	(CURPTR),y
    141  193d		       d0 08		      bne	xfernotit
    142  193f		       c8		      iny
    143  1940		       a5 53		      lda	R0+1
    144  1942		       d1 4f		      cmp	(CURPTR),y
    145  1944		       d0 01		      bne	xfernotit	; not a matching line number
    146  1946							;
    147  1946							; This is exactly the line we want.
    148  1946							;
    149  1946		       60		      rts		;it matches exactly
    150  1947							;
    151  1947							; See if this line is greater than the one we're
    152  1947							; searching for.
    153  1947							;
    154  1947		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1949		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  194b		       c5 53		      cmp	R0+1
    157  194d		       90 0b		      bcc	xfer3
    158  194f		       d0 07		      bne	xfer4
    159  1951		       88		      dey
    160  1952		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1954		       c5 52		      cmp	R0
    162  1956		       90 02		      bcc	xfer3
    163  1958							;
    164  1958							; This line is greater than the one we want, so
    165  1958							; return Z clear and C set.
    166  1958							;
    167  1958		       38	   xfer4      sec		;We found a line number greater
    168  1959		       60		      rts		;both conditions set
    169  195a							;
    170  195a							; Not the line (or droid) we're looking for.  Move to
    171  195a							; the next line.
    172  195a							;
    173  195a		       20 60 19    xfer3      jsr	FindNextLine
    174  195d		       4c 25 19 	      jmp	iXFER1
    175  1960							;
    176  1960							;=====================================================
    177  1960							; This advances CURPTR to the next line.  If there
    178  1960							; are no more lines, this leaves CURPTR equal to
    179  1960							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1960							; CURPTR is pointing to a valid line on entry.  This
    181  1960							; pointer points to the two-byte line number.
    182  1960							; Update this points to the 1 byte line length  ****************
    183  1960							;
    184  1960				   FindNextLine
    185  1960		       a0 03		      ldy	#3	;skip line number and length byte
    186  1962		       84 51		      sty	CUROFF	;this is the new offset
    187  1964		       a0 00		      ldy	#0
    188  1966		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1968		       18		      clc
    190  1969		       65 4f		      adc	CURPTR
    191  196b		       85 4f		      sta	CURPTR
    192  196d		       a5 50		      lda	CURPTR+1
    193  196f		       69 00		      adc	#0
    194  1971		       85 50		      sta	CURPTR+1
    195  1973		       60	   FindNext4  rts
    196  1974							;
    197  1974							;=====================================================
    198  1974							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1974							; if they are equal, Z clear if not.
    200  1974							;
    201  1974		       a5 4f	   AtEnd      lda	CURPTR
    202  1976		       cd 30 2c 	      cmp	ProgramEnd
    203  1979		       d0 05		      bne	atendexit
    204  197b		       a5 50		      lda	CURPTR+1
    205  197d		       cd 31 2c 	      cmp	ProgramEnd+1
    206  1980		       60	   atendexit  rts
    207  1981							;
    208  1981
    209  1981							;
    210  1981							;=====================================================
    211  1981							; Convert an ASCII string to a number.  On input,
    212  1981							; (CURPTR),Y points to the first digit.  This gets
    213  1981							; digit-by-digit until finding a non-number.  Returns
    214  1981							; Y pointing to the non-digit, and R0 contains the
    215  1981							; number.  This does NOT check for valid ranges, so
    216  1981							; a value like "123456789" will produce something,
    217  1981							; but not what you had expected.
    218  1981							;
    219  1981		       a9 00	   getDecimal lda	#0
    220  1983		       85 52		      sta	R0
    221  1985		       85 53		      sta	R0+1
    222  1987		       85 59		      sta	dpl	;temporary negative flag
    223  1989							;
    224  1989							; See if it's negative...
    225  1989							;
    226  1989							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1989		       b1 4f		      lda	(CURPTR),y
    228  198b		       c9 2d		      cmp	#'-
    229  198d		       d0 02		      bne	getDecLoop
    230  198f		       e6 59		      inc	dpl	;it's negative
    231  1991							;
    232  1991		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1993		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1995		       c9 30		      cmp	#'0
    235  1997		       90 36		      bcc	getDdone
    236  1999		       c9 3a		      cmp	#'9+1
    237  199b		       b0 32		      bcs	getDdone
    238  199d		       38		      sec
    239  199e		       e9 30		      sbc	#'0	;convert to binary
    240  19a0		       48		      pha
    241  19a1							;
    242  19a1							; Now multiply R0 by 10.  Remember that
    243  19a1							; 2*N + 8*N = 10*N.
    244  19a1							;
    245  19a1		       06 52		      asl	R0
    246  19a3		       26 53		      rol	R0+1	;*2
    247  19a5		       a5 52		      lda	R0
    248  19a7		       85 54		      sta	R1
    249  19a9		       a5 53		      lda	R0+1
    250  19ab		       85 55		      sta	R1+1
    251  19ad		       06 52		      asl	R0
    252  19af		       26 53		      rol	R0+1	;*4
    253  19b1		       06 52		      asl	R0
    254  19b3		       26 53		      rol	R0+1	;*8
    255  19b5		       18		      clc		;now add the partial sums...
    256  19b6		       a5 52		      lda	R0	;...to get *10
    257  19b8		       65 54		      adc	R1
    258  19ba		       85 52		      sta	R0
    259  19bc		       a5 53		      lda	R0+1
    260  19be		       65 55		      adc	R1+1
    261  19c0		       85 53		      sta	R0+1
    262  19c2							;
    263  19c2							; Add in the new digit
    264  19c2							;
    265  19c2		       68		      pla
    266  19c3		       18		      clc
    267  19c4		       65 52		      adc	R0
    268  19c6		       85 52		      sta	R0
    269  19c8		       90 02		      bcc	getD2
    270  19ca		       e6 53		      inc	R0+1
    271  19cc							;
    272  19cc							; Move to next character
    273  19cc							;
    274  19cc		       c8	   getD2      iny
    275  19cd		       d0 c2		      bne	getDecLoop
    276  19cf							;
    277  19cf							; All done with digits, so now deal with it being
    278  19cf							; negative.  If zero, then don't check for negative
    279  19cf							; flag.  Ie, -0 is stored as 0.
    280  19cf							;
    281  19cf		       a5 52	   getDdone   lda	R0
    282  19d1		       05 53		      ora	R0+1
    283  19d3		       f0 16		      beq	getDone2	;zero
    284  19d5		       a5 59		      lda	dpl
    285  19d7		       f0 12		      beq	getDone2	;positive
    286  19d9							;
    287  19d9							; Invert all the bits, then add one.
    288  19d9							;
    289  19d9		       a5 52		      lda	R0
    290  19db		       49 ff		      eor	#$ff
    291  19dd		       85 52		      sta	R0
    292  19df		       a5 53		      lda	R0+1
    293  19e1		       49 ff		      eor	#$ff
    294  19e3		       85 53		      sta	R0+1
    295  19e5							;
    296  19e5		       e6 52		      inc	R0
    297  19e7		       d0 02		      bne	getDone2
    298  19e9		       e6 53		      inc	R0+1
    299  19eb				   getDone2
    300  19eb							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  19eb							;lda	  R0
    302  19eb							;sta	  $0010
    303  19eb							;lda	  R0+1
    304  19eb							;sta	  $0011
    305  19eb							;lda	  dpl
    306  19eb							;sta	  $012
    307  19eb
    308  19eb		       60		      rts
    309  19ec
    310  19ec							;=====================================================
    311  19ec							; Gets a line of input into LINBUF.
    312  19ec							;
    313  19ec							; On entry:
    314  19ec							;    A contains the prompt character, or 0 if none.
    315  19ec							;    X = 1 Background read
    316  19ec							;    x = 0 Forground read with wait
    317  19ec							;
    318  19ec							; On exit:
    319  19ec							;    CURPTR points to LINBUF
    320  19ec							;    LINBUF contains the line with 0 at the end.
    321  19ec							;    Y has offset to first non-space character
    322  19ec							;    CURROFF has the same as Y.
    323  19ec							;
    324  19ec		       20 3b 1a    GetLine    jsr	ReadPrompt
    325  19ef		       e0 00		      cpx	#0
    326  19f1		       f0 14		      beq	GetLineRetry
    327  19f3		       ae d5 22 	      ldx	taskPtr
    328  19f6		       bd d6 22 	      lda	taskTable,x
    329  19f9		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  19fb		       d0 3d		      bne	taskWaitingIO
    331  19fd		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  19ff		       9d d6 22 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1a02		       ce 3a 1a 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1a05		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1a07
    336  1a07							;
    337  1a07							; Now read a line and wait for the CR
    338  1a07							;
    339  1a07				   GetLineRetry
    340  1a07		       a9 00		      lda	#0	;Wait for input to complete
    341  1a09		       20 53 1a 	      jsr	ReadLine
    342  1a0c
    343  1a0c							;
    344  1a0c							; Point to the line we just read
    345  1a0c							; Set the current pointer to point to the input line
    346  1a0c							;
    347  1a0c		       a0 00	   ReadComplete ldy	#0
    348  1a0e		       84 51		      sty	CUROFF
    349  1a10		       a2 91		      ldx	#LINBUF&$ff
    350  1a12		       86 4f		      stx	CURPTR
    351  1a14		       a2 2b		      ldx	#LINBUF>>8
    352  1a16		       86 50		      stx	CURPTR+1
    353  1a18							;
    354  1a18							; Output a CR/LF
    355  1a18							;
    356  1a18		       20 0c 1c 	      jsr	CRLF
    357  1a1b							;
    358  1a1b							; If a blank line, prompt again.
    359  1a1b							;
    360  1a1b		       20 03 1c 	      jsr	SkipSpaces
    361  1a1e		       b1 4f		      lda	(CURPTR),y
    362  1a20		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1a22		       20 3e 1a 	      jsr	ReadPromptRetry
    364  1a25		       ae d5 22 	      ldx	taskPtr	;if this task is waiting for IO
    365  1a28		       bd d6 22 	      lda	taskTable,x	;then get out, wait for line to
    366  1a2b		       29 40		      and	#TASKWAITIO	;Complete again
    367  1a2d		       d0 0b		      bne	taskWaitingIO
    368  1a2f		       4c 07 1a 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1a32
    370  1a32				   GetLineDone
    371  1a32		       ae d5 22 	      ldx	taskPtr
    372  1a35		       a9 80		      lda	#TASKACTIVE
    373  1a37		       9d d6 22 	      sta	taskTable,x	;IO is complete
    374  1a3a
    375  1a3a				   taskWaitingIO
    376  1a3a		       60		      rts
    377  1a3b
    378  1a3b							;
    379  1a3b							;=======================================================================
    380  1a3b							; Display the prompt character
    381  1a3b							; On entry
    382  1a3b							;	    A contains the prompt character
    383  1a3b							; On exit
    384  1a3b							;	    The readbuffer index is reset to 0
    385  1a3b							;
    386  1a3b		       8d 18 2c    ReadPrompt sta	promptChar
    387  1a3e
    388  1a3e							;
    389  1a3e							; Prompt
    390  1a3e							;
    391  1a3e
    392  1a3e		       ad 18 2c    ReadPromptRetry lda	promptChar
    393  1a41		       09 00		      ora	#0	;any prompt?
    394  1a43		       f0 08		      beq	getlinenp
    395  1a45		       20 55 1d 	      jsr	VOUTCH
    396  1a48		       a9 20		      lda	#$20
    397  1a4a		       20 55 1d 	      jsr	VOUTCH	;Space after prompt
    398  1a4d							;
    399  1a4d		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1a4f		       8e 15 2c 	      stx	getlinx
    401  1a52		       60		      rts
    402  1a53							;
    403  1a53							;===============================================================
    404  1a53							; This fuction is the driver for the line input
    405  1a53							; on call if a = 0 then it waits for all input
    406  1a53							;	      a = 1 then nowait for input
    407  1a53							; On exit
    408  1a53							;		       c clear if not complete line
    409  1a53							;		       c set if it was a complete line
    410  1a53
    411  1a53				   ReadLine
    412  1a53		       8d 17 2c 	      sta	inputNoWait
    413  1a56		       c9 00		      cmp	#0
    414  1a58		       f0 05		      beq	getline1
    415  1a5a		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1a5d		       f0 2b		      beq	GetLineNoWait
    417  1a5f		       20 58 1d    getline1   jsr	VGETCH
    418  1a62					      if	CTMON65
    419  1a62		       48		      pha
    420  1a63		       20 55 1d 	      jsr	VOUTCH	;echo echo echo
    421  1a66		       68		      pla
    422  1a67					      endif
    423  1a67		       c9 0d		      cmp	#CR
    424  1a69		       f0 15		      beq	getlind	;end of line
    425  1a6b		       c9 08		      cmp	#BS	;backspace?
    426  1a6d		       f0 1d		      beq	getlinebs
    427  1a6f		       ae 15 2c 	      ldx	getlinx
    428  1a72		       9d 91 2b 	      sta	LINBUF,x
    429  1a75		       e8		      inx
    430  1a76		       8e 15 2c 	      stx	getlinx
    431  1a79		       ad 17 2c 	      lda	inputNoWait
    432  1a7c		       f0 e1		      beq	getline1
    433  1a7e		       d0 0a		      bne	GetLineNoWait
    434  1a80							;
    435  1a80							; CR was hit
    436  1a80							;
    437  1a80		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1a82		       ae 15 2c 	      ldx	getlinx
    439  1a85		       9d 91 2b 	      sta	LINBUF,x
    440  1a88
    441  1a88		       38		      sec		; Carry set then cr received
    442  1a89		       60		      rts
    443  1a8a
    444  1a8a				   GetLineNoWait
    445  1a8a		       18		      clc		; Carry clear no end of line
    446  1a8b		       60		      rts
    447  1a8c							;
    448  1a8c							; Backspace was hit
    449  1a8c							;
    450  1a8c		       ae 15 2c    getlinebs  ldx	getlinx
    451  1a8f		       f0 0e		      beq	getlineEOL	;at start of line
    452  1a91		       ca		      dex
    453  1a92		       8e 15 2c 	      stx	getlinx
    454  1a95		       20 82 13    getlinepbs jsr	puts
      0  1a98					      db	27,"[K",0
      1  1a98		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1a9c		       4c 5f 1a 	      jmp	getline1
    457  1a9f		       a9 20	   getlineEOL lda	#SPACE
    458  1aa1		       20 55 1d 	      jsr	VOUTCH
    459  1aa4		       d0 ef		      bne	getlinepbs
    460  1aa6							;
    461  1aa6							;=====================================================
    462  1aa6							; Count the length of the line currently in LINBUF
    463  1aa6							; starting at offset Y.  Returns the length in X.  The
    464  1aa6							; starting offset in Y should point past the ASCII
    465  1aa6							; line number.  Also counts the trailing NULL and two
    466  1aa6							; extra bytes for where the line number will be.
    467  1aa6							; Update must now include leading length byte not the null at end ****************
    468  1aa6							;
    469  1aa6				   getLineLength
    470  1aa6		       a2 00		      ldx	#0	;size
    471  1aa8		       b9 91 2b    getLineL2  lda	LINBUF,y
    472  1aab		       f0 04		      beq	getLineL3
    473  1aad		       c8		      iny
    474  1aae		       e8		      inx
    475  1aaf		       d0 f7		      bne	getLineL2
    476  1ab1		       e8	   getLineL3  inx		;count null at end
    477  1ab2		       e8		      inx		;line number LSB
    478  1ab3		       e8		      inx		;MSB
    479  1ab4		       e8		      inx		;change: count new leading line length
    480  1ab5		       8e 2b 2c 	      stx	lineLength
    481  1ab8		       60		      rts
    482  1ab9							;
    483  1ab9							;=====================================================
    484  1ab9							; Count the length of the line pointed to by CURPTR.
    485  1ab9							; This also counts the line number and the terminating
    486  1ab9							; null.  Ie, this string returns 8:
    487  1ab9							;
    488  1ab9							; <lineLow><lineHi>Hello<null>
    489  1ab9							;
    490  1ab9							; Another way of looking at it: add the return value
    491  1ab9							; to the CURPTR and it'll point to the next line's
    492  1ab9							; line number.  Returns the value in Y.
    493  1ab9							; Update to ject get the leading byte length ********************
    494  1ab9							;
    495  1ab9							;getCURPTRLength
    496  1ab9							;		ldy	CURPTR
    497  1ab9							;		ldy	#3	;change: skip line number and leading length byte
    498  1ab9							;getCLineL2	lda	(CURPTR),y
    499  1ab9							;		beq	getCLineL3
    500  1ab9							;		iny
    501  1ab9							;		bne	getCLineL2
    502  1ab9							;getCLineL3	iny		;count null at end
    503  1ab9							;		rts
    504  1ab9
    505  1ab9							;
    506  1ab9							;=====================================================
    507  1ab9							; This saves ILPC.  This saves to a single save area,
    508  1ab9							; so it can't be called more than once.
    509  1ab9							;
    510  1ab9		       a5 43	   saveIL     lda	ILPC
    511  1abb		       8d 27 2c 	      sta	tempIL
    512  1abe		       a5 44		      lda	ILPC+1
    513  1ac0		       8d 28 2c 	      sta	tempIL+1
    514  1ac3		       60		      rts
    515  1ac4							;
    516  1ac4							;=====================================================
    517  1ac4							; This restores ILPC.
    518  1ac4							;
    519  1ac4		       ad 27 2c    restoreIL  lda	tempIL
    520  1ac7		       85 43		      sta	ILPC
    521  1ac9		       ad 28 2c 	      lda	tempIL+1
    522  1acc		       85 44		      sta	ILPC+1
    523  1ace		       60		      rts
    524  1acf							;
    525  1acf							;=====================================================
    526  1acf							; This pushes R0 onto the stack.
    527  1acf							;
    528  1acf		       8c 1e 2c    pushR0     sty	rtemp1
    529  1ad2		       a4 4a		      ldy	MATHSTACKPTR
    530  1ad4		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1ad6		       b0 34		      bcs	pusherr
    532  1ad8		       a5 52		      lda	R0
    533  1ada		       91 48		      sta	(MATHSTACK),y
    534  1adc		       c8		      iny
    535  1add		       a5 53		      lda	R0+1
    536  1adf		       91 48		      sta	(MATHSTACK),y
    537  1ae1		       c8		      iny
    538  1ae2		       84 4a		      sty	MATHSTACKPTR
    539  1ae4		       ac 1e 2c 	      ldy	rtemp1
    540  1ae7		       18		      clc
    541  1ae8		       60		      rts
    542  1ae9
    543  1ae9							;=====================================================
    544  1ae9							; This pushes curptr basic current line onto the call stack.
    545  1ae9							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1ae9
    547  1ae9				   pushLN
    548  1ae9		       8c 1e 2c 	      sty	rtemp1
    549  1aec		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  1aee		       c5 4d		      cmp	GOSUBSTACKPTR
    551  1af0		       90 1a		      bcc	pusherr	; No error
    552  1af2		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  1af4		       a2 00		      ldx	#0	; Start of bytes to copy
    554  1af6				   pushLoop
    555  1af6		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  1af8		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  1afa		       c8		      iny		; Next destination
    558  1afb		       e8		      inx		; Next Source byte
    559  1afc		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  1afe		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  1b00
    562  1b00		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  1b02		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  1b04		       c8		      iny		; Next entry
    565  1b05
    566  1b05		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  1b07		       ac 1e 2c 	      ldy	rtemp1
    568  1b0a		       18		      clc
    569  1b0b		       60		      rts
    570  1b0c				   pusherr
    571  1b0c		       38		      sec
    572  1b0d		       60		      rts
    573  1b0e							;=====================================================
    574  1b0e							; This pops Top Off gosub call Stack and
    575  1b0e							; places it in CURPTR/CUROFF.
    576  1b0e							; This checks if the type = 1 GOSUB
    577  1b0e							; if not it removes what ever is on the stack
    578  1b0e							; until it finds the next return. Allowing
    579  1b0e							; a return from within a for/next
    580  1b0e		       8c 1e 2c    popLN      sty	rtemp1
    581  1b11		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  1b13		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  1b15
    584  1b15				   popContinue
    585  1b15		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  1b17		       90 18		      bcc	poperr	; Process an error
    587  1b19
    588  1b19		       88		      dey		; Position to read entry type
    589  1b1a		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  1b1c		       c9 01		      cmp	#1	; Type is a gosub entry
    591  1b1e		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  1b20
    593  1b20				   popLoop
    594  1b20		       88		      dey
    595  1b21		       ca		      dex
    596  1b22		       b1 4b		      lda	(GOSUBSTACK),y
    597  1b24		       95 4f		      sta	CURPTR,x
    598  1b26		       e0 00		      cpx	#0
    599  1b28		       d0 f6		      bne	popLoop	; Loop until all moved
    600  1b2a
    601  1b2a
    602  1b2a		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  1b2c		       ac 1e 2c 	      ldy	rtemp1
    604  1b2f		       18		      clc
    605  1b30		       60		      rts
    606  1b31
    607  1b31		       38	   poperr     sec
    608  1b32		       60		      rts
    609  1b33
    610  1b33		       88	   popSkipEntry dey
    611  1b34		       88		      dey
    612  1b35		       88		      dey
    613  1b36		       4c 15 1b 	      jmp	popContinue
    614  1b39
    615  1b39							;
    616  1b39							;=====================================================
    617  1b39							; This pushes R1 onto the stack
    618  1b39							;
    619  1b39		       8c 1e 2c    pushR1     sty	rtemp1
    620  1b3c		       a4 4a		      ldy	MATHSTACKPTR
    621  1b3e		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  1b40		       b0 ef		      bcs	poperr
    623  1b42		       a5 54		      lda	R1
    624  1b44		       91 48		      sta	(MATHSTACK),y
    625  1b46		       c8		      iny
    626  1b47		       a5 55		      lda	R1+1
    627  1b49		       91 48		      sta	(MATHSTACK),y
    628  1b4b		       c8		      iny
    629  1b4c		       84 4a		      sty	MATHSTACKPTR
    630  1b4e		       ac 1e 2c 	      ldy	rtemp1
    631  1b51		       18		      clc
    632  1b52		       60		      rts
    633  1b53							;
    634  1b53							;=====================================================
    635  1b53							; This pops Top Of Stack and places it in R0.
    636  1b53							;
    637  1b53		       8c 1e 2c    popR0      sty	rtemp1
    638  1b56		       a4 4a		      ldy	MATHSTACKPTR
    639  1b58		       f0 d7		      beq	poperr
    640  1b5a		       88		      dey
    641  1b5b		       b1 48		      lda	(MATHSTACK),y
    642  1b5d		       85 53		      sta	R0+1
    643  1b5f		       88		      dey
    644  1b60		       b1 48		      lda	(MATHSTACK),y
    645  1b62		       85 52		      sta	R0
    646  1b64		       84 4a		      sty	MATHSTACKPTR
    647  1b66		       ac 1e 2c 	      ldy	rtemp1
    648  1b69		       18		      clc
    649  1b6a		       60		      rts
    650  1b6b
    651  1b6b							;
    652  1b6b							;=====================================================
    653  1b6b							; This pops TOS and places it in R1.
    654  1b6b							;
    655  1b6b		       8c 1e 2c    popR1      sty	rtemp1
    656  1b6e		       a4 4a		      ldy	MATHSTACKPTR
    657  1b70		       f0 bf		      beq	poperr
    658  1b72		       88		      dey
    659  1b73		       b1 48		      lda	(MATHSTACK),y
    660  1b75		       85 55		      sta	R1+1
    661  1b77		       88		      dey
    662  1b78		       b1 48		      lda	(MATHSTACK),y
    663  1b7a		       85 54		      sta	R1
    664  1b7c		       84 4a		      sty	MATHSTACKPTR
    665  1b7e		       ac 1e 2c 	      ldy	rtemp1
    666  1b81		       60		      rts
    667  1b82							;
    668  1b82							;=====================================================
    669  1b82							; This pops TOS and places it in MQ.
    670  1b82							;
    671  1b82		       8c 1e 2c    popMQ      sty	rtemp1
    672  1b85		       a4 4a		      ldy	MATHSTACKPTR
    673  1b87		       f0 a8		      beq	poperr
    674  1b89		       88		      dey
    675  1b8a		       b1 48		      lda	(MATHSTACK),y
    676  1b8c		       85 57		      sta	MQ+1
    677  1b8e		       88		      dey
    678  1b8f		       b1 48		      lda	(MATHSTACK),y
    679  1b91		       85 56		      sta	MQ
    680  1b93		       84 4a		      sty	MATHSTACKPTR
    681  1b95		       ac 1e 2c 	      ldy	rtemp1
    682  1b98		       60		      rts
    683  1b99							;
    684  1b99							;=====================================================
    685  1b99							; This assists with multiplication and division by
    686  1b99							; looking at R0 and R1 and saving a flag as to what
    687  1b99							; sign the result will be.  Math is always done on
    688  1b99							; positive numbers, so this converts negative numbers
    689  1b99							; into positives.  On exit, R0 and R1 are both
    690  1b99							; positive.  If the signs were different then 'signs'
    691  1b99							; will be non-zero.
    692  1b99							;
    693  1b99		       a9 00	   SaveSigns  lda	#0
    694  1b9b		       8d 1d 2c 	      sta	sign	;assume positive
    695  1b9e		       a5 53		      lda	R0+1	;MSB
    696  1ba0		       10 13		      bpl	SaveSigns1
    697  1ba2		       ee 1d 2c 	      inc	sign	;it's negative
    698  1ba5		       49 ff		      eor	#$ff	;flip bits
    699  1ba7		       85 53		      sta	R0+1
    700  1ba9		       a5 52		      lda	R0
    701  1bab		       49 ff		      eor	#$ff
    702  1bad		       85 52		      sta	R0
    703  1baf		       e6 52		      inc	R0
    704  1bb1		       d0 02		      bne	SaveSigns1
    705  1bb3		       e6 53		      inc	R0+1
    706  1bb5		       a5 55	   SaveSigns1 lda	R1+1
    707  1bb7		       10 1a		      bpl	SaveSigns2
    708  1bb9		       48		      pha
    709  1bba		       ad 1d 2c 	      lda	sign
    710  1bbd		       49 01		      eor	#1
    711  1bbf		       8d 1d 2c 	      sta	sign
    712  1bc2		       68		      pla
    713  1bc3		       49 ff		      eor	#$ff	;flip bits
    714  1bc5		       85 55		      sta	R1+1
    715  1bc7		       a5 54		      lda	R1
    716  1bc9		       49 ff		      eor	#$ff
    717  1bcb		       85 54		      sta	R1
    718  1bcd		       e6 54		      inc	R1
    719  1bcf		       d0 02		      bne	SaveSigns2
    720  1bd1		       e6 55		      inc	R1+1
    721  1bd3		       60	   SaveSigns2 rts
    722  1bd4							;
    723  1bd4							;=====================================================
    724  1bd4							; This looks at the value of 'signs' and will convert
    725  1bd4							; both R0 and R1 to negative if set.
    726  1bd4							;
    727  1bd4				   RestoreSigns
    728  1bd4		       ad 1d 2c 	      lda	sign
    729  1bd7		       f0 28		      beq	restoresigns2
    730  1bd9							;
    731  1bd9		       a5 52		      lda	R0
    732  1bdb		       d0 02		      bne	restoresigns3
    733  1bdd		       c6 53		      dec	R0+1
    734  1bdf				   restoresigns3
    735  1bdf		       c6 52		      dec	R0
    736  1be1		       a5 52		      lda	R0
    737  1be3		       49 ff		      eor	#$ff
    738  1be5		       85 52		      sta	R0
    739  1be7		       a5 53		      lda	R0+1
    740  1be9		       49 ff		      eor	#$ff
    741  1beb		       85 53		      sta	R0+1
    742  1bed							;
    743  1bed		       a5 54		      lda	R1
    744  1bef		       d0 02		      bne	restoresigns4
    745  1bf1		       c6 55		      dec	R1+1
    746  1bf3				   restoresigns4
    747  1bf3		       c6 54		      dec	R1
    748  1bf5		       a5 54		      lda	R1
    749  1bf7		       49 ff		      eor	#$ff
    750  1bf9		       85 54		      sta	R1
    751  1bfb		       a5 55		      lda	R1+1
    752  1bfd		       49 ff		      eor	#$ff
    753  1bff		       85 55		      sta	R1+1
    754  1c01							;
    755  1c01				   restoresigns2
    756  1c01		       60		      rts
    757  1c02							;
    758  1c02							;=====================================================
    759  1c02							; Skip over spaces.  Returns Y with the offset to
    760  1c02							; either the last character in the line, or the first
    761  1c02							; non-space character.
    762  1c02							;
    763  1c02
    764  1c02		       c8	   skipsp2    iny
    765  1c03		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  1c05		       f0 04		      beq	Skip3	;end of line
    767  1c07		       c9 20		      cmp	#SPACE
    768  1c09		       f0 f7		      beq	skipsp2
    769  1c0b		       60	   Skip3      rts
    770  1c0c							;*********************************************************
    771  1c0c							; Output a CR/LF combination to the console.  Preserves
    772  1c0c							; all registers.
    773  1c0c							;
    774  1c0c		       48	   tbcrlf     pha
    775  1c0d		       a9 0d		      lda	#CR
    776  1c0f		       20 55 1d 	      jsr	VOUTCH
    777  1c12		       a9 0a		      lda	#LF
    778  1c14		       20 55 1d 	      jsr	VOUTCH
    779  1c17		       68		      pla
    780  1c18		       60		      rts
    781  1c19							;
    782  1c19							;=====================================================
    783  1c19							; Some logic to print the Line of basic code being executed
    784  1c19		       24 40	   idbgBasic  bit	ILTrace
    785  1c1b		       50 70		      bvc	dbgBasicNone
    786  1c1d		       98		      tya
    787  1c1e		       48		      pha
    788  1c1f		       20 85 1d 	      jsr	SetOutDebug
    789  1c22		       20 a5 13 	      jsr	PrtPrgLine
    790  1c25		       20 0c 1c 	      jsr	CRLF
    791  1c28		       a5 40		      lda	ILTrace
    792  1c2a		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  1c2c		       f0 5a		      beq	dbgBasicDone
    794  1c2e		       20 90 1d 	      jsr	SetInDebug
    795  1c31		       20 82 13 	      jsr	puts
      0  1c34					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1c34		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1c71				   dbgBasicLoop
    798  1c71		       20 58 1d 	      jsr	VGETCH
    799  1c74		       20 0c 1c 	      jsr	CRLF
    800  1c77		       20 48 1d 	      jsr	SetInConsole
    801  1c7a
    802  1c7a		       c9 73		      cmp	#'s	; Quit program
    803  1c7c		       f0 12		      beq	dbgBasicStop
    804  1c7e
    805  1c7e		       c9 64		      cmp	#'d	; Display Variables
    806  1c80		       d0 06		      bne	dbgBasicDone
    807  1c82
    808  1c82		       20 e4 13 	      jsr	PrintAllVars
    809  1c85		       18		      clc
    810  1c86		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1c88
    812  1c88		       20 3b 1d    dbgBasicDone jsr	SetOutConsole
    813  1c8b		       68		      pla
    814  1c8c		       a8		      tay
    815  1c8d		       4c c2 02    dbgBasicNone jmp	NextIL
    816  1c90
    817  1c90				   dbgBasicStop
    818  1c90		       20 3b 1d 	      jsr	SetOutConsole
    819  1c93		       68		      pla
    820  1c94		       a8		      tay
    821  1c95		       4c fc 05 	      jmp	iFIN
    822  1c98							;
    823  1c98							;=====================================================
    824  1c98							; This is some debug logic which displays the current
    825  1c98							; value of the ILPC and the line buffer.
    826  1c98							;
    827  1c98		       24 40	   dbgLine    bit	ILTrace
    828  1c9a		       30 01		      bmi	dbgPrt
    829  1c9c		       60		      rts
    830  1c9d				   dbgPrt
    831  1c9d		       20 85 1d 	      jsr	SetOutDebug
    832  1ca0		       20 82 13 	      jsr	puts
      0  1ca3					      db	"ILPC: ",0
      1  1ca3		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  1caa		       a5 44		      lda	ILPC+1
    835  1cac		       20 65 13 	      jsr	OUTHEX
    836  1caf		       a5 43		      lda	ILPC
    837  1cb1		       20 65 13 	      jsr	OUTHEX
    838  1cb4		       a9 20		      lda	#SPACE
    839  1cb6		       20 55 1d 	      jsr	VOUTCH
    840  1cb9		       a0 00		      ldy	#0
    841  1cbb		       b1 43		      lda	(ILPC),y
    842  1cbd		       20 65 13 	      jsr	OUTHEX
    843  1cc0							;
    844  1cc0							; Display the CURPTR value and offset
    845  1cc0							;
    846  1cc0		       20 82 13 	      jsr	puts
      0  1cc3					      db	", CURPTR: ",0
      1  1cc3		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  1cce		       a5 50		      lda	CURPTR+1
    849  1cd0		       20 65 13 	      jsr	OUTHEX
    850  1cd3		       a5 4f		      lda	CURPTR
    851  1cd5		       20 65 13 	      jsr	OUTHEX
    852  1cd8		       a9 2b		      lda	#'+
    853  1cda		       20 55 1d 	      jsr	VOUTCH
    854  1cdd		       a5 51		      lda	CUROFF
    855  1cdf		       20 65 13 	      jsr	OUTHEX
    856  1ce2							;
    857  1ce2		       20 0c 1c 	      jsr	CRLF
    858  1ce5		       20 3b 1d 	      jsr	SetOutConsole
    859  1ce8		       20 1b 1d 	      jsr	ILChkRange
    860  1ceb		       b0 02		      bcs	dbgLineErr
    861  1ced		       18		      clc
    862  1cee		       60		      rts
    863  1cef
    864  1cef				   dbgLineErr
    865  1cef		       20 85 1d 	      jsr	SetOutDebug
    866  1cf2		       20 82 13 	      jsr	puts
      0  1cf5					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1cf5		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  1d16		       20 3b 1d 	      jsr	SetOutConsole
    869  1d19		       38		      sec
    870  1d1a		       60		      rts
    871  1d1b
    872  1d1b		       a5 44	   ILChkRange lda	ILPC+1
    873  1d1d		       c9 1e		      cmp	#IL>>8
    874  1d1f		       90 18		      bcc	ILBadRange
    875  1d21		       d0 06		      bne	ILChkHigh
    876  1d23
    877  1d23		       a5 43		      lda	ILPC
    878  1d25		       c9 dc		      cmp	#IL&$ff
    879  1d27		       90 10		      bcc	ILBadRange
    880  1d29
    881  1d29		       a5 44	   ILChkHigh  lda	ILPC+1
    882  1d2b		       c9 22		      cmp	#ILEND>>8
    883  1d2d		       90 08		      bcc	ILGoodRange
    884  1d2f		       d0 08		      bne	ILBadRange
    885  1d31
    886  1d31		       a5 43		      lda	ILPC
    887  1d33		       c9 c0		      cmp	#ILEND&$ff
    888  1d35		       b0 02		      bcs	ILBadRange
    889  1d37
    890  1d37		       18	   ILGoodRange clc
    891  1d38		       60		      rts
    892  1d39				   ILBadRange
    893  1d39		       38		      sec
    894  1d3a		       60		      rts
    895  1d3b
    896  1d3b
    897  1d3b							;=====================================================
    898  1d3b							; Set output vector to the console output function
    899  1d3b							;
    900  1d3b				   SetOutConsole
    901  1d3b		       48		      pha
    902  1d3c		       a9 0c		      lda	#OUTCH&$ff
    903  1d3e		       8d 22 2c 	      sta	BOutVec
    904  1d41		       a9 f0		      lda	#OUTCH>>8
    905  1d43		       8d 23 2c 	      sta	BOutVec+1
    906  1d46		       68		      pla
    907  1d47		       60		      rts
    908  1d48
    909  1d48				   SetInConsole
    910  1d48		       48		      pha
    911  1d49		       a9 09		      lda	#GETCH&$ff
    912  1d4b		       8d 24 2c 	      sta	BInVec
    913  1d4e		       a9 f0		      lda	#GETCH>>8
    914  1d50		       8d 25 2c 	      sta	BInVec+1
    915  1d53		       68		      pla
    916  1d54		       60		      rts
    917  1d55
    918  1d55							;=====================================================
    919  1d55							; Jump to the output/input function in BOutVec/BInVec
    920  1d55							;
    921  1d55		       6c 22 2c    VOUTCH     jmp	(BOutVec)
    922  1d58		       6c 24 2c    VGETCH     jmp	(BInVec)
    923  1d5b
    924  1d5b
    925  1d5b							;====================================================
    926  1d5b							;Clear the terminal assume it is ansii or vt100
    927  1d5b							;
    928  1d5b				   iCLEARSCREEN
    929  1d5b		       20 82 13 	      jsr	puts
      0  1d5e					      db	$1b,'[,'2,'J,0
      1  1d5e		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    931  1d63		       4c c2 02 	      jmp	NextIL
    932  1d66
    933  1d66							;====================================================
    934  1d66							; Push true and false onto math stack
    935  1d66				   pushTrue
    936  1d66		       a9 ff		      lda	#$ff
    937  1d68		       85 52	   pushTF     sta	R0
    938  1d6a		       85 53		      sta	R0+1
    939  1d6c		       20 cf 1a 	      jsr	pushR0
    940  1d6f		       60		      rts
    941  1d70		       a9 00	   pushFalse  lda	#0
    942  1d72		       f0 f4		      beq	pushTF
    943  1d74
    944  1d74							;======================================================
    945  1d74							; Copy stack top to R1
    946  1d74				   CopyStackR1
    947  1d74		       98		      tya
    948  1d75		       48		      pha
    949  1d76		       a4 4a		      ldy	MATHSTACKPTR
    950  1d78		       88		      dey
    951  1d79		       b1 48		      lda	(MATHSTACK),y
    952  1d7b		       85 55		      sta	R1+1
    953  1d7d		       88		      dey
    954  1d7e		       b1 48		      lda	(MATHSTACK),y
    955  1d80		       85 54		      sta	R1
    956  1d82		       68		      pla
    957  1d83		       a8		      tay
    958  1d84		       60		      rts
    959  1d85
    960  1d85
    961  1d85							;====================================================
    962  1d85							;Swap the out debug call for standard calls
    963  1d85
    964  1d85				   SetOutDebug
    965  1d85					      if	USEDEBUGPORT
    966  1d85		       a9 a5		      lda	#OUTDEBUG&$ff	; Put the Debug output
    967  1d87		       8d 22 2c 	      sta	BOutVec
    968  1d8a		       a9 1d		      lda	#OUTDEBUG>>8
    969  1d8c		       8d 23 2c 	      sta	BOutVec+1
    970  1d8f					      endif
    971  1d8f		       60		      rts
    972  1d90				   SetInDebug
    973  1d90					      if	USEDEBUGPORT
    974  1d90		       a9 a9		      lda	#INDEBUG&$ff
    975  1d92		       8d 24 2c 	      sta	BInVec
    976  1d95		       a9 1d		      lda	#INDEBUG>>8
    977  1d97		       8d 25 2c 	      sta	BInVec+1
    978  1d9a					      endif
    979  1d9a		       60		      rts
    980  1d9b							;
    981  1d9b							;====================================================
    982  1d9b							; Output to the debug console
    983  1d9b							;     x = high address byte
    984  1d9b							;     y = low address byte
    985  1d9b							;     a = Terminator for string
    986  1d9b				   DebugWrite
    987  1d9b		       20 85 1d 	      jsr	SetOutDebug
    988  1d9e		       20 c7 13 	      jsr	PrtStr
    989  1da1		       20 3b 1d 	      jsr	SetOutConsole
    990  1da4		       60		      rts
    991  1da5
    992  1da5				   OUTDEBUG
    993  1da5		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
    994  1da8		       60		      RTS
    995  1da9
    996  1da9		       ad 20 e0    INDEBUG    lda	DEBUGPORT
    997  1dac		       29 01		      and	#$01
    998  1dae		       f0 f9		      beq	INDEBUG
    999  1db0		       ad 21 e0 	      lda	DEBUGPORT+1
   1000  1db3		       60		      rts
   1001  1db4
   1002  1db4
   1003  1db4
   1004  1db4
   1005  1db4
   1006  1db4
   1007  1db4
   1008  1db4
   1009  1db4
   1010  1db4
   1011  1db4
   1012  1db4
   1013  1db4
   1014  1db4
   1015  1db4
   1016  1db4
   1017  1db4
   1018  1db4
   1019  1db4
------- FILE mytb.asm
   2299  1db4
   2300  1db4					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  1db4					      include	"storage.asm"
      1  1db4							;
      2  1db4							;=====================================================
      3  1db4							;=====================================================
      4  1db4							;=====================================================
      5  1db4							; This file contains the functions for saving and
      6  1db4							; restoring programs from some sort of mass storage
      7  1db4							; device.  This particular version is for using the
      8  1db4							; Corsham Tech SD Card System.
      9  1db4							;=====================================================
     10  1db4							;=====================================================
     11  1db4							;=====================================================
     12  1db4
     13 U22c0					      seg.u	TBData
     14 U22c0		       00	   diskBufLength ds	1
     15 U22c1		       00	   diskBufOffset ds	1
     16 U22c2		       00 00 00 00*DiskFileName ds	14
     17 U22d0
     18  1db4					      SEG	Code
     19  1db4
     20  1db4							;
     21  1db4							;=====================================================
     22  1db4							; Open a file for reading as a program.  The next
     23  1db4							; thing on the line should be the filename.
     24  1db4							;
     25  1db4				   iOPENREAD
     26  1db4					      if	XKIM || CTMON65
     27  1db4		       a4 51		      ldy	CUROFF
     28  1db6		       b1 4f		      lda	(CURPTR),y
     29  1db8		       d0 07		      bne	iOPENfn	;might be filename
     30  1dba							;
     31  1dba							; No filename supplied.
     32  1dba							;
     33  1dba		       a9 00	   iOPENnofn  lda	#0
     34  1dbc		       a2 09		      ldx	#ERR_NO_FILENAME
     35  1dbe		       4c 13 06 	      jmp	iErr2
     36  1dc1							;
     37  1dc1							; Add the offset into the buffer start
     38  1dc1							;
     39  1dc1		       18	   iOPENfn    clc
     40  1dc2		       98		      tya
     41  1dc3		       65 4f		      adc	CURPTR
     42  1dc5		       a8		      tay		;LSB
     43  1dc6		       a5 50		      lda	CURPTR+1
     44  1dc8		       69 00		      adc	#0
     45  1dca		       aa		      tax
     46  1dcb		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  1dce		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1dd0							;
     49  1dd0							; Open failed
     50  1dd0							;
     51  1dd0		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1dd2		       a9 00	   Rdfail2    lda	#0
     53  1dd4		       4c 13 06 	      jmp	iErr2
     54  1dd7							;
     55  1dd7							; Clear counts and offsets so the next read will
     56  1dd7							; cause the file to be read.
     57  1dd7							;
     58  1dd7		       a9 00	   Ropenok    lda	#0
     59  1dd9		       8d c1 22 	      sta	diskBufOffset
     60  1ddc		       8d c0 22 	      sta	diskBufLength
     61  1ddf		       4c c2 02 	      jmp	NextIL
     62  1de2					      endif
     63  1de2
     64  1de2							;
     65  1de2							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1de2							;Remove a file from the disk
     67  1de2				   iRMFILE
     68  1de2					      if	XKIM || CTMON65
     69  1de2		       a4 51		      ldy	CUROFF
     70  1de4		       b1 4f		      lda	(CURPTR),y
     71  1de6		       f0 19		      beq	iRMnofn
     72  1de8							;
     73  1de8		       18		      clc
     74  1de9		       98		      tya
     75  1dea		       65 4f		      adc	CURPTR
     76  1dec		       a8		      tay		;LSB
     77  1ded		       a5 50		      lda	CURPTR+1
     78  1def		       69 00		      adc	#0
     79  1df1		       aa		      tax
     80  1df2		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1df5		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1df7		       a9 00		      lda	#0
     83  1df9		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1dfb		       4c 13 06 	      jmp	iErr2
     85  1dfe		       4c c2 02    wrmOk      jmp	NextIL
     86  1e01
     87  1e01							; No filename supplied.
     88  1e01							;
     89  1e01		       a9 00	   iRMnofn    lda	#0
     90  1e03		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1e05		       4c 13 06 	      jmp	iErr2
     92  1e08					      endif
     93  1e08							;
     94  1e08							;=====================================================
     95  1e08				   iOPENWRITE
     96  1e08					      if	XKIM || CTMON65
     97  1e08		       a4 51		      ldy	CUROFF
     98  1e0a		       b1 4f		      lda	(CURPTR),y
     99  1e0c		       f0 f3		      beq	iRMnofn
    100  1e0e							;
    101  1e0e		       18		      clc
    102  1e0f		       98		      tya
    103  1e10		       65 4f		      adc	CURPTR
    104  1e12		       a8		      tay		;LSB
    105  1e13		       a5 50		      lda	CURPTR+1
    106  1e15		       69 00		      adc	#0
    107  1e17		       aa		      tax
    108  1e18		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1e1b		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1e1d							;
    111  1e1d							; Open failed
    112  1e1d							;
    113  1e1d		       a9 00	   Wdfail     lda	#0
    114  1e1f		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1e21		       4c 13 06 	      jmp	iErr2
    116  1e24							;
    117  1e24		       4c c2 02    Wopenok    jmp	NextIL
    118  1e27					      endif
    119  1e27							;
    120  1e27							;=====================================================
    121  1e27							; Gets a line of input from the disk file and puts it
    122  1e27							; into LINBUF.
    123  1e27							;
    124  1e27							; On exit:
    125  1e27							;    CURPTR points to LINBUF
    126  1e27							;    LINBUF contains the line with 0 at the end.
    127  1e27							;    Y has offset to first non-space character
    128  1e27							;    CURROFF has the same as Y.
    129  1e27							;
    130  1e27				   iDGETLINE
    131  1e27					      if	XKIM || CTMON65
    132  1e27		       a2 91		      ldx	#LINBUF&$ff
    133  1e29		       86 4f		      stx	CURPTR
    134  1e2b		       a2 2b		      ldx	#LINBUF>>8
    135  1e2d		       86 50		      stx	CURPTR+1
    136  1e2f							;
    137  1e2f		       a2 00		      ldx	#0	;offset
    138  1e31		       8e 15 2c    iDgetLoop  stx	getlinx
    139  1e34		       20 95 1e 	      jsr	getNextFileByte
    140  1e37		       b0 16		      bcs	iGetEOF
    141  1e39		       c9 0d		      cmp	#CR
    142  1e3b		       f0 0d		      beq	iGetEOL
    143  1e3d		       c9 0a		      cmp	#LF
    144  1e3f		       f0 09		      beq	iGetEOL
    145  1e41		       ae 15 2c 	      ldx	getlinx
    146  1e44		       9d 91 2b 	      sta	LINBUF,x
    147  1e47		       e8		      inx
    148  1e48		       d0 e7		      bne	iDgetLoop
    149  1e4a							;
    150  1e4a							; Handle end of line.	If the line has nothing, loop
    151  1e4a							; back and get another line.
    152  1e4a							;
    153  1e4a		       ae 15 2c    iGetEOL    ldx	getlinx	;blank line?
    154  1e4d		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  1e4f							;
    156  1e4f							; This can fall through when there is a line, or
    157  1e4f							; called directly when EOF is encountered.
    158  1e4f							;
    159  1e4f		       ae 15 2c    iGetEOF    ldx	getlinx
    160  1e52		       a9 00		      lda	#0
    161  1e54		       9d 91 2b 	      sta	LINBUF,x
    162  1e57		       85 51		      sta	CUROFF
    163  1e59		       a0 00		      ldy	#0
    164  1e5b		       20 03 1c 	      jsr	SkipSpaces
    165  1e5e		       20 38 0f 	      jsr	ParseInputLine
    166  1e61		       4c c2 02 	      jmp	NextIL
    167  1e64					      endif
    168  1e64
    169  1e64							;
    170  1e64							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  1e64							; DISK
    172  1e64							;
    173  1e64				   iDDIR
    174  1e64					      if	XKIM || CTMON65
    175  1e64		       20 30 f0 	      jsr	DiskDir
    176  1e67							;
    177  1e67							; Get/Display each entry
    178  1e67							;
    179  1e67		       a2 22	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  1e69		       a0 c2		      ldy	#DiskFileName&$ff
    181  1e6b		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  1e6e		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  1e70		       20 82 13 	      jsr	puts
      0  1e73					      db	"   ",0
      1  1e73		       20 20 20 00	      .byte.b	"   ",0
    185  1e77							; Print the line to the console
    186  1e77		       a2 22		      ldx	#DiskFileName>>8	;pointer to buffer
    187  1e79		       a0 c2		      ldy	#DiskFileName&$ff
    188  1e7b		       a5 00		      lda	0
    189  1e7d		       20 c7 13 	      jsr	PrtStr	;else print name
    190  1e80		       20 18 f0 	      jsr	crlf
    191  1e83
    192  1e83		       4c 67 1e 	      jmp	DiskDirLoop	;do next entry
    193  1e86
    194  1e86		       4c c2 02    DiskDirEnd jmp	NextIL
    195  1e89					      endif
    196  1e89							;
    197  1e89							;=====================================================
    198  1e89							; Does a LIST to a Disk file.
    199  1e89							;
    200  1e89				   iDLIST
    201  1e89					      if	XKIM || CTMON65
    202  1e89		       20 c4 1e 	      jsr	SetOutDisk
    203  1e8c		       4c e3 07 	      jmp	iLST2
    204  1e8f					      endif
    205  1e8f							;
    206  1e8f							;=====================================================
    207  1e8f							; Closes any pending disk file.  Okay to call if there
    208  1e8f							; is no open file.
    209  1e8f							;
    210  1e8f				   iDCLOSE
    211  1e8f					      if	XKIM || CTMON65
    212  1e8f		       20 42 f0 	      jsr	DiskClose
    213  1e92		       4c c2 02 	      jmp	NextIL
    214  1e95					      endif
    215  1e95							;
    216  1e95							;=====================================================
    217  1e95							; This gets the next byte from an open disk file.  If
    218  1e95							; there are no more bytes left, this returns C set.
    219  1e95							; Else, C is clear and A contains the character.
    220  1e95							;
    221  1e95				   getNextFileByte
    222  1e95					      if	XKIM || CTMON65
    223  1e95		       ae c1 22 	      ldx	diskBufOffset
    224  1e98		       ec c0 22 	      cpx	diskBufLength
    225  1e9b		       d0 14		      bne	hasdata	;branch if still data
    226  1e9d							;
    227  1e9d							; There is no data left in the buffer, so read a
    228  1e9d							; block from the SD system.
    229  1e9d							;
    230  1e9d		       a9 84		      lda	#BUFFER_SIZE
    231  1e9f		       a2 df		      ldx	#buffer>>8
    232  1ea1		       a0 0a		      ldy	#buffer&$ff
    233  1ea3		       20 3c f0 	      jsr	DiskRead
    234  1ea6		       b0 12		      bcs	getNextEof
    235  1ea8							;
    236  1ea8							; A contains the number of bytes actually read.
    237  1ea8							;
    238  1ea8		       8d c0 22 	      sta	diskBufLength	;save length
    239  1eab		       c9 00		      cmp	#0	;shouldn't happen
    240  1ead		       f0 0b		      beq	getNextEof
    241  1eaf							;
    242  1eaf		       a2 00		      ldx	#0
    243  1eb1		       bd 0a df    hasdata    lda	buffer,x
    244  1eb4		       e8		      inx
    245  1eb5		       8e c1 22 	      stx	diskBufOffset
    246  1eb8		       18		      clc
    247  1eb9		       60		      rts
    248  1eba							;
    249  1eba		       a9 00	   getNextEof lda	#0
    250  1ebc		       8d c1 22 	      sta	diskBufOffset
    251  1ebf		       8d c0 22 	      sta	diskBufLength
    252  1ec2		       38		      sec
    253  1ec3		       60		      rts
    254  1ec4							;
    255  1ec4							;=====================================================
    256  1ec4							; Set output vector to the disk output function
    257  1ec4							;
    258  1ec4		       a9 cf	   SetOutDisk lda	#DOUT&$ff
    259  1ec6		       8d 22 2c 	      sta	BOutVec
    260  1ec9		       a9 1e		      lda	#DOUT/256
    261  1ecb		       8d 23 2c 	      sta	BOutVec+1
    262  1ece		       60		      rts
    263  1ecf							;
    264  1ecf							;=====================================================
    265  1ecf
    266  1ecf		       8d 0a df    DOUT       sta	buffer
    267  1ed2		       a9 01		      lda	#1
    268  1ed4		       a0 0a		      ldy	#buffer&$ff
    269  1ed6		       a2 df		      ldx	#buffer>>8
    270  1ed8		       20 3f f0 	      jsr	DiskWrite
    271  1edb							;
    272  1edb							; need error checking here
    273  1edb							;
    274  1edb		       60		      rts
    275  1edc					      endif
    276  1edc
    277  1edc
------- FILE mytb.asm
   2302  1edc					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1edc					      include	"IL.inc"
      1  1edc
      2  1edc							;=====================================================
      3  1edc							; IL.inc
      4  1edc							; These are macros for IL instructions
      5  1edc							;
      6  1edc					      mac	dw
      7  1edc					      .word	{0}
      8  1edc					      endm
      9  1edc					      mac	db
     10  1edc					      .byte	{0}
     11  1edc					      endm
     12  1edc					      macro	xinit
     13  1edc					      db	0
     14  1edc					      endm		;reset the il to start clear all
     15  1edc							;
     16  1edc					      macro	done
     17  1edc					      db	1
     18  1edc					      endm		;print an error if not end of line
     19  1edc							;
     20  1edc					      macro	prs
     21  1edc					      db	2
     22  1edc					      endm		;print a quoted string
     23  1edc							;
     24  1edc					      macro	prn
     25  1edc					      db	3
     26  1edc					      endm		;print a number
     27  1edc							;
     28  1edc					      macro	spc
     29  1edc					      db	4
     30  1edc					      endm		;print space til new tabstop
     31  1edc							;
     32  1edc					      macro	nline
     33  1edc					      db	5
     34  1edc					      endm		;print a new line crlf
     35  1edc							;
     36  1edc							; My NXT is a bit different in that it takes one
     37  1edc							; parameter, which is an address.  If the BASIC
     38  1edc							; program is currently running then move to the
     39  1edc							; next line and continue execution.  However, if
     40  1edc							; in direct mode, jump to the specified IL label.
     41  1edc							;
     42  1edc					      macro	nxt
     43  1edc					      db	6
     44  1edc					      dw	{1}	; addr
     45  1edc					      endm		; addr
     46  1edc							;
     47  1edc					      macro	xfer
     48  1edc					      db	7
     49  1edc					      endm
     50  1edc							;
     51  1edc					      macro	sav
     52  1edc					      db	8
     53  1edc					      db	{1}
     54  1edc					      endm
     55  1edc							;
     56  1edc					      macro	rstr
     57  1edc					      db	9
     58  1edc					      endm
     59  1edc							;
     60  1edc					      macro	cmpr
     61  1edc					      db	10
     62  1edc					      endm
     63  1edc							;
     64  1edc					      macro	innum
     65  1edc					      db	11
     66  1edc					      endm
     67  1edc							;
     68  1edc					      macro	fin
     69  1edc					      db	12
     70  1edc					      endm
     71  1edc							;
     72  1edc							; ERR is followed by an error number.	The error
     73  1edc							; code is printed along with the line number.
     74  1edc							; Control is passed to the statement set with
     75  1edc							; the ERRGOTO statement.
     76  1edc							;
     77  1edc					      macro	errmsg
     78  1edc					      db	13
     79  1edc					      dw	{1}	;ecode
     80  1edc					      endm		;ecode
     81  1edc							;
     82  1edc					      macro	add
     83  1edc					      db	14
     84  1edc					      endm
     85  1edc							;
     86  1edc					      macro	sub
     87  1edc					      db	15
     88  1edc					      endm
     89  1edc							;
     90  1edc					      macro	neg
     91  1edc					      db	16
     92  1edc					      endm
     93  1edc							;
     94  1edc					      macro	mul
     95  1edc					      db	17
     96  1edc					      endm
     97  1edc							;
     98  1edc					      macro	div
     99  1edc					      db	18
    100  1edc					      endm
    101  1edc							;
    102  1edc					      macro	store
    103  1edc					      db	19
    104  1edc					      endm
    105  1edc							;
    106  1edc					      macro	ind
    107  1edc					      db	20
    108  1edc					      endm
    109  1edc							;
    110  1edc					      macro	lst
    111  1edc					      db	21
    112  1edc					      endm
    113  1edc							;
    114  1edc					      macro	init
    115  1edc					      db	22
    116  1edc					      endm
    117  1edc							;
    118  1edc					      macro	getline
    119  1edc					      db	23
    120  1edc					      endm
    121  1edc							;
    122  1edc					      macro	insert
    123  1edc					      db	24
    124  1edc					      endm
    125  1edc							;
    126  1edc					      macro	rtn
    127  1edc					      db	25
    128  1edc					      endm
    129  1edc							;
    130  1edc					      macro	exit
    131  1edc					      db	26
    132  1edc					      endm
    133  1edc							;
    134  1edc					      macro	lit
    135  1edc					      db	27
    136  1edc					      dw	{1}	;value
    137  1edc					      endm		; value LIT
    138  1edc							;
    139  1edc					      macro	call
    140  1edc					      db	28
    141  1edc					      dw	{1}	;addr
    142  1edc					      endm		;addr
    143  1edc							;
    144  1edc							; IJMP will set the IL PC to the specified value.
    145  1edc							;
    146  1edc					      macro	ijmp
    147  1edc					      db	29
    148  1edc					      dw	{1}	;addr
    149  1edc					      endm		;addr
    150  1edc							;
    151  1edc					      macro	vinit
    152  1edc					      db	30
    153  1edc					      endm
    154  1edc							;
    155  1edc							; ERRGOTO sets the point in the code where the IL
    156  1edc							; interpreter will go after any error.
    157  1edc							;
    158  1edc					      macro	errgoto
    159  1edc					      db	31
    160  1edc					      dw	{1}	;addr
    161  1edc					      endm		;addr
    162  1edc							;
    163  1edc					      macro	tst
    164  1edc					      db	32
    165  1edc					      db	({1}-*)-1	;(addr-*)-1
    166  1edc					      db	{2},0	;string,0
    167  1edc					      endm		;addr,string
    168  1edc							;
    169  1edc					      macro	tstv
    170  1edc					      db	33
    171  1edc					      db	({1}-*)-1	;(addr-*)-1
    172  1edc					      endm		;addr
    173  1edc							;
    174  1edc					      macro	tstl
    175  1edc					      db	34
    176  1edc					      db	({1}-*)-1	;(addr-*)-1
    177  1edc					      endm		;addr
    178  1edc							;
    179  1edc					      macro	tstn
    180  1edc					      db	35
    181  1edc					      db	({1}-*)-1	;(addr-*)-1
    182  1edc					      endm		;addr
    183  1edc							;
    184  1edc							; FREE returns the amount of free RAM on top of
    185  1edc							; the stack.  This is the amount of room the user
    186  1edc							; program has available.
    187  1edc							;
    188  1edc					      macro	free
    189  1edc					      db	36
    190  1edc					      endm
    191  1edc							;
    192  1edc							; RANDOM takes the top item off the stack and
    193  1edc							; replaces it with a random number that is
    194  1edc							; MOD the initial value.  Ie, if the TOS is
    195  1edc							; 42 then RANDOM returns a value from 0 to 41.
    196  1edc							;
    197  1edc					      macro	random
    198  1edc					      db	37
    199  1edc					      endm
    200  1edc							;
    201  1edc							; ABS will replace the top of stack with the
    202  1edc							; absolute value.
    203  1edc							;
    204  1edc					      macro	abs
    205  1edc					      db	38
    206  1edc					      endm
    207  1edc							;
    208  1edc							; OPENREAD opens a file for reading, as in getting
    209  1edc							; statements from it.
    210  1edc							;
    211  1edc					      macro	openread
    212  1edc					      db	39
    213  1edc					      endm
    214  1edc							;
    215  1edc							; OPENWRITE opens a file for writing, as in saving
    216  1edc							; the current program to it.
    217  1edc							;
    218  1edc					      macro	openwrite
    219  1edc					      db	40
    220  1edc					      endm
    221  1edc							;
    222  1edc							; DCLOSE closes any open disk file.
    223  1edc							;
    224  1edc					      macro	dclose
    225  1edc					      db	41
    226  1edc					      endm
    227  1edc							;
    228  1edc							; DGETLINE gets one line from the disk file and puts it
    229  1edc							; into LINBUFF.
    230  1edc							;
    231  1edc					      macro	dgetline
    232  1edc					      db	42
    233  1edc					      endm
    234  1edc							;
    235  1edc							; DLIST saves the program to an open disk file.
    236  1edc							;
    237  1edc					      macro	dlist
    238  1edc					      db	43
    239  1edc					      endm
    240  1edc							; DDIR list the current directory
    241  1edc							;
    242  1edc					      macro	ddir
    243  1edc					      db	44
    244  1edc					      endm
    245  1edc
    246  1edc							; RMFILE remove a fle from disk
    247  1edc					      macro	rmfile
    248  1edc					      db	45
    249  1edc					      endm
    250  1edc
    251  1edc							; CLEARSCREEN clear the screen
    252  1edc					      macro	clearscreen
    253  1edc					      db	46
    254  1edc					      endm
    255  1edc							; POKEMEM Poke value into memory
    256  1edc					      macro	pokemem
    257  1edc					      db	47
    258  1edc					      endm
    259  1edc							; PEEKMEM peek at value in memory
    260  1edc					      macro	peekmem
    261  1edc					      db	48
    262  1edc					      endm
    263  1edc							; TSTLET Test if the statement is a let without the keyword let
    264  1edc					      macro	tstlet
    265  1edc					      db	49
    266  1edc					      db	({1}-*)-1	;(addr-*)-1
    267  1edc					      endm		;addr
    268  1edc							; TSTDONE if we reach the end of a statement
    269  1edc					      macro	tstdone
    270  1edc					      db	50
    271  1edc					      db	({1}-*)-1	;(addr-*)-1
    272  1edc					      endm		;addr
    273  1edc							; GETCHAR	get a character from the input line leave it in RO
    274  1edc					      macro	getchar
    275  1edc					      db	51
    276  1edc					      endm
    277  1edc							; PUTCHAR	Put a character to the terminal
    278  1edc					      macro	putchar
    279  1edc					      db	52
    280  1edc					      endm
    281  1edc							; Call		Call a machine function return a to stack
    282  1edc					      macro	callfunc
    283  1edc					      db	53
    284  1edc					      endm
    285  1edc
    286  1edc							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1edc					      macro	ibranch
    288  1edc					      db	54
    289  1edc					      endm
    290  1edc
    291  1edc							; TSTSTR	 Tests for the open quote in a string
    292  1edc					      macro	tststr
    293  1edc					      db	55
    294  1edc					      db	({1}-*)-1	;(addr-*)-1
    295  1edc					      endm
    296  1edc							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1edc					      macro	setirq
    298  1edc					      db	56
    299  1edc					      endm
    300  1edc
    301  1edc							; TSTIRQ	Test for irq pending,
    302  1edc							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1edc					      macro	tstirq
    304  1edc					      db	57
    305  1edc					      db	({1}-*)-1	;(addr-*)-1
    306  1edc					      endm
    307  1edc
    308  1edc							; IRET    return from interupt service
    309  1edc					      macro	iret
    310  1edc					      db	58
    311  1edc					      endm
    312  1edc
    313  1edc							; INSTR   read a string from the input
    314  1edc					      macro	instr
    315  1edc					      db	59
    316  1edc					      endm
    317  1edc
    318  1edc							; MODULO Returns the remainder of the division
    319  1edc					      macro	modulo
    320  1edc					      db	60
    321  1edc					      endm
    322  1edc							; Set a task line
    323  1edc					      macro	taskcreate
    324  1edc					      db	61
    325  1edc					      endm
    326  1edc							; End a task
    327  1edc					      macro	etask
    328  1edc					      db	62
    329  1edc					      endm
    330  1edc							; Skip to next task
    331  1edc					      macro	ntask
    332  1edc					      db	63
    333  1edc					      endm
    334  1edc							; Subscript
    335  1edc					      macro	subscript
    336  1edc					      db	64
    337  1edc					      endm
    338  1edc							; KILL Task
    339  1edc					      macro	taskkill
    340  1edc					      db	65
    341  1edc					      endm
    342  1edc							; STAT Task
    343  1edc					      macro	taskstat
    344  1edc					      db	66
    345  1edc					      endm
    346  1edc							;  output value as hex
    347  1edc					      macro	hexprt
    348  1edc					      db	67
    349  1edc					      endm
    350  1edc							;  Read in background has completed
    351  1edc					      macro	readcomplete
    352  1edc					      db	68
    353  1edc					      endm
    354  1edc							;  ReadInput line
    355  1edc					      macro	readstart
    356  1edc					      db	69
    357  1edc					      endm
    358  1edc							; Startio request
    359  1edc					      macro	startio
    360  1edc					      db	70
    361  1edc					      endm
    362  1edc							; Endio
    363  1edc					      macro	endio
    364  1edc					      db	71
    365  1edc					      endm
    366  1edc							; Logical not
    367  1edc					      macro	lognot
    368  1edc					      db	72
    369  1edc					      endm
    370  1edc							; Logical OR
    371  1edc					      macro	logor
    372  1edc					      db	73
    373  1edc					      endm
    374  1edc							;Logical and
    375  1edc					      macro	logand
    376  1edc					      db	74
    377  1edc					      endm
    378  1edc							;Logical XOR
    379  1edc					      macro	logxor
    380  1edc					      db	75
    381  1edc					      endm
    382  1edc							;Wait for task to complete, or list of tasks
    383  1edc					      macro	wtask
    384  1edc					      db	76
    385  1edc					      db	({1}-*)-1	;(addr-*)-1
    386  1edc					      endm
    387  1edc							;Get the current task id
    388  1edc					      MACRO	taskpid
    389  1edc					      db	77
    390  1edc					      endm
    391  1edc							;Trace the basic execution
    392  1edc					      Macro	traceprogram
    393  1edc					      db	78
    394  1edc					      endm
    395  1edc							;Do a basic program Trace
    396  1edc					      Macro	debugbasic
    397  1edc					      db	79
    398  1edc					      endm
    399  1edc
    400  1edc							; Inter Process communications instructions
    401  1edc					      Macro	ipcsend
    402  1edc					      db	80
    403  1edc					      endm
    404  1edc					      Macro	ipcreceive
    405  1edc					      db	81
    406  1edc					      endm
    407  1edc					      Macro	ipccheck
    408  1edc					      db	82
    409  1edc					      endm
    410  1edc					      Macro	ipcio
    411  1edc					      db	83
    412  1edc					      endm
    413  1edc					      Macro	pushmathstack
    414  1edc					      db	84
    415  1edc					      endm
    416  1edc					      Macro	popmathstack
    417  1edc					      db	85
    418  1edc					      endm
    419  1edc					      Macro	savemathstack
    420  1edc					      db	86
    421  1edc					      endm
    422  1edc					      Macro	restoremathstack
    423  1edc					      db	87
    424  1edc					      endm
    425  1edc					      Macro	incparmcount
    426  1edc					      db	88
    427  1edc					      endm
    428  1edc					      Macro	taskgetmathstack
    429  1edc					      db	89
    430  1edc					      endm
    431  1edc					      Macro	taskenable
    432  1edc					      db	90
    433  1edc					      endm
    434  1edc					      Macro	tasksuspend
    435  1edc					      db	91
    436  1edc					      endm
    437  1edc					      Macro	taskputmathptr
    438  1edc					      db	92
    439  1edc					      endm
    440  1edc							; Test for an extension type of variable that allows access to a tasks variables
    441  1edc							; Using  PID!<Var name>
    442  1edc					      Macro	tstvt
    443  1edc					      db	93
    444  1edc					      db	({1}-*)-1	;(addr-*)-1
    445  1edc					      endm
    446  1edc
    447  1edc							; Provide access to R2 for the IL program
    448  1edc					      Macro	setr2
    449  1edc					      db	94
    450  1edc					      db	{1}	; R2 is only one byte
    451  1edc					      endm
    452  1edc							;Move stack top to temp
    453  1edc					      Macro	stk2tmp
    454  1edc					      db	95
    455  1edc					      endm
    456  1edc
    457  1edc					      Macro	tmp2stk
    458  1edc					      db	96
    459  1edc					      endm
    460  1edc
    461  1edc					      Macro	tstbyte
    462  1edc					      db	97
    463  1edc					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1edc					      dw	{2}	; address to check
    465  1edc					      db	{3}	; Value to compare
    466  1edc					      endm
    467  1edc
    468  1edc					      Macro	incvar
    469  1edc					      db	98
    470  1edc					      endm
    471  1edc					      Macro	decvar
    472  1edc					      db	99
    473  1edc					      endm
    474  1edc
    475  1edc					      Macro	slice
    476  1edc					      db	100
    477  1edc					      endm
    478  1edc
    479  1edc					      Macro	tstb
    480  1edc					      db	101
    481  1edc					      db	({1}-*)-1
    482  1edc					      db	{2}
    483  1edc					      endm
    484  1edc
    485  1edc					      Macro	tstw
    486  1edc					      db	102
    487  1edc					      db	({1}-*)-1
    488  1edc					      dw	{2}
    489  1edc					      endm
    490  1edc
    491  1edc
------- FILE mytb.asm
   2304  1edc							;
   2305  1edc				  -	      if	FIXED
   2306  1edc				  -	      org	$1000
   2307  1edc					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1edc					      include	"basic.il"
      1  1edc							;LET
      2  1edc							;=====================================================
      3  1edc							;=====================================================
      4  1edc					      seg	Code
      5  1edc							;=====================================================
      6  1edc							; This is the IL of the BASIC (or whatever) language.
      7  1edc							; Because of the way macros are implemented by as65,
      8  1edc							; labels can't be on the same line as a macro
      9  1edc							; invocation, so that's why labels are on separate
     10  1edc							; lines.
     11  1edc							;
     12  1edc		       1e dc	   IL	      equ	*
     13  1edc
     14  1edc							;THE IL CONTROL SECTION
     15  1edc
     16  1edc				   START
      0  1edc					      INIT		;INITIALIZE
      0  1edc					      db	22
      1  1edc		       16		      .byte.b	22
      0  1edd					      NLINE		;WRITE CRLF
      0  1edd					      db	5
      1  1edd		       05		      .byte.b	5
      0  1ede					      ERRGOTO	CO	;where to go after an error
      0  1ede					      db	31
      1  1ede		       1f		      .byte.b	31
      0  1edf					      dw	CO
      1  1edf		       e2 1e		      .word.w	CO
      0  1ee1					      VINIT		;clear all variables
      0  1ee1					      db	30
      1  1ee1		       1e		      .byte.b	30
     21  1ee2							;
     22  1ee2							; This is where we jump to get a line of commands or
     23  1ee2							; a program from the user.
     24  1ee2							;
     25  1ee2				   CO
      0  1ee2					      GETLINE		;WRITE PROMPT AND GET LINE
      0  1ee2					      db	23
      1  1ee2		       17		      .byte.b	23
      0  1ee3					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1ee3					      db	34
      1  1ee3		       22		      .byte.b	34
      0  1ee4					      db	(XEC-*)-1
      1  1ee4		       04		      .byte.b	(XEC-*)-1
      0  1ee5					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1ee5					      db	24
      1  1ee5		       18		      .byte.b	24
      0  1ee6					      IJMP	CO
      0  1ee6					      db	29
      1  1ee6		       1d		      .byte.b	29
      0  1ee7					      dw	CO
      1  1ee7		       e2 1e		      .word.w	CO
     30  1ee9				   XEC
      0  1ee9					      XINIT		;INITIALIZE
      0  1ee9					      db	0
      1  1ee9		       00		      .byte.b	0
     32  1eea							;============================================================================
     33  1eea							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1eea							;
     35  1eea				   STMT
      0  1eea					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1eea					      db	79
      1  1eea		       4f		      .byte.b	79
      0  1eeb					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1eeb					      db	57
      1  1eeb		       39		      .byte.b	57
      0  1eec					      db	(notirq-*)-1
      1  1eec		       00		      .byte.b	(notirq-*)-1
     38  1eed							;==========================================================================================
     39  1eed							; Process a let statement implied or explicit.
     40  1eed							;
     41  1eed				   notirq
      0  1eed					      TSTLET	S1	; Test if Let keyword or a variable
      0  1eed					      db	49
      1  1eed		       31		      .byte.b	49
      0  1eee					      db	(S1-*)-1
      1  1eee		       1a		      .byte.b	(S1-*)-1
     43  1eef				   DOLET
      0  1eef					      TSTV	ERRVEC	; YES, PLACE VAR ADDRESS ON AESTK
      0  1eef					      db	33
      1  1eef		       21		      .byte.b	33
      0  1ef0					      db	(ERRVEC-*)-1
      1  1ef0		       ab		      .byte.b	(ERRVEC-*)-1
      0  1ef1					      TSTB	LETBE,oLeftSQBracket	; [
      0  1ef1					      db	101
      1  1ef1		       65		      .byte.b	101
      0  1ef2					      db	(LETBE-*)-1
      1  1ef2		       08		      .byte.b	(LETBE-*)-1
      0  1ef3					      db	oLeftSQBracket
      1  1ef3		       e4		      .byte.b	oLeftSQBracket
      0  1ef4					      CALL	EXPR
      0  1ef4					      db	28
      1  1ef4		       1c		      .byte.b	28
      0  1ef5					      dw	EXPR
      1  1ef5		       ed 20		      .word.w	EXPR
      0  1ef7					      TSTB	ERRVEC,oRightSQBracket	; ]
      0  1ef7					      db	101
      1  1ef7		       65		      .byte.b	101
      0  1ef8					      db	(ERRVEC-*)-1
      1  1ef8		       a3		      .byte.b	(ERRVEC-*)-1
      0  1ef9					      db	oRightSQBracket
      1  1ef9		       e5		      .byte.b	oRightSQBracket
      0  1efa					      SUBSCRIPT
      0  1efa					      db	64
      1  1efa		       40		      .byte.b	64
     49  1efb				   LETBE
      0  1efb					      TSTB	ERRVEC,oEqual	; (This line originally omitted)
      0  1efb					      db	101
      1  1efb		       65		      .byte.b	101
      0  1efc					      db	(ERRVEC-*)-1
      1  1efc		       9f		      .byte.b	(ERRVEC-*)-1
      0  1efd					      db	oEqual
      1  1efd		       f2		      .byte.b	oEqual
      0  1efe					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  1efe					      db	28
      1  1efe		       1c		      .byte.b	28
      0  1eff					      dw	EXPR
      1  1eff		       ed 20		      .word.w	EXPR
      0  1f01					      DONE		; REPORT ERROR IF NOT NEXT
      0  1f01					      db	1
      1  1f01		       01		      .byte.b	1
      0  1f02					      STORE		; STORE RESULT
      0  1f02					      db	19
      1  1f02		       13		      .byte.b	19
      0  1f03					      NXT	CO	; AND SEQUENCE TO NEXT
      0  1f03					      db	6
      1  1f03		       06		      .byte.b	6
      0  1f04					      dw	CO
      1  1f04		       e2 1e		      .word.w	CO
      0  1f06					      IJMP	STMT
      0  1f06					      db	29
      1  1f06		       1d		      .byte.b	29
      0  1f07					      dw	STMT
      1  1f07		       ea 1e		      .word.w	STMT
     56  1f09							;=============================================================
     57  1f09							; Inc or dec a variable
     58  1f09				   S1
      0  1f09					      TSTB	S1Dec,kInc	; Increment variable
      0  1f09					      db	101
      1  1f09		       65		      .byte.b	101
      0  1f0a					      db	(S1Dec-*)-1
      1  1f0a		       0b		      .byte.b	(S1Dec-*)-1
      0  1f0b					      db	kInc
      1  1f0b		       02		      .byte.b	kInc
      0  1f0c					      TSTV	ERRVEC	; Verify we have a variable
      0  1f0c					      db	33
      1  1f0c		       21		      .byte.b	33
      0  1f0d					      db	(ERRVEC-*)-1
      1  1f0d		       8e		      .byte.b	(ERRVEC-*)-1
      0  1f0e					      INCVAR		; Do the increment of the variable
      0  1f0e					      db	98
      1  1f0e		       62		      .byte.b	98
      0  1f0f					      DONE		; Test for end of line or end of statement ":"
      0  1f0f					      db	1
      1  1f0f		       01		      .byte.b	1
      0  1f10					      NXT	CO	; Get the next statement, branch CO if end of program
      0  1f10					      db	6
      1  1f10		       06		      .byte.b	6
      0  1f11					      dw	CO
      1  1f11		       e2 1e		      .word.w	CO
      0  1f13					      IJMP	STMT	; Process the next statement
      0  1f13					      db	29
      1  1f13		       1d		      .byte.b	29
      0  1f14					      dw	STMT
      1  1f14		       ea 1e		      .word.w	STMT
     65  1f16				   S1Dec
      0  1f16					      TSTB	S1Iret,kDec	; Dec variable
      0  1f16					      db	101
      1  1f16		       65		      .byte.b	101
      0  1f17					      db	(S1Iret-*)-1
      1  1f17		       0b		      .byte.b	(S1Iret-*)-1
      0  1f18					      db	kDec
      1  1f18		       03		      .byte.b	kDec
      0  1f19					      TSTV	ERRVEC	; Must be followed by a variable
      0  1f19					      db	33
      1  1f19		       21		      .byte.b	33
      0  1f1a					      db	(ERRVEC-*)-1
      1  1f1a		       81		      .byte.b	(ERRVEC-*)-1
      0  1f1b					      DECVAR		; Decrement the actual variable
      0  1f1b					      db	99
      1  1f1b		       63		      .byte.b	99
      0  1f1c					      DONE		; Test if end of line or : statement
      0  1f1c					      db	1
      1  1f1c		       01		      .byte.b	1
      0  1f1d					      NXT	CO	; If at end of program then got the console
      0  1f1d					      db	6
      1  1f1d		       06		      .byte.b	6
      0  1f1e					      dw	CO
      1  1f1e		       e2 1e		      .word.w	CO
      0  1f20					      IJMP	STMT	; Process the next statement of command line
      0  1f20					      db	29
      1  1f20		       1d		      .byte.b	29
      0  1f21					      dw	STMT
      1  1f21		       ea 1e		      .word.w	STMT
     72  1f23							;====================================================================
     73  1f23							; iret or ireturn, Return from interupt process
     74  1f23							;
     75  1f23				   S1Iret
      0  1f23					      TSTB	S1S1,kIreturn	; test return from interupt
      0  1f23					      db	101
      1  1f23		       65		      .byte.b	101
      0  1f24					      db	(S1S1-*)-1
      1  1f24		       09		      .byte.b	(S1S1-*)-1
      0  1f25					      db	kIreturn
      1  1f25		       04		      .byte.b	kIreturn
      0  1f26					      TSTB	S1S1,kIret	; Allow the short form as well
      0  1f26					      db	101
      1  1f26		       65		      .byte.b	101
      0  1f27					      db	(S1S1-*)-1
      1  1f27		       06		      .byte.b	(S1S1-*)-1
      0  1f28					      db	kIret
      1  1f28		       32		      .byte.b	kIret
     78  1f29				   S1Sa
      0  1f29					      DONE		; Must be only thing on the line
      0  1f29					      db	1
      1  1f29		       01		      .byte.b	1
      0  1f2a					      IRET		; RESTORE LINE NUMBER OF CALL
      0  1f2a					      db	58
      1  1f2a		       3a		      .byte.b	58
      0  1f2b					      IJMP	STMT
      0  1f2b					      db	29
      1  1f2b		       1d		      .byte.b	29
      0  1f2c					      dw	STMT
      1  1f2c		       ea 1e		      .word.w	STMT
     82  1f2e							;=======================================================================
     83  1f2e							;Process if statement, if true then process all statements until end of line reached
     84  1f2e				   S1S1
      0  1f2e					      TSTB	S1Z,kIf	; IF STATEMENT
      0  1f2e					      db	101
      1  1f2e		       65		      .byte.b	101
      0  1f2f					      db	(S1Z-*)-1
      1  1f2f		       0b		      .byte.b	(S1Z-*)-1
      0  1f30					      db	kIf
      1  1f30		       05		      .byte.b	kIf
      0  1f31					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  1f31					      db	28
      1  1f31		       1c		      .byte.b	28
      0  1f32					      dw	EXPR
      1  1f32		       ed 20		      .word.w	EXPR
      0  1f34					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  1f34					      db	101
      1  1f34		       65		      .byte.b	101
      0  1f35					      db	(S1W-*)-1
      1  1f35		       01		      .byte.b	(S1W-*)-1
      0  1f36					      db	kThen
      1  1f36		       06		      .byte.b	kThen
     88  1f37				   S1W
      0  1f37					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1f37					      db	54
      1  1f37		       36		      .byte.b	54
      0  1f38					      IJMP	STMT
      0  1f38					      db	29
      1  1f38		       1d		      .byte.b	29
      0  1f39					      dw	STMT
      1  1f39		       ea 1e		      .word.w	STMT
     91  1f3b							;===============================================================
     92  1f3b							; Test for GOTO
     93  1f3b				   S1Z
      0  1f3b					      TSTB	S2,kGoto	; YES...TO, OR...SUB
      0  1f3b					      db	101
      1  1f3b		       65		      .byte.b	101
      0  1f3c					      db	(S2-*)-1
      1  1f3c		       05		      .byte.b	(S2-*)-1
      0  1f3d					      db	kGoto
      1  1f3d		       07		      .byte.b	kGoto
      0  1f3e					      CALL	EXPR	; GET LABEL
      0  1f3e					      db	28
      1  1f3e		       1c		      .byte.b	28
      0  1f3f					      dw	EXPR
      1  1f3f		       ed 20		      .word.w	EXPR
      0  1f41					      XFER		; SET UP AND JUMP
      0  1f41					      db	7
      1  1f41		       07		      .byte.b	7
     97  1f42
     98  1f42							;===========================================================================
     99  1f42							; Process gosub / function
    100  1f42							;
    101  1f42				   S2
      0  1f42					      TSTB	S2b,kGosub	; ERROR IF NO MATCH
      0  1f42					      db	101
      1  1f42		       65		      .byte.b	101
      0  1f43					      db	(S2b-*)-1
      1  1f43		       08		      .byte.b	(S2b-*)-1
      0  1f44					      db	kGosub
      1  1f44		       08		      .byte.b	kGosub
      0  1f45					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  1f45					      db	28
      1  1f45		       1c		      .byte.b	28
      0  1f46					      dw	GOSUBSTATEMENT
      1  1f46		       a9 22		      .word.w	GOSUBSTATEMENT
      0  1f48					      DONE		; ERROR IF CR NOT NEXT
      0  1f48					      db	1
      1  1f48		       01		      .byte.b	1
      0  1f49					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  1f49					      db	8
      1  1f49		       08		      .byte.b	8
      0  1f4a					      db	GOSUB_RTN
      1  1f4a		       01		      .byte.b	GOSUB_RTN
      0  1f4b					      XFER		; AND JUMP to sub rtn
      0  1f4b					      db	7
      1  1f4b		       07		      .byte.b	7
    107  1f4c							;
    108  1f4c							; End of gosub processing
    109  1f4c							;==========================================================================
    110  1f4c							; Return from a gosub
    111  1f4c				   S2b
      0  1f4c					      TSTB	S2a,kReturn	; Speed up pocessing but more memory
      0  1f4c					      db	101
      1  1f4c		       65		      .byte.b	101
      0  1f4d					      db	(S2a-*)-1
      1  1f4d		       1e		      .byte.b	(S2a-*)-1
      0  1f4e					      db	kReturn
      1  1f4e		       09		      .byte.b	kReturn
      0  1f4f					      SETR2	0	; Default no return value
      0  1f4f					      db	94
      1  1f4f		       5e		      .byte.b	94
      0  1f50					      db	0
      1  1f50		       00		      .byte.b	0
      0  1f51					      TSTB	S2RetDone,oLeftBracket	; Check if we will return some value
      0  1f51					      db	101
      1  1f51		       65		      .byte.b	101
      0  1f52					      db	(S2RetDone-*)-1
      1  1f52		       09		      .byte.b	(S2RetDone-*)-1
      0  1f53					      db	oLeftBracket
      1  1f53		       e0		      .byte.b	oLeftBracket
      0  1f54					      SETR2	1	; Indicate a return value provided
      0  1f54					      db	94
      1  1f54		       5e		      .byte.b	94
      0  1f55					      db	1
      1  1f55		       01		      .byte.b	1
      0  1f56					      CALL	EXPR
      0  1f56					      db	28
      1  1f56		       1c		      .byte.b	28
      0  1f57					      dw	EXPR
      1  1f57		       ed 20		      .word.w	EXPR
      0  1f59					      TSTB	ERRVEC,oRightBracket	; Now a value is on the stack
      0  1f59					      db	101
      1  1f59		       65		      .byte.b	101
      0  1f5a					      db	(ERRVEC-*)-1
      1  1f5a		       41		      .byte.b	(ERRVEC-*)-1
      0  1f5b					      db	oRightBracket
      1  1f5b		       e1		      .byte.b	oRightBracket
    118  1f5c
    119  1f5c				   S2RetDone
      0  1f5c					      DONE		; MUST BE CR or :
      0  1f5c					      db	1
      1  1f5c		       01		      .byte.b	1
      0  1f5d					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  1f5d					      db	9
      1  1f5d		       09		      .byte.b	9
      0  1f5e					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  1f5e					      db	97
      1  1f5e		       61		      .byte.b	97
      0  1f5f					      db	(S2RetFunc-*)-1
      1  1f5f		       09		      .byte.b	(S2RetFunc-*)-1
      0  1f60					      dw	R2
      1  1f60		       58 00		      .word.w	R2
      0  1f62					      db	1
      1  1f62		       01		      .byte.b	1
      0  1f63					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  1f63					      db	6
      1  1f63		       06		      .byte.b	6
      0  1f64					      dw	CO
      1  1f64		       e2 1e		      .word.w	CO
      0  1f66					      IJMP	STMT	; Process the new statement
      0  1f66					      db	29
      1  1f66		       1d		      .byte.b	29
      0  1f67					      dw	STMT
      1  1f67		       ea 1e		      .word.w	STMT
    125  1f69				   S2RetFunc
      0  1f69					      IJMP	GOFNRet	; Back into the Function
      0  1f69					      db	29
      1  1f69		       1d		      .byte.b	29
      0  1f6a					      dw	GOFNRet
      1  1f6a		       83 22		      .word.w	GOFNRet
    127  1f6c							;
    128  1f6c							; End of return from gosub
    129  1f6c							;============================================================================
    130  1f6c							; Process REM statement
    131  1f6c							;
    132  1f6c				   S2a
      0  1f6c					      TSTB	S3,kRem	; REMark.  Skip rest of line
      0  1f6c					      db	101
      1  1f6c		       65		      .byte.b	101
      0  1f6d					      db	(S3-*)-1
      1  1f6d		       07		      .byte.b	(S3-*)-1
      0  1f6e					      db	kRem
      1  1f6e		       0a		      .byte.b	kRem
      0  1f6f					      NXT	CO	; The rest of the line is ignored
      0  1f6f					      db	6
      1  1f6f		       06		      .byte.b	6
      0  1f70					      dw	CO
      1  1f70		       e2 1e		      .word.w	CO
      0  1f72					      IJMP	STMT	; Process the next statement
      0  1f72					      db	29
      1  1f72		       1d		      .byte.b	29
      0  1f73					      dw	STMT
      1  1f73		       ea 1e		      .word.w	STMT
    136  1f75							;============================================================================
    137  1f75							; Print statement
    138  1f75							;
    139  1f75				   S3
      0  1f75					      TSTB	S8,kPrint	; ? or Print symonym for print
      0  1f75					      db	101
      1  1f75		       65		      .byte.b	101
      0  1f76					      db	(S8-*)-1
      1  1f76		       4f		      .byte.b	(S8-*)-1
      0  1f77					      db	kPrint
      1  1f77		       0b		      .byte.b	kPrint
      0  1f78					      STARTIO		; Lock task until io completes
      0  1f78					      db	70
      1  1f78		       46		      .byte.b	70
    142  1f79				   S4
      0  1f79					      TSTDONE	S4a	; Test if we just want crlf printed
      0  1f79					      db	50
      1  1f79		       32		      .byte.b	50
      0  1f7a					      db	(S4a-*)-1
      1  1f7a		       03		      .byte.b	(S4a-*)-1
      0  1f7b					      IJMP	S6
      0  1f7b					      db	29
      1  1f7b		       1d		      .byte.b	29
      0  1f7c					      dw	S6
      1  1f7c		       93 1f		      .word.w	S6
    145  1f7e
    146  1f7e				   S4a
      0  1f7e					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  1f7e					      db	101
      1  1f7e		       65		      .byte.b	101
      0  1f7f					      db	(S7-*)-1
      1  1f7f		       20		      .byte.b	(S7-*)-1
      0  1f80					      db	tString
      1  1f80		       a0		      .byte.b	tString
      0  1f81					      PRS		; PRINT STRING
      0  1f81					      db	2
      1  1f81		       02		      .byte.b	2
    149  1f82				   S5
      0  1f82					      TSTB	S6A,oComma	; IS THERE MORE?
      0  1f82					      db	101
      1  1f82		       65		      .byte.b	101
      0  1f83					      db	(S6A-*)-1
      1  1f83		       07		      .byte.b	(S6A-*)-1
      0  1f84					      db	oComma
      1  1f84		       e2		      .byte.b	oComma
      0  1f85					      SPC		; SPACE TO NEXT ZONE
      0  1f85					      db	4
      1  1f85		       04		      .byte.b	4
      0  1f86					      TSTDONE	S4	; Not end of line jump back
      0  1f86					      db	50
      1  1f86		       32		      .byte.b	50
      0  1f87					      db	(S4-*)-1
      1  1f87		       f1		      .byte.b	(S4-*)-1
      0  1f88					      IJMP	S6Z	; YES JUMP BACK
      0  1f88					      db	29
      1  1f88		       1d		      .byte.b	29
      0  1f89					      dw	S6Z
      1  1f89		       95 1f		      .word.w	S6Z
    154  1f8b
    155  1f8b							;
    156  1f8b							; If a semicolon, don't do anything.
    157  1f8b							;
    158  1f8b				   S6A
      0  1f8b					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  1f8b					      db	101
      1  1f8b		       65		      .byte.b	101
      0  1f8c					      db	(S6-*)-1
      1  1f8c		       06		      .byte.b	(S6-*)-1
      0  1f8d					      db	oSemiColon
      1  1f8d		       e3		      .byte.b	oSemiColon
      0  1f8e					      TSTDONE	S4	; Jump Back if not end of line
      0  1f8e					      db	50
      1  1f8e		       32		      .byte.b	50
      0  1f8f					      db	(S4-*)-1
      1  1f8f		       e9		      .byte.b	(S4-*)-1
      0  1f90					      IJMP	S6Z
      0  1f90					      db	29
      1  1f90		       1d		      .byte.b	29
      0  1f91					      dw	S6Z
      1  1f91		       95 1f		      .word.w	S6Z
    162  1f93
    163  1f93				   S6
    164  1f93
      0  1f93					      DONE		; ERROR IF CR NOT NEXT
      0  1f93					      db	1
      1  1f93		       01		      .byte.b	1
      0  1f94					      NLINE
      0  1f94					      db	5
      1  1f94		       05		      .byte.b	5
    167  1f95				   S6Z
      0  1f95					      ENDIO		; release task io completed
      0  1f95					      db	71
      1  1f95		       47		      .byte.b	71
      0  1f96					      NXT	CO	; exit here if , or ; at end of print
      0  1f96					      db	6
      1  1f96		       06		      .byte.b	6
      0  1f97					      dw	CO
      1  1f97		       e2 1e		      .word.w	CO
      0  1f99					      IJMP	STMT
      0  1f99					      db	29
      1  1f99		       1d		      .byte.b	29
      0  1f9a					      dw	STMT
      1  1f9a		       ea 1e		      .word.w	STMT
    171  1f9c							;
    172  1f9c							; A jump for code too far away for relative branch
    173  1f9c							;
    174  1f9c				   ERRVEC
      0  1f9c					      ENDIO
      0  1f9c					      db	71
      1  1f9c		       47		      .byte.b	71
      0  1f9d					      IJMP	UNKNOWN
      0  1f9d					      db	29
      1  1f9d		       1d		      .byte.b	29
      0  1f9e					      dw	UNKNOWN
      1  1f9e		       e9 20		      .word.w	UNKNOWN
    177  1fa0							;
    178  1fa0							; Get here if there is an expression to print
    179  1fa0				   S7
      0  1fa0					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  1fa0					      db	101
      1  1fa0		       65		      .byte.b	101
      0  1fa1					      db	(S7AUnsigned-*)-1
      1  1fa1		       08		      .byte.b	(S7AUnsigned-*)-1
      0  1fa2					      db	oDollar
      1  1fa2		       e7		      .byte.b	oDollar
      0  1fa3					      CALL	EXPR
      0  1fa3					      db	28
      1  1fa3		       1c		      .byte.b	28
      0  1fa4					      dw	EXPR
      1  1fa4		       ed 20		      .word.w	EXPR
      0  1fa6					      HEXPRT
      0  1fa6					      db	67
      1  1fa6		       43		      .byte.b	67
      0  1fa7					      IJMP	S5
      0  1fa7					      db	29
      1  1fa7		       1d		      .byte.b	29
      0  1fa8					      dw	S5
      1  1fa8		       82 1f		      .word.w	S5
    184  1faa
    185  1faa				   S7AUnsigned
    186  1faa
      0  1faa					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  1faa					      db	101
      1  1faa		       65		      .byte.b	101
      0  1fab					      db	(S7A-*)-1
      1  1fab		       0a		      .byte.b	(S7A-*)-1
      0  1fac					      db	oPercent
      1  1fac		       f9		      .byte.b	oPercent
      0  1fad					      CALL	EXPR
      0  1fad					      db	28
      1  1fad		       1c		      .byte.b	28
      0  1fae					      dw	EXPR
      1  1fae		       ed 20		      .word.w	EXPR
      0  1fb0					      SETR2	1
      0  1fb0					      db	94
      1  1fb0		       5e		      .byte.b	94
      0  1fb1					      db	1
      1  1fb1		       01		      .byte.b	1
      0  1fb2					      PRN
      0  1fb2					      db	3
      1  1fb2		       03		      .byte.b	3
      0  1fb3					      IJMP	S5
      0  1fb3					      db	29
      1  1fb3		       1d		      .byte.b	29
      0  1fb4					      dw	S5
      1  1fb4		       82 1f		      .word.w	S5
    192  1fb6
    193  1fb6				   S7A
    194  1fb6
      0  1fb6					      CALL	EXPR
      0  1fb6					      db	28
      1  1fb6		       1c		      .byte.b	28
      0  1fb7					      dw	EXPR
      1  1fb7		       ed 20		      .word.w	EXPR
      0  1fb9					      TSTB	S7B,oDollar	; Print the value as a single character
      0  1fb9					      db	101
      1  1fb9		       65		      .byte.b	101
      0  1fba					      db	(S7B-*)-1
      1  1fba		       05		      .byte.b	(S7B-*)-1
      0  1fbb					      db	oDollar
      1  1fbb		       e7		      .byte.b	oDollar
      0  1fbc					      PUTCHAR
      0  1fbc					      db	52
      1  1fbc		       34		      .byte.b	52
      0  1fbd					      IJMP	S5
      0  1fbd					      db	29
      1  1fbd		       1d		      .byte.b	29
      0  1fbe					      dw	S5
      1  1fbe		       82 1f		      .word.w	S5
    199  1fc0
    200  1fc0				   S7B
      0  1fc0					      SETR2	0	; Print the value as a signed number
      0  1fc0					      db	94
      1  1fc0		       5e		      .byte.b	94
      0  1fc1					      db	0
      1  1fc1		       00		      .byte.b	0
      0  1fc2					      PRN		; PRINT IT
      0  1fc2					      db	3
      1  1fc2		       03		      .byte.b	3
      0  1fc3					      IJMP	S5	; IS THERE MORE?
      0  1fc3					      db	29
      1  1fc3		       1d		      .byte.b	29
      0  1fc4					      dw	S5
      1  1fc4		       82 1f		      .word.w	S5
    204  1fc6							;
    205  1fc6							;===========================================================
    206  1fc6							; PROCESS ALL THE TAST STATEMENTS
    207  1fc6							;
    208  1fc6				   S8
      0  1fc6					      TSTB	S8G,kTaske	; End Task
      0  1fc6					      db	101
      1  1fc6		       65		      .byte.b	101
      0  1fc7					      db	(S8G-*)-1
      1  1fc7		       17		      .byte.b	(S8G-*)-1
      0  1fc8					      db	kTaske
      1  1fc8		       0c		      .byte.b	kTaske
      0  1fc9					      TSTB	S8NoParm,oLeftBracket
      0  1fc9					      db	101
      1  1fc9		       65		      .byte.b	101
      0  1fca					      db	(S8NoParm-*)-1
      1  1fca		       0c		      .byte.b	(S8NoParm-*)-1
      0  1fcb					      db	oLeftBracket
      1  1fcb		       e0		      .byte.b	oLeftBracket
      0  1fcc					      CALL	EXPR
      0  1fcc					      db	28
      1  1fcc		       1c		      .byte.b	28
      0  1fcd					      dw	EXPR
      1  1fcd		       ed 20		      .word.w	EXPR
      0  1fcf					      TSTB	UNKNOWNLnk,oRightBracket
      0  1fcf					      db	101
      1  1fcf		       65		      .byte.b	101
      0  1fd0					      db	(UNKNOWNLnk-*)-1
      1  1fd0		       34		      .byte.b	(UNKNOWNLnk-*)-1
      0  1fd1					      db	oRightBracket
      1  1fd1		       e1		      .byte.b	oRightBracket
      0  1fd2					      ETASK
      0  1fd2					      db	62
      1  1fd2		       3e		      .byte.b	62
      0  1fd3					      DONE
      0  1fd3					      db	1
      1  1fd3		       01		      .byte.b	1
      0  1fd4					      IJMP	STMT
      0  1fd4					      db	29
      1  1fd4		       1d		      .byte.b	29
      0  1fd5					      dw	STMT
      1  1fd5		       ea 1e		      .word.w	STMT
    216  1fd7				   S8NoParm
      0  1fd7					      LIT	0
      0  1fd7					      db	27
      1  1fd7		       1b		      .byte.b	27
      0  1fd8					      dw	0
      1  1fd8		       00 00		      .word.w	0
      0  1fda					      ETASK
      0  1fda					      db	62
      1  1fda		       3e		      .byte.b	62
      0  1fdb					      DONE		; Must be last thing on a line
      0  1fdb					      db	1
      1  1fdb		       01		      .byte.b	1
      0  1fdc					      IJMP	STMT
      0  1fdc					      db	29
      1  1fdc		       1d		      .byte.b	29
      0  1fdd					      dw	STMT
      1  1fdd		       ea 1e		      .word.w	STMT
    221  1fdf							;
    222  1fdf							;===========================================================
    223  1fdf							; The task gives up the rest of the cycles
    224  1fdf				   S8G
      0  1fdf					      TSTB	S8a,kTaskn	;Next task
      0  1fdf					      db	101
      1  1fdf		       65		      .byte.b	101
      0  1fe0					      db	(S8a-*)-1
      1  1fe0		       08		      .byte.b	(S8a-*)-1
      0  1fe1					      db	kTaskn
      1  1fe1		       0d		      .byte.b	kTaskn
      0  1fe2					      NTASK
      0  1fe2					      db	63
      1  1fe2		       3f		      .byte.b	63
      0  1fe3					      NXT	CO	;Next statement to execute
      0  1fe3					      db	6
      1  1fe3		       06		      .byte.b	6
      0  1fe4					      dw	CO
      1  1fe4		       e2 1e		      .word.w	CO
      0  1fe6					      IJMP	STMT
      0  1fe6					      db	29
      1  1fe6		       1d		      .byte.b	29
      0  1fe7					      dw	STMT
      1  1fe7		       ea 1e		      .word.w	STMT
    229  1fe9							;
    230  1fe9							;===========================================================
    231  1fe9							; Waits for a task or list of tasks to complete
    232  1fe9				   S8a
      0  1fe9					      TSTB	S8TASKNO,kTaskw	;Wait for tasks
      0  1fe9					      db	101
      1  1fe9		       65		      .byte.b	101
      0  1fea					      db	(S8TASKNO-*)-1
      1  1fea		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1feb					      db	kTaskw
      1  1feb		       0e		      .byte.b	kTaskw
      0  1fec					      TSTB	UNKNOWNLnk,oLeftBracket
      0  1fec					      db	101
      1  1fec		       65		      .byte.b	101
      0  1fed					      db	(UNKNOWNLnk-*)-1
      1  1fed		       17		      .byte.b	(UNKNOWNLnk-*)-1
      0  1fee					      db	oLeftBracket
      1  1fee		       e0		      .byte.b	oLeftBracket
    235  1fef				   S8TSK
      0  1fef					      Call	EXPR	;Gets the PID of task to wait for
      0  1fef					      db	28
      1  1fef		       1c		      .byte.b	28
      0  1ff0					      dw	EXPR
      1  1ff0		       ed 20		      .word.w	EXPR
    237  1ff2				   S8LOOP
      0  1ff2					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1ff2					      db	76
      1  1ff2		       4c		      .byte.b	76
      0  1ff3					      db	(S8LOOP-*)-1
      1  1ff3		       fe		      .byte.b	(S8LOOP-*)-1
      0  1ff4					      TST	S8aa,COMMA	;Checks for more tasks
      0  1ff4					      db	32
      1  1ff4		       20		      .byte.b	32
      0  1ff5					      db	(S8aa-*)-1
      1  1ff5		       05		      .byte.b	(S8aa-*)-1
      0  1ff6					      db	COMMA,0
      1  1ff6		       2c 00		      .byte.b	COMMA,0
      0  1ff8					      IJMP	S8TSK	;Go for the next task number
      0  1ff8					      db	29
      1  1ff8		       1d		      .byte.b	29
      0  1ff9					      dw	S8TSK
      1  1ff9		       ef 1f		      .word.w	S8TSK
    241  1ffb				   S8aa
      0  1ffb					      TSTB	S8TASKNO,oRightBracket	;end of list
      0  1ffb					      db	101
      1  1ffb		       65		      .byte.b	101
      0  1ffc					      db	(S8TASKNO-*)-1
      1  1ffc		       08		      .byte.b	(S8TASKNO-*)-1
      0  1ffd					      db	oRightBracket
      1  1ffd		       e1		      .byte.b	oRightBracket
      0  1ffe					      DONE
      0  1ffe					      db	1
      1  1ffe		       01		      .byte.b	1
      0  1fff					      NXT	CO
      0  1fff					      db	6
      1  1fff		       06		      .byte.b	6
      0  2000					      dw	CO
      1  2000		       e2 1e		      .word.w	CO
      0  2002					      IJMP	STMT	;Next Statement
      0  2002					      db	29
      1  2002		       1d		      .byte.b	29
      0  2003					      dw	STMT
      1  2003		       ea 1e		      .word.w	STMT
    246  2005
    247  2005				   S8TASKNO
    248  2005
    249  2005				   UNKNOWNLnk
      0  2005					      iJMP	UNKNOWN
      0  2005					      db	29
      1  2005		       1d		      .byte.b	29
      0  2006					      dw	UNKNOWN
      1  2006		       e9 20		      .word.w	UNKNOWN
    251  2008
    252  2008							;
    253  2008							;===========================================================
    254  2008							; Update a memory location with a value
    255  2008							;  Use @[offset] to write a word value to memory
    256  2008							;
    257  2008				   S8a1
      0  2008					      TSTB	S8b,kPoke	; Poke a value into memory
      0  2008					      db	101
      1  2008		       65		      .byte.b	101
      0  2009					      db	(S8b-*)-1
      1  2009		       18		      .byte.b	(S8b-*)-1
      0  200a					      db	kPoke
      1  200a		       0f		      .byte.b	kPoke
      0  200b					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  200b					      db	101
      1  200b		       65		      .byte.b	101
      0  200c					      db	(UNKNOWNV-*)-1
      1  200c		       56		      .byte.b	(UNKNOWNV-*)-1
      0  200d					      db	oLeftBracket
      1  200d		       e0		      .byte.b	oLeftBracket
      0  200e					      CALL	EXPR	; Get address to write to
      0  200e					      db	28
      1  200e		       1c		      .byte.b	28
      0  200f					      dw	EXPR
      1  200f		       ed 20		      .word.w	EXPR
      0  2011					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  2011					      db	101
      1  2011		       65		      .byte.b	101
      0  2012					      db	(UNKNOWNV-*)-1
      1  2012		       50		      .byte.b	(UNKNOWNV-*)-1
      0  2013					      db	oComma
      1  2013		       e2		      .byte.b	oComma
      0  2014					      CALL	EXPR	; Get the value to poke
      0  2014					      db	28
      1  2014		       1c		      .byte.b	28
      0  2015					      dw	EXPR
      1  2015		       ed 20		      .word.w	EXPR
      0  2017					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  2017					      db	101
      1  2017		       65		      .byte.b	101
      0  2018					      db	(UNKNOWNV-*)-1
      1  2018		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  2019					      db	oRightBracket
      1  2019		       e1		      .byte.b	oRightBracket
      0  201a					      POKEMEM
      0  201a					      db	47
      1  201a		       2f		      .byte.b	47
      0  201b					      DONE
      0  201b					      db	1
      1  201b		       01		      .byte.b	1
      0  201c					      NXT	CO	;AND SEQUENCE TO NEXT
      0  201c					      db	6
      1  201c		       06		      .byte.b	6
      0  201d					      dw	CO
      1  201d		       e2 1e		      .word.w	CO
      0  201f					      IJMP	STMT
      0  201f					      db	29
      1  201f		       1d		      .byte.b	29
      0  2020					      dw	STMT
      1  2020		       ea 1e		      .word.w	STMT
    268  2022							;================================================================
    269  2022							; Write a single byte to the output device
    270  2022							;
    271  2022				   S8b
      0  2022					      TSTB	S8c,kPutch	;Put a char to the terminal
      0  2022					      db	101
      1  2022		       65		      .byte.b	101
      0  2023					      db	(S8c-*)-1
      1  2023		       0c		      .byte.b	(S8c-*)-1
      0  2024					      db	kPutch
      1  2024		       10		      .byte.b	kPutch
      0  2025					      CALL	EXPR
      0  2025					      db	28
      1  2025		       1c		      .byte.b	28
      0  2026					      dw	EXPR
      1  2026		       ed 20		      .word.w	EXPR
      0  2028					      PUTCHAR
      0  2028					      db	52
      1  2028		       34		      .byte.b	52
      0  2029					      DONE
      0  2029					      db	1
      1  2029		       01		      .byte.b	1
      0  202a					      NXT	CO	;AND SEQUENCE TO NEXT
      0  202a					      db	6
      1  202a		       06		      .byte.b	6
      0  202b					      dw	CO
      1  202b		       e2 1e		      .word.w	CO
      0  202d					      IJMP	STMT
      0  202d					      db	29
      1  202d		       1d		      .byte.b	29
      0  202e					      dw	STMT
      1  202e		       ea 1e		      .word.w	STMT
    278  2030							;================================================================
    279  2030							; Clear the screen lines
    280  2030							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    281  2030							;
    282  2030				   S8c
      0  2030					      TSTB	S9,kCls	;Clear the screen
      0  2030					      db	101
      1  2030		       65		      .byte.b	101
      0  2031					      db	(S9-*)-1
      1  2031		       08		      .byte.b	(S9-*)-1
      0  2032					      db	kCls
      1  2032		       11		      .byte.b	kCls
      0  2033					      CLEARSCREEN
      0  2033					      db	46
      1  2033		       2e		      .byte.b	46
      0  2034					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2034					      db	6
      1  2034		       06		      .byte.b	6
      0  2035					      dw	CO
      1  2035		       e2 1e		      .word.w	CO
      0  2037					      IJMP	STMT
      0  2037					      db	29
      1  2037		       1d		      .byte.b	29
      0  2038					      dw	STMT
      1  2038		       ea 1e		      .word.w	STMT
    287  203a							;==================================================================
    288  203a							; Get input from the terminal
    289  203a							;   Reads from the currently active input device
    290  203a							;
    291  203a				   S9
      0  203a					      TSTB	S13,kInput	;INPUT STATEMENT
      0  203a					      db	101
      1  203a		       65		      .byte.b	101
      0  203b					      db	(S13-*)-1
      1  203b		       23		      .byte.b	(S13-*)-1
      0  203c					      db	kInput
      1  203c		       12		      .byte.b	kInput
    293  203d				   S10
      0  203d					      TSTB	S10A,tString	;If there is a string print the prompt
      0  203d					      db	101
      1  203d		       65		      .byte.b	101
      0  203e					      db	(S10A-*)-1
      1  203e		       05		      .byte.b	(S10A-*)-1
      0  203f					      db	tString
      1  203f		       a0		      .byte.b	tString
      0  2040					      PRS
      0  2040					      db	2
      1  2040		       02		      .byte.b	2
      0  2041					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  2041					      db	101
      1  2041		       65		      .byte.b	101
      0  2042					      db	(S10Z-*)-1
      1  2042		       12		      .byte.b	(S10Z-*)-1
      0  2043					      db	oSemiColon
      1  2043		       e3		      .byte.b	oSemiColon
    297  2044				   S10A
      0  2044					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  2044					      db	33
      1  2044		       21		      .byte.b	33
      0  2045					      db	(UNKNOWN-*)-1
      1  2045		       a3		      .byte.b	(UNKNOWN-*)-1
      0  2046					      TSTB	S10A1,oDollar
      0  2046					      db	101
      1  2046		       65		      .byte.b	101
      0  2047					      db	(S10A1-*)-1
      1  2047		       05		      .byte.b	(S10A1-*)-1
      0  2048					      db	oDollar
      1  2048		       e7		      .byte.b	oDollar
      0  2049					      INSTR		;Move character From tty to AESTK
      0  2049					      db	59
      1  2049		       3b		      .byte.b	59
      0  204a					      IJMP	S10A2
      0  204a					      db	29
      1  204a		       1d		      .byte.b	29
      0  204b					      dw	S10A2
      1  204b		       4e 20		      .word.w	S10A2
    302  204d				   S10A1
      0  204d					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  204d					      db	11
      1  204d		       0b		      .byte.b	11
    304  204e				   S10A2
      0  204e					      STORE		;STORE IT
      0  204e					      db	19
      1  204e		       13		      .byte.b	19
      0  204f					      TSTB	S11,oComma	;IS THERE MORE?
      0  204f					      db	101
      1  204f		       65		      .byte.b	101
      0  2050					      db	(S11-*)-1
      1  2050		       07		      .byte.b	(S11-*)-1
      0  2051					      db	oComma
      1  2051		       e2		      .byte.b	oComma
      0  2052					      IJMP	S10	;YES
      0  2052					      db	29
      1  2052		       1d		      .byte.b	29
      0  2053					      dw	S10
      1  2053		       3d 20		      .word.w	S10
    308  2055				   S10Z
      0  2055					      iJMP	UNKNOWN
      0  2055					      db	29
      1  2055		       1d		      .byte.b	29
      0  2056					      dw	UNKNOWN
      1  2056		       e9 20		      .word.w	UNKNOWN
    310  2058				   S11
      0  2058					      DONE		;MUST BE CR
      0  2058					      db	1
      1  2058		       01		      .byte.b	1
      0  2059					      NXT	CO	;SEQUENCE TO NEXT
      0  2059					      db	6
      1  2059		       06		      .byte.b	6
      0  205a					      dw	CO
      1  205a		       e2 1e		      .word.w	CO
      0  205c					      IJMP	STMT
      0  205c					      db	29
      1  205c		       1d		      .byte.b	29
      0  205d					      dw	STMT
      1  205d		       ea 1e		      .word.w	STMT
    314  205f							;=====================================================================
    315  205f							; End of program, return to command line process
    316  205f							; Main Task may also use taske or return to stopped
    317  205f							;
    318  205f				   S13
      0  205f					      TSTB	S14,kEnd
      0  205f					      db	101
      1  205f		       65		      .byte.b	101
      0  2060					      db	(S14-*)-1
      1  2060		       05		      .byte.b	(S14-*)-1
      0  2061					      db	kEnd
      1  2061		       13		      .byte.b	kEnd
      0  2062					      FIN
      0  2062					      db	12
      1  2062		       0c		      .byte.b	12
    321  2063
    322  2063				   UNKNOWNV
      0  2063					      IJMP	UNKNOWN
      0  2063					      db	29
      1  2063		       1d		      .byte.b	29
      0  2064					      dw	UNKNOWN
      1  2064		       e9 20		      .word.w	UNKNOWN
    324  2066							;====================================================================
    325  2066							; IRQ <IRQ-HANDLER-Line expression>
    326  2066							;   Specify a line number subroutine to call when an interupt is processed
    327  2066							;   These subroutines must use iret to return.
    328  2066							;
    329  2066				   S14
      0  2066					      TSTB	S14Z,kIrq	;Check if we are setting IRQ HANDLER
      0  2066					      db	101
      1  2066		       65		      .byte.b	101
      0  2067					      db	(S14Z-*)-1
      1  2067		       0c		      .byte.b	(S14Z-*)-1
      0  2068					      db	kIrq
      1  2068		       14		      .byte.b	kIrq
      0  2069					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2069					      db	28
      1  2069		       1c		      .byte.b	28
      0  206a					      dw	EXPR
      1  206a		       ed 20		      .word.w	EXPR
      0  206c					      DONE		;must be CR
      0  206c					      db	1
      1  206c		       01		      .byte.b	1
      0  206d					      SETIRQ		;Set the line number now
      0  206d					      db	56
      1  206d		       38		      .byte.b	56
      0  206e					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  206e					      db	6
      1  206e		       06		      .byte.b	6
      0  206f					      dw	CO
      1  206f		       e2 1e		      .word.w	CO
      0  2071					      IJMP	STMT
      0  2071					      db	29
      1  2071		       1d		      .byte.b	29
      0  2072					      dw	STMT
      1  2072		       ea 1e		      .word.w	STMT
    336  2074
    337  2074							;=========================================================================
    338  2074							; KILL PID-expression	 kill a running task
    339  2074							;  ignored of task has already stopped
    340  2074							;
    341  2074				   S14Z
      0  2074					      TSTB	S14S1,kKill	; Kill A running Task
      0  2074					      db	101
      1  2074		       65		      .byte.b	101
      0  2075					      db	(S14S1-*)-1
      1  2075		       0c		      .byte.b	(S14S1-*)-1
      0  2076					      db	kKill
      1  2076		       15		      .byte.b	kKill
      0  2077					      CALL	EXPR
      0  2077					      db	28
      1  2077		       1c		      .byte.b	28
      0  2078					      dw	EXPR
      1  2078		       ed 20		      .word.w	EXPR
      0  207a					      DONE
      0  207a					      db	1
      1  207a		       01		      .byte.b	1
      0  207b					      TASKKILL
      0  207b					      db	65
      1  207b		       41		      .byte.b	65
      0  207c					      NXT	CO
      0  207c					      db	6
      1  207c		       06		      .byte.b	6
      0  207d					      dw	CO
      1  207d		       e2 1e		      .word.w	CO
      0  207f					      IJMP	STMT
      0  207f					      db	29
      1  207f		       1d		      .byte.b	29
      0  2080					      dw	STMT
      1  2080		       ea 1e		      .word.w	STMT
    348  2082
    349  2082							;============================================================================
    350  2082							; List all program lines
    351  2082							;
    352  2082				   S14S1
      0  2082					      TSTB	S15,kList	;LIST COMMAND
      0  2082					      db	101
      1  2082		       65		      .byte.b	101
      0  2083					      db	(S15-*)-1
      1  2083		       06		      .byte.b	(S15-*)-1
      0  2084					      db	kList
      1  2084		       16		      .byte.b	kList
      0  2085					      DONE
      0  2085					      db	1
      1  2085		       01		      .byte.b	1
      0  2086					      LST
      0  2086					      db	21
      1  2086		       15		      .byte.b	21
      0  2087					      IJMP	CO
      0  2087					      db	29
      1  2087		       1d		      .byte.b	29
      0  2088					      dw	CO
      1  2088		       e2 1e		      .word.w	CO
    357  208a							;=======================================================================
    358  208a							;RUN begin to executed the program in memory
    359  208a							;
    360  208a				   S15
      0  208a					      TSTB	S16,kRun	;RUN COMMAND
      0  208a					      db	101
      1  208a		       65		      .byte.b	101
      0  208b					      db	(S16-*)-1
      1  208b		       0a		      .byte.b	(S16-*)-1
      0  208c					      db	kRun
      1  208c		       17		      .byte.b	kRun
      0  208d					      DONE
      0  208d					      db	1
      1  208d		       01		      .byte.b	1
      0  208e					      VINIT		;clear variables
      0  208e					      db	30
      1  208e		       1e		      .byte.b	30
      0  208f					      LIT	1	;GOTO line 1
      0  208f					      db	27
      1  208f		       1b		      .byte.b	27
      0  2090					      dw	1
      1  2090		       01 00		      .word.w	1
      0  2092					      XFER		;Bob's addition
      0  2092					      db	7
      1  2092		       07		      .byte.b	7
    366  2093							; EXIT
      0  2093					      IJMP	STMT	;and run!
      0  2093					      db	29
      1  2093		       1d		      .byte.b	29
      0  2094					      dw	STMT
      1  2094		       ea 1e		      .word.w	STMT
    368  2096							;=========================================================================
    369  2096							;Clear the program memory, delete all proram lines
    370  2096							;
    371  2096				   S16
      0  2096					      TSTB	S16A,kNew	;clear program
      0  2096					      db	101
      1  2096		       65		      .byte.b	101
      0  2097					      db	(S16A-*)-1
      1  2097		       05		      .byte.b	(S16A-*)-1
      0  2098					      db	kNew
      1  2098		       18		      .byte.b	kNew
      0  2099					      DONE
      0  2099					      db	1
      1  2099		       01		      .byte.b	1
      0  209a					      IJMP	START
      0  209a					      db	29
      1  209a		       1d		      .byte.b	29
      0  209b					      dw	START
      1  209b		       dc 1e		      .word.w	START
    375  209d
    376  209d							;========================================================================
    377  209d							; Slice(slice legth expression)
    378  209d							;   set the length of time between task switches
    379  209d							;
    380  209d				   S16A
      0  209d					      TSTB	S16Trace,kSlice
      0  209d					      db	101
      1  209d		       65		      .byte.b	101
      0  209e					      db	(S16Trace-*)-1
      1  209e		       0c		      .byte.b	(S16Trace-*)-1
      0  209f					      db	kSlice
      1  209f		       19		      .byte.b	kSlice
      0  20a0					      CALL	EXPR
      0  20a0					      db	28
      1  20a0		       1c		      .byte.b	28
      0  20a1					      dw	EXPR
      1  20a1		       ed 20		      .word.w	EXPR
      0  20a3					      SLICE
      0  20a3					      db	100
      1  20a3		       64		      .byte.b	100
      0  20a4					      DONE
      0  20a4					      db	1
      1  20a4		       01		      .byte.b	1
      0  20a5					      NXT	CO
      0  20a5					      db	6
      1  20a5		       06		      .byte.b	6
      0  20a6					      dw	CO
      1  20a6		       e2 1e		      .word.w	CO
      0  20a8					      IJMP	STMT
      0  20a8					      db	29
      1  20a8		       1d		      .byte.b	29
      0  20a9					      dw	STMT
      1  20a9		       ea 1e		      .word.w	STMT
    387  20ab							;==========================================================================
    388  20ab							; Turn off and on the thrace functions
    389  20ab							; a debug terminal needs to be available
    390  20ab							; Trace( Trace flag expression)
    391  20ab							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    392  20ab							;	for individual lines of basic code. These can be combined
    393  20ab				   S16Trace
      0  20ab					      TSTB	S17A,kTrace
      0  20ab					      db	101
      1  20ab		       65		      .byte.b	101
      0  20ac					      db	(S17A-*)-1
      1  20ac		       12		      .byte.b	(S17A-*)-1
      0  20ad					      db	kTrace
      1  20ad		       1a		      .byte.b	kTrace
      0  20ae					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  20ae					      db	101
      1  20ae		       65		      .byte.b	101
      0  20af					      db	(UNKNOWN-*)-1
      1  20af		       39		      .byte.b	(UNKNOWN-*)-1
      0  20b0					      db	oLeftBracket
      1  20b0		       e0		      .byte.b	oLeftBracket
      0  20b1					      CALL	EXPR
      0  20b1					      db	28
      1  20b1		       1c		      .byte.b	28
      0  20b2					      dw	EXPR
      1  20b2		       ed 20		      .word.w	EXPR
      0  20b4					      TSTB	UNKNOWN,oRightBracket
      0  20b4					      db	101
      1  20b4		       65		      .byte.b	101
      0  20b5					      db	(UNKNOWN-*)-1
      1  20b5		       33		      .byte.b	(UNKNOWN-*)-1
      0  20b6					      db	oRightBracket
      1  20b6		       e1		      .byte.b	oRightBracket
      0  20b7					      TRACEPROGRAM
      0  20b7					      db	78
      1  20b7		       4e		      .byte.b	78
      0  20b8					      DONE
      0  20b8					      db	1
      1  20b8		       01		      .byte.b	1
      0  20b9					      NXT	CO
      0  20b9					      db	6
      1  20b9		       06		      .byte.b	6
      0  20ba					      dw	CO
      1  20ba		       e2 1e		      .word.w	CO
      0  20bc					      IJMP	STMT
      0  20bc					      db	29
      1  20bc		       1d		      .byte.b	29
      0  20bd					      dw	STMT
      1  20bd		       ea 1e		      .word.w	STMT
    402  20bf							;=====================================================================
    403  20bf							; Exit basic to machine monitor
    404  20bf							;
    405  20bf				   S17A
      0  20bf					      TSTB	S17B,kExit	;allow them to exit BASIC
      0  20bf					      db	101
      1  20bf		       65		      .byte.b	101
      0  20c0					      db	(S17B-*)-1
      1  20c0		       02		      .byte.b	(S17B-*)-1
      0  20c1					      db	kExit
      1  20c1		       1b		      .byte.b	kExit
      0  20c2					      EXIT
      0  20c2					      db	26
      1  20c2		       1a		      .byte.b	26
    408  20c3
    409  20c3							;=======================================================================
    410  20c3							; Commands related to saving/restoring programs
    411  20c3							; to/from mass storage.
    412  20c3							;
    413  20c3				   S17B
    414  20c3					      if	(XKIM || CTMON65) && DISK_ACCESS
    415  20c3
      0  20c3					      TSTB	S17C,kSave
      0  20c3					      db	101
      1  20c3		       65		      .byte.b	101
      0  20c4					      db	(S17C-*)-1
      1  20c4		       07		      .byte.b	(S17C-*)-1
      0  20c5					      db	kSave
      1  20c5		       1c		      .byte.b	kSave
      0  20c6					      OPENWRITE
      0  20c6					      db	40
      1  20c6		       28		      .byte.b	40
      0  20c7					      DLIST
      0  20c7					      db	43
      1  20c7		       2b		      .byte.b	43
      0  20c8					      DCLOSE
      0  20c8					      db	41
      1  20c8		       29		      .byte.b	41
      0  20c9					      IJMP	CO
      0  20c9					      db	29
      1  20c9		       1d		      .byte.b	29
      0  20ca					      dw	CO
      1  20ca		       e2 1e		      .word.w	CO
    421  20cc
    422  20cc				   S17C
      0  20cc					      TSTB	S18,kLoad
      0  20cc					      db	101
      1  20cc		       65		      .byte.b	101
      0  20cd					      db	(S18-*)-1
      1  20cd		       0d		      .byte.b	(S18-*)-1
      0  20ce					      db	kLoad
      1  20ce		       1d		      .byte.b	kLoad
      0  20cf					      OPENREAD
      0  20cf					      db	39
      1  20cf		       27		      .byte.b	39
    425  20d0				   S17CLP
      0  20d0					      DGETLINE		;get line from file
      0  20d0					      db	42
      1  20d0		       2a		      .byte.b	42
      0  20d1					      TSTL	S17EOL	;no line num means EOL
      0  20d1					      db	34
      1  20d1		       22		      .byte.b	34
      0  20d2					      db	(S17EOL-*)-1
      1  20d2		       04		      .byte.b	(S17EOL-*)-1
      0  20d3					      INSERT		;put it into the program
      0  20d3					      db	24
      1  20d3		       18		      .byte.b	24
      0  20d4					      IJMP	S17CLP	;keep going
      0  20d4					      db	29
      1  20d4		       1d		      .byte.b	29
      0  20d5					      dw	S17CLP
      1  20d5		       d0 20		      .word.w	S17CLP
    430  20d7				   S17EOL
      0  20d7					      DCLOSE		;close disk file
      0  20d7					      db	41
      1  20d7		       29		      .byte.b	41
      0  20d8					      IJMP	CO	;back to start
      0  20d8					      db	29
      1  20d8		       1d		      .byte.b	29
      0  20d9					      dw	CO
      1  20d9		       e2 1e		      .word.w	CO
    433  20db
    434  20db				   S18
      0  20db					      TSTB	S19,kDir
      0  20db					      db	101
      1  20db		       65		      .byte.b	101
      0  20dc					      db	(S19-*)-1
      1  20dc		       05		      .byte.b	(S19-*)-1
      0  20dd					      db	kDir
      1  20dd		       25		      .byte.b	kDir
      0  20de					      DDIR		;Display the directory content
      0  20de					      db	44
      1  20de		       2c		      .byte.b	44
      0  20df					      IJMP	CO
      0  20df					      db	29
      1  20df		       1d		      .byte.b	29
      0  20e0					      dw	CO
      1  20e0		       e2 1e		      .word.w	CO
    438  20e2
      0  20e2				   S19	      TSTB	UNKNOWN,kErase
      0  20e2					      db	101
      1  20e2		       65		      .byte.b	101
      0  20e3					      db	(UNKNOWN-*)-1
      1  20e3		       05		      .byte.b	(UNKNOWN-*)-1
      0  20e4					      db	kErase
      1  20e4		       1e		      .byte.b	kErase
      0  20e5					      RMFILE		;Erase the file from the disk
      0  20e5					      db	45
      1  20e5		       2d		      .byte.b	45
      0  20e6					      IJMP	CO
      0  20e6					      db	29
      1  20e6		       1d		      .byte.b	29
      0  20e7					      dw	CO
      1  20e7		       e2 1e		      .word.w	CO
    442  20e9
    443  20e9					      endif
    444  20e9
    445  20e9							;
    446  20e9							; Else, unknown command.
    447  20e9							;
    448  20e9				   UNKNOWN
      0  20e9					      ENDIO
      0  20e9					      db	71
      1  20e9		       47		      .byte.b	71
      0  20ea					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  20ea					      db	13
      1  20ea		       0d		      .byte.b	13
      0  20eb					      dw	ERR_SYNTAX
      1  20eb		       05 00		      .word.w	ERR_SYNTAX
    451  20ed
    452  20ed							;=======================================================
    453  20ed							; Process Expresions, precidence is represented by the
    454  20ed							; various call levels
    455  20ed							;
    456  20ed				   EXPR
      0  20ed					      TSTB	EXPRLOGS,kNot
      0  20ed					      db	101
      1  20ed		       65		      .byte.b	101
      0  20ee					      db	(EXPRLOGS-*)-1
      1  20ee		       06		      .byte.b	(EXPRLOGS-*)-1
      0  20ef					      db	kNot
      1  20ef		       1f		      .byte.b	kNot
      0  20f0					      Call	EXPR
      0  20f0					      db	28
      1  20f0		       1c		      .byte.b	28
      0  20f1					      dw	EXPR
      1  20f1		       ed 20		      .word.w	EXPR
      0  20f3					      LOGNOT
      0  20f3					      db	72
      1  20f3		       48		      .byte.b	72
      0  20f4					      RTN
      0  20f4					      db	25
      1  20f4		       19		      .byte.b	25
    461  20f5
    462  20f5							;=========================================================
    463  20f5							;Look for logical operators
    464  20f5				   EXPRLOGS
      0  20f5					      Call	EXPRCMP
      0  20f5					      db	28
      1  20f5		       1c		      .byte.b	28
      0  20f6					      dw	EXPRCMP
      1  20f6		       14 21		      .word.w	EXPRCMP
      0  20f8					      TSTB	iLOG1,kAnd
      0  20f8					      db	101
      1  20f8		       65		      .byte.b	101
      0  20f9					      db	(iLOG1-*)-1
      1  20f9		       06		      .byte.b	(iLOG1-*)-1
      0  20fa					      db	kAnd
      1  20fa		       22		      .byte.b	kAnd
      0  20fb					      Call	EXPR
      0  20fb					      db	28
      1  20fb		       1c		      .byte.b	28
      0  20fc					      dw	EXPR
      1  20fc		       ed 20		      .word.w	EXPR
      0  20fe					      LOGAND
      0  20fe					      db	74
      1  20fe		       4a		      .byte.b	74
      0  20ff					      RTN
      0  20ff					      db	25
      1  20ff		       19		      .byte.b	25
    470  2100				   iLOG1
      0  2100					      TSTB	iLOG2,kOr
      0  2100					      db	101
      1  2100		       65		      .byte.b	101
      0  2101					      db	(iLOG2-*)-1
      1  2101		       06		      .byte.b	(iLOG2-*)-1
      0  2102					      db	kOr
      1  2102		       20		      .byte.b	kOr
      0  2103					      Call	EXPR
      0  2103					      db	28
      1  2103		       1c		      .byte.b	28
      0  2104					      dw	EXPR
      1  2104		       ed 20		      .word.w	EXPR
      0  2106					      LOGOR
      0  2106					      db	73
      1  2106		       49		      .byte.b	73
      0  2107					      RTN
      0  2107					      db	25
      1  2107		       19		      .byte.b	25
    475  2108				   iLOG2
      0  2108					      TST	iLOG3,"XOR"
      0  2108					      db	32
      1  2108		       20		      .byte.b	32
      0  2109					      db	(iLOG3-*)-1
      1  2109		       09		      .byte.b	(iLOG3-*)-1
      0  210a					      db	"XOR",0
      1  210a		       58 4f 52 00	      .byte.b	"XOR",0
      0  210e					      Call	EXPR
      0  210e					      db	28
      1  210e		       1c		      .byte.b	28
      0  210f					      dw	EXPR
      1  210f		       ed 20		      .word.w	EXPR
      0  2111					      LOGXOR
      0  2111					      db	75
      1  2111		       4b		      .byte.b	75
      0  2112					      RTN
      0  2112					      db	25
      1  2112		       19		      .byte.b	25
    480  2113				   iLOG3
      0  2113					      RTN
      0  2113					      db	25
      1  2113		       19		      .byte.b	25
    482  2114
    483  2114				   EXPRCMP
      0  2114					      Call	EXPR2	; get the first expression
      0  2114					      db	28
      1  2114		       1c		      .byte.b	28
      0  2115					      dw	EXPR2
      1  2115		       51 21		      .word.w	EXPR2
      0  2117					      TSTB	iR0,oEqual
      0  2117					      db	101
      1  2117		       65		      .byte.b	101
      0  2118					      db	(iR0-*)-1
      1  2118		       07		      .byte.b	(iR0-*)-1
      0  2119					      db	oEqual
      1  2119		       f2		      .byte.b	oEqual
      0  211a					      LIT	2	;=
      0  211a					      db	27
      1  211a		       1b		      .byte.b	27
      0  211b					      dw	2
      1  211b		       02 00		      .word.w	2
      0  211d					      IJMP	iRFound
      0  211d					      db	29
      1  211d		       1d		      .byte.b	29
      0  211e					      dw	iRFound
      1  211e		       4b 21		      .word.w	iRFound
    488  2120				   iR0
      0  2120					      TSTB	iR1,oLessEqual
      0  2120					      db	101
      1  2120		       65		      .byte.b	101
      0  2121					      db	(iR1-*)-1
      1  2121		       07		      .byte.b	(iR1-*)-1
      0  2122					      db	oLessEqual
      1  2122		       f3		      .byte.b	oLessEqual
      0  2123					      LIT	3	;<=
      0  2123					      db	27
      1  2123		       1b		      .byte.b	27
      0  2124					      dw	3
      1  2124		       03 00		      .word.w	3
      0  2126					      IJMP	iRFound
      0  2126					      db	29
      1  2126		       1d		      .byte.b	29
      0  2127					      dw	iRFound
      1  2127		       4b 21		      .word.w	iRFound
    492  2129				   iR1
      0  2129					      TSTB	iR3,oNotEqual
      0  2129					      db	101
      1  2129		       65		      .byte.b	101
      0  212a					      db	(iR3-*)-1
      1  212a		       07		      .byte.b	(iR3-*)-1
      0  212b					      db	oNotEqual
      1  212b		       f5		      .byte.b	oNotEqual
      0  212c					      LIT	5	;<>
      0  212c					      db	27
      1  212c		       1b		      .byte.b	27
      0  212d					      dw	5
      1  212d		       05 00		      .word.w	5
      0  212f					      IJMP	iRFound
      0  212f					      db	29
      1  212f		       1d		      .byte.b	29
      0  2130					      dw	iRFound
      1  2130		       4b 21		      .word.w	iRFound
    496  2132				   iR3
      0  2132					      TSTB	iR4,oLess
      0  2132					      db	101
      1  2132		       65		      .byte.b	101
      0  2133					      db	(iR4-*)-1
      1  2133		       07		      .byte.b	(iR4-*)-1
      0  2134					      db	oLess
      1  2134		       f1		      .byte.b	oLess
      0  2135					      LIT	1	;<
      0  2135					      db	27
      1  2135		       1b		      .byte.b	27
      0  2136					      dw	1
      1  2136		       01 00		      .word.w	1
      0  2138					      IJMP	iRFound
      0  2138					      db	29
      1  2138		       1d		      .byte.b	29
      0  2139					      dw	iRFound
      1  2139		       4b 21		      .word.w	iRFound
    500  213b				   iR4
      0  213b					      TST	iR5,oGreaterEqual
      0  213b					      db	32
      1  213b		       20		      .byte.b	32
      0  213c					      db	(iR5-*)-1
      1  213c		       08		      .byte.b	(iR5-*)-1
      0  213d					      db	oGreaterEqual,0
      1  213d		       f6 00		      .byte.b	oGreaterEqual,0
      0  213f					      LIT	6	;>=
      0  213f					      db	27
      1  213f		       1b		      .byte.b	27
      0  2140					      dw	6
      1  2140		       06 00		      .word.w	6
      0  2142					      IJMP	iRFound
      0  2142					      db	29
      1  2142		       1d		      .byte.b	29
      0  2143					      dw	iRFound
      1  2143		       4b 21		      .word.w	iRFound
    504  2145				   iR5
      0  2145					      TSTB	iRDone,oGreater
      0  2145					      db	101
      1  2145		       65		      .byte.b	101
      0  2146					      db	(iRDone-*)-1
      1  2146		       09		      .byte.b	(iRDone-*)-1
      0  2147					      db	oGreater
      1  2147		       f4		      .byte.b	oGreater
      0  2148					      LIT	4	;>
      0  2148					      db	27
      1  2148		       1b		      .byte.b	27
      0  2149					      dw	4
      1  2149		       04 00		      .word.w	4
    507  214b				   iRFound
      0  214b					      Call	EXPR	; get the right side of the expression
      0  214b					      db	28
      1  214b		       1c		      .byte.b	28
      0  214c					      dw	EXPR
      1  214c		       ed 20		      .word.w	EXPR
      0  214e					      CMPR		; Push the value of the true false onto the stack
      0  214e					      db	10
      1  214e		       0a		      .byte.b	10
      0  214f					      RTN
      0  214f					      db	25
      1  214f		       19		      .byte.b	25
    511  2150
    512  2150				   iRDone
      0  2150					      RTN
      0  2150					      db	25
      1  2150		       19		      .byte.b	25
    514  2151
    515  2151				   EXPR2
      0  2151					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  2151					      db	101
      1  2151		       65		      .byte.b	101
      0  2152					      db	(E0-*)-1
      1  2152		       08		      .byte.b	(E0-*)-1
      0  2153					      db	oMinus
      1  2153		       f7		      .byte.b	oMinus
      0  2154					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  2154					      db	28
      1  2154		       1c		      .byte.b	28
      0  2155					      dw	TERM
      1  2155		       77 21		      .word.w	TERM
      0  2157					      NEG		; Make value negated
      0  2157					      db	16
      1  2157		       10		      .byte.b	16
      0  2158					      IJMP	E1	; We have Left term process operators next
      0  2158					      db	29
      1  2158		       1d		      .byte.b	29
      0  2159					      dw	E1
      1  2159		       61 21		      .word.w	E1
    520  215b				   E0
      0  215b					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  215b					      db	101
      1  215b		       65		      .byte.b	101
      0  215c					      db	(E1A-*)-1
      1  215c		       01		      .byte.b	(E1A-*)-1
      0  215d					      db	oPlus
      1  215d		       f0		      .byte.b	oPlus
    522  215e				   E1A
      0  215e					      CALL	TERM	; Get the left term if it was not negated
      0  215e					      db	28
      1  215e		       1c		      .byte.b	28
      0  215f					      dw	TERM
      1  215f		       77 21		      .word.w	TERM
    524  2161				   E1
      0  2161					      TST	E2,oPlus	; Check if we are adding left term to something
      0  2161					      db	32
      1  2161		       20		      .byte.b	32
      0  2162					      db	(E2-*)-1
      1  2162		       09		      .byte.b	(E2-*)-1
      0  2163					      db	oPlus,0
      1  2163		       f0 00		      .byte.b	oPlus,0
      0  2165					      CALL	TERM	; if adding then get the right side term
      0  2165					      db	28
      1  2165		       1c		      .byte.b	28
      0  2166					      dw	TERM
      1  2166		       77 21		      .word.w	TERM
      0  2168					      ADD		; Add it to left term
      0  2168					      db	14
      1  2168		       0e		      .byte.b	14
      0  2169					      IJMP	E1	; look for next + or -
      0  2169					      db	29
      1  2169		       1d		      .byte.b	29
      0  216a					      dw	E1
      1  216a		       61 21		      .word.w	E1
    529  216c				   E2
      0  216c					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  216c					      db	101
      1  216c		       65		      .byte.b	101
      0  216d					      db	(E3-*)-1
      1  216d		       08		      .byte.b	(E3-*)-1
      0  216e					      db	oMinus
      1  216e		       f7		      .byte.b	oMinus
      0  216f					      CALL	TERM	; get right side to subtract Diffrence
      0  216f					      db	28
      1  216f		       1c		      .byte.b	28
      0  2170					      dw	TERM
      1  2170		       77 21		      .word.w	TERM
      0  2172					      SUB		; Subtract the value
      0  2172					      db	15
      1  2172		       0f		      .byte.b	15
      0  2173					      IJMP	E1	; Look for next + or -
      0  2173					      db	29
      1  2173		       1d		      .byte.b	29
      0  2174					      dw	E1
      1  2174		       61 21		      .word.w	E1
    534  2176				   E3			; Finish processing the expression
      0  2176					      RTN		; We are finished processing the Expression
      0  2176					      db	25
      1  2176		       19		      .byte.b	25
    536  2177							;
    537  2177							; Get one of the terms of an expression
    538  2177							;
    539  2177				   TERM
      0  2177					      CALL	FACT	; Get a value
      0  2177					      db	28
      1  2177		       1c		      .byte.b	28
      0  2178					      dw	FACT
      1  2178		       9c 21		      .word.w	FACT
    541  217a				   T0			; Check for higher precidence operators
      0  217a					      TSTB	T1,oMultiply	; Check for *
      0  217a					      db	101
      1  217a		       65		      .byte.b	101
      0  217b					      db	(T1-*)-1
      1  217b		       08		      .byte.b	(T1-*)-1
      0  217c					      db	oMultiply
      1  217c		       fa		      .byte.b	oMultiply
      0  217d					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  217d					      db	28
      1  217d		       1c		      .byte.b	28
      0  217e					      dw	FACT
      1  217e		       9c 21		      .word.w	FACT
      0  2180					      MUL		; Multiply factors
      0  2180					      db	17
      1  2180		       11		      .byte.b	17
      0  2181					      IJMP	T0	; Check for * or /
      0  2181					      db	29
      1  2181		       1d		      .byte.b	29
      0  2182					      dw	T0
      1  2182		       7a 21		      .word.w	T0
    546  2184				   T1
      0  2184					      TSTB	T2,oDivide	; Check for a division
      0  2184					      db	101
      1  2184		       65		      .byte.b	101
      0  2185					      db	(T2-*)-1
      1  2185		       08		      .byte.b	(T2-*)-1
      0  2186					      db	oDivide
      1  2186		       f8		      .byte.b	oDivide
      0  2187					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2187					      db	28
      1  2187		       1c		      .byte.b	28
      0  2188					      dw	FACT
      1  2188		       9c 21		      .word.w	FACT
      0  218a					      DIV		; do division
      0  218a					      db	18
      1  218a		       12		      .byte.b	18
      0  218b					      IJMP	T0	; check for more * or /
      0  218b					      db	29
      1  218b		       1d		      .byte.b	29
      0  218c					      dw	T0
      1  218c		       7a 21		      .word.w	T0
    551  218e				   T2
      0  218e					      TSTB	T3,oModulo	; Check for a division
      0  218e					      db	101
      1  218e		       65		      .byte.b	101
      0  218f					      db	(T3-*)-1
      1  218f		       08		      .byte.b	(T3-*)-1
      0  2190					      db	oModulo
      1  2190		       f9		      .byte.b	oModulo
      0  2191					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2191					      db	28
      1  2191		       1c		      .byte.b	28
      0  2192					      dw	FACT
      1  2192		       9c 21		      .word.w	FACT
      0  2194					      MODULO		; do division for remainder
      0  2194					      db	60
      1  2194		       3c		      .byte.b	60
      0  2195					      IJMP	T0	; check for more * or / or %
      0  2195					      db	29
      1  2195		       1d		      .byte.b	29
      0  2196					      dw	T0
      1  2196		       7a 21		      .word.w	T0
    556  2198				   T3			; Finish processing the Term
      0  2198					      RTN
      0  2198					      db	25
      1  2198		       19		      .byte.b	25
    558  2199
    559  2199				   UNKNOWNVEC
      0  2199					      IJMP	UNKNOWN
      0  2199					      db	29
      1  2199		       1d		      .byte.b	29
      0  219a					      dw	UNKNOWN
      1  219a		       e9 20		      .word.w	UNKNOWN
    561  219c
    562  219c							;=============================================================================================
    563  219c							; Factor an expression.  Always test for functions
    564  219c							; first or else they'll be confused for variables.
    565  219c							;
    566  219c				   FACT
      0  219c					      TSTB	F1AA,kTrue
      0  219c					      db	101
      1  219c		       65		      .byte.b	101
      0  219d					      db	(F1AA-*)-1
      1  219d		       05		      .byte.b	(F1AA-*)-1
      0  219e					      db	kTrue
      1  219e		       23		      .byte.b	kTrue
      0  219f					      LIT	-1
      0  219f					      db	27
      1  219f		       1b		      .byte.b	27
      0  21a0					      dw	-1
      1  21a0		       ff ff		      .word.w	-1
      0  21a2					      RTN
      0  21a2					      db	25
      1  21a2		       19		      .byte.b	25
    570  21a3				   F1AA
      0  21a3					      TSTB	F1AB,kFalse
      0  21a3					      db	101
      1  21a3		       65		      .byte.b	101
      0  21a4					      db	(F1AB-*)-1
      1  21a4		       05		      .byte.b	(F1AB-*)-1
      0  21a5					      db	kFalse
      1  21a5		       24		      .byte.b	kFalse
      0  21a6					      LIT	0
      0  21a6					      db	27
      1  21a6		       1b		      .byte.b	27
      0  21a7					      dw	0
      1  21a7		       00 00		      .word.w	0
      0  21a9					      RTN
      0  21a9					      db	25
      1  21a9		       19		      .byte.b	25
    574  21aa							;==================================================================================
    575  21aa							; Returns the amount of free SPACE
    576  21aa							;
    577  21aa				   F1AB
      0  21aa					      TSTB	F1A,kFree
      0  21aa					      db	101
      1  21aa		       65		      .byte.b	101
      0  21ab					      db	(F1A-*)-1
      1  21ab		       09		      .byte.b	(F1A-*)-1
      0  21ac					      db	kFree
      1  21ac		       26		      .byte.b	kFree
      0  21ad					      TSTB	UNKNOWNVEC,oLeftBracket
      0  21ad					      db	101
      1  21ad		       65		      .byte.b	101
      0  21ae					      db	(UNKNOWNVEC-*)-1
      1  21ae		       ea		      .byte.b	(UNKNOWNVEC-*)-1
      0  21af					      db	oLeftBracket
      1  21af		       e0		      .byte.b	oLeftBracket
      0  21b0					      TSTB	UNKNOWNVEC,oRightBracket
      0  21b0					      db	101
      1  21b0		       65		      .byte.b	101
      0  21b1					      db	(UNKNOWNVEC-*)-1
      1  21b1		       e7		      .byte.b	(UNKNOWNVEC-*)-1
      0  21b2					      db	oRightBracket
      1  21b2		       e1		      .byte.b	oRightBracket
      0  21b3					      FREE
      0  21b3					      db	36
      1  21b3		       24		      .byte.b	36
      0  21b4					      RTN
      0  21b4					      db	25
      1  21b4		       19		      .byte.b	25
    583  21b5							;===================================================================================
    584  21b5							; getch() read a character from the input device
    585  21b5							;
    586  21b5				   F1A
      0  21b5					      TSTB	F1A2,kGetch	; read char from the terminal
      0  21b5					      db	101
      1  21b5		       65		      .byte.b	101
      0  21b6					      db	(F1A2-*)-1
      1  21b6		       09		      .byte.b	(F1A2-*)-1
      0  21b7					      db	kGetch
      1  21b7		       27		      .byte.b	kGetch
      0  21b8					      TSTB	UNKNOWNVEC,oLeftBracket
      0  21b8					      db	101
      1  21b8		       65		      .byte.b	101
      0  21b9					      db	(UNKNOWNVEC-*)-1
      1  21b9		       df		      .byte.b	(UNKNOWNVEC-*)-1
      0  21ba					      db	oLeftBracket
      1  21ba		       e0		      .byte.b	oLeftBracket
      0  21bb					      TSTB	UNKNOWNVEC,oRightBracket
      0  21bb					      db	101
      1  21bb		       65		      .byte.b	101
      0  21bc					      db	(UNKNOWNVEC-*)-1
      1  21bc		       dc		      .byte.b	(UNKNOWNVEC-*)-1
      0  21bd					      db	oRightBracket
      1  21bd		       e1		      .byte.b	oRightBracket
      0  21be					      GETCHAR
      0  21be					      db	51
      1  21be		       33		      .byte.b	51
      0  21bf					      RTN
      0  21bf					      db	25
      1  21bf		       19		      .byte.b	25
    592  21c0							;====================================================================================
    593  21c0							; peek(mem address) return the value of a byte in memory
    594  21c0							; @[offset] return a word value from offset -- see tstv
    595  21c0							;
    596  21c0				   F1A2
      0  21c0					      TSTB	F2AZ,kPeek	;Return a value from memory
      0  21c0					      db	101
      1  21c0		       65		      .byte.b	101
      0  21c1					      db	(F2AZ-*)-1
      1  21c1		       0c		      .byte.b	(F2AZ-*)-1
      0  21c2					      db	kPeek
      1  21c2		       28		      .byte.b	kPeek
      0  21c3					      TSTB	UNKNOWNVEC,oLeftBracket
      0  21c3					      db	101
      1  21c3		       65		      .byte.b	101
      0  21c4					      db	(UNKNOWNVEC-*)-1
      1  21c4		       d4		      .byte.b	(UNKNOWNVEC-*)-1
      0  21c5					      db	oLeftBracket
      1  21c5		       e0		      .byte.b	oLeftBracket
      0  21c6					      CALL	EXPR	;Get the address to write to
      0  21c6					      db	28
      1  21c6		       1c		      .byte.b	28
      0  21c7					      dw	EXPR
      1  21c7		       ed 20		      .word.w	EXPR
      0  21c9					      TSTB	UNKNOWNVEC,oRightBracket
      0  21c9					      db	101
      1  21c9		       65		      .byte.b	101
      0  21ca					      db	(UNKNOWNVEC-*)-1
      1  21ca		       ce		      .byte.b	(UNKNOWNVEC-*)-1
      0  21cb					      db	oRightBracket
      1  21cb		       e1		      .byte.b	oRightBracket
      0  21cc					      PEEKMEM
      0  21cc					      db	48
      1  21cc		       30		      .byte.b	48
      0  21cd					      RTN
      0  21cd					      db	25
      1  21cd		       19		      .byte.b	25
    603  21ce							;=======================================================================================
    604  21ce							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    605  21ce							;
    606  21ce				   F2AZ
      0  21ce					      TSTB	F2AZ1,kTask	;Check if we are setting a task start
      0  21ce					      db	101
      1  21ce		       65		      .byte.b	101
      0  21cf					      db	(F2AZ1-*)-1
      1  21cf		       1d		      .byte.b	(F2AZ1-*)-1
      0  21d0					      db	kTask
      1  21d0		       29		      .byte.b	kTask
      0  21d1					      TSTB	UNKNOWNVEC,oLeftBracket
      0  21d1					      db	101
      1  21d1		       65		      .byte.b	101
      0  21d2					      db	(UNKNOWNVEC-*)-1
      1  21d2		       c6		      .byte.b	(UNKNOWNVEC-*)-1
      0  21d3					      db	oLeftBracket
      1  21d3		       e0		      .byte.b	oLeftBracket
      0  21d4					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  21d4					      db	28
      1  21d4		       1c		      .byte.b	28
      0  21d5					      dw	EXPR
      1  21d5		       ed 20		      .word.w	EXPR
      0  21d7					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  21d7					      db	61
      1  21d7		       3d		      .byte.b	61
      0  21d8					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  21d8					      db	101
      1  21d8		       65		      .byte.b	101
      0  21d9					      db	(F2AZNoParms-*)-1
      1  21d9		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  21da					      db	oComma
      1  21da		       e2		      .byte.b	oComma
      0  21db					      SAVEMATHSTACK		;Push The mathstack
      0  21db					      db	86
      1  21db		       56		      .byte.b	86
      0  21dc					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  21dc					      db	89
      1  21dc		       59		      .byte.b	89
    614  21dd				   F2AZLOOP
      0  21dd					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  21dd					      db	28
      1  21dd		       1c		      .byte.b	28
      0  21de					      dw	EXPR
      1  21de		       ed 20		      .word.w	EXPR
      0  21e0					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  21e0					      db	101
      1  21e0		       65		      .byte.b	101
      0  21e1					      db	(F2AZEndParm-*)-1
      1  21e1		       04		      .byte.b	(F2AZEndParm-*)-1
      0  21e2					      db	oComma
      1  21e2		       e2		      .byte.b	oComma
      0  21e3					      IJMP	F2AZLOOP	;check for more
      0  21e3					      db	29
      1  21e3		       1d		      .byte.b	29
      0  21e4					      dw	F2AZLOOP
      1  21e4		       dd 21		      .word.w	F2AZLOOP
    618  21e6				   F2AZEndParm
      0  21e6					      RESTOREMATHSTACK		;Back to normal stack
      0  21e6					      db	87
      1  21e6		       57		      .byte.b	87
      0  21e7					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  21e7					      db	92
      1  21e7		       5c		      .byte.b	92
    621  21e8				   F2AZNoParms
      0  21e8					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  21e8					      db	101
      1  21e8		       65		      .byte.b	101
      0  21e9					      db	(UNKNOWNVEC-*)-1
      1  21e9		       af		      .byte.b	(UNKNOWNVEC-*)-1
      0  21ea					      db	oRightBracket
      1  21ea		       e1		      .byte.b	oRightBracket
      0  21eb					      TASKENABLE		;Enable the task to execute
      0  21eb					      db	90
      1  21eb		       5a		      .byte.b	90
      0  21ec					      RTN		;Returns the Task number
      0  21ec					      db	25
      1  21ec		       19		      .byte.b	25
    625  21ed							;=========================================================================================
    626  21ed							; Check for IPC interproccess instructions
    627  21ed							;   IPCS  - Send a message
    628  21ed							;
    629  21ed				   F2AZ1
      0  21ed					      TSTB	F2AZa,kIpcs	;Test if one of the IPC functions
      0  21ed					      db	101
      1  21ed		       65		      .byte.b	101
      0  21ee					      db	(F2AZa-*)-1
      1  21ee		       12		      .byte.b	(F2AZa-*)-1
      0  21ef					      db	kIpcs
      1  21ef		       2b		      .byte.b	kIpcs
      0  21f0					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  21f0					      db	101
      1  21f0		       65		      .byte.b	101
      0  21f1					      db	(UNKNOWNVEC-*)-1
      1  21f1		       a7		      .byte.b	(UNKNOWNVEC-*)-1
      0  21f2					      db	oLeftBracket
      1  21f2		       e0		      .byte.b	oLeftBracket
      0  21f3					      CALL	EXPR	;Get the message value
      0  21f3					      db	28
      1  21f3		       1c		      .byte.b	28
      0  21f4					      dw	EXPR
      1  21f4		       ed 20		      .word.w	EXPR
      0  21f6					      TSTB	UNKNOWNVEC,oComma
      0  21f6					      db	101
      1  21f6		       65		      .byte.b	101
      0  21f7					      db	(UNKNOWNVEC-*)-1
      1  21f7		       a1		      .byte.b	(UNKNOWNVEC-*)-1
      0  21f8					      db	oComma
      1  21f8		       e2		      .byte.b	oComma
      0  21f9					      CALL	EXPR	;Get pid of task to send to
      0  21f9					      db	28
      1  21f9		       1c		      .byte.b	28
      0  21fa					      dw	EXPR
      1  21fa		       ed 20		      .word.w	EXPR
      0  21fc					      TSTB	UNKNOWNVEC,oRightBracket
      0  21fc					      db	101
      1  21fc		       65		      .byte.b	101
      0  21fd					      db	(UNKNOWNVEC-*)-1
      1  21fd		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  21fe					      db	oRightBracket
      1  21fe		       e1		      .byte.b	oRightBracket
      0  21ff					      IPCSEND		;Send msg and clear pid msg pending
      0  21ff					      db	80
      1  21ff		       50		      .byte.b	80
      0  2200					      RTN
      0  2200					      db	25
      1  2200		       19		      .byte.b	25
    638  2201							;================================================================================
    639  2201							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    640  2201							;
    641  2201				   F2AZa
      0  2201					      TSTB	F2AZb,kIpcr	;IPCR recieve a message , wait if none
      0  2201					      db	101
      1  2201		       65		      .byte.b	101
      0  2202					      db	(F2AZb-*)-1
      1  2202		       15		      .byte.b	(F2AZb-*)-1
      0  2203					      db	kIpcr
      1  2203		       2c		      .byte.b	kIpcr
      0  2204					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2204					      db	101
      1  2204		       65		      .byte.b	101
      0  2205					      db	(UNKNOWNVEC-*)-1
      1  2205		       93		      .byte.b	(UNKNOWNVEC-*)-1
      0  2206					      db	oLeftBracket
      1  2206		       e0		      .byte.b	oLeftBracket
      0  2207					      TSTB	F2AZa1,oRightBracket
      0  2207					      db	101
      1  2207		       65		      .byte.b	101
      0  2208					      db	(F2AZa1-*)-1
      1  2208		       07		      .byte.b	(F2AZa1-*)-1
      0  2209					      db	oRightBracket
      1  2209		       e1		      .byte.b	oRightBracket
      0  220a					      LIT	0	;We dont want the pid returned to us
      0  220a					      db	27
      1  220a		       1b		      .byte.b	27
      0  220b					      dw	0
      1  220b		       00 00		      .word.w	0
      0  220d					      IPCIO		;Set the io bit and suspend the task till message
      0  220d					      db	83
      1  220d		       53		      .byte.b	83
      0  220e					      IPCRECEIVE		;Get the message
      0  220e					      db	81
      1  220e		       51		      .byte.b	81
      0  220f					      RTN
      0  220f					      db	25
      1  220f		       19		      .byte.b	25
    649  2210				   F2AZa1
      0  2210					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  2210					      db	33
      1  2210		       21		      .byte.b	33
      0  2211					      db	(UNKNOWNVEC-*)-1
      1  2211		       87		      .byte.b	(UNKNOWNVEC-*)-1
      0  2212					      TSTB	UNKNOWNVEC,oRightBracket
      0  2212					      db	101
      1  2212		       65		      .byte.b	101
      0  2213					      db	(UNKNOWNVEC-*)-1
      1  2213		       85		      .byte.b	(UNKNOWNVEC-*)-1
      0  2214					      db	oRightBracket
      1  2214		       e1		      .byte.b	oRightBracket
      0  2215					      IPCIO		;Set the io bit and exit task till message
      0  2215					      db	83
      1  2215		       53		      .byte.b	83
      0  2216					      IPCRECEIVE		;Get the message
      0  2216					      db	81
      1  2216		       51		      .byte.b	81
      0  2217					      RTN
      0  2217					      db	25
      1  2217		       19		      .byte.b	25
    655  2218							;===============================================================================
    656  2218							; IPCC ---- check if a message is available
    657  2218				   F2AZb
      0  2218					      TST	F2A,kIpcc	;Returns number of messages on the message queue
      0  2218					      db	32
      1  2218		       20		      .byte.b	32
      0  2219					      db	(F2A-*)-1
      1  2219		       0d		      .byte.b	(F2A-*)-1
      0  221a					      db	kIpcc,0
      1  221a		       2a 00		      .byte.b	kIpcc,0
      0  221c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  221c					      db	101
      1  221c		       65		      .byte.b	101
      0  221d					      db	(UNKNOWNVEC-*)-1
      1  221d		       7b		      .byte.b	(UNKNOWNVEC-*)-1
      0  221e					      db	oLeftBracket
      1  221e		       e0		      .byte.b	oLeftBracket
      0  221f					      TSTB	UNKNOWNVEC,oRightBracket
      0  221f					      db	101
      1  221f		       65		      .byte.b	101
      0  2220					      db	(UNKNOWNVEC-*)-1
      1  2220		       78		      .byte.b	(UNKNOWNVEC-*)-1
      0  2221					      db	oRightBracket
      1  2221		       e1		      .byte.b	oRightBracket
      0  2222					      IPCCHECK
      0  2222					      db	82
      1  2222		       52		      .byte.b	82
      0  2223					      RTN
      0  2223					      db	25
      1  2223		       19		      .byte.b	25
    663  2224
    664  2224				   UNKNOWNID
      0  2224					      IJMP	UNKNOWN
      0  2224					      db	29
      1  2224		       1d		      .byte.b	29
      0  2225					      dw	UNKNOWN
      1  2225		       e9 20		      .word.w	UNKNOWN
    666  2227							;============================================================
    667  2227							; RND() is supposed to have an argument but if none
    668  2227							; was provided, just assume a large value.
    669  2227							;
    670  2227				   F2A
      0  2227					      TSTB	F2B,kRnd
      0  2227					      db	101
      1  2227		       65		      .byte.b	101
      0  2228					      db	(F2B-*)-1
      1  2228		       14		      .byte.b	(F2B-*)-1
      0  2229					      db	kRnd
      1  2229		       2d		      .byte.b	kRnd
      0  222a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  222a					      db	101
      1  222a		       65		      .byte.b	101
      0  222b					      db	(UNKNOWNVEC-*)-1
      1  222b		       6d		      .byte.b	(UNKNOWNVEC-*)-1
      0  222c					      db	oLeftBracket
      1  222c		       e0		      .byte.b	oLeftBracket
      0  222d					      TSTB	F2A1,oRightBracket
      0  222d					      db	101
      1  222d		       65		      .byte.b	101
      0  222e					      db	(F2A1-*)-1
      1  222e		       06		      .byte.b	(F2A1-*)-1
      0  222f					      db	oRightBracket
      1  222f		       e1		      .byte.b	oRightBracket
      0  2230					      LIT	32766
      0  2230					      db	27
      1  2230		       1b		      .byte.b	27
      0  2231					      dw	32766
      1  2231		       fe 7f		      .word.w	32766
      0  2233					      RANDOM
      0  2233					      db	37
      1  2233		       25		      .byte.b	37
      0  2234					      RTN
      0  2234					      db	25
      1  2234		       19		      .byte.b	25
    677  2235
    678  2235				   F2A1
      0  2235					      CALL	FACT	;GET RANGE
      0  2235					      db	28
      1  2235		       1c		      .byte.b	28
      0  2236					      dw	FACT
      1  2236		       9c 21		      .word.w	FACT
      0  2238					      TSTB	UNKNOWNVEC,oRightBracket
      0  2238					      db	101
      1  2238		       65		      .byte.b	101
      0  2239					      db	(UNKNOWNVEC-*)-1
      1  2239		       5f		      .byte.b	(UNKNOWNVEC-*)-1
      0  223a					      db	oRightBracket
      1  223a		       e1		      .byte.b	oRightBracket
      0  223b					      RANDOM
      0  223b					      db	37
      1  223b		       25		      .byte.b	37
      0  223c					      RTN
      0  223c					      db	25
      1  223c		       19		      .byte.b	25
    683  223d							;==========================================================
    684  223d							;	Return absolute value of expresion
    685  223d							;
    686  223d				   F2B
      0  223d					      TSTB	F2B2,kAbs
      0  223d					      db	101
      1  223d		       65		      .byte.b	101
      0  223e					      db	(F2B2-*)-1
      1  223e		       0c		      .byte.b	(F2B2-*)-1
      0  223f					      db	kAbs
      1  223f		       2f		      .byte.b	kAbs
      0  2240					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2240					      db	101
      1  2240		       65		      .byte.b	101
      0  2241					      db	(UNKNOWNVEC-*)-1
      1  2241		       57		      .byte.b	(UNKNOWNVEC-*)-1
      0  2242					      db	oLeftBracket
      1  2242		       e0		      .byte.b	oLeftBracket
      0  2243					      CALL	EXPR	;get value
      0  2243					      db	28
      1  2243		       1c		      .byte.b	28
      0  2244					      dw	EXPR
      1  2244		       ed 20		      .word.w	EXPR
      0  2246					      TSTB	UNKNOWNVEC,oRightBracket
      0  2246					      db	101
      1  2246		       65		      .byte.b	101
      0  2247					      db	(UNKNOWNVEC-*)-1
      1  2247		       51		      .byte.b	(UNKNOWNVEC-*)-1
      0  2248					      db	oRightBracket
      1  2248		       e1		      .byte.b	oRightBracket
      0  2249					      ABS
      0  2249					      db	38
      1  2249		       26		      .byte.b	38
      0  224a					      RTN
      0  224a					      db	25
      1  224a		       19		      .byte.b	25
    693  224b							;============================================================
    694  224b							;     Return the the status of a task, provide the PID
    695  224b							;
    696  224b				   F2B2
      0  224b					      TSTB	F2Z,kStat
      0  224b					      db	101
      1  224b		       65		      .byte.b	101
      0  224c					      db	(F2Z-*)-1
      1  224c		       0c		      .byte.b	(F2Z-*)-1
      0  224d					      db	kStat
      1  224d		       2e		      .byte.b	kStat
      0  224e					      TSTB	UNKNOWNVEC,oLeftBracket
      0  224e					      db	101
      1  224e		       65		      .byte.b	101
      0  224f					      db	(UNKNOWNVEC-*)-1
      1  224f		       49		      .byte.b	(UNKNOWNVEC-*)-1
      0  2250					      db	oLeftBracket
      1  2250		       e0		      .byte.b	oLeftBracket
      0  2251					      Call	EXPR
      0  2251					      db	28
      1  2251		       1c		      .byte.b	28
      0  2252					      dw	EXPR
      1  2252		       ed 20		      .word.w	EXPR
      0  2254					      TSTB	UNKNOWNVEC,oRightBracket
      0  2254					      db	101
      1  2254		       65		      .byte.b	101
      0  2255					      db	(UNKNOWNVEC-*)-1
      1  2255		       43		      .byte.b	(UNKNOWNVEC-*)-1
      0  2256					      db	oRightBracket
      1  2256		       e1		      .byte.b	oRightBracket
      0  2257					      TASKSTAT
      0  2257					      db	66
      1  2257		       42		      .byte.b	66
      0  2258					      RTN
      0  2258					      db	25
      1  2258		       19		      .byte.b	25
    703  2259				   F2Z
      0  2259					      TSTB	F2ZA,kPid
      0  2259					      db	101
      1  2259		       65		      .byte.b	101
      0  225a					      db	(F2ZA-*)-1
      1  225a		       03		      .byte.b	(F2ZA-*)-1
      0  225b					      db	kPid
      1  225b		       33		      .byte.b	kPid
      0  225c					      TASKPID
      0  225c					      db	77
      1  225c		       4d		      .byte.b	77
      0  225d					      RTN
      0  225d					      db	25
      1  225d		       19		      .byte.b	25
    707  225e							;===========================================================================
    708  225e							; Call a machine function, provide the address to call and optionally
    709  225e							; the value to be passed in reg A
    710  225e				   F2ZA
      0  225e					      TSTB	F2FUNC,kCall	;call machine function
      0  225e					      db	101
      1  225e		       65		      .byte.b	101
      0  225f					      db	(F2FUNC-*)-1
      1  225f		       1a		      .byte.b	(F2FUNC-*)-1
      0  2260					      db	kCall
      1  2260		       30		      .byte.b	kCall
      0  2261					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2261					      db	101
      1  2261		       65		      .byte.b	101
      0  2262					      db	(UNKNOWNVEC-*)-1
      1  2262		       36		      .byte.b	(UNKNOWNVEC-*)-1
      0  2263					      db	oLeftBracket
      1  2263		       e0		      .byte.b	oLeftBracket
      0  2264					      CALL	EXPR
      0  2264					      db	28
      1  2264		       1c		      .byte.b	28
      0  2265					      dw	EXPR
      1  2265		       ed 20		      .word.w	EXPR
      0  2267					      TSTB	F2B2A,oComma
      0  2267					      db	101
      1  2267		       65		      .byte.b	101
      0  2268					      db	(F2B2A-*)-1
      1  2268		       09		      .byte.b	(F2B2A-*)-1
      0  2269					      db	oComma
      1  2269		       e2		      .byte.b	oComma
      0  226a					      CALL	EXPR
      0  226a					      db	28
      1  226a		       1c		      .byte.b	28
      0  226b					      dw	EXPR
      1  226b		       ed 20		      .word.w	EXPR
      0  226d					      TSTB	UNKNOWNVEC,oRightBracket
      0  226d					      db	101
      1  226d		       65		      .byte.b	101
      0  226e					      db	(UNKNOWNVEC-*)-1
      1  226e		       2a		      .byte.b	(UNKNOWNVEC-*)-1
      0  226f					      db	oRightBracket
      1  226f		       e1		      .byte.b	oRightBracket
      0  2270					      CALLFUNC
      0  2270					      db	53
      1  2270		       35		      .byte.b	53
      0  2271					      RTN
      0  2271					      db	25
      1  2271		       19		      .byte.b	25
    719  2272							; Run the gosub within this function
    720  2272				   F2B2A
      0  2272					      TSTB	UNKNOWNID,oRightBracket
      0  2272					      db	101
      1  2272		       65		      .byte.b	101
      0  2273					      db	(UNKNOWNID-*)-1
      1  2273		       b0		      .byte.b	(UNKNOWNID-*)-1
      0  2274					      db	oRightBracket
      1  2274		       e1		      .byte.b	oRightBracket
      0  2275					      LIT	0	; No parameter passed so just load zero to A
      0  2275					      db	27
      1  2275		       1b		      .byte.b	27
      0  2276					      dw	0
      1  2276		       00 00		      .word.w	0
      0  2278					      CALLFUNC
      0  2278					      db	53
      1  2278		       35		      .byte.b	53
      0  2279					      RTN
      0  2279					      db	25
      1  2279		       19		      .byte.b	25
    725  227a							;===========================================================================
    726  227a							; Same as gosub but expects a return value
    727  227a							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    728  227a							;
      0  227a				   F2FUNC     TSTB	F2C,kGofn
      0  227a					      db	101
      1  227a		       65		      .byte.b	101
      0  227b					      db	(F2C-*)-1
      1  227b		       08		      .byte.b	(F2C-*)-1
      0  227c					      db	kGofn
      1  227c		       31		      .byte.b	kGofn
      0  227d					      Call	GOSUBSTATEMENT
      0  227d					      db	28
      1  227d		       1c		      .byte.b	28
      0  227e					      dw	GOSUBSTATEMENT
      1  227e		       a9 22		      .word.w	GOSUBSTATEMENT
      0  2280					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  2280					      db	8
      1  2280		       08		      .byte.b	8
      0  2281					      db	GOSUB_RTN_VALUE
      1  2281		       81		      .byte.b	GOSUB_RTN_VALUE
      0  2282					      XFER
      0  2282					      db	7
      1  2282		       07		      .byte.b	7
    733  2283				   GOFNRet
      0  2283					      RTN
      0  2283					      db	25
      1  2283		       19		      .byte.b	25
    735  2284							;=============================================================================
    736  2284							; See if this is just a simple variable
    737  2284							;  Allow a subscript for any variable
    738  2284							;
    739  2284				   F2C
      0  2284					      TSTV	F0
      0  2284					      db	33
      1  2284		       21		      .byte.b	33
      0  2285					      db	(F0-*)-1
      1  2285		       12		      .byte.b	(F0-*)-1
      0  2286					      TSTB	F2CLocalTask,oBang
      0  2286					      db	101
      1  2286		       65		      .byte.b	101
      0  2287					      db	(F2CLocalTask-*)-1
      1  2287		       04		      .byte.b	(F2CLocalTask-*)-1
      0  2288					      db	oBang
      1  2288		       e8		      .byte.b	oBang
      0  2289					      IND		; we just got a pid
      0  2289					      db	20
      1  2289		       14		      .byte.b	20
      0  228a					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  228a					      db	93
      1  228a		       5d		      .byte.b	93
      0  228b					      db	(UNKNOWNID-*)-1
      1  228b		       98		      .byte.b	(UNKNOWNID-*)-1
    744  228c
    745  228c				   F2CLocalTask
      0  228c					      TSTB	F2C1,oLeftSQBracket
      0  228c					      db	101
      1  228c		       65		      .byte.b	101
      0  228d					      db	(F2C1-*)-1
      1  228d		       08		      .byte.b	(F2C1-*)-1
      0  228e					      db	oLeftSQBracket
      1  228e		       e4		      .byte.b	oLeftSQBracket
      0  228f					      CALL	EXPR
      0  228f					      db	28
      1  228f		       1c		      .byte.b	28
      0  2290					      dw	EXPR
      1  2290		       ed 20		      .word.w	EXPR
      0  2292					      TSTB	UNKNOWNID,oRightSQBracket
      0  2292					      db	101
      1  2292		       65		      .byte.b	101
      0  2293					      db	(UNKNOWNID-*)-1
      1  2293		       90		      .byte.b	(UNKNOWNID-*)-1
      0  2294					      db	oRightSQBracket
      1  2294		       e5		      .byte.b	oRightSQBracket
      0  2295					      SUBSCRIPT
      0  2295					      db	64
      1  2295		       40		      .byte.b	64
    750  2296				   F2C1
      0  2296					      IND		;YES, GET THE VALUE.
      0  2296					      db	20
      1  2296		       14		      .byte.b	20
      0  2297					      RTN
      0  2297					      db	25
      1  2297		       19		      .byte.b	25
    753  2298							;=================================================================================
    754  2298							;Finally check for a number !
    755  2298							;
    756  2298				   F0
      0  2298					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  2298					      db	35
      1  2298		       23		      .byte.b	35
      0  2299					      db	(F1-*)-1
      1  2299		       01		      .byte.b	(F1-*)-1
      0  229a					      RTN
      0  229a					      db	25
      1  229a		       19		      .byte.b	25
    759  229b				   F1
      0  229b					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  229b					      db	101
      1  229b		       65		      .byte.b	101
      0  229c					      db	(F2RTN-*)-1
      1  229c		       08		      .byte.b	(F2RTN-*)-1
      0  229d					      db	oLeftBracket
      1  229d		       e0		      .byte.b	oLeftBracket
      0  229e					      CALL	EXPR
      0  229e					      db	28
      1  229e		       1c		      .byte.b	28
      0  229f					      dw	EXPR
      1  229f		       ed 20		      .word.w	EXPR
      0  22a1					      TST	F2,oRightBracket
      0  22a1					      db	32
      1  22a1		       20		      .byte.b	32
      0  22a2					      db	(F2-*)-1
      1  22a2		       03		      .byte.b	(F2-*)-1
      0  22a3					      db	oRightBracket,0
      1  22a3		       e1 00		      .byte.b	oRightBracket,0
    763  22a5				   F2RTN
      0  22a5					      RTN
      0  22a5					      db	25
      1  22a5		       19		      .byte.b	25
    765  22a6
    766  22a6				   F2
      0  22a6					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  22a6					      db	13
      1  22a6		       0d		      .byte.b	13
      0  22a7					      dw	ERR_SYNTAX
      1  22a7		       05 00		      .word.w	ERR_SYNTAX
    768  22a9							;
    769  22a9							;=============================================================
    770  22a9							; Gosub can be both a Function and a Subroutine
    771  22a9				   GOSUBSTATEMENT
      0  22a9					      CALL	EXPR	;GET DESTINATION
      0  22a9					      db	28
      1  22a9		       1c		      .byte.b	28
      0  22aa					      dw	EXPR
      1  22aa		       ed 20		      .word.w	EXPR
      0  22ac					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  22ac					      db	101
      1  22ac		       65		      .byte.b	101
      0  22ad					      db	(GOSUBDONE-*)-1
      1  22ad		       11		      .byte.b	(GOSUBDONE-*)-1
      0  22ae					      db	oLeftBracket
      1  22ae		       e0		      .byte.b	oLeftBracket
      0  22af					      STK2TMP		;Transfer stack top to temp
      0  22af					      db	95
      1  22af		       5f		      .byte.b	95
      0  22b0					      PUSHMATHSTACK		;Record stack frame for return
      0  22b0					      db	84
      1  22b0		       54		      .byte.b	84
    776  22b1				   GOSUBLOOP
      0  22b1					      CALL	EXPR	; Allows what ever fits onto stack
      0  22b1					      db	28
      1  22b1		       1c		      .byte.b	28
      0  22b2					      dw	EXPR
      1  22b2		       ed 20		      .word.w	EXPR
      0  22b4					      INCPARMCOUNT
      0  22b4					      db	88
      1  22b4		       58		      .byte.b	88
      0  22b5					      TSTB	GOSUBParmDONE,oComma
      0  22b5					      db	101
      1  22b5		       65		      .byte.b	101
      0  22b6					      db	(GOSUBParmDONE-*)-1
      1  22b6		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  22b7					      db	oComma
      1  22b7		       e2		      .byte.b	oComma
      0  22b8					      IJMP	GOSUBLOOP
      0  22b8					      db	29
      1  22b8		       1d		      .byte.b	29
      0  22b9					      dw	GOSUBLOOP
      1  22b9		       b1 22		      .word.w	GOSUBLOOP
    781  22bb				   GOSUBParmDONE
      0  22bb					      TSTB	F2,oRightBracket
      0  22bb					      db	101
      1  22bb		       65		      .byte.b	101
      0  22bc					      db	(F2-*)-1
      1  22bc		       e9		      .byte.b	(F2-*)-1
      0  22bd					      db	oRightBracket
      1  22bd		       e1		      .byte.b	oRightBracket
      0  22be					      TMP2STK		;Restore line to goto
      0  22be					      db	96
      1  22be		       60		      .byte.b	96
    784  22bf				   GOSUBDONE
      0  22bf					      RTN
      0  22bf					      db	25
      1  22bf		       19		      .byte.b	25
    786  22c0
    787  22c0		       22 c0	   ILEND      equ	*
------- FILE mytb.asm
   2309  22c0		       22 c0	   PROGEND    equ	*
   2310  22c0
   2311  22c0
   2312  22c0							;=====================================================
   2313  22c0							; Define start of non page zero data
   2314 U22d0					      seg.u	TBData
   2315 U22d0
   2316 U22d0							;=====================================================
   2317 U22d0							; These are storage items not in page zero.
   2318 U22d0							;
   2319 U22d0							; IRQ BASIC Code Service RTN Support
      0 U22d0				   SaveIrqReg db	0	; Store current setting
      1 U22d0		       00		      .byte.b	0
      0 U22d1				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U22d1		       00		      .byte.b	0
      0 U22d2				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U22d2		       00		      .byte.b	0
      0 U22d3				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U22d3		       00 00		      .byte.b	0,0
   2324 U22d5
   2325 U22d5							;
   2326 U22d5							;==================================================================================================
   2327 U22d5							; Task Management information
   2328 U22d5							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2329 U22d5							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2330 U22d5							; Task switchs happen at the beginning of the next Basic command line
   2331 U22d5							; It will not happen during an input or output operations
   2332 U22d5							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2333 U22d5							; Task Zero is always the root task, main line program
   2334 U22d5							;
   2335 U22d5							; Layout is repeated for each configured task
   2336 U22d5							; Task Table Byte   use masks follow
   2337 U22d5		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2338 U22d5		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2339 U22d5		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2340 U22d5		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2341 U22d5		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2342 U22d5
   2343 U22d5		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2344 U22d6		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2345 U22d6		       23 d0	   TASKTABLEEND equ	*	; End of task table
   2346 U22d6		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2347 U23d0
   2348 U23d0							;Task Cycle Counter and reset count
   2349 U23d0		       00 00	   taskCurrentCycles ds	2
   2350 U23d2		       00 00	   taskResetValue ds	2
   2351 U23d4		       00	   taskCounter ds	1	; Count of active tasks
   2352 U23d5
   2353 U23d5							;
   2354 U23d5							; Math stack and IL call and Gosub/For-next return stack definitions
   2355 U23d5							;
   2356 U23d5		       23 d5	   STACKSTART equ	*
   2357 U23d5		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2358 U2565		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2359 U26f5		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2360 U2975		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2361 U2975		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2362 U2975		       2b 91	   STACKEND   equ	*
   2363 U2975		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2364 U2b91							;
   2365 U2b91							;
   2366 U2b91		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2367 U2c15		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2368 U2c16		       00	   printtx    ds	1	;temp X for print funcs
   2369 U2c17		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2370 U2c18		       00	   promptChar ds	1	;the character to use for a prompt
   2371 U2c19		       00	   diddigit   ds	1	;for leading zero suppression
   2372 U2c1a		       00	   putsy      ds	1
   2373 U2c1b		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2374 U2c1d		       00	   sign       ds	1	;0 = positive, else negative
   2375 U2c1e		       00 00	   rtemp1     ds	2	;Temp for x and y
   2376 U2c20		       00 00	   random     ds	2
   2377 U2c22		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2378 U2c24		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2379 U2c26		       00	   tempy      ds	1	;temp y storage
   2380 U2c27
   2381 U2c27							; Moved from page zero as one clock cycle diff gives more space on page zero
   2382 U2c27		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2383 U2c29		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2384 U2c2a		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2385 U2c2b		       00	   lineLength ds	1	;Length of current line
   2386 U2c2c
   2387 U2c2c		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2388 U2c2d		       00	   taskRDPending ds	1	; 1 = background read is pending
   2389 U2c2e
   2390 U2c2e				  -	      if	XKIM
   2391 U2c2e				  -buffer     ds	BUFFER_SIZE
   2392 U2c2e					      endif
   2393 U2c2e							;
   2394 U2c2e							; PROGRAMEND is the end of the user's BASIC program.
   2395 U2c2e							; More precisely, it is one byte past the end.  Or,
   2396 U2c2e							; it's where the next line added to the end will be
   2397 U2c2e							; placed.
   2398 U2c2e							;
   2399 U2c2e		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2400 U2c30		       00 00	   ProgramEnd ds	2	; End of users basic program
   2401 U2c32		       00 00	   HighMem    ds	2	; highest location
   2402 U2c34		       00 00	   UsedMem    ds	2	; size of user program
   2403 U2c36		       00 00	   FreeMem    ds	2	; amount of free memory
   2404 U2c38							;
   2405 U2c38							;=====================================================
   2406 U2c38							; This is the start of the user's BASIC program space.
   2407 U2c38							;
   2408 U2c38							; PERSONAL GOAL: This should be no larger than $0DFF.
   2409 U2c38							;		  0200-05FF = 1K
   2410 U2c38							;		  0200-09FF = 2K
   2411 U2c38							;		  0200-0DFF = 3K
   2412 U2c38							;		  0200-11FF = 4K
   2413 U2c38							;		  0200-13FF = 4.5K
   2414 U2c38							;
   2415 U2c38				  -	      if	FIXED
   2416 U2c38				  -	      org	$2000
   2417 U2c38					      endif
   2418 U2c38
   2419 U2c38		       2c 38	   FreeMemStart equ	*
   2420 U2c38							;/*
   2421 U2c38							;	if	CTMON65 || XKIM
   2422 U2c38							;		SEG Code
   2423 U2c38							;		org	AutoRun
   2424 U2c38							;		dw	TBasicCold
   2425 U2c38							;	endif
   2426 U2c38							;*/
   2427 U2c38					      end
