------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2615				   input      processor	6502
      2 U2615 ????						;=====================================================
      3 U2615 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2615 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2615 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2615 ????						;
      7 U2615 ????						; While working on the Corsham Technologies KIM Clone
      8 U2615 ????						; project, I wanted to include a TINY BASIC since that
      9 U2615 ????						; was a highly desirable feature of early computers.
     10 U2615 ????						;
     11 U2615 ????						; Rather than negotiating copyright issues for
     12 U2615 ????						; existing BASICs, I decided to just write one from
     13 U2615 ????						; scratch.
     14 U2615 ????						;
     15 U2615 ????						; 10/07/2017
     16 U2615 ????						;
     17 U2615 ????						; This implements a stripped down Tiny BASIC
     18 U2615 ????						; interpreter using the Interpretive Language (IL)
     19 U2615 ????						; method as described in the first few issues of
     20 U2615 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2615 ????						; to write various languages simply by changing the
     22 U2615 ????						; IL code rather than the interpreter itself.
     23 U2615 ????						;
     24 U2615 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2615 ????						;		* Fixed major bug in findLine that
     26 U2615 ????						;		  caused corrupted lines, crashes, etc.
     27 U2615 ????						;		* If no parameter given to RND, assume
     28 U2615 ????						;		  32766.
     29 U2615 ????						;		* No more error 5 when a program
     30 U2615 ????						;		  reaches the end without an END.
     31 U2615 ????						;
     32 U2615 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2615 ????						;		 * Unexpanded version to play with everything
     34 U2615 ????						;		 * Add some usefull system level functions
     35 U2615 ????						;		 * allow a larger number of tiny basic formats
     36 U2615 ????						;		 * Add byte at start of line holding length
     37 U2615 ????						;		   for faster execution of goto and gosub
     38 U2615 ????						;		 * Re-added gosub
     39 U2615 ????						;		 * allow ; or , at end if print stmt
     40 U2615 ????						;		   without CRLF being added.
     41 U2615 ????						;		 * Added extended function erase to
     42 U2615 ????						;		   use the extended ctmon65 rm file
     43 U2615 ????						;		 * Fix quoted text to not have to backtrack
     44 U2615 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2615 ????						;		 * Add concurrency features
     46 U2615 ????						;
     47 U2615 ????						; www.corshamtech.com
     48 U2615 ????						; bob@corshamtech.com
     49 U2615 ????						; JustLostInTime@gmail.com
     50 U2615 ????						;
     51 U2615 ????						;=====================================================
     52 U2615 ????						;
     53 U2615 ????						; Create TRUE and FALSE values for conditionals.
     54 U2615 ????						;
     55 U2615 ????
     56 U2615 ????	       00 00	   FALSE      equ	0
     57 U2615 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2615 ????						;
     59 U2615 ????						;---------------------------------------------------------
     60 U2615 ????						; One of these must be set to indicate which environment
     61 U2615 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2615 ????						; environments:
     63 U2615 ????						;
     64 U2615 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2615 ????						; more K of RAM.
     66 U2615 ????						;
     67 U2615 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2615 ????						; which enhances, without replacing, the standard KIM
     69 U2615 ????						; monitor.  It gives access to routines to save/load files
     70 U2615 ????						; to a micro SD card.
     71 U2615 ????						;
     72 U2615 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2615 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2615 ????						; easily be ported to other systems.  It has support for
     75 U2615 ????						; using a micro SD card for file storage/retrieval.
     76 U2615 ????						;
     77 U2615 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2615 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2615 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2615 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2615 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2615 ????						;
     83 U2615 ????						;   Need to define some macros for the dasm assembler
     84 U2615 ????						;
     85 U2615 ????				      MACRO	dw
     86 U2615 ????				      .word	{0}
     87 U2615 ????				      ENDM
     88 U2615 ????
     89 U2615 ????				      MACRO	db
     90 U2615 ????				      .byte	{0}
     91 U2615 ????				      ENDM
     92 U2615 ????
     93 U2615 ????						;
     94 U2615 ????						; If set, include disk functions.
     95 U2615 ????						;
     96 U2615 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2615 ????						;
     98 U2615 ????						; If ILTRACE is set then dump out the address of every
     99 U2615 ????						; IL opcode before executing it.
    100 U2615 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2615 ????						;
    102 U2615 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2615 ????						;
    104 U2615 ????						; If FIXED is set, put the IL code and the user
    105 U2615 ????						; program space at fixed locations in memory.	This is
    106 U2615 ????						; meant only for debugging.
    107 U2615 ????						;
    108 U2615 ????	       00 00	   FIXED      equ	FALSE
    109 U2615 ????						;
    110 U2615 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2615 ????						; BASIC, so keep this small!
    112 U2615 ????						;
    113 U2615 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2615 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2615 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2615 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2615 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2615 ????	       00 c8	   TASKCYCLESDEFAULT equ	200	;Default Task Switch 0-255 uses a single byte
    119 U2615 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    120 U2615 ????						;
    121 U2615 ????						; Gosub entry types
    122 U2615 ????
    123 U2615 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    124 U2615 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    125 U2615 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    126 U2615 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    127 U2615 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    128 U2615 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    129 U2615 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    130 U2615 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    131 U2615 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    132 U2615 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    133 U2615 ????						;
    134 U2615 ????						; Common ASCII constants
    135 U2615 ????						;
    136 U2615 ????	       00 07	   BEL	      equ	$07
    137 U2615 ????	       00 08	   BS	      equ	$08
    138 U2615 ????	       00 09	   TAB	      equ	$09
    139 U2615 ????	       00 0a	   LF	      equ	$0A
    140 U2615 ????	       00 0d	   CR	      equ	$0D
    141 U2615 ????	       00 22	   quote      equ	$22
    142 U2615 ????	       00 20	   SPACE      equ	$20
    143 U2615 ????	       00 2c	   COMMA      equ	',
    144 U2615 ????	       00 3b	   SEMICOLON  equ	';
    145 U2615 ????	       00 3a	   COLON      equ	':
    146 U2615 ????	       00 24	   DOLLAR     equ	'$
    147 U2615 ????						;
    148 U2615 ????						; These are error codes
    149 U2615 ????						;
    150 U2615 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    151 U2615 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    152 U2615 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    153 U2615 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    154 U2615 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    155 U2615 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    156 U2615 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    157 U2615 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    158 U2615 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    159 U2615 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    160 U2615 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    161 U2615 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    162 U2615 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    163 U2615 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    164 U2615 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    165 U2615 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    166 U2615 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    167 U2615 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    168 U2615 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    169 U2615 ????						;
    170 U2615 ????						;=====================================================
    171 U2615 ????						; Zero page storage.
    172 U2615 ????						;
    173 U00f6 ????				      SEG.U	ZEROPAGE
    174 U0040					      org	$0040
    175 U0040
    176 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    177 U0041
    178 U0041							; The context is used to locate a task switch
    179 U0041							; it copies from here till all task fields are saved/swapped
    180 U0041							; The max number of tasks is 256 / context length
    181 U0041							; All positions POS values are plus one task table incldues
    182 U0041							; a leading status byte .
    183 U0041							;
    184 U0041		       00 41	   CONTEXT    equ	*
    185 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    186 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    187 U0043		       00 00	   ILPC       ds	2	; IL program counter
    188 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    189 U0047		       00	   ILSTACKPTR ds	1
    190 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    191 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    192 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    193 U004a		       00	   MATHSTACKPTR ds	1
    194 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    195 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    196 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    197 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    198 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    199 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    200 U004f							;
    201 U004f							; CURPTR is a pointer to curent BASIC line being
    202 U004f							; executed.  Always points to start of line, CUROFF
    203 U004f							; is the offset to the current character.
    204 U004f							; The order of these fields is important
    205 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    206 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    207 U0052							;
    208 U0052							;The order of these fields in important
    209 U0052
    210 U0052							;
    211 U0052							; R0, R1 and MQ are used for arithmetic operations and
    212 U0052							; general use.
    213 U0052							;
    214 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    215 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    216 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    217 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    218 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    219 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    220 U0056		       00 00	   MQ	      ds	2	;used for some math
    221 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    222 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    223 U0058		       00 59	   REGISTERSEND equ	*
    224 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    225 U0059
    226 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    227 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    228 U0059
    229 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    230 U005b		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    231 U005d		       00	   tempIlY    ds	1	;Temp IL Y register storage
    232 U005e		       00	   offset     ds	1	;IL Offset to next inst when test fails
    233 U005f		       00	   lineLength ds	1	;Length of current line
    234 U0060
    235 U0060		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
    236 U0061		       00	   taskRDPending ds	1	; 1 = background read is pending
    237 U0062
    238 U0062							;
    239 U0062							; This is zero if in immediate mode, or non-zero
    240 U0062							; if currently running a program.  Any input from
    241 U0062							; the main loop clears this, and the XFER IL
    242 U0062							; statement will set it.
    243 U0062							;
    244 U0062		       00	   RunMode    ds	1	;Basic program is running or stop
    245 U0063							;
    246 U0063							; Used for line insertion/removal.
    247 U0063							;
    248 U0063		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    249 U0065
    250 U0065							; THE ADDRESS USED BY THE PRINTER FUNCTION
    251 U0065							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    252 U0065							;
    253 U0065		       00 00	   PrtFrom    ds	2	; FROM
    254 U0067							;
    255 U0067
    256 U0067							;
    257 U0067							;=====================================================
    258 U0067							;
    259  1ca8 ????				      SEG	Code
    260  0200					      org	$0200
    261  0200							;
    262  0200							; Cold start is at $0200.  Warm start is at $0203.
    263  0200							;
    264  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    265  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    266  0206							;
    267  0206							; These are the user-supplied vectors to I/O routines.
    268  0206							; If you want, you can just patch these in the binary
    269  0206							; file, but it would be better to change the source
    270  0206							; code.
    271  0206							;
    272  0206				  -	      if	KIM
    273  0206				  -OUTCH      jmp	$1ea0	;output char in A
    274  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    275  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    276  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    277  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    278  0206					      endif
    279  0206				  -	      if	XKIM
    280  0206				  -	      include	"xkim.inc"
    281  0206				  -	      SEG	Code
    282  0206				  -OUTCH      jmp	$1ea0
    283  0206				  -GETCH      jmp	xkGETCH
    284  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    285  0206				  -OUTHEX     jmp	xkPRTBYT
    286  0206				  -MONITOR    jmp	extKIM
    287  0206				  -puts       equ	putsil
    288  0206				  -BUFFER_SIZE equ	132
    289  0206					      endif
    290  0206
    291  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0067					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    293 Udf8e
    294  0206					      SEG	Code
    295  0206							;
    296  0206		       f0 0c	   OUTCH      equ	cout
    297  0206		       f0 09	   GETCH      equ	cin
    298  0206		       14 76	   CRLF       equ	tbcrlf
    299  0206		       16 51	   OUTHEX     equ	HexToOut
    300  0206		       f0 03	   MONITOR    equ	WARM
    301  0206		       f0 0f	   ISCHAR     equ	cstatus
    302  0206		       15 f8	   puts       equ	tbputs
    303  0206					      endif
    304  0206							;
    305  0206		       20 d8 15    cold2      jsr	SetOutConsole
    306  0209		       20 e5 15 	      jsr	SetInConsole
    307  020c		       20 f8 15 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    311  023c							;
    312  023c		       20 a5 15 	      jsr	GetSizes	;setup the free space available
    313  023f
    314  023f		       a9 01	   calcstack  lda	#1
    315  0241		       8d ba 1d 	      sta	taskCounter	; Initialize number of tasks to 1
    316  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    317  0246		       8d be 1c 	      sta	taskTable	; mark the main task as active
    318  0249		       20 41 0d 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    319  024c		       a9 1f		      lda	#IL&$ff
    320  024e		       85 43		      sta	ILPC
    321  0250		       a9 18		      lda	#IL>>8
    322  0252		       85 44		      sta	ILPC+1
    323  0254							;
    324  0254		       a9 15		      lda	#ProgramStart&$ff	; user prog
    325  0256		       8d 0d 26 	      sta	PROGRAMEND
    326  0259		       a9 26		      lda	#ProgramStart>>8
    327  025b		       8d 0e 26 	      sta	PROGRAMEND+1
    328  025e							;
    329  025e							; Initialize the pseudo-random number sequence...
    330  025e							;
    331  025e		       a9 5a		      lda	#$5a
    332  0260		       8d 04 26 	      sta	rtemp1
    333  0263		       a9 9d		      lda	#%10011101
    334  0265		       8d 06 26 	      sta	random
    335  0268		       a9 5b		      lda	#%01011011
    336  026a		       8d 07 26 	      sta	random+1
    337  026d							;
    338  026d							;   Insert a Basic irq handler for the basic Language
    339  026d		       a9 7a		      lda	#ServiceIrq&$ff
    340  026f		       8d 00 df 	      sta	IRQvec
    341  0272		       a9 02		      lda	#ServiceIrq>>8
    342  0274		       8d 01 df 	      sta	IRQvec+1
    343  0277		       4c 9f 02 	      jmp	coldtwo
    344  027a
    345  027a							;
    346  027a							; This is the Basic IRQ handler
    347  027a		       48	   ServiceIrq pha
    348  027b		       ad b9 1c 	      lda	IRQStatus
    349  027e		       f0 0a		      BEQ	RetIrq
    350  0280		       ad ba 1c 	      lda	IRQPending
    351  0283		       d0 05		      bne	RetIrq
    352  0285		       a9 01		      lda	#1
    353  0287		       8d ba 1c 	      sta	IRQPending
    354  028a		       68	   RetIrq     pla
    355  028b		       40		      rti
    356  028c							;
    357  028c							;
    358  028c							; This is the warm start entry point
    359  028c							;
    360  028c		       20 d8 15    warm2      jsr	SetOutConsole
    361  028f		       20 e5 15 	      jsr	SetInConsole
    362  0292		       20 76 14 	      jsr	CRLF
    363  0295		       ad 01 26 	      lda	errGoto
    364  0298		       85 43		      sta	ILPC
    365  029a		       ad 02 26 	      lda	errGoto+1
    366  029d		       85 44		      sta	ILPC+1
    367  029f							;
    368  029f							; And continue with both starts here
    369  029f							;
    370  029f				   coldtwo
    371  029f							;
    372  029f							; The ILTrace flag is now run-time settable.
    373  029f							;
    374  029f		       a9 00		      lda	#ILTRACE&$ff
    375  02a1		       85 40		      sta	ILTrace
    376  02a3							;
    377  02a3
    378  02a3		       a9 00		      lda	#0
    379  02a5		       85 62		      sta	RunMode
    380  02a7		       8d 77 25 	      sta	LINBUF
    381  02aa
    382  02aa							; Clear everything from the stacks
    383  02aa
    384  02aa		       85 60		      sta	taskIOPending	; No one waiting for io
    385  02ac		       85 61		      sta	taskRDPending	; No one waiting for bg io
    386  02ae
    387  02ae		       20 b4 0d 	      jsr	taskReset
    388  02b1							;
    389  02b1		       a9 77		      lda	#LINBUF&$ff
    390  02b3		       85 4f		      sta	CURPTR
    391  02b5		       a9 25		      lda	#LINBUF>>8
    392  02b7		       85 50		      sta	CURPTR+1	;fall through...
    393  02b9
    394  02b9							;=====================================================
    395  02b9							; This is the top of the IL interpreter.  This fetches
    396  02b9							; and executes the instruction currently pointed to
    397  02b9							; by ILPC and adjusts ILPC to point to the next
    398  02b9							; instruction to execute.
    399  02b9							;
    400  02b9		       ce b8 1d    NextIL     dec	taskCurrentCycles
    401  02bc		       d0 03		      bne	NextIlNow
    402  02be		       20 dd 0d 	      jsr	iTaskSwitch	;check for a task switch
    403  02c1		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    404  02c3		       f0 03		      beq	NextIL2	;Skip if no bits set
    405  02c5
    406  02c5		       20 02 15 	      jsr	dbgLine	;Print the IL trace information
    407  02c8
    408  02c8		       a4 51	   NextIL2    ldy	CUROFF
    409  02ca		       20 6d 14 	      jsr	SkipSpaces
    410  02cd		       84 51		      sty	CUROFF
    411  02cf							;Task IO Management
    412  02cf		       a5 61		      lda	taskRDPending	; if it is zero then Nothing pending
    413  02d1		       f0 07		      beq	NextILStr
    414  02d3		       20 c2 12 	      jsr	ReadLine	; else Pending and poll keyboard
    415  02d6		       90 02		      bcc	NextILStr	; if carry is clear then no end of line yet
    416  02d8		       c6 61		      dec	taskRDPending	; Carry is set if CR has been recieved
    417  02da							;
    418  02da		       20 dd 10    NextILStr  jsr	getILByte
    419  02dd							;
    420  02dd							; When the handler is called, these are the conditions
    421  02dd							; of several important items:
    422  02dd							;
    423  02dd							;    (ILPC) will point to the byte AFTER the IL
    424  02dd							;    opcode being executed.
    425  02dd							;
    426  02dd							;    (CURPTR),CUROFF will point to the start of the
    427  02dd							;    next word in the input buffer.  Ie, the next word
    428  02dd							;    in the user program.
    429  02dd							;
    430  02dd		       0a		      asl
    431  02de		       c9 c6		      cmp	#ILTBLend-ILTBL+2
    432  02e0		       90 33		      bcc	ILgood
    433  02e2							;
    434  02e2							; This handles an illegal IL opcode.  This is serious
    435  02e2							; and there's no way to recover.
    436  02e2							;
    437  02e2		       20 f8 15    ILbad      jsr	puts
      0  02e5					      db	CR,LF
      1  02e5		       0d 0a		      .byte.b	CR,LF
      0  02e7					      db	"Illegal IL "
      1  02e7		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f2					      db	0
      1  02f2		       00		      .byte.b	0
    441  02f3							;
    442  02f3							; Well this is awkward, we need to back up the IL
    443  02f3							; by one since it no longer points to the current
    444  02f3							; opcode.
    445  02f3							;
    446  02f3		       20 ea 10 	      jsr	decIL
    447  02f6							;
    448  02f6		       a0 00		      ldy	#0
    449  02f8		       b1 43		      lda	(ILPC),y
    450  02fa		       20 51 16 	      jsr	OUTHEX
    451  02fd		       20 f8 15 	      jsr	puts
      0  0300					      db	" at ",0
      1  0300		       20 61 74 20*	      .byte.b	" at ",0
    453  0305		       a5 44		      lda	ILPC+1
    454  0307		       20 51 16 	      jsr	OUTHEX
    455  030a		       a5 43		      lda	ILPC
    456  030c		       20 51 16 	      jsr	OUTHEX
    457  030f		       20 76 14 	      jsr	CRLF
    458  0312		       4c 03 f0 	      jmp	MONITOR
    459  0315							;
    460  0315							; Just jump to the address (ILPC),y.  Have to do
    461  0315							; some goofy stuff.
    462  0315							;
    463  0315		       a8	   ILgood     tay		;move index into Y
    464  0316		       b9 23 03 	      lda	ILTBL,y
    465  0319		       85 59		      sta	dpl
    466  031b		       b9 24 03 	      lda	ILTBL+1,y
    467  031e		       85 5a		      sta	dpl+1
    468  0320		       6c 59 00 	      jmp	(dpl)	;go to handler
    469  0323							;
    470  0323							;=====================================================
    471  0323							; This is the IL jump table.  The IL opcode is
    472  0323							; mulitplied by two, then looked-up in this table.
    473  0323							; There is absolutely nothing special about the order
    474  0323							; of entries here... they all decode at exactly the
    475  0323							; same speed.	However the entry number must match the
    476  0323							; values in IL.inc.
    477  0323							;
    478  0323				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0323					      include	"ilvectortable.asm"
      1  0323					      seg	Code
      2  0323
      0  0323					      dw	iXINIT	;0
      1  0323		       19 04		      .word.w	iXINIT
      0  0325					      dw	iDONE	;1
      1  0325		       34 04		      .word.w	iDONE
      0  0327					      dw	iPRS	;2
      1  0327		       50 04		      .word.w	iPRS
      0  0329					      dw	iPRN	;3
      1  0329		       5a 04		      .word.w	iPRN
      0  032b					      dw	iSPC	;4
      1  032b		       63 04		      .word.w	iSPC
      0  032d					      dw	iNLINE	;5
      1  032d		       fd 08		      .word.w	iNLINE
      0  032f					      dw	iNXT	;6
      1  032f		       6b 04		      .word.w	iNXT
      0  0331					      dw	iXFER	;7
      1  0331		       97 04		      .word.w	iXFER
      0  0333					      dw	iSAV	;8
      1  0333		       c4 04		      .word.w	iSAV
      0  0335					      dw	iRSTR	;9
      1  0335		       07 05		      .word.w	iRSTR
      0  0337					      dw	iCMPR	;10
      1  0337		       3c 05		      .word.w	iCMPR
      0  0339					      dw	iINNUM	;11
      1  0339		       bd 05		      .word.w	iINNUM
      0  033b					      dw	iFIN	;12
      1  033b		       f1 05		      .word.w	iFIN
      0  033d					      dw	iERR	;13
      1  033d		       05 06		      .word.w	iERR
      0  033f					      dw	iADD	;14
      1  033f		       75 06		      .word.w	iADD
      0  0341					      dw	iSUB	;15
      1  0341		       8b 06		      .word.w	iSUB
      0  0343					      dw	iNEG	;16
      1  0343		       a1 06		      .word.w	iNEG
      0  0345					      dw	iMUL	;17
      1  0345		       b9 06		      .word.w	iMUL
      0  0347					      dw	iDIV	;18
      1  0347		       f9 06		      .word.w	iDIV
      0  0349					      dw	iSTORE	;19
      1  0349		       4f 07		      .word.w	iSTORE
      0  034b					      dw	iIND	;20
      1  034b		       67 07		      .word.w	iIND
      0  034d					      dw	iLST	;21
      1  034d		       d5 07		      .word.w	iLST
      0  034f					      dw	iINIT	;22
      1  034f		       e7 03		      .word.w	iINIT
      0  0351					      dw	iGETLINE	;23
      1  0351		       34 08		      .word.w	iGETLINE
      0  0353					      dw	iINSRT	;24
      1  0353		       42 08		      .word.w	iINSRT
      0  0355					      dw	iRTN	;25
      1  0355		       f7 08		      .word.w	iRTN
      0  0357					      dw	MONITOR	;26
      1  0357		       03 f0		      .word.w	MONITOR
      0  0359					      dw	iLIT	;27
      1  0359		       1d 09		      .word.w	iLIT
      0  035b					      dw	iCALL	;28
      1  035b		       03 09		      .word.w	iCALL
      0  035d					      dw	iJMP	;29
      1  035d		       0b 09		      .word.w	iJMP
      0  035f					      dw	iVINIT	;30
      1  035f		       3a 09		      .word.w	iVINIT
      0  0361					      dw	iERRGOTO	;31
      1  0361		       40 09		      .word.w	iERRGOTO
      0  0363					      dw	iTST	;32
      1  0363		       4c 09		      .word.w	iTST
      0  0365					      dw	iTSTV	;33
      1  0365		       fa 09		      .word.w	iTSTV
      0  0367					      dw	iTSTL	;34
      1  0367		       78 0a		      .word.w	iTSTL
      0  0369					      dw	iTSTN	;35
      1  0369		       92 0a		      .word.w	iTSTN
      0  036b					      dw	iFREE	;36
      1  036b		       0c 0b		      .word.w	iFREE
      0  036d					      dw	iRANDOM	;37
      1  036d		       15 0b		      .word.w	iRANDOM
      0  036f					      dw	iABS	;38
      1  036f		       e6 0b		      .word.w	iABS
     42  0371							;
     43  0371							; Disk functions.  There must be pointers
     44  0371							; to functions even if no disk is supported.
     45  0371							; Makes things easier in IL.inc.
     46  0371							;
     47  0371					      if	DISK_ACCESS
      0  0371					      dw	iOPENREAD	;39
      1  0371		       fa 16		      .word.w	iOPENREAD
      0  0373					      dw	iOPENWRITE	;40
      1  0373		       4e 17		      .word.w	iOPENWRITE
      0  0375					      dw	iDCLOSE	;41
      1  0375		       d2 17		      .word.w	iDCLOSE
      0  0377					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0377		       6d 17		      .word.w	iDGETLINE
      0  0379					      dw	iDLIST	;43 Did you remeber your towel?
      1  0379		       cc 17		      .word.w	iDLIST
      0  037b					      dw	iDDIR	;44
      1  037b		       a7 17		      .word.w	iDDIR
      0  037d					      dw	iRMFILE	;45
      1  037d		       28 17		      .word.w	iRMFILE
     55  037f				  -	      else
     56  037f				  -	      dw	NextIL	;39
     57  037f				  -	      dw	NextIL	;40
     58  037f				  -	      dw	NextIL	;41
     59  037f				  -	      dw	NextIL	;42
     60  037f				  -	      dw	NextIL	;43
     61  037f				  -	      dw	NextIL	;44
     62  037f				  -	      dw	NextIL	;45
     63  037f					      endif
     64  037f							;
      0  037f					      dw	iCLEARSCREEN	;46
      1  037f		       6e 16		      .word.w	iCLEARSCREEN
      0  0381					      dw	iPOKEMEMORY	;47
      1  0381		       73 0b		      .word.w	iPOKEMEMORY
      0  0383					      dw	iPEEKMEMORY	;48
      1  0383		       88 0b		      .word.w	iPEEKMEMORY
      0  0385					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0385		       91 09		      .word.w	iTSTLET
      0  0387					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0387		       cd 09		      .word.w	iTSTDONE
      0  0389					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0389		       b5 0b		      .word.w	iGETCHAR
      0  038b					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038b		       c9 0b		      .word.w	iPUTCHAR
      0  038d					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038d		       9e 0b		      .word.w	iCallFunc
      0  038f					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038f		       8d 05		      .word.w	iBranch
      0  0391					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0391		       75 09		      .word.w	iTSTStr
      0  0393					      dw	iSetIrq	;56	   sets the irq handler
      1  0393		       63 0c		      .word.w	iSetIrq
      0  0395					      dw	iTstIrq	;57	   test if irq is pending
      1  0395		       d5 0a		      .word.w	iTstIrq
      0  0397					      dw	iRET	;58	   return from interupt
      1  0397		       f5 04		      .word.w	iRET
      0  0399					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0399		       d4 05		      .word.w	iINSTR
      0  039b					      dw	iMOD	;60	   returns remainder of division
      1  039b		       02 07		      .word.w	iMOD
      0  039d					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039d		       25 0e		      .word.w	iTaskSet
      0  039f					      dw	iETask	;62	   Terminates a task
      1  039f		       46 0f		      .word.w	iETask
      0  03a1					      dw	iNTask	;63	   goto next task
      1  03a1		       03 0f		      .word.w	iNTask
      0  03a3					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a3		       7c 07		      .word.w	iArray
      0  03a5					      dw	iTaskKill	;65	   kill a running task
      1  03a5		       fb 0e		      .word.w	iTaskKill
      0  03a7					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a7		       cf 0e		      .word.w	iTaskStat
      0  03a9					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a9		       d4 0b		      .word.w	iHexOut
      0  03ab					      dw	iReadComplete	;68	   Called after a background read completes
      1  03ab		       a9 05		      .word.w	iReadComplete
      0  03ad					      dw	iReadStart	;69	   Called to start a background read request
      1  03ad		       9f 05		      .word.w	iReadStart
      0  03af					      dw	iStartIO	;70	   Lock task until io complete
      1  03af		       2c 0f		      .word.w	iStartIO
      0  03b1					      dw	iEndIO	;71	   release task lock for io
      1  03b1		       31 0f		      .word.w	iEndIO
      0  03b3					      dw	iLogNot	;72	   Logical not
      1  03b3		       3f 0c		      .word.w	iLogNot
      0  03b5					      dw	iLogOr	;73	   Logical Or
      1  03b5		       15 0c		      .word.w	iLogOr
      0  03b7					      dw	iLogAnd	;74	   Logical And
      1  03b7		       00 0c		      .word.w	iLogAnd
      0  03b9					      dw	iLogXor	;75	   Logical Xor
      1  03b9		       2a 0c		      .word.w	iLogXor
      0  03bb					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bb		       0b 0f		      .word.w	iWTASK
      0  03bd					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03bd		       3a 0f		      .word.w	iTASKPID
      0  03bf					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bf		       9f 0c		      .word.w	iTRACEPROG
      0  03c1					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c1		       83 14		      .word.w	idbgBasic
      0  03c3					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c3		       dc 0f		      .word.w	iIPCS
      0  03c5					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c5		       f3 0f		      .word.w	iIPCR
      0  03c7					      dw	iIPCC	;82	   Check if any message available for task
      1  03c7		       07 10		      .word.w	iIPCC
      0  03c9					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c9		       14 10		      .word.w	iIPCIO
      0  03cb					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cb		       a9 0c		      .word.w	iPushMathStack
      0  03cd					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03cd		       d9 0c		      .word.w	iPopMathStack
      0  03cf					      dw	iSaveMathStack	;86	   Save all math info
      1  03cf		       f6 0c		      .word.w	iSaveMathStack
      0  03d1					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d1		       15 0d		      .word.w	iRestoreMathStack
      0  03d3					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d3		       c6 0c		      .word.w	iIncParmCount
      0  03d5					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d5		       63 0f		      .word.w	iTaskGetMathStack
      0  03d7					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d7		       9d 0e		      .word.w	iTaskEnable
      0  03d9					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d9		       b7 0e		      .word.w	iTaskSuspend
      0  03db					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03db		       7d 0f		      .word.w	iTaskPutMathPtr
      0  03dd					      dw	iTSTVT	;93	   test for another tasks variable
      1  03dd		       f1 09		      .word.w	iTSTVT
      0  03df					      dw	iSetR2	;94
      1  03df		       15 09		      .word.w	iSetR2
      0  03e1					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e1		       d3 04		      .word.w	iStk2Tmp
      0  03e3					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e3		       e4 04		      .word.w	iTmp2Stk
      0  03e5					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e5		       af 09		      .word.w	iTSTBYTE
    117  03e7
------- FILE mytb.asm
    480  03e7		       03 e7	   ILTBLend   equ	*
    481  03e7							;
    482  03e7							;=====================================================
    483  03e7							;=====================================================
    484  03e7							;=====================================================
    485  03e7							; This marks the start of the handlers for IL opcodes.
    486  03e7							;=====================================================
    487  03e7							;=====================================================
    488  03e7							;=====================================================
    489  03e7							;
    490  03e7							;
    491  03e7		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    492  03e9		       85 47		      sta	ILSTACKPTR
    493  03eb		       85 4a		      sta	MATHSTACKPTR
    494  03ed		       85 4d		      sta	GOSUBSTACKPTR
    495  03ef		       a9 40		      lda	#GOSUBSTACKSIZE*4
    496  03f1		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    497  03f3							;
    498  03f3		       a9 15		      lda	#ProgramStart&$ff	;user prog
    499  03f5		       85 4f		      sta	CURPTR
    500  03f7		       8d bf 1c 	      sta	taskTable+1
    501  03fa		       8d 0d 26 	      sta	PROGRAMEND
    502  03fd		       a9 26		      lda	#ProgramStart>>8
    503  03ff		       85 50		      sta	CURPTR+1
    504  0401		       8d c0 1c 	      sta	taskTable+2
    505  0404		       8d 0e 26 	      sta	PROGRAMEND+1
    506  0407		       a9 80		      lda	#TASKACTIVE
    507  0409		       8d be 1c 	      sta	taskTable	;Mark the first slot as active
    508  040c		       a9 01		      lda	#1
    509  040e		       8d ba 1d 	      sta	taskCounter	;there is always one task / Main task
    510  0411		       a9 c8		      lda	#TASKCYCLESDEFAULT
    511  0413		       8d b9 1d 	      sta	taskResetValue
    512  0416		       8d b8 1d 	      sta	taskCurrentCycles	; set up the task switch counts
    513  0419							;
    514  0419							; fall into XINIT...
    515  0419							;
    516  0419							;=====================================================
    517  0419							; This initializes for the start of the next line of
    518  0419							; BASIC text.
    519  0419							;
    520  0419		       78	   iXINIT     sei		;ensure interupts are off
    521  041a		       20 b4 0d 	      jsr	taskReset	;Clear the task table
    522  041d		       8d ba 1c 	      sta	IRQPending	; reset the irq pending
    523  0420		       8d b9 1c 	      sta	IRQStatus	; Make sure irqs are off
    524  0423
    525  0423		       4c b9 02    goodExit   jmp	NextIL
    526  0426							;
    527  0426							;=====================================================
    528  0426							; This check if the escape key has been entered
    529  0426							; then changes out of run mode. z Set if esc found
    530  0426				   BreakSet
    531  0426		       20 0f f0 	      jsr	ISCHAR
    532  0429		       f0 06		      beq	BreakNo
    533  042b		       20 f5 15 	      jsr	VGETCH
    534  042e		       c9 1b		      cmp	#$1B
    535  0430		       60		      rts
    536  0431				   BreakNo
    537  0431		       a9 01		      lda	#1
    538  0433		       60		      rts
    539  0434
    540  0434							;
    541  0434
    542  0434							;=====================================================
    543  0434							; Verify there is nothing else on this input line.
    544  0434							; If there is, generate an error.
    545  0434							;
    546  0434		       a4 51	   iDONE      ldy	CUROFF
    547  0436		       20 6d 14 	      jsr	SkipSpaces
    548  0439		       b1 4f		      lda	(CURPTR),y
    549  043b		       f0 10		      beq	doneadv
    550  043d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    551  043f		       d0 05		      bne	idoneErr
    552  0441		       84 51		      sty	CUROFF
    553  0443		       4c b9 02 	      jmp	NextIL	; continue on this line
    554  0446
    555  0446				   idoneErr
    556  0446		       a2 04		      ldx	#ERR_EXTRA_STUFF
    557  0448		       a9 00		      lda	#0
    558  044a		       4c 08 06 	      jmp	iErr2
    559  044d							;
    560  044d							; Advance to the next line
    561  044d							;
    562  044d				   doneadv
    563  044d							;		 jsr	 FindNext2
    564  044d		       4c b9 02 	      jmp	NextIL
    565  0450							;
    566  0450							;=====================================================
    567  0450							; Print the string until a closing quote
    568  0450							;
    569  0450		       a4 51	   iPRS       ldy	CUROFF
    570  0452							;
    571  0452							; Odd logic here.  The main loop skipped any leading
    572  0452							; whitespace inside the quoted text, so move back to
    573  0452							; the quote, then move forward again.
    574  0452							;
    575  0452		       20 22 16 	      jsr	PrtQuoted
    576  0455		       84 51		      sty	CUROFF
    577  0457		       4c b9 02 	      jmp	NextIL
    578  045a							;
    579  045a							;=====================================================
    580  045a							; Pop the top off the stack and print it as a signed
    581  045a							; decimal number.
    582  045a							;
    583  045a		       20 bd 13    iPRN       jsr	popR0
    584  045d		       20 84 11 	      jsr	PrintDecimal
    585  0460		       4c b9 02 	      jmp	NextIL
    586  0463							;
    587  0463							;=====================================================
    588  0463							; Space to next zone.	Currently the code does not
    589  0463							; keep track of which column the output is on, so
    590  0463							; just print a tab.
    591  0463							;
    592  0463		       a9 09	   iSPC       lda	#TAB
    593  0465		       20 f2 15 	      jsr	VOUTCH
    594  0468		       4c b9 02 	      jmp	NextIL
    595  046b							;
    596  046b							;=====================================================
    597  046b							; If in immediate mode, jump to the address following
    598  046b							; the NXT instruction.  Else move to the next line of
    599  046b							; user code and continue.
    600  046b							;
    601  046b		       a5 62	   iNXT       lda	RunMode
    602  046d		       d0 03		      bne	iNxtRun	;in run mode
    603  046f							;
    604  046f							; Get address and jump to it.
    605  046f							;
    606  046f		       4c 0b 09 	      jmp	iJMP
    607  0472							;
    608  0472				   iNxtRun
    609  0472		       a4 51		      ldy	CUROFF
    610  0474		       20 6d 14 	      jsr	SkipSpaces
    611  0477		       b1 4f		      lda	(CURPTR),y
    612  0479		       c9 3a		      cmp	#COLON
    613  047b		       d0 09		      bne	iNxtRunGo
    614  047d		       c8		      iny
    615  047e		       20 6d 14 	      jsr	SkipSpaces
    616  0481		       84 51		      sty	CUROFF
    617  0483		       4c 91 04 	      jmp	iNxtRun2
    618  0486
    619  0486				   iNxtRunGo
    620  0486		       20 65 11 	      jsr	FindNextLine
    621  0489		       20 77 11 	      jsr	AtEnd
    622  048c		       d0 03		      bne	iNxtRun2	;not at end
    623  048e							;
    624  048e							; At the end of the program.  Pretend an END statement
    625  048e							; was found.
    626  048e							;
    627  048e		       4c f1 05    iFINv      jmp	iFIN
    628  0491							;
    629  0491		       20 d9 10    iNxtRun2   jsr	getILWord	;ignore next word
    630  0494		       4c b9 02 	      jmp	NextIL
    631  0497							;
    632  0497							;=====================================================
    633  0497							; XFER takes the number on top of the stack and looks
    634  0497							; for that line in the program, or the next line
    635  0497							; higher.  Ie, if it's 1 but there is no line 1, then
    636  0497							; find the next one after that.
    637  0497							;
    638  0497		       20 bd 13    iXFER      jsr	popR0
    639  049a		       20 22 11 	      jsr	findLine
    640  049d		       20 77 11    iXFER2     jsr	AtEnd	;at end of user program?
    641  04a0		       f0 ec		      beq	iFINv
    642  04a2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    643  04a4		       84 51		      sty	CUROFF
    644  04a6		       a9 ff		      lda	#$ff
    645  04a8		       85 62		      sta	RunMode
    646  04aa							;
    647  04aa							; Transfer IL to STMT.  I don't like having this
    648  04aa							; hard-coded; fix it.
    649  04aa							;
    650  04aa		       a9 2d		      lda	#STMT&$ff
    651  04ac		       85 43		      sta	ILPC
    652  04ae		       a9 18		      lda	#STMT>>8
    653  04b0		       85 44		      sta	ILPC+1
    654  04b2		       4c b9 02 	      jmp	NextIL
    655  04b5							;
    656  04b5							; Run
    657  04b5							;
    658  04b5				   iXferok
    659  04b5		       a9 ff		      lda	#$ff
    660  04b7		       85 62		      sta	RunMode	;we're running
    661  04b9							;
    662  04b9							; Need a more elegant way to do this
    663  04b9							;
    664  04b9		       a9 2d		      lda	#STMT&$ff
    665  04bb		       85 43		      sta	ILPC
    666  04bd		       a9 18		      lda	#STMT>>8
    667  04bf		       85 44		      sta	ILPC+1
    668  04c1		       4c b9 02 	      jmp	NextIL
    669  04c4							;
    670  04c4							;=====================================================
    671  04c4							; Save the pointer to the next line to the call stack.
    672  04c4							;
    673  04c4		       20 53 13    iSAV       jsr	pushLN
    674  04c7		       b0 03		      bcs	iSAVErr
    675  04c9		       4c b9 02 	      jmp	NextIL
    676  04cc
    677  04cc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    678  04ce		       a9 00	   iSAVErr2   lda	#0
    679  04d0		       4c 08 06 	      jmp	iErr2
    680  04d3							;====================================================
    681  04d3							; Move stack top to and from temp area
    682  04d3				   iStk2Tmp
    683  04d3		       20 bd 13 	      jsr	popR0
    684  04d6		       a5 52		      lda	R0
    685  04d8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    686  04da		       91 41		      sta	(VARIABLES),y
    687  04dc		       c8		      iny
    688  04dd		       a5 53		      lda	R0+1
    689  04df		       91 41		      sta	(VARIABLES),y
    690  04e1		       4c b9 02 	      jmp	NextIL
    691  04e4
    692  04e4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    693  04e6		       b1 41		      lda	(VARIABLES),y
    694  04e8		       85 52		      sta	R0
    695  04ea		       c8		      iny
    696  04eb		       b1 41		      lda	(VARIABLES),y
    697  04ed		       85 53		      sta	R0+1
    698  04ef		       20 39 13 	      jsr	pushR0
    699  04f2		       4c b9 02 	      jmp	NextIL
    700  04f5							;
    701  04f5							;=====================================================
    702  04f5							; Pop the next line from the call stack.
    703  04f5							;
    704  04f5		       20 78 13    iRET       jsr	popLN
    705  04f8		       b0 d2		      bcs	iSAVErr
    706  04fa		       a0 03		      ldy	#3
    707  04fc		       84 51		      sty	CUROFF
    708  04fe		       a9 00		      lda	#0
    709  0500		       8d ba 1c 	      sta	IRQPending
    710  0503		       58		      cli
    711  0504		       4c b9 02 	      jmp	NextIL
    712  0507							;
    713  0507							;=====================================================
    714  0507							; Return from GOSUB function
    715  0507							;
    716  0507		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    717  0509		       f0 0f		      beq	iRSTRNoValue
    718  050b		       a5 58		      lda	R2
    719  050d		       85 56		      sta	MQ
    720  050f		       88		      dey
    721  0510		       b1 4b		      lda	(GOSUBSTACK),y
    722  0512		       c9 81		      cmp	#GOSUB_RTN_VALUE
    723  0514		       d0 04		      bne	iRSTRNoValue
    724  0516		       a9 01		      lda	#1
    725  0518		       d0 02		      bne	iRSTRExit
    726  051a				   iRSTRNoValue
    727  051a		       a9 00		      lda	#0
    728  051c				   iRSTRExit
    729  051c		       85 58		      sta	R2
    730  051e		       20 78 13 	      jsr	popLN
    731  0521		       b0 06		      bcs	iRSTRErr
    732  0523		       20 df 0c 	      jsr	PopMathStackNow
    733  0526		       4c b9 02 	      jmp	NextIL
    734  0529
    735  0529		       ad bd 1c    iRSTRErr   lda	taskPtr	; Check if this is task zero
    736  052c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    737  052e		       a5 56		      lda	MQ
    738  0530		       d0 03		      bne	taskRet
    739  0532		       20 83 16 	      jsr	pushFalse	; the result code by default is 0
    740  0535				   taskRet
    741  0535		       4c 46 0f 	      jmp	iETask	; not task zero then do a task end instead
    742  0538				   taskZeroEnd
    743  0538		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    744  053a		       d0 92		      bne	iSAVErr2
    745  053c							;
    746  053c							;=====================================================
    747  053c							; Compare items on stack.  Okay, so on input there are
    748  053c							; three things on the stack
    749  053c							;
    750  053c							;    EXPR2 <- Top of stack
    751  053c							;    OP    <- relational operator, next on stack
    752  053c							;    EXPR1 <- last item on stack
    753  053c							;
    754  053c							; Comparison is: EXPR1 <operator> EXPR2
    755  053c							;
    756  053c							; Operator is one of...
    757  053c							;
    758  053c							;    2 is =
    759  053c							;    1 is <
    760  053c							;    3 is <=
    761  053c							;    5 is <>
    762  053c							;    4 is >
    763  053c							;    6 is >=
    764  053c							;
    765  053c							; Those are bit-mapped:
    766  053c							;
    767  053c							;    xxxxxGEL
    768  053c							;
    769  053c							;    G = Greater than
    770  053c							;    E = Equal
    771  053c							;    L = Less than
    772  053c							;
    773  053c							; If the comparison is false, do a NXT, ie, move to the
    774  053c							; next line and continue.  If true, continue executing
    775  053c							; on this line.
    776  053c							;
    777  053c		       00 01	   REL_LT     equ	%001
    778  053c		       00 02	   REL_EQUAL  equ	%010
    779  053c		       00 04	   REL_GT     equ	%100
    780  053c							;
    781  053c		       20 d5 13    iCMPR      jsr	popR1
    782  053f		       20 ec 13 	      jsr	popMQ	;operator in MQ
    783  0542		       20 bd 13 	      jsr	popR0
    784  0545		       20 4e 05 	      jsr	iCMPRsub
    785  0548		       20 39 13 	      jsr	pushR0
    786  054b		       4c b9 02 	      jmp	NextIL
    787  054e							;
    788  054e							; See if they are equal or not
    789  054e							;
    790  054e				   iCMPRsub		; Called by internal functions
    791  054e
    792  054e		       a5 52		      lda	R0
    793  0550		       c5 54		      cmp	R1
    794  0552		       d0 0a		      bne	iCMPRnoteq	;try not equal
    795  0554		       a5 53		      lda	R0+1
    796  0556		       c5 55		      cmp	R1+1
    797  0558		       d0 04		      bne	iCMPRnoteq
    798  055a							;
    799  055a							; Equal, set the flag in MQ+1
    800  055a							;
    801  055a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    802  055c		       d0 14		      bne	iCMPcom	;Exit it is equal
    803  055e							;
    804  055e							; See if EXPR1 (R0) < EXPR2 (R1)
    805  055e							; See www.6502.org/tutorials/compare_beyond.html
    806  055e							;
    807  055e				   iCMPRnoteq
    808  055e		       a5 52		      lda	R0
    809  0560		       c5 54		      cmp	R1
    810  0562		       a5 53		      lda	R0+1
    811  0564		       e5 55		      sbc	R1+1
    812  0566		       50 02		      bvc	iCMPR_2
    813  0568		       49 80		      eor	#$80
    814  056a		       30 04	   iCMPR_2    bmi	iCMPlt
    815  056c		       a9 04		      lda	#REL_GT
    816  056e		       d0 02		      bne	iCMPcom
    817  0570		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    818  0572
    819  0572		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    820  0574							;
    821  0574							; Now compare the end result with what the caller
    822  0574							; was looking for.
    823  0574							;
    824  0574		       25 56		      and	MQ
    825  0576		       f0 0c		      beq	iCMPno	; no match
    826  0578		       a9 ff		      lda	#$FF	; true is $ffff
    827  057a		       85 52		      sta	R0
    828  057c		       85 53		      sta	R0+1
    829  057e		       d0 0c		      bne	iCMPDone
    830  0580							;
    831  0580							; R0 > R1
    832  0580							;
    833  0580		       a9 04	   iCMPgt     lda	#REL_GT
    834  0582		       d0 ee		      bne	iCMPcom
    835  0584				   iCMPno
    836  0584		       a9 00		      lda	#0
    837  0586		       85 52		      sta	R0
    838  0588		       a9 00		      lda	#0
    839  058a		       85 53		      sta	R0+1
    840  058c
    841  058c				   iCMPDone
    842  058c		       60		      rts
    843  058d
    844  058d							;
    845  058d							; if Not a match, so jump to the next line of code.
    846  058d							; Branches based upon value on top of the stack
    847  058d				   iBranch
    848  058d		       20 bd 13 	      jsr	popR0
    849  0590		       a5 52		      lda	R0
    850  0592		       05 53		      ora	R0+1
    851  0594		       f0 03		      beq	iBranchFalse	; not true
    852  0596		       4c b9 02 	      jmp	NextIL	; It is true if any value not zero
    853  0599							;
    854  0599				   iBranchFalse
    855  0599		       20 65 11 	      jsr	FindNextLine
    856  059c		       4c 9d 04 	      jmp	iXFER2
    857  059f							;
    858  059f							;=====================================================
    859  059f							; Start a read of data in background
    860  059f				   iReadStart
    861  059f		       a9 3f		      lda	#'?	; Prompt with question mark
    862  05a1		       a6 01		      ldx	1	; Indicate to start read in background
    863  05a3		       20 5b 12 	      jsr	GetLine	; Call the getline to start read
    864  05a6		       4c b9 02 	      jmp	NextIL	; next instruction
    865  05a9							;
    866  05a9							;=====================================================
    867  05a9							; Complete the read and return the curptr, curoff pointing to data
    868  05a9				   iReadComplete
    869  05a9		       20 53 13 	      jsr	pushLN
    870  05ac		       90 03		      bcc	iReadOk
    871  05ae		       4c 05 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    872  05b1				   iReadOk
    873  05b1		       20 7b 12 	      jsr	ReadComplete
    874  05b4		       4c b9 02 	      jmp	NextIL
    875  05b7		       20 78 13 	      jsr	popLN
    876  05ba		       4c b9 02 	      jmp	NextIL
    877  05bd							;=====================================================
    878  05bd							; Get a line of text from the user, convert to a
    879  05bd							; number, leave on top of stack.
    880  05bd							;
    881  05bd				   iINNUM
    882  05bd		       20 53 13 	      jsr	pushLN
    883  05c0		       b0 ec		      bcs	iReadErr	; Stack over flow error
    884  05c2							;
    885  05c2		       a9 3f		      lda	#'?
    886  05c4		       a2 00		      ldx	#0	;Wait for complete
    887  05c6		       20 5b 12 	      jsr	GetLine
    888  05c9		       20 f0 11 	      jsr	getDecimal
    889  05cc		       20 39 13 	      jsr	pushR0	;put onto stack
    890  05cf		       b0 dd		      bcs	iReadErr	;StackOverflow error
    891  05d1							;
    892  05d1		       4c eb 05 	      jmp	ExitIn
    893  05d4							;
    894  05d4							;=====================================================
    895  05d4							; Get a line of text from the user, convert to a
    896  05d4							; character value , leave on top of stack. up to 2 characters
    897  05d4							;
    898  05d4				   iINSTR
    899  05d4		       20 53 13 	      jsr	pushLN
    900  05d7		       b0 d5		      bcs	iReadErr	; Stack overflow error
    901  05d9		       a9 3f		      lda	#'?
    902  05db		       a2 00		      ldx	#0	;wait for read complete
    903  05dd		       20 5b 12 	      jsr	GetLine
    904  05e0		       b1 4f		      lda	(CURPTR),y
    905  05e2		       85 52		      sta	R0
    906  05e4		       a9 00		      lda	#0
    907  05e6		       85 53		      sta	R0+1
    908  05e8		       20 39 13 	      jsr	pushR0	;put onto stack
    909  05eb				   ExitIn
    910  05eb		       20 78 13 	      jsr	popLN
    911  05ee		       4c b9 02 	      jmp	NextIL
    912  05f1							;
    913  05f1							;
    914  05f1							;=====================================================
    915  05f1							; Stop the currently running program.	Actually very
    916  05f1							; simple to do... clear the RunMode flag, then set the
    917  05f1							; ILPC to the standard handler and continue running.
    918  05f1							;
    919  05f1		       a9 00	   iFIN       lda	#0
    920  05f3		       85 62		      sta	RunMode
    921  05f5		       20 b4 0d 	      jsr	taskReset
    922  05f8							;
    923  05f8		       ad 01 26 	      lda	errGoto
    924  05fb		       85 43		      sta	ILPC
    925  05fd		       ad 02 26 	      lda	errGoto+1
    926  0600		       85 44		      sta	ILPC+1
    927  0602		       4c b9 02 	      jmp	NextIL
    928  0605							;
    929  0605							;=====================================================
    930  0605							; Handle the ERR opcode.  Following the instruction is
    931  0605							; a 16 bit error number.  Print an error message, and
    932  0605							; if we're in run mode, print the line number.  Stop
    933  0605							; program execution and return to the initial state.
    934  0605							;
    935  0605		       20 d9 10    iERR       jsr	getILWord	;get err code
    936  0608							;
    937  0608							; Enter here with the error code in X (LSB) and A (MSB).
    938  0608							;
    939  0608		       86 52	   iErr2      stx	R0
    940  060a		       85 53		      sta	R0+1
    941  060c							;
    942  060c		       20 f8 15 	      jsr	puts
      0  060f					      db	CR,LF,"Error ",0
      1  060f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    944  0618		       20 84 11 	      jsr	PrintDecimal
    945  061b							;
    946  061b		       a5 62		      lda	RunMode	;running?
    947  061d		       f0 3b		      beq	iERR3	;nope
    948  061f		       20 f8 15 	      jsr	puts
      0  0622					      db	" at line ",0
      1  0622		       20 61 74 20*	      .byte.b	" at line ",0
    950  062c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    951  062e				   iErr2a
    952  062e		       b1 4f		      lda	(CURPTR),y
    953  0630		       85 52		      sta	R0
    954  0632		       c8		      iny
    955  0633		       b1 4f		      lda	(CURPTR),y
    956  0635		       85 53		      sta	R0+1
    957  0637		       20 84 11 	      jsr	PrintDecimal
    958  063a		       20 f8 15 	      jsr	puts
      0  063d					      db	":",0
      1  063d		       3a 00		      .byte.b	":",0
    960  063f		       a9 00		      lda	#0
    961  0641		       85 53		      sta	R0+1
    962  0643		       a5 51		      lda	CUROFF
    963  0645		       18		      clc
    964  0646		       e9 03		      sbc	#3
    965  0648		       85 52		      sta	R0
    966  064a		       20 84 11 	      jsr	PrintDecimal
    967  064d		       20 f8 15 	      jsr	puts
      0  0650					      db	":",0
      1  0650		       3a 00		      .byte.b	":",0
    969  0652		       ad bd 1c 	      lda	taskPtr
    970  0655		       85 52		      sta	R0
    971  0657		       20 84 11 	      jsr	PrintDecimal
    972  065a							;
    973  065a		       20 76 14    iERR3      jsr	CRLF
    974  065d		       20 ac 0d 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    975  0660		       a9 00		      lda	#0
    976  0662		       85 62		      sta	RunMode	;fall through...
    977  0664							;
    978  0664							;=====================================================
    979  0664							; Reset the IL to be back at the idle loop.  Does not
    980  0664							; clear variables so the user can see what state
    981  0664							; the program is in.
    982  0664							;
    983  0664		       a9 00	   ResetIL    lda	#0
    984  0666		       85 47		      sta	ILSTACKPTR
    985  0668		       ad 01 26 	      lda	errGoto
    986  066b		       85 43		      sta	ILPC
    987  066d		       ad 02 26 	      lda	errGoto+1
    988  0670		       85 44		      sta	ILPC+1
    989  0672		       4c b9 02 	      jmp	NextIL
    990  0675
    991  0675							;
    992  0675							;=====================================================
    993  0675							; Pop two items off stack, add them, then place the
    994  0675							; result back onto the stack.
    995  0675							;
    996  0675		       20 bd 13    iADD       jsr	popR0
    997  0678		       20 d5 13 	      jsr	popR1
    998  067b				   iADDfast
    999  067b		       18		      clc
   1000  067c		       a5 52		      lda	R0
   1001  067e		       65 54		      adc	R1
   1002  0680		       85 52		      sta	R0
   1003  0682		       a5 53		      lda	R0+1
   1004  0684		       65 55		      adc	R1+1
   1005  0686		       85 53		      sta	R0+1
   1006  0688		       4c f3 06 	      jmp	pushR0nextIl
   1007  068b							;
   1008  068b							;=====================================================
   1009  068b							; Pop two items off the stack.  Subtract the top of
   1010  068b							; stack from the lower entry.
   1011  068b							;
   1012  068b		       20 d5 13    iSUB       jsr	popR1
   1013  068e		       20 bd 13 	      jsr	popR0
   1014  0691		       38		      sec
   1015  0692		       a5 52		      lda	R0
   1016  0694		       e5 54		      sbc	R1
   1017  0696		       85 52		      sta	R0
   1018  0698		       a5 53		      lda	R0+1
   1019  069a		       e5 55		      sbc	R1+1
   1020  069c		       85 53		      sta	R0+1
   1021  069e		       4c f3 06 	      jmp	pushR0nextIl
   1022  06a1							;
   1023  06a1							;=====================================================
   1024  06a1							; Negate the top of stack.
   1025  06a1							;
   1026  06a1		       20 bd 13    iNEG       jsr	popR0
   1027  06a4		       a5 52		      lda	R0
   1028  06a6		       49 ff		      eor	#$ff
   1029  06a8		       85 52		      sta	R0
   1030  06aa		       a5 53		      lda	R0+1
   1031  06ac		       49 ff		      eor	#$ff
   1032  06ae		       85 53		      sta	R0+1
   1033  06b0		       e6 52		      inc	R0
   1034  06b2		       d0 02		      bne	iNEG2
   1035  06b4		       e6 53		      inc	R0+1
   1036  06b6		       4c f3 06    iNEG2      jmp	pushR0nextIl
   1037  06b9							;
   1038  06b9							;=====================================================
   1039  06b9							; Multiply top two items on the stack, put the results
   1040  06b9							; on top.  This uses the algorithm documented on page
   1041  06b9							; 115 of "Microprocessor Programming for Computer
   1042  06b9							; Hobbyists" by Neill Graham.
   1043  06b9							;
   1044  06b9		       20 bf 06    iMUL       jsr	iMultiply
   1045  06bc		       4c b9 02 	      jmp	NextIL
   1046  06bf
   1047  06bf				   iMultiply
   1048  06bf		       20 bd 13 	      jsr	popR0	;AC
   1049  06c2		       20 d5 13 	      jsr	popR1	;OP
   1050  06c5							;
   1051  06c5		       a5 52		      lda	R0
   1052  06c7		       85 56		      sta	MQ
   1053  06c9		       a5 53		      lda	R0+1
   1054  06cb		       85 57		      sta	MQ+1
   1055  06cd		       a9 00		      lda	#0	;clear result
   1056  06cf		       85 52		      sta	R0
   1057  06d1		       85 53		      sta	R0+1
   1058  06d3							;
   1059  06d3		       a2 10		      ldx	#16	;number of bits in value
   1060  06d5		       06 52	   multloop   asl	R0
   1061  06d7		       26 53		      rol	R0+1
   1062  06d9		       06 56		      asl	MQ
   1063  06db		       26 57		      rol	MQ+1
   1064  06dd		       90 0d		      bcc	multno	;skip add if no carry
   1065  06df							;
   1066  06df							; Add R1 back into R0
   1067  06df							;
   1068  06df		       18		      clc
   1069  06e0		       a5 52		      lda	R0
   1070  06e2		       65 54		      adc	R1
   1071  06e4		       85 52		      sta	R0
   1072  06e6		       a5 53		      lda	R0+1
   1073  06e8		       65 55		      adc	R1+1
   1074  06ea		       85 53		      sta	R0+1
   1075  06ec							;
   1076  06ec		       ca	   multno     dex		;did all bits yet?
   1077  06ed		       d0 e6		      bne	multloop
   1078  06ef		       20 39 13 	      jsr	pushR0	;OP
   1079  06f2		       60		      rts
   1080  06f3							;
   1081  06f3				   pushR0nextIl
   1082  06f3		       20 39 13 	      jsr	pushR0	;OP
   1083  06f6		       4c b9 02 	      jmp	NextIL
   1084  06f9							;
   1085  06f9							;=====================================================
   1086  06f9							; Divide the top of stack into the next to top item.
   1087  06f9							; Leave results on stack.  Taken from:
   1088  06f9							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1089  06f9							;
   1090  06f9							; R0 = R0 / R1
   1091  06f9							; Remainder is in MQ
   1092  06f9							;
   1093  06f9		       20 13 07    iDIV       jsr	iDoDiv
   1094  06fc		       20 3e 14 	      jsr	RestoreSigns
   1095  06ff		       4c f3 06 	      jmp	pushR0nextIl
   1096  0702
   1097  0702		       20 13 07    iMOD       jsr	iDoDiv
   1098  0705		       20 3e 14 	      jsr	RestoreSigns
   1099  0708		       a5 56		      lda	MQ
   1100  070a		       85 52		      sta	R0
   1101  070c		       a5 57		      lda	MQ+1
   1102  070e		       85 53		      sta	R0+1
   1103  0710		       4c f3 06 	      jmp	pushR0nextIl
   1104  0713
   1105  0713				   iDoDiv
   1106  0713		       20 d5 13 	      jsr	popR1
   1107  0716		       20 bd 13 	      jsr	popR0
   1108  0719							;
   1109  0719							; Check for divide by zero
   1110  0719							;
   1111  0719
   1112  0719				   iDivNoPop
   1113  0719		       a5 54		      lda	R1
   1114  071b		       05 55		      ora	R1+1
   1115  071d		       f0 29		      beq	divby0
   1116  071f							;
   1117  071f		       20 03 14 	      jsr	SaveSigns
   1118  0722		       a9 00		      lda	#0	;preset remainder to 0
   1119  0724		       85 56		      sta	MQ
   1120  0726		       85 57		      sta	MQ+1
   1121  0728		       a2 10		      ldx	#16	;repeat for each bit: ...
   1122  072a				   divloop
   1123  072a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1124  072c		       26 53		      rol	R0+1
   1125  072e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1126  0730		       26 57		      rol	MQ+1
   1127  0732		       a5 56		      lda	MQ
   1128  0734		       38		      sec
   1129  0735		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1130  0737		       a8		      tay		;lb result -> Y, for we may need it later
   1131  0738		       a5 57		      lda	MQ+1
   1132  073a		       e5 55		      sbc	R1+1
   1133  073c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1134  073e
   1135  073e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1136  0740		       84 56		      sty	MQ
   1137  0742		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1138  0744
   1139  0744		       ca	   skip       dex
   1140  0745		       d0 e3		      bne	divloop
   1141  0747		       60		      rts
   1142  0748							;
   1143  0748							; Indicate divide-by-zero error
   1144  0748							;
   1145  0748		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1146  074a		       a9 00		      lda	#0
   1147  074c		       4c 08 06 	      jmp	iErr2
   1148  074f							;
   1149  074f							;=====================================================
   1150  074f							; This pops the top two items off the stack.  The top
   1151  074f							; item is a data value and the other is an ABSOLUTE address.
   1152  074f							;Save the value into that address.
   1153  074f							;
   1154  074f		       98	   iSTORE     tya
   1155  0750		       48		      pha
   1156  0751		       20 bd 13 	      jsr	popR0	;data
   1157  0754		       20 d5 13 	      jsr	popR1	;Storage location
   1158  0757		       a0 00		      ldy	#0
   1159  0759		       a5 52		      lda	R0
   1160  075b		       91 54		      sta	(R1),y
   1161  075d		       a5 53		      lda	R0+1
   1162  075f		       c8		      iny
   1163  0760		       91 54		      sta	(R1),y
   1164  0762		       68		      pla
   1165  0763		       a8		      tay
   1166  0764		       4c b9 02 	      jmp	NextIL
   1167  0767							;
   1168  0767							;=====================================================
   1169  0767							; Replaces the top of stack with the variable whose
   1170  0767							; absolute address it represents.
   1171  0767							;
   1172  0767		       98	   iIND       tya
   1173  0768		       48		      pha
   1174  0769		       20 d5 13 	      jsr	popR1
   1175  076c		       a0 00		      ldy	#0
   1176  076e		       b1 54		      lda	(R1),y
   1177  0770		       85 52		      sta	R0
   1178  0772		       c8		      iny
   1179  0773		       b1 54		      lda	(R1),y
   1180  0775		       85 53		      sta	R0+1
   1181  0777		       68		      pla
   1182  0778		       a8		      tay
   1183  0779		       4c f3 06 	      jmp	pushR0nextIl
   1184  077c							;
   1185  077c							;=====================================================
   1186  077c							; Get the array index from top of stack get Current variable
   1187  077c							; address from next on stack, add the offset
   1188  077c							; push the result back onto the stack
   1189  077c				   iArray
   1190  077c		       20 bd 13 	      jsr	popR0	; Get the array index
   1191  077f		       20 d5 13 	      jsr	popR1	; Get the Variable address
   1192  0782
   1193  0782		       18		      clc		; Multiplythe value by 2
   1194  0783		       26 52		      rol	R0	; Do the multiply
   1195  0785		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1196  0787		       18		      clc
   1197  0788		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1198  078a		       65 52		      adc	R0
   1199  078c		       85 52		      sta	R0
   1200  078e		       a5 55		      lda	R1+1
   1201  0790		       65 53		      adc	R0+1
   1202  0792		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1203  0794		       20 39 13 	      jsr	pushR0	; Push R0 assume it is correct
   1204  0797
   1205  0797		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1206  0799		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1207  079b		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1208  079d		       a5 55		      lda	R1+1
   1209  079f		       c5 42		      cmp	VARIABLES+1
   1210  07a1		       d0 1c		      bne	iArrayAtTest
   1211  07a3		       18		      clc
   1212  07a4		       a9 34		      lda	#52	; add the max offset that is valid
   1213  07a6		       65 54		      adc	R1	; update to be the largest offset that is valid
   1214  07a8		       85 54		      sta	R1
   1215  07aa		       a9 00		      lda	#0
   1216  07ac		       65 55		      adc	R1+1
   1217  07ae		       85 55		      sta	R1+1
   1218  07b0				   iArrayVerify 		; try to enforce some sanity to using arrays
   1219  07b0		       a5 53		      lda	R0+1
   1220  07b2		       c5 55		      cmp	R1+1
   1221  07b4		       d0 04		      bne	iArrayDecide
   1222  07b6		       a5 52		      lda	R0
   1223  07b8		       c5 54		      cmp	R1
   1224  07ba				   iArrayDecide
   1225  07ba		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1226  07bc		       4c b9 02 	      jmp	NextIL
   1227  07bf
   1228  07bf				   iArrayAtTest
   1229  07bf		       ad 0f 26 	      lda	HighMem
   1230  07c2		       85 54		      sta	R1
   1231  07c4		       ad 10 26 	      lda	HighMem+1
   1232  07c7		       85 55		      sta	R1+1
   1233  07c9		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1234  07cb
   1235  07cb							; Get here if array index is out of range
   1236  07cb		       20 bd 13    iArrayError jsr	popR0
   1237  07ce		       a9 00		      lda	#0
   1238  07d0		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1239  07d2		       4c 08 06 	      jmp	iErr2
   1240  07d5							;
   1241  07d5							;=====================================================
   1242  07d5							; List the current BASIC program in memory.  Uses R0,
   1243  07d5							; tempIly, and dpl.
   1244  07d5							;
   1245  07d5		       20 d8 15    iLST       jsr	SetOutConsole
   1246  07d8		       a9 15	   iLST2      lda	#ProgramStart&$ff
   1247  07da		       85 59		      sta	dpl
   1248  07dc		       a9 26		      lda	#ProgramStart>>8
   1249  07de		       85 5a		      sta	dpl+1
   1250  07e0							;
   1251  07e0							; dpl/dph point to the current line.  See if we're at
   1252  07e0							; the end of the program.
   1253  07e0							;
   1254  07e0		       a5 59	   iLSTloop   lda	dpl
   1255  07e2		       cd 0d 26 	      cmp	PROGRAMEND
   1256  07e5		       d0 07		      bne	iLstNotEnd
   1257  07e7		       a5 5a		      lda	dpl+1
   1258  07e9		       cd 0e 26 	      cmp	PROGRAMEND+1
   1259  07ec		       f0 40		      beq	iLstdone
   1260  07ee							;
   1261  07ee		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1262  07f0		       b1 59		      lda	(dpl),y	;line number LSB
   1263  07f2		       85 52		      sta	R0
   1264  07f4		       c8		      iny
   1265  07f5		       b1 59		      lda	(dpl),y	;line number MSB
   1266  07f7		       85 53		      sta	R0+1
   1267  07f9		       c8		      iny
   1268  07fa		       84 5d		      sty	tempIlY
   1269  07fc		       20 84 11 	      jsr	PrintDecimal
   1270  07ff		       a9 20		      lda	#SPACE
   1271  0801		       20 f2 15 	      jsr	VOUTCH
   1272  0804		       a4 5d		      ldy	tempIlY
   1273  0806		       b1 59	   iLSTl2     lda	(dpl),y
   1274  0808		       f0 0a		      beq	iLST3	;end of this line 0 value
   1275  080a		       84 5d		      sty	tempIlY
   1276  080c		       20 f2 15 	      jsr	VOUTCH
   1277  080f		       a4 5d		      ldy	tempIlY
   1278  0811		       c8		      iny
   1279  0812		       d0 f2		      bne	iLSTl2	;do next char
   1280  0814							;
   1281  0814							; End of this line.  Print CR/LF, then move to the
   1282  0814							; next line.
   1283  0814							;
   1284  0814		       c8	   iLST3      iny		;Move to next line
   1285  0815		       18		      clc		;Clear the carry flag
   1286  0816		       98		      tya		;Current Offset
   1287  0817		       65 59		      adc	dpl	;Add the offset to the pointer
   1288  0819		       85 59		      sta	dpl	;Save the new value
   1289  081b		       a5 5a		      lda	dpl+1	;Next byte
   1290  081d		       69 00		      adc	#0	;ad in the carry if any
   1291  081f		       85 5a		      sta	dpl+1	;Save it
   1292  0821							;
   1293  0821							; Have to manually do CR/LF so it uses the vectored
   1294  0821							; output function.
   1295  0821							;
   1296  0821		       a9 0d		      lda	#CR
   1297  0823		       20 f2 15 	      jsr	VOUTCH
   1298  0826		       a9 0a		      lda	#LF
   1299  0828		       20 f2 15 	      jsr	VOUTCH
   1300  082b		       4c e0 07 	      jmp	iLSTloop	;do next line
   1301  082e							;
   1302  082e		       20 d8 15    iLstdone   jsr	SetOutConsole
   1303  0831		       4c b9 02 	      jmp	NextIL
   1304  0834							;
   1305  0834							;=====================================================
   1306  0834							; Get a line of text into LINBUF.  Terminate with a
   1307  0834							; null byte.
   1308  0834							;
   1309  0834				   iGETLINE
   1310  0834		       a9 3e		      lda	#'>	;prompt character
   1311  0836		       a6 00		      ldx	0	;Wait for read to complete
   1312  0838		       20 5b 12 	      jsr	GetLine
   1313  083b							;
   1314  083b		       a9 00		      lda	#0
   1315  083d		       85 62		      sta	RunMode
   1316  083f		       4c b9 02 	      jmp	NextIL
   1317  0842							;
   1318  0842							;=====================================================
   1319  0842							; This is called when the input buffer contains a line
   1320  0842							; typed in by the user that starts with a line number.
   1321  0842							; Insert the line into the program or delete the line
   1322  0842							; if there is nothing after the line number,
   1323  0842							;
   1324  0842		       a0 00	   iINSRT     ldy	#0
   1325  0844		       20 f0 11 	      jsr	getDecimal	;convert line #
   1326  0847		       20 6d 14 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1327  084a		       84 5e		      sty	offset	;Save the start of the program line text
   1328  084c							;
   1329  084c							; Now find the line OR the next higher line OR the
   1330  084c							; end of the program.
   1331  084c							;
   1332  084c		       20 22 11 	      jsr	findLine	; Look for the line number in the current program
   1333  084f							; Returns Z and curptr point to the line if found
   1334  084f							; Returns C and curptr at next higher line if not found and there is a higher line
   1335  084f							; Returns ZC clear and curptr to end of program if higher than all other lines
   1336  084f							;
   1337  084f							; If the line exists, it needs to be removed.
   1338  084f							;
   1339  084f		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1340  0851							;
   1341  0851							; Get length of line to be removed, we fall thru to here if we find a matching line
   1342  0851							;
   1343  0851							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1344  0851		       a0 00		      ldy	#0
   1345  0853		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1346  0855		       a8		      tay
   1347  0856							;If it is equal we delete the line and replace it, get length
   1348  0856							;then adjust all program line after up or down depending on len of line
   1349  0856							;If next higher then just move everythimg down by length bytes
   1350  0856							;This call will return how many bytes in the line we found
   1351  0856		       84 5f		      sty	lineLength	;Save the length of the line we found
   1352  0858							;
   1353  0858							; Compute the new end of the program first.
   1354  0858							;
   1355  0858		       38		      sec		;Set the carry bit
   1356  0859		       ad 0d 26 	      lda	PROGRAMEND	;Get low byte of program end
   1357  085c		       e5 5f		      sbc	lineLength	;Subtract the length of the current line
   1358  085e		       8d 0d 26 	      sta	PROGRAMEND	;save it
   1359  0861		       ad 0e 26 	      lda	PROGRAMEND+1
   1360  0864		       e9 00		      sbc	#0	;Process the carry
   1361  0866		       8d 0e 26 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1362  0869							;
   1363  0869							; Copy CURPTR into R1 for working
   1364  0869							;
   1365  0869		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1366  086b		       85 54		      sta	R1
   1367  086d		       a5 50		      lda	CURPTR+1
   1368  086f		       85 55		      sta	R1+1
   1369  0871							;
   1370  0871							; See if we're at the end.
   1371  0871							;
   1372  0871		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1373  0873		       cd 0d 26 	      cmp	PROGRAMEND
   1374  0876		       d0 07		      bne	InsDelLoop
   1375  0878		       a5 55		      lda	R1+1
   1376  087a		       cd 0e 26 	      cmp	PROGRAMEND+1
   1377  087d		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1378  087f							;
   1379  087f							; Move one byte, move to next location.
   1380  087f							;
   1381  087f		       a4 5f	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1382  0881		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1383  0883		       b1 54		      lda	(R1),y
   1384  0885		       a0 00		      ldy	#0
   1385  0887		       91 54		      sta	(R1),y
   1386  0889		       e6 54		      inc	R1
   1387  088b		       d0 e4		      bne	InsDelChk
   1388  088d		       e6 55		      inc	R1+1
   1389  088f		       4c 71 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1390  0892							;
   1391  0892							; Deletion is done.
   1392  0892							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1393  0892							;
   1394  0892		       a4 5e	   insert2    ldy	offset	;get back ptr	Get the current offset
   1395  0894		       b9 77 25 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1396  0897		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1397  0899							;
   1398  0899							; CURPTR points to where the line will be inserted.
   1399  0899							;
   1400  0899		       20 15 13 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1401  089c							;
   1402  089c		       ad 0d 26 	      lda	PROGRAMEND	;Load the start address for the copy
   1403  089f							;At this point curptr still contains the location we will insert data
   1404  089f		       85 63		      sta	FROM
   1405  08a1		       ad 0e 26 	      lda	PROGRAMEND+1
   1406  08a4		       85 64		      sta	FROM+1
   1407  08a6							;
   1408  08a6		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1409  08a8		       b1 63		      lda	(FROM),y
   1410  08aa		       a4 5f		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1411  08ac		       91 63		      sta	(FROM),y	;Save the new byte
   1412  08ae							;
   1413  08ae		       a5 63		      lda	FROM	;Check if we have copies the last byte
   1414  08b0		       c5 4f		      cmp	CURPTR
   1415  08b2		       d0 06		      bne	mvUpMore
   1416  08b4		       a5 64		      lda	FROM+1
   1417  08b6		       c5 50		      cmp	CURPTR+1
   1418  08b8		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1419  08ba							;
   1420  08ba							; Not done yet
   1421  08ba							;
   1422  08ba		       a5 63	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1423  08bc		       d0 02		      bne	mvUpMore2
   1424  08be		       c6 64		      dec	FROM+1
   1425  08c0		       c6 63	   mvUpMore2  dec	FROM
   1426  08c2		       4c a6 08 	      jmp	mvup1	;Loop until everything is moved
   1427  08c5							;
   1428  08c5							; All done with copy.
   1429  08c5							;
   1430  08c5		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1431  08c6		       a5 5f		      lda	lineLength	;Number of bytes to copy from line buff
   1432  08c8		       6d 0d 26 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1433  08cb		       8d 0d 26 	      sta	PROGRAMEND
   1434  08ce		       ad 0e 26 	      lda	PROGRAMEND+1
   1435  08d1		       69 00		      adc	#0
   1436  08d3		       8d 0e 26 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1437  08d6							;
   1438  08d6							;===================jlit use length before line newline
   1439  08d6
   1440  08d6		       a0 00		      ldy	#0	;Set offset of copy
   1441  08d8		       a5 5f		      lda	lineLength	;We will insert the actual length of the line first
   1442  08da		       91 4f		      sta	(CURPTR),y	;Store the length
   1443  08dc		       c8		      iny
   1444  08dd		       a5 52		      lda	R0	;Store the line number next
   1445  08df		       91 4f		      sta	(CURPTR),y
   1446  08e1		       c8		      iny
   1447  08e2		       a5 53		      lda	R0+1
   1448  08e4		       91 4f		      sta	(CURPTR),y
   1449  08e6		       c8		      iny
   1450  08e7							;
   1451  08e7		       a6 5e		      ldx	offset	;Load the offset into line buffer in page zero
   1452  08e9		       bd 77 25    mvUpLoop2  lda	LINBUF,x	;get a byte
   1453  08ec		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1454  08ee		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1455  08f0		       e8		      inx
   1456  08f1		       c8		      iny
   1457  08f2		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1458  08f4							;
   1459  08f4		       4c b9 02    mvUpFini   jmp	NextIL
   1460  08f7							;
   1461  08f7							;=====================================================
   1462  08f7							; Pops the top value of the ILPC stack and stores it
   1463  08f7							; in ILPC.  Ie, return from an IL subroutine.
   1464  08f7							;
   1465  08f7		       20 10 11    iRTN       jsr	popILPC
   1466  08fa		       4c b9 02 	      jmp	NextIL
   1467  08fd							;
   1468  08fd							;=====================================================
   1469  08fd							; NLINE print a newline
   1470  08fd							;
   1471  08fd		       20 76 14    iNLINE     jsr	CRLF	;user supplied sub
   1472  0900		       4c b9 02 	      jmp	NextIL
   1473  0903							;
   1474  0903							;=====================================================
   1475  0903							; This saves the current ILPC value on the stack, then
   1476  0903							; jumps to the address specified by the next two bytes.
   1477  0903							;
   1478  0903		       20 f3 10    iCALL      jsr	pushILPC	;save ILPC
   1479  0906		       90 03		      bcc	iJMP
   1480  0908		       4c 05 0b 	      jmp	ErrStkOver	; Check if there was an error
   1481  090b							;
   1482  090b							; Jmp to a specific location in the IL code.  The new
   1483  090b							; address immediately follows the opcode.
   1484  090b							;
   1485  090b		       20 d9 10    iJMP       jsr	getILWord
   1486  090e		       86 43		      stx	ILPC
   1487  0910		       85 44		      sta	ILPC+1
   1488  0912		       4c b9 02 	      jmp	NextIL
   1489  0915
   1490  0915
   1491  0915							;
   1492  0915							;=====================================================
   1493  0915							; Push the next two bytes onto the arithmetic stack.
   1494  0915							;
   1495  0915		       20 dd 10    iSetR2     jsr	getILByte
   1496  0918		       86 58		      stx	R2
   1497  091a		       4c b9 02 	      jmp	NextIL
   1498  091d							;
   1499  091d							;=====================================================
   1500  091d							; Push the next two bytes onto the arithmetic stack.
   1501  091d							;
   1502  091d		       20 d9 10    iLIT       jsr	getILWord
   1503  0920		       86 52		      stx	R0
   1504  0922		       85 53		      sta	R0+1
   1505  0924		       20 39 13 	      jsr	pushR0
   1506  0927		       4c b9 02 	      jmp	NextIL
   1507  092a							;
   1508  092a							;=====================================================
   1509  092a							; Initialize all variables for a single task.	Ie, set to zero.
   1510  092a							;
   1511  092a		       98	   subVINIT   tya
   1512  092b		       48		      pha
   1513  092c
   1514  092c		       a9 00		      lda	#0
   1515  092e		       a0 00		      ldy	#0
   1516  0930		       91 41	   Vinit2     sta	(VARIABLES),y
   1517  0932		       c8		      iny
   1518  0933		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1519  0935		       90 f9		      bcc	Vinit2
   1520  0937
   1521  0937		       68		      pla
   1522  0938		       a8		      tay
   1523  0939		       60		      rts
   1524  093a
   1525  093a		       20 2a 09    iVINIT     jsr	subVINIT
   1526  093d		       4c b9 02 	      jmp	NextIL
   1527  0940							;
   1528  0940							;=====================================================
   1529  0940							; Set the address of the error handler.  After any
   1530  0940							; error, set to the ILPC to the specified location.
   1531  0940							;
   1532  0940		       20 d9 10    iERRGOTO   jsr	getILWord
   1533  0943		       8e 01 26 	      stx	errGoto
   1534  0946		       8d 02 26 	      sta	errGoto+1
   1535  0949		       4c b9 02 	      jmp	NextIL
   1536  094c							;
   1537  094c							;=====================================================
   1538  094c							; TST is followed by an 8 bit signed offset, then a
   1539  094c							; null terminated string.  Compare the string against
   1540  094c							; the string starting at (CURPTR),CUROFF.  If the
   1541  094c							; strings match, continue executing the next IL
   1542  094c							; opcode.  Else, add the offset to ILPC.
   1543  094c							;
   1544  094c		       20 dd 10    iTST       jsr	getILByte	;Get the relative jump address
   1545  094f		       85 5e		      sta	offset	;save it to use if test faile
   1546  0951		       20 27 13 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1547  0954
   1548  0954		       a4 51		      ldy	CUROFF
   1549  0956		       84 59		      sty	dpl	;save for later
   1550  0958							;
   1551  0958		       20 dd 10    iTSTloop   jsr	getILByte	;get next char
   1552  095b		       f0 11		      beq	iTSTm	;match!
   1553  095d		       a4 59		      ldy	dpl
   1554  095f		       d1 4f		      cmp	(CURPTR),y
   1555  0961		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1556  0963		       09 20		      ora	#$20	; lets allow lowercase as well
   1557  0965		       d1 4f		      cmp	(CURPTR),y
   1558  0967		       d0 22		      bne	iTSTfail	;mismatch
   1559  0969		       c8	   iTSTUpper  iny
   1560  096a		       84 59		      sty	dpl
   1561  096c		       d0 ea		      bne	iTSTloop
   1562  096e							;
   1563  096e							; It's a match!  Clean up a bit.
   1564  096e							;
   1565  096e		       a4 59	   iTSTm      ldy	dpl
   1566  0970		       84 51		      sty	CUROFF
   1567  0972		       4c b9 02 	      jmp	NextIL
   1568  0975
   1569  0975							; Test for a single quote string
   1570  0975		       20 dd 10    iTSTStr    jsr	getILByte
   1571  0978		       85 5e		      sta	offset
   1572  097a		       20 27 13 	      jsr	saveIL
   1573  097d		       a4 51		      ldy	CUROFF
   1574  097f		       a9 22		      lda	#'"
   1575  0981		       d1 4f		      cmp	(CURPTR),y
   1576  0983		       d0 06		      bne	iTSTfail
   1577  0985		       c8		      iny
   1578  0986		       84 51		      sty	CUROFF
   1579  0988		       4c da 02 	      jmp	NextILStr
   1580  098b							;
   1581  098b							; Not a match, reset ILPC and then move to the
   1582  098b							; offset.
   1583  098b							;
   1584  098b		       20 30 13    iTSTfail   jsr	restoreIL
   1585  098e		       4c b7 0a 	      jmp	tstBranch
   1586  0991							;
   1587  0991							;=================================================JLIT=
   1588  0991							; Test if we have a let statement without the let keyword
   1589  0991		       20 dd 10    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1590  0994		       85 5e		      sta	offset	; Save the jump offset for fails
   1591  0996		       20 27 13 	      jsr	saveIL	; save to restore when done if fail
   1592  0999
   1593  0999		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1594  099b		       20 6d 14 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1595  099e		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1596  099f		       20 6d 14 	      jsr	SkipSpaces	; skip any SkipSpaces
   1597  09a2		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1598  09a4		       c9 3d		      cmp	#'=	; check if equals
   1599  09a6		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1600  09a8		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1601  09aa		       d0 df		      bne	iTSTfail	; return it failed
   1602  09ac
   1603  09ac				   iTSTLETGOOD
   1604  09ac		       4c b9 02 	      jmp	NextIL	; Then next instruction
   1605  09af
   1606  09af							;=================================================JLIT=
   1607  09af							;
   1608  09af		       20 dd 10    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1609  09b2		       85 5e		      sta	offset	; Save the jump offset for fails
   1610  09b4		       20 27 13 	      jsr	saveIL	; save to restore when done if fail
   1611  09b7		       20 d9 10 	      jsr	getILWord	; Get a word into RO
   1612  09ba		       86 52		      stx	R0
   1613  09bc		       85 53		      sta	R0+1
   1614  09be		       20 dd 10 	      jsr	getILByte	; Get byte into A
   1615  09c1		       a0 00		      ldy	#0
   1616  09c3		       d1 52		      cmp	(R0),y
   1617  09c5		       d0 03		      bne	iTSTByteNotEqual
   1618  09c7		       4c 8b 09 	      jmp	iTSTfail
   1619  09ca
   1620  09ca				   iTSTByteNotEqual
   1621  09ca		       4c b9 02 	      jmp	NextIL	; Then next instruction
   1622  09cd
   1623  09cd
   1624  09cd							;================================================jLIT=
   1625  09cd							;Test for end of line
   1626  09cd							;
   1627  09cd		       20 dd 10    iTSTDONE   jsr	getILByte
   1628  09d0		       85 5e		      sta	offset
   1629  09d2		       20 27 13 	      jsr	saveIL
   1630  09d5		       a4 51		      ldy	CUROFF
   1631  09d7		       84 59		      sty	dpl
   1632  09d9		       20 6d 14 	      jsr	SkipSpaces
   1633  09dc		       b1 4f		      lda	(CURPTR),y
   1634  09de		       f0 0b		      beq	iTSTDONEtrue
   1635  09e0		       c9 3a		      cmp	#COLON
   1636  09e2		       f0 07		      beq	iTSTDONEtrue
   1637  09e4		       a4 59		      ldy	dpl
   1638  09e6		       84 51		      sty	CUROFF
   1639  09e8		       4c 8b 09 	      jmp	iTSTfail
   1640  09eb							;
   1641  09eb							; Advance to the next line
   1642  09eb							;
   1643  09eb				   iTSTDONEtrue
   1644  09eb		       4c b9 02 	      jmp	NextIL
   1645  09ee
   1646  09ee		       4c b7 0a    tstBranchLink jmp	tstBranch
   1647  09f1							;
   1648  09f1							;=====================================================
   1649  09f1							; TSTV is followed by an 8 bit signed offset.	If the
   1650  09f1							; value at (CURPTR),CUROFF appears to be a variable
   1651  09f1							; name, move to the next IL statement.  Else, add the
   1652  09f1							; offset to ILPC. Converted to use actual absolute memory addresses
   1653  09f1							; TSTVT Looks for the task context
   1654  09f1							;
   1655  09f1		       20 d5 13    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1656  09f4		       a9 00		      lda	#0
   1657  09f6		       85 58		      sta	R2
   1658  09f8		       f0 04		      beq	iTSTVV
   1659  09fa
   1660  09fa		       a9 01	   iTSTV      lda	#1
   1661  09fc		       85 58		      sta	R2
   1662  09fe
   1663  09fe		       20 dd 10    iTSTVV     jsr	getILByte	;offset
   1664  0a01		       85 5e		      sta	offset
   1665  0a03							;
   1666  0a03		       a4 51		      ldy	CUROFF
   1667  0a05		       20 6d 14 	      jsr	SkipSpaces
   1668  0a08		       b1 4f		      lda	(CURPTR),y
   1669  0a0a		       d0 03		      bne	iTSTVnext
   1670  0a0c		       4c ee 09 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1671  0a0f							;
   1672  0a0f				   iTSTVnext
   1673  0a0f		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1674  0a11		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1675  0a13
   1676  0a13		       c9 23		      cmp	#'#	; parameters passed to this task
   1677  0a15		       f0 53		      beq	iTSTVParm
   1678  0a17
   1679  0a17		       c9 5e		      cmp	#'^	; task exit code
   1680  0a19		       d0 04		      bne	iTSTV_A2Z
   1681  0a1b		       a9 19		      lda	#TASKEXITCODE
   1682  0a1d		       d0 10		      bne	iTSTVContinue
   1683  0a1f
   1684  0a1f				   iTSTV_A2Z
   1685  0a1f		       09 20		      ora	#$20	;make lower then upper
   1686  0a21		       49 20		      eor	#$20	;allow lower case here
   1687  0a23		       c9 41		      cmp	#'A
   1688  0a25		       90 c7		      bcc	tstBranchLink
   1689  0a27		       c9 5b		      cmp	#'Z+1
   1690  0a29		       b0 c3		      bcs	tstBranchLink
   1691  0a2b
   1692  0a2b
   1693  0a2b							;
   1694  0a2b							; The condition is true, so convert to an index, push
   1695  0a2b							; it onto the stack and continue running.
   1696  0a2b							;
   1697  0a2b		       38		      sec
   1698  0a2c		       e9 41		      sbc	#'A	;index is zero based
   1699  0a2e		       0a		      asl		;multiply by two
   1700  0a2f
   1701  0a2f				   iTSTVContinue
   1702  0a2f		       c8		      iny
   1703  0a30		       84 51		      sty	CUROFF	;it is a valid variable
   1704  0a32		       48		      pha
   1705  0a33		       a5 58		      lda	R2
   1706  0a35		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1707  0a37
   1708  0a37		       20 c0 10 	      jsr	ipc_getcontext	; Get the other tasks variables
   1709  0a3a		       a0 01		      ldy	#VARIABLEPOS
   1710  0a3c		       b1 56		      lda	(MQ),y
   1711  0a3e		       85 52		      sta	R0
   1712  0a40		       c8		      iny
   1713  0a41		       b1 56		      lda	(MQ),y
   1714  0a43		       85 53		      sta	R0+1
   1715  0a45		       4c 50 0a 	      jmp	iTSTVAddOffset
   1716  0a48
   1717  0a48				   iTSTVLocalValue
   1718  0a48		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1719  0a4a		       85 52		      sta	R0
   1720  0a4c		       a5 42		      lda	VARIABLES+1
   1721  0a4e		       85 53		      sta	R0+1
   1722  0a50
   1723  0a50				   iTSTVAddOffset
   1724  0a50		       68		      pla
   1725  0a51		       85 54		      sta	R1
   1726  0a53		       a9 00		      lda	#0
   1727  0a55		       85 55		      sta	R1+1
   1728  0a57
   1729  0a57				   iTSTVcontinue
   1730  0a57
   1731  0a57		       4c 7b 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1732  0a5a
   1733  0a5a							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1734  0a5a							; an array of integer values
   1735  0a5a				   iTSTVat
   1736  0a5a		       c8		      iny
   1737  0a5b		       84 51		      sty	CUROFF	;it is a valid variable
   1738  0a5d		       ad 0d 26 	      lda	PROGRAMEND	;set flag to let evaluator to use PROGRAMEND as the root
   1739  0a60		       85 52		      sta	R0
   1740  0a62		       ad 0e 26 	      lda	PROGRAMEND+1
   1741  0a65		       85 53		      sta	R0+1
   1742  0a67		       4c f3 06 	      jmp	pushR0nextIl	;place this onto the stack
   1743  0a6a
   1744  0a6a							; When we get parameters passed we can access them using the # variable with[]
   1745  0a6a							; example #[0] #[1] etc, we dont check yet if there is too many
   1746  0a6a				   iTSTVParm
   1747  0a6a		       c8		      iny
   1748  0a6b		       84 51		      sty	CUROFF	;it is a valid variable
   1749  0a6d		       a5 48		      lda	MATHSTACK
   1750  0a6f		       85 52		      sta	R0
   1751  0a71		       a5 49		      lda	MATHSTACK+1
   1752  0a73		       85 53		      sta	R0+1
   1753  0a75		       4c f3 06 	      jmp	pushR0nextIl
   1754  0a78
   1755  0a78							;
   1756  0a78							;=====================================================
   1757  0a78							; TSTL seems basically the same as TSTN, but leave the
   1758  0a78							; value in R0 instead of pushing onto stack.
   1759  0a78							; This tests for a valid line number
   1760  0a78							;
   1761  0a78		       20 dd 10    iTSTL      jsr	getILByte
   1762  0a7b		       85 5e		      sta	offset
   1763  0a7d							;
   1764  0a7d		       a4 51		      ldy	CUROFF
   1765  0a7f		       20 6d 14 	      jsr	SkipSpaces
   1766  0a82		       b1 4f		      lda	(CURPTR),y
   1767  0a84							;
   1768  0a84		       c9 30		      cmp	#'0
   1769  0a86		       90 2f		      bcc	tstBranch
   1770  0a88		       c9 3a		      cmp	#'9+1
   1771  0a8a		       b0 2b		      bcs	tstBranch
   1772  0a8c							;
   1773  0a8c							; It's a digit, so convert to a number.
   1774  0a8c							;
   1775  0a8c		       20 f0 11 	      jsr	getDecimal
   1776  0a8f		       4c b9 02 	      jmp	NextIL
   1777  0a92							;
   1778  0a92							;=====================================================
   1779  0a92							; TSTN checks for a number.  This is very simplistic;
   1780  0a92							; if the character is a digit, assume it's a number.
   1781  0a92							; Convert to a number and push it onto the stack.
   1782  0a92							;
   1783  0a92		       20 dd 10    iTSTN      jsr	getILByte
   1784  0a95		       85 5e		      sta	offset
   1785  0a97							;
   1786  0a97		       a4 51		      ldy	CUROFF
   1787  0a99		       20 6d 14 	      jsr	SkipSpaces
   1788  0a9c		       b1 4f		      lda	(CURPTR),y
   1789  0a9e		       f0 17		      beq	tstBranch
   1790  0aa0		       c9 2d		      cmp	#'-	;negative?
   1791  0aa2		       f0 08		      beq	iTSTN_1
   1792  0aa4		       c9 30		      cmp	#'0
   1793  0aa6		       90 0f		      bcc	tstBranch
   1794  0aa8		       c9 3a		      cmp	#'9+1
   1795  0aaa		       b0 0b		      bcs	tstBranch
   1796  0aac							;
   1797  0aac							; It's a digit, so convert to a number.
   1798  0aac							;
   1799  0aac				   iTSTN_1
   1800  0aac		       20 f0 11 	      jsr	getDecimal
   1801  0aaf		       84 51		      sty	CUROFF
   1802  0ab1		       20 39 13 	      jsr	pushR0	;save onto stack
   1803  0ab4		       4c b9 02 	      jmp	NextIL
   1804  0ab7
   1805  0ab7							;
   1806  0ab7							; Common jump point for all TSTx instructions that
   1807  0ab7							; fail to meet the requirements.  This takes the
   1808  0ab7							; offset and adds/subtracts to/from ILPC.
   1809  0ab7							;
   1810  0ab7		       a5 5e	   tstBranch  lda	offset	;get signed offset
   1811  0ab9		       10 0e		      bpl	tstPositive
   1812  0abb							;
   1813  0abb							; Do negative branch.	Do sign extension.
   1814  0abb							;
   1815  0abb		       18	   tstNegative clc
   1816  0abc		       65 43		      adc	ILPC
   1817  0abe		       85 43		      sta	ILPC
   1818  0ac0							;		  bcc	  tstBothDone
   1819  0ac0							;		  dec	  ILPC+1
   1820  0ac0							;		  jmp	  NextIL
   1821  0ac0
   1822  0ac0		       a5 44		      lda	ILPC+1
   1823  0ac2		       69 ff		      adc	#$ff
   1824  0ac4		       85 44		      sta	ILPC+1
   1825  0ac6		       4c b9 02 	      jmp	NextIL	;keep going
   1826  0ac9							;
   1827  0ac9		       18	   tstPositive clc
   1828  0aca		       65 43		      adc	ILPC
   1829  0acc		       85 43		      sta	ILPC
   1830  0ace		       90 02		      bcc	tstBothDone
   1831  0ad0		       e6 44		      inc	ILPC+1
   1832  0ad2				   tstBothDone
   1833  0ad2		       4c b9 02 	      jmp	NextIL
   1834  0ad5
   1835  0ad5							;
   1836  0ad5							;====================================================
   1837  0ad5							; Test for IRQ pending, and test if a break key pressed
   1838  0ad5							; Yes I know but this handles all sorts of irq/break issues
   1839  0ad5							;
   1840  0ad5		       20 dd 10    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1841  0ad8		       85 5e		      sta	offset	; Store the not true jump address offset
   1842  0ada		       20 26 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1843  0add		       d0 03		      bne	irqNo	; z not set of no break found
   1844  0adf		       4c f1 05 	      jmp	iFIN	; Exit out of run mode
   1845  0ae2		       ad ba 1c    irqNo      lda	IRQPending
   1846  0ae5		       f0 d0		      beq	tstBranch
   1847  0ae7		       c9 01		      cmp	#1	; only do this if set to first time
   1848  0ae9		       d0 cc		      bne	tstBranch
   1849  0aeb		       78		      sei		; disable the interupt until ireturn resets it
   1850  0aec		       ee ba 1c    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1851  0aef		       20 53 13 	      jsr	pushLN	; Push the next line to be executed
   1852  0af2		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1853  0af4		       ad bb 1c 	      lda	IRQEntry	; Get the line number to branch to
   1854  0af7		       85 4f		      sta	CURPTR	; put line number into r0
   1855  0af9		       ad bc 1c 	      lda	IRQEntry+1
   1856  0afc		       85 50		      sta	CURPTR+1
   1857  0afe		       a9 03		      lda	#3	; Point to first byte of program text
   1858  0b00		       85 51		      sta	CUROFF
   1859  0b02		       4c b9 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1860  0b05
   1861  0b05		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1862  0b07		       a9 00		      lda	#0	; stop the execution
   1863  0b09		       4c 08 06 	      jmp	iErr2
   1864  0b0c							;
   1865  0b0c
   1866  0b0c							;=====================================================
   1867  0b0c							; This places the number of free bytes on top of the
   1868  0b0c							; stack.
   1869  0b0c							;
   1870  0b0c		       20 a5 15    iFREE      jsr	GetSizes
   1871  0b0f		       20 39 13 	      jsr	pushR0
   1872  0b12		       4c b9 02 	      jmp	NextIL
   1873  0b15							;
   1874  0b15							;=====================================================
   1875  0b15							; Generate a random number from 0-FFFF and then MOD
   1876  0b15							; it with the value on top of stack.  Leaves number on
   1877  0b15							; stack
   1878  0b15							;
   1879  0b15		       20 d5 13    iRANDOM    jsr	popR1	;mod value
   1880  0b18							;
   1881  0b18							; If the value is zero, just return a one.
   1882  0b18							;
   1883  0b18		       a5 54		      lda	R1
   1884  0b1a		       05 55		      ora	R1+1
   1885  0b1c		       f0 4a		      beq	irandom1
   1886  0b1e							;
   1887  0b1e		       ad 07 26 	      lda	random+1
   1888  0b21		       8d 04 26 	      sta	rtemp1
   1889  0b24		       ad 06 26 	      lda	random
   1890  0b27		       0a		      asl
   1891  0b28		       2e 04 26 	      rol	rtemp1
   1892  0b2b		       0a		      asl
   1893  0b2c		       2e 04 26 	      rol	rtemp1
   1894  0b2f		       18		      clc
   1895  0b30		       6d 06 26 	      adc	random
   1896  0b33
   1897  0b33		       48		      pha
   1898  0b34
   1899  0b34		       ad 04 26 	      lda	rtemp1
   1900  0b37		       6d 07 26 	      adc	random+1
   1901  0b3a		       8d 07 26 	      sta	random+1
   1902  0b3d
   1903  0b3d		       68		      pla
   1904  0b3e
   1905  0b3e		       69 11		      adc	#$11
   1906  0b40		       8d 06 26 	      sta	random
   1907  0b43		       ad 07 26 	      lda	random+1
   1908  0b46		       69 36		      adc	#$36
   1909  0b48		       8d 07 26 	      sta	random+1
   1910  0b4b
   1911  0b4b		       ad 06 26 	      lda	random
   1912  0b4e		       85 52		      sta	R0
   1913  0b50		       ad 07 26 	      lda	random+1
   1914  0b53		       29 7f		      and	#$7f	;make positive
   1915  0b55		       85 53		      sta	R0+1
   1916  0b57							;
   1917  0b57							; R0 contains the number and R1 contains the max value.
   1918  0b57							;
   1919  0b57		       20 19 07 	      jsr	iDivNoPop
   1920  0b5a		       20 3e 14 	      jsr	RestoreSigns
   1921  0b5d		       a5 56		      lda	MQ
   1922  0b5f		       85 52		      sta	R0
   1923  0b61		       a5 57		      lda	MQ+1
   1924  0b63		       85 53		      sta	R0+1
   1925  0b65		       4c f3 06 	      jmp	pushR0nextIl
   1926  0b68				   irandom1
   1927  0b68		       a9 00		      lda	#0
   1928  0b6a		       85 53		      sta	R0+1
   1929  0b6c		       a9 01		      lda	#1
   1930  0b6e		       85 52		      sta	R0
   1931  0b70		       4c f3 06 	      jmp	pushR0nextIl
   1932  0b73
   1933  0b73							; The following replaced by call to division/modulo
   1934  0b73							;iRANDOM_2	lda	R0
   1935  0b73							;		cmp	R1
   1936  0b73							;		bne	iRANDOM_1
   1937  0b73							;		lda	R0+1
   1938  0b73							;		cmp	R1+1
   1939  0b73							;		bne	iRANDOM_1	;need to subtract
   1940  0b73							;
   1941  0b73							; Subtract R1 from R0
   1942  0b73							;
   1943  0b73							;iRANDOM_sub	sec
   1944  0b73							;		lda	R0
   1945  0b73							;		sbc	R1
   1946  0b73							;		sta	R0
   1947  0b73							;		lda	R0+1
   1948  0b73							;		sbc	R1+1
   1949  0b73							;		sta	R0+1
   1950  0b73							;		jmp	iRANDOM_2
   1951  0b73							;
   1952  0b73							; See if R1 > R0.  If so, branch to subtract.
   1953  0b73							;
   1954  0b73							;iRANDOM_1	lda	R0
   1955  0b73							;		cmp	R1
   1956  0b73							;		lda	R0+1
   1957  0b73							;		sbc	R1+1
   1958  0b73							;		bvc	iRANDOM_4
   1959  0b73							;		eor	#$80
   1960  0b73							;iRANDOM_4	bpl	iRANDOM_sub
   1961  0b73							;
   1962  0b73							; All done.  Almost.  Add one, then push the result.
   1963  0b73							;
   1964  0b73							;irandom1	inc	R0
   1965  0b73							;		bne	iRANDOM_3
   1966  0b73							;		inc	R0+1
   1967  0b73							;iRANDOM_3
   1968  0b73							;		  jsr	pushR0	;return value
   1969  0b73							;		jmp	NextIL
   1970  0b73							;
   1971  0b73							; Poke a value into a memory location
   1972  0b73		       8c 0c 26    iPOKEMEMORY sty	tempy
   1973  0b76		       20 bd 13 	      jsr	popR0
   1974  0b79		       20 d5 13 	      jsr	popR1
   1975  0b7c		       a0 00		      ldy	#0
   1976  0b7e		       a5 52		      lda	R0
   1977  0b80		       91 54		      sta	(R1),y
   1978  0b82		       ac 0c 26 	      ldy	tempy
   1979  0b85		       4c b9 02 	      jmp	NextIL
   1980  0b88							;
   1981  0b88							; Get a value from a memory location
   1982  0b88							;
   1983  0b88		       8c 0c 26    iPEEKMEMORY sty	tempy
   1984  0b8b		       20 bd 13 	      jsr	popR0
   1985  0b8e		       a0 00		      ldy	#0
   1986  0b90		       b1 52		      lda	(R0),y
   1987  0b92		       ac 0c 26 	      ldy	tempy
   1988  0b95		       85 52		      sta	R0
   1989  0b97		       a9 00		      lda	#0
   1990  0b99		       85 53		      sta	R0+1
   1991  0b9b		       4c f3 06 	      jmp	pushR0nextIl
   1992  0b9e							;
   1993  0b9e							; Call to address return what ever is in a to the stack
   1994  0b9e							; func2 will load a value into a before the call
   1995  0b9e		       20 d5 13    iCallFunc  jsr	popR1
   1996  0ba1		       a5 54		      lda	R1
   1997  0ba3		       20 af 0b 	      jsr	iCallRtn
   1998  0ba6		       85 52		      sta	R0
   1999  0ba8		       a9 00		      lda	#0
   2000  0baa		       85 53		      sta	R0+1
   2001  0bac		       20 f3 06 	      jsr	pushR0nextIl
   2002  0baf				   iCallRtn
   2003  0baf		       20 bd 13 	      jsr	popR0
   2004  0bb2		       6c 52 00 	      jmp	(R0)
   2005  0bb5
   2006  0bb5
   2007  0bb5							;===========================================jlit======
   2008  0bb5							;Get a character from the terminal convert to value
   2009  0bb5							;leave the number on top of the stack
   2010  0bb5							;
   2011  0bb5				   iGETCHAR
   2012  0bb5		       20 f5 15 	      jsr	VGETCH
   2013  0bb8					      if	CTMON65
   2014  0bb8		       48		      pha
   2015  0bb9		       20 f2 15 	      jsr	VOUTCH	;echo echo echo
   2016  0bbc		       68		      pla
   2017  0bbd					      endif
   2018  0bbd		       85 52		      sta	R0
   2019  0bbf		       a9 00		      lda	#0
   2020  0bc1		       85 53		      sta	R0+1
   2021  0bc3		       20 39 13 	      jsr	pushR0
   2022  0bc6							;
   2023  0bc6		       4c b9 02 	      jmp	NextIL
   2024  0bc9							;===========================================jusilostintim======
   2025  0bc9							;Put a character to the terminal convert to
   2026  0bc9							;
   2027  0bc9		       20 bd 13    iPUTCHAR   jsr	popR0
   2028  0bcc		       a5 52		      lda	R0
   2029  0bce		       20 f2 15 	      jsr	VOUTCH
   2030  0bd1		       4c b9 02 	      jmp	NextIL
   2031  0bd4							;=====================================================
   2032  0bd4							; Put the number on the stack out as hex, suppress leading 0
   2033  0bd4				   iHexOut
   2034  0bd4		       20 bd 13 	      jsr	popR0
   2035  0bd7		       a5 53		      lda	R0+1
   2036  0bd9		       f0 03		      beq	iHexSecondByte
   2037  0bdb		       20 51 16 	      jsr	OUTHEX
   2038  0bde				   iHexSecondByte
   2039  0bde		       a5 52		      lda	R0
   2040  0be0		       20 51 16 	      jsr	OUTHEX
   2041  0be3		       4c b9 02 	      jmp	NextIL
   2042  0be6							;
   2043  0be6							;=====================================================
   2044  0be6							; Replace TOS with its absolute value.
   2045  0be6							;
   2046  0be6		       20 bd 13    iABS       jsr	popR0
   2047  0be9		       a5 53		      lda	R0+1
   2048  0beb		       10 10		      bpl	iABS_1	;already positive
   2049  0bed		       49 ff		      eor	#$ff
   2050  0bef		       85 53		      sta	R0+1
   2051  0bf1		       a5 52		      lda	R0
   2052  0bf3		       49 ff		      eor	#$ff
   2053  0bf5		       85 52		      sta	R0
   2054  0bf7		       e6 52		      inc	R0
   2055  0bf9		       d0 02		      bne	iABS_1
   2056  0bfb		       e6 53		      inc	R0+1
   2057  0bfd		       4c f3 06    iABS_1     jmp	pushR0nextIl
   2058  0c00
   2059  0c00							;
   2060  0c00							;================================================================
   2061  0c00							; The set of logical operators
   2062  0c00				   iLogAnd
   2063  0c00		       20 bd 13 	      jsr	popR0
   2064  0c03		       20 d5 13 	      jsr	popR1
   2065  0c06		       a5 52		      lda	R0
   2066  0c08		       25 54		      and	R1
   2067  0c0a		       85 52		      sta	R0
   2068  0c0c		       a5 53		      lda	R0+1
   2069  0c0e		       25 55		      and	R1+1
   2070  0c10		       85 53		      sta	R0+1
   2071  0c12		       4c f3 06 	      jmp	pushR0nextIl
   2072  0c15				   iLogOr
   2073  0c15		       20 bd 13 	      jsr	popR0
   2074  0c18		       20 d5 13 	      jsr	popR1
   2075  0c1b		       a5 52		      lda	R0
   2076  0c1d		       05 54		      ora	R1
   2077  0c1f		       85 52		      sta	R0
   2078  0c21		       a5 53		      lda	R0+1
   2079  0c23		       05 55		      ora	R1+1
   2080  0c25		       85 53		      sta	R0+1
   2081  0c27		       4c f3 06 	      jmp	pushR0nextIl
   2082  0c2a				   iLogXor
   2083  0c2a		       20 bd 13 	      jsr	popR0
   2084  0c2d		       20 d5 13 	      jsr	popR1
   2085  0c30		       a5 52		      lda	R0
   2086  0c32		       45 54		      eor	R1
   2087  0c34		       85 52		      sta	R0
   2088  0c36		       a5 53		      lda	R0+1
   2089  0c38		       45 55		      eor	R1+1
   2090  0c3a		       85 53		      sta	R0+1
   2091  0c3c		       4c f3 06 	      jmp	pushR0nextIl
   2092  0c3f				   iLogNot
   2093  0c3f		       20 bd 13 	      jsr	popR0
   2094  0c42		       a5 52		      lda	R0
   2095  0c44		       49 ff		      eor	#$FF
   2096  0c46		       85 52		      sta	R0
   2097  0c48		       a5 53		      lda	R0+1
   2098  0c4a		       49 ff		      eor	#$FF
   2099  0c4c		       85 53		      sta	R0+1
   2100  0c4e		       4c f3 06 	      jmp	pushR0nextIl
   2101  0c51
   2102  0c51				   iTruth
   2103  0c51		       a9 ff		      lda	#$FF
   2104  0c53		       85 52		      sta	R0
   2105  0c55		       85 53		      sta	R0+1
   2106  0c57		       4c f3 06 	      jmp	pushR0nextIl
   2107  0c5a				   iFalse
   2108  0c5a		       a9 00		      lda	#$00
   2109  0c5c		       85 52		      sta	R0
   2110  0c5e		       85 53		      sta	R0+1
   2111  0c60		       4c f3 06 	      jmp	pushR0nextIl
   2112  0c63
   2113  0c63							;================================================================
   2114  0c63							;Set the IRQ service rtn line number
   2115  0c63							;
   2116  0c63		       78	   iSetIrq    sei		; disable the interupts
   2117  0c64		       a9 00		      lda	#0	; Zero the Status flag
   2118  0c66		       8d b9 1c 	      sta	IRQStatus
   2119  0c69		       20 bd 13 	      jsr	popR0	; get the line number
   2120  0c6c		       a5 52		      lda	R0
   2121  0c6e		       05 53		      ora	R0+1
   2122  0c70		       f0 20		      beq	iSetExt	; if it is zero disable all
   2123  0c72		       20 53 13 	      jsr	pushLN	; Save the current line pointer
   2124  0c75		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2125  0c77		       4c 05 0b 	      jmp	ErrStkOver	; Check if there was an error
   2126  0c7a				   iSetIrqOk
   2127  0c7a		       20 22 11 	      jsr	findLine	; Find the IRQ func Line Pointer
   2128  0c7d		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2129  0c7f		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2130  0c81		       8d bc 1c 	      sta	IRQEntry+1
   2131  0c84		       a5 4f		      lda	CURPTR
   2132  0c86		       8d bb 1c 	      sta	IRQEntry
   2133  0c89		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2134  0c8b		       8d b9 1c 	      sta	IRQStatus
   2135  0c8e		       20 78 13 	      jsr	popLN	; Restore the old line number
   2136  0c91		       58		      cli		; Enable the interupts
   2137  0c92		       4c b9 02    iSetExt    jmp	NextIL
   2138  0c95
   2139  0c95		       20 78 13    iSetIrqErr jsr	popLN
   2140  0c98		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2141  0c9a		       a9 00		      lda	#0
   2142  0c9c		       4c 08 06 	      jmp	iErr2
   2143  0c9f							;
   2144  0c9f		       20 bd 13    iTRACEPROG jsr	popR0
   2145  0ca2		       a5 52		      lda	R0
   2146  0ca4		       85 40		      sta	ILTrace
   2147  0ca6		       4c b9 02 	      jmp	NextIL
   2148  0ca9
   2149  0ca9							;=====================================================
   2150  0ca9							; Define start of non page zero data
   2151 U2615 ????				      seg.u	TBData
   2152 U1ca8					      org	PROGEND
   2153 U1ca8							;=================================================================
   2154 U1ca8							;
------- FILE gosub.asm LEVEL 2 PASS 6
      0 U1ca8					      include	"gosub.asm"
      1  0ca9					      seg	Code
      2  0ca9
      3  0ca9							; Gosub and return related functions
      4  0ca9							;==========================================================
      5  0ca9							; Push the current math stack frame onto the gosub stack
      6  0ca9				   iPushMathStack
      7  0ca9		       98		      tya
      8  0caa		       48		      pha
      9  0cab		       a4 4d		      ldy	GOSUBSTACKPTR
     10  0cad		       a5 4a		      lda	MATHSTACKPTR
     11  0caf		       91 4b		      sta	(GOSUBSTACK),y
     12  0cb1		       a9 00		      lda	#0
     13  0cb3		       c8		      iny
     14  0cb4		       91 4b		      sta	(GOSUBSTACK),y
     15  0cb6		       c8		      iny
     16  0cb7		       91 4b		      sta	(GOSUBSTACK),y
     17  0cb9		       c8		      iny
     18  0cba		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  0cbc		       91 4b		      sta	(GOSUBSTACK),y
     20  0cbe		       c8		      iny
     21  0cbf		       84 4d		      sty	GOSUBSTACKPTR
     22  0cc1		       68		      pla
     23  0cc2		       a8		      tay
     24  0cc3		       4c b9 02 	      jmp	NextIL
     25  0cc6							;
     26  0cc6							;==========================================================
     27  0cc6							; Increment parameter count. Assume Stack frame is top of stack
     28  0cc6				   iIncParmCount
     29  0cc6		       98		      tya
     30  0cc7		       48		      pha
     31  0cc8		       a4 4d		      ldy	GOSUBSTACKPTR
     32  0cca		       88		      dey
     33  0ccb		       88		      dey
     34  0ccc		       88		      dey
     35  0ccd		       b1 4b		      lda	(GOSUBSTACK),y
     36  0ccf		       aa		      tax
     37  0cd0		       e8		      inx
     38  0cd1		       8a		      txa
     39  0cd2		       91 4b		      sta	(GOSUBSTACK),y
     40  0cd4		       68		      pla
     41  0cd5		       a8		      tay
     42  0cd6		       4c b9 02 	      jmp	NextIL
     43  0cd9							;
     44  0cd9							;==========================================================
     45  0cd9							;Restore the math stack frame
     46  0cd9		       20 df 0c    iPopMathStack jsr	PopMathStackNow
     47  0cdc		       4c b9 02 	      jmp	NextIL
     48  0cdf
     49  0cdf				   PopMathStackNow
     50  0cdf		       98		      tya
     51  0ce0		       48		      pha
     52  0ce1
     53  0ce1		       a4 4d		      ldy	GOSUBSTACKPTR
     54  0ce3		       88		      dey
     55  0ce4		       b1 4b		      lda	(GOSUBSTACK),y
     56  0ce6		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  0ce8		       d0 09		      bne	iPopMathStackNoFrame
     58  0cea		       88		      dey
     59  0ceb		       88		      dey
     60  0cec		       88		      dey
     61  0ced		       b1 4b		      lda	(GOSUBSTACK),y
     62  0cef		       85 4a		      sta	MATHSTACKPTR
     63  0cf1		       84 4d		      sty	GOSUBSTACKPTR
     64  0cf3
     65  0cf3				   iPopMathStackNoFrame
     66  0cf3
     67  0cf3		       68		      pla
     68  0cf4		       a8		      tay
     69  0cf5		       60		      rts
     70  0cf6
     71  0cf6
     72  0cf6							;==========================================================
     73  0cf6							; Push the current math stack information onto the gosub stack
     74  0cf6				   iSaveMathStack
     75  0cf6		       98		      tya
     76  0cf7		       48		      pha
     77  0cf8		       a4 4d		      ldy	GOSUBSTACKPTR
     78  0cfa		       a5 4a		      lda	MATHSTACKPTR
     79  0cfc		       91 4b		      sta	(GOSUBSTACK),y
     80  0cfe		       a5 48		      lda	MATHSTACK
     81  0d00		       c8		      iny
     82  0d01
     83  0d01		       91 4b		      sta	(GOSUBSTACK),y
     84  0d03		       c8		      iny
     85  0d04
     86  0d04		       a5 49		      lda	MATHSTACK+1
     87  0d06		       91 4b		      sta	(GOSUBSTACK),y
     88  0d08		       c8		      iny
     89  0d09
     90  0d09		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  0d0b		       91 4b		      sta	(GOSUBSTACK),y
     92  0d0d		       c8		      iny
     93  0d0e
     94  0d0e		       84 4d		      sty	GOSUBSTACKPTR
     95  0d10		       68		      pla
     96  0d11		       a8		      tay
     97  0d12		       4c b9 02 	      jmp	NextIL
     98  0d15							;
     99  0d15							;==========================================================
    100  0d15							;Restore the math stack information from the gosub stack
    101  0d15				   iRestoreMathStack
    102  0d15		       98		      tya
    103  0d16		       48		      pha
    104  0d17
    105  0d17		       a5 4a		      lda	MATHSTACKPTR
    106  0d19		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  0d1b
    108  0d1b		       a4 4d		      ldy	GOSUBSTACKPTR
    109  0d1d		       88		      dey
    110  0d1e		       b1 4b		      lda	(GOSUBSTACK),y
    111  0d20		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  0d22		       d0 16		      bne	iPopMathStack_Err
    113  0d24		       88		      dey
    114  0d25		       b1 4b		      lda	(GOSUBSTACK),y
    115  0d27		       85 49		      sta	MATHSTACK+1
    116  0d29		       88		      dey
    117  0d2a		       b1 4b		      lda	(GOSUBSTACK),y
    118  0d2c		       85 48		      sta	MATHSTACK
    119  0d2e		       88		      dey
    120  0d2f		       b1 4b		      lda	(GOSUBSTACK),y
    121  0d31		       85 4a		      sta	MATHSTACKPTR
    122  0d33		       84 4d		      sty	GOSUBSTACKPTR
    123  0d35		       68		      pla
    124  0d36		       a8		      tay
    125  0d37		       4c b9 02 	      jmp	NextIL
    126  0d3a
    127  0d3a				   iPopMathStack_Err
    128  0d3a		       a9 00		      lda	#0
    129  0d3c		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  0d3e		       4c 08 06 	      jmp	iErr2
    131  0d41							;=========================================
    132  0d41							; For functions and tasks the variable address of # means
    133  0d41							; a passed parameter so #[0] is the first parameter etc
    134  0d41							; will try for a better way later
    135  0d41
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  0d41					      include	"tasks.asm"
      1  0d41							;=====================================================
      2  0d41							; Tiny Basic IL task management
      3  0d41							; Data required by task management
      4  0d41							; currently each context is about 30 bytes and is swapped
      5  0d41							; into and out of page zero on each task switch....
      6  0d41							; LOL yes it is slow, but works for this itteration.
      7  0d41							;
      8  0d41
      9  0d41					      Seg	Code
     10  0d41							;=====================================================
     11  0d41							; Sets the pointers to the math,IL and gosub stacks
     12  0d41							; Creates the initial Context for each task slot
     13  0d41				   taskSetStacks
     14  0d41		       a9 bb		      lda	#mathStack&$FF
     15  0d43		       85 48		      sta	MATHSTACK
     16  0d45		       a9 1d		      lda	#mathStack>>8
     17  0d47		       85 49		      sta	MATHSTACK+1
     18  0d49
     19  0d49		       a9 4b		      lda	#ilStack&$ff
     20  0d4b		       85 45		      sta	ILSTACK
     21  0d4d		       a9 1f		      lda	#ilStack>>8
     22  0d4f		       85 46		      sta	ILSTACK+1
     23  0d51
     24  0d51		       a9 db		      lda	#gosubStack&$FF
     25  0d53		       85 4b		      sta	GOSUBSTACK
     26  0d55		       a9 20		      lda	#gosubStack>>8
     27  0d57		       85 4c		      sta	GOSUBSTACK+1
     28  0d59
     29  0d59		       a9 5b		      lda	#variableStack&$FF
     30  0d5b		       85 41		      sta	VARIABLES
     31  0d5d		       a9 23		      lda	#variableStack>>8
     32  0d5f		       85 42		      sta	VARIABLES+1
     33  0d61		       a2 0a		      ldx	#TASKCOUNT
     34  0d63		       a0 00		      ldy	#0
     35  0d65		       20 ba 0f 	      jsr	ContextSave
     36  0d68
     37  0d68		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  0d6a		       b0 3a		      bcs	taskSetDone
     39  0d6c
     40  0d6c		       a5 4b		      lda	GOSUBSTACK
     41  0d6e		       18		      clc
     42  0d6f		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  0d71		       85 4b		      sta	GOSUBSTACK
     44  0d73		       a5 4c		      lda	GOSUBSTACK+1
     45  0d75		       69 00		      adc	#0
     46  0d77		       85 4c		      sta	GOSUBSTACK+1
     47  0d79
     48  0d79		       a5 45		      lda	ILSTACK	; must be less than 256
     49  0d7b		       18		      clc
     50  0d7c		       69 28		      adc	#ILSTACKSIZE*2
     51  0d7e		       85 45		      sta	ILSTACK
     52  0d80		       a5 46		      lda	ILSTACK+1
     53  0d82		       69 00		      adc	#0
     54  0d84		       85 46		      sta	ILSTACK+1
     55  0d86
     56  0d86		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  0d88		       18		      clc
     58  0d89		       69 28		      adc	#MATHSTACKSIZE*2
     59  0d8b		       85 48		      sta	MATHSTACK
     60  0d8d		       a5 49		      lda	MATHSTACK+1
     61  0d8f		       69 00		      adc	#0
     62  0d91		       85 49		      sta	MATHSTACK+1
     63  0d93
     64  0d93		       a5 41		      lda	VARIABLES	; must be less than 256
     65  0d95		       18		      clc
     66  0d96		       69 36		      adc	#VARIABLESSIZE*2
     67  0d98		       85 41		      sta	VARIABLES
     68  0d9a		       a5 42		      lda	VARIABLES+1
     69  0d9c		       69 00		      adc	#0
     70  0d9e		       85 42		      sta	VARIABLES+1
     71  0da0
     72  0da0		       20 ba 0f 	      jsr	ContextSave
     73  0da3		       4c 68 0d 	      jmp	taskSetLoop
     74  0da6
     75  0da6				   taskSetDone
     76  0da6		       a0 00		      ldy	#0	; reload the main loop context
     77  0da8		       20 c9 0f 	      jsr	ContextLoad
     78  0dab		       60		      rts
     79  0dac							;
     80  0dac							;=====================================================
     81  0dac							; In some error cases the math stacks may be left pointing to the wrong stack
     82  0dac							; This function will reset those stack addresses but not the actual pointer
     83  0dac				   taskResetStacks
     84  0dac		       a0 00		      ldy	#0
     85  0dae		       20 c9 0f 	      jsr	ContextLoad
     86  0db1		       4c 41 0d 	      jmp	taskSetStacks
     87  0db4							;
     88  0db4							;=====================================================
     89  0db4							; Clear all task entries and task stacks
     90  0db4		       98	   taskReset  tya		; Save Y
     91  0db5		       48		      pha
     92  0db6		       a9 01		      lda	#1
     93  0db8		       8d ba 1d 	      sta	taskCounter	; Set number of active tasks to 1
     94  0dbb		       ac bd 1c 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  0dbe		       c0 00		      cpy	#0	; check if we are the main context
     96  0dc0		       f0 08		      beq	taskResetCont	; if we are just continue
     97  0dc2
     98  0dc2		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  0dc4		       8c bd 1c 	      sty	taskPtr
    100  0dc7		       20 c9 0f 	      jsr	ContextLoad	; load the System Task context
    101  0dca				   taskResetCont
    102  0dca		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  0dcc
    104  0dcc				   taskResetLoop
    105  0dcc		       a9 00		      lda	#TASKINACTIVE
    106  0dce		       99 be 1c 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  0dd1		       18		      clc
    108  0dd2		       98		      tya
    109  0dd3		       69 19		      adc	#CONTEXTLEN+1
    110  0dd5		       a8		      tay
    111  0dd6		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  0dd8		       90 f2		      bcc	taskResetLoop	; Go for more
    113  0dda
    114  0dda				   taskResetComplete
    115  0dda
    116  0dda		       68		      pla		; Restore y
    117  0ddb		       a8		      tay
    118  0ddc		       60		      rts
    119  0ddd
    120  0ddd							;
    121  0ddd							;======================================================
    122  0ddd							; iTaskSwitch	 switch to new task if not interrupt and
    123  0ddd							;		 count is exceded for task time slice gets here
    124  0ddd							;		 when time slice has reached zero
    125  0ddd							;
    126  0ddd		       98	   iTaskSwitch tya
    127  0dde		       48		      pha
    128  0ddf		       ad b9 1d 	      lda	taskResetValue	; Always reset the counter value
    129  0de2		       8d b8 1d 	      sta	taskCurrentCycles	; Update the counter with the new value
    130  0de5
    131  0de5		       ad ba 1c 	      lda	IRQPending	; Skip this if we are processing an irq
    132  0de8		       05 60		      ora	taskIOPending	; If set then don't switch
    133  0dea		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    134  0dec
    135  0dec		       ad ba 1d    iTaskMain  lda	taskCounter	; Number of tasks
    136  0def		       c9 01		      cmp	#1	; if there is only one task must be main
    137  0df1		       d0 07		      bne	itasknext	; if it some other number continue to next
    138  0df3
    139  0df3		       ac bd 1c 	      ldy	taskPtr	; check if we have not just ended some other task
    140  0df6		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    141  0df8		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    142  0dfa							;
    143  0dfa							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    144  0dfa							;
    145  0dfa				   itasknext
    146  0dfa		       ac bd 1c 	      ldy	taskPtr
    147  0dfd		       20 ba 0f 	      jsr	ContextSave	; Save the current context, y points to next context
    148  0e00				   itaskLoop
    149  0e00		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    150  0e02		       90 04		      bcc	iTaskNextChk
    151  0e04
    152  0e04		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    153  0e06		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    154  0e08
    155  0e08				   iTaskNextChk
    156  0e08		       b9 be 1c 	      lda	taskTable,y	; there is always at least one entry in table
    157  0e0b		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    158  0e0d		       18	   iTaskNext  clc
    159  0e0e		       98		      tya
    160  0e0f		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    161  0e11		       a8		      tay
    162  0e12		       4c 00 0e 	      jmp	itaskLoop	; Check for busy entry
    163  0e15
    164  0e15		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    165  0e17		       59 be 1c 	      eor	taskTable,y	; Check for anything waiting io
    166  0e1a		       d0 f1		      bne	iTaskNext
    167  0e1c		       20 c9 0f 	      jsr	ContextLoad	; load the next context
    168  0e1f		       8c bd 1c 	      sty	taskPtr	; update the task pointer
    169  0e22
    170  0e22				   iTaskSwitchDone
    171  0e22		       68		      pla
    172  0e23		       a8		      tay
    173  0e24		       60		      rts
    174  0e25							;
    175  0e25							;================================================================
    176  0e25							; Task Set task number to line number to start
    177  0e25							; Task Table structure:
    178  0e25							;    byte 0	-   Active inactive
    179  0e25							;    byte 1-2	-   Basic code line pointer
    180  0e25							;    byte 3	-   Offset on current line
    181  0e25		       98	   iTaskSet   tya		;preserve Y
    182  0e26		       48		      pha		; push a
    183  0e27
    184  0e27		       20 bd 13 	      jsr	popR0	; Get the line number to be saved
    185  0e2a
    186  0e2a		       ac bd 1c 	      ldy	taskPtr	; find out where we are
    187  0e2d		       20 ba 0f 	      jsr	ContextSave	; Save the current context
    188  0e30
    189  0e30							;Find the pointer to the line we need to start at
    190  0e30		       20 22 11 	      jsr	findLine	; Get the offset of the line to start task at
    191  0e33		       f0 0b		      beq	iTaskCont
    192  0e35
    193  0e35		       ac bd 1c 	      ldy	taskPtr	; Restore the original Context Error Exit
    194  0e38		       20 c9 0f 	      jsr	ContextLoad
    195  0e3b
    196  0e3b		       68		      pla		; pop a - exit
    197  0e3c		       a8		      tay
    198  0e3d		       4c 95 0c 	      jmp	iSetIrqErr	; Bad line number provided
    199  0e40
    200  0e40				   iTaskCont
    201  0e40		       20 8c 0f 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    202  0e43		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    203  0e45
    204  0e45		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    205  0e47		       99 be 1c 	      sta	taskTable,y	; new task as active
    206  0e4a
    207  0e4a		       a5 4f		      lda	CURPTR
    208  0e4c		       48		      pha		; push a
    209  0e4d		       a5 50		      lda	CURPTR+1
    210  0e4f		       48		      pha		; push a
    211  0e50
    212  0e50		       20 c9 0f 	      jsr	ContextLoad	; load the context of the new task
    213  0e53
    214  0e53		       68		      pla		; pop a
    215  0e54		       85 50		      sta	CURPTR+1
    216  0e56		       68		      pla		; pop a
    217  0e57		       85 4f		      sta	CURPTR
    218  0e59		       a9 03		      lda	#3	; Offset to first instruction
    219  0e5b		       85 51		      sta	CUROFF
    220  0e5d
    221  0e5d		       a9 00		      lda	#0
    222  0e5f		       85 47		      sta	ILSTACKPTR
    223  0e61		       85 4a		      sta	MATHSTACKPTR
    224  0e63		       85 4d		      sta	GOSUBSTACKPTR
    225  0e65		       a9 40		      lda	#GOSUBSTACKSIZE*4
    226  0e67		       85 4e		      sta	MESSAGEPTR
    227  0e69
    228  0e69		       20 2a 09 	      jsr	subVINIT	; Clear the variables
    229  0e6c
    230  0e6c		       a9 2d		      lda	#STMT&$FF
    231  0e6e		       85 43		      sta	ILPC
    232  0e70		       a9 18		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    233  0e72		       85 44		      sta	ILPC+1
    234  0e74
    235  0e74		       98		      tya		; Save the new context offset to return to user
    236  0e75		       48		      pha		; push a
    237  0e76
    238  0e76		       20 ba 0f    itaskSetSave jsr	ContextSave	; save the updated context
    239  0e79		       ee ba 1d 	      inc	taskCounter	; Update the number of Tasks running
    240  0e7c
    241  0e7c		       ac bd 1c 	      ldy	taskPtr
    242  0e7f		       20 c9 0f 	      jsr	ContextLoad	; restore the original context
    243  0e82
    244  0e82		       a9 00		      lda	#0	; Set the R0 upper to zero
    245  0e84		       85 53		      sta	R0+1
    246  0e86		       68		      pla		; Get the task pid we stored				 ; pop a
    247  0e87		       85 52		      sta	R0	; Get the table entry value
    248  0e89
    249  0e89		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    250  0e8a		       a8		      tay
    251  0e8b
    252  0e8b		       4c f3 06 	      jmp	pushR0nextIl	; Push R0 and continue
    253  0e8e				   iTaskNoEmpty
    254  0e8e		       ac bd 1c 	      ldy	taskPtr
    255  0e91		       20 c9 0f 	      jsr	ContextLoad
    256  0e94
    257  0e94		       68		      pla		; pop a    -- exit
    258  0e95		       a8		      tay
    259  0e96
    260  0e96		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    261  0e98		       a9 00		      lda	#0
    262  0e9a		       4c 08 06 	      jmp	iErr2
    263  0e9d							;
    264  0e9d							;===============================================================
    265  0e9d							; Run the task whos PID is on the stack, preserve the stack
    266  0e9d							;
    267  0e9d				   iTaskEnable
    268  0e9d		       98		      tya
    269  0e9e		       48		      pha
    270  0e9f		       20 d5 13 	      jsr	popR1
    271  0ea2		       20 a3 13 	      jsr	pushR1
    272  0ea5		       20 c0 10 	      jsr	ipc_getcontext	; get context pointer into mq
    273  0ea8		       a0 00		      ldy	#0
    274  0eaa		       b1 56		      lda	(MQ),y
    275  0eac		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    276  0eae		       09 80		      ora	#TASKACTIVE
    277  0eb0		       91 56		      sta	(MQ),y
    278  0eb2		       68		      pla
    279  0eb3		       a8		      tay
    280  0eb4		       4c b9 02 	      jmp	NextIL
    281  0eb7
    282  0eb7							;
    283  0eb7							;===============================================================
    284  0eb7							; Suspend the task whos PID  is on the stack, preserve the stack
    285  0eb7							;
    286  0eb7				   iTaskSuspend
    287  0eb7		       98		      tya
    288  0eb8		       48		      pha
    289  0eb9		       20 d5 13 	      jsr	popR1
    290  0ebc		       20 a3 13 	      jsr	pushR1
    291  0ebf		       20 c0 10 	      jsr	ipc_getcontext	; get context pointer into mq
    292  0ec2		       a0 00		      ldy	#0
    293  0ec4		       b1 56		      lda	(MQ),y
    294  0ec6		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    295  0ec8		       09 80		      ora	#TASKACTIVE
    296  0eca		       68		      pla
    297  0ecb		       a8		      tay
    298  0ecc		       4c b9 02 	      jmp	NextIL
    299  0ecf
    300  0ecf							;================================================================
    301  0ecf							; Returns task Status
    302  0ecf				   iTaskStat
    303  0ecf		       98		      tya
    304  0ed0		       48		      pha
    305  0ed1		       20 e3 0e 	      jsr	iTaskValid	; returns pointer to task entry
    306  0ed4		       b9 be 1c 	      lda	taskTable,y
    307  0ed7		       f0 05		      beq	iTaskStatExit
    308  0ed9		       68		      pla
    309  0eda		       a8		      tay
    310  0edb		       4c 51 0c 	      jmp	iTruth
    311  0ede				   iTaskStatExit
    312  0ede		       68		      pla
    313  0edf		       a8		      tay
    314  0ee0		       4c 5a 0c 	      jmp	iFalse
    315  0ee3
    316  0ee3							;
    317  0ee3							;================================================================
    318  0ee3							; Validate the task number on top of the stack
    319  0ee3							; on exit y points to the requested task entry
    320  0ee3							;
    321  0ee3		       20 bd 13    iTaskValid jsr	popR0	; get result of the multiply
    322  0ee6		       a5 53		      lda	R0+1
    323  0ee8		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    324  0eea		       a5 52		      lda	R0
    325  0eec		       c9 fa		      cmp	#TASKTABLELEN
    326  0eee		       90 09		      bcc	iTaskIsValid
    327  0ef0
    328  0ef0		       68	   iTaskValidErr pla		;remove return address
    329  0ef1		       68		      pla
    330  0ef2		       a2 10		      ldx	#ERR_INVALID_PID
    331  0ef4		       a9 00		      lda	#0
    332  0ef6		       4c 08 06 	      jmp	iErr2
    333  0ef9
    334  0ef9		       a8	   iTaskIsValid tay
    335  0efa		       60		      rts
    336  0efb							;
    337  0efb							;================================================================
    338  0efb							; Kill a running task, do nothing if already stopped
    339  0efb		       20 e3 0e    iTaskKill  jsr	iTaskValid
    340  0efe		       a9 00		      lda	#0
    341  0f00		       99 be 1c 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    342  0f03							;
    343  0f03							;================================================================
    344  0f03							;Skip to next task
    345  0f03				   iNTask
    346  0f03		       a9 01		      lda	#1
    347  0f05		       8d b8 1d 	      sta	taskCurrentCycles
    348  0f08		       4c b9 02 	      jmp	NextIL
    349  0f0b							;
    350  0f0b							;=======================================================
    351  0f0b							; Wait for a task to complete
    352  0f0b				   iWTASK
    353  0f0b		       20 dd 10 	      jsr	getILByte
    354  0f0e		       85 5e		      sta	offset
    355  0f10							;
    356  0f10		       20 27 13 	      jsr	saveIL	;in case of failure
    357  0f13
    358  0f13		       20 e3 0e 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    359  0f16		       b9 be 1c 	      lda	taskTable,y
    360  0f19		       d0 03		      bne	iWTASKWAIT
    361  0f1b				   iWTASKEXITED
    362  0f1b		       4c b9 02 	      jmp	NextIL
    363  0f1e				   iWTASKWAIT
    364  0f1e		       20 39 13 	      jsr	pushR0	; Push R0 back onto the stack
    365  0f21		       a9 01		      lda	#1
    366  0f23		       8d b8 1d 	      sta	taskCurrentCycles	; Give up the cycles
    367  0f26
    368  0f26		       20 30 13 	      jsr	restoreIL
    369  0f29		       4c b7 0a 	      jmp	tstBranch
    370  0f2c							;
    371  0f2c							;=======================================================
    372  0f2c							; Set task io lock
    373  0f2c		       e6 60	   iStartIO   inc	taskIOPending
    374  0f2e		       4c b9 02 	      jmp	NextIL
    375  0f31							;
    376  0f31							;=======================================================
    377  0f31							; Release the io lock
    378  0f31		       a5 60	   iEndIO     lda	taskIOPending
    379  0f33		       f0 02		      beq	iEndIOExit
    380  0f35		       c6 60		      dec	taskIOPending
    381  0f37		       4c b9 02    iEndIOExit jmp	NextIL
    382  0f3a							;
    383  0f3a							;===============================================================
    384  0f3a							; Return the task PID
    385  0f3a				   iTASKPID
    386  0f3a		       a9 00		      lda	#0
    387  0f3c		       85 53		      sta	R0+1
    388  0f3e		       ad bd 1c 	      lda	taskPtr
    389  0f41		       85 52		      sta	R0
    390  0f43		       4c f3 06 	      jmp	pushR0nextIl
    391  0f46							;
    392  0f46							;================================================================
    393  0f46							; Terminate a task
    394  0f46		       ac bd 1c    iETask     ldy	taskPtr
    395  0f49		       c0 00		      cpy	#0
    396  0f4b		       d0 03		      bne	iETaskCont
    397  0f4d		       4c f1 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    398  0f50				   iETaskCont
    399  0f50		       a9 00		      lda	#TASKINACTIVE
    400  0f52		       99 be 1c 	      sta	taskTable,y	; mark entry as free
    401  0f55		       ce ba 1d 	      dec	taskCounter	; reduce the number of active tasks
    402  0f58		       a9 01		      lda	#1
    403  0f5a		       8d b8 1d 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    404  0f5d		       20 a7 0f 	      jsr	TaskSetExitCode
    405  0f60				   iETaskExit
    406  0f60		       4c b9 02 	      jmp	NextIL
    407  0f63							;================================================================
    408  0f63							; make the current tasks math stack equal another tasks stack
    409  0f63							; The task to get is stored on the math stack
    410  0f63
    411  0f63				   iTaskGetMathStack
    412  0f63		       20 87 16 	      jsr	CopyStackR1	; Get the top of stack to R1
    413  0f66		       20 c0 10 	      jsr	ipc_getcontext	; MQ now has the context address
    414  0f69		       a0 0a		      ldy	#MATHSTACKPTRPOS
    415  0f6b		       b1 56		      lda	(MQ),y
    416  0f6d		       85 4a		      sta	MATHSTACKPTR
    417  0f6f		       a0 08		      ldy	#MATHSTACKPOS
    418  0f71		       b1 56		      lda	(MQ),y
    419  0f73		       85 48		      sta	MATHSTACK
    420  0f75		       c8		      iny
    421  0f76		       b1 56		      lda	(MQ),y
    422  0f78		       85 49		      sta	MATHSTACK+1
    423  0f7a		       4c b9 02 	      jmp	NextIL
    424  0f7d							;==================================================================
    425  0f7d							; Updates the tasks math stack pointer with contents of R2
    426  0f7d							; PID is on top of the stack
    427  0f7d				   iTaskPutMathPtr
    428  0f7d		       20 87 16 	      jsr	CopyStackR1	; Get the top of stack to R1
    429  0f80		       20 c0 10 	      jsr	ipc_getcontext	; MQ now has the context address
    430  0f83		       a5 58		      lda	R2
    431  0f85		       a0 0a		      ldy	#MATHSTACKPTRPOS
    432  0f87		       91 56		      sta	(MQ),y
    433  0f89		       4c b9 02 	      jmp	NextIL
    434  0f8c							;================================================================
    435  0f8c							; Find an empty slot in the taskTable
    436  0f8c							; Return the index in y
    437  0f8c							; on exit   c set if an empty slot is found
    438  0f8c							;	     c clear if not found
    439  0f8c							;================================================================
    440  0f8c							;
    441  0f8c		       ad ba 1d    TaskEmpty  lda	taskCounter
    442  0f8f		       c9 0a		      cmp	#TASKCOUNT
    443  0f91		       b0 10		      bcs	TaskNoSlot
    444  0f93		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    445  0f95				   TaskLoop
    446  0f95		       b9 be 1c 	      lda	taskTable,y
    447  0f98		       f0 0b		      beq	TaskEmptyFnd
    448  0f9a		       98		      tya
    449  0f9b		       18		      clc
    450  0f9c		       69 19		      adc	#CONTEXTLEN+1
    451  0f9e		       a8		      tay
    452  0f9f		       c0 fa		      cpy	#TASKTABLELEN
    453  0fa1		       90 f2		      bcc	TaskLoop	; Y is never zero
    454  0fa3				   TaskNoSlot
    455  0fa3		       18		      clc
    456  0fa4		       60		      rts
    457  0fa5				   TaskEmptyFnd
    458  0fa5		       38		      sec
    459  0fa6		       60		      rts
    460  0fa7							;====================================================
    461  0fa7							; Set the task exit code called from the return command
    462  0fa7							; on entry stack top hold exit value
    463  0fa7				   TaskSetExitCode
    464  0fa7		       98		      tya
    465  0fa8		       48		      pha
    466  0fa9		       20 bd 13 	      jsr	popR0
    467  0fac		       a0 19		      ldy	#TASKEXITCODE
    468  0fae		       a5 52		      lda	R0
    469  0fb0		       91 41		      sta	(VARIABLES),y
    470  0fb2		       c8		      iny
    471  0fb3		       a5 53		      lda	R0+1
    472  0fb5		       91 41		      sta	(VARIABLES),y
    473  0fb7		       68		      pla
    474  0fb8		       98		      tya
    475  0fb9		       60		      rts
    476  0fba
    477  0fba							;
    478  0fba							;=====================================================
    479  0fba							; Save Context Store the context to the TASK Table
    480  0fba							; on entry y contains the task table entry to save to
    481  0fba							; on exit y points to next task table entry
    482  0fba							;	   x contains the number of bytes copied
    483  0fba		       a2 00	   ContextSave ldx	#0
    484  0fbc		       c8		      iny		;inc past the task flags
    485  0fbd		       b5 41	   ContextSvLoop lda	CONTEXT,x
    486  0fbf		       99 be 1c 	      sta	taskTable,y
    487  0fc2		       c8		      iny
    488  0fc3		       e8		      inx
    489  0fc4		       e0 18		      cpx	#CONTEXTLEN
    490  0fc6		       90 f5		      bcc	ContextSvLoop
    491  0fc8		       60		      rts
    492  0fc9							;
    493  0fc9							; Load Context transfer context from task table to the Current Context
    494  0fc9							; on entry y contains the task table entry to transfer
    495  0fc9							; on exit y points to the original task table entry
    496  0fc9							;	   x contains the number of byts copied
    497  0fc9		       98	   ContextLoad tya
    498  0fca		       48		      pha
    499  0fcb		       a2 00		      ldx	#0
    500  0fcd		       c8		      iny		;inc past the task flags
    501  0fce		       b9 be 1c    ContextLDLoop lda	taskTable,y
    502  0fd1		       95 41		      sta	CONTEXT,x
    503  0fd3		       c8		      iny
    504  0fd4		       e8		      inx
    505  0fd5		       e0 18		      cpx	#CONTEXTLEN
    506  0fd7		       90 f5		      bcc	ContextLDLoop
    507  0fd9		       68		      pla
    508  0fda		       a8		      tay
    509  0fdb		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  0fdc					      include	"ipc.asm"
      1  0fdc							;======================================================
      2  0fdc							; Inter process communications.
      3  0fdc							; Tasks may write/read integer messages among
      4  0fdc							; them selves.
      5  0fdc							; This uses each tasks gosub stack as a message queue
      6  0fdc							; Gosub calls start at the highest address and the
      7  0fdc							; msg queue starts at the highest address.
      8  0fdc							;
      9  0fdc							;======================================================
     10  0fdc							; ipcs   - Send msg to another task or many tasks
     11  0fdc							; on entry  math stack contains the  top PID
     12  0fdc							;				      2ND Message value
     13  0fdc							; on exit   math stack contain top True-good or False-failed
     14  0fdc							;
     15  0fdc							; it may not be sent if queue is full
     16  0fdc							;
     17  0fdc							; a = ipcs(<message-expression>,<task PID-expression>)
     18  0fdc							;
     19  0fdc				   iIPCS
     20  0fdc		       98		      tya
     21  0fdd		       48		      pha
     22  0fde		       20 45 10 	      jsr	ipc_enqueue
     23  0fe1		       b0 08		      bcs	iIPC_BAD
     24  0fe3		       20 79 16 	      jsr	pushTrue
     25  0fe6		       68		      pla
     26  0fe7		       a8		      tay
     27  0fe8		       4c b9 02 	      jmp	NextIL
     28  0feb				   iIPC_BAD
     29  0feb		       68		      pla
     30  0fec		       a8		      tay
     31  0fed		       20 83 16 	      jsr	pushFalse
     32  0ff0		       4c b9 02 	      jmp	NextIL
     33  0ff3
     34  0ff3							;======================================================
     35  0ff3							; ipcr   - Recieve msg from task
     36  0ff3							; on exit  the message value is returned from message queue
     37  0ff3							;	    message -1	is reserved meaning no entry found
     38  0ff3							; The provided variable contains the pid of the sending
     39  0ff3							; task. This is optional. This always waits for a message
     40  0ff3							; before returning.
     41  0ff3							;
     42  0ff3							; a = ipcr(<variable name>)
     43  0ff3							;
     44  0ff3				   iIPCR
     45  0ff3		       98		      tya
     46  0ff4		       48		      pha
     47  0ff5		       20 87 10 	      jsr	ipc_dequeue
     48  0ff8		       b0 05		      bcs	iIPCR_Q_Empty
     49  0ffa		       68		      pla
     50  0ffb		       a8		      tay
     51  0ffc		       4c b9 02 	      jmp	NextIL
     52  0fff				   iIPCR_Q_Empty
     53  0fff		       68		      pla
     54  1000		       a8		      tay
     55  1001		       20 79 16 	      jsr	pushTrue	; puts -1 on the stack
     56  1004		       4c b9 02 	      jmp	NextIL
     57  1007
     58  1007							;=======================================================
     59  1007							; ipcc   - Check if message available
     60  1007							; on exit  Stack contains number of messages
     61  1007							;
     62  1007							; a = ipcc()
     63  1007							;
     64  1007				   iIPCC
     65  1007		       98		      tya
     66  1008		       48		      pha
     67  1009		       20 32 10 	      jsr	ipc_queue_count
     68  100c		       20 39 13 	      jsr	pushR0	; return the count
     69  100f		       68		      pla
     70  1010		       a8		      tay
     71  1011		       4c b9 02 	      jmp	NextIL
     72  1014
     73  1014							;=======================================================
     74  1014							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  1014				   iIPCIO
     76  1014		       98		      tya
     77  1015		       48		      pha
     78  1016		       20 32 10 	      jsr	ipc_queue_count
     79  1019		       a5 52		      lda	R0
     80  101b		       d0 10		      bne	iIPCIO_No_Halt
     81  101d		       a9 01		      lda	#1
     82  101f		       8d b8 1d 	      sta	taskCurrentCycles	; force a task switch
     83  1022		       a9 01		      lda	#TASKWAITIPC
     84  1024		       ac bd 1c 	      ldy	taskPtr
     85  1027		       19 be 1c 	      ora	taskTable,y
     86  102a		       99 be 1c 	      sta	taskTable,y
     87  102d
     88  102d				   iIPCIO_No_Halt
     89  102d		       68		      pla
     90  102e		       a8		      tay
     91  102f		       4c b9 02 	      jmp	NextIL
     92  1032							;======================================================
     93  1032							;ipc_queue_count
     94  1032				   ipc_queue_count
     95  1032		       a5 4e		      lda	MESSAGEPTR
     96  1034		       18		      clc
     97  1035		       4a		      lsr		; divide by 4
     98  1036		       4a		      lsr
     99  1037		       85 52		      sta	R0	; store into R0
    100  1039		       a9 10		      lda	#GOSUBSTACKSIZE
    101  103b		       38		      sec
    102  103c		       e5 52		      sbc	R0	; Get how many entries on queue
    103  103e		       85 52		      sta	R0
    104  1040		       a9 00		      lda	#0
    105  1042		       85 53		      sta	R0+1
    106  1044		       60		      rts
    107  1045							;=======================================================
    108  1045							; Support functions for messaging
    109  1045							;
    110  1045							; Enqueue message -> onto PID's MSG Q
    111  1045							; on entry top of stack contains the PID
    112  1045							;	    second contains the Message of the task
    113  1045							; on exit contains c set if failed
    114  1045							;		    c cleared if success
    115  1045							;		    PID's MSG Q PTR points to the message
    116  1045							;
    117  1045				   ipc_enqueue
    118  1045		       20 d5 13 	      jsr	popR1	; Get the pid
    119  1048		       20 c0 10 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  104b
    121  104b		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  104d		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  104f		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1051		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1053		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1055
    127  1055
    128  1055							; Get the PID'S stack address into R0
    129  1055		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1057		       b1 56		      lda	(MQ),y
    131  1059		       85 52		      sta	R0
    132  105b		       c8		      iny
    133  105c		       b1 56		      lda	(MQ),y
    134  105e		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1060
    136  1060							; Set y to point to the msg q entry
    137  1060		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1062		       b1 56		      lda	(MQ),y	; Get the index
    139  1064		       a8		      tay		; Set y to queue offset
    140  1065
    141  1065							; enqueue the message
    142  1065		       88		      dey		; First byte to save to
    143  1066		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1068		       91 52		      sta	(R0),y	; Set the entry type
    145  106a
    146  106a		       88		      dey
    147  106b		       ad bd 1c 	      lda	taskPtr	; Store the PID into queue
    148  106e		       91 52		      sta	(R0),y
    149  1070		       20 d5 13 	      jsr	popR1	; Get the actual message value
    150  1073		       20 ce 10 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1076
    152  1076		       98		      tya		; Save the new q ptr
    153  1077		       a0 0e		      ldy	#MSGPTRPOS
    154  1079		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  107b		       a0 00		      ldy	#0	; points to context root
    156  107d		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  107f		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1081		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1083		       18		      clc
    160  1084		       60		      rts
    161  1085				   ipc_enq_full
    162  1085		       38		      sec
    163  1086		       60		      rts
    164  1087							;=============================================================
    165  1087							; De-queue for message stack -> local tasks msg q
    166  1087							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1087							;  message into
    168  1087							;  on exit   math stack contains value of message
    169  1087							;				  Variable if provided is pid
    170  1087				   ipc_dequeue
    171  1087		       20 ec 13 	      jsr	popMQ	; Variable address to put PID into
    172  108a
    173  108a		       a4 4e		      ldy	MESSAGEPTR
    174  108c		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  108e		       b0 2e		      bcs	ipc_deq_empty
    176  1090		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1092		       85 52		      sta	R0
    178  1094		       c8		      iny
    179  1095		       b1 4b		      lda	(GOSUBSTACK),y
    180  1097		       85 53		      sta	R0+1
    181  1099		       c8		      iny
    182  109a		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  109c		       85 54		      sta	R1
    184  109e		       c8		      iny
    185  109f		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  10a1		       c8		      iny
    187  10a2		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  10a4
    189  10a4		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  10a6		       d0 16		      bne	ipc_deq_empty
    191  10a8
    192  10a8		       20 39 13 	      jsr	pushR0	; place value on stack
    193  10ab
    194  10ab		       a5 56		      lda	MQ
    195  10ad		       05 57		      ora	MQ+1
    196  10af		       f0 0b		      beq	ipc_deq_done
    197  10b1		       a5 54		      lda	R1
    198  10b3		       a0 00		      ldy	#0
    199  10b5		       91 56		      sta	(MQ),y
    200  10b7		       c8		      iny
    201  10b8		       a9 00		      lda	#0
    202  10ba		       91 56		      sta	(MQ),y
    203  10bc				   ipc_deq_done
    204  10bc		       18		      clc
    205  10bd		       60		      rts
    206  10be
    207  10be				   ipc_deq_empty
    208  10be		       38		      sec
    209  10bf		       60		      rts
    210  10c0
    211  10c0							;=============================================
    212  10c0							;  Get the context address into MQ from R1 with
    213  10c0							;  context/index/pid
    214  10c0				   ipc_getcontext
    215  10c0		       18		      clc		; Get pointer to Task context
    216  10c1		       a9 be		      lda	#taskTable&$FF	; change ptr to address
    217  10c3		       65 54		      adc	R1
    218  10c5		       85 56		      sta	MQ
    219  10c7		       a9 1c		      lda	#taskTable>>8
    220  10c9		       65 55		      adc	R1+1
    221  10cb		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  10cd		       60		      rts
    223  10ce							;
    224  10ce							;==============================================
    225  10ce							;Push R1 onto the stack
    226  10ce							;on entry y = next entry
    227  10ce							;R0 points to the stack space
    228  10ce							;on exit y points to next free byte
    229  10ce				   ipc_pushR1
    230  10ce		       88		      dey
    231  10cf		       a5 55		      lda	R1+1	; PID first
    232  10d1		       91 52		      sta	(R0),y
    233  10d3		       88		      dey
    234  10d4		       a5 54		      lda	R1
    235  10d6		       91 52		      sta	(R0),y
    236  10d8		       60		      rts
    237  10d9
    238  10d9
    239  10d9
    240  10d9
    241  10d9
    242  10d9
    243  10d9
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  10d9					      include	"support.asm"
      1  10d9							;
      2  10d9							;=====================================================
      3  10d9							;=====================================================
      4  10d9							;=====================================================
      5  10d9							; This marks the start of support functions used by
      6  10d9							; the IL opcodes.  These are support functions, NOT
      7  10d9							; the IL code.
      8  10d9							;=====================================================
      9  10d9							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  10d9							;=====================================================
     11  10d9					      Seg	Code
     12  10d9							;=====================================================
     13  10d9							; This gets the next two bytes pointed to by ILPC and
     14  10d9							; returns them; X contains LSB, A contains MSB.  ILPC
     15  10d9							; is advanced by two, and Y contains 0 on return.
     16  10d9
     17  10d9							;
     18  10d9		       20 dd 10    getILWord  jsr	getILByte	;LSB
     19  10dc		       aa		      tax
     20  10dd							;
     21  10dd							;=====================================================
     22  10dd							; This gets the next byte pointed to by ILPC and
     23  10dd							; returns it in A.  On return, X is unchanged but Y
     24  10dd							; contains 0.
     25  10dd							;
     26  10dd		       a0 00	   getILByte  ldy	#0
     27  10df		       b1 43		      lda	(ILPC),y	;get byte
     28  10e1		       08		      php		;save status
     29  10e2		       e6 43		      inc	ILPC	;inc LSB
     30  10e4		       d0 02		      bne	getILb2	;branch if no overflow
     31  10e6		       e6 44		      inc	ILPC+1	;inc MSB
     32  10e8		       28	   getILb2    plp		;restore status
     33  10e9		       60		      rts
     34  10ea							;
     35  10ea							;=====================================================
     36  10ea							; Decrement ILPC by one.
     37  10ea							;
     38  10ea		       a5 43	   decIL      lda	ILPC
     39  10ec		       d0 02		      bne	decIL2
     40  10ee		       c6 44		      dec	ILPC+1
     41  10f0		       c6 43	   decIL2     dec	ILPC
     42  10f2		       60		      rts
     43  10f3							;
     44  10f3							;=====================================================
     45  10f3							; Push the ILPC onto the return stack.  Actually, this
     46  10f3							; pushes the address of ILPC+2 since that's the next
     47  10f3							; address to execute.
     48  10f3							;
     49  10f3		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  10f5		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  10f7		       b0 15		      bcs	pushErr
     52  10f9		       a5 43		      lda	ILPC
     53  10fb		       18		      clc
     54  10fc		       69 02		      adc	#2
     55  10fe		       91 45		      sta	(ILSTACK),y
     56  1100		       08		      php		;save C bit
     57  1101		       c8		      iny
     58  1102		       a5 44		      lda	ILPC+1
     59  1104		       28		      plp		;restore C
     60  1105		       69 00		      adc	#0
     61  1107		       91 45		      sta	(ILSTACK),y
     62  1109		       c8		      iny
     63  110a		       84 47		      sty	ILSTACKPTR
     64  110c		       18		      clc
     65  110d		       60		      rts
     66  110e				   pushErr
     67  110e		       38		      sec
     68  110f		       60		      rts
     69  1110							;
     70  1110							;=====================================================
     71  1110							; Pull the top entry from return stack and put into
     72  1110							; ILPC.
     73  1110							;
     74  1110		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1112		       f0 fa		      beq	pushErr
     76  1114		       88		      dey
     77  1115		       b1 45		      lda	(ILSTACK),y
     78  1117		       85 44		      sta	ILPC+1
     79  1119		       88		      dey
     80  111a		       b1 45		      lda	(ILSTACK),y
     81  111c		       85 43		      sta	ILPC
     82  111e		       84 47		      sty	ILSTACKPTR
     83  1120		       18		      clc
     84  1121		       60		      rts
     85  1122							;
     86  1122							;=====================================================
     87  1122							; This searches for a specific line number that is in
     88  1122							; R0.	There are three possible return conditions:
     89  1122							; Line numbers are now the third byte, the first byte is now **************
     90  1122							; a pointer to the next line, of course no longer that 53 byte
     91  1122							; per line.
     92  1122							;
     93  1122							; Exact match was found:
     94  1122							;    * Z set
     95  1122							;    * CURPTR points to two-byte line number for that
     96  1122							;	line.
     97  1122							;
     98  1122							; Next highest line found:
     99  1122							;    * Z cleared
    100  1122							;    * C set
    101  1122							;    * CURPTR points to two-byte line number for that
    102  1122							;	line.
    103  1122							;
    104  1122							; End of program reached:
    105  1122							;    * Z cleared
    106  1122							;    * C cleared
    107  1122							;    * CURPTR points to first free byte at end of
    108  1122							;	program.  Ie, it has save value as PROGRAMEND.
    109  1122							;
    110  1122							; A, X, and Y are all undefined on return.
    111  1122							;
    112  1122
    113  1122				   findLine
    114  1122		       a9 15		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    115  1124		       85 4f		      sta	CURPTR
    116  1126		       a9 26		      lda	#ProgramStart>>8
    117  1128		       85 50		      sta	CURPTR+1
    118  112a							;
    119  112a							; At end of code?
    120  112a							;
    121  112a				   iXFER1
    122  112a		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  112c		       cd 0d 26 	      cmp	PROGRAMEND	; at end of program then stop run
    124  112f		       d0 0b		      bne	xfer2	; not end
    125  1131		       a5 50		      lda	CURPTR+1
    126  1133		       cd 0e 26 	      cmp	PROGRAMEND+1
    127  1136		       d0 04		      bne	xfer2	;Not at end
    128  1138							;
    129  1138							; Line not found and the end of the program was
    130  1138							; reached.  Return Z and C both clear.
    131  1138							;
    132  1138		       a9 01		      lda	#1	;clear Z
    133  113a		       18		      clc		;clear C
    134  113b		       60		      rts
    135  113c							;
    136  113c							; Check for an exact line number match
    137  113c							;
    138  113c		       a5 52	   xfer2      lda	R0
    139  113e		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1140		       d1 4f		      cmp	(CURPTR),y
    141  1142		       d0 08		      bne	xfernotit
    142  1144		       c8		      iny
    143  1145		       a5 53		      lda	R0+1
    144  1147		       d1 4f		      cmp	(CURPTR),y
    145  1149		       d0 01		      bne	xfernotit	; not a matching line number
    146  114b							;
    147  114b							; This is exactly the line we want.
    148  114b							;
    149  114b		       60		      rts		;it matches exactly
    150  114c							;
    151  114c							; See if this line is greater than the one we're
    152  114c							; searching for.
    153  114c							;
    154  114c		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    155  114e		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1150		       c5 53		      cmp	R0+1
    157  1152		       90 0b		      bcc	xfer3
    158  1154		       d0 07		      bne	xfer4
    159  1156		       88		      dey
    160  1157		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1159		       c5 52		      cmp	R0
    162  115b		       90 02		      bcc	xfer3
    163  115d							;
    164  115d							; This line is greater than the one we want, so
    165  115d							; return Z clear and C set.
    166  115d							;
    167  115d		       38	   xfer4      sec		;We found a line number greater
    168  115e		       60		      rts		;both conditions set
    169  115f							;
    170  115f							; Not the line (or droid) we're looking for.  Move to
    171  115f							; the next line.
    172  115f							;
    173  115f		       20 65 11    xfer3      jsr	FindNextLine
    174  1162		       4c 2a 11 	      jmp	iXFER1
    175  1165							;
    176  1165							;=====================================================
    177  1165							; This advances CURPTR to the next line.  If there
    178  1165							; are no more lines, this leaves CURPTR equal to
    179  1165							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1165							; CURPTR is pointing to a valid line on entry.  This
    181  1165							; pointer points to the two-byte line number.
    182  1165							; Update this points to the 1 byte line length  ****************
    183  1165							;
    184  1165				   FindNextLine
    185  1165		       a0 03		      ldy	#3	;skip line number and length byte
    186  1167		       84 51		      sty	CUROFF	;this is the new offset
    187  1169		       a0 00		      ldy	#0
    188  116b		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  116d		       18		      clc
    190  116e		       65 4f		      adc	CURPTR
    191  1170		       85 4f		      sta	CURPTR
    192  1172		       90 02		      bcc	FindNext4	;exit
    193  1174		       e6 50		      inc	CURPTR+1
    194  1176		       60	   FindNext4  rts
    195  1177							;
    196  1177							;=====================================================
    197  1177							; This compares CURPTR to PROGRAMEND and returns Z set
    198  1177							; if they are equal, Z clear if not.
    199  1177							;
    200  1177		       a5 4f	   AtEnd      lda	CURPTR
    201  1179		       cd 0d 26 	      cmp	PROGRAMEND
    202  117c		       d0 05		      bne	atendexit
    203  117e		       a5 50		      lda	CURPTR+1
    204  1180		       cd 0e 26 	      cmp	PROGRAMEND+1
    205  1183		       60	   atendexit  rts
    206  1184							;
    207  1184							;=====================================================
    208  1184							; Print the contents of R0 as a signed decimal number.
    209  1184							; Does leading zero suppression.
    210  1184							;
    211  1184				   PrintDecimal
    212  1184		       a5 53		      lda	R0+1	;MSB has sign
    213  1186		       10 17		      bpl	pplus	;it's a positive number
    214  1188							;
    215  1188							; Negative numbers need more work.  Invert all the bits,
    216  1188							; then add one.
    217  1188							;
    218  1188		       a9 2d		      lda	#'-
    219  118a		       20 f2 15 	      jsr	VOUTCH	;print the negative sign
    220  118d							;
    221  118d		       a5 52		      lda	R0	;invert bits
    222  118f		       49 ff		      eor	#$ff
    223  1191		       85 52		      sta	R0
    224  1193		       a5 53		      lda	R0+1
    225  1195		       49 ff		      eor	#$ff
    226  1197		       85 53		      sta	R0+1
    227  1199		       e6 52		      inc	R0	;add one
    228  119b		       d0 02		      bne	pplus
    229  119d		       e6 53		      inc	R0+1
    230  119f							;
    231  119f							; Print the value in R0 as a positive number.
    232  119f							;
    233  119f		       a2 00	   pplus      ldx	#0	;start of subtraction table
    234  11a1		       8e ff 25 	      stx	diddigit	;no digits yet
    235  11a4		       a0 00	   pploop     ldy	#0	;result of division
    236  11a6		       a5 52	   pploop2    lda	R0	;LSB
    237  11a8		       38		      sec
    238  11a9		       fd e8 11 	      sbc	dectable,x
    239  11ac		       85 52		      sta	R0
    240  11ae		       a5 53		      lda	R0+1
    241  11b0		       fd e9 11 	      sbc	dectable+1,x
    242  11b3		       10 2e		      bpl	pplusok	;no underflow
    243  11b5							;
    244  11b5							; Else, underflow.  Add back in the LSB of the
    245  11b5							; table to R0.
    246  11b5							;
    247  11b5		       18		      clc
    248  11b6		       a5 52		      lda	R0
    249  11b8		       7d e8 11 	      adc	dectable,x
    250  11bb		       85 52		      sta	R0
    251  11bd							;
    252  11bd							; Print the value in Y.  Actually, see if Y is zero and
    253  11bd							; whether any digit has been printed yet.  If Y isn't
    254  11bd							; zero or we've printed a digit, go ahead and print.
    255  11bd							;
    256  11bd		       8e fc 25 	      stx	printtx
    257  11c0		       98		      tya
    258  11c1		       09 00		      ora	#0	;set flags
    259  11c3		       d0 05		      bne	pprintit	;non-zero, print
    260  11c5							;
    261  11c5		       ad ff 25 	      lda	diddigit
    262  11c8		       f0 09		      beq	pprintno	;don't print
    263  11ca							;
    264  11ca		       98	   pprintit   tya
    265  11cb		       09 30		      ora	#'0
    266  11cd		       8d ff 25 	      sta	diddigit
    267  11d0		       20 f2 15 	      jsr	VOUTCH
    268  11d3		       ae fc 25    pprintno   ldx	printtx
    269  11d6							;
    270  11d6							; Move to the next table entry
    271  11d6							;
    272  11d6		       e8		      inx
    273  11d7		       e8		      inx
    274  11d8		       e0 08		      cpx	#dectableend-dectable
    275  11da		       d0 c8		      bne	pploop	;not at end
    276  11dc							;
    277  11dc							; At the end.	R0 contains the final value
    278  11dc							; to print.
    279  11dc							;
    280  11dc		       a5 52		      lda	R0
    281  11de		       09 30		      ora	#'0
    282  11e0		       4c f2 15 	      jmp	VOUTCH
    283  11e3							;
    284  11e3							; Finish doing the subtraction.
    285  11e3							;
    286  11e3		       85 53	   pplusok    sta	R0+1
    287  11e5		       c8		      iny
    288  11e6		       d0 be		      bne	pploop2
    289  11e8							;
    290  11e8							; Table of powers-of-ten
    291  11e8							;
      0  11e8				   dectable   dw	10000
      1  11e8		       10 27		      .word.w	10000
      0  11ea					      dw	1000
      1  11ea		       e8 03		      .word.w	1000
      0  11ec					      dw	100
      1  11ec		       64 00		      .word.w	100
      0  11ee					      dw	10
      1  11ee		       0a 00		      .word.w	10
    296  11ee		       11 f0	   dectableend equ	*
    297  11f0							;
    298  11f0							;=====================================================
    299  11f0							; Convert an ASCII string to a number.  On input,
    300  11f0							; (CURPTR),Y points to the first digit.  This gets
    301  11f0							; digit-by-digit until finding a non-number.  Returns
    302  11f0							; Y pointing to the non-digit, and R0 contains the
    303  11f0							; number.  This does NOT check for valid ranges, so
    304  11f0							; a value like "123456789" will produce something,
    305  11f0							; but not what you had expected.
    306  11f0							;
    307  11f0		       a9 00	   getDecimal lda	#0
    308  11f2		       85 52		      sta	R0
    309  11f4		       85 53		      sta	R0+1
    310  11f6		       85 59		      sta	dpl	;temporary negative flag
    311  11f8							;
    312  11f8							; See if it's negative...
    313  11f8							;
    314  11f8							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    315  11f8		       b1 4f		      lda	(CURPTR),y
    316  11fa		       c9 2d		      cmp	#'-
    317  11fc		       d0 02		      bne	getDecLoop
    318  11fe		       e6 59		      inc	dpl	;it's negative
    319  1200							;
    320  1200		       b1 4f	   getDecLoop lda	(CURPTR),y
    321  1202		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    322  1204		       c9 30		      cmp	#'0
    323  1206		       90 36		      bcc	getDdone
    324  1208		       c9 3a		      cmp	#'9+1
    325  120a		       b0 32		      bcs	getDdone
    326  120c		       38		      sec
    327  120d		       e9 30		      sbc	#'0	;convert to binary
    328  120f		       48		      pha
    329  1210							;
    330  1210							; Now multiply R0 by 10.  Remember that
    331  1210							; 2*N + 8*N = 10*N.
    332  1210							;
    333  1210		       06 52		      asl	R0
    334  1212		       26 53		      rol	R0+1	;*2
    335  1214		       a5 52		      lda	R0
    336  1216		       85 54		      sta	R1
    337  1218		       a5 53		      lda	R0+1
    338  121a		       85 55		      sta	R1+1
    339  121c		       06 52		      asl	R0
    340  121e		       26 53		      rol	R0+1	;*4
    341  1220		       06 52		      asl	R0
    342  1222		       26 53		      rol	R0+1	;*8
    343  1224		       18		      clc		;now add the partial sums...
    344  1225		       a5 52		      lda	R0	;...to get *10
    345  1227		       65 54		      adc	R1
    346  1229		       85 52		      sta	R0
    347  122b		       a5 53		      lda	R0+1
    348  122d		       65 55		      adc	R1+1
    349  122f		       85 53		      sta	R0+1
    350  1231							;
    351  1231							; Add in the new digit
    352  1231							;
    353  1231		       68		      pla
    354  1232		       18		      clc
    355  1233		       65 52		      adc	R0
    356  1235		       85 52		      sta	R0
    357  1237		       90 02		      bcc	getD2
    358  1239		       e6 53		      inc	R0+1
    359  123b							;
    360  123b							; Move to next character
    361  123b							;
    362  123b		       c8	   getD2      iny
    363  123c		       d0 c2		      bne	getDecLoop
    364  123e							;
    365  123e							; All done with digits, so now deal with it being
    366  123e							; negative.  If zero, then don't check for negative
    367  123e							; flag.  Ie, -0 is stored as 0.
    368  123e							;
    369  123e		       a5 52	   getDdone   lda	R0
    370  1240		       05 53		      ora	R0+1
    371  1242		       f0 16		      beq	getDone2	;zero
    372  1244		       a5 59		      lda	dpl
    373  1246		       f0 12		      beq	getDone2	;positive
    374  1248							;
    375  1248							; Invert all the bits, then add one.
    376  1248							;
    377  1248		       a5 52		      lda	R0
    378  124a		       49 ff		      eor	#$ff
    379  124c		       85 52		      sta	R0
    380  124e		       a5 53		      lda	R0+1
    381  1250		       49 ff		      eor	#$ff
    382  1252		       85 53		      sta	R0+1
    383  1254							;
    384  1254		       e6 52		      inc	R0
    385  1256		       d0 02		      bne	getDone2
    386  1258		       e6 53		      inc	R0+1
    387  125a				   getDone2
    388  125a							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    389  125a							;lda	  R0
    390  125a							;sta	  $0010
    391  125a							;lda	  R0+1
    392  125a							;sta	  $0011
    393  125a							;lda	  dpl
    394  125a							;sta	  $012
    395  125a
    396  125a		       60		      rts
    397  125b
    398  125b							;=====================================================
    399  125b							; Gets a line of input into LINBUF.
    400  125b							;
    401  125b							; On entry:
    402  125b							;    A contains the prompt character, or 0 if none.
    403  125b							;    X = 1 Background read
    404  125b							;    x = 0 Forground read with wait
    405  125b							;
    406  125b							; On exit:
    407  125b							;    CURPTR points to LINBUF
    408  125b							;    LINBUF contains the line with 0 at the end.
    409  125b							;    Y has offset to first non-space character
    410  125b							;    CURROFF has the same as Y.
    411  125b							;
    412  125b		       20 aa 12    GetLine    jsr	ReadPrompt
    413  125e		       e0 00		      cpx	#0
    414  1260		       f0 14		      beq	GetLineRetry
    415  1262		       ae bd 1c 	      ldx	taskPtr
    416  1265		       bd be 1c 	      lda	taskTable,x
    417  1268		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    418  126a		       d0 3d		      bne	taskWaitingIO
    419  126c		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    420  126e		       9d be 1c 	      sta	taskTable,x	;Mark the state for task as waiting io
    421  1271		       ce a9 12 	      dec	taskWaitingIO	;Start polling the input and make task wait
    422  1274		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    423  1276
    424  1276							;
    425  1276							; Now read a line and wait for the CR
    426  1276							;
    427  1276				   GetLineRetry
    428  1276		       a9 00		      lda	#0	;Wait for input to complete
    429  1278		       20 c2 12 	      jsr	ReadLine
    430  127b
    431  127b							;
    432  127b							; Point to the line we just read
    433  127b							; Set the current pointer to point to the input line
    434  127b							;
    435  127b		       a0 00	   ReadComplete ldy	#0
    436  127d		       84 51		      sty	CUROFF
    437  127f		       a2 77		      ldx	#LINBUF&$ff
    438  1281		       86 4f		      stx	CURPTR
    439  1283		       a2 25		      ldx	#LINBUF>>8
    440  1285		       86 50		      stx	CURPTR+1
    441  1287							;
    442  1287							; Output a CR/LF
    443  1287							;
    444  1287		       20 76 14 	      jsr	CRLF
    445  128a							;
    446  128a							; If a blank line, prompt again.
    447  128a							;
    448  128a		       20 6d 14 	      jsr	SkipSpaces
    449  128d		       b1 4f		      lda	(CURPTR),y
    450  128f		       d0 10		      bne	GetLineDone	;We have data then exit
    451  1291		       20 ad 12 	      jsr	ReadPromptRetry
    452  1294		       ae bd 1c 	      ldx	taskPtr	;if this task is waiting for IO
    453  1297		       bd be 1c 	      lda	taskTable,x	;then get out, wait for line to
    454  129a		       29 40		      and	#TASKWAITIO	;Complete again
    455  129c		       d0 0b		      bne	taskWaitingIO
    456  129e		       4c 76 12 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    457  12a1
    458  12a1				   GetLineDone
    459  12a1		       ae bd 1c 	      ldx	taskPtr
    460  12a4		       a9 80		      lda	#TASKACTIVE
    461  12a6		       9d be 1c 	      sta	taskTable,x	;IO is complete
    462  12a9
    463  12a9				   taskWaitingIO
    464  12a9		       60		      rts
    465  12aa
    466  12aa							;
    467  12aa							;=======================================================================
    468  12aa							; Display the prompt character
    469  12aa							; On entry
    470  12aa							;	    A contains the prompt character
    471  12aa							; On exit
    472  12aa							;	    The readbuffer index is reset to 0
    473  12aa							;
    474  12aa		       8d fe 25    ReadPrompt sta	promptChar
    475  12ad
    476  12ad							;
    477  12ad							; Prompt
    478  12ad							;
    479  12ad
    480  12ad		       ad fe 25    ReadPromptRetry lda	promptChar
    481  12b0		       09 00		      ora	#0	;any prompt?
    482  12b2		       f0 08		      beq	getlinenp
    483  12b4		       20 f2 15 	      jsr	VOUTCH
    484  12b7		       a9 20		      lda	#$20
    485  12b9		       20 f2 15 	      jsr	VOUTCH	;Space after prompt
    486  12bc							;
    487  12bc		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    488  12be		       8e fb 25 	      stx	getlinx
    489  12c1		       60		      rts
    490  12c2							;
    491  12c2							;===============================================================
    492  12c2							; This fuction is the driver for the line input
    493  12c2							; on call if a = 0 then it waits for all input
    494  12c2							;	      a = 1 then nowait for input
    495  12c2							; On exit
    496  12c2							;		       c clear if not complete line
    497  12c2							;		       c set if it was a complete line
    498  12c2
    499  12c2				   ReadLine
    500  12c2		       8d fd 25 	      sta	inputNoWait
    501  12c5		       c9 00		      cmp	#0
    502  12c7		       f0 05		      beq	getline1
    503  12c9		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    504  12cc		       f0 2b		      beq	GetLineNoWait
    505  12ce		       20 f5 15    getline1   jsr	VGETCH
    506  12d1					      if	CTMON65
    507  12d1		       48		      pha
    508  12d2		       20 f2 15 	      jsr	VOUTCH	;echo echo echo
    509  12d5		       68		      pla
    510  12d6					      endif
    511  12d6		       c9 0d		      cmp	#CR
    512  12d8		       f0 15		      beq	getlind	;end of line
    513  12da		       c9 08		      cmp	#BS	;backspace?
    514  12dc		       f0 1d		      beq	getlinebs
    515  12de		       ae fb 25 	      ldx	getlinx
    516  12e1		       9d 77 25 	      sta	LINBUF,x
    517  12e4		       e8		      inx
    518  12e5		       8e fb 25 	      stx	getlinx
    519  12e8		       ad fd 25 	      lda	inputNoWait
    520  12eb		       f0 e1		      beq	getline1
    521  12ed		       d0 0a		      bne	GetLineNoWait
    522  12ef							;
    523  12ef							; CR was hit
    524  12ef							;
    525  12ef		       a9 00	   getlind    lda	#0	; set the end pf buffer
    526  12f1		       ae fb 25 	      ldx	getlinx
    527  12f4		       9d 77 25 	      sta	LINBUF,x
    528  12f7
    529  12f7		       38		      sec		; Carry set then cr received
    530  12f8		       60		      rts
    531  12f9
    532  12f9				   GetLineNoWait
    533  12f9		       18		      clc		; Carry clear no end of line
    534  12fa		       60		      rts
    535  12fb							;
    536  12fb							; Backspace was hit
    537  12fb							;
    538  12fb		       ae fb 25    getlinebs  ldx	getlinx
    539  12fe		       f0 0e		      beq	getlineEOL	;at start of line
    540  1300		       ca		      dex
    541  1301		       8e fb 25 	      stx	getlinx
    542  1304		       20 f8 15    getlinepbs jsr	puts
      0  1307					      db	27,"[K",0
      1  1307		       1b 5b 4b 00	      .byte.b	27,"[K",0
    544  130b		       4c ce 12 	      jmp	getline1
    545  130e		       a9 20	   getlineEOL lda	#SPACE
    546  1310		       20 f2 15 	      jsr	VOUTCH
    547  1313		       d0 ef		      bne	getlinepbs
    548  1315							;
    549  1315							;=====================================================
    550  1315							; Count the length of the line currently in LINBUF
    551  1315							; starting at offset Y.  Returns the length in X.  The
    552  1315							; starting offset in Y should point past the ASCII
    553  1315							; line number.  Also counts the trailing NULL and two
    554  1315							; extra bytes for where the line number will be.
    555  1315							; Update must now include leading length byte not the null at end ****************
    556  1315							;
    557  1315				   getLineLength
    558  1315		       a2 00		      ldx	#0	;size
    559  1317		       b9 77 25    getLineL2  lda	LINBUF,y
    560  131a		       f0 04		      beq	getLineL3
    561  131c		       c8		      iny
    562  131d		       e8		      inx
    563  131e		       d0 f7		      bne	getLineL2
    564  1320		       e8	   getLineL3  inx		;count null at end
    565  1321		       e8		      inx		;line number LSB
    566  1322		       e8		      inx		;MSB
    567  1323		       e8		      inx		;change: count new leading line length
    568  1324		       86 5f		      stx	lineLength
    569  1326		       60		      rts
    570  1327							;
    571  1327							;=====================================================
    572  1327							; Count the length of the line pointed to by CURPTR.
    573  1327							; This also counts the line number and the terminating
    574  1327							; null.  Ie, this string returns 8:
    575  1327							;
    576  1327							; <lineLow><lineHi>Hello<null>
    577  1327							;
    578  1327							; Another way of looking at it: add the return value
    579  1327							; to the CURPTR and it'll point to the next line's
    580  1327							; line number.  Returns the value in Y.
    581  1327							; Update to ject get the leading byte length ********************
    582  1327							;
    583  1327							;getCURPTRLength
    584  1327							;		ldy	CURPTR
    585  1327							;		ldy	#3	;change: skip line number and leading length byte
    586  1327							;getCLineL2	lda	(CURPTR),y
    587  1327							;		beq	getCLineL3
    588  1327							;		iny
    589  1327							;		bne	getCLineL2
    590  1327							;getCLineL3	iny		;count null at end
    591  1327							;		rts
    592  1327
    593  1327							;
    594  1327							;=====================================================
    595  1327							; This saves ILPC.  This saves to a single save area,
    596  1327							; so it can't be called more than once.
    597  1327							;
    598  1327		       a5 43	   saveIL     lda	ILPC
    599  1329		       85 5b		      sta	tempIL
    600  132b		       a5 44		      lda	ILPC+1
    601  132d		       85 5c		      sta	tempIL+1
    602  132f		       60		      rts
    603  1330							;
    604  1330							;=====================================================
    605  1330							; This restores ILPC.
    606  1330							;
    607  1330		       a5 5b	   restoreIL  lda	tempIL
    608  1332		       85 43		      sta	ILPC
    609  1334		       a5 5c		      lda	tempIL+1
    610  1336		       85 44		      sta	ILPC+1
    611  1338		       60		      rts
    612  1339							;
    613  1339							;=====================================================
    614  1339							; This pushes R0 onto the stack.
    615  1339							;
    616  1339		       8c 04 26    pushR0     sty	rtemp1
    617  133c		       a4 4a		      ldy	MATHSTACKPTR
    618  133e		       c0 28		      cpy	#MATHSTACKSIZE<<1
    619  1340		       b0 34		      bcs	pusherr
    620  1342		       a5 52		      lda	R0
    621  1344		       91 48		      sta	(MATHSTACK),y
    622  1346		       c8		      iny
    623  1347		       a5 53		      lda	R0+1
    624  1349		       91 48		      sta	(MATHSTACK),y
    625  134b		       c8		      iny
    626  134c		       84 4a		      sty	MATHSTACKPTR
    627  134e		       ac 04 26 	      ldy	rtemp1
    628  1351		       18		      clc
    629  1352		       60		      rts
    630  1353
    631  1353							;=====================================================
    632  1353							; This pushes curptr basic current line onto the call stack.
    633  1353							; and CUROFF. Also marks entry type as 1 = GOSUB
    634  1353
    635  1353				   pushLN
    636  1353		       8c 04 26 	      sty	rtemp1
    637  1356		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    638  1358		       c5 4d		      cmp	GOSUBSTACKPTR
    639  135a		       90 1a		      bcc	pusherr	; No error
    640  135c		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    641  135e		       a2 00		      ldx	#0	; Start of bytes to copy
    642  1360				   pushLoop
    643  1360		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    644  1362		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    645  1364		       c8		      iny		; Next destination
    646  1365		       e8		      inx		; Next Source byte
    647  1366		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    648  1368		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    649  136a
    650  136a		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    651  136c		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    652  136e		       c8		      iny		; Next entry
    653  136f
    654  136f		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    655  1371		       ac 04 26 	      ldy	rtemp1
    656  1374		       18		      clc
    657  1375		       60		      rts
    658  1376				   pusherr
    659  1376		       38		      sec
    660  1377		       60		      rts
    661  1378							;=====================================================
    662  1378							; This pops Top Off gosub call Stack and
    663  1378							; places it in CURPTR/CUROFF.
    664  1378							; This checks if the type = 1 GOSUB
    665  1378							; if not it removes what ever is on the stack
    666  1378							; until it finds the next return. Allowing
    667  1378							; a return from within a for/next
    668  1378		       8c 04 26    popLN      sty	rtemp1
    669  137b		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    670  137d		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    671  137f
    672  137f				   popContinue
    673  137f		       c0 04		      cpy	#4	; if less than 4 on stack then error
    674  1381		       90 18		      bcc	poperr	; Process an error
    675  1383
    676  1383		       88		      dey		; Position to read entry type
    677  1384		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    678  1386		       c9 01		      cmp	#1	; Type is a gosub entry
    679  1388		       d0 13		      bne	popSkipEntry	; No then just skip this
    680  138a
    681  138a				   popLoop
    682  138a		       88		      dey
    683  138b		       ca		      dex
    684  138c		       b1 4b		      lda	(GOSUBSTACK),y
    685  138e		       95 4f		      sta	CURPTR,x
    686  1390		       e0 00		      cpx	#0
    687  1392		       d0 f6		      bne	popLoop	; Loop until all moved
    688  1394
    689  1394
    690  1394		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    691  1396		       ac 04 26 	      ldy	rtemp1
    692  1399		       18		      clc
    693  139a		       60		      rts
    694  139b
    695  139b		       38	   poperr     sec
    696  139c		       60		      rts
    697  139d
    698  139d		       88	   popSkipEntry dey
    699  139e		       88		      dey
    700  139f		       88		      dey
    701  13a0		       4c 7f 13 	      jmp	popContinue
    702  13a3
    703  13a3							;
    704  13a3							;=====================================================
    705  13a3							; This pushes R1 onto the stack
    706  13a3							;
    707  13a3		       8c 04 26    pushR1     sty	rtemp1
    708  13a6		       a4 4a		      ldy	MATHSTACKPTR
    709  13a8		       c0 28		      cpy	#MATHSTACKSIZE<<1
    710  13aa		       b0 ef		      bcs	poperr
    711  13ac		       a5 54		      lda	R1
    712  13ae		       91 48		      sta	(MATHSTACK),y
    713  13b0		       c8		      iny
    714  13b1		       a5 55		      lda	R1+1
    715  13b3		       91 48		      sta	(MATHSTACK),y
    716  13b5		       c8		      iny
    717  13b6		       84 4a		      sty	MATHSTACKPTR
    718  13b8		       ac 04 26 	      ldy	rtemp1
    719  13bb		       18		      clc
    720  13bc		       60		      rts
    721  13bd							;
    722  13bd							;=====================================================
    723  13bd							; This pops Top Of Stack and places it in R0.
    724  13bd							;
    725  13bd		       8c 04 26    popR0      sty	rtemp1
    726  13c0		       a4 4a		      ldy	MATHSTACKPTR
    727  13c2		       f0 d7		      beq	poperr
    728  13c4		       88		      dey
    729  13c5		       b1 48		      lda	(MATHSTACK),y
    730  13c7		       85 53		      sta	R0+1
    731  13c9		       88		      dey
    732  13ca		       b1 48		      lda	(MATHSTACK),y
    733  13cc		       85 52		      sta	R0
    734  13ce		       84 4a		      sty	MATHSTACKPTR
    735  13d0		       ac 04 26 	      ldy	rtemp1
    736  13d3		       18		      clc
    737  13d4		       60		      rts
    738  13d5
    739  13d5							;
    740  13d5							;=====================================================
    741  13d5							; This pops TOS and places it in R1.
    742  13d5							;
    743  13d5		       8c 04 26    popR1      sty	rtemp1
    744  13d8		       a4 4a		      ldy	MATHSTACKPTR
    745  13da		       f0 bf		      beq	poperr
    746  13dc		       88		      dey
    747  13dd		       b1 48		      lda	(MATHSTACK),y
    748  13df		       85 55		      sta	R1+1
    749  13e1		       88		      dey
    750  13e2		       b1 48		      lda	(MATHSTACK),y
    751  13e4		       85 54		      sta	R1
    752  13e6		       84 4a		      sty	MATHSTACKPTR
    753  13e8		       ac 04 26 	      ldy	rtemp1
    754  13eb		       60		      rts
    755  13ec							;
    756  13ec							;=====================================================
    757  13ec							; This pops TOS and places it in MQ.
    758  13ec							;
    759  13ec		       8c 04 26    popMQ      sty	rtemp1
    760  13ef		       a4 4a		      ldy	MATHSTACKPTR
    761  13f1		       f0 a8		      beq	poperr
    762  13f3		       88		      dey
    763  13f4		       b1 48		      lda	(MATHSTACK),y
    764  13f6		       85 57		      sta	MQ+1
    765  13f8		       88		      dey
    766  13f9		       b1 48		      lda	(MATHSTACK),y
    767  13fb		       85 56		      sta	MQ
    768  13fd		       84 4a		      sty	MATHSTACKPTR
    769  13ff		       ac 04 26 	      ldy	rtemp1
    770  1402		       60		      rts
    771  1403							;
    772  1403							;=====================================================
    773  1403							; This assists with multiplication and division by
    774  1403							; looking at R0 and R1 and saving a flag as to what
    775  1403							; sign the result will be.  Math is always done on
    776  1403							; positive numbers, so this converts negative numbers
    777  1403							; into positives.  On exit, R0 and R1 are both
    778  1403							; positive.  If the signs were different then 'signs'
    779  1403							; will be non-zero.
    780  1403							;
    781  1403		       a9 00	   SaveSigns  lda	#0
    782  1405		       8d 03 26 	      sta	sign	;assume positive
    783  1408		       a5 53		      lda	R0+1	;MSB
    784  140a		       10 13		      bpl	SaveSigns1
    785  140c		       ee 03 26 	      inc	sign	;it's negative
    786  140f		       49 ff		      eor	#$ff	;flip bits
    787  1411		       85 53		      sta	R0+1
    788  1413		       a5 52		      lda	R0
    789  1415		       49 ff		      eor	#$ff
    790  1417		       85 52		      sta	R0
    791  1419		       e6 52		      inc	R0
    792  141b		       d0 02		      bne	SaveSigns1
    793  141d		       e6 53		      inc	R0+1
    794  141f		       a5 55	   SaveSigns1 lda	R1+1
    795  1421		       10 1a		      bpl	SaveSigns2
    796  1423		       48		      pha
    797  1424		       ad 03 26 	      lda	sign
    798  1427		       49 01		      eor	#1
    799  1429		       8d 03 26 	      sta	sign
    800  142c		       68		      pla
    801  142d		       49 ff		      eor	#$ff	;flip bits
    802  142f		       85 55		      sta	R1+1
    803  1431		       a5 54		      lda	R1
    804  1433		       49 ff		      eor	#$ff
    805  1435		       85 54		      sta	R1
    806  1437		       e6 54		      inc	R1
    807  1439		       d0 02		      bne	SaveSigns2
    808  143b		       e6 55		      inc	R1+1
    809  143d		       60	   SaveSigns2 rts
    810  143e							;
    811  143e							;=====================================================
    812  143e							; This looks at the value of 'signs' and will convert
    813  143e							; both R0 and R1 to negative if set.
    814  143e							;
    815  143e				   RestoreSigns
    816  143e		       ad 03 26 	      lda	sign
    817  1441		       f0 28		      beq	restoresigns2
    818  1443							;
    819  1443		       a5 52		      lda	R0
    820  1445		       d0 02		      bne	restoresigns3
    821  1447		       c6 53		      dec	R0+1
    822  1449				   restoresigns3
    823  1449		       c6 52		      dec	R0
    824  144b		       a5 52		      lda	R0
    825  144d		       49 ff		      eor	#$ff
    826  144f		       85 52		      sta	R0
    827  1451		       a5 53		      lda	R0+1
    828  1453		       49 ff		      eor	#$ff
    829  1455		       85 53		      sta	R0+1
    830  1457							;
    831  1457		       a5 54		      lda	R1
    832  1459		       d0 02		      bne	restoresigns4
    833  145b		       c6 55		      dec	R1+1
    834  145d				   restoresigns4
    835  145d		       c6 54		      dec	R1
    836  145f		       a5 54		      lda	R1
    837  1461		       49 ff		      eor	#$ff
    838  1463		       85 54		      sta	R1
    839  1465		       a5 55		      lda	R1+1
    840  1467		       49 ff		      eor	#$ff
    841  1469		       85 55		      sta	R1+1
    842  146b							;
    843  146b				   restoresigns2
    844  146b		       60		      rts
    845  146c							;
    846  146c							;=====================================================
    847  146c							; Skip over spaces.  Returns Y with the offset to
    848  146c							; either the last character in the line, or the first
    849  146c							; non-space character.
    850  146c							;
    851  146c
    852  146c		       c8	   skipsp2    iny
    853  146d		       b1 4f	   SkipSpaces lda	(CURPTR),y
    854  146f		       f0 04		      beq	Skip3	;end of line
    855  1471		       c9 20		      cmp	#SPACE
    856  1473		       f0 f7		      beq	skipsp2
    857  1475		       60	   Skip3      rts
    858  1476							;*********************************************************
    859  1476							; Output a CR/LF combination to the console.  Preserves
    860  1476							; all registers.
    861  1476							;
    862  1476		       48	   tbcrlf     pha
    863  1477		       a9 0d		      lda	#CR
    864  1479		       20 f2 15 	      jsr	VOUTCH
    865  147c		       a9 0a		      lda	#LF
    866  147e		       20 f2 15 	      jsr	VOUTCH
    867  1481		       68		      pla
    868  1482		       60		      rts
    869  1483							;
    870  1483							;=====================================================
    871  1483							; Some logic to print the Line of basic code being executed
    872  1483		       24 40	   idbgBasic  bit	ILTrace
    873  1485		       50 70		      bvc	dbgBasicNone
    874  1487		       98		      tya
    875  1488		       48		      pha
    876  1489		       20 98 16 	      jsr	SetOutDebug
    877  148c		       20 1b 16 	      jsr	PrtPrgLine
    878  148f		       20 76 14 	      jsr	CRLF
    879  1492		       a5 40		      lda	ILTrace
    880  1494		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    881  1496		       f0 5a		      beq	dbgBasicDone
    882  1498		       20 a3 16 	      jsr	SetInDebug
    883  149b		       20 f8 15 	      jsr	puts
      0  149e					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  149e		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    885  14db				   dbgBasicLoop
    886  14db		       20 f5 15 	      jsr	VGETCH
    887  14de		       20 76 14 	      jsr	CRLF
    888  14e1		       20 e5 15 	      jsr	SetInConsole
    889  14e4
    890  14e4		       c9 73		      cmp	#'s	; Quit program
    891  14e6		       f0 12		      beq	dbgBasicStop
    892  14e8
    893  14e8		       c9 64		      cmp	#'d	; Display Variables
    894  14ea		       d0 06		      bne	dbgBasicDone
    895  14ec
    896  14ec		       20 c7 16 	      jsr	PrintAllVars
    897  14ef		       18		      clc
    898  14f0		       90 e9		      bcc	dbgBasicLoop	; Next char
    899  14f2
    900  14f2		       20 d8 15    dbgBasicDone jsr	SetOutConsole
    901  14f5		       68		      pla
    902  14f6		       a8		      tay
    903  14f7		       4c b9 02    dbgBasicNone jmp	NextIL
    904  14fa
    905  14fa				   dbgBasicStop
    906  14fa		       20 d8 15 	      jsr	SetOutConsole
    907  14fd		       68		      pla
    908  14fe		       a8		      tay
    909  14ff		       4c f1 05 	      jmp	iFIN
    910  1502							;
    911  1502							;=====================================================
    912  1502							; This is some debug logic which displays the current
    913  1502							; value of the ILPC and the line buffer.
    914  1502							;
    915  1502		       24 40	   dbgLine    bit	ILTrace
    916  1504		       30 01		      bmi	dbgPrt
    917  1506		       60		      rts
    918  1507				   dbgPrt
    919  1507		       20 98 16 	      jsr	SetOutDebug
    920  150a		       20 f8 15 	      jsr	puts
      0  150d					      db	"ILPC: ",0
      1  150d		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    922  1514		       a5 44		      lda	ILPC+1
    923  1516		       20 51 16 	      jsr	OUTHEX
    924  1519		       a5 43		      lda	ILPC
    925  151b		       20 51 16 	      jsr	OUTHEX
    926  151e		       a9 20		      lda	#SPACE
    927  1520		       20 f2 15 	      jsr	VOUTCH
    928  1523		       a0 00		      ldy	#0
    929  1525		       b1 43		      lda	(ILPC),y
    930  1527		       20 51 16 	      jsr	OUTHEX
    931  152a							;
    932  152a							; Display the CURPTR value and offset
    933  152a							;
    934  152a		       20 f8 15 	      jsr	puts
      0  152d					      db	", CURPTR: ",0
      1  152d		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    936  1538		       a5 50		      lda	CURPTR+1
    937  153a		       20 51 16 	      jsr	OUTHEX
    938  153d		       a5 4f		      lda	CURPTR
    939  153f		       20 51 16 	      jsr	OUTHEX
    940  1542		       a9 2b		      lda	#'+
    941  1544		       20 f2 15 	      jsr	VOUTCH
    942  1547		       a5 51		      lda	CUROFF
    943  1549		       20 51 16 	      jsr	OUTHEX
    944  154c							;
    945  154c		       20 76 14 	      jsr	CRLF
    946  154f		       20 d8 15 	      jsr	SetOutConsole
    947  1552		       20 85 15 	      jsr	ILChkRange
    948  1555		       b0 02		      bcs	dbgLineErr
    949  1557		       18		      clc
    950  1558		       60		      rts
    951  1559
    952  1559				   dbgLineErr
    953  1559		       20 98 16 	      jsr	SetOutDebug
    954  155c		       20 f8 15 	      jsr	puts
      0  155f					      db	"Outside Valid IL Address Range",CR,LF,0
      1  155f		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    956  1580		       20 d8 15 	      jsr	SetOutConsole
    957  1583		       38		      sec
    958  1584		       60		      rts
    959  1585
    960  1585		       a5 44	   ILChkRange lda	ILPC+1
    961  1587		       c9 18		      cmp	#IL>>8
    962  1589		       90 18		      bcc	ILBadRange
    963  158b		       d0 06		      bne	ILChkHigh
    964  158d
    965  158d		       a5 43		      lda	ILPC
    966  158f		       c9 1f		      cmp	#IL&$ff
    967  1591		       90 10		      bcc	ILBadRange
    968  1593
    969  1593		       a5 44	   ILChkHigh  lda	ILPC+1
    970  1595		       c9 1c		      cmp	#ILEND>>8
    971  1597		       90 08		      bcc	ILGoodRange
    972  1599		       d0 08		      bne	ILBadRange
    973  159b
    974  159b		       a5 43		      lda	ILPC
    975  159d		       c9 a8		      cmp	#ILEND&$ff
    976  159f		       b0 02		      bcs	ILBadRange
    977  15a1
    978  15a1		       18	   ILGoodRange clc
    979  15a2		       60		      rts
    980  15a3				   ILBadRange
    981  15a3		       38		      sec
    982  15a4		       60		      rts
    983  15a5
    984  15a5							;
    985  15a5							;=====================================================
    986  15a5							; This function might go away eventually, but was
    987  15a5							; added to provide data for other pieces of code.
    988  15a5							; It has some ties to the operating environment that
    989  15a5							; will need to be customized for the target system.
    990  15a5							;
    991  15a5				   GetSizes
    992  15a5							;
    993  15a5							; Here is machine specific code to get the highest
    994  15a5							; memory location that can be used by BASIC.
    995  15a5							;
    996  15a5				  -	      if	ProgramStart < $2000
    997  15a5				  -	      lda	#$ff
    998  15a5				  -	      sta	HighMem	;$13ff for KIM-1
    999  15a5				  -	      lda	#$DE	;#$13
   1000  15a5				  -	      sta	HighMem+1
   1001  15a5					      else
   1002  15a5		       a9 ff		      lda	#$ff
   1003  15a7		       8d 0f 26 	      sta	HighMem	;$CFFF otherwise
   1004  15aa		       a9 cf		      lda	#$cf
   1005  15ac		       8d 10 26 	      sta	HighMem+1
   1006  15af					      endif
   1007  15af							;
   1008  15af							; This computes the available memory remaining.
   1009  15af							;
   1010  15af		       38		      sec
   1011  15b0		       ad 0f 26 	      lda	HighMem
   1012  15b3		       ed 0d 26 	      sbc	PROGRAMEND
   1013  15b6		       8d 13 26 	      sta	FreeMem
   1014  15b9		       85 52		      sta	R0
   1015  15bb		       ad 10 26 	      lda	HighMem+1
   1016  15be		       ed 0e 26 	      sbc	PROGRAMEND+1
   1017  15c1		       8d 14 26 	      sta	FreeMem+1
   1018  15c4		       85 53		      sta	R0+1
   1019  15c6							;
   1020  15c6							; This computes the size of the current user program.
   1021  15c6							;
   1022  15c6		       38		      sec
   1023  15c7		       ad 0d 26 	      lda	PROGRAMEND
   1024  15ca		       e9 15		      sbc	#ProgramStart&$ff
   1025  15cc		       8d 11 26 	      sta	UsedMem
   1026  15cf		       ad 0e 26 	      lda	PROGRAMEND+1
   1027  15d2		       e9 26		      sbc	#ProgramStart>>8
   1028  15d4		       8d 12 26 	      sta	UsedMem+1
   1029  15d7							;
   1030  15d7		       60		      rts
   1031  15d8							;
   1032  15d8							;=====================================================
   1033  15d8							; Set output vector to the console output function
   1034  15d8							;
   1035  15d8				   SetOutConsole
   1036  15d8		       48		      pha
   1037  15d9		       a9 0c		      lda	#OUTCH&$ff
   1038  15db		       8d 08 26 	      sta	BOutVec
   1039  15de		       a9 f0		      lda	#OUTCH>>8
   1040  15e0		       8d 09 26 	      sta	BOutVec+1
   1041  15e3		       68		      pla
   1042  15e4		       60		      rts
   1043  15e5
   1044  15e5				   SetInConsole
   1045  15e5		       48		      pha
   1046  15e6		       a9 09		      lda	#GETCH&$ff
   1047  15e8		       8d 0a 26 	      sta	BInVec
   1048  15eb		       a9 f0		      lda	#GETCH>>8
   1049  15ed		       8d 0b 26 	      sta	BInVec+1
   1050  15f0		       68		      pla
   1051  15f1		       60		      rts
   1052  15f2
   1053  15f2							;=====================================================
   1054  15f2							; Jump to the output/input function in BOutVec/BInVec
   1055  15f2							;
   1056  15f2		       6c 08 26    VOUTCH     jmp	(BOutVec)
   1057  15f5		       6c 0a 26    VGETCH     jmp	(BInVec)
   1058  15f8							;
   1059  15f8							;=====================================================
   1060  15f8							; Print the string that immediately follows the JSR to
   1061  15f8							; this function.  Stops when a null byte is found,
   1062  15f8							; then returns to the instruction immediately
   1063  15f8							; following the null.
   1064  15f8							;
   1065  15f8							; Thanks to Ross Archer for this code.
   1066  15f8							; http://www.6502.org/source/io/primm.htm
   1067  15f8							;
   1068  15f8
   1069  15f8		       68	   tbputs     pla		;Get the low part of "return" address
   1070  15f9							;(data start address)
   1071  15f9		       85 65		      sta	PrtFrom
   1072  15fb		       68		      pla
   1073  15fc		       85 66		      sta	PrtFrom+1	;Get the high part of "return" address
   1074  15fe							;(data start address)
   1075  15fe							;Note: actually we're pointing one short
   1076  15fe		       a0 01	   PSINB      ldy	#1
   1077  1600		       b1 65		      lda	(PrtFrom),y	;Get the next string character
   1078  1602		       e6 65		      inc	PrtFrom	;update the pointer
   1079  1604		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
   1080  1606		       e6 66		      inc	PrtFrom+1	;account for page crossing
   1081  1608		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
   1082  160a							;   Accumulator
   1083  160a		       f0 06		      beq	PSIX1	;don't print the final NULL
   1084  160c		       20 f2 15 	      jsr	VOUTCH	;write it out
   1085  160f		       4c fe 15 	      jmp	PSINB	;back around
   1086  1612		       e6 65	   PSIX1      inc	PrtFrom
   1087  1614		       d0 02		      bne	PSIX2
   1088  1616		       e6 66		      inc	PrtFrom+1	;account for page crossing
   1089  1618		       6c 65 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
   1090  161b
   1091  161b							;
   1092  161b
   1093  161b							;====================================================
   1094  161b		       26 0c	   PrtTerm    equ	tempy
   1095  161b
   1096  161b							; on exit Print Y has the offset to use
   1097  161b							; input y =	 addr low
   1098  161b							;	 x =	 addr high
   1099  161b							;	 a =	 termination string
   1100  161b
   1101  161b				   PrtPrgLine
   1102  161b		       a9 00		      lda	#0
   1103  161d		       8d 0c 26 	      sta	PrtTerm
   1104  1620		       f0 05		      beq	PrtPrgText
   1105  1622
   1106  1622		       a9 22	   PrtQuoted  lda	#'"
   1107  1624		       8d 0c 26 	      sta	PrtTerm
   1108  1627
   1109  1627		       a4 51	   PrtPrgText ldy	CUROFF
   1110  1629		       a5 4f		      lda	CURPTR
   1111  162b		       85 65		      sta	PrtFrom
   1112  162d		       a5 50		      lda	CURPTR+1
   1113  162f		       85 66		      sta	PrtFrom+1
   1114  1631		       4c 3d 16 	      jmp	PrtLoop
   1115  1634
   1116  1634							; Print a string pointed to by x= h, y=l terminated by a
   1117  1634							; Return y as the length
   1118  1634
   1119  1634		       86 66	   PrtStr     stx	PrtFrom+1
   1120  1636		       84 65		      sty	PrtFrom
   1121  1638		       8d 0c 26 	      sta	PrtTerm
   1122  163b		       a0 00		      ldy	#0
   1123  163d							;
   1124  163d							; On entry here ptrfrom and prtterm point to area to print
   1125  163d							;
   1126  163d		       b1 65	   PrtLoop    lda	(PrtFrom),y
   1127  163f		       cd 0c 26 	      cmp	PrtTerm
   1128  1642		       f0 0b		      beq	PrtEnd
   1129  1644		       c9 00		      cmp	#0	; always end if 0 is found
   1130  1646		       f0 07		      beq	PrtEnd
   1131  1648		       20 f2 15 	      jsr	VOUTCH
   1132  164b		       c8		      iny
   1133  164c		       4c 3d 16 	      jmp	PrtLoop
   1134  164f		       c8	   PrtEnd     iny		;return byte after the copy
   1135  1650		       60		      rts
   1136  1651							;=====================================================
   1137  1651							; Print character in A as two hex digits to the
   1138  1651							; current output device (console or file).
   1139  1651							;
   1140  1651		       48	   HexToOut   pha		;save return value
   1141  1652		       48		      pha
   1142  1653		       4a		      lsr		;a  ;move top nibble to bottom
   1143  1654		       4a		      lsr		;a
   1144  1655		       4a		      lsr		;a
   1145  1656		       4a		      lsr		;a
   1146  1657		       20 60 16 	      jsr	hexta	;output nibble
   1147  165a		       68		      pla
   1148  165b		       20 60 16 	      jsr	hexta
   1149  165e		       68		      pla		;restore
   1150  165f		       60		      rts
   1151  1660							;
   1152  1660		       29 0f	   hexta      and	#%0001111
   1153  1662		       c9 0a		      cmp	#$0a
   1154  1664		       18		      clc
   1155  1665		       30 02		      bmi	hexta1
   1156  1667		       69 07		      adc	#7
   1157  1669		       69 30	   hexta1     adc	#'0	;then fall into...
   1158  166b		       4c f2 15 	      jmp	VOUTCH
   1159  166e							;====================================================
   1160  166e							;Clear the terminal assume it is ansii or vt100
   1161  166e							;
   1162  166e				   iCLEARSCREEN
   1163  166e		       20 f8 15 	      jsr	puts
      0  1671					      db	$1b,'[,'3,'J,0
      1  1671		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
   1165  1676		       4c b9 02 	      jmp	NextIL
   1166  1679
   1167  1679							;====================================================
   1168  1679							; Push true and false onto math stack
   1169  1679				   pushTrue
   1170  1679		       a9 ff		      lda	#$ff
   1171  167b		       85 52	   pushTF     sta	R0
   1172  167d		       85 53		      sta	R0+1
   1173  167f		       20 39 13 	      jsr	pushR0
   1174  1682		       60		      rts
   1175  1683		       a9 00	   pushFalse  lda	#0
   1176  1685		       f0 f4		      beq	pushTF
   1177  1687
   1178  1687							;======================================================
   1179  1687							; Copy stack top to R1
   1180  1687				   CopyStackR1
   1181  1687		       98		      tya
   1182  1688		       48		      pha
   1183  1689		       a4 4a		      ldy	MATHSTACKPTR
   1184  168b		       88		      dey
   1185  168c		       b1 48		      lda	(MATHSTACK),y
   1186  168e		       85 55		      sta	R1+1
   1187  1690		       88		      dey
   1188  1691		       b1 48		      lda	(MATHSTACK),y
   1189  1693		       85 54		      sta	R1
   1190  1695		       68		      pla
   1191  1696		       a8		      tay
   1192  1697		       60		      rts
   1193  1698
   1194  1698
   1195  1698							;====================================================
   1196  1698							;Swap the out debug call for standard calls
   1197  1698
   1198  1698				   SetOutDebug
   1199  1698					      if	USEDEBUGPORT
   1200  1698		       a9 b8		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1201  169a		       8d 08 26 	      sta	BOutVec
   1202  169d		       a9 16		      lda	#OUTDEBUG>>8
   1203  169f		       8d 09 26 	      sta	BOutVec+1
   1204  16a2					      endif
   1205  16a2		       60		      rts
   1206  16a3				   SetInDebug
   1207  16a3					      if	USEDEBUGPORT
   1208  16a3		       a9 bc		      lda	#INDEBUG&$ff
   1209  16a5		       8d 0a 26 	      sta	BInVec
   1210  16a8		       a9 16		      lda	#INDEBUG>>8
   1211  16aa		       8d 0b 26 	      sta	BInVec+1
   1212  16ad					      endif
   1213  16ad		       60		      rts
   1214  16ae							;
   1215  16ae							;====================================================
   1216  16ae							; Output to the debug console
   1217  16ae							;     x = high address byte
   1218  16ae							;     y = low address byte
   1219  16ae							;     a = Terminator for string
   1220  16ae				   DebugWrite
   1221  16ae		       20 98 16 	      jsr	SetOutDebug
   1222  16b1		       20 34 16 	      jsr	PrtStr
   1223  16b4		       20 d8 15 	      jsr	SetOutConsole
   1224  16b7		       60		      rts
   1225  16b8
   1226  16b8				   OUTDEBUG
   1227  16b8		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1228  16bb		       60		      RTS
   1229  16bc
   1230  16bc		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1231  16bf		       29 01		      and	#$01
   1232  16c1		       f0 f9		      beq	INDEBUG
   1233  16c3		       ad 21 e0 	      lda	DEBUGPORT+1
   1234  16c6		       60		      rts
   1235  16c7							;
   1236  16c7							;=======================================================
   1237  16c7							; Print all Variables
   1238  16c7				   PrintAllVars
   1239  16c7		       a0 00		      ldy	#0
   1240  16c9		       a9 41		      lda	#'A
   1241  16cb				   PrintAllVarsLoop
   1242  16cb		       48		      pha
   1243  16cc		       b1 41		      lda	(VARIABLES),y
   1244  16ce		       85 52		      sta	R0
   1245  16d0		       c8		      iny
   1246  16d1		       b1 41		      lda	(VARIABLES),y
   1247  16d3		       85 53		      sta	R0+1
   1248  16d5
   1249  16d5		       68		      pla		;get the current letter
   1250  16d6		       48		      pha
   1251  16d7		       20 f2 15 	      jsr	VOUTCH
   1252  16da		       20 f8 15 	      jsr	puts
      0  16dd					      db	"=",0
      1  16dd		       3d 00		      .byte.b	"=",0
   1254  16df		       68		      pla
   1255  16e0		       aa		      tax
   1256  16e1		       e8		      inx
   1257  16e2		       8a		      txa
   1258  16e3		       48		      pha		;
   1259  16e4
   1260  16e4		       98		      tya
   1261  16e5		       48		      pha
   1262  16e6		       20 84 11 	      jsr	PrintDecimal
   1263  16e9		       20 f8 15 	      jsr	puts
      0  16ec					      db	" ",0
      1  16ec		       20 00		      .byte.b	" ",0
   1265  16ee		       68		      pla
   1266  16ef		       a8		      tay
   1267  16f0		       c8		      iny
   1268  16f1		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1269  16f3		       90 d6		      bcc	PrintAllVarsLoop
   1270  16f5		       20 76 14 	      jsr	CRLF
   1271  16f8
   1272  16f8		       68		      pla
   1273  16f9		       60		      rts
   1274  16fa
   1275  16fa
   1276  16fa
   1277  16fa
   1278  16fa
   1279  16fa
   1280  16fa
   1281  16fa
   1282  16fa
   1283  16fa
   1284  16fa
   1285  16fa
   1286  16fa
   1287  16fa
   1288  16fa
   1289  16fa
   1290  16fa
   1291  16fa
   1292  16fa
------- FILE mytb.asm
   2159  16fa
   2160  16fa					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  16fa					      include	"storage.asm"
      1  16fa							;
      2  16fa							;=====================================================
      3  16fa							;=====================================================
      4  16fa							;=====================================================
      5  16fa							; This file contains the functions for saving and
      6  16fa							; restoring programs from some sort of mass storage
      7  16fa							; device.  This particular version is for using the
      8  16fa							; Corsham Tech SD Card System.
      9  16fa							;=====================================================
     10  16fa							;=====================================================
     11  16fa							;=====================================================
     12  16fa
     13 U1ca8					      seg.u	TBData
     14 U1ca8		       00	   diskBufLength ds	1
     15 U1ca9		       00	   diskBufOffset ds	1
     16 U1caa		       00 00 00 00*DiskFileName ds	14
     17 U1cb8
     18  16fa					      SEG	Code
     19  16fa
     20  16fa							;
     21  16fa							;=====================================================
     22  16fa							; Open a file for reading as a program.  The next
     23  16fa							; thing on the line should be the filename.
     24  16fa							;
     25  16fa				   iOPENREAD
     26  16fa					      if	XKIM || CTMON65
     27  16fa		       a4 51		      ldy	CUROFF
     28  16fc		       b1 4f		      lda	(CURPTR),y
     29  16fe		       d0 07		      bne	iOPENfn	;might be filename
     30  1700							;
     31  1700							; No filename supplied.
     32  1700							;
     33  1700		       a9 00	   iOPENnofn  lda	#0
     34  1702		       a2 09		      ldx	#ERR_NO_FILENAME
     35  1704		       4c 08 06 	      jmp	iErr2
     36  1707							;
     37  1707							; Add the offset into the buffer start
     38  1707							;
     39  1707		       18	   iOPENfn    clc
     40  1708		       98		      tya
     41  1709		       65 4f		      adc	CURPTR
     42  170b		       a8		      tay		;LSB
     43  170c		       a5 50		      lda	CURPTR+1
     44  170e		       69 00		      adc	#0
     45  1710		       aa		      tax
     46  1711		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  1714		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1716							;
     49  1716							; Open failed
     50  1716							;
     51  1716		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1718		       a9 00	   Rdfail2    lda	#0
     53  171a		       4c 08 06 	      jmp	iErr2
     54  171d							;
     55  171d							; Clear counts and offsets so the next read will
     56  171d							; cause the file to be read.
     57  171d							;
     58  171d		       a9 00	   Ropenok    lda	#0
     59  171f		       8d a9 1c 	      sta	diskBufOffset
     60  1722		       8d a8 1c 	      sta	diskBufLength
     61  1725		       4c b9 02 	      jmp	NextIL
     62  1728					      endif
     63  1728
     64  1728							;
     65  1728							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1728							;Remove a file from the disk
     67  1728				   iRMFILE
     68  1728					      if	XKIM || CTMON65
     69  1728		       a4 51		      ldy	CUROFF
     70  172a		       b1 4f		      lda	(CURPTR),y
     71  172c		       f0 19		      beq	iRMnofn
     72  172e							;
     73  172e		       18		      clc
     74  172f		       98		      tya
     75  1730		       65 4f		      adc	CURPTR
     76  1732		       a8		      tay		;LSB
     77  1733		       a5 50		      lda	CURPTR+1
     78  1735		       69 00		      adc	#0
     79  1737		       aa		      tax
     80  1738		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  173b		       90 07		      bcc	wrmOk	;branch if removed ok
     82  173d		       a9 00		      lda	#0
     83  173f		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1741		       4c 08 06 	      jmp	iErr2
     85  1744		       4c b9 02    wrmOk      jmp	NextIL
     86  1747
     87  1747							; No filename supplied.
     88  1747							;
     89  1747		       a9 00	   iRMnofn    lda	#0
     90  1749		       a2 09		      ldx	#ERR_NO_FILENAME
     91  174b		       4c 08 06 	      jmp	iErr2
     92  174e					      endif
     93  174e							;
     94  174e							;=====================================================
     95  174e				   iOPENWRITE
     96  174e					      if	XKIM || CTMON65
     97  174e		       a4 51		      ldy	CUROFF
     98  1750		       b1 4f		      lda	(CURPTR),y
     99  1752		       f0 f3		      beq	iRMnofn
    100  1754							;
    101  1754		       18		      clc
    102  1755		       98		      tya
    103  1756		       65 4f		      adc	CURPTR
    104  1758		       a8		      tay		;LSB
    105  1759		       a5 50		      lda	CURPTR+1
    106  175b		       69 00		      adc	#0
    107  175d		       aa		      tax
    108  175e		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1761		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1763							;
    111  1763							; Open failed
    112  1763							;
    113  1763		       a9 00	   Wdfail     lda	#0
    114  1765		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1767		       4c 08 06 	      jmp	iErr2
    116  176a							;
    117  176a		       4c b9 02    Wopenok    jmp	NextIL
    118  176d					      endif
    119  176d							;
    120  176d							;=====================================================
    121  176d							; Gets a line of input from the disk file and puts it
    122  176d							; into LINBUF.
    123  176d							;
    124  176d							; On exit:
    125  176d							;    CURPTR points to LINBUF
    126  176d							;    LINBUF contains the line with 0 at the end.
    127  176d							;    Y has offset to first non-space character
    128  176d							;    CURROFF has the same as Y.
    129  176d							;
    130  176d				   iDGETLINE
    131  176d					      if	XKIM || CTMON65
    132  176d		       a2 77		      ldx	#LINBUF&$ff
    133  176f		       86 4f		      stx	CURPTR
    134  1771		       a2 25		      ldx	#LINBUF>>8
    135  1773		       86 50		      stx	CURPTR+1
    136  1775							;
    137  1775		       a2 00		      ldx	#0	;offset
    138  1777		       8e fb 25    iDgetLoop  stx	getlinx
    139  177a		       20 d8 17 	      jsr	getNextFileByte
    140  177d		       b0 16		      bcs	iGetEOF
    141  177f		       c9 0d		      cmp	#CR
    142  1781		       f0 0d		      beq	iGetEOL
    143  1783		       c9 0a		      cmp	#LF
    144  1785		       f0 09		      beq	iGetEOL
    145  1787		       ae fb 25 	      ldx	getlinx
    146  178a		       9d 77 25 	      sta	LINBUF,x
    147  178d		       e8		      inx
    148  178e		       d0 e7		      bne	iDgetLoop
    149  1790							;
    150  1790							; Handle end of line.	If the line has nothing, loop
    151  1790							; back and get another line.
    152  1790							;
    153  1790		       ae fb 25    iGetEOL    ldx	getlinx	;blank line?
    154  1793		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  1795							;
    156  1795							; This can fall through when there is a line, or
    157  1795							; called directly when EOF is encountered.
    158  1795							;
    159  1795		       ae fb 25    iGetEOF    ldx	getlinx
    160  1798		       a9 00		      lda	#0
    161  179a		       9d 77 25 	      sta	LINBUF,x
    162  179d		       85 51		      sta	CUROFF
    163  179f		       a0 00		      ldy	#0
    164  17a1		       20 6d 14 	      jsr	SkipSpaces
    165  17a4		       4c b9 02 	      jmp	NextIL
    166  17a7					      endif
    167  17a7
    168  17a7							;
    169  17a7							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  17a7							; DISK
    171  17a7							;
    172  17a7				   iDDIR
    173  17a7					      if	XKIM || CTMON65
    174  17a7		       20 30 f0 	      jsr	DiskDir
    175  17aa							;
    176  17aa							; Get/Display each entry
    177  17aa							;
    178  17aa		       a2 1c	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  17ac		       a0 aa		      ldy	#DiskFileName&$ff
    180  17ae		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  17b1		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  17b3		       20 f8 15 	      jsr	puts
      0  17b6					      db	"   ",0
      1  17b6		       20 20 20 00	      .byte.b	"   ",0
    184  17ba							; Print the line to the console
    185  17ba		       a2 1c		      ldx	#DiskFileName>>8	;pointer to buffer
    186  17bc		       a0 aa		      ldy	#DiskFileName&$ff
    187  17be		       a5 00		      lda	0
    188  17c0		       20 34 16 	      jsr	PrtStr	;else print name
    189  17c3		       20 18 f0 	      jsr	crlf
    190  17c6
    191  17c6		       4c aa 17 	      jmp	DiskDirLoop	;do next entry
    192  17c9
    193  17c9		       4c b9 02    DiskDirEnd jmp	NextIL
    194  17cc					      endif
    195  17cc							;
    196  17cc							;=====================================================
    197  17cc							; Does a LIST to a Disk file.
    198  17cc							;
    199  17cc				   iDLIST
    200  17cc					      if	XKIM || CTMON65
    201  17cc		       20 07 18 	      jsr	SetOutDisk
    202  17cf		       4c d8 07 	      jmp	iLST2
    203  17d2					      endif
    204  17d2							;
    205  17d2							;=====================================================
    206  17d2							; Closes any pending disk file.  Okay to call if there
    207  17d2							; is no open file.
    208  17d2							;
    209  17d2				   iDCLOSE
    210  17d2					      if	XKIM || CTMON65
    211  17d2		       20 42 f0 	      jsr	DiskClose
    212  17d5		       4c b9 02 	      jmp	NextIL
    213  17d8					      endif
    214  17d8							;
    215  17d8							;=====================================================
    216  17d8							; This gets the next byte from an open disk file.  If
    217  17d8							; there are no more bytes left, this returns C set.
    218  17d8							; Else, C is clear and A contains the character.
    219  17d8							;
    220  17d8				   getNextFileByte
    221  17d8					      if	XKIM || CTMON65
    222  17d8		       ae a9 1c 	      ldx	diskBufOffset
    223  17db		       ec a8 1c 	      cpx	diskBufLength
    224  17de		       d0 14		      bne	hasdata	;branch if still data
    225  17e0							;
    226  17e0							; There is no data left in the buffer, so read a
    227  17e0							; block from the SD system.
    228  17e0							;
    229  17e0		       a9 84		      lda	#BUFFER_SIZE
    230  17e2		       a2 df		      ldx	#buffer>>8
    231  17e4		       a0 0a		      ldy	#buffer&$ff
    232  17e6		       20 3c f0 	      jsr	DiskRead
    233  17e9		       b0 12		      bcs	getNextEof
    234  17eb							;
    235  17eb							; A contains the number of bytes actually read.
    236  17eb							;
    237  17eb		       8d a8 1c 	      sta	diskBufLength	;save length
    238  17ee		       c9 00		      cmp	#0	;shouldn't happen
    239  17f0		       f0 0b		      beq	getNextEof
    240  17f2							;
    241  17f2		       a2 00		      ldx	#0
    242  17f4		       bd 0a df    hasdata    lda	buffer,x
    243  17f7		       e8		      inx
    244  17f8		       8e a9 1c 	      stx	diskBufOffset
    245  17fb		       18		      clc
    246  17fc		       60		      rts
    247  17fd							;
    248  17fd		       a9 00	   getNextEof lda	#0
    249  17ff		       8d a9 1c 	      sta	diskBufOffset
    250  1802		       8d a8 1c 	      sta	diskBufLength
    251  1805		       38		      sec
    252  1806		       60		      rts
    253  1807							;
    254  1807							;=====================================================
    255  1807							; Set output vector to the disk output function
    256  1807							;
    257  1807		       a9 12	   SetOutDisk lda	#DOUT&$ff
    258  1809		       8d 08 26 	      sta	BOutVec
    259  180c		       a9 18		      lda	#DOUT/256
    260  180e		       8d 09 26 	      sta	BOutVec+1
    261  1811		       60		      rts
    262  1812							;
    263  1812							;=====================================================
    264  1812
    265  1812		       8d 0a df    DOUT       sta	buffer
    266  1815		       a9 01		      lda	#1
    267  1817		       a0 0a		      ldy	#buffer&$ff
    268  1819		       a2 df		      ldx	#buffer>>8
    269  181b		       20 3f f0 	      jsr	DiskWrite
    270  181e							;
    271  181e							; need error checking here
    272  181e							;
    273  181e		       60		      rts
    274  181f					      endif
    275  181f
    276  181f
------- FILE mytb.asm
   2162  181f					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  181f					      include	"IL.inc"
      1  181f
      2  181f							;=====================================================
      3  181f							; IL.inc
      4  181f							; These are macros for IL instructions
      5  181f							;
      6  181f					      mac	dw
      7  181f					      .word	{0}
      8  181f					      endm
      9  181f					      mac	db
     10  181f					      .byte	{0}
     11  181f					      endm
     12  181f					      macro	xinit
     13  181f					      db	0
     14  181f					      endm		;reset the il to start clear all
     15  181f							;
     16  181f					      macro	done
     17  181f					      db	1
     18  181f					      endm		;print an error if not end of line
     19  181f							;
     20  181f					      macro	prs
     21  181f					      db	2
     22  181f					      endm		;print a quoted string
     23  181f							;
     24  181f					      macro	prn
     25  181f					      db	3
     26  181f					      endm		;print a number
     27  181f							;
     28  181f					      macro	spc
     29  181f					      db	4
     30  181f					      endm		;print space til new tabstop
     31  181f							;
     32  181f					      macro	nline
     33  181f					      db	5
     34  181f					      endm		;print a new line crlf
     35  181f							;
     36  181f							; My NXT is a bit different in that it takes one
     37  181f							; parameter, which is an address.  If the BASIC
     38  181f							; program is currently running then move to the
     39  181f							; next line and continue execution.  However, if
     40  181f							; in direct mode, jump to the specified IL label.
     41  181f							;
     42  181f					      macro	nxt
     43  181f					      db	6
     44  181f					      dw	{1}	; addr
     45  181f					      endm		; addr
     46  181f							;
     47  181f					      macro	xfer
     48  181f					      db	7
     49  181f					      endm
     50  181f							;
     51  181f					      macro	sav
     52  181f					      db	8
     53  181f					      db	{1}
     54  181f					      endm
     55  181f							;
     56  181f					      macro	rstr
     57  181f					      db	9
     58  181f					      endm
     59  181f							;
     60  181f					      macro	cmpr
     61  181f					      db	10
     62  181f					      endm
     63  181f							;
     64  181f					      macro	innum
     65  181f					      db	11
     66  181f					      endm
     67  181f							;
     68  181f					      macro	fin
     69  181f					      db	12
     70  181f					      endm
     71  181f							;
     72  181f							; ERR is followed by an error number.	The error
     73  181f							; code is printed along with the line number.
     74  181f							; Control is passed to the statement set with
     75  181f							; the ERRGOTO statement.
     76  181f							;
     77  181f					      macro	errmsg
     78  181f					      db	13
     79  181f					      dw	{1}	;ecode
     80  181f					      endm		;ecode
     81  181f							;
     82  181f					      macro	add
     83  181f					      db	14
     84  181f					      endm
     85  181f							;
     86  181f					      macro	sub
     87  181f					      db	15
     88  181f					      endm
     89  181f							;
     90  181f					      macro	neg
     91  181f					      db	16
     92  181f					      endm
     93  181f							;
     94  181f					      macro	mul
     95  181f					      db	17
     96  181f					      endm
     97  181f							;
     98  181f					      macro	div
     99  181f					      db	18
    100  181f					      endm
    101  181f							;
    102  181f					      macro	store
    103  181f					      db	19
    104  181f					      endm
    105  181f							;
    106  181f					      macro	ind
    107  181f					      db	20
    108  181f					      endm
    109  181f							;
    110  181f					      macro	lst
    111  181f					      db	21
    112  181f					      endm
    113  181f							;
    114  181f					      macro	init
    115  181f					      db	22
    116  181f					      endm
    117  181f							;
    118  181f					      macro	getline
    119  181f					      db	23
    120  181f					      endm
    121  181f							;
    122  181f					      macro	insert
    123  181f					      db	24
    124  181f					      endm
    125  181f							;
    126  181f					      macro	rtn
    127  181f					      db	25
    128  181f					      endm
    129  181f							;
    130  181f					      macro	exit
    131  181f					      db	26
    132  181f					      endm
    133  181f							;
    134  181f					      macro	lit
    135  181f					      db	27
    136  181f					      dw	{1}	;value
    137  181f					      endm		; value LIT
    138  181f							;
    139  181f					      macro	call
    140  181f					      db	28
    141  181f					      dw	{1}	;addr
    142  181f					      endm		;addr
    143  181f							;
    144  181f							; IJMP will set the IL PC to the specified value.
    145  181f							;
    146  181f					      macro	ijmp
    147  181f					      db	29
    148  181f					      dw	{1}	;addr
    149  181f					      endm		;addr
    150  181f							;
    151  181f					      macro	vinit
    152  181f					      db	30
    153  181f					      endm
    154  181f							;
    155  181f							; ERRGOTO sets the point in the code where the IL
    156  181f							; interpreter will go after any error.
    157  181f							;
    158  181f					      macro	errgoto
    159  181f					      db	31
    160  181f					      dw	{1}	;addr
    161  181f					      endm		;addr
    162  181f							;
    163  181f					      macro	tst
    164  181f					      db	32
    165  181f					      db	({1}-*)-1	;(addr-*)-1
    166  181f					      db	{2},0	;string,0
    167  181f					      endm		;addr,string
    168  181f							;
    169  181f					      macro	tstv
    170  181f					      db	33
    171  181f					      db	({1}-*)-1	;(addr-*)-1
    172  181f					      endm		;addr
    173  181f							;
    174  181f					      macro	tstl
    175  181f					      db	34
    176  181f					      db	({1}-*)-1	;(addr-*)-1
    177  181f					      endm		;addr
    178  181f							;
    179  181f					      macro	tstn
    180  181f					      db	35
    181  181f					      db	({1}-*)-1	;(addr-*)-1
    182  181f					      endm		;addr
    183  181f							;
    184  181f							; FREE returns the amount of free RAM on top of
    185  181f							; the stack.  This is the amount of room the user
    186  181f							; program has available.
    187  181f							;
    188  181f					      macro	free
    189  181f					      db	36
    190  181f					      endm
    191  181f							;
    192  181f							; RANDOM takes the top item off the stack and
    193  181f							; replaces it with a random number that is
    194  181f							; MOD the initial value.  Ie, if the TOS is
    195  181f							; 42 then RANDOM returns a value from 0 to 41.
    196  181f							;
    197  181f					      macro	random
    198  181f					      db	37
    199  181f					      endm
    200  181f							;
    201  181f							; ABS will replace the top of stack with the
    202  181f							; absolute value.
    203  181f							;
    204  181f					      macro	abs
    205  181f					      db	38
    206  181f					      endm
    207  181f							;
    208  181f							; OPENREAD opens a file for reading, as in getting
    209  181f							; statements from it.
    210  181f							;
    211  181f					      macro	openread
    212  181f					      db	39
    213  181f					      endm
    214  181f							;
    215  181f							; OPENWRITE opens a file for writing, as in saving
    216  181f							; the current program to it.
    217  181f							;
    218  181f					      macro	openwrite
    219  181f					      db	40
    220  181f					      endm
    221  181f							;
    222  181f							; DCLOSE closes any open disk file.
    223  181f							;
    224  181f					      macro	dclose
    225  181f					      db	41
    226  181f					      endm
    227  181f							;
    228  181f							; DGETLINE gets one line from the disk file and puts it
    229  181f							; into LINBUFF.
    230  181f							;
    231  181f					      macro	dgetline
    232  181f					      db	42
    233  181f					      endm
    234  181f							;
    235  181f							; DLIST saves the program to an open disk file.
    236  181f							;
    237  181f					      macro	dlist
    238  181f					      db	43
    239  181f					      endm
    240  181f							; DDIR list the current directory
    241  181f							;
    242  181f					      macro	ddir
    243  181f					      db	44
    244  181f					      endm
    245  181f
    246  181f							; RMFILE remove a fle from disk
    247  181f					      macro	rmfile
    248  181f					      db	45
    249  181f					      endm
    250  181f
    251  181f							; CLEARSCREEN clear the screen
    252  181f					      macro	clearscreen
    253  181f					      db	46
    254  181f					      endm
    255  181f							; POKEMEM Poke value into memory
    256  181f					      macro	pokemem
    257  181f					      db	47
    258  181f					      endm
    259  181f							; PEEKMEM peek at value in memory
    260  181f					      macro	peekmem
    261  181f					      db	48
    262  181f					      endm
    263  181f							; TSTLET Test if the statement is a let without the keyword let
    264  181f					      macro	tstlet
    265  181f					      db	49
    266  181f					      db	({1}-*)-1	;(addr-*)-1
    267  181f					      endm		;addr
    268  181f							; TSTDONE if we reach the end of a statement
    269  181f					      macro	tstdone
    270  181f					      db	50
    271  181f					      db	({1}-*)-1	;(addr-*)-1
    272  181f					      endm		;addr
    273  181f							; GETCHAR	get a character from the input line leave it in RO
    274  181f					      macro	getchar
    275  181f					      db	51
    276  181f					      endm
    277  181f							; PUTCHAR	Put a character to the terminal
    278  181f					      macro	putchar
    279  181f					      db	52
    280  181f					      endm
    281  181f							; Call		Call a machine function return a to stack
    282  181f					      macro	callfunc
    283  181f					      db	53
    284  181f					      endm
    285  181f
    286  181f							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  181f					      macro	ibranch
    288  181f					      db	54
    289  181f					      endm
    290  181f
    291  181f							; TSTSTR	 Tests for the open quote in a string
    292  181f					      macro	tststr
    293  181f					      db	55
    294  181f					      db	({1}-*)-1	;(addr-*)-1
    295  181f					      endm
    296  181f							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  181f					      macro	setirq
    298  181f					      db	56
    299  181f					      endm
    300  181f
    301  181f							; TSTIRQ	Test for irq pending,
    302  181f							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  181f					      macro	tstirq
    304  181f					      db	57
    305  181f					      db	({1}-*)-1	;(addr-*)-1
    306  181f					      endm
    307  181f
    308  181f							; IRET    return from interupt service
    309  181f					      macro	iret
    310  181f					      db	58
    311  181f					      endm
    312  181f
    313  181f							; INSTR   read a string from the input
    314  181f					      macro	instr
    315  181f					      db	59
    316  181f					      endm
    317  181f
    318  181f							; MODULO Returns the remainder of the division
    319  181f					      macro	modulo
    320  181f					      db	60
    321  181f					      endm
    322  181f							; Set a task line
    323  181f					      macro	taskcreate
    324  181f					      db	61
    325  181f					      endm
    326  181f							; End a task
    327  181f					      macro	etask
    328  181f					      db	62
    329  181f					      endm
    330  181f							; Skip to next task
    331  181f					      macro	ntask
    332  181f					      db	63
    333  181f					      endm
    334  181f							; Subscript
    335  181f					      macro	subscript
    336  181f					      db	64
    337  181f					      endm
    338  181f							; KILL Task
    339  181f					      macro	taskkill
    340  181f					      db	65
    341  181f					      endm
    342  181f							; STAT Task
    343  181f					      macro	taskstat
    344  181f					      db	66
    345  181f					      endm
    346  181f							;  output value as hex
    347  181f					      macro	hexprt
    348  181f					      db	67
    349  181f					      endm
    350  181f							;  Read in background has completed
    351  181f					      macro	readcomplete
    352  181f					      db	68
    353  181f					      endm
    354  181f							;  ReadInput line
    355  181f					      macro	readstart
    356  181f					      db	69
    357  181f					      endm
    358  181f							; Startio request
    359  181f					      macro	startio
    360  181f					      db	70
    361  181f					      endm
    362  181f							; Endio
    363  181f					      macro	endio
    364  181f					      db	71
    365  181f					      endm
    366  181f							; Logical not
    367  181f					      macro	lognot
    368  181f					      db	72
    369  181f					      endm
    370  181f							; Logical OR
    371  181f					      macro	logor
    372  181f					      db	73
    373  181f					      endm
    374  181f							;Logical and
    375  181f					      macro	logand
    376  181f					      db	74
    377  181f					      endm
    378  181f							;Logical XOR
    379  181f					      macro	logxor
    380  181f					      db	75
    381  181f					      endm
    382  181f							;Wait for task to complete, or list of tasks
    383  181f					      macro	wtask
    384  181f					      db	76
    385  181f					      db	({1}-*)-1	;(addr-*)-1
    386  181f					      endm
    387  181f							;Get the current task id
    388  181f					      MACRO	taskpid
    389  181f					      db	77
    390  181f					      endm
    391  181f							;Trace the basic execution
    392  181f					      Macro	traceprogram
    393  181f					      db	78
    394  181f					      endm
    395  181f							;Do a basic program Trace
    396  181f					      Macro	debugbasic
    397  181f					      db	79
    398  181f					      endm
    399  181f
    400  181f							; Inter Process communications instructions
    401  181f					      Macro	ipcsend
    402  181f					      db	80
    403  181f					      endm
    404  181f					      Macro	ipcreceive
    405  181f					      db	81
    406  181f					      endm
    407  181f					      Macro	ipccheck
    408  181f					      db	82
    409  181f					      endm
    410  181f					      Macro	ipcio
    411  181f					      db	83
    412  181f					      endm
    413  181f					      Macro	pushmathstack
    414  181f					      db	84
    415  181f					      endm
    416  181f					      Macro	popmathstack
    417  181f					      db	85
    418  181f					      endm
    419  181f					      Macro	savemathstack
    420  181f					      db	86
    421  181f					      endm
    422  181f					      Macro	restoremathstack
    423  181f					      db	87
    424  181f					      endm
    425  181f					      Macro	incparmcount
    426  181f					      db	88
    427  181f					      endm
    428  181f					      Macro	taskgetmathstack
    429  181f					      db	89
    430  181f					      endm
    431  181f					      Macro	taskenable
    432  181f					      db	90
    433  181f					      endm
    434  181f					      Macro	tasksuspend
    435  181f					      db	91
    436  181f					      endm
    437  181f					      Macro	taskputmathptr
    438  181f					      db	92
    439  181f					      endm
    440  181f							; Test for an extension type of variable that allows access to a tasks variables
    441  181f							; Using  PID!<Var name>
    442  181f					      Macro	tstvt
    443  181f					      db	93
    444  181f					      db	({1}-*)-1	;(addr-*)-1
    445  181f					      endm
    446  181f
    447  181f							; Provide access to R2 for the IL program
    448  181f					      Macro	setr2
    449  181f					      db	94
    450  181f					      db	{1}	; R2 is only one byte
    451  181f					      endm
    452  181f							;Move stack top to temp
    453  181f					      Macro	stk2tmp
    454  181f					      db	95
    455  181f					      endm
    456  181f
    457  181f					      Macro	tmp2stk
    458  181f					      db	96
    459  181f					      endm
    460  181f
    461  181f					      Macro	tstbyte
    462  181f					      db	97
    463  181f					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  181f					      dw	{2}	; address to check
    465  181f					      db	{3}	; Value to compare
    466  181f					      endm
    467  181f
    468  181f
------- FILE mytb.asm
   2164  181f							;
   2165  181f				  -	      if	FIXED
   2166  181f				  -	      org	$1000
   2167  181f					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  181f					      include	"basic.il"
      1  181f							;LET
      2  181f							;=====================================================
      3  181f							;=====================================================
      4  181f					      seg	Code
      5  181f							;=====================================================
      6  181f							; This is the IL of the BASIC (or whatever) language.
      7  181f							; Because of the way macros are implemented by as65,
      8  181f							; labels can't be on the same line as a macro
      9  181f							; invocation, so that's why labels are on separate
     10  181f							; lines.
     11  181f							;
     12  181f		       18 1f	   IL	      equ	*
     13  181f
     14  181f							;THE IL CONTROL SECTION
     15  181f
     16  181f				   START
      0  181f					      INIT		;INITIALIZE
      0  181f					      db	22
      1  181f		       16		      .byte.b	22
      0  1820					      NLINE		;WRITE CRLF
      0  1820					      db	5
      1  1820		       05		      .byte.b	5
      0  1821					      ERRGOTO	CO	;where to go after an error
      0  1821					      db	31
      1  1821		       1f		      .byte.b	31
      0  1822					      dw	CO
      1  1822		       25 18		      .word.w	CO
      0  1824					      VINIT		;clear all variables
      0  1824					      db	30
      1  1824		       1e		      .byte.b	30
     21  1825							;
     22  1825							; This is where we jump to get a line of commands or
     23  1825							; a program from the user.
     24  1825							;
     25  1825				   CO
      0  1825					      GETLINE		;WRITE PROMPT AND GET LINE
      0  1825					      db	23
      1  1825		       17		      .byte.b	23
      0  1826					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1826					      db	34
      1  1826		       22		      .byte.b	34
      0  1827					      db	(XEC-*)-1
      1  1827		       04		      .byte.b	(XEC-*)-1
      0  1828					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1828					      db	24
      1  1828		       18		      .byte.b	24
      0  1829					      IJMP	CO
      0  1829					      db	29
      1  1829		       1d		      .byte.b	29
      0  182a					      dw	CO
      1  182a		       25 18		      .word.w	CO
     30  182c				   XEC
      0  182c					      XINIT		;INITIALIZE
      0  182c					      db	0
      1  182c		       00		      .byte.b	0
     32  182d
     33  182d							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  182d				   STMT
      0  182d					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  182d					      db	79
      1  182d		       4f		      .byte.b	79
      0  182e					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  182e					      db	57
      1  182e		       39		      .byte.b	57
      0  182f					      db	(notirq-*)-1
      1  182f		       00		      .byte.b	(notirq-*)-1
     37  1830				   notirq
      0  1830					      TSTLET	LET	;Test if second field is =
      0  1830					      db	49
      1  1830		       31		      .byte.b	49
      0  1831					      db	(LET-*)-1
      1  1831		       03		      .byte.b	(LET-*)-1
      0  1832					      IJMP	DOLET	;allow the default to be let
      0  1832					      db	29
      1  1832		       1d		      .byte.b	29
      0  1833					      dw	DOLET
      1  1833		       3b 18		      .word.w	DOLET
     40  1835				   LET
      0  1835					      TST	S1,"LET"	;IS STATEMENT A LET
      0  1835					      db	32
      1  1835		       20		      .byte.b	32
      0  1836					      db	(S1-*)-1
      1  1836		       21		      .byte.b	(S1-*)-1
      0  1837					      db	"LET",0
      1  1837		       4c 45 54 00	      .byte.b	"LET",0
     42  183b				   DOLET
      0  183b					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  183b					      db	33
      1  183b		       21		      .byte.b	33
      0  183c					      db	(ERRVEC-*)-1
      1  183c		       ca		      .byte.b	(ERRVEC-*)-1
      0  183d					      TST	LETBE,"["
      0  183d					      db	32
      1  183d		       20		      .byte.b	32
      0  183e					      db	(LETBE-*)-1
      1  183e		       0a		      .byte.b	(LETBE-*)-1
      0  183f					      db	"[",0
      1  183f		       5b 00		      .byte.b	"[",0
      0  1841					      CALL	EXPR
      0  1841					      db	28
      1  1841		       1c		      .byte.b	28
      0  1842					      dw	EXPR
      1  1842		       88 1a		      .word.w	EXPR
      0  1844					      TST	ERRVEC,"]"
      0  1844					      db	32
      1  1844		       20		      .byte.b	32
      0  1845					      db	(ERRVEC-*)-1
      1  1845		       c1		      .byte.b	(ERRVEC-*)-1
      0  1846					      db	"]",0
      1  1846		       5d 00		      .byte.b	"]",0
      0  1848					      SUBSCRIPT
      0  1848					      db	64
      1  1848		       40		      .byte.b	64
     48  1849				   LETBE
      0  1849					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1849					      db	32
      1  1849		       20		      .byte.b	32
      0  184a					      db	(ERRVEC-*)-1
      1  184a		       bc		      .byte.b	(ERRVEC-*)-1
      0  184b					      db	"=",0
      1  184b		       3d 00		      .byte.b	"=",0
      0  184d					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  184d					      db	28
      1  184d		       1c		      .byte.b	28
      0  184e					      dw	EXPR
      1  184e		       88 1a		      .word.w	EXPR
      0  1850					      DONE		;REPORT ERROR IF NOT NEXT
      0  1850					      db	1
      1  1850		       01		      .byte.b	1
      0  1851					      STORE		;STORE RESULT
      0  1851					      db	19
      1  1851		       13		      .byte.b	19
      0  1852					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1852					      db	6
      1  1852		       06		      .byte.b	6
      0  1853					      dw	CO
      1  1853		       25 18		      .word.w	CO
      0  1855					      IJMP	STMT
      0  1855					      db	29
      1  1855		       1d		      .byte.b	29
      0  1856					      dw	STMT
      1  1856		       2d 18		      .word.w	STMT
     55  1858				   S1
      0  1858					      TST	S1S1,"IRET"	;test return from interupt
      0  1858					      db	32
      1  1858		       20		      .byte.b	32
      0  1859					      db	(S1S1-*)-1
      1  1859		       10		      .byte.b	(S1S1-*)-1
      0  185a					      db	"IRET",0
      1  185a		       49 52 45 54*	      .byte.b	"IRET",0
      0  185f					      TST	S1Sa,"URN"
      0  185f					      db	32
      1  185f		       20		      .byte.b	32
      0  1860					      db	(S1Sa-*)-1
      1  1860		       04		      .byte.b	(S1Sa-*)-1
      0  1861					      db	"URN",0
      1  1861		       55 52 4e 00	      .byte.b	"URN",0
     58  1865				   S1Sa
      0  1865					      DONE		;Must be only thing on the line
      0  1865					      db	1
      1  1865		       01		      .byte.b	1
      0  1866					      IRET		;RESTORE LINE NUMBER OF CALL
      0  1866					      db	58
      1  1866		       3a		      .byte.b	58
      0  1867					      IJMP	STMT
      0  1867					      db	29
      1  1867		       1d		      .byte.b	29
      0  1868					      dw	STMT
      1  1868		       2d 18		      .word.w	STMT
     62  186a
     63  186a				   S1S1
      0  186a					      TST	S1Z,"IF"	;IF STATEMENT
      0  186a					      db	32
      1  186a		       20		      .byte.b	32
      0  186b					      db	(S1Z-*)-1
      1  186b		       11		      .byte.b	(S1Z-*)-1
      0  186c					      db	"IF",0
      1  186c		       49 46 00 	      .byte.b	"IF",0
      0  186f					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  186f					      db	28
      1  186f		       1c		      .byte.b	28
      0  1870					      dw	EXPR
      1  1870		       88 1a		      .word.w	EXPR
      0  1872					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  1872					      db	32
      1  1872		       20		      .byte.b	32
      0  1873					      db	(S1W-*)-1
      1  1873		       05		      .byte.b	(S1W-*)-1
      0  1874					      db	"THEN",0
      1  1874		       54 48 45 4e*	      .byte.b	"THEN",0
     67  1879				   S1W
      0  1879					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1879					      db	54
      1  1879		       36		      .byte.b	54
      0  187a					      IJMP	STMT
      0  187a					      db	29
      1  187a		       1d		      .byte.b	29
      0  187b					      dw	STMT
      1  187b		       2d 18		      .word.w	STMT
     70  187d
     71  187d				   S1Z
      0  187d					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  187d					      db	32
      1  187d		       20		      .byte.b	32
      0  187e					      db	(S2b-*)-1
      1  187e		       19		      .byte.b	(S2b-*)-1
      0  187f					      db	"GO",0
      1  187f		       47 4f 00 	      .byte.b	"GO",0
      0  1882					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  1882					      db	32
      1  1882		       20		      .byte.b	32
      0  1883					      db	(S2-*)-1
      1  1883		       07		      .byte.b	(S2-*)-1
      0  1884					      db	"TO",0
      1  1884		       54 4f 00 	      .byte.b	"TO",0
      0  1887					      CALL	EXPR	;GET LABEL
      0  1887					      db	28
      1  1887		       1c		      .byte.b	28
      0  1888					      dw	EXPR
      1  1888		       88 1a		      .word.w	EXPR
      0  188a					      XFER		;SET UP AND JUMP
      0  188a					      db	7
      1  188a		       07		      .byte.b	7
     76  188b				   S2
     77  188b							;===========================================================================
     78  188b							; Process gosub / function
     79  188b							;
      0  188b					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  188b					      db	32
      1  188b		       20		      .byte.b	32
      0  188c					      db	(ERRVEC-*)-1
      1  188c		       7a		      .byte.b	(ERRVEC-*)-1
      0  188d					      db	"SUB",0
      1  188d		       53 55 42 00	      .byte.b	"SUB",0
      0  1891					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  1891					      db	28
      1  1891		       1c		      .byte.b	28
      0  1892					      dw	GOSUBSTATEMENT
      1  1892		       8e 1c		      .word.w	GOSUBSTATEMENT
      0  1894					      DONE		;ERROR IF CR NOT NEXT
      0  1894					      db	1
      1  1894		       01		      .byte.b	1
      0  1895					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  1895					      db	8
      1  1895		       08		      .byte.b	8
      0  1896					      db	GOSUB_RTN
      1  1896		       01		      .byte.b	GOSUB_RTN
      0  1897					      XFER		;AND JUMP
      0  1897					      db	7
      1  1897		       07		      .byte.b	7
     85  1898							;
     86  1898							; End of gosub processing
     87  1898							;==========================================================================
     88  1898							; Return from a gosub
     89  1898				   S2b
      0  1898					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1898					      db	32
      1  1898		       20		      .byte.b	32
      0  1899					      db	(S3-*)-1
      1  1899		       36		      .byte.b	(S3-*)-1
      0  189a					      db	"RE",0
      1  189a		       52 45 00 	      .byte.b	"RE",0
      0  189d					      TST	S2a,"T"
      0  189d					      db	32
      1  189d		       20		      .byte.b	32
      0  189e					      db	(S2a-*)-1
      1  189e		       27		      .byte.b	(S2a-*)-1
      0  189f					      db	"T",0
      1  189f		       54 00		      .byte.b	"T",0
      0  18a1					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  18a1					      db	32
      1  18a1		       20		      .byte.b	32
      0  18a2					      db	(S2aa-*)-1
      1  18a2		       04		      .byte.b	(S2aa-*)-1
      0  18a3					      db	"URN",0
      1  18a3		       55 52 4e 00	      .byte.b	"URN",0
     93  18a7				   S2aa
      0  18a7					      SETR2	0	; Default no return value
      0  18a7					      db	94
      1  18a7		       5e		      .byte.b	94
      0  18a8					      db	0
      1  18a8		       00		      .byte.b	0
      0  18a9					      TST	S2RetDone,"("	; Check if we will return some value
      0  18a9					      db	32
      1  18a9		       20		      .byte.b	32
      0  18aa					      db	(S2RetDone-*)-1
      1  18aa		       0b		      .byte.b	(S2RetDone-*)-1
      0  18ab					      db	"(",0
      1  18ab		       28 00		      .byte.b	"(",0
      0  18ad					      SETR2	1	; Indicate a return value provided
      0  18ad					      db	94
      1  18ad		       5e		      .byte.b	94
      0  18ae					      db	1
      1  18ae		       01		      .byte.b	1
      0  18af					      CALL	EXPR
      0  18af					      db	28
      1  18af		       1c		      .byte.b	28
      0  18b0					      dw	EXPR
      1  18b0		       88 1a		      .word.w	EXPR
      0  18b2					      TST	ERRVEC,")"	; Now a value is on the stack
      0  18b2					      db	32
      1  18b2		       20		      .byte.b	32
      0  18b3					      db	(ERRVEC-*)-1
      1  18b3		       53		      .byte.b	(ERRVEC-*)-1
      0  18b4					      db	")",0
      1  18b4		       29 00		      .byte.b	")",0
     99  18b6
    100  18b6				   S2RetDone
      0  18b6					      DONE		; MUST BE CR or :
      0  18b6					      db	1
      1  18b6		       01		      .byte.b	1
      0  18b7					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  18b7					      db	9
      1  18b7		       09		      .byte.b	9
      0  18b8					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  18b8					      db	97
      1  18b8		       61		      .byte.b	97
      0  18b9					      db	(S2RetFunc-*)-1
      1  18b9		       09		      .byte.b	(S2RetFunc-*)-1
      0  18ba					      dw	R2
      1  18ba		       58 00		      .word.w	R2
      0  18bc					      db	1
      1  18bc		       01		      .byte.b	1
      0  18bd					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  18bd					      db	6
      1  18bd		       06		      .byte.b	6
      0  18be					      dw	CO
      1  18be		       25 18		      .word.w	CO
      0  18c0					      IJMP	STMT
      0  18c0					      db	29
      1  18c0		       1d		      .byte.b	29
      0  18c1					      dw	STMT
      1  18c1		       2d 18		      .word.w	STMT
    106  18c3				   S2RetFunc
      0  18c3					      IJMP	GOFNRet	; Back into the Function
      0  18c3					      db	29
      1  18c3		       1d		      .byte.b	29
      0  18c4					      dw	GOFNRet
      1  18c4		       64 1c		      .word.w	GOFNRet
    108  18c6							;
    109  18c6							; End of return from gosub
    110  18c6							;============================================================================
    111  18c6							; Process REM statement
    112  18c6				   S2a
      0  18c6					      TST	S3,"M"	;REMark.  Skip rest of line
      0  18c6					      db	32
      1  18c6		       20		      .byte.b	32
      0  18c7					      db	(S3-*)-1
      1  18c7		       08		      .byte.b	(S3-*)-1
      0  18c8					      db	"M",0
      1  18c8		       4d 00		      .byte.b	"M",0
      0  18ca					      NXT	CO
      0  18ca					      db	6
      1  18ca		       06		      .byte.b	6
      0  18cb					      dw	CO
      1  18cb		       25 18		      .word.w	CO
      0  18cd					      IJMP	STMT
      0  18cd					      db	29
      1  18cd		       1d		      .byte.b	29
      0  18ce					      dw	STMT
      1  18ce		       2d 18		      .word.w	STMT
    116  18d0
    117  18d0				   S3
      0  18d0					      TST	S3a,"?"	; ? symonym for print
      0  18d0					      db	32
      1  18d0		       20		      .byte.b	32
      0  18d1					      db	(S3a-*)-1
      1  18d1		       05		      .byte.b	(S3a-*)-1
      0  18d2					      db	"?",0
      1  18d2		       3f 00		      .byte.b	"?",0
      0  18d4					      IJMP	S4S
      0  18d4					      db	29
      1  18d4		       1d		      .byte.b	29
      0  18d5					      dw	S4S
      1  18d5		       e2 18		      .word.w	S4S
    120  18d7				   S3a
      0  18d7					      TST	S8,"PR"	;allow short form of print
      0  18d7					      db	32
      1  18d7		       20		      .byte.b	32
      0  18d8					      db	(S8-*)-1
      1  18d8		       4c		      .byte.b	(S8-*)-1
      0  18d9					      db	"PR",0
      1  18d9		       50 52 00 	      .byte.b	"PR",0
      0  18dc					      TST	S4S,"INT"	;PRINT
      0  18dc					      db	32
      1  18dc		       20		      .byte.b	32
      0  18dd					      db	(S4S-*)-1
      1  18dd		       04		      .byte.b	(S4S-*)-1
      0  18de					      db	"INT",0
      1  18de		       49 4e 54 00	      .byte.b	"INT",0
    123  18e2				   S4S
      0  18e2					      STARTIO		;Lock task until io completes
      0  18e2					      db	70
      1  18e2		       46		      .byte.b	70
    125  18e3				   S4
      0  18e3					      TSTDONE	S4a	;Test if we just want crlf printed
      0  18e3					      db	50
      1  18e3		       32		      .byte.b	50
      0  18e4					      db	(S4a-*)-1
      1  18e4		       03		      .byte.b	(S4a-*)-1
      0  18e5					      IJMP	S6
      0  18e5					      db	29
      1  18e5		       1d		      .byte.b	29
      0  18e6					      dw	S6
      1  18e6		       fe 18		      .word.w	S6
    128  18e8
    129  18e8				   S4a
      0  18e8					      TSTSTR	S7	;TEST FOR QUOTED String
      0  18e8					      db	55
      1  18e8		       37		      .byte.b	55
      0  18e9					      db	(S7-*)-1
      1  18e9		       21		      .byte.b	(S7-*)-1
      0  18ea					      PRS		;PRINT STRING
      0  18ea					      db	2
      1  18ea		       02		      .byte.b	2
    132  18eb				   S5
      0  18eb					      TST	S6A,COMMA	;IS THERE MORE?
      0  18eb					      db	32
      1  18eb		       20		      .byte.b	32
      0  18ec					      db	(S6A-*)-1
      1  18ec		       08		      .byte.b	(S6A-*)-1
      0  18ed					      db	COMMA,0
      1  18ed		       2c 00		      .byte.b	COMMA,0
      0  18ef					      SPC		;SPACE TO NEXT ZONE
      0  18ef					      db	4
      1  18ef		       04		      .byte.b	4
      0  18f0					      TSTDONE	S4	;Not end of line jump back
      0  18f0					      db	50
      1  18f0		       32		      .byte.b	50
      0  18f1					      db	(S4-*)-1
      1  18f1		       f1		      .byte.b	(S4-*)-1
      0  18f2					      IJMP	S6Z	;YES JUMP BACK
      0  18f2					      db	29
      1  18f2		       1d		      .byte.b	29
      0  18f3					      dw	S6Z
      1  18f3		       00 19		      .word.w	S6Z
    137  18f5
    138  18f5							;
    139  18f5							; If a semicolon, don't do anything.
    140  18f5							;
    141  18f5				   S6A
      0  18f5					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  18f5					      db	32
      1  18f5		       20		      .byte.b	32
      0  18f6					      db	(S6-*)-1
      1  18f6		       07		      .byte.b	(S6-*)-1
      0  18f7					      db	SEMICOLON,0
      1  18f7		       3b 00		      .byte.b	SEMICOLON,0
      0  18f9					      TSTDONE	S4	;Jump Back if not end of line
      0  18f9					      db	50
      1  18f9		       32		      .byte.b	50
      0  18fa					      db	(S4-*)-1
      1  18fa		       e8		      .byte.b	(S4-*)-1
      0  18fb					      IJMP	S6Z
      0  18fb					      db	29
      1  18fb		       1d		      .byte.b	29
      0  18fc					      dw	S6Z
      1  18fc		       00 19		      .word.w	S6Z
    145  18fe				   S6
      0  18fe					      DONE		;ERROR IF CR NOT NEXT
      0  18fe					      db	1
      1  18fe		       01		      .byte.b	1
      0  18ff					      NLINE
      0  18ff					      db	5
      1  18ff		       05		      .byte.b	5
    148  1900				   S6Z
      0  1900					      ENDIO		;release task io completed
      0  1900					      db	71
      1  1900		       47		      .byte.b	71
      0  1901					      NXT	CO	;exit here if , or ; at end of print
      0  1901					      db	6
      1  1901		       06		      .byte.b	6
      0  1902					      dw	CO
      1  1902		       25 18		      .word.w	CO
      0  1904					      IJMP	STMT
      0  1904					      db	29
      1  1904		       1d		      .byte.b	29
      0  1905					      dw	STMT
      1  1905		       2d 18		      .word.w	STMT
    152  1907							;
    153  1907							; A jump for code too far away for relative branch
    154  1907							;
    155  1907				   ERRVEC
      0  1907					      ENDIO
      0  1907					      db	71
      1  1907		       47		      .byte.b	71
      0  1908					      IJMP	UNKNOWN
      0  1908					      db	29
      1  1908		       1d		      .byte.b	29
      0  1909					      dw	UNKNOWN
      1  1909		       84 1a		      .word.w	UNKNOWN
    158  190b							;
    159  190b							; Get here if there is an expression to print
    160  190b				   S7
      0  190b					      TST	S7A,"$"
      0  190b					      db	32
      1  190b		       20		      .byte.b	32
      0  190c					      db	(S7A-*)-1
      1  190c		       09		      .byte.b	(S7A-*)-1
      0  190d					      db	"$",0
      1  190d		       24 00		      .byte.b	"$",0
      0  190f					      CALL	EXPR
      0  190f					      db	28
      1  190f		       1c		      .byte.b	28
      0  1910					      dw	EXPR
      1  1910		       88 1a		      .word.w	EXPR
      0  1912					      HEXPRT
      0  1912					      db	67
      1  1912		       43		      .byte.b	67
      0  1913					      IJMP	S5
      0  1913					      db	29
      1  1913		       1d		      .byte.b	29
      0  1914					      dw	S5
      1  1914		       eb 18		      .word.w	S5
    165  1916				   S7A
      0  1916					      CALL	EXPR
      0  1916					      db	28
      1  1916		       1c		      .byte.b	28
      0  1917					      dw	EXPR
      1  1917		       88 1a		      .word.w	EXPR
      0  1919					      TST	S7B,"$"
      0  1919					      db	32
      1  1919		       20		      .byte.b	32
      0  191a					      db	(S7B-*)-1
      1  191a		       06		      .byte.b	(S7B-*)-1
      0  191b					      db	"$",0
      1  191b		       24 00		      .byte.b	"$",0
      0  191d					      PUTCHAR
      0  191d					      db	52
      1  191d		       34		      .byte.b	52
      0  191e					      IJMP	S5
      0  191e					      db	29
      1  191e		       1d		      .byte.b	29
      0  191f					      dw	S5
      1  191f		       eb 18		      .word.w	S5
    170  1921				   S7B
      0  1921					      PRN		;PRINT IT
      0  1921					      db	3
      1  1921		       03		      .byte.b	3
      0  1922					      IJMP	S5	;IS THERE MORE?
      0  1922					      db	29
      1  1922		       1d		      .byte.b	29
      0  1923					      dw	S5
      1  1923		       eb 18		      .word.w	S5
    173  1925							;
    174  1925							;===========================================================
    175  1925							; End of TASK process
    176  1925				   S8
      0  1925					      TST	S8a1,"TASK"	; Any Task COmmand
      0  1925					      db	32
      1  1925		       20		      .byte.b	32
      0  1926					      db	(S8a1-*)-1
      1  1926		       4b		      .byte.b	(S8a1-*)-1
      0  1927					      db	"TASK",0
      1  1927		       54 41 53 4b*	      .byte.b	"TASK",0
      0  192c					      TST	S8G,"E"
      0  192c					      db	32
      1  192c		       20		      .byte.b	32
      0  192d					      db	(S8G-*)-1
      1  192d		       1a		      .byte.b	(S8G-*)-1
      0  192e					      db	"E",0
      1  192e		       45 00		      .byte.b	"E",0
      0  1930					      TST	S8NoParm,"("
      0  1930					      db	32
      1  1930		       20		      .byte.b	32
      0  1931					      db	(S8NoParm-*)-1
      1  1931		       0e		      .byte.b	(S8NoParm-*)-1
      0  1932					      db	"(",0
      1  1932		       28 00		      .byte.b	"(",0
      0  1934					      CALL	EXPR
      0  1934					      db	28
      1  1934		       1c		      .byte.b	28
      0  1935					      dw	EXPR
      1  1935		       88 1a		      .word.w	EXPR
      0  1937					      TST	UNKNOWNLnk,")"
      0  1937					      db	32
      1  1937		       20		      .byte.b	32
      0  1938					      db	(UNKNOWNLnk-*)-1
      1  1938		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1939					      db	")",0
      1  1939		       29 00		      .byte.b	")",0
      0  193b					      ETASK
      0  193b					      db	62
      1  193b		       3e		      .byte.b	62
      0  193c					      DONE
      0  193c					      db	1
      1  193c		       01		      .byte.b	1
      0  193d					      IJMP	STMT
      0  193d					      db	29
      1  193d		       1d		      .byte.b	29
      0  193e					      dw	STMT
      1  193e		       2d 18		      .word.w	STMT
    185  1940				   S8NoParm
      0  1940					      LIT	0
      0  1940					      db	27
      1  1940		       1b		      .byte.b	27
      0  1941					      dw	0
      1  1941		       00 00		      .word.w	0
      0  1943					      ETASK
      0  1943					      db	62
      1  1943		       3e		      .byte.b	62
      0  1944					      DONE		; Must be last thing on a line
      0  1944					      db	1
      1  1944		       01		      .byte.b	1
      0  1945					      IJMP	STMT
      0  1945					      db	29
      1  1945		       1d		      .byte.b	29
      0  1946					      dw	STMT
      1  1946		       2d 18		      .word.w	STMT
    190  1948							;
    191  1948							;===========================================================
    192  1948							; The task gives up the rest of the cycles
    193  1948				   S8G
      0  1948					      TST	S8a,"N"	;Next task
      0  1948					      db	32
      1  1948		       20		      .byte.b	32
      0  1949					      db	(S8a-*)-1
      1  1949		       09		      .byte.b	(S8a-*)-1
      0  194a					      db	"N",0
      1  194a		       4e 00		      .byte.b	"N",0
      0  194c					      NTASK
      0  194c					      db	63
      1  194c		       3f		      .byte.b	63
      0  194d					      NXT	CO	;Next statement to execute
      0  194d					      db	6
      1  194d		       06		      .byte.b	6
      0  194e					      dw	CO
      1  194e		       25 18		      .word.w	CO
      0  1950					      IJMP	STMT
      0  1950					      db	29
      1  1950		       1d		      .byte.b	29
      0  1951					      dw	STMT
      1  1951		       2d 18		      .word.w	STMT
    198  1953							;
    199  1953							;===========================================================
    200  1953							; Waits for a task or list of tasks to complete
    201  1953				   S8a
      0  1953					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1953					      db	32
      1  1953		       20		      .byte.b	32
      0  1954					      db	(S8TASKNO-*)-1
      1  1954		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1955					      db	"W(",0
      1  1955		       57 28 00 	      .byte.b	"W(",0
    203  1958				   S8TSK
      0  1958					      Call	EXPR	;Gets the PID of task to wait for
      0  1958					      db	28
      1  1958		       1c		      .byte.b	28
      0  1959					      dw	EXPR
      1  1959		       88 1a		      .word.w	EXPR
    205  195b				   S8LOOP
      0  195b					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  195b					      db	76
      1  195b		       4c		      .byte.b	76
      0  195c					      db	(S8LOOP-*)-1
      1  195c		       fe		      .byte.b	(S8LOOP-*)-1
      0  195d					      TST	S8aa,COMMA	;Checks for more tasks
      0  195d					      db	32
      1  195d		       20		      .byte.b	32
      0  195e					      db	(S8aa-*)-1
      1  195e		       05		      .byte.b	(S8aa-*)-1
      0  195f					      db	COMMA,0
      1  195f		       2c 00		      .byte.b	COMMA,0
      0  1961					      IJMP	S8TSK	;Go for the next task number
      0  1961					      db	29
      1  1961		       1d		      .byte.b	29
      0  1962					      dw	S8TSK
      1  1962		       58 19		      .word.w	S8TSK
    209  1964				   S8aa
      0  1964					      TST	S8TASKNO,")"	;end of list
      0  1964					      db	32
      1  1964		       20		      .byte.b	32
      0  1965					      db	(S8TASKNO-*)-1
      1  1965		       09		      .byte.b	(S8TASKNO-*)-1
      0  1966					      db	")",0
      1  1966		       29 00		      .byte.b	")",0
      0  1968					      DONE
      0  1968					      db	1
      1  1968		       01		      .byte.b	1
      0  1969					      NXT	CO
      0  1969					      db	6
      1  1969		       06		      .byte.b	6
      0  196a					      dw	CO
      1  196a		       25 18		      .word.w	CO
      0  196c					      IJMP	STMT	;Next Statement
      0  196c					      db	29
      1  196c		       1d		      .byte.b	29
      0  196d					      dw	STMT
      1  196d		       2d 18		      .word.w	STMT
    214  196f				   S8TASKNO
    215  196f
    216  196f				   UNKNOWNLnk
      0  196f					      iJMP	UNKNOWN
      0  196f					      db	29
      1  196f		       1d		      .byte.b	29
      0  1970					      dw	UNKNOWN
      1  1970		       84 1a		      .word.w	UNKNOWN
    218  1972
    219  1972							;
    220  1972							;===========================================================
    221  1972							; Update a memory location with a value
    222  1972				   S8a1
      0  1972					      TST	S8b,"POKE("	; Poke a value into memory
      0  1972					      db	32
      1  1972		       20		      .byte.b	32
      0  1973					      db	(S8b-*)-1
      1  1973		       1c		      .byte.b	(S8b-*)-1
      0  1974					      db	"POKE(",0
      1  1974		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  197a					      CALL	EXPR	; Get address to write to
      0  197a					      db	28
      1  197a		       1c		      .byte.b	28
      0  197b					      dw	EXPR
      1  197b		       88 1a		      .word.w	EXPR
      0  197d					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  197d					      db	32
      1  197d		       20		      .byte.b	32
      0  197e					      db	(UNKNOWNV-*)-1
      1  197e		       64		      .byte.b	(UNKNOWNV-*)-1
      0  197f					      db	COMMA,0
      1  197f		       2c 00		      .byte.b	COMMA,0
      0  1981					      CALL	EXPR	; Get the value to poke
      0  1981					      db	28
      1  1981		       1c		      .byte.b	28
      0  1982					      dw	EXPR
      1  1982		       88 1a		      .word.w	EXPR
      0  1984					      TST	UNKNOWNV,")"	; closing bracket
      0  1984					      db	32
      1  1984		       20		      .byte.b	32
      0  1985					      db	(UNKNOWNV-*)-1
      1  1985		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1986					      db	")",0
      1  1986		       29 00		      .byte.b	")",0
      0  1988					      POKEMEM
      0  1988					      db	47
      1  1988		       2f		      .byte.b	47
      0  1989					      DONE
      0  1989					      db	1
      1  1989		       01		      .byte.b	1
      0  198a					      NXT	CO	;AND SEQUENCE TO NEXT
      0  198a					      db	6
      1  198a		       06		      .byte.b	6
      0  198b					      dw	CO
      1  198b		       25 18		      .word.w	CO
      0  198d					      IJMP	STMT
      0  198d					      db	29
      1  198d		       1d		      .byte.b	29
      0  198e					      dw	STMT
      1  198e		       2d 18		      .word.w	STMT
    232  1990
    233  1990				   S8b
      0  1990					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1990					      db	32
      1  1990		       20		      .byte.b	32
      0  1991					      db	(S8c-*)-1
      1  1991		       11		      .byte.b	(S8c-*)-1
      0  1992					      db	"PUTCH",0
      1  1992		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1998					      CALL	EXPR
      0  1998					      db	28
      1  1998		       1c		      .byte.b	28
      0  1999					      dw	EXPR
      1  1999		       88 1a		      .word.w	EXPR
      0  199b					      PUTCHAR
      0  199b					      db	52
      1  199b		       34		      .byte.b	52
      0  199c					      DONE
      0  199c					      db	1
      1  199c		       01		      .byte.b	1
      0  199d					      NXT	CO	;AND SEQUENCE TO NEXT
      0  199d					      db	6
      1  199d		       06		      .byte.b	6
      0  199e					      dw	CO
      1  199e		       25 18		      .word.w	CO
      0  19a0					      IJMP	STMT
      0  19a0					      db	29
      1  19a0		       1d		      .byte.b	29
      0  19a1					      dw	STMT
      1  19a1		       2d 18		      .word.w	STMT
    240  19a3				   S8c
      0  19a3					      TST	S9,"CLS"	;Clear the screen
      0  19a3					      db	32
      1  19a3		       20		      .byte.b	32
      0  19a4					      db	(S9-*)-1
      1  19a4		       0b		      .byte.b	(S9-*)-1
      0  19a5					      db	"CLS",0
      1  19a5		       43 4c 53 00	      .byte.b	"CLS",0
      0  19a9					      CLEARSCREEN
      0  19a9					      db	46
      1  19a9		       2e		      .byte.b	46
      0  19aa					      NXT	CO	;AND SEQUENCE TO NEXT
      0  19aa					      db	6
      1  19aa		       06		      .byte.b	6
      0  19ab					      dw	CO
      1  19ab		       25 18		      .word.w	CO
      0  19ad					      IJMP	STMT
      0  19ad					      db	29
      1  19ad		       1d		      .byte.b	29
      0  19ae					      dw	STMT
      1  19ae		       2d 18		      .word.w	STMT
    245  19b0				   S9
      0  19b0					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  19b0					      db	32
      1  19b0		       20		      .byte.b	32
      0  19b1					      db	(S13-*)-1
      1  19b1		       2a		      .byte.b	(S13-*)-1
      0  19b2					      db	"INPUT",0
      1  19b2		       49 4e 50 55*	      .byte.b	"INPUT",0
    247  19b8				   S10
      0  19b8					      TSTSTR	S10A	;If there is a string print the prompt
      0  19b8					      db	55
      1  19b8		       37		      .byte.b	55
      0  19b9					      db	(S10A-*)-1
      1  19b9		       05		      .byte.b	(S10A-*)-1
      0  19ba					      PRS
      0  19ba					      db	2
      1  19ba		       02		      .byte.b	2
      0  19bb					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  19bb					      db	32
      1  19bb		       20		      .byte.b	32
      0  19bc					      db	(S10Z-*)-1
      1  19bc		       15		      .byte.b	(S10Z-*)-1
      0  19bd					      db	SEMICOLON,0
      1  19bd		       3b 00		      .byte.b	SEMICOLON,0
    251  19bf				   S10A
      0  19bf					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  19bf					      db	33
      1  19bf		       21		      .byte.b	33
      0  19c0					      db	(UNKNOWN-*)-1
      1  19c0		       c3		      .byte.b	(UNKNOWN-*)-1
      0  19c1					      TST	S10A1,DOLLAR
      0  19c1					      db	32
      1  19c1		       20		      .byte.b	32
      0  19c2					      db	(S10A1-*)-1
      1  19c2		       06		      .byte.b	(S10A1-*)-1
      0  19c3					      db	DOLLAR,0
      1  19c3		       24 00		      .byte.b	DOLLAR,0
      0  19c5					      INSTR		;Move character From tty to AESTK
      0  19c5					      db	59
      1  19c5		       3b		      .byte.b	59
      0  19c6					      IJMP	S10A2
      0  19c6					      db	29
      1  19c6		       1d		      .byte.b	29
      0  19c7					      dw	S10A2
      1  19c7		       ca 19		      .word.w	S10A2
    256  19c9				   S10A1
      0  19c9					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  19c9					      db	11
      1  19c9		       0b		      .byte.b	11
    258  19ca				   S10A2
      0  19ca					      STORE		;STORE IT
      0  19ca					      db	19
      1  19ca		       13		      .byte.b	19
      0  19cb					      TST	S11,COMMA	;IS THERE MORE?
      0  19cb					      db	32
      1  19cb		       20		      .byte.b	32
      0  19cc					      db	(S11-*)-1
      1  19cc		       08		      .byte.b	(S11-*)-1
      0  19cd					      db	COMMA,0
      1  19cd		       2c 00		      .byte.b	COMMA,0
      0  19cf					      IJMP	S10	;YES
      0  19cf					      db	29
      1  19cf		       1d		      .byte.b	29
      0  19d0					      dw	S10
      1  19d0		       b8 19		      .word.w	S10
    262  19d2				   S10Z
      0  19d2					      iJMP	UNKNOWN
      0  19d2					      db	29
      1  19d2		       1d		      .byte.b	29
      0  19d3					      dw	UNKNOWN
      1  19d3		       84 1a		      .word.w	UNKNOWN
    264  19d5				   S11
      0  19d5					      DONE		;MUST BE CR
      0  19d5					      db	1
      1  19d5		       01		      .byte.b	1
      0  19d6					      NXT	CO	;SEQUENCE TO NEXT
      0  19d6					      db	6
      1  19d6		       06		      .byte.b	6
      0  19d7					      dw	CO
      1  19d7		       25 18		      .word.w	CO
      0  19d9					      IJMP	STMT
      0  19d9					      db	29
      1  19d9		       1d		      .byte.b	29
      0  19da					      dw	STMT
      1  19da		       2d 18		      .word.w	STMT
    268  19dc				   S13
      0  19dc					      TST	S14,"END"
      0  19dc					      db	32
      1  19dc		       20		      .byte.b	32
      0  19dd					      db	(S14-*)-1
      1  19dd		       08		      .byte.b	(S14-*)-1
      0  19de					      db	"END",0
      1  19de		       45 4e 44 00	      .byte.b	"END",0
      0  19e2					      FIN
      0  19e2					      db	12
      1  19e2		       0c		      .byte.b	12
    271  19e3
    272  19e3				   UNKNOWNV
      0  19e3					      IJMP	UNKNOWN
      0  19e3					      db	29
      1  19e3		       1d		      .byte.b	29
      0  19e4					      dw	UNKNOWN
      1  19e4		       84 1a		      .word.w	UNKNOWN
    274  19e6
    275  19e6				   S14
      0  19e6					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  19e6					      db	32
      1  19e6		       20		      .byte.b	32
      0  19e7					      db	(S14Z-*)-1
      1  19e7		       0f		      .byte.b	(S14Z-*)-1
      0  19e8					      db	"IRQ",0
      1  19e8		       49 52 51 00	      .byte.b	"IRQ",0
      0  19ec					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  19ec					      db	28
      1  19ec		       1c		      .byte.b	28
      0  19ed					      dw	EXPR
      1  19ed		       88 1a		      .word.w	EXPR
      0  19ef					      DONE		;must be CR
      0  19ef					      db	1
      1  19ef		       01		      .byte.b	1
      0  19f0					      SETIRQ		;Set the line number now
      0  19f0					      db	56
      1  19f0		       38		      .byte.b	56
      0  19f1					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  19f1					      db	6
      1  19f1		       06		      .byte.b	6
      0  19f2					      dw	CO
      1  19f2		       25 18		      .word.w	CO
      0  19f4					      IJMP	STMT
      0  19f4					      db	29
      1  19f4		       1d		      .byte.b	29
      0  19f5					      dw	STMT
      1  19f5		       2d 18		      .word.w	STMT
    282  19f7
    283  19f7				   S14Z
      0  19f7					      TST	S14S1,"KILL"	; Kill A running Task
      0  19f7					      db	32
      1  19f7		       20		      .byte.b	32
      0  19f8					      db	(S14S1-*)-1
      1  19f8		       10		      .byte.b	(S14S1-*)-1
      0  19f9					      db	"KILL",0
      1  19f9		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  19fe					      CALL	EXPR
      0  19fe					      db	28
      1  19fe		       1c		      .byte.b	28
      0  19ff					      dw	EXPR
      1  19ff		       88 1a		      .word.w	EXPR
      0  1a01					      DONE
      0  1a01					      db	1
      1  1a01		       01		      .byte.b	1
      0  1a02					      TASKKILL
      0  1a02					      db	65
      1  1a02		       41		      .byte.b	65
      0  1a03					      NXT	CO
      0  1a03					      db	6
      1  1a03		       06		      .byte.b	6
      0  1a04					      dw	CO
      1  1a04		       25 18		      .word.w	CO
      0  1a06					      IJMP	STMT
      0  1a06					      db	29
      1  1a06		       1d		      .byte.b	29
      0  1a07					      dw	STMT
      1  1a07		       2d 18		      .word.w	STMT
    290  1a09
    291  1a09				   S14S1
      0  1a09					      TST	S15,"LIST"	;LIST COMMAND
      0  1a09					      db	32
      1  1a09		       20		      .byte.b	32
      0  1a0a					      db	(S15-*)-1
      1  1a0a		       0a		      .byte.b	(S15-*)-1
      0  1a0b					      db	"LIST",0
      1  1a0b		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1a10					      DONE
      0  1a10					      db	1
      1  1a10		       01		      .byte.b	1
      0  1a11					      LST
      0  1a11					      db	21
      1  1a11		       15		      .byte.b	21
      0  1a12					      IJMP	CO
      0  1a12					      db	29
      1  1a12		       1d		      .byte.b	29
      0  1a13					      dw	CO
      1  1a13		       25 18		      .word.w	CO
    296  1a15				   S15
      0  1a15					      TST	S16,"RUN"	;RUN COMMAND
      0  1a15					      db	32
      1  1a15		       20		      .byte.b	32
      0  1a16					      db	(S16-*)-1
      1  1a16		       0d		      .byte.b	(S16-*)-1
      0  1a17					      db	"RUN",0
      1  1a17		       52 55 4e 00	      .byte.b	"RUN",0
      0  1a1b					      DONE
      0  1a1b					      db	1
      1  1a1b		       01		      .byte.b	1
      0  1a1c					      VINIT		;clear variables
      0  1a1c					      db	30
      1  1a1c		       1e		      .byte.b	30
      0  1a1d					      LIT	1	;GOTO line 1
      0  1a1d					      db	27
      1  1a1d		       1b		      .byte.b	27
      0  1a1e					      dw	1
      1  1a1e		       01 00		      .word.w	1
      0  1a20					      XFER		;Bob's addition
      0  1a20					      db	7
      1  1a20		       07		      .byte.b	7
    302  1a21							; EXIT
      0  1a21					      IJMP	STMT	;and run!
      0  1a21					      db	29
      1  1a21		       1d		      .byte.b	29
      0  1a22					      dw	STMT
      1  1a22		       2d 18		      .word.w	STMT
    304  1a24				   S16
      0  1a24					      TST	S16A,"NEW"	;clear program
      0  1a24					      db	32
      1  1a24		       20		      .byte.b	32
      0  1a25					      db	(S16A-*)-1
      1  1a25		       08		      .byte.b	(S16A-*)-1
      0  1a26					      db	"NEW",0
      1  1a26		       4e 45 57 00	      .byte.b	"NEW",0
      0  1a2a					      DONE
      0  1a2a					      db	1
      1  1a2a		       01		      .byte.b	1
      0  1a2b					      IJMP	START
      0  1a2b					      db	29
      1  1a2b		       1d		      .byte.b	29
      0  1a2c					      dw	START
      1  1a2c		       1f 18		      .word.w	START
    308  1a2e
    309  1a2e				   S16A
      0  1a2e					      TST	S17A,"TRACE("	;Are we going to trace
      0  1a2e					      db	32
      1  1a2e		       20		      .byte.b	32
      0  1a2f					      db	(S17A-*)-1
      1  1a2f		       16		      .byte.b	(S17A-*)-1
      0  1a30					      db	"TRACE(",0
      1  1a30		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  1a37					      CALL	EXPR
      0  1a37					      db	28
      1  1a37		       1c		      .byte.b	28
      0  1a38					      dw	EXPR
      1  1a38		       88 1a		      .word.w	EXPR
      0  1a3a					      TST	UNKNOWN,")"
      0  1a3a					      db	32
      1  1a3a		       20		      .byte.b	32
      0  1a3b					      db	(UNKNOWN-*)-1
      1  1a3b		       48		      .byte.b	(UNKNOWN-*)-1
      0  1a3c					      db	")",0
      1  1a3c		       29 00		      .byte.b	")",0
      0  1a3e					      TRACEPROGRAM
      0  1a3e					      db	78
      1  1a3e		       4e		      .byte.b	78
      0  1a3f					      DONE
      0  1a3f					      db	1
      1  1a3f		       01		      .byte.b	1
      0  1a40					      NXT	CO
      0  1a40					      db	6
      1  1a40		       06		      .byte.b	6
      0  1a41					      dw	CO
      1  1a41		       25 18		      .word.w	CO
      0  1a43					      IJMP	STMT
      0  1a43					      db	29
      1  1a43		       1d		      .byte.b	29
      0  1a44					      dw	STMT
      1  1a44		       2d 18		      .word.w	STMT
    317  1a46
    318  1a46				   S17A
      0  1a46					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1a46					      db	32
      1  1a46		       20		      .byte.b	32
      0  1a47					      db	(S17B-*)-1
      1  1a47		       06		      .byte.b	(S17B-*)-1
      0  1a48					      db	"EXIT",0
      1  1a48		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1a4d					      EXIT
      0  1a4d					      db	26
      1  1a4d		       1a		      .byte.b	26
    321  1a4e
    322  1a4e							;
    323  1a4e							; Commands related to saving/restoring programs
    324  1a4e							; to/from mass storage.
    325  1a4e							;
    326  1a4e				   S17B
    327  1a4e					      if	(XKIM || CTMON65) && DISK_ACCESS
    328  1a4e
      0  1a4e					      TST	S17C,"SAVE"
      0  1a4e					      db	32
      1  1a4e		       20		      .byte.b	32
      0  1a4f					      db	(S17C-*)-1
      1  1a4f		       0b		      .byte.b	(S17C-*)-1
      0  1a50					      db	"SAVE",0
      1  1a50		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1a55					      OPENWRITE
      0  1a55					      db	40
      1  1a55		       28		      .byte.b	40
      0  1a56					      DLIST
      0  1a56					      db	43
      1  1a56		       2b		      .byte.b	43
      0  1a57					      DCLOSE
      0  1a57					      db	41
      1  1a57		       29		      .byte.b	41
      0  1a58					      IJMP	CO
      0  1a58					      db	29
      1  1a58		       1d		      .byte.b	29
      0  1a59					      dw	CO
      1  1a59		       25 18		      .word.w	CO
    334  1a5b
    335  1a5b				   S17C
      0  1a5b					      TST	S18,"LOAD"
      0  1a5b					      db	32
      1  1a5b		       20		      .byte.b	32
      0  1a5c					      db	(S18-*)-1
      1  1a5c		       11		      .byte.b	(S18-*)-1
      0  1a5d					      db	"LOAD",0
      1  1a5d		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1a62					      OPENREAD
      0  1a62					      db	39
      1  1a62		       27		      .byte.b	39
    338  1a63				   S17CLP
      0  1a63					      DGETLINE		;get line from file
      0  1a63					      db	42
      1  1a63		       2a		      .byte.b	42
      0  1a64					      TSTL	S17EOL	;no line num means EOL
      0  1a64					      db	34
      1  1a64		       22		      .byte.b	34
      0  1a65					      db	(S17EOL-*)-1
      1  1a65		       04		      .byte.b	(S17EOL-*)-1
      0  1a66					      INSERT		;put it into the program
      0  1a66					      db	24
      1  1a66		       18		      .byte.b	24
      0  1a67					      IJMP	S17CLP	;keep going
      0  1a67					      db	29
      1  1a67		       1d		      .byte.b	29
      0  1a68					      dw	S17CLP
      1  1a68		       63 1a		      .word.w	S17CLP
    343  1a6a				   S17EOL
      0  1a6a					      DCLOSE		;close disk file
      0  1a6a					      db	41
      1  1a6a		       29		      .byte.b	41
      0  1a6b					      IJMP	CO	;back to start
      0  1a6b					      db	29
      1  1a6b		       1d		      .byte.b	29
      0  1a6c					      dw	CO
      1  1a6c		       25 18		      .word.w	CO
    346  1a6e
    347  1a6e				   S18
      0  1a6e					      TST	S19,"DIR"
      0  1a6e					      db	32
      1  1a6e		       20		      .byte.b	32
      0  1a6f					      db	(S19-*)-1
      1  1a6f		       08		      .byte.b	(S19-*)-1
      0  1a70					      db	"DIR",0
      1  1a70		       44 49 52 00	      .byte.b	"DIR",0
      0  1a74					      DDIR		;Display the directory content
      0  1a74					      db	44
      1  1a74		       2c		      .byte.b	44
      0  1a75					      IJMP	CO
      0  1a75					      db	29
      1  1a75		       1d		      .byte.b	29
      0  1a76					      dw	CO
      1  1a76		       25 18		      .word.w	CO
    351  1a78					      endif
    352  1a78
      0  1a78				   S19	      TST	UNKNOWN,"ERASE"
      0  1a78					      db	32
      1  1a78		       20		      .byte.b	32
      0  1a79					      db	(UNKNOWN-*)-1
      1  1a79		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1a7a					      db	"ERASE",0
      1  1a7a		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1a80					      RMFILE		;Erase the file from the disk
      0  1a80					      db	45
      1  1a80		       2d		      .byte.b	45
      0  1a81					      IJMP	CO
      0  1a81					      db	29
      1  1a81		       1d		      .byte.b	29
      0  1a82					      dw	CO
      1  1a82		       25 18		      .word.w	CO
    356  1a82					      endif
    357  1a84
    358  1a84							;
    359  1a84							; Else, unknown command.
    360  1a84							;
    361  1a84				   UNKNOWN
      0  1a84					      ENDIO
      0  1a84					      db	71
      1  1a84		       47		      .byte.b	71
      0  1a85					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1a85					      db	13
      1  1a85		       0d		      .byte.b	13
      0  1a86					      dw	ERR_SYNTAX
      1  1a86		       05 00		      .word.w	ERR_SYNTAX
    364  1a88
    365  1a88							;-----------------------------------------------------
    366  1a88				   EXPR
      0  1a88					      TST	EXPRNOT,"NOT"
      0  1a88					      db	32
      1  1a88		       20		      .byte.b	32
      0  1a89					      db	(EXPRNOT-*)-1
      1  1a89		       09		      .byte.b	(EXPRNOT-*)-1
      0  1a8a					      db	"NOT",0
      1  1a8a		       4e 4f 54 00	      .byte.b	"NOT",0
      0  1a8e					      Call	EXPR
      0  1a8e					      db	28
      1  1a8e		       1c		      .byte.b	28
      0  1a8f					      dw	EXPR
      1  1a8f		       88 1a		      .word.w	EXPR
      0  1a91					      LOGNOT
      0  1a91					      db	72
      1  1a91		       48		      .byte.b	72
      0  1a92					      RTN
      0  1a92					      db	25
      1  1a92		       19		      .byte.b	25
    371  1a93				   EXPRNOT
    372  1a93
    373  1a93				   EXPRLOGS
      0  1a93					      Call	EXPRCMP
      0  1a93					      db	28
      1  1a93		       1c		      .byte.b	28
      0  1a94					      dw	EXPRCMP
      1  1a94		       b7 1a		      .word.w	EXPRCMP
      0  1a96					      TST	iLOG1,"AND"
      0  1a96					      db	32
      1  1a96		       20		      .byte.b	32
      0  1a97					      db	(iLOG1-*)-1
      1  1a97		       09		      .byte.b	(iLOG1-*)-1
      0  1a98					      db	"AND",0
      1  1a98		       41 4e 44 00	      .byte.b	"AND",0
      0  1a9c					      Call	EXPR
      0  1a9c					      db	28
      1  1a9c		       1c		      .byte.b	28
      0  1a9d					      dw	EXPR
      1  1a9d		       88 1a		      .word.w	EXPR
      0  1a9f					      LOGAND
      0  1a9f					      db	74
      1  1a9f		       4a		      .byte.b	74
      0  1aa0					      RTN
      0  1aa0					      db	25
      1  1aa0		       19		      .byte.b	25
    379  1aa1				   iLOG1
      0  1aa1					      TST	iLOG2,"OR"
      0  1aa1					      db	32
      1  1aa1		       20		      .byte.b	32
      0  1aa2					      db	(iLOG2-*)-1
      1  1aa2		       08		      .byte.b	(iLOG2-*)-1
      0  1aa3					      db	"OR",0
      1  1aa3		       4f 52 00 	      .byte.b	"OR",0
      0  1aa6					      Call	EXPR
      0  1aa6					      db	28
      1  1aa6		       1c		      .byte.b	28
      0  1aa7					      dw	EXPR
      1  1aa7		       88 1a		      .word.w	EXPR
      0  1aa9					      LOGOR
      0  1aa9					      db	73
      1  1aa9		       49		      .byte.b	73
      0  1aaa					      RTN
      0  1aaa					      db	25
      1  1aaa		       19		      .byte.b	25
    384  1aab				   iLOG2
      0  1aab					      TST	iLOG3,"XOR"
      0  1aab					      db	32
      1  1aab		       20		      .byte.b	32
      0  1aac					      db	(iLOG3-*)-1
      1  1aac		       09		      .byte.b	(iLOG3-*)-1
      0  1aad					      db	"XOR",0
      1  1aad		       58 4f 52 00	      .byte.b	"XOR",0
      0  1ab1					      Call	EXPR
      0  1ab1					      db	28
      1  1ab1		       1c		      .byte.b	28
      0  1ab2					      dw	EXPR
      1  1ab2		       88 1a		      .word.w	EXPR
      0  1ab4					      LOGXOR
      0  1ab4					      db	75
      1  1ab4		       4b		      .byte.b	75
      0  1ab5					      RTN
      0  1ab5					      db	25
      1  1ab5		       19		      .byte.b	25
    389  1ab6				   iLOG3
      0  1ab6					      RTN
      0  1ab6					      db	25
      1  1ab6		       19		      .byte.b	25
    391  1ab7
    392  1ab7				   EXPRCMP
      0  1ab7					      Call	EXPR2	; get the first expression
      0  1ab7					      db	28
      1  1ab7		       1c		      .byte.b	28
      0  1ab8					      dw	EXPR2
      1  1ab8		       02 1b		      .word.w	EXPR2
      0  1aba					      TST	iR0,"="
      0  1aba					      db	32
      1  1aba		       20		      .byte.b	32
      0  1abb					      db	(iR0-*)-1
      1  1abb		       08		      .byte.b	(iR0-*)-1
      0  1abc					      db	"=",0
      1  1abc		       3d 00		      .byte.b	"=",0
      0  1abe					      LIT	2	;=
      0  1abe					      db	27
      1  1abe		       1b		      .byte.b	27
      0  1abf					      dw	2
      1  1abf		       02 00		      .word.w	2
      0  1ac1					      IJMP	iRFound
      0  1ac1					      db	29
      1  1ac1		       1d		      .byte.b	29
      0  1ac2					      dw	iRFound
      1  1ac2		       fd 1a		      .word.w	iRFound
    397  1ac4				   iR0
      0  1ac4					      TST	iR4,"<"
      0  1ac4					      db	32
      1  1ac4		       20		      .byte.b	32
      0  1ac5					      db	(iR4-*)-1
      1  1ac5		       1c		      .byte.b	(iR4-*)-1
      0  1ac6					      db	"<",0
      1  1ac6		       3c 00		      .byte.b	"<",0
      0  1ac8					      TST	iR1,"="
      0  1ac8					      db	32
      1  1ac8		       20		      .byte.b	32
      0  1ac9					      db	(iR1-*)-1
      1  1ac9		       08		      .byte.b	(iR1-*)-1
      0  1aca					      db	"=",0
      1  1aca		       3d 00		      .byte.b	"=",0
      0  1acc					      LIT	3	;<=
      0  1acc					      db	27
      1  1acc		       1b		      .byte.b	27
      0  1acd					      dw	3
      1  1acd		       03 00		      .word.w	3
      0  1acf					      IJMP	iRFound
      0  1acf					      db	29
      1  1acf		       1d		      .byte.b	29
      0  1ad0					      dw	iRFound
      1  1ad0		       fd 1a		      .word.w	iRFound
    402  1ad2				   iR1
      0  1ad2					      TST	iR3,">"
      0  1ad2					      db	32
      1  1ad2		       20		      .byte.b	32
      0  1ad3					      db	(iR3-*)-1
      1  1ad3		       08		      .byte.b	(iR3-*)-1
      0  1ad4					      db	">",0
      1  1ad4		       3e 00		      .byte.b	">",0
      0  1ad6					      LIT	5	;<>
      0  1ad6					      db	27
      1  1ad6		       1b		      .byte.b	27
      0  1ad7					      dw	5
      1  1ad7		       05 00		      .word.w	5
      0  1ad9					      IJMP	iRFound
      0  1ad9					      db	29
      1  1ad9		       1d		      .byte.b	29
      0  1ada					      dw	iRFound
      1  1ada		       fd 1a		      .word.w	iRFound
    406  1adc				   iR3
      0  1adc					      LIT	1	;<
      0  1adc					      db	27
      1  1adc		       1b		      .byte.b	27
      0  1add					      dw	1
      1  1add		       01 00		      .word.w	1
      0  1adf					      IJMP	iRFound
      0  1adf					      db	29
      1  1adf		       1d		      .byte.b	29
      0  1ae0					      dw	iRFound
      1  1ae0		       fd 1a		      .word.w	iRFound
    409  1ae2				   iR4
      0  1ae2					      TST	iRDone,">"
      0  1ae2					      db	32
      1  1ae2		       20		      .byte.b	32
      0  1ae3					      db	(iRDone-*)-1
      1  1ae3		       1d		      .byte.b	(iRDone-*)-1
      0  1ae4					      db	">",0
      1  1ae4		       3e 00		      .byte.b	">",0
      0  1ae6					      TST	iR5,"="
      0  1ae6					      db	32
      1  1ae6		       20		      .byte.b	32
      0  1ae7					      db	(iR5-*)-1
      1  1ae7		       08		      .byte.b	(iR5-*)-1
      0  1ae8					      db	"=",0
      1  1ae8		       3d 00		      .byte.b	"=",0
      0  1aea					      LIT	6	;>=
      0  1aea					      db	27
      1  1aea		       1b		      .byte.b	27
      0  1aeb					      dw	6
      1  1aeb		       06 00		      .word.w	6
      0  1aed					      IJMP	iRFound
      0  1aed					      db	29
      1  1aed		       1d		      .byte.b	29
      0  1aee					      dw	iRFound
      1  1aee		       fd 1a		      .word.w	iRFound
    414  1af0				   iR5
      0  1af0					      TST	iR6,"<"
      0  1af0					      db	32
      1  1af0		       20		      .byte.b	32
      0  1af1					      db	(iR6-*)-1
      1  1af1		       08		      .byte.b	(iR6-*)-1
      0  1af2					      db	"<",0
      1  1af2		       3c 00		      .byte.b	"<",0
      0  1af4					      LIT	1
      0  1af4					      db	27
      1  1af4		       1b		      .byte.b	27
      0  1af5					      dw	1
      1  1af5		       01 00		      .word.w	1
      0  1af7					      IJMP	iRFound	;(This line originally omitted)
      0  1af7					      db	29
      1  1af7		       1d		      .byte.b	29
      0  1af8					      dw	iRFound
      1  1af8		       fd 1a		      .word.w	iRFound
    418  1afa				   iR6
      0  1afa					      LIT	4	;>
      0  1afa					      db	27
      1  1afa		       1b		      .byte.b	27
      0  1afb					      dw	4
      1  1afb		       04 00		      .word.w	4
    420  1afd				   iRFound
      0  1afd					      Call	EXPR2	; get the right side of the expression
      0  1afd					      db	28
      1  1afd		       1c		      .byte.b	28
      0  1afe					      dw	EXPR2
      1  1afe		       02 1b		      .word.w	EXPR2
      0  1b00					      CMPR		; Push the value of the true false onto the stack
      0  1b00					      db	10
      1  1b00		       0a		      .byte.b	10
    423  1b01
    424  1b01				   iRDone
      0  1b01					      RTN
      0  1b01					      db	25
      1  1b01		       19		      .byte.b	25
    426  1b02
    427  1b02				   EXPR2
      0  1b02					      TST	E0,"-"	; Look for leading - to negate term
      0  1b02					      db	32
      1  1b02		       20		      .byte.b	32
      0  1b03					      db	(E0-*)-1
      1  1b03		       09		      .byte.b	(E0-*)-1
      0  1b04					      db	"-",0
      1  1b04		       2d 00		      .byte.b	"-",0
      0  1b06					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1b06					      db	28
      1  1b06		       1c		      .byte.b	28
      0  1b07					      dw	TERM
      1  1b07		       2b 1b		      .word.w	TERM
      0  1b09					      NEG		; Make value negated
      0  1b09					      db	16
      1  1b09		       10		      .byte.b	16
      0  1b0a					      IJMP	E1	; We have Left term process operators next
      0  1b0a					      db	29
      1  1b0a		       1d		      .byte.b	29
      0  1b0b					      dw	E1
      1  1b0b		       14 1b		      .word.w	E1
    432  1b0d				   E0
      0  1b0d					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1b0d					      db	32
      1  1b0d		       20		      .byte.b	32
      0  1b0e					      db	(E1A-*)-1
      1  1b0e		       02		      .byte.b	(E1A-*)-1
      0  1b0f					      db	"+",0
      1  1b0f		       2b 00		      .byte.b	"+",0
    434  1b11				   E1A
      0  1b11					      CALL	TERM	; Get the left term if it was not negated
      0  1b11					      db	28
      1  1b11		       1c		      .byte.b	28
      0  1b12					      dw	TERM
      1  1b12		       2b 1b		      .word.w	TERM
    436  1b14				   E1
      0  1b14					      TST	E2,"+"	; Check if we are adding left term to something
      0  1b14					      db	32
      1  1b14		       20		      .byte.b	32
      0  1b15					      db	(E2-*)-1
      1  1b15		       09		      .byte.b	(E2-*)-1
      0  1b16					      db	"+",0
      1  1b16		       2b 00		      .byte.b	"+",0
      0  1b18					      CALL	TERM	; if adding then get the right side term
      0  1b18					      db	28
      1  1b18		       1c		      .byte.b	28
      0  1b19					      dw	TERM
      1  1b19		       2b 1b		      .word.w	TERM
      0  1b1b					      ADD		; Add it to left term
      0  1b1b					      db	14
      1  1b1b		       0e		      .byte.b	14
      0  1b1c					      IJMP	E1	; look for next + or -
      0  1b1c					      db	29
      1  1b1c		       1d		      .byte.b	29
      0  1b1d					      dw	E1
      1  1b1d		       14 1b		      .word.w	E1
    441  1b1f				   E2
      0  1b1f					      TST	E3,"-"	; Check if we are subtractig something
      0  1b1f					      db	32
      1  1b1f		       20		      .byte.b	32
      0  1b20					      db	(E3-*)-1
      1  1b20		       09		      .byte.b	(E3-*)-1
      0  1b21					      db	"-",0
      1  1b21		       2d 00		      .byte.b	"-",0
      0  1b23					      CALL	TERM	; get right side to subtract Diffrence
      0  1b23					      db	28
      1  1b23		       1c		      .byte.b	28
      0  1b24					      dw	TERM
      1  1b24		       2b 1b		      .word.w	TERM
      0  1b26					      SUB		; Subtract the value
      0  1b26					      db	15
      1  1b26		       0f		      .byte.b	15
      0  1b27					      IJMP	E1	; Look for next + or -
      0  1b27					      db	29
      1  1b27		       1d		      .byte.b	29
      0  1b28					      dw	E1
      1  1b28		       14 1b		      .word.w	E1
    446  1b2a				   E3			; Finish processing the expression
      0  1b2a					      RTN		; We are finished processing the Expression
      0  1b2a					      db	25
      1  1b2a		       19		      .byte.b	25
    448  1b2b							;
    449  1b2b							; Get one of the terms of an expression
    450  1b2b							;
    451  1b2b				   TERM
      0  1b2b					      CALL	FACT	; Get a value
      0  1b2b					      db	28
      1  1b2b		       1c		      .byte.b	28
      0  1b2c					      dw	FACT
      1  1b2c		       53 1b		      .word.w	FACT
    453  1b2e				   T0			; Check for higher precidence operators
      0  1b2e					      TST	T1,"*"	; Check for *
      0  1b2e					      db	32
      1  1b2e		       20		      .byte.b	32
      0  1b2f					      db	(T1-*)-1
      1  1b2f		       09		      .byte.b	(T1-*)-1
      0  1b30					      db	"*",0
      1  1b30		       2a 00		      .byte.b	"*",0
      0  1b32					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1b32					      db	28
      1  1b32		       1c		      .byte.b	28
      0  1b33					      dw	FACT
      1  1b33		       53 1b		      .word.w	FACT
      0  1b35					      MUL		; Multiply factors
      0  1b35					      db	17
      1  1b35		       11		      .byte.b	17
      0  1b36					      IJMP	T0	; Check for * or /
      0  1b36					      db	29
      1  1b36		       1d		      .byte.b	29
      0  1b37					      dw	T0
      1  1b37		       2e 1b		      .word.w	T0
    458  1b39				   T1
      0  1b39					      TST	T2,"/"	; Check for a division
      0  1b39					      db	32
      1  1b39		       20		      .byte.b	32
      0  1b3a					      db	(T2-*)-1
      1  1b3a		       09		      .byte.b	(T2-*)-1
      0  1b3b					      db	"/",0
      1  1b3b		       2f 00		      .byte.b	"/",0
      0  1b3d					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1b3d					      db	28
      1  1b3d		       1c		      .byte.b	28
      0  1b3e					      dw	FACT
      1  1b3e		       53 1b		      .word.w	FACT
      0  1b40					      DIV		; do division
      0  1b40					      db	18
      1  1b40		       12		      .byte.b	18
      0  1b41					      IJMP	T0	; check for more * or /
      0  1b41					      db	29
      1  1b41		       1d		      .byte.b	29
      0  1b42					      dw	T0
      1  1b42		       2e 1b		      .word.w	T0
    463  1b44				   T2
      0  1b44					      TST	T3,"%"	; Check for a division
      0  1b44					      db	32
      1  1b44		       20		      .byte.b	32
      0  1b45					      db	(T3-*)-1
      1  1b45		       09		      .byte.b	(T3-*)-1
      0  1b46					      db	"%",0
      1  1b46		       25 00		      .byte.b	"%",0
      0  1b48					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1b48					      db	28
      1  1b48		       1c		      .byte.b	28
      0  1b49					      dw	FACT
      1  1b49		       53 1b		      .word.w	FACT
      0  1b4b					      MODULO		; do division for remainder
      0  1b4b					      db	60
      1  1b4b		       3c		      .byte.b	60
      0  1b4c					      IJMP	T0	; check for more * or / or %
      0  1b4c					      db	29
      1  1b4c		       1d		      .byte.b	29
      0  1b4d					      dw	T0
      1  1b4d		       2e 1b		      .word.w	T0
    468  1b4f				   T3			; Finish processing the Term
      0  1b4f					      RTN
      0  1b4f					      db	25
      1  1b4f		       19		      .byte.b	25
    470  1b50
    471  1b50				   UNKNOWNVEC
      0  1b50					      IJMP	UNKNOWN
      0  1b50					      db	29
      1  1b50		       1d		      .byte.b	29
      0  1b51					      dw	UNKNOWN
      1  1b51		       84 1a		      .word.w	UNKNOWN
    473  1b53
    474  1b53							;
    475  1b53							; Factor an expression.  Always test for functions
    476  1b53							; first or else they'll be confused for variables.
    477  1b53							;
    478  1b53				   FACT
      0  1b53					      TST	F1AA,"TRUE"
      0  1b53					      db	32
      1  1b53		       20		      .byte.b	32
      0  1b54					      db	(F1AA-*)-1
      1  1b54		       09		      .byte.b	(F1AA-*)-1
      0  1b55					      db	"TRUE",0
      1  1b55		       54 52 55 45*	      .byte.b	"TRUE",0
      0  1b5a					      LIT	-1
      0  1b5a					      db	27
      1  1b5a		       1b		      .byte.b	27
      0  1b5b					      dw	-1
      1  1b5b		       ff ff		      .word.w	-1
      0  1b5d					      RTN
      0  1b5d					      db	25
      1  1b5d		       19		      .byte.b	25
    482  1b5e				   F1AA
      0  1b5e					      TST	F1AB,"FALSE"
      0  1b5e					      db	32
      1  1b5e		       20		      .byte.b	32
      0  1b5f					      db	(F1AB-*)-1
      1  1b5f		       0a		      .byte.b	(F1AB-*)-1
      0  1b60					      db	"FALSE",0
      1  1b60		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1b66					      LIT	0
      0  1b66					      db	27
      1  1b66		       1b		      .byte.b	27
      0  1b67					      dw	0
      1  1b67		       00 00		      .word.w	0
      0  1b69					      RTN
      0  1b69					      db	25
      1  1b69		       19		      .byte.b	25
    486  1b6a				   F1AB
      0  1b6a					      TST	F1A,"FREE()"
      0  1b6a					      db	32
      1  1b6a		       20		      .byte.b	32
      0  1b6b					      db	(F1A-*)-1
      1  1b6b		       09		      .byte.b	(F1A-*)-1
      0  1b6c					      db	"FREE()",0
      1  1b6c		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1b73					      FREE
      0  1b73					      db	36
      1  1b73		       24		      .byte.b	36
      0  1b74					      RTN
      0  1b74					      db	25
      1  1b74		       19		      .byte.b	25
    490  1b75				   F1A
      0  1b75					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1b75					      db	32
      1  1b75		       20		      .byte.b	32
      0  1b76					      db	(F1A2-*)-1
      1  1b76		       0a		      .byte.b	(F1A2-*)-1
      0  1b77					      db	"GETCH()",0
      1  1b77		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1b7f					      GETCHAR
      0  1b7f					      db	51
      1  1b7f		       33		      .byte.b	51
      0  1b80					      RTN
      0  1b80					      db	25
      1  1b80		       19		      .byte.b	25
    494  1b81				   F1A2
      0  1b81					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1b81					      db	32
      1  1b81		       20		      .byte.b	32
      0  1b82					      db	(F2AZ-*)-1
      1  1b82		       0f		      .byte.b	(F2AZ-*)-1
      0  1b83					      db	"PEEK(",0
      1  1b83		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1b89					      CALL	EXPR	;Get the address to write to
      0  1b89					      db	28
      1  1b89		       1c		      .byte.b	28
      0  1b8a					      dw	EXPR
      1  1b8a		       88 1a		      .word.w	EXPR
      0  1b8c					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  1b8c					      db	32
      1  1b8c		       20		      .byte.b	32
      0  1b8d					      db	(UNKNOWNVEC-*)-1
      1  1b8d		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  1b8e					      db	")",0
      1  1b8e		       29 00		      .byte.b	")",0
      0  1b90					      PEEKMEM
      0  1b90					      db	48
      1  1b90		       30		      .byte.b	48
      0  1b91					      RTN
      0  1b91					      db	25
      1  1b91		       19		      .byte.b	25
    500  1b92				   F2AZ
      0  1b92					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  1b92					      db	32
      1  1b92		       20		      .byte.b	32
      0  1b93					      db	(F2AZ1-*)-1
      1  1b93		       22		      .byte.b	(F2AZ1-*)-1
      0  1b94					      db	"TASK(",0
      1  1b94		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1b9a					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1b9a					      db	28
      1  1b9a		       1c		      .byte.b	28
      0  1b9b					      dw	EXPR
      1  1b9b		       88 1a		      .word.w	EXPR
      0  1b9d					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  1b9d					      db	61
      1  1b9d		       3d		      .byte.b	61
      0  1b9e					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  1b9e					      db	32
      1  1b9e		       20		      .byte.b	32
      0  1b9f					      db	(F2AZNoParms-*)-1
      1  1b9f		       10		      .byte.b	(F2AZNoParms-*)-1
      0  1ba0					      db	COMMA,0
      1  1ba0		       2c 00		      .byte.b	COMMA,0
      0  1ba2					      SAVEMATHSTACK		;Push The mathstack
      0  1ba2					      db	86
      1  1ba2		       56		      .byte.b	86
      0  1ba3					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  1ba3					      db	89
      1  1ba3		       59		      .byte.b	89
    507  1ba4				   F2AZLOOP
      0  1ba4					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  1ba4					      db	28
      1  1ba4		       1c		      .byte.b	28
      0  1ba5					      dw	EXPR
      1  1ba5		       88 1a		      .word.w	EXPR
      0  1ba7					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  1ba7					      db	32
      1  1ba7		       20		      .byte.b	32
      0  1ba8					      db	(F2AZEndParm-*)-1
      1  1ba8		       05		      .byte.b	(F2AZEndParm-*)-1
      0  1ba9					      db	COMMA,0
      1  1ba9		       2c 00		      .byte.b	COMMA,0
      0  1bab					      IJMP	F2AZLOOP	;check for more
      0  1bab					      db	29
      1  1bab		       1d		      .byte.b	29
      0  1bac					      dw	F2AZLOOP
      1  1bac		       a4 1b		      .word.w	F2AZLOOP
    511  1bae				   F2AZEndParm
      0  1bae					      RESTOREMATHSTACK		;Back to normal stack
      0  1bae					      db	87
      1  1bae		       57		      .byte.b	87
      0  1baf					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  1baf					      db	92
      1  1baf		       5c		      .byte.b	92
    514  1bb0				   F2AZNoParms
      0  1bb0					      TST	UNKNOWNVEC,")"	;must be )
      0  1bb0					      db	32
      1  1bb0		       20		      .byte.b	32
      0  1bb1					      db	(UNKNOWNVEC-*)-1
      1  1bb1		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bb2					      db	")",0
      1  1bb2		       29 00		      .byte.b	")",0
      0  1bb4					      TASKENABLE		;Enable the task to execute
      0  1bb4					      db	90
      1  1bb4		       5a		      .byte.b	90
      0  1bb5					      RTN		;Returns the Task number
      0  1bb5					      db	25
      1  1bb5		       19		      .byte.b	25
    518  1bb6				   F2AZ1
      0  1bb6					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  1bb6					      db	32
      1  1bb6		       20		      .byte.b	32
      0  1bb7					      db	(F2A-*)-1
      1  1bb7		       3c		      .byte.b	(F2A-*)-1
      0  1bb8					      db	"IPC",0
      1  1bb8		       49 50 43 00	      .byte.b	"IPC",0
      0  1bbc					      TST	F2AZa,"S("	;IPCS - send a message
      0  1bbc					      db	32
      1  1bbc		       20		      .byte.b	32
      0  1bbd					      db	(F2AZa-*)-1
      1  1bbd		       13		      .byte.b	(F2AZa-*)-1
      0  1bbe					      db	"S(",0
      1  1bbe		       53 28 00 	      .byte.b	"S(",0
      0  1bc1					      CALL	EXPR	;Get the message value
      0  1bc1					      db	28
      1  1bc1		       1c		      .byte.b	28
      0  1bc2					      dw	EXPR
      1  1bc2		       88 1a		      .word.w	EXPR
      0  1bc4					      TST	UNKNOWNVEC,COMMA
      0  1bc4					      db	32
      1  1bc4		       20		      .byte.b	32
      0  1bc5					      db	(UNKNOWNVEC-*)-1
      1  1bc5		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bc6					      db	COMMA,0
      1  1bc6		       2c 00		      .byte.b	COMMA,0
      0  1bc8					      CALL	EXPR	;Get pid of task to send to
      0  1bc8					      db	28
      1  1bc8		       1c		      .byte.b	28
      0  1bc9					      dw	EXPR
      1  1bc9		       88 1a		      .word.w	EXPR
      0  1bcb					      TST	UNKNOWNVEC,")"
      0  1bcb					      db	32
      1  1bcb		       20		      .byte.b	32
      0  1bcc					      db	(UNKNOWNVEC-*)-1
      1  1bcc		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bcd					      db	")",0
      1  1bcd		       29 00		      .byte.b	")",0
      0  1bcf					      IPCSEND		;Send msg and clear pid msg pending
      0  1bcf					      db	80
      1  1bcf		       50		      .byte.b	80
      0  1bd0					      RTN
      0  1bd0					      db	25
      1  1bd0		       19		      .byte.b	25
    527  1bd1				   F2AZa
      0  1bd1					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  1bd1					      db	32
      1  1bd1		       20		      .byte.b	32
      0  1bd2					      db	(F2AZb-*)-1
      1  1bd2		       16		      .byte.b	(F2AZb-*)-1
      0  1bd3					      db	"R(",0
      1  1bd3		       52 28 00 	      .byte.b	"R(",0
      0  1bd6					      TST	F2AZa1,")"
      0  1bd6					      db	32
      1  1bd6		       20		      .byte.b	32
      0  1bd7					      db	(F2AZa1-*)-1
      1  1bd7		       08		      .byte.b	(F2AZa1-*)-1
      0  1bd8					      db	")",0
      1  1bd8		       29 00		      .byte.b	")",0
      0  1bda					      LIT	0	;We dont want the pid returned to us
      0  1bda					      db	27
      1  1bda		       1b		      .byte.b	27
      0  1bdb					      dw	0
      1  1bdb		       00 00		      .word.w	0
      0  1bdd					      IPCIO		;Set the io bit and suspend the task till message
      0  1bdd					      db	83
      1  1bdd		       53		      .byte.b	83
      0  1bde					      IPCRECEIVE		;Get the message
      0  1bde					      db	81
      1  1bde		       51		      .byte.b	81
      0  1bdf					      RTN
      0  1bdf					      db	25
      1  1bdf		       19		      .byte.b	25
    534  1be0				   F2AZa1
      0  1be0					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  1be0					      db	33
      1  1be0		       21		      .byte.b	33
      0  1be1					      db	(UNKNOWNVEC-*)-1
      1  1be1		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1be2					      TST	UNKNOWNVEC,")"
      0  1be2					      db	32
      1  1be2		       20		      .byte.b	32
      0  1be3					      db	(UNKNOWNVEC-*)-1
      1  1be3		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  1be4					      db	")",0
      1  1be4		       29 00		      .byte.b	")",0
      0  1be6					      IPCIO		;Set the io bit and exit task till message
      0  1be6					      db	83
      1  1be6		       53		      .byte.b	83
      0  1be7					      IPCRECEIVE		;Get the message
      0  1be7					      db	81
      1  1be7		       51		      .byte.b	81
      0  1be8					      RTN
      0  1be8					      db	25
      1  1be8		       19		      .byte.b	25
    540  1be9				   F2AZb
      0  1be9					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  1be9					      db	32
      1  1be9		       20		      .byte.b	32
      0  1bea					      db	(UNKNOWNVEC-*)-1
      1  1bea		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1beb					      db	"C()",0
      1  1beb		       43 28 29 00	      .byte.b	"C()",0
      0  1bef					      IPCCHECK
      0  1bef					      db	82
      1  1bef		       52		      .byte.b	82
      0  1bf0					      RTN
      0  1bf0					      db	25
      1  1bf0		       19		      .byte.b	25
    544  1bf1
    545  1bf1				   UNKNOWNID
      0  1bf1					      IJMP	UNKNOWN
      0  1bf1					      db	29
      1  1bf1		       1d		      .byte.b	29
      0  1bf2					      dw	UNKNOWN
      1  1bf2		       84 1a		      .word.w	UNKNOWN
    547  1bf4							;
    548  1bf4							; RND() is supposed to have an argument but if none
    549  1bf4							; was provided, just assume a large value.
    550  1bf4							;
    551  1bf4				   F2A
      0  1bf4					      TST	F2B,"RND("
      0  1bf4					      db	32
      1  1bf4		       20		      .byte.b	32
      0  1bf5					      db	(F2B-*)-1
      1  1bf5		       17		      .byte.b	(F2B-*)-1
      0  1bf6					      db	"RND(",0
      1  1bf6		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1bfb					      TST	F2A1,")"
      0  1bfb					      db	32
      1  1bfb		       20		      .byte.b	32
      0  1bfc					      db	(F2A1-*)-1
      1  1bfc		       07		      .byte.b	(F2A1-*)-1
      0  1bfd					      db	")",0
      1  1bfd		       29 00		      .byte.b	")",0
      0  1bff					      LIT	32766
      0  1bff					      db	27
      1  1bff		       1b		      .byte.b	27
      0  1c00					      dw	32766
      1  1c00		       fe 7f		      .word.w	32766
      0  1c02					      RANDOM
      0  1c02					      db	37
      1  1c02		       25		      .byte.b	37
      0  1c03					      RTN
      0  1c03					      db	25
      1  1c03		       19		      .byte.b	25
    557  1c04
    558  1c04				   F2A1
      0  1c04					      CALL	FACT	;GET RANGE
      0  1c04					      db	28
      1  1c04		       1c		      .byte.b	28
      0  1c05					      dw	FACT
      1  1c05		       53 1b		      .word.w	FACT
      0  1c07					      TST	UNKNOWNVEC,")"
      0  1c07					      db	32
      1  1c07		       20		      .byte.b	32
      0  1c08					      db	(UNKNOWNVEC-*)-1
      1  1c08		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c09					      db	")",0
      1  1c09		       29 00		      .byte.b	")",0
      0  1c0b					      RANDOM
      0  1c0b					      db	37
      1  1c0b		       25		      .byte.b	37
      0  1c0c					      RTN
      0  1c0c					      db	25
      1  1c0c		       19		      .byte.b	25
    563  1c0d
    564  1c0d				   F2B
      0  1c0d					      TST	F2B2,"ABS("
      0  1c0d					      db	32
      1  1c0d		       20		      .byte.b	32
      0  1c0e					      db	(F2B2-*)-1
      1  1c0e		       0e		      .byte.b	(F2B2-*)-1
      0  1c0f					      db	"ABS(",0
      1  1c0f		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1c14					      CALL	EXPR	;get value
      0  1c14					      db	28
      1  1c14		       1c		      .byte.b	28
      0  1c15					      dw	EXPR
      1  1c15		       88 1a		      .word.w	EXPR
      0  1c17					      TST	UNKNOWNVEC,")"
      0  1c17					      db	32
      1  1c17		       20		      .byte.b	32
      0  1c18					      db	(UNKNOWNVEC-*)-1
      1  1c18		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c19					      db	")",0
      1  1c19		       29 00		      .byte.b	")",0
      0  1c1b					      ABS
      0  1c1b					      db	38
      1  1c1b		       26		      .byte.b	38
      0  1c1c					      RTN
      0  1c1c					      db	25
      1  1c1c		       19		      .byte.b	25
    570  1c1d
    571  1c1d				   F2B2
      0  1c1d					      TST	F2Z,"STAT("
      0  1c1d					      db	32
      1  1c1d		       20		      .byte.b	32
      0  1c1e					      db	(F2Z-*)-1
      1  1c1e		       0f		      .byte.b	(F2Z-*)-1
      0  1c1f					      db	"STAT(",0
      1  1c1f		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1c25					      Call	EXPR
      0  1c25					      db	28
      1  1c25		       1c		      .byte.b	28
      0  1c26					      dw	EXPR
      1  1c26		       88 1a		      .word.w	EXPR
      0  1c28					      TST	UNKNOWNVEC,")"
      0  1c28					      db	32
      1  1c28		       20		      .byte.b	32
      0  1c29					      db	(UNKNOWNVEC-*)-1
      1  1c29		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c2a					      db	")",0
      1  1c2a		       29 00		      .byte.b	")",0
      0  1c2c					      TASKSTAT
      0  1c2c					      db	66
      1  1c2c		       42		      .byte.b	66
      0  1c2d					      RTN
      0  1c2d					      db	25
      1  1c2d		       19		      .byte.b	25
    577  1c2e				   F2Z
      0  1c2e					      TST	F2ZA,"PID"
      0  1c2e					      db	32
      1  1c2e		       20		      .byte.b	32
      0  1c2f					      db	(F2ZA-*)-1
      1  1c2f		       06		      .byte.b	(F2ZA-*)-1
      0  1c30					      db	"PID",0
      1  1c30		       50 49 44 00	      .byte.b	"PID",0
      0  1c34					      TASKPID
      0  1c34					      db	77
      1  1c34		       4d		      .byte.b	77
      0  1c35					      RTN
      0  1c35					      db	25
      1  1c35		       19		      .byte.b	25
    581  1c36				   F2ZA
      0  1c36					      TST	F2FUNC,"CALL("	;call machine function
      0  1c36					      db	32
      1  1c36		       20		      .byte.b	32
      0  1c37					      db	(F2FUNC-*)-1
      1  1c37		       1f		      .byte.b	(F2FUNC-*)-1
      0  1c38					      db	"CALL(",0
      1  1c38		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1c3e					      CALL	EXPR
      0  1c3e					      db	28
      1  1c3e		       1c		      .byte.b	28
      0  1c3f					      dw	EXPR
      1  1c3f		       88 1a		      .word.w	EXPR
      0  1c41					      TST	F2B2A,COMMA
      0  1c41					      db	32
      1  1c41		       20		      .byte.b	32
      0  1c42					      db	(F2B2A-*)-1
      1  1c42		       0b		      .byte.b	(F2B2A-*)-1
      0  1c43					      db	COMMA,0
      1  1c43		       2c 00		      .byte.b	COMMA,0
      0  1c45					      CALL	EXPR
      0  1c45					      db	28
      1  1c45		       1c		      .byte.b	28
      0  1c46					      dw	EXPR
      1  1c46		       88 1a		      .word.w	EXPR
      0  1c48					      TST	UNKNOWNVEC,")"
      0  1c48					      db	32
      1  1c48		       20		      .byte.b	32
      0  1c49					      db	(UNKNOWNVEC-*)-1
      1  1c49		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c4a					      db	")",0
      1  1c4a		       29 00		      .byte.b	")",0
      0  1c4c					      CALLFUNC
      0  1c4c					      db	53
      1  1c4c		       35		      .byte.b	53
      0  1c4d					      RTN
      0  1c4d					      db	25
      1  1c4d		       19		      .byte.b	25
    589  1c4e							; Run the gosub within this function
    590  1c4e				   F2B2A
      0  1c4e					      TST	UNKNOWNID,")"
      0  1c4e					      db	32
      1  1c4e		       20		      .byte.b	32
      0  1c4f					      db	(UNKNOWNID-*)-1
      1  1c4f		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  1c50					      db	")",0
      1  1c50		       29 00		      .byte.b	")",0
      0  1c52					      LIT	0
      0  1c52					      db	27
      1  1c52		       1b		      .byte.b	27
      0  1c53					      dw	0
      1  1c53		       00 00		      .word.w	0
      0  1c55					      CALLFUNC
      0  1c55					      db	53
      1  1c55		       35		      .byte.b	53
      0  1c56					      RTN
      0  1c56					      db	25
      1  1c56		       19		      .byte.b	25
    595  1c57
      0  1c57				   F2FUNC     TST	F2C,"GOFN"
      0  1c57					      db	32
      1  1c57		       20		      .byte.b	32
      0  1c58					      db	(F2C-*)-1
      1  1c58		       0c		      .byte.b	(F2C-*)-1
      0  1c59					      db	"GOFN",0
      1  1c59		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  1c5e					      Call	GOSUBSTATEMENT
      0  1c5e					      db	28
      1  1c5e		       1c		      .byte.b	28
      0  1c5f					      dw	GOSUBSTATEMENT
      1  1c5f		       8e 1c		      .word.w	GOSUBSTATEMENT
      0  1c61					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  1c61					      db	8
      1  1c61		       08		      .byte.b	8
      0  1c62					      db	GOSUB_RTN_VALUE
      1  1c62		       81		      .byte.b	GOSUB_RTN_VALUE
      0  1c63					      XFER
      0  1c63					      db	7
      1  1c63		       07		      .byte.b	7
    600  1c64				   GOFNRet
      0  1c64					      RTN
      0  1c64					      db	25
      1  1c64		       19		      .byte.b	25
    602  1c65				   F2C
      0  1c65					      TSTV	F0
      0  1c65					      db	33
      1  1c65		       21		      .byte.b	33
      0  1c66					      db	(F0-*)-1
      1  1c66		       15		      .byte.b	(F0-*)-1
      0  1c67					      TST	F2CLocalTask,"!"
      0  1c67					      db	32
      1  1c67		       20		      .byte.b	32
      0  1c68					      db	(F2CLocalTask-*)-1
      1  1c68		       05		      .byte.b	(F2CLocalTask-*)-1
      0  1c69					      db	"!",0
      1  1c69		       21 00		      .byte.b	"!",0
      0  1c6b					      IND		; we just got a pid
      0  1c6b					      db	20
      1  1c6b		       14		      .byte.b	20
      0  1c6c					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  1c6c					      db	93
      1  1c6c		       5d		      .byte.b	93
      0  1c6d					      db	(UNKNOWNID-*)-1
      1  1c6d		       83		      .byte.b	(UNKNOWNID-*)-1
    607  1c6e
    608  1c6e				   F2CLocalTask
      0  1c6e					      TST	F2C1,"["
      0  1c6e					      db	32
      1  1c6e		       20		      .byte.b	32
      0  1c6f					      db	(F2C1-*)-1
      1  1c6f		       0a		      .byte.b	(F2C1-*)-1
      0  1c70					      db	"[",0
      1  1c70		       5b 00		      .byte.b	"[",0
      0  1c72					      CALL	EXPR
      0  1c72					      db	28
      1  1c72		       1c		      .byte.b	28
      0  1c73					      dw	EXPR
      1  1c73		       88 1a		      .word.w	EXPR
      0  1c75					      TST	UNKNOWNID,"]"
      0  1c75					      db	32
      1  1c75		       20		      .byte.b	32
      0  1c76					      db	(UNKNOWNID-*)-1
      1  1c76		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  1c77					      db	"]",0
      1  1c77		       5d 00		      .byte.b	"]",0
      0  1c79					      SUBSCRIPT
      0  1c79					      db	64
      1  1c79		       40		      .byte.b	64
    613  1c7a				   F2C1
      0  1c7a					      IND		;YES, GET THE VALUE.
      0  1c7a					      db	20
      1  1c7a		       14		      .byte.b	20
      0  1c7b					      RTN
      0  1c7b					      db	25
      1  1c7b		       19		      .byte.b	25
    616  1c7c				   F0
      0  1c7c					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1c7c					      db	35
      1  1c7c		       23		      .byte.b	35
      0  1c7d					      db	(F1-*)-1
      1  1c7d		       01		      .byte.b	(F1-*)-1
      0  1c7e					      RTN
      0  1c7e					      db	25
      1  1c7e		       19		      .byte.b	25
    619  1c7f				   F1
      0  1c7f					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  1c7f					      db	32
      1  1c7f		       20		      .byte.b	32
      0  1c80					      db	(F2RTN-*)-1
      1  1c80		       09		      .byte.b	(F2RTN-*)-1
      0  1c81					      db	"(",0
      1  1c81		       28 00		      .byte.b	"(",0
      0  1c83					      CALL	EXPR
      0  1c83					      db	28
      1  1c83		       1c		      .byte.b	28
      0  1c84					      dw	EXPR
      1  1c84		       88 1a		      .word.w	EXPR
      0  1c86					      TST	F2,")"
      0  1c86					      db	32
      1  1c86		       20		      .byte.b	32
      0  1c87					      db	(F2-*)-1
      1  1c87		       03		      .byte.b	(F2-*)-1
      0  1c88					      db	")",0
      1  1c88		       29 00		      .byte.b	")",0
    623  1c8a				   F2RTN
      0  1c8a					      RTN
      0  1c8a					      db	25
      1  1c8a		       19		      .byte.b	25
    625  1c8b
    626  1c8b				   F2
      0  1c8b					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1c8b					      db	13
      1  1c8b		       0d		      .byte.b	13
      0  1c8c					      dw	ERR_SYNTAX
      1  1c8c		       05 00		      .word.w	ERR_SYNTAX
    628  1c8e							;
    629  1c8e							;=============================================================
    630  1c8e							; Gosub can be both a Function and a Subroutine
    631  1c8e				   GOSUBSTATEMENT
      0  1c8e					      CALL	EXPR	;GET DESTINATION
      0  1c8e					      db	28
      1  1c8e		       1c		      .byte.b	28
      0  1c8f					      dw	EXPR
      1  1c8f		       88 1a		      .word.w	EXPR
      0  1c91					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  1c91					      db	32
      1  1c91		       20		      .byte.b	32
      0  1c92					      db	(GOSUBDONE-*)-1
      1  1c92		       14		      .byte.b	(GOSUBDONE-*)-1
      0  1c93					      db	"(",0
      1  1c93		       28 00		      .byte.b	"(",0
      0  1c95					      STK2TMP		;Transfer stack top to temp
      0  1c95					      db	95
      1  1c95		       5f		      .byte.b	95
      0  1c96					      PUSHMATHSTACK		;Record stack frame for return
      0  1c96					      db	84
      1  1c96		       54		      .byte.b	84
    636  1c97				   GOSUBLOOP
      0  1c97					      CALL	EXPR	; Allows what ever fits onto stack
      0  1c97					      db	28
      1  1c97		       1c		      .byte.b	28
      0  1c98					      dw	EXPR
      1  1c98		       88 1a		      .word.w	EXPR
      0  1c9a					      INCPARMCOUNT
      0  1c9a					      db	88
      1  1c9a		       58		      .byte.b	88
      0  1c9b					      TST	GOSUBParmDONE,COMMA
      0  1c9b					      db	32
      1  1c9b		       20		      .byte.b	32
      0  1c9c					      db	(GOSUBParmDONE-*)-1
      1  1c9c		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  1c9d					      db	COMMA,0
      1  1c9d		       2c 00		      .byte.b	COMMA,0
      0  1c9f					      IJMP	GOSUBLOOP
      0  1c9f					      db	29
      1  1c9f		       1d		      .byte.b	29
      0  1ca0					      dw	GOSUBLOOP
      1  1ca0		       97 1c		      .word.w	GOSUBLOOP
    641  1ca2				   GOSUBParmDONE
      0  1ca2					      TST	F2,")"
      0  1ca2					      db	32
      1  1ca2		       20		      .byte.b	32
      0  1ca3					      db	(F2-*)-1
      1  1ca3		       e7		      .byte.b	(F2-*)-1
      0  1ca4					      db	")",0
      1  1ca4		       29 00		      .byte.b	")",0
      0  1ca6					      TMP2STK		;Restore line to goto
      0  1ca6					      db	96
      1  1ca6		       60		      .byte.b	96
    644  1ca7				   GOSUBDONE
      0  1ca7					      RTN
      0  1ca7					      db	25
      1  1ca7		       19		      .byte.b	25
    646  1ca8
    647  1ca8		       1c a8	   ILEND      equ	*
------- FILE mytb.asm
   2169  1ca8		       1c a8	   PROGEND    equ	*
   2170  1ca8
   2171  1ca8
   2172  1ca8							;=====================================================
   2173  1ca8							; Define start of non page zero data
   2174 U1cb8					      seg.u	TBData
   2175 U1cb8
   2176 U1cb8							;=====================================================
   2177 U1cb8							; These are storage items not in page zero.
   2178 U1cb8							;
   2179 U1cb8							; IRQ BASIC Code Service RTN Support
      0 U1cb8				   SaveIrqReg db	0	; Store current setting
      1 U1cb8		       00		      .byte.b	0
      0 U1cb9				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1cb9		       00		      .byte.b	0
      0 U1cba				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1cba		       00		      .byte.b	0
      0 U1cbb				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1cbb		       00 00		      .byte.b	0,0
   2184 U1cbd
   2185 U1cbd							;
   2186 U1cbd							;==================================================================================================
   2187 U1cbd							; Task Management information
   2188 U1cbd							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2189 U1cbd							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2190 U1cbd							; Task switchs happen at the beginning of the next Basic command line
   2191 U1cbd							; It will not happen during an input or output operations
   2192 U1cbd							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2193 U1cbd							; Task Zero is always the root task, main line program
   2194 U1cbd							;
   2195 U1cbd							; Layout is repeated for each configured task
   2196 U1cbd							; Task Table Byte   use masks follow
   2197 U1cbd		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2198 U1cbd		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2199 U1cbd		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2200 U1cbd		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2201 U1cbd		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2202 U1cbd
   2203 U1cbd		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2204 U1cbe		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2205 U1cbe		       1d b8	   TASKTABLEEND equ	*	; End of task table
   2206 U1cbe		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2207 U1db8
   2208 U1db8							;Task Cycle Counter and reset count
   2209 U1db8		       00	   taskCurrentCycles ds	1
   2210 U1db9		       00	   taskResetValue ds	1
   2211 U1dba		       00	   taskCounter ds	1	; Count of active tasks
   2212 U1dbb
   2213 U1dbb							;
   2214 U1dbb							; Math stack and IL call and Gosub/For-next return stack definitions
   2215 U1dbb							;
   2216 U1dbb		       1d bb	   STACKSTART equ	*
   2217 U1dbb		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2218 U1f4b		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2219 U20db		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2220 U235b		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2221 U235b		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2222 U235b		       25 77	   STACKEND   equ	*
   2223 U235b		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2224 U2577							;
   2225 U2577							;
   2226 U2577		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2227 U25fb		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2228 U25fc		       00	   printtx    ds	1	;temp X for print funcs
   2229 U25fd		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2230 U25fe		       00	   promptChar ds	1	;the character to use for a prompt
   2231 U25ff		       00	   diddigit   ds	1	;for leading zero suppression
   2232 U2600		       00	   putsy      ds	1
   2233 U2601		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2234 U2603		       00	   sign       ds	1	;0 = positive, else negative
   2235 U2604		       00 00	   rtemp1     ds	2	;Temp for x and y
   2236 U2606		       00 00	   random     ds	2
   2237 U2608		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2238 U260a		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2239 U260c		       00	   tempy      ds	1	;temp y storage
   2240 U260d				  -	      if	XKIM
   2241 U260d				  -buffer     ds	BUFFER_SIZE
   2242 U260d					      endif
   2243 U260d							;
   2244 U260d							; PROGRAMEND is the end of the user's BASIC program.
   2245 U260d							; More precisely, it is one byte past the end.  Or,
   2246 U260d							; it's where the next line added to the end will be
   2247 U260d							; placed.
   2248 U260d							;
   2249 U260d		       00 00	   PROGRAMEND ds	2	; End of users basic program
   2250 U260f		       00 00	   HighMem    ds	2	; highest location
   2251 U2611		       00 00	   UsedMem    ds	2	; size of user program
   2252 U2613		       00 00	   FreeMem    ds	2	; amount of free memory
   2253 U2615							;
   2254 U2615							;=====================================================
   2255 U2615							; This is the start of the user's BASIC program space.
   2256 U2615							;
   2257 U2615							; PERSONAL GOAL: This should be no larger than $0DFF.
   2258 U2615							;		  0200-05FF = 1K
   2259 U2615							;		  0200-09FF = 2K
   2260 U2615							;		  0200-0DFF = 3K
   2261 U2615							;		  0200-11FF = 4K
   2262 U2615							;		  0200-13FF = 4.5K
   2263 U2615							;
   2264 U2615				  -	      if	FIXED
   2265 U2615				  -	      org	$2000
   2266 U2615					      endif
   2267 U2615		       26 15	   ProgramStart equ	*
   2268 U2615							;/*
   2269 U2615							;	if	CTMON65 || XKIM
   2270 U2615							;		SEG Code
   2271 U2615							;		org	AutoRun
   2272 U2615							;		dw	TBasicCold
   2273 U2615							;	endif
   2274 U2615							;*/
   2275 U2615					      end
