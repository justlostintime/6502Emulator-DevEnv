------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2fb8				   input      processor	6502
      2 U2fb8 ????						;=====================================================
      3 U2fb8 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2fb8 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2fb8 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2fb8 ????						;
      7 U2fb8 ????						; While working on the Corsham Technologies KIM Clone
      8 U2fb8 ????						; project, I wanted to include a TINY BASIC since that
      9 U2fb8 ????						; was a highly desirable feature of early computers.
     10 U2fb8 ????						;
     11 U2fb8 ????						; Rather than negotiating copyright issues for
     12 U2fb8 ????						; existing BASICs, I decided to just write one from
     13 U2fb8 ????						; scratch.
     14 U2fb8 ????						;
     15 U2fb8 ????						; 10/07/2017
     16 U2fb8 ????						;
     17 U2fb8 ????						; This implements a stripped down Tiny BASIC
     18 U2fb8 ????						; interpreter using the Interpretive Language (IL)
     19 U2fb8 ????						; method as described in the first few issues of
     20 U2fb8 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2fb8 ????						; to write various languages simply by changing the
     22 U2fb8 ????						; IL code rather than the interpreter itself.
     23 U2fb8 ????						;
     24 U2fb8 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2fb8 ????						;		* Fixed major bug in findLine that
     26 U2fb8 ????						;		  caused corrupted lines, crashes, etc.
     27 U2fb8 ????						;		* If no parameter given to RND, assume
     28 U2fb8 ????						;		  32766.
     29 U2fb8 ????						;		* No more error 5 when a program
     30 U2fb8 ????						;		  reaches the end without an END.
     31 U2fb8 ????						;
     32 U2fb8 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2fb8 ????						;		 * Unexpanded version to play with everything
     34 U2fb8 ????						;		 * Add some usefull system level functions
     35 U2fb8 ????						;		 * allow a larger number of tiny basic formats
     36 U2fb8 ????						;		 * Add byte at start of line holding length
     37 U2fb8 ????						;		   for faster execution of goto and gosub
     38 U2fb8 ????						;		 * Re-added gosub
     39 U2fb8 ????						;		 * allow ; or , at end if print stmt
     40 U2fb8 ????						;		   without CRLF being added.
     41 U2fb8 ????						;		 * Added extended function erase to
     42 U2fb8 ????						;		   use the extended ctmon65 rm file
     43 U2fb8 ????						;		 * Fix quoted text to not have to backtrack
     44 U2fb8 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2fb8 ????						;		 * Add concurrency features
     46 U2fb8 ????						;
     47 U2fb8 ????						; www.corshamtech.com
     48 U2fb8 ????						; bob@corshamtech.com
     49 U2fb8 ????						; JustLostInTime@gmail.com
     50 U2fb8 ????						;
     51 U2fb8 ????						;=====================================================
     52 U2fb8 ????						;
     53 U2fb8 ????						; Create TRUE and FALSE values for conditionals.
     54 U2fb8 ????						;
     55 U2fb8 ????
     56 U2fb8 ????	       00 00	   FALSE      equ	0
     57 U2fb8 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2fb8 ????						;
     59 U2fb8 ????						;---------------------------------------------------------
     60 U2fb8 ????						; One of these must be set to indicate which environment
     61 U2fb8 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2fb8 ????						; environments:
     63 U2fb8 ????						;
     64 U2fb8 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2fb8 ????						; more K of RAM.
     66 U2fb8 ????						;
     67 U2fb8 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2fb8 ????						; which enhances, without replacing, the standard KIM
     69 U2fb8 ????						; monitor.  It gives access to routines to save/load files
     70 U2fb8 ????						; to a micro SD card.
     71 U2fb8 ????						;
     72 U2fb8 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2fb8 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2fb8 ????						; easily be ported to other systems.  It has support for
     75 U2fb8 ????						; using a micro SD card for file storage/retrieval.
     76 U2fb8 ????						;
     77 U2fb8 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2fb8 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2fb8 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2fb8 ????
     81 U2fb8 ????						;
     82 U2fb8 ????						;   Need to define some macros for the dasm assembler
     83 U2fb8 ????						;
     84 U2fb8 ????				      MACRO	dw
     85 U2fb8 ????				      .word	{0}
     86 U2fb8 ????				      ENDM
     87 U2fb8 ????
     88 U2fb8 ????				      MACRO	db
     89 U2fb8 ????				      .byte	{0}
     90 U2fb8 ????				      ENDM
     91 U2fb8 ????
     92 U2fb8 ????						;
     93 U2fb8 ????						; If set, include disk functions.
     94 U2fb8 ????						;
     95 U2fb8 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     96 U2fb8 ????						;
     97 U2fb8 ????						; If ILTRACE is set then dump out the address of every
     98 U2fb8 ????						; IL opcode before executing it.
     99 U2fb8 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    100 U2fb8 ????						;
    101 U2fb8 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    102 U2fb8 ????						;
    103 U2fb8 ????						; If FIXED is set, put the IL code and the user
    104 U2fb8 ????						; program space at fixed locations in memory.	This is
    105 U2fb8 ????						; meant only for debugging.
    106 U2fb8 ????						;
    107 U2fb8 ????	       00 00	   FIXED      equ	FALSE
    108 U2fb8 ????						;
    109 U2fb8 ????						; Sets the arithmetic stack depth.  This is *TINY*
    110 U2fb8 ????						; BASIC, so keep this small!
    111 U2fb8 ????						;
    112 U2fb8 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    113 U2fb8 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    114 U2fb8 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    115 U2fb8 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    116 U2fb8 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    117 U2fb8 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    118 U2fb8 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    119 U2fb8 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    120 U2fb8 ????						;
    121 U2fb8 ????						; Gosub entry types
    122 U2fb8 ????
    123 U2fb8 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    124 U2fb8 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    125 U2fb8 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    126 U2fb8 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    127 U2fb8 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    128 U2fb8 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    129 U2fb8 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    130 U2fb8 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    131 U2fb8 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    132 U2fb8 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    133 U2fb8 ????						;
    134 U2fb8 ????						; Common ASCII constants
    135 U2fb8 ????						;
    136 U2fb8 ????	       00 07	   BEL	      equ	$07
    137 U2fb8 ????	       00 08	   BS	      equ	$08
    138 U2fb8 ????	       00 09	   TAB	      equ	$09
    139 U2fb8 ????	       00 0a	   LF	      equ	$0A
    140 U2fb8 ????	       00 0d	   CR	      equ	$0D
    141 U2fb8 ????	       00 22	   quote      equ	$22
    142 U2fb8 ????	       00 20	   SPACE      equ	$20
    143 U2fb8 ????	       00 2c	   COMMA      equ	',
    144 U2fb8 ????	       00 3b	   SEMICOLON  equ	';
    145 U2fb8 ????	       00 3a	   COLON      equ	':
    146 U2fb8 ????	       00 24	   DOLLAR     equ	'$
    147 U2fb8 ????						;
    148 U2fb8 ????						; These are error codes
    149 U2fb8 ????						;
    150 U2fb8 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    151 U2fb8 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    152 U2fb8 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    153 U2fb8 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    154 U2fb8 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    155 U2fb8 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    156 U2fb8 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    157 U2fb8 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    158 U2fb8 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    159 U2fb8 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    160 U2fb8 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    161 U2fb8 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    162 U2fb8 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    163 U2fb8 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    164 U2fb8 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    165 U2fb8 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    166 U2fb8 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    167 U2fb8 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    168 U2fb8 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    169 U2fb8 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    170 U2fb8 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    171 U2fb8 ????						;
    172 U2fb8 ????						;=====================================================
    173 U2fb8 ????						; Zero page storage.
    174 U2fb8 ????						;
    175 U00f6 ????				      SEG.U	ZEROPAGE
    176 U0040					      org	$0040
    177 U0040
    178 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    179 U0041
    180 U0041							; The context is used to locate a task switch
    181 U0041							; it copies from here till all task fields are saved/swapped
    182 U0041							; The max number of tasks is 256 / context length
    183 U0041							; All positions POS values are plus one task table incldues
    184 U0041							; a leading status byte .
    185 U0041							;
    186 U0041		       00 41	   CONTEXT    equ	*
    187 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    188 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    189 U0043		       00 00	   ILPC       ds	2	; IL program counter
    190 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    191 U0047		       00	   ILSTACKPTR ds	1
    192 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    193 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    194 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    195 U004a		       00	   MATHSTACKPTR ds	1
    196 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    197 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    198 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT + 1	; Pointer to gosub stack pointer
    199 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    200 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT + 1	; Pointer to the message counter
    201 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    202 U004f							;
    203 U004f							; CURPTR is a pointer to curent BASIC line being
    204 U004f							; executed.  Always points to start of line, CUROFF
    205 U004f							; is the offset to the current character.
    206 U004f							; The order of these fields is important
    207 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    208 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    209 U0052							;
    210 U0052							;The order of these fields in important
    211 U0052
    212 U0052							;
    213 U0052							; R0, R1 and MQ are used for arithmetic operations and
    214 U0052							; general use.
    215 U0052							;
    216 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    217 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    218 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    219 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    220 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    221 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    222 U0056		       00 00	   MQ	      ds	2	;used for some math
    223 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    224 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    225 U0058		       00 59	   REGISTERSEND equ	*
    226 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    227 U0059
    228 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    229 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    230 U0059
    231 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    232 U005b							;
    233 U005b							; This is zero if in immediate mode, or non-zero
    234 U005b							; if currently running a program.  Any input from
    235 U005b							; the main loop clears this, and the XFER IL
    236 U005b							; statement will set it.
    237 U005b							;
    238 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    239 U005c							;
    240 U005c							; Used for line insertion/removal.
    241 U005c							;
    242 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    243 U005e
    244 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    245 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    246 U005e							;
    247 U005e		       00 00	   PrtFrom    ds	2	; FROM
    248 U0060							;
    249 U0060							;=====================================================
    250 U0060							;Pointers for memory Management
    251 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    252 U0060							; Mem block format is
    253 U0060							;	 0-1   pointer to next block for free blocks
    254 U0060							;	 0-1   for allocated blocks
    255 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    256 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    257 U0060							;	 2-3   length constant for exevy type of memory block
    258 U0060							; Memory is recombined as it is released
    259 U0060							; The memory manager is not interupted durring allocation
    260 U0060							; or freeing of memory
    261 U0060							;====================================================
    262 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    263 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    264 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    265 U0066							;
    266 U0066							;=====================================================
    267 U0066							;
    268  260e ????				      SEG	Code
    269  0200					      org	$0200
    270  0200							;
    271  0200							; Cold start is at $0200.  Warm start is at $0203.
    272  0200							;
    273  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    274  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    275  0206							;
    276  0206							; These are the user-supplied vectors to I/O routines.
    277  0206							; If you want, you can just patch these in the binary
    278  0206							; file, but it would be better to change the source
    279  0206							; code.
    280  0206							;
    281  0206				  -	      if	KIM
    282  0206				  -OUTCH      jmp	$1ea0	;output char in A
    283  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    284  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    285  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    286  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    287  0206					      endif
    288  0206				  -	      if	XKIM
    289  0206				  -	      include	"xkim.inc"
    290  0206				  -	      SEG	Code
    291  0206				  -OUTCH      jmp	$1ea0
    292  0206				  -GETCH      jmp	xkGETCH
    293  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    294  0206				  -OUTHEX     jmp	xkPRTBYT
    295  0206				  -MONITOR    jmp	extKIM
    296  0206				  -puts       equ	putsil
    297  0206				  -BUFFER_SIZE equ	132
    298  0206					      endif
    299  0206
    300  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    302 Udf8e
    303  0206					      SEG	Code
    304  0206							;
    305  0206		       f0 0c	   OUTCH      equ	cout
    306  0206		       f0 09	   GETCH      equ	cin
    307  0206		       1e 2b	   CRLF       equ	tbcrlf
    308  0206		       14 05	   OUTHEX     equ	HexToOut
    309  0206		       f0 03	   MONITOR    equ	WARM
    310  0206		       f0 0f	   ISCHAR     equ	cstatus
    311  0206		       14 22	   puts       equ	tbputs
    312  0206					      endif
    313  0206							;
    314  0206		       20 5f 1f    cold2      jsr	SetOutConsole
    315  0209		       20 6c 1f 	      jsr	SetInConsole
    316  020c		       20 22 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    320  0243							;
    321  0243		       20 16 16 	      jsr	MemInit	;setup the free space available
    322  0246
    323  0246		       a9 01	   calcstack  lda	#1
    324  0248		       8d 54 27 	      sta	taskCounter	; Initialize number of tasks to 1
    325  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    326  024d		       8d 56 26 	      sta	taskTable	; mark the main task as active
    327  0250		       20 03 17 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    328  0253		       a9 18		      lda	#IL&$ff
    329  0255		       85 43		      sta	ILPC
    330  0257		       a9 22		      lda	#IL>>8
    331  0259		       85 44		      sta	ILPC+1
    332  025b							;
    333  025b							;		  lda	  ProgramStart		     ; user prog
    334  025b							;		  sta	  ProgramEnd
    335  025b							;		  lda	  ProgramStart+1
    336  025b							;		  sta	  ProgramEnd+1
    337  025b							;
    338  025b
    339  025b							;  Init time slices defaults
    340  025b		       a9 02		      lda	#TASKCYCLESHIGH
    341  025d		       8d 53 27 	      sta	taskResetValue+1
    342  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    343  0262		       8d 52 27 	      sta	taskResetValue
    344  0265							;
    345  0265							; Initialize the pseudo-random number sequence...
    346  0265							;
    347  0265		       a9 5a		      lda	#$5a
    348  0267		       8d 9e 2f 	      sta	rtemp1
    349  026a		       a9 9d		      lda	#%10011101
    350  026c		       8d a0 2f 	      sta	random
    351  026f		       a9 5b		      lda	#%01011011
    352  0271		       8d a1 2f 	      sta	random+1
    353  0274							;
    354  0274							;   Insert a Basic irq handler for the basic Language
    355  0274		       a9 81		      lda	#ServiceIrq&$ff
    356  0276		       8d 00 df 	      sta	IRQvec
    357  0279		       a9 02		      lda	#ServiceIrq>>8
    358  027b		       8d 01 df 	      sta	IRQvec+1
    359  027e		       4c a6 02 	      jmp	coldtwo
    360  0281
    361  0281							;
    362  0281							; This is the Basic IRQ handler
    363  0281		       48	   ServiceIrq pha
    364  0282		       ad 51 26 	      lda	IRQStatus
    365  0285		       f0 0a		      BEQ	RetIrq
    366  0287		       ad 52 26 	      lda	IRQPending
    367  028a		       d0 05		      bne	RetIrq
    368  028c		       a9 01		      lda	#1
    369  028e		       8d 52 26 	      sta	IRQPending
    370  0291		       68	   RetIrq     pla
    371  0292		       40		      rti
    372  0293							;
    373  0293							;
    374  0293							; This is the warm start entry point
    375  0293							;
    376  0293		       20 5f 1f    warm2      jsr	SetOutConsole
    377  0296		       20 6c 1f 	      jsr	SetInConsole
    378  0299		       20 2b 1e 	      jsr	CRLF
    379  029c		       ad 9b 2f 	      lda	errGoto
    380  029f		       85 43		      sta	ILPC
    381  02a1		       ad 9c 2f 	      lda	errGoto+1
    382  02a4		       85 44		      sta	ILPC+1
    383  02a6							;
    384  02a6							; And continue with both starts here
    385  02a6							;
    386  02a6				   coldtwo
    387  02a6							;
    388  02a6							; The ILTrace flag is now run-time settable.
    389  02a6							;
    390  02a6		       a9 00		      lda	#ILTRACE&$ff
    391  02a8		       85 40		      sta	ILTrace
    392  02aa							;
    393  02aa
    394  02aa		       a9 00		      lda	#0
    395  02ac		       85 5b		      sta	RunMode
    396  02ae		       8d 11 2f 	      sta	LINBUF
    397  02b1
    398  02b1							; Clear everything from the stacks
    399  02b1
    400  02b1		       8d ac 2f 	      sta	taskIOPending	; No one waiting for io
    401  02b4		       8d ad 2f 	      sta	taskRDPending	; No one waiting for bg io
    402  02b7
    403  02b7		       20 76 17 	      jsr	taskReset
    404  02ba							;
    405  02ba		       a9 11		      lda	#LINBUF&$ff
    406  02bc		       85 4f		      sta	CURPTR
    407  02be		       a9 2f		      lda	#LINBUF>>8
    408  02c0		       85 50		      sta	CURPTR+1	;fall through...
    409  02c2
    410  02c2							;=====================================================
    411  02c2							; This is the top of the IL interpreter.  This fetches
    412  02c2							; and executes the instruction currently pointed to
    413  02c2							; by ILPC and adjusts ILPC to point to the next
    414  02c2							; instruction to execute.
    415  02c2							;
    416  02c2		       ce 50 27    NextIL     dec	taskCurrentCycles
    417  02c5		       d0 03		      bne	NextIlNow
    418  02c7		       20 9f 17 	      jsr	iTaskSwitch	;check for a task switch
    419  02ca		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    420  02cc		       f0 03		      beq	NextIL2	;Skip if no bits set
    421  02ce
    422  02ce		       20 bc 1e 	      jsr	dbgLine	;Print the IL trace information
    423  02d1
    424  02d1		       a4 51	   NextIL2    ldy	CUROFF
    425  02d3							;		  jsr	  SkipSpaces
    426  02d3							;		  sty	  CUROFF
    427  02d3							;Task IO Management
    428  02d3		       ad ad 2f 	      lda	taskRDPending	; if it is zero then Nothing pending
    429  02d6		       f0 08		      beq	NextILStr
    430  02d8		       20 64 1c 	      jsr	ReadLine	; else Pending and poll keyboard
    431  02db		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    432  02dd		       ce ad 2f 	      dec	taskRDPending	; Carry is set if CR has been recieved
    433  02e0							;
    434  02e0		       20 e7 1a    NextILStr  jsr	getILByte
    435  02e3							;
    436  02e3							; When the handler is called, these are the conditions
    437  02e3							; of several important items:
    438  02e3							;
    439  02e3							;    (ILPC) will point to the byte AFTER the IL
    440  02e3							;    opcode being executed.
    441  02e3							;
    442  02e3							;    (CURPTR),CUROFF will point to the start of the
    443  02e3							;    next word in the input buffer.  Ie, the next word
    444  02e3							;    in the user program.
    445  02e3							;
    446  02e3		       0a		      asl
    447  02e4		       c9 da		      cmp	#ILTBLend-ILTBL+2
    448  02e6		       90 33		      bcc	ILgood
    449  02e8							;
    450  02e8							; This handles an illegal IL opcode.  This is serious
    451  02e8							; and there's no way to recover.
    452  02e8							;
    453  02e8		       20 22 14    ILbad      jsr	puts
      0  02eb					      db	CR,LF
      1  02eb		       0d 0a		      .byte.b	CR,LF
      0  02ed					      db	"Illegal IL "
      1  02ed		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f8					      db	0
      1  02f8		       00		      .byte.b	0
    457  02f9							;
    458  02f9							; Well this is awkward, we need to back up the IL
    459  02f9							; by one since it no longer points to the current
    460  02f9							; opcode.
    461  02f9							;
    462  02f9		       20 f4 1a 	      jsr	decIL
    463  02fc							;
    464  02fc		       a0 00		      ldy	#0
    465  02fe		       b1 43		      lda	(ILPC),y
    466  0300		       20 05 14 	      jsr	OUTHEX
    467  0303		       20 22 14 	      jsr	puts
      0  0306					      db	" at ",0
      1  0306		       20 61 74 20*	      .byte.b	" at ",0
    469  030b		       a5 44		      lda	ILPC+1
    470  030d		       20 05 14 	      jsr	OUTHEX
    471  0310		       a5 43		      lda	ILPC
    472  0312		       20 05 14 	      jsr	OUTHEX
    473  0315		       20 2b 1e 	      jsr	CRLF
    474  0318		       4c 03 f0 	      jmp	MONITOR
    475  031b							;
    476  031b							; Just jump to the address (ILPC),y.  Have to do
    477  031b							; some goofy stuff.
    478  031b							;
    479  031b		       a8	   ILgood     tay		;move index into Y
    480  031c		       b9 29 03 	      lda	ILTBL,y
    481  031f		       85 59		      sta	dpl
    482  0321		       b9 2a 03 	      lda	ILTBL+1,y
    483  0324		       85 5a		      sta	dpl+1
    484  0326		       6c 59 00 	      jmp	(dpl)	;go to handler
    485  0329							;
    486  0329							;=====================================================
    487  0329							; This is the IL jump table.  The IL opcode is
    488  0329							; mulitplied by two, then looked-up in this table.
    489  0329							; There is absolutely nothing special about the order
    490  0329							; of entries here... they all decode at exactly the
    491  0329							; same speed.	However the entry number must match the
    492  0329							; values in IL.inc.
    493  0329							;
    494  0329				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0329					      include	"ilvectortable.asm"
      1  0329					      seg	Code
      2  0329
      0  0329					      dw	iXINIT	;0
      1  0329		       39 04		      .word.w	iXINIT
      0  032b					      dw	iDONE	;1
      1  032b		       54 04		      .word.w	iDONE
      0  032d					      dw	iPRS	;2
      1  032d		       6d 04		      .word.w	iPRS
      0  032f					      dw	iPRN	;3
      1  032f		       75 04		      .word.w	iPRN
      0  0331					      dw	iSPC	;4
      1  0331		       7e 04		      .word.w	iSPC
      0  0333					      dw	iNLINE	;5
      1  0333		       29 09		      .word.w	iNLINE
      0  0335					      dw	iNXT	;6
      1  0335		       86 04		      .word.w	iNXT
      0  0337					      dw	iXFER	;7
      1  0337		       c8 04		      .word.w	iXFER
      0  0339					      dw	iSAV	;8
      1  0339		       e6 04		      .word.w	iSAV
      0  033b					      dw	iRSTR	;9
      1  033b		       2c 05		      .word.w	iRSTR
      0  033d					      dw	iCMPR	;10
      1  033d		       7a 05		      .word.w	iCMPR
      0  033f					      dw	iINNUM	;11
      1  033f		       f9 05		      .word.w	iINNUM
      0  0341					      dw	iFIN	;12
      1  0341		       31 06		      .word.w	iFIN
      0  0343					      dw	iERR	;13
      1  0343		       45 06		      .word.w	iERR
      0  0345					      dw	iADD	;14
      1  0345		       bf 06		      .word.w	iADD
      0  0347					      dw	iSUB	;15
      1  0347		       d5 06		      .word.w	iSUB
      0  0349					      dw	iNEG	;16
      1  0349		       eb 06		      .word.w	iNEG
      0  034b					      dw	iMUL	;17
      1  034b		       03 07		      .word.w	iMUL
      0  034d					      dw	iDIV	;18
      1  034d		       43 07		      .word.w	iDIV
      0  034f					      dw	iSTORE	;19
      1  034f		       99 07		      .word.w	iSTORE
      0  0351					      dw	iIND	;20
      1  0351		       b1 07		      .word.w	iIND
      0  0353					      dw	iLST	;21
      1  0353		       1f 08		      .word.w	iLST
      0  0355					      dw	iINIT	;22
      1  0355		       01 04		      .word.w	iINIT
      0  0357					      dw	iGETLINE	;23
      1  0357		       55 08		      .word.w	iGETLINE
      0  0359					      dw	iINSRT	;24
      1  0359		       72 08		      .word.w	iINSRT
      0  035b					      dw	iRTN	;25
      1  035b		       23 09		      .word.w	iRTN
      0  035d					      dw	MONITOR	;26
      1  035d		       03 f0		      .word.w	MONITOR
      0  035f					      dw	iLIT	;27
      1  035f		       49 09		      .word.w	iLIT
      0  0361					      dw	iCALL	;28
      1  0361		       2f 09		      .word.w	iCALL
      0  0363					      dw	iJMP	;29
      1  0363		       37 09		      .word.w	iJMP
      0  0365					      dw	iVINIT	;30
      1  0365		       66 09		      .word.w	iVINIT
      0  0367					      dw	iERRGOTO	;31
      1  0367		       6f 09		      .word.w	iERRGOTO
      0  0369					      dw	iTST	;32
      1  0369		       7b 09		      .word.w	iTST
      0  036b					      dw	iTSTV	;33
      1  036b		       a0 0a		      .word.w	iTSTV
      0  036d					      dw	iTSTL	;34
      1  036d		       17 0b		      .word.w	iTSTL
      0  036f					      dw	iTSTN	;35
      1  036f		       32 0b		      .word.w	iTSTN
      0  0371					      dw	iFREE	;36
      1  0371		       e3 0b		      .word.w	iFREE
      0  0373					      dw	iRANDOM	;37
      1  0373		       ec 0b		      .word.w	iRANDOM
      0  0375					      dw	iABS	;38
      1  0375		       bd 0c		      .word.w	iABS
     42  0377							;
     43  0377							; Disk functions.  There must be pointers
     44  0377							; to functions even if no disk is supported.
     45  0377							; Makes things easier in IL.inc.
     46  0377							;
     47  0377					      if	DISK_ACCESS
      0  0377					      dw	iOPENREAD	;39
      1  0377		       70 20		      .word.w	iOPENREAD
      0  0379					      dw	iOPENWRITE	;40
      1  0379		       d1 20		      .word.w	iOPENWRITE
      0  037b					      dw	iDCLOSE	;41
      1  037b		       55 21		      .word.w	iDCLOSE
      0  037d					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037d		       e3 20		      .word.w	iDGETLINE
      0  037f					      dw	iDLIST	;43 Did you remember your towel?
      1  037f		       4f 21		      .word.w	iDLIST
      0  0381					      dw	iDDIR	;44
      1  0381		       2a 21		      .word.w	iDDIR
      0  0383					      dw	iRMFILE	;45
      1  0383		       bf 20		      .word.w	iRMFILE
     55  0385				  -	      else
     56  0385				  -	      dw	NextIL	;39
     57  0385				  -	      dw	NextIL	;40
     58  0385				  -	      dw	NextIL	;41
     59  0385				  -	      dw	NextIL	;42
     60  0385				  -	      dw	NextIL	;43
     61  0385				  -	      dw	NextIL	;44
     62  0385				  -	      dw	NextIL	;45
     63  0385					      endif
     64  0385							;
      0  0385					      dw	iCLEARSCREEN	;46
      1  0385		       7f 1f		      .word.w	iCLEARSCREEN
      0  0387					      dw	iPOKEMEMORY	;47
      1  0387		       4a 0c		      .word.w	iPOKEMEMORY
      0  0389					      dw	iPEEKMEMORY	;48
      1  0389		       5f 0c		      .word.w	iPEEKMEMORY
      0  038b					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  038b		       c2 09		      .word.w	iTSTLET
      0  038d					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038d		       47 0a		      .word.w	iTSTDONE
      0  038f					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038f		       8c 0c		      .word.w	iGETCHAR
      0  0391					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0391		       a0 0c		      .word.w	iPUTCHAR
      0  0393					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0393		       75 0c		      .word.w	iCallFunc
      0  0395					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0395		       c7 05		      .word.w	iBranch
      0  0397					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0397		       a5 09		      .word.w	iTSTStr
      0  0399					      dw	iSetIrq	;56	   sets the irq handler
      1  0399		       3a 0d		      .word.w	iSetIrq
      0  039b					      dw	iTstIrq	;57	   test if irq is pending
      1  039b		       a9 0b		      .word.w	iTstIrq
      0  039d					      dw	iRET	;58	   return from interupt
      1  039d		       1a 05		      .word.w	iRET
      0  039f					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039f		       12 06		      .word.w	iINSTR
      0  03a1					      dw	iMOD	;60	   returns remainder of division
      1  03a1		       4c 07		      .word.w	iMOD
      0  03a3					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a3		       f3 17		      .word.w	iTaskSet
      0  03a5					      dw	iETask	;62	   Terminates a task
      1  03a5		       30 19		      .word.w	iETask
      0  03a7					      dw	iNTask	;63	   goto next task
      1  03a7		       e3 18		      .word.w	iNTask
      0  03a9					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a9		       c6 07		      .word.w	iArray
      0  03ab					      dw	iTaskKill	;65	   kill a running task
      1  03ab		       db 18		      .word.w	iTaskKill
      0  03ad					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ad		       af 18		      .word.w	iTaskStat
      0  03af					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03af		       ab 0c		      .word.w	iHexOut
      0  03b1					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b1		       e3 05		      .word.w	iReadComplete
      0  03b3					      dw	iReadStart	;69	   Called to start a background read request
      1  03b3		       d9 05		      .word.w	iReadStart
      0  03b5					      dw	iStartIO	;70	   Lock task until io complete
      1  03b5		       13 19		      .word.w	iStartIO
      0  03b7					      dw	iEndIO	;71	   release task lock for io
      1  03b7		       19 19		      .word.w	iEndIO
      0  03b9					      dw	iLogNot	;72	   Logical not
      1  03b9		       16 0d		      .word.w	iLogNot
      0  03bb					      dw	iLogOr	;73	   Logical Or
      1  03bb		       ec 0c		      .word.w	iLogOr
      0  03bd					      dw	iLogAnd	;74	   Logical And
      1  03bd		       d7 0c		      .word.w	iLogAnd
      0  03bf					      dw	iLogXor	;75	   Logical Xor
      1  03bf		       01 0d		      .word.w	iLogXor
      0  03c1					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c1		       ee 18		      .word.w	iWTASK
      0  03c3					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c3		       24 19		      .word.w	iTASKPID
      0  03c5					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c5		       78 0d		      .word.w	iTRACEPROG
      0  03c7					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c7		       38 1e		      .word.w	idbgBasic
      0  03c9					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c9		       e6 19		      .word.w	iIPCS
      0  03cb					      dw	iIPCR	;81	   Recieve a message from a task
      1  03cb		       fd 19		      .word.w	iIPCR
      0  03cd					      dw	iIPCC	;82	   Check if any message available for task
      1  03cd		       11 1a		      .word.w	iIPCC
      0  03cf					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cf		       1e 1a		      .word.w	iIPCIO
      0  03d1					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d1		       6b 16		      .word.w	iPushMathStack
      0  03d3					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d3		       9b 16		      .word.w	iPopMathStack
      0  03d5					      dw	iSaveMathStack	;86	   Save all math info
      1  03d5		       b8 16		      .word.w	iSaveMathStack
      0  03d7					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d7		       d7 16		      .word.w	iRestoreMathStack
      0  03d9					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d9		       88 16		      .word.w	iIncParmCount
      0  03db					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03db		       50 19		      .word.w	iTaskGetMathStack
      0  03dd					      dw	iTaskEnable	;90	   enable a suspended task
      1  03dd		       7d 18		      .word.w	iTaskEnable
      0  03df					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03df		       97 18		      .word.w	iTaskSuspend
      0  03e1					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e1		       6a 19		      .word.w	iTaskPutMathPtr
      0  03e3					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e3		       97 0a		      .word.w	iTSTVT
      0  03e5					      dw	iSetR2	;94
      1  03e5		       41 09		      .word.w	iSetR2
      0  03e7					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e7		       f8 04		      .word.w	iStk2Tmp
      0  03e9					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e9		       09 05		      .word.w	iTmp2Stk
      0  03eb					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03eb		       e3 09		      .word.w	iTSTBYTE
      0  03ed					      dw	iINCVAR	;98	   Increment variable
      1  03ed		       69 0a		      .word.w	iINCVAR
      0  03ef					      dw	iDECVAR	;99	   Decrement variable
      1  03ef		       81 0a		      .word.w	iDECVAR
      0  03f1					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f1		       79 19		      .word.w	iSLICE
      0  03f3					      dw	iTSTB	;101	   Test if byte equals
      1  03f3		       02 0a		      .word.w	iTSTB
      0  03f5					      dw	iTSTW	;102	   Test If word equals
      1  03f5		       1d 0a		      .word.w	iTSTW
      0  03f7					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03f7		       b9 12		      .word.w	iOnGoto
      0  03f9					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f9		       ea 12		      .word.w	iTSTRELOP
      0  03fb					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03fb		       ac 04		      .word.w	iRepeatLine
      0  03fd					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch is is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03fd		       11 13		      .word.w	iTSTBRANCH
      0  03ff					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03ff		       b3 04		      .word.w	iFastXfer
    127  0401
------- FILE mytb.asm
    496  0401		       04 01	   ILTBLend   equ	*
    497  0401							;
    498  0401							;=====================================================
    499  0401							;=====================================================
    500  0401							;=====================================================
    501  0401							; This marks the start of the handlers for IL opcodes.
    502  0401							;=====================================================
    503  0401							;=====================================================
    504  0401							;=====================================================
    505  0401							;
    506  0401							;
    507  0401		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    508  0403		       85 47		      sta	ILSTACKPTR
    509  0405		       85 4a		      sta	MATHSTACKPTR
    510  0407		       85 4d		      sta	GOSUBSTACKPTR
    511  0409		       a9 40		      lda	#GOSUBSTACKSIZE*4
    512  040b		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    513  040d							;
    514  040d		       ad ae 2f 	      lda	ProgramStart	;user prog
    515  0410		       85 4f		      sta	CURPTR
    516  0412		       8d 57 26 	      sta	taskTable+1
    517  0415		       8d b0 2f 	      sta	ProgramEnd
    518  0418		       ad af 2f 	      lda	ProgramStart+1
    519  041b		       85 50		      sta	CURPTR+1
    520  041d		       8d 58 26 	      sta	taskTable+2
    521  0420		       8d b1 2f 	      sta	ProgramEnd+1
    522  0423		       a9 80		      lda	#TASKACTIVE
    523  0425		       8d 56 26 	      sta	taskTable	;Mark the first slot as active
    524  0428		       a9 01		      lda	#1
    525  042a		       8d 54 27 	      sta	taskCounter	;there is always one task / Main task
    526  042d		       ad 52 27 	      lda	taskResetValue
    527  0430		       8d 50 27 	      sta	taskCurrentCycles	; set up the task switch counts
    528  0433		       ad 53 27 	      lda	taskResetValue+1
    529  0436		       8d 51 27 	      sta	taskCurrentCycles+1
    530  0439							;
    531  0439							; fall into XINIT...
    532  0439							;
    533  0439							;=====================================================
    534  0439							; This initializes for the start of the next line of
    535  0439							; BASIC text.
    536  0439							;
    537  0439		       78	   iXINIT     sei		;ensure interupts are off
    538  043a		       20 76 17 	      jsr	taskReset	;Clear the task table
    539  043d		       8d 52 26 	      sta	IRQPending	; reset the irq pending
    540  0440		       8d 51 26 	      sta	IRQStatus	; Make sure irqs are off
    541  0443
    542  0443		       4c c2 02    goodExit   jmp	NextIL
    543  0446							;
    544  0446							;=====================================================
    545  0446							; This check if the escape key has been entered
    546  0446							; then changes out of run mode. z Set if esc found
    547  0446				   BreakSet
    548  0446		       20 0f f0 	      jsr	ISCHAR
    549  0449		       f0 06		      beq	BreakNo
    550  044b		       20 7c 1f 	      jsr	VGETCH
    551  044e		       c9 1b		      cmp	#$1B
    552  0450		       60		      rts
    553  0451				   BreakNo
    554  0451		       a9 01		      lda	#1
    555  0453		       60		      rts
    556  0454
    557  0454							;
    558  0454
    559  0454							;=====================================================
    560  0454							; Verify there is nothing else on this input line.
    561  0454							; If there is, generate an error.
    562  0454							;
    563  0454		       a4 51	   iDONE      ldy	CUROFF
    564  0456		       b1 4f		      lda	(CURPTR),y
    565  0458		       f0 10		      beq	doneadv
    566  045a		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    567  045c		       d0 05		      bne	idoneErr
    568  045e		       84 51		      sty	CUROFF
    569  0460		       4c c2 02 	      jmp	NextIL	; continue on this line
    570  0463
    571  0463				   idoneErr
    572  0463		       a2 04		      ldx	#ERR_EXTRA_STUFF
    573  0465		       a9 00		      lda	#0
    574  0467		       4c a4 06 	      jmp	iErr2
    575  046a							;
    576  046a							; Advance to the next line
    577  046a							;
    578  046a				   doneadv
    579  046a		       4c c2 02 	      jmp	NextIL
    580  046d							;
    581  046d							;=====================================================
    582  046d							; Print the string until a closing quote
    583  046d							;
    584  046d				   iPRS
    585  046d		       20 45 14 	      jsr	PrtQuoted
    586  0470		       84 51		      sty	CUROFF
    587  0472		       4c c2 02 	      jmp	NextIL
    588  0475							;
    589  0475							;=====================================================
    590  0475							; Pop the top off the stack and print it as a signed
    591  0475							; decimal number.
    592  0475							;
    593  0475				   iPRN
    594  0475		       20 72 1d 	      jsr	popR0
    595  0478		       20 53 13 	      jsr	PrintDecimal
    596  047b		       4c c2 02 	      jmp	NextIL
    597  047e							;
    598  047e							;=====================================================
    599  047e							; Space to next zone.	Currently the code does not
    600  047e							; keep track of which column the output is on, so
    601  047e							; just print a tab.
    602  047e							;
    603  047e				   iSPC
    604  047e		       a9 09		      lda	#TAB
    605  0480		       20 79 1f 	      jsr	VOUTCH
    606  0483		       4c c2 02 	      jmp	NextIL
    607  0486							;
    608  0486							;=====================================================
    609  0486							; If in immediate mode, jump to the address following
    610  0486							; the NXT instruction.  Else move to the next line of
    611  0486							; user code and continue.
    612  0486							;
    613  0486		       a5 5b	   iNXT       lda	RunMode
    614  0488		       d0 03		      bne	iNxtRun	;in run mode
    615  048a							;
    616  048a							; Get address and jump to it.
    617  048a							;
    618  048a		       4c 37 09 	      jmp	iJMP
    619  048d							;
    620  048d				   iNxtRun
    621  048d		       a4 51		      ldy	CUROFF
    622  048f		       b1 4f		      lda	(CURPTR),y
    623  0491		       c9 e6		      cmp	#oColon
    624  0493		       d0 06		      bne	iNxtRunGo
    625  0495		       c8		      iny
    626  0496		       84 51		      sty	CUROFF
    627  0498		       4c a6 04 	      jmp	iNxtRun2
    628  049b
    629  049b				   iNxtRunGo
    630  049b		       20 71 1b 	      jsr	FindNextLine
    631  049e		       20 85 1b 	      jsr	AtEnd
    632  04a1		       d0 03		      bne	iNxtRun2	;not at end
    633  04a3							;
    634  04a3							; At the end of the program.  Pretend an END statement
    635  04a3							; was found.
    636  04a3							;
    637  04a3		       4c 31 06    iFINv      jmp	iFIN
    638  04a6							;
    639  04a6		       20 e3 1a    iNxtRun2   jsr	getILWord	;ignore next word
    640  04a9		       4c c2 02 	      jmp	NextIL
    641  04ac							;=====================================================
    642  04ac							;Repeat the same line against
    643  04ac		       a0 03	   iRepeatLine ldy	#3
    644  04ae		       84 51		      sty	CUROFF
    645  04b0		       4c c2 02 	      jmp	NextIL
    646  04b3							;
    647  04b3							;=====================================================
    648  04b3							; XFER takes the number on top of the stack and looks
    649  04b3							; for that line in the program, or the next line
    650  04b3							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04b3							; find the next one after that.
    652  04b3							;
    653  04b3				   iFastXfer
    654  04b3		       20 8a 1d 	      jsr	popR1	; get type of transfer
    655  04b6		       a5 54		      lda	R1
    656  04b8		       f0 0e		      beq	iXFER
    657  04ba
    658  04ba		       20 72 1d 	      jsr	popR0	; get where to transfer
    659  04bd		       a5 52		      lda	R0
    660  04bf		       85 4f		      sta	CURPTR
    661  04c1		       a5 53		      lda	R0+1
    662  04c3		       85 50		      sta	CURPTR+1
    663  04c5		       4c ce 04 	      jmp	iXFER2
    664  04c8
    665  04c8				   iXFER
    666  04c8		       20 72 1d 	      jsr	popR0
    667  04cb		       20 2c 1b 	      jsr	findLine
    668  04ce
    669  04ce				   iXFER2
    670  04ce		       20 85 1b 	      jsr	AtEnd	;at end of user program?
    671  04d1		       f0 d0		      beq	iFINv
    672  04d3
    673  04d3		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    674  04d5		       84 51		      sty	CUROFF
    675  04d7
    676  04d7							;		  lda	  #$ff
    677  04d7							;		  sta	  RunMode
    678  04d7							;
    679  04d7							; Transfer IL to STMT.  I don't like having this
    680  04d7							; hard-coded; fix it.
    681  04d7							;
    682  04d7							;		  lda	  #STMT&$ff
    683  04d7							;		  sta	  ILPC
    684  04d7							;		  lda	  #STMT>>8
    685  04d7							;		  sta	  ILPC+1
    686  04d7							;		  jmp	  NextIL
    687  04d7							;
    688  04d7							; Run
    689  04d7							;
    690  04d7				   iXferok
    691  04d7		       a9 ff		      lda	#$ff
    692  04d9		       85 5b		      sta	RunMode	;we're running
    693  04db							;
    694  04db							; Need a more elegant way to do this
    695  04db							;
    696  04db		       a9 26		      lda	#STMT&$ff
    697  04dd		       85 43		      sta	ILPC
    698  04df		       a9 22		      lda	#STMT>>8
    699  04e1		       85 44		      sta	ILPC+1
    700  04e3		       4c c2 02 	      jmp	NextIL
    701  04e6							;
    702  04e6							;=====================================================
    703  04e6							; Save the pointer to the next line to the call stack.
    704  04e6							;
    705  04e6		       20 e7 1a    iSAV       jsr	getILByte	; load type of gosub
    706  04e9		       20 fa 1c 	      jsr	pushLN	; Type passed in A
    707  04ec		       b0 03		      bcs	iSAVErr
    708  04ee		       4c c2 02 	      jmp	NextIL
    709  04f1
    710  04f1		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    711  04f3		       a9 00	   iSAVErr2   lda	#0
    712  04f5		       4c a4 06 	      jmp	iErr2
    713  04f8							;====================================================
    714  04f8							; Move stack top to and from temp area
    715  04f8				   iStk2Tmp
    716  04f8		       20 72 1d 	      jsr	popR0
    717  04fb		       a5 52		      lda	R0
    718  04fd		       a0 34		      ldy	#TASKEXITCODE	; can also be used as temp
    719  04ff		       91 41		      sta	(VARIABLES),y
    720  0501		       c8		      iny
    721  0502		       a5 53		      lda	R0+1
    722  0504		       91 41		      sta	(VARIABLES),y
    723  0506		       4c c2 02 	      jmp	NextIL
    724  0509
    725  0509		       a0 34	   iTmp2Stk   ldy	#TASKEXITCODE
    726  050b		       b1 41		      lda	(VARIABLES),y
    727  050d		       85 52		      sta	R0
    728  050f		       c8		      iny
    729  0510		       b1 41		      lda	(VARIABLES),y
    730  0512		       85 53		      sta	R0+1
    731  0514		       20 e0 1c 	      jsr	pushR0
    732  0517		       4c c2 02 	      jmp	NextIL
    733  051a							;
    734  051a							;=====================================================
    735  051a							; Pop the next line from the call stack.
    736  051a							;
    737  051a		       20 23 1d    iRET       jsr	popLN
    738  051d		       b0 d2		      bcs	iSAVErr
    739  051f		       a0 03		      ldy	#3
    740  0521		       84 51		      sty	CUROFF
    741  0523		       a9 00		      lda	#0
    742  0525		       8d 52 26 	      sta	IRQPending
    743  0528		       58		      cli
    744  0529		       4c c2 02 	      jmp	NextIL
    745  052c							;
    746  052c							;=====================================================
    747  052c							; On entry il, branch to if function
    748  052c							;	    il+1, value to be returned or not true or false
    749  052c							;
    750  052c							; Return from GOSUB function
    751  052c							;
    752  052c		       20 e7 1a    iRSTR      jsr	getILByte	; get where to go if gosub is a fucntion
    753  052f		       8d aa 2f 	      sta	offset
    754  0532		       20 ca 1c 	      jsr	saveIL	; for later jump if needed
    755  0535
    756  0535		       20 23 1d 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    757  0538		       85 54		      sta	R1	; keep the type of call returning from
    758  053a		       b0 2a		      bcs	iRSTRErr	; stack underflow error possible
    759  053c
    760  053c		       20 e7 1a 	      jsr	getILByte	; get if a value is being returned
    761  053f		       48		      pha		; save if a value was passed to be returned
    762  0540		       c9 00		      cmp	#0	; yes attemping to return a value
    763  0542		       f0 03		      beq	iRSTRPOP	; no value to return
    764  0544		       20 72 1d 	      jsr	popR0	; Get the value from the stack save if needed
    765  0547				   iRSTRPOP
    766  0547		       20 a1 16 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    767  054a		       a5 54		      lda	R1	; called as a statement ?
    768  054c		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    769  054e		       f0 12		      beq	iRSTRExit
    770  0550		       68		      pla		; get back if value returned or not
    771  0551		       c9 01		      cmp	#1	; we have a value to return
    772  0553		       f0 04		      beq	iRSTRVALUE
    773  0555
    774  0555		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    775  0557		       d0 9a		      bne	iSAVErr2
    776  0559
    777  0559				   iRSTRVALUE
    778  0559		       20 e0 1c 	      jsr	pushR0	; return value back to top of stack
    779  055c		       20 d5 1c 	      jsr	restoreIL	; get the correct il
    780  055f		       4c 8a 0b 	      jmp	tstBranch	; And called as a function
    781  0562
    782  0562				   iRSTRExit
    783  0562		       68		      pla		; throw away the return value if provided
    784  0563		       4c c2 02 	      jmp	NextIL
    785  0566
    786  0566				   iRSTRNORETURNVALUE
    787  0566
    788  0566
    789  0566		       ad 55 26    iRSTRErr   lda	taskPtr	; Check if this is task zero
    790  0569		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    791  056b		       a5 56		      lda	MQ
    792  056d		       d0 03		      bne	taskRet
    793  056f		       20 94 1f 	      jsr	pushFalse	; the result code by default is 0
    794  0572				   taskRet
    795  0572		       4c 30 19 	      jmp	iETask	; not task zero then do a task end instead
    796  0575				   taskZeroEnd
    797  0575		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    798  0577		       4c f3 04 	      jmp	iSAVErr2
    799  057a							;
    800  057a							;=====================================================
    801  057a							; Compare items on stack.  Okay, so on input there are
    802  057a							; three things on the stack
    803  057a							;
    804  057a							;    EXPR2 <- Top of stack
    805  057a							;    OP    <- relational operator, next on stack
    806  057a							;    EXPR1 <- last item on stack
    807  057a							;
    808  057a							; Comparison is: EXPR1 <operator> EXPR2
    809  057a							;
    810  057a							; Operator is one of...
    811  057a							;
    812  057a							;    2 is =
    813  057a							;    1 is <
    814  057a							;    3 is <=
    815  057a							;    5 is <>
    816  057a							;    4 is >
    817  057a							;    6 is >=
    818  057a							;
    819  057a							; Those are bit-mapped:
    820  057a							;
    821  057a							;    xxxxxGEL
    822  057a							;
    823  057a							;    G = Greater than
    824  057a							;    E = Equal
    825  057a							;    L = Less than
    826  057a							;
    827  057a							; If the comparison is false, do a NXT, ie, move to the
    828  057a							; next line and continue.  If true, continue executing
    829  057a							; on this line.
    830  057a							;
    831  057a		       00 01	   REL_LT     equ	%001
    832  057a		       00 02	   REL_EQUAL  equ	%010
    833  057a		       00 04	   REL_GT     equ	%100
    834  057a							;
    835  057a		       20 8a 1d    iCMPR      jsr	popR1
    836  057d		       20 a1 1d 	      jsr	popMQ	;operator in MQ
    837  0580		       20 72 1d 	      jsr	popR0
    838  0583		       20 8c 05 	      jsr	iCMPRsub
    839  0586		       20 e0 1c 	      jsr	pushR0
    840  0589		       4c c2 02 	      jmp	NextIL
    841  058c							;
    842  058c							; See if they are equal or not
    843  058c							;
    844  058c				   iCMPRsub		; Called by internal functions
    845  058c
    846  058c		       a5 52		      lda	R0
    847  058e		       c5 54		      cmp	R1
    848  0590		       d0 0a		      bne	iCMPRnoteq	;try not equal
    849  0592		       a5 53		      lda	R0+1
    850  0594		       c5 55		      cmp	R1+1
    851  0596		       d0 04		      bne	iCMPRnoteq
    852  0598							;
    853  0598							; Equal, set the flag in MQ+1
    854  0598							;
    855  0598		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    856  059a		       d0 14		      bne	iCMPcom	;Exit it is equal
    857  059c							;
    858  059c							; See if EXPR1 (R0) < EXPR2 (R1)
    859  059c							; See www.6502.org/tutorials/compare_beyond.html
    860  059c							;
    861  059c				   iCMPRnoteq
    862  059c		       a5 52		      lda	R0
    863  059e		       c5 54		      cmp	R1	; Sets the carry flag
    864  05a0		       a5 53		      lda	R0+1
    865  05a2		       e5 55		      sbc	R1+1
    866  05a4
    867  05a4		       50 02		      bvc	iCMPR_2	; branch if N eor V
    868  05a6		       49 80		      eor	#$80
    869  05a8
    870  05a8		       30 04	   iCMPR_2    bmi	iCMPlt
    871  05aa		       a9 04		      lda	#REL_GT
    872  05ac		       d0 02		      bne	iCMPcom
    873  05ae
    874  05ae		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    875  05b0
    876  05b0				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    877  05b0							;
    878  05b0							; Now compare the end result with what the caller
    879  05b0							; was looking for.
    880  05b0							;
    881  05b0		       25 56		      and	MQ
    882  05b2		       f0 0c		      beq	iCMPno	; no match
    883  05b4		       a9 ff		      lda	#$FF	; true is $ffff
    884  05b6		       85 52		      sta	R0
    885  05b8		       85 53		      sta	R0+1
    886  05ba		       d0 0a		      bne	iCMPDone
    887  05bc							;
    888  05bc							; R0 > R1
    889  05bc							;
    890  05bc		       a9 04	   iCMPgt     lda	#REL_GT
    891  05be		       d0 f0		      bne	iCMPcom
    892  05c0				   iCMPno
    893  05c0		       a9 00		      lda	#0
    894  05c2		       85 52		      sta	R0
    895  05c4		       85 53		      sta	R0+1
    896  05c6
    897  05c6				   iCMPDone
    898  05c6		       60		      rts
    899  05c7
    900  05c7							;
    901  05c7							; if Not a match, so jump to the next line of code.
    902  05c7							; Branches based upon value on top of the stack
    903  05c7				   iBranch
    904  05c7		       20 72 1d 	      jsr	popR0
    905  05ca		       a5 52		      lda	R0
    906  05cc		       05 53		      ora	R0+1
    907  05ce		       f0 03		      beq	iBranchFalse	; not true
    908  05d0		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    909  05d3							;
    910  05d3				   iBranchFalse
    911  05d3		       20 71 1b 	      jsr	FindNextLine
    912  05d6		       4c ce 04 	      jmp	iXFER2
    913  05d9							;
    914  05d9							;=====================================================
    915  05d9							; Start a read of data in background
    916  05d9				   iReadStart
    917  05d9		       a9 3f		      lda	#'?	; Prompt with question mark
    918  05db		       a6 01		      ldx	1	; Indicate to start read in background
    919  05dd		       20 fd 1b 	      jsr	GetLine	; Call the getline to start read
    920  05e0		       4c c2 02 	      jmp	NextIL	; next instruction
    921  05e3							;
    922  05e3							;=====================================================
    923  05e3							; Complete the read and return the curptr, curoff pointing to data
    924  05e3				   iReadComplete
    925  05e3		       a9 01		      lda	#GOSUB_RTN
    926  05e5		       20 fa 1c 	      jsr	pushLN
    927  05e8		       90 03		      bcc	iReadOk
    928  05ea		       4c dc 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    929  05ed				   iReadOk
    930  05ed		       20 1d 1c 	      jsr	ReadComplete
    931  05f0		       4c c2 02 	      jmp	NextIL
    932  05f3		       20 23 1d 	      jsr	popLN
    933  05f6		       4c c2 02 	      jmp	NextIL
    934  05f9							;=====================================================
    935  05f9							; Get a line of text from the user, convert to a
    936  05f9							; number, leave on top of stack.
    937  05f9							;
    938  05f9				   iINNUM
    939  05f9		       a9 01		      lda	#GOSUB_RTN
    940  05fb		       20 fa 1c 	      jsr	pushLN
    941  05fe		       b0 ea		      bcs	iReadErr	; Stack over flow error
    942  0600							;
    943  0600		       a9 3f		      lda	#'?
    944  0602		       a2 00		      ldx	#0	;Wait for complete
    945  0604		       20 fd 1b 	      jsr	GetLine
    946  0607		       20 92 1b 	      jsr	getDecimal
    947  060a		       20 e0 1c 	      jsr	pushR0	;put onto stack
    948  060d		       b0 db		      bcs	iReadErr	;StackOverflow error
    949  060f							;
    950  060f		       4c 2b 06 	      jmp	ExitIn
    951  0612							;
    952  0612							;=====================================================
    953  0612							; Get a line of text from the user, convert to a
    954  0612							; character value , leave on top of stack. up to 2 characters
    955  0612							;
    956  0612				   iINSTR
    957  0612		       a9 01		      lda	#GOSUB_RTN
    958  0614		       20 fa 1c 	      jsr	pushLN
    959  0617		       b0 d1		      bcs	iReadErr	; Stack overflow error
    960  0619		       a9 3f		      lda	#'?
    961  061b		       a2 00		      ldx	#0	;wait for read complete
    962  061d		       20 fd 1b 	      jsr	GetLine
    963  0620		       b1 4f		      lda	(CURPTR),y
    964  0622		       85 52		      sta	R0
    965  0624		       a9 00		      lda	#0
    966  0626		       85 53		      sta	R0+1
    967  0628		       20 e0 1c 	      jsr	pushR0	;put onto stack
    968  062b				   ExitIn
    969  062b		       20 23 1d 	      jsr	popLN
    970  062e		       4c c2 02 	      jmp	NextIL
    971  0631							;
    972  0631							;
    973  0631							;=====================================================
    974  0631							; Stop the currently running program.	Actually very
    975  0631							; simple to do... clear the RunMode flag, then set the
    976  0631							; ILPC to the standard handler and continue running.
    977  0631							;
    978  0631		       a9 00	   iFIN       lda	#0
    979  0633		       85 5b		      sta	RunMode
    980  0635		       20 76 17 	      jsr	taskReset
    981  0638							;
    982  0638		       ad 9b 2f 	      lda	errGoto
    983  063b		       85 43		      sta	ILPC
    984  063d		       ad 9c 2f 	      lda	errGoto+1
    985  0640		       85 44		      sta	ILPC+1
    986  0642		       4c c2 02 	      jmp	NextIL
    987  0645							;
    988  0645							;=====================================================
    989  0645							; Handle the ERR opcode.  Following the instruction is
    990  0645							; a 16 bit error number.  Print an error message, and
    991  0645							; if we're in run mode, print the line number.  Stop
    992  0645							; program execution and return to the initial state.
    993  0645							;
    994  0645		       20 e3 1a    iERR       jsr	getILWord	;get err code
    995  0648		       20 4e 06 	      jsr	DisplayError
    996  064b		       4c a7 06 	      jmp	iErrComplete
    997  064e							;
    998  064e							; Enter here with the error code in X (LSB) and A (MSB).
    999  064e							;
   1000  064e				   DisplayError
   1001  064e		       86 52		      stx	R0
   1002  0650		       85 53		      sta	R0+1
   1003  0652							;
   1004  0652		       20 22 14 	      jsr	puts
      0  0655					      db	CR,LF,"Error ",0
      1  0655		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
   1006  065e		       20 53 13 	      jsr	PrintDecimal
   1007  0661							;
   1008  0661		       a5 5b		      lda	RunMode	;running?
   1009  0663		       f0 3b		      beq	iERR3	;nope
   1010  0665		       20 22 14 	      jsr	puts
      0  0668					      db	" at line ",0
      1  0668		       20 61 74 20*	      .byte.b	" at line ",0
   1012  0672		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
   1013  0674				   iErr2a
   1014  0674		       b1 4f		      lda	(CURPTR),y
   1015  0676		       85 52		      sta	R0
   1016  0678		       c8		      iny
   1017  0679		       b1 4f		      lda	(CURPTR),y
   1018  067b		       85 53		      sta	R0+1
   1019  067d		       20 53 13 	      jsr	PrintDecimal
   1020  0680		       20 22 14 	      jsr	puts
      0  0683					      db	":",0
      1  0683		       3a 00		      .byte.b	":",0
   1022  0685		       a9 00		      lda	#0
   1023  0687		       85 53		      sta	R0+1
   1024  0689		       a5 51		      lda	CUROFF
   1025  068b		       18		      clc
   1026  068c		       e9 03		      sbc	#3
   1027  068e		       85 52		      sta	R0
   1028  0690		       20 53 13 	      jsr	PrintDecimal
   1029  0693		       20 22 14 	      jsr	puts
      0  0696					      db	":",0
      1  0696		       3a 00		      .byte.b	":",0
   1031  0698		       ad 55 26 	      lda	taskPtr
   1032  069b		       85 52		      sta	R0
   1033  069d		       20 53 13 	      jsr	PrintDecimal
   1034  06a0							;
   1035  06a0				   iERR3
   1036  06a0		       20 2b 1e 	      jsr	CRLF
   1037  06a3		       60		      rts
   1038  06a4
   1039  06a4				   iErr2
   1040  06a4		       20 4e 06 	      jsr	DisplayError
   1041  06a7
   1042  06a7				   iErrComplete
   1043  06a7		       20 6e 17 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1044  06aa		       a9 00		      lda	#0
   1045  06ac		       85 5b		      sta	RunMode	;fall through...
   1046  06ae							;
   1047  06ae							;=====================================================
   1048  06ae							; Reset the IL to be back at the idle loop.  Does not
   1049  06ae							; clear variables so the user can see what state
   1050  06ae							; the program is in.
   1051  06ae							;
   1052  06ae		       a9 00	   ResetIL    lda	#0
   1053  06b0		       85 47		      sta	ILSTACKPTR
   1054  06b2		       ad 9b 2f 	      lda	errGoto
   1055  06b5		       85 43		      sta	ILPC
   1056  06b7		       ad 9c 2f 	      lda	errGoto+1
   1057  06ba		       85 44		      sta	ILPC+1
   1058  06bc		       4c c2 02 	      jmp	NextIL
   1059  06bf
   1060  06bf							;
   1061  06bf							;=====================================================
   1062  06bf							; Pop two items off stack, add them, then place the
   1063  06bf							; result back onto the stack.
   1064  06bf							;
   1065  06bf		       20 72 1d    iADD       jsr	popR0
   1066  06c2		       20 8a 1d 	      jsr	popR1
   1067  06c5				   iADDfast
   1068  06c5		       18		      clc
   1069  06c6		       a5 52		      lda	R0
   1070  06c8		       65 54		      adc	R1
   1071  06ca		       85 52		      sta	R0
   1072  06cc		       a5 53		      lda	R0+1
   1073  06ce		       65 55		      adc	R1+1
   1074  06d0		       85 53		      sta	R0+1
   1075  06d2		       4c 3d 07 	      jmp	pushR0nextIl
   1076  06d5							;
   1077  06d5							;=====================================================
   1078  06d5							; Pop two items off the stack.  Subtract the top of
   1079  06d5							; stack from the lower entry.
   1080  06d5							;
   1081  06d5		       20 8a 1d    iSUB       jsr	popR1
   1082  06d8		       20 72 1d 	      jsr	popR0
   1083  06db		       38		      sec
   1084  06dc		       a5 52		      lda	R0
   1085  06de		       e5 54		      sbc	R1
   1086  06e0		       85 52		      sta	R0
   1087  06e2		       a5 53		      lda	R0+1
   1088  06e4		       e5 55		      sbc	R1+1
   1089  06e6		       85 53		      sta	R0+1
   1090  06e8		       4c 3d 07 	      jmp	pushR0nextIl
   1091  06eb							;
   1092  06eb							;=====================================================
   1093  06eb							; Negate the top of stack.
   1094  06eb							;
   1095  06eb		       20 72 1d    iNEG       jsr	popR0
   1096  06ee		       a5 52		      lda	R0
   1097  06f0		       49 ff		      eor	#$ff
   1098  06f2		       85 52		      sta	R0
   1099  06f4		       a5 53		      lda	R0+1
   1100  06f6		       49 ff		      eor	#$ff
   1101  06f8		       85 53		      sta	R0+1
   1102  06fa		       e6 52		      inc	R0
   1103  06fc		       d0 02		      bne	iNEG2
   1104  06fe		       e6 53		      inc	R0+1
   1105  0700		       4c 3d 07    iNEG2      jmp	pushR0nextIl
   1106  0703							;
   1107  0703							;=====================================================
   1108  0703							; Multiply top two items on the stack, put the results
   1109  0703							; on top.  This uses the algorithm documented on page
   1110  0703							; 115 of "Microprocessor Programming for Computer
   1111  0703							; Hobbyists" by Neill Graham.
   1112  0703							;
   1113  0703		       20 09 07    iMUL       jsr	iMultiply
   1114  0706		       4c c2 02 	      jmp	NextIL
   1115  0709
   1116  0709				   iMultiply
   1117  0709		       20 72 1d 	      jsr	popR0	;AC
   1118  070c		       20 8a 1d 	      jsr	popR1	;OP
   1119  070f							;
   1120  070f		       a5 52		      lda	R0
   1121  0711		       85 56		      sta	MQ
   1122  0713		       a5 53		      lda	R0+1
   1123  0715		       85 57		      sta	MQ+1
   1124  0717		       a9 00		      lda	#0	;clear result
   1125  0719		       85 52		      sta	R0
   1126  071b		       85 53		      sta	R0+1
   1127  071d							;
   1128  071d		       a2 10		      ldx	#16	;number of bits in value
   1129  071f		       06 52	   multloop   asl	R0
   1130  0721		       26 53		      rol	R0+1
   1131  0723		       06 56		      asl	MQ
   1132  0725		       26 57		      rol	MQ+1
   1133  0727		       90 0d		      bcc	multno	;skip add if no carry
   1134  0729							;
   1135  0729							; Add R1 back into R0
   1136  0729							;
   1137  0729		       18		      clc
   1138  072a		       a5 52		      lda	R0
   1139  072c		       65 54		      adc	R1
   1140  072e		       85 52		      sta	R0
   1141  0730		       a5 53		      lda	R0+1
   1142  0732		       65 55		      adc	R1+1
   1143  0734		       85 53		      sta	R0+1
   1144  0736							;
   1145  0736		       ca	   multno     dex		;did all bits yet?
   1146  0737		       d0 e6		      bne	multloop
   1147  0739		       20 e0 1c 	      jsr	pushR0	;OP
   1148  073c		       60		      rts
   1149  073d							;
   1150  073d				   pushR0nextIl
   1151  073d		       20 e0 1c 	      jsr	pushR0	;OP
   1152  0740		       4c c2 02 	      jmp	NextIL
   1153  0743							;
   1154  0743							;=====================================================
   1155  0743							; Divide the top of stack into the next to top item.
   1156  0743							; Leave results on stack.  Taken from:
   1157  0743							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1158  0743							;
   1159  0743							; R0 = R0 / R1
   1160  0743							; Remainder is in MQ
   1161  0743							;
   1162  0743		       20 5d 07    iDIV       jsr	iDoDiv
   1163  0746		       20 f3 1d 	      jsr	RestoreSigns
   1164  0749		       4c 3d 07 	      jmp	pushR0nextIl
   1165  074c
   1166  074c		       20 5d 07    iMOD       jsr	iDoDiv
   1167  074f		       20 f3 1d 	      jsr	RestoreSigns
   1168  0752		       a5 56		      lda	MQ
   1169  0754		       85 52		      sta	R0
   1170  0756		       a5 57		      lda	MQ+1
   1171  0758		       85 53		      sta	R0+1
   1172  075a		       4c 3d 07 	      jmp	pushR0nextIl
   1173  075d
   1174  075d				   iDoDiv
   1175  075d		       20 8a 1d 	      jsr	popR1
   1176  0760		       20 72 1d 	      jsr	popR0
   1177  0763							;
   1178  0763							; Check for divide by zero
   1179  0763							;
   1180  0763
   1181  0763				   iDivNoPop
   1182  0763		       a5 54		      lda	R1
   1183  0765		       05 55		      ora	R1+1
   1184  0767		       f0 29		      beq	divby0
   1185  0769							;
   1186  0769		       20 b8 1d 	      jsr	SaveSigns
   1187  076c		       a9 00		      lda	#0	;preset remainder to 0
   1188  076e		       85 56		      sta	MQ
   1189  0770		       85 57		      sta	MQ+1
   1190  0772		       a2 10		      ldx	#16	;repeat for each bit: ...
   1191  0774				   divloop
   1192  0774		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1193  0776		       26 53		      rol	R0+1
   1194  0778		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1195  077a		       26 57		      rol	MQ+1
   1196  077c		       a5 56		      lda	MQ
   1197  077e		       38		      sec
   1198  077f		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1199  0781		       a8		      tay		;lb result -> Y, for we may need it later
   1200  0782		       a5 57		      lda	MQ+1
   1201  0784		       e5 55		      sbc	R1+1
   1202  0786		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1203  0788
   1204  0788		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1205  078a		       84 56		      sty	MQ
   1206  078c		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1207  078e
   1208  078e		       ca	   skip       dex
   1209  078f		       d0 e3		      bne	divloop
   1210  0791		       60		      rts
   1211  0792							;
   1212  0792							; Indicate divide-by-zero error
   1213  0792							;
   1214  0792		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1215  0794		       a9 00		      lda	#0
   1216  0796		       4c a4 06 	      jmp	iErr2
   1217  0799							;
   1218  0799							;=====================================================
   1219  0799							; This pops the top two items off the stack.  The top
   1220  0799							; item is a data value and the other is an ABSOLUTE address.
   1221  0799							;Save the value into that address.
   1222  0799							;
   1223  0799		       98	   iSTORE     tya
   1224  079a		       48		      pha
   1225  079b		       20 72 1d 	      jsr	popR0	;data
   1226  079e		       20 8a 1d 	      jsr	popR1	;Storage location
   1227  07a1		       a0 00		      ldy	#0
   1228  07a3		       a5 52		      lda	R0
   1229  07a5		       91 54		      sta	(R1),y
   1230  07a7		       a5 53		      lda	R0+1
   1231  07a9		       c8		      iny
   1232  07aa		       91 54		      sta	(R1),y
   1233  07ac		       68		      pla
   1234  07ad		       a8		      tay
   1235  07ae		       4c c2 02 	      jmp	NextIL
   1236  07b1							;
   1237  07b1							;=====================================================
   1238  07b1							; Replaces the top of stack with the variable whose
   1239  07b1							; absolute address it represents.
   1240  07b1							;
   1241  07b1		       98	   iIND       tya
   1242  07b2		       48		      pha
   1243  07b3		       20 8a 1d 	      jsr	popR1
   1244  07b6		       a0 00		      ldy	#0
   1245  07b8		       b1 54		      lda	(R1),y
   1246  07ba		       85 52		      sta	R0
   1247  07bc		       c8		      iny
   1248  07bd		       b1 54		      lda	(R1),y
   1249  07bf		       85 53		      sta	R0+1
   1250  07c1		       68		      pla
   1251  07c2		       a8		      tay
   1252  07c3		       4c 3d 07 	      jmp	pushR0nextIl
   1253  07c6							;
   1254  07c6							;=====================================================
   1255  07c6							; Get the array index from top of stack get Current variable
   1256  07c6							; address from next on stack, add the offset
   1257  07c6							; push the result back onto the stack
   1258  07c6				   iArray
   1259  07c6		       20 72 1d 	      jsr	popR0	; Get the array index
   1260  07c9		       20 8a 1d 	      jsr	popR1	; Get the Variable address
   1261  07cc
   1262  07cc		       18		      clc		; Multiplythe value by 2
   1263  07cd		       26 52		      rol	R0	; Do the multiply
   1264  07cf		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1265  07d1		       18		      clc
   1266  07d2		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1267  07d4		       65 52		      adc	R0
   1268  07d6		       85 52		      sta	R0
   1269  07d8		       a5 55		      lda	R1+1
   1270  07da		       65 53		      adc	R0+1
   1271  07dc		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1272  07de		       20 e0 1c 	      jsr	pushR0	; Push R0 assume it is correct
   1273  07e1
   1274  07e1		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1275  07e3		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1276  07e5		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1277  07e7		       a5 55		      lda	R1+1
   1278  07e9		       c5 42		      cmp	VARIABLES+1
   1279  07eb		       d0 1c		      bne	iArrayAtTest
   1280  07ed		       18		      clc
   1281  07ee		       a9 34		      lda	#52	; add the max offset that is valid
   1282  07f0		       65 54		      adc	R1	; update to be the largest offset that is valid
   1283  07f2		       85 54		      sta	R1
   1284  07f4		       a9 00		      lda	#0
   1285  07f6		       65 55		      adc	R1+1
   1286  07f8		       85 55		      sta	R1+1
   1287  07fa				   iArrayVerify 		; try to enforce some sanity to using arrays
   1288  07fa		       a5 53		      lda	R0+1
   1289  07fc		       c5 55		      cmp	R1+1
   1290  07fe		       d0 04		      bne	iArrayDecide
   1291  0800		       a5 52		      lda	R0
   1292  0802		       c5 54		      cmp	R1
   1293  0804				   iArrayDecide
   1294  0804		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1295  0806		       4c c2 02 	      jmp	NextIL
   1296  0809
   1297  0809				   iArrayAtTest
   1298  0809		       ad b2 2f 	      lda	HighMem
   1299  080c		       85 54		      sta	R1
   1300  080e		       ad b3 2f 	      lda	HighMem+1
   1301  0811		       85 55		      sta	R1+1
   1302  0813		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1303  0815
   1304  0815							; Get here if array index is out of range
   1305  0815		       20 72 1d    iArrayError jsr	popR0
   1306  0818		       a9 00		      lda	#0
   1307  081a		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1308  081c		       4c a4 06 	      jmp	iErr2
   1309  081f							;
   1310  081f							;=====================================================
   1311  081f							; List the current BASIC program in memory.  Uses R0,
   1312  081f							; tempIly, and dpl.
   1313  081f							;
   1314  081f		       20 5f 1f    iLST       jsr	SetOutConsole
   1315  0822		       ad ae 2f    iLST2      lda	ProgramStart
   1316  0825		       85 59		      sta	dpl
   1317  0827		       ad af 2f 	      lda	ProgramStart+1
   1318  082a		       85 5a		      sta	dpl+1
   1319  082c							;
   1320  082c							; dpl/dph point to the current line.  See if we're at
   1321  082c							; the end of the program.
   1322  082c							;
   1323  082c		       a5 59	   iLSTloop   lda	dpl
   1324  082e		       cd b0 2f 	      cmp	ProgramEnd
   1325  0831		       d0 07		      bne	iLstNotEnd
   1326  0833		       a5 5a		      lda	dpl+1
   1327  0835		       cd b1 2f 	      cmp	ProgramEnd+1
   1328  0838		       f0 15		      beq	iLstdone
   1329  083a							;
   1330  083a		       20 ba 14    iLstNotEnd jsr	PrintProgramLine
   1331  083d							;		  ldy	  #1		  ;Change:  Skip first byte length
   1332  083d							;		  lda	  (dpl),y	  ;line number LSB
   1333  083d							;		  sta	  R0
   1334  083d							;		  iny
   1335  083d							;		  lda	  (dpl),y		 ;line number MSB
   1336  083d							;		  sta	  R0+1
   1337  083d							;		  iny
   1338  083d							;		  sty	  tempIlY
   1339  083d							;		  jsr	  PrintDecimal
   1340  083d							;		  lda	  #SPACE
   1341  083d							;		  jsr	  VOUTCH
   1342  083d							;		  ldy	  tempIlY
   1343  083d							;iLSTl2	  lda	  (dpl),y
   1344  083d							;		  beq	  iLST3 	  ;end of this line 0 value
   1345  083d							;		  sty	  tempIlY
   1346  083d							;		  jsr	  VOUTCH
   1347  083d							;		  ldy	  tempIlY
   1348  083d							;		  iny
   1349  083d							;		  bne	  iLSTl2	  ;do next char
   1350  083d							;
   1351  083d							; End of this line.  Print CR/LF, then move to the
   1352  083d							; next line.
   1353  083d							;
   1354  083d		       a0 00	   iLST3      ldy	#0	;Move to next line
   1355  083f		       b1 59		      lda	(dpl),y	;Current line length
   1356  0841		       18		      clc		;Clear the carry flag
   1357  0842							;		  tya
   1358  0842		       65 59		      adc	dpl	;Add the offset to the pointer
   1359  0844		       85 59		      sta	dpl	;Save the new value
   1360  0846		       a5 5a		      lda	dpl+1	;Next byte
   1361  0848		       69 00		      adc	#0	;ad in the carry if any
   1362  084a		       85 5a		      sta	dpl+1	;Save it
   1363  084c							;
   1364  084c							; Have to manually do CR/LF so it uses the vectored
   1365  084c							; output function.
   1366  084c							;
   1367  084c							;		  lda	  #CR
   1368  084c							;		  jsr	  VOUTCH
   1369  084c							;		  lda	  #LF
   1370  084c							;		  jsr	  VOUTCH
   1371  084c		       4c 2c 08 	      jmp	iLSTloop	;do next line
   1372  084f							;
   1373  084f		       20 5f 1f    iLstdone   jsr	SetOutConsole
   1374  0852		       4c c2 02 	      jmp	NextIL
   1375  0855							;
   1376  0855							;=====================================================
   1377  0855							; Get a line of text into LINBUF.  Terminate with a
   1378  0855							; null byte.
   1379  0855							;
   1380  0855				   iGETLINE
   1381  0855		       a9 3e		      lda	#'>	;prompt character
   1382  0857		       a6 00		      ldx	0	;Wait for read to complete
   1383  0859		       20 fd 1b 	      jsr	GetLine
   1384  085c							;
   1385  085c		       a9 00		      lda	#0
   1386  085e		       85 5b		      sta	RunMode
   1387  0860				   iGetParseLine
   1388  0860							; lda	   CUROFF
   1389  0860							; pha
   1390  0860		       20 c3 10 	      jsr	ParseInputLine
   1391  0863							; pla
   1392  0863							;  sta     CUROFF
   1393  0863		       a9 c0		      lda	#TOKENBUFFER&$FF
   1394  0865		       85 4f		      sta	CURPTR
   1395  0867		       a9 0f		      lda	#TOKENBUFFER>>8
   1396  0869		       85 50		      sta	CURPTR+1
   1397  086b		       a9 01		      lda	#1
   1398  086d		       85 51		      sta	CUROFF
   1399  086f		       4c c2 02 	      jmp	NextIL
   1400  0872							;
   1401  0872							;=====================================================
   1402  0872							; This is called when the input buffer contains a line
   1403  0872							; typed in by the user that starts with a line number.
   1404  0872							; Insert the line into the program or delete the line
   1405  0872							; if there is nothing after the line number,
   1406  0872							;
   1407  0872				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1408  0872		       ad c1 0f 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1409  0875		       85 52		      sta	R0	; place the number into R0
   1410  0877		       ad c2 0f 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1411  087a		       85 53		      STA	R0+1	; Place it into
   1412  087c							;
   1413  087c							; Now find the line OR the next higher line OR the
   1414  087c							; end of the program.
   1415  087c							;
   1416  087c		       20 2c 1b 	      jsr	findLine	; Look for the line number in the current program
   1417  087f							; Returns Z and curptr point to the line if found
   1418  087f							; Returns C and curptr at next higher line if not found and there is a higher line
   1419  087f							; Returns ZC clear and curptr to end of program if higher than all other lines
   1420  087f							;
   1421  087f							; If the line exists, it needs to be removed.
   1422  087f							;
   1423  087f		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1424  0881							;
   1425  0881							; Get length of line to be removed, we fall thru to here if we find a matching line
   1426  0881							;
   1427  0881							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1428  0881		       a0 00		      ldy	#0
   1429  0883		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1430  0885		       a8		      tay
   1431  0886							;If it is equal we delete the line and replace it, get length
   1432  0886							;then adjust all program line after up or down depending on len of line
   1433  0886							;If next higher then just move everythimg down by length bytes
   1434  0886							;This call will return how many bytes in the line we found
   1435  0886		       8c ab 2f 	      sty	lineLength	;Save the length of the line we found
   1436  0889							;
   1437  0889							; Compute the new end of the program first.
   1438  0889							;
   1439  0889		       38		      sec		;Set the carry bit
   1440  088a		       ad b0 2f 	      lda	ProgramEnd	;Get low byte of program end
   1441  088d		       ed ab 2f 	      sbc	lineLength	;Subtract the length of the current line
   1442  0890		       8d b0 2f 	      sta	ProgramEnd	;save it
   1443  0893		       ad b1 2f 	      lda	ProgramEnd+1
   1444  0896		       e9 00		      sbc	#0	;Process the carry
   1445  0898		       8d b1 2f 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1446  089b							;
   1447  089b							; Copy CURPTR into R1 for working
   1448  089b							;
   1449  089b		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1450  089d		       85 54		      sta	R1
   1451  089f		       a5 50		      lda	CURPTR+1
   1452  08a1		       85 55		      sta	R1+1
   1453  08a3							;
   1454  08a3							; See if we're at the end.
   1455  08a3							;
   1456  08a3		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1457  08a5		       cd b0 2f 	      cmp	ProgramEnd
   1458  08a8		       d0 07		      bne	InsDelLoop
   1459  08aa		       a5 55		      lda	R1+1
   1460  08ac		       cd b1 2f 	      cmp	ProgramEnd+1
   1461  08af		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1462  08b1							;
   1463  08b1							; Move one byte, move to next location.
   1464  08b1							;
   1465  08b1		       ac ab 2f    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1466  08b4		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1467  08b6		       b1 54		      lda	(R1),y
   1468  08b8		       a0 00		      ldy	#0
   1469  08ba		       91 54		      sta	(R1),y
   1470  08bc		       e6 54		      inc	R1
   1471  08be		       d0 e3		      bne	InsDelChk
   1472  08c0		       e6 55		      inc	R1+1
   1473  08c2		       4c a3 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1474  08c5							;
   1475  08c5							; Deletion is done.
   1476  08c5							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1477  08c5							;
   1478  08c5				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1479  08c5		       ad c0 0f 	      lda	TOKENBUFFER	; Get the length
   1480  08c8		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1481  08ca							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1482  08ca		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1483  08cc							;
   1484  08cc							; CURPTR points to where the line will be inserted.
   1485  08cc							;
   1486  08cc							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1487  08cc		       ae c0 0f 	      ldx	TOKENBUFFER
   1488  08cf		       8e ab 2f 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1489  08d2							;
   1490  08d2		       ad b0 2f 	      lda	ProgramEnd	;Load the start address for the copy
   1491  08d5							;At this point curptr still contains the location we will insert data
   1492  08d5		       85 5c		      sta	FROM
   1493  08d7		       ad b1 2f 	      lda	ProgramEnd+1
   1494  08da		       85 5d		      sta	FROM+1
   1495  08dc							;
   1496  08dc		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1497  08de		       b1 5c		      lda	(FROM),y
   1498  08e0		       ac ab 2f 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1499  08e3		       91 5c		      sta	(FROM),y	;Save the new byte
   1500  08e5							;
   1501  08e5		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1502  08e7		       c5 4f		      cmp	CURPTR
   1503  08e9		       d0 06		      bne	mvUpMore
   1504  08eb		       a5 5d		      lda	FROM+1
   1505  08ed		       c5 50		      cmp	CURPTR+1
   1506  08ef		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1507  08f1							;
   1508  08f1							; Not done yet
   1509  08f1							;
   1510  08f1		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1511  08f3		       d0 02		      bne	mvUpMore2
   1512  08f5		       c6 5d		      dec	FROM+1
   1513  08f7		       c6 5c	   mvUpMore2  dec	FROM
   1514  08f9		       4c dc 08 	      jmp	mvup1	;Loop until everything is moved
   1515  08fc							;
   1516  08fc							; All done with copy.
   1517  08fc							;
   1518  08fc				   mvUpDone
   1519  08fc		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1520  08fd		       ad ab 2f 	      lda	lineLength	;Number of bytes to copy from line buff
   1521  0900		       6d b0 2f 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1522  0903		       8d b0 2f 	      sta	ProgramEnd
   1523  0906		       ad b1 2f 	      lda	ProgramEnd+1
   1524  0909		       69 00		      adc	#0
   1525  090b		       8d b1 2f 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1526  090e							;
   1527  090e							;===================jlit use length before line newline
   1528  090e
   1529  090e		       a0 00		      ldy	#0	;Set offset of copy
   1530  0910							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1531  0910							;		  sta	  (CURPTR),y	  ;Store the length
   1532  0910							;		  iny
   1533  0910							;		  lda	  R0		  ;Store the line number next
   1534  0910							;		  sta	  (CURPTR),y
   1535  0910							;		  iny
   1536  0910							;		  lda	  R0+1
   1537  0910							;		  sta	  (CURPTR),y
   1538  0910							;		  iny
   1539  0910							;
   1540  0910							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1541  0910		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1542  0912				   mvUpLoop2
   1543  0912							;		  lda	  LINBUF,x	 ;get a byte
   1544  0912		       bd c0 0f 	      lda	TOKENBUFFER,x	;get a byte
   1545  0915		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1546  0917
   1547  0917		       e8		      inx
   1548  0918		       ec c0 0f 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1549  091b		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1550  091d		       c8		      iny
   1551  091e		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1552  0920							;
   1553  0920		       4c c2 02    mvUpFini   jmp	NextIL
   1554  0923							;
   1555  0923							;=====================================================
   1556  0923							; Pops the top value of the ILPC stack and stores it
   1557  0923							; in ILPC.  Ie, return from an IL subroutine.
   1558  0923							;
   1559  0923		       20 1a 1b    iRTN       jsr	popILPC
   1560  0926		       4c c2 02 	      jmp	NextIL
   1561  0929							;
   1562  0929							;=====================================================
   1563  0929							; NLINE print a newline
   1564  0929							;
   1565  0929		       20 2b 1e    iNLINE     jsr	CRLF	;user supplied sub
   1566  092c		       4c c2 02 	      jmp	NextIL
   1567  092f							;
   1568  092f							;=====================================================
   1569  092f							; This saves the current ILPC value on the stack, then
   1570  092f							; jumps to the address specified by the next two bytes.
   1571  092f							;
   1572  092f		       20 fd 1a    iCALL      jsr	pushILPC	;save ILPC
   1573  0932		       90 03		      bcc	iJMP
   1574  0934		       4c dc 0b 	      jmp	ErrStkOver	; Check if there was an error
   1575  0937							;
   1576  0937							; Jmp to a specific location in the IL code.  The new
   1577  0937							; address immediately follows the opcode.
   1578  0937							;
   1579  0937		       20 e3 1a    iJMP       jsr	getILWord
   1580  093a		       86 43		      stx	ILPC
   1581  093c		       85 44		      sta	ILPC+1
   1582  093e		       4c c2 02 	      jmp	NextIL
   1583  0941
   1584  0941
   1585  0941							;
   1586  0941							;=====================================================
   1587  0941							; Push the next two bytes onto the arithmetic stack.
   1588  0941							;
   1589  0941		       20 e7 1a    iSetR2     jsr	getILByte
   1590  0944		       85 58		      sta	R2
   1591  0946		       4c c2 02 	      jmp	NextIL
   1592  0949							;
   1593  0949							;=====================================================
   1594  0949							; Push the next two bytes onto the arithmetic stack.
   1595  0949							;
   1596  0949		       20 e3 1a    iLIT       jsr	getILWord
   1597  094c		       86 52		      stx	R0
   1598  094e		       85 53		      sta	R0+1
   1599  0950		       20 e0 1c 	      jsr	pushR0
   1600  0953		       4c c2 02 	      jmp	NextIL
   1601  0956							;
   1602  0956							;=====================================================
   1603  0956							; Initialize all variables for a single task.	Ie, set to zero.
   1604  0956							;
   1605  0956		       98	   subVINIT   tya
   1606  0957		       48		      pha
   1607  0958
   1608  0958		       a9 00		      lda	#0
   1609  095a		       a0 00		      ldy	#0
   1610  095c		       91 41	   Vinit2     sta	(VARIABLES),y
   1611  095e		       c8		      iny
   1612  095f		       c0 34		      cpy	#(VARIABLESSIZE * 2 - 2)	; skip the old exit code
   1613  0961		       90 f9		      bcc	Vinit2
   1614  0963
   1615  0963		       68		      pla
   1616  0964		       a8		      tay
   1617  0965		       60		      rts
   1618  0966
   1619  0966		       20 82 0d    iVINIT     jsr	Compile	; compile line numbers to memory pointers
   1620  0969		       20 56 09 	      jsr	subVINIT
   1621  096c		       4c c2 02 	      jmp	NextIL
   1622  096f							;
   1623  096f							;=====================================================
   1624  096f							; Set the address of the error handler.  After any
   1625  096f							; error, set to the ILPC to the specified location.
   1626  096f							;
   1627  096f		       20 e3 1a    iERRGOTO   jsr	getILWord
   1628  0972		       8e 9b 2f 	      stx	errGoto
   1629  0975		       8d 9c 2f 	      sta	errGoto+1
   1630  0978		       4c c2 02 	      jmp	NextIL
   1631  097b							;
   1632  097b							;=====================================================
   1633  097b							; TST is followed by an 8 bit signed offset, then a
   1634  097b							; null terminated string.  Compare the string against
   1635  097b							; the string starting at (CURPTR),CUROFF.  If the
   1636  097b							; strings match, continue executing the next IL
   1637  097b							; opcode.  Else, add the offset to ILPC.
   1638  097b							;
   1639  097b		       20 e7 1a    iTST       jsr	getILByte	;Get the relative jump address
   1640  097e		       8d aa 2f 	      sta	offset	;save it to use if test faile
   1641  0981		       20 ca 1c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1642  0984
   1643  0984		       a4 51		      ldy	CUROFF
   1644  0986		       84 59		      sty	dpl	;save for later
   1645  0988							;
   1646  0988		       20 e7 1a    iTSTloop   jsr	getILByte	;get next char
   1647  098b		       f0 11		      beq	iTSTm	;match!
   1648  098d		       a4 59		      ldy	dpl
   1649  098f		       d1 4f		      cmp	(CURPTR),y
   1650  0991		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1651  0993		       09 20		      ora	#$20	; lets allow lowercase as well
   1652  0995		       d1 4f		      cmp	(CURPTR),y
   1653  0997		       d0 23		      bne	iTSTfail	;mismatch
   1654  0999		       c8	   iTSTUpper  iny
   1655  099a		       84 59		      sty	dpl
   1656  099c		       d0 ea		      bne	iTSTloop
   1657  099e							;
   1658  099e							; It's a match!  Clean up a bit.
   1659  099e							;
   1660  099e		       a4 59	   iTSTm      ldy	dpl
   1661  09a0		       84 51		      sty	CUROFF
   1662  09a2		       4c c2 02 	      jmp	NextIL
   1663  09a5
   1664  09a5							; Test for a single quote string
   1665  09a5		       20 e7 1a    iTSTStr    jsr	getILByte
   1666  09a8		       8d aa 2f 	      sta	offset
   1667  09ab		       20 ca 1c 	      jsr	saveIL
   1668  09ae		       a4 51		      ldy	CUROFF
   1669  09b0		       a9 22		      lda	#'"
   1670  09b2		       d1 4f		      cmp	(CURPTR),y
   1671  09b4		       d0 06		      bne	iTSTfail
   1672  09b6		       c8		      iny
   1673  09b7		       84 51		      sty	CUROFF
   1674  09b9		       4c e0 02 	      jmp	NextILStr
   1675  09bc							;
   1676  09bc							; Not a match, reset ILPC and then move to the
   1677  09bc							; offset.
   1678  09bc							;
   1679  09bc		       20 d5 1c    iTSTfail   jsr	restoreIL
   1680  09bf		       4c 8a 0b 	      jmp	tstBranch
   1681  09c2							;
   1682  09c2							;=================================================JLIT=
   1683  09c2							; Test if we have a let statement without the let keyword
   1684  09c2		       20 e7 1a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1685  09c5		       8d aa 2f 	      sta	offset	; Save the jump offset for fails
   1686  09c8		       20 ca 1c 	      jsr	saveIL	; save to restore when done if fail
   1687  09cb
   1688  09cb		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1689  09cd		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1690  09cf		       c9 01		      cmp	#kLet	; Is it a let keyword
   1691  09d1		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1692  09d3		       c9 80		      cmp	#tVa	; lets check for a variable
   1693  09d5		       90 e5		      bcc	iTSTfail	; Less than variable range
   1694  09d7		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1695  09d9		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1696  09db		       b0 df		      bcs	iTSTfail	; return it failed
   1697  09dd
   1698  09dd				   iTSTLETGOOD
   1699  09dd		       c8		      iny
   1700  09de		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1701  09e0				   iTSTGOODVAR
   1702  09e0		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1703  09e3
   1704  09e3							;=================================================JLIT=
   1705  09e3							; Test a byte at an indirect address
   1706  09e3							; fails if byte is not equal to the value at the address
   1707  09e3							; The tests an indirect byte and branches if true
   1708  09e3		       20 e7 1a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1709  09e6		       8d aa 2f 	      sta	offset	; Save the jump offset for fails
   1710  09e9		       20 ca 1c 	      jsr	saveIL	; save to restore when done if fail
   1711  09ec		       20 e3 1a 	      jsr	getILWord	; Get a word into RO
   1712  09ef		       86 52		      stx	R0
   1713  09f1		       85 53		      sta	R0+1
   1714  09f3		       20 e7 1a 	      jsr	getILByte	; Get byte into A
   1715  09f6		       a0 00		      ldy	#0
   1716  09f8		       d1 52		      cmp	(R0),y
   1717  09fa		       d0 03		      bne	iTSTByteNotEqual
   1718  09fc		       4c bc 09 	      jmp	iTSTfail
   1719  09ff
   1720  09ff				   iTSTByteNotEqual
   1721  09ff		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1722  0a02
   1723  0a02							;=================================================JLIT=
   1724  0a02							; Test a byte	branch if it fails
   1725  0a02		       20 e7 1a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1726  0a05		       8d aa 2f 	      sta	offset	; Save the jump offset for fails
   1727  0a08		       20 ca 1c 	      jsr	saveIL	; save to restore when done if fail
   1728  0a0b		       20 e7 1a 	      jsr	getILByte	; Get a word into RO
   1729  0a0e		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1730  0a10		       d1 4f		      cmp	(CURPTR),y
   1731  0a12		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1732  0a14		       4c bc 09 	      jmp	iTSTfail	; REcover and move on to next test
   1733  0a17
   1734  0a17				   iTSTBMatch
   1735  0a17		       c8		      iny
   1736  0a18		       84 51		      sty	CUROFF	; Point to the next byte
   1737  0a1a		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1738  0a1d
   1739  0a1d							;=================================================JLIT=
   1740  0a1d							; Test a byte	branch if it fails
   1741  0a1d		       20 e7 1a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1742  0a20		       8d aa 2f 	      sta	offset	; Save the jump offset for fails
   1743  0a23		       20 ca 1c 	      jsr	saveIL	; save to restore when done if fail
   1744  0a26		       20 e3 1a 	      jsr	getILWord	; Get a word into RO
   1745  0a29		       86 52		      stx	R0
   1746  0a2b		       85 53		      sta	R0+1
   1747  0a2d		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1748  0a2f		       8a		      txa
   1749  0a30		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1750  0a32		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1751  0a34		       4c bc 09 	      jmp	iTSTfail	; REcover and move on to next test
   1752  0a37		       c8	   iTSTWM1    iny
   1753  0a38		       a5 53		      lda	R0+1
   1754  0a3a		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1755  0a3c		       f0 03		      beq	iTSTWMatch
   1756  0a3e		       4c bc 09 	      jmp	iTSTfail
   1757  0a41
   1758  0a41				   iTSTWMatch
   1759  0a41		       c8		      iny
   1760  0a42		       84 51		      sty	CUROFF
   1761  0a44		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1762  0a47
   1763  0a47							;================================================jLIT=
   1764  0a47							;Test for end of line
   1765  0a47							;
   1766  0a47				   iTSTDONE
   1767  0a47		       20 e7 1a 	      jsr	getILByte
   1768  0a4a		       8d aa 2f 	      sta	offset
   1769  0a4d		       20 ca 1c 	      jsr	saveIL
   1770  0a50		       a4 51		      ldy	CUROFF
   1771  0a52		       84 59		      sty	dpl
   1772  0a54		       b1 4f		      lda	(CURPTR),y
   1773  0a56		       f0 0b		      beq	iTSTDONEtrue
   1774  0a58		       c9 e6		      cmp	#oColon
   1775  0a5a		       f0 07		      beq	iTSTDONEtrue
   1776  0a5c		       a4 59		      ldy	dpl
   1777  0a5e		       84 51		      sty	CUROFF
   1778  0a60		       4c bc 09 	      jmp	iTSTfail
   1779  0a63							;
   1780  0a63							; Advance to the next line
   1781  0a63							;
   1782  0a63				   iTSTDONEtrue
   1783  0a63		       4c c2 02 	      jmp	NextIL
   1784  0a66
   1785  0a66		       4c 8a 0b    tstBranchLink jmp	tstBranch
   1786  0a69							;
   1787  0a69							;=====================================================
   1788  0a69							; Inc and dec a variable , faster than a = a + 1
   1789  0a69				   iINCVAR
   1790  0a69		       20 72 1d 	      jsr	popR0
   1791  0a6c		       a0 00		      ldy	#0
   1792  0a6e		       18		      clc
   1793  0a6f		       a9 01		      lda	#1
   1794  0a71		       71 52		      adc	(R0),y
   1795  0a73		       91 52		      sta	(R0),y
   1796  0a75		       90 07		      bcc	iINCDONE
   1797  0a77		       c8		      iny
   1798  0a78		       a9 00		      lda	#0
   1799  0a7a		       71 52		      adc	(R0),y
   1800  0a7c		       91 52		      sta	(R0),y
   1801  0a7e				   iINCDONE
   1802  0a7e		       4c c2 02 	      jmp	NextIL
   1803  0a81
   1804  0a81				   iDECVAR
   1805  0a81		       20 72 1d 	      jsr	popR0
   1806  0a84		       a0 00		      ldy	#0
   1807  0a86		       38		      sec
   1808  0a87		       b1 52		      lda	(R0),y
   1809  0a89		       e9 01		      sbc	#1
   1810  0a8b		       91 52		      sta	(R0),y
   1811  0a8d		       c8		      iny
   1812  0a8e		       b1 52		      lda	(R0),y
   1813  0a90		       e9 00		      sbc	#0
   1814  0a92		       91 52		      sta	(R0),y
   1815  0a94		       4c c2 02 	      jmp	NextIL
   1816  0a97
   1817  0a97
   1818  0a97							;
   1819  0a97							;=====================================================
   1820  0a97							; TSTV is followed by an 8 bit signed offset.	If the
   1821  0a97							; value at (CURPTR),CUROFF appears to be a variable
   1822  0a97							; name, move to the next IL statement.  Else, add the
   1823  0a97							; offset to ILPC. Converted to use actual absolute memory addresses
   1824  0a97							; TSTVT Looks for the task context
   1825  0a97							;
   1826  0a97		       20 8a 1d    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1827  0a9a		       a9 00		      lda	#0
   1828  0a9c		       85 58		      sta	R2
   1829  0a9e		       f0 04		      beq	iTSTVV
   1830  0aa0
   1831  0aa0		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1832  0aa2		       85 58		      sta	R2
   1833  0aa4
   1834  0aa4		       20 e7 1a    iTSTVV     jsr	getILByte	;offset
   1835  0aa7		       8d aa 2f 	      sta	offset
   1836  0aaa							;
   1837  0aaa		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1838  0aac		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1839  0aae		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1840  0ab0		       4c 66 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1841  0ab3							;
   1842  0ab3				   iTSTVnext
   1843  0ab3		       c9 9d		      cmp	#tVat	;allow access to all unused memory as an array or integers
   1844  0ab5		       f0 42		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1845  0ab7
   1846  0ab7		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1847  0ab9		       f0 4e		      beq	iTSTVParm
   1848  0abb
   1849  0abb		       c9 9b		      cmp	#tVhat	; task exit code
   1850  0abd		       d0 04		      bne	iTSTV_A2Z
   1851  0abf		       a9 34		      lda	#TASKEXITCODE
   1852  0ac1		       d0 0b		      bne	iTSTVContinue
   1853  0ac3
   1854  0ac3				   iTSTV_A2Z
   1855  0ac3
   1856  0ac3		       c9 80		      cmp	#tVa
   1857  0ac5		       90 9f		      bcc	tstBranchLink
   1858  0ac7		       c9 9a		      cmp	#tVz+1
   1859  0ac9		       b0 9b		      bcs	tstBranchLink
   1860  0acb
   1861  0acb
   1862  0acb							;
   1863  0acb							; The condition is true, so convert to an index, push
   1864  0acb							; it onto the stack and continue running.
   1865  0acb							;
   1866  0acb		       29 7f		      and	#%01111111	;Mask off the high bit
   1867  0acd		       0a		      asl		;multiply by two
   1868  0ace
   1869  0ace				   iTSTVContinue
   1870  0ace		       c8		      iny
   1871  0acf		       84 51		      sty	CUROFF	;it is a valid variable
   1872  0ad1		       48		      pha
   1873  0ad2		       a5 58		      lda	R2
   1874  0ad4		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1875  0ad6
   1876  0ad6		       20 ca 1a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1877  0ad9		       a0 01		      ldy	#VARIABLEPOS
   1878  0adb		       b1 56		      lda	(MQ),y
   1879  0add		       85 52		      sta	R0
   1880  0adf		       c8		      iny
   1881  0ae0		       b1 56		      lda	(MQ),y
   1882  0ae2		       85 53		      sta	R0+1
   1883  0ae4		       4c ef 0a 	      jmp	iTSTVAddOffset
   1884  0ae7
   1885  0ae7				   iTSTVLocalValue
   1886  0ae7		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1887  0ae9		       85 52		      sta	R0
   1888  0aeb		       a5 42		      lda	VARIABLES+1
   1889  0aed		       85 53		      sta	R0+1
   1890  0aef
   1891  0aef				   iTSTVAddOffset
   1892  0aef		       68		      pla
   1893  0af0		       85 54		      sta	R1
   1894  0af2		       a9 00		      lda	#0
   1895  0af4		       85 55		      sta	R1+1
   1896  0af6
   1897  0af6				   iTSTVcontinue
   1898  0af6
   1899  0af6		       4c c5 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1900  0af9
   1901  0af9							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1902  0af9							; an array of integer values
   1903  0af9				   iTSTVat
   1904  0af9		       c8		      iny
   1905  0afa		       84 51		      sty	CUROFF	;it is a valid variable
   1906  0afc		       ad b0 2f 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1907  0aff		       85 52		      sta	R0
   1908  0b01		       ad b1 2f 	      lda	ProgramEnd+1
   1909  0b04		       85 53		      sta	R0+1
   1910  0b06		       4c 3d 07 	      jmp	pushR0nextIl	;place this onto the stack
   1911  0b09
   1912  0b09							; When we get parameters passed we can access them using the # variable with[]
   1913  0b09							; example #[0] #[1] etc, we dont check yet if there is too many
   1914  0b09				   iTSTVParm
   1915  0b09		       c8		      iny
   1916  0b0a		       84 51		      sty	CUROFF	;it is a valid variable
   1917  0b0c		       a5 48		      lda	MATHSTACK
   1918  0b0e		       85 52		      sta	R0
   1919  0b10		       a5 49		      lda	MATHSTACK+1
   1920  0b12		       85 53		      sta	R0+1
   1921  0b14		       4c 3d 07 	      jmp	pushR0nextIl
   1922  0b17
   1923  0b17							;
   1924  0b17							;=====================================================
   1925  0b17							; TSTL seems basically the same as TSTN, but leave the
   1926  0b17							; value in R0 instead of pushing onto stack.
   1927  0b17							; This tests for a valid line number
   1928  0b17							;
   1929  0b17		       20 e7 1a    iTSTL      jsr	getILByte
   1930  0b1a		       8d aa 2f 	      sta	offset
   1931  0b1d							;
   1932  0b1d		       a4 51		      ldy	CUROFF
   1933  0b1f		       b1 4f		      lda	(CURPTR),y
   1934  0b21		       c8		      iny
   1935  0b22		       11 4f		      ora	(CURPTR),y
   1936  0b24		       f0 06		      beq	iTSTLNotLineNo
   1937  0b26
   1938  0b26
   1939  0b26							; In Both cases we need to point to the first usefull byte to process.
   1940  0b26		       c8		      iny
   1941  0b27		       84 51		      sty	CUROFF
   1942  0b29		       4c c2 02 	      jmp	NextIL
   1943  0b2c				   iTSTLNotLineNo
   1944  0b2c		       c8		      iny
   1945  0b2d		       84 51		      sty	CUROFF
   1946  0b2f		       4c 8a 0b 	      jmp	tstBranch
   1947  0b32
   1948  0b32							;
   1949  0b32							;=====================================================
   1950  0b32							; TSTN checks for a number.  This is very simplistic;
   1951  0b32							; if the character is a digit, assume it's a number.
   1952  0b32							; Convert to a number and push it onto the stack.
   1953  0b32							;
   1954  0b32		       20 e7 1a    iTSTN      jsr	getILByte
   1955  0b35		       8d aa 2f 	      sta	offset
   1956  0b38							;
   1957  0b38		       a9 00		      lda	#0
   1958  0b3a		       85 59		      sta	dpl
   1959  0b3c		       a4 51		      ldy	CUROFF
   1960  0b3e				   chkType
   1961  0b3e		       b1 4f		      lda	(CURPTR),y
   1962  0b40		       c9 a2		      cmp	#tByte
   1963  0b42		       f0 0e		      beq	chkByte
   1964  0b44		       c9 a1		      cmp	#tInteger
   1965  0b46		       f0 16		      beq	chkInteger
   1966  0b48		       c9 eb		      cmp	#oMinus
   1967  0b4a		       d0 3e		      bne	tstBranch
   1968  0b4c		       e6 59		      inc	dpl
   1969  0b4e		       c8		      iny
   1970  0b4f		       4c 3e 0b 	      jmp	chkType
   1971  0b52
   1972  0b52				   chkByte
   1973  0b52		       a9 00		      lda	#0
   1974  0b54		       85 53		      sta	R0+1
   1975  0b56		       c8		      iny
   1976  0b57		       b1 4f		      lda	(CURPTR),y
   1977  0b59		       85 52		      sta	R0
   1978  0b5b		       c8		      iny
   1979  0b5c		       d0 0b		      bne	iTSTN_1
   1980  0b5e
   1981  0b5e				   chkInteger
   1982  0b5e		       c8		      iny
   1983  0b5f		       b1 4f		      lda	(CURPTR),y
   1984  0b61		       85 52		      sta	R0
   1985  0b63		       c8		      iny
   1986  0b64		       b1 4f		      lda	(CURPTR),y
   1987  0b66		       85 53		      sta	R0+1
   1988  0b68		       c8		      iny
   1989  0b69							;
   1990  0b69							; Check if it is negative and make it so
   1991  0b69							;
   1992  0b69				   iTSTN_1
   1993  0b69		       84 51		      sty	CUROFF
   1994  0b6b
   1995  0b6b		       a5 59		      lda	dpl
   1996  0b6d		       f0 18		      beq	iTSTN_2	;positive
   1997  0b6f							;
   1998  0b6f		       a5 52		      lda	R0
   1999  0b71		       05 53		      ora	R0+1
   2000  0b73		       f0 12		      beq	iTSTN_2	;zero
   2001  0b75
   2002  0b75							; Invert all the bits, then add one.
   2003  0b75							;
   2004  0b75		       a5 52		      lda	R0
   2005  0b77		       49 ff		      eor	#$ff
   2006  0b79		       85 52		      sta	R0
   2007  0b7b		       a5 53		      lda	R0+1
   2008  0b7d		       49 ff		      eor	#$ff
   2009  0b7f		       85 53		      sta	R0+1
   2010  0b81							;
   2011  0b81		       e6 52		      inc	R0
   2012  0b83		       d0 02		      bne	iTSTN_2
   2013  0b85		       e6 53		      inc	R0+1
   2014  0b87				   iTSTN_2
   2015  0b87		       20 3d 07 	      jsr	pushR0nextIl	;save onto stack
   2016  0b8a
   2017  0b8a							;
   2018  0b8a							; Common jump point for all TSTx instructions that
   2019  0b8a							; fail to meet the requirements.  This takes the
   2020  0b8a							; offset and adds/subtracts to/from ILPC.
   2021  0b8a							;
   2022  0b8a		       ad aa 2f    tstBranch  lda	offset	;get signed offset
   2023  0b8d		       10 0e		      bpl	tstPositive
   2024  0b8f							;
   2025  0b8f							; Do negative branch.	Do sign extension.
   2026  0b8f							;
   2027  0b8f		       18	   tstNegative clc
   2028  0b90		       65 43		      adc	ILPC
   2029  0b92		       85 43		      sta	ILPC
   2030  0b94							;		  bcc	  tstBothDone
   2031  0b94							;		  dec	  ILPC+1
   2032  0b94							;		  jmp	  NextIL
   2033  0b94
   2034  0b94		       a5 44		      lda	ILPC+1
   2035  0b96		       69 ff		      adc	#$ff
   2036  0b98		       85 44		      sta	ILPC+1
   2037  0b9a		       4c c2 02 	      jmp	NextIL	;keep going
   2038  0b9d							;
   2039  0b9d		       18	   tstPositive clc
   2040  0b9e		       65 43		      adc	ILPC
   2041  0ba0		       85 43		      sta	ILPC
   2042  0ba2		       90 02		      bcc	tstBothDone
   2043  0ba4		       e6 44		      inc	ILPC+1
   2044  0ba6				   tstBothDone
   2045  0ba6		       4c c2 02 	      jmp	NextIL
   2046  0ba9
   2047  0ba9							;
   2048  0ba9							;====================================================
   2049  0ba9							; Test for IRQ pending, and test if a break key pressed
   2050  0ba9							; Yes I know but this handles all sorts of irq/break issues
   2051  0ba9							;
   2052  0ba9		       20 e7 1a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2053  0bac		       8d aa 2f 	      sta	offset	; Store the not true jump address offset
   2054  0baf		       20 46 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2055  0bb2		       d0 03		      bne	irqNo	; z not set of no break found
   2056  0bb4		       4c 31 06 	      jmp	iFIN	; Exit out of run mode
   2057  0bb7		       ad 52 26    irqNo      lda	IRQPending
   2058  0bba		       f0 ce		      beq	tstBranch
   2059  0bbc		       c9 01		      cmp	#1	; only do this if set to first time
   2060  0bbe		       d0 ca		      bne	tstBranch
   2061  0bc0		       78		      sei		; disable the interupt until ireturn resets it
   2062  0bc1		       ee 52 26    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2063  0bc4		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2064  0bc6		       20 fa 1c 	      jsr	pushLN	; Push the next line to be executed
   2065  0bc9		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2066  0bcb		       ad 53 26 	      lda	IRQEntry	; Get the line number to branch to
   2067  0bce		       85 4f		      sta	CURPTR	; put line number into r0
   2068  0bd0		       ad 54 26 	      lda	IRQEntry+1
   2069  0bd3		       85 50		      sta	CURPTR+1
   2070  0bd5		       a9 03		      lda	#3	; Point to first byte of program text
   2071  0bd7		       85 51		      sta	CUROFF
   2072  0bd9		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2073  0bdc
   2074  0bdc		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2075  0bde		       a9 00		      lda	#0	; stop the execution
   2076  0be0		       4c a4 06 	      jmp	iErr2
   2077  0be3							;
   2078  0be3
   2079  0be3							;=====================================================
   2080  0be3							; This places the number of free bytes on top of the
   2081  0be3							; stack.
   2082  0be3							;
   2083  0be3		       20 3b 16    iFREE      jsr	MemFree
   2084  0be6		       20 e0 1c 	      jsr	pushR0
   2085  0be9		       4c c2 02 	      jmp	NextIL
   2086  0bec							;
   2087  0bec							;=====================================================
   2088  0bec							; Generate a random number from 0-FFFF and then MOD
   2089  0bec							; it with the value on top of stack.  Leaves number on
   2090  0bec							; stack
   2091  0bec							;
   2092  0bec		       20 8a 1d    iRANDOM    jsr	popR1	;mod value
   2093  0bef							;
   2094  0bef							; If the value is zero, just return a one.
   2095  0bef							;
   2096  0bef		       a5 54		      lda	R1
   2097  0bf1		       05 55		      ora	R1+1
   2098  0bf3		       f0 4a		      beq	irandom1
   2099  0bf5							;
   2100  0bf5		       ad a1 2f 	      lda	random+1
   2101  0bf8		       8d 9e 2f 	      sta	rtemp1
   2102  0bfb		       ad a0 2f 	      lda	random
   2103  0bfe		       0a		      asl
   2104  0bff		       2e 9e 2f 	      rol	rtemp1
   2105  0c02		       0a		      asl
   2106  0c03		       2e 9e 2f 	      rol	rtemp1
   2107  0c06		       18		      clc
   2108  0c07		       6d a0 2f 	      adc	random
   2109  0c0a
   2110  0c0a		       48		      pha
   2111  0c0b
   2112  0c0b		       ad 9e 2f 	      lda	rtemp1
   2113  0c0e		       6d a1 2f 	      adc	random+1
   2114  0c11		       8d a1 2f 	      sta	random+1
   2115  0c14
   2116  0c14		       68		      pla
   2117  0c15
   2118  0c15		       69 11		      adc	#$11
   2119  0c17		       8d a0 2f 	      sta	random
   2120  0c1a		       ad a1 2f 	      lda	random+1
   2121  0c1d		       69 36		      adc	#$36
   2122  0c1f		       8d a1 2f 	      sta	random+1
   2123  0c22
   2124  0c22		       ad a0 2f 	      lda	random
   2125  0c25		       85 52		      sta	R0
   2126  0c27		       ad a1 2f 	      lda	random+1
   2127  0c2a		       29 7f		      and	#$7f	;make positive
   2128  0c2c		       85 53		      sta	R0+1
   2129  0c2e							;
   2130  0c2e							; R0 contains the number and R1 contains the max value.
   2131  0c2e							;
   2132  0c2e		       20 63 07 	      jsr	iDivNoPop
   2133  0c31		       20 f3 1d 	      jsr	RestoreSigns
   2134  0c34		       a5 56		      lda	MQ
   2135  0c36		       85 52		      sta	R0
   2136  0c38		       a5 57		      lda	MQ+1
   2137  0c3a		       85 53		      sta	R0+1
   2138  0c3c		       4c 3d 07 	      jmp	pushR0nextIl
   2139  0c3f				   irandom1
   2140  0c3f		       a9 00		      lda	#0
   2141  0c41		       85 53		      sta	R0+1
   2142  0c43		       a9 01		      lda	#1
   2143  0c45		       85 52		      sta	R0
   2144  0c47		       4c 3d 07 	      jmp	pushR0nextIl
   2145  0c4a
   2146  0c4a							; The following replaced by call to division/modulo
   2147  0c4a							;iRANDOM_2	lda	R0
   2148  0c4a							;		cmp	R1
   2149  0c4a							;		bne	iRANDOM_1
   2150  0c4a							;		lda	R0+1
   2151  0c4a							;		cmp	R1+1
   2152  0c4a							;		bne	iRANDOM_1	;need to subtract
   2153  0c4a							;
   2154  0c4a							; Subtract R1 from R0
   2155  0c4a							;
   2156  0c4a							;iRANDOM_sub	sec
   2157  0c4a							;		lda	R0
   2158  0c4a							;		sbc	R1
   2159  0c4a							;		sta	R0
   2160  0c4a							;		lda	R0+1
   2161  0c4a							;		sbc	R1+1
   2162  0c4a							;		sta	R0+1
   2163  0c4a							;		jmp	iRANDOM_2
   2164  0c4a							;
   2165  0c4a							; See if R1 > R0.  If so, branch to subtract.
   2166  0c4a							;
   2167  0c4a							;iRANDOM_1	lda	R0
   2168  0c4a							;		cmp	R1
   2169  0c4a							;		lda	R0+1
   2170  0c4a							;		sbc	R1+1
   2171  0c4a							;		bvc	iRANDOM_4
   2172  0c4a							;		eor	#$80
   2173  0c4a							;iRANDOM_4	bpl	iRANDOM_sub
   2174  0c4a							;
   2175  0c4a							; All done.  Almost.  Add one, then push the result.
   2176  0c4a							;
   2177  0c4a							;irandom1	inc	R0
   2178  0c4a							;		bne	iRANDOM_3
   2179  0c4a							;		inc	R0+1
   2180  0c4a							;iRANDOM_3
   2181  0c4a							;		  jsr	pushR0	;return value
   2182  0c4a							;		jmp	NextIL
   2183  0c4a							;
   2184  0c4a							; Poke a value into a memory location
   2185  0c4a		       8c a6 2f    iPOKEMEMORY sty	tempy
   2186  0c4d		       20 72 1d 	      jsr	popR0
   2187  0c50		       20 8a 1d 	      jsr	popR1
   2188  0c53		       a0 00		      ldy	#0
   2189  0c55		       a5 52		      lda	R0
   2190  0c57		       91 54		      sta	(R1),y
   2191  0c59		       ac a6 2f 	      ldy	tempy
   2192  0c5c		       4c c2 02 	      jmp	NextIL
   2193  0c5f							;
   2194  0c5f							; Get a value from a memory location
   2195  0c5f							;
   2196  0c5f		       8c a6 2f    iPEEKMEMORY sty	tempy
   2197  0c62		       20 72 1d 	      jsr	popR0
   2198  0c65		       a0 00		      ldy	#0
   2199  0c67		       b1 52		      lda	(R0),y
   2200  0c69		       ac a6 2f 	      ldy	tempy
   2201  0c6c		       85 52		      sta	R0
   2202  0c6e		       a9 00		      lda	#0
   2203  0c70		       85 53		      sta	R0+1
   2204  0c72		       4c 3d 07 	      jmp	pushR0nextIl
   2205  0c75							;
   2206  0c75							; Call to address return what ever is in a to the stack
   2207  0c75							; func2 will load a value into a before the call
   2208  0c75		       20 8a 1d    iCallFunc  jsr	popR1
   2209  0c78		       a5 54		      lda	R1
   2210  0c7a		       20 86 0c 	      jsr	iCallRtn
   2211  0c7d		       85 52		      sta	R0
   2212  0c7f		       a9 00		      lda	#0
   2213  0c81		       85 53		      sta	R0+1
   2214  0c83		       20 3d 07 	      jsr	pushR0nextIl
   2215  0c86				   iCallRtn
   2216  0c86		       20 72 1d 	      jsr	popR0
   2217  0c89		       6c 52 00 	      jmp	(R0)
   2218  0c8c
   2219  0c8c
   2220  0c8c							;===========================================jlit======
   2221  0c8c							;Get a character from the terminal convert to value
   2222  0c8c							;leave the number on top of the stack
   2223  0c8c							;
   2224  0c8c				   iGETCHAR
   2225  0c8c		       20 7c 1f 	      jsr	VGETCH
   2226  0c8f					      if	CTMON65
   2227  0c8f		       48		      pha
   2228  0c90		       20 79 1f 	      jsr	VOUTCH	;echo echo echo
   2229  0c93		       68		      pla
   2230  0c94					      endif
   2231  0c94		       85 52		      sta	R0
   2232  0c96		       a9 00		      lda	#0
   2233  0c98		       85 53		      sta	R0+1
   2234  0c9a		       20 e0 1c 	      jsr	pushR0
   2235  0c9d							;
   2236  0c9d		       4c c2 02 	      jmp	NextIL
   2237  0ca0							;===========================================jusilostintim======
   2238  0ca0							;Put a character to the terminal convert to
   2239  0ca0							;
   2240  0ca0		       20 72 1d    iPUTCHAR   jsr	popR0
   2241  0ca3		       a5 52		      lda	R0
   2242  0ca5		       20 79 1f 	      jsr	VOUTCH
   2243  0ca8		       4c c2 02 	      jmp	NextIL
   2244  0cab							;=====================================================
   2245  0cab							; Put the number on the stack out as hex, suppress leading 0
   2246  0cab				   iHexOut
   2247  0cab		       20 72 1d 	      jsr	popR0
   2248  0cae		       a5 53		      lda	R0+1
   2249  0cb0		       f0 03		      beq	iHexSecondByte
   2250  0cb2		       20 05 14 	      jsr	OUTHEX
   2251  0cb5				   iHexSecondByte
   2252  0cb5		       a5 52		      lda	R0
   2253  0cb7		       20 05 14 	      jsr	OUTHEX
   2254  0cba		       4c c2 02 	      jmp	NextIL
   2255  0cbd							;
   2256  0cbd							;=====================================================
   2257  0cbd							; Replace TOS with its absolute value.
   2258  0cbd							;
   2259  0cbd		       20 72 1d    iABS       jsr	popR0
   2260  0cc0		       a5 53		      lda	R0+1
   2261  0cc2		       10 10		      bpl	iABS_1	;already positive
   2262  0cc4		       49 ff		      eor	#$ff
   2263  0cc6		       85 53		      sta	R0+1
   2264  0cc8		       a5 52		      lda	R0
   2265  0cca		       49 ff		      eor	#$ff
   2266  0ccc		       85 52		      sta	R0
   2267  0cce		       e6 52		      inc	R0
   2268  0cd0		       d0 02		      bne	iABS_1
   2269  0cd2		       e6 53		      inc	R0+1
   2270  0cd4		       4c 3d 07    iABS_1     jmp	pushR0nextIl
   2271  0cd7
   2272  0cd7							;
   2273  0cd7							;================================================================
   2274  0cd7							; The set of logical operators
   2275  0cd7				   iLogAnd
   2276  0cd7		       20 72 1d 	      jsr	popR0
   2277  0cda		       20 8a 1d 	      jsr	popR1
   2278  0cdd		       a5 52		      lda	R0
   2279  0cdf		       25 54		      and	R1
   2280  0ce1		       85 52		      sta	R0
   2281  0ce3		       a5 53		      lda	R0+1
   2282  0ce5		       25 55		      and	R1+1
   2283  0ce7		       85 53		      sta	R0+1
   2284  0ce9		       4c 3d 07 	      jmp	pushR0nextIl
   2285  0cec				   iLogOr
   2286  0cec		       20 72 1d 	      jsr	popR0
   2287  0cef		       20 8a 1d 	      jsr	popR1
   2288  0cf2		       a5 52		      lda	R0
   2289  0cf4		       05 54		      ora	R1
   2290  0cf6		       85 52		      sta	R0
   2291  0cf8		       a5 53		      lda	R0+1
   2292  0cfa		       05 55		      ora	R1+1
   2293  0cfc		       85 53		      sta	R0+1
   2294  0cfe		       4c 3d 07 	      jmp	pushR0nextIl
   2295  0d01				   iLogXor
   2296  0d01		       20 72 1d 	      jsr	popR0
   2297  0d04		       20 8a 1d 	      jsr	popR1
   2298  0d07		       a5 52		      lda	R0
   2299  0d09		       45 54		      eor	R1
   2300  0d0b		       85 52		      sta	R0
   2301  0d0d		       a5 53		      lda	R0+1
   2302  0d0f		       45 55		      eor	R1+1
   2303  0d11		       85 53		      sta	R0+1
   2304  0d13		       4c 3d 07 	      jmp	pushR0nextIl
   2305  0d16				   iLogNot
   2306  0d16		       20 72 1d 	      jsr	popR0
   2307  0d19		       a5 52		      lda	R0
   2308  0d1b		       49 ff		      eor	#$FF
   2309  0d1d		       85 52		      sta	R0
   2310  0d1f		       a5 53		      lda	R0+1
   2311  0d21		       49 ff		      eor	#$FF
   2312  0d23		       85 53		      sta	R0+1
   2313  0d25		       4c 3d 07 	      jmp	pushR0nextIl
   2314  0d28
   2315  0d28				   iTruth
   2316  0d28		       a9 ff		      lda	#$FF
   2317  0d2a		       85 52		      sta	R0
   2318  0d2c		       85 53		      sta	R0+1
   2319  0d2e		       4c 3d 07 	      jmp	pushR0nextIl
   2320  0d31				   iFalse
   2321  0d31		       a9 00		      lda	#$00
   2322  0d33		       85 52		      sta	R0
   2323  0d35		       85 53		      sta	R0+1
   2324  0d37		       4c 3d 07 	      jmp	pushR0nextIl
   2325  0d3a
   2326  0d3a							;================================================================
   2327  0d3a							;Set the IRQ service rtn line number
   2328  0d3a							;
   2329  0d3a		       78	   iSetIrq    sei		; disable the interupts
   2330  0d3b		       a9 00		      lda	#0	; Zero the Status flag
   2331  0d3d		       8d 51 26 	      sta	IRQStatus
   2332  0d40		       20 72 1d 	      jsr	popR0	; get the line number
   2333  0d43		       a5 52		      lda	R0
   2334  0d45		       05 53		      ora	R0+1
   2335  0d47		       f0 22		      beq	iSetExt	; if it is zero disable all
   2336  0d49		       a9 01		      lda	#GOSUB_RTN	; default push type
   2337  0d4b		       20 fa 1c 	      jsr	pushLN	; Save the current line pointer
   2338  0d4e		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2339  0d50		       4c dc 0b 	      jmp	ErrStkOver	; Check if there was an error
   2340  0d53				   iSetIrqOk
   2341  0d53		       20 2c 1b 	      jsr	findLine	; Find the IRQ func Line Pointer
   2342  0d56		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2343  0d58		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2344  0d5a		       8d 54 26 	      sta	IRQEntry+1
   2345  0d5d		       a5 4f		      lda	CURPTR
   2346  0d5f		       8d 53 26 	      sta	IRQEntry
   2347  0d62		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2348  0d64		       8d 51 26 	      sta	IRQStatus
   2349  0d67		       20 23 1d 	      jsr	popLN	; Restore the old line number
   2350  0d6a		       58		      cli		; Enable the interupts
   2351  0d6b		       4c c2 02    iSetExt    jmp	NextIL
   2352  0d6e
   2353  0d6e		       20 23 1d    iSetIrqErr jsr	popLN
   2354  0d71		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2355  0d73		       a9 00		      lda	#0
   2356  0d75		       4c a4 06 	      jmp	iErr2
   2357  0d78							;
   2358  0d78		       20 72 1d    iTRACEPROG jsr	popR0
   2359  0d7b		       a5 52		      lda	R0
   2360  0d7d		       85 40		      sta	ILTrace
   2361  0d7f		       4c c2 02 	      jmp	NextIL
   2362  0d82
   2363  0d82							;=====================================================
   2364  0d82							; Define start of non page zero data
   2365 U2fb8 ????				      seg.u	TBData
   2366 U260e					      org	PROGEND
   2367 U260e							;=================================================================
   2368 U260e							;
------- FILE compile.asm LEVEL 2 PASS 6
      0 U260e					      include	"compile.asm"
      1  0d82					      Seg	Code
      2  0d82							;
      3  0d82							;=====================================================================
      4  0d82							; Scan the loaded program just before running and insert memory locations of each
      5  0d82							; line number branched to. goto gosub, gofn
      6  0d82							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  0d82				   Compile
      8  0d82		       a9 00		      lda	#0
      9  0d84		       85 52		      sta	R0	; keep track of how many errors we find
     10  0d86		       a5 5b		      lda	RunMode
     11  0d88		       48		      pha
     12  0d89		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  0d8b		       a5 4f		      lda	CURPTR
     14  0d8d		       48		      pha
     15  0d8e		       a5 50		      lda	CURPTR+1
     16  0d90		       48		      pha
     17  0d91		       a5 51		      lda	CUROFF
     18  0d93		       48		      pha
     19  0d94		       ad ae 2f 	      lda	ProgramStart
     20  0d97		       85 59		      sta	dpl
     21  0d99		       ad af 2f 	      lda	ProgramStart+1
     22  0d9c		       85 5a		      sta	dpl+1
     23  0d9e
     24  0d9e				   CompileLineStart
     25  0d9e		       a5 59		      lda	dpl
     26  0da0		       cd b0 2f 	      cmp	ProgramEnd
     27  0da3		       d0 07		      bne	CompileContinue
     28  0da5		       a5 5a		      lda	dpl+1
     29  0da7		       cd b1 2f 	      cmp	ProgramEnd+1
     30  0daa		       f0 3f		      beq	CompileComplete
     31  0dac
     32  0dac				   CompileContinue
     33  0dac		       a0 03		      ldy	#3	; first real character in the line
     34  0dae
     35  0dae				   CompileLoop
     36  0dae		       b1 59		      lda	(dpl),y	; get the byte
     37  0db0		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  0db2		       c8		      iny		; Pass this byte
     39  0db3		       c9 07		      cmp	#kGoto
     40  0db5		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  0db7		       c9 08		      cmp	#kGosub
     42  0db9		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  0dbb		       c9 31		      cmp	#kGofn
     44  0dbd		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  0dbf		       c9 29		      cmp	#kTask
     46  0dc1		       f0 4c		      beq	CompileField
     47  0dc3		       c9 0a		      cmp	#kRem
     48  0dc5		       f0 12		      beq	CompileRem	; Skip until end of line
     49  0dc7		       c9 a0		      cmp	#tString
     50  0dc9		       f0 2f		      beq	CompileString
     51  0dcb		       c9 a1		      cmp	#tInteger
     52  0dcd		       f0 06		      beq	CompileInteger
     53  0dcf		       c9 a2		      cmp	#tByte
     54  0dd1		       f0 03		      beq	CompileByte
     55  0dd3		       d0 d9		      bne	CompileLoop	; Next character
     56  0dd5
     57  0dd5				   CompileInteger
     58  0dd5		       c8		      iny
     59  0dd6				   CompileByte
     60  0dd6		       c8		      iny
     61  0dd7		       d0 d5		      bne	CompileLoop
     62  0dd9				   CompileRem
     63  0dd9				   CompileEndOfLine
     64  0dd9		       a0 00		      ldy	#0
     65  0ddb		       b1 59		      lda	(dpl),y
     66  0ddd		       18		      clc
     67  0dde		       65 59		      adc	dpl
     68  0de0		       85 59		      sta	dpl
     69  0de2		       a9 00		      lda	#0
     70  0de4		       65 5a		      adc	dpl+1
     71  0de6		       85 5a		      sta	dpl+1
     72  0de8
     73  0de8		       4c 9e 0d 	      jmp	CompileLineStart
     74  0deb
     75  0deb				   CompileComplete
     76  0deb		       68		      pla
     77  0dec		       85 51		      sta	CUROFF
     78  0dee		       68		      pla
     79  0def		       85 50		      sta	CURPTR+1
     80  0df1		       68		      pla
     81  0df2		       85 4f		      sta	CURPTR
     82  0df4		       68		      pla
     83  0df5		       85 5b		      sta	RunMode
     84  0df7		       a5 52		      lda	R0	; returning the number of errors
     85  0df9		       60		      rts
     86  0dfa
     87  0dfa
     88  0dfa				   CompileString
     89  0dfa		       c8		      iny		; point past first "
     90  0dfb				   CompileStringLoop
     91  0dfb		       b1 59		      lda	(dpl),y
     92  0dfd		       f0 0d		      beq	CompileStrDone2
     93  0dff		       c9 22		      cmp	#'"	; end of string
     94  0e01		       f0 08		      beq	CompileStrDone
     95  0e03		       c9 5c		      cmp	#'\	; escape character
     96  0e05		       d0 01		      bne	CompileStrNext
     97  0e07		       c8		      iny
     98  0e08				   CompileStrNext
     99  0e08		       c8		      iny		; Next character
    100  0e09		       d0 f0		      bne	CompileStringLoop	; test for end
    101  0e0b				   CompileStrDone
    102  0e0b		       c8		      iny
    103  0e0c				   CompileStrDone2
    104  0e0c		       4c ae 0d 	      Jmp	CompileLoop
    105  0e0f							;
    106  0e0f							;===============================================================
    107  0e0f							; on entry y points to storage location y+2 points to line number
    108  0e0f							; on exit y points to line number type
    109  0e0f
    110  0e0f		       85 52	   CompileField sta	R0
    111  0e11		       98		      tya		; save the y pointer to store the memory value
    112  0e12		       48		      pha
    113  0e13		       c8		      iny		; Skip over the memory vector
    114  0e14		       c8		      iny
    115  0e15		       a5 52		      lda	R0
    116  0e17		       c9 29		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  0e19		       d0 07		      bne	CompNoBracket
    118  0e1b
    119  0e1b		       b1 59		      lda	(dpl),y	; Lets make sure it is a
    120  0e1d		       c9 e0		      cmp	#oLeftBracket
    121  0e1f		       d0 01		      bne	CompNoBracket	; in case of error
    122  0e21		       c8		      iny		; skip the bracket
    123  0e22
    124  0e22				   CompNoBracket
    125  0e22		       a9 00		      lda	#0	; In case the value is a byte
    126  0e24		       85 53		      sta	R0+1
    127  0e26
    128  0e26		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  0e28		       c9 a2		      cmp	#tByte
    130  0e2a		       f0 15		      beq	CompByteLoad
    131  0e2c		       c9 a1		      cmp	#tInteger
    132  0e2e		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  0e30		       68		      pla
    134  0e31		       4c ae 0d 	      jmp	CompileLoop	; Ignore the saved stack
    135  0e34				   CompIntLoad
    136  0e34		       c8		      iny
    137  0e35		       b1 59		      lda	(dpl),y
    138  0e37		       85 52		      sta	R0
    139  0e39		       c8		      iny
    140  0e3a		       b1 59		      lda	(dpl),y
    141  0e3c		       85 53		      sta	R0+1
    142  0e3e		       4c 46 0e 	      jmp	CompFindLine
    143  0e41				   CompByteLoad
    144  0e41		       c8		      iny
    145  0e42		       b1 59		      lda	(dpl),y
    146  0e44		       85 52		      sta	R0
    147  0e46				   CompFindLine
    148  0e46		       20 2c 1b 	      jsr	findLine
    149  0e49		       f0 1d		      beq	CompFoundLine
    150  0e4b		       e6 52		      inc	R0	; number of errors
    151  0e4d
    152  0e4d
    153  0e4d
    154  0e4d		       a5 59		      lda	dpl
    155  0e4f		       85 4f		      sta	CURPTR
    156  0e51		       a5 5a		      lda	dpl+1
    157  0e53		       85 50		      sta	CURPTR+1
    158  0e55		       84 51		      sty	CUROFF
    159  0e57
    160  0e57		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    161  0e59		       a9 00		      lda	#0
    162  0e5b
    163  0e5b		       20 4e 06 	      jsr	DisplayError
    164  0e5e		       20 ba 14 	      jsr	PrintProgramLine
    165  0e61
    166  0e61		       68		      pla
    167  0e62		       a8		      tay
    168  0e63		       c8		      iny
    169  0e64		       c8		      iny
    170  0e65		       4c ae 0d 	      jmp	CompileLoop
    171  0e68
    172  0e68				   CompFoundLine
    173  0e68		       68		      pla
    174  0e69		       a8		      tay
    175  0e6a		       a5 4f		      lda	CURPTR
    176  0e6c		       91 59		      sta	(dpl),y
    177  0e6e		       c8		      iny
    178  0e6f		       a5 50		      lda	CURPTR+1
    179  0e71		       91 59		      sta	(dpl),y
    180  0e73		       c8		      iny
    181  0e74		       4c ae 0d 	      jmp	CompileLoop
    182  0e77
    183  0e77
    184  0e77
    185  0e77
    186  0e77
    187  0e77
    188  0e77
    189  0e77
    190  0e77
    191  0e77
    192  0e77
    193  0e77
    194  0e77
    195  0e77
    196  0e77
    197  0e77
    198  0e77
    199  0e77
    200  0e77
    201  0e77
    202  0e77
    203  0e77
    204  0e77
    205  0e77
    206  0e77
    207  0e77
    208  0e77
    209  0e77
    210  0e77
    211  0e77
    212  0e77
    213  0e77
    214  0e77
    215  0e77
    216  0e77
    217  0e77
    218  0e77
    219  0e77
    220  0e77
    221  0e77
    222  0e77
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  0e77					      include	"tokenizer.asm"
      1  0e77					      seg	Code
      2  0e77		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  0e77
      4  0e77							; Define the types of tokens found, and identifiers
      5  0e77		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0e77		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0e77		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0e77		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0e77
     10  0e77		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0e77		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0e77		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0e77
     14  0e77
     15  0e77		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0e77		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0e77		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0e77		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0e77							; Arrays of string are arrays of pointers 2 bytes
     20  0e77		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0e77		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0e77
     23  0e77		       3c 3e	   Operators  BYTE.b	"<>"
     24  0e79		       3c 3d		      BYTE.b	"<="
     25  0e7b		       3e 3d		      BYTE.b	">="
     26  0e7d		       3c 00		      BYTE.b	"<",0
     27  0e7f		       3d 00		      BYTE.b	"=",0
     28  0e81		       3e 00		      BYTE.b	">",0
     29  0e83		       2b 00		      BYTE.b	"+",0
     30  0e85		       2d 00		      BYTE.b	"-",0
     31  0e87		       2f 00		      BYTE.b	"/",0
     32  0e89		       25 00		      BYTE.b	"%",0
     33  0e8b		       2a 00		      BYTE.b	"*",0
     34  0e8d		       28 00		      BYTE.b	"(",0
     35  0e8f		       29 00		      BYTE.b	")",0
     36  0e91		       2c 00		      BYTE.b	",",0
     37  0e93		       3b 00		      BYTE.b	";",0
     38  0e95		       5b 00		      BYTE.b	"[",0
     39  0e97		       5d 00		      BYTE.b	"]",0
     40  0e99		       3a 00		      BYTE.b	":",0
     41  0e9b		       24 00		      BYTE.b	"$",0
     42  0e9d		       21 00		      BYTE.b	"!",0
     43  0e9f		       3f 00		      BYTE.b	"?",0
     44  0ea1		       2e 00		      BYTE.b	".",0
     45  0ea3		       00 00		      BYTE.b	0,0
     46  0ea5
     47  0ea5		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     48  0eab		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     49  0eb0		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     50  0eb6		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     51  0ebb
     52  0ebb		       00 0b	   oQuestion  equ	kPrint
     53  0ebb							;    2 is =
     54  0ebb							;    1 is <
     55  0ebb							;    3 is <=
     56  0ebb							;    5 is <>
     57  0ebb							;    4 is >
     58  0ebb							;    6 is >=
     59  0ebb		       00 f1	   oLess      equ	$F1
     60  0ebb		       00 f2	   oEqual     equ	$F2
     61  0ebb		       00 f3	   oLessEqual equ	$F3
     62  0ebb		       00 f4	   oGreater   equ	$F4
     63  0ebb		       00 f5	   oNotEqual  equ	$F5
     64  0ebb		       00 f6	   oGreaterEqual equ	$F6
     65  0ebb
     66  0ebb		       00 e0	   oLeftBracket equ	$E0
     67  0ebb		       00 e1	   oRightBracket equ	$E1
     68  0ebb		       00 e2	   oComma     equ	$E2
     69  0ebb		       00 e3	   oSemiColon equ	$E3
     70  0ebb		       00 e4	   oLeftSQBracket equ	$E4
     71  0ebb		       00 e5	   oRightSQBracket equ	$E5
     72  0ebb		       00 e6	   oColon     equ	$E6
     73  0ebb		       00 e7	   oDollar    equ	$E7
     74  0ebb		       00 e8	   oBang      equ	$E8
     75  0ebb		       00 e9	   oPeriod    equ	$E9
     76  0ebb
     77  0ebb
     78  0ebb		       00 ea	   oPlus      equ	$EA
     79  0ebb		       00 eb	   oMinus     equ	$EB
     80  0ebb		       00 ec	   oDivide    equ	$EC
     81  0ebb		       00 ed	   oModulo    equ	$ED
     82  0ebb		       00 ee	   oMultiply  equ	$EE
     83  0ebb
     84  0ebb		       00 ed	   oPercent   equ	oModulo
     85  0ebb
     86  0ebb		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     87  0ebb
     88  0ebb		       00 ff	   tError     equ	$FF	; Error should never happen
     89  0ebb							;============================================================================================
     90  0ebb							; Keyword and seperator values
     91  0ebb				   '
     92  0ebb		       00 01	   kBeginKey  equ	kLet
     93  0ebb							;
     94  0ebb		       00 01	   kLet       equ	1
     95  0ebb		       00 02	   kInc       equ	kLet+1
     96  0ebb		       00 03	   kDec       equ	kInc+1
     97  0ebb		       00 04	   kIreturn   equ	kDec+1
     98  0ebb		       00 05	   kIf	      equ	kIreturn+1
     99  0ebb		       00 06	   kThen      equ	kIf+1
    100  0ebb		       00 07	   kGoto      equ	kThen+1
    101  0ebb		       00 08	   kGosub     equ	kGoto+1
    102  0ebb		       00 09	   kReturn    equ	kGosub+1
    103  0ebb		       00 0a	   kRem       equ	kReturn+1
    104  0ebb		       00 0b	   kPrint     equ	kRem+1
    105  0ebb		       00 0c	   kTaske     equ	kPrint+1
    106  0ebb		       00 0d	   kTaskn     equ	kTaske+1
    107  0ebb		       00 0e	   kTaskw     equ	kTaskn+1
    108  0ebb		       00 0f	   kPoke      equ	kTaskw+1
    109  0ebb		       00 10	   kPutch     equ	kPoke+1
    110  0ebb		       00 11	   kCls       equ	kPutch+1
    111  0ebb		       00 12	   kInput     equ	kCls+1
    112  0ebb		       00 13	   kEnd       equ	kInput+1
    113  0ebb		       00 14	   kIrq       equ	kEnd+1
    114  0ebb		       00 15	   kKill      equ	kIrq+1
    115  0ebb		       00 16	   kList      equ	kKill+1
    116  0ebb		       00 17	   kRun       equ	kList+1
    117  0ebb		       00 18	   kNew       equ	kRun+1
    118  0ebb		       00 19	   kSlice     equ	kNew+1
    119  0ebb		       00 1a	   kTrace     equ	kSlice+1
    120  0ebb		       00 1b	   kExit      equ	kTrace+1
    121  0ebb		       00 1c	   kSave      equ	kExit+1
    122  0ebb		       00 1d	   kLoad      equ	kSave+1
    123  0ebb		       00 1e	   kErase     equ	kLoad+1
    124  0ebb		       00 1f	   kDir       equ	kErase+1
    125  0ebb							;
    126  0ebb							; End of actual key words
    127  0ebb							;
    128  0ebb		       00 1e	   kKeyCount  equ	kDir-kBeginKey
    129  0ebb							;
    130  0ebb							; Logical operators
    131  0ebb							;
    132  0ebb		       00 20	   kNot       equ	kDir+1
    133  0ebb		       00 21	   kOr	      equ	kNot+1
    134  0ebb		       00 22	   kXor       equ	kOr+1
    135  0ebb		       00 23	   kAnd       equ	kXor+1
    136  0ebb
    137  0ebb							; numeric functions
    138  0ebb							;
    139  0ebb		       00 24	   kBeginFunc equ	kTrue
    140  0ebb							;
    141  0ebb							; Truth operators
    142  0ebb							;
    143  0ebb		       00 24	   kTrue      equ	kAnd+1
    144  0ebb		       00 25	   kFalse     equ	kTrue+1
    145  0ebb							; Functions
    146  0ebb		       00 26	   kFree      equ	kFalse+1
    147  0ebb		       00 27	   kGetch     equ	kFree+1
    148  0ebb		       00 28	   kPeek      equ	kGetch+1
    149  0ebb		       00 29	   kTask      equ	kPeek+1
    150  0ebb		       00 2a	   kIpcc      equ	kTask+1
    151  0ebb		       00 2b	   kIpcs      equ	kIpcc+1
    152  0ebb		       00 2c	   kIpcr      equ	kIpcs+1
    153  0ebb		       00 2d	   kRnd       equ	kIpcr+1
    154  0ebb		       00 2e	   kStat      equ	kRnd+1
    155  0ebb		       00 2f	   kAbs       equ	kStat+1
    156  0ebb		       00 30	   kCall      equ	kAbs+1
    157  0ebb		       00 31	   kGofn      equ	kCall+1
    158  0ebb		       00 32	   kPid       equ	kGofn+1
    159  0ebb							;
    160  0ebb		       00 0e	   kFuncCount equ	kPid - kBeginFunc
    161  0ebb
    162  0ebb							;
    163  0ebb							; Keyword table contains 49 keywords
    164  0ebb				   KeyWordTable
      0  0ebb					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0ebb		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0ebf					      db	kInc,"inC"
      1  0ebf		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0ec3					      db	kDec,"deC"
      1  0ec3		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0ec7					      db	kIreturn,"ireturN"
      1  0ec7		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0ecf					      db	kIf,"iF"
      1  0ecf		       05 69 46 	      .byte.b	kIf,"iF"
      0  0ed2					      db	kThen,"theN"
      1  0ed2		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0ed7					      db	kGoto,"gotO"
      1  0ed7		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0edc					      db	kGosub,"gosuB"
      1  0edc		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0ee2					      db	kReturn,"returN"
      1  0ee2		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0ee9					      db	kRem,"reM"
      1  0ee9		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0eed					      db	kPrint,"prinT"
      1  0eed		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0ef3					      db	kTaske,"taskE"
      1  0ef3		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0ef9					      db	kTaskn,"taskN"
      1  0ef9		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0eff					      db	kTaskw,"taskW"
      1  0eff		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0f05					      db	kPoke,"pokE"
      1  0f05		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0f0a					      db	kPutch,"putcH"
      1  0f0a		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0f10					      db	kCls,"clS"
      1  0f10		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0f14					      db	kInput,"inpuT"
      1  0f14		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0f1a					      db	kEnd,"enD"
      1  0f1a		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0f1e					      db	kIrq,"irQ"
      1  0f1e		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0f22					      db	kKill,"kilL"
      1  0f22		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0f27					      db	kList,"lisT"
      1  0f27		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0f2c					      db	kRun,"ruN"
      1  0f2c		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0f30					      db	kNew,"neW"
      1  0f30		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0f34					      db	kSlice,"slicE"
      1  0f34		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0f3a					      db	kTrace,"tracE"
      1  0f3a		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0f40					      db	kExit,"exiT"
      1  0f40		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0f45					      db	kSave,"savE"
      1  0f45		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0f4a					      db	kLoad,"loaD"
      1  0f4a		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0f4f					      db	kErase,"erasE"
      1  0f4f		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0f55					      db	kDir,"diR"
      1  0f55		       1f 64 69 52	      .byte.b	kDir,"diR"
    196  0f59							;Short form for statements:
      0  0f59					      db	kIreturn,"ireT"
      1  0f59		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0f5e					      db	kReturn,"reT"
      1  0f5e		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  0f62					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  0f62		       0b 70 52 	      .byte.b	kPrint,"pR"
    200  0f65
    201  0f65							;Logical and truth operators
      0  0f65					      db	kNot,"noT"
      1  0f65		       20 6e 6f 54	      .byte.b	kNot,"noT"
      0  0f69					      db	kOr,"oR"
      1  0f69		       21 6f 52 	      .byte.b	kOr,"oR"
      0  0f6c					      db	kXor,"xoR"
      1  0f6c		       22 78 6f 52	      .byte.b	kXor,"xoR"
      0  0f70					      db	kAnd,"anD"
      1  0f70		       23 61 6e 44	      .byte.b	kAnd,"anD"
    206  0f74							; Truth values
      0  0f74					      db	kTrue,"truE"
      1  0f74		       24 74 72 75*	      .byte.b	kTrue,"truE"
      0  0f79					      db	kFalse,"falsE"
      1  0f79		       25 66 61 6c*	      .byte.b	kFalse,"falsE"
    209  0f7f
    210  0f7f							;functions returning values
    211  0f7f
      0  0f7f					      db	kFree,"freE"
      1  0f7f		       26 66 72 65*	      .byte.b	kFree,"freE"
      0  0f84					      db	kGetch,"getcH"
      1  0f84		       27 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0f8a					      db	kPeek,"peeK"
      1  0f8a		       28 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0f8f					      db	kTask,"tasK"
      1  0f8f		       29 74 61 73*	      .byte.b	kTask,"tasK"
      0  0f94					      db	kIpcc,"ipcC"
      1  0f94		       2a 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0f99					      db	kIpcs,"ipcS"
      1  0f99		       2b 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0f9e					      db	kIpcr,"ipcR"
      1  0f9e		       2c 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0fa3					      db	kRnd,"rnD"
      1  0fa3		       2d 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0fa7					      db	kStat,"staT"
      1  0fa7		       2e 73 74 61*	      .byte.b	kStat,"staT"
      0  0fac					      db	kAbs,"abS"
      1  0fac		       2f 61 62 53	      .byte.b	kAbs,"abS"
      0  0fb0					      db	kCall,"calL"
      1  0fb0		       30 63 61 6c*	      .byte.b	kCall,"calL"
      0  0fb5					      db	kGofn,"gofN"
      1  0fb5		       31 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0fba					      db	kPid,"piD"
      1  0fba		       32 70 69 44	      .byte.b	kPid,"piD"
      0  0fbe					      db	0,0
      1  0fbe		       00 00		      .byte.b	0,0
    226  0fc0
    227  0fc0		       0f c0	   KeyWordTableEnd equ	*
    228  0fc0		       01 05	   KeyWordTableLength equ	* - KeyWordTable
    229  0fc0		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    230  10c0		       00 00 00    printStorage ds	3
    231  10c3							;==================================================================================================================
    232  10c3							; Read accross the inputline and output to TOKENBUFFER
    233  10c3							; Format   byte      Description
    234  10c3							;	     0	      length of line 1-255
    235  10c3							;	    0-1       Line Number
    236  10c3							;	    Tokens and litteral values encoded into the line
    237  10c3							;
    238  10c3							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    239  10c3							;  if fails then test for keywords
    240  10c3							;  if fails then test for variables and arrays
    241  10c3							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    242  10c3
    243  10c3				   ParseInputLine
    244  10c3				  -	      if	DEBUGPARSER
    245  10c3				  -	      jsr	SetOutDebug
    246  10c3				  -	      jsr	DebugClearBuffer
    247  10c3					      endif
    248  10c3		       a5 51		      lda	CUROFF
    249  10c5		       48		      pha
    250  10c6		       8a		      txa
    251  10c7		       48		      pha
    252  10c8		       98		      tya
    253  10c9		       48		      pha
    254  10ca		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    255  10cc		       20 92 1b 	      jsr	getDecimal	; Check for a line number, none is ok too
    256  10cf		       84 51		      sty	CUROFF
    257  10d1		       20 8f 12 	      jsr	R02TOKEN	; Move R0 to token buffer
    258  10d4
    259  10d4				   ParseInputLoop
    260  10d4		       a4 51		      ldy	CUROFF
    261  10d6		       20 22 1e 	      jsr	SkipSpaces	; Skip any spaces
    262  10d9		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    263  10db		       b9 11 2f 	      lda	LINBUF,y	; Check for end of line
    264  10de		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    265  10e0
    266  10e0				   ParseForNumber
    267  10e0		       20 e3 11 	      jsr	ParseNumeric	; Check for a numeric value
    268  10e3		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    269  10e5
    270  10e5				   ParseForString
    271  10e5		       20 b9 11 	      jsr	ParseString	; Check for a string
    272  10e8		       90 ea		      bcc	ParseInputLoop	; It was a string
    273  10ea
    274  10ea				   ParseForOp
    275  10ea		       20 21 12 	      jsr	ParseForOperator	; Check for operator or punctuation
    276  10ed		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    277  10ef
    278  10ef				   ParseForKey
    279  10ef		       20 16 11 	      jsr	ParseLookupKey	; Check for a keyword value
    280  10f2		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    281  10f4
    282  10f4				   ParseForVar
    283  10f4		       20 58 12 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    284  10f7		       90 db		      bcc	ParseInputLoop
    285  10f9
    286  10f9				   ParseKeepChar		; if it does not parse just keep it safe
    287  10f9		       b9 11 2f 	      lda	LINBUF,y
    288  10fc		       9d c0 0f 	      sta	TOKENBUFFER,x
    289  10ff		       e8		      inx
    290  1100		       c8		      iny
    291  1101		       84 51		      sty	CUROFF
    292  1103		       d0 cf		      bne	ParseInputLoop
    293  1105
    294  1105				   ParseComplete
    295  1105		       a9 00		      lda	#0
    296  1107		       9d c0 0f 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    297  110a		       e8		      inx
    298  110b		       8e c0 0f 	      stx	TOKENBUFFER	; Place size including null into buffer start
    299  110e
    300  110e		       68		      pla
    301  110f		       a8		      tay
    302  1110		       68		      pla
    303  1111		       aa		      tax
    304  1112		       68		      pla
    305  1113		       85 51		      sta	CUROFF
    306  1115
    307  1115				  -	      if	DEBUGPARSER
    308  1115				  -
    309  1115				  -	      jsr	printTokenBuffer
    310  1115				  -			;jsr	  DebugPrintProgramLine
    311  1115				  -	      jsr	SetOutDebugEnd
    312  1115				  -
    313  1115					      endif
    314  1115		       60		      rts
    315  1116
    316  1116							;==================================================================================================================
    317  1116							; Look at curptr, curpos and check for a valid KeyWord
    318  1116							; A contains the index value. c is clear
    319  1116							;		     not found c set  A undefined
    320  1116							; X is prerserved
    321  1116							;
    322  1116				   ParseLookupKey
    323  1116		       86 58		      stx	R2
    324  1118		       a0 00		      ldy	#0
    325  111a		       a9 bb		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    326  111c		       85 54		      sta	R1
    327  111e		       a9 0e		      lda	#KeyWordTable>>8
    328  1120		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    329  1122		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    330  1124		       85 52		      sta	R0	; Save until next keyword
    331  1126		       c8		      iny		; Point to first character of keyword
    332  1127		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    333  1129
    334  1129				  -	      if	DEBUGPARSER
    335  1129				  -			;    jsr DebugKeyword
    336  1129					      endif
    337  1129
    338  1129				   ParseLookupLoop
    339  1129		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    340  112b		       29 df		      and	#%11011111	; Force Keyword to upper case
    341  112d		       dd 11 2f 	      cmp	LINBUF,x	; Check the input buffer
    342  1130		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    343  1132		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    344  1134		       dd 11 2f 	      cmp	LINBUF,x	; Compare value to upercase
    345  1137		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    346  1139
    347  1139				   ParseNextLetter
    348  1139		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    349  113b		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    350  113d		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    351  113f		       e8		      inx		; Point to next char in the input buffer
    352  1140		       c8		      iny		; Point to the next character in the Keyword table
    353  1141		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    354  1143		       dd 11 2f 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    355  1146		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    356  1148		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    357  114a
    358  114a				   ParseKeyFound
    359  114a		       a5 52		      lda	R0	; get the keyword index
    360  114c
    361  114c				   ParseKeyDone
    362  114c		       e8		      inx		; point past the last character
    363  114d		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    364  114f		       a6 58		      ldx	R2	; Restore the original x pointer
    365  1151		       9d c0 0f 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    366  1154		       e8		      inx		; Point to next position in the output buffer
    367  1155		       86 58		      stx	R2	; Save next position in buffer
    368  1157		       c9 0a		      cmp	#kRem	; remark statement
    369  1159		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    370  115b		       c9 07		      cmp	#kGoto
    371  115d		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    372  115f		       c9 08		      cmp	#kGosub
    373  1161		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    374  1163		       c9 31		      cmp	#kGofn
    375  1165		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    376  1167		       c9 29		      cmp	#kTask
    377  1169		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    378  116b
    379  116b		       18		      clc		; C flag clear, we found it
    380  116c		       60		      rts
    381  116d
    382  116d							; Move forward to the next entry in table
    383  116d				   ParseNextEntry
    384  116d		       b1 54		      lda	(R1),y	; Get the next character in the token
    385  116f		       29 20		      and	#%00100000	; Is it the last character
    386  1171		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    387  1173		       c8		      iny		; Point to next char in the entry
    388  1174		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    389  1176
    390  1176				   ParseEndOfEntry
    391  1176		       c8		      iny		; Point to the byte after the last character
    392  1177		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    393  1178		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    394  1179		       65 54		      adc	R1
    395  117b		       85 54		      sta	R1
    396  117d		       a5 55		      lda	R1+1
    397  117f		       69 00		      adc	#0
    398  1181		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    399  1183		       a0 00		      ldy	#0	; Reset the index back to zero
    400  1185		       b1 54		      lda	(R1),y	; get keyword value
    401  1187		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    402  1189		       85 52		      sta	R0	; save the next token value
    403  118b		       c8		      iny		; Inc past token value
    404  118c
    405  118c				  -	      if	DEBUGPARSER
    406  118c				  -			;    jsr DebugKeyword
    407  118c					      endif
    408  118c		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    409  118e		       4c 29 11 	      jmp	ParseLookupLoop	; branch back for next key word
    410  1191
    411  1191				   ParseNoneFound
    412  1191		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    413  1193		       38		      sec		; c clear, not found
    414  1194		       60		      rts
    415  1195
    416  1195							;===============================================================================
    417  1195							; Move everything from current position until the end of line into the token buffer
    418  1195							;
    419  1195		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    420  1197		       a6 58		      ldx	R2	; where to place in the buffer
    421  1199				   ParseMoveLoop
    422  1199		       b9 11 2f 	      lda	LINBUF,y	; get the next byte
    423  119c		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    424  119e		       9d c0 0f 	      sta	TOKENBUFFER,x	; save the byte
    425  11a1		       c8		      iny
    426  11a2		       e8		      inx
    427  11a3		       d0 f4		      bne	ParseMoveLoop
    428  11a5				   ParseMoveDone
    429  11a5		       84 51		      sty	CUROFF
    430  11a7		       18		      clc
    431  11a8		       60		      rts
    432  11a9							;================================================================================================
    433  11a9							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    434  11a9							; transfer to a memory address
    435  11a9				   ParseHandleBranches
    436  11a9		       a6 58		      ldx	R2
    437  11ab		       a9 00		      lda	#0
    438  11ad		       9d c0 0f 	      sta	TOKENBUFFER,x
    439  11b0		       e8		      inx
    440  11b1		       9d c0 0f 	      sta	TOKENBUFFER,x
    441  11b4		       e8		      inx
    442  11b5		       86 58		      stx	R2
    443  11b7		       18		      clc
    444  11b8		       60		      rts
    445  11b9
    446  11b9							;=========================================================================================================
    447  11b9							;ParseString Parse a quotes string
    448  11b9							; on input X = outbuf position
    449  11b9							; y = inbuf position
    450  11b9							; Copies string to output buffer, updates x and y
    451  11b9				   ParseString
    452  11b9		       a4 51		      ldy	CUROFF
    453  11bb		       a9 a0		      lda	#tString
    454  11bd		       9d c0 0f 	      sta	TOKENBUFFER,X
    455  11c0		       b9 11 2f 	      lda	LINBUF,y
    456  11c3		       c9 22		      cmp	#'"
    457  11c5		       d0 1a		      bne	ParseStringInvalid
    458  11c7		       e8		      inx
    459  11c8		       9d c0 0f 	      sta	TOKENBUFFER,x
    460  11cb		       e8		      inx
    461  11cc		       c8		      iny
    462  11cd
    463  11cd				   ParseStringLoop
    464  11cd		       b9 11 2f 	      lda	LINBUF,y
    465  11d0		       9d c0 0f 	      sta	TOKENBUFFER,x
    466  11d3		       c9 22		      cmp	#'"
    467  11d5		       f0 04		      beq	ParseStringDone
    468  11d7		       c8		      iny
    469  11d8		       e8		      inx
    470  11d9		       d0 f2		      bne	ParseStringLoop
    471  11db
    472  11db				   ParseStringDone
    473  11db		       e8		      inx
    474  11dc		       c8		      iny
    475  11dd		       84 51		      sty	CUROFF
    476  11df		       18		      clc
    477  11e0		       60		      rts
    478  11e1
    479  11e1				   ParseStringInvalid
    480  11e1		       38		      sec
    481  11e2		       60		      rts
    482  11e3
    483  11e3							;=========================================================================================================
    484  11e3							; Get numeric values and return value in RO and type in a
    485  11e3							;
    486  11e3				   ParseNumeric
    487  11e3		       a4 51		      ldy	CUROFF
    488  11e5		       b9 11 2f 	      lda	LINBUF,y
    489  11e8		       c9 30		      cmp	#'0
    490  11ea		       90 33		      bcc	ParseNumInvalid
    491  11ec		       c9 3a		      cmp	#'9+1
    492  11ee		       b0 2f		      bcs	ParseNumInvalid
    493  11f0		       86 58		      stx	R2
    494  11f2		       20 92 1b 	      jsr	getDecimal
    495  11f5		       a6 58		      ldx	R2
    496  11f7		       84 51		      sty	CUROFF
    497  11f9		       a5 53		      lda	R0+1
    498  11fb		       f0 14		      beq	ParseByteValue
    499  11fd
    500  11fd				   ParseIntegerValue
    501  11fd		       a9 a1		      lda	#tInteger
    502  11ff		       9d c0 0f 	      sta	TOKENBUFFER,x
    503  1202		       e8		      inx
    504  1203		       a5 52		      lda	R0
    505  1205		       9d c0 0f 	      sta	TOKENBUFFER,x
    506  1208		       e8		      inx
    507  1209		       a5 53		      lda	R0+1
    508  120b		       9d c0 0f 	      sta	TOKENBUFFER,X
    509  120e		       e8		      inx
    510  120f		       18		      clc
    511  1210		       60		      rts
    512  1211
    513  1211				   ParseByteValue
    514  1211		       a9 a2		      lda	#tByte
    515  1213		       9d c0 0f 	      sta	TOKENBUFFER,x
    516  1216		       e8		      inx
    517  1217		       a5 52		      lda	R0
    518  1219		       9d c0 0f 	      sta	TOKENBUFFER,x
    519  121c		       e8		      inx
    520  121d		       18		      clc
    521  121e		       60		      rts
    522  121f
    523  121f				   ParseNumInvalid		;Not a valid Numeric
    524  121f		       38		      sec
    525  1220		       60		      rts
    526  1221
    527  1221							;=========================================================================================================
    528  1221							;Parse for operators and seperators
    529  1221							; on exit the A has the oper code, c is clear
    530  1221							;		 not found then c is set
    531  1221							;	x is preserved
    532  1221							;
    533  1221				   ParseForOperator
    534  1221		       86 58		      stx	R2
    535  1223		       a4 51		      ldy	CUROFF
    536  1225		       a2 00		      ldx	#0
    537  1227				  -	      if	DEBUGPARSER
    538  1227				  -			;	jsr    DebugPrintOP
    539  1227					      endif
    540  1227
    541  1227				   ParseOpLoop
    542  1227		       bd 77 0e 	      lda	Operators,x	; First byte of operator
    543  122a		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    544  122c
    545  122c		       d9 11 2f 	      cmp	LINBUF,y	; Check the first byte
    546  122f		       d0 1c		      bne	ParseOpNext
    547  1231
    548  1231		       c8		      iny
    549  1232
    550  1232		       bd 78 0e 	      lda	Operators+1,x
    551  1235		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    552  1237
    553  1237		       d9 11 2f 	      cmp	LINBUF,y
    554  123a		       d0 11		      bne	ParseOpNext
    555  123c
    556  123c				   ParseOpFound
    557  123c		       c8		      iny
    558  123d
    559  123d				   ParseOpFoundSingle
    560  123d		       84 51		      sty	CUROFF
    561  123f
    562  123f		       8a		      txa
    563  1240		       4a		      lsr
    564  1241		       aa		      tax
    565  1242		       bd a5 0e 	      lda	OperValues,x
    566  1245		       a6 58		      ldx	R2
    567  1247		       9d c0 0f 	      sta	TOKENBUFFER,x
    568  124a		       e8		      inx
    569  124b		       18		      clc
    570  124c		       60		      rts
    571  124d
    572  124d				   ParseOpNext
    573  124d		       e8		      inx
    574  124e		       e8		      inx
    575  124f
    576  124f				  -	      if	DEBUGPARSER
    577  124f				  -			;	 jsr	DebugPrintOP
    578  124f					      endif
    579  124f		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    580  1251		       4c 27 12 	      jmp	ParseOpLoop
    581  1254
    582  1254				   ParseOpNotFound
    583  1254		       a6 58		      ldx	R2
    584  1256		       38		      sec
    585  1257		       60		      rts
    586  1258							;=========================================================================================================
    587  1258				  -	      if	DEBUGPARSER
    588  1258				  -			;Print the text of a keyword
    589  1258				  -			;Input R1    = offset into table
    590  1258				  -DebugKeyword
    591  1258				  -	      tya
    592  1258				  -	      pha
    593  1258				  -	      ldy	#1
    594  1258				  -DebugKeyLoop
    595  1258				  -	      lda	(R1),y
    596  1258				  -	      jsr	VOUTCH
    597  1258				  -	      and	#%00100000
    598  1258				  -	      beq	DebugKeyDone
    599  1258				  -	      iny
    600  1258				  -	      bne	DebugKeyLoop
    601  1258				  -
    602  1258				  -DebugKeyDone
    603  1258				  -	      jsr	CRLF
    604  1258				  -	      pla
    605  1258				  -	      tay
    606  1258				  -	      rts
    607  1258				  -			;========================================
    608  1258				  -DebugPrintOP
    609  1258				  -	      pha
    610  1258				  -	      lda	Operators,x
    611  1258				  -	      jsr	VOUTCH
    612  1258				  -	      lda	Operators+1,x
    613  1258				  -	      beq	DbgPrtOpDone
    614  1258				  -	      jsr	VOUTCH
    615  1258				  -
    616  1258				  -DbgPrtOpDone
    617  1258				  -	      jsr	CRLF
    618  1258				  -	      pla
    619  1258				  -	      rts
    620  1258				  -			;=======================================
    621  1258				  -DebugClearBuffer
    622  1258				  -	      txa
    623  1258				  -	      pha
    624  1258				  -	      ldx	#$FF
    625  1258				  -	      lda	#0
    626  1258				  -DebugClrLoop
    627  1258				  -	      sta	TOKENBUFFER,x
    628  1258				  -	      dex
    629  1258				  -	      bne	DebugClrLoop
    630  1258				  -	      sta	TOKENBUFFER,x
    631  1258				  -	      pla
    632  1258				  -	      tax
    633  1258				  -	      rts
    634  1258				  -
    635  1258				  -			;=====================================================
    636  1258				  -			; Print the parser buffer as hex values
    637  1258				  -printTokenBuffer
    638  1258				  -	      stx	printStorage
    639  1258				  -	      sty	printStorage+1
    640  1258				  -	      sta	printStorage+2
    641  1258				  -
    642  1258				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    643  1258				  -	      inx		; we want to show the last zero byte
    644  1258				  -	      ldy	#0
    645  1258				  -
    646  1258				  -printHexLoop
    647  1258				  -	      lda	TOKENBUFFER,y	; get the character
    648  1258				  -	      jsr	HexToOut	; print it
    649  1258				  -	      lda	#$20
    650  1258				  -	      jsr	VOUTCH
    651  1258				  -	      iny
    652  1258				  -	      dex
    653  1258				  -	      cpx	#0
    654  1258				  -	      bne	printHexLoop
    655  1258				  -	      jsr	CRLF
    656  1258				  -
    657  1258				  -	      ldy	printStorage+1
    658  1258				  -	      ldx	printStorage
    659  1258				  -	      lda	printStorage+2
    660  1258				  -printHexDone
    661  1258				  -	      clc
    662  1258				  -	      rts
    663  1258					      endif
    664  1258
    665  1258
    666  1258							;=========================================================================================================
    667  1258							; Parse for variables A-Z @, ^  x!x x[op]
    668  1258				   ParseForVariable
    669  1258		       a4 51		      ldy	CUROFF
    670  125a		       b9 11 2f 	      lda	LINBUF,y
    671  125d		       c9 5e		      cmp	#'^	; is it an exit code
    672  125f		       d0 04		      bne	ParseVarMem
    673  1261		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    674  1263		       d0 1f		      bne	ParseVarSpecial
    675  1265
    676  1265				   ParseVarMem
    677  1265		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    678  1267		       d0 04		      bne	ParseVarStack
    679  1269		       a9 9d		      lda	#tVat
    680  126b		       d0 17		      bne	ParseVarSpecial
    681  126d
    682  126d				   ParseVarStack
    683  126d		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    684  126f		       d0 04		      bne	ParseVarLetters
    685  1271		       a9 9c		      lda	#tVhash
    686  1273		       d0 0f		      bne	ParseVarSpecial
    687  1275
    688  1275				   ParseVarLetters
    689  1275		       29 df		      and	#%11011111	; Force upper case
    690  1277		       c9 41		      cmp	#'A
    691  1279		       90 12		      bcc	ParseVarInvalid
    692  127b		       c9 5b		      cmp	#'Z+1
    693  127d		       b0 0e		      bcs	ParseVarInvalid
    694  127f							;
    695  127f							; The condition is true, so convert to an index, push
    696  127f							; it onto the stack and continue running.
    697  127f							;
    698  127f		       38		      sec
    699  1280		       e9 41		      sbc	#'A	;index is zero based
    700  1282		       09 80		      ora	#$80
    701  1284
    702  1284				   ParseVarSpecial
    703  1284		       9d c0 0f 	      sta	TOKENBUFFER,x
    704  1287		       e8		      inx
    705  1288		       c8		      iny
    706  1289		       84 51		      sty	CUROFF
    707  128b		       18		      clc
    708  128c		       60		      rts
    709  128d
    710  128d				   ParseVarInvalid
    711  128d		       38		      sec
    712  128e		       60		      rts
    713  128f
    714  128f
    715  128f							;=========================================================================================================
    716  128f							; Transfer R0 to the TOKENBUFFER
    717  128f							;
    718  128f				   R02TOKEN
    719  128f		       a5 52		      lda	R0
    720  1291		       9d c0 0f 	      sta	TOKENBUFFER,x
    721  1294		       e8		      inx
    722  1295		       a5 53		      lda	R0+1
    723  1297		       9d c0 0f 	      sta	TOKENBUFFER,x
    724  129a		       e8		      inx
    725  129b		       18		      clc
    726  129c		       60		      rts
    727  129d							;=========================================================================
    728  129d							; Transfer word in Token Buffer to R0
    729  129d				   TOKEN2R0
    730  129d		       b9 c0 0f 	      lda	TOKENBUFFER,y
    731  12a0		       85 52		      sta	R0
    732  12a2		       c8		      iny
    733  12a3		       ca		      dex
    734  12a4		       b9 c0 0f 	      lda	TOKENBUFFER,y
    735  12a7		       c8		      iny
    736  12a8		       ca		      dex
    737  12a9		       85 53		      sta	R0+1
    738  12ab		       60		      rts
    739  12ac							;==========================================================================
    740  12ac							; Transfer	Display Buffer position to R0
    741  12ac							;
    742  12ac				   DPL2R0
    743  12ac		       b1 59		      lda	(dpl),y
    744  12ae		       85 52		      sta	R0
    745  12b0		       c8		      iny
    746  12b1		       ca		      dex
    747  12b2		       b1 59		      lda	(dpl),y
    748  12b4		       c8		      iny
    749  12b5		       ca		      dex
    750  12b6		       85 53		      sta	R0+1
    751  12b8		       60		      rts
    752  12b9
    753  12b9
    754  12b9							;=========================================================================
    755  12b9							; Read an IL byte lookit up in the table, of words
    756  12b9							; set the next ilpc to point to that address
    757  12b9							; if not found then do ussual filter stuff
    758  12b9							; ongoto ilvectortable, not found address
    759  12b9		       20 e3 1a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    760  12bc		       86 52		      stx	R0
    761  12be		       85 53		      sta	R0+1
    762  12c0
    763  12c0		       a4 51		      ldy	CUROFF
    764  12c2		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    765  12c4		       a0 00		      ldy	#0
    766  12c6		       38		      sec
    767  12c7		       f1 52		      sbc	(R0),y	; Subract the base value
    768  12c9		       c8		      iny
    769  12ca		       d1 52		      cmp	(R0),y	; Check if we are in range
    770  12cc		       b0 12		      bcs	iOnGotoInvalid
    771  12ce		       e6 51		      inc	CUROFF	; Save the offset
    772  12d0
    773  12d0		       0a		      asl
    774  12d1		       a8		      tay		; Turn into vector
    775  12d2		       c8		      iny		; Inc must include the table base and entry count
    776  12d3		       c8		      iny
    777  12d4
    778  12d4		       b1 52		      lda	(R0),y
    779  12d6		       85 43		      sta	ILPC
    780  12d8		       c8		      iny
    781  12d9		       b1 52		      lda	(R0),y
    782  12db		       85 44		      sta	ILPC+1
    783  12dd		       4c c2 02 	      jmp	NextIL
    784  12e0
    785  12e0				   iOnGotoInvalid
    786  12e0		       20 e3 1a 	      jsr	getILWord
    787  12e3		       86 43		      stx	ILPC
    788  12e5		       85 44		      sta	ILPC+1
    789  12e7		       4c c2 02 	      jmp	NextIL
    790  12ea							;
    791  12ea							;==========================================================================================
    792  12ea							; Test the token for relop and push the value onto the stack if true
    793  12ea							;
    794  12ea				   iTSTRELOP
    795  12ea		       20 e7 1a 	      jsr	getILByte
    796  12ed		       8d aa 2f 	      sta	offset
    797  12f0
    798  12f0		       a4 51		      ldy	CUROFF
    799  12f2		       b1 4f		      lda	(CURPTR),y
    800  12f4		       48		      pha
    801  12f5		       29 f0		      and	#$F0
    802  12f7		       c9 f0		      cmp	#$F0
    803  12f9		       d0 12		      bne	iTSTRELOPNOT
    804  12fb		       68		      pla
    805  12fc		       29 0f		      and	#$0F	; get the actual value
    806  12fe		       85 52		      sta	R0	; save it for later
    807  1300		       a9 00		      lda	#0
    808  1302		       85 53		      sta	R0+1
    809  1304		       20 e0 1c 	      jsr	pushR0
    810  1307		       c8		      iny
    811  1308		       84 51		      sty	CUROFF	; save the y pointer
    812  130a		       4c c2 02 	      jmp	NextIL
    813  130d
    814  130d				   iTSTRELOPNOT
    815  130d		       68		      pla
    816  130e		       4c 8a 0b 	      jmp	tstBranch
    817  1311
    818  1311							;
    819  1311							;===================================================================================================
    820  1311							; Test the token and following info for precompiled address information
    821  1311							; skip it if zero, transfer and skip next integer value if not zero
    822  1311							; used by both gosub, goto and gofN
    823  1311							;
    824  1311				   iTSTBRANCH
    825  1311		       20 e7 1a 	      jsr	getILByte	; Get jump address if vector is valid
    826  1314		       8d aa 2f 	      sta	offset	; Mark offset for later if vector found
    827  1317		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    828  1319		       88		      dey		; point back to the type of branch
    829  131a		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    830  131c		       48		      pha		; Save till needed
    831  131d		       c8		      iny		; back to memory vectors
    832  131e				   ITSTBRANCHCont
    833  131e		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    834  1320		       85 52		      sta	R0	; R0 will contain mem pointer of present
    835  1322		       c8		      iny		; Point to next byte of mem vector
    836  1323		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    837  1325		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    838  1327		       c8		      iny		; Point to the byte past memory vector
    839  1328		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    840  132a
    841  132a		       05 52		      ora	R0	; Get the second byte of the mem
    842  132c		       f0 21		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    843  132e		       68		      pla
    844  132f		       c9 29		      cmp	#kTask	; Task defied with Task() so bypass the first bracket
    845  1331		       d0 07		      bne	iTSTBRANCHCont
    846  1333		       b1 4f		      lda	(CURPTR),y
    847  1335		       c9 e0		      cmp	#oLeftBracket
    848  1337		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    849  1339		       c8		      iny		; Increment past the bracket
    850  133a				   iTSTBRANCHCont
    851  133a		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    852  133c		       c9 a2		      cmp	#tByte	; A byte value is valid
    853  133e		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    854  1340		       c9 a1		      cmp	#tInteger	; An integer value is valid
    855  1342		       d0 0b		      bne	iTSTBRANCHNoCompile	; If not then we can not use the memory vector
    856  1344		       c8		      iny		; skip type indicator for
    857  1345				   ITSTBRANCHBYTE
    858  1345		       c8		      iny		; skip first byte of value line number
    859  1346		       c8		      iny		; Skip second byte of line number
    860  1347
    861  1347				   iTSTBRANCHVALID
    862  1347		       84 51		      sty	CUROFF
    863  1349		       20 e0 1c 	      jsr	pushR0	; place transfer address on top of stack
    864  134c		       4c 8a 0b 	      jmp	tstBranch
    865  134f
    866  134f				   iTSTBRANCHNoCompile
    867  134f		       68		      pla
    868  1350				   iTSTBRANCHErr
    869  1350		       4c c2 02 	      jmp	NextIL
    870  1353
    871  1353
    872  1353
    873  1353
    874  1353
    875  1353
    876  1353
    877  1353
    878  1353
    879  1353
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  1353					      include	"print.asm"
      1  1353					      Seg	Code
      2  1353							;---------------------------
      3  1353							; Print 24-bit decimal number or  16bit unsigned
      4  1353							; ---------------------------
      5  1353							; On entry, R0=number to print
      6  1353							;	     Defaults to pad=0 , y=21 default
      7  1353							;	     R2 = 1 unsigned 16 bit
      8  1353							;	     R2 = 0 Signed   16 bit
      9  1353
     10  1353							; On entry at PrintDecPadded:
     11  1353							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  1353
     13  1353							; On exit,  A,X,Y,num,pad corrupted
     14  1353							; Size      129 bytes, Table 24 bytes	--- total 153
     15  1353							; -----------------------------------------------------------------
     16  1353
     17  1353				   PrintDecimal
     18  1353		       8a		      TXA
     19  1354		       48		      pha
     20  1355		       98		      tya
     21  1356		       48		      pha
     22  1357		       a9 00		      lda	#0
     23  1359		       8d ec 13 	      sta	pad
     24  135c		       a0 15		      LDY	#21	; Offset to powers of ten
     25  135e		       4c 64 13 	      JMP	PrintDo
     26  1361
     27  1361				   PrintDecPadded
     28  1361		       8e ec 13 	      stx	pad
     29  1364
     30  1364				   PrintDo
     31  1364		       a9 00		      lda	#0
     32  1366		       85 54		      sta	R1
     33  1368
     34  1368		       a5 58		      lda	R2
     35  136a		       d0 29		      bne	PrintPos
     36  136c
     37  136c		       a5 53		      lda	R0+1	;MSB has sign
     38  136e		       10 25		      bpl	PrintPos	;it's a positive number;
     39  1370
     40  1370
     41  1370							; Negative numbers need more work.  Invert all the bits,
     42  1370							; then add one.
     43  1370
     44  1370		       a9 2d		      lda	#'-
     45  1372		       20 79 1f 	      jsr	VOUTCH	;print the negative sign
     46  1375
     47  1375		       a9 ff		      lda	#$FF
     48  1377		       85 54		      sta	R1
     49  1379		       a5 52		      lda	R0	;invert bits
     50  137b		       49 ff		      eor	#$ff
     51  137d		       85 52		      sta	R0
     52  137f		       a5 53		      lda	R0+1
     53  1381		       49 ff		      eor	#$ff
     54  1383		       85 53		      sta	R0+1
     55  1385		       a5 54		      lda	R1
     56  1387		       49 ff		      eor	#$ff
     57  1389		       85 54		      sta	R1
     58  138b		       e6 52		      inc	R0	;add one
     59  138d		       d0 06		      bne	PrintPos
     60  138f		       e6 53		      inc	R0+1
     61  1391		       d0 02		      bne	PrintPos
     62  1393		       e6 54		      inc	R1
     63  1395				   PrintPos
     64  1395
     65  1395				   PrDec24Lp1
     66  1395		       a2 ff		      LDX	#$FF
     67  1397		       38		      SEC		; Start with digit=-1
     68  1398				   PrDec24Lp2
     69  1398		       a5 52		      LDA	R0+0
     70  139a		       f9 ed 13 	      SBC	PrDec24Tens+0,Y
     71  139d		       85 52		      STA	R0+0	; Subtract current tens
     72  139f		       a5 53		      LDA	R0+1
     73  13a1		       f9 ee 13 	      SBC	PrDec24Tens+1,Y
     74  13a4		       85 53		      STA	R0+1
     75  13a6		       a5 54		      LDA	R0+2
     76  13a8		       f9 ef 13 	      SBC	PrDec24Tens+2,Y
     77  13ab		       85 54		      STA	R0+2
     78  13ad		       e8		      INX
     79  13ae		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  13b0		       a5 52		      LDA	R0+0
     81  13b2		       79 ed 13 	      ADC	PrDec24Tens+0,Y
     82  13b5		       85 52		      STA	R0+0	; Add current tens back in
     83  13b7		       a5 53		      LDA	R0+1
     84  13b9		       79 ee 13 	      ADC	PrDec24Tens+1,Y
     85  13bc		       85 53		      STA	R0+1
     86  13be		       a5 54		      LDA	R0+2
     87  13c0		       79 ef 13 	      ADC	PrDec24Tens+2,Y
     88  13c3		       85 54		      STA	R0+2
     89  13c5		       8a		      TXA
     90  13c6		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  13c8		       ad ec 13 	      LDA	pad
     92  13cb		       d0 09		      BNE	PrDec24Print
     93  13cd		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  13cf				   PrDec24Digit
     95  13cf		       a2 30		      LDX	#'0
     96  13d1		       8e ec 13 	      STX	pad	; No more zero padding
     97  13d4		       09 30		      ORA	#'0	; Print this digit
     98  13d6				   PrDec24Print
     99  13d6		       20 79 1f 	      JSR	VOUTCH
    100  13d9				   PrDec24Next
    101  13d9		       88		      DEY
    102  13da		       88		      DEY
    103  13db		       88		      DEY
    104  13dc		       f0 07		      beq	PrDec24LastDigit
    105  13de		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  13e0		       68		      pla
    107  13e1		       a8		      tay
    108  13e2		       68		      pla
    109  13e3		       aa		      tax
    110  13e4		       60		      RTS
    111  13e5				   PrDec24LastDigit
    112  13e5		       a2 30		      LDX	#'0
    113  13e7		       8e ec 13 	      STX	pad	; No more zero padding
    114  13ea		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  13ec
      0  13ec				   pad	      db	0
      1  13ec		       00		      .byte.b	0
    117  13ed
    118  13ed				   PrDec24Tens
      0  13ed					      dw	1
      1  13ed		       01 00		      .word.w	1
      0  13ef					      db	(1 / 65536)
      1  13ef		       00		      .byte.b	(1 / 65536)
      0  13f0					      dw	10
      1  13f0		       0a 00		      .word.w	10
      0  13f2					      db	(10 / 65536)
      1  13f2		       00		      .byte.b	(10 / 65536)
      0  13f3					      dw	100
      1  13f3		       64 00		      .word.w	100
      0  13f5					      db	(100 / 65536)
      1  13f5		       00		      .byte.b	(100 / 65536)
      0  13f6					      dw	1000
      1  13f6		       e8 03		      .word.w	1000
      0  13f8					      db	(1000 / 65536)
      1  13f8		       00		      .byte.b	(1000 / 65536)
      0  13f9					      dw	10000
      1  13f9		       10 27		      .word.w	10000
      0  13fb					      db	(10000 / 65536)
      1  13fb		       00		      .byte.b	(10000 / 65536)
      0  13fc					      dw	100000
      1  13fc		       a0 86		      .word.w	100000
      0  13fe					      db	(100000 / 65536)
      1  13fe		       01		      .byte.b	(100000 / 65536)
      0  13ff					      dw	1000000
      1  13ff		       40 42		      .word.w	1000000
      0  1401					      db	(1000000 / 65536)
      1  1401		       0f		      .byte.b	(1000000 / 65536)
      0  1402					      dw	10000000
      1  1402		       80 96		      .word.w	10000000
      0  1404					      db	(10000000 / 65536)
      1  1404		       98		      .byte.b	(10000000 / 65536)
    135  1405							;=====================================================
    136  1405							; Print character in A as two hex digits to the Console
    137  1405
    138  1405		       48	   HexToOut   pha		;save return value
    139  1406		       48		      pha
    140  1407		       4a		      lsr		;a  ;move top nibble to bottom
    141  1408		       4a		      lsr		;a
    142  1409		       4a		      lsr		;a
    143  140a		       4a		      lsr		;a
    144  140b		       20 14 14 	      jsr	hexta	;output nibble
    145  140e		       68		      pla
    146  140f		       20 14 14 	      jsr	hexta
    147  1412		       68		      pla		;restore
    148  1413		       60		      rts
    149  1414							;
    150  1414		       29 0f	   hexta      and	#%0001111
    151  1416		       c9 0a		      cmp	#$0a
    152  1418		       18		      clc
    153  1419		       30 02		      bmi	hexta1
    154  141b		       69 07		      adc	#7
    155  141d		       69 30	   hexta1     adc	#'0	;then fall into...
    156  141f		       4c 79 1f 	      jmp	VOUTCH
    157  1422							;
    158  1422							;=====================================================
    159  1422							; Print the string that immediately follows the JSR to
    160  1422							; this function.  Stops when a null byte is found,
    161  1422							; then returns to the instruction immediately
    162  1422							; following the null.
    163  1422							;
    164  1422							; Thanks to Ross Archer for this code.
    165  1422							; http://www.6502.org/source/io/primm.htm
    166  1422							;
    167  1422
    168  1422		       68	   tbputs     pla		;Get the low part of "return" address
    169  1423							;(data start address)
    170  1423		       85 5e		      sta	PrtFrom
    171  1425		       68		      pla
    172  1426		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    173  1428							;(data start address)
    174  1428							;Note: actually we're pointing one short
    175  1428		       a0 01	   PSINB      ldy	#1
    176  142a		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    177  142c		       e6 5e		      inc	PrtFrom	;update the pointer
    178  142e		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    179  1430		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    180  1432		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    181  1434							;   Accumulator
    182  1434		       f0 06		      beq	PSIX1	;don't print the final NULL
    183  1436		       20 79 1f 	      jsr	VOUTCH	;write it out
    184  1439		       4c 28 14 	      jmp	PSINB	;back around
    185  143c		       e6 5e	   PSIX1      inc	PrtFrom
    186  143e		       d0 02		      bne	PSIX2
    187  1440		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    188  1442		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    189  1445
    190  1445							;+
    191  1445							;====================================================
    192  1445		       2f a6	   PrtTerm    equ	tempy
    193  1445
    194  1445							; on exit Print Y has the offset to use
    195  1445							; input y =	 addr low
    196  1445							;	 x =	 addr high
    197  1445							;	 a =	 termination string
    198  1445
    199  1445
    200  1445				   PrtQuoted		; Print a quoted string from the current program space
    201  1445		       a9 22		      lda	#'"
    202  1447		       a4 51		      ldy	CUROFF
    203  1449		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    204  144b		       d0 03		      bne	PrtNoInc
    205  144d		       c8		      iny
    206  144e		       84 51		      sty	CUROFF
    207  1450				   PrtNoInc
    208  1450		       8d a6 2f 	      sta	PrtTerm
    209  1453
    210  1453				   PrtPrgString 		; Print a terminated string from the static program space
    211  1453		       a4 51		      ldy	CUROFF
    212  1455		       a5 4f		      lda	CURPTR
    213  1457		       85 5e		      sta	PrtFrom
    214  1459		       a5 50		      lda	CURPTR+1
    215  145b		       85 5f		      sta	PrtFrom+1
    216  145d		       4c 69 14 	      jmp	PrtLoop
    217  1460
    218  1460							; Print a string pointed to by x= h, y=l terminated by a
    219  1460							; Return y as the length
    220  1460
    221  1460		       86 5f	   PrtStr     stx	PrtFrom+1
    222  1462		       84 5e		      sty	PrtFrom
    223  1464		       8d a6 2f 	      sta	PrtTerm
    224  1467		       a0 00		      ldy	#0
    225  1469							;
    226  1469							; On entry here ptrfrom and prtterm point to area to print
    227  1469							;
    228  1469		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    229  146b		       cd a6 2f 	      cmp	PrtTerm
    230  146e		       f0 0b		      beq	PrtEnd
    231  1470		       c9 00		      cmp	#0	; always end if 0 is found
    232  1472		       f0 07		      beq	PrtEnd
    233  1474		       20 79 1f 	      jsr	VOUTCH
    234  1477		       c8		      iny
    235  1478		       4c 69 14 	      jmp	PrtLoop
    236  147b		       c8	   PrtEnd     iny		;return byte after the copy
    237  147c		       60		      rts
    238  147d
    239  147d							;
    240  147d							;=======================================================
    241  147d							; Print all Variables
    242  147d				   PrintAllVars
    243  147d		       a0 00		      ldy	#0
    244  147f		       a9 41		      lda	#'A
    245  1481				   PrintAllVarsLoop
    246  1481		       48		      pha
    247  1482		       b1 41		      lda	(VARIABLES),y
    248  1484		       85 52		      sta	R0
    249  1486		       c8		      iny
    250  1487		       b1 41		      lda	(VARIABLES),y
    251  1489		       85 53		      sta	R0+1
    252  148b
    253  148b		       68		      pla		;get the current letter
    254  148c		       48		      pha
    255  148d		       20 79 1f 	      jsr	VOUTCH
    256  1490		       20 22 14 	      jsr	puts
      0  1493					      db	"=",0
      1  1493		       3d 00		      .byte.b	"=",0
    258  1495		       68		      pla
    259  1496		       aa		      tax
    260  1497		       e8		      inx
    261  1498		       8a		      txa
    262  1499		       48		      pha		;
    263  149a
    264  149a		       98		      tya
    265  149b		       48		      pha
    266  149c		       20 53 13 	      jsr	PrintDecimal
    267  149f		       20 22 14 	      jsr	puts
      0  14a2					      db	" ",0
      1  14a2		       20 00		      .byte.b	" ",0
    269  14a4		       68		      pla
    270  14a5		       a8		      tay
    271  14a6		       c8		      iny
    272  14a7		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    273  14a9		       90 d6		      bcc	PrintAllVarsLoop
    274  14ab		       20 2b 1e 	      jsr	CRLF
    275  14ae
    276  14ae		       68		      pla
    277  14af		       60		      rts
    278  14b0							;==========================================================================================================
    279  14b0							;Debug   Print a Program Line from compile buffer
    280  14b0							;
    281  14b0				   DebugPrintProgramLine
    282  14b0		       48		      pha
    283  14b1		       a9 c0		      lda	#TOKENBUFFER&$FF
    284  14b3		       85 59		      sta	dpl
    285  14b5		       a9 0f		      lda	#TOKENBUFFER>>8
    286  14b7		       85 5a		      sta	dpl+1
    287  14b9		       68		      pla
    288  14ba
    289  14ba							; Decode and print a line of program text
    290  14ba							; on entry	 dpl points to line of code to print
    291  14ba							; on exit	 no change in reg or dpl
    292  14ba							;
    293  14ba				   PrintProgramLine
    294  14ba
    295  14ba		       8e c0 10 	      stx	printStorage
    296  14bd		       8c c1 10 	      sty	printStorage+1
    297  14c0		       48		      pha
    298  14c1
    299  14c1		       a0 01		      ldy	#1	; index into the token buffer
    300  14c3		       84 58		      sty	R2	; print unsigned decimal
    301  14c5		       a0 00		      ldy	#0
    302  14c7		       b1 59		      lda	(dpl),y	; get number of bytes
    303  14c9		       aa		      tax		; place pointer into x
    304  14ca		       c8		      iny
    305  14cb		       ca		      dex		; Deduct the length byte
    306  14cc		       20 ac 12 	      jsr	DPL2R0	; Print the line number
    307  14cf		       20 53 13 	      jsr	PrintDecimal
    308  14d2		       a9 20		      lda	#$20
    309  14d4		       20 79 1f 	      jsr	VOUTCH
    310  14d7
    311  14d7				   PrintProgLoop
    312  14d7		       b1 59		      lda	(dpl),y	; Get a character
    313  14d9		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    314  14db		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    315  14dd		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    316  14df
    317  14df				   PrintProgVars
    318  14df		       b1 59		      lda	(dpl),y
    319  14e1		       29 e0		      and	#$E0	; Check for operators and punctuation
    320  14e3		       c9 e0		      cmp	#$E0
    321  14e5		       f0 6b		      beq	PrintProgOperatorVect
    322  14e7
    323  14e7		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    324  14e9		       c9 9e		      cmp	#$9D+1
    325  14eb		       90 62		      bcc	PrintProgVariableVec
    326  14ed		       29 a0		      and	#$A0	; Check for a valid datatype
    327  14ef		       c9 a0		      cmp	#$A0
    328  14f1		       f0 06		      beq	PrintDataType	; if not just print the character
    329  14f3		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    330  14f5		       ca		      dex		; Ok we are processing it
    331  14f6		       c8		      iny
    332  14f7		       d0 25		      bne	PrintContinue	; Print and do the next character
    333  14f9
    334  14f9				   PrintDataType
    335  14f9		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    336  14fb		       c9 a0		      cmp	#tString
    337  14fd		       f0 31		      beq	PrintStringVariable
    338  14ff
    339  14ff				   PrintProgNumber
    340  14ff		       c8		      iny		; we have a numerical integer value
    341  1500		       ca		      dex
    342  1501		       48		      pha
    343  1502		       a9 00		      lda	#0
    344  1504		       85 53		      sta	R0+1
    345  1506		       85 58		      sta	R2	; Set to print signed number
    346  1508		       b1 59		      lda	(dpl),y
    347  150a		       85 52		      sta	R0
    348  150c		       68		      pla
    349  150d		       c9 a1		      cmp	#tInteger
    350  150f		       d0 06		      bne	PrintProgNumDone
    351  1511		       c8		      iny
    352  1512		       ca		      dex
    353  1513		       b1 59		      lda	(dpl),y
    354  1515		       85 53		      sta	R0+1
    355  1517
    356  1517				   PrintProgNumDone
    357  1517		       c8		      iny
    358  1518		       ca		      dex
    359  1519		       20 53 13 	      jsr	PrintDecimal
    360  151c
    361  151c				   PrintProgNext
    362  151c		       a9 20		      lda	#$20
    363  151e				   PrintContinue
    364  151e		       20 79 1f 	      jsr	VOUTCH
    365  1521				   PrintProgSkipSpace
    366  1521		       e0 00		      cpx	#0
    367  1523		       d0 b2		      bne	PrintProgLoop
    368  1525				   PrintProgramComplete
    369  1525		       20 2b 1e 	      jsr	CRLF
    370  1528
    371  1528		       ae c0 10 	      ldx	printStorage
    372  152b		       ac c1 10 	      ldy	printStorage+1
    373  152e		       68		      pla
    374  152f
    375  152f		       60		      rts
    376  1530							;=================================================================================================================
    377  1530							; Print a string variable including the quotes
    378  1530							; On Input	 y is offset into buffer
    379  1530							; On Exit	 y is updated to new offset
    380  1530
    381  1530				   PrintStringVariable
    382  1530		       c8		      iny
    383  1531		       a9 22		      lda	#'"
    384  1533		       20 79 1f 	      jsr	VOUTCH
    385  1536		       c8		      iny
    386  1537		       a5 59		      lda	dpl
    387  1539		       85 5e		      sta	PrtFrom
    388  153b		       a5 5a		      lda	dpl+1
    389  153d		       85 5f		      sta	PrtFrom+1
    390  153f		       a9 22		      lda	#'"
    391  1541		       8d a6 2f 	      sta	PrtTerm
    392  1544		       20 69 14 	      jsr	PrtLoop
    393  1547		       a9 22		      lda	#'"
    394  1549		       20 79 1f 	      jsr	VOUTCH
    395  154c		       4c 1c 15 	      jmp	PrintProgNext
    396  154f
    397  154f				   PrintProgVariableVec
    398  154f		       4c ef 15 	      jmp	PrintProgVariable
    399  1552
    400  1552				   PrintProgOperatorVect
    401  1552		       4c c6 15 	      jmp	PrintProgOperator
    402  1555							;===============================================================================================================
    403  1555							; On entry dpl points to the buffer we are printing from
    404  1555							;	    y	current offset into the dpl buffer
    405  1555							; all registers preserved
    406  1555							;
    407  1555				   PrintKeyword
    408  1555
    409  1555		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    410  1557		       85 52		      sta	R0	; The value we are looking for
    411  1559		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    412  155b		       f0 0c		      beq	PrintKeyBranch
    413  155d		       c9 08		      cmp	#kGosub
    414  155f		       f0 08		      beq	PrintKeyBranch
    415  1561		       c9 29		      cmp	#kTask
    416  1563		       f0 04		      beq	PrintKeyBranch
    417  1565		       c9 31		      cmp	#kGofn
    418  1567		       d0 04		      bne	PrintKeySkipped
    419  1569				   PrintKeyBranch
    420  1569		       c8		      iny		; Skip the compiled memory address
    421  156a		       c8		      iny
    422  156b		       ca		      dex		; Change number of bytes to print
    423  156c		       ca		      dex		; Remove the bytes to print
    424  156d
    425  156d				   PrintKeySkipped
    426  156d		       c8		      iny		; Inc y to point to the next char to be printed
    427  156e		       ca		      dex		; Reduce number of bytes to print
    428  156f		       98		      tya		; Save y and x for the return
    429  1570		       48		      pha
    430  1571		       8a		      txa
    431  1572		       48		      pha
    432  1573
    433  1573		       a9 bb		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    434  1575		       85 54		      sta	R1
    435  1577		       a9 0e		      lda	#KeyWordTable>>8
    436  1579		       85 55		      sta	R1+1
    437  157b
    438  157b
    439  157b				   PrintKeyLoop
    440  157b		       a0 00		      ldy	#0	; Index into the keyword entry
    441  157d		       b1 54		      lda	(R1),y	; Get token value for this entry
    442  157f		       c8		      iny		; Point to first byte of key
    443  1580		       c5 52		      cmp	R0	; Compare to the token we are looking for
    444  1582		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    445  1584
    446  1584				   PrintKeyNext
    447  1584		       b1 54		      lda	(R1),y	; Get key letter
    448  1586		       c8		      iny		; Point to next byte always
    449  1587		       29 20		      and	#%00100000	; Check for last character in key work
    450  1589		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    451  158b
    452  158b		       98		      tya		; Trabsfer y to a for the addition
    453  158c		       18		      clc		; Table > 256 bytes
    454  158d		       65 54		      adc	R1
    455  158f		       85 54		      sta	R1
    456  1591		       a9 00		      lda	#0
    457  1593		       65 55		      adc	R1+1
    458  1595		       85 55		      sta	R1+1
    459  1597		       4c 7b 15 	      jmp	PrintKeyLoop
    460  159a
    461  159a				   PrintKeyFound
    462  159a		       b1 54		      lda	(R1),y	; letter from key table
    463  159c		       48		      pha		; Save it for later check
    464  159d		       09 20		      ora	#%00100000	; Force it to lower case
    465  159f		       20 79 1f 	      jsr	VOUTCH	; Print it out
    466  15a2		       c8		      iny		; Point to next character
    467  15a3		       68		      pla		; Restore the value
    468  15a4		       29 20		      and	#%00100000	; Check if it was last char in keyword
    469  15a6		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    470  15a8
    471  15a8		       68		      pla		; Restore the x and y values
    472  15a9		       aa		      tax
    473  15aa		       68		      pla
    474  15ab		       a8		      tay
    475  15ac
    476  15ac				   PrintChkRem
    477  15ac		       a9 0a		      lda	#kRem
    478  15ae		       c5 52		      cmp	R0
    479  15b0		       d0 11		      bne	PrintKeyDone
    480  15b2				   PrintKeyRem
    481  15b2		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    482  15b4		       85 5e		      sta	PrtFrom
    483  15b6		       a5 5a		      lda	dpl+1
    484  15b8		       85 5f		      sta	PrtFrom+1
    485  15ba		       a9 00		      lda	#0
    486  15bc		       8d a6 2f 	      sta	PrtTerm
    487  15bf		       20 69 14 	      jsr	PrtLoop
    488  15c2		       88		      dey		; point back to the terminating null value
    489  15c3				   PrintKeyDone
    490  15c3		       4c 1c 15 	      jmp	PrintProgNext
    491  15c6							;==================================================================================================================
    492  15c6							;Print Variable, number or operator
    493  15c6				   PrintProgOperator
    494  15c6		       b1 59		      lda	(dpl),y
    495  15c8		       c8		      iny
    496  15c9		       ca		      dex
    497  15ca		       8e c2 10 	      stx	printStorage+2
    498  15cd		       a2 00		      ldx	#0
    499  15cf				   PrintOprLoop
    500  15cf		       dd a5 0e 	      cmp	OperValues,x
    501  15d2		       f0 03		      beq	PrintOprFound
    502  15d4		       e8		      inx
    503  15d5		       d0 f8		      bne	PrintOprLoop
    504  15d7				   PrintOprFound
    505  15d7		       8a		      txa
    506  15d8		       0a		      asl
    507  15d9		       aa		      tax
    508  15da		       bd 77 0e 	      lda	Operators,x
    509  15dd		       20 79 1f 	      jsr	VOUTCH
    510  15e0		       e8		      inx
    511  15e1		       bd 77 0e 	      lda	Operators,x
    512  15e4		       f0 03		      beq	PrintOprDone
    513  15e6		       20 79 1f 	      jsr	VOUTCH
    514  15e9				   PrintOprDone
    515  15e9		       ae c2 10 	      ldx	printStorage+2
    516  15ec		       4c 1c 15 	      jmp	PrintProgNext
    517  15ef
    518  15ef							;=================================================================================================================
    519  15ef							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    520  15ef							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    521  15ef							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    522  15ef							;tVhat 	    equ     155 		   ; Variable ^
    523  15ef							;tVhash	    equ     156 		   ; Variable #
    524  15ef							;tVat		    equ     157 		   ; Variable @ = 0
    525  15ef				   PrintProgVariable
    526  15ef		       b1 59		      lda	(dpl),y
    527  15f1		       c8		      iny
    528  15f2		       ca		      dex
    529  15f3		       c9 9b		      cmp	#tVhat
    530  15f5		       d0 04		      bne	PrintProgChkHash
    531  15f7		       a9 5e		      lda	#'^
    532  15f9		       d0 15		      bne	PrintTheVar
    533  15fb				   PrintProgChkHash
    534  15fb		       c9 9c		      cmp	#tVhash
    535  15fd		       d0 04		      bne	PrintProgChkAt
    536  15ff		       a9 23		      lda	#'#
    537  1601		       d0 0d		      bne	PrintTheVar
    538  1603				   PrintProgChkAt
    539  1603		       c9 9d		      cmp	#tVat
    540  1605		       d0 04		      bne	PrintProgVarLetter
    541  1607		       a9 40		      lda	#'@
    542  1609		       d0 05		      bne	PrintTheVar
    543  160b				   PrintProgVarLetter
    544  160b		       29 7f		      and	#%01111111
    545  160d		       18		      clc
    546  160e		       69 41		      adc	#'A
    547  1610				   PrintTheVar
    548  1610		       20 79 1f 	      jsr	VOUTCH
    549  1613		       4c 1c 15 	      jmp	PrintProgNext
    550  1616
    551  1616
    552  1616							;==================================================================================================
    553  1616							; Size of print functions
    554  1616		       02 c3	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  1616					      include	"mem.asm"
      1  1616							;===================================================================
      2  1616							;This file contains the memory allocation and free functions
      3  1616							;in herant in this is the management of free memory in the system
      4  1616							; the interface to these functions
      5  1616							; a,x returns or provides the low hi bytes of the managed addresses
      6  1616							; This uses the programend, to memory end as the area to manage
      7  1616							;===================================================================
      8  1616					      Seg	Code
      9  1616							;=====================================================
     10  1616							;Pointers for memory Management
     11  1616							;Allocated block are not chained but can be followed for all memory by the associated length
     12  1616							; Mem block format is
     13  1616							;	 0-1   pointer to next block for free blocks
     14  1616							;	 0-1   for allocated blocks
     15  1616							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  1616							;	   1   refrence counter ... lol only up to 256 but it is something
     17  1616							;	 2-3   length constant for exevy type of memory block
     18  1616							; Memory is recombined as it is released
     19  1616							; The memory manager is not interupted durring allocation
     20  1616							; or freeing of memory
     21  1616							; Memory is allocated from the highest memory address towards
     22  1616							; the lowest memory address. meeting the Basic program end.
     23  1616							;====================================================
     24  1616							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  1616							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  1616							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  1616							;=====================================================
     28  1616				   MemInit
     29  1616		       a9 b8		      lda	#FreeMemStart&$FF
     30  1618		       8d ae 2f 	      sta	ProgramStart
     31  161b		       8d b0 2f 	      sta	ProgramEnd
     32  161e		       a9 2f		      lda	#FreeMemStart>>8
     33  1620		       8d af 2f 	      sta	ProgramStart+1
     34  1623		       8d b1 2f 	      sta	ProgramEnd+1
     35  1626
     36  1626		       20 30 16 	      jsr	GetSizes
     37  1629		       20 3b 16 	      jsr	MemFree
     38  162c		       20 53 16 	      jsr	MemUsed
     39  162f				   MemInitEnd
     40  162f		       60		      rts
     41  1630
     42  1630
     43  1630							;
     44  1630							;=====================================================
     45  1630							; This function might go away eventually, but was
     46  1630							; added to provide data for other pieces of code.
     47  1630							; It has some ties to the operating environment that
     48  1630							; will need to be customized for the target system.
     49  1630							;
     50  1630				   GetSizes
     51  1630							;
     52  1630							; Here is machine specific code to get the highest
     53  1630							; memory location that can be used by BASIC.
     54  1630							;
     55  1630				  -	      if	ProgramStart < $2000
     56  1630				  -	      lda	#$ff
     57  1630				  -	      sta	HighMem	;$13ff for KIM-1
     58  1630				  -	      sta	MemFreeList
     59  1630				  -	      lda	#$DE	;#$13
     60  1630				  -	      sta	HighMem+1
     61  1630				  -	      sta	MemFreeList+1
     62  1630					      else
     63  1630		       a9 ff		      lda	#$ff
     64  1632		       8d b2 2f 	      sta	HighMem	;$CFFF otherwise
     65  1635		       a9 cf		      lda	#$cf
     66  1637		       8d b3 2f 	      sta	HighMem+1
     67  163a					      endif
     68  163a		       60		      rts
     69  163b							;
     70  163b							; This computes the available memory remaining.
     71  163b							;
     72  163b				   MemFree
     73  163b		       38		      sec
     74  163c		       ad b2 2f 	      lda	HighMem
     75  163f		       ed b0 2f 	      sbc	ProgramEnd
     76  1642		       8d b6 2f 	      sta	FreeMem
     77  1645		       85 52		      sta	R0
     78  1647		       ad b3 2f 	      lda	HighMem+1
     79  164a		       ed b1 2f 	      sbc	ProgramEnd+1
     80  164d		       8d b7 2f 	      sta	FreeMem+1
     81  1650		       85 53		      sta	R0+1
     82  1652		       60		      rts
     83  1653							;
     84  1653							; This computes the size of the current user program.
     85  1653							;
     86  1653				   MemUsed
     87  1653		       38		      sec
     88  1654		       ad b0 2f 	      lda	ProgramEnd
     89  1657		       ed ae 2f 	      sbc	ProgramStart
     90  165a		       8d b4 2f 	      sta	UsedMem
     91  165d		       85 52		      sta	R0
     92  165f		       ad b1 2f 	      lda	ProgramEnd+1
     93  1662		       ed af 2f 	      sbc	ProgramStart+1
     94  1665		       8d b5 2f 	      sta	UsedMem+1
     95  1668		       85 53		      sta	R0+1
     96  166a							;
     97  166a		       60		      rts
     98  166b
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  166b					      include	"gosub.asm"
      1  166b					      seg	Code
      2  166b
      3  166b							; Gosub and return related functions
      4  166b							;==========================================================
      5  166b							; Push the current math stack frame onto the gosub stack
      6  166b				   iPushMathStack
      7  166b		       98		      tya
      8  166c		       48		      pha
      9  166d		       a4 4d		      ldy	GOSUBSTACKPTR
     10  166f		       a5 4a		      lda	MATHSTACKPTR
     11  1671		       91 4b		      sta	(GOSUBSTACK),y
     12  1673		       a9 00		      lda	#0
     13  1675		       c8		      iny
     14  1676		       91 4b		      sta	(GOSUBSTACK),y
     15  1678		       c8		      iny
     16  1679		       91 4b		      sta	(GOSUBSTACK),y
     17  167b		       c8		      iny
     18  167c		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  167e		       91 4b		      sta	(GOSUBSTACK),y
     20  1680		       c8		      iny
     21  1681		       84 4d		      sty	GOSUBSTACKPTR
     22  1683		       68		      pla
     23  1684		       a8		      tay
     24  1685		       4c c2 02 	      jmp	NextIL
     25  1688							;
     26  1688							;==========================================================
     27  1688							; Increment parameter count. Assume Stack frame is top of stack
     28  1688				   iIncParmCount
     29  1688		       98		      tya
     30  1689		       48		      pha
     31  168a		       a4 4d		      ldy	GOSUBSTACKPTR
     32  168c		       88		      dey
     33  168d		       88		      dey
     34  168e		       88		      dey
     35  168f		       b1 4b		      lda	(GOSUBSTACK),y
     36  1691		       aa		      tax
     37  1692		       e8		      inx
     38  1693		       8a		      txa
     39  1694		       91 4b		      sta	(GOSUBSTACK),y
     40  1696		       68		      pla
     41  1697		       a8		      tay
     42  1698		       4c c2 02 	      jmp	NextIL
     43  169b							;
     44  169b							;==========================================================
     45  169b							;Restore the math stack frame
     46  169b		       20 a1 16    iPopMathStack jsr	PopMathStackNow
     47  169e		       4c c2 02 	      jmp	NextIL
     48  16a1
     49  16a1				   PopMathStackNow
     50  16a1		       98		      tya
     51  16a2		       48		      pha
     52  16a3
     53  16a3		       a4 4d		      ldy	GOSUBSTACKPTR
     54  16a5		       88		      dey
     55  16a6		       b1 4b		      lda	(GOSUBSTACK),y
     56  16a8		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  16aa		       d0 09		      bne	iPopMathStackNoFrame
     58  16ac		       88		      dey
     59  16ad		       88		      dey
     60  16ae		       88		      dey
     61  16af		       b1 4b		      lda	(GOSUBSTACK),y
     62  16b1		       85 4a		      sta	MATHSTACKPTR
     63  16b3		       84 4d		      sty	GOSUBSTACKPTR
     64  16b5
     65  16b5				   iPopMathStackNoFrame
     66  16b5
     67  16b5		       68		      pla
     68  16b6		       a8		      tay
     69  16b7		       60		      rts
     70  16b8
     71  16b8
     72  16b8							;==========================================================
     73  16b8							; Push the current math stack information onto the gosub stack
     74  16b8				   iSaveMathStack
     75  16b8		       98		      tya
     76  16b9		       48		      pha
     77  16ba		       a4 4d		      ldy	GOSUBSTACKPTR
     78  16bc		       a5 4a		      lda	MATHSTACKPTR
     79  16be		       91 4b		      sta	(GOSUBSTACK),y
     80  16c0		       a5 48		      lda	MATHSTACK
     81  16c2		       c8		      iny
     82  16c3
     83  16c3		       91 4b		      sta	(GOSUBSTACK),y
     84  16c5		       c8		      iny
     85  16c6
     86  16c6		       a5 49		      lda	MATHSTACK+1
     87  16c8		       91 4b		      sta	(GOSUBSTACK),y
     88  16ca		       c8		      iny
     89  16cb
     90  16cb		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  16cd		       91 4b		      sta	(GOSUBSTACK),y
     92  16cf		       c8		      iny
     93  16d0
     94  16d0		       84 4d		      sty	GOSUBSTACKPTR
     95  16d2		       68		      pla
     96  16d3		       a8		      tay
     97  16d4		       4c c2 02 	      jmp	NextIL
     98  16d7							;
     99  16d7							;==========================================================
    100  16d7							;Restore the math stack information from the gosub stack
    101  16d7				   iRestoreMathStack
    102  16d7		       98		      tya
    103  16d8		       48		      pha
    104  16d9
    105  16d9		       a5 4a		      lda	MATHSTACKPTR
    106  16db		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  16dd
    108  16dd		       a4 4d		      ldy	GOSUBSTACKPTR
    109  16df		       88		      dey
    110  16e0		       b1 4b		      lda	(GOSUBSTACK),y
    111  16e2		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  16e4		       d0 16		      bne	iPopMathStack_Err
    113  16e6		       88		      dey
    114  16e7		       b1 4b		      lda	(GOSUBSTACK),y
    115  16e9		       85 49		      sta	MATHSTACK+1
    116  16eb		       88		      dey
    117  16ec		       b1 4b		      lda	(GOSUBSTACK),y
    118  16ee		       85 48		      sta	MATHSTACK
    119  16f0		       88		      dey
    120  16f1		       b1 4b		      lda	(GOSUBSTACK),y
    121  16f3		       85 4a		      sta	MATHSTACKPTR
    122  16f5		       84 4d		      sty	GOSUBSTACKPTR
    123  16f7		       68		      pla
    124  16f8		       a8		      tay
    125  16f9		       4c c2 02 	      jmp	NextIL
    126  16fc
    127  16fc				   iPopMathStack_Err
    128  16fc		       a9 00		      lda	#0
    129  16fe		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  1700		       4c a4 06 	      jmp	iErr2
    131  1703							;=========================================
    132  1703							; For functions and tasks the variable address of # means
    133  1703							; a passed parameter so #[0] is the first parameter etc
    134  1703							; will try for a better way later
    135  1703
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  1703					      include	"tasks.asm"
      1  1703							;=====================================================
      2  1703							; Tiny Basic IL task management
      3  1703							; Data required by task management
      4  1703							; currently each context is about 30 bytes and is swapped
      5  1703							; into and out of page zero on each task switch....
      6  1703							; LOL yes it is slow, but works for this iteration.
      7  1703							;
      8  1703
      9  1703					      Seg	Code
     10  1703							;=====================================================
     11  1703							; Sets the pointers to the math,IL and gosub stacks
     12  1703							; Creates the initial Context for each task slot
     13  1703				   taskSetStacks
     14  1703		       a9 55		      lda	#mathStack&$FF
     15  1705		       85 48		      sta	MATHSTACK
     16  1707		       a9 27		      lda	#mathStack>>8
     17  1709		       85 49		      sta	MATHSTACK+1
     18  170b
     19  170b		       a9 e5		      lda	#ilStack&$ff
     20  170d		       85 45		      sta	ILSTACK
     21  170f		       a9 28		      lda	#ilStack>>8
     22  1711		       85 46		      sta	ILSTACK+1
     23  1713
     24  1713		       a9 75		      lda	#gosubStack&$FF
     25  1715		       85 4b		      sta	GOSUBSTACK
     26  1717		       a9 2a		      lda	#gosubStack>>8
     27  1719		       85 4c		      sta	GOSUBSTACK+1
     28  171b
     29  171b		       a9 f5		      lda	#variableStack&$FF
     30  171d		       85 41		      sta	VARIABLES
     31  171f		       a9 2c		      lda	#variableStack>>8
     32  1721		       85 42		      sta	VARIABLES+1
     33  1723		       a2 0a		      ldx	#TASKCOUNT
     34  1725		       a0 00		      ldy	#0
     35  1727		       20 c4 19 	      jsr	ContextSave
     36  172a
     37  172a		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  172c		       b0 3a		      bcs	taskSetDone
     39  172e
     40  172e		       a5 4b		      lda	GOSUBSTACK
     41  1730		       18		      clc
     42  1731		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  1733		       85 4b		      sta	GOSUBSTACK
     44  1735		       a5 4c		      lda	GOSUBSTACK+1
     45  1737		       69 00		      adc	#0
     46  1739		       85 4c		      sta	GOSUBSTACK+1
     47  173b
     48  173b		       a5 45		      lda	ILSTACK	; must be less than 256
     49  173d		       18		      clc
     50  173e		       69 28		      adc	#ILSTACKSIZE*2
     51  1740		       85 45		      sta	ILSTACK
     52  1742		       a5 46		      lda	ILSTACK+1
     53  1744		       69 00		      adc	#0
     54  1746		       85 46		      sta	ILSTACK+1
     55  1748
     56  1748		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  174a		       18		      clc
     58  174b		       69 28		      adc	#MATHSTACKSIZE*2
     59  174d		       85 48		      sta	MATHSTACK
     60  174f		       a5 49		      lda	MATHSTACK+1
     61  1751		       69 00		      adc	#0
     62  1753		       85 49		      sta	MATHSTACK+1
     63  1755
     64  1755		       a5 41		      lda	VARIABLES	; must be less than 256
     65  1757		       18		      clc
     66  1758		       69 36		      adc	#VARIABLESSIZE*2
     67  175a		       85 41		      sta	VARIABLES
     68  175c		       a5 42		      lda	VARIABLES+1
     69  175e		       69 00		      adc	#0
     70  1760		       85 42		      sta	VARIABLES+1
     71  1762
     72  1762		       20 c4 19 	      jsr	ContextSave
     73  1765		       4c 2a 17 	      jmp	taskSetLoop
     74  1768
     75  1768				   taskSetDone
     76  1768		       a0 00		      ldy	#0	; reload the main loop context
     77  176a		       20 d3 19 	      jsr	ContextLoad
     78  176d		       60		      rts
     79  176e							;
     80  176e							;=====================================================
     81  176e							; In some error cases the math stacks may be left pointing to the wrong stack
     82  176e							; This function will reset those stack addresses but not the actual pointer
     83  176e				   taskResetStacks
     84  176e		       a0 00		      ldy	#0
     85  1770		       20 d3 19 	      jsr	ContextLoad
     86  1773		       4c 03 17 	      jmp	taskSetStacks
     87  1776							;
     88  1776							;=====================================================
     89  1776							; Clear all task entries and task stacks
     90  1776		       98	   taskReset  tya		; Save Y
     91  1777		       48		      pha
     92  1778		       a9 01		      lda	#1
     93  177a		       8d 54 27 	      sta	taskCounter	; Set number of active tasks to 1
     94  177d		       ac 55 26 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  1780		       c0 00		      cpy	#0	; check if we are the main context
     96  1782		       f0 08		      beq	taskResetCont	; if we are just continue
     97  1784
     98  1784		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  1786		       8c 55 26 	      sty	taskPtr
    100  1789		       20 d3 19 	      jsr	ContextLoad	; load the System Task context
    101  178c				   taskResetCont
    102  178c		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  178e
    104  178e				   taskResetLoop
    105  178e		       a9 00		      lda	#TASKINACTIVE
    106  1790		       99 56 26 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  1793		       18		      clc
    108  1794		       98		      tya
    109  1795		       69 19		      adc	#CONTEXTLEN+1
    110  1797		       a8		      tay
    111  1798		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  179a		       90 f2		      bcc	taskResetLoop	; Go for more
    113  179c
    114  179c				   taskResetComplete
    115  179c
    116  179c		       68		      pla		; Restore y
    117  179d		       a8		      tay
    118  179e		       60		      rts
    119  179f
    120  179f							;
    121  179f							;======================================================
    122  179f							; iTaskSwitch	 switch to new task if not interrupt and
    123  179f							;		 count is exceded for task time slice gets here
    124  179f							;		 when time slice has reached zero
    125  179f							;
    126  179f		       98	   iTaskSwitch tya
    127  17a0		       48		      pha
    128  17a1
    129  17a1		       ad 52 27 	      lda	taskResetValue	; Always reset the counter value
    130  17a4		       8d 50 27 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  17a7		       ce 51 27 	      dec	taskCurrentCycles+1	; dec high order byte
    132  17aa		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  17ac
    134  17ac		       ad 53 27 	      lda	taskResetValue+1
    135  17af		       8d 51 27 	      sta	taskCurrentCycles+1
    136  17b2
    137  17b2		       ad 52 26 	      lda	IRQPending	; Skip this if we are processing an irq
    138  17b5		       0d ac 2f 	      ora	taskIOPending	; If set then don't switch
    139  17b8		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  17ba
    141  17ba		       ad 54 27    iTaskMain  lda	taskCounter	; Number of tasks
    142  17bd		       c9 01		      cmp	#1	; if there is only one task must be main
    143  17bf		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  17c1
    145  17c1		       ac 55 26 	      ldy	taskPtr	; check if we have not just ended some other task
    146  17c4		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  17c6		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  17c8							;
    149  17c8							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  17c8							;
    151  17c8				   itasknext
    152  17c8		       ac 55 26 	      ldy	taskPtr
    153  17cb		       20 c4 19 	      jsr	ContextSave	; Save the current context, y points to next context
    154  17ce				   itaskLoop
    155  17ce		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  17d0		       90 04		      bcc	iTaskNextChk
    157  17d2
    158  17d2		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  17d4		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  17d6
    161  17d6				   iTaskNextChk
    162  17d6		       b9 56 26 	      lda	taskTable,y	; there is always at least one entry in table
    163  17d9		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  17db		       18	   iTaskNext  clc
    165  17dc		       98		      tya
    166  17dd		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  17df		       a8		      tay
    168  17e0		       4c ce 17 	      jmp	itaskLoop	; Check for busy entry
    169  17e3
    170  17e3		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  17e5		       59 56 26 	      eor	taskTable,y	; Check for anything waiting io
    172  17e8		       d0 f1		      bne	iTaskNext
    173  17ea		       20 d3 19 	      jsr	ContextLoad	; load the next context
    174  17ed		       8c 55 26 	      sty	taskPtr	; update the task pointer
    175  17f0
    176  17f0				   iTaskSwitchDone
    177  17f0		       68		      pla
    178  17f1		       a8		      tay
    179  17f2		       60		      rts
    180  17f3							;
    181  17f3							;================================================================
    182  17f3							; Task Set task number to line number to start
    183  17f3							; on entry stack contains, type of line description and  memvector or linenumber
    184  17f3							; Task Table structure:
    185  17f3							;    byte 0	-   Active inactive
    186  17f3							;    byte 1-2	-   Basic code line pointer
    187  17f3							;    byte 3	-   Offset on current line
    188  17f3		       98	   iTaskSet   tya		;preserve Y
    189  17f4		       48		      pha		; push a
    190  17f5		       20 8a 1d 	      jsr	popR1	; Get if compiled or line number expression
    191  17f8		       20 72 1d 	      jsr	popR0	; Get the line number to be saved
    192  17fb
    193  17fb
    194  17fb
    195  17fb		       ac 55 26 	      ldy	taskPtr	; find out where we are
    196  17fe		       20 c4 19 	      jsr	ContextSave	; Save the current context
    197  1801
    198  1801							;Find the pointer to the line we need to start at
    199  1801		       a5 54		      lda	R1
    200  1803		       f0 0b		      beq	iTaskLineNum
    201  1805		       a5 52		      lda	R0
    202  1807		       85 4f		      sta	CURPTR
    203  1809		       a5 53		      lda	R0+1
    204  180b		       85 50		      sta	CURPTR+1
    205  180d		       4c 20 18 	      jmp	iTaskCont
    206  1810
    207  1810				   iTaskLineNum
    208  1810		       20 2c 1b 	      jsr	findLine	; Get the offset of the line to start task at
    209  1813		       f0 0b		      beq	iTaskCont
    210  1815
    211  1815		       ac 55 26 	      ldy	taskPtr	; Restore the original Context Error Exit
    212  1818		       20 d3 19 	      jsr	ContextLoad
    213  181b
    214  181b		       68		      pla		; pop a - exit
    215  181c		       a8		      tay
    216  181d		       4c 6e 0d 	      jmp	iSetIrqErr	; Bad line number provided
    217  1820
    218  1820				   iTaskCont
    219  1820		       20 96 19 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    220  1823		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    221  1825
    222  1825		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    223  1827		       99 56 26 	      sta	taskTable,y	; new task as active
    224  182a
    225  182a		       a5 4f		      lda	CURPTR
    226  182c		       48		      pha		; push a
    227  182d		       a5 50		      lda	CURPTR+1
    228  182f		       48		      pha		; push a
    229  1830
    230  1830		       20 d3 19 	      jsr	ContextLoad	; load the context of the new task
    231  1833
    232  1833		       68		      pla		; pop a
    233  1834		       85 50		      sta	CURPTR+1
    234  1836		       68		      pla		; pop a
    235  1837		       85 4f		      sta	CURPTR
    236  1839		       a9 03		      lda	#3	; Offset to first instruction
    237  183b		       85 51		      sta	CUROFF
    238  183d
    239  183d		       a9 00		      lda	#0
    240  183f		       85 47		      sta	ILSTACKPTR
    241  1841		       85 4a		      sta	MATHSTACKPTR
    242  1843		       85 4d		      sta	GOSUBSTACKPTR
    243  1845		       a9 40		      lda	#GOSUBSTACKSIZE*4
    244  1847		       85 4e		      sta	MESSAGEPTR
    245  1849
    246  1849		       20 56 09 	      jsr	subVINIT	; Clear the variables
    247  184c
    248  184c		       a9 26		      lda	#STMT&$FF
    249  184e		       85 43		      sta	ILPC
    250  1850		       a9 22		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    251  1852		       85 44		      sta	ILPC+1
    252  1854
    253  1854		       98		      tya		; Save the new context offset to return to user
    254  1855		       48		      pha		; push a
    255  1856
    256  1856		       20 c4 19    itaskSetSave jsr	ContextSave	; save the updated context
    257  1859		       ee 54 27 	      inc	taskCounter	; Update the number of Tasks running
    258  185c
    259  185c		       ac 55 26 	      ldy	taskPtr
    260  185f		       20 d3 19 	      jsr	ContextLoad	; restore the original context
    261  1862
    262  1862		       a9 00		      lda	#0	; Set the R0 upper to zero
    263  1864		       85 53		      sta	R0+1
    264  1866		       68		      pla		; Get the task pid we stored				 ; pop a
    265  1867		       85 52		      sta	R0	; Get the table entry value
    266  1869
    267  1869		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    268  186a		       a8		      tay
    269  186b
    270  186b		       4c 3d 07 	      jmp	pushR0nextIl	; Push R0 and continue
    271  186e				   iTaskNoEmpty
    272  186e		       ac 55 26 	      ldy	taskPtr
    273  1871		       20 d3 19 	      jsr	ContextLoad
    274  1874
    275  1874		       68		      pla		; pop a    -- exit
    276  1875		       a8		      tay
    277  1876
    278  1876		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    279  1878		       a9 00		      lda	#0
    280  187a		       4c a4 06 	      jmp	iErr2
    281  187d							;
    282  187d							;===============================================================
    283  187d							; Run the task whos PID is on the stack, preserve the stack
    284  187d							;
    285  187d				   iTaskEnable
    286  187d		       98		      tya
    287  187e		       48		      pha
    288  187f		       20 8a 1d 	      jsr	popR1
    289  1882		       20 58 1d 	      jsr	pushR1
    290  1885		       20 ca 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    291  1888		       a0 00		      ldy	#0
    292  188a		       b1 56		      lda	(MQ),y
    293  188c		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    294  188e		       09 80		      ora	#TASKACTIVE
    295  1890		       91 56		      sta	(MQ),y
    296  1892		       68		      pla
    297  1893		       a8		      tay
    298  1894		       4c c2 02 	      jmp	NextIL
    299  1897
    300  1897							;
    301  1897							;===============================================================
    302  1897							; Suspend the task whos PID  is on the stack, preserve the stack
    303  1897							;
    304  1897				   iTaskSuspend
    305  1897		       98		      tya
    306  1898		       48		      pha
    307  1899		       20 8a 1d 	      jsr	popR1
    308  189c		       20 58 1d 	      jsr	pushR1
    309  189f		       20 ca 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    310  18a2		       a0 00		      ldy	#0
    311  18a4		       b1 56		      lda	(MQ),y
    312  18a6		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    313  18a8		       09 80		      ora	#TASKACTIVE
    314  18aa		       68		      pla
    315  18ab		       a8		      tay
    316  18ac		       4c c2 02 	      jmp	NextIL
    317  18af
    318  18af							;================================================================
    319  18af							; Returns task Status
    320  18af				   iTaskStat
    321  18af		       98		      tya
    322  18b0		       48		      pha
    323  18b1		       20 c3 18 	      jsr	iTaskValid	; returns pointer to task entry
    324  18b4		       b9 56 26 	      lda	taskTable,y
    325  18b7		       f0 05		      beq	iTaskStatExit
    326  18b9		       68		      pla
    327  18ba		       a8		      tay
    328  18bb		       4c 28 0d 	      jmp	iTruth
    329  18be				   iTaskStatExit
    330  18be		       68		      pla
    331  18bf		       a8		      tay
    332  18c0		       4c 31 0d 	      jmp	iFalse
    333  18c3
    334  18c3							;
    335  18c3							;================================================================
    336  18c3							; Validate the task number on top of the stack
    337  18c3							; on exit y points to the requested task entry
    338  18c3							;
    339  18c3		       20 72 1d    iTaskValid jsr	popR0	; get result of the multiply
    340  18c6		       a5 53		      lda	R0+1
    341  18c8		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    342  18ca		       a5 52		      lda	R0
    343  18cc		       c9 fa		      cmp	#TASKTABLELEN
    344  18ce		       90 09		      bcc	iTaskIsValid
    345  18d0
    346  18d0		       68	   iTaskValidErr pla		;remove return address
    347  18d1		       68		      pla
    348  18d2		       a2 10		      ldx	#ERR_INVALID_PID
    349  18d4		       a9 00		      lda	#0
    350  18d6		       4c a4 06 	      jmp	iErr2
    351  18d9
    352  18d9		       a8	   iTaskIsValid tay
    353  18da		       60		      rts
    354  18db							;
    355  18db							;================================================================
    356  18db							; Kill a running task, do nothing if already stopped
    357  18db		       20 c3 18    iTaskKill  jsr	iTaskValid
    358  18de		       a9 00		      lda	#0
    359  18e0		       99 56 26 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    360  18e3							;
    361  18e3							;================================================================
    362  18e3							;Skip to next task
    363  18e3				   iNTask
    364  18e3		       a9 01		      lda	#1
    365  18e5		       8d 50 27 	      sta	taskCurrentCycles
    366  18e8		       8d 51 27 	      sta	taskCurrentCycles+1
    367  18eb		       4c c2 02 	      jmp	NextIL
    368  18ee							;
    369  18ee							;=======================================================
    370  18ee							; Wait for a task to complete
    371  18ee				   iWTASK
    372  18ee		       20 e7 1a 	      jsr	getILByte
    373  18f1		       8d aa 2f 	      sta	offset
    374  18f4							;
    375  18f4		       20 ca 1c 	      jsr	saveIL	;in case of failure
    376  18f7
    377  18f7		       20 c3 18 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    378  18fa		       b9 56 26 	      lda	taskTable,y
    379  18fd		       d0 03		      bne	iWTASKWAIT
    380  18ff				   iWTASKEXITED
    381  18ff		       4c c2 02 	      jmp	NextIL
    382  1902				   iWTASKWAIT
    383  1902		       20 e0 1c 	      jsr	pushR0	; Push R0 back onto the stack
    384  1905		       a9 01		      lda	#1
    385  1907		       8d 50 27 	      sta	taskCurrentCycles	; Give up the cycles
    386  190a		       8d 51 27 	      sta	taskCurrentCycles+1
    387  190d		       20 d5 1c 	      jsr	restoreIL
    388  1910		       4c 8a 0b 	      jmp	tstBranch
    389  1913							;
    390  1913							;=======================================================
    391  1913							; Set task io lock
    392  1913		       ee ac 2f    iStartIO   inc	taskIOPending
    393  1916		       4c c2 02 	      jmp	NextIL
    394  1919							;
    395  1919							;=======================================================
    396  1919							; Release the io lock
    397  1919		       ad ac 2f    iEndIO     lda	taskIOPending
    398  191c		       f0 03		      beq	iEndIOExit
    399  191e		       ce ac 2f 	      dec	taskIOPending
    400  1921		       4c c2 02    iEndIOExit jmp	NextIL
    401  1924							;
    402  1924							;===============================================================
    403  1924							; Return the task PID
    404  1924				   iTASKPID
    405  1924		       a9 00		      lda	#0
    406  1926		       85 53		      sta	R0+1
    407  1928		       ad 55 26 	      lda	taskPtr
    408  192b		       85 52		      sta	R0
    409  192d		       4c 3d 07 	      jmp	pushR0nextIl
    410  1930							;
    411  1930							;================================================================
    412  1930							; Terminate a task
    413  1930		       ac 55 26    iETask     ldy	taskPtr
    414  1933		       c0 00		      cpy	#0
    415  1935		       d0 03		      bne	iETaskCont
    416  1937		       4c 31 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    417  193a				   iETaskCont
    418  193a		       a9 00		      lda	#TASKINACTIVE
    419  193c		       99 56 26 	      sta	taskTable,y	; mark entry as free
    420  193f		       ce 54 27 	      dec	taskCounter	; reduce the number of active tasks
    421  1942		       a9 01		      lda	#1
    422  1944		       8d 50 27 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    423  1947		       8d 51 27 	      sta	taskCurrentCycles+1
    424  194a		       20 b1 19 	      jsr	TaskSetExitCode
    425  194d				   iETaskExit
    426  194d		       4c c2 02 	      jmp	NextIL
    427  1950							;================================================================
    428  1950							; make the current tasks math stack equal another tasks stack
    429  1950							; The task to get is stored on the math stack
    430  1950
    431  1950				   iTaskGetMathStack
    432  1950		       20 98 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    433  1953		       20 ca 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    434  1956		       a0 0a		      ldy	#MATHSTACKPTRPOS
    435  1958		       b1 56		      lda	(MQ),y
    436  195a		       85 4a		      sta	MATHSTACKPTR
    437  195c		       a0 08		      ldy	#MATHSTACKPOS
    438  195e		       b1 56		      lda	(MQ),y
    439  1960		       85 48		      sta	MATHSTACK
    440  1962		       c8		      iny
    441  1963		       b1 56		      lda	(MQ),y
    442  1965		       85 49		      sta	MATHSTACK+1
    443  1967		       4c c2 02 	      jmp	NextIL
    444  196a							;==================================================================
    445  196a							; Updates the tasks math stack pointer with contents of R2
    446  196a							; PID is on top of the stack
    447  196a				   iTaskPutMathPtr
    448  196a		       20 98 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    449  196d		       20 ca 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    450  1970		       a5 58		      lda	R2
    451  1972		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  1974		       91 56		      sta	(MQ),y
    453  1976		       4c c2 02 	      jmp	NextIL
    454  1979							;
    455  1979							;================================================================
    456  1979							; Set the time slice for each task
    457  1979				   iSLICE
    458  1979		       20 72 1d 	      jsr	popR0
    459  197c		       a5 52		      lda	R0
    460  197e		       8d 52 27 	      sta	taskResetValue
    461  1981		       a5 53		      lda	R0+1
    462  1983		       8d 53 27 	      sta	taskResetValue+1
    463  1986		       d0 0b		      bne	iSliceSet
    464  1988		       ee 53 27 	      inc	taskResetValue+1	; must be at least 1 high counter
    465  198b		       a9 01		      lda	#1
    466  198d		       8d 50 27 	      sta	taskCurrentCycles
    467  1990		       8d 51 27 	      sta	taskCurrentCycles+1
    468  1993				   iSliceSet
    469  1993		       4c c2 02 	      jmp	NextIL
    470  1996							;================================================================
    471  1996							; Find an empty slot in the taskTable
    472  1996							; Return the index in y
    473  1996							; on exit   c set if an empty slot is found
    474  1996							;	     c clear if not found
    475  1996							;================================================================
    476  1996							;
    477  1996		       ad 54 27    TaskEmpty  lda	taskCounter
    478  1999		       c9 0a		      cmp	#TASKCOUNT
    479  199b		       b0 10		      bcs	TaskNoSlot
    480  199d		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    481  199f				   TaskLoop
    482  199f		       b9 56 26 	      lda	taskTable,y
    483  19a2		       f0 0b		      beq	TaskEmptyFnd
    484  19a4		       98		      tya
    485  19a5		       18		      clc
    486  19a6		       69 19		      adc	#CONTEXTLEN+1
    487  19a8		       a8		      tay
    488  19a9		       c0 fa		      cpy	#TASKTABLELEN
    489  19ab		       90 f2		      bcc	TaskLoop	; Y is never zero
    490  19ad				   TaskNoSlot
    491  19ad		       18		      clc
    492  19ae		       60		      rts
    493  19af				   TaskEmptyFnd
    494  19af		       38		      sec
    495  19b0		       60		      rts
    496  19b1							;====================================================
    497  19b1							; Set the task exit code called from the return command
    498  19b1							; on entry stack top hold exit value
    499  19b1				   TaskSetExitCode
    500  19b1		       98		      tya
    501  19b2		       48		      pha
    502  19b3		       20 72 1d 	      jsr	popR0
    503  19b6		       a0 34		      ldy	#TASKEXITCODE
    504  19b8		       a5 52		      lda	R0
    505  19ba		       91 41		      sta	(VARIABLES),y
    506  19bc		       c8		      iny
    507  19bd		       a5 53		      lda	R0+1
    508  19bf		       91 41		      sta	(VARIABLES),y
    509  19c1		       68		      pla
    510  19c2		       98		      tya
    511  19c3		       60		      rts
    512  19c4
    513  19c4							;
    514  19c4							;=====================================================
    515  19c4							; Save Context Store the context to the TASK Table
    516  19c4							; on entry y contains the task table entry to save to
    517  19c4							; on exit y points to next task table entry
    518  19c4							;	   x contains the number of bytes copied
    519  19c4		       a2 00	   ContextSave ldx	#0
    520  19c6		       c8		      iny		;inc past the task flags
    521  19c7		       b5 41	   ContextSvLoop lda	CONTEXT,x
    522  19c9		       99 56 26 	      sta	taskTable,y
    523  19cc		       c8		      iny
    524  19cd		       e8		      inx
    525  19ce		       e0 18		      cpx	#CONTEXTLEN
    526  19d0		       90 f5		      bcc	ContextSvLoop
    527  19d2		       60		      rts
    528  19d3							;
    529  19d3							; Load Context transfer context from task table to the Current Context
    530  19d3							; on entry y contains the task table entry to transfer
    531  19d3							; on exit y points to the original task table entry
    532  19d3							;	   x contains the number of byts copied
    533  19d3		       98	   ContextLoad tya
    534  19d4		       48		      pha
    535  19d5		       a2 00		      ldx	#0
    536  19d7		       c8		      iny		;inc past the task flags
    537  19d8		       b9 56 26    ContextLDLoop lda	taskTable,y
    538  19db		       95 41		      sta	CONTEXT,x
    539  19dd		       c8		      iny
    540  19de		       e8		      inx
    541  19df		       e0 18		      cpx	#CONTEXTLEN
    542  19e1		       90 f5		      bcc	ContextLDLoop
    543  19e3		       68		      pla
    544  19e4		       a8		      tay
    545  19e5		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  19e6					      include	"ipc.asm"
      1  19e6							;======================================================
      2  19e6							; Inter process communications.
      3  19e6							; Tasks may write/read integer messages among
      4  19e6							; them selves.
      5  19e6							; This uses each tasks gosub stack as a message queue
      6  19e6							; Gosub calls start at the highest address and the
      7  19e6							; msg queue starts at the highest address.
      8  19e6							;
      9  19e6							;======================================================
     10  19e6							; ipcs   - Send msg to another task or many tasks
     11  19e6							; on entry  math stack contains the  top PID
     12  19e6							;				      2ND Message value
     13  19e6							; on exit   math stack contain top True-good or False-failed
     14  19e6							;
     15  19e6							; it may not be sent if queue is full
     16  19e6							;
     17  19e6							; a = ipcs(<message-expression>,<task PID-expression>)
     18  19e6							;
     19  19e6				   iIPCS
     20  19e6		       98		      tya
     21  19e7		       48		      pha
     22  19e8		       20 4f 1a 	      jsr	ipc_enqueue
     23  19eb		       b0 08		      bcs	iIPC_BAD
     24  19ed		       20 8a 1f 	      jsr	pushTrue
     25  19f0		       68		      pla
     26  19f1		       a8		      tay
     27  19f2		       4c c2 02 	      jmp	NextIL
     28  19f5				   iIPC_BAD
     29  19f5		       68		      pla
     30  19f6		       a8		      tay
     31  19f7		       20 94 1f 	      jsr	pushFalse
     32  19fa		       4c c2 02 	      jmp	NextIL
     33  19fd
     34  19fd							;======================================================
     35  19fd							; ipcr   - Recieve msg from task
     36  19fd							; on exit  the message value is returned from message queue
     37  19fd							;	    message -1	is reserved meaning no entry found
     38  19fd							; The provided variable contains the pid of the sending
     39  19fd							; task. This is optional. This always waits for a message
     40  19fd							; before returning.
     41  19fd							;
     42  19fd							; a = ipcr(<variable name>)
     43  19fd							;
     44  19fd				   iIPCR
     45  19fd		       98		      tya
     46  19fe		       48		      pha
     47  19ff		       20 91 1a 	      jsr	ipc_dequeue
     48  1a02		       b0 05		      bcs	iIPCR_Q_Empty
     49  1a04		       68		      pla
     50  1a05		       a8		      tay
     51  1a06		       4c c2 02 	      jmp	NextIL
     52  1a09				   iIPCR_Q_Empty
     53  1a09		       68		      pla
     54  1a0a		       a8		      tay
     55  1a0b		       20 8a 1f 	      jsr	pushTrue	; puts -1 on the stack
     56  1a0e		       4c c2 02 	      jmp	NextIL
     57  1a11
     58  1a11							;=======================================================
     59  1a11							; ipcc   - Check if message available
     60  1a11							; on exit  Stack contains number of messages
     61  1a11							;
     62  1a11							; a = ipcc()
     63  1a11							;
     64  1a11				   iIPCC
     65  1a11		       98		      tya
     66  1a12		       48		      pha
     67  1a13		       20 3c 1a 	      jsr	ipc_queue_count
     68  1a16		       20 e0 1c 	      jsr	pushR0	; return the count
     69  1a19		       68		      pla
     70  1a1a		       a8		      tay
     71  1a1b		       4c c2 02 	      jmp	NextIL
     72  1a1e
     73  1a1e							;=======================================================
     74  1a1e							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  1a1e				   iIPCIO
     76  1a1e		       98		      tya
     77  1a1f		       48		      pha
     78  1a20		       20 3c 1a 	      jsr	ipc_queue_count
     79  1a23		       a5 52		      lda	R0
     80  1a25		       d0 10		      bne	iIPCIO_No_Halt
     81  1a27		       a9 01		      lda	#1
     82  1a29		       8d 50 27 	      sta	taskCurrentCycles	; force a task switch
     83  1a2c		       a9 01		      lda	#TASKWAITIPC
     84  1a2e		       ac 55 26 	      ldy	taskPtr
     85  1a31		       19 56 26 	      ora	taskTable,y
     86  1a34		       99 56 26 	      sta	taskTable,y
     87  1a37
     88  1a37				   iIPCIO_No_Halt
     89  1a37		       68		      pla
     90  1a38		       a8		      tay
     91  1a39		       4c c2 02 	      jmp	NextIL
     92  1a3c							;======================================================
     93  1a3c							;ipc_queue_count
     94  1a3c				   ipc_queue_count
     95  1a3c		       a5 4e		      lda	MESSAGEPTR
     96  1a3e		       18		      clc
     97  1a3f		       4a		      lsr		; divide by 4
     98  1a40		       4a		      lsr
     99  1a41		       85 52		      sta	R0	; store into R0
    100  1a43		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1a45		       38		      sec
    102  1a46		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1a48		       85 52		      sta	R0
    104  1a4a		       a9 00		      lda	#0
    105  1a4c		       85 53		      sta	R0+1
    106  1a4e		       60		      rts
    107  1a4f							;=======================================================
    108  1a4f							; Support functions for messaging
    109  1a4f							;
    110  1a4f							; Enqueue message -> onto PID's MSG Q
    111  1a4f							; on entry top of stack contains the PID
    112  1a4f							;	    second contains the Message of the task
    113  1a4f							; on exit contains c set if failed
    114  1a4f							;		    c cleared if success
    115  1a4f							;		    PID's MSG Q PTR points to the message
    116  1a4f							;
    117  1a4f				   ipc_enqueue
    118  1a4f		       20 8a 1d 	      jsr	popR1	; Get the pid
    119  1a52		       20 ca 1a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1a55
    121  1a55		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1a57		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1a59		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1a5b		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1a5d		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1a5f
    127  1a5f
    128  1a5f							; Get the PID'S stack address into R0
    129  1a5f		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1a61		       b1 56		      lda	(MQ),y
    131  1a63		       85 52		      sta	R0
    132  1a65		       c8		      iny
    133  1a66		       b1 56		      lda	(MQ),y
    134  1a68		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1a6a
    136  1a6a							; Set y to point to the msg q entry
    137  1a6a		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1a6c		       b1 56		      lda	(MQ),y	; Get the index
    139  1a6e		       a8		      tay		; Set y to queue offset
    140  1a6f
    141  1a6f							; enqueue the message
    142  1a6f		       88		      dey		; First byte to save to
    143  1a70		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1a72		       91 52		      sta	(R0),y	; Set the entry type
    145  1a74
    146  1a74		       88		      dey
    147  1a75		       ad 55 26 	      lda	taskPtr	; Store the PID into queue
    148  1a78		       91 52		      sta	(R0),y
    149  1a7a		       20 8a 1d 	      jsr	popR1	; Get the actual message value
    150  1a7d		       20 d8 1a 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1a80
    152  1a80		       98		      tya		; Save the new q ptr
    153  1a81		       a0 0e		      ldy	#MSGPTRPOS
    154  1a83		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1a85		       a0 00		      ldy	#0	; points to context root
    156  1a87		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1a89		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1a8b		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1a8d		       18		      clc
    160  1a8e		       60		      rts
    161  1a8f				   ipc_enq_full
    162  1a8f		       38		      sec
    163  1a90		       60		      rts
    164  1a91							;=============================================================
    165  1a91							; De-queue for message stack -> local tasks msg q
    166  1a91							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1a91							;  message into
    168  1a91							;  on exit   math stack contains value of message
    169  1a91							;				  Variable if provided is pid
    170  1a91				   ipc_dequeue
    171  1a91		       20 a1 1d 	      jsr	popMQ	; Variable address to put PID into
    172  1a94
    173  1a94		       a4 4e		      ldy	MESSAGEPTR
    174  1a96		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1a98		       b0 2e		      bcs	ipc_deq_empty
    176  1a9a		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1a9c		       85 52		      sta	R0
    178  1a9e		       c8		      iny
    179  1a9f		       b1 4b		      lda	(GOSUBSTACK),y
    180  1aa1		       85 53		      sta	R0+1
    181  1aa3		       c8		      iny
    182  1aa4		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1aa6		       85 54		      sta	R1
    184  1aa8		       c8		      iny
    185  1aa9		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1aab		       c8		      iny
    187  1aac		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1aae
    189  1aae		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1ab0		       d0 16		      bne	ipc_deq_empty
    191  1ab2
    192  1ab2		       20 e0 1c 	      jsr	pushR0	; place value on stack
    193  1ab5
    194  1ab5		       a5 56		      lda	MQ
    195  1ab7		       05 57		      ora	MQ+1
    196  1ab9		       f0 0b		      beq	ipc_deq_done
    197  1abb		       a5 54		      lda	R1
    198  1abd		       a0 00		      ldy	#0
    199  1abf		       91 56		      sta	(MQ),y
    200  1ac1		       c8		      iny
    201  1ac2		       a9 00		      lda	#0
    202  1ac4		       91 56		      sta	(MQ),y
    203  1ac6				   ipc_deq_done
    204  1ac6		       18		      clc
    205  1ac7		       60		      rts
    206  1ac8
    207  1ac8				   ipc_deq_empty
    208  1ac8		       38		      sec
    209  1ac9		       60		      rts
    210  1aca
    211  1aca							;=============================================
    212  1aca							;  Get the context address into MQ from R1 with
    213  1aca							;  context/index/pid
    214  1aca				   ipc_getcontext
    215  1aca		       18		      clc		; Get pointer to Task context
    216  1acb		       a9 56		      lda	#taskTable&$FF	; change ptr to address
    217  1acd		       65 54		      adc	R1
    218  1acf		       85 56		      sta	MQ
    219  1ad1		       a9 26		      lda	#taskTable>>8
    220  1ad3		       65 55		      adc	R1+1
    221  1ad5		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1ad7		       60		      rts
    223  1ad8							;
    224  1ad8							;==============================================
    225  1ad8							;Push R1 onto the stack
    226  1ad8							;on entry y = next entry
    227  1ad8							;R0 points to the stack space
    228  1ad8							;on exit y points to next free byte
    229  1ad8				   ipc_pushR1
    230  1ad8		       88		      dey
    231  1ad9		       a5 55		      lda	R1+1	; PID first
    232  1adb		       91 52		      sta	(R0),y
    233  1add		       88		      dey
    234  1ade		       a5 54		      lda	R1
    235  1ae0		       91 52		      sta	(R0),y
    236  1ae2		       60		      rts
    237  1ae3
    238  1ae3
    239  1ae3
    240  1ae3
    241  1ae3
    242  1ae3
    243  1ae3
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1ae3					      include	"support.asm"
      1  1ae3							;
      2  1ae3							;=====================================================
      3  1ae3							;=====================================================
      4  1ae3							;=====================================================
      5  1ae3							; This marks the start of support functions used by
      6  1ae3							; the IL opcodes.  These are support functions, NOT
      7  1ae3							; the IL code.
      8  1ae3							;=====================================================
      9  1ae3							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1ae3							;=====================================================
     11  1ae3					      Seg	Code
     12  1ae3							;=====================================================
     13  1ae3							; This gets the next two bytes pointed to by ILPC and
     14  1ae3							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1ae3							; is advanced by two, and Y contains 0 on return.
     16  1ae3
     17  1ae3							;
     18  1ae3		       20 e7 1a    getILWord  jsr	getILByte	;LSB
     19  1ae6		       aa		      tax
     20  1ae7							;
     21  1ae7							;=====================================================
     22  1ae7							; This gets the next byte pointed to by ILPC and
     23  1ae7							; returns it in A.  On return, X is unchanged but Y
     24  1ae7							; contains 0.
     25  1ae7							;
     26  1ae7		       a0 00	   getILByte  ldy	#0
     27  1ae9		       b1 43		      lda	(ILPC),y	;get byte
     28  1aeb		       08		      php		;save status
     29  1aec		       e6 43		      inc	ILPC	;inc LSB
     30  1aee		       d0 02		      bne	getILb2	;branch if no overflow
     31  1af0		       e6 44		      inc	ILPC+1	;inc MSB
     32  1af2		       28	   getILb2    plp		;restore status
     33  1af3		       60		      rts
     34  1af4							;
     35  1af4							;=====================================================
     36  1af4							; Decrement ILPC by one.
     37  1af4							;
     38  1af4		       a5 43	   decIL      lda	ILPC
     39  1af6		       d0 02		      bne	decIL2
     40  1af8		       c6 44		      dec	ILPC+1
     41  1afa		       c6 43	   decIL2     dec	ILPC
     42  1afc		       60		      rts
     43  1afd							;
     44  1afd							;=====================================================
     45  1afd							; Push the ILPC onto the return stack.  Actually, this
     46  1afd							; pushes the address of ILPC+2 since that's the next
     47  1afd							; address to execute.
     48  1afd							;
     49  1afd		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  1aff		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  1b01		       b0 15		      bcs	pushErr
     52  1b03		       a5 43		      lda	ILPC
     53  1b05		       18		      clc
     54  1b06		       69 02		      adc	#2
     55  1b08		       91 45		      sta	(ILSTACK),y
     56  1b0a		       08		      php		;save C bit
     57  1b0b		       c8		      iny
     58  1b0c		       a5 44		      lda	ILPC+1
     59  1b0e		       28		      plp		;restore C
     60  1b0f		       69 00		      adc	#0
     61  1b11		       91 45		      sta	(ILSTACK),y
     62  1b13		       c8		      iny
     63  1b14		       84 47		      sty	ILSTACKPTR
     64  1b16		       18		      clc
     65  1b17		       60		      rts
     66  1b18				   pushErr
     67  1b18		       38		      sec
     68  1b19		       60		      rts
     69  1b1a							;
     70  1b1a							;=====================================================
     71  1b1a							; Pull the top entry from return stack and put into
     72  1b1a							; ILPC.
     73  1b1a							;
     74  1b1a		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1b1c		       f0 fa		      beq	pushErr
     76  1b1e		       88		      dey
     77  1b1f		       b1 45		      lda	(ILSTACK),y
     78  1b21		       85 44		      sta	ILPC+1
     79  1b23		       88		      dey
     80  1b24		       b1 45		      lda	(ILSTACK),y
     81  1b26		       85 43		      sta	ILPC
     82  1b28		       84 47		      sty	ILSTACKPTR
     83  1b2a		       18		      clc
     84  1b2b		       60		      rts
     85  1b2c							;
     86  1b2c							;=====================================================
     87  1b2c							; This searches for a specific line number that is in
     88  1b2c							; R0.	There are three possible return conditions:
     89  1b2c							; Line numbers are now the third byte, the first byte is now
     90  1b2c							; a pointer to the next line, of course no longer than 255 byte
     91  1b2c							; per line.
     92  1b2c							;
     93  1b2c							; Exact match was found:
     94  1b2c							;    * Z set
     95  1b2c							;    * CURPTR points to two-byte line number for that
     96  1b2c							;	line.
     97  1b2c							;
     98  1b2c							; Next highest line found:
     99  1b2c							;    * Z cleared
    100  1b2c							;    * C set
    101  1b2c							;    * CURPTR points to two-byte line number for that
    102  1b2c							;	line.
    103  1b2c							;
    104  1b2c							; End of program reached:
    105  1b2c							;    * Z cleared
    106  1b2c							;    * C cleared
    107  1b2c							;    * CURPTR points to first free byte at end of
    108  1b2c							;	program.  Ie, it has save value as PROGRAMEND.
    109  1b2c							;
    110  1b2c							; A, X, and Y are all undefined on return.
    111  1b2c							;
    112  1b2c
    113  1b2c				   findLine
    114  1b2c		       ad ae 2f 	      lda	ProgramStart	;Start of program -> CURPTR
    115  1b2f		       85 4f		      sta	CURPTR
    116  1b31		       ad af 2f 	      lda	ProgramStart+1
    117  1b34		       85 50		      sta	CURPTR+1
    118  1b36							;
    119  1b36							; At end of code?
    120  1b36							;
    121  1b36				   iXFER1
    122  1b36		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1b38		       cd b0 2f 	      cmp	ProgramEnd	; at end of program then stop run
    124  1b3b		       d0 0b		      bne	xfer2	; not end
    125  1b3d		       a5 50		      lda	CURPTR+1
    126  1b3f		       cd b1 2f 	      cmp	ProgramEnd+1
    127  1b42		       d0 04		      bne	xfer2	;Not at end
    128  1b44							;
    129  1b44							; Line not found and the end of the program was
    130  1b44							; reached.  Return Z and C both clear.
    131  1b44							;
    132  1b44		       a9 01		      lda	#1	;clear Z
    133  1b46		       18		      clc		;clear C
    134  1b47		       60		      rts
    135  1b48							;
    136  1b48							; Check for an exact line number match
    137  1b48							;
    138  1b48		       a5 52	   xfer2      lda	R0
    139  1b4a		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1b4c		       d1 4f		      cmp	(CURPTR),y
    141  1b4e		       d0 08		      bne	xfernotit
    142  1b50		       c8		      iny
    143  1b51		       a5 53		      lda	R0+1
    144  1b53		       d1 4f		      cmp	(CURPTR),y
    145  1b55		       d0 01		      bne	xfernotit	; not a matching line number
    146  1b57							;
    147  1b57							; This is exactly the line we want.
    148  1b57							;
    149  1b57		       60		      rts		;it matches exactly
    150  1b58							;
    151  1b58							; See if this line is greater than the one we're
    152  1b58							; searching for.
    153  1b58							;
    154  1b58		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1b5a		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1b5c		       c5 53		      cmp	R0+1
    157  1b5e		       90 0b		      bcc	xfer3
    158  1b60		       d0 07		      bne	xfer4
    159  1b62		       88		      dey
    160  1b63		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1b65		       c5 52		      cmp	R0
    162  1b67		       90 02		      bcc	xfer3
    163  1b69							;
    164  1b69							; This line is greater than the one we want, so
    165  1b69							; return Z clear and C set.
    166  1b69							;
    167  1b69		       38	   xfer4      sec		;We found a line number greater
    168  1b6a		       60		      rts		;both conditions set
    169  1b6b							;
    170  1b6b							; Not the line (or droid) we're looking for.  Move to
    171  1b6b							; the next line.
    172  1b6b							;
    173  1b6b		       20 71 1b    xfer3      jsr	FindNextLine
    174  1b6e		       4c 36 1b 	      jmp	iXFER1
    175  1b71							;
    176  1b71							;=====================================================
    177  1b71							; This advances CURPTR to the next line.  If there
    178  1b71							; are no more lines, this leaves CURPTR equal to
    179  1b71							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1b71							; CURPTR is pointing to a valid line on entry.  This
    181  1b71							; pointer points to the two-byte line number.
    182  1b71							; Update this points to the 1 byte line length  ****************
    183  1b71							;
    184  1b71				   FindNextLine
    185  1b71		       a0 03		      ldy	#3	;skip line number and length byte
    186  1b73		       84 51		      sty	CUROFF	;this is the new offset
    187  1b75		       a0 00		      ldy	#0
    188  1b77		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1b79		       18		      clc
    190  1b7a		       65 4f		      adc	CURPTR
    191  1b7c		       85 4f		      sta	CURPTR
    192  1b7e		       a5 50		      lda	CURPTR+1
    193  1b80		       69 00		      adc	#0
    194  1b82		       85 50		      sta	CURPTR+1
    195  1b84		       60	   FindNext4  rts
    196  1b85							;
    197  1b85							;=====================================================
    198  1b85							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1b85							; if they are equal, Z clear if not.
    200  1b85							;
    201  1b85		       a5 4f	   AtEnd      lda	CURPTR
    202  1b87		       cd b0 2f 	      cmp	ProgramEnd
    203  1b8a		       d0 05		      bne	atendexit
    204  1b8c		       a5 50		      lda	CURPTR+1
    205  1b8e		       cd b1 2f 	      cmp	ProgramEnd+1
    206  1b91		       60	   atendexit  rts
    207  1b92							;
    208  1b92
    209  1b92							;
    210  1b92							;=====================================================
    211  1b92							; Convert an ASCII string to a number.  On input,
    212  1b92							; (CURPTR),Y points to the first digit.  This gets
    213  1b92							; digit-by-digit until finding a non-number.  Returns
    214  1b92							; Y pointing to the non-digit, and R0 contains the
    215  1b92							; number.  This does NOT check for valid ranges, so
    216  1b92							; a value like "123456789" will produce something,
    217  1b92							; but not what you had expected.
    218  1b92							;
    219  1b92		       a9 00	   getDecimal lda	#0
    220  1b94		       85 52		      sta	R0
    221  1b96		       85 53		      sta	R0+1
    222  1b98		       85 59		      sta	dpl	;temporary negative flag
    223  1b9a							;
    224  1b9a							; See if it's negative...
    225  1b9a							;
    226  1b9a							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1b9a		       b1 4f		      lda	(CURPTR),y
    228  1b9c		       c9 2d		      cmp	#'-
    229  1b9e		       d0 02		      bne	getDecLoop
    230  1ba0		       e6 59		      inc	dpl	;it's negative
    231  1ba2							;
    232  1ba2		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1ba4		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1ba6		       c9 30		      cmp	#'0
    235  1ba8		       90 36		      bcc	getDdone
    236  1baa		       c9 3a		      cmp	#'9+1
    237  1bac		       b0 32		      bcs	getDdone
    238  1bae		       38		      sec
    239  1baf		       e9 30		      sbc	#'0	;convert to binary
    240  1bb1		       48		      pha
    241  1bb2							;
    242  1bb2							; Now multiply R0 by 10.  Remember that
    243  1bb2							; 2*N + 8*N = 10*N.
    244  1bb2							;
    245  1bb2		       06 52		      asl	R0
    246  1bb4		       26 53		      rol	R0+1	;*2
    247  1bb6		       a5 52		      lda	R0
    248  1bb8		       85 54		      sta	R1
    249  1bba		       a5 53		      lda	R0+1
    250  1bbc		       85 55		      sta	R1+1
    251  1bbe		       06 52		      asl	R0
    252  1bc0		       26 53		      rol	R0+1	;*4
    253  1bc2		       06 52		      asl	R0
    254  1bc4		       26 53		      rol	R0+1	;*8
    255  1bc6		       18		      clc		;now add the partial sums...
    256  1bc7		       a5 52		      lda	R0	;...to get *10
    257  1bc9		       65 54		      adc	R1
    258  1bcb		       85 52		      sta	R0
    259  1bcd		       a5 53		      lda	R0+1
    260  1bcf		       65 55		      adc	R1+1
    261  1bd1		       85 53		      sta	R0+1
    262  1bd3							;
    263  1bd3							; Add in the new digit
    264  1bd3							;
    265  1bd3		       68		      pla
    266  1bd4		       18		      clc
    267  1bd5		       65 52		      adc	R0
    268  1bd7		       85 52		      sta	R0
    269  1bd9		       90 02		      bcc	getD2
    270  1bdb		       e6 53		      inc	R0+1
    271  1bdd							;
    272  1bdd							; Move to next character
    273  1bdd							;
    274  1bdd		       c8	   getD2      iny
    275  1bde		       d0 c2		      bne	getDecLoop
    276  1be0							;
    277  1be0							; All done with digits, so now deal with it being
    278  1be0							; negative.  If zero, then don't check for negative
    279  1be0							; flag.  Ie, -0 is stored as 0.
    280  1be0							;
    281  1be0		       a5 52	   getDdone   lda	R0
    282  1be2		       05 53		      ora	R0+1
    283  1be4		       f0 16		      beq	getDone2	;zero
    284  1be6		       a5 59		      lda	dpl
    285  1be8		       f0 12		      beq	getDone2	;positive
    286  1bea							;
    287  1bea							; Invert all the bits, then add one.
    288  1bea							;
    289  1bea		       a5 52		      lda	R0
    290  1bec		       49 ff		      eor	#$ff
    291  1bee		       85 52		      sta	R0
    292  1bf0		       a5 53		      lda	R0+1
    293  1bf2		       49 ff		      eor	#$ff
    294  1bf4		       85 53		      sta	R0+1
    295  1bf6							;
    296  1bf6		       e6 52		      inc	R0
    297  1bf8		       d0 02		      bne	getDone2
    298  1bfa		       e6 53		      inc	R0+1
    299  1bfc				   getDone2
    300  1bfc							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1bfc							;lda	  R0
    302  1bfc							;sta	  $0010
    303  1bfc							;lda	  R0+1
    304  1bfc							;sta	  $0011
    305  1bfc							;lda	  dpl
    306  1bfc							;sta	  $012
    307  1bfc
    308  1bfc		       60		      rts
    309  1bfd
    310  1bfd							;=====================================================
    311  1bfd							; Gets a line of input into LINBUF.
    312  1bfd							;
    313  1bfd							; On entry:
    314  1bfd							;    A contains the prompt character, or 0 if none.
    315  1bfd							;    X = 1 Background read
    316  1bfd							;    x = 0 Forground read with wait
    317  1bfd							;
    318  1bfd							; On exit:
    319  1bfd							;    CURPTR points to LINBUF
    320  1bfd							;    LINBUF contains the line with 0 at the end.
    321  1bfd							;    Y has offset to first non-space character
    322  1bfd							;    CURROFF has the same as Y.
    323  1bfd							;
    324  1bfd		       20 4c 1c    GetLine    jsr	ReadPrompt
    325  1c00		       e0 00		      cpx	#0
    326  1c02		       f0 14		      beq	GetLineRetry
    327  1c04		       ae 55 26 	      ldx	taskPtr
    328  1c07		       bd 56 26 	      lda	taskTable,x
    329  1c0a		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1c0c		       d0 3d		      bne	taskWaitingIO
    331  1c0e		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1c10		       9d 56 26 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1c13		       ce 4b 1c 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1c16		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1c18
    336  1c18							;
    337  1c18							; Now read a line and wait for the CR
    338  1c18							;
    339  1c18				   GetLineRetry
    340  1c18		       a9 00		      lda	#0	;Wait for input to complete
    341  1c1a		       20 64 1c 	      jsr	ReadLine
    342  1c1d
    343  1c1d							;
    344  1c1d							; Point to the line we just read
    345  1c1d							; Set the current pointer to point to the input line
    346  1c1d							;
    347  1c1d		       a0 00	   ReadComplete ldy	#0
    348  1c1f		       84 51		      sty	CUROFF
    349  1c21		       a2 11		      ldx	#LINBUF&$ff
    350  1c23		       86 4f		      stx	CURPTR
    351  1c25		       a2 2f		      ldx	#LINBUF>>8
    352  1c27		       86 50		      stx	CURPTR+1
    353  1c29							;
    354  1c29							; Output a CR/LF
    355  1c29							;
    356  1c29		       20 2b 1e 	      jsr	CRLF
    357  1c2c							;
    358  1c2c							; If a blank line, prompt again.
    359  1c2c							;
    360  1c2c		       20 22 1e 	      jsr	SkipSpaces
    361  1c2f		       b1 4f		      lda	(CURPTR),y
    362  1c31		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1c33		       20 4f 1c 	      jsr	ReadPromptRetry
    364  1c36		       ae 55 26 	      ldx	taskPtr	;if this task is waiting for IO
    365  1c39		       bd 56 26 	      lda	taskTable,x	;then get out, wait for line to
    366  1c3c		       29 40		      and	#TASKWAITIO	;Complete again
    367  1c3e		       d0 0b		      bne	taskWaitingIO
    368  1c40		       4c 18 1c 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1c43
    370  1c43				   GetLineDone
    371  1c43		       ae 55 26 	      ldx	taskPtr
    372  1c46		       a9 80		      lda	#TASKACTIVE
    373  1c48		       9d 56 26 	      sta	taskTable,x	;IO is complete
    374  1c4b
    375  1c4b				   taskWaitingIO
    376  1c4b		       60		      rts
    377  1c4c
    378  1c4c							;
    379  1c4c							;=======================================================================
    380  1c4c							; Display the prompt character
    381  1c4c							; On entry
    382  1c4c							;	    A contains the prompt character
    383  1c4c							; On exit
    384  1c4c							;	    The readbuffer index is reset to 0
    385  1c4c							;
    386  1c4c		       8d 98 2f    ReadPrompt sta	promptChar
    387  1c4f
    388  1c4f							;
    389  1c4f							; Prompt
    390  1c4f							;
    391  1c4f
    392  1c4f		       ad 98 2f    ReadPromptRetry lda	promptChar
    393  1c52		       09 00		      ora	#0	;any prompt?
    394  1c54		       f0 08		      beq	getlinenp
    395  1c56		       20 79 1f 	      jsr	VOUTCH
    396  1c59		       a9 20		      lda	#$20
    397  1c5b		       20 79 1f 	      jsr	VOUTCH	;Space after prompt
    398  1c5e							;
    399  1c5e		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1c60		       8e 95 2f 	      stx	getlinx
    401  1c63		       60		      rts
    402  1c64							;
    403  1c64							;===============================================================
    404  1c64							; This fuction is the driver for the line input
    405  1c64							; on call if a = 0 then it waits for all input
    406  1c64							;	      a = 1 then nowait for input
    407  1c64							; On exit
    408  1c64							;		       c clear if not complete line
    409  1c64							;		       c set if it was a complete line
    410  1c64
    411  1c64				   ReadLine
    412  1c64		       8d 97 2f 	      sta	inputNoWait
    413  1c67		       c9 00		      cmp	#0
    414  1c69		       f0 05		      beq	getline1
    415  1c6b		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1c6e		       f0 2b		      beq	GetLineNoWait
    417  1c70		       20 7c 1f    getline1   jsr	VGETCH
    418  1c73					      if	CTMON65
    419  1c73		       48		      pha
    420  1c74		       20 79 1f 	      jsr	VOUTCH	;echo echo echo
    421  1c77		       68		      pla
    422  1c78					      endif
    423  1c78		       c9 0d		      cmp	#CR
    424  1c7a		       f0 15		      beq	getlind	;end of line
    425  1c7c		       c9 08		      cmp	#BS	;backspace?
    426  1c7e		       f0 1d		      beq	getlinebs
    427  1c80		       ae 95 2f 	      ldx	getlinx
    428  1c83		       9d 11 2f 	      sta	LINBUF,x
    429  1c86		       e8		      inx
    430  1c87		       8e 95 2f 	      stx	getlinx
    431  1c8a		       ad 97 2f 	      lda	inputNoWait
    432  1c8d		       f0 e1		      beq	getline1
    433  1c8f		       d0 0a		      bne	GetLineNoWait
    434  1c91							;
    435  1c91							; CR was hit
    436  1c91							;
    437  1c91		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1c93		       ae 95 2f 	      ldx	getlinx
    439  1c96		       9d 11 2f 	      sta	LINBUF,x
    440  1c99
    441  1c99		       38		      sec		; Carry set then cr received
    442  1c9a		       60		      rts
    443  1c9b
    444  1c9b				   GetLineNoWait
    445  1c9b		       18		      clc		; Carry clear no end of line
    446  1c9c		       60		      rts
    447  1c9d							;
    448  1c9d							; Backspace was hit
    449  1c9d							;
    450  1c9d		       ae 95 2f    getlinebs  ldx	getlinx
    451  1ca0		       f0 0e		      beq	getlineEOL	;at start of line
    452  1ca2		       ca		      dex
    453  1ca3		       8e 95 2f 	      stx	getlinx
    454  1ca6		       20 22 14    getlinepbs jsr	puts
      0  1ca9					      db	27,"[K",0
      1  1ca9		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1cad		       4c 70 1c 	      jmp	getline1
    457  1cb0		       a9 20	   getlineEOL lda	#SPACE
    458  1cb2		       20 79 1f 	      jsr	VOUTCH
    459  1cb5		       d0 ef		      bne	getlinepbs
    460  1cb7							;
    461  1cb7							;=====================================================
    462  1cb7							; Count the length of the line currently in LINBUF
    463  1cb7							; starting at offset Y.  Returns the length in X.  The
    464  1cb7							; starting offset in Y should point past the ASCII
    465  1cb7							; line number.  Also counts the trailing NULL and two
    466  1cb7							; extra bytes for where the line number will be.
    467  1cb7							; Update must now include leading length byte not the null at end ****************
    468  1cb7							;
    469  1cb7				   getLineLength
    470  1cb7		       a2 00		      ldx	#0	;size
    471  1cb9		       b9 11 2f    getLineL2  lda	LINBUF,y
    472  1cbc		       f0 04		      beq	getLineL3
    473  1cbe		       c8		      iny
    474  1cbf		       e8		      inx
    475  1cc0		       d0 f7		      bne	getLineL2
    476  1cc2		       e8	   getLineL3  inx		;count null at end
    477  1cc3		       e8		      inx		;line number LSB
    478  1cc4		       e8		      inx		;MSB
    479  1cc5		       e8		      inx		;change: count new leading line length
    480  1cc6		       8e ab 2f 	      stx	lineLength
    481  1cc9		       60		      rts
    482  1cca							;
    483  1cca							;=====================================================
    484  1cca							; Count the length of the line pointed to by CURPTR.
    485  1cca							; This also counts the line number and the terminating
    486  1cca							; null.  Ie, this string returns 8:
    487  1cca							;
    488  1cca							; <lineLow><lineHi>Hello<null>
    489  1cca							;
    490  1cca							; Another way of looking at it: add the return value
    491  1cca							; to the CURPTR and it'll point to the next line's
    492  1cca							; line number.  Returns the value in Y.
    493  1cca							; Update to ject get the leading byte length ********************
    494  1cca							;
    495  1cca							;getCURPTRLength
    496  1cca							;		ldy	CURPTR
    497  1cca							;		ldy	#3	;change: skip line number and leading length byte
    498  1cca							;getCLineL2	lda	(CURPTR),y
    499  1cca							;		beq	getCLineL3
    500  1cca							;		iny
    501  1cca							;		bne	getCLineL2
    502  1cca							;getCLineL3	iny		;count null at end
    503  1cca							;		rts
    504  1cca
    505  1cca							;
    506  1cca							;=====================================================
    507  1cca							; This saves ILPC.  This saves to a single save area,
    508  1cca							; so it can't be called more than once.
    509  1cca							;
    510  1cca		       a5 43	   saveIL     lda	ILPC
    511  1ccc		       8d a7 2f 	      sta	tempIL
    512  1ccf		       a5 44		      lda	ILPC+1
    513  1cd1		       8d a8 2f 	      sta	tempIL+1
    514  1cd4		       60		      rts
    515  1cd5							;
    516  1cd5							;=====================================================
    517  1cd5							; This restores ILPC.
    518  1cd5							;
    519  1cd5		       ad a7 2f    restoreIL  lda	tempIL
    520  1cd8		       85 43		      sta	ILPC
    521  1cda		       ad a8 2f 	      lda	tempIL+1
    522  1cdd		       85 44		      sta	ILPC+1
    523  1cdf		       60		      rts
    524  1ce0							;
    525  1ce0							;=====================================================
    526  1ce0							; This pushes R0 onto the stack.
    527  1ce0							;
    528  1ce0		       8c 9e 2f    pushR0     sty	rtemp1
    529  1ce3		       a4 4a		      ldy	MATHSTACKPTR
    530  1ce5		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1ce7		       b0 38		      bcs	pusherr
    532  1ce9		       a5 52		      lda	R0
    533  1ceb		       91 48		      sta	(MATHSTACK),y
    534  1ced		       c8		      iny
    535  1cee		       a5 53		      lda	R0+1
    536  1cf0		       91 48		      sta	(MATHSTACK),y
    537  1cf2		       c8		      iny
    538  1cf3		       84 4a		      sty	MATHSTACKPTR
    539  1cf5		       ac 9e 2f 	      ldy	rtemp1
    540  1cf8		       18		      clc
    541  1cf9		       60		      rts
    542  1cfa
    543  1cfa							;=====================================================
    544  1cfa							; This pushes curptr basic current line onto the call stack.
    545  1cfa							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1cfa
    547  1cfa				   pushLN
    548  1cfa		       8d 9f 2f 	      STA	rtemp1+1	; Store type of push being done
    549  1cfd		       8c 9e 2f 	      sty	rtemp1
    550  1d00		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  1d02		       c5 4d		      cmp	GOSUBSTACKPTR
    552  1d04		       90 1b		      bcc	pusherr	; No error
    553  1d06		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  1d08		       a2 00		      ldx	#0	; Start of bytes to copy
    555  1d0a				   pushLoop
    556  1d0a		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  1d0c		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  1d0e		       c8		      iny		; Next destination
    559  1d0f		       e8		      inx		; Next Source byte
    560  1d10		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  1d12		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  1d14
    563  1d14		       ad 9f 2f    pushDone   lda	rtemp1+1	; Type of stack entry
    564  1d17		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  1d19		       c8		      iny		; Next entry
    566  1d1a
    567  1d1a		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  1d1c		       ac 9e 2f 	      ldy	rtemp1
    569  1d1f		       18		      clc
    570  1d20		       60		      rts
    571  1d21				   pusherr
    572  1d21		       38		      sec
    573  1d22		       60		      rts
    574  1d23							;=====================================================
    575  1d23							; This pops Top Off gosub call Stack and
    576  1d23							; places it in CURPTR/CUROFF.
    577  1d23							; This checks if the type = 1 GOSUB
    578  1d23							; if not it removes what ever is on the stack
    579  1d23							; until it finds the next return. Allowing
    580  1d23							; a return from within a for/next
    581  1d23							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  1d23		       8c 9e 2f    popLN      sty	rtemp1
    583  1d26		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  1d28		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  1d2a
    586  1d2a				   popContinue
    587  1d2a		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  1d2c		       90 22		      bcc	poperr	; Process an error
    589  1d2e
    590  1d2e		       88		      dey		; Position to read entry type
    591  1d2f		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  1d31		       8d 9f 2f 	      sta	rtemp1+1	; Save to be returned
    593  1d34		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  1d36		       f0 04		      beq	popLoop	; Restore the line
    595  1d38		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  1d3a		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  1d3c
    598  1d3c				   popLoop
    599  1d3c		       88		      dey
    600  1d3d		       ca		      dex
    601  1d3e		       b1 4b		      lda	(GOSUBSTACK),y
    602  1d40		       95 4f		      sta	CURPTR,x
    603  1d42		       e0 00		      cpx	#0
    604  1d44		       d0 f6		      bne	popLoop	; Loop until all moved
    605  1d46
    606  1d46
    607  1d46		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  1d48		       ac 9e 2f 	      ldy	rtemp1
    609  1d4b		       ad 9f 2f 	      lda	rtemp1+1	; get the type of return
    610  1d4e		       18		      clc
    611  1d4f		       60		      rts
    612  1d50
    613  1d50		       38	   poperr     sec
    614  1d51		       60		      rts
    615  1d52
    616  1d52		       88	   popSkipEntry dey
    617  1d53		       88		      dey
    618  1d54		       88		      dey
    619  1d55		       4c 2a 1d 	      jmp	popContinue
    620  1d58
    621  1d58							;
    622  1d58							;=====================================================
    623  1d58							; This pushes R1 onto the stack
    624  1d58							;
    625  1d58		       8c 9e 2f    pushR1     sty	rtemp1
    626  1d5b		       a4 4a		      ldy	MATHSTACKPTR
    627  1d5d		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  1d5f		       b0 ef		      bcs	poperr
    629  1d61		       a5 54		      lda	R1
    630  1d63		       91 48		      sta	(MATHSTACK),y
    631  1d65		       c8		      iny
    632  1d66		       a5 55		      lda	R1+1
    633  1d68		       91 48		      sta	(MATHSTACK),y
    634  1d6a		       c8		      iny
    635  1d6b		       84 4a		      sty	MATHSTACKPTR
    636  1d6d		       ac 9e 2f 	      ldy	rtemp1
    637  1d70		       18		      clc
    638  1d71		       60		      rts
    639  1d72							;
    640  1d72							;=====================================================
    641  1d72							; This pops Top Of Stack and places it in R0.
    642  1d72							;
    643  1d72		       8c 9e 2f    popR0      sty	rtemp1
    644  1d75		       a4 4a		      ldy	MATHSTACKPTR
    645  1d77		       f0 d7		      beq	poperr
    646  1d79		       88		      dey
    647  1d7a		       b1 48		      lda	(MATHSTACK),y
    648  1d7c		       85 53		      sta	R0+1
    649  1d7e		       88		      dey
    650  1d7f		       b1 48		      lda	(MATHSTACK),y
    651  1d81		       85 52		      sta	R0
    652  1d83		       84 4a		      sty	MATHSTACKPTR
    653  1d85		       ac 9e 2f 	      ldy	rtemp1
    654  1d88		       18		      clc
    655  1d89		       60		      rts
    656  1d8a
    657  1d8a							;
    658  1d8a							;=====================================================
    659  1d8a							; This pops TOS and places it in R1.
    660  1d8a							;
    661  1d8a		       8c 9e 2f    popR1      sty	rtemp1
    662  1d8d		       a4 4a		      ldy	MATHSTACKPTR
    663  1d8f		       f0 bf		      beq	poperr
    664  1d91		       88		      dey
    665  1d92		       b1 48		      lda	(MATHSTACK),y
    666  1d94		       85 55		      sta	R1+1
    667  1d96		       88		      dey
    668  1d97		       b1 48		      lda	(MATHSTACK),y
    669  1d99		       85 54		      sta	R1
    670  1d9b		       84 4a		      sty	MATHSTACKPTR
    671  1d9d		       ac 9e 2f 	      ldy	rtemp1
    672  1da0		       60		      rts
    673  1da1							;
    674  1da1							;=====================================================
    675  1da1							; This pops TOS and places it in MQ.
    676  1da1							;
    677  1da1		       8c 9e 2f    popMQ      sty	rtemp1
    678  1da4		       a4 4a		      ldy	MATHSTACKPTR
    679  1da6		       f0 a8		      beq	poperr
    680  1da8		       88		      dey
    681  1da9		       b1 48		      lda	(MATHSTACK),y
    682  1dab		       85 57		      sta	MQ+1
    683  1dad		       88		      dey
    684  1dae		       b1 48		      lda	(MATHSTACK),y
    685  1db0		       85 56		      sta	MQ
    686  1db2		       84 4a		      sty	MATHSTACKPTR
    687  1db4		       ac 9e 2f 	      ldy	rtemp1
    688  1db7		       60		      rts
    689  1db8							;
    690  1db8							;=====================================================
    691  1db8							; This assists with multiplication and division by
    692  1db8							; looking at R0 and R1 and saving a flag as to what
    693  1db8							; sign the result will be.  Math is always done on
    694  1db8							; positive numbers, so this converts negative numbers
    695  1db8							; into positives.  On exit, R0 and R1 are both
    696  1db8							; positive.  If the signs were different then 'signs'
    697  1db8							; will be non-zero.
    698  1db8							;
    699  1db8		       a9 00	   SaveSigns  lda	#0
    700  1dba		       8d 9d 2f 	      sta	sign	;assume positive
    701  1dbd		       a5 53		      lda	R0+1	;MSB
    702  1dbf		       10 13		      bpl	SaveSigns1
    703  1dc1		       ee 9d 2f 	      inc	sign	;it's negative
    704  1dc4		       49 ff		      eor	#$ff	;flip bits
    705  1dc6		       85 53		      sta	R0+1
    706  1dc8		       a5 52		      lda	R0
    707  1dca		       49 ff		      eor	#$ff
    708  1dcc		       85 52		      sta	R0
    709  1dce		       e6 52		      inc	R0
    710  1dd0		       d0 02		      bne	SaveSigns1
    711  1dd2		       e6 53		      inc	R0+1
    712  1dd4		       a5 55	   SaveSigns1 lda	R1+1
    713  1dd6		       10 1a		      bpl	SaveSigns2
    714  1dd8		       48		      pha
    715  1dd9		       ad 9d 2f 	      lda	sign
    716  1ddc		       49 01		      eor	#1
    717  1dde		       8d 9d 2f 	      sta	sign
    718  1de1		       68		      pla
    719  1de2		       49 ff		      eor	#$ff	;flip bits
    720  1de4		       85 55		      sta	R1+1
    721  1de6		       a5 54		      lda	R1
    722  1de8		       49 ff		      eor	#$ff
    723  1dea		       85 54		      sta	R1
    724  1dec		       e6 54		      inc	R1
    725  1dee		       d0 02		      bne	SaveSigns2
    726  1df0		       e6 55		      inc	R1+1
    727  1df2		       60	   SaveSigns2 rts
    728  1df3							;
    729  1df3							;=====================================================
    730  1df3							; This looks at the value of 'signs' and will convert
    731  1df3							; both R0 and R1 to negative if set.
    732  1df3							;
    733  1df3				   RestoreSigns
    734  1df3		       ad 9d 2f 	      lda	sign
    735  1df6		       f0 28		      beq	restoresigns2
    736  1df8							;
    737  1df8		       a5 52		      lda	R0
    738  1dfa		       d0 02		      bne	restoresigns3
    739  1dfc		       c6 53		      dec	R0+1
    740  1dfe				   restoresigns3
    741  1dfe		       c6 52		      dec	R0
    742  1e00		       a5 52		      lda	R0
    743  1e02		       49 ff		      eor	#$ff
    744  1e04		       85 52		      sta	R0
    745  1e06		       a5 53		      lda	R0+1
    746  1e08		       49 ff		      eor	#$ff
    747  1e0a		       85 53		      sta	R0+1
    748  1e0c							;
    749  1e0c		       a5 54		      lda	R1
    750  1e0e		       d0 02		      bne	restoresigns4
    751  1e10		       c6 55		      dec	R1+1
    752  1e12				   restoresigns4
    753  1e12		       c6 54		      dec	R1
    754  1e14		       a5 54		      lda	R1
    755  1e16		       49 ff		      eor	#$ff
    756  1e18		       85 54		      sta	R1
    757  1e1a		       a5 55		      lda	R1+1
    758  1e1c		       49 ff		      eor	#$ff
    759  1e1e		       85 55		      sta	R1+1
    760  1e20							;
    761  1e20				   restoresigns2
    762  1e20		       60		      rts
    763  1e21							;
    764  1e21							;=====================================================
    765  1e21							; Skip over spaces.  Returns Y with the offset to
    766  1e21							; either the last character in the line, or the first
    767  1e21							; non-space character.
    768  1e21							;
    769  1e21
    770  1e21		       c8	   skipsp2    iny
    771  1e22		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  1e24		       f0 04		      beq	Skip3	;end of line
    773  1e26		       c9 20		      cmp	#SPACE
    774  1e28		       f0 f7		      beq	skipsp2
    775  1e2a		       60	   Skip3      rts
    776  1e2b							;*********************************************************
    777  1e2b							; Output a CR/LF combination to the console.  Preserves
    778  1e2b							; all registers.
    779  1e2b							;
    780  1e2b		       48	   tbcrlf     pha
    781  1e2c		       a9 0d		      lda	#CR
    782  1e2e		       20 79 1f 	      jsr	VOUTCH
    783  1e31		       a9 0a		      lda	#LF
    784  1e33		       20 79 1f 	      jsr	VOUTCH
    785  1e36		       68		      pla
    786  1e37		       60		      rts
    787  1e38							;
    788  1e38							;=====================================================
    789  1e38							; Some logic to print the Line of basic code being executed
    790  1e38		       24 40	   idbgBasic  bit	ILTrace
    791  1e3a		       50 75		      bvc	dbgBasicNone
    792  1e3c		       98		      tya
    793  1e3d		       48		      pha
    794  1e3e		       20 ad 1f 	      jsr	SetOutDebug
    795  1e41
    796  1e41		       a5 4f		      lda	CURPTR
    797  1e43		       85 59		      sta	dpl
    798  1e45		       a5 50		      lda	CURPTR+1
    799  1e47		       85 5a		      sta	dpl+1
    800  1e49
    801  1e49		       20 ba 14 	      jsr	PrintProgramLine
    802  1e4c
    803  1e4c		       a5 40		      lda	ILTrace
    804  1e4e		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  1e50		       f0 5a		      beq	dbgBasicDone
    806  1e52		       20 c4 1f 	      jsr	SetInDebug
    807  1e55		       20 22 14 	      jsr	puts
      0  1e58					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1e58		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  1e95				   dbgBasicLoop
    810  1e95		       20 7c 1f 	      jsr	VGETCH
    811  1e98		       20 2b 1e 	      jsr	CRLF
    812  1e9b		       20 e8 1f 	      jsr	SetInDebugEnd
    813  1e9e
    814  1e9e		       c9 73		      cmp	#'s	; Quit program
    815  1ea0		       f0 12		      beq	dbgBasicStop
    816  1ea2
    817  1ea2		       c9 64		      cmp	#'d	; Display Variables
    818  1ea4		       d0 06		      bne	dbgBasicDone
    819  1ea6
    820  1ea6		       20 7d 14 	      jsr	PrintAllVars
    821  1ea9		       18		      clc
    822  1eaa		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  1eac
    824  1eac		       20 db 1f    dbgBasicDone jsr	SetOutDebugEnd
    825  1eaf		       68		      pla
    826  1eb0		       a8		      tay
    827  1eb1		       4c c2 02    dbgBasicNone jmp	NextIL
    828  1eb4
    829  1eb4				   dbgBasicStop
    830  1eb4		       20 db 1f 	      jsr	SetOutDebugEnd
    831  1eb7		       68		      pla
    832  1eb8		       a8		      tay
    833  1eb9		       4c 31 06 	      jmp	iFIN
    834  1ebc							;
    835  1ebc							;=====================================================
    836  1ebc							; This is some debug logic which displays the current
    837  1ebc							; value of the ILPC and the line buffer.
    838  1ebc							;
    839  1ebc		       24 40	   dbgLine    bit	ILTrace
    840  1ebe		       30 01		      bmi	dbgPrt
    841  1ec0		       60		      rts
    842  1ec1				   dbgPrt
    843  1ec1		       20 ad 1f 	      jsr	SetOutDebug
    844  1ec4		       20 22 14 	      jsr	puts
      0  1ec7					      db	"ILPC: ",0
      1  1ec7		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    846  1ece		       a5 44		      lda	ILPC+1
    847  1ed0		       20 05 14 	      jsr	OUTHEX
    848  1ed3		       a5 43		      lda	ILPC
    849  1ed5		       20 05 14 	      jsr	OUTHEX
    850  1ed8		       a9 20		      lda	#SPACE
    851  1eda		       20 79 1f 	      jsr	VOUTCH
    852  1edd		       a0 00		      ldy	#0
    853  1edf		       b1 43		      lda	(ILPC),y
    854  1ee1		       20 05 14 	      jsr	OUTHEX
    855  1ee4							;
    856  1ee4							; Display the CURPTR value and offset
    857  1ee4							;
    858  1ee4		       20 22 14 	      jsr	puts
      0  1ee7					      db	", CURPTR: ",0
      1  1ee7		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    860  1ef2		       a5 50		      lda	CURPTR+1
    861  1ef4		       20 05 14 	      jsr	OUTHEX
    862  1ef7		       a5 4f		      lda	CURPTR
    863  1ef9		       20 05 14 	      jsr	OUTHEX
    864  1efc		       a9 2b		      lda	#'+
    865  1efe		       20 79 1f 	      jsr	VOUTCH
    866  1f01		       a5 51		      lda	CUROFF
    867  1f03		       20 05 14 	      jsr	OUTHEX
    868  1f06							;
    869  1f06		       20 2b 1e 	      jsr	CRLF
    870  1f09		       20 db 1f 	      jsr	SetOutDebugEnd
    871  1f0c		       20 3f 1f 	      jsr	ILChkRange
    872  1f0f		       b0 02		      bcs	dbgLineErr
    873  1f11		       18		      clc
    874  1f12		       60		      rts
    875  1f13
    876  1f13				   dbgLineErr
    877  1f13		       20 ad 1f 	      jsr	SetOutDebug
    878  1f16		       20 22 14 	      jsr	puts
      0  1f19					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1f19		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    880  1f3a		       20 db 1f 	      jsr	SetOutDebugEnd
    881  1f3d		       38		      sec
    882  1f3e		       60		      rts
    883  1f3f
    884  1f3f		       a5 44	   ILChkRange lda	ILPC+1
    885  1f41		       c9 22		      cmp	#IL>>8
    886  1f43		       90 18		      bcc	ILBadRange
    887  1f45		       d0 06		      bne	ILChkHigh
    888  1f47
    889  1f47		       a5 43		      lda	ILPC
    890  1f49		       c9 18		      cmp	#IL&$ff
    891  1f4b		       90 10		      bcc	ILBadRange
    892  1f4d
    893  1f4d		       a5 44	   ILChkHigh  lda	ILPC+1
    894  1f4f		       c9 26		      cmp	#ILEND>>8
    895  1f51		       90 08		      bcc	ILGoodRange
    896  1f53		       d0 08		      bne	ILBadRange
    897  1f55
    898  1f55		       a5 43		      lda	ILPC
    899  1f57		       c9 0e		      cmp	#ILEND&$ff
    900  1f59		       b0 02		      bcs	ILBadRange
    901  1f5b
    902  1f5b		       18	   ILGoodRange clc
    903  1f5c		       60		      rts
    904  1f5d				   ILBadRange
    905  1f5d		       38		      sec
    906  1f5e		       60		      rts
    907  1f5f
    908  1f5f
    909  1f5f							;=====================================================
    910  1f5f							; Set output vector to the console output function
    911  1f5f							;
    912  1f5f				   SetOutConsole
    913  1f5f		       48		      pha
    914  1f60		       a9 0c		      lda	#OUTCH&$ff
    915  1f62		       8d a2 2f 	      sta	BOutVec
    916  1f65		       a9 f0		      lda	#OUTCH>>8
    917  1f67		       8d a3 2f 	      sta	BOutVec+1
    918  1f6a		       68		      pla
    919  1f6b		       60		      rts
    920  1f6c
    921  1f6c				   SetInConsole
    922  1f6c		       48		      pha
    923  1f6d		       a9 09		      lda	#GETCH&$ff
    924  1f6f		       8d a4 2f 	      sta	BInVec
    925  1f72		       a9 f0		      lda	#GETCH>>8
    926  1f74		       8d a5 2f 	      sta	BInVec+1
    927  1f77		       68		      pla
    928  1f78		       60		      rts
    929  1f79
    930  1f79							;=====================================================
    931  1f79							; Jump to the output/input function in BOutVec/BInVec
    932  1f79							;
    933  1f79		       6c a2 2f    VOUTCH     jmp	(BOutVec)
    934  1f7c		       6c a4 2f    VGETCH     jmp	(BInVec)
    935  1f7f
    936  1f7f
    937  1f7f							;====================================================
    938  1f7f							;Clear the terminal assume it is ansii or vt100
    939  1f7f							;
    940  1f7f				   iCLEARSCREEN
    941  1f7f		       20 22 14 	      jsr	puts
      0  1f82					      db	$1b,'[,'2,'J,0
      1  1f82		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    943  1f87		       4c c2 02 	      jmp	NextIL
    944  1f8a
    945  1f8a							;====================================================
    946  1f8a							; Push true and false onto math stack
    947  1f8a				   pushTrue
    948  1f8a		       a9 ff		      lda	#$ff
    949  1f8c		       85 52	   pushTF     sta	R0
    950  1f8e		       85 53		      sta	R0+1
    951  1f90		       20 e0 1c 	      jsr	pushR0
    952  1f93		       60		      rts
    953  1f94		       a9 00	   pushFalse  lda	#0
    954  1f96		       f0 f4		      beq	pushTF
    955  1f98
    956  1f98							;======================================================
    957  1f98							; Copy stack top to R1
    958  1f98				   CopyStackR1
    959  1f98		       98		      tya
    960  1f99		       48		      pha
    961  1f9a		       a4 4a		      ldy	MATHSTACKPTR
    962  1f9c		       88		      dey
    963  1f9d		       b1 48		      lda	(MATHSTACK),y
    964  1f9f		       85 55		      sta	R1+1
    965  1fa1		       88		      dey
    966  1fa2		       b1 48		      lda	(MATHSTACK),y
    967  1fa4		       85 54		      sta	R1
    968  1fa6		       68		      pla
    969  1fa7		       a8		      tay
    970  1fa8		       60		      rts
    971  1fa9
    972  1fa9
    973  1fa9							;====================================================
    974  1fa9							;Swap the out debug call for standard calls
    975  1fa9		       00 00	   DebugIOSave ds	2
    976  1fab		       00 00	   DebugInSave ds	2
    977  1fad				   SetOutDebug
    978  1fad		       ad a2 2f 	      lda	BOutVec
    979  1fb0		       8d a9 1f 	      sta	DebugIOSave
    980  1fb3		       ad a3 2f 	      lda	BOutVec+1
    981  1fb6		       8d aa 1f 	      sta	DebugIOSave+1
    982  1fb9		       a9 ff		      lda	#OUTDEBUG&$ff	; Put the Debug output
    983  1fbb		       8d a2 2f 	      sta	BOutVec
    984  1fbe		       a9 1f		      lda	#OUTDEBUG>>8
    985  1fc0		       8d a3 2f 	      sta	BOutVec+1
    986  1fc3		       60		      rts
    987  1fc4				   SetInDebug
    988  1fc4		       ad a4 2f 	      lda	BInVec
    989  1fc7		       8d ab 1f 	      sta	DebugInSave
    990  1fca		       ad a5 2f 	      lda	BInVec+1
    991  1fcd		       8d ac 1f 	      sta	DebugInSave+1
    992  1fd0		       a9 03		      lda	#INDEBUG&$ff
    993  1fd2		       8d a4 2f 	      sta	BInVec
    994  1fd5		       a9 20		      lda	#INDEBUG>>8
    995  1fd7		       8d a5 2f 	      sta	BInVec+1
    996  1fda		       60		      rts
    997  1fdb				   SetOutDebugEnd
    998  1fdb		       ad a9 1f 	      lda	DebugIOSave
    999  1fde		       8d a2 2f 	      sta	BOutVec
   1000  1fe1		       ad aa 1f 	      lda	DebugIOSave+1
   1001  1fe4		       8d a3 2f 	      sta	BOutVec+1
   1002  1fe7		       60		      rts
   1003  1fe8				   SetInDebugEnd
   1004  1fe8		       ad ab 1f 	      lda	DebugInSave
   1005  1feb		       8d a4 2f 	      sta	BInVec
   1006  1fee		       ad aa 1f 	      lda	DebugIOSave+1
   1007  1ff1		       8d a5 2f 	      sta	BInVec+1
   1008  1ff4		       60		      rts
   1009  1ff5							;
   1010  1ff5							;====================================================
   1011  1ff5							; Output to the debug console
   1012  1ff5							;     x = high address byte
   1013  1ff5							;     y = low address byte
   1014  1ff5							;     a = Terminator for string
   1015  1ff5				   DebugWrite
   1016  1ff5		       20 ad 1f 	      jsr	SetOutDebug
   1017  1ff8		       20 60 14 	      jsr	PrtStr
   1018  1ffb		       20 db 1f 	      jsr	SetOutDebugEnd
   1019  1ffe		       60		      rts
   1020  1fff
   1021  1fff				   OUTDEBUG
   1022  1fff		       8d		      .byte.b	$8D	; STA
   1023  2000		       01 e0	   DEBUGPORT  .word.w	$E001	;Dont check anything just output the byte
   1024  2002		       60		      RTS
   1025  2003
   1026  2003				   INDEBUG
   1027  2003		       ad		      .byte.b	$AD	; LDA
   1028  2004		       00 e0	   DEBUGPORTSTATUS .word.w	$E000
   1029  2006
   1030  2006		       29 01		      and	#$01
   1031  2008		       f0 f9		      beq	INDEBUG
   1032  200a
   1033  200a		       ad		      .byte.b	$AD	; LDA
   1034  200b		       01 e0	   DEBUGPORTIN .word.w	$E001
   1035  200d		       60		      rts
   1036  200e
   1037  200e							;======================================================================
   1038  200e							;Copy Quoted string to buffer, terminate with 0 byte
   1039  200e							; R0  Source tring points to tString type
   1040  200e							; x is terminator
   1041  200e							; R1 points to destinition location
   1042  200e							; On exit R0 contains length of copy Plus Term and leading bytes
   1043  200e
   1044  200e				   qstrcpy
   1045  200e		       20 e0 1c 	      jsr	pushR0
   1046  2011		       20 5e 20 	      jsr	IncR0	; point past the tString
   1047  2014		       20 5e 20 	      jsr	IncR0	; Point Past the opening "
   1048  2017		       a2 22		      ldx	#'"	; copy Termination
   1049  2019		       20 33 20 	      jsr	pstrcpy
   1050  201c		       20 5e 20 	      jsr	IncR0	; point to "
   1051  201f		       20 5e 20 	      jsr	IncR0	; Point to next free byte
   1052  2022		       20 8a 1d 	      jsr	popR1
   1053  2025		       38		      sec
   1054  2026		       a5 52		      lda	R0
   1055  2028		       e5 54		      sbc	R1
   1056  202a		       85 52		      sta	R0
   1057  202c		       a5 53		      lda	R0+1
   1058  202e		       e5 55		      sbc	R1+1
   1059  2030		       85 53		      sta	R0+1
   1060  2032		       60		      rts
   1061  2033
   1062  2033							;=========================================================================
   1063  2033							;Copy string from R0 to R1, terminator in x
   1064  2033							; On exit    R0 contains the length of the copy
   1065  2033				   pstrcpy
   1066  2033		       a0 00		      ldy	#0
   1067  2035		       86 58		      stx	R2
   1068  2037
   1069  2037				   strcpyLoop
   1070  2037		       b1 52		      lda	(R0),y
   1071  2039		       c5 58		      cmp	R2
   1072  203b		       f0 0a		      beq	strcpyDone
   1073  203d		       91 54		      sta	(R1),y
   1074  203f		       20 5e 20 	      jsr	IncR0
   1075  2042		       20 4c 20 	      jsr	IncR1
   1076  2045		       90 f0		      bcc	strcpyLoop
   1077  2047				   strcpyDone
   1078  2047		       a9 00		      lda	#0
   1079  2049		       91 54		      sta	(R1),y
   1080  204b
   1081  204b		       60		      rts
   1082  204c
   1083  204c							;=========================================================================
   1084  204c							; on exit c is set on overflow
   1085  204c				   IncR1
   1086  204c		       48		      pha
   1087  204d		       18		      clc
   1088  204e		       a9 01		      lda	#1
   1089  2050		       65 54		      adc	R1
   1090  2052		       85 54		      sta	R1
   1091  2054		       90 06		      bcc	IncR1Done
   1092  2056		       a9 00		      lda	#0
   1093  2058		       65 55		      adc	R1+1
   1094  205a		       85 55		      sta	R1+1
   1095  205c				   IncR1Done
   1096  205c		       68		      pla
   1097  205d		       60		      rts
   1098  205e							;=========================================================================
   1099  205e							; on exit c is set on overflow
   1100  205e				   IncR0
   1101  205e		       48		      pha
   1102  205f		       18		      clc
   1103  2060		       a9 01		      lda	#1
   1104  2062		       65 52		      adc	R0
   1105  2064		       85 52		      sta	R0
   1106  2066		       90 06		      bcc	IncR0Done
   1107  2068		       a9 00		      lda	#0
   1108  206a		       65 53		      adc	R0+1
   1109  206c		       85 53		      sta	R0+1
   1110  206e				   IncR0Done
   1111  206e		       68		      pla
   1112  206f		       60		      rts
   1113  2070
   1114  2070
   1115  2070
   1116  2070
   1117  2070
   1118  2070
   1119  2070
   1120  2070
   1121  2070
   1122  2070
   1123  2070
   1124  2070
   1125  2070
   1126  2070
   1127  2070
   1128  2070
------- FILE mytb.asm
   2377  2070
   2378  2070					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  2070					      include	"storage.asm"
      1  2070							;
      2  2070							;=====================================================
      3  2070							;=====================================================
      4  2070							;=====================================================
      5  2070							; This file contains the functions for saving and
      6  2070							; restoring programs from some sort of mass storage
      7  2070							; device.  This particular version is for using the
      8  2070							; Corsham Tech SD Card System.
      9  2070							;=====================================================
     10  2070							;=====================================================
     11  2070							;=====================================================
     12  2070
     13 U260e					      seg.u	TBData
     14 U260e		       00	   diskBufLength ds	1
     15 U260f		       00	   diskBufOffset ds	1
     16 U2610		       00 00 00 00*DiskFileName ds	64
     17 U2650
     18  2070					      SEG	Code
     19  2070
     20  2070							;
     21  2070							;=====================================================
     22  2070							; Open a file for reading as a program.  The next
     23  2070							; thing on the line should be the filename.
     24  2070							;
     25  2070				   iOPENREAD
     26  2070					      if	XKIM || CTMON65
     27  2070		       20 8a 20 	      jsr	setFileName	;Set the file name to open
     28  2073		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  2076		       90 07		      bcc	Ropenok	;branch if opened ok
     30  2078							;
     31  2078							; Open failed
     32  2078							;
     33  2078		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  207a		       a9 00	   Rdfail2    lda	#0
     35  207c		       4c a4 06 	      jmp	iErr2
     36  207f							;
     37  207f							; Clear counts and offsets so the next read will
     38  207f							; cause the file to be read.
     39  207f							;
     40  207f		       a9 00	   Ropenok    lda	#0
     41  2081		       8d 0f 26 	      sta	diskBufOffset
     42  2084		       8d 0e 26 	      sta	diskBufLength
     43  2087		       4c c2 02 	      jmp	NextIL
     44  208a					      endif
     45  208a
     46  208a							;===============================================================
     47  208a							; Set file name
     48  208a				   setFileName
     49  208a		       a4 51		      ldy	CUROFF
     50  208c		       b1 4f		      lda	(CURPTR),y
     51  208e		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  2090		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  2092
     54  2092		       18		      clc
     55  2093		       98		      tya
     56  2094		       65 4f		      adc	CURPTR
     57  2096		       85 52		      sta	R0	;LSB
     58  2098		       a5 50		      lda	CURPTR+1
     59  209a		       69 00		      adc	#0
     60  209c		       85 53		      sta	R0+1
     61  209e		       a9 10		      lda	#DiskFileName&$ff
     62  20a0		       85 54		      sta	R1
     63  20a2		       a9 26		      lda	#DiskFileName>>8
     64  20a4		       85 55		      sta	R1+1
     65  20a6		       20 0e 20 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  20a9		       a5 52		      lda	R0
     67  20ab		       18		      clc
     68  20ac		       65 51		      adc	CUROFF	; add the current offset
     69  20ae		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  20b0
     71  20b0		       a0 10		      ldy	#DiskFileName&$ff
     72  20b2		       a2 26		      ldx	#DiskFileName>>8
     73  20b4		       18		      clc
     74  20b5		       60		      rts
     75  20b6
     76  20b6				   setFileNameNotFound
     77  20b6		       68		      pla
     78  20b7		       68		      pla		; remove the return address from the stack
     79  20b8		       a9 00		      lda	#0
     80  20ba		       a2 09		      ldx	#ERR_NO_FILENAME
     81  20bc		       4c a4 06 	      jmp	iErr2
     82  20bf
     83  20bf							;
     84  20bf							;==============================JUSTLOSTINTIME 08/02/2022========
     85  20bf							;Remove a file from the disk
     86  20bf				   iRMFILE
     87  20bf					      if	XKIM || CTMON65
     88  20bf		       20 8a 20 	      jsr	setFileName
     89  20c2		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  20c5		       90 07		      bcc	wrmOk	;branch if removed ok
     91  20c7		       a9 00		      lda	#0
     92  20c9		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  20cb		       4c a4 06 	      jmp	iErr2
     94  20ce				   wrmOk
     95  20ce		       4c c2 02 	      jmp	NextIL
     96  20d1
     97  20d1					      endif
     98  20d1							;
     99  20d1							;=====================================================
    100  20d1				   iOPENWRITE
    101  20d1					      if	XKIM || CTMON65
    102  20d1		       20 8a 20 	      jsr	setFileName
    103  20d4		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  20d7		       90 07		      bcc	Wopenok	;branch if opened ok
    105  20d9							;
    106  20d9							; Open failed
    107  20d9							;
    108  20d9		       a9 00	   Wdfail     lda	#0
    109  20db		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  20dd		       4c a4 06 	      jmp	iErr2
    111  20e0							;
    112  20e0		       4c c2 02    Wopenok    jmp	NextIL
    113  20e3					      endif
    114  20e3							;
    115  20e3							;=====================================================
    116  20e3							; Gets a line of input from the disk file and puts it
    117  20e3							; into LINBUF.
    118  20e3							;
    119  20e3							; On exit:
    120  20e3							;    CURPTR points to LINBUF
    121  20e3							;    LINBUF contains the line with 0 at the end.
    122  20e3							;    Y has offset to first non-space character
    123  20e3							;    CURROFF has the same as Y.
    124  20e3							;
    125  20e3				   iDGETLINE
    126  20e3					      if	XKIM || CTMON65
    127  20e3		       a2 11		      ldx	#LINBUF&$ff
    128  20e5		       86 4f		      stx	CURPTR
    129  20e7		       a2 2f		      ldx	#LINBUF>>8
    130  20e9		       86 50		      stx	CURPTR+1
    131  20eb							;
    132  20eb		       a2 00		      ldx	#0	;offset
    133  20ed		       8e 95 2f    iDgetLoop  stx	getlinx
    134  20f0		       20 5b 21 	      jsr	getNextFileByte
    135  20f3		       b0 16		      bcs	iGetEOF
    136  20f5		       c9 0d		      cmp	#CR
    137  20f7		       f0 0d		      beq	iGetEOL
    138  20f9		       c9 0a		      cmp	#LF
    139  20fb		       f0 09		      beq	iGetEOL
    140  20fd		       ae 95 2f 	      ldx	getlinx
    141  2100		       9d 11 2f 	      sta	LINBUF,x
    142  2103		       e8		      inx
    143  2104		       d0 e7		      bne	iDgetLoop
    144  2106							;
    145  2106							; Handle end of line.	If the line has nothing, loop
    146  2106							; back and get another line.
    147  2106							;
    148  2106		       ae 95 2f    iGetEOL    ldx	getlinx	;blank line?
    149  2109		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  210b							;
    151  210b							; This can fall through when there is a line, or
    152  210b							; called directly when EOF is encountered.
    153  210b							;
    154  210b		       ae 95 2f    iGetEOF    ldx	getlinx
    155  210e		       a9 00		      lda	#0
    156  2110		       9d 11 2f 	      sta	LINBUF,x
    157  2113		       a0 00		      ldy	#0
    158  2115		       20 22 1e 	      jsr	SkipSpaces
    159  2118		       20 c3 10 	      jsr	ParseInputLine
    160  211b		       a9 c0		      lda	#TOKENBUFFER&$ff
    161  211d		       85 4f		      sta	CURPTR
    162  211f		       a9 0f		      lda	#TOKENBUFFER>>8
    163  2121		       85 50		      sta	CURPTR+1
    164  2123		       a9 01		      lda	#1
    165  2125		       85 51		      sta	CUROFF
    166  2127		       4c c2 02 	      jmp	NextIL
    167  212a					      endif
    168  212a
    169  212a							;
    170  212a							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  212a							; DISK
    172  212a							;
    173  212a				   iDDIR
    174  212a					      if	XKIM || CTMON65
    175  212a		       20 30 f0 	      jsr	DiskDir
    176  212d							;
    177  212d							; Get/Display each entry
    178  212d							;
    179  212d		       a2 26	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  212f		       a0 10		      ldy	#DiskFileName&$ff
    181  2131		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  2134		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  2136		       20 22 14 	      jsr	puts
      0  2139					      db	"   ",0
      1  2139		       20 20 20 00	      .byte.b	"   ",0
    185  213d							; Print the line to the console
    186  213d		       a2 26		      ldx	#DiskFileName>>8	;pointer to buffer
    187  213f		       a0 10		      ldy	#DiskFileName&$ff
    188  2141		       a5 00		      lda	0
    189  2143		       20 60 14 	      jsr	PrtStr	;else print name
    190  2146		       20 18 f0 	      jsr	crlf
    191  2149
    192  2149		       4c 2d 21 	      jmp	DiskDirLoop	;do next entry
    193  214c
    194  214c		       4c c2 02    DiskDirEnd jmp	NextIL
    195  214f					      endif
    196  214f							;
    197  214f							;=====================================================
    198  214f							; Does a LIST to a Disk file.
    199  214f							;
    200  214f				   iDLIST
    201  214f					      if	XKIM || CTMON65
    202  214f		       20 8a 21 	      jsr	SetOutDisk
    203  2152		       4c 22 08 	      jmp	iLST2
    204  2155					      endif
    205  2155							;
    206  2155							;=====================================================
    207  2155							; Closes any pending disk file.  Okay to call if there
    208  2155							; is no open file.
    209  2155							;
    210  2155				   iDCLOSE
    211  2155					      if	XKIM || CTMON65
    212  2155		       20 42 f0 	      jsr	DiskClose
    213  2158		       4c c2 02 	      jmp	NextIL
    214  215b					      endif
    215  215b							;
    216  215b							;=====================================================
    217  215b							; This gets the next byte from an open disk file.  If
    218  215b							; there are no more bytes left, this returns C set.
    219  215b							; Else, C is clear and A contains the character.
    220  215b							;
    221  215b				   getNextFileByte
    222  215b					      if	XKIM || CTMON65
    223  215b		       ae 0f 26 	      ldx	diskBufOffset
    224  215e		       ec 0e 26 	      cpx	diskBufLength
    225  2161		       d0 14		      bne	hasdata	;branch if still data
    226  2163							;
    227  2163							; There is no data left in the buffer, so read a
    228  2163							; block from the SD system.
    229  2163							;
    230  2163		       a9 84		      lda	#BUFFER_SIZE
    231  2165		       a2 df		      ldx	#buffer>>8
    232  2167		       a0 0a		      ldy	#buffer&$ff
    233  2169		       20 3c f0 	      jsr	DiskRead
    234  216c		       b0 12		      bcs	getNextEof
    235  216e							;
    236  216e							; A contains the number of bytes actually read.
    237  216e							;
    238  216e		       8d 0e 26 	      sta	diskBufLength	;save length
    239  2171		       c9 00		      cmp	#0	;shouldn't happen
    240  2173		       f0 0b		      beq	getNextEof
    241  2175							;
    242  2175		       a2 00		      ldx	#0
    243  2177		       bd 0a df    hasdata    lda	buffer,x
    244  217a		       e8		      inx
    245  217b		       8e 0f 26 	      stx	diskBufOffset
    246  217e		       18		      clc
    247  217f		       60		      rts
    248  2180							;
    249  2180		       a9 00	   getNextEof lda	#0
    250  2182		       8d 0f 26 	      sta	diskBufOffset
    251  2185		       8d 0e 26 	      sta	diskBufLength
    252  2188		       38		      sec
    253  2189		       60		      rts
    254  218a							;
    255  218a							;=====================================================
    256  218a							; Set output vector to the disk output function
    257  218a							;
    258  218a		       a9 95	   SetOutDisk lda	#DOUT&$ff
    259  218c		       8d a2 2f 	      sta	BOutVec
    260  218f		       a9 21		      lda	#DOUT/256
    261  2191		       8d a3 2f 	      sta	BOutVec+1
    262  2194		       60		      rts
    263  2195							;
    264  2195							;=====================================================
    265  2195
    266  2195		       8e 10 26    DOUT       stx	DiskFileName
    267  2198		       8c 11 26 	      sty	DiskFileName+1
    268  219b		       8d 0a df 	      sta	buffer
    269  219e		       a9 01		      lda	#1
    270  21a0		       a0 0a		      ldy	#buffer&$ff
    271  21a2		       a2 df		      ldx	#buffer>>8
    272  21a4		       20 3f f0 	      jsr	DiskWrite
    273  21a7		       ae 10 26 	      ldx	DiskFileName
    274  21aa		       ac 11 26 	      ldy	DiskFileName+1
    275  21ad
    276  21ad							;
    277  21ad							; need error checking here
    278  21ad							;
    279  21ad		       60		      rts
    280  21ae					      endif
    281  21ae
    282  21ae
------- FILE mytb.asm
   2380  21ae					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  21ae					      include	"IL.inc"
      1  21ae
      2  21ae							;=====================================================
      3  21ae							; IL.inc
      4  21ae							; These are macros for IL instructions
      5  21ae							;
      6  21ae					      mac	dw
      7  21ae					      .word	{0}
      8  21ae					      endm
      9  21ae					      mac	db
     10  21ae					      .byte	{0}
     11  21ae					      endm
     12  21ae					      macro	xinit
     13  21ae					      db	0
     14  21ae					      endm		;reset the il to start clear all
     15  21ae							;
     16  21ae					      macro	done
     17  21ae					      db	1
     18  21ae					      endm		;print an error if not end of line
     19  21ae							;
     20  21ae					      macro	prs
     21  21ae					      db	2
     22  21ae					      endm		;print a quoted string
     23  21ae							;
     24  21ae					      macro	prn
     25  21ae					      db	3
     26  21ae					      endm		;print a number
     27  21ae							;
     28  21ae					      macro	spc
     29  21ae					      db	4
     30  21ae					      endm		;print space til new tabstop
     31  21ae							;
     32  21ae					      macro	nline
     33  21ae					      db	5
     34  21ae					      endm		;print a new line crlf
     35  21ae							;
     36  21ae							; My NXT is a bit different in that it takes one
     37  21ae							; parameter, which is an address.  If the BASIC
     38  21ae							; program is currently running then move to the
     39  21ae							; next line and continue execution.  However, if
     40  21ae							; in direct mode, jump to the specified IL label.
     41  21ae							;
     42  21ae					      macro	nxt
     43  21ae					      db	6
     44  21ae					      dw	{1}	; addr
     45  21ae					      endm		; addr
     46  21ae							;
     47  21ae					      macro	xfer
     48  21ae					      db	7
     49  21ae					      endm
     50  21ae							;
     51  21ae					      macro	sav
     52  21ae					      db	8
     53  21ae					      db	{1}
     54  21ae					      endm
     55  21ae							;
     56  21ae							;  Passed jump if function called, and true false value returned
     57  21ae					      macro	rstr
     58  21ae					      db	9
     59  21ae					      db	({1}-*)-1	;(addr-*)-1
     60  21ae					      db	{2}
     61  21ae					      endm
     62  21ae							;
     63  21ae					      macro	cmpr
     64  21ae					      db	10
     65  21ae					      endm
     66  21ae							;
     67  21ae					      macro	innum
     68  21ae					      db	11
     69  21ae					      endm
     70  21ae							;
     71  21ae					      macro	fin
     72  21ae					      db	12
     73  21ae					      endm
     74  21ae							;
     75  21ae							; ERR is followed by an error number.	The error
     76  21ae							; code is printed along with the line number.
     77  21ae							; Control is passed to the statement set with
     78  21ae							; the ERRGOTO statement.
     79  21ae							;
     80  21ae					      macro	errmsg
     81  21ae					      db	13
     82  21ae					      dw	{1}	;ecode
     83  21ae					      endm		;ecode
     84  21ae							;
     85  21ae					      macro	add
     86  21ae					      db	14
     87  21ae					      endm
     88  21ae							;
     89  21ae					      macro	sub
     90  21ae					      db	15
     91  21ae					      endm
     92  21ae							;
     93  21ae					      macro	neg
     94  21ae					      db	16
     95  21ae					      endm
     96  21ae							;
     97  21ae					      macro	mul
     98  21ae					      db	17
     99  21ae					      endm
    100  21ae							;
    101  21ae					      macro	div
    102  21ae					      db	18
    103  21ae					      endm
    104  21ae							;
    105  21ae					      macro	store
    106  21ae					      db	19
    107  21ae					      endm
    108  21ae							;
    109  21ae					      macro	ind
    110  21ae					      db	20
    111  21ae					      endm
    112  21ae							;
    113  21ae					      macro	lst
    114  21ae					      db	21
    115  21ae					      endm
    116  21ae							;
    117  21ae					      macro	init
    118  21ae					      db	22
    119  21ae					      endm
    120  21ae							;
    121  21ae					      macro	getline
    122  21ae					      db	23
    123  21ae					      endm
    124  21ae							;
    125  21ae					      macro	insert
    126  21ae					      db	24
    127  21ae					      endm
    128  21ae							;
    129  21ae					      macro	rtn
    130  21ae					      db	25
    131  21ae					      endm
    132  21ae							;
    133  21ae					      macro	exit
    134  21ae					      db	26
    135  21ae					      endm
    136  21ae							;
    137  21ae					      macro	lit
    138  21ae					      db	27
    139  21ae					      dw	{1}	;value
    140  21ae					      endm		; value LIT
    141  21ae							;
    142  21ae					      macro	call
    143  21ae					      db	28
    144  21ae					      dw	{1}	;addr
    145  21ae					      endm		;addr
    146  21ae							;
    147  21ae							; IJMP will set the IL PC to the specified value.
    148  21ae							;
    149  21ae					      macro	ijmp
    150  21ae					      db	29
    151  21ae					      dw	{1}	;addr
    152  21ae					      endm		;addr
    153  21ae							;
    154  21ae					      macro	vinit
    155  21ae					      db	30
    156  21ae					      endm
    157  21ae							;
    158  21ae							; ERRGOTO sets the point in the code where the IL
    159  21ae							; interpreter will go after any error.
    160  21ae							;
    161  21ae					      macro	errgoto
    162  21ae					      db	31
    163  21ae					      dw	{1}	;addr
    164  21ae					      endm		;addr
    165  21ae							;
    166  21ae					      macro	tst
    167  21ae					      db	32
    168  21ae					      db	({1}-*)-1	;(addr-*)-1
    169  21ae					      db	{2},0	;string,0
    170  21ae					      endm		;addr,string
    171  21ae							;
    172  21ae					      macro	tstv
    173  21ae					      db	33
    174  21ae					      db	({1}-*)-1	;(addr-*)-1
    175  21ae					      endm		;addr
    176  21ae							;
    177  21ae					      macro	tstl
    178  21ae					      db	34
    179  21ae					      db	({1}-*)-1	;(addr-*)-1
    180  21ae					      endm		;addr
    181  21ae							;
    182  21ae					      macro	tstn
    183  21ae					      db	35
    184  21ae					      db	({1}-*)-1	;(addr-*)-1
    185  21ae					      endm		;addr
    186  21ae							;
    187  21ae							; FREE returns the amount of free RAM on top of
    188  21ae							; the stack.  This is the amount of room the user
    189  21ae							; program has available.
    190  21ae							;
    191  21ae					      macro	free
    192  21ae					      db	36
    193  21ae					      endm
    194  21ae							;
    195  21ae							; RANDOM takes the top item off the stack and
    196  21ae							; replaces it with a random number that is
    197  21ae							; MOD the initial value.  Ie, if the TOS is
    198  21ae							; 42 then RANDOM returns a value from 0 to 41.
    199  21ae							;
    200  21ae					      macro	random
    201  21ae					      db	37
    202  21ae					      endm
    203  21ae							;
    204  21ae							; ABS will replace the top of stack with the
    205  21ae							; absolute value.
    206  21ae							;
    207  21ae					      macro	abs
    208  21ae					      db	38
    209  21ae					      endm
    210  21ae							;
    211  21ae							; OPENREAD opens a file for reading, as in getting
    212  21ae							; statements from it.
    213  21ae							;
    214  21ae					      macro	openread
    215  21ae					      db	39
    216  21ae					      endm
    217  21ae							;
    218  21ae							; OPENWRITE opens a file for writing, as in saving
    219  21ae							; the current program to it.
    220  21ae							;
    221  21ae					      macro	openwrite
    222  21ae					      db	40
    223  21ae					      endm
    224  21ae							;
    225  21ae							; DCLOSE closes any open disk file.
    226  21ae							;
    227  21ae					      macro	dclose
    228  21ae					      db	41
    229  21ae					      endm
    230  21ae							;
    231  21ae							; DGETLINE gets one line from the disk file and puts it
    232  21ae							; into LINBUFF.
    233  21ae							;
    234  21ae					      macro	dgetline
    235  21ae					      db	42
    236  21ae					      endm
    237  21ae							;
    238  21ae							; DLIST saves the program to an open disk file.
    239  21ae							;
    240  21ae					      macro	dlist
    241  21ae					      db	43
    242  21ae					      endm
    243  21ae							; DDIR list the current directory
    244  21ae							;
    245  21ae					      macro	ddir
    246  21ae					      db	44
    247  21ae					      endm
    248  21ae
    249  21ae							; RMFILE remove a fle from disk
    250  21ae					      macro	rmfile
    251  21ae					      db	45
    252  21ae					      endm
    253  21ae
    254  21ae							; CLEARSCREEN clear the screen
    255  21ae					      macro	clearscreen
    256  21ae					      db	46
    257  21ae					      endm
    258  21ae							; POKEMEM Poke value into memory
    259  21ae					      macro	pokemem
    260  21ae					      db	47
    261  21ae					      endm
    262  21ae							; PEEKMEM peek at value in memory
    263  21ae					      macro	peekmem
    264  21ae					      db	48
    265  21ae					      endm
    266  21ae							; TSTLET Test if the statement is a let without the keyword let
    267  21ae					      macro	tstlet
    268  21ae					      db	49
    269  21ae					      db	({1}-*)-1	;(addr-*)-1
    270  21ae					      endm		;addr
    271  21ae							; TSTDONE if we reach the end of a statement
    272  21ae					      macro	tstdone
    273  21ae					      db	50
    274  21ae					      db	({1}-*)-1	;(addr-*)-1
    275  21ae					      endm		;addr
    276  21ae							; GETCHAR	get a character from the input line leave it in RO
    277  21ae					      macro	getchar
    278  21ae					      db	51
    279  21ae					      endm
    280  21ae							; PUTCHAR	Put a character to the terminal
    281  21ae					      macro	putchar
    282  21ae					      db	52
    283  21ae					      endm
    284  21ae							; Call		Call a machine function return a to stack
    285  21ae					      macro	callfunc
    286  21ae					      db	53
    287  21ae					      endm
    288  21ae
    289  21ae							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    290  21ae					      macro	ibranch
    291  21ae					      db	54
    292  21ae					      endm
    293  21ae
    294  21ae							; TSTSTR	 Tests for the open quote in a string
    295  21ae					      macro	tststr
    296  21ae					      db	55
    297  21ae					      db	({1}-*)-1	;(addr-*)-1
    298  21ae					      endm
    299  21ae							; SETIRQ	Sets the line number to run when an irq happens irq 550
    300  21ae					      macro	setirq
    301  21ae					      db	56
    302  21ae					      endm
    303  21ae
    304  21ae							; TSTIRQ	Test for irq pending,
    305  21ae							;		if so push the IRQ LINE NUMBER into RO, onto stack
    306  21ae					      macro	tstirq
    307  21ae					      db	57
    308  21ae					      db	({1}-*)-1	;(addr-*)-1
    309  21ae					      endm
    310  21ae
    311  21ae							; IRET    return from interupt service
    312  21ae					      macro	iret
    313  21ae					      db	58
    314  21ae					      endm
    315  21ae
    316  21ae							; INSTR   read a string from the input
    317  21ae					      macro	instr
    318  21ae					      db	59
    319  21ae					      endm
    320  21ae
    321  21ae							; MODULO Returns the remainder of the division
    322  21ae					      macro	modulo
    323  21ae					      db	60
    324  21ae					      endm
    325  21ae							; Set a task line
    326  21ae					      macro	taskcreate
    327  21ae					      db	61
    328  21ae					      endm
    329  21ae							; End a task
    330  21ae					      macro	etask
    331  21ae					      db	62
    332  21ae					      endm
    333  21ae							; Skip to next task
    334  21ae					      macro	ntask
    335  21ae					      db	63
    336  21ae					      endm
    337  21ae							; Subscript
    338  21ae					      macro	subscript
    339  21ae					      db	64
    340  21ae					      endm
    341  21ae							; KILL Task
    342  21ae					      macro	taskkill
    343  21ae					      db	65
    344  21ae					      endm
    345  21ae							; STAT Task
    346  21ae					      macro	taskstat
    347  21ae					      db	66
    348  21ae					      endm
    349  21ae							;  output value as hex
    350  21ae					      macro	hexprt
    351  21ae					      db	67
    352  21ae					      endm
    353  21ae							;  Read in background has completed
    354  21ae					      macro	readcomplete
    355  21ae					      db	68
    356  21ae					      endm
    357  21ae							;  ReadInput line
    358  21ae					      macro	readstart
    359  21ae					      db	69
    360  21ae					      endm
    361  21ae							; Startio request
    362  21ae					      macro	startio
    363  21ae					      db	70
    364  21ae					      endm
    365  21ae							; Endio
    366  21ae					      macro	endio
    367  21ae					      db	71
    368  21ae					      endm
    369  21ae							; Logical not
    370  21ae					      macro	lognot
    371  21ae					      db	72
    372  21ae					      endm
    373  21ae							; Logical OR
    374  21ae					      macro	logor
    375  21ae					      db	73
    376  21ae					      endm
    377  21ae							;Logical and
    378  21ae					      macro	logand
    379  21ae					      db	74
    380  21ae					      endm
    381  21ae							;Logical XOR
    382  21ae					      macro	logxor
    383  21ae					      db	75
    384  21ae					      endm
    385  21ae							;Wait for task to complete, or list of tasks
    386  21ae					      macro	wtask
    387  21ae					      db	76
    388  21ae					      db	({1}-*)-1	;(addr-*)-1
    389  21ae					      endm
    390  21ae							;Get the current task id
    391  21ae					      MACRO	taskpid
    392  21ae					      db	77
    393  21ae					      endm
    394  21ae							;Trace the basic execution
    395  21ae					      Macro	traceprogram
    396  21ae					      db	78
    397  21ae					      endm
    398  21ae							;Do a basic program Trace
    399  21ae					      Macro	debugbasic
    400  21ae					      db	79
    401  21ae					      endm
    402  21ae
    403  21ae							; Inter Process communications instructions
    404  21ae					      Macro	ipcsend
    405  21ae					      db	80
    406  21ae					      endm
    407  21ae					      Macro	ipcreceive
    408  21ae					      db	81
    409  21ae					      endm
    410  21ae					      Macro	ipccheck
    411  21ae					      db	82
    412  21ae					      endm
    413  21ae					      Macro	ipcio
    414  21ae					      db	83
    415  21ae					      endm
    416  21ae					      Macro	pushmathstack
    417  21ae					      db	84
    418  21ae					      endm
    419  21ae					      Macro	popmathstack
    420  21ae					      db	85
    421  21ae					      endm
    422  21ae					      Macro	savemathstack
    423  21ae					      db	86
    424  21ae					      endm
    425  21ae					      Macro	restoremathstack
    426  21ae					      db	87
    427  21ae					      endm
    428  21ae					      Macro	incparmcount
    429  21ae					      db	88
    430  21ae					      endm
    431  21ae					      Macro	taskgetmathstack
    432  21ae					      db	89
    433  21ae					      endm
    434  21ae					      Macro	taskenable
    435  21ae					      db	90
    436  21ae					      endm
    437  21ae					      Macro	tasksuspend
    438  21ae					      db	91
    439  21ae					      endm
    440  21ae					      Macro	taskputmathptr
    441  21ae					      db	92
    442  21ae					      endm
    443  21ae							; Test for an extension type of variable that allows access to a tasks variables
    444  21ae							; Using  PID!<Var name>
    445  21ae					      Macro	tstvt
    446  21ae					      db	93
    447  21ae					      db	({1}-*)-1	;(addr-*)-1
    448  21ae					      endm
    449  21ae
    450  21ae							; Provide access to R2 for the IL program
    451  21ae					      Macro	setr2
    452  21ae					      db	94
    453  21ae					      db	{1}	; R2 is only one byte
    454  21ae					      endm
    455  21ae							;Move stack top to temp
    456  21ae					      Macro	stk2tmp
    457  21ae					      db	95
    458  21ae					      endm
    459  21ae
    460  21ae					      Macro	tmp2stk
    461  21ae					      db	96
    462  21ae					      endm
    463  21ae
    464  21ae					      Macro	tstbyte
    465  21ae					      db	97
    466  21ae					      db	({1}-*)-1	; (addr-*)-1 goto if match
    467  21ae					      dw	{2}	; address to check
    468  21ae					      db	{3}	; Value to compare
    469  21ae					      endm
    470  21ae
    471  21ae					      Macro	incvar
    472  21ae					      db	98
    473  21ae					      endm
    474  21ae					      Macro	decvar
    475  21ae					      db	99
    476  21ae					      endm
    477  21ae
    478  21ae					      Macro	slice
    479  21ae					      db	100
    480  21ae					      endm
    481  21ae
    482  21ae					      Macro	tstb
    483  21ae					      db	101
    484  21ae					      db	({1}-*)-1
    485  21ae					      db	{2}
    486  21ae					      endm
    487  21ae
    488  21ae					      Macro	tstw
    489  21ae					      db	102
    490  21ae					      db	({1}-*)-1
    491  21ae					      dw	{2}
    492  21ae					      endm
    493  21ae
    494  21ae					      Macro	ongoto
    495  21ae					      db	103
    496  21ae					      dw	{1}
    497  21ae					      dw	{2}
    498  21ae					      endm
    499  21ae
    500  21ae					      Macro	tstrelop
    501  21ae					      db	104
    502  21ae					      db	({1}-*)-1
    503  21ae					      endm
    504  21ae
    505  21ae
    506  21ae					      Macro	repeatline
    507  21ae					      db	105
    508  21ae					      endm
    509  21ae
    510  21ae							; Check for a precompiled branch, will take branch if precompiled value present
    511  21ae					      Macro	tstbranch
    512  21ae					      db	106
    513  21ae					      db	({1}-*)-1
    514  21ae					      endm
    515  21ae
    516  21ae					      Macro	fastxfer
    517  21ae					      db	107
    518  21ae					      endm
------- FILE mytb.asm
   2382  21ae							;
   2383  21ae				  -	      if	FIXED
   2384  21ae				  -	      org	$1000
   2385  21ae					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  21ae					      include	"basic.il"
      1  21ae					      seg	Code
      2  21ae							; on goto table
      3  21ae							; format :   first byte is value Base, subtracted from value found
      4  21ae							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  21ae				   BasicStmts
      0  21ae					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  21ae		       01 1f		      .byte.b	kBeginKey,(kKeyCount+1)
      0  21b0					      dw	ekLet
      1  21b0		       2b 22		      .word.w	ekLet
      0  21b2					      dw	ekInc
      1  21b2		       56 22		      .word.w	ekInc
      0  21b4					      dw	ekDec
      1  21b4		       69 22		      .word.w	ekDec
      0  21b6					      dw	ekIreturn
      1  21b6		       7c 22		      .word.w	ekIreturn
      0  21b8					      dw	ekIf
      1  21b8		       84 22		      .word.w	ekIf
      0  21ba					      dw	ekThen
      1  21ba		       8a 22		      .word.w	ekThen
      0  21bc					      dw	ekGoto
      1  21bc		       91 22		      .word.w	ekGoto
      0  21be					      dw	ekGosub
      1  21be		       a8 22		      .word.w	ekGosub
      0  21c0					      dw	ekReturn
      1  21c0		       b2 22		      .word.w	ekReturn
      0  21c2					      dw	ekRem
      1  21c2		       d5 22		      .word.w	ekRem
      0  21c4					      dw	ekPrint	; should be entry for print
      1  21c4		       de 22		      .word.w	ekPrint
      0  21c6					      dw	ekTaske
      1  21c6		       2e 23		      .word.w	ekTaske
      0  21c8					      dw	ekTaskn
      1  21c8		       47 23		      .word.w	ekTaskn
      0  21ca					      dw	ekTaskw
      1  21ca		       51 23		      .word.w	ekTaskw
      0  21cc					      dw	ekPoke
      1  21cc		       6f 23		      .word.w	ekPoke
      0  21ce					      dw	ekPutch
      1  21ce		       89 23		      .word.w	ekPutch
      0  21d0					      dw	ekCls
      1  21d0		       97 23		      .word.w	ekCls
      0  21d2					      dw	ekInput
      1  21d2		       a1 23		      .word.w	ekInput
      0  21d4					      dw	ekEnd
      1  21d4		       c6 23		      .word.w	ekEnd
      0  21d6					      dw	ekIrq
      1  21d6		       cd 23		      .word.w	ekIrq
      0  21d8					      dw	ekKill
      1  21d8		       db 23		      .word.w	ekKill
      0  21da					      dw	ekList
      1  21da		       e9 23		      .word.w	ekList
      0  21dc					      dw	ekRun
      1  21dc		       f1 23		      .word.w	ekRun
      0  21de					      dw	ekNew
      1  21de		       fd 23		      .word.w	ekNew
      0  21e0					      dw	ekSlice
      1  21e0		       04 24		      .word.w	ekSlice
      0  21e2					      dw	ekTrace
      1  21e2		       12 24		      .word.w	ekTrace
      0  21e4					      dw	ekExit
      1  21e4		       26 24		      .word.w	ekExit
      0  21e6					      dw	ekSave
      1  21e6		       2a 24		      .word.w	ekSave
      0  21e8					      dw	ekLoad
      1  21e8		       33 24		      .word.w	ekLoad
      0  21ea					      dw	ekErase
      1  21ea		       49 24		      .word.w	ekErase
      0  21ec					      dw	ekDir
      1  21ec		       42 24		      .word.w	ekDir
     38  21ee							;
     39  21ee							; Logical operators
      0  21ee				   BasicLogical db	kNot,4
      1  21ee		       20 04		      .byte.b	kNot,4
      0  21f0					      dw	ekNot
      1  21f0		       54 24		      .word.w	ekNot
     42  21f2
      0  21f2					      dw	ekOr
      1  21f2		       67 24		      .word.w	ekOr
      0  21f4					      dw	ekXor
      1  21f4		       6f 24		      .word.w	ekXor
      0  21f6					      dw	ekAnd
      1  21f6		       5f 24		      .word.w	ekAnd
     46  21f8
     47  21f8							;functions returning values
     48  21f8
      0  21f8				   BasicFuncs db	kBeginFunc,kFuncCount
      1  21f8		       24 0e		      .byte.b	kBeginFunc,kFuncCount
      0  21fa					      dw	ekTrue
      1  21fa		       d2 24		      .word.w	ekTrue
      0  21fc					      dw	ekFalse
      1  21fc		       d9 24		      .word.w	ekFalse
      0  21fe					      dw	ekFree
      1  21fe		       e0 24		      .word.w	ekFree
      0  2200					      dw	ekGetch
      1  2200		       eb 24		      .word.w	ekGetch
      0  2202					      dw	ekPeek
      1  2202		       f6 24		      .word.w	ekPeek
      0  2204					      dw	ekTask
      1  2204		       04 25		      .word.w	ekTask
      0  2206					      dw	ekIpcc
      1  2206		       5a 25		      .word.w	ekIpcc
      0  2208					      dw	ekIpcs
      1  2208		       2e 25		      .word.w	ekIpcs
      0  220a					      dw	ekIpcr
      1  220a		       42 25		      .word.w	ekIpcr
      0  220c					      dw	ekRnd
      1  220c		       68 25		      .word.w	ekRnd
      0  220e					      dw	ekStat
      1  220e		       8c 25		      .word.w	ekStat
      0  2210					      dw	ekAbs
      1  2210		       7e 25		      .word.w	ekAbs
      0  2212					      dw	ekCall
      1  2212		       9f 25		      .word.w	ekCall
      0  2214					      dw	ekGofn
      1  2214		       bb 25		      .word.w	ekGofn
      0  2216					      dw	ekPid
      1  2216		       9a 25		      .word.w	ekPid
     65  2218
     66  2218
     67  2218							;=====================================================
     68  2218							; This is the IL of the BASIC (or whatever) language.
     69  2218							; Because of the way macros are implemented by as65,
     70  2218							; labels can't be on the same line as a macro
     71  2218							; invocation, so that's why labels are on separate
     72  2218							; lines.
     73  2218							;
     74  2218		       22 18	   IL	      equ	*
     75  2218
     76  2218							;THE IL CONTROL SECTION
     77  2218
     78  2218				   START
      0  2218					      INIT		;INITIALIZE
      0  2218					      db	22
      1  2218		       16		      .byte.b	22
      0  2219					      NLINE		;WRITE CRLF
      0  2219					      db	5
      1  2219		       05		      .byte.b	5
      0  221a					      ERRGOTO	CO	;where to go after an error
      0  221a					      db	31
      1  221a		       1f		      .byte.b	31
      0  221b					      dw	CO
      1  221b		       1e 22		      .word.w	CO
      0  221d					      VINIT		;clear all variables
      0  221d					      db	30
      1  221d		       1e		      .byte.b	30
     83  221e							;
     84  221e							; This is where we jump to get a line of commands or
     85  221e							; a program from the user.
     86  221e							;
     87  221e				   CO
      0  221e					      GETLINE		;WRITE PROMPT AND GET LINE
      0  221e					      db	23
      1  221e		       17		      .byte.b	23
      0  221f					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  221f					      db	34
      1  221f		       22		      .byte.b	34
      0  2220					      db	(XEC-*)-1
      1  2220		       04		      .byte.b	(XEC-*)-1
      0  2221					      INSERT		;INSERT IT (MAY BE DELETE)
      0  2221					      db	24
      1  2221		       18		      .byte.b	24
      0  2222					      IJMP	CO
      0  2222					      db	29
      1  2222		       1d		      .byte.b	29
      0  2223					      dw	CO
      1  2223		       1e 22		      .word.w	CO
     92  2225				   XEC
      0  2225					      XINIT		;INITIALIZE
      0  2225					      db	0
      1  2225		       00		      .byte.b	0
     94  2226							;============================================================================
     95  2226							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     96  2226							;
     97  2226				   STMT
      0  2226					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  2226					      db	79
      1  2226		       4f		      .byte.b	79
      0  2227					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  2227					      db	57
      1  2227		       39		      .byte.b	57
      0  2228					      db	(notirq-*)-1
      1  2228		       00		      .byte.b	(notirq-*)-1
    100  2229							;==========================================================================================
    101  2229							; Process a let statement implied or explicit.
    102  2229							;
    103  2229				   notirq
      0  2229					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  2229					      db	49
      1  2229		       31		      .byte.b	49
      0  222a					      db	(DoVector-*)-1
      1  222a		       23		      .byte.b	(DoVector-*)-1
    105  222b				   ekLet
      0  222b					      TSTV	ERRVEC2	; YES, PLACE VAR ADDRESS ON AESTK
      0  222b					      db	33
      1  222b		       21		      .byte.b	33
      0  222c					      db	(ERRVEC2-*)-1
      1  222c		       1e		      .byte.b	(ERRVEC2-*)-1
      0  222d					      TSTB	LETSQBRACKET,oEqual	; (This line originally omitted)
      0  222d					      db	101
      1  222d		       65		      .byte.b	101
      0  222e					      db	(LETSQBRACKET-*)-1
      1  222e		       04		      .byte.b	(LETSQBRACKET-*)-1
      0  222f					      db	oEqual
      1  222f		       f2		      .byte.b	oEqual
      0  2230					      IJMP	LETBE
      0  2230					      db	29
      1  2230		       1d		      .byte.b	29
      0  2231					      dw	LETBE
      1  2231		       40 22		      .word.w	LETBE
    109  2233
    110  2233				   LETSQBRACKET 		; is this an array access ?
    111  2233
      0  2233					      TSTB	ERRVEC2,oLeftSQBracket	; [
      0  2233					      db	101
      1  2233		       65		      .byte.b	101
      0  2234					      db	(ERRVEC2-*)-1
      1  2234		       16		      .byte.b	(ERRVEC2-*)-1
      0  2235					      db	oLeftSQBracket
      1  2235		       e4		      .byte.b	oLeftSQBracket
      0  2236					      CALL	EXPR
      0  2236					      db	28
      1  2236		       1c		      .byte.b	28
      0  2237					      dw	EXPR
      1  2237		       51 24		      .word.w	EXPR
      0  2239					      TSTB	ERRVEC2,oRightSQBracket	; ]
      0  2239					      db	101
      1  2239		       65		      .byte.b	101
      0  223a					      db	(ERRVEC2-*)-1
      1  223a		       10		      .byte.b	(ERRVEC2-*)-1
      0  223b					      db	oRightSQBracket
      1  223b		       e5		      .byte.b	oRightSQBracket
      0  223c					      SUBSCRIPT
      0  223c					      db	64
      1  223c		       40		      .byte.b	64
      0  223d					      TSTB	ERRVEC2,oEqual	; (This line originally omitted)
      0  223d					      db	101
      1  223d		       65		      .byte.b	101
      0  223e					      db	(ERRVEC2-*)-1
      1  223e		       0c		      .byte.b	(ERRVEC2-*)-1
      0  223f					      db	oEqual
      1  223f		       f2		      .byte.b	oEqual
    117  2240				   LETBE
    118  2240
      0  2240					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  2240					      db	28
      1  2240		       1c		      .byte.b	28
      0  2241					      dw	EXPR
      1  2241		       51 24		      .word.w	EXPR
      0  2243					      DONE		; REPORT ERROR IF NOT NEXT
      0  2243					      db	1
      1  2243		       01		      .byte.b	1
      0  2244					      STORE		; STORE RESULT
      0  2244					      db	19
      1  2244		       13		      .byte.b	19
      0  2245					      NXT	CO	; AND SEQUENCE TO NEXT
      0  2245					      db	6
      1  2245		       06		      .byte.b	6
      0  2246					      dw	CO
      1  2246		       1e 22		      .word.w	CO
      0  2248					      IJMP	STMT
      0  2248					      db	29
      1  2248		       1d		      .byte.b	29
      0  2249					      dw	STMT
      1  2249		       26 22		      .word.w	STMT
    124  224b				   ERRVEC2
      0  224b					      IJMP	UNKNOWN
      0  224b					      db	29
      1  224b		       1d		      .byte.b	29
      0  224c					      dw	UNKNOWN
      1  224c		       4d 24		      .word.w	UNKNOWN
    126  224e							;=============================================================
    127  224e							;Branch on a valid statement start
    128  224e				   DoVector
      0  224e					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  224e					      db	103
      1  224e		       67		      .byte.b	103
      0  224f					      dw	BasicStmts
      1  224f		       ae 21		      .word.w	BasicStmts
      0  2251					      dw	UNKNOWN
      1  2251		       4d 24		      .word.w	UNKNOWN
    130  2253							;This will never return here!
    131  2253							;=============================================================
    132  2253							; Inc or dec a variable
    133  2253				   S1
      0  2253					      TSTB	S1Dec,kInc	; Increment variable
      0  2253					      db	101
      1  2253		       65		      .byte.b	101
      0  2254					      db	(S1Dec-*)-1
      1  2254		       11		      .byte.b	(S1Dec-*)-1
      0  2255					      db	kInc
      1  2255		       02		      .byte.b	kInc
    135  2256				   ekInc
      0  2256					      TSTV	ERRVEC2	; Verify we have a variable
      0  2256					      db	33
      1  2256		       21		      .byte.b	33
      0  2257					      db	(ERRVEC2-*)-1
      1  2257		       f3		      .byte.b	(ERRVEC2-*)-1
      0  2258					      TSTB	eDoInc,oBang	; Allow to inc or dec other tasks variables
      0  2258					      db	101
      1  2258		       65		      .byte.b	101
      0  2259					      db	(eDoInc-*)-1
      1  2259		       04		      .byte.b	(eDoInc-*)-1
      0  225a					      db	oBang
      1  225a		       e8		      .byte.b	oBang
      0  225b					      IND		; we just got a pid
      0  225b					      db	20
      1  225b		       14		      .byte.b	20
      0  225c					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  225c					      db	93
      1  225c		       5d		      .byte.b	93
      0  225d					      db	(ERRVEC2-*)-1
      1  225d		       ed		      .byte.b	(ERRVEC2-*)-1
    140  225e				   eDoInc
      0  225e					      INCVAR		; Do the increment of the variable
      0  225e					      db	98
      1  225e		       62		      .byte.b	98
      0  225f					      DONE		; Test for end of line or end of statement ":"
      0  225f					      db	1
      1  225f		       01		      .byte.b	1
      0  2260					      NXT	CO	; Get the next statement, branch CO if end of program
      0  2260					      db	6
      1  2260		       06		      .byte.b	6
      0  2261					      dw	CO
      1  2261		       1e 22		      .word.w	CO
      0  2263					      IJMP	STMT	; Process the next statement
      0  2263					      db	29
      1  2263		       1d		      .byte.b	29
      0  2264					      dw	STMT
      1  2264		       26 22		      .word.w	STMT
    145  2266				   S1Dec
      0  2266					      TSTB	S1Iret,kDec	; Dec variable
      0  2266					      db	101
      1  2266		       65		      .byte.b	101
      0  2267					      db	(S1Iret-*)-1
      1  2267		       11		      .byte.b	(S1Iret-*)-1
      0  2268					      db	kDec
      1  2268		       03		      .byte.b	kDec
    147  2269				   ekDec
      0  2269					      TSTV	ERRVEC2	; Must be followed by a variable
      0  2269					      db	33
      1  2269		       21		      .byte.b	33
      0  226a					      db	(ERRVEC2-*)-1
      1  226a		       e0		      .byte.b	(ERRVEC2-*)-1
      0  226b					      TSTB	eDoDec,oBang	; Allow to inc or dec other tasks variables
      0  226b					      db	101
      1  226b		       65		      .byte.b	101
      0  226c					      db	(eDoDec-*)-1
      1  226c		       04		      .byte.b	(eDoDec-*)-1
      0  226d					      db	oBang
      1  226d		       e8		      .byte.b	oBang
      0  226e					      IND		; we just got a pid
      0  226e					      db	20
      1  226e		       14		      .byte.b	20
      0  226f					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  226f					      db	93
      1  226f		       5d		      .byte.b	93
      0  2270					      db	(ERRVEC2-*)-1
      1  2270		       da		      .byte.b	(ERRVEC2-*)-1
    152  2271				   eDoDec
      0  2271					      DECVAR		; Decrement the actual variable
      0  2271					      db	99
      1  2271		       63		      .byte.b	99
      0  2272					      DONE		; Test if end of line or : statement
      0  2272					      db	1
      1  2272		       01		      .byte.b	1
      0  2273					      NXT	CO	; If at end of program then got the console
      0  2273					      db	6
      1  2273		       06		      .byte.b	6
      0  2274					      dw	CO
      1  2274		       1e 22		      .word.w	CO
      0  2276					      IJMP	STMT	; Process the next statement of command line
      0  2276					      db	29
      1  2276		       1d		      .byte.b	29
      0  2277					      dw	STMT
      1  2277		       26 22		      .word.w	STMT
    157  2279							;=============================================================================================================================
    158  2279							; iret or ireturn, Return from interupt process
    159  2279							;
    160  2279				   S1Iret
      0  2279					      TSTB	S1S1,kIreturn	; test return from interupt
      0  2279					      db	101
      1  2279		       65		      .byte.b	101
      0  227a					      db	(S1S1-*)-1
      1  227a		       06		      .byte.b	(S1S1-*)-1
      0  227b					      db	kIreturn
      1  227b		       04		      .byte.b	kIreturn
    162  227c				   S1Sa
    163  227c				   ekIreturn
      0  227c					      DONE		; Must be only thing on the line
      0  227c					      db	1
      1  227c		       01		      .byte.b	1
      0  227d					      IRET		; RESTORE LINE NUMBER OF CALL
      0  227d					      db	58
      1  227d		       3a		      .byte.b	58
      0  227e					      IJMP	STMT
      0  227e					      db	29
      1  227e		       1d		      .byte.b	29
      0  227f					      dw	STMT
      1  227f		       26 22		      .word.w	STMT
    167  2281							;==============================================================================================================================
    168  2281							;Process if statement, if true then process all statements until end of line reached
    169  2281				   S1S1
      0  2281					      TSTB	S1Z,kIf	; IF STATEMENT
      0  2281					      db	101
      1  2281		       65		      .byte.b	101
      0  2282					      db	(S1Z-*)-1
      1  2282		       0b		      .byte.b	(S1Z-*)-1
      0  2283					      db	kIf
      1  2283		       05		      .byte.b	kIf
    171  2284				   ekIf
      0  2284					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  2284					      db	28
      1  2284		       1c		      .byte.b	28
      0  2285					      dw	EXPR
      1  2285		       51 24		      .word.w	EXPR
      0  2287					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  2287					      db	101
      1  2287		       65		      .byte.b	101
      0  2288					      db	(S1W-*)-1
      1  2288		       01		      .byte.b	(S1W-*)-1
      0  2289					      db	kThen
      1  2289		       06		      .byte.b	kThen
    174  228a				   ekThen
    175  228a				   S1W
      0  228a					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  228a					      db	54
      1  228a		       36		      .byte.b	54
      0  228b					      IJMP	STMT
      0  228b					      db	29
      1  228b		       1d		      .byte.b	29
      0  228c					      dw	STMT
      1  228c		       26 22		      .word.w	STMT
    178  228e							;===============================================================================================================================
    179  228e							; Test for GOTO
    180  228e				   S1Z
      0  228e					      TSTB	S2,kGoto	; YES...TO, OR...SUB
      0  228e					      db	101
      1  228e		       65		      .byte.b	101
      0  228f					      db	(S2-*)-1
      1  228f		       15		      .byte.b	(S2-*)-1
      0  2290					      db	kGoto
      1  2290		       07		      .byte.b	kGoto
    182  2291
    183  2291				   ekGoto
      0  2291					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  2291					      db	106
      1  2291		       6a		      .byte.b	106
      0  2292					      db	(ekGotoCompiled-*)-1
      1  2292		       0e		      .byte.b	(ekGotoCompiled-*)-1
    185  2293							; Else we have the address ad just goto that address
      0  2293					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  2293					      db	101
      1  2293		       65		      .byte.b	101
      0  2294					      db	(ekGotoLine-*)-1
      1  2294		       05		      .byte.b	(ekGotoLine-*)-1
      0  2295					      db	oPeriod
      1  2295		       e9		      .byte.b	oPeriod
      0  2296					      REPEATLINE		; Repeat the same line again
      0  2296					      db	105
      1  2296		       69		      .byte.b	105
      0  2297					      IJMP	STMT	; Go do the statement
      0  2297					      db	29
      1  2297		       1d		      .byte.b	29
      0  2298					      dw	STMT
      1  2298		       26 22		      .word.w	STMT
    189  229a
    190  229a				   ekGotoLine
      0  229a					      CALL	EXPR	; GET LABEL
      0  229a					      db	28
      1  229a		       1c		      .byte.b	28
      0  229b					      dw	EXPR
      1  229b		       51 24		      .word.w	EXPR
      0  229d					      lit	0	; Place indicator for line num on stack
      0  229d					      db	27
      1  229d		       1b		      .byte.b	27
      0  229e					      dw	0
      1  229e		       00 00		      .word.w	0
      0  22a0					      FASTXFER
      0  22a0					      db	107
      1  22a0		       6b		      .byte.b	107
    194  22a1				   ekGotoCompiled
      0  22a1					      lit	1	; tell it that mempointer on the stack
      0  22a1					      db	27
      1  22a1		       1b		      .byte.b	27
      0  22a2					      dw	1
      1  22a2		       01 00		      .word.w	1
      0  22a4					      FASTXFER		; put top of stack into curptr
      0  22a4					      db	107
      1  22a4		       6b		      .byte.b	107
    197  22a5
    198  22a5							;===============================================================================================================================
    199  22a5							; Process gosub / function
    200  22a5							;
    201  22a5				   S2
      0  22a5					      TSTB	S2b,kGosub	; ERROR IF NO MATCH
      0  22a5					      db	101
      1  22a5		       65		      .byte.b	101
      0  22a6					      db	(S2b-*)-1
      1  22a6		       08		      .byte.b	(S2b-*)-1
      0  22a7					      db	kGosub
      1  22a7		       08		      .byte.b	kGosub
    203  22a8				   ekGosub
      0  22a8					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  22a8					      db	28
      1  22a8		       1c		      .byte.b	28
      0  22a9					      dw	GOSUBSTATEMENT
      1  22a9		       e7 25		      .word.w	GOSUBSTATEMENT
      0  22ab					      DONE		; ERROR IF CR NOT NEXT
      0  22ab					      db	1
      1  22ab		       01		      .byte.b	1
      0  22ac					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  22ac					      db	8
      1  22ac		       08		      .byte.b	8
      0  22ad					      db	GOSUB_RTN
      1  22ad		       01		      .byte.b	GOSUB_RTN
      0  22ae					      FASTXFER		; AND JUMP to sub rtn
      0  22ae					      db	107
      1  22ae		       6b		      .byte.b	107
    208  22af							;
    209  22af							; End of gosub processing
    210  22af							;===============================================================================================================================
    211  22af							; Return from a gosub
    212  22af				   S2b
      0  22af					      TSTB	S2a,kReturn	; Speed up pocessing but more memory
      0  22af					      db	101
      1  22af		       65		      .byte.b	101
      0  22b0					      db	(S2a-*)-1
      1  22b0		       21		      .byte.b	(S2a-*)-1
      0  22b1					      db	kReturn
      1  22b1		       09		      .byte.b	kReturn
    214  22b2				   ekReturn
      0  22b2					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  22b2					      db	101
      1  22b2		       65		      .byte.b	101
      0  22b3					      db	(S2NoReturnValue-*)-1
      1  22b3		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  22b4					      db	oLeftBracket
      1  22b4		       e0		      .byte.b	oLeftBracket
      0  22b5					      CALL	EXPR
      0  22b5					      db	28
      1  22b5		       1c		      .byte.b	28
      0  22b6					      dw	EXPR
      1  22b6		       51 24		      .word.w	EXPR
      0  22b8					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  22b8					      db	101
      1  22b8		       65		      .byte.b	101
      0  22b9					      db	(ERRVEC2-*)-1
      1  22b9		       91		      .byte.b	(ERRVEC2-*)-1
      0  22ba					      db	oRightBracket
      1  22ba		       e1		      .byte.b	oRightBracket
      0  22bb					      DONE
      0  22bb					      db	1
      1  22bb		       01		      .byte.b	1
      0  22bc					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  22bc					      db	9
      1  22bc		       09		      .byte.b	9
      0  22bd					      db	(S2RetFunc-*)-1
      1  22bd		       11		      .byte.b	(S2RetFunc-*)-1
      0  22be					      db	1
      1  22be		       01		      .byte.b	1
      0  22bf					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  22bf					      db	6
      1  22bf		       06		      .byte.b	6
      0  22c0					      dw	CO
      1  22c0		       1e 22		      .word.w	CO
      0  22c2					      IJMP	STMT	; Process the new statement
      0  22c2					      db	29
      1  22c2		       1d		      .byte.b	29
      0  22c3					      dw	STMT
      1  22c3		       26 22		      .word.w	STMT
    222  22c5
    223  22c5				   S2NoReturnValue
      0  22c5					      DONE
      0  22c5					      db	1
      1  22c5		       01		      .byte.b	1
      0  22c6					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  22c6					      db	9
      1  22c6		       09		      .byte.b	9
      0  22c7					      db	(S2RetFunc-*)-1
      1  22c7		       07		      .byte.b	(S2RetFunc-*)-1
      0  22c8					      db	0
      1  22c8		       00		      .byte.b	0
      0  22c9					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  22c9					      db	6
      1  22c9		       06		      .byte.b	6
      0  22ca					      dw	CO
      1  22ca		       1e 22		      .word.w	CO
      0  22cc					      IJMP	STMT	; Process the new statement
      0  22cc					      db	29
      1  22cc		       1d		      .byte.b	29
      0  22cd					      dw	STMT
      1  22cd		       26 22		      .word.w	STMT
    228  22cf
    229  22cf				   S2RetFunc
      0  22cf					      IJMP	GOFNRet	; Back into the Function
      0  22cf					      db	29
      1  22cf		       1d		      .byte.b	29
      0  22d0					      dw	GOFNRet
      1  22d0		       c1 25		      .word.w	GOFNRet
    231  22d2							;
    232  22d2							; End of return from gosub
    233  22d2							;==================================================================================================================================
    234  22d2							; Process REM statement
    235  22d2							;
    236  22d2				   S2a
      0  22d2					      TSTB	S3,kRem	; REMark.  Skip rest of line
      0  22d2					      db	101
      1  22d2		       65		      .byte.b	101
      0  22d3					      db	(S3-*)-1
      1  22d3		       07		      .byte.b	(S3-*)-1
      0  22d4					      db	kRem
      1  22d4		       0a		      .byte.b	kRem
    238  22d5				   ekRem
      0  22d5					      NXT	CO	; The rest of the line is ignored
      0  22d5					      db	6
      1  22d5		       06		      .byte.b	6
      0  22d6					      dw	CO
      1  22d6		       1e 22		      .word.w	CO
      0  22d8					      IJMP	STMT	; Process the next statement
      0  22d8					      db	29
      1  22d8		       1d		      .byte.b	29
      0  22d9					      dw	STMT
      1  22d9		       26 22		      .word.w	STMT
    241  22db							;==================================================================================================================================
    242  22db							; Print statement
    243  22db							;
    244  22db				   S3
      0  22db					      TSTB	S8,kPrint	; ? or Print symonym for print
      0  22db					      db	101
      1  22db		       65		      .byte.b	101
      0  22dc					      db	(S8-*)-1
      1  22dc		       4e		      .byte.b	(S8-*)-1
      0  22dd					      db	kPrint
      1  22dd		       0b		      .byte.b	kPrint
    246  22de				   ekPrint
      0  22de					      STARTIO		; Lock task until io completes
      0  22de					      db	70
      1  22de		       46		      .byte.b	70
    248  22df				   S4
      0  22df					      TSTDONE	S4a	; Test if we just want crlf printed
      0  22df					      db	50
      1  22df		       32		      .byte.b	50
      0  22e0					      db	(S4a-*)-1
      1  22e0		       03		      .byte.b	(S4a-*)-1
      0  22e1					      IJMP	S6
      0  22e1					      db	29
      1  22e1		       1d		      .byte.b	29
      0  22e2					      dw	S6
      1  22e2		       f9 22		      .word.w	S6
    251  22e4
    252  22e4				   S4a
      0  22e4					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  22e4					      db	101
      1  22e4		       65		      .byte.b	101
      0  22e5					      db	(S7-*)-1
      1  22e5		       1f		      .byte.b	(S7-*)-1
      0  22e6					      db	tString
      1  22e6		       a0		      .byte.b	tString
      0  22e7					      PRS		; PRINT STRING
      0  22e7					      db	2
      1  22e7		       02		      .byte.b	2
    255  22e8				   S5
      0  22e8					      TSTB	S6A,oComma	; IS THERE MORE?
      0  22e8					      db	101
      1  22e8		       65		      .byte.b	101
      0  22e9					      db	(S6A-*)-1
      1  22e9		       07		      .byte.b	(S6A-*)-1
      0  22ea					      db	oComma
      1  22ea		       e2		      .byte.b	oComma
      0  22eb					      SPC		; SPACE TO NEXT ZONE
      0  22eb					      db	4
      1  22eb		       04		      .byte.b	4
      0  22ec					      TSTDONE	S4	; Not end of line jump back
      0  22ec					      db	50
      1  22ec		       32		      .byte.b	50
      0  22ed					      db	(S4-*)-1
      1  22ed		       f1		      .byte.b	(S4-*)-1
      0  22ee					      IJMP	S6Z	; YES JUMP BACK
      0  22ee					      db	29
      1  22ee		       1d		      .byte.b	29
      0  22ef					      dw	S6Z
      1  22ef		       fb 22		      .word.w	S6Z
    260  22f1
    261  22f1							;
    262  22f1							; If a semicolon, don't do anything.
    263  22f1							;
    264  22f1				   S6A
      0  22f1					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  22f1					      db	101
      1  22f1		       65		      .byte.b	101
      0  22f2					      db	(S6-*)-1
      1  22f2		       06		      .byte.b	(S6-*)-1
      0  22f3					      db	oSemiColon
      1  22f3		       e3		      .byte.b	oSemiColon
      0  22f4					      TSTDONE	S4	; Jump Back if not end of line
      0  22f4					      db	50
      1  22f4		       32		      .byte.b	50
      0  22f5					      db	(S4-*)-1
      1  22f5		       e9		      .byte.b	(S4-*)-1
      0  22f6					      IJMP	S6Z
      0  22f6					      db	29
      1  22f6		       1d		      .byte.b	29
      0  22f7					      dw	S6Z
      1  22f7		       fb 22		      .word.w	S6Z
    268  22f9
    269  22f9				   S6
    270  22f9
      0  22f9					      DONE		; ERROR IF CR NOT NEXT
      0  22f9					      db	1
      1  22f9		       01		      .byte.b	1
      0  22fa					      NLINE
      0  22fa					      db	5
      1  22fa		       05		      .byte.b	5
    273  22fb				   S6Z
      0  22fb					      ENDIO		; release task io completed
      0  22fb					      db	71
      1  22fb		       47		      .byte.b	71
      0  22fc					      NXT	CO	; exit here if , or ; at end of print
      0  22fc					      db	6
      1  22fc		       06		      .byte.b	6
      0  22fd					      dw	CO
      1  22fd		       1e 22		      .word.w	CO
      0  22ff					      IJMP	STMT
      0  22ff					      db	29
      1  22ff		       1d		      .byte.b	29
      0  2300					      dw	STMT
      1  2300		       26 22		      .word.w	STMT
    277  2302							;
    278  2302							; A jump for code too far away for relative branch
    279  2302							;
    280  2302				   ERRVEC
      0  2302					      IJMP	UNKNOWN
      0  2302					      db	29
      1  2302		       1d		      .byte.b	29
      0  2303					      dw	UNKNOWN
      1  2303		       4d 24		      .word.w	UNKNOWN
    282  2305							;
    283  2305							; Get here if there is an expression to print
    284  2305				   S7
      0  2305					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  2305					      db	101
      1  2305		       65		      .byte.b	101
      0  2306					      db	(S7AUnsigned-*)-1
      1  2306		       08		      .byte.b	(S7AUnsigned-*)-1
      0  2307					      db	oDollar
      1  2307		       e7		      .byte.b	oDollar
      0  2308					      CALL	EXPR
      0  2308					      db	28
      1  2308		       1c		      .byte.b	28
      0  2309					      dw	EXPR
      1  2309		       51 24		      .word.w	EXPR
      0  230b					      HEXPRT
      0  230b					      db	67
      1  230b		       43		      .byte.b	67
      0  230c					      IJMP	S5
      0  230c					      db	29
      1  230c		       1d		      .byte.b	29
      0  230d					      dw	S5
      1  230d		       e8 22		      .word.w	S5
    289  230f
    290  230f				   S7AUnsigned
    291  230f
      0  230f					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  230f					      db	101
      1  230f		       65		      .byte.b	101
      0  2310					      db	(S7A-*)-1
      1  2310		       0a		      .byte.b	(S7A-*)-1
      0  2311					      db	oPercent
      1  2311		       ed		      .byte.b	oPercent
      0  2312					      CALL	EXPR
      0  2312					      db	28
      1  2312		       1c		      .byte.b	28
      0  2313					      dw	EXPR
      1  2313		       51 24		      .word.w	EXPR
      0  2315					      SETR2	1
      0  2315					      db	94
      1  2315		       5e		      .byte.b	94
      0  2316					      db	1
      1  2316		       01		      .byte.b	1
      0  2317					      PRN
      0  2317					      db	3
      1  2317		       03		      .byte.b	3
      0  2318					      IJMP	S5
      0  2318					      db	29
      1  2318		       1d		      .byte.b	29
      0  2319					      dw	S5
      1  2319		       e8 22		      .word.w	S5
    297  231b
    298  231b				   S7A
    299  231b
      0  231b					      CALL	EXPR
      0  231b					      db	28
      1  231b		       1c		      .byte.b	28
      0  231c					      dw	EXPR
      1  231c		       51 24		      .word.w	EXPR
      0  231e					      TSTB	S7B,oDollar	; Print the value as a single character
      0  231e					      db	101
      1  231e		       65		      .byte.b	101
      0  231f					      db	(S7B-*)-1
      1  231f		       05		      .byte.b	(S7B-*)-1
      0  2320					      db	oDollar
      1  2320		       e7		      .byte.b	oDollar
      0  2321					      PUTCHAR
      0  2321					      db	52
      1  2321		       34		      .byte.b	52
      0  2322					      IJMP	S5
      0  2322					      db	29
      1  2322		       1d		      .byte.b	29
      0  2323					      dw	S5
      1  2323		       e8 22		      .word.w	S5
    304  2325
    305  2325				   S7B
      0  2325					      SETR2	0	; Print the value as a signed number
      0  2325					      db	94
      1  2325		       5e		      .byte.b	94
      0  2326					      db	0
      1  2326		       00		      .byte.b	0
      0  2327					      PRN		; PRINT IT
      0  2327					      db	3
      1  2327		       03		      .byte.b	3
      0  2328					      IJMP	S5	; IS THERE MORE?
      0  2328					      db	29
      1  2328		       1d		      .byte.b	29
      0  2329					      dw	S5
      1  2329		       e8 22		      .word.w	S5
    309  232b							;
    310  232b							;===========================================================
    311  232b							; PROCESS ALL THE TAST STATEMENTS
    312  232b							;
    313  232b				   S8
      0  232b					      TSTB	S8G,kTaske	; End Task
      0  232b					      db	101
      1  232b		       65		      .byte.b	101
      0  232c					      db	(S8G-*)-1
      1  232c		       17		      .byte.b	(S8G-*)-1
      0  232d					      db	kTaske
      1  232d		       0c		      .byte.b	kTaske
    315  232e				   ekTaske
      0  232e					      TSTB	S8NoParm,oLeftBracket
      0  232e					      db	101
      1  232e		       65		      .byte.b	101
      0  232f					      db	(S8NoParm-*)-1
      1  232f		       0c		      .byte.b	(S8NoParm-*)-1
      0  2330					      db	oLeftBracket
      1  2330		       e0		      .byte.b	oLeftBracket
      0  2331					      CALL	EXPR
      0  2331					      db	28
      1  2331		       1c		      .byte.b	28
      0  2332					      dw	EXPR
      1  2332		       51 24		      .word.w	EXPR
      0  2334					      TSTB	UNKNOWNLnk,oRightBracket
      0  2334					      db	101
      1  2334		       65		      .byte.b	101
      0  2335					      db	(UNKNOWNLnk-*)-1
      1  2335		       33		      .byte.b	(UNKNOWNLnk-*)-1
      0  2336					      db	oRightBracket
      1  2336		       e1		      .byte.b	oRightBracket
      0  2337					      ETASK
      0  2337					      db	62
      1  2337		       3e		      .byte.b	62
      0  2338					      DONE
      0  2338					      db	1
      1  2338		       01		      .byte.b	1
      0  2339					      IJMP	STMT
      0  2339					      db	29
      1  2339		       1d		      .byte.b	29
      0  233a					      dw	STMT
      1  233a		       26 22		      .word.w	STMT
    322  233c				   S8NoParm
      0  233c					      LIT	0
      0  233c					      db	27
      1  233c		       1b		      .byte.b	27
      0  233d					      dw	0
      1  233d		       00 00		      .word.w	0
      0  233f					      ETASK
      0  233f					      db	62
      1  233f		       3e		      .byte.b	62
      0  2340					      DONE		; Must be last thing on a line
      0  2340					      db	1
      1  2340		       01		      .byte.b	1
      0  2341					      IJMP	STMT
      0  2341					      db	29
      1  2341		       1d		      .byte.b	29
      0  2342					      dw	STMT
      1  2342		       26 22		      .word.w	STMT
    327  2344							;
    328  2344							;===========================================================
    329  2344							; The task gives up the rest of the cycles
    330  2344				   S8G
      0  2344					      TSTB	S8a,kTaskn	;Next task
      0  2344					      db	101
      1  2344		       65		      .byte.b	101
      0  2345					      db	(S8a-*)-1
      1  2345		       08		      .byte.b	(S8a-*)-1
      0  2346					      db	kTaskn
      1  2346		       0d		      .byte.b	kTaskn
    332  2347				   ekTaskn
      0  2347					      NTASK
      0  2347					      db	63
      1  2347		       3f		      .byte.b	63
      0  2348					      NXT	CO	;Next statement to execute
      0  2348					      db	6
      1  2348		       06		      .byte.b	6
      0  2349					      dw	CO
      1  2349		       1e 22		      .word.w	CO
      0  234b					      IJMP	STMT
      0  234b					      db	29
      1  234b		       1d		      .byte.b	29
      0  234c					      dw	STMT
      1  234c		       26 22		      .word.w	STMT
    336  234e							;
    337  234e							;===========================================================
    338  234e							; Waits for a task or list of tasks to complete
    339  234e				   S8a
      0  234e					      TSTB	S8a1,kTaskw	;Wait for tasks
      0  234e					      db	101
      1  234e		       65		      .byte.b	101
      0  234f					      db	(S8a1-*)-1
      1  234f		       1c		      .byte.b	(S8a1-*)-1
      0  2350					      db	kTaskw
      1  2350		       0e		      .byte.b	kTaskw
    341  2351				   ekTaskw
      0  2351					      TSTB	UNKNOWNLnk,oLeftBracket
      0  2351					      db	101
      1  2351		       65		      .byte.b	101
      0  2352					      db	(UNKNOWNLnk-*)-1
      1  2352		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  2353					      db	oLeftBracket
      1  2353		       e0		      .byte.b	oLeftBracket
    343  2354				   S8TSK
      0  2354					      Call	EXPR	;Gets the PID of task to wait for
      0  2354					      db	28
      1  2354		       1c		      .byte.b	28
      0  2355					      dw	EXPR
      1  2355		       51 24		      .word.w	EXPR
    345  2357				   S8LOOP
      0  2357					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  2357					      db	76
      1  2357		       4c		      .byte.b	76
      0  2358					      db	(S8LOOP-*)-1
      1  2358		       fe		      .byte.b	(S8LOOP-*)-1
      0  2359					      TSTB	S8aa,oComma	;Checks for more tasks
      0  2359					      db	101
      1  2359		       65		      .byte.b	101
      0  235a					      db	(S8aa-*)-1
      1  235a		       04		      .byte.b	(S8aa-*)-1
      0  235b					      db	oComma
      1  235b		       e2		      .byte.b	oComma
      0  235c					      IJMP	S8TSK	;Go for the next task number
      0  235c					      db	29
      1  235c		       1d		      .byte.b	29
      0  235d					      dw	S8TSK
      1  235d		       54 23		      .word.w	S8TSK
    349  235f				   S8aa
      0  235f					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  235f					      db	101
      1  235f		       65		      .byte.b	101
      0  2360					      db	(UNKNOWNLnk-*)-1
      1  2360		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  2361					      db	oRightBracket
      1  2361		       e1		      .byte.b	oRightBracket
      0  2362					      DONE
      0  2362					      db	1
      1  2362		       01		      .byte.b	1
      0  2363					      NXT	CO
      0  2363					      db	6
      1  2363		       06		      .byte.b	6
      0  2364					      dw	CO
      1  2364		       1e 22		      .word.w	CO
      0  2366					      IJMP	STMT	;Next Statement
      0  2366					      db	29
      1  2366		       1d		      .byte.b	29
      0  2367					      dw	STMT
      1  2367		       26 22		      .word.w	STMT
    354  2369
    355  2369
    356  2369
    357  2369				   UNKNOWNLnk
      0  2369					      iJMP	UNKNOWN
      0  2369					      db	29
      1  2369		       1d		      .byte.b	29
      0  236a					      dw	UNKNOWN
      1  236a		       4d 24		      .word.w	UNKNOWN
    359  236c
    360  236c							;
    361  236c							;===========================================================
    362  236c							; Update a memory location with a value
    363  236c							;  Use @[offset] to write a word value to memory
    364  236c							;
    365  236c				   S8a1
      0  236c					      TSTB	S8b,kPoke	; Poke a value into memory
      0  236c					      db	101
      1  236c		       65		      .byte.b	101
      0  236d					      db	(S8b-*)-1
      1  236d		       18		      .byte.b	(S8b-*)-1
      0  236e					      db	kPoke
      1  236e		       0f		      .byte.b	kPoke
    367  236f				   ekPoke
      0  236f					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  236f					      db	101
      1  236f		       65		      .byte.b	101
      0  2370					      db	(UNKNOWNV-*)-1
      1  2370		       56		      .byte.b	(UNKNOWNV-*)-1
      0  2371					      db	oLeftBracket
      1  2371		       e0		      .byte.b	oLeftBracket
      0  2372					      CALL	EXPR	; Get address to write to
      0  2372					      db	28
      1  2372		       1c		      .byte.b	28
      0  2373					      dw	EXPR
      1  2373		       51 24		      .word.w	EXPR
      0  2375					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  2375					      db	101
      1  2375		       65		      .byte.b	101
      0  2376					      db	(UNKNOWNV-*)-1
      1  2376		       50		      .byte.b	(UNKNOWNV-*)-1
      0  2377					      db	oComma
      1  2377		       e2		      .byte.b	oComma
      0  2378					      CALL	EXPR	; Get the value to poke
      0  2378					      db	28
      1  2378		       1c		      .byte.b	28
      0  2379					      dw	EXPR
      1  2379		       51 24		      .word.w	EXPR
      0  237b					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  237b					      db	101
      1  237b		       65		      .byte.b	101
      0  237c					      db	(UNKNOWNV-*)-1
      1  237c		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  237d					      db	oRightBracket
      1  237d		       e1		      .byte.b	oRightBracket
      0  237e					      POKEMEM
      0  237e					      db	47
      1  237e		       2f		      .byte.b	47
      0  237f					      DONE
      0  237f					      db	1
      1  237f		       01		      .byte.b	1
      0  2380					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2380					      db	6
      1  2380		       06		      .byte.b	6
      0  2381					      dw	CO
      1  2381		       1e 22		      .word.w	CO
      0  2383					      IJMP	STMT
      0  2383					      db	29
      1  2383		       1d		      .byte.b	29
      0  2384					      dw	STMT
      1  2384		       26 22		      .word.w	STMT
    377  2386							;================================================================
    378  2386							; Write a single byte to the output device
    379  2386							;
    380  2386				   S8b
      0  2386					      TSTB	S8c,kPutch	;Put a char to the terminal
      0  2386					      db	101
      1  2386		       65		      .byte.b	101
      0  2387					      db	(S8c-*)-1
      1  2387		       0c		      .byte.b	(S8c-*)-1
      0  2388					      db	kPutch
      1  2388		       10		      .byte.b	kPutch
    382  2389				   ekPutch
      0  2389					      CALL	EXPR
      0  2389					      db	28
      1  2389		       1c		      .byte.b	28
      0  238a					      dw	EXPR
      1  238a		       51 24		      .word.w	EXPR
      0  238c					      PUTCHAR
      0  238c					      db	52
      1  238c		       34		      .byte.b	52
      0  238d					      DONE
      0  238d					      db	1
      1  238d		       01		      .byte.b	1
      0  238e					      NXT	CO	;AND SEQUENCE TO NEXT
      0  238e					      db	6
      1  238e		       06		      .byte.b	6
      0  238f					      dw	CO
      1  238f		       1e 22		      .word.w	CO
      0  2391					      IJMP	STMT
      0  2391					      db	29
      1  2391		       1d		      .byte.b	29
      0  2392					      dw	STMT
      1  2392		       26 22		      .word.w	STMT
    388  2394							;================================================================
    389  2394							; Clear the screen lines
    390  2394							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    391  2394							;
    392  2394				   S8c
      0  2394					      TSTB	S9,kCls	;Clear the screen
      0  2394					      db	101
      1  2394		       65		      .byte.b	101
      0  2395					      db	(S9-*)-1
      1  2395		       08		      .byte.b	(S9-*)-1
      0  2396					      db	kCls
      1  2396		       11		      .byte.b	kCls
    394  2397				   ekCls
      0  2397					      CLEARSCREEN
      0  2397					      db	46
      1  2397		       2e		      .byte.b	46
      0  2398					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2398					      db	6
      1  2398		       06		      .byte.b	6
      0  2399					      dw	CO
      1  2399		       1e 22		      .word.w	CO
      0  239b					      IJMP	STMT
      0  239b					      db	29
      1  239b		       1d		      .byte.b	29
      0  239c					      dw	STMT
      1  239c		       26 22		      .word.w	STMT
    398  239e							;==================================================================
    399  239e							; Get input from the terminal
    400  239e							;   Reads from the currently active input device
    401  239e							;
    402  239e				   S9
      0  239e					      TSTB	S13,kInput	;INPUT STATEMENT
      0  239e					      db	101
      1  239e		       65		      .byte.b	101
      0  239f					      db	(S13-*)-1
      1  239f		       23		      .byte.b	(S13-*)-1
      0  23a0					      db	kInput
      1  23a0		       12		      .byte.b	kInput
    404  23a1				   ekInput
    405  23a1				   S10
      0  23a1					      TSTB	S10A,tString	;If there is a string print the prompt
      0  23a1					      db	101
      1  23a1		       65		      .byte.b	101
      0  23a2					      db	(S10A-*)-1
      1  23a2		       05		      .byte.b	(S10A-*)-1
      0  23a3					      db	tString
      1  23a3		       a0		      .byte.b	tString
      0  23a4					      PRS
      0  23a4					      db	2
      1  23a4		       02		      .byte.b	2
      0  23a5					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  23a5					      db	101
      1  23a5		       65		      .byte.b	101
      0  23a6					      db	(S10Z-*)-1
      1  23a6		       12		      .byte.b	(S10Z-*)-1
      0  23a7					      db	oSemiColon
      1  23a7		       e3		      .byte.b	oSemiColon
    409  23a8				   S10A
      0  23a8					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  23a8					      db	33
      1  23a8		       21		      .byte.b	33
      0  23a9					      db	(UNKNOWN-*)-1
      1  23a9		       a3		      .byte.b	(UNKNOWN-*)-1
      0  23aa					      TSTB	S10A1,oDollar
      0  23aa					      db	101
      1  23aa		       65		      .byte.b	101
      0  23ab					      db	(S10A1-*)-1
      1  23ab		       05		      .byte.b	(S10A1-*)-1
      0  23ac					      db	oDollar
      1  23ac		       e7		      .byte.b	oDollar
      0  23ad					      INSTR		;Move character From tty to AESTK
      0  23ad					      db	59
      1  23ad		       3b		      .byte.b	59
      0  23ae					      IJMP	S10A2
      0  23ae					      db	29
      1  23ae		       1d		      .byte.b	29
      0  23af					      dw	S10A2
      1  23af		       b2 23		      .word.w	S10A2
    414  23b1				   S10A1
      0  23b1					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  23b1					      db	11
      1  23b1		       0b		      .byte.b	11
    416  23b2				   S10A2
      0  23b2					      STORE		;STORE IT
      0  23b2					      db	19
      1  23b2		       13		      .byte.b	19
      0  23b3					      TSTB	S11,oComma	;IS THERE MORE?
      0  23b3					      db	101
      1  23b3		       65		      .byte.b	101
      0  23b4					      db	(S11-*)-1
      1  23b4		       07		      .byte.b	(S11-*)-1
      0  23b5					      db	oComma
      1  23b5		       e2		      .byte.b	oComma
      0  23b6					      IJMP	S10	;YES
      0  23b6					      db	29
      1  23b6		       1d		      .byte.b	29
      0  23b7					      dw	S10
      1  23b7		       a1 23		      .word.w	S10
    420  23b9				   S10Z
      0  23b9					      iJMP	UNKNOWN
      0  23b9					      db	29
      1  23b9		       1d		      .byte.b	29
      0  23ba					      dw	UNKNOWN
      1  23ba		       4d 24		      .word.w	UNKNOWN
    422  23bc				   S11
      0  23bc					      DONE		;MUST BE CR
      0  23bc					      db	1
      1  23bc		       01		      .byte.b	1
      0  23bd					      NXT	CO	;SEQUENCE TO NEXT
      0  23bd					      db	6
      1  23bd		       06		      .byte.b	6
      0  23be					      dw	CO
      1  23be		       1e 22		      .word.w	CO
      0  23c0					      IJMP	STMT
      0  23c0					      db	29
      1  23c0		       1d		      .byte.b	29
      0  23c1					      dw	STMT
      1  23c1		       26 22		      .word.w	STMT
    426  23c3							;=====================================================================
    427  23c3							; End of program, return to command line process
    428  23c3							; Main Task may also use taske or return to stopped
    429  23c3							;
    430  23c3				   S13
      0  23c3					      TSTB	S14,kEnd
      0  23c3					      db	101
      1  23c3		       65		      .byte.b	101
      0  23c4					      db	(S14-*)-1
      1  23c4		       05		      .byte.b	(S14-*)-1
      0  23c5					      db	kEnd
      1  23c5		       13		      .byte.b	kEnd
    432  23c6				   ekEnd
      0  23c6					      FIN
      0  23c6					      db	12
      1  23c6		       0c		      .byte.b	12
    434  23c7
    435  23c7				   UNKNOWNV
      0  23c7					      IJMP	UNKNOWN
      0  23c7					      db	29
      1  23c7		       1d		      .byte.b	29
      0  23c8					      dw	UNKNOWN
      1  23c8		       4d 24		      .word.w	UNKNOWN
    437  23ca							;====================================================================
    438  23ca							; IRQ <IRQ-HANDLER-Line expression>
    439  23ca							;   Specify a line number subroutine to call when an interupt is processed
    440  23ca							;   These subroutines must use iret to return.
    441  23ca							;
    442  23ca				   S14
      0  23ca					      TSTB	S14Z,kIrq	;Check if we are setting IRQ HANDLER
      0  23ca					      db	101
      1  23ca		       65		      .byte.b	101
      0  23cb					      db	(S14Z-*)-1
      1  23cb		       0c		      .byte.b	(S14Z-*)-1
      0  23cc					      db	kIrq
      1  23cc		       14		      .byte.b	kIrq
    444  23cd				   ekIrq
      0  23cd					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  23cd					      db	28
      1  23cd		       1c		      .byte.b	28
      0  23ce					      dw	EXPR
      1  23ce		       51 24		      .word.w	EXPR
      0  23d0					      DONE		;must be CR
      0  23d0					      db	1
      1  23d0		       01		      .byte.b	1
      0  23d1					      SETIRQ		;Set the line number now
      0  23d1					      db	56
      1  23d1		       38		      .byte.b	56
      0  23d2					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  23d2					      db	6
      1  23d2		       06		      .byte.b	6
      0  23d3					      dw	CO
      1  23d3		       1e 22		      .word.w	CO
      0  23d5					      IJMP	STMT
      0  23d5					      db	29
      1  23d5		       1d		      .byte.b	29
      0  23d6					      dw	STMT
      1  23d6		       26 22		      .word.w	STMT
    450  23d8
    451  23d8							;=========================================================================
    452  23d8							; KILL PID-expression	 kill a running task
    453  23d8							;  ignored of task has already stopped
    454  23d8							;
    455  23d8				   S14Z
      0  23d8					      TSTB	S14S1,kKill	; Kill A running Task
      0  23d8					      db	101
      1  23d8		       65		      .byte.b	101
      0  23d9					      db	(S14S1-*)-1
      1  23d9		       0c		      .byte.b	(S14S1-*)-1
      0  23da					      db	kKill
      1  23da		       15		      .byte.b	kKill
    457  23db				   ekKill
      0  23db					      CALL	EXPR
      0  23db					      db	28
      1  23db		       1c		      .byte.b	28
      0  23dc					      dw	EXPR
      1  23dc		       51 24		      .word.w	EXPR
      0  23de					      DONE
      0  23de					      db	1
      1  23de		       01		      .byte.b	1
      0  23df					      TASKKILL
      0  23df					      db	65
      1  23df		       41		      .byte.b	65
      0  23e0					      NXT	CO
      0  23e0					      db	6
      1  23e0		       06		      .byte.b	6
      0  23e1					      dw	CO
      1  23e1		       1e 22		      .word.w	CO
      0  23e3					      IJMP	STMT
      0  23e3					      db	29
      1  23e3		       1d		      .byte.b	29
      0  23e4					      dw	STMT
      1  23e4		       26 22		      .word.w	STMT
    463  23e6
    464  23e6							;============================================================================
    465  23e6							; List all program lines
    466  23e6							;
    467  23e6				   S14S1
      0  23e6					      TSTB	S15,kList	;LIST COMMAND
      0  23e6					      db	101
      1  23e6		       65		      .byte.b	101
      0  23e7					      db	(S15-*)-1
      1  23e7		       06		      .byte.b	(S15-*)-1
      0  23e8					      db	kList
      1  23e8		       16		      .byte.b	kList
    469  23e9				   ekList
      0  23e9					      DONE
      0  23e9					      db	1
      1  23e9		       01		      .byte.b	1
      0  23ea					      LST
      0  23ea					      db	21
      1  23ea		       15		      .byte.b	21
      0  23eb					      IJMP	CO
      0  23eb					      db	29
      1  23eb		       1d		      .byte.b	29
      0  23ec					      dw	CO
      1  23ec		       1e 22		      .word.w	CO
    473  23ee							;=======================================================================
    474  23ee							;RUN begin to executed the program in memory
    475  23ee							;
    476  23ee				   S15
      0  23ee					      TSTB	S16,kRun	;RUN COMMAND
      0  23ee					      db	101
      1  23ee		       65		      .byte.b	101
      0  23ef					      db	(S16-*)-1
      1  23ef		       0a		      .byte.b	(S16-*)-1
      0  23f0					      db	kRun
      1  23f0		       17		      .byte.b	kRun
    478  23f1				   ekRun
      0  23f1					      DONE
      0  23f1					      db	1
      1  23f1		       01		      .byte.b	1
      0  23f2					      VINIT		;clear variables compile the line numbers
      0  23f2					      db	30
      1  23f2		       1e		      .byte.b	30
      0  23f3					      LIT	1	;GOTO line 1
      0  23f3					      db	27
      1  23f3		       1b		      .byte.b	27
      0  23f4					      dw	1
      1  23f4		       01 00		      .word.w	1
      0  23f6					      XFER		;Bob's addition
      0  23f6					      db	7
      1  23f6		       07		      .byte.b	7
    483  23f7							; EXIT
      0  23f7					      IJMP	STMT	;and run!
      0  23f7					      db	29
      1  23f7		       1d		      .byte.b	29
      0  23f8					      dw	STMT
      1  23f8		       26 22		      .word.w	STMT
    485  23fa							;=========================================================================
    486  23fa							;Clear the program memory, delete all proram lines
    487  23fa							;
    488  23fa				   S16
      0  23fa					      TSTB	S16A,kNew	;clear program
      0  23fa					      db	101
      1  23fa		       65		      .byte.b	101
      0  23fb					      db	(S16A-*)-1
      1  23fb		       05		      .byte.b	(S16A-*)-1
      0  23fc					      db	kNew
      1  23fc		       18		      .byte.b	kNew
    490  23fd				   ekNew
      0  23fd					      DONE
      0  23fd					      db	1
      1  23fd		       01		      .byte.b	1
      0  23fe					      IJMP	START
      0  23fe					      db	29
      1  23fe		       1d		      .byte.b	29
      0  23ff					      dw	START
      1  23ff		       18 22		      .word.w	START
    493  2401
    494  2401							;========================================================================
    495  2401							; Slice(slice legth expression)
    496  2401							;   set the length of time between task switches
    497  2401							;
    498  2401				   S16A
      0  2401					      TSTB	S16Trace,kSlice
      0  2401					      db	101
      1  2401		       65		      .byte.b	101
      0  2402					      db	(S16Trace-*)-1
      1  2402		       0c		      .byte.b	(S16Trace-*)-1
      0  2403					      db	kSlice
      1  2403		       19		      .byte.b	kSlice
    500  2404				   ekSlice
      0  2404					      CALL	EXPR
      0  2404					      db	28
      1  2404		       1c		      .byte.b	28
      0  2405					      dw	EXPR
      1  2405		       51 24		      .word.w	EXPR
      0  2407					      SLICE
      0  2407					      db	100
      1  2407		       64		      .byte.b	100
      0  2408					      DONE
      0  2408					      db	1
      1  2408		       01		      .byte.b	1
      0  2409					      NXT	CO
      0  2409					      db	6
      1  2409		       06		      .byte.b	6
      0  240a					      dw	CO
      1  240a		       1e 22		      .word.w	CO
      0  240c					      IJMP	STMT
      0  240c					      db	29
      1  240c		       1d		      .byte.b	29
      0  240d					      dw	STMT
      1  240d		       26 22		      .word.w	STMT
    506  240f							;==========================================================================
    507  240f							; Turn off and on the thrace functions
    508  240f							; a debug terminal needs to be available
    509  240f							; Trace( Trace flag expression)
    510  240f							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    511  240f							;	for individual lines of basic code. These can be combined
    512  240f				   S16Trace
      0  240f					      TSTB	S17A,kTrace
      0  240f					      db	101
      1  240f		       65		      .byte.b	101
      0  2410					      db	(S17A-*)-1
      1  2410		       12		      .byte.b	(S17A-*)-1
      0  2411					      db	kTrace
      1  2411		       1a		      .byte.b	kTrace
    514  2412				   ekTrace
      0  2412					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  2412					      db	101
      1  2412		       65		      .byte.b	101
      0  2413					      db	(UNKNOWN-*)-1
      1  2413		       39		      .byte.b	(UNKNOWN-*)-1
      0  2414					      db	oLeftBracket
      1  2414		       e0		      .byte.b	oLeftBracket
      0  2415					      CALL	EXPR
      0  2415					      db	28
      1  2415		       1c		      .byte.b	28
      0  2416					      dw	EXPR
      1  2416		       51 24		      .word.w	EXPR
      0  2418					      TSTB	UNKNOWN,oRightBracket
      0  2418					      db	101
      1  2418		       65		      .byte.b	101
      0  2419					      db	(UNKNOWN-*)-1
      1  2419		       33		      .byte.b	(UNKNOWN-*)-1
      0  241a					      db	oRightBracket
      1  241a		       e1		      .byte.b	oRightBracket
      0  241b					      TRACEPROGRAM
      0  241b					      db	78
      1  241b		       4e		      .byte.b	78
      0  241c					      DONE
      0  241c					      db	1
      1  241c		       01		      .byte.b	1
      0  241d					      NXT	CO
      0  241d					      db	6
      1  241d		       06		      .byte.b	6
      0  241e					      dw	CO
      1  241e		       1e 22		      .word.w	CO
      0  2420					      IJMP	STMT
      0  2420					      db	29
      1  2420		       1d		      .byte.b	29
      0  2421					      dw	STMT
      1  2421		       26 22		      .word.w	STMT
    522  2423							;=====================================================================
    523  2423							; Exit basic to machine monitor
    524  2423							;
    525  2423				   S17A
      0  2423					      TSTB	S17B,kExit	;allow them to exit BASIC
      0  2423					      db	101
      1  2423		       65		      .byte.b	101
      0  2424					      db	(S17B-*)-1
      1  2424		       02		      .byte.b	(S17B-*)-1
      0  2425					      db	kExit
      1  2425		       1b		      .byte.b	kExit
    527  2426				   ekExit
      0  2426					      EXIT
      0  2426					      db	26
      1  2426		       1a		      .byte.b	26
    529  2427
    530  2427							;=======================================================================
    531  2427							; Commands related to saving/restoring programs
    532  2427							; to/from mass storage.
    533  2427							;
    534  2427				   S17B
    535  2427					      if	(XKIM || CTMON65) && DISK_ACCESS
    536  2427
      0  2427					      TSTB	S17C,kSave
      0  2427					      db	101
      1  2427		       65		      .byte.b	101
      0  2428					      db	(S17C-*)-1
      1  2428		       07		      .byte.b	(S17C-*)-1
      0  2429					      db	kSave
      1  2429		       1c		      .byte.b	kSave
    538  242a				   ekSave
      0  242a					      OPENWRITE
      0  242a					      db	40
      1  242a		       28		      .byte.b	40
      0  242b					      DLIST
      0  242b					      db	43
      1  242b		       2b		      .byte.b	43
      0  242c					      DCLOSE
      0  242c					      db	41
      1  242c		       29		      .byte.b	41
      0  242d					      IJMP	CO
      0  242d					      db	29
      1  242d		       1d		      .byte.b	29
      0  242e					      dw	CO
      1  242e		       1e 22		      .word.w	CO
    543  2430
    544  2430				   S17C
      0  2430					      TSTB	S18,kLoad
      0  2430					      db	101
      1  2430		       65		      .byte.b	101
      0  2431					      db	(S18-*)-1
      1  2431		       0d		      .byte.b	(S18-*)-1
      0  2432					      db	kLoad
      1  2432		       1d		      .byte.b	kLoad
    546  2433				   ekLoad
      0  2433					      OPENREAD
      0  2433					      db	39
      1  2433		       27		      .byte.b	39
    548  2434				   S17CLP
      0  2434					      DGETLINE		;get line from file
      0  2434					      db	42
      1  2434		       2a		      .byte.b	42
      0  2435					      TSTL	S17EOL	;no line num means EOL
      0  2435					      db	34
      1  2435		       22		      .byte.b	34
      0  2436					      db	(S17EOL-*)-1
      1  2436		       04		      .byte.b	(S17EOL-*)-1
      0  2437					      INSERT		;put it into the program
      0  2437					      db	24
      1  2437		       18		      .byte.b	24
      0  2438					      IJMP	S17CLP	;keep going
      0  2438					      db	29
      1  2438		       1d		      .byte.b	29
      0  2439					      dw	S17CLP
      1  2439		       34 24		      .word.w	S17CLP
    553  243b				   S17EOL
      0  243b					      DCLOSE		;close disk file
      0  243b					      db	41
      1  243b		       29		      .byte.b	41
      0  243c					      IJMP	CO	;back to start
      0  243c					      db	29
      1  243c		       1d		      .byte.b	29
      0  243d					      dw	CO
      1  243d		       1e 22		      .word.w	CO
    556  243f
    557  243f				   S18
      0  243f					      TSTB	S19,kDir
      0  243f					      db	101
      1  243f		       65		      .byte.b	101
      0  2440					      db	(S19-*)-1
      1  2440		       05		      .byte.b	(S19-*)-1
      0  2441					      db	kDir
      1  2441		       1f		      .byte.b	kDir
    559  2442				   ekDir
      0  2442					      DDIR		;Display the directory content
      0  2442					      db	44
      1  2442		       2c		      .byte.b	44
      0  2443					      IJMP	CO
      0  2443					      db	29
      1  2443		       1d		      .byte.b	29
      0  2444					      dw	CO
      1  2444		       1e 22		      .word.w	CO
    562  2446							;=========================================================================
    563  2446							; Erase a file from disk
    564  2446							;
      0  2446				   S19	      TSTB	UNKNOWN,kErase
      0  2446					      db	101
      1  2446		       65		      .byte.b	101
      0  2447					      db	(UNKNOWN-*)-1
      1  2447		       05		      .byte.b	(UNKNOWN-*)-1
      0  2448					      db	kErase
      1  2448		       1e		      .byte.b	kErase
    566  2449				   ekErase
      0  2449					      RMFILE		;Erase the file from the disk
      0  2449					      db	45
      1  2449		       2d		      .byte.b	45
      0  244a					      IJMP	CO
      0  244a					      db	29
      1  244a		       1d		      .byte.b	29
      0  244b					      dw	CO
      1  244b		       1e 22		      .word.w	CO
    569  244d
    570  244d					      endif
    571  244d
    572  244d							;
    573  244d							; Else, unknown command.
    574  244d							;
    575  244d				   UNKNOWN
      0  244d					      ENDIO
      0  244d					      db	71
      1  244d		       47		      .byte.b	71
    577  244e
    578  244e				   NotKnownStatement
    579  244e
      0  244e					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  244e					      db	13
      1  244e		       0d		      .byte.b	13
      0  244f					      dw	ERR_SYNTAX
      1  244f		       05 00		      .word.w	ERR_SYNTAX
    581  2451
    582  2451							;=======================================================
    583  2451							; Process Expresions, precidence is represented by the
    584  2451							; various call levels
    585  2451							;
    586  2451				   EXPR
      0  2451					      TSTB	EXPRLOGS,kNot
      0  2451					      db	101
      1  2451		       65		      .byte.b	101
      0  2452					      db	(EXPRLOGS-*)-1
      1  2452		       06		      .byte.b	(EXPRLOGS-*)-1
      0  2453					      db	kNot
      1  2453		       20		      .byte.b	kNot
    588  2454				   ekNot
      0  2454					      Call	EXPR
      0  2454					      db	28
      1  2454		       1c		      .byte.b	28
      0  2455					      dw	EXPR
      1  2455		       51 24		      .word.w	EXPR
      0  2457					      LOGNOT
      0  2457					      db	72
      1  2457		       48		      .byte.b	72
      0  2458					      RTN
      0  2458					      db	25
      1  2458		       19		      .byte.b	25
    592  2459
    593  2459							;=========================================================
    594  2459							;Look for logical operators
    595  2459				   EXPRLOGS
      0  2459					      Call	EXPRCMP
      0  2459					      db	28
      1  2459		       1c		      .byte.b	28
      0  245a					      dw	EXPRCMP
      1  245a		       74 24		      .word.w	EXPRCMP
      0  245c					      TSTB	iLOG1,kAnd
      0  245c					      db	101
      1  245c		       65		      .byte.b	101
      0  245d					      db	(iLOG1-*)-1
      1  245d		       06		      .byte.b	(iLOG1-*)-1
      0  245e					      db	kAnd
      1  245e		       23		      .byte.b	kAnd
    598  245f				   ekAnd
      0  245f					      Call	EXPR
      0  245f					      db	28
      1  245f		       1c		      .byte.b	28
      0  2460					      dw	EXPR
      1  2460		       51 24		      .word.w	EXPR
      0  2462					      LOGAND
      0  2462					      db	74
      1  2462		       4a		      .byte.b	74
      0  2463					      RTN
      0  2463					      db	25
      1  2463		       19		      .byte.b	25
    602  2464				   iLOG1
      0  2464					      TSTB	iLOG2,kOr
      0  2464					      db	101
      1  2464		       65		      .byte.b	101
      0  2465					      db	(iLOG2-*)-1
      1  2465		       06		      .byte.b	(iLOG2-*)-1
      0  2466					      db	kOr
      1  2466		       21		      .byte.b	kOr
    604  2467				   ekOr
      0  2467					      Call	EXPR
      0  2467					      db	28
      1  2467		       1c		      .byte.b	28
      0  2468					      dw	EXPR
      1  2468		       51 24		      .word.w	EXPR
      0  246a					      LOGOR
      0  246a					      db	73
      1  246a		       49		      .byte.b	73
      0  246b					      RTN
      0  246b					      db	25
      1  246b		       19		      .byte.b	25
    608  246c				   iLOG2
      0  246c					      TSTB	iLOG3,kXor
      0  246c					      db	101
      1  246c		       65		      .byte.b	101
      0  246d					      db	(iLOG3-*)-1
      1  246d		       05		      .byte.b	(iLOG3-*)-1
      0  246e					      db	kXor
      1  246e		       22		      .byte.b	kXor
    610  246f				   ekXor
      0  246f					      Call	EXPR
      0  246f					      db	28
      1  246f		       1c		      .byte.b	28
      0  2470					      dw	EXPR
      1  2470		       51 24		      .word.w	EXPR
      0  2472					      LOGXOR
      0  2472					      db	75
      1  2472		       4b		      .byte.b	75
    613  2473				   iLOG3
      0  2473					      RTN
      0  2473					      db	25
      1  2473		       19		      .byte.b	25
    615  2474
    616  2474				   EXPRCMP
      0  2474					      Call	EXPR2	; get the first expression
      0  2474					      db	28
      1  2474		       1c		      .byte.b	28
      0  2475					      dw	EXPR2
      1  2475		       7f 24		      .word.w	EXPR2
      0  2477					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  2477					      db	104
      1  2477		       68		      .byte.b	104
      0  2478					      db	(iRDone-*)-1
      1  2478		       05		      .byte.b	(iRDone-*)-1
    619  2479							;	  TSTB	     iR0,oEqual
    620  2479							;	  LIT	     2		     ;=
    621  2479							;	  IJMP	     iRFound
    622  2479							;iR0:
    623  2479							;	  TSTB	      iR1,oLessEqual
    624  2479							;	  LIT	      3 	      ;<=
    625  2479							;	  IJMP	     iRFound
    626  2479							;iR1:
    627  2479							;	  TSTB	     iR3,oNotEqual
    628  2479							;	  LIT	     5		      ;<>
    629  2479							;	      IJMP	  iRFound
    630  2479							;iR3:
    631  2479							;	  TSTB	     iR4,oLess
    632  2479							;	  LIT	     1		     ;<
    633  2479							;	      IJMP	  iRFound
    634  2479							;iR4:
    635  2479							;	  TST	     iR5,oGreaterEqual
    636  2479							;	  LIT	     6		     ;>=
    637  2479							;	      IJMP	  iRFound
    638  2479							;iR5:
    639  2479							;	  TSTB	     iRDone,oGreater
    640  2479							;	  LIT	     4		     ;>
    641  2479				   iRFound
      0  2479					      Call	EXPR	; get the right side of the expression
      0  2479					      db	28
      1  2479		       1c		      .byte.b	28
      0  247a					      dw	EXPR
      1  247a		       51 24		      .word.w	EXPR
      0  247c					      CMPR		; Push the value of the true false onto the stack
      0  247c					      db	10
      1  247c		       0a		      .byte.b	10
      0  247d					      RTN
      0  247d					      db	25
      1  247d		       19		      .byte.b	25
    645  247e
    646  247e				   iRDone
      0  247e					      RTN
      0  247e					      db	25
      1  247e		       19		      .byte.b	25
    648  247f
    649  247f				   EXPR2
      0  247f					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  247f					      db	101
      1  247f		       65		      .byte.b	101
      0  2480					      db	(E0-*)-1
      1  2480		       08		      .byte.b	(E0-*)-1
      0  2481					      db	oMinus
      1  2481		       eb		      .byte.b	oMinus
      0  2482					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  2482					      db	28
      1  2482		       1c		      .byte.b	28
      0  2483					      dw	TERM
      1  2483		       a5 24		      .word.w	TERM
      0  2485					      NEG		; Make value negated
      0  2485					      db	16
      1  2485		       10		      .byte.b	16
      0  2486					      IJMP	E1	; We have Left term process operators next
      0  2486					      db	29
      1  2486		       1d		      .byte.b	29
      0  2487					      dw	E1
      1  2487		       8f 24		      .word.w	E1
    654  2489				   E0
      0  2489					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  2489					      db	101
      1  2489		       65		      .byte.b	101
      0  248a					      db	(E1A-*)-1
      1  248a		       01		      .byte.b	(E1A-*)-1
      0  248b					      db	oPlus
      1  248b		       ea		      .byte.b	oPlus
    656  248c				   E1A
      0  248c					      CALL	TERM	; Get the left term if it was not negated
      0  248c					      db	28
      1  248c		       1c		      .byte.b	28
      0  248d					      dw	TERM
      1  248d		       a5 24		      .word.w	TERM
    658  248f				   E1
      0  248f					      TST	E2,oPlus	; Check if we are adding left term to something
      0  248f					      db	32
      1  248f		       20		      .byte.b	32
      0  2490					      db	(E2-*)-1
      1  2490		       09		      .byte.b	(E2-*)-1
      0  2491					      db	oPlus,0
      1  2491		       ea 00		      .byte.b	oPlus,0
      0  2493					      CALL	TERM	; if adding then get the right side term
      0  2493					      db	28
      1  2493		       1c		      .byte.b	28
      0  2494					      dw	TERM
      1  2494		       a5 24		      .word.w	TERM
      0  2496					      ADD		; Add it to left term
      0  2496					      db	14
      1  2496		       0e		      .byte.b	14
      0  2497					      IJMP	E1	; look for next + or -
      0  2497					      db	29
      1  2497		       1d		      .byte.b	29
      0  2498					      dw	E1
      1  2498		       8f 24		      .word.w	E1
    663  249a				   E2
      0  249a					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  249a					      db	101
      1  249a		       65		      .byte.b	101
      0  249b					      db	(E3-*)-1
      1  249b		       08		      .byte.b	(E3-*)-1
      0  249c					      db	oMinus
      1  249c		       eb		      .byte.b	oMinus
      0  249d					      CALL	TERM	; get right side to subtract Diffrence
      0  249d					      db	28
      1  249d		       1c		      .byte.b	28
      0  249e					      dw	TERM
      1  249e		       a5 24		      .word.w	TERM
      0  24a0					      SUB		; Subtract the value
      0  24a0					      db	15
      1  24a0		       0f		      .byte.b	15
      0  24a1					      IJMP	E1	; Look for next + or -
      0  24a1					      db	29
      1  24a1		       1d		      .byte.b	29
      0  24a2					      dw	E1
      1  24a2		       8f 24		      .word.w	E1
    668  24a4				   E3			; Finish processing the expression
      0  24a4					      RTN		; We are finished processing the Expression
      0  24a4					      db	25
      1  24a4		       19		      .byte.b	25
    670  24a5							;
    671  24a5							; Get one of the terms of an expression
    672  24a5							;
    673  24a5				   TERM
      0  24a5					      CALL	FACT	; Get a value
      0  24a5					      db	28
      1  24a5		       1c		      .byte.b	28
      0  24a6					      dw	FACT
      1  24a6		       ca 24		      .word.w	FACT
    675  24a8				   T0			; Check for higher precidence operators
      0  24a8					      TSTB	T1,oMultiply	; Check for *
      0  24a8					      db	101
      1  24a8		       65		      .byte.b	101
      0  24a9					      db	(T1-*)-1
      1  24a9		       08		      .byte.b	(T1-*)-1
      0  24aa					      db	oMultiply
      1  24aa		       ee		      .byte.b	oMultiply
      0  24ab					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  24ab					      db	28
      1  24ab		       1c		      .byte.b	28
      0  24ac					      dw	FACT
      1  24ac		       ca 24		      .word.w	FACT
      0  24ae					      MUL		; Multiply factors
      0  24ae					      db	17
      1  24ae		       11		      .byte.b	17
      0  24af					      IJMP	T0	; Check for * or /
      0  24af					      db	29
      1  24af		       1d		      .byte.b	29
      0  24b0					      dw	T0
      1  24b0		       a8 24		      .word.w	T0
    680  24b2				   T1
      0  24b2					      TSTB	T2,oDivide	; Check for a division
      0  24b2					      db	101
      1  24b2		       65		      .byte.b	101
      0  24b3					      db	(T2-*)-1
      1  24b3		       08		      .byte.b	(T2-*)-1
      0  24b4					      db	oDivide
      1  24b4		       ec		      .byte.b	oDivide
      0  24b5					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  24b5					      db	28
      1  24b5		       1c		      .byte.b	28
      0  24b6					      dw	FACT
      1  24b6		       ca 24		      .word.w	FACT
      0  24b8					      DIV		; do division
      0  24b8					      db	18
      1  24b8		       12		      .byte.b	18
      0  24b9					      IJMP	T0	; check for more * or /
      0  24b9					      db	29
      1  24b9		       1d		      .byte.b	29
      0  24ba					      dw	T0
      1  24ba		       a8 24		      .word.w	T0
    685  24bc				   T2
      0  24bc					      TSTB	T3,oModulo	; Check for a division
      0  24bc					      db	101
      1  24bc		       65		      .byte.b	101
      0  24bd					      db	(T3-*)-1
      1  24bd		       08		      .byte.b	(T3-*)-1
      0  24be					      db	oModulo
      1  24be		       ed		      .byte.b	oModulo
      0  24bf					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  24bf					      db	28
      1  24bf		       1c		      .byte.b	28
      0  24c0					      dw	FACT
      1  24c0		       ca 24		      .word.w	FACT
      0  24c2					      MODULO		; do division for remainder
      0  24c2					      db	60
      1  24c2		       3c		      .byte.b	60
      0  24c3					      IJMP	T0	; check for more * or / or %
      0  24c3					      db	29
      1  24c3		       1d		      .byte.b	29
      0  24c4					      dw	T0
      1  24c4		       a8 24		      .word.w	T0
    690  24c6				   T3			; Finish processing the Term
      0  24c6					      RTN
      0  24c6					      db	25
      1  24c6		       19		      .byte.b	25
    692  24c7
    693  24c7				   UNKNOWNVEC
      0  24c7					      IJMP	UNKNOWN
      0  24c7					      db	29
      1  24c7		       1d		      .byte.b	29
      0  24c8					      dw	UNKNOWN
      1  24c8		       4d 24		      .word.w	UNKNOWN
    695  24ca
    696  24ca							;=============================================================================================
    697  24ca							; Factor an expression.  Always test for functions
    698  24ca							; first or else they'll be confused for variables.
    699  24ca							;
    700  24ca				   FACT
      0  24ca					      OnGoto	BasicFuncs,FactNumber
      0  24ca					      db	103
      1  24ca		       67		      .byte.b	103
      0  24cb					      dw	BasicFuncs
      1  24cb		       f8 21		      .word.w	BasicFuncs
      0  24cd					      dw	FactNumber
      1  24cd		       c2 25		      .word.w	FactNumber
    702  24cf
    703  24cf				   FACTCONTINUE
      0  24cf					      TSTB	F1AA,kTrue
      0  24cf					      db	101
      1  24cf		       65		      .byte.b	101
      0  24d0					      db	(F1AA-*)-1
      1  24d0		       05		      .byte.b	(F1AA-*)-1
      0  24d1					      db	kTrue
      1  24d1		       24		      .byte.b	kTrue
    705  24d2				   ekTrue
      0  24d2					      LIT	-1
      0  24d2					      db	27
      1  24d2		       1b		      .byte.b	27
      0  24d3					      dw	-1
      1  24d3		       ff ff		      .word.w	-1
      0  24d5					      RTN
      0  24d5					      db	25
      1  24d5		       19		      .byte.b	25
    708  24d6				   F1AA
      0  24d6					      TSTB	F1AB,kFalse
      0  24d6					      db	101
      1  24d6		       65		      .byte.b	101
      0  24d7					      db	(F1AB-*)-1
      1  24d7		       05		      .byte.b	(F1AB-*)-1
      0  24d8					      db	kFalse
      1  24d8		       25		      .byte.b	kFalse
    710  24d9				   ekFalse
      0  24d9					      LIT	0
      0  24d9					      db	27
      1  24d9		       1b		      .byte.b	27
      0  24da					      dw	0
      1  24da		       00 00		      .word.w	0
      0  24dc					      RTN
      0  24dc					      db	25
      1  24dc		       19		      .byte.b	25
    713  24dd							;==================================================================================
    714  24dd							; Returns the amount of free SPACE
    715  24dd							;
    716  24dd				   F1AB
      0  24dd					      TSTB	F1A,kFree
      0  24dd					      db	101
      1  24dd		       65		      .byte.b	101
      0  24de					      db	(F1A-*)-1
      1  24de		       09		      .byte.b	(F1A-*)-1
      0  24df					      db	kFree
      1  24df		       26		      .byte.b	kFree
    718  24e0				   ekFree
      0  24e0					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24e0					      db	101
      1  24e0		       65		      .byte.b	101
      0  24e1					      db	(UNKNOWNVEC-*)-1
      1  24e1		       e5		      .byte.b	(UNKNOWNVEC-*)-1
      0  24e2					      db	oLeftBracket
      1  24e2		       e0		      .byte.b	oLeftBracket
      0  24e3					      TSTB	UNKNOWNVEC,oRightBracket
      0  24e3					      db	101
      1  24e3		       65		      .byte.b	101
      0  24e4					      db	(UNKNOWNVEC-*)-1
      1  24e4		       e2		      .byte.b	(UNKNOWNVEC-*)-1
      0  24e5					      db	oRightBracket
      1  24e5		       e1		      .byte.b	oRightBracket
      0  24e6					      FREE
      0  24e6					      db	36
      1  24e6		       24		      .byte.b	36
      0  24e7					      RTN
      0  24e7					      db	25
      1  24e7		       19		      .byte.b	25
    723  24e8							;===================================================================================
    724  24e8							; getch() read a character from the input device
    725  24e8							;
    726  24e8				   F1A
      0  24e8					      TSTB	F1A2,kGetch	; read char from the terminal
      0  24e8					      db	101
      1  24e8		       65		      .byte.b	101
      0  24e9					      db	(F1A2-*)-1
      1  24e9		       09		      .byte.b	(F1A2-*)-1
      0  24ea					      db	kGetch
      1  24ea		       27		      .byte.b	kGetch
    728  24eb				   ekGetch
      0  24eb					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24eb					      db	101
      1  24eb		       65		      .byte.b	101
      0  24ec					      db	(UNKNOWNVEC-*)-1
      1  24ec		       da		      .byte.b	(UNKNOWNVEC-*)-1
      0  24ed					      db	oLeftBracket
      1  24ed		       e0		      .byte.b	oLeftBracket
      0  24ee					      TSTB	UNKNOWNVEC,oRightBracket
      0  24ee					      db	101
      1  24ee		       65		      .byte.b	101
      0  24ef					      db	(UNKNOWNVEC-*)-1
      1  24ef		       d7		      .byte.b	(UNKNOWNVEC-*)-1
      0  24f0					      db	oRightBracket
      1  24f0		       e1		      .byte.b	oRightBracket
      0  24f1					      GETCHAR
      0  24f1					      db	51
      1  24f1		       33		      .byte.b	51
      0  24f2					      RTN
      0  24f2					      db	25
      1  24f2		       19		      .byte.b	25
    733  24f3							;====================================================================================
    734  24f3							; peek(mem address) return the value of a byte in memory
    735  24f3							; @[offset] return a word value from offset -- see tstv
    736  24f3							;
    737  24f3				   F1A2
      0  24f3					      TSTB	F2AZ,kPeek	;Return a value from memory
      0  24f3					      db	101
      1  24f3		       65		      .byte.b	101
      0  24f4					      db	(F2AZ-*)-1
      1  24f4		       0c		      .byte.b	(F2AZ-*)-1
      0  24f5					      db	kPeek
      1  24f5		       28		      .byte.b	kPeek
    739  24f6				   ekPeek
      0  24f6					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24f6					      db	101
      1  24f6		       65		      .byte.b	101
      0  24f7					      db	(UNKNOWNVEC-*)-1
      1  24f7		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  24f8					      db	oLeftBracket
      1  24f8		       e0		      .byte.b	oLeftBracket
      0  24f9					      CALL	EXPR	;Get the address to write to
      0  24f9					      db	28
      1  24f9		       1c		      .byte.b	28
      0  24fa					      dw	EXPR
      1  24fa		       51 24		      .word.w	EXPR
      0  24fc					      TSTB	UNKNOWNVEC,oRightBracket
      0  24fc					      db	101
      1  24fc		       65		      .byte.b	101
      0  24fd					      db	(UNKNOWNVEC-*)-1
      1  24fd		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  24fe					      db	oRightBracket
      1  24fe		       e1		      .byte.b	oRightBracket
      0  24ff					      PEEKMEM
      0  24ff					      db	48
      1  24ff		       30		      .byte.b	48
      0  2500					      RTN
      0  2500					      db	25
      1  2500		       19		      .byte.b	25
    745  2501							;=======================================================================================
    746  2501							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    747  2501							;
    748  2501				   F2AZ
      0  2501					      TSTB	F2AZ1,kTask	;Check if we are setting a task start
      0  2501					      db	101
      1  2501		       65		      .byte.b	101
      0  2502					      db	(F2AZ1-*)-1
      1  2502		       28		      .byte.b	(F2AZ1-*)-1
      0  2503					      db	kTask
      1  2503		       29		      .byte.b	kTask
    750  2504				   ekTask
      0  2504					      TSTBRANCH	ekTaskCompiled
      0  2504					      db	106
      1  2504		       6a		      .byte.b	106
      0  2505					      db	(ekTaskCompiled-*)-1
      1  2505		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  2506					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2506					      db	101
      1  2506		       65		      .byte.b	101
      0  2507					      db	(UNKNOWNVEC-*)-1
      1  2507		       bf		      .byte.b	(UNKNOWNVEC-*)-1
      0  2508					      db	oLeftBracket
      1  2508		       e0		      .byte.b	oLeftBracket
      0  2509					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2509					      db	28
      1  2509		       1c		      .byte.b	28
      0  250a					      dw	EXPR
      1  250a		       51 24		      .word.w	EXPR
      0  250c					      lit	0
      0  250c					      db	27
      1  250c		       1b		      .byte.b	27
      0  250d					      dw	0
      1  250d		       00 00		      .word.w	0
      0  250f					      iJMP	ekTaskLinenum
      0  250f					      db	29
      1  250f		       1d		      .byte.b	29
      0  2510					      dw	ekTaskLinenum
      1  2510		       15 25		      .word.w	ekTaskLinenum
    756  2512
    757  2512				   ekTaskCompiled
      0  2512					      lit	1
      0  2512					      db	27
      1  2512		       1b		      .byte.b	27
      0  2513					      dw	1
      1  2513		       01 00		      .word.w	1
    759  2515
    760  2515				   ekTaskLinenum
      0  2515					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  2515					      db	61
      1  2515		       3d		      .byte.b	61
      0  2516					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  2516					      db	101
      1  2516		       65		      .byte.b	101
      0  2517					      db	(F2AZNoParms-*)-1
      1  2517		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  2518					      db	oComma
      1  2518		       e2		      .byte.b	oComma
      0  2519					      SAVEMATHSTACK		;Push The mathstack
      0  2519					      db	86
      1  2519		       56		      .byte.b	86
      0  251a					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  251a					      db	89
      1  251a		       59		      .byte.b	89
    765  251b				   F2AZLOOP
      0  251b					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  251b					      db	28
      1  251b		       1c		      .byte.b	28
      0  251c					      dw	EXPR
      1  251c		       51 24		      .word.w	EXPR
      0  251e					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  251e					      db	101
      1  251e		       65		      .byte.b	101
      0  251f					      db	(F2AZEndParm-*)-1
      1  251f		       04		      .byte.b	(F2AZEndParm-*)-1
      0  2520					      db	oComma
      1  2520		       e2		      .byte.b	oComma
      0  2521					      IJMP	F2AZLOOP	;check for more
      0  2521					      db	29
      1  2521		       1d		      .byte.b	29
      0  2522					      dw	F2AZLOOP
      1  2522		       1b 25		      .word.w	F2AZLOOP
    769  2524
    770  2524				   F2AZEndParm
      0  2524					      RESTOREMATHSTACK		;Back to normal stack
      0  2524					      db	87
      1  2524		       57		      .byte.b	87
      0  2525					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  2525					      db	92
      1  2525		       5c		      .byte.b	92
    773  2526
    774  2526				   F2AZNoParms
      0  2526					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  2526					      db	101
      1  2526		       65		      .byte.b	101
      0  2527					      db	(UNKNOWNVEC-*)-1
      1  2527		       9f		      .byte.b	(UNKNOWNVEC-*)-1
      0  2528					      db	oRightBracket
      1  2528		       e1		      .byte.b	oRightBracket
    776  2529
      0  2529					      TASKENABLE		;Enable the task to execute
      0  2529					      db	90
      1  2529		       5a		      .byte.b	90
    778  252a
      0  252a					      RTN		;Returns the Task number
      0  252a					      db	25
      1  252a		       19		      .byte.b	25
    780  252b							;=========================================================================================
    781  252b							; Check for IPC interproccess instructions
    782  252b							;   IPCS  - Send a message
    783  252b							;
    784  252b				   F2AZ1
      0  252b					      TSTB	F2AZa,kIpcs	;Test if one of the IPC functions
      0  252b					      db	101
      1  252b		       65		      .byte.b	101
      0  252c					      db	(F2AZa-*)-1
      1  252c		       12		      .byte.b	(F2AZa-*)-1
      0  252d					      db	kIpcs
      1  252d		       2b		      .byte.b	kIpcs
    786  252e				   ekIpcs
      0  252e					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  252e					      db	101
      1  252e		       65		      .byte.b	101
      0  252f					      db	(UNKNOWNVEC-*)-1
      1  252f		       97		      .byte.b	(UNKNOWNVEC-*)-1
      0  2530					      db	oLeftBracket
      1  2530		       e0		      .byte.b	oLeftBracket
      0  2531					      CALL	EXPR	;Get the message value
      0  2531					      db	28
      1  2531		       1c		      .byte.b	28
      0  2532					      dw	EXPR
      1  2532		       51 24		      .word.w	EXPR
      0  2534					      TSTB	UNKNOWNVEC,oComma
      0  2534					      db	101
      1  2534		       65		      .byte.b	101
      0  2535					      db	(UNKNOWNVEC-*)-1
      1  2535		       91		      .byte.b	(UNKNOWNVEC-*)-1
      0  2536					      db	oComma
      1  2536		       e2		      .byte.b	oComma
      0  2537					      CALL	EXPR	;Get pid of task to send to
      0  2537					      db	28
      1  2537		       1c		      .byte.b	28
      0  2538					      dw	EXPR
      1  2538		       51 24		      .word.w	EXPR
      0  253a					      TSTB	UNKNOWNVEC,oRightBracket
      0  253a					      db	101
      1  253a		       65		      .byte.b	101
      0  253b					      db	(UNKNOWNVEC-*)-1
      1  253b		       8b		      .byte.b	(UNKNOWNVEC-*)-1
      0  253c					      db	oRightBracket
      1  253c		       e1		      .byte.b	oRightBracket
      0  253d					      IPCSEND		;Send msg and clear pid msg pending
      0  253d					      db	80
      1  253d		       50		      .byte.b	80
      0  253e					      RTN
      0  253e					      db	25
      1  253e		       19		      .byte.b	25
    794  253f							;================================================================================
    795  253f							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    796  253f							;
    797  253f				   F2AZa
      0  253f					      TSTB	F2AZb,kIpcr	;IPCR recieve a message , wait if none
      0  253f					      db	101
      1  253f		       65		      .byte.b	101
      0  2540					      db	(F2AZb-*)-1
      1  2540		       15		      .byte.b	(F2AZb-*)-1
      0  2541					      db	kIpcr
      1  2541		       2c		      .byte.b	kIpcr
    799  2542				   ekIpcr
      0  2542					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2542					      db	101
      1  2542		       65		      .byte.b	101
      0  2543					      db	(UNKNOWNVEC-*)-1
      1  2543		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  2544					      db	oLeftBracket
      1  2544		       e0		      .byte.b	oLeftBracket
      0  2545					      TSTB	F2AZa1,oRightBracket
      0  2545					      db	101
      1  2545		       65		      .byte.b	101
      0  2546					      db	(F2AZa1-*)-1
      1  2546		       07		      .byte.b	(F2AZa1-*)-1
      0  2547					      db	oRightBracket
      1  2547		       e1		      .byte.b	oRightBracket
      0  2548					      LIT	0	;We dont want the pid returned to us
      0  2548					      db	27
      1  2548		       1b		      .byte.b	27
      0  2549					      dw	0
      1  2549		       00 00		      .word.w	0
      0  254b					      IPCIO		;Set the io bit and suspend the task till message
      0  254b					      db	83
      1  254b		       53		      .byte.b	83
      0  254c					      IPCRECEIVE		;Get the message
      0  254c					      db	81
      1  254c		       51		      .byte.b	81
      0  254d					      RTN
      0  254d					      db	25
      1  254d		       19		      .byte.b	25
    806  254e				   F2AZa1
      0  254e					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  254e					      db	33
      1  254e		       21		      .byte.b	33
      0  254f					      db	(UNKNOWNVEC-*)-1
      1  254f		       77		      .byte.b	(UNKNOWNVEC-*)-1
      0  2550					      TSTB	UNKNOWNVEC,oRightBracket
      0  2550					      db	101
      1  2550		       65		      .byte.b	101
      0  2551					      db	(UNKNOWNVEC-*)-1
      1  2551		       75		      .byte.b	(UNKNOWNVEC-*)-1
      0  2552					      db	oRightBracket
      1  2552		       e1		      .byte.b	oRightBracket
      0  2553					      IPCIO		;Set the io bit and exit task till message
      0  2553					      db	83
      1  2553		       53		      .byte.b	83
      0  2554					      IPCRECEIVE		;Get the message
      0  2554					      db	81
      1  2554		       51		      .byte.b	81
      0  2555					      RTN
      0  2555					      db	25
      1  2555		       19		      .byte.b	25
    812  2556							;===============================================================================
    813  2556							; IPCC ---- check if a message is available
    814  2556				   F2AZb
      0  2556					      TST	F2A,kIpcc	;Returns number of messages on the message queue
      0  2556					      db	32
      1  2556		       20		      .byte.b	32
      0  2557					      db	(F2A-*)-1
      1  2557		       0d		      .byte.b	(F2A-*)-1
      0  2558					      db	kIpcc,0
      1  2558		       2a 00		      .byte.b	kIpcc,0
    816  255a				   ekIpcc
      0  255a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  255a					      db	101
      1  255a		       65		      .byte.b	101
      0  255b					      db	(UNKNOWNVEC-*)-1
      1  255b		       6b		      .byte.b	(UNKNOWNVEC-*)-1
      0  255c					      db	oLeftBracket
      1  255c		       e0		      .byte.b	oLeftBracket
      0  255d					      TSTB	UNKNOWNVEC,oRightBracket
      0  255d					      db	101
      1  255d		       65		      .byte.b	101
      0  255e					      db	(UNKNOWNVEC-*)-1
      1  255e		       68		      .byte.b	(UNKNOWNVEC-*)-1
      0  255f					      db	oRightBracket
      1  255f		       e1		      .byte.b	oRightBracket
      0  2560					      IPCCHECK
      0  2560					      db	82
      1  2560		       52		      .byte.b	82
      0  2561					      RTN
      0  2561					      db	25
      1  2561		       19		      .byte.b	25
    821  2562
    822  2562				   UNKNOWNID
      0  2562					      IJMP	UNKNOWN
      0  2562					      db	29
      1  2562		       1d		      .byte.b	29
      0  2563					      dw	UNKNOWN
      1  2563		       4d 24		      .word.w	UNKNOWN
    824  2565							;============================================================
    825  2565							; RND() is supposed to have an argument but if none
    826  2565							; was provided, just assume a large value.
    827  2565							;
    828  2565				   F2A
      0  2565					      TSTB	F2B,kRnd
      0  2565					      db	101
      1  2565		       65		      .byte.b	101
      0  2566					      db	(F2B-*)-1
      1  2566		       14		      .byte.b	(F2B-*)-1
      0  2567					      db	kRnd
      1  2567		       2d		      .byte.b	kRnd
    830  2568				   ekRnd
      0  2568					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2568					      db	101
      1  2568		       65		      .byte.b	101
      0  2569					      db	(UNKNOWNVEC-*)-1
      1  2569		       5d		      .byte.b	(UNKNOWNVEC-*)-1
      0  256a					      db	oLeftBracket
      1  256a		       e0		      .byte.b	oLeftBracket
      0  256b					      TSTB	F2A1,oRightBracket
      0  256b					      db	101
      1  256b		       65		      .byte.b	101
      0  256c					      db	(F2A1-*)-1
      1  256c		       06		      .byte.b	(F2A1-*)-1
      0  256d					      db	oRightBracket
      1  256d		       e1		      .byte.b	oRightBracket
      0  256e					      LIT	32766
      0  256e					      db	27
      1  256e		       1b		      .byte.b	27
      0  256f					      dw	32766
      1  256f		       fe 7f		      .word.w	32766
      0  2571					      RANDOM
      0  2571					      db	37
      1  2571		       25		      .byte.b	37
      0  2572					      RTN
      0  2572					      db	25
      1  2572		       19		      .byte.b	25
    836  2573
    837  2573				   F2A1
      0  2573					      CALL	FACT	;GET RANGE
      0  2573					      db	28
      1  2573		       1c		      .byte.b	28
      0  2574					      dw	FACT
      1  2574		       ca 24		      .word.w	FACT
      0  2576					      TSTB	UNKNOWNVEC,oRightBracket
      0  2576					      db	101
      1  2576		       65		      .byte.b	101
      0  2577					      db	(UNKNOWNVEC-*)-1
      1  2577		       4f		      .byte.b	(UNKNOWNVEC-*)-1
      0  2578					      db	oRightBracket
      1  2578		       e1		      .byte.b	oRightBracket
      0  2579					      RANDOM
      0  2579					      db	37
      1  2579		       25		      .byte.b	37
      0  257a					      RTN
      0  257a					      db	25
      1  257a		       19		      .byte.b	25
    842  257b							;==========================================================
    843  257b							;	Return absolute value of expresion
    844  257b							;
    845  257b				   F2B
      0  257b					      TSTB	F2B2,kAbs
      0  257b					      db	101
      1  257b		       65		      .byte.b	101
      0  257c					      db	(F2B2-*)-1
      1  257c		       0c		      .byte.b	(F2B2-*)-1
      0  257d					      db	kAbs
      1  257d		       2f		      .byte.b	kAbs
    847  257e				   ekAbs
      0  257e					      TSTB	UNKNOWNVEC,oLeftBracket
      0  257e					      db	101
      1  257e		       65		      .byte.b	101
      0  257f					      db	(UNKNOWNVEC-*)-1
      1  257f		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  2580					      db	oLeftBracket
      1  2580		       e0		      .byte.b	oLeftBracket
      0  2581					      CALL	EXPR	;get value
      0  2581					      db	28
      1  2581		       1c		      .byte.b	28
      0  2582					      dw	EXPR
      1  2582		       51 24		      .word.w	EXPR
      0  2584					      TSTB	UNKNOWNVEC,oRightBracket
      0  2584					      db	101
      1  2584		       65		      .byte.b	101
      0  2585					      db	(UNKNOWNVEC-*)-1
      1  2585		       41		      .byte.b	(UNKNOWNVEC-*)-1
      0  2586					      db	oRightBracket
      1  2586		       e1		      .byte.b	oRightBracket
      0  2587					      ABS
      0  2587					      db	38
      1  2587		       26		      .byte.b	38
      0  2588					      RTN
      0  2588					      db	25
      1  2588		       19		      .byte.b	25
    853  2589							;============================================================
    854  2589							;     Return the the status of a task, provide the PID
    855  2589							;
    856  2589				   F2B2
      0  2589					      TSTB	F2Z,kStat
      0  2589					      db	101
      1  2589		       65		      .byte.b	101
      0  258a					      db	(F2Z-*)-1
      1  258a		       0c		      .byte.b	(F2Z-*)-1
      0  258b					      db	kStat
      1  258b		       2e		      .byte.b	kStat
    858  258c				   ekStat
      0  258c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  258c					      db	101
      1  258c		       65		      .byte.b	101
      0  258d					      db	(UNKNOWNVEC-*)-1
      1  258d		       39		      .byte.b	(UNKNOWNVEC-*)-1
      0  258e					      db	oLeftBracket
      1  258e		       e0		      .byte.b	oLeftBracket
      0  258f					      Call	EXPR
      0  258f					      db	28
      1  258f		       1c		      .byte.b	28
      0  2590					      dw	EXPR
      1  2590		       51 24		      .word.w	EXPR
      0  2592					      TSTB	UNKNOWNVEC,oRightBracket
      0  2592					      db	101
      1  2592		       65		      .byte.b	101
      0  2593					      db	(UNKNOWNVEC-*)-1
      1  2593		       33		      .byte.b	(UNKNOWNVEC-*)-1
      0  2594					      db	oRightBracket
      1  2594		       e1		      .byte.b	oRightBracket
      0  2595					      TASKSTAT
      0  2595					      db	66
      1  2595		       42		      .byte.b	66
      0  2596					      RTN
      0  2596					      db	25
      1  2596		       19		      .byte.b	25
    864  2597				   F2Z
      0  2597					      TSTB	F2ZA,kPid
      0  2597					      db	101
      1  2597		       65		      .byte.b	101
      0  2598					      db	(F2ZA-*)-1
      1  2598		       03		      .byte.b	(F2ZA-*)-1
      0  2599					      db	kPid
      1  2599		       32		      .byte.b	kPid
    866  259a				   ekPid
      0  259a					      TASKPID
      0  259a					      db	77
      1  259a		       4d		      .byte.b	77
      0  259b					      RTN
      0  259b					      db	25
      1  259b		       19		      .byte.b	25
    869  259c							;===========================================================================
    870  259c							; Call a machine function, provide the address to call and optionally
    871  259c							; the value to be passed in reg A
    872  259c				   F2ZA
      0  259c					      TSTB	F2FUNC,kCall	;call machine function
      0  259c					      db	101
      1  259c		       65		      .byte.b	101
      0  259d					      db	(F2FUNC-*)-1
      1  259d		       1a		      .byte.b	(F2FUNC-*)-1
      0  259e					      db	kCall
      1  259e		       30		      .byte.b	kCall
    874  259f				   ekCall
      0  259f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  259f					      db	101
      1  259f		       65		      .byte.b	101
      0  25a0					      db	(UNKNOWNVEC-*)-1
      1  25a0		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  25a1					      db	oLeftBracket
      1  25a1		       e0		      .byte.b	oLeftBracket
      0  25a2					      CALL	EXPR
      0  25a2					      db	28
      1  25a2		       1c		      .byte.b	28
      0  25a3					      dw	EXPR
      1  25a3		       51 24		      .word.w	EXPR
      0  25a5					      TSTB	F2B2A,oComma
      0  25a5					      db	101
      1  25a5		       65		      .byte.b	101
      0  25a6					      db	(F2B2A-*)-1
      1  25a6		       09		      .byte.b	(F2B2A-*)-1
      0  25a7					      db	oComma
      1  25a7		       e2		      .byte.b	oComma
      0  25a8					      CALL	EXPR
      0  25a8					      db	28
      1  25a8		       1c		      .byte.b	28
      0  25a9					      dw	EXPR
      1  25a9		       51 24		      .word.w	EXPR
      0  25ab					      TSTB	UNKNOWNVEC,oRightBracket
      0  25ab					      db	101
      1  25ab		       65		      .byte.b	101
      0  25ac					      db	(UNKNOWNVEC-*)-1
      1  25ac		       1a		      .byte.b	(UNKNOWNVEC-*)-1
      0  25ad					      db	oRightBracket
      1  25ad		       e1		      .byte.b	oRightBracket
      0  25ae					      CALLFUNC
      0  25ae					      db	53
      1  25ae		       35		      .byte.b	53
      0  25af					      RTN
      0  25af					      db	25
      1  25af		       19		      .byte.b	25
    882  25b0							; Run the gosub within this function
    883  25b0				   F2B2A
      0  25b0					      TSTB	UNKNOWNID,oRightBracket
      0  25b0					      db	101
      1  25b0		       65		      .byte.b	101
      0  25b1					      db	(UNKNOWNID-*)-1
      1  25b1		       b0		      .byte.b	(UNKNOWNID-*)-1
      0  25b2					      db	oRightBracket
      1  25b2		       e1		      .byte.b	oRightBracket
      0  25b3					      LIT	0	; No parameter passed so just load zero to A
      0  25b3					      db	27
      1  25b3		       1b		      .byte.b	27
      0  25b4					      dw	0
      1  25b4		       00 00		      .word.w	0
      0  25b6					      CALLFUNC
      0  25b6					      db	53
      1  25b6		       35		      .byte.b	53
      0  25b7					      RTN
      0  25b7					      db	25
      1  25b7		       19		      .byte.b	25
    888  25b8							;===========================================================================
    889  25b8							; Same as gosub but expects a return value
    890  25b8							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    891  25b8							;
      0  25b8				   F2FUNC     TSTB	F2C,kGofn
      0  25b8					      db	101
      1  25b8		       65		      .byte.b	101
      0  25b9					      db	(F2C-*)-1
      1  25b9		       19		      .byte.b	(F2C-*)-1
      0  25ba					      db	kGofn
      1  25ba		       31		      .byte.b	kGofn
    893  25bb				   ekGofn
      0  25bb					      Call	GOSUBSTATEMENT
      0  25bb					      db	28
      1  25bb		       1c		      .byte.b	28
      0  25bc					      dw	GOSUBSTATEMENT
      1  25bc		       e7 25		      .word.w	GOSUBSTATEMENT
      0  25be					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  25be					      db	8
      1  25be		       08		      .byte.b	8
      0  25bf					      db	GOSUB_RTN_VALUE
      1  25bf		       81		      .byte.b	GOSUB_RTN_VALUE
      0  25c0					      FASTXFER
      0  25c0					      db	107
      1  25c0		       6b		      .byte.b	107
    897  25c1
    898  25c1				   GOFNRet
      0  25c1					      RTN
      0  25c1					      db	25
      1  25c1		       19		      .byte.b	25
    900  25c2
    901  25c2							;=================================================================================
    902  25c2							;Check for a number !
    903  25c2							;
    904  25c2				   F0
    905  25c2				   FactNumber
      0  25c2					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  25c2					      db	35
      1  25c2		       23		      .byte.b	35
      0  25c3					      db	(FactVariable-*)-1
      1  25c3		       0f		      .byte.b	(FactVariable-*)-1
      0  25c4					      RTN
      0  25c4					      db	25
      1  25c4		       19		      .byte.b	25
    908  25c5				   F1
      0  25c5					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  25c5					      db	101
      1  25c5		       65		      .byte.b	101
      0  25c6					      db	(F2RTN-*)-1
      1  25c6		       08		      .byte.b	(F2RTN-*)-1
      0  25c7					      db	oLeftBracket
      1  25c7		       e0		      .byte.b	oLeftBracket
      0  25c8					      CALL	EXPR
      0  25c8					      db	28
      1  25c8		       1c		      .byte.b	28
      0  25c9					      dw	EXPR
      1  25c9		       51 24		      .word.w	EXPR
      0  25cb					      TST	F2,oRightBracket
      0  25cb					      db	32
      1  25cb		       20		      .byte.b	32
      0  25cc					      db	(F2-*)-1
      1  25cc		       03		      .byte.b	(F2-*)-1
      0  25cd					      db	oRightBracket,0
      1  25cd		       e1 00		      .byte.b	oRightBracket,0
    912  25cf				   F2RTN
      0  25cf					      RTN
      0  25cf					      db	25
      1  25cf		       19		      .byte.b	25
    914  25d0
    915  25d0				   F2
      0  25d0					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  25d0					      db	13
      1  25d0		       0d		      .byte.b	13
      0  25d1					      dw	ERR_SYNTAX
      1  25d1		       05 00		      .word.w	ERR_SYNTAX
    917  25d3							;
    918  25d3							;=============================================================================
    919  25d3							; See if this is just a simple variable
    920  25d3							;  Allow a subscript for any variable
    921  25d3							;
    922  25d3				   F2C
    923  25d3
    924  25d3				   FactVariable
      0  25d3					      TSTV	F1
      0  25d3					      db	33
      1  25d3		       21		      .byte.b	33
      0  25d4					      db	(F1-*)-1
      1  25d4		       f0		      .byte.b	(F1-*)-1
      0  25d5					      TSTB	F2CLocalTask,oBang
      0  25d5					      db	101
      1  25d5		       65		      .byte.b	101
      0  25d6					      db	(F2CLocalTask-*)-1
      1  25d6		       04		      .byte.b	(F2CLocalTask-*)-1
      0  25d7					      db	oBang
      1  25d7		       e8		      .byte.b	oBang
      0  25d8					      IND		; we just got a pid
      0  25d8					      db	20
      1  25d8		       14		      .byte.b	20
      0  25d9					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  25d9					      db	93
      1  25d9		       5d		      .byte.b	93
      0  25da					      db	(UNKNOWNID-*)-1
      1  25da		       87		      .byte.b	(UNKNOWNID-*)-1
    929  25db
    930  25db				   F2CLocalTask
      0  25db					      TSTB	F2C1,oLeftSQBracket
      0  25db					      db	101
      1  25db		       65		      .byte.b	101
      0  25dc					      db	(F2C1-*)-1
      1  25dc		       08		      .byte.b	(F2C1-*)-1
      0  25dd					      db	oLeftSQBracket
      1  25dd		       e4		      .byte.b	oLeftSQBracket
      0  25de					      CALL	EXPR
      0  25de					      db	28
      1  25de		       1c		      .byte.b	28
      0  25df					      dw	EXPR
      1  25df		       51 24		      .word.w	EXPR
      0  25e1					      TSTB	UNKNOWNID,oRightSQBracket
      0  25e1					      db	101
      1  25e1		       65		      .byte.b	101
      0  25e2					      db	(UNKNOWNID-*)-1
      1  25e2		       7f		      .byte.b	(UNKNOWNID-*)-1
      0  25e3					      db	oRightSQBracket
      1  25e3		       e5		      .byte.b	oRightSQBracket
      0  25e4					      SUBSCRIPT
      0  25e4					      db	64
      1  25e4		       40		      .byte.b	64
    935  25e5				   F2C1
      0  25e5					      IND		; YES, GET THE VALUE.
      0  25e5					      db	20
      1  25e5		       14		      .byte.b	20
      0  25e6					      RTN
      0  25e6					      db	25
      1  25e6		       19		      .byte.b	25
    938  25e7
    939  25e7							;=============================================================
    940  25e7							; Gosub can be both a Function and a Subroutine
    941  25e7				   GOSUBSTATEMENT
      0  25e7					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  25e7					      db	106
      1  25e7		       6a		      .byte.b	106
      0  25e8					      db	(GOSUBCOMPILED-*)-1
      1  25e8		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  25e9					      CALL	EXPR	; GET DESTINATION
      0  25e9					      db	28
      1  25e9		       1c		      .byte.b	28
      0  25ea					      dw	EXPR
      1  25ea		       51 24		      .word.w	EXPR
      0  25ec					      CALL	GOSUBCONT
      0  25ec					      db	28
      1  25ec		       1c		      .byte.b	28
      0  25ed					      dw	GOSUBCONT
      1  25ed		       fa 25		      .word.w	GOSUBCONT
      0  25ef					      lit	0	; mark as lookup on stack
      0  25ef					      db	27
      1  25ef		       1b		      .byte.b	27
      0  25f0					      dw	0
      1  25f0		       00 00		      .word.w	0
      0  25f2					      RTN
      0  25f2					      db	25
      1  25f2		       19		      .byte.b	25
    947  25f3
    948  25f3				   GOSUBCOMPILED
      0  25f3					      CALL	GOSUBCONT
      0  25f3					      db	28
      1  25f3		       1c		      .byte.b	28
      0  25f4					      dw	GOSUBCONT
      1  25f4		       fa 25		      .word.w	GOSUBCONT
      0  25f6					      lit	1	;mark as compiled on stack
      0  25f6					      db	27
      1  25f6		       1b		      .byte.b	27
      0  25f7					      dw	1
      1  25f7		       01 00		      .word.w	1
      0  25f9					      RTN
      0  25f9					      db	25
      1  25f9		       19		      .byte.b	25
    952  25fa
    953  25fa				   GOSUBCONT
      0  25fa					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  25fa					      db	101
      1  25fa		       65		      .byte.b	101
      0  25fb					      db	(GOSUBDONE-*)-1
      1  25fb		       11		      .byte.b	(GOSUBDONE-*)-1
      0  25fc					      db	oLeftBracket
      1  25fc		       e0		      .byte.b	oLeftBracket
      0  25fd					      STK2TMP		;Transfer stack top to temp
      0  25fd					      db	95
      1  25fd		       5f		      .byte.b	95
      0  25fe					      PUSHMATHSTACK		;Record stack frame for return
      0  25fe					      db	84
      1  25fe		       54		      .byte.b	84
    957  25ff				   GOSUBLOOP
      0  25ff					      CALL	EXPR	; Allows what ever fits onto stack
      0  25ff					      db	28
      1  25ff		       1c		      .byte.b	28
      0  2600					      dw	EXPR
      1  2600		       51 24		      .word.w	EXPR
      0  2602					      INCPARMCOUNT
      0  2602					      db	88
      1  2602		       58		      .byte.b	88
      0  2603					      TSTB	GOSUBParmDONE,oComma
      0  2603					      db	101
      1  2603		       65		      .byte.b	101
      0  2604					      db	(GOSUBParmDONE-*)-1
      1  2604		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  2605					      db	oComma
      1  2605		       e2		      .byte.b	oComma
      0  2606					      IJMP	GOSUBLOOP
      0  2606					      db	29
      1  2606		       1d		      .byte.b	29
      0  2607					      dw	GOSUBLOOP
      1  2607		       ff 25		      .word.w	GOSUBLOOP
    962  2609				   GOSUBParmDONE
      0  2609					      TSTB	F2,oRightBracket
      0  2609					      db	101
      1  2609		       65		      .byte.b	101
      0  260a					      db	(F2-*)-1
      1  260a		       c5		      .byte.b	(F2-*)-1
      0  260b					      db	oRightBracket
      1  260b		       e1		      .byte.b	oRightBracket
      0  260c					      TMP2STK		; Restore line to goto
      0  260c					      db	96
      1  260c		       60		      .byte.b	96
    965  260d				   GOSUBDONE
      0  260d					      RTN
      0  260d					      db	25
      1  260d		       19		      .byte.b	25
    967  260e
    968  260e		       26 0e	   ILEND      equ	*
------- FILE mytb.asm
   2387  260e		       26 0e	   PROGEND    equ	*
   2388  260e
   2389  260e
   2390  260e							;=====================================================
   2391  260e							; Define start of non page zero data
   2392 U2650					      seg.u	TBData
   2393 U2650
   2394 U2650							;=====================================================
   2395 U2650							; These are storage items not in page zero.
   2396 U2650							;
   2397 U2650							; IRQ BASIC Code Service RTN Support
      0 U2650				   SaveIrqReg db	0	; Store current setting
      1 U2650		       00		      .byte.b	0
      0 U2651				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U2651		       00		      .byte.b	0
      0 U2652				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U2652		       00		      .byte.b	0
      0 U2653				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U2653		       00 00		      .byte.b	0,0
   2402 U2655
   2403 U2655							;
   2404 U2655							;==================================================================================================
   2405 U2655							; Task Management information
   2406 U2655							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2407 U2655							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2408 U2655							; Task switchs happen at the beginning of the next Basic command line
   2409 U2655							; It will not happen during an input or output operations
   2410 U2655							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2411 U2655							; Task Zero is always the root task, main line program
   2412 U2655							;
   2413 U2655							; Layout is repeated for each configured task
   2414 U2655							; Task Table Byte   use masks follow
   2415 U2655		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2416 U2655		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2417 U2655		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2418 U2655		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2419 U2655		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2420 U2655
   2421 U2655		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2422 U2656		       00 00 00 00*taskTable  ds	(TASKCOUNT * (CONTEXTLEN + 1))	; Task Table Offset and pointer to Basic code, active flag
   2423 U2656		       27 50	   TASKTABLEEND equ	*	; End of task table
   2424 U2656		       00 fa	   TASKTABLELEN equ	(TASKTABLEEND-taskTable)	; actual length of the task table
   2425 U2750
   2426 U2750							;Task Cycle Counter and reset count
   2427 U2750		       00 00	   taskCurrentCycles ds	2
   2428 U2752		       00 00	   taskResetValue ds	2
   2429 U2754		       00	   taskCounter ds	1	; Count of active tasks
   2430 U2755
   2431 U2755							;
   2432 U2755							; Math stack and IL call and Gosub/For-next return stack definitions
   2433 U2755							;
   2434 U2755		       27 55	   STACKSTART equ	*
   2435 U2755		       00 00 00 00*mathStack  ds	(MATHSTACKSIZE * 2 * TASKCOUNT)	; Stack used for math expressions
   2436 U28e5		       00 00 00 00*ilStack    ds	(ILSTACKSIZE * 2 * TASKCOUNT)	; stack used by the IL for calls and returns
   2437 U2a75		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE * 4 * TASKCOUNT)	; stack size for gosub stacks
   2438 U2cf5		       00 00 00 00*variableStack ds	(VARIABLESSIZE * 2 * TASKCOUNT)	; Stack of variables, 26 A-Z-task exit code
   2439 U2cf5		       00 34	   TASKEXITCODE equ	(VARIABLESSIZE * 2 - 2)	; Offset to exit code location
   2440 U2cf5		       2f 11	   STACKEND   equ	*
   2441 U2cf5		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2442 U2f11							;
   2443 U2f11							;
   2444 U2f11		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2445 U2f95		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2446 U2f96		       00	   printtx    ds	1	;temp X for print funcs
   2447 U2f97		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2448 U2f98		       00	   promptChar ds	1	;the character to use for a prompt
   2449 U2f99		       00	   diddigit   ds	1	;for leading zero suppression
   2450 U2f9a		       00	   putsy      ds	1
   2451 U2f9b		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2452 U2f9d		       00	   sign       ds	1	;0 = positive, else negative
   2453 U2f9e		       00 00	   rtemp1     ds	2	;Temp for x and y
   2454 U2fa0		       00 00	   random     ds	2
   2455 U2fa2		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2456 U2fa4		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2457 U2fa6		       00	   tempy      ds	1	;temp y storage
   2458 U2fa7
   2459 U2fa7
   2460 U2fa7							; Moved from page zero as one clock cycle diff gives more space on page zero
   2461 U2fa7		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2462 U2fa9		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2463 U2faa		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2464 U2fab		       00	   lineLength ds	1	;Length of current line
   2465 U2fac
   2466 U2fac		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2467 U2fad		       00	   taskRDPending ds	1	; 1 = background read is pending
   2468 U2fae
   2469 U2fae				  -	      if	XKIM
   2470 U2fae				  -buffer     ds	BUFFER_SIZE
   2471 U2fae					      endif
   2472 U2fae							;
   2473 U2fae							; PROGRAMEND is the end of the user's BASIC program.
   2474 U2fae							; More precisely, it is one byte past the end.  Or,
   2475 U2fae							; it's where the next line added to the end will be
   2476 U2fae							; placed.
   2477 U2fae							;
   2478 U2fae		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2479 U2fb0		       00 00	   ProgramEnd ds	2	; End of users basic program
   2480 U2fb2		       00 00	   HighMem    ds	2	; highest location
   2481 U2fb4		       00 00	   UsedMem    ds	2	; size of user program
   2482 U2fb6		       00 00	   FreeMem    ds	2	; amount of free memory
   2483 U2fb8							;
   2484 U2fb8							;=====================================================
   2485 U2fb8							; This is the start of the user's BASIC program space.
   2486 U2fb8							;
   2487 U2fb8							; PERSONAL GOAL: This should be no larger than $0DFF.
   2488 U2fb8							;		  0200-05FF = 1K
   2489 U2fb8							;		  0200-09FF = 2K
   2490 U2fb8							;		  0200-0DFF = 3K
   2491 U2fb8							;		  0200-11FF = 4K
   2492 U2fb8							;		  0200-13FF = 4.5K
   2493 U2fb8							;
   2494 U2fb8				  -	      if	FIXED
   2495 U2fb8				  -	      org	$2000
   2496 U2fb8					      endif
   2497 U2fb8
   2498 U2fb8		       2f b8	   FreeMemStart equ	*
   2499 U2fb8							;/*
   2500 U2fb8							;	if	CTMON65 || XKIM
   2501 U2fb8							;		SEG Code
   2502 U2fb8							;		org	AutoRun
   2503 U2fb8							;		dw	TBasicCold
   2504 U2fb8							;	endif
   2505 U2fb8							;*/
   2506 U2fb8					      end
