------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2e31				   input      processor	6502
      2 U2e31 ????						;=====================================================
      3 U2e31 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2e31 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2e31 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2e31 ????						;
      7 U2e31 ????						; While working on the Corsham Technologies KIM Clone
      8 U2e31 ????						; project, I wanted to include a TINY BASIC since that
      9 U2e31 ????						; was a highly desirable feature of early computers.
     10 U2e31 ????						;
     11 U2e31 ????						; Rather than negotiating copyright issues for
     12 U2e31 ????						; existing BASICs, I decided to just write one from
     13 U2e31 ????						; scratch.
     14 U2e31 ????						;
     15 U2e31 ????						; 10/07/2017
     16 U2e31 ????						;
     17 U2e31 ????						; This implements a stripped down Tiny BASIC
     18 U2e31 ????						; interpreter using the Interpretive Language (IL)
     19 U2e31 ????						; method as described in the first few issues of
     20 U2e31 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2e31 ????						; to write various languages simply by changing the
     22 U2e31 ????						; IL code rather than the interpreter itself.
     23 U2e31 ????						;
     24 U2e31 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2e31 ????						;		* Fixed major bug in findLine that
     26 U2e31 ????						;		  caused corrupted lines, crashes, etc.
     27 U2e31 ????						;		* If no parameter given to RND, assume
     28 U2e31 ????						;		  32766.
     29 U2e31 ????						;		* No more error 5 when a program
     30 U2e31 ????						;		  reaches the end without an END.
     31 U2e31 ????						;
     32 U2e31 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2e31 ????						;		 * Unexpanded version to play with everything
     34 U2e31 ????						;		 * Add some usefull system level functions
     35 U2e31 ????						;		 * allow a larger number of tiny basic formats
     36 U2e31 ????						;		 * Add byte at start of line holding length
     37 U2e31 ????						;		   for faster execution of goto and gosub
     38 U2e31 ????						;		 * Re-added gosub
     39 U2e31 ????						;		 * allow ; or , at end if print stmt
     40 U2e31 ????						;		   without CRLF being added.
     41 U2e31 ????						;		 * Added extended function erase to
     42 U2e31 ????						;		   use the extended ctmon65 rm file
     43 U2e31 ????						;		 * Fix quoted text to not have to backtrack
     44 U2e31 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2e31 ????						;		 * Add concurrency features
     46 U2e31 ????						;
     47 U2e31 ????						; www.corshamtech.com
     48 U2e31 ????						; bob@corshamtech.com
     49 U2e31 ????						; JustLostInTime@gmail.com
     50 U2e31 ????						;
     51 U2e31 ????						;=====================================================
     52 U2e31 ????						;
     53 U2e31 ????						; Create TRUE and FALSE values for conditionals.
     54 U2e31 ????						;
     55 U2e31 ????
     56 U2e31 ????	       00 00	   FALSE      equ	0
     57 U2e31 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2e31 ????						;
     59 U2e31 ????						;---------------------------------------------------------
     60 U2e31 ????						; One of these must be set to indicate which environment
     61 U2e31 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2e31 ????						; environments:
     63 U2e31 ????						;
     64 U2e31 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2e31 ????						; more K of RAM.
     66 U2e31 ????						;
     67 U2e31 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2e31 ????						; which enhances, without replacing, the standard KIM
     69 U2e31 ????						; monitor.  It gives access to routines to save/load files
     70 U2e31 ????						; to a micro SD card.
     71 U2e31 ????						;
     72 U2e31 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2e31 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2e31 ????						; easily be ported to other systems.  It has support for
     75 U2e31 ????						; using a micro SD card for file storage/retrieval.
     76 U2e31 ????						;
     77 U2e31 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2e31 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2e31 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2e31 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2e31 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2e31 ????						;
     83 U2e31 ????						;   Need to define some macros for the dasm assembler
     84 U2e31 ????						;
     85 U2e31 ????				      MACRO	dw
     86 U2e31 ????				      .word	{0}
     87 U2e31 ????				      ENDM
     88 U2e31 ????
     89 U2e31 ????				      MACRO	db
     90 U2e31 ????				      .byte	{0}
     91 U2e31 ????				      ENDM
     92 U2e31 ????
     93 U2e31 ????						;
     94 U2e31 ????						; If set, include disk functions.
     95 U2e31 ????						;
     96 U2e31 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2e31 ????						;
     98 U2e31 ????						; If ILTRACE is set then dump out the address of every
     99 U2e31 ????						; IL opcode before executing it.
    100 U2e31 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2e31 ????						;
    102 U2e31 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2e31 ????						;
    104 U2e31 ????						; If FIXED is set, put the IL code and the user
    105 U2e31 ????						; program space at fixed locations in memory.	This is
    106 U2e31 ????						; meant only for debugging.
    107 U2e31 ????						;
    108 U2e31 ????	       00 00	   FIXED      equ	FALSE
    109 U2e31 ????						;
    110 U2e31 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2e31 ????						; BASIC, so keep this small!
    112 U2e31 ????						;
    113 U2e31 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2e31 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2e31 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2e31 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2e31 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2e31 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2e31 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2e31 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2e31 ????						;
    122 U2e31 ????						; Gosub entry types
    123 U2e31 ????
    124 U2e31 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2e31 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2e31 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2e31 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2e31 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2e31 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2e31 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2e31 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2e31 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2e31 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2e31 ????						;
    135 U2e31 ????						; Common ASCII constants
    136 U2e31 ????						;
    137 U2e31 ????	       00 07	   BEL	      equ	$07
    138 U2e31 ????	       00 08	   BS	      equ	$08
    139 U2e31 ????	       00 09	   TAB	      equ	$09
    140 U2e31 ????	       00 0a	   LF	      equ	$0A
    141 U2e31 ????	       00 0d	   CR	      equ	$0D
    142 U2e31 ????	       00 22	   quote      equ	$22
    143 U2e31 ????	       00 20	   SPACE      equ	$20
    144 U2e31 ????	       00 2c	   COMMA      equ	',
    145 U2e31 ????	       00 3b	   SEMICOLON  equ	';
    146 U2e31 ????	       00 3a	   COLON      equ	':
    147 U2e31 ????	       00 24	   DOLLAR     equ	'$
    148 U2e31 ????						;
    149 U2e31 ????						; These are error codes
    150 U2e31 ????						;
    151 U2e31 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2e31 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2e31 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2e31 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2e31 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2e31 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2e31 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2e31 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2e31 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2e31 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2e31 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2e31 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2e31 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2e31 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2e31 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2e31 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2e31 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2e31 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2e31 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2e31 ????						;
    171 U2e31 ????						;=====================================================
    172 U2e31 ????						; Zero page storage.
    173 U2e31 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  2487 ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       1c d7	   CRLF       equ	tbcrlf
    307  0206		       14 30	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       14 4d	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 06 1e    cold2      jsr	SetOutConsole
    314  0209		       20 13 1e 	      jsr	SetInConsole
    315  020c		       20 4d 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    319  0243							;
    320  0243		       20 e2 14 	      jsr	MemInit	;setup the free space available
    321  0246
    322  0246		       a9 01	   calcstack  lda	#1
    323  0248		       8d cd 25 	      sta	taskCounter	; Initialize number of tasks to 1
    324  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  024d		       8d cf 24 	      sta	taskTable	; mark the main task as active
    326  0250		       20 cf 15 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  0253		       a9 bf		      lda	#IL&$ff
    328  0255		       85 43		      sta	ILPC
    329  0257		       a9 20		      lda	#IL>>8
    330  0259		       85 44		      sta	ILPC+1
    331  025b							;
    332  025b							;		  lda	  ProgramStart		     ; user prog
    333  025b							;		  sta	  ProgramEnd
    334  025b							;		  lda	  ProgramStart+1
    335  025b							;		  sta	  ProgramEnd+1
    336  025b							;
    337  025b							;  Init time slices defaults
    338  025b		       a9 02		      lda	#TASKCYCLESHIGH
    339  025d		       8d cc 25 	      sta	taskResetValue+1
    340  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  0262		       8d cb 25 	      sta	taskResetValue
    342  0265							;
    343  0265							; Initialize the pseudo-random number sequence...
    344  0265							;
    345  0265		       a9 5a		      lda	#$5a
    346  0267		       8d 17 2e 	      sta	rtemp1
    347  026a		       a9 9d		      lda	#%10011101
    348  026c		       8d 19 2e 	      sta	random
    349  026f		       a9 5b		      lda	#%01011011
    350  0271		       8d 1a 2e 	      sta	random+1
    351  0274							;
    352  0274							;   Insert a Basic irq handler for the basic Language
    353  0274		       a9 81		      lda	#ServiceIrq&$ff
    354  0276		       8d 00 df 	      sta	IRQvec
    355  0279		       a9 02		      lda	#ServiceIrq>>8
    356  027b		       8d 01 df 	      sta	IRQvec+1
    357  027e		       4c a6 02 	      jmp	coldtwo
    358  0281
    359  0281							;
    360  0281							; This is the Basic IRQ handler
    361  0281		       48	   ServiceIrq pha
    362  0282		       ad ca 24 	      lda	IRQStatus
    363  0285		       f0 0a		      BEQ	RetIrq
    364  0287		       ad cb 24 	      lda	IRQPending
    365  028a		       d0 05		      bne	RetIrq
    366  028c		       a9 01		      lda	#1
    367  028e		       8d cb 24 	      sta	IRQPending
    368  0291		       68	   RetIrq     pla
    369  0292		       40		      rti
    370  0293							;
    371  0293							;
    372  0293							; This is the warm start entry point
    373  0293							;
    374  0293		       20 06 1e    warm2      jsr	SetOutConsole
    375  0296		       20 13 1e 	      jsr	SetInConsole
    376  0299		       20 d7 1c 	      jsr	CRLF
    377  029c		       ad 14 2e 	      lda	errGoto
    378  029f		       85 43		      sta	ILPC
    379  02a1		       ad 15 2e 	      lda	errGoto+1
    380  02a4		       85 44		      sta	ILPC+1
    381  02a6							;
    382  02a6							; And continue with both starts here
    383  02a6							;
    384  02a6				   coldtwo
    385  02a6							;
    386  02a6							; The ILTrace flag is now run-time settable.
    387  02a6							;
    388  02a6		       a9 00		      lda	#ILTRACE&$ff
    389  02a8		       85 40		      sta	ILTrace
    390  02aa							;
    391  02aa
    392  02aa		       a9 00		      lda	#0
    393  02ac		       85 5b		      sta	RunMode
    394  02ae		       8d 8a 2d 	      sta	LINBUF
    395  02b1
    396  02b1							; Clear everything from the stacks
    397  02b1
    398  02b1		       8d 25 2e 	      sta	taskIOPending	; No one waiting for io
    399  02b4		       8d 26 2e 	      sta	taskRDPending	; No one waiting for bg io
    400  02b7
    401  02b7		       20 42 16 	      jsr	taskReset
    402  02ba							;
    403  02ba		       a9 8a		      lda	#LINBUF&$ff
    404  02bc		       85 4f		      sta	CURPTR
    405  02be		       a9 2d		      lda	#LINBUF>>8
    406  02c0		       85 50		      sta	CURPTR+1	;fall through...
    407  02c2
    408  02c2							;=====================================================
    409  02c2							; This is the top of the IL interpreter.  This fetches
    410  02c2							; and executes the instruction currently pointed to
    411  02c2							; by ILPC and adjusts ILPC to point to the next
    412  02c2							; instruction to execute.
    413  02c2							;
    414  02c2		       ce c9 25    NextIL     dec	taskCurrentCycles
    415  02c5		       d0 03		      bne	NextIlNow
    416  02c7		       20 6b 16 	      jsr	iTaskSwitch	;check for a task switch
    417  02ca		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02cc		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02ce
    420  02ce		       20 63 1d 	      jsr	dbgLine	;Print the IL trace information
    421  02d1
    422  02d1		       a4 51	   NextIL2    ldy	CUROFF
    423  02d3							;		  jsr	  SkipSpaces
    424  02d3							;		  sty	  CUROFF
    425  02d3							;Task IO Management
    426  02d3		       ad 26 2e 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d6		       f0 08		      beq	NextILStr
    428  02d8		       20 1e 1b 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02db		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02dd		       ce 26 2e 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02e0							;
    432  02e0		       20 a1 19    NextILStr  jsr	getILByte
    433  02e3							;
    434  02e3							; When the handler is called, these are the conditions
    435  02e3							; of several important items:
    436  02e3							;
    437  02e3							;    (ILPC) will point to the byte AFTER the IL
    438  02e3							;    opcode being executed.
    439  02e3							;
    440  02e3							;    (CURPTR),CUROFF will point to the start of the
    441  02e3							;    next word in the input buffer.  Ie, the next word
    442  02e3							;    in the user program.
    443  02e3							;
    444  02e3		       0a		      asl
    445  02e4		       c9 d4		      cmp	#ILTBLend-ILTBL+2
    446  02e6		       90 33		      bcc	ILgood
    447  02e8							;
    448  02e8							; This handles an illegal IL opcode.  This is serious
    449  02e8							; and there's no way to recover.
    450  02e8							;
    451  02e8		       20 4d 14    ILbad      jsr	puts
      0  02eb					      db	CR,LF
      1  02eb		       0d 0a		      .byte.b	CR,LF
      0  02ed					      db	"Illegal IL "
      1  02ed		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f8					      db	0
      1  02f8		       00		      .byte.b	0
    455  02f9							;
    456  02f9							; Well this is awkward, we need to back up the IL
    457  02f9							; by one since it no longer points to the current
    458  02f9							; opcode.
    459  02f9							;
    460  02f9		       20 ae 19 	      jsr	decIL
    461  02fc							;
    462  02fc		       a0 00		      ldy	#0
    463  02fe		       b1 43		      lda	(ILPC),y
    464  0300		       20 30 14 	      jsr	OUTHEX
    465  0303		       20 4d 14 	      jsr	puts
      0  0306					      db	" at ",0
      1  0306		       20 61 74 20*	      .byte.b	" at ",0
    467  030b		       a5 44		      lda	ILPC+1
    468  030d		       20 30 14 	      jsr	OUTHEX
    469  0310		       a5 43		      lda	ILPC
    470  0312		       20 30 14 	      jsr	OUTHEX
    471  0315		       20 d7 1c 	      jsr	CRLF
    472  0318		       4c 03 f0 	      jmp	MONITOR
    473  031b							;
    474  031b							; Just jump to the address (ILPC),y.  Have to do
    475  031b							; some goofy stuff.
    476  031b							;
    477  031b		       a8	   ILgood     tay		;move index into Y
    478  031c		       b9 29 03 	      lda	ILTBL,y
    479  031f		       85 59		      sta	dpl
    480  0321		       b9 2a 03 	      lda	ILTBL+1,y
    481  0324		       85 5a		      sta	dpl+1
    482  0326		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0329							;
    484  0329							;=====================================================
    485  0329							; This is the IL jump table.  The IL opcode is
    486  0329							; mulitplied by two, then looked-up in this table.
    487  0329							; There is absolutely nothing special about the order
    488  0329							; of entries here... they all decode at exactly the
    489  0329							; same speed.	However the entry number must match the
    490  0329							; values in IL.inc.
    491  0329							;
    492  0329				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0329					      include	"ilvectortable.asm"
      1  0329					      seg	Code
      2  0329
      0  0329					      dw	iXINIT	;0
      1  0329		       33 04		      .word.w	iXINIT
      0  032b					      dw	iDONE	;1
      1  032b		       4e 04		      .word.w	iDONE
      0  032d					      dw	iPRS	;2
      1  032d		       67 04		      .word.w	iPRS
      0  032f					      dw	iPRN	;3
      1  032f		       6f 04		      .word.w	iPRN
      0  0331					      dw	iSPC	;4
      1  0331		       78 04		      .word.w	iSPC
      0  0333					      dw	iNLINE	;5
      1  0333		       ee 08		      .word.w	iNLINE
      0  0335					      dw	iNXT	;6
      1  0335		       80 04		      .word.w	iNXT
      0  0337					      dw	iXFER	;7
      1  0337		       a6 04		      .word.w	iXFER
      0  0339					      dw	iSAV	;8
      1  0339		       d3 04		      .word.w	iSAV
      0  033b					      dw	iRSTR	;9
      1  033b		       16 05		      .word.w	iRSTR
      0  033d					      dw	iCMPR	;10
      1  033d		       4b 05		      .word.w	iCMPR
      0  033f					      dw	iINNUM	;11
      1  033f		       cc 05		      .word.w	iINNUM
      0  0341					      dw	iFIN	;12
      1  0341		       00 06		      .word.w	iFIN
      0  0343					      dw	iERR	;13
      1  0343		       14 06		      .word.w	iERR
      0  0345					      dw	iADD	;14
      1  0345		       84 06		      .word.w	iADD
      0  0347					      dw	iSUB	;15
      1  0347		       9a 06		      .word.w	iSUB
      0  0349					      dw	iNEG	;16
      1  0349		       b0 06		      .word.w	iNEG
      0  034b					      dw	iMUL	;17
      1  034b		       c8 06		      .word.w	iMUL
      0  034d					      dw	iDIV	;18
      1  034d		       08 07		      .word.w	iDIV
      0  034f					      dw	iSTORE	;19
      1  034f		       5e 07		      .word.w	iSTORE
      0  0351					      dw	iIND	;20
      1  0351		       76 07		      .word.w	iIND
      0  0353					      dw	iLST	;21
      1  0353		       e4 07		      .word.w	iLST
      0  0355					      dw	iINIT	;22
      1  0355		       fb 03		      .word.w	iINIT
      0  0357					      dw	iGETLINE	;23
      1  0357		       1a 08		      .word.w	iGETLINE
      0  0359					      dw	iINSRT	;24
      1  0359		       37 08		      .word.w	iINSRT
      0  035b					      dw	iRTN	;25
      1  035b		       e8 08		      .word.w	iRTN
      0  035d					      dw	MONITOR	;26
      1  035d		       03 f0		      .word.w	MONITOR
      0  035f					      dw	iLIT	;27
      1  035f		       0e 09		      .word.w	iLIT
      0  0361					      dw	iCALL	;28
      1  0361		       f4 08		      .word.w	iCALL
      0  0363					      dw	iJMP	;29
      1  0363		       fc 08		      .word.w	iJMP
      0  0365					      dw	iVINIT	;30
      1  0365		       2b 09		      .word.w	iVINIT
      0  0367					      dw	iERRGOTO	;31
      1  0367		       31 09		      .word.w	iERRGOTO
      0  0369					      dw	iTST	;32
      1  0369		       3d 09		      .word.w	iTST
      0  036b					      dw	iTSTV	;33
      1  036b		       62 0a		      .word.w	iTSTV
      0  036d					      dw	iTSTL	;34
      1  036d		       d9 0a		      .word.w	iTSTL
      0  036f					      dw	iTSTN	;35
      1  036f		       f4 0a		      .word.w	iTSTN
      0  0371					      dw	iFREE	;36
      1  0371		       a3 0b		      .word.w	iFREE
      0  0373					      dw	iRANDOM	;37
      1  0373		       ac 0b		      .word.w	iRANDOM
      0  0375					      dw	iABS	;38
      1  0375		       7d 0c		      .word.w	iABS
     42  0377							;
     43  0377							; Disk functions.  There must be pointers
     44  0377							; to functions even if no disk is supported.
     45  0377							; Makes things easier in IL.inc.
     46  0377							;
     47  0377					      if	DISK_ACCESS
      0  0377					      dw	iOPENREAD	;39
      1  0377		       17 1f		      .word.w	iOPENREAD
      0  0379					      dw	iOPENWRITE	;40
      1  0379		       78 1f		      .word.w	iOPENWRITE
      0  037b					      dw	iDCLOSE	;41
      1  037b		       fc 1f		      .word.w	iDCLOSE
      0  037d					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037d		       8a 1f		      .word.w	iDGETLINE
      0  037f					      dw	iDLIST	;43 Did you remember your towel?
      1  037f		       f6 1f		      .word.w	iDLIST
      0  0381					      dw	iDDIR	;44
      1  0381		       d1 1f		      .word.w	iDDIR
      0  0383					      dw	iRMFILE	;45
      1  0383		       66 1f		      .word.w	iRMFILE
     55  0385				  -	      else
     56  0385				  -	      dw	NextIL	;39
     57  0385				  -	      dw	NextIL	;40
     58  0385				  -	      dw	NextIL	;41
     59  0385				  -	      dw	NextIL	;42
     60  0385				  -	      dw	NextIL	;43
     61  0385				  -	      dw	NextIL	;44
     62  0385				  -	      dw	NextIL	;45
     63  0385					      endif
     64  0385							;
      0  0385					      dw	iCLEARSCREEN	;46
      1  0385		       26 1e		      .word.w	iCLEARSCREEN
      0  0387					      dw	iPOKEMEMORY	;47
      1  0387		       0a 0c		      .word.w	iPOKEMEMORY
      0  0389					      dw	iPEEKMEMORY	;48
      1  0389		       1f 0c		      .word.w	iPEEKMEMORY
      0  038b					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  038b		       84 09		      .word.w	iTSTLET
      0  038d					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038d		       09 0a		      .word.w	iTSTDONE
      0  038f					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038f		       4c 0c		      .word.w	iGETCHAR
      0  0391					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0391		       60 0c		      .word.w	iPUTCHAR
      0  0393					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0393		       35 0c		      .word.w	iCallFunc
      0  0395					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0395		       9c 05		      .word.w	iBranch
      0  0397					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0397		       67 09		      .word.w	iTSTStr
      0  0399					      dw	iSetIrq	;56	   sets the irq handler
      1  0399		       fa 0c		      .word.w	iSetIrq
      0  039b					      dw	iTstIrq	;57	   test if irq is pending
      1  039b		       6b 0b		      .word.w	iTstIrq
      0  039d					      dw	iRET	;58	   return from interupt
      1  039d		       04 05		      .word.w	iRET
      0  039f					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039f		       e3 05		      .word.w	iINSTR
      0  03a1					      dw	iMOD	;60	   returns remainder of division
      1  03a1		       11 07		      .word.w	iMOD
      0  03a3					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a3		       bf 16		      .word.w	iTaskSet
      0  03a5					      dw	iETask	;62	   Terminates a task
      1  03a5		       ea 17		      .word.w	iETask
      0  03a7					      dw	iNTask	;63	   goto next task
      1  03a7		       9d 17		      .word.w	iNTask
      0  03a9					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a9		       8b 07		      .word.w	iArray
      0  03ab					      dw	iTaskKill	;65	   kill a running task
      1  03ab		       95 17		      .word.w	iTaskKill
      0  03ad					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ad		       69 17		      .word.w	iTaskStat
      0  03af					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03af		       6b 0c		      .word.w	iHexOut
      0  03b1					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b1		       b8 05		      .word.w	iReadComplete
      0  03b3					      dw	iReadStart	;69	   Called to start a background read request
      1  03b3		       ae 05		      .word.w	iReadStart
      0  03b5					      dw	iStartIO	;70	   Lock task until io complete
      1  03b5		       cd 17		      .word.w	iStartIO
      0  03b7					      dw	iEndIO	;71	   release task lock for io
      1  03b7		       d3 17		      .word.w	iEndIO
      0  03b9					      dw	iLogNot	;72	   Logical not
      1  03b9		       d6 0c		      .word.w	iLogNot
      0  03bb					      dw	iLogOr	;73	   Logical Or
      1  03bb		       ac 0c		      .word.w	iLogOr
      0  03bd					      dw	iLogAnd	;74	   Logical And
      1  03bd		       97 0c		      .word.w	iLogAnd
      0  03bf					      dw	iLogXor	;75	   Logical Xor
      1  03bf		       c1 0c		      .word.w	iLogXor
      0  03c1					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c1		       a8 17		      .word.w	iWTASK
      0  03c3					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c3		       de 17		      .word.w	iTASKPID
      0  03c5					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c5		       36 0d		      .word.w	iTRACEPROG
      0  03c7					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c7		       e4 1c		      .word.w	idbgBasic
      0  03c9					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c9		       a0 18		      .word.w	iIPCS
      0  03cb					      dw	iIPCR	;81	   Recieve a message from a task
      1  03cb		       b7 18		      .word.w	iIPCR
      0  03cd					      dw	iIPCC	;82	   Check if any message available for task
      1  03cd		       cb 18		      .word.w	iIPCC
      0  03cf					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cf		       d8 18		      .word.w	iIPCIO
      0  03d1					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d1		       37 15		      .word.w	iPushMathStack
      0  03d3					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d3		       67 15		      .word.w	iPopMathStack
      0  03d5					      dw	iSaveMathStack	;86	   Save all math info
      1  03d5		       84 15		      .word.w	iSaveMathStack
      0  03d7					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d7		       a3 15		      .word.w	iRestoreMathStack
      0  03d9					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d9		       54 15		      .word.w	iIncParmCount
      0  03db					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03db		       0a 18		      .word.w	iTaskGetMathStack
      0  03dd					      dw	iTaskEnable	;90	   enable a suspended task
      1  03dd		       37 17		      .word.w	iTaskEnable
      0  03df					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03df		       51 17		      .word.w	iTaskSuspend
      0  03e1					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e1		       24 18		      .word.w	iTaskPutMathPtr
      0  03e3					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e3		       59 0a		      .word.w	iTSTVT
      0  03e5					      dw	iSetR2	;94
      1  03e5		       06 09		      .word.w	iSetR2
      0  03e7					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e7		       e2 04		      .word.w	iStk2Tmp
      0  03e9					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e9		       f3 04		      .word.w	iTmp2Stk
      0  03eb					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03eb		       a5 09		      .word.w	iTSTBYTE
      0  03ed					      dw	iINCVAR	;98	   Increment variable
      1  03ed		       2b 0a		      .word.w	iINCVAR
      0  03ef					      dw	iDECVAR	;99	   Decrement variable
      1  03ef		       43 0a		      .word.w	iDECVAR
      0  03f1					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f1		       33 18		      .word.w	iSLICE
      0  03f3					      dw	iTSTB	;101	   Test if byte equals
      1  03f3		       c4 09		      .word.w	iTSTB
      0  03f5					      dw	iTSTW	;102	   Test If word equals
      1  03f5		       df 09		      .word.w	iTSTW
      0  03f7					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03f7		       26 13		      .word.w	iOnGoto
      0  03f9					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f9		       57 13		      .word.w	iTSTRELOP
    124  03fb
------- FILE mytb.asm
    494  03fb		       03 fb	   ILTBLend   equ	*
    495  03fb							;
    496  03fb							;=====================================================
    497  03fb							;=====================================================
    498  03fb							;=====================================================
    499  03fb							; This marks the start of the handlers for IL opcodes.
    500  03fb							;=====================================================
    501  03fb							;=====================================================
    502  03fb							;=====================================================
    503  03fb							;
    504  03fb							;
    505  03fb		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03fd		       85 47		      sta	ILSTACKPTR
    507  03ff		       85 4a		      sta	MATHSTACKPTR
    508  0401		       85 4d		      sta	GOSUBSTACKPTR
    509  0403		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  0405		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  0407							;
    512  0407		       ad 27 2e 	      lda	ProgramStart	;user prog
    513  040a		       85 4f		      sta	CURPTR
    514  040c		       8d d0 24 	      sta	taskTable+1
    515  040f		       8d 29 2e 	      sta	ProgramEnd
    516  0412		       ad 28 2e 	      lda	ProgramStart+1
    517  0415		       85 50		      sta	CURPTR+1
    518  0417		       8d d1 24 	      sta	taskTable+2
    519  041a		       8d 2a 2e 	      sta	ProgramEnd+1
    520  041d		       a9 80		      lda	#TASKACTIVE
    521  041f		       8d cf 24 	      sta	taskTable	;Mark the first slot as active
    522  0422		       a9 01		      lda	#1
    523  0424		       8d cd 25 	      sta	taskCounter	;there is always one task / Main task
    524  0427		       ad cb 25 	      lda	taskResetValue
    525  042a		       8d c9 25 	      sta	taskCurrentCycles	; set up the task switch counts
    526  042d		       ad cc 25 	      lda	taskResetValue+1
    527  0430		       8d ca 25 	      sta	taskCurrentCycles+1
    528  0433							;
    529  0433							; fall into XINIT...
    530  0433							;
    531  0433							;=====================================================
    532  0433							; This initializes for the start of the next line of
    533  0433							; BASIC text.
    534  0433							;
    535  0433		       78	   iXINIT     sei		;ensure interupts are off
    536  0434		       20 42 16 	      jsr	taskReset	;Clear the task table
    537  0437		       8d cb 24 	      sta	IRQPending	; reset the irq pending
    538  043a		       8d ca 24 	      sta	IRQStatus	; Make sure irqs are off
    539  043d
    540  043d		       4c c2 02    goodExit   jmp	NextIL
    541  0440							;
    542  0440							;=====================================================
    543  0440							; This check if the escape key has been entered
    544  0440							; then changes out of run mode. z Set if esc found
    545  0440				   BreakSet
    546  0440		       20 0f f0 	      jsr	ISCHAR
    547  0443		       f0 06		      beq	BreakNo
    548  0445		       20 23 1e 	      jsr	VGETCH
    549  0448		       c9 1b		      cmp	#$1B
    550  044a		       60		      rts
    551  044b				   BreakNo
    552  044b		       a9 01		      lda	#1
    553  044d		       60		      rts
    554  044e
    555  044e							;
    556  044e
    557  044e							;=====================================================
    558  044e							; Verify there is nothing else on this input line.
    559  044e							; If there is, generate an error.
    560  044e							;
    561  044e		       a4 51	   iDONE      ldy	CUROFF
    562  0450		       b1 4f		      lda	(CURPTR),y
    563  0452		       f0 10		      beq	doneadv
    564  0454		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    565  0456		       d0 05		      bne	idoneErr
    566  0458		       84 51		      sty	CUROFF
    567  045a		       4c c2 02 	      jmp	NextIL	; continue on this line
    568  045d
    569  045d				   idoneErr
    570  045d		       a2 04		      ldx	#ERR_EXTRA_STUFF
    571  045f		       a9 00		      lda	#0
    572  0461		       4c 17 06 	      jmp	iErr2
    573  0464							;
    574  0464							; Advance to the next line
    575  0464							;
    576  0464				   doneadv
    577  0464		       4c c2 02 	      jmp	NextIL
    578  0467							;
    579  0467							;=====================================================
    580  0467							; Print the string until a closing quote
    581  0467							;
    582  0467				   iPRS
    583  0467		       20 77 14 	      jsr	PrtQuoted
    584  046a		       84 51		      sty	CUROFF
    585  046c		       4c c2 02 	      jmp	NextIL
    586  046f							;
    587  046f							;=====================================================
    588  046f							; Pop the top off the stack and print it as a signed
    589  046f							; decimal number.
    590  046f							;
    591  046f				   iPRN
    592  046f		       20 1e 1c 	      jsr	popR0
    593  0472		       20 7e 13 	      jsr	PrintDecimal
    594  0475		       4c c2 02 	      jmp	NextIL
    595  0478							;
    596  0478							;=====================================================
    597  0478							; Space to next zone.	Currently the code does not
    598  0478							; keep track of which column the output is on, so
    599  0478							; just print a tab.
    600  0478							;
    601  0478				   iSPC
    602  0478		       a9 09		      lda	#TAB
    603  047a		       20 20 1e 	      jsr	VOUTCH
    604  047d		       4c c2 02 	      jmp	NextIL
    605  0480							;
    606  0480							;=====================================================
    607  0480							; If in immediate mode, jump to the address following
    608  0480							; the NXT instruction.  Else move to the next line of
    609  0480							; user code and continue.
    610  0480							;
    611  0480		       a5 5b	   iNXT       lda	RunMode
    612  0482		       d0 03		      bne	iNxtRun	;in run mode
    613  0484							;
    614  0484							; Get address and jump to it.
    615  0484							;
    616  0484		       4c fc 08 	      jmp	iJMP
    617  0487							;
    618  0487				   iNxtRun
    619  0487		       a4 51		      ldy	CUROFF
    620  0489		       b1 4f		      lda	(CURPTR),y
    621  048b		       c9 e6		      cmp	#oColon
    622  048d		       d0 06		      bne	iNxtRunGo
    623  048f		       c8		      iny
    624  0490		       84 51		      sty	CUROFF
    625  0492		       4c a0 04 	      jmp	iNxtRun2
    626  0495
    627  0495				   iNxtRunGo
    628  0495		       20 2b 1a 	      jsr	FindNextLine
    629  0498		       20 3f 1a 	      jsr	AtEnd
    630  049b		       d0 03		      bne	iNxtRun2	;not at end
    631  049d							;
    632  049d							; At the end of the program.  Pretend an END statement
    633  049d							; was found.
    634  049d							;
    635  049d		       4c 00 06    iFINv      jmp	iFIN
    636  04a0							;
    637  04a0		       20 9d 19    iNxtRun2   jsr	getILWord	;ignore next word
    638  04a3		       4c c2 02 	      jmp	NextIL
    639  04a6							;
    640  04a6							;=====================================================
    641  04a6							; XFER takes the number on top of the stack and looks
    642  04a6							; for that line in the program, or the next line
    643  04a6							; higher.  Ie, if it's 1 but there is no line 1, then
    644  04a6							; find the next one after that.
    645  04a6							;
    646  04a6		       20 1e 1c    iXFER      jsr	popR0
    647  04a9		       20 e6 19 	      jsr	findLine
    648  04ac		       20 3f 1a    iXFER2     jsr	AtEnd	;at end of user program?
    649  04af		       f0 ec		      beq	iFINv
    650  04b1		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    651  04b3		       84 51		      sty	CUROFF
    652  04b5		       a9 ff		      lda	#$ff
    653  04b7		       85 5b		      sta	RunMode
    654  04b9							;
    655  04b9							; Transfer IL to STMT.  I don't like having this
    656  04b9							; hard-coded; fix it.
    657  04b9							;
    658  04b9		       a9 cd		      lda	#STMT&$ff
    659  04bb		       85 43		      sta	ILPC
    660  04bd		       a9 20		      lda	#STMT>>8
    661  04bf		       85 44		      sta	ILPC+1
    662  04c1		       4c c2 02 	      jmp	NextIL
    663  04c4							;
    664  04c4							; Run
    665  04c4							;
    666  04c4				   iXferok
    667  04c4		       a9 ff		      lda	#$ff
    668  04c6		       85 5b		      sta	RunMode	;we're running
    669  04c8							;
    670  04c8							; Need a more elegant way to do this
    671  04c8							;
    672  04c8		       a9 cd		      lda	#STMT&$ff
    673  04ca		       85 43		      sta	ILPC
    674  04cc		       a9 20		      lda	#STMT>>8
    675  04ce		       85 44		      sta	ILPC+1
    676  04d0		       4c c2 02 	      jmp	NextIL
    677  04d3							;
    678  04d3							;=====================================================
    679  04d3							; Save the pointer to the next line to the call stack.
    680  04d3							;
    681  04d3		       20 b4 1b    iSAV       jsr	pushLN
    682  04d6		       b0 03		      bcs	iSAVErr
    683  04d8		       4c c2 02 	      jmp	NextIL
    684  04db
    685  04db		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    686  04dd		       a9 00	   iSAVErr2   lda	#0
    687  04df		       4c 17 06 	      jmp	iErr2
    688  04e2							;====================================================
    689  04e2							; Move stack top to and from temp area
    690  04e2				   iStk2Tmp
    691  04e2		       20 1e 1c 	      jsr	popR0
    692  04e5		       a5 52		      lda	R0
    693  04e7		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    694  04e9		       91 41		      sta	(VARIABLES),y
    695  04eb		       c8		      iny
    696  04ec		       a5 53		      lda	R0+1
    697  04ee		       91 41		      sta	(VARIABLES),y
    698  04f0		       4c c2 02 	      jmp	NextIL
    699  04f3
    700  04f3		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    701  04f5		       b1 41		      lda	(VARIABLES),y
    702  04f7		       85 52		      sta	R0
    703  04f9		       c8		      iny
    704  04fa		       b1 41		      lda	(VARIABLES),y
    705  04fc		       85 53		      sta	R0+1
    706  04fe		       20 9a 1b 	      jsr	pushR0
    707  0501		       4c c2 02 	      jmp	NextIL
    708  0504							;
    709  0504							;=====================================================
    710  0504							; Pop the next line from the call stack.
    711  0504							;
    712  0504		       20 d9 1b    iRET       jsr	popLN
    713  0507		       b0 d2		      bcs	iSAVErr
    714  0509		       a0 03		      ldy	#3
    715  050b		       84 51		      sty	CUROFF
    716  050d		       a9 00		      lda	#0
    717  050f		       8d cb 24 	      sta	IRQPending
    718  0512		       58		      cli
    719  0513		       4c c2 02 	      jmp	NextIL
    720  0516							;
    721  0516							;=====================================================
    722  0516							; Return from GOSUB function
    723  0516							;
    724  0516		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    725  0518		       f0 0f		      beq	iRSTRNoValue
    726  051a		       a5 58		      lda	R2
    727  051c		       85 56		      sta	MQ
    728  051e		       88		      dey
    729  051f		       b1 4b		      lda	(GOSUBSTACK),y
    730  0521		       c9 81		      cmp	#GOSUB_RTN_VALUE
    731  0523		       d0 04		      bne	iRSTRNoValue
    732  0525		       a9 01		      lda	#1
    733  0527		       d0 02		      bne	iRSTRExit
    734  0529				   iRSTRNoValue
    735  0529		       a9 00		      lda	#0
    736  052b				   iRSTRExit
    737  052b		       85 58		      sta	R2
    738  052d		       20 d9 1b 	      jsr	popLN
    739  0530		       b0 06		      bcs	iRSTRErr
    740  0532		       20 6d 15 	      jsr	PopMathStackNow
    741  0535		       4c c2 02 	      jmp	NextIL
    742  0538
    743  0538		       ad ce 24    iRSTRErr   lda	taskPtr	; Check if this is task zero
    744  053b		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    745  053d		       a5 56		      lda	MQ
    746  053f		       d0 03		      bne	taskRet
    747  0541		       20 3b 1e 	      jsr	pushFalse	; the result code by default is 0
    748  0544				   taskRet
    749  0544		       4c ea 17 	      jmp	iETask	; not task zero then do a task end instead
    750  0547				   taskZeroEnd
    751  0547		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    752  0549		       d0 92		      bne	iSAVErr2
    753  054b							;
    754  054b							;=====================================================
    755  054b							; Compare items on stack.  Okay, so on input there are
    756  054b							; three things on the stack
    757  054b							;
    758  054b							;    EXPR2 <- Top of stack
    759  054b							;    OP    <- relational operator, next on stack
    760  054b							;    EXPR1 <- last item on stack
    761  054b							;
    762  054b							; Comparison is: EXPR1 <operator> EXPR2
    763  054b							;
    764  054b							; Operator is one of...
    765  054b							;
    766  054b							;    2 is =
    767  054b							;    1 is <
    768  054b							;    3 is <=
    769  054b							;    5 is <>
    770  054b							;    4 is >
    771  054b							;    6 is >=
    772  054b							;
    773  054b							; Those are bit-mapped:
    774  054b							;
    775  054b							;    xxxxxGEL
    776  054b							;
    777  054b							;    G = Greater than
    778  054b							;    E = Equal
    779  054b							;    L = Less than
    780  054b							;
    781  054b							; If the comparison is false, do a NXT, ie, move to the
    782  054b							; next line and continue.  If true, continue executing
    783  054b							; on this line.
    784  054b							;
    785  054b		       00 01	   REL_LT     equ	%001
    786  054b		       00 02	   REL_EQUAL  equ	%010
    787  054b		       00 04	   REL_GT     equ	%100
    788  054b							;
    789  054b		       20 36 1c    iCMPR      jsr	popR1
    790  054e		       20 4d 1c 	      jsr	popMQ	;operator in MQ
    791  0551		       20 1e 1c 	      jsr	popR0
    792  0554		       20 5d 05 	      jsr	iCMPRsub
    793  0557		       20 9a 1b 	      jsr	pushR0
    794  055a		       4c c2 02 	      jmp	NextIL
    795  055d							;
    796  055d							; See if they are equal or not
    797  055d							;
    798  055d				   iCMPRsub		; Called by internal functions
    799  055d
    800  055d		       a5 52		      lda	R0
    801  055f		       c5 54		      cmp	R1
    802  0561		       d0 0a		      bne	iCMPRnoteq	;try not equal
    803  0563		       a5 53		      lda	R0+1
    804  0565		       c5 55		      cmp	R1+1
    805  0567		       d0 04		      bne	iCMPRnoteq
    806  0569							;
    807  0569							; Equal, set the flag in MQ+1
    808  0569							;
    809  0569		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    810  056b		       d0 14		      bne	iCMPcom	;Exit it is equal
    811  056d							;
    812  056d							; See if EXPR1 (R0) < EXPR2 (R1)
    813  056d							; See www.6502.org/tutorials/compare_beyond.html
    814  056d							;
    815  056d				   iCMPRnoteq
    816  056d		       a5 52		      lda	R0
    817  056f		       c5 54		      cmp	R1
    818  0571		       a5 53		      lda	R0+1
    819  0573		       e5 55		      sbc	R1+1
    820  0575		       50 02		      bvc	iCMPR_2
    821  0577		       49 80		      eor	#$80
    822  0579		       30 04	   iCMPR_2    bmi	iCMPlt
    823  057b		       a9 04		      lda	#REL_GT
    824  057d		       d0 02		      bne	iCMPcom
    825  057f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    826  0581
    827  0581		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    828  0583							;
    829  0583							; Now compare the end result with what the caller
    830  0583							; was looking for.
    831  0583							;
    832  0583		       25 56		      and	MQ
    833  0585		       f0 0c		      beq	iCMPno	; no match
    834  0587		       a9 ff		      lda	#$FF	; true is $ffff
    835  0589		       85 52		      sta	R0
    836  058b		       85 53		      sta	R0+1
    837  058d		       d0 0c		      bne	iCMPDone
    838  058f							;
    839  058f							; R0 > R1
    840  058f							;
    841  058f		       a9 04	   iCMPgt     lda	#REL_GT
    842  0591		       d0 ee		      bne	iCMPcom
    843  0593				   iCMPno
    844  0593		       a9 00		      lda	#0
    845  0595		       85 52		      sta	R0
    846  0597		       a9 00		      lda	#0
    847  0599		       85 53		      sta	R0+1
    848  059b
    849  059b				   iCMPDone
    850  059b		       60		      rts
    851  059c
    852  059c							;
    853  059c							; if Not a match, so jump to the next line of code.
    854  059c							; Branches based upon value on top of the stack
    855  059c				   iBranch
    856  059c		       20 1e 1c 	      jsr	popR0
    857  059f		       a5 52		      lda	R0
    858  05a1		       05 53		      ora	R0+1
    859  05a3		       f0 03		      beq	iBranchFalse	; not true
    860  05a5		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    861  05a8							;
    862  05a8				   iBranchFalse
    863  05a8		       20 2b 1a 	      jsr	FindNextLine
    864  05ab		       4c ac 04 	      jmp	iXFER2
    865  05ae							;
    866  05ae							;=====================================================
    867  05ae							; Start a read of data in background
    868  05ae				   iReadStart
    869  05ae		       a9 3f		      lda	#'?	; Prompt with question mark
    870  05b0		       a6 01		      ldx	1	; Indicate to start read in background
    871  05b2		       20 b7 1a 	      jsr	GetLine	; Call the getline to start read
    872  05b5		       4c c2 02 	      jmp	NextIL	; next instruction
    873  05b8							;
    874  05b8							;=====================================================
    875  05b8							; Complete the read and return the curptr, curoff pointing to data
    876  05b8				   iReadComplete
    877  05b8		       20 b4 1b 	      jsr	pushLN
    878  05bb		       90 03		      bcc	iReadOk
    879  05bd		       4c 9c 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    880  05c0				   iReadOk
    881  05c0		       20 d7 1a 	      jsr	ReadComplete
    882  05c3		       4c c2 02 	      jmp	NextIL
    883  05c6		       20 d9 1b 	      jsr	popLN
    884  05c9		       4c c2 02 	      jmp	NextIL
    885  05cc							;=====================================================
    886  05cc							; Get a line of text from the user, convert to a
    887  05cc							; number, leave on top of stack.
    888  05cc							;
    889  05cc				   iINNUM
    890  05cc		       20 b4 1b 	      jsr	pushLN
    891  05cf		       b0 ec		      bcs	iReadErr	; Stack over flow error
    892  05d1							;
    893  05d1		       a9 3f		      lda	#'?
    894  05d3		       a2 00		      ldx	#0	;Wait for complete
    895  05d5		       20 b7 1a 	      jsr	GetLine
    896  05d8		       20 4c 1a 	      jsr	getDecimal
    897  05db		       20 9a 1b 	      jsr	pushR0	;put onto stack
    898  05de		       b0 dd		      bcs	iReadErr	;StackOverflow error
    899  05e0							;
    900  05e0		       4c fa 05 	      jmp	ExitIn
    901  05e3							;
    902  05e3							;=====================================================
    903  05e3							; Get a line of text from the user, convert to a
    904  05e3							; character value , leave on top of stack. up to 2 characters
    905  05e3							;
    906  05e3				   iINSTR
    907  05e3		       20 b4 1b 	      jsr	pushLN
    908  05e6		       b0 d5		      bcs	iReadErr	; Stack overflow error
    909  05e8		       a9 3f		      lda	#'?
    910  05ea		       a2 00		      ldx	#0	;wait for read complete
    911  05ec		       20 b7 1a 	      jsr	GetLine
    912  05ef		       b1 4f		      lda	(CURPTR),y
    913  05f1		       85 52		      sta	R0
    914  05f3		       a9 00		      lda	#0
    915  05f5		       85 53		      sta	R0+1
    916  05f7		       20 9a 1b 	      jsr	pushR0	;put onto stack
    917  05fa				   ExitIn
    918  05fa		       20 d9 1b 	      jsr	popLN
    919  05fd		       4c c2 02 	      jmp	NextIL
    920  0600							;
    921  0600							;
    922  0600							;=====================================================
    923  0600							; Stop the currently running program.	Actually very
    924  0600							; simple to do... clear the RunMode flag, then set the
    925  0600							; ILPC to the standard handler and continue running.
    926  0600							;
    927  0600		       a9 00	   iFIN       lda	#0
    928  0602		       85 5b		      sta	RunMode
    929  0604		       20 42 16 	      jsr	taskReset
    930  0607							;
    931  0607		       ad 14 2e 	      lda	errGoto
    932  060a		       85 43		      sta	ILPC
    933  060c		       ad 15 2e 	      lda	errGoto+1
    934  060f		       85 44		      sta	ILPC+1
    935  0611		       4c c2 02 	      jmp	NextIL
    936  0614							;
    937  0614							;=====================================================
    938  0614							; Handle the ERR opcode.  Following the instruction is
    939  0614							; a 16 bit error number.  Print an error message, and
    940  0614							; if we're in run mode, print the line number.  Stop
    941  0614							; program execution and return to the initial state.
    942  0614							;
    943  0614		       20 9d 19    iERR       jsr	getILWord	;get err code
    944  0617							;
    945  0617							; Enter here with the error code in X (LSB) and A (MSB).
    946  0617							;
    947  0617		       86 52	   iErr2      stx	R0
    948  0619		       85 53		      sta	R0+1
    949  061b							;
    950  061b		       20 4d 14 	      jsr	puts
      0  061e					      db	CR,LF,"Error ",0
      1  061e		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    952  0627		       20 7e 13 	      jsr	PrintDecimal
    953  062a							;
    954  062a		       a5 5b		      lda	RunMode	;running?
    955  062c		       f0 3b		      beq	iERR3	;nope
    956  062e		       20 4d 14 	      jsr	puts
      0  0631					      db	" at line ",0
      1  0631		       20 61 74 20*	      .byte.b	" at line ",0
    958  063b		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    959  063d				   iErr2a
    960  063d		       b1 4f		      lda	(CURPTR),y
    961  063f		       85 52		      sta	R0
    962  0641		       c8		      iny
    963  0642		       b1 4f		      lda	(CURPTR),y
    964  0644		       85 53		      sta	R0+1
    965  0646		       20 7e 13 	      jsr	PrintDecimal
    966  0649		       20 4d 14 	      jsr	puts
      0  064c					      db	":",0
      1  064c		       3a 00		      .byte.b	":",0
    968  064e		       a9 00		      lda	#0
    969  0650		       85 53		      sta	R0+1
    970  0652		       a5 51		      lda	CUROFF
    971  0654		       18		      clc
    972  0655		       e9 03		      sbc	#3
    973  0657		       85 52		      sta	R0
    974  0659		       20 7e 13 	      jsr	PrintDecimal
    975  065c		       20 4d 14 	      jsr	puts
      0  065f					      db	":",0
      1  065f		       3a 00		      .byte.b	":",0
    977  0661		       ad ce 24 	      lda	taskPtr
    978  0664		       85 52		      sta	R0
    979  0666		       20 7e 13 	      jsr	PrintDecimal
    980  0669							;
    981  0669		       20 d7 1c    iERR3      jsr	CRLF
    982  066c		       20 3a 16 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    983  066f		       a9 00		      lda	#0
    984  0671		       85 5b		      sta	RunMode	;fall through...
    985  0673							;
    986  0673							;=====================================================
    987  0673							; Reset the IL to be back at the idle loop.  Does not
    988  0673							; clear variables so the user can see what state
    989  0673							; the program is in.
    990  0673							;
    991  0673		       a9 00	   ResetIL    lda	#0
    992  0675		       85 47		      sta	ILSTACKPTR
    993  0677		       ad 14 2e 	      lda	errGoto
    994  067a		       85 43		      sta	ILPC
    995  067c		       ad 15 2e 	      lda	errGoto+1
    996  067f		       85 44		      sta	ILPC+1
    997  0681		       4c c2 02 	      jmp	NextIL
    998  0684
    999  0684							;
   1000  0684							;=====================================================
   1001  0684							; Pop two items off stack, add them, then place the
   1002  0684							; result back onto the stack.
   1003  0684							;
   1004  0684		       20 1e 1c    iADD       jsr	popR0
   1005  0687		       20 36 1c 	      jsr	popR1
   1006  068a				   iADDfast
   1007  068a		       18		      clc
   1008  068b		       a5 52		      lda	R0
   1009  068d		       65 54		      adc	R1
   1010  068f		       85 52		      sta	R0
   1011  0691		       a5 53		      lda	R0+1
   1012  0693		       65 55		      adc	R1+1
   1013  0695		       85 53		      sta	R0+1
   1014  0697		       4c 02 07 	      jmp	pushR0nextIl
   1015  069a							;
   1016  069a							;=====================================================
   1017  069a							; Pop two items off the stack.  Subtract the top of
   1018  069a							; stack from the lower entry.
   1019  069a							;
   1020  069a		       20 36 1c    iSUB       jsr	popR1
   1021  069d		       20 1e 1c 	      jsr	popR0
   1022  06a0		       38		      sec
   1023  06a1		       a5 52		      lda	R0
   1024  06a3		       e5 54		      sbc	R1
   1025  06a5		       85 52		      sta	R0
   1026  06a7		       a5 53		      lda	R0+1
   1027  06a9		       e5 55		      sbc	R1+1
   1028  06ab		       85 53		      sta	R0+1
   1029  06ad		       4c 02 07 	      jmp	pushR0nextIl
   1030  06b0							;
   1031  06b0							;=====================================================
   1032  06b0							; Negate the top of stack.
   1033  06b0							;
   1034  06b0		       20 1e 1c    iNEG       jsr	popR0
   1035  06b3		       a5 52		      lda	R0
   1036  06b5		       49 ff		      eor	#$ff
   1037  06b7		       85 52		      sta	R0
   1038  06b9		       a5 53		      lda	R0+1
   1039  06bb		       49 ff		      eor	#$ff
   1040  06bd		       85 53		      sta	R0+1
   1041  06bf		       e6 52		      inc	R0
   1042  06c1		       d0 02		      bne	iNEG2
   1043  06c3		       e6 53		      inc	R0+1
   1044  06c5		       4c 02 07    iNEG2      jmp	pushR0nextIl
   1045  06c8							;
   1046  06c8							;=====================================================
   1047  06c8							; Multiply top two items on the stack, put the results
   1048  06c8							; on top.  This uses the algorithm documented on page
   1049  06c8							; 115 of "Microprocessor Programming for Computer
   1050  06c8							; Hobbyists" by Neill Graham.
   1051  06c8							;
   1052  06c8		       20 ce 06    iMUL       jsr	iMultiply
   1053  06cb		       4c c2 02 	      jmp	NextIL
   1054  06ce
   1055  06ce				   iMultiply
   1056  06ce		       20 1e 1c 	      jsr	popR0	;AC
   1057  06d1		       20 36 1c 	      jsr	popR1	;OP
   1058  06d4							;
   1059  06d4		       a5 52		      lda	R0
   1060  06d6		       85 56		      sta	MQ
   1061  06d8		       a5 53		      lda	R0+1
   1062  06da		       85 57		      sta	MQ+1
   1063  06dc		       a9 00		      lda	#0	;clear result
   1064  06de		       85 52		      sta	R0
   1065  06e0		       85 53		      sta	R0+1
   1066  06e2							;
   1067  06e2		       a2 10		      ldx	#16	;number of bits in value
   1068  06e4		       06 52	   multloop   asl	R0
   1069  06e6		       26 53		      rol	R0+1
   1070  06e8		       06 56		      asl	MQ
   1071  06ea		       26 57		      rol	MQ+1
   1072  06ec		       90 0d		      bcc	multno	;skip add if no carry
   1073  06ee							;
   1074  06ee							; Add R1 back into R0
   1075  06ee							;
   1076  06ee		       18		      clc
   1077  06ef		       a5 52		      lda	R0
   1078  06f1		       65 54		      adc	R1
   1079  06f3		       85 52		      sta	R0
   1080  06f5		       a5 53		      lda	R0+1
   1081  06f7		       65 55		      adc	R1+1
   1082  06f9		       85 53		      sta	R0+1
   1083  06fb							;
   1084  06fb		       ca	   multno     dex		;did all bits yet?
   1085  06fc		       d0 e6		      bne	multloop
   1086  06fe		       20 9a 1b 	      jsr	pushR0	;OP
   1087  0701		       60		      rts
   1088  0702							;
   1089  0702				   pushR0nextIl
   1090  0702		       20 9a 1b 	      jsr	pushR0	;OP
   1091  0705		       4c c2 02 	      jmp	NextIL
   1092  0708							;
   1093  0708							;=====================================================
   1094  0708							; Divide the top of stack into the next to top item.
   1095  0708							; Leave results on stack.  Taken from:
   1096  0708							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1097  0708							;
   1098  0708							; R0 = R0 / R1
   1099  0708							; Remainder is in MQ
   1100  0708							;
   1101  0708		       20 22 07    iDIV       jsr	iDoDiv
   1102  070b		       20 9f 1c 	      jsr	RestoreSigns
   1103  070e		       4c 02 07 	      jmp	pushR0nextIl
   1104  0711
   1105  0711		       20 22 07    iMOD       jsr	iDoDiv
   1106  0714		       20 9f 1c 	      jsr	RestoreSigns
   1107  0717		       a5 56		      lda	MQ
   1108  0719		       85 52		      sta	R0
   1109  071b		       a5 57		      lda	MQ+1
   1110  071d		       85 53		      sta	R0+1
   1111  071f		       4c 02 07 	      jmp	pushR0nextIl
   1112  0722
   1113  0722				   iDoDiv
   1114  0722		       20 36 1c 	      jsr	popR1
   1115  0725		       20 1e 1c 	      jsr	popR0
   1116  0728							;
   1117  0728							; Check for divide by zero
   1118  0728							;
   1119  0728
   1120  0728				   iDivNoPop
   1121  0728		       a5 54		      lda	R1
   1122  072a		       05 55		      ora	R1+1
   1123  072c		       f0 29		      beq	divby0
   1124  072e							;
   1125  072e		       20 64 1c 	      jsr	SaveSigns
   1126  0731		       a9 00		      lda	#0	;preset remainder to 0
   1127  0733		       85 56		      sta	MQ
   1128  0735		       85 57		      sta	MQ+1
   1129  0737		       a2 10		      ldx	#16	;repeat for each bit: ...
   1130  0739				   divloop
   1131  0739		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1132  073b		       26 53		      rol	R0+1
   1133  073d		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1134  073f		       26 57		      rol	MQ+1
   1135  0741		       a5 56		      lda	MQ
   1136  0743		       38		      sec
   1137  0744		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1138  0746		       a8		      tay		;lb result -> Y, for we may need it later
   1139  0747		       a5 57		      lda	MQ+1
   1140  0749		       e5 55		      sbc	R1+1
   1141  074b		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1142  074d
   1143  074d		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1144  074f		       84 56		      sty	MQ
   1145  0751		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1146  0753
   1147  0753		       ca	   skip       dex
   1148  0754		       d0 e3		      bne	divloop
   1149  0756		       60		      rts
   1150  0757							;
   1151  0757							; Indicate divide-by-zero error
   1152  0757							;
   1153  0757		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1154  0759		       a9 00		      lda	#0
   1155  075b		       4c 17 06 	      jmp	iErr2
   1156  075e							;
   1157  075e							;=====================================================
   1158  075e							; This pops the top two items off the stack.  The top
   1159  075e							; item is a data value and the other is an ABSOLUTE address.
   1160  075e							;Save the value into that address.
   1161  075e							;
   1162  075e		       98	   iSTORE     tya
   1163  075f		       48		      pha
   1164  0760		       20 1e 1c 	      jsr	popR0	;data
   1165  0763		       20 36 1c 	      jsr	popR1	;Storage location
   1166  0766		       a0 00		      ldy	#0
   1167  0768		       a5 52		      lda	R0
   1168  076a		       91 54		      sta	(R1),y
   1169  076c		       a5 53		      lda	R0+1
   1170  076e		       c8		      iny
   1171  076f		       91 54		      sta	(R1),y
   1172  0771		       68		      pla
   1173  0772		       a8		      tay
   1174  0773		       4c c2 02 	      jmp	NextIL
   1175  0776							;
   1176  0776							;=====================================================
   1177  0776							; Replaces the top of stack with the variable whose
   1178  0776							; absolute address it represents.
   1179  0776							;
   1180  0776		       98	   iIND       tya
   1181  0777		       48		      pha
   1182  0778		       20 36 1c 	      jsr	popR1
   1183  077b		       a0 00		      ldy	#0
   1184  077d		       b1 54		      lda	(R1),y
   1185  077f		       85 52		      sta	R0
   1186  0781		       c8		      iny
   1187  0782		       b1 54		      lda	(R1),y
   1188  0784		       85 53		      sta	R0+1
   1189  0786		       68		      pla
   1190  0787		       a8		      tay
   1191  0788		       4c 02 07 	      jmp	pushR0nextIl
   1192  078b							;
   1193  078b							;=====================================================
   1194  078b							; Get the array index from top of stack get Current variable
   1195  078b							; address from next on stack, add the offset
   1196  078b							; push the result back onto the stack
   1197  078b				   iArray
   1198  078b		       20 1e 1c 	      jsr	popR0	; Get the array index
   1199  078e		       20 36 1c 	      jsr	popR1	; Get the Variable address
   1200  0791
   1201  0791		       18		      clc		; Multiplythe value by 2
   1202  0792		       26 52		      rol	R0	; Do the multiply
   1203  0794		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1204  0796		       18		      clc
   1205  0797		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1206  0799		       65 52		      adc	R0
   1207  079b		       85 52		      sta	R0
   1208  079d		       a5 55		      lda	R1+1
   1209  079f		       65 53		      adc	R0+1
   1210  07a1		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1211  07a3		       20 9a 1b 	      jsr	pushR0	; Push R0 assume it is correct
   1212  07a6
   1213  07a6		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1214  07a8		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1215  07aa		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1216  07ac		       a5 55		      lda	R1+1
   1217  07ae		       c5 42		      cmp	VARIABLES+1
   1218  07b0		       d0 1c		      bne	iArrayAtTest
   1219  07b2		       18		      clc
   1220  07b3		       a9 34		      lda	#52	; add the max offset that is valid
   1221  07b5		       65 54		      adc	R1	; update to be the largest offset that is valid
   1222  07b7		       85 54		      sta	R1
   1223  07b9		       a9 00		      lda	#0
   1224  07bb		       65 55		      adc	R1+1
   1225  07bd		       85 55		      sta	R1+1
   1226  07bf				   iArrayVerify 		; try to enforce some sanity to using arrays
   1227  07bf		       a5 53		      lda	R0+1
   1228  07c1		       c5 55		      cmp	R1+1
   1229  07c3		       d0 04		      bne	iArrayDecide
   1230  07c5		       a5 52		      lda	R0
   1231  07c7		       c5 54		      cmp	R1
   1232  07c9				   iArrayDecide
   1233  07c9		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1234  07cb		       4c c2 02 	      jmp	NextIL
   1235  07ce
   1236  07ce				   iArrayAtTest
   1237  07ce		       ad 2b 2e 	      lda	HighMem
   1238  07d1		       85 54		      sta	R1
   1239  07d3		       ad 2c 2e 	      lda	HighMem+1
   1240  07d6		       85 55		      sta	R1+1
   1241  07d8		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1242  07da
   1243  07da							; Get here if array index is out of range
   1244  07da		       20 1e 1c    iArrayError jsr	popR0
   1245  07dd		       a9 00		      lda	#0
   1246  07df		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1247  07e1		       4c 17 06 	      jmp	iErr2
   1248  07e4							;
   1249  07e4							;=====================================================
   1250  07e4							; List the current BASIC program in memory.  Uses R0,
   1251  07e4							; tempIly, and dpl.
   1252  07e4							;
   1253  07e4		       20 06 1e    iLST       jsr	SetOutConsole
   1254  07e7		       ad 27 2e    iLST2      lda	ProgramStart
   1255  07ea		       85 59		      sta	dpl
   1256  07ec		       ad 28 2e 	      lda	ProgramStart+1
   1257  07ef		       85 5a		      sta	dpl+1
   1258  07f1							;
   1259  07f1							; dpl/dph point to the current line.  See if we're at
   1260  07f1							; the end of the program.
   1261  07f1							;
   1262  07f1		       a5 59	   iLSTloop   lda	dpl
   1263  07f3		       cd 29 2e 	      cmp	ProgramEnd
   1264  07f6		       d0 07		      bne	iLstNotEnd
   1265  07f8		       a5 5a		      lda	dpl+1
   1266  07fa		       cd 2a 2e 	      cmp	ProgramEnd+1
   1267  07fd		       f0 15		      beq	iLstdone
   1268  07ff							;
   1269  07ff		       20 df 11    iLstNotEnd jsr	PrintProgramLine
   1270  0802							;		  ldy	  #1		  ;Change:  Skip first byte length
   1271  0802							;		  lda	  (dpl),y	  ;line number LSB
   1272  0802							;		  sta	  R0
   1273  0802							;		  iny
   1274  0802							;		  lda	  (dpl),y		 ;line number MSB
   1275  0802							;		  sta	  R0+1
   1276  0802							;		  iny
   1277  0802							;		  sty	  tempIlY
   1278  0802							;		  jsr	  PrintDecimal
   1279  0802							;		  lda	  #SPACE
   1280  0802							;		  jsr	  VOUTCH
   1281  0802							;		  ldy	  tempIlY
   1282  0802							;iLSTl2	  lda	  (dpl),y
   1283  0802							;		  beq	  iLST3 	  ;end of this line 0 value
   1284  0802							;		  sty	  tempIlY
   1285  0802							;		  jsr	  VOUTCH
   1286  0802							;		  ldy	  tempIlY
   1287  0802							;		  iny
   1288  0802							;		  bne	  iLSTl2	  ;do next char
   1289  0802							;
   1290  0802							; End of this line.  Print CR/LF, then move to the
   1291  0802							; next line.
   1292  0802							;
   1293  0802		       a0 00	   iLST3      ldy	#0	;Move to next line
   1294  0804		       b1 59		      lda	(dpl),y	;Current line length
   1295  0806		       18		      clc		;Clear the carry flag
   1296  0807							;		  tya
   1297  0807		       65 59		      adc	dpl	;Add the offset to the pointer
   1298  0809		       85 59		      sta	dpl	;Save the new value
   1299  080b		       a5 5a		      lda	dpl+1	;Next byte
   1300  080d		       69 00		      adc	#0	;ad in the carry if any
   1301  080f		       85 5a		      sta	dpl+1	;Save it
   1302  0811							;
   1303  0811							; Have to manually do CR/LF so it uses the vectored
   1304  0811							; output function.
   1305  0811							;
   1306  0811							;		  lda	  #CR
   1307  0811							;		  jsr	  VOUTCH
   1308  0811							;		  lda	  #LF
   1309  0811							;		  jsr	  VOUTCH
   1310  0811		       4c f1 07 	      jmp	iLSTloop	;do next line
   1311  0814							;
   1312  0814		       20 06 1e    iLstdone   jsr	SetOutConsole
   1313  0817		       4c c2 02 	      jmp	NextIL
   1314  081a							;
   1315  081a							;=====================================================
   1316  081a							; Get a line of text into LINBUF.  Terminate with a
   1317  081a							; null byte.
   1318  081a							;
   1319  081a				   iGETLINE
   1320  081a		       a9 3e		      lda	#'>	;prompt character
   1321  081c		       a6 00		      ldx	0	;Wait for read to complete
   1322  081e		       20 b7 1a 	      jsr	GetLine
   1323  0821							;
   1324  0821		       a9 00		      lda	#0
   1325  0823		       85 5b		      sta	RunMode
   1326  0825				   iGetParseLine
   1327  0825							; lda	   CUROFF
   1328  0825							; pha
   1329  0825		       20 86 0f 	      jsr	ParseInputLine
   1330  0828							; pla
   1331  0828							;  sta     CUROFF
   1332  0828		       a9 83		      lda	#TOKENBUFFER&$FF
   1333  082a		       85 4f		      sta	CURPTR
   1334  082c		       a9 0e		      lda	#TOKENBUFFER>>8
   1335  082e		       85 50		      sta	CURPTR+1
   1336  0830		       a9 01		      lda	#1
   1337  0832		       85 51		      sta	CUROFF
   1338  0834		       4c c2 02 	      jmp	NextIL
   1339  0837							;
   1340  0837							;=====================================================
   1341  0837							; This is called when the input buffer contains a line
   1342  0837							; typed in by the user that starts with a line number.
   1343  0837							; Insert the line into the program or delete the line
   1344  0837							; if there is nothing after the line number,
   1345  0837							;
   1346  0837				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1347  0837		       ad 84 0e 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1348  083a		       85 52		      sta	R0	; place the number into R0
   1349  083c		       ad 85 0e 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1350  083f		       85 53		      STA	R0+1	; Place it into
   1351  0841							;
   1352  0841							; Now find the line OR the next higher line OR the
   1353  0841							; end of the program.
   1354  0841							;
   1355  0841		       20 e6 19 	      jsr	findLine	; Look for the line number in the current program
   1356  0844							; Returns Z and curptr point to the line if found
   1357  0844							; Returns C and curptr at next higher line if not found and there is a higher line
   1358  0844							; Returns ZC clear and curptr to end of program if higher than all other lines
   1359  0844							;
   1360  0844							; If the line exists, it needs to be removed.
   1361  0844							;
   1362  0844		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1363  0846							;
   1364  0846							; Get length of line to be removed, we fall thru to here if we find a matching line
   1365  0846							;
   1366  0846							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1367  0846		       a0 00		      ldy	#0
   1368  0848		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1369  084a		       a8		      tay
   1370  084b							;If it is equal we delete the line and replace it, get length
   1371  084b							;then adjust all program line after up or down depending on len of line
   1372  084b							;If next higher then just move everythimg down by length bytes
   1373  084b							;This call will return how many bytes in the line we found
   1374  084b		       8c 24 2e 	      sty	lineLength	;Save the length of the line we found
   1375  084e							;
   1376  084e							; Compute the new end of the program first.
   1377  084e							;
   1378  084e		       38		      sec		;Set the carry bit
   1379  084f		       ad 29 2e 	      lda	ProgramEnd	;Get low byte of program end
   1380  0852		       ed 24 2e 	      sbc	lineLength	;Subtract the length of the current line
   1381  0855		       8d 29 2e 	      sta	ProgramEnd	;save it
   1382  0858		       ad 2a 2e 	      lda	ProgramEnd+1
   1383  085b		       e9 00		      sbc	#0	;Process the carry
   1384  085d		       8d 2a 2e 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1385  0860							;
   1386  0860							; Copy CURPTR into R1 for working
   1387  0860							;
   1388  0860		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1389  0862		       85 54		      sta	R1
   1390  0864		       a5 50		      lda	CURPTR+1
   1391  0866		       85 55		      sta	R1+1
   1392  0868							;
   1393  0868							; See if we're at the end.
   1394  0868							;
   1395  0868		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1396  086a		       cd 29 2e 	      cmp	ProgramEnd
   1397  086d		       d0 07		      bne	InsDelLoop
   1398  086f		       a5 55		      lda	R1+1
   1399  0871		       cd 2a 2e 	      cmp	ProgramEnd+1
   1400  0874		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1401  0876							;
   1402  0876							; Move one byte, move to next location.
   1403  0876							;
   1404  0876		       ac 24 2e    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1405  0879		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1406  087b		       b1 54		      lda	(R1),y
   1407  087d		       a0 00		      ldy	#0
   1408  087f		       91 54		      sta	(R1),y
   1409  0881		       e6 54		      inc	R1
   1410  0883		       d0 e3		      bne	InsDelChk
   1411  0885		       e6 55		      inc	R1+1
   1412  0887		       4c 68 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1413  088a							;
   1414  088a							; Deletion is done.
   1415  088a							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1416  088a							;
   1417  088a				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1418  088a		       ad 83 0e 	      lda	TOKENBUFFER	; Get the length
   1419  088d		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1420  088f							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1421  088f		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1422  0891							;
   1423  0891							; CURPTR points to where the line will be inserted.
   1424  0891							;
   1425  0891							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1426  0891		       ae 83 0e 	      ldx	TOKENBUFFER
   1427  0894		       8e 24 2e 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1428  0897							;
   1429  0897		       ad 29 2e 	      lda	ProgramEnd	;Load the start address for the copy
   1430  089a							;At this point curptr still contains the location we will insert data
   1431  089a		       85 5c		      sta	FROM
   1432  089c		       ad 2a 2e 	      lda	ProgramEnd+1
   1433  089f		       85 5d		      sta	FROM+1
   1434  08a1							;
   1435  08a1		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1436  08a3		       b1 5c		      lda	(FROM),y
   1437  08a5		       ac 24 2e 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1438  08a8		       91 5c		      sta	(FROM),y	;Save the new byte
   1439  08aa							;
   1440  08aa		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1441  08ac		       c5 4f		      cmp	CURPTR
   1442  08ae		       d0 06		      bne	mvUpMore
   1443  08b0		       a5 5d		      lda	FROM+1
   1444  08b2		       c5 50		      cmp	CURPTR+1
   1445  08b4		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1446  08b6							;
   1447  08b6							; Not done yet
   1448  08b6							;
   1449  08b6		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1450  08b8		       d0 02		      bne	mvUpMore2
   1451  08ba		       c6 5d		      dec	FROM+1
   1452  08bc		       c6 5c	   mvUpMore2  dec	FROM
   1453  08be		       4c a1 08 	      jmp	mvup1	;Loop until everything is moved
   1454  08c1							;
   1455  08c1							; All done with copy.
   1456  08c1							;
   1457  08c1				   mvUpDone
   1458  08c1		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1459  08c2		       ad 24 2e 	      lda	lineLength	;Number of bytes to copy from line buff
   1460  08c5		       6d 29 2e 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1461  08c8		       8d 29 2e 	      sta	ProgramEnd
   1462  08cb		       ad 2a 2e 	      lda	ProgramEnd+1
   1463  08ce		       69 00		      adc	#0
   1464  08d0		       8d 2a 2e 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1465  08d3							;
   1466  08d3							;===================jlit use length before line newline
   1467  08d3
   1468  08d3		       a0 00		      ldy	#0	;Set offset of copy
   1469  08d5							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1470  08d5							;		  sta	  (CURPTR),y	  ;Store the length
   1471  08d5							;		  iny
   1472  08d5							;		  lda	  R0		  ;Store the line number next
   1473  08d5							;		  sta	  (CURPTR),y
   1474  08d5							;		  iny
   1475  08d5							;		  lda	  R0+1
   1476  08d5							;		  sta	  (CURPTR),y
   1477  08d5							;		  iny
   1478  08d5							;
   1479  08d5							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1480  08d5		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1481  08d7				   mvUpLoop2
   1482  08d7							;		  lda	  LINBUF,x	 ;get a byte
   1483  08d7		       bd 83 0e 	      lda	TOKENBUFFER,x	;get a byte
   1484  08da		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1485  08dc
   1486  08dc		       e8		      inx
   1487  08dd		       ec 83 0e 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1488  08e0		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1489  08e2		       c8		      iny
   1490  08e3		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1491  08e5							;
   1492  08e5		       4c c2 02    mvUpFini   jmp	NextIL
   1493  08e8							;
   1494  08e8							;=====================================================
   1495  08e8							; Pops the top value of the ILPC stack and stores it
   1496  08e8							; in ILPC.  Ie, return from an IL subroutine.
   1497  08e8							;
   1498  08e8		       20 d4 19    iRTN       jsr	popILPC
   1499  08eb		       4c c2 02 	      jmp	NextIL
   1500  08ee							;
   1501  08ee							;=====================================================
   1502  08ee							; NLINE print a newline
   1503  08ee							;
   1504  08ee		       20 d7 1c    iNLINE     jsr	CRLF	;user supplied sub
   1505  08f1		       4c c2 02 	      jmp	NextIL
   1506  08f4							;
   1507  08f4							;=====================================================
   1508  08f4							; This saves the current ILPC value on the stack, then
   1509  08f4							; jumps to the address specified by the next two bytes.
   1510  08f4							;
   1511  08f4		       20 b7 19    iCALL      jsr	pushILPC	;save ILPC
   1512  08f7		       90 03		      bcc	iJMP
   1513  08f9		       4c 9c 0b 	      jmp	ErrStkOver	; Check if there was an error
   1514  08fc							;
   1515  08fc							; Jmp to a specific location in the IL code.  The new
   1516  08fc							; address immediately follows the opcode.
   1517  08fc							;
   1518  08fc		       20 9d 19    iJMP       jsr	getILWord
   1519  08ff		       86 43		      stx	ILPC
   1520  0901		       85 44		      sta	ILPC+1
   1521  0903		       4c c2 02 	      jmp	NextIL
   1522  0906
   1523  0906
   1524  0906							;
   1525  0906							;=====================================================
   1526  0906							; Push the next two bytes onto the arithmetic stack.
   1527  0906							;
   1528  0906		       20 a1 19    iSetR2     jsr	getILByte
   1529  0909		       85 58		      sta	R2
   1530  090b		       4c c2 02 	      jmp	NextIL
   1531  090e							;
   1532  090e							;=====================================================
   1533  090e							; Push the next two bytes onto the arithmetic stack.
   1534  090e							;
   1535  090e		       20 9d 19    iLIT       jsr	getILWord
   1536  0911		       86 52		      stx	R0
   1537  0913		       85 53		      sta	R0+1
   1538  0915		       20 9a 1b 	      jsr	pushR0
   1539  0918		       4c c2 02 	      jmp	NextIL
   1540  091b							;
   1541  091b							;=====================================================
   1542  091b							; Initialize all variables for a single task.	Ie, set to zero.
   1543  091b							;
   1544  091b		       98	   subVINIT   tya
   1545  091c		       48		      pha
   1546  091d
   1547  091d		       a9 00		      lda	#0
   1548  091f		       a0 00		      ldy	#0
   1549  0921		       91 41	   Vinit2     sta	(VARIABLES),y
   1550  0923		       c8		      iny
   1551  0924		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1552  0926		       90 f9		      bcc	Vinit2
   1553  0928
   1554  0928		       68		      pla
   1555  0929		       a8		      tay
   1556  092a		       60		      rts
   1557  092b
   1558  092b		       20 1b 09    iVINIT     jsr	subVINIT
   1559  092e		       4c c2 02 	      jmp	NextIL
   1560  0931							;
   1561  0931							;=====================================================
   1562  0931							; Set the address of the error handler.  After any
   1563  0931							; error, set to the ILPC to the specified location.
   1564  0931							;
   1565  0931		       20 9d 19    iERRGOTO   jsr	getILWord
   1566  0934		       8e 14 2e 	      stx	errGoto
   1567  0937		       8d 15 2e 	      sta	errGoto+1
   1568  093a		       4c c2 02 	      jmp	NextIL
   1569  093d							;
   1570  093d							;=====================================================
   1571  093d							; TST is followed by an 8 bit signed offset, then a
   1572  093d							; null terminated string.  Compare the string against
   1573  093d							; the string starting at (CURPTR),CUROFF.  If the
   1574  093d							; strings match, continue executing the next IL
   1575  093d							; opcode.  Else, add the offset to ILPC.
   1576  093d							;
   1577  093d		       20 a1 19    iTST       jsr	getILByte	;Get the relative jump address
   1578  0940		       8d 23 2e 	      sta	offset	;save it to use if test faile
   1579  0943		       20 84 1b 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1580  0946
   1581  0946		       a4 51		      ldy	CUROFF
   1582  0948		       84 59		      sty	dpl	;save for later
   1583  094a							;
   1584  094a		       20 a1 19    iTSTloop   jsr	getILByte	;get next char
   1585  094d		       f0 11		      beq	iTSTm	;match!
   1586  094f		       a4 59		      ldy	dpl
   1587  0951		       d1 4f		      cmp	(CURPTR),y
   1588  0953		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1589  0955		       09 20		      ora	#$20	; lets allow lowercase as well
   1590  0957		       d1 4f		      cmp	(CURPTR),y
   1591  0959		       d0 23		      bne	iTSTfail	;mismatch
   1592  095b		       c8	   iTSTUpper  iny
   1593  095c		       84 59		      sty	dpl
   1594  095e		       d0 ea		      bne	iTSTloop
   1595  0960							;
   1596  0960							; It's a match!  Clean up a bit.
   1597  0960							;
   1598  0960		       a4 59	   iTSTm      ldy	dpl
   1599  0962		       84 51		      sty	CUROFF
   1600  0964		       4c c2 02 	      jmp	NextIL
   1601  0967
   1602  0967							; Test for a single quote string
   1603  0967		       20 a1 19    iTSTStr    jsr	getILByte
   1604  096a		       8d 23 2e 	      sta	offset
   1605  096d		       20 84 1b 	      jsr	saveIL
   1606  0970		       a4 51		      ldy	CUROFF
   1607  0972		       a9 22		      lda	#'"
   1608  0974		       d1 4f		      cmp	(CURPTR),y
   1609  0976		       d0 06		      bne	iTSTfail
   1610  0978		       c8		      iny
   1611  0979		       84 51		      sty	CUROFF
   1612  097b		       4c e0 02 	      jmp	NextILStr
   1613  097e							;
   1614  097e							; Not a match, reset ILPC and then move to the
   1615  097e							; offset.
   1616  097e							;
   1617  097e		       20 8f 1b    iTSTfail   jsr	restoreIL
   1618  0981		       4c 4c 0b 	      jmp	tstBranch
   1619  0984							;
   1620  0984							;=================================================JLIT=
   1621  0984							; Test if we have a let statement without the let keyword
   1622  0984		       20 a1 19    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1623  0987		       8d 23 2e 	      sta	offset	; Save the jump offset for fails
   1624  098a		       20 84 1b 	      jsr	saveIL	; save to restore when done if fail
   1625  098d
   1626  098d		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1627  098f		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1628  0991		       c9 01		      cmp	#kLet	; Is it a let keyword
   1629  0993		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1630  0995		       c9 80		      cmp	#tVa	; lets check for a variable
   1631  0997		       90 e5		      bcc	iTSTfail	; Less than variable range
   1632  0999		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1633  099b		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1634  099d		       b0 df		      bcs	iTSTfail	; return it failed
   1635  099f
   1636  099f				   iTSTLETGOOD
   1637  099f		       c8		      iny
   1638  09a0		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1639  09a2				   iTSTGOODVAR
   1640  09a2		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1641  09a5
   1642  09a5							;=================================================JLIT=
   1643  09a5							; Test a byte at an indirect address
   1644  09a5							; fails if byte is not equal to the value at the address
   1645  09a5							; The tests an indirect byte and branches if true
   1646  09a5		       20 a1 19    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1647  09a8		       8d 23 2e 	      sta	offset	; Save the jump offset for fails
   1648  09ab		       20 84 1b 	      jsr	saveIL	; save to restore when done if fail
   1649  09ae		       20 9d 19 	      jsr	getILWord	; Get a word into RO
   1650  09b1		       86 52		      stx	R0
   1651  09b3		       85 53		      sta	R0+1
   1652  09b5		       20 a1 19 	      jsr	getILByte	; Get byte into A
   1653  09b8		       a0 00		      ldy	#0
   1654  09ba		       d1 52		      cmp	(R0),y
   1655  09bc		       d0 03		      bne	iTSTByteNotEqual
   1656  09be		       4c 7e 09 	      jmp	iTSTfail
   1657  09c1
   1658  09c1				   iTSTByteNotEqual
   1659  09c1		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1660  09c4
   1661  09c4							;=================================================JLIT=
   1662  09c4							; Test a byte	branch if it fails
   1663  09c4		       20 a1 19    iTSTB      jsr	getILByte	; Get the relative offset byte
   1664  09c7		       8d 23 2e 	      sta	offset	; Save the jump offset for fails
   1665  09ca		       20 84 1b 	      jsr	saveIL	; save to restore when done if fail
   1666  09cd		       20 a1 19 	      jsr	getILByte	; Get a word into RO
   1667  09d0		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1668  09d2		       d1 4f		      cmp	(CURPTR),y
   1669  09d4		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1670  09d6		       4c 7e 09 	      jmp	iTSTfail	; REcover and move on to next test
   1671  09d9
   1672  09d9				   iTSTBMatch
   1673  09d9		       c8		      iny
   1674  09da		       84 51		      sty	CUROFF	; Point to the next byte
   1675  09dc		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1676  09df
   1677  09df							;=================================================JLIT=
   1678  09df							; Test a byte	branch if it fails
   1679  09df		       20 a1 19    iTSTW      jsr	getILByte	; Get the relative offset byte
   1680  09e2		       8d 23 2e 	      sta	offset	; Save the jump offset for fails
   1681  09e5		       20 84 1b 	      jsr	saveIL	; save to restore when done if fail
   1682  09e8		       20 9d 19 	      jsr	getILWord	; Get a word into RO
   1683  09eb		       86 52		      stx	R0
   1684  09ed		       85 53		      sta	R0+1
   1685  09ef		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1686  09f1		       8a		      txa
   1687  09f2		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1688  09f4		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1689  09f6		       4c 7e 09 	      jmp	iTSTfail	; REcover and move on to next test
   1690  09f9		       c8	   iTSTWM1    iny
   1691  09fa		       a5 53		      lda	R0+1
   1692  09fc		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1693  09fe		       f0 03		      beq	iTSTWMatch
   1694  0a00		       4c 7e 09 	      jmp	iTSTfail
   1695  0a03
   1696  0a03				   iTSTWMatch
   1697  0a03		       c8		      iny
   1698  0a04		       84 51		      sty	CUROFF
   1699  0a06		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1700  0a09
   1701  0a09							;================================================jLIT=
   1702  0a09							;Test for end of line
   1703  0a09							;
   1704  0a09				   iTSTDONE
   1705  0a09		       20 a1 19 	      jsr	getILByte
   1706  0a0c		       8d 23 2e 	      sta	offset
   1707  0a0f		       20 84 1b 	      jsr	saveIL
   1708  0a12		       a4 51		      ldy	CUROFF
   1709  0a14		       84 59		      sty	dpl
   1710  0a16		       b1 4f		      lda	(CURPTR),y
   1711  0a18		       f0 0b		      beq	iTSTDONEtrue
   1712  0a1a		       c9 e6		      cmp	#oColon
   1713  0a1c		       f0 07		      beq	iTSTDONEtrue
   1714  0a1e		       a4 59		      ldy	dpl
   1715  0a20		       84 51		      sty	CUROFF
   1716  0a22		       4c 7e 09 	      jmp	iTSTfail
   1717  0a25							;
   1718  0a25							; Advance to the next line
   1719  0a25							;
   1720  0a25				   iTSTDONEtrue
   1721  0a25		       4c c2 02 	      jmp	NextIL
   1722  0a28
   1723  0a28		       4c 4c 0b    tstBranchLink jmp	tstBranch
   1724  0a2b							;
   1725  0a2b							;=====================================================
   1726  0a2b							; Inc and dec a variable , faster than a = a + 1
   1727  0a2b				   iINCVAR
   1728  0a2b		       20 1e 1c 	      jsr	popR0
   1729  0a2e		       a0 00		      ldy	#0
   1730  0a30		       18		      clc
   1731  0a31		       a9 01		      lda	#1
   1732  0a33		       71 52		      adc	(R0),y
   1733  0a35		       91 52		      sta	(R0),y
   1734  0a37		       90 07		      bcc	iINCDONE
   1735  0a39		       c8		      iny
   1736  0a3a		       a9 00		      lda	#0
   1737  0a3c		       71 52		      adc	(R0),y
   1738  0a3e		       91 52		      sta	(R0),y
   1739  0a40				   iINCDONE
   1740  0a40		       4c c2 02 	      jmp	NextIL
   1741  0a43
   1742  0a43				   iDECVAR
   1743  0a43		       20 1e 1c 	      jsr	popR0
   1744  0a46		       a0 00		      ldy	#0
   1745  0a48		       38		      sec
   1746  0a49		       b1 52		      lda	(R0),y
   1747  0a4b		       e9 01		      sbc	#1
   1748  0a4d		       91 52		      sta	(R0),y
   1749  0a4f		       c8		      iny
   1750  0a50		       b1 52		      lda	(R0),y
   1751  0a52		       e9 00		      sbc	#0
   1752  0a54		       91 52		      sta	(R0),y
   1753  0a56		       4c c2 02 	      jmp	NextIL
   1754  0a59
   1755  0a59
   1756  0a59							;
   1757  0a59							;=====================================================
   1758  0a59							; TSTV is followed by an 8 bit signed offset.	If the
   1759  0a59							; value at (CURPTR),CUROFF appears to be a variable
   1760  0a59							; name, move to the next IL statement.  Else, add the
   1761  0a59							; offset to ILPC. Converted to use actual absolute memory addresses
   1762  0a59							; TSTVT Looks for the task context
   1763  0a59							;
   1764  0a59		       20 36 1c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1765  0a5c		       a9 00		      lda	#0
   1766  0a5e		       85 58		      sta	R2
   1767  0a60		       f0 04		      beq	iTSTVV
   1768  0a62
   1769  0a62		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1770  0a64		       85 58		      sta	R2
   1771  0a66
   1772  0a66		       20 a1 19    iTSTVV     jsr	getILByte	;offset
   1773  0a69		       8d 23 2e 	      sta	offset
   1774  0a6c							;
   1775  0a6c		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1776  0a6e		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1777  0a70		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1778  0a72		       4c 28 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1779  0a75							;
   1780  0a75				   iTSTVnext
   1781  0a75		       c9 9d		      cmp	#tVat	;allow access to all unused memory as an array or integers
   1782  0a77		       f0 42		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1783  0a79
   1784  0a79		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1785  0a7b		       f0 4e		      beq	iTSTVParm
   1786  0a7d
   1787  0a7d		       c9 9b		      cmp	#tVhat	; task exit code
   1788  0a7f		       d0 04		      bne	iTSTV_A2Z
   1789  0a81		       a9 19		      lda	#TASKEXITCODE
   1790  0a83		       d0 0b		      bne	iTSTVContinue
   1791  0a85
   1792  0a85				   iTSTV_A2Z
   1793  0a85
   1794  0a85		       c9 80		      cmp	#tVa
   1795  0a87		       90 9f		      bcc	tstBranchLink
   1796  0a89		       c9 9a		      cmp	#tVz+1
   1797  0a8b		       b0 9b		      bcs	tstBranchLink
   1798  0a8d
   1799  0a8d
   1800  0a8d							;
   1801  0a8d							; The condition is true, so convert to an index, push
   1802  0a8d							; it onto the stack and continue running.
   1803  0a8d							;
   1804  0a8d		       29 7f		      and	#%01111111	;Mask off the high bit
   1805  0a8f		       0a		      asl		;multiply by two
   1806  0a90
   1807  0a90				   iTSTVContinue
   1808  0a90		       c8		      iny
   1809  0a91		       84 51		      sty	CUROFF	;it is a valid variable
   1810  0a93		       48		      pha
   1811  0a94		       a5 58		      lda	R2
   1812  0a96		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1813  0a98
   1814  0a98		       20 84 19 	      jsr	ipc_getcontext	; Get the other tasks variables
   1815  0a9b		       a0 01		      ldy	#VARIABLEPOS
   1816  0a9d		       b1 56		      lda	(MQ),y
   1817  0a9f		       85 52		      sta	R0
   1818  0aa1		       c8		      iny
   1819  0aa2		       b1 56		      lda	(MQ),y
   1820  0aa4		       85 53		      sta	R0+1
   1821  0aa6		       4c b1 0a 	      jmp	iTSTVAddOffset
   1822  0aa9
   1823  0aa9				   iTSTVLocalValue
   1824  0aa9		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1825  0aab		       85 52		      sta	R0
   1826  0aad		       a5 42		      lda	VARIABLES+1
   1827  0aaf		       85 53		      sta	R0+1
   1828  0ab1
   1829  0ab1				   iTSTVAddOffset
   1830  0ab1		       68		      pla
   1831  0ab2		       85 54		      sta	R1
   1832  0ab4		       a9 00		      lda	#0
   1833  0ab6		       85 55		      sta	R1+1
   1834  0ab8
   1835  0ab8				   iTSTVcontinue
   1836  0ab8
   1837  0ab8		       4c 8a 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1838  0abb
   1839  0abb							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1840  0abb							; an array of integer values
   1841  0abb				   iTSTVat
   1842  0abb		       c8		      iny
   1843  0abc		       84 51		      sty	CUROFF	;it is a valid variable
   1844  0abe		       ad 29 2e 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1845  0ac1		       85 52		      sta	R0
   1846  0ac3		       ad 2a 2e 	      lda	ProgramEnd+1
   1847  0ac6		       85 53		      sta	R0+1
   1848  0ac8		       4c 02 07 	      jmp	pushR0nextIl	;place this onto the stack
   1849  0acb
   1850  0acb							; When we get parameters passed we can access them using the # variable with[]
   1851  0acb							; example #[0] #[1] etc, we dont check yet if there is too many
   1852  0acb				   iTSTVParm
   1853  0acb		       c8		      iny
   1854  0acc		       84 51		      sty	CUROFF	;it is a valid variable
   1855  0ace		       a5 48		      lda	MATHSTACK
   1856  0ad0		       85 52		      sta	R0
   1857  0ad2		       a5 49		      lda	MATHSTACK+1
   1858  0ad4		       85 53		      sta	R0+1
   1859  0ad6		       4c 02 07 	      jmp	pushR0nextIl
   1860  0ad9
   1861  0ad9							;
   1862  0ad9							;=====================================================
   1863  0ad9							; TSTL seems basically the same as TSTN, but leave the
   1864  0ad9							; value in R0 instead of pushing onto stack.
   1865  0ad9							; This tests for a valid line number
   1866  0ad9							;
   1867  0ad9		       20 a1 19    iTSTL      jsr	getILByte
   1868  0adc		       8d 23 2e 	      sta	offset
   1869  0adf							;
   1870  0adf		       a4 51		      ldy	CUROFF
   1871  0ae1		       b1 4f		      lda	(CURPTR),y
   1872  0ae3		       c8		      iny
   1873  0ae4		       11 4f		      ora	(CURPTR),y
   1874  0ae6		       f0 06		      beq	iTSTLNotLineNo
   1875  0ae8
   1876  0ae8
   1877  0ae8							; In Both cases we need to point to the first usefull byte to process.
   1878  0ae8		       c8		      iny
   1879  0ae9		       84 51		      sty	CUROFF
   1880  0aeb		       4c c2 02 	      jmp	NextIL
   1881  0aee				   iTSTLNotLineNo
   1882  0aee		       c8		      iny
   1883  0aef		       84 51		      sty	CUROFF
   1884  0af1		       4c 4c 0b 	      jmp	tstBranch
   1885  0af4
   1886  0af4							;
   1887  0af4							;=====================================================
   1888  0af4							; TSTN checks for a number.  This is very simplistic;
   1889  0af4							; if the character is a digit, assume it's a number.
   1890  0af4							; Convert to a number and push it onto the stack.
   1891  0af4							;
   1892  0af4		       20 a1 19    iTSTN      jsr	getILByte
   1893  0af7		       8d 23 2e 	      sta	offset
   1894  0afa							;
   1895  0afa		       a4 51		      ldy	CUROFF
   1896  0afc		       a9 00		      lda	#0
   1897  0afe		       85 59		      sta	dpl
   1898  0b00		       b1 4f		      lda	(CURPTR),y
   1899  0b02		       c9 ea		      cmp	#oMinus
   1900  0b04		       d0 02		      bne	chkByte
   1901  0b06		       e6 59		      inc	dpl
   1902  0b08
   1903  0b08				   chkByte
   1904  0b08		       c9 a2		      cmp	#tByte
   1905  0b0a		       d0 0d		      bne	chkInteger
   1906  0b0c		       a9 00		      lda	#0
   1907  0b0e		       85 53		      sta	R0+1
   1908  0b10		       c8		      iny
   1909  0b11		       b1 4f		      lda	(CURPTR),y
   1910  0b13		       85 52		      sta	R0
   1911  0b15		       c8		      iny
   1912  0b16		       4c 28 0b 	      jmp	iTSTN_1
   1913  0b19
   1914  0b19				   chkInteger
   1915  0b19		       c9 a1		      cmp	#tInteger
   1916  0b1b		       d0 2f		      bne	tstBranch
   1917  0b1d		       c8		      iny
   1918  0b1e		       b1 4f		      lda	(CURPTR),y
   1919  0b20		       85 52		      sta	R0
   1920  0b22		       c8		      iny
   1921  0b23		       b1 4f		      lda	(CURPTR),y
   1922  0b25		       85 53		      sta	R0+1
   1923  0b27		       c8		      iny
   1924  0b28							;
   1925  0b28							; Check if it is negative and make it so
   1926  0b28							;
   1927  0b28				   iTSTN_1
   1928  0b28		       84 51		      sty	CUROFF
   1929  0b2a
   1930  0b2a		       a5 59		      lda	dpl
   1931  0b2c		       f0 18		      beq	iTSTN_2	;positive
   1932  0b2e							;
   1933  0b2e		       a5 52		      lda	R0
   1934  0b30		       05 53		      ora	R0+1
   1935  0b32		       f0 12		      beq	iTSTN_2	;zero
   1936  0b34
   1937  0b34							; Invert all the bits, then add one.
   1938  0b34							;
   1939  0b34		       a5 52		      lda	R0
   1940  0b36		       49 ff		      eor	#$ff
   1941  0b38		       85 52		      sta	R0
   1942  0b3a		       a5 53		      lda	R0+1
   1943  0b3c		       49 ff		      eor	#$ff
   1944  0b3e		       85 53		      sta	R0+1
   1945  0b40							;
   1946  0b40		       e6 52		      inc	R0
   1947  0b42		       d0 02		      bne	iTSTN_2
   1948  0b44		       e6 53		      inc	R0+1
   1949  0b46				   iTSTN_2
   1950  0b46		       20 9a 1b 	      jsr	pushR0	;save onto stack
   1951  0b49		       4c c2 02 	      jmp	NextIL
   1952  0b4c							;
   1953  0b4c							; Common jump point for all TSTx instructions that
   1954  0b4c							; fail to meet the requirements.  This takes the
   1955  0b4c							; offset and adds/subtracts to/from ILPC.
   1956  0b4c							;
   1957  0b4c		       ad 23 2e    tstBranch  lda	offset	;get signed offset
   1958  0b4f		       10 0e		      bpl	tstPositive
   1959  0b51							;
   1960  0b51							; Do negative branch.	Do sign extension.
   1961  0b51							;
   1962  0b51		       18	   tstNegative clc
   1963  0b52		       65 43		      adc	ILPC
   1964  0b54		       85 43		      sta	ILPC
   1965  0b56							;		  bcc	  tstBothDone
   1966  0b56							;		  dec	  ILPC+1
   1967  0b56							;		  jmp	  NextIL
   1968  0b56
   1969  0b56		       a5 44		      lda	ILPC+1
   1970  0b58		       69 ff		      adc	#$ff
   1971  0b5a		       85 44		      sta	ILPC+1
   1972  0b5c		       4c c2 02 	      jmp	NextIL	;keep going
   1973  0b5f							;
   1974  0b5f		       18	   tstPositive clc
   1975  0b60		       65 43		      adc	ILPC
   1976  0b62		       85 43		      sta	ILPC
   1977  0b64		       90 02		      bcc	tstBothDone
   1978  0b66		       e6 44		      inc	ILPC+1
   1979  0b68				   tstBothDone
   1980  0b68		       4c c2 02 	      jmp	NextIL
   1981  0b6b
   1982  0b6b							;
   1983  0b6b							;====================================================
   1984  0b6b							; Test for IRQ pending, and test if a break key pressed
   1985  0b6b							; Yes I know but this handles all sorts of irq/break issues
   1986  0b6b							;
   1987  0b6b		       20 a1 19    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1988  0b6e		       8d 23 2e 	      sta	offset	; Store the not true jump address offset
   1989  0b71		       20 40 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1990  0b74		       d0 03		      bne	irqNo	; z not set of no break found
   1991  0b76		       4c 00 06 	      jmp	iFIN	; Exit out of run mode
   1992  0b79		       ad cb 24    irqNo      lda	IRQPending
   1993  0b7c		       f0 ce		      beq	tstBranch
   1994  0b7e		       c9 01		      cmp	#1	; only do this if set to first time
   1995  0b80		       d0 ca		      bne	tstBranch
   1996  0b82		       78		      sei		; disable the interupt until ireturn resets it
   1997  0b83		       ee cb 24    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1998  0b86		       20 b4 1b 	      jsr	pushLN	; Push the next line to be executed
   1999  0b89		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2000  0b8b		       ad cc 24 	      lda	IRQEntry	; Get the line number to branch to
   2001  0b8e		       85 4f		      sta	CURPTR	; put line number into r0
   2002  0b90		       ad cd 24 	      lda	IRQEntry+1
   2003  0b93		       85 50		      sta	CURPTR+1
   2004  0b95		       a9 03		      lda	#3	; Point to first byte of program text
   2005  0b97		       85 51		      sta	CUROFF
   2006  0b99		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2007  0b9c
   2008  0b9c		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2009  0b9e		       a9 00		      lda	#0	; stop the execution
   2010  0ba0		       4c 17 06 	      jmp	iErr2
   2011  0ba3							;
   2012  0ba3
   2013  0ba3							;=====================================================
   2014  0ba3							; This places the number of free bytes on top of the
   2015  0ba3							; stack.
   2016  0ba3							;
   2017  0ba3		       20 07 15    iFREE      jsr	MemFree
   2018  0ba6		       20 9a 1b 	      jsr	pushR0
   2019  0ba9		       4c c2 02 	      jmp	NextIL
   2020  0bac							;
   2021  0bac							;=====================================================
   2022  0bac							; Generate a random number from 0-FFFF and then MOD
   2023  0bac							; it with the value on top of stack.  Leaves number on
   2024  0bac							; stack
   2025  0bac							;
   2026  0bac		       20 36 1c    iRANDOM    jsr	popR1	;mod value
   2027  0baf							;
   2028  0baf							; If the value is zero, just return a one.
   2029  0baf							;
   2030  0baf		       a5 54		      lda	R1
   2031  0bb1		       05 55		      ora	R1+1
   2032  0bb3		       f0 4a		      beq	irandom1
   2033  0bb5							;
   2034  0bb5		       ad 1a 2e 	      lda	random+1
   2035  0bb8		       8d 17 2e 	      sta	rtemp1
   2036  0bbb		       ad 19 2e 	      lda	random
   2037  0bbe		       0a		      asl
   2038  0bbf		       2e 17 2e 	      rol	rtemp1
   2039  0bc2		       0a		      asl
   2040  0bc3		       2e 17 2e 	      rol	rtemp1
   2041  0bc6		       18		      clc
   2042  0bc7		       6d 19 2e 	      adc	random
   2043  0bca
   2044  0bca		       48		      pha
   2045  0bcb
   2046  0bcb		       ad 17 2e 	      lda	rtemp1
   2047  0bce		       6d 1a 2e 	      adc	random+1
   2048  0bd1		       8d 1a 2e 	      sta	random+1
   2049  0bd4
   2050  0bd4		       68		      pla
   2051  0bd5
   2052  0bd5		       69 11		      adc	#$11
   2053  0bd7		       8d 19 2e 	      sta	random
   2054  0bda		       ad 1a 2e 	      lda	random+1
   2055  0bdd		       69 36		      adc	#$36
   2056  0bdf		       8d 1a 2e 	      sta	random+1
   2057  0be2
   2058  0be2		       ad 19 2e 	      lda	random
   2059  0be5		       85 52		      sta	R0
   2060  0be7		       ad 1a 2e 	      lda	random+1
   2061  0bea		       29 7f		      and	#$7f	;make positive
   2062  0bec		       85 53		      sta	R0+1
   2063  0bee							;
   2064  0bee							; R0 contains the number and R1 contains the max value.
   2065  0bee							;
   2066  0bee		       20 28 07 	      jsr	iDivNoPop
   2067  0bf1		       20 9f 1c 	      jsr	RestoreSigns
   2068  0bf4		       a5 56		      lda	MQ
   2069  0bf6		       85 52		      sta	R0
   2070  0bf8		       a5 57		      lda	MQ+1
   2071  0bfa		       85 53		      sta	R0+1
   2072  0bfc		       4c 02 07 	      jmp	pushR0nextIl
   2073  0bff				   irandom1
   2074  0bff		       a9 00		      lda	#0
   2075  0c01		       85 53		      sta	R0+1
   2076  0c03		       a9 01		      lda	#1
   2077  0c05		       85 52		      sta	R0
   2078  0c07		       4c 02 07 	      jmp	pushR0nextIl
   2079  0c0a
   2080  0c0a							; The following replaced by call to division/modulo
   2081  0c0a							;iRANDOM_2	lda	R0
   2082  0c0a							;		cmp	R1
   2083  0c0a							;		bne	iRANDOM_1
   2084  0c0a							;		lda	R0+1
   2085  0c0a							;		cmp	R1+1
   2086  0c0a							;		bne	iRANDOM_1	;need to subtract
   2087  0c0a							;
   2088  0c0a							; Subtract R1 from R0
   2089  0c0a							;
   2090  0c0a							;iRANDOM_sub	sec
   2091  0c0a							;		lda	R0
   2092  0c0a							;		sbc	R1
   2093  0c0a							;		sta	R0
   2094  0c0a							;		lda	R0+1
   2095  0c0a							;		sbc	R1+1
   2096  0c0a							;		sta	R0+1
   2097  0c0a							;		jmp	iRANDOM_2
   2098  0c0a							;
   2099  0c0a							; See if R1 > R0.  If so, branch to subtract.
   2100  0c0a							;
   2101  0c0a							;iRANDOM_1	lda	R0
   2102  0c0a							;		cmp	R1
   2103  0c0a							;		lda	R0+1
   2104  0c0a							;		sbc	R1+1
   2105  0c0a							;		bvc	iRANDOM_4
   2106  0c0a							;		eor	#$80
   2107  0c0a							;iRANDOM_4	bpl	iRANDOM_sub
   2108  0c0a							;
   2109  0c0a							; All done.  Almost.  Add one, then push the result.
   2110  0c0a							;
   2111  0c0a							;irandom1	inc	R0
   2112  0c0a							;		bne	iRANDOM_3
   2113  0c0a							;		inc	R0+1
   2114  0c0a							;iRANDOM_3
   2115  0c0a							;		  jsr	pushR0	;return value
   2116  0c0a							;		jmp	NextIL
   2117  0c0a							;
   2118  0c0a							; Poke a value into a memory location
   2119  0c0a		       8c 1f 2e    iPOKEMEMORY sty	tempy
   2120  0c0d		       20 1e 1c 	      jsr	popR0
   2121  0c10		       20 36 1c 	      jsr	popR1
   2122  0c13		       a0 00		      ldy	#0
   2123  0c15		       a5 52		      lda	R0
   2124  0c17		       91 54		      sta	(R1),y
   2125  0c19		       ac 1f 2e 	      ldy	tempy
   2126  0c1c		       4c c2 02 	      jmp	NextIL
   2127  0c1f							;
   2128  0c1f							; Get a value from a memory location
   2129  0c1f							;
   2130  0c1f		       8c 1f 2e    iPEEKMEMORY sty	tempy
   2131  0c22		       20 1e 1c 	      jsr	popR0
   2132  0c25		       a0 00		      ldy	#0
   2133  0c27		       b1 52		      lda	(R0),y
   2134  0c29		       ac 1f 2e 	      ldy	tempy
   2135  0c2c		       85 52		      sta	R0
   2136  0c2e		       a9 00		      lda	#0
   2137  0c30		       85 53		      sta	R0+1
   2138  0c32		       4c 02 07 	      jmp	pushR0nextIl
   2139  0c35							;
   2140  0c35							; Call to address return what ever is in a to the stack
   2141  0c35							; func2 will load a value into a before the call
   2142  0c35		       20 36 1c    iCallFunc  jsr	popR1
   2143  0c38		       a5 54		      lda	R1
   2144  0c3a		       20 46 0c 	      jsr	iCallRtn
   2145  0c3d		       85 52		      sta	R0
   2146  0c3f		       a9 00		      lda	#0
   2147  0c41		       85 53		      sta	R0+1
   2148  0c43		       20 02 07 	      jsr	pushR0nextIl
   2149  0c46				   iCallRtn
   2150  0c46		       20 1e 1c 	      jsr	popR0
   2151  0c49		       6c 52 00 	      jmp	(R0)
   2152  0c4c
   2153  0c4c
   2154  0c4c							;===========================================jlit======
   2155  0c4c							;Get a character from the terminal convert to value
   2156  0c4c							;leave the number on top of the stack
   2157  0c4c							;
   2158  0c4c				   iGETCHAR
   2159  0c4c		       20 23 1e 	      jsr	VGETCH
   2160  0c4f					      if	CTMON65
   2161  0c4f		       48		      pha
   2162  0c50		       20 20 1e 	      jsr	VOUTCH	;echo echo echo
   2163  0c53		       68		      pla
   2164  0c54					      endif
   2165  0c54		       85 52		      sta	R0
   2166  0c56		       a9 00		      lda	#0
   2167  0c58		       85 53		      sta	R0+1
   2168  0c5a		       20 9a 1b 	      jsr	pushR0
   2169  0c5d							;
   2170  0c5d		       4c c2 02 	      jmp	NextIL
   2171  0c60							;===========================================jusilostintim======
   2172  0c60							;Put a character to the terminal convert to
   2173  0c60							;
   2174  0c60		       20 1e 1c    iPUTCHAR   jsr	popR0
   2175  0c63		       a5 52		      lda	R0
   2176  0c65		       20 20 1e 	      jsr	VOUTCH
   2177  0c68		       4c c2 02 	      jmp	NextIL
   2178  0c6b							;=====================================================
   2179  0c6b							; Put the number on the stack out as hex, suppress leading 0
   2180  0c6b				   iHexOut
   2181  0c6b		       20 1e 1c 	      jsr	popR0
   2182  0c6e		       a5 53		      lda	R0+1
   2183  0c70		       f0 03		      beq	iHexSecondByte
   2184  0c72		       20 30 14 	      jsr	OUTHEX
   2185  0c75				   iHexSecondByte
   2186  0c75		       a5 52		      lda	R0
   2187  0c77		       20 30 14 	      jsr	OUTHEX
   2188  0c7a		       4c c2 02 	      jmp	NextIL
   2189  0c7d							;
   2190  0c7d							;=====================================================
   2191  0c7d							; Replace TOS with its absolute value.
   2192  0c7d							;
   2193  0c7d		       20 1e 1c    iABS       jsr	popR0
   2194  0c80		       a5 53		      lda	R0+1
   2195  0c82		       10 10		      bpl	iABS_1	;already positive
   2196  0c84		       49 ff		      eor	#$ff
   2197  0c86		       85 53		      sta	R0+1
   2198  0c88		       a5 52		      lda	R0
   2199  0c8a		       49 ff		      eor	#$ff
   2200  0c8c		       85 52		      sta	R0
   2201  0c8e		       e6 52		      inc	R0
   2202  0c90		       d0 02		      bne	iABS_1
   2203  0c92		       e6 53		      inc	R0+1
   2204  0c94		       4c 02 07    iABS_1     jmp	pushR0nextIl
   2205  0c97
   2206  0c97							;
   2207  0c97							;================================================================
   2208  0c97							; The set of logical operators
   2209  0c97				   iLogAnd
   2210  0c97		       20 1e 1c 	      jsr	popR0
   2211  0c9a		       20 36 1c 	      jsr	popR1
   2212  0c9d		       a5 52		      lda	R0
   2213  0c9f		       25 54		      and	R1
   2214  0ca1		       85 52		      sta	R0
   2215  0ca3		       a5 53		      lda	R0+1
   2216  0ca5		       25 55		      and	R1+1
   2217  0ca7		       85 53		      sta	R0+1
   2218  0ca9		       4c 02 07 	      jmp	pushR0nextIl
   2219  0cac				   iLogOr
   2220  0cac		       20 1e 1c 	      jsr	popR0
   2221  0caf		       20 36 1c 	      jsr	popR1
   2222  0cb2		       a5 52		      lda	R0
   2223  0cb4		       05 54		      ora	R1
   2224  0cb6		       85 52		      sta	R0
   2225  0cb8		       a5 53		      lda	R0+1
   2226  0cba		       05 55		      ora	R1+1
   2227  0cbc		       85 53		      sta	R0+1
   2228  0cbe		       4c 02 07 	      jmp	pushR0nextIl
   2229  0cc1				   iLogXor
   2230  0cc1		       20 1e 1c 	      jsr	popR0
   2231  0cc4		       20 36 1c 	      jsr	popR1
   2232  0cc7		       a5 52		      lda	R0
   2233  0cc9		       45 54		      eor	R1
   2234  0ccb		       85 52		      sta	R0
   2235  0ccd		       a5 53		      lda	R0+1
   2236  0ccf		       45 55		      eor	R1+1
   2237  0cd1		       85 53		      sta	R0+1
   2238  0cd3		       4c 02 07 	      jmp	pushR0nextIl
   2239  0cd6				   iLogNot
   2240  0cd6		       20 1e 1c 	      jsr	popR0
   2241  0cd9		       a5 52		      lda	R0
   2242  0cdb		       49 ff		      eor	#$FF
   2243  0cdd		       85 52		      sta	R0
   2244  0cdf		       a5 53		      lda	R0+1
   2245  0ce1		       49 ff		      eor	#$FF
   2246  0ce3		       85 53		      sta	R0+1
   2247  0ce5		       4c 02 07 	      jmp	pushR0nextIl
   2248  0ce8
   2249  0ce8				   iTruth
   2250  0ce8		       a9 ff		      lda	#$FF
   2251  0cea		       85 52		      sta	R0
   2252  0cec		       85 53		      sta	R0+1
   2253  0cee		       4c 02 07 	      jmp	pushR0nextIl
   2254  0cf1				   iFalse
   2255  0cf1		       a9 00		      lda	#$00
   2256  0cf3		       85 52		      sta	R0
   2257  0cf5		       85 53		      sta	R0+1
   2258  0cf7		       4c 02 07 	      jmp	pushR0nextIl
   2259  0cfa
   2260  0cfa							;================================================================
   2261  0cfa							;Set the IRQ service rtn line number
   2262  0cfa							;
   2263  0cfa		       78	   iSetIrq    sei		; disable the interupts
   2264  0cfb		       a9 00		      lda	#0	; Zero the Status flag
   2265  0cfd		       8d ca 24 	      sta	IRQStatus
   2266  0d00		       20 1e 1c 	      jsr	popR0	; get the line number
   2267  0d03		       a5 52		      lda	R0
   2268  0d05		       05 53		      ora	R0+1
   2269  0d07		       f0 20		      beq	iSetExt	; if it is zero disable all
   2270  0d09		       20 b4 1b 	      jsr	pushLN	; Save the current line pointer
   2271  0d0c		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2272  0d0e		       4c 9c 0b 	      jmp	ErrStkOver	; Check if there was an error
   2273  0d11				   iSetIrqOk
   2274  0d11		       20 e6 19 	      jsr	findLine	; Find the IRQ func Line Pointer
   2275  0d14		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2276  0d16		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2277  0d18		       8d cd 24 	      sta	IRQEntry+1
   2278  0d1b		       a5 4f		      lda	CURPTR
   2279  0d1d		       8d cc 24 	      sta	IRQEntry
   2280  0d20		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2281  0d22		       8d ca 24 	      sta	IRQStatus
   2282  0d25		       20 d9 1b 	      jsr	popLN	; Restore the old line number
   2283  0d28		       58		      cli		; Enable the interupts
   2284  0d29		       4c c2 02    iSetExt    jmp	NextIL
   2285  0d2c
   2286  0d2c		       20 d9 1b    iSetIrqErr jsr	popLN
   2287  0d2f		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2288  0d31		       a9 00		      lda	#0
   2289  0d33		       4c 17 06 	      jmp	iErr2
   2290  0d36							;
   2291  0d36		       20 1e 1c    iTRACEPROG jsr	popR0
   2292  0d39		       a5 52		      lda	R0
   2293  0d3b		       85 40		      sta	ILTrace
   2294  0d3d		       4c c2 02 	      jmp	NextIL
   2295  0d40
   2296  0d40							;=====================================================
   2297  0d40							; Define start of non page zero data
   2298 U2e31 ????				      seg.u	TBData
   2299 U2487					      org	PROGEND
   2300 U2487							;=================================================================
   2301 U2487							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U2487					      include	"tokenizer.asm"
      1  0d40					      seg	Code
      2  0d40		       ff ff ff ff DEBUGPARSER equ	TRUE	; Print debugging information
      3  0d40
      4  0d40							; Define the types of tokens found, and identifiers
      5  0d40		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0d40		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0d40		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0d40		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0d40
     10  0d40		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0d40		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0d40		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0d40
     14  0d40
     15  0d40		       00 a0	   tString    equ	$A0	; String all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0d40		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0d40		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0d40		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0d40							; Arrays of string are arrays of pointers 2 bytes
     20  0d40		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0d40		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0d40
     23  0d40		       3c 3e	   Operators  BYTE.b	"<>"
     24  0d42		       3c 3d		      BYTE.b	"<="
     25  0d44		       3e 3d		      BYTE.b	">="
     26  0d46		       3c 00		      BYTE.b	"<",0
     27  0d48		       3d 00		      BYTE.b	"=",0
     28  0d4a		       3e 00		      BYTE.b	">",0
     29  0d4c		       2b 00		      BYTE.b	"+",0
     30  0d4e		       2d 00		      BYTE.b	"-",0
     31  0d50		       2f 00		      BYTE.b	"/",0
     32  0d52		       25 00		      BYTE.b	"%",0
     33  0d54		       2a 00		      BYTE.b	"*",0
     34  0d56		       28 00		      BYTE.b	"(",0
     35  0d58		       29 00		      BYTE.b	")",0
     36  0d5a		       2c 00		      BYTE.b	",",0
     37  0d5c		       3b 00		      BYTE.b	";",0
     38  0d5e		       5b 00		      BYTE.b	"[",0
     39  0d60		       5d 00		      BYTE.b	"]",0
     40  0d62		       3a 00		      BYTE.b	":",0
     41  0d64		       24 00		      BYTE.b	"$",0
     42  0d66		       21 00		      BYTE.b	"!",0
     43  0d68		       3f 00		      BYTE.b	"?",0
     44  0d6a		       00 00		      BYTE.b	0,0
     45  0d6c
     46  0d6c		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     47  0d72		       e9 ea eb ec*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     48  0d77		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     49  0d7d		       e6 e7 e8 0b	      BYTE.b	oColon, oDollar, oBang, oQuestion
     50  0d81
     51  0d81		       00 0b	   oQuestion  equ	kPrint
     52  0d81
     53  0d81		       00 f1	   oLess      equ	$F1
     54  0d81		       00 f2	   oEqual     equ	$F2
     55  0d81		       00 f3	   oLessEqual equ	$F3
     56  0d81		       00 f4	   oGreater   equ	$F4
     57  0d81		       00 f5	   oNotEqual  equ	$F5
     58  0d81		       00 f6	   oGreaterEqual equ	$F6
     59  0d81
     60  0d81		       00 e0	   oLeftBracket equ	$E0
     61  0d81		       00 e1	   oRightBracket equ	$E1
     62  0d81		       00 e2	   oComma     equ	$E2
     63  0d81		       00 e3	   oSemiColon equ	$E3
     64  0d81		       00 e4	   oLeftSQBracket equ	$E4
     65  0d81		       00 e5	   oRightSQBracket equ	$E5
     66  0d81		       00 e6	   oColon     equ	$E6
     67  0d81		       00 e7	   oDollar    equ	$E7
     68  0d81		       00 e8	   oBang      equ	$E8
     69  0d81
     70  0d81
     71  0d81		       00 e9	   oPlus      equ	$E9
     72  0d81		       00 ea	   oMinus     equ	$EA
     73  0d81		       00 eb	   oDivide    equ	$EB
     74  0d81		       00 ec	   oModulo    equ	$EC
     75  0d81		       00 ed	   oMultiply  equ	$ED
     76  0d81		       00 ec	   oPercent   equ	oModulo
     77  0d81
     78  0d81		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     79  0d81
     80  0d81		       00 ff	   tError     equ	$FF	; Error should never happen
     81  0d81							;============================================================================================
     82  0d81							; Keyword and seperator values
     83  0d81				   '
     84  0d81		       00 01	   kBeginKey  equ	kLet
     85  0d81							;
     86  0d81		       00 01	   kLet       equ	1
     87  0d81		       00 02	   kInc       equ	kLet+1
     88  0d81		       00 03	   kDec       equ	kInc+1
     89  0d81		       00 04	   kIreturn   equ	kDec+1
     90  0d81		       00 05	   kIf	      equ	kIreturn+1
     91  0d81		       00 06	   kThen      equ	kIf+1
     92  0d81		       00 07	   kGoto      equ	kThen+1
     93  0d81		       00 08	   kGosub     equ	kGoto+1
     94  0d81		       00 09	   kReturn    equ	kGosub+1
     95  0d81		       00 0a	   kRem       equ	kReturn+1
     96  0d81		       00 0b	   kPrint     equ	kRem+1
     97  0d81		       00 0c	   kTaske     equ	kPrint+1
     98  0d81		       00 0d	   kTaskn     equ	kTaske+1
     99  0d81		       00 0e	   kTaskw     equ	kTaskn+1
    100  0d81		       00 0f	   kPoke      equ	kTaskw+1
    101  0d81		       00 10	   kPutch     equ	kPoke+1
    102  0d81		       00 11	   kCls       equ	kPutch+1
    103  0d81		       00 12	   kInput     equ	kCls+1
    104  0d81		       00 13	   kEnd       equ	kInput+1
    105  0d81		       00 14	   kIrq       equ	kEnd+1
    106  0d81		       00 15	   kKill      equ	kIrq+1
    107  0d81		       00 16	   kList      equ	kKill+1
    108  0d81		       00 17	   kRun       equ	kList+1
    109  0d81		       00 18	   kNew       equ	kRun+1
    110  0d81		       00 19	   kSlice     equ	kNew+1
    111  0d81		       00 1a	   kTrace     equ	kSlice+1
    112  0d81		       00 1b	   kExit      equ	kTrace+1
    113  0d81		       00 1c	   kSave      equ	kExit+1
    114  0d81		       00 1d	   kLoad      equ	kSave+1
    115  0d81		       00 1e	   kErase     equ	kLoad+1
    116  0d81		       00 1f	   kDir       equ	kErase+1
    117  0d81							;
    118  0d81							; End of actual key words
    119  0d81							;
    120  0d81		       00 1e	   kKeyCount  equ	kDir-kBeginKey
    121  0d81							;
    122  0d81							; Logical operators
    123  0d81							;
    124  0d81		       00 20	   kNot       equ	kDir+1
    125  0d81		       00 21	   kOr	      equ	kNot+1
    126  0d81		       00 22	   kXor       equ	kOr+1
    127  0d81		       00 23	   kAnd       equ	kXor+1
    128  0d81
    129  0d81							; numeric functions
    130  0d81							;
    131  0d81		       00 24	   kBeginFunc equ	kTrue
    132  0d81							;
    133  0d81							; Truth operators
    134  0d81							;
    135  0d81		       00 24	   kTrue      equ	kAnd+1
    136  0d81		       00 25	   kFalse     equ	kTrue+1
    137  0d81							; Functions
    138  0d81		       00 26	   kFree      equ	kFalse+1
    139  0d81		       00 27	   kGetch     equ	kFree+1
    140  0d81		       00 28	   kPeek      equ	kGetch+1
    141  0d81		       00 29	   kTask      equ	kPeek+1
    142  0d81		       00 2a	   kIpcc      equ	kTask+1
    143  0d81		       00 2b	   kIpcs      equ	kIpcc+1
    144  0d81		       00 2c	   kIpcr      equ	kIpcs+1
    145  0d81		       00 2d	   kRnd       equ	kIpcr+1
    146  0d81		       00 2e	   kStat      equ	kRnd+1
    147  0d81		       00 2f	   kAbs       equ	kStat+1
    148  0d81		       00 30	   kCall      equ	kAbs+1
    149  0d81		       00 31	   kGofn      equ	kCall+1
    150  0d81		       00 32	   kPid       equ	kGofn+1
    151  0d81							;
    152  0d81		       00 0e	   kFuncCount equ	kPid - kBeginFunc
    153  0d81
    154  0d81							;
    155  0d81							; Keyword table contains 49 keywords
    156  0d81				   KeyWordTable
      0  0d81					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0d81		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0d85					      db	kInc,"inC"
      1  0d85		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0d89					      db	kDec,"deC"
      1  0d89		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0d8d					      db	kIreturn,"ireturN"
      1  0d8d		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0d95					      db	kIf,"iF"
      1  0d95		       05 69 46 	      .byte.b	kIf,"iF"
      0  0d98					      db	kThen,"theN"
      1  0d98		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0d9d					      db	kGoto,"gotO"
      1  0d9d		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0da2					      db	kGosub,"gosuB"
      1  0da2		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0da8					      db	kReturn,"returN"
      1  0da8		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0daf					      db	kRem,"reM"
      1  0daf		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0db3					      db	kPrint,"prinT"
      1  0db3		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0db9					      db	kTaske,"taskE"
      1  0db9		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0dbf					      db	kTaskn,"taskN"
      1  0dbf		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0dc5					      db	kTaskw,"taskW"
      1  0dc5		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0dcb					      db	kPoke,"pokE"
      1  0dcb		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0dd0					      db	kPutch,"putcH"
      1  0dd0		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0dd6					      db	kCls,"clS"
      1  0dd6		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0dda					      db	kInput,"inpuT"
      1  0dda		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0de0					      db	kEnd,"enD"
      1  0de0		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0de4					      db	kIrq,"irQ"
      1  0de4		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0de8					      db	kKill,"kilL"
      1  0de8		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0ded					      db	kList,"lisT"
      1  0ded		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0df2					      db	kRun,"ruN"
      1  0df2		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0df6					      db	kNew,"neW"
      1  0df6		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0dfa					      db	kSlice,"slicE"
      1  0dfa		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0e00					      db	kTrace,"tracE"
      1  0e00		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0e06					      db	kExit,"exiT"
      1  0e06		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0e0b					      db	kSave,"savE"
      1  0e0b		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0e10					      db	kLoad,"loaD"
      1  0e10		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0e15					      db	kErase,"erasE"
      1  0e15		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0e1b					      db	kDir,"diR"
      1  0e1b		       1f 64 69 52	      .byte.b	kDir,"diR"
    188  0e1f							;Short form for statements:
      0  0e1f					      db	kIreturn,"ireT"
      1  0e1f		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0e24					      db	kReturn,"reT"
      1  0e24		       09 72 65 54	      .byte.b	kReturn,"reT"
    191  0e28
    192  0e28							;Logical and truth operators
      0  0e28					      db	kNot,"noT"
      1  0e28		       20 6e 6f 54	      .byte.b	kNot,"noT"
      0  0e2c					      db	kOr,"oR"
      1  0e2c		       21 6f 52 	      .byte.b	kOr,"oR"
      0  0e2f					      db	kXor,"xoR"
      1  0e2f		       22 78 6f 52	      .byte.b	kXor,"xoR"
      0  0e33					      db	kAnd,"anD"
      1  0e33		       23 61 6e 44	      .byte.b	kAnd,"anD"
    197  0e37							; Truth values
      0  0e37					      db	kTrue,"truE"
      1  0e37		       24 74 72 75*	      .byte.b	kTrue,"truE"
      0  0e3c					      db	kFalse,"falsE"
      1  0e3c		       25 66 61 6c*	      .byte.b	kFalse,"falsE"
    200  0e42
    201  0e42							;functions returning values
    202  0e42
      0  0e42					      db	kFree,"freE"
      1  0e42		       26 66 72 65*	      .byte.b	kFree,"freE"
      0  0e47					      db	kGetch,"getcH"
      1  0e47		       27 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0e4d					      db	kPeek,"peeK"
      1  0e4d		       28 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0e52					      db	kTask,"tasK"
      1  0e52		       29 74 61 73*	      .byte.b	kTask,"tasK"
      0  0e57					      db	kIpcc,"ipcC"
      1  0e57		       2a 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0e5c					      db	kIpcs,"ipcS"
      1  0e5c		       2b 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0e61					      db	kIpcr,"ipcR"
      1  0e61		       2c 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0e66					      db	kRnd,"rnD"
      1  0e66		       2d 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0e6a					      db	kStat,"staT"
      1  0e6a		       2e 73 74 61*	      .byte.b	kStat,"staT"
      0  0e6f					      db	kAbs,"abS"
      1  0e6f		       2f 61 62 53	      .byte.b	kAbs,"abS"
      0  0e73					      db	kCall,"calL"
      1  0e73		       30 63 61 6c*	      .byte.b	kCall,"calL"
      0  0e78					      db	kGofn,"gofN"
      1  0e78		       31 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0e7d					      db	kPid,"piD"
      1  0e7d		       32 70 69 44	      .byte.b	kPid,"piD"
      0  0e81					      db	0,0
      1  0e81		       00 00		      .byte.b	0,0
    217  0e83
    218  0e83		       0e 83	   KeyWordTableEnd equ	*
    219  0e83		       01 02	   KeyWordTableLength equ	* - KeyWordTable
    220  0e83		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    221  0f83		       00 00 00    printStorage ds	3
    222  0f86							;==================================================================================================================
    223  0f86							; Read accross the inputline and output to TOKENBUFFER
    224  0f86							; Format   byte      Description
    225  0f86							;	     0	      length of line 1-255
    226  0f86							;	    0-1       Line Number
    227  0f86							;	    Tokens and litteral values encoded into the line
    228  0f86							;
    229  0f86							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    230  0f86							;  if fails then test for keywords
    231  0f86							;  if fails then test for variables and arrays
    232  0f86							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    233  0f86
    234  0f86				   ParseInputLine
    235  0f86					      if	DEBUGPARSER
    236  0f86		       20 54 1e 	      jsr	SetOutDebug
    237  0f89		       20 34 11 	      jsr	DebugClearBuffer
    238  0f8c					      endif
    239  0f8c		       a5 51		      lda	CUROFF
    240  0f8e		       48		      pha
    241  0f8f		       8a		      txa
    242  0f90		       48		      pha
    243  0f91		       98		      tya
    244  0f92		       48		      pha
    245  0f93		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    246  0f95		       20 4c 1a 	      jsr	getDecimal	; Check for a line number, none is ok too
    247  0f98		       84 51		      sty	CUROFF
    248  0f9a		       20 ab 11 	      jsr	R02TOKEN	; Move R0 to token buffer
    249  0f9d
    250  0f9d				   ParseInputLoop
    251  0f9d		       a4 51		      ldy	CUROFF
    252  0f9f		       20 ce 1c 	      jsr	SkipSpaces	; Skip any spaces
    253  0fa2		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    254  0fa4		       b9 8a 2d 	      lda	LINBUF,y	; Check for end of line
    255  0fa7		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    256  0fa9
    257  0fa9				   ParseForNumber
    258  0fa9		       20 95 10 	      jsr	ParseNumeric	; Check for a numeric value
    259  0fac		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    260  0fae
    261  0fae				   ParseForString
    262  0fae		       20 6b 10 	      jsr	ParseString	; Check for a string
    263  0fb1		       90 ea		      bcc	ParseInputLoop	; It was a string
    264  0fb3
    265  0fb3				   ParseForOp
    266  0fb3		       20 d3 10 	      jsr	ParseForOperator	; Check for operator or punctuation
    267  0fb6		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    268  0fb8
    269  0fb8				   ParseForKey
    270  0fb8		       20 e5 0f 	      jsr	ParseLookupKey	; Check for a keyword value
    271  0fbb		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    272  0fbd
    273  0fbd				   ParseForVar
    274  0fbd		       20 74 11 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    275  0fc0		       90 db		      bcc	ParseInputLoop
    276  0fc2
    277  0fc2				   ParseKeepChar		; if it does not parse just keep it safe
    278  0fc2		       b9 8a 2d 	      lda	LINBUF,y
    279  0fc5		       9d 83 0e 	      sta	TOKENBUFFER,x
    280  0fc8		       e8		      inx
    281  0fc9		       c8		      iny
    282  0fca		       84 51		      sty	CUROFF
    283  0fcc		       d0 cf		      bne	ParseInputLoop
    284  0fce
    285  0fce				   ParseComplete
    286  0fce		       a9 00		      lda	#0
    287  0fd0		       9d 83 0e 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    288  0fd3		       e8		      inx
    289  0fd4		       8e 83 0e 	      stx	TOKENBUFFER	; Place size including null into buffer start
    290  0fd7
    291  0fd7		       68		      pla
    292  0fd8		       a8		      tay
    293  0fd9		       68		      pla
    294  0fda		       aa		      tax
    295  0fdb		       68		      pla
    296  0fdc		       85 51		      sta	CUROFF
    297  0fde
    298  0fde					      if	DEBUGPARSER
    299  0fde
    300  0fde		       20 46 11 	      jsr	printTokenBuffer
    301  0fe1							;jsr	  DebugPrintProgramLine
    302  0fe1		       20 82 1e 	      jsr	SetOutDebugEnd
    303  0fe4
    304  0fe4					      endif
    305  0fe4		       60		      rts
    306  0fe5
    307  0fe5							;==================================================================================================================
    308  0fe5							; Look at curptr, curpos and check for a valid KeyWord
    309  0fe5							; A contains the index value. c is clear
    310  0fe5							;		     not found c set  A undefined
    311  0fe5							; X is prerserved
    312  0fe5							;
    313  0fe5				   ParseLookupKey
    314  0fe5		       86 58		      stx	R2
    315  0fe7		       a0 00		      ldy	#0
    316  0fe9		       a9 81		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    317  0feb		       85 54		      sta	R1
    318  0fed		       a9 0d		      lda	#KeyWordTable>>8
    319  0fef		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    320  0ff1		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    321  0ff3		       85 52		      sta	R0	; Save until next keyword
    322  0ff5		       c8		      iny		; Point to first character of keyword
    323  0ff6		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    324  0ff8
    325  0ff8					      if	DEBUGPARSER
    326  0ff8							;    jsr DebugKeyword
    327  0ff8					      endif
    328  0ff8
    329  0ff8				   ParseLookupLoop
    330  0ff8		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    331  0ffa		       29 df		      and	#%11011111	; Force Keyword to upper case
    332  0ffc		       dd 8a 2d 	      cmp	LINBUF,x	; Check the input buffer
    333  0fff		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    334  1001		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    335  1003		       dd 8a 2d 	      cmp	LINBUF,x	; Compare value to upercase
    336  1006		       d0 22		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    337  1008
    338  1008				   ParseNextLetter
    339  1008		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    340  100a		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    341  100c		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    342  100e		       e8		      inx		; Point to next char in the input buffer
    343  100f		       c8		      iny		; Point to the next character in the Keyword table
    344  1010		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    345  1012		       dd 8a 2d 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    346  1015		       f0 13		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    347  1017		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    348  1019
    349  1019				   ParseKeyFound
    350  1019		       a5 52		      lda	R0	; get the keyword index
    351  101b		       c9 0a		      cmp	#kRem	; remark statement
    352  101d		       f0 33		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    353  101f
    354  101f				   ParseKeyDone
    355  101f		       e8		      inx		; point past the last character
    356  1020		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    357  1022		       a6 58		      ldx	R2	; Restore the original x pointer
    358  1024		       9d 83 0e 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    359  1027		       e8		      inx		; Point to next position in the output buffer
    360  1028		       18		      clc		; C flag clear, we found it
    361  1029		       60		      rts
    362  102a
    363  102a							; Move forward to the next entry in table
    364  102a				   ParseNextEntry
    365  102a		       b1 54		      lda	(R1),y	; Get the next character in the token
    366  102c		       29 20		      and	#%00100000	; Is it the last character
    367  102e		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    368  1030		       c8		      iny		; Point to next char in the entry
    369  1031		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    370  1033
    371  1033				   ParseEndOfEntry
    372  1033		       c8		      iny		; Point to the byte after the last character
    373  1034		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    374  1035		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    375  1036		       65 54		      adc	R1
    376  1038		       85 54		      sta	R1
    377  103a		       a5 55		      lda	R1+1
    378  103c		       69 00		      adc	#0
    379  103e		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    380  1040		       a0 00		      ldy	#0	; Reset the index back to zero
    381  1042		       b1 54		      lda	(R1),y	; get keyword value
    382  1044		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    383  1046		       85 52		      sta	R0	; save the next token value
    384  1048		       c8		      iny		; Inc past token value
    385  1049
    386  1049					      if	DEBUGPARSER
    387  1049							;    jsr DebugKeyword
    388  1049					      endif
    389  1049		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    390  104b		       4c f8 0f 	      jmp	ParseLookupLoop	; branch back for next key word
    391  104e
    392  104e				   ParseNoneFound
    393  104e		       a6 58		      ldx	R2	; it did not faind one, restore x to position in output buffer
    394  1050		       38		      sec		; c clear, not found
    395  1051		       60		      rts
    396  1052
    397  1052							;===============================================================================
    398  1052							; Move everything from current position until the end of line into the token buffer
    399  1052							;
    400  1052		       c8	   ParseMoveLine iny		; next byte to parse
    401  1053		       a6 58		      ldx	R2	; where to place in the buffer
    402  1055		       a5 52		      lda	R0
    403  1057		       9d 83 0e 	      sta	TOKENBUFFER,x	;Put the rem into the buffer
    404  105a		       e8		      inx		;Skip to next byte after the reM
    405  105b				   ParseMoveLoop
    406  105b		       b9 8a 2d 	      lda	LINBUF,y	; get the next byte
    407  105e		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    408  1060		       9d 83 0e 	      sta	TOKENBUFFER,x	; save the byte
    409  1063		       c8		      iny
    410  1064		       e8		      inx
    411  1065		       d0 f4		      bne	ParseMoveLoop
    412  1067				   ParseMoveDone
    413  1067		       84 51		      sty	CUROFF
    414  1069		       18		      clc
    415  106a		       60		      rts
    416  106b
    417  106b							;=========================================================================================================
    418  106b							;ParseString Parse a quotes string
    419  106b							; on input X = outbuf position
    420  106b							; y = inbuf position
    421  106b							; Copies string to output buffer, updates x and y
    422  106b				   ParseString
    423  106b		       a4 51		      ldy	CUROFF
    424  106d		       a9 a0		      lda	#tString
    425  106f		       9d 83 0e 	      sta	TOKENBUFFER,X
    426  1072		       b9 8a 2d 	      lda	LINBUF,y
    427  1075		       c9 22		      cmp	#'"
    428  1077		       d0 1a		      bne	ParseStringInvalid
    429  1079		       e8		      inx
    430  107a		       9d 83 0e 	      sta	TOKENBUFFER,x
    431  107d		       e8		      inx
    432  107e		       c8		      iny
    433  107f
    434  107f				   ParseStringLoop
    435  107f		       b9 8a 2d 	      lda	LINBUF,y
    436  1082		       9d 83 0e 	      sta	TOKENBUFFER,x
    437  1085		       c9 22		      cmp	#'"
    438  1087		       f0 04		      beq	ParseStringDone
    439  1089		       c8		      iny
    440  108a		       e8		      inx
    441  108b		       d0 f2		      bne	ParseStringLoop
    442  108d
    443  108d				   ParseStringDone
    444  108d		       e8		      inx
    445  108e		       c8		      iny
    446  108f		       84 51		      sty	CUROFF
    447  1091		       18		      clc
    448  1092		       60		      rts
    449  1093
    450  1093				   ParseStringInvalid
    451  1093		       38		      sec
    452  1094		       60		      rts
    453  1095
    454  1095							;=========================================================================================================
    455  1095							; Get numeric values and return value in RO and type in a
    456  1095							;
    457  1095				   ParseNumeric
    458  1095		       a4 51		      ldy	CUROFF
    459  1097		       b9 8a 2d 	      lda	LINBUF,y
    460  109a		       c9 30		      cmp	#'0
    461  109c		       90 33		      bcc	ParseNumInvalid
    462  109e		       c9 3a		      cmp	#'9+1
    463  10a0		       b0 2f		      bcs	ParseNumInvalid
    464  10a2		       86 58		      stx	R2
    465  10a4		       20 4c 1a 	      jsr	getDecimal
    466  10a7		       a6 58		      ldx	R2
    467  10a9		       84 51		      sty	CUROFF
    468  10ab		       a5 53		      lda	R0+1
    469  10ad		       f0 14		      beq	ParseByteValue
    470  10af
    471  10af				   ParseIntegerValue
    472  10af		       a9 a1		      lda	#tInteger
    473  10b1		       9d 83 0e 	      sta	TOKENBUFFER,x
    474  10b4		       e8		      inx
    475  10b5		       a5 52		      lda	R0
    476  10b7		       9d 83 0e 	      sta	TOKENBUFFER,x
    477  10ba		       e8		      inx
    478  10bb		       a5 53		      lda	R0+1
    479  10bd		       9d 83 0e 	      sta	TOKENBUFFER,X
    480  10c0		       e8		      inx
    481  10c1		       18		      clc
    482  10c2		       60		      rts
    483  10c3
    484  10c3				   ParseByteValue
    485  10c3		       a9 a2		      lda	#tByte
    486  10c5		       9d 83 0e 	      sta	TOKENBUFFER,x
    487  10c8		       e8		      inx
    488  10c9		       a5 52		      lda	R0
    489  10cb		       9d 83 0e 	      sta	TOKENBUFFER,x
    490  10ce		       e8		      inx
    491  10cf		       18		      clc
    492  10d0		       60		      rts
    493  10d1
    494  10d1				   ParseNumInvalid		;Not a valid Numeric
    495  10d1		       38		      sec
    496  10d2		       60		      rts
    497  10d3
    498  10d3							;=========================================================================================================
    499  10d3							;Parse for operators and seperators
    500  10d3							; on exit the A has the oper code, c is clear
    501  10d3							;		 not found then c is set
    502  10d3							;	x is preserved
    503  10d3							;
    504  10d3				   ParseForOperator
    505  10d3		       86 58		      stx	R2
    506  10d5		       a4 51		      ldy	CUROFF
    507  10d7		       a2 00		      ldx	#0
    508  10d9					      if	DEBUGPARSER
    509  10d9							;	jsr    DebugPrintOP
    510  10d9					      endif
    511  10d9
    512  10d9				   ParseOpLoop
    513  10d9		       bd 40 0d 	      lda	Operators,x	; First byte of operator
    514  10dc		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    515  10de
    516  10de		       d9 8a 2d 	      cmp	LINBUF,y	; Check the first byte
    517  10e1		       d0 1c		      bne	ParseOpNext
    518  10e3
    519  10e3		       c8		      iny
    520  10e4
    521  10e4		       bd 41 0d 	      lda	Operators+1,x
    522  10e7		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    523  10e9
    524  10e9		       d9 8a 2d 	      cmp	LINBUF,y
    525  10ec		       d0 11		      bne	ParseOpNext
    526  10ee
    527  10ee				   ParseOpFound
    528  10ee		       c8		      iny
    529  10ef
    530  10ef				   ParseOpFoundSingle
    531  10ef		       84 51		      sty	CUROFF
    532  10f1
    533  10f1		       8a		      txa
    534  10f2		       4a		      lsr
    535  10f3		       aa		      tax
    536  10f4		       bd 6c 0d 	      lda	OperValues,x
    537  10f7		       a6 58		      ldx	R2
    538  10f9		       9d 83 0e 	      sta	TOKENBUFFER,x
    539  10fc		       e8		      inx
    540  10fd		       18		      clc
    541  10fe		       60		      rts
    542  10ff
    543  10ff				   ParseOpNext
    544  10ff		       e8		      inx
    545  1100		       e8		      inx
    546  1101
    547  1101					      if	DEBUGPARSER
    548  1101							;	 jsr	DebugPrintOP
    549  1101					      endif
    550  1101		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    551  1103		       4c d9 10 	      jmp	ParseOpLoop
    552  1106
    553  1106				   ParseOpNotFound
    554  1106		       a6 58		      ldx	R2
    555  1108		       38		      sec
    556  1109		       60		      rts
    557  110a							;=========================================================================================================
    558  110a					      if	DEBUGPARSER
    559  110a							;Print the text of a keyword
    560  110a							;Input R1    = offset into table
    561  110a				   DebugKeyword
    562  110a		       98		      tya
    563  110b		       48		      pha
    564  110c		       a0 01		      ldy	#1
    565  110e				   DebugKeyLoop
    566  110e		       b1 54		      lda	(R1),y
    567  1110		       20 20 1e 	      jsr	VOUTCH
    568  1113		       29 20		      and	#%00100000
    569  1115		       f0 03		      beq	DebugKeyDone
    570  1117		       c8		      iny
    571  1118		       d0 f4		      bne	DebugKeyLoop
    572  111a
    573  111a				   DebugKeyDone
    574  111a		       20 d7 1c 	      jsr	CRLF
    575  111d		       68		      pla
    576  111e		       a8		      tay
    577  111f		       60		      rts
    578  1120							;========================================
    579  1120				   DebugPrintOP
    580  1120		       48		      pha
    581  1121		       bd 40 0d 	      lda	Operators,x
    582  1124		       20 20 1e 	      jsr	VOUTCH
    583  1127		       bd 41 0d 	      lda	Operators+1,x
    584  112a		       f0 03		      beq	DbgPrtOpDone
    585  112c		       20 20 1e 	      jsr	VOUTCH
    586  112f
    587  112f				   DbgPrtOpDone
    588  112f		       20 d7 1c 	      jsr	CRLF
    589  1132		       68		      pla
    590  1133		       60		      rts
    591  1134							;=======================================
    592  1134				   DebugClearBuffer
    593  1134		       8a		      txa
    594  1135		       48		      pha
    595  1136		       a2 ff		      ldx	#$FF
    596  1138		       a9 00		      lda	#0
    597  113a				   DebugClrLoop
    598  113a		       9d 83 0e 	      sta	TOKENBUFFER,x
    599  113d		       ca		      dex
    600  113e		       d0 fa		      bne	DebugClrLoop
    601  1140		       9d 83 0e 	      sta	TOKENBUFFER,x
    602  1143		       68		      pla
    603  1144		       aa		      tax
    604  1145		       60		      rts
    605  1146
    606  1146							;=====================================================
    607  1146							; Print the parser buffer as hex values
    608  1146				   printTokenBuffer
    609  1146		       8e 83 0f 	      stx	printStorage
    610  1149		       8c 84 0f 	      sty	printStorage+1
    611  114c		       8d 85 0f 	      sta	printStorage+2
    612  114f
    613  114f		       ae 83 0e 	      ldx	TOKENBUFFER	; get the length of the buffer
    614  1152		       e8		      inx		; we want to show the last zero byte
    615  1153		       a0 00		      ldy	#0
    616  1155
    617  1155				   printHexLoop
    618  1155		       b9 83 0e 	      lda	TOKENBUFFER,y	; get the character
    619  1158		       20 30 14 	      jsr	HexToOut	; print it
    620  115b		       a9 20		      lda	#$20
    621  115d		       20 20 1e 	      jsr	VOUTCH
    622  1160		       c8		      iny
    623  1161		       ca		      dex
    624  1162		       e0 00		      cpx	#0
    625  1164		       d0 ef		      bne	printHexLoop
    626  1166		       20 d7 1c 	      jsr	CRLF
    627  1169
    628  1169		       ac 84 0f 	      ldy	printStorage+1
    629  116c		       ae 83 0f 	      ldx	printStorage
    630  116f		       ad 85 0f 	      lda	printStorage+2
    631  1172				   printHexDone
    632  1172		       18		      clc
    633  1173		       60		      rts
    634  1174					      endif
    635  1174
    636  1174
    637  1174							;=========================================================================================================
    638  1174							; Parse for variables A-Z @, ^  x!x x[op]
    639  1174				   ParseForVariable
    640  1174		       a4 51		      ldy	CUROFF
    641  1176		       b9 8a 2d 	      lda	LINBUF,y
    642  1179		       c9 5e		      cmp	#'^	; is it an exit code
    643  117b		       d0 04		      bne	ParseVarMem
    644  117d		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    645  117f		       d0 1f		      bne	ParseVarSpecial
    646  1181
    647  1181				   ParseVarMem
    648  1181		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    649  1183		       d0 04		      bne	ParseVarStack
    650  1185		       a9 9d		      lda	#tVat
    651  1187		       d0 17		      bne	ParseVarSpecial
    652  1189
    653  1189				   ParseVarStack
    654  1189		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    655  118b		       d0 04		      bne	ParseVarLetters
    656  118d		       a9 9c		      lda	#tVhash
    657  118f		       d0 0f		      bne	ParseVarSpecial
    658  1191
    659  1191				   ParseVarLetters
    660  1191		       29 df		      and	#%11011111	; Force upper case
    661  1193		       c9 41		      cmp	#'A
    662  1195		       90 12		      bcc	ParseVarInvalid
    663  1197		       c9 5b		      cmp	#'Z+1
    664  1199		       b0 0e		      bcs	ParseVarInvalid
    665  119b							;
    666  119b							; The condition is true, so convert to an index, push
    667  119b							; it onto the stack and continue running.
    668  119b							;
    669  119b		       38		      sec
    670  119c		       e9 41		      sbc	#'A	;index is zero based
    671  119e		       09 80		      ora	#$80
    672  11a0
    673  11a0				   ParseVarSpecial
    674  11a0		       9d 83 0e 	      sta	TOKENBUFFER,x
    675  11a3		       e8		      inx
    676  11a4		       c8		      iny
    677  11a5		       84 51		      sty	CUROFF
    678  11a7		       18		      clc
    679  11a8		       60		      rts
    680  11a9
    681  11a9				   ParseVarInvalid
    682  11a9		       38		      sec
    683  11aa		       60		      rts
    684  11ab
    685  11ab
    686  11ab							;=========================================================================================================
    687  11ab							; Transfer R0 to the TOKENBUFFER
    688  11ab							;
    689  11ab				   R02TOKEN
    690  11ab		       a5 52		      lda	R0
    691  11ad		       9d 83 0e 	      sta	TOKENBUFFER,x
    692  11b0		       e8		      inx
    693  11b1		       a5 53		      lda	R0+1
    694  11b3		       9d 83 0e 	      sta	TOKENBUFFER,x
    695  11b6		       e8		      inx
    696  11b7		       18		      clc
    697  11b8		       60		      rts
    698  11b9							;=========================================================================
    699  11b9							; Transfer word in Token Buffer to R0
    700  11b9				   TOKEN2R0
    701  11b9		       b9 83 0e 	      lda	TOKENBUFFER,y
    702  11bc		       85 52		      sta	R0
    703  11be		       c8		      iny
    704  11bf		       ca		      dex
    705  11c0		       b9 83 0e 	      lda	TOKENBUFFER,y
    706  11c3		       c8		      iny
    707  11c4		       ca		      dex
    708  11c5		       85 53		      sta	R0+1
    709  11c7		       60		      rts
    710  11c8							;==========================================================================
    711  11c8							; Transfer	Display Buffer position to R0
    712  11c8							;
    713  11c8				   DPL2R0
    714  11c8		       b1 59		      lda	(dpl),y
    715  11ca		       85 52		      sta	R0
    716  11cc		       c8		      iny
    717  11cd		       ca		      dex
    718  11ce		       b1 59		      lda	(dpl),y
    719  11d0		       c8		      iny
    720  11d1		       ca		      dex
    721  11d2		       85 53		      sta	R0+1
    722  11d4		       60		      rts
    723  11d5
    724  11d5							;==========================================================================================================
    725  11d5							;Debug   Print a Program Line from compile buffer
    726  11d5							;
    727  11d5				   DebugPrintProgramLine
    728  11d5		       48		      pha
    729  11d6		       a9 83		      lda	#TOKENBUFFER&$FF
    730  11d8		       85 59		      sta	dpl
    731  11da		       a9 0e		      lda	#TOKENBUFFER>>8
    732  11dc		       85 5a		      sta	dpl+1
    733  11de		       68		      pla
    734  11df
    735  11df							; Decode and print a line of program text
    736  11df							; on entry	 dpl points to line of code to print
    737  11df							; on exit	 no change in reg of dpl
    738  11df							;
    739  11df				   PrintProgramLine
    740  11df
    741  11df		       8e 83 0f 	      stx	printStorage
    742  11e2		       8c 84 0f 	      sty	printStorage+1
    743  11e5		       48		      pha
    744  11e6
    745  11e6		       a0 01		      ldy	#1	; index into the token buffer
    746  11e8		       84 58		      sty	R2	; print unsigned decimal
    747  11ea		       a0 00		      ldy	#0
    748  11ec		       b1 59		      lda	(dpl),y	; get number of bytes
    749  11ee		       aa		      tax		; place pointer into x
    750  11ef		       c8		      iny
    751  11f0		       ca		      dex		; Deduct the length byte
    752  11f1		       20 c8 11 	      jsr	DPL2R0	; Print the line number
    753  11f4		       20 7e 13 	      jsr	PrintDecimal
    754  11f7		       a9 20		      lda	#$20
    755  11f9		       20 20 1e 	      jsr	VOUTCH
    756  11fc
    757  11fc				   PrintProgLoop
    758  11fc		       b1 59		      lda	(dpl),y	; Get a character
    759  11fe		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    760  1200		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    761  1202		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    762  1204
    763  1204				   PrintProgVars
    764  1204		       b1 59		      lda	(dpl),y
    765  1206		       29 e0		      and	#$E0	; Check for operators and punctuation
    766  1208		       c9 e0		      cmp	#$E0
    767  120a		       f0 6b		      beq	PrintProgOperatorVect
    768  120c
    769  120c		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    770  120e		       c9 9e		      cmp	#$9D+1
    771  1210		       90 62		      bcc	PrintProgVariableVec
    772  1212		       29 a0		      and	#$A0	; Check for a valid datatype
    773  1214		       c9 a0		      cmp	#$A0
    774  1216		       f0 06		      beq	PrintDataType	; if not just print the character
    775  1218		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    776  121a		       ca		      dex		; Ok we are prcessing it
    777  121b		       c8		      iny
    778  121c		       d0 25		      bne	PrintContinue	; Print and do the next character
    779  121e
    780  121e				   PrintDataType
    781  121e		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    782  1220		       c9 a0		      cmp	#tString
    783  1222		       f0 31		      beq	PrintStringVariable
    784  1224
    785  1224				   PrintProgNumber
    786  1224		       c8		      iny		; we have a numerical integer value
    787  1225		       ca		      dex
    788  1226		       48		      pha
    789  1227		       a9 00		      lda	#0
    790  1229		       85 53		      sta	R0+1
    791  122b		       85 58		      sta	R2	; Set to print signed number
    792  122d		       b1 59		      lda	(dpl),y
    793  122f		       85 52		      sta	R0
    794  1231		       68		      pla
    795  1232		       c9 a1		      cmp	#tInteger
    796  1234		       d0 06		      bne	PrintProgNumDone
    797  1236		       c8		      iny
    798  1237		       ca		      dex
    799  1238		       b1 59		      lda	(dpl),y
    800  123a		       85 53		      sta	R0+1
    801  123c
    802  123c				   PrintProgNumDone
    803  123c		       c8		      iny
    804  123d		       ca		      dex
    805  123e		       20 7e 13 	      jsr	PrintDecimal
    806  1241
    807  1241				   PrintProgNext
    808  1241		       a9 20		      lda	#$20
    809  1243				   PrintContinue
    810  1243		       20 20 1e 	      jsr	VOUTCH
    811  1246				   PrintProgSkipSpace
    812  1246		       e0 00		      cpx	#0
    813  1248		       d0 b2		      bne	PrintProgLoop
    814  124a				   PrintProgramComplete
    815  124a		       20 d7 1c 	      jsr	CRLF
    816  124d
    817  124d		       ae 83 0f 	      ldx	printStorage
    818  1250		       ac 84 0f 	      ldy	printStorage+1
    819  1253		       68		      pla
    820  1254
    821  1254		       60		      rts
    822  1255							;=================================================================================================================
    823  1255							; Print a string variable including the quotes
    824  1255							; On Input	 y is offset into buffer
    825  1255							; On Exit	 y is updated to new offset
    826  1255
    827  1255				   PrintStringVariable
    828  1255		       c8		      iny
    829  1256		       a9 22		      lda	#'"
    830  1258		       20 20 1e 	      jsr	VOUTCH
    831  125b		       c8		      iny
    832  125c		       a5 59		      lda	dpl
    833  125e		       85 5e		      sta	PrtFrom
    834  1260		       a5 5a		      lda	dpl+1
    835  1262		       85 5f		      sta	PrtFrom+1
    836  1264		       a9 22		      lda	#'"
    837  1266		       8d 1f 2e 	      sta	PrtTerm
    838  1269		       20 9b 14 	      jsr	PrtLoop
    839  126c		       a9 22		      lda	#'"
    840  126e		       20 20 1e 	      jsr	VOUTCH
    841  1271		       4c 41 12 	      jmp	PrintProgNext
    842  1274
    843  1274				   PrintProgVariableVec
    844  1274		       4c ff 12 	      jmp	PrintProgVariable
    845  1277
    846  1277				   PrintProgOperatorVect
    847  1277		       4c d6 12 	      jmp	PrintProgOperator
    848  127a							;===============================================================================================================
    849  127a							; On entry dpl points to the buffer we are printing from
    850  127a							;	    y	current offset into the dpl buffer
    851  127a							; all registers preserved
    852  127a							;
    853  127a				   PrintKeyword
    854  127a
    855  127a		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    856  127c		       85 52		      sta	R0	; The value we are looking for
    857  127e		       c8		      iny		; Inc i to point to the next char to be printed
    858  127f
    859  127f		       98		      tya		; Save y and x for the return
    860  1280		       48		      pha
    861  1281		       8a		      txa
    862  1282		       48		      pha
    863  1283
    864  1283		       a9 81		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    865  1285		       85 54		      sta	R1
    866  1287		       a9 0d		      lda	#KeyWordTable>>8
    867  1289		       85 55		      sta	R1+1
    868  128b
    869  128b
    870  128b				   PrintKeyLoop
    871  128b		       a0 00		      ldy	#0	; Index into the keyword entry
    872  128d		       b1 54		      lda	(R1),y	; Get token value for this entry
    873  128f		       c8		      iny		; Point to first byte of key
    874  1290		       c5 52		      cmp	R0	; Compare to the token we are looking for
    875  1292		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    876  1294
    877  1294				   PrintKeyNext
    878  1294		       b1 54		      lda	(R1),y	; Get key letter
    879  1296		       c8		      iny		; Point to next byte always
    880  1297		       29 20		      and	#%00100000	; Check for last character in key work
    881  1299		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    882  129b
    883  129b		       98		      tya		; Trabsfer y to a for the addition
    884  129c		       18		      clc		; Table > 256 bytes
    885  129d		       65 54		      adc	R1
    886  129f		       85 54		      sta	R1
    887  12a1		       a9 00		      lda	#0
    888  12a3		       65 55		      adc	R1+1
    889  12a5		       85 55		      sta	R1+1
    890  12a7		       4c 8b 12 	      jmp	PrintKeyLoop
    891  12aa
    892  12aa				   PrintKeyFound
    893  12aa		       b1 54		      lda	(R1),y	; letter from key table
    894  12ac		       48		      pha		; Save it for later check
    895  12ad		       09 20		      ora	#%00100000	; Force it to lower case
    896  12af		       20 20 1e 	      jsr	VOUTCH	; Print it out
    897  12b2		       c8		      iny		; Point to next character
    898  12b3		       68		      pla		; Restore the value
    899  12b4		       29 20		      and	#%00100000	; Check if it was last char in keyword
    900  12b6		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    901  12b8
    902  12b8		       68		      pla		; Restore the x and y values
    903  12b9		       aa		      tax
    904  12ba		       68		      pla
    905  12bb		       a8		      tay
    906  12bc
    907  12bc				   PrintChkRem
    908  12bc		       a9 0a		      lda	#kRem
    909  12be		       c5 52		      cmp	R0
    910  12c0		       d0 11		      bne	PrintKeyDone
    911  12c2				   PrintKeyRem
    912  12c2		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    913  12c4		       85 5e		      sta	PrtFrom
    914  12c6		       a5 5a		      lda	dpl+1
    915  12c8		       85 5f		      sta	PrtFrom+1
    916  12ca		       a9 00		      lda	#0
    917  12cc		       8d 1f 2e 	      sta	PrtTerm
    918  12cf		       20 9b 14 	      jsr	PrtLoop
    919  12d2		       88		      dey		; point back to the terminating null value
    920  12d3				   PrintKeyDone
    921  12d3		       4c 41 12 	      jmp	PrintProgNext
    922  12d6							;==================================================================================================================
    923  12d6							;Print Variable, number or operator
    924  12d6				   PrintProgOperator
    925  12d6		       b1 59		      lda	(dpl),y
    926  12d8		       c8		      iny
    927  12d9		       ca		      dex
    928  12da		       8e 85 0f 	      stx	printStorage+2
    929  12dd		       a2 00		      ldx	#0
    930  12df				   PrintOprLoop
    931  12df		       dd 6c 0d 	      cmp	OperValues,x
    932  12e2		       f0 03		      beq	PrintOprFound
    933  12e4		       e8		      inx
    934  12e5		       d0 f8		      bne	PrintOprLoop
    935  12e7				   PrintOprFound
    936  12e7		       8a		      txa
    937  12e8		       0a		      asl
    938  12e9		       aa		      tax
    939  12ea		       bd 40 0d 	      lda	Operators,x
    940  12ed		       20 20 1e 	      jsr	VOUTCH
    941  12f0		       e8		      inx
    942  12f1		       bd 40 0d 	      lda	Operators,x
    943  12f4		       f0 03		      beq	PrintOprDone
    944  12f6		       20 20 1e 	      jsr	VOUTCH
    945  12f9				   PrintOprDone
    946  12f9		       ae 85 0f 	      ldx	printStorage+2
    947  12fc		       4c 41 12 	      jmp	PrintProgNext
    948  12ff
    949  12ff							;=================================================================================================================
    950  12ff							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    951  12ff							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    952  12ff							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    953  12ff							;tVhat 	    equ     155 		   ; Variable ^
    954  12ff							;tVhash	    equ     156 		   ; Variable #
    955  12ff							;tVat		    equ     157 		   ; Variable @ = 0
    956  12ff				   PrintProgVariable
    957  12ff		       b1 59		      lda	(dpl),y
    958  1301		       c8		      iny
    959  1302		       ca		      dex
    960  1303		       c5 9b		      cmp	tVhat
    961  1305		       d0 04		      bne	PrintProgChkHash
    962  1307		       a9 5e		      lda	#'^
    963  1309		       d0 15		      bne	PrintTheVar
    964  130b				   PrintProgChkHash
    965  130b		       c5 9c		      cmp	tVhash
    966  130d		       d0 04		      bne	PrintProgChkAt
    967  130f		       a9 23		      lda	#'#
    968  1311		       d0 0d		      bne	PrintTheVar
    969  1313				   PrintProgChkAt
    970  1313		       c5 9d		      cmp	tVat
    971  1315		       d0 04		      bne	PrintProgVarLetter
    972  1317		       a9 40		      lda	#'@
    973  1319		       d0 05		      bne	PrintTheVar
    974  131b				   PrintProgVarLetter
    975  131b		       29 7f		      and	#%01111111
    976  131d		       18		      clc
    977  131e		       69 41		      adc	#'A
    978  1320				   PrintTheVar
    979  1320		       20 20 1e 	      jsr	VOUTCH
    980  1323		       4c 41 12 	      jmp	PrintProgNext
    981  1326
    982  1326							;=========================================================================
    983  1326							; Read an IL byte lookit up in the table, of words
    984  1326							; set the next ilpc to point to that address
    985  1326							; if not found then do ussual filter stuff
    986  1326							; ongoto ilvectortable, not found address
    987  1326		       20 9d 19    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    988  1329		       86 52		      stx	R0
    989  132b		       85 53		      sta	R0+1
    990  132d
    991  132d		       a4 51		      ldy	CUROFF
    992  132f		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    993  1331		       a0 00		      ldy	#0
    994  1333		       38		      sec
    995  1334		       f1 52		      sbc	(R0),y	; Subract the base value
    996  1336		       c8		      iny
    997  1337		       d1 52		      cmp	(R0),y	; Check if we are in range
    998  1339		       b0 12		      bcs	iOnGotoInvalid
    999  133b		       e6 51		      inc	CUROFF	; Save the offset
   1000  133d
   1001  133d		       0a		      asl
   1002  133e		       a8		      tay		; Turn into vector
   1003  133f		       c8		      iny		; Inc must include the table base and entry count
   1004  1340		       c8		      iny
   1005  1341
   1006  1341		       b1 52		      lda	(R0),y
   1007  1343		       85 43		      sta	ILPC
   1008  1345		       c8		      iny
   1009  1346		       b1 52		      lda	(R0),y
   1010  1348		       85 44		      sta	ILPC+1
   1011  134a		       4c c2 02 	      jmp	NextIL
   1012  134d
   1013  134d				   iOnGotoInvalid
   1014  134d		       20 9d 19 	      jsr	getILWord
   1015  1350		       86 43		      stx	ILPC
   1016  1352		       85 44		      sta	ILPC+1
   1017  1354		       4c c2 02 	      jmp	NextIL
   1018  1357							;
   1019  1357							;==========================================================================================
   1020  1357							; Test the token for relop and push the value onto the stack if true
   1021  1357							;
   1022  1357				   iTSTRELOP
   1023  1357		       20 a1 19 	      jsr	getILByte
   1024  135a		       8d 23 2e 	      sta	offset
   1025  135d
   1026  135d		       a4 51		      ldy	CUROFF
   1027  135f		       b1 4f		      lda	(CURPTR),y
   1028  1361		       48		      pha
   1029  1362		       29 f0		      and	#$F0
   1030  1364		       c9 f0		      cmp	#$F0
   1031  1366		       d0 12		      bne	iTSTRELOPNOT
   1032  1368		       68		      pla
   1033  1369		       29 0f		      and	#$0F	; get the actual value
   1034  136b		       85 52		      sta	R0	; save it for later
   1035  136d		       a9 00		      lda	#0
   1036  136f		       85 53		      sta	R0+1
   1037  1371		       20 9a 1b 	      jsr	pushR0
   1038  1374		       c8		      iny
   1039  1375		       84 51		      sty	CUROFF	; save the y pointer
   1040  1377		       4c c2 02 	      jmp	NextIL
   1041  137a
   1042  137a				   iTSTRELOPNOT
   1043  137a		       68		      pla
   1044  137b		       4c 4c 0b 	      jmp	tstBranch
   1045  137e
   1046  137e
   1047  137e
   1048  137e
   1049  137e
   1050  137e
   1051  137e
   1052  137e
   1053  137e
   1054  137e
   1055  137e
   1056  137e
   1057  137e
   1058  137e
   1059  137e
   1060  137e
   1061  137e
   1062  137e
   1063  137e
   1064  137e
   1065  137e
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  137e					      include	"print.asm"
      1  137e					      Seg	Code
      2  137e							;---------------------------
      3  137e							; Print 24-bit decimal number or  16bit unsigned
      4  137e							; ---------------------------
      5  137e							; On entry, R0=number to print
      6  137e							;	     Defaults to pad=0 , y=21 default
      7  137e							;	     R2 = 1 unsigned 16 bit
      8  137e							;	     R2 = 0 Signed   16 bit
      9  137e
     10  137e							; On entry at PrintDecPadded:
     11  137e							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  137e
     13  137e							; On exit,  A,X,Y,num,pad corrupted
     14  137e							; Size      129 bytes, Table 24 bytes	--- total 153
     15  137e							; -----------------------------------------------------------------
     16  137e
     17  137e				   PrintDecimal
     18  137e		       8a		      TXA
     19  137f		       48		      pha
     20  1380		       98		      tya
     21  1381		       48		      pha
     22  1382		       a9 00		      lda	#0
     23  1384		       8d 17 14 	      sta	pad
     24  1387		       a0 15		      LDY	#21	; Offset to powers of ten
     25  1389		       4c 8f 13 	      JMP	PrintDo
     26  138c
     27  138c				   PrintDecPadded
     28  138c		       8e 17 14 	      stx	pad
     29  138f
     30  138f				   PrintDo
     31  138f		       a9 00		      lda	#0
     32  1391		       85 54		      sta	R1
     33  1393
     34  1393		       a5 58		      lda	R2
     35  1395		       d0 29		      bne	PrintPos
     36  1397
     37  1397		       a5 53		      lda	R0+1	;MSB has sign
     38  1399		       10 25		      bpl	PrintPos	;it's a positive number;
     39  139b
     40  139b
     41  139b							; Negative numbers need more work.  Invert all the bits,
     42  139b							; then add one.
     43  139b
     44  139b		       a9 2d		      lda	#'-
     45  139d		       20 20 1e 	      jsr	VOUTCH	;print the negative sign
     46  13a0
     47  13a0		       a9 ff		      lda	#$FF
     48  13a2		       85 54		      sta	R1
     49  13a4		       a5 52		      lda	R0	;invert bits
     50  13a6		       49 ff		      eor	#$ff
     51  13a8		       85 52		      sta	R0
     52  13aa		       a5 53		      lda	R0+1
     53  13ac		       49 ff		      eor	#$ff
     54  13ae		       85 53		      sta	R0+1
     55  13b0		       a5 54		      lda	R1
     56  13b2		       49 ff		      eor	#$ff
     57  13b4		       85 54		      sta	R1
     58  13b6		       e6 52		      inc	R0	;add one
     59  13b8		       d0 06		      bne	PrintPos
     60  13ba		       e6 53		      inc	R0+1
     61  13bc		       d0 02		      bne	PrintPos
     62  13be		       e6 54		      inc	R1
     63  13c0				   PrintPos
     64  13c0
     65  13c0				   PrDec24Lp1
     66  13c0		       a2 ff		      LDX	#$FF
     67  13c2		       38		      SEC		; Start with digit=-1
     68  13c3				   PrDec24Lp2
     69  13c3		       a5 52		      LDA	R0+0
     70  13c5		       f9 18 14 	      SBC	PrDec24Tens+0,Y
     71  13c8		       85 52		      STA	R0+0	; Subtract current tens
     72  13ca		       a5 53		      LDA	R0+1
     73  13cc		       f9 19 14 	      SBC	PrDec24Tens+1,Y
     74  13cf		       85 53		      STA	R0+1
     75  13d1		       a5 54		      LDA	R0+2
     76  13d3		       f9 1a 14 	      SBC	PrDec24Tens+2,Y
     77  13d6		       85 54		      STA	R0+2
     78  13d8		       e8		      INX
     79  13d9		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  13db		       a5 52		      LDA	R0+0
     81  13dd		       79 18 14 	      ADC	PrDec24Tens+0,Y
     82  13e0		       85 52		      STA	R0+0	; Add current tens back in
     83  13e2		       a5 53		      LDA	R0+1
     84  13e4		       79 19 14 	      ADC	PrDec24Tens+1,Y
     85  13e7		       85 53		      STA	R0+1
     86  13e9		       a5 54		      LDA	R0+2
     87  13eb		       79 1a 14 	      ADC	PrDec24Tens+2,Y
     88  13ee		       85 54		      STA	R0+2
     89  13f0		       8a		      TXA
     90  13f1		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  13f3		       ad 17 14 	      LDA	pad
     92  13f6		       d0 09		      BNE	PrDec24Print
     93  13f8		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  13fa				   PrDec24Digit
     95  13fa		       a2 30		      LDX	#'0
     96  13fc		       8e 17 14 	      STX	pad	; No more zero padding
     97  13ff		       09 30		      ORA	#'0	; Print this digit
     98  1401				   PrDec24Print
     99  1401		       20 20 1e 	      JSR	VOUTCH
    100  1404				   PrDec24Next
    101  1404		       88		      DEY
    102  1405		       88		      DEY
    103  1406		       88		      DEY
    104  1407		       f0 07		      beq	PrDec24LastDigit
    105  1409		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  140b		       68		      pla
    107  140c		       a8		      tay
    108  140d		       68		      pla
    109  140e		       aa		      tax
    110  140f		       60		      RTS
    111  1410				   PrDec24LastDigit
    112  1410		       a2 30		      LDX	#'0
    113  1412		       8e 17 14 	      STX	pad	; No more zero padding
    114  1415		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  1417
      0  1417				   pad	      db	0
      1  1417		       00		      .byte.b	0
    117  1418				   PrDec24Tens
      0  1418					      dw	1
      1  1418		       01 00		      .word.w	1
      0  141a					      db	1 / 65536
      1  141a		       00		      .byte.b	1 / 65536
      0  141b					      dw	10
      1  141b		       0a 00		      .word.w	10
      0  141d					      db	10 / 65536
      1  141d		       00		      .byte.b	10 / 65536
      0  141e					      dw	100
      1  141e		       64 00		      .word.w	100
      0  1420					      db	100 / 65536
      1  1420		       00		      .byte.b	100 / 65536
      0  1421					      dw	1000
      1  1421		       e8 03		      .word.w	1000
      0  1423					      db	1000 / 65536
      1  1423		       00		      .byte.b	1000 / 65536
      0  1424					      dw	10000
      1  1424		       10 27		      .word.w	10000
      0  1426					      db	10000 / 65536
      1  1426		       00		      .byte.b	10000 / 65536
      0  1427					      dw	100000
      1  1427		       a0 86		      .word.w	100000
      0  1429					      db	100000 / 65536
      1  1429		       01		      .byte.b	100000 / 65536
      0  142a					      dw	1000000
      1  142a		       40 42		      .word.w	1000000
      0  142c					      db	1000000 / 65536
      1  142c		       0f		      .byte.b	1000000 / 65536
      0  142d					      dw	10000000
      1  142d		       80 96		      .word.w	10000000
      0  142f					      db	10000000 / 65536
      1  142f		       98		      .byte.b	10000000 / 65536
    134  1430							;=====================================================
    135  1430							; Print character in A as two hex digits to the
    136  1430
    137  1430		       48	   HexToOut   pha		;save return value
    138  1431		       48		      pha
    139  1432		       4a		      lsr		;a  ;move top nibble to bottom
    140  1433		       4a		      lsr		;a
    141  1434		       4a		      lsr		;a
    142  1435		       4a		      lsr		;a
    143  1436		       20 3f 14 	      jsr	hexta	;output nibble
    144  1439		       68		      pla
    145  143a		       20 3f 14 	      jsr	hexta
    146  143d		       68		      pla		;restore
    147  143e		       60		      rts
    148  143f							;
    149  143f		       29 0f	   hexta      and	#%0001111
    150  1441		       c9 0a		      cmp	#$0a
    151  1443		       18		      clc
    152  1444		       30 02		      bmi	hexta1
    153  1446		       69 07		      adc	#7
    154  1448		       69 30	   hexta1     adc	#'0	;then fall into...
    155  144a		       4c 20 1e 	      jmp	VOUTCH
    156  144d							;
    157  144d							;=====================================================
    158  144d							; Print the string that immediately follows the JSR to
    159  144d							; this function.  Stops when a null byte is found,
    160  144d							; then returns to the instruction immediately
    161  144d							; following the null.
    162  144d							;
    163  144d							; Thanks to Ross Archer for this code.
    164  144d							; http://www.6502.org/source/io/primm.htm
    165  144d							;
    166  144d
    167  144d		       68	   tbputs     pla		;Get the low part of "return" address
    168  144e							;(data start address)
    169  144e		       85 5e		      sta	PrtFrom
    170  1450		       68		      pla
    171  1451		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    172  1453							;(data start address)
    173  1453							;Note: actually we're pointing one short
    174  1453		       a0 01	   PSINB      ldy	#1
    175  1455		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    176  1457		       e6 5e		      inc	PrtFrom	;update the pointer
    177  1459		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    178  145b		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    179  145d		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    180  145f							;   Accumulator
    181  145f		       f0 06		      beq	PSIX1	;don't print the final NULL
    182  1461		       20 20 1e 	      jsr	VOUTCH	;write it out
    183  1464		       4c 53 14 	      jmp	PSINB	;back around
    184  1467		       e6 5e	   PSIX1      inc	PrtFrom
    185  1469		       d0 02		      bne	PSIX2
    186  146b		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    187  146d		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    188  1470
    189  1470							;+
    190  1470							;====================================================
    191  1470		       2e 1f	   PrtTerm    equ	tempy
    192  1470
    193  1470							; on exit Print Y has the offset to use
    194  1470							; input y =	 addr low
    195  1470							;	 x =	 addr high
    196  1470							;	 a =	 termination string
    197  1470
    198  1470				   PrtPrgLine
    199  1470		       a9 00		      lda	#0
    200  1472		       8d 1f 2e 	      sta	PrtTerm
    201  1475		       f0 0e		      beq	PrtPrgText
    202  1477
    203  1477				   PrtQuoted
    204  1477		       a9 22		      lda	#'"
    205  1479		       a4 51		      ldy	CUROFF
    206  147b		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    207  147d		       d0 03		      bne	PrtNoInc
    208  147f		       c8		      iny
    209  1480		       84 51		      sty	CUROFF
    210  1482				   PrtNoInc
    211  1482		       8d 1f 2e 	      sta	PrtTerm
    212  1485
    213  1485		       a4 51	   PrtPrgText ldy	CUROFF
    214  1487		       a5 4f		      lda	CURPTR
    215  1489		       85 5e		      sta	PrtFrom
    216  148b		       a5 50		      lda	CURPTR+1
    217  148d		       85 5f		      sta	PrtFrom+1
    218  148f		       4c 9b 14 	      jmp	PrtLoop
    219  1492
    220  1492							; Print a string pointed to by x= h, y=l terminated by a
    221  1492							; Return y as the length
    222  1492
    223  1492		       86 5f	   PrtStr     stx	PrtFrom+1
    224  1494		       84 5e		      sty	PrtFrom
    225  1496		       8d 1f 2e 	      sta	PrtTerm
    226  1499		       a0 00		      ldy	#0
    227  149b							;
    228  149b							; On entry here ptrfrom and prtterm point to area to print
    229  149b							;
    230  149b		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    231  149d		       cd 1f 2e 	      cmp	PrtTerm
    232  14a0		       f0 0b		      beq	PrtEnd
    233  14a2		       c9 00		      cmp	#0	; always end if 0 is found
    234  14a4		       f0 07		      beq	PrtEnd
    235  14a6		       20 20 1e 	      jsr	VOUTCH
    236  14a9		       c8		      iny
    237  14aa		       4c 9b 14 	      jmp	PrtLoop
    238  14ad		       c8	   PrtEnd     iny		;return byte after the copy
    239  14ae		       60		      rts
    240  14af
    241  14af							;
    242  14af							;=======================================================
    243  14af							; Print all Variables
    244  14af				   PrintAllVars
    245  14af		       a0 00		      ldy	#0
    246  14b1		       a9 41		      lda	#'A
    247  14b3				   PrintAllVarsLoop
    248  14b3		       48		      pha
    249  14b4		       b1 41		      lda	(VARIABLES),y
    250  14b6		       85 52		      sta	R0
    251  14b8		       c8		      iny
    252  14b9		       b1 41		      lda	(VARIABLES),y
    253  14bb		       85 53		      sta	R0+1
    254  14bd
    255  14bd		       68		      pla		;get the current letter
    256  14be		       48		      pha
    257  14bf		       20 20 1e 	      jsr	VOUTCH
    258  14c2		       20 4d 14 	      jsr	puts
      0  14c5					      db	"=",0
      1  14c5		       3d 00		      .byte.b	"=",0
    260  14c7		       68		      pla
    261  14c8		       aa		      tax
    262  14c9		       e8		      inx
    263  14ca		       8a		      txa
    264  14cb		       48		      pha		;
    265  14cc
    266  14cc		       98		      tya
    267  14cd		       48		      pha
    268  14ce		       20 7e 13 	      jsr	PrintDecimal
    269  14d1		       20 4d 14 	      jsr	puts
      0  14d4					      db	" ",0
      1  14d4		       20 00		      .byte.b	" ",0
    271  14d6		       68		      pla
    272  14d7		       a8		      tay
    273  14d8		       c8		      iny
    274  14d9		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    275  14db		       90 d6		      bcc	PrintAllVarsLoop
    276  14dd		       20 d7 1c 	      jsr	CRLF
    277  14e0
    278  14e0		       68		      pla
    279  14e1		       60		      rts
    280  14e2
    281  14e2							;==================================================================================================
    282  14e2							; Size of print functions
    283  14e2		       01 64	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  14e2					      include	"mem.asm"
      1  14e2							;===================================================================
      2  14e2							;This file contains the memory allocation and free functions
      3  14e2							;in herant in this is the management of free memory in the system
      4  14e2							; the interface to these functions
      5  14e2							; a,x returns or provides the low hi bytes of the managed addresses
      6  14e2							; This uses the programend, to memory end as the area to manage
      7  14e2							;===================================================================
      8  14e2					      Seg	Code
      9  14e2							;=====================================================
     10  14e2							;Pointers for memory Management
     11  14e2							;Allocated block are not chained but can be followed for all memory by the associated length
     12  14e2							; Mem block format is
     13  14e2							;	 0-1   pointer to next block for free blocks
     14  14e2							;	 0-1   for allocated blocks
     15  14e2							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  14e2							;	   1   refrence counter ... lol only up to 256 but it is something
     17  14e2							;	 2-3   length constant for exevy type of memory block
     18  14e2							; Memory is recombined as it is released
     19  14e2							; The memory manager is not interupted durring allocation
     20  14e2							; or freeing of memory
     21  14e2							; Memory is allocated from the highest memory address towards
     22  14e2							; the lowest memory address. meeting the Basic program end.
     23  14e2							;====================================================
     24  14e2							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  14e2							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  14e2							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  14e2							;=====================================================
     28  14e2				   MemInit
     29  14e2		       a9 31		      lda	#FreeMemStart&$FF
     30  14e4		       8d 27 2e 	      sta	ProgramStart
     31  14e7		       8d 29 2e 	      sta	ProgramEnd
     32  14ea		       a9 2e		      lda	#FreeMemStart>>8
     33  14ec		       8d 28 2e 	      sta	ProgramStart+1
     34  14ef		       8d 2a 2e 	      sta	ProgramEnd+1
     35  14f2
     36  14f2		       20 fc 14 	      jsr	GetSizes
     37  14f5		       20 07 15 	      jsr	MemFree
     38  14f8		       20 1f 15 	      jsr	MemUsed
     39  14fb				   MemInitEnd
     40  14fb		       60		      rts
     41  14fc
     42  14fc
     43  14fc							;
     44  14fc							;=====================================================
     45  14fc							; This function might go away eventually, but was
     46  14fc							; added to provide data for other pieces of code.
     47  14fc							; It has some ties to the operating environment that
     48  14fc							; will need to be customized for the target system.
     49  14fc							;
     50  14fc				   GetSizes
     51  14fc							;
     52  14fc							; Here is machine specific code to get the highest
     53  14fc							; memory location that can be used by BASIC.
     54  14fc							;
     55  14fc				  -	      if	ProgramStart < $2000
     56  14fc				  -	      lda	#$ff
     57  14fc				  -	      sta	HighMem	;$13ff for KIM-1
     58  14fc				  -	      sta	MemFreeList
     59  14fc				  -	      lda	#$DE	;#$13
     60  14fc				  -	      sta	HighMem+1
     61  14fc				  -	      sta	MemFreeList+1
     62  14fc					      else
     63  14fc		       a9 ff		      lda	#$ff
     64  14fe		       8d 2b 2e 	      sta	HighMem	;$CFFF otherwise
     65  1501		       a9 cf		      lda	#$cf
     66  1503		       8d 2c 2e 	      sta	HighMem+1
     67  1506					      endif
     68  1506		       60		      rts
     69  1507							;
     70  1507							; This computes the available memory remaining.
     71  1507							;
     72  1507				   MemFree
     73  1507		       38		      sec
     74  1508		       ad 2b 2e 	      lda	HighMem
     75  150b		       ed 29 2e 	      sbc	ProgramEnd
     76  150e		       8d 2f 2e 	      sta	FreeMem
     77  1511		       85 52		      sta	R0
     78  1513		       ad 2c 2e 	      lda	HighMem+1
     79  1516		       ed 2a 2e 	      sbc	ProgramEnd+1
     80  1519		       8d 30 2e 	      sta	FreeMem+1
     81  151c		       85 53		      sta	R0+1
     82  151e		       60		      rts
     83  151f							;
     84  151f							; This computes the size of the current user program.
     85  151f							;
     86  151f				   MemUsed
     87  151f		       38		      sec
     88  1520		       ad 29 2e 	      lda	ProgramEnd
     89  1523		       ed 27 2e 	      sbc	ProgramStart
     90  1526		       8d 2d 2e 	      sta	UsedMem
     91  1529		       85 52		      sta	R0
     92  152b		       ad 2a 2e 	      lda	ProgramEnd+1
     93  152e		       ed 28 2e 	      sbc	ProgramStart+1
     94  1531		       8d 2e 2e 	      sta	UsedMem+1
     95  1534		       85 53		      sta	R0+1
     96  1536							;
     97  1536		       60		      rts
     98  1537
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  1537					      include	"gosub.asm"
      1  1537					      seg	Code
      2  1537
      3  1537							; Gosub and return related functions
      4  1537							;==========================================================
      5  1537							; Push the current math stack frame onto the gosub stack
      6  1537				   iPushMathStack
      7  1537		       98		      tya
      8  1538		       48		      pha
      9  1539		       a4 4d		      ldy	GOSUBSTACKPTR
     10  153b		       a5 4a		      lda	MATHSTACKPTR
     11  153d		       91 4b		      sta	(GOSUBSTACK),y
     12  153f		       a9 00		      lda	#0
     13  1541		       c8		      iny
     14  1542		       91 4b		      sta	(GOSUBSTACK),y
     15  1544		       c8		      iny
     16  1545		       91 4b		      sta	(GOSUBSTACK),y
     17  1547		       c8		      iny
     18  1548		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  154a		       91 4b		      sta	(GOSUBSTACK),y
     20  154c		       c8		      iny
     21  154d		       84 4d		      sty	GOSUBSTACKPTR
     22  154f		       68		      pla
     23  1550		       a8		      tay
     24  1551		       4c c2 02 	      jmp	NextIL
     25  1554							;
     26  1554							;==========================================================
     27  1554							; Increment parameter count. Assume Stack frame is top of stack
     28  1554				   iIncParmCount
     29  1554		       98		      tya
     30  1555		       48		      pha
     31  1556		       a4 4d		      ldy	GOSUBSTACKPTR
     32  1558		       88		      dey
     33  1559		       88		      dey
     34  155a		       88		      dey
     35  155b		       b1 4b		      lda	(GOSUBSTACK),y
     36  155d		       aa		      tax
     37  155e		       e8		      inx
     38  155f		       8a		      txa
     39  1560		       91 4b		      sta	(GOSUBSTACK),y
     40  1562		       68		      pla
     41  1563		       a8		      tay
     42  1564		       4c c2 02 	      jmp	NextIL
     43  1567							;
     44  1567							;==========================================================
     45  1567							;Restore the math stack frame
     46  1567		       20 6d 15    iPopMathStack jsr	PopMathStackNow
     47  156a		       4c c2 02 	      jmp	NextIL
     48  156d
     49  156d				   PopMathStackNow
     50  156d		       98		      tya
     51  156e		       48		      pha
     52  156f
     53  156f		       a4 4d		      ldy	GOSUBSTACKPTR
     54  1571		       88		      dey
     55  1572		       b1 4b		      lda	(GOSUBSTACK),y
     56  1574		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  1576		       d0 09		      bne	iPopMathStackNoFrame
     58  1578		       88		      dey
     59  1579		       88		      dey
     60  157a		       88		      dey
     61  157b		       b1 4b		      lda	(GOSUBSTACK),y
     62  157d		       85 4a		      sta	MATHSTACKPTR
     63  157f		       84 4d		      sty	GOSUBSTACKPTR
     64  1581
     65  1581				   iPopMathStackNoFrame
     66  1581
     67  1581		       68		      pla
     68  1582		       a8		      tay
     69  1583		       60		      rts
     70  1584
     71  1584
     72  1584							;==========================================================
     73  1584							; Push the current math stack information onto the gosub stack
     74  1584				   iSaveMathStack
     75  1584		       98		      tya
     76  1585		       48		      pha
     77  1586		       a4 4d		      ldy	GOSUBSTACKPTR
     78  1588		       a5 4a		      lda	MATHSTACKPTR
     79  158a		       91 4b		      sta	(GOSUBSTACK),y
     80  158c		       a5 48		      lda	MATHSTACK
     81  158e		       c8		      iny
     82  158f
     83  158f		       91 4b		      sta	(GOSUBSTACK),y
     84  1591		       c8		      iny
     85  1592
     86  1592		       a5 49		      lda	MATHSTACK+1
     87  1594		       91 4b		      sta	(GOSUBSTACK),y
     88  1596		       c8		      iny
     89  1597
     90  1597		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  1599		       91 4b		      sta	(GOSUBSTACK),y
     92  159b		       c8		      iny
     93  159c
     94  159c		       84 4d		      sty	GOSUBSTACKPTR
     95  159e		       68		      pla
     96  159f		       a8		      tay
     97  15a0		       4c c2 02 	      jmp	NextIL
     98  15a3							;
     99  15a3							;==========================================================
    100  15a3							;Restore the math stack information from the gosub stack
    101  15a3				   iRestoreMathStack
    102  15a3		       98		      tya
    103  15a4		       48		      pha
    104  15a5
    105  15a5		       a5 4a		      lda	MATHSTACKPTR
    106  15a7		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  15a9
    108  15a9		       a4 4d		      ldy	GOSUBSTACKPTR
    109  15ab		       88		      dey
    110  15ac		       b1 4b		      lda	(GOSUBSTACK),y
    111  15ae		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  15b0		       d0 16		      bne	iPopMathStack_Err
    113  15b2		       88		      dey
    114  15b3		       b1 4b		      lda	(GOSUBSTACK),y
    115  15b5		       85 49		      sta	MATHSTACK+1
    116  15b7		       88		      dey
    117  15b8		       b1 4b		      lda	(GOSUBSTACK),y
    118  15ba		       85 48		      sta	MATHSTACK
    119  15bc		       88		      dey
    120  15bd		       b1 4b		      lda	(GOSUBSTACK),y
    121  15bf		       85 4a		      sta	MATHSTACKPTR
    122  15c1		       84 4d		      sty	GOSUBSTACKPTR
    123  15c3		       68		      pla
    124  15c4		       a8		      tay
    125  15c5		       4c c2 02 	      jmp	NextIL
    126  15c8
    127  15c8				   iPopMathStack_Err
    128  15c8		       a9 00		      lda	#0
    129  15ca		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  15cc		       4c 17 06 	      jmp	iErr2
    131  15cf							;=========================================
    132  15cf							; For functions and tasks the variable address of # means
    133  15cf							; a passed parameter so #[0] is the first parameter etc
    134  15cf							; will try for a better way later
    135  15cf
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  15cf					      include	"tasks.asm"
      1  15cf							;=====================================================
      2  15cf							; Tiny Basic IL task management
      3  15cf							; Data required by task management
      4  15cf							; currently each context is about 30 bytes and is swapped
      5  15cf							; into and out of page zero on each task switch....
      6  15cf							; LOL yes it is slow, but works for this iteration.
      7  15cf							;
      8  15cf
      9  15cf					      Seg	Code
     10  15cf							;=====================================================
     11  15cf							; Sets the pointers to the math,IL and gosub stacks
     12  15cf							; Creates the initial Context for each task slot
     13  15cf				   taskSetStacks
     14  15cf		       a9 ce		      lda	#mathStack&$FF
     15  15d1		       85 48		      sta	MATHSTACK
     16  15d3		       a9 25		      lda	#mathStack>>8
     17  15d5		       85 49		      sta	MATHSTACK+1
     18  15d7
     19  15d7		       a9 5e		      lda	#ilStack&$ff
     20  15d9		       85 45		      sta	ILSTACK
     21  15db		       a9 27		      lda	#ilStack>>8
     22  15dd		       85 46		      sta	ILSTACK+1
     23  15df
     24  15df		       a9 ee		      lda	#gosubStack&$FF
     25  15e1		       85 4b		      sta	GOSUBSTACK
     26  15e3		       a9 28		      lda	#gosubStack>>8
     27  15e5		       85 4c		      sta	GOSUBSTACK+1
     28  15e7
     29  15e7		       a9 6e		      lda	#variableStack&$FF
     30  15e9		       85 41		      sta	VARIABLES
     31  15eb		       a9 2b		      lda	#variableStack>>8
     32  15ed		       85 42		      sta	VARIABLES+1
     33  15ef		       a2 0a		      ldx	#TASKCOUNT
     34  15f1		       a0 00		      ldy	#0
     35  15f3		       20 7e 18 	      jsr	ContextSave
     36  15f6
     37  15f6		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  15f8		       b0 3a		      bcs	taskSetDone
     39  15fa
     40  15fa		       a5 4b		      lda	GOSUBSTACK
     41  15fc		       18		      clc
     42  15fd		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  15ff		       85 4b		      sta	GOSUBSTACK
     44  1601		       a5 4c		      lda	GOSUBSTACK+1
     45  1603		       69 00		      adc	#0
     46  1605		       85 4c		      sta	GOSUBSTACK+1
     47  1607
     48  1607		       a5 45		      lda	ILSTACK	; must be less than 256
     49  1609		       18		      clc
     50  160a		       69 28		      adc	#ILSTACKSIZE*2
     51  160c		       85 45		      sta	ILSTACK
     52  160e		       a5 46		      lda	ILSTACK+1
     53  1610		       69 00		      adc	#0
     54  1612		       85 46		      sta	ILSTACK+1
     55  1614
     56  1614		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  1616		       18		      clc
     58  1617		       69 28		      adc	#MATHSTACKSIZE*2
     59  1619		       85 48		      sta	MATHSTACK
     60  161b		       a5 49		      lda	MATHSTACK+1
     61  161d		       69 00		      adc	#0
     62  161f		       85 49		      sta	MATHSTACK+1
     63  1621
     64  1621		       a5 41		      lda	VARIABLES	; must be less than 256
     65  1623		       18		      clc
     66  1624		       69 36		      adc	#VARIABLESSIZE*2
     67  1626		       85 41		      sta	VARIABLES
     68  1628		       a5 42		      lda	VARIABLES+1
     69  162a		       69 00		      adc	#0
     70  162c		       85 42		      sta	VARIABLES+1
     71  162e
     72  162e		       20 7e 18 	      jsr	ContextSave
     73  1631		       4c f6 15 	      jmp	taskSetLoop
     74  1634
     75  1634				   taskSetDone
     76  1634		       a0 00		      ldy	#0	; reload the main loop context
     77  1636		       20 8d 18 	      jsr	ContextLoad
     78  1639		       60		      rts
     79  163a							;
     80  163a							;=====================================================
     81  163a							; In some error cases the math stacks may be left pointing to the wrong stack
     82  163a							; This function will reset those stack addresses but not the actual pointer
     83  163a				   taskResetStacks
     84  163a		       a0 00		      ldy	#0
     85  163c		       20 8d 18 	      jsr	ContextLoad
     86  163f		       4c cf 15 	      jmp	taskSetStacks
     87  1642							;
     88  1642							;=====================================================
     89  1642							; Clear all task entries and task stacks
     90  1642		       98	   taskReset  tya		; Save Y
     91  1643		       48		      pha
     92  1644		       a9 01		      lda	#1
     93  1646		       8d cd 25 	      sta	taskCounter	; Set number of active tasks to 1
     94  1649		       ac ce 24 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  164c		       c0 00		      cpy	#0	; check if we are the main context
     96  164e		       f0 08		      beq	taskResetCont	; if we are just continue
     97  1650
     98  1650		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  1652		       8c ce 24 	      sty	taskPtr
    100  1655		       20 8d 18 	      jsr	ContextLoad	; load the System Task context
    101  1658				   taskResetCont
    102  1658		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  165a
    104  165a				   taskResetLoop
    105  165a		       a9 00		      lda	#TASKINACTIVE
    106  165c		       99 cf 24 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  165f		       18		      clc
    108  1660		       98		      tya
    109  1661		       69 19		      adc	#CONTEXTLEN+1
    110  1663		       a8		      tay
    111  1664		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  1666		       90 f2		      bcc	taskResetLoop	; Go for more
    113  1668
    114  1668				   taskResetComplete
    115  1668
    116  1668		       68		      pla		; Restore y
    117  1669		       a8		      tay
    118  166a		       60		      rts
    119  166b
    120  166b							;
    121  166b							;======================================================
    122  166b							; iTaskSwitch	 switch to new task if not interrupt and
    123  166b							;		 count is exceded for task time slice gets here
    124  166b							;		 when time slice has reached zero
    125  166b							;
    126  166b		       98	   iTaskSwitch tya
    127  166c		       48		      pha
    128  166d
    129  166d		       ad cb 25 	      lda	taskResetValue	; Always reset the counter value
    130  1670		       8d c9 25 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  1673		       ce ca 25 	      dec	taskCurrentCycles+1	; dec high order byte
    132  1676		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  1678
    134  1678		       ad cc 25 	      lda	taskResetValue+1
    135  167b		       8d ca 25 	      sta	taskCurrentCycles+1
    136  167e
    137  167e		       ad cb 24 	      lda	IRQPending	; Skip this if we are processing an irq
    138  1681		       0d 25 2e 	      ora	taskIOPending	; If set then don't switch
    139  1684		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  1686
    141  1686		       ad cd 25    iTaskMain  lda	taskCounter	; Number of tasks
    142  1689		       c9 01		      cmp	#1	; if there is only one task must be main
    143  168b		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  168d
    145  168d		       ac ce 24 	      ldy	taskPtr	; check if we have not just ended some other task
    146  1690		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  1692		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  1694							;
    149  1694							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  1694							;
    151  1694				   itasknext
    152  1694		       ac ce 24 	      ldy	taskPtr
    153  1697		       20 7e 18 	      jsr	ContextSave	; Save the current context, y points to next context
    154  169a				   itaskLoop
    155  169a		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  169c		       90 04		      bcc	iTaskNextChk
    157  169e
    158  169e		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  16a0		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  16a2
    161  16a2				   iTaskNextChk
    162  16a2		       b9 cf 24 	      lda	taskTable,y	; there is always at least one entry in table
    163  16a5		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  16a7		       18	   iTaskNext  clc
    165  16a8		       98		      tya
    166  16a9		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  16ab		       a8		      tay
    168  16ac		       4c 9a 16 	      jmp	itaskLoop	; Check for busy entry
    169  16af
    170  16af		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  16b1		       59 cf 24 	      eor	taskTable,y	; Check for anything waiting io
    172  16b4		       d0 f1		      bne	iTaskNext
    173  16b6		       20 8d 18 	      jsr	ContextLoad	; load the next context
    174  16b9		       8c ce 24 	      sty	taskPtr	; update the task pointer
    175  16bc
    176  16bc				   iTaskSwitchDone
    177  16bc		       68		      pla
    178  16bd		       a8		      tay
    179  16be		       60		      rts
    180  16bf							;
    181  16bf							;================================================================
    182  16bf							; Task Set task number to line number to start
    183  16bf							; Task Table structure:
    184  16bf							;    byte 0	-   Active inactive
    185  16bf							;    byte 1-2	-   Basic code line pointer
    186  16bf							;    byte 3	-   Offset on current line
    187  16bf		       98	   iTaskSet   tya		;preserve Y
    188  16c0		       48		      pha		; push a
    189  16c1
    190  16c1		       20 1e 1c 	      jsr	popR0	; Get the line number to be saved
    191  16c4
    192  16c4		       ac ce 24 	      ldy	taskPtr	; find out where we are
    193  16c7		       20 7e 18 	      jsr	ContextSave	; Save the current context
    194  16ca
    195  16ca							;Find the pointer to the line we need to start at
    196  16ca		       20 e6 19 	      jsr	findLine	; Get the offset of the line to start task at
    197  16cd		       f0 0b		      beq	iTaskCont
    198  16cf
    199  16cf		       ac ce 24 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  16d2		       20 8d 18 	      jsr	ContextLoad
    201  16d5
    202  16d5		       68		      pla		; pop a - exit
    203  16d6		       a8		      tay
    204  16d7		       4c 2c 0d 	      jmp	iSetIrqErr	; Bad line number provided
    205  16da
    206  16da				   iTaskCont
    207  16da		       20 50 18 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  16dd		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  16df
    210  16df		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  16e1		       99 cf 24 	      sta	taskTable,y	; new task as active
    212  16e4
    213  16e4		       a5 4f		      lda	CURPTR
    214  16e6		       48		      pha		; push a
    215  16e7		       a5 50		      lda	CURPTR+1
    216  16e9		       48		      pha		; push a
    217  16ea
    218  16ea		       20 8d 18 	      jsr	ContextLoad	; load the context of the new task
    219  16ed
    220  16ed		       68		      pla		; pop a
    221  16ee		       85 50		      sta	CURPTR+1
    222  16f0		       68		      pla		; pop a
    223  16f1		       85 4f		      sta	CURPTR
    224  16f3		       a9 03		      lda	#3	; Offset to first instruction
    225  16f5		       85 51		      sta	CUROFF
    226  16f7
    227  16f7		       a9 00		      lda	#0
    228  16f9		       85 47		      sta	ILSTACKPTR
    229  16fb		       85 4a		      sta	MATHSTACKPTR
    230  16fd		       85 4d		      sta	GOSUBSTACKPTR
    231  16ff		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  1701		       85 4e		      sta	MESSAGEPTR
    233  1703
    234  1703		       20 1b 09 	      jsr	subVINIT	; Clear the variables
    235  1706
    236  1706		       a9 cd		      lda	#STMT&$FF
    237  1708		       85 43		      sta	ILPC
    238  170a		       a9 20		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  170c		       85 44		      sta	ILPC+1
    240  170e
    241  170e		       98		      tya		; Save the new context offset to return to user
    242  170f		       48		      pha		; push a
    243  1710
    244  1710		       20 7e 18    itaskSetSave jsr	ContextSave	; save the updated context
    245  1713		       ee cd 25 	      inc	taskCounter	; Update the number of Tasks running
    246  1716
    247  1716		       ac ce 24 	      ldy	taskPtr
    248  1719		       20 8d 18 	      jsr	ContextLoad	; restore the original context
    249  171c
    250  171c		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  171e		       85 53		      sta	R0+1
    252  1720		       68		      pla		; Get the task pid we stored				 ; pop a
    253  1721		       85 52		      sta	R0	; Get the table entry value
    254  1723
    255  1723		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  1724		       a8		      tay
    257  1725
    258  1725		       4c 02 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  1728				   iTaskNoEmpty
    260  1728		       ac ce 24 	      ldy	taskPtr
    261  172b		       20 8d 18 	      jsr	ContextLoad
    262  172e
    263  172e		       68		      pla		; pop a    -- exit
    264  172f		       a8		      tay
    265  1730
    266  1730		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  1732		       a9 00		      lda	#0
    268  1734		       4c 17 06 	      jmp	iErr2
    269  1737							;
    270  1737							;===============================================================
    271  1737							; Run the task whos PID is on the stack, preserve the stack
    272  1737							;
    273  1737				   iTaskEnable
    274  1737		       98		      tya
    275  1738		       48		      pha
    276  1739		       20 36 1c 	      jsr	popR1
    277  173c		       20 04 1c 	      jsr	pushR1
    278  173f		       20 84 19 	      jsr	ipc_getcontext	; get context pointer into mq
    279  1742		       a0 00		      ldy	#0
    280  1744		       b1 56		      lda	(MQ),y
    281  1746		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  1748		       09 80		      ora	#TASKACTIVE
    283  174a		       91 56		      sta	(MQ),y
    284  174c		       68		      pla
    285  174d		       a8		      tay
    286  174e		       4c c2 02 	      jmp	NextIL
    287  1751
    288  1751							;
    289  1751							;===============================================================
    290  1751							; Suspend the task whos PID  is on the stack, preserve the stack
    291  1751							;
    292  1751				   iTaskSuspend
    293  1751		       98		      tya
    294  1752		       48		      pha
    295  1753		       20 36 1c 	      jsr	popR1
    296  1756		       20 04 1c 	      jsr	pushR1
    297  1759		       20 84 19 	      jsr	ipc_getcontext	; get context pointer into mq
    298  175c		       a0 00		      ldy	#0
    299  175e		       b1 56		      lda	(MQ),y
    300  1760		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  1762		       09 80		      ora	#TASKACTIVE
    302  1764		       68		      pla
    303  1765		       a8		      tay
    304  1766		       4c c2 02 	      jmp	NextIL
    305  1769
    306  1769							;================================================================
    307  1769							; Returns task Status
    308  1769				   iTaskStat
    309  1769		       98		      tya
    310  176a		       48		      pha
    311  176b		       20 7d 17 	      jsr	iTaskValid	; returns pointer to task entry
    312  176e		       b9 cf 24 	      lda	taskTable,y
    313  1771		       f0 05		      beq	iTaskStatExit
    314  1773		       68		      pla
    315  1774		       a8		      tay
    316  1775		       4c e8 0c 	      jmp	iTruth
    317  1778				   iTaskStatExit
    318  1778		       68		      pla
    319  1779		       a8		      tay
    320  177a		       4c f1 0c 	      jmp	iFalse
    321  177d
    322  177d							;
    323  177d							;================================================================
    324  177d							; Validate the task number on top of the stack
    325  177d							; on exit y points to the requested task entry
    326  177d							;
    327  177d		       20 1e 1c    iTaskValid jsr	popR0	; get result of the multiply
    328  1780		       a5 53		      lda	R0+1
    329  1782		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  1784		       a5 52		      lda	R0
    331  1786		       c9 fa		      cmp	#TASKTABLELEN
    332  1788		       90 09		      bcc	iTaskIsValid
    333  178a
    334  178a		       68	   iTaskValidErr pla		;remove return address
    335  178b		       68		      pla
    336  178c		       a2 10		      ldx	#ERR_INVALID_PID
    337  178e		       a9 00		      lda	#0
    338  1790		       4c 17 06 	      jmp	iErr2
    339  1793
    340  1793		       a8	   iTaskIsValid tay
    341  1794		       60		      rts
    342  1795							;
    343  1795							;================================================================
    344  1795							; Kill a running task, do nothing if already stopped
    345  1795		       20 7d 17    iTaskKill  jsr	iTaskValid
    346  1798		       a9 00		      lda	#0
    347  179a		       99 cf 24 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  179d							;
    349  179d							;================================================================
    350  179d							;Skip to next task
    351  179d				   iNTask
    352  179d		       a9 01		      lda	#1
    353  179f		       8d c9 25 	      sta	taskCurrentCycles
    354  17a2		       8d ca 25 	      sta	taskCurrentCycles+1
    355  17a5		       4c c2 02 	      jmp	NextIL
    356  17a8							;
    357  17a8							;=======================================================
    358  17a8							; Wait for a task to complete
    359  17a8				   iWTASK
    360  17a8		       20 a1 19 	      jsr	getILByte
    361  17ab		       8d 23 2e 	      sta	offset
    362  17ae							;
    363  17ae		       20 84 1b 	      jsr	saveIL	;in case of failure
    364  17b1
    365  17b1		       20 7d 17 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  17b4		       b9 cf 24 	      lda	taskTable,y
    367  17b7		       d0 03		      bne	iWTASKWAIT
    368  17b9				   iWTASKEXITED
    369  17b9		       4c c2 02 	      jmp	NextIL
    370  17bc				   iWTASKWAIT
    371  17bc		       20 9a 1b 	      jsr	pushR0	; Push R0 back onto the stack
    372  17bf		       a9 01		      lda	#1
    373  17c1		       8d c9 25 	      sta	taskCurrentCycles	; Give up the cycles
    374  17c4		       8d ca 25 	      sta	taskCurrentCycles+1
    375  17c7		       20 8f 1b 	      jsr	restoreIL
    376  17ca		       4c 4c 0b 	      jmp	tstBranch
    377  17cd							;
    378  17cd							;=======================================================
    379  17cd							; Set task io lock
    380  17cd		       ee 25 2e    iStartIO   inc	taskIOPending
    381  17d0		       4c c2 02 	      jmp	NextIL
    382  17d3							;
    383  17d3							;=======================================================
    384  17d3							; Release the io lock
    385  17d3		       ad 25 2e    iEndIO     lda	taskIOPending
    386  17d6		       f0 03		      beq	iEndIOExit
    387  17d8		       ce 25 2e 	      dec	taskIOPending
    388  17db		       4c c2 02    iEndIOExit jmp	NextIL
    389  17de							;
    390  17de							;===============================================================
    391  17de							; Return the task PID
    392  17de				   iTASKPID
    393  17de		       a9 00		      lda	#0
    394  17e0		       85 53		      sta	R0+1
    395  17e2		       ad ce 24 	      lda	taskPtr
    396  17e5		       85 52		      sta	R0
    397  17e7		       4c 02 07 	      jmp	pushR0nextIl
    398  17ea							;
    399  17ea							;================================================================
    400  17ea							; Terminate a task
    401  17ea		       ac ce 24    iETask     ldy	taskPtr
    402  17ed		       c0 00		      cpy	#0
    403  17ef		       d0 03		      bne	iETaskCont
    404  17f1		       4c 00 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  17f4				   iETaskCont
    406  17f4		       a9 00		      lda	#TASKINACTIVE
    407  17f6		       99 cf 24 	      sta	taskTable,y	; mark entry as free
    408  17f9		       ce cd 25 	      dec	taskCounter	; reduce the number of active tasks
    409  17fc		       a9 01		      lda	#1
    410  17fe		       8d c9 25 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  1801		       8d ca 25 	      sta	taskCurrentCycles+1
    412  1804		       20 6b 18 	      jsr	TaskSetExitCode
    413  1807				   iETaskExit
    414  1807		       4c c2 02 	      jmp	NextIL
    415  180a							;================================================================
    416  180a							; make the current tasks math stack equal another tasks stack
    417  180a							; The task to get is stored on the math stack
    418  180a
    419  180a				   iTaskGetMathStack
    420  180a		       20 3f 1e 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  180d		       20 84 19 	      jsr	ipc_getcontext	; MQ now has the context address
    422  1810		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  1812		       b1 56		      lda	(MQ),y
    424  1814		       85 4a		      sta	MATHSTACKPTR
    425  1816		       a0 08		      ldy	#MATHSTACKPOS
    426  1818		       b1 56		      lda	(MQ),y
    427  181a		       85 48		      sta	MATHSTACK
    428  181c		       c8		      iny
    429  181d		       b1 56		      lda	(MQ),y
    430  181f		       85 49		      sta	MATHSTACK+1
    431  1821		       4c c2 02 	      jmp	NextIL
    432  1824							;==================================================================
    433  1824							; Updates the tasks math stack pointer with contents of R2
    434  1824							; PID is on top of the stack
    435  1824				   iTaskPutMathPtr
    436  1824		       20 3f 1e 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  1827		       20 84 19 	      jsr	ipc_getcontext	; MQ now has the context address
    438  182a		       a5 58		      lda	R2
    439  182c		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  182e		       91 56		      sta	(MQ),y
    441  1830		       4c c2 02 	      jmp	NextIL
    442  1833							;
    443  1833							;================================================================
    444  1833							; Set the time slice for each task
    445  1833				   iSLICE
    446  1833		       20 1e 1c 	      jsr	popR0
    447  1836		       a5 52		      lda	R0
    448  1838		       8d cb 25 	      sta	taskResetValue
    449  183b		       a5 53		      lda	R0+1
    450  183d		       8d cc 25 	      sta	taskResetValue+1
    451  1840		       d0 0b		      bne	iSliceSet
    452  1842		       ee cc 25 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  1845		       a9 01		      lda	#1
    454  1847		       8d c9 25 	      sta	taskCurrentCycles
    455  184a		       8d ca 25 	      sta	taskCurrentCycles+1
    456  184d				   iSliceSet
    457  184d		       4c c2 02 	      jmp	NextIL
    458  1850							;================================================================
    459  1850							; Find an empty slot in the taskTable
    460  1850							; Return the index in y
    461  1850							; on exit   c set if an empty slot is found
    462  1850							;	     c clear if not found
    463  1850							;================================================================
    464  1850							;
    465  1850		       ad cd 25    TaskEmpty  lda	taskCounter
    466  1853		       c9 0a		      cmp	#TASKCOUNT
    467  1855		       b0 10		      bcs	TaskNoSlot
    468  1857		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  1859				   TaskLoop
    470  1859		       b9 cf 24 	      lda	taskTable,y
    471  185c		       f0 0b		      beq	TaskEmptyFnd
    472  185e		       98		      tya
    473  185f		       18		      clc
    474  1860		       69 19		      adc	#CONTEXTLEN+1
    475  1862		       a8		      tay
    476  1863		       c0 fa		      cpy	#TASKTABLELEN
    477  1865		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  1867				   TaskNoSlot
    479  1867		       18		      clc
    480  1868		       60		      rts
    481  1869				   TaskEmptyFnd
    482  1869		       38		      sec
    483  186a		       60		      rts
    484  186b							;====================================================
    485  186b							; Set the task exit code called from the return command
    486  186b							; on entry stack top hold exit value
    487  186b				   TaskSetExitCode
    488  186b		       98		      tya
    489  186c		       48		      pha
    490  186d		       20 1e 1c 	      jsr	popR0
    491  1870		       a0 19		      ldy	#TASKEXITCODE
    492  1872		       a5 52		      lda	R0
    493  1874		       91 41		      sta	(VARIABLES),y
    494  1876		       c8		      iny
    495  1877		       a5 53		      lda	R0+1
    496  1879		       91 41		      sta	(VARIABLES),y
    497  187b		       68		      pla
    498  187c		       98		      tya
    499  187d		       60		      rts
    500  187e
    501  187e							;
    502  187e							;=====================================================
    503  187e							; Save Context Store the context to the TASK Table
    504  187e							; on entry y contains the task table entry to save to
    505  187e							; on exit y points to next task table entry
    506  187e							;	   x contains the number of bytes copied
    507  187e		       a2 00	   ContextSave ldx	#0
    508  1880		       c8		      iny		;inc past the task flags
    509  1881		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  1883		       99 cf 24 	      sta	taskTable,y
    511  1886		       c8		      iny
    512  1887		       e8		      inx
    513  1888		       e0 18		      cpx	#CONTEXTLEN
    514  188a		       90 f5		      bcc	ContextSvLoop
    515  188c		       60		      rts
    516  188d							;
    517  188d							; Load Context transfer context from task table to the Current Context
    518  188d							; on entry y contains the task table entry to transfer
    519  188d							; on exit y points to the original task table entry
    520  188d							;	   x contains the number of byts copied
    521  188d		       98	   ContextLoad tya
    522  188e		       48		      pha
    523  188f		       a2 00		      ldx	#0
    524  1891		       c8		      iny		;inc past the task flags
    525  1892		       b9 cf 24    ContextLDLoop lda	taskTable,y
    526  1895		       95 41		      sta	CONTEXT,x
    527  1897		       c8		      iny
    528  1898		       e8		      inx
    529  1899		       e0 18		      cpx	#CONTEXTLEN
    530  189b		       90 f5		      bcc	ContextLDLoop
    531  189d		       68		      pla
    532  189e		       a8		      tay
    533  189f		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  18a0					      include	"ipc.asm"
      1  18a0							;======================================================
      2  18a0							; Inter process communications.
      3  18a0							; Tasks may write/read integer messages among
      4  18a0							; them selves.
      5  18a0							; This uses each tasks gosub stack as a message queue
      6  18a0							; Gosub calls start at the highest address and the
      7  18a0							; msg queue starts at the highest address.
      8  18a0							;
      9  18a0							;======================================================
     10  18a0							; ipcs   - Send msg to another task or many tasks
     11  18a0							; on entry  math stack contains the  top PID
     12  18a0							;				      2ND Message value
     13  18a0							; on exit   math stack contain top True-good or False-failed
     14  18a0							;
     15  18a0							; it may not be sent if queue is full
     16  18a0							;
     17  18a0							; a = ipcs(<message-expression>,<task PID-expression>)
     18  18a0							;
     19  18a0				   iIPCS
     20  18a0		       98		      tya
     21  18a1		       48		      pha
     22  18a2		       20 09 19 	      jsr	ipc_enqueue
     23  18a5		       b0 08		      bcs	iIPC_BAD
     24  18a7		       20 31 1e 	      jsr	pushTrue
     25  18aa		       68		      pla
     26  18ab		       a8		      tay
     27  18ac		       4c c2 02 	      jmp	NextIL
     28  18af				   iIPC_BAD
     29  18af		       68		      pla
     30  18b0		       a8		      tay
     31  18b1		       20 3b 1e 	      jsr	pushFalse
     32  18b4		       4c c2 02 	      jmp	NextIL
     33  18b7
     34  18b7							;======================================================
     35  18b7							; ipcr   - Recieve msg from task
     36  18b7							; on exit  the message value is returned from message queue
     37  18b7							;	    message -1	is reserved meaning no entry found
     38  18b7							; The provided variable contains the pid of the sending
     39  18b7							; task. This is optional. This always waits for a message
     40  18b7							; before returning.
     41  18b7							;
     42  18b7							; a = ipcr(<variable name>)
     43  18b7							;
     44  18b7				   iIPCR
     45  18b7		       98		      tya
     46  18b8		       48		      pha
     47  18b9		       20 4b 19 	      jsr	ipc_dequeue
     48  18bc		       b0 05		      bcs	iIPCR_Q_Empty
     49  18be		       68		      pla
     50  18bf		       a8		      tay
     51  18c0		       4c c2 02 	      jmp	NextIL
     52  18c3				   iIPCR_Q_Empty
     53  18c3		       68		      pla
     54  18c4		       a8		      tay
     55  18c5		       20 31 1e 	      jsr	pushTrue	; puts -1 on the stack
     56  18c8		       4c c2 02 	      jmp	NextIL
     57  18cb
     58  18cb							;=======================================================
     59  18cb							; ipcc   - Check if message available
     60  18cb							; on exit  Stack contains number of messages
     61  18cb							;
     62  18cb							; a = ipcc()
     63  18cb							;
     64  18cb				   iIPCC
     65  18cb		       98		      tya
     66  18cc		       48		      pha
     67  18cd		       20 f6 18 	      jsr	ipc_queue_count
     68  18d0		       20 9a 1b 	      jsr	pushR0	; return the count
     69  18d3		       68		      pla
     70  18d4		       a8		      tay
     71  18d5		       4c c2 02 	      jmp	NextIL
     72  18d8
     73  18d8							;=======================================================
     74  18d8							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  18d8				   iIPCIO
     76  18d8		       98		      tya
     77  18d9		       48		      pha
     78  18da		       20 f6 18 	      jsr	ipc_queue_count
     79  18dd		       a5 52		      lda	R0
     80  18df		       d0 10		      bne	iIPCIO_No_Halt
     81  18e1		       a9 01		      lda	#1
     82  18e3		       8d c9 25 	      sta	taskCurrentCycles	; force a task switch
     83  18e6		       a9 01		      lda	#TASKWAITIPC
     84  18e8		       ac ce 24 	      ldy	taskPtr
     85  18eb		       19 cf 24 	      ora	taskTable,y
     86  18ee		       99 cf 24 	      sta	taskTable,y
     87  18f1
     88  18f1				   iIPCIO_No_Halt
     89  18f1		       68		      pla
     90  18f2		       a8		      tay
     91  18f3		       4c c2 02 	      jmp	NextIL
     92  18f6							;======================================================
     93  18f6							;ipc_queue_count
     94  18f6				   ipc_queue_count
     95  18f6		       a5 4e		      lda	MESSAGEPTR
     96  18f8		       18		      clc
     97  18f9		       4a		      lsr		; divide by 4
     98  18fa		       4a		      lsr
     99  18fb		       85 52		      sta	R0	; store into R0
    100  18fd		       a9 10		      lda	#GOSUBSTACKSIZE
    101  18ff		       38		      sec
    102  1900		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1902		       85 52		      sta	R0
    104  1904		       a9 00		      lda	#0
    105  1906		       85 53		      sta	R0+1
    106  1908		       60		      rts
    107  1909							;=======================================================
    108  1909							; Support functions for messaging
    109  1909							;
    110  1909							; Enqueue message -> onto PID's MSG Q
    111  1909							; on entry top of stack contains the PID
    112  1909							;	    second contains the Message of the task
    113  1909							; on exit contains c set if failed
    114  1909							;		    c cleared if success
    115  1909							;		    PID's MSG Q PTR points to the message
    116  1909							;
    117  1909				   ipc_enqueue
    118  1909		       20 36 1c 	      jsr	popR1	; Get the pid
    119  190c		       20 84 19 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  190f
    121  190f		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1911		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1913		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1915		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1917		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1919
    127  1919
    128  1919							; Get the PID'S stack address into R0
    129  1919		       a0 0b		      ldy	#GOSUBSTKPOS
    130  191b		       b1 56		      lda	(MQ),y
    131  191d		       85 52		      sta	R0
    132  191f		       c8		      iny
    133  1920		       b1 56		      lda	(MQ),y
    134  1922		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1924
    136  1924							; Set y to point to the msg q entry
    137  1924		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1926		       b1 56		      lda	(MQ),y	; Get the index
    139  1928		       a8		      tay		; Set y to queue offset
    140  1929
    141  1929							; enqueue the message
    142  1929		       88		      dey		; First byte to save to
    143  192a		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  192c		       91 52		      sta	(R0),y	; Set the entry type
    145  192e
    146  192e		       88		      dey
    147  192f		       ad ce 24 	      lda	taskPtr	; Store the PID into queue
    148  1932		       91 52		      sta	(R0),y
    149  1934		       20 36 1c 	      jsr	popR1	; Get the actual message value
    150  1937		       20 92 19 	      jsr	ipc_pushR1	; Store Message value into queue
    151  193a
    152  193a		       98		      tya		; Save the new q ptr
    153  193b		       a0 0e		      ldy	#MSGPTRPOS
    154  193d		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  193f		       a0 00		      ldy	#0	; points to context root
    156  1941		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1943		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1945		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1947		       18		      clc
    160  1948		       60		      rts
    161  1949				   ipc_enq_full
    162  1949		       38		      sec
    163  194a		       60		      rts
    164  194b							;=============================================================
    165  194b							; De-queue for message stack -> local tasks msg q
    166  194b							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  194b							;  message into
    168  194b							;  on exit   math stack contains value of message
    169  194b							;				  Variable if provided is pid
    170  194b				   ipc_dequeue
    171  194b		       20 4d 1c 	      jsr	popMQ	; Variable address to put PID into
    172  194e
    173  194e		       a4 4e		      ldy	MESSAGEPTR
    174  1950		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1952		       b0 2e		      bcs	ipc_deq_empty
    176  1954		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1956		       85 52		      sta	R0
    178  1958		       c8		      iny
    179  1959		       b1 4b		      lda	(GOSUBSTACK),y
    180  195b		       85 53		      sta	R0+1
    181  195d		       c8		      iny
    182  195e		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1960		       85 54		      sta	R1
    184  1962		       c8		      iny
    185  1963		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1965		       c8		      iny
    187  1966		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1968
    189  1968		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  196a		       d0 16		      bne	ipc_deq_empty
    191  196c
    192  196c		       20 9a 1b 	      jsr	pushR0	; place value on stack
    193  196f
    194  196f		       a5 56		      lda	MQ
    195  1971		       05 57		      ora	MQ+1
    196  1973		       f0 0b		      beq	ipc_deq_done
    197  1975		       a5 54		      lda	R1
    198  1977		       a0 00		      ldy	#0
    199  1979		       91 56		      sta	(MQ),y
    200  197b		       c8		      iny
    201  197c		       a9 00		      lda	#0
    202  197e		       91 56		      sta	(MQ),y
    203  1980				   ipc_deq_done
    204  1980		       18		      clc
    205  1981		       60		      rts
    206  1982
    207  1982				   ipc_deq_empty
    208  1982		       38		      sec
    209  1983		       60		      rts
    210  1984
    211  1984							;=============================================
    212  1984							;  Get the context address into MQ from R1 with
    213  1984							;  context/index/pid
    214  1984				   ipc_getcontext
    215  1984		       18		      clc		; Get pointer to Task context
    216  1985		       a9 cf		      lda	#taskTable&$FF	; change ptr to address
    217  1987		       65 54		      adc	R1
    218  1989		       85 56		      sta	MQ
    219  198b		       a9 24		      lda	#taskTable>>8
    220  198d		       65 55		      adc	R1+1
    221  198f		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1991		       60		      rts
    223  1992							;
    224  1992							;==============================================
    225  1992							;Push R1 onto the stack
    226  1992							;on entry y = next entry
    227  1992							;R0 points to the stack space
    228  1992							;on exit y points to next free byte
    229  1992				   ipc_pushR1
    230  1992		       88		      dey
    231  1993		       a5 55		      lda	R1+1	; PID first
    232  1995		       91 52		      sta	(R0),y
    233  1997		       88		      dey
    234  1998		       a5 54		      lda	R1
    235  199a		       91 52		      sta	(R0),y
    236  199c		       60		      rts
    237  199d
    238  199d
    239  199d
    240  199d
    241  199d
    242  199d
    243  199d
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  199d					      include	"support.asm"
      1  199d							;
      2  199d							;=====================================================
      3  199d							;=====================================================
      4  199d							;=====================================================
      5  199d							; This marks the start of support functions used by
      6  199d							; the IL opcodes.  These are support functions, NOT
      7  199d							; the IL code.
      8  199d							;=====================================================
      9  199d							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  199d							;=====================================================
     11  199d					      Seg	Code
     12  199d							;=====================================================
     13  199d							; This gets the next two bytes pointed to by ILPC and
     14  199d							; returns them; X contains LSB, A contains MSB.  ILPC
     15  199d							; is advanced by two, and Y contains 0 on return.
     16  199d
     17  199d							;
     18  199d		       20 a1 19    getILWord  jsr	getILByte	;LSB
     19  19a0		       aa		      tax
     20  19a1							;
     21  19a1							;=====================================================
     22  19a1							; This gets the next byte pointed to by ILPC and
     23  19a1							; returns it in A.  On return, X is unchanged but Y
     24  19a1							; contains 0.
     25  19a1							;
     26  19a1		       a0 00	   getILByte  ldy	#0
     27  19a3		       b1 43		      lda	(ILPC),y	;get byte
     28  19a5		       08		      php		;save status
     29  19a6		       e6 43		      inc	ILPC	;inc LSB
     30  19a8		       d0 02		      bne	getILb2	;branch if no overflow
     31  19aa		       e6 44		      inc	ILPC+1	;inc MSB
     32  19ac		       28	   getILb2    plp		;restore status
     33  19ad		       60		      rts
     34  19ae							;
     35  19ae							;=====================================================
     36  19ae							; Decrement ILPC by one.
     37  19ae							;
     38  19ae		       a5 43	   decIL      lda	ILPC
     39  19b0		       d0 02		      bne	decIL2
     40  19b2		       c6 44		      dec	ILPC+1
     41  19b4		       c6 43	   decIL2     dec	ILPC
     42  19b6		       60		      rts
     43  19b7							;
     44  19b7							;=====================================================
     45  19b7							; Push the ILPC onto the return stack.  Actually, this
     46  19b7							; pushes the address of ILPC+2 since that's the next
     47  19b7							; address to execute.
     48  19b7							;
     49  19b7		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  19b9		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  19bb		       b0 15		      bcs	pushErr
     52  19bd		       a5 43		      lda	ILPC
     53  19bf		       18		      clc
     54  19c0		       69 02		      adc	#2
     55  19c2		       91 45		      sta	(ILSTACK),y
     56  19c4		       08		      php		;save C bit
     57  19c5		       c8		      iny
     58  19c6		       a5 44		      lda	ILPC+1
     59  19c8		       28		      plp		;restore C
     60  19c9		       69 00		      adc	#0
     61  19cb		       91 45		      sta	(ILSTACK),y
     62  19cd		       c8		      iny
     63  19ce		       84 47		      sty	ILSTACKPTR
     64  19d0		       18		      clc
     65  19d1		       60		      rts
     66  19d2				   pushErr
     67  19d2		       38		      sec
     68  19d3		       60		      rts
     69  19d4							;
     70  19d4							;=====================================================
     71  19d4							; Pull the top entry from return stack and put into
     72  19d4							; ILPC.
     73  19d4							;
     74  19d4		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  19d6		       f0 fa		      beq	pushErr
     76  19d8		       88		      dey
     77  19d9		       b1 45		      lda	(ILSTACK),y
     78  19db		       85 44		      sta	ILPC+1
     79  19dd		       88		      dey
     80  19de		       b1 45		      lda	(ILSTACK),y
     81  19e0		       85 43		      sta	ILPC
     82  19e2		       84 47		      sty	ILSTACKPTR
     83  19e4		       18		      clc
     84  19e5		       60		      rts
     85  19e6							;
     86  19e6							;=====================================================
     87  19e6							; This searches for a specific line number that is in
     88  19e6							; R0.	There are three possible return conditions:
     89  19e6							; Line numbers are now the third byte, the first byte is now **************
     90  19e6							; a pointer to the next line, of course no longer that 53 byte
     91  19e6							; per line.
     92  19e6							;
     93  19e6							; Exact match was found:
     94  19e6							;    * Z set
     95  19e6							;    * CURPTR points to two-byte line number for that
     96  19e6							;	line.
     97  19e6							;
     98  19e6							; Next highest line found:
     99  19e6							;    * Z cleared
    100  19e6							;    * C set
    101  19e6							;    * CURPTR points to two-byte line number for that
    102  19e6							;	line.
    103  19e6							;
    104  19e6							; End of program reached:
    105  19e6							;    * Z cleared
    106  19e6							;    * C cleared
    107  19e6							;    * CURPTR points to first free byte at end of
    108  19e6							;	program.  Ie, it has save value as PROGRAMEND.
    109  19e6							;
    110  19e6							; A, X, and Y are all undefined on return.
    111  19e6							;
    112  19e6
    113  19e6				   findLine
    114  19e6		       ad 27 2e 	      lda	ProgramStart	;Start of program -> CURPTR
    115  19e9		       85 4f		      sta	CURPTR
    116  19eb		       ad 28 2e 	      lda	ProgramStart+1
    117  19ee		       85 50		      sta	CURPTR+1
    118  19f0							;
    119  19f0							; At end of code?
    120  19f0							;
    121  19f0				   iXFER1
    122  19f0		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  19f2		       cd 29 2e 	      cmp	ProgramEnd	; at end of program then stop run
    124  19f5		       d0 0b		      bne	xfer2	; not end
    125  19f7		       a5 50		      lda	CURPTR+1
    126  19f9		       cd 2a 2e 	      cmp	ProgramEnd+1
    127  19fc		       d0 04		      bne	xfer2	;Not at end
    128  19fe							;
    129  19fe							; Line not found and the end of the program was
    130  19fe							; reached.  Return Z and C both clear.
    131  19fe							;
    132  19fe		       a9 01		      lda	#1	;clear Z
    133  1a00		       18		      clc		;clear C
    134  1a01		       60		      rts
    135  1a02							;
    136  1a02							; Check for an exact line number match
    137  1a02							;
    138  1a02		       a5 52	   xfer2      lda	R0
    139  1a04		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1a06		       d1 4f		      cmp	(CURPTR),y
    141  1a08		       d0 08		      bne	xfernotit
    142  1a0a		       c8		      iny
    143  1a0b		       a5 53		      lda	R0+1
    144  1a0d		       d1 4f		      cmp	(CURPTR),y
    145  1a0f		       d0 01		      bne	xfernotit	; not a matching line number
    146  1a11							;
    147  1a11							; This is exactly the line we want.
    148  1a11							;
    149  1a11		       60		      rts		;it matches exactly
    150  1a12							;
    151  1a12							; See if this line is greater than the one we're
    152  1a12							; searching for.
    153  1a12							;
    154  1a12		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1a14		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1a16		       c5 53		      cmp	R0+1
    157  1a18		       90 0b		      bcc	xfer3
    158  1a1a		       d0 07		      bne	xfer4
    159  1a1c		       88		      dey
    160  1a1d		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1a1f		       c5 52		      cmp	R0
    162  1a21		       90 02		      bcc	xfer3
    163  1a23							;
    164  1a23							; This line is greater than the one we want, so
    165  1a23							; return Z clear and C set.
    166  1a23							;
    167  1a23		       38	   xfer4      sec		;We found a line number greater
    168  1a24		       60		      rts		;both conditions set
    169  1a25							;
    170  1a25							; Not the line (or droid) we're looking for.  Move to
    171  1a25							; the next line.
    172  1a25							;
    173  1a25		       20 2b 1a    xfer3      jsr	FindNextLine
    174  1a28		       4c f0 19 	      jmp	iXFER1
    175  1a2b							;
    176  1a2b							;=====================================================
    177  1a2b							; This advances CURPTR to the next line.  If there
    178  1a2b							; are no more lines, this leaves CURPTR equal to
    179  1a2b							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1a2b							; CURPTR is pointing to a valid line on entry.  This
    181  1a2b							; pointer points to the two-byte line number.
    182  1a2b							; Update this points to the 1 byte line length  ****************
    183  1a2b							;
    184  1a2b				   FindNextLine
    185  1a2b		       a0 03		      ldy	#3	;skip line number and length byte
    186  1a2d		       84 51		      sty	CUROFF	;this is the new offset
    187  1a2f		       a0 00		      ldy	#0
    188  1a31		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1a33		       18		      clc
    190  1a34		       65 4f		      adc	CURPTR
    191  1a36		       85 4f		      sta	CURPTR
    192  1a38		       a5 50		      lda	CURPTR+1
    193  1a3a		       69 00		      adc	#0
    194  1a3c		       85 50		      sta	CURPTR+1
    195  1a3e		       60	   FindNext4  rts
    196  1a3f							;
    197  1a3f							;=====================================================
    198  1a3f							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1a3f							; if they are equal, Z clear if not.
    200  1a3f							;
    201  1a3f		       a5 4f	   AtEnd      lda	CURPTR
    202  1a41		       cd 29 2e 	      cmp	ProgramEnd
    203  1a44		       d0 05		      bne	atendexit
    204  1a46		       a5 50		      lda	CURPTR+1
    205  1a48		       cd 2a 2e 	      cmp	ProgramEnd+1
    206  1a4b		       60	   atendexit  rts
    207  1a4c							;
    208  1a4c
    209  1a4c							;
    210  1a4c							;=====================================================
    211  1a4c							; Convert an ASCII string to a number.  On input,
    212  1a4c							; (CURPTR),Y points to the first digit.  This gets
    213  1a4c							; digit-by-digit until finding a non-number.  Returns
    214  1a4c							; Y pointing to the non-digit, and R0 contains the
    215  1a4c							; number.  This does NOT check for valid ranges, so
    216  1a4c							; a value like "123456789" will produce something,
    217  1a4c							; but not what you had expected.
    218  1a4c							;
    219  1a4c		       a9 00	   getDecimal lda	#0
    220  1a4e		       85 52		      sta	R0
    221  1a50		       85 53		      sta	R0+1
    222  1a52		       85 59		      sta	dpl	;temporary negative flag
    223  1a54							;
    224  1a54							; See if it's negative...
    225  1a54							;
    226  1a54							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1a54		       b1 4f		      lda	(CURPTR),y
    228  1a56		       c9 2d		      cmp	#'-
    229  1a58		       d0 02		      bne	getDecLoop
    230  1a5a		       e6 59		      inc	dpl	;it's negative
    231  1a5c							;
    232  1a5c		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1a5e		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1a60		       c9 30		      cmp	#'0
    235  1a62		       90 36		      bcc	getDdone
    236  1a64		       c9 3a		      cmp	#'9+1
    237  1a66		       b0 32		      bcs	getDdone
    238  1a68		       38		      sec
    239  1a69		       e9 30		      sbc	#'0	;convert to binary
    240  1a6b		       48		      pha
    241  1a6c							;
    242  1a6c							; Now multiply R0 by 10.  Remember that
    243  1a6c							; 2*N + 8*N = 10*N.
    244  1a6c							;
    245  1a6c		       06 52		      asl	R0
    246  1a6e		       26 53		      rol	R0+1	;*2
    247  1a70		       a5 52		      lda	R0
    248  1a72		       85 54		      sta	R1
    249  1a74		       a5 53		      lda	R0+1
    250  1a76		       85 55		      sta	R1+1
    251  1a78		       06 52		      asl	R0
    252  1a7a		       26 53		      rol	R0+1	;*4
    253  1a7c		       06 52		      asl	R0
    254  1a7e		       26 53		      rol	R0+1	;*8
    255  1a80		       18		      clc		;now add the partial sums...
    256  1a81		       a5 52		      lda	R0	;...to get *10
    257  1a83		       65 54		      adc	R1
    258  1a85		       85 52		      sta	R0
    259  1a87		       a5 53		      lda	R0+1
    260  1a89		       65 55		      adc	R1+1
    261  1a8b		       85 53		      sta	R0+1
    262  1a8d							;
    263  1a8d							; Add in the new digit
    264  1a8d							;
    265  1a8d		       68		      pla
    266  1a8e		       18		      clc
    267  1a8f		       65 52		      adc	R0
    268  1a91		       85 52		      sta	R0
    269  1a93		       90 02		      bcc	getD2
    270  1a95		       e6 53		      inc	R0+1
    271  1a97							;
    272  1a97							; Move to next character
    273  1a97							;
    274  1a97		       c8	   getD2      iny
    275  1a98		       d0 c2		      bne	getDecLoop
    276  1a9a							;
    277  1a9a							; All done with digits, so now deal with it being
    278  1a9a							; negative.  If zero, then don't check for negative
    279  1a9a							; flag.  Ie, -0 is stored as 0.
    280  1a9a							;
    281  1a9a		       a5 52	   getDdone   lda	R0
    282  1a9c		       05 53		      ora	R0+1
    283  1a9e		       f0 16		      beq	getDone2	;zero
    284  1aa0		       a5 59		      lda	dpl
    285  1aa2		       f0 12		      beq	getDone2	;positive
    286  1aa4							;
    287  1aa4							; Invert all the bits, then add one.
    288  1aa4							;
    289  1aa4		       a5 52		      lda	R0
    290  1aa6		       49 ff		      eor	#$ff
    291  1aa8		       85 52		      sta	R0
    292  1aaa		       a5 53		      lda	R0+1
    293  1aac		       49 ff		      eor	#$ff
    294  1aae		       85 53		      sta	R0+1
    295  1ab0							;
    296  1ab0		       e6 52		      inc	R0
    297  1ab2		       d0 02		      bne	getDone2
    298  1ab4		       e6 53		      inc	R0+1
    299  1ab6				   getDone2
    300  1ab6							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1ab6							;lda	  R0
    302  1ab6							;sta	  $0010
    303  1ab6							;lda	  R0+1
    304  1ab6							;sta	  $0011
    305  1ab6							;lda	  dpl
    306  1ab6							;sta	  $012
    307  1ab6
    308  1ab6		       60		      rts
    309  1ab7
    310  1ab7							;=====================================================
    311  1ab7							; Gets a line of input into LINBUF.
    312  1ab7							;
    313  1ab7							; On entry:
    314  1ab7							;    A contains the prompt character, or 0 if none.
    315  1ab7							;    X = 1 Background read
    316  1ab7							;    x = 0 Forground read with wait
    317  1ab7							;
    318  1ab7							; On exit:
    319  1ab7							;    CURPTR points to LINBUF
    320  1ab7							;    LINBUF contains the line with 0 at the end.
    321  1ab7							;    Y has offset to first non-space character
    322  1ab7							;    CURROFF has the same as Y.
    323  1ab7							;
    324  1ab7		       20 06 1b    GetLine    jsr	ReadPrompt
    325  1aba		       e0 00		      cpx	#0
    326  1abc		       f0 14		      beq	GetLineRetry
    327  1abe		       ae ce 24 	      ldx	taskPtr
    328  1ac1		       bd cf 24 	      lda	taskTable,x
    329  1ac4		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1ac6		       d0 3d		      bne	taskWaitingIO
    331  1ac8		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1aca		       9d cf 24 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1acd		       ce 05 1b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1ad0		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1ad2
    336  1ad2							;
    337  1ad2							; Now read a line and wait for the CR
    338  1ad2							;
    339  1ad2				   GetLineRetry
    340  1ad2		       a9 00		      lda	#0	;Wait for input to complete
    341  1ad4		       20 1e 1b 	      jsr	ReadLine
    342  1ad7
    343  1ad7							;
    344  1ad7							; Point to the line we just read
    345  1ad7							; Set the current pointer to point to the input line
    346  1ad7							;
    347  1ad7		       a0 00	   ReadComplete ldy	#0
    348  1ad9		       84 51		      sty	CUROFF
    349  1adb		       a2 8a		      ldx	#LINBUF&$ff
    350  1add		       86 4f		      stx	CURPTR
    351  1adf		       a2 2d		      ldx	#LINBUF>>8
    352  1ae1		       86 50		      stx	CURPTR+1
    353  1ae3							;
    354  1ae3							; Output a CR/LF
    355  1ae3							;
    356  1ae3		       20 d7 1c 	      jsr	CRLF
    357  1ae6							;
    358  1ae6							; If a blank line, prompt again.
    359  1ae6							;
    360  1ae6		       20 ce 1c 	      jsr	SkipSpaces
    361  1ae9		       b1 4f		      lda	(CURPTR),y
    362  1aeb		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1aed		       20 09 1b 	      jsr	ReadPromptRetry
    364  1af0		       ae ce 24 	      ldx	taskPtr	;if this task is waiting for IO
    365  1af3		       bd cf 24 	      lda	taskTable,x	;then get out, wait for line to
    366  1af6		       29 40		      and	#TASKWAITIO	;Complete again
    367  1af8		       d0 0b		      bne	taskWaitingIO
    368  1afa		       4c d2 1a 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1afd
    370  1afd				   GetLineDone
    371  1afd		       ae ce 24 	      ldx	taskPtr
    372  1b00		       a9 80		      lda	#TASKACTIVE
    373  1b02		       9d cf 24 	      sta	taskTable,x	;IO is complete
    374  1b05
    375  1b05				   taskWaitingIO
    376  1b05		       60		      rts
    377  1b06
    378  1b06							;
    379  1b06							;=======================================================================
    380  1b06							; Display the prompt character
    381  1b06							; On entry
    382  1b06							;	    A contains the prompt character
    383  1b06							; On exit
    384  1b06							;	    The readbuffer index is reset to 0
    385  1b06							;
    386  1b06		       8d 11 2e    ReadPrompt sta	promptChar
    387  1b09
    388  1b09							;
    389  1b09							; Prompt
    390  1b09							;
    391  1b09
    392  1b09		       ad 11 2e    ReadPromptRetry lda	promptChar
    393  1b0c		       09 00		      ora	#0	;any prompt?
    394  1b0e		       f0 08		      beq	getlinenp
    395  1b10		       20 20 1e 	      jsr	VOUTCH
    396  1b13		       a9 20		      lda	#$20
    397  1b15		       20 20 1e 	      jsr	VOUTCH	;Space after prompt
    398  1b18							;
    399  1b18		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1b1a		       8e 0e 2e 	      stx	getlinx
    401  1b1d		       60		      rts
    402  1b1e							;
    403  1b1e							;===============================================================
    404  1b1e							; This fuction is the driver for the line input
    405  1b1e							; on call if a = 0 then it waits for all input
    406  1b1e							;	      a = 1 then nowait for input
    407  1b1e							; On exit
    408  1b1e							;		       c clear if not complete line
    409  1b1e							;		       c set if it was a complete line
    410  1b1e
    411  1b1e				   ReadLine
    412  1b1e		       8d 10 2e 	      sta	inputNoWait
    413  1b21		       c9 00		      cmp	#0
    414  1b23		       f0 05		      beq	getline1
    415  1b25		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1b28		       f0 2b		      beq	GetLineNoWait
    417  1b2a		       20 23 1e    getline1   jsr	VGETCH
    418  1b2d					      if	CTMON65
    419  1b2d		       48		      pha
    420  1b2e		       20 20 1e 	      jsr	VOUTCH	;echo echo echo
    421  1b31		       68		      pla
    422  1b32					      endif
    423  1b32		       c9 0d		      cmp	#CR
    424  1b34		       f0 15		      beq	getlind	;end of line
    425  1b36		       c9 08		      cmp	#BS	;backspace?
    426  1b38		       f0 1d		      beq	getlinebs
    427  1b3a		       ae 0e 2e 	      ldx	getlinx
    428  1b3d		       9d 8a 2d 	      sta	LINBUF,x
    429  1b40		       e8		      inx
    430  1b41		       8e 0e 2e 	      stx	getlinx
    431  1b44		       ad 10 2e 	      lda	inputNoWait
    432  1b47		       f0 e1		      beq	getline1
    433  1b49		       d0 0a		      bne	GetLineNoWait
    434  1b4b							;
    435  1b4b							; CR was hit
    436  1b4b							;
    437  1b4b		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1b4d		       ae 0e 2e 	      ldx	getlinx
    439  1b50		       9d 8a 2d 	      sta	LINBUF,x
    440  1b53
    441  1b53		       38		      sec		; Carry set then cr received
    442  1b54		       60		      rts
    443  1b55
    444  1b55				   GetLineNoWait
    445  1b55		       18		      clc		; Carry clear no end of line
    446  1b56		       60		      rts
    447  1b57							;
    448  1b57							; Backspace was hit
    449  1b57							;
    450  1b57		       ae 0e 2e    getlinebs  ldx	getlinx
    451  1b5a		       f0 0e		      beq	getlineEOL	;at start of line
    452  1b5c		       ca		      dex
    453  1b5d		       8e 0e 2e 	      stx	getlinx
    454  1b60		       20 4d 14    getlinepbs jsr	puts
      0  1b63					      db	27,"[K",0
      1  1b63		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1b67		       4c 2a 1b 	      jmp	getline1
    457  1b6a		       a9 20	   getlineEOL lda	#SPACE
    458  1b6c		       20 20 1e 	      jsr	VOUTCH
    459  1b6f		       d0 ef		      bne	getlinepbs
    460  1b71							;
    461  1b71							;=====================================================
    462  1b71							; Count the length of the line currently in LINBUF
    463  1b71							; starting at offset Y.  Returns the length in X.  The
    464  1b71							; starting offset in Y should point past the ASCII
    465  1b71							; line number.  Also counts the trailing NULL and two
    466  1b71							; extra bytes for where the line number will be.
    467  1b71							; Update must now include leading length byte not the null at end ****************
    468  1b71							;
    469  1b71				   getLineLength
    470  1b71		       a2 00		      ldx	#0	;size
    471  1b73		       b9 8a 2d    getLineL2  lda	LINBUF,y
    472  1b76		       f0 04		      beq	getLineL3
    473  1b78		       c8		      iny
    474  1b79		       e8		      inx
    475  1b7a		       d0 f7		      bne	getLineL2
    476  1b7c		       e8	   getLineL3  inx		;count null at end
    477  1b7d		       e8		      inx		;line number LSB
    478  1b7e		       e8		      inx		;MSB
    479  1b7f		       e8		      inx		;change: count new leading line length
    480  1b80		       8e 24 2e 	      stx	lineLength
    481  1b83		       60		      rts
    482  1b84							;
    483  1b84							;=====================================================
    484  1b84							; Count the length of the line pointed to by CURPTR.
    485  1b84							; This also counts the line number and the terminating
    486  1b84							; null.  Ie, this string returns 8:
    487  1b84							;
    488  1b84							; <lineLow><lineHi>Hello<null>
    489  1b84							;
    490  1b84							; Another way of looking at it: add the return value
    491  1b84							; to the CURPTR and it'll point to the next line's
    492  1b84							; line number.  Returns the value in Y.
    493  1b84							; Update to ject get the leading byte length ********************
    494  1b84							;
    495  1b84							;getCURPTRLength
    496  1b84							;		ldy	CURPTR
    497  1b84							;		ldy	#3	;change: skip line number and leading length byte
    498  1b84							;getCLineL2	lda	(CURPTR),y
    499  1b84							;		beq	getCLineL3
    500  1b84							;		iny
    501  1b84							;		bne	getCLineL2
    502  1b84							;getCLineL3	iny		;count null at end
    503  1b84							;		rts
    504  1b84
    505  1b84							;
    506  1b84							;=====================================================
    507  1b84							; This saves ILPC.  This saves to a single save area,
    508  1b84							; so it can't be called more than once.
    509  1b84							;
    510  1b84		       a5 43	   saveIL     lda	ILPC
    511  1b86		       8d 20 2e 	      sta	tempIL
    512  1b89		       a5 44		      lda	ILPC+1
    513  1b8b		       8d 21 2e 	      sta	tempIL+1
    514  1b8e		       60		      rts
    515  1b8f							;
    516  1b8f							;=====================================================
    517  1b8f							; This restores ILPC.
    518  1b8f							;
    519  1b8f		       ad 20 2e    restoreIL  lda	tempIL
    520  1b92		       85 43		      sta	ILPC
    521  1b94		       ad 21 2e 	      lda	tempIL+1
    522  1b97		       85 44		      sta	ILPC+1
    523  1b99		       60		      rts
    524  1b9a							;
    525  1b9a							;=====================================================
    526  1b9a							; This pushes R0 onto the stack.
    527  1b9a							;
    528  1b9a		       8c 17 2e    pushR0     sty	rtemp1
    529  1b9d		       a4 4a		      ldy	MATHSTACKPTR
    530  1b9f		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1ba1		       b0 34		      bcs	pusherr
    532  1ba3		       a5 52		      lda	R0
    533  1ba5		       91 48		      sta	(MATHSTACK),y
    534  1ba7		       c8		      iny
    535  1ba8		       a5 53		      lda	R0+1
    536  1baa		       91 48		      sta	(MATHSTACK),y
    537  1bac		       c8		      iny
    538  1bad		       84 4a		      sty	MATHSTACKPTR
    539  1baf		       ac 17 2e 	      ldy	rtemp1
    540  1bb2		       18		      clc
    541  1bb3		       60		      rts
    542  1bb4
    543  1bb4							;=====================================================
    544  1bb4							; This pushes curptr basic current line onto the call stack.
    545  1bb4							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1bb4
    547  1bb4				   pushLN
    548  1bb4		       8c 17 2e 	      sty	rtemp1
    549  1bb7		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  1bb9		       c5 4d		      cmp	GOSUBSTACKPTR
    551  1bbb		       90 1a		      bcc	pusherr	; No error
    552  1bbd		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  1bbf		       a2 00		      ldx	#0	; Start of bytes to copy
    554  1bc1				   pushLoop
    555  1bc1		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  1bc3		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  1bc5		       c8		      iny		; Next destination
    558  1bc6		       e8		      inx		; Next Source byte
    559  1bc7		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  1bc9		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  1bcb
    562  1bcb		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  1bcd		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  1bcf		       c8		      iny		; Next entry
    565  1bd0
    566  1bd0		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  1bd2		       ac 17 2e 	      ldy	rtemp1
    568  1bd5		       18		      clc
    569  1bd6		       60		      rts
    570  1bd7				   pusherr
    571  1bd7		       38		      sec
    572  1bd8		       60		      rts
    573  1bd9							;=====================================================
    574  1bd9							; This pops Top Off gosub call Stack and
    575  1bd9							; places it in CURPTR/CUROFF.
    576  1bd9							; This checks if the type = 1 GOSUB
    577  1bd9							; if not it removes what ever is on the stack
    578  1bd9							; until it finds the next return. Allowing
    579  1bd9							; a return from within a for/next
    580  1bd9		       8c 17 2e    popLN      sty	rtemp1
    581  1bdc		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  1bde		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  1be0
    584  1be0				   popContinue
    585  1be0		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  1be2		       90 18		      bcc	poperr	; Process an error
    587  1be4
    588  1be4		       88		      dey		; Position to read entry type
    589  1be5		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  1be7		       c9 01		      cmp	#1	; Type is a gosub entry
    591  1be9		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  1beb
    593  1beb				   popLoop
    594  1beb		       88		      dey
    595  1bec		       ca		      dex
    596  1bed		       b1 4b		      lda	(GOSUBSTACK),y
    597  1bef		       95 4f		      sta	CURPTR,x
    598  1bf1		       e0 00		      cpx	#0
    599  1bf3		       d0 f6		      bne	popLoop	; Loop until all moved
    600  1bf5
    601  1bf5
    602  1bf5		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  1bf7		       ac 17 2e 	      ldy	rtemp1
    604  1bfa		       18		      clc
    605  1bfb		       60		      rts
    606  1bfc
    607  1bfc		       38	   poperr     sec
    608  1bfd		       60		      rts
    609  1bfe
    610  1bfe		       88	   popSkipEntry dey
    611  1bff		       88		      dey
    612  1c00		       88		      dey
    613  1c01		       4c e0 1b 	      jmp	popContinue
    614  1c04
    615  1c04							;
    616  1c04							;=====================================================
    617  1c04							; This pushes R1 onto the stack
    618  1c04							;
    619  1c04		       8c 17 2e    pushR1     sty	rtemp1
    620  1c07		       a4 4a		      ldy	MATHSTACKPTR
    621  1c09		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  1c0b		       b0 ef		      bcs	poperr
    623  1c0d		       a5 54		      lda	R1
    624  1c0f		       91 48		      sta	(MATHSTACK),y
    625  1c11		       c8		      iny
    626  1c12		       a5 55		      lda	R1+1
    627  1c14		       91 48		      sta	(MATHSTACK),y
    628  1c16		       c8		      iny
    629  1c17		       84 4a		      sty	MATHSTACKPTR
    630  1c19		       ac 17 2e 	      ldy	rtemp1
    631  1c1c		       18		      clc
    632  1c1d		       60		      rts
    633  1c1e							;
    634  1c1e							;=====================================================
    635  1c1e							; This pops Top Of Stack and places it in R0.
    636  1c1e							;
    637  1c1e		       8c 17 2e    popR0      sty	rtemp1
    638  1c21		       a4 4a		      ldy	MATHSTACKPTR
    639  1c23		       f0 d7		      beq	poperr
    640  1c25		       88		      dey
    641  1c26		       b1 48		      lda	(MATHSTACK),y
    642  1c28		       85 53		      sta	R0+1
    643  1c2a		       88		      dey
    644  1c2b		       b1 48		      lda	(MATHSTACK),y
    645  1c2d		       85 52		      sta	R0
    646  1c2f		       84 4a		      sty	MATHSTACKPTR
    647  1c31		       ac 17 2e 	      ldy	rtemp1
    648  1c34		       18		      clc
    649  1c35		       60		      rts
    650  1c36
    651  1c36							;
    652  1c36							;=====================================================
    653  1c36							; This pops TOS and places it in R1.
    654  1c36							;
    655  1c36		       8c 17 2e    popR1      sty	rtemp1
    656  1c39		       a4 4a		      ldy	MATHSTACKPTR
    657  1c3b		       f0 bf		      beq	poperr
    658  1c3d		       88		      dey
    659  1c3e		       b1 48		      lda	(MATHSTACK),y
    660  1c40		       85 55		      sta	R1+1
    661  1c42		       88		      dey
    662  1c43		       b1 48		      lda	(MATHSTACK),y
    663  1c45		       85 54		      sta	R1
    664  1c47		       84 4a		      sty	MATHSTACKPTR
    665  1c49		       ac 17 2e 	      ldy	rtemp1
    666  1c4c		       60		      rts
    667  1c4d							;
    668  1c4d							;=====================================================
    669  1c4d							; This pops TOS and places it in MQ.
    670  1c4d							;
    671  1c4d		       8c 17 2e    popMQ      sty	rtemp1
    672  1c50		       a4 4a		      ldy	MATHSTACKPTR
    673  1c52		       f0 a8		      beq	poperr
    674  1c54		       88		      dey
    675  1c55		       b1 48		      lda	(MATHSTACK),y
    676  1c57		       85 57		      sta	MQ+1
    677  1c59		       88		      dey
    678  1c5a		       b1 48		      lda	(MATHSTACK),y
    679  1c5c		       85 56		      sta	MQ
    680  1c5e		       84 4a		      sty	MATHSTACKPTR
    681  1c60		       ac 17 2e 	      ldy	rtemp1
    682  1c63		       60		      rts
    683  1c64							;
    684  1c64							;=====================================================
    685  1c64							; This assists with multiplication and division by
    686  1c64							; looking at R0 and R1 and saving a flag as to what
    687  1c64							; sign the result will be.  Math is always done on
    688  1c64							; positive numbers, so this converts negative numbers
    689  1c64							; into positives.  On exit, R0 and R1 are both
    690  1c64							; positive.  If the signs were different then 'signs'
    691  1c64							; will be non-zero.
    692  1c64							;
    693  1c64		       a9 00	   SaveSigns  lda	#0
    694  1c66		       8d 16 2e 	      sta	sign	;assume positive
    695  1c69		       a5 53		      lda	R0+1	;MSB
    696  1c6b		       10 13		      bpl	SaveSigns1
    697  1c6d		       ee 16 2e 	      inc	sign	;it's negative
    698  1c70		       49 ff		      eor	#$ff	;flip bits
    699  1c72		       85 53		      sta	R0+1
    700  1c74		       a5 52		      lda	R0
    701  1c76		       49 ff		      eor	#$ff
    702  1c78		       85 52		      sta	R0
    703  1c7a		       e6 52		      inc	R0
    704  1c7c		       d0 02		      bne	SaveSigns1
    705  1c7e		       e6 53		      inc	R0+1
    706  1c80		       a5 55	   SaveSigns1 lda	R1+1
    707  1c82		       10 1a		      bpl	SaveSigns2
    708  1c84		       48		      pha
    709  1c85		       ad 16 2e 	      lda	sign
    710  1c88		       49 01		      eor	#1
    711  1c8a		       8d 16 2e 	      sta	sign
    712  1c8d		       68		      pla
    713  1c8e		       49 ff		      eor	#$ff	;flip bits
    714  1c90		       85 55		      sta	R1+1
    715  1c92		       a5 54		      lda	R1
    716  1c94		       49 ff		      eor	#$ff
    717  1c96		       85 54		      sta	R1
    718  1c98		       e6 54		      inc	R1
    719  1c9a		       d0 02		      bne	SaveSigns2
    720  1c9c		       e6 55		      inc	R1+1
    721  1c9e		       60	   SaveSigns2 rts
    722  1c9f							;
    723  1c9f							;=====================================================
    724  1c9f							; This looks at the value of 'signs' and will convert
    725  1c9f							; both R0 and R1 to negative if set.
    726  1c9f							;
    727  1c9f				   RestoreSigns
    728  1c9f		       ad 16 2e 	      lda	sign
    729  1ca2		       f0 28		      beq	restoresigns2
    730  1ca4							;
    731  1ca4		       a5 52		      lda	R0
    732  1ca6		       d0 02		      bne	restoresigns3
    733  1ca8		       c6 53		      dec	R0+1
    734  1caa				   restoresigns3
    735  1caa		       c6 52		      dec	R0
    736  1cac		       a5 52		      lda	R0
    737  1cae		       49 ff		      eor	#$ff
    738  1cb0		       85 52		      sta	R0
    739  1cb2		       a5 53		      lda	R0+1
    740  1cb4		       49 ff		      eor	#$ff
    741  1cb6		       85 53		      sta	R0+1
    742  1cb8							;
    743  1cb8		       a5 54		      lda	R1
    744  1cba		       d0 02		      bne	restoresigns4
    745  1cbc		       c6 55		      dec	R1+1
    746  1cbe				   restoresigns4
    747  1cbe		       c6 54		      dec	R1
    748  1cc0		       a5 54		      lda	R1
    749  1cc2		       49 ff		      eor	#$ff
    750  1cc4		       85 54		      sta	R1
    751  1cc6		       a5 55		      lda	R1+1
    752  1cc8		       49 ff		      eor	#$ff
    753  1cca		       85 55		      sta	R1+1
    754  1ccc							;
    755  1ccc				   restoresigns2
    756  1ccc		       60		      rts
    757  1ccd							;
    758  1ccd							;=====================================================
    759  1ccd							; Skip over spaces.  Returns Y with the offset to
    760  1ccd							; either the last character in the line, or the first
    761  1ccd							; non-space character.
    762  1ccd							;
    763  1ccd
    764  1ccd		       c8	   skipsp2    iny
    765  1cce		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  1cd0		       f0 04		      beq	Skip3	;end of line
    767  1cd2		       c9 20		      cmp	#SPACE
    768  1cd4		       f0 f7		      beq	skipsp2
    769  1cd6		       60	   Skip3      rts
    770  1cd7							;*********************************************************
    771  1cd7							; Output a CR/LF combination to the console.  Preserves
    772  1cd7							; all registers.
    773  1cd7							;
    774  1cd7		       48	   tbcrlf     pha
    775  1cd8		       a9 0d		      lda	#CR
    776  1cda		       20 20 1e 	      jsr	VOUTCH
    777  1cdd		       a9 0a		      lda	#LF
    778  1cdf		       20 20 1e 	      jsr	VOUTCH
    779  1ce2		       68		      pla
    780  1ce3		       60		      rts
    781  1ce4							;
    782  1ce4							;=====================================================
    783  1ce4							; Some logic to print the Line of basic code being executed
    784  1ce4		       24 40	   idbgBasic  bit	ILTrace
    785  1ce6		       50 70		      bvc	dbgBasicNone
    786  1ce8		       98		      tya
    787  1ce9		       48		      pha
    788  1cea		       20 54 1e 	      jsr	SetOutDebug
    789  1ced		       20 70 14 	      jsr	PrtPrgLine
    790  1cf0		       20 d7 1c 	      jsr	CRLF
    791  1cf3		       a5 40		      lda	ILTrace
    792  1cf5		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  1cf7		       f0 5a		      beq	dbgBasicDone
    794  1cf9		       20 6b 1e 	      jsr	SetInDebug
    795  1cfc		       20 4d 14 	      jsr	puts
      0  1cff					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1cff		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1d3c				   dbgBasicLoop
    798  1d3c		       20 23 1e 	      jsr	VGETCH
    799  1d3f		       20 d7 1c 	      jsr	CRLF
    800  1d42		       20 8f 1e 	      jsr	SetInDebugEnd
    801  1d45
    802  1d45		       c9 73		      cmp	#'s	; Quit program
    803  1d47		       f0 12		      beq	dbgBasicStop
    804  1d49
    805  1d49		       c9 64		      cmp	#'d	; Display Variables
    806  1d4b		       d0 06		      bne	dbgBasicDone
    807  1d4d
    808  1d4d		       20 af 14 	      jsr	PrintAllVars
    809  1d50		       18		      clc
    810  1d51		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1d53
    812  1d53		       20 82 1e    dbgBasicDone jsr	SetOutDebugEnd
    813  1d56		       68		      pla
    814  1d57		       a8		      tay
    815  1d58		       4c c2 02    dbgBasicNone jmp	NextIL
    816  1d5b
    817  1d5b				   dbgBasicStop
    818  1d5b		       20 82 1e 	      jsr	SetOutDebugEnd
    819  1d5e		       68		      pla
    820  1d5f		       a8		      tay
    821  1d60		       4c 00 06 	      jmp	iFIN
    822  1d63							;
    823  1d63							;=====================================================
    824  1d63							; This is some debug logic which displays the current
    825  1d63							; value of the ILPC and the line buffer.
    826  1d63							;
    827  1d63		       24 40	   dbgLine    bit	ILTrace
    828  1d65		       30 01		      bmi	dbgPrt
    829  1d67		       60		      rts
    830  1d68				   dbgPrt
    831  1d68		       20 54 1e 	      jsr	SetOutDebug
    832  1d6b		       20 4d 14 	      jsr	puts
      0  1d6e					      db	"ILPC: ",0
      1  1d6e		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  1d75		       a5 44		      lda	ILPC+1
    835  1d77		       20 30 14 	      jsr	OUTHEX
    836  1d7a		       a5 43		      lda	ILPC
    837  1d7c		       20 30 14 	      jsr	OUTHEX
    838  1d7f		       a9 20		      lda	#SPACE
    839  1d81		       20 20 1e 	      jsr	VOUTCH
    840  1d84		       a0 00		      ldy	#0
    841  1d86		       b1 43		      lda	(ILPC),y
    842  1d88		       20 30 14 	      jsr	OUTHEX
    843  1d8b							;
    844  1d8b							; Display the CURPTR value and offset
    845  1d8b							;
    846  1d8b		       20 4d 14 	      jsr	puts
      0  1d8e					      db	", CURPTR: ",0
      1  1d8e		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  1d99		       a5 50		      lda	CURPTR+1
    849  1d9b		       20 30 14 	      jsr	OUTHEX
    850  1d9e		       a5 4f		      lda	CURPTR
    851  1da0		       20 30 14 	      jsr	OUTHEX
    852  1da3		       a9 2b		      lda	#'+
    853  1da5		       20 20 1e 	      jsr	VOUTCH
    854  1da8		       a5 51		      lda	CUROFF
    855  1daa		       20 30 14 	      jsr	OUTHEX
    856  1dad							;
    857  1dad		       20 d7 1c 	      jsr	CRLF
    858  1db0		       20 82 1e 	      jsr	SetOutDebugEnd
    859  1db3		       20 e6 1d 	      jsr	ILChkRange
    860  1db6		       b0 02		      bcs	dbgLineErr
    861  1db8		       18		      clc
    862  1db9		       60		      rts
    863  1dba
    864  1dba				   dbgLineErr
    865  1dba		       20 54 1e 	      jsr	SetOutDebug
    866  1dbd		       20 4d 14 	      jsr	puts
      0  1dc0					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1dc0		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  1de1		       20 82 1e 	      jsr	SetOutDebugEnd
    869  1de4		       38		      sec
    870  1de5		       60		      rts
    871  1de6
    872  1de6		       a5 44	   ILChkRange lda	ILPC+1
    873  1de8		       c9 20		      cmp	#IL>>8
    874  1dea		       90 18		      bcc	ILBadRange
    875  1dec		       d0 06		      bne	ILChkHigh
    876  1dee
    877  1dee		       a5 43		      lda	ILPC
    878  1df0		       c9 bf		      cmp	#IL&$ff
    879  1df2		       90 10		      bcc	ILBadRange
    880  1df4
    881  1df4		       a5 44	   ILChkHigh  lda	ILPC+1
    882  1df6		       c9 24		      cmp	#ILEND>>8
    883  1df8		       90 08		      bcc	ILGoodRange
    884  1dfa		       d0 08		      bne	ILBadRange
    885  1dfc
    886  1dfc		       a5 43		      lda	ILPC
    887  1dfe		       c9 87		      cmp	#ILEND&$ff
    888  1e00		       b0 02		      bcs	ILBadRange
    889  1e02
    890  1e02		       18	   ILGoodRange clc
    891  1e03		       60		      rts
    892  1e04				   ILBadRange
    893  1e04		       38		      sec
    894  1e05		       60		      rts
    895  1e06
    896  1e06
    897  1e06							;=====================================================
    898  1e06							; Set output vector to the console output function
    899  1e06							;
    900  1e06				   SetOutConsole
    901  1e06		       48		      pha
    902  1e07		       a9 0c		      lda	#OUTCH&$ff
    903  1e09		       8d 1b 2e 	      sta	BOutVec
    904  1e0c		       a9 f0		      lda	#OUTCH>>8
    905  1e0e		       8d 1c 2e 	      sta	BOutVec+1
    906  1e11		       68		      pla
    907  1e12		       60		      rts
    908  1e13
    909  1e13				   SetInConsole
    910  1e13		       48		      pha
    911  1e14		       a9 09		      lda	#GETCH&$ff
    912  1e16		       8d 1d 2e 	      sta	BInVec
    913  1e19		       a9 f0		      lda	#GETCH>>8
    914  1e1b		       8d 1e 2e 	      sta	BInVec+1
    915  1e1e		       68		      pla
    916  1e1f		       60		      rts
    917  1e20
    918  1e20							;=====================================================
    919  1e20							; Jump to the output/input function in BOutVec/BInVec
    920  1e20							;
    921  1e20		       6c 1b 2e    VOUTCH     jmp	(BOutVec)
    922  1e23		       6c 1d 2e    VGETCH     jmp	(BInVec)
    923  1e26
    924  1e26
    925  1e26							;====================================================
    926  1e26							;Clear the terminal assume it is ansii or vt100
    927  1e26							;
    928  1e26				   iCLEARSCREEN
    929  1e26		       20 4d 14 	      jsr	puts
      0  1e29					      db	$1b,'[,'2,'J,0
      1  1e29		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    931  1e2e		       4c c2 02 	      jmp	NextIL
    932  1e31
    933  1e31							;====================================================
    934  1e31							; Push true and false onto math stack
    935  1e31				   pushTrue
    936  1e31		       a9 ff		      lda	#$ff
    937  1e33		       85 52	   pushTF     sta	R0
    938  1e35		       85 53		      sta	R0+1
    939  1e37		       20 9a 1b 	      jsr	pushR0
    940  1e3a		       60		      rts
    941  1e3b		       a9 00	   pushFalse  lda	#0
    942  1e3d		       f0 f4		      beq	pushTF
    943  1e3f
    944  1e3f							;======================================================
    945  1e3f							; Copy stack top to R1
    946  1e3f				   CopyStackR1
    947  1e3f		       98		      tya
    948  1e40		       48		      pha
    949  1e41		       a4 4a		      ldy	MATHSTACKPTR
    950  1e43		       88		      dey
    951  1e44		       b1 48		      lda	(MATHSTACK),y
    952  1e46		       85 55		      sta	R1+1
    953  1e48		       88		      dey
    954  1e49		       b1 48		      lda	(MATHSTACK),y
    955  1e4b		       85 54		      sta	R1
    956  1e4d		       68		      pla
    957  1e4e		       a8		      tay
    958  1e4f		       60		      rts
    959  1e50
    960  1e50
    961  1e50							;====================================================
    962  1e50							;Swap the out debug call for standard calls
    963  1e50					      if	USEDEBUGPORT
    964  1e50		       00 00	   DebugIOSave ds	2
    965  1e52		       00 00	   DebugInSave ds	2
    966  1e54					      endif
    967  1e54				   SetOutDebug
    968  1e54					      if	USEDEBUGPORT
    969  1e54		       ad 1b 2e 	      lda	BOutVec
    970  1e57		       8d 50 1e 	      sta	DebugIOSave
    971  1e5a		       ad 1c 2e 	      lda	BOutVec+1
    972  1e5d		       8d 51 1e 	      sta	DebugIOSave+1
    973  1e60		       a9 a6		      lda	#OUTDEBUG&$ff	; Put the Debug output
    974  1e62		       8d 1b 2e 	      sta	BOutVec
    975  1e65		       a9 1e		      lda	#OUTDEBUG>>8
    976  1e67		       8d 1c 2e 	      sta	BOutVec+1
    977  1e6a					      endif
    978  1e6a		       60		      rts
    979  1e6b				   SetInDebug
    980  1e6b					      if	USEDEBUGPORT
    981  1e6b		       ad 1d 2e 	      lda	BInVec
    982  1e6e		       8d 52 1e 	      sta	DebugInSave
    983  1e71		       ad 1e 2e 	      lda	BInVec+1
    984  1e74		       8d 53 1e 	      sta	DebugInSave+1
    985  1e77		       a9 aa		      lda	#INDEBUG&$ff
    986  1e79		       8d 1d 2e 	      sta	BInVec
    987  1e7c		       a9 1e		      lda	#INDEBUG>>8
    988  1e7e		       8d 1e 2e 	      sta	BInVec+1
    989  1e81					      endif
    990  1e81		       60		      rts
    991  1e82				   SetOutDebugEnd
    992  1e82					      if	USEDEBUGPORT
    993  1e82		       ad 50 1e 	      lda	DebugIOSave
    994  1e85		       8d 1b 2e 	      sta	BOutVec
    995  1e88		       ad 51 1e 	      lda	DebugIOSave+1
    996  1e8b		       8d 1c 2e 	      sta	BOutVec+1
    997  1e8e					      endif
    998  1e8e		       60		      rts
    999  1e8f				   SetInDebugEnd
   1000  1e8f					      if	USEDEBUGPORT
   1001  1e8f		       ad 52 1e 	      lda	DebugInSave
   1002  1e92		       8d 1d 2e 	      sta	BInVec
   1003  1e95		       ad 51 1e 	      lda	DebugIOSave+1
   1004  1e98		       8d 1e 2e 	      sta	BInVec+1
   1005  1e9b					      endif
   1006  1e9b		       60		      rts
   1007  1e9c							;
   1008  1e9c							;====================================================
   1009  1e9c							; Output to the debug console
   1010  1e9c							;     x = high address byte
   1011  1e9c							;     y = low address byte
   1012  1e9c							;     a = Terminator for string
   1013  1e9c				   DebugWrite
   1014  1e9c		       20 54 1e 	      jsr	SetOutDebug
   1015  1e9f		       20 92 14 	      jsr	PrtStr
   1016  1ea2		       20 82 1e 	      jsr	SetOutDebugEnd
   1017  1ea5		       60		      rts
   1018  1ea6
   1019  1ea6				   OUTDEBUG
   1020  1ea6		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1021  1ea9		       60		      RTS
   1022  1eaa
   1023  1eaa		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1024  1ead		       29 01		      and	#$01
   1025  1eaf		       f0 f9		      beq	INDEBUG
   1026  1eb1		       ad 21 e0 	      lda	DEBUGPORT+1
   1027  1eb4		       60		      rts
   1028  1eb5
   1029  1eb5							;======================================================================
   1030  1eb5							;Copy Quoted string to buffer, terminate with 0 byte
   1031  1eb5							; R0  Source tring points to tString type
   1032  1eb5							; x is terminator
   1033  1eb5							; R1 points to destinition location
   1034  1eb5							; On exit R0 contains length of copy Plus Term and leading bytes
   1035  1eb5
   1036  1eb5				   qstrcpy
   1037  1eb5		       20 9a 1b 	      jsr	pushR0
   1038  1eb8		       20 05 1f 	      jsr	IncR0	; point past the tString
   1039  1ebb		       20 05 1f 	      jsr	IncR0	; Point Past the opening "
   1040  1ebe		       a2 22		      ldx	#'"	; copy Termination
   1041  1ec0		       20 da 1e 	      jsr	pstrcpy
   1042  1ec3		       20 05 1f 	      jsr	IncR0	; point to "
   1043  1ec6		       20 05 1f 	      jsr	IncR0	; Point to next free byte
   1044  1ec9		       20 36 1c 	      jsr	popR1
   1045  1ecc		       38		      sec
   1046  1ecd		       a5 52		      lda	R0
   1047  1ecf		       e5 54		      sbc	R1
   1048  1ed1		       85 52		      sta	R0
   1049  1ed3		       a5 53		      lda	R0+1
   1050  1ed5		       e5 55		      sbc	R1+1
   1051  1ed7		       85 53		      sta	R0+1
   1052  1ed9		       60		      rts
   1053  1eda
   1054  1eda							;=========================================================================
   1055  1eda							;Copy string from R0 to R1, terminator in x
   1056  1eda							; On exit    R0 contains the length of the copy
   1057  1eda				   pstrcpy
   1058  1eda		       a0 00		      ldy	#0
   1059  1edc		       86 58		      stx	R2
   1060  1ede
   1061  1ede				   strcpyLoop
   1062  1ede		       b1 52		      lda	(R0),y
   1063  1ee0		       c5 58		      cmp	R2
   1064  1ee2		       f0 0a		      beq	strcpyDone
   1065  1ee4		       91 54		      sta	(R1),y
   1066  1ee6		       20 05 1f 	      jsr	IncR0
   1067  1ee9		       20 f3 1e 	      jsr	IncR1
   1068  1eec		       90 f0		      bcc	strcpyLoop
   1069  1eee				   strcpyDone
   1070  1eee		       a9 00		      lda	#0
   1071  1ef0		       91 54		      sta	(R1),y
   1072  1ef2
   1073  1ef2		       60		      rts
   1074  1ef3
   1075  1ef3							;=========================================================================
   1076  1ef3							; on exit c is set on overflow
   1077  1ef3				   IncR1
   1078  1ef3		       48		      pha
   1079  1ef4		       18		      clc
   1080  1ef5		       a9 01		      lda	#1
   1081  1ef7		       65 54		      adc	R1
   1082  1ef9		       85 54		      sta	R1
   1083  1efb		       90 06		      bcc	IncR1Done
   1084  1efd		       a9 00		      lda	#0
   1085  1eff		       65 55		      adc	R1+1
   1086  1f01		       85 55		      sta	R1+1
   1087  1f03				   IncR1Done
   1088  1f03		       68		      pla
   1089  1f04		       60		      rts
   1090  1f05							;=========================================================================
   1091  1f05							; on exit c is set on overflow
   1092  1f05				   IncR0
   1093  1f05		       48		      pha
   1094  1f06		       18		      clc
   1095  1f07		       a9 01		      lda	#1
   1096  1f09		       65 52		      adc	R0
   1097  1f0b		       85 52		      sta	R0
   1098  1f0d		       90 06		      bcc	IncR0Done
   1099  1f0f		       a9 00		      lda	#0
   1100  1f11		       65 53		      adc	R0+1
   1101  1f13		       85 53		      sta	R0+1
   1102  1f15				   IncR0Done
   1103  1f15		       68		      pla
   1104  1f16		       60		      rts
   1105  1f17
   1106  1f17
   1107  1f17
   1108  1f17
   1109  1f17
   1110  1f17
   1111  1f17
   1112  1f17
   1113  1f17
   1114  1f17
   1115  1f17
   1116  1f17
   1117  1f17
   1118  1f17
   1119  1f17
   1120  1f17
------- FILE mytb.asm
   2309  1f17
   2310  1f17					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  1f17					      include	"storage.asm"
      1  1f17							;
      2  1f17							;=====================================================
      3  1f17							;=====================================================
      4  1f17							;=====================================================
      5  1f17							; This file contains the functions for saving and
      6  1f17							; restoring programs from some sort of mass storage
      7  1f17							; device.  This particular version is for using the
      8  1f17							; Corsham Tech SD Card System.
      9  1f17							;=====================================================
     10  1f17							;=====================================================
     11  1f17							;=====================================================
     12  1f17
     13 U2487					      seg.u	TBData
     14 U2487		       00	   diskBufLength ds	1
     15 U2488		       00	   diskBufOffset ds	1
     16 U2489		       00 00 00 00*DiskFileName ds	64
     17 U24c9
     18  1f17					      SEG	Code
     19  1f17
     20  1f17							;
     21  1f17							;=====================================================
     22  1f17							; Open a file for reading as a program.  The next
     23  1f17							; thing on the line should be the filename.
     24  1f17							;
     25  1f17				   iOPENREAD
     26  1f17					      if	XKIM || CTMON65
     27  1f17		       20 31 1f 	      jsr	setFileName	;Set the file name to open
     28  1f1a		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  1f1d		       90 07		      bcc	Ropenok	;branch if opened ok
     30  1f1f							;
     31  1f1f							; Open failed
     32  1f1f							;
     33  1f1f		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  1f21		       a9 00	   Rdfail2    lda	#0
     35  1f23		       4c 17 06 	      jmp	iErr2
     36  1f26							;
     37  1f26							; Clear counts and offsets so the next read will
     38  1f26							; cause the file to be read.
     39  1f26							;
     40  1f26		       a9 00	   Ropenok    lda	#0
     41  1f28		       8d 88 24 	      sta	diskBufOffset
     42  1f2b		       8d 87 24 	      sta	diskBufLength
     43  1f2e		       4c c2 02 	      jmp	NextIL
     44  1f31					      endif
     45  1f31
     46  1f31							;===============================================================
     47  1f31							; Set file name
     48  1f31				   setFileName
     49  1f31		       a4 51		      ldy	CUROFF
     50  1f33		       b1 4f		      lda	(CURPTR),y
     51  1f35		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  1f37		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  1f39
     54  1f39		       18		      clc
     55  1f3a		       98		      tya
     56  1f3b		       65 4f		      adc	CURPTR
     57  1f3d		       85 52		      sta	R0	;LSB
     58  1f3f		       a5 50		      lda	CURPTR+1
     59  1f41		       69 00		      adc	#0
     60  1f43		       85 53		      sta	R0+1
     61  1f45		       a9 89		      lda	#DiskFileName&$ff
     62  1f47		       85 54		      sta	R1
     63  1f49		       a9 24		      lda	#DiskFileName>>8
     64  1f4b		       85 55		      sta	R1+1
     65  1f4d		       20 b5 1e 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  1f50		       a5 52		      lda	R0
     67  1f52		       18		      clc
     68  1f53		       65 51		      adc	CUROFF	; add the current offset
     69  1f55		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  1f57
     71  1f57		       a0 89		      ldy	#DiskFileName&$ff
     72  1f59		       a2 24		      ldx	#DiskFileName>>8
     73  1f5b		       18		      clc
     74  1f5c		       60		      rts
     75  1f5d
     76  1f5d				   setFileNameNotFound
     77  1f5d		       68		      pla
     78  1f5e		       68		      pla		; remove the return address from the stack
     79  1f5f		       a9 00		      lda	#0
     80  1f61		       a2 09		      ldx	#ERR_NO_FILENAME
     81  1f63		       4c 17 06 	      jmp	iErr2
     82  1f66
     83  1f66							;
     84  1f66							;==============================JUSTLOSTINTIME 08/02/2022========
     85  1f66							;Remove a file from the disk
     86  1f66				   iRMFILE
     87  1f66					      if	XKIM || CTMON65
     88  1f66		       20 31 1f 	      jsr	setFileName
     89  1f69		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  1f6c		       90 07		      bcc	wrmOk	;branch if removed ok
     91  1f6e		       a9 00		      lda	#0
     92  1f70		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  1f72		       4c 17 06 	      jmp	iErr2
     94  1f75				   wrmOk
     95  1f75		       4c c2 02 	      jmp	NextIL
     96  1f78
     97  1f78					      endif
     98  1f78							;
     99  1f78							;=====================================================
    100  1f78				   iOPENWRITE
    101  1f78					      if	XKIM || CTMON65
    102  1f78		       20 31 1f 	      jsr	setFileName
    103  1f7b		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  1f7e		       90 07		      bcc	Wopenok	;branch if opened ok
    105  1f80							;
    106  1f80							; Open failed
    107  1f80							;
    108  1f80		       a9 00	   Wdfail     lda	#0
    109  1f82		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  1f84		       4c 17 06 	      jmp	iErr2
    111  1f87							;
    112  1f87		       4c c2 02    Wopenok    jmp	NextIL
    113  1f8a					      endif
    114  1f8a							;
    115  1f8a							;=====================================================
    116  1f8a							; Gets a line of input from the disk file and puts it
    117  1f8a							; into LINBUF.
    118  1f8a							;
    119  1f8a							; On exit:
    120  1f8a							;    CURPTR points to LINBUF
    121  1f8a							;    LINBUF contains the line with 0 at the end.
    122  1f8a							;    Y has offset to first non-space character
    123  1f8a							;    CURROFF has the same as Y.
    124  1f8a							;
    125  1f8a				   iDGETLINE
    126  1f8a					      if	XKIM || CTMON65
    127  1f8a		       a2 8a		      ldx	#LINBUF&$ff
    128  1f8c		       86 4f		      stx	CURPTR
    129  1f8e		       a2 2d		      ldx	#LINBUF>>8
    130  1f90		       86 50		      stx	CURPTR+1
    131  1f92							;
    132  1f92		       a2 00		      ldx	#0	;offset
    133  1f94		       8e 0e 2e    iDgetLoop  stx	getlinx
    134  1f97		       20 02 20 	      jsr	getNextFileByte
    135  1f9a		       b0 16		      bcs	iGetEOF
    136  1f9c		       c9 0d		      cmp	#CR
    137  1f9e		       f0 0d		      beq	iGetEOL
    138  1fa0		       c9 0a		      cmp	#LF
    139  1fa2		       f0 09		      beq	iGetEOL
    140  1fa4		       ae 0e 2e 	      ldx	getlinx
    141  1fa7		       9d 8a 2d 	      sta	LINBUF,x
    142  1faa		       e8		      inx
    143  1fab		       d0 e7		      bne	iDgetLoop
    144  1fad							;
    145  1fad							; Handle end of line.	If the line has nothing, loop
    146  1fad							; back and get another line.
    147  1fad							;
    148  1fad		       ae 0e 2e    iGetEOL    ldx	getlinx	;blank line?
    149  1fb0		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  1fb2							;
    151  1fb2							; This can fall through when there is a line, or
    152  1fb2							; called directly when EOF is encountered.
    153  1fb2							;
    154  1fb2		       ae 0e 2e    iGetEOF    ldx	getlinx
    155  1fb5		       a9 00		      lda	#0
    156  1fb7		       9d 8a 2d 	      sta	LINBUF,x
    157  1fba		       a0 00		      ldy	#0
    158  1fbc		       20 ce 1c 	      jsr	SkipSpaces
    159  1fbf		       20 86 0f 	      jsr	ParseInputLine
    160  1fc2		       a9 83		      lda	#TOKENBUFFER&$ff
    161  1fc4		       85 4f		      sta	CURPTR
    162  1fc6		       a9 0e		      lda	#TOKENBUFFER>>8
    163  1fc8		       85 50		      sta	CURPTR+1
    164  1fca		       a9 01		      lda	#1
    165  1fcc		       85 51		      sta	CUROFF
    166  1fce		       4c c2 02 	      jmp	NextIL
    167  1fd1					      endif
    168  1fd1
    169  1fd1							;
    170  1fd1							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  1fd1							; DISK
    172  1fd1							;
    173  1fd1				   iDDIR
    174  1fd1					      if	XKIM || CTMON65
    175  1fd1		       20 30 f0 	      jsr	DiskDir
    176  1fd4							;
    177  1fd4							; Get/Display each entry
    178  1fd4							;
    179  1fd4		       a2 24	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  1fd6		       a0 89		      ldy	#DiskFileName&$ff
    181  1fd8		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  1fdb		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  1fdd		       20 4d 14 	      jsr	puts
      0  1fe0					      db	"   ",0
      1  1fe0		       20 20 20 00	      .byte.b	"   ",0
    185  1fe4							; Print the line to the console
    186  1fe4		       a2 24		      ldx	#DiskFileName>>8	;pointer to buffer
    187  1fe6		       a0 89		      ldy	#DiskFileName&$ff
    188  1fe8		       a5 00		      lda	0
    189  1fea		       20 92 14 	      jsr	PrtStr	;else print name
    190  1fed		       20 18 f0 	      jsr	crlf
    191  1ff0
    192  1ff0		       4c d4 1f 	      jmp	DiskDirLoop	;do next entry
    193  1ff3
    194  1ff3		       4c c2 02    DiskDirEnd jmp	NextIL
    195  1ff6					      endif
    196  1ff6							;
    197  1ff6							;=====================================================
    198  1ff6							; Does a LIST to a Disk file.
    199  1ff6							;
    200  1ff6				   iDLIST
    201  1ff6					      if	XKIM || CTMON65
    202  1ff6		       20 31 20 	      jsr	SetOutDisk
    203  1ff9		       4c e7 07 	      jmp	iLST2
    204  1ffc					      endif
    205  1ffc							;
    206  1ffc							;=====================================================
    207  1ffc							; Closes any pending disk file.  Okay to call if there
    208  1ffc							; is no open file.
    209  1ffc							;
    210  1ffc				   iDCLOSE
    211  1ffc					      if	XKIM || CTMON65
    212  1ffc		       20 42 f0 	      jsr	DiskClose
    213  1fff		       4c c2 02 	      jmp	NextIL
    214  2002					      endif
    215  2002							;
    216  2002							;=====================================================
    217  2002							; This gets the next byte from an open disk file.  If
    218  2002							; there are no more bytes left, this returns C set.
    219  2002							; Else, C is clear and A contains the character.
    220  2002							;
    221  2002				   getNextFileByte
    222  2002					      if	XKIM || CTMON65
    223  2002		       ae 88 24 	      ldx	diskBufOffset
    224  2005		       ec 87 24 	      cpx	diskBufLength
    225  2008		       d0 14		      bne	hasdata	;branch if still data
    226  200a							;
    227  200a							; There is no data left in the buffer, so read a
    228  200a							; block from the SD system.
    229  200a							;
    230  200a		       a9 84		      lda	#BUFFER_SIZE
    231  200c		       a2 df		      ldx	#buffer>>8
    232  200e		       a0 0a		      ldy	#buffer&$ff
    233  2010		       20 3c f0 	      jsr	DiskRead
    234  2013		       b0 12		      bcs	getNextEof
    235  2015							;
    236  2015							; A contains the number of bytes actually read.
    237  2015							;
    238  2015		       8d 87 24 	      sta	diskBufLength	;save length
    239  2018		       c9 00		      cmp	#0	;shouldn't happen
    240  201a		       f0 0b		      beq	getNextEof
    241  201c							;
    242  201c		       a2 00		      ldx	#0
    243  201e		       bd 0a df    hasdata    lda	buffer,x
    244  2021		       e8		      inx
    245  2022		       8e 88 24 	      stx	diskBufOffset
    246  2025		       18		      clc
    247  2026		       60		      rts
    248  2027							;
    249  2027		       a9 00	   getNextEof lda	#0
    250  2029		       8d 88 24 	      sta	diskBufOffset
    251  202c		       8d 87 24 	      sta	diskBufLength
    252  202f		       38		      sec
    253  2030		       60		      rts
    254  2031							;
    255  2031							;=====================================================
    256  2031							; Set output vector to the disk output function
    257  2031							;
    258  2031		       a9 3c	   SetOutDisk lda	#DOUT&$ff
    259  2033		       8d 1b 2e 	      sta	BOutVec
    260  2036		       a9 20		      lda	#DOUT/256
    261  2038		       8d 1c 2e 	      sta	BOutVec+1
    262  203b		       60		      rts
    263  203c							;
    264  203c							;=====================================================
    265  203c
    266  203c		       8e 89 24    DOUT       stx	DiskFileName
    267  203f		       8c 8a 24 	      sty	DiskFileName+1
    268  2042		       8d 0a df 	      sta	buffer
    269  2045		       a9 01		      lda	#1
    270  2047		       a0 0a		      ldy	#buffer&$ff
    271  2049		       a2 df		      ldx	#buffer>>8
    272  204b		       20 3f f0 	      jsr	DiskWrite
    273  204e		       ae 89 24 	      ldx	DiskFileName
    274  2051		       ac 8a 24 	      ldy	DiskFileName+1
    275  2054
    276  2054							;
    277  2054							; need error checking here
    278  2054							;
    279  2054		       60		      rts
    280  2055					      endif
    281  2055
    282  2055
------- FILE mytb.asm
   2312  2055					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  2055					      include	"IL.inc"
      1  2055
      2  2055							;=====================================================
      3  2055							; IL.inc
      4  2055							; These are macros for IL instructions
      5  2055							;
      6  2055					      mac	dw
      7  2055					      .word	{0}
      8  2055					      endm
      9  2055					      mac	db
     10  2055					      .byte	{0}
     11  2055					      endm
     12  2055					      macro	xinit
     13  2055					      db	0
     14  2055					      endm		;reset the il to start clear all
     15  2055							;
     16  2055					      macro	done
     17  2055					      db	1
     18  2055					      endm		;print an error if not end of line
     19  2055							;
     20  2055					      macro	prs
     21  2055					      db	2
     22  2055					      endm		;print a quoted string
     23  2055							;
     24  2055					      macro	prn
     25  2055					      db	3
     26  2055					      endm		;print a number
     27  2055							;
     28  2055					      macro	spc
     29  2055					      db	4
     30  2055					      endm		;print space til new tabstop
     31  2055							;
     32  2055					      macro	nline
     33  2055					      db	5
     34  2055					      endm		;print a new line crlf
     35  2055							;
     36  2055							; My NXT is a bit different in that it takes one
     37  2055							; parameter, which is an address.  If the BASIC
     38  2055							; program is currently running then move to the
     39  2055							; next line and continue execution.  However, if
     40  2055							; in direct mode, jump to the specified IL label.
     41  2055							;
     42  2055					      macro	nxt
     43  2055					      db	6
     44  2055					      dw	{1}	; addr
     45  2055					      endm		; addr
     46  2055							;
     47  2055					      macro	xfer
     48  2055					      db	7
     49  2055					      endm
     50  2055							;
     51  2055					      macro	sav
     52  2055					      db	8
     53  2055					      db	{1}
     54  2055					      endm
     55  2055							;
     56  2055					      macro	rstr
     57  2055					      db	9
     58  2055					      endm
     59  2055							;
     60  2055					      macro	cmpr
     61  2055					      db	10
     62  2055					      endm
     63  2055							;
     64  2055					      macro	innum
     65  2055					      db	11
     66  2055					      endm
     67  2055							;
     68  2055					      macro	fin
     69  2055					      db	12
     70  2055					      endm
     71  2055							;
     72  2055							; ERR is followed by an error number.	The error
     73  2055							; code is printed along with the line number.
     74  2055							; Control is passed to the statement set with
     75  2055							; the ERRGOTO statement.
     76  2055							;
     77  2055					      macro	errmsg
     78  2055					      db	13
     79  2055					      dw	{1}	;ecode
     80  2055					      endm		;ecode
     81  2055							;
     82  2055					      macro	add
     83  2055					      db	14
     84  2055					      endm
     85  2055							;
     86  2055					      macro	sub
     87  2055					      db	15
     88  2055					      endm
     89  2055							;
     90  2055					      macro	neg
     91  2055					      db	16
     92  2055					      endm
     93  2055							;
     94  2055					      macro	mul
     95  2055					      db	17
     96  2055					      endm
     97  2055							;
     98  2055					      macro	div
     99  2055					      db	18
    100  2055					      endm
    101  2055							;
    102  2055					      macro	store
    103  2055					      db	19
    104  2055					      endm
    105  2055							;
    106  2055					      macro	ind
    107  2055					      db	20
    108  2055					      endm
    109  2055							;
    110  2055					      macro	lst
    111  2055					      db	21
    112  2055					      endm
    113  2055							;
    114  2055					      macro	init
    115  2055					      db	22
    116  2055					      endm
    117  2055							;
    118  2055					      macro	getline
    119  2055					      db	23
    120  2055					      endm
    121  2055							;
    122  2055					      macro	insert
    123  2055					      db	24
    124  2055					      endm
    125  2055							;
    126  2055					      macro	rtn
    127  2055					      db	25
    128  2055					      endm
    129  2055							;
    130  2055					      macro	exit
    131  2055					      db	26
    132  2055					      endm
    133  2055							;
    134  2055					      macro	lit
    135  2055					      db	27
    136  2055					      dw	{1}	;value
    137  2055					      endm		; value LIT
    138  2055							;
    139  2055					      macro	call
    140  2055					      db	28
    141  2055					      dw	{1}	;addr
    142  2055					      endm		;addr
    143  2055							;
    144  2055							; IJMP will set the IL PC to the specified value.
    145  2055							;
    146  2055					      macro	ijmp
    147  2055					      db	29
    148  2055					      dw	{1}	;addr
    149  2055					      endm		;addr
    150  2055							;
    151  2055					      macro	vinit
    152  2055					      db	30
    153  2055					      endm
    154  2055							;
    155  2055							; ERRGOTO sets the point in the code where the IL
    156  2055							; interpreter will go after any error.
    157  2055							;
    158  2055					      macro	errgoto
    159  2055					      db	31
    160  2055					      dw	{1}	;addr
    161  2055					      endm		;addr
    162  2055							;
    163  2055					      macro	tst
    164  2055					      db	32
    165  2055					      db	({1}-*)-1	;(addr-*)-1
    166  2055					      db	{2},0	;string,0
    167  2055					      endm		;addr,string
    168  2055							;
    169  2055					      macro	tstv
    170  2055					      db	33
    171  2055					      db	({1}-*)-1	;(addr-*)-1
    172  2055					      endm		;addr
    173  2055							;
    174  2055					      macro	tstl
    175  2055					      db	34
    176  2055					      db	({1}-*)-1	;(addr-*)-1
    177  2055					      endm		;addr
    178  2055							;
    179  2055					      macro	tstn
    180  2055					      db	35
    181  2055					      db	({1}-*)-1	;(addr-*)-1
    182  2055					      endm		;addr
    183  2055							;
    184  2055							; FREE returns the amount of free RAM on top of
    185  2055							; the stack.  This is the amount of room the user
    186  2055							; program has available.
    187  2055							;
    188  2055					      macro	free
    189  2055					      db	36
    190  2055					      endm
    191  2055							;
    192  2055							; RANDOM takes the top item off the stack and
    193  2055							; replaces it with a random number that is
    194  2055							; MOD the initial value.  Ie, if the TOS is
    195  2055							; 42 then RANDOM returns a value from 0 to 41.
    196  2055							;
    197  2055					      macro	random
    198  2055					      db	37
    199  2055					      endm
    200  2055							;
    201  2055							; ABS will replace the top of stack with the
    202  2055							; absolute value.
    203  2055							;
    204  2055					      macro	abs
    205  2055					      db	38
    206  2055					      endm
    207  2055							;
    208  2055							; OPENREAD opens a file for reading, as in getting
    209  2055							; statements from it.
    210  2055							;
    211  2055					      macro	openread
    212  2055					      db	39
    213  2055					      endm
    214  2055							;
    215  2055							; OPENWRITE opens a file for writing, as in saving
    216  2055							; the current program to it.
    217  2055							;
    218  2055					      macro	openwrite
    219  2055					      db	40
    220  2055					      endm
    221  2055							;
    222  2055							; DCLOSE closes any open disk file.
    223  2055							;
    224  2055					      macro	dclose
    225  2055					      db	41
    226  2055					      endm
    227  2055							;
    228  2055							; DGETLINE gets one line from the disk file and puts it
    229  2055							; into LINBUFF.
    230  2055							;
    231  2055					      macro	dgetline
    232  2055					      db	42
    233  2055					      endm
    234  2055							;
    235  2055							; DLIST saves the program to an open disk file.
    236  2055							;
    237  2055					      macro	dlist
    238  2055					      db	43
    239  2055					      endm
    240  2055							; DDIR list the current directory
    241  2055							;
    242  2055					      macro	ddir
    243  2055					      db	44
    244  2055					      endm
    245  2055
    246  2055							; RMFILE remove a fle from disk
    247  2055					      macro	rmfile
    248  2055					      db	45
    249  2055					      endm
    250  2055
    251  2055							; CLEARSCREEN clear the screen
    252  2055					      macro	clearscreen
    253  2055					      db	46
    254  2055					      endm
    255  2055							; POKEMEM Poke value into memory
    256  2055					      macro	pokemem
    257  2055					      db	47
    258  2055					      endm
    259  2055							; PEEKMEM peek at value in memory
    260  2055					      macro	peekmem
    261  2055					      db	48
    262  2055					      endm
    263  2055							; TSTLET Test if the statement is a let without the keyword let
    264  2055					      macro	tstlet
    265  2055					      db	49
    266  2055					      db	({1}-*)-1	;(addr-*)-1
    267  2055					      endm		;addr
    268  2055							; TSTDONE if we reach the end of a statement
    269  2055					      macro	tstdone
    270  2055					      db	50
    271  2055					      db	({1}-*)-1	;(addr-*)-1
    272  2055					      endm		;addr
    273  2055							; GETCHAR	get a character from the input line leave it in RO
    274  2055					      macro	getchar
    275  2055					      db	51
    276  2055					      endm
    277  2055							; PUTCHAR	Put a character to the terminal
    278  2055					      macro	putchar
    279  2055					      db	52
    280  2055					      endm
    281  2055							; Call		Call a machine function return a to stack
    282  2055					      macro	callfunc
    283  2055					      db	53
    284  2055					      endm
    285  2055
    286  2055							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  2055					      macro	ibranch
    288  2055					      db	54
    289  2055					      endm
    290  2055
    291  2055							; TSTSTR	 Tests for the open quote in a string
    292  2055					      macro	tststr
    293  2055					      db	55
    294  2055					      db	({1}-*)-1	;(addr-*)-1
    295  2055					      endm
    296  2055							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  2055					      macro	setirq
    298  2055					      db	56
    299  2055					      endm
    300  2055
    301  2055							; TSTIRQ	Test for irq pending,
    302  2055							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  2055					      macro	tstirq
    304  2055					      db	57
    305  2055					      db	({1}-*)-1	;(addr-*)-1
    306  2055					      endm
    307  2055
    308  2055							; IRET    return from interupt service
    309  2055					      macro	iret
    310  2055					      db	58
    311  2055					      endm
    312  2055
    313  2055							; INSTR   read a string from the input
    314  2055					      macro	instr
    315  2055					      db	59
    316  2055					      endm
    317  2055
    318  2055							; MODULO Returns the remainder of the division
    319  2055					      macro	modulo
    320  2055					      db	60
    321  2055					      endm
    322  2055							; Set a task line
    323  2055					      macro	taskcreate
    324  2055					      db	61
    325  2055					      endm
    326  2055							; End a task
    327  2055					      macro	etask
    328  2055					      db	62
    329  2055					      endm
    330  2055							; Skip to next task
    331  2055					      macro	ntask
    332  2055					      db	63
    333  2055					      endm
    334  2055							; Subscript
    335  2055					      macro	subscript
    336  2055					      db	64
    337  2055					      endm
    338  2055							; KILL Task
    339  2055					      macro	taskkill
    340  2055					      db	65
    341  2055					      endm
    342  2055							; STAT Task
    343  2055					      macro	taskstat
    344  2055					      db	66
    345  2055					      endm
    346  2055							;  output value as hex
    347  2055					      macro	hexprt
    348  2055					      db	67
    349  2055					      endm
    350  2055							;  Read in background has completed
    351  2055					      macro	readcomplete
    352  2055					      db	68
    353  2055					      endm
    354  2055							;  ReadInput line
    355  2055					      macro	readstart
    356  2055					      db	69
    357  2055					      endm
    358  2055							; Startio request
    359  2055					      macro	startio
    360  2055					      db	70
    361  2055					      endm
    362  2055							; Endio
    363  2055					      macro	endio
    364  2055					      db	71
    365  2055					      endm
    366  2055							; Logical not
    367  2055					      macro	lognot
    368  2055					      db	72
    369  2055					      endm
    370  2055							; Logical OR
    371  2055					      macro	logor
    372  2055					      db	73
    373  2055					      endm
    374  2055							;Logical and
    375  2055					      macro	logand
    376  2055					      db	74
    377  2055					      endm
    378  2055							;Logical XOR
    379  2055					      macro	logxor
    380  2055					      db	75
    381  2055					      endm
    382  2055							;Wait for task to complete, or list of tasks
    383  2055					      macro	wtask
    384  2055					      db	76
    385  2055					      db	({1}-*)-1	;(addr-*)-1
    386  2055					      endm
    387  2055							;Get the current task id
    388  2055					      MACRO	taskpid
    389  2055					      db	77
    390  2055					      endm
    391  2055							;Trace the basic execution
    392  2055					      Macro	traceprogram
    393  2055					      db	78
    394  2055					      endm
    395  2055							;Do a basic program Trace
    396  2055					      Macro	debugbasic
    397  2055					      db	79
    398  2055					      endm
    399  2055
    400  2055							; Inter Process communications instructions
    401  2055					      Macro	ipcsend
    402  2055					      db	80
    403  2055					      endm
    404  2055					      Macro	ipcreceive
    405  2055					      db	81
    406  2055					      endm
    407  2055					      Macro	ipccheck
    408  2055					      db	82
    409  2055					      endm
    410  2055					      Macro	ipcio
    411  2055					      db	83
    412  2055					      endm
    413  2055					      Macro	pushmathstack
    414  2055					      db	84
    415  2055					      endm
    416  2055					      Macro	popmathstack
    417  2055					      db	85
    418  2055					      endm
    419  2055					      Macro	savemathstack
    420  2055					      db	86
    421  2055					      endm
    422  2055					      Macro	restoremathstack
    423  2055					      db	87
    424  2055					      endm
    425  2055					      Macro	incparmcount
    426  2055					      db	88
    427  2055					      endm
    428  2055					      Macro	taskgetmathstack
    429  2055					      db	89
    430  2055					      endm
    431  2055					      Macro	taskenable
    432  2055					      db	90
    433  2055					      endm
    434  2055					      Macro	tasksuspend
    435  2055					      db	91
    436  2055					      endm
    437  2055					      Macro	taskputmathptr
    438  2055					      db	92
    439  2055					      endm
    440  2055							; Test for an extension type of variable that allows access to a tasks variables
    441  2055							; Using  PID!<Var name>
    442  2055					      Macro	tstvt
    443  2055					      db	93
    444  2055					      db	({1}-*)-1	;(addr-*)-1
    445  2055					      endm
    446  2055
    447  2055							; Provide access to R2 for the IL program
    448  2055					      Macro	setr2
    449  2055					      db	94
    450  2055					      db	{1}	; R2 is only one byte
    451  2055					      endm
    452  2055							;Move stack top to temp
    453  2055					      Macro	stk2tmp
    454  2055					      db	95
    455  2055					      endm
    456  2055
    457  2055					      Macro	tmp2stk
    458  2055					      db	96
    459  2055					      endm
    460  2055
    461  2055					      Macro	tstbyte
    462  2055					      db	97
    463  2055					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  2055					      dw	{2}	; address to check
    465  2055					      db	{3}	; Value to compare
    466  2055					      endm
    467  2055
    468  2055					      Macro	incvar
    469  2055					      db	98
    470  2055					      endm
    471  2055					      Macro	decvar
    472  2055					      db	99
    473  2055					      endm
    474  2055
    475  2055					      Macro	slice
    476  2055					      db	100
    477  2055					      endm
    478  2055
    479  2055					      Macro	tstb
    480  2055					      db	101
    481  2055					      db	({1}-*)-1
    482  2055					      db	{2}
    483  2055					      endm
    484  2055
    485  2055					      Macro	tstw
    486  2055					      db	102
    487  2055					      db	({1}-*)-1
    488  2055					      dw	{2}
    489  2055					      endm
    490  2055
    491  2055					      Macro	ongoto
    492  2055					      db	103
    493  2055					      dw	{1}
    494  2055					      dw	{2}
    495  2055					      endm
    496  2055
    497  2055					      Macro	tstrelop
    498  2055					      db	104
    499  2055					      db	({1}-*)-1
    500  2055					      endm
    501  2055
------- FILE mytb.asm
   2314  2055							;
   2315  2055				  -	      if	FIXED
   2316  2055				  -	      org	$1000
   2317  2055					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  2055					      include	"basic.il"
      1  2055					      seg	Code
      2  2055							; on goto table
      3  2055							; format :   first byte is value Base, subtracted from value found
      4  2055							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  2055				   BasicStmts
      0  2055					      db	kBeginKey,kKeyCount+1	; Base address of table, length of table
      1  2055		       01 1f		      .byte.b	kBeginKey,kKeyCount+1
      0  2057					      dw	ekLet
      1  2057		       d2 20		      .word.w	ekLet
      0  2059					      dw	ekInc
      1  2059		       fd 20		      .word.w	ekInc
      0  205b					      dw	ekDec
      1  205b		       10 21		      .word.w	ekDec
      0  205d					      dw	ekIreturn
      1  205d		       23 21		      .word.w	ekIreturn
      0  205f					      dw	ekIf
      1  205f		       2b 21		      .word.w	ekIf
      0  2061					      dw	ekThen
      1  2061		       31 21		      .word.w	ekThen
      0  2063					      dw	ekGoto
      1  2063		       38 21		      .word.w	ekGoto
      0  2065					      dw	ekGosub
      1  2065		       3f 21		      .word.w	ekGosub
      0  2067					      dw	ekReturn
      1  2067		       49 21		      .word.w	ekReturn
      0  2069					      dw	ekRem
      1  2069		       69 21		      .word.w	ekRem
      0  206b					      dw	ekPrint	; should be entry for print
      1  206b		       72 21		      .word.w	ekPrint
      0  206d					      dw	ekTaske
      1  206d		       c2 21		      .word.w	ekTaske
      0  206f					      dw	ekTaskn
      1  206f		       db 21		      .word.w	ekTaskn
      0  2071					      dw	ekTaskw
      1  2071		       e5 21		      .word.w	ekTaskw
      0  2073					      dw	ekPoke
      1  2073		       03 22		      .word.w	ekPoke
      0  2075					      dw	ekPutch
      1  2075		       1d 22		      .word.w	ekPutch
      0  2077					      dw	ekCls
      1  2077		       2b 22		      .word.w	ekCls
      0  2079					      dw	ekInput
      1  2079		       35 22		      .word.w	ekInput
      0  207b					      dw	ekEnd
      1  207b		       5a 22		      .word.w	ekEnd
      0  207d					      dw	ekIrq
      1  207d		       61 22		      .word.w	ekIrq
      0  207f					      dw	ekKill
      1  207f		       6f 22		      .word.w	ekKill
      0  2081					      dw	ekList
      1  2081		       7d 22		      .word.w	ekList
      0  2083					      dw	ekRun
      1  2083		       85 22		      .word.w	ekRun
      0  2085					      dw	ekNew
      1  2085		       91 22		      .word.w	ekNew
      0  2087					      dw	ekSlice
      1  2087		       98 22		      .word.w	ekSlice
      0  2089					      dw	ekTrace
      1  2089		       a6 22		      .word.w	ekTrace
      0  208b					      dw	ekExit
      1  208b		       ba 22		      .word.w	ekExit
      0  208d					      dw	ekSave
      1  208d		       be 22		      .word.w	ekSave
      0  208f					      dw	ekLoad
      1  208f		       c7 22		      .word.w	ekLoad
      0  2091					      dw	ekErase
      1  2091		       dd 22		      .word.w	ekErase
      0  2093					      dw	ekDir
      1  2093		       d6 22		      .word.w	ekDir
     38  2095							;
     39  2095							; Logical operators
      0  2095				   BasicLogical db	kNot,4
      1  2095		       20 04		      .byte.b	kNot,4
      0  2097					      dw	ekNot
      1  2097		       e8 22		      .word.w	ekNot
     42  2099
      0  2099					      dw	ekOr
      1  2099		       fb 22		      .word.w	ekOr
      0  209b					      dw	ekXor
      1  209b		       03 23		      .word.w	ekXor
      0  209d					      dw	ekAnd
      1  209d		       f3 22		      .word.w	ekAnd
     46  209f
     47  209f							;functions returning values
     48  209f
      0  209f				   BasicFuncs db	kBeginFunc,kFuncCount
      1  209f		       24 0e		      .byte.b	kBeginFunc,kFuncCount
      0  20a1					      dw	ekTrue
      1  20a1		       66 23		      .word.w	ekTrue
      0  20a3					      dw	ekFalse
      1  20a3		       6d 23		      .word.w	ekFalse
      0  20a5					      dw	ekFree
      1  20a5		       74 23		      .word.w	ekFree
      0  20a7					      dw	ekGetch
      1  20a7		       7f 23		      .word.w	ekGetch
      0  20a9					      dw	ekPeek
      1  20a9		       8a 23		      .word.w	ekPeek
      0  20ab					      dw	ekTask
      1  20ab		       98 23		      .word.w	ekTask
      0  20ad					      dw	ekIpcc
      1  20ad		       e3 23		      .word.w	ekIpcc
      0  20af					      dw	ekIpcs
      1  20af		       b7 23		      .word.w	ekIpcs
      0  20b1					      dw	ekIpcr
      1  20b1		       cb 23		      .word.w	ekIpcr
      0  20b3					      dw	ekRnd
      1  20b3		       f1 23		      .word.w	ekRnd
      0  20b5					      dw	ekStat
      1  20b5		       15 24		      .word.w	ekStat
      0  20b7					      dw	ekAbs
      1  20b7		       07 24		      .word.w	ekAbs
      0  20b9					      dw	ekCall
      1  20b9		       28 24		      .word.w	ekCall
      0  20bb					      dw	ekGofn
      1  20bb		       44 24		      .word.w	ekGofn
      0  20bd					      dw	ekPid
      1  20bd		       23 24		      .word.w	ekPid
     65  20bf
     66  20bf
     67  20bf							;=====================================================
     68  20bf							; This is the IL of the BASIC (or whatever) language.
     69  20bf							; Because of the way macros are implemented by as65,
     70  20bf							; labels can't be on the same line as a macro
     71  20bf							; invocation, so that's why labels are on separate
     72  20bf							; lines.
     73  20bf							;
     74  20bf		       20 bf	   IL	      equ	*
     75  20bf
     76  20bf							;THE IL CONTROL SECTION
     77  20bf
     78  20bf				   START
      0  20bf					      INIT		;INITIALIZE
      0  20bf					      db	22
      1  20bf		       16		      .byte.b	22
      0  20c0					      NLINE		;WRITE CRLF
      0  20c0					      db	5
      1  20c0		       05		      .byte.b	5
      0  20c1					      ERRGOTO	CO	;where to go after an error
      0  20c1					      db	31
      1  20c1		       1f		      .byte.b	31
      0  20c2					      dw	CO
      1  20c2		       c5 20		      .word.w	CO
      0  20c4					      VINIT		;clear all variables
      0  20c4					      db	30
      1  20c4		       1e		      .byte.b	30
     83  20c5							;
     84  20c5							; This is where we jump to get a line of commands or
     85  20c5							; a program from the user.
     86  20c5							;
     87  20c5				   CO
      0  20c5					      GETLINE		;WRITE PROMPT AND GET LINE
      0  20c5					      db	23
      1  20c5		       17		      .byte.b	23
      0  20c6					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  20c6					      db	34
      1  20c6		       22		      .byte.b	34
      0  20c7					      db	(XEC-*)-1
      1  20c7		       04		      .byte.b	(XEC-*)-1
      0  20c8					      INSERT		;INSERT IT (MAY BE DELETE)
      0  20c8					      db	24
      1  20c8		       18		      .byte.b	24
      0  20c9					      IJMP	CO
      0  20c9					      db	29
      1  20c9		       1d		      .byte.b	29
      0  20ca					      dw	CO
      1  20ca		       c5 20		      .word.w	CO
     92  20cc				   XEC
      0  20cc					      XINIT		;INITIALIZE
      0  20cc					      db	0
      1  20cc		       00		      .byte.b	0
     94  20cd							;============================================================================
     95  20cd							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     96  20cd							;
     97  20cd				   STMT
      0  20cd					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  20cd					      db	79
      1  20cd		       4f		      .byte.b	79
      0  20ce					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  20ce					      db	57
      1  20ce		       39		      .byte.b	57
      0  20cf					      db	(notirq-*)-1
      1  20cf		       00		      .byte.b	(notirq-*)-1
    100  20d0							;==========================================================================================
    101  20d0							; Process a let statement implied or explicit.
    102  20d0							;
    103  20d0				   notirq
      0  20d0					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  20d0					      db	49
      1  20d0		       31		      .byte.b	49
      0  20d1					      db	(DoVector-*)-1
      1  20d1		       23		      .byte.b	(DoVector-*)-1
    105  20d2				   ekLet
      0  20d2					      TSTV	ERRVEC2	; YES, PLACE VAR ADDRESS ON AESTK
      0  20d2					      db	33
      1  20d2		       21		      .byte.b	33
      0  20d3					      db	(ERRVEC2-*)-1
      1  20d3		       1e		      .byte.b	(ERRVEC2-*)-1
      0  20d4					      TSTB	LETSQBRACKET,oEqual	; (This line originally omitted)
      0  20d4					      db	101
      1  20d4		       65		      .byte.b	101
      0  20d5					      db	(LETSQBRACKET-*)-1
      1  20d5		       04		      .byte.b	(LETSQBRACKET-*)-1
      0  20d6					      db	oEqual
      1  20d6		       f2		      .byte.b	oEqual
      0  20d7					      IJMP	LETBE
      0  20d7					      db	29
      1  20d7		       1d		      .byte.b	29
      0  20d8					      dw	LETBE
      1  20d8		       e7 20		      .word.w	LETBE
    109  20da
    110  20da				   LETSQBRACKET 		; is this an array access ?
    111  20da
      0  20da					      TSTB	ERRVEC2,oLeftSQBracket	; [
      0  20da					      db	101
      1  20da		       65		      .byte.b	101
      0  20db					      db	(ERRVEC2-*)-1
      1  20db		       16		      .byte.b	(ERRVEC2-*)-1
      0  20dc					      db	oLeftSQBracket
      1  20dc		       e4		      .byte.b	oLeftSQBracket
      0  20dd					      CALL	EXPR
      0  20dd					      db	28
      1  20dd		       1c		      .byte.b	28
      0  20de					      dw	EXPR
      1  20de		       e5 22		      .word.w	EXPR
      0  20e0					      TSTB	ERRVEC2,oRightSQBracket	; ]
      0  20e0					      db	101
      1  20e0		       65		      .byte.b	101
      0  20e1					      db	(ERRVEC2-*)-1
      1  20e1		       10		      .byte.b	(ERRVEC2-*)-1
      0  20e2					      db	oRightSQBracket
      1  20e2		       e5		      .byte.b	oRightSQBracket
      0  20e3					      SUBSCRIPT
      0  20e3					      db	64
      1  20e3		       40		      .byte.b	64
      0  20e4					      TSTB	ERRVEC2,oEqual	; (This line originally omitted)
      0  20e4					      db	101
      1  20e4		       65		      .byte.b	101
      0  20e5					      db	(ERRVEC2-*)-1
      1  20e5		       0c		      .byte.b	(ERRVEC2-*)-1
      0  20e6					      db	oEqual
      1  20e6		       f2		      .byte.b	oEqual
    117  20e7				   LETBE
    118  20e7
      0  20e7					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  20e7					      db	28
      1  20e7		       1c		      .byte.b	28
      0  20e8					      dw	EXPR
      1  20e8		       e5 22		      .word.w	EXPR
      0  20ea					      DONE		; REPORT ERROR IF NOT NEXT
      0  20ea					      db	1
      1  20ea		       01		      .byte.b	1
      0  20eb					      STORE		; STORE RESULT
      0  20eb					      db	19
      1  20eb		       13		      .byte.b	19
      0  20ec					      NXT	CO	; AND SEQUENCE TO NEXT
      0  20ec					      db	6
      1  20ec		       06		      .byte.b	6
      0  20ed					      dw	CO
      1  20ed		       c5 20		      .word.w	CO
      0  20ef					      IJMP	STMT
      0  20ef					      db	29
      1  20ef		       1d		      .byte.b	29
      0  20f0					      dw	STMT
      1  20f0		       cd 20		      .word.w	STMT
    124  20f2				   ERRVEC2
      0  20f2					      IJMP	UNKNOWN
      0  20f2					      db	29
      1  20f2		       1d		      .byte.b	29
      0  20f3					      dw	UNKNOWN
      1  20f3		       e1 22		      .word.w	UNKNOWN
    126  20f5							;=============================================================
    127  20f5							;Branch on a valid statement start
    128  20f5				   DoVector
      0  20f5					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  20f5					      db	103
      1  20f5		       67		      .byte.b	103
      0  20f6					      dw	BasicStmts
      1  20f6		       55 20		      .word.w	BasicStmts
      0  20f8					      dw	UNKNOWN
      1  20f8		       e1 22		      .word.w	UNKNOWN
    130  20fa							;This will never return here!
    131  20fa							;=============================================================
    132  20fa							; Inc or dec a variable
    133  20fa				   S1
      0  20fa					      TSTB	S1Dec,kInc	; Increment variable
      0  20fa					      db	101
      1  20fa		       65		      .byte.b	101
      0  20fb					      db	(S1Dec-*)-1
      1  20fb		       11		      .byte.b	(S1Dec-*)-1
      0  20fc					      db	kInc
      1  20fc		       02		      .byte.b	kInc
    135  20fd				   ekInc
      0  20fd					      TSTV	ERRVEC2	; Verify we have a variable
      0  20fd					      db	33
      1  20fd		       21		      .byte.b	33
      0  20fe					      db	(ERRVEC2-*)-1
      1  20fe		       f3		      .byte.b	(ERRVEC2-*)-1
      0  20ff					      TSTB	eDoInc,oBang	; Allow to inc or dec other tasks variables
      0  20ff					      db	101
      1  20ff		       65		      .byte.b	101
      0  2100					      db	(eDoInc-*)-1
      1  2100		       04		      .byte.b	(eDoInc-*)-1
      0  2101					      db	oBang
      1  2101		       e8		      .byte.b	oBang
      0  2102					      IND		; we just got a pid
      0  2102					      db	20
      1  2102		       14		      .byte.b	20
      0  2103					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  2103					      db	93
      1  2103		       5d		      .byte.b	93
      0  2104					      db	(ERRVEC2-*)-1
      1  2104		       ed		      .byte.b	(ERRVEC2-*)-1
    140  2105				   eDoInc
      0  2105					      INCVAR		; Do the increment of the variable
      0  2105					      db	98
      1  2105		       62		      .byte.b	98
      0  2106					      DONE		; Test for end of line or end of statement ":"
      0  2106					      db	1
      1  2106		       01		      .byte.b	1
      0  2107					      NXT	CO	; Get the next statement, branch CO if end of program
      0  2107					      db	6
      1  2107		       06		      .byte.b	6
      0  2108					      dw	CO
      1  2108		       c5 20		      .word.w	CO
      0  210a					      IJMP	STMT	; Process the next statement
      0  210a					      db	29
      1  210a		       1d		      .byte.b	29
      0  210b					      dw	STMT
      1  210b		       cd 20		      .word.w	STMT
    145  210d				   S1Dec
      0  210d					      TSTB	S1Iret,kDec	; Dec variable
      0  210d					      db	101
      1  210d		       65		      .byte.b	101
      0  210e					      db	(S1Iret-*)-1
      1  210e		       11		      .byte.b	(S1Iret-*)-1
      0  210f					      db	kDec
      1  210f		       03		      .byte.b	kDec
    147  2110				   ekDec
      0  2110					      TSTV	ERRVEC2	; Must be followed by a variable
      0  2110					      db	33
      1  2110		       21		      .byte.b	33
      0  2111					      db	(ERRVEC2-*)-1
      1  2111		       e0		      .byte.b	(ERRVEC2-*)-1
      0  2112					      TSTB	eDoDec,oBang	; Allow to inc or dec other tasks variables
      0  2112					      db	101
      1  2112		       65		      .byte.b	101
      0  2113					      db	(eDoDec-*)-1
      1  2113		       04		      .byte.b	(eDoDec-*)-1
      0  2114					      db	oBang
      1  2114		       e8		      .byte.b	oBang
      0  2115					      IND		; we just got a pid
      0  2115					      db	20
      1  2115		       14		      .byte.b	20
      0  2116					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  2116					      db	93
      1  2116		       5d		      .byte.b	93
      0  2117					      db	(ERRVEC2-*)-1
      1  2117		       da		      .byte.b	(ERRVEC2-*)-1
    152  2118				   eDoDec
      0  2118					      DECVAR		; Decrement the actual variable
      0  2118					      db	99
      1  2118		       63		      .byte.b	99
      0  2119					      DONE		; Test if end of line or : statement
      0  2119					      db	1
      1  2119		       01		      .byte.b	1
      0  211a					      NXT	CO	; If at end of program then got the console
      0  211a					      db	6
      1  211a		       06		      .byte.b	6
      0  211b					      dw	CO
      1  211b		       c5 20		      .word.w	CO
      0  211d					      IJMP	STMT	; Process the next statement of command line
      0  211d					      db	29
      1  211d		       1d		      .byte.b	29
      0  211e					      dw	STMT
      1  211e		       cd 20		      .word.w	STMT
    157  2120							;=============================================================================================================================
    158  2120							; iret or ireturn, Return from interupt process
    159  2120							;
    160  2120				   S1Iret
      0  2120					      TSTB	S1S1,kIreturn	; test return from interupt
      0  2120					      db	101
      1  2120		       65		      .byte.b	101
      0  2121					      db	(S1S1-*)-1
      1  2121		       06		      .byte.b	(S1S1-*)-1
      0  2122					      db	kIreturn
      1  2122		       04		      .byte.b	kIreturn
    162  2123				   S1Sa
    163  2123				   ekIreturn
      0  2123					      DONE		; Must be only thing on the line
      0  2123					      db	1
      1  2123		       01		      .byte.b	1
      0  2124					      IRET		; RESTORE LINE NUMBER OF CALL
      0  2124					      db	58
      1  2124		       3a		      .byte.b	58
      0  2125					      IJMP	STMT
      0  2125					      db	29
      1  2125		       1d		      .byte.b	29
      0  2126					      dw	STMT
      1  2126		       cd 20		      .word.w	STMT
    167  2128							;==============================================================================================================================
    168  2128							;Process if statement, if true then process all statements until end of line reached
    169  2128				   S1S1
      0  2128					      TSTB	S1Z,kIf	; IF STATEMENT
      0  2128					      db	101
      1  2128		       65		      .byte.b	101
      0  2129					      db	(S1Z-*)-1
      1  2129		       0b		      .byte.b	(S1Z-*)-1
      0  212a					      db	kIf
      1  212a		       05		      .byte.b	kIf
    171  212b				   ekIf
      0  212b					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  212b					      db	28
      1  212b		       1c		      .byte.b	28
      0  212c					      dw	EXPR
      1  212c		       e5 22		      .word.w	EXPR
      0  212e					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  212e					      db	101
      1  212e		       65		      .byte.b	101
      0  212f					      db	(S1W-*)-1
      1  212f		       01		      .byte.b	(S1W-*)-1
      0  2130					      db	kThen
      1  2130		       06		      .byte.b	kThen
    174  2131				   ekThen
    175  2131				   S1W
      0  2131					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  2131					      db	54
      1  2131		       36		      .byte.b	54
      0  2132					      IJMP	STMT
      0  2132					      db	29
      1  2132		       1d		      .byte.b	29
      0  2133					      dw	STMT
      1  2133		       cd 20		      .word.w	STMT
    178  2135							;===============================================================================================================================
    179  2135							; Test for GOTO
    180  2135				   S1Z
      0  2135					      TSTB	S2,kGoto	; YES...TO, OR...SUB
      0  2135					      db	101
      1  2135		       65		      .byte.b	101
      0  2136					      db	(S2-*)-1
      1  2136		       05		      .byte.b	(S2-*)-1
      0  2137					      db	kGoto
      1  2137		       07		      .byte.b	kGoto
    182  2138				   ekGoto
      0  2138					      CALL	EXPR	; GET LABEL
      0  2138					      db	28
      1  2138		       1c		      .byte.b	28
      0  2139					      dw	EXPR
      1  2139		       e5 22		      .word.w	EXPR
      0  213b					      XFER		; SET UP AND JUMP
      0  213b					      db	7
      1  213b		       07		      .byte.b	7
    185  213c
    186  213c							;===============================================================================================================================
    187  213c							; Process gosub / function
    188  213c							;
    189  213c				   S2
      0  213c					      TSTB	S2b,kGosub	; ERROR IF NO MATCH
      0  213c					      db	101
      1  213c		       65		      .byte.b	101
      0  213d					      db	(S2b-*)-1
      1  213d		       08		      .byte.b	(S2b-*)-1
      0  213e					      db	kGosub
      1  213e		       08		      .byte.b	kGosub
    191  213f				   ekGosub
      0  213f					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  213f					      db	28
      1  213f		       1c		      .byte.b	28
      0  2140					      dw	GOSUBSTATEMENT
      1  2140		       70 24		      .word.w	GOSUBSTATEMENT
      0  2142					      DONE		; ERROR IF CR NOT NEXT
      0  2142					      db	1
      1  2142		       01		      .byte.b	1
      0  2143					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  2143					      db	8
      1  2143		       08		      .byte.b	8
      0  2144					      db	GOSUB_RTN
      1  2144		       01		      .byte.b	GOSUB_RTN
      0  2145					      XFER		; AND JUMP to sub rtn
      0  2145					      db	7
      1  2145		       07		      .byte.b	7
    196  2146							;
    197  2146							; End of gosub processing
    198  2146							;===============================================================================================================================
    199  2146							; Return from a gosub
    200  2146				   S2b
      0  2146					      TSTB	S2a,kReturn	; Speed up pocessing but more memory
      0  2146					      db	101
      1  2146		       65		      .byte.b	101
      0  2147					      db	(S2a-*)-1
      1  2147		       1e		      .byte.b	(S2a-*)-1
      0  2148					      db	kReturn
      1  2148		       09		      .byte.b	kReturn
    202  2149				   ekReturn
      0  2149					      SETR2	0	; Default no return value
      0  2149					      db	94
      1  2149		       5e		      .byte.b	94
      0  214a					      db	0
      1  214a		       00		      .byte.b	0
      0  214b					      TSTB	S2RetDone,oLeftBracket	; Check if we will return some value
      0  214b					      db	101
      1  214b		       65		      .byte.b	101
      0  214c					      db	(S2RetDone-*)-1
      1  214c		       09		      .byte.b	(S2RetDone-*)-1
      0  214d					      db	oLeftBracket
      1  214d		       e0		      .byte.b	oLeftBracket
      0  214e					      SETR2	1	; Indicate a return value provided
      0  214e					      db	94
      1  214e		       5e		      .byte.b	94
      0  214f					      db	1
      1  214f		       01		      .byte.b	1
      0  2150					      CALL	EXPR
      0  2150					      db	28
      1  2150		       1c		      .byte.b	28
      0  2151					      dw	EXPR
      1  2151		       e5 22		      .word.w	EXPR
      0  2153					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  2153					      db	101
      1  2153		       65		      .byte.b	101
      0  2154					      db	(ERRVEC2-*)-1
      1  2154		       9d		      .byte.b	(ERRVEC2-*)-1
      0  2155					      db	oRightBracket
      1  2155		       e1		      .byte.b	oRightBracket
    208  2156
    209  2156				   S2RetDone
      0  2156					      DONE		; MUST BE CR or :
      0  2156					      db	1
      1  2156		       01		      .byte.b	1
      0  2157					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  2157					      db	9
      1  2157		       09		      .byte.b	9
      0  2158					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  2158					      db	97
      1  2158		       61		      .byte.b	97
      0  2159					      db	(S2RetFunc-*)-1
      1  2159		       09		      .byte.b	(S2RetFunc-*)-1
      0  215a					      dw	R2
      1  215a		       58 00		      .word.w	R2
      0  215c					      db	1
      1  215c		       01		      .byte.b	1
      0  215d					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  215d					      db	6
      1  215d		       06		      .byte.b	6
      0  215e					      dw	CO
      1  215e		       c5 20		      .word.w	CO
      0  2160					      IJMP	STMT	; Process the new statement
      0  2160					      db	29
      1  2160		       1d		      .byte.b	29
      0  2161					      dw	STMT
      1  2161		       cd 20		      .word.w	STMT
    215  2163				   S2RetFunc
      0  2163					      IJMP	GOFNRet	; Back into the Function
      0  2163					      db	29
      1  2163		       1d		      .byte.b	29
      0  2164					      dw	GOFNRet
      1  2164		       4a 24		      .word.w	GOFNRet
    217  2166							;
    218  2166							; End of return from gosub
    219  2166							;==================================================================================================================================
    220  2166							; Process REM statement
    221  2166							;
    222  2166				   S2a
      0  2166					      TSTB	S3,kRem	; REMark.  Skip rest of line
      0  2166					      db	101
      1  2166		       65		      .byte.b	101
      0  2167					      db	(S3-*)-1
      1  2167		       07		      .byte.b	(S3-*)-1
      0  2168					      db	kRem
      1  2168		       0a		      .byte.b	kRem
    224  2169				   ekRem
      0  2169					      NXT	CO	; The rest of the line is ignored
      0  2169					      db	6
      1  2169		       06		      .byte.b	6
      0  216a					      dw	CO
      1  216a		       c5 20		      .word.w	CO
      0  216c					      IJMP	STMT	; Process the next statement
      0  216c					      db	29
      1  216c		       1d		      .byte.b	29
      0  216d					      dw	STMT
      1  216d		       cd 20		      .word.w	STMT
    227  216f							;==================================================================================================================================
    228  216f							; Print statement
    229  216f							;
    230  216f				   S3
      0  216f					      TSTB	S8,kPrint	; ? or Print symonym for print
      0  216f					      db	101
      1  216f		       65		      .byte.b	101
      0  2170					      db	(S8-*)-1
      1  2170		       4e		      .byte.b	(S8-*)-1
      0  2171					      db	kPrint
      1  2171		       0b		      .byte.b	kPrint
    232  2172				   ekPrint
      0  2172					      STARTIO		; Lock task until io completes
      0  2172					      db	70
      1  2172		       46		      .byte.b	70
    234  2173				   S4
      0  2173					      TSTDONE	S4a	; Test if we just want crlf printed
      0  2173					      db	50
      1  2173		       32		      .byte.b	50
      0  2174					      db	(S4a-*)-1
      1  2174		       03		      .byte.b	(S4a-*)-1
      0  2175					      IJMP	S6
      0  2175					      db	29
      1  2175		       1d		      .byte.b	29
      0  2176					      dw	S6
      1  2176		       8d 21		      .word.w	S6
    237  2178
    238  2178				   S4a
      0  2178					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  2178					      db	101
      1  2178		       65		      .byte.b	101
      0  2179					      db	(S7-*)-1
      1  2179		       1f		      .byte.b	(S7-*)-1
      0  217a					      db	tString
      1  217a		       a0		      .byte.b	tString
      0  217b					      PRS		; PRINT STRING
      0  217b					      db	2
      1  217b		       02		      .byte.b	2
    241  217c				   S5
      0  217c					      TSTB	S6A,oComma	; IS THERE MORE?
      0  217c					      db	101
      1  217c		       65		      .byte.b	101
      0  217d					      db	(S6A-*)-1
      1  217d		       07		      .byte.b	(S6A-*)-1
      0  217e					      db	oComma
      1  217e		       e2		      .byte.b	oComma
      0  217f					      SPC		; SPACE TO NEXT ZONE
      0  217f					      db	4
      1  217f		       04		      .byte.b	4
      0  2180					      TSTDONE	S4	; Not end of line jump back
      0  2180					      db	50
      1  2180		       32		      .byte.b	50
      0  2181					      db	(S4-*)-1
      1  2181		       f1		      .byte.b	(S4-*)-1
      0  2182					      IJMP	S6Z	; YES JUMP BACK
      0  2182					      db	29
      1  2182		       1d		      .byte.b	29
      0  2183					      dw	S6Z
      1  2183		       8f 21		      .word.w	S6Z
    246  2185
    247  2185							;
    248  2185							; If a semicolon, don't do anything.
    249  2185							;
    250  2185				   S6A
      0  2185					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  2185					      db	101
      1  2185		       65		      .byte.b	101
      0  2186					      db	(S6-*)-1
      1  2186		       06		      .byte.b	(S6-*)-1
      0  2187					      db	oSemiColon
      1  2187		       e3		      .byte.b	oSemiColon
      0  2188					      TSTDONE	S4	; Jump Back if not end of line
      0  2188					      db	50
      1  2188		       32		      .byte.b	50
      0  2189					      db	(S4-*)-1
      1  2189		       e9		      .byte.b	(S4-*)-1
      0  218a					      IJMP	S6Z
      0  218a					      db	29
      1  218a		       1d		      .byte.b	29
      0  218b					      dw	S6Z
      1  218b		       8f 21		      .word.w	S6Z
    254  218d
    255  218d				   S6
    256  218d
      0  218d					      DONE		; ERROR IF CR NOT NEXT
      0  218d					      db	1
      1  218d		       01		      .byte.b	1
      0  218e					      NLINE
      0  218e					      db	5
      1  218e		       05		      .byte.b	5
    259  218f				   S6Z
      0  218f					      ENDIO		; release task io completed
      0  218f					      db	71
      1  218f		       47		      .byte.b	71
      0  2190					      NXT	CO	; exit here if , or ; at end of print
      0  2190					      db	6
      1  2190		       06		      .byte.b	6
      0  2191					      dw	CO
      1  2191		       c5 20		      .word.w	CO
      0  2193					      IJMP	STMT
      0  2193					      db	29
      1  2193		       1d		      .byte.b	29
      0  2194					      dw	STMT
      1  2194		       cd 20		      .word.w	STMT
    263  2196							;
    264  2196							; A jump for code too far away for relative branch
    265  2196							;
    266  2196				   ERRVEC
      0  2196					      IJMP	UNKNOWN
      0  2196					      db	29
      1  2196		       1d		      .byte.b	29
      0  2197					      dw	UNKNOWN
      1  2197		       e1 22		      .word.w	UNKNOWN
    268  2199							;
    269  2199							; Get here if there is an expression to print
    270  2199				   S7
      0  2199					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  2199					      db	101
      1  2199		       65		      .byte.b	101
      0  219a					      db	(S7AUnsigned-*)-1
      1  219a		       08		      .byte.b	(S7AUnsigned-*)-1
      0  219b					      db	oDollar
      1  219b		       e7		      .byte.b	oDollar
      0  219c					      CALL	EXPR
      0  219c					      db	28
      1  219c		       1c		      .byte.b	28
      0  219d					      dw	EXPR
      1  219d		       e5 22		      .word.w	EXPR
      0  219f					      HEXPRT
      0  219f					      db	67
      1  219f		       43		      .byte.b	67
      0  21a0					      IJMP	S5
      0  21a0					      db	29
      1  21a0		       1d		      .byte.b	29
      0  21a1					      dw	S5
      1  21a1		       7c 21		      .word.w	S5
    275  21a3
    276  21a3				   S7AUnsigned
    277  21a3
      0  21a3					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  21a3					      db	101
      1  21a3		       65		      .byte.b	101
      0  21a4					      db	(S7A-*)-1
      1  21a4		       0a		      .byte.b	(S7A-*)-1
      0  21a5					      db	oPercent
      1  21a5		       ec		      .byte.b	oPercent
      0  21a6					      CALL	EXPR
      0  21a6					      db	28
      1  21a6		       1c		      .byte.b	28
      0  21a7					      dw	EXPR
      1  21a7		       e5 22		      .word.w	EXPR
      0  21a9					      SETR2	1
      0  21a9					      db	94
      1  21a9		       5e		      .byte.b	94
      0  21aa					      db	1
      1  21aa		       01		      .byte.b	1
      0  21ab					      PRN
      0  21ab					      db	3
      1  21ab		       03		      .byte.b	3
      0  21ac					      IJMP	S5
      0  21ac					      db	29
      1  21ac		       1d		      .byte.b	29
      0  21ad					      dw	S5
      1  21ad		       7c 21		      .word.w	S5
    283  21af
    284  21af				   S7A
    285  21af
      0  21af					      CALL	EXPR
      0  21af					      db	28
      1  21af		       1c		      .byte.b	28
      0  21b0					      dw	EXPR
      1  21b0		       e5 22		      .word.w	EXPR
      0  21b2					      TSTB	S7B,oDollar	; Print the value as a single character
      0  21b2					      db	101
      1  21b2		       65		      .byte.b	101
      0  21b3					      db	(S7B-*)-1
      1  21b3		       05		      .byte.b	(S7B-*)-1
      0  21b4					      db	oDollar
      1  21b4		       e7		      .byte.b	oDollar
      0  21b5					      PUTCHAR
      0  21b5					      db	52
      1  21b5		       34		      .byte.b	52
      0  21b6					      IJMP	S5
      0  21b6					      db	29
      1  21b6		       1d		      .byte.b	29
      0  21b7					      dw	S5
      1  21b7		       7c 21		      .word.w	S5
    290  21b9
    291  21b9				   S7B
      0  21b9					      SETR2	0	; Print the value as a signed number
      0  21b9					      db	94
      1  21b9		       5e		      .byte.b	94
      0  21ba					      db	0
      1  21ba		       00		      .byte.b	0
      0  21bb					      PRN		; PRINT IT
      0  21bb					      db	3
      1  21bb		       03		      .byte.b	3
      0  21bc					      IJMP	S5	; IS THERE MORE?
      0  21bc					      db	29
      1  21bc		       1d		      .byte.b	29
      0  21bd					      dw	S5
      1  21bd		       7c 21		      .word.w	S5
    295  21bf							;
    296  21bf							;===========================================================
    297  21bf							; PROCESS ALL THE TAST STATEMENTS
    298  21bf							;
    299  21bf				   S8
      0  21bf					      TSTB	S8G,kTaske	; End Task
      0  21bf					      db	101
      1  21bf		       65		      .byte.b	101
      0  21c0					      db	(S8G-*)-1
      1  21c0		       17		      .byte.b	(S8G-*)-1
      0  21c1					      db	kTaske
      1  21c1		       0c		      .byte.b	kTaske
    301  21c2				   ekTaske
      0  21c2					      TSTB	S8NoParm,oLeftBracket
      0  21c2					      db	101
      1  21c2		       65		      .byte.b	101
      0  21c3					      db	(S8NoParm-*)-1
      1  21c3		       0c		      .byte.b	(S8NoParm-*)-1
      0  21c4					      db	oLeftBracket
      1  21c4		       e0		      .byte.b	oLeftBracket
      0  21c5					      CALL	EXPR
      0  21c5					      db	28
      1  21c5		       1c		      .byte.b	28
      0  21c6					      dw	EXPR
      1  21c6		       e5 22		      .word.w	EXPR
      0  21c8					      TSTB	UNKNOWNLnk,oRightBracket
      0  21c8					      db	101
      1  21c8		       65		      .byte.b	101
      0  21c9					      db	(UNKNOWNLnk-*)-1
      1  21c9		       33		      .byte.b	(UNKNOWNLnk-*)-1
      0  21ca					      db	oRightBracket
      1  21ca		       e1		      .byte.b	oRightBracket
      0  21cb					      ETASK
      0  21cb					      db	62
      1  21cb		       3e		      .byte.b	62
      0  21cc					      DONE
      0  21cc					      db	1
      1  21cc		       01		      .byte.b	1
      0  21cd					      IJMP	STMT
      0  21cd					      db	29
      1  21cd		       1d		      .byte.b	29
      0  21ce					      dw	STMT
      1  21ce		       cd 20		      .word.w	STMT
    308  21d0				   S8NoParm
      0  21d0					      LIT	0
      0  21d0					      db	27
      1  21d0		       1b		      .byte.b	27
      0  21d1					      dw	0
      1  21d1		       00 00		      .word.w	0
      0  21d3					      ETASK
      0  21d3					      db	62
      1  21d3		       3e		      .byte.b	62
      0  21d4					      DONE		; Must be last thing on a line
      0  21d4					      db	1
      1  21d4		       01		      .byte.b	1
      0  21d5					      IJMP	STMT
      0  21d5					      db	29
      1  21d5		       1d		      .byte.b	29
      0  21d6					      dw	STMT
      1  21d6		       cd 20		      .word.w	STMT
    313  21d8							;
    314  21d8							;===========================================================
    315  21d8							; The task gives up the rest of the cycles
    316  21d8				   S8G
      0  21d8					      TSTB	S8a,kTaskn	;Next task
      0  21d8					      db	101
      1  21d8		       65		      .byte.b	101
      0  21d9					      db	(S8a-*)-1
      1  21d9		       08		      .byte.b	(S8a-*)-1
      0  21da					      db	kTaskn
      1  21da		       0d		      .byte.b	kTaskn
    318  21db				   ekTaskn
      0  21db					      NTASK
      0  21db					      db	63
      1  21db		       3f		      .byte.b	63
      0  21dc					      NXT	CO	;Next statement to execute
      0  21dc					      db	6
      1  21dc		       06		      .byte.b	6
      0  21dd					      dw	CO
      1  21dd		       c5 20		      .word.w	CO
      0  21df					      IJMP	STMT
      0  21df					      db	29
      1  21df		       1d		      .byte.b	29
      0  21e0					      dw	STMT
      1  21e0		       cd 20		      .word.w	STMT
    322  21e2							;
    323  21e2							;===========================================================
    324  21e2							; Waits for a task or list of tasks to complete
    325  21e2				   S8a
      0  21e2					      TSTB	S8a1,kTaskw	;Wait for tasks
      0  21e2					      db	101
      1  21e2		       65		      .byte.b	101
      0  21e3					      db	(S8a1-*)-1
      1  21e3		       1c		      .byte.b	(S8a1-*)-1
      0  21e4					      db	kTaskw
      1  21e4		       0e		      .byte.b	kTaskw
    327  21e5				   ekTaskw
      0  21e5					      TSTB	UNKNOWNLnk,oLeftBracket
      0  21e5					      db	101
      1  21e5		       65		      .byte.b	101
      0  21e6					      db	(UNKNOWNLnk-*)-1
      1  21e6		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  21e7					      db	oLeftBracket
      1  21e7		       e0		      .byte.b	oLeftBracket
    329  21e8				   S8TSK
      0  21e8					      Call	EXPR	;Gets the PID of task to wait for
      0  21e8					      db	28
      1  21e8		       1c		      .byte.b	28
      0  21e9					      dw	EXPR
      1  21e9		       e5 22		      .word.w	EXPR
    331  21eb				   S8LOOP
      0  21eb					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  21eb					      db	76
      1  21eb		       4c		      .byte.b	76
      0  21ec					      db	(S8LOOP-*)-1
      1  21ec		       fe		      .byte.b	(S8LOOP-*)-1
      0  21ed					      TSTB	S8aa,oComma	;Checks for more tasks
      0  21ed					      db	101
      1  21ed		       65		      .byte.b	101
      0  21ee					      db	(S8aa-*)-1
      1  21ee		       04		      .byte.b	(S8aa-*)-1
      0  21ef					      db	oComma
      1  21ef		       e2		      .byte.b	oComma
      0  21f0					      IJMP	S8TSK	;Go for the next task number
      0  21f0					      db	29
      1  21f0		       1d		      .byte.b	29
      0  21f1					      dw	S8TSK
      1  21f1		       e8 21		      .word.w	S8TSK
    335  21f3				   S8aa
      0  21f3					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  21f3					      db	101
      1  21f3		       65		      .byte.b	101
      0  21f4					      db	(UNKNOWNLnk-*)-1
      1  21f4		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  21f5					      db	oRightBracket
      1  21f5		       e1		      .byte.b	oRightBracket
      0  21f6					      DONE
      0  21f6					      db	1
      1  21f6		       01		      .byte.b	1
      0  21f7					      NXT	CO
      0  21f7					      db	6
      1  21f7		       06		      .byte.b	6
      0  21f8					      dw	CO
      1  21f8		       c5 20		      .word.w	CO
      0  21fa					      IJMP	STMT	;Next Statement
      0  21fa					      db	29
      1  21fa		       1d		      .byte.b	29
      0  21fb					      dw	STMT
      1  21fb		       cd 20		      .word.w	STMT
    340  21fd
    341  21fd
    342  21fd
    343  21fd				   UNKNOWNLnk
      0  21fd					      iJMP	UNKNOWN
      0  21fd					      db	29
      1  21fd		       1d		      .byte.b	29
      0  21fe					      dw	UNKNOWN
      1  21fe		       e1 22		      .word.w	UNKNOWN
    345  2200
    346  2200							;
    347  2200							;===========================================================
    348  2200							; Update a memory location with a value
    349  2200							;  Use @[offset] to write a word value to memory
    350  2200							;
    351  2200				   S8a1
      0  2200					      TSTB	S8b,kPoke	; Poke a value into memory
      0  2200					      db	101
      1  2200		       65		      .byte.b	101
      0  2201					      db	(S8b-*)-1
      1  2201		       18		      .byte.b	(S8b-*)-1
      0  2202					      db	kPoke
      1  2202		       0f		      .byte.b	kPoke
    353  2203				   ekPoke
      0  2203					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  2203					      db	101
      1  2203		       65		      .byte.b	101
      0  2204					      db	(UNKNOWNV-*)-1
      1  2204		       56		      .byte.b	(UNKNOWNV-*)-1
      0  2205					      db	oLeftBracket
      1  2205		       e0		      .byte.b	oLeftBracket
      0  2206					      CALL	EXPR	; Get address to write to
      0  2206					      db	28
      1  2206		       1c		      .byte.b	28
      0  2207					      dw	EXPR
      1  2207		       e5 22		      .word.w	EXPR
      0  2209					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  2209					      db	101
      1  2209		       65		      .byte.b	101
      0  220a					      db	(UNKNOWNV-*)-1
      1  220a		       50		      .byte.b	(UNKNOWNV-*)-1
      0  220b					      db	oComma
      1  220b		       e2		      .byte.b	oComma
      0  220c					      CALL	EXPR	; Get the value to poke
      0  220c					      db	28
      1  220c		       1c		      .byte.b	28
      0  220d					      dw	EXPR
      1  220d		       e5 22		      .word.w	EXPR
      0  220f					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  220f					      db	101
      1  220f		       65		      .byte.b	101
      0  2210					      db	(UNKNOWNV-*)-1
      1  2210		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  2211					      db	oRightBracket
      1  2211		       e1		      .byte.b	oRightBracket
      0  2212					      POKEMEM
      0  2212					      db	47
      1  2212		       2f		      .byte.b	47
      0  2213					      DONE
      0  2213					      db	1
      1  2213		       01		      .byte.b	1
      0  2214					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2214					      db	6
      1  2214		       06		      .byte.b	6
      0  2215					      dw	CO
      1  2215		       c5 20		      .word.w	CO
      0  2217					      IJMP	STMT
      0  2217					      db	29
      1  2217		       1d		      .byte.b	29
      0  2218					      dw	STMT
      1  2218		       cd 20		      .word.w	STMT
    363  221a							;================================================================
    364  221a							; Write a single byte to the output device
    365  221a							;
    366  221a				   S8b
      0  221a					      TSTB	S8c,kPutch	;Put a char to the terminal
      0  221a					      db	101
      1  221a		       65		      .byte.b	101
      0  221b					      db	(S8c-*)-1
      1  221b		       0c		      .byte.b	(S8c-*)-1
      0  221c					      db	kPutch
      1  221c		       10		      .byte.b	kPutch
    368  221d				   ekPutch
      0  221d					      CALL	EXPR
      0  221d					      db	28
      1  221d		       1c		      .byte.b	28
      0  221e					      dw	EXPR
      1  221e		       e5 22		      .word.w	EXPR
      0  2220					      PUTCHAR
      0  2220					      db	52
      1  2220		       34		      .byte.b	52
      0  2221					      DONE
      0  2221					      db	1
      1  2221		       01		      .byte.b	1
      0  2222					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2222					      db	6
      1  2222		       06		      .byte.b	6
      0  2223					      dw	CO
      1  2223		       c5 20		      .word.w	CO
      0  2225					      IJMP	STMT
      0  2225					      db	29
      1  2225		       1d		      .byte.b	29
      0  2226					      dw	STMT
      1  2226		       cd 20		      .word.w	STMT
    374  2228							;================================================================
    375  2228							; Clear the screen lines
    376  2228							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    377  2228							;
    378  2228				   S8c
      0  2228					      TSTB	S9,kCls	;Clear the screen
      0  2228					      db	101
      1  2228		       65		      .byte.b	101
      0  2229					      db	(S9-*)-1
      1  2229		       08		      .byte.b	(S9-*)-1
      0  222a					      db	kCls
      1  222a		       11		      .byte.b	kCls
    380  222b				   ekCls
      0  222b					      CLEARSCREEN
      0  222b					      db	46
      1  222b		       2e		      .byte.b	46
      0  222c					      NXT	CO	;AND SEQUENCE TO NEXT
      0  222c					      db	6
      1  222c		       06		      .byte.b	6
      0  222d					      dw	CO
      1  222d		       c5 20		      .word.w	CO
      0  222f					      IJMP	STMT
      0  222f					      db	29
      1  222f		       1d		      .byte.b	29
      0  2230					      dw	STMT
      1  2230		       cd 20		      .word.w	STMT
    384  2232							;==================================================================
    385  2232							; Get input from the terminal
    386  2232							;   Reads from the currently active input device
    387  2232							;
    388  2232				   S9
      0  2232					      TSTB	S13,kInput	;INPUT STATEMENT
      0  2232					      db	101
      1  2232		       65		      .byte.b	101
      0  2233					      db	(S13-*)-1
      1  2233		       23		      .byte.b	(S13-*)-1
      0  2234					      db	kInput
      1  2234		       12		      .byte.b	kInput
    390  2235				   ekInput
    391  2235				   S10
      0  2235					      TSTB	S10A,tString	;If there is a string print the prompt
      0  2235					      db	101
      1  2235		       65		      .byte.b	101
      0  2236					      db	(S10A-*)-1
      1  2236		       05		      .byte.b	(S10A-*)-1
      0  2237					      db	tString
      1  2237		       a0		      .byte.b	tString
      0  2238					      PRS
      0  2238					      db	2
      1  2238		       02		      .byte.b	2
      0  2239					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  2239					      db	101
      1  2239		       65		      .byte.b	101
      0  223a					      db	(S10Z-*)-1
      1  223a		       12		      .byte.b	(S10Z-*)-1
      0  223b					      db	oSemiColon
      1  223b		       e3		      .byte.b	oSemiColon
    395  223c				   S10A
      0  223c					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  223c					      db	33
      1  223c		       21		      .byte.b	33
      0  223d					      db	(UNKNOWN-*)-1
      1  223d		       a3		      .byte.b	(UNKNOWN-*)-1
      0  223e					      TSTB	S10A1,oDollar
      0  223e					      db	101
      1  223e		       65		      .byte.b	101
      0  223f					      db	(S10A1-*)-1
      1  223f		       05		      .byte.b	(S10A1-*)-1
      0  2240					      db	oDollar
      1  2240		       e7		      .byte.b	oDollar
      0  2241					      INSTR		;Move character From tty to AESTK
      0  2241					      db	59
      1  2241		       3b		      .byte.b	59
      0  2242					      IJMP	S10A2
      0  2242					      db	29
      1  2242		       1d		      .byte.b	29
      0  2243					      dw	S10A2
      1  2243		       46 22		      .word.w	S10A2
    400  2245				   S10A1
      0  2245					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  2245					      db	11
      1  2245		       0b		      .byte.b	11
    402  2246				   S10A2
      0  2246					      STORE		;STORE IT
      0  2246					      db	19
      1  2246		       13		      .byte.b	19
      0  2247					      TSTB	S11,oComma	;IS THERE MORE?
      0  2247					      db	101
      1  2247		       65		      .byte.b	101
      0  2248					      db	(S11-*)-1
      1  2248		       07		      .byte.b	(S11-*)-1
      0  2249					      db	oComma
      1  2249		       e2		      .byte.b	oComma
      0  224a					      IJMP	S10	;YES
      0  224a					      db	29
      1  224a		       1d		      .byte.b	29
      0  224b					      dw	S10
      1  224b		       35 22		      .word.w	S10
    406  224d				   S10Z
      0  224d					      iJMP	UNKNOWN
      0  224d					      db	29
      1  224d		       1d		      .byte.b	29
      0  224e					      dw	UNKNOWN
      1  224e		       e1 22		      .word.w	UNKNOWN
    408  2250				   S11
      0  2250					      DONE		;MUST BE CR
      0  2250					      db	1
      1  2250		       01		      .byte.b	1
      0  2251					      NXT	CO	;SEQUENCE TO NEXT
      0  2251					      db	6
      1  2251		       06		      .byte.b	6
      0  2252					      dw	CO
      1  2252		       c5 20		      .word.w	CO
      0  2254					      IJMP	STMT
      0  2254					      db	29
      1  2254		       1d		      .byte.b	29
      0  2255					      dw	STMT
      1  2255		       cd 20		      .word.w	STMT
    412  2257							;=====================================================================
    413  2257							; End of program, return to command line process
    414  2257							; Main Task may also use taske or return to stopped
    415  2257							;
    416  2257				   S13
      0  2257					      TSTB	S14,kEnd
      0  2257					      db	101
      1  2257		       65		      .byte.b	101
      0  2258					      db	(S14-*)-1
      1  2258		       05		      .byte.b	(S14-*)-1
      0  2259					      db	kEnd
      1  2259		       13		      .byte.b	kEnd
    418  225a				   ekEnd
      0  225a					      FIN
      0  225a					      db	12
      1  225a		       0c		      .byte.b	12
    420  225b
    421  225b				   UNKNOWNV
      0  225b					      IJMP	UNKNOWN
      0  225b					      db	29
      1  225b		       1d		      .byte.b	29
      0  225c					      dw	UNKNOWN
      1  225c		       e1 22		      .word.w	UNKNOWN
    423  225e							;====================================================================
    424  225e							; IRQ <IRQ-HANDLER-Line expression>
    425  225e							;   Specify a line number subroutine to call when an interupt is processed
    426  225e							;   These subroutines must use iret to return.
    427  225e							;
    428  225e				   S14
      0  225e					      TSTB	S14Z,kIrq	;Check if we are setting IRQ HANDLER
      0  225e					      db	101
      1  225e		       65		      .byte.b	101
      0  225f					      db	(S14Z-*)-1
      1  225f		       0c		      .byte.b	(S14Z-*)-1
      0  2260					      db	kIrq
      1  2260		       14		      .byte.b	kIrq
    430  2261				   ekIrq
      0  2261					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2261					      db	28
      1  2261		       1c		      .byte.b	28
      0  2262					      dw	EXPR
      1  2262		       e5 22		      .word.w	EXPR
      0  2264					      DONE		;must be CR
      0  2264					      db	1
      1  2264		       01		      .byte.b	1
      0  2265					      SETIRQ		;Set the line number now
      0  2265					      db	56
      1  2265		       38		      .byte.b	56
      0  2266					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  2266					      db	6
      1  2266		       06		      .byte.b	6
      0  2267					      dw	CO
      1  2267		       c5 20		      .word.w	CO
      0  2269					      IJMP	STMT
      0  2269					      db	29
      1  2269		       1d		      .byte.b	29
      0  226a					      dw	STMT
      1  226a		       cd 20		      .word.w	STMT
    436  226c
    437  226c							;=========================================================================
    438  226c							; KILL PID-expression	 kill a running task
    439  226c							;  ignored of task has already stopped
    440  226c							;
    441  226c				   S14Z
      0  226c					      TSTB	S14S1,kKill	; Kill A running Task
      0  226c					      db	101
      1  226c		       65		      .byte.b	101
      0  226d					      db	(S14S1-*)-1
      1  226d		       0c		      .byte.b	(S14S1-*)-1
      0  226e					      db	kKill
      1  226e		       15		      .byte.b	kKill
    443  226f				   ekKill
      0  226f					      CALL	EXPR
      0  226f					      db	28
      1  226f		       1c		      .byte.b	28
      0  2270					      dw	EXPR
      1  2270		       e5 22		      .word.w	EXPR
      0  2272					      DONE
      0  2272					      db	1
      1  2272		       01		      .byte.b	1
      0  2273					      TASKKILL
      0  2273					      db	65
      1  2273		       41		      .byte.b	65
      0  2274					      NXT	CO
      0  2274					      db	6
      1  2274		       06		      .byte.b	6
      0  2275					      dw	CO
      1  2275		       c5 20		      .word.w	CO
      0  2277					      IJMP	STMT
      0  2277					      db	29
      1  2277		       1d		      .byte.b	29
      0  2278					      dw	STMT
      1  2278		       cd 20		      .word.w	STMT
    449  227a
    450  227a							;============================================================================
    451  227a							; List all program lines
    452  227a							;
    453  227a				   S14S1
      0  227a					      TSTB	S15,kList	;LIST COMMAND
      0  227a					      db	101
      1  227a		       65		      .byte.b	101
      0  227b					      db	(S15-*)-1
      1  227b		       06		      .byte.b	(S15-*)-1
      0  227c					      db	kList
      1  227c		       16		      .byte.b	kList
    455  227d				   ekList
      0  227d					      DONE
      0  227d					      db	1
      1  227d		       01		      .byte.b	1
      0  227e					      LST
      0  227e					      db	21
      1  227e		       15		      .byte.b	21
      0  227f					      IJMP	CO
      0  227f					      db	29
      1  227f		       1d		      .byte.b	29
      0  2280					      dw	CO
      1  2280		       c5 20		      .word.w	CO
    459  2282							;=======================================================================
    460  2282							;RUN begin to executed the program in memory
    461  2282							;
    462  2282				   S15
      0  2282					      TSTB	S16,kRun	;RUN COMMAND
      0  2282					      db	101
      1  2282		       65		      .byte.b	101
      0  2283					      db	(S16-*)-1
      1  2283		       0a		      .byte.b	(S16-*)-1
      0  2284					      db	kRun
      1  2284		       17		      .byte.b	kRun
    464  2285				   ekRun
      0  2285					      DONE
      0  2285					      db	1
      1  2285		       01		      .byte.b	1
      0  2286					      VINIT		;clear variables
      0  2286					      db	30
      1  2286		       1e		      .byte.b	30
      0  2287					      LIT	1	;GOTO line 1
      0  2287					      db	27
      1  2287		       1b		      .byte.b	27
      0  2288					      dw	1
      1  2288		       01 00		      .word.w	1
      0  228a					      XFER		;Bob's addition
      0  228a					      db	7
      1  228a		       07		      .byte.b	7
    469  228b							; EXIT
      0  228b					      IJMP	STMT	;and run!
      0  228b					      db	29
      1  228b		       1d		      .byte.b	29
      0  228c					      dw	STMT
      1  228c		       cd 20		      .word.w	STMT
    471  228e							;=========================================================================
    472  228e							;Clear the program memory, delete all proram lines
    473  228e							;
    474  228e				   S16
      0  228e					      TSTB	S16A,kNew	;clear program
      0  228e					      db	101
      1  228e		       65		      .byte.b	101
      0  228f					      db	(S16A-*)-1
      1  228f		       05		      .byte.b	(S16A-*)-1
      0  2290					      db	kNew
      1  2290		       18		      .byte.b	kNew
    476  2291				   ekNew
      0  2291					      DONE
      0  2291					      db	1
      1  2291		       01		      .byte.b	1
      0  2292					      IJMP	START
      0  2292					      db	29
      1  2292		       1d		      .byte.b	29
      0  2293					      dw	START
      1  2293		       bf 20		      .word.w	START
    479  2295
    480  2295							;========================================================================
    481  2295							; Slice(slice legth expression)
    482  2295							;   set the length of time between task switches
    483  2295							;
    484  2295				   S16A
      0  2295					      TSTB	S16Trace,kSlice
      0  2295					      db	101
      1  2295		       65		      .byte.b	101
      0  2296					      db	(S16Trace-*)-1
      1  2296		       0c		      .byte.b	(S16Trace-*)-1
      0  2297					      db	kSlice
      1  2297		       19		      .byte.b	kSlice
    486  2298				   ekSlice
      0  2298					      CALL	EXPR
      0  2298					      db	28
      1  2298		       1c		      .byte.b	28
      0  2299					      dw	EXPR
      1  2299		       e5 22		      .word.w	EXPR
      0  229b					      SLICE
      0  229b					      db	100
      1  229b		       64		      .byte.b	100
      0  229c					      DONE
      0  229c					      db	1
      1  229c		       01		      .byte.b	1
      0  229d					      NXT	CO
      0  229d					      db	6
      1  229d		       06		      .byte.b	6
      0  229e					      dw	CO
      1  229e		       c5 20		      .word.w	CO
      0  22a0					      IJMP	STMT
      0  22a0					      db	29
      1  22a0		       1d		      .byte.b	29
      0  22a1					      dw	STMT
      1  22a1		       cd 20		      .word.w	STMT
    492  22a3							;==========================================================================
    493  22a3							; Turn off and on the thrace functions
    494  22a3							; a debug terminal needs to be available
    495  22a3							; Trace( Trace flag expression)
    496  22a3							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    497  22a3							;	for individual lines of basic code. These can be combined
    498  22a3				   S16Trace
      0  22a3					      TSTB	S17A,kTrace
      0  22a3					      db	101
      1  22a3		       65		      .byte.b	101
      0  22a4					      db	(S17A-*)-1
      1  22a4		       12		      .byte.b	(S17A-*)-1
      0  22a5					      db	kTrace
      1  22a5		       1a		      .byte.b	kTrace
    500  22a6				   ekTrace
      0  22a6					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  22a6					      db	101
      1  22a6		       65		      .byte.b	101
      0  22a7					      db	(UNKNOWN-*)-1
      1  22a7		       39		      .byte.b	(UNKNOWN-*)-1
      0  22a8					      db	oLeftBracket
      1  22a8		       e0		      .byte.b	oLeftBracket
      0  22a9					      CALL	EXPR
      0  22a9					      db	28
      1  22a9		       1c		      .byte.b	28
      0  22aa					      dw	EXPR
      1  22aa		       e5 22		      .word.w	EXPR
      0  22ac					      TSTB	UNKNOWN,oRightBracket
      0  22ac					      db	101
      1  22ac		       65		      .byte.b	101
      0  22ad					      db	(UNKNOWN-*)-1
      1  22ad		       33		      .byte.b	(UNKNOWN-*)-1
      0  22ae					      db	oRightBracket
      1  22ae		       e1		      .byte.b	oRightBracket
      0  22af					      TRACEPROGRAM
      0  22af					      db	78
      1  22af		       4e		      .byte.b	78
      0  22b0					      DONE
      0  22b0					      db	1
      1  22b0		       01		      .byte.b	1
      0  22b1					      NXT	CO
      0  22b1					      db	6
      1  22b1		       06		      .byte.b	6
      0  22b2					      dw	CO
      1  22b2		       c5 20		      .word.w	CO
      0  22b4					      IJMP	STMT
      0  22b4					      db	29
      1  22b4		       1d		      .byte.b	29
      0  22b5					      dw	STMT
      1  22b5		       cd 20		      .word.w	STMT
    508  22b7							;=====================================================================
    509  22b7							; Exit basic to machine monitor
    510  22b7							;
    511  22b7				   S17A
      0  22b7					      TSTB	S17B,kExit	;allow them to exit BASIC
      0  22b7					      db	101
      1  22b7		       65		      .byte.b	101
      0  22b8					      db	(S17B-*)-1
      1  22b8		       02		      .byte.b	(S17B-*)-1
      0  22b9					      db	kExit
      1  22b9		       1b		      .byte.b	kExit
    513  22ba				   ekExit
      0  22ba					      EXIT
      0  22ba					      db	26
      1  22ba		       1a		      .byte.b	26
    515  22bb
    516  22bb							;=======================================================================
    517  22bb							; Commands related to saving/restoring programs
    518  22bb							; to/from mass storage.
    519  22bb							;
    520  22bb				   S17B
    521  22bb					      if	(XKIM || CTMON65) && DISK_ACCESS
    522  22bb
      0  22bb					      TSTB	S17C,kSave
      0  22bb					      db	101
      1  22bb		       65		      .byte.b	101
      0  22bc					      db	(S17C-*)-1
      1  22bc		       07		      .byte.b	(S17C-*)-1
      0  22bd					      db	kSave
      1  22bd		       1c		      .byte.b	kSave
    524  22be				   ekSave
      0  22be					      OPENWRITE
      0  22be					      db	40
      1  22be		       28		      .byte.b	40
      0  22bf					      DLIST
      0  22bf					      db	43
      1  22bf		       2b		      .byte.b	43
      0  22c0					      DCLOSE
      0  22c0					      db	41
      1  22c0		       29		      .byte.b	41
      0  22c1					      IJMP	CO
      0  22c1					      db	29
      1  22c1		       1d		      .byte.b	29
      0  22c2					      dw	CO
      1  22c2		       c5 20		      .word.w	CO
    529  22c4
    530  22c4				   S17C
      0  22c4					      TSTB	S18,kLoad
      0  22c4					      db	101
      1  22c4		       65		      .byte.b	101
      0  22c5					      db	(S18-*)-1
      1  22c5		       0d		      .byte.b	(S18-*)-1
      0  22c6					      db	kLoad
      1  22c6		       1d		      .byte.b	kLoad
    532  22c7				   ekLoad
      0  22c7					      OPENREAD
      0  22c7					      db	39
      1  22c7		       27		      .byte.b	39
    534  22c8				   S17CLP
      0  22c8					      DGETLINE		;get line from file
      0  22c8					      db	42
      1  22c8		       2a		      .byte.b	42
      0  22c9					      TSTL	S17EOL	;no line num means EOL
      0  22c9					      db	34
      1  22c9		       22		      .byte.b	34
      0  22ca					      db	(S17EOL-*)-1
      1  22ca		       04		      .byte.b	(S17EOL-*)-1
      0  22cb					      INSERT		;put it into the program
      0  22cb					      db	24
      1  22cb		       18		      .byte.b	24
      0  22cc					      IJMP	S17CLP	;keep going
      0  22cc					      db	29
      1  22cc		       1d		      .byte.b	29
      0  22cd					      dw	S17CLP
      1  22cd		       c8 22		      .word.w	S17CLP
    539  22cf				   S17EOL
      0  22cf					      DCLOSE		;close disk file
      0  22cf					      db	41
      1  22cf		       29		      .byte.b	41
      0  22d0					      IJMP	CO	;back to start
      0  22d0					      db	29
      1  22d0		       1d		      .byte.b	29
      0  22d1					      dw	CO
      1  22d1		       c5 20		      .word.w	CO
    542  22d3
    543  22d3				   S18
      0  22d3					      TSTB	S19,kDir
      0  22d3					      db	101
      1  22d3		       65		      .byte.b	101
      0  22d4					      db	(S19-*)-1
      1  22d4		       05		      .byte.b	(S19-*)-1
      0  22d5					      db	kDir
      1  22d5		       1f		      .byte.b	kDir
    545  22d6				   ekDir
      0  22d6					      DDIR		;Display the directory content
      0  22d6					      db	44
      1  22d6		       2c		      .byte.b	44
      0  22d7					      IJMP	CO
      0  22d7					      db	29
      1  22d7		       1d		      .byte.b	29
      0  22d8					      dw	CO
      1  22d8		       c5 20		      .word.w	CO
    548  22da							;=========================================================================
    549  22da							; Erase a file from disk
    550  22da							;
      0  22da				   S19	      TSTB	UNKNOWN,kErase
      0  22da					      db	101
      1  22da		       65		      .byte.b	101
      0  22db					      db	(UNKNOWN-*)-1
      1  22db		       05		      .byte.b	(UNKNOWN-*)-1
      0  22dc					      db	kErase
      1  22dc		       1e		      .byte.b	kErase
    552  22dd				   ekErase
      0  22dd					      RMFILE		;Erase the file from the disk
      0  22dd					      db	45
      1  22dd		       2d		      .byte.b	45
      0  22de					      IJMP	CO
      0  22de					      db	29
      1  22de		       1d		      .byte.b	29
      0  22df					      dw	CO
      1  22df		       c5 20		      .word.w	CO
    555  22e1
    556  22e1					      endif
    557  22e1
    558  22e1							;
    559  22e1							; Else, unknown command.
    560  22e1							;
    561  22e1				   UNKNOWN
      0  22e1					      ENDIO
      0  22e1					      db	71
      1  22e1		       47		      .byte.b	71
    563  22e2
    564  22e2				   NotKnownStatement
    565  22e2
      0  22e2					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  22e2					      db	13
      1  22e2		       0d		      .byte.b	13
      0  22e3					      dw	ERR_SYNTAX
      1  22e3		       05 00		      .word.w	ERR_SYNTAX
    567  22e5
    568  22e5							;=======================================================
    569  22e5							; Process Expresions, precidence is represented by the
    570  22e5							; various call levels
    571  22e5							;
    572  22e5				   EXPR
      0  22e5					      TSTB	EXPRLOGS,kNot
      0  22e5					      db	101
      1  22e5		       65		      .byte.b	101
      0  22e6					      db	(EXPRLOGS-*)-1
      1  22e6		       06		      .byte.b	(EXPRLOGS-*)-1
      0  22e7					      db	kNot
      1  22e7		       20		      .byte.b	kNot
    574  22e8				   ekNot
      0  22e8					      Call	EXPR
      0  22e8					      db	28
      1  22e8		       1c		      .byte.b	28
      0  22e9					      dw	EXPR
      1  22e9		       e5 22		      .word.w	EXPR
      0  22eb					      LOGNOT
      0  22eb					      db	72
      1  22eb		       48		      .byte.b	72
      0  22ec					      RTN
      0  22ec					      db	25
      1  22ec		       19		      .byte.b	25
    578  22ed
    579  22ed							;=========================================================
    580  22ed							;Look for logical operators
    581  22ed				   EXPRLOGS
      0  22ed					      Call	EXPRCMP
      0  22ed					      db	28
      1  22ed		       1c		      .byte.b	28
      0  22ee					      dw	EXPRCMP
      1  22ee		       08 23		      .word.w	EXPRCMP
      0  22f0					      TSTB	iLOG1,kAnd
      0  22f0					      db	101
      1  22f0		       65		      .byte.b	101
      0  22f1					      db	(iLOG1-*)-1
      1  22f1		       06		      .byte.b	(iLOG1-*)-1
      0  22f2					      db	kAnd
      1  22f2		       23		      .byte.b	kAnd
    584  22f3				   ekAnd
      0  22f3					      Call	EXPR
      0  22f3					      db	28
      1  22f3		       1c		      .byte.b	28
      0  22f4					      dw	EXPR
      1  22f4		       e5 22		      .word.w	EXPR
      0  22f6					      LOGAND
      0  22f6					      db	74
      1  22f6		       4a		      .byte.b	74
      0  22f7					      RTN
      0  22f7					      db	25
      1  22f7		       19		      .byte.b	25
    588  22f8				   iLOG1
      0  22f8					      TSTB	iLOG2,kOr
      0  22f8					      db	101
      1  22f8		       65		      .byte.b	101
      0  22f9					      db	(iLOG2-*)-1
      1  22f9		       06		      .byte.b	(iLOG2-*)-1
      0  22fa					      db	kOr
      1  22fa		       21		      .byte.b	kOr
    590  22fb				   ekOr
      0  22fb					      Call	EXPR
      0  22fb					      db	28
      1  22fb		       1c		      .byte.b	28
      0  22fc					      dw	EXPR
      1  22fc		       e5 22		      .word.w	EXPR
      0  22fe					      LOGOR
      0  22fe					      db	73
      1  22fe		       49		      .byte.b	73
      0  22ff					      RTN
      0  22ff					      db	25
      1  22ff		       19		      .byte.b	25
    594  2300				   iLOG2
      0  2300					      TSTB	iLOG3,kXor
      0  2300					      db	101
      1  2300		       65		      .byte.b	101
      0  2301					      db	(iLOG3-*)-1
      1  2301		       05		      .byte.b	(iLOG3-*)-1
      0  2302					      db	kXor
      1  2302		       22		      .byte.b	kXor
    596  2303				   ekXor
      0  2303					      Call	EXPR
      0  2303					      db	28
      1  2303		       1c		      .byte.b	28
      0  2304					      dw	EXPR
      1  2304		       e5 22		      .word.w	EXPR
      0  2306					      LOGXOR
      0  2306					      db	75
      1  2306		       4b		      .byte.b	75
    599  2307				   iLOG3
      0  2307					      RTN
      0  2307					      db	25
      1  2307		       19		      .byte.b	25
    601  2308
    602  2308				   EXPRCMP
      0  2308					      Call	EXPR2	; get the first expression
      0  2308					      db	28
      1  2308		       1c		      .byte.b	28
      0  2309					      dw	EXPR2
      1  2309		       13 23		      .word.w	EXPR2
      0  230b					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  230b					      db	104
      1  230b		       68		      .byte.b	104
      0  230c					      db	(iRDone-*)-1
      1  230c		       05		      .byte.b	(iRDone-*)-1
    605  230d							;	  TSTB	     iR0,oEqual
    606  230d							;	  LIT	     2		     ;=
    607  230d							;	  IJMP	     iRFound
    608  230d							;iR0:
    609  230d							;	  TSTB	      iR1,oLessEqual
    610  230d							;	  LIT	      3 	      ;<=
    611  230d							;	  IJMP	     iRFound
    612  230d							;iR1:
    613  230d							;	  TSTB	     iR3,oNotEqual
    614  230d							;	  LIT	     5		      ;<>
    615  230d							;	      IJMP	  iRFound
    616  230d							;iR3:
    617  230d							;	  TSTB	     iR4,oLess
    618  230d							;	  LIT	     1		     ;<
    619  230d							;	      IJMP	  iRFound
    620  230d							;iR4:
    621  230d							;	  TST	     iR5,oGreaterEqual
    622  230d							;	  LIT	     6		     ;>=
    623  230d							;	      IJMP	  iRFound
    624  230d							;iR5:
    625  230d							;	  TSTB	     iRDone,oGreater
    626  230d							;	  LIT	     4		     ;>
    627  230d				   iRFound
      0  230d					      Call	EXPR	; get the right side of the expression
      0  230d					      db	28
      1  230d		       1c		      .byte.b	28
      0  230e					      dw	EXPR
      1  230e		       e5 22		      .word.w	EXPR
      0  2310					      CMPR		; Push the value of the true false onto the stack
      0  2310					      db	10
      1  2310		       0a		      .byte.b	10
      0  2311					      RTN
      0  2311					      db	25
      1  2311		       19		      .byte.b	25
    631  2312
    632  2312				   iRDone
      0  2312					      RTN
      0  2312					      db	25
      1  2312		       19		      .byte.b	25
    634  2313
    635  2313				   EXPR2
      0  2313					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  2313					      db	101
      1  2313		       65		      .byte.b	101
      0  2314					      db	(E0-*)-1
      1  2314		       08		      .byte.b	(E0-*)-1
      0  2315					      db	oMinus
      1  2315		       ea		      .byte.b	oMinus
      0  2316					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  2316					      db	28
      1  2316		       1c		      .byte.b	28
      0  2317					      dw	TERM
      1  2317		       39 23		      .word.w	TERM
      0  2319					      NEG		; Make value negated
      0  2319					      db	16
      1  2319		       10		      .byte.b	16
      0  231a					      IJMP	E1	; We have Left term process operators next
      0  231a					      db	29
      1  231a		       1d		      .byte.b	29
      0  231b					      dw	E1
      1  231b		       23 23		      .word.w	E1
    640  231d				   E0
      0  231d					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  231d					      db	101
      1  231d		       65		      .byte.b	101
      0  231e					      db	(E1A-*)-1
      1  231e		       01		      .byte.b	(E1A-*)-1
      0  231f					      db	oPlus
      1  231f		       e9		      .byte.b	oPlus
    642  2320				   E1A
      0  2320					      CALL	TERM	; Get the left term if it was not negated
      0  2320					      db	28
      1  2320		       1c		      .byte.b	28
      0  2321					      dw	TERM
      1  2321		       39 23		      .word.w	TERM
    644  2323				   E1
      0  2323					      TST	E2,oPlus	; Check if we are adding left term to something
      0  2323					      db	32
      1  2323		       20		      .byte.b	32
      0  2324					      db	(E2-*)-1
      1  2324		       09		      .byte.b	(E2-*)-1
      0  2325					      db	oPlus,0
      1  2325		       e9 00		      .byte.b	oPlus,0
      0  2327					      CALL	TERM	; if adding then get the right side term
      0  2327					      db	28
      1  2327		       1c		      .byte.b	28
      0  2328					      dw	TERM
      1  2328		       39 23		      .word.w	TERM
      0  232a					      ADD		; Add it to left term
      0  232a					      db	14
      1  232a		       0e		      .byte.b	14
      0  232b					      IJMP	E1	; look for next + or -
      0  232b					      db	29
      1  232b		       1d		      .byte.b	29
      0  232c					      dw	E1
      1  232c		       23 23		      .word.w	E1
    649  232e				   E2
      0  232e					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  232e					      db	101
      1  232e		       65		      .byte.b	101
      0  232f					      db	(E3-*)-1
      1  232f		       08		      .byte.b	(E3-*)-1
      0  2330					      db	oMinus
      1  2330		       ea		      .byte.b	oMinus
      0  2331					      CALL	TERM	; get right side to subtract Diffrence
      0  2331					      db	28
      1  2331		       1c		      .byte.b	28
      0  2332					      dw	TERM
      1  2332		       39 23		      .word.w	TERM
      0  2334					      SUB		; Subtract the value
      0  2334					      db	15
      1  2334		       0f		      .byte.b	15
      0  2335					      IJMP	E1	; Look for next + or -
      0  2335					      db	29
      1  2335		       1d		      .byte.b	29
      0  2336					      dw	E1
      1  2336		       23 23		      .word.w	E1
    654  2338				   E3			; Finish processing the expression
      0  2338					      RTN		; We are finished processing the Expression
      0  2338					      db	25
      1  2338		       19		      .byte.b	25
    656  2339							;
    657  2339							; Get one of the terms of an expression
    658  2339							;
    659  2339				   TERM
      0  2339					      CALL	FACT	; Get a value
      0  2339					      db	28
      1  2339		       1c		      .byte.b	28
      0  233a					      dw	FACT
      1  233a		       5e 23		      .word.w	FACT
    661  233c				   T0			; Check for higher precidence operators
      0  233c					      TSTB	T1,oMultiply	; Check for *
      0  233c					      db	101
      1  233c		       65		      .byte.b	101
      0  233d					      db	(T1-*)-1
      1  233d		       08		      .byte.b	(T1-*)-1
      0  233e					      db	oMultiply
      1  233e		       ed		      .byte.b	oMultiply
      0  233f					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  233f					      db	28
      1  233f		       1c		      .byte.b	28
      0  2340					      dw	FACT
      1  2340		       5e 23		      .word.w	FACT
      0  2342					      MUL		; Multiply factors
      0  2342					      db	17
      1  2342		       11		      .byte.b	17
      0  2343					      IJMP	T0	; Check for * or /
      0  2343					      db	29
      1  2343		       1d		      .byte.b	29
      0  2344					      dw	T0
      1  2344		       3c 23		      .word.w	T0
    666  2346				   T1
      0  2346					      TSTB	T2,oDivide	; Check for a division
      0  2346					      db	101
      1  2346		       65		      .byte.b	101
      0  2347					      db	(T2-*)-1
      1  2347		       08		      .byte.b	(T2-*)-1
      0  2348					      db	oDivide
      1  2348		       eb		      .byte.b	oDivide
      0  2349					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2349					      db	28
      1  2349		       1c		      .byte.b	28
      0  234a					      dw	FACT
      1  234a		       5e 23		      .word.w	FACT
      0  234c					      DIV		; do division
      0  234c					      db	18
      1  234c		       12		      .byte.b	18
      0  234d					      IJMP	T0	; check for more * or /
      0  234d					      db	29
      1  234d		       1d		      .byte.b	29
      0  234e					      dw	T0
      1  234e		       3c 23		      .word.w	T0
    671  2350				   T2
      0  2350					      TSTB	T3,oModulo	; Check for a division
      0  2350					      db	101
      1  2350		       65		      .byte.b	101
      0  2351					      db	(T3-*)-1
      1  2351		       08		      .byte.b	(T3-*)-1
      0  2352					      db	oModulo
      1  2352		       ec		      .byte.b	oModulo
      0  2353					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2353					      db	28
      1  2353		       1c		      .byte.b	28
      0  2354					      dw	FACT
      1  2354		       5e 23		      .word.w	FACT
      0  2356					      MODULO		; do division for remainder
      0  2356					      db	60
      1  2356		       3c		      .byte.b	60
      0  2357					      IJMP	T0	; check for more * or / or %
      0  2357					      db	29
      1  2357		       1d		      .byte.b	29
      0  2358					      dw	T0
      1  2358		       3c 23		      .word.w	T0
    676  235a				   T3			; Finish processing the Term
      0  235a					      RTN
      0  235a					      db	25
      1  235a		       19		      .byte.b	25
    678  235b
    679  235b				   UNKNOWNVEC
      0  235b					      IJMP	UNKNOWN
      0  235b					      db	29
      1  235b		       1d		      .byte.b	29
      0  235c					      dw	UNKNOWN
      1  235c		       e1 22		      .word.w	UNKNOWN
    681  235e
    682  235e							;=============================================================================================
    683  235e							; Factor an expression.  Always test for functions
    684  235e							; first or else they'll be confused for variables.
    685  235e							;
    686  235e				   FACT
      0  235e					      OnGoto	BasicFuncs,FactVariable
      0  235e					      db	103
      1  235e		       67		      .byte.b	103
      0  235f					      dw	BasicFuncs
      1  235f		       9f 20		      .word.w	BasicFuncs
      0  2361					      dw	FactVariable
      1  2361		       4b 24		      .word.w	FactVariable
    688  2363
    689  2363				   FACTCONTINUE
      0  2363					      TSTB	F1AA,kTrue
      0  2363					      db	101
      1  2363		       65		      .byte.b	101
      0  2364					      db	(F1AA-*)-1
      1  2364		       05		      .byte.b	(F1AA-*)-1
      0  2365					      db	kTrue
      1  2365		       24		      .byte.b	kTrue
    691  2366				   ekTrue
      0  2366					      LIT	-1
      0  2366					      db	27
      1  2366		       1b		      .byte.b	27
      0  2367					      dw	-1
      1  2367		       ff ff		      .word.w	-1
      0  2369					      RTN
      0  2369					      db	25
      1  2369		       19		      .byte.b	25
    694  236a				   F1AA
      0  236a					      TSTB	F1AB,kFalse
      0  236a					      db	101
      1  236a		       65		      .byte.b	101
      0  236b					      db	(F1AB-*)-1
      1  236b		       05		      .byte.b	(F1AB-*)-1
      0  236c					      db	kFalse
      1  236c		       25		      .byte.b	kFalse
    696  236d				   ekFalse
      0  236d					      LIT	0
      0  236d					      db	27
      1  236d		       1b		      .byte.b	27
      0  236e					      dw	0
      1  236e		       00 00		      .word.w	0
      0  2370					      RTN
      0  2370					      db	25
      1  2370		       19		      .byte.b	25
    699  2371							;==================================================================================
    700  2371							; Returns the amount of free SPACE
    701  2371							;
    702  2371				   F1AB
      0  2371					      TSTB	F1A,kFree
      0  2371					      db	101
      1  2371		       65		      .byte.b	101
      0  2372					      db	(F1A-*)-1
      1  2372		       09		      .byte.b	(F1A-*)-1
      0  2373					      db	kFree
      1  2373		       26		      .byte.b	kFree
    704  2374				   ekFree
      0  2374					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2374					      db	101
      1  2374		       65		      .byte.b	101
      0  2375					      db	(UNKNOWNVEC-*)-1
      1  2375		       e5		      .byte.b	(UNKNOWNVEC-*)-1
      0  2376					      db	oLeftBracket
      1  2376		       e0		      .byte.b	oLeftBracket
      0  2377					      TSTB	UNKNOWNVEC,oRightBracket
      0  2377					      db	101
      1  2377		       65		      .byte.b	101
      0  2378					      db	(UNKNOWNVEC-*)-1
      1  2378		       e2		      .byte.b	(UNKNOWNVEC-*)-1
      0  2379					      db	oRightBracket
      1  2379		       e1		      .byte.b	oRightBracket
      0  237a					      FREE
      0  237a					      db	36
      1  237a		       24		      .byte.b	36
      0  237b					      RTN
      0  237b					      db	25
      1  237b		       19		      .byte.b	25
    709  237c							;===================================================================================
    710  237c							; getch() read a character from the input device
    711  237c							;
    712  237c				   F1A
      0  237c					      TSTB	F1A2,kGetch	; read char from the terminal
      0  237c					      db	101
      1  237c		       65		      .byte.b	101
      0  237d					      db	(F1A2-*)-1
      1  237d		       09		      .byte.b	(F1A2-*)-1
      0  237e					      db	kGetch
      1  237e		       27		      .byte.b	kGetch
    714  237f				   ekGetch
      0  237f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  237f					      db	101
      1  237f		       65		      .byte.b	101
      0  2380					      db	(UNKNOWNVEC-*)-1
      1  2380		       da		      .byte.b	(UNKNOWNVEC-*)-1
      0  2381					      db	oLeftBracket
      1  2381		       e0		      .byte.b	oLeftBracket
      0  2382					      TSTB	UNKNOWNVEC,oRightBracket
      0  2382					      db	101
      1  2382		       65		      .byte.b	101
      0  2383					      db	(UNKNOWNVEC-*)-1
      1  2383		       d7		      .byte.b	(UNKNOWNVEC-*)-1
      0  2384					      db	oRightBracket
      1  2384		       e1		      .byte.b	oRightBracket
      0  2385					      GETCHAR
      0  2385					      db	51
      1  2385		       33		      .byte.b	51
      0  2386					      RTN
      0  2386					      db	25
      1  2386		       19		      .byte.b	25
    719  2387							;====================================================================================
    720  2387							; peek(mem address) return the value of a byte in memory
    721  2387							; @[offset] return a word value from offset -- see tstv
    722  2387							;
    723  2387				   F1A2
      0  2387					      TSTB	F2AZ,kPeek	;Return a value from memory
      0  2387					      db	101
      1  2387		       65		      .byte.b	101
      0  2388					      db	(F2AZ-*)-1
      1  2388		       0c		      .byte.b	(F2AZ-*)-1
      0  2389					      db	kPeek
      1  2389		       28		      .byte.b	kPeek
    725  238a				   ekPeek
      0  238a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  238a					      db	101
      1  238a		       65		      .byte.b	101
      0  238b					      db	(UNKNOWNVEC-*)-1
      1  238b		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  238c					      db	oLeftBracket
      1  238c		       e0		      .byte.b	oLeftBracket
      0  238d					      CALL	EXPR	;Get the address to write to
      0  238d					      db	28
      1  238d		       1c		      .byte.b	28
      0  238e					      dw	EXPR
      1  238e		       e5 22		      .word.w	EXPR
      0  2390					      TSTB	UNKNOWNVEC,oRightBracket
      0  2390					      db	101
      1  2390		       65		      .byte.b	101
      0  2391					      db	(UNKNOWNVEC-*)-1
      1  2391		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  2392					      db	oRightBracket
      1  2392		       e1		      .byte.b	oRightBracket
      0  2393					      PEEKMEM
      0  2393					      db	48
      1  2393		       30		      .byte.b	48
      0  2394					      RTN
      0  2394					      db	25
      1  2394		       19		      .byte.b	25
    731  2395							;=======================================================================================
    732  2395							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    733  2395							;
    734  2395				   F2AZ
      0  2395					      TSTB	F2AZ1,kTask	;Check if we are setting a task start
      0  2395					      db	101
      1  2395		       65		      .byte.b	101
      0  2396					      db	(F2AZ1-*)-1
      1  2396		       1d		      .byte.b	(F2AZ1-*)-1
      0  2397					      db	kTask
      1  2397		       29		      .byte.b	kTask
    736  2398				   ekTask
      0  2398					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2398					      db	101
      1  2398		       65		      .byte.b	101
      0  2399					      db	(UNKNOWNVEC-*)-1
      1  2399		       c1		      .byte.b	(UNKNOWNVEC-*)-1
      0  239a					      db	oLeftBracket
      1  239a		       e0		      .byte.b	oLeftBracket
      0  239b					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  239b					      db	28
      1  239b		       1c		      .byte.b	28
      0  239c					      dw	EXPR
      1  239c		       e5 22		      .word.w	EXPR
      0  239e					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  239e					      db	61
      1  239e		       3d		      .byte.b	61
      0  239f					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  239f					      db	101
      1  239f		       65		      .byte.b	101
      0  23a0					      db	(F2AZNoParms-*)-1
      1  23a0		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  23a1					      db	oComma
      1  23a1		       e2		      .byte.b	oComma
      0  23a2					      SAVEMATHSTACK		;Push The mathstack
      0  23a2					      db	86
      1  23a2		       56		      .byte.b	86
      0  23a3					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  23a3					      db	89
      1  23a3		       59		      .byte.b	89
    743  23a4				   F2AZLOOP
      0  23a4					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  23a4					      db	28
      1  23a4		       1c		      .byte.b	28
      0  23a5					      dw	EXPR
      1  23a5		       e5 22		      .word.w	EXPR
      0  23a7					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  23a7					      db	101
      1  23a7		       65		      .byte.b	101
      0  23a8					      db	(F2AZEndParm-*)-1
      1  23a8		       04		      .byte.b	(F2AZEndParm-*)-1
      0  23a9					      db	oComma
      1  23a9		       e2		      .byte.b	oComma
      0  23aa					      IJMP	F2AZLOOP	;check for more
      0  23aa					      db	29
      1  23aa		       1d		      .byte.b	29
      0  23ab					      dw	F2AZLOOP
      1  23ab		       a4 23		      .word.w	F2AZLOOP
    747  23ad				   F2AZEndParm
      0  23ad					      RESTOREMATHSTACK		;Back to normal stack
      0  23ad					      db	87
      1  23ad		       57		      .byte.b	87
      0  23ae					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  23ae					      db	92
      1  23ae		       5c		      .byte.b	92
    750  23af				   F2AZNoParms
      0  23af					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  23af					      db	101
      1  23af		       65		      .byte.b	101
      0  23b0					      db	(UNKNOWNVEC-*)-1
      1  23b0		       aa		      .byte.b	(UNKNOWNVEC-*)-1
      0  23b1					      db	oRightBracket
      1  23b1		       e1		      .byte.b	oRightBracket
      0  23b2					      TASKENABLE		;Enable the task to execute
      0  23b2					      db	90
      1  23b2		       5a		      .byte.b	90
      0  23b3					      RTN		;Returns the Task number
      0  23b3					      db	25
      1  23b3		       19		      .byte.b	25
    754  23b4							;=========================================================================================
    755  23b4							; Check for IPC interproccess instructions
    756  23b4							;   IPCS  - Send a message
    757  23b4							;
    758  23b4				   F2AZ1
      0  23b4					      TSTB	F2AZa,kIpcs	;Test if one of the IPC functions
      0  23b4					      db	101
      1  23b4		       65		      .byte.b	101
      0  23b5					      db	(F2AZa-*)-1
      1  23b5		       12		      .byte.b	(F2AZa-*)-1
      0  23b6					      db	kIpcs
      1  23b6		       2b		      .byte.b	kIpcs
    760  23b7				   ekIpcs
      0  23b7					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  23b7					      db	101
      1  23b7		       65		      .byte.b	101
      0  23b8					      db	(UNKNOWNVEC-*)-1
      1  23b8		       a2		      .byte.b	(UNKNOWNVEC-*)-1
      0  23b9					      db	oLeftBracket
      1  23b9		       e0		      .byte.b	oLeftBracket
      0  23ba					      CALL	EXPR	;Get the message value
      0  23ba					      db	28
      1  23ba		       1c		      .byte.b	28
      0  23bb					      dw	EXPR
      1  23bb		       e5 22		      .word.w	EXPR
      0  23bd					      TSTB	UNKNOWNVEC,oComma
      0  23bd					      db	101
      1  23bd		       65		      .byte.b	101
      0  23be					      db	(UNKNOWNVEC-*)-1
      1  23be		       9c		      .byte.b	(UNKNOWNVEC-*)-1
      0  23bf					      db	oComma
      1  23bf		       e2		      .byte.b	oComma
      0  23c0					      CALL	EXPR	;Get pid of task to send to
      0  23c0					      db	28
      1  23c0		       1c		      .byte.b	28
      0  23c1					      dw	EXPR
      1  23c1		       e5 22		      .word.w	EXPR
      0  23c3					      TSTB	UNKNOWNVEC,oRightBracket
      0  23c3					      db	101
      1  23c3		       65		      .byte.b	101
      0  23c4					      db	(UNKNOWNVEC-*)-1
      1  23c4		       96		      .byte.b	(UNKNOWNVEC-*)-1
      0  23c5					      db	oRightBracket
      1  23c5		       e1		      .byte.b	oRightBracket
      0  23c6					      IPCSEND		;Send msg and clear pid msg pending
      0  23c6					      db	80
      1  23c6		       50		      .byte.b	80
      0  23c7					      RTN
      0  23c7					      db	25
      1  23c7		       19		      .byte.b	25
    768  23c8							;================================================================================
    769  23c8							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    770  23c8							;
    771  23c8				   F2AZa
      0  23c8					      TSTB	F2AZb,kIpcr	;IPCR recieve a message , wait if none
      0  23c8					      db	101
      1  23c8		       65		      .byte.b	101
      0  23c9					      db	(F2AZb-*)-1
      1  23c9		       15		      .byte.b	(F2AZb-*)-1
      0  23ca					      db	kIpcr
      1  23ca		       2c		      .byte.b	kIpcr
    773  23cb				   ekIpcr
      0  23cb					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  23cb					      db	101
      1  23cb		       65		      .byte.b	101
      0  23cc					      db	(UNKNOWNVEC-*)-1
      1  23cc		       8e		      .byte.b	(UNKNOWNVEC-*)-1
      0  23cd					      db	oLeftBracket
      1  23cd		       e0		      .byte.b	oLeftBracket
      0  23ce					      TSTB	F2AZa1,oRightBracket
      0  23ce					      db	101
      1  23ce		       65		      .byte.b	101
      0  23cf					      db	(F2AZa1-*)-1
      1  23cf		       07		      .byte.b	(F2AZa1-*)-1
      0  23d0					      db	oRightBracket
      1  23d0		       e1		      .byte.b	oRightBracket
      0  23d1					      LIT	0	;We dont want the pid returned to us
      0  23d1					      db	27
      1  23d1		       1b		      .byte.b	27
      0  23d2					      dw	0
      1  23d2		       00 00		      .word.w	0
      0  23d4					      IPCIO		;Set the io bit and suspend the task till message
      0  23d4					      db	83
      1  23d4		       53		      .byte.b	83
      0  23d5					      IPCRECEIVE		;Get the message
      0  23d5					      db	81
      1  23d5		       51		      .byte.b	81
      0  23d6					      RTN
      0  23d6					      db	25
      1  23d6		       19		      .byte.b	25
    780  23d7				   F2AZa1
      0  23d7					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  23d7					      db	33
      1  23d7		       21		      .byte.b	33
      0  23d8					      db	(UNKNOWNVEC-*)-1
      1  23d8		       82		      .byte.b	(UNKNOWNVEC-*)-1
      0  23d9					      TSTB	UNKNOWNVEC,oRightBracket
      0  23d9					      db	101
      1  23d9		       65		      .byte.b	101
      0  23da					      db	(UNKNOWNVEC-*)-1
      1  23da		       80		      .byte.b	(UNKNOWNVEC-*)-1
      0  23db					      db	oRightBracket
      1  23db		       e1		      .byte.b	oRightBracket
      0  23dc					      IPCIO		;Set the io bit and exit task till message
      0  23dc					      db	83
      1  23dc		       53		      .byte.b	83
      0  23dd					      IPCRECEIVE		;Get the message
      0  23dd					      db	81
      1  23dd		       51		      .byte.b	81
      0  23de					      RTN
      0  23de					      db	25
      1  23de		       19		      .byte.b	25
    786  23df							;===============================================================================
    787  23df							; IPCC ---- check if a message is available
    788  23df				   F2AZb
      0  23df					      TST	F2A,kIpcc	;Returns number of messages on the message queue
      0  23df					      db	32
      1  23df		       20		      .byte.b	32
      0  23e0					      db	(F2A-*)-1
      1  23e0		       0d		      .byte.b	(F2A-*)-1
      0  23e1					      db	kIpcc,0
      1  23e1		       2a 00		      .byte.b	kIpcc,0
    790  23e3				   ekIpcc
      0  23e3					      TSTB	UNKNOWNVEC,oLeftBracket
      0  23e3					      db	101
      1  23e3		       65		      .byte.b	101
      0  23e4					      db	(UNKNOWNVEC-*)-1
      1  23e4		       76		      .byte.b	(UNKNOWNVEC-*)-1
      0  23e5					      db	oLeftBracket
      1  23e5		       e0		      .byte.b	oLeftBracket
      0  23e6					      TSTB	UNKNOWNVEC,oRightBracket
      0  23e6					      db	101
      1  23e6		       65		      .byte.b	101
      0  23e7					      db	(UNKNOWNVEC-*)-1
      1  23e7		       73		      .byte.b	(UNKNOWNVEC-*)-1
      0  23e8					      db	oRightBracket
      1  23e8		       e1		      .byte.b	oRightBracket
      0  23e9					      IPCCHECK
      0  23e9					      db	82
      1  23e9		       52		      .byte.b	82
      0  23ea					      RTN
      0  23ea					      db	25
      1  23ea		       19		      .byte.b	25
    795  23eb
    796  23eb				   UNKNOWNID
      0  23eb					      IJMP	UNKNOWN
      0  23eb					      db	29
      1  23eb		       1d		      .byte.b	29
      0  23ec					      dw	UNKNOWN
      1  23ec		       e1 22		      .word.w	UNKNOWN
    798  23ee							;============================================================
    799  23ee							; RND() is supposed to have an argument but if none
    800  23ee							; was provided, just assume a large value.
    801  23ee							;
    802  23ee				   F2A
      0  23ee					      TSTB	F2B,kRnd
      0  23ee					      db	101
      1  23ee		       65		      .byte.b	101
      0  23ef					      db	(F2B-*)-1
      1  23ef		       14		      .byte.b	(F2B-*)-1
      0  23f0					      db	kRnd
      1  23f0		       2d		      .byte.b	kRnd
    804  23f1				   ekRnd
      0  23f1					      TSTB	UNKNOWNVEC,oLeftBracket
      0  23f1					      db	101
      1  23f1		       65		      .byte.b	101
      0  23f2					      db	(UNKNOWNVEC-*)-1
      1  23f2		       68		      .byte.b	(UNKNOWNVEC-*)-1
      0  23f3					      db	oLeftBracket
      1  23f3		       e0		      .byte.b	oLeftBracket
      0  23f4					      TSTB	F2A1,oRightBracket
      0  23f4					      db	101
      1  23f4		       65		      .byte.b	101
      0  23f5					      db	(F2A1-*)-1
      1  23f5		       06		      .byte.b	(F2A1-*)-1
      0  23f6					      db	oRightBracket
      1  23f6		       e1		      .byte.b	oRightBracket
      0  23f7					      LIT	32766
      0  23f7					      db	27
      1  23f7		       1b		      .byte.b	27
      0  23f8					      dw	32766
      1  23f8		       fe 7f		      .word.w	32766
      0  23fa					      RANDOM
      0  23fa					      db	37
      1  23fa		       25		      .byte.b	37
      0  23fb					      RTN
      0  23fb					      db	25
      1  23fb		       19		      .byte.b	25
    810  23fc
    811  23fc				   F2A1
      0  23fc					      CALL	FACT	;GET RANGE
      0  23fc					      db	28
      1  23fc		       1c		      .byte.b	28
      0  23fd					      dw	FACT
      1  23fd		       5e 23		      .word.w	FACT
      0  23ff					      TSTB	UNKNOWNVEC,oRightBracket
      0  23ff					      db	101
      1  23ff		       65		      .byte.b	101
      0  2400					      db	(UNKNOWNVEC-*)-1
      1  2400		       5a		      .byte.b	(UNKNOWNVEC-*)-1
      0  2401					      db	oRightBracket
      1  2401		       e1		      .byte.b	oRightBracket
      0  2402					      RANDOM
      0  2402					      db	37
      1  2402		       25		      .byte.b	37
      0  2403					      RTN
      0  2403					      db	25
      1  2403		       19		      .byte.b	25
    816  2404							;==========================================================
    817  2404							;	Return absolute value of expresion
    818  2404							;
    819  2404				   F2B
      0  2404					      TSTB	F2B2,kAbs
      0  2404					      db	101
      1  2404		       65		      .byte.b	101
      0  2405					      db	(F2B2-*)-1
      1  2405		       0c		      .byte.b	(F2B2-*)-1
      0  2406					      db	kAbs
      1  2406		       2f		      .byte.b	kAbs
    821  2407				   ekAbs
      0  2407					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2407					      db	101
      1  2407		       65		      .byte.b	101
      0  2408					      db	(UNKNOWNVEC-*)-1
      1  2408		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  2409					      db	oLeftBracket
      1  2409		       e0		      .byte.b	oLeftBracket
      0  240a					      CALL	EXPR	;get value
      0  240a					      db	28
      1  240a		       1c		      .byte.b	28
      0  240b					      dw	EXPR
      1  240b		       e5 22		      .word.w	EXPR
      0  240d					      TSTB	UNKNOWNVEC,oRightBracket
      0  240d					      db	101
      1  240d		       65		      .byte.b	101
      0  240e					      db	(UNKNOWNVEC-*)-1
      1  240e		       4c		      .byte.b	(UNKNOWNVEC-*)-1
      0  240f					      db	oRightBracket
      1  240f		       e1		      .byte.b	oRightBracket
      0  2410					      ABS
      0  2410					      db	38
      1  2410		       26		      .byte.b	38
      0  2411					      RTN
      0  2411					      db	25
      1  2411		       19		      .byte.b	25
    827  2412							;============================================================
    828  2412							;     Return the the status of a task, provide the PID
    829  2412							;
    830  2412				   F2B2
      0  2412					      TSTB	F2Z,kStat
      0  2412					      db	101
      1  2412		       65		      .byte.b	101
      0  2413					      db	(F2Z-*)-1
      1  2413		       0c		      .byte.b	(F2Z-*)-1
      0  2414					      db	kStat
      1  2414		       2e		      .byte.b	kStat
    832  2415				   ekStat
      0  2415					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2415					      db	101
      1  2415		       65		      .byte.b	101
      0  2416					      db	(UNKNOWNVEC-*)-1
      1  2416		       44		      .byte.b	(UNKNOWNVEC-*)-1
      0  2417					      db	oLeftBracket
      1  2417		       e0		      .byte.b	oLeftBracket
      0  2418					      Call	EXPR
      0  2418					      db	28
      1  2418		       1c		      .byte.b	28
      0  2419					      dw	EXPR
      1  2419		       e5 22		      .word.w	EXPR
      0  241b					      TSTB	UNKNOWNVEC,oRightBracket
      0  241b					      db	101
      1  241b		       65		      .byte.b	101
      0  241c					      db	(UNKNOWNVEC-*)-1
      1  241c		       3e		      .byte.b	(UNKNOWNVEC-*)-1
      0  241d					      db	oRightBracket
      1  241d		       e1		      .byte.b	oRightBracket
      0  241e					      TASKSTAT
      0  241e					      db	66
      1  241e		       42		      .byte.b	66
      0  241f					      RTN
      0  241f					      db	25
      1  241f		       19		      .byte.b	25
    838  2420				   F2Z
      0  2420					      TSTB	F2ZA,kPid
      0  2420					      db	101
      1  2420		       65		      .byte.b	101
      0  2421					      db	(F2ZA-*)-1
      1  2421		       03		      .byte.b	(F2ZA-*)-1
      0  2422					      db	kPid
      1  2422		       32		      .byte.b	kPid
    840  2423				   ekPid
      0  2423					      TASKPID
      0  2423					      db	77
      1  2423		       4d		      .byte.b	77
      0  2424					      RTN
      0  2424					      db	25
      1  2424		       19		      .byte.b	25
    843  2425							;===========================================================================
    844  2425							; Call a machine function, provide the address to call and optionally
    845  2425							; the value to be passed in reg A
    846  2425				   F2ZA
      0  2425					      TSTB	F2FUNC,kCall	;call machine function
      0  2425					      db	101
      1  2425		       65		      .byte.b	101
      0  2426					      db	(F2FUNC-*)-1
      1  2426		       1a		      .byte.b	(F2FUNC-*)-1
      0  2427					      db	kCall
      1  2427		       30		      .byte.b	kCall
    848  2428				   ekCall
      0  2428					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2428					      db	101
      1  2428		       65		      .byte.b	101
      0  2429					      db	(UNKNOWNVEC-*)-1
      1  2429		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  242a					      db	oLeftBracket
      1  242a		       e0		      .byte.b	oLeftBracket
      0  242b					      CALL	EXPR
      0  242b					      db	28
      1  242b		       1c		      .byte.b	28
      0  242c					      dw	EXPR
      1  242c		       e5 22		      .word.w	EXPR
      0  242e					      TSTB	F2B2A,oComma
      0  242e					      db	101
      1  242e		       65		      .byte.b	101
      0  242f					      db	(F2B2A-*)-1
      1  242f		       09		      .byte.b	(F2B2A-*)-1
      0  2430					      db	oComma
      1  2430		       e2		      .byte.b	oComma
      0  2431					      CALL	EXPR
      0  2431					      db	28
      1  2431		       1c		      .byte.b	28
      0  2432					      dw	EXPR
      1  2432		       e5 22		      .word.w	EXPR
      0  2434					      TSTB	UNKNOWNVEC,oRightBracket
      0  2434					      db	101
      1  2434		       65		      .byte.b	101
      0  2435					      db	(UNKNOWNVEC-*)-1
      1  2435		       25		      .byte.b	(UNKNOWNVEC-*)-1
      0  2436					      db	oRightBracket
      1  2436		       e1		      .byte.b	oRightBracket
      0  2437					      CALLFUNC
      0  2437					      db	53
      1  2437		       35		      .byte.b	53
      0  2438					      RTN
      0  2438					      db	25
      1  2438		       19		      .byte.b	25
    856  2439							; Run the gosub within this function
    857  2439				   F2B2A
      0  2439					      TSTB	UNKNOWNID,oRightBracket
      0  2439					      db	101
      1  2439		       65		      .byte.b	101
      0  243a					      db	(UNKNOWNID-*)-1
      1  243a		       b0		      .byte.b	(UNKNOWNID-*)-1
      0  243b					      db	oRightBracket
      1  243b		       e1		      .byte.b	oRightBracket
      0  243c					      LIT	0	; No parameter passed so just load zero to A
      0  243c					      db	27
      1  243c		       1b		      .byte.b	27
      0  243d					      dw	0
      1  243d		       00 00		      .word.w	0
      0  243f					      CALLFUNC
      0  243f					      db	53
      1  243f		       35		      .byte.b	53
      0  2440					      RTN
      0  2440					      db	25
      1  2440		       19		      .byte.b	25
    862  2441							;===========================================================================
    863  2441							; Same as gosub but expects a return value
    864  2441							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    865  2441							;
      0  2441				   F2FUNC     TSTB	F2C,kGofn
      0  2441					      db	101
      1  2441		       65		      .byte.b	101
      0  2442					      db	(F2C-*)-1
      1  2442		       08		      .byte.b	(F2C-*)-1
      0  2443					      db	kGofn
      1  2443		       31		      .byte.b	kGofn
    867  2444				   ekGofn
      0  2444					      Call	GOSUBSTATEMENT
      0  2444					      db	28
      1  2444		       1c		      .byte.b	28
      0  2445					      dw	GOSUBSTATEMENT
      1  2445		       70 24		      .word.w	GOSUBSTATEMENT
      0  2447					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  2447					      db	8
      1  2447		       08		      .byte.b	8
      0  2448					      db	GOSUB_RTN_VALUE
      1  2448		       81		      .byte.b	GOSUB_RTN_VALUE
      0  2449					      XFER
      0  2449					      db	7
      1  2449		       07		      .byte.b	7
    871  244a				   GOFNRet
      0  244a					      RTN
      0  244a					      db	25
      1  244a		       19		      .byte.b	25
    873  244b							;=============================================================================
    874  244b							; See if this is just a simple variable
    875  244b							;  Allow a subscript for any variable
    876  244b							;
    877  244b				   F2C
    878  244b
    879  244b				   FactVariable
      0  244b					      TSTV	F0
      0  244b					      db	33
      1  244b		       21		      .byte.b	33
      0  244c					      db	(F0-*)-1
      1  244c		       12		      .byte.b	(F0-*)-1
      0  244d					      TSTB	F2CLocalTask,oBang
      0  244d					      db	101
      1  244d		       65		      .byte.b	101
      0  244e					      db	(F2CLocalTask-*)-1
      1  244e		       04		      .byte.b	(F2CLocalTask-*)-1
      0  244f					      db	oBang
      1  244f		       e8		      .byte.b	oBang
      0  2450					      IND		; we just got a pid
      0  2450					      db	20
      1  2450		       14		      .byte.b	20
      0  2451					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  2451					      db	93
      1  2451		       5d		      .byte.b	93
      0  2452					      db	(UNKNOWNID-*)-1
      1  2452		       98		      .byte.b	(UNKNOWNID-*)-1
    884  2453
    885  2453				   F2CLocalTask
      0  2453					      TSTB	F2C1,oLeftSQBracket
      0  2453					      db	101
      1  2453		       65		      .byte.b	101
      0  2454					      db	(F2C1-*)-1
      1  2454		       08		      .byte.b	(F2C1-*)-1
      0  2455					      db	oLeftSQBracket
      1  2455		       e4		      .byte.b	oLeftSQBracket
      0  2456					      CALL	EXPR
      0  2456					      db	28
      1  2456		       1c		      .byte.b	28
      0  2457					      dw	EXPR
      1  2457		       e5 22		      .word.w	EXPR
      0  2459					      TSTB	UNKNOWNID,oRightSQBracket
      0  2459					      db	101
      1  2459		       65		      .byte.b	101
      0  245a					      db	(UNKNOWNID-*)-1
      1  245a		       90		      .byte.b	(UNKNOWNID-*)-1
      0  245b					      db	oRightSQBracket
      1  245b		       e5		      .byte.b	oRightSQBracket
      0  245c					      SUBSCRIPT
      0  245c					      db	64
      1  245c		       40		      .byte.b	64
    890  245d				   F2C1
      0  245d					      IND		;YES, GET THE VALUE.
      0  245d					      db	20
      1  245d		       14		      .byte.b	20
      0  245e					      RTN
      0  245e					      db	25
      1  245e		       19		      .byte.b	25
    893  245f							;=================================================================================
    894  245f							;Finally check for a number !
    895  245f							;
    896  245f				   F0
      0  245f					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  245f					      db	35
      1  245f		       23		      .byte.b	35
      0  2460					      db	(F1-*)-1
      1  2460		       01		      .byte.b	(F1-*)-1
      0  2461					      RTN
      0  2461					      db	25
      1  2461		       19		      .byte.b	25
    899  2462				   F1
      0  2462					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  2462					      db	101
      1  2462		       65		      .byte.b	101
      0  2463					      db	(F2RTN-*)-1
      1  2463		       08		      .byte.b	(F2RTN-*)-1
      0  2464					      db	oLeftBracket
      1  2464		       e0		      .byte.b	oLeftBracket
      0  2465					      CALL	EXPR
      0  2465					      db	28
      1  2465		       1c		      .byte.b	28
      0  2466					      dw	EXPR
      1  2466		       e5 22		      .word.w	EXPR
      0  2468					      TST	F2,oRightBracket
      0  2468					      db	32
      1  2468		       20		      .byte.b	32
      0  2469					      db	(F2-*)-1
      1  2469		       03		      .byte.b	(F2-*)-1
      0  246a					      db	oRightBracket,0
      1  246a		       e1 00		      .byte.b	oRightBracket,0
    903  246c				   F2RTN
      0  246c					      RTN
      0  246c					      db	25
      1  246c		       19		      .byte.b	25
    905  246d
    906  246d				   F2
      0  246d					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  246d					      db	13
      1  246d		       0d		      .byte.b	13
      0  246e					      dw	ERR_SYNTAX
      1  246e		       05 00		      .word.w	ERR_SYNTAX
    908  2470							;
    909  2470							;=============================================================
    910  2470							; Gosub can be both a Function and a Subroutine
    911  2470				   GOSUBSTATEMENT
      0  2470					      CALL	EXPR	;GET DESTINATION
      0  2470					      db	28
      1  2470		       1c		      .byte.b	28
      0  2471					      dw	EXPR
      1  2471		       e5 22		      .word.w	EXPR
      0  2473					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  2473					      db	101
      1  2473		       65		      .byte.b	101
      0  2474					      db	(GOSUBDONE-*)-1
      1  2474		       11		      .byte.b	(GOSUBDONE-*)-1
      0  2475					      db	oLeftBracket
      1  2475		       e0		      .byte.b	oLeftBracket
      0  2476					      STK2TMP		;Transfer stack top to temp
      0  2476					      db	95
      1  2476		       5f		      .byte.b	95
      0  2477					      PUSHMATHSTACK		;Record stack frame for return
      0  2477					      db	84
      1  2477		       54		      .byte.b	84
    916  2478				   GOSUBLOOP
      0  2478					      CALL	EXPR	; Allows what ever fits onto stack
      0  2478					      db	28
      1  2478		       1c		      .byte.b	28
      0  2479					      dw	EXPR
      1  2479		       e5 22		      .word.w	EXPR
      0  247b					      INCPARMCOUNT
      0  247b					      db	88
      1  247b		       58		      .byte.b	88
      0  247c					      TSTB	GOSUBParmDONE,oComma
      0  247c					      db	101
      1  247c		       65		      .byte.b	101
      0  247d					      db	(GOSUBParmDONE-*)-1
      1  247d		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  247e					      db	oComma
      1  247e		       e2		      .byte.b	oComma
      0  247f					      IJMP	GOSUBLOOP
      0  247f					      db	29
      1  247f		       1d		      .byte.b	29
      0  2480					      dw	GOSUBLOOP
      1  2480		       78 24		      .word.w	GOSUBLOOP
    921  2482				   GOSUBParmDONE
      0  2482					      TSTB	F2,oRightBracket
      0  2482					      db	101
      1  2482		       65		      .byte.b	101
      0  2483					      db	(F2-*)-1
      1  2483		       e9		      .byte.b	(F2-*)-1
      0  2484					      db	oRightBracket
      1  2484		       e1		      .byte.b	oRightBracket
      0  2485					      TMP2STK		;Restore line to goto
      0  2485					      db	96
      1  2485		       60		      .byte.b	96
    924  2486				   GOSUBDONE
      0  2486					      RTN
      0  2486					      db	25
      1  2486		       19		      .byte.b	25
    926  2487
    927  2487		       24 87	   ILEND      equ	*
------- FILE mytb.asm
   2319  2487		       24 87	   PROGEND    equ	*
   2320  2487
   2321  2487
   2322  2487							;=====================================================
   2323  2487							; Define start of non page zero data
   2324 U24c9					      seg.u	TBData
   2325 U24c9
   2326 U24c9							;=====================================================
   2327 U24c9							; These are storage items not in page zero.
   2328 U24c9							;
   2329 U24c9							; IRQ BASIC Code Service RTN Support
      0 U24c9				   SaveIrqReg db	0	; Store current setting
      1 U24c9		       00		      .byte.b	0
      0 U24ca				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U24ca		       00		      .byte.b	0
      0 U24cb				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U24cb		       00		      .byte.b	0
      0 U24cc				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U24cc		       00 00		      .byte.b	0,0
   2334 U24ce
   2335 U24ce							;
   2336 U24ce							;==================================================================================================
   2337 U24ce							; Task Management information
   2338 U24ce							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2339 U24ce							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2340 U24ce							; Task switchs happen at the beginning of the next Basic command line
   2341 U24ce							; It will not happen during an input or output operations
   2342 U24ce							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2343 U24ce							; Task Zero is always the root task, main line program
   2344 U24ce							;
   2345 U24ce							; Layout is repeated for each configured task
   2346 U24ce							; Task Table Byte   use masks follow
   2347 U24ce		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2348 U24ce		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2349 U24ce		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2350 U24ce		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2351 U24ce		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2352 U24ce
   2353 U24ce		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2354 U24cf		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2355 U24cf		       25 c9	   TASKTABLEEND equ	*	; End of task table
   2356 U24cf		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2357 U25c9
   2358 U25c9							;Task Cycle Counter and reset count
   2359 U25c9		       00 00	   taskCurrentCycles ds	2
   2360 U25cb		       00 00	   taskResetValue ds	2
   2361 U25cd		       00	   taskCounter ds	1	; Count of active tasks
   2362 U25ce
   2363 U25ce							;
   2364 U25ce							; Math stack and IL call and Gosub/For-next return stack definitions
   2365 U25ce							;
   2366 U25ce		       25 ce	   STACKSTART equ	*
   2367 U25ce		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2368 U275e		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2369 U28ee		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2370 U2b6e		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2371 U2b6e		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2372 U2b6e		       2d 8a	   STACKEND   equ	*
   2373 U2b6e		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2374 U2d8a							;
   2375 U2d8a							;
   2376 U2d8a		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2377 U2e0e		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2378 U2e0f		       00	   printtx    ds	1	;temp X for print funcs
   2379 U2e10		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2380 U2e11		       00	   promptChar ds	1	;the character to use for a prompt
   2381 U2e12		       00	   diddigit   ds	1	;for leading zero suppression
   2382 U2e13		       00	   putsy      ds	1
   2383 U2e14		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2384 U2e16		       00	   sign       ds	1	;0 = positive, else negative
   2385 U2e17		       00 00	   rtemp1     ds	2	;Temp for x and y
   2386 U2e19		       00 00	   random     ds	2
   2387 U2e1b		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2388 U2e1d		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2389 U2e1f		       00	   tempy      ds	1	;temp y storage
   2390 U2e20
   2391 U2e20							; Moved from page zero as one clock cycle diff gives more space on page zero
   2392 U2e20		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2393 U2e22		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2394 U2e23		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2395 U2e24		       00	   lineLength ds	1	;Length of current line
   2396 U2e25
   2397 U2e25		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2398 U2e26		       00	   taskRDPending ds	1	; 1 = background read is pending
   2399 U2e27
   2400 U2e27				  -	      if	XKIM
   2401 U2e27				  -buffer     ds	BUFFER_SIZE
   2402 U2e27					      endif
   2403 U2e27							;
   2404 U2e27							; PROGRAMEND is the end of the user's BASIC program.
   2405 U2e27							; More precisely, it is one byte past the end.  Or,
   2406 U2e27							; it's where the next line added to the end will be
   2407 U2e27							; placed.
   2408 U2e27							;
   2409 U2e27		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2410 U2e29		       00 00	   ProgramEnd ds	2	; End of users basic program
   2411 U2e2b		       00 00	   HighMem    ds	2	; highest location
   2412 U2e2d		       00 00	   UsedMem    ds	2	; size of user program
   2413 U2e2f		       00 00	   FreeMem    ds	2	; amount of free memory
   2414 U2e31							;
   2415 U2e31							;=====================================================
   2416 U2e31							; This is the start of the user's BASIC program space.
   2417 U2e31							;
   2418 U2e31							; PERSONAL GOAL: This should be no larger than $0DFF.
   2419 U2e31							;		  0200-05FF = 1K
   2420 U2e31							;		  0200-09FF = 2K
   2421 U2e31							;		  0200-0DFF = 3K
   2422 U2e31							;		  0200-11FF = 4K
   2423 U2e31							;		  0200-13FF = 4.5K
   2424 U2e31							;
   2425 U2e31				  -	      if	FIXED
   2426 U2e31				  -	      org	$2000
   2427 U2e31					      endif
   2428 U2e31
   2429 U2e31		       2e 31	   FreeMemStart equ	*
   2430 U2e31							;/*
   2431 U2e31							;	if	CTMON65 || XKIM
   2432 U2e31							;		SEG Code
   2433 U2e31							;		org	AutoRun
   2434 U2e31							;		dw	TBasicCold
   2435 U2e31							;	endif
   2436 U2e31							;*/
   2437 U2e31					      end
