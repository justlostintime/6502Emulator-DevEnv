------- FILE mytb.asm LEVEL 1 PASS 4
      1 U1b32				   input      processor	6502
      2 U1b32 ????						;=====================================================
      3 U1b32 ????						; Bob's Tiny BASIC
      4 U1b32 ????						;
      5 U1b32 ????						; While working on the Corsham Technologies KIM Clone
      6 U1b32 ????						; project, I wanted to include a TINY BASIC since that
      7 U1b32 ????						; was a highly desirable feature of early computers.
      8 U1b32 ????						;
      9 U1b32 ????						; Rather than negotiating copyright issues for
     10 U1b32 ????						; existing BASICs, I decided to just write one from
     11 U1b32 ????						; scratch.
     12 U1b32 ????						;
     13 U1b32 ????						; 10/07/2017
     14 U1b32 ????						;
     15 U1b32 ????						; This implements a stripped down Tiny BASIC
     16 U1b32 ????						; interpreter using the Interpretive Language (IL)
     17 U1b32 ????						; method as described in the first few issues of
     18 U1b32 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1b32 ????						; to write various languages simply by changing the
     20 U1b32 ????						; IL code rather than the interpreter itself.
     21 U1b32 ????						;
     22 U1b32 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1b32 ????						;		* Fixed major bug in findLine that
     24 U1b32 ????						;		  caused corrupted lines, crashes, etc.
     25 U1b32 ????						;		* If no parameter given to RND, assume
     26 U1b32 ????						;		  32766.
     27 U1b32 ????						;		* No more error 5 when a program
     28 U1b32 ????						;		  reaches the end without an END.
     29 U1b32 ????						;
     30 U1b32 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U1b32 ????						;		 * Add some usefull system level functions
     32 U1b32 ????						;		 * allow a larger number of tiny basic formats
     33 U1b32 ????						;		 * Add byte at start of line holding length
     34 U1b32 ????						;		   for faster execution of goto and gosub
     35 U1b32 ????						;		 * Re-added gosub
     36 U1b32 ????						;		 * allow ; or , at end if print stmt
     37 U1b32 ????						;		   without CRLF being added.
     38 U1b32 ????						;		 * Added extended function erase to
     39 U1b32 ????						;		   use the extended ctmon65 rm file
     40 U1b32 ????						;		 * Fix quoted text to not have to backtrack
     41 U1b32 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     42 U1b32 ????						;
     43 U1b32 ????						; www.corshamtech.com
     44 U1b32 ????						; bob@corshamtech.com
     45 U1b32 ????						; JustLostInTime@gmail.com
     46 U1b32 ????						;
     47 U1b32 ????						;=====================================================
     48 U1b32 ????						;
     49 U1b32 ????						; Create TRUE and FALSE values for conditionals.
     50 U1b32 ????						;
     51 U1b32 ????
     52 U1b32 ????	       00 00	   FALSE      equ	0
     53 U1b32 ????	       ff ff ff ff TRUE       equ	~FALSE
     54 U1b32 ????						;
     55 U1b32 ????						;---------------------------------------------------------
     56 U1b32 ????						; One of these must be set to indicate which environment
     57 U1b32 ????						; Tiny BASIC will be running in.  Here are the current
     58 U1b32 ????						; environments:
     59 U1b32 ????						;
     60 U1b32 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     61 U1b32 ????						; more K of RAM.
     62 U1b32 ????						;
     63 U1b32 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     64 U1b32 ????						; which enhances, without replacing, the standard KIM
     65 U1b32 ????						; monitor.  It gives access to routines to save/load files
     66 U1b32 ????						; to a micro SD card.
     67 U1b32 ????						;
     68 U1b32 ????						; CTMON65 is a from-scratch monitor written for the
     69 U1b32 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     70 U1b32 ????						; easily be ported to other systems.  It has support for
     71 U1b32 ????						; using a micro SD card for file storage/retrieval.
     72 U1b32 ????						;
     73 U1b32 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     74 U1b32 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     75 U1b32 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     76 U1b32 ????						;
     77 U1b32 ????						;   Need to define some macros for the dasm assembler
     78 U1b32 ????						;
     79 U1b32 ????				      MACRO	dw
     80 U1b32 ????				      .word	{0}
     81 U1b32 ????				      ENDM
     82 U1b32 ????
     83 U1b32 ????				      MACRO	db
     84 U1b32 ????				      .byte	{0}
     85 U1b32 ????				      ENDM
     86 U1b32 ????
     87 U1b32 ????						;
     88 U1b32 ????						; If set, include disk functions.
     89 U1b32 ????						;
     90 U1b32 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     91 U1b32 ????						;
     92 U1b32 ????						; If ILTRACE is set then dump out the address of every
     93 U1b32 ????						; IL opcode before executing it.
     94 U1b32 ????						;
     95 U1b32 ????	       00 00	   ILTRACE    equ	FALSE
     96 U1b32 ????						;
     97 U1b32 ????						; If FIXED is set, put the IL code and the user
     98 U1b32 ????						; program space at fixed locations in memory.	This is
     99 U1b32 ????						; meant only for debugging.
    100 U1b32 ????						;
    101 U1b32 ????	       00 00	   FIXED      equ	FALSE
    102 U1b32 ????						;
    103 U1b32 ????						; Sets the arithmetic stack depth.  This is *TINY*
    104 U1b32 ????						; BASIC, so keep this small!
    105 U1b32 ????						;
    106 U1b32 ????	       00 0a	   MATHSTACKSIZE equ	10	;number of entries in math stack
    107 U1b32 ????	       00 0a	   ILSTACKSIZE equ	10	;number of entries in ilstack
    108 U1b32 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/Fornext nesting max is 64 times TASKTABLE LENGTH must < 256
    109 U1b32 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    110 U1b32 ????	       00 c8	   TASKCYCLESDEFAULT equ	200	;Default Task Switch 0-255 uses a single byte
    111 U1b32 ????						;
    112 U1b32 ????						; Common ASCII constants
    113 U1b32 ????						;
    114 U1b32 ????	       00 07	   BEL	      equ	$07
    115 U1b32 ????	       00 08	   BS	      equ	$08
    116 U1b32 ????	       00 09	   TAB	      equ	$09
    117 U1b32 ????	       00 0a	   LF	      equ	$0A
    118 U1b32 ????	       00 0d	   CR	      equ	$0D
    119 U1b32 ????	       00 22	   quote      equ	$22
    120 U1b32 ????	       00 20	   SPACE      equ	$20
    121 U1b32 ????	       00 2c	   COMMA      equ	',
    122 U1b32 ????	       00 3b	   SEMICOLON  equ	';
    123 U1b32 ????	       00 3a	   COLON      equ	':
    124 U1b32 ????	       00 24	   DOLLAR     equ	'$
    125 U1b32 ????						;
    126 U1b32 ????						; These are error codes
    127 U1b32 ????						;
    128 U1b32 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    129 U1b32 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    130 U1b32 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    131 U1b32 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    132 U1b32 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    133 U1b32 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    134 U1b32 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    135 U1b32 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    136 U1b32 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    137 U1b32 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    138 U1b32 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    139 U1b32 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    140 U1b32 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    141 U1b32 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    142 U1b32 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    143 U1b32 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    144 U1b32 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    145 U1b32 ????						;
    146 U1b32 ????						;=====================================================
    147 U1b32 ????						; Zero page storage.
    148 U1b32 ????						;
    149 U1b32 ????				      SEG.U	Data
    150 U0040					      org	$0040
    151 U0040
    152 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    153 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    154 U0041		       00 75	   variablesEnd equ	*	;End of variable space
    155 U0075							;
    156 U0075							; The context is used to locate a task switch
    157 U0075							; it copies from here till all task fields are saved/swapped
    158 U0075							; The max number of tasks is 256 / context length
    159 U0075							;
    160 U0075		       00 75	   CONTEXT    equ	*
    161 U0075
    162 U0075		       00 00	   ILPC       ds	2	; IL program counter
    163 U0077		       00 00	   ILSTACK    ds	2	; IL call stack
    164 U0079		       00	   ILSTACKPTR ds	1
    165 U007a		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    166 U007c		       00	   MATHSTACKPTR ds	1
    167 U007d		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    168 U007f		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    169 U0080							;
    170 U0080							; CURPTR is a pointer to curent BASIC line being
    171 U0080							; executed.  Always points to start of line, CUROFF
    172 U0080							; is the offset to the current character.
    173 U0080							; The order of these fields is important
    174 U0080		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    175 U0082		       00	   CUROFF     ds	1	; Current offset in Basic Line
    176 U0083							;
    177 U0083							;The order of these fields in important
    178 U0083
    179 U0083							;
    180 U0083							; R0, R1 and MQ are used for arithmetic operations and
    181 U0083							; general use.
    182 U0083							;
    183 U0083		       00 83	   REGISTERS  equ	*	;IL MATH REGISTERS
    184 U0083		       00 00	   REG0       equ	0
    185 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    186 U0083		       00 02	   REG1       equ	2	;offset of R1
    187 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    188 U0085		       00 04	   REGMQ      equ	4	;offset og MQ
    189 U0087		       00 00	   MQ	      ds	2	;used for some math
    190 U0087		       00 89	   REGISTERSEND equ	*
    191 U0087		       00 06	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    192 U0089
    193 U0089		       00 89	   CONTEXTEND equ	*	; End of swap context
    194 U0089		       00 14	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    195 U0089
    196 U0089		       00 00	   dpl	      ds	2
    197 U008b		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    198 U008d		       00	   tempIlY    ds	1	;Temp IL Y register storage
    199 U008e		       00	   offset     ds	1	;IL Offset to next inst when test fails
    200 U008f		       00	   lineLength ds	1	;Length of current line
    201 U0090
    202 U0090		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
    203 U0091		       00	   taskRDPending ds	1	; 1 = background read is pending
    204 U0092
    205 U0092							;
    206 U0092							; This is zero if in immediate mode, or non-zero
    207 U0092							; if currently running a program.  Any input from
    208 U0092							; the main loop clears this, and the XFER IL
    209 U0092							; statement will set it.
    210 U0092							;
    211 U0092		       00	   RunMode    ds	1	;Basic program is running or stop
    212 U0093							;
    213 U0093							; Used for line insertion/removal.
    214 U0093							;
    215 U0093		       00 00	   FROM       ds	2	;Used for basic prog insert/remove and print text
    216 U0095
    217 U0095							; THE ADDRESS USED BY THE PRINTER FUNCTION
    218 U0095							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    219 U0095							;
    220 U0095		       00 93	   PrtFrom    EQU	FROM
    221 U0095							;
    222 U0095
    223 U0095							;
    224 U0095							;=====================================================
    225 U0095							;
    226  15ab ????				      SEG	Code
    227  0200					      org	$0200
    228  0200							;
    229  0200							; Cold start is at $0200.  Warm start is at $0203.
    230  0200							;
    231  0200		       4c 18 02    TBasicCold jmp	cold2	;jump around vectors
    232  0203		       4c ba 02    warm       jmp	warm2	;Entry point for worm restart
    233  0206							;
    234  0206							; These are the user-supplied vectors to I/O routines.
    235  0206							; If you want, you can just patch these in the binary
    236  0206							; file, but it would be better to change the source
    237  0206							; code.
    238  0206							;
    239  0206				  -	      if	KIM
    240  0206				  -OUTCH      jmp	$1ea0	;output char in A
    241  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    242  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    243  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    244  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    245  0206					      endif
    246  0206				  -	      if	XKIM
    247  0206				  -	      include	"xkim.inc"
    248  0206				  -	      SEG	Code
    249  0206				  -OUTCH      jmp	$1ea0
    250  0206				  -GETCH      jmp	xkGETCH
    251  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    252  0206				  -OUTHEX     jmp	xkPRTBYT
    253  0206				  -MONITOR    jmp	extKIM
    254  0206				  -puts       equ	putsil
    255  0206				  -BUFFER_SIZE equ	132
    256  0206					      endif
    257  0206
    258  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U00f6 ????				      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 U0095					      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    260  0206					      SEG	Code
    261  0206							;
    262  0206		       4c 0c f0    OUTCH      jmp	cout
    263  0209		       4c 09 f0    GETCH      jmp	cin
    264  020c		       4c 18 f0    CRLF       jmp	crlf
    265  020f		       4c 1b f0    OUTHEX     jmp	HexA
    266  0212		       4c 03 f0    MONITOR    jmp	WARM
    267  0215		       4c 0f f0    ISCHAR     jmp	cstatus
    268  0215		       f0 12	   puts       equ	putsil
    269  0218					      endif
    270  0218							;
    271  0218		       20 12 f0    cold2      jsr	puts
      0  021b					      db	CR,LF
      1  021b		       0d 0a		      .byte.b	CR,LF
      0  021d					      db	"Bob's Tiny BASIC v1.0.2 IRQs"
      1  021d		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs"
      0  0239					      db	CR,LF
      1  0239		       0d 0a		      .byte.b	CR,LF
      0  023b					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  023b		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0269					      db	CR,LF,0
      1  0269		       0d 0a 00 	      .byte.b	CR,LF,0
    277  026c							;
    278  026c		       20 b1 10 	      jsr	GetSizes	;setup the free space available
    279  026f
    280  026f		       a9 01	   calcstack  lda	#1
    281  0271		       8d 85 16 	      sta	taskCounter	; Initialize number of tasks to 1
    282  0274		       8d b1 15 	      sta	taskTable	; mark the main task as active
    283  0277		       20 2d 04 	      jsr	taskSetStacks	; setup all the task stacks
    284  027a		       a9 4f		      lda	#IL&$ff
    285  027c		       85 75		      sta	ILPC
    286  027e		       a9 12		      lda	#IL>>8
    287  0280		       85 76		      sta	ILPC+1
    288  0282							;
    289  0282		       a9 32		      lda	#ProgramStart&$ff	;user prog
    290  0284		       8d 2a 1b 	      sta	PROGRAMEND
    291  0287		       a9 1b		      lda	#ProgramStart>>8
    292  0289		       8d 2b 1b 	      sta	PROGRAMEND+1
    293  028c							;
    294  028c							; Initialize the pseudo-random number sequence...
    295  028c							;
    296  028c		       a9 5a		      lda	#$5a
    297  028e		       8d 23 1b 	      sta	rtemp1
    298  0291		       a9 9d		      lda	#%10011101
    299  0293		       8d 25 1b 	      sta	random
    300  0296		       a9 5b		      lda	#%01011011
    301  0298		       8d 26 1b 	      sta	random+1
    302  029b							;
    303  029b							;   Insert a Basic irq handler for the basic Language
    304  029b		       a9 a8		      lda	#ServiceIrq&$ff
    305  029d		       8d 00 df 	      sta	IRQvec
    306  02a0		       a9 02		      lda	#ServiceIrq>>8
    307  02a2		       8d 01 df 	      sta	IRQvec+1
    308  02a5		       4c c7 02 	      jmp	coldtwo
    309  02a8
    310  02a8							;
    311  02a8							; This is the Basic IRQ handler
    312  02a8		       48	   ServiceIrq pha
    313  02a9		       ad ac 15 	      lda	IRQStatus
    314  02ac		       f0 0a		      BEQ	RetIrq
    315  02ae		       ad ad 15 	      lda	IRQPending
    316  02b1		       d0 05		      bne	RetIrq
    317  02b3		       a9 01		      lda	#1
    318  02b5		       8d ad 15 	      sta	IRQPending
    319  02b8		       68	   RetIrq     pla
    320  02b9		       40		      rti
    321  02ba							;
    322  02ba							;
    323  02ba							; This is the warm start entry point
    324  02ba							;
    325  02ba		       20 0c 02    warm2      jsr	CRLF
    326  02bd		       ad 20 1b 	      lda	errGoto
    327  02c0		       85 75		      sta	ILPC
    328  02c2		       ad 21 1b 	      lda	errGoto+1
    329  02c5		       85 76		      sta	ILPC+1
    330  02c7							;
    331  02c7							; And continue with both starts here
    332  02c7							;
    333  02c7		       20 e4 10    coldtwo    jsr	SetOutConsole
    334  02ca							;
    335  02ca							; The ILTrace flag is now run-time settable.
    336  02ca							;
    337  02ca		       a9 00		      lda	#ILTRACE&$ff
    338  02cc		       85 40		      sta	ILTrace
    339  02ce							;
    340  02ce
    341  02ce		       a9 00		      lda	#0
    342  02d0		       85 92		      sta	RunMode
    343  02d2		       8d 96 1a 	      sta	LINBUF
    344  02d5
    345  02d5							; Clear everything from the stacks
    346  02d5
    347  02d5		       85 90		      sta	taskIOPending	; No one waiting for io
    348  02d7		       85 91		      sta	taskRDPending	; No one waiting for bg io
    349  02d9		       20 83 04 	      jsr	taskReset
    350  02dc							;
    351  02dc		       a9 96		      lda	#LINBUF&$ff
    352  02de		       85 80		      sta	CURPTR
    353  02e0		       a9 1a		      lda	#LINBUF>>8
    354  02e2		       85 81		      sta	CURPTR+1	;fall through...
    355  02e4
    356  02e4							;=====================================================
    357  02e4							; This is the top of the IL interpreter.  This fetches
    358  02e4							; and executes the instruction currently pointed to
    359  02e4							; by ILPC and adjusts ILPC to point to the next
    360  02e4							; instruction to execute.
    361  02e4							;
    362  02e4		       20 5c 0a    NextIL     jsr	iTaskSwitch	;check for a task switch
    363  02e7		       a5 40		      lda	ILTrace
    364  02e9		       f0 03		      beq	NextIL2
    365  02eb		       20 6c 10 	      jsr	dbgLine
    366  02ee		       a4 82	   NextIL2    ldy	CUROFF
    367  02f0		       20 63 10 	      jsr	SkipSpaces
    368  02f3		       84 82		      sty	CUROFF
    369  02f5							;Task IO Management
    370  02f5		       a5 91		      lda	taskRDPending	; if it is zero then Nothing pending
    371  02f7		       f0 07		      beq	NextILStr
    372  02f9		       20 a9 0e 	      jsr	ReadLine	; else Pending and poll keyboard
    373  02fc		       90 02		      bcc	NextILStr	; if carry is clear then no end of line yet
    374  02fe		       c6 91		      dec	taskRDPending	; Carry is set if CR has been recievec
    375  0300							;
    376  0300		       20 c2 0c    NextILStr  jsr	getILByte
    377  0303							;
    378  0303							; When the handler is called, these are the conditions
    379  0303							; of several important items:
    380  0303							;
    381  0303							;    (ILPC) will point to the byte AFTER the IL
    382  0303							;    opcode being executed.
    383  0303							;
    384  0303							;    (CURPTR),CUROFF will point to the start of the
    385  0303							;    next word in the input buffer.  Ie, the next word
    386  0303							;    in the user program.
    387  0303							;
    388  0303		       0a		      asl
    389  0304		       c9 92		      cmp	#ILTBLend-ILTBL+2
    390  0306		       90 33		      bcc	ILgood
    391  0308							;
    392  0308							; This handles an illegal IL opcode.  This is serious
    393  0308							; and there's no way to recover.
    394  0308							;
    395  0308		       20 12 f0    ILbad      jsr	puts
      0  030b					      db	CR,LF
      1  030b		       0d 0a		      .byte.b	CR,LF
      0  030d					      db	"Illegal IL "
      1  030d		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  0318					      db	0
      1  0318		       00		      .byte.b	0
    399  0319							;
    400  0319							; Well this is awkward, we need to back up the IL
    401  0319							; by one since it no longer points to the current
    402  0319							; opcode.
    403  0319							;
    404  0319		       20 cf 0c 	      jsr	decIL
    405  031c							;
    406  031c		       a0 00		      ldy	#0
    407  031e		       b1 75		      lda	(ILPC),y
    408  0320		       20 0f 02 	      jsr	OUTHEX
    409  0323		       20 12 f0 	      jsr	puts
      0  0326					      db	" at ",0
      1  0326		       20 61 74 20*	      .byte.b	" at ",0
    411  032b		       a5 76		      lda	ILPC+1
    412  032d		       20 0f 02 	      jsr	OUTHEX
    413  0330		       a5 75		      lda	ILPC
    414  0332		       20 0f 02 	      jsr	OUTHEX
    415  0335		       20 0c 02 	      jsr	CRLF
    416  0338		       4c 12 02 	      jmp	MONITOR
    417  033b							;
    418  033b							; Just jump to the address (ILPC),y.  Have to do
    419  033b							; some goofy stuff.
    420  033b							;
    421  033b		       a8	   ILgood     tay		;move index into Y
    422  033c		       b9 49 03 	      lda	ILTBL,y
    423  033f		       85 89		      sta	dpl
    424  0341		       b9 4a 03 	      lda	ILTBL+1,y
    425  0344		       85 8a		      sta	dpl+1
    426  0346		       6c 89 00 	      jmp	(dpl)	;go to handler
    427  0349							;
    428  0349							;=====================================================
    429  0349							; This is the IL jump table.  The IL opcode is
    430  0349							; mulitplied by two, then looked-up in this table.
    431  0349							; There is absolutely nothing special about the order
    432  0349							; of entries here... they all decode at exactly the
    433  0349							; same speed.	However the entry number must match the
    434  0349							; values in IL.inc.
    435  0349							;
      0  0349				   ILTBL      dw	iXINIT	;0
      1  0349		       08 04		      .word.w	iXINIT
      0  034b					      dw	iDONE	;1
      1  034b		       b1 04		      .word.w	iDONE
      0  034d					      dw	iPRS	;2
      1  034d		       cd 04		      .word.w	iPRS
      0  034f					      dw	iPRN	;3
      1  034f		       d7 04		      .word.w	iPRN
      0  0351					      dw	iSPC	;4
      1  0351		       e0 04		      .word.w	iSPC
      0  0353					      dw	iNLINE	;5
      1  0353		       db 08		      .word.w	iNLINE
      0  0355					      dw	iNXT	;6
      1  0355		       e8 04		      .word.w	iNXT
      0  0357					      dw	iXFER	;7
      1  0357		       14 05		      .word.w	iXFER
      0  0359					      dw	iSAV	;8
      1  0359		       41 05		      .word.w	iSAV
      0  035b					      dw	iRSTR	;9
      1  035b		       62 05		      .word.w	iRSTR
      0  035d					      dw	iCMPR	;10
      1  035d		       6e 05		      .word.w	iCMPR
      0  035f					      dw	iINNUM	;11
      1  035f		       e4 05		      .word.w	iINNUM
      0  0361					      dw	iFIN	;12
      1  0361		       12 06		      .word.w	iFIN
      0  0363					      dw	iERR	;13
      1  0363		       23 06		      .word.w	iERR
      0  0365					      dw	iADD	;14
      1  0365		       8e 06		      .word.w	iADD
      0  0367					      dw	iSUB	;15
      1  0367		       a4 06		      .word.w	iSUB
      0  0369					      dw	iNEG	;16
      1  0369		       ba 06		      .word.w	iNEG
      0  036b					      dw	iMUL	;17
      1  036b		       d2 06		      .word.w	iMUL
      0  036d					      dw	iDIV	;18
      1  036d		       12 07		      .word.w	iDIV
      0  036f					      dw	iSTORE	;19
      1  036f		       68 07		      .word.w	iSTORE
      0  0371					      dw	iIND	;20
      1  0371		       7b 07		      .word.w	iIND
      0  0373					      dw	iLST	;21
      1  0373		       b3 07		      .word.w	iLST
      0  0375					      dw	iINIT	;22
      1  0375		       d9 03		      .word.w	iINIT
      0  0377					      dw	iGETLINE	;23
      1  0377		       12 08		      .word.w	iGETLINE
      0  0379					      dw	iINSRT	;24
      1  0379		       20 08		      .word.w	iINSRT
      0  037b					      dw	iRTN	;25
      1  037b		       d5 08		      .word.w	iRTN
      0  037d					      dw	MONITOR	;26
      1  037d		       12 02		      .word.w	MONITOR
      0  037f					      dw	iLIT	;27
      1  037f		       ee 08		      .word.w	iLIT
      0  0381					      dw	iCALL	;28
      1  0381		       e1 08		      .word.w	iCALL
      0  0383					      dw	iJMP	;29
      1  0383		       e4 08		      .word.w	iJMP
      0  0385					      dw	iVINIT	;30
      1  0385		       fb 08		      .word.w	iVINIT
      0  0387					      dw	iERRGOTO	;31
      1  0387		       09 09		      .word.w	iERRGOTO
      0  0389					      dw	iTST	;32
      1  0389		       15 09		      .word.w	iTST
      0  038b					      dw	iTSTV	;33
      1  038b		       9e 09		      .word.w	iTSTV
      0  038d					      dw	iTSTL	;34
      1  038d		       c8 09		      .word.w	iTSTL
      0  038f					      dw	iTSTN	;35
      1  038f		       e2 09		      .word.w	iTSTN
      0  0391					      dw	iFREE	;36
      1  0391		       9c 0a		      .word.w	iFREE
      0  0393					      dw	iRANDOM	;37
      1  0393		       a5 0a		      .word.w	iRANDOM
      0  0395					      dw	iABS	;38
      1  0395		       76 0b		      .word.w	iABS
    475  0397							;
    476  0397							; Disk functions.  There must be pointers
    477  0397							; to functions even if no disk is supported.
    478  0397							; Makes things easier in IL.inc.
    479  0397							;
    480  0397					      if	DISK_ACCESS
      0  0397					      dw	iOPENREAD	;39
      1  0397		       2a 11		      .word.w	iOPENREAD
      0  0399					      dw	iOPENWRITE	;40
      1  0399		       7e 11		      .word.w	iOPENWRITE
      0  039b					      dw	iDCLOSE	;41
      1  039b		       02 12		      .word.w	iDCLOSE
      0  039d					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  039d		       9d 11		      .word.w	iDGETLINE
      0  039f					      dw	iDLIST	;43 Did you remeber your towel?
      1  039f		       fc 11		      .word.w	iDLIST
      0  03a1					      dw	iDDIR	;44
      1  03a1		       d7 11		      .word.w	iDDIR
      0  03a3					      dw	iRMFILE	;45
      1  03a3		       58 11		      .word.w	iRMFILE
    488  03a5				  -	      else
    489  03a5				  -	      dw	NextIL	;39
    490  03a5				  -	      dw	NextIL	;40
    491  03a5				  -	      dw	NextIL	;41
    492  03a5				  -	      dw	NextIL	;42
    493  03a5				  -	      dw	NextIL	;43
    494  03a5				  -	      dw	NextIL	;44
    495  03a5				  -	      dw	NextIL	;45
    496  03a5					      endif
    497  03a5							;
      0  03a5					      dw	iCLEARSCREEN	;46
      1  03a5		       1f 11		      .word.w	iCLEARSCREEN
      0  03a7					      dw	iPOKEMEMORY	;47
      1  03a7		       03 0b		      .word.w	iPOKEMEMORY
      0  03a9					      dw	iPEEKMEMORY	;48
      1  03a9		       18 0b		      .word.w	iPEEKMEMORY
      0  03ab					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03ab		       5a 09		      .word.w	iTSTLET
      0  03ad					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  03ad		       7d 09		      .word.w	iTSTDONE
      0  03af					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03af		       45 0b		      .word.w	iGETCHAR
      0  03b1					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03b1		       59 0b		      .word.w	iPUTCHAR
      0  03b3					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03b3		       2e 0b		      .word.w	iCallFunc
      0  03b5					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  03b5		       b9 05		      .word.w	iBranch
      0  03b7					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03b7		       3e 09		      .word.w	iTSTStr
      0  03b9					      dw	iSetIrq	;56	   sets the irq handler
      1  03b9		       90 0b		      .word.w	iSetIrq
      0  03bb					      dw	iTstIrq	;57	   test if irq is pending
      1  03bb		       25 0a		      .word.w	iTstIrq
      0  03bd					      dw	iRET	;58	   return from interupt
      1  03bd		       50 05		      .word.w	iRET
      0  03bf					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03bf		       f7 05		      .word.w	iINSTR
      0  03c1					      dw	iMOD	;60	   returns remainder of division
      1  03c1		       1b 07		      .word.w	iMOD
      0  03c3					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03c3		       c7 0b		      .word.w	iTaskSet
      0  03c5					      dw	iETask	;62	   Terminates a task
      1  03c5		       90 0c		      .word.w	iETask
      0  03c7					      dw	iNTask	;63	   goto next task
      1  03c7		       7a 0c		      .word.w	iNTask
      0  03c9					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03c9		       8b 07		      .word.w	iArray
      0  03cb					      dw	iTaskKill	;65	   kill a running task
      1  03cb		       72 0c		      .word.w	iTaskKill
      0  03cd					      dw	iTaskStat	;66	   return the state of a task PID
      1  03cd		       4b 0c		      .word.w	iTaskStat
      0  03cf					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03cf		       64 0b		      .word.w	iHexOut
      0  03d1					      dw	iReadComplete	;68	   Called after a background read completes
      1  03d1		       d5 05		      .word.w	iReadComplete
      0  03d3					      dw	iReadStart	;69	   Called to start a background read request
      1  03d3		       cb 05		      .word.w	iReadStart
      0  03d5					      dw	iStartIO	;70	   Lock task until io complete
      1  03d5		       82 0c		      .word.w	iStartIO
      0  03d7					      dw	iEndIO	;71	   release task lock for io
      1  03d7		       87 0c		      .word.w	iEndIO
    524  03d9
    525  03d9		       03 d9	   ILTBLend   equ	*
    526  03d9							;
    527  03d9							;=====================================================
    528  03d9							;=====================================================
    529  03d9							;=====================================================
    530  03d9							; This marks the start of the handlers for IL opcodes.
    531  03d9							;=====================================================
    532  03d9							;=====================================================
    533  03d9							;=====================================================
    534  03d9							;
    535  03d9							;
    536  03d9		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    537  03db		       85 79		      sta	ILSTACKPTR
    538  03dd		       85 7c		      sta	MATHSTACKPTR
    539  03df		       85 7f		      sta	GOSUBSTACKPTR
    540  03e1
    541  03e1		       20 83 04 	      jsr	taskReset
    542  03e4							;
    543  03e4		       a9 32		      lda	#ProgramStart&$ff	;user prog
    544  03e6		       85 80		      sta	CURPTR
    545  03e8		       8d b2 15 	      sta	taskTable+1
    546  03eb		       8d 2a 1b 	      sta	PROGRAMEND
    547  03ee		       a9 1b		      lda	#ProgramStart>>8
    548  03f0		       85 81		      sta	CURPTR+1
    549  03f2		       8d b3 15 	      sta	taskTable+2
    550  03f5		       8d 2b 1b 	      sta	PROGRAMEND+1
    551  03f8		       a9 01		      lda	#1
    552  03fa		       8d b1 15 	      sta	taskTable	;Mark the first slot as active
    553  03fd		       8d 85 16 	      sta	taskCounter	;there is always one task / Main task
    554  0400		       a9 c8		      lda	#TASKCYCLESDEFAULT
    555  0402		       8d 84 16 	      sta	taskResetValue
    556  0405		       8d 83 16 	      sta	taskCurrentCycles	; set up the task switch counts
    557  0408							;
    558  0408							; fall into XINIT...
    559  0408							;
    560  0408							;=====================================================
    561  0408							; This initializes for the start of the next line of
    562  0408							; BASIC text.
    563  0408							;
    564  0408		       78	   iXINIT     sei		;ensure interupts are off
    565  0409		       a9 00		      lda	#0
    566  040b		       8d b0 15 	      sta	taskPtr	;Set the first slot
    567  040e		       8d ad 15 	      sta	IRQPending	; reset the irq pending
    568  0411		       8d ac 15 	      sta	IRQStatus	; Make sure irqs are off
    569  0414		       a9 01		      lda	#1
    570  0416		       8d 85 16 	      sta	taskCounter	;Number of actual tasks
    571  0419		       20 83 04 	      jsr	taskReset	;Clear the task table
    572  041c		       4c e4 02    goodExit   jmp	NextIL
    573  041f							;
    574  041f							;=====================================================
    575  041f							; This check if the escape key has been entered
    576  041f							; then changes out of run mode. z Set if esc found
    577  041f				   BreakSet
    578  041f		       20 15 02 	      jsr	ISCHAR
    579  0422		       f0 06		      beq	BreakNo
    580  0424		       20 09 02 	      jsr	GETCH
    581  0427		       c9 1b		      cmp	#$1B
    582  0429		       60		      rts
    583  042a				   BreakNo
    584  042a		       a9 01		      lda	#1
    585  042c		       60		      rts
    586  042d
    587  042d							;
    588  042d							;=====================================================
    589  042d							; Sets the pointers to the math,IL and gosub stacks
    590  042d				   taskSetStacks
    591  042d		       a9 86		      lda	#mathStack&$FF
    592  042f		       85 7a		      sta	MATHSTACK
    593  0431		       a9 16		      lda	#mathStack>>8
    594  0433		       85 7b		      sta	MATHSTACK+1
    595  0435		       a9 4e		      lda	#ilStack&$ff
    596  0437		       85 77		      sta	ILSTACK
    597  0439		       a9 17		      lda	#ilStack>>8
    598  043b		       85 78		      sta	ILSTACK+1
    599  043d		       a9 16		      lda	#gosubStack&$FF
    600  043f		       85 7d		      sta	GOSUBSTACK
    601  0441		       a9 18		      lda	#gosubStack>>8
    602  0443		       85 7e		      sta	GOSUBSTACK+1
    603  0445		       a2 0a		      ldx	#TASKCOUNT
    604  0447		       a0 00		      ldy	#0
    605  0449		       20 0e 0f 	      jsr	ContextSave
    606  044c
    607  044c		       c0 d2	   taskSetLoop cpy	#TASKTABLELEN
    608  044e		       b0 2d		      bcs	taskSetDone
    609  0450
    610  0450		       a5 7d		      lda	GOSUBSTACK
    611  0452		       18		      clc
    612  0453		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
    613  0455		       85 7d		      sta	GOSUBSTACK
    614  0457		       a5 7e		      lda	GOSUBSTACK+1
    615  0459		       69 00		      adc	#0
    616  045b		       85 7e		      sta	GOSUBSTACK+1
    617  045d
    618  045d		       a5 77		      lda	ILSTACK	; must be less than 256
    619  045f		       18		      clc
    620  0460		       69 14		      adc	#ILSTACKSIZE*2
    621  0462		       85 77		      sta	ILSTACK
    622  0464		       a5 78		      lda	ILSTACK+1
    623  0466		       69 00		      adc	#0
    624  0468		       85 78		      sta	ILSTACK+1
    625  046a
    626  046a		       a5 7a		      lda	MATHSTACK	; must be less than 256
    627  046c		       18		      clc
    628  046d		       69 14		      adc	#MATHSTACKSIZE*2
    629  046f		       85 7a		      sta	MATHSTACK
    630  0471		       a5 7b		      lda	MATHSTACK+1
    631  0473		       69 00		      adc	#0
    632  0475		       85 7b		      sta	MATHSTACK+1
    633  0477
    634  0477		       20 0e 0f 	      jsr	ContextSave
    635  047a		       4c 4c 04 	      jmp	taskSetLoop
    636  047d
    637  047d				   taskSetDone
    638  047d		       a0 00		      ldy	#0
    639  047f		       20 1d 0f 	      jsr	ContextLoad
    640  0482		       60		      rts
    641  0483							;
    642  0483							;=====================================================
    643  0483							; Clear all task entries and task gosub stacks
    644  0483		       98	   taskReset  tya
    645  0484		       48		      pha
    646  0485		       a0 00		      ldy	#0
    647  0487		       8c b0 15 	      sty	taskPtr	; Set the active task to 0 MAIN
    648  048a		       20 0e 0f 	      jsr	ContextSave
    649  048d		       a0 00		      ldy	#0
    650  048f		       20 1d 0f    taskResetLoop jsr	ContextLoad	; get the first task
    651  0492		       a9 00		      lda	#0
    652  0494		       99 b1 15 	      sta	taskTable,y	; clear any active tasks flags
    653  0497		       85 7f		      sta	GOSUBSTACKPTR	; clear all the task gosub pointers
    654  0499		       85 7c		      sta	MATHSTACKPTR	; Clear the math stack pointers
    655  049b		       85 79		      sta	ILSTACKPTR	; Clear all the IL Stack Pointers
    656  049d		       20 0e 0f 	      jsr	ContextSave	; Save this context, returns y at next task entry
    657  04a0
    658  04a0		       c0 d2		      cpy	#TASKTABLELEN	; Are we at the end yet
    659  04a2		       90 eb		      bcc	taskResetLoop	; Go for more
    660  04a4
    661  04a4				   taskResetComplete
    662  04a4		       a0 00		      ldy	#0
    663  04a6		       a9 01		      lda	#1
    664  04a8		       8d b1 15 	      sta	taskTable	; mark main context as active
    665  04ab		       20 1d 0f 	      jsr	ContextLoad	; Restore main context
    666  04ae		       68		      pla
    667  04af		       a8		      tay
    668  04b0		       60		      rts
    669  04b1
    670  04b1							;
    671  04b1							;=====================================================
    672  04b1							; Verify there is nothing else on this input line.
    673  04b1							; If there is, generate an error.
    674  04b1							;
    675  04b1		       a4 82	   iDONE      ldy	CUROFF
    676  04b3		       20 63 10 	      jsr	SkipSpaces
    677  04b6		       b1 80		      lda	(CURPTR),y
    678  04b8		       f0 10		      beq	doneadv
    679  04ba		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    680  04bc		       d0 05		      bne	idoneErr
    681  04be		       84 82		      sty	CUROFF
    682  04c0		       4c e4 02 	      jmp	NextIL	; continue on this line
    683  04c3
    684  04c3				   idoneErr
    685  04c3		       a2 04		      ldx	#ERR_EXTRA_STUFF
    686  04c5		       a9 00		      lda	#0
    687  04c7		       4c 26 06 	      jmp	iErr2
    688  04ca							;
    689  04ca							; Advance to the next line
    690  04ca							;
    691  04ca				   doneadv
    692  04ca							;		 jsr	 FindNext2
    693  04ca		       4c e4 02 	      jmp	NextIL
    694  04cd							;
    695  04cd							;=====================================================
    696  04cd							; Print the string until a closing quote
    697  04cd							;
    698  04cd		       a4 82	   iPRS       ldy	CUROFF
    699  04cf							;
    700  04cf							; Odd logic here.  The main loop skipped any leading
    701  04cf							; whitespace inside the quoted text, so move back to
    702  04cf							; the quote, then move forward again.
    703  04cf							;
    704  04cf		       20 f2 10 	      jsr	PrtQuoted
    705  04d2		       84 82		      sty	CUROFF
    706  04d4		       4c e4 02 	      jmp	NextIL
    707  04d7							;
    708  04d7							;=====================================================
    709  04d7							; Pop the top off the stack and print it as a signed
    710  04d7							; decimal number.
    711  04d7							;
    712  04d7		       20 ba 0f    iPRN       jsr	popR0
    713  04da		       20 5f 0d 	      jsr	PrintDecimal
    714  04dd		       4c e4 02 	      jmp	NextIL
    715  04e0							;
    716  04e0							;=====================================================
    717  04e0							; Space to next zone.	Currently the code does not
    718  04e0							; keep track of which column the output is on, so
    719  04e0							; just print a tab.
    720  04e0							;
    721  04e0		       a9 09	   iSPC       lda	#TAB
    722  04e2		       20 06 02 	      jsr	OUTCH
    723  04e5		       4c e4 02 	      jmp	NextIL
    724  04e8							;
    725  04e8							;=====================================================
    726  04e8							; If in immediate mode, jump to the address following
    727  04e8							; the NXT instruction.  Else move to the next line of
    728  04e8							; user code and continue.
    729  04e8							;
    730  04e8		       a5 92	   iNXT       lda	RunMode
    731  04ea		       d0 03		      bne	iNxtRun	;in run mode
    732  04ec							;
    733  04ec							; Get address and jump to it.
    734  04ec							;
    735  04ec		       4c e4 08 	      jmp	iJMP
    736  04ef							;
    737  04ef				   iNxtRun
    738  04ef		       a4 82		      ldy	CUROFF
    739  04f1		       20 63 10 	      jsr	SkipSpaces
    740  04f4		       b1 80		      lda	(CURPTR),y
    741  04f6		       c9 3a		      cmp	#COLON
    742  04f8		       d0 09		      bne	iNxtRunGo
    743  04fa		       c8		      iny
    744  04fb		       20 63 10 	      jsr	SkipSpaces
    745  04fe		       84 82		      sty	CUROFF
    746  0500		       4c 0e 05 	      jmp	iNxtRun2
    747  0503
    748  0503				   iNxtRunGo
    749  0503		       20 40 0d 	      jsr	FindNextLine
    750  0506		       20 52 0d 	      jsr	AtEnd
    751  0509		       d0 03		      bne	iNxtRun2	;not at end
    752  050b							;
    753  050b							; At the end of the program.  Pretend an END statement
    754  050b							; was found.
    755  050b							;
    756  050b		       4c 12 06    iFINv      jmp	iFIN
    757  050e							;
    758  050e		       20 be 0c    iNxtRun2   jsr	getILWord	;ignore next word
    759  0511		       4c e4 02 	      jmp	NextIL
    760  0514							;
    761  0514							;=====================================================
    762  0514							; XFER takes the number on top of the stack and looks
    763  0514							; for that line in the program, or the next line
    764  0514							; higher.  Ie, if it's 1 but there is no line 1, then
    765  0514							; find the next one after that.
    766  0514							;
    767  0514		       20 ba 0f    iXFER      jsr	popR0
    768  0517		       20 fd 0c 	      jsr	findLine
    769  051a		       20 52 0d    iXFER2     jsr	AtEnd	;at end of user program?
    770  051d		       f0 ec		      beq	iFINv
    771  051f		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    772  0521		       84 82		      sty	CUROFF
    773  0523		       a9 ff		      lda	#$ff
    774  0525		       85 92		      sta	RunMode
    775  0527							;
    776  0527							; Transfer IL to STMT.  I don't like having this
    777  0527							; hard-coded; fix it.
    778  0527							;
    779  0527		       a9 5d		      lda	#STMT&$ff
    780  0529		       85 75		      sta	ILPC
    781  052b		       a9 12		      lda	#STMT>>8
    782  052d		       85 76		      sta	ILPC+1
    783  052f		       4c e4 02 	      jmp	NextIL
    784  0532							;
    785  0532							; Run
    786  0532							;
    787  0532				   iXferok
    788  0532		       a9 ff		      lda	#$ff
    789  0534		       85 92		      sta	RunMode	;we're running
    790  0536							;
    791  0536							; Need a more elegant way to do this
    792  0536							;
    793  0536		       a9 5d		      lda	#STMT&$ff
    794  0538		       85 75		      sta	ILPC
    795  053a		       a9 12		      lda	#STMT>>8
    796  053c		       85 76		      sta	ILPC+1
    797  053e		       4c e4 02 	      jmp	NextIL
    798  0541							;
    799  0541							;=====================================================
    800  0541							; Save the pointer to the next line to the call stack.
    801  0541							;
    802  0541		       20 57 0f    iSAV       jsr	pushLN
    803  0544		       b0 03		      bcs	iSAVErr
    804  0546		       4c e4 02 	      jmp	NextIL
    805  0549
    806  0549		       a2 0c	   iSAVErr    ldx	#12
    807  054b		       a9 00	   iSAVErr2   lda	#0
    808  054d		       4c 26 06 	      jmp	iErr2
    809  0550
    810  0550							;
    811  0550							;=====================================================
    812  0550							; Pop the next line from the call stack.
    813  0550							;
    814  0550		       20 7a 0f    iRET       jsr	popLN
    815  0553		       b0 f4		      bcs	iSAVErr
    816  0555		       a0 03		      ldy	#3
    817  0557		       84 82		      sty	CUROFF
    818  0559		       a9 00		      lda	#0
    819  055b		       8d ad 15 	      sta	IRQPending
    820  055e		       58		      cli
    821  055f		       4c e4 02 	      jmp	NextIL
    822  0562							;
    823  0562							;=====================================================
    824  0562							; Return from IL program call
    825  0562							;
    826  0562		       20 7a 0f    iRSTR      jsr	popLN
    827  0565		       b0 e2		      bcs	iSAVErr
    828  0567		       4c e4 02 	      jmp	NextIL
    829  056a
    830  056a		       a2 0b	   iRSTRErr   ldx	#11
    831  056c		       d0 dd		      bne	iSAVErr2
    832  056e							;
    833  056e							;=====================================================
    834  056e							; Compare items on stack.  Okay, so on input there are
    835  056e							; three things on the stack
    836  056e							;
    837  056e							;    EXPR2 <- Top of stack
    838  056e							;    OP    <- relational operator, next on stack
    839  056e							;    EXPR1 <- last item on stack
    840  056e							;
    841  056e							; Comparison is: EXPR1 <operator> EXPR2
    842  056e							;
    843  056e							; Operator is one of...
    844  056e							;
    845  056e							;    2 is =
    846  056e							;    1 is <
    847  056e							;    3 is <=
    848  056e							;    5 is <>
    849  056e							;    4 is >
    850  056e							;    6 is >=
    851  056e							;
    852  056e							; Those are bit-mapped:
    853  056e							;
    854  056e							;    xxxxxGEL
    855  056e							;
    856  056e							;    G = Greater than
    857  056e							;    E = Equal
    858  056e							;    L = Less than
    859  056e							;
    860  056e							; If the comparison is false, do a NXT, ie, move to the
    861  056e							; next line and continue.  If true, continue executing
    862  056e							; on this line.
    863  056e							;
    864  056e		       00 01	   REL_LT     equ	%001
    865  056e		       00 02	   REL_EQUAL  equ	%010
    866  056e		       00 04	   REL_GT     equ	%100
    867  056e							;
    868  056e		       20 cf 0f    iCMPR      jsr	popR1
    869  0571		       20 e4 0f 	      jsr	popMQ	;operator in MQ
    870  0574		       20 ba 0f 	      jsr	popR0
    871  0577							;
    872  0577							; See if they are equal or not
    873  0577							;
    874  0577		       a5 83		      lda	R0
    875  0579		       c5 85		      cmp	R1
    876  057b		       d0 0a		      bne	iCMPRnoteq	;try not equal
    877  057d		       a5 84		      lda	R0+1
    878  057f		       c5 86		      cmp	R1+1
    879  0581		       d0 04		      bne	iCMPRnoteq
    880  0583							;
    881  0583							; Equal, set the flag in MQ+1
    882  0583							;
    883  0583		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    884  0585		       d0 14		      bne	iCMPcom	;Exit it is equal
    885  0587							;
    886  0587							; See if EXPR1 (R0) < EXPR2 (R1)
    887  0587							; See www.6502.org/tutorials/compare_beyond.html
    888  0587							;
    889  0587				   iCMPRnoteq
    890  0587		       a5 83		      lda	R0
    891  0589		       c5 85		      cmp	R1
    892  058b		       a5 84		      lda	R0+1
    893  058d		       e5 86		      sbc	R1+1
    894  058f		       50 02		      bvc	iCMPR_2
    895  0591		       49 80		      eor	#$80
    896  0593		       30 04	   iCMPR_2    bmi	iCMPlt
    897  0595		       a9 04		      lda	#REL_GT
    898  0597		       d0 02		      bne	iCMPcom
    899  0599		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    900  059b
    901  059b		       05 88	   iCMPcom    ora	MQ+1	; or with original mask
    902  059d							;
    903  059d							; Now compare the end result with what the caller
    904  059d							; was looking for.
    905  059d							;
    906  059d		       25 87		      and	MQ
    907  059f		       f0 0a		      beq	iCMPno	; no match
    908  05a1		       a9 01		      lda	#1
    909  05a3		       85 83		      sta	R0
    910  05a5		       d0 08		      bne	iCMPDone
    911  05a7							;
    912  05a7							; R0 > R1
    913  05a7							;
    914  05a7		       a9 04	   iCMPgt     lda	#REL_GT
    915  05a9		       d0 f0		      bne	iCMPcom
    916  05ab				   iCMPno
    917  05ab		       a9 00		      lda	#0
    918  05ad		       85 83		      sta	R0
    919  05af
    920  05af				   iCMPDone
    921  05af		       a9 00		      lda	#0
    922  05b1		       85 84		      sta	R0+1
    923  05b3		       20 42 0f 	      jsr	pushR0
    924  05b6		       4c e4 02 	      jmp	NextIL
    925  05b9							;
    926  05b9							; if Not a match, so jump to the next line of code.
    927  05b9							; Branches based upon value on top of the stack
    928  05b9				   iBranch
    929  05b9		       20 ba 0f 	      jsr	popR0
    930  05bc		       a5 83		      lda	R0
    931  05be		       05 84		      ora	R0+1
    932  05c0		       f0 03		      beq	iBranchFalse	; not true
    933  05c2		       4c e4 02 	      jmp	NextIL	; It is true if any value not zero
    934  05c5							;
    935  05c5				   iBranchFalse
    936  05c5		       20 40 0d 	      jsr	FindNextLine
    937  05c8		       4c 1a 05 	      jmp	iXFER2
    938  05cb							;
    939  05cb							;=====================================================
    940  05cb							; Start a read of data in background
    941  05cb				   iReadStart
    942  05cb		       a9 3f		      lda	#'?	; Prompt with question mark
    943  05cd		       a6 01		      ldx	1	; Indicate to start read in background
    944  05cf		       20 42 0e 	      jsr	GetLine	; Call the getline to start read
    945  05d2		       4c e4 02 	      jmp	NextIL	; next instruction
    946  05d5							;
    947  05d5							;=====================================================
    948  05d5							; Complete the read and return the curptr, curoff pointing to data
    949  05d5				   iReadComplete
    950  05d5		       20 57 0f 	      jsr	pushLN
    951  05d8		       20 62 0e 	      jsr	ReadComplete
    952  05db		       4c e4 02 	      jmp	NextIL
    953  05de		       20 7a 0f 	      jsr	popLN
    954  05e1		       4c e4 02 	      jmp	NextIL
    955  05e4							;=====================================================
    956  05e4							; Get a line of text from the user, convert to a
    957  05e4							; number, leave on top of stack.
    958  05e4							;
    959  05e4				   iINNUM
    960  05e4		       20 57 0f 	      jsr	pushLN
    961  05e7							;
    962  05e7		       a9 3f		      lda	#'?
    963  05e9		       a2 00		      ldx	#0	;Wait for complete
    964  05eb		       20 42 0e 	      jsr	GetLine
    965  05ee		       20 cb 0d 	      jsr	getDecimal
    966  05f1		       20 42 0f 	      jsr	pushR0	;put onto stack
    967  05f4							;
    968  05f4		       4c 0c 06 	      jmp	ExitIn
    969  05f7							;
    970  05f7							;=====================================================
    971  05f7							; Get a line of text from the user, convert to a
    972  05f7							; character value , leave on top of stack. up to 2 characters
    973  05f7							;
    974  05f7				   iINSTR
    975  05f7		       20 57 0f 	      jsr	pushLN
    976  05fa		       a9 3f		      lda	#'?
    977  05fc		       a2 00		      ldx	#0	;wait for read complete
    978  05fe		       20 42 0e 	      jsr	GetLine
    979  0601		       b1 80		      lda	(CURPTR),y
    980  0603		       85 83		      sta	R0
    981  0605		       a9 00		      lda	#0
    982  0607		       85 84		      sta	R0+1
    983  0609		       20 42 0f 	      jsr	pushR0	;put onto stack
    984  060c				   ExitIn
    985  060c		       20 7a 0f 	      jsr	popLN
    986  060f		       4c e4 02 	      jmp	NextIL
    987  0612							;
    988  0612							;
    989  0612							;=====================================================
    990  0612							; Stop the currently running program.	Actually very
    991  0612							; simple to do... clear the RunMode flag, then set the
    992  0612							; ILPC to the standard handler and continue running.
    993  0612							;
    994  0612		       a9 00	   iFIN       lda	#0
    995  0614		       85 92		      sta	RunMode
    996  0616							;
    997  0616		       ad 20 1b 	      lda	errGoto
    998  0619		       85 75		      sta	ILPC
    999  061b		       ad 21 1b 	      lda	errGoto+1
   1000  061e		       85 76		      sta	ILPC+1
   1001  0620		       4c e4 02 	      jmp	NextIL
   1002  0623							;
   1003  0623							;=====================================================
   1004  0623							; Handle the ERR opcode.  Following the instruction is
   1005  0623							; a 16 bit error number.  Print an error message, and
   1006  0623							; if we're in run mode, print the line number.  Stop
   1007  0623							; program execution and return to the initial state.
   1008  0623							;
   1009  0623		       20 be 0c    iERR       jsr	getILWord	;get err code
   1010  0626							;
   1011  0626							; Enter here with the error code in X (LSB) and A (MSB).
   1012  0626							;
   1013  0626		       86 83	   iErr2      stx	R0
   1014  0628		       85 84		      sta	R0+1
   1015  062a							;
   1016  062a		       20 12 f0 	      jsr	puts
      0  062d					      db	"Error ",0
      1  062d		       45 72 72 6f*	      .byte.b	"Error ",0
   1018  0634		       20 5f 0d 	      jsr	PrintDecimal
   1019  0637							;
   1020  0637		       a5 92		      lda	RunMode	;running?
   1021  0639		       f0 3b		      beq	iERR3	;nope
   1022  063b		       20 12 f0 	      jsr	puts
      0  063e					      db	" at line ",0
      1  063e		       20 61 74 20*	      .byte.b	" at line ",0
   1024  0648		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
   1025  064a				   iErr2a
   1026  064a		       b1 80		      lda	(CURPTR),y
   1027  064c		       85 83		      sta	R0
   1028  064e		       c8		      iny
   1029  064f		       b1 80		      lda	(CURPTR),y
   1030  0651		       85 84		      sta	R0+1
   1031  0653		       20 5f 0d 	      jsr	PrintDecimal
   1032  0656		       20 12 f0 	      jsr	puts
      0  0659					      db	":",0
      1  0659		       3a 00		      .byte.b	":",0
   1034  065b		       a9 00		      lda	#0
   1035  065d		       85 84		      sta	R0+1
   1036  065f		       a5 82		      lda	CUROFF
   1037  0661		       18		      clc
   1038  0662		       e9 03		      sbc	#3
   1039  0664		       85 83		      sta	R0
   1040  0666		       20 5f 0d 	      jsr	PrintDecimal
   1041  0669		       20 12 f0 	      jsr	puts
      0  066c					      db	":",0
      1  066c		       3a 00		      .byte.b	":",0
   1043  066e		       ad b0 15 	      lda	taskPtr
   1044  0671		       85 83		      sta	R0
   1045  0673		       20 5f 0d 	      jsr	PrintDecimal
   1046  0676							;
   1047  0676		       20 0c 02    iERR3      jsr	CRLF
   1048  0679		       a9 00		      lda	#0
   1049  067b		       85 92		      sta	RunMode	;fall through...
   1050  067d							;
   1051  067d							;=====================================================
   1052  067d							; Reset the IL to be back at the idle loop.  Does not
   1053  067d							; clear variables so the user can see what state
   1054  067d							; the program is in.
   1055  067d							;
   1056  067d		       a9 00	   ResetIL    lda	#0
   1057  067f		       85 79		      sta	ILSTACKPTR
   1058  0681		       ad 20 1b 	      lda	errGoto
   1059  0684		       85 75		      sta	ILPC
   1060  0686		       ad 21 1b 	      lda	errGoto+1
   1061  0689		       85 76		      sta	ILPC+1
   1062  068b		       4c e4 02 	      jmp	NextIL
   1063  068e
   1064  068e							;
   1065  068e							;=====================================================
   1066  068e							; Pop two items off stack, add them, then place the
   1067  068e							; result back onto the stack.
   1068  068e							;
   1069  068e		       20 ba 0f    iADD       jsr	popR0
   1070  0691		       20 cf 0f 	      jsr	popR1
   1071  0694		       18		      clc
   1072  0695		       a5 83		      lda	R0
   1073  0697		       65 85		      adc	R1
   1074  0699		       85 83		      sta	R0
   1075  069b		       a5 84		      lda	R0+1
   1076  069d		       65 86		      adc	R1+1
   1077  069f		       85 84		      sta	R0+1
   1078  06a1		       4c 0c 07 	      jmp	pushR0nextIl
   1079  06a4							;
   1080  06a4							;=====================================================
   1081  06a4							; Pop two items off the stack.  Subtract the top of
   1082  06a4							; stack from the lower entry.
   1083  06a4							;
   1084  06a4		       20 cf 0f    iSUB       jsr	popR1
   1085  06a7		       20 ba 0f 	      jsr	popR0
   1086  06aa		       38		      sec
   1087  06ab		       a5 83		      lda	R0
   1088  06ad		       e5 85		      sbc	R1
   1089  06af		       85 83		      sta	R0
   1090  06b1		       a5 84		      lda	R0+1
   1091  06b3		       e5 86		      sbc	R1+1
   1092  06b5		       85 84		      sta	R0+1
   1093  06b7		       4c 0c 07 	      jmp	pushR0nextIl
   1094  06ba							;
   1095  06ba							;=====================================================
   1096  06ba							; Negate the top of stack.
   1097  06ba							;
   1098  06ba		       20 ba 0f    iNEG       jsr	popR0
   1099  06bd		       a5 83		      lda	R0
   1100  06bf		       49 ff		      eor	#$ff
   1101  06c1		       85 83		      sta	R0
   1102  06c3		       a5 84		      lda	R0+1
   1103  06c5		       49 ff		      eor	#$ff
   1104  06c7		       85 84		      sta	R0+1
   1105  06c9		       e6 83		      inc	R0
   1106  06cb		       d0 02		      bne	iNEG2
   1107  06cd		       e6 84		      inc	R0+1
   1108  06cf		       4c 0c 07    iNEG2      jmp	pushR0nextIl
   1109  06d2							;
   1110  06d2							;=====================================================
   1111  06d2							; Multiply top two items on the stack, put the results
   1112  06d2							; on top.  This uses the algorithm documented on page
   1113  06d2							; 115 of "Microprocessor Programming for Computer
   1114  06d2							; Hobbyists" by Neill Graham.
   1115  06d2							;
   1116  06d2		       20 d8 06    iMUL       jsr	iMultiply
   1117  06d5		       4c e4 02 	      jmp	NextIL
   1118  06d8
   1119  06d8				   iMultiply
   1120  06d8		       20 ba 0f 	      jsr	popR0	;AC
   1121  06db		       20 cf 0f 	      jsr	popR1	;OP
   1122  06de							;
   1123  06de		       a5 83		      lda	R0
   1124  06e0		       85 87		      sta	MQ
   1125  06e2		       a5 84		      lda	R0+1
   1126  06e4		       85 88		      sta	MQ+1
   1127  06e6		       a9 00		      lda	#0	;clear result
   1128  06e8		       85 83		      sta	R0
   1129  06ea		       85 84		      sta	R0+1
   1130  06ec							;
   1131  06ec		       a2 10		      ldx	#16	;number of bits in value
   1132  06ee		       06 83	   multloop   asl	R0
   1133  06f0		       26 84		      rol	R0+1
   1134  06f2		       06 87		      asl	MQ
   1135  06f4		       26 88		      rol	MQ+1
   1136  06f6		       90 0d		      bcc	multno	;skip add if no carry
   1137  06f8							;
   1138  06f8							; Add R1 back into R0
   1139  06f8							;
   1140  06f8		       18		      clc
   1141  06f9		       a5 83		      lda	R0
   1142  06fb		       65 85		      adc	R1
   1143  06fd		       85 83		      sta	R0
   1144  06ff		       a5 84		      lda	R0+1
   1145  0701		       65 86		      adc	R1+1
   1146  0703		       85 84		      sta	R0+1
   1147  0705							;
   1148  0705		       ca	   multno     dex		;did all bits yet?
   1149  0706		       d0 e6		      bne	multloop
   1150  0708		       20 42 0f 	      jsr	pushR0	;OP
   1151  070b		       60		      rts
   1152  070c							;
   1153  070c				   pushR0nextIl
   1154  070c		       20 42 0f 	      jsr	pushR0	;OP
   1155  070f		       4c e4 02 	      jmp	NextIL
   1156  0712							;
   1157  0712							;=====================================================
   1158  0712							; Divide the top of stack into the next to top item.
   1159  0712							; Leave results on stack.  Taken from:
   1160  0712							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1161  0712							;
   1162  0712							; R0 = R0 / R1
   1163  0712							; Remainder is in MQ
   1164  0712							;
   1165  0712		       20 2c 07    iDIV       jsr	iDoDiv
   1166  0715		       20 34 10 	      jsr	RestoreSigns
   1167  0718		       4c 0c 07 	      jmp	pushR0nextIl
   1168  071b
   1169  071b		       20 2c 07    iMOD       jsr	iDoDiv
   1170  071e		       20 34 10 	      jsr	RestoreSigns
   1171  0721		       a5 87		      lda	MQ
   1172  0723		       85 83		      sta	R0
   1173  0725		       a5 88		      lda	MQ+1
   1174  0727		       85 84		      sta	R0+1
   1175  0729		       4c 0c 07 	      jmp	pushR0nextIl
   1176  072c
   1177  072c				   iDoDiv
   1178  072c		       20 cf 0f 	      jsr	popR1
   1179  072f		       20 ba 0f 	      jsr	popR0
   1180  0732							;
   1181  0732							; Check for divide by zero
   1182  0732							;
   1183  0732
   1184  0732				   iDivNoPop
   1185  0732		       a5 85		      lda	R1
   1186  0734		       05 86		      ora	R1+1
   1187  0736		       f0 29		      beq	divby0
   1188  0738							;
   1189  0738		       20 f9 0f 	      jsr	SaveSigns
   1190  073b		       a9 00		      lda	#0	;preset remainder to 0
   1191  073d		       85 87		      sta	MQ
   1192  073f		       85 88		      sta	MQ+1
   1193  0741		       a2 10		      ldx	#16	;repeat for each bit: ...
   1194  0743				   divloop
   1195  0743		       06 83		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1196  0745		       26 84		      rol	R0+1
   1197  0747		       26 87		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1198  0749		       26 88		      rol	MQ+1
   1199  074b		       a5 87		      lda	MQ
   1200  074d		       38		      sec
   1201  074e		       e5 85		      sbc	R1	;substract divisor to see if it fits in
   1202  0750		       a8		      tay		;lb result -> Y, for we may need it later
   1203  0751		       a5 88		      lda	MQ+1
   1204  0753		       e5 86		      sbc	R1+1
   1205  0755		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1206  0757
   1207  0757		       85 88		      sta	MQ+1	;else save substraction result as new remainder,
   1208  0759		       84 87		      sty	MQ
   1209  075b		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1210  075d
   1211  075d		       ca	   skip       dex
   1212  075e		       d0 e3		      bne	divloop
   1213  0760		       60		      rts
   1214  0761							;
   1215  0761							; Indicate divide-by-zero error
   1216  0761							;
   1217  0761		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1218  0763		       a9 00		      lda	#0
   1219  0765		       4c 26 06 	      jmp	iErr2
   1220  0768							;
   1221  0768							;=====================================================
   1222  0768							; This pops the top two items off the stack.  The top
   1223  0768							; item is a data value and the other is an index into
   1224  0768							; the variable table.	Save the value into that entry.
   1225  0768							;
   1226  0768		       20 ba 0f    iSTORE     jsr	popR0	;data
   1227  076b		       20 cf 0f 	      jsr	popR1	;index
   1228  076e		       a6 85		      ldx	R1	;get index
   1229  0770		       a5 83		      lda	R0
   1230  0772		       95 41		      sta	variables,x
   1231  0774		       a5 84		      lda	R0+1
   1232  0776		       95 42		      sta	variables+1,x
   1233  0778		       4c e4 02 	      jmp	NextIL
   1234  077b							;
   1235  077b							;=====================================================
   1236  077b							; Replaces the top of stack with the variable whose
   1237  077b							; index it represents.
   1238  077b							;
   1239  077b				   iIND
   1240  077b		       20 cf 0f 	      jsr	popR1
   1241  077e		       a6 85		      ldx	R1	;get index
   1242  0780		       b5 41		      lda	variables,x
   1243  0782		       85 83		      sta	R0
   1244  0784		       b5 42		      lda	variables+1,x
   1245  0786		       85 84		      sta	R0+1
   1246  0788		       4c 0c 07 	      jmp	pushR0nextIl
   1247  078b							;
   1248  078b							;=====================================================
   1249  078b							; Get the array index from top of stack get Current variable
   1250  078b							; index from next on stack, add the offset
   1251  078b							; push the result back onto the stack
   1252  078b				   iArray
   1253  078b		       20 ba 0f 	      jsr	popR0
   1254  078e		       20 cf 0f 	      jsr	popR1
   1255  0791		       a5 83		      lda	R0	; Verify that it is not zero
   1256  0793		       05 84		      ora	R0+1
   1257  0795		       f0 15		      beq	iArrayError
   1258  0797		       c6 83		      dec	R0	; Basic array index starts at 1
   1259  0799		       a5 83		      lda	R0
   1260  079b		       18		      clc
   1261  079c		       2a		      rol
   1262  079d		       65 85		      adc	R1
   1263  079f		       c9 34		      cmp	#(26*2)
   1264  07a1		       b0 09		      bcs	iArrayError
   1265  07a3		       85 83		      sta	R0
   1266  07a5		       a5 84		      lda	R0+1
   1267  07a7		       d0 03		      bne	iArrayError
   1268  07a9		       4c 0c 07 	      jmp	pushR0nextIl
   1269  07ac							; Get here if array index is out of range
   1270  07ac				   iArrayError
   1271  07ac		       a9 00		      lda	#0
   1272  07ae		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1273  07b0		       4c 26 06 	      jmp	iErr2
   1274  07b3							;
   1275  07b3							;=====================================================
   1276  07b3							; List the current BASIC program in memory.  Uses R0,
   1277  07b3							; tempIly, and dpl.
   1278  07b3							;
   1279  07b3		       20 e4 10    iLST       jsr	SetOutConsole
   1280  07b6		       a9 32	   iLST2      lda	#ProgramStart&$ff
   1281  07b8		       85 89		      sta	dpl
   1282  07ba		       a9 1b		      lda	#ProgramStart>>8
   1283  07bc		       85 8a		      sta	dpl+1
   1284  07be							;
   1285  07be							; dpl/dph point to the current line.  See if we're at
   1286  07be							; the end of the program.
   1287  07be							;
   1288  07be		       a5 89	   iLSTloop   lda	dpl
   1289  07c0		       cd 2a 1b 	      cmp	PROGRAMEND
   1290  07c3		       d0 07		      bne	iLstNotEnd
   1291  07c5		       a5 8a		      lda	dpl+1
   1292  07c7		       cd 2b 1b 	      cmp	PROGRAMEND+1
   1293  07ca		       f0 40		      beq	iLstdone
   1294  07cc							;
   1295  07cc		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1296  07ce		       b1 89		      lda	(dpl),y	;line number LSB
   1297  07d0		       85 83		      sta	R0
   1298  07d2		       c8		      iny
   1299  07d3		       b1 89		      lda	(dpl),y	;line number MSB
   1300  07d5		       85 84		      sta	R0+1
   1301  07d7		       c8		      iny
   1302  07d8		       84 8d		      sty	tempIlY
   1303  07da		       20 5f 0d 	      jsr	PrintDecimal
   1304  07dd		       a9 20		      lda	#SPACE
   1305  07df		       20 ef 10 	      jsr	VOUTCH
   1306  07e2		       a4 8d		      ldy	tempIlY
   1307  07e4		       b1 89	   iLSTl2     lda	(dpl),y
   1308  07e6		       f0 0a		      beq	iLST3	;end of this line 0 value
   1309  07e8		       84 8d		      sty	tempIlY
   1310  07ea		       20 ef 10 	      jsr	VOUTCH
   1311  07ed		       a4 8d		      ldy	tempIlY
   1312  07ef		       c8		      iny
   1313  07f0		       d0 f2		      bne	iLSTl2	;do next char
   1314  07f2							;
   1315  07f2							; End of this line.  Print CR/LF, then move to the
   1316  07f2							; next line.
   1317  07f2							;
   1318  07f2		       c8	   iLST3      iny		;Move to next line
   1319  07f3		       18		      clc		;Clear the carry flag
   1320  07f4		       98		      tya		;Current Offset
   1321  07f5		       65 89		      adc	dpl	;Add the offset to the pointer
   1322  07f7		       85 89		      sta	dpl	;Save the new value
   1323  07f9		       a5 8a		      lda	dpl+1	;Next byte
   1324  07fb		       69 00		      adc	#0	;ad in the carry if any
   1325  07fd		       85 8a		      sta	dpl+1	;Save it
   1326  07ff							;
   1327  07ff							; Have to manually do CR/LF so it uses the vectored
   1328  07ff							; output function.
   1329  07ff							;
   1330  07ff		       a9 0d		      lda	#CR
   1331  0801		       20 ef 10 	      jsr	VOUTCH
   1332  0804		       a9 0a		      lda	#LF
   1333  0806		       20 ef 10 	      jsr	VOUTCH
   1334  0809		       4c be 07 	      jmp	iLSTloop	;do next line
   1335  080c							;
   1336  080c		       20 e4 10    iLstdone   jsr	SetOutConsole
   1337  080f		       4c e4 02 	      jmp	NextIL
   1338  0812							;
   1339  0812							;=====================================================
   1340  0812							; Get a line of text into LINBUF.  Terminate with a
   1341  0812							; null byte.
   1342  0812							;
   1343  0812				   iGETLINE
   1344  0812		       a9 3e		      lda	#'>	;prompt character
   1345  0814		       a6 00		      ldx	0	;Wait for read to complete
   1346  0816		       20 42 0e 	      jsr	GetLine
   1347  0819							;
   1348  0819		       a9 00		      lda	#0
   1349  081b		       85 92		      sta	RunMode
   1350  081d		       4c e4 02 	      jmp	NextIL
   1351  0820							;
   1352  0820							;=====================================================
   1353  0820							; This is called when the input buffer contains a line
   1354  0820							; typed in by the user that starts with a line number.
   1355  0820							; Insert the line into the program or delete the line
   1356  0820							; if there is nothing after the line number,
   1357  0820							;
   1358  0820		       a0 00	   iINSRT     ldy	#0
   1359  0822		       20 cb 0d 	      jsr	getDecimal	;convert line #
   1360  0825		       20 63 10 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1361  0828		       84 8e		      sty	offset	;Save the start of the program line text
   1362  082a							;
   1363  082a							; Now find the line OR the next higher line OR the
   1364  082a							; end of the program.
   1365  082a							;
   1366  082a		       20 fd 0c 	      jsr	findLine	; Look for the line number in the current program
   1367  082d							; Returns Z and curptr point to the line if found
   1368  082d							; Returns C and curptr at next higher line if not found and there is a higher line
   1369  082d							; Returns ZC clear and curptr to end of program if higher than all other lines
   1370  082d							;
   1371  082d							; If the line exists, it needs to be removed.
   1372  082d							;
   1373  082d		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1374  082f							;
   1375  082f							; Get length of line to be removed, we fall thru to here if we find a matching line
   1376  082f							;
   1377  082f							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1378  082f		       a0 00		      ldy	#0
   1379  0831		       b1 80		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1380  0833		       a8		      tay
   1381  0834							;If it is equal we delete the line and replace it, get length
   1382  0834							;then adjust all program line after up or down depending on len of line
   1383  0834							;If next higher then just move everythimg down by length bytes
   1384  0834							;This call will return how many bytes in the line we found
   1385  0834		       84 8f		      sty	lineLength	;Save the length of the line we found
   1386  0836							;
   1387  0836							; Compute the new end of the program first.
   1388  0836							;
   1389  0836		       38		      sec		;Set the carry bit
   1390  0837		       ad 2a 1b 	      lda	PROGRAMEND	;Get low byte of program end
   1391  083a		       e5 8f		      sbc	lineLength	;Subtract the length of the current line
   1392  083c		       8d 2a 1b 	      sta	PROGRAMEND	;save it
   1393  083f		       ad 2b 1b 	      lda	PROGRAMEND+1
   1394  0842		       e9 00		      sbc	#0	;Process the carry
   1395  0844		       8d 2b 1b 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1396  0847							;
   1397  0847							; Copy CURPTR into R1 for working
   1398  0847							;
   1399  0847		       a5 80		      lda	CURPTR	;Save the current position to r1 copy destination
   1400  0849		       85 85		      sta	R1
   1401  084b		       a5 81		      lda	CURPTR+1
   1402  084d		       85 86		      sta	R1+1
   1403  084f							;
   1404  084f							; See if we're at the end.
   1405  084f							;
   1406  084f		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1407  0851		       cd 2a 1b 	      cmp	PROGRAMEND
   1408  0854		       d0 07		      bne	InsDelLoop
   1409  0856		       a5 86		      lda	R1+1
   1410  0858		       cd 2b 1b 	      cmp	PROGRAMEND+1
   1411  085b		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1412  085d							;
   1413  085d							; Move one byte, move to next location.
   1414  085d							;
   1415  085d		       a4 8f	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1416  085f		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1417  0861		       b1 85		      lda	(R1),y
   1418  0863		       a0 00		      ldy	#0
   1419  0865		       91 85		      sta	(R1),y
   1420  0867		       e6 85		      inc	R1
   1421  0869		       d0 e4		      bne	InsDelChk
   1422  086b		       e6 86		      inc	R1+1
   1423  086d		       4c 4f 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1424  0870							;
   1425  0870							; Deletion is done.
   1426  0870							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1427  0870							;
   1428  0870		       a4 8e	   insert2    ldy	offset	;get back ptr	Get the current offset
   1429  0872		       b9 96 1a 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1430  0875		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1431  0877							;
   1432  0877							; CURPTR points to where the line will be inserted.
   1433  0877							;
   1434  0877		       20 fc 0e 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1435  087a							;
   1436  087a		       ad 2a 1b 	      lda	PROGRAMEND	;Load the start address for the copy
   1437  087d							;At this point curptr still contains the location we will insert data
   1438  087d		       85 93		      sta	FROM
   1439  087f		       ad 2b 1b 	      lda	PROGRAMEND+1
   1440  0882		       85 94		      sta	FROM+1
   1441  0884							;
   1442  0884		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1443  0886		       b1 93		      lda	(FROM),y
   1444  0888		       a4 8f		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1445  088a		       91 93		      sta	(FROM),y	;Save the new byte
   1446  088c							;
   1447  088c		       a5 93		      lda	FROM	;Check if we have copies the last byte
   1448  088e		       c5 80		      cmp	CURPTR
   1449  0890		       d0 06		      bne	mvUpMore
   1450  0892		       a5 94		      lda	FROM+1
   1451  0894		       c5 81		      cmp	CURPTR+1
   1452  0896		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1453  0898							;
   1454  0898							; Not done yet
   1455  0898							;
   1456  0898		       a5 93	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1457  089a		       d0 02		      bne	mvUpMore2
   1458  089c		       c6 94		      dec	FROM+1
   1459  089e		       c6 93	   mvUpMore2  dec	FROM
   1460  08a0		       4c 84 08 	      jmp	mvup1	;Loop until everything is moved
   1461  08a3							;
   1462  08a3							; All done with copy.
   1463  08a3							;
   1464  08a3		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1465  08a4		       a5 8f		      lda	lineLength	;Number of bytes to copy from line buff
   1466  08a6		       6d 2a 1b 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1467  08a9		       8d 2a 1b 	      sta	PROGRAMEND
   1468  08ac		       ad 2b 1b 	      lda	PROGRAMEND+1
   1469  08af		       69 00		      adc	#0
   1470  08b1		       8d 2b 1b 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1471  08b4							;
   1472  08b4							;===================jlit use length before line newline
   1473  08b4
   1474  08b4		       a0 00		      ldy	#0	;Set offset of copy
   1475  08b6		       a5 8f		      lda	lineLength	;We will insert the actual length of the line first
   1476  08b8		       91 80		      sta	(CURPTR),y	;Store the length
   1477  08ba		       c8		      iny
   1478  08bb		       a5 83		      lda	R0	;Store the line number next
   1479  08bd		       91 80		      sta	(CURPTR),y
   1480  08bf		       c8		      iny
   1481  08c0		       a5 84		      lda	R0+1
   1482  08c2		       91 80		      sta	(CURPTR),y
   1483  08c4		       c8		      iny
   1484  08c5							;
   1485  08c5		       a6 8e		      ldx	offset	;Load the offset into line buffer in page zero
   1486  08c7		       bd 96 1a    mvUpLoop2  lda	LINBUF,x	;get a byte
   1487  08ca		       91 80		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1488  08cc		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1489  08ce		       e8		      inx
   1490  08cf		       c8		      iny
   1491  08d0		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1492  08d2							;
   1493  08d2		       4c e4 02    mvUpFini   jmp	NextIL
   1494  08d5							;
   1495  08d5							;=====================================================
   1496  08d5							; Pops the top value of the ILPC stack and stores it
   1497  08d5							; in ILPC.  Ie, return from an IL subroutine.
   1498  08d5							;
   1499  08d5		       20 ee 0c    iRTN       jsr	popILPC
   1500  08d8		       4c e4 02 	      jmp	NextIL
   1501  08db							;
   1502  08db							;=====================================================
   1503  08db							; NLINE print a newline
   1504  08db							;
   1505  08db		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1506  08de		       4c e4 02 	      jmp	NextIL
   1507  08e1							;
   1508  08e1							;=====================================================
   1509  08e1							; This saves the current ILPC value on the stack, then
   1510  08e1							; jumps to the address specified by the next two bytes.
   1511  08e1							;
   1512  08e1		       20 d8 0c    iCALL      jsr	pushILPC	;save ILPC
   1513  08e4							;
   1514  08e4							; Jmp to a specific location in the IL code.  The new
   1515  08e4							; address immediately follows the opcode.
   1516  08e4							;
   1517  08e4		       20 be 0c    iJMP       jsr	getILWord
   1518  08e7		       86 75		      stx	ILPC
   1519  08e9		       85 76		      sta	ILPC+1
   1520  08eb		       4c e4 02 	      jmp	NextIL
   1521  08ee							;
   1522  08ee							;=====================================================
   1523  08ee							; Push the next two bytes onto the arithmetic stack.
   1524  08ee							;
   1525  08ee		       20 be 0c    iLIT       jsr	getILWord
   1526  08f1		       86 83		      stx	R0
   1527  08f3		       85 84		      sta	R0+1
   1528  08f5		       20 42 0f 	      jsr	pushR0
   1529  08f8		       4c e4 02 	      jmp	NextIL
   1530  08fb							;
   1531  08fb							;=====================================================
   1532  08fb							; Initialize all variables.  Ie, set to zero.
   1533  08fb							;
   1534  08fb		       a9 00	   iVINIT     lda	#0
   1535  08fd		       a2 00		      ldx	#0
   1536  08ff		       95 41	   Vinit2     sta	variables,x
   1537  0901		       e8		      inx
   1538  0902		       e0 34		      cpx	#variablesEnd-variables
   1539  0904		       d0 f9		      bne	Vinit2
   1540  0906		       4c e4 02 	      jmp	NextIL
   1541  0909							;
   1542  0909							;=====================================================
   1543  0909							; Set the address of the error handler.  After any
   1544  0909							; error, set to the ILPC to the specified location.
   1545  0909							;
   1546  0909		       20 be 0c    iERRGOTO   jsr	getILWord
   1547  090c		       8e 20 1b 	      stx	errGoto
   1548  090f		       8d 21 1b 	      sta	errGoto+1
   1549  0912		       4c e4 02 	      jmp	NextIL
   1550  0915							;
   1551  0915							;=====================================================
   1552  0915							; TST is followed by an 8 bit signed offset, then a
   1553  0915							; null terminated string.  Compare the string against
   1554  0915							; the string starting at (CURPTR),CUROFF.  If the
   1555  0915							; strings match, continue executing the next IL
   1556  0915							; opcode.  Else, add the offset to ILPC.
   1557  0915							;
   1558  0915		       20 c2 0c    iTST       jsr	getILByte
   1559  0918		       85 8e		      sta	offset
   1560  091a							;
   1561  091a		       20 30 0f 	      jsr	saveIL	;in case of failure
   1562  091d		       a4 82		      ldy	CUROFF
   1563  091f		       84 89		      sty	dpl	;save for later
   1564  0921							;
   1565  0921		       20 c2 0c    iTSTloop   jsr	getILByte	;get next char
   1566  0924		       f0 11		      beq	iTSTm	;match!
   1567  0926		       a4 89		      ldy	dpl
   1568  0928		       d1 80		      cmp	(CURPTR),y
   1569  092a		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1570  092c		       09 20		      ora	#$20	; lets allow lowercase as well
   1571  092e		       d1 80		      cmp	(CURPTR),y
   1572  0930		       d0 22		      bne	iTSTfail	;mismatch
   1573  0932		       c8	   iTSTUpper  iny
   1574  0933		       84 89		      sty	dpl
   1575  0935		       d0 ea		      bne	iTSTloop
   1576  0937							;
   1577  0937							; It's a match!  Clean up a bit.
   1578  0937							;
   1579  0937		       a4 89	   iTSTm      ldy	dpl
   1580  0939		       84 82		      sty	CUROFF
   1581  093b		       4c e4 02 	      jmp	NextIL
   1582  093e							; Test for a single quote
   1583  093e		       20 c2 0c    iTSTStr    jsr	getILByte
   1584  0941		       85 8e		      sta	offset
   1585  0943		       20 30 0f 	      jsr	saveIL
   1586  0946		       a4 82		      ldy	CUROFF
   1587  0948		       a9 22		      lda	#'"
   1588  094a		       d1 80		      cmp	(CURPTR),y
   1589  094c		       d0 06		      bne	iTSTfail
   1590  094e		       c8		      iny
   1591  094f		       84 82		      sty	CUROFF
   1592  0951		       4c 00 03 	      jmp	NextILStr
   1593  0954							;
   1594  0954							; Not a match, reset ILPC and then move to the
   1595  0954							; offset.
   1596  0954							;
   1597  0954		       20 39 0f    iTSTfail   jsr	restoreIL
   1598  0957		       4c 05 0a 	      jmp	tstBranch
   1599  095a							;
   1600  095a							;=================================================JLIT=
   1601  095a							; Test if we have a let statement without the let keyword
   1602  095a		       20 c2 0c    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1603  095d		       85 8e		      sta	offset	; Save the jump offset for fails
   1604  095f		       20 30 0f 	      jsr	saveIL	; save to restore when done
   1605  0962		       a4 82		      ldy	CUROFF	; Get the current offset into the buffer
   1606  0964		       20 63 10 	      jsr	SkipSpaces	; move to first element on line
   1607  0967		       84 82		      sty	CUROFF	; Just remember skipped spaces
   1608  0969		       c8		      iny		; skip the Variable name
   1609  096a		       20 63 10 	      jsr	SkipSpaces	; skip any SkipSpaces
   1610  096d		       b1 80		      lda	(CURPTR),y	; Get what should be an equal sign
   1611  096f		       c9 3d		      cmp	#'=	; check if equals
   1612  0971		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1613  0973		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1614  0975		       d0 dd		      bne	iTSTfail	; return it failed
   1615  0977		       20 39 0f    iTSTLETGOOD jsr	restoreIL	; restore the IL anyway
   1616  097a		       4c e4 02 	      jmp	NextIL	; Then next instruction
   1617  097d
   1618  097d							;================================================jLIT=
   1619  097d							;Test for end of line
   1620  097d							;
   1621  097d		       20 c2 0c    iTSTDONE   jsr	getILByte
   1622  0980		       85 8e		      sta	offset
   1623  0982		       20 30 0f 	      jsr	saveIL
   1624  0985		       a4 82		      ldy	CUROFF
   1625  0987		       84 89		      sty	dpl
   1626  0989		       20 63 10 	      jsr	SkipSpaces
   1627  098c		       b1 80		      lda	(CURPTR),y
   1628  098e		       f0 0b		      beq	iTSTDONEtrue
   1629  0990		       c9 3a		      cmp	#COLON
   1630  0992		       f0 07		      beq	iTSTDONEtrue
   1631  0994		       a4 89		      ldy	dpl
   1632  0996		       84 82		      sty	CUROFF
   1633  0998		       4c 54 09 	      jmp	iTSTfail
   1634  099b							;
   1635  099b							; Advance to the next line
   1636  099b							;
   1637  099b				   iTSTDONEtrue
   1638  099b		       4c e4 02 	      jmp	NextIL
   1639  099e							;
   1640  099e							;=====================================================
   1641  099e							; TSTV is followed by an 8 bit signed offset.	If the
   1642  099e							; value at (CURPTR),CUROFF appears to be a variable
   1643  099e							; name, move to the next IL statement.  Else, add the
   1644  099e							; offset to ILPC.
   1645  099e							;
   1646  099e		       20 c2 0c    iTSTV      jsr	getILByte	;offset
   1647  09a1		       85 8e		      sta	offset
   1648  09a3							;
   1649  09a3		       a4 82		      ldy	CUROFF
   1650  09a5		       20 63 10 	      jsr	SkipSpaces
   1651  09a8		       b1 80		      lda	(CURPTR),y
   1652  09aa							;
   1653  09aa		       09 20		      ora	#$20	;make lower then upper
   1654  09ac		       49 20		      eor	#$20	;allow lower case here
   1655  09ae		       c9 41		      cmp	#'A
   1656  09b0		       90 53		      bcc	tstBranch
   1657  09b2		       c9 5b		      cmp	#'Z+1
   1658  09b4		       b0 4f		      bcs	tstBranch
   1659  09b6							;
   1660  09b6							; The condition is true, so convert to an index, push
   1661  09b6							; it onto the stack and continue running.
   1662  09b6							;
   1663  09b6		       38		      sec
   1664  09b7		       e9 41		      sbc	#'A	;index is zero based
   1665  09b9		       0a		      asl		;multiply by two
   1666  09ba		       85 83		      sta	R0
   1667  09bc		       a9 00		      lda	#0
   1668  09be		       85 84		      sta	R0+1
   1669  09c0		       20 42 0f 	      jsr	pushR0	;put index onto stack
   1670  09c3		       e6 82		      inc	CUROFF	;move to next input char
   1671  09c5		       4c e4 02 	      jmp	NextIL
   1672  09c8							;
   1673  09c8							;=====================================================
   1674  09c8							; TSTL seems basically the same as TSTN, but leave the
   1675  09c8							; value in R0 instead of pushing onto stack.
   1676  09c8							; This tests for a valid line number
   1677  09c8							;
   1678  09c8		       20 c2 0c    iTSTL      jsr	getILByte
   1679  09cb		       85 8e		      sta	offset
   1680  09cd							;
   1681  09cd		       a4 82		      ldy	CUROFF
   1682  09cf		       20 63 10 	      jsr	SkipSpaces
   1683  09d2		       b1 80		      lda	(CURPTR),y
   1684  09d4							;
   1685  09d4		       c9 30		      cmp	#'0
   1686  09d6		       90 2d		      bcc	tstBranch
   1687  09d8		       c9 3a		      cmp	#'9+1
   1688  09da		       b0 29		      bcs	tstBranch
   1689  09dc							;
   1690  09dc							; It's a digit, so convert to a number.
   1691  09dc							;
   1692  09dc		       20 cb 0d 	      jsr	getDecimal
   1693  09df		       4c e4 02 	      jmp	NextIL
   1694  09e2							;
   1695  09e2							;=====================================================
   1696  09e2							; TSTN checks for a number.  This is very simplistic;
   1697  09e2							; if the character is a digit, assume it's a number.
   1698  09e2							; Convert to a number and push it onto the stack.
   1699  09e2							;
   1700  09e2		       20 c2 0c    iTSTN      jsr	getILByte
   1701  09e5		       85 8e		      sta	offset
   1702  09e7							;
   1703  09e7		       a4 82		      ldy	CUROFF
   1704  09e9		       20 63 10 	      jsr	SkipSpaces
   1705  09ec		       b1 80		      lda	(CURPTR),y
   1706  09ee		       c9 2d		      cmp	#'-	;negative?
   1707  09f0		       f0 08		      beq	iTSTN_1
   1708  09f2		       c9 30		      cmp	#'0
   1709  09f4		       90 0f		      bcc	tstBranch
   1710  09f6		       c9 3a		      cmp	#'9+1
   1711  09f8		       b0 0b		      bcs	tstBranch
   1712  09fa							;
   1713  09fa							; It's a digit, so convert to a number.
   1714  09fa							;
   1715  09fa		       20 cb 0d    iTSTN_1    jsr	getDecimal
   1716  09fd		       84 82		      sty	CUROFF
   1717  09ff		       20 42 0f 	      jsr	pushR0	;save onto stack
   1718  0a02		       4c e4 02 	      jmp	NextIL
   1719  0a05
   1720  0a05							;
   1721  0a05							; Common jump point for all TSTx instructions that
   1722  0a05							; fail to meet the requirements.  This takes the
   1723  0a05							; offset and adds/subtracts to/from ILPC.
   1724  0a05							;
   1725  0a05		       a5 8e	   tstBranch  lda	offset	;get signed offset
   1726  0a07		       10 0e		      bpl	tstPositive
   1727  0a09							;
   1728  0a09							; Do negative branch.	Do sign extension.
   1729  0a09							;
   1730  0a09		       18		      clc
   1731  0a0a		       65 75		      adc	ILPC
   1732  0a0c		       85 75		      sta	ILPC
   1733  0a0e		       a5 76		      lda	ILPC+1
   1734  0a10		       69 ff		      adc	#$ff
   1735  0a12		       85 76		      sta	ILPC+1
   1736  0a14		       4c e4 02 	      jmp	NextIL	;keep going
   1737  0a17							;
   1738  0a17		       18	   tstPositive clc
   1739  0a18		       65 75		      adc	ILPC
   1740  0a1a		       85 75		      sta	ILPC
   1741  0a1c		       a5 76		      lda	ILPC+1
   1742  0a1e		       69 00		      adc	#0
   1743  0a20		       85 76		      sta	ILPC+1
   1744  0a22		       4c e4 02 	      jmp	NextIL
   1745  0a25
   1746  0a25							;
   1747  0a25							;====================================================
   1748  0a25							; Test for IRQ pending, and test if a break key pressed
   1749  0a25							; Yes I know but this handles all sorts of irq/break issues
   1750  0a25							;
   1751  0a25		       20 c2 0c    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1752  0a28		       85 8e		      sta	offset	; Store the not true jump address offset
   1753  0a2a		       20 1f 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1754  0a2d		       d0 03		      bne	irqNo	; z not set of no break found
   1755  0a2f		       4c 12 06 	      jmp	iFIN	; Exit out of run mode
   1756  0a32		       ad ad 15    irqNo      lda	IRQPending
   1757  0a35		       f0 ce		      beq	tstBranch
   1758  0a37		       c9 01		      cmp	#1	; only do this if set to first time
   1759  0a39		       d0 ca		      bne	tstBranch
   1760  0a3b		       78		      sei		; disable the interupt until ireturn resets it
   1761  0a3c		       ee ad 15    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1762  0a3f		       20 57 0f 	      jsr	pushLN	; Push the next line to be executed
   1763  0a42		       b0 11		      bcs	irqErra	; Check if there was an error
   1764  0a44		       ad ae 15 	      lda	IRQEntry	; Get the line number to branch to
   1765  0a47		       85 80		      sta	CURPTR	; put line number into r0
   1766  0a49		       ad af 15 	      lda	IRQEntry+1
   1767  0a4c		       85 81		      sta	CURPTR+1
   1768  0a4e		       a9 03		      lda	#3	; Point to first byte of program text
   1769  0a50		       85 82		      sta	CUROFF
   1770  0a52		       4c e4 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1771  0a55		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1772  0a57		       a9 00		      lda	#0	; stop the execution
   1773  0a59		       4c 26 06 	      jmp	iErr2
   1774  0a5c							;
   1775  0a5c							;======================================================
   1776  0a5c							; iTaskSwitch	 switch to new task if not interrupt and
   1777  0a5c							;		 count is exceded for task time slice
   1778  0a5c							;
   1779  0a5c				   iTaskSwitch
   1780  0a5c		       ad ad 15 	      lda	IRQPending	; Skip this if we are processing an irq
   1781  0a5f		       05 90		      ora	taskIOPending	; If set then don't switch
   1782  0a61		       d0 38		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
   1783  0a63
   1784  0a63		       ad 85 16    iTaskMain  lda	taskCounter	; Number of tasks
   1785  0a66		       c9 01		      cmp	#1	; if there is only one task must be main
   1786  0a68		       d0 07		      bne	itasknext	; if it some other number continue to next
   1787  0a6a
   1788  0a6a		       ac b0 15 	      ldy	taskPtr	; check if we have not just ended some other task
   1789  0a6d		       d0 02		      bne	itasknext	; if so then do a next anyway
   1790  0a6f		       f0 2a		      beq	iTaskSwitchDone	; Skip this if main is only task
   1791  0a71
   1792  0a71				   itasknext
   1793  0a71		       ce 83 16 	      dec	taskCurrentCycles	; Dec the current cycle count
   1794  0a74		       d0 25		      bne	iTaskSwitchDone	; Skip this if we are not end of cycle
   1795  0a76							;
   1796  0a76							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
   1797  0a76							;
   1798  0a76		       ac b0 15 	      ldy	taskPtr
   1799  0a79		       20 0e 0f 	      jsr	ContextSave	; Save the current context, y points to next context
   1800  0a7c				   itaskLoop
   1801  0a7c		       c0 d2		      cpy	#TASKTABLELEN	;Are we at end of task table
   1802  0a7e		       90 02		      bcc	iTaskNextChk
   1803  0a80
   1804  0a80		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
   1805  0a82				   iTaskNextChk
   1806  0a82		       b9 b1 15 	      lda	taskTable,y	; there is always at least one entry in table
   1807  0a85		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
   1808  0a87		       18		      clc
   1809  0a88		       98		      tya
   1810  0a89		       69 15		      adc	#CONTEXTLEN+1	; Next Table entry
   1811  0a8b		       a8		      tay
   1812  0a8c		       4c 7c 0a 	      jmp	itaskLoop	; Check for busy entry
   1813  0a8f
   1814  0a8f
   1815  0a8f				   iTaskLoadEntry
   1816  0a8f		       20 1d 0f 	      jsr	ContextLoad	; load the next context
   1817  0a92		       8c b0 15 	      sty	taskPtr	; update the task pointer
   1818  0a95
   1819  0a95		       ad 84 16    iTaskReloadCnt lda	taskResetValue	;reset the clock ticks
   1820  0a98		       8d 83 16 	      sta	taskCurrentCycles
   1821  0a9b
   1822  0a9b				   iTaskSwitchDone
   1823  0a9b		       60		      rts
   1824  0a9c							;
   1825  0a9c							;=====================================================
   1826  0a9c							; This places the number of free bytes on top of the
   1827  0a9c							; stack.
   1828  0a9c							;
   1829  0a9c		       20 b1 10    iFREE      jsr	GetSizes
   1830  0a9f		       20 42 0f 	      jsr	pushR0
   1831  0aa2		       4c e4 02 	      jmp	NextIL
   1832  0aa5							;
   1833  0aa5							;=====================================================
   1834  0aa5							; Generate a random number from 0-FFFF and then MOD
   1835  0aa5							; it with the value on top of stack.  Leaves number on
   1836  0aa5							; stack
   1837  0aa5							;
   1838  0aa5		       20 cf 0f    iRANDOM    jsr	popR1	;mod value
   1839  0aa8							;
   1840  0aa8							; If the value is zero, just return a one.
   1841  0aa8							;
   1842  0aa8		       a5 85		      lda	R1
   1843  0aaa		       05 86		      ora	R1+1
   1844  0aac		       f0 4a		      beq	irandom1
   1845  0aae							;
   1846  0aae		       ad 26 1b 	      lda	random+1
   1847  0ab1		       8d 23 1b 	      sta	rtemp1
   1848  0ab4		       ad 25 1b 	      lda	random
   1849  0ab7		       0a		      asl
   1850  0ab8		       2e 23 1b 	      rol	rtemp1
   1851  0abb		       0a		      asl
   1852  0abc		       2e 23 1b 	      rol	rtemp1
   1853  0abf		       18		      clc
   1854  0ac0		       6d 25 1b 	      adc	random
   1855  0ac3		       48		      pha
   1856  0ac4		       ad 23 1b 	      lda	rtemp1
   1857  0ac7		       6d 26 1b 	      adc	random+1
   1858  0aca		       8d 26 1b 	      sta	random+1
   1859  0acd		       68		      pla
   1860  0ace		       69 11		      adc	#$11
   1861  0ad0		       8d 25 1b 	      sta	random
   1862  0ad3		       ad 26 1b 	      lda	random+1
   1863  0ad6		       69 36		      adc	#$36
   1864  0ad8		       8d 26 1b 	      sta	random+1
   1865  0adb
   1866  0adb		       ad 25 1b 	      lda	random
   1867  0ade		       85 83		      sta	R0
   1868  0ae0		       ad 26 1b 	      lda	random+1
   1869  0ae3		       29 7f		      and	#$7f	;make positive
   1870  0ae5		       85 84		      sta	R0+1
   1871  0ae7							;
   1872  0ae7							; R0 contains the number and R1 contains the max value.
   1873  0ae7							;
   1874  0ae7		       20 32 07 	      jsr	iDivNoPop
   1875  0aea		       20 34 10 	      jsr	RestoreSigns
   1876  0aed		       a5 87		      lda	MQ
   1877  0aef		       85 83		      sta	R0
   1878  0af1		       a5 88		      lda	MQ+1
   1879  0af3		       85 84		      sta	R0+1
   1880  0af5		       4c 0c 07 	      jmp	pushR0nextIl
   1881  0af8				   irandom1
   1882  0af8		       a9 00		      lda	#0
   1883  0afa		       85 84		      sta	R0+1
   1884  0afc		       a9 01		      lda	#1
   1885  0afe		       85 83		      sta	R0
   1886  0b00		       4c 0c 07 	      jmp	pushR0nextIl
   1887  0b03
   1888  0b03							; The following replaced by call to division/modulo
   1889  0b03							;iRANDOM_2	lda	R0
   1890  0b03							;		cmp	R1
   1891  0b03							;		bne	iRANDOM_1
   1892  0b03							;		lda	R0+1
   1893  0b03							;		cmp	R1+1
   1894  0b03							;		bne	iRANDOM_1	;need to subtract
   1895  0b03							;
   1896  0b03							; Subtract R1 from R0
   1897  0b03							;
   1898  0b03							;iRANDOM_sub	sec
   1899  0b03							;		lda	R0
   1900  0b03							;		sbc	R1
   1901  0b03							;		sta	R0
   1902  0b03							;		lda	R0+1
   1903  0b03							;		sbc	R1+1
   1904  0b03							;		sta	R0+1
   1905  0b03							;		jmp	iRANDOM_2
   1906  0b03							;
   1907  0b03							; See if R1 > R0.  If so, branch to subtract.
   1908  0b03							;
   1909  0b03							;iRANDOM_1	lda	R0
   1910  0b03							;		cmp	R1
   1911  0b03							;		lda	R0+1
   1912  0b03							;		sbc	R1+1
   1913  0b03							;		bvc	iRANDOM_4
   1914  0b03							;		eor	#$80
   1915  0b03							;iRANDOM_4	bpl	iRANDOM_sub
   1916  0b03							;
   1917  0b03							; All done.  Almost.  Add one, then push the result.
   1918  0b03							;
   1919  0b03							;irandom1	inc	R0
   1920  0b03							;		bne	iRANDOM_3
   1921  0b03							;		inc	R0+1
   1922  0b03							;iRANDOM_3
   1923  0b03							;		  jsr	pushR0	;return value
   1924  0b03							;		jmp	NextIL
   1925  0b03							;
   1926  0b03							; Poke a value into a memory location
   1927  0b03		       8c 29 1b    iPOKEMEMORY sty	tempy
   1928  0b06		       20 ba 0f 	      jsr	popR0
   1929  0b09		       20 cf 0f 	      jsr	popR1
   1930  0b0c		       a0 00		      ldy	#0
   1931  0b0e		       a5 83		      lda	R0
   1932  0b10		       91 85		      sta	(R1),y
   1933  0b12		       ac 29 1b 	      ldy	tempy
   1934  0b15		       4c e4 02 	      jmp	NextIL
   1935  0b18							;
   1936  0b18							; Get a value from a memory location
   1937  0b18							;
   1938  0b18		       8c 29 1b    iPEEKMEMORY sty	tempy
   1939  0b1b		       20 ba 0f 	      jsr	popR0
   1940  0b1e		       a0 00		      ldy	#0
   1941  0b20		       b1 83		      lda	(R0),y
   1942  0b22		       ac 29 1b 	      ldy	tempy
   1943  0b25		       85 83		      sta	R0
   1944  0b27		       a9 00		      lda	#0
   1945  0b29		       85 84		      sta	R0+1
   1946  0b2b		       4c 0c 07 	      jmp	pushR0nextIl
   1947  0b2e							;
   1948  0b2e							; Call to address return what ever is in a to the stack
   1949  0b2e							; func2 will load a value into a before the call
   1950  0b2e		       20 cf 0f    iCallFunc  jsr	popR1
   1951  0b31		       a5 85		      lda	R1
   1952  0b33		       20 3f 0b 	      jsr	iCallRtn
   1953  0b36		       85 83		      sta	R0
   1954  0b38		       a9 00		      lda	#0
   1955  0b3a		       85 84		      sta	R0+1
   1956  0b3c		       20 0c 07 	      jsr	pushR0nextIl
   1957  0b3f				   iCallRtn
   1958  0b3f		       20 ba 0f 	      jsr	popR0
   1959  0b42		       6c 83 00 	      jmp	(R0)
   1960  0b45
   1961  0b45
   1962  0b45							;===========================================jlit======
   1963  0b45							;Get a character from the terminal convert to value
   1964  0b45							;leave the number on top of the stack
   1965  0b45							;
   1966  0b45				   iGETCHAR
   1967  0b45							;		  jsr	  pushLN      ;Save state before getline
   1968  0b45		       20 09 02 	      jsr	GETCH
   1969  0b48					      if	CTMON65
   1970  0b48		       48		      pha
   1971  0b49		       20 0c f0 	      jsr	cout	;echo echo echo
   1972  0b4c		       68		      pla
   1973  0b4d					      endif
   1974  0b4d		       85 83		      sta	R0
   1975  0b4f		       a9 00		      lda	#0
   1976  0b51		       85 84		      sta	R0+1
   1977  0b53		       20 42 0f 	      jsr	pushR0
   1978  0b56							;
   1979  0b56							;		  jsr	  popLN
   1980  0b56		       4c e4 02 	      jmp	NextIL
   1981  0b59							;===========================================jlit======
   1982  0b59							;Put a character to the terminal convert to
   1983  0b59							;
   1984  0b59		       20 ba 0f    iPUTCHAR   jsr	popR0
   1985  0b5c		       a5 83		      lda	R0
   1986  0b5e		       20 06 02 	      jsr	OUTCH
   1987  0b61		       4c e4 02 	      jmp	NextIL
   1988  0b64							;=====================================================
   1989  0b64							; Put the number on the stack out as hex, suppress leading 0
   1990  0b64				   iHexOut
   1991  0b64		       20 ba 0f 	      jsr	popR0
   1992  0b67		       a5 84		      lda	R0+1
   1993  0b69		       f0 03		      beq	iHexSecondByte
   1994  0b6b		       20 0f 02 	      jsr	OUTHEX
   1995  0b6e				   iHexSecondByte
   1996  0b6e		       a5 83		      lda	R0
   1997  0b70		       20 0f 02 	      jsr	OUTHEX
   1998  0b73		       4c e4 02 	      jmp	NextIL
   1999  0b76							;
   2000  0b76							;=====================================================
   2001  0b76							; Replace TOS with its absolute value.
   2002  0b76							;
   2003  0b76		       20 ba 0f    iABS       jsr	popR0
   2004  0b79		       a5 84		      lda	R0+1
   2005  0b7b		       10 10		      bpl	iABS_1	;already positive
   2006  0b7d		       49 ff		      eor	#$ff
   2007  0b7f		       85 84		      sta	R0+1
   2008  0b81		       a5 83		      lda	R0
   2009  0b83		       49 ff		      eor	#$ff
   2010  0b85		       85 83		      sta	R0
   2011  0b87		       e6 83		      inc	R0
   2012  0b89		       d0 02		      bne	iABS_1
   2013  0b8b		       e6 84		      inc	R0+1
   2014  0b8d		       4c 0c 07    iABS_1     jmp	pushR0nextIl
   2015  0b90
   2016  0b90							;================================================================
   2017  0b90							;Set the IRQ service rtn line number
   2018  0b90							;
   2019  0b90		       78	   iSetIrq    sei		; disable the interupts
   2020  0b91		       a9 00		      lda	#0	; Zero the Status flag
   2021  0b93		       8d ac 15 	      sta	IRQStatus
   2022  0b96		       20 ba 0f 	      jsr	popR0	; get the line number
   2023  0b99		       a5 83		      lda	R0
   2024  0b9b		       05 84		      ora	R0+1
   2025  0b9d		       f0 1b		      beq	iSetExt	; if it is zero disable all
   2026  0b9f		       20 57 0f 	      jsr	pushLN	; Save the current line pointer
   2027  0ba2		       20 fd 0c 	      jsr	findLine	; Find the IRQ func Line Pointer
   2028  0ba5		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2029  0ba7		       a5 81		      lda	CURPTR+1	; Copy it to the Entry pointer
   2030  0ba9		       8d af 15 	      sta	IRQEntry+1
   2031  0bac		       a5 80		      lda	CURPTR
   2032  0bae		       8d ae 15 	      sta	IRQEntry
   2033  0bb1		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2034  0bb3		       8d ac 15 	      sta	IRQStatus
   2035  0bb6		       20 7a 0f 	      jsr	popLN	; Restore the old line number
   2036  0bb9		       58		      cli		; Enable the interupts
   2037  0bba		       4c e4 02    iSetExt    jmp	NextIL
   2038  0bbd
   2039  0bbd		       20 7a 0f    iSetIrqErr jsr	popLN
   2040  0bc0		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2041  0bc2		       a9 00		      lda	#0
   2042  0bc4		       4c 26 06 	      jmp	iErr2
   2043  0bc7							;
   2044  0bc7							;================================================================
   2045  0bc7							; Task Set task number to line number to start
   2046  0bc7							; Task Table structure:
   2047  0bc7							;    byte 0	-   Active inactive 0 or 1
   2048  0bc7							;    byte 1-2	-   Basic code line pointer
   2049  0bc7							;    byte 3	-   Offset on current line
   2050  0bc7		       98	   iTaskSet   tya
   2051  0bc8		       48		      pha
   2052  0bc9		       20 57 0f 	      jsr	pushLN	; Store the current line number
   2053  0bcc		       20 ba 0f 	      jsr	popR0	; Get the line number to be saved
   2054  0bcf		       a5 83		      lda	R0	; if the value is zero then return current task PID
   2055  0bd1		       05 84		      ora	R0+1
   2056  0bd3		       f0 70		      beq	iTaskRetCurrent
   2057  0bd5
   2058  0bd5							;Find the pointer to the line we need to start at
   2059  0bd5		       20 fd 0c 	      jsr	findLine	; Get the offset of the line to start task at
   2060  0bd8		       f0 05		      beq	iTaskCont
   2061  0bda		       68		      pla
   2062  0bdb		       a8		      tay
   2063  0bdc		       4c bd 0b 	      jmp	iSetIrqErr	; Bad line number provided
   2064  0bdf				   iTaskCont
   2065  0bdf		       ac b0 15 	      ldy	taskPtr	; where to save the context
   2066  0be2		       20 0e 0f 	      jsr	ContextSave	; Save the original context
   2067  0be5		       20 aa 0c 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
   2068  0be8		       90 4f		      bcc	iTaskNoEmpty	; There are no more empty slots
   2069  0bea		       a5 80		      lda	CURPTR
   2070  0bec		       8d 23 1b 	      sta	rtemp1	; Save the new line number for the new task
   2071  0bef		       a5 81		      lda	CURPTR+1
   2072  0bf1		       8d 24 1b 	      sta	rtemp1+1	; Save it
   2073  0bf4		       20 1d 0f 	      jsr	ContextLoad	; load the context of the new task
   2074  0bf7		       ad 23 1b 	      lda	rtemp1
   2075  0bfa		       85 80		      sta	CURPTR
   2076  0bfc		       ad 24 1b 	      lda	rtemp1+1
   2077  0bff		       85 81		      sta	CURPTR+1
   2078  0c01		       a9 03		      lda	#3	; Offset to first instruction
   2079  0c03		       85 82		      sta	CUROFF
   2080  0c05
   2081  0c05		       a9 01		      lda	#1
   2082  0c07		       99 b1 15 	      sta	taskTable,y	; Mark as busy/used
   2083  0c0a
   2084  0c0a		       a9 00		      lda	#0
   2085  0c0c		       85 79		      sta	ILSTACKPTR
   2086  0c0e		       85 7c		      sta	MATHSTACKPTR
   2087  0c10		       85 7f		      sta	GOSUBSTACKPTR
   2088  0c12		       a9 5d		      lda	#STMT&$FF
   2089  0c14		       85 75		      sta	ILPC
   2090  0c16		       a9 12		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
   2091  0c18		       85 76		      sta	ILPC+1
   2092  0c1a		       98		      tya
   2093  0c1b		       48		      pha
   2094  0c1c		       20 0e 0f 	      jsr	ContextSave
   2095  0c1f
   2096  0c1f		       ee 85 16 	      inc	taskCounter	; Update the number of Tasks running
   2097  0c22		       ac b0 15 	      ldy	taskPtr
   2098  0c25		       20 1d 0f 	      jsr	ContextLoad	; restore the original context
   2099  0c28		       68		      pla
   2100  0c29		       a8		      tay
   2101  0c2a
   2102  0c2a				   iTaskGetCurrent
   2103  0c2a		       20 7a 0f 	      jsr	popLN
   2104  0c2d		       98		      tya
   2105  0c2e		       85 83		      sta	R0	;Get the table entry value
   2106  0c30		       a9 00		      lda	#0
   2107  0c32		       85 84		      sta	R0+1
   2108  0c34		       68		      pla
   2109  0c35		       a8		      tay
   2110  0c36		       4c 0c 07 	      jmp	pushR0nextIl
   2111  0c39				   iTaskNoEmpty
   2112  0c39		       20 7a 0f 	      jsr	popLN
   2113  0c3c		       68		      pla
   2114  0c3d		       a8		      tay
   2115  0c3e		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
   2116  0c40		       a9 00		      lda	#0
   2117  0c42		       4c 26 06 	      jmp	iErr2
   2118  0c45				   iTaskRetCurrent		;Get if task number is zero Current task
   2119  0c45		       ac b0 15 	      ldy	taskPtr
   2120  0c48		       4c 2a 0c 	      jmp	iTaskGetCurrent
   2121  0c4b							;
   2122  0c4b							;================================================================
   2123  0c4b							; Returns task Status
   2124  0c4b				   iTaskStat
   2125  0c4b		       20 5a 0c 	      jsr	iTaskValid	; returns pointer to task entry
   2126  0c4e		       a9 00		      lda	#0
   2127  0c50		       85 84		      sta	R0+1
   2128  0c52		       b9 b1 15 	      lda	taskTable,y
   2129  0c55		       85 83		      sta	R0
   2130  0c57		       4c 0c 07 	      jmp	pushR0nextIl
   2131  0c5a							;
   2132  0c5a							;================================================================
   2133  0c5a							; Validate the task number on top of the stack
   2134  0c5a							; on exit y points to the requested task entry
   2135  0c5a							;
   2136  0c5a		       20 ba 0f    iTaskValid jsr	popR0	; get result of the multiply
   2137  0c5d		       a5 84		      lda	R0+1
   2138  0c5f		       d0 06		      bne	iTaskValidErr	; high byte must be zero
   2139  0c61		       a5 83		      lda	R0
   2140  0c63		       c9 d2		      cmp	#TASKTABLELEN
   2141  0c65		       90 09		      bcc	iTaskIsValid
   2142  0c67
   2143  0c67		       68	   iTaskValidErr pla		;remove return address
   2144  0c68		       68		      pla
   2145  0c69		       a2 10		      ldx	#ERR_INVALID_PID
   2146  0c6b		       a9 00		      lda	#0
   2147  0c6d		       4c 26 06 	      jmp	iErr2
   2148  0c70
   2149  0c70		       a8	   iTaskIsValid tay
   2150  0c71		       60		      rts
   2151  0c72							;
   2152  0c72							;================================================================
   2153  0c72							; Kill a running task, do nothing if already stopped
   2154  0c72		       20 5a 0c    iTaskKill  jsr	iTaskValid
   2155  0c75		       a9 00		      lda	#0
   2156  0c77		       99 b1 15 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
   2157  0c7a							;
   2158  0c7a							;================================================================
   2159  0c7a							;Skip to next task
   2160  0c7a				   iNTask
   2161  0c7a		       a9 01		      lda	#1
   2162  0c7c		       8d 83 16 	      sta	taskCurrentCycles
   2163  0c7f		       4c e4 02 	      jmp	NextIL
   2164  0c82							;
   2165  0c82							;=======================================================
   2166  0c82							; Set task io lock
   2167  0c82		       e6 90	   iStartIO   inc	taskIOPending
   2168  0c84		       4c e4 02 	      jmp	NextIL
   2169  0c87							;
   2170  0c87							;=======================================================
   2171  0c87							; Release the io lock
   2172  0c87		       a5 90	   iEndIO     lda	taskIOPending
   2173  0c89		       f0 02		      beq	iEndIOExit
   2174  0c8b		       c6 90		      dec	taskIOPending
   2175  0c8d		       4c e4 02    iEndIOExit jmp	NextIL
   2176  0c90
   2177  0c90							;
   2178  0c90							;================================================================
   2179  0c90							; Terminate a task
   2180  0c90		       ac b0 15    iETask     ldy	taskPtr
   2181  0c93		       c0 00		      cpy	#0
   2182  0c95		       d0 03		      bne	iETaskCont
   2183  0c97		       4c 12 06 	      jmp	iFIN	; if the main task does a ETASK then stop
   2184  0c9a				   iETaskCont
   2185  0c9a		       a9 00		      lda	#0
   2186  0c9c		       99 b1 15 	      sta	taskTable,y	; mark entry as free
   2187  0c9f		       ce 85 16 	      dec	taskCounter	; reduce the number of active tasks
   2188  0ca2		       a9 01		      lda	#1
   2189  0ca4		       8d 83 16 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
   2190  0ca7				   iETaskExit
   2191  0ca7		       4c e4 02 	      jmp	NextIL
   2192  0caa
   2193  0caa							;
   2194  0caa							;================================================================
   2195  0caa							; Find an empty slot in the taskTable
   2196  0caa							; Return the index in y
   2197  0caa							; on exit   c set if an empty slot is found
   2198  0caa							;	     c clear if not found
   2199  0caa							;================================================================
   2200  0caa							;
   2201  0caa				   TaskEmpty
   2202  0caa		       a0 15		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
   2203  0cac				   TaskLoop
   2204  0cac		       b9 b1 15 	      lda	taskTable,y
   2205  0caf		       f0 0b		      beq	TaskEmptyFnd
   2206  0cb1		       98		      tya
   2207  0cb2		       18		      clc
   2208  0cb3		       69 15		      adc	#CONTEXTLEN+1
   2209  0cb5		       a8		      tay
   2210  0cb6		       c0 d2		      cpy	#TASKTABLELEN
   2211  0cb8		       90 f2		      bcc	TaskLoop	; Y is never zero
   2212  0cba				   TaskNoSlot
   2213  0cba		       18		      clc
   2214  0cbb		       60		      rts
   2215  0cbc				   TaskEmptyFnd
   2216  0cbc		       38		      sec
   2217  0cbd		       60		      rts
   2218  0cbe
   2219  0cbe							;
   2220  0cbe							;=================================================================
   2221  0cbe							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0cbe					      include	"support.asm"
      1  0cbe							;
      2  0cbe							;=====================================================
      3  0cbe							;=====================================================
      4  0cbe							;=====================================================
      5  0cbe							; This marks the start of support functions used by
      6  0cbe							; the IL opcodes.  These are support functions, NOT
      7  0cbe							; the IL code.
      8  0cbe							;=====================================================
      9  0cbe							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  0cbe							;=====================================================
     11  0cbe					      Seg	Code
     12  0cbe							;=====================================================
     13  0cbe							; This gets the next two bytes pointed to by ILPC and
     14  0cbe							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0cbe							; is advanced by two, and Y contains 0 on return.
     16  0cbe
     17  0cbe							;
     18  0cbe		       20 c2 0c    getILWord  jsr	getILByte	;LSB
     19  0cc1		       aa		      tax
     20  0cc2							;
     21  0cc2							;=====================================================
     22  0cc2							; This gets the next byte pointed to by ILPC and
     23  0cc2							; returns it in A.  On return, X is unchanged but Y
     24  0cc2							; contains 0.
     25  0cc2							;
     26  0cc2		       a0 00	   getILByte  ldy	#0
     27  0cc4		       b1 75		      lda	(ILPC),y	;get byte
     28  0cc6		       08		      php		;save status
     29  0cc7		       e6 75		      inc	ILPC	;inc LSB
     30  0cc9		       d0 02		      bne	getILb2	;branch if no overflow
     31  0ccb		       e6 76		      inc	ILPC+1	;inc MSB
     32  0ccd		       28	   getILb2    plp		;restore status
     33  0cce		       60		      rts
     34  0ccf							;
     35  0ccf							;=====================================================
     36  0ccf							; Decrement ILPC by one.
     37  0ccf							;
     38  0ccf		       a5 75	   decIL      lda	ILPC
     39  0cd1		       d0 02		      bne	decIL2
     40  0cd3		       c6 76		      dec	ILPC+1
     41  0cd5		       c6 75	   decIL2     dec	ILPC
     42  0cd7		       60		      rts
     43  0cd8							;
     44  0cd8							;=====================================================
     45  0cd8							; Push the ILPC onto the return stack.  Actually, this
     46  0cd8							; pushes the address of ILPC+2 since that's the next
     47  0cd8							; address to execute.
     48  0cd8							;
     49  0cd8		       a4 79	   pushILPC   ldy	ILSTACKPTR
     50  0cda		       a5 75		      lda	ILPC
     51  0cdc		       18		      clc
     52  0cdd		       69 02		      adc	#2
     53  0cdf		       91 77		      sta	(ILSTACK),y
     54  0ce1		       08		      php		;save C bit
     55  0ce2		       c8		      iny
     56  0ce3		       a5 76		      lda	ILPC+1
     57  0ce5		       28		      plp		;restore C
     58  0ce6		       69 00		      adc	#0
     59  0ce8		       91 77		      sta	(ILSTACK),y
     60  0cea		       c8		      iny
     61  0ceb		       84 79		      sty	ILSTACKPTR
     62  0ced		       60		      rts
     63  0cee							;
     64  0cee							;=====================================================
     65  0cee							; Pull the top entry from return stack and put into
     66  0cee							; ILPC.
     67  0cee							;
     68  0cee		       a4 79	   popILPC    ldy	ILSTACKPTR
     69  0cf0		       88		      dey
     70  0cf1		       b1 77		      lda	(ILSTACK),y
     71  0cf3		       85 76		      sta	ILPC+1
     72  0cf5		       88		      dey
     73  0cf6		       b1 77		      lda	(ILSTACK),y
     74  0cf8		       85 75		      sta	ILPC
     75  0cfa		       84 79		      sty	ILSTACKPTR
     76  0cfc		       60		      rts
     77  0cfd							;
     78  0cfd							;=====================================================
     79  0cfd							; This searches for a specific line number that is in
     80  0cfd							; R0.	There are three possible return conditions:
     81  0cfd							; Line numbers are now the third byte, the first byte is now **************
     82  0cfd							; a pointer to the next line, of course no longer that 53 byte
     83  0cfd							; per line.
     84  0cfd							;
     85  0cfd							; Exact match was found:
     86  0cfd							;    * Z set
     87  0cfd							;    * CURPTR points to two-byte line number for that
     88  0cfd							;	line.
     89  0cfd							;
     90  0cfd							; Next highest line found:
     91  0cfd							;    * Z cleared
     92  0cfd							;    * C set
     93  0cfd							;    * CURPTR points to two-byte line number for that
     94  0cfd							;	line.
     95  0cfd							;
     96  0cfd							; End of program reached:
     97  0cfd							;    * Z cleared
     98  0cfd							;    * C cleared
     99  0cfd							;    * CURPTR points to first free byte at end of
    100  0cfd							;	program.  Ie, it has save value as PROGRAMEND.
    101  0cfd							;
    102  0cfd							; A, X, and Y are all undefined on return.
    103  0cfd							;
    104  0cfd
    105  0cfd				   findLine
    106  0cfd		       a9 32		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    107  0cff		       85 80		      sta	CURPTR
    108  0d01		       a9 1b		      lda	#ProgramStart>>8
    109  0d03		       85 81		      sta	CURPTR+1
    110  0d05							;
    111  0d05							; At end of code?
    112  0d05							;
    113  0d05				   iXFER1
    114  0d05		       a5 80		      lda	CURPTR	; chk CURPTR = END PROGRAM
    115  0d07		       cd 2a 1b 	      cmp	PROGRAMEND	; at end of program then stop run
    116  0d0a		       d0 0b		      bne	xfer2	; not end
    117  0d0c		       a5 81		      lda	CURPTR+1
    118  0d0e		       cd 2b 1b 	      cmp	PROGRAMEND+1
    119  0d11		       d0 04		      bne	xfer2	;Not at end
    120  0d13							;
    121  0d13							; Line not found and the end of the program was
    122  0d13							; reached.  Return Z and C both clear.
    123  0d13							;
    124  0d13		       a9 01		      lda	#1	;clear Z
    125  0d15		       18		      clc		;clear C
    126  0d16		       60		      rts
    127  0d17							;
    128  0d17							; Check for an exact line number match
    129  0d17							;
    130  0d17		       a5 83	   xfer2      lda	R0
    131  0d19		       a0 01		      ldy	#1	; changed to skip extra length byte
    132  0d1b		       d1 80		      cmp	(CURPTR),y
    133  0d1d		       d0 08		      bne	xfernotit
    134  0d1f		       c8		      iny
    135  0d20		       a5 84		      lda	R0+1
    136  0d22		       d1 80		      cmp	(CURPTR),y
    137  0d24		       d0 01		      bne	xfernotit	; not a matching line number
    138  0d26							;
    139  0d26							; This is exactly the line we want.
    140  0d26							;
    141  0d26		       60		      rts		;it matches exactly
    142  0d27							;
    143  0d27							; See if this line is greater than the one we're
    144  0d27							; searching for.
    145  0d27							;
    146  0d27		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    147  0d29		       b1 80		      lda	(CURPTR),y	;compare MSB first
    148  0d2b		       c5 84		      cmp	R0+1
    149  0d2d		       90 0b		      bcc	xfer3
    150  0d2f		       d0 07		      bne	xfer4
    151  0d31		       88		      dey
    152  0d32		       b1 80		      lda	(CURPTR),y	;compare LSB
    153  0d34		       c5 83		      cmp	R0
    154  0d36		       90 02		      bcc	xfer3
    155  0d38							;
    156  0d38							; This line is greater than the one we want, so
    157  0d38							; return Z clear and C set.
    158  0d38							;
    159  0d38		       38	   xfer4      sec		;We found a line number greater
    160  0d39		       60		      rts		;both conditions set
    161  0d3a							;
    162  0d3a							; Not the line (or droid) we're looking for.  Move to
    163  0d3a							; the next line.
    164  0d3a							;
    165  0d3a		       20 40 0d    xfer3      jsr	FindNextLine
    166  0d3d		       4c 05 0d 	      jmp	iXFER1
    167  0d40							;
    168  0d40							;=====================================================
    169  0d40							; This advances CURPTR to the next line.  If there
    170  0d40							; are no more lines, this leaves CURPTR equal to
    171  0d40							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    172  0d40							; CURPTR is pointing to a valid line on entry.  This
    173  0d40							; pointer points to the two-byte line number.
    174  0d40							; Update this points to the 1 byte line length  ****************
    175  0d40							;
    176  0d40				   FindNextLine
    177  0d40		       a0 03		      ldy	#3	;skip line number and length byte
    178  0d42		       84 82		      sty	CUROFF	;this is the new offset
    179  0d44		       a0 00		      ldy	#0
    180  0d46		       b1 80		      lda	(CURPTR),y	;Get the length
    181  0d48		       18		      clc
    182  0d49		       65 80		      adc	CURPTR
    183  0d4b		       85 80		      sta	CURPTR
    184  0d4d		       90 02		      bcc	FindNext4	;exit
    185  0d4f		       e6 81		      inc	CURPTR+1
    186  0d51		       60	   FindNext4  rts
    187  0d52							;
    188  0d52							;=====================================================
    189  0d52							; This compares CURPTR to PROGRAMEND and returns Z set
    190  0d52							; if they are equal, Z clear if not.
    191  0d52							;
    192  0d52		       a5 80	   AtEnd      lda	CURPTR
    193  0d54		       cd 2a 1b 	      cmp	PROGRAMEND
    194  0d57		       d0 05		      bne	atendexit
    195  0d59		       a5 81		      lda	CURPTR+1
    196  0d5b		       cd 2b 1b 	      cmp	PROGRAMEND+1
    197  0d5e		       60	   atendexit  rts
    198  0d5f							;
    199  0d5f							;=====================================================
    200  0d5f							; Print the contents of R0 as a signed decimal number.
    201  0d5f							; Does leading zero suppression.
    202  0d5f							;
    203  0d5f				   PrintDecimal
    204  0d5f		       a5 84		      lda	R0+1	;MSB has sign
    205  0d61		       10 17		      bpl	pplus	;it's a positive number
    206  0d63							;
    207  0d63							; Negative numbers need more work.  Invert all the bits,
    208  0d63							; then add one.
    209  0d63							;
    210  0d63		       a9 2d		      lda	#'-
    211  0d65		       20 ef 10 	      jsr	VOUTCH	;print the negative sign
    212  0d68							;
    213  0d68		       a5 83		      lda	R0	;invert bits
    214  0d6a		       49 ff		      eor	#$ff
    215  0d6c		       85 83		      sta	R0
    216  0d6e		       a5 84		      lda	R0+1
    217  0d70		       49 ff		      eor	#$ff
    218  0d72		       85 84		      sta	R0+1
    219  0d74		       e6 83		      inc	R0	;add one
    220  0d76		       d0 02		      bne	pplus
    221  0d78		       e6 84		      inc	R0+1
    222  0d7a							;
    223  0d7a							; Print the value in R0 as a positive number.
    224  0d7a							;
    225  0d7a		       a2 00	   pplus      ldx	#0	;start of subtraction table
    226  0d7c		       8e 1e 1b 	      stx	diddigit	;no digits yet
    227  0d7f		       a0 00	   pploop     ldy	#0	;result of division
    228  0d81		       a5 83	   pploop2    lda	R0	;LSB
    229  0d83		       38		      sec
    230  0d84		       fd c3 0d 	      sbc	dectable,x
    231  0d87		       85 83		      sta	R0
    232  0d89		       a5 84		      lda	R0+1
    233  0d8b		       fd c4 0d 	      sbc	dectable+1,x
    234  0d8e		       10 2e		      bpl	pplusok	;no underflow
    235  0d90							;
    236  0d90							; Else, underflow.  Add back in the LSB of the
    237  0d90							; table to R0.
    238  0d90							;
    239  0d90		       18		      clc
    240  0d91		       a5 83		      lda	R0
    241  0d93		       7d c3 0d 	      adc	dectable,x
    242  0d96		       85 83		      sta	R0
    243  0d98							;
    244  0d98							; Print the value in Y.  Actually, see if Y is zero and
    245  0d98							; whether any digit has been printed yet.  If Y isn't
    246  0d98							; zero or we've printed a digit, go ahead and print.
    247  0d98							;
    248  0d98		       8e 1b 1b 	      stx	printtx
    249  0d9b		       98		      tya
    250  0d9c		       09 00		      ora	#0	;set flags
    251  0d9e		       d0 05		      bne	pprintit	;non-zero, print
    252  0da0							;
    253  0da0		       ad 1e 1b 	      lda	diddigit
    254  0da3		       f0 09		      beq	pprintno	;don't print
    255  0da5							;
    256  0da5		       98	   pprintit   tya
    257  0da6		       09 30		      ora	#'0
    258  0da8		       8d 1e 1b 	      sta	diddigit
    259  0dab		       20 ef 10 	      jsr	VOUTCH
    260  0dae		       ae 1b 1b    pprintno   ldx	printtx
    261  0db1							;
    262  0db1							; Move to the next table entry
    263  0db1							;
    264  0db1		       e8		      inx
    265  0db2		       e8		      inx
    266  0db3		       e0 08		      cpx	#dectableend-dectable
    267  0db5		       d0 c8		      bne	pploop	;not at end
    268  0db7							;
    269  0db7							; At the end.	R0 contains the final value
    270  0db7							; to print.
    271  0db7							;
    272  0db7		       a5 83		      lda	R0
    273  0db9		       09 30		      ora	#'0
    274  0dbb		       4c ef 10 	      jmp	VOUTCH
    275  0dbe							;
    276  0dbe							; Finish doing the subtraction.
    277  0dbe							;
    278  0dbe		       85 84	   pplusok    sta	R0+1
    279  0dc0		       c8		      iny
    280  0dc1		       d0 be		      bne	pploop2
    281  0dc3							;
    282  0dc3							; Table of powers-of-ten
    283  0dc3							;
      0  0dc3				   dectable   dw	10000
      1  0dc3		       10 27		      .word.w	10000
      0  0dc5					      dw	1000
      1  0dc5		       e8 03		      .word.w	1000
      0  0dc7					      dw	100
      1  0dc7		       64 00		      .word.w	100
      0  0dc9					      dw	10
      1  0dc9		       0a 00		      .word.w	10
    288  0dc9		       0d cb	   dectableend equ	*
    289  0dcb							;
    290  0dcb							;=====================================================
    291  0dcb							; Convert an ASCII string to a number.  On input,
    292  0dcb							; (CURPTR),Y points to the first digit.  This gets
    293  0dcb							; digit-by-digit until finding a non-number.  Returns
    294  0dcb							; Y pointing to the non-digit, and R0 contains the
    295  0dcb							; number.  This does NOT check for valid ranges, so
    296  0dcb							; a value like "123456789" will produce something,
    297  0dcb							; but not what you had expected.
    298  0dcb							;
    299  0dcb		       a9 00	   getDecimal lda	#0
    300  0dcd		       85 83		      sta	R0
    301  0dcf		       85 84		      sta	R0+1
    302  0dd1		       85 89		      sta	dpl	;temporary negative flag
    303  0dd3							;
    304  0dd3							; See if it's negative...
    305  0dd3							;
    306  0dd3		       84 13		      sty	$0013
    307  0dd5		       b1 80		      lda	(CURPTR),y
    308  0dd7		       c9 2d		      cmp	#'-
    309  0dd9		       d0 02		      bne	getDecLoop
    310  0ddb		       e6 89		      inc	dpl	;it's negative
    311  0ddd							;
    312  0ddd		       b1 80	   getDecLoop lda	(CURPTR),y
    313  0ddf		       c9 30		      cmp	#'0
    314  0de1		       90 36		      bcc	getDdone
    315  0de3		       c9 3a		      cmp	#'9+1
    316  0de5		       b0 32		      bcs	getDdone
    317  0de7		       38		      sec
    318  0de8		       e9 30		      sbc	#'0	;convert to binary
    319  0dea		       48		      pha
    320  0deb							;
    321  0deb							; Now multiply R0 by 10.  Remember that
    322  0deb							; 2*N + 8*N = 10*N.
    323  0deb							;
    324  0deb		       06 83		      asl	R0
    325  0ded		       26 84		      rol	R0+1	;*2
    326  0def		       a5 83		      lda	R0
    327  0df1		       85 85		      sta	R1
    328  0df3		       a5 84		      lda	R0+1
    329  0df5		       85 86		      sta	R1+1
    330  0df7		       06 83		      asl	R0
    331  0df9		       26 84		      rol	R0+1	;*4
    332  0dfb		       06 83		      asl	R0
    333  0dfd		       26 84		      rol	R0+1	;*8
    334  0dff		       18		      clc		;now add the partial sums...
    335  0e00		       a5 83		      lda	R0	;...to get *10
    336  0e02		       65 85		      adc	R1
    337  0e04		       85 83		      sta	R0
    338  0e06		       a5 84		      lda	R0+1
    339  0e08		       65 86		      adc	R1+1
    340  0e0a		       85 84		      sta	R0+1
    341  0e0c							;
    342  0e0c							; Add in the new digit
    343  0e0c							;
    344  0e0c		       68		      pla
    345  0e0d		       18		      clc
    346  0e0e		       65 83		      adc	R0
    347  0e10		       85 83		      sta	R0
    348  0e12		       90 02		      bcc	getD2
    349  0e14		       e6 84		      inc	R0+1
    350  0e16							;
    351  0e16							; Move to next character
    352  0e16							;
    353  0e16		       c8	   getD2      iny
    354  0e17		       d0 c4		      bne	getDecLoop
    355  0e19							;
    356  0e19							; All done with digits, so now deal with it being
    357  0e19							; negative.  If zero, then don't check for negative
    358  0e19							; flag.  Ie, -0 is stored as 0.
    359  0e19							;
    360  0e19		       a5 83	   getDdone   lda	R0
    361  0e1b		       05 84		      ora	R0+1
    362  0e1d		       f0 16		      beq	getDone2	;zero
    363  0e1f		       a5 89		      lda	dpl
    364  0e21		       f0 12		      beq	getDone2	;positive
    365  0e23							;
    366  0e23							; Invert all the bits, then add one.
    367  0e23							;
    368  0e23		       a5 83		      lda	R0
    369  0e25		       49 ff		      eor	#$ff
    370  0e27		       85 83		      sta	R0
    371  0e29		       a5 84		      lda	R0+1
    372  0e2b		       49 ff		      eor	#$ff
    373  0e2d		       85 84		      sta	R0+1
    374  0e2f							;
    375  0e2f		       e6 83		      inc	R0
    376  0e31		       d0 02		      bne	getDone2
    377  0e33		       e6 84		      inc	R0+1
    378  0e35				   getDone2
    379  0e35		       a5 83		      lda	R0
    380  0e37		       85 10		      sta	$0010
    381  0e39		       a5 84		      lda	R0+1
    382  0e3b		       85 11		      sta	$0011
    383  0e3d		       a5 89		      lda	dpl
    384  0e3f		       85 12		      sta	$012
    385  0e41
    386  0e41		       60		      rts
    387  0e42							;
    388  0e42							;=====================================================
    389  0e42							; Print the string that immediately follows the JSR to
    390  0e42							; this function.  Stops when a null byte is found,
    391  0e42							; then returns to the instruction immediately
    392  0e42							; following the null.
    393  0e42							;
    394  0e42							; Thanks to Ross Archer for this code.
    395  0e42							; http://www.6502.org/source/io/primm.htm
    396  0e42							;
    397  0e42				  -	      if	KIM
    398  0e42				  -puts       sty	putsy
    399  0e42				  -	      pla		;low part of "return" address
    400  0e42				  -			;(data start address)
    401  0e42				  -	      sta	dpl
    402  0e42				  -	      pla
    403  0e42				  -	      sta	dpl+1	;high part of "return" address
    404  0e42				  -			;(data start address)
    405  0e42				  -			;Note: we're pointing one short
    406  0e42				  -psinb      ldy	#1
    407  0e42				  -	      lda	(dpl),y	;Get next string character
    408  0e42				  -	      inc	dpl	;update the pointer
    409  0e42				  -	      bne	psinc	;if not, we're pntng to next char
    410  0e42				  -	      inc	dpl+1	;account for page crossing
    411  0e42				  -psinc      ora	#0	;Set flags according to contents of
    412  0e42				  -			;   Accumulator
    413  0e42				  -	      beq	psix1	;don't print the final NULL
    414  0e42				  -	      jsr	OUTCH	;write it out
    415  0e42				  -	      jmp	psinb	;back around
    416  0e42				  -psix1      inc	dpl
    417  0e42				  -	      bne	psix2
    418  0e42				  -	      inc	dpl+1	;account for page crossing
    419  0e42				  -psix2      ldy	putsy
    420  0e42				  -	      jmp	(dpl)	;return to byte following NULL
    421  0e42					      endif
    422  0e42							;
    423  0e42							;=====================================================
    424  0e42							; Gets a line of input into LINBUF.
    425  0e42							;
    426  0e42							; On entry:
    427  0e42							;    A contains the prompt character, or 0 if none.
    428  0e42							;    X = 1 Background read
    429  0e42							;    x = 0 Forground read with wait
    430  0e42							;
    431  0e42							; On exit:
    432  0e42							;    CURPTR points to LINBUF
    433  0e42							;    LINBUF contains the line with 0 at the end.
    434  0e42							;    Y has offset to first non-space character
    435  0e42							;    CURROFF has the same as Y.
    436  0e42							;
    437  0e42		       20 91 0e    GetLine    jsr	ReadPrompt
    438  0e45		       e0 00		      cpx	#0
    439  0e47		       f0 14		      beq	GetLineRetry
    440  0e49		       ae b0 15 	      ldx	taskPtr
    441  0e4c		       bd b1 15 	      lda	taskTable,x
    442  0e4f		       c9 03		      cmp	#$03	;Task Active and waiting for IO
    443  0e51		       f0 3d		      beq	taskWaitingIO
    444  0e53		       09 02		      ora	#$02	;Mark Task as waiting for IO
    445  0e55		       9d b1 15 	      sta	taskTable,x	;Mark the state for task as waiting io
    446  0e58		       ce 90 0e 	      dec	taskWaitingIO	;Start polling the input and make task wait
    447  0e5b		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    448  0e5d
    449  0e5d							;
    450  0e5d							; Now read a line and wait for the CR
    451  0e5d							;
    452  0e5d				   GetLineRetry
    453  0e5d		       a9 00		      lda	#0	;Wait for input to complete
    454  0e5f		       20 a9 0e 	      jsr	ReadLine
    455  0e62
    456  0e62							;
    457  0e62							; Point to the line we just read
    458  0e62							; Set the current pointer to point to the input line
    459  0e62							;
    460  0e62		       a0 00	   ReadComplete ldy	#0
    461  0e64		       84 82		      sty	CUROFF
    462  0e66		       a2 96		      ldx	#LINBUF&$ff
    463  0e68		       86 80		      stx	CURPTR
    464  0e6a		       a2 1a		      ldx	#LINBUF>>8
    465  0e6c		       86 81		      stx	CURPTR+1
    466  0e6e							;
    467  0e6e							; Output a CR/LF
    468  0e6e							;
    469  0e6e		       20 0c 02 	      jsr	CRLF
    470  0e71							;
    471  0e71							; If a blank line, prompt again.
    472  0e71							;
    473  0e71		       20 63 10 	      jsr	SkipSpaces
    474  0e74		       b1 80		      lda	(CURPTR),y
    475  0e76		       d0 10		      bne	GetLineDone	;We have data then exit
    476  0e78		       20 94 0e 	      jsr	ReadPromptRetry
    477  0e7b		       ae b0 15 	      ldx	taskPtr	;if this task is waiting for IO
    478  0e7e		       bd b1 15 	      lda	taskTable,x	;then get out, wait for line to
    479  0e81		       c9 03		      cmp	#3	;Complete again
    480  0e83		       f0 0b		      beq	taskWaitingIO
    481  0e85		       4c 5d 0e 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    482  0e88
    483  0e88				   GetLineDone
    484  0e88		       ae b0 15 	      ldx	taskPtr
    485  0e8b		       a9 01		      lda	#1
    486  0e8d		       9d b1 15 	      sta	taskTable,x	;IO is complete
    487  0e90
    488  0e90				   taskWaitingIO
    489  0e90		       60		      rts
    490  0e91
    491  0e91							;
    492  0e91							;=======================================================================
    493  0e91							; Display the prompt character
    494  0e91							; On entry
    495  0e91							;	    A contains the prompt character
    496  0e91							; On exit
    497  0e91							;	    The readbuffer index is reset to 0
    498  0e91							;
    499  0e91		       8d 1d 1b    ReadPrompt sta	promptChar
    500  0e94
    501  0e94							;
    502  0e94							; Prompt
    503  0e94							;
    504  0e94
    505  0e94		       ad 1d 1b    ReadPromptRetry lda	promptChar
    506  0e97		       09 00		      ora	#0	;any prompt?
    507  0e99		       f0 08		      beq	getlinenp
    508  0e9b		       20 06 02 	      jsr	OUTCH
    509  0e9e		       a9 20		      lda	#$20
    510  0ea0		       20 06 02 	      jsr	OUTCH	;Space after prompt
    511  0ea3							;
    512  0ea3		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    513  0ea5		       8e 1a 1b 	      stx	getlinx
    514  0ea8		       60		      rts
    515  0ea9							;
    516  0ea9							;===============================================================
    517  0ea9							; This fuction is the driver for the line input
    518  0ea9							; on call if a = 0 then it waits for all input
    519  0ea9							;	      a = 1 then nowait for input
    520  0ea9							; On exit
    521  0ea9							;		       c clear if not complete line
    522  0ea9							;		       c set if it was a complete line
    523  0ea9
    524  0ea9				   ReadLine
    525  0ea9		       8d 1c 1b 	      sta	inputNoWait
    526  0eac		       c9 00		      cmp	#0
    527  0eae		       f0 05		      beq	getline1
    528  0eb0		       20 15 02 	      jsr	ISCHAR	; if there is no character just get out
    529  0eb3		       f0 2b		      beq	GetLineNoWait
    530  0eb5		       20 09 02    getline1   jsr	GETCH
    531  0eb8					      if	CTMON65
    532  0eb8		       48		      pha
    533  0eb9		       20 0c f0 	      jsr	cout	;echo echo echo
    534  0ebc		       68		      pla
    535  0ebd					      endif
    536  0ebd		       c9 0d		      cmp	#CR
    537  0ebf		       f0 15		      beq	getlind	;end of line
    538  0ec1		       c9 08		      cmp	#BS	;backspace?
    539  0ec3		       f0 1d		      beq	getlinebs
    540  0ec5		       ae 1a 1b 	      ldx	getlinx
    541  0ec8		       9d 96 1a 	      sta	LINBUF,x
    542  0ecb		       e8		      inx
    543  0ecc		       8e 1a 1b 	      stx	getlinx
    544  0ecf		       ad 1c 1b 	      lda	inputNoWait
    545  0ed2		       f0 e1		      beq	getline1
    546  0ed4		       d0 0a		      bne	GetLineNoWait
    547  0ed6							;
    548  0ed6							; CR was hit
    549  0ed6							;
    550  0ed6		       a9 00	   getlind    lda	#0	; set the end pf buffer
    551  0ed8		       ae 1a 1b 	      ldx	getlinx
    552  0edb		       9d 96 1a 	      sta	LINBUF,x
    553  0ede
    554  0ede		       38		      sec		; Carry set then cr received
    555  0edf		       60		      rts
    556  0ee0
    557  0ee0				   GetLineNoWait
    558  0ee0		       18		      clc		; Carry clear no end of line
    559  0ee1		       60		      rts
    560  0ee2							;
    561  0ee2							; Backspace was hit
    562  0ee2							;
    563  0ee2		       ae 1a 1b    getlinebs  ldx	getlinx
    564  0ee5		       f0 0e		      beq	getlineEOL	;at start of line
    565  0ee7		       ca		      dex
    566  0ee8		       8e 1a 1b 	      stx	getlinx
    567  0eeb		       20 12 f0    getlinepbs jsr	puts
      0  0eee					      db	27,"[K",0
      1  0eee		       1b 5b 4b 00	      .byte.b	27,"[K",0
    569  0ef2		       4c b5 0e 	      jmp	getline1
    570  0ef5		       a9 20	   getlineEOL lda	#SPACE
    571  0ef7		       20 06 02 	      jsr	OUTCH
    572  0efa		       d0 ef		      bne	getlinepbs
    573  0efc							;
    574  0efc							;=====================================================
    575  0efc							; Count the length of the line currently in LINBUF
    576  0efc							; starting at offset Y.  Returns the length in X.  The
    577  0efc							; starting offset in Y should point past the ASCII
    578  0efc							; line number.  Also counts the trailing NULL and two
    579  0efc							; extra bytes for where the line number will be.
    580  0efc							; Update must now include leading length byte not the null at end ****************
    581  0efc							;
    582  0efc				   getLineLength
    583  0efc		       a2 00		      ldx	#0	;size
    584  0efe		       b9 96 1a    getLineL2  lda	LINBUF,y
    585  0f01		       f0 04		      beq	getLineL3
    586  0f03		       c8		      iny
    587  0f04		       e8		      inx
    588  0f05		       d0 f7		      bne	getLineL2
    589  0f07		       e8	   getLineL3  inx		;count null at end
    590  0f08		       e8		      inx		;line number LSB
    591  0f09		       e8		      inx		;MSB
    592  0f0a		       e8		      inx		;change: count new leading line length
    593  0f0b		       86 8f		      stx	lineLength
    594  0f0d		       60		      rts
    595  0f0e							;
    596  0f0e							;=====================================================
    597  0f0e							; Count the length of the line pointed to by CURPTR.
    598  0f0e							; This also counts the line number and the terminating
    599  0f0e							; null.  Ie, this string returns 8:
    600  0f0e							;
    601  0f0e							; <lineLow><lineHi>Hello<null>
    602  0f0e							;
    603  0f0e							; Another way of looking at it: add the return value
    604  0f0e							; to the CURPTR and it'll point to the next line's
    605  0f0e							; line number.  Returns the value in Y.
    606  0f0e							; Update to ject get the leading byte length ********************
    607  0f0e							;
    608  0f0e							;getCURPTRLength
    609  0f0e							;		ldy	CURPTR
    610  0f0e							;		ldy	#3	;change: skip line number and leading length byte
    611  0f0e							;getCLineL2	lda	(CURPTR),y
    612  0f0e							;		beq	getCLineL3
    613  0f0e							;		iny
    614  0f0e							;		bne	getCLineL2
    615  0f0e							;getCLineL3	iny		;count null at end
    616  0f0e							;		rts
    617  0f0e							;
    618  0f0e							;=====================================================
    619  0f0e							; Save Context Store the context to the TASK Table
    620  0f0e							; on entry y contains the task table entry to save to
    621  0f0e							; on exit y points to next task table entry
    622  0f0e							;	   x contains the number of bytes copied
    623  0f0e		       a2 00	   ContextSave ldx	#0
    624  0f10		       c8		      iny		;inc past the task flags
    625  0f11		       b5 75	   ContextSvLoop lda	CONTEXT,x
    626  0f13		       99 b1 15 	      sta	taskTable,y
    627  0f16		       c8		      iny
    628  0f17		       e8		      inx
    629  0f18		       e0 14		      cpx	#CONTEXTLEN
    630  0f1a		       90 f5		      bcc	ContextSvLoop
    631  0f1c		       60		      rts
    632  0f1d							;
    633  0f1d							; Load Context transfer context from task table to the Current Context
    634  0f1d							; on entry y contains the task table entry to transfer
    635  0f1d							; on exit y points to the original task table entry
    636  0f1d							;	   x contains the number of byts copied
    637  0f1d		       98	   ContextLoad tya
    638  0f1e		       48		      pha
    639  0f1f		       a2 00		      ldx	#0
    640  0f21		       c8		      iny		;inc past the task flags
    641  0f22		       b9 b1 15    ContextLDLoop lda	taskTable,y
    642  0f25		       95 75		      sta	CONTEXT,x
    643  0f27		       c8		      iny
    644  0f28		       e8		      inx
    645  0f29		       e0 14		      cpx	#CONTEXTLEN
    646  0f2b		       90 f5		      bcc	ContextLDLoop
    647  0f2d		       68		      pla
    648  0f2e		       a8		      tay
    649  0f2f		       60		      rts
    650  0f30							;
    651  0f30							;=====================================================
    652  0f30							; This saves ILPC.  This saves to a single save area,
    653  0f30							; so it can't be called more than once.
    654  0f30							;
    655  0f30		       a5 75	   saveIL     lda	ILPC
    656  0f32		       85 8b		      sta	tempIL
    657  0f34		       a5 76		      lda	ILPC+1
    658  0f36		       85 8c		      sta	tempIL+1
    659  0f38		       60		      rts
    660  0f39							;
    661  0f39							;=====================================================
    662  0f39							; This restores ILPC.
    663  0f39							;
    664  0f39		       a5 8b	   restoreIL  lda	tempIL
    665  0f3b		       85 75		      sta	ILPC
    666  0f3d		       a5 8c		      lda	tempIL+1
    667  0f3f		       85 76		      sta	ILPC+1
    668  0f41		       60		      rts
    669  0f42							;
    670  0f42							;=====================================================
    671  0f42							; This pushes R0 onto the stack.
    672  0f42							;
    673  0f42		       8c 23 1b    pushR0     sty	rtemp1
    674  0f45		       a4 7c		      ldy	MATHSTACKPTR
    675  0f47		       a5 83		      lda	R0
    676  0f49		       91 7a		      sta	(MATHSTACK),y
    677  0f4b		       c8		      iny
    678  0f4c		       a5 84		      lda	R0+1
    679  0f4e		       91 7a		      sta	(MATHSTACK),y
    680  0f50		       c8		      iny
    681  0f51		       84 7c		      sty	MATHSTACKPTR
    682  0f53		       ac 23 1b 	      ldy	rtemp1
    683  0f56		       60		      rts
    684  0f57
    685  0f57							;=====================================================
    686  0f57							; This pushes curptr basic current line onto the call stack.
    687  0f57							; and CUROFF. Also marks entry type as 1 = GOSUB
    688  0f57
    689  0f57				   pushLN
    690  0f57		       8c 23 1b 	      sty	rtemp1
    691  0f5a		       a4 7f		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    692  0f5c		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; Is there space available
    693  0f5e		       f0 18		      beq	pusherr	; No error
    694  0f60		       a2 00		      ldx	#0	; Start of bytes to copy
    695  0f62				   pushLoop
    696  0f62		       b5 80		      lda	CURPTR,x	; Get the current pointer Start address
    697  0f64		       91 7d		      sta	(GOSUBSTACK),y	; put it onto the stack
    698  0f66		       c8		      iny		; Next destination
    699  0f67		       e8		      inx		; Next Source byte
    700  0f68		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    701  0f6a		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    702  0f6c
    703  0f6c		       a9 01	   pushDone   lda	#1	; Type of stack entry, 1 gosub, 2 for , 3 next
    704  0f6e		       91 7d		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    705  0f70		       c8		      iny		; Next entry
    706  0f71
    707  0f71		       84 7f		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    708  0f73		       ac 23 1b 	      ldy	rtemp1
    709  0f76		       18		      clc
    710  0f77		       60		      rts
    711  0f78				   pusherr
    712  0f78		       38		      sec
    713  0f79		       60		      rts
    714  0f7a							;=====================================================
    715  0f7a							; This pops Top Off gosub call Stack and
    716  0f7a							; places it in CURPTR/CUROFF.
    717  0f7a							; This checks if the type = 1 GOSUB
    718  0f7a							; if not it removes what ever is on the stack
    719  0f7a							; until it finds the next return. Allowing
    720  0f7a							; a return from within a for/next
    721  0f7a		       8c 23 1b    popLN      sty	rtemp1
    722  0f7d		       a4 7f		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    723  0f7f		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    724  0f81
    725  0f81				   popContinue
    726  0f81		       c0 04		      cpy	#4	; if less than 4 on stack then error
    727  0f83		       90 18		      bcc	poperr	; Process an error
    728  0f85
    729  0f85		       88		      dey		; Position to read entry type
    730  0f86		       b1 7d		      lda	(GOSUBSTACK),y	; get the stack entry type
    731  0f88		       c9 01		      cmp	#1	; Type is a gosub entry
    732  0f8a		       d0 13		      bne	popSkipEntry	; No then just skip this
    733  0f8c
    734  0f8c				   popLoop
    735  0f8c		       88		      dey
    736  0f8d		       ca		      dex
    737  0f8e		       b1 7d		      lda	(GOSUBSTACK),y
    738  0f90		       95 80		      sta	CURPTR,x
    739  0f92		       e0 00		      cpx	#0
    740  0f94		       d0 f6		      bne	popLoop	; Loop until all moved
    741  0f96
    742  0f96
    743  0f96		       84 7f	   PopDone    sty	GOSUBSTACKPTR
    744  0f98		       ac 23 1b 	      ldy	rtemp1
    745  0f9b		       18		      clc
    746  0f9c		       60		      rts
    747  0f9d		       38	   poperr     sec
    748  0f9e		       60		      rts
    749  0f9f
    750  0f9f		       88	   popSkipEntry dey
    751  0fa0		       88		      dey
    752  0fa1		       88		      dey
    753  0fa2		       4c 81 0f 	      jmp	popContinue
    754  0fa5
    755  0fa5							;
    756  0fa5							;=====================================================
    757  0fa5							; This pushes R1 onto the stack
    758  0fa5							;
    759  0fa5		       8c 23 1b    pushR1     sty	rtemp1
    760  0fa8		       a4 7c		      ldy	MATHSTACKPTR
    761  0faa		       a5 85		      lda	R1
    762  0fac		       91 7a		      sta	(MATHSTACK),y
    763  0fae		       c8		      iny
    764  0faf		       a5 86		      lda	R1+1
    765  0fb1		       91 7a		      sta	(MATHSTACK),y
    766  0fb3		       c8		      iny
    767  0fb4		       84 7c		      sty	MATHSTACKPTR
    768  0fb6		       ac 23 1b 	      ldy	rtemp1
    769  0fb9		       60		      rts
    770  0fba							;
    771  0fba							;=====================================================
    772  0fba							; This pops Top Of Stack and places it in R0.
    773  0fba							;
    774  0fba		       8c 23 1b    popR0      sty	rtemp1
    775  0fbd		       a4 7c		      ldy	MATHSTACKPTR
    776  0fbf		       88		      dey
    777  0fc0		       b1 7a		      lda	(MATHSTACK),y
    778  0fc2		       85 84		      sta	R0+1
    779  0fc4		       88		      dey
    780  0fc5		       b1 7a		      lda	(MATHSTACK),y
    781  0fc7		       85 83		      sta	R0
    782  0fc9		       84 7c		      sty	MATHSTACKPTR
    783  0fcb		       ac 23 1b 	      ldy	rtemp1
    784  0fce		       60		      rts
    785  0fcf
    786  0fcf							;
    787  0fcf							;=====================================================
    788  0fcf							; This pops TOS and places it in R1.
    789  0fcf							;
    790  0fcf		       8c 23 1b    popR1      sty	rtemp1
    791  0fd2		       a4 7c		      ldy	MATHSTACKPTR
    792  0fd4		       88		      dey
    793  0fd5		       b1 7a		      lda	(MATHSTACK),y
    794  0fd7		       85 86		      sta	R1+1
    795  0fd9		       88		      dey
    796  0fda		       b1 7a		      lda	(MATHSTACK),y
    797  0fdc		       85 85		      sta	R1
    798  0fde		       84 7c		      sty	MATHSTACKPTR
    799  0fe0		       ac 23 1b 	      ldy	rtemp1
    800  0fe3		       60		      rts
    801  0fe4							;
    802  0fe4							;=====================================================
    803  0fe4							; This pops TOS and places it in MQ.
    804  0fe4							;
    805  0fe4		       8c 23 1b    popMQ      sty	rtemp1
    806  0fe7		       a4 7c		      ldy	MATHSTACKPTR
    807  0fe9		       88		      dey
    808  0fea		       b1 7a		      lda	(MATHSTACK),y
    809  0fec		       85 88		      sta	MQ+1
    810  0fee		       88		      dey
    811  0fef		       b1 7a		      lda	(MATHSTACK),y
    812  0ff1		       85 87		      sta	MQ
    813  0ff3		       84 7c		      sty	MATHSTACKPTR
    814  0ff5		       ac 23 1b 	      ldy	rtemp1
    815  0ff8		       60		      rts
    816  0ff9							;
    817  0ff9							;=====================================================
    818  0ff9							; This assists with multiplication and division by
    819  0ff9							; looking at R0 and R1 and saving a flag as to what
    820  0ff9							; sign the result will be.  Math is always done on
    821  0ff9							; positive numbers, so this converts negative numbers
    822  0ff9							; into positives.  On exit, R0 and R1 are both
    823  0ff9							; positive.  If the signs were different then 'signs'
    824  0ff9							; will be non-zero.
    825  0ff9							;
    826  0ff9		       a9 00	   SaveSigns  lda	#0
    827  0ffb		       8d 22 1b 	      sta	sign	;assume positive
    828  0ffe		       a5 84		      lda	R0+1	;MSB
    829  1000		       10 13		      bpl	SaveSigns1
    830  1002		       ee 22 1b 	      inc	sign	;it's negative
    831  1005		       49 ff		      eor	#$ff	;flip bits
    832  1007		       85 84		      sta	R0+1
    833  1009		       a5 83		      lda	R0
    834  100b		       49 ff		      eor	#$ff
    835  100d		       85 83		      sta	R0
    836  100f		       e6 83		      inc	R0
    837  1011		       d0 02		      bne	SaveSigns1
    838  1013		       e6 84		      inc	R0+1
    839  1015		       a5 86	   SaveSigns1 lda	R1+1
    840  1017		       10 1a		      bpl	SaveSigns2
    841  1019		       48		      pha
    842  101a		       ad 22 1b 	      lda	sign
    843  101d		       49 01		      eor	#1
    844  101f		       8d 22 1b 	      sta	sign
    845  1022		       68		      pla
    846  1023		       49 ff		      eor	#$ff	;flip bits
    847  1025		       85 86		      sta	R1+1
    848  1027		       a5 85		      lda	R1
    849  1029		       49 ff		      eor	#$ff
    850  102b		       85 85		      sta	R1
    851  102d		       e6 85		      inc	R1
    852  102f		       d0 02		      bne	SaveSigns2
    853  1031		       e6 86		      inc	R1+1
    854  1033		       60	   SaveSigns2 rts
    855  1034							;
    856  1034							;=====================================================
    857  1034							; This looks at the value of 'signs' and will convert
    858  1034							; both R0 and R1 to negative if set.
    859  1034							;
    860  1034				   RestoreSigns
    861  1034		       ad 22 1b 	      lda	sign
    862  1037		       f0 28		      beq	restoresigns2
    863  1039							;
    864  1039		       a5 83		      lda	R0
    865  103b		       d0 02		      bne	restoresigns3
    866  103d		       c6 84		      dec	R0+1
    867  103f				   restoresigns3
    868  103f		       c6 83		      dec	R0
    869  1041		       a5 83		      lda	R0
    870  1043		       49 ff		      eor	#$ff
    871  1045		       85 83		      sta	R0
    872  1047		       a5 84		      lda	R0+1
    873  1049		       49 ff		      eor	#$ff
    874  104b		       85 84		      sta	R0+1
    875  104d							;
    876  104d		       a5 85		      lda	R1
    877  104f		       d0 02		      bne	restoresigns4
    878  1051		       c6 86		      dec	R1+1
    879  1053				   restoresigns4
    880  1053		       c6 85		      dec	R1
    881  1055		       a5 85		      lda	R1
    882  1057		       49 ff		      eor	#$ff
    883  1059		       85 85		      sta	R1
    884  105b		       a5 86		      lda	R1+1
    885  105d		       49 ff		      eor	#$ff
    886  105f		       85 86		      sta	R1+1
    887  1061							;
    888  1061				   restoresigns2
    889  1061		       60		      rts
    890  1062							;
    891  1062							;=====================================================
    892  1062							; Skip over spaces.  Returns Y with the offset to
    893  1062							; either the last character in the line, or the first
    894  1062							; non-space character.
    895  1062							;
    896  1062		       c8	   skipsp2    iny
    897  1063		       b1 80	   SkipSpaces lda	(CURPTR),y
    898  1065		       f0 04		      beq	Skip3	;end of line
    899  1067		       c9 20		      cmp	#SPACE
    900  1069		       f0 f7		      beq	skipsp2
    901  106b		       60	   Skip3      rts
    902  106c							;
    903  106c							;=====================================================
    904  106c							; This is some debug logic which displays the current
    905  106c							; value of the ILPC and the line buffer.
    906  106c							;
    907  106c		       20 12 f0    dbgLine    jsr	puts
      0  106f					      db	"ILPC: ",0
      1  106f		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    909  1076		       a5 76		      lda	ILPC+1
    910  1078		       20 0f 02 	      jsr	OUTHEX
    911  107b		       a5 75		      lda	ILPC
    912  107d		       20 0f 02 	      jsr	OUTHEX
    913  1080		       a9 20		      lda	#SPACE
    914  1082		       20 06 02 	      jsr	OUTCH
    915  1085		       a0 00		      ldy	#0
    916  1087		       b1 75		      lda	(ILPC),y
    917  1089		       20 0f 02 	      jsr	OUTHEX
    918  108c							;
    919  108c							; Display the CURPTR value and offset
    920  108c							;
    921  108c		       20 12 f0 	      jsr	puts
      0  108f					      db	", CURPTR: ",0
      1  108f		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    923  109a		       a5 81		      lda	CURPTR+1
    924  109c		       20 0f 02 	      jsr	OUTHEX
    925  109f		       a5 80		      lda	CURPTR
    926  10a1		       20 0f 02 	      jsr	OUTHEX
    927  10a4		       a9 2b		      lda	#'+
    928  10a6		       20 06 02 	      jsr	OUTCH
    929  10a9		       a5 82		      lda	CUROFF
    930  10ab		       20 0f 02 	      jsr	OUTHEX
    931  10ae							;
    932  10ae		       4c 0c 02 	      jmp	CRLF
    933  10b1							;
    934  10b1							;=====================================================
    935  10b1							; This function might go away eventually, but was
    936  10b1							; added to provide data for other pieces of code.
    937  10b1							; It has some ties to the operating environment that
    938  10b1							; will need to be customized for the target system.
    939  10b1							;
    940  10b1				   GetSizes
    941  10b1							;
    942  10b1							; Here is machine specific code to get the highest
    943  10b1							; memory location that can be used by BASIC.
    944  10b1							;
    945  10b1					      if	ProgramStart < $2000
    946  10b1		       a9 ff		      lda	#$ff
    947  10b3		       8d 2c 1b 	      sta	HighMem	;$13ff for KIM-1
    948  10b6		       a9 de		      lda	#$DE	;#$13
    949  10b8		       8d 2d 1b 	      sta	HighMem+1
    950  10bb				  -	      else
    951  10bb				  -	      lda	#$ff
    952  10bb				  -	      sta	HighMem	;$CFFF otherwise
    953  10bb				  -	      lda	#$cf
    954  10bb				  -	      sta	HighMem+1
    955  10bb					      endif
    956  10bb							;
    957  10bb							; This computes the available memory remaining.
    958  10bb							;
    959  10bb		       38		      sec
    960  10bc		       ad 2c 1b 	      lda	HighMem
    961  10bf		       ed 2a 1b 	      sbc	PROGRAMEND
    962  10c2		       8d 30 1b 	      sta	FreeMem
    963  10c5		       85 83		      sta	R0
    964  10c7		       ad 2d 1b 	      lda	HighMem+1
    965  10ca		       ed 2b 1b 	      sbc	PROGRAMEND+1
    966  10cd		       8d 31 1b 	      sta	FreeMem+1
    967  10d0		       85 84		      sta	R0+1
    968  10d2							;
    969  10d2							; This computes the size of the current user program.
    970  10d2							;
    971  10d2		       38		      sec
    972  10d3		       ad 2a 1b 	      lda	PROGRAMEND
    973  10d6		       e9 32		      sbc	#ProgramStart&$ff
    974  10d8		       8d 2e 1b 	      sta	UsedMem
    975  10db		       ad 2b 1b 	      lda	PROGRAMEND+1
    976  10de		       e9 1b		      sbc	#ProgramStart>>8
    977  10e0		       8d 2f 1b 	      sta	UsedMem+1
    978  10e3							;
    979  10e3		       60		      rts
    980  10e4							;
    981  10e4							;=====================================================
    982  10e4							; Set output vector to the console output function
    983  10e4							;
    984  10e4				   SetOutConsole
    985  10e4		       a9 06		      lda	#OUTCH&$ff
    986  10e6		       8d 27 1b 	      sta	BOutVec
    987  10e9		       a9 02		      lda	#OUTCH/256
    988  10eb		       8d 28 1b 	      sta	BOutVec+1
    989  10ee		       60		      rts
    990  10ef							;
    991  10ef							;=====================================================
    992  10ef							; Jump to the output function in BOutVec
    993  10ef							;
    994  10ef		       6c 27 1b    VOUTCH     jmp	(BOutVec)
    995  10f2
    996  10f2							;====================================================
    997  10f2		       1b 23	   PrtTerm    equ	rtemp1
    998  10f2
    999  10f2							; Print Y has the offset to use
   1000  10f2		       a5 80	   PrtQuoted  lda	CURPTR
   1001  10f4		       85 93		      sta	PrtFrom
   1002  10f6		       a5 81		      lda	CURPTR+1
   1003  10f8		       85 94		      sta	PrtFrom+1
   1004  10fa		       a9 22		      lda	#'"
   1005  10fc		       8d 23 1b 	      sta	PrtTerm
   1006  10ff		       4c 0b 11 	      jmp	PrtLoop
   1007  1102
   1008  1102							; Print a string pointed to by x= h, y=l terminated by a
   1009  1102							; Return y as the length
   1010  1102
   1011  1102		       86 94	   PrtStr     stx	PrtFrom+1
   1012  1104		       84 93		      sty	PrtFrom
   1013  1106		       8d 23 1b 	      sta	PrtTerm
   1014  1109		       a0 00		      ldy	#0
   1015  110b
   1016  110b		       b1 93	   PrtLoop    lda	(PrtFrom),y
   1017  110d		       cd 23 1b 	      cmp	PrtTerm
   1018  1110		       f0 0b		      beq	PrtEnd
   1019  1112		       c9 00		      cmp	#0	; always end if 0 is found
   1020  1114		       f0 07		      beq	PrtEnd
   1021  1116		       20 06 02 	      jsr	OUTCH
   1022  1119		       c8		      iny
   1023  111a		       4c 0b 11 	      jmp	PrtLoop
   1024  111d		       c8	   PrtEnd     iny		;return byte after the copy
   1025  111e		       60		      rts
   1026  111f
   1027  111f							;====================================================
   1028  111f							;Clear the terminal assume it is ansii or vt100
   1029  111f							;
   1030  111f				   iCLEARSCREEN
   1031  111f		       20 12 f0 	      jsr	puts
      0  1122					      db	$1b,'[,'3,'J,0
      1  1122		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
   1033  1127		       4c e4 02 	      jmp	NextIL
------- FILE mytb.asm
   2223  112a					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  112a					      include	"storage.asm"
      1  112a							;
      2  112a							;=====================================================
      3  112a							;=====================================================
      4  112a							;=====================================================
      5  112a							; This file contains the functions for saving and
      6  112a							; restoring programs from some sort of mass storage
      7  112a							; device.  This particular version is for using the
      8  112a							; Corsham Tech SD Card System.
      9  112a							;=====================================================
     10  112a							;=====================================================
     11  112a							;=====================================================
     12  112a
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  112a					      SEG	Code
     19  112a
     20  112a							;
     21  112a							;=====================================================
     22  112a							; Open a file for reading as a program.  The next
     23  112a							; thing on the line should be the filename.
     24  112a							;
     25  112a				   iOPENREAD
     26  112a					      if	XKIM || CTMON65
     27  112a		       a4 82		      ldy	CUROFF
     28  112c		       b1 80		      lda	(CURPTR),y
     29  112e		       d0 07		      bne	iOPENfn	;might be filename
     30  1130							;
     31  1130							; No filename supplied.
     32  1130							;
     33  1130		       a9 00	   iOPENnofn  lda	#0
     34  1132		       a2 09		      ldx	#ERR_NO_FILENAME
     35  1134		       4c 26 06 	      jmp	iErr2
     36  1137							;
     37  1137							; Add the offset into the buffer start
     38  1137							;
     39  1137		       18	   iOPENfn    clc
     40  1138		       98		      tya
     41  1139		       65 80		      adc	CURPTR
     42  113b		       a8		      tay		;LSB
     43  113c		       a5 81		      lda	CURPTR+1
     44  113e		       69 00		      adc	#0
     45  1140		       aa		      tax
     46  1141		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  1144		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1146							;
     49  1146							; Open failed
     50  1146							;
     51  1146		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1148		       a9 00	   Rdfail2    lda	#0
     53  114a		       4c 26 06 	      jmp	iErr2
     54  114d							;
     55  114d							; Clear counts and offsets so the next read will
     56  114d							; cause the file to be read.
     57  114d							;
     58  114d		       a9 00	   Ropenok    lda	#0
     59  114f		       8d 8f df 	      sta	diskBufOffset
     60  1152		       8d 8e df 	      sta	diskBufLength
     61  1155		       4c e4 02 	      jmp	NextIL
     62  1158					      endif
     63  1158
     64  1158							;
     65  1158							;==============================jlit 08/02/2022========
     66  1158							;Remove a file from the disk
     67  1158				   iRMFILE
     68  1158					      if	XKIM || CTMON65
     69  1158		       a4 82		      ldy	CUROFF
     70  115a		       b1 80		      lda	(CURPTR),y
     71  115c		       f0 19		      beq	iRMnofn
     72  115e							;
     73  115e		       18		      clc
     74  115f		       98		      tya
     75  1160		       65 80		      adc	CURPTR
     76  1162		       a8		      tay		;LSB
     77  1163		       a5 81		      lda	CURPTR+1
     78  1165		       69 00		      adc	#0
     79  1167		       aa		      tax
     80  1168		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  116b		       90 07		      bcc	wrmOk	;branch if removed ok
     82  116d		       a9 00		      lda	#0
     83  116f		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1171		       4c 26 06 	      jmp	iErr2
     85  1174		       4c e4 02    wrmOk      jmp	NextIL
     86  1177
     87  1177							; No filename supplied.
     88  1177							;
     89  1177		       a9 00	   iRMnofn    lda	#0
     90  1179		       a2 09		      ldx	#ERR_NO_FILENAME
     91  117b		       4c 26 06 	      jmp	iErr2
     92  117e					      endif
     93  117e							;
     94  117e							;=====================================================
     95  117e				   iOPENWRITE
     96  117e					      if	XKIM || CTMON65
     97  117e		       a4 82		      ldy	CUROFF
     98  1180		       b1 80		      lda	(CURPTR),y
     99  1182		       f0 f3		      beq	iRMnofn
    100  1184							;
    101  1184		       18		      clc
    102  1185		       98		      tya
    103  1186		       65 80		      adc	CURPTR
    104  1188		       a8		      tay		;LSB
    105  1189		       a5 81		      lda	CURPTR+1
    106  118b		       69 00		      adc	#0
    107  118d		       aa		      tax
    108  118e		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1191		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1193							;
    111  1193							; Open failed
    112  1193							;
    113  1193		       a9 00	   Wdfail     lda	#0
    114  1195		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1197		       4c 26 06 	      jmp	iErr2
    116  119a							;
    117  119a		       4c e4 02    Wopenok    jmp	NextIL
    118  119d					      endif
    119  119d							;
    120  119d							;=====================================================
    121  119d							; Gets a line of input from the disk file and puts it
    122  119d							; into LINBUF.
    123  119d							;
    124  119d							; On exit:
    125  119d							;    CURPTR points to LINBUF
    126  119d							;    LINBUF contains the line with 0 at the end.
    127  119d							;    Y has offset to first non-space character
    128  119d							;    CURROFF has the same as Y.
    129  119d							;
    130  119d				   iDGETLINE
    131  119d					      if	XKIM || CTMON65
    132  119d		       a2 96		      ldx	#LINBUF&$ff
    133  119f		       86 80		      stx	CURPTR
    134  11a1		       a2 1a		      ldx	#LINBUF>>8
    135  11a3		       86 81		      stx	CURPTR+1
    136  11a5							;
    137  11a5		       a2 00		      ldx	#0	;offset
    138  11a7		       8e 1a 1b    iDgetLoop  stx	getlinx
    139  11aa		       20 08 12 	      jsr	getNextFileByte
    140  11ad		       b0 16		      bcs	iGetEOF
    141  11af		       c9 0d		      cmp	#CR
    142  11b1		       f0 0d		      beq	iGetEOL
    143  11b3		       c9 0a		      cmp	#LF
    144  11b5		       f0 09		      beq	iGetEOL
    145  11b7		       ae 1a 1b 	      ldx	getlinx
    146  11ba		       9d 96 1a 	      sta	LINBUF,x
    147  11bd		       e8		      inx
    148  11be		       d0 e7		      bne	iDgetLoop
    149  11c0							;
    150  11c0							; Handle end of line.	If the line has nothing, loop
    151  11c0							; back and get another line.
    152  11c0							;
    153  11c0		       ae 1a 1b    iGetEOL    ldx	getlinx	;blank line?
    154  11c3		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  11c5							;
    156  11c5							; This can fall through when there is a line, or
    157  11c5							; called directly when EOF is encountered.
    158  11c5							;
    159  11c5		       ae 1a 1b    iGetEOF    ldx	getlinx
    160  11c8		       a9 00		      lda	#0
    161  11ca		       9d 96 1a 	      sta	LINBUF,x
    162  11cd		       85 82		      sta	CUROFF
    163  11cf		       a0 00		      ldy	#0
    164  11d1		       20 63 10 	      jsr	SkipSpaces
    165  11d4		       4c e4 02 	      jmp	NextIL
    166  11d7					      endif
    167  11d7
    168  11d7							;
    169  11d7							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  11d7							; DISK
    171  11d7							;
    172  11d7				   iDDIR
    173  11d7					      if	XKIM || CTMON65
    174  11d7		       20 30 f0 	      jsr	DiskDir
    175  11da							;
    176  11da							; Get/Display each entry
    177  11da							;
    178  11da		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  11dc		       a0 90		      ldy	#DiskFileName&$ff
    180  11de		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  11e1		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  11e3		       20 12 f0 	      jsr	puts
      0  11e6					      db	"   ",0
      1  11e6		       20 20 20 00	      .byte.b	"   ",0
    184  11ea							; Print the line to the console
    185  11ea		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  11ec		       a0 90		      ldy	#DiskFileName&$ff
    187  11ee		       a5 00		      lda	0
    188  11f0		       20 02 11 	      jsr	PrtStr	;else print name
    189  11f3		       20 18 f0 	      jsr	crlf
    190  11f6
    191  11f6		       4c da 11 	      jmp	DiskDirLoop	;do next entry
    192  11f9		       4c e4 02    DiskDirEnd jmp	NextIL
    193  11fc					      endif
    194  11fc							;
    195  11fc							;=====================================================
    196  11fc							; Does a LIST to a Disk file.
    197  11fc							;
    198  11fc				   iDLIST
    199  11fc					      if	XKIM || CTMON65
    200  11fc		       20 37 12 	      jsr	SetOutDisk
    201  11ff		       4c b6 07 	      jmp	iLST2
    202  1202					      endif
    203  1202							;
    204  1202							;=====================================================
    205  1202							; Closes any pending disk file.  Okay to call if there
    206  1202							; is no open file.
    207  1202							;
    208  1202				   iDCLOSE
    209  1202					      if	XKIM || CTMON65
    210  1202		       20 42 f0 	      jsr	DiskClose
    211  1205		       4c e4 02 	      jmp	NextIL
    212  1208					      endif
    213  1208							;
    214  1208							;=====================================================
    215  1208							; This gets the next byte from an open disk file.  If
    216  1208							; there are no more bytes left, this returns C set.
    217  1208							; Else, C is clear and A contains the character.
    218  1208							;
    219  1208				   getNextFileByte
    220  1208					      if	XKIM || CTMON65
    221  1208		       ae 8f df 	      ldx	diskBufOffset
    222  120b		       ec 8e df 	      cpx	diskBufLength
    223  120e		       d0 14		      bne	hasdata	;branch if still data
    224  1210							;
    225  1210							; There is no data left in the buffer, so read a
    226  1210							; block from the SD system.
    227  1210							;
    228  1210		       a9 84		      lda	#BUFFER_SIZE
    229  1212		       a2 df		      ldx	#buffer>>8
    230  1214		       a0 0a		      ldy	#buffer&$ff
    231  1216		       20 3c f0 	      jsr	DiskRead
    232  1219		       b0 12		      bcs	getNextEof
    233  121b							;
    234  121b							; A contains the number of bytes actually read.
    235  121b							;
    236  121b		       8d 8e df 	      sta	diskBufLength	;save length
    237  121e		       c9 00		      cmp	#0	;shouldn't happen
    238  1220		       f0 0b		      beq	getNextEof
    239  1222							;
    240  1222		       a2 00		      ldx	#0
    241  1224		       bd 0a df    hasdata    lda	buffer,x
    242  1227		       e8		      inx
    243  1228		       8e 8f df 	      stx	diskBufOffset
    244  122b		       18		      clc
    245  122c		       60		      rts
    246  122d							;
    247  122d		       a9 00	   getNextEof lda	#0
    248  122f		       8d 8f df 	      sta	diskBufOffset
    249  1232		       8d 8e df 	      sta	diskBufLength
    250  1235		       38		      sec
    251  1236		       60		      rts
    252  1237							;
    253  1237							;=====================================================
    254  1237							; Set output vector to the disk output function
    255  1237							;
    256  1237		       a9 42	   SetOutDisk lda	#DOUT&$ff
    257  1239		       8d 27 1b 	      sta	BOutVec
    258  123c		       a9 12		      lda	#DOUT/256
    259  123e		       8d 28 1b 	      sta	BOutVec+1
    260  1241		       60		      rts
    261  1242							;
    262  1242							;=====================================================
    263  1242
    264  1242		       8d 0a df    DOUT       sta	buffer
    265  1245		       a9 01		      lda	#1
    266  1247		       a0 0a		      ldy	#buffer&$ff
    267  1249		       a2 df		      ldx	#buffer/256
    268  124b		       20 3f f0 	      jsr	DiskWrite
    269  124e							;
    270  124e							; need error checking here
    271  124e							;
    272  124e		       60		      rts
    273  124f					      endif
    274  124f
    275  124f
------- FILE mytb.asm
   2225  124f					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  124f					      include	"IL.inc"
      1  124f
      2  124f							;=====================================================
      3  124f							; IL.inc
      4  124f							; These are macros for IL instructions
      5  124f							;
      6  124f					      mac	dw
      7  124f					      .word	{0}
      8  124f					      endm
      9  124f					      mac	db
     10  124f					      .byte	{0}
     11  124f					      endm
     12  124f					      macro	xinit
     13  124f					      db	0
     14  124f					      endm		;reset the il to start clear all
     15  124f							;
     16  124f					      macro	done
     17  124f					      db	1
     18  124f					      endm		;print an error if not end of line
     19  124f							;
     20  124f					      macro	prs
     21  124f					      db	2
     22  124f					      endm		;print a quoted string
     23  124f							;
     24  124f					      macro	prn
     25  124f					      db	3
     26  124f					      endm		;print a number
     27  124f							;
     28  124f					      macro	spc
     29  124f					      db	4
     30  124f					      endm		;print space til new tabstop
     31  124f							;
     32  124f					      macro	nline
     33  124f					      db	5
     34  124f					      endm		;print a new line crlf
     35  124f							;
     36  124f							; My NXT is a bit different in that it takes one
     37  124f							; parameter, which is an address.  If the BASIC
     38  124f							; program is currently running then move to the
     39  124f							; next line and continue execution.  However, if
     40  124f							; in direct mode, jump to the specified IL label.
     41  124f							;
     42  124f					      macro	nxt
     43  124f					      db	6
     44  124f					      dw	{1}	; addr
     45  124f					      endm		; addr
     46  124f							;
     47  124f					      macro	xfer
     48  124f					      db	7
     49  124f					      endm
     50  124f							;
     51  124f					      macro	sav
     52  124f					      db	8
     53  124f					      endm
     54  124f							;
     55  124f					      macro	rstr
     56  124f					      db	9
     57  124f					      endm
     58  124f							;
     59  124f					      macro	cmpr
     60  124f					      db	10
     61  124f					      endm
     62  124f							;
     63  124f					      macro	innum
     64  124f					      db	11
     65  124f					      endm
     66  124f							;
     67  124f					      macro	fin
     68  124f					      db	12
     69  124f					      endm
     70  124f							;
     71  124f							; ERR is followed by an error number.	The error
     72  124f							; code is printed along with the line number.
     73  124f							; Control is passed to the statement set with
     74  124f							; the ERRGOTO statement.
     75  124f							;
     76  124f					      macro	errmsg
     77  124f					      db	13
     78  124f					      dw	{1}	;ecode
     79  124f					      endm		;ecode
     80  124f							;
     81  124f					      macro	add
     82  124f					      db	14
     83  124f					      endm
     84  124f							;
     85  124f					      macro	sub
     86  124f					      db	15
     87  124f					      endm
     88  124f							;
     89  124f					      macro	neg
     90  124f					      db	16
     91  124f					      endm
     92  124f							;
     93  124f					      macro	mul
     94  124f					      db	17
     95  124f					      endm
     96  124f							;
     97  124f					      macro	div
     98  124f					      db	18
     99  124f					      endm
    100  124f							;
    101  124f					      macro	store
    102  124f					      db	19
    103  124f					      endm
    104  124f							;
    105  124f					      macro	ind
    106  124f					      db	20
    107  124f					      endm
    108  124f							;
    109  124f					      macro	lst
    110  124f					      db	21
    111  124f					      endm
    112  124f							;
    113  124f					      macro	init
    114  124f					      db	22
    115  124f					      endm
    116  124f							;
    117  124f					      macro	getline
    118  124f					      db	23
    119  124f					      endm
    120  124f							;
    121  124f					      macro	insert
    122  124f					      db	24
    123  124f					      endm
    124  124f							;
    125  124f					      macro	rtn
    126  124f					      db	25
    127  124f					      endm
    128  124f							;
    129  124f					      macro	exit
    130  124f					      db	26
    131  124f					      endm
    132  124f							;
    133  124f					      macro	lit
    134  124f					      db	27
    135  124f					      dw	{1}	;value
    136  124f					      endm		; value LIT
    137  124f							;
    138  124f					      macro	call
    139  124f					      db	28
    140  124f					      dw	{1}	;addr
    141  124f					      endm		;addr
    142  124f							;
    143  124f							; IJMP will set the IL PC to the specified value.
    144  124f							;
    145  124f					      macro	ijmp
    146  124f					      db	29
    147  124f					      dw	{1}	;addr
    148  124f					      endm		;addr
    149  124f							;
    150  124f					      macro	vinit
    151  124f					      db	30
    152  124f					      endm
    153  124f							;
    154  124f							; ERRGOTO sets the point in the code where the IL
    155  124f							; interpreter will go after any error.
    156  124f							;
    157  124f					      macro	errgoto
    158  124f					      db	31
    159  124f					      dw	{1}	;addr
    160  124f					      endm		;addr
    161  124f							;
    162  124f					      macro	tst
    163  124f					      db	32
    164  124f					      db	({1}-*)-1	;(addr-*)-1
    165  124f					      db	{2},0	;string,0
    166  124f					      endm		;addr,string
    167  124f							;
    168  124f					      macro	tstv
    169  124f					      db	33
    170  124f					      db	({1}-*)-1	;(addr-*)-1
    171  124f					      endm		;addr
    172  124f							;
    173  124f					      macro	tstl
    174  124f					      db	34
    175  124f					      db	({1}-*)-1	;(addr-*)-1
    176  124f					      endm		;addr
    177  124f							;
    178  124f					      macro	tstn
    179  124f					      db	35
    180  124f					      db	({1}-*)-1	;(addr-*)-1
    181  124f					      endm		;addr
    182  124f							;
    183  124f							; FREE returns the amount of free RAM on top of
    184  124f							; the stack.  This is the amount of room the user
    185  124f							; program has available.
    186  124f							;
    187  124f					      macro	free
    188  124f					      db	36
    189  124f					      endm
    190  124f							;
    191  124f							; RANDOM takes the top item off the stack and
    192  124f							; replaces it with a random number that is
    193  124f							; MOD the initial value.  Ie, if the TOS is
    194  124f							; 42 then RANDOM returns a value from 0 to 41.
    195  124f							;
    196  124f					      macro	random
    197  124f					      db	37
    198  124f					      endm
    199  124f							;
    200  124f							; ABS will replace the top of stack with the
    201  124f							; absolute value.
    202  124f							;
    203  124f					      macro	abs
    204  124f					      db	38
    205  124f					      endm
    206  124f							;
    207  124f							; OPENREAD opens a file for reading, as in getting
    208  124f							; statements from it.
    209  124f							;
    210  124f					      macro	openread
    211  124f					      db	39
    212  124f					      endm
    213  124f							;
    214  124f							; OPENWRITE opens a file for writing, as in saving
    215  124f							; the current program to it.
    216  124f							;
    217  124f					      macro	openwrite
    218  124f					      db	40
    219  124f					      endm
    220  124f							;
    221  124f							; DCLOSE closes any open disk file.
    222  124f							;
    223  124f					      macro	dclose
    224  124f					      db	41
    225  124f					      endm
    226  124f							;
    227  124f							; DGETLINE gets one line from the disk file and puts it
    228  124f							; into LINBUFF.
    229  124f							;
    230  124f					      macro	dgetline
    231  124f					      db	42
    232  124f					      endm
    233  124f							;
    234  124f							; DLIST saves the program to an open disk file.
    235  124f							;
    236  124f					      macro	dlist
    237  124f					      db	43
    238  124f					      endm
    239  124f							; DDIR list the current directory
    240  124f							;
    241  124f					      macro	ddir
    242  124f					      db	44
    243  124f					      endm
    244  124f
    245  124f							; RMFILE remove a fle from disk
    246  124f					      macro	rmfile
    247  124f					      db	45
    248  124f					      endm
    249  124f
    250  124f							; CLEARSCREEN clear the screen
    251  124f					      macro	clearscreen
    252  124f					      db	46
    253  124f					      endm
    254  124f							; POKEMEM Poke value into memory
    255  124f					      macro	pokemem
    256  124f					      db	47
    257  124f					      endm
    258  124f							; PEEKMEM peek at value in memory
    259  124f					      macro	peekmem
    260  124f					      db	48
    261  124f					      endm
    262  124f							; TSTLET Test if the statement is a let without the keyword let
    263  124f					      macro	tstlet
    264  124f					      db	49
    265  124f					      db	({1}-*)-1	;(addr-*)-1
    266  124f					      endm		;addr
    267  124f							; TSTDONE if we reach the end of a statement
    268  124f					      macro	tstdone
    269  124f					      db	50
    270  124f					      db	({1}-*)-1	;(addr-*)-1
    271  124f					      endm		;addr
    272  124f							; GETCHAR	get a character from the input line leave it in RO
    273  124f					      macro	getchar
    274  124f					      db	51
    275  124f					      endm
    276  124f							; PUTCHAR	Put a character to the terminal
    277  124f					      macro	putchar
    278  124f					      db	52
    279  124f					      endm
    280  124f							; Call		Call a machine function return a to stack
    281  124f					      macro	callfunc
    282  124f					      db	53
    283  124f					      endm
    284  124f
    285  124f							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    286  124f					      macro	ibranch
    287  124f					      db	54
    288  124f					      endm
    289  124f
    290  124f							; TSTSTR	 Tests for the open quote in a string
    291  124f					      macro	tststr
    292  124f					      db	55
    293  124f					      db	({1}-*)-1	;(addr-*)-1
    294  124f					      endm
    295  124f							; SETIRQ	Sets the line number to run when an irq happens irq 550
    296  124f					      macro	setirq
    297  124f					      db	56
    298  124f					      endm
    299  124f
    300  124f							; TSTIRQ	Test for irq pending,
    301  124f							;		if so push the IRQ LINE NUMBER into RO, onto stack
    302  124f					      macro	tstirq
    303  124f					      db	57
    304  124f					      db	({1}-*)-1	;(addr-*)-1
    305  124f					      endm
    306  124f
    307  124f							; IRET    return from interupt service
    308  124f					      macro	iret
    309  124f					      db	58
    310  124f					      endm
    311  124f
    312  124f							; INSTR   read a string from the input
    313  124f					      macro	instr
    314  124f					      db	59
    315  124f					      endm
    316  124f
    317  124f							; MODULO Returns the remainder of the division
    318  124f					      macro	modulo
    319  124f					      db	60
    320  124f					      endm
    321  124f							; Set a task line
    322  124f					      macro	settask
    323  124f					      db	61
    324  124f					      endm
    325  124f							; End a task
    326  124f					      macro	etask
    327  124f					      db	62
    328  124f					      endm
    329  124f							; Skip to next task
    330  124f					      macro	ntask
    331  124f					      db	63
    332  124f					      endm
    333  124f							; Subscript
    334  124f					      macro	subscript
    335  124f					      db	64
    336  124f					      endm
    337  124f							; KILL Task
    338  124f					      macro	taskkill
    339  124f					      db	65
    340  124f					      endm
    341  124f							; STAT Task
    342  124f					      macro	taskstat
    343  124f					      db	66
    344  124f					      endm
    345  124f							;  output value as hex
    346  124f					      macro	hexprt
    347  124f					      db	67
    348  124f					      endm
    349  124f							;  Read in background has completed
    350  124f					      macro	readcomplete
    351  124f					      db	68
    352  124f					      endm
    353  124f							;  ReadInput line
    354  124f					      macro	readstart
    355  124f					      db	69
    356  124f					      endm
    357  124f							; Startio request
    358  124f					      macro	startio
    359  124f					      db	70
    360  124f					      endm
    361  124f							; Endio
    362  124f					      macro	endio
    363  124f					      db	71
    364  124f					      endm
------- FILE mytb.asm
   2227  124f							;
   2228  124f				  -	      if	FIXED
   2229  124f				  -	      org	$1000
   2230  124f					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  124f					      include	"basic.il"
      1  124f							;LET
      2  124f							;=====================================================
      3  124f							;=====================================================
      4  124f							;=====================================================
      5  124f							; This is the IL of the BASIC (or whatever) language.
      6  124f							; Because of the way macros are implemented by as65,
      7  124f							; labels can't be on the same line as a macro
      8  124f							; invocation, so that's why labels are on separate
      9  124f							; lines.
     10  124f							;
     11  124f		       12 4f	   IL	      equ	*
     12  124f
     13  124f							;THE IL CONTROL SECTION
     14  124f
     15  124f				   START
      0  124f					      INIT		;INITIALIZE
      0  124f					      db	22
      1  124f		       16		      .byte.b	22
      0  1250					      NLINE		;WRITE CRLF
      0  1250					      db	5
      1  1250		       05		      .byte.b	5
      0  1251					      ERRGOTO	CO	;where to go after an error
      0  1251					      db	31
      1  1251		       1f		      .byte.b	31
      0  1252					      dw	CO
      1  1252		       55 12		      .word.w	CO
      0  1254					      VINIT		;clear all variables
      0  1254					      db	30
      1  1254		       1e		      .byte.b	30
     20  1255							;
     21  1255							; This is where we jump to get a line of commands or
     22  1255							; a program from the user.
     23  1255							;
     24  1255				   CO
      0  1255					      GETLINE		;WRITE PROMPT AND GET LINE
      0  1255					      db	23
      1  1255		       17		      .byte.b	23
      0  1256					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1256					      db	34
      1  1256		       22		      .byte.b	34
      0  1257					      db	(XEC-*)-1
      1  1257		       04		      .byte.b	(XEC-*)-1
      0  1258					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1258					      db	24
      1  1258		       18		      .byte.b	24
      0  1259					      IJMP	CO
      0  1259					      db	29
      1  1259		       1d		      .byte.b	29
      0  125a					      dw	CO
      1  125a		       55 12		      .word.w	CO
     29  125c				   XEC
      0  125c					      XINIT		;INITIALIZE
      0  125c					      db	0
      1  125c		       00		      .byte.b	0
     31  125d
     32  125d							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     33  125d				   STMT
      0  125d					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  125d					      db	57
      1  125d		       39		      .byte.b	57
      0  125e					      db	(notirq-*)-1
      1  125e		       00		      .byte.b	(notirq-*)-1
     35  125f				   notirq
      0  125f					      TSTLET	LET	;Test if second field is =
      0  125f					      db	49
      1  125f		       31		      .byte.b	49
      0  1260					      db	(LET-*)-1
      1  1260		       03		      .byte.b	(LET-*)-1
      0  1261					      IJMP	DOLET	;allow the default to be let
      0  1261					      db	29
      1  1261		       1d		      .byte.b	29
      0  1262					      dw	DOLET
      1  1262		       6a 12		      .word.w	DOLET
     38  1264				   LET
      0  1264					      TST	S1,"LET"	;IS STATEMENT A LET
      0  1264					      db	32
      1  1264		       20		      .byte.b	32
      0  1265					      db	(S1-*)-1
      1  1265		       21		      .byte.b	(S1-*)-1
      0  1266					      db	"LET",0
      1  1266		       4c 45 54 00	      .byte.b	"LET",0
     40  126a				   DOLET
      0  126a					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  126a					      db	33
      1  126a		       21		      .byte.b	33
      0  126b					      db	(ERRVEC-*)-1
      1  126b		       b2		      .byte.b	(ERRVEC-*)-1
      0  126c					      TST	LETBE,"["
      0  126c					      db	32
      1  126c		       20		      .byte.b	32
      0  126d					      db	(LETBE-*)-1
      1  126d		       0a		      .byte.b	(LETBE-*)-1
      0  126e					      db	"[",0
      1  126e		       5b 00		      .byte.b	"[",0
      0  1270					      CALL	EXPR
      0  1270					      db	28
      1  1270		       1c		      .byte.b	28
      0  1271					      dw	EXPR
      1  1271		       4e 14		      .word.w	EXPR
      0  1273					      TST	ERRVEC,"]"
      0  1273					      db	32
      1  1273		       20		      .byte.b	32
      0  1274					      db	(ERRVEC-*)-1
      1  1274		       a9		      .byte.b	(ERRVEC-*)-1
      0  1275					      db	"]",0
      1  1275		       5d 00		      .byte.b	"]",0
      0  1277					      SUBSCRIPT
      0  1277					      db	64
      1  1277		       40		      .byte.b	64
     46  1278				   LETBE
      0  1278					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1278					      db	32
      1  1278		       20		      .byte.b	32
      0  1279					      db	(ERRVEC-*)-1
      1  1279		       a4		      .byte.b	(ERRVEC-*)-1
      0  127a					      db	"=",0
      1  127a		       3d 00		      .byte.b	"=",0
      0  127c					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  127c					      db	28
      1  127c		       1c		      .byte.b	28
      0  127d					      dw	EXPR
      1  127d		       4e 14		      .word.w	EXPR
      0  127f					      DONE		;REPORT ERROR IF NOT NEXT
      0  127f					      db	1
      1  127f		       01		      .byte.b	1
      0  1280					      STORE		;STORE RESULT
      0  1280					      db	19
      1  1280		       13		      .byte.b	19
      0  1281					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1281					      db	6
      1  1281		       06		      .byte.b	6
      0  1282					      dw	CO
      1  1282		       55 12		      .word.w	CO
      0  1284					      IJMP	STMT
      0  1284					      db	29
      1  1284		       1d		      .byte.b	29
      0  1285					      dw	STMT
      1  1285		       5d 12		      .word.w	STMT
     53  1287				   S1
      0  1287					      TST	S1S1,"IRET"	;test return from interupt
      0  1287					      db	32
      1  1287		       20		      .byte.b	32
      0  1288					      db	(S1S1-*)-1
      1  1288		       10		      .byte.b	(S1S1-*)-1
      0  1289					      db	"IRET",0
      1  1289		       49 52 45 54*	      .byte.b	"IRET",0
      0  128e					      TST	S1Sa,"URN"
      0  128e					      db	32
      1  128e		       20		      .byte.b	32
      0  128f					      db	(S1Sa-*)-1
      1  128f		       04		      .byte.b	(S1Sa-*)-1
      0  1290					      db	"URN",0
      1  1290		       55 52 4e 00	      .byte.b	"URN",0
     56  1294				   S1Sa
      0  1294					      DONE		;Must be only thing on the line
      0  1294					      db	1
      1  1294		       01		      .byte.b	1
      0  1295					      IRET		;RESTORE LINE NUMBER OF CALL
      0  1295					      db	58
      1  1295		       3a		      .byte.b	58
      0  1296					      IJMP	STMT
      0  1296					      db	29
      1  1296		       1d		      .byte.b	29
      0  1297					      dw	STMT
      1  1297		       5d 12		      .word.w	STMT
     60  1299
     61  1299				   S1S1
      0  1299					      TST	S1Z,"IF"	;IF STATEMENT
      0  1299					      db	32
      1  1299		       20		      .byte.b	32
      0  129a					      db	(S1Z-*)-1
      1  129a		       11		      .byte.b	(S1Z-*)-1
      0  129b					      db	"IF",0
      1  129b		       49 46 00 	      .byte.b	"IF",0
      0  129e					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  129e					      db	28
      1  129e		       1c		      .byte.b	28
      0  129f					      dw	EXPR
      1  129f		       4e 14		      .word.w	EXPR
      0  12a1					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  12a1					      db	32
      1  12a1		       20		      .byte.b	32
      0  12a2					      db	(S1W-*)-1
      1  12a2		       05		      .byte.b	(S1W-*)-1
      0  12a3					      db	"THEN",0
      1  12a3		       54 48 45 4e*	      .byte.b	"THEN",0
     65  12a8				   S1W
      0  12a8					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  12a8					      db	54
      1  12a8		       36		      .byte.b	54
      0  12a9					      IJMP	STMT
      0  12a9					      db	29
      1  12a9		       1d		      .byte.b	29
      0  12aa					      dw	STMT
      1  12aa		       5d 12		      .word.w	STMT
     68  12ac
     69  12ac				   S1Z
      0  12ac					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  12ac					      db	32
      1  12ac		       20		      .byte.b	32
      0  12ad					      db	(S2b-*)-1
      1  12ad		       18		      .byte.b	(S2b-*)-1
      0  12ae					      db	"GO",0
      1  12ae		       47 4f 00 	      .byte.b	"GO",0
      0  12b1					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  12b1					      db	32
      1  12b1		       20		      .byte.b	32
      0  12b2					      db	(S2-*)-1
      1  12b2		       07		      .byte.b	(S2-*)-1
      0  12b3					      db	"TO",0
      1  12b3		       54 4f 00 	      .byte.b	"TO",0
      0  12b6					      CALL	EXPR	;GET LABEL
      0  12b6					      db	28
      1  12b6		       1c		      .byte.b	28
      0  12b7					      dw	EXPR
      1  12b7		       4e 14		      .word.w	EXPR
      0  12b9					      XFER		;SET UP AND JUMP
      0  12b9					      db	7
      1  12b9		       07		      .byte.b	7
     74  12ba				   S2
      0  12ba					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  12ba					      db	32
      1  12ba		       20		      .byte.b	32
      0  12bb					      db	(ERRVEC-*)-1
      1  12bb		       62		      .byte.b	(ERRVEC-*)-1
      0  12bc					      db	"SUB",0
      1  12bc		       53 55 42 00	      .byte.b	"SUB",0
      0  12c0					      CALL	EXPR	;GET DESTINATION
      0  12c0					      db	28
      1  12c0		       1c		      .byte.b	28
      0  12c1					      dw	EXPR
      1  12c1		       4e 14		      .word.w	EXPR
      0  12c3					      DONE		;ERROR IF CR NOT NEXT
      0  12c3					      db	1
      1  12c3		       01		      .byte.b	1
      0  12c4					      SAV		;SAVE RETURN LINE
      0  12c4					      db	8
      1  12c4		       08		      .byte.b	8
      0  12c5					      XFER		;AND JUMP
      0  12c5					      db	7
      1  12c5		       07		      .byte.b	7
     80  12c6				   S2b
      0  12c6					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  12c6					      db	32
      1  12c6		       20		      .byte.b	32
      0  12c7					      db	(S3-*)-1
      1  12c7		       1f		      .byte.b	(S3-*)-1
      0  12c8					      db	"RE",0
      1  12c8		       52 45 00 	      .byte.b	"RE",0
      0  12cb					      TST	S2a,"T"
      0  12cb					      db	32
      1  12cb		       20		      .byte.b	32
      0  12cc					      db	(S2a-*)-1
      1  12cc		       10		      .byte.b	(S2a-*)-1
      0  12cd					      db	"T",0
      1  12cd		       54 00		      .byte.b	"T",0
      0  12cf					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  12cf					      db	32
      1  12cf		       20		      .byte.b	32
      0  12d0					      db	(S2aa-*)-1
      1  12d0		       04		      .byte.b	(S2aa-*)-1
      0  12d1					      db	"URN",0
      1  12d1		       55 52 4e 00	      .byte.b	"URN",0
     84  12d5				   S2aa
      0  12d5					      DONE		;MUST BE CR
      0  12d5					      db	1
      1  12d5		       01		      .byte.b	1
      0  12d6					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  12d6					      db	9
      1  12d6		       09		      .byte.b	9
      0  12d7					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  12d7					      db	6
      1  12d7		       06		      .byte.b	6
      0  12d8					      dw	CO
      1  12d8		       55 12		      .word.w	CO
      0  12da					      IJMP	STMT
      0  12da					      db	29
      1  12da		       1d		      .byte.b	29
      0  12db					      dw	STMT
      1  12db		       5d 12		      .word.w	STMT
     89  12dd				   S2a
      0  12dd					      TST	S3,"M"	;REMark.  Skip rest of line
      0  12dd					      db	32
      1  12dd		       20		      .byte.b	32
      0  12de					      db	(S3-*)-1
      1  12de		       08		      .byte.b	(S3-*)-1
      0  12df					      db	"M",0
      1  12df		       4d 00		      .byte.b	"M",0
      0  12e1					      NXT	CO
      0  12e1					      db	6
      1  12e1		       06		      .byte.b	6
      0  12e2					      dw	CO
      1  12e2		       55 12		      .word.w	CO
      0  12e4					      IJMP	STMT
      0  12e4					      db	29
      1  12e4		       1d		      .byte.b	29
      0  12e5					      dw	STMT
      1  12e5		       5d 12		      .word.w	STMT
     93  12e7
     94  12e7				   S3
      0  12e7					      TST	S3a,"?"	; ? symonym for print
      0  12e7					      db	32
      1  12e7		       20		      .byte.b	32
      0  12e8					      db	(S3a-*)-1
      1  12e8		       05		      .byte.b	(S3a-*)-1
      0  12e9					      db	"?",0
      1  12e9		       3f 00		      .byte.b	"?",0
      0  12eb					      IJMP	S4S
      0  12eb					      db	29
      1  12eb		       1d		      .byte.b	29
      0  12ec					      dw	S4S
      1  12ec		       f9 12		      .word.w	S4S
     97  12ee				   S3a
      0  12ee					      TST	S8,"PR"	;allow short form of print
      0  12ee					      db	32
      1  12ee		       20		      .byte.b	32
      0  12ef					      db	(S8-*)-1
      1  12ef		       4c		      .byte.b	(S8-*)-1
      0  12f0					      db	"PR",0
      1  12f0		       50 52 00 	      .byte.b	"PR",0
      0  12f3					      TST	S4S,"INT"	;PRINT
      0  12f3					      db	32
      1  12f3		       20		      .byte.b	32
      0  12f4					      db	(S4S-*)-1
      1  12f4		       04		      .byte.b	(S4S-*)-1
      0  12f5					      db	"INT",0
      1  12f5		       49 4e 54 00	      .byte.b	"INT",0
    100  12f9				   S4S
      0  12f9					      STARTIO		;Lock task until io completes
      0  12f9					      db	70
      1  12f9		       46		      .byte.b	70
    102  12fa				   S4
      0  12fa					      TSTDONE	S4a	;Test if we just want crlf printed
      0  12fa					      db	50
      1  12fa		       32		      .byte.b	50
      0  12fb					      db	(S4a-*)-1
      1  12fb		       03		      .byte.b	(S4a-*)-1
      0  12fc					      IJMP	S6
      0  12fc					      db	29
      1  12fc		       1d		      .byte.b	29
      0  12fd					      dw	S6
      1  12fd		       15 13		      .word.w	S6
    105  12ff
    106  12ff				   S4a
      0  12ff					      TSTSTR	S7	;TEST FOR QUOTED String
      0  12ff					      db	55
      1  12ff		       37		      .byte.b	55
      0  1300					      db	(S7-*)-1
      1  1300		       21		      .byte.b	(S7-*)-1
      0  1301					      PRS		;PRINT STRING
      0  1301					      db	2
      1  1301		       02		      .byte.b	2
    109  1302				   S5
      0  1302					      TST	S6A,COMMA	;IS THERE MORE?
      0  1302					      db	32
      1  1302		       20		      .byte.b	32
      0  1303					      db	(S6A-*)-1
      1  1303		       08		      .byte.b	(S6A-*)-1
      0  1304					      db	COMMA,0
      1  1304		       2c 00		      .byte.b	COMMA,0
      0  1306					      SPC		;SPACE TO NEXT ZONE
      0  1306					      db	4
      1  1306		       04		      .byte.b	4
      0  1307					      TSTDONE	S4	;Not end of line jump back
      0  1307					      db	50
      1  1307		       32		      .byte.b	50
      0  1308					      db	(S4-*)-1
      1  1308		       f1		      .byte.b	(S4-*)-1
      0  1309					      IJMP	S6Z	;YES JUMP BACK
      0  1309					      db	29
      1  1309		       1d		      .byte.b	29
      0  130a					      dw	S6Z
      1  130a		       17 13		      .word.w	S6Z
    114  130c
    115  130c							;
    116  130c							; If a semicolon, don't do anything.
    117  130c							;
    118  130c				   S6A
      0  130c					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  130c					      db	32
      1  130c		       20		      .byte.b	32
      0  130d					      db	(S6-*)-1
      1  130d		       07		      .byte.b	(S6-*)-1
      0  130e					      db	SEMICOLON,0
      1  130e		       3b 00		      .byte.b	SEMICOLON,0
      0  1310					      TSTDONE	S4	;Jump Back if not end of line
      0  1310					      db	50
      1  1310		       32		      .byte.b	50
      0  1311					      db	(S4-*)-1
      1  1311		       e8		      .byte.b	(S4-*)-1
      0  1312					      IJMP	S6Z
      0  1312					      db	29
      1  1312		       1d		      .byte.b	29
      0  1313					      dw	S6Z
      1  1313		       17 13		      .word.w	S6Z
    122  1315				   S6
      0  1315					      DONE		;ERROR IF CR NOT NEXT
      0  1315					      db	1
      1  1315		       01		      .byte.b	1
      0  1316					      NLINE
      0  1316					      db	5
      1  1316		       05		      .byte.b	5
    125  1317				   S6Z
      0  1317					      ENDIO		;release task io completed
      0  1317					      db	71
      1  1317		       47		      .byte.b	71
      0  1318					      NXT	CO	;exit here if , or ; at end of print
      0  1318					      db	6
      1  1318		       06		      .byte.b	6
      0  1319					      dw	CO
      1  1319		       55 12		      .word.w	CO
      0  131b					      IJMP	STMT
      0  131b					      db	29
      1  131b		       1d		      .byte.b	29
      0  131c					      dw	STMT
      1  131c		       5d 12		      .word.w	STMT
    129  131e							;
    130  131e							; A jump for code too far away for relative branch
    131  131e							;
    132  131e				   ERRVEC
      0  131e					      ENDIO
      0  131e					      db	71
      1  131e		       47		      .byte.b	71
      0  131f					      IJMP	UNKNOWN
      0  131f					      db	29
      1  131f		       1d		      .byte.b	29
      0  1320					      dw	UNKNOWN
      1  1320		       4a 14		      .word.w	UNKNOWN
    135  1322							;
    136  1322							; Get here if there is an expression to print
    137  1322				   S7
      0  1322					      TST	S7A,"$"
      0  1322					      db	32
      1  1322		       20		      .byte.b	32
      0  1323					      db	(S7A-*)-1
      1  1323		       09		      .byte.b	(S7A-*)-1
      0  1324					      db	"$",0
      1  1324		       24 00		      .byte.b	"$",0
      0  1326					      CALL	EXPR
      0  1326					      db	28
      1  1326		       1c		      .byte.b	28
      0  1327					      dw	EXPR
      1  1327		       4e 14		      .word.w	EXPR
      0  1329					      HEXPRT
      0  1329					      db	67
      1  1329		       43		      .byte.b	67
      0  132a					      IJMP	S5
      0  132a					      db	29
      1  132a		       1d		      .byte.b	29
      0  132b					      dw	S5
      1  132b		       02 13		      .word.w	S5
    142  132d				   S7A
      0  132d					      CALL	EXPR
      0  132d					      db	28
      1  132d		       1c		      .byte.b	28
      0  132e					      dw	EXPR
      1  132e		       4e 14		      .word.w	EXPR
      0  1330					      TST	S7B,"$"
      0  1330					      db	32
      1  1330		       20		      .byte.b	32
      0  1331					      db	(S7B-*)-1
      1  1331		       06		      .byte.b	(S7B-*)-1
      0  1332					      db	"$",0
      1  1332		       24 00		      .byte.b	"$",0
      0  1334					      PUTCHAR
      0  1334					      db	52
      1  1334		       34		      .byte.b	52
      0  1335					      IJMP	S5
      0  1335					      db	29
      1  1335		       1d		      .byte.b	29
      0  1336					      dw	S5
      1  1336		       02 13		      .word.w	S5
    147  1338				   S7B
      0  1338					      PRN		;PRINT IT
      0  1338					      db	3
      1  1338		       03		      .byte.b	3
      0  1339					      IJMP	S5	;IS THERE MORE?
      0  1339					      db	29
      1  1339		       1d		      .byte.b	29
      0  133a					      dw	S5
      1  133a		       02 13		      .word.w	S5
    150  133c							;
    151  133c							;===========================================================
    152  133c							; End of TASK process
    153  133c				   S8
      0  133c					      TST	S8G,"ETASK"	; End task
      0  133c					      db	32
      1  133c		       20		      .byte.b	32
      0  133d					      db	(S8G-*)-1
      1  133d		       0b		      .byte.b	(S8G-*)-1
      0  133e					      db	"ETASK",0
      1  133e		       45 54 41 53*	      .byte.b	"ETASK",0
      0  1344					      ETASK
      0  1344					      db	62
      1  1344		       3e		      .byte.b	62
      0  1345					      DONE		; Must be last thing on a line
      0  1345					      db	1
      1  1345		       01		      .byte.b	1
      0  1346					      IJMP	STMT
      0  1346					      db	29
      1  1346		       1d		      .byte.b	29
      0  1347					      dw	STMT
      1  1347		       5d 12		      .word.w	STMT
    158  1349							;
    159  1349							;===========================================================
    160  1349							; The task gives up the rest of the cycles
    161  1349				   S8G
      0  1349					      TST	S8a,"NTASK"	;Next task
      0  1349					      db	32
      1  1349		       20		      .byte.b	32
      0  134a					      db	(S8a-*)-1
      1  134a		       0d		      .byte.b	(S8a-*)-1
      0  134b					      db	"NTASK",0
      1  134b		       4e 54 41 53*	      .byte.b	"NTASK",0
      0  1351					      NTASK
      0  1351					      db	63
      1  1351		       3f		      .byte.b	63
      0  1352					      NXT	CO	;Next statement to execute
      0  1352					      db	6
      1  1352		       06		      .byte.b	6
      0  1353					      dw	CO
      1  1353		       55 12		      .word.w	CO
      0  1355					      IJMP	STMT
      0  1355					      db	29
      1  1355		       1d		      .byte.b	29
      0  1356					      dw	STMT
      1  1356		       5d 12		      .word.w	STMT
    166  1358							;
    167  1358							;===========================================================
    168  1358							; Update a memory location with a value
    169  1358				   S8a
      0  1358					      TST	S8b,"POKE"	;Poke a value into memory
      0  1358					      db	32
      1  1358		       20		      .byte.b	32
      0  1359					      db	(S8b-*)-1
      1  1359		       17		      .byte.b	(S8b-*)-1
      0  135a					      db	"POKE",0
      1  135a		       50 4f 4b 45*	      .byte.b	"POKE",0
      0  135f					      CALL	EXPR	;Get address to write to
      0  135f					      db	28
      1  135f		       1c		      .byte.b	28
      0  1360					      dw	EXPR
      1  1360		       4e 14		      .word.w	EXPR
      0  1362					      TST	UNKNOWN,COMMA	;Must have a coma
      0  1362					      db	32
      1  1362		       20		      .byte.b	32
      0  1363					      db	(UNKNOWN-*)-1
      1  1363		       e6		      .byte.b	(UNKNOWN-*)-1
      0  1364					      db	COMMA,0
      1  1364		       2c 00		      .byte.b	COMMA,0
      0  1366					      CALL	EXPR	;Get the value to poke
      0  1366					      db	28
      1  1366		       1c		      .byte.b	28
      0  1367					      dw	EXPR
      1  1367		       4e 14		      .word.w	EXPR
      0  1369					      POKEMEM
      0  1369					      db	47
      1  1369		       2f		      .byte.b	47
      0  136a					      DONE
      0  136a					      db	1
      1  136a		       01		      .byte.b	1
      0  136b					      NXT	CO	;AND SEQUENCE TO NEXT
      0  136b					      db	6
      1  136b		       06		      .byte.b	6
      0  136c					      dw	CO
      1  136c		       55 12		      .word.w	CO
      0  136e					      IJMP	STMT
      0  136e					      db	29
      1  136e		       1d		      .byte.b	29
      0  136f					      dw	STMT
      1  136f		       5d 12		      .word.w	STMT
    178  1371
    179  1371				   S8b
      0  1371					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1371					      db	32
      1  1371		       20		      .byte.b	32
      0  1372					      db	(S8c-*)-1
      1  1372		       11		      .byte.b	(S8c-*)-1
      0  1373					      db	"PUTCH",0
      1  1373		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1379					      CALL	EXPR
      0  1379					      db	28
      1  1379		       1c		      .byte.b	28
      0  137a					      dw	EXPR
      1  137a		       4e 14		      .word.w	EXPR
      0  137c					      PUTCHAR
      0  137c					      db	52
      1  137c		       34		      .byte.b	52
      0  137d					      DONE
      0  137d					      db	1
      1  137d		       01		      .byte.b	1
      0  137e					      NXT	CO	;AND SEQUENCE TO NEXT
      0  137e					      db	6
      1  137e		       06		      .byte.b	6
      0  137f					      dw	CO
      1  137f		       55 12		      .word.w	CO
      0  1381					      IJMP	STMT
      0  1381					      db	29
      1  1381		       1d		      .byte.b	29
      0  1382					      dw	STMT
      1  1382		       5d 12		      .word.w	STMT
    186  1384				   S8c
      0  1384					      TST	S9,"CLS"	;Clear the screen
      0  1384					      db	32
      1  1384		       20		      .byte.b	32
      0  1385					      db	(S9-*)-1
      1  1385		       0b		      .byte.b	(S9-*)-1
      0  1386					      db	"CLS",0
      1  1386		       43 4c 53 00	      .byte.b	"CLS",0
      0  138a					      CLEARSCREEN
      0  138a					      db	46
      1  138a		       2e		      .byte.b	46
      0  138b					      NXT	CO	;AND SEQUENCE TO NEXT
      0  138b					      db	6
      1  138b		       06		      .byte.b	6
      0  138c					      dw	CO
      1  138c		       55 12		      .word.w	CO
      0  138e					      IJMP	STMT
      0  138e					      db	29
      1  138e		       1d		      .byte.b	29
      0  138f					      dw	STMT
      1  138f		       5d 12		      .word.w	STMT
    191  1391				   S9
      0  1391					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1391					      db	32
      1  1391		       20		      .byte.b	32
      0  1392					      db	(S13-*)-1
      1  1392		       2a		      .byte.b	(S13-*)-1
      0  1393					      db	"INPUT",0
      1  1393		       49 4e 50 55*	      .byte.b	"INPUT",0
    193  1399				   S10
      0  1399					      TSTSTR	S10A	;If there is a string print the prompt
      0  1399					      db	55
      1  1399		       37		      .byte.b	55
      0  139a					      db	(S10A-*)-1
      1  139a		       05		      .byte.b	(S10A-*)-1
      0  139b					      PRS
      0  139b					      db	2
      1  139b		       02		      .byte.b	2
      0  139c					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  139c					      db	32
      1  139c		       20		      .byte.b	32
      0  139d					      db	(S10Z-*)-1
      1  139d		       15		      .byte.b	(S10Z-*)-1
      0  139e					      db	SEMICOLON,0
      1  139e		       3b 00		      .byte.b	SEMICOLON,0
    197  13a0				   S10A
      0  13a0					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  13a0					      db	33
      1  13a0		       21		      .byte.b	33
      0  13a1					      db	(UNKNOWN-*)-1
      1  13a1		       a8		      .byte.b	(UNKNOWN-*)-1
      0  13a2					      TST	S10A1,DOLLAR
      0  13a2					      db	32
      1  13a2		       20		      .byte.b	32
      0  13a3					      db	(S10A1-*)-1
      1  13a3		       06		      .byte.b	(S10A1-*)-1
      0  13a4					      db	DOLLAR,0
      1  13a4		       24 00		      .byte.b	DOLLAR,0
      0  13a6					      INSTR		;Move character From tty to AESTK
      0  13a6					      db	59
      1  13a6		       3b		      .byte.b	59
      0  13a7					      IJMP	S10A2
      0  13a7					      db	29
      1  13a7		       1d		      .byte.b	29
      0  13a8					      dw	S10A2
      1  13a8		       ab 13		      .word.w	S10A2
    202  13aa				   S10A1
      0  13aa					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  13aa					      db	11
      1  13aa		       0b		      .byte.b	11
    204  13ab				   S10A2
      0  13ab					      STORE		;STORE IT
      0  13ab					      db	19
      1  13ab		       13		      .byte.b	19
      0  13ac					      TST	S11,COMMA	;IS THERE MORE?
      0  13ac					      db	32
      1  13ac		       20		      .byte.b	32
      0  13ad					      db	(S11-*)-1
      1  13ad		       08		      .byte.b	(S11-*)-1
      0  13ae					      db	COMMA,0
      1  13ae		       2c 00		      .byte.b	COMMA,0
      0  13b0					      IJMP	S10	;YES
      0  13b0					      db	29
      1  13b0		       1d		      .byte.b	29
      0  13b1					      dw	S10
      1  13b1		       99 13		      .word.w	S10
    208  13b3				   S10Z
      0  13b3					      iJMP	UNKNOWN
      0  13b3					      db	29
      1  13b3		       1d		      .byte.b	29
      0  13b4					      dw	UNKNOWN
      1  13b4		       4a 14		      .word.w	UNKNOWN
    210  13b6				   S11
      0  13b6					      DONE		;MUST BE CR
      0  13b6					      db	1
      1  13b6		       01		      .byte.b	1
      0  13b7					      NXT	CO	;SEQUENCE TO NEXT
      0  13b7					      db	6
      1  13b7		       06		      .byte.b	6
      0  13b8					      dw	CO
      1  13b8		       55 12		      .word.w	CO
      0  13ba					      IJMP	STMT
      0  13ba					      db	29
      1  13ba		       1d		      .byte.b	29
      0  13bb					      dw	STMT
      1  13bb		       5d 12		      .word.w	STMT
    214  13bd				   S13
      0  13bd					      TST	S14,"END"
      0  13bd					      db	32
      1  13bd		       20		      .byte.b	32
      0  13be					      db	(S14-*)-1
      1  13be		       05		      .byte.b	(S14-*)-1
      0  13bf					      db	"END",0
      1  13bf		       45 4e 44 00	      .byte.b	"END",0
      0  13c3					      FIN
      0  13c3					      db	12
      1  13c3		       0c		      .byte.b	12
    217  13c4
    218  13c4				   S14
      0  13c4					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  13c4					      db	32
      1  13c4		       20		      .byte.b	32
      0  13c5					      db	(S14Z-*)-1
      1  13c5		       0f		      .byte.b	(S14Z-*)-1
      0  13c6					      db	"IRQ",0
      1  13c6		       49 52 51 00	      .byte.b	"IRQ",0
      0  13ca					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  13ca					      db	28
      1  13ca		       1c		      .byte.b	28
      0  13cb					      dw	EXPR
      1  13cb		       4e 14		      .word.w	EXPR
      0  13cd					      DONE		;must be CR
      0  13cd					      db	1
      1  13cd		       01		      .byte.b	1
      0  13ce					      SETIRQ		;Set the line number now
      0  13ce					      db	56
      1  13ce		       38		      .byte.b	56
      0  13cf					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  13cf					      db	6
      1  13cf		       06		      .byte.b	6
      0  13d0					      dw	CO
      1  13d0		       55 12		      .word.w	CO
      0  13d2					      IJMP	STMT
      0  13d2					      db	29
      1  13d2		       1d		      .byte.b	29
      0  13d3					      dw	STMT
      1  13d3		       5d 12		      .word.w	STMT
    225  13d5
    226  13d5				   S14Z
      0  13d5					      TST	S14S1,"KILL"	; Kill A running Task
      0  13d5					      db	32
      1  13d5		       20		      .byte.b	32
      0  13d6					      db	(S14S1-*)-1
      1  13d6		       10		      .byte.b	(S14S1-*)-1
      0  13d7					      db	"KILL",0
      1  13d7		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  13dc					      CALL	EXPR
      0  13dc					      db	28
      1  13dc		       1c		      .byte.b	28
      0  13dd					      dw	EXPR
      1  13dd		       4e 14		      .word.w	EXPR
      0  13df					      DONE
      0  13df					      db	1
      1  13df		       01		      .byte.b	1
      0  13e0					      TASKKILL
      0  13e0					      db	65
      1  13e0		       41		      .byte.b	65
      0  13e1					      NXT	CO
      0  13e1					      db	6
      1  13e1		       06		      .byte.b	6
      0  13e2					      dw	CO
      1  13e2		       55 12		      .word.w	CO
      0  13e4					      IJMP	STMT
      0  13e4					      db	29
      1  13e4		       1d		      .byte.b	29
      0  13e5					      dw	STMT
      1  13e5		       5d 12		      .word.w	STMT
    233  13e7
    234  13e7				   S14S1
      0  13e7					      TST	S15,"LIST"	;LIST COMMAND
      0  13e7					      db	32
      1  13e7		       20		      .byte.b	32
      0  13e8					      db	(S15-*)-1
      1  13e8		       0a		      .byte.b	(S15-*)-1
      0  13e9					      db	"LIST",0
      1  13e9		       4c 49 53 54*	      .byte.b	"LIST",0
      0  13ee					      DONE
      0  13ee					      db	1
      1  13ee		       01		      .byte.b	1
      0  13ef					      LST
      0  13ef					      db	21
      1  13ef		       15		      .byte.b	21
      0  13f0					      IJMP	CO
      0  13f0					      db	29
      1  13f0		       1d		      .byte.b	29
      0  13f1					      dw	CO
      1  13f1		       55 12		      .word.w	CO
    239  13f3				   S15
      0  13f3					      TST	S16,"RUN"	;RUN COMMAND
      0  13f3					      db	32
      1  13f3		       20		      .byte.b	32
      0  13f4					      db	(S16-*)-1
      1  13f4		       0d		      .byte.b	(S16-*)-1
      0  13f5					      db	"RUN",0
      1  13f5		       52 55 4e 00	      .byte.b	"RUN",0
      0  13f9					      DONE
      0  13f9					      db	1
      1  13f9		       01		      .byte.b	1
      0  13fa					      VINIT		;clear variables
      0  13fa					      db	30
      1  13fa		       1e		      .byte.b	30
      0  13fb					      LIT	1	;GOTO line 1
      0  13fb					      db	27
      1  13fb		       1b		      .byte.b	27
      0  13fc					      dw	1
      1  13fc		       01 00		      .word.w	1
      0  13fe					      XFER		;Bob's addition
      0  13fe					      db	7
      1  13fe		       07		      .byte.b	7
    245  13ff							; EXIT
      0  13ff					      IJMP	STMT	;and run!
      0  13ff					      db	29
      1  13ff		       1d		      .byte.b	29
      0  1400					      dw	STMT
      1  1400		       5d 12		      .word.w	STMT
    247  1402				   S16
      0  1402					      TST	S17A,"NEW"	;clear program
      0  1402					      db	32
      1  1402		       20		      .byte.b	32
      0  1403					      db	(S17A-*)-1
      1  1403		       08		      .byte.b	(S17A-*)-1
      0  1404					      db	"NEW",0
      1  1404		       4e 45 57 00	      .byte.b	"NEW",0
      0  1408					      DONE
      0  1408					      db	1
      1  1408		       01		      .byte.b	1
      0  1409					      IJMP	START
      0  1409					      db	29
      1  1409		       1d		      .byte.b	29
      0  140a					      dw	START
      1  140a		       4f 12		      .word.w	START
    251  140c
    252  140c				   S17A
      0  140c					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  140c					      db	32
      1  140c		       20		      .byte.b	32
      0  140d					      db	(S17B-*)-1
      1  140d		       06		      .byte.b	(S17B-*)-1
      0  140e					      db	"EXIT",0
      1  140e		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1413					      EXIT
      0  1413					      db	26
      1  1413		       1a		      .byte.b	26
    255  1414
    256  1414							;
    257  1414							; Commands related to saving/restoring programs
    258  1414							; to/from mass storage.
    259  1414							;
    260  1414				   S17B
    261  1414					      if	(XKIM || CTMON65) && DISK_ACCESS
    262  1414
      0  1414					      TST	S17C,"SAVE"
      0  1414					      db	32
      1  1414		       20		      .byte.b	32
      0  1415					      db	(S17C-*)-1
      1  1415		       0b		      .byte.b	(S17C-*)-1
      0  1416					      db	"SAVE",0
      1  1416		       53 41 56 45*	      .byte.b	"SAVE",0
      0  141b					      OPENWRITE
      0  141b					      db	40
      1  141b		       28		      .byte.b	40
      0  141c					      DLIST
      0  141c					      db	43
      1  141c		       2b		      .byte.b	43
      0  141d					      DCLOSE
      0  141d					      db	41
      1  141d		       29		      .byte.b	41
      0  141e					      IJMP	CO
      0  141e					      db	29
      1  141e		       1d		      .byte.b	29
      0  141f					      dw	CO
      1  141f		       55 12		      .word.w	CO
    268  1421
    269  1421				   S17C
      0  1421					      TST	S18,"LOAD"
      0  1421					      db	32
      1  1421		       20		      .byte.b	32
      0  1422					      db	(S18-*)-1
      1  1422		       11		      .byte.b	(S18-*)-1
      0  1423					      db	"LOAD",0
      1  1423		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1428					      OPENREAD
      0  1428					      db	39
      1  1428		       27		      .byte.b	39
    272  1429				   S17CLP
      0  1429					      DGETLINE		;get line from file
      0  1429					      db	42
      1  1429		       2a		      .byte.b	42
      0  142a					      TSTL	S17EOL	;no line num means EOL
      0  142a					      db	34
      1  142a		       22		      .byte.b	34
      0  142b					      db	(S17EOL-*)-1
      1  142b		       04		      .byte.b	(S17EOL-*)-1
      0  142c					      INSERT		;put it into the program
      0  142c					      db	24
      1  142c		       18		      .byte.b	24
      0  142d					      IJMP	S17CLP	;keep going
      0  142d					      db	29
      1  142d		       1d		      .byte.b	29
      0  142e					      dw	S17CLP
      1  142e		       29 14		      .word.w	S17CLP
    277  1430				   S17EOL
      0  1430					      DCLOSE		;close disk file
      0  1430					      db	41
      1  1430		       29		      .byte.b	41
      0  1431					      IJMP	CO	;back to start
      0  1431					      db	29
      1  1431		       1d		      .byte.b	29
      0  1432					      dw	CO
      1  1432		       55 12		      .word.w	CO
    280  1434
      0  1434				   S18	      TST	S19,"DIR"
      0  1434					      db	32
      1  1434		       20		      .byte.b	32
      0  1435					      db	(S19-*)-1
      1  1435		       08		      .byte.b	(S19-*)-1
      0  1436					      db	"DIR",0
      1  1436		       44 49 52 00	      .byte.b	"DIR",0
      0  143a					      DDIR		;Display the directory content
      0  143a					      db	44
      1  143a		       2c		      .byte.b	44
      0  143b					      IJMP	CO
      0  143b					      db	29
      1  143b		       1d		      .byte.b	29
      0  143c					      dw	CO
      1  143c		       55 12		      .word.w	CO
    284  143e					      endif
    285  143e
      0  143e				   S19	      TST	UNKNOWN,"ERASE"
      0  143e					      db	32
      1  143e		       20		      .byte.b	32
      0  143f					      db	(UNKNOWN-*)-1
      1  143f		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1440					      db	"ERASE",0
      1  1440		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1446					      RMFILE		;Erase the file from the disk
      0  1446					      db	45
      1  1446		       2d		      .byte.b	45
      0  1447					      IJMP	CO
      0  1447					      db	29
      1  1447		       1d		      .byte.b	29
      0  1448					      dw	CO
      1  1448		       55 12		      .word.w	CO
    289  1448					      endif
    290  144a
    291  144a							;
    292  144a							; Else, unknown command.
    293  144a							;
    294  144a				   UNKNOWN
      0  144a					      ENDIO
      0  144a					      db	71
      1  144a		       47		      .byte.b	71
      0  144b					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  144b					      db	13
      1  144b		       0d		      .byte.b	13
      0  144c					      dw	ERR_SYNTAX
      1  144c		       05 00		      .word.w	ERR_SYNTAX
    297  144e
    298  144e							;-----------------------------------------------------
    299  144e				   EXPR
      0  144e					      Call	EXPR2	; get the first expression
      0  144e					      db	28
      1  144e		       1c		      .byte.b	28
      0  144f					      dw	EXPR2
      1  144f		       99 14		      .word.w	EXPR2
      0  1451					      TST	iR0,"="
      0  1451					      db	32
      1  1451		       20		      .byte.b	32
      0  1452					      db	(iR0-*)-1
      1  1452		       08		      .byte.b	(iR0-*)-1
      0  1453					      db	"=",0
      1  1453		       3d 00		      .byte.b	"=",0
      0  1455					      LIT	2	;=
      0  1455					      db	27
      1  1455		       1b		      .byte.b	27
      0  1456					      dw	2
      1  1456		       02 00		      .word.w	2
      0  1458					      IJMP	iRFound
      0  1458					      db	29
      1  1458		       1d		      .byte.b	29
      0  1459					      dw	iRFound
      1  1459		       94 14		      .word.w	iRFound
    304  145b				   iR0
      0  145b					      TST	iR4,"<"
      0  145b					      db	32
      1  145b		       20		      .byte.b	32
      0  145c					      db	(iR4-*)-1
      1  145c		       1c		      .byte.b	(iR4-*)-1
      0  145d					      db	"<",0
      1  145d		       3c 00		      .byte.b	"<",0
      0  145f					      TST	iR1,"="
      0  145f					      db	32
      1  145f		       20		      .byte.b	32
      0  1460					      db	(iR1-*)-1
      1  1460		       08		      .byte.b	(iR1-*)-1
      0  1461					      db	"=",0
      1  1461		       3d 00		      .byte.b	"=",0
      0  1463					      LIT	3	;<=
      0  1463					      db	27
      1  1463		       1b		      .byte.b	27
      0  1464					      dw	3
      1  1464		       03 00		      .word.w	3
      0  1466					      IJMP	iRFound
      0  1466					      db	29
      1  1466		       1d		      .byte.b	29
      0  1467					      dw	iRFound
      1  1467		       94 14		      .word.w	iRFound
    309  1469				   iR1
      0  1469					      TST	iR3,">"
      0  1469					      db	32
      1  1469		       20		      .byte.b	32
      0  146a					      db	(iR3-*)-1
      1  146a		       08		      .byte.b	(iR3-*)-1
      0  146b					      db	">",0
      1  146b		       3e 00		      .byte.b	">",0
      0  146d					      LIT	5	;<>
      0  146d					      db	27
      1  146d		       1b		      .byte.b	27
      0  146e					      dw	5
      1  146e		       05 00		      .word.w	5
      0  1470					      IJMP	iRFound
      0  1470					      db	29
      1  1470		       1d		      .byte.b	29
      0  1471					      dw	iRFound
      1  1471		       94 14		      .word.w	iRFound
    313  1473				   iR3
      0  1473					      LIT	1	;<
      0  1473					      db	27
      1  1473		       1b		      .byte.b	27
      0  1474					      dw	1
      1  1474		       01 00		      .word.w	1
      0  1476					      IJMP	iRFound
      0  1476					      db	29
      1  1476		       1d		      .byte.b	29
      0  1477					      dw	iRFound
      1  1477		       94 14		      .word.w	iRFound
    316  1479				   iR4
      0  1479					      TST	iRDone,">"
      0  1479					      db	32
      1  1479		       20		      .byte.b	32
      0  147a					      db	(iRDone-*)-1
      1  147a		       1d		      .byte.b	(iRDone-*)-1
      0  147b					      db	">",0
      1  147b		       3e 00		      .byte.b	">",0
      0  147d					      TST	iR5,"="
      0  147d					      db	32
      1  147d		       20		      .byte.b	32
      0  147e					      db	(iR5-*)-1
      1  147e		       08		      .byte.b	(iR5-*)-1
      0  147f					      db	"=",0
      1  147f		       3d 00		      .byte.b	"=",0
      0  1481					      LIT	6	;>=
      0  1481					      db	27
      1  1481		       1b		      .byte.b	27
      0  1482					      dw	6
      1  1482		       06 00		      .word.w	6
      0  1484					      IJMP	iRFound
      0  1484					      db	29
      1  1484		       1d		      .byte.b	29
      0  1485					      dw	iRFound
      1  1485		       94 14		      .word.w	iRFound
    321  1487				   iR5
      0  1487					      TST	iR6,"<"
      0  1487					      db	32
      1  1487		       20		      .byte.b	32
      0  1488					      db	(iR6-*)-1
      1  1488		       08		      .byte.b	(iR6-*)-1
      0  1489					      db	"<",0
      1  1489		       3c 00		      .byte.b	"<",0
      0  148b					      LIT	1
      0  148b					      db	27
      1  148b		       1b		      .byte.b	27
      0  148c					      dw	1
      1  148c		       01 00		      .word.w	1
      0  148e					      IJMP	iRFound	;(This line originally omitted)
      0  148e					      db	29
      1  148e		       1d		      .byte.b	29
      0  148f					      dw	iRFound
      1  148f		       94 14		      .word.w	iRFound
    325  1491				   iR6
      0  1491					      LIT	4	;>
      0  1491					      db	27
      1  1491		       1b		      .byte.b	27
      0  1492					      dw	4
      1  1492		       04 00		      .word.w	4
    327  1494				   iRFound
      0  1494					      Call	EXPR2	; get the right side of the expression
      0  1494					      db	28
      1  1494		       1c		      .byte.b	28
      0  1495					      dw	EXPR2
      1  1495		       99 14		      .word.w	EXPR2
      0  1497					      CMPR		; Push the value of the true false onto the stack
      0  1497					      db	10
      1  1497		       0a		      .byte.b	10
    330  1498
    331  1498				   iRDone
      0  1498					      RTN
      0  1498					      db	25
      1  1498		       19		      .byte.b	25
    333  1499
    334  1499				   EXPR2
      0  1499					      TST	E0,"-"	; Look for leading - to negate term
      0  1499					      db	32
      1  1499		       20		      .byte.b	32
      0  149a					      db	(E0-*)-1
      1  149a		       09		      .byte.b	(E0-*)-1
      0  149b					      db	"-",0
      1  149b		       2d 00		      .byte.b	"-",0
      0  149d					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  149d					      db	28
      1  149d		       1c		      .byte.b	28
      0  149e					      dw	TERM
      1  149e		       c2 14		      .word.w	TERM
      0  14a0					      NEG		; Make value negated
      0  14a0					      db	16
      1  14a0		       10		      .byte.b	16
      0  14a1					      IJMP	E1	; We have Left term process operators next
      0  14a1					      db	29
      1  14a1		       1d		      .byte.b	29
      0  14a2					      dw	E1
      1  14a2		       ab 14		      .word.w	E1
    339  14a4				   E0
      0  14a4					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  14a4					      db	32
      1  14a4		       20		      .byte.b	32
      0  14a5					      db	(E1A-*)-1
      1  14a5		       02		      .byte.b	(E1A-*)-1
      0  14a6					      db	"+",0
      1  14a6		       2b 00		      .byte.b	"+",0
    341  14a8				   E1A
      0  14a8					      CALL	TERM	; Get the left term if it was not negated
      0  14a8					      db	28
      1  14a8		       1c		      .byte.b	28
      0  14a9					      dw	TERM
      1  14a9		       c2 14		      .word.w	TERM
    343  14ab				   E1
      0  14ab					      TST	E2,"+"	; Check if we are adding left term to something
      0  14ab					      db	32
      1  14ab		       20		      .byte.b	32
      0  14ac					      db	(E2-*)-1
      1  14ac		       09		      .byte.b	(E2-*)-1
      0  14ad					      db	"+",0
      1  14ad		       2b 00		      .byte.b	"+",0
      0  14af					      CALL	TERM	; if adding then get the right side term
      0  14af					      db	28
      1  14af		       1c		      .byte.b	28
      0  14b0					      dw	TERM
      1  14b0		       c2 14		      .word.w	TERM
      0  14b2					      ADD		; Add it to left term
      0  14b2					      db	14
      1  14b2		       0e		      .byte.b	14
      0  14b3					      IJMP	E1	; look for next + or -
      0  14b3					      db	29
      1  14b3		       1d		      .byte.b	29
      0  14b4					      dw	E1
      1  14b4		       ab 14		      .word.w	E1
    348  14b6				   E2
      0  14b6					      TST	E3,"-"	; Check if we are subtractig something
      0  14b6					      db	32
      1  14b6		       20		      .byte.b	32
      0  14b7					      db	(E3-*)-1
      1  14b7		       09		      .byte.b	(E3-*)-1
      0  14b8					      db	"-",0
      1  14b8		       2d 00		      .byte.b	"-",0
      0  14ba					      CALL	TERM	; get right side to subtract Diffrence
      0  14ba					      db	28
      1  14ba		       1c		      .byte.b	28
      0  14bb					      dw	TERM
      1  14bb		       c2 14		      .word.w	TERM
      0  14bd					      SUB		; Subtract the value
      0  14bd					      db	15
      1  14bd		       0f		      .byte.b	15
      0  14be					      IJMP	E1	; Look for next + or -
      0  14be					      db	29
      1  14be		       1d		      .byte.b	29
      0  14bf					      dw	E1
      1  14bf		       ab 14		      .word.w	E1
    353  14c1				   E3			; Finish processing the expression
      0  14c1					      RTN		; We are finished processing the Expression
      0  14c1					      db	25
      1  14c1		       19		      .byte.b	25
    355  14c2							;
    356  14c2							; Get one of the terms of an expression
    357  14c2							;
    358  14c2				   TERM
      0  14c2					      CALL	FACT	; Get a value
      0  14c2					      db	28
      1  14c2		       1c		      .byte.b	28
      0  14c3					      dw	FACT
      1  14c3		       ea 14		      .word.w	FACT
    360  14c5				   T0			; Check for higher precidence operators
      0  14c5					      TST	T1,"*"	; Check for *
      0  14c5					      db	32
      1  14c5		       20		      .byte.b	32
      0  14c6					      db	(T1-*)-1
      1  14c6		       09		      .byte.b	(T1-*)-1
      0  14c7					      db	"*",0
      1  14c7		       2a 00		      .byte.b	"*",0
      0  14c9					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  14c9					      db	28
      1  14c9		       1c		      .byte.b	28
      0  14ca					      dw	FACT
      1  14ca		       ea 14		      .word.w	FACT
      0  14cc					      MUL		; Multiply factors
      0  14cc					      db	17
      1  14cc		       11		      .byte.b	17
      0  14cd					      IJMP	T0	; Check for * or /
      0  14cd					      db	29
      1  14cd		       1d		      .byte.b	29
      0  14ce					      dw	T0
      1  14ce		       c5 14		      .word.w	T0
    365  14d0				   T1
      0  14d0					      TST	T2,"/"	; Check for a division
      0  14d0					      db	32
      1  14d0		       20		      .byte.b	32
      0  14d1					      db	(T2-*)-1
      1  14d1		       09		      .byte.b	(T2-*)-1
      0  14d2					      db	"/",0
      1  14d2		       2f 00		      .byte.b	"/",0
      0  14d4					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  14d4					      db	28
      1  14d4		       1c		      .byte.b	28
      0  14d5					      dw	FACT
      1  14d5		       ea 14		      .word.w	FACT
      0  14d7					      DIV		; do division
      0  14d7					      db	18
      1  14d7		       12		      .byte.b	18
      0  14d8					      IJMP	T0	; check for more * or /
      0  14d8					      db	29
      1  14d8		       1d		      .byte.b	29
      0  14d9					      dw	T0
      1  14d9		       c5 14		      .word.w	T0
    370  14db				   T2
      0  14db					      TST	T3,"%"	; Check for a division
      0  14db					      db	32
      1  14db		       20		      .byte.b	32
      0  14dc					      db	(T3-*)-1
      1  14dc		       09		      .byte.b	(T3-*)-1
      0  14dd					      db	"%",0
      1  14dd		       25 00		      .byte.b	"%",0
      0  14df					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  14df					      db	28
      1  14df		       1c		      .byte.b	28
      0  14e0					      dw	FACT
      1  14e0		       ea 14		      .word.w	FACT
      0  14e2					      MODULO		; do division for remainder
      0  14e2					      db	60
      1  14e2		       3c		      .byte.b	60
      0  14e3					      IJMP	T0	; check for more * or / or %
      0  14e3					      db	29
      1  14e3		       1d		      .byte.b	29
      0  14e4					      dw	T0
      1  14e4		       c5 14		      .word.w	T0
    375  14e6				   T3			; Finish processing the Term
      0  14e6					      RTN
      0  14e6					      db	25
      1  14e6		       19		      .byte.b	25
    377  14e7
    378  14e7				   UNKNOWNVEC
      0  14e7					      IJMP	UNKNOWN
      0  14e7					      db	29
      1  14e7		       1d		      .byte.b	29
      0  14e8					      dw	UNKNOWN
      1  14e8		       4a 14		      .word.w	UNKNOWN
    380  14ea
    381  14ea							;
    382  14ea							; Factor an expression.  Always test for functions
    383  14ea							; first or else they'll be confused for variables.
    384  14ea							;
    385  14ea				   FACT
      0  14ea					      TST	F1A,"FREE()"
      0  14ea					      db	32
      1  14ea		       20		      .byte.b	32
      0  14eb					      db	(F1A-*)-1
      1  14eb		       09		      .byte.b	(F1A-*)-1
      0  14ec					      db	"FREE()",0
      1  14ec		       46 52 45 45*	      .byte.b	"FREE()",0
      0  14f3					      FREE
      0  14f3					      db	36
      1  14f3		       24		      .byte.b	36
      0  14f4					      RTN
      0  14f4					      db	25
      1  14f4		       19		      .byte.b	25
    389  14f5				   F1A
      0  14f5					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  14f5					      db	32
      1  14f5		       20		      .byte.b	32
      0  14f6					      db	(F1A2-*)-1
      1  14f6		       0a		      .byte.b	(F1A2-*)-1
      0  14f7					      db	"GETCH()",0
      1  14f7		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  14ff					      GETCHAR
      0  14ff					      db	51
      1  14ff		       33		      .byte.b	51
      0  1500					      RTN
      0  1500					      db	25
      1  1500		       19		      .byte.b	25
    393  1501				   F1A2
      0  1501					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1501					      db	32
      1  1501		       20		      .byte.b	32
      0  1502					      db	(F2AZ-*)-1
      1  1502		       0f		      .byte.b	(F2AZ-*)-1
      0  1503					      db	"PEEK(",0
      1  1503		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1509					      CALL	EXPR	;Get the address to write to
      0  1509					      db	28
      1  1509		       1c		      .byte.b	28
      0  150a					      dw	EXPR
      1  150a		       4e 14		      .word.w	EXPR
      0  150c					      TST	UNKNOWN,")"	;Closing bracket
      0  150c					      db	32
      1  150c		       20		      .byte.b	32
      0  150d					      db	(UNKNOWN-*)-1
      1  150d		       3c		      .byte.b	(UNKNOWN-*)-1
      0  150e					      db	")",0
      1  150e		       29 00		      .byte.b	")",0
      0  1510					      PEEKMEM
      0  1510					      db	48
      1  1510		       30		      .byte.b	48
      0  1511					      RTN
      0  1511					      db	25
      1  1511		       19		      .byte.b	25
    399  1512				   F2AZ
      0  1512					      TST	F2A,"TASK("	;Check if we are setting a task start
      0  1512					      db	32
      1  1512		       20		      .byte.b	32
      0  1513					      db	(F2A-*)-1
      1  1513		       0f		      .byte.b	(F2A-*)-1
      0  1514					      db	"TASK(",0
      1  1514		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  151a					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  151a					      db	28
      1  151a		       1c		      .byte.b	28
      0  151b					      dw	EXPR
      1  151b		       4e 14		      .word.w	EXPR
      0  151d					      TST	UNKNOWN,")"	;must be )
      0  151d					      db	32
      1  151d		       20		      .byte.b	32
      0  151e					      db	(UNKNOWN-*)-1
      1  151e		       2b		      .byte.b	(UNKNOWN-*)-1
      0  151f					      db	")",0
      1  151f		       29 00		      .byte.b	")",0
      0  1521					      SETTASK		;Set the Task up and start it
      0  1521					      db	61
      1  1521		       3d		      .byte.b	61
      0  1522					      RTN		;Returns the Task number
      0  1522					      db	25
      1  1522		       19		      .byte.b	25
    405  1523							;
    406  1523							; RND() is supposed to have an argument but if none
    407  1523							; was provided, just assume a large value.
    408  1523							;
    409  1523				   F2A
      0  1523					      TST	F2B,"RND("
      0  1523					      db	32
      1  1523		       20		      .byte.b	32
      0  1524					      db	(F2B-*)-1
      1  1524		       17		      .byte.b	(F2B-*)-1
      0  1525					      db	"RND(",0
      1  1525		       52 4e 44 28*	      .byte.b	"RND(",0
      0  152a					      TST	F2A1,")"
      0  152a					      db	32
      1  152a		       20		      .byte.b	32
      0  152b					      db	(F2A1-*)-1
      1  152b		       07		      .byte.b	(F2A1-*)-1
      0  152c					      db	")",0
      1  152c		       29 00		      .byte.b	")",0
      0  152e					      LIT	32766
      0  152e					      db	27
      1  152e		       1b		      .byte.b	27
      0  152f					      dw	32766
      1  152f		       fe 7f		      .word.w	32766
      0  1531					      RANDOM
      0  1531					      db	37
      1  1531		       25		      .byte.b	37
      0  1532					      RTN
      0  1532					      db	25
      1  1532		       19		      .byte.b	25
    415  1533				   F2A1
      0  1533					      CALL	FACT	;GET RANGE
      0  1533					      db	28
      1  1533		       1c		      .byte.b	28
      0  1534					      dw	FACT
      1  1534		       ea 14		      .word.w	FACT
      0  1536					      TST	UNKNOWN,")"
      0  1536					      db	32
      1  1536		       20		      .byte.b	32
      0  1537					      db	(UNKNOWN-*)-1
      1  1537		       12		      .byte.b	(UNKNOWN-*)-1
      0  1538					      db	")",0
      1  1538		       29 00		      .byte.b	")",0
      0  153a					      RANDOM
      0  153a					      db	37
      1  153a		       25		      .byte.b	37
      0  153b					      RTN
      0  153b					      db	25
      1  153b		       19		      .byte.b	25
    420  153c
    421  153c				   F2B
      0  153c					      TST	F2B2,"ABS("
      0  153c					      db	32
      1  153c		       20		      .byte.b	32
      0  153d					      db	(F2B2-*)-1
      1  153d		       0e		      .byte.b	(F2B2-*)-1
      0  153e					      db	"ABS(",0
      1  153e		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1543					      CALL	FACT	;get value
      0  1543					      db	28
      1  1543		       1c		      .byte.b	28
      0  1544					      dw	FACT
      1  1544		       ea 14		      .word.w	FACT
      0  1546					      TST	UNKNOWNVEC,")"
      0  1546					      db	32
      1  1546		       20		      .byte.b	32
      0  1547					      db	(UNKNOWNVEC-*)-1
      1  1547		       9f		      .byte.b	(UNKNOWNVEC-*)-1
      0  1548					      db	")",0
      1  1548		       29 00		      .byte.b	")",0
      0  154a					      ABS
      0  154a					      db	38
      1  154a		       26		      .byte.b	38
      0  154b					      RTN
      0  154b					      db	25
      1  154b		       19		      .byte.b	25
    427  154c
    428  154c				   F2B2
      0  154c					      TST	F2Z,"STAT("
      0  154c					      db	32
      1  154c		       20		      .byte.b	32
      0  154d					      db	(F2Z-*)-1
      1  154d		       0f		      .byte.b	(F2Z-*)-1
      0  154e					      db	"STAT(",0
      1  154e		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1554					      Call	EXPR
      0  1554					      db	28
      1  1554		       1c		      .byte.b	28
      0  1555					      dw	EXPR
      1  1555		       4e 14		      .word.w	EXPR
      0  1557					      TST	UNKNOWNVEC,")"
      0  1557					      db	32
      1  1557		       20		      .byte.b	32
      0  1558					      db	(UNKNOWNVEC-*)-1
      1  1558		       8e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1559					      db	")",0
      1  1559		       29 00		      .byte.b	")",0
      0  155b					      TASKSTAT
      0  155b					      db	66
      1  155b		       42		      .byte.b	66
      0  155c					      RTN
      0  155c					      db	25
      1  155c		       19		      .byte.b	25
    434  155d				   F2Z
      0  155d					      TST	F2ZA,"PID"
      0  155d					      db	32
      1  155d		       20		      .byte.b	32
      0  155e					      db	(F2ZA-*)-1
      1  155e		       09		      .byte.b	(F2ZA-*)-1
      0  155f					      db	"PID",0
      1  155f		       50 49 44 00	      .byte.b	"PID",0
      0  1563					      LIT	0
      0  1563					      db	27
      1  1563		       1b		      .byte.b	27
      0  1564					      dw	0
      1  1564		       00 00		      .word.w	0
      0  1566					      SETTASK
      0  1566					      db	61
      1  1566		       3d		      .byte.b	61
      0  1567					      RTN
      0  1567					      db	25
      1  1567		       19		      .byte.b	25
    439  1568				   F2ZA
      0  1568					      TST	F2C,"CALL("	;call machine function
      0  1568					      db	32
      1  1568		       20		      .byte.b	32
      0  1569					      db	(F2C-*)-1
      1  1569		       1f		      .byte.b	(F2C-*)-1
      0  156a					      db	"CALL(",0
      1  156a		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1570					      CALL	EXPR
      0  1570					      db	28
      1  1570		       1c		      .byte.b	28
      0  1571					      dw	EXPR
      1  1571		       4e 14		      .word.w	EXPR
      0  1573					      TST	F2B2A,COMMA
      0  1573					      db	32
      1  1573		       20		      .byte.b	32
      0  1574					      db	(F2B2A-*)-1
      1  1574		       0b		      .byte.b	(F2B2A-*)-1
      0  1575					      db	COMMA,0
      1  1575		       2c 00		      .byte.b	COMMA,0
      0  1577					      CALL	EXPR
      0  1577					      db	28
      1  1577		       1c		      .byte.b	28
      0  1578					      dw	EXPR
      1  1578		       4e 14		      .word.w	EXPR
      0  157a					      TST	UNKNOWNVEC,")"
      0  157a					      db	32
      1  157a		       20		      .byte.b	32
      0  157b					      db	(UNKNOWNVEC-*)-1
      1  157b		       6b		      .byte.b	(UNKNOWNVEC-*)-1
      0  157c					      db	")",0
      1  157c		       29 00		      .byte.b	")",0
      0  157e					      CALLFUNC
      0  157e					      db	53
      1  157e		       35		      .byte.b	53
      0  157f					      RTN
      0  157f					      db	25
      1  157f		       19		      .byte.b	25
      0  1580				   F2B2A      TST	UNKNOWNVEC,")"
      0  1580					      db	32
      1  1580		       20		      .byte.b	32
      0  1581					      db	(UNKNOWNVEC-*)-1
      1  1581		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1582					      db	")",0
      1  1582		       29 00		      .byte.b	")",0
      0  1584					      LIT	0
      0  1584					      db	27
      1  1584		       1b		      .byte.b	27
      0  1585					      dw	0
      1  1585		       00 00		      .word.w	0
      0  1587					      CALLFUNC
      0  1587					      db	53
      1  1587		       35		      .byte.b	53
      0  1588					      RTN
      0  1588					      db	25
      1  1588		       19		      .byte.b	25
    451  1589				   F2C
      0  1589					      TSTV	F0
      0  1589					      db	33
      1  1589		       21		      .byte.b	33
      0  158a					      db	(F0-*)-1
      1  158a		       0e		      .byte.b	(F0-*)-1
      0  158b					      TST	F2C1,"["
      0  158b					      db	32
      1  158b		       20		      .byte.b	32
      0  158c					      db	(F2C1-*)-1
      1  158c		       0a		      .byte.b	(F2C1-*)-1
      0  158d					      db	"[",0
      1  158d		       5b 00		      .byte.b	"[",0
      0  158f					      CALL	EXPR
      0  158f					      db	28
      1  158f		       1c		      .byte.b	28
      0  1590					      dw	EXPR
      1  1590		       4e 14		      .word.w	EXPR
      0  1592					      TST	UNKNOWNVEC,"]"
      0  1592					      db	32
      1  1592		       20		      .byte.b	32
      0  1593					      db	(UNKNOWNVEC-*)-1
      1  1593		       53		      .byte.b	(UNKNOWNVEC-*)-1
      0  1594					      db	"]",0
      1  1594		       5d 00		      .byte.b	"]",0
      0  1596					      SUBSCRIPT
      0  1596					      db	64
      1  1596		       40		      .byte.b	64
    457  1597				   F2C1
      0  1597					      IND		;YES, GET THE VALUE.
      0  1597					      db	20
      1  1597		       14		      .byte.b	20
      0  1598					      RTN
      0  1598					      db	25
      1  1598		       19		      .byte.b	25
    460  1599				   F0
      0  1599					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1599					      db	35
      1  1599		       23		      .byte.b	35
      0  159a					      db	(F1-*)-1
      1  159a		       01		      .byte.b	(F1-*)-1
      0  159b					      RTN
      0  159b					      db	25
      1  159b		       19		      .byte.b	25
    463  159c				   F1
      0  159c					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  159c					      db	32
      1  159c		       20		      .byte.b	32
      0  159d					      db	(F2A-*)-1
      1  159d		       85		      .byte.b	(F2A-*)-1
      0  159e					      db	"(",0
      1  159e		       28 00		      .byte.b	"(",0
      0  15a0					      CALL	EXPR
      0  15a0					      db	28
      1  15a0		       1c		      .byte.b	28
      0  15a1					      dw	EXPR
      1  15a1		       4e 14		      .word.w	EXPR
      0  15a3					      TST	F2,")"
      0  15a3					      db	32
      1  15a3		       20		      .byte.b	32
      0  15a4					      db	(F2-*)-1
      1  15a4		       03		      .byte.b	(F2-*)-1
      0  15a5					      db	")",0
      1  15a5		       29 00		      .byte.b	")",0
      0  15a7					      RTN
      0  15a7					      db	25
      1  15a7		       19		      .byte.b	25
    468  15a8
    469  15a8				   F2
      0  15a8					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  15a8					      db	13
      1  15a8		       0d		      .byte.b	13
      0  15a9					      dw	ERR_SYNTAX
      1  15a9		       05 00		      .word.w	ERR_SYNTAX
    471  15ab
    472  15ab		       15 ab	   ILEND      equ	*
------- FILE mytb.asm
   2232  15ab		       15 ab	   PROGEND    equ	*
   2233  15ab
   2234  15ab							;=====================================================
   2235  15ab							;=====================================================
   2236  15ab							;=====================================================
   2237  15ab							; These are storage items not in page zero.
   2238  15ab							;
   2239 Udf9e					      seg.u	Data
   2240 U15ab					      org	PROGEND
   2241 U15ab							;
   2242 U15ab							; IRQ BASIC Code Service RTN Support
      0 U15ab				   SaveIrqReg db	0	; Store current setting
      1 U15ab		       00		      .byte.b	0
      0 U15ac				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U15ac		       00		      .byte.b	0
      0 U15ad				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U15ad		       00		      .byte.b	0
      0 U15ae				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U15ae		       00 00		      .byte.b	0,0
   2247 U15b0
   2248 U15b0							;
   2249 U15b0							;==================================================================================================
   2250 U15b0							; Task Management information
   2251 U15b0							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2252 U15b0							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2253 U15b0							; Task switchs happen at the beginning of the next Basic command line
   2254 U15b0							; It will not happen during an input or output operations
   2255 U15b0							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2256 U15b0							; Task Zero is always the root task, main line program
   2257 U15b0							;
   2258 U15b0							; Layout is repeated for each configured task
   2259 U15b0							; Task Table Byte   use
   2260 U15b0							;	      0      Bit 0	     Active task
   2261 U15b0							;		     Bit 1	     Task IO pending
   2262 U15b0							;	      1..CONTEXTLEN	     All saved data for the task
   2263 U15b0		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2264 U15b1		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2265 U15b1		       16 83	   TASKTABLEEND equ	*	; End of task table
   2266 U15b1		       00 d2	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2267 U1683
   2268 U1683							;Task Cycle Counter and reset count
   2269 U1683		       00	   taskCurrentCycles ds	1
   2270 U1684		       00	   taskResetValue ds	1
   2271 U1685		       00	   taskCounter ds	1	; Count of active tasks
   2272 U1686
   2273 U1686							;
   2274 U1686							; Math stack and IL call and Gosub/For-next return stack definitions
   2275 U1686							;
   2276 U1686		       16 86	   STACKSTART equ	*
   2277 U1686		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2278 U174e		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2279 U1816		       00 00 00 00*gosubStack ds	GOSUBSTACKSIZE*4*TASKCOUNT	;stack size for gosub stacks
   2280 U1816		       1a 96	   STACKEND   equ	*
   2281 U1816		       04 10	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2282 U1a96							;
   2283 U1a96							;
   2284 U1a96		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2285 U1b1a		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2286 U1b1b		       00	   printtx    ds	1	;temp X for print funcs
   2287 U1b1c		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2288 U1b1d		       00	   promptChar ds	1	;the character to use for a prompt
   2289 U1b1e		       00	   diddigit   ds	1	;for leading zero suppression
   2290 U1b1f		       00	   putsy      ds	1
   2291 U1b20		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2292 U1b22		       00	   sign       ds	1	;0 = positive, else negative
   2293 U1b23		       00 00	   rtemp1     ds	2	;Temp for x and y
   2294 U1b25		       00 00	   random     ds	2
   2295 U1b27		       00 00	   BOutVec    ds	2
   2296 U1b29		       00	   tempy      ds	1	;temp y storage
   2297 U1b2a				  -	      if	XKIM
   2298 U1b2a				  -buffer     ds	BUFFER_SIZE
   2299 U1b2a					      endif
   2300 U1b2a							;
   2301 U1b2a							; PROGRAMEND is the end of the user's BASIC program.
   2302 U1b2a							; More precisely, it is one byte past the end.  Or,
   2303 U1b2a							; it's where the next line added to the end will be
   2304 U1b2a							; placed.
   2305 U1b2a							;
   2306 U1b2a		       00 00	   PROGRAMEND ds	2
   2307 U1b2c		       00 00	   HighMem    ds	2	;highest location
   2308 U1b2e		       00 00	   UsedMem    ds	2	;size of user program
   2309 U1b30		       00 00	   FreeMem    ds	2	;amount of free memory
   2310 U1b32							;
   2311 U1b32							;=====================================================
   2312 U1b32							; This is the start of the user's BASIC program space.
   2313 U1b32							;
   2314 U1b32							; PERSONAL GOAL: This should be no larger than $0DFF.
   2315 U1b32							;		  0200-05FF = 1K
   2316 U1b32							;		  0200-09FF = 2K
   2317 U1b32							;		  0200-0DFF = 3K
   2318 U1b32							;		  0200-11FF = 4K
   2319 U1b32							;		  0200-13FF = 4.5K
   2320 U1b32							;
   2321 U1b32				  -	      if	FIXED
   2322 U1b32				  -	      org	$2000
   2323 U1b32					      endif
   2324 U1b32		       1b 32	   ProgramStart equ	*
   2325 U1b32							;/*
   2326 U1b32							;	if	CTMON65 || XKIM
   2327 U1b32							;		SEG Code
   2328 U1b32							;		org	AutoRun
   2329 U1b32							;		dw	TBasicCold
   2330 U1b32							;	endif
   2331 U1b32							;*/
   2332 U1b32					      end
