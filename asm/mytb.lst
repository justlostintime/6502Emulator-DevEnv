------- FILE mytb.asm LEVEL 1 PASS 6
      1 U1f37				   input      processor	6502
      2 U1f37 ????						;=====================================================
      3 U1f37 ????						; Bob's Tiny BASIC
      4 U1f37 ????						;
      5 U1f37 ????						; While working on the Corsham Technologies KIM Clone
      6 U1f37 ????						; project, I wanted to include a TINY BASIC since that
      7 U1f37 ????						; was a highly desirable feature of early computers.
      8 U1f37 ????						;
      9 U1f37 ????						; Rather than negotiating copyright issues for
     10 U1f37 ????						; existing BASICs, I decided to just write one from
     11 U1f37 ????						; scratch.
     12 U1f37 ????						;
     13 U1f37 ????						; 10/07/2017
     14 U1f37 ????						;
     15 U1f37 ????						; This implements a stripped down Tiny BASIC
     16 U1f37 ????						; interpreter using the Interpretive Language (IL)
     17 U1f37 ????						; method as described in the first few issues of
     18 U1f37 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1f37 ????						; to write various languages simply by changing the
     20 U1f37 ????						; IL code rather than the interpreter itself.
     21 U1f37 ????						;
     22 U1f37 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1f37 ????						;		* Fixed major bug in findLine that
     24 U1f37 ????						;		  caused corrupted lines, crashes, etc.
     25 U1f37 ????						;		* If no parameter given to RND, assume
     26 U1f37 ????						;		  32766.
     27 U1f37 ????						;		* No more error 5 when a program
     28 U1f37 ????						;		  reaches the end without an END.
     29 U1f37 ????						;
     30 U1f37 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U1f37 ????						;		 * Unexpanded version to play with everything
     32 U1f37 ????						;		 * Add some usefull system level functions
     33 U1f37 ????						;		 * allow a larger number of tiny basic formats
     34 U1f37 ????						;		 * Add byte at start of line holding length
     35 U1f37 ????						;		   for faster execution of goto and gosub
     36 U1f37 ????						;		 * Re-added gosub
     37 U1f37 ????						;		 * allow ; or , at end if print stmt
     38 U1f37 ????						;		   without CRLF being added.
     39 U1f37 ????						;		 * Added extended function erase to
     40 U1f37 ????						;		   use the extended ctmon65 rm file
     41 U1f37 ????						;		 * Fix quoted text to not have to backtrack
     42 U1f37 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     43 U1f37 ????						;
     44 U1f37 ????						; www.corshamtech.com
     45 U1f37 ????						; bob@corshamtech.com
     46 U1f37 ????						; JustLostInTime@gmail.com
     47 U1f37 ????						;
     48 U1f37 ????						;=====================================================
     49 U1f37 ????						;
     50 U1f37 ????						; Create TRUE and FALSE values for conditionals.
     51 U1f37 ????						;
     52 U1f37 ????
     53 U1f37 ????	       00 00	   FALSE      equ	0
     54 U1f37 ????	       ff ff ff ff TRUE       equ	~FALSE
     55 U1f37 ????						;
     56 U1f37 ????						;---------------------------------------------------------
     57 U1f37 ????						; One of these must be set to indicate which environment
     58 U1f37 ????						; Tiny BASIC will be running in.  Here are the current
     59 U1f37 ????						; environments:
     60 U1f37 ????						;
     61 U1f37 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     62 U1f37 ????						; more K of RAM.
     63 U1f37 ????						;
     64 U1f37 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     65 U1f37 ????						; which enhances, without replacing, the standard KIM
     66 U1f37 ????						; monitor.  It gives access to routines to save/load files
     67 U1f37 ????						; to a micro SD card.
     68 U1f37 ????						;
     69 U1f37 ????						; CTMON65 is a from-scratch monitor written for the
     70 U1f37 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     71 U1f37 ????						; easily be ported to other systems.  It has support for
     72 U1f37 ????						; using a micro SD card for file storage/retrieval.
     73 U1f37 ????						;
     74 U1f37 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     75 U1f37 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     76 U1f37 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     77 U1f37 ????						;
     78 U1f37 ????						;   Need to define some macros for the dasm assembler
     79 U1f37 ????						;
     80 U1f37 ????				      MACRO	dw
     81 U1f37 ????				      .word	{0}
     82 U1f37 ????				      ENDM
     83 U1f37 ????
     84 U1f37 ????				      MACRO	db
     85 U1f37 ????				      .byte	{0}
     86 U1f37 ????				      ENDM
     87 U1f37 ????
     88 U1f37 ????						;
     89 U1f37 ????						; If set, include disk functions.
     90 U1f37 ????						;
     91 U1f37 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     92 U1f37 ????						;
     93 U1f37 ????						; If ILTRACE is set then dump out the address of every
     94 U1f37 ????						; IL opcode before executing it.
     95 U1f37 ????						;
     96 U1f37 ????	       00 00	   ILTRACE    equ	FALSE
     97 U1f37 ????						;
     98 U1f37 ????						; If FIXED is set, put the IL code and the user
     99 U1f37 ????						; program space at fixed locations in memory.	This is
    100 U1f37 ????						; meant only for debugging.
    101 U1f37 ????						;
    102 U1f37 ????	       00 00	   FIXED      equ	FALSE
    103 U1f37 ????						;
    104 U1f37 ????						; Sets the arithmetic stack depth.  This is *TINY*
    105 U1f37 ????						; BASIC, so keep this small!
    106 U1f37 ????						;
    107 U1f37 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    108 U1f37 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    109 U1f37 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    110 U1f37 ????	       00 09	   TASKCOUNT  equ	9	;Task Table count, up to 64 tasks
    111 U1f37 ????	       00 c8	   TASKCYCLESDEFAULT equ	200	;Default Task Switch 0-255 uses a single byte
    112 U1f37 ????	       00 02	   MESSAGESMAX equ	2	;MAX of 2 Messages
    113 U1f37 ????						;
    114 U1f37 ????						; Common ASCII constants
    115 U1f37 ????						;
    116 U1f37 ????	       00 07	   BEL	      equ	$07
    117 U1f37 ????	       00 08	   BS	      equ	$08
    118 U1f37 ????	       00 09	   TAB	      equ	$09
    119 U1f37 ????	       00 0a	   LF	      equ	$0A
    120 U1f37 ????	       00 0d	   CR	      equ	$0D
    121 U1f37 ????	       00 22	   quote      equ	$22
    122 U1f37 ????	       00 20	   SPACE      equ	$20
    123 U1f37 ????	       00 2c	   COMMA      equ	',
    124 U1f37 ????	       00 3b	   SEMICOLON  equ	';
    125 U1f37 ????	       00 3a	   COLON      equ	':
    126 U1f37 ????	       00 24	   DOLLAR     equ	'$
    127 U1f37 ????						;
    128 U1f37 ????						; These are error codes
    129 U1f37 ????						;
    130 U1f37 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    131 U1f37 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    132 U1f37 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    133 U1f37 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    134 U1f37 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    135 U1f37 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    136 U1f37 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    137 U1f37 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    138 U1f37 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    139 U1f37 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    140 U1f37 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    141 U1f37 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    142 U1f37 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    143 U1f37 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    144 U1f37 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    145 U1f37 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    146 U1f37 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    147 U1f37 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    148 U1f37 ????						;
    149 U1f37 ????						;=====================================================
    150 U1f37 ????						; Zero page storage.
    151 U1f37 ????						;
    152 U00f6 ????				      SEG.U	ZEROPAGE
    153 U0040					      org	$0040
    154 U0040
    155 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    156 U0041
    157 U0041							; The context is used to locate a task switch
    158 U0041							; it copies from here till all task fields are saved/swapped
    159 U0041							; The max number of tasks is 256 / context length
    160 U0041							;
    161 U0041		       00 41	   CONTEXT    equ	*
    162 U0041
    163 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    164 U0043		       00 00	   ILPC       ds	2	; IL program counter
    165 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    166 U0047		       00	   ILSTACKPTR ds	1
    167 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    168 U004a		       00	   MATHSTACKPTR ds	1
    169 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    170 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    171 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    172 U004f							;
    173 U004f							; CURPTR is a pointer to curent BASIC line being
    174 U004f							; executed.  Always points to start of line, CUROFF
    175 U004f							; is the offset to the current character.
    176 U004f							; The order of these fields is important
    177 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    178 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    179 U0052							;
    180 U0052							;The order of these fields in important
    181 U0052
    182 U0052							;
    183 U0052							; R0, R1 and MQ are used for arithmetic operations and
    184 U0052							; general use.
    185 U0052							;
    186 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    187 U0052		       00 00	   REG0       equ	0
    188 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    189 U0052		       00 02	   REG1       equ	2	;offset of R1
    190 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    191 U0054		       00 04	   REGMQ      equ	4	;offset og MQ
    192 U0056		       00 00	   MQ	      ds	2	;used for some math
    193 U0056		       00 58	   REGISTERSEND equ	*
    194 U0056		       00 06	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    195 U0058
    196 U0058		       00 58	   CONTEXTEND equ	*	; End of swap context
    197 U0058		       00 17	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    198 U0058		       00 34	   variablesEnd equ	26*2	; length of variable space
    199 U0058
    200 U0058		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    201 U005a		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    202 U005c		       00	   tempIlY    ds	1	;Temp IL Y register storage
    203 U005d		       00	   offset     ds	1	;IL Offset to next inst when test fails
    204 U005e		       00	   lineLength ds	1	;Length of current line
    205 U005f
    206 U005f		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
    207 U0060		       00	   taskRDPending ds	1	; 1 = background read is pending
    208 U0061
    209 U0061							;
    210 U0061							; This is zero if in immediate mode, or non-zero
    211 U0061							; if currently running a program.  Any input from
    212 U0061							; the main loop clears this, and the XFER IL
    213 U0061							; statement will set it.
    214 U0061							;
    215 U0061		       00	   RunMode    ds	1	;Basic program is running or stop
    216 U0062							;
    217 U0062							; Used for line insertion/removal.
    218 U0062							;
    219 U0062		       00 00	   FROM       ds	2	;Used for basic prog insert/remove and print text
    220 U0064
    221 U0064							; THE ADDRESS USED BY THE PRINTER FUNCTION
    222 U0064							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    223 U0064							;
    224 U0064		       00 62	   PrtFrom    EQU	FROM
    225 U0064							;
    226 U0064
    227 U0064							;
    228 U0064							;=====================================================
    229 U0064							;
    230  16c6 ????				      SEG	Code
    231  0200					      org	$0200
    232  0200							;
    233  0200							; Cold start is at $0200.  Warm start is at $0203.
    234  0200							;
    235  0200		       4c 18 02    TBasicCold jmp	cold2	;jump around vectors
    236  0203		       4c c0 02    warm       jmp	warm2	;Entry point for worm restart
    237  0206							;
    238  0206							; These are the user-supplied vectors to I/O routines.
    239  0206							; If you want, you can just patch these in the binary
    240  0206							; file, but it would be better to change the source
    241  0206							; code.
    242  0206							;
    243  0206				  -	      if	KIM
    244  0206				  -OUTCH      jmp	$1ea0	;output char in A
    245  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    246  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    247  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    248  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    249  0206					      endif
    250  0206				  -	      if	XKIM
    251  0206				  -	      include	"xkim.inc"
    252  0206				  -	      SEG	Code
    253  0206				  -OUTCH      jmp	$1ea0
    254  0206				  -GETCH      jmp	xkGETCH
    255  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    256  0206				  -OUTHEX     jmp	xkPRTBYT
    257  0206				  -MONITOR    jmp	extKIM
    258  0206				  -puts       equ	putsil
    259  0206				  -BUFFER_SIZE equ	132
    260  0206					      endif
    261  0206
    262  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0064					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    264 Udf8e
    265  0206					      SEG	Code
    266  0206							;
    267  0206		       4c 0c f0    OUTCH      jmp	cout
    268  0209		       4c 09 f0    GETCH      jmp	cin
    269  020c		       4c 18 f0    CRLF       jmp	crlf
    270  020f		       4c 1b f0    OUTHEX     jmp	HexA
    271  0212		       4c 03 f0    MONITOR    jmp	WARM
    272  0215		       4c 0f f0    ISCHAR     jmp	cstatus
    273  0215		       f0 12	   puts       equ	putsil
    274  0218					      endif
    275  0218							;
    276  0218		       20 12 f0    cold2      jsr	puts
      0  021b					      db	CR,LF
      1  021b		       0d 0a		      .byte.b	CR,LF
      0  021d					      db	"Bob's Tiny BASIC v1.0.2 IRQs/Tasks"
      1  021d		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs/Tasks"
      0  023f					      db	CR,LF
      1  023f		       0d 0a		      .byte.b	CR,LF
      0  0241					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  0241		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  026f					      db	CR,LF,0
      1  026f		       0d 0a 00 	      .byte.b	CR,LF,0
    282  0272							;
    283  0272		       20 66 11 	      jsr	GetSizes	;setup the free space available
    284  0275
    285  0275		       a9 01	   calcstack  lda	#1
    286  0277		       8d b6 17 	      sta	taskCounter	; Initialize number of tasks to 1
    287  027a		       8d dc 16 	      sta	taskTable	; mark the main task as active
    288  027d		       20 89 0b 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    289  0280		       a9 04		      lda	#IL&$ff
    290  0282		       85 43		      sta	ILPC
    291  0284		       a9 13		      lda	#IL>>8
    292  0286		       85 44		      sta	ILPC+1
    293  0288							;
    294  0288		       a9 37		      lda	#ProgramStart&$ff	;user prog
    295  028a		       8d 2f 1f 	      sta	PROGRAMEND
    296  028d		       a9 1f		      lda	#ProgramStart>>8
    297  028f		       8d 30 1f 	      sta	PROGRAMEND+1
    298  0292							;
    299  0292							; Initialize the pseudo-random number sequence...
    300  0292							;
    301  0292		       a9 5a		      lda	#$5a
    302  0294		       8d 28 1f 	      sta	rtemp1
    303  0297		       a9 9d		      lda	#%10011101
    304  0299		       8d 2a 1f 	      sta	random
    305  029c		       a9 5b		      lda	#%01011011
    306  029e		       8d 2b 1f 	      sta	random+1
    307  02a1							;
    308  02a1							;   Insert a Basic irq handler for the basic Language
    309  02a1		       a9 ae		      lda	#ServiceIrq&$ff
    310  02a3		       8d 00 df 	      sta	IRQvec
    311  02a6		       a9 02		      lda	#ServiceIrq>>8
    312  02a8		       8d 01 df 	      sta	IRQvec+1
    313  02ab		       4c cd 02 	      jmp	coldtwo
    314  02ae
    315  02ae							;
    316  02ae							; This is the Basic IRQ handler
    317  02ae		       48	   ServiceIrq pha
    318  02af		       ad d7 16 	      lda	IRQStatus
    319  02b2		       f0 0a		      BEQ	RetIrq
    320  02b4		       ad d8 16 	      lda	IRQPending
    321  02b7		       d0 05		      bne	RetIrq
    322  02b9		       a9 01		      lda	#1
    323  02bb		       8d d8 16 	      sta	IRQPending
    324  02be		       68	   RetIrq     pla
    325  02bf		       40		      rti
    326  02c0							;
    327  02c0							;
    328  02c0							; This is the warm start entry point
    329  02c0							;
    330  02c0		       20 0c 02    warm2      jsr	CRLF
    331  02c3		       ad 25 1f 	      lda	errGoto
    332  02c6		       85 43		      sta	ILPC
    333  02c8		       ad 26 1f 	      lda	errGoto+1
    334  02cb		       85 44		      sta	ILPC+1
    335  02cd							;
    336  02cd							; And continue with both starts here
    337  02cd							;
    338  02cd		       20 99 11    coldtwo    jsr	SetOutConsole
    339  02d0							;
    340  02d0							; The ILTrace flag is now run-time settable.
    341  02d0							;
    342  02d0		       a9 00		      lda	#ILTRACE&$ff
    343  02d2		       85 40		      sta	ILTrace
    344  02d4							;
    345  02d4
    346  02d4		       a9 00		      lda	#0
    347  02d6		       85 61		      sta	RunMode
    348  02d8		       8d 9b 1e 	      sta	LINBUF
    349  02db
    350  02db							; Clear everything from the stacks
    351  02db
    352  02db		       85 5f		      sta	taskIOPending	; No one waiting for io
    353  02dd		       85 60		      sta	taskRDPending	; No one waiting for bg io
    354  02df		       20 f4 0b 	      jsr	taskReset
    355  02e2							;
    356  02e2		       a9 9b		      lda	#LINBUF&$ff
    357  02e4		       85 4f		      sta	CURPTR
    358  02e6		       a9 1e		      lda	#LINBUF>>8
    359  02e8		       85 50		      sta	CURPTR+1	;fall through...
    360  02ea
    361  02ea							;=====================================================
    362  02ea							; This is the top of the IL interpreter.  This fetches
    363  02ea							; and executes the instruction currently pointed to
    364  02ea							; by ILPC and adjusts ILPC to point to the next
    365  02ea							; instruction to execute.
    366  02ea							;
    367  02ea		       ce b4 17    NextIL     dec	taskCurrentCycles
    368  02ed		       d0 03		      bne	NextIlNow
    369  02ef		       20 1d 0c 	      jsr	iTaskSwitch	;check for a task switch
    370  02f2		       a5 40	   NextIlNow  lda	ILTrace
    371  02f4		       f0 03		      beq	NextIL2
    372  02f6		       20 21 11 	      jsr	dbgLine
    373  02f9		       a4 51	   NextIL2    ldy	CUROFF
    374  02fb		       20 18 11 	      jsr	SkipSpaces
    375  02fe		       84 51		      sty	CUROFF
    376  0300							;Task IO Management
    377  0300		       a5 60		      lda	taskRDPending	; if it is zero then Nothing pending
    378  0302		       f0 07		      beq	NextILStr
    379  0304		       20 80 0f 	      jsr	ReadLine	; else Pending and poll keyboard
    380  0307		       90 02		      bcc	NextILStr	; if carry is clear then no end of line yet
    381  0309		       c6 60		      dec	taskRDPending	; Carry is set if CR has been recievec
    382  030b							;
    383  030b		       20 99 0d    NextILStr  jsr	getILByte
    384  030e							;
    385  030e							; When the handler is called, these are the conditions
    386  030e							; of several important items:
    387  030e							;
    388  030e							;    (ILPC) will point to the byte AFTER the IL
    389  030e							;    opcode being executed.
    390  030e							;
    391  030e							;    (CURPTR),CUROFF will point to the start of the
    392  030e							;    next word in the input buffer.  Ie, the next word
    393  030e							;    in the user program.
    394  030e							;
    395  030e		       0a		      asl
    396  030f		       c9 9e		      cmp	#ILTBLend-ILTBL+2
    397  0311		       90 33		      bcc	ILgood
    398  0313							;
    399  0313							; This handles an illegal IL opcode.  This is serious
    400  0313							; and there's no way to recover.
    401  0313							;
    402  0313		       20 12 f0    ILbad      jsr	puts
      0  0316					      db	CR,LF
      1  0316		       0d 0a		      .byte.b	CR,LF
      0  0318					      db	"Illegal IL "
      1  0318		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  0323					      db	0
      1  0323		       00		      .byte.b	0
    406  0324							;
    407  0324							; Well this is awkward, we need to back up the IL
    408  0324							; by one since it no longer points to the current
    409  0324							; opcode.
    410  0324							;
    411  0324		       20 a6 0d 	      jsr	decIL
    412  0327							;
    413  0327		       a0 00		      ldy	#0
    414  0329		       b1 43		      lda	(ILPC),y
    415  032b		       20 0f 02 	      jsr	OUTHEX
    416  032e		       20 12 f0 	      jsr	puts
      0  0331					      db	" at ",0
      1  0331		       20 61 74 20*	      .byte.b	" at ",0
    418  0336		       a5 44		      lda	ILPC+1
    419  0338		       20 0f 02 	      jsr	OUTHEX
    420  033b		       a5 43		      lda	ILPC
    421  033d		       20 0f 02 	      jsr	OUTHEX
    422  0340		       20 0c 02 	      jsr	CRLF
    423  0343		       4c 12 02 	      jmp	MONITOR
    424  0346							;
    425  0346							; Just jump to the address (ILPC),y.  Have to do
    426  0346							; some goofy stuff.
    427  0346							;
    428  0346		       a8	   ILgood     tay		;move index into Y
    429  0347		       b9 54 03 	      lda	ILTBL,y
    430  034a		       85 58		      sta	dpl
    431  034c		       b9 55 03 	      lda	ILTBL+1,y
    432  034f		       85 59		      sta	dpl+1
    433  0351		       6c 58 00 	      jmp	(dpl)	;go to handler
    434  0354							;
    435  0354							;=====================================================
    436  0354							; This is the IL jump table.  The IL opcode is
    437  0354							; mulitplied by two, then looked-up in this table.
    438  0354							; There is absolutely nothing special about the order
    439  0354							; of entries here... they all decode at exactly the
    440  0354							; same speed.	However the entry number must match the
    441  0354							; values in IL.inc.
    442  0354							;
      0  0354				   ILTBL      dw	iXINIT	;0
      1  0354		       1c 04		      .word.w	iXINIT
      0  0356					      dw	iDONE	;1
      1  0356		       37 04		      .word.w	iDONE
      0  0358					      dw	iPRS	;2
      1  0358		       53 04		      .word.w	iPRS
      0  035a					      dw	iPRN	;3
      1  035a		       5d 04		      .word.w	iPRN
      0  035c					      dw	iSPC	;4
      1  035c		       66 04		      .word.w	iSPC
      0  035e					      dw	iNLINE	;5
      1  035e		       72 08		      .word.w	iNLINE
      0  0360					      dw	iNXT	;6
      1  0360		       6e 04		      .word.w	iNXT
      0  0362					      dw	iXFER	;7
      1  0362		       9a 04		      .word.w	iXFER
      0  0364					      dw	iSAV	;8
      1  0364		       c7 04		      .word.w	iSAV
      0  0366					      dw	iRSTR	;9
      1  0366		       e8 04		      .word.w	iRSTR
      0  0368					      dw	iCMPR	;10
      1  0368		       f4 04		      .word.w	iCMPR
      0  036a					      dw	iINNUM	;11
      1  036a		       6c 05		      .word.w	iINNUM
      0  036c					      dw	iFIN	;12
      1  036c		       9a 05		      .word.w	iFIN
      0  036e					      dw	iERR	;13
      1  036e		       ae 05		      .word.w	iERR
      0  0370					      dw	iADD	;14
      1  0370		       1b 06		      .word.w	iADD
      0  0372					      dw	iSUB	;15
      1  0372		       31 06		      .word.w	iSUB
      0  0374					      dw	iNEG	;16
      1  0374		       47 06		      .word.w	iNEG
      0  0376					      dw	iMUL	;17
      1  0376		       5f 06		      .word.w	iMUL
      0  0378					      dw	iDIV	;18
      1  0378		       9f 06		      .word.w	iDIV
      0  037a					      dw	iSTORE	;19
      1  037a		       f5 06		      .word.w	iSTORE
      0  037c					      dw	iIND	;20
      1  037c		       0d 07		      .word.w	iIND
      0  037e					      dw	iLST	;21
      1  037e		       4a 07		      .word.w	iLST
      0  0380					      dw	iINIT	;22
      1  0380		       f0 03		      .word.w	iINIT
      0  0382					      dw	iGETLINE	;23
      1  0382		       a9 07		      .word.w	iGETLINE
      0  0384					      dw	iINSRT	;24
      1  0384		       b7 07		      .word.w	iINSRT
      0  0386					      dw	iRTN	;25
      1  0386		       6c 08		      .word.w	iRTN
      0  0388					      dw	MONITOR	;26
      1  0388		       12 02		      .word.w	MONITOR
      0  038a					      dw	iLIT	;27
      1  038a		       85 08		      .word.w	iLIT
      0  038c					      dw	iCALL	;28
      1  038c		       78 08		      .word.w	iCALL
      0  038e					      dw	iJMP	;29
      1  038e		       7b 08		      .word.w	iJMP
      0  0390					      dw	iVINIT	;30
      1  0390		       a2 08		      .word.w	iVINIT
      0  0392					      dw	iERRGOTO	;31
      1  0392		       a8 08		      .word.w	iERRGOTO
      0  0394					      dw	iTST	;32
      1  0394		       b4 08		      .word.w	iTST
      0  0396					      dw	iTSTV	;33
      1  0396		       3d 09		      .word.w	iTSTV
      0  0398					      dw	iTSTL	;34
      1  0398		       67 09		      .word.w	iTSTL
      0  039a					      dw	iTSTN	;35
      1  039a		       81 09		      .word.w	iTSTN
      0  039c					      dw	iFREE	;36
      1  039c		       fb 09		      .word.w	iFREE
      0  039e					      dw	iRANDOM	;37
      1  039e		       04 0a		      .word.w	iRANDOM
      0  03a0					      dw	iABS	;38
      1  03a0		       d5 0a		      .word.w	iABS
    482  03a2							;
    483  03a2							; Disk functions.  There must be pointers
    484  03a2							; to functions even if no disk is supported.
    485  03a2							; Makes things easier in IL.inc.
    486  03a2							;
    487  03a2					      if	DISK_ACCESS
      0  03a2					      dw	iOPENREAD	;39
      1  03a2		       df 11		      .word.w	iOPENREAD
      0  03a4					      dw	iOPENWRITE	;40
      1  03a4		       33 12		      .word.w	iOPENWRITE
      0  03a6					      dw	iDCLOSE	;41
      1  03a6		       b7 12		      .word.w	iDCLOSE
      0  03a8					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  03a8		       52 12		      .word.w	iDGETLINE
      0  03aa					      dw	iDLIST	;43 Did you remeber your towel?
      1  03aa		       b1 12		      .word.w	iDLIST
      0  03ac					      dw	iDDIR	;44
      1  03ac		       8c 12		      .word.w	iDDIR
      0  03ae					      dw	iRMFILE	;45
      1  03ae		       0d 12		      .word.w	iRMFILE
    495  03b0				  -	      else
    496  03b0				  -	      dw	NextIL	;39
    497  03b0				  -	      dw	NextIL	;40
    498  03b0				  -	      dw	NextIL	;41
    499  03b0				  -	      dw	NextIL	;42
    500  03b0				  -	      dw	NextIL	;43
    501  03b0				  -	      dw	NextIL	;44
    502  03b0				  -	      dw	NextIL	;45
    503  03b0					      endif
    504  03b0							;
      0  03b0					      dw	iCLEARSCREEN	;46
      1  03b0		       d4 11		      .word.w	iCLEARSCREEN
      0  03b2					      dw	iPOKEMEMORY	;47
      1  03b2		       62 0a		      .word.w	iPOKEMEMORY
      0  03b4					      dw	iPEEKMEMORY	;48
      1  03b4		       77 0a		      .word.w	iPEEKMEMORY
      0  03b6					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03b6		       f9 08		      .word.w	iTSTLET
      0  03b8					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  03b8		       1c 09		      .word.w	iTSTDONE
      0  03ba					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03ba		       a4 0a		      .word.w	iGETCHAR
      0  03bc					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03bc		       b8 0a		      .word.w	iPUTCHAR
      0  03be					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03be		       8d 0a		      .word.w	iCallFunc
      0  03c0					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  03c0		       41 05		      .word.w	iBranch
      0  03c2					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03c2		       dd 08		      .word.w	iTSTStr
      0  03c4					      dw	iSetIrq	;56	   sets the irq handler
      1  03c4		       52 0b		      .word.w	iSetIrq
      0  03c6					      dw	iTstIrq	;57	   test if irq is pending
      1  03c6		       c4 09		      .word.w	iTstIrq
      0  03c8					      dw	iRET	;58	   return from interupt
      1  03c8		       d6 04		      .word.w	iRET
      0  03ca					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03ca		       7f 05		      .word.w	iINSTR
      0  03cc					      dw	iMOD	;60	   returns remainder of division
      1  03cc		       a8 06		      .word.w	iMOD
      0  03ce					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03ce		       5e 0c		      .word.w	iTaskSet
      0  03d0					      dw	iETask	;62	   Terminates a task
      1  03d0		       45 0d		      .word.w	iETask
      0  03d2					      dw	iNTask	;63	   goto next task
      1  03d2		       02 0d		      .word.w	iNTask
      0  03d4					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03d4		       22 07		      .word.w	iArray
      0  03d6					      dw	iTaskKill	;65	   kill a running task
      1  03d6		       fa 0c		      .word.w	iTaskKill
      0  03d8					      dw	iTaskStat	;66	   return the state of a task PID
      1  03d8		       d4 0c		      .word.w	iTaskStat
      0  03da					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03da		       c3 0a		      .word.w	iHexOut
      0  03dc					      dw	iReadComplete	;68	   Called after a background read completes
      1  03dc		       5d 05		      .word.w	iReadComplete
      0  03de					      dw	iReadStart	;69	   Called to start a background read request
      1  03de		       53 05		      .word.w	iReadStart
      0  03e0					      dw	iStartIO	;70	   Lock task until io complete
      1  03e0		       2b 0d		      .word.w	iStartIO
      0  03e2					      dw	iEndIO	;71	   release task lock for io
      1  03e2		       30 0d		      .word.w	iEndIO
      0  03e4					      dw	iLogNot	;72	   Logical not
      1  03e4		       2e 0b		      .word.w	iLogNot
      0  03e6					      dw	iLogOr	;73	   Logical Or
      1  03e6		       04 0b		      .word.w	iLogOr
      0  03e8					      dw	iLogAnd	;74	   Logical And
      1  03e8		       ef 0a		      .word.w	iLogAnd
      0  03ea					      dw	iLogXor	;75	   Logical Xor
      1  03ea		       19 0b		      .word.w	iLogXor
      0  03ec					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03ec		       0a 0d		      .word.w	iWTASK
      0  03ee					      dw	iTASKPID	;77
      1  03ee		       39 0d		      .word.w	iTASKPID
    537  03f0
    538  03f0		       03 f0	   ILTBLend   equ	*
    539  03f0							;
    540  03f0							;=====================================================
    541  03f0							;=====================================================
    542  03f0							;=====================================================
    543  03f0							; This marks the start of the handlers for IL opcodes.
    544  03f0							;=====================================================
    545  03f0							;=====================================================
    546  03f0							;=====================================================
    547  03f0							;
    548  03f0							;
    549  03f0		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    550  03f2		       85 47		      sta	ILSTACKPTR
    551  03f4		       85 4a		      sta	MATHSTACKPTR
    552  03f6		       85 4d		      sta	GOSUBSTACKPTR
    553  03f8							;
    554  03f8		       a9 37		      lda	#ProgramStart&$ff	;user prog
    555  03fa		       85 4f		      sta	CURPTR
    556  03fc		       8d dd 16 	      sta	taskTable+1
    557  03ff		       8d 2f 1f 	      sta	PROGRAMEND
    558  0402		       a9 1f		      lda	#ProgramStart>>8
    559  0404		       85 50		      sta	CURPTR+1
    560  0406		       8d de 16 	      sta	taskTable+2
    561  0409		       8d 30 1f 	      sta	PROGRAMEND+1
    562  040c		       a9 01		      lda	#1
    563  040e		       8d dc 16 	      sta	taskTable	;Mark the first slot as active
    564  0411		       8d b6 17 	      sta	taskCounter	;there is always one task / Main task
    565  0414		       a9 c8		      lda	#TASKCYCLESDEFAULT
    566  0416		       8d b5 17 	      sta	taskResetValue
    567  0419		       8d b4 17 	      sta	taskCurrentCycles	; set up the task switch counts
    568  041c							;
    569  041c							; fall into XINIT...
    570  041c							;
    571  041c							;=====================================================
    572  041c							; This initializes for the start of the next line of
    573  041c							; BASIC text.
    574  041c							;
    575  041c		       78	   iXINIT     sei		;ensure interupts are off
    576  041d		       20 f4 0b 	      jsr	taskReset	;Clear the task table
    577  0420		       8d d8 16 	      sta	IRQPending	; reset the irq pending
    578  0423		       8d d7 16 	      sta	IRQStatus	; Make sure irqs are off
    579  0426
    580  0426		       4c ea 02    goodExit   jmp	NextIL
    581  0429							;
    582  0429							;=====================================================
    583  0429							; This check if the escape key has been entered
    584  0429							; then changes out of run mode. z Set if esc found
    585  0429				   BreakSet
    586  0429		       20 15 02 	      jsr	ISCHAR
    587  042c		       f0 06		      beq	BreakNo
    588  042e		       20 09 02 	      jsr	GETCH
    589  0431		       c9 1b		      cmp	#$1B
    590  0433		       60		      rts
    591  0434				   BreakNo
    592  0434		       a9 01		      lda	#1
    593  0436		       60		      rts
    594  0437
    595  0437							;
    596  0437
    597  0437							;=====================================================
    598  0437							; Verify there is nothing else on this input line.
    599  0437							; If there is, generate an error.
    600  0437							;
    601  0437		       a4 51	   iDONE      ldy	CUROFF
    602  0439		       20 18 11 	      jsr	SkipSpaces
    603  043c		       b1 4f		      lda	(CURPTR),y
    604  043e		       f0 10		      beq	doneadv
    605  0440		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    606  0442		       d0 05		      bne	idoneErr
    607  0444		       84 51		      sty	CUROFF
    608  0446		       4c ea 02 	      jmp	NextIL	; continue on this line
    609  0449
    610  0449				   idoneErr
    611  0449		       a2 04		      ldx	#ERR_EXTRA_STUFF
    612  044b		       a9 00		      lda	#0
    613  044d		       4c b1 05 	      jmp	iErr2
    614  0450							;
    615  0450							; Advance to the next line
    616  0450							;
    617  0450				   doneadv
    618  0450							;		 jsr	 FindNext2
    619  0450		       4c ea 02 	      jmp	NextIL
    620  0453							;
    621  0453							;=====================================================
    622  0453							; Print the string until a closing quote
    623  0453							;
    624  0453		       a4 51	   iPRS       ldy	CUROFF
    625  0455							;
    626  0455							; Odd logic here.  The main loop skipped any leading
    627  0455							; whitespace inside the quoted text, so move back to
    628  0455							; the quote, then move forward again.
    629  0455							;
    630  0455		       20 a7 11 	      jsr	PrtQuoted
    631  0458		       84 51		      sty	CUROFF
    632  045a		       4c ea 02 	      jmp	NextIL
    633  045d							;
    634  045d							;=====================================================
    635  045d							; Pop the top off the stack and print it as a signed
    636  045d							; decimal number.
    637  045d							;
    638  045d		       20 6f 10    iPRN       jsr	popR0
    639  0460		       20 36 0e 	      jsr	PrintDecimal
    640  0463		       4c ea 02 	      jmp	NextIL
    641  0466							;
    642  0466							;=====================================================
    643  0466							; Space to next zone.	Currently the code does not
    644  0466							; keep track of which column the output is on, so
    645  0466							; just print a tab.
    646  0466							;
    647  0466		       a9 09	   iSPC       lda	#TAB
    648  0468		       20 06 02 	      jsr	OUTCH
    649  046b		       4c ea 02 	      jmp	NextIL
    650  046e							;
    651  046e							;=====================================================
    652  046e							; If in immediate mode, jump to the address following
    653  046e							; the NXT instruction.  Else move to the next line of
    654  046e							; user code and continue.
    655  046e							;
    656  046e		       a5 61	   iNXT       lda	RunMode
    657  0470		       d0 03		      bne	iNxtRun	;in run mode
    658  0472							;
    659  0472							; Get address and jump to it.
    660  0472							;
    661  0472		       4c 7b 08 	      jmp	iJMP
    662  0475							;
    663  0475				   iNxtRun
    664  0475		       a4 51		      ldy	CUROFF
    665  0477		       20 18 11 	      jsr	SkipSpaces
    666  047a		       b1 4f		      lda	(CURPTR),y
    667  047c		       c9 3a		      cmp	#COLON
    668  047e		       d0 09		      bne	iNxtRunGo
    669  0480		       c8		      iny
    670  0481		       20 18 11 	      jsr	SkipSpaces
    671  0484		       84 51		      sty	CUROFF
    672  0486		       4c 94 04 	      jmp	iNxtRun2
    673  0489
    674  0489				   iNxtRunGo
    675  0489		       20 17 0e 	      jsr	FindNextLine
    676  048c		       20 29 0e 	      jsr	AtEnd
    677  048f		       d0 03		      bne	iNxtRun2	;not at end
    678  0491							;
    679  0491							; At the end of the program.  Pretend an END statement
    680  0491							; was found.
    681  0491							;
    682  0491		       4c 9a 05    iFINv      jmp	iFIN
    683  0494							;
    684  0494		       20 95 0d    iNxtRun2   jsr	getILWord	;ignore next word
    685  0497		       4c ea 02 	      jmp	NextIL
    686  049a							;
    687  049a							;=====================================================
    688  049a							; XFER takes the number on top of the stack and looks
    689  049a							; for that line in the program, or the next line
    690  049a							; higher.  Ie, if it's 1 but there is no line 1, then
    691  049a							; find the next one after that.
    692  049a							;
    693  049a		       20 6f 10    iXFER      jsr	popR0
    694  049d		       20 d4 0d 	      jsr	findLine
    695  04a0		       20 29 0e    iXFER2     jsr	AtEnd	;at end of user program?
    696  04a3		       f0 ec		      beq	iFINv
    697  04a5		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    698  04a7		       84 51		      sty	CUROFF
    699  04a9		       a9 ff		      lda	#$ff
    700  04ab		       85 61		      sta	RunMode
    701  04ad							;
    702  04ad							; Transfer IL to STMT.  I don't like having this
    703  04ad							; hard-coded; fix it.
    704  04ad							;
    705  04ad		       a9 12		      lda	#STMT&$ff
    706  04af		       85 43		      sta	ILPC
    707  04b1		       a9 13		      lda	#STMT>>8
    708  04b3		       85 44		      sta	ILPC+1
    709  04b5		       4c ea 02 	      jmp	NextIL
    710  04b8							;
    711  04b8							; Run
    712  04b8							;
    713  04b8				   iXferok
    714  04b8		       a9 ff		      lda	#$ff
    715  04ba		       85 61		      sta	RunMode	;we're running
    716  04bc							;
    717  04bc							; Need a more elegant way to do this
    718  04bc							;
    719  04bc		       a9 12		      lda	#STMT&$ff
    720  04be		       85 43		      sta	ILPC
    721  04c0		       a9 13		      lda	#STMT>>8
    722  04c2		       85 44		      sta	ILPC+1
    723  04c4		       4c ea 02 	      jmp	NextIL
    724  04c7							;
    725  04c7							;=====================================================
    726  04c7							; Save the pointer to the next line to the call stack.
    727  04c7							;
    728  04c7		       20 0c 10    iSAV       jsr	pushLN
    729  04ca		       b0 03		      bcs	iSAVErr
    730  04cc		       4c ea 02 	      jmp	NextIL
    731  04cf
    732  04cf		       a2 0c	   iSAVErr    ldx	#12
    733  04d1		       a9 00	   iSAVErr2   lda	#0
    734  04d3		       4c b1 05 	      jmp	iErr2
    735  04d6
    736  04d6							;
    737  04d6							;=====================================================
    738  04d6							; Pop the next line from the call stack.
    739  04d6							;
    740  04d6		       20 2f 10    iRET       jsr	popLN
    741  04d9		       b0 f4		      bcs	iSAVErr
    742  04db		       a0 03		      ldy	#3
    743  04dd		       84 51		      sty	CUROFF
    744  04df		       a9 00		      lda	#0
    745  04e1		       8d d8 16 	      sta	IRQPending
    746  04e4		       58		      cli
    747  04e5		       4c ea 02 	      jmp	NextIL
    748  04e8							;
    749  04e8							;=====================================================
    750  04e8							; Return from IL program call
    751  04e8							;
    752  04e8		       20 2f 10    iRSTR      jsr	popLN
    753  04eb		       b0 e2		      bcs	iSAVErr
    754  04ed		       4c ea 02 	      jmp	NextIL
    755  04f0
    756  04f0		       a2 0b	   iRSTRErr   ldx	#11
    757  04f2		       d0 dd		      bne	iSAVErr2
    758  04f4							;
    759  04f4							;=====================================================
    760  04f4							; Compare items on stack.  Okay, so on input there are
    761  04f4							; three things on the stack
    762  04f4							;
    763  04f4							;    EXPR2 <- Top of stack
    764  04f4							;    OP    <- relational operator, next on stack
    765  04f4							;    EXPR1 <- last item on stack
    766  04f4							;
    767  04f4							; Comparison is: EXPR1 <operator> EXPR2
    768  04f4							;
    769  04f4							; Operator is one of...
    770  04f4							;
    771  04f4							;    2 is =
    772  04f4							;    1 is <
    773  04f4							;    3 is <=
    774  04f4							;    5 is <>
    775  04f4							;    4 is >
    776  04f4							;    6 is >=
    777  04f4							;
    778  04f4							; Those are bit-mapped:
    779  04f4							;
    780  04f4							;    xxxxxGEL
    781  04f4							;
    782  04f4							;    G = Greater than
    783  04f4							;    E = Equal
    784  04f4							;    L = Less than
    785  04f4							;
    786  04f4							; If the comparison is false, do a NXT, ie, move to the
    787  04f4							; next line and continue.  If true, continue executing
    788  04f4							; on this line.
    789  04f4							;
    790  04f4		       00 01	   REL_LT     equ	%001
    791  04f4		       00 02	   REL_EQUAL  equ	%010
    792  04f4		       00 04	   REL_GT     equ	%100
    793  04f4							;
    794  04f4		       20 84 10    iCMPR      jsr	popR1
    795  04f7		       20 99 10 	      jsr	popMQ	;operator in MQ
    796  04fa		       20 6f 10 	      jsr	popR0
    797  04fd							;
    798  04fd							; See if they are equal or not
    799  04fd							;
    800  04fd		       a5 52		      lda	R0
    801  04ff		       c5 54		      cmp	R1
    802  0501		       d0 0a		      bne	iCMPRnoteq	;try not equal
    803  0503		       a5 53		      lda	R0+1
    804  0505		       c5 55		      cmp	R1+1
    805  0507		       d0 04		      bne	iCMPRnoteq
    806  0509							;
    807  0509							; Equal, set the flag in MQ+1
    808  0509							;
    809  0509		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    810  050b		       d0 14		      bne	iCMPcom	;Exit it is equal
    811  050d							;
    812  050d							; See if EXPR1 (R0) < EXPR2 (R1)
    813  050d							; See www.6502.org/tutorials/compare_beyond.html
    814  050d							;
    815  050d				   iCMPRnoteq
    816  050d		       a5 52		      lda	R0
    817  050f		       c5 54		      cmp	R1
    818  0511		       a5 53		      lda	R0+1
    819  0513		       e5 55		      sbc	R1+1
    820  0515		       50 02		      bvc	iCMPR_2
    821  0517		       49 80		      eor	#$80
    822  0519		       30 04	   iCMPR_2    bmi	iCMPlt
    823  051b		       a9 04		      lda	#REL_GT
    824  051d		       d0 02		      bne	iCMPcom
    825  051f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    826  0521
    827  0521		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    828  0523							;
    829  0523							; Now compare the end result with what the caller
    830  0523							; was looking for.
    831  0523							;
    832  0523		       25 56		      and	MQ
    833  0525		       f0 0c		      beq	iCMPno	; no match
    834  0527		       a9 ff		      lda	#$FF	; true is $ffff
    835  0529		       85 52		      sta	R0
    836  052b		       85 53		      sta	R0+1
    837  052d		       d0 0c		      bne	iCMPDone
    838  052f							;
    839  052f							; R0 > R1
    840  052f							;
    841  052f		       a9 04	   iCMPgt     lda	#REL_GT
    842  0531		       d0 ee		      bne	iCMPcom
    843  0533				   iCMPno
    844  0533		       a9 00		      lda	#0
    845  0535		       85 52		      sta	R0
    846  0537		       a9 00		      lda	#0
    847  0539		       85 53		      sta	R0+1
    848  053b
    849  053b				   iCMPDone
    850  053b		       20 f7 0f 	      jsr	pushR0
    851  053e		       4c ea 02 	      jmp	NextIL
    852  0541							;
    853  0541							; if Not a match, so jump to the next line of code.
    854  0541							; Branches based upon value on top of the stack
    855  0541				   iBranch
    856  0541		       20 6f 10 	      jsr	popR0
    857  0544		       a5 52		      lda	R0
    858  0546		       05 53		      ora	R0+1
    859  0548		       f0 03		      beq	iBranchFalse	; not true
    860  054a		       4c ea 02 	      jmp	NextIL	; It is true if any value not zero
    861  054d							;
    862  054d				   iBranchFalse
    863  054d		       20 17 0e 	      jsr	FindNextLine
    864  0550		       4c a0 04 	      jmp	iXFER2
    865  0553							;
    866  0553							;=====================================================
    867  0553							; Start a read of data in background
    868  0553				   iReadStart
    869  0553		       a9 3f		      lda	#'?	; Prompt with question mark
    870  0555		       a6 01		      ldx	1	; Indicate to start read in background
    871  0557		       20 19 0f 	      jsr	GetLine	; Call the getline to start read
    872  055a		       4c ea 02 	      jmp	NextIL	; next instruction
    873  055d							;
    874  055d							;=====================================================
    875  055d							; Complete the read and return the curptr, curoff pointing to data
    876  055d				   iReadComplete
    877  055d		       20 0c 10 	      jsr	pushLN
    878  0560		       20 39 0f 	      jsr	ReadComplete
    879  0563		       4c ea 02 	      jmp	NextIL
    880  0566		       20 2f 10 	      jsr	popLN
    881  0569		       4c ea 02 	      jmp	NextIL
    882  056c							;=====================================================
    883  056c							; Get a line of text from the user, convert to a
    884  056c							; number, leave on top of stack.
    885  056c							;
    886  056c				   iINNUM
    887  056c		       20 0c 10 	      jsr	pushLN
    888  056f							;
    889  056f		       a9 3f		      lda	#'?
    890  0571		       a2 00		      ldx	#0	;Wait for complete
    891  0573		       20 19 0f 	      jsr	GetLine
    892  0576		       20 a2 0e 	      jsr	getDecimal
    893  0579		       20 f7 0f 	      jsr	pushR0	;put onto stack
    894  057c							;
    895  057c		       4c 94 05 	      jmp	ExitIn
    896  057f							;
    897  057f							;=====================================================
    898  057f							; Get a line of text from the user, convert to a
    899  057f							; character value , leave on top of stack. up to 2 characters
    900  057f							;
    901  057f				   iINSTR
    902  057f		       20 0c 10 	      jsr	pushLN
    903  0582		       a9 3f		      lda	#'?
    904  0584		       a2 00		      ldx	#0	;wait for read complete
    905  0586		       20 19 0f 	      jsr	GetLine
    906  0589		       b1 4f		      lda	(CURPTR),y
    907  058b		       85 52		      sta	R0
    908  058d		       a9 00		      lda	#0
    909  058f		       85 53		      sta	R0+1
    910  0591		       20 f7 0f 	      jsr	pushR0	;put onto stack
    911  0594				   ExitIn
    912  0594		       20 2f 10 	      jsr	popLN
    913  0597		       4c ea 02 	      jmp	NextIL
    914  059a							;
    915  059a							;
    916  059a							;=====================================================
    917  059a							; Stop the currently running program.	Actually very
    918  059a							; simple to do... clear the RunMode flag, then set the
    919  059a							; ILPC to the standard handler and continue running.
    920  059a							;
    921  059a		       a9 00	   iFIN       lda	#0
    922  059c		       85 61		      sta	RunMode
    923  059e		       20 f4 0b 	      jsr	taskReset
    924  05a1							;
    925  05a1		       ad 25 1f 	      lda	errGoto
    926  05a4		       85 43		      sta	ILPC
    927  05a6		       ad 26 1f 	      lda	errGoto+1
    928  05a9		       85 44		      sta	ILPC+1
    929  05ab		       4c ea 02 	      jmp	NextIL
    930  05ae							;
    931  05ae							;=====================================================
    932  05ae							; Handle the ERR opcode.  Following the instruction is
    933  05ae							; a 16 bit error number.  Print an error message, and
    934  05ae							; if we're in run mode, print the line number.  Stop
    935  05ae							; program execution and return to the initial state.
    936  05ae							;
    937  05ae		       20 95 0d    iERR       jsr	getILWord	;get err code
    938  05b1							;
    939  05b1							; Enter here with the error code in X (LSB) and A (MSB).
    940  05b1							;
    941  05b1		       86 52	   iErr2      stx	R0
    942  05b3		       85 53		      sta	R0+1
    943  05b5							;
    944  05b5		       20 12 f0 	      jsr	puts
      0  05b8					      db	CR,LF,"Error ",0
      1  05b8		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    946  05c1		       20 36 0e 	      jsr	PrintDecimal
    947  05c4							;
    948  05c4		       a5 61		      lda	RunMode	;running?
    949  05c6		       f0 3b		      beq	iERR3	;nope
    950  05c8		       20 12 f0 	      jsr	puts
      0  05cb					      db	" at line ",0
      1  05cb		       20 61 74 20*	      .byte.b	" at line ",0
    952  05d5		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    953  05d7				   iErr2a
    954  05d7		       b1 4f		      lda	(CURPTR),y
    955  05d9		       85 52		      sta	R0
    956  05db		       c8		      iny
    957  05dc		       b1 4f		      lda	(CURPTR),y
    958  05de		       85 53		      sta	R0+1
    959  05e0		       20 36 0e 	      jsr	PrintDecimal
    960  05e3		       20 12 f0 	      jsr	puts
      0  05e6					      db	":",0
      1  05e6		       3a 00		      .byte.b	":",0
    962  05e8		       a9 00		      lda	#0
    963  05ea		       85 53		      sta	R0+1
    964  05ec		       a5 51		      lda	CUROFF
    965  05ee		       18		      clc
    966  05ef		       e9 03		      sbc	#3
    967  05f1		       85 52		      sta	R0
    968  05f3		       20 36 0e 	      jsr	PrintDecimal
    969  05f6		       20 12 f0 	      jsr	puts
      0  05f9					      db	":",0
      1  05f9		       3a 00		      .byte.b	":",0
    971  05fb		       ad db 16 	      lda	taskPtr
    972  05fe		       85 52		      sta	R0
    973  0600		       20 36 0e 	      jsr	PrintDecimal
    974  0603							;
    975  0603		       20 0c 02    iERR3      jsr	CRLF
    976  0606		       a9 00		      lda	#0
    977  0608		       85 61		      sta	RunMode	;fall through...
    978  060a							;
    979  060a							;=====================================================
    980  060a							; Reset the IL to be back at the idle loop.  Does not
    981  060a							; clear variables so the user can see what state
    982  060a							; the program is in.
    983  060a							;
    984  060a		       a9 00	   ResetIL    lda	#0
    985  060c		       85 47		      sta	ILSTACKPTR
    986  060e		       ad 25 1f 	      lda	errGoto
    987  0611		       85 43		      sta	ILPC
    988  0613		       ad 26 1f 	      lda	errGoto+1
    989  0616		       85 44		      sta	ILPC+1
    990  0618		       4c ea 02 	      jmp	NextIL
    991  061b
    992  061b							;
    993  061b							;=====================================================
    994  061b							; Pop two items off stack, add them, then place the
    995  061b							; result back onto the stack.
    996  061b							;
    997  061b		       20 6f 10    iADD       jsr	popR0
    998  061e		       20 84 10 	      jsr	popR1
    999  0621		       18		      clc
   1000  0622		       a5 52		      lda	R0
   1001  0624		       65 54		      adc	R1
   1002  0626		       85 52		      sta	R0
   1003  0628		       a5 53		      lda	R0+1
   1004  062a		       65 55		      adc	R1+1
   1005  062c		       85 53		      sta	R0+1
   1006  062e		       4c 99 06 	      jmp	pushR0nextIl
   1007  0631							;
   1008  0631							;=====================================================
   1009  0631							; Pop two items off the stack.  Subtract the top of
   1010  0631							; stack from the lower entry.
   1011  0631							;
   1012  0631		       20 84 10    iSUB       jsr	popR1
   1013  0634		       20 6f 10 	      jsr	popR0
   1014  0637		       38		      sec
   1015  0638		       a5 52		      lda	R0
   1016  063a		       e5 54		      sbc	R1
   1017  063c		       85 52		      sta	R0
   1018  063e		       a5 53		      lda	R0+1
   1019  0640		       e5 55		      sbc	R1+1
   1020  0642		       85 53		      sta	R0+1
   1021  0644		       4c 99 06 	      jmp	pushR0nextIl
   1022  0647							;
   1023  0647							;=====================================================
   1024  0647							; Negate the top of stack.
   1025  0647							;
   1026  0647		       20 6f 10    iNEG       jsr	popR0
   1027  064a		       a5 52		      lda	R0
   1028  064c		       49 ff		      eor	#$ff
   1029  064e		       85 52		      sta	R0
   1030  0650		       a5 53		      lda	R0+1
   1031  0652		       49 ff		      eor	#$ff
   1032  0654		       85 53		      sta	R0+1
   1033  0656		       e6 52		      inc	R0
   1034  0658		       d0 02		      bne	iNEG2
   1035  065a		       e6 53		      inc	R0+1
   1036  065c		       4c 99 06    iNEG2      jmp	pushR0nextIl
   1037  065f							;
   1038  065f							;=====================================================
   1039  065f							; Multiply top two items on the stack, put the results
   1040  065f							; on top.  This uses the algorithm documented on page
   1041  065f							; 115 of "Microprocessor Programming for Computer
   1042  065f							; Hobbyists" by Neill Graham.
   1043  065f							;
   1044  065f		       20 65 06    iMUL       jsr	iMultiply
   1045  0662		       4c ea 02 	      jmp	NextIL
   1046  0665
   1047  0665				   iMultiply
   1048  0665		       20 6f 10 	      jsr	popR0	;AC
   1049  0668		       20 84 10 	      jsr	popR1	;OP
   1050  066b							;
   1051  066b		       a5 52		      lda	R0
   1052  066d		       85 56		      sta	MQ
   1053  066f		       a5 53		      lda	R0+1
   1054  0671		       85 57		      sta	MQ+1
   1055  0673		       a9 00		      lda	#0	;clear result
   1056  0675		       85 52		      sta	R0
   1057  0677		       85 53		      sta	R0+1
   1058  0679							;
   1059  0679		       a2 10		      ldx	#16	;number of bits in value
   1060  067b		       06 52	   multloop   asl	R0
   1061  067d		       26 53		      rol	R0+1
   1062  067f		       06 56		      asl	MQ
   1063  0681		       26 57		      rol	MQ+1
   1064  0683		       90 0d		      bcc	multno	;skip add if no carry
   1065  0685							;
   1066  0685							; Add R1 back into R0
   1067  0685							;
   1068  0685		       18		      clc
   1069  0686		       a5 52		      lda	R0
   1070  0688		       65 54		      adc	R1
   1071  068a		       85 52		      sta	R0
   1072  068c		       a5 53		      lda	R0+1
   1073  068e		       65 55		      adc	R1+1
   1074  0690		       85 53		      sta	R0+1
   1075  0692							;
   1076  0692		       ca	   multno     dex		;did all bits yet?
   1077  0693		       d0 e6		      bne	multloop
   1078  0695		       20 f7 0f 	      jsr	pushR0	;OP
   1079  0698		       60		      rts
   1080  0699							;
   1081  0699				   pushR0nextIl
   1082  0699		       20 f7 0f 	      jsr	pushR0	;OP
   1083  069c		       4c ea 02 	      jmp	NextIL
   1084  069f							;
   1085  069f							;=====================================================
   1086  069f							; Divide the top of stack into the next to top item.
   1087  069f							; Leave results on stack.  Taken from:
   1088  069f							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1089  069f							;
   1090  069f							; R0 = R0 / R1
   1091  069f							; Remainder is in MQ
   1092  069f							;
   1093  069f		       20 b9 06    iDIV       jsr	iDoDiv
   1094  06a2		       20 e9 10 	      jsr	RestoreSigns
   1095  06a5		       4c 99 06 	      jmp	pushR0nextIl
   1096  06a8
   1097  06a8		       20 b9 06    iMOD       jsr	iDoDiv
   1098  06ab		       20 e9 10 	      jsr	RestoreSigns
   1099  06ae		       a5 56		      lda	MQ
   1100  06b0		       85 52		      sta	R0
   1101  06b2		       a5 57		      lda	MQ+1
   1102  06b4		       85 53		      sta	R0+1
   1103  06b6		       4c 99 06 	      jmp	pushR0nextIl
   1104  06b9
   1105  06b9				   iDoDiv
   1106  06b9		       20 84 10 	      jsr	popR1
   1107  06bc		       20 6f 10 	      jsr	popR0
   1108  06bf							;
   1109  06bf							; Check for divide by zero
   1110  06bf							;
   1111  06bf
   1112  06bf				   iDivNoPop
   1113  06bf		       a5 54		      lda	R1
   1114  06c1		       05 55		      ora	R1+1
   1115  06c3		       f0 29		      beq	divby0
   1116  06c5							;
   1117  06c5		       20 ae 10 	      jsr	SaveSigns
   1118  06c8		       a9 00		      lda	#0	;preset remainder to 0
   1119  06ca		       85 56		      sta	MQ
   1120  06cc		       85 57		      sta	MQ+1
   1121  06ce		       a2 10		      ldx	#16	;repeat for each bit: ...
   1122  06d0				   divloop
   1123  06d0		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1124  06d2		       26 53		      rol	R0+1
   1125  06d4		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1126  06d6		       26 57		      rol	MQ+1
   1127  06d8		       a5 56		      lda	MQ
   1128  06da		       38		      sec
   1129  06db		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1130  06dd		       a8		      tay		;lb result -> Y, for we may need it later
   1131  06de		       a5 57		      lda	MQ+1
   1132  06e0		       e5 55		      sbc	R1+1
   1133  06e2		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1134  06e4
   1135  06e4		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1136  06e6		       84 56		      sty	MQ
   1137  06e8		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1138  06ea
   1139  06ea		       ca	   skip       dex
   1140  06eb		       d0 e3		      bne	divloop
   1141  06ed		       60		      rts
   1142  06ee							;
   1143  06ee							; Indicate divide-by-zero error
   1144  06ee							;
   1145  06ee		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1146  06f0		       a9 00		      lda	#0
   1147  06f2		       4c b1 05 	      jmp	iErr2
   1148  06f5							;
   1149  06f5							;=====================================================
   1150  06f5							; This pops the top two items off the stack.  The top
   1151  06f5							; item is a data value and the other is an index into
   1152  06f5							; the variable table.	Save the value into that entry.
   1153  06f5							;
   1154  06f5		       20 6f 10    iSTORE     jsr	popR0	;data
   1155  06f8		       20 84 10 	      jsr	popR1	;index
   1156  06fb		       98		      tya
   1157  06fc		       48		      pha
   1158  06fd		       a4 54		      ldy	R1	;get index
   1159  06ff		       a5 52		      lda	R0
   1160  0701		       91 41		      sta	(VARIABLES),y
   1161  0703		       a5 53		      lda	R0+1
   1162  0705		       c8		      iny
   1163  0706		       91 41		      sta	(VARIABLES),y
   1164  0708		       68		      pla
   1165  0709		       a8		      tay
   1166  070a		       4c ea 02 	      jmp	NextIL
   1167  070d							;
   1168  070d							;=====================================================
   1169  070d							; Replaces the top of stack with the variable whose
   1170  070d							; index it represents.
   1171  070d							;
   1172  070d				   iIND
   1173  070d		       20 84 10 	      jsr	popR1
   1174  0710		       98		      tya
   1175  0711		       48		      pha
   1176  0712		       a4 54		      ldy	R1	;get index
   1177  0714		       b1 41		      lda	(VARIABLES),y
   1178  0716		       85 52		      sta	R0
   1179  0718		       c8		      iny
   1180  0719		       b1 41		      lda	(VARIABLES),y
   1181  071b		       85 53		      sta	R0+1
   1182  071d		       68		      pla
   1183  071e		       a8		      tay
   1184  071f		       4c 99 06 	      jmp	pushR0nextIl
   1185  0722							;
   1186  0722							;=====================================================
   1187  0722							; Get the array index from top of stack get Current variable
   1188  0722							; index from next on stack, add the offset
   1189  0722							; push the result back onto the stack
   1190  0722				   iArray
   1191  0722		       20 6f 10 	      jsr	popR0	; Get the array index
   1192  0725		       20 84 10 	      jsr	popR1	; Get the Variable number
   1193  0728		       a5 52		      lda	R0	; Verify that it is not zero
   1194  072a		       05 53		      ora	R0+1
   1195  072c		       f0 15		      beq	iArrayError	; index must not be zero
   1196  072e		       c6 52		      dec	R0	; Basic array index starts at 1
   1197  0730		       a5 52		      lda	R0	; Get the Variable index
   1198  0732		       18		      clc
   1199  0733		       2a		      rol
   1200  0734		       65 54		      adc	R1
   1201  0736		       c9 34		      cmp	#(variablesEnd)
   1202  0738		       b0 09		      bcs	iArrayError
   1203  073a		       85 52		      sta	R0
   1204  073c		       a5 53		      lda	R0+1
   1205  073e		       d0 03		      bne	iArrayError	; Error if the Value is > than last Var index
   1206  0740		       4c 99 06 	      jmp	pushR0nextIl
   1207  0743							; Get here if array index is out of range
   1208  0743				   iArrayError
   1209  0743		       a9 00		      lda	#0
   1210  0745		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1211  0747		       4c b1 05 	      jmp	iErr2
   1212  074a							;
   1213  074a							;=====================================================
   1214  074a							; List the current BASIC program in memory.  Uses R0,
   1215  074a							; tempIly, and dpl.
   1216  074a							;
   1217  074a		       20 99 11    iLST       jsr	SetOutConsole
   1218  074d		       a9 37	   iLST2      lda	#ProgramStart&$ff
   1219  074f		       85 58		      sta	dpl
   1220  0751		       a9 1f		      lda	#ProgramStart>>8
   1221  0753		       85 59		      sta	dpl+1
   1222  0755							;
   1223  0755							; dpl/dph point to the current line.  See if we're at
   1224  0755							; the end of the program.
   1225  0755							;
   1226  0755		       a5 58	   iLSTloop   lda	dpl
   1227  0757		       cd 2f 1f 	      cmp	PROGRAMEND
   1228  075a		       d0 07		      bne	iLstNotEnd
   1229  075c		       a5 59		      lda	dpl+1
   1230  075e		       cd 30 1f 	      cmp	PROGRAMEND+1
   1231  0761		       f0 40		      beq	iLstdone
   1232  0763							;
   1233  0763		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1234  0765		       b1 58		      lda	(dpl),y	;line number LSB
   1235  0767		       85 52		      sta	R0
   1236  0769		       c8		      iny
   1237  076a		       b1 58		      lda	(dpl),y	;line number MSB
   1238  076c		       85 53		      sta	R0+1
   1239  076e		       c8		      iny
   1240  076f		       84 5c		      sty	tempIlY
   1241  0771		       20 36 0e 	      jsr	PrintDecimal
   1242  0774		       a9 20		      lda	#SPACE
   1243  0776		       20 a4 11 	      jsr	VOUTCH
   1244  0779		       a4 5c		      ldy	tempIlY
   1245  077b		       b1 58	   iLSTl2     lda	(dpl),y
   1246  077d		       f0 0a		      beq	iLST3	;end of this line 0 value
   1247  077f		       84 5c		      sty	tempIlY
   1248  0781		       20 a4 11 	      jsr	VOUTCH
   1249  0784		       a4 5c		      ldy	tempIlY
   1250  0786		       c8		      iny
   1251  0787		       d0 f2		      bne	iLSTl2	;do next char
   1252  0789							;
   1253  0789							; End of this line.  Print CR/LF, then move to the
   1254  0789							; next line.
   1255  0789							;
   1256  0789		       c8	   iLST3      iny		;Move to next line
   1257  078a		       18		      clc		;Clear the carry flag
   1258  078b		       98		      tya		;Current Offset
   1259  078c		       65 58		      adc	dpl	;Add the offset to the pointer
   1260  078e		       85 58		      sta	dpl	;Save the new value
   1261  0790		       a5 59		      lda	dpl+1	;Next byte
   1262  0792		       69 00		      adc	#0	;ad in the carry if any
   1263  0794		       85 59		      sta	dpl+1	;Save it
   1264  0796							;
   1265  0796							; Have to manually do CR/LF so it uses the vectored
   1266  0796							; output function.
   1267  0796							;
   1268  0796		       a9 0d		      lda	#CR
   1269  0798		       20 a4 11 	      jsr	VOUTCH
   1270  079b		       a9 0a		      lda	#LF
   1271  079d		       20 a4 11 	      jsr	VOUTCH
   1272  07a0		       4c 55 07 	      jmp	iLSTloop	;do next line
   1273  07a3							;
   1274  07a3		       20 99 11    iLstdone   jsr	SetOutConsole
   1275  07a6		       4c ea 02 	      jmp	NextIL
   1276  07a9							;
   1277  07a9							;=====================================================
   1278  07a9							; Get a line of text into LINBUF.  Terminate with a
   1279  07a9							; null byte.
   1280  07a9							;
   1281  07a9				   iGETLINE
   1282  07a9		       a9 3e		      lda	#'>	;prompt character
   1283  07ab		       a6 00		      ldx	0	;Wait for read to complete
   1284  07ad		       20 19 0f 	      jsr	GetLine
   1285  07b0							;
   1286  07b0		       a9 00		      lda	#0
   1287  07b2		       85 61		      sta	RunMode
   1288  07b4		       4c ea 02 	      jmp	NextIL
   1289  07b7							;
   1290  07b7							;=====================================================
   1291  07b7							; This is called when the input buffer contains a line
   1292  07b7							; typed in by the user that starts with a line number.
   1293  07b7							; Insert the line into the program or delete the line
   1294  07b7							; if there is nothing after the line number,
   1295  07b7							;
   1296  07b7		       a0 00	   iINSRT     ldy	#0
   1297  07b9		       20 a2 0e 	      jsr	getDecimal	;convert line #
   1298  07bc		       20 18 11 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1299  07bf		       84 5d		      sty	offset	;Save the start of the program line text
   1300  07c1							;
   1301  07c1							; Now find the line OR the next higher line OR the
   1302  07c1							; end of the program.
   1303  07c1							;
   1304  07c1		       20 d4 0d 	      jsr	findLine	; Look for the line number in the current program
   1305  07c4							; Returns Z and curptr point to the line if found
   1306  07c4							; Returns C and curptr at next higher line if not found and there is a higher line
   1307  07c4							; Returns ZC clear and curptr to end of program if higher than all other lines
   1308  07c4							;
   1309  07c4							; If the line exists, it needs to be removed.
   1310  07c4							;
   1311  07c4		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1312  07c6							;
   1313  07c6							; Get length of line to be removed, we fall thru to here if we find a matching line
   1314  07c6							;
   1315  07c6							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1316  07c6		       a0 00		      ldy	#0
   1317  07c8		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1318  07ca		       a8		      tay
   1319  07cb							;If it is equal we delete the line and replace it, get length
   1320  07cb							;then adjust all program line after up or down depending on len of line
   1321  07cb							;If next higher then just move everythimg down by length bytes
   1322  07cb							;This call will return how many bytes in the line we found
   1323  07cb		       84 5e		      sty	lineLength	;Save the length of the line we found
   1324  07cd							;
   1325  07cd							; Compute the new end of the program first.
   1326  07cd							;
   1327  07cd		       38		      sec		;Set the carry bit
   1328  07ce		       ad 2f 1f 	      lda	PROGRAMEND	;Get low byte of program end
   1329  07d1		       e5 5e		      sbc	lineLength	;Subtract the length of the current line
   1330  07d3		       8d 2f 1f 	      sta	PROGRAMEND	;save it
   1331  07d6		       ad 30 1f 	      lda	PROGRAMEND+1
   1332  07d9		       e9 00		      sbc	#0	;Process the carry
   1333  07db		       8d 30 1f 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1334  07de							;
   1335  07de							; Copy CURPTR into R1 for working
   1336  07de							;
   1337  07de		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1338  07e0		       85 54		      sta	R1
   1339  07e2		       a5 50		      lda	CURPTR+1
   1340  07e4		       85 55		      sta	R1+1
   1341  07e6							;
   1342  07e6							; See if we're at the end.
   1343  07e6							;
   1344  07e6		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1345  07e8		       cd 2f 1f 	      cmp	PROGRAMEND
   1346  07eb		       d0 07		      bne	InsDelLoop
   1347  07ed		       a5 55		      lda	R1+1
   1348  07ef		       cd 30 1f 	      cmp	PROGRAMEND+1
   1349  07f2		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1350  07f4							;
   1351  07f4							; Move one byte, move to next location.
   1352  07f4							;
   1353  07f4		       a4 5e	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1354  07f6		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1355  07f8		       b1 54		      lda	(R1),y
   1356  07fa		       a0 00		      ldy	#0
   1357  07fc		       91 54		      sta	(R1),y
   1358  07fe		       e6 54		      inc	R1
   1359  0800		       d0 e4		      bne	InsDelChk
   1360  0802		       e6 55		      inc	R1+1
   1361  0804		       4c e6 07 	      jmp	InsDelChk	; Check if we have moved the last byte
   1362  0807							;
   1363  0807							; Deletion is done.
   1364  0807							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1365  0807							;
   1366  0807		       a4 5d	   insert2    ldy	offset	;get back ptr	Get the current offset
   1367  0809		       b9 9b 1e 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1368  080c		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1369  080e							;
   1370  080e							; CURPTR points to where the line will be inserted.
   1371  080e							;
   1372  080e		       20 d3 0f 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1373  0811							;
   1374  0811		       ad 2f 1f 	      lda	PROGRAMEND	;Load the start address for the copy
   1375  0814							;At this point curptr still contains the location we will insert data
   1376  0814		       85 62		      sta	FROM
   1377  0816		       ad 30 1f 	      lda	PROGRAMEND+1
   1378  0819		       85 63		      sta	FROM+1
   1379  081b							;
   1380  081b		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1381  081d		       b1 62		      lda	(FROM),y
   1382  081f		       a4 5e		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1383  0821		       91 62		      sta	(FROM),y	;Save the new byte
   1384  0823							;
   1385  0823		       a5 62		      lda	FROM	;Check if we have copies the last byte
   1386  0825		       c5 4f		      cmp	CURPTR
   1387  0827		       d0 06		      bne	mvUpMore
   1388  0829		       a5 63		      lda	FROM+1
   1389  082b		       c5 50		      cmp	CURPTR+1
   1390  082d		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1391  082f							;
   1392  082f							; Not done yet
   1393  082f							;
   1394  082f		       a5 62	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1395  0831		       d0 02		      bne	mvUpMore2
   1396  0833		       c6 63		      dec	FROM+1
   1397  0835		       c6 62	   mvUpMore2  dec	FROM
   1398  0837		       4c 1b 08 	      jmp	mvup1	;Loop until everything is moved
   1399  083a							;
   1400  083a							; All done with copy.
   1401  083a							;
   1402  083a		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1403  083b		       a5 5e		      lda	lineLength	;Number of bytes to copy from line buff
   1404  083d		       6d 2f 1f 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1405  0840		       8d 2f 1f 	      sta	PROGRAMEND
   1406  0843		       ad 30 1f 	      lda	PROGRAMEND+1
   1407  0846		       69 00		      adc	#0
   1408  0848		       8d 30 1f 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1409  084b							;
   1410  084b							;===================jlit use length before line newline
   1411  084b
   1412  084b		       a0 00		      ldy	#0	;Set offset of copy
   1413  084d		       a5 5e		      lda	lineLength	;We will insert the actual length of the line first
   1414  084f		       91 4f		      sta	(CURPTR),y	;Store the length
   1415  0851		       c8		      iny
   1416  0852		       a5 52		      lda	R0	;Store the line number next
   1417  0854		       91 4f		      sta	(CURPTR),y
   1418  0856		       c8		      iny
   1419  0857		       a5 53		      lda	R0+1
   1420  0859		       91 4f		      sta	(CURPTR),y
   1421  085b		       c8		      iny
   1422  085c							;
   1423  085c		       a6 5d		      ldx	offset	;Load the offset into line buffer in page zero
   1424  085e		       bd 9b 1e    mvUpLoop2  lda	LINBUF,x	;get a byte
   1425  0861		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1426  0863		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1427  0865		       e8		      inx
   1428  0866		       c8		      iny
   1429  0867		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1430  0869							;
   1431  0869		       4c ea 02    mvUpFini   jmp	NextIL
   1432  086c							;
   1433  086c							;=====================================================
   1434  086c							; Pops the top value of the ILPC stack and stores it
   1435  086c							; in ILPC.  Ie, return from an IL subroutine.
   1436  086c							;
   1437  086c		       20 c5 0d    iRTN       jsr	popILPC
   1438  086f		       4c ea 02 	      jmp	NextIL
   1439  0872							;
   1440  0872							;=====================================================
   1441  0872							; NLINE print a newline
   1442  0872							;
   1443  0872		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1444  0875		       4c ea 02 	      jmp	NextIL
   1445  0878							;
   1446  0878							;=====================================================
   1447  0878							; This saves the current ILPC value on the stack, then
   1448  0878							; jumps to the address specified by the next two bytes.
   1449  0878							;
   1450  0878		       20 af 0d    iCALL      jsr	pushILPC	;save ILPC
   1451  087b							;
   1452  087b							; Jmp to a specific location in the IL code.  The new
   1453  087b							; address immediately follows the opcode.
   1454  087b							;
   1455  087b		       20 95 0d    iJMP       jsr	getILWord
   1456  087e		       86 43		      stx	ILPC
   1457  0880		       85 44		      sta	ILPC+1
   1458  0882		       4c ea 02 	      jmp	NextIL
   1459  0885							;
   1460  0885							;=====================================================
   1461  0885							; Push the next two bytes onto the arithmetic stack.
   1462  0885							;
   1463  0885		       20 95 0d    iLIT       jsr	getILWord
   1464  0888		       86 52		      stx	R0
   1465  088a		       85 53		      sta	R0+1
   1466  088c		       20 f7 0f 	      jsr	pushR0
   1467  088f		       4c ea 02 	      jmp	NextIL
   1468  0892							;
   1469  0892							;=====================================================
   1470  0892							; Initialize all variables for a single task.	Ie, set to zero.
   1471  0892							;
   1472  0892		       98	   subVINIT   tya
   1473  0893		       48		      pha
   1474  0894
   1475  0894		       a9 00		      lda	#0
   1476  0896		       a0 00		      ldy	#0
   1477  0898		       91 41	   Vinit2     sta	(VARIABLES),y
   1478  089a		       c8		      iny
   1479  089b		       c0 34		      cpy	#variablesEnd
   1480  089d		       90 f9		      bcc	Vinit2
   1481  089f		       68		      pla
   1482  08a0		       a8		      tay
   1483  08a1		       60		      rts
   1484  08a2
   1485  08a2		       20 92 08    iVINIT     jsr	subVINIT
   1486  08a5		       4c ea 02 	      jmp	NextIL
   1487  08a8							;
   1488  08a8							;=====================================================
   1489  08a8							; Set the address of the error handler.  After any
   1490  08a8							; error, set to the ILPC to the specified location.
   1491  08a8							;
   1492  08a8		       20 95 0d    iERRGOTO   jsr	getILWord
   1493  08ab		       8e 25 1f 	      stx	errGoto
   1494  08ae		       8d 26 1f 	      sta	errGoto+1
   1495  08b1		       4c ea 02 	      jmp	NextIL
   1496  08b4							;
   1497  08b4							;=====================================================
   1498  08b4							; TST is followed by an 8 bit signed offset, then a
   1499  08b4							; null terminated string.  Compare the string against
   1500  08b4							; the string starting at (CURPTR),CUROFF.  If the
   1501  08b4							; strings match, continue executing the next IL
   1502  08b4							; opcode.  Else, add the offset to ILPC.
   1503  08b4							;
   1504  08b4		       20 99 0d    iTST       jsr	getILByte
   1505  08b7		       85 5d		      sta	offset
   1506  08b9							;
   1507  08b9		       20 e5 0f 	      jsr	saveIL	;in case of failure
   1508  08bc		       a4 51		      ldy	CUROFF
   1509  08be		       84 58		      sty	dpl	;save for later
   1510  08c0							;
   1511  08c0		       20 99 0d    iTSTloop   jsr	getILByte	;get next char
   1512  08c3		       f0 11		      beq	iTSTm	;match!
   1513  08c5		       a4 58		      ldy	dpl
   1514  08c7		       d1 4f		      cmp	(CURPTR),y
   1515  08c9		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1516  08cb		       09 20		      ora	#$20	; lets allow lowercase as well
   1517  08cd		       d1 4f		      cmp	(CURPTR),y
   1518  08cf		       d0 22		      bne	iTSTfail	;mismatch
   1519  08d1		       c8	   iTSTUpper  iny
   1520  08d2		       84 58		      sty	dpl
   1521  08d4		       d0 ea		      bne	iTSTloop
   1522  08d6							;
   1523  08d6							; It's a match!  Clean up a bit.
   1524  08d6							;
   1525  08d6		       a4 58	   iTSTm      ldy	dpl
   1526  08d8		       84 51		      sty	CUROFF
   1527  08da		       4c ea 02 	      jmp	NextIL
   1528  08dd							; Test for a single quote
   1529  08dd		       20 99 0d    iTSTStr    jsr	getILByte
   1530  08e0		       85 5d		      sta	offset
   1531  08e2		       20 e5 0f 	      jsr	saveIL
   1532  08e5		       a4 51		      ldy	CUROFF
   1533  08e7		       a9 22		      lda	#'"
   1534  08e9		       d1 4f		      cmp	(CURPTR),y
   1535  08eb		       d0 06		      bne	iTSTfail
   1536  08ed		       c8		      iny
   1537  08ee		       84 51		      sty	CUROFF
   1538  08f0		       4c 0b 03 	      jmp	NextILStr
   1539  08f3							;
   1540  08f3							; Not a match, reset ILPC and then move to the
   1541  08f3							; offset.
   1542  08f3							;
   1543  08f3		       20 ee 0f    iTSTfail   jsr	restoreIL
   1544  08f6		       4c a4 09 	      jmp	tstBranch
   1545  08f9							;
   1546  08f9							;=================================================JLIT=
   1547  08f9							; Test if we have a let statement without the let keyword
   1548  08f9		       20 99 0d    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1549  08fc		       85 5d		      sta	offset	; Save the jump offset for fails
   1550  08fe		       20 e5 0f 	      jsr	saveIL	; save to restore when done
   1551  0901		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1552  0903		       20 18 11 	      jsr	SkipSpaces	; move to first element on line
   1553  0906		       84 51		      sty	CUROFF	; Just remember skipped spaces
   1554  0908		       c8		      iny		; skip the Variable name
   1555  0909		       20 18 11 	      jsr	SkipSpaces	; skip any SkipSpaces
   1556  090c		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1557  090e		       c9 3d		      cmp	#'=	; check if equals
   1558  0910		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1559  0912		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1560  0914		       d0 dd		      bne	iTSTfail	; return it failed
   1561  0916		       20 ee 0f    iTSTLETGOOD jsr	restoreIL	; restore the IL anyway
   1562  0919		       4c ea 02 	      jmp	NextIL	; Then next instruction
   1563  091c
   1564  091c							;================================================jLIT=
   1565  091c							;Test for end of line
   1566  091c							;
   1567  091c		       20 99 0d    iTSTDONE   jsr	getILByte
   1568  091f		       85 5d		      sta	offset
   1569  0921		       20 e5 0f 	      jsr	saveIL
   1570  0924		       a4 51		      ldy	CUROFF
   1571  0926		       84 58		      sty	dpl
   1572  0928		       20 18 11 	      jsr	SkipSpaces
   1573  092b		       b1 4f		      lda	(CURPTR),y
   1574  092d		       f0 0b		      beq	iTSTDONEtrue
   1575  092f		       c9 3a		      cmp	#COLON
   1576  0931		       f0 07		      beq	iTSTDONEtrue
   1577  0933		       a4 58		      ldy	dpl
   1578  0935		       84 51		      sty	CUROFF
   1579  0937		       4c f3 08 	      jmp	iTSTfail
   1580  093a							;
   1581  093a							; Advance to the next line
   1582  093a							;
   1583  093a				   iTSTDONEtrue
   1584  093a		       4c ea 02 	      jmp	NextIL
   1585  093d							;
   1586  093d							;=====================================================
   1587  093d							; TSTV is followed by an 8 bit signed offset.	If the
   1588  093d							; value at (CURPTR),CUROFF appears to be a variable
   1589  093d							; name, move to the next IL statement.  Else, add the
   1590  093d							; offset to ILPC.
   1591  093d							;
   1592  093d		       20 99 0d    iTSTV      jsr	getILByte	;offset
   1593  0940		       85 5d		      sta	offset
   1594  0942							;
   1595  0942		       a4 51		      ldy	CUROFF
   1596  0944		       20 18 11 	      jsr	SkipSpaces
   1597  0947		       b1 4f		      lda	(CURPTR),y
   1598  0949							;
   1599  0949		       09 20		      ora	#$20	;make lower then upper
   1600  094b		       49 20		      eor	#$20	;allow lower case here
   1601  094d		       c9 41		      cmp	#'A
   1602  094f		       90 53		      bcc	tstBranch
   1603  0951		       c9 5b		      cmp	#'Z+1
   1604  0953		       b0 4f		      bcs	tstBranch
   1605  0955							;
   1606  0955							; The condition is true, so convert to an index, push
   1607  0955							; it onto the stack and continue running.
   1608  0955							;
   1609  0955		       38		      sec
   1610  0956		       e9 41		      sbc	#'A	;index is zero based
   1611  0958		       0a		      asl		;multiply by two
   1612  0959		       85 52		      sta	R0
   1613  095b		       a9 00		      lda	#0
   1614  095d		       85 53		      sta	R0+1
   1615  095f		       20 f7 0f 	      jsr	pushR0	;put index onto stack
   1616  0962		       e6 51		      inc	CUROFF	;move to next input char
   1617  0964		       4c ea 02 	      jmp	NextIL
   1618  0967							;
   1619  0967							;=====================================================
   1620  0967							; TSTL seems basically the same as TSTN, but leave the
   1621  0967							; value in R0 instead of pushing onto stack.
   1622  0967							; This tests for a valid line number
   1623  0967							;
   1624  0967		       20 99 0d    iTSTL      jsr	getILByte
   1625  096a		       85 5d		      sta	offset
   1626  096c							;
   1627  096c		       a4 51		      ldy	CUROFF
   1628  096e		       20 18 11 	      jsr	SkipSpaces
   1629  0971		       b1 4f		      lda	(CURPTR),y
   1630  0973							;
   1631  0973		       c9 30		      cmp	#'0
   1632  0975		       90 2d		      bcc	tstBranch
   1633  0977		       c9 3a		      cmp	#'9+1
   1634  0979		       b0 29		      bcs	tstBranch
   1635  097b							;
   1636  097b							; It's a digit, so convert to a number.
   1637  097b							;
   1638  097b		       20 a2 0e 	      jsr	getDecimal
   1639  097e		       4c ea 02 	      jmp	NextIL
   1640  0981							;
   1641  0981							;=====================================================
   1642  0981							; TSTN checks for a number.  This is very simplistic;
   1643  0981							; if the character is a digit, assume it's a number.
   1644  0981							; Convert to a number and push it onto the stack.
   1645  0981							;
   1646  0981		       20 99 0d    iTSTN      jsr	getILByte
   1647  0984		       85 5d		      sta	offset
   1648  0986							;
   1649  0986		       a4 51		      ldy	CUROFF
   1650  0988		       20 18 11 	      jsr	SkipSpaces
   1651  098b		       b1 4f		      lda	(CURPTR),y
   1652  098d		       c9 2d		      cmp	#'-	;negative?
   1653  098f		       f0 08		      beq	iTSTN_1
   1654  0991		       c9 30		      cmp	#'0
   1655  0993		       90 0f		      bcc	tstBranch
   1656  0995		       c9 3a		      cmp	#'9+1
   1657  0997		       b0 0b		      bcs	tstBranch
   1658  0999							;
   1659  0999							; It's a digit, so convert to a number.
   1660  0999							;
   1661  0999		       20 a2 0e    iTSTN_1    jsr	getDecimal
   1662  099c		       84 51		      sty	CUROFF
   1663  099e		       20 f7 0f 	      jsr	pushR0	;save onto stack
   1664  09a1		       4c ea 02 	      jmp	NextIL
   1665  09a4
   1666  09a4							;
   1667  09a4							; Common jump point for all TSTx instructions that
   1668  09a4							; fail to meet the requirements.  This takes the
   1669  09a4							; offset and adds/subtracts to/from ILPC.
   1670  09a4							;
   1671  09a4		       a5 5d	   tstBranch  lda	offset	;get signed offset
   1672  09a6		       10 0e		      bpl	tstPositive
   1673  09a8							;
   1674  09a8							; Do negative branch.	Do sign extension.
   1675  09a8							;
   1676  09a8		       18		      clc
   1677  09a9		       65 43		      adc	ILPC
   1678  09ab		       85 43		      sta	ILPC
   1679  09ad		       a5 44		      lda	ILPC+1
   1680  09af		       69 ff		      adc	#$ff
   1681  09b1		       85 44		      sta	ILPC+1
   1682  09b3		       4c ea 02 	      jmp	NextIL	;keep going
   1683  09b6							;
   1684  09b6		       18	   tstPositive clc
   1685  09b7		       65 43		      adc	ILPC
   1686  09b9		       85 43		      sta	ILPC
   1687  09bb		       a5 44		      lda	ILPC+1
   1688  09bd		       69 00		      adc	#0
   1689  09bf		       85 44		      sta	ILPC+1
   1690  09c1		       4c ea 02 	      jmp	NextIL
   1691  09c4
   1692  09c4							;
   1693  09c4							;====================================================
   1694  09c4							; Test for IRQ pending, and test if a break key pressed
   1695  09c4							; Yes I know but this handles all sorts of irq/break issues
   1696  09c4							;
   1697  09c4		       20 99 0d    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1698  09c7		       85 5d		      sta	offset	; Store the not true jump address offset
   1699  09c9		       20 29 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1700  09cc		       d0 03		      bne	irqNo	; z not set of no break found
   1701  09ce		       4c 9a 05 	      jmp	iFIN	; Exit out of run mode
   1702  09d1		       ad d8 16    irqNo      lda	IRQPending
   1703  09d4		       f0 ce		      beq	tstBranch
   1704  09d6		       c9 01		      cmp	#1	; only do this if set to first time
   1705  09d8		       d0 ca		      bne	tstBranch
   1706  09da		       78		      sei		; disable the interupt until ireturn resets it
   1707  09db		       ee d8 16    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1708  09de		       20 0c 10 	      jsr	pushLN	; Push the next line to be executed
   1709  09e1		       b0 11		      bcs	irqErra	; Check if there was an error
   1710  09e3		       ad d9 16 	      lda	IRQEntry	; Get the line number to branch to
   1711  09e6		       85 4f		      sta	CURPTR	; put line number into r0
   1712  09e8		       ad da 16 	      lda	IRQEntry+1
   1713  09eb		       85 50		      sta	CURPTR+1
   1714  09ed		       a9 03		      lda	#3	; Point to first byte of program text
   1715  09ef		       85 51		      sta	CUROFF
   1716  09f1		       4c ea 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1717  09f4		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1718  09f6		       a9 00		      lda	#0	; stop the execution
   1719  09f8		       4c b1 05 	      jmp	iErr2
   1720  09fb							;
   1721  09fb
   1722  09fb							;=====================================================
   1723  09fb							; This places the number of free bytes on top of the
   1724  09fb							; stack.
   1725  09fb							;
   1726  09fb		       20 66 11    iFREE      jsr	GetSizes
   1727  09fe		       20 f7 0f 	      jsr	pushR0
   1728  0a01		       4c ea 02 	      jmp	NextIL
   1729  0a04							;
   1730  0a04							;=====================================================
   1731  0a04							; Generate a random number from 0-FFFF and then MOD
   1732  0a04							; it with the value on top of stack.  Leaves number on
   1733  0a04							; stack
   1734  0a04							;
   1735  0a04		       20 84 10    iRANDOM    jsr	popR1	;mod value
   1736  0a07							;
   1737  0a07							; If the value is zero, just return a one.
   1738  0a07							;
   1739  0a07		       a5 54		      lda	R1
   1740  0a09		       05 55		      ora	R1+1
   1741  0a0b		       f0 4a		      beq	irandom1
   1742  0a0d							;
   1743  0a0d		       ad 2b 1f 	      lda	random+1
   1744  0a10		       8d 28 1f 	      sta	rtemp1
   1745  0a13		       ad 2a 1f 	      lda	random
   1746  0a16		       0a		      asl
   1747  0a17		       2e 28 1f 	      rol	rtemp1
   1748  0a1a		       0a		      asl
   1749  0a1b		       2e 28 1f 	      rol	rtemp1
   1750  0a1e		       18		      clc
   1751  0a1f		       6d 2a 1f 	      adc	random
   1752  0a22		       48		      pha
   1753  0a23		       ad 28 1f 	      lda	rtemp1
   1754  0a26		       6d 2b 1f 	      adc	random+1
   1755  0a29		       8d 2b 1f 	      sta	random+1
   1756  0a2c		       68		      pla
   1757  0a2d		       69 11		      adc	#$11
   1758  0a2f		       8d 2a 1f 	      sta	random
   1759  0a32		       ad 2b 1f 	      lda	random+1
   1760  0a35		       69 36		      adc	#$36
   1761  0a37		       8d 2b 1f 	      sta	random+1
   1762  0a3a
   1763  0a3a		       ad 2a 1f 	      lda	random
   1764  0a3d		       85 52		      sta	R0
   1765  0a3f		       ad 2b 1f 	      lda	random+1
   1766  0a42		       29 7f		      and	#$7f	;make positive
   1767  0a44		       85 53		      sta	R0+1
   1768  0a46							;
   1769  0a46							; R0 contains the number and R1 contains the max value.
   1770  0a46							;
   1771  0a46		       20 bf 06 	      jsr	iDivNoPop
   1772  0a49		       20 e9 10 	      jsr	RestoreSigns
   1773  0a4c		       a5 56		      lda	MQ
   1774  0a4e		       85 52		      sta	R0
   1775  0a50		       a5 57		      lda	MQ+1
   1776  0a52		       85 53		      sta	R0+1
   1777  0a54		       4c 99 06 	      jmp	pushR0nextIl
   1778  0a57				   irandom1
   1779  0a57		       a9 00		      lda	#0
   1780  0a59		       85 53		      sta	R0+1
   1781  0a5b		       a9 01		      lda	#1
   1782  0a5d		       85 52		      sta	R0
   1783  0a5f		       4c 99 06 	      jmp	pushR0nextIl
   1784  0a62
   1785  0a62							; The following replaced by call to division/modulo
   1786  0a62							;iRANDOM_2	lda	R0
   1787  0a62							;		cmp	R1
   1788  0a62							;		bne	iRANDOM_1
   1789  0a62							;		lda	R0+1
   1790  0a62							;		cmp	R1+1
   1791  0a62							;		bne	iRANDOM_1	;need to subtract
   1792  0a62							;
   1793  0a62							; Subtract R1 from R0
   1794  0a62							;
   1795  0a62							;iRANDOM_sub	sec
   1796  0a62							;		lda	R0
   1797  0a62							;		sbc	R1
   1798  0a62							;		sta	R0
   1799  0a62							;		lda	R0+1
   1800  0a62							;		sbc	R1+1
   1801  0a62							;		sta	R0+1
   1802  0a62							;		jmp	iRANDOM_2
   1803  0a62							;
   1804  0a62							; See if R1 > R0.  If so, branch to subtract.
   1805  0a62							;
   1806  0a62							;iRANDOM_1	lda	R0
   1807  0a62							;		cmp	R1
   1808  0a62							;		lda	R0+1
   1809  0a62							;		sbc	R1+1
   1810  0a62							;		bvc	iRANDOM_4
   1811  0a62							;		eor	#$80
   1812  0a62							;iRANDOM_4	bpl	iRANDOM_sub
   1813  0a62							;
   1814  0a62							; All done.  Almost.  Add one, then push the result.
   1815  0a62							;
   1816  0a62							;irandom1	inc	R0
   1817  0a62							;		bne	iRANDOM_3
   1818  0a62							;		inc	R0+1
   1819  0a62							;iRANDOM_3
   1820  0a62							;		  jsr	pushR0	;return value
   1821  0a62							;		jmp	NextIL
   1822  0a62							;
   1823  0a62							; Poke a value into a memory location
   1824  0a62		       8c 2e 1f    iPOKEMEMORY sty	tempy
   1825  0a65		       20 6f 10 	      jsr	popR0
   1826  0a68		       20 84 10 	      jsr	popR1
   1827  0a6b		       a0 00		      ldy	#0
   1828  0a6d		       a5 52		      lda	R0
   1829  0a6f		       91 54		      sta	(R1),y
   1830  0a71		       ac 2e 1f 	      ldy	tempy
   1831  0a74		       4c ea 02 	      jmp	NextIL
   1832  0a77							;
   1833  0a77							; Get a value from a memory location
   1834  0a77							;
   1835  0a77		       8c 2e 1f    iPEEKMEMORY sty	tempy
   1836  0a7a		       20 6f 10 	      jsr	popR0
   1837  0a7d		       a0 00		      ldy	#0
   1838  0a7f		       b1 52		      lda	(R0),y
   1839  0a81		       ac 2e 1f 	      ldy	tempy
   1840  0a84		       85 52		      sta	R0
   1841  0a86		       a9 00		      lda	#0
   1842  0a88		       85 53		      sta	R0+1
   1843  0a8a		       4c 99 06 	      jmp	pushR0nextIl
   1844  0a8d							;
   1845  0a8d							; Call to address return what ever is in a to the stack
   1846  0a8d							; func2 will load a value into a before the call
   1847  0a8d		       20 84 10    iCallFunc  jsr	popR1
   1848  0a90		       a5 54		      lda	R1
   1849  0a92		       20 9e 0a 	      jsr	iCallRtn
   1850  0a95		       85 52		      sta	R0
   1851  0a97		       a9 00		      lda	#0
   1852  0a99		       85 53		      sta	R0+1
   1853  0a9b		       20 99 06 	      jsr	pushR0nextIl
   1854  0a9e				   iCallRtn
   1855  0a9e		       20 6f 10 	      jsr	popR0
   1856  0aa1		       6c 52 00 	      jmp	(R0)
   1857  0aa4
   1858  0aa4
   1859  0aa4							;===========================================jlit======
   1860  0aa4							;Get a character from the terminal convert to value
   1861  0aa4							;leave the number on top of the stack
   1862  0aa4							;
   1863  0aa4				   iGETCHAR
   1864  0aa4							;		  jsr	  pushLN      ;Save state before getline
   1865  0aa4		       20 09 02 	      jsr	GETCH
   1866  0aa7					      if	CTMON65
   1867  0aa7		       48		      pha
   1868  0aa8		       20 0c f0 	      jsr	cout	;echo echo echo
   1869  0aab		       68		      pla
   1870  0aac					      endif
   1871  0aac		       85 52		      sta	R0
   1872  0aae		       a9 00		      lda	#0
   1873  0ab0		       85 53		      sta	R0+1
   1874  0ab2		       20 f7 0f 	      jsr	pushR0
   1875  0ab5							;
   1876  0ab5							;		  jsr	  popLN
   1877  0ab5		       4c ea 02 	      jmp	NextIL
   1878  0ab8							;===========================================jlit======
   1879  0ab8							;Put a character to the terminal convert to
   1880  0ab8							;
   1881  0ab8		       20 6f 10    iPUTCHAR   jsr	popR0
   1882  0abb		       a5 52		      lda	R0
   1883  0abd		       20 06 02 	      jsr	OUTCH
   1884  0ac0		       4c ea 02 	      jmp	NextIL
   1885  0ac3							;=====================================================
   1886  0ac3							; Put the number on the stack out as hex, suppress leading 0
   1887  0ac3				   iHexOut
   1888  0ac3		       20 6f 10 	      jsr	popR0
   1889  0ac6		       a5 53		      lda	R0+1
   1890  0ac8		       f0 03		      beq	iHexSecondByte
   1891  0aca		       20 0f 02 	      jsr	OUTHEX
   1892  0acd				   iHexSecondByte
   1893  0acd		       a5 52		      lda	R0
   1894  0acf		       20 0f 02 	      jsr	OUTHEX
   1895  0ad2		       4c ea 02 	      jmp	NextIL
   1896  0ad5							;
   1897  0ad5							;=====================================================
   1898  0ad5							; Replace TOS with its absolute value.
   1899  0ad5							;
   1900  0ad5		       20 6f 10    iABS       jsr	popR0
   1901  0ad8		       a5 53		      lda	R0+1
   1902  0ada		       10 10		      bpl	iABS_1	;already positive
   1903  0adc		       49 ff		      eor	#$ff
   1904  0ade		       85 53		      sta	R0+1
   1905  0ae0		       a5 52		      lda	R0
   1906  0ae2		       49 ff		      eor	#$ff
   1907  0ae4		       85 52		      sta	R0
   1908  0ae6		       e6 52		      inc	R0
   1909  0ae8		       d0 02		      bne	iABS_1
   1910  0aea		       e6 53		      inc	R0+1
   1911  0aec		       4c 99 06    iABS_1     jmp	pushR0nextIl
   1912  0aef
   1913  0aef							;
   1914  0aef							;================================================================
   1915  0aef							; The set of logical operators
   1916  0aef				   iLogAnd
   1917  0aef		       20 6f 10 	      jsr	popR0
   1918  0af2		       20 84 10 	      jsr	popR1
   1919  0af5		       a5 52		      lda	R0
   1920  0af7		       25 54		      and	R1
   1921  0af9		       85 52		      sta	R0
   1922  0afb		       a5 53		      lda	R0+1
   1923  0afd		       25 55		      and	R1+1
   1924  0aff		       85 53		      sta	R0+1
   1925  0b01		       4c 99 06 	      jmp	pushR0nextIl
   1926  0b04				   iLogOr
   1927  0b04		       20 6f 10 	      jsr	popR0
   1928  0b07		       20 84 10 	      jsr	popR1
   1929  0b0a		       a5 52		      lda	R0
   1930  0b0c		       05 54		      ora	R1
   1931  0b0e		       85 52		      sta	R0
   1932  0b10		       a5 53		      lda	R0+1
   1933  0b12		       05 55		      ora	R1+1
   1934  0b14		       85 53		      sta	R0+1
   1935  0b16		       4c 99 06 	      jmp	pushR0nextIl
   1936  0b19				   iLogXor
   1937  0b19		       20 6f 10 	      jsr	popR0
   1938  0b1c		       20 84 10 	      jsr	popR1
   1939  0b1f		       a5 52		      lda	R0
   1940  0b21		       45 54		      eor	R1
   1941  0b23		       85 52		      sta	R0
   1942  0b25		       a5 53		      lda	R0+1
   1943  0b27		       45 55		      eor	R1+1
   1944  0b29		       85 53		      sta	R0+1
   1945  0b2b		       4c 99 06 	      jmp	pushR0nextIl
   1946  0b2e				   iLogNot
   1947  0b2e		       20 6f 10 	      jsr	popR0
   1948  0b31		       a5 52		      lda	R0
   1949  0b33		       49 ff		      eor	#$FF
   1950  0b35		       85 52		      sta	R0
   1951  0b37		       a5 53		      lda	R0+1
   1952  0b39		       49 ff		      eor	#$FF
   1953  0b3b		       85 53		      sta	R0+1
   1954  0b3d		       4c 99 06 	      jmp	pushR0nextIl
   1955  0b40
   1956  0b40				   iTruth
   1957  0b40		       a9 ff		      lda	#$FF
   1958  0b42		       85 52		      sta	R0
   1959  0b44		       85 53		      sta	R0+1
   1960  0b46		       4c 99 06 	      jmp	pushR0nextIl
   1961  0b49				   iFalse
   1962  0b49		       a9 00		      lda	#$00
   1963  0b4b		       85 52		      sta	R0
   1964  0b4d		       85 53		      sta	R0+1
   1965  0b4f		       4c 99 06 	      jmp	pushR0nextIl
   1966  0b52
   1967  0b52							;================================================================
   1968  0b52							;Set the IRQ service rtn line number
   1969  0b52							;
   1970  0b52		       78	   iSetIrq    sei		; disable the interupts
   1971  0b53		       a9 00		      lda	#0	; Zero the Status flag
   1972  0b55		       8d d7 16 	      sta	IRQStatus
   1973  0b58		       20 6f 10 	      jsr	popR0	; get the line number
   1974  0b5b		       a5 52		      lda	R0
   1975  0b5d		       05 53		      ora	R0+1
   1976  0b5f		       f0 1b		      beq	iSetExt	; if it is zero disable all
   1977  0b61		       20 0c 10 	      jsr	pushLN	; Save the current line pointer
   1978  0b64		       20 d4 0d 	      jsr	findLine	; Find the IRQ func Line Pointer
   1979  0b67		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   1980  0b69		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   1981  0b6b		       8d da 16 	      sta	IRQEntry+1
   1982  0b6e		       a5 4f		      lda	CURPTR
   1983  0b70		       8d d9 16 	      sta	IRQEntry
   1984  0b73		       a9 01		      lda	#1	; Indicate there is an irq gosub
   1985  0b75		       8d d7 16 	      sta	IRQStatus
   1986  0b78		       20 2f 10 	      jsr	popLN	; Restore the old line number
   1987  0b7b		       58		      cli		; Enable the interupts
   1988  0b7c		       4c ea 02    iSetExt    jmp	NextIL
   1989  0b7f
   1990  0b7f		       20 2f 10    iSetIrqErr jsr	popLN
   1991  0b82		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   1992  0b84		       a9 00		      lda	#0
   1993  0b86		       4c b1 05 	      jmp	iErr2
   1994  0b89							;
   1995  0b89
   1996  0b89
   1997  0b89							;=====================================================
   1998  0b89							; Define start of non page zero data
   1999 U1f37 ????				      seg.u	TBData
   2000 U16c6					      org	PROGEND
   2001 U16c6							;=================================================================
   2002 U16c6							;
------- FILE tasks.asm LEVEL 2 PASS 6
      0 U16c6					      include	"tasks.asm"
      1 U16c6							;=====================================================
      2 U16c6							; Tiny Basic IL task management
      3 U16c6							; Data required by task management
      4 U16c6							;
      5 U16c6
      6  0b89					      Seg	Code
      7  0b89							;=====================================================
      8  0b89							; Sets the pointers to the math,IL and gosub stacks
      9  0b89				   taskSetStacks
     10  0b89		       a9 b7		      lda	#mathStack&$FF
     11  0b8b		       85 48		      sta	MATHSTACK
     12  0b8d		       a9 17		      lda	#mathStack>>8
     13  0b8f		       85 49		      sta	MATHSTACK+1
     14  0b91
     15  0b91		       a9 1f		      lda	#ilStack&$ff
     16  0b93		       85 45		      sta	ILSTACK
     17  0b95		       a9 19		      lda	#ilStack>>8
     18  0b97		       85 46		      sta	ILSTACK+1
     19  0b99
     20  0b99		       a9 87		      lda	#gosubStack&$FF
     21  0b9b		       85 4b		      sta	GOSUBSTACK
     22  0b9d		       a9 1a		      lda	#gosubStack>>8
     23  0b9f		       85 4c		      sta	GOSUBSTACK+1
     24  0ba1
     25  0ba1		       a9 c7		      lda	#variableStack&$FF
     26  0ba3		       85 41		      sta	VARIABLES
     27  0ba5		       a9 1c		      lda	#variableStack>>8
     28  0ba7		       85 42		      sta	VARIABLES+1
     29  0ba9		       a2 09		      ldx	#TASKCOUNT
     30  0bab		       a0 00		      ldy	#0
     31  0bad		       20 73 0d 	      jsr	ContextSave
     32  0bb0
     33  0bb0		       c0 d8	   taskSetLoop cpy	#TASKTABLELEN
     34  0bb2		       b0 3a		      bcs	taskSetDone
     35  0bb4
     36  0bb4		       a5 4b		      lda	GOSUBSTACK
     37  0bb6		       18		      clc
     38  0bb7		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     39  0bb9		       85 4b		      sta	GOSUBSTACK
     40  0bbb		       a5 4c		      lda	GOSUBSTACK+1
     41  0bbd		       69 00		      adc	#0
     42  0bbf		       85 4c		      sta	GOSUBSTACK+1
     43  0bc1
     44  0bc1		       a5 45		      lda	ILSTACK	; must be less than 256
     45  0bc3		       18		      clc
     46  0bc4		       69 28		      adc	#ILSTACKSIZE*2
     47  0bc6		       85 45		      sta	ILSTACK
     48  0bc8		       a5 46		      lda	ILSTACK+1
     49  0bca		       69 00		      adc	#0
     50  0bcc		       85 46		      sta	ILSTACK+1
     51  0bce
     52  0bce		       a5 48		      lda	MATHSTACK	; must be less than 256
     53  0bd0		       18		      clc
     54  0bd1		       69 28		      adc	#MATHSTACKSIZE*2
     55  0bd3		       85 48		      sta	MATHSTACK
     56  0bd5		       a5 49		      lda	MATHSTACK+1
     57  0bd7		       69 00		      adc	#0
     58  0bd9		       85 49		      sta	MATHSTACK+1
     59  0bdb
     60  0bdb		       a5 41		      lda	VARIABLES	; must be less than 256
     61  0bdd		       18		      clc
     62  0bde		       69 34		      adc	#variablesEnd
     63  0be0		       85 41		      sta	VARIABLES
     64  0be2		       a5 42		      lda	VARIABLES+1
     65  0be4		       69 00		      adc	#0
     66  0be6		       85 42		      sta	VARIABLES+1
     67  0be8
     68  0be8		       20 73 0d 	      jsr	ContextSave
     69  0beb		       4c b0 0b 	      jmp	taskSetLoop
     70  0bee
     71  0bee				   taskSetDone
     72  0bee		       a0 00		      ldy	#0	; reload the main loop context
     73  0bf0		       20 82 0d 	      jsr	ContextLoad
     74  0bf3		       60		      rts
     75  0bf4							;
     76  0bf4							;=====================================================
     77  0bf4							; Clear all task entries and task stacks
     78  0bf4		       98	   taskReset  tya		; Save Y
     79  0bf5		       48		      pha
     80  0bf6		       a9 01		      lda	#1
     81  0bf8		       8d b6 17 	      sta	taskCounter	; Set number of active tasks to 1
     82  0bfb		       ac db 16 	      ldy	taskPtr	; Set the active task to 0 MAIN
     83  0bfe		       c0 00		      cpy	#0	; check if we are the main context
     84  0c00		       f0 08		      beq	taskResetCont	; if we are just continue
     85  0c02
     86  0c02		       a0 00		      ldy	#0	; else we need to switch to the main context
     87  0c04		       8c db 16 	      sty	taskPtr
     88  0c07		       20 82 0d 	      jsr	ContextLoad	; load the Main Loop context
     89  0c0a				   taskResetCont
     90  0c0a		       a0 18		      ldy	#CONTEXTLEN+1	; Start at the second task
     91  0c0c
     92  0c0c				   taskResetLoop
     93  0c0c		       a9 00		      lda	#0
     94  0c0e		       99 dc 16 	      sta	taskTable,y	; Ensure that the task is made inactive
     95  0c11		       18		      clc
     96  0c12		       98		      tya
     97  0c13		       69 18		      adc	#CONTEXTLEN+1
     98  0c15		       a8		      tay
     99  0c16		       c0 d8		      cpy	#TASKTABLELEN	; Are we at the end yet
    100  0c18		       90 f2		      bcc	taskResetLoop	; Go for more
    101  0c1a
    102  0c1a				   taskResetComplete
    103  0c1a
    104  0c1a		       68		      pla		; Restore y
    105  0c1b		       a8		      tay
    106  0c1c		       60		      rts
    107  0c1d
    108  0c1d							;
    109  0c1d							;======================================================
    110  0c1d							; iTaskSwitch	 switch to new task if not interrupt and
    111  0c1d							;		 count is exceded for task time slice gets here
    112  0c1d							;		 when time slice has reached zero
    113  0c1d							;
    114  0c1d		       98	   iTaskSwitch tya
    115  0c1e		       48		      pha
    116  0c1f		       ad b5 17 	      lda	taskResetValue	; Always reset the counter value
    117  0c22		       8d b4 17 	      sta	taskCurrentCycles	; Update the counter with the new value
    118  0c25
    119  0c25		       ad d8 16 	      lda	IRQPending	; Skip this if we are processing an irq
    120  0c28		       05 5f		      ora	taskIOPending	; If set then don't switch
    121  0c2a		       d0 2f		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    122  0c2c
    123  0c2c		       ad b6 17    iTaskMain  lda	taskCounter	; Number of tasks
    124  0c2f		       c9 01		      cmp	#1	; if there is only one task must be main
    125  0c31		       d0 07		      bne	itasknext	; if it some other number continue to next
    126  0c33
    127  0c33		       ac db 16 	      ldy	taskPtr	; check if we have not just ended some other task
    128  0c36		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    129  0c38		       f0 21		      beq	iTaskSwitchDone	; Skip this if main is only task
    130  0c3a							;
    131  0c3a							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    132  0c3a							;
    133  0c3a				   itasknext
    134  0c3a		       ac db 16 	      ldy	taskPtr
    135  0c3d		       20 73 0d 	      jsr	ContextSave	; Save the current context, y points to next context
    136  0c40				   itaskLoop
    137  0c40		       c0 d8		      cpy	#TASKTABLELEN	; Are we at end of task table
    138  0c42		       90 04		      bcc	iTaskNextChk
    139  0c44
    140  0c44		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    141  0c46		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    142  0c48
    143  0c48				   iTaskNextChk
    144  0c48		       b9 dc 16 	      lda	taskTable,y	; there is always at least one entry in table
    145  0c4b		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    146  0c4d		       18		      clc
    147  0c4e		       98		      tya
    148  0c4f		       69 18		      adc	#CONTEXTLEN+1	; Next Table entry
    149  0c51		       a8		      tay
    150  0c52		       4c 40 0c 	      jmp	itaskLoop	; Check for busy entry
    151  0c55
    152  0c55				   iTaskLoadEntry
    153  0c55		       20 82 0d 	      jsr	ContextLoad	; load the next context
    154  0c58		       8c db 16 	      sty	taskPtr	; update the task pointer
    155  0c5b
    156  0c5b				   iTaskSwitchDone
    157  0c5b		       68		      pla
    158  0c5c		       a8		      tay
    159  0c5d		       60		      rts
    160  0c5e							;
    161  0c5e							;================================================================
    162  0c5e							; Task Set task number to line number to start
    163  0c5e							; Task Table structure:
    164  0c5e							;    byte 0	-   Active inactive 0 or 1
    165  0c5e							;    byte 1-2	-   Basic code line pointer
    166  0c5e							;    byte 3	-   Offset on current line
    167  0c5e		       98	   iTaskSet   tya		;preserve Y
    168  0c5f		       48		      pha
    169  0c60
    170  0c60		       20 6f 10 	      jsr	popR0	; Get the line number to be saved
    171  0c63
    172  0c63		       ac db 16 	      ldy	taskPtr	; find out where we are
    173  0c66		       20 73 0d 	      jsr	ContextSave	; Save the current context
    174  0c69
    175  0c69							;Find the pointer to the line we need to start at
    176  0c69		       20 d4 0d 	      jsr	findLine	; Get the offset of the line to start task at
    177  0c6c		       f0 0b		      beq	iTaskCont
    178  0c6e
    179  0c6e		       ac db 16 	      ldy	taskPtr	; Restore the original Context Error Exit
    180  0c71		       20 82 0d 	      jsr	ContextLoad
    181  0c74
    182  0c74		       68		      pla
    183  0c75		       a8		      tay
    184  0c76		       4c 7f 0b 	      jmp	iSetIrqErr	; Bad line number provided
    185  0c79
    186  0c79				   iTaskCont
    187  0c79		       20 5f 0d 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    188  0c7c		       90 47		      bcc	iTaskNoEmpty	; There are no more empty slots
    189  0c7e
    190  0c7e		       a9 01		      lda	#1	; Mark as enabled
    191  0c80		       99 dc 16 	      sta	taskTable,y	; new task as active
    192  0c83
    193  0c83		       a5 4f		      lda	CURPTR
    194  0c85		       48		      pha
    195  0c86		       a5 50		      lda	CURPTR+1
    196  0c88		       48		      pha
    197  0c89
    198  0c89		       20 82 0d 	      jsr	ContextLoad	; load the context of the new task
    199  0c8c
    200  0c8c		       68		      pla
    201  0c8d		       85 50		      sta	CURPTR+1
    202  0c8f		       68		      pla
    203  0c90		       85 4f		      sta	CURPTR
    204  0c92		       a9 03		      lda	#3	; Offset to first instruction
    205  0c94		       85 51		      sta	CUROFF
    206  0c96
    207  0c96		       a9 00		      lda	#0
    208  0c98		       85 47		      sta	ILSTACKPTR
    209  0c9a		       85 4a		      sta	MATHSTACKPTR
    210  0c9c		       85 4d		      sta	GOSUBSTACKPTR
    211  0c9e		       85 4e		      sta	MESSAGEPTR
    212  0ca0
    213  0ca0		       20 92 08 	      jsr	subVINIT	; Clear the variables
    214  0ca3
    215  0ca3		       a9 12		      lda	#STMT&$FF
    216  0ca5		       85 43		      sta	ILPC
    217  0ca7		       a9 13		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    218  0ca9		       85 44		      sta	ILPC+1
    219  0cab
    220  0cab		       98		      tya		; Save the new context offset to return to user
    221  0cac		       48		      pha
    222  0cad
    223  0cad		       20 73 0d    itaskSetSave jsr	ContextSave	; save the updated context
    224  0cb0		       ee b6 17 	      inc	taskCounter	; Update the number of Tasks running
    225  0cb3
    226  0cb3		       ac db 16 	      ldy	taskPtr
    227  0cb6		       20 82 0d 	      jsr	ContextLoad	; restore the original context
    228  0cb9
    229  0cb9		       a9 00		      lda	#0	; Set the R0 upper to zero
    230  0cbb		       85 53		      sta	R0+1
    231  0cbd		       68		      pla		; Get the task pid we stored
    232  0cbe		       85 52		      sta	R0	; Get the table entry value
    233  0cc0
    234  0cc0		       68		      pla		; Restore the y register we saved
    235  0cc1		       a8		      tay
    236  0cc2
    237  0cc2		       4c 99 06 	      jmp	pushR0nextIl	; Push R0 and continue
    238  0cc5				   iTaskNoEmpty
    239  0cc5		       ac db 16 	      ldy	taskPtr
    240  0cc8		       20 82 0d 	      jsr	ContextLoad
    241  0ccb
    242  0ccb		       68		      pla
    243  0ccc		       a8		      tay
    244  0ccd
    245  0ccd		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    246  0ccf		       a9 00		      lda	#0
    247  0cd1		       4c b1 05 	      jmp	iErr2
    248  0cd4							;
    249  0cd4							;================================================================
    250  0cd4							; Returns task Status
    251  0cd4				   iTaskStat
    252  0cd4		       20 e2 0c 	      jsr	iTaskValid	; returns pointer to task entry
    253  0cd7		       b9 dc 16 	      lda	taskTable,y
    254  0cda		       f0 03		      beq	iTaskStatExit
    255  0cdc		       4c 40 0b 	      jmp	iTruth
    256  0cdf				   iTaskStatExit
    257  0cdf		       4c 49 0b 	      jmp	iFalse
    258  0ce2
    259  0ce2							;
    260  0ce2							;================================================================
    261  0ce2							; Validate the task number on top of the stack
    262  0ce2							; on exit y points to the requested task entry
    263  0ce2							;
    264  0ce2		       20 6f 10    iTaskValid jsr	popR0	; get result of the multiply
    265  0ce5		       a5 53		      lda	R0+1
    266  0ce7		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    267  0ce9		       a5 52		      lda	R0
    268  0ceb		       c9 d8		      cmp	#TASKTABLELEN
    269  0ced		       90 09		      bcc	iTaskIsValid
    270  0cef
    271  0cef		       68	   iTaskValidErr pla		;remove return address
    272  0cf0		       68		      pla
    273  0cf1		       a2 10		      ldx	#ERR_INVALID_PID
    274  0cf3		       a9 00		      lda	#0
    275  0cf5		       4c b1 05 	      jmp	iErr2
    276  0cf8
    277  0cf8		       a8	   iTaskIsValid tay
    278  0cf9		       60		      rts
    279  0cfa							;
    280  0cfa							;================================================================
    281  0cfa							; Kill a running task, do nothing if already stopped
    282  0cfa		       20 e2 0c    iTaskKill  jsr	iTaskValid
    283  0cfd		       a9 00		      lda	#0
    284  0cff		       99 dc 16 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    285  0d02							;
    286  0d02							;================================================================
    287  0d02							;Skip to next task
    288  0d02				   iNTask
    289  0d02		       a9 01		      lda	#1
    290  0d04		       8d b4 17 	      sta	taskCurrentCycles
    291  0d07		       4c ea 02 	      jmp	NextIL
    292  0d0a							;
    293  0d0a							;=======================================================
    294  0d0a							; Wait for a task to complete
    295  0d0a				   iWTASK
    296  0d0a		       20 99 0d 	      jsr	getILByte
    297  0d0d		       85 5d		      sta	offset
    298  0d0f							;
    299  0d0f		       20 e5 0f 	      jsr	saveIL	;in case of failure
    300  0d12
    301  0d12		       20 e2 0c 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    302  0d15		       b9 dc 16 	      lda	taskTable,y
    303  0d18		       d0 03		      bne	iWTASKWAIT
    304  0d1a		       4c ea 02 	      jmp	NextIL
    305  0d1d				   iWTASKWAIT
    306  0d1d		       20 f7 0f 	      jsr	pushR0	; Push R0 back onto the stack
    307  0d20		       a9 01		      lda	#1
    308  0d22		       8d b4 17 	      sta	taskCurrentCycles	; Give up the cycles
    309  0d25
    310  0d25		       20 ee 0f 	      jsr	restoreIL
    311  0d28		       4c a4 09 	      jmp	tstBranch
    312  0d2b							;
    313  0d2b							;=======================================================
    314  0d2b							; Set task io lock
    315  0d2b		       e6 5f	   iStartIO   inc	taskIOPending
    316  0d2d		       4c ea 02 	      jmp	NextIL
    317  0d30							;
    318  0d30							;=======================================================
    319  0d30							; Release the io lock
    320  0d30		       a5 5f	   iEndIO     lda	taskIOPending
    321  0d32		       f0 02		      beq	iEndIOExit
    322  0d34		       c6 5f		      dec	taskIOPending
    323  0d36		       4c ea 02    iEndIOExit jmp	NextIL
    324  0d39							;
    325  0d39							;===============================================================
    326  0d39							; Return the task PID
    327  0d39				   iTASKPID
    328  0d39		       a9 00		      lda	#0
    329  0d3b		       85 53		      sta	R0+1
    330  0d3d		       ad db 16 	      lda	taskPtr
    331  0d40		       85 52		      sta	R0
    332  0d42		       4c 99 06 	      jmp	pushR0nextIl
    333  0d45							;
    334  0d45							;================================================================
    335  0d45							; Terminate a task
    336  0d45		       ac db 16    iETask     ldy	taskPtr
    337  0d48		       c0 00		      cpy	#0
    338  0d4a		       d0 03		      bne	iETaskCont
    339  0d4c		       4c 9a 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    340  0d4f				   iETaskCont
    341  0d4f		       a9 00		      lda	#0
    342  0d51		       99 dc 16 	      sta	taskTable,y	; mark entry as free
    343  0d54		       ce b6 17 	      dec	taskCounter	; reduce the number of active tasks
    344  0d57		       a9 01		      lda	#1
    345  0d59		       8d b4 17 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    346  0d5c				   iETaskExit
    347  0d5c		       4c ea 02 	      jmp	NextIL
    348  0d5f
    349  0d5f							;
    350  0d5f							;================================================================
    351  0d5f							; Find an empty slot in the taskTable
    352  0d5f							; Return the index in y
    353  0d5f							; on exit   c set if an empty slot is found
    354  0d5f							;	     c clear if not found
    355  0d5f							;================================================================
    356  0d5f							;
    357  0d5f				   TaskEmpty
    358  0d5f		       a0 18		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    359  0d61				   TaskLoop
    360  0d61		       b9 dc 16 	      lda	taskTable,y
    361  0d64		       f0 0b		      beq	TaskEmptyFnd
    362  0d66		       98		      tya
    363  0d67		       18		      clc
    364  0d68		       69 18		      adc	#CONTEXTLEN+1
    365  0d6a		       a8		      tay
    366  0d6b		       c0 d8		      cpy	#TASKTABLELEN
    367  0d6d		       90 f2		      bcc	TaskLoop	; Y is never zero
    368  0d6f				   TaskNoSlot
    369  0d6f		       18		      clc
    370  0d70		       60		      rts
    371  0d71				   TaskEmptyFnd
    372  0d71		       38		      sec
    373  0d72		       60		      rts
    374  0d73
    375  0d73							;
    376  0d73							;=====================================================
    377  0d73							; Save Context Store the context to the TASK Table
    378  0d73							; on entry y contains the task table entry to save to
    379  0d73							; on exit y points to next task table entry
    380  0d73							;	   x contains the number of bytes copied
    381  0d73		       a2 00	   ContextSave ldx	#0
    382  0d75		       c8		      iny		;inc past the task flags
    383  0d76		       b5 41	   ContextSvLoop lda	CONTEXT,x
    384  0d78		       99 dc 16 	      sta	taskTable,y
    385  0d7b		       c8		      iny
    386  0d7c		       e8		      inx
    387  0d7d		       e0 17		      cpx	#CONTEXTLEN
    388  0d7f		       90 f5		      bcc	ContextSvLoop
    389  0d81		       60		      rts
    390  0d82							;
    391  0d82							; Load Context transfer context from task table to the Current Context
    392  0d82							; on entry y contains the task table entry to transfer
    393  0d82							; on exit y points to the original task table entry
    394  0d82							;	   x contains the number of byts copied
    395  0d82		       98	   ContextLoad tya
    396  0d83		       48		      pha
    397  0d84		       a2 00		      ldx	#0
    398  0d86		       c8		      iny		;inc past the task flags
    399  0d87		       b9 dc 16    ContextLDLoop lda	taskTable,y
    400  0d8a		       95 41		      sta	CONTEXT,x
    401  0d8c		       c8		      iny
    402  0d8d		       e8		      inx
    403  0d8e		       e0 17		      cpx	#CONTEXTLEN
    404  0d90		       90 f5		      bcc	ContextLDLoop
    405  0d92		       68		      pla
    406  0d93		       a8		      tay
    407  0d94		       60		      rts
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  0d95					      include	"support.asm"
      1  0d95							;
      2  0d95							;=====================================================
      3  0d95							;=====================================================
      4  0d95							;=====================================================
      5  0d95							; This marks the start of support functions used by
      6  0d95							; the IL opcodes.  These are support functions, NOT
      7  0d95							; the IL code.
      8  0d95							;=====================================================
      9  0d95							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  0d95							;=====================================================
     11  0d95					      Seg	Code
     12  0d95							;=====================================================
     13  0d95							; This gets the next two bytes pointed to by ILPC and
     14  0d95							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0d95							; is advanced by two, and Y contains 0 on return.
     16  0d95
     17  0d95							;
     18  0d95		       20 99 0d    getILWord  jsr	getILByte	;LSB
     19  0d98		       aa		      tax
     20  0d99							;
     21  0d99							;=====================================================
     22  0d99							; This gets the next byte pointed to by ILPC and
     23  0d99							; returns it in A.  On return, X is unchanged but Y
     24  0d99							; contains 0.
     25  0d99							;
     26  0d99		       a0 00	   getILByte  ldy	#0
     27  0d9b		       b1 43		      lda	(ILPC),y	;get byte
     28  0d9d		       08		      php		;save status
     29  0d9e		       e6 43		      inc	ILPC	;inc LSB
     30  0da0		       d0 02		      bne	getILb2	;branch if no overflow
     31  0da2		       e6 44		      inc	ILPC+1	;inc MSB
     32  0da4		       28	   getILb2    plp		;restore status
     33  0da5		       60		      rts
     34  0da6							;
     35  0da6							;=====================================================
     36  0da6							; Decrement ILPC by one.
     37  0da6							;
     38  0da6		       a5 43	   decIL      lda	ILPC
     39  0da8		       d0 02		      bne	decIL2
     40  0daa		       c6 44		      dec	ILPC+1
     41  0dac		       c6 43	   decIL2     dec	ILPC
     42  0dae		       60		      rts
     43  0daf							;
     44  0daf							;=====================================================
     45  0daf							; Push the ILPC onto the return stack.  Actually, this
     46  0daf							; pushes the address of ILPC+2 since that's the next
     47  0daf							; address to execute.
     48  0daf							;
     49  0daf		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  0db1		       a5 43		      lda	ILPC
     51  0db3		       18		      clc
     52  0db4		       69 02		      adc	#2
     53  0db6		       91 45		      sta	(ILSTACK),y
     54  0db8		       08		      php		;save C bit
     55  0db9		       c8		      iny
     56  0dba		       a5 44		      lda	ILPC+1
     57  0dbc		       28		      plp		;restore C
     58  0dbd		       69 00		      adc	#0
     59  0dbf		       91 45		      sta	(ILSTACK),y
     60  0dc1		       c8		      iny
     61  0dc2		       84 47		      sty	ILSTACKPTR
     62  0dc4		       60		      rts
     63  0dc5							;
     64  0dc5							;=====================================================
     65  0dc5							; Pull the top entry from return stack and put into
     66  0dc5							; ILPC.
     67  0dc5							;
     68  0dc5		       a4 47	   popILPC    ldy	ILSTACKPTR
     69  0dc7		       88		      dey
     70  0dc8		       b1 45		      lda	(ILSTACK),y
     71  0dca		       85 44		      sta	ILPC+1
     72  0dcc		       88		      dey
     73  0dcd		       b1 45		      lda	(ILSTACK),y
     74  0dcf		       85 43		      sta	ILPC
     75  0dd1		       84 47		      sty	ILSTACKPTR
     76  0dd3		       60		      rts
     77  0dd4							;
     78  0dd4							;=====================================================
     79  0dd4							; This searches for a specific line number that is in
     80  0dd4							; R0.	There are three possible return conditions:
     81  0dd4							; Line numbers are now the third byte, the first byte is now **************
     82  0dd4							; a pointer to the next line, of course no longer that 53 byte
     83  0dd4							; per line.
     84  0dd4							;
     85  0dd4							; Exact match was found:
     86  0dd4							;    * Z set
     87  0dd4							;    * CURPTR points to two-byte line number for that
     88  0dd4							;	line.
     89  0dd4							;
     90  0dd4							; Next highest line found:
     91  0dd4							;    * Z cleared
     92  0dd4							;    * C set
     93  0dd4							;    * CURPTR points to two-byte line number for that
     94  0dd4							;	line.
     95  0dd4							;
     96  0dd4							; End of program reached:
     97  0dd4							;    * Z cleared
     98  0dd4							;    * C cleared
     99  0dd4							;    * CURPTR points to first free byte at end of
    100  0dd4							;	program.  Ie, it has save value as PROGRAMEND.
    101  0dd4							;
    102  0dd4							; A, X, and Y are all undefined on return.
    103  0dd4							;
    104  0dd4
    105  0dd4				   findLine
    106  0dd4		       a9 37		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    107  0dd6		       85 4f		      sta	CURPTR
    108  0dd8		       a9 1f		      lda	#ProgramStart>>8
    109  0dda		       85 50		      sta	CURPTR+1
    110  0ddc							;
    111  0ddc							; At end of code?
    112  0ddc							;
    113  0ddc				   iXFER1
    114  0ddc		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    115  0dde		       cd 2f 1f 	      cmp	PROGRAMEND	; at end of program then stop run
    116  0de1		       d0 0b		      bne	xfer2	; not end
    117  0de3		       a5 50		      lda	CURPTR+1
    118  0de5		       cd 30 1f 	      cmp	PROGRAMEND+1
    119  0de8		       d0 04		      bne	xfer2	;Not at end
    120  0dea							;
    121  0dea							; Line not found and the end of the program was
    122  0dea							; reached.  Return Z and C both clear.
    123  0dea							;
    124  0dea		       a9 01		      lda	#1	;clear Z
    125  0dec		       18		      clc		;clear C
    126  0ded		       60		      rts
    127  0dee							;
    128  0dee							; Check for an exact line number match
    129  0dee							;
    130  0dee		       a5 52	   xfer2      lda	R0
    131  0df0		       a0 01		      ldy	#1	; changed to skip extra length byte
    132  0df2		       d1 4f		      cmp	(CURPTR),y
    133  0df4		       d0 08		      bne	xfernotit
    134  0df6		       c8		      iny
    135  0df7		       a5 53		      lda	R0+1
    136  0df9		       d1 4f		      cmp	(CURPTR),y
    137  0dfb		       d0 01		      bne	xfernotit	; not a matching line number
    138  0dfd							;
    139  0dfd							; This is exactly the line we want.
    140  0dfd							;
    141  0dfd		       60		      rts		;it matches exactly
    142  0dfe							;
    143  0dfe							; See if this line is greater than the one we're
    144  0dfe							; searching for.
    145  0dfe							;
    146  0dfe		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    147  0e00		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    148  0e02		       c5 53		      cmp	R0+1
    149  0e04		       90 0b		      bcc	xfer3
    150  0e06		       d0 07		      bne	xfer4
    151  0e08		       88		      dey
    152  0e09		       b1 4f		      lda	(CURPTR),y	;compare LSB
    153  0e0b		       c5 52		      cmp	R0
    154  0e0d		       90 02		      bcc	xfer3
    155  0e0f							;
    156  0e0f							; This line is greater than the one we want, so
    157  0e0f							; return Z clear and C set.
    158  0e0f							;
    159  0e0f		       38	   xfer4      sec		;We found a line number greater
    160  0e10		       60		      rts		;both conditions set
    161  0e11							;
    162  0e11							; Not the line (or droid) we're looking for.  Move to
    163  0e11							; the next line.
    164  0e11							;
    165  0e11		       20 17 0e    xfer3      jsr	FindNextLine
    166  0e14		       4c dc 0d 	      jmp	iXFER1
    167  0e17							;
    168  0e17							;=====================================================
    169  0e17							; This advances CURPTR to the next line.  If there
    170  0e17							; are no more lines, this leaves CURPTR equal to
    171  0e17							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    172  0e17							; CURPTR is pointing to a valid line on entry.  This
    173  0e17							; pointer points to the two-byte line number.
    174  0e17							; Update this points to the 1 byte line length  ****************
    175  0e17							;
    176  0e17				   FindNextLine
    177  0e17		       a0 03		      ldy	#3	;skip line number and length byte
    178  0e19		       84 51		      sty	CUROFF	;this is the new offset
    179  0e1b		       a0 00		      ldy	#0
    180  0e1d		       b1 4f		      lda	(CURPTR),y	;Get the length
    181  0e1f		       18		      clc
    182  0e20		       65 4f		      adc	CURPTR
    183  0e22		       85 4f		      sta	CURPTR
    184  0e24		       90 02		      bcc	FindNext4	;exit
    185  0e26		       e6 50		      inc	CURPTR+1
    186  0e28		       60	   FindNext4  rts
    187  0e29							;
    188  0e29							;=====================================================
    189  0e29							; This compares CURPTR to PROGRAMEND and returns Z set
    190  0e29							; if they are equal, Z clear if not.
    191  0e29							;
    192  0e29		       a5 4f	   AtEnd      lda	CURPTR
    193  0e2b		       cd 2f 1f 	      cmp	PROGRAMEND
    194  0e2e		       d0 05		      bne	atendexit
    195  0e30		       a5 50		      lda	CURPTR+1
    196  0e32		       cd 30 1f 	      cmp	PROGRAMEND+1
    197  0e35		       60	   atendexit  rts
    198  0e36							;
    199  0e36							;=====================================================
    200  0e36							; Print the contents of R0 as a signed decimal number.
    201  0e36							; Does leading zero suppression.
    202  0e36							;
    203  0e36				   PrintDecimal
    204  0e36		       a5 53		      lda	R0+1	;MSB has sign
    205  0e38		       10 17		      bpl	pplus	;it's a positive number
    206  0e3a							;
    207  0e3a							; Negative numbers need more work.  Invert all the bits,
    208  0e3a							; then add one.
    209  0e3a							;
    210  0e3a		       a9 2d		      lda	#'-
    211  0e3c		       20 a4 11 	      jsr	VOUTCH	;print the negative sign
    212  0e3f							;
    213  0e3f		       a5 52		      lda	R0	;invert bits
    214  0e41		       49 ff		      eor	#$ff
    215  0e43		       85 52		      sta	R0
    216  0e45		       a5 53		      lda	R0+1
    217  0e47		       49 ff		      eor	#$ff
    218  0e49		       85 53		      sta	R0+1
    219  0e4b		       e6 52		      inc	R0	;add one
    220  0e4d		       d0 02		      bne	pplus
    221  0e4f		       e6 53		      inc	R0+1
    222  0e51							;
    223  0e51							; Print the value in R0 as a positive number.
    224  0e51							;
    225  0e51		       a2 00	   pplus      ldx	#0	;start of subtraction table
    226  0e53		       8e 23 1f 	      stx	diddigit	;no digits yet
    227  0e56		       a0 00	   pploop     ldy	#0	;result of division
    228  0e58		       a5 52	   pploop2    lda	R0	;LSB
    229  0e5a		       38		      sec
    230  0e5b		       fd 9a 0e 	      sbc	dectable,x
    231  0e5e		       85 52		      sta	R0
    232  0e60		       a5 53		      lda	R0+1
    233  0e62		       fd 9b 0e 	      sbc	dectable+1,x
    234  0e65		       10 2e		      bpl	pplusok	;no underflow
    235  0e67							;
    236  0e67							; Else, underflow.  Add back in the LSB of the
    237  0e67							; table to R0.
    238  0e67							;
    239  0e67		       18		      clc
    240  0e68		       a5 52		      lda	R0
    241  0e6a		       7d 9a 0e 	      adc	dectable,x
    242  0e6d		       85 52		      sta	R0
    243  0e6f							;
    244  0e6f							; Print the value in Y.  Actually, see if Y is zero and
    245  0e6f							; whether any digit has been printed yet.  If Y isn't
    246  0e6f							; zero or we've printed a digit, go ahead and print.
    247  0e6f							;
    248  0e6f		       8e 20 1f 	      stx	printtx
    249  0e72		       98		      tya
    250  0e73		       09 00		      ora	#0	;set flags
    251  0e75		       d0 05		      bne	pprintit	;non-zero, print
    252  0e77							;
    253  0e77		       ad 23 1f 	      lda	diddigit
    254  0e7a		       f0 09		      beq	pprintno	;don't print
    255  0e7c							;
    256  0e7c		       98	   pprintit   tya
    257  0e7d		       09 30		      ora	#'0
    258  0e7f		       8d 23 1f 	      sta	diddigit
    259  0e82		       20 a4 11 	      jsr	VOUTCH
    260  0e85		       ae 20 1f    pprintno   ldx	printtx
    261  0e88							;
    262  0e88							; Move to the next table entry
    263  0e88							;
    264  0e88		       e8		      inx
    265  0e89		       e8		      inx
    266  0e8a		       e0 08		      cpx	#dectableend-dectable
    267  0e8c		       d0 c8		      bne	pploop	;not at end
    268  0e8e							;
    269  0e8e							; At the end.	R0 contains the final value
    270  0e8e							; to print.
    271  0e8e							;
    272  0e8e		       a5 52		      lda	R0
    273  0e90		       09 30		      ora	#'0
    274  0e92		       4c a4 11 	      jmp	VOUTCH
    275  0e95							;
    276  0e95							; Finish doing the subtraction.
    277  0e95							;
    278  0e95		       85 53	   pplusok    sta	R0+1
    279  0e97		       c8		      iny
    280  0e98		       d0 be		      bne	pploop2
    281  0e9a							;
    282  0e9a							; Table of powers-of-ten
    283  0e9a							;
      0  0e9a				   dectable   dw	10000
      1  0e9a		       10 27		      .word.w	10000
      0  0e9c					      dw	1000
      1  0e9c		       e8 03		      .word.w	1000
      0  0e9e					      dw	100
      1  0e9e		       64 00		      .word.w	100
      0  0ea0					      dw	10
      1  0ea0		       0a 00		      .word.w	10
    288  0ea0		       0e a2	   dectableend equ	*
    289  0ea2							;
    290  0ea2							;=====================================================
    291  0ea2							; Convert an ASCII string to a number.  On input,
    292  0ea2							; (CURPTR),Y points to the first digit.  This gets
    293  0ea2							; digit-by-digit until finding a non-number.  Returns
    294  0ea2							; Y pointing to the non-digit, and R0 contains the
    295  0ea2							; number.  This does NOT check for valid ranges, so
    296  0ea2							; a value like "123456789" will produce something,
    297  0ea2							; but not what you had expected.
    298  0ea2							;
    299  0ea2		       a9 00	   getDecimal lda	#0
    300  0ea4		       85 52		      sta	R0
    301  0ea6		       85 53		      sta	R0+1
    302  0ea8		       85 58		      sta	dpl	;temporary negative flag
    303  0eaa							;
    304  0eaa							; See if it's negative...
    305  0eaa							;
    306  0eaa		       84 13		      sty	$0013
    307  0eac		       b1 4f		      lda	(CURPTR),y
    308  0eae		       c9 2d		      cmp	#'-
    309  0eb0		       d0 02		      bne	getDecLoop
    310  0eb2		       e6 58		      inc	dpl	;it's negative
    311  0eb4							;
    312  0eb4		       b1 4f	   getDecLoop lda	(CURPTR),y
    313  0eb6		       c9 30		      cmp	#'0
    314  0eb8		       90 36		      bcc	getDdone
    315  0eba		       c9 3a		      cmp	#'9+1
    316  0ebc		       b0 32		      bcs	getDdone
    317  0ebe		       38		      sec
    318  0ebf		       e9 30		      sbc	#'0	;convert to binary
    319  0ec1		       48		      pha
    320  0ec2							;
    321  0ec2							; Now multiply R0 by 10.  Remember that
    322  0ec2							; 2*N + 8*N = 10*N.
    323  0ec2							;
    324  0ec2		       06 52		      asl	R0
    325  0ec4		       26 53		      rol	R0+1	;*2
    326  0ec6		       a5 52		      lda	R0
    327  0ec8		       85 54		      sta	R1
    328  0eca		       a5 53		      lda	R0+1
    329  0ecc		       85 55		      sta	R1+1
    330  0ece		       06 52		      asl	R0
    331  0ed0		       26 53		      rol	R0+1	;*4
    332  0ed2		       06 52		      asl	R0
    333  0ed4		       26 53		      rol	R0+1	;*8
    334  0ed6		       18		      clc		;now add the partial sums...
    335  0ed7		       a5 52		      lda	R0	;...to get *10
    336  0ed9		       65 54		      adc	R1
    337  0edb		       85 52		      sta	R0
    338  0edd		       a5 53		      lda	R0+1
    339  0edf		       65 55		      adc	R1+1
    340  0ee1		       85 53		      sta	R0+1
    341  0ee3							;
    342  0ee3							; Add in the new digit
    343  0ee3							;
    344  0ee3		       68		      pla
    345  0ee4		       18		      clc
    346  0ee5		       65 52		      adc	R0
    347  0ee7		       85 52		      sta	R0
    348  0ee9		       90 02		      bcc	getD2
    349  0eeb		       e6 53		      inc	R0+1
    350  0eed							;
    351  0eed							; Move to next character
    352  0eed							;
    353  0eed		       c8	   getD2      iny
    354  0eee		       d0 c4		      bne	getDecLoop
    355  0ef0							;
    356  0ef0							; All done with digits, so now deal with it being
    357  0ef0							; negative.  If zero, then don't check for negative
    358  0ef0							; flag.  Ie, -0 is stored as 0.
    359  0ef0							;
    360  0ef0		       a5 52	   getDdone   lda	R0
    361  0ef2		       05 53		      ora	R0+1
    362  0ef4		       f0 16		      beq	getDone2	;zero
    363  0ef6		       a5 58		      lda	dpl
    364  0ef8		       f0 12		      beq	getDone2	;positive
    365  0efa							;
    366  0efa							; Invert all the bits, then add one.
    367  0efa							;
    368  0efa		       a5 52		      lda	R0
    369  0efc		       49 ff		      eor	#$ff
    370  0efe		       85 52		      sta	R0
    371  0f00		       a5 53		      lda	R0+1
    372  0f02		       49 ff		      eor	#$ff
    373  0f04		       85 53		      sta	R0+1
    374  0f06							;
    375  0f06		       e6 52		      inc	R0
    376  0f08		       d0 02		      bne	getDone2
    377  0f0a		       e6 53		      inc	R0+1
    378  0f0c				   getDone2
    379  0f0c		       a5 52		      lda	R0
    380  0f0e		       85 10		      sta	$0010
    381  0f10		       a5 53		      lda	R0+1
    382  0f12		       85 11		      sta	$0011
    383  0f14		       a5 58		      lda	dpl
    384  0f16		       85 12		      sta	$012
    385  0f18
    386  0f18		       60		      rts
    387  0f19							;
    388  0f19							;=====================================================
    389  0f19							; Print the string that immediately follows the JSR to
    390  0f19							; this function.  Stops when a null byte is found,
    391  0f19							; then returns to the instruction immediately
    392  0f19							; following the null.
    393  0f19							;
    394  0f19							; Thanks to Ross Archer for this code.
    395  0f19							; http://www.6502.org/source/io/primm.htm
    396  0f19							;
    397  0f19				  -	      if	KIM
    398  0f19				  -puts       sty	putsy
    399  0f19				  -	      pla		;low part of "return" address
    400  0f19				  -			;(data start address)
    401  0f19				  -	      sta	dpl
    402  0f19				  -	      pla
    403  0f19				  -	      sta	dpl+1	;high part of "return" address
    404  0f19				  -			;(data start address)
    405  0f19				  -			;Note: we're pointing one short
    406  0f19				  -psinb      ldy	#1
    407  0f19				  -	      lda	(dpl),y	;Get next string character
    408  0f19				  -	      inc	dpl	;update the pointer
    409  0f19				  -	      bne	psinc	;if not, we're pntng to next char
    410  0f19				  -	      inc	dpl+1	;account for page crossing
    411  0f19				  -psinc      ora	#0	;Set flags according to contents of
    412  0f19				  -			;   Accumulator
    413  0f19				  -	      beq	psix1	;don't print the final NULL
    414  0f19				  -	      jsr	OUTCH	;write it out
    415  0f19				  -	      jmp	psinb	;back around
    416  0f19				  -psix1      inc	dpl
    417  0f19				  -	      bne	psix2
    418  0f19				  -	      inc	dpl+1	;account for page crossing
    419  0f19				  -psix2      ldy	putsy
    420  0f19				  -	      jmp	(dpl)	;return to byte following NULL
    421  0f19					      endif
    422  0f19							;
    423  0f19							;=====================================================
    424  0f19							; Gets a line of input into LINBUF.
    425  0f19							;
    426  0f19							; On entry:
    427  0f19							;    A contains the prompt character, or 0 if none.
    428  0f19							;    X = 1 Background read
    429  0f19							;    x = 0 Forground read with wait
    430  0f19							;
    431  0f19							; On exit:
    432  0f19							;    CURPTR points to LINBUF
    433  0f19							;    LINBUF contains the line with 0 at the end.
    434  0f19							;    Y has offset to first non-space character
    435  0f19							;    CURROFF has the same as Y.
    436  0f19							;
    437  0f19		       20 68 0f    GetLine    jsr	ReadPrompt
    438  0f1c		       e0 00		      cpx	#0
    439  0f1e		       f0 14		      beq	GetLineRetry
    440  0f20		       ae db 16 	      ldx	taskPtr
    441  0f23		       bd dc 16 	      lda	taskTable,x
    442  0f26		       c9 03		      cmp	#$03	;Task Active and waiting for IO
    443  0f28		       f0 3d		      beq	taskWaitingIO
    444  0f2a		       09 02		      ora	#$02	;Mark Task as waiting for IO
    445  0f2c		       9d dc 16 	      sta	taskTable,x	;Mark the state for task as waiting io
    446  0f2f		       ce 67 0f 	      dec	taskWaitingIO	;Start polling the input and make task wait
    447  0f32		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    448  0f34
    449  0f34							;
    450  0f34							; Now read a line and wait for the CR
    451  0f34							;
    452  0f34				   GetLineRetry
    453  0f34		       a9 00		      lda	#0	;Wait for input to complete
    454  0f36		       20 80 0f 	      jsr	ReadLine
    455  0f39
    456  0f39							;
    457  0f39							; Point to the line we just read
    458  0f39							; Set the current pointer to point to the input line
    459  0f39							;
    460  0f39		       a0 00	   ReadComplete ldy	#0
    461  0f3b		       84 51		      sty	CUROFF
    462  0f3d		       a2 9b		      ldx	#LINBUF&$ff
    463  0f3f		       86 4f		      stx	CURPTR
    464  0f41		       a2 1e		      ldx	#LINBUF>>8
    465  0f43		       86 50		      stx	CURPTR+1
    466  0f45							;
    467  0f45							; Output a CR/LF
    468  0f45							;
    469  0f45		       20 0c 02 	      jsr	CRLF
    470  0f48							;
    471  0f48							; If a blank line, prompt again.
    472  0f48							;
    473  0f48		       20 18 11 	      jsr	SkipSpaces
    474  0f4b		       b1 4f		      lda	(CURPTR),y
    475  0f4d		       d0 10		      bne	GetLineDone	;We have data then exit
    476  0f4f		       20 6b 0f 	      jsr	ReadPromptRetry
    477  0f52		       ae db 16 	      ldx	taskPtr	;if this task is waiting for IO
    478  0f55		       bd dc 16 	      lda	taskTable,x	;then get out, wait for line to
    479  0f58		       c9 03		      cmp	#3	;Complete again
    480  0f5a		       f0 0b		      beq	taskWaitingIO
    481  0f5c		       4c 34 0f 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    482  0f5f
    483  0f5f				   GetLineDone
    484  0f5f		       ae db 16 	      ldx	taskPtr
    485  0f62		       a9 01		      lda	#1
    486  0f64		       9d dc 16 	      sta	taskTable,x	;IO is complete
    487  0f67
    488  0f67				   taskWaitingIO
    489  0f67		       60		      rts
    490  0f68
    491  0f68							;
    492  0f68							;=======================================================================
    493  0f68							; Display the prompt character
    494  0f68							; On entry
    495  0f68							;	    A contains the prompt character
    496  0f68							; On exit
    497  0f68							;	    The readbuffer index is reset to 0
    498  0f68							;
    499  0f68		       8d 22 1f    ReadPrompt sta	promptChar
    500  0f6b
    501  0f6b							;
    502  0f6b							; Prompt
    503  0f6b							;
    504  0f6b
    505  0f6b		       ad 22 1f    ReadPromptRetry lda	promptChar
    506  0f6e		       09 00		      ora	#0	;any prompt?
    507  0f70		       f0 08		      beq	getlinenp
    508  0f72		       20 06 02 	      jsr	OUTCH
    509  0f75		       a9 20		      lda	#$20
    510  0f77		       20 06 02 	      jsr	OUTCH	;Space after prompt
    511  0f7a							;
    512  0f7a		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    513  0f7c		       8e 1f 1f 	      stx	getlinx
    514  0f7f		       60		      rts
    515  0f80							;
    516  0f80							;===============================================================
    517  0f80							; This fuction is the driver for the line input
    518  0f80							; on call if a = 0 then it waits for all input
    519  0f80							;	      a = 1 then nowait for input
    520  0f80							; On exit
    521  0f80							;		       c clear if not complete line
    522  0f80							;		       c set if it was a complete line
    523  0f80
    524  0f80				   ReadLine
    525  0f80		       8d 21 1f 	      sta	inputNoWait
    526  0f83		       c9 00		      cmp	#0
    527  0f85		       f0 05		      beq	getline1
    528  0f87		       20 15 02 	      jsr	ISCHAR	; if there is no character just get out
    529  0f8a		       f0 2b		      beq	GetLineNoWait
    530  0f8c		       20 09 02    getline1   jsr	GETCH
    531  0f8f					      if	CTMON65
    532  0f8f		       48		      pha
    533  0f90		       20 0c f0 	      jsr	cout	;echo echo echo
    534  0f93		       68		      pla
    535  0f94					      endif
    536  0f94		       c9 0d		      cmp	#CR
    537  0f96		       f0 15		      beq	getlind	;end of line
    538  0f98		       c9 08		      cmp	#BS	;backspace?
    539  0f9a		       f0 1d		      beq	getlinebs
    540  0f9c		       ae 1f 1f 	      ldx	getlinx
    541  0f9f		       9d 9b 1e 	      sta	LINBUF,x
    542  0fa2		       e8		      inx
    543  0fa3		       8e 1f 1f 	      stx	getlinx
    544  0fa6		       ad 21 1f 	      lda	inputNoWait
    545  0fa9		       f0 e1		      beq	getline1
    546  0fab		       d0 0a		      bne	GetLineNoWait
    547  0fad							;
    548  0fad							; CR was hit
    549  0fad							;
    550  0fad		       a9 00	   getlind    lda	#0	; set the end pf buffer
    551  0faf		       ae 1f 1f 	      ldx	getlinx
    552  0fb2		       9d 9b 1e 	      sta	LINBUF,x
    553  0fb5
    554  0fb5		       38		      sec		; Carry set then cr received
    555  0fb6		       60		      rts
    556  0fb7
    557  0fb7				   GetLineNoWait
    558  0fb7		       18		      clc		; Carry clear no end of line
    559  0fb8		       60		      rts
    560  0fb9							;
    561  0fb9							; Backspace was hit
    562  0fb9							;
    563  0fb9		       ae 1f 1f    getlinebs  ldx	getlinx
    564  0fbc		       f0 0e		      beq	getlineEOL	;at start of line
    565  0fbe		       ca		      dex
    566  0fbf		       8e 1f 1f 	      stx	getlinx
    567  0fc2		       20 12 f0    getlinepbs jsr	puts
      0  0fc5					      db	27,"[K",0
      1  0fc5		       1b 5b 4b 00	      .byte.b	27,"[K",0
    569  0fc9		       4c 8c 0f 	      jmp	getline1
    570  0fcc		       a9 20	   getlineEOL lda	#SPACE
    571  0fce		       20 06 02 	      jsr	OUTCH
    572  0fd1		       d0 ef		      bne	getlinepbs
    573  0fd3							;
    574  0fd3							;=====================================================
    575  0fd3							; Count the length of the line currently in LINBUF
    576  0fd3							; starting at offset Y.  Returns the length in X.  The
    577  0fd3							; starting offset in Y should point past the ASCII
    578  0fd3							; line number.  Also counts the trailing NULL and two
    579  0fd3							; extra bytes for where the line number will be.
    580  0fd3							; Update must now include leading length byte not the null at end ****************
    581  0fd3							;
    582  0fd3				   getLineLength
    583  0fd3		       a2 00		      ldx	#0	;size
    584  0fd5		       b9 9b 1e    getLineL2  lda	LINBUF,y
    585  0fd8		       f0 04		      beq	getLineL3
    586  0fda		       c8		      iny
    587  0fdb		       e8		      inx
    588  0fdc		       d0 f7		      bne	getLineL2
    589  0fde		       e8	   getLineL3  inx		;count null at end
    590  0fdf		       e8		      inx		;line number LSB
    591  0fe0		       e8		      inx		;MSB
    592  0fe1		       e8		      inx		;change: count new leading line length
    593  0fe2		       86 5e		      stx	lineLength
    594  0fe4		       60		      rts
    595  0fe5							;
    596  0fe5							;=====================================================
    597  0fe5							; Count the length of the line pointed to by CURPTR.
    598  0fe5							; This also counts the line number and the terminating
    599  0fe5							; null.  Ie, this string returns 8:
    600  0fe5							;
    601  0fe5							; <lineLow><lineHi>Hello<null>
    602  0fe5							;
    603  0fe5							; Another way of looking at it: add the return value
    604  0fe5							; to the CURPTR and it'll point to the next line's
    605  0fe5							; line number.  Returns the value in Y.
    606  0fe5							; Update to ject get the leading byte length ********************
    607  0fe5							;
    608  0fe5							;getCURPTRLength
    609  0fe5							;		ldy	CURPTR
    610  0fe5							;		ldy	#3	;change: skip line number and leading length byte
    611  0fe5							;getCLineL2	lda	(CURPTR),y
    612  0fe5							;		beq	getCLineL3
    613  0fe5							;		iny
    614  0fe5							;		bne	getCLineL2
    615  0fe5							;getCLineL3	iny		;count null at end
    616  0fe5							;		rts
    617  0fe5
    618  0fe5							;
    619  0fe5							;=====================================================
    620  0fe5							; This saves ILPC.  This saves to a single save area,
    621  0fe5							; so it can't be called more than once.
    622  0fe5							;
    623  0fe5		       a5 43	   saveIL     lda	ILPC
    624  0fe7		       85 5a		      sta	tempIL
    625  0fe9		       a5 44		      lda	ILPC+1
    626  0feb		       85 5b		      sta	tempIL+1
    627  0fed		       60		      rts
    628  0fee							;
    629  0fee							;=====================================================
    630  0fee							; This restores ILPC.
    631  0fee							;
    632  0fee		       a5 5a	   restoreIL  lda	tempIL
    633  0ff0		       85 43		      sta	ILPC
    634  0ff2		       a5 5b		      lda	tempIL+1
    635  0ff4		       85 44		      sta	ILPC+1
    636  0ff6		       60		      rts
    637  0ff7							;
    638  0ff7							;=====================================================
    639  0ff7							; This pushes R0 onto the stack.
    640  0ff7							;
    641  0ff7		       8c 28 1f    pushR0     sty	rtemp1
    642  0ffa		       a4 4a		      ldy	MATHSTACKPTR
    643  0ffc		       a5 52		      lda	R0
    644  0ffe		       91 48		      sta	(MATHSTACK),y
    645  1000		       c8		      iny
    646  1001		       a5 53		      lda	R0+1
    647  1003		       91 48		      sta	(MATHSTACK),y
    648  1005		       c8		      iny
    649  1006		       84 4a		      sty	MATHSTACKPTR
    650  1008		       ac 28 1f 	      ldy	rtemp1
    651  100b		       60		      rts
    652  100c
    653  100c							;=====================================================
    654  100c							; This pushes curptr basic current line onto the call stack.
    655  100c							; and CUROFF. Also marks entry type as 1 = GOSUB
    656  100c
    657  100c				   pushLN
    658  100c		       8c 28 1f 	      sty	rtemp1
    659  100f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    660  1011		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; Is there space available
    661  1013		       f0 18		      beq	pusherr	; No error
    662  1015		       a2 00		      ldx	#0	; Start of bytes to copy
    663  1017				   pushLoop
    664  1017		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    665  1019		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    666  101b		       c8		      iny		; Next destination
    667  101c		       e8		      inx		; Next Source byte
    668  101d		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    669  101f		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    670  1021
    671  1021		       a9 01	   pushDone   lda	#1	; Type of stack entry, 1 gosub, 2 for , 3 next
    672  1023		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    673  1025		       c8		      iny		; Next entry
    674  1026
    675  1026		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    676  1028		       ac 28 1f 	      ldy	rtemp1
    677  102b		       18		      clc
    678  102c		       60		      rts
    679  102d				   pusherr
    680  102d		       38		      sec
    681  102e		       60		      rts
    682  102f							;=====================================================
    683  102f							; This pops Top Off gosub call Stack and
    684  102f							; places it in CURPTR/CUROFF.
    685  102f							; This checks if the type = 1 GOSUB
    686  102f							; if not it removes what ever is on the stack
    687  102f							; until it finds the next return. Allowing
    688  102f							; a return from within a for/next
    689  102f		       8c 28 1f    popLN      sty	rtemp1
    690  1032		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    691  1034		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    692  1036
    693  1036				   popContinue
    694  1036		       c0 04		      cpy	#4	; if less than 4 on stack then error
    695  1038		       90 18		      bcc	poperr	; Process an error
    696  103a
    697  103a		       88		      dey		; Position to read entry type
    698  103b		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    699  103d		       c9 01		      cmp	#1	; Type is a gosub entry
    700  103f		       d0 13		      bne	popSkipEntry	; No then just skip this
    701  1041
    702  1041				   popLoop
    703  1041		       88		      dey
    704  1042		       ca		      dex
    705  1043		       b1 4b		      lda	(GOSUBSTACK),y
    706  1045		       95 4f		      sta	CURPTR,x
    707  1047		       e0 00		      cpx	#0
    708  1049		       d0 f6		      bne	popLoop	; Loop until all moved
    709  104b
    710  104b
    711  104b		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    712  104d		       ac 28 1f 	      ldy	rtemp1
    713  1050		       18		      clc
    714  1051		       60		      rts
    715  1052		       38	   poperr     sec
    716  1053		       60		      rts
    717  1054
    718  1054		       88	   popSkipEntry dey
    719  1055		       88		      dey
    720  1056		       88		      dey
    721  1057		       4c 36 10 	      jmp	popContinue
    722  105a
    723  105a							;
    724  105a							;=====================================================
    725  105a							; This pushes R1 onto the stack
    726  105a							;
    727  105a		       8c 28 1f    pushR1     sty	rtemp1
    728  105d		       a4 4a		      ldy	MATHSTACKPTR
    729  105f		       a5 54		      lda	R1
    730  1061		       91 48		      sta	(MATHSTACK),y
    731  1063		       c8		      iny
    732  1064		       a5 55		      lda	R1+1
    733  1066		       91 48		      sta	(MATHSTACK),y
    734  1068		       c8		      iny
    735  1069		       84 4a		      sty	MATHSTACKPTR
    736  106b		       ac 28 1f 	      ldy	rtemp1
    737  106e		       60		      rts
    738  106f							;
    739  106f							;=====================================================
    740  106f							; This pops Top Of Stack and places it in R0.
    741  106f							;
    742  106f		       8c 28 1f    popR0      sty	rtemp1
    743  1072		       a4 4a		      ldy	MATHSTACKPTR
    744  1074		       88		      dey
    745  1075		       b1 48		      lda	(MATHSTACK),y
    746  1077		       85 53		      sta	R0+1
    747  1079		       88		      dey
    748  107a		       b1 48		      lda	(MATHSTACK),y
    749  107c		       85 52		      sta	R0
    750  107e		       84 4a		      sty	MATHSTACKPTR
    751  1080		       ac 28 1f 	      ldy	rtemp1
    752  1083		       60		      rts
    753  1084
    754  1084							;
    755  1084							;=====================================================
    756  1084							; This pops TOS and places it in R1.
    757  1084							;
    758  1084		       8c 28 1f    popR1      sty	rtemp1
    759  1087		       a4 4a		      ldy	MATHSTACKPTR
    760  1089		       88		      dey
    761  108a		       b1 48		      lda	(MATHSTACK),y
    762  108c		       85 55		      sta	R1+1
    763  108e		       88		      dey
    764  108f		       b1 48		      lda	(MATHSTACK),y
    765  1091		       85 54		      sta	R1
    766  1093		       84 4a		      sty	MATHSTACKPTR
    767  1095		       ac 28 1f 	      ldy	rtemp1
    768  1098		       60		      rts
    769  1099							;
    770  1099							;=====================================================
    771  1099							; This pops TOS and places it in MQ.
    772  1099							;
    773  1099		       8c 28 1f    popMQ      sty	rtemp1
    774  109c		       a4 4a		      ldy	MATHSTACKPTR
    775  109e		       88		      dey
    776  109f		       b1 48		      lda	(MATHSTACK),y
    777  10a1		       85 57		      sta	MQ+1
    778  10a3		       88		      dey
    779  10a4		       b1 48		      lda	(MATHSTACK),y
    780  10a6		       85 56		      sta	MQ
    781  10a8		       84 4a		      sty	MATHSTACKPTR
    782  10aa		       ac 28 1f 	      ldy	rtemp1
    783  10ad		       60		      rts
    784  10ae							;
    785  10ae							;=====================================================
    786  10ae							; This assists with multiplication and division by
    787  10ae							; looking at R0 and R1 and saving a flag as to what
    788  10ae							; sign the result will be.  Math is always done on
    789  10ae							; positive numbers, so this converts negative numbers
    790  10ae							; into positives.  On exit, R0 and R1 are both
    791  10ae							; positive.  If the signs were different then 'signs'
    792  10ae							; will be non-zero.
    793  10ae							;
    794  10ae		       a9 00	   SaveSigns  lda	#0
    795  10b0		       8d 27 1f 	      sta	sign	;assume positive
    796  10b3		       a5 53		      lda	R0+1	;MSB
    797  10b5		       10 13		      bpl	SaveSigns1
    798  10b7		       ee 27 1f 	      inc	sign	;it's negative
    799  10ba		       49 ff		      eor	#$ff	;flip bits
    800  10bc		       85 53		      sta	R0+1
    801  10be		       a5 52		      lda	R0
    802  10c0		       49 ff		      eor	#$ff
    803  10c2		       85 52		      sta	R0
    804  10c4		       e6 52		      inc	R0
    805  10c6		       d0 02		      bne	SaveSigns1
    806  10c8		       e6 53		      inc	R0+1
    807  10ca		       a5 55	   SaveSigns1 lda	R1+1
    808  10cc		       10 1a		      bpl	SaveSigns2
    809  10ce		       48		      pha
    810  10cf		       ad 27 1f 	      lda	sign
    811  10d2		       49 01		      eor	#1
    812  10d4		       8d 27 1f 	      sta	sign
    813  10d7		       68		      pla
    814  10d8		       49 ff		      eor	#$ff	;flip bits
    815  10da		       85 55		      sta	R1+1
    816  10dc		       a5 54		      lda	R1
    817  10de		       49 ff		      eor	#$ff
    818  10e0		       85 54		      sta	R1
    819  10e2		       e6 54		      inc	R1
    820  10e4		       d0 02		      bne	SaveSigns2
    821  10e6		       e6 55		      inc	R1+1
    822  10e8		       60	   SaveSigns2 rts
    823  10e9							;
    824  10e9							;=====================================================
    825  10e9							; This looks at the value of 'signs' and will convert
    826  10e9							; both R0 and R1 to negative if set.
    827  10e9							;
    828  10e9				   RestoreSigns
    829  10e9		       ad 27 1f 	      lda	sign
    830  10ec		       f0 28		      beq	restoresigns2
    831  10ee							;
    832  10ee		       a5 52		      lda	R0
    833  10f0		       d0 02		      bne	restoresigns3
    834  10f2		       c6 53		      dec	R0+1
    835  10f4				   restoresigns3
    836  10f4		       c6 52		      dec	R0
    837  10f6		       a5 52		      lda	R0
    838  10f8		       49 ff		      eor	#$ff
    839  10fa		       85 52		      sta	R0
    840  10fc		       a5 53		      lda	R0+1
    841  10fe		       49 ff		      eor	#$ff
    842  1100		       85 53		      sta	R0+1
    843  1102							;
    844  1102		       a5 54		      lda	R1
    845  1104		       d0 02		      bne	restoresigns4
    846  1106		       c6 55		      dec	R1+1
    847  1108				   restoresigns4
    848  1108		       c6 54		      dec	R1
    849  110a		       a5 54		      lda	R1
    850  110c		       49 ff		      eor	#$ff
    851  110e		       85 54		      sta	R1
    852  1110		       a5 55		      lda	R1+1
    853  1112		       49 ff		      eor	#$ff
    854  1114		       85 55		      sta	R1+1
    855  1116							;
    856  1116				   restoresigns2
    857  1116		       60		      rts
    858  1117							;
    859  1117							;=====================================================
    860  1117							; Skip over spaces.  Returns Y with the offset to
    861  1117							; either the last character in the line, or the first
    862  1117							; non-space character.
    863  1117							;
    864  1117		       c8	   skipsp2    iny
    865  1118		       b1 4f	   SkipSpaces lda	(CURPTR),y
    866  111a		       f0 04		      beq	Skip3	;end of line
    867  111c		       c9 20		      cmp	#SPACE
    868  111e		       f0 f7		      beq	skipsp2
    869  1120		       60	   Skip3      rts
    870  1121							;
    871  1121							;=====================================================
    872  1121							; This is some debug logic which displays the current
    873  1121							; value of the ILPC and the line buffer.
    874  1121							;
    875  1121		       20 12 f0    dbgLine    jsr	puts
      0  1124					      db	"ILPC: ",0
      1  1124		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    877  112b		       a5 44		      lda	ILPC+1
    878  112d		       20 0f 02 	      jsr	OUTHEX
    879  1130		       a5 43		      lda	ILPC
    880  1132		       20 0f 02 	      jsr	OUTHEX
    881  1135		       a9 20		      lda	#SPACE
    882  1137		       20 06 02 	      jsr	OUTCH
    883  113a		       a0 00		      ldy	#0
    884  113c		       b1 43		      lda	(ILPC),y
    885  113e		       20 0f 02 	      jsr	OUTHEX
    886  1141							;
    887  1141							; Display the CURPTR value and offset
    888  1141							;
    889  1141		       20 12 f0 	      jsr	puts
      0  1144					      db	", CURPTR: ",0
      1  1144		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    891  114f		       a5 50		      lda	CURPTR+1
    892  1151		       20 0f 02 	      jsr	OUTHEX
    893  1154		       a5 4f		      lda	CURPTR
    894  1156		       20 0f 02 	      jsr	OUTHEX
    895  1159		       a9 2b		      lda	#'+
    896  115b		       20 06 02 	      jsr	OUTCH
    897  115e		       a5 51		      lda	CUROFF
    898  1160		       20 0f 02 	      jsr	OUTHEX
    899  1163							;
    900  1163		       4c 0c 02 	      jmp	CRLF
    901  1166							;
    902  1166							;=====================================================
    903  1166							; This function might go away eventually, but was
    904  1166							; added to provide data for other pieces of code.
    905  1166							; It has some ties to the operating environment that
    906  1166							; will need to be customized for the target system.
    907  1166							;
    908  1166				   GetSizes
    909  1166							;
    910  1166							; Here is machine specific code to get the highest
    911  1166							; memory location that can be used by BASIC.
    912  1166							;
    913  1166					      if	ProgramStart < $2000
    914  1166		       a9 ff		      lda	#$ff
    915  1168		       8d 31 1f 	      sta	HighMem	;$13ff for KIM-1
    916  116b		       a9 de		      lda	#$DE	;#$13
    917  116d		       8d 32 1f 	      sta	HighMem+1
    918  1170				  -	      else
    919  1170				  -	      lda	#$ff
    920  1170				  -	      sta	HighMem	;$CFFF otherwise
    921  1170				  -	      lda	#$cf
    922  1170				  -	      sta	HighMem+1
    923  1170					      endif
    924  1170							;
    925  1170							; This computes the available memory remaining.
    926  1170							;
    927  1170		       38		      sec
    928  1171		       ad 31 1f 	      lda	HighMem
    929  1174		       ed 2f 1f 	      sbc	PROGRAMEND
    930  1177		       8d 35 1f 	      sta	FreeMem
    931  117a		       85 52		      sta	R0
    932  117c		       ad 32 1f 	      lda	HighMem+1
    933  117f		       ed 30 1f 	      sbc	PROGRAMEND+1
    934  1182		       8d 36 1f 	      sta	FreeMem+1
    935  1185		       85 53		      sta	R0+1
    936  1187							;
    937  1187							; This computes the size of the current user program.
    938  1187							;
    939  1187		       38		      sec
    940  1188		       ad 2f 1f 	      lda	PROGRAMEND
    941  118b		       e9 37		      sbc	#ProgramStart&$ff
    942  118d		       8d 33 1f 	      sta	UsedMem
    943  1190		       ad 30 1f 	      lda	PROGRAMEND+1
    944  1193		       e9 1f		      sbc	#ProgramStart>>8
    945  1195		       8d 34 1f 	      sta	UsedMem+1
    946  1198							;
    947  1198		       60		      rts
    948  1199							;
    949  1199							;=====================================================
    950  1199							; Set output vector to the console output function
    951  1199							;
    952  1199				   SetOutConsole
    953  1199		       a9 06		      lda	#OUTCH&$ff
    954  119b		       8d 2c 1f 	      sta	BOutVec
    955  119e		       a9 02		      lda	#OUTCH/256
    956  11a0		       8d 2d 1f 	      sta	BOutVec+1
    957  11a3		       60		      rts
    958  11a4							;
    959  11a4							;=====================================================
    960  11a4							; Jump to the output function in BOutVec
    961  11a4							;
    962  11a4		       6c 2c 1f    VOUTCH     jmp	(BOutVec)
    963  11a7
    964  11a7							;====================================================
    965  11a7		       1f 28	   PrtTerm    equ	rtemp1
    966  11a7
    967  11a7							; Print Y has the offset to use
    968  11a7		       a5 4f	   PrtQuoted  lda	CURPTR
    969  11a9		       85 62		      sta	PrtFrom
    970  11ab		       a5 50		      lda	CURPTR+1
    971  11ad		       85 63		      sta	PrtFrom+1
    972  11af		       a9 22		      lda	#'"
    973  11b1		       8d 28 1f 	      sta	PrtTerm
    974  11b4		       4c c0 11 	      jmp	PrtLoop
    975  11b7
    976  11b7							; Print a string pointed to by x= h, y=l terminated by a
    977  11b7							; Return y as the length
    978  11b7
    979  11b7		       86 63	   PrtStr     stx	PrtFrom+1
    980  11b9		       84 62		      sty	PrtFrom
    981  11bb		       8d 28 1f 	      sta	PrtTerm
    982  11be		       a0 00		      ldy	#0
    983  11c0
    984  11c0		       b1 62	   PrtLoop    lda	(PrtFrom),y
    985  11c2		       cd 28 1f 	      cmp	PrtTerm
    986  11c5		       f0 0b		      beq	PrtEnd
    987  11c7		       c9 00		      cmp	#0	; always end if 0 is found
    988  11c9		       f0 07		      beq	PrtEnd
    989  11cb		       20 06 02 	      jsr	OUTCH
    990  11ce		       c8		      iny
    991  11cf		       4c c0 11 	      jmp	PrtLoop
    992  11d2		       c8	   PrtEnd     iny		;return byte after the copy
    993  11d3		       60		      rts
    994  11d4
    995  11d4							;====================================================
    996  11d4							;Clear the terminal assume it is ansii or vt100
    997  11d4							;
    998  11d4				   iCLEARSCREEN
    999  11d4		       20 12 f0 	      jsr	puts
      0  11d7					      db	$1b,'[,'3,'J,0
      1  11d7		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
   1001  11dc		       4c ea 02 	      jmp	NextIL
------- FILE mytb.asm
   2005  11df
   2006  11df					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  11df					      include	"storage.asm"
      1  11df							;
      2  11df							;=====================================================
      3  11df							;=====================================================
      4  11df							;=====================================================
      5  11df							; This file contains the functions for saving and
      6  11df							; restoring programs from some sort of mass storage
      7  11df							; device.  This particular version is for using the
      8  11df							; Corsham Tech SD Card System.
      9  11df							;=====================================================
     10  11df							;=====================================================
     11  11df							;=====================================================
     12  11df
     13 U16c6					      seg.u	TBData
     14 U16c6		       00	   diskBufLength ds	1
     15 U16c7		       00	   diskBufOffset ds	1
     16 U16c8		       00 00 00 00*DiskFileName ds	14
     17 U16d6
     18  11df					      SEG	Code
     19  11df
     20  11df							;
     21  11df							;=====================================================
     22  11df							; Open a file for reading as a program.  The next
     23  11df							; thing on the line should be the filename.
     24  11df							;
     25  11df				   iOPENREAD
     26  11df					      if	XKIM || CTMON65
     27  11df		       a4 51		      ldy	CUROFF
     28  11e1		       b1 4f		      lda	(CURPTR),y
     29  11e3		       d0 07		      bne	iOPENfn	;might be filename
     30  11e5							;
     31  11e5							; No filename supplied.
     32  11e5							;
     33  11e5		       a9 00	   iOPENnofn  lda	#0
     34  11e7		       a2 09		      ldx	#ERR_NO_FILENAME
     35  11e9		       4c b1 05 	      jmp	iErr2
     36  11ec							;
     37  11ec							; Add the offset into the buffer start
     38  11ec							;
     39  11ec		       18	   iOPENfn    clc
     40  11ed		       98		      tya
     41  11ee		       65 4f		      adc	CURPTR
     42  11f0		       a8		      tay		;LSB
     43  11f1		       a5 50		      lda	CURPTR+1
     44  11f3		       69 00		      adc	#0
     45  11f5		       aa		      tax
     46  11f6		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  11f9		       90 07		      bcc	Ropenok	;branch if opened ok
     48  11fb							;
     49  11fb							; Open failed
     50  11fb							;
     51  11fb		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  11fd		       a9 00	   Rdfail2    lda	#0
     53  11ff		       4c b1 05 	      jmp	iErr2
     54  1202							;
     55  1202							; Clear counts and offsets so the next read will
     56  1202							; cause the file to be read.
     57  1202							;
     58  1202		       a9 00	   Ropenok    lda	#0
     59  1204		       8d c7 16 	      sta	diskBufOffset
     60  1207		       8d c6 16 	      sta	diskBufLength
     61  120a		       4c ea 02 	      jmp	NextIL
     62  120d					      endif
     63  120d
     64  120d							;
     65  120d							;==============================jlit 08/02/2022========
     66  120d							;Remove a file from the disk
     67  120d				   iRMFILE
     68  120d					      if	XKIM || CTMON65
     69  120d		       a4 51		      ldy	CUROFF
     70  120f		       b1 4f		      lda	(CURPTR),y
     71  1211		       f0 19		      beq	iRMnofn
     72  1213							;
     73  1213		       18		      clc
     74  1214		       98		      tya
     75  1215		       65 4f		      adc	CURPTR
     76  1217		       a8		      tay		;LSB
     77  1218		       a5 50		      lda	CURPTR+1
     78  121a		       69 00		      adc	#0
     79  121c		       aa		      tax
     80  121d		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1220		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1222		       a9 00		      lda	#0
     83  1224		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1226		       4c b1 05 	      jmp	iErr2
     85  1229		       4c ea 02    wrmOk      jmp	NextIL
     86  122c
     87  122c							; No filename supplied.
     88  122c							;
     89  122c		       a9 00	   iRMnofn    lda	#0
     90  122e		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1230		       4c b1 05 	      jmp	iErr2
     92  1233					      endif
     93  1233							;
     94  1233							;=====================================================
     95  1233				   iOPENWRITE
     96  1233					      if	XKIM || CTMON65
     97  1233		       a4 51		      ldy	CUROFF
     98  1235		       b1 4f		      lda	(CURPTR),y
     99  1237		       f0 f3		      beq	iRMnofn
    100  1239							;
    101  1239		       18		      clc
    102  123a		       98		      tya
    103  123b		       65 4f		      adc	CURPTR
    104  123d		       a8		      tay		;LSB
    105  123e		       a5 50		      lda	CURPTR+1
    106  1240		       69 00		      adc	#0
    107  1242		       aa		      tax
    108  1243		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1246		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1248							;
    111  1248							; Open failed
    112  1248							;
    113  1248		       a9 00	   Wdfail     lda	#0
    114  124a		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  124c		       4c b1 05 	      jmp	iErr2
    116  124f							;
    117  124f		       4c ea 02    Wopenok    jmp	NextIL
    118  1252					      endif
    119  1252							;
    120  1252							;=====================================================
    121  1252							; Gets a line of input from the disk file and puts it
    122  1252							; into LINBUF.
    123  1252							;
    124  1252							; On exit:
    125  1252							;    CURPTR points to LINBUF
    126  1252							;    LINBUF contains the line with 0 at the end.
    127  1252							;    Y has offset to first non-space character
    128  1252							;    CURROFF has the same as Y.
    129  1252							;
    130  1252				   iDGETLINE
    131  1252					      if	XKIM || CTMON65
    132  1252		       a2 9b		      ldx	#LINBUF&$ff
    133  1254		       86 4f		      stx	CURPTR
    134  1256		       a2 1e		      ldx	#LINBUF>>8
    135  1258		       86 50		      stx	CURPTR+1
    136  125a							;
    137  125a		       a2 00		      ldx	#0	;offset
    138  125c		       8e 1f 1f    iDgetLoop  stx	getlinx
    139  125f		       20 bd 12 	      jsr	getNextFileByte
    140  1262		       b0 16		      bcs	iGetEOF
    141  1264		       c9 0d		      cmp	#CR
    142  1266		       f0 0d		      beq	iGetEOL
    143  1268		       c9 0a		      cmp	#LF
    144  126a		       f0 09		      beq	iGetEOL
    145  126c		       ae 1f 1f 	      ldx	getlinx
    146  126f		       9d 9b 1e 	      sta	LINBUF,x
    147  1272		       e8		      inx
    148  1273		       d0 e7		      bne	iDgetLoop
    149  1275							;
    150  1275							; Handle end of line.	If the line has nothing, loop
    151  1275							; back and get another line.
    152  1275							;
    153  1275		       ae 1f 1f    iGetEOL    ldx	getlinx	;blank line?
    154  1278		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  127a							;
    156  127a							; This can fall through when there is a line, or
    157  127a							; called directly when EOF is encountered.
    158  127a							;
    159  127a		       ae 1f 1f    iGetEOF    ldx	getlinx
    160  127d		       a9 00		      lda	#0
    161  127f		       9d 9b 1e 	      sta	LINBUF,x
    162  1282		       85 51		      sta	CUROFF
    163  1284		       a0 00		      ldy	#0
    164  1286		       20 18 11 	      jsr	SkipSpaces
    165  1289		       4c ea 02 	      jmp	NextIL
    166  128c					      endif
    167  128c
    168  128c							;
    169  128c							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  128c							; DISK
    171  128c							;
    172  128c				   iDDIR
    173  128c					      if	XKIM || CTMON65
    174  128c		       20 30 f0 	      jsr	DiskDir
    175  128f							;
    176  128f							; Get/Display each entry
    177  128f							;
    178  128f		       a2 16	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  1291		       a0 c8		      ldy	#DiskFileName&$ff
    180  1293		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  1296		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  1298		       20 12 f0 	      jsr	puts
      0  129b					      db	"   ",0
      1  129b		       20 20 20 00	      .byte.b	"   ",0
    184  129f							; Print the line to the console
    185  129f		       a2 16		      ldx	#DiskFileName/256	;pointer to buffer
    186  12a1		       a0 c8		      ldy	#DiskFileName&$ff
    187  12a3		       a5 00		      lda	0
    188  12a5		       20 b7 11 	      jsr	PrtStr	;else print name
    189  12a8		       20 18 f0 	      jsr	crlf
    190  12ab
    191  12ab		       4c 8f 12 	      jmp	DiskDirLoop	;do next entry
    192  12ae		       4c ea 02    DiskDirEnd jmp	NextIL
    193  12b1					      endif
    194  12b1							;
    195  12b1							;=====================================================
    196  12b1							; Does a LIST to a Disk file.
    197  12b1							;
    198  12b1				   iDLIST
    199  12b1					      if	XKIM || CTMON65
    200  12b1		       20 ec 12 	      jsr	SetOutDisk
    201  12b4		       4c 4d 07 	      jmp	iLST2
    202  12b7					      endif
    203  12b7							;
    204  12b7							;=====================================================
    205  12b7							; Closes any pending disk file.  Okay to call if there
    206  12b7							; is no open file.
    207  12b7							;
    208  12b7				   iDCLOSE
    209  12b7					      if	XKIM || CTMON65
    210  12b7		       20 42 f0 	      jsr	DiskClose
    211  12ba		       4c ea 02 	      jmp	NextIL
    212  12bd					      endif
    213  12bd							;
    214  12bd							;=====================================================
    215  12bd							; This gets the next byte from an open disk file.  If
    216  12bd							; there are no more bytes left, this returns C set.
    217  12bd							; Else, C is clear and A contains the character.
    218  12bd							;
    219  12bd				   getNextFileByte
    220  12bd					      if	XKIM || CTMON65
    221  12bd		       ae c7 16 	      ldx	diskBufOffset
    222  12c0		       ec c6 16 	      cpx	diskBufLength
    223  12c3		       d0 14		      bne	hasdata	;branch if still data
    224  12c5							;
    225  12c5							; There is no data left in the buffer, so read a
    226  12c5							; block from the SD system.
    227  12c5							;
    228  12c5		       a9 84		      lda	#BUFFER_SIZE
    229  12c7		       a2 df		      ldx	#buffer>>8
    230  12c9		       a0 0a		      ldy	#buffer&$ff
    231  12cb		       20 3c f0 	      jsr	DiskRead
    232  12ce		       b0 12		      bcs	getNextEof
    233  12d0							;
    234  12d0							; A contains the number of bytes actually read.
    235  12d0							;
    236  12d0		       8d c6 16 	      sta	diskBufLength	;save length
    237  12d3		       c9 00		      cmp	#0	;shouldn't happen
    238  12d5		       f0 0b		      beq	getNextEof
    239  12d7							;
    240  12d7		       a2 00		      ldx	#0
    241  12d9		       bd 0a df    hasdata    lda	buffer,x
    242  12dc		       e8		      inx
    243  12dd		       8e c7 16 	      stx	diskBufOffset
    244  12e0		       18		      clc
    245  12e1		       60		      rts
    246  12e2							;
    247  12e2		       a9 00	   getNextEof lda	#0
    248  12e4		       8d c7 16 	      sta	diskBufOffset
    249  12e7		       8d c6 16 	      sta	diskBufLength
    250  12ea		       38		      sec
    251  12eb		       60		      rts
    252  12ec							;
    253  12ec							;=====================================================
    254  12ec							; Set output vector to the disk output function
    255  12ec							;
    256  12ec		       a9 f7	   SetOutDisk lda	#DOUT&$ff
    257  12ee		       8d 2c 1f 	      sta	BOutVec
    258  12f1		       a9 12		      lda	#DOUT/256
    259  12f3		       8d 2d 1f 	      sta	BOutVec+1
    260  12f6		       60		      rts
    261  12f7							;
    262  12f7							;=====================================================
    263  12f7
    264  12f7		       8d 0a df    DOUT       sta	buffer
    265  12fa		       a9 01		      lda	#1
    266  12fc		       a0 0a		      ldy	#buffer&$ff
    267  12fe		       a2 df		      ldx	#buffer/256
    268  1300		       20 3f f0 	      jsr	DiskWrite
    269  1303							;
    270  1303							; need error checking here
    271  1303							;
    272  1303		       60		      rts
    273  1304					      endif
    274  1304
    275  1304
------- FILE mytb.asm
   2008  1304					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1304					      include	"IL.inc"
      1  1304
      2  1304							;=====================================================
      3  1304							; IL.inc
      4  1304							; These are macros for IL instructions
      5  1304							;
      6  1304					      mac	dw
      7  1304					      .word	{0}
      8  1304					      endm
      9  1304					      mac	db
     10  1304					      .byte	{0}
     11  1304					      endm
     12  1304					      macro	xinit
     13  1304					      db	0
     14  1304					      endm		;reset the il to start clear all
     15  1304							;
     16  1304					      macro	done
     17  1304					      db	1
     18  1304					      endm		;print an error if not end of line
     19  1304							;
     20  1304					      macro	prs
     21  1304					      db	2
     22  1304					      endm		;print a quoted string
     23  1304							;
     24  1304					      macro	prn
     25  1304					      db	3
     26  1304					      endm		;print a number
     27  1304							;
     28  1304					      macro	spc
     29  1304					      db	4
     30  1304					      endm		;print space til new tabstop
     31  1304							;
     32  1304					      macro	nline
     33  1304					      db	5
     34  1304					      endm		;print a new line crlf
     35  1304							;
     36  1304							; My NXT is a bit different in that it takes one
     37  1304							; parameter, which is an address.  If the BASIC
     38  1304							; program is currently running then move to the
     39  1304							; next line and continue execution.  However, if
     40  1304							; in direct mode, jump to the specified IL label.
     41  1304							;
     42  1304					      macro	nxt
     43  1304					      db	6
     44  1304					      dw	{1}	; addr
     45  1304					      endm		; addr
     46  1304							;
     47  1304					      macro	xfer
     48  1304					      db	7
     49  1304					      endm
     50  1304							;
     51  1304					      macro	sav
     52  1304					      db	8
     53  1304					      endm
     54  1304							;
     55  1304					      macro	rstr
     56  1304					      db	9
     57  1304					      endm
     58  1304							;
     59  1304					      macro	cmpr
     60  1304					      db	10
     61  1304					      endm
     62  1304							;
     63  1304					      macro	innum
     64  1304					      db	11
     65  1304					      endm
     66  1304							;
     67  1304					      macro	fin
     68  1304					      db	12
     69  1304					      endm
     70  1304							;
     71  1304							; ERR is followed by an error number.	The error
     72  1304							; code is printed along with the line number.
     73  1304							; Control is passed to the statement set with
     74  1304							; the ERRGOTO statement.
     75  1304							;
     76  1304					      macro	errmsg
     77  1304					      db	13
     78  1304					      dw	{1}	;ecode
     79  1304					      endm		;ecode
     80  1304							;
     81  1304					      macro	add
     82  1304					      db	14
     83  1304					      endm
     84  1304							;
     85  1304					      macro	sub
     86  1304					      db	15
     87  1304					      endm
     88  1304							;
     89  1304					      macro	neg
     90  1304					      db	16
     91  1304					      endm
     92  1304							;
     93  1304					      macro	mul
     94  1304					      db	17
     95  1304					      endm
     96  1304							;
     97  1304					      macro	div
     98  1304					      db	18
     99  1304					      endm
    100  1304							;
    101  1304					      macro	store
    102  1304					      db	19
    103  1304					      endm
    104  1304							;
    105  1304					      macro	ind
    106  1304					      db	20
    107  1304					      endm
    108  1304							;
    109  1304					      macro	lst
    110  1304					      db	21
    111  1304					      endm
    112  1304							;
    113  1304					      macro	init
    114  1304					      db	22
    115  1304					      endm
    116  1304							;
    117  1304					      macro	getline
    118  1304					      db	23
    119  1304					      endm
    120  1304							;
    121  1304					      macro	insert
    122  1304					      db	24
    123  1304					      endm
    124  1304							;
    125  1304					      macro	rtn
    126  1304					      db	25
    127  1304					      endm
    128  1304							;
    129  1304					      macro	exit
    130  1304					      db	26
    131  1304					      endm
    132  1304							;
    133  1304					      macro	lit
    134  1304					      db	27
    135  1304					      dw	{1}	;value
    136  1304					      endm		; value LIT
    137  1304							;
    138  1304					      macro	call
    139  1304					      db	28
    140  1304					      dw	{1}	;addr
    141  1304					      endm		;addr
    142  1304							;
    143  1304							; IJMP will set the IL PC to the specified value.
    144  1304							;
    145  1304					      macro	ijmp
    146  1304					      db	29
    147  1304					      dw	{1}	;addr
    148  1304					      endm		;addr
    149  1304							;
    150  1304					      macro	vinit
    151  1304					      db	30
    152  1304					      endm
    153  1304							;
    154  1304							; ERRGOTO sets the point in the code where the IL
    155  1304							; interpreter will go after any error.
    156  1304							;
    157  1304					      macro	errgoto
    158  1304					      db	31
    159  1304					      dw	{1}	;addr
    160  1304					      endm		;addr
    161  1304							;
    162  1304					      macro	tst
    163  1304					      db	32
    164  1304					      db	({1}-*)-1	;(addr-*)-1
    165  1304					      db	{2},0	;string,0
    166  1304					      endm		;addr,string
    167  1304							;
    168  1304					      macro	tstv
    169  1304					      db	33
    170  1304					      db	({1}-*)-1	;(addr-*)-1
    171  1304					      endm		;addr
    172  1304							;
    173  1304					      macro	tstl
    174  1304					      db	34
    175  1304					      db	({1}-*)-1	;(addr-*)-1
    176  1304					      endm		;addr
    177  1304							;
    178  1304					      macro	tstn
    179  1304					      db	35
    180  1304					      db	({1}-*)-1	;(addr-*)-1
    181  1304					      endm		;addr
    182  1304							;
    183  1304							; FREE returns the amount of free RAM on top of
    184  1304							; the stack.  This is the amount of room the user
    185  1304							; program has available.
    186  1304							;
    187  1304					      macro	free
    188  1304					      db	36
    189  1304					      endm
    190  1304							;
    191  1304							; RANDOM takes the top item off the stack and
    192  1304							; replaces it with a random number that is
    193  1304							; MOD the initial value.  Ie, if the TOS is
    194  1304							; 42 then RANDOM returns a value from 0 to 41.
    195  1304							;
    196  1304					      macro	random
    197  1304					      db	37
    198  1304					      endm
    199  1304							;
    200  1304							; ABS will replace the top of stack with the
    201  1304							; absolute value.
    202  1304							;
    203  1304					      macro	abs
    204  1304					      db	38
    205  1304					      endm
    206  1304							;
    207  1304							; OPENREAD opens a file for reading, as in getting
    208  1304							; statements from it.
    209  1304							;
    210  1304					      macro	openread
    211  1304					      db	39
    212  1304					      endm
    213  1304							;
    214  1304							; OPENWRITE opens a file for writing, as in saving
    215  1304							; the current program to it.
    216  1304							;
    217  1304					      macro	openwrite
    218  1304					      db	40
    219  1304					      endm
    220  1304							;
    221  1304							; DCLOSE closes any open disk file.
    222  1304							;
    223  1304					      macro	dclose
    224  1304					      db	41
    225  1304					      endm
    226  1304							;
    227  1304							; DGETLINE gets one line from the disk file and puts it
    228  1304							; into LINBUFF.
    229  1304							;
    230  1304					      macro	dgetline
    231  1304					      db	42
    232  1304					      endm
    233  1304							;
    234  1304							; DLIST saves the program to an open disk file.
    235  1304							;
    236  1304					      macro	dlist
    237  1304					      db	43
    238  1304					      endm
    239  1304							; DDIR list the current directory
    240  1304							;
    241  1304					      macro	ddir
    242  1304					      db	44
    243  1304					      endm
    244  1304
    245  1304							; RMFILE remove a fle from disk
    246  1304					      macro	rmfile
    247  1304					      db	45
    248  1304					      endm
    249  1304
    250  1304							; CLEARSCREEN clear the screen
    251  1304					      macro	clearscreen
    252  1304					      db	46
    253  1304					      endm
    254  1304							; POKEMEM Poke value into memory
    255  1304					      macro	pokemem
    256  1304					      db	47
    257  1304					      endm
    258  1304							; PEEKMEM peek at value in memory
    259  1304					      macro	peekmem
    260  1304					      db	48
    261  1304					      endm
    262  1304							; TSTLET Test if the statement is a let without the keyword let
    263  1304					      macro	tstlet
    264  1304					      db	49
    265  1304					      db	({1}-*)-1	;(addr-*)-1
    266  1304					      endm		;addr
    267  1304							; TSTDONE if we reach the end of a statement
    268  1304					      macro	tstdone
    269  1304					      db	50
    270  1304					      db	({1}-*)-1	;(addr-*)-1
    271  1304					      endm		;addr
    272  1304							; GETCHAR	get a character from the input line leave it in RO
    273  1304					      macro	getchar
    274  1304					      db	51
    275  1304					      endm
    276  1304							; PUTCHAR	Put a character to the terminal
    277  1304					      macro	putchar
    278  1304					      db	52
    279  1304					      endm
    280  1304							; Call		Call a machine function return a to stack
    281  1304					      macro	callfunc
    282  1304					      db	53
    283  1304					      endm
    284  1304
    285  1304							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    286  1304					      macro	ibranch
    287  1304					      db	54
    288  1304					      endm
    289  1304
    290  1304							; TSTSTR	 Tests for the open quote in a string
    291  1304					      macro	tststr
    292  1304					      db	55
    293  1304					      db	({1}-*)-1	;(addr-*)-1
    294  1304					      endm
    295  1304							; SETIRQ	Sets the line number to run when an irq happens irq 550
    296  1304					      macro	setirq
    297  1304					      db	56
    298  1304					      endm
    299  1304
    300  1304							; TSTIRQ	Test for irq pending,
    301  1304							;		if so push the IRQ LINE NUMBER into RO, onto stack
    302  1304					      macro	tstirq
    303  1304					      db	57
    304  1304					      db	({1}-*)-1	;(addr-*)-1
    305  1304					      endm
    306  1304
    307  1304							; IRET    return from interupt service
    308  1304					      macro	iret
    309  1304					      db	58
    310  1304					      endm
    311  1304
    312  1304							; INSTR   read a string from the input
    313  1304					      macro	instr
    314  1304					      db	59
    315  1304					      endm
    316  1304
    317  1304							; MODULO Returns the remainder of the division
    318  1304					      macro	modulo
    319  1304					      db	60
    320  1304					      endm
    321  1304							; Set a task line
    322  1304					      macro	settask
    323  1304					      db	61
    324  1304					      endm
    325  1304							; End a task
    326  1304					      macro	etask
    327  1304					      db	62
    328  1304					      endm
    329  1304							; Skip to next task
    330  1304					      macro	ntask
    331  1304					      db	63
    332  1304					      endm
    333  1304							; Subscript
    334  1304					      macro	subscript
    335  1304					      db	64
    336  1304					      endm
    337  1304							; KILL Task
    338  1304					      macro	taskkill
    339  1304					      db	65
    340  1304					      endm
    341  1304							; STAT Task
    342  1304					      macro	taskstat
    343  1304					      db	66
    344  1304					      endm
    345  1304							;  output value as hex
    346  1304					      macro	hexprt
    347  1304					      db	67
    348  1304					      endm
    349  1304							;  Read in background has completed
    350  1304					      macro	readcomplete
    351  1304					      db	68
    352  1304					      endm
    353  1304							;  ReadInput line
    354  1304					      macro	readstart
    355  1304					      db	69
    356  1304					      endm
    357  1304							; Startio request
    358  1304					      macro	startio
    359  1304					      db	70
    360  1304					      endm
    361  1304							; Endio
    362  1304					      macro	endio
    363  1304					      db	71
    364  1304					      endm
    365  1304							; Logical not
    366  1304					      macro	lognot
    367  1304					      db	72
    368  1304					      endm
    369  1304							; Logical OR
    370  1304					      macro	logor
    371  1304					      db	73
    372  1304					      endm
    373  1304							;Logical and
    374  1304					      macro	logand
    375  1304					      db	74
    376  1304					      endm
    377  1304							;Logical XOR
    378  1304					      macro	logxor
    379  1304					      db	75
    380  1304					      endm
    381  1304							;Wait for task to complete, or list of tasks
    382  1304					      macro	wtask
    383  1304					      db	76
    384  1304					      db	({1}-*)-1	;(addr-*)-1
    385  1304					      endm
    386  1304							;Get the current task id
    387  1304					      MACRO	taskpid
    388  1304					      db	77
    389  1304					      endm
    390  1304
    391  1304
------- FILE mytb.asm
   2010  1304							;
   2011  1304				  -	      if	FIXED
   2012  1304				  -	      org	$1000
   2013  1304					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1304					      include	"basic.il"
      1  1304							;LET
      2  1304							;=====================================================
      3  1304							;=====================================================
      4  1304					      seg	Code
      5  1304							;=====================================================
      6  1304							; This is the IL of the BASIC (or whatever) language.
      7  1304							; Because of the way macros are implemented by as65,
      8  1304							; labels can't be on the same line as a macro
      9  1304							; invocation, so that's why labels are on separate
     10  1304							; lines.
     11  1304							;
     12  1304		       13 04	   IL	      equ	*
     13  1304
     14  1304							;THE IL CONTROL SECTION
     15  1304
     16  1304				   START
      0  1304					      INIT		;INITIALIZE
      0  1304					      db	22
      1  1304		       16		      .byte.b	22
      0  1305					      NLINE		;WRITE CRLF
      0  1305					      db	5
      1  1305		       05		      .byte.b	5
      0  1306					      ERRGOTO	CO	;where to go after an error
      0  1306					      db	31
      1  1306		       1f		      .byte.b	31
      0  1307					      dw	CO
      1  1307		       0a 13		      .word.w	CO
      0  1309					      VINIT		;clear all variables
      0  1309					      db	30
      1  1309		       1e		      .byte.b	30
     21  130a							;
     22  130a							; This is where we jump to get a line of commands or
     23  130a							; a program from the user.
     24  130a							;
     25  130a				   CO
      0  130a					      GETLINE		;WRITE PROMPT AND GET LINE
      0  130a					      db	23
      1  130a		       17		      .byte.b	23
      0  130b					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  130b					      db	34
      1  130b		       22		      .byte.b	34
      0  130c					      db	(XEC-*)-1
      1  130c		       04		      .byte.b	(XEC-*)-1
      0  130d					      INSERT		;INSERT IT (MAY BE DELETE)
      0  130d					      db	24
      1  130d		       18		      .byte.b	24
      0  130e					      IJMP	CO
      0  130e					      db	29
      1  130e		       1d		      .byte.b	29
      0  130f					      dw	CO
      1  130f		       0a 13		      .word.w	CO
     30  1311				   XEC
      0  1311					      XINIT		;INITIALIZE
      0  1311					      db	0
      1  1311		       00		      .byte.b	0
     32  1312
     33  1312							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1312				   STMT
      0  1312					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1312					      db	57
      1  1312		       39		      .byte.b	57
      0  1313					      db	(notirq-*)-1
      1  1313		       00		      .byte.b	(notirq-*)-1
     36  1314				   notirq
      0  1314					      TSTLET	LET	;Test if second field is =
      0  1314					      db	49
      1  1314		       31		      .byte.b	49
      0  1315					      db	(LET-*)-1
      1  1315		       03		      .byte.b	(LET-*)-1
      0  1316					      IJMP	DOLET	;allow the default to be let
      0  1316					      db	29
      1  1316		       1d		      .byte.b	29
      0  1317					      dw	DOLET
      1  1317		       1f 13		      .word.w	DOLET
     39  1319				   LET
      0  1319					      TST	S1,"LET"	;IS STATEMENT A LET
      0  1319					      db	32
      1  1319		       20		      .byte.b	32
      0  131a					      db	(S1-*)-1
      1  131a		       21		      .byte.b	(S1-*)-1
      0  131b					      db	"LET",0
      1  131b		       4c 45 54 00	      .byte.b	"LET",0
     41  131f				   DOLET
      0  131f					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  131f					      db	33
      1  131f		       21		      .byte.b	33
      0  1320					      db	(ERRVEC-*)-1
      1  1320		       b2		      .byte.b	(ERRVEC-*)-1
      0  1321					      TST	LETBE,"["
      0  1321					      db	32
      1  1321		       20		      .byte.b	32
      0  1322					      db	(LETBE-*)-1
      1  1322		       0a		      .byte.b	(LETBE-*)-1
      0  1323					      db	"[",0
      1  1323		       5b 00		      .byte.b	"[",0
      0  1325					      CALL	EXPR
      0  1325					      db	28
      1  1325		       1c		      .byte.b	28
      0  1326					      dw	EXPR
      1  1326		       26 15		      .word.w	EXPR
      0  1328					      TST	ERRVEC,"]"
      0  1328					      db	32
      1  1328		       20		      .byte.b	32
      0  1329					      db	(ERRVEC-*)-1
      1  1329		       a9		      .byte.b	(ERRVEC-*)-1
      0  132a					      db	"]",0
      1  132a		       5d 00		      .byte.b	"]",0
      0  132c					      SUBSCRIPT
      0  132c					      db	64
      1  132c		       40		      .byte.b	64
     47  132d				   LETBE
      0  132d					      TST	ERRVEC,"="	;(This line originally omitted)
      0  132d					      db	32
      1  132d		       20		      .byte.b	32
      0  132e					      db	(ERRVEC-*)-1
      1  132e		       a4		      .byte.b	(ERRVEC-*)-1
      0  132f					      db	"=",0
      1  132f		       3d 00		      .byte.b	"=",0
      0  1331					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  1331					      db	28
      1  1331		       1c		      .byte.b	28
      0  1332					      dw	EXPR
      1  1332		       26 15		      .word.w	EXPR
      0  1334					      DONE		;REPORT ERROR IF NOT NEXT
      0  1334					      db	1
      1  1334		       01		      .byte.b	1
      0  1335					      STORE		;STORE RESULT
      0  1335					      db	19
      1  1335		       13		      .byte.b	19
      0  1336					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1336					      db	6
      1  1336		       06		      .byte.b	6
      0  1337					      dw	CO
      1  1337		       0a 13		      .word.w	CO
      0  1339					      IJMP	STMT
      0  1339					      db	29
      1  1339		       1d		      .byte.b	29
      0  133a					      dw	STMT
      1  133a		       12 13		      .word.w	STMT
     54  133c				   S1
      0  133c					      TST	S1S1,"IRET"	;test return from interupt
      0  133c					      db	32
      1  133c		       20		      .byte.b	32
      0  133d					      db	(S1S1-*)-1
      1  133d		       10		      .byte.b	(S1S1-*)-1
      0  133e					      db	"IRET",0
      1  133e		       49 52 45 54*	      .byte.b	"IRET",0
      0  1343					      TST	S1Sa,"URN"
      0  1343					      db	32
      1  1343		       20		      .byte.b	32
      0  1344					      db	(S1Sa-*)-1
      1  1344		       04		      .byte.b	(S1Sa-*)-1
      0  1345					      db	"URN",0
      1  1345		       55 52 4e 00	      .byte.b	"URN",0
     57  1349				   S1Sa
      0  1349					      DONE		;Must be only thing on the line
      0  1349					      db	1
      1  1349		       01		      .byte.b	1
      0  134a					      IRET		;RESTORE LINE NUMBER OF CALL
      0  134a					      db	58
      1  134a		       3a		      .byte.b	58
      0  134b					      IJMP	STMT
      0  134b					      db	29
      1  134b		       1d		      .byte.b	29
      0  134c					      dw	STMT
      1  134c		       12 13		      .word.w	STMT
     61  134e
     62  134e				   S1S1
      0  134e					      TST	S1Z,"IF"	;IF STATEMENT
      0  134e					      db	32
      1  134e		       20		      .byte.b	32
      0  134f					      db	(S1Z-*)-1
      1  134f		       11		      .byte.b	(S1Z-*)-1
      0  1350					      db	"IF",0
      1  1350		       49 46 00 	      .byte.b	"IF",0
      0  1353					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1353					      db	28
      1  1353		       1c		      .byte.b	28
      0  1354					      dw	EXPR
      1  1354		       26 15		      .word.w	EXPR
      0  1356					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  1356					      db	32
      1  1356		       20		      .byte.b	32
      0  1357					      db	(S1W-*)-1
      1  1357		       05		      .byte.b	(S1W-*)-1
      0  1358					      db	"THEN",0
      1  1358		       54 48 45 4e*	      .byte.b	"THEN",0
     66  135d				   S1W
      0  135d					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  135d					      db	54
      1  135d		       36		      .byte.b	54
      0  135e					      IJMP	STMT
      0  135e					      db	29
      1  135e		       1d		      .byte.b	29
      0  135f					      dw	STMT
      1  135f		       12 13		      .word.w	STMT
     69  1361
     70  1361				   S1Z
      0  1361					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1361					      db	32
      1  1361		       20		      .byte.b	32
      0  1362					      db	(S2b-*)-1
      1  1362		       18		      .byte.b	(S2b-*)-1
      0  1363					      db	"GO",0
      1  1363		       47 4f 00 	      .byte.b	"GO",0
      0  1366					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  1366					      db	32
      1  1366		       20		      .byte.b	32
      0  1367					      db	(S2-*)-1
      1  1367		       07		      .byte.b	(S2-*)-1
      0  1368					      db	"TO",0
      1  1368		       54 4f 00 	      .byte.b	"TO",0
      0  136b					      CALL	EXPR	;GET LABEL
      0  136b					      db	28
      1  136b		       1c		      .byte.b	28
      0  136c					      dw	EXPR
      1  136c		       26 15		      .word.w	EXPR
      0  136e					      XFER		;SET UP AND JUMP
      0  136e					      db	7
      1  136e		       07		      .byte.b	7
     75  136f				   S2
      0  136f					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  136f					      db	32
      1  136f		       20		      .byte.b	32
      0  1370					      db	(ERRVEC-*)-1
      1  1370		       62		      .byte.b	(ERRVEC-*)-1
      0  1371					      db	"SUB",0
      1  1371		       53 55 42 00	      .byte.b	"SUB",0
      0  1375					      CALL	EXPR	;GET DESTINATION
      0  1375					      db	28
      1  1375		       1c		      .byte.b	28
      0  1376					      dw	EXPR
      1  1376		       26 15		      .word.w	EXPR
      0  1378					      DONE		;ERROR IF CR NOT NEXT
      0  1378					      db	1
      1  1378		       01		      .byte.b	1
      0  1379					      SAV		;SAVE RETURN LINE
      0  1379					      db	8
      1  1379		       08		      .byte.b	8
      0  137a					      XFER		;AND JUMP
      0  137a					      db	7
      1  137a		       07		      .byte.b	7
     81  137b				   S2b
      0  137b					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  137b					      db	32
      1  137b		       20		      .byte.b	32
      0  137c					      db	(S3-*)-1
      1  137c		       1f		      .byte.b	(S3-*)-1
      0  137d					      db	"RE",0
      1  137d		       52 45 00 	      .byte.b	"RE",0
      0  1380					      TST	S2a,"T"
      0  1380					      db	32
      1  1380		       20		      .byte.b	32
      0  1381					      db	(S2a-*)-1
      1  1381		       10		      .byte.b	(S2a-*)-1
      0  1382					      db	"T",0
      1  1382		       54 00		      .byte.b	"T",0
      0  1384					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  1384					      db	32
      1  1384		       20		      .byte.b	32
      0  1385					      db	(S2aa-*)-1
      1  1385		       04		      .byte.b	(S2aa-*)-1
      0  1386					      db	"URN",0
      1  1386		       55 52 4e 00	      .byte.b	"URN",0
     85  138a				   S2aa
      0  138a					      DONE		;MUST BE CR
      0  138a					      db	1
      1  138a		       01		      .byte.b	1
      0  138b					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  138b					      db	9
      1  138b		       09		      .byte.b	9
      0  138c					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  138c					      db	6
      1  138c		       06		      .byte.b	6
      0  138d					      dw	CO
      1  138d		       0a 13		      .word.w	CO
      0  138f					      IJMP	STMT
      0  138f					      db	29
      1  138f		       1d		      .byte.b	29
      0  1390					      dw	STMT
      1  1390		       12 13		      .word.w	STMT
     90  1392				   S2a
      0  1392					      TST	S3,"M"	;REMark.  Skip rest of line
      0  1392					      db	32
      1  1392		       20		      .byte.b	32
      0  1393					      db	(S3-*)-1
      1  1393		       08		      .byte.b	(S3-*)-1
      0  1394					      db	"M",0
      1  1394		       4d 00		      .byte.b	"M",0
      0  1396					      NXT	CO
      0  1396					      db	6
      1  1396		       06		      .byte.b	6
      0  1397					      dw	CO
      1  1397		       0a 13		      .word.w	CO
      0  1399					      IJMP	STMT
      0  1399					      db	29
      1  1399		       1d		      .byte.b	29
      0  139a					      dw	STMT
      1  139a		       12 13		      .word.w	STMT
     94  139c
     95  139c				   S3
      0  139c					      TST	S3a,"?"	; ? symonym for print
      0  139c					      db	32
      1  139c		       20		      .byte.b	32
      0  139d					      db	(S3a-*)-1
      1  139d		       05		      .byte.b	(S3a-*)-1
      0  139e					      db	"?",0
      1  139e		       3f 00		      .byte.b	"?",0
      0  13a0					      IJMP	S4S
      0  13a0					      db	29
      1  13a0		       1d		      .byte.b	29
      0  13a1					      dw	S4S
      1  13a1		       ae 13		      .word.w	S4S
     98  13a3				   S3a
      0  13a3					      TST	S8,"PR"	;allow short form of print
      0  13a3					      db	32
      1  13a3		       20		      .byte.b	32
      0  13a4					      db	(S8-*)-1
      1  13a4		       4c		      .byte.b	(S8-*)-1
      0  13a5					      db	"PR",0
      1  13a5		       50 52 00 	      .byte.b	"PR",0
      0  13a8					      TST	S4S,"INT"	;PRINT
      0  13a8					      db	32
      1  13a8		       20		      .byte.b	32
      0  13a9					      db	(S4S-*)-1
      1  13a9		       04		      .byte.b	(S4S-*)-1
      0  13aa					      db	"INT",0
      1  13aa		       49 4e 54 00	      .byte.b	"INT",0
    101  13ae				   S4S
      0  13ae					      STARTIO		;Lock task until io completes
      0  13ae					      db	70
      1  13ae		       46		      .byte.b	70
    103  13af				   S4
      0  13af					      TSTDONE	S4a	;Test if we just want crlf printed
      0  13af					      db	50
      1  13af		       32		      .byte.b	50
      0  13b0					      db	(S4a-*)-1
      1  13b0		       03		      .byte.b	(S4a-*)-1
      0  13b1					      IJMP	S6
      0  13b1					      db	29
      1  13b1		       1d		      .byte.b	29
      0  13b2					      dw	S6
      1  13b2		       ca 13		      .word.w	S6
    106  13b4
    107  13b4				   S4a
      0  13b4					      TSTSTR	S7	;TEST FOR QUOTED String
      0  13b4					      db	55
      1  13b4		       37		      .byte.b	55
      0  13b5					      db	(S7-*)-1
      1  13b5		       21		      .byte.b	(S7-*)-1
      0  13b6					      PRS		;PRINT STRING
      0  13b6					      db	2
      1  13b6		       02		      .byte.b	2
    110  13b7				   S5
      0  13b7					      TST	S6A,COMMA	;IS THERE MORE?
      0  13b7					      db	32
      1  13b7		       20		      .byte.b	32
      0  13b8					      db	(S6A-*)-1
      1  13b8		       08		      .byte.b	(S6A-*)-1
      0  13b9					      db	COMMA,0
      1  13b9		       2c 00		      .byte.b	COMMA,0
      0  13bb					      SPC		;SPACE TO NEXT ZONE
      0  13bb					      db	4
      1  13bb		       04		      .byte.b	4
      0  13bc					      TSTDONE	S4	;Not end of line jump back
      0  13bc					      db	50
      1  13bc		       32		      .byte.b	50
      0  13bd					      db	(S4-*)-1
      1  13bd		       f1		      .byte.b	(S4-*)-1
      0  13be					      IJMP	S6Z	;YES JUMP BACK
      0  13be					      db	29
      1  13be		       1d		      .byte.b	29
      0  13bf					      dw	S6Z
      1  13bf		       cc 13		      .word.w	S6Z
    115  13c1
    116  13c1							;
    117  13c1							; If a semicolon, don't do anything.
    118  13c1							;
    119  13c1				   S6A
      0  13c1					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  13c1					      db	32
      1  13c1		       20		      .byte.b	32
      0  13c2					      db	(S6-*)-1
      1  13c2		       07		      .byte.b	(S6-*)-1
      0  13c3					      db	SEMICOLON,0
      1  13c3		       3b 00		      .byte.b	SEMICOLON,0
      0  13c5					      TSTDONE	S4	;Jump Back if not end of line
      0  13c5					      db	50
      1  13c5		       32		      .byte.b	50
      0  13c6					      db	(S4-*)-1
      1  13c6		       e8		      .byte.b	(S4-*)-1
      0  13c7					      IJMP	S6Z
      0  13c7					      db	29
      1  13c7		       1d		      .byte.b	29
      0  13c8					      dw	S6Z
      1  13c8		       cc 13		      .word.w	S6Z
    123  13ca				   S6
      0  13ca					      DONE		;ERROR IF CR NOT NEXT
      0  13ca					      db	1
      1  13ca		       01		      .byte.b	1
      0  13cb					      NLINE
      0  13cb					      db	5
      1  13cb		       05		      .byte.b	5
    126  13cc				   S6Z
      0  13cc					      ENDIO		;release task io completed
      0  13cc					      db	71
      1  13cc		       47		      .byte.b	71
      0  13cd					      NXT	CO	;exit here if , or ; at end of print
      0  13cd					      db	6
      1  13cd		       06		      .byte.b	6
      0  13ce					      dw	CO
      1  13ce		       0a 13		      .word.w	CO
      0  13d0					      IJMP	STMT
      0  13d0					      db	29
      1  13d0		       1d		      .byte.b	29
      0  13d1					      dw	STMT
      1  13d1		       12 13		      .word.w	STMT
    130  13d3							;
    131  13d3							; A jump for code too far away for relative branch
    132  13d3							;
    133  13d3				   ERRVEC
      0  13d3					      ENDIO
      0  13d3					      db	71
      1  13d3		       47		      .byte.b	71
      0  13d4					      IJMP	UNKNOWN
      0  13d4					      db	29
      1  13d4		       1d		      .byte.b	29
      0  13d5					      dw	UNKNOWN
      1  13d5		       22 15		      .word.w	UNKNOWN
    136  13d7							;
    137  13d7							; Get here if there is an expression to print
    138  13d7				   S7
      0  13d7					      TST	S7A,"$"
      0  13d7					      db	32
      1  13d7		       20		      .byte.b	32
      0  13d8					      db	(S7A-*)-1
      1  13d8		       09		      .byte.b	(S7A-*)-1
      0  13d9					      db	"$",0
      1  13d9		       24 00		      .byte.b	"$",0
      0  13db					      CALL	EXPR
      0  13db					      db	28
      1  13db		       1c		      .byte.b	28
      0  13dc					      dw	EXPR
      1  13dc		       26 15		      .word.w	EXPR
      0  13de					      HEXPRT
      0  13de					      db	67
      1  13de		       43		      .byte.b	67
      0  13df					      IJMP	S5
      0  13df					      db	29
      1  13df		       1d		      .byte.b	29
      0  13e0					      dw	S5
      1  13e0		       b7 13		      .word.w	S5
    143  13e2				   S7A
      0  13e2					      CALL	EXPR
      0  13e2					      db	28
      1  13e2		       1c		      .byte.b	28
      0  13e3					      dw	EXPR
      1  13e3		       26 15		      .word.w	EXPR
      0  13e5					      TST	S7B,"$"
      0  13e5					      db	32
      1  13e5		       20		      .byte.b	32
      0  13e6					      db	(S7B-*)-1
      1  13e6		       06		      .byte.b	(S7B-*)-1
      0  13e7					      db	"$",0
      1  13e7		       24 00		      .byte.b	"$",0
      0  13e9					      PUTCHAR
      0  13e9					      db	52
      1  13e9		       34		      .byte.b	52
      0  13ea					      IJMP	S5
      0  13ea					      db	29
      1  13ea		       1d		      .byte.b	29
      0  13eb					      dw	S5
      1  13eb		       b7 13		      .word.w	S5
    148  13ed				   S7B
      0  13ed					      PRN		;PRINT IT
      0  13ed					      db	3
      1  13ed		       03		      .byte.b	3
      0  13ee					      IJMP	S5	;IS THERE MORE?
      0  13ee					      db	29
      1  13ee		       1d		      .byte.b	29
      0  13ef					      dw	S5
      1  13ef		       b7 13		      .word.w	S5
    151  13f1							;
    152  13f1							;===========================================================
    153  13f1							; End of TASK process
    154  13f1				   S8
      0  13f1					      TST	S8a1,"TASK"	; Any Task COmmand
      0  13f1					      db	32
      1  13f1		       20		      .byte.b	32
      0  13f2					      db	(S8a1-*)-1
      1  13f2		       38		      .byte.b	(S8a1-*)-1
      0  13f3					      db	"TASK",0
      1  13f3		       54 41 53 4b*	      .byte.b	"TASK",0
      0  13f8					      TST	S8G,"E"
      0  13f8					      db	32
      1  13f8		       20		      .byte.b	32
      0  13f9					      db	(S8G-*)-1
      1  13f9		       07		      .byte.b	(S8G-*)-1
      0  13fa					      db	"E",0
      1  13fa		       45 00		      .byte.b	"E",0
      0  13fc					      ETASK
      0  13fc					      db	62
      1  13fc		       3e		      .byte.b	62
      0  13fd					      DONE		; Must be last thing on a line
      0  13fd					      db	1
      1  13fd		       01		      .byte.b	1
      0  13fe					      IJMP	STMT
      0  13fe					      db	29
      1  13fe		       1d		      .byte.b	29
      0  13ff					      dw	STMT
      1  13ff		       12 13		      .word.w	STMT
    160  1401							;
    161  1401							;===========================================================
    162  1401							; The task gives up the rest of the cycles
    163  1401				   S8G
      0  1401					      TST	S8a,"N"	;Next task
      0  1401					      db	32
      1  1401		       20		      .byte.b	32
      0  1402					      db	(S8a-*)-1
      1  1402		       09		      .byte.b	(S8a-*)-1
      0  1403					      db	"N",0
      1  1403		       4e 00		      .byte.b	"N",0
      0  1405					      NTASK
      0  1405					      db	63
      1  1405		       3f		      .byte.b	63
      0  1406					      NXT	CO	;Next statement to execute
      0  1406					      db	6
      1  1406		       06		      .byte.b	6
      0  1407					      dw	CO
      1  1407		       0a 13		      .word.w	CO
      0  1409					      IJMP	STMT
      0  1409					      db	29
      1  1409		       1d		      .byte.b	29
      0  140a					      dw	STMT
      1  140a		       12 13		      .word.w	STMT
    168  140c							;
    169  140c							;===========================================================
    170  140c							; Waits for a task or list of tasks to complete
    171  140c				   S8a
      0  140c					      TST	S8TASKNO,"W("	;Wait for tasks
      0  140c					      db	32
      1  140c		       20		      .byte.b	32
      0  140d					      db	(S8TASKNO-*)-1
      1  140d		       1a		      .byte.b	(S8TASKNO-*)-1
      0  140e					      db	"W(",0
      1  140e		       57 28 00 	      .byte.b	"W(",0
    173  1411				   S8TSK
      0  1411					      Call	EXPR	;Gets the PID of task to wait for
      0  1411					      db	28
      1  1411		       1c		      .byte.b	28
      0  1412					      dw	EXPR
      1  1412		       26 15		      .word.w	EXPR
    175  1414				   S8LOOP
      0  1414					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1414					      db	76
      1  1414		       4c		      .byte.b	76
      0  1415					      db	(S8LOOP-*)-1
      1  1415		       fe		      .byte.b	(S8LOOP-*)-1
      0  1416					      TST	S8aa,COMMA	;Checks for more tasks
      0  1416					      db	32
      1  1416		       20		      .byte.b	32
      0  1417					      db	(S8aa-*)-1
      1  1417		       05		      .byte.b	(S8aa-*)-1
      0  1418					      db	COMMA,0
      1  1418		       2c 00		      .byte.b	COMMA,0
      0  141a					      IJMP	S8TSK	;Go for the next task number
      0  141a					      db	29
      1  141a		       1d		      .byte.b	29
      0  141b					      dw	S8TSK
      1  141b		       11 14		      .word.w	S8TSK
    179  141d				   S8aa
      0  141d					      TST	S8TASKNO,")"	;end of list
      0  141d					      db	32
      1  141d		       20		      .byte.b	32
      0  141e					      db	(S8TASKNO-*)-1
      1  141e		       09		      .byte.b	(S8TASKNO-*)-1
      0  141f					      db	")",0
      1  141f		       29 00		      .byte.b	")",0
      0  1421					      DONE
      0  1421					      db	1
      1  1421		       01		      .byte.b	1
      0  1422					      NXT	CO
      0  1422					      db	6
      1  1422		       06		      .byte.b	6
      0  1423					      dw	CO
      1  1423		       0a 13		      .word.w	CO
      0  1425					      IJMP	STMT	;Next Statement
      0  1425					      db	29
      1  1425		       1d		      .byte.b	29
      0  1426					      dw	STMT
      1  1426		       12 13		      .word.w	STMT
    184  1428				   S8TASKNO
    185  1428				   UNKNOWNVEC1
      0  1428					      IJMP	UNKNOWN
      0  1428					      db	29
      1  1428		       1d		      .byte.b	29
      0  1429					      dw	UNKNOWN
      1  1429		       22 15		      .word.w	UNKNOWN
    187  142b
    188  142b							;
    189  142b							;===========================================================
    190  142b							; Update a memory location with a value
    191  142b				   S8a1
      0  142b					      TST	S8b,"POKE("	; Poke a value into memory
      0  142b					      db	32
      1  142b		       20		      .byte.b	32
      0  142c					      db	(S8b-*)-1
      1  142c		       1c		      .byte.b	(S8b-*)-1
      0  142d					      db	"POKE(",0
      1  142d		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1433					      CALL	EXPR	; Get address to write to
      0  1433					      db	28
      1  1433		       1c		      .byte.b	28
      0  1434					      dw	EXPR
      1  1434		       26 15		      .word.w	EXPR
      0  1436					      TST	UNKNOWN,COMMA	; Must have a coma
      0  1436					      db	32
      1  1436		       20		      .byte.b	32
      0  1437					      db	(UNKNOWN-*)-1
      1  1437		       ea		      .byte.b	(UNKNOWN-*)-1
      0  1438					      db	COMMA,0
      1  1438		       2c 00		      .byte.b	COMMA,0
      0  143a					      CALL	EXPR	; Get the value to poke
      0  143a					      db	28
      1  143a		       1c		      .byte.b	28
      0  143b					      dw	EXPR
      1  143b		       26 15		      .word.w	EXPR
      0  143d					      TST	UNKNOWN,")"	; closing bracket
      0  143d					      db	32
      1  143d		       20		      .byte.b	32
      0  143e					      db	(UNKNOWN-*)-1
      1  143e		       e3		      .byte.b	(UNKNOWN-*)-1
      0  143f					      db	")",0
      1  143f		       29 00		      .byte.b	")",0
      0  1441					      POKEMEM
      0  1441					      db	47
      1  1441		       2f		      .byte.b	47
      0  1442					      DONE
      0  1442					      db	1
      1  1442		       01		      .byte.b	1
      0  1443					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1443					      db	6
      1  1443		       06		      .byte.b	6
      0  1444					      dw	CO
      1  1444		       0a 13		      .word.w	CO
      0  1446					      IJMP	STMT
      0  1446					      db	29
      1  1446		       1d		      .byte.b	29
      0  1447					      dw	STMT
      1  1447		       12 13		      .word.w	STMT
    201  1449
    202  1449				   S8b
      0  1449					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1449					      db	32
      1  1449		       20		      .byte.b	32
      0  144a					      db	(S8c-*)-1
      1  144a		       11		      .byte.b	(S8c-*)-1
      0  144b					      db	"PUTCH",0
      1  144b		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1451					      CALL	EXPR
      0  1451					      db	28
      1  1451		       1c		      .byte.b	28
      0  1452					      dw	EXPR
      1  1452		       26 15		      .word.w	EXPR
      0  1454					      PUTCHAR
      0  1454					      db	52
      1  1454		       34		      .byte.b	52
      0  1455					      DONE
      0  1455					      db	1
      1  1455		       01		      .byte.b	1
      0  1456					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1456					      db	6
      1  1456		       06		      .byte.b	6
      0  1457					      dw	CO
      1  1457		       0a 13		      .word.w	CO
      0  1459					      IJMP	STMT
      0  1459					      db	29
      1  1459		       1d		      .byte.b	29
      0  145a					      dw	STMT
      1  145a		       12 13		      .word.w	STMT
    209  145c				   S8c
      0  145c					      TST	S9,"CLS"	;Clear the screen
      0  145c					      db	32
      1  145c		       20		      .byte.b	32
      0  145d					      db	(S9-*)-1
      1  145d		       0b		      .byte.b	(S9-*)-1
      0  145e					      db	"CLS",0
      1  145e		       43 4c 53 00	      .byte.b	"CLS",0
      0  1462					      CLEARSCREEN
      0  1462					      db	46
      1  1462		       2e		      .byte.b	46
      0  1463					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1463					      db	6
      1  1463		       06		      .byte.b	6
      0  1464					      dw	CO
      1  1464		       0a 13		      .word.w	CO
      0  1466					      IJMP	STMT
      0  1466					      db	29
      1  1466		       1d		      .byte.b	29
      0  1467					      dw	STMT
      1  1467		       12 13		      .word.w	STMT
    214  1469				   S9
      0  1469					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1469					      db	32
      1  1469		       20		      .byte.b	32
      0  146a					      db	(S13-*)-1
      1  146a		       2a		      .byte.b	(S13-*)-1
      0  146b					      db	"INPUT",0
      1  146b		       49 4e 50 55*	      .byte.b	"INPUT",0
    216  1471				   S10
      0  1471					      TSTSTR	S10A	;If there is a string print the prompt
      0  1471					      db	55
      1  1471		       37		      .byte.b	55
      0  1472					      db	(S10A-*)-1
      1  1472		       05		      .byte.b	(S10A-*)-1
      0  1473					      PRS
      0  1473					      db	2
      1  1473		       02		      .byte.b	2
      0  1474					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1474					      db	32
      1  1474		       20		      .byte.b	32
      0  1475					      db	(S10Z-*)-1
      1  1475		       15		      .byte.b	(S10Z-*)-1
      0  1476					      db	SEMICOLON,0
      1  1476		       3b 00		      .byte.b	SEMICOLON,0
    220  1478				   S10A
      0  1478					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1478					      db	33
      1  1478		       21		      .byte.b	33
      0  1479					      db	(UNKNOWN-*)-1
      1  1479		       a8		      .byte.b	(UNKNOWN-*)-1
      0  147a					      TST	S10A1,DOLLAR
      0  147a					      db	32
      1  147a		       20		      .byte.b	32
      0  147b					      db	(S10A1-*)-1
      1  147b		       06		      .byte.b	(S10A1-*)-1
      0  147c					      db	DOLLAR,0
      1  147c		       24 00		      .byte.b	DOLLAR,0
      0  147e					      INSTR		;Move character From tty to AESTK
      0  147e					      db	59
      1  147e		       3b		      .byte.b	59
      0  147f					      IJMP	S10A2
      0  147f					      db	29
      1  147f		       1d		      .byte.b	29
      0  1480					      dw	S10A2
      1  1480		       83 14		      .word.w	S10A2
    225  1482				   S10A1
      0  1482					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1482					      db	11
      1  1482		       0b		      .byte.b	11
    227  1483				   S10A2
      0  1483					      STORE		;STORE IT
      0  1483					      db	19
      1  1483		       13		      .byte.b	19
      0  1484					      TST	S11,COMMA	;IS THERE MORE?
      0  1484					      db	32
      1  1484		       20		      .byte.b	32
      0  1485					      db	(S11-*)-1
      1  1485		       08		      .byte.b	(S11-*)-1
      0  1486					      db	COMMA,0
      1  1486		       2c 00		      .byte.b	COMMA,0
      0  1488					      IJMP	S10	;YES
      0  1488					      db	29
      1  1488		       1d		      .byte.b	29
      0  1489					      dw	S10
      1  1489		       71 14		      .word.w	S10
    231  148b				   S10Z
      0  148b					      iJMP	UNKNOWN
      0  148b					      db	29
      1  148b		       1d		      .byte.b	29
      0  148c					      dw	UNKNOWN
      1  148c		       22 15		      .word.w	UNKNOWN
    233  148e				   S11
      0  148e					      DONE		;MUST BE CR
      0  148e					      db	1
      1  148e		       01		      .byte.b	1
      0  148f					      NXT	CO	;SEQUENCE TO NEXT
      0  148f					      db	6
      1  148f		       06		      .byte.b	6
      0  1490					      dw	CO
      1  1490		       0a 13		      .word.w	CO
      0  1492					      IJMP	STMT
      0  1492					      db	29
      1  1492		       1d		      .byte.b	29
      0  1493					      dw	STMT
      1  1493		       12 13		      .word.w	STMT
    237  1495				   S13
      0  1495					      TST	S14,"END"
      0  1495					      db	32
      1  1495		       20		      .byte.b	32
      0  1496					      db	(S14-*)-1
      1  1496		       05		      .byte.b	(S14-*)-1
      0  1497					      db	"END",0
      1  1497		       45 4e 44 00	      .byte.b	"END",0
      0  149b					      FIN
      0  149b					      db	12
      1  149b		       0c		      .byte.b	12
    240  149c
    241  149c				   S14
      0  149c					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  149c					      db	32
      1  149c		       20		      .byte.b	32
      0  149d					      db	(S14Z-*)-1
      1  149d		       0f		      .byte.b	(S14Z-*)-1
      0  149e					      db	"IRQ",0
      1  149e		       49 52 51 00	      .byte.b	"IRQ",0
      0  14a2					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  14a2					      db	28
      1  14a2		       1c		      .byte.b	28
      0  14a3					      dw	EXPR
      1  14a3		       26 15		      .word.w	EXPR
      0  14a5					      DONE		;must be CR
      0  14a5					      db	1
      1  14a5		       01		      .byte.b	1
      0  14a6					      SETIRQ		;Set the line number now
      0  14a6					      db	56
      1  14a6		       38		      .byte.b	56
      0  14a7					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  14a7					      db	6
      1  14a7		       06		      .byte.b	6
      0  14a8					      dw	CO
      1  14a8		       0a 13		      .word.w	CO
      0  14aa					      IJMP	STMT
      0  14aa					      db	29
      1  14aa		       1d		      .byte.b	29
      0  14ab					      dw	STMT
      1  14ab		       12 13		      .word.w	STMT
    248  14ad
    249  14ad				   S14Z
      0  14ad					      TST	S14S1,"KILL"	; Kill A running Task
      0  14ad					      db	32
      1  14ad		       20		      .byte.b	32
      0  14ae					      db	(S14S1-*)-1
      1  14ae		       10		      .byte.b	(S14S1-*)-1
      0  14af					      db	"KILL",0
      1  14af		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  14b4					      CALL	EXPR
      0  14b4					      db	28
      1  14b4		       1c		      .byte.b	28
      0  14b5					      dw	EXPR
      1  14b5		       26 15		      .word.w	EXPR
      0  14b7					      DONE
      0  14b7					      db	1
      1  14b7		       01		      .byte.b	1
      0  14b8					      TASKKILL
      0  14b8					      db	65
      1  14b8		       41		      .byte.b	65
      0  14b9					      NXT	CO
      0  14b9					      db	6
      1  14b9		       06		      .byte.b	6
      0  14ba					      dw	CO
      1  14ba		       0a 13		      .word.w	CO
      0  14bc					      IJMP	STMT
      0  14bc					      db	29
      1  14bc		       1d		      .byte.b	29
      0  14bd					      dw	STMT
      1  14bd		       12 13		      .word.w	STMT
    256  14bf
    257  14bf				   S14S1
      0  14bf					      TST	S15,"LIST"	;LIST COMMAND
      0  14bf					      db	32
      1  14bf		       20		      .byte.b	32
      0  14c0					      db	(S15-*)-1
      1  14c0		       0a		      .byte.b	(S15-*)-1
      0  14c1					      db	"LIST",0
      1  14c1		       4c 49 53 54*	      .byte.b	"LIST",0
      0  14c6					      DONE
      0  14c6					      db	1
      1  14c6		       01		      .byte.b	1
      0  14c7					      LST
      0  14c7					      db	21
      1  14c7		       15		      .byte.b	21
      0  14c8					      IJMP	CO
      0  14c8					      db	29
      1  14c8		       1d		      .byte.b	29
      0  14c9					      dw	CO
      1  14c9		       0a 13		      .word.w	CO
    262  14cb				   S15
      0  14cb					      TST	S16,"RUN"	;RUN COMMAND
      0  14cb					      db	32
      1  14cb		       20		      .byte.b	32
      0  14cc					      db	(S16-*)-1
      1  14cc		       0d		      .byte.b	(S16-*)-1
      0  14cd					      db	"RUN",0
      1  14cd		       52 55 4e 00	      .byte.b	"RUN",0
      0  14d1					      DONE
      0  14d1					      db	1
      1  14d1		       01		      .byte.b	1
      0  14d2					      VINIT		;clear variables
      0  14d2					      db	30
      1  14d2		       1e		      .byte.b	30
      0  14d3					      LIT	1	;GOTO line 1
      0  14d3					      db	27
      1  14d3		       1b		      .byte.b	27
      0  14d4					      dw	1
      1  14d4		       01 00		      .word.w	1
      0  14d6					      XFER		;Bob's addition
      0  14d6					      db	7
      1  14d6		       07		      .byte.b	7
    268  14d7							; EXIT
      0  14d7					      IJMP	STMT	;and run!
      0  14d7					      db	29
      1  14d7		       1d		      .byte.b	29
      0  14d8					      dw	STMT
      1  14d8		       12 13		      .word.w	STMT
    270  14da				   S16
      0  14da					      TST	S17A,"NEW"	;clear program
      0  14da					      db	32
      1  14da		       20		      .byte.b	32
      0  14db					      db	(S17A-*)-1
      1  14db		       08		      .byte.b	(S17A-*)-1
      0  14dc					      db	"NEW",0
      1  14dc		       4e 45 57 00	      .byte.b	"NEW",0
      0  14e0					      DONE
      0  14e0					      db	1
      1  14e0		       01		      .byte.b	1
      0  14e1					      IJMP	START
      0  14e1					      db	29
      1  14e1		       1d		      .byte.b	29
      0  14e2					      dw	START
      1  14e2		       04 13		      .word.w	START
    274  14e4
    275  14e4				   S17A
      0  14e4					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  14e4					      db	32
      1  14e4		       20		      .byte.b	32
      0  14e5					      db	(S17B-*)-1
      1  14e5		       06		      .byte.b	(S17B-*)-1
      0  14e6					      db	"EXIT",0
      1  14e6		       45 58 49 54*	      .byte.b	"EXIT",0
      0  14eb					      EXIT
      0  14eb					      db	26
      1  14eb		       1a		      .byte.b	26
    278  14ec
    279  14ec							;
    280  14ec							; Commands related to saving/restoring programs
    281  14ec							; to/from mass storage.
    282  14ec							;
    283  14ec				   S17B
    284  14ec					      if	(XKIM || CTMON65) && DISK_ACCESS
    285  14ec
      0  14ec					      TST	S17C,"SAVE"
      0  14ec					      db	32
      1  14ec		       20		      .byte.b	32
      0  14ed					      db	(S17C-*)-1
      1  14ed		       0b		      .byte.b	(S17C-*)-1
      0  14ee					      db	"SAVE",0
      1  14ee		       53 41 56 45*	      .byte.b	"SAVE",0
      0  14f3					      OPENWRITE
      0  14f3					      db	40
      1  14f3		       28		      .byte.b	40
      0  14f4					      DLIST
      0  14f4					      db	43
      1  14f4		       2b		      .byte.b	43
      0  14f5					      DCLOSE
      0  14f5					      db	41
      1  14f5		       29		      .byte.b	41
      0  14f6					      IJMP	CO
      0  14f6					      db	29
      1  14f6		       1d		      .byte.b	29
      0  14f7					      dw	CO
      1  14f7		       0a 13		      .word.w	CO
    291  14f9
    292  14f9				   S17C
      0  14f9					      TST	S18,"LOAD"
      0  14f9					      db	32
      1  14f9		       20		      .byte.b	32
      0  14fa					      db	(S18-*)-1
      1  14fa		       11		      .byte.b	(S18-*)-1
      0  14fb					      db	"LOAD",0
      1  14fb		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1500					      OPENREAD
      0  1500					      db	39
      1  1500		       27		      .byte.b	39
    295  1501				   S17CLP
      0  1501					      DGETLINE		;get line from file
      0  1501					      db	42
      1  1501		       2a		      .byte.b	42
      0  1502					      TSTL	S17EOL	;no line num means EOL
      0  1502					      db	34
      1  1502		       22		      .byte.b	34
      0  1503					      db	(S17EOL-*)-1
      1  1503		       04		      .byte.b	(S17EOL-*)-1
      0  1504					      INSERT		;put it into the program
      0  1504					      db	24
      1  1504		       18		      .byte.b	24
      0  1505					      IJMP	S17CLP	;keep going
      0  1505					      db	29
      1  1505		       1d		      .byte.b	29
      0  1506					      dw	S17CLP
      1  1506		       01 15		      .word.w	S17CLP
    300  1508				   S17EOL
      0  1508					      DCLOSE		;close disk file
      0  1508					      db	41
      1  1508		       29		      .byte.b	41
      0  1509					      IJMP	CO	;back to start
      0  1509					      db	29
      1  1509		       1d		      .byte.b	29
      0  150a					      dw	CO
      1  150a		       0a 13		      .word.w	CO
    303  150c
      0  150c				   S18	      TST	S19,"DIR"
      0  150c					      db	32
      1  150c		       20		      .byte.b	32
      0  150d					      db	(S19-*)-1
      1  150d		       08		      .byte.b	(S19-*)-1
      0  150e					      db	"DIR",0
      1  150e		       44 49 52 00	      .byte.b	"DIR",0
      0  1512					      DDIR		;Display the directory content
      0  1512					      db	44
      1  1512		       2c		      .byte.b	44
      0  1513					      IJMP	CO
      0  1513					      db	29
      1  1513		       1d		      .byte.b	29
      0  1514					      dw	CO
      1  1514		       0a 13		      .word.w	CO
    307  1516					      endif
    308  1516
      0  1516				   S19	      TST	UNKNOWN,"ERASE"
      0  1516					      db	32
      1  1516		       20		      .byte.b	32
      0  1517					      db	(UNKNOWN-*)-1
      1  1517		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1518					      db	"ERASE",0
      1  1518		       45 52 41 53*	      .byte.b	"ERASE",0
      0  151e					      RMFILE		;Erase the file from the disk
      0  151e					      db	45
      1  151e		       2d		      .byte.b	45
      0  151f					      IJMP	CO
      0  151f					      db	29
      1  151f		       1d		      .byte.b	29
      0  1520					      dw	CO
      1  1520		       0a 13		      .word.w	CO
    312  1520					      endif
    313  1522
    314  1522							;
    315  1522							; Else, unknown command.
    316  1522							;
    317  1522				   UNKNOWN
      0  1522					      ENDIO
      0  1522					      db	71
      1  1522		       47		      .byte.b	71
      0  1523					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1523					      db	13
      1  1523		       0d		      .byte.b	13
      0  1524					      dw	ERR_SYNTAX
      1  1524		       05 00		      .word.w	ERR_SYNTAX
    320  1526
    321  1526							;-----------------------------------------------------
    322  1526				   EXPR
      0  1526					      TST	EXPRNOT,"NOT"
      0  1526					      db	32
      1  1526		       20		      .byte.b	32
      0  1527					      db	(EXPRNOT-*)-1
      1  1527		       09		      .byte.b	(EXPRNOT-*)-1
      0  1528					      db	"NOT",0
      1  1528		       4e 4f 54 00	      .byte.b	"NOT",0
      0  152c					      Call	EXPRLOGS
      0  152c					      db	28
      1  152c		       1c		      .byte.b	28
      0  152d					      dw	EXPRLOGS
      1  152d		       31 15		      .word.w	EXPRLOGS
      0  152f					      LOGNOT
      0  152f					      db	72
      1  152f		       48		      .byte.b	72
      0  1530					      RTN
      0  1530					      db	25
      1  1530		       19		      .byte.b	25
    327  1531				   EXPRNOT
    328  1531
    329  1531				   EXPRLOGS
      0  1531					      Call	EXPRCMP
      0  1531					      db	28
      1  1531		       1c		      .byte.b	28
      0  1532					      dw	EXPRCMP
      1  1532		       55 15		      .word.w	EXPRCMP
      0  1534					      TST	iLOG1,"AND"
      0  1534					      db	32
      1  1534		       20		      .byte.b	32
      0  1535					      db	(iLOG1-*)-1
      1  1535		       09		      .byte.b	(iLOG1-*)-1
      0  1536					      db	"AND",0
      1  1536		       41 4e 44 00	      .byte.b	"AND",0
      0  153a					      Call	EXPRCMP
      0  153a					      db	28
      1  153a		       1c		      .byte.b	28
      0  153b					      dw	EXPRCMP
      1  153b		       55 15		      .word.w	EXPRCMP
      0  153d					      LOGAND
      0  153d					      db	74
      1  153d		       4a		      .byte.b	74
      0  153e					      RTN
      0  153e					      db	25
      1  153e		       19		      .byte.b	25
    335  153f				   iLOG1
      0  153f					      TST	iLOG2,"OR"
      0  153f					      db	32
      1  153f		       20		      .byte.b	32
      0  1540					      db	(iLOG2-*)-1
      1  1540		       08		      .byte.b	(iLOG2-*)-1
      0  1541					      db	"OR",0
      1  1541		       4f 52 00 	      .byte.b	"OR",0
      0  1544					      Call	EXPRCMP
      0  1544					      db	28
      1  1544		       1c		      .byte.b	28
      0  1545					      dw	EXPRCMP
      1  1545		       55 15		      .word.w	EXPRCMP
      0  1547					      LOGOR
      0  1547					      db	73
      1  1547		       49		      .byte.b	73
      0  1548					      RTN
      0  1548					      db	25
      1  1548		       19		      .byte.b	25
    340  1549				   iLOG2
      0  1549					      TST	iLOG3,"XOR"
      0  1549					      db	32
      1  1549		       20		      .byte.b	32
      0  154a					      db	(iLOG3-*)-1
      1  154a		       09		      .byte.b	(iLOG3-*)-1
      0  154b					      db	"XOR",0
      1  154b		       58 4f 52 00	      .byte.b	"XOR",0
      0  154f					      Call	EXPRCMP
      0  154f					      db	28
      1  154f		       1c		      .byte.b	28
      0  1550					      dw	EXPRCMP
      1  1550		       55 15		      .word.w	EXPRCMP
      0  1552					      LOGXOR
      0  1552					      db	75
      1  1552		       4b		      .byte.b	75
      0  1553					      RTN
      0  1553					      db	25
      1  1553		       19		      .byte.b	25
    345  1554				   iLOG3
      0  1554					      RTN
      0  1554					      db	25
      1  1554		       19		      .byte.b	25
    347  1555
    348  1555				   EXPRCMP
      0  1555					      Call	EXPR2	; get the first expression
      0  1555					      db	28
      1  1555		       1c		      .byte.b	28
      0  1556					      dw	EXPR2
      1  1556		       a0 15		      .word.w	EXPR2
      0  1558					      TST	iR0,"="
      0  1558					      db	32
      1  1558		       20		      .byte.b	32
      0  1559					      db	(iR0-*)-1
      1  1559		       08		      .byte.b	(iR0-*)-1
      0  155a					      db	"=",0
      1  155a		       3d 00		      .byte.b	"=",0
      0  155c					      LIT	2	;=
      0  155c					      db	27
      1  155c		       1b		      .byte.b	27
      0  155d					      dw	2
      1  155d		       02 00		      .word.w	2
      0  155f					      IJMP	iRFound
      0  155f					      db	29
      1  155f		       1d		      .byte.b	29
      0  1560					      dw	iRFound
      1  1560		       9b 15		      .word.w	iRFound
    353  1562				   iR0
      0  1562					      TST	iR4,"<"
      0  1562					      db	32
      1  1562		       20		      .byte.b	32
      0  1563					      db	(iR4-*)-1
      1  1563		       1c		      .byte.b	(iR4-*)-1
      0  1564					      db	"<",0
      1  1564		       3c 00		      .byte.b	"<",0
      0  1566					      TST	iR1,"="
      0  1566					      db	32
      1  1566		       20		      .byte.b	32
      0  1567					      db	(iR1-*)-1
      1  1567		       08		      .byte.b	(iR1-*)-1
      0  1568					      db	"=",0
      1  1568		       3d 00		      .byte.b	"=",0
      0  156a					      LIT	3	;<=
      0  156a					      db	27
      1  156a		       1b		      .byte.b	27
      0  156b					      dw	3
      1  156b		       03 00		      .word.w	3
      0  156d					      IJMP	iRFound
      0  156d					      db	29
      1  156d		       1d		      .byte.b	29
      0  156e					      dw	iRFound
      1  156e		       9b 15		      .word.w	iRFound
    358  1570				   iR1
      0  1570					      TST	iR3,">"
      0  1570					      db	32
      1  1570		       20		      .byte.b	32
      0  1571					      db	(iR3-*)-1
      1  1571		       08		      .byte.b	(iR3-*)-1
      0  1572					      db	">",0
      1  1572		       3e 00		      .byte.b	">",0
      0  1574					      LIT	5	;<>
      0  1574					      db	27
      1  1574		       1b		      .byte.b	27
      0  1575					      dw	5
      1  1575		       05 00		      .word.w	5
      0  1577					      IJMP	iRFound
      0  1577					      db	29
      1  1577		       1d		      .byte.b	29
      0  1578					      dw	iRFound
      1  1578		       9b 15		      .word.w	iRFound
    362  157a				   iR3
      0  157a					      LIT	1	;<
      0  157a					      db	27
      1  157a		       1b		      .byte.b	27
      0  157b					      dw	1
      1  157b		       01 00		      .word.w	1
      0  157d					      IJMP	iRFound
      0  157d					      db	29
      1  157d		       1d		      .byte.b	29
      0  157e					      dw	iRFound
      1  157e		       9b 15		      .word.w	iRFound
    365  1580				   iR4
      0  1580					      TST	iRDone,">"
      0  1580					      db	32
      1  1580		       20		      .byte.b	32
      0  1581					      db	(iRDone-*)-1
      1  1581		       1d		      .byte.b	(iRDone-*)-1
      0  1582					      db	">",0
      1  1582		       3e 00		      .byte.b	">",0
      0  1584					      TST	iR5,"="
      0  1584					      db	32
      1  1584		       20		      .byte.b	32
      0  1585					      db	(iR5-*)-1
      1  1585		       08		      .byte.b	(iR5-*)-1
      0  1586					      db	"=",0
      1  1586		       3d 00		      .byte.b	"=",0
      0  1588					      LIT	6	;>=
      0  1588					      db	27
      1  1588		       1b		      .byte.b	27
      0  1589					      dw	6
      1  1589		       06 00		      .word.w	6
      0  158b					      IJMP	iRFound
      0  158b					      db	29
      1  158b		       1d		      .byte.b	29
      0  158c					      dw	iRFound
      1  158c		       9b 15		      .word.w	iRFound
    370  158e				   iR5
      0  158e					      TST	iR6,"<"
      0  158e					      db	32
      1  158e		       20		      .byte.b	32
      0  158f					      db	(iR6-*)-1
      1  158f		       08		      .byte.b	(iR6-*)-1
      0  1590					      db	"<",0
      1  1590		       3c 00		      .byte.b	"<",0
      0  1592					      LIT	1
      0  1592					      db	27
      1  1592		       1b		      .byte.b	27
      0  1593					      dw	1
      1  1593		       01 00		      .word.w	1
      0  1595					      IJMP	iRFound	;(This line originally omitted)
      0  1595					      db	29
      1  1595		       1d		      .byte.b	29
      0  1596					      dw	iRFound
      1  1596		       9b 15		      .word.w	iRFound
    374  1598				   iR6
      0  1598					      LIT	4	;>
      0  1598					      db	27
      1  1598		       1b		      .byte.b	27
      0  1599					      dw	4
      1  1599		       04 00		      .word.w	4
    376  159b				   iRFound
      0  159b					      Call	EXPR2	; get the right side of the expression
      0  159b					      db	28
      1  159b		       1c		      .byte.b	28
      0  159c					      dw	EXPR2
      1  159c		       a0 15		      .word.w	EXPR2
      0  159e					      CMPR		; Push the value of the true false onto the stack
      0  159e					      db	10
      1  159e		       0a		      .byte.b	10
    379  159f
    380  159f				   iRDone
      0  159f					      RTN
      0  159f					      db	25
      1  159f		       19		      .byte.b	25
    382  15a0
    383  15a0				   EXPR2
      0  15a0					      TST	E0,"-"	; Look for leading - to negate term
      0  15a0					      db	32
      1  15a0		       20		      .byte.b	32
      0  15a1					      db	(E0-*)-1
      1  15a1		       09		      .byte.b	(E0-*)-1
      0  15a2					      db	"-",0
      1  15a2		       2d 00		      .byte.b	"-",0
      0  15a4					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  15a4					      db	28
      1  15a4		       1c		      .byte.b	28
      0  15a5					      dw	TERM
      1  15a5		       c9 15		      .word.w	TERM
      0  15a7					      NEG		; Make value negated
      0  15a7					      db	16
      1  15a7		       10		      .byte.b	16
      0  15a8					      IJMP	E1	; We have Left term process operators next
      0  15a8					      db	29
      1  15a8		       1d		      .byte.b	29
      0  15a9					      dw	E1
      1  15a9		       b2 15		      .word.w	E1
    388  15ab				   E0
      0  15ab					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  15ab					      db	32
      1  15ab		       20		      .byte.b	32
      0  15ac					      db	(E1A-*)-1
      1  15ac		       02		      .byte.b	(E1A-*)-1
      0  15ad					      db	"+",0
      1  15ad		       2b 00		      .byte.b	"+",0
    390  15af				   E1A
      0  15af					      CALL	TERM	; Get the left term if it was not negated
      0  15af					      db	28
      1  15af		       1c		      .byte.b	28
      0  15b0					      dw	TERM
      1  15b0		       c9 15		      .word.w	TERM
    392  15b2				   E1
      0  15b2					      TST	E2,"+"	; Check if we are adding left term to something
      0  15b2					      db	32
      1  15b2		       20		      .byte.b	32
      0  15b3					      db	(E2-*)-1
      1  15b3		       09		      .byte.b	(E2-*)-1
      0  15b4					      db	"+",0
      1  15b4		       2b 00		      .byte.b	"+",0
      0  15b6					      CALL	TERM	; if adding then get the right side term
      0  15b6					      db	28
      1  15b6		       1c		      .byte.b	28
      0  15b7					      dw	TERM
      1  15b7		       c9 15		      .word.w	TERM
      0  15b9					      ADD		; Add it to left term
      0  15b9					      db	14
      1  15b9		       0e		      .byte.b	14
      0  15ba					      IJMP	E1	; look for next + or -
      0  15ba					      db	29
      1  15ba		       1d		      .byte.b	29
      0  15bb					      dw	E1
      1  15bb		       b2 15		      .word.w	E1
    397  15bd				   E2
      0  15bd					      TST	E3,"-"	; Check if we are subtractig something
      0  15bd					      db	32
      1  15bd		       20		      .byte.b	32
      0  15be					      db	(E3-*)-1
      1  15be		       09		      .byte.b	(E3-*)-1
      0  15bf					      db	"-",0
      1  15bf		       2d 00		      .byte.b	"-",0
      0  15c1					      CALL	TERM	; get right side to subtract Diffrence
      0  15c1					      db	28
      1  15c1		       1c		      .byte.b	28
      0  15c2					      dw	TERM
      1  15c2		       c9 15		      .word.w	TERM
      0  15c4					      SUB		; Subtract the value
      0  15c4					      db	15
      1  15c4		       0f		      .byte.b	15
      0  15c5					      IJMP	E1	; Look for next + or -
      0  15c5					      db	29
      1  15c5		       1d		      .byte.b	29
      0  15c6					      dw	E1
      1  15c6		       b2 15		      .word.w	E1
    402  15c8				   E3			; Finish processing the expression
      0  15c8					      RTN		; We are finished processing the Expression
      0  15c8					      db	25
      1  15c8		       19		      .byte.b	25
    404  15c9							;
    405  15c9							; Get one of the terms of an expression
    406  15c9							;
    407  15c9				   TERM
      0  15c9					      CALL	FACT	; Get a value
      0  15c9					      db	28
      1  15c9		       1c		      .byte.b	28
      0  15ca					      dw	FACT
      1  15ca		       f1 15		      .word.w	FACT
    409  15cc				   T0			; Check for higher precidence operators
      0  15cc					      TST	T1,"*"	; Check for *
      0  15cc					      db	32
      1  15cc		       20		      .byte.b	32
      0  15cd					      db	(T1-*)-1
      1  15cd		       09		      .byte.b	(T1-*)-1
      0  15ce					      db	"*",0
      1  15ce		       2a 00		      .byte.b	"*",0
      0  15d0					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  15d0					      db	28
      1  15d0		       1c		      .byte.b	28
      0  15d1					      dw	FACT
      1  15d1		       f1 15		      .word.w	FACT
      0  15d3					      MUL		; Multiply factors
      0  15d3					      db	17
      1  15d3		       11		      .byte.b	17
      0  15d4					      IJMP	T0	; Check for * or /
      0  15d4					      db	29
      1  15d4		       1d		      .byte.b	29
      0  15d5					      dw	T0
      1  15d5		       cc 15		      .word.w	T0
    414  15d7				   T1
      0  15d7					      TST	T2,"/"	; Check for a division
      0  15d7					      db	32
      1  15d7		       20		      .byte.b	32
      0  15d8					      db	(T2-*)-1
      1  15d8		       09		      .byte.b	(T2-*)-1
      0  15d9					      db	"/",0
      1  15d9		       2f 00		      .byte.b	"/",0
      0  15db					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  15db					      db	28
      1  15db		       1c		      .byte.b	28
      0  15dc					      dw	FACT
      1  15dc		       f1 15		      .word.w	FACT
      0  15de					      DIV		; do division
      0  15de					      db	18
      1  15de		       12		      .byte.b	18
      0  15df					      IJMP	T0	; check for more * or /
      0  15df					      db	29
      1  15df		       1d		      .byte.b	29
      0  15e0					      dw	T0
      1  15e0		       cc 15		      .word.w	T0
    419  15e2				   T2
      0  15e2					      TST	T3,"%"	; Check for a division
      0  15e2					      db	32
      1  15e2		       20		      .byte.b	32
      0  15e3					      db	(T3-*)-1
      1  15e3		       09		      .byte.b	(T3-*)-1
      0  15e4					      db	"%",0
      1  15e4		       25 00		      .byte.b	"%",0
      0  15e6					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  15e6					      db	28
      1  15e6		       1c		      .byte.b	28
      0  15e7					      dw	FACT
      1  15e7		       f1 15		      .word.w	FACT
      0  15e9					      MODULO		; do division for remainder
      0  15e9					      db	60
      1  15e9		       3c		      .byte.b	60
      0  15ea					      IJMP	T0	; check for more * or / or %
      0  15ea					      db	29
      1  15ea		       1d		      .byte.b	29
      0  15eb					      dw	T0
      1  15eb		       cc 15		      .word.w	T0
    424  15ed				   T3			; Finish processing the Term
      0  15ed					      RTN
      0  15ed					      db	25
      1  15ed		       19		      .byte.b	25
    426  15ee
    427  15ee				   UNKNOWNVEC
      0  15ee					      IJMP	UNKNOWN
      0  15ee					      db	29
      1  15ee		       1d		      .byte.b	29
      0  15ef					      dw	UNKNOWN
      1  15ef		       22 15		      .word.w	UNKNOWN
    429  15f1
    430  15f1							;
    431  15f1							; Factor an expression.  Always test for functions
    432  15f1							; first or else they'll be confused for variables.
    433  15f1							;
    434  15f1				   FACT
      0  15f1					      TST	F1AA,"TRUE"
      0  15f1					      db	32
      1  15f1		       20		      .byte.b	32
      0  15f2					      db	(F1AA-*)-1
      1  15f2		       09		      .byte.b	(F1AA-*)-1
      0  15f3					      db	"TRUE",0
      1  15f3		       54 52 55 45*	      .byte.b	"TRUE",0
      0  15f8					      LIT	-1
      0  15f8					      db	27
      1  15f8		       1b		      .byte.b	27
      0  15f9					      dw	-1
      1  15f9		       ff ff		      .word.w	-1
      0  15fb					      RTN
      0  15fb					      db	25
      1  15fb		       19		      .byte.b	25
    438  15fc				   F1AA
      0  15fc					      TST	F1AB,"FALSE"
      0  15fc					      db	32
      1  15fc		       20		      .byte.b	32
      0  15fd					      db	(F1AB-*)-1
      1  15fd		       0a		      .byte.b	(F1AB-*)-1
      0  15fe					      db	"FALSE",0
      1  15fe		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1604					      LIT	0
      0  1604					      db	27
      1  1604		       1b		      .byte.b	27
      0  1605					      dw	0
      1  1605		       00 00		      .word.w	0
      0  1607					      RTN
      0  1607					      db	25
      1  1607		       19		      .byte.b	25
    442  1608				   F1AB
      0  1608					      TST	F1A,"FREE()"
      0  1608					      db	32
      1  1608		       20		      .byte.b	32
      0  1609					      db	(F1A-*)-1
      1  1609		       09		      .byte.b	(F1A-*)-1
      0  160a					      db	"FREE()",0
      1  160a		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1611					      FREE
      0  1611					      db	36
      1  1611		       24		      .byte.b	36
      0  1612					      RTN
      0  1612					      db	25
      1  1612		       19		      .byte.b	25
    446  1613				   F1A
      0  1613					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1613					      db	32
      1  1613		       20		      .byte.b	32
      0  1614					      db	(F1A2-*)-1
      1  1614		       0a		      .byte.b	(F1A2-*)-1
      0  1615					      db	"GETCH()",0
      1  1615		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  161d					      GETCHAR
      0  161d					      db	51
      1  161d		       33		      .byte.b	51
      0  161e					      RTN
      0  161e					      db	25
      1  161e		       19		      .byte.b	25
    450  161f				   F1A2
      0  161f					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  161f					      db	32
      1  161f		       20		      .byte.b	32
      0  1620					      db	(F2AZ-*)-1
      1  1620		       0f		      .byte.b	(F2AZ-*)-1
      0  1621					      db	"PEEK(",0
      1  1621		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1627					      CALL	EXPR	;Get the address to write to
      0  1627					      db	28
      1  1627		       1c		      .byte.b	28
      0  1628					      dw	EXPR
      1  1628		       26 15		      .word.w	EXPR
      0  162a					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  162a					      db	32
      1  162a		       20		      .byte.b	32
      0  162b					      db	(UNKNOWNVEC-*)-1
      1  162b		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  162c					      db	")",0
      1  162c		       29 00		      .byte.b	")",0
      0  162e					      PEEKMEM
      0  162e					      db	48
      1  162e		       30		      .byte.b	48
      0  162f					      RTN
      0  162f					      db	25
      1  162f		       19		      .byte.b	25
    456  1630				   F2AZ
      0  1630					      TST	F2A,"TASK("	;Check if we are setting a task start
      0  1630					      db	32
      1  1630		       20		      .byte.b	32
      0  1631					      db	(F2A-*)-1
      1  1631		       0f		      .byte.b	(F2A-*)-1
      0  1632					      db	"TASK(",0
      1  1632		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1638					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1638					      db	28
      1  1638		       1c		      .byte.b	28
      0  1639					      dw	EXPR
      1  1639		       26 15		      .word.w	EXPR
      0  163b					      TST	UNKNOWNVEC,")"	;must be )
      0  163b					      db	32
      1  163b		       20		      .byte.b	32
      0  163c					      db	(UNKNOWNVEC-*)-1
      1  163c		       b1		      .byte.b	(UNKNOWNVEC-*)-1
      0  163d					      db	")",0
      1  163d		       29 00		      .byte.b	")",0
      0  163f					      SETTASK		;Set the Task up and start it
      0  163f					      db	61
      1  163f		       3d		      .byte.b	61
      0  1640					      RTN		;Returns the Task number
      0  1640					      db	25
      1  1640		       19		      .byte.b	25
    462  1641							;
    463  1641							; RND() is supposed to have an argument but if none
    464  1641							; was provided, just assume a large value.
    465  1641							;
    466  1641				   F2A
      0  1641					      TST	F2B,"RND("
      0  1641					      db	32
      1  1641		       20		      .byte.b	32
      0  1642					      db	(F2B-*)-1
      1  1642		       17		      .byte.b	(F2B-*)-1
      0  1643					      db	"RND(",0
      1  1643		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1648					      TST	F2A1,")"
      0  1648					      db	32
      1  1648		       20		      .byte.b	32
      0  1649					      db	(F2A1-*)-1
      1  1649		       07		      .byte.b	(F2A1-*)-1
      0  164a					      db	")",0
      1  164a		       29 00		      .byte.b	")",0
      0  164c					      LIT	32766
      0  164c					      db	27
      1  164c		       1b		      .byte.b	27
      0  164d					      dw	32766
      1  164d		       fe 7f		      .word.w	32766
      0  164f					      RANDOM
      0  164f					      db	37
      1  164f		       25		      .byte.b	37
      0  1650					      RTN
      0  1650					      db	25
      1  1650		       19		      .byte.b	25
    472  1651				   F2A1
      0  1651					      CALL	FACT	;GET RANGE
      0  1651					      db	28
      1  1651		       1c		      .byte.b	28
      0  1652					      dw	FACT
      1  1652		       f1 15		      .word.w	FACT
      0  1654					      TST	UNKNOWNVEC,")"
      0  1654					      db	32
      1  1654		       20		      .byte.b	32
      0  1655					      db	(UNKNOWNVEC-*)-1
      1  1655		       98		      .byte.b	(UNKNOWNVEC-*)-1
      0  1656					      db	")",0
      1  1656		       29 00		      .byte.b	")",0
      0  1658					      RANDOM
      0  1658					      db	37
      1  1658		       25		      .byte.b	37
      0  1659					      RTN
      0  1659					      db	25
      1  1659		       19		      .byte.b	25
    477  165a
    478  165a				   F2B
      0  165a					      TST	F2B2,"ABS("
      0  165a					      db	32
      1  165a		       20		      .byte.b	32
      0  165b					      db	(F2B2-*)-1
      1  165b		       0e		      .byte.b	(F2B2-*)-1
      0  165c					      db	"ABS(",0
      1  165c		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1661					      CALL	FACT	;get value
      0  1661					      db	28
      1  1661		       1c		      .byte.b	28
      0  1662					      dw	FACT
      1  1662		       f1 15		      .word.w	FACT
      0  1664					      TST	UNKNOWNVEC,")"
      0  1664					      db	32
      1  1664		       20		      .byte.b	32
      0  1665					      db	(UNKNOWNVEC-*)-1
      1  1665		       88		      .byte.b	(UNKNOWNVEC-*)-1
      0  1666					      db	")",0
      1  1666		       29 00		      .byte.b	")",0
      0  1668					      ABS
      0  1668					      db	38
      1  1668		       26		      .byte.b	38
      0  1669					      RTN
      0  1669					      db	25
      1  1669		       19		      .byte.b	25
    484  166a
    485  166a				   F2B2
      0  166a					      TST	F2Z,"STAT("
      0  166a					      db	32
      1  166a		       20		      .byte.b	32
      0  166b					      db	(F2Z-*)-1
      1  166b		       0f		      .byte.b	(F2Z-*)-1
      0  166c					      db	"STAT(",0
      1  166c		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1672					      Call	EXPR
      0  1672					      db	28
      1  1672		       1c		      .byte.b	28
      0  1673					      dw	EXPR
      1  1673		       26 15		      .word.w	EXPR
      0  1675					      TST	UNKNOWNVEC,")"
      0  1675					      db	32
      1  1675		       20		      .byte.b	32
      0  1676					      db	(UNKNOWNVEC-*)-1
      1  1676		       77		      .byte.b	(UNKNOWNVEC-*)-1
      0  1677					      db	")",0
      1  1677		       29 00		      .byte.b	")",0
      0  1679					      TASKSTAT
      0  1679					      db	66
      1  1679		       42		      .byte.b	66
      0  167a					      RTN
      0  167a					      db	25
      1  167a		       19		      .byte.b	25
    491  167b				   F2Z
      0  167b					      TST	F2ZA,"PID"
      0  167b					      db	32
      1  167b		       20		      .byte.b	32
      0  167c					      db	(F2ZA-*)-1
      1  167c		       06		      .byte.b	(F2ZA-*)-1
      0  167d					      db	"PID",0
      1  167d		       50 49 44 00	      .byte.b	"PID",0
      0  1681					      TASKPID
      0  1681					      db	77
      1  1681		       4d		      .byte.b	77
      0  1682					      RTN
      0  1682					      db	25
      1  1682		       19		      .byte.b	25
    495  1683				   F2ZA
      0  1683					      TST	F2C,"CALL("	;call machine function
      0  1683					      db	32
      1  1683		       20		      .byte.b	32
      0  1684					      db	(F2C-*)-1
      1  1684		       1f		      .byte.b	(F2C-*)-1
      0  1685					      db	"CALL(",0
      1  1685		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  168b					      CALL	EXPR
      0  168b					      db	28
      1  168b		       1c		      .byte.b	28
      0  168c					      dw	EXPR
      1  168c		       26 15		      .word.w	EXPR
      0  168e					      TST	F2B2A,COMMA
      0  168e					      db	32
      1  168e		       20		      .byte.b	32
      0  168f					      db	(F2B2A-*)-1
      1  168f		       0b		      .byte.b	(F2B2A-*)-1
      0  1690					      db	COMMA,0
      1  1690		       2c 00		      .byte.b	COMMA,0
      0  1692					      CALL	EXPR
      0  1692					      db	28
      1  1692		       1c		      .byte.b	28
      0  1693					      dw	EXPR
      1  1693		       26 15		      .word.w	EXPR
      0  1695					      TST	UNKNOWNVEC,")"
      0  1695					      db	32
      1  1695		       20		      .byte.b	32
      0  1696					      db	(UNKNOWNVEC-*)-1
      1  1696		       57		      .byte.b	(UNKNOWNVEC-*)-1
      0  1697					      db	")",0
      1  1697		       29 00		      .byte.b	")",0
      0  1699					      CALLFUNC
      0  1699					      db	53
      1  1699		       35		      .byte.b	53
      0  169a					      RTN
      0  169a					      db	25
      1  169a		       19		      .byte.b	25
      0  169b				   F2B2A      TST	UNKNOWNVEC,")"
      0  169b					      db	32
      1  169b		       20		      .byte.b	32
      0  169c					      db	(UNKNOWNVEC-*)-1
      1  169c		       51		      .byte.b	(UNKNOWNVEC-*)-1
      0  169d					      db	")",0
      1  169d		       29 00		      .byte.b	")",0
      0  169f					      LIT	0
      0  169f					      db	27
      1  169f		       1b		      .byte.b	27
      0  16a0					      dw	0
      1  16a0		       00 00		      .word.w	0
      0  16a2					      CALLFUNC
      0  16a2					      db	53
      1  16a2		       35		      .byte.b	53
      0  16a3					      RTN
      0  16a3					      db	25
      1  16a3		       19		      .byte.b	25
    507  16a4				   F2C
      0  16a4					      TSTV	F0
      0  16a4					      db	33
      1  16a4		       21		      .byte.b	33
      0  16a5					      db	(F0-*)-1
      1  16a5		       0e		      .byte.b	(F0-*)-1
      0  16a6					      TST	F2C1,"["
      0  16a6					      db	32
      1  16a6		       20		      .byte.b	32
      0  16a7					      db	(F2C1-*)-1
      1  16a7		       0a		      .byte.b	(F2C1-*)-1
      0  16a8					      db	"[",0
      1  16a8		       5b 00		      .byte.b	"[",0
      0  16aa					      CALL	EXPR
      0  16aa					      db	28
      1  16aa		       1c		      .byte.b	28
      0  16ab					      dw	EXPR
      1  16ab		       26 15		      .word.w	EXPR
      0  16ad					      TST	UNKNOWNVEC,"]"
      0  16ad					      db	32
      1  16ad		       20		      .byte.b	32
      0  16ae					      db	(UNKNOWNVEC-*)-1
      1  16ae		       3f		      .byte.b	(UNKNOWNVEC-*)-1
      0  16af					      db	"]",0
      1  16af		       5d 00		      .byte.b	"]",0
      0  16b1					      SUBSCRIPT
      0  16b1					      db	64
      1  16b1		       40		      .byte.b	64
    513  16b2				   F2C1
      0  16b2					      IND		;YES, GET THE VALUE.
      0  16b2					      db	20
      1  16b2		       14		      .byte.b	20
      0  16b3					      RTN
      0  16b3					      db	25
      1  16b3		       19		      .byte.b	25
    516  16b4				   F0
      0  16b4					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  16b4					      db	35
      1  16b4		       23		      .byte.b	35
      0  16b5					      db	(F1-*)-1
      1  16b5		       01		      .byte.b	(F1-*)-1
      0  16b6					      RTN
      0  16b6					      db	25
      1  16b6		       19		      .byte.b	25
    519  16b7				   F1
      0  16b7					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  16b7					      db	32
      1  16b7		       20		      .byte.b	32
      0  16b8					      db	(F2A-*)-1
      1  16b8		       88		      .byte.b	(F2A-*)-1
      0  16b9					      db	"(",0
      1  16b9		       28 00		      .byte.b	"(",0
      0  16bb					      CALL	EXPR
      0  16bb					      db	28
      1  16bb		       1c		      .byte.b	28
      0  16bc					      dw	EXPR
      1  16bc		       26 15		      .word.w	EXPR
      0  16be					      TST	F2,")"
      0  16be					      db	32
      1  16be		       20		      .byte.b	32
      0  16bf					      db	(F2-*)-1
      1  16bf		       03		      .byte.b	(F2-*)-1
      0  16c0					      db	")",0
      1  16c0		       29 00		      .byte.b	")",0
      0  16c2					      RTN
      0  16c2					      db	25
      1  16c2		       19		      .byte.b	25
    524  16c3
    525  16c3				   F2
      0  16c3					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  16c3					      db	13
      1  16c3		       0d		      .byte.b	13
      0  16c4					      dw	ERR_SYNTAX
      1  16c4		       05 00		      .word.w	ERR_SYNTAX
    527  16c6
    528  16c6		       16 c6	   ILEND      equ	*
------- FILE mytb.asm
   2015  16c6		       16 c6	   PROGEND    equ	*
   2016  16c6
   2017  16c6
   2018  16c6							;=====================================================
   2019  16c6							; Define start of non page zero data
   2020 U16d6					      seg.u	TBData
   2021 U16d6
   2022 U16d6							;=====================================================
   2023 U16d6							; These are storage items not in page zero.
   2024 U16d6							;
   2025 U16d6							; IRQ BASIC Code Service RTN Support
      0 U16d6				   SaveIrqReg db	0	; Store current setting
      1 U16d6		       00		      .byte.b	0
      0 U16d7				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U16d7		       00		      .byte.b	0
      0 U16d8				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U16d8		       00		      .byte.b	0
      0 U16d9				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U16d9		       00 00		      .byte.b	0,0
   2030 U16db
   2031 U16db							;
   2032 U16db							;==================================================================================================
   2033 U16db							; Task Management information
   2034 U16db							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2035 U16db							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2036 U16db							; Task switchs happen at the beginning of the next Basic command line
   2037 U16db							; It will not happen during an input or output operations
   2038 U16db							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2039 U16db							; Task Zero is always the root task, main line program
   2040 U16db							;
   2041 U16db							; Layout is repeated for each configured task
   2042 U16db							; Task Table Byte   use
   2043 U16db							;	      0      Bit 0	     Active task
   2044 U16db							;		     Bit 1	     Task IO pending
   2045 U16db							;	      1..CONTEXTLEN	     All saved data for the task
   2046 U16db		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2047 U16dc		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2048 U16dc		       17 b4	   TASKTABLEEND equ	*	; End of task table
   2049 U16dc		       00 d8	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2050 U17b4
   2051 U17b4							;Task Cycle Counter and reset count
   2052 U17b4		       00	   taskCurrentCycles ds	1
   2053 U17b5		       00	   taskResetValue ds	1
   2054 U17b6		       00	   taskCounter ds	1	; Count of active tasks
   2055 U17b7
   2056 U17b7							;
   2057 U17b7							; Math stack and IL call and Gosub/For-next return stack definitions
   2058 U17b7							;
   2059 U17b7		       17 b7	   STACKSTART equ	*
   2060 U17b7		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2061 U191f		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2062 U1a87		       00 00 00 00*gosubStack ds	GOSUBSTACKSIZE*4*TASKCOUNT	;stack size for gosub stacks
   2063 U1cc7		       00 00 00 00*variableStack ds	26*2*TASKCOUNT	;Stack of variables, 26 A-Z
   2064 U1cc7		       1e 9b	   STACKEND   equ	*
   2065 U1cc7		       06 e4	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2066 U1e9b							;
   2067 U1e9b							;
   2068 U1e9b		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2069 U1f1f		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2070 U1f20		       00	   printtx    ds	1	;temp X for print funcs
   2071 U1f21		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2072 U1f22		       00	   promptChar ds	1	;the character to use for a prompt
   2073 U1f23		       00	   diddigit   ds	1	;for leading zero suppression
   2074 U1f24		       00	   putsy      ds	1
   2075 U1f25		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2076 U1f27		       00	   sign       ds	1	;0 = positive, else negative
   2077 U1f28		       00 00	   rtemp1     ds	2	;Temp for x and y
   2078 U1f2a		       00 00	   random     ds	2
   2079 U1f2c		       00 00	   BOutVec    ds	2
   2080 U1f2e		       00	   tempy      ds	1	;temp y storage
   2081 U1f2f				  -	      if	XKIM
   2082 U1f2f				  -buffer     ds	BUFFER_SIZE
   2083 U1f2f					      endif
   2084 U1f2f							;
   2085 U1f2f							; PROGRAMEND is the end of the user's BASIC program.
   2086 U1f2f							; More precisely, it is one byte past the end.  Or,
   2087 U1f2f							; it's where the next line added to the end will be
   2088 U1f2f							; placed.
   2089 U1f2f							;
   2090 U1f2f		       00 00	   PROGRAMEND ds	2
   2091 U1f31		       00 00	   HighMem    ds	2	;highest location
   2092 U1f33		       00 00	   UsedMem    ds	2	;size of user program
   2093 U1f35		       00 00	   FreeMem    ds	2	;amount of free memory
   2094 U1f37							;
   2095 U1f37							;=====================================================
   2096 U1f37							; This is the start of the user's BASIC program space.
   2097 U1f37							;
   2098 U1f37							; PERSONAL GOAL: This should be no larger than $0DFF.
   2099 U1f37							;		  0200-05FF = 1K
   2100 U1f37							;		  0200-09FF = 2K
   2101 U1f37							;		  0200-0DFF = 3K
   2102 U1f37							;		  0200-11FF = 4K
   2103 U1f37							;		  0200-13FF = 4.5K
   2104 U1f37							;
   2105 U1f37				  -	      if	FIXED
   2106 U1f37				  -	      org	$2000
   2107 U1f37					      endif
   2108 U1f37		       1f 37	   ProgramStart equ	*
   2109 U1f37							;/*
   2110 U1f37							;	if	CTMON65 || XKIM
   2111 U1f37							;		SEG Code
   2112 U1f37							;		org	AutoRun
   2113 U1f37							;		dw	TBasicCold
   2114 U1f37							;	endif
   2115 U1f37							;*/
   2116 U1f37					      end
