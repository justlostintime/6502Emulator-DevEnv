------- FILE mytb.asm LEVEL 1 PASS 4
      1 U1255				   input      processor	6502
      2 U1255 ????						;=====================================================
      3 U1255 ????						; Bob's Tiny BASIC
      4 U1255 ????						;
      5 U1255 ????						; While working on the Corsham Technologies KIM Clone
      6 U1255 ????						; project, I wanted to include a TINY BASIC since that
      7 U1255 ????						; was a highly desirable feature of early computers.
      8 U1255 ????						;
      9 U1255 ????						; Rather than negotiating copyright issues for
     10 U1255 ????						; existing BASICs, I decided to just write one from
     11 U1255 ????						; scratch.
     12 U1255 ????						;
     13 U1255 ????						; 10/07/2017
     14 U1255 ????						;
     15 U1255 ????						; This implements a stripped down Tiny BASIC
     16 U1255 ????						; interpreter using the Interpretive Language (IL)
     17 U1255 ????						; method as described in the first few issues of
     18 U1255 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1255 ????						; to write various languages simply by changing the
     20 U1255 ????						; IL code rather than the interpreter itself.
     21 U1255 ????						;
     22 U1255 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1255 ????						;		* Fixed major bug in findLine that
     24 U1255 ????						;		  caused corrupted lines, crashes, etc.
     25 U1255 ????						;		* If no parameter given to RND, assume
     26 U1255 ????						;		  32766.
     27 U1255 ????						;		* No more error 5 when a program
     28 U1255 ????						;		  reaches the end without an END.
     29 U1255 ????						;
     30 U1255 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U1255 ????						;		 * Add some usefull system level functions
     32 U1255 ????						;		 * allow a larger number of tiny basic formats
     33 U1255 ????						;		 * Add byte at start of line holding length
     34 U1255 ????						;		   for faster execution of goto and gosub
     35 U1255 ????						;		 * Re-added gosub
     36 U1255 ????						;		 * allow ; or , at end if print stmt
     37 U1255 ????						;		   without CRLF being added.
     38 U1255 ????						;		 * Added extended function erase to
     39 U1255 ????						;		   use the extended ctmon65 rm file
     40 U1255 ????						;		 * Fix quoted text to not have to backtrack
     41 U1255 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     42 U1255 ????						;
     43 U1255 ????						; www.corshamtech.com
     44 U1255 ????						; bob@corshamtech.com
     45 U1255 ????						; JustLostInTime@gmail.com
     46 U1255 ????						;
     47 U1255 ????						;=====================================================
     48 U1255 ????						;
     49 U1255 ????						; Create TRUE and FALSE values for conditionals.
     50 U1255 ????						;
     51 U1255 ????
     52 U1255 ????	       00 00	   FALSE      equ	0
     53 U1255 ????	       ff ff ff ff TRUE       equ	~FALSE
     54 U1255 ????						;
     55 U1255 ????						;---------------------------------------------------------
     56 U1255 ????						; One of these must be set to indicate which environment
     57 U1255 ????						; Tiny BASIC will be running in.  Here are the current
     58 U1255 ????						; environments:
     59 U1255 ????						;
     60 U1255 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     61 U1255 ????						; more K of RAM.
     62 U1255 ????						;
     63 U1255 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     64 U1255 ????						; which enhances, without replacing, the standard KIM
     65 U1255 ????						; monitor.  It gives access to routines to save/load files
     66 U1255 ????						; to a micro SD card.
     67 U1255 ????						;
     68 U1255 ????						; CTMON65 is a from-scratch monitor written for the
     69 U1255 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     70 U1255 ????						; easily be ported to other systems.  It has support for
     71 U1255 ????						; using a micro SD card for file storage/retrieval.
     72 U1255 ????						;
     73 U1255 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     74 U1255 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     75 U1255 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     76 U1255 ????						;
     77 U1255 ????						;   Need to define some macros for the dasm assembler
     78 U1255 ????						;
     79 U1255 ????				      MACRO	dw
     80 U1255 ????				      .word	{0}
     81 U1255 ????				      ENDM
     82 U1255 ????
     83 U1255 ????				      MACRO	db
     84 U1255 ????				      .byte	{0}
     85 U1255 ????				      ENDM
     86 U1255 ????
     87 U1255 ????						;
     88 U1255 ????						; If set, include disk functions.
     89 U1255 ????						;
     90 U1255 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     91 U1255 ????						;
     92 U1255 ????						; If ILTRACE is set then dump out the address of every
     93 U1255 ????						; IL opcode before executing it.
     94 U1255 ????						;
     95 U1255 ????	       00 00	   ILTRACE    equ	FALSE
     96 U1255 ????						;
     97 U1255 ????						; If FIXED is set, put the IL code and the user
     98 U1255 ????						; program space at fixed locations in memory.	This is
     99 U1255 ????						; meant only for debugging.
    100 U1255 ????						;
    101 U1255 ????	       00 00	   FIXED      equ	FALSE
    102 U1255 ????						;
    103 U1255 ????						; Sets the arithmetic stack depth.  This is *TINY*
    104 U1255 ????						; BASIC, so keep this small!
    105 U1255 ????						;
    106 U1255 ????	       00 08	   STACKSIZE  equ	8	;number of entries
    107 U1255 ????	       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting max is 128
    108 U1255 ????						;
    109 U1255 ????						; Common ASCII constants
    110 U1255 ????						;
    111 U1255 ????	       00 07	   BEL	      equ	$07
    112 U1255 ????	       00 08	   BS	      equ	$08
    113 U1255 ????	       00 09	   TAB	      equ	$09
    114 U1255 ????	       00 0a	   LF	      equ	$0A
    115 U1255 ????	       00 0d	   CR	      equ	$0D
    116 U1255 ????	       00 22	   QUOTE      equ	$22
    117 U1255 ????	       00 20	   SPACE      equ	$20
    118 U1255 ????	       00 2c	   COMMA      equ	',
    119 U1255 ????	       00 3b	   SEMICOLON  equ	';
    120 U1255 ????						;
    121 U1255 ????						; These are error codes
    122 U1255 ????						;
    123 U1255 ????	       00 00	   ERR_NONE   equ	0
    124 U1255 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    125 U1255 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    126 U1255 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    127 U1255 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    128 U1255 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    129 U1255 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    130 U1255 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    131 U1255 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    132 U1255 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    133 U1255 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    134 U1255 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    135 U1255 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    136 U1255 ????						;
    137 U1255 ????						;=====================================================
    138 U1255 ????						; Zero page storage.
    139 U1255 ????						;
    140 U1255 ????				      SEG.U	Data
    141 U0040					      org	$0040
    142 U0040
    143 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    144 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    145 U0041		       00 75	   variablesEnd equ	*
    146 U0075		       00 00	   ILPC       ds	2	;IL program counter
    147 U0077		       00 00	   dpl	      ds	2
    148 U0079		       00 00	   tempIL     ds	2
    149 U007b		       00	   tempIlY    ds	1
    150 U007c		       00	   offset     ds	1
    151 U007d		       00	   lineLength ds	1
    152 U007e							;
    153 U007e							; CURPTR is a pointer to curent BASIC line being
    154 U007e							; executed.  Always points to start of line, CUROFF
    155 U007e							; is the offset to the current character.
    156 U007e							;
    157 U007e		       00 00	   CURPTR     ds	2
    158 U0080		       00	   CUROFF     ds	1
    159 U0081							;
    160 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    161 U0083							;
    162 U0083
    163 U0083							;
    164 U0083							; R0 and R1 are used for arithmetic operations and
    165 U0083							; general use.
    166 U0083							;
    167 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    168 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    169 U0087							;
    170 U0087							; This is zero if in immediate mode, or non-zero
    171 U0087							; if currently running a program.  Any input from
    172 U0087							; the main loop clears this, and the XFER IL
    173 U0087							; statement will set it.
    174 U0087							;
    175 U0087		       00	   RunMode    ds	1
    176 U0088							;
    177 U0088							; Used for line insertion/removal.
    178 U0088							;
    179 U0088		       00 00	   FROM       ds	2
    180 U008a
    181 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    182 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    183 U008a							;
    184 U008a		       00 88	   PrtFrom    EQU	FROM
    185 U008a							;
    186 U008a							;=====================================================
    187 U008a							;
    188  1197 ????				      SEG	Code
    189  0200					      org	$0200
    190  0200							;
    191  0200							; Cold start is at $0200.  Warm start is at $0203.
    192  0200							;
    193  0200		       4c 15 02    TBasicCold jmp	cold2	;jump around vectors
    194  0203		       4c bf 02    warm       jmp	warm2
    195  0206							;
    196  0206							; These are the user-supplied vectors to I/O routines.
    197  0206							; If you want, you can just patch these in the binary
    198  0206							; file, but it would be better to change the source
    199  0206							; code.
    200  0206							;
    201  0206				  -	      if	KIM
    202  0206				  -OUTCH      jmp	$1ea0	;output char in A
    203  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    204  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    205  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    206  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    207  0206					      endif
    208  0206				  -	      if	XKIM
    209  0206				  -	      include	"xkim.inc"
    210  0206				  -	      SEG	Code
    211  0206				  -OUTCH      jmp	$1ea0
    212  0206				  -GETCH      jmp	xkGETCH
    213  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    214  0206				  -OUTHEX     jmp	xkPRTBYT
    215  0206				  -MONITOR    jmp	extKIM
    216  0206				  -puts       equ	putsil
    217  0206				  -BUFFER_SIZE equ	132
    218  0206					      endif
    219  0206
    220  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U00f6 ????				      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 U008a					      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    222  0206					      SEG	Code
    223  0206
    224  0206		       4c 0c f0    OUTCH      jmp	cout
    225  0209		       4c 09 f0    GETCH      jmp	cin
    226  020c		       4c 18 f0    CRLF       jmp	crlf
    227  020f		       4c 1b f0    OUTHEX     jmp	HexA
    228  0212		       4c 03 f0    MONITOR    jmp	WARM
    229  0212		       f0 12	   puts       equ	putsil
    230  0215					      endif
    231  0215							;
    232  0215		       20 12 f0    cold2      jsr	puts
      0  0218					      db	CR,LF
      1  0218		       0d 0a		      .byte.b	CR,LF
      0  021a					      db	"Bob's Tiny BASIC v1.0.2 IRQs"
      1  021a		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs"
      0  0236					      db	CR,LF
      1  0236		       0d 0a		      .byte.b	CR,LF
      0  0238					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  0238		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0266					      db	CR,LF,0
      1  0266		       0d 0a 00 	      .byte.b	CR,LF,0
    238  0269							;
    239  0269		       20 49 0d 	      jsr	GetSizes	;setup the free space available
    240  026c		       ad 4f 12 	      lda	HighMem
    241  026f		       e9 28		      sbc	#GOSUBSTACKSIZE*2
    242  0271		       85 81		      sta	GOSUBSTACK
    243  0273		       ad 50 12 	      lda	HighMem+1
    244  0276		       e9 00		      sbc	#0
    245  0278		       85 82		      sta	GOSUBSTACK+1
    246  027a		       a9 e7		      lda	#IL&$ff
    247  027c		       85 75		      sta	ILPC
    248  027e		       a9 0e		      lda	#IL>>8
    249  0280		       85 76		      sta	ILPC+1
    250  0282							;
    251  0282		       a9 55		      lda	#ProgramStart&$ff	;user prog
    252  0284		       8d 4d 12 	      sta	PROGRAMEND
    253  0287		       a9 12		      lda	#ProgramStart>>8
    254  0289		       8d 4e 12 	      sta	PROGRAMEND+1
    255  028c							;
    256  028c							; Initialize the pseudo-random number sequence...
    257  028c							;
    258  028c		       a9 5a		      lda	#$5a
    259  028e		       8d 47 12 	      sta	rtemp1
    260  0291		       a9 9d		      lda	#%10011101
    261  0293		       8d 48 12 	      sta	random
    262  0296		       a9 5b		      lda	#%01011011
    263  0298		       8d 49 12 	      sta	random+1
    264  029b							;
    265  029b							;   Insert a Basic irq handler for the basic Language
    266  029b		       a9 ad		      lda	#ServiceIrq&$ff
    267  029d		       8d 00 df 	      sta	IRQvec
    268  02a0		       a9 02		      lda	#ServiceIrq>>8
    269  02a2		       8d 01 df 	      sta	IRQvec+1
    270  02a5		       4c cc 02 	      jmp	coldtwo
    271  02a8
    272  02a8							;
    273  02a8							; This is the Basic IRQ handler
      0  02a8				   SaveIrqReg db	0
      1  02a8		       00		      .byte.b	0
      0  02a9				   IRQStatus  db	0
      1  02a9		       00		      .byte.b	0
      0  02aa				   IRQPending db	0
      1  02aa		       00		      .byte.b	0
      0  02ab				   IRQEntry   db	0,0
      1  02ab		       00 00		      .byte.b	0,0
    278  02ad
    279  02ad		       48	   ServiceIrq pha
    280  02ae		       ad a9 02 	      lda	IRQStatus
    281  02b1		       f0 0a		      BEQ	RetIrq
    282  02b3		       ad aa 02 	      lda	IRQPending
    283  02b6		       d0 05		      BNE	RetIrq
    284  02b8		       a9 01		      lda	#1
    285  02ba		       8d aa 02 	      sta	IRQPending
    286  02bd		       68	   RetIrq     pla
    287  02be		       40		      rti
    288  02bf							;
    289  02bf							;
    290  02bf							; This is the warm start entry point
    291  02bf							;
    292  02bf		       20 0c 02    warm2      jsr	CRLF
    293  02c2		       ad 42 12 	      lda	errGoto
    294  02c5		       85 75		      sta	ILPC
    295  02c7		       ad 43 12 	      lda	errGoto+1
    296  02ca		       85 76		      sta	ILPC+1
    297  02cc							;
    298  02cc							; And continue with both starts here
    299  02cc							;
    300  02cc		       20 7c 0d    coldtwo    jsr	SetOutConsole
    301  02cf							;
    302  02cf							; The ILTrace flag is now run-time settable.
    303  02cf							;
    304  02cf		       a9 00		      lda	#ILTRACE&$ff
    305  02d1		       85 40		      sta	ILTrace
    306  02d3							;
    307  02d3		       a9 00		      lda	#0
    308  02d5		       85 87		      sta	RunMode
    309  02d7		       8d ba 11 	      sta	LINBUF
    310  02da							; Clear everything from the stacks
    311  02da		       8d a7 11 	      sta	mathStackPtr
    312  02dd		       8d b8 11 	      sta	retStackPtr
    313  02e0		       8d b9 11 	      sta	GoSubStackPtr
    314  02e3							;
    315  02e3		       a9 ba		      lda	#LINBUF&$ff
    316  02e5		       85 7e		      sta	CURPTR
    317  02e7		       a9 11		      lda	#LINBUF>>8
    318  02e9		       85 7f		      sta	CURPTR+1	;fall through...
    319  02eb							;
    320  02eb							;=====================================================
    321  02eb							; This is the top of the IL interpreter.  This fetches
    322  02eb							; and executes the instruction currently pointed to
    323  02eb							; by ILPC and adjusts ILPC to point to the next
    324  02eb							; instruction to execute.
    325  02eb							;
    326  02eb		       a5 40	   NextIL     lda	ILTrace
    327  02ed		       f0 03		      beq	NextIL2
    328  02ef		       20 04 0d 	      jsr	dbgLine
    329  02f2		       a4 80	   NextIL2    ldy	CUROFF
    330  02f4		       20 fb 0c 	      jsr	SkipSpaces
    331  02f7		       84 80		      sty	CUROFF
    332  02f9							;
    333  02f9		       20 e9 09    NextILStr  jsr	getILByte
    334  02fc							;
    335  02fc							; When the handler is called, these are the conditions
    336  02fc							; of several important items:
    337  02fc							;
    338  02fc							;    (ILPC) will point to the byte AFTER the IL
    339  02fc							;    opcode being executed.
    340  02fc							;
    341  02fc							;    (CURPTR),CUROFF will point to the start of the
    342  02fc							;    next word in the input buffer.  Ie, the next word
    343  02fc							;    in the user program.
    344  02fc							;
    345  02fc		       0a		      asl
    346  02fd		       c9 78		      cmp	#ILTBLend-ILTBL+2
    347  02ff		       90 33		      bcc	ILgood
    348  0301							;
    349  0301							; This handles an illegal IL opcode.  This is serious
    350  0301							; and there's no way to recover.
    351  0301							;
    352  0301		       20 12 f0    ILbad      jsr	puts
      0  0304					      db	CR,LF
      1  0304		       0d 0a		      .byte.b	CR,LF
      0  0306					      db	"Illegal IL "
      1  0306		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  0311					      db	0
      1  0311		       00		      .byte.b	0
    356  0312							;
    357  0312							; Well this is awkward, we need to back up the IL
    358  0312							; by one since it no longer points to the current
    359  0312							; opcode.
    360  0312							;
    361  0312		       20 f6 09 	      jsr	decIL
    362  0315							;
    363  0315		       a0 00		      ldy	#0
    364  0317		       b1 75		      lda	(ILPC),y
    365  0319		       20 0f 02 	      jsr	OUTHEX
    366  031c		       20 12 f0 	      jsr	puts
      0  031f					      db	" at ",0
      1  031f		       20 61 74 20*	      .byte.b	" at ",0
    368  0324		       a5 76		      lda	ILPC+1
    369  0326		       20 0f 02 	      jsr	OUTHEX
    370  0329		       a5 75		      lda	ILPC
    371  032b		       20 0f 02 	      jsr	OUTHEX
    372  032e		       20 0c 02 	      jsr	CRLF
    373  0331		       4c 12 02 	      jmp	MONITOR
    374  0334							;
    375  0334							; Just jump to the address (ILPC),y.  Have to do
    376  0334							; some goofy stuff.
    377  0334							;
    378  0334		       a8	   ILgood     tay		;move index into Y
    379  0335		       b9 42 03 	      lda	ILTBL,y
    380  0338		       85 77		      sta	dpl
    381  033a		       b9 43 03 	      lda	ILTBL+1,y
    382  033d		       85 78		      sta	dpl+1
    383  033f		       6c 77 00 	      jmp	(dpl)	;go to handler
    384  0342							;
    385  0342							;=====================================================
    386  0342							; This is the IL jump table.  The IL opcode is
    387  0342							; mulitplied by two, then looked-up in this table.
    388  0342							; There is absolutely nothing special about the order
    389  0342							; of entries here... they all decode at exactly the
    390  0342							; same speed.	However the entry number must match the
    391  0342							; values in IL.inc.
    392  0342							;
      0  0342				   ILTBL      dw	iXINIT	;0
      1  0342		       ce 03		      .word.w	iXINIT
      0  0344					      dw	iDONE	;1
      1  0344		       d6 03		      .word.w	iDONE
      0  0346					      dw	iPRS	;2
      1  0346		       e9 03		      .word.w	iPRS
      0  0348					      dw	iPRN	;3
      1  0348		       f3 03		      .word.w	iPRN
      0  034a					      dw	iSPC	;4
      1  034a		       fc 03		      .word.w	iSPC
      0  034c					      dw	iNLINE	;5
      1  034c		       45 07		      .word.w	iNLINE
      0  034e					      dw	iNXT	;6
      1  034e		       04 04		      .word.w	iNXT
      0  0350					      dw	iXFER	;7
      1  0350		       1c 04		      .word.w	iXFER
      0  0352					      dw	iSAV	;8
      1  0352		       49 04		      .word.w	iSAV
      0  0354					      dw	iRSTR	;9
      1  0354		       6a 04		      .word.w	iRSTR
      0  0356					      dw	iCMPR	;10
      1  0356		       76 04		      .word.w	iCMPR
      0  0358					      dw	iINNUM	;11
      1  0358		       b8 04		      .word.w	iINNUM
      0  035a					      dw	iFIN	;12
      1  035a		       d8 04		      .word.w	iFIN
      0  035c					      dw	iERR	;13
      1  035c		       e9 04		      .word.w	iERR
      0  035e					      dw	iADD	;14
      1  035e		       35 05		      .word.w	iADD
      0  0360					      dw	iSUB	;15
      1  0360		       4b 05		      .word.w	iSUB
      0  0362					      dw	iNEG	;16
      1  0362		       61 05		      .word.w	iNEG
      0  0364					      dw	iMUL	;17
      1  0364		       79 05		      .word.w	iMUL
      0  0366					      dw	iDIV	;18
      1  0366		       b3 05		      .word.w	iDIV
      0  0368					      dw	iSTORE	;19
      1  0368		       fc 05		      .word.w	iSTORE
      0  036a					      dw	iIND	;20
      1  036a		       0f 06		      .word.w	iIND
      0  036c					      dw	iLST	;21
      1  036c		       1f 06		      .word.w	iLST
      0  036e					      dw	iINIT	;22
      1  036e		       b8 03		      .word.w	iINIT
      0  0370					      dw	iGETLINE	;23
      1  0370		       7e 06		      .word.w	iGETLINE
      0  0372					      dw	iINSRT	;24
      1  0372		       8a 06		      .word.w	iINSRT
      0  0374					      dw	iRTN	;25
      1  0374		       3f 07		      .word.w	iRTN
      0  0376					      dw	MONITOR	;26
      1  0376		       12 02		      .word.w	MONITOR
      0  0378					      dw	iLIT	;27
      1  0378		       58 07		      .word.w	iLIT
      0  037a					      dw	iCALL	;28
      1  037a		       4b 07		      .word.w	iCALL
      0  037c					      dw	iJMP	;29
      1  037c		       4e 07		      .word.w	iJMP
      0  037e					      dw	iVINIT	;30
      1  037e		       65 07		      .word.w	iVINIT
      0  0380					      dw	iERRGOTO	;31
      1  0380		       73 07		      .word.w	iERRGOTO
      0  0382					      dw	iTST	;32
      1  0382		       7f 07		      .word.w	iTST
      0  0384					      dw	iTSTV	;33
      1  0384		       fe 07		      .word.w	iTSTV
      0  0386					      dw	iTSTL	;34
      1  0386		       28 08		      .word.w	iTSTL
      0  0388					      dw	iTSTN	;35
      1  0388		       42 08		      .word.w	iTSTN
      0  038a					      dw	iFREE	;36
      1  038a		       b4 08		      .word.w	iFREE
      0  038c					      dw	iRANDOM	;37
      1  038c		       bd 08		      .word.w	iRANDOM
      0  038e					      dw	iABS	;38
      1  038e		       93 09		      .word.w	iABS
    432  0390							;
    433  0390							; Disk functions.  There must be pointers
    434  0390							; to functions even if no disk is supported.
    435  0390							; Makes things easier in IL.inc.
    436  0390							;
    437  0390					      if	DISK_ACCESS
      0  0390					      dw	iOPENREAD	;39
      1  0390		       c2 0d		      .word.w	iOPENREAD
      0  0392					      dw	iOPENWRITE	;40
      1  0392		       16 0e		      .word.w	iOPENWRITE
      0  0394					      dw	iDCLOSE	;41
      1  0394		       9a 0e		      .word.w	iDCLOSE
      0  0396					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0396		       35 0e		      .word.w	iDGETLINE
      0  0398					      dw	iDLIST	;43 Did you remeber your towel?
      1  0398		       94 0e		      .word.w	iDLIST
      0  039a					      dw	iDDIR	;44
      1  039a		       6f 0e		      .word.w	iDDIR
      0  039c					      dw	iRMFILE	;45
      1  039c		       f0 0d		      .word.w	iRMFILE
    445  039e				  -	      else
    446  039e				  -	      dw	NextIL	;39
    447  039e				  -	      dw	NextIL	;40
    448  039e				  -	      dw	NextIL	;41
    449  039e				  -	      dw	NextIL	;42
    450  039e				  -	      dw	NextIL	;43
    451  039e				  -	      dw	NextIL	;44
    452  039e				  -	      dw	NextIL	;45
    453  039e					      endif
    454  039e							;
      0  039e					      dw	iCLEARSCREEN	;46
      1  039e		       b7 0d		      .word.w	iCLEARSCREEN
      0  03a0					      dw	iPOKEMEMORY	;47
      1  03a0		       35 09		      .word.w	iPOKEMEMORY
      0  03a2					      dw	iPEEKMEMORY	;48
      1  03a2		       4a 09		      .word.w	iPEEKMEMORY
      0  03a4					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03a4		       c4 07		      .word.w	iTSTLET
      0  03a6					      dw	iTSTDONE	;50	     Test if we are at the end of a line
      1  03a6		       e1 07		      .word.w	iTSTDONE
      0  03a8					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03a8		       74 09		      .word.w	iGETCHAR
      0  03aa					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03aa		       88 09		      .word.w	iPUTCHAR
      0  03ac					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03ac		       5f 09		      .word.w	iCallFunc
      0  03ae					      dw	iCallFunc2	;54	   call system rtn with value in a
      1  03ae		       5a 09		      .word.w	iCallFunc2
      0  03b0					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03b0		       a8 07		      .word.w	iTSTStr
      0  03b2					      dw	iSetIrq	;56	   sets the irq handler
      1  03b2		       b0 09		      .word.w	iSetIrq
      0  03b4					      dw	iTstIrq	;57	   test if irq is pending
      1  03b4		       85 08		      .word.w	iTstIrq
      0  03b6					      dw	iRET	;58	   return from interupt
      1  03b6		       58 04		      .word.w	iRET
    468  03b8
    469  03b8		       03 b8	   ILTBLend   equ	*
    470  03b8							;
    471  03b8							;=====================================================
    472  03b8							;=====================================================
    473  03b8							;=====================================================
    474  03b8							; This marks the start of the handlers for IL opcodes.
    475  03b8							;=====================================================
    476  03b8							;=====================================================
    477  03b8							;=====================================================
    478  03b8							;
    479  03b8							;
    480  03b8		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    481  03ba		       8d b8 11 	      sta	retStackPtr
    482  03bd		       8d b9 11 	      sta	GoSubStackPtr
    483  03c0							;
    484  03c0		       a9 55		      lda	#ProgramStart&$ff	;user prog
    485  03c2		       85 7e		      sta	CURPTR
    486  03c4		       8d 4d 12 	      sta	PROGRAMEND
    487  03c7		       a9 12		      lda	#ProgramStart>>8
    488  03c9		       85 7f		      sta	CURPTR+1
    489  03cb		       8d 4e 12 	      sta	PROGRAMEND+1
    490  03ce							;
    491  03ce							; fall into XINIT...
    492  03ce							;
    493  03ce							;=====================================================
    494  03ce							; This initializes for the start of the next line of
    495  03ce							; BASIC text.
    496  03ce							;
    497  03ce		       a9 00	   iXINIT     lda	#0
    498  03d0		       8d a7 11 	      sta	mathStackPtr	;clear math stack
    499  03d3		       4c eb 02    goodExit   jmp	NextIL
    500  03d6							;
    501  03d6							;=====================================================
    502  03d6							; Verify there is nothing else on this input line.
    503  03d6							; If there is, generate an error.
    504  03d6							;
    505  03d6		       a4 80	   iDONE      ldy	CUROFF
    506  03d8		       20 fb 0c 	      jsr	SkipSpaces
    507  03db		       b1 7e		      lda	(CURPTR),y
    508  03dd		       f0 07		      beq	doneadv
    509  03df		       a2 04		      ldx	#ERR_EXTRA_STUFF
    510  03e1		       a9 00		      lda	#0
    511  03e3		       4c ec 04 	      jmp	iErr2
    512  03e6							;
    513  03e6							; Advance to the next line
    514  03e6							;
    515  03e6				   doneadv
    516  03e6							;		jsr	FindNext2
    517  03e6		       4c eb 02 	      jmp	NextIL
    518  03e9							;
    519  03e9							;=====================================================
    520  03e9							; Print the string until a closing quote
    521  03e9							;
    522  03e9		       a4 80	   iPRS       ldy	CUROFF
    523  03eb							;
    524  03eb							; Odd logic here.  The main loop skipped any leading
    525  03eb							; whitespace inside the quoted text, so move back to
    526  03eb							; the quote, then move forward again.
    527  03eb							;
    528  03eb		       20 8a 0d 	      jsr	PrtQuoted
    529  03ee		       84 80		      sty	CUROFF
    530  03f0		       4c eb 02 	      jmp	NextIL
    531  03f3							;
    532  03f3							;=====================================================
    533  03f3							; Pop the top off the stack and print it as a signed
    534  03f3							; decimal number.
    535  03f3							;
    536  03f3		       20 37 0c    iPRN       jsr	popR0
    537  03f6		       20 8e 0a 	      jsr	PrintDecimal
    538  03f9		       4c eb 02 	      jmp	NextIL
    539  03fc							;
    540  03fc							;=====================================================
    541  03fc							; Space to next zone.	Currently the code does not
    542  03fc							; keep track of which column the output is on, so
    543  03fc							; just print a tab.
    544  03fc							;
    545  03fc		       a9 09	   iSPC       lda	#TAB
    546  03fe		       20 06 02 	      jsr	OUTCH
    547  0401		       4c eb 02 	      jmp	NextIL
    548  0404							;
    549  0404							;=====================================================
    550  0404							; If in immediate mode, jump to the address following
    551  0404							; the NXT instruction.  Else move to the next line of
    552  0404							; user code and continue.
    553  0404							;
    554  0404		       a5 87	   iNXT       lda	RunMode
    555  0406		       d0 03		      bne	iNxtRun	;in run mode
    556  0408							;
    557  0408							; Get address and jump to it.
    558  0408							;
    559  0408		       4c 4e 07 	      jmp	iJMP
    560  040b							;
    561  040b		       20 6f 0a    iNxtRun    jsr	FindNextLine
    562  040e		       20 81 0a 	      jsr	AtEnd
    563  0411		       d0 03		      bne	iNxtRun2	;not at end
    564  0413							;
    565  0413							; At the end of the program.  Pretend an END statement
    566  0413							; was found.
    567  0413							;
    568  0413		       4c d8 04    iFINv      jmp	iFIN
    569  0416							;
    570  0416		       20 e5 09    iNxtRun2   jsr	getILWord	;ignore next word
    571  0419		       4c eb 02 	      jmp	NextIL
    572  041c							;
    573  041c							;=====================================================
    574  041c							; XFER takes the number on top of the stack and looks
    575  041c							; for that line in the program, or the next line
    576  041c							; higher.  Ie, if it's 1 but there is no line 1, then
    577  041c							; find the next one after that.
    578  041c							;
    579  041c		       20 37 0c    iXFER      jsr	popR0
    580  041f		       20 2c 0a 	      jsr	findLine
    581  0422		       20 81 0a    iXFER2     jsr	AtEnd	;at end of user program?
    582  0425		       f0 ec		      beq	iFINv
    583  0427		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    584  0429		       84 80		      sty	CUROFF
    585  042b		       a9 ff		      lda	#$ff
    586  042d		       85 87		      sta	RunMode
    587  042f							;
    588  042f							; Transfer IL to STMT.  I don't like having this
    589  042f							; hard-coded; fix it.
    590  042f							;
    591  042f		       a9 f5		      lda	#STMT&$ff
    592  0431		       85 75		      sta	ILPC
    593  0433		       a9 0e		      lda	#STMT>>8
    594  0435		       85 76		      sta	ILPC+1
    595  0437		       4c eb 02 	      jmp	NextIL
    596  043a							;
    597  043a							; Run
    598  043a							;
    599  043a				   iXferok
    600  043a		       a9 ff		      lda	#$ff
    601  043c		       85 87		      sta	RunMode	;we're running
    602  043e							;
    603  043e							; Need a more elegant way to do this
    604  043e							;
    605  043e		       a9 f5		      lda	#STMT&$ff
    606  0440		       85 75		      sta	ILPC
    607  0442		       a9 0e		      lda	#STMT>>8
    608  0444		       85 76		      sta	ILPC+1
    609  0446		       4c eb 02 	      jmp	NextIL
    610  0449							;
    611  0449							;=====================================================
    612  0449							; Save the pointer to the next line to the call stack.
    613  0449							;
    614  0449		       20 05 0c    iSAV       jsr	pushLN
    615  044c		       b0 03		      bcs	iSAVErr
    616  044e		       4c eb 02 	      jmp	NextIL
    617  0451		       a2 0c	   iSAVErr    ldx	#12
    618  0453		       a9 00	   iSAVErr2   lda	#0
    619  0455		       4c ec 04 	      jmp	iErr2
    620  0458
    621  0458							;
    622  0458							;=====================================================
    623  0458							; Pop the next line from the call stack.
    624  0458							;
    625  0458		       20 4a 0c    iRET       jsr	popLN
    626  045b		       b0 f4		      bcs	iSAVErr
    627  045d		       a0 03		      ldy	#3
    628  045f		       84 80		      sty	CUROFF
    629  0461		       a5 00		      lda	0
    630  0463		       8d aa 02 	      sta	IRQPending
    631  0466		       58		      cli
    632  0467		       4c eb 02 	      jmp	NextIL
    633  046a
    634  046a		       20 4a 0c    iRSTR      jsr	popLN
    635  046d		       b0 e2		      bcs	iSAVErr
    636  046f		       4c eb 02 	      jmp	NextIL
    637  0472		       a2 0b	   iRSTRErr   ldx	#11
    638  0474		       d0 dd		      bne	iSAVErr2
    639  0476							;
    640  0476							;=====================================================
    641  0476							; Compare items on stack.  Okay, so on input there are
    642  0476							; three things on the stack
    643  0476							;
    644  0476							;    EXPR2 <- Top of stack
    645  0476							;    OP    <- relational operator, next on stack
    646  0476							;    EXPR1 <- last item on stack
    647  0476							;
    648  0476							; Comparison is: EXPR1 <operator> EXPR2
    649  0476							;
    650  0476							; Operator is one of...
    651  0476							;
    652  0476							;    2 is =
    653  0476							;    1 is <
    654  0476							;    3 is <=
    655  0476							;    5 is <>
    656  0476							;    4 is >
    657  0476							;    6 is >=
    658  0476							;
    659  0476							; Those are bit-mapped:
    660  0476							;
    661  0476							;    xxxxxGEL
    662  0476							;
    663  0476							;    G = Greater than
    664  0476							;    E = Equal
    665  0476							;    L = Less than
    666  0476							;
    667  0476							; If the comparison is false, do a NXT, ie, move to the
    668  0476							; next line and continue.  If true, continue executing
    669  0476							; on this line.
    670  0476							;
    671  0476		       00 01	   REL_LT     equ	%001
    672  0476		       00 02	   REL_EQUAL  equ	%010
    673  0476		       00 04	   REL_GT     equ	%100
    674  0476							;
    675  0476		       20 69 0c    iCMPR      jsr	popR1
    676  0479		       20 7c 0c 	      jsr	popMQ	;operator in MQ
    677  047c		       20 37 0c 	      jsr	popR0
    678  047f							;
    679  047f							; See if they are equal or not
    680  047f							;
    681  047f		       a5 83		      lda	R0
    682  0481		       c5 85		      cmp	R1
    683  0483		       d0 0a		      bne	iCMPRnoteq	;try not equal
    684  0485		       a5 84		      lda	R0+1
    685  0487		       c5 86		      cmp	R1+1
    686  0489		       d0 04		      bne	iCMPRnoteq
    687  048b							;
    688  048b							; Equal, set the flag in MQ+1
    689  048b							;
    690  048b		       a9 02		      lda	#REL_EQUAL
    691  048d		       d0 14		      bne	iCMPcom
    692  048f							;
    693  048f							; See if EXPR1 (R0) < EXPR2 (R1)
    694  048f							; See www.6502.org/tutorials/compare_beyond.html
    695  048f							;
    696  048f		       a5 83	   iCMPRnoteq lda	R0
    697  0491		       c5 85		      cmp	R1
    698  0493		       a5 84		      lda	R0+1
    699  0495		       e5 86		      sbc	R1+1
    700  0497		       50 02		      bvc	iCMPR_2
    701  0499		       49 80		      eor	#$80
    702  049b		       30 04	   iCMPR_2    bmi	iCMPlt
    703  049d		       a9 04		      lda	#REL_GT
    704  049f		       d0 02		      bne	iCMPcom
    705  04a1		       a9 01	   iCMPlt     lda	#REL_LT	;R0 < R1
    706  04a3		       0d 45 12    iCMPcom    ora	MQ+1
    707  04a6							;
    708  04a6							; Now compare the end result with what the caller
    709  04a6							; was looking for.
    710  04a6							;
    711  04a6		       2d 44 12 	      and	MQ
    712  04a9		       f0 07		      beq	iCMPno	;no match
    713  04ab		       4c eb 02 	      jmp	NextIL
    714  04ae							;
    715  04ae							; R0 > R1
    716  04ae							;
    717  04ae		       a9 04	   iCMPgt     lda	#REL_GT
    718  04b0		       d0 f1		      bne	iCMPcom
    719  04b2							;
    720  04b2							; Not a match, so jump to the next line of code.
    721  04b2							;
    722  04b2		       20 6f 0a    iCMPno     jsr	FindNextLine
    723  04b5		       4c 22 04 	      jmp	iXFER2
    724  04b8							;
    725  04b8							;=====================================================
    726  04b8							; Get a line of text from the user, convert to a
    727  04b8							; number, leave on top of stack.
    728  04b8							;
    729  04b8		       a5 80	   iINNUM     lda	CUROFF	;save state before GetLine
    730  04ba		       48		      pha
    731  04bb		       a5 7f		      lda	CURPTR+1
    732  04bd		       48		      pha
    733  04be		       a5 7e		      lda	CURPTR
    734  04c0		       48		      pha
    735  04c1							;
    736  04c1		       a9 3f		      lda	#'?
    737  04c3		       20 71 0b 	      jsr	GetLine
    738  04c6		       20 fa 0a 	      jsr	getDecimal
    739  04c9		       20 f2 0b 	      jsr	pushR0	;put onto stack
    740  04cc							;
    741  04cc		       68		      pla
    742  04cd		       85 7e		      sta	CURPTR
    743  04cf		       68		      pla
    744  04d0		       85 7f		      sta	CURPTR+1
    745  04d2		       68		      pla
    746  04d3		       85 80		      sta	CUROFF
    747  04d5							;
    748  04d5		       4c eb 02 	      jmp	NextIL
    749  04d8							;
    750  04d8
    751  04d8							;
    752  04d8							;=====================================================
    753  04d8							; Stop the currently running program.	Actually very
    754  04d8							; simple to do... clear the RunMode flag, then set the
    755  04d8							; ILPC to the standard handler and continue running.
    756  04d8							;
    757  04d8		       a9 00	   iFIN       lda	#0
    758  04da		       85 87		      sta	RunMode
    759  04dc							;
    760  04dc		       ad 42 12 	      lda	errGoto
    761  04df		       85 75		      sta	ILPC
    762  04e1		       ad 43 12 	      lda	errGoto+1
    763  04e4		       85 76		      sta	ILPC+1
    764  04e6		       4c eb 02 	      jmp	NextIL
    765  04e9							;
    766  04e9							;=====================================================
    767  04e9							; Handle the ERR opcode.  Following the instruction is
    768  04e9							; a 16 bit error number.  Print an error message, and
    769  04e9							; if we're in run mode, print the line number.  Stop
    770  04e9							; program execution and return to the initial state.
    771  04e9							;
    772  04e9		       20 e5 09    iERR       jsr	getILWord	;get err code
    773  04ec							;
    774  04ec							; Enter here with the error code in X (LSB) and A (MSB).
    775  04ec							;
    776  04ec		       86 83	   iErr2      stx	R0
    777  04ee		       85 84		      sta	R0+1
    778  04f0							;
    779  04f0		       20 12 f0 	      jsr	puts
      0  04f3					      db	"Error ",0
      1  04f3		       45 72 72 6f*	      .byte.b	"Error ",0
    781  04fa		       20 8e 0a 	      jsr	PrintDecimal
    782  04fd							;
    783  04fd		       a5 87		      lda	RunMode	;running?
    784  04ff		       f0 1b		      beq	iERR2	;nope
    785  0501		       20 12 f0 	      jsr	puts
      0  0504					      db	" at line ",0
      1  0504		       20 61 74 20*	      .byte.b	" at line ",0
    787  050e		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    788  0510		       b1 7e		      lda	(CURPTR),y
    789  0512		       85 83		      sta	R0
    790  0514		       c8		      iny
    791  0515		       b1 7e		      lda	(CURPTR),y
    792  0517		       85 84		      sta	R0+1
    793  0519		       20 8e 0a 	      jsr	PrintDecimal
    794  051c							;
    795  051c		       20 0c 02    iERR2      jsr	CRLF
    796  051f		       a9 00		      lda	#0
    797  0521		       85 87		      sta	RunMode	;fall through...
    798  0523							;
    799  0523							;=====================================================
    800  0523							; Reset the IL to be back at the idle loop.  Does not
    801  0523							; clear variables so the user can see what state
    802  0523							; the program is in.
    803  0523							;
    804  0523		       a9 00	   ResetIL    lda	#0
    805  0525		       8d b8 11 	      sta	retStackPtr
    806  0528		       ad 42 12 	      lda	errGoto
    807  052b		       85 75		      sta	ILPC
    808  052d		       ad 43 12 	      lda	errGoto+1
    809  0530		       85 76		      sta	ILPC+1
    810  0532		       4c eb 02 	      jmp	NextIL
    811  0535							;
    812  0535							;=====================================================
    813  0535							; Pop two items off stack, add them, then place the
    814  0535							; result back onto the stack.
    815  0535							;
    816  0535		       20 37 0c    iADD       jsr	popR0
    817  0538		       20 69 0c 	      jsr	popR1
    818  053b		       18		      clc
    819  053c		       a5 83		      lda	R0
    820  053e		       65 85		      adc	R1
    821  0540		       85 83		      sta	R0
    822  0542		       a5 84		      lda	R0+1
    823  0544		       65 86		      adc	R1+1
    824  0546		       85 84		      sta	R0+1
    825  0548		       4c ad 05 	      jmp	pushR0nextIl
    826  054b							;
    827  054b							;=====================================================
    828  054b							; Pop two items off the stack.  Subtract the top of
    829  054b							; stack from the lower entry.
    830  054b							;
    831  054b		       20 69 0c    iSUB       jsr	popR1
    832  054e		       20 37 0c 	      jsr	popR0
    833  0551		       38		      sec
    834  0552		       a5 83		      lda	R0
    835  0554		       e5 85		      sbc	R1
    836  0556		       85 83		      sta	R0
    837  0558		       a5 84		      lda	R0+1
    838  055a		       e5 86		      sbc	R1+1
    839  055c		       85 84		      sta	R0+1
    840  055e		       4c ad 05 	      jmp	pushR0nextIl
    841  0561							;
    842  0561							;=====================================================
    843  0561							; Negate the top of stack.
    844  0561							;
    845  0561		       20 37 0c    iNEG       jsr	popR0
    846  0564		       a5 83		      lda	R0
    847  0566		       49 ff		      eor	#$ff
    848  0568		       85 83		      sta	R0
    849  056a		       a5 84		      lda	R0+1
    850  056c		       49 ff		      eor	#$ff
    851  056e		       85 84		      sta	R0+1
    852  0570		       e6 83		      inc	R0
    853  0572		       d0 02		      bne	iNEG2
    854  0574		       e6 84		      inc	R0+1
    855  0576		       4c ad 05    iNEG2      jmp	pushR0nextIl
    856  0579							;
    857  0579							;=====================================================
    858  0579							; Multiply top two items on the stack, put the results
    859  0579							; on top.  This uses the algorithm documented on page
    860  0579							; 115 of "Microprocessor Programming for Computer
    861  0579							; Hobbyists" by Neill Graham.
    862  0579							;
    863  0579		       20 37 0c    iMUL       jsr	popR0	;AC
    864  057c		       20 69 0c 	      jsr	popR1	;OP
    865  057f							;
    866  057f		       a5 83		      lda	R0
    867  0581		       8d 44 12 	      sta	MQ
    868  0584		       a5 84		      lda	R0+1
    869  0586		       8d 45 12 	      sta	MQ+1
    870  0589		       a9 00		      lda	#0	;clear result
    871  058b		       85 83		      sta	R0
    872  058d		       85 84		      sta	R0+1
    873  058f							;
    874  058f		       a2 10		      ldx	#16	;number of bits in value
    875  0591		       06 83	   multloop   asl	R0
    876  0593		       26 84		      rol	R0+1
    877  0595		       0e 44 12 	      asl	MQ
    878  0598		       2e 45 12 	      rol	MQ+1
    879  059b		       90 0d		      bcc	multno	;skip add if no carry
    880  059d							;
    881  059d							; Add R1 back into R0
    882  059d							;
    883  059d		       18		      clc
    884  059e		       a5 83		      lda	R0
    885  05a0		       65 85		      adc	R1
    886  05a2		       85 83		      sta	R0
    887  05a4		       a5 84		      lda	R0+1
    888  05a6		       65 86		      adc	R1+1
    889  05a8		       85 84		      sta	R0+1
    890  05aa							;
    891  05aa		       ca	   multno     dex		;did all bits yet?
    892  05ab		       d0 e4		      bne	multloop
    893  05ad							;
    894  05ad				   pushR0nextIl
    895  05ad		       20 f2 0b 	      jsr	pushR0	;OP
    896  05b0		       4c eb 02 	      jmp	NextIL
    897  05b3							;
    898  05b3							;=====================================================
    899  05b3							; Divide the top of stack into the next to top item.
    900  05b3							; Leave results on stack.  Taken from:
    901  05b3							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
    902  05b3							;
    903  05b3							; MQ = R0 / R1
    904  05b3							; Remainder is in R0
    905  05b3							;
    906  05b3		       20 69 0c    iDIV       jsr	popR1
    907  05b6		       20 37 0c 	      jsr	popR0
    908  05b9							;
    909  05b9							; Check for divide by zero
    910  05b9							;
    911  05b9		       a5 85		      lda	R1
    912  05bb		       05 86		      ora	R1+1
    913  05bd		       f0 36		      beq	divby0
    914  05bf							;
    915  05bf		       20 91 0c 	      jsr	SaveSigns
    916  05c2		       a9 00		      lda	#0	;preset remainder to 0
    917  05c4		       8d 44 12 	      sta	MQ
    918  05c7		       8d 45 12 	      sta	MQ+1
    919  05ca		       a2 10		      ldx	#16	;repeat for each bit: ...
    920  05cc
    921  05cc		       06 83	   divloop    asl	R0	;dividend lb & hb*2, msb -> Carry
    922  05ce		       26 84		      rol	R0+1
    923  05d0		       2e 44 12 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
    924  05d3		       2e 45 12 	      rol	MQ+1
    925  05d6		       ad 44 12 	      lda	MQ
    926  05d9		       38		      sec
    927  05da		       e5 85		      sbc	R1	;substract divisor to see if it fits in
    928  05dc		       a8		      tay		;lb result -> Y, for we may need it later
    929  05dd		       ad 45 12 	      lda	MQ+1
    930  05e0		       e5 86		      sbc	R1+1
    931  05e2		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
    932  05e4
    933  05e4		       8d 45 12 	      sta	MQ+1	;else save substraction result as new remainder,
    934  05e7		       8c 44 12 	      sty	MQ
    935  05ea		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
    936  05ec
    937  05ec		       ca	   skip       dex
    938  05ed		       d0 dd		      bne	divloop
    939  05ef		       20 cc 0c 	      jsr	RestoreSigns
    940  05f2		       4c ad 05 	      jmp	pushR0nextIl
    941  05f5							;
    942  05f5							; Indicate divide-by-zero error
    943  05f5							;
    944  05f5		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
    945  05f7		       a9 00		      lda	#0
    946  05f9		       4c ec 04 	      jmp	iErr2
    947  05fc							;
    948  05fc							;=====================================================
    949  05fc							; This pops the top two items off the stack.  The top
    950  05fc							; item is a data value and the other is an index into
    951  05fc							; the variable table.	Save the value into that entry.
    952  05fc							;
    953  05fc		       20 37 0c    iSTORE     jsr	popR0	;data
    954  05ff		       20 69 0c 	      jsr	popR1	;index
    955  0602		       a6 85		      ldx	R1	;get index
    956  0604		       a5 83		      lda	R0
    957  0606		       95 41		      sta	variables,x
    958  0608		       a5 84		      lda	R0+1
    959  060a		       95 42		      sta	variables+1,x
    960  060c		       4c eb 02 	      jmp	NextIL
    961  060f							;
    962  060f							;=====================================================
    963  060f							; Replaces the top of stack with the variable whose
    964  060f							; index it represents.
    965  060f							;
    966  060f		       20 69 0c    iIND       jsr	popR1
    967  0612		       a6 85		      ldx	R1	;get index
    968  0614		       b5 41		      lda	variables,x
    969  0616		       85 83		      sta	R0
    970  0618		       b5 42		      lda	variables+1,x
    971  061a		       85 84		      sta	R0+1
    972  061c		       4c ad 05 	      jmp	pushR0nextIl
    973  061f							;
    974  061f							;=====================================================
    975  061f							; List the current BASIC program in memory.  Uses R0,
    976  061f							; tempIly, and dpl.
    977  061f							;
    978  061f		       20 7c 0d    iLST       jsr	SetOutConsole
    979  0622		       a9 55	   iLST2      lda	#ProgramStart&$ff
    980  0624		       85 77		      sta	dpl
    981  0626		       a9 12		      lda	#ProgramStart>>8
    982  0628		       85 78		      sta	dpl+1
    983  062a							;
    984  062a							; dpl/dph point to the current line.  See if we're at
    985  062a							; the end of the program.
    986  062a							;
    987  062a		       a5 77	   iLSTloop   lda	dpl
    988  062c		       cd 4d 12 	      cmp	PROGRAMEND
    989  062f		       d0 07		      bne	iLstNotEnd
    990  0631		       a5 78		      lda	dpl+1
    991  0633		       cd 4e 12 	      cmp	PROGRAMEND+1
    992  0636		       f0 40		      beq	iLstdone
    993  0638							;
    994  0638		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
    995  063a		       b1 77		      lda	(dpl),y	;line number LSB
    996  063c		       85 83		      sta	R0
    997  063e		       c8		      iny
    998  063f		       b1 77		      lda	(dpl),y	;line number MSB
    999  0641		       85 84		      sta	R0+1
   1000  0643		       c8		      iny
   1001  0644		       84 7b		      sty	tempIlY
   1002  0646		       20 8e 0a 	      jsr	PrintDecimal
   1003  0649		       a9 20		      lda	#SPACE
   1004  064b		       20 87 0d 	      jsr	VOUTCH
   1005  064e		       a4 7b		      ldy	tempIlY
   1006  0650		       b1 77	   iLSTl2     lda	(dpl),y
   1007  0652		       f0 0a		      beq	iLST3	;end of this line
   1008  0654		       84 7b		      sty	tempIlY
   1009  0656		       20 87 0d 	      jsr	VOUTCH
   1010  0659		       a4 7b		      ldy	tempIlY
   1011  065b		       c8		      iny
   1012  065c		       d0 f2		      bne	iLSTl2	;do next char
   1013  065e							;
   1014  065e							; End of this line.  Print CR/LF, then move to the
   1015  065e							; next line.
   1016  065e							;
   1017  065e		       c8	   iLST3      iny
   1018  065f		       18		      clc
   1019  0660		       98		      tya
   1020  0661		       65 77		      adc	dpl
   1021  0663		       85 77		      sta	dpl
   1022  0665		       a5 78		      lda	dpl+1
   1023  0667		       69 00		      adc	#0
   1024  0669		       85 78		      sta	dpl+1
   1025  066b							;
   1026  066b							; Have to manually do CR/LF so it uses the vectored
   1027  066b							; output function.
   1028  066b							;
   1029  066b		       a9 0d		      lda	#CR
   1030  066d		       20 87 0d 	      jsr	VOUTCH
   1031  0670		       a9 0a		      lda	#LF
   1032  0672		       20 87 0d 	      jsr	VOUTCH
   1033  0675		       4c 2a 06 	      jmp	iLSTloop	;do next line
   1034  0678							;
   1035  0678		       20 7c 0d    iLstdone   jsr	SetOutConsole
   1036  067b		       4c eb 02 	      jmp	NextIL
   1037  067e							;
   1038  067e							;=====================================================
   1039  067e							; Get a line of text into LINBUF.  Terminate with a
   1040  067e							; null byte.
   1041  067e							;
   1042  067e		       a9 3e	   iGETLINE   lda	#'>	;prompt character
   1043  0680		       20 71 0b 	      jsr	GetLine
   1044  0683							;
   1045  0683		       a9 00		      lda	#0
   1046  0685		       85 87		      sta	RunMode
   1047  0687		       4c eb 02 	      jmp	NextIL
   1048  068a							;
   1049  068a							;=====================================================
   1050  068a							; This is called when the input buffer contains a line
   1051  068a							; typed in by the user that starts with a line number.
   1052  068a							; Insert the line into the program or delete the line
   1053  068a							; if there is nothing after the line number,
   1054  068a							;
   1055  068a		       a0 00	   iINSRT     ldy	#0
   1056  068c		       20 fa 0a 	      jsr	getDecimal	;convert line #
   1057  068f		       20 fb 0c 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1058  0692		       84 7c		      sty	offset	;Save the start of the program line text
   1059  0694							;
   1060  0694							; Now find the line OR the next higher line OR the
   1061  0694							; end of the program.
   1062  0694							;
   1063  0694		       20 2c 0a 	      jsr	findLine	; Look for the line number in the current program
   1064  0697							; Returns Z and curptr point to the line if found
   1065  0697							; Returns C and curptr at next higher line if not found and there is a higher line
   1066  0697							; Returns ZC clear and curptr to end of program if higher than all other lines
   1067  0697							;
   1068  0697							; If the line exists, it needs to be removed.
   1069  0697							;
   1070  0697		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1071  0699							;
   1072  0699							; Get length of line to be removed, we fall thru to here if we find a matching line
   1073  0699							;
   1074  0699							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1075  0699		       a0 00		      ldy	#0
   1076  069b		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1077  069d		       a8		      tay
   1078  069e							;If it is equal we delete the line and replace it, get length
   1079  069e							;then adjust all program line after up or down depending on len of line
   1080  069e							;If next higher then just move everythimg down by length bytes
   1081  069e							;This call will return how many bytes in the line we found
   1082  069e		       84 7d		      sty	lineLength	;Save the length of the line we found
   1083  06a0							;
   1084  06a0							; Compute the new end of the program first.
   1085  06a0							;
   1086  06a0		       38		      sec		;Set the carry bit
   1087  06a1		       ad 4d 12 	      lda	PROGRAMEND	;Get low byte of program end
   1088  06a4		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1089  06a6		       8d 4d 12 	      sta	PROGRAMEND	;save it
   1090  06a9		       ad 4e 12 	      lda	PROGRAMEND+1
   1091  06ac		       e9 00		      sbc	#0	;Process the carry
   1092  06ae		       8d 4e 12 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1093  06b1							;
   1094  06b1							; Copy CURPTR into R1 for working
   1095  06b1							;
   1096  06b1		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1097  06b3		       85 85		      sta	R1
   1098  06b5		       a5 7f		      lda	CURPTR+1
   1099  06b7		       85 86		      sta	R1+1
   1100  06b9							;
   1101  06b9							; See if we're at the end.
   1102  06b9							;
   1103  06b9		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1104  06bb		       cd 4d 12 	      cmp	PROGRAMEND
   1105  06be		       d0 07		      bne	InsDelLoop
   1106  06c0		       a5 86		      lda	R1+1
   1107  06c2		       cd 4e 12 	      cmp	PROGRAMEND+1
   1108  06c5		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1109  06c7							;
   1110  06c7							; Move one byte, move to next location.
   1111  06c7							;
   1112  06c7		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1113  06c9		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1114  06cb		       b1 85		      lda	(R1),y
   1115  06cd		       a0 00		      ldy	#0
   1116  06cf		       91 85		      sta	(R1),y
   1117  06d1		       e6 85		      inc	R1
   1118  06d3		       d0 e4		      bne	InsDelChk
   1119  06d5		       e6 86		      inc	R1+1
   1120  06d7		       4c b9 06 	      jmp	InsDelChk	; Check if we have moved the last byte
   1121  06da							;
   1122  06da							; Deletion is done.
   1123  06da							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1124  06da							;
   1125  06da		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1126  06dc		       b9 ba 11 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1127  06df		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1128  06e1							;
   1129  06e1							; CURPTR points to where the line will be inserted.
   1130  06e1							;
   1131  06e1		       20 ce 0b 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1132  06e4							;
   1133  06e4		       ad 4d 12 	      lda	PROGRAMEND	;Load the start address for the copy
   1134  06e7							;At this point curptr still contains the location we will insert data
   1135  06e7		       85 88		      sta	FROM
   1136  06e9		       ad 4e 12 	      lda	PROGRAMEND+1
   1137  06ec		       85 89		      sta	FROM+1
   1138  06ee							;
   1139  06ee		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1140  06f0		       b1 88		      lda	(FROM),y
   1141  06f2		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1142  06f4		       91 88		      sta	(FROM),y	;Save the new byte
   1143  06f6							;
   1144  06f6		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1145  06f8		       c5 7e		      cmp	CURPTR
   1146  06fa		       d0 06		      bne	mvUpMore
   1147  06fc		       a5 89		      lda	FROM+1
   1148  06fe		       c5 7f		      cmp	CURPTR+1
   1149  0700		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1150  0702							;
   1151  0702							; Not done yet
   1152  0702							;
   1153  0702		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1154  0704		       d0 02		      bne	mvUpMore2
   1155  0706		       c6 89		      dec	FROM+1
   1156  0708		       c6 88	   mvUpMore2  dec	FROM
   1157  070a		       4c ee 06 	      jmp	mvup1	;Loop until everything is moved
   1158  070d							;
   1159  070d							; All done with copy.
   1160  070d							;
   1161  070d		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1162  070e		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1163  0710		       6d 4d 12 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1164  0713		       8d 4d 12 	      sta	PROGRAMEND
   1165  0716		       ad 4e 12 	      lda	PROGRAMEND+1
   1166  0719		       69 00		      adc	#0
   1167  071b		       8d 4e 12 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1168  071e							;
   1169  071e							;===================jlit use length before line newline
   1170  071e
   1171  071e		       a0 00		      ldy	#0	;Set offset of copy
   1172  0720		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1173  0722		       91 7e		      sta	(CURPTR),y	;Store the length
   1174  0724		       c8		      iny
   1175  0725		       a5 83		      lda	R0	;Store the line number next
   1176  0727		       91 7e		      sta	(CURPTR),y
   1177  0729		       c8		      iny
   1178  072a		       a5 84		      lda	R0+1
   1179  072c		       91 7e		      sta	(CURPTR),y
   1180  072e		       c8		      iny
   1181  072f							;
   1182  072f		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1183  0731		       bd ba 11    mvUpLoop2  lda	LINBUF,x	;get a byte
   1184  0734		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1185  0736		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1186  0738		       e8		      inx
   1187  0739		       c8		      iny
   1188  073a		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1189  073c							;
   1190  073c		       4c eb 02    mvUpFini   jmp	NextIL
   1191  073f							;
   1192  073f							;=====================================================
   1193  073f							; Pops the top value of the ILPC stack and stores it
   1194  073f							; in ILPC.  Ie, return from an IL subroutine.
   1195  073f							;
   1196  073f		       20 19 0a    iRTN       jsr	popILPC
   1197  0742		       4c eb 02 	      jmp	NextIL
   1198  0745							;
   1199  0745							;=====================================================
   1200  0745							; NLINE print a newline
   1201  0745							;
   1202  0745		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1203  0748		       4c eb 02 	      jmp	NextIL
   1204  074b							;
   1205  074b							;=====================================================
   1206  074b							; This saves the current ILPC value on the stack, then
   1207  074b							; jumps to the address specified by the next two bytes.
   1208  074b							;
   1209  074b		       20 ff 09    iCALL      jsr	pushILPC	;save ILPC
   1210  074e							;
   1211  074e							; Jmp to a specific location in the IL code.  The new
   1212  074e							; address immediately follows the opcode.
   1213  074e							;
   1214  074e		       20 e5 09    iJMP       jsr	getILWord
   1215  0751		       86 75		      stx	ILPC
   1216  0753		       85 76		      sta	ILPC+1
   1217  0755		       4c eb 02 	      jmp	NextIL
   1218  0758							;
   1219  0758							;=====================================================
   1220  0758							; Push the next two bytes onto the arithmetic stack.
   1221  0758							;
   1222  0758		       20 e5 09    iLIT       jsr	getILWord
   1223  075b		       86 83		      stx	R0
   1224  075d		       85 84		      sta	R0+1
   1225  075f		       20 f2 0b 	      jsr	pushR0
   1226  0762		       4c eb 02 	      jmp	NextIL
   1227  0765							;
   1228  0765							;=====================================================
   1229  0765							; Initialize all variables.  Ie, set to zero.
   1230  0765							;
   1231  0765		       a9 00	   iVINIT     lda	#0
   1232  0767		       a2 00		      ldx	#0
   1233  0769		       95 41	   Vinit2     sta	variables,x
   1234  076b		       e8		      inx
   1235  076c		       e0 34		      cpx	#variablesEnd-variables
   1236  076e		       d0 f9		      bne	Vinit2
   1237  0770		       4c eb 02 	      jmp	NextIL
   1238  0773							;
   1239  0773							;=====================================================
   1240  0773							; Set the address of the error handler.  After any
   1241  0773							; error, set to the ILPC to the specified location.
   1242  0773							;
   1243  0773		       20 e5 09    iERRGOTO   jsr	getILWord
   1244  0776		       8e 42 12 	      stx	errGoto
   1245  0779		       8d 43 12 	      sta	errGoto+1
   1246  077c		       4c eb 02 	      jmp	NextIL
   1247  077f							;
   1248  077f							;=====================================================
   1249  077f							; TST is followed by an 8 bit signed offset, then a
   1250  077f							; null terminated string.  Compare the string against
   1251  077f							; the string starting at (CURPTR),CUROFF.  If the
   1252  077f							; strings match, continue executing the next IL
   1253  077f							; opcode.  Else, add the offset to ILPC.
   1254  077f							;
   1255  077f		       20 e9 09    iTST       jsr	getILByte
   1256  0782		       85 7c		      sta	offset
   1257  0784							;
   1258  0784		       20 e0 0b 	      jsr	saveIL	;in case of failure
   1259  0787		       a4 80		      ldy	CUROFF
   1260  0789		       84 77		      sty	dpl	;save for later
   1261  078b							;
   1262  078b		       20 e9 09    iTSTloop   jsr	getILByte	;get next char
   1263  078e		       f0 11		      beq	iTSTm	;match!
   1264  0790		       a4 77		      ldy	dpl
   1265  0792		       d1 7e		      cmp	(CURPTR),y
   1266  0794		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1267  0796		       09 20		      ora	#$20	; lets allow lowercase as well
   1268  0798		       d1 7e		      cmp	(CURPTR),y
   1269  079a		       d0 22		      bne	iTSTfail	;mismatch
   1270  079c		       c8	   iTSTUpper  iny
   1271  079d		       84 77		      sty	dpl
   1272  079f		       d0 ea		      bne	iTSTloop
   1273  07a1							;
   1274  07a1							; It's a match!  Clean up a bit.
   1275  07a1							;
   1276  07a1		       a4 77	   iTSTm      ldy	dpl
   1277  07a3		       84 80		      sty	CUROFF
   1278  07a5		       4c eb 02 	      jmp	NextIL
   1279  07a8							; Test for a single quote
   1280  07a8		       20 e9 09    iTSTStr    jsr	getILByte
   1281  07ab		       85 7c		      sta	offset
   1282  07ad		       20 e0 0b 	      jsr	saveIL
   1283  07b0		       a4 80		      ldy	CUROFF
   1284  07b2		       a9 22		      lda	#'"
   1285  07b4		       d1 7e		      cmp	(CURPTR),y
   1286  07b6		       d0 06		      bne	iTSTfail
   1287  07b8		       c8		      iny
   1288  07b9		       84 80		      sty	CUROFF
   1289  07bb		       4c f9 02 	      jmp	NextILStr
   1290  07be							;
   1291  07be							; Not a match, reset ILPC and then move to the
   1292  07be							; offset.
   1293  07be							;
   1294  07be		       20 e9 0b    iTSTfail   jsr	restoreIL
   1295  07c1		       4c 65 08 	      jmp	tstBranch
   1296  07c4							;
   1297  07c4							;=================================================JLIT=
   1298  07c4							; Test if we have a let statement without the let keyword
   1299  07c4		       20 e9 09    iTSTLET    jsr	getILByte
   1300  07c7		       85 7c		      sta	offset
   1301  07c9		       20 e0 0b 	      jsr	saveIL	; save to restore when done
   1302  07cc
   1303  07cc		       a4 80		      ldy	CUROFF
   1304  07ce		       20 fb 0c 	      jsr	SkipSpaces
   1305  07d1		       c8		      iny		; skip the Variable name
   1306  07d2		       20 fb 0c 	      jsr	SkipSpaces	; skip any SkipSpaces
   1307  07d5		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1308  07d7		       c9 3d		      cmp	#'=	; check if equals
   1309  07d9		       d0 e3		      bne	iTSTfail	; return it failed
   1310  07db		       20 e9 0b 	      jsr	restoreIL	; restore the IL anyway
   1311  07de		       4c eb 02 	      jmp	NextIL	; Then next instruction
   1312  07e1
   1313  07e1							;================================================jLIT=
   1314  07e1							;Test for end of line
   1315  07e1							;
   1316  07e1		       20 e9 09    iTSTDONE   jsr	getILByte
   1317  07e4		       85 7c		      sta	offset
   1318  07e6		       20 e0 0b 	      jsr	saveIL
   1319  07e9
   1320  07e9		       a4 80		      ldy	CUROFF
   1321  07eb		       84 77		      sty	dpl
   1322  07ed		       20 fb 0c 	      jsr	SkipSpaces
   1323  07f0		       b1 7e		      lda	(CURPTR),y
   1324  07f2		       f0 07		      beq	iTSTDONEtrue
   1325  07f4		       a4 77		      ldy	dpl
   1326  07f6		       84 80		      sty	CUROFF
   1327  07f8		       4c be 07 	      jmp	iTSTfail
   1328  07fb							;
   1329  07fb							; Advance to the next line
   1330  07fb							;
   1331  07fb		       4c eb 02    iTSTDONEtrue jmp	NextIL
   1332  07fe							;
   1333  07fe							;=====================================================
   1334  07fe							; TSTV is followed by an 8 bit signed offset.	If the
   1335  07fe							; value at (CURPTR),CUROFF appears to be a variable
   1336  07fe							; name, move to the next IL statement.  Else, add the
   1337  07fe							; offset to ILPC.
   1338  07fe							;
   1339  07fe		       20 e9 09    iTSTV      jsr	getILByte	;offset
   1340  0801		       85 7c		      sta	offset
   1341  0803							;
   1342  0803		       a4 80		      ldy	CUROFF
   1343  0805		       20 fb 0c 	      jsr	SkipSpaces
   1344  0808		       b1 7e		      lda	(CURPTR),y
   1345  080a							;
   1346  080a		       09 20		      ora	#$20	;make lower then upper
   1347  080c		       49 20		      eor	#$20	;allow lower case here
   1348  080e		       c9 41		      cmp	#'A
   1349  0810		       90 53		      bcc	tstBranch
   1350  0812		       c9 5b		      cmp	#'Z+1
   1351  0814		       b0 4f		      bcs	tstBranch
   1352  0816							;
   1353  0816							; The condition is true, so convert to an index, push
   1354  0816							; it onto the stack and continue running.
   1355  0816							;
   1356  0816		       38		      sec
   1357  0817		       e9 41		      sbc	#'A	;index is zero based
   1358  0819		       0a		      asl		;multiply by two
   1359  081a		       85 83		      sta	R0
   1360  081c		       a9 00		      lda	#0
   1361  081e		       85 84		      sta	R0+1
   1362  0820		       20 f2 0b 	      jsr	pushR0	;put index onto stack
   1363  0823		       e6 80		      inc	CUROFF	;move to next input char
   1364  0825		       4c eb 02 	      jmp	NextIL
   1365  0828							;
   1366  0828							;=====================================================
   1367  0828							; TSTL seems basically the same as TSTN, but leave the
   1368  0828							; value in R0 instead of pushing onto stack.
   1369  0828							; This tests for a valid line number
   1370  0828							;
   1371  0828		       20 e9 09    iTSTL      jsr	getILByte
   1372  082b		       85 7c		      sta	offset
   1373  082d							;
   1374  082d		       a4 80		      ldy	CUROFF
   1375  082f		       20 fb 0c 	      jsr	SkipSpaces
   1376  0832		       b1 7e		      lda	(CURPTR),y
   1377  0834							;
   1378  0834		       c9 30		      cmp	#'0
   1379  0836		       90 2d		      bcc	tstBranch
   1380  0838		       c9 3a		      cmp	#'9+1
   1381  083a		       b0 29		      bcs	tstBranch
   1382  083c							;
   1383  083c							; It's a digit, so convert to a number.
   1384  083c							;
   1385  083c		       20 fa 0a 	      jsr	getDecimal
   1386  083f		       4c eb 02 	      jmp	NextIL
   1387  0842							;
   1388  0842							;=====================================================
   1389  0842							; TSTN checks for a number.  This is very simplistic;
   1390  0842							; if the character is a digit, assume it's a number.
   1391  0842							; Convert to a number and push it onto the stack.
   1392  0842							;
   1393  0842		       20 e9 09    iTSTN      jsr	getILByte
   1394  0845		       85 7c		      sta	offset
   1395  0847							;
   1396  0847		       a4 80		      ldy	CUROFF
   1397  0849		       20 fb 0c 	      jsr	SkipSpaces
   1398  084c		       b1 7e		      lda	(CURPTR),y
   1399  084e		       c9 2d		      cmp	#'-	;negative?
   1400  0850		       f0 08		      beq	iTSTN_1
   1401  0852		       c9 30		      cmp	#'0
   1402  0854		       90 0f		      bcc	tstBranch
   1403  0856		       c9 3a		      cmp	#'9+1
   1404  0858		       b0 0b		      bcs	tstBranch
   1405  085a							;
   1406  085a							; It's a digit, so convert to a number.
   1407  085a							;
   1408  085a		       20 fa 0a    iTSTN_1    jsr	getDecimal
   1409  085d		       84 80		      sty	CUROFF
   1410  085f		       20 f2 0b 	      jsr	pushR0	;save onto stack
   1411  0862		       4c eb 02 	      jmp	NextIL
   1412  0865
   1413  0865							;
   1414  0865							; Common jump point for all TSTx instructions that
   1415  0865							; fail to meet the requirements.  This takes the
   1416  0865							; offset and adds/subtracts to/from ILPC.
   1417  0865							;
   1418  0865		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1419  0867		       10 0e		      bpl	tstPositive
   1420  0869							;
   1421  0869							; Do negative branch.	Do sign extension.
   1422  0869							;
   1423  0869		       18		      clc
   1424  086a		       65 75		      adc	ILPC
   1425  086c		       85 75		      sta	ILPC
   1426  086e		       a5 76		      lda	ILPC+1
   1427  0870		       69 ff		      adc	#$ff
   1428  0872		       85 76		      sta	ILPC+1
   1429  0874		       4c eb 02 	      jmp	NextIL	;keep going
   1430  0877							;
   1431  0877		       18	   tstPositive clc
   1432  0878		       65 75		      adc	ILPC
   1433  087a		       85 75		      sta	ILPC
   1434  087c		       a5 76		      lda	ILPC+1
   1435  087e		       69 00		      adc	#0
   1436  0880		       85 76		      sta	ILPC+1
   1437  0882		       4c eb 02 	      jmp	NextIL
   1438  0885
   1439  0885							;
   1440  0885							;====================================================
   1441  0885							;Test for IRQ pending
   1442  0885							;
   1443  0885		       20 e9 09    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1444  0888		       85 7c		      sta	offset
   1445  088a		       ad aa 02 	      lda	IRQPending
   1446  088d		       f0 d6		      beq	tstBranch
   1447  088f		       c9 01		      cmp	#1	; only do this if set to first time
   1448  0891		       d0 d2		      bne	tstBranch
   1449  0893		       78		      sei		; disable the interupt until ireturn resets it
   1450  0894		       ee aa 02    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1451  0897		       20 05 0c 	      jsr	pushLN	; Push the next line to be executed
   1452  089a		       b0 11		      bcs	irqErra	; Check if there was an error
   1453  089c		       ad ab 02 	      lda	IRQEntry	; Get the line number to branch to
   1454  089f		       85 7e		      sta	CURPTR	; put line number into r0
   1455  08a1		       ad ac 02 	      lda	IRQEntry+1
   1456  08a4		       85 7f		      sta	CURPTR+1
   1457  08a6		       a9 03		      lda	#3
   1458  08a8		       85 80		      sta	CUROFF
   1459  08aa		       4c eb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1460  08ad		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1461  08af		       a9 00		      lda	#0	; stop the execution
   1462  08b1		       4c ec 04 	      jmp	iErr2
   1463  08b4							;
   1464  08b4							;=====================================================
   1465  08b4							; This places the number of free bytes on top of the
   1466  08b4							; stack.
   1467  08b4							;
   1468  08b4		       20 49 0d    iFREE      jsr	GetSizes
   1469  08b7		       20 f2 0b 	      jsr	pushR0
   1470  08ba		       4c eb 02 	      jmp	NextIL
   1471  08bd							;
   1472  08bd							;=====================================================
   1473  08bd							; Generate a random number from 0-FFFF and then MOD
   1474  08bd							; it with the value on top of stack.  Leaves number on
   1475  08bd							; stack
   1476  08bd							;
   1477  08bd		       20 69 0c    iRANDOM    jsr	popR1	;mod value
   1478  08c0							;
   1479  08c0							; If the value is zero, just return a one.
   1480  08c0							;
   1481  08c0		       a5 85		      lda	R1
   1482  08c2		       05 86		      ora	R1+1
   1483  08c4		       f0 63		      beq	irandom1
   1484  08c6							;
   1485  08c6		       ad 49 12 	      lda	random+1
   1486  08c9		       8d 47 12 	      sta	rtemp1
   1487  08cc		       ad 48 12 	      lda	random
   1488  08cf		       0a		      asl
   1489  08d0		       2e 47 12 	      rol	rtemp1
   1490  08d3		       0a		      asl
   1491  08d4		       2e 47 12 	      rol	rtemp1
   1492  08d7		       18		      clc
   1493  08d8		       6d 48 12 	      adc	random
   1494  08db		       48		      pha
   1495  08dc		       ad 47 12 	      lda	rtemp1
   1496  08df		       6d 49 12 	      adc	random+1
   1497  08e2		       8d 49 12 	      sta	random+1
   1498  08e5		       68		      pla
   1499  08e6		       69 11		      adc	#$11
   1500  08e8		       8d 48 12 	      sta	random
   1501  08eb		       ad 49 12 	      lda	random+1
   1502  08ee		       69 36		      adc	#$36
   1503  08f0		       8d 49 12 	      sta	random+1
   1504  08f3
   1505  08f3		       ad 48 12 	      lda	random
   1506  08f6		       85 83		      sta	R0
   1507  08f8		       ad 49 12 	      lda	random+1
   1508  08fb		       29 7f		      and	#$7f	;make positive
   1509  08fd		       85 84		      sta	R0+1
   1510  08ff							;
   1511  08ff							; R0 contains the number and R1 contains the max value.
   1512  08ff							;
   1513  08ff		       a5 83	   iRANDOM_2  lda	R0
   1514  0901		       c5 85		      cmp	R1
   1515  0903		       d0 16		      bne	iRANDOM_1
   1516  0905		       a5 84		      lda	R0+1
   1517  0907		       c5 86		      cmp	R1+1
   1518  0909		       d0 10		      bne	iRANDOM_1	;need to subtract
   1519  090b							;
   1520  090b							; Subtract R1 from R0
   1521  090b							;
   1522  090b		       38	   iRANDOM_sub sec
   1523  090c		       a5 83		      lda	R0
   1524  090e		       e5 85		      sbc	R1
   1525  0910		       85 83		      sta	R0
   1526  0912		       a5 84		      lda	R0+1
   1527  0914		       e5 86		      sbc	R1+1
   1528  0916		       85 84		      sta	R0+1
   1529  0918		       4c ff 08 	      jmp	iRANDOM_2
   1530  091b							;
   1531  091b							; See if R1 > R0.  If so, branch to subtract.
   1532  091b							;
   1533  091b		       a5 83	   iRANDOM_1  lda	R0
   1534  091d		       c5 85		      cmp	R1
   1535  091f		       a5 84		      lda	R0+1
   1536  0921		       e5 86		      sbc	R1+1
   1537  0923		       50 02		      bvc	iRANDOM_4
   1538  0925		       49 80		      eor	#$80
   1539  0927		       10 e2	   iRANDOM_4  bpl	iRANDOM_sub
   1540  0929							;
   1541  0929							; All done.  Almost.  Add one, then push the result.
   1542  0929							;
   1543  0929		       e6 83	   irandom1   inc	R0
   1544  092b		       d0 02		      bne	iRANDOM_3
   1545  092d		       e6 84		      inc	R0+1
   1546  092f				   iRANDOM_3
   1547  092f		       20 f2 0b 	      jsr	pushR0	;return value
   1548  0932		       4c eb 02 	      jmp	NextIL
   1549  0935							;
   1550  0935							; Poke a value into a memory location
   1551  0935		       8c 4c 12    iPOKEMEMORY sty	tempy
   1552  0938		       20 37 0c 	      jsr	popR0
   1553  093b		       20 69 0c 	      jsr	popR1
   1554  093e		       a0 00		      ldy	#0
   1555  0940		       a5 83		      lda	R0
   1556  0942		       91 85		      sta	(R1),y
   1557  0944		       ac 4c 12 	      ldy	tempy
   1558  0947		       4c eb 02 	      jmp	NextIL
   1559  094a							;
   1560  094a							; Get a value from a memory location
   1561  094a							;
   1562  094a		       8c 4c 12    iPEEKMEMORY sty	tempy
   1563  094d		       20 37 0c 	      jsr	popR0
   1564  0950		       a0 00		      ldy	#0
   1565  0952		       b1 83		      lda	(R0),y
   1566  0954		       ac 4c 12 	      ldy	tempy
   1567  0957		       4c 7c 09 	      jmp	iPutStack
   1568  095a							;
   1569  095a							; Call to address return what ever is in a to the stack
   1570  095a							; func2 will load a value into a before the call
   1571  095a		       20 69 0c    iCallFunc2 jsr	popR1
   1572  095d		       a5 85		      lda	R1
   1573  095f		       20 6e 09    iCallFunc  jsr	iCallRtn
   1574  0962		       85 83		      sta	R0
   1575  0964		       a9 00		      lda	#0
   1576  0966		       85 84		      sta	R0+1
   1577  0968		       20 f2 0b 	      jsr	pushR0
   1578  096b		       4c eb 02 	      jmp	NextIL
   1579  096e		       20 37 0c    iCallRtn   jsr	popR0
   1580  0971		       6c 83 00 	      jmp	(R0)
   1581  0974
   1582  0974
   1583  0974							;===========================================jlit======
   1584  0974							;Get a character from the terminal convert to value
   1585  0974							;leave the number on top f the stack
   1586  0974							;
   1587  0974		       20 09 02    iGETCHAR   jsr	GETCH
   1588  0977					      if	CTMON65
   1589  0977		       48		      pha
   1590  0978		       20 0c f0 	      jsr	cout	;echo echo echo
   1591  097b		       68		      pla
   1592  097c					      endif
   1593  097c		       85 83	   iPutStack  sta	R0
   1594  097e		       a9 00		      lda	#0
   1595  0980		       85 84		      sta	R0+1
   1596  0982		       20 f2 0b 	      jsr	pushR0
   1597  0985		       4c eb 02 	      jmp	NextIL
   1598  0988							;===========================================jlit======
   1599  0988							;Put a character to the terminal convert to
   1600  0988							;
   1601  0988		       20 37 0c    iPUTCHAR   jsr	popR0
   1602  098b		       a5 83		      lda	R0
   1603  098d		       20 06 02 	      jsr	OUTCH
   1604  0990		       4c eb 02 	      jmp	NextIL
   1605  0993							;
   1606  0993							;
   1607  0993							;=====================================================
   1608  0993							; Replace TOS with its absolute value.
   1609  0993							;
   1610  0993		       20 37 0c    iABS       jsr	popR0
   1611  0996		       a5 84		      lda	R0+1
   1612  0998		       10 10		      bpl	iABS_1	;already positive
   1613  099a		       49 ff		      eor	#$ff
   1614  099c		       85 84		      sta	R0+1
   1615  099e		       a5 83		      lda	R0
   1616  09a0		       49 ff		      eor	#$ff
   1617  09a2		       85 83		      sta	R0
   1618  09a4		       e6 83		      inc	R0
   1619  09a6		       d0 02		      bne	iABS_1
   1620  09a8		       e6 84		      inc	R0+1
   1621  09aa		       20 f2 0b    iABS_1     jsr	pushR0
   1622  09ad		       4c eb 02 	      jmp	NextIL
   1623  09b0							;
   1624  09b0							;================================================================
   1625  09b0							;Set the IRQ service rtn line number
   1626  09b0							;
   1627  09b0		       78	   iSetIrq    sei		; disable the interupts
   1628  09b1		       a9 00		      lda	#0	; Zero the Status flag
   1629  09b3		       8d a9 02 	      sta	IRQStatus
   1630  09b6		       20 37 0c 	      jsr	popR0	; get the line number
   1631  09b9		       a5 83		      lda	R0
   1632  09bb		       05 84		      ora	R0+1
   1633  09bd		       f0 23		      beq	iSetExt	; if it is zero disable all
   1634  09bf		       a5 80		      lda	CUROFF
   1635  09c1		       8d a8 02 	      sta	SaveIrqReg	; save the offset
   1636  09c4		       20 05 0c 	      jsr	pushLN	; Save the current line pointer
   1637  09c7		       20 2c 0a 	      jsr	findLine	; Find the IRQ func Line Pointer
   1638  09ca		       a5 7f		      lda	CURPTR+1	; Copy it to the Entry pointer
   1639  09cc		       8d ac 02 	      sta	IRQEntry+1
   1640  09cf		       a5 7e		      lda	CURPTR
   1641  09d1		       8d ab 02 	      sta	IRQEntry
   1642  09d4		       a9 01		      lda	#1	; Indicate there is an irq gosub
   1643  09d6		       8d a9 02 	      sta	IRQStatus
   1644  09d9		       20 4a 0c 	      jsr	popLN	; Restore the old line number
   1645  09dc		       ad a8 02 	      lda	SaveIrqReg
   1646  09df		       85 80		      sta	CUROFF	; restore the offset
   1647  09e1		       58		      cli		; Enable the interupts
   1648  09e2		       4c eb 02    iSetExt    jmp	NextIL
   1649  09e5
   1650  09e5							;================================================================
   1651  09e5							;
------- FILE support.asm LEVEL 2 PASS 4
      0  09e5					      include	"support.asm"
      1  09e5							;
      2  09e5							;=====================================================
      3  09e5							;=====================================================
      4  09e5							;=====================================================
      5  09e5							; This marks the start of support functions used by
      6  09e5							; the IL opcodes.  These are support functions, NOT
      7  09e5							; the IL code.
      8  09e5							;=====================================================
      9  09e5		       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting
     10  09e5							;=====================================================
     11  09e5					      Seg	Code
     12  09e5							;=====================================================
     13  09e5							; This gets the next two bytes pointed to by ILPC and
     14  09e5							; returns them; X contains LSB, A contains MSB.  ILPC
     15  09e5							; is advanced by two, and Y contains 0 on return.
     16  09e5
     17  09e5							;
     18  09e5		       20 e9 09    getILWord  jsr	getILByte	;LSB
     19  09e8		       aa		      tax
     20  09e9							;
     21  09e9							;=====================================================
     22  09e9							; This gets the next byte pointed to by ILPC and
     23  09e9							; returns it in A.  On return, X is unchanged but Y
     24  09e9							; contains 0.
     25  09e9							;
     26  09e9		       a0 00	   getILByte  ldy	#0
     27  09eb		       b1 75		      lda	(ILPC),y	;get byte
     28  09ed		       08		      php		;save status
     29  09ee		       e6 75		      inc	ILPC	;inc LSB
     30  09f0		       d0 02		      bne	getILb2	;branch if no overflow
     31  09f2		       e6 76		      inc	ILPC+1	;inc MSB
     32  09f4		       28	   getILb2    plp		;restore status
     33  09f5		       60		      rts
     34  09f6							;
     35  09f6							;=====================================================
     36  09f6							; Decrement ILPC by one.
     37  09f6							;
     38  09f6		       a5 75	   decIL      lda	ILPC
     39  09f8		       d0 02		      bne	decIL2
     40  09fa		       c6 76		      dec	ILPC+1
     41  09fc		       c6 75	   decIL2     dec	ILPC
     42  09fe		       60		      rts
     43  09ff							;
     44  09ff							;=====================================================
     45  09ff							; Push the ILPC onto the return stack.  Actually, this
     46  09ff							; pushes the address of ILPC+2 since that's the next
     47  09ff							; address to execute.
     48  09ff							;
     49  09ff		       ac b8 11    pushILPC   ldy	retStackPtr
     50  0a02		       a5 75		      lda	ILPC
     51  0a04		       18		      clc
     52  0a05		       69 02		      adc	#2
     53  0a07		       99 a8 11 	      sta	retStack,y
     54  0a0a		       08		      php		;save C bit
     55  0a0b		       c8		      iny
     56  0a0c		       a5 76		      lda	ILPC+1
     57  0a0e		       28		      plp		;restore C
     58  0a0f		       69 00		      adc	#0
     59  0a11		       99 a8 11 	      sta	retStack,y
     60  0a14		       c8		      iny
     61  0a15		       8c b8 11 	      sty	retStackPtr
     62  0a18		       60		      rts
     63  0a19							;
     64  0a19							;=====================================================
     65  0a19							; Pull the top entry from return stack and put into
     66  0a19							; ILPC.
     67  0a19							;
     68  0a19		       ac b8 11    popILPC    ldy	retStackPtr
     69  0a1c		       88		      dey
     70  0a1d		       b9 a8 11 	      lda	retStack,y
     71  0a20		       85 76		      sta	ILPC+1
     72  0a22		       88		      dey
     73  0a23		       b9 a8 11 	      lda	retStack,y
     74  0a26		       85 75		      sta	ILPC
     75  0a28		       8c b8 11 	      sty	retStackPtr
     76  0a2b		       60		      rts
     77  0a2c							;
     78  0a2c							;=====================================================
     79  0a2c							; This searches for a specific line number that is in
     80  0a2c							; R0.	There are three possible return conditions:
     81  0a2c							; Line numbers are now the third byte, the first byte is now **************
     82  0a2c							; a pointer to the next line, of course no longer that 53 byte
     83  0a2c							; per line.
     84  0a2c							;
     85  0a2c							; Exact match was found:
     86  0a2c							;    * Z set
     87  0a2c							;    * CURPTR points to two-byte line number for that
     88  0a2c							;	line.
     89  0a2c							;
     90  0a2c							; Next highest line found:
     91  0a2c							;    * Z cleared
     92  0a2c							;    * C set
     93  0a2c							;    * CURPTR points to two-byte line number for that
     94  0a2c							;	line.
     95  0a2c							;
     96  0a2c							; End of program reached:
     97  0a2c							;    * Z cleared
     98  0a2c							;    * C cleared
     99  0a2c							;    * CURPTR points to first free byte at end of
    100  0a2c							;	program.  Ie, it has save value as PROGRAMEND.
    101  0a2c							;
    102  0a2c							; A, X, and Y are all undefined on return.
    103  0a2c							;
    104  0a2c
    105  0a2c		       a9 55	   findLine   lda	#ProgramStart&$ff	;Start of program -> CURPTR
    106  0a2e		       85 7e		      sta	CURPTR
    107  0a30		       a9 12		      lda	#ProgramStart>>8
    108  0a32		       85 7f		      sta	CURPTR+1
    109  0a34							;
    110  0a34							; At end of code?
    111  0a34							;
    112  0a34		       a5 7e	   iXFER1     lda	CURPTR	; chk CURPTR = END PROGRAM
    113  0a36		       cd 4d 12 	      cmp	PROGRAMEND
    114  0a39		       d0 0b		      bne	xfer2	;not end
    115  0a3b		       a5 7f		      lda	CURPTR+1
    116  0a3d		       cd 4e 12 	      cmp	PROGRAMEND+1
    117  0a40		       d0 04		      bne	xfer2	;Not at end
    118  0a42							;
    119  0a42							; Line not found and the end of the program was
    120  0a42							; reached.  Return Z and C both clear.
    121  0a42							;
    122  0a42		       a9 01		      lda	#1	;clear Z
    123  0a44		       18		      clc		;clear C
    124  0a45		       60		      rts
    125  0a46							;
    126  0a46							; Check for an exact line number match
    127  0a46							;
    128  0a46		       a5 83	   xfer2      lda	R0
    129  0a48		       a0 01		      ldy	#1	; changed to skip extra length byte
    130  0a4a		       d1 7e		      cmp	(CURPTR),y
    131  0a4c		       d0 08		      bne	xfernotit
    132  0a4e		       c8		      iny
    133  0a4f		       a5 84		      lda	R0+1
    134  0a51		       d1 7e		      cmp	(CURPTR),y
    135  0a53		       d0 01		      bne	xfernotit	; not a matching line number
    136  0a55							;
    137  0a55							; This is exactly the line we want.
    138  0a55							;
    139  0a55		       60		      rts		;it matches exactly
    140  0a56							;
    141  0a56							; See if this line is greater than the one we're
    142  0a56							; searching for.
    143  0a56							;
    144  0a56		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    145  0a58		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    146  0a5a		       c5 84		      cmp	R0+1
    147  0a5c		       90 0b		      bcc	xfer3
    148  0a5e		       d0 07		      bne	xfer4
    149  0a60		       88		      dey
    150  0a61		       b1 7e		      lda	(CURPTR),y	;compare LSB
    151  0a63		       c5 83		      cmp	R0
    152  0a65		       90 02		      bcc	xfer3
    153  0a67							;
    154  0a67							; This line is greater than the one we want, so
    155  0a67							; return Z clear and C set.
    156  0a67							;
    157  0a67		       38	   xfer4      sec		;We found a line number greater
    158  0a68		       60		      rts		;both conditions set
    159  0a69							;
    160  0a69							; Not the line (or droid) we're looking for.  Move to
    161  0a69							; the next line.
    162  0a69							;
    163  0a69		       20 6f 0a    xfer3      jsr	FindNextLine
    164  0a6c		       4c 34 0a 	      jmp	iXFER1
    165  0a6f							;
    166  0a6f							;=====================================================
    167  0a6f							; This advances CURPTR to the next line.  If there
    168  0a6f							; are no more lines, this leaves CURPTR equal to
    169  0a6f							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    170  0a6f							; CURPTR is pointing to a valid line on entry.  This
    171  0a6f							; pointer points to the two-byte line number.
    172  0a6f							; Update this points to the 1 byte line length  ****************
    173  0a6f							;
    174  0a6f				   FindNextLine
    175  0a6f		       a0 03		      ldy	#3	;skip line number and length byte
    176  0a71		       84 80		      sty	CUROFF	;this is the new offset
    177  0a73		       a0 00		      ldy	#0
    178  0a75		       b1 7e		      lda	(CURPTR),y	;Get the length
    179  0a77		       18		      clc
    180  0a78		       65 7e		      adc	CURPTR
    181  0a7a		       85 7e		      sta	CURPTR
    182  0a7c		       90 02		      bcc	FindNext4	;exit
    183  0a7e		       e6 7f		      inc	CURPTR+1
    184  0a80		       60	   FindNext4  rts
    185  0a81							;
    186  0a81							;=====================================================
    187  0a81							; This compares CURPTR to PROGRAMEND and returns Z set
    188  0a81							; if they are equal, Z clear if not.
    189  0a81							;
    190  0a81		       a5 7e	   AtEnd      lda	CURPTR
    191  0a83		       cd 4d 12 	      cmp	PROGRAMEND
    192  0a86		       d0 05		      bne	atendexit
    193  0a88		       a5 7f		      lda	CURPTR+1
    194  0a8a		       cd 4e 12 	      cmp	PROGRAMEND+1
    195  0a8d		       60	   atendexit  rts
    196  0a8e							;
    197  0a8e							;=====================================================
    198  0a8e							; Print the contents of R0 as a signed decimal number.
    199  0a8e							; Does leading zero suppression.
    200  0a8e							;
    201  0a8e				   PrintDecimal
    202  0a8e		       a5 84		      lda	R0+1	;MSB has sign
    203  0a90		       10 17		      bpl	pplus	;it's a positive number
    204  0a92							;
    205  0a92							; Negative numbers need more work.  Invert all the bits,
    206  0a92							; then add one.
    207  0a92							;
    208  0a92		       a9 2d		      lda	#'-
    209  0a94		       20 87 0d 	      jsr	VOUTCH	;print the negative sign
    210  0a97							;
    211  0a97		       a5 83		      lda	R0	;invert bits
    212  0a99		       49 ff		      eor	#$ff
    213  0a9b		       85 83		      sta	R0
    214  0a9d		       a5 84		      lda	R0+1
    215  0a9f		       49 ff		      eor	#$ff
    216  0aa1		       85 84		      sta	R0+1
    217  0aa3		       e6 83		      inc	R0	;add one
    218  0aa5		       d0 02		      bne	pplus
    219  0aa7		       e6 84		      inc	R0+1
    220  0aa9							;
    221  0aa9							; Print the value in R0 as a positive number.
    222  0aa9							;
    223  0aa9		       a2 00	   pplus      ldx	#0	;start of subtraction table
    224  0aab		       8e 40 12 	      stx	diddigit	;no digits yet
    225  0aae		       a0 00	   pploop     ldy	#0	;result of division
    226  0ab0		       a5 83	   pploop2    lda	R0	;LSB
    227  0ab2		       38		      sec
    228  0ab3		       fd f2 0a 	      sbc	dectable,x
    229  0ab6		       85 83		      sta	R0
    230  0ab8		       a5 84		      lda	R0+1
    231  0aba		       fd f3 0a 	      sbc	dectable+1,x
    232  0abd		       10 2e		      bpl	pplusok	;no underflow
    233  0abf							;
    234  0abf							; Else, underflow.  Add back in the LSB of the
    235  0abf							; table to R0.
    236  0abf							;
    237  0abf		       18		      clc
    238  0ac0		       a5 83		      lda	R0
    239  0ac2		       7d f2 0a 	      adc	dectable,x
    240  0ac5		       85 83		      sta	R0
    241  0ac7							;
    242  0ac7							; Print the value in Y.  Actually, see if Y is zero and
    243  0ac7							; whether any digit has been printed yet.  If Y isn't
    244  0ac7							; zero or we've printed a digit, go ahead and print.
    245  0ac7							;
    246  0ac7		       8e 3f 12 	      stx	printtx
    247  0aca		       98		      tya
    248  0acb		       09 00		      ora	#0	;set flags
    249  0acd		       d0 05		      bne	pprintit	;non-zero, print
    250  0acf							;
    251  0acf		       ad 40 12 	      lda	diddigit
    252  0ad2		       f0 09		      beq	pprintno	;don't print
    253  0ad4							;
    254  0ad4		       98	   pprintit   tya
    255  0ad5		       09 30		      ora	#'0
    256  0ad7		       8d 40 12 	      sta	diddigit
    257  0ada		       20 87 0d 	      jsr	VOUTCH
    258  0add		       ae 3f 12    pprintno   ldx	printtx
    259  0ae0							;
    260  0ae0							; Move to the next table entry
    261  0ae0							;
    262  0ae0		       e8		      inx
    263  0ae1		       e8		      inx
    264  0ae2		       e0 08		      cpx	#dectableend-dectable
    265  0ae4		       d0 c8		      bne	pploop	;not at end
    266  0ae6							;
    267  0ae6							; At the end.	R0 contains the final value
    268  0ae6							; to print.
    269  0ae6							;
    270  0ae6		       a5 83		      lda	R0
    271  0ae8		       09 30		      ora	#'0
    272  0aea		       4c 87 0d 	      jmp	VOUTCH
    273  0aed							;
    274  0aed							; Finish doing the subtraction.
    275  0aed							;
    276  0aed		       85 84	   pplusok    sta	R0+1
    277  0aef		       c8		      iny
    278  0af0		       d0 be		      bne	pploop2
    279  0af2							;
    280  0af2							; Table of powers-of-ten
    281  0af2							;
      0  0af2				   dectable   dw	10000
      1  0af2		       10 27		      .word.w	10000
      0  0af4					      dw	1000
      1  0af4		       e8 03		      .word.w	1000
      0  0af6					      dw	100
      1  0af6		       64 00		      .word.w	100
      0  0af8					      dw	10
      1  0af8		       0a 00		      .word.w	10
    286  0af8		       0a fa	   dectableend equ	*
    287  0afa							;
    288  0afa							;=====================================================
    289  0afa							; Convert an ASCII string to a number.  On input,
    290  0afa							; (CURPTR),Y points to the first digit.  This gets
    291  0afa							; digit-by-digit until finding a non-number.  Returns
    292  0afa							; Y pointing to the non-digit, and R0 contains the
    293  0afa							; number.  This does NOT check for valid ranges, so
    294  0afa							; a value like "123456789" will produce something,
    295  0afa							; but not what you had expected.
    296  0afa							;
    297  0afa		       a9 00	   getDecimal lda	#0
    298  0afc		       85 83		      sta	R0
    299  0afe		       85 84		      sta	R0+1
    300  0b00		       85 77		      sta	dpl	;temporary negative flag
    301  0b02							;
    302  0b02							; See if it's negative...
    303  0b02							;
    304  0b02		       84 13		      sty	$0013
    305  0b04		       b1 7e		      lda	(CURPTR),y
    306  0b06		       c9 2d		      cmp	#'-
    307  0b08		       d0 02		      bne	getDecLoop
    308  0b0a		       e6 77		      inc	dpl	;it's negative
    309  0b0c							;
    310  0b0c		       b1 7e	   getDecLoop lda	(CURPTR),y
    311  0b0e		       c9 30		      cmp	#'0
    312  0b10		       90 36		      bcc	getDdone
    313  0b12		       c9 3a		      cmp	#'9+1
    314  0b14		       b0 32		      bcs	getDdone
    315  0b16		       38		      sec
    316  0b17		       e9 30		      sbc	#'0	;convert to binary
    317  0b19		       48		      pha
    318  0b1a							;
    319  0b1a							; Now multiply R0 by 10.  Remember that
    320  0b1a							; 2*N + 8*N = 10*N.
    321  0b1a							;
    322  0b1a		       06 83		      asl	R0
    323  0b1c		       26 84		      rol	R0+1	;*2
    324  0b1e		       a5 83		      lda	R0
    325  0b20		       85 85		      sta	R1
    326  0b22		       a5 84		      lda	R0+1
    327  0b24		       85 86		      sta	R1+1
    328  0b26		       06 83		      asl	R0
    329  0b28		       26 84		      rol	R0+1	;*4
    330  0b2a		       06 83		      asl	R0
    331  0b2c		       26 84		      rol	R0+1	;*8
    332  0b2e		       18		      clc		;now add the partial sums...
    333  0b2f		       a5 83		      lda	R0	;...to get *10
    334  0b31		       65 85		      adc	R1
    335  0b33		       85 83		      sta	R0
    336  0b35		       a5 84		      lda	R0+1
    337  0b37		       65 86		      adc	R1+1
    338  0b39		       85 84		      sta	R0+1
    339  0b3b							;
    340  0b3b							; Add in the new digit
    341  0b3b							;
    342  0b3b		       68		      pla
    343  0b3c		       18		      clc
    344  0b3d		       65 83		      adc	R0
    345  0b3f		       85 83		      sta	R0
    346  0b41		       90 02		      bcc	getD2
    347  0b43		       e6 84		      inc	R0+1
    348  0b45							;
    349  0b45							; Move to next character
    350  0b45							;
    351  0b45		       c8	   getD2      iny
    352  0b46		       d0 c4		      bne	getDecLoop
    353  0b48							;
    354  0b48							; All done with digits, so now deal with it being
    355  0b48							; negative.  If zero, then don't check for negative
    356  0b48							; flag.  Ie, -0 is stored as 0.
    357  0b48							;
    358  0b48		       a5 83	   getDdone   lda	R0
    359  0b4a		       05 84		      ora	R0+1
    360  0b4c		       f0 16		      beq	getDone2	;zero
    361  0b4e		       a5 77		      lda	dpl
    362  0b50		       f0 12		      beq	getDone2	;positive
    363  0b52							;
    364  0b52							; Invert all the bits, then add one.
    365  0b52							;
    366  0b52		       a5 83		      lda	R0
    367  0b54		       49 ff		      eor	#$ff
    368  0b56		       85 83		      sta	R0
    369  0b58		       a5 84		      lda	R0+1
    370  0b5a		       49 ff		      eor	#$ff
    371  0b5c		       85 84		      sta	R0+1
    372  0b5e							;
    373  0b5e		       e6 83		      inc	R0
    374  0b60		       d0 02		      bne	getDone2
    375  0b62		       e6 84		      inc	R0+1
    376  0b64				   getDone2
    377  0b64		       a5 83		      lda	R0
    378  0b66		       85 10		      sta	$0010
    379  0b68		       a5 84		      lda	R0+1
    380  0b6a		       85 11		      sta	$0011
    381  0b6c		       a5 77		      lda	dpl
    382  0b6e		       85 12		      sta	$012
    383  0b70
    384  0b70		       60		      rts
    385  0b71							;
    386  0b71							;=====================================================
    387  0b71							; Print the string that immediately follows the JSR to
    388  0b71							; this function.  Stops when a null byte is found,
    389  0b71							; then returns to the instruction immediately
    390  0b71							; following the null.
    391  0b71							;
    392  0b71							; Thanks to Ross Archer for this code.
    393  0b71							; http://www.6502.org/source/io/primm.htm
    394  0b71							;
    395  0b71				  -	      if	KIM
    396  0b71				  -puts       sty	putsy
    397  0b71				  -	      pla		;low part of "return" address
    398  0b71				  -			;(data start address)
    399  0b71				  -	      sta	dpl
    400  0b71				  -	      pla
    401  0b71				  -	      sta	dpl+1	;high part of "return" address
    402  0b71				  -			;(data start address)
    403  0b71				  -			;Note: we're pointing one short
    404  0b71				  -psinb      ldy	#1
    405  0b71				  -	      lda	(dpl),y	;Get next string character
    406  0b71				  -	      inc	dpl	;update the pointer
    407  0b71				  -	      bne	psinc	;if not, we're pntng to next char
    408  0b71				  -	      inc	dpl+1	;account for page crossing
    409  0b71				  -psinc      ora	#0	;Set flags according to contents of
    410  0b71				  -			;   Accumulator
    411  0b71				  -	      beq	psix1	;don't print the final NULL
    412  0b71				  -	      jsr	OUTCH	;write it out
    413  0b71				  -	      jmp	psinb	;back around
    414  0b71				  -psix1      inc	dpl
    415  0b71				  -	      bne	psix2
    416  0b71				  -	      inc	dpl+1	;account for page crossing
    417  0b71				  -psix2      ldy	putsy
    418  0b71				  -	      jmp	(dpl)	;return to byte following NULL
    419  0b71					      endif
    420  0b71							;
    421  0b71							;=====================================================
    422  0b71							; Gets a line of input into LINBUF.
    423  0b71							;
    424  0b71							; On entry:
    425  0b71							;    A contains the prompt character, or 0 if none.
    426  0b71							;
    427  0b71							; On exit:
    428  0b71							;    CURPTR points to LINBUF
    429  0b71							;    LINBUF contains the line with 0 at the end.
    430  0b71							;    Y has offset to first non-space character
    431  0b71							;    CURROFF has the same as Y.
    432  0b71							;
    433  0b71		       a2 ba	   GetLine    ldx	#LINBUF&$ff
    434  0b73		       86 7e		      stx	CURPTR
    435  0b75		       a2 11		      ldx	#LINBUF>>8
    436  0b77		       86 7f		      stx	CURPTR+1
    437  0b79							;
    438  0b79							; Prompt
    439  0b79							;
    440  0b79		       48		      pha		;save for retries
    441  0b7a		       68	   GetLinePr  pla		;restore
    442  0b7b		       48		      pha		;save again
    443  0b7c		       09 00		      ora	#0	;any prompt?
    444  0b7e		       f0 08		      beq	getlinenp
    445  0b80		       20 06 02 	      jsr	OUTCH
    446  0b83		       a9 20		      lda	#$20
    447  0b85		       20 06 02 	      jsr	OUTCH	;space after prompt
    448  0b88							;
    449  0b88		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    450  0b8a		       8e 3e 12    getline1   stx	getlinx
    451  0b8d		       20 09 02 	      jsr	GETCH
    452  0b90					      if	CTMON65
    453  0b90		       48		      pha
    454  0b91		       20 0c f0 	      jsr	cout	;echo echo echo
    455  0b94		       68		      pla
    456  0b95					      endif
    457  0b95		       c9 0d		      cmp	#CR
    458  0b97		       f0 0d		      beq	getlind	;end of line
    459  0b99		       c9 08		      cmp	#BS	;backspace?
    460  0b9b		       f0 21		      beq	getlinebs
    461  0b9d		       ae 3e 12 	      ldx	getlinx
    462  0ba0		       9d ba 11 	      sta	LINBUF,x
    463  0ba3		       e8		      inx
    464  0ba4		       d0 e4		      bne	getline1
    465  0ba6							;
    466  0ba6							; CR was hit
    467  0ba6							;
    468  0ba6		       a9 00	   getlind    lda	#0
    469  0ba8		       ae 3e 12 	      ldx	getlinx
    470  0bab		       9d ba 11 	      sta	LINBUF,x
    471  0bae		       85 80		      sta	CUROFF
    472  0bb0							;
    473  0bb0							; Output a CR/LF
    474  0bb0							;
    475  0bb0		       20 0c 02 	      jsr	CRLF
    476  0bb3							;
    477  0bb3							; If a blank line, prompt again.
    478  0bb3							;
    479  0bb3		       a0 00		      ldy	#0
    480  0bb5		       20 fb 0c 	      jsr	SkipSpaces
    481  0bb8		       b1 7e		      lda	(CURPTR),y
    482  0bba		       f0 be		      beq	GetLinePr	;empty line
    483  0bbc		       68		      pla		;get rid of prompt char
    484  0bbd		       60		      rts
    485  0bbe							;
    486  0bbe							; Backspace was hit
    487  0bbe							;
    488  0bbe		       ae 3e 12    getlinebs  ldx	getlinx
    489  0bc1		       f0 c7		      beq	getline1	;at start of line
    490  0bc3		       ca		      dex
    491  0bc4		       20 12 f0 	      jsr	puts
      0  0bc7					      db	27,"[K",0
      1  0bc7		       1b 5b 4b 00	      .byte.b	27,"[K",0
    493  0bcb		       4c 8a 0b 	      jmp	getline1
    494  0bce							;
    495  0bce							;=====================================================
    496  0bce							; Count the length of the line currently in LINBUF
    497  0bce							; starting at offset Y.  Returns the length in X.  The
    498  0bce							; starting offset in Y should point past the ASCII
    499  0bce							; line number.  Also counts the trailing NULL and two
    500  0bce							; extra bytes for where the line number will be.
    501  0bce							; Update must now include leading length byte not the null at end ****************
    502  0bce							;
    503  0bce				   getLineLength
    504  0bce		       a2 00		      ldx	#0	;size
    505  0bd0		       b9 ba 11    getLineL2  lda	LINBUF,y
    506  0bd3		       f0 04		      beq	getLineL3
    507  0bd5		       c8		      iny
    508  0bd6		       e8		      inx
    509  0bd7		       d0 f7		      bne	getLineL2
    510  0bd9		       e8	   getLineL3  inx		;count null at end
    511  0bda		       e8		      inx		;line number LSB
    512  0bdb		       e8		      inx		;MSB
    513  0bdc		       e8		      inx		;change: count new leading line length
    514  0bdd		       86 7d		      stx	lineLength
    515  0bdf		       60		      rts
    516  0be0							;
    517  0be0							;=====================================================
    518  0be0							; Count the length of the line pointed to by CURPTR.
    519  0be0							; This also counts the line number and the terminating
    520  0be0							; null.  Ie, this string returns 8:
    521  0be0							;
    522  0be0							; <lineLow><lineHi>Hello<null>
    523  0be0							;
    524  0be0							; Another way of looking at it: add the return value
    525  0be0							; to the CURPTR and it'll point to the next line's
    526  0be0							; line number.  Returns the value in Y.
    527  0be0							; Update to ject get the leading byte length ********************
    528  0be0							;
    529  0be0							;getCURPTRLength
    530  0be0							;		ldy	CURPTR
    531  0be0							;		ldy	#3	;change: skip line number and leading length byte
    532  0be0							;getCLineL2	lda	(CURPTR),y
    533  0be0							;		beq	getCLineL3
    534  0be0							;		iny
    535  0be0							;		bne	getCLineL2
    536  0be0							;getCLineL3	iny		;count null at end
    537  0be0							;		rts
    538  0be0							;
    539  0be0							;=====================================================
    540  0be0							; This saves ILPC.  This saves to a single save area,
    541  0be0							; so it can't be called more than once.
    542  0be0							;
    543  0be0		       a5 75	   saveIL     lda	ILPC
    544  0be2		       85 79		      sta	tempIL
    545  0be4		       a5 76		      lda	ILPC+1
    546  0be6		       85 7a		      sta	tempIL+1
    547  0be8		       60		      rts
    548  0be9							;
    549  0be9							;=====================================================
    550  0be9							; This restores ILPC.
    551  0be9							;
    552  0be9		       a5 79	   restoreIL  lda	tempIL
    553  0beb		       85 75		      sta	ILPC
    554  0bed		       a5 7a		      lda	tempIL+1
    555  0bef		       85 76		      sta	ILPC+1
    556  0bf1		       60		      rts
    557  0bf2							;
    558  0bf2							;=====================================================
    559  0bf2							; This pushes R0 onto the stack.
    560  0bf2							;
    561  0bf2		       ae a7 11    pushR0     ldx	mathStackPtr
    562  0bf5		       a5 83		      lda	R0
    563  0bf7		       9d 97 11 	      sta	mathStack,x
    564  0bfa		       e8		      inx
    565  0bfb		       a5 84		      lda	R0+1
    566  0bfd		       9d 97 11 	      sta	mathStack,x
    567  0c00		       e8		      inx
    568  0c01		       8e a7 11 	      stx	mathStackPtr
    569  0c04		       60		      rts
    570  0c05
    571  0c05							;=====================================================
    572  0c05							; This pushes curptr basic current line onto the call stack.
    573  0c05
    574  0c05		       8c 47 12    pushLN     sty	rtemp1
    575  0c08		       ac b9 11 	      ldy	GoSubStackPtr
    576  0c0b		       98		      tya
    577  0c0c		       c9 28		      cmp	#GOSUBSTACKSIZE*2
    578  0c0e		       f0 12		      beq	pusherr
    579  0c10		       a5 7e		      lda	CURPTR
    580  0c12		       91 81		      sta	(GOSUBSTACK),y
    581  0c14		       c8		      iny
    582  0c15		       a5 7f		      lda	CURPTR+1
    583  0c17		       91 81		      sta	(GOSUBSTACK),y
    584  0c19		       c8		      iny
    585  0c1a		       8c b9 11 	      sty	GoSubStackPtr
    586  0c1d		       ac 47 12 	      ldy	rtemp1
    587  0c20		       18		      clc
    588  0c21		       60		      rts
    589  0c22
    590  0c22		       38	   pusherr    sec
    591  0c23		       60		      rts
    592  0c24							;
    593  0c24							;=====================================================
    594  0c24							; This pushes R1 onto the stack
    595  0c24							;
    596  0c24		       ae a7 11    pushR1     ldx	mathStackPtr
    597  0c27		       a5 85		      lda	R1
    598  0c29		       9d 97 11 	      sta	mathStack,x
    599  0c2c		       e8		      inx
    600  0c2d		       a5 86		      lda	R1+1
    601  0c2f		       9d 97 11 	      sta	mathStack,x
    602  0c32		       e8		      inx
    603  0c33		       8e a7 11 	      stx	mathStackPtr
    604  0c36		       60		      rts
    605  0c37							;
    606  0c37							;=====================================================
    607  0c37							; This pops Top Of Stack and places it in R0.
    608  0c37							;
    609  0c37		       ae a7 11    popR0      ldx	mathStackPtr
    610  0c3a		       ca		      dex
    611  0c3b		       bd 97 11 	      lda	mathStack,x
    612  0c3e		       85 84		      sta	R0+1
    613  0c40		       ca		      dex
    614  0c41		       bd 97 11 	      lda	mathStack,x
    615  0c44		       85 83		      sta	R0
    616  0c46		       8e a7 11 	      stx	mathStackPtr
    617  0c49		       60		      rts
    618  0c4a							;=====================================================
    619  0c4a							; This pops Top Of gosub call Stack and
    620  0c4a							; laces it in CURPTR.
    621  0c4a							;
    622  0c4a		       8c 47 12    popLN      sty	rtemp1
    623  0c4d		       ac b9 11 	      ldy	GoSubStackPtr
    624  0c50		       88		      dey
    625  0c51		       98		      tya
    626  0c52		       c9 ff		      cmp	#$FF
    627  0c54		       f0 11		      beq	poperr
    628  0c56		       b1 81		      lda	(GOSUBSTACK),y
    629  0c58		       85 7f		      sta	CURPTR+1
    630  0c5a		       88		      dey
    631  0c5b		       b1 81		      lda	(GOSUBSTACK),y
    632  0c5d		       85 7e		      sta	CURPTR
    633  0c5f		       8c b9 11 	      sty	GoSubStackPtr
    634  0c62		       ac 47 12 	      ldy	rtemp1
    635  0c65		       18		      clc
    636  0c66		       60		      rts
    637  0c67		       38	   poperr     sec
      0  0c68					      rtn
      0  0c68					      db	25
      1  0c68		       19		      .byte.b	25
    639  0c69							;
    640  0c69							;=====================================================
    641  0c69							; This pops TOS and places it in R1.
    642  0c69							;
    643  0c69		       ae a7 11    popR1      ldx	mathStackPtr
    644  0c6c		       ca		      dex
    645  0c6d		       bd 97 11 	      lda	mathStack,x
    646  0c70		       85 86		      sta	R1+1
    647  0c72		       ca		      dex
    648  0c73		       bd 97 11 	      lda	mathStack,x
    649  0c76		       85 85		      sta	R1
    650  0c78		       8e a7 11 	      stx	mathStackPtr
    651  0c7b		       60		      rts
    652  0c7c							;
    653  0c7c							;=====================================================
    654  0c7c							; This pops TOS and places it in MQ.
    655  0c7c							;
    656  0c7c		       ae a7 11    popMQ      ldx	mathStackPtr
    657  0c7f		       ca		      dex
    658  0c80		       bd 97 11 	      lda	mathStack,x
    659  0c83		       8d 45 12 	      sta	MQ+1
    660  0c86		       ca		      dex
    661  0c87		       bd 97 11 	      lda	mathStack,x
    662  0c8a		       8d 44 12 	      sta	MQ
    663  0c8d		       8e a7 11 	      stx	mathStackPtr
    664  0c90		       60		      rts
    665  0c91							;
    666  0c91							;=====================================================
    667  0c91							; This assists with multiplication and division by
    668  0c91							; looking at R0 and R1 and saving a flag as to what
    669  0c91							; sign the result will be.  Math is always done on
    670  0c91							; positive numbers, so this converts negative numbers
    671  0c91							; into positives.  On exit, R0 and R1 are both
    672  0c91							; positive.  If the signs were different then 'signs'
    673  0c91							; will be non-zero.
    674  0c91							;
    675  0c91		       a9 00	   SaveSigns  lda	#0
    676  0c93		       8d 46 12 	      sta	sign	;assume positive
    677  0c96		       a5 84		      lda	R0+1	;MSB
    678  0c98		       10 13		      bpl	SaveSigns1
    679  0c9a		       ee 46 12 	      inc	sign	;it's negative
    680  0c9d		       49 ff		      eor	#$ff	;flip bits
    681  0c9f		       85 84		      sta	R0+1
    682  0ca1		       a5 83		      lda	R0
    683  0ca3		       49 ff		      eor	#$ff
    684  0ca5		       85 83		      sta	R0
    685  0ca7		       e6 83		      inc	R0
    686  0ca9		       d0 02		      bne	SaveSigns1
    687  0cab		       e6 84		      inc	R0+1
    688  0cad		       a5 86	   SaveSigns1 lda	R1+1
    689  0caf		       10 1a		      bpl	SaveSigns2
    690  0cb1		       48		      pha
    691  0cb2		       ad 46 12 	      lda	sign
    692  0cb5		       49 01		      eor	#1
    693  0cb7		       8d 46 12 	      sta	sign
    694  0cba		       68		      pla
    695  0cbb		       49 ff		      eor	#$ff	;flip bits
    696  0cbd		       85 86		      sta	R1+1
    697  0cbf		       a5 85		      lda	R1
    698  0cc1		       49 ff		      eor	#$ff
    699  0cc3		       85 85		      sta	R1
    700  0cc5		       e6 85		      inc	R1
    701  0cc7		       d0 02		      bne	SaveSigns2
    702  0cc9		       e6 86		      inc	R1+1
    703  0ccb		       60	   SaveSigns2 rts
    704  0ccc							;
    705  0ccc							;=====================================================
    706  0ccc							; This looks at the value of 'signs' and will convert
    707  0ccc							; both R0 and R1 to negative if set.
    708  0ccc							;
    709  0ccc				   RestoreSigns
    710  0ccc		       ad 46 12 	      lda	sign
    711  0ccf		       f0 28		      beq	restoresigns2
    712  0cd1							;
    713  0cd1		       a5 83		      lda	R0
    714  0cd3		       d0 02		      bne	restoresigns3
    715  0cd5		       c6 84		      dec	R0+1
    716  0cd7				   restoresigns3
    717  0cd7		       c6 83		      dec	R0
    718  0cd9		       a5 83		      lda	R0
    719  0cdb		       49 ff		      eor	#$ff
    720  0cdd		       85 83		      sta	R0
    721  0cdf		       a5 84		      lda	R0+1
    722  0ce1		       49 ff		      eor	#$ff
    723  0ce3		       85 84		      sta	R0+1
    724  0ce5							;
    725  0ce5		       a5 85		      lda	R1
    726  0ce7		       d0 02		      bne	restoresigns4
    727  0ce9		       c6 86		      dec	R1+1
    728  0ceb				   restoresigns4
    729  0ceb		       c6 85		      dec	R1
    730  0ced		       a5 85		      lda	R1
    731  0cef		       49 ff		      eor	#$ff
    732  0cf1		       85 85		      sta	R1
    733  0cf3		       a5 86		      lda	R1+1
    734  0cf5		       49 ff		      eor	#$ff
    735  0cf7		       85 86		      sta	R1+1
    736  0cf9							;
    737  0cf9				   restoresigns2
    738  0cf9		       60		      rts
    739  0cfa							;
    740  0cfa							;=====================================================
    741  0cfa							; Skip over spaces.  Returns Y with the offset to
    742  0cfa							; either the last character in the line, or the first
    743  0cfa							; non-space character.
    744  0cfa							;
    745  0cfa		       c8	   skipsp2    iny
    746  0cfb		       b1 7e	   SkipSpaces lda	(CURPTR),y
    747  0cfd		       f0 04		      beq	Skip3	;end of line
    748  0cff		       c9 20		      cmp	#SPACE
    749  0d01		       f0 f7		      beq	skipsp2
    750  0d03		       60	   Skip3      rts
    751  0d04							;
    752  0d04							;=====================================================
    753  0d04							; This is some debug logic which displays the current
    754  0d04							; value of the ILPC and the line buffer.
    755  0d04							;
    756  0d04		       20 12 f0    dbgLine    jsr	puts
      0  0d07					      db	"ILPC: ",0
      1  0d07		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    758  0d0e		       a5 76		      lda	ILPC+1
    759  0d10		       20 0f 02 	      jsr	OUTHEX
    760  0d13		       a5 75		      lda	ILPC
    761  0d15		       20 0f 02 	      jsr	OUTHEX
    762  0d18		       a9 20		      lda	#SPACE
    763  0d1a		       20 06 02 	      jsr	OUTCH
    764  0d1d		       a0 00		      ldy	#0
    765  0d1f		       b1 75		      lda	(ILPC),y
    766  0d21		       20 0f 02 	      jsr	OUTHEX
    767  0d24							;
    768  0d24							; Display the CURPTR value and offset
    769  0d24							;
    770  0d24		       20 12 f0 	      jsr	puts
      0  0d27					      db	", CURPTR: ",0
      1  0d27		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    772  0d32		       a5 7f		      lda	CURPTR+1
    773  0d34		       20 0f 02 	      jsr	OUTHEX
    774  0d37		       a5 7e		      lda	CURPTR
    775  0d39		       20 0f 02 	      jsr	OUTHEX
    776  0d3c		       a9 2b		      lda	#'+
    777  0d3e		       20 06 02 	      jsr	OUTCH
    778  0d41		       a5 80		      lda	CUROFF
    779  0d43		       20 0f 02 	      jsr	OUTHEX
    780  0d46							;
    781  0d46		       4c 0c 02 	      jmp	CRLF
    782  0d49							;
    783  0d49							;=====================================================
    784  0d49							; This function might go away eventually, but was
    785  0d49							; added to provide data for other pieces of code.
    786  0d49							; It has some ties to the operating environment that
    787  0d49							; will need to be customized for the target system.
    788  0d49							;
    789  0d49				   GetSizes
    790  0d49							;
    791  0d49							; Here is machine specific code to get the highest
    792  0d49							; memory location that can be used by BASIC.
    793  0d49							;
    794  0d49					      if	ProgramStart < $2000
    795  0d49		       a9 ff		      lda	#$ff
    796  0d4b		       8d 4f 12 	      sta	HighMem	;$13ff for KIM-1
    797  0d4e		       a9 de		      lda	#$DE	;#$13
    798  0d50		       8d 50 12 	      sta	HighMem+1
    799  0d53				  -	      else
    800  0d53				  -	      lda	#$ff
    801  0d53				  -	      sta	HighMem	;$CFFF otherwise
    802  0d53				  -	      lda	#$cf
    803  0d53				  -	      sta	HighMem+1
    804  0d53					      endif
    805  0d53							;
    806  0d53							; This computes the available memory remaining.
    807  0d53							;
    808  0d53		       38		      sec
    809  0d54		       ad 4f 12 	      lda	HighMem
    810  0d57		       ed 4d 12 	      sbc	PROGRAMEND
    811  0d5a		       8d 53 12 	      sta	FreeMem
    812  0d5d		       85 83		      sta	R0
    813  0d5f		       ad 50 12 	      lda	HighMem+1
    814  0d62		       ed 4e 12 	      sbc	PROGRAMEND+1
    815  0d65		       8d 54 12 	      sta	FreeMem+1
    816  0d68		       85 84		      sta	R0+1
    817  0d6a							;
    818  0d6a							; This computes the size of the current user program.
    819  0d6a							;
    820  0d6a		       38		      sec
    821  0d6b		       ad 4d 12 	      lda	PROGRAMEND
    822  0d6e		       e9 55		      sbc	#ProgramStart&$ff
    823  0d70		       8d 51 12 	      sta	UsedMem
    824  0d73		       ad 4e 12 	      lda	PROGRAMEND+1
    825  0d76		       e9 12		      sbc	#ProgramStart>>8
    826  0d78		       8d 52 12 	      sta	UsedMem+1
    827  0d7b							;
    828  0d7b		       60		      rts
    829  0d7c							;
    830  0d7c							;=====================================================
    831  0d7c							; Set output vector to the console output function
    832  0d7c							;
    833  0d7c				   SetOutConsole
    834  0d7c		       a9 06		      lda	#OUTCH&$ff
    835  0d7e		       8d 4a 12 	      sta	BOutVec
    836  0d81		       a9 02		      lda	#OUTCH/256
    837  0d83		       8d 4b 12 	      sta	BOutVec+1
    838  0d86		       60		      rts
    839  0d87							;
    840  0d87							;=====================================================
    841  0d87							; Jump to the output function in BOutVec
    842  0d87							;
    843  0d87		       6c 4a 12    VOUTCH     jmp	(BOutVec)
    844  0d8a
    845  0d8a							;====================================================
    846  0d8a		       12 47	   PrtTerm    equ	rtemp1
    847  0d8a
    848  0d8a							; Print Y has the offset to use
    849  0d8a		       a5 7e	   PrtQuoted  lda	CURPTR
    850  0d8c		       85 88		      sta	PrtFrom
    851  0d8e		       a5 7f		      lda	CURPTR+1
    852  0d90		       85 89		      sta	PrtFrom+1
    853  0d92		       a9 22		      lda	#'"
    854  0d94		       8d 47 12 	      sta	PrtTerm
    855  0d97		       4c a3 0d 	      jmp	PrtLoop
    856  0d9a							; Print a string pointed to by x= h, y=l terminated by a
    857  0d9a							; Return y as the length
    858  0d9a		       86 89	   PrtStr     stx	PrtFrom+1
    859  0d9c		       84 88		      sty	PrtFrom
    860  0d9e		       8d 47 12 	      sta	PrtTerm
    861  0da1		       a0 00		      ldy	#0
    862  0da3
    863  0da3		       b1 88	   PrtLoop    lda	(PrtFrom),y
    864  0da5		       cd 47 12 	      cmp	PrtTerm
    865  0da8		       f0 0b		      beq	PrtEnd
    866  0daa		       c9 00		      cmp	#0	; always end if 0 is found
    867  0dac		       f0 07		      beq	PrtEnd
    868  0dae		       20 06 02 	      jsr	OUTCH
    869  0db1		       c8		      iny
    870  0db2		       4c a3 0d 	      jmp	PrtLoop
    871  0db5		       c8	   PrtEnd     iny		;return byte after the copy
    872  0db6		       60		      rts
    873  0db7
    874  0db7							;====================================================
    875  0db7							;Clear the terminal assume it is ansii or vt100
    876  0db7							;
    877  0db7				   iCLEARSCREEN
    878  0db7		       20 12 f0 	      jsr	puts
      0  0dba					      db	$1b,'[,'3,'J,0
      1  0dba		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    880  0dbf		       4c eb 02 	      jmp	NextIL
------- FILE mytb.asm
   1653  0dc2					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  0dc2					      include	"storage.asm"
      1  0dc2							;
      2  0dc2							;=====================================================
      3  0dc2							;=====================================================
      4  0dc2							;=====================================================
      5  0dc2							; This file contains the functions for saving and
      6  0dc2							; restoring programs from some sort of mass storage
      7  0dc2							; device.  This particular version is for using the
      8  0dc2							; Corsham Tech SD Card System.
      9  0dc2							;=====================================================
     10  0dc2							;=====================================================
     11  0dc2							;=====================================================
     12  0dc2
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  0dc2					      SEG	Code
     19  0dc2
     20  0dc2							;
     21  0dc2							;=====================================================
     22  0dc2							; Open a file for reading as a program.  The next
     23  0dc2							; thing on the line should be the filename.
     24  0dc2							;
     25  0dc2				   iOPENREAD
     26  0dc2					      if	XKIM || CTMON65
     27  0dc2		       a4 80		      ldy	CUROFF
     28  0dc4		       b1 7e		      lda	(CURPTR),y
     29  0dc6		       d0 07		      bne	iOPENfn	;might be filename
     30  0dc8							;
     31  0dc8							; No filename supplied.
     32  0dc8							;
     33  0dc8		       a9 00	   iOPENnofn  lda	#0
     34  0dca		       a2 09		      ldx	#ERR_NO_FILENAME
     35  0dcc		       4c ec 04 	      jmp	iErr2
     36  0dcf							;
     37  0dcf							; Add the offset into the buffer start
     38  0dcf							;
     39  0dcf		       18	   iOPENfn    clc
     40  0dd0		       98		      tya
     41  0dd1		       65 7e		      adc	CURPTR
     42  0dd3		       a8		      tay		;LSB
     43  0dd4		       a5 7f		      lda	CURPTR+1
     44  0dd6		       69 00		      adc	#0
     45  0dd8		       aa		      tax
     46  0dd9		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  0ddc		       90 07		      bcc	Ropenok	;branch if opened ok
     48  0dde							;
     49  0dde							; Open failed
     50  0dde							;
     51  0dde		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  0de0		       a9 00	   Rdfail2    lda	#0
     53  0de2		       4c ec 04 	      jmp	iErr2
     54  0de5							;
     55  0de5							; Clear counts and offsets so the next read will
     56  0de5							; cause the file to be read.
     57  0de5							;
     58  0de5		       a9 00	   Ropenok    lda	#0
     59  0de7		       8d 8f df 	      sta	diskBufOffset
     60  0dea		       8d 8e df 	      sta	diskBufLength
     61  0ded		       4c eb 02 	      jmp	NextIL
     62  0df0					      endif
     63  0df0
     64  0df0							;
     65  0df0							;==============================jlit 08/02/2022========
     66  0df0							;Remove a file from the disk
     67  0df0				   iRMFILE
     68  0df0					      if	XKIM || CTMON65
     69  0df0		       a4 80		      ldy	CUROFF
     70  0df2		       b1 7e		      lda	(CURPTR),y
     71  0df4		       f0 19		      beq	iRMnofn
     72  0df6							;
     73  0df6		       18		      clc
     74  0df7		       98		      tya
     75  0df8		       65 7e		      adc	CURPTR
     76  0dfa		       a8		      tay		;LSB
     77  0dfb		       a5 7f		      lda	CURPTR+1
     78  0dfd		       69 00		      adc	#0
     79  0dff		       aa		      tax
     80  0e00		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  0e03		       90 07		      bcc	wrmOk	;branch if removed ok
     82  0e05		       a9 00		      lda	#0
     83  0e07		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  0e09		       4c ec 04 	      jmp	iErr2
     85  0e0c		       4c eb 02    wrmOk      jmp	NextIL
     86  0e0f
     87  0e0f							; No filename supplied.
     88  0e0f							;
     89  0e0f		       a9 00	   iRMnofn    lda	#0
     90  0e11		       a2 09		      ldx	#ERR_NO_FILENAME
     91  0e13		       4c ec 04 	      jmp	iErr2
     92  0e16					      endif
     93  0e16							;
     94  0e16							;=====================================================
     95  0e16				   iOPENWRITE
     96  0e16					      if	XKIM || CTMON65
     97  0e16		       a4 80		      ldy	CUROFF
     98  0e18		       b1 7e		      lda	(CURPTR),y
     99  0e1a		       f0 f3		      beq	iRMnofn
    100  0e1c							;
    101  0e1c		       18		      clc
    102  0e1d		       98		      tya
    103  0e1e		       65 7e		      adc	CURPTR
    104  0e20		       a8		      tay		;LSB
    105  0e21		       a5 7f		      lda	CURPTR+1
    106  0e23		       69 00		      adc	#0
    107  0e25		       aa		      tax
    108  0e26		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  0e29		       90 07		      bcc	Wopenok	;branch if opened ok
    110  0e2b							;
    111  0e2b							; Open failed
    112  0e2b							;
    113  0e2b		       a9 00	   Wdfail     lda	#0
    114  0e2d		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  0e2f		       4c ec 04 	      jmp	iErr2
    116  0e32							;
    117  0e32		       4c eb 02    Wopenok    jmp	NextIL
    118  0e35					      endif
    119  0e35							;
    120  0e35							;=====================================================
    121  0e35							; Gets a line of input from the disk file and puts it
    122  0e35							; into LINBUF.
    123  0e35							;
    124  0e35							; On exit:
    125  0e35							;    CURPTR points to LINBUF
    126  0e35							;    LINBUF contains the line with 0 at the end.
    127  0e35							;    Y has offset to first non-space character
    128  0e35							;    CURROFF has the same as Y.
    129  0e35							;
    130  0e35				   iDGETLINE
    131  0e35					      if	XKIM || CTMON65
    132  0e35		       a2 ba		      ldx	#LINBUF&$ff
    133  0e37		       86 7e		      stx	CURPTR
    134  0e39		       a2 11		      ldx	#LINBUF>>8
    135  0e3b		       86 7f		      stx	CURPTR+1
    136  0e3d							;
    137  0e3d		       a2 00		      ldx	#0	;offset
    138  0e3f		       8e 3e 12    iDgetLoop  stx	getlinx
    139  0e42		       20 a0 0e 	      jsr	getNextFileByte
    140  0e45		       b0 16		      bcs	iGetEOF
    141  0e47		       c9 0d		      cmp	#CR
    142  0e49		       f0 0d		      beq	iGetEOL
    143  0e4b		       c9 0a		      cmp	#LF
    144  0e4d		       f0 09		      beq	iGetEOL
    145  0e4f		       ae 3e 12 	      ldx	getlinx
    146  0e52		       9d ba 11 	      sta	LINBUF,x
    147  0e55		       e8		      inx
    148  0e56		       d0 e7		      bne	iDgetLoop
    149  0e58							;
    150  0e58							; Handle end of line.	If the line has nothing, loop
    151  0e58							; back and get another line.
    152  0e58							;
    153  0e58		       ae 3e 12    iGetEOL    ldx	getlinx	;blank line?
    154  0e5b		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  0e5d							;
    156  0e5d							; This can fall through when there is a line, or
    157  0e5d							; called directly when EOF is encountered.
    158  0e5d							;
    159  0e5d		       ae 3e 12    iGetEOF    ldx	getlinx
    160  0e60		       a9 00		      lda	#0
    161  0e62		       9d ba 11 	      sta	LINBUF,x
    162  0e65		       85 80		      sta	CUROFF
    163  0e67		       a0 00		      ldy	#0
    164  0e69		       20 fb 0c 	      jsr	SkipSpaces
    165  0e6c		       4c eb 02 	      jmp	NextIL
    166  0e6f					      endif
    167  0e6f
    168  0e6f							;
    169  0e6f							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  0e6f							; DISK
    171  0e6f							;
    172  0e6f				   iDDIR
    173  0e6f					      if	XKIM || CTMON65
    174  0e6f		       20 30 f0 	      jsr	DiskDir
    175  0e72							;
    176  0e72							; Get/Display each entry
    177  0e72							;
    178  0e72		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  0e74		       a0 90		      ldy	#DiskFileName&$ff
    180  0e76		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  0e79		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  0e7b		       20 12 f0 	      jsr	puts
      0  0e7e					      db	"   ",0
      1  0e7e		       20 20 20 00	      .byte.b	"   ",0
    184  0e82							; Print the line to the console
    185  0e82		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  0e84		       a0 90		      ldy	#DiskFileName&$ff
    187  0e86		       a5 00		      lda	0
    188  0e88		       20 9a 0d 	      jsr	PrtStr	;else print name
    189  0e8b		       20 18 f0 	      jsr	crlf
    190  0e8e
    191  0e8e		       4c 72 0e 	      jmp	DiskDirLoop	;do next entry
    192  0e91		       4c eb 02    DiskDirEnd jmp	NextIL
    193  0e94					      endif
    194  0e94							;
    195  0e94							;=====================================================
    196  0e94							; Does a LIST to a Disk file.
    197  0e94							;
    198  0e94				   iDLIST
    199  0e94					      if	XKIM || CTMON65
    200  0e94		       20 cf 0e 	      jsr	SetOutDisk
    201  0e97		       4c 22 06 	      jmp	iLST2
    202  0e9a					      endif
    203  0e9a							;
    204  0e9a							;=====================================================
    205  0e9a							; Closes any pending disk file.  Okay to call if there
    206  0e9a							; is no open file.
    207  0e9a							;
    208  0e9a				   iDCLOSE
    209  0e9a					      if	XKIM || CTMON65
    210  0e9a		       20 42 f0 	      jsr	DiskClose
    211  0e9d		       4c eb 02 	      jmp	NextIL
    212  0ea0					      endif
    213  0ea0							;
    214  0ea0							;=====================================================
    215  0ea0							; This gets the next byte from an open disk file.  If
    216  0ea0							; there are no more bytes left, this returns C set.
    217  0ea0							; Else, C is clear and A contains the character.
    218  0ea0							;
    219  0ea0				   getNextFileByte
    220  0ea0					      if	XKIM || CTMON65
    221  0ea0		       ae 8f df 	      ldx	diskBufOffset
    222  0ea3		       ec 8e df 	      cpx	diskBufLength
    223  0ea6		       d0 14		      bne	hasdata	;branch if still data
    224  0ea8							;
    225  0ea8							; There is no data left in the buffer, so read a
    226  0ea8							; block from the SD system.
    227  0ea8							;
    228  0ea8		       a9 84		      lda	#BUFFER_SIZE
    229  0eaa		       a2 df		      ldx	#buffer>>8
    230  0eac		       a0 0a		      ldy	#buffer&$ff
    231  0eae		       20 3c f0 	      jsr	DiskRead
    232  0eb1		       b0 12		      bcs	getNextEof
    233  0eb3							;
    234  0eb3							; A contains the number of bytes actually read.
    235  0eb3							;
    236  0eb3		       8d 8e df 	      sta	diskBufLength	;save length
    237  0eb6		       c9 00		      cmp	#0	;shouldn't happen
    238  0eb8		       f0 0b		      beq	getNextEof
    239  0eba							;
    240  0eba		       a2 00		      ldx	#0
    241  0ebc		       bd 0a df    hasdata    lda	buffer,x
    242  0ebf		       e8		      inx
    243  0ec0		       8e 8f df 	      stx	diskBufOffset
    244  0ec3		       18		      clc
    245  0ec4		       60		      rts
    246  0ec5							;
    247  0ec5		       a9 00	   getNextEof lda	#0
    248  0ec7		       8d 8f df 	      sta	diskBufOffset
    249  0eca		       8d 8e df 	      sta	diskBufLength
    250  0ecd		       38		      sec
    251  0ece		       60		      rts
    252  0ecf							;
    253  0ecf							;=====================================================
    254  0ecf							; Set output vector to the disk output function
    255  0ecf							;
    256  0ecf		       a9 da	   SetOutDisk lda	#DOUT&$ff
    257  0ed1		       8d 4a 12 	      sta	BOutVec
    258  0ed4		       a9 0e		      lda	#DOUT/256
    259  0ed6		       8d 4b 12 	      sta	BOutVec+1
    260  0ed9		       60		      rts
    261  0eda							;
    262  0eda							;=====================================================
    263  0eda
    264  0eda		       8d 0a df    DOUT       sta	buffer
    265  0edd		       a9 01		      lda	#1
    266  0edf		       a0 0a		      ldy	#buffer&$ff
    267  0ee1		       a2 df		      ldx	#buffer/256
    268  0ee3		       20 3f f0 	      jsr	DiskWrite
    269  0ee6							;
    270  0ee6							; need error checking here
    271  0ee6							;
    272  0ee6		       60		      rts
    273  0ee7					      endif
    274  0ee7
    275  0ee7
------- FILE mytb.asm
   1655  0ee7					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  0ee7					      include	"IL.inc"
      1  0ee7
      2  0ee7							;=====================================================
      3  0ee7							; IL.inc
      4  0ee7							; These are macros for IL instructions
      5  0ee7							;
      6  0ee7					      mac	dw
      7  0ee7					      .word	{0}
      8  0ee7					      endm
      9  0ee7					      mac	db
     10  0ee7					      .byte	{0}
     11  0ee7					      endm
     12  0ee7					      macro	xinit
     13  0ee7					      db	0
     14  0ee7					      endm		;reset the il to start clear all
     15  0ee7							;
     16  0ee7					      macro	done
     17  0ee7					      db	1
     18  0ee7					      endm		;print an error if not end of line
     19  0ee7							;
     20  0ee7					      macro	prs
     21  0ee7					      db	2
     22  0ee7					      endm		;print a quoted string
     23  0ee7							;
     24  0ee7					      macro	prn
     25  0ee7					      db	3
     26  0ee7					      endm		;print a number
     27  0ee7							;
     28  0ee7					      macro	spc
     29  0ee7					      db	4
     30  0ee7					      endm		;print space til new tabstop
     31  0ee7							;
     32  0ee7					      macro	nline
     33  0ee7					      db	5
     34  0ee7					      endm		;print a new line crlf
     35  0ee7							;
     36  0ee7							; My NXT is a bit different in that it takes one
     37  0ee7							; parameter, which is an address.  If the BASIC
     38  0ee7							; program is currently running then move to the
     39  0ee7							; next line and continue execution.  However, if
     40  0ee7							; in direct mode, jump to the specified IL label.
     41  0ee7							;
     42  0ee7					      macro	nxt
     43  0ee7					      db	6
     44  0ee7					      dw	{1}	; addr
     45  0ee7					      endm		; addr
     46  0ee7							;
     47  0ee7					      macro	xfer
     48  0ee7					      db	7
     49  0ee7					      endm
     50  0ee7							;
     51  0ee7					      macro	sav
     52  0ee7					      db	8
     53  0ee7					      endm
     54  0ee7							;
     55  0ee7					      macro	rstr
     56  0ee7					      db	9
     57  0ee7					      endm
     58  0ee7							;
     59  0ee7					      macro	cmpr
     60  0ee7					      db	10
     61  0ee7					      endm
     62  0ee7							;
     63  0ee7					      macro	innum
     64  0ee7					      db	11
     65  0ee7					      endm
     66  0ee7							;
     67  0ee7					      macro	fin
     68  0ee7					      db	12
     69  0ee7					      endm
     70  0ee7							;
     71  0ee7							; ERR is followed by an error number.	The error
     72  0ee7							; code is printed along with the line number.
     73  0ee7							; Control is passed to the statement set with
     74  0ee7							; the ERRGOTO statement.
     75  0ee7							;
     76  0ee7					      macro	errmsg
     77  0ee7					      db	13
     78  0ee7					      dw	{1}	;ecode
     79  0ee7					      endm		;ecode
     80  0ee7							;
     81  0ee7					      macro	add
     82  0ee7					      db	14
     83  0ee7					      endm
     84  0ee7							;
     85  0ee7					      macro	sub
     86  0ee7					      db	15
     87  0ee7					      endm
     88  0ee7							;
     89  0ee7					      macro	neg
     90  0ee7					      db	16
     91  0ee7					      endm
     92  0ee7							;
     93  0ee7					      macro	mul
     94  0ee7					      db	17
     95  0ee7					      endm
     96  0ee7							;
     97  0ee7					      macro	div
     98  0ee7					      db	18
     99  0ee7					      endm
    100  0ee7							;
    101  0ee7					      macro	store
    102  0ee7					      db	19
    103  0ee7					      endm
    104  0ee7							;
    105  0ee7					      macro	ind
    106  0ee7					      db	20
    107  0ee7					      endm
    108  0ee7							;
    109  0ee7					      macro	lst
    110  0ee7					      db	21
    111  0ee7					      endm
    112  0ee7							;
    113  0ee7					      macro	init
    114  0ee7					      db	22
    115  0ee7					      endm
    116  0ee7							;
    117  0ee7					      macro	getline
    118  0ee7					      db	23
    119  0ee7					      endm
    120  0ee7							;
    121  0ee7					      macro	insert
    122  0ee7					      db	24
    123  0ee7					      endm
    124  0ee7							;
    125  0ee7					      macro	rtn
    126  0ee7					      db	25
    127  0ee7					      endm
    128  0ee7							;
    129  0ee7					      macro	exit
    130  0ee7					      db	26
    131  0ee7					      endm
    132  0ee7							;
    133  0ee7					      macro	lit
    134  0ee7					      db	27
    135  0ee7					      dw	{1}	;value
    136  0ee7					      endm		; value LIT
    137  0ee7							;
    138  0ee7					      macro	call
    139  0ee7					      db	28
    140  0ee7					      dw	{1}	;addr
    141  0ee7					      endm		;addr
    142  0ee7							;
    143  0ee7							; IJMP will set the IL PC to the specified value.
    144  0ee7							;
    145  0ee7					      macro	ijmp
    146  0ee7					      db	29
    147  0ee7					      dw	{1}	;addr
    148  0ee7					      endm		;addr
    149  0ee7							;
    150  0ee7					      macro	vinit
    151  0ee7					      db	30
    152  0ee7					      endm
    153  0ee7							;
    154  0ee7							; ERRGOTO sets the point in the code where the IL
    155  0ee7							; interpreter will go after any error.
    156  0ee7							;
    157  0ee7					      macro	errgoto
    158  0ee7					      db	31
    159  0ee7					      dw	{1}	;addr
    160  0ee7					      endm		;addr
    161  0ee7							;
    162  0ee7					      macro	tst
    163  0ee7					      db	32
    164  0ee7					      db	({1}-*)-1	;(addr-*)-1
    165  0ee7					      db	{2},0	;string,0
    166  0ee7					      endm		;addr,string
    167  0ee7							;
    168  0ee7					      macro	tstv
    169  0ee7					      db	33
    170  0ee7					      db	({1}-*)-1	;(addr-*)-1
    171  0ee7					      endm		;addr
    172  0ee7							;
    173  0ee7					      macro	tstl
    174  0ee7					      db	34
    175  0ee7					      db	({1}-*)-1	;(addr-*)-1
    176  0ee7					      endm		;addr
    177  0ee7							;
    178  0ee7					      macro	tstn
    179  0ee7					      db	35
    180  0ee7					      db	({1}-*)-1	;(addr-*)-1
    181  0ee7					      endm		;addr
    182  0ee7							;
    183  0ee7							; FREE returns the amount of free RAM on top of
    184  0ee7							; the stack.  This is the amount of room the user
    185  0ee7							; program has available.
    186  0ee7							;
    187  0ee7					      macro	free
    188  0ee7					      db	36
    189  0ee7					      endm
    190  0ee7							;
    191  0ee7							; RANDOM takes the top item off the stack and
    192  0ee7							; replaces it with a random number that is
    193  0ee7							; MOD the initial value.  Ie, if the TOS is
    194  0ee7							; 42 then RANDOM returns a value from 0 to 41.
    195  0ee7							;
    196  0ee7					      macro	random
    197  0ee7					      db	37
    198  0ee7					      endm
    199  0ee7							;
    200  0ee7							; ABS will replace the top of stack with the
    201  0ee7							; absolute value.
    202  0ee7							;
    203  0ee7					      macro	abs
    204  0ee7					      db	38
    205  0ee7					      endm
    206  0ee7							;
    207  0ee7							; OPENREAD opens a file for reading, as in getting
    208  0ee7							; statements from it.
    209  0ee7							;
    210  0ee7					      macro	openread
    211  0ee7					      db	39
    212  0ee7					      endm
    213  0ee7							;
    214  0ee7							; OPENWRITE opens a file for writing, as in saving
    215  0ee7							; the current program to it.
    216  0ee7							;
    217  0ee7					      macro	openwrite
    218  0ee7					      db	40
    219  0ee7					      endm
    220  0ee7							;
    221  0ee7							; DCLOSE closes any open disk file.
    222  0ee7							;
    223  0ee7					      macro	dclose
    224  0ee7					      db	41
    225  0ee7					      endm
    226  0ee7							;
    227  0ee7							; DGETLINE gets one line from the disk file and puts it
    228  0ee7							; into LINBUFF.
    229  0ee7							;
    230  0ee7					      macro	dgetline
    231  0ee7					      db	42
    232  0ee7					      endm
    233  0ee7							;
    234  0ee7							; DLIST saves the program to an open disk file.
    235  0ee7							;
    236  0ee7					      macro	dlist
    237  0ee7					      db	43
    238  0ee7					      endm
    239  0ee7							; DDIR list the current directory
    240  0ee7							;
    241  0ee7					      macro	ddir
    242  0ee7					      db	44
    243  0ee7					      endm
    244  0ee7
    245  0ee7							; RMFILE remove a fle from disk
    246  0ee7					      macro	rmfile
    247  0ee7					      db	45
    248  0ee7					      endm
    249  0ee7
    250  0ee7							; CLEARSCREEN clear the screen
    251  0ee7					      macro	clearscreen
    252  0ee7					      db	46
    253  0ee7					      endm
    254  0ee7							; POKEMEM Poke value into memory
    255  0ee7					      macro	pokemem
    256  0ee7					      db	47
    257  0ee7					      endm
    258  0ee7							; PEEKMEM peek at value in memory
    259  0ee7					      macro	peekmem
    260  0ee7					      db	48
    261  0ee7					      endm
    262  0ee7							; TSTLET Test if the statement is a let without the keyword let
    263  0ee7					      macro	tstlet
    264  0ee7					      db	49
    265  0ee7					      db	({1}-*)-1	;(addr-*)-1
    266  0ee7					      endm		;addr
    267  0ee7							; TSTDONE if we reach the end of a statement
    268  0ee7					      macro	tstdone
    269  0ee7					      db	50
    270  0ee7					      db	({1}-*)-1	;(addr-*)-1
    271  0ee7					      endm		;addr
    272  0ee7							; GETCHAR	get a character from the input line leave it in RO
    273  0ee7					      macro	getchar
    274  0ee7					      db	51
    275  0ee7					      endm
    276  0ee7							; PUTCHAR	Put a character to the terminal
    277  0ee7					      macro	putchar
    278  0ee7					      db	52
    279  0ee7					      endm
    280  0ee7							; Call		Call a machine function return a to stack
    281  0ee7					      macro	callfunc
    282  0ee7					      db	53
    283  0ee7					      endm
    284  0ee7							; Call		Call a machine function return a to stack
    285  0ee7					      macro	callfunc2
    286  0ee7					      db	54
    287  0ee7					      endm
    288  0ee7							; TSTSTR	 Tests for the open quote in a string
    289  0ee7					      macro	tststr
    290  0ee7					      db	55
    291  0ee7					      db	({1}-*)-1	;(addr-*)-1
    292  0ee7					      endm
    293  0ee7							; SETIRQ	Sets the line number to run when an irq happens irq 550
    294  0ee7					      macro	setirq
    295  0ee7					      db	56
    296  0ee7					      endm
    297  0ee7
    298  0ee7							; TSTIRQ	Test for irq pending,
    299  0ee7							;		if so push the IRQ LINE NUMBER into RO, onto stack
    300  0ee7					      macro	tstirq
    301  0ee7					      db	57
    302  0ee7					      db	({1}-*)-1	;(addr-*)-1
    303  0ee7					      endm
    304  0ee7
    305  0ee7							; IRET    return from interupt service
    306  0ee7					      macro	iret
    307  0ee7					      db	58
    308  0ee7					      endm
    309  0ee7
------- FILE mytb.asm
   1657  0ee7							;
   1658  0ee7				  -	      if	FIXED
   1659  0ee7				  -	      org	$1000
   1660  0ee7					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  0ee7					      include	"basic.il"
      1  0ee7							;LET
      2  0ee7							;=====================================================
      3  0ee7							;=====================================================
      4  0ee7							;=====================================================
      5  0ee7							; This is the IL of the BASIC (or whatever) language.
      6  0ee7							; Because of the way macros are implemented by as65,
      7  0ee7							; labels can't be on the same line as a macro
      8  0ee7							; invocation, so that's why labels are on separate
      9  0ee7							; lines.
     10  0ee7							;
     11  0ee7		       0e e7	   IL	      equ	*
     12  0ee7
     13  0ee7							;THE IL CONTROL SECTION
     14  0ee7
     15  0ee7				   START
      0  0ee7					      INIT		;INITIALIZE
      0  0ee7					      db	22
      1  0ee7		       16		      .byte.b	22
      0  0ee8					      NLINE		;WRITE CRLF
      0  0ee8					      db	5
      1  0ee8		       05		      .byte.b	5
      0  0ee9					      ERRGOTO	CO	;where to go after an error
      0  0ee9					      db	31
      1  0ee9		       1f		      .byte.b	31
      0  0eea					      dw	CO
      1  0eea		       ed 0e		      .word.w	CO
      0  0eec					      VINIT		;clear all variables
      0  0eec					      db	30
      1  0eec		       1e		      .byte.b	30
     20  0eed							;
     21  0eed							; This is where we jump to get a line of commands or
     22  0eed							; a program from the user.
     23  0eed							;
     24  0eed				   CO
      0  0eed					      GETLINE		;WRITE PROMPT AND GET LINE
      0  0eed					      db	23
      1  0eed		       17		      .byte.b	23
      0  0eee					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  0eee					      db	34
      1  0eee		       22		      .byte.b	34
      0  0eef					      db	(XEC-*)-1
      1  0eef		       04		      .byte.b	(XEC-*)-1
      0  0ef0					      INSERT		;INSERT IT (MAY BE DELETE)
      0  0ef0					      db	24
      1  0ef0		       18		      .byte.b	24
      0  0ef1					      IJMP	CO
      0  0ef1					      db	29
      1  0ef1		       1d		      .byte.b	29
      0  0ef2					      dw	CO
      1  0ef2		       ed 0e		      .word.w	CO
     29  0ef4				   XEC
      0  0ef4					      XINIT		;INITIALIZE
      0  0ef4					      db	0
      1  0ef4		       00		      .byte.b	0
     31  0ef5
     32  0ef5							;STATEMENT EXECUTOR
     33  0ef5				   STMT
      0  0ef5					      TSTIRQ	notirq	;if it is an irq set, this will cause transfer to irq handler
      0  0ef5					      db	57
      1  0ef5		       39		      .byte.b	57
      0  0ef6					      db	(notirq-*)-1
      1  0ef6		       00		      .byte.b	(notirq-*)-1
     35  0ef7				   notirq
      0  0ef7					      TSTLET	LET	;Test if second field is =
      0  0ef7					      db	49
      1  0ef7		       31		      .byte.b	49
      0  0ef8					      db	(LET-*)-1
      1  0ef8		       03		      .byte.b	(LET-*)-1
      0  0ef9					      IJMP	DOLET	;allow the default to be let
      0  0ef9					      db	29
      1  0ef9		       1d		      .byte.b	29
      0  0efa					      dw	DOLET
      1  0efa		       02 0f		      .word.w	DOLET
     38  0efc				   LET
      0  0efc					      TST	S1,"LET"	;IS STATEMENT A LET
      0  0efc					      db	32
      1  0efc		       20		      .byte.b	32
      0  0efd					      db	(S1-*)-1
      1  0efd		       15		      .byte.b	(S1-*)-1
      0  0efe					      db	"LET",0
      1  0efe		       4c 45 54 00	      .byte.b	"LET",0
     40  0f02				   DOLET
      0  0f02					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  0f02					      db	33
      1  0f02		       21		      .byte.b	33
      0  0f03					      db	(ERRVEC-*)-1
      1  0f03		       92		      .byte.b	(ERRVEC-*)-1
      0  0f04					      TST	ERRVEC,"="	;(This line originally omitted)
      0  0f04					      db	32
      1  0f04		       20		      .byte.b	32
      0  0f05					      db	(ERRVEC-*)-1
      1  0f05		       90		      .byte.b	(ERRVEC-*)-1
      0  0f06					      db	"=",0
      1  0f06		       3d 00		      .byte.b	"=",0
      0  0f08					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  0f08					      db	28
      1  0f08		       1c		      .byte.b	28
      0  0f09					      dw	EXPR
      1  0f09		       95 10		      .word.w	EXPR
      0  0f0b					      DONE		;REPORT ERROR IF NOT NEXT
      0  0f0b					      db	1
      1  0f0b		       01		      .byte.b	1
      0  0f0c					      STORE		;STORE RESULT
      0  0f0c					      db	19
      1  0f0c		       13		      .byte.b	19
      0  0f0d					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0f0d					      db	6
      1  0f0d		       06		      .byte.b	6
      0  0f0e					      dw	CO
      1  0f0e		       ed 0e		      .word.w	CO
      0  0f10					      IJMP	STMT
      0  0f10					      db	29
      1  0f10		       1d		      .byte.b	29
      0  0f11					      dw	STMT
      1  0f11		       f5 0e		      .word.w	STMT
     48  0f13				   S1
      0  0f13					      TST	S1S1,"IRET"	;test return from interupt
      0  0f13					      db	32
      1  0f13		       20		      .byte.b	32
      0  0f14					      db	(S1S1-*)-1
      1  0f14		       10		      .byte.b	(S1S1-*)-1
      0  0f15					      db	"IRET",0
      1  0f15		       49 52 45 54*	      .byte.b	"IRET",0
      0  0f1a					      TST	S1Sa,"URN"
      0  0f1a					      db	32
      1  0f1a		       20		      .byte.b	32
      0  0f1b					      db	(S1Sa-*)-1
      1  0f1b		       04		      .byte.b	(S1Sa-*)-1
      0  0f1c					      db	"URN",0
      1  0f1c		       55 52 4e 00	      .byte.b	"URN",0
     51  0f20				   S1Sa
      0  0f20					      DONE		;Must be only thing on the line
      0  0f20					      db	1
      1  0f20		       01		      .byte.b	1
      0  0f21					      IRET		;RESTORE LINE NUMBER OF CALL
      0  0f21					      db	58
      1  0f21		       3a		      .byte.b	58
      0  0f22					      IJMP	STMT
      0  0f22					      db	29
      1  0f22		       1d		      .byte.b	29
      0  0f23					      dw	STMT
      1  0f23		       f5 0e		      .word.w	STMT
     55  0f25
     56  0f25				   S1S1
      0  0f25					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  0f25					      db	32
      1  0f25		       20		      .byte.b	32
      0  0f26					      db	(S2b-*)-1
      1  0f26		       19		      .byte.b	(S2b-*)-1
      0  0f27					      db	"GO",0
      1  0f27		       47 4f 00 	      .byte.b	"GO",0
      0  0f2a					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  0f2a					      db	32
      1  0f2a		       20		      .byte.b	32
      0  0f2b					      db	(S2-*)-1
      1  0f2b		       08		      .byte.b	(S2-*)-1
      0  0f2c					      db	"TO",0
      1  0f2c		       54 4f 00 	      .byte.b	"TO",0
      0  0f2f					      CALL	EXPR	;GET LABEL
      0  0f2f					      db	28
      1  0f2f		       1c		      .byte.b	28
      0  0f30					      dw	EXPR
      1  0f30		       95 10		      .word.w	EXPR
      0  0f32					      DONE		;ERROR IF CR NOT NEXT
      0  0f32					      db	1
      1  0f32		       01		      .byte.b	1
      0  0f33					      XFER		;SET UP AND JUMP
      0  0f33					      db	7
      1  0f33		       07		      .byte.b	7
     62  0f34				   S2
      0  0f34					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  0f34					      db	32
      1  0f34		       20		      .byte.b	32
      0  0f35					      db	(ERRVEC-*)-1
      1  0f35		       60		      .byte.b	(ERRVEC-*)-1
      0  0f36					      db	"SUB",0
      1  0f36		       53 55 42 00	      .byte.b	"SUB",0
      0  0f3a					      CALL	EXPR	;GET DESTINATION
      0  0f3a					      db	28
      1  0f3a		       1c		      .byte.b	28
      0  0f3b					      dw	EXPR
      1  0f3b		       95 10		      .word.w	EXPR
      0  0f3d					      DONE		;ERROR IF CR NOT NEXT
      0  0f3d					      db	1
      1  0f3d		       01		      .byte.b	1
      0  0f3e					      SAV		;SAVE RETURN LINE
      0  0f3e					      db	8
      1  0f3e		       08		      .byte.b	8
      0  0f3f					      XFER		;AND JUMP
      0  0f3f					      db	7
      1  0f3f		       07		      .byte.b	7
     68  0f40				   S2b
      0  0f40					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  0f40					      db	32
      1  0f40		       20		      .byte.b	32
      0  0f41					      db	(S3-*)-1
      1  0f41		       1f		      .byte.b	(S3-*)-1
      0  0f42					      db	"RE",0
      1  0f42		       52 45 00 	      .byte.b	"RE",0
      0  0f45					      TST	S2a,"T"
      0  0f45					      db	32
      1  0f45		       20		      .byte.b	32
      0  0f46					      db	(S2a-*)-1
      1  0f46		       10		      .byte.b	(S2a-*)-1
      0  0f47					      db	"T",0
      1  0f47		       54 00		      .byte.b	"T",0
      0  0f49					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  0f49					      db	32
      1  0f49		       20		      .byte.b	32
      0  0f4a					      db	(S2aa-*)-1
      1  0f4a		       04		      .byte.b	(S2aa-*)-1
      0  0f4b					      db	"URN",0
      1  0f4b		       55 52 4e 00	      .byte.b	"URN",0
      0  0f4f				   S2aa       DONE		;MUST BE CR
      0  0f4f					      db	1
      1  0f4f		       01		      .byte.b	1
      0  0f50					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  0f50					      db	9
      1  0f50		       09		      .byte.b	9
      0  0f51					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  0f51					      db	6
      1  0f51		       06		      .byte.b	6
      0  0f52					      dw	CO
      1  0f52		       ed 0e		      .word.w	CO
      0  0f54					      IJMP	STMT
      0  0f54					      db	29
      1  0f54		       1d		      .byte.b	29
      0  0f55					      dw	STMT
      1  0f55		       f5 0e		      .word.w	STMT
     76  0f57				   S2a
      0  0f57					      TST	S3,"M"	;REMark.  Skip rest of line
      0  0f57					      db	32
      1  0f57		       20		      .byte.b	32
      0  0f58					      db	(S3-*)-1
      1  0f58		       08		      .byte.b	(S3-*)-1
      0  0f59					      db	"M",0
      1  0f59		       4d 00		      .byte.b	"M",0
      0  0f5b					      NXT	CO
      0  0f5b					      db	6
      1  0f5b		       06		      .byte.b	6
      0  0f5c					      dw	CO
      1  0f5c		       ed 0e		      .word.w	CO
      0  0f5e					      IJMP	STMT
      0  0f5e					      db	29
      1  0f5e		       1d		      .byte.b	29
      0  0f5f					      dw	STMT
      1  0f5f		       f5 0e		      .word.w	STMT
     80  0f61
     81  0f61				   S3
      0  0f61					      TST	S3a,"?"	; ? symonym for print
      0  0f61					      db	32
      1  0f61		       20		      .byte.b	32
      0  0f62					      db	(S3a-*)-1
      1  0f62		       05		      .byte.b	(S3a-*)-1
      0  0f63					      db	"?",0
      1  0f63		       3f 00		      .byte.b	"?",0
      0  0f65					      IJMP	S4
      0  0f65					      db	29
      1  0f65		       1d		      .byte.b	29
      0  0f66					      dw	S4
      1  0f66		       73 0f		      .word.w	S4
     84  0f68				   S3a
      0  0f68					      TST	S8,"PR"	;allow short form of print
      0  0f68					      db	32
      1  0f68		       20		      .byte.b	32
      0  0f69					      db	(S8-*)-1
      1  0f69		       36		      .byte.b	(S8-*)-1
      0  0f6a					      db	"PR",0
      1  0f6a		       50 52 00 	      .byte.b	"PR",0
      0  0f6d					      TST	S4,"INT"	;PRINT
      0  0f6d					      db	32
      1  0f6d		       20		      .byte.b	32
      0  0f6e					      db	(S4-*)-1
      1  0f6e		       04		      .byte.b	(S4-*)-1
      0  0f6f					      db	"INT",0
      1  0f6f		       49 4e 54 00	      .byte.b	"INT",0
     87  0f73				   S4
      0  0f73					      TSTDONE	S4a	;Test if we just want crlf printed
      0  0f73					      db	50
      1  0f73		       32		      .byte.b	50
      0  0f74					      db	(S4a-*)-1
      1  0f74		       03		      .byte.b	(S4a-*)-1
      0  0f75					      IJMP	S6
      0  0f75					      db	29
      1  0f75		       1d		      .byte.b	29
      0  0f76					      dw	S6
      1  0f76		       8e 0f		      .word.w	S6
     90  0f78
      0  0f78				   S4a	      TSTSTR	S7	;TEST FOR QUOTED String
      0  0f78					      db	55
      1  0f78		       37		      .byte.b	55
      0  0f79					      db	(S7-*)-1
      1  0f79		       1f		      .byte.b	(S7-*)-1
      0  0f7a					      PRS		;PRINT STRING
      0  0f7a					      db	2
      1  0f7a		       02		      .byte.b	2
     93  0f7b				   S5
      0  0f7b					      TST	S6A,COMMA	;IS THERE MORE?
      0  0f7b					      db	32
      1  0f7b		       20		      .byte.b	32
      0  0f7c					      db	(S6A-*)-1
      1  0f7c		       08		      .byte.b	(S6A-*)-1
      0  0f7d					      db	COMMA,0
      1  0f7d		       2c 00		      .byte.b	COMMA,0
      0  0f7f					      SPC		;SPACE TO NEXT ZONE
      0  0f7f					      db	4
      1  0f7f		       04		      .byte.b	4
      0  0f80					      TSTDONE	S4	;Not end of line jump back
      0  0f80					      db	50
      1  0f80		       32		      .byte.b	50
      0  0f81					      db	(S4-*)-1
      1  0f81		       f1		      .byte.b	(S4-*)-1
      0  0f82					      IJMP	S6a	;YES JUMP BACK
      0  0f82					      db	29
      1  0f82		       1d		      .byte.b	29
      0  0f83					      dw	S6a
      1  0f83		       90 0f		      .word.w	S6a
     98  0f85							;
     99  0f85							; If a semicolon, don't do anything.
    100  0f85							;
    101  0f85				   S6A
      0  0f85					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  0f85					      db	32
      1  0f85		       20		      .byte.b	32
      0  0f86					      db	(S6-*)-1
      1  0f86		       07		      .byte.b	(S6-*)-1
      0  0f87					      db	SEMICOLON,0
      1  0f87		       3b 00		      .byte.b	SEMICOLON,0
      0  0f89					      TSTDONE	S4	;Jump Back if not end of line
      0  0f89					      db	50
      1  0f89		       32		      .byte.b	50
      0  0f8a					      db	(S4-*)-1
      1  0f8a		       e8		      .byte.b	(S4-*)-1
      0  0f8b					      IJMP	S6a
      0  0f8b					      db	29
      1  0f8b		       1d		      .byte.b	29
      0  0f8c					      dw	S6a
      1  0f8c		       90 0f		      .word.w	S6a
    105  0f8e				   S6
      0  0f8e					      DONE		;ERROR IF CR NOT NEXT
      0  0f8e					      db	1
      1  0f8e		       01		      .byte.b	1
      0  0f8f					      NLINE
      0  0f8f					      db	5
      1  0f8f		       05		      .byte.b	5
      0  0f90				   S6a	      NXT	CO	;exit here if , or ; at end of print
      0  0f90					      db	6
      1  0f90		       06		      .byte.b	6
      0  0f91					      dw	CO
      1  0f91		       ed 0e		      .word.w	CO
      0  0f93					      IJMP	STMT
      0  0f93					      db	29
      1  0f93		       1d		      .byte.b	29
      0  0f94					      dw	STMT
      1  0f94		       f5 0e		      .word.w	STMT
    110  0f96							;
    111  0f96							; A jump for code too far away for relative branch
    112  0f96							;
    113  0f96				   ERRVEC
      0  0f96					      IJMP	UNKNOWN
      0  0f96					      db	29
      1  0f96		       1d		      .byte.b	29
      0  0f97					      dw	UNKNOWN
      1  0f97		       92 10		      .word.w	UNKNOWN
    115  0f99							;
    116  0f99				   S7
      0  0f99					      CALL	EXPR
      0  0f99					      db	28
      1  0f99		       1c		      .byte.b	28
      0  0f9a					      dw	EXPR
      1  0f9a		       95 10		      .word.w	EXPR
      0  0f9c					      PRN		;PRINT IT
      0  0f9c					      db	3
      1  0f9c		       03		      .byte.b	3
      0  0f9d					      IJMP	S5	;IS THERE MORE?
      0  0f9d					      db	29
      1  0f9d		       1d		      .byte.b	29
      0  0f9e					      dw	S5
      1  0f9e		       7b 0f		      .word.w	S5
    120  0fa0				   S8
      0  0fa0					      TST	S8a,"IF"	;IF STATEMENT
      0  0fa0					      db	32
      1  0fa0		       20		      .byte.b	32
      0  0fa1					      db	(S8a-*)-1
      1  0fa1		       17		      .byte.b	(S8a-*)-1
      0  0fa2					      db	"IF",0
      1  0fa2		       49 46 00 	      .byte.b	"IF",0
      0  0fa5					      CALL	EXPR	;GET EXPRESSION
      0  0fa5					      db	28
      1  0fa5		       1c		      .byte.b	28
      0  0fa6					      dw	EXPR
      1  0fa6		       95 10		      .word.w	EXPR
      0  0fa8					      CALL	RELOP	;DETERMINE OPR AND PUT ON STK
      0  0fa8					      db	28
      1  0fa8		       1c		      .byte.b	28
      0  0fa9					      dw	RELOP
      1  0fa9		       5f 11		      .word.w	RELOP
      0  0fab					      CALL	EXPR	;GET EXPRESSION
      0  0fab					      db	28
      1  0fab		       1c		      .byte.b	28
      0  0fac					      dw	EXPR
      1  0fac		       95 10		      .word.w	EXPR
      0  0fae					      TST	S8a1,"THEN"	;(This line originally omitted) not required
      0  0fae					      db	32
      1  0fae		       20		      .byte.b	32
      0  0faf					      db	(S8a1-*)-1
      1  0faf		       05		      .byte.b	(S8a1-*)-1
      0  0fb0					      db	"THEN",0
      1  0fb0		       54 48 45 4e*	      .byte.b	"THEN",0
      0  0fb5				   S8a1       CMPR		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE
      0  0fb5					      db	10
      1  0fb5		       0a		      .byte.b	10
      0  0fb6					      IJMP	STMT
      0  0fb6					      db	29
      1  0fb6		       1d		      .byte.b	29
      0  0fb7					      dw	STMT
      1  0fb7		       f5 0e		      .word.w	STMT
    128  0fb9
    129  0fb9				   S8a
      0  0fb9					      TST	S8b,"POKE("	;Poke a value into memory
      0  0fb9					      db	32
      1  0fb9		       20		      .byte.b	32
      0  0fba					      db	(S8b-*)-1
      1  0fba		       1c		      .byte.b	(S8b-*)-1
      0  0fbb					      db	"POKE(",0
      1  0fbb		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  0fc1					      CALL	EXPR	;Get address to write to
      0  0fc1					      db	28
      1  0fc1		       1c		      .byte.b	28
      0  0fc2					      dw	EXPR
      1  0fc2		       95 10		      .word.w	EXPR
      0  0fc4					      TST	UNKNOWN,COMMA	;Must have a coma
      0  0fc4					      db	32
      1  0fc4		       20		      .byte.b	32
      0  0fc5					      db	(UNKNOWN-*)-1
      1  0fc5		       cc		      .byte.b	(UNKNOWN-*)-1
      0  0fc6					      db	COMMA,0
      1  0fc6		       2c 00		      .byte.b	COMMA,0
      0  0fc8					      CALL	EXPR	;Get the value to poke
      0  0fc8					      db	28
      1  0fc8		       1c		      .byte.b	28
      0  0fc9					      dw	EXPR
      1  0fc9		       95 10		      .word.w	EXPR
      0  0fcb					      TST	UNKNOWN,")"
      0  0fcb					      db	32
      1  0fcb		       20		      .byte.b	32
      0  0fcc					      db	(UNKNOWN-*)-1
      1  0fcc		       c5		      .byte.b	(UNKNOWN-*)-1
      0  0fcd					      db	")",0
      1  0fcd		       29 00		      .byte.b	")",0
      0  0fcf					      POKEMEM
      0  0fcf					      db	47
      1  0fcf		       2f		      .byte.b	47
      0  0fd0					      DONE
      0  0fd0					      db	1
      1  0fd0		       01		      .byte.b	1
      0  0fd1					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0fd1					      db	6
      1  0fd1		       06		      .byte.b	6
      0  0fd2					      dw	CO
      1  0fd2		       ed 0e		      .word.w	CO
      0  0fd4					      IJMP	STMT
      0  0fd4					      db	29
      1  0fd4		       1d		      .byte.b	29
      0  0fd5					      dw	STMT
      1  0fd5		       f5 0e		      .word.w	STMT
    139  0fd7
    140  0fd7				   S8b
      0  0fd7					      TST	S8c,"PUTCH("	;Put a char to the terminal
      0  0fd7					      db	32
      1  0fd7		       20		      .byte.b	32
      0  0fd8					      db	(S8c-*)-1
      1  0fd8		       16		      .byte.b	(S8c-*)-1
      0  0fd9					      db	"PUTCH(",0
      1  0fd9		       50 55 54 43*	      .byte.b	"PUTCH(",0
      0  0fe0					      CALL	EXPR
      0  0fe0					      db	28
      1  0fe0		       1c		      .byte.b	28
      0  0fe1					      dw	EXPR
      1  0fe1		       95 10		      .word.w	EXPR
      0  0fe3					      TST	UNKNOWN,")"
      0  0fe3					      db	32
      1  0fe3		       20		      .byte.b	32
      0  0fe4					      db	(UNKNOWN-*)-1
      1  0fe4		       ad		      .byte.b	(UNKNOWN-*)-1
      0  0fe5					      db	")",0
      1  0fe5		       29 00		      .byte.b	")",0
      0  0fe7					      PUTCHAR
      0  0fe7					      db	52
      1  0fe7		       34		      .byte.b	52
      0  0fe8					      DONE
      0  0fe8					      db	1
      1  0fe8		       01		      .byte.b	1
      0  0fe9					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0fe9					      db	6
      1  0fe9		       06		      .byte.b	6
      0  0fea					      dw	CO
      1  0fea		       ed 0e		      .word.w	CO
      0  0fec					      IJMP	STMT
      0  0fec					      db	29
      1  0fec		       1d		      .byte.b	29
      0  0fed					      dw	STMT
      1  0fed		       f5 0e		      .word.w	STMT
    148  0fef				   S8c
      0  0fef					      TST	S9,"CLS"	;Clear the screen
      0  0fef					      db	32
      1  0fef		       20		      .byte.b	32
      0  0ff0					      db	(S9-*)-1
      1  0ff0		       0c		      .byte.b	(S9-*)-1
      0  0ff1					      db	"CLS",0
      1  0ff1		       43 4c 53 00	      .byte.b	"CLS",0
      0  0ff5					      CLEARSCREEN
      0  0ff5					      db	46
      1  0ff5		       2e		      .byte.b	46
      0  0ff6					      DONE
      0  0ff6					      db	1
      1  0ff6		       01		      .byte.b	1
      0  0ff7					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0ff7					      db	6
      1  0ff7		       06		      .byte.b	6
      0  0ff8					      dw	CO
      1  0ff8		       ed 0e		      .word.w	CO
      0  0ffa					      IJMP	STMT
      0  0ffa					      db	29
      1  0ffa		       1d		      .byte.b	29
      0  0ffb					      dw	STMT
      1  0ffb		       f5 0e		      .word.w	STMT
    154  0ffd				   S9
      0  0ffd					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  0ffd					      db	32
      1  0ffd		       20		      .byte.b	32
      0  0ffe					      db	(S13-*)-1
      1  0ffe		       18		      .byte.b	(S13-*)-1
      0  0fff					      db	"INPUT",0
      1  0fff		       49 4e 50 55*	      .byte.b	"INPUT",0
    156  1005				   S10
      0  1005					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1005					      db	33
      1  1005		       21		      .byte.b	33
      0  1006					      db	(UNKNOWN-*)-1
      1  1006		       8b		      .byte.b	(UNKNOWN-*)-1
      0  1007					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1007					      db	11
      1  1007		       0b		      .byte.b	11
      0  1008					      STORE		;STORE IT
      0  1008					      db	19
      1  1008		       13		      .byte.b	19
      0  1009					      TST	S11,COMMA	;IS THERE MORE?
      0  1009					      db	32
      1  1009		       20		      .byte.b	32
      0  100a					      db	(S11-*)-1
      1  100a		       05		      .byte.b	(S11-*)-1
      0  100b					      db	COMMA,0
      1  100b		       2c 00		      .byte.b	COMMA,0
      0  100d					      IJMP	S10	;YES
      0  100d					      db	29
      1  100d		       1d		      .byte.b	29
      0  100e					      dw	S10
      1  100e		       05 10		      .word.w	S10
    162  1010
    163  1010				   S11
      0  1010					      DONE		;MUST BE CR
      0  1010					      db	1
      1  1010		       01		      .byte.b	1
      0  1011					      NXT	CO	;SEQUENCE TO NEXT
      0  1011					      db	6
      1  1011		       06		      .byte.b	6
      0  1012					      dw	CO
      1  1012		       ed 0e		      .word.w	CO
      0  1014					      IJMP	STMT
      0  1014					      db	29
      1  1014		       1d		      .byte.b	29
      0  1015					      dw	STMT
      1  1015		       f5 0e		      .word.w	STMT
    167  1017				   S13
      0  1017					      TST	S14,"END"
      0  1017					      db	32
      1  1017		       20		      .byte.b	32
      0  1018					      db	(S14-*)-1
      1  1018		       05		      .byte.b	(S14-*)-1
      0  1019					      db	"END",0
      1  1019		       45 4e 44 00	      .byte.b	"END",0
      0  101d					      FIN
      0  101d					      db	12
      1  101d		       0c		      .byte.b	12
    170  101e				   S14
      0  101e					      TST	S14S1,"IRQ"	;Check if we are setting IRQ HANDLER
      0  101e					      db	32
      1  101e		       20		      .byte.b	32
      0  101f					      db	(S14S1-*)-1
      1  101f		       0f		      .byte.b	(S14S1-*)-1
      0  1020					      db	"IRQ",0
      1  1020		       49 52 51 00	      .byte.b	"IRQ",0
      0  1024					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1024					      db	28
      1  1024		       1c		      .byte.b	28
      0  1025					      dw	EXPR
      1  1025		       95 10		      .word.w	EXPR
      0  1027					      DONE		;must be CR
      0  1027					      db	1
      1  1027		       01		      .byte.b	1
      0  1028					      SETIRQ		;Set the line number now
      0  1028					      db	56
      1  1028		       38		      .byte.b	56
      0  1029					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1029					      db	6
      1  1029		       06		      .byte.b	6
      0  102a					      dw	CO
      1  102a		       ed 0e		      .word.w	CO
      0  102c					      IJMP	STMT
      0  102c					      db	29
      1  102c		       1d		      .byte.b	29
      0  102d					      dw	STMT
      1  102d		       f5 0e		      .word.w	STMT
    177  102f				   S14S1
      0  102f					      TST	S15,"LIST"	;LIST COMMAND
      0  102f					      db	32
      1  102f		       20		      .byte.b	32
      0  1030					      db	(S15-*)-1
      1  1030		       0a		      .byte.b	(S15-*)-1
      0  1031					      db	"LIST",0
      1  1031		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1036					      DONE
      0  1036					      db	1
      1  1036		       01		      .byte.b	1
      0  1037					      LST
      0  1037					      db	21
      1  1037		       15		      .byte.b	21
      0  1038					      IJMP	CO
      0  1038					      db	29
      1  1038		       1d		      .byte.b	29
      0  1039					      dw	CO
      1  1039		       ed 0e		      .word.w	CO
    182  103b				   S15
      0  103b					      TST	S16,"RUN"	;RUN COMMAND
      0  103b					      db	32
      1  103b		       20		      .byte.b	32
      0  103c					      db	(S16-*)-1
      1  103c		       0d		      .byte.b	(S16-*)-1
      0  103d					      db	"RUN",0
      1  103d		       52 55 4e 00	      .byte.b	"RUN",0
      0  1041					      DONE
      0  1041					      db	1
      1  1041		       01		      .byte.b	1
      0  1042					      VINIT		;clear variables
      0  1042					      db	30
      1  1042		       1e		      .byte.b	30
      0  1043					      LIT	1	;GOTO line 1
      0  1043					      db	27
      1  1043		       1b		      .byte.b	27
      0  1044					      dw	1
      1  1044		       01 00		      .word.w	1
      0  1046					      XFER		;Bob's addition
      0  1046					      db	7
      1  1046		       07		      .byte.b	7
    188  1047							; EXIT
      0  1047					      IJMP	STMT	;and run!
      0  1047					      db	29
      1  1047		       1d		      .byte.b	29
      0  1048					      dw	STMT
      1  1048		       f5 0e		      .word.w	STMT
    190  104a				   S16
      0  104a					      TST	S17A,"NEW"	;clear program
      0  104a					      db	32
      1  104a		       20		      .byte.b	32
      0  104b					      db	(S17A-*)-1
      1  104b		       08		      .byte.b	(S17A-*)-1
      0  104c					      db	"NEW",0
      1  104c		       4e 45 57 00	      .byte.b	"NEW",0
      0  1050					      DONE
      0  1050					      db	1
      1  1050		       01		      .byte.b	1
      0  1051					      IJMP	START
      0  1051					      db	29
      1  1051		       1d		      .byte.b	29
      0  1052					      dw	START
      1  1052		       e7 0e		      .word.w	START
    194  1054
    195  1054				   S17A
      0  1054					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1054					      db	32
      1  1054		       20		      .byte.b	32
      0  1055					      db	(S17B-*)-1
      1  1055		       06		      .byte.b	(S17B-*)-1
      0  1056					      db	"EXIT",0
      1  1056		       45 58 49 54*	      .byte.b	"EXIT",0
      0  105b					      EXIT
      0  105b					      db	26
      1  105b		       1a		      .byte.b	26
    198  105c
    199  105c							;
    200  105c							; Commands related to saving/restoring programs
    201  105c							; to/from mass storage.
    202  105c							;
    203  105c				   S17B
    204  105c					      if	(XKIM || CTMON65) && DISK_ACCESS
    205  105c
      0  105c					      TST	S17C,"SAVE"
      0  105c					      db	32
      1  105c		       20		      .byte.b	32
      0  105d					      db	(S17C-*)-1
      1  105d		       0b		      .byte.b	(S17C-*)-1
      0  105e					      db	"SAVE",0
      1  105e		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1063					      OPENWRITE
      0  1063					      db	40
      1  1063		       28		      .byte.b	40
      0  1064					      DLIST
      0  1064					      db	43
      1  1064		       2b		      .byte.b	43
      0  1065					      DCLOSE
      0  1065					      db	41
      1  1065		       29		      .byte.b	41
      0  1066					      IJMP	CO
      0  1066					      db	29
      1  1066		       1d		      .byte.b	29
      0  1067					      dw	CO
      1  1067		       ed 0e		      .word.w	CO
    211  1069
    212  1069				   S17C
      0  1069					      TST	S18,"LOAD"
      0  1069					      db	32
      1  1069		       20		      .byte.b	32
      0  106a					      db	(S18-*)-1
      1  106a		       11		      .byte.b	(S18-*)-1
      0  106b					      db	"LOAD",0
      1  106b		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1070					      OPENREAD
      0  1070					      db	39
      1  1070		       27		      .byte.b	39
    215  1071				   S17CLP
      0  1071					      DGETLINE		;get line from file
      0  1071					      db	42
      1  1071		       2a		      .byte.b	42
      0  1072					      TSTL	S17EOL	;no line num means EOL
      0  1072					      db	34
      1  1072		       22		      .byte.b	34
      0  1073					      db	(S17EOL-*)-1
      1  1073		       04		      .byte.b	(S17EOL-*)-1
      0  1074					      INSERT		;put it into the program
      0  1074					      db	24
      1  1074		       18		      .byte.b	24
      0  1075					      IJMP	S17CLP	;keep going
      0  1075					      db	29
      1  1075		       1d		      .byte.b	29
      0  1076					      dw	S17CLP
      1  1076		       71 10		      .word.w	S17CLP
    220  1078				   S17EOL
      0  1078					      DCLOSE		;close disk file
      0  1078					      db	41
      1  1078		       29		      .byte.b	41
      0  1079					      IJMP	CO	;back to start
      0  1079					      db	29
      1  1079		       1d		      .byte.b	29
      0  107a					      dw	CO
      1  107a		       ed 0e		      .word.w	CO
    223  107c
      0  107c				   S18	      TST	S19,"DIR"
      0  107c					      db	32
      1  107c		       20		      .byte.b	32
      0  107d					      db	(S19-*)-1
      1  107d		       08		      .byte.b	(S19-*)-1
      0  107e					      db	"DIR",0
      1  107e		       44 49 52 00	      .byte.b	"DIR",0
      0  1082					      DDIR		;Display the directory content
      0  1082					      db	44
      1  1082		       2c		      .byte.b	44
      0  1083					      IJMP	CO
      0  1083					      db	29
      1  1083		       1d		      .byte.b	29
      0  1084					      dw	CO
      1  1084		       ed 0e		      .word.w	CO
    227  1086					      endif
    228  1086
      0  1086				   S19	      TST	UNKNOWN,"ERASE"
      0  1086					      db	32
      1  1086		       20		      .byte.b	32
      0  1087					      db	(UNKNOWN-*)-1
      1  1087		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1088					      db	"ERASE",0
      1  1088		       45 52 41 53*	      .byte.b	"ERASE",0
      0  108e					      RMFILE		;Erase the file from the disk
      0  108e					      db	45
      1  108e		       2d		      .byte.b	45
      0  108f					      IJMP	CO
      0  108f					      db	29
      1  108f		       1d		      .byte.b	29
      0  1090					      dw	CO
      1  1090		       ed 0e		      .word.w	CO
    232  1090					      endif
    233  1092
    234  1092							;
    235  1092							; Else, unknown command.
    236  1092							;
    237  1092				   UNKNOWN
      0  1092					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1092					      db	13
      1  1092		       0d		      .byte.b	13
      0  1093					      dw	ERR_SYNTAX
      1  1093		       05 00		      .word.w	ERR_SYNTAX
    239  1095
    240  1095							;-----------------------------------------------------
    241  1095				   EXPR
      0  1095					      TST	E0,"-"
      0  1095					      db	32
      1  1095		       20		      .byte.b	32
      0  1096					      db	(E0-*)-1
      1  1096		       09		      .byte.b	(E0-*)-1
      0  1097					      db	"-",0
      1  1097		       2d 00		      .byte.b	"-",0
      0  1099					      CALL	TERM	;TEST FOR UNARY -.
      0  1099					      db	28
      1  1099		       1c		      .byte.b	28
      0  109a					      dw	TERM
      1  109a		       be 10		      .word.w	TERM
      0  109c					      NEG		;GET VALUE
      0  109c					      db	16
      1  109c		       10		      .byte.b	16
      0  109d					      IJMP	E1	;NEGATE IT
      0  109d					      db	29
      1  109d		       1d		      .byte.b	29
      0  109e					      dw	E1
      1  109e		       a7 10		      .word.w	E1
    246  10a0				   E0
      0  10a0					      TST	E1A,"+"	;LOOK FOR MORE
      0  10a0					      db	32
      1  10a0		       20		      .byte.b	32
      0  10a1					      db	(E1A-*)-1
      1  10a1		       02		      .byte.b	(E1A-*)-1
      0  10a2					      db	"+",0
      1  10a2		       2b 00		      .byte.b	"+",0
    248  10a4				   E1A
      0  10a4					      CALL	TERM	;TEST FOR UNARY +
      0  10a4					      db	28
      1  10a4		       1c		      .byte.b	28
      0  10a5					      dw	TERM
      1  10a5		       be 10		      .word.w	TERM
    250  10a7				   E1
      0  10a7					      TST	E2,"+"	;LEADING TERM
      0  10a7					      db	32
      1  10a7		       20		      .byte.b	32
      0  10a8					      db	(E2-*)-1
      1  10a8		       09		      .byte.b	(E2-*)-1
      0  10a9					      db	"+",0
      1  10a9		       2b 00		      .byte.b	"+",0
      0  10ab					      CALL	TERM
      0  10ab					      db	28
      1  10ab		       1c		      .byte.b	28
      0  10ac					      dw	TERM
      1  10ac		       be 10		      .word.w	TERM
      0  10ae					      ADD
      0  10ae					      db	14
      1  10ae		       0e		      .byte.b	14
      0  10af					      IJMP	E1
      0  10af					      db	29
      1  10af		       1d		      .byte.b	29
      0  10b0					      dw	E1
      1  10b0		       a7 10		      .word.w	E1
    255  10b2				   E2
      0  10b2					      TST	E3,"-"	;ANY MORE?
      0  10b2					      db	32
      1  10b2		       20		      .byte.b	32
      0  10b3					      db	(E3-*)-1
      1  10b3		       09		      .byte.b	(E3-*)-1
      0  10b4					      db	"-",0
      1  10b4		       2d 00		      .byte.b	"-",0
      0  10b6					      CALL	TERM	;DIFFERENCE TERM
      0  10b6					      db	28
      1  10b6		       1c		      .byte.b	28
      0  10b7					      dw	TERM
      1  10b7		       be 10		      .word.w	TERM
      0  10b9					      SUB
      0  10b9					      db	15
      1  10b9		       0f		      .byte.b	15
      0  10ba					      IJMP	E1
      0  10ba					      db	29
      1  10ba		       1d		      .byte.b	29
      0  10bb					      dw	E1
      1  10bb		       a7 10		      .word.w	E1
    260  10bd				   E3
    261  10bd				   T2
      0  10bd					      RTN		;ANY MORE?
      0  10bd					      db	25
      1  10bd		       19		      .byte.b	25
    263  10be				   TERM
      0  10be					      CALL	FACT
      0  10be					      db	28
      1  10be		       1c		      .byte.b	28
      0  10bf					      dw	FACT
      1  10bf		       da 10		      .word.w	FACT
    265  10c1				   T0
      0  10c1					      TST	T1,"*"
      0  10c1					      db	32
      1  10c1		       20		      .byte.b	32
      0  10c2					      db	(T1-*)-1
      1  10c2		       09		      .byte.b	(T1-*)-1
      0  10c3					      db	"*",0
      1  10c3		       2a 00		      .byte.b	"*",0
      0  10c5					      CALL	FACT	;PRODUCT FACTOR.
      0  10c5					      db	28
      1  10c5		       1c		      .byte.b	28
      0  10c6					      dw	FACT
      1  10c6		       da 10		      .word.w	FACT
      0  10c8					      MUL
      0  10c8					      db	17
      1  10c8		       11		      .byte.b	17
      0  10c9					      IJMP	T0
      0  10c9					      db	29
      1  10c9		       1d		      .byte.b	29
      0  10ca					      dw	T0
      1  10ca		       c1 10		      .word.w	T0
    270  10cc				   T1
      0  10cc					      TST	T2,"/"
      0  10cc					      db	32
      1  10cc		       20		      .byte.b	32
      0  10cd					      db	(T2-*)-1
      1  10cd		       ef		      .byte.b	(T2-*)-1
      0  10ce					      db	"/",0
      1  10ce		       2f 00		      .byte.b	"/",0
      0  10d0					      CALL	FACT	;QUOTIENT FACTOR.
      0  10d0					      db	28
      1  10d0		       1c		      .byte.b	28
      0  10d1					      dw	FACT
      1  10d1		       da 10		      .word.w	FACT
      0  10d3					      DIV
      0  10d3					      db	18
      1  10d3		       12		      .byte.b	18
      0  10d4					      IJMP	T0
      0  10d4					      db	29
      1  10d4		       1d		      .byte.b	29
      0  10d5					      dw	T0
      1  10d5		       c1 10		      .word.w	T0
    275  10d7
    276  10d7				   UNKNOWNVEC
      0  10d7					      IJMP	UNKNOWN
      0  10d7					      db	29
      1  10d7		       1d		      .byte.b	29
      0  10d8					      dw	UNKNOWN
      1  10d8		       92 10		      .word.w	UNKNOWN
    278  10da
    279  10da							;
    280  10da							; Factor an expression.  Always test for functions
    281  10da							; first or else they'll be confused for variables.
    282  10da							;
    283  10da				   FACT
      0  10da					      TST	F1A,"FREE()"
      0  10da					      db	32
      1  10da		       20		      .byte.b	32
      0  10db					      db	(F1A-*)-1
      1  10db		       09		      .byte.b	(F1A-*)-1
      0  10dc					      db	"FREE()",0
      1  10dc		       46 52 45 45*	      .byte.b	"FREE()",0
      0  10e3					      FREE
      0  10e3					      db	36
      1  10e3		       24		      .byte.b	36
      0  10e4					      RTN
      0  10e4					      db	25
      1  10e4		       19		      .byte.b	25
    287  10e5				   F1A
      0  10e5					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  10e5					      db	32
      1  10e5		       20		      .byte.b	32
      0  10e6					      db	(F1A2-*)-1
      1  10e6		       0a		      .byte.b	(F1A2-*)-1
      0  10e7					      db	"GETCH()",0
      1  10e7		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  10ef					      GETCHAR
      0  10ef					      db	51
      1  10ef		       33		      .byte.b	51
      0  10f0					      RTN
      0  10f0					      db	25
      1  10f0		       19		      .byte.b	25
    291  10f1				   F1A2
      0  10f1					      TST	F2A,"PEEK("	;Return a value from memory
      0  10f1					      db	32
      1  10f1		       20		      .byte.b	32
      0  10f2					      db	(F2A-*)-1
      1  10f2		       0f		      .byte.b	(F2A-*)-1
      0  10f3					      db	"PEEK(",0
      1  10f3		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  10f9					      CALL	EXPR	;Get the address to write to
      0  10f9					      db	28
      1  10f9		       1c		      .byte.b	28
      0  10fa					      dw	EXPR
      1  10fa		       95 10		      .word.w	EXPR
      0  10fc					      TST	UNKNOWN,")"	;Closing bracket
      0  10fc					      db	32
      1  10fc		       20		      .byte.b	32
      0  10fd					      db	(UNKNOWN-*)-1
      1  10fd		       94		      .byte.b	(UNKNOWN-*)-1
      0  10fe					      db	")",0
      1  10fe		       29 00		      .byte.b	")",0
      0  1100					      PEEKMEM
      0  1100					      db	48
      1  1100		       30		      .byte.b	48
      0  1101					      RTN
      0  1101					      db	25
      1  1101		       19		      .byte.b	25
    297  1102							;
    298  1102							; RND() is supposed to have an argument but if none
    299  1102							; was provided, just assume a large value.
    300  1102							;
    301  1102				   F2A
      0  1102					      TST	F2B,"RND("
      0  1102					      db	32
      1  1102		       20		      .byte.b	32
      0  1103					      db	(F2B-*)-1
      1  1103		       17		      .byte.b	(F2B-*)-1
      0  1104					      db	"RND(",0
      1  1104		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1109					      TST	F2A1,")"
      0  1109					      db	32
      1  1109		       20		      .byte.b	32
      0  110a					      db	(F2A1-*)-1
      1  110a		       07		      .byte.b	(F2A1-*)-1
      0  110b					      db	")",0
      1  110b		       29 00		      .byte.b	")",0
      0  110d					      LIT	32766
      0  110d					      db	27
      1  110d		       1b		      .byte.b	27
      0  110e					      dw	32766
      1  110e		       fe 7f		      .word.w	32766
      0  1110					      RANDOM
      0  1110					      db	37
      1  1110		       25		      .byte.b	37
      0  1111					      RTN
      0  1111					      db	25
      1  1111		       19		      .byte.b	25
    307  1112				   F2A1
      0  1112					      CALL	FACT	;GET RANGE
      0  1112					      db	28
      1  1112		       1c		      .byte.b	28
      0  1113					      dw	FACT
      1  1113		       da 10		      .word.w	FACT
      0  1115					      TST	UNKNOWN,")"
      0  1115					      db	32
      1  1115		       20		      .byte.b	32
      0  1116					      db	(UNKNOWN-*)-1
      1  1116		       7b		      .byte.b	(UNKNOWN-*)-1
      0  1117					      db	")",0
      1  1117		       29 00		      .byte.b	")",0
      0  1119					      RANDOM
      0  1119					      db	37
      1  1119		       25		      .byte.b	37
      0  111a					      RTN
      0  111a					      db	25
      1  111a		       19		      .byte.b	25
    312  111b
    313  111b				   F2B
      0  111b					      TST	F2B2,"ABS("
      0  111b					      db	32
      1  111b		       20		      .byte.b	32
      0  111c					      db	(F2B2-*)-1
      1  111c		       0e		      .byte.b	(F2B2-*)-1
      0  111d					      db	"ABS(",0
      1  111d		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1122					      CALL	FACT	;get value
      0  1122					      db	28
      1  1122		       1c		      .byte.b	28
      0  1123					      dw	FACT
      1  1123		       da 10		      .word.w	FACT
      0  1125					      TST	UNKNOWN,")"
      0  1125					      db	32
      1  1125		       20		      .byte.b	32
      0  1126					      db	(UNKNOWN-*)-1
      1  1126		       6b		      .byte.b	(UNKNOWN-*)-1
      0  1127					      db	")",0
      1  1127		       29 00		      .byte.b	")",0
      0  1129					      ABS
      0  1129					      db	38
      1  1129		       26		      .byte.b	38
      0  112a					      RTN
      0  112a					      db	25
      1  112a		       19		      .byte.b	25
    319  112b
    320  112b				   F2B2
      0  112b					      TST	F2C,"CALL("	;call machine function
      0  112b					      db	32
      1  112b		       20		      .byte.b	32
      0  112c					      db	(F2C-*)-1
      1  112c		       1c		      .byte.b	(F2C-*)-1
      0  112d					      db	"CALL(",0
      1  112d		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1133					      CALL	EXPR
      0  1133					      db	28
      1  1133		       1c		      .byte.b	28
      0  1134					      dw	EXPR
      1  1134		       95 10		      .word.w	EXPR
      0  1136					      TST	F2B2A,COMMA
      0  1136					      db	32
      1  1136		       20		      .byte.b	32
      0  1137					      db	(F2B2A-*)-1
      1  1137		       0b		      .byte.b	(F2B2A-*)-1
      0  1138					      db	COMMA,0
      1  1138		       2c 00		      .byte.b	COMMA,0
      0  113a					      CALL	EXPR
      0  113a					      db	28
      1  113a		       1c		      .byte.b	28
      0  113b					      dw	EXPR
      1  113b		       95 10		      .word.w	EXPR
      0  113d					      TST	UNKNOWN,")"
      0  113d					      db	32
      1  113d		       20		      .byte.b	32
      0  113e					      db	(UNKNOWN-*)-1
      1  113e		       53		      .byte.b	(UNKNOWN-*)-1
      0  113f					      db	")",0
      1  113f		       29 00		      .byte.b	")",0
      0  1141					      CALLFUNC2
      0  1141					      db	54
      1  1141		       36		      .byte.b	54
      0  1142					      RTN
      0  1142					      db	25
      1  1142		       19		      .byte.b	25
    328  1143
      0  1143				   F2B2A      TST	UNKNOWN,")"
      0  1143					      db	32
      1  1143		       20		      .byte.b	32
      0  1144					      db	(UNKNOWN-*)-1
      1  1144		       4d		      .byte.b	(UNKNOWN-*)-1
      0  1145					      db	")",0
      1  1145		       29 00		      .byte.b	")",0
      0  1147					      CALLFUNC
      0  1147					      db	53
      1  1147		       35		      .byte.b	53
      0  1148					      RTN
      0  1148					      db	25
      1  1148		       19		      .byte.b	25
    332  1149				   F2C
      0  1149					      TSTV	F0
      0  1149					      db	33
      1  1149		       21		      .byte.b	33
      0  114a					      db	(F0-*)-1
      1  114a		       02		      .byte.b	(F0-*)-1
      0  114b					      IND		;YES, GET THE VALUE.
      0  114b					      db	20
      1  114b		       14		      .byte.b	20
      0  114c					      RTN
      0  114c					      db	25
      1  114c		       19		      .byte.b	25
    336  114d				   F0
      0  114d					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  114d					      db	35
      1  114d		       23		      .byte.b	35
      0  114e					      db	(F1-*)-1
      1  114e		       01		      .byte.b	(F1-*)-1
      0  114f					      RTN
      0  114f					      db	25
      1  114f		       19		      .byte.b	25
    339  1150				   F1
      0  1150					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  1150					      db	32
      1  1150		       20		      .byte.b	32
      0  1151					      db	(F2A-*)-1
      1  1151		       b0		      .byte.b	(F2A-*)-1
      0  1152					      db	"(",0
      1  1152		       28 00		      .byte.b	"(",0
      0  1154					      CALL	EXPR
      0  1154					      db	28
      1  1154		       1c		      .byte.b	28
      0  1155					      dw	EXPR
      1  1155		       95 10		      .word.w	EXPR
      0  1157					      TST	F2,")"
      0  1157					      db	32
      1  1157		       20		      .byte.b	32
      0  1158					      db	(F2-*)-1
      1  1158		       03		      .byte.b	(F2-*)-1
      0  1159					      db	")",0
      1  1159		       29 00		      .byte.b	")",0
      0  115b					      RTN
      0  115b					      db	25
      1  115b		       19		      .byte.b	25
    344  115c
    345  115c				   F2
      0  115c					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  115c					      db	13
      1  115c		       0d		      .byte.b	13
      0  115d					      dw	ERR_SYNTAX
      1  115d		       05 00		      .word.w	ERR_SYNTAX
    347  115f
    348  115f				   RELOP
      0  115f					      TST	iR0,"="
      0  115f					      db	32
      1  115f		       20		      .byte.b	32
      0  1160					      db	(iR0-*)-1
      1  1160		       06		      .byte.b	(iR0-*)-1
      0  1161					      db	"=",0
      1  1161		       3d 00		      .byte.b	"=",0
      0  1163					      LIT	2	;=
      0  1163					      db	27
      1  1163		       1b		      .byte.b	27
      0  1164					      dw	2
      1  1164		       02 00		      .word.w	2
      0  1166					      RTN
      0  1166					      db	25
      1  1166		       19		      .byte.b	25
    352  1167				   iR0
      0  1167					      TST	R4,"<"
      0  1167					      db	32
      1  1167		       20		      .byte.b	32
      0  1168					      db	(R4-*)-1
      1  1168		       16		      .byte.b	(R4-*)-1
      0  1169					      db	"<",0
      1  1169		       3c 00		      .byte.b	"<",0
      0  116b					      TST	iR1,"="
      0  116b					      db	32
      1  116b		       20		      .byte.b	32
      0  116c					      db	(iR1-*)-1
      1  116c		       06		      .byte.b	(iR1-*)-1
      0  116d					      db	"=",0
      1  116d		       3d 00		      .byte.b	"=",0
      0  116f					      LIT	3	;<=
      0  116f					      db	27
      1  116f		       1b		      .byte.b	27
      0  1170					      dw	3
      1  1170		       03 00		      .word.w	3
      0  1172					      RTN
      0  1172					      db	25
      1  1172		       19		      .byte.b	25
    357  1173				   iR1
      0  1173					      TST	R3,">"
      0  1173					      db	32
      1  1173		       20		      .byte.b	32
      0  1174					      db	(R3-*)-1
      1  1174		       06		      .byte.b	(R3-*)-1
      0  1175					      db	">",0
      1  1175		       3e 00		      .byte.b	">",0
      0  1177					      LIT	5	;<>
      0  1177					      db	27
      1  1177		       1b		      .byte.b	27
      0  1178					      dw	5
      1  1178		       05 00		      .word.w	5
      0  117a					      RTN
      0  117a					      db	25
      1  117a		       19		      .byte.b	25
    361  117b				   R3
      0  117b					      LIT	1	;<
      0  117b					      db	27
      1  117b		       1b		      .byte.b	27
      0  117c					      dw	1
      1  117c		       01 00		      .word.w	1
      0  117e					      RTN
      0  117e					      db	25
      1  117e		       19		      .byte.b	25
    364  117f				   R4
      0  117f					      TST	UNKNOWNVEC,">"
      0  117f					      db	32
      1  117f		       20		      .byte.b	32
      0  1180					      db	(UNKNOWNVEC-*)-1
      1  1180		       56		      .byte.b	(UNKNOWNVEC-*)-1
      0  1181					      db	">",0
      1  1181		       3e 00		      .byte.b	">",0
      0  1183					      TST	R5,"="
      0  1183					      db	32
      1  1183		       20		      .byte.b	32
      0  1184					      db	(R5-*)-1
      1  1184		       06		      .byte.b	(R5-*)-1
      0  1185					      db	"=",0
      1  1185		       3d 00		      .byte.b	"=",0
      0  1187					      LIT	6	;>=
      0  1187					      db	27
      1  1187		       1b		      .byte.b	27
      0  1188					      dw	6
      1  1188		       06 00		      .word.w	6
      0  118a					      RTN
      0  118a					      db	25
      1  118a		       19		      .byte.b	25
    369  118b				   R5
      0  118b					      TST	R6,"<"
      0  118b					      db	32
      1  118b		       20		      .byte.b	32
      0  118c					      db	(R6-*)-1
      1  118c		       06		      .byte.b	(R6-*)-1
      0  118d					      db	"<",0
      1  118d		       3c 00		      .byte.b	"<",0
      0  118f					      LIT	1
      0  118f					      db	27
      1  118f		       1b		      .byte.b	27
      0  1190					      dw	1
      1  1190		       01 00		      .word.w	1
      0  1192					      RTN		;(This line originally omitted)
      0  1192					      db	25
      1  1192		       19		      .byte.b	25
    373  1193				   R6
      0  1193					      LIT	4	;>???
      0  1193					      db	27
      1  1193		       1b		      .byte.b	27
      0  1194					      dw	4
      1  1194		       04 00		      .word.w	4
      0  1196					      RTN
      0  1196					      db	25
      1  1196		       19		      .byte.b	25
    376  1197
    377  1197		       11 97	   ILEND      equ	*
------- FILE mytb.asm
   1662  1197		       11 97	   PROGEND    equ	*
   1663  1197
   1664  1197							;=====================================================
   1665  1197							;=====================================================
   1666  1197							;=====================================================
   1667  1197							; These are storage items not in page zero.
   1668  1197							;
   1669 Udf9e					      seg.u	Data
   1670 U1197					      org	PROGEND
   1671 U1197
   1672 U1197		       00 00 00 00*mathStack  ds	STACKSIZE*2
   1673 U11a7		       00	   mathStackPtr ds	1
   1674 U11a8		       00 00 00 00*retStack   ds	STACKSIZE*2
   1675 U11b8		       00	   retStackPtr ds	1
   1676 U11b9							;callStack	ds	GOSUBSTACKSIZE*2
   1677 U11b9		       00	   GoSubStackPtr ds	1
   1678 U11ba		       00 00 00 00*LINBUF     ds	132
   1679 U123e		       00	   getlinx    ds	1
   1680 U123f		       00	   printtx    ds	1	;temp X for print funcs
   1681 U1240		       00	   diddigit   ds	1	;for leading zero suppression
   1682 U1241		       00	   putsy      ds	1
   1683 U1242		       00 00	   errGoto    ds	2	;where to set ILPC on err
   1684 U1244		       00 00	   MQ	      ds	2	;used for some math
   1685 U1246		       00	   sign       ds	1	;0 = positive, else negative
   1686 U1247		       00	   rtemp1     ds	1
   1687 U1248		       00 00	   random     ds	2
   1688 U124a		       00 00	   BOutVec    ds	2
   1689 U124c		       00	   tempy      ds	1	;temp y storage
   1690 U124d				  -	      if	XKIM
   1691 U124d				  -buffer     ds	BUFFER_SIZE
   1692 U124d					      endif
   1693 U124d							;
   1694 U124d							; PROGRAMEND is the end of the user's BASIC program.
   1695 U124d							; More precisely, it is one byte past the end.  Or,
   1696 U124d							; it's where the next line added to the end will be
   1697 U124d							; placed.
   1698 U124d							;
   1699 U124d		       00 00	   PROGRAMEND ds	2
   1700 U124f		       00 00	   HighMem    ds	2	;highest location
   1701 U1251		       00 00	   UsedMem    ds	2	;size of user program
   1702 U1253		       00 00	   FreeMem    ds	2	;amount of free memory
   1703 U1255							;
   1704 U1255							;=====================================================
   1705 U1255							; This is the start of the user's BASIC program space.
   1706 U1255							;
   1707 U1255							; PERSONAL GOAL: This should be no larger than $0DFF.
   1708 U1255							;		  0200-05FF = 1K
   1709 U1255							;		  0200-09FF = 2K
   1710 U1255							;		  0200-0DFF = 3K
   1711 U1255							;		  0200-11FF = 4K
   1712 U1255							;		  0200-13FF = 4.5K
   1713 U1255							;
   1714 U1255				  -	      if	FIXED
   1715 U1255				  -	      org	$2000
   1716 U1255					      endif
   1717 U1255		       12 55	   ProgramStart equ	*
   1718 U1255							;/*
   1719 U1255							;	if	CTMON65 || XKIM
   1720 U1255							;		SEG Code
   1721 U1255							;		org	AutoRun
   1722 U1255							;		dw	TBasicCold
   1723 U1255							;	endif
   1724 U1255							;*/
   1725 U1255					      end
