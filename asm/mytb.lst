------- FILE mytb.asm LEVEL 1 PASS 6
      1 U260f				   input      processor	6502
      2 U260f ????						;=====================================================
      3 U260f ????						; Concurrent Tiny Basic, no longer Tiny
      4 U260f ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U260f ????						; Free Time. Now abiut 6K Full OS features.
      6 U260f ????						;
      7 U260f ????						; While working on the Corsham Technologies KIM Clone
      8 U260f ????						; project, I wanted to include a TINY BASIC since that
      9 U260f ????						; was a highly desirable feature of early computers.
     10 U260f ????						;
     11 U260f ????						; Rather than negotiating copyright issues for
     12 U260f ????						; existing BASICs, I decided to just write one from
     13 U260f ????						; scratch.
     14 U260f ????						;
     15 U260f ????						; 10/07/2017
     16 U260f ????						;
     17 U260f ????						; This implements a stripped down Tiny BASIC
     18 U260f ????						; interpreter using the Interpretive Language (IL)
     19 U260f ????						; method as described in the first few issues of
     20 U260f ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U260f ????						; to write various languages simply by changing the
     22 U260f ????						; IL code rather than the interpreter itself.
     23 U260f ????						;
     24 U260f ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U260f ????						;		* Fixed major bug in findLine that
     26 U260f ????						;		  caused corrupted lines, crashes, etc.
     27 U260f ????						;		* If no parameter given to RND, assume
     28 U260f ????						;		  32766.
     29 U260f ????						;		* No more error 5 when a program
     30 U260f ????						;		  reaches the end without an END.
     31 U260f ????						;
     32 U260f ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U260f ????						;		 * Unexpanded version to play with everything
     34 U260f ????						;		 * Add some usefull system level functions
     35 U260f ????						;		 * allow a larger number of tiny basic formats
     36 U260f ????						;		 * Add byte at start of line holding length
     37 U260f ????						;		   for faster execution of goto and gosub
     38 U260f ????						;		 * Re-added gosub
     39 U260f ????						;		 * allow ; or , at end if print stmt
     40 U260f ????						;		   without CRLF being added.
     41 U260f ????						;		 * Added extended function erase to
     42 U260f ????						;		   use the extended ctmon65 rm file
     43 U260f ????						;		 * Fix quoted text to not have to backtrack
     44 U260f ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U260f ????						;		 * Add concurrency features
     46 U260f ????						;
     47 U260f ????						; www.corshamtech.com
     48 U260f ????						; bob@corshamtech.com
     49 U260f ????						; JustLostInTime@gmail.com
     50 U260f ????						;
     51 U260f ????						;=====================================================
     52 U260f ????						;
     53 U260f ????						; Create TRUE and FALSE values for conditionals.
     54 U260f ????						;
     55 U260f ????
     56 U260f ????	       00 00	   FALSE      equ	0
     57 U260f ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U260f ????						;
     59 U260f ????						;---------------------------------------------------------
     60 U260f ????						; One of these must be set to indicate which environment
     61 U260f ????						; Tiny BASIC will be running in.  Here are the current
     62 U260f ????						; environments:
     63 U260f ????						;
     64 U260f ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U260f ????						; more K of RAM.
     66 U260f ????						;
     67 U260f ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U260f ????						; which enhances, without replacing, the standard KIM
     69 U260f ????						; monitor.  It gives access to routines to save/load files
     70 U260f ????						; to a micro SD card.
     71 U260f ????						;
     72 U260f ????						; CTMON65 is a from-scratch monitor written for the
     73 U260f ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U260f ????						; easily be ported to other systems.  It has support for
     75 U260f ????						; using a micro SD card for file storage/retrieval.
     76 U260f ????						;
     77 U260f ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U260f ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U260f ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U260f ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U260f ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U260f ????						;
     83 U260f ????						;   Need to define some macros for the dasm assembler
     84 U260f ????						;
     85 U260f ????				      MACRO	dw
     86 U260f ????				      .word	{0}
     87 U260f ????				      ENDM
     88 U260f ????
     89 U260f ????				      MACRO	db
     90 U260f ????				      .byte	{0}
     91 U260f ????				      ENDM
     92 U260f ????
     93 U260f ????						;
     94 U260f ????						; If set, include disk functions.
     95 U260f ????						;
     96 U260f ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U260f ????						;
     98 U260f ????						; If ILTRACE is set then dump out the address of every
     99 U260f ????						; IL opcode before executing it.
    100 U260f ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U260f ????						;
    102 U260f ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U260f ????						;
    104 U260f ????						; If FIXED is set, put the IL code and the user
    105 U260f ????						; program space at fixed locations in memory.	This is
    106 U260f ????						; meant only for debugging.
    107 U260f ????						;
    108 U260f ????	       00 00	   FIXED      equ	FALSE
    109 U260f ????						;
    110 U260f ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U260f ????						; BASIC, so keep this small!
    112 U260f ????						;
    113 U260f ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U260f ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U260f ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U260f ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U260f ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U260f ????	       00 c8	   TASKCYCLESDEFAULT equ	200	;Default Task Switch 0-255 uses a single byte
    119 U260f ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    120 U260f ????						;
    121 U260f ????						; Gosub entry types
    122 U260f ????
    123 U260f ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    124 U260f ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    125 U260f ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    126 U260f ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    127 U260f ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    128 U260f ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    129 U260f ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    130 U260f ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    131 U260f ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    132 U260f ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    133 U260f ????						;
    134 U260f ????						; Common ASCII constants
    135 U260f ????						;
    136 U260f ????	       00 07	   BEL	      equ	$07
    137 U260f ????	       00 08	   BS	      equ	$08
    138 U260f ????	       00 09	   TAB	      equ	$09
    139 U260f ????	       00 0a	   LF	      equ	$0A
    140 U260f ????	       00 0d	   CR	      equ	$0D
    141 U260f ????	       00 22	   quote      equ	$22
    142 U260f ????	       00 20	   SPACE      equ	$20
    143 U260f ????	       00 2c	   COMMA      equ	',
    144 U260f ????	       00 3b	   SEMICOLON  equ	';
    145 U260f ????	       00 3a	   COLON      equ	':
    146 U260f ????	       00 24	   DOLLAR     equ	'$
    147 U260f ????						;
    148 U260f ????						; These are error codes
    149 U260f ????						;
    150 U260f ????	       00 00	   ERR_NONE   equ	0	;No Errror
    151 U260f ????	       00 01	   ERR_EXPR   equ	1	;expression error
    152 U260f ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    153 U260f ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    154 U260f ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    155 U260f ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    156 U260f ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    157 U260f ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    158 U260f ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    159 U260f ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    160 U260f ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    161 U260f ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    162 U260f ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    163 U260f ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    164 U260f ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    165 U260f ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    166 U260f ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    167 U260f ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    168 U260f ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    169 U260f ????						;
    170 U260f ????						;=====================================================
    171 U260f ????						; Zero page storage.
    172 U260f ????						;
    173 U00f6 ????				      SEG.U	ZEROPAGE
    174 U0040					      org	$0040
    175 U0040
    176 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    177 U0041
    178 U0041							; The context is used to locate a task switch
    179 U0041							; it copies from here till all task fields are saved/swapped
    180 U0041							; The max number of tasks is 256 / context length
    181 U0041							; All positions POS values are plus one task table incldues
    182 U0041							; a leading status byte .
    183 U0041							;
    184 U0041		       00 41	   CONTEXT    equ	*
    185 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    186 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    187 U0043		       00 00	   ILPC       ds	2	; IL program counter
    188 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    189 U0047		       00	   ILSTACKPTR ds	1
    190 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    191 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    192 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    193 U004a		       00	   MATHSTACKPTR ds	1
    194 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    195 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    196 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    197 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    198 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    199 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    200 U004f							;
    201 U004f							; CURPTR is a pointer to curent BASIC line being
    202 U004f							; executed.  Always points to start of line, CUROFF
    203 U004f							; is the offset to the current character.
    204 U004f							; The order of these fields is important
    205 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    206 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    207 U0052							;
    208 U0052							;The order of these fields in important
    209 U0052
    210 U0052							;
    211 U0052							; R0, R1 and MQ are used for arithmetic operations and
    212 U0052							; general use.
    213 U0052							;
    214 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    215 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    216 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    217 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    218 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    219 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    220 U0056		       00 00	   MQ	      ds	2	;used for some math
    221 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    222 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    223 U0058		       00 59	   REGISTERSEND equ	*
    224 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    225 U0059
    226 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    227 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    228 U0059
    229 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    230 U005b		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    231 U005d		       00	   tempIlY    ds	1	;Temp IL Y register storage
    232 U005e		       00	   offset     ds	1	;IL Offset to next inst when test fails
    233 U005f		       00	   lineLength ds	1	;Length of current line
    234 U0060
    235 U0060		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
    236 U0061		       00	   taskRDPending ds	1	; 1 = background read is pending
    237 U0062
    238 U0062							;
    239 U0062							; This is zero if in immediate mode, or non-zero
    240 U0062							; if currently running a program.  Any input from
    241 U0062							; the main loop clears this, and the XFER IL
    242 U0062							; statement will set it.
    243 U0062							;
    244 U0062		       00	   RunMode    ds	1	;Basic program is running or stop
    245 U0063							;
    246 U0063							; Used for line insertion/removal.
    247 U0063							;
    248 U0063		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    249 U0065
    250 U0065							; THE ADDRESS USED BY THE PRINTER FUNCTION
    251 U0065							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    252 U0065							;
    253 U0065		       00 00	   PrtFrom    ds	2	; FROM
    254 U0067							;
    255 U0067
    256 U0067							;
    257 U0067							;=====================================================
    258 U0067							;
    259  1ca2 ????				      SEG	Code
    260  0200					      org	$0200
    261  0200							;
    262  0200							; Cold start is at $0200.  Warm start is at $0203.
    263  0200							;
    264  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    265  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    266  0206							;
    267  0206							; These are the user-supplied vectors to I/O routines.
    268  0206							; If you want, you can just patch these in the binary
    269  0206							; file, but it would be better to change the source
    270  0206							; code.
    271  0206							;
    272  0206				  -	      if	KIM
    273  0206				  -OUTCH      jmp	$1ea0	;output char in A
    274  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    275  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    276  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    277  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    278  0206					      endif
    279  0206				  -	      if	XKIM
    280  0206				  -	      include	"xkim.inc"
    281  0206				  -	      SEG	Code
    282  0206				  -OUTCH      jmp	$1ea0
    283  0206				  -GETCH      jmp	xkGETCH
    284  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    285  0206				  -OUTHEX     jmp	xkPRTBYT
    286  0206				  -MONITOR    jmp	extKIM
    287  0206				  -puts       equ	putsil
    288  0206				  -BUFFER_SIZE equ	132
    289  0206					      endif
    290  0206
    291  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0067					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    293 Udf8e
    294  0206					      SEG	Code
    295  0206							;
    296  0206		       f0 0c	   OUTCH      equ	cout
    297  0206		       f0 09	   GETCH      equ	cin
    298  0206		       14 70	   CRLF       equ	tbcrlf
    299  0206		       16 4b	   OUTHEX     equ	HexToOut
    300  0206		       f0 03	   MONITOR    equ	WARM
    301  0206		       f0 0f	   ISCHAR     equ	cstatus
    302  0206		       15 f2	   puts       equ	tbputs
    303  0206					      endif
    304  0206							;
    305  0206		       20 d2 15    cold2      jsr	SetOutConsole
    306  0209		       20 df 15 	      jsr	SetInConsole
    307  020c		       20 f2 15 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    311  023c							;
    312  023c		       20 9f 15 	      jsr	GetSizes	;setup the free space available
    313  023f
    314  023f		       a9 01	   calcstack  lda	#1
    315  0241		       8d b4 1d 	      sta	taskCounter	; Initialize number of tasks to 1
    316  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    317  0246		       8d b8 1c 	      sta	taskTable	; mark the main task as active
    318  0249		       20 3b 0d 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    319  024c		       a9 19		      lda	#IL&$ff
    320  024e		       85 43		      sta	ILPC
    321  0250		       a9 18		      lda	#IL>>8
    322  0252		       85 44		      sta	ILPC+1
    323  0254							;
    324  0254		       a9 0f		      lda	#ProgramStart&$ff	; user prog
    325  0256		       8d 07 26 	      sta	PROGRAMEND
    326  0259		       a9 26		      lda	#ProgramStart>>8
    327  025b		       8d 08 26 	      sta	PROGRAMEND+1
    328  025e							;
    329  025e							; Initialize the pseudo-random number sequence...
    330  025e							;
    331  025e		       a9 5a		      lda	#$5a
    332  0260		       8d fe 25 	      sta	rtemp1
    333  0263		       a9 9d		      lda	#%10011101
    334  0265		       8d 00 26 	      sta	random
    335  0268		       a9 5b		      lda	#%01011011
    336  026a		       8d 01 26 	      sta	random+1
    337  026d							;
    338  026d							;   Insert a Basic irq handler for the basic Language
    339  026d		       a9 7a		      lda	#ServiceIrq&$ff
    340  026f		       8d 00 df 	      sta	IRQvec
    341  0272		       a9 02		      lda	#ServiceIrq>>8
    342  0274		       8d 01 df 	      sta	IRQvec+1
    343  0277		       4c 9f 02 	      jmp	coldtwo
    344  027a
    345  027a							;
    346  027a							; This is the Basic IRQ handler
    347  027a		       48	   ServiceIrq pha
    348  027b		       ad b3 1c 	      lda	IRQStatus
    349  027e		       f0 0a		      BEQ	RetIrq
    350  0280		       ad b4 1c 	      lda	IRQPending
    351  0283		       d0 05		      bne	RetIrq
    352  0285		       a9 01		      lda	#1
    353  0287		       8d b4 1c 	      sta	IRQPending
    354  028a		       68	   RetIrq     pla
    355  028b		       40		      rti
    356  028c							;
    357  028c							;
    358  028c							; This is the warm start entry point
    359  028c							;
    360  028c		       20 d2 15    warm2      jsr	SetOutConsole
    361  028f		       20 df 15 	      jsr	SetInConsole
    362  0292		       20 70 14 	      jsr	CRLF
    363  0295		       ad fb 25 	      lda	errGoto
    364  0298		       85 43		      sta	ILPC
    365  029a		       ad fc 25 	      lda	errGoto+1
    366  029d		       85 44		      sta	ILPC+1
    367  029f							;
    368  029f							; And continue with both starts here
    369  029f							;
    370  029f				   coldtwo
    371  029f							;
    372  029f							; The ILTrace flag is now run-time settable.
    373  029f							;
    374  029f		       a9 00		      lda	#ILTRACE&$ff
    375  02a1		       85 40		      sta	ILTrace
    376  02a3							;
    377  02a3
    378  02a3		       a9 00		      lda	#0
    379  02a5		       85 62		      sta	RunMode
    380  02a7		       8d 71 25 	      sta	LINBUF
    381  02aa
    382  02aa							; Clear everything from the stacks
    383  02aa
    384  02aa		       85 60		      sta	taskIOPending	; No one waiting for io
    385  02ac		       85 61		      sta	taskRDPending	; No one waiting for bg io
    386  02ae
    387  02ae		       20 ae 0d 	      jsr	taskReset
    388  02b1							;
    389  02b1		       a9 71		      lda	#LINBUF&$ff
    390  02b3		       85 4f		      sta	CURPTR
    391  02b5		       a9 25		      lda	#LINBUF>>8
    392  02b7		       85 50		      sta	CURPTR+1	;fall through...
    393  02b9
    394  02b9							;=====================================================
    395  02b9							; This is the top of the IL interpreter.  This fetches
    396  02b9							; and executes the instruction currently pointed to
    397  02b9							; by ILPC and adjusts ILPC to point to the next
    398  02b9							; instruction to execute.
    399  02b9							;
    400  02b9		       ce b2 1d    NextIL     dec	taskCurrentCycles
    401  02bc		       d0 03		      bne	NextIlNow
    402  02be		       20 d7 0d 	      jsr	iTaskSwitch	;check for a task switch
    403  02c1		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    404  02c3		       f0 03		      beq	NextIL2	;Skip if no bits set
    405  02c5
    406  02c5		       20 fc 14 	      jsr	dbgLine	;Print the IL trace information
    407  02c8
    408  02c8		       a4 51	   NextIL2    ldy	CUROFF
    409  02ca		       20 67 14 	      jsr	SkipSpaces
    410  02cd		       84 51		      sty	CUROFF
    411  02cf							;Task IO Management
    412  02cf		       a5 61		      lda	taskRDPending	; if it is zero then Nothing pending
    413  02d1		       f0 07		      beq	NextILStr
    414  02d3		       20 bc 12 	      jsr	ReadLine	; else Pending and poll keyboard
    415  02d6		       90 02		      bcc	NextILStr	; if carry is clear then no end of line yet
    416  02d8		       c6 61		      dec	taskRDPending	; Carry is set if CR has been recieved
    417  02da							;
    418  02da		       20 d7 10    NextILStr  jsr	getILByte
    419  02dd							;
    420  02dd							; When the handler is called, these are the conditions
    421  02dd							; of several important items:
    422  02dd							;
    423  02dd							;    (ILPC) will point to the byte AFTER the IL
    424  02dd							;    opcode being executed.
    425  02dd							;
    426  02dd							;    (CURPTR),CUROFF will point to the start of the
    427  02dd							;    next word in the input buffer.  Ie, the next word
    428  02dd							;    in the user program.
    429  02dd							;
    430  02dd		       0a		      asl
    431  02de		       c9 c6		      cmp	#ILTBLend-ILTBL+2
    432  02e0		       90 33		      bcc	ILgood
    433  02e2							;
    434  02e2							; This handles an illegal IL opcode.  This is serious
    435  02e2							; and there's no way to recover.
    436  02e2							;
    437  02e2		       20 f2 15    ILbad      jsr	puts
      0  02e5					      db	CR,LF
      1  02e5		       0d 0a		      .byte.b	CR,LF
      0  02e7					      db	"Illegal IL "
      1  02e7		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f2					      db	0
      1  02f2		       00		      .byte.b	0
    441  02f3							;
    442  02f3							; Well this is awkward, we need to back up the IL
    443  02f3							; by one since it no longer points to the current
    444  02f3							; opcode.
    445  02f3							;
    446  02f3		       20 e4 10 	      jsr	decIL
    447  02f6							;
    448  02f6		       a0 00		      ldy	#0
    449  02f8		       b1 43		      lda	(ILPC),y
    450  02fa		       20 4b 16 	      jsr	OUTHEX
    451  02fd		       20 f2 15 	      jsr	puts
      0  0300					      db	" at ",0
      1  0300		       20 61 74 20*	      .byte.b	" at ",0
    453  0305		       a5 44		      lda	ILPC+1
    454  0307		       20 4b 16 	      jsr	OUTHEX
    455  030a		       a5 43		      lda	ILPC
    456  030c		       20 4b 16 	      jsr	OUTHEX
    457  030f		       20 70 14 	      jsr	CRLF
    458  0312		       4c 03 f0 	      jmp	MONITOR
    459  0315							;
    460  0315							; Just jump to the address (ILPC),y.  Have to do
    461  0315							; some goofy stuff.
    462  0315							;
    463  0315		       a8	   ILgood     tay		;move index into Y
    464  0316		       b9 23 03 	      lda	ILTBL,y
    465  0319		       85 59		      sta	dpl
    466  031b		       b9 24 03 	      lda	ILTBL+1,y
    467  031e		       85 5a		      sta	dpl+1
    468  0320		       6c 59 00 	      jmp	(dpl)	;go to handler
    469  0323							;
    470  0323							;=====================================================
    471  0323							; This is the IL jump table.  The IL opcode is
    472  0323							; mulitplied by two, then looked-up in this table.
    473  0323							; There is absolutely nothing special about the order
    474  0323							; of entries here... they all decode at exactly the
    475  0323							; same speed.	However the entry number must match the
    476  0323							; values in IL.inc.
    477  0323							;
    478  0323				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0323					      include	"ilvectortable.asm"
      1  0323					      seg	Code
      2  0323
      0  0323					      dw	iXINIT	;0
      1  0323		       19 04		      .word.w	iXINIT
      0  0325					      dw	iDONE	;1
      1  0325		       34 04		      .word.w	iDONE
      0  0327					      dw	iPRS	;2
      1  0327		       50 04		      .word.w	iPRS
      0  0329					      dw	iPRN	;3
      1  0329		       5a 04		      .word.w	iPRN
      0  032b					      dw	iSPC	;4
      1  032b		       63 04		      .word.w	iSPC
      0  032d					      dw	iNLINE	;5
      1  032d		       f7 08		      .word.w	iNLINE
      0  032f					      dw	iNXT	;6
      1  032f		       6b 04		      .word.w	iNXT
      0  0331					      dw	iXFER	;7
      1  0331		       97 04		      .word.w	iXFER
      0  0333					      dw	iSAV	;8
      1  0333		       c4 04		      .word.w	iSAV
      0  0335					      dw	iRSTR	;9
      1  0335		       07 05		      .word.w	iRSTR
      0  0337					      dw	iCMPR	;10
      1  0337		       36 05		      .word.w	iCMPR
      0  0339					      dw	iINNUM	;11
      1  0339		       b7 05		      .word.w	iINNUM
      0  033b					      dw	iFIN	;12
      1  033b		       eb 05		      .word.w	iFIN
      0  033d					      dw	iERR	;13
      1  033d		       ff 05		      .word.w	iERR
      0  033f					      dw	iADD	;14
      1  033f		       6f 06		      .word.w	iADD
      0  0341					      dw	iSUB	;15
      1  0341		       85 06		      .word.w	iSUB
      0  0343					      dw	iNEG	;16
      1  0343		       9b 06		      .word.w	iNEG
      0  0345					      dw	iMUL	;17
      1  0345		       b3 06		      .word.w	iMUL
      0  0347					      dw	iDIV	;18
      1  0347		       f3 06		      .word.w	iDIV
      0  0349					      dw	iSTORE	;19
      1  0349		       49 07		      .word.w	iSTORE
      0  034b					      dw	iIND	;20
      1  034b		       61 07		      .word.w	iIND
      0  034d					      dw	iLST	;21
      1  034d		       cf 07		      .word.w	iLST
      0  034f					      dw	iINIT	;22
      1  034f		       e7 03		      .word.w	iINIT
      0  0351					      dw	iGETLINE	;23
      1  0351		       2e 08		      .word.w	iGETLINE
      0  0353					      dw	iINSRT	;24
      1  0353		       3c 08		      .word.w	iINSRT
      0  0355					      dw	iRTN	;25
      1  0355		       f1 08		      .word.w	iRTN
      0  0357					      dw	MONITOR	;26
      1  0357		       03 f0		      .word.w	MONITOR
      0  0359					      dw	iLIT	;27
      1  0359		       17 09		      .word.w	iLIT
      0  035b					      dw	iCALL	;28
      1  035b		       fd 08		      .word.w	iCALL
      0  035d					      dw	iJMP	;29
      1  035d		       05 09		      .word.w	iJMP
      0  035f					      dw	iVINIT	;30
      1  035f		       34 09		      .word.w	iVINIT
      0  0361					      dw	iERRGOTO	;31
      1  0361		       3a 09		      .word.w	iERRGOTO
      0  0363					      dw	iTST	;32
      1  0363		       46 09		      .word.w	iTST
      0  0365					      dw	iTSTV	;33
      1  0365		       f4 09		      .word.w	iTSTV
      0  0367					      dw	iTSTL	;34
      1  0367		       72 0a		      .word.w	iTSTL
      0  0369					      dw	iTSTN	;35
      1  0369		       8c 0a		      .word.w	iTSTN
      0  036b					      dw	iFREE	;36
      1  036b		       06 0b		      .word.w	iFREE
      0  036d					      dw	iRANDOM	;37
      1  036d		       0f 0b		      .word.w	iRANDOM
      0  036f					      dw	iABS	;38
      1  036f		       e0 0b		      .word.w	iABS
     42  0371							;
     43  0371							; Disk functions.  There must be pointers
     44  0371							; to functions even if no disk is supported.
     45  0371							; Makes things easier in IL.inc.
     46  0371							;
     47  0371					      if	DISK_ACCESS
      0  0371					      dw	iOPENREAD	;39
      1  0371		       f4 16		      .word.w	iOPENREAD
      0  0373					      dw	iOPENWRITE	;40
      1  0373		       48 17		      .word.w	iOPENWRITE
      0  0375					      dw	iDCLOSE	;41
      1  0375		       cc 17		      .word.w	iDCLOSE
      0  0377					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0377		       67 17		      .word.w	iDGETLINE
      0  0379					      dw	iDLIST	;43 Did you remeber your towel?
      1  0379		       c6 17		      .word.w	iDLIST
      0  037b					      dw	iDDIR	;44
      1  037b		       a1 17		      .word.w	iDDIR
      0  037d					      dw	iRMFILE	;45
      1  037d		       22 17		      .word.w	iRMFILE
     55  037f				  -	      else
     56  037f				  -	      dw	NextIL	;39
     57  037f				  -	      dw	NextIL	;40
     58  037f				  -	      dw	NextIL	;41
     59  037f				  -	      dw	NextIL	;42
     60  037f				  -	      dw	NextIL	;43
     61  037f				  -	      dw	NextIL	;44
     62  037f				  -	      dw	NextIL	;45
     63  037f					      endif
     64  037f							;
      0  037f					      dw	iCLEARSCREEN	;46
      1  037f		       68 16		      .word.w	iCLEARSCREEN
      0  0381					      dw	iPOKEMEMORY	;47
      1  0381		       6d 0b		      .word.w	iPOKEMEMORY
      0  0383					      dw	iPEEKMEMORY	;48
      1  0383		       82 0b		      .word.w	iPEEKMEMORY
      0  0385					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0385		       8b 09		      .word.w	iTSTLET
      0  0387					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0387		       c7 09		      .word.w	iTSTDONE
      0  0389					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0389		       af 0b		      .word.w	iGETCHAR
      0  038b					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038b		       c3 0b		      .word.w	iPUTCHAR
      0  038d					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038d		       98 0b		      .word.w	iCallFunc
      0  038f					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038f		       87 05		      .word.w	iBranch
      0  0391					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0391		       6f 09		      .word.w	iTSTStr
      0  0393					      dw	iSetIrq	;56	   sets the irq handler
      1  0393		       5d 0c		      .word.w	iSetIrq
      0  0395					      dw	iTstIrq	;57	   test if irq is pending
      1  0395		       cf 0a		      .word.w	iTstIrq
      0  0397					      dw	iRET	;58	   return from interupt
      1  0397		       f5 04		      .word.w	iRET
      0  0399					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0399		       ce 05		      .word.w	iINSTR
      0  039b					      dw	iMOD	;60	   returns remainder of division
      1  039b		       fc 06		      .word.w	iMOD
      0  039d					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039d		       1f 0e		      .word.w	iTaskSet
      0  039f					      dw	iETask	;62	   Terminates a task
      1  039f		       40 0f		      .word.w	iETask
      0  03a1					      dw	iNTask	;63	   goto next task
      1  03a1		       fd 0e		      .word.w	iNTask
      0  03a3					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a3		       76 07		      .word.w	iArray
      0  03a5					      dw	iTaskKill	;65	   kill a running task
      1  03a5		       f5 0e		      .word.w	iTaskKill
      0  03a7					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a7		       c9 0e		      .word.w	iTaskStat
      0  03a9					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a9		       ce 0b		      .word.w	iHexOut
      0  03ab					      dw	iReadComplete	;68	   Called after a background read completes
      1  03ab		       a3 05		      .word.w	iReadComplete
      0  03ad					      dw	iReadStart	;69	   Called to start a background read request
      1  03ad		       99 05		      .word.w	iReadStart
      0  03af					      dw	iStartIO	;70	   Lock task until io complete
      1  03af		       26 0f		      .word.w	iStartIO
      0  03b1					      dw	iEndIO	;71	   release task lock for io
      1  03b1		       2b 0f		      .word.w	iEndIO
      0  03b3					      dw	iLogNot	;72	   Logical not
      1  03b3		       39 0c		      .word.w	iLogNot
      0  03b5					      dw	iLogOr	;73	   Logical Or
      1  03b5		       0f 0c		      .word.w	iLogOr
      0  03b7					      dw	iLogAnd	;74	   Logical And
      1  03b7		       fa 0b		      .word.w	iLogAnd
      0  03b9					      dw	iLogXor	;75	   Logical Xor
      1  03b9		       24 0c		      .word.w	iLogXor
      0  03bb					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bb		       05 0f		      .word.w	iWTASK
      0  03bd					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03bd		       34 0f		      .word.w	iTASKPID
      0  03bf					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bf		       99 0c		      .word.w	iTRACEPROG
      0  03c1					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c1		       7d 14		      .word.w	idbgBasic
      0  03c3					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c3		       d6 0f		      .word.w	iIPCS
      0  03c5					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c5		       ed 0f		      .word.w	iIPCR
      0  03c7					      dw	iIPCC	;82	   Check if any message available for task
      1  03c7		       01 10		      .word.w	iIPCC
      0  03c9					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c9		       0e 10		      .word.w	iIPCIO
      0  03cb					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cb		       a3 0c		      .word.w	iPushMathStack
      0  03cd					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03cd		       d3 0c		      .word.w	iPopMathStack
      0  03cf					      dw	iSaveMathStack	;86	   Save all math info
      1  03cf		       f0 0c		      .word.w	iSaveMathStack
      0  03d1					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d1		       0f 0d		      .word.w	iRestoreMathStack
      0  03d3					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d3		       c0 0c		      .word.w	iIncParmCount
      0  03d5					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d5		       5d 0f		      .word.w	iTaskGetMathStack
      0  03d7					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d7		       97 0e		      .word.w	iTaskEnable
      0  03d9					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d9		       b1 0e		      .word.w	iTaskSuspend
      0  03db					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03db		       77 0f		      .word.w	iTaskPutMathPtr
      0  03dd					      dw	iTSTVT	;93	   test for another tasks variable
      1  03dd		       eb 09		      .word.w	iTSTVT
      0  03df					      dw	iSetR2	;94
      1  03df		       0f 09		      .word.w	iSetR2
      0  03e1					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e1		       d3 04		      .word.w	iStk2Tmp
      0  03e3					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e3		       e4 04		      .word.w	iTmp2Stk
      0  03e5					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e5		       a9 09		      .word.w	iTSTBYTE
    117  03e7
------- FILE mytb.asm
    480  03e7		       03 e7	   ILTBLend   equ	*
    481  03e7							;
    482  03e7							;=====================================================
    483  03e7							;=====================================================
    484  03e7							;=====================================================
    485  03e7							; This marks the start of the handlers for IL opcodes.
    486  03e7							;=====================================================
    487  03e7							;=====================================================
    488  03e7							;=====================================================
    489  03e7							;
    490  03e7							;
    491  03e7		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    492  03e9		       85 47		      sta	ILSTACKPTR
    493  03eb		       85 4a		      sta	MATHSTACKPTR
    494  03ed		       85 4d		      sta	GOSUBSTACKPTR
    495  03ef		       a9 40		      lda	#GOSUBSTACKSIZE*4
    496  03f1		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    497  03f3							;
    498  03f3		       a9 0f		      lda	#ProgramStart&$ff	;user prog
    499  03f5		       85 4f		      sta	CURPTR
    500  03f7		       8d b9 1c 	      sta	taskTable+1
    501  03fa		       8d 07 26 	      sta	PROGRAMEND
    502  03fd		       a9 26		      lda	#ProgramStart>>8
    503  03ff		       85 50		      sta	CURPTR+1
    504  0401		       8d ba 1c 	      sta	taskTable+2
    505  0404		       8d 08 26 	      sta	PROGRAMEND+1
    506  0407		       a9 80		      lda	#TASKACTIVE
    507  0409		       8d b8 1c 	      sta	taskTable	;Mark the first slot as active
    508  040c		       a9 01		      lda	#1
    509  040e		       8d b4 1d 	      sta	taskCounter	;there is always one task / Main task
    510  0411		       a9 c8		      lda	#TASKCYCLESDEFAULT
    511  0413		       8d b3 1d 	      sta	taskResetValue
    512  0416		       8d b2 1d 	      sta	taskCurrentCycles	; set up the task switch counts
    513  0419							;
    514  0419							; fall into XINIT...
    515  0419							;
    516  0419							;=====================================================
    517  0419							; This initializes for the start of the next line of
    518  0419							; BASIC text.
    519  0419							;
    520  0419		       78	   iXINIT     sei		;ensure interupts are off
    521  041a		       20 ae 0d 	      jsr	taskReset	;Clear the task table
    522  041d		       8d b4 1c 	      sta	IRQPending	; reset the irq pending
    523  0420		       8d b3 1c 	      sta	IRQStatus	; Make sure irqs are off
    524  0423
    525  0423		       4c b9 02    goodExit   jmp	NextIL
    526  0426							;
    527  0426							;=====================================================
    528  0426							; This check if the escape key has been entered
    529  0426							; then changes out of run mode. z Set if esc found
    530  0426				   BreakSet
    531  0426		       20 0f f0 	      jsr	ISCHAR
    532  0429		       f0 06		      beq	BreakNo
    533  042b		       20 ef 15 	      jsr	VGETCH
    534  042e		       c9 1b		      cmp	#$1B
    535  0430		       60		      rts
    536  0431				   BreakNo
    537  0431		       a9 01		      lda	#1
    538  0433		       60		      rts
    539  0434
    540  0434							;
    541  0434
    542  0434							;=====================================================
    543  0434							; Verify there is nothing else on this input line.
    544  0434							; If there is, generate an error.
    545  0434							;
    546  0434		       a4 51	   iDONE      ldy	CUROFF
    547  0436		       20 67 14 	      jsr	SkipSpaces
    548  0439		       b1 4f		      lda	(CURPTR),y
    549  043b		       f0 10		      beq	doneadv
    550  043d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    551  043f		       d0 05		      bne	idoneErr
    552  0441		       84 51		      sty	CUROFF
    553  0443		       4c b9 02 	      jmp	NextIL	; continue on this line
    554  0446
    555  0446				   idoneErr
    556  0446		       a2 04		      ldx	#ERR_EXTRA_STUFF
    557  0448		       a9 00		      lda	#0
    558  044a		       4c 02 06 	      jmp	iErr2
    559  044d							;
    560  044d							; Advance to the next line
    561  044d							;
    562  044d				   doneadv
    563  044d							;		 jsr	 FindNext2
    564  044d		       4c b9 02 	      jmp	NextIL
    565  0450							;
    566  0450							;=====================================================
    567  0450							; Print the string until a closing quote
    568  0450							;
    569  0450		       a4 51	   iPRS       ldy	CUROFF
    570  0452							;
    571  0452							; Odd logic here.  The main loop skipped any leading
    572  0452							; whitespace inside the quoted text, so move back to
    573  0452							; the quote, then move forward again.
    574  0452							;
    575  0452		       20 1c 16 	      jsr	PrtQuoted
    576  0455		       84 51		      sty	CUROFF
    577  0457		       4c b9 02 	      jmp	NextIL
    578  045a							;
    579  045a							;=====================================================
    580  045a							; Pop the top off the stack and print it as a signed
    581  045a							; decimal number.
    582  045a							;
    583  045a		       20 b7 13    iPRN       jsr	popR0
    584  045d		       20 7e 11 	      jsr	PrintDecimal
    585  0460		       4c b9 02 	      jmp	NextIL
    586  0463							;
    587  0463							;=====================================================
    588  0463							; Space to next zone.	Currently the code does not
    589  0463							; keep track of which column the output is on, so
    590  0463							; just print a tab.
    591  0463							;
    592  0463		       a9 09	   iSPC       lda	#TAB
    593  0465		       20 ec 15 	      jsr	VOUTCH
    594  0468		       4c b9 02 	      jmp	NextIL
    595  046b							;
    596  046b							;=====================================================
    597  046b							; If in immediate mode, jump to the address following
    598  046b							; the NXT instruction.  Else move to the next line of
    599  046b							; user code and continue.
    600  046b							;
    601  046b		       a5 62	   iNXT       lda	RunMode
    602  046d		       d0 03		      bne	iNxtRun	;in run mode
    603  046f							;
    604  046f							; Get address and jump to it.
    605  046f							;
    606  046f		       4c 05 09 	      jmp	iJMP
    607  0472							;
    608  0472				   iNxtRun
    609  0472		       a4 51		      ldy	CUROFF
    610  0474		       20 67 14 	      jsr	SkipSpaces
    611  0477		       b1 4f		      lda	(CURPTR),y
    612  0479		       c9 3a		      cmp	#COLON
    613  047b		       d0 09		      bne	iNxtRunGo
    614  047d		       c8		      iny
    615  047e		       20 67 14 	      jsr	SkipSpaces
    616  0481		       84 51		      sty	CUROFF
    617  0483		       4c 91 04 	      jmp	iNxtRun2
    618  0486
    619  0486				   iNxtRunGo
    620  0486		       20 5f 11 	      jsr	FindNextLine
    621  0489		       20 71 11 	      jsr	AtEnd
    622  048c		       d0 03		      bne	iNxtRun2	;not at end
    623  048e							;
    624  048e							; At the end of the program.  Pretend an END statement
    625  048e							; was found.
    626  048e							;
    627  048e		       4c eb 05    iFINv      jmp	iFIN
    628  0491							;
    629  0491		       20 d3 10    iNxtRun2   jsr	getILWord	;ignore next word
    630  0494		       4c b9 02 	      jmp	NextIL
    631  0497							;
    632  0497							;=====================================================
    633  0497							; XFER takes the number on top of the stack and looks
    634  0497							; for that line in the program, or the next line
    635  0497							; higher.  Ie, if it's 1 but there is no line 1, then
    636  0497							; find the next one after that.
    637  0497							;
    638  0497		       20 b7 13    iXFER      jsr	popR0
    639  049a		       20 1c 11 	      jsr	findLine
    640  049d		       20 71 11    iXFER2     jsr	AtEnd	;at end of user program?
    641  04a0		       f0 ec		      beq	iFINv
    642  04a2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    643  04a4		       84 51		      sty	CUROFF
    644  04a6		       a9 ff		      lda	#$ff
    645  04a8		       85 62		      sta	RunMode
    646  04aa							;
    647  04aa							; Transfer IL to STMT.  I don't like having this
    648  04aa							; hard-coded; fix it.
    649  04aa							;
    650  04aa		       a9 27		      lda	#STMT&$ff
    651  04ac		       85 43		      sta	ILPC
    652  04ae		       a9 18		      lda	#STMT>>8
    653  04b0		       85 44		      sta	ILPC+1
    654  04b2		       4c b9 02 	      jmp	NextIL
    655  04b5							;
    656  04b5							; Run
    657  04b5							;
    658  04b5				   iXferok
    659  04b5		       a9 ff		      lda	#$ff
    660  04b7		       85 62		      sta	RunMode	;we're running
    661  04b9							;
    662  04b9							; Need a more elegant way to do this
    663  04b9							;
    664  04b9		       a9 27		      lda	#STMT&$ff
    665  04bb		       85 43		      sta	ILPC
    666  04bd		       a9 18		      lda	#STMT>>8
    667  04bf		       85 44		      sta	ILPC+1
    668  04c1		       4c b9 02 	      jmp	NextIL
    669  04c4							;
    670  04c4							;=====================================================
    671  04c4							; Save the pointer to the next line to the call stack.
    672  04c4							;
    673  04c4		       20 4d 13    iSAV       jsr	pushLN
    674  04c7		       b0 03		      bcs	iSAVErr
    675  04c9		       4c b9 02 	      jmp	NextIL
    676  04cc
    677  04cc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    678  04ce		       a9 00	   iSAVErr2   lda	#0
    679  04d0		       4c 02 06 	      jmp	iErr2
    680  04d3							;====================================================
    681  04d3							; Move stack top to and from temp area
    682  04d3				   iStk2Tmp
    683  04d3		       20 b7 13 	      jsr	popR0
    684  04d6		       a5 52		      lda	R0
    685  04d8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    686  04da		       91 41		      sta	(VARIABLES),y
    687  04dc		       c8		      iny
    688  04dd		       a5 53		      lda	R0+1
    689  04df		       91 41		      sta	(VARIABLES),y
    690  04e1		       4c b9 02 	      jmp	NextIL
    691  04e4
    692  04e4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    693  04e6		       b1 41		      lda	(VARIABLES),y
    694  04e8		       85 52		      sta	R0
    695  04ea		       c8		      iny
    696  04eb		       b1 41		      lda	(VARIABLES),y
    697  04ed		       85 53		      sta	R0+1
    698  04ef		       20 33 13 	      jsr	pushR0
    699  04f2		       4c b9 02 	      jmp	NextIL
    700  04f5							;
    701  04f5							;=====================================================
    702  04f5							; Pop the next line from the call stack.
    703  04f5							;
    704  04f5		       20 72 13    iRET       jsr	popLN
    705  04f8		       b0 d2		      bcs	iSAVErr
    706  04fa		       a0 03		      ldy	#3
    707  04fc		       84 51		      sty	CUROFF
    708  04fe		       a9 00		      lda	#0
    709  0500		       8d b4 1c 	      sta	IRQPending
    710  0503		       58		      cli
    711  0504		       4c b9 02 	      jmp	NextIL
    712  0507							;
    713  0507							;=====================================================
    714  0507							; Return from GOSUB function
    715  0507							;
    716  0507		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    717  0509		       88		      dey
    718  050a		       b1 4b		      lda	(GOSUBSTACK),y
    719  050c		       c9 81		      cmp	#GOSUB_RTN_VALUE
    720  050e		       d0 04		      bne	iRSTRNoValue
    721  0510		       a9 01		      lda	#1
    722  0512		       d0 02		      bne	iRSTRExit
    723  0514				   iRSTRNoValue
    724  0514		       a9 00		      lda	#0
    725  0516				   iRSTRExit
    726  0516		       85 58		      sta	R2
    727  0518		       20 72 13 	      jsr	popLN
    728  051b		       b0 06		      bcs	iRSTRErr
    729  051d		       20 d9 0c 	      jsr	PopMathStackNow
    730  0520		       4c b9 02 	      jmp	NextIL
    731  0523
    732  0523		       ad b7 1c    iRSTRErr   lda	taskPtr	; Check if this is task zero
    733  0526		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    734  0528		       a5 58		      lda	R2
    735  052a		       d0 03		      bne	taskRet
    736  052c		       20 7d 16 	      jsr	pushFalse	; the result code by default is 0
    737  052f				   taskRet
    738  052f		       4c 40 0f 	      jmp	iETask	; not task zero then do a task end instead
    739  0532				   taskZeroEnd
    740  0532		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    741  0534		       d0 98		      bne	iSAVErr2
    742  0536							;
    743  0536							;=====================================================
    744  0536							; Compare items on stack.  Okay, so on input there are
    745  0536							; three things on the stack
    746  0536							;
    747  0536							;    EXPR2 <- Top of stack
    748  0536							;    OP    <- relational operator, next on stack
    749  0536							;    EXPR1 <- last item on stack
    750  0536							;
    751  0536							; Comparison is: EXPR1 <operator> EXPR2
    752  0536							;
    753  0536							; Operator is one of...
    754  0536							;
    755  0536							;    2 is =
    756  0536							;    1 is <
    757  0536							;    3 is <=
    758  0536							;    5 is <>
    759  0536							;    4 is >
    760  0536							;    6 is >=
    761  0536							;
    762  0536							; Those are bit-mapped:
    763  0536							;
    764  0536							;    xxxxxGEL
    765  0536							;
    766  0536							;    G = Greater than
    767  0536							;    E = Equal
    768  0536							;    L = Less than
    769  0536							;
    770  0536							; If the comparison is false, do a NXT, ie, move to the
    771  0536							; next line and continue.  If true, continue executing
    772  0536							; on this line.
    773  0536							;
    774  0536		       00 01	   REL_LT     equ	%001
    775  0536		       00 02	   REL_EQUAL  equ	%010
    776  0536		       00 04	   REL_GT     equ	%100
    777  0536							;
    778  0536		       20 cf 13    iCMPR      jsr	popR1
    779  0539		       20 e6 13 	      jsr	popMQ	;operator in MQ
    780  053c		       20 b7 13 	      jsr	popR0
    781  053f		       20 48 05 	      jsr	iCMPRsub
    782  0542		       20 33 13 	      jsr	pushR0
    783  0545		       4c b9 02 	      jmp	NextIL
    784  0548							;
    785  0548							; See if they are equal or not
    786  0548							;
    787  0548				   iCMPRsub		; Called by internal functions
    788  0548
    789  0548		       a5 52		      lda	R0
    790  054a		       c5 54		      cmp	R1
    791  054c		       d0 0a		      bne	iCMPRnoteq	;try not equal
    792  054e		       a5 53		      lda	R0+1
    793  0550		       c5 55		      cmp	R1+1
    794  0552		       d0 04		      bne	iCMPRnoteq
    795  0554							;
    796  0554							; Equal, set the flag in MQ+1
    797  0554							;
    798  0554		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    799  0556		       d0 14		      bne	iCMPcom	;Exit it is equal
    800  0558							;
    801  0558							; See if EXPR1 (R0) < EXPR2 (R1)
    802  0558							; See www.6502.org/tutorials/compare_beyond.html
    803  0558							;
    804  0558				   iCMPRnoteq
    805  0558		       a5 52		      lda	R0
    806  055a		       c5 54		      cmp	R1
    807  055c		       a5 53		      lda	R0+1
    808  055e		       e5 55		      sbc	R1+1
    809  0560		       50 02		      bvc	iCMPR_2
    810  0562		       49 80		      eor	#$80
    811  0564		       30 04	   iCMPR_2    bmi	iCMPlt
    812  0566		       a9 04		      lda	#REL_GT
    813  0568		       d0 02		      bne	iCMPcom
    814  056a		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    815  056c
    816  056c		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    817  056e							;
    818  056e							; Now compare the end result with what the caller
    819  056e							; was looking for.
    820  056e							;
    821  056e		       25 56		      and	MQ
    822  0570		       f0 0c		      beq	iCMPno	; no match
    823  0572		       a9 ff		      lda	#$FF	; true is $ffff
    824  0574		       85 52		      sta	R0
    825  0576		       85 53		      sta	R0+1
    826  0578		       d0 0c		      bne	iCMPDone
    827  057a							;
    828  057a							; R0 > R1
    829  057a							;
    830  057a		       a9 04	   iCMPgt     lda	#REL_GT
    831  057c		       d0 ee		      bne	iCMPcom
    832  057e				   iCMPno
    833  057e		       a9 00		      lda	#0
    834  0580		       85 52		      sta	R0
    835  0582		       a9 00		      lda	#0
    836  0584		       85 53		      sta	R0+1
    837  0586
    838  0586				   iCMPDone
    839  0586		       60		      rts
    840  0587
    841  0587							;
    842  0587							; if Not a match, so jump to the next line of code.
    843  0587							; Branches based upon value on top of the stack
    844  0587				   iBranch
    845  0587		       20 b7 13 	      jsr	popR0
    846  058a		       a5 52		      lda	R0
    847  058c		       05 53		      ora	R0+1
    848  058e		       f0 03		      beq	iBranchFalse	; not true
    849  0590		       4c b9 02 	      jmp	NextIL	; It is true if any value not zero
    850  0593							;
    851  0593				   iBranchFalse
    852  0593		       20 5f 11 	      jsr	FindNextLine
    853  0596		       4c 9d 04 	      jmp	iXFER2
    854  0599							;
    855  0599							;=====================================================
    856  0599							; Start a read of data in background
    857  0599				   iReadStart
    858  0599		       a9 3f		      lda	#'?	; Prompt with question mark
    859  059b		       a6 01		      ldx	1	; Indicate to start read in background
    860  059d		       20 55 12 	      jsr	GetLine	; Call the getline to start read
    861  05a0		       4c b9 02 	      jmp	NextIL	; next instruction
    862  05a3							;
    863  05a3							;=====================================================
    864  05a3							; Complete the read and return the curptr, curoff pointing to data
    865  05a3				   iReadComplete
    866  05a3		       20 4d 13 	      jsr	pushLN
    867  05a6		       90 03		      bcc	iReadOk
    868  05a8		       4c ff 0a    iReadErr   jmp	ErrStkOver	; Check if there was an error
    869  05ab				   iReadOk
    870  05ab		       20 75 12 	      jsr	ReadComplete
    871  05ae		       4c b9 02 	      jmp	NextIL
    872  05b1		       20 72 13 	      jsr	popLN
    873  05b4		       4c b9 02 	      jmp	NextIL
    874  05b7							;=====================================================
    875  05b7							; Get a line of text from the user, convert to a
    876  05b7							; number, leave on top of stack.
    877  05b7							;
    878  05b7				   iINNUM
    879  05b7		       20 4d 13 	      jsr	pushLN
    880  05ba		       b0 ec		      bcs	iReadErr	; Stack over flow error
    881  05bc							;
    882  05bc		       a9 3f		      lda	#'?
    883  05be		       a2 00		      ldx	#0	;Wait for complete
    884  05c0		       20 55 12 	      jsr	GetLine
    885  05c3		       20 ea 11 	      jsr	getDecimal
    886  05c6		       20 33 13 	      jsr	pushR0	;put onto stack
    887  05c9		       b0 dd		      bcs	iReadErr	;StackOverflow error
    888  05cb							;
    889  05cb		       4c e5 05 	      jmp	ExitIn
    890  05ce							;
    891  05ce							;=====================================================
    892  05ce							; Get a line of text from the user, convert to a
    893  05ce							; character value , leave on top of stack. up to 2 characters
    894  05ce							;
    895  05ce				   iINSTR
    896  05ce		       20 4d 13 	      jsr	pushLN
    897  05d1		       b0 d5		      bcs	iReadErr	; Stack overflow error
    898  05d3		       a9 3f		      lda	#'?
    899  05d5		       a2 00		      ldx	#0	;wait for read complete
    900  05d7		       20 55 12 	      jsr	GetLine
    901  05da		       b1 4f		      lda	(CURPTR),y
    902  05dc		       85 52		      sta	R0
    903  05de		       a9 00		      lda	#0
    904  05e0		       85 53		      sta	R0+1
    905  05e2		       20 33 13 	      jsr	pushR0	;put onto stack
    906  05e5				   ExitIn
    907  05e5		       20 72 13 	      jsr	popLN
    908  05e8		       4c b9 02 	      jmp	NextIL
    909  05eb							;
    910  05eb							;
    911  05eb							;=====================================================
    912  05eb							; Stop the currently running program.	Actually very
    913  05eb							; simple to do... clear the RunMode flag, then set the
    914  05eb							; ILPC to the standard handler and continue running.
    915  05eb							;
    916  05eb		       a9 00	   iFIN       lda	#0
    917  05ed		       85 62		      sta	RunMode
    918  05ef		       20 ae 0d 	      jsr	taskReset
    919  05f2							;
    920  05f2		       ad fb 25 	      lda	errGoto
    921  05f5		       85 43		      sta	ILPC
    922  05f7		       ad fc 25 	      lda	errGoto+1
    923  05fa		       85 44		      sta	ILPC+1
    924  05fc		       4c b9 02 	      jmp	NextIL
    925  05ff							;
    926  05ff							;=====================================================
    927  05ff							; Handle the ERR opcode.  Following the instruction is
    928  05ff							; a 16 bit error number.  Print an error message, and
    929  05ff							; if we're in run mode, print the line number.  Stop
    930  05ff							; program execution and return to the initial state.
    931  05ff							;
    932  05ff		       20 d3 10    iERR       jsr	getILWord	;get err code
    933  0602							;
    934  0602							; Enter here with the error code in X (LSB) and A (MSB).
    935  0602							;
    936  0602		       86 52	   iErr2      stx	R0
    937  0604		       85 53		      sta	R0+1
    938  0606							;
    939  0606		       20 f2 15 	      jsr	puts
      0  0609					      db	CR,LF,"Error ",0
      1  0609		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    941  0612		       20 7e 11 	      jsr	PrintDecimal
    942  0615							;
    943  0615		       a5 62		      lda	RunMode	;running?
    944  0617		       f0 3b		      beq	iERR3	;nope
    945  0619		       20 f2 15 	      jsr	puts
      0  061c					      db	" at line ",0
      1  061c		       20 61 74 20*	      .byte.b	" at line ",0
    947  0626		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    948  0628				   iErr2a
    949  0628		       b1 4f		      lda	(CURPTR),y
    950  062a		       85 52		      sta	R0
    951  062c		       c8		      iny
    952  062d		       b1 4f		      lda	(CURPTR),y
    953  062f		       85 53		      sta	R0+1
    954  0631		       20 7e 11 	      jsr	PrintDecimal
    955  0634		       20 f2 15 	      jsr	puts
      0  0637					      db	":",0
      1  0637		       3a 00		      .byte.b	":",0
    957  0639		       a9 00		      lda	#0
    958  063b		       85 53		      sta	R0+1
    959  063d		       a5 51		      lda	CUROFF
    960  063f		       18		      clc
    961  0640		       e9 03		      sbc	#3
    962  0642		       85 52		      sta	R0
    963  0644		       20 7e 11 	      jsr	PrintDecimal
    964  0647		       20 f2 15 	      jsr	puts
      0  064a					      db	":",0
      1  064a		       3a 00		      .byte.b	":",0
    966  064c		       ad b7 1c 	      lda	taskPtr
    967  064f		       85 52		      sta	R0
    968  0651		       20 7e 11 	      jsr	PrintDecimal
    969  0654							;
    970  0654		       20 70 14    iERR3      jsr	CRLF
    971  0657		       20 a6 0d 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    972  065a		       a9 00		      lda	#0
    973  065c		       85 62		      sta	RunMode	;fall through...
    974  065e							;
    975  065e							;=====================================================
    976  065e							; Reset the IL to be back at the idle loop.  Does not
    977  065e							; clear variables so the user can see what state
    978  065e							; the program is in.
    979  065e							;
    980  065e		       a9 00	   ResetIL    lda	#0
    981  0660		       85 47		      sta	ILSTACKPTR
    982  0662		       ad fb 25 	      lda	errGoto
    983  0665		       85 43		      sta	ILPC
    984  0667		       ad fc 25 	      lda	errGoto+1
    985  066a		       85 44		      sta	ILPC+1
    986  066c		       4c b9 02 	      jmp	NextIL
    987  066f
    988  066f							;
    989  066f							;=====================================================
    990  066f							; Pop two items off stack, add them, then place the
    991  066f							; result back onto the stack.
    992  066f							;
    993  066f		       20 b7 13    iADD       jsr	popR0
    994  0672		       20 cf 13 	      jsr	popR1
    995  0675				   iADDfast
    996  0675		       18		      clc
    997  0676		       a5 52		      lda	R0
    998  0678		       65 54		      adc	R1
    999  067a		       85 52		      sta	R0
   1000  067c		       a5 53		      lda	R0+1
   1001  067e		       65 55		      adc	R1+1
   1002  0680		       85 53		      sta	R0+1
   1003  0682		       4c ed 06 	      jmp	pushR0nextIl
   1004  0685							;
   1005  0685							;=====================================================
   1006  0685							; Pop two items off the stack.  Subtract the top of
   1007  0685							; stack from the lower entry.
   1008  0685							;
   1009  0685		       20 cf 13    iSUB       jsr	popR1
   1010  0688		       20 b7 13 	      jsr	popR0
   1011  068b		       38		      sec
   1012  068c		       a5 52		      lda	R0
   1013  068e		       e5 54		      sbc	R1
   1014  0690		       85 52		      sta	R0
   1015  0692		       a5 53		      lda	R0+1
   1016  0694		       e5 55		      sbc	R1+1
   1017  0696		       85 53		      sta	R0+1
   1018  0698		       4c ed 06 	      jmp	pushR0nextIl
   1019  069b							;
   1020  069b							;=====================================================
   1021  069b							; Negate the top of stack.
   1022  069b							;
   1023  069b		       20 b7 13    iNEG       jsr	popR0
   1024  069e		       a5 52		      lda	R0
   1025  06a0		       49 ff		      eor	#$ff
   1026  06a2		       85 52		      sta	R0
   1027  06a4		       a5 53		      lda	R0+1
   1028  06a6		       49 ff		      eor	#$ff
   1029  06a8		       85 53		      sta	R0+1
   1030  06aa		       e6 52		      inc	R0
   1031  06ac		       d0 02		      bne	iNEG2
   1032  06ae		       e6 53		      inc	R0+1
   1033  06b0		       4c ed 06    iNEG2      jmp	pushR0nextIl
   1034  06b3							;
   1035  06b3							;=====================================================
   1036  06b3							; Multiply top two items on the stack, put the results
   1037  06b3							; on top.  This uses the algorithm documented on page
   1038  06b3							; 115 of "Microprocessor Programming for Computer
   1039  06b3							; Hobbyists" by Neill Graham.
   1040  06b3							;
   1041  06b3		       20 b9 06    iMUL       jsr	iMultiply
   1042  06b6		       4c b9 02 	      jmp	NextIL
   1043  06b9
   1044  06b9				   iMultiply
   1045  06b9		       20 b7 13 	      jsr	popR0	;AC
   1046  06bc		       20 cf 13 	      jsr	popR1	;OP
   1047  06bf							;
   1048  06bf		       a5 52		      lda	R0
   1049  06c1		       85 56		      sta	MQ
   1050  06c3		       a5 53		      lda	R0+1
   1051  06c5		       85 57		      sta	MQ+1
   1052  06c7		       a9 00		      lda	#0	;clear result
   1053  06c9		       85 52		      sta	R0
   1054  06cb		       85 53		      sta	R0+1
   1055  06cd							;
   1056  06cd		       a2 10		      ldx	#16	;number of bits in value
   1057  06cf		       06 52	   multloop   asl	R0
   1058  06d1		       26 53		      rol	R0+1
   1059  06d3		       06 56		      asl	MQ
   1060  06d5		       26 57		      rol	MQ+1
   1061  06d7		       90 0d		      bcc	multno	;skip add if no carry
   1062  06d9							;
   1063  06d9							; Add R1 back into R0
   1064  06d9							;
   1065  06d9		       18		      clc
   1066  06da		       a5 52		      lda	R0
   1067  06dc		       65 54		      adc	R1
   1068  06de		       85 52		      sta	R0
   1069  06e0		       a5 53		      lda	R0+1
   1070  06e2		       65 55		      adc	R1+1
   1071  06e4		       85 53		      sta	R0+1
   1072  06e6							;
   1073  06e6		       ca	   multno     dex		;did all bits yet?
   1074  06e7		       d0 e6		      bne	multloop
   1075  06e9		       20 33 13 	      jsr	pushR0	;OP
   1076  06ec		       60		      rts
   1077  06ed							;
   1078  06ed				   pushR0nextIl
   1079  06ed		       20 33 13 	      jsr	pushR0	;OP
   1080  06f0		       4c b9 02 	      jmp	NextIL
   1081  06f3							;
   1082  06f3							;=====================================================
   1083  06f3							; Divide the top of stack into the next to top item.
   1084  06f3							; Leave results on stack.  Taken from:
   1085  06f3							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1086  06f3							;
   1087  06f3							; R0 = R0 / R1
   1088  06f3							; Remainder is in MQ
   1089  06f3							;
   1090  06f3		       20 0d 07    iDIV       jsr	iDoDiv
   1091  06f6		       20 38 14 	      jsr	RestoreSigns
   1092  06f9		       4c ed 06 	      jmp	pushR0nextIl
   1093  06fc
   1094  06fc		       20 0d 07    iMOD       jsr	iDoDiv
   1095  06ff		       20 38 14 	      jsr	RestoreSigns
   1096  0702		       a5 56		      lda	MQ
   1097  0704		       85 52		      sta	R0
   1098  0706		       a5 57		      lda	MQ+1
   1099  0708		       85 53		      sta	R0+1
   1100  070a		       4c ed 06 	      jmp	pushR0nextIl
   1101  070d
   1102  070d				   iDoDiv
   1103  070d		       20 cf 13 	      jsr	popR1
   1104  0710		       20 b7 13 	      jsr	popR0
   1105  0713							;
   1106  0713							; Check for divide by zero
   1107  0713							;
   1108  0713
   1109  0713				   iDivNoPop
   1110  0713		       a5 54		      lda	R1
   1111  0715		       05 55		      ora	R1+1
   1112  0717		       f0 29		      beq	divby0
   1113  0719							;
   1114  0719		       20 fd 13 	      jsr	SaveSigns
   1115  071c		       a9 00		      lda	#0	;preset remainder to 0
   1116  071e		       85 56		      sta	MQ
   1117  0720		       85 57		      sta	MQ+1
   1118  0722		       a2 10		      ldx	#16	;repeat for each bit: ...
   1119  0724				   divloop
   1120  0724		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1121  0726		       26 53		      rol	R0+1
   1122  0728		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1123  072a		       26 57		      rol	MQ+1
   1124  072c		       a5 56		      lda	MQ
   1125  072e		       38		      sec
   1126  072f		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1127  0731		       a8		      tay		;lb result -> Y, for we may need it later
   1128  0732		       a5 57		      lda	MQ+1
   1129  0734		       e5 55		      sbc	R1+1
   1130  0736		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1131  0738
   1132  0738		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1133  073a		       84 56		      sty	MQ
   1134  073c		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1135  073e
   1136  073e		       ca	   skip       dex
   1137  073f		       d0 e3		      bne	divloop
   1138  0741		       60		      rts
   1139  0742							;
   1140  0742							; Indicate divide-by-zero error
   1141  0742							;
   1142  0742		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1143  0744		       a9 00		      lda	#0
   1144  0746		       4c 02 06 	      jmp	iErr2
   1145  0749							;
   1146  0749							;=====================================================
   1147  0749							; This pops the top two items off the stack.  The top
   1148  0749							; item is a data value and the other is an ABSOLUTE address.
   1149  0749							;Save the value into that address.
   1150  0749							;
   1151  0749		       98	   iSTORE     tya
   1152  074a		       48		      pha
   1153  074b		       20 b7 13 	      jsr	popR0	;data
   1154  074e		       20 cf 13 	      jsr	popR1	;Storage location
   1155  0751		       a0 00		      ldy	#0
   1156  0753		       a5 52		      lda	R0
   1157  0755		       91 54		      sta	(R1),y
   1158  0757		       a5 53		      lda	R0+1
   1159  0759		       c8		      iny
   1160  075a		       91 54		      sta	(R1),y
   1161  075c		       68		      pla
   1162  075d		       a8		      tay
   1163  075e		       4c b9 02 	      jmp	NextIL
   1164  0761							;
   1165  0761							;=====================================================
   1166  0761							; Replaces the top of stack with the variable whose
   1167  0761							; absolute address it represents.
   1168  0761							;
   1169  0761		       98	   iIND       tya
   1170  0762		       48		      pha
   1171  0763		       20 cf 13 	      jsr	popR1
   1172  0766		       a0 00		      ldy	#0
   1173  0768		       b1 54		      lda	(R1),y
   1174  076a		       85 52		      sta	R0
   1175  076c		       c8		      iny
   1176  076d		       b1 54		      lda	(R1),y
   1177  076f		       85 53		      sta	R0+1
   1178  0771		       68		      pla
   1179  0772		       a8		      tay
   1180  0773		       4c ed 06 	      jmp	pushR0nextIl
   1181  0776							;
   1182  0776							;=====================================================
   1183  0776							; Get the array index from top of stack get Current variable
   1184  0776							; address from next on stack, add the offset
   1185  0776							; push the result back onto the stack
   1186  0776				   iArray
   1187  0776		       20 b7 13 	      jsr	popR0	; Get the array index
   1188  0779		       20 cf 13 	      jsr	popR1	; Get the Variable address
   1189  077c
   1190  077c		       18		      clc		; Multiplythe value by 2
   1191  077d		       26 52		      rol	R0	; Do the multiply
   1192  077f		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1193  0781		       18		      clc
   1194  0782		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1195  0784		       65 52		      adc	R0
   1196  0786		       85 52		      sta	R0
   1197  0788		       a5 55		      lda	R1+1
   1198  078a		       65 53		      adc	R0+1
   1199  078c		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1200  078e		       20 33 13 	      jsr	pushR0	; Push R0 assume it is correct
   1201  0791
   1202  0791		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1203  0793		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1204  0795		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1205  0797		       a5 55		      lda	R1+1
   1206  0799		       c5 42		      cmp	VARIABLES+1
   1207  079b		       d0 1c		      bne	iArrayAtTest
   1208  079d		       18		      clc
   1209  079e		       a9 34		      lda	#52	; add the max offset that is valid
   1210  07a0		       65 54		      adc	R1	; update to be the largest offset that is valid
   1211  07a2		       85 54		      sta	R1
   1212  07a4		       a9 00		      lda	#0
   1213  07a6		       65 55		      adc	R1+1
   1214  07a8		       85 55		      sta	R1+1
   1215  07aa				   iArrayVerify 		; try to enforce some sanity to using arrays
   1216  07aa		       a5 53		      lda	R0+1
   1217  07ac		       c5 55		      cmp	R1+1
   1218  07ae		       d0 04		      bne	iArrayDecide
   1219  07b0		       a5 52		      lda	R0
   1220  07b2		       c5 54		      cmp	R1
   1221  07b4				   iArrayDecide
   1222  07b4		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1223  07b6		       4c b9 02 	      jmp	NextIL
   1224  07b9
   1225  07b9				   iArrayAtTest
   1226  07b9		       ad 09 26 	      lda	HighMem
   1227  07bc		       85 54		      sta	R1
   1228  07be		       ad 0a 26 	      lda	HighMem+1
   1229  07c1		       85 55		      sta	R1+1
   1230  07c3		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1231  07c5
   1232  07c5							; Get here if array index is out of range
   1233  07c5		       20 b7 13    iArrayError jsr	popR0
   1234  07c8		       a9 00		      lda	#0
   1235  07ca		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1236  07cc		       4c 02 06 	      jmp	iErr2
   1237  07cf							;
   1238  07cf							;=====================================================
   1239  07cf							; List the current BASIC program in memory.  Uses R0,
   1240  07cf							; tempIly, and dpl.
   1241  07cf							;
   1242  07cf		       20 d2 15    iLST       jsr	SetOutConsole
   1243  07d2		       a9 0f	   iLST2      lda	#ProgramStart&$ff
   1244  07d4		       85 59		      sta	dpl
   1245  07d6		       a9 26		      lda	#ProgramStart>>8
   1246  07d8		       85 5a		      sta	dpl+1
   1247  07da							;
   1248  07da							; dpl/dph point to the current line.  See if we're at
   1249  07da							; the end of the program.
   1250  07da							;
   1251  07da		       a5 59	   iLSTloop   lda	dpl
   1252  07dc		       cd 07 26 	      cmp	PROGRAMEND
   1253  07df		       d0 07		      bne	iLstNotEnd
   1254  07e1		       a5 5a		      lda	dpl+1
   1255  07e3		       cd 08 26 	      cmp	PROGRAMEND+1
   1256  07e6		       f0 40		      beq	iLstdone
   1257  07e8							;
   1258  07e8		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1259  07ea		       b1 59		      lda	(dpl),y	;line number LSB
   1260  07ec		       85 52		      sta	R0
   1261  07ee		       c8		      iny
   1262  07ef		       b1 59		      lda	(dpl),y	;line number MSB
   1263  07f1		       85 53		      sta	R0+1
   1264  07f3		       c8		      iny
   1265  07f4		       84 5d		      sty	tempIlY
   1266  07f6		       20 7e 11 	      jsr	PrintDecimal
   1267  07f9		       a9 20		      lda	#SPACE
   1268  07fb		       20 ec 15 	      jsr	VOUTCH
   1269  07fe		       a4 5d		      ldy	tempIlY
   1270  0800		       b1 59	   iLSTl2     lda	(dpl),y
   1271  0802		       f0 0a		      beq	iLST3	;end of this line 0 value
   1272  0804		       84 5d		      sty	tempIlY
   1273  0806		       20 ec 15 	      jsr	VOUTCH
   1274  0809		       a4 5d		      ldy	tempIlY
   1275  080b		       c8		      iny
   1276  080c		       d0 f2		      bne	iLSTl2	;do next char
   1277  080e							;
   1278  080e							; End of this line.  Print CR/LF, then move to the
   1279  080e							; next line.
   1280  080e							;
   1281  080e		       c8	   iLST3      iny		;Move to next line
   1282  080f		       18		      clc		;Clear the carry flag
   1283  0810		       98		      tya		;Current Offset
   1284  0811		       65 59		      adc	dpl	;Add the offset to the pointer
   1285  0813		       85 59		      sta	dpl	;Save the new value
   1286  0815		       a5 5a		      lda	dpl+1	;Next byte
   1287  0817		       69 00		      adc	#0	;ad in the carry if any
   1288  0819		       85 5a		      sta	dpl+1	;Save it
   1289  081b							;
   1290  081b							; Have to manually do CR/LF so it uses the vectored
   1291  081b							; output function.
   1292  081b							;
   1293  081b		       a9 0d		      lda	#CR
   1294  081d		       20 ec 15 	      jsr	VOUTCH
   1295  0820		       a9 0a		      lda	#LF
   1296  0822		       20 ec 15 	      jsr	VOUTCH
   1297  0825		       4c da 07 	      jmp	iLSTloop	;do next line
   1298  0828							;
   1299  0828		       20 d2 15    iLstdone   jsr	SetOutConsole
   1300  082b		       4c b9 02 	      jmp	NextIL
   1301  082e							;
   1302  082e							;=====================================================
   1303  082e							; Get a line of text into LINBUF.  Terminate with a
   1304  082e							; null byte.
   1305  082e							;
   1306  082e				   iGETLINE
   1307  082e		       a9 3e		      lda	#'>	;prompt character
   1308  0830		       a6 00		      ldx	0	;Wait for read to complete
   1309  0832		       20 55 12 	      jsr	GetLine
   1310  0835							;
   1311  0835		       a9 00		      lda	#0
   1312  0837		       85 62		      sta	RunMode
   1313  0839		       4c b9 02 	      jmp	NextIL
   1314  083c							;
   1315  083c							;=====================================================
   1316  083c							; This is called when the input buffer contains a line
   1317  083c							; typed in by the user that starts with a line number.
   1318  083c							; Insert the line into the program or delete the line
   1319  083c							; if there is nothing after the line number,
   1320  083c							;
   1321  083c		       a0 00	   iINSRT     ldy	#0
   1322  083e		       20 ea 11 	      jsr	getDecimal	;convert line #
   1323  0841		       20 67 14 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1324  0844		       84 5e		      sty	offset	;Save the start of the program line text
   1325  0846							;
   1326  0846							; Now find the line OR the next higher line OR the
   1327  0846							; end of the program.
   1328  0846							;
   1329  0846		       20 1c 11 	      jsr	findLine	; Look for the line number in the current program
   1330  0849							; Returns Z and curptr point to the line if found
   1331  0849							; Returns C and curptr at next higher line if not found and there is a higher line
   1332  0849							; Returns ZC clear and curptr to end of program if higher than all other lines
   1333  0849							;
   1334  0849							; If the line exists, it needs to be removed.
   1335  0849							;
   1336  0849		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1337  084b							;
   1338  084b							; Get length of line to be removed, we fall thru to here if we find a matching line
   1339  084b							;
   1340  084b							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1341  084b		       a0 00		      ldy	#0
   1342  084d		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1343  084f		       a8		      tay
   1344  0850							;If it is equal we delete the line and replace it, get length
   1345  0850							;then adjust all program line after up or down depending on len of line
   1346  0850							;If next higher then just move everythimg down by length bytes
   1347  0850							;This call will return how many bytes in the line we found
   1348  0850		       84 5f		      sty	lineLength	;Save the length of the line we found
   1349  0852							;
   1350  0852							; Compute the new end of the program first.
   1351  0852							;
   1352  0852		       38		      sec		;Set the carry bit
   1353  0853		       ad 07 26 	      lda	PROGRAMEND	;Get low byte of program end
   1354  0856		       e5 5f		      sbc	lineLength	;Subtract the length of the current line
   1355  0858		       8d 07 26 	      sta	PROGRAMEND	;save it
   1356  085b		       ad 08 26 	      lda	PROGRAMEND+1
   1357  085e		       e9 00		      sbc	#0	;Process the carry
   1358  0860		       8d 08 26 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1359  0863							;
   1360  0863							; Copy CURPTR into R1 for working
   1361  0863							;
   1362  0863		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1363  0865		       85 54		      sta	R1
   1364  0867		       a5 50		      lda	CURPTR+1
   1365  0869		       85 55		      sta	R1+1
   1366  086b							;
   1367  086b							; See if we're at the end.
   1368  086b							;
   1369  086b		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1370  086d		       cd 07 26 	      cmp	PROGRAMEND
   1371  0870		       d0 07		      bne	InsDelLoop
   1372  0872		       a5 55		      lda	R1+1
   1373  0874		       cd 08 26 	      cmp	PROGRAMEND+1
   1374  0877		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1375  0879							;
   1376  0879							; Move one byte, move to next location.
   1377  0879							;
   1378  0879		       a4 5f	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1379  087b		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1380  087d		       b1 54		      lda	(R1),y
   1381  087f		       a0 00		      ldy	#0
   1382  0881		       91 54		      sta	(R1),y
   1383  0883		       e6 54		      inc	R1
   1384  0885		       d0 e4		      bne	InsDelChk
   1385  0887		       e6 55		      inc	R1+1
   1386  0889		       4c 6b 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1387  088c							;
   1388  088c							; Deletion is done.
   1389  088c							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1390  088c							;
   1391  088c		       a4 5e	   insert2    ldy	offset	;get back ptr	Get the current offset
   1392  088e		       b9 71 25 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1393  0891		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1394  0893							;
   1395  0893							; CURPTR points to where the line will be inserted.
   1396  0893							;
   1397  0893		       20 0f 13 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1398  0896							;
   1399  0896		       ad 07 26 	      lda	PROGRAMEND	;Load the start address for the copy
   1400  0899							;At this point curptr still contains the location we will insert data
   1401  0899		       85 63		      sta	FROM
   1402  089b		       ad 08 26 	      lda	PROGRAMEND+1
   1403  089e		       85 64		      sta	FROM+1
   1404  08a0							;
   1405  08a0		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1406  08a2		       b1 63		      lda	(FROM),y
   1407  08a4		       a4 5f		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1408  08a6		       91 63		      sta	(FROM),y	;Save the new byte
   1409  08a8							;
   1410  08a8		       a5 63		      lda	FROM	;Check if we have copies the last byte
   1411  08aa		       c5 4f		      cmp	CURPTR
   1412  08ac		       d0 06		      bne	mvUpMore
   1413  08ae		       a5 64		      lda	FROM+1
   1414  08b0		       c5 50		      cmp	CURPTR+1
   1415  08b2		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1416  08b4							;
   1417  08b4							; Not done yet
   1418  08b4							;
   1419  08b4		       a5 63	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1420  08b6		       d0 02		      bne	mvUpMore2
   1421  08b8		       c6 64		      dec	FROM+1
   1422  08ba		       c6 63	   mvUpMore2  dec	FROM
   1423  08bc		       4c a0 08 	      jmp	mvup1	;Loop until everything is moved
   1424  08bf							;
   1425  08bf							; All done with copy.
   1426  08bf							;
   1427  08bf		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1428  08c0		       a5 5f		      lda	lineLength	;Number of bytes to copy from line buff
   1429  08c2		       6d 07 26 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1430  08c5		       8d 07 26 	      sta	PROGRAMEND
   1431  08c8		       ad 08 26 	      lda	PROGRAMEND+1
   1432  08cb		       69 00		      adc	#0
   1433  08cd		       8d 08 26 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1434  08d0							;
   1435  08d0							;===================jlit use length before line newline
   1436  08d0
   1437  08d0		       a0 00		      ldy	#0	;Set offset of copy
   1438  08d2		       a5 5f		      lda	lineLength	;We will insert the actual length of the line first
   1439  08d4		       91 4f		      sta	(CURPTR),y	;Store the length
   1440  08d6		       c8		      iny
   1441  08d7		       a5 52		      lda	R0	;Store the line number next
   1442  08d9		       91 4f		      sta	(CURPTR),y
   1443  08db		       c8		      iny
   1444  08dc		       a5 53		      lda	R0+1
   1445  08de		       91 4f		      sta	(CURPTR),y
   1446  08e0		       c8		      iny
   1447  08e1							;
   1448  08e1		       a6 5e		      ldx	offset	;Load the offset into line buffer in page zero
   1449  08e3		       bd 71 25    mvUpLoop2  lda	LINBUF,x	;get a byte
   1450  08e6		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1451  08e8		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1452  08ea		       e8		      inx
   1453  08eb		       c8		      iny
   1454  08ec		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1455  08ee							;
   1456  08ee		       4c b9 02    mvUpFini   jmp	NextIL
   1457  08f1							;
   1458  08f1							;=====================================================
   1459  08f1							; Pops the top value of the ILPC stack and stores it
   1460  08f1							; in ILPC.  Ie, return from an IL subroutine.
   1461  08f1							;
   1462  08f1		       20 0a 11    iRTN       jsr	popILPC
   1463  08f4		       4c b9 02 	      jmp	NextIL
   1464  08f7							;
   1465  08f7							;=====================================================
   1466  08f7							; NLINE print a newline
   1467  08f7							;
   1468  08f7		       20 70 14    iNLINE     jsr	CRLF	;user supplied sub
   1469  08fa		       4c b9 02 	      jmp	NextIL
   1470  08fd							;
   1471  08fd							;=====================================================
   1472  08fd							; This saves the current ILPC value on the stack, then
   1473  08fd							; jumps to the address specified by the next two bytes.
   1474  08fd							;
   1475  08fd		       20 ed 10    iCALL      jsr	pushILPC	;save ILPC
   1476  0900		       90 03		      bcc	iJMP
   1477  0902		       4c ff 0a 	      jmp	ErrStkOver	; Check if there was an error
   1478  0905							;
   1479  0905							; Jmp to a specific location in the IL code.  The new
   1480  0905							; address immediately follows the opcode.
   1481  0905							;
   1482  0905		       20 d3 10    iJMP       jsr	getILWord
   1483  0908		       86 43		      stx	ILPC
   1484  090a		       85 44		      sta	ILPC+1
   1485  090c		       4c b9 02 	      jmp	NextIL
   1486  090f
   1487  090f
   1488  090f							;
   1489  090f							;=====================================================
   1490  090f							; Push the next two bytes onto the arithmetic stack.
   1491  090f							;
   1492  090f		       20 d7 10    iSetR2     jsr	getILByte
   1493  0912		       86 58		      stx	R2
   1494  0914		       4c b9 02 	      jmp	NextIL
   1495  0917							;
   1496  0917							;=====================================================
   1497  0917							; Push the next two bytes onto the arithmetic stack.
   1498  0917							;
   1499  0917		       20 d3 10    iLIT       jsr	getILWord
   1500  091a		       86 52		      stx	R0
   1501  091c		       85 53		      sta	R0+1
   1502  091e		       20 33 13 	      jsr	pushR0
   1503  0921		       4c b9 02 	      jmp	NextIL
   1504  0924							;
   1505  0924							;=====================================================
   1506  0924							; Initialize all variables for a single task.	Ie, set to zero.
   1507  0924							;
   1508  0924		       98	   subVINIT   tya
   1509  0925		       48		      pha
   1510  0926
   1511  0926		       a9 00		      lda	#0
   1512  0928		       a0 00		      ldy	#0
   1513  092a		       91 41	   Vinit2     sta	(VARIABLES),y
   1514  092c		       c8		      iny
   1515  092d		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1516  092f		       90 f9		      bcc	Vinit2
   1517  0931
   1518  0931		       68		      pla
   1519  0932		       a8		      tay
   1520  0933		       60		      rts
   1521  0934
   1522  0934		       20 24 09    iVINIT     jsr	subVINIT
   1523  0937		       4c b9 02 	      jmp	NextIL
   1524  093a							;
   1525  093a							;=====================================================
   1526  093a							; Set the address of the error handler.  After any
   1527  093a							; error, set to the ILPC to the specified location.
   1528  093a							;
   1529  093a		       20 d3 10    iERRGOTO   jsr	getILWord
   1530  093d		       8e fb 25 	      stx	errGoto
   1531  0940		       8d fc 25 	      sta	errGoto+1
   1532  0943		       4c b9 02 	      jmp	NextIL
   1533  0946							;
   1534  0946							;=====================================================
   1535  0946							; TST is followed by an 8 bit signed offset, then a
   1536  0946							; null terminated string.  Compare the string against
   1537  0946							; the string starting at (CURPTR),CUROFF.  If the
   1538  0946							; strings match, continue executing the next IL
   1539  0946							; opcode.  Else, add the offset to ILPC.
   1540  0946							;
   1541  0946		       20 d7 10    iTST       jsr	getILByte	;Get the relative jump address
   1542  0949		       85 5e		      sta	offset	;save it to use if test faile
   1543  094b		       20 21 13 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1544  094e
   1545  094e		       a4 51		      ldy	CUROFF
   1546  0950		       84 59		      sty	dpl	;save for later
   1547  0952							;
   1548  0952		       20 d7 10    iTSTloop   jsr	getILByte	;get next char
   1549  0955		       f0 11		      beq	iTSTm	;match!
   1550  0957		       a4 59		      ldy	dpl
   1551  0959		       d1 4f		      cmp	(CURPTR),y
   1552  095b		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1553  095d		       09 20		      ora	#$20	; lets allow lowercase as well
   1554  095f		       d1 4f		      cmp	(CURPTR),y
   1555  0961		       d0 22		      bne	iTSTfail	;mismatch
   1556  0963		       c8	   iTSTUpper  iny
   1557  0964		       84 59		      sty	dpl
   1558  0966		       d0 ea		      bne	iTSTloop
   1559  0968							;
   1560  0968							; It's a match!  Clean up a bit.
   1561  0968							;
   1562  0968		       a4 59	   iTSTm      ldy	dpl
   1563  096a		       84 51		      sty	CUROFF
   1564  096c		       4c b9 02 	      jmp	NextIL
   1565  096f
   1566  096f							; Test for a single quote string
   1567  096f		       20 d7 10    iTSTStr    jsr	getILByte
   1568  0972		       85 5e		      sta	offset
   1569  0974		       20 21 13 	      jsr	saveIL
   1570  0977		       a4 51		      ldy	CUROFF
   1571  0979		       a9 22		      lda	#'"
   1572  097b		       d1 4f		      cmp	(CURPTR),y
   1573  097d		       d0 06		      bne	iTSTfail
   1574  097f		       c8		      iny
   1575  0980		       84 51		      sty	CUROFF
   1576  0982		       4c da 02 	      jmp	NextILStr
   1577  0985							;
   1578  0985							; Not a match, reset ILPC and then move to the
   1579  0985							; offset.
   1580  0985							;
   1581  0985		       20 2a 13    iTSTfail   jsr	restoreIL
   1582  0988		       4c b1 0a 	      jmp	tstBranch
   1583  098b							;
   1584  098b							;=================================================JLIT=
   1585  098b							; Test if we have a let statement without the let keyword
   1586  098b		       20 d7 10    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1587  098e		       85 5e		      sta	offset	; Save the jump offset for fails
   1588  0990		       20 21 13 	      jsr	saveIL	; save to restore when done if fail
   1589  0993
   1590  0993		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1591  0995		       20 67 14 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1592  0998		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1593  0999		       20 67 14 	      jsr	SkipSpaces	; skip any SkipSpaces
   1594  099c		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1595  099e		       c9 3d		      cmp	#'=	; check if equals
   1596  09a0		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1597  09a2		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1598  09a4		       d0 df		      bne	iTSTfail	; return it failed
   1599  09a6
   1600  09a6				   iTSTLETGOOD
   1601  09a6		       4c b9 02 	      jmp	NextIL	; Then next instruction
   1602  09a9
   1603  09a9							;=================================================JLIT=
   1604  09a9							;
   1605  09a9		       20 d7 10    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1606  09ac		       85 5e		      sta	offset	; Save the jump offset for fails
   1607  09ae		       20 21 13 	      jsr	saveIL	; save to restore when done if fail
   1608  09b1		       20 d3 10 	      jsr	getILWord	; Get a word into RO
   1609  09b4		       86 52		      stx	R0
   1610  09b6		       85 53		      sta	R0+1
   1611  09b8		       20 d7 10 	      jsr	getILByte	; Get byte into A
   1612  09bb		       a0 00		      ldy	#0
   1613  09bd		       d1 52		      cmp	(R0),y
   1614  09bf		       d0 03		      bne	iTSTByteNotEqual
   1615  09c1		       4c 85 09 	      jmp	iTSTfail
   1616  09c4
   1617  09c4				   iTSTByteNotEqual
   1618  09c4		       4c b9 02 	      jmp	NextIL	; Then next instruction
   1619  09c7
   1620  09c7
   1621  09c7							;================================================jLIT=
   1622  09c7							;Test for end of line
   1623  09c7							;
   1624  09c7		       20 d7 10    iTSTDONE   jsr	getILByte
   1625  09ca		       85 5e		      sta	offset
   1626  09cc		       20 21 13 	      jsr	saveIL
   1627  09cf		       a4 51		      ldy	CUROFF
   1628  09d1		       84 59		      sty	dpl
   1629  09d3		       20 67 14 	      jsr	SkipSpaces
   1630  09d6		       b1 4f		      lda	(CURPTR),y
   1631  09d8		       f0 0b		      beq	iTSTDONEtrue
   1632  09da		       c9 3a		      cmp	#COLON
   1633  09dc		       f0 07		      beq	iTSTDONEtrue
   1634  09de		       a4 59		      ldy	dpl
   1635  09e0		       84 51		      sty	CUROFF
   1636  09e2		       4c 85 09 	      jmp	iTSTfail
   1637  09e5							;
   1638  09e5							; Advance to the next line
   1639  09e5							;
   1640  09e5				   iTSTDONEtrue
   1641  09e5		       4c b9 02 	      jmp	NextIL
   1642  09e8
   1643  09e8		       4c b1 0a    tstBranchLink jmp	tstBranch
   1644  09eb							;
   1645  09eb							;=====================================================
   1646  09eb							; TSTV is followed by an 8 bit signed offset.	If the
   1647  09eb							; value at (CURPTR),CUROFF appears to be a variable
   1648  09eb							; name, move to the next IL statement.  Else, add the
   1649  09eb							; offset to ILPC. Converted to use actual absolute memory addresses
   1650  09eb							; TSTVT Looks for the task context
   1651  09eb							;
   1652  09eb		       20 cf 13    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1653  09ee		       a9 00		      lda	#0
   1654  09f0		       85 58		      sta	R2
   1655  09f2		       f0 04		      beq	iTSTVV
   1656  09f4
   1657  09f4		       a9 01	   iTSTV      lda	#1
   1658  09f6		       85 58		      sta	R2
   1659  09f8
   1660  09f8		       20 d7 10    iTSTVV     jsr	getILByte	;offset
   1661  09fb		       85 5e		      sta	offset
   1662  09fd							;
   1663  09fd		       a4 51		      ldy	CUROFF
   1664  09ff		       20 67 14 	      jsr	SkipSpaces
   1665  0a02		       b1 4f		      lda	(CURPTR),y
   1666  0a04		       d0 03		      bne	iTSTVnext
   1667  0a06		       4c e8 09 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1668  0a09							;
   1669  0a09				   iTSTVnext
   1670  0a09		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1671  0a0b		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1672  0a0d
   1673  0a0d		       c9 23		      cmp	#'#	; parameters passed to this task
   1674  0a0f		       f0 53		      beq	iTSTVParm
   1675  0a11
   1676  0a11		       c9 5e		      cmp	#'^	; task exit code
   1677  0a13		       d0 04		      bne	iTSTV_A2Z
   1678  0a15		       a9 19		      lda	#TASKEXITCODE
   1679  0a17		       d0 10		      bne	iTSTVContinue
   1680  0a19
   1681  0a19				   iTSTV_A2Z
   1682  0a19		       09 20		      ora	#$20	;make lower then upper
   1683  0a1b		       49 20		      eor	#$20	;allow lower case here
   1684  0a1d		       c9 41		      cmp	#'A
   1685  0a1f		       90 c7		      bcc	tstBranchLink
   1686  0a21		       c9 5b		      cmp	#'Z+1
   1687  0a23		       b0 c3		      bcs	tstBranchLink
   1688  0a25
   1689  0a25
   1690  0a25							;
   1691  0a25							; The condition is true, so convert to an index, push
   1692  0a25							; it onto the stack and continue running.
   1693  0a25							;
   1694  0a25		       38		      sec
   1695  0a26		       e9 41		      sbc	#'A	;index is zero based
   1696  0a28		       0a		      asl		;multiply by two
   1697  0a29
   1698  0a29				   iTSTVContinue
   1699  0a29		       c8		      iny
   1700  0a2a		       84 51		      sty	CUROFF	;it is a valid variable
   1701  0a2c		       48		      pha
   1702  0a2d		       a5 58		      lda	R2
   1703  0a2f		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1704  0a31
   1705  0a31		       20 ba 10 	      jsr	ipc_getcontext	; Get the other tasks variables
   1706  0a34		       a0 01		      ldy	#VARIABLEPOS
   1707  0a36		       b1 56		      lda	(MQ),y
   1708  0a38		       85 52		      sta	R0
   1709  0a3a		       c8		      iny
   1710  0a3b		       b1 56		      lda	(MQ),y
   1711  0a3d		       85 53		      sta	R0+1
   1712  0a3f		       4c 4a 0a 	      jmp	iTSTVAddOffset
   1713  0a42
   1714  0a42				   iTSTVLocalValue
   1715  0a42		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1716  0a44		       85 52		      sta	R0
   1717  0a46		       a5 42		      lda	VARIABLES+1
   1718  0a48		       85 53		      sta	R0+1
   1719  0a4a
   1720  0a4a				   iTSTVAddOffset
   1721  0a4a		       68		      pla
   1722  0a4b		       85 54		      sta	R1
   1723  0a4d		       a9 00		      lda	#0
   1724  0a4f		       85 55		      sta	R1+1
   1725  0a51
   1726  0a51				   iTSTVcontinue
   1727  0a51
   1728  0a51		       4c 75 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1729  0a54
   1730  0a54							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1731  0a54							; an array of integer values
   1732  0a54				   iTSTVat
   1733  0a54		       c8		      iny
   1734  0a55		       84 51		      sty	CUROFF	;it is a valid variable
   1735  0a57		       ad 07 26 	      lda	PROGRAMEND	;set flag to let evaluator to use PROGRAMEND as the root
   1736  0a5a		       85 52		      sta	R0
   1737  0a5c		       ad 08 26 	      lda	PROGRAMEND+1
   1738  0a5f		       85 53		      sta	R0+1
   1739  0a61		       4c ed 06 	      jmp	pushR0nextIl	;place this onto the stack
   1740  0a64
   1741  0a64							; When we get parameters passed we can access them using the # variable with[]
   1742  0a64							; example #[0] #[1] etc, we dont check yet if there is too many
   1743  0a64				   iTSTVParm
   1744  0a64		       c8		      iny
   1745  0a65		       84 51		      sty	CUROFF	;it is a valid variable
   1746  0a67		       a5 48		      lda	MATHSTACK
   1747  0a69		       85 52		      sta	R0
   1748  0a6b		       a5 49		      lda	MATHSTACK+1
   1749  0a6d		       85 53		      sta	R0+1
   1750  0a6f		       4c ed 06 	      jmp	pushR0nextIl
   1751  0a72
   1752  0a72							;
   1753  0a72							;=====================================================
   1754  0a72							; TSTL seems basically the same as TSTN, but leave the
   1755  0a72							; value in R0 instead of pushing onto stack.
   1756  0a72							; This tests for a valid line number
   1757  0a72							;
   1758  0a72		       20 d7 10    iTSTL      jsr	getILByte
   1759  0a75		       85 5e		      sta	offset
   1760  0a77							;
   1761  0a77		       a4 51		      ldy	CUROFF
   1762  0a79		       20 67 14 	      jsr	SkipSpaces
   1763  0a7c		       b1 4f		      lda	(CURPTR),y
   1764  0a7e							;
   1765  0a7e		       c9 30		      cmp	#'0
   1766  0a80		       90 2f		      bcc	tstBranch
   1767  0a82		       c9 3a		      cmp	#'9+1
   1768  0a84		       b0 2b		      bcs	tstBranch
   1769  0a86							;
   1770  0a86							; It's a digit, so convert to a number.
   1771  0a86							;
   1772  0a86		       20 ea 11 	      jsr	getDecimal
   1773  0a89		       4c b9 02 	      jmp	NextIL
   1774  0a8c							;
   1775  0a8c							;=====================================================
   1776  0a8c							; TSTN checks for a number.  This is very simplistic;
   1777  0a8c							; if the character is a digit, assume it's a number.
   1778  0a8c							; Convert to a number and push it onto the stack.
   1779  0a8c							;
   1780  0a8c		       20 d7 10    iTSTN      jsr	getILByte
   1781  0a8f		       85 5e		      sta	offset
   1782  0a91							;
   1783  0a91		       a4 51		      ldy	CUROFF
   1784  0a93		       20 67 14 	      jsr	SkipSpaces
   1785  0a96		       b1 4f		      lda	(CURPTR),y
   1786  0a98		       f0 17		      beq	tstBranch
   1787  0a9a		       c9 2d		      cmp	#'-	;negative?
   1788  0a9c		       f0 08		      beq	iTSTN_1
   1789  0a9e		       c9 30		      cmp	#'0
   1790  0aa0		       90 0f		      bcc	tstBranch
   1791  0aa2		       c9 3a		      cmp	#'9+1
   1792  0aa4		       b0 0b		      bcs	tstBranch
   1793  0aa6							;
   1794  0aa6							; It's a digit, so convert to a number.
   1795  0aa6							;
   1796  0aa6				   iTSTN_1
   1797  0aa6		       20 ea 11 	      jsr	getDecimal
   1798  0aa9		       84 51		      sty	CUROFF
   1799  0aab		       20 33 13 	      jsr	pushR0	;save onto stack
   1800  0aae		       4c b9 02 	      jmp	NextIL
   1801  0ab1
   1802  0ab1							;
   1803  0ab1							; Common jump point for all TSTx instructions that
   1804  0ab1							; fail to meet the requirements.  This takes the
   1805  0ab1							; offset and adds/subtracts to/from ILPC.
   1806  0ab1							;
   1807  0ab1		       a5 5e	   tstBranch  lda	offset	;get signed offset
   1808  0ab3		       10 0e		      bpl	tstPositive
   1809  0ab5							;
   1810  0ab5							; Do negative branch.	Do sign extension.
   1811  0ab5							;
   1812  0ab5		       18	   tstNegative clc
   1813  0ab6		       65 43		      adc	ILPC
   1814  0ab8		       85 43		      sta	ILPC
   1815  0aba							;		  bcc	  tstBothDone
   1816  0aba							;		  dec	  ILPC+1
   1817  0aba							;		  jmp	  NextIL
   1818  0aba
   1819  0aba		       a5 44		      lda	ILPC+1
   1820  0abc		       69 ff		      adc	#$ff
   1821  0abe		       85 44		      sta	ILPC+1
   1822  0ac0		       4c b9 02 	      jmp	NextIL	;keep going
   1823  0ac3							;
   1824  0ac3		       18	   tstPositive clc
   1825  0ac4		       65 43		      adc	ILPC
   1826  0ac6		       85 43		      sta	ILPC
   1827  0ac8		       90 02		      bcc	tstBothDone
   1828  0aca		       e6 44		      inc	ILPC+1
   1829  0acc				   tstBothDone
   1830  0acc		       4c b9 02 	      jmp	NextIL
   1831  0acf
   1832  0acf							;
   1833  0acf							;====================================================
   1834  0acf							; Test for IRQ pending, and test if a break key pressed
   1835  0acf							; Yes I know but this handles all sorts of irq/break issues
   1836  0acf							;
   1837  0acf		       20 d7 10    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1838  0ad2		       85 5e		      sta	offset	; Store the not true jump address offset
   1839  0ad4		       20 26 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1840  0ad7		       d0 03		      bne	irqNo	; z not set of no break found
   1841  0ad9		       4c eb 05 	      jmp	iFIN	; Exit out of run mode
   1842  0adc		       ad b4 1c    irqNo      lda	IRQPending
   1843  0adf		       f0 d0		      beq	tstBranch
   1844  0ae1		       c9 01		      cmp	#1	; only do this if set to first time
   1845  0ae3		       d0 cc		      bne	tstBranch
   1846  0ae5		       78		      sei		; disable the interupt until ireturn resets it
   1847  0ae6		       ee b4 1c    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1848  0ae9		       20 4d 13 	      jsr	pushLN	; Push the next line to be executed
   1849  0aec		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1850  0aee		       ad b5 1c 	      lda	IRQEntry	; Get the line number to branch to
   1851  0af1		       85 4f		      sta	CURPTR	; put line number into r0
   1852  0af3		       ad b6 1c 	      lda	IRQEntry+1
   1853  0af6		       85 50		      sta	CURPTR+1
   1854  0af8		       a9 03		      lda	#3	; Point to first byte of program text
   1855  0afa		       85 51		      sta	CUROFF
   1856  0afc		       4c b9 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1857  0aff
   1858  0aff		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1859  0b01		       a9 00		      lda	#0	; stop the execution
   1860  0b03		       4c 02 06 	      jmp	iErr2
   1861  0b06							;
   1862  0b06
   1863  0b06							;=====================================================
   1864  0b06							; This places the number of free bytes on top of the
   1865  0b06							; stack.
   1866  0b06							;
   1867  0b06		       20 9f 15    iFREE      jsr	GetSizes
   1868  0b09		       20 33 13 	      jsr	pushR0
   1869  0b0c		       4c b9 02 	      jmp	NextIL
   1870  0b0f							;
   1871  0b0f							;=====================================================
   1872  0b0f							; Generate a random number from 0-FFFF and then MOD
   1873  0b0f							; it with the value on top of stack.  Leaves number on
   1874  0b0f							; stack
   1875  0b0f							;
   1876  0b0f		       20 cf 13    iRANDOM    jsr	popR1	;mod value
   1877  0b12							;
   1878  0b12							; If the value is zero, just return a one.
   1879  0b12							;
   1880  0b12		       a5 54		      lda	R1
   1881  0b14		       05 55		      ora	R1+1
   1882  0b16		       f0 4a		      beq	irandom1
   1883  0b18							;
   1884  0b18		       ad 01 26 	      lda	random+1
   1885  0b1b		       8d fe 25 	      sta	rtemp1
   1886  0b1e		       ad 00 26 	      lda	random
   1887  0b21		       0a		      asl
   1888  0b22		       2e fe 25 	      rol	rtemp1
   1889  0b25		       0a		      asl
   1890  0b26		       2e fe 25 	      rol	rtemp1
   1891  0b29		       18		      clc
   1892  0b2a		       6d 00 26 	      adc	random
   1893  0b2d
   1894  0b2d		       48		      pha
   1895  0b2e
   1896  0b2e		       ad fe 25 	      lda	rtemp1
   1897  0b31		       6d 01 26 	      adc	random+1
   1898  0b34		       8d 01 26 	      sta	random+1
   1899  0b37
   1900  0b37		       68		      pla
   1901  0b38
   1902  0b38		       69 11		      adc	#$11
   1903  0b3a		       8d 00 26 	      sta	random
   1904  0b3d		       ad 01 26 	      lda	random+1
   1905  0b40		       69 36		      adc	#$36
   1906  0b42		       8d 01 26 	      sta	random+1
   1907  0b45
   1908  0b45		       ad 00 26 	      lda	random
   1909  0b48		       85 52		      sta	R0
   1910  0b4a		       ad 01 26 	      lda	random+1
   1911  0b4d		       29 7f		      and	#$7f	;make positive
   1912  0b4f		       85 53		      sta	R0+1
   1913  0b51							;
   1914  0b51							; R0 contains the number and R1 contains the max value.
   1915  0b51							;
   1916  0b51		       20 13 07 	      jsr	iDivNoPop
   1917  0b54		       20 38 14 	      jsr	RestoreSigns
   1918  0b57		       a5 56		      lda	MQ
   1919  0b59		       85 52		      sta	R0
   1920  0b5b		       a5 57		      lda	MQ+1
   1921  0b5d		       85 53		      sta	R0+1
   1922  0b5f		       4c ed 06 	      jmp	pushR0nextIl
   1923  0b62				   irandom1
   1924  0b62		       a9 00		      lda	#0
   1925  0b64		       85 53		      sta	R0+1
   1926  0b66		       a9 01		      lda	#1
   1927  0b68		       85 52		      sta	R0
   1928  0b6a		       4c ed 06 	      jmp	pushR0nextIl
   1929  0b6d
   1930  0b6d							; The following replaced by call to division/modulo
   1931  0b6d							;iRANDOM_2	lda	R0
   1932  0b6d							;		cmp	R1
   1933  0b6d							;		bne	iRANDOM_1
   1934  0b6d							;		lda	R0+1
   1935  0b6d							;		cmp	R1+1
   1936  0b6d							;		bne	iRANDOM_1	;need to subtract
   1937  0b6d							;
   1938  0b6d							; Subtract R1 from R0
   1939  0b6d							;
   1940  0b6d							;iRANDOM_sub	sec
   1941  0b6d							;		lda	R0
   1942  0b6d							;		sbc	R1
   1943  0b6d							;		sta	R0
   1944  0b6d							;		lda	R0+1
   1945  0b6d							;		sbc	R1+1
   1946  0b6d							;		sta	R0+1
   1947  0b6d							;		jmp	iRANDOM_2
   1948  0b6d							;
   1949  0b6d							; See if R1 > R0.  If so, branch to subtract.
   1950  0b6d							;
   1951  0b6d							;iRANDOM_1	lda	R0
   1952  0b6d							;		cmp	R1
   1953  0b6d							;		lda	R0+1
   1954  0b6d							;		sbc	R1+1
   1955  0b6d							;		bvc	iRANDOM_4
   1956  0b6d							;		eor	#$80
   1957  0b6d							;iRANDOM_4	bpl	iRANDOM_sub
   1958  0b6d							;
   1959  0b6d							; All done.  Almost.  Add one, then push the result.
   1960  0b6d							;
   1961  0b6d							;irandom1	inc	R0
   1962  0b6d							;		bne	iRANDOM_3
   1963  0b6d							;		inc	R0+1
   1964  0b6d							;iRANDOM_3
   1965  0b6d							;		  jsr	pushR0	;return value
   1966  0b6d							;		jmp	NextIL
   1967  0b6d							;
   1968  0b6d							; Poke a value into a memory location
   1969  0b6d		       8c 06 26    iPOKEMEMORY sty	tempy
   1970  0b70		       20 b7 13 	      jsr	popR0
   1971  0b73		       20 cf 13 	      jsr	popR1
   1972  0b76		       a0 00		      ldy	#0
   1973  0b78		       a5 52		      lda	R0
   1974  0b7a		       91 54		      sta	(R1),y
   1975  0b7c		       ac 06 26 	      ldy	tempy
   1976  0b7f		       4c b9 02 	      jmp	NextIL
   1977  0b82							;
   1978  0b82							; Get a value from a memory location
   1979  0b82							;
   1980  0b82		       8c 06 26    iPEEKMEMORY sty	tempy
   1981  0b85		       20 b7 13 	      jsr	popR0
   1982  0b88		       a0 00		      ldy	#0
   1983  0b8a		       b1 52		      lda	(R0),y
   1984  0b8c		       ac 06 26 	      ldy	tempy
   1985  0b8f		       85 52		      sta	R0
   1986  0b91		       a9 00		      lda	#0
   1987  0b93		       85 53		      sta	R0+1
   1988  0b95		       4c ed 06 	      jmp	pushR0nextIl
   1989  0b98							;
   1990  0b98							; Call to address return what ever is in a to the stack
   1991  0b98							; func2 will load a value into a before the call
   1992  0b98		       20 cf 13    iCallFunc  jsr	popR1
   1993  0b9b		       a5 54		      lda	R1
   1994  0b9d		       20 a9 0b 	      jsr	iCallRtn
   1995  0ba0		       85 52		      sta	R0
   1996  0ba2		       a9 00		      lda	#0
   1997  0ba4		       85 53		      sta	R0+1
   1998  0ba6		       20 ed 06 	      jsr	pushR0nextIl
   1999  0ba9				   iCallRtn
   2000  0ba9		       20 b7 13 	      jsr	popR0
   2001  0bac		       6c 52 00 	      jmp	(R0)
   2002  0baf
   2003  0baf
   2004  0baf							;===========================================jlit======
   2005  0baf							;Get a character from the terminal convert to value
   2006  0baf							;leave the number on top of the stack
   2007  0baf							;
   2008  0baf				   iGETCHAR
   2009  0baf		       20 ef 15 	      jsr	VGETCH
   2010  0bb2					      if	CTMON65
   2011  0bb2		       48		      pha
   2012  0bb3		       20 ec 15 	      jsr	VOUTCH	;echo echo echo
   2013  0bb6		       68		      pla
   2014  0bb7					      endif
   2015  0bb7		       85 52		      sta	R0
   2016  0bb9		       a9 00		      lda	#0
   2017  0bbb		       85 53		      sta	R0+1
   2018  0bbd		       20 33 13 	      jsr	pushR0
   2019  0bc0							;
   2020  0bc0		       4c b9 02 	      jmp	NextIL
   2021  0bc3							;===========================================jusilostintim======
   2022  0bc3							;Put a character to the terminal convert to
   2023  0bc3							;
   2024  0bc3		       20 b7 13    iPUTCHAR   jsr	popR0
   2025  0bc6		       a5 52		      lda	R0
   2026  0bc8		       20 ec 15 	      jsr	VOUTCH
   2027  0bcb		       4c b9 02 	      jmp	NextIL
   2028  0bce							;=====================================================
   2029  0bce							; Put the number on the stack out as hex, suppress leading 0
   2030  0bce				   iHexOut
   2031  0bce		       20 b7 13 	      jsr	popR0
   2032  0bd1		       a5 53		      lda	R0+1
   2033  0bd3		       f0 03		      beq	iHexSecondByte
   2034  0bd5		       20 4b 16 	      jsr	OUTHEX
   2035  0bd8				   iHexSecondByte
   2036  0bd8		       a5 52		      lda	R0
   2037  0bda		       20 4b 16 	      jsr	OUTHEX
   2038  0bdd		       4c b9 02 	      jmp	NextIL
   2039  0be0							;
   2040  0be0							;=====================================================
   2041  0be0							; Replace TOS with its absolute value.
   2042  0be0							;
   2043  0be0		       20 b7 13    iABS       jsr	popR0
   2044  0be3		       a5 53		      lda	R0+1
   2045  0be5		       10 10		      bpl	iABS_1	;already positive
   2046  0be7		       49 ff		      eor	#$ff
   2047  0be9		       85 53		      sta	R0+1
   2048  0beb		       a5 52		      lda	R0
   2049  0bed		       49 ff		      eor	#$ff
   2050  0bef		       85 52		      sta	R0
   2051  0bf1		       e6 52		      inc	R0
   2052  0bf3		       d0 02		      bne	iABS_1
   2053  0bf5		       e6 53		      inc	R0+1
   2054  0bf7		       4c ed 06    iABS_1     jmp	pushR0nextIl
   2055  0bfa
   2056  0bfa							;
   2057  0bfa							;================================================================
   2058  0bfa							; The set of logical operators
   2059  0bfa				   iLogAnd
   2060  0bfa		       20 b7 13 	      jsr	popR0
   2061  0bfd		       20 cf 13 	      jsr	popR1
   2062  0c00		       a5 52		      lda	R0
   2063  0c02		       25 54		      and	R1
   2064  0c04		       85 52		      sta	R0
   2065  0c06		       a5 53		      lda	R0+1
   2066  0c08		       25 55		      and	R1+1
   2067  0c0a		       85 53		      sta	R0+1
   2068  0c0c		       4c ed 06 	      jmp	pushR0nextIl
   2069  0c0f				   iLogOr
   2070  0c0f		       20 b7 13 	      jsr	popR0
   2071  0c12		       20 cf 13 	      jsr	popR1
   2072  0c15		       a5 52		      lda	R0
   2073  0c17		       05 54		      ora	R1
   2074  0c19		       85 52		      sta	R0
   2075  0c1b		       a5 53		      lda	R0+1
   2076  0c1d		       05 55		      ora	R1+1
   2077  0c1f		       85 53		      sta	R0+1
   2078  0c21		       4c ed 06 	      jmp	pushR0nextIl
   2079  0c24				   iLogXor
   2080  0c24		       20 b7 13 	      jsr	popR0
   2081  0c27		       20 cf 13 	      jsr	popR1
   2082  0c2a		       a5 52		      lda	R0
   2083  0c2c		       45 54		      eor	R1
   2084  0c2e		       85 52		      sta	R0
   2085  0c30		       a5 53		      lda	R0+1
   2086  0c32		       45 55		      eor	R1+1
   2087  0c34		       85 53		      sta	R0+1
   2088  0c36		       4c ed 06 	      jmp	pushR0nextIl
   2089  0c39				   iLogNot
   2090  0c39		       20 b7 13 	      jsr	popR0
   2091  0c3c		       a5 52		      lda	R0
   2092  0c3e		       49 ff		      eor	#$FF
   2093  0c40		       85 52		      sta	R0
   2094  0c42		       a5 53		      lda	R0+1
   2095  0c44		       49 ff		      eor	#$FF
   2096  0c46		       85 53		      sta	R0+1
   2097  0c48		       4c ed 06 	      jmp	pushR0nextIl
   2098  0c4b
   2099  0c4b				   iTruth
   2100  0c4b		       a9 ff		      lda	#$FF
   2101  0c4d		       85 52		      sta	R0
   2102  0c4f		       85 53		      sta	R0+1
   2103  0c51		       4c ed 06 	      jmp	pushR0nextIl
   2104  0c54				   iFalse
   2105  0c54		       a9 00		      lda	#$00
   2106  0c56		       85 52		      sta	R0
   2107  0c58		       85 53		      sta	R0+1
   2108  0c5a		       4c ed 06 	      jmp	pushR0nextIl
   2109  0c5d
   2110  0c5d							;================================================================
   2111  0c5d							;Set the IRQ service rtn line number
   2112  0c5d							;
   2113  0c5d		       78	   iSetIrq    sei		; disable the interupts
   2114  0c5e		       a9 00		      lda	#0	; Zero the Status flag
   2115  0c60		       8d b3 1c 	      sta	IRQStatus
   2116  0c63		       20 b7 13 	      jsr	popR0	; get the line number
   2117  0c66		       a5 52		      lda	R0
   2118  0c68		       05 53		      ora	R0+1
   2119  0c6a		       f0 20		      beq	iSetExt	; if it is zero disable all
   2120  0c6c		       20 4d 13 	      jsr	pushLN	; Save the current line pointer
   2121  0c6f		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2122  0c71		       4c ff 0a 	      jmp	ErrStkOver	; Check if there was an error
   2123  0c74				   iSetIrqOk
   2124  0c74		       20 1c 11 	      jsr	findLine	; Find the IRQ func Line Pointer
   2125  0c77		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2126  0c79		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2127  0c7b		       8d b6 1c 	      sta	IRQEntry+1
   2128  0c7e		       a5 4f		      lda	CURPTR
   2129  0c80		       8d b5 1c 	      sta	IRQEntry
   2130  0c83		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2131  0c85		       8d b3 1c 	      sta	IRQStatus
   2132  0c88		       20 72 13 	      jsr	popLN	; Restore the old line number
   2133  0c8b		       58		      cli		; Enable the interupts
   2134  0c8c		       4c b9 02    iSetExt    jmp	NextIL
   2135  0c8f
   2136  0c8f		       20 72 13    iSetIrqErr jsr	popLN
   2137  0c92		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2138  0c94		       a9 00		      lda	#0
   2139  0c96		       4c 02 06 	      jmp	iErr2
   2140  0c99							;
   2141  0c99		       20 b7 13    iTRACEPROG jsr	popR0
   2142  0c9c		       a5 52		      lda	R0
   2143  0c9e		       85 40		      sta	ILTrace
   2144  0ca0		       4c b9 02 	      jmp	NextIL
   2145  0ca3
   2146  0ca3							;=====================================================
   2147  0ca3							; Define start of non page zero data
   2148 U260f ????				      seg.u	TBData
   2149 U1ca2					      org	PROGEND
   2150 U1ca2							;=================================================================
   2151 U1ca2							;
------- FILE gosub.asm LEVEL 2 PASS 6
      0 U1ca2					      include	"gosub.asm"
      1  0ca3					      seg	Code
      2  0ca3
      3  0ca3							; Gosub and return related functions
      4  0ca3							;==========================================================
      5  0ca3							; Push the current math stack frame onto the gosub stack
      6  0ca3				   iPushMathStack
      7  0ca3		       98		      tya
      8  0ca4		       48		      pha
      9  0ca5		       a4 4d		      ldy	GOSUBSTACKPTR
     10  0ca7		       a5 4a		      lda	MATHSTACKPTR
     11  0ca9		       91 4b		      sta	(GOSUBSTACK),y
     12  0cab		       a9 00		      lda	#0
     13  0cad		       c8		      iny
     14  0cae		       91 4b		      sta	(GOSUBSTACK),y
     15  0cb0		       c8		      iny
     16  0cb1		       91 4b		      sta	(GOSUBSTACK),y
     17  0cb3		       c8		      iny
     18  0cb4		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  0cb6		       91 4b		      sta	(GOSUBSTACK),y
     20  0cb8		       c8		      iny
     21  0cb9		       84 4d		      sty	GOSUBSTACKPTR
     22  0cbb		       68		      pla
     23  0cbc		       a8		      tay
     24  0cbd		       4c b9 02 	      jmp	NextIL
     25  0cc0							;
     26  0cc0							;==========================================================
     27  0cc0							; Increment parameter count. Assume Stack frame is top of stack
     28  0cc0				   iIncParmCount
     29  0cc0		       98		      tya
     30  0cc1		       48		      pha
     31  0cc2		       a4 4d		      ldy	GOSUBSTACKPTR
     32  0cc4		       88		      dey
     33  0cc5		       88		      dey
     34  0cc6		       88		      dey
     35  0cc7		       b1 4b		      lda	(GOSUBSTACK),y
     36  0cc9		       aa		      tax
     37  0cca		       e8		      inx
     38  0ccb		       8a		      txa
     39  0ccc		       91 4b		      sta	(GOSUBSTACK),y
     40  0cce		       68		      pla
     41  0ccf		       a8		      tay
     42  0cd0		       4c b9 02 	      jmp	NextIL
     43  0cd3							;
     44  0cd3							;==========================================================
     45  0cd3							;Restore the math stack frame
     46  0cd3		       20 d9 0c    iPopMathStack jsr	PopMathStackNow
     47  0cd6		       4c b9 02 	      jmp	NextIL
     48  0cd9
     49  0cd9				   PopMathStackNow
     50  0cd9		       98		      tya
     51  0cda		       48		      pha
     52  0cdb
     53  0cdb		       a4 4d		      ldy	GOSUBSTACKPTR
     54  0cdd		       88		      dey
     55  0cde		       b1 4b		      lda	(GOSUBSTACK),y
     56  0ce0		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  0ce2		       d0 09		      bne	iPopMathStackNoFrame
     58  0ce4		       88		      dey
     59  0ce5		       88		      dey
     60  0ce6		       88		      dey
     61  0ce7		       b1 4b		      lda	(GOSUBSTACK),y
     62  0ce9		       85 4a		      sta	MATHSTACKPTR
     63  0ceb		       84 4d		      sty	GOSUBSTACKPTR
     64  0ced
     65  0ced				   iPopMathStackNoFrame
     66  0ced
     67  0ced		       68		      pla
     68  0cee		       a8		      tay
     69  0cef		       60		      rts
     70  0cf0
     71  0cf0
     72  0cf0							;==========================================================
     73  0cf0							; Push the current math stack information onto the gosub stack
     74  0cf0				   iSaveMathStack
     75  0cf0		       98		      tya
     76  0cf1		       48		      pha
     77  0cf2		       a4 4d		      ldy	GOSUBSTACKPTR
     78  0cf4		       a5 4a		      lda	MATHSTACKPTR
     79  0cf6		       91 4b		      sta	(GOSUBSTACK),y
     80  0cf8		       a5 48		      lda	MATHSTACK
     81  0cfa		       c8		      iny
     82  0cfb
     83  0cfb		       91 4b		      sta	(GOSUBSTACK),y
     84  0cfd		       c8		      iny
     85  0cfe
     86  0cfe		       a5 49		      lda	MATHSTACK+1
     87  0d00		       91 4b		      sta	(GOSUBSTACK),y
     88  0d02		       c8		      iny
     89  0d03
     90  0d03		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  0d05		       91 4b		      sta	(GOSUBSTACK),y
     92  0d07		       c8		      iny
     93  0d08
     94  0d08		       84 4d		      sty	GOSUBSTACKPTR
     95  0d0a		       68		      pla
     96  0d0b		       a8		      tay
     97  0d0c		       4c b9 02 	      jmp	NextIL
     98  0d0f							;
     99  0d0f							;==========================================================
    100  0d0f							;Restore the math stack information from the gosub stack
    101  0d0f				   iRestoreMathStack
    102  0d0f		       98		      tya
    103  0d10		       48		      pha
    104  0d11
    105  0d11		       a5 4a		      lda	MATHSTACKPTR
    106  0d13		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  0d15
    108  0d15		       a4 4d		      ldy	GOSUBSTACKPTR
    109  0d17		       88		      dey
    110  0d18		       b1 4b		      lda	(GOSUBSTACK),y
    111  0d1a		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  0d1c		       d0 16		      bne	iPopMathStack_Err
    113  0d1e		       88		      dey
    114  0d1f		       b1 4b		      lda	(GOSUBSTACK),y
    115  0d21		       85 49		      sta	MATHSTACK+1
    116  0d23		       88		      dey
    117  0d24		       b1 4b		      lda	(GOSUBSTACK),y
    118  0d26		       85 48		      sta	MATHSTACK
    119  0d28		       88		      dey
    120  0d29		       b1 4b		      lda	(GOSUBSTACK),y
    121  0d2b		       85 4a		      sta	MATHSTACKPTR
    122  0d2d		       84 4d		      sty	GOSUBSTACKPTR
    123  0d2f		       68		      pla
    124  0d30		       a8		      tay
    125  0d31		       4c b9 02 	      jmp	NextIL
    126  0d34
    127  0d34				   iPopMathStack_Err
    128  0d34		       a9 00		      lda	#0
    129  0d36		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  0d38		       4c 02 06 	      jmp	iErr2
    131  0d3b							;=========================================
    132  0d3b							; For functions and tasks the variable address of # means
    133  0d3b							; a passed parameter so #[0] is the first parameter etc
    134  0d3b							; will try for a better way later
    135  0d3b
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  0d3b					      include	"tasks.asm"
      1  0d3b							;=====================================================
      2  0d3b							; Tiny Basic IL task management
      3  0d3b							; Data required by task management
      4  0d3b							; currently each context is about 30 bytes and is swapped
      5  0d3b							; into and out of page zero on each task switch....
      6  0d3b							; LOL yes it is slow, but works for this itteration.
      7  0d3b							;
      8  0d3b
      9  0d3b					      Seg	Code
     10  0d3b							;=====================================================
     11  0d3b							; Sets the pointers to the math,IL and gosub stacks
     12  0d3b							; Creates the initial Context for each task slot
     13  0d3b				   taskSetStacks
     14  0d3b		       a9 b5		      lda	#mathStack&$FF
     15  0d3d		       85 48		      sta	MATHSTACK
     16  0d3f		       a9 1d		      lda	#mathStack>>8
     17  0d41		       85 49		      sta	MATHSTACK+1
     18  0d43
     19  0d43		       a9 45		      lda	#ilStack&$ff
     20  0d45		       85 45		      sta	ILSTACK
     21  0d47		       a9 1f		      lda	#ilStack>>8
     22  0d49		       85 46		      sta	ILSTACK+1
     23  0d4b
     24  0d4b		       a9 d5		      lda	#gosubStack&$FF
     25  0d4d		       85 4b		      sta	GOSUBSTACK
     26  0d4f		       a9 20		      lda	#gosubStack>>8
     27  0d51		       85 4c		      sta	GOSUBSTACK+1
     28  0d53
     29  0d53		       a9 55		      lda	#variableStack&$FF
     30  0d55		       85 41		      sta	VARIABLES
     31  0d57		       a9 23		      lda	#variableStack>>8
     32  0d59		       85 42		      sta	VARIABLES+1
     33  0d5b		       a2 0a		      ldx	#TASKCOUNT
     34  0d5d		       a0 00		      ldy	#0
     35  0d5f		       20 b4 0f 	      jsr	ContextSave
     36  0d62
     37  0d62		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  0d64		       b0 3a		      bcs	taskSetDone
     39  0d66
     40  0d66		       a5 4b		      lda	GOSUBSTACK
     41  0d68		       18		      clc
     42  0d69		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  0d6b		       85 4b		      sta	GOSUBSTACK
     44  0d6d		       a5 4c		      lda	GOSUBSTACK+1
     45  0d6f		       69 00		      adc	#0
     46  0d71		       85 4c		      sta	GOSUBSTACK+1
     47  0d73
     48  0d73		       a5 45		      lda	ILSTACK	; must be less than 256
     49  0d75		       18		      clc
     50  0d76		       69 28		      adc	#ILSTACKSIZE*2
     51  0d78		       85 45		      sta	ILSTACK
     52  0d7a		       a5 46		      lda	ILSTACK+1
     53  0d7c		       69 00		      adc	#0
     54  0d7e		       85 46		      sta	ILSTACK+1
     55  0d80
     56  0d80		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  0d82		       18		      clc
     58  0d83		       69 28		      adc	#MATHSTACKSIZE*2
     59  0d85		       85 48		      sta	MATHSTACK
     60  0d87		       a5 49		      lda	MATHSTACK+1
     61  0d89		       69 00		      adc	#0
     62  0d8b		       85 49		      sta	MATHSTACK+1
     63  0d8d
     64  0d8d		       a5 41		      lda	VARIABLES	; must be less than 256
     65  0d8f		       18		      clc
     66  0d90		       69 36		      adc	#VARIABLESSIZE*2
     67  0d92		       85 41		      sta	VARIABLES
     68  0d94		       a5 42		      lda	VARIABLES+1
     69  0d96		       69 00		      adc	#0
     70  0d98		       85 42		      sta	VARIABLES+1
     71  0d9a
     72  0d9a		       20 b4 0f 	      jsr	ContextSave
     73  0d9d		       4c 62 0d 	      jmp	taskSetLoop
     74  0da0
     75  0da0				   taskSetDone
     76  0da0		       a0 00		      ldy	#0	; reload the main loop context
     77  0da2		       20 c3 0f 	      jsr	ContextLoad
     78  0da5		       60		      rts
     79  0da6							;
     80  0da6							;=====================================================
     81  0da6							; In some error cases the math stacks may be left pointing to the wrong stack
     82  0da6							; This function will reset those stack addresses but not the actual pointer
     83  0da6				   taskResetStacks
     84  0da6		       a0 00		      ldy	#0
     85  0da8		       20 c3 0f 	      jsr	ContextLoad
     86  0dab		       4c 3b 0d 	      jmp	taskSetStacks
     87  0dae							;
     88  0dae							;=====================================================
     89  0dae							; Clear all task entries and task stacks
     90  0dae		       98	   taskReset  tya		; Save Y
     91  0daf		       48		      pha
     92  0db0		       a9 01		      lda	#1
     93  0db2		       8d b4 1d 	      sta	taskCounter	; Set number of active tasks to 1
     94  0db5		       ac b7 1c 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  0db8		       c0 00		      cpy	#0	; check if we are the main context
     96  0dba		       f0 08		      beq	taskResetCont	; if we are just continue
     97  0dbc
     98  0dbc		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  0dbe		       8c b7 1c 	      sty	taskPtr
    100  0dc1		       20 c3 0f 	      jsr	ContextLoad	; load the System Task context
    101  0dc4				   taskResetCont
    102  0dc4		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  0dc6
    104  0dc6				   taskResetLoop
    105  0dc6		       a9 00		      lda	#TASKINACTIVE
    106  0dc8		       99 b8 1c 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  0dcb		       18		      clc
    108  0dcc		       98		      tya
    109  0dcd		       69 19		      adc	#CONTEXTLEN+1
    110  0dcf		       a8		      tay
    111  0dd0		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  0dd2		       90 f2		      bcc	taskResetLoop	; Go for more
    113  0dd4
    114  0dd4				   taskResetComplete
    115  0dd4
    116  0dd4		       68		      pla		; Restore y
    117  0dd5		       a8		      tay
    118  0dd6		       60		      rts
    119  0dd7
    120  0dd7							;
    121  0dd7							;======================================================
    122  0dd7							; iTaskSwitch	 switch to new task if not interrupt and
    123  0dd7							;		 count is exceded for task time slice gets here
    124  0dd7							;		 when time slice has reached zero
    125  0dd7							;
    126  0dd7		       98	   iTaskSwitch tya
    127  0dd8		       48		      pha
    128  0dd9		       ad b3 1d 	      lda	taskResetValue	; Always reset the counter value
    129  0ddc		       8d b2 1d 	      sta	taskCurrentCycles	; Update the counter with the new value
    130  0ddf
    131  0ddf		       ad b4 1c 	      lda	IRQPending	; Skip this if we are processing an irq
    132  0de2		       05 60		      ora	taskIOPending	; If set then don't switch
    133  0de4		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    134  0de6
    135  0de6		       ad b4 1d    iTaskMain  lda	taskCounter	; Number of tasks
    136  0de9		       c9 01		      cmp	#1	; if there is only one task must be main
    137  0deb		       d0 07		      bne	itasknext	; if it some other number continue to next
    138  0ded
    139  0ded		       ac b7 1c 	      ldy	taskPtr	; check if we have not just ended some other task
    140  0df0		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    141  0df2		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    142  0df4							;
    143  0df4							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    144  0df4							;
    145  0df4				   itasknext
    146  0df4		       ac b7 1c 	      ldy	taskPtr
    147  0df7		       20 b4 0f 	      jsr	ContextSave	; Save the current context, y points to next context
    148  0dfa				   itaskLoop
    149  0dfa		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    150  0dfc		       90 04		      bcc	iTaskNextChk
    151  0dfe
    152  0dfe		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    153  0e00		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    154  0e02
    155  0e02				   iTaskNextChk
    156  0e02		       b9 b8 1c 	      lda	taskTable,y	; there is always at least one entry in table
    157  0e05		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    158  0e07		       18	   iTaskNext  clc
    159  0e08		       98		      tya
    160  0e09		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    161  0e0b		       a8		      tay
    162  0e0c		       4c fa 0d 	      jmp	itaskLoop	; Check for busy entry
    163  0e0f
    164  0e0f		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    165  0e11		       59 b8 1c 	      eor	taskTable,y	; Check for anything waiting io
    166  0e14		       d0 f1		      bne	iTaskNext
    167  0e16		       20 c3 0f 	      jsr	ContextLoad	; load the next context
    168  0e19		       8c b7 1c 	      sty	taskPtr	; update the task pointer
    169  0e1c
    170  0e1c				   iTaskSwitchDone
    171  0e1c		       68		      pla
    172  0e1d		       a8		      tay
    173  0e1e		       60		      rts
    174  0e1f							;
    175  0e1f							;================================================================
    176  0e1f							; Task Set task number to line number to start
    177  0e1f							; Task Table structure:
    178  0e1f							;    byte 0	-   Active inactive
    179  0e1f							;    byte 1-2	-   Basic code line pointer
    180  0e1f							;    byte 3	-   Offset on current line
    181  0e1f		       98	   iTaskSet   tya		;preserve Y
    182  0e20		       48		      pha		; push a
    183  0e21
    184  0e21		       20 b7 13 	      jsr	popR0	; Get the line number to be saved
    185  0e24
    186  0e24		       ac b7 1c 	      ldy	taskPtr	; find out where we are
    187  0e27		       20 b4 0f 	      jsr	ContextSave	; Save the current context
    188  0e2a
    189  0e2a							;Find the pointer to the line we need to start at
    190  0e2a		       20 1c 11 	      jsr	findLine	; Get the offset of the line to start task at
    191  0e2d		       f0 0b		      beq	iTaskCont
    192  0e2f
    193  0e2f		       ac b7 1c 	      ldy	taskPtr	; Restore the original Context Error Exit
    194  0e32		       20 c3 0f 	      jsr	ContextLoad
    195  0e35
    196  0e35		       68		      pla		; pop a - exit
    197  0e36		       a8		      tay
    198  0e37		       4c 8f 0c 	      jmp	iSetIrqErr	; Bad line number provided
    199  0e3a
    200  0e3a				   iTaskCont
    201  0e3a		       20 86 0f 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    202  0e3d		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    203  0e3f
    204  0e3f		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    205  0e41		       99 b8 1c 	      sta	taskTable,y	; new task as active
    206  0e44
    207  0e44		       a5 4f		      lda	CURPTR
    208  0e46		       48		      pha		; push a
    209  0e47		       a5 50		      lda	CURPTR+1
    210  0e49		       48		      pha		; push a
    211  0e4a
    212  0e4a		       20 c3 0f 	      jsr	ContextLoad	; load the context of the new task
    213  0e4d
    214  0e4d		       68		      pla		; pop a
    215  0e4e		       85 50		      sta	CURPTR+1
    216  0e50		       68		      pla		; pop a
    217  0e51		       85 4f		      sta	CURPTR
    218  0e53		       a9 03		      lda	#3	; Offset to first instruction
    219  0e55		       85 51		      sta	CUROFF
    220  0e57
    221  0e57		       a9 00		      lda	#0
    222  0e59		       85 47		      sta	ILSTACKPTR
    223  0e5b		       85 4a		      sta	MATHSTACKPTR
    224  0e5d		       85 4d		      sta	GOSUBSTACKPTR
    225  0e5f		       a9 40		      lda	#GOSUBSTACKSIZE*4
    226  0e61		       85 4e		      sta	MESSAGEPTR
    227  0e63
    228  0e63		       20 24 09 	      jsr	subVINIT	; Clear the variables
    229  0e66
    230  0e66		       a9 27		      lda	#STMT&$FF
    231  0e68		       85 43		      sta	ILPC
    232  0e6a		       a9 18		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    233  0e6c		       85 44		      sta	ILPC+1
    234  0e6e
    235  0e6e		       98		      tya		; Save the new context offset to return to user
    236  0e6f		       48		      pha		; push a
    237  0e70
    238  0e70		       20 b4 0f    itaskSetSave jsr	ContextSave	; save the updated context
    239  0e73		       ee b4 1d 	      inc	taskCounter	; Update the number of Tasks running
    240  0e76
    241  0e76		       ac b7 1c 	      ldy	taskPtr
    242  0e79		       20 c3 0f 	      jsr	ContextLoad	; restore the original context
    243  0e7c
    244  0e7c		       a9 00		      lda	#0	; Set the R0 upper to zero
    245  0e7e		       85 53		      sta	R0+1
    246  0e80		       68		      pla		; Get the task pid we stored				 ; pop a
    247  0e81		       85 52		      sta	R0	; Get the table entry value
    248  0e83
    249  0e83		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    250  0e84		       a8		      tay
    251  0e85
    252  0e85		       4c ed 06 	      jmp	pushR0nextIl	; Push R0 and continue
    253  0e88				   iTaskNoEmpty
    254  0e88		       ac b7 1c 	      ldy	taskPtr
    255  0e8b		       20 c3 0f 	      jsr	ContextLoad
    256  0e8e
    257  0e8e		       68		      pla		; pop a    -- exit
    258  0e8f		       a8		      tay
    259  0e90
    260  0e90		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    261  0e92		       a9 00		      lda	#0
    262  0e94		       4c 02 06 	      jmp	iErr2
    263  0e97							;
    264  0e97							;===============================================================
    265  0e97							; Run the task whos PID is on the stack, preserve the stack
    266  0e97							;
    267  0e97				   iTaskEnable
    268  0e97		       98		      tya
    269  0e98		       48		      pha
    270  0e99		       20 cf 13 	      jsr	popR1
    271  0e9c		       20 9d 13 	      jsr	pushR1
    272  0e9f		       20 ba 10 	      jsr	ipc_getcontext	; get context pointer into mq
    273  0ea2		       a0 00		      ldy	#0
    274  0ea4		       b1 56		      lda	(MQ),y
    275  0ea6		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    276  0ea8		       09 80		      ora	#TASKACTIVE
    277  0eaa		       91 56		      sta	(MQ),y
    278  0eac		       68		      pla
    279  0ead		       a8		      tay
    280  0eae		       4c b9 02 	      jmp	NextIL
    281  0eb1
    282  0eb1							;
    283  0eb1							;===============================================================
    284  0eb1							; Suspend the task whos PID  is on the stack, preserve the stack
    285  0eb1							;
    286  0eb1				   iTaskSuspend
    287  0eb1		       98		      tya
    288  0eb2		       48		      pha
    289  0eb3		       20 cf 13 	      jsr	popR1
    290  0eb6		       20 9d 13 	      jsr	pushR1
    291  0eb9		       20 ba 10 	      jsr	ipc_getcontext	; get context pointer into mq
    292  0ebc		       a0 00		      ldy	#0
    293  0ebe		       b1 56		      lda	(MQ),y
    294  0ec0		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    295  0ec2		       09 80		      ora	#TASKACTIVE
    296  0ec4		       68		      pla
    297  0ec5		       a8		      tay
    298  0ec6		       4c b9 02 	      jmp	NextIL
    299  0ec9
    300  0ec9							;================================================================
    301  0ec9							; Returns task Status
    302  0ec9				   iTaskStat
    303  0ec9		       98		      tya
    304  0eca		       48		      pha
    305  0ecb		       20 dd 0e 	      jsr	iTaskValid	; returns pointer to task entry
    306  0ece		       b9 b8 1c 	      lda	taskTable,y
    307  0ed1		       f0 05		      beq	iTaskStatExit
    308  0ed3		       68		      pla
    309  0ed4		       a8		      tay
    310  0ed5		       4c 4b 0c 	      jmp	iTruth
    311  0ed8				   iTaskStatExit
    312  0ed8		       68		      pla
    313  0ed9		       a8		      tay
    314  0eda		       4c 54 0c 	      jmp	iFalse
    315  0edd
    316  0edd							;
    317  0edd							;================================================================
    318  0edd							; Validate the task number on top of the stack
    319  0edd							; on exit y points to the requested task entry
    320  0edd							;
    321  0edd		       20 b7 13    iTaskValid jsr	popR0	; get result of the multiply
    322  0ee0		       a5 53		      lda	R0+1
    323  0ee2		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    324  0ee4		       a5 52		      lda	R0
    325  0ee6		       c9 fa		      cmp	#TASKTABLELEN
    326  0ee8		       90 09		      bcc	iTaskIsValid
    327  0eea
    328  0eea		       68	   iTaskValidErr pla		;remove return address
    329  0eeb		       68		      pla
    330  0eec		       a2 10		      ldx	#ERR_INVALID_PID
    331  0eee		       a9 00		      lda	#0
    332  0ef0		       4c 02 06 	      jmp	iErr2
    333  0ef3
    334  0ef3		       a8	   iTaskIsValid tay
    335  0ef4		       60		      rts
    336  0ef5							;
    337  0ef5							;================================================================
    338  0ef5							; Kill a running task, do nothing if already stopped
    339  0ef5		       20 dd 0e    iTaskKill  jsr	iTaskValid
    340  0ef8		       a9 00		      lda	#0
    341  0efa		       99 b8 1c 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    342  0efd							;
    343  0efd							;================================================================
    344  0efd							;Skip to next task
    345  0efd				   iNTask
    346  0efd		       a9 01		      lda	#1
    347  0eff		       8d b2 1d 	      sta	taskCurrentCycles
    348  0f02		       4c b9 02 	      jmp	NextIL
    349  0f05							;
    350  0f05							;=======================================================
    351  0f05							; Wait for a task to complete
    352  0f05				   iWTASK
    353  0f05		       20 d7 10 	      jsr	getILByte
    354  0f08		       85 5e		      sta	offset
    355  0f0a							;
    356  0f0a		       20 21 13 	      jsr	saveIL	;in case of failure
    357  0f0d
    358  0f0d		       20 dd 0e 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    359  0f10		       b9 b8 1c 	      lda	taskTable,y
    360  0f13		       d0 03		      bne	iWTASKWAIT
    361  0f15				   iWTASKEXITED
    362  0f15		       4c b9 02 	      jmp	NextIL
    363  0f18				   iWTASKWAIT
    364  0f18		       20 33 13 	      jsr	pushR0	; Push R0 back onto the stack
    365  0f1b		       a9 01		      lda	#1
    366  0f1d		       8d b2 1d 	      sta	taskCurrentCycles	; Give up the cycles
    367  0f20
    368  0f20		       20 2a 13 	      jsr	restoreIL
    369  0f23		       4c b1 0a 	      jmp	tstBranch
    370  0f26							;
    371  0f26							;=======================================================
    372  0f26							; Set task io lock
    373  0f26		       e6 60	   iStartIO   inc	taskIOPending
    374  0f28		       4c b9 02 	      jmp	NextIL
    375  0f2b							;
    376  0f2b							;=======================================================
    377  0f2b							; Release the io lock
    378  0f2b		       a5 60	   iEndIO     lda	taskIOPending
    379  0f2d		       f0 02		      beq	iEndIOExit
    380  0f2f		       c6 60		      dec	taskIOPending
    381  0f31		       4c b9 02    iEndIOExit jmp	NextIL
    382  0f34							;
    383  0f34							;===============================================================
    384  0f34							; Return the task PID
    385  0f34				   iTASKPID
    386  0f34		       a9 00		      lda	#0
    387  0f36		       85 53		      sta	R0+1
    388  0f38		       ad b7 1c 	      lda	taskPtr
    389  0f3b		       85 52		      sta	R0
    390  0f3d		       4c ed 06 	      jmp	pushR0nextIl
    391  0f40							;
    392  0f40							;================================================================
    393  0f40							; Terminate a task
    394  0f40		       ac b7 1c    iETask     ldy	taskPtr
    395  0f43		       c0 00		      cpy	#0
    396  0f45		       d0 03		      bne	iETaskCont
    397  0f47		       4c eb 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    398  0f4a				   iETaskCont
    399  0f4a		       a9 00		      lda	#TASKINACTIVE
    400  0f4c		       99 b8 1c 	      sta	taskTable,y	; mark entry as free
    401  0f4f		       ce b4 1d 	      dec	taskCounter	; reduce the number of active tasks
    402  0f52		       a9 01		      lda	#1
    403  0f54		       8d b2 1d 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    404  0f57		       20 a1 0f 	      jsr	TaskSetExitCode
    405  0f5a				   iETaskExit
    406  0f5a		       4c b9 02 	      jmp	NextIL
    407  0f5d							;================================================================
    408  0f5d							; make the current tasks math stack equal another tasks stack
    409  0f5d							; The task to get is stored on the math stack
    410  0f5d
    411  0f5d				   iTaskGetMathStack
    412  0f5d		       20 81 16 	      jsr	CopyStackR1	; Get the top of stack to R1
    413  0f60		       20 ba 10 	      jsr	ipc_getcontext	; MQ now has the context address
    414  0f63		       a0 0a		      ldy	#MATHSTACKPTRPOS
    415  0f65		       b1 56		      lda	(MQ),y
    416  0f67		       85 4a		      sta	MATHSTACKPTR
    417  0f69		       a0 08		      ldy	#MATHSTACKPOS
    418  0f6b		       b1 56		      lda	(MQ),y
    419  0f6d		       85 48		      sta	MATHSTACK
    420  0f6f		       c8		      iny
    421  0f70		       b1 56		      lda	(MQ),y
    422  0f72		       85 49		      sta	MATHSTACK+1
    423  0f74		       4c b9 02 	      jmp	NextIL
    424  0f77							;==================================================================
    425  0f77							; Updates the tasks math stack pointer with contents of R2
    426  0f77							; PID is on top of the stack
    427  0f77				   iTaskPutMathPtr
    428  0f77		       20 81 16 	      jsr	CopyStackR1	; Get the top of stack to R1
    429  0f7a		       20 ba 10 	      jsr	ipc_getcontext	; MQ now has the context address
    430  0f7d		       a5 58		      lda	R2
    431  0f7f		       a0 0a		      ldy	#MATHSTACKPTRPOS
    432  0f81		       91 56		      sta	(MQ),y
    433  0f83		       4c b9 02 	      jmp	NextIL
    434  0f86							;================================================================
    435  0f86							; Find an empty slot in the taskTable
    436  0f86							; Return the index in y
    437  0f86							; on exit   c set if an empty slot is found
    438  0f86							;	     c clear if not found
    439  0f86							;================================================================
    440  0f86							;
    441  0f86		       ad b4 1d    TaskEmpty  lda	taskCounter
    442  0f89		       c9 0a		      cmp	#TASKCOUNT
    443  0f8b		       b0 10		      bcs	TaskNoSlot
    444  0f8d		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    445  0f8f				   TaskLoop
    446  0f8f		       b9 b8 1c 	      lda	taskTable,y
    447  0f92		       f0 0b		      beq	TaskEmptyFnd
    448  0f94		       98		      tya
    449  0f95		       18		      clc
    450  0f96		       69 19		      adc	#CONTEXTLEN+1
    451  0f98		       a8		      tay
    452  0f99		       c0 fa		      cpy	#TASKTABLELEN
    453  0f9b		       90 f2		      bcc	TaskLoop	; Y is never zero
    454  0f9d				   TaskNoSlot
    455  0f9d		       18		      clc
    456  0f9e		       60		      rts
    457  0f9f				   TaskEmptyFnd
    458  0f9f		       38		      sec
    459  0fa0		       60		      rts
    460  0fa1							;====================================================
    461  0fa1							; Set the task exit code called from the return command
    462  0fa1							; on entry stack top hold exit value
    463  0fa1				   TaskSetExitCode
    464  0fa1		       98		      tya
    465  0fa2		       48		      pha
    466  0fa3		       20 b7 13 	      jsr	popR0
    467  0fa6		       a0 19		      ldy	#TASKEXITCODE
    468  0fa8		       a5 52		      lda	R0
    469  0faa		       91 41		      sta	(VARIABLES),y
    470  0fac		       c8		      iny
    471  0fad		       a5 53		      lda	R0+1
    472  0faf		       91 41		      sta	(VARIABLES),y
    473  0fb1		       68		      pla
    474  0fb2		       98		      tya
    475  0fb3		       60		      rts
    476  0fb4
    477  0fb4							;
    478  0fb4							;=====================================================
    479  0fb4							; Save Context Store the context to the TASK Table
    480  0fb4							; on entry y contains the task table entry to save to
    481  0fb4							; on exit y points to next task table entry
    482  0fb4							;	   x contains the number of bytes copied
    483  0fb4		       a2 00	   ContextSave ldx	#0
    484  0fb6		       c8		      iny		;inc past the task flags
    485  0fb7		       b5 41	   ContextSvLoop lda	CONTEXT,x
    486  0fb9		       99 b8 1c 	      sta	taskTable,y
    487  0fbc		       c8		      iny
    488  0fbd		       e8		      inx
    489  0fbe		       e0 18		      cpx	#CONTEXTLEN
    490  0fc0		       90 f5		      bcc	ContextSvLoop
    491  0fc2		       60		      rts
    492  0fc3							;
    493  0fc3							; Load Context transfer context from task table to the Current Context
    494  0fc3							; on entry y contains the task table entry to transfer
    495  0fc3							; on exit y points to the original task table entry
    496  0fc3							;	   x contains the number of byts copied
    497  0fc3		       98	   ContextLoad tya
    498  0fc4		       48		      pha
    499  0fc5		       a2 00		      ldx	#0
    500  0fc7		       c8		      iny		;inc past the task flags
    501  0fc8		       b9 b8 1c    ContextLDLoop lda	taskTable,y
    502  0fcb		       95 41		      sta	CONTEXT,x
    503  0fcd		       c8		      iny
    504  0fce		       e8		      inx
    505  0fcf		       e0 18		      cpx	#CONTEXTLEN
    506  0fd1		       90 f5		      bcc	ContextLDLoop
    507  0fd3		       68		      pla
    508  0fd4		       a8		      tay
    509  0fd5		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  0fd6					      include	"ipc.asm"
      1  0fd6							;======================================================
      2  0fd6							; Inter process communications.
      3  0fd6							; Tasks may write/read integer messages among
      4  0fd6							; them selves.
      5  0fd6							; This uses each tasks gosub stack as a message queue
      6  0fd6							; Gosub calls start at the highest address and the
      7  0fd6							; msg queue starts at the highest address.
      8  0fd6							;
      9  0fd6							;======================================================
     10  0fd6							; ipcs   - Send msg to another task or many tasks
     11  0fd6							; on entry  math stack contains the  top PID
     12  0fd6							;				      2ND Message value
     13  0fd6							; on exit   math stack contain top True-good or False-failed
     14  0fd6							;
     15  0fd6							; it may not be sent if queue is full
     16  0fd6							;
     17  0fd6							; a = ipcs(<message-expression>,<task PID-expression>)
     18  0fd6							;
     19  0fd6				   iIPCS
     20  0fd6		       98		      tya
     21  0fd7		       48		      pha
     22  0fd8		       20 3f 10 	      jsr	ipc_enqueue
     23  0fdb		       b0 08		      bcs	iIPC_BAD
     24  0fdd		       20 73 16 	      jsr	pushTrue
     25  0fe0		       68		      pla
     26  0fe1		       a8		      tay
     27  0fe2		       4c b9 02 	      jmp	NextIL
     28  0fe5				   iIPC_BAD
     29  0fe5		       68		      pla
     30  0fe6		       a8		      tay
     31  0fe7		       20 7d 16 	      jsr	pushFalse
     32  0fea		       4c b9 02 	      jmp	NextIL
     33  0fed
     34  0fed							;======================================================
     35  0fed							; ipcr   - Recieve msg from task
     36  0fed							; on exit  the message value is returned from message queue
     37  0fed							;	    message -1	is reserved meaning no entry found
     38  0fed							; The provided variable contains the pid of the sending
     39  0fed							; task. This is optional. This always waits for a message
     40  0fed							; before returning.
     41  0fed							;
     42  0fed							; a = ipcr(<variable name>)
     43  0fed							;
     44  0fed				   iIPCR
     45  0fed		       98		      tya
     46  0fee		       48		      pha
     47  0fef		       20 81 10 	      jsr	ipc_dequeue
     48  0ff2		       b0 05		      bcs	iIPCR_Q_Empty
     49  0ff4		       68		      pla
     50  0ff5		       a8		      tay
     51  0ff6		       4c b9 02 	      jmp	NextIL
     52  0ff9				   iIPCR_Q_Empty
     53  0ff9		       68		      pla
     54  0ffa		       a8		      tay
     55  0ffb		       20 73 16 	      jsr	pushTrue	; puts -1 on the stack
     56  0ffe		       4c b9 02 	      jmp	NextIL
     57  1001
     58  1001							;=======================================================
     59  1001							; ipcc   - Check if message available
     60  1001							; on exit  Stack contains number of messages
     61  1001							;
     62  1001							; a = ipcc()
     63  1001							;
     64  1001				   iIPCC
     65  1001		       98		      tya
     66  1002		       48		      pha
     67  1003		       20 2c 10 	      jsr	ipc_queue_count
     68  1006		       20 33 13 	      jsr	pushR0	; return the count
     69  1009		       68		      pla
     70  100a		       a8		      tay
     71  100b		       4c b9 02 	      jmp	NextIL
     72  100e
     73  100e							;=======================================================
     74  100e							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  100e				   iIPCIO
     76  100e		       98		      tya
     77  100f		       48		      pha
     78  1010		       20 2c 10 	      jsr	ipc_queue_count
     79  1013		       a5 52		      lda	R0
     80  1015		       d0 10		      bne	iIPCIO_No_Halt
     81  1017		       a9 01		      lda	#1
     82  1019		       8d b2 1d 	      sta	taskCurrentCycles	; force a task switch
     83  101c		       a9 01		      lda	#TASKWAITIPC
     84  101e		       ac b7 1c 	      ldy	taskPtr
     85  1021		       19 b8 1c 	      ora	taskTable,y
     86  1024		       99 b8 1c 	      sta	taskTable,y
     87  1027
     88  1027				   iIPCIO_No_Halt
     89  1027		       68		      pla
     90  1028		       a8		      tay
     91  1029		       4c b9 02 	      jmp	NextIL
     92  102c							;======================================================
     93  102c							;ipc_queue_count
     94  102c				   ipc_queue_count
     95  102c		       a5 4e		      lda	MESSAGEPTR
     96  102e		       18		      clc
     97  102f		       4a		      lsr		; divide by 4
     98  1030		       4a		      lsr
     99  1031		       85 52		      sta	R0	; store into R0
    100  1033		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1035		       38		      sec
    102  1036		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1038		       85 52		      sta	R0
    104  103a		       a9 00		      lda	#0
    105  103c		       85 53		      sta	R0+1
    106  103e		       60		      rts
    107  103f							;=======================================================
    108  103f							; Support functions for messaging
    109  103f							;
    110  103f							; Enqueue message -> onto PID's MSG Q
    111  103f							; on entry top of stack contains the PID
    112  103f							;	    second contains the Message of the task
    113  103f							; on exit contains c set if failed
    114  103f							;		    c cleared if success
    115  103f							;		    PID's MSG Q PTR points to the message
    116  103f							;
    117  103f				   ipc_enqueue
    118  103f		       20 cf 13 	      jsr	popR1	; Get the pid
    119  1042		       20 ba 10 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1045
    121  1045		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1047		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1049		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  104b		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  104d		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  104f
    127  104f
    128  104f							; Get the PID'S stack address into R0
    129  104f		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1051		       b1 56		      lda	(MQ),y
    131  1053		       85 52		      sta	R0
    132  1055		       c8		      iny
    133  1056		       b1 56		      lda	(MQ),y
    134  1058		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  105a
    136  105a							; Set y to point to the msg q entry
    137  105a		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  105c		       b1 56		      lda	(MQ),y	; Get the index
    139  105e		       a8		      tay		; Set y to queue offset
    140  105f
    141  105f							; enqueue the message
    142  105f		       88		      dey		; First byte to save to
    143  1060		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1062		       91 52		      sta	(R0),y	; Set the entry type
    145  1064
    146  1064		       88		      dey
    147  1065		       ad b7 1c 	      lda	taskPtr	; Store the PID into queue
    148  1068		       91 52		      sta	(R0),y
    149  106a		       20 cf 13 	      jsr	popR1	; Get the actual message value
    150  106d		       20 c8 10 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1070
    152  1070		       98		      tya		; Save the new q ptr
    153  1071		       a0 0e		      ldy	#MSGPTRPOS
    154  1073		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1075		       a0 00		      ldy	#0	; points to context root
    156  1077		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1079		       51 56		      eor	(MQ),y	; Turn off the bit
    158  107b		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  107d		       18		      clc
    160  107e		       60		      rts
    161  107f				   ipc_enq_full
    162  107f		       38		      sec
    163  1080		       60		      rts
    164  1081							;=============================================================
    165  1081							; De-queue for message stack -> local tasks msg q
    166  1081							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1081							;  message into
    168  1081							;  on exit   math stack contains value of message
    169  1081							;				  Variable if provided is pid
    170  1081				   ipc_dequeue
    171  1081		       20 e6 13 	      jsr	popMQ	; Variable address to put PID into
    172  1084
    173  1084		       a4 4e		      ldy	MESSAGEPTR
    174  1086		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1088		       b0 2e		      bcs	ipc_deq_empty
    176  108a		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  108c		       85 52		      sta	R0
    178  108e		       c8		      iny
    179  108f		       b1 4b		      lda	(GOSUBSTACK),y
    180  1091		       85 53		      sta	R0+1
    181  1093		       c8		      iny
    182  1094		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1096		       85 54		      sta	R1
    184  1098		       c8		      iny
    185  1099		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  109b		       c8		      iny
    187  109c		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  109e
    189  109e		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  10a0		       d0 16		      bne	ipc_deq_empty
    191  10a2
    192  10a2		       20 33 13 	      jsr	pushR0	; place value on stack
    193  10a5
    194  10a5		       a5 56		      lda	MQ
    195  10a7		       05 57		      ora	MQ+1
    196  10a9		       f0 0b		      beq	ipc_deq_done
    197  10ab		       a5 54		      lda	R1
    198  10ad		       a0 00		      ldy	#0
    199  10af		       91 56		      sta	(MQ),y
    200  10b1		       c8		      iny
    201  10b2		       a9 00		      lda	#0
    202  10b4		       91 56		      sta	(MQ),y
    203  10b6				   ipc_deq_done
    204  10b6		       18		      clc
    205  10b7		       60		      rts
    206  10b8
    207  10b8				   ipc_deq_empty
    208  10b8		       38		      sec
    209  10b9		       60		      rts
    210  10ba
    211  10ba							;=============================================
    212  10ba							;  Get the context address into MQ from R1 with
    213  10ba							;  context/index/pid
    214  10ba				   ipc_getcontext
    215  10ba		       18		      clc		; Get pointer to Task context
    216  10bb		       a9 b8		      lda	#taskTable&$FF	; change ptr to address
    217  10bd		       65 54		      adc	R1
    218  10bf		       85 56		      sta	MQ
    219  10c1		       a9 1c		      lda	#taskTable>>8
    220  10c3		       65 55		      adc	R1+1
    221  10c5		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  10c7		       60		      rts
    223  10c8							;
    224  10c8							;==============================================
    225  10c8							;Push R1 onto the stack
    226  10c8							;on entry y = next entry
    227  10c8							;R0 points to the stack space
    228  10c8							;on exit y points to next free byte
    229  10c8				   ipc_pushR1
    230  10c8		       88		      dey
    231  10c9		       a5 55		      lda	R1+1	; PID first
    232  10cb		       91 52		      sta	(R0),y
    233  10cd		       88		      dey
    234  10ce		       a5 54		      lda	R1
    235  10d0		       91 52		      sta	(R0),y
    236  10d2		       60		      rts
    237  10d3
    238  10d3
    239  10d3
    240  10d3
    241  10d3
    242  10d3
    243  10d3
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  10d3					      include	"support.asm"
      1  10d3							;
      2  10d3							;=====================================================
      3  10d3							;=====================================================
      4  10d3							;=====================================================
      5  10d3							; This marks the start of support functions used by
      6  10d3							; the IL opcodes.  These are support functions, NOT
      7  10d3							; the IL code.
      8  10d3							;=====================================================
      9  10d3							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  10d3							;=====================================================
     11  10d3					      Seg	Code
     12  10d3							;=====================================================
     13  10d3							; This gets the next two bytes pointed to by ILPC and
     14  10d3							; returns them; X contains LSB, A contains MSB.  ILPC
     15  10d3							; is advanced by two, and Y contains 0 on return.
     16  10d3
     17  10d3							;
     18  10d3		       20 d7 10    getILWord  jsr	getILByte	;LSB
     19  10d6		       aa		      tax
     20  10d7							;
     21  10d7							;=====================================================
     22  10d7							; This gets the next byte pointed to by ILPC and
     23  10d7							; returns it in A.  On return, X is unchanged but Y
     24  10d7							; contains 0.
     25  10d7							;
     26  10d7		       a0 00	   getILByte  ldy	#0
     27  10d9		       b1 43		      lda	(ILPC),y	;get byte
     28  10db		       08		      php		;save status
     29  10dc		       e6 43		      inc	ILPC	;inc LSB
     30  10de		       d0 02		      bne	getILb2	;branch if no overflow
     31  10e0		       e6 44		      inc	ILPC+1	;inc MSB
     32  10e2		       28	   getILb2    plp		;restore status
     33  10e3		       60		      rts
     34  10e4							;
     35  10e4							;=====================================================
     36  10e4							; Decrement ILPC by one.
     37  10e4							;
     38  10e4		       a5 43	   decIL      lda	ILPC
     39  10e6		       d0 02		      bne	decIL2
     40  10e8		       c6 44		      dec	ILPC+1
     41  10ea		       c6 43	   decIL2     dec	ILPC
     42  10ec		       60		      rts
     43  10ed							;
     44  10ed							;=====================================================
     45  10ed							; Push the ILPC onto the return stack.  Actually, this
     46  10ed							; pushes the address of ILPC+2 since that's the next
     47  10ed							; address to execute.
     48  10ed							;
     49  10ed		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  10ef		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  10f1		       b0 15		      bcs	pushErr
     52  10f3		       a5 43		      lda	ILPC
     53  10f5		       18		      clc
     54  10f6		       69 02		      adc	#2
     55  10f8		       91 45		      sta	(ILSTACK),y
     56  10fa		       08		      php		;save C bit
     57  10fb		       c8		      iny
     58  10fc		       a5 44		      lda	ILPC+1
     59  10fe		       28		      plp		;restore C
     60  10ff		       69 00		      adc	#0
     61  1101		       91 45		      sta	(ILSTACK),y
     62  1103		       c8		      iny
     63  1104		       84 47		      sty	ILSTACKPTR
     64  1106		       18		      clc
     65  1107		       60		      rts
     66  1108				   pushErr
     67  1108		       38		      sec
     68  1109		       60		      rts
     69  110a							;
     70  110a							;=====================================================
     71  110a							; Pull the top entry from return stack and put into
     72  110a							; ILPC.
     73  110a							;
     74  110a		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  110c		       f0 fa		      beq	pushErr
     76  110e		       88		      dey
     77  110f		       b1 45		      lda	(ILSTACK),y
     78  1111		       85 44		      sta	ILPC+1
     79  1113		       88		      dey
     80  1114		       b1 45		      lda	(ILSTACK),y
     81  1116		       85 43		      sta	ILPC
     82  1118		       84 47		      sty	ILSTACKPTR
     83  111a		       18		      clc
     84  111b		       60		      rts
     85  111c							;
     86  111c							;=====================================================
     87  111c							; This searches for a specific line number that is in
     88  111c							; R0.	There are three possible return conditions:
     89  111c							; Line numbers are now the third byte, the first byte is now **************
     90  111c							; a pointer to the next line, of course no longer that 53 byte
     91  111c							; per line.
     92  111c							;
     93  111c							; Exact match was found:
     94  111c							;    * Z set
     95  111c							;    * CURPTR points to two-byte line number for that
     96  111c							;	line.
     97  111c							;
     98  111c							; Next highest line found:
     99  111c							;    * Z cleared
    100  111c							;    * C set
    101  111c							;    * CURPTR points to two-byte line number for that
    102  111c							;	line.
    103  111c							;
    104  111c							; End of program reached:
    105  111c							;    * Z cleared
    106  111c							;    * C cleared
    107  111c							;    * CURPTR points to first free byte at end of
    108  111c							;	program.  Ie, it has save value as PROGRAMEND.
    109  111c							;
    110  111c							; A, X, and Y are all undefined on return.
    111  111c							;
    112  111c
    113  111c				   findLine
    114  111c		       a9 0f		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    115  111e		       85 4f		      sta	CURPTR
    116  1120		       a9 26		      lda	#ProgramStart>>8
    117  1122		       85 50		      sta	CURPTR+1
    118  1124							;
    119  1124							; At end of code?
    120  1124							;
    121  1124				   iXFER1
    122  1124		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1126		       cd 07 26 	      cmp	PROGRAMEND	; at end of program then stop run
    124  1129		       d0 0b		      bne	xfer2	; not end
    125  112b		       a5 50		      lda	CURPTR+1
    126  112d		       cd 08 26 	      cmp	PROGRAMEND+1
    127  1130		       d0 04		      bne	xfer2	;Not at end
    128  1132							;
    129  1132							; Line not found and the end of the program was
    130  1132							; reached.  Return Z and C both clear.
    131  1132							;
    132  1132		       a9 01		      lda	#1	;clear Z
    133  1134		       18		      clc		;clear C
    134  1135		       60		      rts
    135  1136							;
    136  1136							; Check for an exact line number match
    137  1136							;
    138  1136		       a5 52	   xfer2      lda	R0
    139  1138		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  113a		       d1 4f		      cmp	(CURPTR),y
    141  113c		       d0 08		      bne	xfernotit
    142  113e		       c8		      iny
    143  113f		       a5 53		      lda	R0+1
    144  1141		       d1 4f		      cmp	(CURPTR),y
    145  1143		       d0 01		      bne	xfernotit	; not a matching line number
    146  1145							;
    147  1145							; This is exactly the line we want.
    148  1145							;
    149  1145		       60		      rts		;it matches exactly
    150  1146							;
    151  1146							; See if this line is greater than the one we're
    152  1146							; searching for.
    153  1146							;
    154  1146		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    155  1148		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  114a		       c5 53		      cmp	R0+1
    157  114c		       90 0b		      bcc	xfer3
    158  114e		       d0 07		      bne	xfer4
    159  1150		       88		      dey
    160  1151		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1153		       c5 52		      cmp	R0
    162  1155		       90 02		      bcc	xfer3
    163  1157							;
    164  1157							; This line is greater than the one we want, so
    165  1157							; return Z clear and C set.
    166  1157							;
    167  1157		       38	   xfer4      sec		;We found a line number greater
    168  1158		       60		      rts		;both conditions set
    169  1159							;
    170  1159							; Not the line (or droid) we're looking for.  Move to
    171  1159							; the next line.
    172  1159							;
    173  1159		       20 5f 11    xfer3      jsr	FindNextLine
    174  115c		       4c 24 11 	      jmp	iXFER1
    175  115f							;
    176  115f							;=====================================================
    177  115f							; This advances CURPTR to the next line.  If there
    178  115f							; are no more lines, this leaves CURPTR equal to
    179  115f							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  115f							; CURPTR is pointing to a valid line on entry.  This
    181  115f							; pointer points to the two-byte line number.
    182  115f							; Update this points to the 1 byte line length  ****************
    183  115f							;
    184  115f				   FindNextLine
    185  115f		       a0 03		      ldy	#3	;skip line number and length byte
    186  1161		       84 51		      sty	CUROFF	;this is the new offset
    187  1163		       a0 00		      ldy	#0
    188  1165		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1167		       18		      clc
    190  1168		       65 4f		      adc	CURPTR
    191  116a		       85 4f		      sta	CURPTR
    192  116c		       90 02		      bcc	FindNext4	;exit
    193  116e		       e6 50		      inc	CURPTR+1
    194  1170		       60	   FindNext4  rts
    195  1171							;
    196  1171							;=====================================================
    197  1171							; This compares CURPTR to PROGRAMEND and returns Z set
    198  1171							; if they are equal, Z clear if not.
    199  1171							;
    200  1171		       a5 4f	   AtEnd      lda	CURPTR
    201  1173		       cd 07 26 	      cmp	PROGRAMEND
    202  1176		       d0 05		      bne	atendexit
    203  1178		       a5 50		      lda	CURPTR+1
    204  117a		       cd 08 26 	      cmp	PROGRAMEND+1
    205  117d		       60	   atendexit  rts
    206  117e							;
    207  117e							;=====================================================
    208  117e							; Print the contents of R0 as a signed decimal number.
    209  117e							; Does leading zero suppression.
    210  117e							;
    211  117e				   PrintDecimal
    212  117e		       a5 53		      lda	R0+1	;MSB has sign
    213  1180		       10 17		      bpl	pplus	;it's a positive number
    214  1182							;
    215  1182							; Negative numbers need more work.  Invert all the bits,
    216  1182							; then add one.
    217  1182							;
    218  1182		       a9 2d		      lda	#'-
    219  1184		       20 ec 15 	      jsr	VOUTCH	;print the negative sign
    220  1187							;
    221  1187		       a5 52		      lda	R0	;invert bits
    222  1189		       49 ff		      eor	#$ff
    223  118b		       85 52		      sta	R0
    224  118d		       a5 53		      lda	R0+1
    225  118f		       49 ff		      eor	#$ff
    226  1191		       85 53		      sta	R0+1
    227  1193		       e6 52		      inc	R0	;add one
    228  1195		       d0 02		      bne	pplus
    229  1197		       e6 53		      inc	R0+1
    230  1199							;
    231  1199							; Print the value in R0 as a positive number.
    232  1199							;
    233  1199		       a2 00	   pplus      ldx	#0	;start of subtraction table
    234  119b		       8e f9 25 	      stx	diddigit	;no digits yet
    235  119e		       a0 00	   pploop     ldy	#0	;result of division
    236  11a0		       a5 52	   pploop2    lda	R0	;LSB
    237  11a2		       38		      sec
    238  11a3		       fd e2 11 	      sbc	dectable,x
    239  11a6		       85 52		      sta	R0
    240  11a8		       a5 53		      lda	R0+1
    241  11aa		       fd e3 11 	      sbc	dectable+1,x
    242  11ad		       10 2e		      bpl	pplusok	;no underflow
    243  11af							;
    244  11af							; Else, underflow.  Add back in the LSB of the
    245  11af							; table to R0.
    246  11af							;
    247  11af		       18		      clc
    248  11b0		       a5 52		      lda	R0
    249  11b2		       7d e2 11 	      adc	dectable,x
    250  11b5		       85 52		      sta	R0
    251  11b7							;
    252  11b7							; Print the value in Y.  Actually, see if Y is zero and
    253  11b7							; whether any digit has been printed yet.  If Y isn't
    254  11b7							; zero or we've printed a digit, go ahead and print.
    255  11b7							;
    256  11b7		       8e f6 25 	      stx	printtx
    257  11ba		       98		      tya
    258  11bb		       09 00		      ora	#0	;set flags
    259  11bd		       d0 05		      bne	pprintit	;non-zero, print
    260  11bf							;
    261  11bf		       ad f9 25 	      lda	diddigit
    262  11c2		       f0 09		      beq	pprintno	;don't print
    263  11c4							;
    264  11c4		       98	   pprintit   tya
    265  11c5		       09 30		      ora	#'0
    266  11c7		       8d f9 25 	      sta	diddigit
    267  11ca		       20 ec 15 	      jsr	VOUTCH
    268  11cd		       ae f6 25    pprintno   ldx	printtx
    269  11d0							;
    270  11d0							; Move to the next table entry
    271  11d0							;
    272  11d0		       e8		      inx
    273  11d1		       e8		      inx
    274  11d2		       e0 08		      cpx	#dectableend-dectable
    275  11d4		       d0 c8		      bne	pploop	;not at end
    276  11d6							;
    277  11d6							; At the end.	R0 contains the final value
    278  11d6							; to print.
    279  11d6							;
    280  11d6		       a5 52		      lda	R0
    281  11d8		       09 30		      ora	#'0
    282  11da		       4c ec 15 	      jmp	VOUTCH
    283  11dd							;
    284  11dd							; Finish doing the subtraction.
    285  11dd							;
    286  11dd		       85 53	   pplusok    sta	R0+1
    287  11df		       c8		      iny
    288  11e0		       d0 be		      bne	pploop2
    289  11e2							;
    290  11e2							; Table of powers-of-ten
    291  11e2							;
      0  11e2				   dectable   dw	10000
      1  11e2		       10 27		      .word.w	10000
      0  11e4					      dw	1000
      1  11e4		       e8 03		      .word.w	1000
      0  11e6					      dw	100
      1  11e6		       64 00		      .word.w	100
      0  11e8					      dw	10
      1  11e8		       0a 00		      .word.w	10
    296  11e8		       11 ea	   dectableend equ	*
    297  11ea							;
    298  11ea							;=====================================================
    299  11ea							; Convert an ASCII string to a number.  On input,
    300  11ea							; (CURPTR),Y points to the first digit.  This gets
    301  11ea							; digit-by-digit until finding a non-number.  Returns
    302  11ea							; Y pointing to the non-digit, and R0 contains the
    303  11ea							; number.  This does NOT check for valid ranges, so
    304  11ea							; a value like "123456789" will produce something,
    305  11ea							; but not what you had expected.
    306  11ea							;
    307  11ea		       a9 00	   getDecimal lda	#0
    308  11ec		       85 52		      sta	R0
    309  11ee		       85 53		      sta	R0+1
    310  11f0		       85 59		      sta	dpl	;temporary negative flag
    311  11f2							;
    312  11f2							; See if it's negative...
    313  11f2							;
    314  11f2							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    315  11f2		       b1 4f		      lda	(CURPTR),y
    316  11f4		       c9 2d		      cmp	#'-
    317  11f6		       d0 02		      bne	getDecLoop
    318  11f8		       e6 59		      inc	dpl	;it's negative
    319  11fa							;
    320  11fa		       b1 4f	   getDecLoop lda	(CURPTR),y
    321  11fc		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    322  11fe		       c9 30		      cmp	#'0
    323  1200		       90 36		      bcc	getDdone
    324  1202		       c9 3a		      cmp	#'9+1
    325  1204		       b0 32		      bcs	getDdone
    326  1206		       38		      sec
    327  1207		       e9 30		      sbc	#'0	;convert to binary
    328  1209		       48		      pha
    329  120a							;
    330  120a							; Now multiply R0 by 10.  Remember that
    331  120a							; 2*N + 8*N = 10*N.
    332  120a							;
    333  120a		       06 52		      asl	R0
    334  120c		       26 53		      rol	R0+1	;*2
    335  120e		       a5 52		      lda	R0
    336  1210		       85 54		      sta	R1
    337  1212		       a5 53		      lda	R0+1
    338  1214		       85 55		      sta	R1+1
    339  1216		       06 52		      asl	R0
    340  1218		       26 53		      rol	R0+1	;*4
    341  121a		       06 52		      asl	R0
    342  121c		       26 53		      rol	R0+1	;*8
    343  121e		       18		      clc		;now add the partial sums...
    344  121f		       a5 52		      lda	R0	;...to get *10
    345  1221		       65 54		      adc	R1
    346  1223		       85 52		      sta	R0
    347  1225		       a5 53		      lda	R0+1
    348  1227		       65 55		      adc	R1+1
    349  1229		       85 53		      sta	R0+1
    350  122b							;
    351  122b							; Add in the new digit
    352  122b							;
    353  122b		       68		      pla
    354  122c		       18		      clc
    355  122d		       65 52		      adc	R0
    356  122f		       85 52		      sta	R0
    357  1231		       90 02		      bcc	getD2
    358  1233		       e6 53		      inc	R0+1
    359  1235							;
    360  1235							; Move to next character
    361  1235							;
    362  1235		       c8	   getD2      iny
    363  1236		       d0 c2		      bne	getDecLoop
    364  1238							;
    365  1238							; All done with digits, so now deal with it being
    366  1238							; negative.  If zero, then don't check for negative
    367  1238							; flag.  Ie, -0 is stored as 0.
    368  1238							;
    369  1238		       a5 52	   getDdone   lda	R0
    370  123a		       05 53		      ora	R0+1
    371  123c		       f0 16		      beq	getDone2	;zero
    372  123e		       a5 59		      lda	dpl
    373  1240		       f0 12		      beq	getDone2	;positive
    374  1242							;
    375  1242							; Invert all the bits, then add one.
    376  1242							;
    377  1242		       a5 52		      lda	R0
    378  1244		       49 ff		      eor	#$ff
    379  1246		       85 52		      sta	R0
    380  1248		       a5 53		      lda	R0+1
    381  124a		       49 ff		      eor	#$ff
    382  124c		       85 53		      sta	R0+1
    383  124e							;
    384  124e		       e6 52		      inc	R0
    385  1250		       d0 02		      bne	getDone2
    386  1252		       e6 53		      inc	R0+1
    387  1254				   getDone2
    388  1254							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    389  1254							;lda	  R0
    390  1254							;sta	  $0010
    391  1254							;lda	  R0+1
    392  1254							;sta	  $0011
    393  1254							;lda	  dpl
    394  1254							;sta	  $012
    395  1254
    396  1254		       60		      rts
    397  1255
    398  1255							;=====================================================
    399  1255							; Gets a line of input into LINBUF.
    400  1255							;
    401  1255							; On entry:
    402  1255							;    A contains the prompt character, or 0 if none.
    403  1255							;    X = 1 Background read
    404  1255							;    x = 0 Forground read with wait
    405  1255							;
    406  1255							; On exit:
    407  1255							;    CURPTR points to LINBUF
    408  1255							;    LINBUF contains the line with 0 at the end.
    409  1255							;    Y has offset to first non-space character
    410  1255							;    CURROFF has the same as Y.
    411  1255							;
    412  1255		       20 a4 12    GetLine    jsr	ReadPrompt
    413  1258		       e0 00		      cpx	#0
    414  125a		       f0 14		      beq	GetLineRetry
    415  125c		       ae b7 1c 	      ldx	taskPtr
    416  125f		       bd b8 1c 	      lda	taskTable,x
    417  1262		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    418  1264		       d0 3d		      bne	taskWaitingIO
    419  1266		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    420  1268		       9d b8 1c 	      sta	taskTable,x	;Mark the state for task as waiting io
    421  126b		       ce a3 12 	      dec	taskWaitingIO	;Start polling the input and make task wait
    422  126e		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    423  1270
    424  1270							;
    425  1270							; Now read a line and wait for the CR
    426  1270							;
    427  1270				   GetLineRetry
    428  1270		       a9 00		      lda	#0	;Wait for input to complete
    429  1272		       20 bc 12 	      jsr	ReadLine
    430  1275
    431  1275							;
    432  1275							; Point to the line we just read
    433  1275							; Set the current pointer to point to the input line
    434  1275							;
    435  1275		       a0 00	   ReadComplete ldy	#0
    436  1277		       84 51		      sty	CUROFF
    437  1279		       a2 71		      ldx	#LINBUF&$ff
    438  127b		       86 4f		      stx	CURPTR
    439  127d		       a2 25		      ldx	#LINBUF>>8
    440  127f		       86 50		      stx	CURPTR+1
    441  1281							;
    442  1281							; Output a CR/LF
    443  1281							;
    444  1281		       20 70 14 	      jsr	CRLF
    445  1284							;
    446  1284							; If a blank line, prompt again.
    447  1284							;
    448  1284		       20 67 14 	      jsr	SkipSpaces
    449  1287		       b1 4f		      lda	(CURPTR),y
    450  1289		       d0 10		      bne	GetLineDone	;We have data then exit
    451  128b		       20 a7 12 	      jsr	ReadPromptRetry
    452  128e		       ae b7 1c 	      ldx	taskPtr	;if this task is waiting for IO
    453  1291		       bd b8 1c 	      lda	taskTable,x	;then get out, wait for line to
    454  1294		       29 40		      and	#TASKWAITIO	;Complete again
    455  1296		       d0 0b		      bne	taskWaitingIO
    456  1298		       4c 70 12 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    457  129b
    458  129b				   GetLineDone
    459  129b		       ae b7 1c 	      ldx	taskPtr
    460  129e		       a9 80		      lda	#TASKACTIVE
    461  12a0		       9d b8 1c 	      sta	taskTable,x	;IO is complete
    462  12a3
    463  12a3				   taskWaitingIO
    464  12a3		       60		      rts
    465  12a4
    466  12a4							;
    467  12a4							;=======================================================================
    468  12a4							; Display the prompt character
    469  12a4							; On entry
    470  12a4							;	    A contains the prompt character
    471  12a4							; On exit
    472  12a4							;	    The readbuffer index is reset to 0
    473  12a4							;
    474  12a4		       8d f8 25    ReadPrompt sta	promptChar
    475  12a7
    476  12a7							;
    477  12a7							; Prompt
    478  12a7							;
    479  12a7
    480  12a7		       ad f8 25    ReadPromptRetry lda	promptChar
    481  12aa		       09 00		      ora	#0	;any prompt?
    482  12ac		       f0 08		      beq	getlinenp
    483  12ae		       20 ec 15 	      jsr	VOUTCH
    484  12b1		       a9 20		      lda	#$20
    485  12b3		       20 ec 15 	      jsr	VOUTCH	;Space after prompt
    486  12b6							;
    487  12b6		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    488  12b8		       8e f5 25 	      stx	getlinx
    489  12bb		       60		      rts
    490  12bc							;
    491  12bc							;===============================================================
    492  12bc							; This fuction is the driver for the line input
    493  12bc							; on call if a = 0 then it waits for all input
    494  12bc							;	      a = 1 then nowait for input
    495  12bc							; On exit
    496  12bc							;		       c clear if not complete line
    497  12bc							;		       c set if it was a complete line
    498  12bc
    499  12bc				   ReadLine
    500  12bc		       8d f7 25 	      sta	inputNoWait
    501  12bf		       c9 00		      cmp	#0
    502  12c1		       f0 05		      beq	getline1
    503  12c3		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    504  12c6		       f0 2b		      beq	GetLineNoWait
    505  12c8		       20 ef 15    getline1   jsr	VGETCH
    506  12cb					      if	CTMON65
    507  12cb		       48		      pha
    508  12cc		       20 ec 15 	      jsr	VOUTCH	;echo echo echo
    509  12cf		       68		      pla
    510  12d0					      endif
    511  12d0		       c9 0d		      cmp	#CR
    512  12d2		       f0 15		      beq	getlind	;end of line
    513  12d4		       c9 08		      cmp	#BS	;backspace?
    514  12d6		       f0 1d		      beq	getlinebs
    515  12d8		       ae f5 25 	      ldx	getlinx
    516  12db		       9d 71 25 	      sta	LINBUF,x
    517  12de		       e8		      inx
    518  12df		       8e f5 25 	      stx	getlinx
    519  12e2		       ad f7 25 	      lda	inputNoWait
    520  12e5		       f0 e1		      beq	getline1
    521  12e7		       d0 0a		      bne	GetLineNoWait
    522  12e9							;
    523  12e9							; CR was hit
    524  12e9							;
    525  12e9		       a9 00	   getlind    lda	#0	; set the end pf buffer
    526  12eb		       ae f5 25 	      ldx	getlinx
    527  12ee		       9d 71 25 	      sta	LINBUF,x
    528  12f1
    529  12f1		       38		      sec		; Carry set then cr received
    530  12f2		       60		      rts
    531  12f3
    532  12f3				   GetLineNoWait
    533  12f3		       18		      clc		; Carry clear no end of line
    534  12f4		       60		      rts
    535  12f5							;
    536  12f5							; Backspace was hit
    537  12f5							;
    538  12f5		       ae f5 25    getlinebs  ldx	getlinx
    539  12f8		       f0 0e		      beq	getlineEOL	;at start of line
    540  12fa		       ca		      dex
    541  12fb		       8e f5 25 	      stx	getlinx
    542  12fe		       20 f2 15    getlinepbs jsr	puts
      0  1301					      db	27,"[K",0
      1  1301		       1b 5b 4b 00	      .byte.b	27,"[K",0
    544  1305		       4c c8 12 	      jmp	getline1
    545  1308		       a9 20	   getlineEOL lda	#SPACE
    546  130a		       20 ec 15 	      jsr	VOUTCH
    547  130d		       d0 ef		      bne	getlinepbs
    548  130f							;
    549  130f							;=====================================================
    550  130f							; Count the length of the line currently in LINBUF
    551  130f							; starting at offset Y.  Returns the length in X.  The
    552  130f							; starting offset in Y should point past the ASCII
    553  130f							; line number.  Also counts the trailing NULL and two
    554  130f							; extra bytes for where the line number will be.
    555  130f							; Update must now include leading length byte not the null at end ****************
    556  130f							;
    557  130f				   getLineLength
    558  130f		       a2 00		      ldx	#0	;size
    559  1311		       b9 71 25    getLineL2  lda	LINBUF,y
    560  1314		       f0 04		      beq	getLineL3
    561  1316		       c8		      iny
    562  1317		       e8		      inx
    563  1318		       d0 f7		      bne	getLineL2
    564  131a		       e8	   getLineL3  inx		;count null at end
    565  131b		       e8		      inx		;line number LSB
    566  131c		       e8		      inx		;MSB
    567  131d		       e8		      inx		;change: count new leading line length
    568  131e		       86 5f		      stx	lineLength
    569  1320		       60		      rts
    570  1321							;
    571  1321							;=====================================================
    572  1321							; Count the length of the line pointed to by CURPTR.
    573  1321							; This also counts the line number and the terminating
    574  1321							; null.  Ie, this string returns 8:
    575  1321							;
    576  1321							; <lineLow><lineHi>Hello<null>
    577  1321							;
    578  1321							; Another way of looking at it: add the return value
    579  1321							; to the CURPTR and it'll point to the next line's
    580  1321							; line number.  Returns the value in Y.
    581  1321							; Update to ject get the leading byte length ********************
    582  1321							;
    583  1321							;getCURPTRLength
    584  1321							;		ldy	CURPTR
    585  1321							;		ldy	#3	;change: skip line number and leading length byte
    586  1321							;getCLineL2	lda	(CURPTR),y
    587  1321							;		beq	getCLineL3
    588  1321							;		iny
    589  1321							;		bne	getCLineL2
    590  1321							;getCLineL3	iny		;count null at end
    591  1321							;		rts
    592  1321
    593  1321							;
    594  1321							;=====================================================
    595  1321							; This saves ILPC.  This saves to a single save area,
    596  1321							; so it can't be called more than once.
    597  1321							;
    598  1321		       a5 43	   saveIL     lda	ILPC
    599  1323		       85 5b		      sta	tempIL
    600  1325		       a5 44		      lda	ILPC+1
    601  1327		       85 5c		      sta	tempIL+1
    602  1329		       60		      rts
    603  132a							;
    604  132a							;=====================================================
    605  132a							; This restores ILPC.
    606  132a							;
    607  132a		       a5 5b	   restoreIL  lda	tempIL
    608  132c		       85 43		      sta	ILPC
    609  132e		       a5 5c		      lda	tempIL+1
    610  1330		       85 44		      sta	ILPC+1
    611  1332		       60		      rts
    612  1333							;
    613  1333							;=====================================================
    614  1333							; This pushes R0 onto the stack.
    615  1333							;
    616  1333		       8c fe 25    pushR0     sty	rtemp1
    617  1336		       a4 4a		      ldy	MATHSTACKPTR
    618  1338		       c0 28		      cpy	#MATHSTACKSIZE<<1
    619  133a		       b0 34		      bcs	pusherr
    620  133c		       a5 52		      lda	R0
    621  133e		       91 48		      sta	(MATHSTACK),y
    622  1340		       c8		      iny
    623  1341		       a5 53		      lda	R0+1
    624  1343		       91 48		      sta	(MATHSTACK),y
    625  1345		       c8		      iny
    626  1346		       84 4a		      sty	MATHSTACKPTR
    627  1348		       ac fe 25 	      ldy	rtemp1
    628  134b		       18		      clc
    629  134c		       60		      rts
    630  134d
    631  134d							;=====================================================
    632  134d							; This pushes curptr basic current line onto the call stack.
    633  134d							; and CUROFF. Also marks entry type as 1 = GOSUB
    634  134d
    635  134d				   pushLN
    636  134d		       8c fe 25 	      sty	rtemp1
    637  1350		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    638  1352		       c5 4d		      cmp	GOSUBSTACKPTR
    639  1354		       90 1a		      bcc	pusherr	; No error
    640  1356		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    641  1358		       a2 00		      ldx	#0	; Start of bytes to copy
    642  135a				   pushLoop
    643  135a		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    644  135c		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    645  135e		       c8		      iny		; Next destination
    646  135f		       e8		      inx		; Next Source byte
    647  1360		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    648  1362		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    649  1364
    650  1364		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    651  1366		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    652  1368		       c8		      iny		; Next entry
    653  1369
    654  1369		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    655  136b		       ac fe 25 	      ldy	rtemp1
    656  136e		       18		      clc
    657  136f		       60		      rts
    658  1370				   pusherr
    659  1370		       38		      sec
    660  1371		       60		      rts
    661  1372							;=====================================================
    662  1372							; This pops Top Off gosub call Stack and
    663  1372							; places it in CURPTR/CUROFF.
    664  1372							; This checks if the type = 1 GOSUB
    665  1372							; if not it removes what ever is on the stack
    666  1372							; until it finds the next return. Allowing
    667  1372							; a return from within a for/next
    668  1372		       8c fe 25    popLN      sty	rtemp1
    669  1375		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    670  1377		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    671  1379
    672  1379				   popContinue
    673  1379		       c0 04		      cpy	#4	; if less than 4 on stack then error
    674  137b		       90 18		      bcc	poperr	; Process an error
    675  137d
    676  137d		       88		      dey		; Position to read entry type
    677  137e		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    678  1380		       c9 01		      cmp	#1	; Type is a gosub entry
    679  1382		       d0 13		      bne	popSkipEntry	; No then just skip this
    680  1384
    681  1384				   popLoop
    682  1384		       88		      dey
    683  1385		       ca		      dex
    684  1386		       b1 4b		      lda	(GOSUBSTACK),y
    685  1388		       95 4f		      sta	CURPTR,x
    686  138a		       e0 00		      cpx	#0
    687  138c		       d0 f6		      bne	popLoop	; Loop until all moved
    688  138e
    689  138e
    690  138e		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    691  1390		       ac fe 25 	      ldy	rtemp1
    692  1393		       18		      clc
    693  1394		       60		      rts
    694  1395
    695  1395		       38	   poperr     sec
    696  1396		       60		      rts
    697  1397
    698  1397		       88	   popSkipEntry dey
    699  1398		       88		      dey
    700  1399		       88		      dey
    701  139a		       4c 79 13 	      jmp	popContinue
    702  139d
    703  139d							;
    704  139d							;=====================================================
    705  139d							; This pushes R1 onto the stack
    706  139d							;
    707  139d		       8c fe 25    pushR1     sty	rtemp1
    708  13a0		       a4 4a		      ldy	MATHSTACKPTR
    709  13a2		       c0 28		      cpy	#MATHSTACKSIZE<<1
    710  13a4		       b0 ef		      bcs	poperr
    711  13a6		       a5 54		      lda	R1
    712  13a8		       91 48		      sta	(MATHSTACK),y
    713  13aa		       c8		      iny
    714  13ab		       a5 55		      lda	R1+1
    715  13ad		       91 48		      sta	(MATHSTACK),y
    716  13af		       c8		      iny
    717  13b0		       84 4a		      sty	MATHSTACKPTR
    718  13b2		       ac fe 25 	      ldy	rtemp1
    719  13b5		       18		      clc
    720  13b6		       60		      rts
    721  13b7							;
    722  13b7							;=====================================================
    723  13b7							; This pops Top Of Stack and places it in R0.
    724  13b7							;
    725  13b7		       8c fe 25    popR0      sty	rtemp1
    726  13ba		       a4 4a		      ldy	MATHSTACKPTR
    727  13bc		       f0 d7		      beq	poperr
    728  13be		       88		      dey
    729  13bf		       b1 48		      lda	(MATHSTACK),y
    730  13c1		       85 53		      sta	R0+1
    731  13c3		       88		      dey
    732  13c4		       b1 48		      lda	(MATHSTACK),y
    733  13c6		       85 52		      sta	R0
    734  13c8		       84 4a		      sty	MATHSTACKPTR
    735  13ca		       ac fe 25 	      ldy	rtemp1
    736  13cd		       18		      clc
    737  13ce		       60		      rts
    738  13cf
    739  13cf							;
    740  13cf							;=====================================================
    741  13cf							; This pops TOS and places it in R1.
    742  13cf							;
    743  13cf		       8c fe 25    popR1      sty	rtemp1
    744  13d2		       a4 4a		      ldy	MATHSTACKPTR
    745  13d4		       f0 bf		      beq	poperr
    746  13d6		       88		      dey
    747  13d7		       b1 48		      lda	(MATHSTACK),y
    748  13d9		       85 55		      sta	R1+1
    749  13db		       88		      dey
    750  13dc		       b1 48		      lda	(MATHSTACK),y
    751  13de		       85 54		      sta	R1
    752  13e0		       84 4a		      sty	MATHSTACKPTR
    753  13e2		       ac fe 25 	      ldy	rtemp1
    754  13e5		       60		      rts
    755  13e6							;
    756  13e6							;=====================================================
    757  13e6							; This pops TOS and places it in MQ.
    758  13e6							;
    759  13e6		       8c fe 25    popMQ      sty	rtemp1
    760  13e9		       a4 4a		      ldy	MATHSTACKPTR
    761  13eb		       f0 a8		      beq	poperr
    762  13ed		       88		      dey
    763  13ee		       b1 48		      lda	(MATHSTACK),y
    764  13f0		       85 57		      sta	MQ+1
    765  13f2		       88		      dey
    766  13f3		       b1 48		      lda	(MATHSTACK),y
    767  13f5		       85 56		      sta	MQ
    768  13f7		       84 4a		      sty	MATHSTACKPTR
    769  13f9		       ac fe 25 	      ldy	rtemp1
    770  13fc		       60		      rts
    771  13fd							;
    772  13fd							;=====================================================
    773  13fd							; This assists with multiplication and division by
    774  13fd							; looking at R0 and R1 and saving a flag as to what
    775  13fd							; sign the result will be.  Math is always done on
    776  13fd							; positive numbers, so this converts negative numbers
    777  13fd							; into positives.  On exit, R0 and R1 are both
    778  13fd							; positive.  If the signs were different then 'signs'
    779  13fd							; will be non-zero.
    780  13fd							;
    781  13fd		       a9 00	   SaveSigns  lda	#0
    782  13ff		       8d fd 25 	      sta	sign	;assume positive
    783  1402		       a5 53		      lda	R0+1	;MSB
    784  1404		       10 13		      bpl	SaveSigns1
    785  1406		       ee fd 25 	      inc	sign	;it's negative
    786  1409		       49 ff		      eor	#$ff	;flip bits
    787  140b		       85 53		      sta	R0+1
    788  140d		       a5 52		      lda	R0
    789  140f		       49 ff		      eor	#$ff
    790  1411		       85 52		      sta	R0
    791  1413		       e6 52		      inc	R0
    792  1415		       d0 02		      bne	SaveSigns1
    793  1417		       e6 53		      inc	R0+1
    794  1419		       a5 55	   SaveSigns1 lda	R1+1
    795  141b		       10 1a		      bpl	SaveSigns2
    796  141d		       48		      pha
    797  141e		       ad fd 25 	      lda	sign
    798  1421		       49 01		      eor	#1
    799  1423		       8d fd 25 	      sta	sign
    800  1426		       68		      pla
    801  1427		       49 ff		      eor	#$ff	;flip bits
    802  1429		       85 55		      sta	R1+1
    803  142b		       a5 54		      lda	R1
    804  142d		       49 ff		      eor	#$ff
    805  142f		       85 54		      sta	R1
    806  1431		       e6 54		      inc	R1
    807  1433		       d0 02		      bne	SaveSigns2
    808  1435		       e6 55		      inc	R1+1
    809  1437		       60	   SaveSigns2 rts
    810  1438							;
    811  1438							;=====================================================
    812  1438							; This looks at the value of 'signs' and will convert
    813  1438							; both R0 and R1 to negative if set.
    814  1438							;
    815  1438				   RestoreSigns
    816  1438		       ad fd 25 	      lda	sign
    817  143b		       f0 28		      beq	restoresigns2
    818  143d							;
    819  143d		       a5 52		      lda	R0
    820  143f		       d0 02		      bne	restoresigns3
    821  1441		       c6 53		      dec	R0+1
    822  1443				   restoresigns3
    823  1443		       c6 52		      dec	R0
    824  1445		       a5 52		      lda	R0
    825  1447		       49 ff		      eor	#$ff
    826  1449		       85 52		      sta	R0
    827  144b		       a5 53		      lda	R0+1
    828  144d		       49 ff		      eor	#$ff
    829  144f		       85 53		      sta	R0+1
    830  1451							;
    831  1451		       a5 54		      lda	R1
    832  1453		       d0 02		      bne	restoresigns4
    833  1455		       c6 55		      dec	R1+1
    834  1457				   restoresigns4
    835  1457		       c6 54		      dec	R1
    836  1459		       a5 54		      lda	R1
    837  145b		       49 ff		      eor	#$ff
    838  145d		       85 54		      sta	R1
    839  145f		       a5 55		      lda	R1+1
    840  1461		       49 ff		      eor	#$ff
    841  1463		       85 55		      sta	R1+1
    842  1465							;
    843  1465				   restoresigns2
    844  1465		       60		      rts
    845  1466							;
    846  1466							;=====================================================
    847  1466							; Skip over spaces.  Returns Y with the offset to
    848  1466							; either the last character in the line, or the first
    849  1466							; non-space character.
    850  1466							;
    851  1466
    852  1466		       c8	   skipsp2    iny
    853  1467		       b1 4f	   SkipSpaces lda	(CURPTR),y
    854  1469		       f0 04		      beq	Skip3	;end of line
    855  146b		       c9 20		      cmp	#SPACE
    856  146d		       f0 f7		      beq	skipsp2
    857  146f		       60	   Skip3      rts
    858  1470							;*********************************************************
    859  1470							; Output a CR/LF combination to the console.  Preserves
    860  1470							; all registers.
    861  1470							;
    862  1470		       48	   tbcrlf     pha
    863  1471		       a9 0d		      lda	#CR
    864  1473		       20 ec 15 	      jsr	VOUTCH
    865  1476		       a9 0a		      lda	#LF
    866  1478		       20 ec 15 	      jsr	VOUTCH
    867  147b		       68		      pla
    868  147c		       60		      rts
    869  147d							;
    870  147d							;=====================================================
    871  147d							; Some logic to print the Line of basic code being executed
    872  147d		       24 40	   idbgBasic  bit	ILTrace
    873  147f		       50 70		      bvc	dbgBasicNone
    874  1481		       98		      tya
    875  1482		       48		      pha
    876  1483		       20 92 16 	      jsr	SetOutDebug
    877  1486		       20 15 16 	      jsr	PrtPrgLine
    878  1489		       20 70 14 	      jsr	CRLF
    879  148c		       a5 40		      lda	ILTrace
    880  148e		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    881  1490		       f0 5a		      beq	dbgBasicDone
    882  1492		       20 9d 16 	      jsr	SetInDebug
    883  1495		       20 f2 15 	      jsr	puts
      0  1498					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1498		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    885  14d5				   dbgBasicLoop
    886  14d5		       20 ef 15 	      jsr	VGETCH
    887  14d8		       20 70 14 	      jsr	CRLF
    888  14db		       20 df 15 	      jsr	SetInConsole
    889  14de
    890  14de		       c9 73		      cmp	#'s	; Quit program
    891  14e0		       f0 12		      beq	dbgBasicStop
    892  14e2
    893  14e2		       c9 64		      cmp	#'d	; Display Variables
    894  14e4		       d0 06		      bne	dbgBasicDone
    895  14e6
    896  14e6		       20 c1 16 	      jsr	PrintAllVars
    897  14e9		       18		      clc
    898  14ea		       90 e9		      bcc	dbgBasicLoop	; Next char
    899  14ec
    900  14ec		       20 d2 15    dbgBasicDone jsr	SetOutConsole
    901  14ef		       68		      pla
    902  14f0		       a8		      tay
    903  14f1		       4c b9 02    dbgBasicNone jmp	NextIL
    904  14f4
    905  14f4				   dbgBasicStop
    906  14f4		       20 d2 15 	      jsr	SetOutConsole
    907  14f7		       68		      pla
    908  14f8		       a8		      tay
    909  14f9		       4c eb 05 	      jmp	iFIN
    910  14fc							;
    911  14fc							;=====================================================
    912  14fc							; This is some debug logic which displays the current
    913  14fc							; value of the ILPC and the line buffer.
    914  14fc							;
    915  14fc		       24 40	   dbgLine    bit	ILTrace
    916  14fe		       30 01		      bmi	dbgPrt
    917  1500		       60		      rts
    918  1501				   dbgPrt
    919  1501		       20 92 16 	      jsr	SetOutDebug
    920  1504		       20 f2 15 	      jsr	puts
      0  1507					      db	"ILPC: ",0
      1  1507		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    922  150e		       a5 44		      lda	ILPC+1
    923  1510		       20 4b 16 	      jsr	OUTHEX
    924  1513		       a5 43		      lda	ILPC
    925  1515		       20 4b 16 	      jsr	OUTHEX
    926  1518		       a9 20		      lda	#SPACE
    927  151a		       20 ec 15 	      jsr	VOUTCH
    928  151d		       a0 00		      ldy	#0
    929  151f		       b1 43		      lda	(ILPC),y
    930  1521		       20 4b 16 	      jsr	OUTHEX
    931  1524							;
    932  1524							; Display the CURPTR value and offset
    933  1524							;
    934  1524		       20 f2 15 	      jsr	puts
      0  1527					      db	", CURPTR: ",0
      1  1527		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    936  1532		       a5 50		      lda	CURPTR+1
    937  1534		       20 4b 16 	      jsr	OUTHEX
    938  1537		       a5 4f		      lda	CURPTR
    939  1539		       20 4b 16 	      jsr	OUTHEX
    940  153c		       a9 2b		      lda	#'+
    941  153e		       20 ec 15 	      jsr	VOUTCH
    942  1541		       a5 51		      lda	CUROFF
    943  1543		       20 4b 16 	      jsr	OUTHEX
    944  1546							;
    945  1546		       20 70 14 	      jsr	CRLF
    946  1549		       20 d2 15 	      jsr	SetOutConsole
    947  154c		       20 7f 15 	      jsr	ILChkRange
    948  154f		       b0 02		      bcs	dbgLineErr
    949  1551		       18		      clc
    950  1552		       60		      rts
    951  1553
    952  1553				   dbgLineErr
    953  1553		       20 92 16 	      jsr	SetOutDebug
    954  1556		       20 f2 15 	      jsr	puts
      0  1559					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1559		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    956  157a		       20 d2 15 	      jsr	SetOutConsole
    957  157d		       38		      sec
    958  157e		       60		      rts
    959  157f
    960  157f		       a5 44	   ILChkRange lda	ILPC+1
    961  1581		       c9 18		      cmp	#IL>>8
    962  1583		       90 18		      bcc	ILBadRange
    963  1585		       d0 06		      bne	ILChkHigh
    964  1587
    965  1587		       a5 43		      lda	ILPC
    966  1589		       c9 19		      cmp	#IL&$ff
    967  158b		       90 10		      bcc	ILBadRange
    968  158d
    969  158d		       a5 44	   ILChkHigh  lda	ILPC+1
    970  158f		       c9 1c		      cmp	#ILEND>>8
    971  1591		       90 08		      bcc	ILGoodRange
    972  1593		       d0 08		      bne	ILBadRange
    973  1595
    974  1595		       a5 43		      lda	ILPC
    975  1597		       c9 a2		      cmp	#ILEND&$ff
    976  1599		       b0 02		      bcs	ILBadRange
    977  159b
    978  159b		       18	   ILGoodRange clc
    979  159c		       60		      rts
    980  159d				   ILBadRange
    981  159d		       38		      sec
    982  159e		       60		      rts
    983  159f
    984  159f							;
    985  159f							;=====================================================
    986  159f							; This function might go away eventually, but was
    987  159f							; added to provide data for other pieces of code.
    988  159f							; It has some ties to the operating environment that
    989  159f							; will need to be customized for the target system.
    990  159f							;
    991  159f				   GetSizes
    992  159f							;
    993  159f							; Here is machine specific code to get the highest
    994  159f							; memory location that can be used by BASIC.
    995  159f							;
    996  159f				  -	      if	ProgramStart < $2000
    997  159f				  -	      lda	#$ff
    998  159f				  -	      sta	HighMem	;$13ff for KIM-1
    999  159f				  -	      lda	#$DE	;#$13
   1000  159f				  -	      sta	HighMem+1
   1001  159f					      else
   1002  159f		       a9 ff		      lda	#$ff
   1003  15a1		       8d 09 26 	      sta	HighMem	;$CFFF otherwise
   1004  15a4		       a9 cf		      lda	#$cf
   1005  15a6		       8d 0a 26 	      sta	HighMem+1
   1006  15a9					      endif
   1007  15a9							;
   1008  15a9							; This computes the available memory remaining.
   1009  15a9							;
   1010  15a9		       38		      sec
   1011  15aa		       ad 09 26 	      lda	HighMem
   1012  15ad		       ed 07 26 	      sbc	PROGRAMEND
   1013  15b0		       8d 0d 26 	      sta	FreeMem
   1014  15b3		       85 52		      sta	R0
   1015  15b5		       ad 0a 26 	      lda	HighMem+1
   1016  15b8		       ed 08 26 	      sbc	PROGRAMEND+1
   1017  15bb		       8d 0e 26 	      sta	FreeMem+1
   1018  15be		       85 53		      sta	R0+1
   1019  15c0							;
   1020  15c0							; This computes the size of the current user program.
   1021  15c0							;
   1022  15c0		       38		      sec
   1023  15c1		       ad 07 26 	      lda	PROGRAMEND
   1024  15c4		       e9 0f		      sbc	#ProgramStart&$ff
   1025  15c6		       8d 0b 26 	      sta	UsedMem
   1026  15c9		       ad 08 26 	      lda	PROGRAMEND+1
   1027  15cc		       e9 26		      sbc	#ProgramStart>>8
   1028  15ce		       8d 0c 26 	      sta	UsedMem+1
   1029  15d1							;
   1030  15d1		       60		      rts
   1031  15d2							;
   1032  15d2							;=====================================================
   1033  15d2							; Set output vector to the console output function
   1034  15d2							;
   1035  15d2				   SetOutConsole
   1036  15d2		       48		      pha
   1037  15d3		       a9 0c		      lda	#OUTCH&$ff
   1038  15d5		       8d 02 26 	      sta	BOutVec
   1039  15d8		       a9 f0		      lda	#OUTCH>>8
   1040  15da		       8d 03 26 	      sta	BOutVec+1
   1041  15dd		       68		      pla
   1042  15de		       60		      rts
   1043  15df
   1044  15df				   SetInConsole
   1045  15df		       48		      pha
   1046  15e0		       a9 09		      lda	#GETCH&$ff
   1047  15e2		       8d 04 26 	      sta	BInVec
   1048  15e5		       a9 f0		      lda	#GETCH>>8
   1049  15e7		       8d 05 26 	      sta	BInVec+1
   1050  15ea		       68		      pla
   1051  15eb		       60		      rts
   1052  15ec
   1053  15ec							;=====================================================
   1054  15ec							; Jump to the output/input function in BOutVec/BInVec
   1055  15ec							;
   1056  15ec		       6c 02 26    VOUTCH     jmp	(BOutVec)
   1057  15ef		       6c 04 26    VGETCH     jmp	(BInVec)
   1058  15f2							;
   1059  15f2							;=====================================================
   1060  15f2							; Print the string that immediately follows the JSR to
   1061  15f2							; this function.  Stops when a null byte is found,
   1062  15f2							; then returns to the instruction immediately
   1063  15f2							; following the null.
   1064  15f2							;
   1065  15f2							; Thanks to Ross Archer for this code.
   1066  15f2							; http://www.6502.org/source/io/primm.htm
   1067  15f2							;
   1068  15f2
   1069  15f2		       68	   tbputs     pla		;Get the low part of "return" address
   1070  15f3							;(data start address)
   1071  15f3		       85 65		      sta	PrtFrom
   1072  15f5		       68		      pla
   1073  15f6		       85 66		      sta	PrtFrom+1	;Get the high part of "return" address
   1074  15f8							;(data start address)
   1075  15f8							;Note: actually we're pointing one short
   1076  15f8		       a0 01	   PSINB      ldy	#1
   1077  15fa		       b1 65		      lda	(PrtFrom),y	;Get the next string character
   1078  15fc		       e6 65		      inc	PrtFrom	;update the pointer
   1079  15fe		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
   1080  1600		       e6 66		      inc	PrtFrom+1	;account for page crossing
   1081  1602		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
   1082  1604							;   Accumulator
   1083  1604		       f0 06		      beq	PSIX1	;don't print the final NULL
   1084  1606		       20 ec 15 	      jsr	VOUTCH	;write it out
   1085  1609		       4c f8 15 	      jmp	PSINB	;back around
   1086  160c		       e6 65	   PSIX1      inc	PrtFrom
   1087  160e		       d0 02		      bne	PSIX2
   1088  1610		       e6 66		      inc	PrtFrom+1	;account for page crossing
   1089  1612		       6c 65 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
   1090  1615
   1091  1615							;
   1092  1615
   1093  1615							;====================================================
   1094  1615		       26 06	   PrtTerm    equ	tempy
   1095  1615
   1096  1615							; on exit Print Y has the offset to use
   1097  1615							; input y =	 addr low
   1098  1615							;	 x =	 addr high
   1099  1615							;	 a =	 termination string
   1100  1615
   1101  1615				   PrtPrgLine
   1102  1615		       a9 00		      lda	#0
   1103  1617		       8d 06 26 	      sta	PrtTerm
   1104  161a		       f0 05		      beq	PrtPrgText
   1105  161c
   1106  161c		       a9 22	   PrtQuoted  lda	#'"
   1107  161e		       8d 06 26 	      sta	PrtTerm
   1108  1621
   1109  1621		       a4 51	   PrtPrgText ldy	CUROFF
   1110  1623		       a5 4f		      lda	CURPTR
   1111  1625		       85 65		      sta	PrtFrom
   1112  1627		       a5 50		      lda	CURPTR+1
   1113  1629		       85 66		      sta	PrtFrom+1
   1114  162b		       4c 37 16 	      jmp	PrtLoop
   1115  162e
   1116  162e							; Print a string pointed to by x= h, y=l terminated by a
   1117  162e							; Return y as the length
   1118  162e
   1119  162e		       86 66	   PrtStr     stx	PrtFrom+1
   1120  1630		       84 65		      sty	PrtFrom
   1121  1632		       8d 06 26 	      sta	PrtTerm
   1122  1635		       a0 00		      ldy	#0
   1123  1637							;
   1124  1637							; On entry here ptrfrom and prtterm point to area to print
   1125  1637							;
   1126  1637		       b1 65	   PrtLoop    lda	(PrtFrom),y
   1127  1639		       cd 06 26 	      cmp	PrtTerm
   1128  163c		       f0 0b		      beq	PrtEnd
   1129  163e		       c9 00		      cmp	#0	; always end if 0 is found
   1130  1640		       f0 07		      beq	PrtEnd
   1131  1642		       20 ec 15 	      jsr	VOUTCH
   1132  1645		       c8		      iny
   1133  1646		       4c 37 16 	      jmp	PrtLoop
   1134  1649		       c8	   PrtEnd     iny		;return byte after the copy
   1135  164a		       60		      rts
   1136  164b							;=====================================================
   1137  164b							; Print character in A as two hex digits to the
   1138  164b							; current output device (console or file).
   1139  164b							;
   1140  164b		       48	   HexToOut   pha		;save return value
   1141  164c		       48		      pha
   1142  164d		       4a		      lsr		;a  ;move top nibble to bottom
   1143  164e		       4a		      lsr		;a
   1144  164f		       4a		      lsr		;a
   1145  1650		       4a		      lsr		;a
   1146  1651		       20 5a 16 	      jsr	hexta	;output nibble
   1147  1654		       68		      pla
   1148  1655		       20 5a 16 	      jsr	hexta
   1149  1658		       68		      pla		;restore
   1150  1659		       60		      rts
   1151  165a							;
   1152  165a		       29 0f	   hexta      and	#%0001111
   1153  165c		       c9 0a		      cmp	#$0a
   1154  165e		       18		      clc
   1155  165f		       30 02		      bmi	hexta1
   1156  1661		       69 07		      adc	#7
   1157  1663		       69 30	   hexta1     adc	#'0	;then fall into...
   1158  1665		       4c ec 15 	      jmp	VOUTCH
   1159  1668							;====================================================
   1160  1668							;Clear the terminal assume it is ansii or vt100
   1161  1668							;
   1162  1668				   iCLEARSCREEN
   1163  1668		       20 f2 15 	      jsr	puts
      0  166b					      db	$1b,'[,'3,'J,0
      1  166b		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
   1165  1670		       4c b9 02 	      jmp	NextIL
   1166  1673
   1167  1673							;====================================================
   1168  1673							; Push true and false onto math stack
   1169  1673				   pushTrue
   1170  1673		       a9 ff		      lda	#$ff
   1171  1675		       85 52	   pushTF     sta	R0
   1172  1677		       85 53		      sta	R0+1
   1173  1679		       20 33 13 	      jsr	pushR0
   1174  167c		       60		      rts
   1175  167d		       a9 00	   pushFalse  lda	#0
   1176  167f		       f0 f4		      beq	pushTF
   1177  1681
   1178  1681							;======================================================
   1179  1681							; Copy stack top to R1
   1180  1681				   CopyStackR1
   1181  1681		       98		      tya
   1182  1682		       48		      pha
   1183  1683		       a4 4a		      ldy	MATHSTACKPTR
   1184  1685		       88		      dey
   1185  1686		       b1 48		      lda	(MATHSTACK),y
   1186  1688		       85 55		      sta	R1+1
   1187  168a		       88		      dey
   1188  168b		       b1 48		      lda	(MATHSTACK),y
   1189  168d		       85 54		      sta	R1
   1190  168f		       68		      pla
   1191  1690		       a8		      tay
   1192  1691		       60		      rts
   1193  1692
   1194  1692
   1195  1692							;====================================================
   1196  1692							;Swap the out debug call for standard calls
   1197  1692
   1198  1692				   SetOutDebug
   1199  1692					      if	USEDEBUGPORT
   1200  1692		       a9 b2		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1201  1694		       8d 02 26 	      sta	BOutVec
   1202  1697		       a9 16		      lda	#OUTDEBUG>>8
   1203  1699		       8d 03 26 	      sta	BOutVec+1
   1204  169c					      endif
   1205  169c		       60		      rts
   1206  169d				   SetInDebug
   1207  169d					      if	USEDEBUGPORT
   1208  169d		       a9 b6		      lda	#INDEBUG&$ff
   1209  169f		       8d 04 26 	      sta	BInVec
   1210  16a2		       a9 16		      lda	#INDEBUG>>8
   1211  16a4		       8d 05 26 	      sta	BInVec+1
   1212  16a7					      endif
   1213  16a7		       60		      rts
   1214  16a8							;
   1215  16a8							;====================================================
   1216  16a8							; Output to the debug console
   1217  16a8							;     x = high address byte
   1218  16a8							;     y = low address byte
   1219  16a8							;     a = Terminator for string
   1220  16a8				   DebugWrite
   1221  16a8		       20 92 16 	      jsr	SetOutDebug
   1222  16ab		       20 2e 16 	      jsr	PrtStr
   1223  16ae		       20 d2 15 	      jsr	SetOutConsole
   1224  16b1		       60		      rts
   1225  16b2
   1226  16b2				   OUTDEBUG
   1227  16b2		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1228  16b5		       60		      RTS
   1229  16b6
   1230  16b6		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1231  16b9		       29 01		      and	#$01
   1232  16bb		       f0 f9		      beq	INDEBUG
   1233  16bd		       ad 21 e0 	      lda	DEBUGPORT+1
   1234  16c0		       60		      rts
   1235  16c1							;
   1236  16c1							;=======================================================
   1237  16c1							; Print all Variables
   1238  16c1				   PrintAllVars
   1239  16c1		       a0 00		      ldy	#0
   1240  16c3		       a9 41		      lda	#'A
   1241  16c5				   PrintAllVarsLoop
   1242  16c5		       48		      pha
   1243  16c6		       b1 41		      lda	(VARIABLES),y
   1244  16c8		       85 52		      sta	R0
   1245  16ca		       c8		      iny
   1246  16cb		       b1 41		      lda	(VARIABLES),y
   1247  16cd		       85 53		      sta	R0+1
   1248  16cf
   1249  16cf		       68		      pla		;get the current letter
   1250  16d0		       48		      pha
   1251  16d1		       20 ec 15 	      jsr	VOUTCH
   1252  16d4		       20 f2 15 	      jsr	puts
      0  16d7					      db	"=",0
      1  16d7		       3d 00		      .byte.b	"=",0
   1254  16d9		       68		      pla
   1255  16da		       aa		      tax
   1256  16db		       e8		      inx
   1257  16dc		       8a		      txa
   1258  16dd		       48		      pha		;
   1259  16de
   1260  16de		       98		      tya
   1261  16df		       48		      pha
   1262  16e0		       20 7e 11 	      jsr	PrintDecimal
   1263  16e3		       20 f2 15 	      jsr	puts
      0  16e6					      db	" ",0
      1  16e6		       20 00		      .byte.b	" ",0
   1265  16e8		       68		      pla
   1266  16e9		       a8		      tay
   1267  16ea		       c8		      iny
   1268  16eb		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1269  16ed		       90 d6		      bcc	PrintAllVarsLoop
   1270  16ef		       20 70 14 	      jsr	CRLF
   1271  16f2
   1272  16f2		       68		      pla
   1273  16f3		       60		      rts
   1274  16f4
   1275  16f4
   1276  16f4
   1277  16f4
   1278  16f4
   1279  16f4
   1280  16f4
   1281  16f4
   1282  16f4
   1283  16f4
   1284  16f4
   1285  16f4
   1286  16f4
   1287  16f4
   1288  16f4
   1289  16f4
   1290  16f4
   1291  16f4
   1292  16f4
------- FILE mytb.asm
   2156  16f4
   2157  16f4					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  16f4					      include	"storage.asm"
      1  16f4							;
      2  16f4							;=====================================================
      3  16f4							;=====================================================
      4  16f4							;=====================================================
      5  16f4							; This file contains the functions for saving and
      6  16f4							; restoring programs from some sort of mass storage
      7  16f4							; device.  This particular version is for using the
      8  16f4							; Corsham Tech SD Card System.
      9  16f4							;=====================================================
     10  16f4							;=====================================================
     11  16f4							;=====================================================
     12  16f4
     13 U1ca2					      seg.u	TBData
     14 U1ca2		       00	   diskBufLength ds	1
     15 U1ca3		       00	   diskBufOffset ds	1
     16 U1ca4		       00 00 00 00*DiskFileName ds	14
     17 U1cb2
     18  16f4					      SEG	Code
     19  16f4
     20  16f4							;
     21  16f4							;=====================================================
     22  16f4							; Open a file for reading as a program.  The next
     23  16f4							; thing on the line should be the filename.
     24  16f4							;
     25  16f4				   iOPENREAD
     26  16f4					      if	XKIM || CTMON65
     27  16f4		       a4 51		      ldy	CUROFF
     28  16f6		       b1 4f		      lda	(CURPTR),y
     29  16f8		       d0 07		      bne	iOPENfn	;might be filename
     30  16fa							;
     31  16fa							; No filename supplied.
     32  16fa							;
     33  16fa		       a9 00	   iOPENnofn  lda	#0
     34  16fc		       a2 09		      ldx	#ERR_NO_FILENAME
     35  16fe		       4c 02 06 	      jmp	iErr2
     36  1701							;
     37  1701							; Add the offset into the buffer start
     38  1701							;
     39  1701		       18	   iOPENfn    clc
     40  1702		       98		      tya
     41  1703		       65 4f		      adc	CURPTR
     42  1705		       a8		      tay		;LSB
     43  1706		       a5 50		      lda	CURPTR+1
     44  1708		       69 00		      adc	#0
     45  170a		       aa		      tax
     46  170b		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  170e		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1710							;
     49  1710							; Open failed
     50  1710							;
     51  1710		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1712		       a9 00	   Rdfail2    lda	#0
     53  1714		       4c 02 06 	      jmp	iErr2
     54  1717							;
     55  1717							; Clear counts and offsets so the next read will
     56  1717							; cause the file to be read.
     57  1717							;
     58  1717		       a9 00	   Ropenok    lda	#0
     59  1719		       8d a3 1c 	      sta	diskBufOffset
     60  171c		       8d a2 1c 	      sta	diskBufLength
     61  171f		       4c b9 02 	      jmp	NextIL
     62  1722					      endif
     63  1722
     64  1722							;
     65  1722							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1722							;Remove a file from the disk
     67  1722				   iRMFILE
     68  1722					      if	XKIM || CTMON65
     69  1722		       a4 51		      ldy	CUROFF
     70  1724		       b1 4f		      lda	(CURPTR),y
     71  1726		       f0 19		      beq	iRMnofn
     72  1728							;
     73  1728		       18		      clc
     74  1729		       98		      tya
     75  172a		       65 4f		      adc	CURPTR
     76  172c		       a8		      tay		;LSB
     77  172d		       a5 50		      lda	CURPTR+1
     78  172f		       69 00		      adc	#0
     79  1731		       aa		      tax
     80  1732		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1735		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1737		       a9 00		      lda	#0
     83  1739		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  173b		       4c 02 06 	      jmp	iErr2
     85  173e		       4c b9 02    wrmOk      jmp	NextIL
     86  1741
     87  1741							; No filename supplied.
     88  1741							;
     89  1741		       a9 00	   iRMnofn    lda	#0
     90  1743		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1745		       4c 02 06 	      jmp	iErr2
     92  1748					      endif
     93  1748							;
     94  1748							;=====================================================
     95  1748				   iOPENWRITE
     96  1748					      if	XKIM || CTMON65
     97  1748		       a4 51		      ldy	CUROFF
     98  174a		       b1 4f		      lda	(CURPTR),y
     99  174c		       f0 f3		      beq	iRMnofn
    100  174e							;
    101  174e		       18		      clc
    102  174f		       98		      tya
    103  1750		       65 4f		      adc	CURPTR
    104  1752		       a8		      tay		;LSB
    105  1753		       a5 50		      lda	CURPTR+1
    106  1755		       69 00		      adc	#0
    107  1757		       aa		      tax
    108  1758		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  175b		       90 07		      bcc	Wopenok	;branch if opened ok
    110  175d							;
    111  175d							; Open failed
    112  175d							;
    113  175d		       a9 00	   Wdfail     lda	#0
    114  175f		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1761		       4c 02 06 	      jmp	iErr2
    116  1764							;
    117  1764		       4c b9 02    Wopenok    jmp	NextIL
    118  1767					      endif
    119  1767							;
    120  1767							;=====================================================
    121  1767							; Gets a line of input from the disk file and puts it
    122  1767							; into LINBUF.
    123  1767							;
    124  1767							; On exit:
    125  1767							;    CURPTR points to LINBUF
    126  1767							;    LINBUF contains the line with 0 at the end.
    127  1767							;    Y has offset to first non-space character
    128  1767							;    CURROFF has the same as Y.
    129  1767							;
    130  1767				   iDGETLINE
    131  1767					      if	XKIM || CTMON65
    132  1767		       a2 71		      ldx	#LINBUF&$ff
    133  1769		       86 4f		      stx	CURPTR
    134  176b		       a2 25		      ldx	#LINBUF>>8
    135  176d		       86 50		      stx	CURPTR+1
    136  176f							;
    137  176f		       a2 00		      ldx	#0	;offset
    138  1771		       8e f5 25    iDgetLoop  stx	getlinx
    139  1774		       20 d2 17 	      jsr	getNextFileByte
    140  1777		       b0 16		      bcs	iGetEOF
    141  1779		       c9 0d		      cmp	#CR
    142  177b		       f0 0d		      beq	iGetEOL
    143  177d		       c9 0a		      cmp	#LF
    144  177f		       f0 09		      beq	iGetEOL
    145  1781		       ae f5 25 	      ldx	getlinx
    146  1784		       9d 71 25 	      sta	LINBUF,x
    147  1787		       e8		      inx
    148  1788		       d0 e7		      bne	iDgetLoop
    149  178a							;
    150  178a							; Handle end of line.	If the line has nothing, loop
    151  178a							; back and get another line.
    152  178a							;
    153  178a		       ae f5 25    iGetEOL    ldx	getlinx	;blank line?
    154  178d		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  178f							;
    156  178f							; This can fall through when there is a line, or
    157  178f							; called directly when EOF is encountered.
    158  178f							;
    159  178f		       ae f5 25    iGetEOF    ldx	getlinx
    160  1792		       a9 00		      lda	#0
    161  1794		       9d 71 25 	      sta	LINBUF,x
    162  1797		       85 51		      sta	CUROFF
    163  1799		       a0 00		      ldy	#0
    164  179b		       20 67 14 	      jsr	SkipSpaces
    165  179e		       4c b9 02 	      jmp	NextIL
    166  17a1					      endif
    167  17a1
    168  17a1							;
    169  17a1							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  17a1							; DISK
    171  17a1							;
    172  17a1				   iDDIR
    173  17a1					      if	XKIM || CTMON65
    174  17a1		       20 30 f0 	      jsr	DiskDir
    175  17a4							;
    176  17a4							; Get/Display each entry
    177  17a4							;
    178  17a4		       a2 1c	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  17a6		       a0 a4		      ldy	#DiskFileName&$ff
    180  17a8		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  17ab		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  17ad		       20 f2 15 	      jsr	puts
      0  17b0					      db	"   ",0
      1  17b0		       20 20 20 00	      .byte.b	"   ",0
    184  17b4							; Print the line to the console
    185  17b4		       a2 1c		      ldx	#DiskFileName>>8	;pointer to buffer
    186  17b6		       a0 a4		      ldy	#DiskFileName&$ff
    187  17b8		       a5 00		      lda	0
    188  17ba		       20 2e 16 	      jsr	PrtStr	;else print name
    189  17bd		       20 18 f0 	      jsr	crlf
    190  17c0
    191  17c0		       4c a4 17 	      jmp	DiskDirLoop	;do next entry
    192  17c3
    193  17c3		       4c b9 02    DiskDirEnd jmp	NextIL
    194  17c6					      endif
    195  17c6							;
    196  17c6							;=====================================================
    197  17c6							; Does a LIST to a Disk file.
    198  17c6							;
    199  17c6				   iDLIST
    200  17c6					      if	XKIM || CTMON65
    201  17c6		       20 01 18 	      jsr	SetOutDisk
    202  17c9		       4c d2 07 	      jmp	iLST2
    203  17cc					      endif
    204  17cc							;
    205  17cc							;=====================================================
    206  17cc							; Closes any pending disk file.  Okay to call if there
    207  17cc							; is no open file.
    208  17cc							;
    209  17cc				   iDCLOSE
    210  17cc					      if	XKIM || CTMON65
    211  17cc		       20 42 f0 	      jsr	DiskClose
    212  17cf		       4c b9 02 	      jmp	NextIL
    213  17d2					      endif
    214  17d2							;
    215  17d2							;=====================================================
    216  17d2							; This gets the next byte from an open disk file.  If
    217  17d2							; there are no more bytes left, this returns C set.
    218  17d2							; Else, C is clear and A contains the character.
    219  17d2							;
    220  17d2				   getNextFileByte
    221  17d2					      if	XKIM || CTMON65
    222  17d2		       ae a3 1c 	      ldx	diskBufOffset
    223  17d5		       ec a2 1c 	      cpx	diskBufLength
    224  17d8		       d0 14		      bne	hasdata	;branch if still data
    225  17da							;
    226  17da							; There is no data left in the buffer, so read a
    227  17da							; block from the SD system.
    228  17da							;
    229  17da		       a9 84		      lda	#BUFFER_SIZE
    230  17dc		       a2 df		      ldx	#buffer>>8
    231  17de		       a0 0a		      ldy	#buffer&$ff
    232  17e0		       20 3c f0 	      jsr	DiskRead
    233  17e3		       b0 12		      bcs	getNextEof
    234  17e5							;
    235  17e5							; A contains the number of bytes actually read.
    236  17e5							;
    237  17e5		       8d a2 1c 	      sta	diskBufLength	;save length
    238  17e8		       c9 00		      cmp	#0	;shouldn't happen
    239  17ea		       f0 0b		      beq	getNextEof
    240  17ec							;
    241  17ec		       a2 00		      ldx	#0
    242  17ee		       bd 0a df    hasdata    lda	buffer,x
    243  17f1		       e8		      inx
    244  17f2		       8e a3 1c 	      stx	diskBufOffset
    245  17f5		       18		      clc
    246  17f6		       60		      rts
    247  17f7							;
    248  17f7		       a9 00	   getNextEof lda	#0
    249  17f9		       8d a3 1c 	      sta	diskBufOffset
    250  17fc		       8d a2 1c 	      sta	diskBufLength
    251  17ff		       38		      sec
    252  1800		       60		      rts
    253  1801							;
    254  1801							;=====================================================
    255  1801							; Set output vector to the disk output function
    256  1801							;
    257  1801		       a9 0c	   SetOutDisk lda	#DOUT&$ff
    258  1803		       8d 02 26 	      sta	BOutVec
    259  1806		       a9 18		      lda	#DOUT/256
    260  1808		       8d 03 26 	      sta	BOutVec+1
    261  180b		       60		      rts
    262  180c							;
    263  180c							;=====================================================
    264  180c
    265  180c		       8d 0a df    DOUT       sta	buffer
    266  180f		       a9 01		      lda	#1
    267  1811		       a0 0a		      ldy	#buffer&$ff
    268  1813		       a2 df		      ldx	#buffer>>8
    269  1815		       20 3f f0 	      jsr	DiskWrite
    270  1818							;
    271  1818							; need error checking here
    272  1818							;
    273  1818		       60		      rts
    274  1819					      endif
    275  1819
    276  1819
------- FILE mytb.asm
   2159  1819					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1819					      include	"IL.inc"
      1  1819
      2  1819							;=====================================================
      3  1819							; IL.inc
      4  1819							; These are macros for IL instructions
      5  1819							;
      6  1819					      mac	dw
      7  1819					      .word	{0}
      8  1819					      endm
      9  1819					      mac	db
     10  1819					      .byte	{0}
     11  1819					      endm
     12  1819					      macro	xinit
     13  1819					      db	0
     14  1819					      endm		;reset the il to start clear all
     15  1819							;
     16  1819					      macro	done
     17  1819					      db	1
     18  1819					      endm		;print an error if not end of line
     19  1819							;
     20  1819					      macro	prs
     21  1819					      db	2
     22  1819					      endm		;print a quoted string
     23  1819							;
     24  1819					      macro	prn
     25  1819					      db	3
     26  1819					      endm		;print a number
     27  1819							;
     28  1819					      macro	spc
     29  1819					      db	4
     30  1819					      endm		;print space til new tabstop
     31  1819							;
     32  1819					      macro	nline
     33  1819					      db	5
     34  1819					      endm		;print a new line crlf
     35  1819							;
     36  1819							; My NXT is a bit different in that it takes one
     37  1819							; parameter, which is an address.  If the BASIC
     38  1819							; program is currently running then move to the
     39  1819							; next line and continue execution.  However, if
     40  1819							; in direct mode, jump to the specified IL label.
     41  1819							;
     42  1819					      macro	nxt
     43  1819					      db	6
     44  1819					      dw	{1}	; addr
     45  1819					      endm		; addr
     46  1819							;
     47  1819					      macro	xfer
     48  1819					      db	7
     49  1819					      endm
     50  1819							;
     51  1819					      macro	sav
     52  1819					      db	8
     53  1819					      db	{1}
     54  1819					      endm
     55  1819							;
     56  1819					      macro	rstr
     57  1819					      db	9
     58  1819					      endm
     59  1819							;
     60  1819					      macro	cmpr
     61  1819					      db	10
     62  1819					      endm
     63  1819							;
     64  1819					      macro	innum
     65  1819					      db	11
     66  1819					      endm
     67  1819							;
     68  1819					      macro	fin
     69  1819					      db	12
     70  1819					      endm
     71  1819							;
     72  1819							; ERR is followed by an error number.	The error
     73  1819							; code is printed along with the line number.
     74  1819							; Control is passed to the statement set with
     75  1819							; the ERRGOTO statement.
     76  1819							;
     77  1819					      macro	errmsg
     78  1819					      db	13
     79  1819					      dw	{1}	;ecode
     80  1819					      endm		;ecode
     81  1819							;
     82  1819					      macro	add
     83  1819					      db	14
     84  1819					      endm
     85  1819							;
     86  1819					      macro	sub
     87  1819					      db	15
     88  1819					      endm
     89  1819							;
     90  1819					      macro	neg
     91  1819					      db	16
     92  1819					      endm
     93  1819							;
     94  1819					      macro	mul
     95  1819					      db	17
     96  1819					      endm
     97  1819							;
     98  1819					      macro	div
     99  1819					      db	18
    100  1819					      endm
    101  1819							;
    102  1819					      macro	store
    103  1819					      db	19
    104  1819					      endm
    105  1819							;
    106  1819					      macro	ind
    107  1819					      db	20
    108  1819					      endm
    109  1819							;
    110  1819					      macro	lst
    111  1819					      db	21
    112  1819					      endm
    113  1819							;
    114  1819					      macro	init
    115  1819					      db	22
    116  1819					      endm
    117  1819							;
    118  1819					      macro	getline
    119  1819					      db	23
    120  1819					      endm
    121  1819							;
    122  1819					      macro	insert
    123  1819					      db	24
    124  1819					      endm
    125  1819							;
    126  1819					      macro	rtn
    127  1819					      db	25
    128  1819					      endm
    129  1819							;
    130  1819					      macro	exit
    131  1819					      db	26
    132  1819					      endm
    133  1819							;
    134  1819					      macro	lit
    135  1819					      db	27
    136  1819					      dw	{1}	;value
    137  1819					      endm		; value LIT
    138  1819							;
    139  1819					      macro	call
    140  1819					      db	28
    141  1819					      dw	{1}	;addr
    142  1819					      endm		;addr
    143  1819							;
    144  1819							; IJMP will set the IL PC to the specified value.
    145  1819							;
    146  1819					      macro	ijmp
    147  1819					      db	29
    148  1819					      dw	{1}	;addr
    149  1819					      endm		;addr
    150  1819							;
    151  1819					      macro	vinit
    152  1819					      db	30
    153  1819					      endm
    154  1819							;
    155  1819							; ERRGOTO sets the point in the code where the IL
    156  1819							; interpreter will go after any error.
    157  1819							;
    158  1819					      macro	errgoto
    159  1819					      db	31
    160  1819					      dw	{1}	;addr
    161  1819					      endm		;addr
    162  1819							;
    163  1819					      macro	tst
    164  1819					      db	32
    165  1819					      db	({1}-*)-1	;(addr-*)-1
    166  1819					      db	{2},0	;string,0
    167  1819					      endm		;addr,string
    168  1819							;
    169  1819					      macro	tstv
    170  1819					      db	33
    171  1819					      db	({1}-*)-1	;(addr-*)-1
    172  1819					      endm		;addr
    173  1819							;
    174  1819					      macro	tstl
    175  1819					      db	34
    176  1819					      db	({1}-*)-1	;(addr-*)-1
    177  1819					      endm		;addr
    178  1819							;
    179  1819					      macro	tstn
    180  1819					      db	35
    181  1819					      db	({1}-*)-1	;(addr-*)-1
    182  1819					      endm		;addr
    183  1819							;
    184  1819							; FREE returns the amount of free RAM on top of
    185  1819							; the stack.  This is the amount of room the user
    186  1819							; program has available.
    187  1819							;
    188  1819					      macro	free
    189  1819					      db	36
    190  1819					      endm
    191  1819							;
    192  1819							; RANDOM takes the top item off the stack and
    193  1819							; replaces it with a random number that is
    194  1819							; MOD the initial value.  Ie, if the TOS is
    195  1819							; 42 then RANDOM returns a value from 0 to 41.
    196  1819							;
    197  1819					      macro	random
    198  1819					      db	37
    199  1819					      endm
    200  1819							;
    201  1819							; ABS will replace the top of stack with the
    202  1819							; absolute value.
    203  1819							;
    204  1819					      macro	abs
    205  1819					      db	38
    206  1819					      endm
    207  1819							;
    208  1819							; OPENREAD opens a file for reading, as in getting
    209  1819							; statements from it.
    210  1819							;
    211  1819					      macro	openread
    212  1819					      db	39
    213  1819					      endm
    214  1819							;
    215  1819							; OPENWRITE opens a file for writing, as in saving
    216  1819							; the current program to it.
    217  1819							;
    218  1819					      macro	openwrite
    219  1819					      db	40
    220  1819					      endm
    221  1819							;
    222  1819							; DCLOSE closes any open disk file.
    223  1819							;
    224  1819					      macro	dclose
    225  1819					      db	41
    226  1819					      endm
    227  1819							;
    228  1819							; DGETLINE gets one line from the disk file and puts it
    229  1819							; into LINBUFF.
    230  1819							;
    231  1819					      macro	dgetline
    232  1819					      db	42
    233  1819					      endm
    234  1819							;
    235  1819							; DLIST saves the program to an open disk file.
    236  1819							;
    237  1819					      macro	dlist
    238  1819					      db	43
    239  1819					      endm
    240  1819							; DDIR list the current directory
    241  1819							;
    242  1819					      macro	ddir
    243  1819					      db	44
    244  1819					      endm
    245  1819
    246  1819							; RMFILE remove a fle from disk
    247  1819					      macro	rmfile
    248  1819					      db	45
    249  1819					      endm
    250  1819
    251  1819							; CLEARSCREEN clear the screen
    252  1819					      macro	clearscreen
    253  1819					      db	46
    254  1819					      endm
    255  1819							; POKEMEM Poke value into memory
    256  1819					      macro	pokemem
    257  1819					      db	47
    258  1819					      endm
    259  1819							; PEEKMEM peek at value in memory
    260  1819					      macro	peekmem
    261  1819					      db	48
    262  1819					      endm
    263  1819							; TSTLET Test if the statement is a let without the keyword let
    264  1819					      macro	tstlet
    265  1819					      db	49
    266  1819					      db	({1}-*)-1	;(addr-*)-1
    267  1819					      endm		;addr
    268  1819							; TSTDONE if we reach the end of a statement
    269  1819					      macro	tstdone
    270  1819					      db	50
    271  1819					      db	({1}-*)-1	;(addr-*)-1
    272  1819					      endm		;addr
    273  1819							; GETCHAR	get a character from the input line leave it in RO
    274  1819					      macro	getchar
    275  1819					      db	51
    276  1819					      endm
    277  1819							; PUTCHAR	Put a character to the terminal
    278  1819					      macro	putchar
    279  1819					      db	52
    280  1819					      endm
    281  1819							; Call		Call a machine function return a to stack
    282  1819					      macro	callfunc
    283  1819					      db	53
    284  1819					      endm
    285  1819
    286  1819							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1819					      macro	ibranch
    288  1819					      db	54
    289  1819					      endm
    290  1819
    291  1819							; TSTSTR	 Tests for the open quote in a string
    292  1819					      macro	tststr
    293  1819					      db	55
    294  1819					      db	({1}-*)-1	;(addr-*)-1
    295  1819					      endm
    296  1819							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1819					      macro	setirq
    298  1819					      db	56
    299  1819					      endm
    300  1819
    301  1819							; TSTIRQ	Test for irq pending,
    302  1819							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1819					      macro	tstirq
    304  1819					      db	57
    305  1819					      db	({1}-*)-1	;(addr-*)-1
    306  1819					      endm
    307  1819
    308  1819							; IRET    return from interupt service
    309  1819					      macro	iret
    310  1819					      db	58
    311  1819					      endm
    312  1819
    313  1819							; INSTR   read a string from the input
    314  1819					      macro	instr
    315  1819					      db	59
    316  1819					      endm
    317  1819
    318  1819							; MODULO Returns the remainder of the division
    319  1819					      macro	modulo
    320  1819					      db	60
    321  1819					      endm
    322  1819							; Set a task line
    323  1819					      macro	taskcreate
    324  1819					      db	61
    325  1819					      endm
    326  1819							; End a task
    327  1819					      macro	etask
    328  1819					      db	62
    329  1819					      endm
    330  1819							; Skip to next task
    331  1819					      macro	ntask
    332  1819					      db	63
    333  1819					      endm
    334  1819							; Subscript
    335  1819					      macro	subscript
    336  1819					      db	64
    337  1819					      endm
    338  1819							; KILL Task
    339  1819					      macro	taskkill
    340  1819					      db	65
    341  1819					      endm
    342  1819							; STAT Task
    343  1819					      macro	taskstat
    344  1819					      db	66
    345  1819					      endm
    346  1819							;  output value as hex
    347  1819					      macro	hexprt
    348  1819					      db	67
    349  1819					      endm
    350  1819							;  Read in background has completed
    351  1819					      macro	readcomplete
    352  1819					      db	68
    353  1819					      endm
    354  1819							;  ReadInput line
    355  1819					      macro	readstart
    356  1819					      db	69
    357  1819					      endm
    358  1819							; Startio request
    359  1819					      macro	startio
    360  1819					      db	70
    361  1819					      endm
    362  1819							; Endio
    363  1819					      macro	endio
    364  1819					      db	71
    365  1819					      endm
    366  1819							; Logical not
    367  1819					      macro	lognot
    368  1819					      db	72
    369  1819					      endm
    370  1819							; Logical OR
    371  1819					      macro	logor
    372  1819					      db	73
    373  1819					      endm
    374  1819							;Logical and
    375  1819					      macro	logand
    376  1819					      db	74
    377  1819					      endm
    378  1819							;Logical XOR
    379  1819					      macro	logxor
    380  1819					      db	75
    381  1819					      endm
    382  1819							;Wait for task to complete, or list of tasks
    383  1819					      macro	wtask
    384  1819					      db	76
    385  1819					      db	({1}-*)-1	;(addr-*)-1
    386  1819					      endm
    387  1819							;Get the current task id
    388  1819					      MACRO	taskpid
    389  1819					      db	77
    390  1819					      endm
    391  1819							;Trace the basic execution
    392  1819					      Macro	traceprogram
    393  1819					      db	78
    394  1819					      endm
    395  1819							;Do a basic program Trace
    396  1819					      Macro	debugbasic
    397  1819					      db	79
    398  1819					      endm
    399  1819
    400  1819							; Inter Process communications instructions
    401  1819					      Macro	ipcsend
    402  1819					      db	80
    403  1819					      endm
    404  1819					      Macro	ipcreceive
    405  1819					      db	81
    406  1819					      endm
    407  1819					      Macro	ipccheck
    408  1819					      db	82
    409  1819					      endm
    410  1819					      Macro	ipcio
    411  1819					      db	83
    412  1819					      endm
    413  1819					      Macro	pushmathstack
    414  1819					      db	84
    415  1819					      endm
    416  1819					      Macro	popmathstack
    417  1819					      db	85
    418  1819					      endm
    419  1819					      Macro	savemathstack
    420  1819					      db	86
    421  1819					      endm
    422  1819					      Macro	restoremathstack
    423  1819					      db	87
    424  1819					      endm
    425  1819					      Macro	incparmcount
    426  1819					      db	88
    427  1819					      endm
    428  1819					      Macro	taskgetmathstack
    429  1819					      db	89
    430  1819					      endm
    431  1819					      Macro	taskenable
    432  1819					      db	90
    433  1819					      endm
    434  1819					      Macro	tasksuspend
    435  1819					      db	91
    436  1819					      endm
    437  1819					      Macro	taskputmathptr
    438  1819					      db	92
    439  1819					      endm
    440  1819							; Test for an extension type of variable that allows access to a tasks variables
    441  1819							; Using  PID!<Var name>
    442  1819					      Macro	tstvt
    443  1819					      db	93
    444  1819					      db	({1}-*)-1	;(addr-*)-1
    445  1819					      endm
    446  1819
    447  1819							; Provide access to R2 for the IL program
    448  1819					      Macro	setr2
    449  1819					      db	94
    450  1819					      db	{1}	; R2 is only one byte
    451  1819					      endm
    452  1819							;Move stack top to temp
    453  1819					      Macro	stk2tmp
    454  1819					      db	95
    455  1819					      endm
    456  1819
    457  1819					      Macro	tmp2stk
    458  1819					      db	96
    459  1819					      endm
    460  1819
    461  1819					      Macro	tstbyte
    462  1819					      db	97
    463  1819					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1819					      dw	{2}	; address to check
    465  1819					      db	{3}	; Value to compare
    466  1819					      endm
    467  1819
    468  1819
------- FILE mytb.asm
   2161  1819							;
   2162  1819				  -	      if	FIXED
   2163  1819				  -	      org	$1000
   2164  1819					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1819					      include	"basic.il"
      1  1819							;LET
      2  1819							;=====================================================
      3  1819							;=====================================================
      4  1819					      seg	Code
      5  1819							;=====================================================
      6  1819							; This is the IL of the BASIC (or whatever) language.
      7  1819							; Because of the way macros are implemented by as65,
      8  1819							; labels can't be on the same line as a macro
      9  1819							; invocation, so that's why labels are on separate
     10  1819							; lines.
     11  1819							;
     12  1819		       18 19	   IL	      equ	*
     13  1819
     14  1819							;THE IL CONTROL SECTION
     15  1819
     16  1819				   START
      0  1819					      INIT		;INITIALIZE
      0  1819					      db	22
      1  1819		       16		      .byte.b	22
      0  181a					      NLINE		;WRITE CRLF
      0  181a					      db	5
      1  181a		       05		      .byte.b	5
      0  181b					      ERRGOTO	CO	;where to go after an error
      0  181b					      db	31
      1  181b		       1f		      .byte.b	31
      0  181c					      dw	CO
      1  181c		       1f 18		      .word.w	CO
      0  181e					      VINIT		;clear all variables
      0  181e					      db	30
      1  181e		       1e		      .byte.b	30
     21  181f							;
     22  181f							; This is where we jump to get a line of commands or
     23  181f							; a program from the user.
     24  181f							;
     25  181f				   CO
      0  181f					      GETLINE		;WRITE PROMPT AND GET LINE
      0  181f					      db	23
      1  181f		       17		      .byte.b	23
      0  1820					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1820					      db	34
      1  1820		       22		      .byte.b	34
      0  1821					      db	(XEC-*)-1
      1  1821		       04		      .byte.b	(XEC-*)-1
      0  1822					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1822					      db	24
      1  1822		       18		      .byte.b	24
      0  1823					      IJMP	CO
      0  1823					      db	29
      1  1823		       1d		      .byte.b	29
      0  1824					      dw	CO
      1  1824		       1f 18		      .word.w	CO
     30  1826				   XEC
      0  1826					      XINIT		;INITIALIZE
      0  1826					      db	0
      1  1826		       00		      .byte.b	0
     32  1827
     33  1827							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1827				   STMT
      0  1827					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1827					      db	79
      1  1827		       4f		      .byte.b	79
      0  1828					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1828					      db	57
      1  1828		       39		      .byte.b	57
      0  1829					      db	(notirq-*)-1
      1  1829		       00		      .byte.b	(notirq-*)-1
     37  182a				   notirq
      0  182a					      TSTLET	LET	;Test if second field is =
      0  182a					      db	49
      1  182a		       31		      .byte.b	49
      0  182b					      db	(LET-*)-1
      1  182b		       03		      .byte.b	(LET-*)-1
      0  182c					      IJMP	DOLET	;allow the default to be let
      0  182c					      db	29
      1  182c		       1d		      .byte.b	29
      0  182d					      dw	DOLET
      1  182d		       35 18		      .word.w	DOLET
     40  182f				   LET
      0  182f					      TST	S1,"LET"	;IS STATEMENT A LET
      0  182f					      db	32
      1  182f		       20		      .byte.b	32
      0  1830					      db	(S1-*)-1
      1  1830		       21		      .byte.b	(S1-*)-1
      0  1831					      db	"LET",0
      1  1831		       4c 45 54 00	      .byte.b	"LET",0
     42  1835				   DOLET
      0  1835					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1835					      db	33
      1  1835		       21		      .byte.b	33
      0  1836					      db	(ERRVEC-*)-1
      1  1836		       ca		      .byte.b	(ERRVEC-*)-1
      0  1837					      TST	LETBE,"["
      0  1837					      db	32
      1  1837		       20		      .byte.b	32
      0  1838					      db	(LETBE-*)-1
      1  1838		       0a		      .byte.b	(LETBE-*)-1
      0  1839					      db	"[",0
      1  1839		       5b 00		      .byte.b	"[",0
      0  183b					      CALL	EXPR
      0  183b					      db	28
      1  183b		       1c		      .byte.b	28
      0  183c					      dw	EXPR
      1  183c		       82 1a		      .word.w	EXPR
      0  183e					      TST	ERRVEC,"]"
      0  183e					      db	32
      1  183e		       20		      .byte.b	32
      0  183f					      db	(ERRVEC-*)-1
      1  183f		       c1		      .byte.b	(ERRVEC-*)-1
      0  1840					      db	"]",0
      1  1840		       5d 00		      .byte.b	"]",0
      0  1842					      SUBSCRIPT
      0  1842					      db	64
      1  1842		       40		      .byte.b	64
     48  1843				   LETBE
      0  1843					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1843					      db	32
      1  1843		       20		      .byte.b	32
      0  1844					      db	(ERRVEC-*)-1
      1  1844		       bc		      .byte.b	(ERRVEC-*)-1
      0  1845					      db	"=",0
      1  1845		       3d 00		      .byte.b	"=",0
      0  1847					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  1847					      db	28
      1  1847		       1c		      .byte.b	28
      0  1848					      dw	EXPR
      1  1848		       82 1a		      .word.w	EXPR
      0  184a					      DONE		;REPORT ERROR IF NOT NEXT
      0  184a					      db	1
      1  184a		       01		      .byte.b	1
      0  184b					      STORE		;STORE RESULT
      0  184b					      db	19
      1  184b		       13		      .byte.b	19
      0  184c					      NXT	CO	;AND SEQUENCE TO NEXT
      0  184c					      db	6
      1  184c		       06		      .byte.b	6
      0  184d					      dw	CO
      1  184d		       1f 18		      .word.w	CO
      0  184f					      IJMP	STMT
      0  184f					      db	29
      1  184f		       1d		      .byte.b	29
      0  1850					      dw	STMT
      1  1850		       27 18		      .word.w	STMT
     55  1852				   S1
      0  1852					      TST	S1S1,"IRET"	;test return from interupt
      0  1852					      db	32
      1  1852		       20		      .byte.b	32
      0  1853					      db	(S1S1-*)-1
      1  1853		       10		      .byte.b	(S1S1-*)-1
      0  1854					      db	"IRET",0
      1  1854		       49 52 45 54*	      .byte.b	"IRET",0
      0  1859					      TST	S1Sa,"URN"
      0  1859					      db	32
      1  1859		       20		      .byte.b	32
      0  185a					      db	(S1Sa-*)-1
      1  185a		       04		      .byte.b	(S1Sa-*)-1
      0  185b					      db	"URN",0
      1  185b		       55 52 4e 00	      .byte.b	"URN",0
     58  185f				   S1Sa
      0  185f					      DONE		;Must be only thing on the line
      0  185f					      db	1
      1  185f		       01		      .byte.b	1
      0  1860					      IRET		;RESTORE LINE NUMBER OF CALL
      0  1860					      db	58
      1  1860		       3a		      .byte.b	58
      0  1861					      IJMP	STMT
      0  1861					      db	29
      1  1861		       1d		      .byte.b	29
      0  1862					      dw	STMT
      1  1862		       27 18		      .word.w	STMT
     62  1864
     63  1864				   S1S1
      0  1864					      TST	S1Z,"IF"	;IF STATEMENT
      0  1864					      db	32
      1  1864		       20		      .byte.b	32
      0  1865					      db	(S1Z-*)-1
      1  1865		       11		      .byte.b	(S1Z-*)-1
      0  1866					      db	"IF",0
      1  1866		       49 46 00 	      .byte.b	"IF",0
      0  1869					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1869					      db	28
      1  1869		       1c		      .byte.b	28
      0  186a					      dw	EXPR
      1  186a		       82 1a		      .word.w	EXPR
      0  186c					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  186c					      db	32
      1  186c		       20		      .byte.b	32
      0  186d					      db	(S1W-*)-1
      1  186d		       05		      .byte.b	(S1W-*)-1
      0  186e					      db	"THEN",0
      1  186e		       54 48 45 4e*	      .byte.b	"THEN",0
     67  1873				   S1W
      0  1873					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1873					      db	54
      1  1873		       36		      .byte.b	54
      0  1874					      IJMP	STMT
      0  1874					      db	29
      1  1874		       1d		      .byte.b	29
      0  1875					      dw	STMT
      1  1875		       27 18		      .word.w	STMT
     70  1877
     71  1877				   S1Z
      0  1877					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1877					      db	32
      1  1877		       20		      .byte.b	32
      0  1878					      db	(S2b-*)-1
      1  1878		       19		      .byte.b	(S2b-*)-1
      0  1879					      db	"GO",0
      1  1879		       47 4f 00 	      .byte.b	"GO",0
      0  187c					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  187c					      db	32
      1  187c		       20		      .byte.b	32
      0  187d					      db	(S2-*)-1
      1  187d		       07		      .byte.b	(S2-*)-1
      0  187e					      db	"TO",0
      1  187e		       54 4f 00 	      .byte.b	"TO",0
      0  1881					      CALL	EXPR	;GET LABEL
      0  1881					      db	28
      1  1881		       1c		      .byte.b	28
      0  1882					      dw	EXPR
      1  1882		       82 1a		      .word.w	EXPR
      0  1884					      XFER		;SET UP AND JUMP
      0  1884					      db	7
      1  1884		       07		      .byte.b	7
     76  1885				   S2
     77  1885							;===========================================================================
     78  1885							; Process gosub / function
     79  1885							;
      0  1885					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1885					      db	32
      1  1885		       20		      .byte.b	32
      0  1886					      db	(ERRVEC-*)-1
      1  1886		       7a		      .byte.b	(ERRVEC-*)-1
      0  1887					      db	"SUB",0
      1  1887		       53 55 42 00	      .byte.b	"SUB",0
      0  188b					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  188b					      db	28
      1  188b		       1c		      .byte.b	28
      0  188c					      dw	GOSUBSTATEMENT
      1  188c		       88 1c		      .word.w	GOSUBSTATEMENT
      0  188e					      DONE		;ERROR IF CR NOT NEXT
      0  188e					      db	1
      1  188e		       01		      .byte.b	1
      0  188f					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  188f					      db	8
      1  188f		       08		      .byte.b	8
      0  1890					      db	GOSUB_RTN
      1  1890		       01		      .byte.b	GOSUB_RTN
      0  1891					      XFER		;AND JUMP
      0  1891					      db	7
      1  1891		       07		      .byte.b	7
     85  1892							;
     86  1892							; End of gosub processing
     87  1892							;==========================================================================
     88  1892							; Return from a gosub
     89  1892				   S2b
      0  1892					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1892					      db	32
      1  1892		       20		      .byte.b	32
      0  1893					      db	(S3-*)-1
      1  1893		       36		      .byte.b	(S3-*)-1
      0  1894					      db	"RE",0
      1  1894		       52 45 00 	      .byte.b	"RE",0
      0  1897					      TST	S2a,"T"
      0  1897					      db	32
      1  1897		       20		      .byte.b	32
      0  1898					      db	(S2a-*)-1
      1  1898		       27		      .byte.b	(S2a-*)-1
      0  1899					      db	"T",0
      1  1899		       54 00		      .byte.b	"T",0
      0  189b					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  189b					      db	32
      1  189b		       20		      .byte.b	32
      0  189c					      db	(S2aa-*)-1
      1  189c		       04		      .byte.b	(S2aa-*)-1
      0  189d					      db	"URN",0
      1  189d		       55 52 4e 00	      .byte.b	"URN",0
     93  18a1				   S2aa
      0  18a1					      SETR2	0	; Default no return value
      0  18a1					      db	94
      1  18a1		       5e		      .byte.b	94
      0  18a2					      db	0
      1  18a2		       00		      .byte.b	0
      0  18a3					      TST	S2RetDone,"("	; Check if we will return some value
      0  18a3					      db	32
      1  18a3		       20		      .byte.b	32
      0  18a4					      db	(S2RetDone-*)-1
      1  18a4		       0b		      .byte.b	(S2RetDone-*)-1
      0  18a5					      db	"(",0
      1  18a5		       28 00		      .byte.b	"(",0
      0  18a7					      SETR2	1	; Indicate a return value provided
      0  18a7					      db	94
      1  18a7		       5e		      .byte.b	94
      0  18a8					      db	1
      1  18a8		       01		      .byte.b	1
      0  18a9					      CALL	EXPR
      0  18a9					      db	28
      1  18a9		       1c		      .byte.b	28
      0  18aa					      dw	EXPR
      1  18aa		       82 1a		      .word.w	EXPR
      0  18ac					      TST	ERRVEC,")"	; Now a value is on the stack
      0  18ac					      db	32
      1  18ac		       20		      .byte.b	32
      0  18ad					      db	(ERRVEC-*)-1
      1  18ad		       53		      .byte.b	(ERRVEC-*)-1
      0  18ae					      db	")",0
      1  18ae		       29 00		      .byte.b	")",0
     99  18b0
    100  18b0				   S2RetDone
      0  18b0					      DONE		; MUST BE CR or :
      0  18b0					      db	1
      1  18b0		       01		      .byte.b	1
      0  18b1					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  18b1					      db	9
      1  18b1		       09		      .byte.b	9
      0  18b2					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  18b2					      db	97
      1  18b2		       61		      .byte.b	97
      0  18b3					      db	(S2RetFunc-*)-1
      1  18b3		       09		      .byte.b	(S2RetFunc-*)-1
      0  18b4					      dw	R2
      1  18b4		       58 00		      .word.w	R2
      0  18b6					      db	1
      1  18b6		       01		      .byte.b	1
      0  18b7					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  18b7					      db	6
      1  18b7		       06		      .byte.b	6
      0  18b8					      dw	CO
      1  18b8		       1f 18		      .word.w	CO
      0  18ba					      IJMP	STMT
      0  18ba					      db	29
      1  18ba		       1d		      .byte.b	29
      0  18bb					      dw	STMT
      1  18bb		       27 18		      .word.w	STMT
    106  18bd				   S2RetFunc
      0  18bd					      IJMP	GOFNRet	; Back into the Function
      0  18bd					      db	29
      1  18bd		       1d		      .byte.b	29
      0  18be					      dw	GOFNRet
      1  18be		       5e 1c		      .word.w	GOFNRet
    108  18c0							;
    109  18c0							; End of return from gosub
    110  18c0							;============================================================================
    111  18c0							; Process REM statement
    112  18c0				   S2a
      0  18c0					      TST	S3,"M"	;REMark.  Skip rest of line
      0  18c0					      db	32
      1  18c0		       20		      .byte.b	32
      0  18c1					      db	(S3-*)-1
      1  18c1		       08		      .byte.b	(S3-*)-1
      0  18c2					      db	"M",0
      1  18c2		       4d 00		      .byte.b	"M",0
      0  18c4					      NXT	CO
      0  18c4					      db	6
      1  18c4		       06		      .byte.b	6
      0  18c5					      dw	CO
      1  18c5		       1f 18		      .word.w	CO
      0  18c7					      IJMP	STMT
      0  18c7					      db	29
      1  18c7		       1d		      .byte.b	29
      0  18c8					      dw	STMT
      1  18c8		       27 18		      .word.w	STMT
    116  18ca
    117  18ca				   S3
      0  18ca					      TST	S3a,"?"	; ? symonym for print
      0  18ca					      db	32
      1  18ca		       20		      .byte.b	32
      0  18cb					      db	(S3a-*)-1
      1  18cb		       05		      .byte.b	(S3a-*)-1
      0  18cc					      db	"?",0
      1  18cc		       3f 00		      .byte.b	"?",0
      0  18ce					      IJMP	S4S
      0  18ce					      db	29
      1  18ce		       1d		      .byte.b	29
      0  18cf					      dw	S4S
      1  18cf		       dc 18		      .word.w	S4S
    120  18d1				   S3a
      0  18d1					      TST	S8,"PR"	;allow short form of print
      0  18d1					      db	32
      1  18d1		       20		      .byte.b	32
      0  18d2					      db	(S8-*)-1
      1  18d2		       4c		      .byte.b	(S8-*)-1
      0  18d3					      db	"PR",0
      1  18d3		       50 52 00 	      .byte.b	"PR",0
      0  18d6					      TST	S4S,"INT"	;PRINT
      0  18d6					      db	32
      1  18d6		       20		      .byte.b	32
      0  18d7					      db	(S4S-*)-1
      1  18d7		       04		      .byte.b	(S4S-*)-1
      0  18d8					      db	"INT",0
      1  18d8		       49 4e 54 00	      .byte.b	"INT",0
    123  18dc				   S4S
      0  18dc					      STARTIO		;Lock task until io completes
      0  18dc					      db	70
      1  18dc		       46		      .byte.b	70
    125  18dd				   S4
      0  18dd					      TSTDONE	S4a	;Test if we just want crlf printed
      0  18dd					      db	50
      1  18dd		       32		      .byte.b	50
      0  18de					      db	(S4a-*)-1
      1  18de		       03		      .byte.b	(S4a-*)-1
      0  18df					      IJMP	S6
      0  18df					      db	29
      1  18df		       1d		      .byte.b	29
      0  18e0					      dw	S6
      1  18e0		       f8 18		      .word.w	S6
    128  18e2
    129  18e2				   S4a
      0  18e2					      TSTSTR	S7	;TEST FOR QUOTED String
      0  18e2					      db	55
      1  18e2		       37		      .byte.b	55
      0  18e3					      db	(S7-*)-1
      1  18e3		       21		      .byte.b	(S7-*)-1
      0  18e4					      PRS		;PRINT STRING
      0  18e4					      db	2
      1  18e4		       02		      .byte.b	2
    132  18e5				   S5
      0  18e5					      TST	S6A,COMMA	;IS THERE MORE?
      0  18e5					      db	32
      1  18e5		       20		      .byte.b	32
      0  18e6					      db	(S6A-*)-1
      1  18e6		       08		      .byte.b	(S6A-*)-1
      0  18e7					      db	COMMA,0
      1  18e7		       2c 00		      .byte.b	COMMA,0
      0  18e9					      SPC		;SPACE TO NEXT ZONE
      0  18e9					      db	4
      1  18e9		       04		      .byte.b	4
      0  18ea					      TSTDONE	S4	;Not end of line jump back
      0  18ea					      db	50
      1  18ea		       32		      .byte.b	50
      0  18eb					      db	(S4-*)-1
      1  18eb		       f1		      .byte.b	(S4-*)-1
      0  18ec					      IJMP	S6Z	;YES JUMP BACK
      0  18ec					      db	29
      1  18ec		       1d		      .byte.b	29
      0  18ed					      dw	S6Z
      1  18ed		       fa 18		      .word.w	S6Z
    137  18ef
    138  18ef							;
    139  18ef							; If a semicolon, don't do anything.
    140  18ef							;
    141  18ef				   S6A
      0  18ef					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  18ef					      db	32
      1  18ef		       20		      .byte.b	32
      0  18f0					      db	(S6-*)-1
      1  18f0		       07		      .byte.b	(S6-*)-1
      0  18f1					      db	SEMICOLON,0
      1  18f1		       3b 00		      .byte.b	SEMICOLON,0
      0  18f3					      TSTDONE	S4	;Jump Back if not end of line
      0  18f3					      db	50
      1  18f3		       32		      .byte.b	50
      0  18f4					      db	(S4-*)-1
      1  18f4		       e8		      .byte.b	(S4-*)-1
      0  18f5					      IJMP	S6Z
      0  18f5					      db	29
      1  18f5		       1d		      .byte.b	29
      0  18f6					      dw	S6Z
      1  18f6		       fa 18		      .word.w	S6Z
    145  18f8				   S6
      0  18f8					      DONE		;ERROR IF CR NOT NEXT
      0  18f8					      db	1
      1  18f8		       01		      .byte.b	1
      0  18f9					      NLINE
      0  18f9					      db	5
      1  18f9		       05		      .byte.b	5
    148  18fa				   S6Z
      0  18fa					      ENDIO		;release task io completed
      0  18fa					      db	71
      1  18fa		       47		      .byte.b	71
      0  18fb					      NXT	CO	;exit here if , or ; at end of print
      0  18fb					      db	6
      1  18fb		       06		      .byte.b	6
      0  18fc					      dw	CO
      1  18fc		       1f 18		      .word.w	CO
      0  18fe					      IJMP	STMT
      0  18fe					      db	29
      1  18fe		       1d		      .byte.b	29
      0  18ff					      dw	STMT
      1  18ff		       27 18		      .word.w	STMT
    152  1901							;
    153  1901							; A jump for code too far away for relative branch
    154  1901							;
    155  1901				   ERRVEC
      0  1901					      ENDIO
      0  1901					      db	71
      1  1901		       47		      .byte.b	71
      0  1902					      IJMP	UNKNOWN
      0  1902					      db	29
      1  1902		       1d		      .byte.b	29
      0  1903					      dw	UNKNOWN
      1  1903		       7e 1a		      .word.w	UNKNOWN
    158  1905							;
    159  1905							; Get here if there is an expression to print
    160  1905				   S7
      0  1905					      TST	S7A,"$"
      0  1905					      db	32
      1  1905		       20		      .byte.b	32
      0  1906					      db	(S7A-*)-1
      1  1906		       09		      .byte.b	(S7A-*)-1
      0  1907					      db	"$",0
      1  1907		       24 00		      .byte.b	"$",0
      0  1909					      CALL	EXPR
      0  1909					      db	28
      1  1909		       1c		      .byte.b	28
      0  190a					      dw	EXPR
      1  190a		       82 1a		      .word.w	EXPR
      0  190c					      HEXPRT
      0  190c					      db	67
      1  190c		       43		      .byte.b	67
      0  190d					      IJMP	S5
      0  190d					      db	29
      1  190d		       1d		      .byte.b	29
      0  190e					      dw	S5
      1  190e		       e5 18		      .word.w	S5
    165  1910				   S7A
      0  1910					      CALL	EXPR
      0  1910					      db	28
      1  1910		       1c		      .byte.b	28
      0  1911					      dw	EXPR
      1  1911		       82 1a		      .word.w	EXPR
      0  1913					      TST	S7B,"$"
      0  1913					      db	32
      1  1913		       20		      .byte.b	32
      0  1914					      db	(S7B-*)-1
      1  1914		       06		      .byte.b	(S7B-*)-1
      0  1915					      db	"$",0
      1  1915		       24 00		      .byte.b	"$",0
      0  1917					      PUTCHAR
      0  1917					      db	52
      1  1917		       34		      .byte.b	52
      0  1918					      IJMP	S5
      0  1918					      db	29
      1  1918		       1d		      .byte.b	29
      0  1919					      dw	S5
      1  1919		       e5 18		      .word.w	S5
    170  191b				   S7B
      0  191b					      PRN		;PRINT IT
      0  191b					      db	3
      1  191b		       03		      .byte.b	3
      0  191c					      IJMP	S5	;IS THERE MORE?
      0  191c					      db	29
      1  191c		       1d		      .byte.b	29
      0  191d					      dw	S5
      1  191d		       e5 18		      .word.w	S5
    173  191f							;
    174  191f							;===========================================================
    175  191f							; End of TASK process
    176  191f				   S8
      0  191f					      TST	S8a1,"TASK"	; Any Task COmmand
      0  191f					      db	32
      1  191f		       20		      .byte.b	32
      0  1920					      db	(S8a1-*)-1
      1  1920		       4b		      .byte.b	(S8a1-*)-1
      0  1921					      db	"TASK",0
      1  1921		       54 41 53 4b*	      .byte.b	"TASK",0
      0  1926					      TST	S8G,"E"
      0  1926					      db	32
      1  1926		       20		      .byte.b	32
      0  1927					      db	(S8G-*)-1
      1  1927		       1a		      .byte.b	(S8G-*)-1
      0  1928					      db	"E",0
      1  1928		       45 00		      .byte.b	"E",0
      0  192a					      TST	S8NoParm,"("
      0  192a					      db	32
      1  192a		       20		      .byte.b	32
      0  192b					      db	(S8NoParm-*)-1
      1  192b		       0e		      .byte.b	(S8NoParm-*)-1
      0  192c					      db	"(",0
      1  192c		       28 00		      .byte.b	"(",0
      0  192e					      CALL	EXPR
      0  192e					      db	28
      1  192e		       1c		      .byte.b	28
      0  192f					      dw	EXPR
      1  192f		       82 1a		      .word.w	EXPR
      0  1931					      TST	UNKNOWNLnk,")"
      0  1931					      db	32
      1  1931		       20		      .byte.b	32
      0  1932					      db	(UNKNOWNLnk-*)-1
      1  1932		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1933					      db	")",0
      1  1933		       29 00		      .byte.b	")",0
      0  1935					      ETASK
      0  1935					      db	62
      1  1935		       3e		      .byte.b	62
      0  1936					      DONE
      0  1936					      db	1
      1  1936		       01		      .byte.b	1
      0  1937					      IJMP	STMT
      0  1937					      db	29
      1  1937		       1d		      .byte.b	29
      0  1938					      dw	STMT
      1  1938		       27 18		      .word.w	STMT
    185  193a				   S8NoParm
      0  193a					      LIT	0
      0  193a					      db	27
      1  193a		       1b		      .byte.b	27
      0  193b					      dw	0
      1  193b		       00 00		      .word.w	0
      0  193d					      ETASK
      0  193d					      db	62
      1  193d		       3e		      .byte.b	62
      0  193e					      DONE		; Must be last thing on a line
      0  193e					      db	1
      1  193e		       01		      .byte.b	1
      0  193f					      IJMP	STMT
      0  193f					      db	29
      1  193f		       1d		      .byte.b	29
      0  1940					      dw	STMT
      1  1940		       27 18		      .word.w	STMT
    190  1942							;
    191  1942							;===========================================================
    192  1942							; The task gives up the rest of the cycles
    193  1942				   S8G
      0  1942					      TST	S8a,"N"	;Next task
      0  1942					      db	32
      1  1942		       20		      .byte.b	32
      0  1943					      db	(S8a-*)-1
      1  1943		       09		      .byte.b	(S8a-*)-1
      0  1944					      db	"N",0
      1  1944		       4e 00		      .byte.b	"N",0
      0  1946					      NTASK
      0  1946					      db	63
      1  1946		       3f		      .byte.b	63
      0  1947					      NXT	CO	;Next statement to execute
      0  1947					      db	6
      1  1947		       06		      .byte.b	6
      0  1948					      dw	CO
      1  1948		       1f 18		      .word.w	CO
      0  194a					      IJMP	STMT
      0  194a					      db	29
      1  194a		       1d		      .byte.b	29
      0  194b					      dw	STMT
      1  194b		       27 18		      .word.w	STMT
    198  194d							;
    199  194d							;===========================================================
    200  194d							; Waits for a task or list of tasks to complete
    201  194d				   S8a
      0  194d					      TST	S8TASKNO,"W("	;Wait for tasks
      0  194d					      db	32
      1  194d		       20		      .byte.b	32
      0  194e					      db	(S8TASKNO-*)-1
      1  194e		       1a		      .byte.b	(S8TASKNO-*)-1
      0  194f					      db	"W(",0
      1  194f		       57 28 00 	      .byte.b	"W(",0
    203  1952				   S8TSK
      0  1952					      Call	EXPR	;Gets the PID of task to wait for
      0  1952					      db	28
      1  1952		       1c		      .byte.b	28
      0  1953					      dw	EXPR
      1  1953		       82 1a		      .word.w	EXPR
    205  1955				   S8LOOP
      0  1955					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1955					      db	76
      1  1955		       4c		      .byte.b	76
      0  1956					      db	(S8LOOP-*)-1
      1  1956		       fe		      .byte.b	(S8LOOP-*)-1
      0  1957					      TST	S8aa,COMMA	;Checks for more tasks
      0  1957					      db	32
      1  1957		       20		      .byte.b	32
      0  1958					      db	(S8aa-*)-1
      1  1958		       05		      .byte.b	(S8aa-*)-1
      0  1959					      db	COMMA,0
      1  1959		       2c 00		      .byte.b	COMMA,0
      0  195b					      IJMP	S8TSK	;Go for the next task number
      0  195b					      db	29
      1  195b		       1d		      .byte.b	29
      0  195c					      dw	S8TSK
      1  195c		       52 19		      .word.w	S8TSK
    209  195e				   S8aa
      0  195e					      TST	S8TASKNO,")"	;end of list
      0  195e					      db	32
      1  195e		       20		      .byte.b	32
      0  195f					      db	(S8TASKNO-*)-1
      1  195f		       09		      .byte.b	(S8TASKNO-*)-1
      0  1960					      db	")",0
      1  1960		       29 00		      .byte.b	")",0
      0  1962					      DONE
      0  1962					      db	1
      1  1962		       01		      .byte.b	1
      0  1963					      NXT	CO
      0  1963					      db	6
      1  1963		       06		      .byte.b	6
      0  1964					      dw	CO
      1  1964		       1f 18		      .word.w	CO
      0  1966					      IJMP	STMT	;Next Statement
      0  1966					      db	29
      1  1966		       1d		      .byte.b	29
      0  1967					      dw	STMT
      1  1967		       27 18		      .word.w	STMT
    214  1969				   S8TASKNO
    215  1969
    216  1969				   UNKNOWNLnk
      0  1969					      iJMP	UNKNOWN
      0  1969					      db	29
      1  1969		       1d		      .byte.b	29
      0  196a					      dw	UNKNOWN
      1  196a		       7e 1a		      .word.w	UNKNOWN
    218  196c
    219  196c							;
    220  196c							;===========================================================
    221  196c							; Update a memory location with a value
    222  196c				   S8a1
      0  196c					      TST	S8b,"POKE("	; Poke a value into memory
      0  196c					      db	32
      1  196c		       20		      .byte.b	32
      0  196d					      db	(S8b-*)-1
      1  196d		       1c		      .byte.b	(S8b-*)-1
      0  196e					      db	"POKE(",0
      1  196e		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1974					      CALL	EXPR	; Get address to write to
      0  1974					      db	28
      1  1974		       1c		      .byte.b	28
      0  1975					      dw	EXPR
      1  1975		       82 1a		      .word.w	EXPR
      0  1977					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1977					      db	32
      1  1977		       20		      .byte.b	32
      0  1978					      db	(UNKNOWNV-*)-1
      1  1978		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1979					      db	COMMA,0
      1  1979		       2c 00		      .byte.b	COMMA,0
      0  197b					      CALL	EXPR	; Get the value to poke
      0  197b					      db	28
      1  197b		       1c		      .byte.b	28
      0  197c					      dw	EXPR
      1  197c		       82 1a		      .word.w	EXPR
      0  197e					      TST	UNKNOWNV,")"	; closing bracket
      0  197e					      db	32
      1  197e		       20		      .byte.b	32
      0  197f					      db	(UNKNOWNV-*)-1
      1  197f		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1980					      db	")",0
      1  1980		       29 00		      .byte.b	")",0
      0  1982					      POKEMEM
      0  1982					      db	47
      1  1982		       2f		      .byte.b	47
      0  1983					      DONE
      0  1983					      db	1
      1  1983		       01		      .byte.b	1
      0  1984					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1984					      db	6
      1  1984		       06		      .byte.b	6
      0  1985					      dw	CO
      1  1985		       1f 18		      .word.w	CO
      0  1987					      IJMP	STMT
      0  1987					      db	29
      1  1987		       1d		      .byte.b	29
      0  1988					      dw	STMT
      1  1988		       27 18		      .word.w	STMT
    232  198a
    233  198a				   S8b
      0  198a					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  198a					      db	32
      1  198a		       20		      .byte.b	32
      0  198b					      db	(S8c-*)-1
      1  198b		       11		      .byte.b	(S8c-*)-1
      0  198c					      db	"PUTCH",0
      1  198c		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1992					      CALL	EXPR
      0  1992					      db	28
      1  1992		       1c		      .byte.b	28
      0  1993					      dw	EXPR
      1  1993		       82 1a		      .word.w	EXPR
      0  1995					      PUTCHAR
      0  1995					      db	52
      1  1995		       34		      .byte.b	52
      0  1996					      DONE
      0  1996					      db	1
      1  1996		       01		      .byte.b	1
      0  1997					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1997					      db	6
      1  1997		       06		      .byte.b	6
      0  1998					      dw	CO
      1  1998		       1f 18		      .word.w	CO
      0  199a					      IJMP	STMT
      0  199a					      db	29
      1  199a		       1d		      .byte.b	29
      0  199b					      dw	STMT
      1  199b		       27 18		      .word.w	STMT
    240  199d				   S8c
      0  199d					      TST	S9,"CLS"	;Clear the screen
      0  199d					      db	32
      1  199d		       20		      .byte.b	32
      0  199e					      db	(S9-*)-1
      1  199e		       0b		      .byte.b	(S9-*)-1
      0  199f					      db	"CLS",0
      1  199f		       43 4c 53 00	      .byte.b	"CLS",0
      0  19a3					      CLEARSCREEN
      0  19a3					      db	46
      1  19a3		       2e		      .byte.b	46
      0  19a4					      NXT	CO	;AND SEQUENCE TO NEXT
      0  19a4					      db	6
      1  19a4		       06		      .byte.b	6
      0  19a5					      dw	CO
      1  19a5		       1f 18		      .word.w	CO
      0  19a7					      IJMP	STMT
      0  19a7					      db	29
      1  19a7		       1d		      .byte.b	29
      0  19a8					      dw	STMT
      1  19a8		       27 18		      .word.w	STMT
    245  19aa				   S9
      0  19aa					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  19aa					      db	32
      1  19aa		       20		      .byte.b	32
      0  19ab					      db	(S13-*)-1
      1  19ab		       2a		      .byte.b	(S13-*)-1
      0  19ac					      db	"INPUT",0
      1  19ac		       49 4e 50 55*	      .byte.b	"INPUT",0
    247  19b2				   S10
      0  19b2					      TSTSTR	S10A	;If there is a string print the prompt
      0  19b2					      db	55
      1  19b2		       37		      .byte.b	55
      0  19b3					      db	(S10A-*)-1
      1  19b3		       05		      .byte.b	(S10A-*)-1
      0  19b4					      PRS
      0  19b4					      db	2
      1  19b4		       02		      .byte.b	2
      0  19b5					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  19b5					      db	32
      1  19b5		       20		      .byte.b	32
      0  19b6					      db	(S10Z-*)-1
      1  19b6		       15		      .byte.b	(S10Z-*)-1
      0  19b7					      db	SEMICOLON,0
      1  19b7		       3b 00		      .byte.b	SEMICOLON,0
    251  19b9				   S10A
      0  19b9					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  19b9					      db	33
      1  19b9		       21		      .byte.b	33
      0  19ba					      db	(UNKNOWN-*)-1
      1  19ba		       c3		      .byte.b	(UNKNOWN-*)-1
      0  19bb					      TST	S10A1,DOLLAR
      0  19bb					      db	32
      1  19bb		       20		      .byte.b	32
      0  19bc					      db	(S10A1-*)-1
      1  19bc		       06		      .byte.b	(S10A1-*)-1
      0  19bd					      db	DOLLAR,0
      1  19bd		       24 00		      .byte.b	DOLLAR,0
      0  19bf					      INSTR		;Move character From tty to AESTK
      0  19bf					      db	59
      1  19bf		       3b		      .byte.b	59
      0  19c0					      IJMP	S10A2
      0  19c0					      db	29
      1  19c0		       1d		      .byte.b	29
      0  19c1					      dw	S10A2
      1  19c1		       c4 19		      .word.w	S10A2
    256  19c3				   S10A1
      0  19c3					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  19c3					      db	11
      1  19c3		       0b		      .byte.b	11
    258  19c4				   S10A2
      0  19c4					      STORE		;STORE IT
      0  19c4					      db	19
      1  19c4		       13		      .byte.b	19
      0  19c5					      TST	S11,COMMA	;IS THERE MORE?
      0  19c5					      db	32
      1  19c5		       20		      .byte.b	32
      0  19c6					      db	(S11-*)-1
      1  19c6		       08		      .byte.b	(S11-*)-1
      0  19c7					      db	COMMA,0
      1  19c7		       2c 00		      .byte.b	COMMA,0
      0  19c9					      IJMP	S10	;YES
      0  19c9					      db	29
      1  19c9		       1d		      .byte.b	29
      0  19ca					      dw	S10
      1  19ca		       b2 19		      .word.w	S10
    262  19cc				   S10Z
      0  19cc					      iJMP	UNKNOWN
      0  19cc					      db	29
      1  19cc		       1d		      .byte.b	29
      0  19cd					      dw	UNKNOWN
      1  19cd		       7e 1a		      .word.w	UNKNOWN
    264  19cf				   S11
      0  19cf					      DONE		;MUST BE CR
      0  19cf					      db	1
      1  19cf		       01		      .byte.b	1
      0  19d0					      NXT	CO	;SEQUENCE TO NEXT
      0  19d0					      db	6
      1  19d0		       06		      .byte.b	6
      0  19d1					      dw	CO
      1  19d1		       1f 18		      .word.w	CO
      0  19d3					      IJMP	STMT
      0  19d3					      db	29
      1  19d3		       1d		      .byte.b	29
      0  19d4					      dw	STMT
      1  19d4		       27 18		      .word.w	STMT
    268  19d6				   S13
      0  19d6					      TST	S14,"END"
      0  19d6					      db	32
      1  19d6		       20		      .byte.b	32
      0  19d7					      db	(S14-*)-1
      1  19d7		       08		      .byte.b	(S14-*)-1
      0  19d8					      db	"END",0
      1  19d8		       45 4e 44 00	      .byte.b	"END",0
      0  19dc					      FIN
      0  19dc					      db	12
      1  19dc		       0c		      .byte.b	12
    271  19dd
    272  19dd				   UNKNOWNV
      0  19dd					      IJMP	UNKNOWN
      0  19dd					      db	29
      1  19dd		       1d		      .byte.b	29
      0  19de					      dw	UNKNOWN
      1  19de		       7e 1a		      .word.w	UNKNOWN
    274  19e0
    275  19e0				   S14
      0  19e0					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  19e0					      db	32
      1  19e0		       20		      .byte.b	32
      0  19e1					      db	(S14Z-*)-1
      1  19e1		       0f		      .byte.b	(S14Z-*)-1
      0  19e2					      db	"IRQ",0
      1  19e2		       49 52 51 00	      .byte.b	"IRQ",0
      0  19e6					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  19e6					      db	28
      1  19e6		       1c		      .byte.b	28
      0  19e7					      dw	EXPR
      1  19e7		       82 1a		      .word.w	EXPR
      0  19e9					      DONE		;must be CR
      0  19e9					      db	1
      1  19e9		       01		      .byte.b	1
      0  19ea					      SETIRQ		;Set the line number now
      0  19ea					      db	56
      1  19ea		       38		      .byte.b	56
      0  19eb					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  19eb					      db	6
      1  19eb		       06		      .byte.b	6
      0  19ec					      dw	CO
      1  19ec		       1f 18		      .word.w	CO
      0  19ee					      IJMP	STMT
      0  19ee					      db	29
      1  19ee		       1d		      .byte.b	29
      0  19ef					      dw	STMT
      1  19ef		       27 18		      .word.w	STMT
    282  19f1
    283  19f1				   S14Z
      0  19f1					      TST	S14S1,"KILL"	; Kill A running Task
      0  19f1					      db	32
      1  19f1		       20		      .byte.b	32
      0  19f2					      db	(S14S1-*)-1
      1  19f2		       10		      .byte.b	(S14S1-*)-1
      0  19f3					      db	"KILL",0
      1  19f3		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  19f8					      CALL	EXPR
      0  19f8					      db	28
      1  19f8		       1c		      .byte.b	28
      0  19f9					      dw	EXPR
      1  19f9		       82 1a		      .word.w	EXPR
      0  19fb					      DONE
      0  19fb					      db	1
      1  19fb		       01		      .byte.b	1
      0  19fc					      TASKKILL
      0  19fc					      db	65
      1  19fc		       41		      .byte.b	65
      0  19fd					      NXT	CO
      0  19fd					      db	6
      1  19fd		       06		      .byte.b	6
      0  19fe					      dw	CO
      1  19fe		       1f 18		      .word.w	CO
      0  1a00					      IJMP	STMT
      0  1a00					      db	29
      1  1a00		       1d		      .byte.b	29
      0  1a01					      dw	STMT
      1  1a01		       27 18		      .word.w	STMT
    290  1a03
    291  1a03				   S14S1
      0  1a03					      TST	S15,"LIST"	;LIST COMMAND
      0  1a03					      db	32
      1  1a03		       20		      .byte.b	32
      0  1a04					      db	(S15-*)-1
      1  1a04		       0a		      .byte.b	(S15-*)-1
      0  1a05					      db	"LIST",0
      1  1a05		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1a0a					      DONE
      0  1a0a					      db	1
      1  1a0a		       01		      .byte.b	1
      0  1a0b					      LST
      0  1a0b					      db	21
      1  1a0b		       15		      .byte.b	21
      0  1a0c					      IJMP	CO
      0  1a0c					      db	29
      1  1a0c		       1d		      .byte.b	29
      0  1a0d					      dw	CO
      1  1a0d		       1f 18		      .word.w	CO
    296  1a0f				   S15
      0  1a0f					      TST	S16,"RUN"	;RUN COMMAND
      0  1a0f					      db	32
      1  1a0f		       20		      .byte.b	32
      0  1a10					      db	(S16-*)-1
      1  1a10		       0d		      .byte.b	(S16-*)-1
      0  1a11					      db	"RUN",0
      1  1a11		       52 55 4e 00	      .byte.b	"RUN",0
      0  1a15					      DONE
      0  1a15					      db	1
      1  1a15		       01		      .byte.b	1
      0  1a16					      VINIT		;clear variables
      0  1a16					      db	30
      1  1a16		       1e		      .byte.b	30
      0  1a17					      LIT	1	;GOTO line 1
      0  1a17					      db	27
      1  1a17		       1b		      .byte.b	27
      0  1a18					      dw	1
      1  1a18		       01 00		      .word.w	1
      0  1a1a					      XFER		;Bob's addition
      0  1a1a					      db	7
      1  1a1a		       07		      .byte.b	7
    302  1a1b							; EXIT
      0  1a1b					      IJMP	STMT	;and run!
      0  1a1b					      db	29
      1  1a1b		       1d		      .byte.b	29
      0  1a1c					      dw	STMT
      1  1a1c		       27 18		      .word.w	STMT
    304  1a1e				   S16
      0  1a1e					      TST	S16A,"NEW"	;clear program
      0  1a1e					      db	32
      1  1a1e		       20		      .byte.b	32
      0  1a1f					      db	(S16A-*)-1
      1  1a1f		       08		      .byte.b	(S16A-*)-1
      0  1a20					      db	"NEW",0
      1  1a20		       4e 45 57 00	      .byte.b	"NEW",0
      0  1a24					      DONE
      0  1a24					      db	1
      1  1a24		       01		      .byte.b	1
      0  1a25					      IJMP	START
      0  1a25					      db	29
      1  1a25		       1d		      .byte.b	29
      0  1a26					      dw	START
      1  1a26		       19 18		      .word.w	START
    308  1a28
    309  1a28				   S16A
      0  1a28					      TST	S17A,"TRACE("	;Are we going to trace
      0  1a28					      db	32
      1  1a28		       20		      .byte.b	32
      0  1a29					      db	(S17A-*)-1
      1  1a29		       16		      .byte.b	(S17A-*)-1
      0  1a2a					      db	"TRACE(",0
      1  1a2a		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  1a31					      CALL	EXPR
      0  1a31					      db	28
      1  1a31		       1c		      .byte.b	28
      0  1a32					      dw	EXPR
      1  1a32		       82 1a		      .word.w	EXPR
      0  1a34					      TST	UNKNOWN,")"
      0  1a34					      db	32
      1  1a34		       20		      .byte.b	32
      0  1a35					      db	(UNKNOWN-*)-1
      1  1a35		       48		      .byte.b	(UNKNOWN-*)-1
      0  1a36					      db	")",0
      1  1a36		       29 00		      .byte.b	")",0
      0  1a38					      TRACEPROGRAM
      0  1a38					      db	78
      1  1a38		       4e		      .byte.b	78
      0  1a39					      DONE
      0  1a39					      db	1
      1  1a39		       01		      .byte.b	1
      0  1a3a					      NXT	CO
      0  1a3a					      db	6
      1  1a3a		       06		      .byte.b	6
      0  1a3b					      dw	CO
      1  1a3b		       1f 18		      .word.w	CO
      0  1a3d					      IJMP	STMT
      0  1a3d					      db	29
      1  1a3d		       1d		      .byte.b	29
      0  1a3e					      dw	STMT
      1  1a3e		       27 18		      .word.w	STMT
    317  1a40
    318  1a40				   S17A
      0  1a40					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1a40					      db	32
      1  1a40		       20		      .byte.b	32
      0  1a41					      db	(S17B-*)-1
      1  1a41		       06		      .byte.b	(S17B-*)-1
      0  1a42					      db	"EXIT",0
      1  1a42		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1a47					      EXIT
      0  1a47					      db	26
      1  1a47		       1a		      .byte.b	26
    321  1a48
    322  1a48							;
    323  1a48							; Commands related to saving/restoring programs
    324  1a48							; to/from mass storage.
    325  1a48							;
    326  1a48				   S17B
    327  1a48					      if	(XKIM || CTMON65) && DISK_ACCESS
    328  1a48
      0  1a48					      TST	S17C,"SAVE"
      0  1a48					      db	32
      1  1a48		       20		      .byte.b	32
      0  1a49					      db	(S17C-*)-1
      1  1a49		       0b		      .byte.b	(S17C-*)-1
      0  1a4a					      db	"SAVE",0
      1  1a4a		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1a4f					      OPENWRITE
      0  1a4f					      db	40
      1  1a4f		       28		      .byte.b	40
      0  1a50					      DLIST
      0  1a50					      db	43
      1  1a50		       2b		      .byte.b	43
      0  1a51					      DCLOSE
      0  1a51					      db	41
      1  1a51		       29		      .byte.b	41
      0  1a52					      IJMP	CO
      0  1a52					      db	29
      1  1a52		       1d		      .byte.b	29
      0  1a53					      dw	CO
      1  1a53		       1f 18		      .word.w	CO
    334  1a55
    335  1a55				   S17C
      0  1a55					      TST	S18,"LOAD"
      0  1a55					      db	32
      1  1a55		       20		      .byte.b	32
      0  1a56					      db	(S18-*)-1
      1  1a56		       11		      .byte.b	(S18-*)-1
      0  1a57					      db	"LOAD",0
      1  1a57		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1a5c					      OPENREAD
      0  1a5c					      db	39
      1  1a5c		       27		      .byte.b	39
    338  1a5d				   S17CLP
      0  1a5d					      DGETLINE		;get line from file
      0  1a5d					      db	42
      1  1a5d		       2a		      .byte.b	42
      0  1a5e					      TSTL	S17EOL	;no line num means EOL
      0  1a5e					      db	34
      1  1a5e		       22		      .byte.b	34
      0  1a5f					      db	(S17EOL-*)-1
      1  1a5f		       04		      .byte.b	(S17EOL-*)-1
      0  1a60					      INSERT		;put it into the program
      0  1a60					      db	24
      1  1a60		       18		      .byte.b	24
      0  1a61					      IJMP	S17CLP	;keep going
      0  1a61					      db	29
      1  1a61		       1d		      .byte.b	29
      0  1a62					      dw	S17CLP
      1  1a62		       5d 1a		      .word.w	S17CLP
    343  1a64				   S17EOL
      0  1a64					      DCLOSE		;close disk file
      0  1a64					      db	41
      1  1a64		       29		      .byte.b	41
      0  1a65					      IJMP	CO	;back to start
      0  1a65					      db	29
      1  1a65		       1d		      .byte.b	29
      0  1a66					      dw	CO
      1  1a66		       1f 18		      .word.w	CO
    346  1a68
    347  1a68				   S18
      0  1a68					      TST	S19,"DIR"
      0  1a68					      db	32
      1  1a68		       20		      .byte.b	32
      0  1a69					      db	(S19-*)-1
      1  1a69		       08		      .byte.b	(S19-*)-1
      0  1a6a					      db	"DIR",0
      1  1a6a		       44 49 52 00	      .byte.b	"DIR",0
      0  1a6e					      DDIR		;Display the directory content
      0  1a6e					      db	44
      1  1a6e		       2c		      .byte.b	44
      0  1a6f					      IJMP	CO
      0  1a6f					      db	29
      1  1a6f		       1d		      .byte.b	29
      0  1a70					      dw	CO
      1  1a70		       1f 18		      .word.w	CO
    351  1a72					      endif
    352  1a72
      0  1a72				   S19	      TST	UNKNOWN,"ERASE"
      0  1a72					      db	32
      1  1a72		       20		      .byte.b	32
      0  1a73					      db	(UNKNOWN-*)-1
      1  1a73		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1a74					      db	"ERASE",0
      1  1a74		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1a7a					      RMFILE		;Erase the file from the disk
      0  1a7a					      db	45
      1  1a7a		       2d		      .byte.b	45
      0  1a7b					      IJMP	CO
      0  1a7b					      db	29
      1  1a7b		       1d		      .byte.b	29
      0  1a7c					      dw	CO
      1  1a7c		       1f 18		      .word.w	CO
    356  1a7c					      endif
    357  1a7e
    358  1a7e							;
    359  1a7e							; Else, unknown command.
    360  1a7e							;
    361  1a7e				   UNKNOWN
      0  1a7e					      ENDIO
      0  1a7e					      db	71
      1  1a7e		       47		      .byte.b	71
      0  1a7f					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1a7f					      db	13
      1  1a7f		       0d		      .byte.b	13
      0  1a80					      dw	ERR_SYNTAX
      1  1a80		       05 00		      .word.w	ERR_SYNTAX
    364  1a82
    365  1a82							;-----------------------------------------------------
    366  1a82				   EXPR
      0  1a82					      TST	EXPRNOT,"NOT"
      0  1a82					      db	32
      1  1a82		       20		      .byte.b	32
      0  1a83					      db	(EXPRNOT-*)-1
      1  1a83		       09		      .byte.b	(EXPRNOT-*)-1
      0  1a84					      db	"NOT",0
      1  1a84		       4e 4f 54 00	      .byte.b	"NOT",0
      0  1a88					      Call	EXPR
      0  1a88					      db	28
      1  1a88		       1c		      .byte.b	28
      0  1a89					      dw	EXPR
      1  1a89		       82 1a		      .word.w	EXPR
      0  1a8b					      LOGNOT
      0  1a8b					      db	72
      1  1a8b		       48		      .byte.b	72
      0  1a8c					      RTN
      0  1a8c					      db	25
      1  1a8c		       19		      .byte.b	25
    371  1a8d				   EXPRNOT
    372  1a8d
    373  1a8d				   EXPRLOGS
      0  1a8d					      Call	EXPRCMP
      0  1a8d					      db	28
      1  1a8d		       1c		      .byte.b	28
      0  1a8e					      dw	EXPRCMP
      1  1a8e		       b1 1a		      .word.w	EXPRCMP
      0  1a90					      TST	iLOG1,"AND"
      0  1a90					      db	32
      1  1a90		       20		      .byte.b	32
      0  1a91					      db	(iLOG1-*)-1
      1  1a91		       09		      .byte.b	(iLOG1-*)-1
      0  1a92					      db	"AND",0
      1  1a92		       41 4e 44 00	      .byte.b	"AND",0
      0  1a96					      Call	EXPR
      0  1a96					      db	28
      1  1a96		       1c		      .byte.b	28
      0  1a97					      dw	EXPR
      1  1a97		       82 1a		      .word.w	EXPR
      0  1a99					      LOGAND
      0  1a99					      db	74
      1  1a99		       4a		      .byte.b	74
      0  1a9a					      RTN
      0  1a9a					      db	25
      1  1a9a		       19		      .byte.b	25
    379  1a9b				   iLOG1
      0  1a9b					      TST	iLOG2,"OR"
      0  1a9b					      db	32
      1  1a9b		       20		      .byte.b	32
      0  1a9c					      db	(iLOG2-*)-1
      1  1a9c		       08		      .byte.b	(iLOG2-*)-1
      0  1a9d					      db	"OR",0
      1  1a9d		       4f 52 00 	      .byte.b	"OR",0
      0  1aa0					      Call	EXPR
      0  1aa0					      db	28
      1  1aa0		       1c		      .byte.b	28
      0  1aa1					      dw	EXPR
      1  1aa1		       82 1a		      .word.w	EXPR
      0  1aa3					      LOGOR
      0  1aa3					      db	73
      1  1aa3		       49		      .byte.b	73
      0  1aa4					      RTN
      0  1aa4					      db	25
      1  1aa4		       19		      .byte.b	25
    384  1aa5				   iLOG2
      0  1aa5					      TST	iLOG3,"XOR"
      0  1aa5					      db	32
      1  1aa5		       20		      .byte.b	32
      0  1aa6					      db	(iLOG3-*)-1
      1  1aa6		       09		      .byte.b	(iLOG3-*)-1
      0  1aa7					      db	"XOR",0
      1  1aa7		       58 4f 52 00	      .byte.b	"XOR",0
      0  1aab					      Call	EXPR
      0  1aab					      db	28
      1  1aab		       1c		      .byte.b	28
      0  1aac					      dw	EXPR
      1  1aac		       82 1a		      .word.w	EXPR
      0  1aae					      LOGXOR
      0  1aae					      db	75
      1  1aae		       4b		      .byte.b	75
      0  1aaf					      RTN
      0  1aaf					      db	25
      1  1aaf		       19		      .byte.b	25
    389  1ab0				   iLOG3
      0  1ab0					      RTN
      0  1ab0					      db	25
      1  1ab0		       19		      .byte.b	25
    391  1ab1
    392  1ab1				   EXPRCMP
      0  1ab1					      Call	EXPR2	; get the first expression
      0  1ab1					      db	28
      1  1ab1		       1c		      .byte.b	28
      0  1ab2					      dw	EXPR2
      1  1ab2		       fc 1a		      .word.w	EXPR2
      0  1ab4					      TST	iR0,"="
      0  1ab4					      db	32
      1  1ab4		       20		      .byte.b	32
      0  1ab5					      db	(iR0-*)-1
      1  1ab5		       08		      .byte.b	(iR0-*)-1
      0  1ab6					      db	"=",0
      1  1ab6		       3d 00		      .byte.b	"=",0
      0  1ab8					      LIT	2	;=
      0  1ab8					      db	27
      1  1ab8		       1b		      .byte.b	27
      0  1ab9					      dw	2
      1  1ab9		       02 00		      .word.w	2
      0  1abb					      IJMP	iRFound
      0  1abb					      db	29
      1  1abb		       1d		      .byte.b	29
      0  1abc					      dw	iRFound
      1  1abc		       f7 1a		      .word.w	iRFound
    397  1abe				   iR0
      0  1abe					      TST	iR4,"<"
      0  1abe					      db	32
      1  1abe		       20		      .byte.b	32
      0  1abf					      db	(iR4-*)-1
      1  1abf		       1c		      .byte.b	(iR4-*)-1
      0  1ac0					      db	"<",0
      1  1ac0		       3c 00		      .byte.b	"<",0
      0  1ac2					      TST	iR1,"="
      0  1ac2					      db	32
      1  1ac2		       20		      .byte.b	32
      0  1ac3					      db	(iR1-*)-1
      1  1ac3		       08		      .byte.b	(iR1-*)-1
      0  1ac4					      db	"=",0
      1  1ac4		       3d 00		      .byte.b	"=",0
      0  1ac6					      LIT	3	;<=
      0  1ac6					      db	27
      1  1ac6		       1b		      .byte.b	27
      0  1ac7					      dw	3
      1  1ac7		       03 00		      .word.w	3
      0  1ac9					      IJMP	iRFound
      0  1ac9					      db	29
      1  1ac9		       1d		      .byte.b	29
      0  1aca					      dw	iRFound
      1  1aca		       f7 1a		      .word.w	iRFound
    402  1acc				   iR1
      0  1acc					      TST	iR3,">"
      0  1acc					      db	32
      1  1acc		       20		      .byte.b	32
      0  1acd					      db	(iR3-*)-1
      1  1acd		       08		      .byte.b	(iR3-*)-1
      0  1ace					      db	">",0
      1  1ace		       3e 00		      .byte.b	">",0
      0  1ad0					      LIT	5	;<>
      0  1ad0					      db	27
      1  1ad0		       1b		      .byte.b	27
      0  1ad1					      dw	5
      1  1ad1		       05 00		      .word.w	5
      0  1ad3					      IJMP	iRFound
      0  1ad3					      db	29
      1  1ad3		       1d		      .byte.b	29
      0  1ad4					      dw	iRFound
      1  1ad4		       f7 1a		      .word.w	iRFound
    406  1ad6				   iR3
      0  1ad6					      LIT	1	;<
      0  1ad6					      db	27
      1  1ad6		       1b		      .byte.b	27
      0  1ad7					      dw	1
      1  1ad7		       01 00		      .word.w	1
      0  1ad9					      IJMP	iRFound
      0  1ad9					      db	29
      1  1ad9		       1d		      .byte.b	29
      0  1ada					      dw	iRFound
      1  1ada		       f7 1a		      .word.w	iRFound
    409  1adc				   iR4
      0  1adc					      TST	iRDone,">"
      0  1adc					      db	32
      1  1adc		       20		      .byte.b	32
      0  1add					      db	(iRDone-*)-1
      1  1add		       1d		      .byte.b	(iRDone-*)-1
      0  1ade					      db	">",0
      1  1ade		       3e 00		      .byte.b	">",0
      0  1ae0					      TST	iR5,"="
      0  1ae0					      db	32
      1  1ae0		       20		      .byte.b	32
      0  1ae1					      db	(iR5-*)-1
      1  1ae1		       08		      .byte.b	(iR5-*)-1
      0  1ae2					      db	"=",0
      1  1ae2		       3d 00		      .byte.b	"=",0
      0  1ae4					      LIT	6	;>=
      0  1ae4					      db	27
      1  1ae4		       1b		      .byte.b	27
      0  1ae5					      dw	6
      1  1ae5		       06 00		      .word.w	6
      0  1ae7					      IJMP	iRFound
      0  1ae7					      db	29
      1  1ae7		       1d		      .byte.b	29
      0  1ae8					      dw	iRFound
      1  1ae8		       f7 1a		      .word.w	iRFound
    414  1aea				   iR5
      0  1aea					      TST	iR6,"<"
      0  1aea					      db	32
      1  1aea		       20		      .byte.b	32
      0  1aeb					      db	(iR6-*)-1
      1  1aeb		       08		      .byte.b	(iR6-*)-1
      0  1aec					      db	"<",0
      1  1aec		       3c 00		      .byte.b	"<",0
      0  1aee					      LIT	1
      0  1aee					      db	27
      1  1aee		       1b		      .byte.b	27
      0  1aef					      dw	1
      1  1aef		       01 00		      .word.w	1
      0  1af1					      IJMP	iRFound	;(This line originally omitted)
      0  1af1					      db	29
      1  1af1		       1d		      .byte.b	29
      0  1af2					      dw	iRFound
      1  1af2		       f7 1a		      .word.w	iRFound
    418  1af4				   iR6
      0  1af4					      LIT	4	;>
      0  1af4					      db	27
      1  1af4		       1b		      .byte.b	27
      0  1af5					      dw	4
      1  1af5		       04 00		      .word.w	4
    420  1af7				   iRFound
      0  1af7					      Call	EXPR2	; get the right side of the expression
      0  1af7					      db	28
      1  1af7		       1c		      .byte.b	28
      0  1af8					      dw	EXPR2
      1  1af8		       fc 1a		      .word.w	EXPR2
      0  1afa					      CMPR		; Push the value of the true false onto the stack
      0  1afa					      db	10
      1  1afa		       0a		      .byte.b	10
    423  1afb
    424  1afb				   iRDone
      0  1afb					      RTN
      0  1afb					      db	25
      1  1afb		       19		      .byte.b	25
    426  1afc
    427  1afc				   EXPR2
      0  1afc					      TST	E0,"-"	; Look for leading - to negate term
      0  1afc					      db	32
      1  1afc		       20		      .byte.b	32
      0  1afd					      db	(E0-*)-1
      1  1afd		       09		      .byte.b	(E0-*)-1
      0  1afe					      db	"-",0
      1  1afe		       2d 00		      .byte.b	"-",0
      0  1b00					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1b00					      db	28
      1  1b00		       1c		      .byte.b	28
      0  1b01					      dw	TERM
      1  1b01		       25 1b		      .word.w	TERM
      0  1b03					      NEG		; Make value negated
      0  1b03					      db	16
      1  1b03		       10		      .byte.b	16
      0  1b04					      IJMP	E1	; We have Left term process operators next
      0  1b04					      db	29
      1  1b04		       1d		      .byte.b	29
      0  1b05					      dw	E1
      1  1b05		       0e 1b		      .word.w	E1
    432  1b07				   E0
      0  1b07					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1b07					      db	32
      1  1b07		       20		      .byte.b	32
      0  1b08					      db	(E1A-*)-1
      1  1b08		       02		      .byte.b	(E1A-*)-1
      0  1b09					      db	"+",0
      1  1b09		       2b 00		      .byte.b	"+",0
    434  1b0b				   E1A
      0  1b0b					      CALL	TERM	; Get the left term if it was not negated
      0  1b0b					      db	28
      1  1b0b		       1c		      .byte.b	28
      0  1b0c					      dw	TERM
      1  1b0c		       25 1b		      .word.w	TERM
    436  1b0e				   E1
      0  1b0e					      TST	E2,"+"	; Check if we are adding left term to something
      0  1b0e					      db	32
      1  1b0e		       20		      .byte.b	32
      0  1b0f					      db	(E2-*)-1
      1  1b0f		       09		      .byte.b	(E2-*)-1
      0  1b10					      db	"+",0
      1  1b10		       2b 00		      .byte.b	"+",0
      0  1b12					      CALL	TERM	; if adding then get the right side term
      0  1b12					      db	28
      1  1b12		       1c		      .byte.b	28
      0  1b13					      dw	TERM
      1  1b13		       25 1b		      .word.w	TERM
      0  1b15					      ADD		; Add it to left term
      0  1b15					      db	14
      1  1b15		       0e		      .byte.b	14
      0  1b16					      IJMP	E1	; look for next + or -
      0  1b16					      db	29
      1  1b16		       1d		      .byte.b	29
      0  1b17					      dw	E1
      1  1b17		       0e 1b		      .word.w	E1
    441  1b19				   E2
      0  1b19					      TST	E3,"-"	; Check if we are subtractig something
      0  1b19					      db	32
      1  1b19		       20		      .byte.b	32
      0  1b1a					      db	(E3-*)-1
      1  1b1a		       09		      .byte.b	(E3-*)-1
      0  1b1b					      db	"-",0
      1  1b1b		       2d 00		      .byte.b	"-",0
      0  1b1d					      CALL	TERM	; get right side to subtract Diffrence
      0  1b1d					      db	28
      1  1b1d		       1c		      .byte.b	28
      0  1b1e					      dw	TERM
      1  1b1e		       25 1b		      .word.w	TERM
      0  1b20					      SUB		; Subtract the value
      0  1b20					      db	15
      1  1b20		       0f		      .byte.b	15
      0  1b21					      IJMP	E1	; Look for next + or -
      0  1b21					      db	29
      1  1b21		       1d		      .byte.b	29
      0  1b22					      dw	E1
      1  1b22		       0e 1b		      .word.w	E1
    446  1b24				   E3			; Finish processing the expression
      0  1b24					      RTN		; We are finished processing the Expression
      0  1b24					      db	25
      1  1b24		       19		      .byte.b	25
    448  1b25							;
    449  1b25							; Get one of the terms of an expression
    450  1b25							;
    451  1b25				   TERM
      0  1b25					      CALL	FACT	; Get a value
      0  1b25					      db	28
      1  1b25		       1c		      .byte.b	28
      0  1b26					      dw	FACT
      1  1b26		       4d 1b		      .word.w	FACT
    453  1b28				   T0			; Check for higher precidence operators
      0  1b28					      TST	T1,"*"	; Check for *
      0  1b28					      db	32
      1  1b28		       20		      .byte.b	32
      0  1b29					      db	(T1-*)-1
      1  1b29		       09		      .byte.b	(T1-*)-1
      0  1b2a					      db	"*",0
      1  1b2a		       2a 00		      .byte.b	"*",0
      0  1b2c					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1b2c					      db	28
      1  1b2c		       1c		      .byte.b	28
      0  1b2d					      dw	FACT
      1  1b2d		       4d 1b		      .word.w	FACT
      0  1b2f					      MUL		; Multiply factors
      0  1b2f					      db	17
      1  1b2f		       11		      .byte.b	17
      0  1b30					      IJMP	T0	; Check for * or /
      0  1b30					      db	29
      1  1b30		       1d		      .byte.b	29
      0  1b31					      dw	T0
      1  1b31		       28 1b		      .word.w	T0
    458  1b33				   T1
      0  1b33					      TST	T2,"/"	; Check for a division
      0  1b33					      db	32
      1  1b33		       20		      .byte.b	32
      0  1b34					      db	(T2-*)-1
      1  1b34		       09		      .byte.b	(T2-*)-1
      0  1b35					      db	"/",0
      1  1b35		       2f 00		      .byte.b	"/",0
      0  1b37					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1b37					      db	28
      1  1b37		       1c		      .byte.b	28
      0  1b38					      dw	FACT
      1  1b38		       4d 1b		      .word.w	FACT
      0  1b3a					      DIV		; do division
      0  1b3a					      db	18
      1  1b3a		       12		      .byte.b	18
      0  1b3b					      IJMP	T0	; check for more * or /
      0  1b3b					      db	29
      1  1b3b		       1d		      .byte.b	29
      0  1b3c					      dw	T0
      1  1b3c		       28 1b		      .word.w	T0
    463  1b3e				   T2
      0  1b3e					      TST	T3,"%"	; Check for a division
      0  1b3e					      db	32
      1  1b3e		       20		      .byte.b	32
      0  1b3f					      db	(T3-*)-1
      1  1b3f		       09		      .byte.b	(T3-*)-1
      0  1b40					      db	"%",0
      1  1b40		       25 00		      .byte.b	"%",0
      0  1b42					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1b42					      db	28
      1  1b42		       1c		      .byte.b	28
      0  1b43					      dw	FACT
      1  1b43		       4d 1b		      .word.w	FACT
      0  1b45					      MODULO		; do division for remainder
      0  1b45					      db	60
      1  1b45		       3c		      .byte.b	60
      0  1b46					      IJMP	T0	; check for more * or / or %
      0  1b46					      db	29
      1  1b46		       1d		      .byte.b	29
      0  1b47					      dw	T0
      1  1b47		       28 1b		      .word.w	T0
    468  1b49				   T3			; Finish processing the Term
      0  1b49					      RTN
      0  1b49					      db	25
      1  1b49		       19		      .byte.b	25
    470  1b4a
    471  1b4a				   UNKNOWNVEC
      0  1b4a					      IJMP	UNKNOWN
      0  1b4a					      db	29
      1  1b4a		       1d		      .byte.b	29
      0  1b4b					      dw	UNKNOWN
      1  1b4b		       7e 1a		      .word.w	UNKNOWN
    473  1b4d
    474  1b4d							;
    475  1b4d							; Factor an expression.  Always test for functions
    476  1b4d							; first or else they'll be confused for variables.
    477  1b4d							;
    478  1b4d				   FACT
      0  1b4d					      TST	F1AA,"TRUE"
      0  1b4d					      db	32
      1  1b4d		       20		      .byte.b	32
      0  1b4e					      db	(F1AA-*)-1
      1  1b4e		       09		      .byte.b	(F1AA-*)-1
      0  1b4f					      db	"TRUE",0
      1  1b4f		       54 52 55 45*	      .byte.b	"TRUE",0
      0  1b54					      LIT	-1
      0  1b54					      db	27
      1  1b54		       1b		      .byte.b	27
      0  1b55					      dw	-1
      1  1b55		       ff ff		      .word.w	-1
      0  1b57					      RTN
      0  1b57					      db	25
      1  1b57		       19		      .byte.b	25
    482  1b58				   F1AA
      0  1b58					      TST	F1AB,"FALSE"
      0  1b58					      db	32
      1  1b58		       20		      .byte.b	32
      0  1b59					      db	(F1AB-*)-1
      1  1b59		       0a		      .byte.b	(F1AB-*)-1
      0  1b5a					      db	"FALSE",0
      1  1b5a		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1b60					      LIT	0
      0  1b60					      db	27
      1  1b60		       1b		      .byte.b	27
      0  1b61					      dw	0
      1  1b61		       00 00		      .word.w	0
      0  1b63					      RTN
      0  1b63					      db	25
      1  1b63		       19		      .byte.b	25
    486  1b64				   F1AB
      0  1b64					      TST	F1A,"FREE()"
      0  1b64					      db	32
      1  1b64		       20		      .byte.b	32
      0  1b65					      db	(F1A-*)-1
      1  1b65		       09		      .byte.b	(F1A-*)-1
      0  1b66					      db	"FREE()",0
      1  1b66		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1b6d					      FREE
      0  1b6d					      db	36
      1  1b6d		       24		      .byte.b	36
      0  1b6e					      RTN
      0  1b6e					      db	25
      1  1b6e		       19		      .byte.b	25
    490  1b6f				   F1A
      0  1b6f					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1b6f					      db	32
      1  1b6f		       20		      .byte.b	32
      0  1b70					      db	(F1A2-*)-1
      1  1b70		       0a		      .byte.b	(F1A2-*)-1
      0  1b71					      db	"GETCH()",0
      1  1b71		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1b79					      GETCHAR
      0  1b79					      db	51
      1  1b79		       33		      .byte.b	51
      0  1b7a					      RTN
      0  1b7a					      db	25
      1  1b7a		       19		      .byte.b	25
    494  1b7b				   F1A2
      0  1b7b					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1b7b					      db	32
      1  1b7b		       20		      .byte.b	32
      0  1b7c					      db	(F2AZ-*)-1
      1  1b7c		       0f		      .byte.b	(F2AZ-*)-1
      0  1b7d					      db	"PEEK(",0
      1  1b7d		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1b83					      CALL	EXPR	;Get the address to write to
      0  1b83					      db	28
      1  1b83		       1c		      .byte.b	28
      0  1b84					      dw	EXPR
      1  1b84		       82 1a		      .word.w	EXPR
      0  1b86					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  1b86					      db	32
      1  1b86		       20		      .byte.b	32
      0  1b87					      db	(UNKNOWNVEC-*)-1
      1  1b87		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  1b88					      db	")",0
      1  1b88		       29 00		      .byte.b	")",0
      0  1b8a					      PEEKMEM
      0  1b8a					      db	48
      1  1b8a		       30		      .byte.b	48
      0  1b8b					      RTN
      0  1b8b					      db	25
      1  1b8b		       19		      .byte.b	25
    500  1b8c				   F2AZ
      0  1b8c					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  1b8c					      db	32
      1  1b8c		       20		      .byte.b	32
      0  1b8d					      db	(F2AZ1-*)-1
      1  1b8d		       22		      .byte.b	(F2AZ1-*)-1
      0  1b8e					      db	"TASK(",0
      1  1b8e		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1b94					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1b94					      db	28
      1  1b94		       1c		      .byte.b	28
      0  1b95					      dw	EXPR
      1  1b95		       82 1a		      .word.w	EXPR
      0  1b97					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  1b97					      db	61
      1  1b97		       3d		      .byte.b	61
      0  1b98					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  1b98					      db	32
      1  1b98		       20		      .byte.b	32
      0  1b99					      db	(F2AZNoParms-*)-1
      1  1b99		       10		      .byte.b	(F2AZNoParms-*)-1
      0  1b9a					      db	COMMA,0
      1  1b9a		       2c 00		      .byte.b	COMMA,0
      0  1b9c					      SAVEMATHSTACK		;Push The mathstack
      0  1b9c					      db	86
      1  1b9c		       56		      .byte.b	86
      0  1b9d					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  1b9d					      db	89
      1  1b9d		       59		      .byte.b	89
    507  1b9e				   F2AZLOOP
      0  1b9e					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  1b9e					      db	28
      1  1b9e		       1c		      .byte.b	28
      0  1b9f					      dw	EXPR
      1  1b9f		       82 1a		      .word.w	EXPR
      0  1ba1					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  1ba1					      db	32
      1  1ba1		       20		      .byte.b	32
      0  1ba2					      db	(F2AZEndParm-*)-1
      1  1ba2		       05		      .byte.b	(F2AZEndParm-*)-1
      0  1ba3					      db	COMMA,0
      1  1ba3		       2c 00		      .byte.b	COMMA,0
      0  1ba5					      IJMP	F2AZLOOP	;check for more
      0  1ba5					      db	29
      1  1ba5		       1d		      .byte.b	29
      0  1ba6					      dw	F2AZLOOP
      1  1ba6		       9e 1b		      .word.w	F2AZLOOP
    511  1ba8				   F2AZEndParm
      0  1ba8					      RESTOREMATHSTACK		;Back to normal stack
      0  1ba8					      db	87
      1  1ba8		       57		      .byte.b	87
      0  1ba9					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  1ba9					      db	92
      1  1ba9		       5c		      .byte.b	92
    514  1baa				   F2AZNoParms
      0  1baa					      TST	UNKNOWNVEC,")"	;must be )
      0  1baa					      db	32
      1  1baa		       20		      .byte.b	32
      0  1bab					      db	(UNKNOWNVEC-*)-1
      1  1bab		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bac					      db	")",0
      1  1bac		       29 00		      .byte.b	")",0
      0  1bae					      TASKENABLE		;Enable the task to execute
      0  1bae					      db	90
      1  1bae		       5a		      .byte.b	90
      0  1baf					      RTN		;Returns the Task number
      0  1baf					      db	25
      1  1baf		       19		      .byte.b	25
    518  1bb0				   F2AZ1
      0  1bb0					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  1bb0					      db	32
      1  1bb0		       20		      .byte.b	32
      0  1bb1					      db	(F2A-*)-1
      1  1bb1		       3c		      .byte.b	(F2A-*)-1
      0  1bb2					      db	"IPC",0
      1  1bb2		       49 50 43 00	      .byte.b	"IPC",0
      0  1bb6					      TST	F2AZa,"S("	;IPCS - send a message
      0  1bb6					      db	32
      1  1bb6		       20		      .byte.b	32
      0  1bb7					      db	(F2AZa-*)-1
      1  1bb7		       13		      .byte.b	(F2AZa-*)-1
      0  1bb8					      db	"S(",0
      1  1bb8		       53 28 00 	      .byte.b	"S(",0
      0  1bbb					      CALL	EXPR	;Get the message value
      0  1bbb					      db	28
      1  1bbb		       1c		      .byte.b	28
      0  1bbc					      dw	EXPR
      1  1bbc		       82 1a		      .word.w	EXPR
      0  1bbe					      TST	UNKNOWNVEC,COMMA
      0  1bbe					      db	32
      1  1bbe		       20		      .byte.b	32
      0  1bbf					      db	(UNKNOWNVEC-*)-1
      1  1bbf		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bc0					      db	COMMA,0
      1  1bc0		       2c 00		      .byte.b	COMMA,0
      0  1bc2					      CALL	EXPR	;Get pid of task to send to
      0  1bc2					      db	28
      1  1bc2		       1c		      .byte.b	28
      0  1bc3					      dw	EXPR
      1  1bc3		       82 1a		      .word.w	EXPR
      0  1bc5					      TST	UNKNOWNVEC,")"
      0  1bc5					      db	32
      1  1bc5		       20		      .byte.b	32
      0  1bc6					      db	(UNKNOWNVEC-*)-1
      1  1bc6		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bc7					      db	")",0
      1  1bc7		       29 00		      .byte.b	")",0
      0  1bc9					      IPCSEND		;Send msg and clear pid msg pending
      0  1bc9					      db	80
      1  1bc9		       50		      .byte.b	80
      0  1bca					      RTN
      0  1bca					      db	25
      1  1bca		       19		      .byte.b	25
    527  1bcb				   F2AZa
      0  1bcb					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  1bcb					      db	32
      1  1bcb		       20		      .byte.b	32
      0  1bcc					      db	(F2AZb-*)-1
      1  1bcc		       16		      .byte.b	(F2AZb-*)-1
      0  1bcd					      db	"R(",0
      1  1bcd		       52 28 00 	      .byte.b	"R(",0
      0  1bd0					      TST	F2AZa1,")"
      0  1bd0					      db	32
      1  1bd0		       20		      .byte.b	32
      0  1bd1					      db	(F2AZa1-*)-1
      1  1bd1		       08		      .byte.b	(F2AZa1-*)-1
      0  1bd2					      db	")",0
      1  1bd2		       29 00		      .byte.b	")",0
      0  1bd4					      LIT	0	;We dont want the pid returned to us
      0  1bd4					      db	27
      1  1bd4		       1b		      .byte.b	27
      0  1bd5					      dw	0
      1  1bd5		       00 00		      .word.w	0
      0  1bd7					      IPCIO		;Set the io bit and suspend the task till message
      0  1bd7					      db	83
      1  1bd7		       53		      .byte.b	83
      0  1bd8					      IPCRECEIVE		;Get the message
      0  1bd8					      db	81
      1  1bd8		       51		      .byte.b	81
      0  1bd9					      RTN
      0  1bd9					      db	25
      1  1bd9		       19		      .byte.b	25
    534  1bda				   F2AZa1
      0  1bda					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  1bda					      db	33
      1  1bda		       21		      .byte.b	33
      0  1bdb					      db	(UNKNOWNVEC-*)-1
      1  1bdb		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bdc					      TST	UNKNOWNVEC,")"
      0  1bdc					      db	32
      1  1bdc		       20		      .byte.b	32
      0  1bdd					      db	(UNKNOWNVEC-*)-1
      1  1bdd		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bde					      db	")",0
      1  1bde		       29 00		      .byte.b	")",0
      0  1be0					      IPCIO		;Set the io bit and exit task till message
      0  1be0					      db	83
      1  1be0		       53		      .byte.b	83
      0  1be1					      IPCRECEIVE		;Get the message
      0  1be1					      db	81
      1  1be1		       51		      .byte.b	81
      0  1be2					      RTN
      0  1be2					      db	25
      1  1be2		       19		      .byte.b	25
    540  1be3				   F2AZb
      0  1be3					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  1be3					      db	32
      1  1be3		       20		      .byte.b	32
      0  1be4					      db	(UNKNOWNVEC-*)-1
      1  1be4		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1be5					      db	"C()",0
      1  1be5		       43 28 29 00	      .byte.b	"C()",0
      0  1be9					      IPCCHECK
      0  1be9					      db	82
      1  1be9		       52		      .byte.b	82
      0  1bea					      RTN
      0  1bea					      db	25
      1  1bea		       19		      .byte.b	25
    544  1beb
    545  1beb				   UNKNOWNID
      0  1beb					      IJMP	UNKNOWN
      0  1beb					      db	29
      1  1beb		       1d		      .byte.b	29
      0  1bec					      dw	UNKNOWN
      1  1bec		       7e 1a		      .word.w	UNKNOWN
    547  1bee							;
    548  1bee							; RND() is supposed to have an argument but if none
    549  1bee							; was provided, just assume a large value.
    550  1bee							;
    551  1bee				   F2A
      0  1bee					      TST	F2B,"RND("
      0  1bee					      db	32
      1  1bee		       20		      .byte.b	32
      0  1bef					      db	(F2B-*)-1
      1  1bef		       17		      .byte.b	(F2B-*)-1
      0  1bf0					      db	"RND(",0
      1  1bf0		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1bf5					      TST	F2A1,")"
      0  1bf5					      db	32
      1  1bf5		       20		      .byte.b	32
      0  1bf6					      db	(F2A1-*)-1
      1  1bf6		       07		      .byte.b	(F2A1-*)-1
      0  1bf7					      db	")",0
      1  1bf7		       29 00		      .byte.b	")",0
      0  1bf9					      LIT	32766
      0  1bf9					      db	27
      1  1bf9		       1b		      .byte.b	27
      0  1bfa					      dw	32766
      1  1bfa		       fe 7f		      .word.w	32766
      0  1bfc					      RANDOM
      0  1bfc					      db	37
      1  1bfc		       25		      .byte.b	37
      0  1bfd					      RTN
      0  1bfd					      db	25
      1  1bfd		       19		      .byte.b	25
    557  1bfe
    558  1bfe				   F2A1
      0  1bfe					      CALL	FACT	;GET RANGE
      0  1bfe					      db	28
      1  1bfe		       1c		      .byte.b	28
      0  1bff					      dw	FACT
      1  1bff		       4d 1b		      .word.w	FACT
      0  1c01					      TST	UNKNOWNVEC,")"
      0  1c01					      db	32
      1  1c01		       20		      .byte.b	32
      0  1c02					      db	(UNKNOWNVEC-*)-1
      1  1c02		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c03					      db	")",0
      1  1c03		       29 00		      .byte.b	")",0
      0  1c05					      RANDOM
      0  1c05					      db	37
      1  1c05		       25		      .byte.b	37
      0  1c06					      RTN
      0  1c06					      db	25
      1  1c06		       19		      .byte.b	25
    563  1c07
    564  1c07				   F2B
      0  1c07					      TST	F2B2,"ABS("
      0  1c07					      db	32
      1  1c07		       20		      .byte.b	32
      0  1c08					      db	(F2B2-*)-1
      1  1c08		       0e		      .byte.b	(F2B2-*)-1
      0  1c09					      db	"ABS(",0
      1  1c09		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1c0e					      CALL	EXPR	;get value
      0  1c0e					      db	28
      1  1c0e		       1c		      .byte.b	28
      0  1c0f					      dw	EXPR
      1  1c0f		       82 1a		      .word.w	EXPR
      0  1c11					      TST	UNKNOWNVEC,")"
      0  1c11					      db	32
      1  1c11		       20		      .byte.b	32
      0  1c12					      db	(UNKNOWNVEC-*)-1
      1  1c12		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c13					      db	")",0
      1  1c13		       29 00		      .byte.b	")",0
      0  1c15					      ABS
      0  1c15					      db	38
      1  1c15		       26		      .byte.b	38
      0  1c16					      RTN
      0  1c16					      db	25
      1  1c16		       19		      .byte.b	25
    570  1c17
    571  1c17				   F2B2
      0  1c17					      TST	F2Z,"STAT("
      0  1c17					      db	32
      1  1c17		       20		      .byte.b	32
      0  1c18					      db	(F2Z-*)-1
      1  1c18		       0f		      .byte.b	(F2Z-*)-1
      0  1c19					      db	"STAT(",0
      1  1c19		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1c1f					      Call	EXPR
      0  1c1f					      db	28
      1  1c1f		       1c		      .byte.b	28
      0  1c20					      dw	EXPR
      1  1c20		       82 1a		      .word.w	EXPR
      0  1c22					      TST	UNKNOWNVEC,")"
      0  1c22					      db	32
      1  1c22		       20		      .byte.b	32
      0  1c23					      db	(UNKNOWNVEC-*)-1
      1  1c23		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c24					      db	")",0
      1  1c24		       29 00		      .byte.b	")",0
      0  1c26					      TASKSTAT
      0  1c26					      db	66
      1  1c26		       42		      .byte.b	66
      0  1c27					      RTN
      0  1c27					      db	25
      1  1c27		       19		      .byte.b	25
    577  1c28				   F2Z
      0  1c28					      TST	F2ZA,"PID"
      0  1c28					      db	32
      1  1c28		       20		      .byte.b	32
      0  1c29					      db	(F2ZA-*)-1
      1  1c29		       06		      .byte.b	(F2ZA-*)-1
      0  1c2a					      db	"PID",0
      1  1c2a		       50 49 44 00	      .byte.b	"PID",0
      0  1c2e					      TASKPID
      0  1c2e					      db	77
      1  1c2e		       4d		      .byte.b	77
      0  1c2f					      RTN
      0  1c2f					      db	25
      1  1c2f		       19		      .byte.b	25
    581  1c30				   F2ZA
      0  1c30					      TST	F2FUNC,"CALL("	;call machine function
      0  1c30					      db	32
      1  1c30		       20		      .byte.b	32
      0  1c31					      db	(F2FUNC-*)-1
      1  1c31		       1f		      .byte.b	(F2FUNC-*)-1
      0  1c32					      db	"CALL(",0
      1  1c32		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1c38					      CALL	EXPR
      0  1c38					      db	28
      1  1c38		       1c		      .byte.b	28
      0  1c39					      dw	EXPR
      1  1c39		       82 1a		      .word.w	EXPR
      0  1c3b					      TST	F2B2A,COMMA
      0  1c3b					      db	32
      1  1c3b		       20		      .byte.b	32
      0  1c3c					      db	(F2B2A-*)-1
      1  1c3c		       0b		      .byte.b	(F2B2A-*)-1
      0  1c3d					      db	COMMA,0
      1  1c3d		       2c 00		      .byte.b	COMMA,0
      0  1c3f					      CALL	EXPR
      0  1c3f					      db	28
      1  1c3f		       1c		      .byte.b	28
      0  1c40					      dw	EXPR
      1  1c40		       82 1a		      .word.w	EXPR
      0  1c42					      TST	UNKNOWNVEC,")"
      0  1c42					      db	32
      1  1c42		       20		      .byte.b	32
      0  1c43					      db	(UNKNOWNVEC-*)-1
      1  1c43		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c44					      db	")",0
      1  1c44		       29 00		      .byte.b	")",0
      0  1c46					      CALLFUNC
      0  1c46					      db	53
      1  1c46		       35		      .byte.b	53
      0  1c47					      RTN
      0  1c47					      db	25
      1  1c47		       19		      .byte.b	25
    589  1c48							; Run the gosub within this function
    590  1c48				   F2B2A
      0  1c48					      TST	UNKNOWNID,")"
      0  1c48					      db	32
      1  1c48		       20		      .byte.b	32
      0  1c49					      db	(UNKNOWNID-*)-1
      1  1c49		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  1c4a					      db	")",0
      1  1c4a		       29 00		      .byte.b	")",0
      0  1c4c					      LIT	0
      0  1c4c					      db	27
      1  1c4c		       1b		      .byte.b	27
      0  1c4d					      dw	0
      1  1c4d		       00 00		      .word.w	0
      0  1c4f					      CALLFUNC
      0  1c4f					      db	53
      1  1c4f		       35		      .byte.b	53
      0  1c50					      RTN
      0  1c50					      db	25
      1  1c50		       19		      .byte.b	25
    595  1c51
      0  1c51				   F2FUNC     TST	F2C,"GOFN"
      0  1c51					      db	32
      1  1c51		       20		      .byte.b	32
      0  1c52					      db	(F2C-*)-1
      1  1c52		       0c		      .byte.b	(F2C-*)-1
      0  1c53					      db	"GOFN",0
      1  1c53		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  1c58					      Call	GOSUBSTATEMENT
      0  1c58					      db	28
      1  1c58		       1c		      .byte.b	28
      0  1c59					      dw	GOSUBSTATEMENT
      1  1c59		       88 1c		      .word.w	GOSUBSTATEMENT
      0  1c5b					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  1c5b					      db	8
      1  1c5b		       08		      .byte.b	8
      0  1c5c					      db	GOSUB_RTN_VALUE
      1  1c5c		       81		      .byte.b	GOSUB_RTN_VALUE
      0  1c5d					      XFER
      0  1c5d					      db	7
      1  1c5d		       07		      .byte.b	7
    600  1c5e				   GOFNRet
      0  1c5e					      RTN
      0  1c5e					      db	25
      1  1c5e		       19		      .byte.b	25
    602  1c5f				   F2C
      0  1c5f					      TSTV	F0
      0  1c5f					      db	33
      1  1c5f		       21		      .byte.b	33
      0  1c60					      db	(F0-*)-1
      1  1c60		       15		      .byte.b	(F0-*)-1
      0  1c61					      TST	F2CLocalTask,"!"
      0  1c61					      db	32
      1  1c61		       20		      .byte.b	32
      0  1c62					      db	(F2CLocalTask-*)-1
      1  1c62		       05		      .byte.b	(F2CLocalTask-*)-1
      0  1c63					      db	"!",0
      1  1c63		       21 00		      .byte.b	"!",0
      0  1c65					      IND		; we just got a pid
      0  1c65					      db	20
      1  1c65		       14		      .byte.b	20
      0  1c66					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  1c66					      db	93
      1  1c66		       5d		      .byte.b	93
      0  1c67					      db	(UNKNOWNID-*)-1
      1  1c67		       83		      .byte.b	(UNKNOWNID-*)-1
    607  1c68
    608  1c68				   F2CLocalTask
      0  1c68					      TST	F2C1,"["
      0  1c68					      db	32
      1  1c68		       20		      .byte.b	32
      0  1c69					      db	(F2C1-*)-1
      1  1c69		       0a		      .byte.b	(F2C1-*)-1
      0  1c6a					      db	"[",0
      1  1c6a		       5b 00		      .byte.b	"[",0
      0  1c6c					      CALL	EXPR
      0  1c6c					      db	28
      1  1c6c		       1c		      .byte.b	28
      0  1c6d					      dw	EXPR
      1  1c6d		       82 1a		      .word.w	EXPR
      0  1c6f					      TST	UNKNOWNID,"]"
      0  1c6f					      db	32
      1  1c6f		       20		      .byte.b	32
      0  1c70					      db	(UNKNOWNID-*)-1
      1  1c70		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  1c71					      db	"]",0
      1  1c71		       5d 00		      .byte.b	"]",0
      0  1c73					      SUBSCRIPT
      0  1c73					      db	64
      1  1c73		       40		      .byte.b	64
    613  1c74				   F2C1
      0  1c74					      IND		;YES, GET THE VALUE.
      0  1c74					      db	20
      1  1c74		       14		      .byte.b	20
      0  1c75					      RTN
      0  1c75					      db	25
      1  1c75		       19		      .byte.b	25
    616  1c76				   F0
      0  1c76					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1c76					      db	35
      1  1c76		       23		      .byte.b	35
      0  1c77					      db	(F1-*)-1
      1  1c77		       01		      .byte.b	(F1-*)-1
      0  1c78					      RTN
      0  1c78					      db	25
      1  1c78		       19		      .byte.b	25
    619  1c79				   F1
      0  1c79					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  1c79					      db	32
      1  1c79		       20		      .byte.b	32
      0  1c7a					      db	(F2RTN-*)-1
      1  1c7a		       09		      .byte.b	(F2RTN-*)-1
      0  1c7b					      db	"(",0
      1  1c7b		       28 00		      .byte.b	"(",0
      0  1c7d					      CALL	EXPR
      0  1c7d					      db	28
      1  1c7d		       1c		      .byte.b	28
      0  1c7e					      dw	EXPR
      1  1c7e		       82 1a		      .word.w	EXPR
      0  1c80					      TST	F2,")"
      0  1c80					      db	32
      1  1c80		       20		      .byte.b	32
      0  1c81					      db	(F2-*)-1
      1  1c81		       03		      .byte.b	(F2-*)-1
      0  1c82					      db	")",0
      1  1c82		       29 00		      .byte.b	")",0
    623  1c84				   F2RTN
      0  1c84					      RTN
      0  1c84					      db	25
      1  1c84		       19		      .byte.b	25
    625  1c85
    626  1c85				   F2
      0  1c85					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1c85					      db	13
      1  1c85		       0d		      .byte.b	13
      0  1c86					      dw	ERR_SYNTAX
      1  1c86		       05 00		      .word.w	ERR_SYNTAX
    628  1c88							;
    629  1c88							;=============================================================
    630  1c88							; Gosub can be both a Function and a Subroutine
    631  1c88				   GOSUBSTATEMENT
      0  1c88					      CALL	EXPR	;GET DESTINATION
      0  1c88					      db	28
      1  1c88		       1c		      .byte.b	28
      0  1c89					      dw	EXPR
      1  1c89		       82 1a		      .word.w	EXPR
      0  1c8b					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  1c8b					      db	32
      1  1c8b		       20		      .byte.b	32
      0  1c8c					      db	(GOSUBDONE-*)-1
      1  1c8c		       14		      .byte.b	(GOSUBDONE-*)-1
      0  1c8d					      db	"(",0
      1  1c8d		       28 00		      .byte.b	"(",0
      0  1c8f					      STK2TMP		;Transfer stack top to temp
      0  1c8f					      db	95
      1  1c8f		       5f		      .byte.b	95
      0  1c90					      PUSHMATHSTACK		;Record stack frame for return
      0  1c90					      db	84
      1  1c90		       54		      .byte.b	84
    636  1c91				   GOSUBLOOP
      0  1c91					      CALL	EXPR	; Allows what ever fits onto stack
      0  1c91					      db	28
      1  1c91		       1c		      .byte.b	28
      0  1c92					      dw	EXPR
      1  1c92		       82 1a		      .word.w	EXPR
      0  1c94					      INCPARMCOUNT
      0  1c94					      db	88
      1  1c94		       58		      .byte.b	88
      0  1c95					      TST	GOSUBParmDONE,COMMA
      0  1c95					      db	32
      1  1c95		       20		      .byte.b	32
      0  1c96					      db	(GOSUBParmDONE-*)-1
      1  1c96		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  1c97					      db	COMMA,0
      1  1c97		       2c 00		      .byte.b	COMMA,0
      0  1c99					      IJMP	GOSUBLOOP
      0  1c99					      db	29
      1  1c99		       1d		      .byte.b	29
      0  1c9a					      dw	GOSUBLOOP
      1  1c9a		       91 1c		      .word.w	GOSUBLOOP
    641  1c9c				   GOSUBParmDONE
      0  1c9c					      TST	F2,")"
      0  1c9c					      db	32
      1  1c9c		       20		      .byte.b	32
      0  1c9d					      db	(F2-*)-1
      1  1c9d		       e7		      .byte.b	(F2-*)-1
      0  1c9e					      db	")",0
      1  1c9e		       29 00		      .byte.b	")",0
      0  1ca0					      TMP2STK		;Restore line to goto
      0  1ca0					      db	96
      1  1ca0		       60		      .byte.b	96
    644  1ca1				   GOSUBDONE
      0  1ca1					      RTN
      0  1ca1					      db	25
      1  1ca1		       19		      .byte.b	25
    646  1ca2
    647  1ca2		       1c a2	   ILEND      equ	*
------- FILE mytb.asm
   2166  1ca2		       1c a2	   PROGEND    equ	*
   2167  1ca2
   2168  1ca2
   2169  1ca2							;=====================================================
   2170  1ca2							; Define start of non page zero data
   2171 U1cb2					      seg.u	TBData
   2172 U1cb2
   2173 U1cb2							;=====================================================
   2174 U1cb2							; These are storage items not in page zero.
   2175 U1cb2							;
   2176 U1cb2							; IRQ BASIC Code Service RTN Support
      0 U1cb2				   SaveIrqReg db	0	; Store current setting
      1 U1cb2		       00		      .byte.b	0
      0 U1cb3				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1cb3		       00		      .byte.b	0
      0 U1cb4				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1cb4		       00		      .byte.b	0
      0 U1cb5				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1cb5		       00 00		      .byte.b	0,0
   2181 U1cb7
   2182 U1cb7							;
   2183 U1cb7							;==================================================================================================
   2184 U1cb7							; Task Management information
   2185 U1cb7							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2186 U1cb7							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2187 U1cb7							; Task switchs happen at the beginning of the next Basic command line
   2188 U1cb7							; It will not happen during an input or output operations
   2189 U1cb7							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2190 U1cb7							; Task Zero is always the root task, main line program
   2191 U1cb7							;
   2192 U1cb7							; Layout is repeated for each configured task
   2193 U1cb7							; Task Table Byte   use masks follow
   2194 U1cb7		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2195 U1cb7		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2196 U1cb7		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2197 U1cb7		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2198 U1cb7		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2199 U1cb7
   2200 U1cb7		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2201 U1cb8		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2202 U1cb8		       1d b2	   TASKTABLEEND equ	*	; End of task table
   2203 U1cb8		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2204 U1db2
   2205 U1db2							;Task Cycle Counter and reset count
   2206 U1db2		       00	   taskCurrentCycles ds	1
   2207 U1db3		       00	   taskResetValue ds	1
   2208 U1db4		       00	   taskCounter ds	1	; Count of active tasks
   2209 U1db5
   2210 U1db5							;
   2211 U1db5							; Math stack and IL call and Gosub/For-next return stack definitions
   2212 U1db5							;
   2213 U1db5		       1d b5	   STACKSTART equ	*
   2214 U1db5		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2215 U1f45		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2216 U20d5		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2217 U2355		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2218 U2355		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2219 U2355		       25 71	   STACKEND   equ	*
   2220 U2355		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2221 U2571							;
   2222 U2571							;
   2223 U2571		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2224 U25f5		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2225 U25f6		       00	   printtx    ds	1	;temp X for print funcs
   2226 U25f7		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2227 U25f8		       00	   promptChar ds	1	;the character to use for a prompt
   2228 U25f9		       00	   diddigit   ds	1	;for leading zero suppression
   2229 U25fa		       00	   putsy      ds	1
   2230 U25fb		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2231 U25fd		       00	   sign       ds	1	;0 = positive, else negative
   2232 U25fe		       00 00	   rtemp1     ds	2	;Temp for x and y
   2233 U2600		       00 00	   random     ds	2
   2234 U2602		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2235 U2604		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2236 U2606		       00	   tempy      ds	1	;temp y storage
   2237 U2607				  -	      if	XKIM
   2238 U2607				  -buffer     ds	BUFFER_SIZE
   2239 U2607					      endif
   2240 U2607							;
   2241 U2607							; PROGRAMEND is the end of the user's BASIC program.
   2242 U2607							; More precisely, it is one byte past the end.  Or,
   2243 U2607							; it's where the next line added to the end will be
   2244 U2607							; placed.
   2245 U2607							;
   2246 U2607		       00 00	   PROGRAMEND ds	2	; End of users basic program
   2247 U2609		       00 00	   HighMem    ds	2	; highest location
   2248 U260b		       00 00	   UsedMem    ds	2	; size of user program
   2249 U260d		       00 00	   FreeMem    ds	2	; amount of free memory
   2250 U260f							;
   2251 U260f							;=====================================================
   2252 U260f							; This is the start of the user's BASIC program space.
   2253 U260f							;
   2254 U260f							; PERSONAL GOAL: This should be no larger than $0DFF.
   2255 U260f							;		  0200-05FF = 1K
   2256 U260f							;		  0200-09FF = 2K
   2257 U260f							;		  0200-0DFF = 3K
   2258 U260f							;		  0200-11FF = 4K
   2259 U260f							;		  0200-13FF = 4.5K
   2260 U260f							;
   2261 U260f				  -	      if	FIXED
   2262 U260f				  -	      org	$2000
   2263 U260f					      endif
   2264 U260f		       26 0f	   ProgramStart equ	*
   2265 U260f							;/*
   2266 U260f							;	if	CTMON65 || XKIM
   2267 U260f							;		SEG Code
   2268 U260f							;		org	AutoRun
   2269 U260f							;		dw	TBasicCold
   2270 U260f							;	endif
   2271 U260f							;*/
   2272 U260f					      end
