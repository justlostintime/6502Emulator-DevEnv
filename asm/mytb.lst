------- FILE mytb.asm LEVEL 1 PASS 4
      1 U15ae				   input      processor	6502
      2 U15ae ????						;=====================================================
      3 U15ae ????						; Bob's Tiny BASIC
      4 U15ae ????						;
      5 U15ae ????						; While working on the Corsham Technologies KIM Clone
      6 U15ae ????						; project, I wanted to include a TINY BASIC since that
      7 U15ae ????						; was a highly desirable feature of early computers.
      8 U15ae ????						;
      9 U15ae ????						; Rather than negotiating copyright issues for
     10 U15ae ????						; existing BASICs, I decided to just write one from
     11 U15ae ????						; scratch.
     12 U15ae ????						;
     13 U15ae ????						; 10/07/2017
     14 U15ae ????						;
     15 U15ae ????						; This implements a stripped down Tiny BASIC
     16 U15ae ????						; interpreter using the Interpretive Language (IL)
     17 U15ae ????						; method as described in the first few issues of
     18 U15ae ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U15ae ????						; to write various languages simply by changing the
     20 U15ae ????						; IL code rather than the interpreter itself.
     21 U15ae ????						;
     22 U15ae ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U15ae ????						;		* Fixed major bug in findLine that
     24 U15ae ????						;		  caused corrupted lines, crashes, etc.
     25 U15ae ????						;		* If no parameter given to RND, assume
     26 U15ae ????						;		  32766.
     27 U15ae ????						;		* No more error 5 when a program
     28 U15ae ????						;		  reaches the end without an END.
     29 U15ae ????						;
     30 U15ae ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U15ae ????						;		 * Add some usefull system level functions
     32 U15ae ????						;		 * allow a larger number of tiny basic formats
     33 U15ae ????						;		 * Add byte at start of line holding length
     34 U15ae ????						;		   for faster execution of goto and gosub
     35 U15ae ????						;		 * Re-added gosub
     36 U15ae ????						;		 * allow ; or , at end if print stmt
     37 U15ae ????						;		   without CRLF being added.
     38 U15ae ????						;		 * Added extended function erase to
     39 U15ae ????						;		   use the extended ctmon65 rm file
     40 U15ae ????						;		 * Fix quoted text to not have to backtrack
     41 U15ae ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     42 U15ae ????						;
     43 U15ae ????						; www.corshamtech.com
     44 U15ae ????						; bob@corshamtech.com
     45 U15ae ????						; JustLostInTime@gmail.com
     46 U15ae ????						;
     47 U15ae ????						;=====================================================
     48 U15ae ????						;
     49 U15ae ????						; Create TRUE and FALSE values for conditionals.
     50 U15ae ????						;
     51 U15ae ????
     52 U15ae ????	       00 00	   FALSE      equ	0
     53 U15ae ????	       ff ff ff ff TRUE       equ	~FALSE
     54 U15ae ????						;
     55 U15ae ????						;---------------------------------------------------------
     56 U15ae ????						; One of these must be set to indicate which environment
     57 U15ae ????						; Tiny BASIC will be running in.  Here are the current
     58 U15ae ????						; environments:
     59 U15ae ????						;
     60 U15ae ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     61 U15ae ????						; more K of RAM.
     62 U15ae ????						;
     63 U15ae ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     64 U15ae ????						; which enhances, without replacing, the standard KIM
     65 U15ae ????						; monitor.  It gives access to routines to save/load files
     66 U15ae ????						; to a micro SD card.
     67 U15ae ????						;
     68 U15ae ????						; CTMON65 is a from-scratch monitor written for the
     69 U15ae ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     70 U15ae ????						; easily be ported to other systems.  It has support for
     71 U15ae ????						; using a micro SD card for file storage/retrieval.
     72 U15ae ????						;
     73 U15ae ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     74 U15ae ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     75 U15ae ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     76 U15ae ????						;
     77 U15ae ????						;   Need to define some macros for the dasm assembler
     78 U15ae ????						;
     79 U15ae ????				      MACRO	dw
     80 U15ae ????				      .word	{0}
     81 U15ae ????				      ENDM
     82 U15ae ????
     83 U15ae ????				      MACRO	db
     84 U15ae ????				      .byte	{0}
     85 U15ae ????				      ENDM
     86 U15ae ????
     87 U15ae ????						;
     88 U15ae ????						; If set, include disk functions.
     89 U15ae ????						;
     90 U15ae ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     91 U15ae ????						;
     92 U15ae ????						; If ILTRACE is set then dump out the address of every
     93 U15ae ????						; IL opcode before executing it.
     94 U15ae ????						;
     95 U15ae ????	       00 00	   ILTRACE    equ	FALSE
     96 U15ae ????						;
     97 U15ae ????						; If FIXED is set, put the IL code and the user
     98 U15ae ????						; program space at fixed locations in memory.	This is
     99 U15ae ????						; meant only for debugging.
    100 U15ae ????						;
    101 U15ae ????	       00 00	   FIXED      equ	FALSE
    102 U15ae ????						;
    103 U15ae ????						; Sets the arithmetic stack depth.  This is *TINY*
    104 U15ae ????						; BASIC, so keep this small!
    105 U15ae ????						;
    106 U15ae ????	       00 14	   STACKSIZE  equ	20	;number of entries
    107 U15ae ????	       00 28	   ILSTACKSIZE equ	40	;number of entries in ilstack
    108 U15ae ????	       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting max is 85
    109 U15ae ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 85 tasks
    110 U15ae ????	       00 14	   TASKCYCLESDEFAULT equ	20	;Default Task Switch 0-255 uses a single byte
    111 U15ae ????						;
    112 U15ae ????						; Common ASCII constants
    113 U15ae ????						;
    114 U15ae ????	       00 07	   BEL	      equ	$07
    115 U15ae ????	       00 08	   BS	      equ	$08
    116 U15ae ????	       00 09	   TAB	      equ	$09
    117 U15ae ????	       00 0a	   LF	      equ	$0A
    118 U15ae ????	       00 0d	   CR	      equ	$0D
    119 U15ae ????	       00 22	   quote      equ	$22
    120 U15ae ????	       00 20	   SPACE      equ	$20
    121 U15ae ????	       00 2c	   COMMA      equ	',
    122 U15ae ????	       00 3b	   SEMICOLON  equ	';
    123 U15ae ????	       00 3a	   COLON      equ	':
    124 U15ae ????	       00 24	   DOLLAR     equ	'$
    125 U15ae ????						;
    126 U15ae ????						; These are error codes
    127 U15ae ????						;
    128 U15ae ????	       00 00	   ERR_NONE   equ	0	;No Errror
    129 U15ae ????	       00 01	   ERR_EXPR   equ	1	;expression error
    130 U15ae ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    131 U15ae ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    132 U15ae ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    133 U15ae ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    134 U15ae ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    135 U15ae ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    136 U15ae ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    137 U15ae ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    138 U15ae ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    139 U15ae ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    140 U15ae ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    141 U15ae ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    142 U15ae ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    143 U15ae ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    144 U15ae ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    145 U15ae ????						;
    146 U15ae ????						;=====================================================
    147 U15ae ????						; Zero page storage.
    148 U15ae ????						;
    149 U15ae ????				      SEG.U	Data
    150 U0040					      org	$0040
    151 U0040
    152 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    153 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    154 U0041		       00 75	   variablesEnd equ	*	;End of variable space
    155 U0075		       00 00	   ILPC       ds	2	;IL program counter
    156 U0077		       00 00	   dpl	      ds	2
    157 U0079		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    158 U007b		       00	   tempIlY    ds	1	;Temp IL Y register storage
    159 U007c		       00	   offset     ds	1	;IL Offset to next inst when test fails
    160 U007d		       00	   lineLength ds	1	;Length of current line
    161 U007e							;
    162 U007e							; CURPTR is a pointer to curent BASIC line being
    163 U007e							; executed.  Always points to start of line, CUROFF
    164 U007e							; is the offset to the current character.
    165 U007e							;
    166 U007e		       00 00	   CURPTR     ds	2	;Pointer to current Basic line
    167 U0080		       00	   CUROFF     ds	1	;Current offset in Basic Line
    168 U0081							;
    169 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    170 U0083							;
    171 U0083
    172 U0083							;
    173 U0083							; R0 and R1 are used for arithmetic operations and
    174 U0083							; general use.
    175 U0083							;
    176 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    177 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    178 U0087							;
    179 U0087							; This is zero if in immediate mode, or non-zero
    180 U0087							; if currently running a program.  Any input from
    181 U0087							; the main loop clears this, and the XFER IL
    182 U0087							; statement will set it.
    183 U0087							;
    184 U0087		       00	   RunMode    ds	1	;Basic program is running or stop
    185 U0088							;
    186 U0088							; Used for line insertion/removal.
    187 U0088							;
    188 U0088		       00 00	   FROM       ds	2	;Used for basic prog insert/remove and print text
    189 U008a
    190 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    191 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    192 U008a							;
    193 U008a		       00 88	   PrtFrom    EQU	FROM
    194 U008a							;
    195 U008a							;Task Cycle Counter and reset count
    196 U008a		       00	   taskCurrentCycles ds	1
    197 U008b		       00	   taskResetValue ds	1
    198 U008c		       00	   taskCount  ds	1	; Count of active tasks
    199 U008d							;
    200 U008d							;=====================================================
    201 U008d							;
    202  146a ????				      SEG	Code
    203  0200					      org	$0200
    204  0200							;
    205  0200							; Cold start is at $0200.  Warm start is at $0203.
    206  0200							;
    207  0200		       4c 18 02    TBasicCold jmp	cold2	;jump around vectors
    208  0203		       4c bd 02    warm       jmp	warm2	;Entry point for worm restart
    209  0206							;
    210  0206							; These are the user-supplied vectors to I/O routines.
    211  0206							; If you want, you can just patch these in the binary
    212  0206							; file, but it would be better to change the source
    213  0206							; code.
    214  0206							;
    215  0206				  -	      if	KIM
    216  0206				  -OUTCH      jmp	$1ea0	;output char in A
    217  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    218  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    219  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    220  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    221  0206					      endif
    222  0206				  -	      if	XKIM
    223  0206				  -	      include	"xkim.inc"
    224  0206				  -	      SEG	Code
    225  0206				  -OUTCH      jmp	$1ea0
    226  0206				  -GETCH      jmp	xkGETCH
    227  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    228  0206				  -OUTHEX     jmp	xkPRTBYT
    229  0206				  -MONITOR    jmp	extKIM
    230  0206				  -puts       equ	putsil
    231  0206				  -BUFFER_SIZE equ	132
    232  0206					      endif
    233  0206
    234  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U00f6 ????				      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 U008d					      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    236  0206					      SEG	Code
    237  0206							;
    238  0206		       4c 0c f0    OUTCH      jmp	cout
    239  0209		       4c 09 f0    GETCH      jmp	cin
    240  020c		       4c 18 f0    CRLF       jmp	crlf
    241  020f		       4c 1b f0    OUTHEX     jmp	HexA
    242  0212		       4c 03 f0    MONITOR    jmp	WARM
    243  0215		       4c 0f f0    ISCHAR     jmp	cstatus
    244  0215		       f0 12	   puts       equ	putsil
    245  0218					      endif
    246  0218							;
    247  0218		       20 12 f0    cold2      jsr	puts
      0  021b					      db	CR,LF
      1  021b		       0d 0a		      .byte.b	CR,LF
      0  021d					      db	"Bob's Tiny BASIC v1.0.2 IRQs"
      1  021d		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs"
      0  0239					      db	CR,LF
      1  0239		       0d 0a		      .byte.b	CR,LF
      0  023b					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  023b		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0269					      db	CR,LF,0
      1  0269		       0d 0a 00 	      .byte.b	CR,LF,0
    253  026c							;
    254  026c		       20 7e 0f 	      jsr	GetSizes	;setup the free space available
    255  026f		       ad a8 15 	      lda	HighMem
    256  0272		       e9 3c		      sbc	#GOSUBSTACKSIZE*3
    257  0274		       85 81		      sta	GOSUBSTACK
    258  0276		       ad a9 15 	      lda	HighMem+1
    259  0279		       e9 00		      sbc	#0
    260  027b		       85 82		      sta	GOSUBSTACK+1
    261  027d		       a9 1c		      lda	#IL&$ff
    262  027f		       85 75		      sta	ILPC
    263  0281		       a9 11		      lda	#IL>>8
    264  0283		       85 76		      sta	ILPC+1
    265  0285							;
    266  0285		       a9 ae		      lda	#ProgramStart&$ff	;user prog
    267  0287		       8d a6 15 	      sta	PROGRAMEND
    268  028a		       a9 15		      lda	#ProgramStart>>8
    269  028c		       8d a7 15 	      sta	PROGRAMEND+1
    270  028f							;
    271  028f							; Initialize the pseudo-random number sequence...
    272  028f							;
    273  028f		       a9 5a		      lda	#$5a
    274  0291		       8d a0 15 	      sta	rtemp1
    275  0294		       a9 9d		      lda	#%10011101
    276  0296		       8d a1 15 	      sta	random
    277  0299		       a9 5b		      lda	#%01011011
    278  029b		       8d a2 15 	      sta	random+1
    279  029e							;
    280  029e							;   Insert a Basic irq handler for the basic Language
    281  029e		       a9 ab		      lda	#ServiceIrq&$ff
    282  02a0		       8d 00 df 	      sta	IRQvec
    283  02a3		       a9 02		      lda	#ServiceIrq>>8
    284  02a5		       8d 01 df 	      sta	IRQvec+1
    285  02a8		       4c ca 02 	      jmp	coldtwo
    286  02ab
    287  02ab							;
    288  02ab							; This is the Basic IRQ handler
    289  02ab		       48	   ServiceIrq pha
    290  02ac		       ad 6b 14 	      lda	IRQStatus
    291  02af		       f0 0a		      BEQ	RetIrq
    292  02b1		       ad 6c 14 	      lda	IRQPending
    293  02b4		       d0 05		      bne	RetIrq
    294  02b6		       a9 01		      lda	#1
    295  02b8		       8d 6c 14 	      sta	IRQPending
    296  02bb		       68	   RetIrq     pla
    297  02bc		       40		      rti
    298  02bd							;
    299  02bd							;
    300  02bd							; This is the warm start entry point
    301  02bd							;
    302  02bd		       20 0c 02    warm2      jsr	CRLF
    303  02c0		       ad 9b 15 	      lda	errGoto
    304  02c3		       85 75		      sta	ILPC
    305  02c5		       ad 9c 15 	      lda	errGoto+1
    306  02c8		       85 76		      sta	ILPC+1
    307  02ca							;
    308  02ca							; And continue with both starts here
    309  02ca							;
    310  02ca		       20 b1 0f    coldtwo    jsr	SetOutConsole
    311  02cd							;
    312  02cd							; The ILTrace flag is now run-time settable.
    313  02cd							;
    314  02cd		       a9 00		      lda	#ILTRACE&$ff
    315  02cf		       85 40		      sta	ILTrace
    316  02d1							;
    317  02d1		       a9 00		      lda	#0
    318  02d3		       85 87		      sta	RunMode
    319  02d5		       8d 13 15 	      sta	LINBUF
    320  02d8							; Clear everything from the stacks
    321  02d8		       8d c0 14 	      sta	mathStackPtr
    322  02db		       8d 11 15 	      sta	retStackPtr
    323  02de		       8d 12 15 	      sta	GoSubStackPtr
    324  02e1							;
    325  02e1		       a9 13		      lda	#LINBUF&$ff
    326  02e3		       85 7e		      sta	CURPTR
    327  02e5		       a9 15		      lda	#LINBUF>>8
    328  02e7		       85 7f		      sta	CURPTR+1	;fall through...
    329  02e9
    330  02e9							;=====================================================
    331  02e9							; This is the top of the IL interpreter.  This fetches
    332  02e9							; and executes the instruction currently pointed to
    333  02e9							; by ILPC and adjusts ILPC to point to the next
    334  02e9							; instruction to execute.
    335  02e9							;
    336  02e9		       a5 40	   NextIL     lda	ILTrace
    337  02eb		       f0 03		      beq	NextIL2
    338  02ed		       20 39 0f 	      jsr	dbgLine
    339  02f0		       a4 80	   NextIL2    ldy	CUROFF
    340  02f2		       20 30 0f 	      jsr	SkipSpaces
    341  02f5		       84 80		      sty	CUROFF
    342  02f7							;
    343  02f7		       20 14 0c    NextILStr  jsr	getILByte
    344  02fa							;
    345  02fa							; When the handler is called, these are the conditions
    346  02fa							; of several important items:
    347  02fa							;
    348  02fa							;    (ILPC) will point to the byte AFTER the IL
    349  02fa							;    opcode being executed.
    350  02fa							;
    351  02fa							;    (CURPTR),CUROFF will point to the start of the
    352  02fa							;    next word in the input buffer.  Ie, the next word
    353  02fa							;    in the user program.
    354  02fa							;
    355  02fa		       0a		      asl
    356  02fb		       c9 8c		      cmp	#ILTBLend-ILTBL+2
    357  02fd		       90 33		      bcc	ILgood
    358  02ff							;
    359  02ff							; This handles an illegal IL opcode.  This is serious
    360  02ff							; and there's no way to recover.
    361  02ff							;
    362  02ff		       20 12 f0    ILbad      jsr	puts
      0  0302					      db	CR,LF
      1  0302		       0d 0a		      .byte.b	CR,LF
      0  0304					      db	"Illegal IL "
      1  0304		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  030f					      db	0
      1  030f		       00		      .byte.b	0
    366  0310							;
    367  0310							; Well this is awkward, we need to back up the IL
    368  0310							; by one since it no longer points to the current
    369  0310							; opcode.
    370  0310							;
    371  0310		       20 21 0c 	      jsr	decIL
    372  0313							;
    373  0313		       a0 00		      ldy	#0
    374  0315		       b1 75		      lda	(ILPC),y
    375  0317		       20 0f 02 	      jsr	OUTHEX
    376  031a		       20 12 f0 	      jsr	puts
      0  031d					      db	" at ",0
      1  031d		       20 61 74 20*	      .byte.b	" at ",0
    378  0322		       a5 76		      lda	ILPC+1
    379  0324		       20 0f 02 	      jsr	OUTHEX
    380  0327		       a5 75		      lda	ILPC
    381  0329		       20 0f 02 	      jsr	OUTHEX
    382  032c		       20 0c 02 	      jsr	CRLF
    383  032f		       4c 12 02 	      jmp	MONITOR
    384  0332							;
    385  0332							; Just jump to the address (ILPC),y.  Have to do
    386  0332							; some goofy stuff.
    387  0332							;
    388  0332		       a8	   ILgood     tay		;move index into Y
    389  0333		       b9 40 03 	      lda	ILTBL,y
    390  0336		       85 77		      sta	dpl
    391  0338		       b9 41 03 	      lda	ILTBL+1,y
    392  033b		       85 78		      sta	dpl+1
    393  033d		       6c 77 00 	      jmp	(dpl)	;go to handler
    394  0340							;
    395  0340							;=====================================================
    396  0340							; This is the IL jump table.  The IL opcode is
    397  0340							; mulitplied by two, then looked-up in this table.
    398  0340							; There is absolutely nothing special about the order
    399  0340							; of entries here... they all decode at exactly the
    400  0340							; same speed.	However the entry number must match the
    401  0340							; values in IL.inc.
    402  0340							;
      0  0340				   ILTBL      dw	iXINIT	;0
      1  0340		       f3 03		      .word.w	iXINIT
      0  0342					      dw	iDONE	;1
      1  0342		       31 04		      .word.w	iDONE
      0  0344					      dw	iPRS	;2
      1  0344		       4d 04		      .word.w	iPRS
      0  0346					      dw	iPRN	;3
      1  0346		       57 04		      .word.w	iPRN
      0  0348					      dw	iSPC	;4
      1  0348		       60 04		      .word.w	iSPC
      0  034a					      dw	iNLINE	;5
      1  034a		       42 08		      .word.w	iNLINE
      0  034c					      dw	iNXT	;6
      1  034c		       68 04		      .word.w	iNXT
      0  034e					      dw	iXFER	;7
      1  034e		       94 04		      .word.w	iXFER
      0  0350					      dw	iSAV	;8
      1  0350		       c1 04		      .word.w	iSAV
      0  0352					      dw	iRSTR	;9
      1  0352		       e2 04		      .word.w	iRSTR
      0  0354					      dw	iCMPR	;10
      1  0354		       ee 04		      .word.w	iCMPR
      0  0356					      dw	iINNUM	;11
      1  0356		       4d 05		      .word.w	iINNUM
      0  0358					      dw	iFIN	;12
      1  0358		       77 05		      .word.w	iFIN
      0  035a					      dw	iERR	;13
      1  035a		       88 05		      .word.w	iERR
      0  035c					      dw	iADD	;14
      1  035c		       f9 05		      .word.w	iADD
      0  035e					      dw	iSUB	;15
      1  035e		       0f 06		      .word.w	iSUB
      0  0360					      dw	iNEG	;16
      1  0360		       25 06		      .word.w	iNEG
      0  0362					      dw	iMUL	;17
      1  0362		       3d 06		      .word.w	iMUL
      0  0364					      dw	iDIV	;18
      1  0364		       77 06		      .word.w	iDIV
      0  0366					      dw	iSTORE	;19
      1  0366		       d7 06		      .word.w	iSTORE
      0  0368					      dw	iIND	;20
      1  0368		       ea 06		      .word.w	iIND
      0  036a					      dw	iLST	;21
      1  036a		       1c 07		      .word.w	iLST
      0  036c					      dw	iINIT	;22
      1  036c		       ca 03		      .word.w	iINIT
      0  036e					      dw	iGETLINE	;23
      1  036e		       7b 07		      .word.w	iGETLINE
      0  0370					      dw	iINSRT	;24
      1  0370		       87 07		      .word.w	iINSRT
      0  0372					      dw	iRTN	;25
      1  0372		       3c 08		      .word.w	iRTN
      0  0374					      dw	MONITOR	;26
      1  0374		       12 02		      .word.w	MONITOR
      0  0376					      dw	iLIT	;27
      1  0376		       55 08		      .word.w	iLIT
      0  0378					      dw	iCALL	;28
      1  0378		       48 08		      .word.w	iCALL
      0  037a					      dw	iJMP	;29
      1  037a		       4b 08		      .word.w	iJMP
      0  037c					      dw	iVINIT	;30
      1  037c		       62 08		      .word.w	iVINIT
      0  037e					      dw	iERRGOTO	;31
      1  037e		       70 08		      .word.w	iERRGOTO
      0  0380					      dw	iTST	;32
      1  0380		       7c 08		      .word.w	iTST
      0  0382					      dw	iTSTV	;33
      1  0382		       01 09		      .word.w	iTSTV
      0  0384					      dw	iTSTL	;34
      1  0384		       2b 09		      .word.w	iTSTL
      0  0386					      dw	iTSTN	;35
      1  0386		       45 09		      .word.w	iTSTN
      0  0388					      dw	iFREE	;36
      1  0388		       11 0a		      .word.w	iFREE
      0  038a					      dw	iRANDOM	;37
      1  038a		       1a 0a		      .word.w	iRANDOM
      0  038c					      dw	iABS	;38
      1  038c		       f3 0a		      .word.w	iABS
    442  038e							;
    443  038e							; Disk functions.  There must be pointers
    444  038e							; to functions even if no disk is supported.
    445  038e							; Makes things easier in IL.inc.
    446  038e							;
    447  038e					      if	DISK_ACCESS
      0  038e					      dw	iOPENREAD	;39
      1  038e		       f7 0f		      .word.w	iOPENREAD
      0  0390					      dw	iOPENWRITE	;40
      1  0390		       4b 10		      .word.w	iOPENWRITE
      0  0392					      dw	iDCLOSE	;41
      1  0392		       cf 10		      .word.w	iDCLOSE
      0  0394					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0394		       6a 10		      .word.w	iDGETLINE
      0  0396					      dw	iDLIST	;43 Did you remeber your towel?
      1  0396		       c9 10		      .word.w	iDLIST
      0  0398					      dw	iDDIR	;44
      1  0398		       a4 10		      .word.w	iDDIR
      0  039a					      dw	iRMFILE	;45
      1  039a		       25 10		      .word.w	iRMFILE
    455  039c				  -	      else
    456  039c				  -	      dw	NextIL	;39
    457  039c				  -	      dw	NextIL	;40
    458  039c				  -	      dw	NextIL	;41
    459  039c				  -	      dw	NextIL	;42
    460  039c				  -	      dw	NextIL	;43
    461  039c				  -	      dw	NextIL	;44
    462  039c				  -	      dw	NextIL	;45
    463  039c					      endif
    464  039c							;
      0  039c					      dw	iCLEARSCREEN	;46
      1  039c		       ec 0f		      .word.w	iCLEARSCREEN
      0  039e					      dw	iPOKEMEMORY	;47
      1  039e		       7a 0a		      .word.w	iPOKEMEMORY
      0  03a0					      dw	iPEEKMEMORY	;48
      1  03a0		       8f 0a		      .word.w	iPEEKMEMORY
      0  03a2					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03a2		       c1 08		      .word.w	iTSTLET
      0  03a4					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  03a4		       e0 08		      .word.w	iTSTDONE
      0  03a6					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03a6		       bc 0a		      .word.w	iGETCHAR
      0  03a8					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03a8		       d6 0a		      .word.w	iPUTCHAR
      0  03aa					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03aa		       a5 0a		      .word.w	iCallFunc
      0  03ac					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  03ac		       3b 05		      .word.w	iBranch
      0  03ae					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03ae		       a5 08		      .word.w	iTSTStr
      0  03b0					      dw	iSetIrq	;56	   sets the irq handler
      1  03b0		       0d 0b		      .word.w	iSetIrq
      0  03b2					      dw	iTstIrq	;57	   test if irq is pending
      1  03b2		       88 09		      .word.w	iTstIrq
      0  03b4					      dw	iRET	;58	   return from interupt
      1  03b4		       d0 04		      .word.w	iRET
      0  03b6					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03b6		       5e 05		      .word.w	iINSTR
      0  03b8					      dw	iMOD	;60	   returns remainder of division
      1  03b8		       80 06		      .word.w	iMOD
      0  03ba					      dw	iTaskSwitch	;61	   switch to the next BASIC program task
      1  03ba		       bf 09		      .word.w	iTaskSwitch
      0  03bc					      dw	iTaskSet	;62	   sets a line number for the start of a task
      1  03bc		       44 0b		      .word.w	iTaskSet
      0  03be					      dw	iETask	;63	   Terminates a task
      1  03be		       d8 0b		      .word.w	iETask
      0  03c0					      dw	iNTask	;64	   goto next task
      1  03c0		       d1 0b		      .word.w	iNTask
      0  03c2					      dw	iArray	;65	   Allow Variable to have a subscript
      1  03c2		       fa 06		      .word.w	iArray
      0  03c4					      dw	iTaskKill	;66	   kill a running task
      1  03c4		       c9 0b		      .word.w	iTaskKill
      0  03c6					      dw	iTaskStat	;67	   return the state of a task PID
      1  03c6		       9b 0b		      .word.w	iTaskStat
      0  03c8					      dw	iHexOut	;68	   output the value on the stack as a hex string
      1  03c8		       e1 0a		      .word.w	iHexOut
    488  03ca
    489  03ca		       03 ca	   ILTBLend   equ	*
    490  03ca							;
    491  03ca							;=====================================================
    492  03ca							;=====================================================
    493  03ca							;=====================================================
    494  03ca							; This marks the start of the handlers for IL opcodes.
    495  03ca							;=====================================================
    496  03ca							;=====================================================
    497  03ca							;=====================================================
    498  03ca							;
    499  03ca							;
    500  03ca		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    501  03cc		       8d 11 15 	      sta	retStackPtr
    502  03cf		       8d 12 15 	      sta	GoSubStackPtr
    503  03d2							;
    504  03d2		       a9 ae		      lda	#ProgramStart&$ff	;user prog
    505  03d4		       85 7e		      sta	CURPTR
    506  03d6		       8d 70 14 	      sta	taskTable+1
    507  03d9		       8d a6 15 	      sta	PROGRAMEND
    508  03dc		       a9 15		      lda	#ProgramStart>>8
    509  03de		       85 7f		      sta	CURPTR+1
    510  03e0		       8d 71 14 	      sta	taskTable+2
    511  03e3		       8d a7 15 	      sta	PROGRAMEND+1
    512  03e6		       a9 01		      lda	#1
    513  03e8		       8d 6f 14 	      sta	taskTable	;Mark the first slot as active
    514  03eb		       85 8c		      sta	taskCount	;there is always one task / Main task
    515  03ed		       a9 14		      lda	#TASKCYCLESDEFAULT
    516  03ef		       85 8b		      sta	taskResetValue
    517  03f1		       85 8a		      sta	taskCurrentCycles	; set up the task switch counts
    518  03f3							;
    519  03f3							; fall into XINIT...
    520  03f3							;
    521  03f3							;=====================================================
    522  03f3							; This initializes for the start of the next line of
    523  03f3							; BASIC text.
    524  03f3							;
    525  03f3		       78	   iXINIT     sei		;ensure interupts are off
    526  03f4		       a9 00		      lda	#0
    527  03f6		       8d c0 14 	      sta	mathStackPtr	;clear math stack
    528  03f9		       8d 97 14 	      sta	taskPtr	;Set the first slot
    529  03fc		       8d 6c 14 	      sta	IRQPending	; reset the irq pending
    530  03ff		       8d 6b 14 	      sta	IRQStatus	; Make sure irqs are off
    531  0402		       a9 01		      lda	#1
    532  0404		       85 8c		      sta	taskCount	;Number of actual tasks
    533  0406		       20 1a 04 	      jsr	taskClear	;Clear the task table
    534  0409		       4c e9 02    goodExit   jmp	NextIL
    535  040c							;
    536  040c							;=====================================================
    537  040c							; This check if the escape key has been entered
    538  040c							; then changes out of run mode. z Set if esc found
    539  040c				   BreakSet
    540  040c		       20 15 02 	      jsr	ISCHAR
    541  040f		       f0 06		      beq	BreakNo
    542  0411		       20 09 02 	      jsr	GETCH
    543  0414		       c9 1b		      cmp	#$1B
    544  0416		       60		      rts
    545  0417				   BreakNo
    546  0417		       a9 01		      lda	#1
    547  0419		       60		      rts
    548  041a							;
    549  041a							;=====================================================
    550  041a							; Clear the task table
    551  041a				   taskClear
    552  041a		       98		      tya
    553  041b		       48		      pha
    554  041c		       a0 04		      ldy	#4
    555  041e		       a9 00		      lda	#0
    556  0420		       c0 28	   taskClearLoop cpy	#TASKCOUNT*4
    557  0422		       f0 0a		      beq	taskClearDone
    558  0424		       99 6f 14 	      sta	taskTable,y
    559  0427		       c8		      iny
    560  0428		       c8		      iny
    561  0429		       c8		      iny
    562  042a		       c8		      iny
    563  042b		       4c 20 04 	      jmp	taskClearLoop
    564  042e		       68	   taskClearDone pla
    565  042f		       a8		      tay
    566  0430		       60		      rts
    567  0431
    568  0431							;
    569  0431							;=====================================================
    570  0431							; Verify there is nothing else on this input line.
    571  0431							; If there is, generate an error.
    572  0431							;
    573  0431		       a4 80	   iDONE      ldy	CUROFF
    574  0433		       20 30 0f 	      jsr	SkipSpaces
    575  0436		       b1 7e		      lda	(CURPTR),y
    576  0438		       f0 10		      beq	doneadv
    577  043a		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    578  043c		       d0 05		      bne	idoneErr
    579  043e		       84 80		      sty	CUROFF
    580  0440		       4c e9 02 	      jmp	NextIL	; continue on this line
    581  0443
    582  0443				   idoneErr
    583  0443		       a2 04		      ldx	#ERR_EXTRA_STUFF
    584  0445		       a9 00		      lda	#0
    585  0447		       4c 8b 05 	      jmp	iErr2
    586  044a							;
    587  044a							; Advance to the next line
    588  044a							;
    589  044a				   doneadv
    590  044a							;		 jsr	 FindNext2
    591  044a		       4c e9 02 	      jmp	NextIL
    592  044d							;
    593  044d							;=====================================================
    594  044d							; Print the string until a closing quote
    595  044d							;
    596  044d		       a4 80	   iPRS       ldy	CUROFF
    597  044f							;
    598  044f							; Odd logic here.  The main loop skipped any leading
    599  044f							; whitespace inside the quoted text, so move back to
    600  044f							; the quote, then move forward again.
    601  044f							;
    602  044f		       20 bf 0f 	      jsr	PrtQuoted
    603  0452		       84 80		      sty	CUROFF
    604  0454		       4c e9 02 	      jmp	NextIL
    605  0457							;
    606  0457							;=====================================================
    607  0457							; Pop the top off the stack and print it as a signed
    608  0457							; decimal number.
    609  0457							;
    610  0457		       20 67 0e    iPRN       jsr	popR0
    611  045a		       20 b9 0c 	      jsr	PrintDecimal
    612  045d		       4c e9 02 	      jmp	NextIL
    613  0460							;
    614  0460							;=====================================================
    615  0460							; Space to next zone.	Currently the code does not
    616  0460							; keep track of which column the output is on, so
    617  0460							; just print a tab.
    618  0460							;
    619  0460		       a9 09	   iSPC       lda	#TAB
    620  0462		       20 06 02 	      jsr	OUTCH
    621  0465		       4c e9 02 	      jmp	NextIL
    622  0468							;
    623  0468							;=====================================================
    624  0468							; If in immediate mode, jump to the address following
    625  0468							; the NXT instruction.  Else move to the next line of
    626  0468							; user code and continue.
    627  0468							;
    628  0468		       a5 87	   iNXT       lda	RunMode
    629  046a		       d0 03		      bne	iNxtRun	;in run mode
    630  046c							;
    631  046c							; Get address and jump to it.
    632  046c							;
    633  046c		       4c 4b 08 	      jmp	iJMP
    634  046f							;
    635  046f				   iNxtRun
    636  046f		       a4 80		      ldy	CUROFF
    637  0471		       20 30 0f 	      jsr	SkipSpaces
    638  0474		       b1 7e		      lda	(CURPTR),y
    639  0476		       c9 3a		      cmp	#COLON
    640  0478		       d0 09		      bne	iNxtRunGo
    641  047a		       c8		      iny
    642  047b		       20 30 0f 	      jsr	SkipSpaces
    643  047e		       84 80		      sty	CUROFF
    644  0480		       4c 8e 04 	      jmp	iNxtRun2
    645  0483
    646  0483				   iNxtRunGo
    647  0483		       20 9a 0c 	      jsr	FindNextLine
    648  0486		       20 ac 0c 	      jsr	AtEnd
    649  0489		       d0 03		      bne	iNxtRun2	;not at end
    650  048b							;
    651  048b							; At the end of the program.  Pretend an END statement
    652  048b							; was found.
    653  048b							;
    654  048b		       4c 77 05    iFINv      jmp	iFIN
    655  048e							;
    656  048e		       20 10 0c    iNxtRun2   jsr	getILWord	;ignore next word
    657  0491		       4c e9 02 	      jmp	NextIL
    658  0494							;
    659  0494							;=====================================================
    660  0494							; XFER takes the number on top of the stack and looks
    661  0494							; for that line in the program, or the next line
    662  0494							; higher.  Ie, if it's 1 but there is no line 1, then
    663  0494							; find the next one after that.
    664  0494							;
    665  0494		       20 67 0e    iXFER      jsr	popR0
    666  0497		       20 57 0c 	      jsr	findLine
    667  049a		       20 ac 0c    iXFER2     jsr	AtEnd	;at end of user program?
    668  049d		       f0 ec		      beq	iFINv
    669  049f		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    670  04a1		       84 80		      sty	CUROFF
    671  04a3		       a9 ff		      lda	#$ff
    672  04a5		       85 87		      sta	RunMode
    673  04a7							;
    674  04a7							; Transfer IL to STMT.  I don't like having this
    675  04a7							; hard-coded; fix it.
    676  04a7							;
    677  04a7		       a9 2a		      lda	#STMT&$ff
    678  04a9		       85 75		      sta	ILPC
    679  04ab		       a9 11		      lda	#STMT>>8
    680  04ad		       85 76		      sta	ILPC+1
    681  04af		       4c e9 02 	      jmp	NextIL
    682  04b2							;
    683  04b2							; Run
    684  04b2							;
    685  04b2				   iXferok
    686  04b2		       a9 ff		      lda	#$ff
    687  04b4		       85 87		      sta	RunMode	;we're running
    688  04b6							;
    689  04b6							; Need a more elegant way to do this
    690  04b6							;
    691  04b6		       a9 2a		      lda	#STMT&$ff
    692  04b8		       85 75		      sta	ILPC
    693  04ba		       a9 11		      lda	#STMT>>8
    694  04bc		       85 76		      sta	ILPC+1
    695  04be		       4c e9 02 	      jmp	NextIL
    696  04c1							;
    697  04c1							;=====================================================
    698  04c1							; Save the pointer to the next line to the call stack.
    699  04c1							;
    700  04c1		       20 30 0e    iSAV       jsr	pushLN
    701  04c4		       b0 03		      bcs	iSAVErr
    702  04c6		       4c e9 02 	      jmp	NextIL
    703  04c9
    704  04c9		       a2 0c	   iSAVErr    ldx	#12
    705  04cb		       a9 00	   iSAVErr2   lda	#0
    706  04cd		       4c 8b 05 	      jmp	iErr2
    707  04d0
    708  04d0							;
    709  04d0							;=====================================================
    710  04d0							; Pop the next line from the call stack.
    711  04d0							;
    712  04d0		       20 7a 0e    iRET       jsr	popLN
    713  04d3		       b0 f4		      bcs	iSAVErr
    714  04d5		       a0 03		      ldy	#3
    715  04d7		       84 80		      sty	CUROFF
    716  04d9		       a9 00		      lda	#0
    717  04db		       8d 6c 14 	      sta	IRQPending
    718  04de		       58		      cli
    719  04df		       4c e9 02 	      jmp	NextIL
    720  04e2							;
    721  04e2							;=====================================================
    722  04e2							; Return from IL program call
    723  04e2							;
    724  04e2		       20 7a 0e    iRSTR      jsr	popLN
    725  04e5		       b0 e2		      bcs	iSAVErr
    726  04e7		       4c e9 02 	      jmp	NextIL
    727  04ea
    728  04ea		       a2 0b	   iRSTRErr   ldx	#11
    729  04ec		       d0 dd		      bne	iSAVErr2
    730  04ee							;
    731  04ee							;=====================================================
    732  04ee							; Compare items on stack.  Okay, so on input there are
    733  04ee							; three things on the stack
    734  04ee							;
    735  04ee							;    EXPR2 <- Top of stack
    736  04ee							;    OP    <- relational operator, next on stack
    737  04ee							;    EXPR1 <- last item on stack
    738  04ee							;
    739  04ee							; Comparison is: EXPR1 <operator> EXPR2
    740  04ee							;
    741  04ee							; Operator is one of...
    742  04ee							;
    743  04ee							;    2 is =
    744  04ee							;    1 is <
    745  04ee							;    3 is <=
    746  04ee							;    5 is <>
    747  04ee							;    4 is >
    748  04ee							;    6 is >=
    749  04ee							;
    750  04ee							; Those are bit-mapped:
    751  04ee							;
    752  04ee							;    xxxxxGEL
    753  04ee							;
    754  04ee							;    G = Greater than
    755  04ee							;    E = Equal
    756  04ee							;    L = Less than
    757  04ee							;
    758  04ee							; If the comparison is false, do a NXT, ie, move to the
    759  04ee							; next line and continue.  If true, continue executing
    760  04ee							; on this line.
    761  04ee							;
    762  04ee		       00 01	   REL_LT     equ	%001
    763  04ee		       00 02	   REL_EQUAL  equ	%010
    764  04ee		       00 04	   REL_GT     equ	%100
    765  04ee							;
    766  04ee		       20 9e 0e    iCMPR      jsr	popR1
    767  04f1		       20 b1 0e 	      jsr	popMQ	;operator in MQ
    768  04f4		       20 67 0e 	      jsr	popR0
    769  04f7							;
    770  04f7							; See if they are equal or not
    771  04f7							;
    772  04f7		       a5 83		      lda	R0
    773  04f9		       c5 85		      cmp	R1
    774  04fb		       d0 0a		      bne	iCMPRnoteq	;try not equal
    775  04fd		       a5 84		      lda	R0+1
    776  04ff		       c5 86		      cmp	R1+1
    777  0501		       d0 04		      bne	iCMPRnoteq
    778  0503							;
    779  0503							; Equal, set the flag in MQ+1
    780  0503							;
    781  0503		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    782  0505		       d0 14		      bne	iCMPcom	;Exit it is equal
    783  0507							;
    784  0507							; See if EXPR1 (R0) < EXPR2 (R1)
    785  0507							; See www.6502.org/tutorials/compare_beyond.html
    786  0507							;
    787  0507				   iCMPRnoteq
    788  0507		       a5 83		      lda	R0
    789  0509		       c5 85		      cmp	R1
    790  050b		       a5 84		      lda	R0+1
    791  050d		       e5 86		      sbc	R1+1
    792  050f		       50 02		      bvc	iCMPR_2
    793  0511		       49 80		      eor	#$80
    794  0513		       30 04	   iCMPR_2    bmi	iCMPlt
    795  0515		       a9 04		      lda	#REL_GT
    796  0517		       d0 02		      bne	iCMPcom
    797  0519		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    798  051b
    799  051b		       0d 9e 15    iCMPcom    ora	MQ+1	; or with original mask
    800  051e							;
    801  051e							; Now compare the end result with what the caller
    802  051e							; was looking for.
    803  051e							;
    804  051e		       2d 9d 15 	      and	MQ
    805  0521		       f0 0a		      beq	iCMPno	; no match
    806  0523		       a9 01		      lda	#1
    807  0525		       85 83		      sta	R0
    808  0527		       d0 08		      bne	iCMPDone
    809  0529							;
    810  0529							; R0 > R1
    811  0529							;
    812  0529		       a9 04	   iCMPgt     lda	#REL_GT
    813  052b		       d0 ee		      bne	iCMPcom
    814  052d				   iCMPno
    815  052d		       a9 00		      lda	#0
    816  052f		       85 83		      sta	R0
    817  0531
    818  0531				   iCMPDone
    819  0531		       a9 00		      lda	#0
    820  0533		       85 84		      sta	R0+1
    821  0535		       20 1d 0e 	      jsr	pushR0
    822  0538		       4c e9 02 	      jmp	NextIL
    823  053b							;
    824  053b							; if Not a match, so jump to the next line of code.
    825  053b							; Branches based upon value on top of the stack
    826  053b				   iBranch
    827  053b		       20 67 0e 	      jsr	popR0
    828  053e		       a5 83		      lda	R0
    829  0540		       05 84		      ora	R0+1
    830  0542		       f0 03		      beq	iBranchFalse	; not true
    831  0544		       4c e9 02 	      jmp	NextIL	; It is true if any value not zero
    832  0547							;
    833  0547				   iBranchFalse
    834  0547		       20 9a 0c 	      jsr	FindNextLine
    835  054a		       4c 9a 04 	      jmp	iXFER2
    836  054d							;
    837  054d							;=====================================================
    838  054d							; Get a line of text from the user, convert to a
    839  054d							; number, leave on top of stack.
    840  054d							;
    841  054d				   iINNUM
    842  054d		       20 30 0e 	      jsr	pushLN
    843  0550							;
    844  0550		       a9 3f		      lda	#'?
    845  0552		       20 9c 0d 	      jsr	GetLine
    846  0555		       20 25 0d 	      jsr	getDecimal
    847  0558		       20 1d 0e 	      jsr	pushR0	;put onto stack
    848  055b							;
    849  055b		       4c 71 05 	      jmp	ExitIn
    850  055e							;
    851  055e							;=====================================================
    852  055e							; Get a line of text from the user, convert to a
    853  055e							; String , leave on top of stack. up to 2 characters
    854  055e							;
    855  055e				   iINSTR
    856  055e		       20 30 0e 	      jsr	pushLN
    857  0561		       a9 3f		      lda	#'?
    858  0563		       20 9c 0d 	      jsr	GetLine
    859  0566		       b1 7e		      lda	(CURPTR),y
    860  0568		       85 83		      sta	R0
    861  056a		       a9 00		      lda	#0
    862  056c		       85 84		      sta	R0+1
    863  056e		       20 1d 0e 	      jsr	pushR0	;put onto stack
    864  0571				   ExitIn
    865  0571		       20 7a 0e 	      jsr	popLN
    866  0574		       4c e9 02 	      jmp	NextIL
    867  0577							;
    868  0577							;
    869  0577							;=====================================================
    870  0577							; Stop the currently running program.	Actually very
    871  0577							; simple to do... clear the RunMode flag, then set the
    872  0577							; ILPC to the standard handler and continue running.
    873  0577							;
    874  0577		       a9 00	   iFIN       lda	#0
    875  0579		       85 87		      sta	RunMode
    876  057b							;
    877  057b		       ad 9b 15 	      lda	errGoto
    878  057e		       85 75		      sta	ILPC
    879  0580		       ad 9c 15 	      lda	errGoto+1
    880  0583		       85 76		      sta	ILPC+1
    881  0585		       4c e9 02 	      jmp	NextIL
    882  0588							;
    883  0588							;=====================================================
    884  0588							; Handle the ERR opcode.  Following the instruction is
    885  0588							; a 16 bit error number.  Print an error message, and
    886  0588							; if we're in run mode, print the line number.  Stop
    887  0588							; program execution and return to the initial state.
    888  0588							;
    889  0588		       20 10 0c    iERR       jsr	getILWord	;get err code
    890  058b							;
    891  058b							; Enter here with the error code in X (LSB) and A (MSB).
    892  058b							;
    893  058b		       86 83	   iErr2      stx	R0
    894  058d		       85 84		      sta	R0+1
    895  058f							;
    896  058f		       20 12 f0 	      jsr	puts
      0  0592					      db	"Error ",0
      1  0592		       45 72 72 6f*	      .byte.b	"Error ",0
    898  0599		       20 b9 0c 	      jsr	PrintDecimal
    899  059c							;
    900  059c		       a5 87		      lda	RunMode	;running?
    901  059e		       f0 40		      beq	iERR3	;nope
    902  05a0		       20 12 f0 	      jsr	puts
      0  05a3					      db	" at line ",0
      1  05a3		       20 61 74 20*	      .byte.b	" at line ",0
    904  05ad		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    905  05af				   iErr2a
    906  05af		       b1 7e		      lda	(CURPTR),y
    907  05b1		       85 83		      sta	R0
    908  05b3		       c8		      iny
    909  05b4		       b1 7e		      lda	(CURPTR),y
    910  05b6		       85 84		      sta	R0+1
    911  05b8		       20 b9 0c 	      jsr	PrintDecimal
    912  05bb		       20 12 f0 	      jsr	puts
      0  05be					      db	" at ",0
      1  05be		       20 61 74 20*	      .byte.b	" at ",0
    914  05c3		       a9 00		      lda	#0
    915  05c5		       85 84		      sta	R0+1
    916  05c7		       a5 80		      lda	CUROFF
    917  05c9		       18		      clc
    918  05ca		       e9 03		      sbc	#3
    919  05cc		       85 83		      sta	R0
    920  05ce		       20 b9 0c 	      jsr	PrintDecimal
    921  05d1		       20 12 f0 	      jsr	puts
      0  05d4					      db	" = $",0
      1  05d4		       20 3d 20 24*	      .byte.b	" = $",0
    923  05d9		       a4 80		      ldy	CUROFF
    924  05db		       b1 7e		      lda	(CURPTR),y
    925  05dd		       20 0f 02 	      jsr	OUTHEX
    926  05e0							;
    927  05e0		       20 0c 02    iERR3      jsr	CRLF
    928  05e3		       a9 00		      lda	#0
    929  05e5		       85 87		      sta	RunMode	;fall through...
    930  05e7							;
    931  05e7							;=====================================================
    932  05e7							; Reset the IL to be back at the idle loop.  Does not
    933  05e7							; clear variables so the user can see what state
    934  05e7							; the program is in.
    935  05e7							;
    936  05e7		       a9 00	   ResetIL    lda	#0
    937  05e9		       8d 11 15 	      sta	retStackPtr
    938  05ec		       ad 9b 15 	      lda	errGoto
    939  05ef		       85 75		      sta	ILPC
    940  05f1		       ad 9c 15 	      lda	errGoto+1
    941  05f4		       85 76		      sta	ILPC+1
    942  05f6		       4c e9 02 	      jmp	NextIL
    943  05f9							;
    944  05f9							;=====================================================
    945  05f9							; Pop two items off stack, add them, then place the
    946  05f9							; result back onto the stack.
    947  05f9							;
    948  05f9		       20 67 0e    iADD       jsr	popR0
    949  05fc		       20 9e 0e 	      jsr	popR1
    950  05ff		       18		      clc
    951  0600		       a5 83		      lda	R0
    952  0602		       65 85		      adc	R1
    953  0604		       85 83		      sta	R0
    954  0606		       a5 84		      lda	R0+1
    955  0608		       65 86		      adc	R1+1
    956  060a		       85 84		      sta	R0+1
    957  060c		       4c 71 06 	      jmp	pushR0nextIl
    958  060f							;
    959  060f							;=====================================================
    960  060f							; Pop two items off the stack.  Subtract the top of
    961  060f							; stack from the lower entry.
    962  060f							;
    963  060f		       20 9e 0e    iSUB       jsr	popR1
    964  0612		       20 67 0e 	      jsr	popR0
    965  0615		       38		      sec
    966  0616		       a5 83		      lda	R0
    967  0618		       e5 85		      sbc	R1
    968  061a		       85 83		      sta	R0
    969  061c		       a5 84		      lda	R0+1
    970  061e		       e5 86		      sbc	R1+1
    971  0620		       85 84		      sta	R0+1
    972  0622		       4c 71 06 	      jmp	pushR0nextIl
    973  0625							;
    974  0625							;=====================================================
    975  0625							; Negate the top of stack.
    976  0625							;
    977  0625		       20 67 0e    iNEG       jsr	popR0
    978  0628		       a5 83		      lda	R0
    979  062a		       49 ff		      eor	#$ff
    980  062c		       85 83		      sta	R0
    981  062e		       a5 84		      lda	R0+1
    982  0630		       49 ff		      eor	#$ff
    983  0632		       85 84		      sta	R0+1
    984  0634		       e6 83		      inc	R0
    985  0636		       d0 02		      bne	iNEG2
    986  0638		       e6 84		      inc	R0+1
    987  063a		       4c 71 06    iNEG2      jmp	pushR0nextIl
    988  063d							;
    989  063d							;=====================================================
    990  063d							; Multiply top two items on the stack, put the results
    991  063d							; on top.  This uses the algorithm documented on page
    992  063d							; 115 of "Microprocessor Programming for Computer
    993  063d							; Hobbyists" by Neill Graham.
    994  063d							;
    995  063d		       20 67 0e    iMUL       jsr	popR0	;AC
    996  0640		       20 9e 0e 	      jsr	popR1	;OP
    997  0643							;
    998  0643		       a5 83		      lda	R0
    999  0645		       8d 9d 15 	      sta	MQ
   1000  0648		       a5 84		      lda	R0+1
   1001  064a		       8d 9e 15 	      sta	MQ+1
   1002  064d		       a9 00		      lda	#0	;clear result
   1003  064f		       85 83		      sta	R0
   1004  0651		       85 84		      sta	R0+1
   1005  0653							;
   1006  0653		       a2 10		      ldx	#16	;number of bits in value
   1007  0655		       06 83	   multloop   asl	R0
   1008  0657		       26 84		      rol	R0+1
   1009  0659		       0e 9d 15 	      asl	MQ
   1010  065c		       2e 9e 15 	      rol	MQ+1
   1011  065f		       90 0d		      bcc	multno	;skip add if no carry
   1012  0661							;
   1013  0661							; Add R1 back into R0
   1014  0661							;
   1015  0661		       18		      clc
   1016  0662		       a5 83		      lda	R0
   1017  0664		       65 85		      adc	R1
   1018  0666		       85 83		      sta	R0
   1019  0668		       a5 84		      lda	R0+1
   1020  066a		       65 86		      adc	R1+1
   1021  066c		       85 84		      sta	R0+1
   1022  066e							;
   1023  066e		       ca	   multno     dex		;did all bits yet?
   1024  066f		       d0 e4		      bne	multloop
   1025  0671							;
   1026  0671				   pushR0nextIl
   1027  0671		       20 1d 0e 	      jsr	pushR0	;OP
   1028  0674		       4c e9 02 	      jmp	NextIL
   1029  0677							;
   1030  0677							;=====================================================
   1031  0677							; Divide the top of stack into the next to top item.
   1032  0677							; Leave results on stack.  Taken from:
   1033  0677							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1034  0677							;
   1035  0677							; R0 = R0 / R1
   1036  0677							; Remainder is in MQ
   1037  0677							;
   1038  0677		       20 93 06    iDIV       jsr	iDoDiv
   1039  067a		       20 01 0f 	      jsr	RestoreSigns
   1040  067d		       4c 71 06 	      jmp	pushR0nextIl
   1041  0680
   1042  0680		       20 93 06    iMOD       jsr	iDoDiv
   1043  0683		       20 01 0f 	      jsr	RestoreSigns
   1044  0686		       ad 9d 15 	      lda	MQ
   1045  0689		       85 83		      sta	R0
   1046  068b		       ad 9e 15 	      lda	MQ+1
   1047  068e		       85 84		      sta	R0+1
   1048  0690		       4c 71 06 	      jmp	pushR0nextIl
   1049  0693
   1050  0693				   iDoDiv
   1051  0693		       20 9e 0e 	      jsr	popR1
   1052  0696		       20 67 0e 	      jsr	popR0
   1053  0699							;
   1054  0699							; Check for divide by zero
   1055  0699							;
   1056  0699
   1057  0699				   iDivNoPop
   1058  0699		       a5 85		      lda	R1
   1059  069b		       05 86		      ora	R1+1
   1060  069d		       f0 31		      beq	divby0
   1061  069f							;
   1062  069f		       20 c6 0e 	      jsr	SaveSigns
   1063  06a2		       a9 00		      lda	#0	;preset remainder to 0
   1064  06a4		       8d 9d 15 	      sta	MQ
   1065  06a7		       8d 9e 15 	      sta	MQ+1
   1066  06aa		       a2 10		      ldx	#16	;repeat for each bit: ...
   1067  06ac				   divloop
   1068  06ac		       06 83		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1069  06ae		       26 84		      rol	R0+1
   1070  06b0		       2e 9d 15 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1071  06b3		       2e 9e 15 	      rol	MQ+1
   1072  06b6		       ad 9d 15 	      lda	MQ
   1073  06b9		       38		      sec
   1074  06ba		       e5 85		      sbc	R1	;substract divisor to see if it fits in
   1075  06bc		       a8		      tay		;lb result -> Y, for we may need it later
   1076  06bd		       ad 9e 15 	      lda	MQ+1
   1077  06c0		       e5 86		      sbc	R1+1
   1078  06c2		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1079  06c4
   1080  06c4		       8d 9e 15 	      sta	MQ+1	;else save substraction result as new remainder,
   1081  06c7		       8c 9d 15 	      sty	MQ
   1082  06ca		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1083  06cc
   1084  06cc		       ca	   skip       dex
   1085  06cd		       d0 dd		      bne	divloop
   1086  06cf		       60		      rts
   1087  06d0							;
   1088  06d0							; Indicate divide-by-zero error
   1089  06d0							;
   1090  06d0		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1091  06d2		       a9 00		      lda	#0
   1092  06d4		       4c 8b 05 	      jmp	iErr2
   1093  06d7							;
   1094  06d7							;=====================================================
   1095  06d7							; This pops the top two items off the stack.  The top
   1096  06d7							; item is a data value and the other is an index into
   1097  06d7							; the variable table.	Save the value into that entry.
   1098  06d7							;
   1099  06d7		       20 67 0e    iSTORE     jsr	popR0	;data
   1100  06da		       20 9e 0e 	      jsr	popR1	;index
   1101  06dd		       a6 85		      ldx	R1	;get index
   1102  06df		       a5 83		      lda	R0
   1103  06e1		       95 41		      sta	variables,x
   1104  06e3		       a5 84		      lda	R0+1
   1105  06e5		       95 42		      sta	variables+1,x
   1106  06e7		       4c e9 02 	      jmp	NextIL
   1107  06ea							;
   1108  06ea							;=====================================================
   1109  06ea							; Replaces the top of stack with the variable whose
   1110  06ea							; index it represents.
   1111  06ea							;
   1112  06ea				   iIND
   1113  06ea		       20 9e 0e 	      jsr	popR1
   1114  06ed		       a6 85		      ldx	R1	;get index
   1115  06ef		       b5 41		      lda	variables,x
   1116  06f1		       85 83		      sta	R0
   1117  06f3		       b5 42		      lda	variables+1,x
   1118  06f5		       85 84		      sta	R0+1
   1119  06f7		       4c 71 06 	      jmp	pushR0nextIl
   1120  06fa							;
   1121  06fa							;=====================================================
   1122  06fa							; Get the array index from top of stack get Current variable
   1123  06fa							; index from next on stack, add the offset
   1124  06fa							; push the result back onto the stack
   1125  06fa				   iArray
   1126  06fa		       20 67 0e 	      jsr	popR0
   1127  06fd		       20 9e 0e 	      jsr	popR1
   1128  0700		       c6 83		      dec	R0	; Basic array index starts at 1
   1129  0702		       a5 83		      lda	R0
   1130  0704		       18		      clc
   1131  0705		       2a		      rol
   1132  0706		       65 85		      adc	R1
   1133  0708		       c9 34		      cmp	#(26*2)
   1134  070a		       b0 09		      bcs	iArrayError
   1135  070c		       85 83		      sta	R0
   1136  070e		       a5 84		      lda	R0+1
   1137  0710		       d0 03		      bne	iArrayError
   1138  0712		       4c 71 06 	      jmp	pushR0nextIl
   1139  0715							; Get here if array index is out of range
   1140  0715				   iArrayError
   1141  0715		       a9 00		      lda	#0
   1142  0717		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1143  0719		       4c 8b 05 	      jmp	iErr2
   1144  071c							;
   1145  071c							;=====================================================
   1146  071c							; List the current BASIC program in memory.  Uses R0,
   1147  071c							; tempIly, and dpl.
   1148  071c							;
   1149  071c		       20 b1 0f    iLST       jsr	SetOutConsole
   1150  071f		       a9 ae	   iLST2      lda	#ProgramStart&$ff
   1151  0721		       85 77		      sta	dpl
   1152  0723		       a9 15		      lda	#ProgramStart>>8
   1153  0725		       85 78		      sta	dpl+1
   1154  0727							;
   1155  0727							; dpl/dph point to the current line.  See if we're at
   1156  0727							; the end of the program.
   1157  0727							;
   1158  0727		       a5 77	   iLSTloop   lda	dpl
   1159  0729		       cd a6 15 	      cmp	PROGRAMEND
   1160  072c		       d0 07		      bne	iLstNotEnd
   1161  072e		       a5 78		      lda	dpl+1
   1162  0730		       cd a7 15 	      cmp	PROGRAMEND+1
   1163  0733		       f0 40		      beq	iLstdone
   1164  0735							;
   1165  0735		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1166  0737		       b1 77		      lda	(dpl),y	;line number LSB
   1167  0739		       85 83		      sta	R0
   1168  073b		       c8		      iny
   1169  073c		       b1 77		      lda	(dpl),y	;line number MSB
   1170  073e		       85 84		      sta	R0+1
   1171  0740		       c8		      iny
   1172  0741		       84 7b		      sty	tempIlY
   1173  0743		       20 b9 0c 	      jsr	PrintDecimal
   1174  0746		       a9 20		      lda	#SPACE
   1175  0748		       20 bc 0f 	      jsr	VOUTCH
   1176  074b		       a4 7b		      ldy	tempIlY
   1177  074d		       b1 77	   iLSTl2     lda	(dpl),y
   1178  074f		       f0 0a		      beq	iLST3	;end of this line 0 value
   1179  0751		       84 7b		      sty	tempIlY
   1180  0753		       20 bc 0f 	      jsr	VOUTCH
   1181  0756		       a4 7b		      ldy	tempIlY
   1182  0758		       c8		      iny
   1183  0759		       d0 f2		      bne	iLSTl2	;do next char
   1184  075b							;
   1185  075b							; End of this line.  Print CR/LF, then move to the
   1186  075b							; next line.
   1187  075b							;
   1188  075b		       c8	   iLST3      iny		;Move to next line
   1189  075c		       18		      clc		;Clear the carry flag
   1190  075d		       98		      tya		;Current Offset
   1191  075e		       65 77		      adc	dpl	;Add the offset to the pointer
   1192  0760		       85 77		      sta	dpl	;Save the new value
   1193  0762		       a5 78		      lda	dpl+1	;Next byte
   1194  0764		       69 00		      adc	#0	;ad in the carry if any
   1195  0766		       85 78		      sta	dpl+1	;Save it
   1196  0768							;
   1197  0768							; Have to manually do CR/LF so it uses the vectored
   1198  0768							; output function.
   1199  0768							;
   1200  0768		       a9 0d		      lda	#CR
   1201  076a		       20 bc 0f 	      jsr	VOUTCH
   1202  076d		       a9 0a		      lda	#LF
   1203  076f		       20 bc 0f 	      jsr	VOUTCH
   1204  0772		       4c 27 07 	      jmp	iLSTloop	;do next line
   1205  0775							;
   1206  0775		       20 b1 0f    iLstdone   jsr	SetOutConsole
   1207  0778		       4c e9 02 	      jmp	NextIL
   1208  077b							;
   1209  077b							;=====================================================
   1210  077b							; Get a line of text into LINBUF.  Terminate with a
   1211  077b							; null byte.
   1212  077b							;
   1213  077b		       a9 3e	   iGETLINE   lda	#'>	;prompt character
   1214  077d		       20 9c 0d 	      jsr	GetLine
   1215  0780							;
   1216  0780		       a9 00		      lda	#0
   1217  0782		       85 87		      sta	RunMode
   1218  0784		       4c e9 02 	      jmp	NextIL
   1219  0787							;
   1220  0787							;=====================================================
   1221  0787							; This is called when the input buffer contains a line
   1222  0787							; typed in by the user that starts with a line number.
   1223  0787							; Insert the line into the program or delete the line
   1224  0787							; if there is nothing after the line number,
   1225  0787							;
   1226  0787		       a0 00	   iINSRT     ldy	#0
   1227  0789		       20 25 0d 	      jsr	getDecimal	;convert line #
   1228  078c		       20 30 0f 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1229  078f		       84 7c		      sty	offset	;Save the start of the program line text
   1230  0791							;
   1231  0791							; Now find the line OR the next higher line OR the
   1232  0791							; end of the program.
   1233  0791							;
   1234  0791		       20 57 0c 	      jsr	findLine	; Look for the line number in the current program
   1235  0794							; Returns Z and curptr point to the line if found
   1236  0794							; Returns C and curptr at next higher line if not found and there is a higher line
   1237  0794							; Returns ZC clear and curptr to end of program if higher than all other lines
   1238  0794							;
   1239  0794							; If the line exists, it needs to be removed.
   1240  0794							;
   1241  0794		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1242  0796							;
   1243  0796							; Get length of line to be removed, we fall thru to here if we find a matching line
   1244  0796							;
   1245  0796							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1246  0796		       a0 00		      ldy	#0
   1247  0798		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1248  079a		       a8		      tay
   1249  079b							;If it is equal we delete the line and replace it, get length
   1250  079b							;then adjust all program line after up or down depending on len of line
   1251  079b							;If next higher then just move everythimg down by length bytes
   1252  079b							;This call will return how many bytes in the line we found
   1253  079b		       84 7d		      sty	lineLength	;Save the length of the line we found
   1254  079d							;
   1255  079d							; Compute the new end of the program first.
   1256  079d							;
   1257  079d		       38		      sec		;Set the carry bit
   1258  079e		       ad a6 15 	      lda	PROGRAMEND	;Get low byte of program end
   1259  07a1		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1260  07a3		       8d a6 15 	      sta	PROGRAMEND	;save it
   1261  07a6		       ad a7 15 	      lda	PROGRAMEND+1
   1262  07a9		       e9 00		      sbc	#0	;Process the carry
   1263  07ab		       8d a7 15 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1264  07ae							;
   1265  07ae							; Copy CURPTR into R1 for working
   1266  07ae							;
   1267  07ae		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1268  07b0		       85 85		      sta	R1
   1269  07b2		       a5 7f		      lda	CURPTR+1
   1270  07b4		       85 86		      sta	R1+1
   1271  07b6							;
   1272  07b6							; See if we're at the end.
   1273  07b6							;
   1274  07b6		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1275  07b8		       cd a6 15 	      cmp	PROGRAMEND
   1276  07bb		       d0 07		      bne	InsDelLoop
   1277  07bd		       a5 86		      lda	R1+1
   1278  07bf		       cd a7 15 	      cmp	PROGRAMEND+1
   1279  07c2		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1280  07c4							;
   1281  07c4							; Move one byte, move to next location.
   1282  07c4							;
   1283  07c4		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1284  07c6		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1285  07c8		       b1 85		      lda	(R1),y
   1286  07ca		       a0 00		      ldy	#0
   1287  07cc		       91 85		      sta	(R1),y
   1288  07ce		       e6 85		      inc	R1
   1289  07d0		       d0 e4		      bne	InsDelChk
   1290  07d2		       e6 86		      inc	R1+1
   1291  07d4		       4c b6 07 	      jmp	InsDelChk	; Check if we have moved the last byte
   1292  07d7							;
   1293  07d7							; Deletion is done.
   1294  07d7							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1295  07d7							;
   1296  07d7		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1297  07d9		       b9 13 15 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1298  07dc		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1299  07de							;
   1300  07de							; CURPTR points to where the line will be inserted.
   1301  07de							;
   1302  07de		       20 f9 0d 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1303  07e1							;
   1304  07e1		       ad a6 15 	      lda	PROGRAMEND	;Load the start address for the copy
   1305  07e4							;At this point curptr still contains the location we will insert data
   1306  07e4		       85 88		      sta	FROM
   1307  07e6		       ad a7 15 	      lda	PROGRAMEND+1
   1308  07e9		       85 89		      sta	FROM+1
   1309  07eb							;
   1310  07eb		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1311  07ed		       b1 88		      lda	(FROM),y
   1312  07ef		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1313  07f1		       91 88		      sta	(FROM),y	;Save the new byte
   1314  07f3							;
   1315  07f3		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1316  07f5		       c5 7e		      cmp	CURPTR
   1317  07f7		       d0 06		      bne	mvUpMore
   1318  07f9		       a5 89		      lda	FROM+1
   1319  07fb		       c5 7f		      cmp	CURPTR+1
   1320  07fd		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1321  07ff							;
   1322  07ff							; Not done yet
   1323  07ff							;
   1324  07ff		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1325  0801		       d0 02		      bne	mvUpMore2
   1326  0803		       c6 89		      dec	FROM+1
   1327  0805		       c6 88	   mvUpMore2  dec	FROM
   1328  0807		       4c eb 07 	      jmp	mvup1	;Loop until everything is moved
   1329  080a							;
   1330  080a							; All done with copy.
   1331  080a							;
   1332  080a		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1333  080b		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1334  080d		       6d a6 15 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1335  0810		       8d a6 15 	      sta	PROGRAMEND
   1336  0813		       ad a7 15 	      lda	PROGRAMEND+1
   1337  0816		       69 00		      adc	#0
   1338  0818		       8d a7 15 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1339  081b							;
   1340  081b							;===================jlit use length before line newline
   1341  081b
   1342  081b		       a0 00		      ldy	#0	;Set offset of copy
   1343  081d		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1344  081f		       91 7e		      sta	(CURPTR),y	;Store the length
   1345  0821		       c8		      iny
   1346  0822		       a5 83		      lda	R0	;Store the line number next
   1347  0824		       91 7e		      sta	(CURPTR),y
   1348  0826		       c8		      iny
   1349  0827		       a5 84		      lda	R0+1
   1350  0829		       91 7e		      sta	(CURPTR),y
   1351  082b		       c8		      iny
   1352  082c							;
   1353  082c		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1354  082e		       bd 13 15    mvUpLoop2  lda	LINBUF,x	;get a byte
   1355  0831		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1356  0833		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1357  0835		       e8		      inx
   1358  0836		       c8		      iny
   1359  0837		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1360  0839							;
   1361  0839		       4c e9 02    mvUpFini   jmp	NextIL
   1362  083c							;
   1363  083c							;=====================================================
   1364  083c							; Pops the top value of the ILPC stack and stores it
   1365  083c							; in ILPC.  Ie, return from an IL subroutine.
   1366  083c							;
   1367  083c		       20 44 0c    iRTN       jsr	popILPC
   1368  083f		       4c e9 02 	      jmp	NextIL
   1369  0842							;
   1370  0842							;=====================================================
   1371  0842							; NLINE print a newline
   1372  0842							;
   1373  0842		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1374  0845		       4c e9 02 	      jmp	NextIL
   1375  0848							;
   1376  0848							;=====================================================
   1377  0848							; This saves the current ILPC value on the stack, then
   1378  0848							; jumps to the address specified by the next two bytes.
   1379  0848							;
   1380  0848		       20 2a 0c    iCALL      jsr	pushILPC	;save ILPC
   1381  084b							;
   1382  084b							; Jmp to a specific location in the IL code.  The new
   1383  084b							; address immediately follows the opcode.
   1384  084b							;
   1385  084b		       20 10 0c    iJMP       jsr	getILWord
   1386  084e		       86 75		      stx	ILPC
   1387  0850		       85 76		      sta	ILPC+1
   1388  0852		       4c e9 02 	      jmp	NextIL
   1389  0855							;
   1390  0855							;=====================================================
   1391  0855							; Push the next two bytes onto the arithmetic stack.
   1392  0855							;
   1393  0855		       20 10 0c    iLIT       jsr	getILWord
   1394  0858		       86 83		      stx	R0
   1395  085a		       85 84		      sta	R0+1
   1396  085c		       20 1d 0e 	      jsr	pushR0
   1397  085f		       4c e9 02 	      jmp	NextIL
   1398  0862							;
   1399  0862							;=====================================================
   1400  0862							; Initialize all variables.  Ie, set to zero.
   1401  0862							;
   1402  0862		       a9 00	   iVINIT     lda	#0
   1403  0864		       a2 00		      ldx	#0
   1404  0866		       95 41	   Vinit2     sta	variables,x
   1405  0868		       e8		      inx
   1406  0869		       e0 34		      cpx	#variablesEnd-variables
   1407  086b		       d0 f9		      bne	Vinit2
   1408  086d		       4c e9 02 	      jmp	NextIL
   1409  0870							;
   1410  0870							;=====================================================
   1411  0870							; Set the address of the error handler.  After any
   1412  0870							; error, set to the ILPC to the specified location.
   1413  0870							;
   1414  0870		       20 10 0c    iERRGOTO   jsr	getILWord
   1415  0873		       8e 9b 15 	      stx	errGoto
   1416  0876		       8d 9c 15 	      sta	errGoto+1
   1417  0879		       4c e9 02 	      jmp	NextIL
   1418  087c							;
   1419  087c							;=====================================================
   1420  087c							; TST is followed by an 8 bit signed offset, then a
   1421  087c							; null terminated string.  Compare the string against
   1422  087c							; the string starting at (CURPTR),CUROFF.  If the
   1423  087c							; strings match, continue executing the next IL
   1424  087c							; opcode.  Else, add the offset to ILPC.
   1425  087c							;
   1426  087c		       20 14 0c    iTST       jsr	getILByte
   1427  087f		       85 7c		      sta	offset
   1428  0881							;
   1429  0881		       20 0b 0e 	      jsr	saveIL	;in case of failure
   1430  0884		       a4 80		      ldy	CUROFF
   1431  0886		       84 77		      sty	dpl	;save for later
   1432  0888							;
   1433  0888		       20 14 0c    iTSTloop   jsr	getILByte	;get next char
   1434  088b		       f0 11		      beq	iTSTm	;match!
   1435  088d		       a4 77		      ldy	dpl
   1436  088f		       d1 7e		      cmp	(CURPTR),y
   1437  0891		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1438  0893		       09 20		      ora	#$20	; lets allow lowercase as well
   1439  0895		       d1 7e		      cmp	(CURPTR),y
   1440  0897		       d0 22		      bne	iTSTfail	;mismatch
   1441  0899		       c8	   iTSTUpper  iny
   1442  089a		       84 77		      sty	dpl
   1443  089c		       d0 ea		      bne	iTSTloop
   1444  089e							;
   1445  089e							; It's a match!  Clean up a bit.
   1446  089e							;
   1447  089e		       a4 77	   iTSTm      ldy	dpl
   1448  08a0		       84 80		      sty	CUROFF
   1449  08a2		       4c e9 02 	      jmp	NextIL
   1450  08a5							; Test for a single quote
   1451  08a5		       20 14 0c    iTSTStr    jsr	getILByte
   1452  08a8		       85 7c		      sta	offset
   1453  08aa		       20 0b 0e 	      jsr	saveIL
   1454  08ad		       a4 80		      ldy	CUROFF
   1455  08af		       a9 22		      lda	#'"
   1456  08b1		       d1 7e		      cmp	(CURPTR),y
   1457  08b3		       d0 06		      bne	iTSTfail
   1458  08b5		       c8		      iny
   1459  08b6		       84 80		      sty	CUROFF
   1460  08b8		       4c f7 02 	      jmp	NextILStr
   1461  08bb							;
   1462  08bb							; Not a match, reset ILPC and then move to the
   1463  08bb							; offset.
   1464  08bb							;
   1465  08bb		       20 14 0e    iTSTfail   jsr	restoreIL
   1466  08be		       4c 68 09 	      jmp	tstBranch
   1467  08c1							;
   1468  08c1							;=================================================JLIT=
   1469  08c1							; Test if we have a let statement without the let keyword
   1470  08c1		       20 14 0c    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1471  08c4		       85 7c		      sta	offset	; Save the jump offset for fails
   1472  08c6		       20 0b 0e 	      jsr	saveIL	; save to restore when done
   1473  08c9		       a4 80		      ldy	CUROFF	; Get the current offset into the buffer
   1474  08cb		       20 30 0f 	      jsr	SkipSpaces	; move to first element on line
   1475  08ce		       84 80		      sty	CUROFF	; Just remember skipped spaces
   1476  08d0		       c8		      iny		; skip the Variable name
   1477  08d1		       20 30 0f 	      jsr	SkipSpaces	; skip any SkipSpaces
   1478  08d4		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1479  08d6		       c9 3d		      cmp	#'=	; check if equals
   1480  08d8		       d0 e1		      bne	iTSTfail	; return it failed
   1481  08da		       20 14 0e 	      jsr	restoreIL	; restore the IL anyway
   1482  08dd		       4c e9 02 	      jmp	NextIL	; Then next instruction
   1483  08e0
   1484  08e0							;================================================jLIT=
   1485  08e0							;Test for end of line
   1486  08e0							;
   1487  08e0		       20 14 0c    iTSTDONE   jsr	getILByte
   1488  08e3		       85 7c		      sta	offset
   1489  08e5		       20 0b 0e 	      jsr	saveIL
   1490  08e8		       a4 80		      ldy	CUROFF
   1491  08ea		       84 77		      sty	dpl
   1492  08ec		       20 30 0f 	      jsr	SkipSpaces
   1493  08ef		       b1 7e		      lda	(CURPTR),y
   1494  08f1		       f0 0b		      beq	iTSTDONEtrue
   1495  08f3		       c9 3a		      cmp	#COLON
   1496  08f5		       f0 07		      beq	iTSTDONEtrue
   1497  08f7		       a4 77		      ldy	dpl
   1498  08f9		       84 80		      sty	CUROFF
   1499  08fb		       4c bb 08 	      jmp	iTSTfail
   1500  08fe							;
   1501  08fe							; Advance to the next line
   1502  08fe							;
   1503  08fe				   iTSTDONEtrue
   1504  08fe		       4c e9 02 	      jmp	NextIL
   1505  0901							;
   1506  0901							;=====================================================
   1507  0901							; TSTV is followed by an 8 bit signed offset.	If the
   1508  0901							; value at (CURPTR),CUROFF appears to be a variable
   1509  0901							; name, move to the next IL statement.  Else, add the
   1510  0901							; offset to ILPC.
   1511  0901							;
   1512  0901		       20 14 0c    iTSTV      jsr	getILByte	;offset
   1513  0904		       85 7c		      sta	offset
   1514  0906							;
   1515  0906		       a4 80		      ldy	CUROFF
   1516  0908		       20 30 0f 	      jsr	SkipSpaces
   1517  090b		       b1 7e		      lda	(CURPTR),y
   1518  090d							;
   1519  090d		       09 20		      ora	#$20	;make lower then upper
   1520  090f		       49 20		      eor	#$20	;allow lower case here
   1521  0911		       c9 41		      cmp	#'A
   1522  0913		       90 53		      bcc	tstBranch
   1523  0915		       c9 5b		      cmp	#'Z+1
   1524  0917		       b0 4f		      bcs	tstBranch
   1525  0919							;
   1526  0919							; The condition is true, so convert to an index, push
   1527  0919							; it onto the stack and continue running.
   1528  0919							;
   1529  0919		       38		      sec
   1530  091a		       e9 41		      sbc	#'A	;index is zero based
   1531  091c		       0a		      asl		;multiply by two
   1532  091d		       85 83		      sta	R0
   1533  091f		       a9 00		      lda	#0
   1534  0921		       85 84		      sta	R0+1
   1535  0923		       20 1d 0e 	      jsr	pushR0	;put index onto stack
   1536  0926		       e6 80		      inc	CUROFF	;move to next input char
   1537  0928		       4c e9 02 	      jmp	NextIL
   1538  092b							;
   1539  092b							;=====================================================
   1540  092b							; TSTL seems basically the same as TSTN, but leave the
   1541  092b							; value in R0 instead of pushing onto stack.
   1542  092b							; This tests for a valid line number
   1543  092b							;
   1544  092b		       20 14 0c    iTSTL      jsr	getILByte
   1545  092e		       85 7c		      sta	offset
   1546  0930							;
   1547  0930		       a4 80		      ldy	CUROFF
   1548  0932		       20 30 0f 	      jsr	SkipSpaces
   1549  0935		       b1 7e		      lda	(CURPTR),y
   1550  0937							;
   1551  0937		       c9 30		      cmp	#'0
   1552  0939		       90 2d		      bcc	tstBranch
   1553  093b		       c9 3a		      cmp	#'9+1
   1554  093d		       b0 29		      bcs	tstBranch
   1555  093f							;
   1556  093f							; It's a digit, so convert to a number.
   1557  093f							;
   1558  093f		       20 25 0d 	      jsr	getDecimal
   1559  0942		       4c e9 02 	      jmp	NextIL
   1560  0945							;
   1561  0945							;=====================================================
   1562  0945							; TSTN checks for a number.  This is very simplistic;
   1563  0945							; if the character is a digit, assume it's a number.
   1564  0945							; Convert to a number and push it onto the stack.
   1565  0945							;
   1566  0945		       20 14 0c    iTSTN      jsr	getILByte
   1567  0948		       85 7c		      sta	offset
   1568  094a							;
   1569  094a		       a4 80		      ldy	CUROFF
   1570  094c		       20 30 0f 	      jsr	SkipSpaces
   1571  094f		       b1 7e		      lda	(CURPTR),y
   1572  0951		       c9 2d		      cmp	#'-	;negative?
   1573  0953		       f0 08		      beq	iTSTN_1
   1574  0955		       c9 30		      cmp	#'0
   1575  0957		       90 0f		      bcc	tstBranch
   1576  0959		       c9 3a		      cmp	#'9+1
   1577  095b		       b0 0b		      bcs	tstBranch
   1578  095d							;
   1579  095d							; It's a digit, so convert to a number.
   1580  095d							;
   1581  095d		       20 25 0d    iTSTN_1    jsr	getDecimal
   1582  0960		       84 80		      sty	CUROFF
   1583  0962		       20 1d 0e 	      jsr	pushR0	;save onto stack
   1584  0965		       4c e9 02 	      jmp	NextIL
   1585  0968
   1586  0968							;
   1587  0968							; Common jump point for all TSTx instructions that
   1588  0968							; fail to meet the requirements.  This takes the
   1589  0968							; offset and adds/subtracts to/from ILPC.
   1590  0968							;
   1591  0968		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1592  096a		       10 0e		      bpl	tstPositive
   1593  096c							;
   1594  096c							; Do negative branch.	Do sign extension.
   1595  096c							;
   1596  096c		       18		      clc
   1597  096d		       65 75		      adc	ILPC
   1598  096f		       85 75		      sta	ILPC
   1599  0971		       a5 76		      lda	ILPC+1
   1600  0973		       69 ff		      adc	#$ff
   1601  0975		       85 76		      sta	ILPC+1
   1602  0977		       4c e9 02 	      jmp	NextIL	;keep going
   1603  097a							;
   1604  097a		       18	   tstPositive clc
   1605  097b		       65 75		      adc	ILPC
   1606  097d		       85 75		      sta	ILPC
   1607  097f		       a5 76		      lda	ILPC+1
   1608  0981		       69 00		      adc	#0
   1609  0983		       85 76		      sta	ILPC+1
   1610  0985		       4c e9 02 	      jmp	NextIL
   1611  0988
   1612  0988							;
   1613  0988							;====================================================
   1614  0988							; Test for IRQ pending, and test if a break key pressed
   1615  0988							; Yes I know but this handles all sorts of irq/break issues
   1616  0988							;
   1617  0988		       20 14 0c    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1618  098b		       85 7c		      sta	offset	; Store the not true jump address offset
   1619  098d		       20 0c 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1620  0990		       d0 03		      bne	irqNo	; z not set of no break found
   1621  0992		       4c 77 05 	      jmp	iFIN	; Exit out of run mode
   1622  0995		       ad 6c 14    irqNo      lda	IRQPending
   1623  0998		       f0 ce		      beq	tstBranch
   1624  099a		       c9 01		      cmp	#1	; only do this if set to first time
   1625  099c		       d0 ca		      bne	tstBranch
   1626  099e		       78		      sei		; disable the interupt until ireturn resets it
   1627  099f		       ee 6c 14    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1628  09a2		       20 30 0e 	      jsr	pushLN	; Push the next line to be executed
   1629  09a5		       b0 11		      bcs	irqErra	; Check if there was an error
   1630  09a7		       ad 6d 14 	      lda	IRQEntry	; Get the line number to branch to
   1631  09aa		       85 7e		      sta	CURPTR	; put line number into r0
   1632  09ac		       ad 6e 14 	      lda	IRQEntry+1
   1633  09af		       85 7f		      sta	CURPTR+1
   1634  09b1		       a9 03		      lda	#3
   1635  09b3		       85 80		      sta	CUROFF
   1636  09b5		       4c e9 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1637  09b8		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1638  09ba		       a9 00		      lda	#0	; stop the execution
   1639  09bc		       4c 8b 05 	      jmp	iErr2
   1640  09bf							;
   1641  09bf							;================================================
   1642  09bf							; iTaskSwitch	 switch to new task if not interupt and
   1643  09bf							;		 count is excceded for task
   1644  09bf							;
   1645  09bf				   iTaskSwitch
   1646  09bf		       ad 6c 14 	      lda	IRQPending	; Skip this if we are processing an irq
   1647  09c2		       d0 4a		      bne	iTaskSwitchDone
   1648  09c4		       a5 8c		      lda	taskCount
   1649  09c6		       c9 01		      cmp	#1	; if there is only one task must be main
   1650  09c8		       d0 07		      bne	tasknext	; if it some other number continue to next
   1651  09ca		       ac 97 14 	      ldy	taskPtr	; check if we have not just ended some other task
   1652  09cd		       d0 02		      bne	tasknext	; if so then do a next anyway
   1653  09cf		       f0 3d		      beq	iTaskSwitchDone	; Skip this if main is only task
   1654  09d1				   tasknext
   1655  09d1		       c6 8a		      dec	taskCurrentCycles	; Dec the current cycle count
   1656  09d3		       d0 39		      bne	iTaskSwitchDone	; Skip this if we are not end of cycle
   1657  09d5		       ac 97 14 	      ldy	taskPtr
   1658  09d8		       a5 7e		      lda	CURPTR
   1659  09da		       99 70 14 	      sta	taskTable+1,y
   1660  09dd		       a5 7f		      lda	CURPTR+1
   1661  09df		       99 71 14 	      sta	taskTable+2,y
   1662  09e2		       a5 80		      lda	CUROFF
   1663  09e4		       99 72 14 	      sta	taskTable+3,y
   1664  09e7				   taskLoop
   1665  09e7		       c8		      iny
   1666  09e8		       c8		      iny
   1667  09e9		       c8		      iny
   1668  09ea		       c8		      iny
   1669  09eb		       c0 24		      cpy	#(TASKCOUNT-1)<<2
   1670  09ed		       f0 04		      beq	TaskNextChk
   1671  09ef		       90 02		      bcc	TaskNextChk
   1672  09f1		       a0 00	   TaskResetTop ldy	#0
   1673  09f3				   TaskNextChk
   1674  09f3		       b9 6f 14 	      lda	taskTable,y	; there is always at least one entry in table
   1675  09f6		       f0 ef		      beq	taskLoop	; get next slot if this one empty
   1676  09f8		       b9 70 14 	      lda	taskTable+1,y
   1677  09fb		       85 7e		      sta	CURPTR
   1678  09fd		       b9 71 14 	      lda	taskTable+2,y
   1679  0a00		       85 7f		      sta	CURPTR+1
   1680  0a02		       b9 72 14 	      lda	taskTable+3,y
   1681  0a05		       85 80		      sta	CUROFF
   1682  0a07		       8c 97 14 	      sty	taskPtr
   1683  0a0a		       a5 8b		      lda	taskResetValue
   1684  0a0c		       85 8a		      sta	taskCurrentCycles
   1685  0a0e				   iTaskSwitchDone
   1686  0a0e		       4c e9 02 	      jmp	NextIL
   1687  0a11							;
   1688  0a11							;=====================================================
   1689  0a11							; This places the number of free bytes on top of the
   1690  0a11							; stack.
   1691  0a11							;
   1692  0a11		       20 7e 0f    iFREE      jsr	GetSizes
   1693  0a14		       20 1d 0e 	      jsr	pushR0
   1694  0a17		       4c e9 02 	      jmp	NextIL
   1695  0a1a							;
   1696  0a1a							;=====================================================
   1697  0a1a							; Generate a random number from 0-FFFF and then MOD
   1698  0a1a							; it with the value on top of stack.  Leaves number on
   1699  0a1a							; stack
   1700  0a1a							;
   1701  0a1a		       20 9e 0e    iRANDOM    jsr	popR1	;mod value
   1702  0a1d							;
   1703  0a1d							; If the value is zero, just return a one.
   1704  0a1d							;
   1705  0a1d		       a5 85		      lda	R1
   1706  0a1f		       05 86		      ora	R1+1
   1707  0a21		       f0 4c		      beq	irandom1
   1708  0a23							;
   1709  0a23		       ad a2 15 	      lda	random+1
   1710  0a26		       8d a0 15 	      sta	rtemp1
   1711  0a29		       ad a1 15 	      lda	random
   1712  0a2c		       0a		      asl
   1713  0a2d		       2e a0 15 	      rol	rtemp1
   1714  0a30		       0a		      asl
   1715  0a31		       2e a0 15 	      rol	rtemp1
   1716  0a34		       18		      clc
   1717  0a35		       6d a1 15 	      adc	random
   1718  0a38		       48		      pha
   1719  0a39		       ad a0 15 	      lda	rtemp1
   1720  0a3c		       6d a2 15 	      adc	random+1
   1721  0a3f		       8d a2 15 	      sta	random+1
   1722  0a42		       68		      pla
   1723  0a43		       69 11		      adc	#$11
   1724  0a45		       8d a1 15 	      sta	random
   1725  0a48		       ad a2 15 	      lda	random+1
   1726  0a4b		       69 36		      adc	#$36
   1727  0a4d		       8d a2 15 	      sta	random+1
   1728  0a50
   1729  0a50		       ad a1 15 	      lda	random
   1730  0a53		       85 83		      sta	R0
   1731  0a55		       ad a2 15 	      lda	random+1
   1732  0a58		       29 7f		      and	#$7f	;make positive
   1733  0a5a		       85 84		      sta	R0+1
   1734  0a5c							;
   1735  0a5c							; R0 contains the number and R1 contains the max value.
   1736  0a5c							;
   1737  0a5c		       20 99 06 	      jsr	iDivNoPop
   1738  0a5f		       20 01 0f 	      jsr	RestoreSigns
   1739  0a62		       ad 9d 15 	      lda	MQ
   1740  0a65		       85 83		      sta	R0
   1741  0a67		       ad 9e 15 	      lda	MQ+1
   1742  0a6a		       85 84		      sta	R0+1
   1743  0a6c		       4c 71 06 	      jmp	pushR0nextIl
   1744  0a6f				   irandom1
   1745  0a6f		       a9 00		      lda	#0
   1746  0a71		       85 84		      sta	R0+1
   1747  0a73		       a9 01		      lda	#1
   1748  0a75		       85 83		      sta	R0
   1749  0a77		       4c 71 06 	      jmp	pushR0nextIl
   1750  0a7a
   1751  0a7a							; The following replaced by call to division/modulo
   1752  0a7a							;iRANDOM_2	lda	R0
   1753  0a7a							;		cmp	R1
   1754  0a7a							;		bne	iRANDOM_1
   1755  0a7a							;		lda	R0+1
   1756  0a7a							;		cmp	R1+1
   1757  0a7a							;		bne	iRANDOM_1	;need to subtract
   1758  0a7a							;
   1759  0a7a							; Subtract R1 from R0
   1760  0a7a							;
   1761  0a7a							;iRANDOM_sub	sec
   1762  0a7a							;		lda	R0
   1763  0a7a							;		sbc	R1
   1764  0a7a							;		sta	R0
   1765  0a7a							;		lda	R0+1
   1766  0a7a							;		sbc	R1+1
   1767  0a7a							;		sta	R0+1
   1768  0a7a							;		jmp	iRANDOM_2
   1769  0a7a							;
   1770  0a7a							; See if R1 > R0.  If so, branch to subtract.
   1771  0a7a							;
   1772  0a7a							;iRANDOM_1	lda	R0
   1773  0a7a							;		cmp	R1
   1774  0a7a							;		lda	R0+1
   1775  0a7a							;		sbc	R1+1
   1776  0a7a							;		bvc	iRANDOM_4
   1777  0a7a							;		eor	#$80
   1778  0a7a							;iRANDOM_4	bpl	iRANDOM_sub
   1779  0a7a							;
   1780  0a7a							; All done.  Almost.  Add one, then push the result.
   1781  0a7a							;
   1782  0a7a							;irandom1	inc	R0
   1783  0a7a							;		bne	iRANDOM_3
   1784  0a7a							;		inc	R0+1
   1785  0a7a							;iRANDOM_3
   1786  0a7a							;		  jsr	pushR0	;return value
   1787  0a7a							;		jmp	NextIL
   1788  0a7a							;
   1789  0a7a							; Poke a value into a memory location
   1790  0a7a		       8c a5 15    iPOKEMEMORY sty	tempy
   1791  0a7d		       20 67 0e 	      jsr	popR0
   1792  0a80		       20 9e 0e 	      jsr	popR1
   1793  0a83		       a0 00		      ldy	#0
   1794  0a85		       a5 83		      lda	R0
   1795  0a87		       91 85		      sta	(R1),y
   1796  0a89		       ac a5 15 	      ldy	tempy
   1797  0a8c		       4c e9 02 	      jmp	NextIL
   1798  0a8f							;
   1799  0a8f							; Get a value from a memory location
   1800  0a8f							;
   1801  0a8f		       8c a5 15    iPEEKMEMORY sty	tempy
   1802  0a92		       20 67 0e 	      jsr	popR0
   1803  0a95		       a0 00		      ldy	#0
   1804  0a97		       b1 83		      lda	(R0),y
   1805  0a99		       ac a5 15 	      ldy	tempy
   1806  0a9c		       85 83		      sta	R0
   1807  0a9e		       a9 00		      lda	#0
   1808  0aa0		       85 84		      sta	R0+1
   1809  0aa2		       4c 71 06 	      jmp	pushR0nextIl
   1810  0aa5							;
   1811  0aa5							; Call to address return what ever is in a to the stack
   1812  0aa5							; func2 will load a value into a before the call
   1813  0aa5		       20 9e 0e    iCallFunc  jsr	popR1
   1814  0aa8		       a5 85		      lda	R1
   1815  0aaa		       20 b6 0a 	      jsr	iCallRtn
   1816  0aad		       85 83		      sta	R0
   1817  0aaf		       a9 00		      lda	#0
   1818  0ab1		       85 84		      sta	R0+1
   1819  0ab3		       20 71 06 	      jsr	pushR0nextIl
   1820  0ab6				   iCallRtn
   1821  0ab6		       20 67 0e 	      jsr	popR0
   1822  0ab9		       6c 83 00 	      jmp	(R0)
   1823  0abc
   1824  0abc
   1825  0abc							;===========================================jlit======
   1826  0abc							;Get a character from the terminal convert to value
   1827  0abc							;leave the number on top of the stack
   1828  0abc							;
   1829  0abc				   iGETCHAR
   1830  0abc		       20 30 0e 	      jsr	pushLN	;Save state befor getline
   1831  0abf		       20 09 02 	      jsr	GETCH
   1832  0ac2					      if	CTMON65
   1833  0ac2		       48		      pha
   1834  0ac3		       20 0c f0 	      jsr	cout	;echo echo echo
   1835  0ac6		       68		      pla
   1836  0ac7					      endif
   1837  0ac7		       85 83		      sta	R0
   1838  0ac9		       a9 00		      lda	#0
   1839  0acb		       85 84		      sta	R0+1
   1840  0acd		       20 1d 0e 	      jsr	pushR0
   1841  0ad0							;
   1842  0ad0		       20 7a 0e 	      jsr	popLN
   1843  0ad3		       4c e9 02 	      jmp	NextIL
   1844  0ad6							;===========================================jlit======
   1845  0ad6							;Put a character to the terminal convert to
   1846  0ad6							;
   1847  0ad6		       20 67 0e    iPUTCHAR   jsr	popR0
   1848  0ad9		       a5 83		      lda	R0
   1849  0adb		       20 06 02 	      jsr	OUTCH
   1850  0ade		       4c e9 02 	      jmp	NextIL
   1851  0ae1							;=====================================================
   1852  0ae1							; Put the number on the stack out as hex, suppress leading 0
   1853  0ae1				   iHexOut
   1854  0ae1		       20 67 0e 	      jsr	popR0
   1855  0ae4		       a5 84		      lda	R0+1
   1856  0ae6		       f0 03		      beq	iHexSecondByte
   1857  0ae8		       20 0f 02 	      jsr	OUTHEX
   1858  0aeb				   iHexSecondByte
   1859  0aeb		       a5 83		      lda	R0
   1860  0aed		       20 0f 02 	      jsr	OUTHEX
   1861  0af0		       4c e9 02 	      jmp	NextIL
   1862  0af3							;
   1863  0af3							;=====================================================
   1864  0af3							; Replace TOS with its absolute value.
   1865  0af3							;
   1866  0af3		       20 67 0e    iABS       jsr	popR0
   1867  0af6		       a5 84		      lda	R0+1
   1868  0af8		       10 10		      bpl	iABS_1	;already positive
   1869  0afa		       49 ff		      eor	#$ff
   1870  0afc		       85 84		      sta	R0+1
   1871  0afe		       a5 83		      lda	R0
   1872  0b00		       49 ff		      eor	#$ff
   1873  0b02		       85 83		      sta	R0
   1874  0b04		       e6 83		      inc	R0
   1875  0b06		       d0 02		      bne	iABS_1
   1876  0b08		       e6 84		      inc	R0+1
   1877  0b0a		       4c 71 06    iABS_1     jmp	pushR0nextIl
   1878  0b0d
   1879  0b0d							;================================================================
   1880  0b0d							;Set the IRQ service rtn line number
   1881  0b0d							;
   1882  0b0d		       78	   iSetIrq    sei		; disable the interupts
   1883  0b0e		       a9 00		      lda	#0	; Zero the Status flag
   1884  0b10		       8d 6b 14 	      sta	IRQStatus
   1885  0b13		       20 67 0e 	      jsr	popR0	; get the line number
   1886  0b16		       a5 83		      lda	R0
   1887  0b18		       05 84		      ora	R0+1
   1888  0b1a		       f0 1b		      beq	iSetExt	; if it is zero disable all
   1889  0b1c		       20 30 0e 	      jsr	pushLN	; Save the current line pointer
   1890  0b1f		       20 57 0c 	      jsr	findLine	; Find the IRQ func Line Pointer
   1891  0b22		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   1892  0b24		       a5 7f		      lda	CURPTR+1	; Copy it to the Entry pointer
   1893  0b26		       8d 6e 14 	      sta	IRQEntry+1
   1894  0b29		       a5 7e		      lda	CURPTR
   1895  0b2b		       8d 6d 14 	      sta	IRQEntry
   1896  0b2e		       a9 01		      lda	#1	; Indicate there is an irq gosub
   1897  0b30		       8d 6b 14 	      sta	IRQStatus
   1898  0b33		       20 7a 0e 	      jsr	popLN	; Restore the old line number
   1899  0b36		       58		      cli		; Enable the interupts
   1900  0b37		       4c e9 02    iSetExt    jmp	NextIL
   1901  0b3a
   1902  0b3a		       20 7a 0e    iSetIrqErr jsr	popLN
   1903  0b3d		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   1904  0b3f		       a9 00		      lda	#0
   1905  0b41		       4c 8b 05 	      jmp	iErr2
   1906  0b44							;
   1907  0b44							;================================================================
   1908  0b44							; Task Set task number to line number to start
   1909  0b44							; Task Table structure:
   1910  0b44							;    byte 0	-   Active inactive 0 or 1
   1911  0b44							;    byte 1-2	-   Basic code line pointer
   1912  0b44							;    byte 3	-   Offset on current line
   1913  0b44		       98	   iTaskSet   tya
   1914  0b45		       48		      pha
   1915  0b46		       20 30 0e 	      jsr	pushLN	; Store the current line number
   1916  0b49		       20 67 0e 	      jsr	popR0	; Get the line number to be saved
   1917  0b4c		       a5 83		      lda	R0
   1918  0b4e		       05 84		      ora	R0+1
   1919  0b50		       f0 44		      beq	iTaskRetCurrent
   1920  0b52		       20 57 0c 	      jsr	findLine	; Get the offset of the line to start task at
   1921  0b55		       f0 05		      beq	iTaskCont
   1922  0b57		       68		      pla
   1923  0b58		       a8		      tay
   1924  0b59		       4c 3a 0b 	      jmp	iSetIrqErr	; Bad line number provided
   1925  0b5c				   iTaskCont
   1926  0b5c		       20 f9 0b 	      jsr	TaskEmpty	; Find an empty slot
   1927  0b5f		       f0 29		      beq	iTaskNoEmpty	; There are no more empty slots
   1928  0b61		       e6 8c		      inc	taskCount	; Update the number of Tasks running
   1929  0b63		       a9 01		      lda	#1
   1930  0b65		       99 6f 14 	      sta	taskTable,y	; Mark as busy/used
   1931  0b68		       a5 7e		      lda	CURPTR
   1932  0b6a		       99 70 14 	      sta	taskTable+1,y
   1933  0b6d		       a5 7f		      lda	CURPTR+1
   1934  0b6f		       99 71 14 	      sta	taskTable+2,y
   1935  0b72		       a9 03		      lda	#3	; Offset to first instruction
   1936  0b74		       99 72 14 	      sta	taskTable+3,y
   1937  0b77		       e6 8c		      inc	taskCount
   1938  0b79				   iTaskGetCurrent
   1939  0b79		       20 7a 0e 	      jsr	popLN
   1940  0b7c		       98		      tya
   1941  0b7d		       4a		      lsr
   1942  0b7e		       4a		      lsr
   1943  0b7f		       85 83		      sta	R0	;Get the table entry value
   1944  0b81		       a9 00		      lda	#0
   1945  0b83		       85 84		      sta	R0+1
   1946  0b85		       68		      pla
   1947  0b86		       a8		      tay
   1948  0b87		       4c 71 06 	      jmp	pushR0nextIl
   1949  0b8a				   iTaskNoEmpty
   1950  0b8a		       20 7a 0e 	      jsr	popLN
   1951  0b8d		       68		      pla
   1952  0b8e		       a8		      tay
   1953  0b8f		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
   1954  0b91		       a9 00		      lda	#0
   1955  0b93		       4c 8b 05 	      jmp	iErr2
   1956  0b96				   iTaskRetCurrent		;Get if task number is zero Current task
   1957  0b96		       ac 97 14 	      ldy	taskPtr
   1958  0b99		       d0 de		      bne	iTaskGetCurrent
   1959  0b9b							;
   1960  0b9b							;================================================================
   1961  0b9b							; Returns task Status
   1962  0b9b				   iTaskStat
   1963  0b9b		       20 aa 0b 	      jsr	iTaskValid
   1964  0b9e		       a9 00		      lda	#0
   1965  0ba0		       85 84		      sta	R0+1
   1966  0ba2		       b9 6f 14 	      lda	taskTable,y
   1967  0ba5		       85 83		      sta	R0
   1968  0ba7		       4c 71 06 	      jmp	pushR0nextIl
   1969  0baa							;
   1970  0baa							;================================================================
   1971  0baa							; Validate the task number on top of the stack
   1972  0baa		       20 67 0e    iTaskValid jsr	popR0
   1973  0bad		       a5 84		      lda	R0+1
   1974  0baf		       d0 0d		      bne	iTaskValidErr
   1975  0bb1		       a5 83		      lda	R0
   1976  0bb3		       c9 00		      cmp	#0
   1977  0bb5		       f0 07		      beq	iTaskValidErr
   1978  0bb7		       18		      clc
   1979  0bb8		       2a		      rol
   1980  0bb9		       2a		      rol
   1981  0bba		       c9 28		      cmp	#TASKCOUNT<<2
   1982  0bbc		       90 09		      bcc	iTaskIsValid
   1983  0bbe
   1984  0bbe		       68	   iTaskValidErr pla		;remove return address
   1985  0bbf		       68		      pla
   1986  0bc0		       a2 10		      ldx	#ERR_INVALID_PID
   1987  0bc2		       a9 00		      lda	#0
   1988  0bc4		       4c 8b 05 	      jmp	iErr2
   1989  0bc7
   1990  0bc7		       a8	   iTaskIsValid tay
   1991  0bc8		       60		      rts
   1992  0bc9							;
   1993  0bc9							;================================================================
   1994  0bc9							; Kill a running task, do nothing if already stopped
   1995  0bc9		       20 aa 0b    iTaskKill  jsr	iTaskValid
   1996  0bcc		       a9 00		      lda	#0
   1997  0bce		       99 6f 14 	      sta	taskTable,y	; Fall thru to go to next task
   1998  0bd1							;
   1999  0bd1							;================================================================
   2000  0bd1							;Skip to next task
   2001  0bd1				   iNTask
   2002  0bd1		       a9 01		      lda	#1
   2003  0bd3		       85 8a		      sta	taskCurrentCycles
   2004  0bd5		       4c e9 02 	      jmp	NextIL
   2005  0bd8							;
   2006  0bd8							;================================================================
   2007  0bd8							; Terminate a task
   2008  0bd8		       ac 97 14    iETask     ldy	taskPtr
   2009  0bdb		       c0 00		      cpy	#0
   2010  0bdd		       d0 03		      bne	iETaskCont
   2011  0bdf		       4c 77 05 	      jmp	iFIN	; if the main task does a ETASK then stop
   2012  0be2				   iETaskCont
   2013  0be2		       a9 00		      lda	#0
   2014  0be4		       99 6f 14 	      sta	taskTable,y	; mark entry as free
   2015  0be7		       99 70 14 	      sta	taskTable+1,y	; Clear the entry in the table
   2016  0bea		       99 71 14 	      sta	taskTable+2,y
   2017  0bed		       99 72 14 	      sta	taskTable+3,y
   2018  0bf0		       c6 8c		      dec	taskCount	; reduce the number of active tasks
   2019  0bf2		       85 8a		      sta	taskCurrentCycles	; Set to zero
   2020  0bf4		       e6 8a		      inc	taskCurrentCycles	; Make it 1 as rtn will dec and check
   2021  0bf6				   iETaskExit
   2022  0bf6		       4c e9 02 	      jmp	NextIL
   2023  0bf9
   2024  0bf9							;
   2025  0bf9							;================================================================
   2026  0bf9							;Find an empty slot in the taskTable
   2027  0bf9							;Return the index in y
   2028  0bf9							;================================================================
   2029  0bf9							;
   2030  0bf9				   TaskEmpty
   2031  0bf9		       a0 04		      ldy	#4	;The first slot is always the main line
   2032  0bfb				   TaskLoop
   2033  0bfb		       b9 6f 14 	      lda	taskTable,y
   2034  0bfe		       f0 0d		      beq	TaskEmptyFnd
   2035  0c00		       c8		      iny
   2036  0c01		       c8		      iny
   2037  0c02		       c8		      iny
   2038  0c03		       c8		      iny
   2039  0c04		       c0 28		      cpy	#TASKCOUNT<<2	; Task
   2040  0c06		       f0 02		      beq	TaskNoSlot	; No Empty Slots
   2041  0c08		       90 f1		      bcc	TaskLoop	; Y is never zero
   2042  0c0a				   TaskNoSlot
   2043  0c0a		       a9 00		      lda	#0	; Z set if not found
   2044  0c0c		       60		      rts
   2045  0c0d				   TaskEmptyFnd
   2046  0c0d		       a9 01		      lda	#1
   2047  0c0f		       60		      rts
   2048  0c10							;
   2049  0c10							;=================================================================
   2050  0c10							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0c10					      include	"support.asm"
      1  0c10							;
      2  0c10							;=====================================================
      3  0c10							;=====================================================
      4  0c10							;=====================================================
      5  0c10							; This marks the start of support functions used by
      6  0c10							; the IL opcodes.  These are support functions, NOT
      7  0c10							; the IL code.
      8  0c10							;=====================================================
      9  0c10		       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting
     10  0c10							;=====================================================
     11  0c10					      Seg	Code
     12  0c10							;=====================================================
     13  0c10							; This gets the next two bytes pointed to by ILPC and
     14  0c10							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0c10							; is advanced by two, and Y contains 0 on return.
     16  0c10
     17  0c10							;
     18  0c10		       20 14 0c    getILWord  jsr	getILByte	;LSB
     19  0c13		       aa		      tax
     20  0c14							;
     21  0c14							;=====================================================
     22  0c14							; This gets the next byte pointed to by ILPC and
     23  0c14							; returns it in A.  On return, X is unchanged but Y
     24  0c14							; contains 0.
     25  0c14							;
     26  0c14		       a0 00	   getILByte  ldy	#0
     27  0c16		       b1 75		      lda	(ILPC),y	;get byte
     28  0c18		       08		      php		;save status
     29  0c19		       e6 75		      inc	ILPC	;inc LSB
     30  0c1b		       d0 02		      bne	getILb2	;branch if no overflow
     31  0c1d		       e6 76		      inc	ILPC+1	;inc MSB
     32  0c1f		       28	   getILb2    plp		;restore status
     33  0c20		       60		      rts
     34  0c21							;
     35  0c21							;=====================================================
     36  0c21							; Decrement ILPC by one.
     37  0c21							;
     38  0c21		       a5 75	   decIL      lda	ILPC
     39  0c23		       d0 02		      bne	decIL2
     40  0c25		       c6 76		      dec	ILPC+1
     41  0c27		       c6 75	   decIL2     dec	ILPC
     42  0c29		       60		      rts
     43  0c2a							;
     44  0c2a							;=====================================================
     45  0c2a							; Push the ILPC onto the return stack.  Actually, this
     46  0c2a							; pushes the address of ILPC+2 since that's the next
     47  0c2a							; address to execute.
     48  0c2a							;
     49  0c2a		       ac 11 15    pushILPC   ldy	retStackPtr
     50  0c2d		       a5 75		      lda	ILPC
     51  0c2f		       18		      clc
     52  0c30		       69 02		      adc	#2
     53  0c32		       99 c1 14 	      sta	retStack,y
     54  0c35		       08		      php		;save C bit
     55  0c36		       c8		      iny
     56  0c37		       a5 76		      lda	ILPC+1
     57  0c39		       28		      plp		;restore C
     58  0c3a		       69 00		      adc	#0
     59  0c3c		       99 c1 14 	      sta	retStack,y
     60  0c3f		       c8		      iny
     61  0c40		       8c 11 15 	      sty	retStackPtr
     62  0c43		       60		      rts
     63  0c44							;
     64  0c44							;=====================================================
     65  0c44							; Pull the top entry from return stack and put into
     66  0c44							; ILPC.
     67  0c44							;
     68  0c44		       ac 11 15    popILPC    ldy	retStackPtr
     69  0c47		       88		      dey
     70  0c48		       b9 c1 14 	      lda	retStack,y
     71  0c4b		       85 76		      sta	ILPC+1
     72  0c4d		       88		      dey
     73  0c4e		       b9 c1 14 	      lda	retStack,y
     74  0c51		       85 75		      sta	ILPC
     75  0c53		       8c 11 15 	      sty	retStackPtr
     76  0c56		       60		      rts
     77  0c57							;
     78  0c57							;=====================================================
     79  0c57							; This searches for a specific line number that is in
     80  0c57							; R0.	There are three possible return conditions:
     81  0c57							; Line numbers are now the third byte, the first byte is now **************
     82  0c57							; a pointer to the next line, of course no longer that 53 byte
     83  0c57							; per line.
     84  0c57							;
     85  0c57							; Exact match was found:
     86  0c57							;    * Z set
     87  0c57							;    * CURPTR points to two-byte line number for that
     88  0c57							;	line.
     89  0c57							;
     90  0c57							; Next highest line found:
     91  0c57							;    * Z cleared
     92  0c57							;    * C set
     93  0c57							;    * CURPTR points to two-byte line number for that
     94  0c57							;	line.
     95  0c57							;
     96  0c57							; End of program reached:
     97  0c57							;    * Z cleared
     98  0c57							;    * C cleared
     99  0c57							;    * CURPTR points to first free byte at end of
    100  0c57							;	program.  Ie, it has save value as PROGRAMEND.
    101  0c57							;
    102  0c57							; A, X, and Y are all undefined on return.
    103  0c57							;
    104  0c57
    105  0c57				   findLine
    106  0c57		       a9 ae		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    107  0c59		       85 7e		      sta	CURPTR
    108  0c5b		       a9 15		      lda	#ProgramStart>>8
    109  0c5d		       85 7f		      sta	CURPTR+1
    110  0c5f							;
    111  0c5f							; At end of code?
    112  0c5f							;
    113  0c5f				   iXFER1
    114  0c5f		       a5 7e		      lda	CURPTR	; chk CURPTR = END PROGRAM
    115  0c61		       cd a6 15 	      cmp	PROGRAMEND	; at end of program then stop run
    116  0c64		       d0 0b		      bne	xfer2	; not end
    117  0c66		       a5 7f		      lda	CURPTR+1
    118  0c68		       cd a7 15 	      cmp	PROGRAMEND+1
    119  0c6b		       d0 04		      bne	xfer2	;Not at end
    120  0c6d							;
    121  0c6d							; Line not found and the end of the program was
    122  0c6d							; reached.  Return Z and C both clear.
    123  0c6d							;
    124  0c6d		       a9 01		      lda	#1	;clear Z
    125  0c6f		       18		      clc		;clear C
    126  0c70		       60		      rts
    127  0c71							;
    128  0c71							; Check for an exact line number match
    129  0c71							;
    130  0c71		       a5 83	   xfer2      lda	R0
    131  0c73		       a0 01		      ldy	#1	; changed to skip extra length byte
    132  0c75		       d1 7e		      cmp	(CURPTR),y
    133  0c77		       d0 08		      bne	xfernotit
    134  0c79		       c8		      iny
    135  0c7a		       a5 84		      lda	R0+1
    136  0c7c		       d1 7e		      cmp	(CURPTR),y
    137  0c7e		       d0 01		      bne	xfernotit	; not a matching line number
    138  0c80							;
    139  0c80							; This is exactly the line we want.
    140  0c80							;
    141  0c80		       60		      rts		;it matches exactly
    142  0c81							;
    143  0c81							; See if this line is greater than the one we're
    144  0c81							; searching for.
    145  0c81							;
    146  0c81		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    147  0c83		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    148  0c85		       c5 84		      cmp	R0+1
    149  0c87		       90 0b		      bcc	xfer3
    150  0c89		       d0 07		      bne	xfer4
    151  0c8b		       88		      dey
    152  0c8c		       b1 7e		      lda	(CURPTR),y	;compare LSB
    153  0c8e		       c5 83		      cmp	R0
    154  0c90		       90 02		      bcc	xfer3
    155  0c92							;
    156  0c92							; This line is greater than the one we want, so
    157  0c92							; return Z clear and C set.
    158  0c92							;
    159  0c92		       38	   xfer4      sec		;We found a line number greater
    160  0c93		       60		      rts		;both conditions set
    161  0c94							;
    162  0c94							; Not the line (or droid) we're looking for.  Move to
    163  0c94							; the next line.
    164  0c94							;
    165  0c94		       20 9a 0c    xfer3      jsr	FindNextLine
    166  0c97		       4c 5f 0c 	      jmp	iXFER1
    167  0c9a							;
    168  0c9a							;=====================================================
    169  0c9a							; This advances CURPTR to the next line.  If there
    170  0c9a							; are no more lines, this leaves CURPTR equal to
    171  0c9a							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    172  0c9a							; CURPTR is pointing to a valid line on entry.  This
    173  0c9a							; pointer points to the two-byte line number.
    174  0c9a							; Update this points to the 1 byte line length  ****************
    175  0c9a							;
    176  0c9a				   FindNextLine
    177  0c9a		       a0 03		      ldy	#3	;skip line number and length byte
    178  0c9c		       84 80		      sty	CUROFF	;this is the new offset
    179  0c9e		       a0 00		      ldy	#0
    180  0ca0		       b1 7e		      lda	(CURPTR),y	;Get the length
    181  0ca2		       18		      clc
    182  0ca3		       65 7e		      adc	CURPTR
    183  0ca5		       85 7e		      sta	CURPTR
    184  0ca7		       90 02		      bcc	FindNext4	;exit
    185  0ca9		       e6 7f		      inc	CURPTR+1
    186  0cab		       60	   FindNext4  rts
    187  0cac							;
    188  0cac							;=====================================================
    189  0cac							; This compares CURPTR to PROGRAMEND and returns Z set
    190  0cac							; if they are equal, Z clear if not.
    191  0cac							;
    192  0cac		       a5 7e	   AtEnd      lda	CURPTR
    193  0cae		       cd a6 15 	      cmp	PROGRAMEND
    194  0cb1		       d0 05		      bne	atendexit
    195  0cb3		       a5 7f		      lda	CURPTR+1
    196  0cb5		       cd a7 15 	      cmp	PROGRAMEND+1
    197  0cb8		       60	   atendexit  rts
    198  0cb9							;
    199  0cb9							;=====================================================
    200  0cb9							; Print the contents of R0 as a signed decimal number.
    201  0cb9							; Does leading zero suppression.
    202  0cb9							;
    203  0cb9				   PrintDecimal
    204  0cb9		       a5 84		      lda	R0+1	;MSB has sign
    205  0cbb		       10 17		      bpl	pplus	;it's a positive number
    206  0cbd							;
    207  0cbd							; Negative numbers need more work.  Invert all the bits,
    208  0cbd							; then add one.
    209  0cbd							;
    210  0cbd		       a9 2d		      lda	#'-
    211  0cbf		       20 bc 0f 	      jsr	VOUTCH	;print the negative sign
    212  0cc2							;
    213  0cc2		       a5 83		      lda	R0	;invert bits
    214  0cc4		       49 ff		      eor	#$ff
    215  0cc6		       85 83		      sta	R0
    216  0cc8		       a5 84		      lda	R0+1
    217  0cca		       49 ff		      eor	#$ff
    218  0ccc		       85 84		      sta	R0+1
    219  0cce		       e6 83		      inc	R0	;add one
    220  0cd0		       d0 02		      bne	pplus
    221  0cd2		       e6 84		      inc	R0+1
    222  0cd4							;
    223  0cd4							; Print the value in R0 as a positive number.
    224  0cd4							;
    225  0cd4		       a2 00	   pplus      ldx	#0	;start of subtraction table
    226  0cd6		       8e 99 15 	      stx	diddigit	;no digits yet
    227  0cd9		       a0 00	   pploop     ldy	#0	;result of division
    228  0cdb		       a5 83	   pploop2    lda	R0	;LSB
    229  0cdd		       38		      sec
    230  0cde		       fd 1d 0d 	      sbc	dectable,x
    231  0ce1		       85 83		      sta	R0
    232  0ce3		       a5 84		      lda	R0+1
    233  0ce5		       fd 1e 0d 	      sbc	dectable+1,x
    234  0ce8		       10 2e		      bpl	pplusok	;no underflow
    235  0cea							;
    236  0cea							; Else, underflow.  Add back in the LSB of the
    237  0cea							; table to R0.
    238  0cea							;
    239  0cea		       18		      clc
    240  0ceb		       a5 83		      lda	R0
    241  0ced		       7d 1d 0d 	      adc	dectable,x
    242  0cf0		       85 83		      sta	R0
    243  0cf2							;
    244  0cf2							; Print the value in Y.  Actually, see if Y is zero and
    245  0cf2							; whether any digit has been printed yet.  If Y isn't
    246  0cf2							; zero or we've printed a digit, go ahead and print.
    247  0cf2							;
    248  0cf2		       8e 98 15 	      stx	printtx
    249  0cf5		       98		      tya
    250  0cf6		       09 00		      ora	#0	;set flags
    251  0cf8		       d0 05		      bne	pprintit	;non-zero, print
    252  0cfa							;
    253  0cfa		       ad 99 15 	      lda	diddigit
    254  0cfd		       f0 09		      beq	pprintno	;don't print
    255  0cff							;
    256  0cff		       98	   pprintit   tya
    257  0d00		       09 30		      ora	#'0
    258  0d02		       8d 99 15 	      sta	diddigit
    259  0d05		       20 bc 0f 	      jsr	VOUTCH
    260  0d08		       ae 98 15    pprintno   ldx	printtx
    261  0d0b							;
    262  0d0b							; Move to the next table entry
    263  0d0b							;
    264  0d0b		       e8		      inx
    265  0d0c		       e8		      inx
    266  0d0d		       e0 08		      cpx	#dectableend-dectable
    267  0d0f		       d0 c8		      bne	pploop	;not at end
    268  0d11							;
    269  0d11							; At the end.	R0 contains the final value
    270  0d11							; to print.
    271  0d11							;
    272  0d11		       a5 83		      lda	R0
    273  0d13		       09 30		      ora	#'0
    274  0d15		       4c bc 0f 	      jmp	VOUTCH
    275  0d18							;
    276  0d18							; Finish doing the subtraction.
    277  0d18							;
    278  0d18		       85 84	   pplusok    sta	R0+1
    279  0d1a		       c8		      iny
    280  0d1b		       d0 be		      bne	pploop2
    281  0d1d							;
    282  0d1d							; Table of powers-of-ten
    283  0d1d							;
      0  0d1d				   dectable   dw	10000
      1  0d1d		       10 27		      .word.w	10000
      0  0d1f					      dw	1000
      1  0d1f		       e8 03		      .word.w	1000
      0  0d21					      dw	100
      1  0d21		       64 00		      .word.w	100
      0  0d23					      dw	10
      1  0d23		       0a 00		      .word.w	10
    288  0d23		       0d 25	   dectableend equ	*
    289  0d25							;
    290  0d25							;=====================================================
    291  0d25							; Convert an ASCII string to a number.  On input,
    292  0d25							; (CURPTR),Y points to the first digit.  This gets
    293  0d25							; digit-by-digit until finding a non-number.  Returns
    294  0d25							; Y pointing to the non-digit, and R0 contains the
    295  0d25							; number.  This does NOT check for valid ranges, so
    296  0d25							; a value like "123456789" will produce something,
    297  0d25							; but not what you had expected.
    298  0d25							;
    299  0d25		       a9 00	   getDecimal lda	#0
    300  0d27		       85 83		      sta	R0
    301  0d29		       85 84		      sta	R0+1
    302  0d2b		       85 77		      sta	dpl	;temporary negative flag
    303  0d2d							;
    304  0d2d							; See if it's negative...
    305  0d2d							;
    306  0d2d		       84 13		      sty	$0013
    307  0d2f		       b1 7e		      lda	(CURPTR),y
    308  0d31		       c9 2d		      cmp	#'-
    309  0d33		       d0 02		      bne	getDecLoop
    310  0d35		       e6 77		      inc	dpl	;it's negative
    311  0d37							;
    312  0d37		       b1 7e	   getDecLoop lda	(CURPTR),y
    313  0d39		       c9 30		      cmp	#'0
    314  0d3b		       90 36		      bcc	getDdone
    315  0d3d		       c9 3a		      cmp	#'9+1
    316  0d3f		       b0 32		      bcs	getDdone
    317  0d41		       38		      sec
    318  0d42		       e9 30		      sbc	#'0	;convert to binary
    319  0d44		       48		      pha
    320  0d45							;
    321  0d45							; Now multiply R0 by 10.  Remember that
    322  0d45							; 2*N + 8*N = 10*N.
    323  0d45							;
    324  0d45		       06 83		      asl	R0
    325  0d47		       26 84		      rol	R0+1	;*2
    326  0d49		       a5 83		      lda	R0
    327  0d4b		       85 85		      sta	R1
    328  0d4d		       a5 84		      lda	R0+1
    329  0d4f		       85 86		      sta	R1+1
    330  0d51		       06 83		      asl	R0
    331  0d53		       26 84		      rol	R0+1	;*4
    332  0d55		       06 83		      asl	R0
    333  0d57		       26 84		      rol	R0+1	;*8
    334  0d59		       18		      clc		;now add the partial sums...
    335  0d5a		       a5 83		      lda	R0	;...to get *10
    336  0d5c		       65 85		      adc	R1
    337  0d5e		       85 83		      sta	R0
    338  0d60		       a5 84		      lda	R0+1
    339  0d62		       65 86		      adc	R1+1
    340  0d64		       85 84		      sta	R0+1
    341  0d66							;
    342  0d66							; Add in the new digit
    343  0d66							;
    344  0d66		       68		      pla
    345  0d67		       18		      clc
    346  0d68		       65 83		      adc	R0
    347  0d6a		       85 83		      sta	R0
    348  0d6c		       90 02		      bcc	getD2
    349  0d6e		       e6 84		      inc	R0+1
    350  0d70							;
    351  0d70							; Move to next character
    352  0d70							;
    353  0d70		       c8	   getD2      iny
    354  0d71		       d0 c4		      bne	getDecLoop
    355  0d73							;
    356  0d73							; All done with digits, so now deal with it being
    357  0d73							; negative.  If zero, then don't check for negative
    358  0d73							; flag.  Ie, -0 is stored as 0.
    359  0d73							;
    360  0d73		       a5 83	   getDdone   lda	R0
    361  0d75		       05 84		      ora	R0+1
    362  0d77		       f0 16		      beq	getDone2	;zero
    363  0d79		       a5 77		      lda	dpl
    364  0d7b		       f0 12		      beq	getDone2	;positive
    365  0d7d							;
    366  0d7d							; Invert all the bits, then add one.
    367  0d7d							;
    368  0d7d		       a5 83		      lda	R0
    369  0d7f		       49 ff		      eor	#$ff
    370  0d81		       85 83		      sta	R0
    371  0d83		       a5 84		      lda	R0+1
    372  0d85		       49 ff		      eor	#$ff
    373  0d87		       85 84		      sta	R0+1
    374  0d89							;
    375  0d89		       e6 83		      inc	R0
    376  0d8b		       d0 02		      bne	getDone2
    377  0d8d		       e6 84		      inc	R0+1
    378  0d8f				   getDone2
    379  0d8f		       a5 83		      lda	R0
    380  0d91		       85 10		      sta	$0010
    381  0d93		       a5 84		      lda	R0+1
    382  0d95		       85 11		      sta	$0011
    383  0d97		       a5 77		      lda	dpl
    384  0d99		       85 12		      sta	$012
    385  0d9b
    386  0d9b		       60		      rts
    387  0d9c							;
    388  0d9c							;=====================================================
    389  0d9c							; Print the string that immediately follows the JSR to
    390  0d9c							; this function.  Stops when a null byte is found,
    391  0d9c							; then returns to the instruction immediately
    392  0d9c							; following the null.
    393  0d9c							;
    394  0d9c							; Thanks to Ross Archer for this code.
    395  0d9c							; http://www.6502.org/source/io/primm.htm
    396  0d9c							;
    397  0d9c				  -	      if	KIM
    398  0d9c				  -puts       sty	putsy
    399  0d9c				  -	      pla		;low part of "return" address
    400  0d9c				  -			;(data start address)
    401  0d9c				  -	      sta	dpl
    402  0d9c				  -	      pla
    403  0d9c				  -	      sta	dpl+1	;high part of "return" address
    404  0d9c				  -			;(data start address)
    405  0d9c				  -			;Note: we're pointing one short
    406  0d9c				  -psinb      ldy	#1
    407  0d9c				  -	      lda	(dpl),y	;Get next string character
    408  0d9c				  -	      inc	dpl	;update the pointer
    409  0d9c				  -	      bne	psinc	;if not, we're pntng to next char
    410  0d9c				  -	      inc	dpl+1	;account for page crossing
    411  0d9c				  -psinc      ora	#0	;Set flags according to contents of
    412  0d9c				  -			;   Accumulator
    413  0d9c				  -	      beq	psix1	;don't print the final NULL
    414  0d9c				  -	      jsr	OUTCH	;write it out
    415  0d9c				  -	      jmp	psinb	;back around
    416  0d9c				  -psix1      inc	dpl
    417  0d9c				  -	      bne	psix2
    418  0d9c				  -	      inc	dpl+1	;account for page crossing
    419  0d9c				  -psix2      ldy	putsy
    420  0d9c				  -	      jmp	(dpl)	;return to byte following NULL
    421  0d9c					      endif
    422  0d9c							;
    423  0d9c							;=====================================================
    424  0d9c							; Gets a line of input into LINBUF.
    425  0d9c							;
    426  0d9c							; On entry:
    427  0d9c							;    A contains the prompt character, or 0 if none.
    428  0d9c							;
    429  0d9c							; On exit:
    430  0d9c							;    CURPTR points to LINBUF
    431  0d9c							;    LINBUF contains the line with 0 at the end.
    432  0d9c							;    Y has offset to first non-space character
    433  0d9c							;    CURROFF has the same as Y.
    434  0d9c							;
    435  0d9c		       a2 13	   GetLine    ldx	#LINBUF&$ff
    436  0d9e		       86 7e		      stx	CURPTR
    437  0da0		       a2 15		      ldx	#LINBUF>>8
    438  0da2		       86 7f		      stx	CURPTR+1
    439  0da4							;
    440  0da4							; Prompt
    441  0da4							;
    442  0da4		       48		      pha		;save for retries
    443  0da5		       68	   GetLinePr  pla		;restore
    444  0da6		       48		      pha		;save again
    445  0da7		       09 00		      ora	#0	;any prompt?
    446  0da9		       f0 08		      beq	getlinenp
    447  0dab		       20 06 02 	      jsr	OUTCH
    448  0dae		       a9 20		      lda	#$20
    449  0db0		       20 06 02 	      jsr	OUTCH	;space after prompt
    450  0db3							;
    451  0db3		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    452  0db5		       8e 97 15    getline1   stx	getlinx
    453  0db8		       20 09 02 	      jsr	GETCH
    454  0dbb					      if	CTMON65
    455  0dbb		       48		      pha
    456  0dbc		       20 0c f0 	      jsr	cout	;echo echo echo
    457  0dbf		       68		      pla
    458  0dc0					      endif
    459  0dc0		       c9 0d		      cmp	#CR
    460  0dc2		       f0 0d		      beq	getlind	;end of line
    461  0dc4		       c9 08		      cmp	#BS	;backspace?
    462  0dc6		       f0 21		      beq	getlinebs
    463  0dc8		       ae 97 15 	      ldx	getlinx
    464  0dcb		       9d 13 15 	      sta	LINBUF,x
    465  0dce		       e8		      inx
    466  0dcf		       d0 e4		      bne	getline1
    467  0dd1							;
    468  0dd1							; CR was hit
    469  0dd1							;
    470  0dd1		       a9 00	   getlind    lda	#0
    471  0dd3		       ae 97 15 	      ldx	getlinx
    472  0dd6		       9d 13 15 	      sta	LINBUF,x
    473  0dd9		       85 80		      sta	CUROFF
    474  0ddb							;
    475  0ddb							; Output a CR/LF
    476  0ddb							;
    477  0ddb		       20 0c 02 	      jsr	CRLF
    478  0dde							;
    479  0dde							; If a blank line, prompt again.
    480  0dde							;
    481  0dde		       a0 00		      ldy	#0
    482  0de0		       20 30 0f 	      jsr	SkipSpaces
    483  0de3		       b1 7e		      lda	(CURPTR),y
    484  0de5		       f0 be		      beq	GetLinePr	;empty line
    485  0de7		       68		      pla		;get rid of prompt char
    486  0de8		       60		      rts
    487  0de9							;
    488  0de9							; Backspace was hit
    489  0de9							;
    490  0de9		       ae 97 15    getlinebs  ldx	getlinx
    491  0dec		       f0 c7		      beq	getline1	;at start of line
    492  0dee		       ca		      dex
    493  0def		       20 12 f0 	      jsr	puts
      0  0df2					      db	27,"[K",0
      1  0df2		       1b 5b 4b 00	      .byte.b	27,"[K",0
    495  0df6		       4c b5 0d 	      jmp	getline1
    496  0df9							;
    497  0df9							;=====================================================
    498  0df9							; Count the length of the line currently in LINBUF
    499  0df9							; starting at offset Y.  Returns the length in X.  The
    500  0df9							; starting offset in Y should point past the ASCII
    501  0df9							; line number.  Also counts the trailing NULL and two
    502  0df9							; extra bytes for where the line number will be.
    503  0df9							; Update must now include leading length byte not the null at end ****************
    504  0df9							;
    505  0df9				   getLineLength
    506  0df9		       a2 00		      ldx	#0	;size
    507  0dfb		       b9 13 15    getLineL2  lda	LINBUF,y
    508  0dfe		       f0 04		      beq	getLineL3
    509  0e00		       c8		      iny
    510  0e01		       e8		      inx
    511  0e02		       d0 f7		      bne	getLineL2
    512  0e04		       e8	   getLineL3  inx		;count null at end
    513  0e05		       e8		      inx		;line number LSB
    514  0e06		       e8		      inx		;MSB
    515  0e07		       e8		      inx		;change: count new leading line length
    516  0e08		       86 7d		      stx	lineLength
    517  0e0a		       60		      rts
    518  0e0b							;
    519  0e0b							;=====================================================
    520  0e0b							; Count the length of the line pointed to by CURPTR.
    521  0e0b							; This also counts the line number and the terminating
    522  0e0b							; null.  Ie, this string returns 8:
    523  0e0b							;
    524  0e0b							; <lineLow><lineHi>Hello<null>
    525  0e0b							;
    526  0e0b							; Another way of looking at it: add the return value
    527  0e0b							; to the CURPTR and it'll point to the next line's
    528  0e0b							; line number.  Returns the value in Y.
    529  0e0b							; Update to ject get the leading byte length ********************
    530  0e0b							;
    531  0e0b							;getCURPTRLength
    532  0e0b							;		ldy	CURPTR
    533  0e0b							;		ldy	#3	;change: skip line number and leading length byte
    534  0e0b							;getCLineL2	lda	(CURPTR),y
    535  0e0b							;		beq	getCLineL3
    536  0e0b							;		iny
    537  0e0b							;		bne	getCLineL2
    538  0e0b							;getCLineL3	iny		;count null at end
    539  0e0b							;		rts
    540  0e0b							;
    541  0e0b							;=====================================================
    542  0e0b							; This saves ILPC.  This saves to a single save area,
    543  0e0b							; so it can't be called more than once.
    544  0e0b							;
    545  0e0b		       a5 75	   saveIL     lda	ILPC
    546  0e0d		       85 79		      sta	tempIL
    547  0e0f		       a5 76		      lda	ILPC+1
    548  0e11		       85 7a		      sta	tempIL+1
    549  0e13		       60		      rts
    550  0e14							;
    551  0e14							;=====================================================
    552  0e14							; This restores ILPC.
    553  0e14							;
    554  0e14		       a5 79	   restoreIL  lda	tempIL
    555  0e16		       85 75		      sta	ILPC
    556  0e18		       a5 7a		      lda	tempIL+1
    557  0e1a		       85 76		      sta	ILPC+1
    558  0e1c		       60		      rts
    559  0e1d							;
    560  0e1d							;=====================================================
    561  0e1d							; This pushes R0 onto the stack.
    562  0e1d							;
    563  0e1d		       ae c0 14    pushR0     ldx	mathStackPtr
    564  0e20		       a5 83		      lda	R0
    565  0e22		       9d 98 14 	      sta	mathStack,x
    566  0e25		       e8		      inx
    567  0e26		       a5 84		      lda	R0+1
    568  0e28		       9d 98 14 	      sta	mathStack,x
    569  0e2b		       e8		      inx
    570  0e2c		       8e c0 14 	      stx	mathStackPtr
    571  0e2f		       60		      rts
    572  0e30
    573  0e30							;=====================================================
    574  0e30							; This pushes curptr basic current line onto the call stack.
    575  0e30
    576  0e30				   pushLN
    577  0e30		       8c a0 15 	      sty	rtemp1
    578  0e33		       ac 12 15 	      ldy	GoSubStackPtr
    579  0e36		       98		      tya
    580  0e37		       c9 3c		      cmp	#GOSUBSTACKSIZE*3
    581  0e39		       f0 17		      beq	pusherr
    582  0e3b		       a5 7e		      lda	CURPTR
    583  0e3d		       91 81		      sta	(GOSUBSTACK),y
    584  0e3f		       c8		      iny
    585  0e40		       a5 7f		      lda	CURPTR+1
    586  0e42		       91 81		      sta	(GOSUBSTACK),y
    587  0e44		       c8		      iny
    588  0e45		       a5 80		      lda	CUROFF
    589  0e47		       91 81		      sta	(GOSUBSTACK),y
    590  0e49		       c8		      iny
    591  0e4a		       8c 12 15 	      sty	GoSubStackPtr
    592  0e4d		       ac a0 15 	      ldy	rtemp1
    593  0e50		       18		      clc
    594  0e51		       60		      rts
    595  0e52
    596  0e52				   pusherr
    597  0e52		       38		      sec
    598  0e53		       60		      rts
    599  0e54							;
    600  0e54							;=====================================================
    601  0e54							; This pushes R1 onto the stack
    602  0e54							;
    603  0e54		       ae c0 14    pushR1     ldx	mathStackPtr
    604  0e57		       a5 85		      lda	R1
    605  0e59		       9d 98 14 	      sta	mathStack,x
    606  0e5c		       e8		      inx
    607  0e5d		       a5 86		      lda	R1+1
    608  0e5f		       9d 98 14 	      sta	mathStack,x
    609  0e62		       e8		      inx
    610  0e63		       8e c0 14 	      stx	mathStackPtr
    611  0e66		       60		      rts
    612  0e67							;
    613  0e67							;=====================================================
    614  0e67							; This pops Top Of Stack and places it in R0.
    615  0e67							;
    616  0e67		       ae c0 14    popR0      ldx	mathStackPtr
    617  0e6a		       ca		      dex
    618  0e6b		       bd 98 14 	      lda	mathStack,x
    619  0e6e		       85 84		      sta	R0+1
    620  0e70		       ca		      dex
    621  0e71		       bd 98 14 	      lda	mathStack,x
    622  0e74		       85 83		      sta	R0
    623  0e76		       8e c0 14 	      stx	mathStackPtr
    624  0e79		       60		      rts
    625  0e7a							;=====================================================
    626  0e7a							; This pops Top Of gosub call Stack and
    627  0e7a							; laces it in CURPTR.
    628  0e7a							;
    629  0e7a		       8c a0 15    popLN      sty	rtemp1
    630  0e7d		       ac 12 15 	      ldy	GoSubStackPtr
    631  0e80		       88		      dey
    632  0e81		       98		      tya
    633  0e82		       c9 ff		      cmp	#$FF
    634  0e84		       f0 16		      beq	poperr
    635  0e86		       b1 81		      lda	(GOSUBSTACK),y
    636  0e88		       85 80		      sta	CUROFF
    637  0e8a		       88		      dey
    638  0e8b		       b1 81		      lda	(GOSUBSTACK),y
    639  0e8d		       85 7f		      sta	CURPTR+1
    640  0e8f		       88		      dey
    641  0e90		       b1 81		      lda	(GOSUBSTACK),y
    642  0e92		       85 7e		      sta	CURPTR
    643  0e94		       8c 12 15 	      sty	GoSubStackPtr
    644  0e97		       ac a0 15 	      ldy	rtemp1
    645  0e9a		       18		      clc
    646  0e9b		       60		      rts
    647  0e9c		       38	   poperr     sec
    648  0e9d		       60		      rts
    649  0e9e							;
    650  0e9e							;=====================================================
    651  0e9e							; This pops TOS and places it in R1.
    652  0e9e							;
    653  0e9e		       ae c0 14    popR1      ldx	mathStackPtr
    654  0ea1		       ca		      dex
    655  0ea2		       bd 98 14 	      lda	mathStack,x
    656  0ea5		       85 86		      sta	R1+1
    657  0ea7		       ca		      dex
    658  0ea8		       bd 98 14 	      lda	mathStack,x
    659  0eab		       85 85		      sta	R1
    660  0ead		       8e c0 14 	      stx	mathStackPtr
    661  0eb0		       60		      rts
    662  0eb1							;
    663  0eb1							;=====================================================
    664  0eb1							; This pops TOS and places it in MQ.
    665  0eb1							;
    666  0eb1		       ae c0 14    popMQ      ldx	mathStackPtr
    667  0eb4		       ca		      dex
    668  0eb5		       bd 98 14 	      lda	mathStack,x
    669  0eb8		       8d 9e 15 	      sta	MQ+1
    670  0ebb		       ca		      dex
    671  0ebc		       bd 98 14 	      lda	mathStack,x
    672  0ebf		       8d 9d 15 	      sta	MQ
    673  0ec2		       8e c0 14 	      stx	mathStackPtr
    674  0ec5		       60		      rts
    675  0ec6							;
    676  0ec6							;=====================================================
    677  0ec6							; This assists with multiplication and division by
    678  0ec6							; looking at R0 and R1 and saving a flag as to what
    679  0ec6							; sign the result will be.  Math is always done on
    680  0ec6							; positive numbers, so this converts negative numbers
    681  0ec6							; into positives.  On exit, R0 and R1 are both
    682  0ec6							; positive.  If the signs were different then 'signs'
    683  0ec6							; will be non-zero.
    684  0ec6							;
    685  0ec6		       a9 00	   SaveSigns  lda	#0
    686  0ec8		       8d 9f 15 	      sta	sign	;assume positive
    687  0ecb		       a5 84		      lda	R0+1	;MSB
    688  0ecd		       10 13		      bpl	SaveSigns1
    689  0ecf		       ee 9f 15 	      inc	sign	;it's negative
    690  0ed2		       49 ff		      eor	#$ff	;flip bits
    691  0ed4		       85 84		      sta	R0+1
    692  0ed6		       a5 83		      lda	R0
    693  0ed8		       49 ff		      eor	#$ff
    694  0eda		       85 83		      sta	R0
    695  0edc		       e6 83		      inc	R0
    696  0ede		       d0 02		      bne	SaveSigns1
    697  0ee0		       e6 84		      inc	R0+1
    698  0ee2		       a5 86	   SaveSigns1 lda	R1+1
    699  0ee4		       10 1a		      bpl	SaveSigns2
    700  0ee6		       48		      pha
    701  0ee7		       ad 9f 15 	      lda	sign
    702  0eea		       49 01		      eor	#1
    703  0eec		       8d 9f 15 	      sta	sign
    704  0eef		       68		      pla
    705  0ef0		       49 ff		      eor	#$ff	;flip bits
    706  0ef2		       85 86		      sta	R1+1
    707  0ef4		       a5 85		      lda	R1
    708  0ef6		       49 ff		      eor	#$ff
    709  0ef8		       85 85		      sta	R1
    710  0efa		       e6 85		      inc	R1
    711  0efc		       d0 02		      bne	SaveSigns2
    712  0efe		       e6 86		      inc	R1+1
    713  0f00		       60	   SaveSigns2 rts
    714  0f01							;
    715  0f01							;=====================================================
    716  0f01							; This looks at the value of 'signs' and will convert
    717  0f01							; both R0 and R1 to negative if set.
    718  0f01							;
    719  0f01				   RestoreSigns
    720  0f01		       ad 9f 15 	      lda	sign
    721  0f04		       f0 28		      beq	restoresigns2
    722  0f06							;
    723  0f06		       a5 83		      lda	R0
    724  0f08		       d0 02		      bne	restoresigns3
    725  0f0a		       c6 84		      dec	R0+1
    726  0f0c				   restoresigns3
    727  0f0c		       c6 83		      dec	R0
    728  0f0e		       a5 83		      lda	R0
    729  0f10		       49 ff		      eor	#$ff
    730  0f12		       85 83		      sta	R0
    731  0f14		       a5 84		      lda	R0+1
    732  0f16		       49 ff		      eor	#$ff
    733  0f18		       85 84		      sta	R0+1
    734  0f1a							;
    735  0f1a		       a5 85		      lda	R1
    736  0f1c		       d0 02		      bne	restoresigns4
    737  0f1e		       c6 86		      dec	R1+1
    738  0f20				   restoresigns4
    739  0f20		       c6 85		      dec	R1
    740  0f22		       a5 85		      lda	R1
    741  0f24		       49 ff		      eor	#$ff
    742  0f26		       85 85		      sta	R1
    743  0f28		       a5 86		      lda	R1+1
    744  0f2a		       49 ff		      eor	#$ff
    745  0f2c		       85 86		      sta	R1+1
    746  0f2e							;
    747  0f2e				   restoresigns2
    748  0f2e		       60		      rts
    749  0f2f							;
    750  0f2f							;=====================================================
    751  0f2f							; Skip over spaces.  Returns Y with the offset to
    752  0f2f							; either the last character in the line, or the first
    753  0f2f							; non-space character.
    754  0f2f							;
    755  0f2f		       c8	   skipsp2    iny
    756  0f30		       b1 7e	   SkipSpaces lda	(CURPTR),y
    757  0f32		       f0 04		      beq	Skip3	;end of line
    758  0f34		       c9 20		      cmp	#SPACE
    759  0f36		       f0 f7		      beq	skipsp2
    760  0f38		       60	   Skip3      rts
    761  0f39							;
    762  0f39							;=====================================================
    763  0f39							; This is some debug logic which displays the current
    764  0f39							; value of the ILPC and the line buffer.
    765  0f39							;
    766  0f39		       20 12 f0    dbgLine    jsr	puts
      0  0f3c					      db	"ILPC: ",0
      1  0f3c		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    768  0f43		       a5 76		      lda	ILPC+1
    769  0f45		       20 0f 02 	      jsr	OUTHEX
    770  0f48		       a5 75		      lda	ILPC
    771  0f4a		       20 0f 02 	      jsr	OUTHEX
    772  0f4d		       a9 20		      lda	#SPACE
    773  0f4f		       20 06 02 	      jsr	OUTCH
    774  0f52		       a0 00		      ldy	#0
    775  0f54		       b1 75		      lda	(ILPC),y
    776  0f56		       20 0f 02 	      jsr	OUTHEX
    777  0f59							;
    778  0f59							; Display the CURPTR value and offset
    779  0f59							;
    780  0f59		       20 12 f0 	      jsr	puts
      0  0f5c					      db	", CURPTR: ",0
      1  0f5c		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    782  0f67		       a5 7f		      lda	CURPTR+1
    783  0f69		       20 0f 02 	      jsr	OUTHEX
    784  0f6c		       a5 7e		      lda	CURPTR
    785  0f6e		       20 0f 02 	      jsr	OUTHEX
    786  0f71		       a9 2b		      lda	#'+
    787  0f73		       20 06 02 	      jsr	OUTCH
    788  0f76		       a5 80		      lda	CUROFF
    789  0f78		       20 0f 02 	      jsr	OUTHEX
    790  0f7b							;
    791  0f7b		       4c 0c 02 	      jmp	CRLF
    792  0f7e							;
    793  0f7e							;=====================================================
    794  0f7e							; This function might go away eventually, but was
    795  0f7e							; added to provide data for other pieces of code.
    796  0f7e							; It has some ties to the operating environment that
    797  0f7e							; will need to be customized for the target system.
    798  0f7e							;
    799  0f7e				   GetSizes
    800  0f7e							;
    801  0f7e							; Here is machine specific code to get the highest
    802  0f7e							; memory location that can be used by BASIC.
    803  0f7e							;
    804  0f7e					      if	ProgramStart < $2000
    805  0f7e		       a9 ff		      lda	#$ff
    806  0f80		       8d a8 15 	      sta	HighMem	;$13ff for KIM-1
    807  0f83		       a9 de		      lda	#$DE	;#$13
    808  0f85		       8d a9 15 	      sta	HighMem+1
    809  0f88				  -	      else
    810  0f88				  -	      lda	#$ff
    811  0f88				  -	      sta	HighMem	;$CFFF otherwise
    812  0f88				  -	      lda	#$cf
    813  0f88				  -	      sta	HighMem+1
    814  0f88					      endif
    815  0f88							;
    816  0f88							; This computes the available memory remaining.
    817  0f88							;
    818  0f88		       38		      sec
    819  0f89		       ad a8 15 	      lda	HighMem
    820  0f8c		       ed a6 15 	      sbc	PROGRAMEND
    821  0f8f		       8d ac 15 	      sta	FreeMem
    822  0f92		       85 83		      sta	R0
    823  0f94		       ad a9 15 	      lda	HighMem+1
    824  0f97		       ed a7 15 	      sbc	PROGRAMEND+1
    825  0f9a		       8d ad 15 	      sta	FreeMem+1
    826  0f9d		       85 84		      sta	R0+1
    827  0f9f							;
    828  0f9f							; This computes the size of the current user program.
    829  0f9f							;
    830  0f9f		       38		      sec
    831  0fa0		       ad a6 15 	      lda	PROGRAMEND
    832  0fa3		       e9 ae		      sbc	#ProgramStart&$ff
    833  0fa5		       8d aa 15 	      sta	UsedMem
    834  0fa8		       ad a7 15 	      lda	PROGRAMEND+1
    835  0fab		       e9 15		      sbc	#ProgramStart>>8
    836  0fad		       8d ab 15 	      sta	UsedMem+1
    837  0fb0							;
    838  0fb0		       60		      rts
    839  0fb1							;
    840  0fb1							;=====================================================
    841  0fb1							; Set output vector to the console output function
    842  0fb1							;
    843  0fb1				   SetOutConsole
    844  0fb1		       a9 06		      lda	#OUTCH&$ff
    845  0fb3		       8d a3 15 	      sta	BOutVec
    846  0fb6		       a9 02		      lda	#OUTCH/256
    847  0fb8		       8d a4 15 	      sta	BOutVec+1
    848  0fbb		       60		      rts
    849  0fbc							;
    850  0fbc							;=====================================================
    851  0fbc							; Jump to the output function in BOutVec
    852  0fbc							;
    853  0fbc		       6c a3 15    VOUTCH     jmp	(BOutVec)
    854  0fbf
    855  0fbf							;====================================================
    856  0fbf		       15 a0	   PrtTerm    equ	rtemp1
    857  0fbf
    858  0fbf							; Print Y has the offset to use
    859  0fbf		       a5 7e	   PrtQuoted  lda	CURPTR
    860  0fc1		       85 88		      sta	PrtFrom
    861  0fc3		       a5 7f		      lda	CURPTR+1
    862  0fc5		       85 89		      sta	PrtFrom+1
    863  0fc7		       a9 22		      lda	#'"
    864  0fc9		       8d a0 15 	      sta	PrtTerm
    865  0fcc		       4c d8 0f 	      jmp	PrtLoop
    866  0fcf
    867  0fcf							; Print a string pointed to by x= h, y=l terminated by a
    868  0fcf							; Return y as the length
    869  0fcf
    870  0fcf		       86 89	   PrtStr     stx	PrtFrom+1
    871  0fd1		       84 88		      sty	PrtFrom
    872  0fd3		       8d a0 15 	      sta	PrtTerm
    873  0fd6		       a0 00		      ldy	#0
    874  0fd8
    875  0fd8		       b1 88	   PrtLoop    lda	(PrtFrom),y
    876  0fda		       cd a0 15 	      cmp	PrtTerm
    877  0fdd		       f0 0b		      beq	PrtEnd
    878  0fdf		       c9 00		      cmp	#0	; always end if 0 is found
    879  0fe1		       f0 07		      beq	PrtEnd
    880  0fe3		       20 06 02 	      jsr	OUTCH
    881  0fe6		       c8		      iny
    882  0fe7		       4c d8 0f 	      jmp	PrtLoop
    883  0fea		       c8	   PrtEnd     iny		;return byte after the copy
    884  0feb		       60		      rts
    885  0fec
    886  0fec							;====================================================
    887  0fec							;Clear the terminal assume it is ansii or vt100
    888  0fec							;
    889  0fec				   iCLEARSCREEN
    890  0fec		       20 12 f0 	      jsr	puts
      0  0fef					      db	$1b,'[,'3,'J,0
      1  0fef		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    892  0ff4		       4c e9 02 	      jmp	NextIL
------- FILE mytb.asm
   2052  0ff7					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  0ff7					      include	"storage.asm"
      1  0ff7							;
      2  0ff7							;=====================================================
      3  0ff7							;=====================================================
      4  0ff7							;=====================================================
      5  0ff7							; This file contains the functions for saving and
      6  0ff7							; restoring programs from some sort of mass storage
      7  0ff7							; device.  This particular version is for using the
      8  0ff7							; Corsham Tech SD Card System.
      9  0ff7							;=====================================================
     10  0ff7							;=====================================================
     11  0ff7							;=====================================================
     12  0ff7
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  0ff7					      SEG	Code
     19  0ff7
     20  0ff7							;
     21  0ff7							;=====================================================
     22  0ff7							; Open a file for reading as a program.  The next
     23  0ff7							; thing on the line should be the filename.
     24  0ff7							;
     25  0ff7				   iOPENREAD
     26  0ff7					      if	XKIM || CTMON65
     27  0ff7		       a4 80		      ldy	CUROFF
     28  0ff9		       b1 7e		      lda	(CURPTR),y
     29  0ffb		       d0 07		      bne	iOPENfn	;might be filename
     30  0ffd							;
     31  0ffd							; No filename supplied.
     32  0ffd							;
     33  0ffd		       a9 00	   iOPENnofn  lda	#0
     34  0fff		       a2 09		      ldx	#ERR_NO_FILENAME
     35  1001		       4c 8b 05 	      jmp	iErr2
     36  1004							;
     37  1004							; Add the offset into the buffer start
     38  1004							;
     39  1004		       18	   iOPENfn    clc
     40  1005		       98		      tya
     41  1006		       65 7e		      adc	CURPTR
     42  1008		       a8		      tay		;LSB
     43  1009		       a5 7f		      lda	CURPTR+1
     44  100b		       69 00		      adc	#0
     45  100d		       aa		      tax
     46  100e		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  1011		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1013							;
     49  1013							; Open failed
     50  1013							;
     51  1013		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1015		       a9 00	   Rdfail2    lda	#0
     53  1017		       4c 8b 05 	      jmp	iErr2
     54  101a							;
     55  101a							; Clear counts and offsets so the next read will
     56  101a							; cause the file to be read.
     57  101a							;
     58  101a		       a9 00	   Ropenok    lda	#0
     59  101c		       8d 8f df 	      sta	diskBufOffset
     60  101f		       8d 8e df 	      sta	diskBufLength
     61  1022		       4c e9 02 	      jmp	NextIL
     62  1025					      endif
     63  1025
     64  1025							;
     65  1025							;==============================jlit 08/02/2022========
     66  1025							;Remove a file from the disk
     67  1025				   iRMFILE
     68  1025					      if	XKIM || CTMON65
     69  1025		       a4 80		      ldy	CUROFF
     70  1027		       b1 7e		      lda	(CURPTR),y
     71  1029		       f0 19		      beq	iRMnofn
     72  102b							;
     73  102b		       18		      clc
     74  102c		       98		      tya
     75  102d		       65 7e		      adc	CURPTR
     76  102f		       a8		      tay		;LSB
     77  1030		       a5 7f		      lda	CURPTR+1
     78  1032		       69 00		      adc	#0
     79  1034		       aa		      tax
     80  1035		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1038		       90 07		      bcc	wrmOk	;branch if removed ok
     82  103a		       a9 00		      lda	#0
     83  103c		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  103e		       4c 8b 05 	      jmp	iErr2
     85  1041		       4c e9 02    wrmOk      jmp	NextIL
     86  1044
     87  1044							; No filename supplied.
     88  1044							;
     89  1044		       a9 00	   iRMnofn    lda	#0
     90  1046		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1048		       4c 8b 05 	      jmp	iErr2
     92  104b					      endif
     93  104b							;
     94  104b							;=====================================================
     95  104b				   iOPENWRITE
     96  104b					      if	XKIM || CTMON65
     97  104b		       a4 80		      ldy	CUROFF
     98  104d		       b1 7e		      lda	(CURPTR),y
     99  104f		       f0 f3		      beq	iRMnofn
    100  1051							;
    101  1051		       18		      clc
    102  1052		       98		      tya
    103  1053		       65 7e		      adc	CURPTR
    104  1055		       a8		      tay		;LSB
    105  1056		       a5 7f		      lda	CURPTR+1
    106  1058		       69 00		      adc	#0
    107  105a		       aa		      tax
    108  105b		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  105e		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1060							;
    111  1060							; Open failed
    112  1060							;
    113  1060		       a9 00	   Wdfail     lda	#0
    114  1062		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1064		       4c 8b 05 	      jmp	iErr2
    116  1067							;
    117  1067		       4c e9 02    Wopenok    jmp	NextIL
    118  106a					      endif
    119  106a							;
    120  106a							;=====================================================
    121  106a							; Gets a line of input from the disk file and puts it
    122  106a							; into LINBUF.
    123  106a							;
    124  106a							; On exit:
    125  106a							;    CURPTR points to LINBUF
    126  106a							;    LINBUF contains the line with 0 at the end.
    127  106a							;    Y has offset to first non-space character
    128  106a							;    CURROFF has the same as Y.
    129  106a							;
    130  106a				   iDGETLINE
    131  106a					      if	XKIM || CTMON65
    132  106a		       a2 13		      ldx	#LINBUF&$ff
    133  106c		       86 7e		      stx	CURPTR
    134  106e		       a2 15		      ldx	#LINBUF>>8
    135  1070		       86 7f		      stx	CURPTR+1
    136  1072							;
    137  1072		       a2 00		      ldx	#0	;offset
    138  1074		       8e 97 15    iDgetLoop  stx	getlinx
    139  1077		       20 d5 10 	      jsr	getNextFileByte
    140  107a		       b0 16		      bcs	iGetEOF
    141  107c		       c9 0d		      cmp	#CR
    142  107e		       f0 0d		      beq	iGetEOL
    143  1080		       c9 0a		      cmp	#LF
    144  1082		       f0 09		      beq	iGetEOL
    145  1084		       ae 97 15 	      ldx	getlinx
    146  1087		       9d 13 15 	      sta	LINBUF,x
    147  108a		       e8		      inx
    148  108b		       d0 e7		      bne	iDgetLoop
    149  108d							;
    150  108d							; Handle end of line.	If the line has nothing, loop
    151  108d							; back and get another line.
    152  108d							;
    153  108d		       ae 97 15    iGetEOL    ldx	getlinx	;blank line?
    154  1090		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  1092							;
    156  1092							; This can fall through when there is a line, or
    157  1092							; called directly when EOF is encountered.
    158  1092							;
    159  1092		       ae 97 15    iGetEOF    ldx	getlinx
    160  1095		       a9 00		      lda	#0
    161  1097		       9d 13 15 	      sta	LINBUF,x
    162  109a		       85 80		      sta	CUROFF
    163  109c		       a0 00		      ldy	#0
    164  109e		       20 30 0f 	      jsr	SkipSpaces
    165  10a1		       4c e9 02 	      jmp	NextIL
    166  10a4					      endif
    167  10a4
    168  10a4							;
    169  10a4							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  10a4							; DISK
    171  10a4							;
    172  10a4				   iDDIR
    173  10a4					      if	XKIM || CTMON65
    174  10a4		       20 30 f0 	      jsr	DiskDir
    175  10a7							;
    176  10a7							; Get/Display each entry
    177  10a7							;
    178  10a7		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  10a9		       a0 90		      ldy	#DiskFileName&$ff
    180  10ab		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  10ae		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  10b0		       20 12 f0 	      jsr	puts
      0  10b3					      db	"   ",0
      1  10b3		       20 20 20 00	      .byte.b	"   ",0
    184  10b7							; Print the line to the console
    185  10b7		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  10b9		       a0 90		      ldy	#DiskFileName&$ff
    187  10bb		       a5 00		      lda	0
    188  10bd		       20 cf 0f 	      jsr	PrtStr	;else print name
    189  10c0		       20 18 f0 	      jsr	crlf
    190  10c3
    191  10c3		       4c a7 10 	      jmp	DiskDirLoop	;do next entry
    192  10c6		       4c e9 02    DiskDirEnd jmp	NextIL
    193  10c9					      endif
    194  10c9							;
    195  10c9							;=====================================================
    196  10c9							; Does a LIST to a Disk file.
    197  10c9							;
    198  10c9				   iDLIST
    199  10c9					      if	XKIM || CTMON65
    200  10c9		       20 04 11 	      jsr	SetOutDisk
    201  10cc		       4c 1f 07 	      jmp	iLST2
    202  10cf					      endif
    203  10cf							;
    204  10cf							;=====================================================
    205  10cf							; Closes any pending disk file.  Okay to call if there
    206  10cf							; is no open file.
    207  10cf							;
    208  10cf				   iDCLOSE
    209  10cf					      if	XKIM || CTMON65
    210  10cf		       20 42 f0 	      jsr	DiskClose
    211  10d2		       4c e9 02 	      jmp	NextIL
    212  10d5					      endif
    213  10d5							;
    214  10d5							;=====================================================
    215  10d5							; This gets the next byte from an open disk file.  If
    216  10d5							; there are no more bytes left, this returns C set.
    217  10d5							; Else, C is clear and A contains the character.
    218  10d5							;
    219  10d5				   getNextFileByte
    220  10d5					      if	XKIM || CTMON65
    221  10d5		       ae 8f df 	      ldx	diskBufOffset
    222  10d8		       ec 8e df 	      cpx	diskBufLength
    223  10db		       d0 14		      bne	hasdata	;branch if still data
    224  10dd							;
    225  10dd							; There is no data left in the buffer, so read a
    226  10dd							; block from the SD system.
    227  10dd							;
    228  10dd		       a9 84		      lda	#BUFFER_SIZE
    229  10df		       a2 df		      ldx	#buffer>>8
    230  10e1		       a0 0a		      ldy	#buffer&$ff
    231  10e3		       20 3c f0 	      jsr	DiskRead
    232  10e6		       b0 12		      bcs	getNextEof
    233  10e8							;
    234  10e8							; A contains the number of bytes actually read.
    235  10e8							;
    236  10e8		       8d 8e df 	      sta	diskBufLength	;save length
    237  10eb		       c9 00		      cmp	#0	;shouldn't happen
    238  10ed		       f0 0b		      beq	getNextEof
    239  10ef							;
    240  10ef		       a2 00		      ldx	#0
    241  10f1		       bd 0a df    hasdata    lda	buffer,x
    242  10f4		       e8		      inx
    243  10f5		       8e 8f df 	      stx	diskBufOffset
    244  10f8		       18		      clc
    245  10f9		       60		      rts
    246  10fa							;
    247  10fa		       a9 00	   getNextEof lda	#0
    248  10fc		       8d 8f df 	      sta	diskBufOffset
    249  10ff		       8d 8e df 	      sta	diskBufLength
    250  1102		       38		      sec
    251  1103		       60		      rts
    252  1104							;
    253  1104							;=====================================================
    254  1104							; Set output vector to the disk output function
    255  1104							;
    256  1104		       a9 0f	   SetOutDisk lda	#DOUT&$ff
    257  1106		       8d a3 15 	      sta	BOutVec
    258  1109		       a9 11		      lda	#DOUT/256
    259  110b		       8d a4 15 	      sta	BOutVec+1
    260  110e		       60		      rts
    261  110f							;
    262  110f							;=====================================================
    263  110f
    264  110f		       8d 0a df    DOUT       sta	buffer
    265  1112		       a9 01		      lda	#1
    266  1114		       a0 0a		      ldy	#buffer&$ff
    267  1116		       a2 df		      ldx	#buffer/256
    268  1118		       20 3f f0 	      jsr	DiskWrite
    269  111b							;
    270  111b							; need error checking here
    271  111b							;
    272  111b		       60		      rts
    273  111c					      endif
    274  111c
    275  111c
------- FILE mytb.asm
   2054  111c					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  111c					      include	"IL.inc"
      1  111c
      2  111c							;=====================================================
      3  111c							; IL.inc
      4  111c							; These are macros for IL instructions
      5  111c							;
      6  111c					      mac	dw
      7  111c					      .word	{0}
      8  111c					      endm
      9  111c					      mac	db
     10  111c					      .byte	{0}
     11  111c					      endm
     12  111c					      macro	xinit
     13  111c					      db	0
     14  111c					      endm		;reset the il to start clear all
     15  111c							;
     16  111c					      macro	done
     17  111c					      db	1
     18  111c					      endm		;print an error if not end of line
     19  111c							;
     20  111c					      macro	prs
     21  111c					      db	2
     22  111c					      endm		;print a quoted string
     23  111c							;
     24  111c					      macro	prn
     25  111c					      db	3
     26  111c					      endm		;print a number
     27  111c							;
     28  111c					      macro	spc
     29  111c					      db	4
     30  111c					      endm		;print space til new tabstop
     31  111c							;
     32  111c					      macro	nline
     33  111c					      db	5
     34  111c					      endm		;print a new line crlf
     35  111c							;
     36  111c							; My NXT is a bit different in that it takes one
     37  111c							; parameter, which is an address.  If the BASIC
     38  111c							; program is currently running then move to the
     39  111c							; next line and continue execution.  However, if
     40  111c							; in direct mode, jump to the specified IL label.
     41  111c							;
     42  111c					      macro	nxt
     43  111c					      db	6
     44  111c					      dw	{1}	; addr
     45  111c					      endm		; addr
     46  111c							;
     47  111c					      macro	xfer
     48  111c					      db	7
     49  111c					      endm
     50  111c							;
     51  111c					      macro	sav
     52  111c					      db	8
     53  111c					      endm
     54  111c							;
     55  111c					      macro	rstr
     56  111c					      db	9
     57  111c					      endm
     58  111c							;
     59  111c					      macro	cmpr
     60  111c					      db	10
     61  111c					      endm
     62  111c							;
     63  111c					      macro	innum
     64  111c					      db	11
     65  111c					      endm
     66  111c							;
     67  111c					      macro	fin
     68  111c					      db	12
     69  111c					      endm
     70  111c							;
     71  111c							; ERR is followed by an error number.	The error
     72  111c							; code is printed along with the line number.
     73  111c							; Control is passed to the statement set with
     74  111c							; the ERRGOTO statement.
     75  111c							;
     76  111c					      macro	errmsg
     77  111c					      db	13
     78  111c					      dw	{1}	;ecode
     79  111c					      endm		;ecode
     80  111c							;
     81  111c					      macro	add
     82  111c					      db	14
     83  111c					      endm
     84  111c							;
     85  111c					      macro	sub
     86  111c					      db	15
     87  111c					      endm
     88  111c							;
     89  111c					      macro	neg
     90  111c					      db	16
     91  111c					      endm
     92  111c							;
     93  111c					      macro	mul
     94  111c					      db	17
     95  111c					      endm
     96  111c							;
     97  111c					      macro	div
     98  111c					      db	18
     99  111c					      endm
    100  111c							;
    101  111c					      macro	store
    102  111c					      db	19
    103  111c					      endm
    104  111c							;
    105  111c					      macro	ind
    106  111c					      db	20
    107  111c					      endm
    108  111c							;
    109  111c					      macro	lst
    110  111c					      db	21
    111  111c					      endm
    112  111c							;
    113  111c					      macro	init
    114  111c					      db	22
    115  111c					      endm
    116  111c							;
    117  111c					      macro	getline
    118  111c					      db	23
    119  111c					      endm
    120  111c							;
    121  111c					      macro	insert
    122  111c					      db	24
    123  111c					      endm
    124  111c							;
    125  111c					      macro	rtn
    126  111c					      db	25
    127  111c					      endm
    128  111c							;
    129  111c					      macro	exit
    130  111c					      db	26
    131  111c					      endm
    132  111c							;
    133  111c					      macro	lit
    134  111c					      db	27
    135  111c					      dw	{1}	;value
    136  111c					      endm		; value LIT
    137  111c							;
    138  111c					      macro	call
    139  111c					      db	28
    140  111c					      dw	{1}	;addr
    141  111c					      endm		;addr
    142  111c							;
    143  111c							; IJMP will set the IL PC to the specified value.
    144  111c							;
    145  111c					      macro	ijmp
    146  111c					      db	29
    147  111c					      dw	{1}	;addr
    148  111c					      endm		;addr
    149  111c							;
    150  111c					      macro	vinit
    151  111c					      db	30
    152  111c					      endm
    153  111c							;
    154  111c							; ERRGOTO sets the point in the code where the IL
    155  111c							; interpreter will go after any error.
    156  111c							;
    157  111c					      macro	errgoto
    158  111c					      db	31
    159  111c					      dw	{1}	;addr
    160  111c					      endm		;addr
    161  111c							;
    162  111c					      macro	tst
    163  111c					      db	32
    164  111c					      db	({1}-*)-1	;(addr-*)-1
    165  111c					      db	{2},0	;string,0
    166  111c					      endm		;addr,string
    167  111c							;
    168  111c					      macro	tstv
    169  111c					      db	33
    170  111c					      db	({1}-*)-1	;(addr-*)-1
    171  111c					      endm		;addr
    172  111c							;
    173  111c					      macro	tstl
    174  111c					      db	34
    175  111c					      db	({1}-*)-1	;(addr-*)-1
    176  111c					      endm		;addr
    177  111c							;
    178  111c					      macro	tstn
    179  111c					      db	35
    180  111c					      db	({1}-*)-1	;(addr-*)-1
    181  111c					      endm		;addr
    182  111c							;
    183  111c							; FREE returns the amount of free RAM on top of
    184  111c							; the stack.  This is the amount of room the user
    185  111c							; program has available.
    186  111c							;
    187  111c					      macro	free
    188  111c					      db	36
    189  111c					      endm
    190  111c							;
    191  111c							; RANDOM takes the top item off the stack and
    192  111c							; replaces it with a random number that is
    193  111c							; MOD the initial value.  Ie, if the TOS is
    194  111c							; 42 then RANDOM returns a value from 0 to 41.
    195  111c							;
    196  111c					      macro	random
    197  111c					      db	37
    198  111c					      endm
    199  111c							;
    200  111c							; ABS will replace the top of stack with the
    201  111c							; absolute value.
    202  111c							;
    203  111c					      macro	abs
    204  111c					      db	38
    205  111c					      endm
    206  111c							;
    207  111c							; OPENREAD opens a file for reading, as in getting
    208  111c							; statements from it.
    209  111c							;
    210  111c					      macro	openread
    211  111c					      db	39
    212  111c					      endm
    213  111c							;
    214  111c							; OPENWRITE opens a file for writing, as in saving
    215  111c							; the current program to it.
    216  111c							;
    217  111c					      macro	openwrite
    218  111c					      db	40
    219  111c					      endm
    220  111c							;
    221  111c							; DCLOSE closes any open disk file.
    222  111c							;
    223  111c					      macro	dclose
    224  111c					      db	41
    225  111c					      endm
    226  111c							;
    227  111c							; DGETLINE gets one line from the disk file and puts it
    228  111c							; into LINBUFF.
    229  111c							;
    230  111c					      macro	dgetline
    231  111c					      db	42
    232  111c					      endm
    233  111c							;
    234  111c							; DLIST saves the program to an open disk file.
    235  111c							;
    236  111c					      macro	dlist
    237  111c					      db	43
    238  111c					      endm
    239  111c							; DDIR list the current directory
    240  111c							;
    241  111c					      macro	ddir
    242  111c					      db	44
    243  111c					      endm
    244  111c
    245  111c							; RMFILE remove a fle from disk
    246  111c					      macro	rmfile
    247  111c					      db	45
    248  111c					      endm
    249  111c
    250  111c							; CLEARSCREEN clear the screen
    251  111c					      macro	clearscreen
    252  111c					      db	46
    253  111c					      endm
    254  111c							; POKEMEM Poke value into memory
    255  111c					      macro	pokemem
    256  111c					      db	47
    257  111c					      endm
    258  111c							; PEEKMEM peek at value in memory
    259  111c					      macro	peekmem
    260  111c					      db	48
    261  111c					      endm
    262  111c							; TSTLET Test if the statement is a let without the keyword let
    263  111c					      macro	tstlet
    264  111c					      db	49
    265  111c					      db	({1}-*)-1	;(addr-*)-1
    266  111c					      endm		;addr
    267  111c							; TSTDONE if we reach the end of a statement
    268  111c					      macro	tstdone
    269  111c					      db	50
    270  111c					      db	({1}-*)-1	;(addr-*)-1
    271  111c					      endm		;addr
    272  111c							; GETCHAR	get a character from the input line leave it in RO
    273  111c					      macro	getchar
    274  111c					      db	51
    275  111c					      endm
    276  111c							; PUTCHAR	Put a character to the terminal
    277  111c					      macro	putchar
    278  111c					      db	52
    279  111c					      endm
    280  111c							; Call		Call a machine function return a to stack
    281  111c					      macro	callfunc
    282  111c					      db	53
    283  111c					      endm
    284  111c
    285  111c							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    286  111c					      macro	ibranch
    287  111c					      db	54
    288  111c					      endm
    289  111c
    290  111c							; TSTSTR	 Tests for the open quote in a string
    291  111c					      macro	tststr
    292  111c					      db	55
    293  111c					      db	({1}-*)-1	;(addr-*)-1
    294  111c					      endm
    295  111c							; SETIRQ	Sets the line number to run when an irq happens irq 550
    296  111c					      macro	setirq
    297  111c					      db	56
    298  111c					      endm
    299  111c
    300  111c							; TSTIRQ	Test for irq pending,
    301  111c							;		if so push the IRQ LINE NUMBER into RO, onto stack
    302  111c					      macro	tstirq
    303  111c					      db	57
    304  111c					      db	({1}-*)-1	;(addr-*)-1
    305  111c					      endm
    306  111c
    307  111c							; IRET    return from interupt service
    308  111c					      macro	iret
    309  111c					      db	58
    310  111c					      endm
    311  111c
    312  111c							; INSTR   read a string from the input
    313  111c					      macro	instr
    314  111c					      db	59
    315  111c					      endm
    316  111c
    317  111c							; MODULO Returns the remainder of the division
    318  111c					      macro	modulo
    319  111c					      db	60
    320  111c					      endm
    321  111c							; Task Switch
    322  111c					      macro	taskswitch
    323  111c					      db	61
    324  111c					      endm
    325  111c							; Set a task line
    326  111c					      macro	settask
    327  111c					      db	62
    328  111c					      endm
    329  111c							; End a task
    330  111c					      macro	etask
    331  111c					      db	63
    332  111c					      endm
    333  111c							; Skip to next task
    334  111c					      macro	ntask
    335  111c					      db	64
    336  111c					      endm
    337  111c							; Subscript
    338  111c					      macro	subscript
    339  111c					      db	65
    340  111c					      endm
    341  111c							; KILL Task
    342  111c					      macro	taskkill
    343  111c					      db	66
    344  111c					      endm
    345  111c							; STAT Task
    346  111c					      macro	taskstat
    347  111c					      db	67
    348  111c					      endm
    349  111c							;  output value as hex
    350  111c					      macro	hexprt
    351  111c					      db	68
    352  111c					      endm
    353  111c
------- FILE mytb.asm
   2056  111c							;
   2057  111c				  -	      if	FIXED
   2058  111c				  -	      org	$1000
   2059  111c					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  111c					      include	"basic.il"
      1  111c							;LET
      2  111c							;=====================================================
      3  111c							;=====================================================
      4  111c							;=====================================================
      5  111c							; This is the IL of the BASIC (or whatever) language.
      6  111c							; Because of the way macros are implemented by as65,
      7  111c							; labels can't be on the same line as a macro
      8  111c							; invocation, so that's why labels are on separate
      9  111c							; lines.
     10  111c							;
     11  111c		       11 1c	   IL	      equ	*
     12  111c
     13  111c							;THE IL CONTROL SECTION
     14  111c
     15  111c				   START
      0  111c					      INIT		;INITIALIZE
      0  111c					      db	22
      1  111c		       16		      .byte.b	22
      0  111d					      NLINE		;WRITE CRLF
      0  111d					      db	5
      1  111d		       05		      .byte.b	5
      0  111e					      ERRGOTO	CO	;where to go after an error
      0  111e					      db	31
      1  111e		       1f		      .byte.b	31
      0  111f					      dw	CO
      1  111f		       22 11		      .word.w	CO
      0  1121					      VINIT		;clear all variables
      0  1121					      db	30
      1  1121		       1e		      .byte.b	30
     20  1122							;
     21  1122							; This is where we jump to get a line of commands or
     22  1122							; a program from the user.
     23  1122							;
     24  1122				   CO
      0  1122					      GETLINE		;WRITE PROMPT AND GET LINE
      0  1122					      db	23
      1  1122		       17		      .byte.b	23
      0  1123					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1123					      db	34
      1  1123		       22		      .byte.b	34
      0  1124					      db	(XEC-*)-1
      1  1124		       04		      .byte.b	(XEC-*)-1
      0  1125					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1125					      db	24
      1  1125		       18		      .byte.b	24
      0  1126					      IJMP	CO
      0  1126					      db	29
      1  1126		       1d		      .byte.b	29
      0  1127					      dw	CO
      1  1127		       22 11		      .word.w	CO
     29  1129				   XEC
      0  1129					      XINIT		;INITIALIZE
      0  1129					      db	0
      1  1129		       00		      .byte.b	0
     31  112a
     32  112a							;STATEMENT EXECUTOR
     33  112a				   STMT
      0  112a					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  112a					      db	57
      1  112a		       39		      .byte.b	57
      0  112b					      db	(notirq-*)-1
      1  112b		       00		      .byte.b	(notirq-*)-1
     35  112c				   notirq
      0  112c					      TASKSWITCH		;if this is not a irq then check for task switch
      0  112c					      db	61
      1  112c		       3d		      .byte.b	61
      0  112d					      TSTLET	LET	;Test if second field is =
      0  112d					      db	49
      1  112d		       31		      .byte.b	49
      0  112e					      db	(LET-*)-1
      1  112e		       03		      .byte.b	(LET-*)-1
      0  112f					      IJMP	DOLET	;allow the default to be let
      0  112f					      db	29
      1  112f		       1d		      .byte.b	29
      0  1130					      dw	DOLET
      1  1130		       38 11		      .word.w	DOLET
     39  1132				   LET
      0  1132					      TST	S1,"LET"	;IS STATEMENT A LET
      0  1132					      db	32
      1  1132		       20		      .byte.b	32
      0  1133					      db	(S1-*)-1
      1  1133		       21		      .byte.b	(S1-*)-1
      0  1134					      db	"LET",0
      1  1134		       4c 45 54 00	      .byte.b	"LET",0
     41  1138				   DOLET
      0  1138					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1138					      db	33
      1  1138		       21		      .byte.b	33
      0  1139					      db	(ERRVEC-*)-1
      1  1139		       b0		      .byte.b	(ERRVEC-*)-1
      0  113a					      TST	LETBE,"["
      0  113a					      db	32
      1  113a		       20		      .byte.b	32
      0  113b					      db	(LETBE-*)-1
      1  113b		       0a		      .byte.b	(LETBE-*)-1
      0  113c					      db	"[",0
      1  113c		       5b 00		      .byte.b	"[",0
      0  113e					      CALL	EXPR
      0  113e					      db	28
      1  113e		       1c		      .byte.b	28
      0  113f					      dw	EXPR
      1  113f		       18 13		      .word.w	EXPR
      0  1141					      TST	ERRVEC,"]"
      0  1141					      db	32
      1  1141		       20		      .byte.b	32
      0  1142					      db	(ERRVEC-*)-1
      1  1142		       a7		      .byte.b	(ERRVEC-*)-1
      0  1143					      db	"]",0
      1  1143		       5d 00		      .byte.b	"]",0
      0  1145					      SUBSCRIPT
      0  1145					      db	65
      1  1145		       41		      .byte.b	65
     47  1146				   LETBE
      0  1146					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1146					      db	32
      1  1146		       20		      .byte.b	32
      0  1147					      db	(ERRVEC-*)-1
      1  1147		       a2		      .byte.b	(ERRVEC-*)-1
      0  1148					      db	"=",0
      1  1148		       3d 00		      .byte.b	"=",0
      0  114a					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  114a					      db	28
      1  114a		       1c		      .byte.b	28
      0  114b					      dw	EXPR
      1  114b		       18 13		      .word.w	EXPR
      0  114d					      DONE		;REPORT ERROR IF NOT NEXT
      0  114d					      db	1
      1  114d		       01		      .byte.b	1
      0  114e					      STORE		;STORE RESULT
      0  114e					      db	19
      1  114e		       13		      .byte.b	19
      0  114f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  114f					      db	6
      1  114f		       06		      .byte.b	6
      0  1150					      dw	CO
      1  1150		       22 11		      .word.w	CO
      0  1152					      IJMP	STMT
      0  1152					      db	29
      1  1152		       1d		      .byte.b	29
      0  1153					      dw	STMT
      1  1153		       2a 11		      .word.w	STMT
     54  1155				   S1
      0  1155					      TST	S1S1,"IRET"	;test return from interupt
      0  1155					      db	32
      1  1155		       20		      .byte.b	32
      0  1156					      db	(S1S1-*)-1
      1  1156		       10		      .byte.b	(S1S1-*)-1
      0  1157					      db	"IRET",0
      1  1157		       49 52 45 54*	      .byte.b	"IRET",0
      0  115c					      TST	S1Sa,"URN"
      0  115c					      db	32
      1  115c		       20		      .byte.b	32
      0  115d					      db	(S1Sa-*)-1
      1  115d		       04		      .byte.b	(S1Sa-*)-1
      0  115e					      db	"URN",0
      1  115e		       55 52 4e 00	      .byte.b	"URN",0
     57  1162				   S1Sa
      0  1162					      DONE		;Must be only thing on the line
      0  1162					      db	1
      1  1162		       01		      .byte.b	1
      0  1163					      IRET		;RESTORE LINE NUMBER OF CALL
      0  1163					      db	58
      1  1163		       3a		      .byte.b	58
      0  1164					      IJMP	STMT
      0  1164					      db	29
      1  1164		       1d		      .byte.b	29
      0  1165					      dw	STMT
      1  1165		       2a 11		      .word.w	STMT
     61  1167
     62  1167				   S1S1
      0  1167					      TST	S1Z,"IF"	;IF STATEMENT
      0  1167					      db	32
      1  1167		       20		      .byte.b	32
      0  1168					      db	(S1Z-*)-1
      1  1168		       11		      .byte.b	(S1Z-*)-1
      0  1169					      db	"IF",0
      1  1169		       49 46 00 	      .byte.b	"IF",0
      0  116c					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  116c					      db	28
      1  116c		       1c		      .byte.b	28
      0  116d					      dw	EXPR
      1  116d		       18 13		      .word.w	EXPR
      0  116f					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  116f					      db	32
      1  116f		       20		      .byte.b	32
      0  1170					      db	(S1W-*)-1
      1  1170		       05		      .byte.b	(S1W-*)-1
      0  1171					      db	"THEN",0
      1  1171		       54 48 45 4e*	      .byte.b	"THEN",0
     66  1176				   S1W
      0  1176					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1176					      db	54
      1  1176		       36		      .byte.b	54
      0  1177					      IJMP	STMT
      0  1177					      db	29
      1  1177		       1d		      .byte.b	29
      0  1178					      dw	STMT
      1  1178		       2a 11		      .word.w	STMT
     69  117a
     70  117a				   S1Z
      0  117a					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  117a					      db	32
      1  117a		       20		      .byte.b	32
      0  117b					      db	(S2b-*)-1
      1  117b		       18		      .byte.b	(S2b-*)-1
      0  117c					      db	"GO",0
      1  117c		       47 4f 00 	      .byte.b	"GO",0
      0  117f					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  117f					      db	32
      1  117f		       20		      .byte.b	32
      0  1180					      db	(S2-*)-1
      1  1180		       07		      .byte.b	(S2-*)-1
      0  1181					      db	"TO",0
      1  1181		       54 4f 00 	      .byte.b	"TO",0
      0  1184					      CALL	EXPR	;GET LABEL
      0  1184					      db	28
      1  1184		       1c		      .byte.b	28
      0  1185					      dw	EXPR
      1  1185		       18 13		      .word.w	EXPR
      0  1187					      XFER		;SET UP AND JUMP
      0  1187					      db	7
      1  1187		       07		      .byte.b	7
     75  1188				   S2
      0  1188					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1188					      db	32
      1  1188		       20		      .byte.b	32
      0  1189					      db	(ERRVEC-*)-1
      1  1189		       60		      .byte.b	(ERRVEC-*)-1
      0  118a					      db	"SUB",0
      1  118a		       53 55 42 00	      .byte.b	"SUB",0
      0  118e					      CALL	EXPR	;GET DESTINATION
      0  118e					      db	28
      1  118e		       1c		      .byte.b	28
      0  118f					      dw	EXPR
      1  118f		       18 13		      .word.w	EXPR
      0  1191					      DONE		;ERROR IF CR NOT NEXT
      0  1191					      db	1
      1  1191		       01		      .byte.b	1
      0  1192					      SAV		;SAVE RETURN LINE
      0  1192					      db	8
      1  1192		       08		      .byte.b	8
      0  1193					      XFER		;AND JUMP
      0  1193					      db	7
      1  1193		       07		      .byte.b	7
     81  1194				   S2b
      0  1194					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1194					      db	32
      1  1194		       20		      .byte.b	32
      0  1195					      db	(S3-*)-1
      1  1195		       1f		      .byte.b	(S3-*)-1
      0  1196					      db	"RE",0
      1  1196		       52 45 00 	      .byte.b	"RE",0
      0  1199					      TST	S2a,"T"
      0  1199					      db	32
      1  1199		       20		      .byte.b	32
      0  119a					      db	(S2a-*)-1
      1  119a		       10		      .byte.b	(S2a-*)-1
      0  119b					      db	"T",0
      1  119b		       54 00		      .byte.b	"T",0
      0  119d					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  119d					      db	32
      1  119d		       20		      .byte.b	32
      0  119e					      db	(S2aa-*)-1
      1  119e		       04		      .byte.b	(S2aa-*)-1
      0  119f					      db	"URN",0
      1  119f		       55 52 4e 00	      .byte.b	"URN",0
     85  11a3				   S2aa
      0  11a3					      DONE		;MUST BE CR
      0  11a3					      db	1
      1  11a3		       01		      .byte.b	1
      0  11a4					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  11a4					      db	9
      1  11a4		       09		      .byte.b	9
      0  11a5					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  11a5					      db	6
      1  11a5		       06		      .byte.b	6
      0  11a6					      dw	CO
      1  11a6		       22 11		      .word.w	CO
      0  11a8					      IJMP	STMT
      0  11a8					      db	29
      1  11a8		       1d		      .byte.b	29
      0  11a9					      dw	STMT
      1  11a9		       2a 11		      .word.w	STMT
     90  11ab				   S2a
      0  11ab					      TST	S3,"M"	;REMark.  Skip rest of line
      0  11ab					      db	32
      1  11ab		       20		      .byte.b	32
      0  11ac					      db	(S3-*)-1
      1  11ac		       08		      .byte.b	(S3-*)-1
      0  11ad					      db	"M",0
      1  11ad		       4d 00		      .byte.b	"M",0
      0  11af					      NXT	CO
      0  11af					      db	6
      1  11af		       06		      .byte.b	6
      0  11b0					      dw	CO
      1  11b0		       22 11		      .word.w	CO
      0  11b2					      IJMP	STMT
      0  11b2					      db	29
      1  11b2		       1d		      .byte.b	29
      0  11b3					      dw	STMT
      1  11b3		       2a 11		      .word.w	STMT
     94  11b5
     95  11b5				   S3
      0  11b5					      TST	S3a,"?"	; ? symonym for print
      0  11b5					      db	32
      1  11b5		       20		      .byte.b	32
      0  11b6					      db	(S3a-*)-1
      1  11b6		       05		      .byte.b	(S3a-*)-1
      0  11b7					      db	"?",0
      1  11b7		       3f 00		      .byte.b	"?",0
      0  11b9					      IJMP	S4
      0  11b9					      db	29
      1  11b9		       1d		      .byte.b	29
      0  11ba					      dw	S4
      1  11ba		       c7 11		      .word.w	S4
     98  11bc				   S3a
      0  11bc					      TST	S8,"PR"	;allow short form of print
      0  11bc					      db	32
      1  11bc		       20		      .byte.b	32
      0  11bd					      db	(S8-*)-1
      1  11bd		       49		      .byte.b	(S8-*)-1
      0  11be					      db	"PR",0
      1  11be		       50 52 00 	      .byte.b	"PR",0
      0  11c1					      TST	S4,"INT"	;PRINT
      0  11c1					      db	32
      1  11c1		       20		      .byte.b	32
      0  11c2					      db	(S4-*)-1
      1  11c2		       04		      .byte.b	(S4-*)-1
      0  11c3					      db	"INT",0
      1  11c3		       49 4e 54 00	      .byte.b	"INT",0
    101  11c7				   S4
      0  11c7					      TSTDONE	S4a	;Test if we just want crlf printed
      0  11c7					      db	50
      1  11c7		       32		      .byte.b	50
      0  11c8					      db	(S4a-*)-1
      1  11c8		       03		      .byte.b	(S4a-*)-1
      0  11c9					      IJMP	S6
      0  11c9					      db	29
      1  11c9		       1d		      .byte.b	29
      0  11ca					      dw	S6
      1  11ca		       e2 11		      .word.w	S6
    104  11cc
    105  11cc				   S4a
      0  11cc					      TSTSTR	S7	;TEST FOR QUOTED String
      0  11cc					      db	55
      1  11cc		       37		      .byte.b	55
      0  11cd					      db	(S7-*)-1
      1  11cd		       1f		      .byte.b	(S7-*)-1
      0  11ce					      PRS		;PRINT STRING
      0  11ce					      db	2
      1  11ce		       02		      .byte.b	2
    108  11cf				   S5
      0  11cf					      TST	S6A,COMMA	;IS THERE MORE?
      0  11cf					      db	32
      1  11cf		       20		      .byte.b	32
      0  11d0					      db	(S6A-*)-1
      1  11d0		       08		      .byte.b	(S6A-*)-1
      0  11d1					      db	COMMA,0
      1  11d1		       2c 00		      .byte.b	COMMA,0
      0  11d3					      SPC		;SPACE TO NEXT ZONE
      0  11d3					      db	4
      1  11d3		       04		      .byte.b	4
      0  11d4					      TSTDONE	S4	;Not end of line jump back
      0  11d4					      db	50
      1  11d4		       32		      .byte.b	50
      0  11d5					      db	(S4-*)-1
      1  11d5		       f1		      .byte.b	(S4-*)-1
      0  11d6					      IJMP	S6Z	;YES JUMP BACK
      0  11d6					      db	29
      1  11d6		       1d		      .byte.b	29
      0  11d7					      dw	S6Z
      1  11d7		       e4 11		      .word.w	S6Z
    113  11d9
    114  11d9							;
    115  11d9							; If a semicolon, don't do anything.
    116  11d9							;
    117  11d9				   S6A
      0  11d9					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  11d9					      db	32
      1  11d9		       20		      .byte.b	32
      0  11da					      db	(S6-*)-1
      1  11da		       07		      .byte.b	(S6-*)-1
      0  11db					      db	SEMICOLON,0
      1  11db		       3b 00		      .byte.b	SEMICOLON,0
      0  11dd					      TSTDONE	S4	;Jump Back if not end of line
      0  11dd					      db	50
      1  11dd		       32		      .byte.b	50
      0  11de					      db	(S4-*)-1
      1  11de		       e8		      .byte.b	(S4-*)-1
      0  11df					      IJMP	S6Z
      0  11df					      db	29
      1  11df		       1d		      .byte.b	29
      0  11e0					      dw	S6Z
      1  11e0		       e4 11		      .word.w	S6Z
    121  11e2				   S6
      0  11e2					      DONE		;ERROR IF CR NOT NEXT
      0  11e2					      db	1
      1  11e2		       01		      .byte.b	1
      0  11e3					      NLINE
      0  11e3					      db	5
      1  11e3		       05		      .byte.b	5
    124  11e4				   S6Z
      0  11e4					      NXT	CO	;exit here if , or ; at end of print
      0  11e4					      db	6
      1  11e4		       06		      .byte.b	6
      0  11e5					      dw	CO
      1  11e5		       22 11		      .word.w	CO
      0  11e7					      IJMP	STMT
      0  11e7					      db	29
      1  11e7		       1d		      .byte.b	29
      0  11e8					      dw	STMT
      1  11e8		       2a 11		      .word.w	STMT
    127  11ea							;
    128  11ea							; A jump for code too far away for relative branch
    129  11ea							;
    130  11ea				   ERRVEC
      0  11ea					      IJMP	UNKNOWN
      0  11ea					      db	29
      1  11ea		       1d		      .byte.b	29
      0  11eb					      dw	UNKNOWN
      1  11eb		       15 13		      .word.w	UNKNOWN
    132  11ed							;
    133  11ed							; Get here if there is an expression to print
    134  11ed				   S7
      0  11ed					      TST	S7A,"$"
      0  11ed					      db	32
      1  11ed		       20		      .byte.b	32
      0  11ee					      db	(S7A-*)-1
      1  11ee		       09		      .byte.b	(S7A-*)-1
      0  11ef					      db	"$",0
      1  11ef		       24 00		      .byte.b	"$",0
      0  11f1					      CALL	EXPR
      0  11f1					      db	28
      1  11f1		       1c		      .byte.b	28
      0  11f2					      dw	EXPR
      1  11f2		       18 13		      .word.w	EXPR
      0  11f4					      HEXPRT
      0  11f4					      db	68
      1  11f4		       44		      .byte.b	68
      0  11f5					      IJMP	S5
      0  11f5					      db	29
      1  11f5		       1d		      .byte.b	29
      0  11f6					      dw	S5
      1  11f6		       cf 11		      .word.w	S5
    139  11f8				   S7A
      0  11f8					      CALL	EXPR
      0  11f8					      db	28
      1  11f8		       1c		      .byte.b	28
      0  11f9					      dw	EXPR
      1  11f9		       18 13		      .word.w	EXPR
      0  11fb					      TST	S7B,"$"
      0  11fb					      db	32
      1  11fb		       20		      .byte.b	32
      0  11fc					      db	(S7B-*)-1
      1  11fc		       06		      .byte.b	(S7B-*)-1
      0  11fd					      db	"$",0
      1  11fd		       24 00		      .byte.b	"$",0
      0  11ff					      PUTCHAR
      0  11ff					      db	52
      1  11ff		       34		      .byte.b	52
      0  1200					      IJMP	S5
      0  1200					      db	29
      1  1200		       1d		      .byte.b	29
      0  1201					      dw	S5
      1  1201		       cf 11		      .word.w	S5
    144  1203				   S7B
      0  1203					      PRN		;PRINT IT
      0  1203					      db	3
      1  1203		       03		      .byte.b	3
      0  1204					      IJMP	S5	;IS THERE MORE?
      0  1204					      db	29
      1  1204		       1d		      .byte.b	29
      0  1205					      dw	S5
      1  1205		       cf 11		      .word.w	S5
    147  1207							;
    148  1207							;===========================================================
    149  1207							; End of TASK process
    150  1207				   S8
      0  1207					      TST	S8G,"ETASK"	; End task
      0  1207					      db	32
      1  1207		       20		      .byte.b	32
      0  1208					      db	(S8G-*)-1
      1  1208		       0b		      .byte.b	(S8G-*)-1
      0  1209					      db	"ETASK",0
      1  1209		       45 54 41 53*	      .byte.b	"ETASK",0
      0  120f					      ETASK
      0  120f					      db	63
      1  120f		       3f		      .byte.b	63
      0  1210					      DONE		; Must be last thing on a line
      0  1210					      db	1
      1  1210		       01		      .byte.b	1
      0  1211					      IJMP	STMT
      0  1211					      db	29
      1  1211		       1d		      .byte.b	29
      0  1212					      dw	STMT
      1  1212		       2a 11		      .word.w	STMT
    155  1214							;
    156  1214							;===========================================================
    157  1214							; The task gives up the rest of the cycles
    158  1214				   S8G
      0  1214					      TST	S8a,"NTASK"	;Next task
      0  1214					      db	32
      1  1214		       20		      .byte.b	32
      0  1215					      db	(S8a-*)-1
      1  1215		       0d		      .byte.b	(S8a-*)-1
      0  1216					      db	"NTASK",0
      1  1216		       4e 54 41 53*	      .byte.b	"NTASK",0
      0  121c					      NTASK
      0  121c					      db	64
      1  121c		       40		      .byte.b	64
      0  121d					      NXT	CO	;Next statement to execute
      0  121d					      db	6
      1  121d		       06		      .byte.b	6
      0  121e					      dw	CO
      1  121e		       22 11		      .word.w	CO
      0  1220					      IJMP	STMT
      0  1220					      db	29
      1  1220		       1d		      .byte.b	29
      0  1221					      dw	STMT
      1  1221		       2a 11		      .word.w	STMT
    163  1223							;
    164  1223							;===========================================================
    165  1223							; Update a memory location with a value
    166  1223				   S8a
      0  1223					      TST	S8b,"POKE"	;Poke a value into memory
      0  1223					      db	32
      1  1223		       20		      .byte.b	32
      0  1224					      db	(S8b-*)-1
      1  1224		       17		      .byte.b	(S8b-*)-1
      0  1225					      db	"POKE",0
      1  1225		       50 4f 4b 45*	      .byte.b	"POKE",0
      0  122a					      CALL	EXPR	;Get address to write to
      0  122a					      db	28
      1  122a		       1c		      .byte.b	28
      0  122b					      dw	EXPR
      1  122b		       18 13		      .word.w	EXPR
      0  122d					      TST	UNKNOWN,COMMA	;Must have a coma
      0  122d					      db	32
      1  122d		       20		      .byte.b	32
      0  122e					      db	(UNKNOWN-*)-1
      1  122e		       e6		      .byte.b	(UNKNOWN-*)-1
      0  122f					      db	COMMA,0
      1  122f		       2c 00		      .byte.b	COMMA,0
      0  1231					      CALL	EXPR	;Get the value to poke
      0  1231					      db	28
      1  1231		       1c		      .byte.b	28
      0  1232					      dw	EXPR
      1  1232		       18 13		      .word.w	EXPR
      0  1234					      POKEMEM
      0  1234					      db	47
      1  1234		       2f		      .byte.b	47
      0  1235					      DONE
      0  1235					      db	1
      1  1235		       01		      .byte.b	1
      0  1236					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1236					      db	6
      1  1236		       06		      .byte.b	6
      0  1237					      dw	CO
      1  1237		       22 11		      .word.w	CO
      0  1239					      IJMP	STMT
      0  1239					      db	29
      1  1239		       1d		      .byte.b	29
      0  123a					      dw	STMT
      1  123a		       2a 11		      .word.w	STMT
    175  123c
    176  123c				   S8b
      0  123c					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  123c					      db	32
      1  123c		       20		      .byte.b	32
      0  123d					      db	(S8c-*)-1
      1  123d		       11		      .byte.b	(S8c-*)-1
      0  123e					      db	"PUTCH",0
      1  123e		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1244					      CALL	EXPR
      0  1244					      db	28
      1  1244		       1c		      .byte.b	28
      0  1245					      dw	EXPR
      1  1245		       18 13		      .word.w	EXPR
      0  1247					      PUTCHAR
      0  1247					      db	52
      1  1247		       34		      .byte.b	52
      0  1248					      DONE
      0  1248					      db	1
      1  1248		       01		      .byte.b	1
      0  1249					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1249					      db	6
      1  1249		       06		      .byte.b	6
      0  124a					      dw	CO
      1  124a		       22 11		      .word.w	CO
      0  124c					      IJMP	STMT
      0  124c					      db	29
      1  124c		       1d		      .byte.b	29
      0  124d					      dw	STMT
      1  124d		       2a 11		      .word.w	STMT
    183  124f				   S8c
      0  124f					      TST	S9,"CLS"	;Clear the screen
      0  124f					      db	32
      1  124f		       20		      .byte.b	32
      0  1250					      db	(S9-*)-1
      1  1250		       0b		      .byte.b	(S9-*)-1
      0  1251					      db	"CLS",0
      1  1251		       43 4c 53 00	      .byte.b	"CLS",0
      0  1255					      CLEARSCREEN
      0  1255					      db	46
      1  1255		       2e		      .byte.b	46
      0  1256					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1256					      db	6
      1  1256		       06		      .byte.b	6
      0  1257					      dw	CO
      1  1257		       22 11		      .word.w	CO
      0  1259					      IJMP	STMT
      0  1259					      db	29
      1  1259		       1d		      .byte.b	29
      0  125a					      dw	STMT
      1  125a		       2a 11		      .word.w	STMT
    188  125c				   S9
      0  125c					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  125c					      db	32
      1  125c		       20		      .byte.b	32
      0  125d					      db	(S13-*)-1
      1  125d		       2a		      .byte.b	(S13-*)-1
      0  125e					      db	"INPUT",0
      1  125e		       49 4e 50 55*	      .byte.b	"INPUT",0
    190  1264				   S10
      0  1264					      TSTSTR	S10A	;If there is a string print the prompt
      0  1264					      db	55
      1  1264		       37		      .byte.b	55
      0  1265					      db	(S10A-*)-1
      1  1265		       05		      .byte.b	(S10A-*)-1
      0  1266					      PRS
      0  1266					      db	2
      1  1266		       02		      .byte.b	2
      0  1267					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1267					      db	32
      1  1267		       20		      .byte.b	32
      0  1268					      db	(S10Z-*)-1
      1  1268		       15		      .byte.b	(S10Z-*)-1
      0  1269					      db	SEMICOLON,0
      1  1269		       3b 00		      .byte.b	SEMICOLON,0
    194  126b				   S10A
      0  126b					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  126b					      db	33
      1  126b		       21		      .byte.b	33
      0  126c					      db	(UNKNOWN-*)-1
      1  126c		       a8		      .byte.b	(UNKNOWN-*)-1
      0  126d					      TST	S10A1,DOLLAR
      0  126d					      db	32
      1  126d		       20		      .byte.b	32
      0  126e					      db	(S10A1-*)-1
      1  126e		       06		      .byte.b	(S10A1-*)-1
      0  126f					      db	DOLLAR,0
      1  126f		       24 00		      .byte.b	DOLLAR,0
      0  1271					      INSTR
      0  1271					      db	59
      1  1271		       3b		      .byte.b	59
      0  1272					      IJMP	S10A2
      0  1272					      db	29
      1  1272		       1d		      .byte.b	29
      0  1273					      dw	S10A2
      1  1273		       76 12		      .word.w	S10A2
    199  1275				   S10A1
      0  1275					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1275					      db	11
      1  1275		       0b		      .byte.b	11
    201  1276				   S10A2
      0  1276					      STORE		;STORE IT
      0  1276					      db	19
      1  1276		       13		      .byte.b	19
      0  1277					      TST	S11,COMMA	;IS THERE MORE?
      0  1277					      db	32
      1  1277		       20		      .byte.b	32
      0  1278					      db	(S11-*)-1
      1  1278		       08		      .byte.b	(S11-*)-1
      0  1279					      db	COMMA,0
      1  1279		       2c 00		      .byte.b	COMMA,0
      0  127b					      IJMP	S10	;YES
      0  127b					      db	29
      1  127b		       1d		      .byte.b	29
      0  127c					      dw	S10
      1  127c		       64 12		      .word.w	S10
    205  127e				   S10Z
      0  127e					      iJMP	UNKNOWN
      0  127e					      db	29
      1  127e		       1d		      .byte.b	29
      0  127f					      dw	UNKNOWN
      1  127f		       15 13		      .word.w	UNKNOWN
    207  1281				   S11
      0  1281					      DONE		;MUST BE CR
      0  1281					      db	1
      1  1281		       01		      .byte.b	1
      0  1282					      NXT	CO	;SEQUENCE TO NEXT
      0  1282					      db	6
      1  1282		       06		      .byte.b	6
      0  1283					      dw	CO
      1  1283		       22 11		      .word.w	CO
      0  1285					      IJMP	STMT
      0  1285					      db	29
      1  1285		       1d		      .byte.b	29
      0  1286					      dw	STMT
      1  1286		       2a 11		      .word.w	STMT
    211  1288				   S13
      0  1288					      TST	S14,"END"
      0  1288					      db	32
      1  1288		       20		      .byte.b	32
      0  1289					      db	(S14-*)-1
      1  1289		       05		      .byte.b	(S14-*)-1
      0  128a					      db	"END",0
      1  128a		       45 4e 44 00	      .byte.b	"END",0
      0  128e					      FIN
      0  128e					      db	12
      1  128e		       0c		      .byte.b	12
    214  128f
    215  128f				   S14
      0  128f					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  128f					      db	32
      1  128f		       20		      .byte.b	32
      0  1290					      db	(S14Z-*)-1
      1  1290		       0f		      .byte.b	(S14Z-*)-1
      0  1291					      db	"IRQ",0
      1  1291		       49 52 51 00	      .byte.b	"IRQ",0
      0  1295					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1295					      db	28
      1  1295		       1c		      .byte.b	28
      0  1296					      dw	EXPR
      1  1296		       18 13		      .word.w	EXPR
      0  1298					      DONE		;must be CR
      0  1298					      db	1
      1  1298		       01		      .byte.b	1
      0  1299					      SETIRQ		;Set the line number now
      0  1299					      db	56
      1  1299		       38		      .byte.b	56
      0  129a					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  129a					      db	6
      1  129a		       06		      .byte.b	6
      0  129b					      dw	CO
      1  129b		       22 11		      .word.w	CO
      0  129d					      IJMP	STMT
      0  129d					      db	29
      1  129d		       1d		      .byte.b	29
      0  129e					      dw	STMT
      1  129e		       2a 11		      .word.w	STMT
    222  12a0
    223  12a0				   S14Z
      0  12a0					      TST	S14S1,"KILL"	; Kill A running Task
      0  12a0					      db	32
      1  12a0		       20		      .byte.b	32
      0  12a1					      db	(S14S1-*)-1
      1  12a1		       10		      .byte.b	(S14S1-*)-1
      0  12a2					      db	"KILL",0
      1  12a2		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  12a7					      CALL	EXPR
      0  12a7					      db	28
      1  12a7		       1c		      .byte.b	28
      0  12a8					      dw	EXPR
      1  12a8		       18 13		      .word.w	EXPR
      0  12aa					      DONE
      0  12aa					      db	1
      1  12aa		       01		      .byte.b	1
      0  12ab					      TASKKILL
      0  12ab					      db	66
      1  12ab		       42		      .byte.b	66
      0  12ac					      NXT	CO
      0  12ac					      db	6
      1  12ac		       06		      .byte.b	6
      0  12ad					      dw	CO
      1  12ad		       22 11		      .word.w	CO
      0  12af					      IJMP	STMT
      0  12af					      db	29
      1  12af		       1d		      .byte.b	29
      0  12b0					      dw	STMT
      1  12b0		       2a 11		      .word.w	STMT
    230  12b2
    231  12b2				   S14S1
      0  12b2					      TST	S15,"LIST"	;LIST COMMAND
      0  12b2					      db	32
      1  12b2		       20		      .byte.b	32
      0  12b3					      db	(S15-*)-1
      1  12b3		       0a		      .byte.b	(S15-*)-1
      0  12b4					      db	"LIST",0
      1  12b4		       4c 49 53 54*	      .byte.b	"LIST",0
      0  12b9					      DONE
      0  12b9					      db	1
      1  12b9		       01		      .byte.b	1
      0  12ba					      LST
      0  12ba					      db	21
      1  12ba		       15		      .byte.b	21
      0  12bb					      IJMP	CO
      0  12bb					      db	29
      1  12bb		       1d		      .byte.b	29
      0  12bc					      dw	CO
      1  12bc		       22 11		      .word.w	CO
    236  12be				   S15
      0  12be					      TST	S16,"RUN"	;RUN COMMAND
      0  12be					      db	32
      1  12be		       20		      .byte.b	32
      0  12bf					      db	(S16-*)-1
      1  12bf		       0d		      .byte.b	(S16-*)-1
      0  12c0					      db	"RUN",0
      1  12c0		       52 55 4e 00	      .byte.b	"RUN",0
      0  12c4					      DONE
      0  12c4					      db	1
      1  12c4		       01		      .byte.b	1
      0  12c5					      VINIT		;clear variables
      0  12c5					      db	30
      1  12c5		       1e		      .byte.b	30
      0  12c6					      LIT	1	;GOTO line 1
      0  12c6					      db	27
      1  12c6		       1b		      .byte.b	27
      0  12c7					      dw	1
      1  12c7		       01 00		      .word.w	1
      0  12c9					      XFER		;Bob's addition
      0  12c9					      db	7
      1  12c9		       07		      .byte.b	7
    242  12ca							; EXIT
      0  12ca					      IJMP	STMT	;and run!
      0  12ca					      db	29
      1  12ca		       1d		      .byte.b	29
      0  12cb					      dw	STMT
      1  12cb		       2a 11		      .word.w	STMT
    244  12cd				   S16
      0  12cd					      TST	S17A,"NEW"	;clear program
      0  12cd					      db	32
      1  12cd		       20		      .byte.b	32
      0  12ce					      db	(S17A-*)-1
      1  12ce		       08		      .byte.b	(S17A-*)-1
      0  12cf					      db	"NEW",0
      1  12cf		       4e 45 57 00	      .byte.b	"NEW",0
      0  12d3					      DONE
      0  12d3					      db	1
      1  12d3		       01		      .byte.b	1
      0  12d4					      IJMP	START
      0  12d4					      db	29
      1  12d4		       1d		      .byte.b	29
      0  12d5					      dw	START
      1  12d5		       1c 11		      .word.w	START
    248  12d7
    249  12d7				   S17A
      0  12d7					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  12d7					      db	32
      1  12d7		       20		      .byte.b	32
      0  12d8					      db	(S17B-*)-1
      1  12d8		       06		      .byte.b	(S17B-*)-1
      0  12d9					      db	"EXIT",0
      1  12d9		       45 58 49 54*	      .byte.b	"EXIT",0
      0  12de					      EXIT
      0  12de					      db	26
      1  12de		       1a		      .byte.b	26
    252  12df
    253  12df							;
    254  12df							; Commands related to saving/restoring programs
    255  12df							; to/from mass storage.
    256  12df							;
    257  12df				   S17B
    258  12df					      if	(XKIM || CTMON65) && DISK_ACCESS
    259  12df
      0  12df					      TST	S17C,"SAVE"
      0  12df					      db	32
      1  12df		       20		      .byte.b	32
      0  12e0					      db	(S17C-*)-1
      1  12e0		       0b		      .byte.b	(S17C-*)-1
      0  12e1					      db	"SAVE",0
      1  12e1		       53 41 56 45*	      .byte.b	"SAVE",0
      0  12e6					      OPENWRITE
      0  12e6					      db	40
      1  12e6		       28		      .byte.b	40
      0  12e7					      DLIST
      0  12e7					      db	43
      1  12e7		       2b		      .byte.b	43
      0  12e8					      DCLOSE
      0  12e8					      db	41
      1  12e8		       29		      .byte.b	41
      0  12e9					      IJMP	CO
      0  12e9					      db	29
      1  12e9		       1d		      .byte.b	29
      0  12ea					      dw	CO
      1  12ea		       22 11		      .word.w	CO
    265  12ec
    266  12ec				   S17C
      0  12ec					      TST	S18,"LOAD"
      0  12ec					      db	32
      1  12ec		       20		      .byte.b	32
      0  12ed					      db	(S18-*)-1
      1  12ed		       11		      .byte.b	(S18-*)-1
      0  12ee					      db	"LOAD",0
      1  12ee		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  12f3					      OPENREAD
      0  12f3					      db	39
      1  12f3		       27		      .byte.b	39
    269  12f4				   S17CLP
      0  12f4					      DGETLINE		;get line from file
      0  12f4					      db	42
      1  12f4		       2a		      .byte.b	42
      0  12f5					      TSTL	S17EOL	;no line num means EOL
      0  12f5					      db	34
      1  12f5		       22		      .byte.b	34
      0  12f6					      db	(S17EOL-*)-1
      1  12f6		       04		      .byte.b	(S17EOL-*)-1
      0  12f7					      INSERT		;put it into the program
      0  12f7					      db	24
      1  12f7		       18		      .byte.b	24
      0  12f8					      IJMP	S17CLP	;keep going
      0  12f8					      db	29
      1  12f8		       1d		      .byte.b	29
      0  12f9					      dw	S17CLP
      1  12f9		       f4 12		      .word.w	S17CLP
    274  12fb				   S17EOL
      0  12fb					      DCLOSE		;close disk file
      0  12fb					      db	41
      1  12fb		       29		      .byte.b	41
      0  12fc					      IJMP	CO	;back to start
      0  12fc					      db	29
      1  12fc		       1d		      .byte.b	29
      0  12fd					      dw	CO
      1  12fd		       22 11		      .word.w	CO
    277  12ff
      0  12ff				   S18	      TST	S19,"DIR"
      0  12ff					      db	32
      1  12ff		       20		      .byte.b	32
      0  1300					      db	(S19-*)-1
      1  1300		       08		      .byte.b	(S19-*)-1
      0  1301					      db	"DIR",0
      1  1301		       44 49 52 00	      .byte.b	"DIR",0
      0  1305					      DDIR		;Display the directory content
      0  1305					      db	44
      1  1305		       2c		      .byte.b	44
      0  1306					      IJMP	CO
      0  1306					      db	29
      1  1306		       1d		      .byte.b	29
      0  1307					      dw	CO
      1  1307		       22 11		      .word.w	CO
    281  1309					      endif
    282  1309
      0  1309				   S19	      TST	UNKNOWN,"ERASE"
      0  1309					      db	32
      1  1309		       20		      .byte.b	32
      0  130a					      db	(UNKNOWN-*)-1
      1  130a		       0a		      .byte.b	(UNKNOWN-*)-1
      0  130b					      db	"ERASE",0
      1  130b		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1311					      RMFILE		;Erase the file from the disk
      0  1311					      db	45
      1  1311		       2d		      .byte.b	45
      0  1312					      IJMP	CO
      0  1312					      db	29
      1  1312		       1d		      .byte.b	29
      0  1313					      dw	CO
      1  1313		       22 11		      .word.w	CO
    286  1313					      endif
    287  1315
    288  1315							;
    289  1315							; Else, unknown command.
    290  1315							;
    291  1315				   UNKNOWN
      0  1315					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1315					      db	13
      1  1315		       0d		      .byte.b	13
      0  1316					      dw	ERR_SYNTAX
      1  1316		       05 00		      .word.w	ERR_SYNTAX
    293  1318
    294  1318							;-----------------------------------------------------
    295  1318				   EXPR
      0  1318					      Call	EXPR2	; get the first expression
      0  1318					      db	28
      1  1318		       1c		      .byte.b	28
      0  1319					      dw	EXPR2
      1  1319		       63 13		      .word.w	EXPR2
      0  131b					      TST	iR0,"="
      0  131b					      db	32
      1  131b		       20		      .byte.b	32
      0  131c					      db	(iR0-*)-1
      1  131c		       08		      .byte.b	(iR0-*)-1
      0  131d					      db	"=",0
      1  131d		       3d 00		      .byte.b	"=",0
      0  131f					      LIT	2	;=
      0  131f					      db	27
      1  131f		       1b		      .byte.b	27
      0  1320					      dw	2
      1  1320		       02 00		      .word.w	2
      0  1322					      IJMP	iRFound
      0  1322					      db	29
      1  1322		       1d		      .byte.b	29
      0  1323					      dw	iRFound
      1  1323		       5e 13		      .word.w	iRFound
    300  1325				   iR0
      0  1325					      TST	iR4,"<"
      0  1325					      db	32
      1  1325		       20		      .byte.b	32
      0  1326					      db	(iR4-*)-1
      1  1326		       1c		      .byte.b	(iR4-*)-1
      0  1327					      db	"<",0
      1  1327		       3c 00		      .byte.b	"<",0
      0  1329					      TST	iR1,"="
      0  1329					      db	32
      1  1329		       20		      .byte.b	32
      0  132a					      db	(iR1-*)-1
      1  132a		       08		      .byte.b	(iR1-*)-1
      0  132b					      db	"=",0
      1  132b		       3d 00		      .byte.b	"=",0
      0  132d					      LIT	3	;<=
      0  132d					      db	27
      1  132d		       1b		      .byte.b	27
      0  132e					      dw	3
      1  132e		       03 00		      .word.w	3
      0  1330					      IJMP	iRFound
      0  1330					      db	29
      1  1330		       1d		      .byte.b	29
      0  1331					      dw	iRFound
      1  1331		       5e 13		      .word.w	iRFound
    305  1333				   iR1
      0  1333					      TST	iR3,">"
      0  1333					      db	32
      1  1333		       20		      .byte.b	32
      0  1334					      db	(iR3-*)-1
      1  1334		       08		      .byte.b	(iR3-*)-1
      0  1335					      db	">",0
      1  1335		       3e 00		      .byte.b	">",0
      0  1337					      LIT	5	;<>
      0  1337					      db	27
      1  1337		       1b		      .byte.b	27
      0  1338					      dw	5
      1  1338		       05 00		      .word.w	5
      0  133a					      IJMP	iRFound
      0  133a					      db	29
      1  133a		       1d		      .byte.b	29
      0  133b					      dw	iRFound
      1  133b		       5e 13		      .word.w	iRFound
    309  133d				   iR3
      0  133d					      LIT	1	;<
      0  133d					      db	27
      1  133d		       1b		      .byte.b	27
      0  133e					      dw	1
      1  133e		       01 00		      .word.w	1
      0  1340					      IJMP	iRFound
      0  1340					      db	29
      1  1340		       1d		      .byte.b	29
      0  1341					      dw	iRFound
      1  1341		       5e 13		      .word.w	iRFound
    312  1343				   iR4
      0  1343					      TST	iRDone,">"
      0  1343					      db	32
      1  1343		       20		      .byte.b	32
      0  1344					      db	(iRDone-*)-1
      1  1344		       1d		      .byte.b	(iRDone-*)-1
      0  1345					      db	">",0
      1  1345		       3e 00		      .byte.b	">",0
      0  1347					      TST	iR5,"="
      0  1347					      db	32
      1  1347		       20		      .byte.b	32
      0  1348					      db	(iR5-*)-1
      1  1348		       08		      .byte.b	(iR5-*)-1
      0  1349					      db	"=",0
      1  1349		       3d 00		      .byte.b	"=",0
      0  134b					      LIT	6	;>=
      0  134b					      db	27
      1  134b		       1b		      .byte.b	27
      0  134c					      dw	6
      1  134c		       06 00		      .word.w	6
      0  134e					      IJMP	iRFound
      0  134e					      db	29
      1  134e		       1d		      .byte.b	29
      0  134f					      dw	iRFound
      1  134f		       5e 13		      .word.w	iRFound
    317  1351				   iR5
      0  1351					      TST	iR6,"<"
      0  1351					      db	32
      1  1351		       20		      .byte.b	32
      0  1352					      db	(iR6-*)-1
      1  1352		       08		      .byte.b	(iR6-*)-1
      0  1353					      db	"<",0
      1  1353		       3c 00		      .byte.b	"<",0
      0  1355					      LIT	1
      0  1355					      db	27
      1  1355		       1b		      .byte.b	27
      0  1356					      dw	1
      1  1356		       01 00		      .word.w	1
      0  1358					      IJMP	iRFound	;(This line originally omitted)
      0  1358					      db	29
      1  1358		       1d		      .byte.b	29
      0  1359					      dw	iRFound
      1  1359		       5e 13		      .word.w	iRFound
    321  135b				   iR6
      0  135b					      LIT	4	;>
      0  135b					      db	27
      1  135b		       1b		      .byte.b	27
      0  135c					      dw	4
      1  135c		       04 00		      .word.w	4
    323  135e				   iRFound
      0  135e					      Call	EXPR2	; get the right side of the expression
      0  135e					      db	28
      1  135e		       1c		      .byte.b	28
      0  135f					      dw	EXPR2
      1  135f		       63 13		      .word.w	EXPR2
      0  1361					      CMPR		; Push the value of the true false onto the stack
      0  1361					      db	10
      1  1361		       0a		      .byte.b	10
    326  1362
    327  1362				   iRDone
      0  1362					      RTN
      0  1362					      db	25
      1  1362		       19		      .byte.b	25
    329  1363
    330  1363				   EXPR2
      0  1363					      TST	E0,"-"	; Look for leading - to negate term
      0  1363					      db	32
      1  1363		       20		      .byte.b	32
      0  1364					      db	(E0-*)-1
      1  1364		       09		      .byte.b	(E0-*)-1
      0  1365					      db	"-",0
      1  1365		       2d 00		      .byte.b	"-",0
      0  1367					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1367					      db	28
      1  1367		       1c		      .byte.b	28
      0  1368					      dw	TERM
      1  1368		       8c 13		      .word.w	TERM
      0  136a					      NEG		; Make value negated
      0  136a					      db	16
      1  136a		       10		      .byte.b	16
      0  136b					      IJMP	E1	; We have Left term process operators next
      0  136b					      db	29
      1  136b		       1d		      .byte.b	29
      0  136c					      dw	E1
      1  136c		       75 13		      .word.w	E1
    335  136e				   E0
      0  136e					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  136e					      db	32
      1  136e		       20		      .byte.b	32
      0  136f					      db	(E1A-*)-1
      1  136f		       02		      .byte.b	(E1A-*)-1
      0  1370					      db	"+",0
      1  1370		       2b 00		      .byte.b	"+",0
    337  1372				   E1A
      0  1372					      CALL	TERM	; Get the left term if it was not negated
      0  1372					      db	28
      1  1372		       1c		      .byte.b	28
      0  1373					      dw	TERM
      1  1373		       8c 13		      .word.w	TERM
    339  1375				   E1
      0  1375					      TST	E2,"+"	; Check if we are adding left term to something
      0  1375					      db	32
      1  1375		       20		      .byte.b	32
      0  1376					      db	(E2-*)-1
      1  1376		       09		      .byte.b	(E2-*)-1
      0  1377					      db	"+",0
      1  1377		       2b 00		      .byte.b	"+",0
      0  1379					      CALL	TERM	; if adding then get the right side term
      0  1379					      db	28
      1  1379		       1c		      .byte.b	28
      0  137a					      dw	TERM
      1  137a		       8c 13		      .word.w	TERM
      0  137c					      ADD		; Add it to left term
      0  137c					      db	14
      1  137c		       0e		      .byte.b	14
      0  137d					      IJMP	E1	; look for next + or -
      0  137d					      db	29
      1  137d		       1d		      .byte.b	29
      0  137e					      dw	E1
      1  137e		       75 13		      .word.w	E1
    344  1380				   E2
      0  1380					      TST	E3,"-"	; Check if we are subtractig something
      0  1380					      db	32
      1  1380		       20		      .byte.b	32
      0  1381					      db	(E3-*)-1
      1  1381		       09		      .byte.b	(E3-*)-1
      0  1382					      db	"-",0
      1  1382		       2d 00		      .byte.b	"-",0
      0  1384					      CALL	TERM	; get right side to subtract Diffrence
      0  1384					      db	28
      1  1384		       1c		      .byte.b	28
      0  1385					      dw	TERM
      1  1385		       8c 13		      .word.w	TERM
      0  1387					      SUB		; Subtract the value
      0  1387					      db	15
      1  1387		       0f		      .byte.b	15
      0  1388					      IJMP	E1	; Look for next + or -
      0  1388					      db	29
      1  1388		       1d		      .byte.b	29
      0  1389					      dw	E1
      1  1389		       75 13		      .word.w	E1
    349  138b				   E3			; Finish processing the expression
      0  138b					      RTN		; We are finished processing the Expression
      0  138b					      db	25
      1  138b		       19		      .byte.b	25
    351  138c							;
    352  138c							; Get one of the terms of an expression
    353  138c							;
    354  138c				   TERM
      0  138c					      CALL	FACT	; Get a value
      0  138c					      db	28
      1  138c		       1c		      .byte.b	28
      0  138d					      dw	FACT
      1  138d		       b4 13		      .word.w	FACT
    356  138f				   T0			; Check for higher precidence operators
      0  138f					      TST	T1,"*"	; Check for *
      0  138f					      db	32
      1  138f		       20		      .byte.b	32
      0  1390					      db	(T1-*)-1
      1  1390		       09		      .byte.b	(T1-*)-1
      0  1391					      db	"*",0
      1  1391		       2a 00		      .byte.b	"*",0
      0  1393					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1393					      db	28
      1  1393		       1c		      .byte.b	28
      0  1394					      dw	FACT
      1  1394		       b4 13		      .word.w	FACT
      0  1396					      MUL		; Multiply factors
      0  1396					      db	17
      1  1396		       11		      .byte.b	17
      0  1397					      IJMP	T0	; Check for * or /
      0  1397					      db	29
      1  1397		       1d		      .byte.b	29
      0  1398					      dw	T0
      1  1398		       8f 13		      .word.w	T0
    361  139a				   T1
      0  139a					      TST	T2,"/"	; Check for a division
      0  139a					      db	32
      1  139a		       20		      .byte.b	32
      0  139b					      db	(T2-*)-1
      1  139b		       09		      .byte.b	(T2-*)-1
      0  139c					      db	"/",0
      1  139c		       2f 00		      .byte.b	"/",0
      0  139e					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  139e					      db	28
      1  139e		       1c		      .byte.b	28
      0  139f					      dw	FACT
      1  139f		       b4 13		      .word.w	FACT
      0  13a1					      DIV		; do division
      0  13a1					      db	18
      1  13a1		       12		      .byte.b	18
      0  13a2					      IJMP	T0	; check for more * or /
      0  13a2					      db	29
      1  13a2		       1d		      .byte.b	29
      0  13a3					      dw	T0
      1  13a3		       8f 13		      .word.w	T0
    366  13a5				   T2
      0  13a5					      TST	T3,"%"	; Check for a division
      0  13a5					      db	32
      1  13a5		       20		      .byte.b	32
      0  13a6					      db	(T3-*)-1
      1  13a6		       09		      .byte.b	(T3-*)-1
      0  13a7					      db	"%",0
      1  13a7		       25 00		      .byte.b	"%",0
      0  13a9					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  13a9					      db	28
      1  13a9		       1c		      .byte.b	28
      0  13aa					      dw	FACT
      1  13aa		       b4 13		      .word.w	FACT
      0  13ac					      MODULO		; do division for remainder
      0  13ac					      db	60
      1  13ac		       3c		      .byte.b	60
      0  13ad					      IJMP	T0	; check for more * or / or %
      0  13ad					      db	29
      1  13ad		       1d		      .byte.b	29
      0  13ae					      dw	T0
      1  13ae		       8f 13		      .word.w	T0
    371  13b0				   T3			; Finish processing the Term
      0  13b0					      RTN
      0  13b0					      db	25
      1  13b0		       19		      .byte.b	25
    373  13b1
    374  13b1				   UNKNOWNVEC
      0  13b1					      IJMP	UNKNOWN
      0  13b1					      db	29
      1  13b1		       1d		      .byte.b	29
      0  13b2					      dw	UNKNOWN
      1  13b2		       15 13		      .word.w	UNKNOWN
    376  13b4
    377  13b4							;
    378  13b4							; Factor an expression.  Always test for functions
    379  13b4							; first or else they'll be confused for variables.
    380  13b4							;
    381  13b4				   FACT
      0  13b4					      TST	F1A,"FREE()"
      0  13b4					      db	32
      1  13b4		       20		      .byte.b	32
      0  13b5					      db	(F1A-*)-1
      1  13b5		       09		      .byte.b	(F1A-*)-1
      0  13b6					      db	"FREE()",0
      1  13b6		       46 52 45 45*	      .byte.b	"FREE()",0
      0  13bd					      FREE
      0  13bd					      db	36
      1  13bd		       24		      .byte.b	36
      0  13be					      RTN
      0  13be					      db	25
      1  13be		       19		      .byte.b	25
    385  13bf				   F1A
      0  13bf					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  13bf					      db	32
      1  13bf		       20		      .byte.b	32
      0  13c0					      db	(F1A2-*)-1
      1  13c0		       0a		      .byte.b	(F1A2-*)-1
      0  13c1					      db	"GETCH()",0
      1  13c1		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  13c9					      GETCHAR
      0  13c9					      db	51
      1  13c9		       33		      .byte.b	51
      0  13ca					      RTN
      0  13ca					      db	25
      1  13ca		       19		      .byte.b	25
    389  13cb				   F1A2
      0  13cb					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  13cb					      db	32
      1  13cb		       20		      .byte.b	32
      0  13cc					      db	(F2AZ-*)-1
      1  13cc		       0f		      .byte.b	(F2AZ-*)-1
      0  13cd					      db	"PEEK(",0
      1  13cd		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  13d3					      CALL	EXPR	;Get the address to write to
      0  13d3					      db	28
      1  13d3		       1c		      .byte.b	28
      0  13d4					      dw	EXPR
      1  13d4		       18 13		      .word.w	EXPR
      0  13d6					      TST	UNKNOWN,")"	;Closing bracket
      0  13d6					      db	32
      1  13d6		       20		      .byte.b	32
      0  13d7					      db	(UNKNOWN-*)-1
      1  13d7		       3d		      .byte.b	(UNKNOWN-*)-1
      0  13d8					      db	")",0
      1  13d8		       29 00		      .byte.b	")",0
      0  13da					      PEEKMEM
      0  13da					      db	48
      1  13da		       30		      .byte.b	48
      0  13db					      RTN
      0  13db					      db	25
      1  13db		       19		      .byte.b	25
    395  13dc				   F2AZ
      0  13dc					      TST	F2A,"TASK("	;Check if we are setting a task start
      0  13dc					      db	32
      1  13dc		       20		      .byte.b	32
      0  13dd					      db	(F2A-*)-1
      1  13dd		       0f		      .byte.b	(F2A-*)-1
      0  13de					      db	"TASK(",0
      1  13de		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  13e4					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  13e4					      db	28
      1  13e4		       1c		      .byte.b	28
      0  13e5					      dw	EXPR
      1  13e5		       18 13		      .word.w	EXPR
      0  13e7					      TST	UNKNOWN,")"	;must be )
      0  13e7					      db	32
      1  13e7		       20		      .byte.b	32
      0  13e8					      db	(UNKNOWN-*)-1
      1  13e8		       2c		      .byte.b	(UNKNOWN-*)-1
      0  13e9					      db	")",0
      1  13e9		       29 00		      .byte.b	")",0
      0  13eb					      SETTASK		;Set the Task up and start it
      0  13eb					      db	62
      1  13eb		       3e		      .byte.b	62
      0  13ec					      RTN		;Returns the Task number
      0  13ec					      db	25
      1  13ec		       19		      .byte.b	25
    401  13ed							;
    402  13ed							; RND() is supposed to have an argument but if none
    403  13ed							; was provided, just assume a large value.
    404  13ed							;
    405  13ed				   F2A
      0  13ed					      TST	F2B,"RND("
      0  13ed					      db	32
      1  13ed		       20		      .byte.b	32
      0  13ee					      db	(F2B-*)-1
      1  13ee		       17		      .byte.b	(F2B-*)-1
      0  13ef					      db	"RND(",0
      1  13ef		       52 4e 44 28*	      .byte.b	"RND(",0
      0  13f4					      TST	F2A1,")"
      0  13f4					      db	32
      1  13f4		       20		      .byte.b	32
      0  13f5					      db	(F2A1-*)-1
      1  13f5		       07		      .byte.b	(F2A1-*)-1
      0  13f6					      db	")",0
      1  13f6		       29 00		      .byte.b	")",0
      0  13f8					      LIT	32766
      0  13f8					      db	27
      1  13f8		       1b		      .byte.b	27
      0  13f9					      dw	32766
      1  13f9		       fe 7f		      .word.w	32766
      0  13fb					      RANDOM
      0  13fb					      db	37
      1  13fb		       25		      .byte.b	37
      0  13fc					      RTN
      0  13fc					      db	25
      1  13fc		       19		      .byte.b	25
    411  13fd				   F2A1
      0  13fd					      CALL	FACT	;GET RANGE
      0  13fd					      db	28
      1  13fd		       1c		      .byte.b	28
      0  13fe					      dw	FACT
      1  13fe		       b4 13		      .word.w	FACT
      0  1400					      TST	UNKNOWN,")"
      0  1400					      db	32
      1  1400		       20		      .byte.b	32
      0  1401					      db	(UNKNOWN-*)-1
      1  1401		       13		      .byte.b	(UNKNOWN-*)-1
      0  1402					      db	")",0
      1  1402		       29 00		      .byte.b	")",0
      0  1404					      RANDOM
      0  1404					      db	37
      1  1404		       25		      .byte.b	37
      0  1405					      RTN
      0  1405					      db	25
      1  1405		       19		      .byte.b	25
    416  1406
    417  1406				   F2B
      0  1406					      TST	F2B2,"ABS("
      0  1406					      db	32
      1  1406		       20		      .byte.b	32
      0  1407					      db	(F2B2-*)-1
      1  1407		       0e		      .byte.b	(F2B2-*)-1
      0  1408					      db	"ABS(",0
      1  1408		       41 42 53 28*	      .byte.b	"ABS(",0
      0  140d					      CALL	FACT	;get value
      0  140d					      db	28
      1  140d		       1c		      .byte.b	28
      0  140e					      dw	FACT
      1  140e		       b4 13		      .word.w	FACT
      0  1410					      TST	UNKNOWNVEC,")"
      0  1410					      db	32
      1  1410		       20		      .byte.b	32
      0  1411					      db	(UNKNOWNVEC-*)-1
      1  1411		       9f		      .byte.b	(UNKNOWNVEC-*)-1
      0  1412					      db	")",0
      1  1412		       29 00		      .byte.b	")",0
      0  1414					      ABS
      0  1414					      db	38
      1  1414		       26		      .byte.b	38
      0  1415					      RTN
      0  1415					      db	25
      1  1415		       19		      .byte.b	25
    423  1416
    424  1416				   F2B2
      0  1416					      TST	F2Z,"STAT("
      0  1416					      db	32
      1  1416		       20		      .byte.b	32
      0  1417					      db	(F2Z-*)-1
      1  1417		       0f		      .byte.b	(F2Z-*)-1
      0  1418					      db	"STAT(",0
      1  1418		       53 54 41 54*	      .byte.b	"STAT(",0
      0  141e					      Call	EXPR
      0  141e					      db	28
      1  141e		       1c		      .byte.b	28
      0  141f					      dw	EXPR
      1  141f		       18 13		      .word.w	EXPR
      0  1421					      TST	UNKNOWNVEC,")"
      0  1421					      db	32
      1  1421		       20		      .byte.b	32
      0  1422					      db	(UNKNOWNVEC-*)-1
      1  1422		       8e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1423					      db	")",0
      1  1423		       29 00		      .byte.b	")",0
      0  1425					      TASKSTAT
      0  1425					      db	67
      1  1425		       43		      .byte.b	67
      0  1426					      RTN
      0  1426					      db	25
      1  1426		       19		      .byte.b	25
    430  1427				   F2Z
      0  1427					      TST	F2C,"CALL("	;call machine function
      0  1427					      db	32
      1  1427		       20		      .byte.b	32
      0  1428					      db	(F2C-*)-1
      1  1428		       1f		      .byte.b	(F2C-*)-1
      0  1429					      db	"CALL(",0
      1  1429		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  142f					      CALL	EXPR
      0  142f					      db	28
      1  142f		       1c		      .byte.b	28
      0  1430					      dw	EXPR
      1  1430		       18 13		      .word.w	EXPR
      0  1432					      TST	F2B2A,COMMA
      0  1432					      db	32
      1  1432		       20		      .byte.b	32
      0  1433					      db	(F2B2A-*)-1
      1  1433		       0b		      .byte.b	(F2B2A-*)-1
      0  1434					      db	COMMA,0
      1  1434		       2c 00		      .byte.b	COMMA,0
      0  1436					      CALL	EXPR
      0  1436					      db	28
      1  1436		       1c		      .byte.b	28
      0  1437					      dw	EXPR
      1  1437		       18 13		      .word.w	EXPR
      0  1439					      TST	UNKNOWNVEC,")"
      0  1439					      db	32
      1  1439		       20		      .byte.b	32
      0  143a					      db	(UNKNOWNVEC-*)-1
      1  143a		       76		      .byte.b	(UNKNOWNVEC-*)-1
      0  143b					      db	")",0
      1  143b		       29 00		      .byte.b	")",0
      0  143d					      CALLFUNC
      0  143d					      db	53
      1  143d		       35		      .byte.b	53
      0  143e					      RTN
      0  143e					      db	25
      1  143e		       19		      .byte.b	25
      0  143f				   F2B2A      TST	UNKNOWNVEC,")"
      0  143f					      db	32
      1  143f		       20		      .byte.b	32
      0  1440					      db	(UNKNOWNVEC-*)-1
      1  1440		       70		      .byte.b	(UNKNOWNVEC-*)-1
      0  1441					      db	")",0
      1  1441		       29 00		      .byte.b	")",0
      0  1443					      LIT	0
      0  1443					      db	27
      1  1443		       1b		      .byte.b	27
      0  1444					      dw	0
      1  1444		       00 00		      .word.w	0
      0  1446					      CALLFUNC
      0  1446					      db	53
      1  1446		       35		      .byte.b	53
      0  1447					      RTN
      0  1447					      db	25
      1  1447		       19		      .byte.b	25
    442  1448				   F2C
      0  1448					      TSTV	F0
      0  1448					      db	33
      1  1448		       21		      .byte.b	33
      0  1449					      db	(F0-*)-1
      1  1449		       0e		      .byte.b	(F0-*)-1
      0  144a					      TST	F2C1,"["
      0  144a					      db	32
      1  144a		       20		      .byte.b	32
      0  144b					      db	(F2C1-*)-1
      1  144b		       0a		      .byte.b	(F2C1-*)-1
      0  144c					      db	"[",0
      1  144c		       5b 00		      .byte.b	"[",0
      0  144e					      CALL	EXPR
      0  144e					      db	28
      1  144e		       1c		      .byte.b	28
      0  144f					      dw	EXPR
      1  144f		       18 13		      .word.w	EXPR
      0  1451					      TST	UNKNOWNVEC,"]"
      0  1451					      db	32
      1  1451		       20		      .byte.b	32
      0  1452					      db	(UNKNOWNVEC-*)-1
      1  1452		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1453					      db	"]",0
      1  1453		       5d 00		      .byte.b	"]",0
      0  1455					      SUBSCRIPT
      0  1455					      db	65
      1  1455		       41		      .byte.b	65
    448  1456				   F2C1
      0  1456					      IND		;YES, GET THE VALUE.
      0  1456					      db	20
      1  1456		       14		      .byte.b	20
      0  1457					      RTN
      0  1457					      db	25
      1  1457		       19		      .byte.b	25
    451  1458				   F0
      0  1458					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1458					      db	35
      1  1458		       23		      .byte.b	35
      0  1459					      db	(F1-*)-1
      1  1459		       01		      .byte.b	(F1-*)-1
      0  145a					      RTN
      0  145a					      db	25
      1  145a		       19		      .byte.b	25
    454  145b				   F1
      0  145b					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  145b					      db	32
      1  145b		       20		      .byte.b	32
      0  145c					      db	(F2A-*)-1
      1  145c		       90		      .byte.b	(F2A-*)-1
      0  145d					      db	"(",0
      1  145d		       28 00		      .byte.b	"(",0
      0  145f					      CALL	EXPR
      0  145f					      db	28
      1  145f		       1c		      .byte.b	28
      0  1460					      dw	EXPR
      1  1460		       18 13		      .word.w	EXPR
      0  1462					      TST	F2,")"
      0  1462					      db	32
      1  1462		       20		      .byte.b	32
      0  1463					      db	(F2-*)-1
      1  1463		       03		      .byte.b	(F2-*)-1
      0  1464					      db	")",0
      1  1464		       29 00		      .byte.b	")",0
      0  1466					      RTN
      0  1466					      db	25
      1  1466		       19		      .byte.b	25
    459  1467
    460  1467				   F2
      0  1467					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1467					      db	13
      1  1467		       0d		      .byte.b	13
      0  1468					      dw	ERR_SYNTAX
      1  1468		       05 00		      .word.w	ERR_SYNTAX
    462  146a
    463  146a		       14 6a	   ILEND      equ	*
------- FILE mytb.asm
   2061  146a		       14 6a	   PROGEND    equ	*
   2062  146a
   2063  146a							;=====================================================
   2064  146a							;=====================================================
   2065  146a							;=====================================================
   2066  146a							; These are storage items not in page zero.
   2067  146a							;
   2068 Udf9e					      seg.u	Data
   2069 U146a					      org	PROGEND
   2070 U146a							;
   2071 U146a							; IRQ BASIC Code Service RTN Support
      0 U146a				   SaveIrqReg db	0	; Store current setting
      1 U146a		       00		      .byte.b	0
      0 U146b				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U146b		       00		      .byte.b	0
      0 U146c				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U146c		       00		      .byte.b	0
      0 U146d				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U146d		       00 00		      .byte.b	0,0
   2076 U146f							;
   2077 U146f							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2078 U146f							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2079 U146f							; Task switchs happen at the beginning of the next Basic command line
   2080 U146f							; It will not happen during an input or output operations
   2081 U146f							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2082 U146f							; Task Zero is always the root task, main line program
   2083 U146f		       00 00 00 00*taskTable  ds	TASKCOUNT*4	; Task Table Offset and pointer to Basic code, active flag
   2084 U1497		       00	   taskPtr    ds	1	; Current offset into task table 0, 3, 6,9 ...
   2085 U1498
   2086 U1498		       00 00 00 00*mathStack  ds	STACKSIZE*2	;Stack used for math expressions
   2087 U14c0		       00	   mathStackPtr ds	1
   2088 U14c1		       00 00 00 00*retStack   ds	ILSTACKSIZE*2	;stack used by the IL for calls and returns
   2089 U1511		       00	   retStackPtr ds	1
   2090 U1512							;callStack	 ds	 GOSUBSTACKSIZE*3   ; Allocated dynamically at App start
   2091 U1512		       00	   GoSubStackPtr ds	1
   2092 U1513
   2093 U1513
   2094 U1513							;
   2095 U1513							;
   2096 U1513		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2097 U1597		       00	   getlinx    ds	1
   2098 U1598		       00	   printtx    ds	1	;temp X for print funcs
   2099 U1599		       00	   diddigit   ds	1	;for leading zero suppression
   2100 U159a		       00	   putsy      ds	1
   2101 U159b		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2102 U159d		       00 00	   MQ	      ds	2	;used for some math
   2103 U159f		       00	   sign       ds	1	;0 = positive, else negative
   2104 U15a0		       00	   rtemp1     ds	1
   2105 U15a1		       00 00	   random     ds	2
   2106 U15a3		       00 00	   BOutVec    ds	2
   2107 U15a5		       00	   tempy      ds	1	;temp y storage
   2108 U15a6				  -	      if	XKIM
   2109 U15a6				  -buffer     ds	BUFFER_SIZE
   2110 U15a6					      endif
   2111 U15a6							;
   2112 U15a6							; PROGRAMEND is the end of the user's BASIC program.
   2113 U15a6							; More precisely, it is one byte past the end.  Or,
   2114 U15a6							; it's where the next line added to the end will be
   2115 U15a6							; placed.
   2116 U15a6							;
   2117 U15a6		       00 00	   PROGRAMEND ds	2
   2118 U15a8		       00 00	   HighMem    ds	2	;highest location
   2119 U15aa		       00 00	   UsedMem    ds	2	;size of user program
   2120 U15ac		       00 00	   FreeMem    ds	2	;amount of free memory
   2121 U15ae							;
   2122 U15ae							;=====================================================
   2123 U15ae							; This is the start of the user's BASIC program space.
   2124 U15ae							;
   2125 U15ae							; PERSONAL GOAL: This should be no larger than $0DFF.
   2126 U15ae							;		  0200-05FF = 1K
   2127 U15ae							;		  0200-09FF = 2K
   2128 U15ae							;		  0200-0DFF = 3K
   2129 U15ae							;		  0200-11FF = 4K
   2130 U15ae							;		  0200-13FF = 4.5K
   2131 U15ae							;
   2132 U15ae				  -	      if	FIXED
   2133 U15ae				  -	      org	$2000
   2134 U15ae					      endif
   2135 U15ae		       15 ae	   ProgramStart equ	*
   2136 U15ae							;/*
   2137 U15ae							;	if	CTMON65 || XKIM
   2138 U15ae							;		SEG Code
   2139 U15ae							;		org	AutoRun
   2140 U15ae							;		dw	TBasicCold
   2141 U15ae							;	endif
   2142 U15ae							;*/
   2143 U15ae					      end
