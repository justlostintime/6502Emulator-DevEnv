------- FILE mytb.asm LEVEL 1 PASS 4
      1 U12c2				   input      processor	6502
      2 U12c2 ????						;=====================================================
      3 U12c2 ????						; Bob's Tiny BASIC
      4 U12c2 ????						;
      5 U12c2 ????						; While working on the Corsham Technologies KIM Clone
      6 U12c2 ????						; project, I wanted to include a TINY BASIC since that
      7 U12c2 ????						; was a highly desirable feature of early computers.
      8 U12c2 ????						;
      9 U12c2 ????						; Rather than negotiating copyright issues for
     10 U12c2 ????						; existing BASICs, I decided to just write one from
     11 U12c2 ????						; scratch.
     12 U12c2 ????						;
     13 U12c2 ????						; 10/07/2017
     14 U12c2 ????						;
     15 U12c2 ????						; This implements a stripped down Tiny BASIC
     16 U12c2 ????						; interpreter using the Interpretive Language (IL)
     17 U12c2 ????						; method as described in the first few issues of
     18 U12c2 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U12c2 ????						; to write various languages simply by changing the
     20 U12c2 ????						; IL code rather than the interpreter itself.
     21 U12c2 ????						;
     22 U12c2 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U12c2 ????						;		* Fixed major bug in findLine that
     24 U12c2 ????						;		  caused corrupted lines, crashes, etc.
     25 U12c2 ????						;		* If no parameter given to RND, assume
     26 U12c2 ????						;		  32766.
     27 U12c2 ????						;		* No more error 5 when a program
     28 U12c2 ????						;		  reaches the end without an END.
     29 U12c2 ????						;
     30 U12c2 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U12c2 ????						;		 * Add some usefull system level functions
     32 U12c2 ????						;		 * allow a larger number of tiny basic formats
     33 U12c2 ????						;		 * Add byte at start of line holding length
     34 U12c2 ????						;		   for faster execution of goto and gosub
     35 U12c2 ????						;		 * Re-added gosub
     36 U12c2 ????						;		 * allow ; or , at end if print stmt
     37 U12c2 ????						;		   without CRLF being added.
     38 U12c2 ????						;		 * Added extended function erase to
     39 U12c2 ????						;		   use the extended ctmon65 rm file
     40 U12c2 ????						;		 * Fix quoted text to not have to backtrack
     41 U12c2 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     42 U12c2 ????						;
     43 U12c2 ????						; www.corshamtech.com
     44 U12c2 ????						; bob@corshamtech.com
     45 U12c2 ????						; JustLostInTime@gmail.com
     46 U12c2 ????						;
     47 U12c2 ????						;=====================================================
     48 U12c2 ????						;
     49 U12c2 ????						; Create TRUE and FALSE values for conditionals.
     50 U12c2 ????						;
     51 U12c2 ????
     52 U12c2 ????	       00 00	   FALSE      equ	0
     53 U12c2 ????	       ff ff ff ff TRUE       equ	~FALSE
     54 U12c2 ????						;
     55 U12c2 ????						;---------------------------------------------------------
     56 U12c2 ????						; One of these must be set to indicate which environment
     57 U12c2 ????						; Tiny BASIC will be running in.  Here are the current
     58 U12c2 ????						; environments:
     59 U12c2 ????						;
     60 U12c2 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     61 U12c2 ????						; more K of RAM.
     62 U12c2 ????						;
     63 U12c2 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     64 U12c2 ????						; which enhances, without replacing, the standard KIM
     65 U12c2 ????						; monitor.  It gives access to routines to save/load files
     66 U12c2 ????						; to a micro SD card.
     67 U12c2 ????						;
     68 U12c2 ????						; CTMON65 is a from-scratch monitor written for the
     69 U12c2 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     70 U12c2 ????						; easily be ported to other systems.  It has support for
     71 U12c2 ????						; using a micro SD card for file storage/retrieval.
     72 U12c2 ????						;
     73 U12c2 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     74 U12c2 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     75 U12c2 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     76 U12c2 ????						;
     77 U12c2 ????						;   Need to define some macros for the dasm assembler
     78 U12c2 ????						;
     79 U12c2 ????				      MACRO	dw
     80 U12c2 ????				      .word	{0}
     81 U12c2 ????				      ENDM
     82 U12c2 ????
     83 U12c2 ????				      MACRO	db
     84 U12c2 ????				      .byte	{0}
     85 U12c2 ????				      ENDM
     86 U12c2 ????
     87 U12c2 ????						;
     88 U12c2 ????						; If set, include disk functions.
     89 U12c2 ????						;
     90 U12c2 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     91 U12c2 ????						;
     92 U12c2 ????						; If ILTRACE is set then dump out the address of every
     93 U12c2 ????						; IL opcode before executing it.
     94 U12c2 ????						;
     95 U12c2 ????	       00 00	   ILTRACE    equ	FALSE
     96 U12c2 ????						;
     97 U12c2 ????						; If FIXED is set, put the IL code and the user
     98 U12c2 ????						; program space at fixed locations in memory.	This is
     99 U12c2 ????						; meant only for debugging.
    100 U12c2 ????						;
    101 U12c2 ????	       00 00	   FIXED      equ	FALSE
    102 U12c2 ????						;
    103 U12c2 ????						; Sets the arithmetic stack depth.  This is *TINY*
    104 U12c2 ????						; BASIC, so keep this small!
    105 U12c2 ????						;
    106 U12c2 ????	       00 08	   STACKSIZE  equ	8	;number of entries
    107 U12c2 ????	       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting max is 85
    108 U12c2 ????						;
    109 U12c2 ????						; Common ASCII constants
    110 U12c2 ????						;
    111 U12c2 ????	       00 07	   BEL	      equ	$07
    112 U12c2 ????	       00 08	   BS	      equ	$08
    113 U12c2 ????	       00 09	   TAB	      equ	$09
    114 U12c2 ????	       00 0a	   LF	      equ	$0A
    115 U12c2 ????	       00 0d	   CR	      equ	$0D
    116 U12c2 ????	       00 22	   QUOTE      equ	$22
    117 U12c2 ????	       00 20	   SPACE      equ	$20
    118 U12c2 ????	       00 2c	   COMMA      equ	',
    119 U12c2 ????	       00 3b	   SEMICOLON  equ	';
    120 U12c2 ????	       00 3a	   COLON      equ	58
    121 U12c2 ????	       00 24	   DOLLAR     equ	$24
    122 U12c2 ????						;
    123 U12c2 ????						; These are error codes
    124 U12c2 ????						;
    125 U12c2 ????	       00 00	   ERR_NONE   equ	0
    126 U12c2 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    127 U12c2 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    128 U12c2 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    129 U12c2 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    130 U12c2 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    131 U12c2 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    132 U12c2 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    133 U12c2 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    134 U12c2 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    135 U12c2 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    136 U12c2 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    137 U12c2 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    138 U12c2 ????						;
    139 U12c2 ????						;=====================================================
    140 U12c2 ????						; Zero page storage.
    141 U12c2 ????						;
    142 U12c2 ????				      SEG.U	Data
    143 U0040					      org	$0040
    144 U0040
    145 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    146 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    147 U0041		       00 75	   variablesEnd equ	*
    148 U0075		       00 00	   ILPC       ds	2	;IL program counter
    149 U0077		       00 00	   dpl	      ds	2
    150 U0079		       00 00	   tempIL     ds	2
    151 U007b		       00	   tempIlY    ds	1
    152 U007c		       00	   offset     ds	1
    153 U007d		       00	   lineLength ds	1
    154 U007e							;
    155 U007e							; CURPTR is a pointer to curent BASIC line being
    156 U007e							; executed.  Always points to start of line, CUROFF
    157 U007e							; is the offset to the current character.
    158 U007e							;
    159 U007e		       00 00	   CURPTR     ds	2
    160 U0080		       00	   CUROFF     ds	1
    161 U0081							;
    162 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    163 U0083							;
    164 U0083
    165 U0083							;
    166 U0083							; R0 and R1 are used for arithmetic operations and
    167 U0083							; general use.
    168 U0083							;
    169 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    170 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    171 U0087							;
    172 U0087							; This is zero if in immediate mode, or non-zero
    173 U0087							; if currently running a program.  Any input from
    174 U0087							; the main loop clears this, and the XFER IL
    175 U0087							; statement will set it.
    176 U0087							;
    177 U0087		       00	   RunMode    ds	1
    178 U0088							;
    179 U0088							; Used for line insertion/removal.
    180 U0088							;
    181 U0088		       00 00	   FROM       ds	2
    182 U008a
    183 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    184 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    185 U008a							;
    186 U008a		       00 88	   PrtFrom    EQU	FROM
    187 U008a							;
    188 U008a							;=====================================================
    189 U008a							;
    190  1204 ????				      SEG	Code
    191  0200					      org	$0200
    192  0200							;
    193  0200							; Cold start is at $0200.  Warm start is at $0203.
    194  0200							;
    195  0200		       4c 15 02    TBasicCold jmp	cold2	;jump around vectors
    196  0203		       4c bf 02    warm       jmp	warm2
    197  0206							;
    198  0206							; These are the user-supplied vectors to I/O routines.
    199  0206							; If you want, you can just patch these in the binary
    200  0206							; file, but it would be better to change the source
    201  0206							; code.
    202  0206							;
    203  0206				  -	      if	KIM
    204  0206				  -OUTCH      jmp	$1ea0	;output char in A
    205  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    206  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    207  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    208  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    209  0206					      endif
    210  0206				  -	      if	XKIM
    211  0206				  -	      include	"xkim.inc"
    212  0206				  -	      SEG	Code
    213  0206				  -OUTCH      jmp	$1ea0
    214  0206				  -GETCH      jmp	xkGETCH
    215  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    216  0206				  -OUTHEX     jmp	xkPRTBYT
    217  0206				  -MONITOR    jmp	extKIM
    218  0206				  -puts       equ	putsil
    219  0206				  -BUFFER_SIZE equ	132
    220  0206					      endif
    221  0206
    222  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U00f6 ????				      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 U008a					      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    224  0206					      SEG	Code
    225  0206
    226  0206		       4c 0c f0    OUTCH      jmp	cout
    227  0209		       4c 09 f0    GETCH      jmp	cin
    228  020c		       4c 18 f0    CRLF       jmp	crlf
    229  020f		       4c 1b f0    OUTHEX     jmp	HexA
    230  0212		       4c 03 f0    MONITOR    jmp	WARM
    231  0212		       f0 12	   puts       equ	putsil
    232  0215					      endif
    233  0215							;
    234  0215		       20 12 f0    cold2      jsr	puts
      0  0218					      db	CR,LF
      1  0218		       0d 0a		      .byte.b	CR,LF
      0  021a					      db	"Bob's Tiny BASIC v1.0.2 IRQs"
      1  021a		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs"
      0  0236					      db	CR,LF
      1  0236		       0d 0a		      .byte.b	CR,LF
      0  0238					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  0238		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0266					      db	CR,LF,0
      1  0266		       0d 0a 00 	      .byte.b	CR,LF,0
    240  0269							;
    241  0269		       20 a7 0d 	      jsr	GetSizes	;setup the free space available
    242  026c		       ad bc 12 	      lda	HighMem
    243  026f		       e9 3c		      sbc	#GOSUBSTACKSIZE*3
    244  0271		       85 81		      sta	GOSUBSTACK
    245  0273		       ad bd 12 	      lda	HighMem+1
    246  0276		       e9 00		      sbc	#0
    247  0278		       85 82		      sta	GOSUBSTACK+1
    248  027a		       a9 45		      lda	#IL&$ff
    249  027c		       85 75		      sta	ILPC
    250  027e		       a9 0f		      lda	#IL>>8
    251  0280		       85 76		      sta	ILPC+1
    252  0282							;
    253  0282		       a9 c2		      lda	#ProgramStart&$ff	;user prog
    254  0284		       8d ba 12 	      sta	PROGRAMEND
    255  0287		       a9 12		      lda	#ProgramStart>>8
    256  0289		       8d bb 12 	      sta	PROGRAMEND+1
    257  028c							;
    258  028c							; Initialize the pseudo-random number sequence...
    259  028c							;
    260  028c		       a9 5a		      lda	#$5a
    261  028e		       8d b4 12 	      sta	rtemp1
    262  0291		       a9 9d		      lda	#%10011101
    263  0293		       8d b5 12 	      sta	random
    264  0296		       a9 5b		      lda	#%01011011
    265  0298		       8d b6 12 	      sta	random+1
    266  029b							;
    267  029b							;   Insert a Basic irq handler for the basic Language
    268  029b		       a9 ad		      lda	#ServiceIrq&$ff
    269  029d		       8d 00 df 	      sta	IRQvec
    270  02a0		       a9 02		      lda	#ServiceIrq>>8
    271  02a2		       8d 01 df 	      sta	IRQvec+1
    272  02a5		       4c cc 02 	      jmp	coldtwo
    273  02a8
    274  02a8							;
    275  02a8							; This is the Basic IRQ handler
      0  02a8				   SaveIrqReg db	0
      1  02a8		       00		      .byte.b	0
      0  02a9				   IRQStatus  db	0
      1  02a9		       00		      .byte.b	0
      0  02aa				   IRQPending db	0
      1  02aa		       00		      .byte.b	0
      0  02ab				   IRQEntry   db	0,0
      1  02ab		       00 00		      .byte.b	0,0
    280  02ad
    281  02ad		       48	   ServiceIrq pha
    282  02ae		       ad a9 02 	      lda	IRQStatus
    283  02b1		       f0 0a		      BEQ	RetIrq
    284  02b3		       ad aa 02 	      lda	IRQPending
    285  02b6		       d0 05		      BNE	RetIrq
    286  02b8		       a9 01		      lda	#1
    287  02ba		       8d aa 02 	      sta	IRQPending
    288  02bd		       68	   RetIrq     pla
    289  02be		       40		      rti
    290  02bf							;
    291  02bf							;
    292  02bf							; This is the warm start entry point
    293  02bf							;
    294  02bf		       20 0c 02    warm2      jsr	CRLF
    295  02c2		       ad af 12 	      lda	errGoto
    296  02c5		       85 75		      sta	ILPC
    297  02c7		       ad b0 12 	      lda	errGoto+1
    298  02ca		       85 76		      sta	ILPC+1
    299  02cc							;
    300  02cc							; And continue with both starts here
    301  02cc							;
    302  02cc		       20 da 0d    coldtwo    jsr	SetOutConsole
    303  02cf							;
    304  02cf							; The ILTrace flag is now run-time settable.
    305  02cf							;
    306  02cf		       a9 00		      lda	#ILTRACE&$ff
    307  02d1		       85 40		      sta	ILTrace
    308  02d3							;
    309  02d3		       a9 00		      lda	#0
    310  02d5		       85 87		      sta	RunMode
    311  02d7		       8d 27 12 	      sta	LINBUF
    312  02da							; Clear everything from the stacks
    313  02da		       8d 14 12 	      sta	mathStackPtr
    314  02dd		       8d 25 12 	      sta	retStackPtr
    315  02e0		       8d 26 12 	      sta	GoSubStackPtr
    316  02e3							;
    317  02e3		       a9 27		      lda	#LINBUF&$ff
    318  02e5		       85 7e		      sta	CURPTR
    319  02e7		       a9 12		      lda	#LINBUF>>8
    320  02e9		       85 7f		      sta	CURPTR+1	;fall through...
    321  02eb							;
    322  02eb							;=====================================================
    323  02eb							; This is the top of the IL interpreter.  This fetches
    324  02eb							; and executes the instruction currently pointed to
    325  02eb							; by ILPC and adjusts ILPC to point to the next
    326  02eb							; instruction to execute.
    327  02eb							;
    328  02eb		       a5 40	   NextIL     lda	ILTrace
    329  02ed		       f0 03		      beq	NextIL2
    330  02ef		       20 62 0d 	      jsr	dbgLine
    331  02f2		       a4 80	   NextIL2    ldy	CUROFF
    332  02f4		       20 59 0d 	      jsr	SkipSpaces
    333  02f7		       84 80		      sty	CUROFF
    334  02f9							;
    335  02f9		       20 3d 0a    NextILStr  jsr	getILByte
    336  02fc							;
    337  02fc							; When the handler is called, these are the conditions
    338  02fc							; of several important items:
    339  02fc							;
    340  02fc							;    (ILPC) will point to the byte AFTER the IL
    341  02fc							;    opcode being executed.
    342  02fc							;
    343  02fc							;    (CURPTR),CUROFF will point to the start of the
    344  02fc							;    next word in the input buffer.  Ie, the next word
    345  02fc							;    in the user program.
    346  02fc							;
    347  02fc		       0a		      asl
    348  02fd		       c9 7a		      cmp	#ILTBLend-ILTBL+2
    349  02ff		       90 33		      bcc	ILgood
    350  0301							;
    351  0301							; This handles an illegal IL opcode.  This is serious
    352  0301							; and there's no way to recover.
    353  0301							;
    354  0301		       20 12 f0    ILbad      jsr	puts
      0  0304					      db	CR,LF
      1  0304		       0d 0a		      .byte.b	CR,LF
      0  0306					      db	"Illegal IL "
      1  0306		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  0311					      db	0
      1  0311		       00		      .byte.b	0
    358  0312							;
    359  0312							; Well this is awkward, we need to back up the IL
    360  0312							; by one since it no longer points to the current
    361  0312							; opcode.
    362  0312							;
    363  0312		       20 4a 0a 	      jsr	decIL
    364  0315							;
    365  0315		       a0 00		      ldy	#0
    366  0317		       b1 75		      lda	(ILPC),y
    367  0319		       20 0f 02 	      jsr	OUTHEX
    368  031c		       20 12 f0 	      jsr	puts
      0  031f					      db	" at ",0
      1  031f		       20 61 74 20*	      .byte.b	" at ",0
    370  0324		       a5 76		      lda	ILPC+1
    371  0326		       20 0f 02 	      jsr	OUTHEX
    372  0329		       a5 75		      lda	ILPC
    373  032b		       20 0f 02 	      jsr	OUTHEX
    374  032e		       20 0c 02 	      jsr	CRLF
    375  0331		       4c 12 02 	      jmp	MONITOR
    376  0334							;
    377  0334							; Just jump to the address (ILPC),y.  Have to do
    378  0334							; some goofy stuff.
    379  0334							;
    380  0334		       a8	   ILgood     tay		;move index into Y
    381  0335		       b9 42 03 	      lda	ILTBL,y
    382  0338		       85 77		      sta	dpl
    383  033a		       b9 43 03 	      lda	ILTBL+1,y
    384  033d		       85 78		      sta	dpl+1
    385  033f		       6c 77 00 	      jmp	(dpl)	;go to handler
    386  0342							;
    387  0342							;=====================================================
    388  0342							; This is the IL jump table.  The IL opcode is
    389  0342							; mulitplied by two, then looked-up in this table.
    390  0342							; There is absolutely nothing special about the order
    391  0342							; of entries here... they all decode at exactly the
    392  0342							; same speed.	However the entry number must match the
    393  0342							; values in IL.inc.
    394  0342							;
      0  0342				   ILTBL      dw	iXINIT	;0
      1  0342		       d0 03		      .word.w	iXINIT
      0  0344					      dw	iDONE	;1
      1  0344		       d8 03		      .word.w	iDONE
      0  0346					      dw	iPRS	;2
      1  0346		       f4 03		      .word.w	iPRS
      0  0348					      dw	iPRN	;3
      1  0348		       fe 03		      .word.w	iPRN
      0  034a					      dw	iSPC	;4
      1  034a		       07 04		      .word.w	iSPC
      0  034c					      dw	iNLINE	;5
      1  034c		       7a 07		      .word.w	iNLINE
      0  034e					      dw	iNXT	;6
      1  034e		       0f 04		      .word.w	iNXT
      0  0350					      dw	iXFER	;7
      1  0350		       35 04		      .word.w	iXFER
      0  0352					      dw	iSAV	;8
      1  0352		       62 04		      .word.w	iSAV
      0  0354					      dw	iRSTR	;9
      1  0354		       83 04		      .word.w	iRSTR
      0  0356					      dw	iCMPR	;10
      1  0356		       8f 04		      .word.w	iCMPR
      0  0358					      dw	iINNUM	;11
      1  0358		       d1 04		      .word.w	iINNUM
      0  035a					      dw	iFIN	;12
      1  035a		       0d 05		      .word.w	iFIN
      0  035c					      dw	iERR	;13
      1  035c		       1e 05		      .word.w	iERR
      0  035e					      dw	iADD	;14
      1  035e		       6a 05		      .word.w	iADD
      0  0360					      dw	iSUB	;15
      1  0360		       80 05		      .word.w	iSUB
      0  0362					      dw	iNEG	;16
      1  0362		       96 05		      .word.w	iNEG
      0  0364					      dw	iMUL	;17
      1  0364		       ae 05		      .word.w	iMUL
      0  0366					      dw	iDIV	;18
      1  0366		       e8 05		      .word.w	iDIV
      0  0368					      dw	iSTORE	;19
      1  0368		       31 06		      .word.w	iSTORE
      0  036a					      dw	iIND	;20
      1  036a		       44 06		      .word.w	iIND
      0  036c					      dw	iLST	;21
      1  036c		       54 06		      .word.w	iLST
      0  036e					      dw	iINIT	;22
      1  036e		       ba 03		      .word.w	iINIT
      0  0370					      dw	iGETLINE	;23
      1  0370		       b3 06		      .word.w	iGETLINE
      0  0372					      dw	iINSRT	;24
      1  0372		       bf 06		      .word.w	iINSRT
      0  0374					      dw	iRTN	;25
      1  0374		       74 07		      .word.w	iRTN
      0  0376					      dw	MONITOR	;26
      1  0376		       12 02		      .word.w	MONITOR
      0  0378					      dw	iLIT	;27
      1  0378		       8d 07		      .word.w	iLIT
      0  037a					      dw	iCALL	;28
      1  037a		       80 07		      .word.w	iCALL
      0  037c					      dw	iJMP	;29
      1  037c		       83 07		      .word.w	iJMP
      0  037e					      dw	iVINIT	;30
      1  037e		       9a 07		      .word.w	iVINIT
      0  0380					      dw	iERRGOTO	;31
      1  0380		       a8 07		      .word.w	iERRGOTO
      0  0382					      dw	iTST	;32
      1  0382		       b4 07		      .word.w	iTST
      0  0384					      dw	iTSTV	;33
      1  0384		       37 08		      .word.w	iTSTV
      0  0386					      dw	iTSTL	;34
      1  0386		       61 08		      .word.w	iTSTL
      0  0388					      dw	iTSTN	;35
      1  0388		       7b 08		      .word.w	iTSTN
      0  038a					      dw	iFREE	;36
      1  038a		       ed 08		      .word.w	iFREE
      0  038c					      dw	iRANDOM	;37
      1  038c		       f6 08		      .word.w	iRANDOM
      0  038e					      dw	iABS	;38
      1  038e		       e7 09		      .word.w	iABS
    434  0390							;
    435  0390							; Disk functions.  There must be pointers
    436  0390							; to functions even if no disk is supported.
    437  0390							; Makes things easier in IL.inc.
    438  0390							;
    439  0390					      if	DISK_ACCESS
      0  0390					      dw	iOPENREAD	;39
      1  0390		       20 0e		      .word.w	iOPENREAD
      0  0392					      dw	iOPENWRITE	;40
      1  0392		       74 0e		      .word.w	iOPENWRITE
      0  0394					      dw	iDCLOSE	;41
      1  0394		       f8 0e		      .word.w	iDCLOSE
      0  0396					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0396		       93 0e		      .word.w	iDGETLINE
      0  0398					      dw	iDLIST	;43 Did you remeber your towel?
      1  0398		       f2 0e		      .word.w	iDLIST
      0  039a					      dw	iDDIR	;44
      1  039a		       cd 0e		      .word.w	iDDIR
      0  039c					      dw	iRMFILE	;45
      1  039c		       4e 0e		      .word.w	iRMFILE
    447  039e				  -	      else
    448  039e				  -	      dw	NextIL	;39
    449  039e				  -	      dw	NextIL	;40
    450  039e				  -	      dw	NextIL	;41
    451  039e				  -	      dw	NextIL	;42
    452  039e				  -	      dw	NextIL	;43
    453  039e				  -	      dw	NextIL	;44
    454  039e				  -	      dw	NextIL	;45
    455  039e					      endif
    456  039e							;
      0  039e					      dw	iCLEARSCREEN	;46
      1  039e		       15 0e		      .word.w	iCLEARSCREEN
      0  03a0					      dw	iPOKEMEMORY	;47
      1  03a0		       6e 09		      .word.w	iPOKEMEMORY
      0  03a2					      dw	iPEEKMEMORY	;48
      1  03a2		       83 09		      .word.w	iPEEKMEMORY
      0  03a4					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03a4		       f9 07		      .word.w	iTSTLET
      0  03a6					      dw	iTSTDONE	;50	     Test if we are at the end of a line
      1  03a6		       16 08		      .word.w	iTSTDONE
      0  03a8					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03a8		       b6 09		      .word.w	iGETCHAR
      0  03aa					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03aa		       dc 09		      .word.w	iPUTCHAR
      0  03ac					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03ac		       a1 09		      .word.w	iCallFunc
      0  03ae					      dw	iCallFunc2	;54	   call system rtn with value in a
      1  03ae		       9c 09		      .word.w	iCallFunc2
      0  03b0					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03b0		       dd 07		      .word.w	iTSTStr
      0  03b2					      dw	iSetIrq	;56	   sets the irq handler
      1  03b2		       04 0a		      .word.w	iSetIrq
      0  03b4					      dw	iTstIrq	;57	   test if irq is pending
      1  03b4		       be 08		      .word.w	iTstIrq
      0  03b6					      dw	iRET	;58	   return from interupt
      1  03b6		       71 04		      .word.w	iRET
      0  03b8					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03b8		       e8 04		      .word.w	iINSTR
    471  03ba
    472  03ba		       03 ba	   ILTBLend   equ	*
    473  03ba							;
    474  03ba							;=====================================================
    475  03ba							;=====================================================
    476  03ba							;=====================================================
    477  03ba							; This marks the start of the handlers for IL opcodes.
    478  03ba							;=====================================================
    479  03ba							;=====================================================
    480  03ba							;=====================================================
    481  03ba							;
    482  03ba							;
    483  03ba		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    484  03bc		       8d 25 12 	      sta	retStackPtr
    485  03bf		       8d 26 12 	      sta	GoSubStackPtr
    486  03c2							;
    487  03c2		       a9 c2		      lda	#ProgramStart&$ff	;user prog
    488  03c4		       85 7e		      sta	CURPTR
    489  03c6		       8d ba 12 	      sta	PROGRAMEND
    490  03c9		       a9 12		      lda	#ProgramStart>>8
    491  03cb		       85 7f		      sta	CURPTR+1
    492  03cd		       8d bb 12 	      sta	PROGRAMEND+1
    493  03d0							;
    494  03d0							; fall into XINIT...
    495  03d0							;
    496  03d0							;=====================================================
    497  03d0							; This initializes for the start of the next line of
    498  03d0							; BASIC text.
    499  03d0							;
    500  03d0		       a9 00	   iXINIT     lda	#0
    501  03d2		       8d 14 12 	      sta	mathStackPtr	;clear math stack
    502  03d5		       4c eb 02    goodExit   jmp	NextIL
    503  03d8							;
    504  03d8							;=====================================================
    505  03d8							; Verify there is nothing else on this input line.
    506  03d8							; If there is, generate an error.
    507  03d8							;
    508  03d8		       a4 80	   iDONE      ldy	CUROFF
    509  03da		       20 59 0d 	      jsr	SkipSpaces
    510  03dd		       b1 7e		      lda	(CURPTR),y
    511  03df		       f0 10		      beq	doneadv
    512  03e1		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    513  03e3		       d0 05		      bne	idoneErr
    514  03e5		       84 80		      sty	CUROFF
    515  03e7		       4c eb 02 	      jmp	NextIL	; continue on this line
    516  03ea
    517  03ea				   idoneErr
    518  03ea		       a2 04		      ldx	#ERR_EXTRA_STUFF
    519  03ec		       a9 00		      lda	#0
    520  03ee		       4c 21 05 	      jmp	iErr2
    521  03f1							;
    522  03f1							; Advance to the next line
    523  03f1							;
    524  03f1				   doneadv
    525  03f1							;		jsr	FindNext2
    526  03f1		       4c eb 02 	      jmp	NextIL
    527  03f4							;
    528  03f4							;=====================================================
    529  03f4							; Print the string until a closing quote
    530  03f4							;
    531  03f4		       a4 80	   iPRS       ldy	CUROFF
    532  03f6							;
    533  03f6							; Odd logic here.  The main loop skipped any leading
    534  03f6							; whitespace inside the quoted text, so move back to
    535  03f6							; the quote, then move forward again.
    536  03f6							;
    537  03f6		       20 e8 0d 	      jsr	PrtQuoted
    538  03f9		       84 80		      sty	CUROFF
    539  03fb		       4c eb 02 	      jmp	NextIL
    540  03fe							;
    541  03fe							;=====================================================
    542  03fe							; Pop the top off the stack and print it as a signed
    543  03fe							; decimal number.
    544  03fe							;
    545  03fe		       20 90 0c    iPRN       jsr	popR0
    546  0401		       20 e2 0a 	      jsr	PrintDecimal
    547  0404		       4c eb 02 	      jmp	NextIL
    548  0407							;
    549  0407							;=====================================================
    550  0407							; Space to next zone.	Currently the code does not
    551  0407							; keep track of which column the output is on, so
    552  0407							; just print a tab.
    553  0407							;
    554  0407		       a9 09	   iSPC       lda	#TAB
    555  0409		       20 06 02 	      jsr	OUTCH
    556  040c		       4c eb 02 	      jmp	NextIL
    557  040f							;
    558  040f							;=====================================================
    559  040f							; If in immediate mode, jump to the address following
    560  040f							; the NXT instruction.  Else move to the next line of
    561  040f							; user code and continue.
    562  040f							;
    563  040f		       a5 87	   iNXT       lda	RunMode
    564  0411		       d0 03		      bne	iNxtRun	;in run mode
    565  0413							;
    566  0413							; Get address and jump to it.
    567  0413							;
    568  0413		       4c 83 07 	      jmp	iJMP
    569  0416							;
    570  0416				   iNxtRun
    571  0416		       a4 80		      ldy	CUROFF
    572  0418		       b1 7e		      lda	(CURPTR),y
    573  041a		       c9 3a		      cmp	#COLON
    574  041c		       d0 06		      bne	iNxtRunGo
    575  041e		       c8		      iny
    576  041f		       84 80		      sty	CUROFF
    577  0421		       4c 2f 04 	      jmp	iNxtRun2
    578  0424
    579  0424				   iNxtRunGo
    580  0424		       20 c3 0a 	      jsr	FindNextLine
    581  0427		       20 d5 0a 	      jsr	AtEnd
    582  042a		       d0 03		      bne	iNxtRun2	;not at end
    583  042c							;
    584  042c							; At the end of the program.  Pretend an END statement
    585  042c							; was found.
    586  042c							;
    587  042c		       4c 0d 05    iFINv      jmp	iFIN
    588  042f							;
    589  042f		       20 39 0a    iNxtRun2   jsr	getILWord	;ignore next word
    590  0432		       4c eb 02 	      jmp	NextIL
    591  0435							;
    592  0435							;=====================================================
    593  0435							; XFER takes the number on top of the stack and looks
    594  0435							; for that line in the program, or the next line
    595  0435							; higher.  Ie, if it's 1 but there is no line 1, then
    596  0435							; find the next one after that.
    597  0435							;
    598  0435		       20 90 0c    iXFER      jsr	popR0
    599  0438		       20 80 0a 	      jsr	findLine
    600  043b		       20 d5 0a    iXFER2     jsr	AtEnd	;at end of user program?
    601  043e		       f0 ec		      beq	iFINv
    602  0440		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    603  0442		       84 80		      sty	CUROFF
    604  0444		       a9 ff		      lda	#$ff
    605  0446		       85 87		      sta	RunMode
    606  0448							;
    607  0448							; Transfer IL to STMT.  I don't like having this
    608  0448							; hard-coded; fix it.
    609  0448							;
    610  0448		       a9 53		      lda	#STMT&$ff
    611  044a		       85 75		      sta	ILPC
    612  044c		       a9 0f		      lda	#STMT>>8
    613  044e		       85 76		      sta	ILPC+1
    614  0450		       4c eb 02 	      jmp	NextIL
    615  0453							;
    616  0453							; Run
    617  0453							;
    618  0453				   iXferok
    619  0453		       a9 ff		      lda	#$ff
    620  0455		       85 87		      sta	RunMode	;we're running
    621  0457							;
    622  0457							; Need a more elegant way to do this
    623  0457							;
    624  0457		       a9 53		      lda	#STMT&$ff
    625  0459		       85 75		      sta	ILPC
    626  045b		       a9 0f		      lda	#STMT>>8
    627  045d		       85 76		      sta	ILPC+1
    628  045f		       4c eb 02 	      jmp	NextIL
    629  0462							;
    630  0462							;=====================================================
    631  0462							; Save the pointer to the next line to the call stack.
    632  0462							;
    633  0462		       20 59 0c    iSAV       jsr	pushLN
    634  0465		       b0 03		      bcs	iSAVErr
    635  0467		       4c eb 02 	      jmp	NextIL
    636  046a		       a2 0c	   iSAVErr    ldx	#12
    637  046c		       a9 00	   iSAVErr2   lda	#0
    638  046e		       4c 21 05 	      jmp	iErr2
    639  0471
    640  0471							;
    641  0471							;=====================================================
    642  0471							; Pop the next line from the call stack.
    643  0471							;
    644  0471		       20 a3 0c    iRET       jsr	popLN
    645  0474		       b0 f4		      bcs	iSAVErr
    646  0476		       a0 03		      ldy	#3
    647  0478		       84 80		      sty	CUROFF
    648  047a		       a5 00		      lda	0
    649  047c		       8d aa 02 	      sta	IRQPending
    650  047f		       58		      cli
    651  0480		       4c eb 02 	      jmp	NextIL
    652  0483
    653  0483		       20 a3 0c    iRSTR      jsr	popLN
    654  0486		       b0 e2		      bcs	iSAVErr
    655  0488		       4c eb 02 	      jmp	NextIL
    656  048b		       a2 0b	   iRSTRErr   ldx	#11
    657  048d		       d0 dd		      bne	iSAVErr2
    658  048f							;
    659  048f							;=====================================================
    660  048f							; Compare items on stack.  Okay, so on input there are
    661  048f							; three things on the stack
    662  048f							;
    663  048f							;    EXPR2 <- Top of stack
    664  048f							;    OP    <- relational operator, next on stack
    665  048f							;    EXPR1 <- last item on stack
    666  048f							;
    667  048f							; Comparison is: EXPR1 <operator> EXPR2
    668  048f							;
    669  048f							; Operator is one of...
    670  048f							;
    671  048f							;    2 is =
    672  048f							;    1 is <
    673  048f							;    3 is <=
    674  048f							;    5 is <>
    675  048f							;    4 is >
    676  048f							;    6 is >=
    677  048f							;
    678  048f							; Those are bit-mapped:
    679  048f							;
    680  048f							;    xxxxxGEL
    681  048f							;
    682  048f							;    G = Greater than
    683  048f							;    E = Equal
    684  048f							;    L = Less than
    685  048f							;
    686  048f							; If the comparison is false, do a NXT, ie, move to the
    687  048f							; next line and continue.  If true, continue executing
    688  048f							; on this line.
    689  048f							;
    690  048f		       00 01	   REL_LT     equ	%001
    691  048f		       00 02	   REL_EQUAL  equ	%010
    692  048f		       00 04	   REL_GT     equ	%100
    693  048f							;
    694  048f		       20 c7 0c    iCMPR      jsr	popR1
    695  0492		       20 da 0c 	      jsr	popMQ	;operator in MQ
    696  0495		       20 90 0c 	      jsr	popR0
    697  0498							;
    698  0498							; See if they are equal or not
    699  0498							;
    700  0498		       a5 83		      lda	R0
    701  049a		       c5 85		      cmp	R1
    702  049c		       d0 0a		      bne	iCMPRnoteq	;try not equal
    703  049e		       a5 84		      lda	R0+1
    704  04a0		       c5 86		      cmp	R1+1
    705  04a2		       d0 04		      bne	iCMPRnoteq
    706  04a4							;
    707  04a4							; Equal, set the flag in MQ+1
    708  04a4							;
    709  04a4		       a9 02		      lda	#REL_EQUAL
    710  04a6		       d0 14		      bne	iCMPcom
    711  04a8							;
    712  04a8							; See if EXPR1 (R0) < EXPR2 (R1)
    713  04a8							; See www.6502.org/tutorials/compare_beyond.html
    714  04a8							;
    715  04a8		       a5 83	   iCMPRnoteq lda	R0
    716  04aa		       c5 85		      cmp	R1
    717  04ac		       a5 84		      lda	R0+1
    718  04ae		       e5 86		      sbc	R1+1
    719  04b0		       50 02		      bvc	iCMPR_2
    720  04b2		       49 80		      eor	#$80
    721  04b4		       30 04	   iCMPR_2    bmi	iCMPlt
    722  04b6		       a9 04		      lda	#REL_GT
    723  04b8		       d0 02		      bne	iCMPcom
    724  04ba		       a9 01	   iCMPlt     lda	#REL_LT	;R0 < R1
    725  04bc		       0d b2 12    iCMPcom    ora	MQ+1
    726  04bf							;
    727  04bf							; Now compare the end result with what the caller
    728  04bf							; was looking for.
    729  04bf							;
    730  04bf		       2d b1 12 	      and	MQ
    731  04c2		       f0 07		      beq	iCMPno	;no match
    732  04c4		       4c eb 02 	      jmp	NextIL
    733  04c7							;
    734  04c7							; R0 > R1
    735  04c7							;
    736  04c7		       a9 04	   iCMPgt     lda	#REL_GT
    737  04c9		       d0 f1		      bne	iCMPcom
    738  04cb							;
    739  04cb							; Not a match, so jump to the next line of code.
    740  04cb							;
    741  04cb		       20 c3 0a    iCMPno     jsr	FindNextLine
    742  04ce		       4c 3b 04 	      jmp	iXFER2
    743  04d1							;
    744  04d1							;=====================================================
    745  04d1							; Get a line of text from the user, convert to a
    746  04d1							; number, leave on top of stack.
    747  04d1							;
    748  04d1				   iINNUM
    749  04d1		       a5 80		      lda	CUROFF	;save state before GetLine
    750  04d3		       48		      pha
    751  04d4		       a5 7f		      lda	CURPTR+1
    752  04d6		       48		      pha
    753  04d7		       a5 7e		      lda	CURPTR
    754  04d9		       48		      pha
    755  04da							;
    756  04da		       a9 3f		      lda	#'?
    757  04dc		       20 c5 0b 	      jsr	GetLine
    758  04df		       20 4e 0b 	      jsr	getDecimal
    759  04e2		       20 46 0c 	      jsr	pushR0	;put onto stack
    760  04e5							;
    761  04e5		       4c 01 05 	      jmp	ExitIn
    762  04e8							;
    763  04e8							;=====================================================
    764  04e8							; Get a line of text from the user, convert to a
    765  04e8							; String , leave on top of stack. up to 2 characters
    766  04e8							;
    767  04e8				   iINSTR
    768  04e8		       a5 80		      lda	CUROFF	;save state before GetLine
    769  04ea		       48		      pha
    770  04eb		       a5 7f		      lda	CURPTR+1
    771  04ed		       48		      pha
    772  04ee		       a5 7e		      lda	CURPTR
    773  04f0		       48		      pha
    774  04f1							;
    775  04f1		       a9 3f		      lda	#'?
    776  04f3		       20 c5 0b 	      jsr	GetLine
    777  04f6		       b1 7e		      lda	(CURPTR),y
    778  04f8		       85 83		      sta	R0
    779  04fa		       a9 00		      lda	#0
    780  04fc		       85 84		      sta	R0+1
    781  04fe		       20 46 0c 	      jsr	pushR0	;put onto stack
    782  0501							;
    783  0501				   ExitIn
    784  0501		       68		      pla
    785  0502		       85 7e		      sta	CURPTR
    786  0504		       68		      pla
    787  0505		       85 7f		      sta	CURPTR+1
    788  0507		       68		      pla
    789  0508		       85 80		      sta	CUROFF
    790  050a							;
    791  050a		       4c eb 02 	      jmp	NextIL
    792  050d							;
    793  050d							;
    794  050d							;=====================================================
    795  050d							; Stop the currently running program.	Actually very
    796  050d							; simple to do... clear the RunMode flag, then set the
    797  050d							; ILPC to the standard handler and continue running.
    798  050d							;
    799  050d		       a9 00	   iFIN       lda	#0
    800  050f		       85 87		      sta	RunMode
    801  0511							;
    802  0511		       ad af 12 	      lda	errGoto
    803  0514		       85 75		      sta	ILPC
    804  0516		       ad b0 12 	      lda	errGoto+1
    805  0519		       85 76		      sta	ILPC+1
    806  051b		       4c eb 02 	      jmp	NextIL
    807  051e							;
    808  051e							;=====================================================
    809  051e							; Handle the ERR opcode.  Following the instruction is
    810  051e							; a 16 bit error number.  Print an error message, and
    811  051e							; if we're in run mode, print the line number.  Stop
    812  051e							; program execution and return to the initial state.
    813  051e							;
    814  051e		       20 39 0a    iERR       jsr	getILWord	;get err code
    815  0521							;
    816  0521							; Enter here with the error code in X (LSB) and A (MSB).
    817  0521							;
    818  0521		       86 83	   iErr2      stx	R0
    819  0523		       85 84		      sta	R0+1
    820  0525							;
    821  0525		       20 12 f0 	      jsr	puts
      0  0528					      db	"Error ",0
      1  0528		       45 72 72 6f*	      .byte.b	"Error ",0
    823  052f		       20 e2 0a 	      jsr	PrintDecimal
    824  0532							;
    825  0532		       a5 87		      lda	RunMode	;running?
    826  0534		       f0 1b		      beq	iERR2	;nope
    827  0536		       20 12 f0 	      jsr	puts
      0  0539					      db	" at line ",0
      1  0539		       20 61 74 20*	      .byte.b	" at line ",0
    829  0543		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    830  0545		       b1 7e		      lda	(CURPTR),y
    831  0547		       85 83		      sta	R0
    832  0549		       c8		      iny
    833  054a		       b1 7e		      lda	(CURPTR),y
    834  054c		       85 84		      sta	R0+1
    835  054e		       20 e2 0a 	      jsr	PrintDecimal
    836  0551							;
    837  0551		       20 0c 02    iERR2      jsr	CRLF
    838  0554		       a9 00		      lda	#0
    839  0556		       85 87		      sta	RunMode	;fall through...
    840  0558							;
    841  0558							;=====================================================
    842  0558							; Reset the IL to be back at the idle loop.  Does not
    843  0558							; clear variables so the user can see what state
    844  0558							; the program is in.
    845  0558							;
    846  0558		       a9 00	   ResetIL    lda	#0
    847  055a		       8d 25 12 	      sta	retStackPtr
    848  055d		       ad af 12 	      lda	errGoto
    849  0560		       85 75		      sta	ILPC
    850  0562		       ad b0 12 	      lda	errGoto+1
    851  0565		       85 76		      sta	ILPC+1
    852  0567		       4c eb 02 	      jmp	NextIL
    853  056a							;
    854  056a							;=====================================================
    855  056a							; Pop two items off stack, add them, then place the
    856  056a							; result back onto the stack.
    857  056a							;
    858  056a		       20 90 0c    iADD       jsr	popR0
    859  056d		       20 c7 0c 	      jsr	popR1
    860  0570		       18		      clc
    861  0571		       a5 83		      lda	R0
    862  0573		       65 85		      adc	R1
    863  0575		       85 83		      sta	R0
    864  0577		       a5 84		      lda	R0+1
    865  0579		       65 86		      adc	R1+1
    866  057b		       85 84		      sta	R0+1
    867  057d		       4c e2 05 	      jmp	pushR0nextIl
    868  0580							;
    869  0580							;=====================================================
    870  0580							; Pop two items off the stack.  Subtract the top of
    871  0580							; stack from the lower entry.
    872  0580							;
    873  0580		       20 c7 0c    iSUB       jsr	popR1
    874  0583		       20 90 0c 	      jsr	popR0
    875  0586		       38		      sec
    876  0587		       a5 83		      lda	R0
    877  0589		       e5 85		      sbc	R1
    878  058b		       85 83		      sta	R0
    879  058d		       a5 84		      lda	R0+1
    880  058f		       e5 86		      sbc	R1+1
    881  0591		       85 84		      sta	R0+1
    882  0593		       4c e2 05 	      jmp	pushR0nextIl
    883  0596							;
    884  0596							;=====================================================
    885  0596							; Negate the top of stack.
    886  0596							;
    887  0596		       20 90 0c    iNEG       jsr	popR0
    888  0599		       a5 83		      lda	R0
    889  059b		       49 ff		      eor	#$ff
    890  059d		       85 83		      sta	R0
    891  059f		       a5 84		      lda	R0+1
    892  05a1		       49 ff		      eor	#$ff
    893  05a3		       85 84		      sta	R0+1
    894  05a5		       e6 83		      inc	R0
    895  05a7		       d0 02		      bne	iNEG2
    896  05a9		       e6 84		      inc	R0+1
    897  05ab		       4c e2 05    iNEG2      jmp	pushR0nextIl
    898  05ae							;
    899  05ae							;=====================================================
    900  05ae							; Multiply top two items on the stack, put the results
    901  05ae							; on top.  This uses the algorithm documented on page
    902  05ae							; 115 of "Microprocessor Programming for Computer
    903  05ae							; Hobbyists" by Neill Graham.
    904  05ae							;
    905  05ae		       20 90 0c    iMUL       jsr	popR0	;AC
    906  05b1		       20 c7 0c 	      jsr	popR1	;OP
    907  05b4							;
    908  05b4		       a5 83		      lda	R0
    909  05b6		       8d b1 12 	      sta	MQ
    910  05b9		       a5 84		      lda	R0+1
    911  05bb		       8d b2 12 	      sta	MQ+1
    912  05be		       a9 00		      lda	#0	;clear result
    913  05c0		       85 83		      sta	R0
    914  05c2		       85 84		      sta	R0+1
    915  05c4							;
    916  05c4		       a2 10		      ldx	#16	;number of bits in value
    917  05c6		       06 83	   multloop   asl	R0
    918  05c8		       26 84		      rol	R0+1
    919  05ca		       0e b1 12 	      asl	MQ
    920  05cd		       2e b2 12 	      rol	MQ+1
    921  05d0		       90 0d		      bcc	multno	;skip add if no carry
    922  05d2							;
    923  05d2							; Add R1 back into R0
    924  05d2							;
    925  05d2		       18		      clc
    926  05d3		       a5 83		      lda	R0
    927  05d5		       65 85		      adc	R1
    928  05d7		       85 83		      sta	R0
    929  05d9		       a5 84		      lda	R0+1
    930  05db		       65 86		      adc	R1+1
    931  05dd		       85 84		      sta	R0+1
    932  05df							;
    933  05df		       ca	   multno     dex		;did all bits yet?
    934  05e0		       d0 e4		      bne	multloop
    935  05e2							;
    936  05e2				   pushR0nextIl
    937  05e2		       20 46 0c 	      jsr	pushR0	;OP
    938  05e5		       4c eb 02 	      jmp	NextIL
    939  05e8							;
    940  05e8							;=====================================================
    941  05e8							; Divide the top of stack into the next to top item.
    942  05e8							; Leave results on stack.  Taken from:
    943  05e8							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
    944  05e8							;
    945  05e8							; MQ = R0 / R1
    946  05e8							; Remainder is in R0
    947  05e8							;
    948  05e8		       20 c7 0c    iDIV       jsr	popR1
    949  05eb		       20 90 0c 	      jsr	popR0
    950  05ee							;
    951  05ee							; Check for divide by zero
    952  05ee							;
    953  05ee		       a5 85		      lda	R1
    954  05f0		       05 86		      ora	R1+1
    955  05f2		       f0 36		      beq	divby0
    956  05f4							;
    957  05f4		       20 ef 0c 	      jsr	SaveSigns
    958  05f7		       a9 00		      lda	#0	;preset remainder to 0
    959  05f9		       8d b1 12 	      sta	MQ
    960  05fc		       8d b2 12 	      sta	MQ+1
    961  05ff		       a2 10		      ldx	#16	;repeat for each bit: ...
    962  0601
    963  0601		       06 83	   divloop    asl	R0	;dividend lb & hb*2, msb -> Carry
    964  0603		       26 84		      rol	R0+1
    965  0605		       2e b1 12 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
    966  0608		       2e b2 12 	      rol	MQ+1
    967  060b		       ad b1 12 	      lda	MQ
    968  060e		       38		      sec
    969  060f		       e5 85		      sbc	R1	;substract divisor to see if it fits in
    970  0611		       a8		      tay		;lb result -> Y, for we may need it later
    971  0612		       ad b2 12 	      lda	MQ+1
    972  0615		       e5 86		      sbc	R1+1
    973  0617		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
    974  0619
    975  0619		       8d b2 12 	      sta	MQ+1	;else save substraction result as new remainder,
    976  061c		       8c b1 12 	      sty	MQ
    977  061f		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
    978  0621
    979  0621		       ca	   skip       dex
    980  0622		       d0 dd		      bne	divloop
    981  0624		       20 2a 0d 	      jsr	RestoreSigns
    982  0627		       4c e2 05 	      jmp	pushR0nextIl
    983  062a							;
    984  062a							; Indicate divide-by-zero error
    985  062a							;
    986  062a		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
    987  062c		       a9 00		      lda	#0
    988  062e		       4c 21 05 	      jmp	iErr2
    989  0631							;
    990  0631							;=====================================================
    991  0631							; This pops the top two items off the stack.  The top
    992  0631							; item is a data value and the other is an index into
    993  0631							; the variable table.	Save the value into that entry.
    994  0631							;
    995  0631		       20 90 0c    iSTORE     jsr	popR0	;data
    996  0634		       20 c7 0c 	      jsr	popR1	;index
    997  0637		       a6 85		      ldx	R1	;get index
    998  0639		       a5 83		      lda	R0
    999  063b		       95 41		      sta	variables,x
   1000  063d		       a5 84		      lda	R0+1
   1001  063f		       95 42		      sta	variables+1,x
   1002  0641		       4c eb 02 	      jmp	NextIL
   1003  0644							;
   1004  0644							;=====================================================
   1005  0644							; Replaces the top of stack with the variable whose
   1006  0644							; index it represents.
   1007  0644							;
   1008  0644		       20 c7 0c    iIND       jsr	popR1
   1009  0647		       a6 85		      ldx	R1	;get index
   1010  0649		       b5 41		      lda	variables,x
   1011  064b		       85 83		      sta	R0
   1012  064d		       b5 42		      lda	variables+1,x
   1013  064f		       85 84		      sta	R0+1
   1014  0651		       4c e2 05 	      jmp	pushR0nextIl
   1015  0654							;
   1016  0654							;=====================================================
   1017  0654							; List the current BASIC program in memory.  Uses R0,
   1018  0654							; tempIly, and dpl.
   1019  0654							;
   1020  0654		       20 da 0d    iLST       jsr	SetOutConsole
   1021  0657		       a9 c2	   iLST2      lda	#ProgramStart&$ff
   1022  0659		       85 77		      sta	dpl
   1023  065b		       a9 12		      lda	#ProgramStart>>8
   1024  065d		       85 78		      sta	dpl+1
   1025  065f							;
   1026  065f							; dpl/dph point to the current line.  See if we're at
   1027  065f							; the end of the program.
   1028  065f							;
   1029  065f		       a5 77	   iLSTloop   lda	dpl
   1030  0661		       cd ba 12 	      cmp	PROGRAMEND
   1031  0664		       d0 07		      bne	iLstNotEnd
   1032  0666		       a5 78		      lda	dpl+1
   1033  0668		       cd bb 12 	      cmp	PROGRAMEND+1
   1034  066b		       f0 40		      beq	iLstdone
   1035  066d							;
   1036  066d		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1037  066f		       b1 77		      lda	(dpl),y	;line number LSB
   1038  0671		       85 83		      sta	R0
   1039  0673		       c8		      iny
   1040  0674		       b1 77		      lda	(dpl),y	;line number MSB
   1041  0676		       85 84		      sta	R0+1
   1042  0678		       c8		      iny
   1043  0679		       84 7b		      sty	tempIlY
   1044  067b		       20 e2 0a 	      jsr	PrintDecimal
   1045  067e		       a9 20		      lda	#SPACE
   1046  0680		       20 e5 0d 	      jsr	VOUTCH
   1047  0683		       a4 7b		      ldy	tempIlY
   1048  0685		       b1 77	   iLSTl2     lda	(dpl),y
   1049  0687		       f0 0a		      beq	iLST3	;end of this line
   1050  0689		       84 7b		      sty	tempIlY
   1051  068b		       20 e5 0d 	      jsr	VOUTCH
   1052  068e		       a4 7b		      ldy	tempIlY
   1053  0690		       c8		      iny
   1054  0691		       d0 f2		      bne	iLSTl2	;do next char
   1055  0693							;
   1056  0693							; End of this line.  Print CR/LF, then move to the
   1057  0693							; next line.
   1058  0693							;
   1059  0693		       c8	   iLST3      iny
   1060  0694		       18		      clc
   1061  0695		       98		      tya
   1062  0696		       65 77		      adc	dpl
   1063  0698		       85 77		      sta	dpl
   1064  069a		       a5 78		      lda	dpl+1
   1065  069c		       69 00		      adc	#0
   1066  069e		       85 78		      sta	dpl+1
   1067  06a0							;
   1068  06a0							; Have to manually do CR/LF so it uses the vectored
   1069  06a0							; output function.
   1070  06a0							;
   1071  06a0		       a9 0d		      lda	#CR
   1072  06a2		       20 e5 0d 	      jsr	VOUTCH
   1073  06a5		       a9 0a		      lda	#LF
   1074  06a7		       20 e5 0d 	      jsr	VOUTCH
   1075  06aa		       4c 5f 06 	      jmp	iLSTloop	;do next line
   1076  06ad							;
   1077  06ad		       20 da 0d    iLstdone   jsr	SetOutConsole
   1078  06b0		       4c eb 02 	      jmp	NextIL
   1079  06b3							;
   1080  06b3							;=====================================================
   1081  06b3							; Get a line of text into LINBUF.  Terminate with a
   1082  06b3							; null byte.
   1083  06b3							;
   1084  06b3		       a9 3e	   iGETLINE   lda	#'>	;prompt character
   1085  06b5		       20 c5 0b 	      jsr	GetLine
   1086  06b8							;
   1087  06b8		       a9 00		      lda	#0
   1088  06ba		       85 87		      sta	RunMode
   1089  06bc		       4c eb 02 	      jmp	NextIL
   1090  06bf							;
   1091  06bf							;=====================================================
   1092  06bf							; This is called when the input buffer contains a line
   1093  06bf							; typed in by the user that starts with a line number.
   1094  06bf							; Insert the line into the program or delete the line
   1095  06bf							; if there is nothing after the line number,
   1096  06bf							;
   1097  06bf		       a0 00	   iINSRT     ldy	#0
   1098  06c1		       20 4e 0b 	      jsr	getDecimal	;convert line #
   1099  06c4		       20 59 0d 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1100  06c7		       84 7c		      sty	offset	;Save the start of the program line text
   1101  06c9							;
   1102  06c9							; Now find the line OR the next higher line OR the
   1103  06c9							; end of the program.
   1104  06c9							;
   1105  06c9		       20 80 0a 	      jsr	findLine	; Look for the line number in the current program
   1106  06cc							; Returns Z and curptr point to the line if found
   1107  06cc							; Returns C and curptr at next higher line if not found and there is a higher line
   1108  06cc							; Returns ZC clear and curptr to end of program if higher than all other lines
   1109  06cc							;
   1110  06cc							; If the line exists, it needs to be removed.
   1111  06cc							;
   1112  06cc		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1113  06ce							;
   1114  06ce							; Get length of line to be removed, we fall thru to here if we find a matching line
   1115  06ce							;
   1116  06ce							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1117  06ce		       a0 00		      ldy	#0
   1118  06d0		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1119  06d2		       a8		      tay
   1120  06d3							;If it is equal we delete the line and replace it, get length
   1121  06d3							;then adjust all program line after up or down depending on len of line
   1122  06d3							;If next higher then just move everythimg down by length bytes
   1123  06d3							;This call will return how many bytes in the line we found
   1124  06d3		       84 7d		      sty	lineLength	;Save the length of the line we found
   1125  06d5							;
   1126  06d5							; Compute the new end of the program first.
   1127  06d5							;
   1128  06d5		       38		      sec		;Set the carry bit
   1129  06d6		       ad ba 12 	      lda	PROGRAMEND	;Get low byte of program end
   1130  06d9		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1131  06db		       8d ba 12 	      sta	PROGRAMEND	;save it
   1132  06de		       ad bb 12 	      lda	PROGRAMEND+1
   1133  06e1		       e9 00		      sbc	#0	;Process the carry
   1134  06e3		       8d bb 12 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1135  06e6							;
   1136  06e6							; Copy CURPTR into R1 for working
   1137  06e6							;
   1138  06e6		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1139  06e8		       85 85		      sta	R1
   1140  06ea		       a5 7f		      lda	CURPTR+1
   1141  06ec		       85 86		      sta	R1+1
   1142  06ee							;
   1143  06ee							; See if we're at the end.
   1144  06ee							;
   1145  06ee		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1146  06f0		       cd ba 12 	      cmp	PROGRAMEND
   1147  06f3		       d0 07		      bne	InsDelLoop
   1148  06f5		       a5 86		      lda	R1+1
   1149  06f7		       cd bb 12 	      cmp	PROGRAMEND+1
   1150  06fa		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1151  06fc							;
   1152  06fc							; Move one byte, move to next location.
   1153  06fc							;
   1154  06fc		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1155  06fe		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1156  0700		       b1 85		      lda	(R1),y
   1157  0702		       a0 00		      ldy	#0
   1158  0704		       91 85		      sta	(R1),y
   1159  0706		       e6 85		      inc	R1
   1160  0708		       d0 e4		      bne	InsDelChk
   1161  070a		       e6 86		      inc	R1+1
   1162  070c		       4c ee 06 	      jmp	InsDelChk	; Check if we have moved the last byte
   1163  070f							;
   1164  070f							; Deletion is done.
   1165  070f							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1166  070f							;
   1167  070f		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1168  0711		       b9 27 12 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1169  0714		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1170  0716							;
   1171  0716							; CURPTR points to where the line will be inserted.
   1172  0716							;
   1173  0716		       20 22 0c 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1174  0719							;
   1175  0719		       ad ba 12 	      lda	PROGRAMEND	;Load the start address for the copy
   1176  071c							;At this point curptr still contains the location we will insert data
   1177  071c		       85 88		      sta	FROM
   1178  071e		       ad bb 12 	      lda	PROGRAMEND+1
   1179  0721		       85 89		      sta	FROM+1
   1180  0723							;
   1181  0723		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1182  0725		       b1 88		      lda	(FROM),y
   1183  0727		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1184  0729		       91 88		      sta	(FROM),y	;Save the new byte
   1185  072b							;
   1186  072b		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1187  072d		       c5 7e		      cmp	CURPTR
   1188  072f		       d0 06		      bne	mvUpMore
   1189  0731		       a5 89		      lda	FROM+1
   1190  0733		       c5 7f		      cmp	CURPTR+1
   1191  0735		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1192  0737							;
   1193  0737							; Not done yet
   1194  0737							;
   1195  0737		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1196  0739		       d0 02		      bne	mvUpMore2
   1197  073b		       c6 89		      dec	FROM+1
   1198  073d		       c6 88	   mvUpMore2  dec	FROM
   1199  073f		       4c 23 07 	      jmp	mvup1	;Loop until everything is moved
   1200  0742							;
   1201  0742							; All done with copy.
   1202  0742							;
   1203  0742		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1204  0743		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1205  0745		       6d ba 12 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1206  0748		       8d ba 12 	      sta	PROGRAMEND
   1207  074b		       ad bb 12 	      lda	PROGRAMEND+1
   1208  074e		       69 00		      adc	#0
   1209  0750		       8d bb 12 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1210  0753							;
   1211  0753							;===================jlit use length before line newline
   1212  0753
   1213  0753		       a0 00		      ldy	#0	;Set offset of copy
   1214  0755		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1215  0757		       91 7e		      sta	(CURPTR),y	;Store the length
   1216  0759		       c8		      iny
   1217  075a		       a5 83		      lda	R0	;Store the line number next
   1218  075c		       91 7e		      sta	(CURPTR),y
   1219  075e		       c8		      iny
   1220  075f		       a5 84		      lda	R0+1
   1221  0761		       91 7e		      sta	(CURPTR),y
   1222  0763		       c8		      iny
   1223  0764							;
   1224  0764		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1225  0766		       bd 27 12    mvUpLoop2  lda	LINBUF,x	;get a byte
   1226  0769		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1227  076b		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1228  076d		       e8		      inx
   1229  076e		       c8		      iny
   1230  076f		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1231  0771							;
   1232  0771		       4c eb 02    mvUpFini   jmp	NextIL
   1233  0774							;
   1234  0774							;=====================================================
   1235  0774							; Pops the top value of the ILPC stack and stores it
   1236  0774							; in ILPC.  Ie, return from an IL subroutine.
   1237  0774							;
   1238  0774		       20 6d 0a    iRTN       jsr	popILPC
   1239  0777		       4c eb 02 	      jmp	NextIL
   1240  077a							;
   1241  077a							;=====================================================
   1242  077a							; NLINE print a newline
   1243  077a							;
   1244  077a		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1245  077d		       4c eb 02 	      jmp	NextIL
   1246  0780							;
   1247  0780							;=====================================================
   1248  0780							; This saves the current ILPC value on the stack, then
   1249  0780							; jumps to the address specified by the next two bytes.
   1250  0780							;
   1251  0780		       20 53 0a    iCALL      jsr	pushILPC	;save ILPC
   1252  0783							;
   1253  0783							; Jmp to a specific location in the IL code.  The new
   1254  0783							; address immediately follows the opcode.
   1255  0783							;
   1256  0783		       20 39 0a    iJMP       jsr	getILWord
   1257  0786		       86 75		      stx	ILPC
   1258  0788		       85 76		      sta	ILPC+1
   1259  078a		       4c eb 02 	      jmp	NextIL
   1260  078d							;
   1261  078d							;=====================================================
   1262  078d							; Push the next two bytes onto the arithmetic stack.
   1263  078d							;
   1264  078d		       20 39 0a    iLIT       jsr	getILWord
   1265  0790		       86 83		      stx	R0
   1266  0792		       85 84		      sta	R0+1
   1267  0794		       20 46 0c 	      jsr	pushR0
   1268  0797		       4c eb 02 	      jmp	NextIL
   1269  079a							;
   1270  079a							;=====================================================
   1271  079a							; Initialize all variables.  Ie, set to zero.
   1272  079a							;
   1273  079a		       a9 00	   iVINIT     lda	#0
   1274  079c		       a2 00		      ldx	#0
   1275  079e		       95 41	   Vinit2     sta	variables,x
   1276  07a0		       e8		      inx
   1277  07a1		       e0 34		      cpx	#variablesEnd-variables
   1278  07a3		       d0 f9		      bne	Vinit2
   1279  07a5		       4c eb 02 	      jmp	NextIL
   1280  07a8							;
   1281  07a8							;=====================================================
   1282  07a8							; Set the address of the error handler.  After any
   1283  07a8							; error, set to the ILPC to the specified location.
   1284  07a8							;
   1285  07a8		       20 39 0a    iERRGOTO   jsr	getILWord
   1286  07ab		       8e af 12 	      stx	errGoto
   1287  07ae		       8d b0 12 	      sta	errGoto+1
   1288  07b1		       4c eb 02 	      jmp	NextIL
   1289  07b4							;
   1290  07b4							;=====================================================
   1291  07b4							; TST is followed by an 8 bit signed offset, then a
   1292  07b4							; null terminated string.  Compare the string against
   1293  07b4							; the string starting at (CURPTR),CUROFF.  If the
   1294  07b4							; strings match, continue executing the next IL
   1295  07b4							; opcode.  Else, add the offset to ILPC.
   1296  07b4							;
   1297  07b4		       20 3d 0a    iTST       jsr	getILByte
   1298  07b7		       85 7c		      sta	offset
   1299  07b9							;
   1300  07b9		       20 34 0c 	      jsr	saveIL	;in case of failure
   1301  07bc		       a4 80		      ldy	CUROFF
   1302  07be		       84 77		      sty	dpl	;save for later
   1303  07c0							;
   1304  07c0		       20 3d 0a    iTSTloop   jsr	getILByte	;get next char
   1305  07c3		       f0 11		      beq	iTSTm	;match!
   1306  07c5		       a4 77		      ldy	dpl
   1307  07c7		       d1 7e		      cmp	(CURPTR),y
   1308  07c9		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1309  07cb		       09 20		      ora	#$20	; lets allow lowercase as well
   1310  07cd		       d1 7e		      cmp	(CURPTR),y
   1311  07cf		       d0 22		      bne	iTSTfail	;mismatch
   1312  07d1		       c8	   iTSTUpper  iny
   1313  07d2		       84 77		      sty	dpl
   1314  07d4		       d0 ea		      bne	iTSTloop
   1315  07d6							;
   1316  07d6							; It's a match!  Clean up a bit.
   1317  07d6							;
   1318  07d6		       a4 77	   iTSTm      ldy	dpl
   1319  07d8		       84 80		      sty	CUROFF
   1320  07da		       4c eb 02 	      jmp	NextIL
   1321  07dd							; Test for a single quote
   1322  07dd		       20 3d 0a    iTSTStr    jsr	getILByte
   1323  07e0		       85 7c		      sta	offset
   1324  07e2		       20 34 0c 	      jsr	saveIL
   1325  07e5		       a4 80		      ldy	CUROFF
   1326  07e7		       a9 22		      lda	#'"
   1327  07e9		       d1 7e		      cmp	(CURPTR),y
   1328  07eb		       d0 06		      bne	iTSTfail
   1329  07ed		       c8		      iny
   1330  07ee		       84 80		      sty	CUROFF
   1331  07f0		       4c f9 02 	      jmp	NextILStr
   1332  07f3							;
   1333  07f3							; Not a match, reset ILPC and then move to the
   1334  07f3							; offset.
   1335  07f3							;
   1336  07f3		       20 3d 0c    iTSTfail   jsr	restoreIL
   1337  07f6		       4c 9e 08 	      jmp	tstBranch
   1338  07f9							;
   1339  07f9							;=================================================JLIT=
   1340  07f9							; Test if we have a let statement without the let keyword
   1341  07f9		       20 3d 0a    iTSTLET    jsr	getILByte
   1342  07fc		       85 7c		      sta	offset
   1343  07fe		       20 34 0c 	      jsr	saveIL	; save to restore when done
   1344  0801
   1345  0801		       a4 80		      ldy	CUROFF
   1346  0803		       20 59 0d 	      jsr	SkipSpaces
   1347  0806		       c8		      iny		; skip the Variable name
   1348  0807		       20 59 0d 	      jsr	SkipSpaces	; skip any SkipSpaces
   1349  080a		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1350  080c		       c9 3d		      cmp	#'=	; check if equals
   1351  080e		       d0 e3		      bne	iTSTfail	; return it failed
   1352  0810		       20 3d 0c 	      jsr	restoreIL	; restore the IL anyway
   1353  0813		       4c eb 02 	      jmp	NextIL	; Then next instruction
   1354  0816
   1355  0816							;================================================jLIT=
   1356  0816							;Test for end of line
   1357  0816							;
   1358  0816		       20 3d 0a    iTSTDONE   jsr	getILByte
   1359  0819		       85 7c		      sta	offset
   1360  081b		       20 34 0c 	      jsr	saveIL
   1361  081e		       a4 80		      ldy	CUROFF
   1362  0820		       84 77		      sty	dpl
   1363  0822		       20 59 0d 	      jsr	SkipSpaces
   1364  0825		       b1 7e		      lda	(CURPTR),y
   1365  0827		       f0 0b		      beq	iTSTDONEtrue
   1366  0829		       c9 3a		      cmp	#COLON
   1367  082b		       f0 07		      beq	iTSTDONEtrue
   1368  082d		       a4 77		      ldy	dpl
   1369  082f		       84 80		      sty	CUROFF
   1370  0831		       4c f3 07 	      jmp	iTSTfail
   1371  0834							;
   1372  0834							; Advance to the next line
   1373  0834							;
   1374  0834				   iTSTDONEtrue
   1375  0834		       4c eb 02 	      jmp	NextIL
   1376  0837							;
   1377  0837							;=====================================================
   1378  0837							; TSTV is followed by an 8 bit signed offset.	If the
   1379  0837							; value at (CURPTR),CUROFF appears to be a variable
   1380  0837							; name, move to the next IL statement.  Else, add the
   1381  0837							; offset to ILPC.
   1382  0837							;
   1383  0837		       20 3d 0a    iTSTV      jsr	getILByte	;offset
   1384  083a		       85 7c		      sta	offset
   1385  083c							;
   1386  083c		       a4 80		      ldy	CUROFF
   1387  083e		       20 59 0d 	      jsr	SkipSpaces
   1388  0841		       b1 7e		      lda	(CURPTR),y
   1389  0843							;
   1390  0843		       09 20		      ora	#$20	;make lower then upper
   1391  0845		       49 20		      eor	#$20	;allow lower case here
   1392  0847		       c9 41		      cmp	#'A
   1393  0849		       90 53		      bcc	tstBranch
   1394  084b		       c9 5b		      cmp	#'Z+1
   1395  084d		       b0 4f		      bcs	tstBranch
   1396  084f							;
   1397  084f							; The condition is true, so convert to an index, push
   1398  084f							; it onto the stack and continue running.
   1399  084f							;
   1400  084f		       38		      sec
   1401  0850		       e9 41		      sbc	#'A	;index is zero based
   1402  0852		       0a		      asl		;multiply by two
   1403  0853		       85 83		      sta	R0
   1404  0855		       a9 00		      lda	#0
   1405  0857		       85 84		      sta	R0+1
   1406  0859		       20 46 0c 	      jsr	pushR0	;put index onto stack
   1407  085c		       e6 80		      inc	CUROFF	;move to next input char
   1408  085e		       4c eb 02 	      jmp	NextIL
   1409  0861							;
   1410  0861							;=====================================================
   1411  0861							; TSTL seems basically the same as TSTN, but leave the
   1412  0861							; value in R0 instead of pushing onto stack.
   1413  0861							; This tests for a valid line number
   1414  0861							;
   1415  0861		       20 3d 0a    iTSTL      jsr	getILByte
   1416  0864		       85 7c		      sta	offset
   1417  0866							;
   1418  0866		       a4 80		      ldy	CUROFF
   1419  0868		       20 59 0d 	      jsr	SkipSpaces
   1420  086b		       b1 7e		      lda	(CURPTR),y
   1421  086d							;
   1422  086d		       c9 30		      cmp	#'0
   1423  086f		       90 2d		      bcc	tstBranch
   1424  0871		       c9 3a		      cmp	#'9+1
   1425  0873		       b0 29		      bcs	tstBranch
   1426  0875							;
   1427  0875							; It's a digit, so convert to a number.
   1428  0875							;
   1429  0875		       20 4e 0b 	      jsr	getDecimal
   1430  0878		       4c eb 02 	      jmp	NextIL
   1431  087b							;
   1432  087b							;=====================================================
   1433  087b							; TSTN checks for a number.  This is very simplistic;
   1434  087b							; if the character is a digit, assume it's a number.
   1435  087b							; Convert to a number and push it onto the stack.
   1436  087b							;
   1437  087b		       20 3d 0a    iTSTN      jsr	getILByte
   1438  087e		       85 7c		      sta	offset
   1439  0880							;
   1440  0880		       a4 80		      ldy	CUROFF
   1441  0882		       20 59 0d 	      jsr	SkipSpaces
   1442  0885		       b1 7e		      lda	(CURPTR),y
   1443  0887		       c9 2d		      cmp	#'-	;negative?
   1444  0889		       f0 08		      beq	iTSTN_1
   1445  088b		       c9 30		      cmp	#'0
   1446  088d		       90 0f		      bcc	tstBranch
   1447  088f		       c9 3a		      cmp	#'9+1
   1448  0891		       b0 0b		      bcs	tstBranch
   1449  0893							;
   1450  0893							; It's a digit, so convert to a number.
   1451  0893							;
   1452  0893		       20 4e 0b    iTSTN_1    jsr	getDecimal
   1453  0896		       84 80		      sty	CUROFF
   1454  0898		       20 46 0c 	      jsr	pushR0	;save onto stack
   1455  089b		       4c eb 02 	      jmp	NextIL
   1456  089e
   1457  089e							;
   1458  089e							; Common jump point for all TSTx instructions that
   1459  089e							; fail to meet the requirements.  This takes the
   1460  089e							; offset and adds/subtracts to/from ILPC.
   1461  089e							;
   1462  089e		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1463  08a0		       10 0e		      bpl	tstPositive
   1464  08a2							;
   1465  08a2							; Do negative branch.	Do sign extension.
   1466  08a2							;
   1467  08a2		       18		      clc
   1468  08a3		       65 75		      adc	ILPC
   1469  08a5		       85 75		      sta	ILPC
   1470  08a7		       a5 76		      lda	ILPC+1
   1471  08a9		       69 ff		      adc	#$ff
   1472  08ab		       85 76		      sta	ILPC+1
   1473  08ad		       4c eb 02 	      jmp	NextIL	;keep going
   1474  08b0							;
   1475  08b0		       18	   tstPositive clc
   1476  08b1		       65 75		      adc	ILPC
   1477  08b3		       85 75		      sta	ILPC
   1478  08b5		       a5 76		      lda	ILPC+1
   1479  08b7		       69 00		      adc	#0
   1480  08b9		       85 76		      sta	ILPC+1
   1481  08bb		       4c eb 02 	      jmp	NextIL
   1482  08be
   1483  08be							;
   1484  08be							;====================================================
   1485  08be							;Test for IRQ pending
   1486  08be							;
   1487  08be		       20 3d 0a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1488  08c1		       85 7c		      sta	offset
   1489  08c3		       ad aa 02 	      lda	IRQPending
   1490  08c6		       f0 d6		      beq	tstBranch
   1491  08c8		       c9 01		      cmp	#1	; only do this if set to first time
   1492  08ca		       d0 d2		      bne	tstBranch
   1493  08cc		       78		      sei		; disable the interupt until ireturn resets it
   1494  08cd		       ee aa 02    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1495  08d0		       20 59 0c 	      jsr	pushLN	; Push the next line to be executed
   1496  08d3		       b0 11		      bcs	irqErra	; Check if there was an error
   1497  08d5		       ad ab 02 	      lda	IRQEntry	; Get the line number to branch to
   1498  08d8		       85 7e		      sta	CURPTR	; put line number into r0
   1499  08da		       ad ac 02 	      lda	IRQEntry+1
   1500  08dd		       85 7f		      sta	CURPTR+1
   1501  08df		       a9 03		      lda	#3
   1502  08e1		       85 80		      sta	CUROFF
   1503  08e3		       4c eb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1504  08e6		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1505  08e8		       a9 00		      lda	#0	; stop the execution
   1506  08ea		       4c 21 05 	      jmp	iErr2
   1507  08ed							;
   1508  08ed							;=====================================================
   1509  08ed							; This places the number of free bytes on top of the
   1510  08ed							; stack.
   1511  08ed							;
   1512  08ed		       20 a7 0d    iFREE      jsr	GetSizes
   1513  08f0		       20 46 0c 	      jsr	pushR0
   1514  08f3		       4c eb 02 	      jmp	NextIL
   1515  08f6							;
   1516  08f6							;=====================================================
   1517  08f6							; Generate a random number from 0-FFFF and then MOD
   1518  08f6							; it with the value on top of stack.  Leaves number on
   1519  08f6							; stack
   1520  08f6							;
   1521  08f6		       20 c7 0c    iRANDOM    jsr	popR1	;mod value
   1522  08f9							;
   1523  08f9							; If the value is zero, just return a one.
   1524  08f9							;
   1525  08f9		       a5 85		      lda	R1
   1526  08fb		       05 86		      ora	R1+1
   1527  08fd		       f0 63		      beq	irandom1
   1528  08ff							;
   1529  08ff		       ad b6 12 	      lda	random+1
   1530  0902		       8d b4 12 	      sta	rtemp1
   1531  0905		       ad b5 12 	      lda	random
   1532  0908		       0a		      asl
   1533  0909		       2e b4 12 	      rol	rtemp1
   1534  090c		       0a		      asl
   1535  090d		       2e b4 12 	      rol	rtemp1
   1536  0910		       18		      clc
   1537  0911		       6d b5 12 	      adc	random
   1538  0914		       48		      pha
   1539  0915		       ad b4 12 	      lda	rtemp1
   1540  0918		       6d b6 12 	      adc	random+1
   1541  091b		       8d b6 12 	      sta	random+1
   1542  091e		       68		      pla
   1543  091f		       69 11		      adc	#$11
   1544  0921		       8d b5 12 	      sta	random
   1545  0924		       ad b6 12 	      lda	random+1
   1546  0927		       69 36		      adc	#$36
   1547  0929		       8d b6 12 	      sta	random+1
   1548  092c
   1549  092c		       ad b5 12 	      lda	random
   1550  092f		       85 83		      sta	R0
   1551  0931		       ad b6 12 	      lda	random+1
   1552  0934		       29 7f		      and	#$7f	;make positive
   1553  0936		       85 84		      sta	R0+1
   1554  0938							;
   1555  0938							; R0 contains the number and R1 contains the max value.
   1556  0938							;
   1557  0938		       a5 83	   iRANDOM_2  lda	R0
   1558  093a		       c5 85		      cmp	R1
   1559  093c		       d0 16		      bne	iRANDOM_1
   1560  093e		       a5 84		      lda	R0+1
   1561  0940		       c5 86		      cmp	R1+1
   1562  0942		       d0 10		      bne	iRANDOM_1	;need to subtract
   1563  0944							;
   1564  0944							; Subtract R1 from R0
   1565  0944							;
   1566  0944		       38	   iRANDOM_sub sec
   1567  0945		       a5 83		      lda	R0
   1568  0947		       e5 85		      sbc	R1
   1569  0949		       85 83		      sta	R0
   1570  094b		       a5 84		      lda	R0+1
   1571  094d		       e5 86		      sbc	R1+1
   1572  094f		       85 84		      sta	R0+1
   1573  0951		       4c 38 09 	      jmp	iRANDOM_2
   1574  0954							;
   1575  0954							; See if R1 > R0.  If so, branch to subtract.
   1576  0954							;
   1577  0954		       a5 83	   iRANDOM_1  lda	R0
   1578  0956		       c5 85		      cmp	R1
   1579  0958		       a5 84		      lda	R0+1
   1580  095a		       e5 86		      sbc	R1+1
   1581  095c		       50 02		      bvc	iRANDOM_4
   1582  095e		       49 80		      eor	#$80
   1583  0960		       10 e2	   iRANDOM_4  bpl	iRANDOM_sub
   1584  0962							;
   1585  0962							; All done.  Almost.  Add one, then push the result.
   1586  0962							;
   1587  0962		       e6 83	   irandom1   inc	R0
   1588  0964		       d0 02		      bne	iRANDOM_3
   1589  0966		       e6 84		      inc	R0+1
   1590  0968				   iRANDOM_3
   1591  0968		       20 46 0c 	      jsr	pushR0	;return value
   1592  096b		       4c eb 02 	      jmp	NextIL
   1593  096e							;
   1594  096e							; Poke a value into a memory location
   1595  096e		       8c b9 12    iPOKEMEMORY sty	tempy
   1596  0971		       20 90 0c 	      jsr	popR0
   1597  0974		       20 c7 0c 	      jsr	popR1
   1598  0977		       a0 00		      ldy	#0
   1599  0979		       a5 83		      lda	R0
   1600  097b		       91 85		      sta	(R1),y
   1601  097d		       ac b9 12 	      ldy	tempy
   1602  0980		       4c eb 02 	      jmp	NextIL
   1603  0983							;
   1604  0983							; Get a value from a memory location
   1605  0983							;
   1606  0983		       8c b9 12    iPEEKMEMORY sty	tempy
   1607  0986		       20 90 0c 	      jsr	popR0
   1608  0989		       a0 00		      ldy	#0
   1609  098b		       b1 83		      lda	(R0),y
   1610  098d		       ac b9 12 	      ldy	tempy
   1611  0990		       85 83		      sta	R0
   1612  0992		       a9 00		      lda	#0
   1613  0994		       85 84		      sta	R0+1
   1614  0996		       20 46 0c 	      jsr	pushR0
   1615  0999		       4c eb 02 	      jmp	NextIL
   1616  099c							;
   1617  099c							; Call to address return what ever is in a to the stack
   1618  099c							; func2 will load a value into a before the call
   1619  099c		       20 c7 0c    iCallFunc2 jsr	popR1
   1620  099f		       a5 85		      lda	R1
   1621  09a1		       20 b0 09    iCallFunc  jsr	iCallRtn
   1622  09a4		       85 83		      sta	R0
   1623  09a6		       a9 00		      lda	#0
   1624  09a8		       85 84		      sta	R0+1
   1625  09aa		       20 46 0c 	      jsr	pushR0
   1626  09ad		       4c eb 02 	      jmp	NextIL
   1627  09b0		       20 90 0c    iCallRtn   jsr	popR0
   1628  09b3		       6c 83 00 	      jmp	(R0)
   1629  09b6
   1630  09b6
   1631  09b6							;===========================================jlit======
   1632  09b6							;Get a character from the terminal convert to value
   1633  09b6							;leave the number on top f the stack
   1634  09b6							;
   1635  09b6				   iGETCHAR
   1636  09b6		       a5 80		      lda	CUROFF	;save state before GetLine
   1637  09b8		       48		      pha
   1638  09b9		       a5 7f		      lda	CURPTR+1
   1639  09bb		       48		      pha
   1640  09bc		       a5 7e		      lda	CURPTR
   1641  09be		       48		      pha
   1642  09bf							;
   1643  09bf		       20 09 02 	      jsr	GETCH
   1644  09c2					      if	CTMON65
   1645  09c2		       48		      pha
   1646  09c3		       20 0c f0 	      jsr	cout	;echo echo echo
   1647  09c6		       68		      pla
   1648  09c7					      endif
   1649  09c7		       85 83		      sta	R0
   1650  09c9		       a9 00		      lda	#0
   1651  09cb		       85 84		      sta	R0+1
   1652  09cd		       20 46 0c 	      jsr	pushR0
   1653  09d0							;
   1654  09d0		       68		      pla
   1655  09d1		       85 7e		      sta	CURPTR
   1656  09d3		       68		      pla
   1657  09d4		       85 7f		      sta	CURPTR+1
   1658  09d6		       68		      pla
   1659  09d7		       85 80		      sta	CUROFF
   1660  09d9
   1661  09d9		       4c eb 02 	      jmp	NextIL
   1662  09dc							;===========================================jlit======
   1663  09dc							;Put a character to the terminal convert to
   1664  09dc							;
   1665  09dc		       20 90 0c    iPUTCHAR   jsr	popR0
   1666  09df		       a5 83		      lda	R0
   1667  09e1		       20 06 02 	      jsr	OUTCH
   1668  09e4		       4c eb 02 	      jmp	NextIL
   1669  09e7							;
   1670  09e7							;
   1671  09e7							;=====================================================
   1672  09e7							; Replace TOS with its absolute value.
   1673  09e7							;
   1674  09e7		       20 90 0c    iABS       jsr	popR0
   1675  09ea		       a5 84		      lda	R0+1
   1676  09ec		       10 10		      bpl	iABS_1	;already positive
   1677  09ee		       49 ff		      eor	#$ff
   1678  09f0		       85 84		      sta	R0+1
   1679  09f2		       a5 83		      lda	R0
   1680  09f4		       49 ff		      eor	#$ff
   1681  09f6		       85 83		      sta	R0
   1682  09f8		       e6 83		      inc	R0
   1683  09fa		       d0 02		      bne	iABS_1
   1684  09fc		       e6 84		      inc	R0+1
   1685  09fe		       20 46 0c    iABS_1     jsr	pushR0
   1686  0a01		       4c eb 02 	      jmp	NextIL
   1687  0a04							;
   1688  0a04							;================================================================
   1689  0a04							;Set the IRQ service rtn line number
   1690  0a04							;
   1691  0a04		       78	   iSetIrq    sei		; disable the interupts
   1692  0a05		       a9 00		      lda	#0	; Zero the Status flag
   1693  0a07		       8d a9 02 	      sta	IRQStatus
   1694  0a0a		       20 90 0c 	      jsr	popR0	; get the line number
   1695  0a0d		       a5 83		      lda	R0
   1696  0a0f		       05 84		      ora	R0+1
   1697  0a11		       f0 23		      beq	iSetExt	; if it is zero disable all
   1698  0a13		       a5 80		      lda	CUROFF
   1699  0a15		       8d a8 02 	      sta	SaveIrqReg	; save the offset
   1700  0a18		       20 59 0c 	      jsr	pushLN	; Save the current line pointer
   1701  0a1b		       20 80 0a 	      jsr	findLine	; Find the IRQ func Line Pointer
   1702  0a1e		       a5 7f		      lda	CURPTR+1	; Copy it to the Entry pointer
   1703  0a20		       8d ac 02 	      sta	IRQEntry+1
   1704  0a23		       a5 7e		      lda	CURPTR
   1705  0a25		       8d ab 02 	      sta	IRQEntry
   1706  0a28		       a9 01		      lda	#1	; Indicate there is an irq gosub
   1707  0a2a		       8d a9 02 	      sta	IRQStatus
   1708  0a2d		       20 a3 0c 	      jsr	popLN	; Restore the old line number
   1709  0a30		       ad a8 02 	      lda	SaveIrqReg
   1710  0a33		       85 80		      sta	CUROFF	; restore the offset
   1711  0a35		       58		      cli		; Enable the interupts
   1712  0a36		       4c eb 02    iSetExt    jmp	NextIL
   1713  0a39
   1714  0a39							;================================================================
   1715  0a39							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0a39					      include	"support.asm"
      1  0a39							;
      2  0a39							;=====================================================
      3  0a39							;=====================================================
      4  0a39							;=====================================================
      5  0a39							; This marks the start of support functions used by
      6  0a39							; the IL opcodes.  These are support functions, NOT
      7  0a39							; the IL code.
      8  0a39							;=====================================================
      9  0a39		       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting
     10  0a39							;=====================================================
     11  0a39					      Seg	Code
     12  0a39							;=====================================================
     13  0a39							; This gets the next two bytes pointed to by ILPC and
     14  0a39							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0a39							; is advanced by two, and Y contains 0 on return.
     16  0a39
     17  0a39							;
     18  0a39		       20 3d 0a    getILWord  jsr	getILByte	;LSB
     19  0a3c		       aa		      tax
     20  0a3d							;
     21  0a3d							;=====================================================
     22  0a3d							; This gets the next byte pointed to by ILPC and
     23  0a3d							; returns it in A.  On return, X is unchanged but Y
     24  0a3d							; contains 0.
     25  0a3d							;
     26  0a3d		       a0 00	   getILByte  ldy	#0
     27  0a3f		       b1 75		      lda	(ILPC),y	;get byte
     28  0a41		       08		      php		;save status
     29  0a42		       e6 75		      inc	ILPC	;inc LSB
     30  0a44		       d0 02		      bne	getILb2	;branch if no overflow
     31  0a46		       e6 76		      inc	ILPC+1	;inc MSB
     32  0a48		       28	   getILb2    plp		;restore status
     33  0a49		       60		      rts
     34  0a4a							;
     35  0a4a							;=====================================================
     36  0a4a							; Decrement ILPC by one.
     37  0a4a							;
     38  0a4a		       a5 75	   decIL      lda	ILPC
     39  0a4c		       d0 02		      bne	decIL2
     40  0a4e		       c6 76		      dec	ILPC+1
     41  0a50		       c6 75	   decIL2     dec	ILPC
     42  0a52		       60		      rts
     43  0a53							;
     44  0a53							;=====================================================
     45  0a53							; Push the ILPC onto the return stack.  Actually, this
     46  0a53							; pushes the address of ILPC+2 since that's the next
     47  0a53							; address to execute.
     48  0a53							;
     49  0a53		       ac 25 12    pushILPC   ldy	retStackPtr
     50  0a56		       a5 75		      lda	ILPC
     51  0a58		       18		      clc
     52  0a59		       69 02		      adc	#2
     53  0a5b		       99 15 12 	      sta	retStack,y
     54  0a5e		       08		      php		;save C bit
     55  0a5f		       c8		      iny
     56  0a60		       a5 76		      lda	ILPC+1
     57  0a62		       28		      plp		;restore C
     58  0a63		       69 00		      adc	#0
     59  0a65		       99 15 12 	      sta	retStack,y
     60  0a68		       c8		      iny
     61  0a69		       8c 25 12 	      sty	retStackPtr
     62  0a6c		       60		      rts
     63  0a6d							;
     64  0a6d							;=====================================================
     65  0a6d							; Pull the top entry from return stack and put into
     66  0a6d							; ILPC.
     67  0a6d							;
     68  0a6d		       ac 25 12    popILPC    ldy	retStackPtr
     69  0a70		       88		      dey
     70  0a71		       b9 15 12 	      lda	retStack,y
     71  0a74		       85 76		      sta	ILPC+1
     72  0a76		       88		      dey
     73  0a77		       b9 15 12 	      lda	retStack,y
     74  0a7a		       85 75		      sta	ILPC
     75  0a7c		       8c 25 12 	      sty	retStackPtr
     76  0a7f		       60		      rts
     77  0a80							;
     78  0a80							;=====================================================
     79  0a80							; This searches for a specific line number that is in
     80  0a80							; R0.	There are three possible return conditions:
     81  0a80							; Line numbers are now the third byte, the first byte is now **************
     82  0a80							; a pointer to the next line, of course no longer that 53 byte
     83  0a80							; per line.
     84  0a80							;
     85  0a80							; Exact match was found:
     86  0a80							;    * Z set
     87  0a80							;    * CURPTR points to two-byte line number for that
     88  0a80							;	line.
     89  0a80							;
     90  0a80							; Next highest line found:
     91  0a80							;    * Z cleared
     92  0a80							;    * C set
     93  0a80							;    * CURPTR points to two-byte line number for that
     94  0a80							;	line.
     95  0a80							;
     96  0a80							; End of program reached:
     97  0a80							;    * Z cleared
     98  0a80							;    * C cleared
     99  0a80							;    * CURPTR points to first free byte at end of
    100  0a80							;	program.  Ie, it has save value as PROGRAMEND.
    101  0a80							;
    102  0a80							; A, X, and Y are all undefined on return.
    103  0a80							;
    104  0a80
    105  0a80		       a9 c2	   findLine   lda	#ProgramStart&$ff	;Start of program -> CURPTR
    106  0a82		       85 7e		      sta	CURPTR
    107  0a84		       a9 12		      lda	#ProgramStart>>8
    108  0a86		       85 7f		      sta	CURPTR+1
    109  0a88							;
    110  0a88							; At end of code?
    111  0a88							;
    112  0a88		       a5 7e	   iXFER1     lda	CURPTR	; chk CURPTR = END PROGRAM
    113  0a8a		       cd ba 12 	      cmp	PROGRAMEND
    114  0a8d		       d0 0b		      bne	xfer2	;not end
    115  0a8f		       a5 7f		      lda	CURPTR+1
    116  0a91		       cd bb 12 	      cmp	PROGRAMEND+1
    117  0a94		       d0 04		      bne	xfer2	;Not at end
    118  0a96							;
    119  0a96							; Line not found and the end of the program was
    120  0a96							; reached.  Return Z and C both clear.
    121  0a96							;
    122  0a96		       a9 01		      lda	#1	;clear Z
    123  0a98		       18		      clc		;clear C
    124  0a99		       60		      rts
    125  0a9a							;
    126  0a9a							; Check for an exact line number match
    127  0a9a							;
    128  0a9a		       a5 83	   xfer2      lda	R0
    129  0a9c		       a0 01		      ldy	#1	; changed to skip extra length byte
    130  0a9e		       d1 7e		      cmp	(CURPTR),y
    131  0aa0		       d0 08		      bne	xfernotit
    132  0aa2		       c8		      iny
    133  0aa3		       a5 84		      lda	R0+1
    134  0aa5		       d1 7e		      cmp	(CURPTR),y
    135  0aa7		       d0 01		      bne	xfernotit	; not a matching line number
    136  0aa9							;
    137  0aa9							; This is exactly the line we want.
    138  0aa9							;
    139  0aa9		       60		      rts		;it matches exactly
    140  0aaa							;
    141  0aaa							; See if this line is greater than the one we're
    142  0aaa							; searching for.
    143  0aaa							;
    144  0aaa		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    145  0aac		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    146  0aae		       c5 84		      cmp	R0+1
    147  0ab0		       90 0b		      bcc	xfer3
    148  0ab2		       d0 07		      bne	xfer4
    149  0ab4		       88		      dey
    150  0ab5		       b1 7e		      lda	(CURPTR),y	;compare LSB
    151  0ab7		       c5 83		      cmp	R0
    152  0ab9		       90 02		      bcc	xfer3
    153  0abb							;
    154  0abb							; This line is greater than the one we want, so
    155  0abb							; return Z clear and C set.
    156  0abb							;
    157  0abb		       38	   xfer4      sec		;We found a line number greater
    158  0abc		       60		      rts		;both conditions set
    159  0abd							;
    160  0abd							; Not the line (or droid) we're looking for.  Move to
    161  0abd							; the next line.
    162  0abd							;
    163  0abd		       20 c3 0a    xfer3      jsr	FindNextLine
    164  0ac0		       4c 88 0a 	      jmp	iXFER1
    165  0ac3							;
    166  0ac3							;=====================================================
    167  0ac3							; This advances CURPTR to the next line.  If there
    168  0ac3							; are no more lines, this leaves CURPTR equal to
    169  0ac3							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    170  0ac3							; CURPTR is pointing to a valid line on entry.  This
    171  0ac3							; pointer points to the two-byte line number.
    172  0ac3							; Update this points to the 1 byte line length  ****************
    173  0ac3							;
    174  0ac3				   FindNextLine
    175  0ac3		       a0 03		      ldy	#3	;skip line number and length byte
    176  0ac5		       84 80		      sty	CUROFF	;this is the new offset
    177  0ac7		       a0 00		      ldy	#0
    178  0ac9		       b1 7e		      lda	(CURPTR),y	;Get the length
    179  0acb		       18		      clc
    180  0acc		       65 7e		      adc	CURPTR
    181  0ace		       85 7e		      sta	CURPTR
    182  0ad0		       90 02		      bcc	FindNext4	;exit
    183  0ad2		       e6 7f		      inc	CURPTR+1
    184  0ad4		       60	   FindNext4  rts
    185  0ad5							;
    186  0ad5							;=====================================================
    187  0ad5							; This compares CURPTR to PROGRAMEND and returns Z set
    188  0ad5							; if they are equal, Z clear if not.
    189  0ad5							;
    190  0ad5		       a5 7e	   AtEnd      lda	CURPTR
    191  0ad7		       cd ba 12 	      cmp	PROGRAMEND
    192  0ada		       d0 05		      bne	atendexit
    193  0adc		       a5 7f		      lda	CURPTR+1
    194  0ade		       cd bb 12 	      cmp	PROGRAMEND+1
    195  0ae1		       60	   atendexit  rts
    196  0ae2							;
    197  0ae2							;=====================================================
    198  0ae2							; Print the contents of R0 as a signed decimal number.
    199  0ae2							; Does leading zero suppression.
    200  0ae2							;
    201  0ae2				   PrintDecimal
    202  0ae2		       a5 84		      lda	R0+1	;MSB has sign
    203  0ae4		       10 17		      bpl	pplus	;it's a positive number
    204  0ae6							;
    205  0ae6							; Negative numbers need more work.  Invert all the bits,
    206  0ae6							; then add one.
    207  0ae6							;
    208  0ae6		       a9 2d		      lda	#'-
    209  0ae8		       20 e5 0d 	      jsr	VOUTCH	;print the negative sign
    210  0aeb							;
    211  0aeb		       a5 83		      lda	R0	;invert bits
    212  0aed		       49 ff		      eor	#$ff
    213  0aef		       85 83		      sta	R0
    214  0af1		       a5 84		      lda	R0+1
    215  0af3		       49 ff		      eor	#$ff
    216  0af5		       85 84		      sta	R0+1
    217  0af7		       e6 83		      inc	R0	;add one
    218  0af9		       d0 02		      bne	pplus
    219  0afb		       e6 84		      inc	R0+1
    220  0afd							;
    221  0afd							; Print the value in R0 as a positive number.
    222  0afd							;
    223  0afd		       a2 00	   pplus      ldx	#0	;start of subtraction table
    224  0aff		       8e ad 12 	      stx	diddigit	;no digits yet
    225  0b02		       a0 00	   pploop     ldy	#0	;result of division
    226  0b04		       a5 83	   pploop2    lda	R0	;LSB
    227  0b06		       38		      sec
    228  0b07		       fd 46 0b 	      sbc	dectable,x
    229  0b0a		       85 83		      sta	R0
    230  0b0c		       a5 84		      lda	R0+1
    231  0b0e		       fd 47 0b 	      sbc	dectable+1,x
    232  0b11		       10 2e		      bpl	pplusok	;no underflow
    233  0b13							;
    234  0b13							; Else, underflow.  Add back in the LSB of the
    235  0b13							; table to R0.
    236  0b13							;
    237  0b13		       18		      clc
    238  0b14		       a5 83		      lda	R0
    239  0b16		       7d 46 0b 	      adc	dectable,x
    240  0b19		       85 83		      sta	R0
    241  0b1b							;
    242  0b1b							; Print the value in Y.  Actually, see if Y is zero and
    243  0b1b							; whether any digit has been printed yet.  If Y isn't
    244  0b1b							; zero or we've printed a digit, go ahead and print.
    245  0b1b							;
    246  0b1b		       8e ac 12 	      stx	printtx
    247  0b1e		       98		      tya
    248  0b1f		       09 00		      ora	#0	;set flags
    249  0b21		       d0 05		      bne	pprintit	;non-zero, print
    250  0b23							;
    251  0b23		       ad ad 12 	      lda	diddigit
    252  0b26		       f0 09		      beq	pprintno	;don't print
    253  0b28							;
    254  0b28		       98	   pprintit   tya
    255  0b29		       09 30		      ora	#'0
    256  0b2b		       8d ad 12 	      sta	diddigit
    257  0b2e		       20 e5 0d 	      jsr	VOUTCH
    258  0b31		       ae ac 12    pprintno   ldx	printtx
    259  0b34							;
    260  0b34							; Move to the next table entry
    261  0b34							;
    262  0b34		       e8		      inx
    263  0b35		       e8		      inx
    264  0b36		       e0 08		      cpx	#dectableend-dectable
    265  0b38		       d0 c8		      bne	pploop	;not at end
    266  0b3a							;
    267  0b3a							; At the end.	R0 contains the final value
    268  0b3a							; to print.
    269  0b3a							;
    270  0b3a		       a5 83		      lda	R0
    271  0b3c		       09 30		      ora	#'0
    272  0b3e		       4c e5 0d 	      jmp	VOUTCH
    273  0b41							;
    274  0b41							; Finish doing the subtraction.
    275  0b41							;
    276  0b41		       85 84	   pplusok    sta	R0+1
    277  0b43		       c8		      iny
    278  0b44		       d0 be		      bne	pploop2
    279  0b46							;
    280  0b46							; Table of powers-of-ten
    281  0b46							;
      0  0b46				   dectable   dw	10000
      1  0b46		       10 27		      .word.w	10000
      0  0b48					      dw	1000
      1  0b48		       e8 03		      .word.w	1000
      0  0b4a					      dw	100
      1  0b4a		       64 00		      .word.w	100
      0  0b4c					      dw	10
      1  0b4c		       0a 00		      .word.w	10
    286  0b4c		       0b 4e	   dectableend equ	*
    287  0b4e							;
    288  0b4e							;=====================================================
    289  0b4e							; Convert an ASCII string to a number.  On input,
    290  0b4e							; (CURPTR),Y points to the first digit.  This gets
    291  0b4e							; digit-by-digit until finding a non-number.  Returns
    292  0b4e							; Y pointing to the non-digit, and R0 contains the
    293  0b4e							; number.  This does NOT check for valid ranges, so
    294  0b4e							; a value like "123456789" will produce something,
    295  0b4e							; but not what you had expected.
    296  0b4e							;
    297  0b4e		       a9 00	   getDecimal lda	#0
    298  0b50		       85 83		      sta	R0
    299  0b52		       85 84		      sta	R0+1
    300  0b54		       85 77		      sta	dpl	;temporary negative flag
    301  0b56							;
    302  0b56							; See if it's negative...
    303  0b56							;
    304  0b56		       84 13		      sty	$0013
    305  0b58		       b1 7e		      lda	(CURPTR),y
    306  0b5a		       c9 2d		      cmp	#'-
    307  0b5c		       d0 02		      bne	getDecLoop
    308  0b5e		       e6 77		      inc	dpl	;it's negative
    309  0b60							;
    310  0b60		       b1 7e	   getDecLoop lda	(CURPTR),y
    311  0b62		       c9 30		      cmp	#'0
    312  0b64		       90 36		      bcc	getDdone
    313  0b66		       c9 3a		      cmp	#'9+1
    314  0b68		       b0 32		      bcs	getDdone
    315  0b6a		       38		      sec
    316  0b6b		       e9 30		      sbc	#'0	;convert to binary
    317  0b6d		       48		      pha
    318  0b6e							;
    319  0b6e							; Now multiply R0 by 10.  Remember that
    320  0b6e							; 2*N + 8*N = 10*N.
    321  0b6e							;
    322  0b6e		       06 83		      asl	R0
    323  0b70		       26 84		      rol	R0+1	;*2
    324  0b72		       a5 83		      lda	R0
    325  0b74		       85 85		      sta	R1
    326  0b76		       a5 84		      lda	R0+1
    327  0b78		       85 86		      sta	R1+1
    328  0b7a		       06 83		      asl	R0
    329  0b7c		       26 84		      rol	R0+1	;*4
    330  0b7e		       06 83		      asl	R0
    331  0b80		       26 84		      rol	R0+1	;*8
    332  0b82		       18		      clc		;now add the partial sums...
    333  0b83		       a5 83		      lda	R0	;...to get *10
    334  0b85		       65 85		      adc	R1
    335  0b87		       85 83		      sta	R0
    336  0b89		       a5 84		      lda	R0+1
    337  0b8b		       65 86		      adc	R1+1
    338  0b8d		       85 84		      sta	R0+1
    339  0b8f							;
    340  0b8f							; Add in the new digit
    341  0b8f							;
    342  0b8f		       68		      pla
    343  0b90		       18		      clc
    344  0b91		       65 83		      adc	R0
    345  0b93		       85 83		      sta	R0
    346  0b95		       90 02		      bcc	getD2
    347  0b97		       e6 84		      inc	R0+1
    348  0b99							;
    349  0b99							; Move to next character
    350  0b99							;
    351  0b99		       c8	   getD2      iny
    352  0b9a		       d0 c4		      bne	getDecLoop
    353  0b9c							;
    354  0b9c							; All done with digits, so now deal with it being
    355  0b9c							; negative.  If zero, then don't check for negative
    356  0b9c							; flag.  Ie, -0 is stored as 0.
    357  0b9c							;
    358  0b9c		       a5 83	   getDdone   lda	R0
    359  0b9e		       05 84		      ora	R0+1
    360  0ba0		       f0 16		      beq	getDone2	;zero
    361  0ba2		       a5 77		      lda	dpl
    362  0ba4		       f0 12		      beq	getDone2	;positive
    363  0ba6							;
    364  0ba6							; Invert all the bits, then add one.
    365  0ba6							;
    366  0ba6		       a5 83		      lda	R0
    367  0ba8		       49 ff		      eor	#$ff
    368  0baa		       85 83		      sta	R0
    369  0bac		       a5 84		      lda	R0+1
    370  0bae		       49 ff		      eor	#$ff
    371  0bb0		       85 84		      sta	R0+1
    372  0bb2							;
    373  0bb2		       e6 83		      inc	R0
    374  0bb4		       d0 02		      bne	getDone2
    375  0bb6		       e6 84		      inc	R0+1
    376  0bb8				   getDone2
    377  0bb8		       a5 83		      lda	R0
    378  0bba		       85 10		      sta	$0010
    379  0bbc		       a5 84		      lda	R0+1
    380  0bbe		       85 11		      sta	$0011
    381  0bc0		       a5 77		      lda	dpl
    382  0bc2		       85 12		      sta	$012
    383  0bc4
    384  0bc4		       60		      rts
    385  0bc5							;
    386  0bc5							;=====================================================
    387  0bc5							; Print the string that immediately follows the JSR to
    388  0bc5							; this function.  Stops when a null byte is found,
    389  0bc5							; then returns to the instruction immediately
    390  0bc5							; following the null.
    391  0bc5							;
    392  0bc5							; Thanks to Ross Archer for this code.
    393  0bc5							; http://www.6502.org/source/io/primm.htm
    394  0bc5							;
    395  0bc5				  -	      if	KIM
    396  0bc5				  -puts       sty	putsy
    397  0bc5				  -	      pla		;low part of "return" address
    398  0bc5				  -			;(data start address)
    399  0bc5				  -	      sta	dpl
    400  0bc5				  -	      pla
    401  0bc5				  -	      sta	dpl+1	;high part of "return" address
    402  0bc5				  -			;(data start address)
    403  0bc5				  -			;Note: we're pointing one short
    404  0bc5				  -psinb      ldy	#1
    405  0bc5				  -	      lda	(dpl),y	;Get next string character
    406  0bc5				  -	      inc	dpl	;update the pointer
    407  0bc5				  -	      bne	psinc	;if not, we're pntng to next char
    408  0bc5				  -	      inc	dpl+1	;account for page crossing
    409  0bc5				  -psinc      ora	#0	;Set flags according to contents of
    410  0bc5				  -			;   Accumulator
    411  0bc5				  -	      beq	psix1	;don't print the final NULL
    412  0bc5				  -	      jsr	OUTCH	;write it out
    413  0bc5				  -	      jmp	psinb	;back around
    414  0bc5				  -psix1      inc	dpl
    415  0bc5				  -	      bne	psix2
    416  0bc5				  -	      inc	dpl+1	;account for page crossing
    417  0bc5				  -psix2      ldy	putsy
    418  0bc5				  -	      jmp	(dpl)	;return to byte following NULL
    419  0bc5					      endif
    420  0bc5							;
    421  0bc5							;=====================================================
    422  0bc5							; Gets a line of input into LINBUF.
    423  0bc5							;
    424  0bc5							; On entry:
    425  0bc5							;    A contains the prompt character, or 0 if none.
    426  0bc5							;
    427  0bc5							; On exit:
    428  0bc5							;    CURPTR points to LINBUF
    429  0bc5							;    LINBUF contains the line with 0 at the end.
    430  0bc5							;    Y has offset to first non-space character
    431  0bc5							;    CURROFF has the same as Y.
    432  0bc5							;
    433  0bc5		       a2 27	   GetLine    ldx	#LINBUF&$ff
    434  0bc7		       86 7e		      stx	CURPTR
    435  0bc9		       a2 12		      ldx	#LINBUF>>8
    436  0bcb		       86 7f		      stx	CURPTR+1
    437  0bcd							;
    438  0bcd							; Prompt
    439  0bcd							;
    440  0bcd		       48		      pha		;save for retries
    441  0bce		       68	   GetLinePr  pla		;restore
    442  0bcf		       48		      pha		;save again
    443  0bd0		       09 00		      ora	#0	;any prompt?
    444  0bd2		       f0 08		      beq	getlinenp
    445  0bd4		       20 06 02 	      jsr	OUTCH
    446  0bd7		       a9 20		      lda	#$20
    447  0bd9		       20 06 02 	      jsr	OUTCH	;space after prompt
    448  0bdc							;
    449  0bdc		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    450  0bde		       8e ab 12    getline1   stx	getlinx
    451  0be1		       20 09 02 	      jsr	GETCH
    452  0be4					      if	CTMON65
    453  0be4		       48		      pha
    454  0be5		       20 0c f0 	      jsr	cout	;echo echo echo
    455  0be8		       68		      pla
    456  0be9					      endif
    457  0be9		       c9 0d		      cmp	#CR
    458  0beb		       f0 0d		      beq	getlind	;end of line
    459  0bed		       c9 08		      cmp	#BS	;backspace?
    460  0bef		       f0 21		      beq	getlinebs
    461  0bf1		       ae ab 12 	      ldx	getlinx
    462  0bf4		       9d 27 12 	      sta	LINBUF,x
    463  0bf7		       e8		      inx
    464  0bf8		       d0 e4		      bne	getline1
    465  0bfa							;
    466  0bfa							; CR was hit
    467  0bfa							;
    468  0bfa		       a9 00	   getlind    lda	#0
    469  0bfc		       ae ab 12 	      ldx	getlinx
    470  0bff		       9d 27 12 	      sta	LINBUF,x
    471  0c02		       85 80		      sta	CUROFF
    472  0c04							;
    473  0c04							; Output a CR/LF
    474  0c04							;
    475  0c04		       20 0c 02 	      jsr	CRLF
    476  0c07							;
    477  0c07							; If a blank line, prompt again.
    478  0c07							;
    479  0c07		       a0 00		      ldy	#0
    480  0c09		       20 59 0d 	      jsr	SkipSpaces
    481  0c0c		       b1 7e		      lda	(CURPTR),y
    482  0c0e		       f0 be		      beq	GetLinePr	;empty line
    483  0c10		       68		      pla		;get rid of prompt char
    484  0c11		       60		      rts
    485  0c12							;
    486  0c12							; Backspace was hit
    487  0c12							;
    488  0c12		       ae ab 12    getlinebs  ldx	getlinx
    489  0c15		       f0 c7		      beq	getline1	;at start of line
    490  0c17		       ca		      dex
    491  0c18		       20 12 f0 	      jsr	puts
      0  0c1b					      db	27,"[K",0
      1  0c1b		       1b 5b 4b 00	      .byte.b	27,"[K",0
    493  0c1f		       4c de 0b 	      jmp	getline1
    494  0c22							;
    495  0c22							;=====================================================
    496  0c22							; Count the length of the line currently in LINBUF
    497  0c22							; starting at offset Y.  Returns the length in X.  The
    498  0c22							; starting offset in Y should point past the ASCII
    499  0c22							; line number.  Also counts the trailing NULL and two
    500  0c22							; extra bytes for where the line number will be.
    501  0c22							; Update must now include leading length byte not the null at end ****************
    502  0c22							;
    503  0c22				   getLineLength
    504  0c22		       a2 00		      ldx	#0	;size
    505  0c24		       b9 27 12    getLineL2  lda	LINBUF,y
    506  0c27		       f0 04		      beq	getLineL3
    507  0c29		       c8		      iny
    508  0c2a		       e8		      inx
    509  0c2b		       d0 f7		      bne	getLineL2
    510  0c2d		       e8	   getLineL3  inx		;count null at end
    511  0c2e		       e8		      inx		;line number LSB
    512  0c2f		       e8		      inx		;MSB
    513  0c30		       e8		      inx		;change: count new leading line length
    514  0c31		       86 7d		      stx	lineLength
    515  0c33		       60		      rts
    516  0c34							;
    517  0c34							;=====================================================
    518  0c34							; Count the length of the line pointed to by CURPTR.
    519  0c34							; This also counts the line number and the terminating
    520  0c34							; null.  Ie, this string returns 8:
    521  0c34							;
    522  0c34							; <lineLow><lineHi>Hello<null>
    523  0c34							;
    524  0c34							; Another way of looking at it: add the return value
    525  0c34							; to the CURPTR and it'll point to the next line's
    526  0c34							; line number.  Returns the value in Y.
    527  0c34							; Update to ject get the leading byte length ********************
    528  0c34							;
    529  0c34							;getCURPTRLength
    530  0c34							;		ldy	CURPTR
    531  0c34							;		ldy	#3	;change: skip line number and leading length byte
    532  0c34							;getCLineL2	lda	(CURPTR),y
    533  0c34							;		beq	getCLineL3
    534  0c34							;		iny
    535  0c34							;		bne	getCLineL2
    536  0c34							;getCLineL3	iny		;count null at end
    537  0c34							;		rts
    538  0c34							;
    539  0c34							;=====================================================
    540  0c34							; This saves ILPC.  This saves to a single save area,
    541  0c34							; so it can't be called more than once.
    542  0c34							;
    543  0c34		       a5 75	   saveIL     lda	ILPC
    544  0c36		       85 79		      sta	tempIL
    545  0c38		       a5 76		      lda	ILPC+1
    546  0c3a		       85 7a		      sta	tempIL+1
    547  0c3c		       60		      rts
    548  0c3d							;
    549  0c3d							;=====================================================
    550  0c3d							; This restores ILPC.
    551  0c3d							;
    552  0c3d		       a5 79	   restoreIL  lda	tempIL
    553  0c3f		       85 75		      sta	ILPC
    554  0c41		       a5 7a		      lda	tempIL+1
    555  0c43		       85 76		      sta	ILPC+1
    556  0c45		       60		      rts
    557  0c46							;
    558  0c46							;=====================================================
    559  0c46							; This pushes R0 onto the stack.
    560  0c46							;
    561  0c46		       ae 14 12    pushR0     ldx	mathStackPtr
    562  0c49		       a5 83		      lda	R0
    563  0c4b		       9d 04 12 	      sta	mathStack,x
    564  0c4e		       e8		      inx
    565  0c4f		       a5 84		      lda	R0+1
    566  0c51		       9d 04 12 	      sta	mathStack,x
    567  0c54		       e8		      inx
    568  0c55		       8e 14 12 	      stx	mathStackPtr
    569  0c58		       60		      rts
    570  0c59
    571  0c59							;=====================================================
    572  0c59							; This pushes curptr basic current line onto the call stack.
    573  0c59
    574  0c59				   pushLN
    575  0c59		       8c b4 12 	      sty	rtemp1
    576  0c5c		       ac 26 12 	      ldy	GoSubStackPtr
    577  0c5f		       98		      tya
    578  0c60		       c9 3c		      cmp	#GOSUBSTACKSIZE*3
    579  0c62		       f0 17		      beq	pusherr
    580  0c64		       a5 7e		      lda	CURPTR
    581  0c66		       91 81		      sta	(GOSUBSTACK),y
    582  0c68		       c8		      iny
    583  0c69		       a5 7f		      lda	CURPTR+1
    584  0c6b		       91 81		      sta	(GOSUBSTACK),y
    585  0c6d		       c8		      iny
    586  0c6e		       a5 80		      lda	CUROFF
    587  0c70		       91 81		      sta	(GOSUBSTACK),y
    588  0c72		       c8		      iny
    589  0c73		       8c 26 12 	      sty	GoSubStackPtr
    590  0c76		       ac b4 12 	      ldy	rtemp1
    591  0c79		       18		      clc
    592  0c7a		       60		      rts
    593  0c7b
    594  0c7b				   pusherr
    595  0c7b		       38		      sec
    596  0c7c		       60		      rts
    597  0c7d							;
    598  0c7d							;=====================================================
    599  0c7d							; This pushes R1 onto the stack
    600  0c7d							;
    601  0c7d		       ae 14 12    pushR1     ldx	mathStackPtr
    602  0c80		       a5 85		      lda	R1
    603  0c82		       9d 04 12 	      sta	mathStack,x
    604  0c85		       e8		      inx
    605  0c86		       a5 86		      lda	R1+1
    606  0c88		       9d 04 12 	      sta	mathStack,x
    607  0c8b		       e8		      inx
    608  0c8c		       8e 14 12 	      stx	mathStackPtr
    609  0c8f		       60		      rts
    610  0c90							;
    611  0c90							;=====================================================
    612  0c90							; This pops Top Of Stack and places it in R0.
    613  0c90							;
    614  0c90		       ae 14 12    popR0      ldx	mathStackPtr
    615  0c93		       ca		      dex
    616  0c94		       bd 04 12 	      lda	mathStack,x
    617  0c97		       85 84		      sta	R0+1
    618  0c99		       ca		      dex
    619  0c9a		       bd 04 12 	      lda	mathStack,x
    620  0c9d		       85 83		      sta	R0
    621  0c9f		       8e 14 12 	      stx	mathStackPtr
    622  0ca2		       60		      rts
    623  0ca3							;=====================================================
    624  0ca3							; This pops Top Of gosub call Stack and
    625  0ca3							; laces it in CURPTR.
    626  0ca3							;
    627  0ca3		       8c b4 12    popLN      sty	rtemp1
    628  0ca6		       ac 26 12 	      ldy	GoSubStackPtr
    629  0ca9		       88		      dey
    630  0caa		       98		      tya
    631  0cab		       c9 ff		      cmp	#$FF
    632  0cad		       f0 16		      beq	poperr
    633  0caf		       b1 81		      lda	(GOSUBSTACK),y
    634  0cb1		       85 80		      sta	CUROFF
    635  0cb3		       88		      dey
    636  0cb4		       b1 81		      lda	(GOSUBSTACK),y
    637  0cb6		       85 7f		      sta	CURPTR+1
    638  0cb8		       88		      dey
    639  0cb9		       b1 81		      lda	(GOSUBSTACK),y
    640  0cbb		       85 7e		      sta	CURPTR
    641  0cbd		       8c 26 12 	      sty	GoSubStackPtr
    642  0cc0		       ac b4 12 	      ldy	rtemp1
    643  0cc3		       18		      clc
    644  0cc4		       60		      rts
    645  0cc5		       38	   poperr     sec
      0  0cc6					      rtn
      0  0cc6					      db	25
      1  0cc6		       19		      .byte.b	25
    647  0cc7							;
    648  0cc7							;=====================================================
    649  0cc7							; This pops TOS and places it in R1.
    650  0cc7							;
    651  0cc7		       ae 14 12    popR1      ldx	mathStackPtr
    652  0cca		       ca		      dex
    653  0ccb		       bd 04 12 	      lda	mathStack,x
    654  0cce		       85 86		      sta	R1+1
    655  0cd0		       ca		      dex
    656  0cd1		       bd 04 12 	      lda	mathStack,x
    657  0cd4		       85 85		      sta	R1
    658  0cd6		       8e 14 12 	      stx	mathStackPtr
    659  0cd9		       60		      rts
    660  0cda							;
    661  0cda							;=====================================================
    662  0cda							; This pops TOS and places it in MQ.
    663  0cda							;
    664  0cda		       ae 14 12    popMQ      ldx	mathStackPtr
    665  0cdd		       ca		      dex
    666  0cde		       bd 04 12 	      lda	mathStack,x
    667  0ce1		       8d b2 12 	      sta	MQ+1
    668  0ce4		       ca		      dex
    669  0ce5		       bd 04 12 	      lda	mathStack,x
    670  0ce8		       8d b1 12 	      sta	MQ
    671  0ceb		       8e 14 12 	      stx	mathStackPtr
    672  0cee		       60		      rts
    673  0cef							;
    674  0cef							;=====================================================
    675  0cef							; This assists with multiplication and division by
    676  0cef							; looking at R0 and R1 and saving a flag as to what
    677  0cef							; sign the result will be.  Math is always done on
    678  0cef							; positive numbers, so this converts negative numbers
    679  0cef							; into positives.  On exit, R0 and R1 are both
    680  0cef							; positive.  If the signs were different then 'signs'
    681  0cef							; will be non-zero.
    682  0cef							;
    683  0cef		       a9 00	   SaveSigns  lda	#0
    684  0cf1		       8d b3 12 	      sta	sign	;assume positive
    685  0cf4		       a5 84		      lda	R0+1	;MSB
    686  0cf6		       10 13		      bpl	SaveSigns1
    687  0cf8		       ee b3 12 	      inc	sign	;it's negative
    688  0cfb		       49 ff		      eor	#$ff	;flip bits
    689  0cfd		       85 84		      sta	R0+1
    690  0cff		       a5 83		      lda	R0
    691  0d01		       49 ff		      eor	#$ff
    692  0d03		       85 83		      sta	R0
    693  0d05		       e6 83		      inc	R0
    694  0d07		       d0 02		      bne	SaveSigns1
    695  0d09		       e6 84		      inc	R0+1
    696  0d0b		       a5 86	   SaveSigns1 lda	R1+1
    697  0d0d		       10 1a		      bpl	SaveSigns2
    698  0d0f		       48		      pha
    699  0d10		       ad b3 12 	      lda	sign
    700  0d13		       49 01		      eor	#1
    701  0d15		       8d b3 12 	      sta	sign
    702  0d18		       68		      pla
    703  0d19		       49 ff		      eor	#$ff	;flip bits
    704  0d1b		       85 86		      sta	R1+1
    705  0d1d		       a5 85		      lda	R1
    706  0d1f		       49 ff		      eor	#$ff
    707  0d21		       85 85		      sta	R1
    708  0d23		       e6 85		      inc	R1
    709  0d25		       d0 02		      bne	SaveSigns2
    710  0d27		       e6 86		      inc	R1+1
    711  0d29		       60	   SaveSigns2 rts
    712  0d2a							;
    713  0d2a							;=====================================================
    714  0d2a							; This looks at the value of 'signs' and will convert
    715  0d2a							; both R0 and R1 to negative if set.
    716  0d2a							;
    717  0d2a				   RestoreSigns
    718  0d2a		       ad b3 12 	      lda	sign
    719  0d2d		       f0 28		      beq	restoresigns2
    720  0d2f							;
    721  0d2f		       a5 83		      lda	R0
    722  0d31		       d0 02		      bne	restoresigns3
    723  0d33		       c6 84		      dec	R0+1
    724  0d35				   restoresigns3
    725  0d35		       c6 83		      dec	R0
    726  0d37		       a5 83		      lda	R0
    727  0d39		       49 ff		      eor	#$ff
    728  0d3b		       85 83		      sta	R0
    729  0d3d		       a5 84		      lda	R0+1
    730  0d3f		       49 ff		      eor	#$ff
    731  0d41		       85 84		      sta	R0+1
    732  0d43							;
    733  0d43		       a5 85		      lda	R1
    734  0d45		       d0 02		      bne	restoresigns4
    735  0d47		       c6 86		      dec	R1+1
    736  0d49				   restoresigns4
    737  0d49		       c6 85		      dec	R1
    738  0d4b		       a5 85		      lda	R1
    739  0d4d		       49 ff		      eor	#$ff
    740  0d4f		       85 85		      sta	R1
    741  0d51		       a5 86		      lda	R1+1
    742  0d53		       49 ff		      eor	#$ff
    743  0d55		       85 86		      sta	R1+1
    744  0d57							;
    745  0d57				   restoresigns2
    746  0d57		       60		      rts
    747  0d58							;
    748  0d58							;=====================================================
    749  0d58							; Skip over spaces.  Returns Y with the offset to
    750  0d58							; either the last character in the line, or the first
    751  0d58							; non-space character.
    752  0d58							;
    753  0d58		       c8	   skipsp2    iny
    754  0d59		       b1 7e	   SkipSpaces lda	(CURPTR),y
    755  0d5b		       f0 04		      beq	Skip3	;end of line
    756  0d5d		       c9 20		      cmp	#SPACE
    757  0d5f		       f0 f7		      beq	skipsp2
    758  0d61		       60	   Skip3      rts
    759  0d62							;
    760  0d62							;=====================================================
    761  0d62							; This is some debug logic which displays the current
    762  0d62							; value of the ILPC and the line buffer.
    763  0d62							;
    764  0d62		       20 12 f0    dbgLine    jsr	puts
      0  0d65					      db	"ILPC: ",0
      1  0d65		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    766  0d6c		       a5 76		      lda	ILPC+1
    767  0d6e		       20 0f 02 	      jsr	OUTHEX
    768  0d71		       a5 75		      lda	ILPC
    769  0d73		       20 0f 02 	      jsr	OUTHEX
    770  0d76		       a9 20		      lda	#SPACE
    771  0d78		       20 06 02 	      jsr	OUTCH
    772  0d7b		       a0 00		      ldy	#0
    773  0d7d		       b1 75		      lda	(ILPC),y
    774  0d7f		       20 0f 02 	      jsr	OUTHEX
    775  0d82							;
    776  0d82							; Display the CURPTR value and offset
    777  0d82							;
    778  0d82		       20 12 f0 	      jsr	puts
      0  0d85					      db	", CURPTR: ",0
      1  0d85		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    780  0d90		       a5 7f		      lda	CURPTR+1
    781  0d92		       20 0f 02 	      jsr	OUTHEX
    782  0d95		       a5 7e		      lda	CURPTR
    783  0d97		       20 0f 02 	      jsr	OUTHEX
    784  0d9a		       a9 2b		      lda	#'+
    785  0d9c		       20 06 02 	      jsr	OUTCH
    786  0d9f		       a5 80		      lda	CUROFF
    787  0da1		       20 0f 02 	      jsr	OUTHEX
    788  0da4							;
    789  0da4		       4c 0c 02 	      jmp	CRLF
    790  0da7							;
    791  0da7							;=====================================================
    792  0da7							; This function might go away eventually, but was
    793  0da7							; added to provide data for other pieces of code.
    794  0da7							; It has some ties to the operating environment that
    795  0da7							; will need to be customized for the target system.
    796  0da7							;
    797  0da7				   GetSizes
    798  0da7							;
    799  0da7							; Here is machine specific code to get the highest
    800  0da7							; memory location that can be used by BASIC.
    801  0da7							;
    802  0da7					      if	ProgramStart < $2000
    803  0da7		       a9 ff		      lda	#$ff
    804  0da9		       8d bc 12 	      sta	HighMem	;$13ff for KIM-1
    805  0dac		       a9 de		      lda	#$DE	;#$13
    806  0dae		       8d bd 12 	      sta	HighMem+1
    807  0db1				  -	      else
    808  0db1				  -	      lda	#$ff
    809  0db1				  -	      sta	HighMem	;$CFFF otherwise
    810  0db1				  -	      lda	#$cf
    811  0db1				  -	      sta	HighMem+1
    812  0db1					      endif
    813  0db1							;
    814  0db1							; This computes the available memory remaining.
    815  0db1							;
    816  0db1		       38		      sec
    817  0db2		       ad bc 12 	      lda	HighMem
    818  0db5		       ed ba 12 	      sbc	PROGRAMEND
    819  0db8		       8d c0 12 	      sta	FreeMem
    820  0dbb		       85 83		      sta	R0
    821  0dbd		       ad bd 12 	      lda	HighMem+1
    822  0dc0		       ed bb 12 	      sbc	PROGRAMEND+1
    823  0dc3		       8d c1 12 	      sta	FreeMem+1
    824  0dc6		       85 84		      sta	R0+1
    825  0dc8							;
    826  0dc8							; This computes the size of the current user program.
    827  0dc8							;
    828  0dc8		       38		      sec
    829  0dc9		       ad ba 12 	      lda	PROGRAMEND
    830  0dcc		       e9 c2		      sbc	#ProgramStart&$ff
    831  0dce		       8d be 12 	      sta	UsedMem
    832  0dd1		       ad bb 12 	      lda	PROGRAMEND+1
    833  0dd4		       e9 12		      sbc	#ProgramStart>>8
    834  0dd6		       8d bf 12 	      sta	UsedMem+1
    835  0dd9							;
    836  0dd9		       60		      rts
    837  0dda							;
    838  0dda							;=====================================================
    839  0dda							; Set output vector to the console output function
    840  0dda							;
    841  0dda				   SetOutConsole
    842  0dda		       a9 06		      lda	#OUTCH&$ff
    843  0ddc		       8d b7 12 	      sta	BOutVec
    844  0ddf		       a9 02		      lda	#OUTCH/256
    845  0de1		       8d b8 12 	      sta	BOutVec+1
    846  0de4		       60		      rts
    847  0de5							;
    848  0de5							;=====================================================
    849  0de5							; Jump to the output function in BOutVec
    850  0de5							;
    851  0de5		       6c b7 12    VOUTCH     jmp	(BOutVec)
    852  0de8
    853  0de8							;====================================================
    854  0de8		       12 b4	   PrtTerm    equ	rtemp1
    855  0de8
    856  0de8							; Print Y has the offset to use
    857  0de8		       a5 7e	   PrtQuoted  lda	CURPTR
    858  0dea		       85 88		      sta	PrtFrom
    859  0dec		       a5 7f		      lda	CURPTR+1
    860  0dee		       85 89		      sta	PrtFrom+1
    861  0df0		       a9 22		      lda	#'"
    862  0df2		       8d b4 12 	      sta	PrtTerm
    863  0df5		       4c 01 0e 	      jmp	PrtLoop
    864  0df8							; Print a string pointed to by x= h, y=l terminated by a
    865  0df8							; Return y as the length
    866  0df8		       86 89	   PrtStr     stx	PrtFrom+1
    867  0dfa		       84 88		      sty	PrtFrom
    868  0dfc		       8d b4 12 	      sta	PrtTerm
    869  0dff		       a0 00		      ldy	#0
    870  0e01
    871  0e01		       b1 88	   PrtLoop    lda	(PrtFrom),y
    872  0e03		       cd b4 12 	      cmp	PrtTerm
    873  0e06		       f0 0b		      beq	PrtEnd
    874  0e08		       c9 00		      cmp	#0	; always end if 0 is found
    875  0e0a		       f0 07		      beq	PrtEnd
    876  0e0c		       20 06 02 	      jsr	OUTCH
    877  0e0f		       c8		      iny
    878  0e10		       4c 01 0e 	      jmp	PrtLoop
    879  0e13		       c8	   PrtEnd     iny		;return byte after the copy
    880  0e14		       60		      rts
    881  0e15
    882  0e15							;====================================================
    883  0e15							;Clear the terminal assume it is ansii or vt100
    884  0e15							;
    885  0e15				   iCLEARSCREEN
    886  0e15		       20 12 f0 	      jsr	puts
      0  0e18					      db	$1b,'[,'3,'J,0
      1  0e18		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    888  0e1d		       4c eb 02 	      jmp	NextIL
------- FILE mytb.asm
   1717  0e20					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  0e20					      include	"storage.asm"
      1  0e20							;
      2  0e20							;=====================================================
      3  0e20							;=====================================================
      4  0e20							;=====================================================
      5  0e20							; This file contains the functions for saving and
      6  0e20							; restoring programs from some sort of mass storage
      7  0e20							; device.  This particular version is for using the
      8  0e20							; Corsham Tech SD Card System.
      9  0e20							;=====================================================
     10  0e20							;=====================================================
     11  0e20							;=====================================================
     12  0e20
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  0e20					      SEG	Code
     19  0e20
     20  0e20							;
     21  0e20							;=====================================================
     22  0e20							; Open a file for reading as a program.  The next
     23  0e20							; thing on the line should be the filename.
     24  0e20							;
     25  0e20				   iOPENREAD
     26  0e20					      if	XKIM || CTMON65
     27  0e20		       a4 80		      ldy	CUROFF
     28  0e22		       b1 7e		      lda	(CURPTR),y
     29  0e24		       d0 07		      bne	iOPENfn	;might be filename
     30  0e26							;
     31  0e26							; No filename supplied.
     32  0e26							;
     33  0e26		       a9 00	   iOPENnofn  lda	#0
     34  0e28		       a2 09		      ldx	#ERR_NO_FILENAME
     35  0e2a		       4c 21 05 	      jmp	iErr2
     36  0e2d							;
     37  0e2d							; Add the offset into the buffer start
     38  0e2d							;
     39  0e2d		       18	   iOPENfn    clc
     40  0e2e		       98		      tya
     41  0e2f		       65 7e		      adc	CURPTR
     42  0e31		       a8		      tay		;LSB
     43  0e32		       a5 7f		      lda	CURPTR+1
     44  0e34		       69 00		      adc	#0
     45  0e36		       aa		      tax
     46  0e37		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  0e3a		       90 07		      bcc	Ropenok	;branch if opened ok
     48  0e3c							;
     49  0e3c							; Open failed
     50  0e3c							;
     51  0e3c		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  0e3e		       a9 00	   Rdfail2    lda	#0
     53  0e40		       4c 21 05 	      jmp	iErr2
     54  0e43							;
     55  0e43							; Clear counts and offsets so the next read will
     56  0e43							; cause the file to be read.
     57  0e43							;
     58  0e43		       a9 00	   Ropenok    lda	#0
     59  0e45		       8d 8f df 	      sta	diskBufOffset
     60  0e48		       8d 8e df 	      sta	diskBufLength
     61  0e4b		       4c eb 02 	      jmp	NextIL
     62  0e4e					      endif
     63  0e4e
     64  0e4e							;
     65  0e4e							;==============================jlit 08/02/2022========
     66  0e4e							;Remove a file from the disk
     67  0e4e				   iRMFILE
     68  0e4e					      if	XKIM || CTMON65
     69  0e4e		       a4 80		      ldy	CUROFF
     70  0e50		       b1 7e		      lda	(CURPTR),y
     71  0e52		       f0 19		      beq	iRMnofn
     72  0e54							;
     73  0e54		       18		      clc
     74  0e55		       98		      tya
     75  0e56		       65 7e		      adc	CURPTR
     76  0e58		       a8		      tay		;LSB
     77  0e59		       a5 7f		      lda	CURPTR+1
     78  0e5b		       69 00		      adc	#0
     79  0e5d		       aa		      tax
     80  0e5e		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  0e61		       90 07		      bcc	wrmOk	;branch if removed ok
     82  0e63		       a9 00		      lda	#0
     83  0e65		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  0e67		       4c 21 05 	      jmp	iErr2
     85  0e6a		       4c eb 02    wrmOk      jmp	NextIL
     86  0e6d
     87  0e6d							; No filename supplied.
     88  0e6d							;
     89  0e6d		       a9 00	   iRMnofn    lda	#0
     90  0e6f		       a2 09		      ldx	#ERR_NO_FILENAME
     91  0e71		       4c 21 05 	      jmp	iErr2
     92  0e74					      endif
     93  0e74							;
     94  0e74							;=====================================================
     95  0e74				   iOPENWRITE
     96  0e74					      if	XKIM || CTMON65
     97  0e74		       a4 80		      ldy	CUROFF
     98  0e76		       b1 7e		      lda	(CURPTR),y
     99  0e78		       f0 f3		      beq	iRMnofn
    100  0e7a							;
    101  0e7a		       18		      clc
    102  0e7b		       98		      tya
    103  0e7c		       65 7e		      adc	CURPTR
    104  0e7e		       a8		      tay		;LSB
    105  0e7f		       a5 7f		      lda	CURPTR+1
    106  0e81		       69 00		      adc	#0
    107  0e83		       aa		      tax
    108  0e84		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  0e87		       90 07		      bcc	Wopenok	;branch if opened ok
    110  0e89							;
    111  0e89							; Open failed
    112  0e89							;
    113  0e89		       a9 00	   Wdfail     lda	#0
    114  0e8b		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  0e8d		       4c 21 05 	      jmp	iErr2
    116  0e90							;
    117  0e90		       4c eb 02    Wopenok    jmp	NextIL
    118  0e93					      endif
    119  0e93							;
    120  0e93							;=====================================================
    121  0e93							; Gets a line of input from the disk file and puts it
    122  0e93							; into LINBUF.
    123  0e93							;
    124  0e93							; On exit:
    125  0e93							;    CURPTR points to LINBUF
    126  0e93							;    LINBUF contains the line with 0 at the end.
    127  0e93							;    Y has offset to first non-space character
    128  0e93							;    CURROFF has the same as Y.
    129  0e93							;
    130  0e93				   iDGETLINE
    131  0e93					      if	XKIM || CTMON65
    132  0e93		       a2 27		      ldx	#LINBUF&$ff
    133  0e95		       86 7e		      stx	CURPTR
    134  0e97		       a2 12		      ldx	#LINBUF>>8
    135  0e99		       86 7f		      stx	CURPTR+1
    136  0e9b							;
    137  0e9b		       a2 00		      ldx	#0	;offset
    138  0e9d		       8e ab 12    iDgetLoop  stx	getlinx
    139  0ea0		       20 fe 0e 	      jsr	getNextFileByte
    140  0ea3		       b0 16		      bcs	iGetEOF
    141  0ea5		       c9 0d		      cmp	#CR
    142  0ea7		       f0 0d		      beq	iGetEOL
    143  0ea9		       c9 0a		      cmp	#LF
    144  0eab		       f0 09		      beq	iGetEOL
    145  0ead		       ae ab 12 	      ldx	getlinx
    146  0eb0		       9d 27 12 	      sta	LINBUF,x
    147  0eb3		       e8		      inx
    148  0eb4		       d0 e7		      bne	iDgetLoop
    149  0eb6							;
    150  0eb6							; Handle end of line.	If the line has nothing, loop
    151  0eb6							; back and get another line.
    152  0eb6							;
    153  0eb6		       ae ab 12    iGetEOL    ldx	getlinx	;blank line?
    154  0eb9		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  0ebb							;
    156  0ebb							; This can fall through when there is a line, or
    157  0ebb							; called directly when EOF is encountered.
    158  0ebb							;
    159  0ebb		       ae ab 12    iGetEOF    ldx	getlinx
    160  0ebe		       a9 00		      lda	#0
    161  0ec0		       9d 27 12 	      sta	LINBUF,x
    162  0ec3		       85 80		      sta	CUROFF
    163  0ec5		       a0 00		      ldy	#0
    164  0ec7		       20 59 0d 	      jsr	SkipSpaces
    165  0eca		       4c eb 02 	      jmp	NextIL
    166  0ecd					      endif
    167  0ecd
    168  0ecd							;
    169  0ecd							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  0ecd							; DISK
    171  0ecd							;
    172  0ecd				   iDDIR
    173  0ecd					      if	XKIM || CTMON65
    174  0ecd		       20 30 f0 	      jsr	DiskDir
    175  0ed0							;
    176  0ed0							; Get/Display each entry
    177  0ed0							;
    178  0ed0		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  0ed2		       a0 90		      ldy	#DiskFileName&$ff
    180  0ed4		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  0ed7		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  0ed9		       20 12 f0 	      jsr	puts
      0  0edc					      db	"   ",0
      1  0edc		       20 20 20 00	      .byte.b	"   ",0
    184  0ee0							; Print the line to the console
    185  0ee0		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  0ee2		       a0 90		      ldy	#DiskFileName&$ff
    187  0ee4		       a5 00		      lda	0
    188  0ee6		       20 f8 0d 	      jsr	PrtStr	;else print name
    189  0ee9		       20 18 f0 	      jsr	crlf
    190  0eec
    191  0eec		       4c d0 0e 	      jmp	DiskDirLoop	;do next entry
    192  0eef		       4c eb 02    DiskDirEnd jmp	NextIL
    193  0ef2					      endif
    194  0ef2							;
    195  0ef2							;=====================================================
    196  0ef2							; Does a LIST to a Disk file.
    197  0ef2							;
    198  0ef2				   iDLIST
    199  0ef2					      if	XKIM || CTMON65
    200  0ef2		       20 2d 0f 	      jsr	SetOutDisk
    201  0ef5		       4c 57 06 	      jmp	iLST2
    202  0ef8					      endif
    203  0ef8							;
    204  0ef8							;=====================================================
    205  0ef8							; Closes any pending disk file.  Okay to call if there
    206  0ef8							; is no open file.
    207  0ef8							;
    208  0ef8				   iDCLOSE
    209  0ef8					      if	XKIM || CTMON65
    210  0ef8		       20 42 f0 	      jsr	DiskClose
    211  0efb		       4c eb 02 	      jmp	NextIL
    212  0efe					      endif
    213  0efe							;
    214  0efe							;=====================================================
    215  0efe							; This gets the next byte from an open disk file.  If
    216  0efe							; there are no more bytes left, this returns C set.
    217  0efe							; Else, C is clear and A contains the character.
    218  0efe							;
    219  0efe				   getNextFileByte
    220  0efe					      if	XKIM || CTMON65
    221  0efe		       ae 8f df 	      ldx	diskBufOffset
    222  0f01		       ec 8e df 	      cpx	diskBufLength
    223  0f04		       d0 14		      bne	hasdata	;branch if still data
    224  0f06							;
    225  0f06							; There is no data left in the buffer, so read a
    226  0f06							; block from the SD system.
    227  0f06							;
    228  0f06		       a9 84		      lda	#BUFFER_SIZE
    229  0f08		       a2 df		      ldx	#buffer>>8
    230  0f0a		       a0 0a		      ldy	#buffer&$ff
    231  0f0c		       20 3c f0 	      jsr	DiskRead
    232  0f0f		       b0 12		      bcs	getNextEof
    233  0f11							;
    234  0f11							; A contains the number of bytes actually read.
    235  0f11							;
    236  0f11		       8d 8e df 	      sta	diskBufLength	;save length
    237  0f14		       c9 00		      cmp	#0	;shouldn't happen
    238  0f16		       f0 0b		      beq	getNextEof
    239  0f18							;
    240  0f18		       a2 00		      ldx	#0
    241  0f1a		       bd 0a df    hasdata    lda	buffer,x
    242  0f1d		       e8		      inx
    243  0f1e		       8e 8f df 	      stx	diskBufOffset
    244  0f21		       18		      clc
    245  0f22		       60		      rts
    246  0f23							;
    247  0f23		       a9 00	   getNextEof lda	#0
    248  0f25		       8d 8f df 	      sta	diskBufOffset
    249  0f28		       8d 8e df 	      sta	diskBufLength
    250  0f2b		       38		      sec
    251  0f2c		       60		      rts
    252  0f2d							;
    253  0f2d							;=====================================================
    254  0f2d							; Set output vector to the disk output function
    255  0f2d							;
    256  0f2d		       a9 38	   SetOutDisk lda	#DOUT&$ff
    257  0f2f		       8d b7 12 	      sta	BOutVec
    258  0f32		       a9 0f		      lda	#DOUT/256
    259  0f34		       8d b8 12 	      sta	BOutVec+1
    260  0f37		       60		      rts
    261  0f38							;
    262  0f38							;=====================================================
    263  0f38
    264  0f38		       8d 0a df    DOUT       sta	buffer
    265  0f3b		       a9 01		      lda	#1
    266  0f3d		       a0 0a		      ldy	#buffer&$ff
    267  0f3f		       a2 df		      ldx	#buffer/256
    268  0f41		       20 3f f0 	      jsr	DiskWrite
    269  0f44							;
    270  0f44							; need error checking here
    271  0f44							;
    272  0f44		       60		      rts
    273  0f45					      endif
    274  0f45
    275  0f45
------- FILE mytb.asm
   1719  0f45					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  0f45					      include	"IL.inc"
      1  0f45
      2  0f45							;=====================================================
      3  0f45							; IL.inc
      4  0f45							; These are macros for IL instructions
      5  0f45							;
      6  0f45					      mac	dw
      7  0f45					      .word	{0}
      8  0f45					      endm
      9  0f45					      mac	db
     10  0f45					      .byte	{0}
     11  0f45					      endm
     12  0f45					      macro	xinit
     13  0f45					      db	0
     14  0f45					      endm		;reset the il to start clear all
     15  0f45							;
     16  0f45					      macro	done
     17  0f45					      db	1
     18  0f45					      endm		;print an error if not end of line
     19  0f45							;
     20  0f45					      macro	prs
     21  0f45					      db	2
     22  0f45					      endm		;print a quoted string
     23  0f45							;
     24  0f45					      macro	prn
     25  0f45					      db	3
     26  0f45					      endm		;print a number
     27  0f45							;
     28  0f45					      macro	spc
     29  0f45					      db	4
     30  0f45					      endm		;print space til new tabstop
     31  0f45							;
     32  0f45					      macro	nline
     33  0f45					      db	5
     34  0f45					      endm		;print a new line crlf
     35  0f45							;
     36  0f45							; My NXT is a bit different in that it takes one
     37  0f45							; parameter, which is an address.  If the BASIC
     38  0f45							; program is currently running then move to the
     39  0f45							; next line and continue execution.  However, if
     40  0f45							; in direct mode, jump to the specified IL label.
     41  0f45							;
     42  0f45					      macro	nxt
     43  0f45					      db	6
     44  0f45					      dw	{1}	; addr
     45  0f45					      endm		; addr
     46  0f45							;
     47  0f45					      macro	xfer
     48  0f45					      db	7
     49  0f45					      endm
     50  0f45							;
     51  0f45					      macro	sav
     52  0f45					      db	8
     53  0f45					      endm
     54  0f45							;
     55  0f45					      macro	rstr
     56  0f45					      db	9
     57  0f45					      endm
     58  0f45							;
     59  0f45					      macro	cmpr
     60  0f45					      db	10
     61  0f45					      endm
     62  0f45							;
     63  0f45					      macro	innum
     64  0f45					      db	11
     65  0f45					      endm
     66  0f45							;
     67  0f45					      macro	fin
     68  0f45					      db	12
     69  0f45					      endm
     70  0f45							;
     71  0f45							; ERR is followed by an error number.	The error
     72  0f45							; code is printed along with the line number.
     73  0f45							; Control is passed to the statement set with
     74  0f45							; the ERRGOTO statement.
     75  0f45							;
     76  0f45					      macro	errmsg
     77  0f45					      db	13
     78  0f45					      dw	{1}	;ecode
     79  0f45					      endm		;ecode
     80  0f45							;
     81  0f45					      macro	add
     82  0f45					      db	14
     83  0f45					      endm
     84  0f45							;
     85  0f45					      macro	sub
     86  0f45					      db	15
     87  0f45					      endm
     88  0f45							;
     89  0f45					      macro	neg
     90  0f45					      db	16
     91  0f45					      endm
     92  0f45							;
     93  0f45					      macro	mul
     94  0f45					      db	17
     95  0f45					      endm
     96  0f45							;
     97  0f45					      macro	div
     98  0f45					      db	18
     99  0f45					      endm
    100  0f45							;
    101  0f45					      macro	store
    102  0f45					      db	19
    103  0f45					      endm
    104  0f45							;
    105  0f45					      macro	ind
    106  0f45					      db	20
    107  0f45					      endm
    108  0f45							;
    109  0f45					      macro	lst
    110  0f45					      db	21
    111  0f45					      endm
    112  0f45							;
    113  0f45					      macro	init
    114  0f45					      db	22
    115  0f45					      endm
    116  0f45							;
    117  0f45					      macro	getline
    118  0f45					      db	23
    119  0f45					      endm
    120  0f45							;
    121  0f45					      macro	insert
    122  0f45					      db	24
    123  0f45					      endm
    124  0f45							;
    125  0f45					      macro	rtn
    126  0f45					      db	25
    127  0f45					      endm
    128  0f45							;
    129  0f45					      macro	exit
    130  0f45					      db	26
    131  0f45					      endm
    132  0f45							;
    133  0f45					      macro	lit
    134  0f45					      db	27
    135  0f45					      dw	{1}	;value
    136  0f45					      endm		; value LIT
    137  0f45							;
    138  0f45					      macro	call
    139  0f45					      db	28
    140  0f45					      dw	{1}	;addr
    141  0f45					      endm		;addr
    142  0f45							;
    143  0f45							; IJMP will set the IL PC to the specified value.
    144  0f45							;
    145  0f45					      macro	ijmp
    146  0f45					      db	29
    147  0f45					      dw	{1}	;addr
    148  0f45					      endm		;addr
    149  0f45							;
    150  0f45					      macro	vinit
    151  0f45					      db	30
    152  0f45					      endm
    153  0f45							;
    154  0f45							; ERRGOTO sets the point in the code where the IL
    155  0f45							; interpreter will go after any error.
    156  0f45							;
    157  0f45					      macro	errgoto
    158  0f45					      db	31
    159  0f45					      dw	{1}	;addr
    160  0f45					      endm		;addr
    161  0f45							;
    162  0f45					      macro	tst
    163  0f45					      db	32
    164  0f45					      db	({1}-*)-1	;(addr-*)-1
    165  0f45					      db	{2},0	;string,0
    166  0f45					      endm		;addr,string
    167  0f45							;
    168  0f45					      macro	tstv
    169  0f45					      db	33
    170  0f45					      db	({1}-*)-1	;(addr-*)-1
    171  0f45					      endm		;addr
    172  0f45							;
    173  0f45					      macro	tstl
    174  0f45					      db	34
    175  0f45					      db	({1}-*)-1	;(addr-*)-1
    176  0f45					      endm		;addr
    177  0f45							;
    178  0f45					      macro	tstn
    179  0f45					      db	35
    180  0f45					      db	({1}-*)-1	;(addr-*)-1
    181  0f45					      endm		;addr
    182  0f45							;
    183  0f45							; FREE returns the amount of free RAM on top of
    184  0f45							; the stack.  This is the amount of room the user
    185  0f45							; program has available.
    186  0f45							;
    187  0f45					      macro	free
    188  0f45					      db	36
    189  0f45					      endm
    190  0f45							;
    191  0f45							; RANDOM takes the top item off the stack and
    192  0f45							; replaces it with a random number that is
    193  0f45							; MOD the initial value.  Ie, if the TOS is
    194  0f45							; 42 then RANDOM returns a value from 0 to 41.
    195  0f45							;
    196  0f45					      macro	random
    197  0f45					      db	37
    198  0f45					      endm
    199  0f45							;
    200  0f45							; ABS will replace the top of stack with the
    201  0f45							; absolute value.
    202  0f45							;
    203  0f45					      macro	abs
    204  0f45					      db	38
    205  0f45					      endm
    206  0f45							;
    207  0f45							; OPENREAD opens a file for reading, as in getting
    208  0f45							; statements from it.
    209  0f45							;
    210  0f45					      macro	openread
    211  0f45					      db	39
    212  0f45					      endm
    213  0f45							;
    214  0f45							; OPENWRITE opens a file for writing, as in saving
    215  0f45							; the current program to it.
    216  0f45							;
    217  0f45					      macro	openwrite
    218  0f45					      db	40
    219  0f45					      endm
    220  0f45							;
    221  0f45							; DCLOSE closes any open disk file.
    222  0f45							;
    223  0f45					      macro	dclose
    224  0f45					      db	41
    225  0f45					      endm
    226  0f45							;
    227  0f45							; DGETLINE gets one line from the disk file and puts it
    228  0f45							; into LINBUFF.
    229  0f45							;
    230  0f45					      macro	dgetline
    231  0f45					      db	42
    232  0f45					      endm
    233  0f45							;
    234  0f45							; DLIST saves the program to an open disk file.
    235  0f45							;
    236  0f45					      macro	dlist
    237  0f45					      db	43
    238  0f45					      endm
    239  0f45							; DDIR list the current directory
    240  0f45							;
    241  0f45					      macro	ddir
    242  0f45					      db	44
    243  0f45					      endm
    244  0f45
    245  0f45							; RMFILE remove a fle from disk
    246  0f45					      macro	rmfile
    247  0f45					      db	45
    248  0f45					      endm
    249  0f45
    250  0f45							; CLEARSCREEN clear the screen
    251  0f45					      macro	clearscreen
    252  0f45					      db	46
    253  0f45					      endm
    254  0f45							; POKEMEM Poke value into memory
    255  0f45					      macro	pokemem
    256  0f45					      db	47
    257  0f45					      endm
    258  0f45							; PEEKMEM peek at value in memory
    259  0f45					      macro	peekmem
    260  0f45					      db	48
    261  0f45					      endm
    262  0f45							; TSTLET Test if the statement is a let without the keyword let
    263  0f45					      macro	tstlet
    264  0f45					      db	49
    265  0f45					      db	({1}-*)-1	;(addr-*)-1
    266  0f45					      endm		;addr
    267  0f45							; TSTDONE if we reach the end of a statement
    268  0f45					      macro	tstdone
    269  0f45					      db	50
    270  0f45					      db	({1}-*)-1	;(addr-*)-1
    271  0f45					      endm		;addr
    272  0f45							; GETCHAR	get a character from the input line leave it in RO
    273  0f45					      macro	getchar
    274  0f45					      db	51
    275  0f45					      endm
    276  0f45							; PUTCHAR	Put a character to the terminal
    277  0f45					      macro	putchar
    278  0f45					      db	52
    279  0f45					      endm
    280  0f45							; Call		Call a machine function return a to stack
    281  0f45					      macro	callfunc
    282  0f45					      db	53
    283  0f45					      endm
    284  0f45							; Call		Call a machine function return a to stack
    285  0f45					      macro	callfunc2
    286  0f45					      db	54
    287  0f45					      endm
    288  0f45							; TSTSTR	 Tests for the open quote in a string
    289  0f45					      macro	tststr
    290  0f45					      db	55
    291  0f45					      db	({1}-*)-1	;(addr-*)-1
    292  0f45					      endm
    293  0f45							; SETIRQ	Sets the line number to run when an irq happens irq 550
    294  0f45					      macro	setirq
    295  0f45					      db	56
    296  0f45					      endm
    297  0f45
    298  0f45							; TSTIRQ	Test for irq pending,
    299  0f45							;		if so push the IRQ LINE NUMBER into RO, onto stack
    300  0f45					      macro	tstirq
    301  0f45					      db	57
    302  0f45					      db	({1}-*)-1	;(addr-*)-1
    303  0f45					      endm
    304  0f45
    305  0f45							; IRET    return from interupt service
    306  0f45					      macro	iret
    307  0f45					      db	58
    308  0f45					      endm
    309  0f45							; INSTR   read a string from the input
    310  0f45					      macro	instr
    311  0f45					      db	59
    312  0f45					      endm
    313  0f45
------- FILE mytb.asm
   1721  0f45							;
   1722  0f45				  -	      if	FIXED
   1723  0f45				  -	      org	$1000
   1724  0f45					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  0f45					      include	"basic.il"
      1  0f45							;LET
      2  0f45							;=====================================================
      3  0f45							;=====================================================
      4  0f45							;=====================================================
      5  0f45							; This is the IL of the BASIC (or whatever) language.
      6  0f45							; Because of the way macros are implemented by as65,
      7  0f45							; labels can't be on the same line as a macro
      8  0f45							; invocation, so that's why labels are on separate
      9  0f45							; lines.
     10  0f45							;
     11  0f45		       0f 45	   IL	      equ	*
     12  0f45
     13  0f45							;THE IL CONTROL SECTION
     14  0f45
     15  0f45				   START
      0  0f45					      INIT		;INITIALIZE
      0  0f45					      db	22
      1  0f45		       16		      .byte.b	22
      0  0f46					      NLINE		;WRITE CRLF
      0  0f46					      db	5
      1  0f46		       05		      .byte.b	5
      0  0f47					      ERRGOTO	CO	;where to go after an error
      0  0f47					      db	31
      1  0f47		       1f		      .byte.b	31
      0  0f48					      dw	CO
      1  0f48		       4b 0f		      .word.w	CO
      0  0f4a					      VINIT		;clear all variables
      0  0f4a					      db	30
      1  0f4a		       1e		      .byte.b	30
     20  0f4b							;
     21  0f4b							; This is where we jump to get a line of commands or
     22  0f4b							; a program from the user.
     23  0f4b							;
     24  0f4b				   CO
      0  0f4b					      GETLINE		;WRITE PROMPT AND GET LINE
      0  0f4b					      db	23
      1  0f4b		       17		      .byte.b	23
      0  0f4c					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  0f4c					      db	34
      1  0f4c		       22		      .byte.b	34
      0  0f4d					      db	(XEC-*)-1
      1  0f4d		       04		      .byte.b	(XEC-*)-1
      0  0f4e					      INSERT		;INSERT IT (MAY BE DELETE)
      0  0f4e					      db	24
      1  0f4e		       18		      .byte.b	24
      0  0f4f					      IJMP	CO
      0  0f4f					      db	29
      1  0f4f		       1d		      .byte.b	29
      0  0f50					      dw	CO
      1  0f50		       4b 0f		      .word.w	CO
     29  0f52				   XEC
      0  0f52					      XINIT		;INITIALIZE
      0  0f52					      db	0
      1  0f52		       00		      .byte.b	0
     31  0f53
     32  0f53							;STATEMENT EXECUTOR
     33  0f53				   STMT
      0  0f53					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  0f53					      db	57
      1  0f53		       39		      .byte.b	57
      0  0f54					      db	(notirq-*)-1
      1  0f54		       00		      .byte.b	(notirq-*)-1
     35  0f55				   notirq
      0  0f55					      TSTLET	LET	;Test if second field is =
      0  0f55					      db	49
      1  0f55		       31		      .byte.b	49
      0  0f56					      db	(LET-*)-1
      1  0f56		       03		      .byte.b	(LET-*)-1
      0  0f57					      IJMP	DOLET	;allow the default to be let
      0  0f57					      db	29
      1  0f57		       1d		      .byte.b	29
      0  0f58					      dw	DOLET
      1  0f58		       60 0f		      .word.w	DOLET
     38  0f5a				   LET
      0  0f5a					      TST	S1,"LET"	;IS STATEMENT A LET
      0  0f5a					      db	32
      1  0f5a		       20		      .byte.b	32
      0  0f5b					      db	(S1-*)-1
      1  0f5b		       15		      .byte.b	(S1-*)-1
      0  0f5c					      db	"LET",0
      1  0f5c		       4c 45 54 00	      .byte.b	"LET",0
     40  0f60				   DOLET
      0  0f60					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  0f60					      db	33
      1  0f60		       21		      .byte.b	33
      0  0f61					      db	(ERRVEC-*)-1
      1  0f61		       92		      .byte.b	(ERRVEC-*)-1
      0  0f62					      TST	ERRVEC,"="	;(This line originally omitted)
      0  0f62					      db	32
      1  0f62		       20		      .byte.b	32
      0  0f63					      db	(ERRVEC-*)-1
      1  0f63		       90		      .byte.b	(ERRVEC-*)-1
      0  0f64					      db	"=",0
      1  0f64		       3d 00		      .byte.b	"=",0
      0  0f66					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  0f66					      db	28
      1  0f66		       1c		      .byte.b	28
      0  0f67					      dw	EXPR
      1  0f67		       02 11		      .word.w	EXPR
      0  0f69					      DONE		;REPORT ERROR IF NOT NEXT
      0  0f69					      db	1
      1  0f69		       01		      .byte.b	1
      0  0f6a					      STORE		;STORE RESULT
      0  0f6a					      db	19
      1  0f6a		       13		      .byte.b	19
      0  0f6b					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0f6b					      db	6
      1  0f6b		       06		      .byte.b	6
      0  0f6c					      dw	CO
      1  0f6c		       4b 0f		      .word.w	CO
      0  0f6e					      IJMP	STMT
      0  0f6e					      db	29
      1  0f6e		       1d		      .byte.b	29
      0  0f6f					      dw	STMT
      1  0f6f		       53 0f		      .word.w	STMT
     48  0f71				   S1
      0  0f71					      TST	S1S1,"IRET"	;test return from interupt
      0  0f71					      db	32
      1  0f71		       20		      .byte.b	32
      0  0f72					      db	(S1S1-*)-1
      1  0f72		       10		      .byte.b	(S1S1-*)-1
      0  0f73					      db	"IRET",0
      1  0f73		       49 52 45 54*	      .byte.b	"IRET",0
      0  0f78					      TST	S1Sa,"URN"
      0  0f78					      db	32
      1  0f78		       20		      .byte.b	32
      0  0f79					      db	(S1Sa-*)-1
      1  0f79		       04		      .byte.b	(S1Sa-*)-1
      0  0f7a					      db	"URN",0
      1  0f7a		       55 52 4e 00	      .byte.b	"URN",0
     51  0f7e				   S1Sa
      0  0f7e					      DONE		;Must be only thing on the line
      0  0f7e					      db	1
      1  0f7e		       01		      .byte.b	1
      0  0f7f					      IRET		;RESTORE LINE NUMBER OF CALL
      0  0f7f					      db	58
      1  0f7f		       3a		      .byte.b	58
      0  0f80					      IJMP	STMT
      0  0f80					      db	29
      1  0f80		       1d		      .byte.b	29
      0  0f81					      dw	STMT
      1  0f81		       53 0f		      .word.w	STMT
     55  0f83
     56  0f83				   S1S1
      0  0f83					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  0f83					      db	32
      1  0f83		       20		      .byte.b	32
      0  0f84					      db	(S2b-*)-1
      1  0f84		       19		      .byte.b	(S2b-*)-1
      0  0f85					      db	"GO",0
      1  0f85		       47 4f 00 	      .byte.b	"GO",0
      0  0f88					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  0f88					      db	32
      1  0f88		       20		      .byte.b	32
      0  0f89					      db	(S2-*)-1
      1  0f89		       08		      .byte.b	(S2-*)-1
      0  0f8a					      db	"TO",0
      1  0f8a		       54 4f 00 	      .byte.b	"TO",0
      0  0f8d					      CALL	EXPR	;GET LABEL
      0  0f8d					      db	28
      1  0f8d		       1c		      .byte.b	28
      0  0f8e					      dw	EXPR
      1  0f8e		       02 11		      .word.w	EXPR
      0  0f90					      DONE		;ERROR IF CR NOT NEXT
      0  0f90					      db	1
      1  0f90		       01		      .byte.b	1
      0  0f91					      XFER		;SET UP AND JUMP
      0  0f91					      db	7
      1  0f91		       07		      .byte.b	7
     62  0f92				   S2
      0  0f92					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  0f92					      db	32
      1  0f92		       20		      .byte.b	32
      0  0f93					      db	(ERRVEC-*)-1
      1  0f93		       60		      .byte.b	(ERRVEC-*)-1
      0  0f94					      db	"SUB",0
      1  0f94		       53 55 42 00	      .byte.b	"SUB",0
      0  0f98					      CALL	EXPR	;GET DESTINATION
      0  0f98					      db	28
      1  0f98		       1c		      .byte.b	28
      0  0f99					      dw	EXPR
      1  0f99		       02 11		      .word.w	EXPR
      0  0f9b					      DONE		;ERROR IF CR NOT NEXT
      0  0f9b					      db	1
      1  0f9b		       01		      .byte.b	1
      0  0f9c					      SAV		;SAVE RETURN LINE
      0  0f9c					      db	8
      1  0f9c		       08		      .byte.b	8
      0  0f9d					      XFER		;AND JUMP
      0  0f9d					      db	7
      1  0f9d		       07		      .byte.b	7
     68  0f9e				   S2b
      0  0f9e					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  0f9e					      db	32
      1  0f9e		       20		      .byte.b	32
      0  0f9f					      db	(S3-*)-1
      1  0f9f		       1f		      .byte.b	(S3-*)-1
      0  0fa0					      db	"RE",0
      1  0fa0		       52 45 00 	      .byte.b	"RE",0
      0  0fa3					      TST	S2a,"T"
      0  0fa3					      db	32
      1  0fa3		       20		      .byte.b	32
      0  0fa4					      db	(S2a-*)-1
      1  0fa4		       10		      .byte.b	(S2a-*)-1
      0  0fa5					      db	"T",0
      1  0fa5		       54 00		      .byte.b	"T",0
      0  0fa7					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  0fa7					      db	32
      1  0fa7		       20		      .byte.b	32
      0  0fa8					      db	(S2aa-*)-1
      1  0fa8		       04		      .byte.b	(S2aa-*)-1
      0  0fa9					      db	"URN",0
      1  0fa9		       55 52 4e 00	      .byte.b	"URN",0
     72  0fad				   S2aa
      0  0fad					      DONE		;MUST BE CR
      0  0fad					      db	1
      1  0fad		       01		      .byte.b	1
      0  0fae					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  0fae					      db	9
      1  0fae		       09		      .byte.b	9
      0  0faf					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  0faf					      db	6
      1  0faf		       06		      .byte.b	6
      0  0fb0					      dw	CO
      1  0fb0		       4b 0f		      .word.w	CO
      0  0fb2					      IJMP	STMT
      0  0fb2					      db	29
      1  0fb2		       1d		      .byte.b	29
      0  0fb3					      dw	STMT
      1  0fb3		       53 0f		      .word.w	STMT
     77  0fb5				   S2a
      0  0fb5					      TST	S3,"M"	;REMark.  Skip rest of line
      0  0fb5					      db	32
      1  0fb5		       20		      .byte.b	32
      0  0fb6					      db	(S3-*)-1
      1  0fb6		       08		      .byte.b	(S3-*)-1
      0  0fb7					      db	"M",0
      1  0fb7		       4d 00		      .byte.b	"M",0
      0  0fb9					      NXT	CO
      0  0fb9					      db	6
      1  0fb9		       06		      .byte.b	6
      0  0fba					      dw	CO
      1  0fba		       4b 0f		      .word.w	CO
      0  0fbc					      IJMP	STMT
      0  0fbc					      db	29
      1  0fbc		       1d		      .byte.b	29
      0  0fbd					      dw	STMT
      1  0fbd		       53 0f		      .word.w	STMT
     81  0fbf
     82  0fbf				   S3
      0  0fbf					      TST	S3a,"?"	; ? symonym for print
      0  0fbf					      db	32
      1  0fbf		       20		      .byte.b	32
      0  0fc0					      db	(S3a-*)-1
      1  0fc0		       05		      .byte.b	(S3a-*)-1
      0  0fc1					      db	"?",0
      1  0fc1		       3f 00		      .byte.b	"?",0
      0  0fc3					      IJMP	S4
      0  0fc3					      db	29
      1  0fc3		       1d		      .byte.b	29
      0  0fc4					      dw	S4
      1  0fc4		       d1 0f		      .word.w	S4
     85  0fc6				   S3a
      0  0fc6					      TST	S8,"PR"	;allow short form of print
      0  0fc6					      db	32
      1  0fc6		       20		      .byte.b	32
      0  0fc7					      db	(S8-*)-1
      1  0fc7		       36		      .byte.b	(S8-*)-1
      0  0fc8					      db	"PR",0
      1  0fc8		       50 52 00 	      .byte.b	"PR",0
      0  0fcb					      TST	S4,"INT"	;PRINT
      0  0fcb					      db	32
      1  0fcb		       20		      .byte.b	32
      0  0fcc					      db	(S4-*)-1
      1  0fcc		       04		      .byte.b	(S4-*)-1
      0  0fcd					      db	"INT",0
      1  0fcd		       49 4e 54 00	      .byte.b	"INT",0
     88  0fd1				   S4
      0  0fd1					      TSTDONE	S4a	;Test if we just want crlf printed
      0  0fd1					      db	50
      1  0fd1		       32		      .byte.b	50
      0  0fd2					      db	(S4a-*)-1
      1  0fd2		       03		      .byte.b	(S4a-*)-1
      0  0fd3					      IJMP	S6
      0  0fd3					      db	29
      1  0fd3		       1d		      .byte.b	29
      0  0fd4					      dw	S6
      1  0fd4		       ec 0f		      .word.w	S6
     91  0fd6
      0  0fd6				   S4a	      TSTSTR	S7	;TEST FOR QUOTED String
      0  0fd6					      db	55
      1  0fd6		       37		      .byte.b	55
      0  0fd7					      db	(S7-*)-1
      1  0fd7		       1f		      .byte.b	(S7-*)-1
      0  0fd8					      PRS		;PRINT STRING
      0  0fd8					      db	2
      1  0fd8		       02		      .byte.b	2
     94  0fd9				   S5
      0  0fd9					      TST	S6A,COMMA	;IS THERE MORE?
      0  0fd9					      db	32
      1  0fd9		       20		      .byte.b	32
      0  0fda					      db	(S6A-*)-1
      1  0fda		       08		      .byte.b	(S6A-*)-1
      0  0fdb					      db	COMMA,0
      1  0fdb		       2c 00		      .byte.b	COMMA,0
      0  0fdd					      SPC		;SPACE TO NEXT ZONE
      0  0fdd					      db	4
      1  0fdd		       04		      .byte.b	4
      0  0fde					      TSTDONE	S4	;Not end of line jump back
      0  0fde					      db	50
      1  0fde		       32		      .byte.b	50
      0  0fdf					      db	(S4-*)-1
      1  0fdf		       f1		      .byte.b	(S4-*)-1
      0  0fe0					      IJMP	S6a	;YES JUMP BACK
      0  0fe0					      db	29
      1  0fe0		       1d		      .byte.b	29
      0  0fe1					      dw	S6a
      1  0fe1		       ee 0f		      .word.w	S6a
     99  0fe3							;
    100  0fe3							; If a semicolon, don't do anything.
    101  0fe3							;
    102  0fe3				   S6A
      0  0fe3					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  0fe3					      db	32
      1  0fe3		       20		      .byte.b	32
      0  0fe4					      db	(S6-*)-1
      1  0fe4		       07		      .byte.b	(S6-*)-1
      0  0fe5					      db	SEMICOLON,0
      1  0fe5		       3b 00		      .byte.b	SEMICOLON,0
      0  0fe7					      TSTDONE	S4	;Jump Back if not end of line
      0  0fe7					      db	50
      1  0fe7		       32		      .byte.b	50
      0  0fe8					      db	(S4-*)-1
      1  0fe8		       e8		      .byte.b	(S4-*)-1
      0  0fe9					      IJMP	S6a
      0  0fe9					      db	29
      1  0fe9		       1d		      .byte.b	29
      0  0fea					      dw	S6a
      1  0fea		       ee 0f		      .word.w	S6a
    106  0fec				   S6
      0  0fec					      DONE		;ERROR IF CR NOT NEXT
      0  0fec					      db	1
      1  0fec		       01		      .byte.b	1
      0  0fed					      NLINE
      0  0fed					      db	5
      1  0fed		       05		      .byte.b	5
      0  0fee				   S6a	      NXT	CO	;exit here if , or ; at end of print
      0  0fee					      db	6
      1  0fee		       06		      .byte.b	6
      0  0fef					      dw	CO
      1  0fef		       4b 0f		      .word.w	CO
      0  0ff1					      IJMP	STMT
      0  0ff1					      db	29
      1  0ff1		       1d		      .byte.b	29
      0  0ff2					      dw	STMT
      1  0ff2		       53 0f		      .word.w	STMT
    111  0ff4							;
    112  0ff4							; A jump for code too far away for relative branch
    113  0ff4							;
    114  0ff4				   ERRVEC
      0  0ff4					      IJMP	UNKNOWN
      0  0ff4					      db	29
      1  0ff4		       1d		      .byte.b	29
      0  0ff5					      dw	UNKNOWN
      1  0ff5		       ff 10		      .word.w	UNKNOWN
    116  0ff7							;
    117  0ff7				   S7
      0  0ff7					      CALL	EXPR
      0  0ff7					      db	28
      1  0ff7		       1c		      .byte.b	28
      0  0ff8					      dw	EXPR
      1  0ff8		       02 11		      .word.w	EXPR
      0  0ffa					      PRN		;PRINT IT
      0  0ffa					      db	3
      1  0ffa		       03		      .byte.b	3
      0  0ffb					      IJMP	S5	;IS THERE MORE?
      0  0ffb					      db	29
      1  0ffb		       1d		      .byte.b	29
      0  0ffc					      dw	S5
      1  0ffc		       d9 0f		      .word.w	S5
    121  0ffe				   S8
      0  0ffe					      TST	S8a,"IF"	;IF STATEMENT
      0  0ffe					      db	32
      1  0ffe		       20		      .byte.b	32
      0  0fff					      db	(S8a-*)-1
      1  0fff		       17		      .byte.b	(S8a-*)-1
      0  1000					      db	"IF",0
      1  1000		       49 46 00 	      .byte.b	"IF",0
      0  1003					      CALL	EXPR	;GET EXPRESSION
      0  1003					      db	28
      1  1003		       1c		      .byte.b	28
      0  1004					      dw	EXPR
      1  1004		       02 11		      .word.w	EXPR
      0  1006					      CALL	RELOP	;DETERMINE OPR AND PUT ON STK
      0  1006					      db	28
      1  1006		       1c		      .byte.b	28
      0  1007					      dw	RELOP
      1  1007		       cc 11		      .word.w	RELOP
      0  1009					      CALL	EXPR	;GET EXPRESSION
      0  1009					      db	28
      1  1009		       1c		      .byte.b	28
      0  100a					      dw	EXPR
      1  100a		       02 11		      .word.w	EXPR
      0  100c					      TST	S8a1,"THEN"	;(This line originally omitted) not required
      0  100c					      db	32
      1  100c		       20		      .byte.b	32
      0  100d					      db	(S8a1-*)-1
      1  100d		       05		      .byte.b	(S8a1-*)-1
      0  100e					      db	"THEN",0
      1  100e		       54 48 45 4e*	      .byte.b	"THEN",0
      0  1013				   S8a1       CMPR		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE
      0  1013					      db	10
      1  1013		       0a		      .byte.b	10
      0  1014					      IJMP	STMT
      0  1014					      db	29
      1  1014		       1d		      .byte.b	29
      0  1015					      dw	STMT
      1  1015		       53 0f		      .word.w	STMT
    129  1017
    130  1017				   S8a
      0  1017					      TST	S8b,"POKE("	;Poke a value into memory
      0  1017					      db	32
      1  1017		       20		      .byte.b	32
      0  1018					      db	(S8b-*)-1
      1  1018		       1c		      .byte.b	(S8b-*)-1
      0  1019					      db	"POKE(",0
      1  1019		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  101f					      CALL	EXPR	;Get address to write to
      0  101f					      db	28
      1  101f		       1c		      .byte.b	28
      0  1020					      dw	EXPR
      1  1020		       02 11		      .word.w	EXPR
      0  1022					      TST	UNKNOWN,COMMA	;Must have a coma
      0  1022					      db	32
      1  1022		       20		      .byte.b	32
      0  1023					      db	(UNKNOWN-*)-1
      1  1023		       db		      .byte.b	(UNKNOWN-*)-1
      0  1024					      db	COMMA,0
      1  1024		       2c 00		      .byte.b	COMMA,0
      0  1026					      CALL	EXPR	;Get the value to poke
      0  1026					      db	28
      1  1026		       1c		      .byte.b	28
      0  1027					      dw	EXPR
      1  1027		       02 11		      .word.w	EXPR
      0  1029					      TST	UNKNOWN,")"
      0  1029					      db	32
      1  1029		       20		      .byte.b	32
      0  102a					      db	(UNKNOWN-*)-1
      1  102a		       d4		      .byte.b	(UNKNOWN-*)-1
      0  102b					      db	")",0
      1  102b		       29 00		      .byte.b	")",0
      0  102d					      POKEMEM
      0  102d					      db	47
      1  102d		       2f		      .byte.b	47
      0  102e					      DONE
      0  102e					      db	1
      1  102e		       01		      .byte.b	1
      0  102f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  102f					      db	6
      1  102f		       06		      .byte.b	6
      0  1030					      dw	CO
      1  1030		       4b 0f		      .word.w	CO
      0  1032					      IJMP	STMT
      0  1032					      db	29
      1  1032		       1d		      .byte.b	29
      0  1033					      dw	STMT
      1  1033		       53 0f		      .word.w	STMT
    140  1035
    141  1035				   S8b
      0  1035					      TST	S8c,"PUTCH("	;Put a char to the terminal
      0  1035					      db	32
      1  1035		       20		      .byte.b	32
      0  1036					      db	(S8c-*)-1
      1  1036		       16		      .byte.b	(S8c-*)-1
      0  1037					      db	"PUTCH(",0
      1  1037		       50 55 54 43*	      .byte.b	"PUTCH(",0
      0  103e					      CALL	EXPR
      0  103e					      db	28
      1  103e		       1c		      .byte.b	28
      0  103f					      dw	EXPR
      1  103f		       02 11		      .word.w	EXPR
      0  1041					      TST	UNKNOWN,")"
      0  1041					      db	32
      1  1041		       20		      .byte.b	32
      0  1042					      db	(UNKNOWN-*)-1
      1  1042		       bc		      .byte.b	(UNKNOWN-*)-1
      0  1043					      db	")",0
      1  1043		       29 00		      .byte.b	")",0
      0  1045					      PUTCHAR
      0  1045					      db	52
      1  1045		       34		      .byte.b	52
      0  1046					      DONE
      0  1046					      db	1
      1  1046		       01		      .byte.b	1
      0  1047					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1047					      db	6
      1  1047		       06		      .byte.b	6
      0  1048					      dw	CO
      1  1048		       4b 0f		      .word.w	CO
      0  104a					      IJMP	STMT
      0  104a					      db	29
      1  104a		       1d		      .byte.b	29
      0  104b					      dw	STMT
      1  104b		       53 0f		      .word.w	STMT
    149  104d				   S8c
      0  104d					      TST	S9,"CLS"	;Clear the screen
      0  104d					      db	32
      1  104d		       20		      .byte.b	32
      0  104e					      db	(S9-*)-1
      1  104e		       0c		      .byte.b	(S9-*)-1
      0  104f					      db	"CLS",0
      1  104f		       43 4c 53 00	      .byte.b	"CLS",0
      0  1053					      CLEARSCREEN
      0  1053					      db	46
      1  1053		       2e		      .byte.b	46
      0  1054					      DONE
      0  1054					      db	1
      1  1054		       01		      .byte.b	1
      0  1055					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1055					      db	6
      1  1055		       06		      .byte.b	6
      0  1056					      dw	CO
      1  1056		       4b 0f		      .word.w	CO
      0  1058					      IJMP	STMT
      0  1058					      db	29
      1  1058		       1d		      .byte.b	29
      0  1059					      dw	STMT
      1  1059		       53 0f		      .word.w	STMT
    155  105b				   S9
      0  105b					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  105b					      db	32
      1  105b		       20		      .byte.b	32
      0  105c					      db	(S13-*)-1
      1  105c		       27		      .byte.b	(S13-*)-1
      0  105d					      db	"INPUT",0
      1  105d		       49 4e 50 55*	      .byte.b	"INPUT",0
    157  1063				   S10
      0  1063					      TSTSTR	S10A	;If there is a string print the prompt
      0  1063					      db	55
      1  1063		       37		      .byte.b	55
      0  1064					      db	(S10A-*)-1
      1  1064		       05		      .byte.b	(S10A-*)-1
      0  1065					      PRS
      0  1065					      db	2
      1  1065		       02		      .byte.b	2
      0  1066					      TST	S10A,COMMA	;IS THERE MORE?
      0  1066					      db	32
      1  1066		       20		      .byte.b	32
      0  1067					      db	(S10A-*)-1
      1  1067		       02		      .byte.b	(S10A-*)-1
      0  1068					      db	COMMA,0
      1  1068		       2c 00		      .byte.b	COMMA,0
    161  106a				   S10A
      0  106a					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  106a					      db	33
      1  106a		       21		      .byte.b	33
      0  106b					      db	(UNKNOWN-*)-1
      1  106b		       93		      .byte.b	(UNKNOWN-*)-1
      0  106c					      TST	S10A1,DOLLAR
      0  106c					      db	32
      1  106c		       20		      .byte.b	32
      0  106d					      db	(S10A1-*)-1
      1  106d		       06		      .byte.b	(S10A1-*)-1
      0  106e					      db	DOLLAR,0
      1  106e		       24 00		      .byte.b	DOLLAR,0
      0  1070					      INSTR
      0  1070					      db	59
      1  1070		       3b		      .byte.b	59
      0  1071					      IJMP	S10A2
      0  1071					      db	29
      1  1071		       1d		      .byte.b	29
      0  1072					      dw	S10A2
      1  1072		       75 10		      .word.w	S10A2
    166  1074				   S10A1
      0  1074					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1074					      db	11
      1  1074		       0b		      .byte.b	11
    168  1075				   S10A2
      0  1075					      STORE		;STORE IT
      0  1075					      db	19
      1  1075		       13		      .byte.b	19
      0  1076					      TST	S11,COMMA	;IS THERE MORE?
      0  1076					      db	32
      1  1076		       20		      .byte.b	32
      0  1077					      db	(S11-*)-1
      1  1077		       05		      .byte.b	(S11-*)-1
      0  1078					      db	COMMA,0
      1  1078		       2c 00		      .byte.b	COMMA,0
      0  107a					      IJMP	S10	;YES
      0  107a					      db	29
      1  107a		       1d		      .byte.b	29
      0  107b					      dw	S10
      1  107b		       63 10		      .word.w	S10
    172  107d
    173  107d				   S11
      0  107d					      DONE		;MUST BE CR
      0  107d					      db	1
      1  107d		       01		      .byte.b	1
      0  107e					      NXT	CO	;SEQUENCE TO NEXT
      0  107e					      db	6
      1  107e		       06		      .byte.b	6
      0  107f					      dw	CO
      1  107f		       4b 0f		      .word.w	CO
      0  1081					      IJMP	STMT
      0  1081					      db	29
      1  1081		       1d		      .byte.b	29
      0  1082					      dw	STMT
      1  1082		       53 0f		      .word.w	STMT
    177  1084				   S13
      0  1084					      TST	S14,"END"
      0  1084					      db	32
      1  1084		       20		      .byte.b	32
      0  1085					      db	(S14-*)-1
      1  1085		       05		      .byte.b	(S14-*)-1
      0  1086					      db	"END",0
      1  1086		       45 4e 44 00	      .byte.b	"END",0
      0  108a					      FIN
      0  108a					      db	12
      1  108a		       0c		      .byte.b	12
    180  108b				   S14
      0  108b					      TST	S14S1,"IRQ"	;Check if we are setting IRQ HANDLER
      0  108b					      db	32
      1  108b		       20		      .byte.b	32
      0  108c					      db	(S14S1-*)-1
      1  108c		       0f		      .byte.b	(S14S1-*)-1
      0  108d					      db	"IRQ",0
      1  108d		       49 52 51 00	      .byte.b	"IRQ",0
      0  1091					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1091					      db	28
      1  1091		       1c		      .byte.b	28
      0  1092					      dw	EXPR
      1  1092		       02 11		      .word.w	EXPR
      0  1094					      DONE		;must be CR
      0  1094					      db	1
      1  1094		       01		      .byte.b	1
      0  1095					      SETIRQ		;Set the line number now
      0  1095					      db	56
      1  1095		       38		      .byte.b	56
      0  1096					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1096					      db	6
      1  1096		       06		      .byte.b	6
      0  1097					      dw	CO
      1  1097		       4b 0f		      .word.w	CO
      0  1099					      IJMP	STMT
      0  1099					      db	29
      1  1099		       1d		      .byte.b	29
      0  109a					      dw	STMT
      1  109a		       53 0f		      .word.w	STMT
    187  109c				   S14S1
      0  109c					      TST	S15,"LIST"	;LIST COMMAND
      0  109c					      db	32
      1  109c		       20		      .byte.b	32
      0  109d					      db	(S15-*)-1
      1  109d		       0a		      .byte.b	(S15-*)-1
      0  109e					      db	"LIST",0
      1  109e		       4c 49 53 54*	      .byte.b	"LIST",0
      0  10a3					      DONE
      0  10a3					      db	1
      1  10a3		       01		      .byte.b	1
      0  10a4					      LST
      0  10a4					      db	21
      1  10a4		       15		      .byte.b	21
      0  10a5					      IJMP	CO
      0  10a5					      db	29
      1  10a5		       1d		      .byte.b	29
      0  10a6					      dw	CO
      1  10a6		       4b 0f		      .word.w	CO
    192  10a8				   S15
      0  10a8					      TST	S16,"RUN"	;RUN COMMAND
      0  10a8					      db	32
      1  10a8		       20		      .byte.b	32
      0  10a9					      db	(S16-*)-1
      1  10a9		       0d		      .byte.b	(S16-*)-1
      0  10aa					      db	"RUN",0
      1  10aa		       52 55 4e 00	      .byte.b	"RUN",0
      0  10ae					      DONE
      0  10ae					      db	1
      1  10ae		       01		      .byte.b	1
      0  10af					      VINIT		;clear variables
      0  10af					      db	30
      1  10af		       1e		      .byte.b	30
      0  10b0					      LIT	1	;GOTO line 1
      0  10b0					      db	27
      1  10b0		       1b		      .byte.b	27
      0  10b1					      dw	1
      1  10b1		       01 00		      .word.w	1
      0  10b3					      XFER		;Bob's addition
      0  10b3					      db	7
      1  10b3		       07		      .byte.b	7
    198  10b4							; EXIT
      0  10b4					      IJMP	STMT	;and run!
      0  10b4					      db	29
      1  10b4		       1d		      .byte.b	29
      0  10b5					      dw	STMT
      1  10b5		       53 0f		      .word.w	STMT
    200  10b7				   S16
      0  10b7					      TST	S17A,"NEW"	;clear program
      0  10b7					      db	32
      1  10b7		       20		      .byte.b	32
      0  10b8					      db	(S17A-*)-1
      1  10b8		       08		      .byte.b	(S17A-*)-1
      0  10b9					      db	"NEW",0
      1  10b9		       4e 45 57 00	      .byte.b	"NEW",0
      0  10bd					      DONE
      0  10bd					      db	1
      1  10bd		       01		      .byte.b	1
      0  10be					      IJMP	START
      0  10be					      db	29
      1  10be		       1d		      .byte.b	29
      0  10bf					      dw	START
      1  10bf		       45 0f		      .word.w	START
    204  10c1
    205  10c1				   S17A
      0  10c1					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  10c1					      db	32
      1  10c1		       20		      .byte.b	32
      0  10c2					      db	(S17B-*)-1
      1  10c2		       06		      .byte.b	(S17B-*)-1
      0  10c3					      db	"EXIT",0
      1  10c3		       45 58 49 54*	      .byte.b	"EXIT",0
      0  10c8					      EXIT
      0  10c8					      db	26
      1  10c8		       1a		      .byte.b	26
    208  10c9
    209  10c9							;
    210  10c9							; Commands related to saving/restoring programs
    211  10c9							; to/from mass storage.
    212  10c9							;
    213  10c9				   S17B
    214  10c9					      if	(XKIM || CTMON65) && DISK_ACCESS
    215  10c9
      0  10c9					      TST	S17C,"SAVE"
      0  10c9					      db	32
      1  10c9		       20		      .byte.b	32
      0  10ca					      db	(S17C-*)-1
      1  10ca		       0b		      .byte.b	(S17C-*)-1
      0  10cb					      db	"SAVE",0
      1  10cb		       53 41 56 45*	      .byte.b	"SAVE",0
      0  10d0					      OPENWRITE
      0  10d0					      db	40
      1  10d0		       28		      .byte.b	40
      0  10d1					      DLIST
      0  10d1					      db	43
      1  10d1		       2b		      .byte.b	43
      0  10d2					      DCLOSE
      0  10d2					      db	41
      1  10d2		       29		      .byte.b	41
      0  10d3					      IJMP	CO
      0  10d3					      db	29
      1  10d3		       1d		      .byte.b	29
      0  10d4					      dw	CO
      1  10d4		       4b 0f		      .word.w	CO
    221  10d6
    222  10d6				   S17C
      0  10d6					      TST	S18,"LOAD"
      0  10d6					      db	32
      1  10d6		       20		      .byte.b	32
      0  10d7					      db	(S18-*)-1
      1  10d7		       11		      .byte.b	(S18-*)-1
      0  10d8					      db	"LOAD",0
      1  10d8		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  10dd					      OPENREAD
      0  10dd					      db	39
      1  10dd		       27		      .byte.b	39
    225  10de				   S17CLP
      0  10de					      DGETLINE		;get line from file
      0  10de					      db	42
      1  10de		       2a		      .byte.b	42
      0  10df					      TSTL	S17EOL	;no line num means EOL
      0  10df					      db	34
      1  10df		       22		      .byte.b	34
      0  10e0					      db	(S17EOL-*)-1
      1  10e0		       04		      .byte.b	(S17EOL-*)-1
      0  10e1					      INSERT		;put it into the program
      0  10e1					      db	24
      1  10e1		       18		      .byte.b	24
      0  10e2					      IJMP	S17CLP	;keep going
      0  10e2					      db	29
      1  10e2		       1d		      .byte.b	29
      0  10e3					      dw	S17CLP
      1  10e3		       de 10		      .word.w	S17CLP
    230  10e5				   S17EOL
      0  10e5					      DCLOSE		;close disk file
      0  10e5					      db	41
      1  10e5		       29		      .byte.b	41
      0  10e6					      IJMP	CO	;back to start
      0  10e6					      db	29
      1  10e6		       1d		      .byte.b	29
      0  10e7					      dw	CO
      1  10e7		       4b 0f		      .word.w	CO
    233  10e9
      0  10e9				   S18	      TST	S19,"DIR"
      0  10e9					      db	32
      1  10e9		       20		      .byte.b	32
      0  10ea					      db	(S19-*)-1
      1  10ea		       08		      .byte.b	(S19-*)-1
      0  10eb					      db	"DIR",0
      1  10eb		       44 49 52 00	      .byte.b	"DIR",0
      0  10ef					      DDIR		;Display the directory content
      0  10ef					      db	44
      1  10ef		       2c		      .byte.b	44
      0  10f0					      IJMP	CO
      0  10f0					      db	29
      1  10f0		       1d		      .byte.b	29
      0  10f1					      dw	CO
      1  10f1		       4b 0f		      .word.w	CO
    237  10f3					      endif
    238  10f3
      0  10f3				   S19	      TST	UNKNOWN,"ERASE"
      0  10f3					      db	32
      1  10f3		       20		      .byte.b	32
      0  10f4					      db	(UNKNOWN-*)-1
      1  10f4		       0a		      .byte.b	(UNKNOWN-*)-1
      0  10f5					      db	"ERASE",0
      1  10f5		       45 52 41 53*	      .byte.b	"ERASE",0
      0  10fb					      RMFILE		;Erase the file from the disk
      0  10fb					      db	45
      1  10fb		       2d		      .byte.b	45
      0  10fc					      IJMP	CO
      0  10fc					      db	29
      1  10fc		       1d		      .byte.b	29
      0  10fd					      dw	CO
      1  10fd		       4b 0f		      .word.w	CO
    242  10fd					      endif
    243  10ff
    244  10ff							;
    245  10ff							; Else, unknown command.
    246  10ff							;
    247  10ff				   UNKNOWN
      0  10ff					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  10ff					      db	13
      1  10ff		       0d		      .byte.b	13
      0  1100					      dw	ERR_SYNTAX
      1  1100		       05 00		      .word.w	ERR_SYNTAX
    249  1102
    250  1102							;-----------------------------------------------------
    251  1102				   EXPR
      0  1102					      TST	E0,"-"
      0  1102					      db	32
      1  1102		       20		      .byte.b	32
      0  1103					      db	(E0-*)-1
      1  1103		       09		      .byte.b	(E0-*)-1
      0  1104					      db	"-",0
      1  1104		       2d 00		      .byte.b	"-",0
      0  1106					      CALL	TERM	;TEST FOR UNARY -.
      0  1106					      db	28
      1  1106		       1c		      .byte.b	28
      0  1107					      dw	TERM
      1  1107		       2b 11		      .word.w	TERM
      0  1109					      NEG		;GET VALUE
      0  1109					      db	16
      1  1109		       10		      .byte.b	16
      0  110a					      IJMP	E1	;NEGATE IT
      0  110a					      db	29
      1  110a		       1d		      .byte.b	29
      0  110b					      dw	E1
      1  110b		       14 11		      .word.w	E1
    256  110d				   E0
      0  110d					      TST	E1A,"+"	;LOOK FOR MORE
      0  110d					      db	32
      1  110d		       20		      .byte.b	32
      0  110e					      db	(E1A-*)-1
      1  110e		       02		      .byte.b	(E1A-*)-1
      0  110f					      db	"+",0
      1  110f		       2b 00		      .byte.b	"+",0
    258  1111				   E1A
      0  1111					      CALL	TERM	;TEST FOR UNARY +
      0  1111					      db	28
      1  1111		       1c		      .byte.b	28
      0  1112					      dw	TERM
      1  1112		       2b 11		      .word.w	TERM
    260  1114				   E1
      0  1114					      TST	E2,"+"	;LEADING TERM
      0  1114					      db	32
      1  1114		       20		      .byte.b	32
      0  1115					      db	(E2-*)-1
      1  1115		       09		      .byte.b	(E2-*)-1
      0  1116					      db	"+",0
      1  1116		       2b 00		      .byte.b	"+",0
      0  1118					      CALL	TERM
      0  1118					      db	28
      1  1118		       1c		      .byte.b	28
      0  1119					      dw	TERM
      1  1119		       2b 11		      .word.w	TERM
      0  111b					      ADD
      0  111b					      db	14
      1  111b		       0e		      .byte.b	14
      0  111c					      IJMP	E1
      0  111c					      db	29
      1  111c		       1d		      .byte.b	29
      0  111d					      dw	E1
      1  111d		       14 11		      .word.w	E1
    265  111f				   E2
      0  111f					      TST	E3,"-"	;ANY MORE?
      0  111f					      db	32
      1  111f		       20		      .byte.b	32
      0  1120					      db	(E3-*)-1
      1  1120		       09		      .byte.b	(E3-*)-1
      0  1121					      db	"-",0
      1  1121		       2d 00		      .byte.b	"-",0
      0  1123					      CALL	TERM	;DIFFERENCE TERM
      0  1123					      db	28
      1  1123		       1c		      .byte.b	28
      0  1124					      dw	TERM
      1  1124		       2b 11		      .word.w	TERM
      0  1126					      SUB
      0  1126					      db	15
      1  1126		       0f		      .byte.b	15
      0  1127					      IJMP	E1
      0  1127					      db	29
      1  1127		       1d		      .byte.b	29
      0  1128					      dw	E1
      1  1128		       14 11		      .word.w	E1
    270  112a				   E3
    271  112a				   T2
      0  112a					      RTN		;ANY MORE?
      0  112a					      db	25
      1  112a		       19		      .byte.b	25
    273  112b				   TERM
      0  112b					      CALL	FACT
      0  112b					      db	28
      1  112b		       1c		      .byte.b	28
      0  112c					      dw	FACT
      1  112c		       47 11		      .word.w	FACT
    275  112e				   T0
      0  112e					      TST	T1,"*"
      0  112e					      db	32
      1  112e		       20		      .byte.b	32
      0  112f					      db	(T1-*)-1
      1  112f		       09		      .byte.b	(T1-*)-1
      0  1130					      db	"*",0
      1  1130		       2a 00		      .byte.b	"*",0
      0  1132					      CALL	FACT	;PRODUCT FACTOR.
      0  1132					      db	28
      1  1132		       1c		      .byte.b	28
      0  1133					      dw	FACT
      1  1133		       47 11		      .word.w	FACT
      0  1135					      MUL
      0  1135					      db	17
      1  1135		       11		      .byte.b	17
      0  1136					      IJMP	T0
      0  1136					      db	29
      1  1136		       1d		      .byte.b	29
      0  1137					      dw	T0
      1  1137		       2e 11		      .word.w	T0
    280  1139				   T1
      0  1139					      TST	T2,"/"
      0  1139					      db	32
      1  1139		       20		      .byte.b	32
      0  113a					      db	(T2-*)-1
      1  113a		       ef		      .byte.b	(T2-*)-1
      0  113b					      db	"/",0
      1  113b		       2f 00		      .byte.b	"/",0
      0  113d					      CALL	FACT	;QUOTIENT FACTOR.
      0  113d					      db	28
      1  113d		       1c		      .byte.b	28
      0  113e					      dw	FACT
      1  113e		       47 11		      .word.w	FACT
      0  1140					      DIV
      0  1140					      db	18
      1  1140		       12		      .byte.b	18
      0  1141					      IJMP	T0
      0  1141					      db	29
      1  1141		       1d		      .byte.b	29
      0  1142					      dw	T0
      1  1142		       2e 11		      .word.w	T0
    285  1144
    286  1144				   UNKNOWNVEC
      0  1144					      IJMP	UNKNOWN
      0  1144					      db	29
      1  1144		       1d		      .byte.b	29
      0  1145					      dw	UNKNOWN
      1  1145		       ff 10		      .word.w	UNKNOWN
    288  1147
    289  1147							;
    290  1147							; Factor an expression.  Always test for functions
    291  1147							; first or else they'll be confused for variables.
    292  1147							;
    293  1147				   FACT
      0  1147					      TST	F1A,"FREE()"
      0  1147					      db	32
      1  1147		       20		      .byte.b	32
      0  1148					      db	(F1A-*)-1
      1  1148		       09		      .byte.b	(F1A-*)-1
      0  1149					      db	"FREE()",0
      1  1149		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1150					      FREE
      0  1150					      db	36
      1  1150		       24		      .byte.b	36
      0  1151					      RTN
      0  1151					      db	25
      1  1151		       19		      .byte.b	25
    297  1152				   F1A
      0  1152					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1152					      db	32
      1  1152		       20		      .byte.b	32
      0  1153					      db	(F1A2-*)-1
      1  1153		       0a		      .byte.b	(F1A2-*)-1
      0  1154					      db	"GETCH()",0
      1  1154		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  115c					      GETCHAR
      0  115c					      db	51
      1  115c		       33		      .byte.b	51
      0  115d					      RTN
      0  115d					      db	25
      1  115d		       19		      .byte.b	25
    301  115e				   F1A2
      0  115e					      TST	F2A,"PEEK("	;Return a value from memory
      0  115e					      db	32
      1  115e		       20		      .byte.b	32
      0  115f					      db	(F2A-*)-1
      1  115f		       0f		      .byte.b	(F2A-*)-1
      0  1160					      db	"PEEK(",0
      1  1160		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1166					      CALL	EXPR	;Get the address to write to
      0  1166					      db	28
      1  1166		       1c		      .byte.b	28
      0  1167					      dw	EXPR
      1  1167		       02 11		      .word.w	EXPR
      0  1169					      TST	UNKNOWN,")"	;Closing bracket
      0  1169					      db	32
      1  1169		       20		      .byte.b	32
      0  116a					      db	(UNKNOWN-*)-1
      1  116a		       94		      .byte.b	(UNKNOWN-*)-1
      0  116b					      db	")",0
      1  116b		       29 00		      .byte.b	")",0
      0  116d					      PEEKMEM
      0  116d					      db	48
      1  116d		       30		      .byte.b	48
      0  116e					      RTN
      0  116e					      db	25
      1  116e		       19		      .byte.b	25
    307  116f							;
    308  116f							; RND() is supposed to have an argument but if none
    309  116f							; was provided, just assume a large value.
    310  116f							;
    311  116f				   F2A
      0  116f					      TST	F2B,"RND("
      0  116f					      db	32
      1  116f		       20		      .byte.b	32
      0  1170					      db	(F2B-*)-1
      1  1170		       17		      .byte.b	(F2B-*)-1
      0  1171					      db	"RND(",0
      1  1171		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1176					      TST	F2A1,")"
      0  1176					      db	32
      1  1176		       20		      .byte.b	32
      0  1177					      db	(F2A1-*)-1
      1  1177		       07		      .byte.b	(F2A1-*)-1
      0  1178					      db	")",0
      1  1178		       29 00		      .byte.b	")",0
      0  117a					      LIT	32766
      0  117a					      db	27
      1  117a		       1b		      .byte.b	27
      0  117b					      dw	32766
      1  117b		       fe 7f		      .word.w	32766
      0  117d					      RANDOM
      0  117d					      db	37
      1  117d		       25		      .byte.b	37
      0  117e					      RTN
      0  117e					      db	25
      1  117e		       19		      .byte.b	25
    317  117f				   F2A1
      0  117f					      CALL	FACT	;GET RANGE
      0  117f					      db	28
      1  117f		       1c		      .byte.b	28
      0  1180					      dw	FACT
      1  1180		       47 11		      .word.w	FACT
      0  1182					      TST	UNKNOWN,")"
      0  1182					      db	32
      1  1182		       20		      .byte.b	32
      0  1183					      db	(UNKNOWN-*)-1
      1  1183		       7b		      .byte.b	(UNKNOWN-*)-1
      0  1184					      db	")",0
      1  1184		       29 00		      .byte.b	")",0
      0  1186					      RANDOM
      0  1186					      db	37
      1  1186		       25		      .byte.b	37
      0  1187					      RTN
      0  1187					      db	25
      1  1187		       19		      .byte.b	25
    322  1188
    323  1188				   F2B
      0  1188					      TST	F2B2,"ABS("
      0  1188					      db	32
      1  1188		       20		      .byte.b	32
      0  1189					      db	(F2B2-*)-1
      1  1189		       0e		      .byte.b	(F2B2-*)-1
      0  118a					      db	"ABS(",0
      1  118a		       41 42 53 28*	      .byte.b	"ABS(",0
      0  118f					      CALL	FACT	;get value
      0  118f					      db	28
      1  118f		       1c		      .byte.b	28
      0  1190					      dw	FACT
      1  1190		       47 11		      .word.w	FACT
      0  1192					      TST	UNKNOWN,")"
      0  1192					      db	32
      1  1192		       20		      .byte.b	32
      0  1193					      db	(UNKNOWN-*)-1
      1  1193		       6b		      .byte.b	(UNKNOWN-*)-1
      0  1194					      db	")",0
      1  1194		       29 00		      .byte.b	")",0
      0  1196					      ABS
      0  1196					      db	38
      1  1196		       26		      .byte.b	38
      0  1197					      RTN
      0  1197					      db	25
      1  1197		       19		      .byte.b	25
    329  1198
    330  1198				   F2B2
      0  1198					      TST	F2C,"CALL("	;call machine function
      0  1198					      db	32
      1  1198		       20		      .byte.b	32
      0  1199					      db	(F2C-*)-1
      1  1199		       1c		      .byte.b	(F2C-*)-1
      0  119a					      db	"CALL(",0
      1  119a		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  11a0					      CALL	EXPR
      0  11a0					      db	28
      1  11a0		       1c		      .byte.b	28
      0  11a1					      dw	EXPR
      1  11a1		       02 11		      .word.w	EXPR
      0  11a3					      TST	F2B2A,COMMA
      0  11a3					      db	32
      1  11a3		       20		      .byte.b	32
      0  11a4					      db	(F2B2A-*)-1
      1  11a4		       0b		      .byte.b	(F2B2A-*)-1
      0  11a5					      db	COMMA,0
      1  11a5		       2c 00		      .byte.b	COMMA,0
      0  11a7					      CALL	EXPR
      0  11a7					      db	28
      1  11a7		       1c		      .byte.b	28
      0  11a8					      dw	EXPR
      1  11a8		       02 11		      .word.w	EXPR
      0  11aa					      TST	UNKNOWN,")"
      0  11aa					      db	32
      1  11aa		       20		      .byte.b	32
      0  11ab					      db	(UNKNOWN-*)-1
      1  11ab		       53		      .byte.b	(UNKNOWN-*)-1
      0  11ac					      db	")",0
      1  11ac		       29 00		      .byte.b	")",0
      0  11ae					      CALLFUNC2
      0  11ae					      db	54
      1  11ae		       36		      .byte.b	54
      0  11af					      RTN
      0  11af					      db	25
      1  11af		       19		      .byte.b	25
    338  11b0
      0  11b0				   F2B2A      TST	UNKNOWN,")"
      0  11b0					      db	32
      1  11b0		       20		      .byte.b	32
      0  11b1					      db	(UNKNOWN-*)-1
      1  11b1		       4d		      .byte.b	(UNKNOWN-*)-1
      0  11b2					      db	")",0
      1  11b2		       29 00		      .byte.b	")",0
      0  11b4					      CALLFUNC
      0  11b4					      db	53
      1  11b4		       35		      .byte.b	53
      0  11b5					      RTN
      0  11b5					      db	25
      1  11b5		       19		      .byte.b	25
    342  11b6				   F2C
      0  11b6					      TSTV	F0
      0  11b6					      db	33
      1  11b6		       21		      .byte.b	33
      0  11b7					      db	(F0-*)-1
      1  11b7		       02		      .byte.b	(F0-*)-1
      0  11b8					      IND		;YES, GET THE VALUE.
      0  11b8					      db	20
      1  11b8		       14		      .byte.b	20
      0  11b9					      RTN
      0  11b9					      db	25
      1  11b9		       19		      .byte.b	25
    346  11ba				   F0
      0  11ba					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  11ba					      db	35
      1  11ba		       23		      .byte.b	35
      0  11bb					      db	(F1-*)-1
      1  11bb		       01		      .byte.b	(F1-*)-1
      0  11bc					      RTN
      0  11bc					      db	25
      1  11bc		       19		      .byte.b	25
    349  11bd				   F1
      0  11bd					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  11bd					      db	32
      1  11bd		       20		      .byte.b	32
      0  11be					      db	(F2A-*)-1
      1  11be		       b0		      .byte.b	(F2A-*)-1
      0  11bf					      db	"(",0
      1  11bf		       28 00		      .byte.b	"(",0
      0  11c1					      CALL	EXPR
      0  11c1					      db	28
      1  11c1		       1c		      .byte.b	28
      0  11c2					      dw	EXPR
      1  11c2		       02 11		      .word.w	EXPR
      0  11c4					      TST	F2,")"
      0  11c4					      db	32
      1  11c4		       20		      .byte.b	32
      0  11c5					      db	(F2-*)-1
      1  11c5		       03		      .byte.b	(F2-*)-1
      0  11c6					      db	")",0
      1  11c6		       29 00		      .byte.b	")",0
      0  11c8					      RTN
      0  11c8					      db	25
      1  11c8		       19		      .byte.b	25
    354  11c9
    355  11c9				   F2
      0  11c9					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  11c9					      db	13
      1  11c9		       0d		      .byte.b	13
      0  11ca					      dw	ERR_SYNTAX
      1  11ca		       05 00		      .word.w	ERR_SYNTAX
    357  11cc
    358  11cc				   RELOP
      0  11cc					      TST	iR0,"="
      0  11cc					      db	32
      1  11cc		       20		      .byte.b	32
      0  11cd					      db	(iR0-*)-1
      1  11cd		       06		      .byte.b	(iR0-*)-1
      0  11ce					      db	"=",0
      1  11ce		       3d 00		      .byte.b	"=",0
      0  11d0					      LIT	2	;=
      0  11d0					      db	27
      1  11d0		       1b		      .byte.b	27
      0  11d1					      dw	2
      1  11d1		       02 00		      .word.w	2
      0  11d3					      RTN
      0  11d3					      db	25
      1  11d3		       19		      .byte.b	25
    362  11d4				   iR0
      0  11d4					      TST	R4,"<"
      0  11d4					      db	32
      1  11d4		       20		      .byte.b	32
      0  11d5					      db	(R4-*)-1
      1  11d5		       16		      .byte.b	(R4-*)-1
      0  11d6					      db	"<",0
      1  11d6		       3c 00		      .byte.b	"<",0
      0  11d8					      TST	iR1,"="
      0  11d8					      db	32
      1  11d8		       20		      .byte.b	32
      0  11d9					      db	(iR1-*)-1
      1  11d9		       06		      .byte.b	(iR1-*)-1
      0  11da					      db	"=",0
      1  11da		       3d 00		      .byte.b	"=",0
      0  11dc					      LIT	3	;<=
      0  11dc					      db	27
      1  11dc		       1b		      .byte.b	27
      0  11dd					      dw	3
      1  11dd		       03 00		      .word.w	3
      0  11df					      RTN
      0  11df					      db	25
      1  11df		       19		      .byte.b	25
    367  11e0				   iR1
      0  11e0					      TST	R3,">"
      0  11e0					      db	32
      1  11e0		       20		      .byte.b	32
      0  11e1					      db	(R3-*)-1
      1  11e1		       06		      .byte.b	(R3-*)-1
      0  11e2					      db	">",0
      1  11e2		       3e 00		      .byte.b	">",0
      0  11e4					      LIT	5	;<>
      0  11e4					      db	27
      1  11e4		       1b		      .byte.b	27
      0  11e5					      dw	5
      1  11e5		       05 00		      .word.w	5
      0  11e7					      RTN
      0  11e7					      db	25
      1  11e7		       19		      .byte.b	25
    371  11e8				   R3
      0  11e8					      LIT	1	;<
      0  11e8					      db	27
      1  11e8		       1b		      .byte.b	27
      0  11e9					      dw	1
      1  11e9		       01 00		      .word.w	1
      0  11eb					      RTN
      0  11eb					      db	25
      1  11eb		       19		      .byte.b	25
    374  11ec				   R4
      0  11ec					      TST	UNKNOWNVEC,">"
      0  11ec					      db	32
      1  11ec		       20		      .byte.b	32
      0  11ed					      db	(UNKNOWNVEC-*)-1
      1  11ed		       56		      .byte.b	(UNKNOWNVEC-*)-1
      0  11ee					      db	">",0
      1  11ee		       3e 00		      .byte.b	">",0
      0  11f0					      TST	R5,"="
      0  11f0					      db	32
      1  11f0		       20		      .byte.b	32
      0  11f1					      db	(R5-*)-1
      1  11f1		       06		      .byte.b	(R5-*)-1
      0  11f2					      db	"=",0
      1  11f2		       3d 00		      .byte.b	"=",0
      0  11f4					      LIT	6	;>=
      0  11f4					      db	27
      1  11f4		       1b		      .byte.b	27
      0  11f5					      dw	6
      1  11f5		       06 00		      .word.w	6
      0  11f7					      RTN
      0  11f7					      db	25
      1  11f7		       19		      .byte.b	25
    379  11f8				   R5
      0  11f8					      TST	R6,"<"
      0  11f8					      db	32
      1  11f8		       20		      .byte.b	32
      0  11f9					      db	(R6-*)-1
      1  11f9		       06		      .byte.b	(R6-*)-1
      0  11fa					      db	"<",0
      1  11fa		       3c 00		      .byte.b	"<",0
      0  11fc					      LIT	1
      0  11fc					      db	27
      1  11fc		       1b		      .byte.b	27
      0  11fd					      dw	1
      1  11fd		       01 00		      .word.w	1
      0  11ff					      RTN		;(This line originally omitted)
      0  11ff					      db	25
      1  11ff		       19		      .byte.b	25
    383  1200				   R6
      0  1200					      LIT	4	;>???
      0  1200					      db	27
      1  1200		       1b		      .byte.b	27
      0  1201					      dw	4
      1  1201		       04 00		      .word.w	4
      0  1203					      RTN
      0  1203					      db	25
      1  1203		       19		      .byte.b	25
    386  1204
    387  1204		       12 04	   ILEND      equ	*
------- FILE mytb.asm
   1726  1204		       12 04	   PROGEND    equ	*
   1727  1204
   1728  1204							;=====================================================
   1729  1204							;=====================================================
   1730  1204							;=====================================================
   1731  1204							; These are storage items not in page zero.
   1732  1204							;
   1733 Udf9e					      seg.u	Data
   1734 U1204					      org	PROGEND
   1735 U1204
   1736 U1204		       00 00 00 00*mathStack  ds	STACKSIZE*2
   1737 U1214		       00	   mathStackPtr ds	1
   1738 U1215		       00 00 00 00*retStack   ds	STACKSIZE*2
   1739 U1225		       00	   retStackPtr ds	1
   1740 U1226							;callStack	ds	GOSUBSTACKSIZE*3
   1741 U1226		       00	   GoSubStackPtr ds	1
   1742 U1227		       00 00 00 00*LINBUF     ds	132
   1743 U12ab		       00	   getlinx    ds	1
   1744 U12ac		       00	   printtx    ds	1	;temp X for print funcs
   1745 U12ad		       00	   diddigit   ds	1	;for leading zero suppression
   1746 U12ae		       00	   putsy      ds	1
   1747 U12af		       00 00	   errGoto    ds	2	;where to set ILPC on err
   1748 U12b1		       00 00	   MQ	      ds	2	;used for some math
   1749 U12b3		       00	   sign       ds	1	;0 = positive, else negative
   1750 U12b4		       00	   rtemp1     ds	1
   1751 U12b5		       00 00	   random     ds	2
   1752 U12b7		       00 00	   BOutVec    ds	2
   1753 U12b9		       00	   tempy      ds	1	;temp y storage
   1754 U12ba				  -	      if	XKIM
   1755 U12ba				  -buffer     ds	BUFFER_SIZE
   1756 U12ba					      endif
   1757 U12ba							;
   1758 U12ba							; PROGRAMEND is the end of the user's BASIC program.
   1759 U12ba							; More precisely, it is one byte past the end.  Or,
   1760 U12ba							; it's where the next line added to the end will be
   1761 U12ba							; placed.
   1762 U12ba							;
   1763 U12ba		       00 00	   PROGRAMEND ds	2
   1764 U12bc		       00 00	   HighMem    ds	2	;highest location
   1765 U12be		       00 00	   UsedMem    ds	2	;size of user program
   1766 U12c0		       00 00	   FreeMem    ds	2	;amount of free memory
   1767 U12c2							;
   1768 U12c2							;=====================================================
   1769 U12c2							; This is the start of the user's BASIC program space.
   1770 U12c2							;
   1771 U12c2							; PERSONAL GOAL: This should be no larger than $0DFF.
   1772 U12c2							;		  0200-05FF = 1K
   1773 U12c2							;		  0200-09FF = 2K
   1774 U12c2							;		  0200-0DFF = 3K
   1775 U12c2							;		  0200-11FF = 4K
   1776 U12c2							;		  0200-13FF = 4.5K
   1777 U12c2							;
   1778 U12c2				  -	      if	FIXED
   1779 U12c2				  -	      org	$2000
   1780 U12c2					      endif
   1781 U12c2		       12 c2	   ProgramStart equ	*
   1782 U12c2							;/*
   1783 U12c2							;	if	CTMON65 || XKIM
   1784 U12c2							;		SEG Code
   1785 U12c2							;		org	AutoRun
   1786 U12c2							;		dw	TBasicCold
   1787 U12c2							;	endif
   1788 U12c2							;*/
   1789 U12c2					      end
