------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2c37				   input      processor	6502
      2 U2c37 ????						;=====================================================
      3 U2c37 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2c37 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2c37 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2c37 ????						;
      7 U2c37 ????						; While working on the Corsham Technologies KIM Clone
      8 U2c37 ????						; project, I wanted to include a TINY BASIC since that
      9 U2c37 ????						; was a highly desirable feature of early computers.
     10 U2c37 ????						;
     11 U2c37 ????						; Rather than negotiating copyright issues for
     12 U2c37 ????						; existing BASICs, I decided to just write one from
     13 U2c37 ????						; scratch.
     14 U2c37 ????						;
     15 U2c37 ????						; 10/07/2017
     16 U2c37 ????						;
     17 U2c37 ????						; This implements a stripped down Tiny BASIC
     18 U2c37 ????						; interpreter using the Interpretive Language (IL)
     19 U2c37 ????						; method as described in the first few issues of
     20 U2c37 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2c37 ????						; to write various languages simply by changing the
     22 U2c37 ????						; IL code rather than the interpreter itself.
     23 U2c37 ????						;
     24 U2c37 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2c37 ????						;		* Fixed major bug in findLine that
     26 U2c37 ????						;		  caused corrupted lines, crashes, etc.
     27 U2c37 ????						;		* If no parameter given to RND, assume
     28 U2c37 ????						;		  32766.
     29 U2c37 ????						;		* No more error 5 when a program
     30 U2c37 ????						;		  reaches the end without an END.
     31 U2c37 ????						;
     32 U2c37 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2c37 ????						;		 * Unexpanded version to play with everything
     34 U2c37 ????						;		 * Add some usefull system level functions
     35 U2c37 ????						;		 * allow a larger number of tiny basic formats
     36 U2c37 ????						;		 * Add byte at start of line holding length
     37 U2c37 ????						;		   for faster execution of goto and gosub
     38 U2c37 ????						;		 * Re-added gosub
     39 U2c37 ????						;		 * allow ; or , at end if print stmt
     40 U2c37 ????						;		   without CRLF being added.
     41 U2c37 ????						;		 * Added extended function erase to
     42 U2c37 ????						;		   use the extended ctmon65 rm file
     43 U2c37 ????						;		 * Fix quoted text to not have to backtrack
     44 U2c37 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2c37 ????						;		 * Add concurrency features
     46 U2c37 ????						;
     47 U2c37 ????						; www.corshamtech.com
     48 U2c37 ????						; bob@corshamtech.com
     49 U2c37 ????						; JustLostInTime@gmail.com
     50 U2c37 ????						;
     51 U2c37 ????						;=====================================================
     52 U2c37 ????						;
     53 U2c37 ????						; Create TRUE and FALSE values for conditionals.
     54 U2c37 ????						;
     55 U2c37 ????
     56 U2c37 ????	       00 00	   FALSE      equ	0
     57 U2c37 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2c37 ????						;
     59 U2c37 ????						;---------------------------------------------------------
     60 U2c37 ????						; One of these must be set to indicate which environment
     61 U2c37 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2c37 ????						; environments:
     63 U2c37 ????						;
     64 U2c37 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2c37 ????						; more K of RAM.
     66 U2c37 ????						;
     67 U2c37 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2c37 ????						; which enhances, without replacing, the standard KIM
     69 U2c37 ????						; monitor.  It gives access to routines to save/load files
     70 U2c37 ????						; to a micro SD card.
     71 U2c37 ????						;
     72 U2c37 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2c37 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2c37 ????						; easily be ported to other systems.  It has support for
     75 U2c37 ????						; using a micro SD card for file storage/retrieval.
     76 U2c37 ????						;
     77 U2c37 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2c37 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2c37 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2c37 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2c37 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2c37 ????						;
     83 U2c37 ????						;   Need to define some macros for the dasm assembler
     84 U2c37 ????						;
     85 U2c37 ????				      MACRO	dw
     86 U2c37 ????				      .word	{0}
     87 U2c37 ????				      ENDM
     88 U2c37 ????
     89 U2c37 ????				      MACRO	db
     90 U2c37 ????				      .byte	{0}
     91 U2c37 ????				      ENDM
     92 U2c37 ????
     93 U2c37 ????						;
     94 U2c37 ????						; If set, include disk functions.
     95 U2c37 ????						;
     96 U2c37 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2c37 ????						;
     98 U2c37 ????						; If ILTRACE is set then dump out the address of every
     99 U2c37 ????						; IL opcode before executing it.
    100 U2c37 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2c37 ????						;
    102 U2c37 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2c37 ????						;
    104 U2c37 ????						; If FIXED is set, put the IL code and the user
    105 U2c37 ????						; program space at fixed locations in memory.	This is
    106 U2c37 ????						; meant only for debugging.
    107 U2c37 ????						;
    108 U2c37 ????	       00 00	   FIXED      equ	FALSE
    109 U2c37 ????						;
    110 U2c37 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2c37 ????						; BASIC, so keep this small!
    112 U2c37 ????						;
    113 U2c37 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2c37 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2c37 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2c37 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2c37 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2c37 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2c37 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2c37 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2c37 ????						;
    122 U2c37 ????						; Gosub entry types
    123 U2c37 ????
    124 U2c37 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2c37 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2c37 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2c37 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2c37 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2c37 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2c37 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2c37 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2c37 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2c37 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2c37 ????						;
    135 U2c37 ????						; Common ASCII constants
    136 U2c37 ????						;
    137 U2c37 ????	       00 07	   BEL	      equ	$07
    138 U2c37 ????	       00 08	   BS	      equ	$08
    139 U2c37 ????	       00 09	   TAB	      equ	$09
    140 U2c37 ????	       00 0a	   LF	      equ	$0A
    141 U2c37 ????	       00 0d	   CR	      equ	$0D
    142 U2c37 ????	       00 22	   quote      equ	$22
    143 U2c37 ????	       00 20	   SPACE      equ	$20
    144 U2c37 ????	       00 2c	   COMMA      equ	',
    145 U2c37 ????	       00 3b	   SEMICOLON  equ	';
    146 U2c37 ????	       00 3a	   COLON      equ	':
    147 U2c37 ????	       00 24	   DOLLAR     equ	'$
    148 U2c37 ????						;
    149 U2c37 ????						; These are error codes
    150 U2c37 ????						;
    151 U2c37 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2c37 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2c37 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2c37 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2c37 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2c37 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2c37 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2c37 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2c37 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2c37 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2c37 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2c37 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2c37 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2c37 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2c37 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2c37 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2c37 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2c37 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2c37 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2c37 ????						;
    171 U2c37 ????						;=====================================================
    172 U2c37 ????						; Zero page storage.
    173 U2c37 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  22bf ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       1a 9a	   CRLF       equ	tbcrlf
    307  0206		       12 88	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       1b e9	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 c9 1b    cold2      jsr	SetOutConsole
    314  0209		       20 d6 1b 	      jsr	SetInConsole
    315  020c		       20 e9 1b 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    319  023c							;
    320  023c		       20 a5 12 	      jsr	MemInit	;setup the free space available
    321  023f
    322  023f		       a9 01	   calcstack  lda	#1
    323  0241		       8d d3 23 	      sta	taskCounter	; Initialize number of tasks to 1
    324  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  0246		       8d d5 22 	      sta	taskTable	; mark the main task as active
    326  0249		       20 92 13 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  024c		       a9 f3		      lda	#IL&$ff
    328  024e		       85 43		      sta	ILPC
    329  0250		       a9 1d		      lda	#IL>>8
    330  0252		       85 44		      sta	ILPC+1
    331  0254							;
    332  0254							;		  lda	  ProgramStart		     ; user prog
    333  0254							;		  sta	  ProgramEnd
    334  0254							;		  lda	  ProgramStart+1
    335  0254							;		  sta	  ProgramEnd+1
    336  0254							;
    337  0254							;  Init time slices defaults
    338  0254		       a9 02		      lda	#TASKCYCLESHIGH
    339  0256		       8d d2 23 	      sta	taskResetValue+1
    340  0259		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  025b		       8d d1 23 	      sta	taskResetValue
    342  025e							;
    343  025e							; Initialize the pseudo-random number sequence...
    344  025e							;
    345  025e		       a9 5a		      lda	#$5a
    346  0260		       8d 1d 2c 	      sta	rtemp1
    347  0263		       a9 9d		      lda	#%10011101
    348  0265		       8d 1f 2c 	      sta	random
    349  0268		       a9 5b		      lda	#%01011011
    350  026a		       8d 20 2c 	      sta	random+1
    351  026d							;
    352  026d							;   Insert a Basic irq handler for the basic Language
    353  026d		       a9 7a		      lda	#ServiceIrq&$ff
    354  026f		       8d 00 df 	      sta	IRQvec
    355  0272		       a9 02		      lda	#ServiceIrq>>8
    356  0274		       8d 01 df 	      sta	IRQvec+1
    357  0277		       4c 9f 02 	      jmp	coldtwo
    358  027a
    359  027a							;
    360  027a							; This is the Basic IRQ handler
    361  027a		       48	   ServiceIrq pha
    362  027b		       ad d0 22 	      lda	IRQStatus
    363  027e		       f0 0a		      BEQ	RetIrq
    364  0280		       ad d1 22 	      lda	IRQPending
    365  0283		       d0 05		      bne	RetIrq
    366  0285		       a9 01		      lda	#1
    367  0287		       8d d1 22 	      sta	IRQPending
    368  028a		       68	   RetIrq     pla
    369  028b		       40		      rti
    370  028c							;
    371  028c							;
    372  028c							; This is the warm start entry point
    373  028c							;
    374  028c		       20 c9 1b    warm2      jsr	SetOutConsole
    375  028f		       20 d6 1b 	      jsr	SetInConsole
    376  0292		       20 9a 1a 	      jsr	CRLF
    377  0295		       ad 1a 2c 	      lda	errGoto
    378  0298		       85 43		      sta	ILPC
    379  029a		       ad 1b 2c 	      lda	errGoto+1
    380  029d		       85 44		      sta	ILPC+1
    381  029f							;
    382  029f							; And continue with both starts here
    383  029f							;
    384  029f				   coldtwo
    385  029f							;
    386  029f							; The ILTrace flag is now run-time settable.
    387  029f							;
    388  029f		       a9 00		      lda	#ILTRACE&$ff
    389  02a1		       85 40		      sta	ILTrace
    390  02a3							;
    391  02a3
    392  02a3		       a9 00		      lda	#0
    393  02a5		       85 5b		      sta	RunMode
    394  02a7		       8d 90 2b 	      sta	LINBUF
    395  02aa
    396  02aa							; Clear everything from the stacks
    397  02aa
    398  02aa		       8d 2b 2c 	      sta	taskIOPending	; No one waiting for io
    399  02ad		       8d 2c 2c 	      sta	taskRDPending	; No one waiting for bg io
    400  02b0
    401  02b0		       20 05 14 	      jsr	taskReset
    402  02b3							;
    403  02b3		       a9 90		      lda	#LINBUF&$ff
    404  02b5		       85 4f		      sta	CURPTR
    405  02b7		       a9 2b		      lda	#LINBUF>>8
    406  02b9		       85 50		      sta	CURPTR+1	;fall through...
    407  02bb
    408  02bb							;=====================================================
    409  02bb							; This is the top of the IL interpreter.  This fetches
    410  02bb							; and executes the instruction currently pointed to
    411  02bb							; by ILPC and adjusts ILPC to point to the next
    412  02bb							; instruction to execute.
    413  02bb							;
    414  02bb		       ce cf 23    NextIL     dec	taskCurrentCycles
    415  02be		       d0 03		      bne	NextIlNow
    416  02c0		       20 2e 14 	      jsr	iTaskSwitch	;check for a task switch
    417  02c3		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02c5		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02c7
    420  02c7		       20 26 1b 	      jsr	dbgLine	;Print the IL trace information
    421  02ca
    422  02ca		       a4 51	   NextIL2    ldy	CUROFF
    423  02cc		       20 91 1a 	      jsr	SkipSpaces
    424  02cf		       84 51		      sty	CUROFF
    425  02d1							;Task IO Management
    426  02d1		       ad 2c 2c 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d4		       f0 08		      beq	NextILStr
    428  02d6		       20 e1 18 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02d9		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02db		       ce 2c 2c 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02de							;
    432  02de		       20 64 17    NextILStr  jsr	getILByte
    433  02e1							;
    434  02e1							; When the handler is called, these are the conditions
    435  02e1							; of several important items:
    436  02e1							;
    437  02e1							;    (ILPC) will point to the byte AFTER the IL
    438  02e1							;    opcode being executed.
    439  02e1							;
    440  02e1							;    (CURPTR),CUROFF will point to the start of the
    441  02e1							;    next word in the input buffer.  Ie, the next word
    442  02e1							;    in the user program.
    443  02e1							;
    444  02e1		       0a		      asl
    445  02e2		       c9 cc		      cmp	#ILTBLend-ILTBL+2
    446  02e4		       90 33		      bcc	ILgood
    447  02e6							;
    448  02e6							; This handles an illegal IL opcode.  This is serious
    449  02e6							; and there's no way to recover.
    450  02e6							;
    451  02e6		       20 e9 1b    ILbad      jsr	puts
      0  02e9					      db	CR,LF
      1  02e9		       0d 0a		      .byte.b	CR,LF
      0  02eb					      db	"Illegal IL "
      1  02eb		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f6					      db	0
      1  02f6		       00		      .byte.b	0
    455  02f7							;
    456  02f7							; Well this is awkward, we need to back up the IL
    457  02f7							; by one since it no longer points to the current
    458  02f7							; opcode.
    459  02f7							;
    460  02f7		       20 71 17 	      jsr	decIL
    461  02fa							;
    462  02fa		       a0 00		      ldy	#0
    463  02fc		       b1 43		      lda	(ILPC),y
    464  02fe		       20 88 12 	      jsr	OUTHEX
    465  0301		       20 e9 1b 	      jsr	puts
      0  0304					      db	" at ",0
      1  0304		       20 61 74 20*	      .byte.b	" at ",0
    467  0309		       a5 44		      lda	ILPC+1
    468  030b		       20 88 12 	      jsr	OUTHEX
    469  030e		       a5 43		      lda	ILPC
    470  0310		       20 88 12 	      jsr	OUTHEX
    471  0313		       20 9a 1a 	      jsr	CRLF
    472  0316		       4c 03 f0 	      jmp	MONITOR
    473  0319							;
    474  0319							; Just jump to the address (ILPC),y.  Have to do
    475  0319							; some goofy stuff.
    476  0319							;
    477  0319		       a8	   ILgood     tay		;move index into Y
    478  031a		       b9 27 03 	      lda	ILTBL,y
    479  031d		       85 59		      sta	dpl
    480  031f		       b9 28 03 	      lda	ILTBL+1,y
    481  0322		       85 5a		      sta	dpl+1
    482  0324		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0327							;
    484  0327							;=====================================================
    485  0327							; This is the IL jump table.  The IL opcode is
    486  0327							; mulitplied by two, then looked-up in this table.
    487  0327							; There is absolutely nothing special about the order
    488  0327							; of entries here... they all decode at exactly the
    489  0327							; same speed.	However the entry number must match the
    490  0327							; values in IL.inc.
    491  0327							;
    492  0327				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0327					      include	"ilvectortable.asm"
      1  0327					      seg	Code
      2  0327
      0  0327					      dw	iXINIT	;0
      1  0327		       29 04		      .word.w	iXINIT
      0  0329					      dw	iDONE	;1
      1  0329		       44 04		      .word.w	iDONE
      0  032b					      dw	iPRS	;2
      1  032b		       60 04		      .word.w	iPRS
      0  032d					      dw	iPRN	;3
      1  032d		       6a 04		      .word.w	iPRN
      0  032f					      dw	iSPC	;4
      1  032f		       73 04		      .word.w	iSPC
      0  0331					      dw	iNLINE	;5
      1  0331		       1c 09		      .word.w	iNLINE
      0  0333					      dw	iNXT	;6
      1  0333		       7b 04		      .word.w	iNXT
      0  0335					      dw	iXFER	;7
      1  0335		       a7 04		      .word.w	iXFER
      0  0337					      dw	iSAV	;8
      1  0337		       d4 04		      .word.w	iSAV
      0  0339					      dw	iRSTR	;9
      1  0339		       17 05		      .word.w	iRSTR
      0  033b					      dw	iCMPR	;10
      1  033b		       4c 05		      .word.w	iCMPR
      0  033d					      dw	iINNUM	;11
      1  033d		       cd 05		      .word.w	iINNUM
      0  033f					      dw	iFIN	;12
      1  033f		       01 06		      .word.w	iFIN
      0  0341					      dw	iERR	;13
      1  0341		       15 06		      .word.w	iERR
      0  0343					      dw	iADD	;14
      1  0343		       85 06		      .word.w	iADD
      0  0345					      dw	iSUB	;15
      1  0345		       9b 06		      .word.w	iSUB
      0  0347					      dw	iNEG	;16
      1  0347		       b1 06		      .word.w	iNEG
      0  0349					      dw	iMUL	;17
      1  0349		       c9 06		      .word.w	iMUL
      0  034b					      dw	iDIV	;18
      1  034b		       09 07		      .word.w	iDIV
      0  034d					      dw	iSTORE	;19
      1  034d		       5f 07		      .word.w	iSTORE
      0  034f					      dw	iIND	;20
      1  034f		       77 07		      .word.w	iIND
      0  0351					      dw	iLST	;21
      1  0351		       e5 07		      .word.w	iLST
      0  0353					      dw	iINIT	;22
      1  0353		       f1 03		      .word.w	iINIT
      0  0355					      dw	iGETLINE	;23
      1  0355		       4a 08		      .word.w	iGETLINE
      0  0357					      dw	iINSRT	;24
      1  0357		       58 08		      .word.w	iINSRT
      0  0359					      dw	iRTN	;25
      1  0359		       16 09		      .word.w	iRTN
      0  035b					      dw	MONITOR	;26
      1  035b		       03 f0		      .word.w	MONITOR
      0  035d					      dw	iLIT	;27
      1  035d		       3c 09		      .word.w	iLIT
      0  035f					      dw	iCALL	;28
      1  035f		       22 09		      .word.w	iCALL
      0  0361					      dw	iJMP	;29
      1  0361		       2a 09		      .word.w	iJMP
      0  0363					      dw	iVINIT	;30
      1  0363		       59 09		      .word.w	iVINIT
      0  0365					      dw	iERRGOTO	;31
      1  0365		       5f 09		      .word.w	iERRGOTO
      0  0367					      dw	iTST	;32
      1  0367		       6b 09		      .word.w	iTST
      0  0369					      dw	iTSTV	;33
      1  0369		       4c 0a		      .word.w	iTSTV
      0  036b					      dw	iTSTL	;34
      1  036b		       cb 0a		      .word.w	iTSTL
      0  036d					      dw	iTSTN	;35
      1  036d		       e6 0a		      .word.w	iTSTN
      0  036f					      dw	iFREE	;36
      1  036f		       63 0b		      .word.w	iFREE
      0  0371					      dw	iRANDOM	;37
      1  0371		       6c 0b		      .word.w	iRANDOM
      0  0373					      dw	iABS	;38
      1  0373		       3d 0c		      .word.w	iABS
     42  0375							;
     43  0375							; Disk functions.  There must be pointers
     44  0375							; to functions even if no disk is supported.
     45  0375							; Makes things easier in IL.inc.
     46  0375							;
     47  0375					      if	DISK_ACCESS
      0  0375					      dw	iOPENREAD	;39
      1  0375		       ce 1c		      .word.w	iOPENREAD
      0  0377					      dw	iOPENWRITE	;40
      1  0377		       22 1d		      .word.w	iOPENWRITE
      0  0379					      dw	iDCLOSE	;41
      1  0379		       a6 1d		      .word.w	iDCLOSE
      0  037b					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037b		       41 1d		      .word.w	iDGETLINE
      0  037d					      dw	iDLIST	;43 Did you remeber your towel?
      1  037d		       a0 1d		      .word.w	iDLIST
      0  037f					      dw	iDDIR	;44
      1  037f		       7b 1d		      .word.w	iDDIR
      0  0381					      dw	iRMFILE	;45
      1  0381		       fc 1c		      .word.w	iRMFILE
     55  0383				  -	      else
     56  0383				  -	      dw	NextIL	;39
     57  0383				  -	      dw	NextIL	;40
     58  0383				  -	      dw	NextIL	;41
     59  0383				  -	      dw	NextIL	;42
     60  0383				  -	      dw	NextIL	;43
     61  0383				  -	      dw	NextIL	;44
     62  0383				  -	      dw	NextIL	;45
     63  0383					      endif
     64  0383							;
      0  0383					      dw	iCLEARSCREEN	;46
      1  0383		       42 1c		      .word.w	iCLEARSCREEN
      0  0385					      dw	iPOKEMEMORY	;47
      1  0385		       ca 0b		      .word.w	iPOKEMEMORY
      0  0387					      dw	iPEEKMEMORY	;48
      1  0387		       df 0b		      .word.w	iPEEKMEMORY
      0  0389					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0389		       b2 09		      .word.w	iTSTLET
      0  038b					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038b		       f0 09		      .word.w	iTSTDONE
      0  038d					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038d		       0c 0c		      .word.w	iGETCHAR
      0  038f					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038f		       20 0c		      .word.w	iPUTCHAR
      0  0391					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0391		       f5 0b		      .word.w	iCallFunc
      0  0393					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0393		       9d 05		      .word.w	iBranch
      0  0395					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0395		       95 09		      .word.w	iTSTStr
      0  0397					      dw	iSetIrq	;56	   sets the irq handler
      1  0397		       ba 0c		      .word.w	iSetIrq
      0  0399					      dw	iTstIrq	;57	   test if irq is pending
      1  0399		       2b 0b		      .word.w	iTstIrq
      0  039b					      dw	iRET	;58	   return from interupt
      1  039b		       05 05		      .word.w	iRET
      0  039d					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039d		       e4 05		      .word.w	iINSTR
      0  039f					      dw	iMOD	;60	   returns remainder of division
      1  039f		       12 07		      .word.w	iMOD
      0  03a1					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a1		       82 14		      .word.w	iTaskSet
      0  03a3					      dw	iETask	;62	   Terminates a task
      1  03a3		       ad 15		      .word.w	iETask
      0  03a5					      dw	iNTask	;63	   goto next task
      1  03a5		       60 15		      .word.w	iNTask
      0  03a7					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a7		       8c 07		      .word.w	iArray
      0  03a9					      dw	iTaskKill	;65	   kill a running task
      1  03a9		       58 15		      .word.w	iTaskKill
      0  03ab					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ab		       2c 15		      .word.w	iTaskStat
      0  03ad					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03ad		       2b 0c		      .word.w	iHexOut
      0  03af					      dw	iReadComplete	;68	   Called after a background read completes
      1  03af		       b9 05		      .word.w	iReadComplete
      0  03b1					      dw	iReadStart	;69	   Called to start a background read request
      1  03b1		       af 05		      .word.w	iReadStart
      0  03b3					      dw	iStartIO	;70	   Lock task until io complete
      1  03b3		       90 15		      .word.w	iStartIO
      0  03b5					      dw	iEndIO	;71	   release task lock for io
      1  03b5		       96 15		      .word.w	iEndIO
      0  03b7					      dw	iLogNot	;72	   Logical not
      1  03b7		       96 0c		      .word.w	iLogNot
      0  03b9					      dw	iLogOr	;73	   Logical Or
      1  03b9		       6c 0c		      .word.w	iLogOr
      0  03bb					      dw	iLogAnd	;74	   Logical And
      1  03bb		       57 0c		      .word.w	iLogAnd
      0  03bd					      dw	iLogXor	;75	   Logical Xor
      1  03bd		       81 0c		      .word.w	iLogXor
      0  03bf					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bf		       6b 15		      .word.w	iWTASK
      0  03c1					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c1		       a1 15		      .word.w	iTASKPID
      0  03c3					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c3		       f6 0c		      .word.w	iTRACEPROG
      0  03c5					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c5		       a7 1a		      .word.w	idbgBasic
      0  03c7					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c7		       63 16		      .word.w	iIPCS
      0  03c9					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c9		       7a 16		      .word.w	iIPCR
      0  03cb					      dw	iIPCC	;82	   Check if any message available for task
      1  03cb		       8e 16		      .word.w	iIPCC
      0  03cd					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cd		       9b 16		      .word.w	iIPCIO
      0  03cf					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cf		       fa 12		      .word.w	iPushMathStack
      0  03d1					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d1		       2a 13		      .word.w	iPopMathStack
      0  03d3					      dw	iSaveMathStack	;86	   Save all math info
      1  03d3		       47 13		      .word.w	iSaveMathStack
      0  03d5					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d5		       66 13		      .word.w	iRestoreMathStack
      0  03d7					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d7		       17 13		      .word.w	iIncParmCount
      0  03d9					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d9		       cd 15		      .word.w	iTaskGetMathStack
      0  03db					      dw	iTaskEnable	;90	   enable a suspended task
      1  03db		       fa 14		      .word.w	iTaskEnable
      0  03dd					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03dd		       14 15		      .word.w	iTaskSuspend
      0  03df					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03df		       e7 15		      .word.w	iTaskPutMathPtr
      0  03e1					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e1		       43 0a		      .word.w	iTSTVT
      0  03e3					      dw	iSetR2	;94
      1  03e3		       34 09		      .word.w	iSetR2
      0  03e5					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e5		       e3 04		      .word.w	iStk2Tmp
      0  03e7					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e7		       f4 04		      .word.w	iTmp2Stk
      0  03e9					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e9		       d1 09		      .word.w	iTSTBYTE
      0  03eb					      dw	iINCVAR	;98	   Increment variable
      1  03eb		       15 0a		      .word.w	iINCVAR
      0  03ed					      dw	iDECVAR	;99	   Decrement variable
      1  03ed		       2d 0a		      .word.w	iDECVAR
      0  03ef					      dw	iSLICE	;100	   set the time slice for tasks
      1  03ef		       f6 15		      .word.w	iSLICE
------- FILE mytb.asm
    494  03ef		       03 f1	   ILTBLend   equ	*
    495  03f1							;
    496  03f1							;=====================================================
    497  03f1							;=====================================================
    498  03f1							;=====================================================
    499  03f1							; This marks the start of the handlers for IL opcodes.
    500  03f1							;=====================================================
    501  03f1							;=====================================================
    502  03f1							;=====================================================
    503  03f1							;
    504  03f1							;
    505  03f1		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03f3		       85 47		      sta	ILSTACKPTR
    507  03f5		       85 4a		      sta	MATHSTACKPTR
    508  03f7		       85 4d		      sta	GOSUBSTACKPTR
    509  03f9		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  03fb		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  03fd							;
    512  03fd		       ad 2d 2c 	      lda	ProgramStart	;user prog
    513  0400		       85 4f		      sta	CURPTR
    514  0402		       8d d6 22 	      sta	taskTable+1
    515  0405		       8d 2f 2c 	      sta	ProgramEnd
    516  0408		       ad 2e 2c 	      lda	ProgramStart+1
    517  040b		       85 50		      sta	CURPTR+1
    518  040d		       8d d7 22 	      sta	taskTable+2
    519  0410		       8d 30 2c 	      sta	ProgramEnd+1
    520  0413		       a9 80		      lda	#TASKACTIVE
    521  0415		       8d d5 22 	      sta	taskTable	;Mark the first slot as active
    522  0418		       a9 01		      lda	#1
    523  041a		       8d d3 23 	      sta	taskCounter	;there is always one task / Main task
    524  041d		       ad d1 23 	      lda	taskResetValue
    525  0420		       8d cf 23 	      sta	taskCurrentCycles	; set up the task switch counts
    526  0423		       ad d2 23 	      lda	taskResetValue+1
    527  0426		       8d d0 23 	      sta	taskCurrentCycles+1
    528  0429							;
    529  0429							; fall into XINIT...
    530  0429							;
    531  0429							;=====================================================
    532  0429							; This initializes for the start of the next line of
    533  0429							; BASIC text.
    534  0429							;
    535  0429		       78	   iXINIT     sei		;ensure interupts are off
    536  042a		       20 05 14 	      jsr	taskReset	;Clear the task table
    537  042d		       8d d1 22 	      sta	IRQPending	; reset the irq pending
    538  0430		       8d d0 22 	      sta	IRQStatus	; Make sure irqs are off
    539  0433
    540  0433		       4c bb 02    goodExit   jmp	NextIL
    541  0436							;
    542  0436							;=====================================================
    543  0436							; This check if the escape key has been entered
    544  0436							; then changes out of run mode. z Set if esc found
    545  0436				   BreakSet
    546  0436		       20 0f f0 	      jsr	ISCHAR
    547  0439		       f0 06		      beq	BreakNo
    548  043b		       20 e6 1b 	      jsr	VGETCH
    549  043e		       c9 1b		      cmp	#$1B
    550  0440		       60		      rts
    551  0441				   BreakNo
    552  0441		       a9 01		      lda	#1
    553  0443		       60		      rts
    554  0444
    555  0444							;
    556  0444
    557  0444							;=====================================================
    558  0444							; Verify there is nothing else on this input line.
    559  0444							; If there is, generate an error.
    560  0444							;
    561  0444		       a4 51	   iDONE      ldy	CUROFF
    562  0446		       20 91 1a 	      jsr	SkipSpaces
    563  0449		       b1 4f		      lda	(CURPTR),y
    564  044b		       f0 10		      beq	doneadv
    565  044d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    566  044f		       d0 05		      bne	idoneErr
    567  0451		       84 51		      sty	CUROFF
    568  0453		       4c bb 02 	      jmp	NextIL	; continue on this line
    569  0456
    570  0456				   idoneErr
    571  0456		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  0458		       a9 00		      lda	#0
    573  045a		       4c 18 06 	      jmp	iErr2
    574  045d							;
    575  045d							; Advance to the next line
    576  045d							;
    577  045d				   doneadv
    578  045d							;		 jsr	 FindNext2
    579  045d		       4c bb 02 	      jmp	NextIL
    580  0460							;
    581  0460							;=====================================================
    582  0460							; Print the string until a closing quote
    583  0460							;
    584  0460		       a4 51	   iPRS       ldy	CUROFF
    585  0462							;
    586  0462							; Odd logic here.  The main loop skipped any leading
    587  0462							; whitespace inside the quoted text, so move back to
    588  0462							; the quote, then move forward again.
    589  0462							;
    590  0462		       20 13 1c 	      jsr	PrtQuoted
    591  0465		       84 51		      sty	CUROFF
    592  0467		       4c bb 02 	      jmp	NextIL
    593  046a							;
    594  046a							;=====================================================
    595  046a							; Pop the top off the stack and print it as a signed
    596  046a							; decimal number.
    597  046a							;
    598  046a		       20 e1 19    iPRN       jsr	popR0
    599  046d		       20 d6 11 	      jsr	PrintDecimal
    600  0470		       4c bb 02 	      jmp	NextIL
    601  0473							;
    602  0473							;=====================================================
    603  0473							; Space to next zone.	Currently the code does not
    604  0473							; keep track of which column the output is on, so
    605  0473							; just print a tab.
    606  0473							;
    607  0473		       a9 09	   iSPC       lda	#TAB
    608  0475		       20 e3 1b 	      jsr	VOUTCH
    609  0478		       4c bb 02 	      jmp	NextIL
    610  047b							;
    611  047b							;=====================================================
    612  047b							; If in immediate mode, jump to the address following
    613  047b							; the NXT instruction.  Else move to the next line of
    614  047b							; user code and continue.
    615  047b							;
    616  047b		       a5 5b	   iNXT       lda	RunMode
    617  047d		       d0 03		      bne	iNxtRun	;in run mode
    618  047f							;
    619  047f							; Get address and jump to it.
    620  047f							;
    621  047f		       4c 2a 09 	      jmp	iJMP
    622  0482							;
    623  0482				   iNxtRun
    624  0482		       a4 51		      ldy	CUROFF
    625  0484		       20 91 1a 	      jsr	SkipSpaces
    626  0487		       b1 4f		      lda	(CURPTR),y
    627  0489		       c9 3a		      cmp	#COLON
    628  048b		       d0 09		      bne	iNxtRunGo
    629  048d		       c8		      iny
    630  048e		       20 91 1a 	      jsr	SkipSpaces
    631  0491		       84 51		      sty	CUROFF
    632  0493		       4c a1 04 	      jmp	iNxtRun2
    633  0496
    634  0496				   iNxtRunGo
    635  0496		       20 ee 17 	      jsr	FindNextLine
    636  0499		       20 02 18 	      jsr	AtEnd
    637  049c		       d0 03		      bne	iNxtRun2	;not at end
    638  049e							;
    639  049e							; At the end of the program.  Pretend an END statement
    640  049e							; was found.
    641  049e							;
    642  049e		       4c 01 06    iFINv      jmp	iFIN
    643  04a1							;
    644  04a1		       20 60 17    iNxtRun2   jsr	getILWord	;ignore next word
    645  04a4		       4c bb 02 	      jmp	NextIL
    646  04a7							;
    647  04a7							;=====================================================
    648  04a7							; XFER takes the number on top of the stack and looks
    649  04a7							; for that line in the program, or the next line
    650  04a7							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04a7							; find the next one after that.
    652  04a7							;
    653  04a7		       20 e1 19    iXFER      jsr	popR0
    654  04aa		       20 a9 17 	      jsr	findLine
    655  04ad		       20 02 18    iXFER2     jsr	AtEnd	;at end of user program?
    656  04b0		       f0 ec		      beq	iFINv
    657  04b2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    658  04b4		       84 51		      sty	CUROFF
    659  04b6		       a9 ff		      lda	#$ff
    660  04b8		       85 5b		      sta	RunMode
    661  04ba							;
    662  04ba							; Transfer IL to STMT.  I don't like having this
    663  04ba							; hard-coded; fix it.
    664  04ba							;
    665  04ba		       a9 01		      lda	#STMT&$ff
    666  04bc		       85 43		      sta	ILPC
    667  04be		       a9 1e		      lda	#STMT>>8
    668  04c0		       85 44		      sta	ILPC+1
    669  04c2		       4c bb 02 	      jmp	NextIL
    670  04c5							;
    671  04c5							; Run
    672  04c5							;
    673  04c5				   iXferok
    674  04c5		       a9 ff		      lda	#$ff
    675  04c7		       85 5b		      sta	RunMode	;we're running
    676  04c9							;
    677  04c9							; Need a more elegant way to do this
    678  04c9							;
    679  04c9		       a9 01		      lda	#STMT&$ff
    680  04cb		       85 43		      sta	ILPC
    681  04cd		       a9 1e		      lda	#STMT>>8
    682  04cf		       85 44		      sta	ILPC+1
    683  04d1		       4c bb 02 	      jmp	NextIL
    684  04d4							;
    685  04d4							;=====================================================
    686  04d4							; Save the pointer to the next line to the call stack.
    687  04d4							;
    688  04d4		       20 77 19    iSAV       jsr	pushLN
    689  04d7		       b0 03		      bcs	iSAVErr
    690  04d9		       4c bb 02 	      jmp	NextIL
    691  04dc
    692  04dc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04de		       a9 00	   iSAVErr2   lda	#0
    694  04e0		       4c 18 06 	      jmp	iErr2
    695  04e3							;====================================================
    696  04e3							; Move stack top to and from temp area
    697  04e3				   iStk2Tmp
    698  04e3		       20 e1 19 	      jsr	popR0
    699  04e6		       a5 52		      lda	R0
    700  04e8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04ea		       91 41		      sta	(VARIABLES),y
    702  04ec		       c8		      iny
    703  04ed		       a5 53		      lda	R0+1
    704  04ef		       91 41		      sta	(VARIABLES),y
    705  04f1		       4c bb 02 	      jmp	NextIL
    706  04f4
    707  04f4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  04f6		       b1 41		      lda	(VARIABLES),y
    709  04f8		       85 52		      sta	R0
    710  04fa		       c8		      iny
    711  04fb		       b1 41		      lda	(VARIABLES),y
    712  04fd		       85 53		      sta	R0+1
    713  04ff		       20 5d 19 	      jsr	pushR0
    714  0502		       4c bb 02 	      jmp	NextIL
    715  0505							;
    716  0505							;=====================================================
    717  0505							; Pop the next line from the call stack.
    718  0505							;
    719  0505		       20 9c 19    iRET       jsr	popLN
    720  0508		       b0 d2		      bcs	iSAVErr
    721  050a		       a0 03		      ldy	#3
    722  050c		       84 51		      sty	CUROFF
    723  050e		       a9 00		      lda	#0
    724  0510		       8d d1 22 	      sta	IRQPending
    725  0513		       58		      cli
    726  0514		       4c bb 02 	      jmp	NextIL
    727  0517							;
    728  0517							;=====================================================
    729  0517							; Return from GOSUB function
    730  0517							;
    731  0517		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    732  0519		       f0 0f		      beq	iRSTRNoValue
    733  051b		       a5 58		      lda	R2
    734  051d		       85 56		      sta	MQ
    735  051f		       88		      dey
    736  0520		       b1 4b		      lda	(GOSUBSTACK),y
    737  0522		       c9 81		      cmp	#GOSUB_RTN_VALUE
    738  0524		       d0 04		      bne	iRSTRNoValue
    739  0526		       a9 01		      lda	#1
    740  0528		       d0 02		      bne	iRSTRExit
    741  052a				   iRSTRNoValue
    742  052a		       a9 00		      lda	#0
    743  052c				   iRSTRExit
    744  052c		       85 58		      sta	R2
    745  052e		       20 9c 19 	      jsr	popLN
    746  0531		       b0 06		      bcs	iRSTRErr
    747  0533		       20 30 13 	      jsr	PopMathStackNow
    748  0536		       4c bb 02 	      jmp	NextIL
    749  0539
    750  0539		       ad d4 22    iRSTRErr   lda	taskPtr	; Check if this is task zero
    751  053c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    752  053e		       a5 56		      lda	MQ
    753  0540		       d0 03		      bne	taskRet
    754  0542		       20 57 1c 	      jsr	pushFalse	; the result code by default is 0
    755  0545				   taskRet
    756  0545		       4c ad 15 	      jmp	iETask	; not task zero then do a task end instead
    757  0548				   taskZeroEnd
    758  0548		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    759  054a		       d0 92		      bne	iSAVErr2
    760  054c							;
    761  054c							;=====================================================
    762  054c							; Compare items on stack.  Okay, so on input there are
    763  054c							; three things on the stack
    764  054c							;
    765  054c							;    EXPR2 <- Top of stack
    766  054c							;    OP    <- relational operator, next on stack
    767  054c							;    EXPR1 <- last item on stack
    768  054c							;
    769  054c							; Comparison is: EXPR1 <operator> EXPR2
    770  054c							;
    771  054c							; Operator is one of...
    772  054c							;
    773  054c							;    2 is =
    774  054c							;    1 is <
    775  054c							;    3 is <=
    776  054c							;    5 is <>
    777  054c							;    4 is >
    778  054c							;    6 is >=
    779  054c							;
    780  054c							; Those are bit-mapped:
    781  054c							;
    782  054c							;    xxxxxGEL
    783  054c							;
    784  054c							;    G = Greater than
    785  054c							;    E = Equal
    786  054c							;    L = Less than
    787  054c							;
    788  054c							; If the comparison is false, do a NXT, ie, move to the
    789  054c							; next line and continue.  If true, continue executing
    790  054c							; on this line.
    791  054c							;
    792  054c		       00 01	   REL_LT     equ	%001
    793  054c		       00 02	   REL_EQUAL  equ	%010
    794  054c		       00 04	   REL_GT     equ	%100
    795  054c							;
    796  054c		       20 f9 19    iCMPR      jsr	popR1
    797  054f		       20 10 1a 	      jsr	popMQ	;operator in MQ
    798  0552		       20 e1 19 	      jsr	popR0
    799  0555		       20 5e 05 	      jsr	iCMPRsub
    800  0558		       20 5d 19 	      jsr	pushR0
    801  055b		       4c bb 02 	      jmp	NextIL
    802  055e							;
    803  055e							; See if they are equal or not
    804  055e							;
    805  055e				   iCMPRsub		; Called by internal functions
    806  055e
    807  055e		       a5 52		      lda	R0
    808  0560		       c5 54		      cmp	R1
    809  0562		       d0 0a		      bne	iCMPRnoteq	;try not equal
    810  0564		       a5 53		      lda	R0+1
    811  0566		       c5 55		      cmp	R1+1
    812  0568		       d0 04		      bne	iCMPRnoteq
    813  056a							;
    814  056a							; Equal, set the flag in MQ+1
    815  056a							;
    816  056a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    817  056c		       d0 14		      bne	iCMPcom	;Exit it is equal
    818  056e							;
    819  056e							; See if EXPR1 (R0) < EXPR2 (R1)
    820  056e							; See www.6502.org/tutorials/compare_beyond.html
    821  056e							;
    822  056e				   iCMPRnoteq
    823  056e		       a5 52		      lda	R0
    824  0570		       c5 54		      cmp	R1
    825  0572		       a5 53		      lda	R0+1
    826  0574		       e5 55		      sbc	R1+1
    827  0576		       50 02		      bvc	iCMPR_2
    828  0578		       49 80		      eor	#$80
    829  057a		       30 04	   iCMPR_2    bmi	iCMPlt
    830  057c		       a9 04		      lda	#REL_GT
    831  057e		       d0 02		      bne	iCMPcom
    832  0580		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    833  0582
    834  0582		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    835  0584							;
    836  0584							; Now compare the end result with what the caller
    837  0584							; was looking for.
    838  0584							;
    839  0584		       25 56		      and	MQ
    840  0586		       f0 0c		      beq	iCMPno	; no match
    841  0588		       a9 ff		      lda	#$FF	; true is $ffff
    842  058a		       85 52		      sta	R0
    843  058c		       85 53		      sta	R0+1
    844  058e		       d0 0c		      bne	iCMPDone
    845  0590							;
    846  0590							; R0 > R1
    847  0590							;
    848  0590		       a9 04	   iCMPgt     lda	#REL_GT
    849  0592		       d0 ee		      bne	iCMPcom
    850  0594				   iCMPno
    851  0594		       a9 00		      lda	#0
    852  0596		       85 52		      sta	R0
    853  0598		       a9 00		      lda	#0
    854  059a		       85 53		      sta	R0+1
    855  059c
    856  059c				   iCMPDone
    857  059c		       60		      rts
    858  059d
    859  059d							;
    860  059d							; if Not a match, so jump to the next line of code.
    861  059d							; Branches based upon value on top of the stack
    862  059d				   iBranch
    863  059d		       20 e1 19 	      jsr	popR0
    864  05a0		       a5 52		      lda	R0
    865  05a2		       05 53		      ora	R0+1
    866  05a4		       f0 03		      beq	iBranchFalse	; not true
    867  05a6		       4c bb 02 	      jmp	NextIL	; It is true if any value not zero
    868  05a9							;
    869  05a9				   iBranchFalse
    870  05a9		       20 ee 17 	      jsr	FindNextLine
    871  05ac		       4c ad 04 	      jmp	iXFER2
    872  05af							;
    873  05af							;=====================================================
    874  05af							; Start a read of data in background
    875  05af				   iReadStart
    876  05af		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05b1		       a6 01		      ldx	1	; Indicate to start read in background
    878  05b3		       20 7a 18 	      jsr	GetLine	; Call the getline to start read
    879  05b6		       4c bb 02 	      jmp	NextIL	; next instruction
    880  05b9							;
    881  05b9							;=====================================================
    882  05b9							; Complete the read and return the curptr, curoff pointing to data
    883  05b9				   iReadComplete
    884  05b9		       20 77 19 	      jsr	pushLN
    885  05bc		       90 03		      bcc	iReadOk
    886  05be		       4c 5c 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    887  05c1				   iReadOk
    888  05c1		       20 9a 18 	      jsr	ReadComplete
    889  05c4		       4c bb 02 	      jmp	NextIL
    890  05c7		       20 9c 19 	      jsr	popLN
    891  05ca		       4c bb 02 	      jmp	NextIL
    892  05cd							;=====================================================
    893  05cd							; Get a line of text from the user, convert to a
    894  05cd							; number, leave on top of stack.
    895  05cd							;
    896  05cd				   iINNUM
    897  05cd		       20 77 19 	      jsr	pushLN
    898  05d0		       b0 ec		      bcs	iReadErr	; Stack over flow error
    899  05d2							;
    900  05d2		       a9 3f		      lda	#'?
    901  05d4		       a2 00		      ldx	#0	;Wait for complete
    902  05d6		       20 7a 18 	      jsr	GetLine
    903  05d9		       20 0f 18 	      jsr	getDecimal
    904  05dc		       20 5d 19 	      jsr	pushR0	;put onto stack
    905  05df		       b0 dd		      bcs	iReadErr	;StackOverflow error
    906  05e1							;
    907  05e1		       4c fb 05 	      jmp	ExitIn
    908  05e4							;
    909  05e4							;=====================================================
    910  05e4							; Get a line of text from the user, convert to a
    911  05e4							; character value , leave on top of stack. up to 2 characters
    912  05e4							;
    913  05e4				   iINSTR
    914  05e4		       20 77 19 	      jsr	pushLN
    915  05e7		       b0 d5		      bcs	iReadErr	; Stack overflow error
    916  05e9		       a9 3f		      lda	#'?
    917  05eb		       a2 00		      ldx	#0	;wait for read complete
    918  05ed		       20 7a 18 	      jsr	GetLine
    919  05f0		       b1 4f		      lda	(CURPTR),y
    920  05f2		       85 52		      sta	R0
    921  05f4		       a9 00		      lda	#0
    922  05f6		       85 53		      sta	R0+1
    923  05f8		       20 5d 19 	      jsr	pushR0	;put onto stack
    924  05fb				   ExitIn
    925  05fb		       20 9c 19 	      jsr	popLN
    926  05fe		       4c bb 02 	      jmp	NextIL
    927  0601							;
    928  0601							;
    929  0601							;=====================================================
    930  0601							; Stop the currently running program.	Actually very
    931  0601							; simple to do... clear the RunMode flag, then set the
    932  0601							; ILPC to the standard handler and continue running.
    933  0601							;
    934  0601		       a9 00	   iFIN       lda	#0
    935  0603		       85 5b		      sta	RunMode
    936  0605		       20 05 14 	      jsr	taskReset
    937  0608							;
    938  0608		       ad 1a 2c 	      lda	errGoto
    939  060b		       85 43		      sta	ILPC
    940  060d		       ad 1b 2c 	      lda	errGoto+1
    941  0610		       85 44		      sta	ILPC+1
    942  0612		       4c bb 02 	      jmp	NextIL
    943  0615							;
    944  0615							;=====================================================
    945  0615							; Handle the ERR opcode.  Following the instruction is
    946  0615							; a 16 bit error number.  Print an error message, and
    947  0615							; if we're in run mode, print the line number.  Stop
    948  0615							; program execution and return to the initial state.
    949  0615							;
    950  0615		       20 60 17    iERR       jsr	getILWord	;get err code
    951  0618							;
    952  0618							; Enter here with the error code in X (LSB) and A (MSB).
    953  0618							;
    954  0618		       86 52	   iErr2      stx	R0
    955  061a		       85 53		      sta	R0+1
    956  061c							;
    957  061c		       20 e9 1b 	      jsr	puts
      0  061f					      db	CR,LF,"Error ",0
      1  061f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    959  0628		       20 d6 11 	      jsr	PrintDecimal
    960  062b							;
    961  062b		       a5 5b		      lda	RunMode	;running?
    962  062d		       f0 3b		      beq	iERR3	;nope
    963  062f		       20 e9 1b 	      jsr	puts
      0  0632					      db	" at line ",0
      1  0632		       20 61 74 20*	      .byte.b	" at line ",0
    965  063c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    966  063e				   iErr2a
    967  063e		       b1 4f		      lda	(CURPTR),y
    968  0640		       85 52		      sta	R0
    969  0642		       c8		      iny
    970  0643		       b1 4f		      lda	(CURPTR),y
    971  0645		       85 53		      sta	R0+1
    972  0647		       20 d6 11 	      jsr	PrintDecimal
    973  064a		       20 e9 1b 	      jsr	puts
      0  064d					      db	":",0
      1  064d		       3a 00		      .byte.b	":",0
    975  064f		       a9 00		      lda	#0
    976  0651		       85 53		      sta	R0+1
    977  0653		       a5 51		      lda	CUROFF
    978  0655		       18		      clc
    979  0656		       e9 03		      sbc	#3
    980  0658		       85 52		      sta	R0
    981  065a		       20 d6 11 	      jsr	PrintDecimal
    982  065d		       20 e9 1b 	      jsr	puts
      0  0660					      db	":",0
      1  0660		       3a 00		      .byte.b	":",0
    984  0662		       ad d4 22 	      lda	taskPtr
    985  0665		       85 52		      sta	R0
    986  0667		       20 d6 11 	      jsr	PrintDecimal
    987  066a							;
    988  066a		       20 9a 1a    iERR3      jsr	CRLF
    989  066d		       20 fd 13 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    990  0670		       a9 00		      lda	#0
    991  0672		       85 5b		      sta	RunMode	;fall through...
    992  0674							;
    993  0674							;=====================================================
    994  0674							; Reset the IL to be back at the idle loop.  Does not
    995  0674							; clear variables so the user can see what state
    996  0674							; the program is in.
    997  0674							;
    998  0674		       a9 00	   ResetIL    lda	#0
    999  0676		       85 47		      sta	ILSTACKPTR
   1000  0678		       ad 1a 2c 	      lda	errGoto
   1001  067b		       85 43		      sta	ILPC
   1002  067d		       ad 1b 2c 	      lda	errGoto+1
   1003  0680		       85 44		      sta	ILPC+1
   1004  0682		       4c bb 02 	      jmp	NextIL
   1005  0685
   1006  0685							;
   1007  0685							;=====================================================
   1008  0685							; Pop two items off stack, add them, then place the
   1009  0685							; result back onto the stack.
   1010  0685							;
   1011  0685		       20 e1 19    iADD       jsr	popR0
   1012  0688		       20 f9 19 	      jsr	popR1
   1013  068b				   iADDfast
   1014  068b		       18		      clc
   1015  068c		       a5 52		      lda	R0
   1016  068e		       65 54		      adc	R1
   1017  0690		       85 52		      sta	R0
   1018  0692		       a5 53		      lda	R0+1
   1019  0694		       65 55		      adc	R1+1
   1020  0696		       85 53		      sta	R0+1
   1021  0698		       4c 03 07 	      jmp	pushR0nextIl
   1022  069b							;
   1023  069b							;=====================================================
   1024  069b							; Pop two items off the stack.  Subtract the top of
   1025  069b							; stack from the lower entry.
   1026  069b							;
   1027  069b		       20 f9 19    iSUB       jsr	popR1
   1028  069e		       20 e1 19 	      jsr	popR0
   1029  06a1		       38		      sec
   1030  06a2		       a5 52		      lda	R0
   1031  06a4		       e5 54		      sbc	R1
   1032  06a6		       85 52		      sta	R0
   1033  06a8		       a5 53		      lda	R0+1
   1034  06aa		       e5 55		      sbc	R1+1
   1035  06ac		       85 53		      sta	R0+1
   1036  06ae		       4c 03 07 	      jmp	pushR0nextIl
   1037  06b1							;
   1038  06b1							;=====================================================
   1039  06b1							; Negate the top of stack.
   1040  06b1							;
   1041  06b1		       20 e1 19    iNEG       jsr	popR0
   1042  06b4		       a5 52		      lda	R0
   1043  06b6		       49 ff		      eor	#$ff
   1044  06b8		       85 52		      sta	R0
   1045  06ba		       a5 53		      lda	R0+1
   1046  06bc		       49 ff		      eor	#$ff
   1047  06be		       85 53		      sta	R0+1
   1048  06c0		       e6 52		      inc	R0
   1049  06c2		       d0 02		      bne	iNEG2
   1050  06c4		       e6 53		      inc	R0+1
   1051  06c6		       4c 03 07    iNEG2      jmp	pushR0nextIl
   1052  06c9							;
   1053  06c9							;=====================================================
   1054  06c9							; Multiply top two items on the stack, put the results
   1055  06c9							; on top.  This uses the algorithm documented on page
   1056  06c9							; 115 of "Microprocessor Programming for Computer
   1057  06c9							; Hobbyists" by Neill Graham.
   1058  06c9							;
   1059  06c9		       20 cf 06    iMUL       jsr	iMultiply
   1060  06cc		       4c bb 02 	      jmp	NextIL
   1061  06cf
   1062  06cf				   iMultiply
   1063  06cf		       20 e1 19 	      jsr	popR0	;AC
   1064  06d2		       20 f9 19 	      jsr	popR1	;OP
   1065  06d5							;
   1066  06d5		       a5 52		      lda	R0
   1067  06d7		       85 56		      sta	MQ
   1068  06d9		       a5 53		      lda	R0+1
   1069  06db		       85 57		      sta	MQ+1
   1070  06dd		       a9 00		      lda	#0	;clear result
   1071  06df		       85 52		      sta	R0
   1072  06e1		       85 53		      sta	R0+1
   1073  06e3							;
   1074  06e3		       a2 10		      ldx	#16	;number of bits in value
   1075  06e5		       06 52	   multloop   asl	R0
   1076  06e7		       26 53		      rol	R0+1
   1077  06e9		       06 56		      asl	MQ
   1078  06eb		       26 57		      rol	MQ+1
   1079  06ed		       90 0d		      bcc	multno	;skip add if no carry
   1080  06ef							;
   1081  06ef							; Add R1 back into R0
   1082  06ef							;
   1083  06ef		       18		      clc
   1084  06f0		       a5 52		      lda	R0
   1085  06f2		       65 54		      adc	R1
   1086  06f4		       85 52		      sta	R0
   1087  06f6		       a5 53		      lda	R0+1
   1088  06f8		       65 55		      adc	R1+1
   1089  06fa		       85 53		      sta	R0+1
   1090  06fc							;
   1091  06fc		       ca	   multno     dex		;did all bits yet?
   1092  06fd		       d0 e6		      bne	multloop
   1093  06ff		       20 5d 19 	      jsr	pushR0	;OP
   1094  0702		       60		      rts
   1095  0703							;
   1096  0703				   pushR0nextIl
   1097  0703		       20 5d 19 	      jsr	pushR0	;OP
   1098  0706		       4c bb 02 	      jmp	NextIL
   1099  0709							;
   1100  0709							;=====================================================
   1101  0709							; Divide the top of stack into the next to top item.
   1102  0709							; Leave results on stack.  Taken from:
   1103  0709							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1104  0709							;
   1105  0709							; R0 = R0 / R1
   1106  0709							; Remainder is in MQ
   1107  0709							;
   1108  0709		       20 23 07    iDIV       jsr	iDoDiv
   1109  070c		       20 62 1a 	      jsr	RestoreSigns
   1110  070f		       4c 03 07 	      jmp	pushR0nextIl
   1111  0712
   1112  0712		       20 23 07    iMOD       jsr	iDoDiv
   1113  0715		       20 62 1a 	      jsr	RestoreSigns
   1114  0718		       a5 56		      lda	MQ
   1115  071a		       85 52		      sta	R0
   1116  071c		       a5 57		      lda	MQ+1
   1117  071e		       85 53		      sta	R0+1
   1118  0720		       4c 03 07 	      jmp	pushR0nextIl
   1119  0723
   1120  0723				   iDoDiv
   1121  0723		       20 f9 19 	      jsr	popR1
   1122  0726		       20 e1 19 	      jsr	popR0
   1123  0729							;
   1124  0729							; Check for divide by zero
   1125  0729							;
   1126  0729
   1127  0729				   iDivNoPop
   1128  0729		       a5 54		      lda	R1
   1129  072b		       05 55		      ora	R1+1
   1130  072d		       f0 29		      beq	divby0
   1131  072f							;
   1132  072f		       20 27 1a 	      jsr	SaveSigns
   1133  0732		       a9 00		      lda	#0	;preset remainder to 0
   1134  0734		       85 56		      sta	MQ
   1135  0736		       85 57		      sta	MQ+1
   1136  0738		       a2 10		      ldx	#16	;repeat for each bit: ...
   1137  073a				   divloop
   1138  073a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1139  073c		       26 53		      rol	R0+1
   1140  073e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1141  0740		       26 57		      rol	MQ+1
   1142  0742		       a5 56		      lda	MQ
   1143  0744		       38		      sec
   1144  0745		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1145  0747		       a8		      tay		;lb result -> Y, for we may need it later
   1146  0748		       a5 57		      lda	MQ+1
   1147  074a		       e5 55		      sbc	R1+1
   1148  074c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1149  074e
   1150  074e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1151  0750		       84 56		      sty	MQ
   1152  0752		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1153  0754
   1154  0754		       ca	   skip       dex
   1155  0755		       d0 e3		      bne	divloop
   1156  0757		       60		      rts
   1157  0758							;
   1158  0758							; Indicate divide-by-zero error
   1159  0758							;
   1160  0758		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1161  075a		       a9 00		      lda	#0
   1162  075c		       4c 18 06 	      jmp	iErr2
   1163  075f							;
   1164  075f							;=====================================================
   1165  075f							; This pops the top two items off the stack.  The top
   1166  075f							; item is a data value and the other is an ABSOLUTE address.
   1167  075f							;Save the value into that address.
   1168  075f							;
   1169  075f		       98	   iSTORE     tya
   1170  0760		       48		      pha
   1171  0761		       20 e1 19 	      jsr	popR0	;data
   1172  0764		       20 f9 19 	      jsr	popR1	;Storage location
   1173  0767		       a0 00		      ldy	#0
   1174  0769		       a5 52		      lda	R0
   1175  076b		       91 54		      sta	(R1),y
   1176  076d		       a5 53		      lda	R0+1
   1177  076f		       c8		      iny
   1178  0770		       91 54		      sta	(R1),y
   1179  0772		       68		      pla
   1180  0773		       a8		      tay
   1181  0774		       4c bb 02 	      jmp	NextIL
   1182  0777							;
   1183  0777							;=====================================================
   1184  0777							; Replaces the top of stack with the variable whose
   1185  0777							; absolute address it represents.
   1186  0777							;
   1187  0777		       98	   iIND       tya
   1188  0778		       48		      pha
   1189  0779		       20 f9 19 	      jsr	popR1
   1190  077c		       a0 00		      ldy	#0
   1191  077e		       b1 54		      lda	(R1),y
   1192  0780		       85 52		      sta	R0
   1193  0782		       c8		      iny
   1194  0783		       b1 54		      lda	(R1),y
   1195  0785		       85 53		      sta	R0+1
   1196  0787		       68		      pla
   1197  0788		       a8		      tay
   1198  0789		       4c 03 07 	      jmp	pushR0nextIl
   1199  078c							;
   1200  078c							;=====================================================
   1201  078c							; Get the array index from top of stack get Current variable
   1202  078c							; address from next on stack, add the offset
   1203  078c							; push the result back onto the stack
   1204  078c				   iArray
   1205  078c		       20 e1 19 	      jsr	popR0	; Get the array index
   1206  078f		       20 f9 19 	      jsr	popR1	; Get the Variable address
   1207  0792
   1208  0792		       18		      clc		; Multiplythe value by 2
   1209  0793		       26 52		      rol	R0	; Do the multiply
   1210  0795		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1211  0797		       18		      clc
   1212  0798		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1213  079a		       65 52		      adc	R0
   1214  079c		       85 52		      sta	R0
   1215  079e		       a5 55		      lda	R1+1
   1216  07a0		       65 53		      adc	R0+1
   1217  07a2		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1218  07a4		       20 5d 19 	      jsr	pushR0	; Push R0 assume it is correct
   1219  07a7
   1220  07a7		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1221  07a9		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1222  07ab		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1223  07ad		       a5 55		      lda	R1+1
   1224  07af		       c5 42		      cmp	VARIABLES+1
   1225  07b1		       d0 1c		      bne	iArrayAtTest
   1226  07b3		       18		      clc
   1227  07b4		       a9 34		      lda	#52	; add the max offset that is valid
   1228  07b6		       65 54		      adc	R1	; update to be the largest offset that is valid
   1229  07b8		       85 54		      sta	R1
   1230  07ba		       a9 00		      lda	#0
   1231  07bc		       65 55		      adc	R1+1
   1232  07be		       85 55		      sta	R1+1
   1233  07c0				   iArrayVerify 		; try to enforce some sanity to using arrays
   1234  07c0		       a5 53		      lda	R0+1
   1235  07c2		       c5 55		      cmp	R1+1
   1236  07c4		       d0 04		      bne	iArrayDecide
   1237  07c6		       a5 52		      lda	R0
   1238  07c8		       c5 54		      cmp	R1
   1239  07ca				   iArrayDecide
   1240  07ca		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1241  07cc		       4c bb 02 	      jmp	NextIL
   1242  07cf
   1243  07cf				   iArrayAtTest
   1244  07cf		       ad 31 2c 	      lda	HighMem
   1245  07d2		       85 54		      sta	R1
   1246  07d4		       ad 32 2c 	      lda	HighMem+1
   1247  07d7		       85 55		      sta	R1+1
   1248  07d9		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1249  07db
   1250  07db							; Get here if array index is out of range
   1251  07db		       20 e1 19    iArrayError jsr	popR0
   1252  07de		       a9 00		      lda	#0
   1253  07e0		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1254  07e2		       4c 18 06 	      jmp	iErr2
   1255  07e5							;
   1256  07e5							;=====================================================
   1257  07e5							; List the current BASIC program in memory.  Uses R0,
   1258  07e5							; tempIly, and dpl.
   1259  07e5							;
   1260  07e5		       20 c9 1b    iLST       jsr	SetOutConsole
   1261  07e8		       ad 2d 2c    iLST2      lda	ProgramStart
   1262  07eb		       85 59		      sta	dpl
   1263  07ed		       ad 2e 2c 	      lda	ProgramStart+1
   1264  07f0		       85 5a		      sta	dpl+1
   1265  07f2							;
   1266  07f2							; dpl/dph point to the current line.  See if we're at
   1267  07f2							; the end of the program.
   1268  07f2							;
   1269  07f2		       a5 59	   iLSTloop   lda	dpl
   1270  07f4		       cd 2f 2c 	      cmp	ProgramEnd
   1271  07f7		       d0 07		      bne	iLstNotEnd
   1272  07f9		       a5 5a		      lda	dpl+1
   1273  07fb		       cd 30 2c 	      cmp	ProgramEnd+1
   1274  07fe		       f0 44		      beq	iLstdone
   1275  0800							;
   1276  0800		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1277  0802		       b1 59		      lda	(dpl),y	;line number LSB
   1278  0804		       85 52		      sta	R0
   1279  0806		       c8		      iny
   1280  0807		       b1 59		      lda	(dpl),y	;line number MSB
   1281  0809		       85 53		      sta	R0+1
   1282  080b		       c8		      iny
   1283  080c		       8c 28 2c 	      sty	tempIlY
   1284  080f		       20 d6 11 	      jsr	PrintDecimal
   1285  0812		       a9 20		      lda	#SPACE
   1286  0814		       20 e3 1b 	      jsr	VOUTCH
   1287  0817		       ac 28 2c 	      ldy	tempIlY
   1288  081a		       b1 59	   iLSTl2     lda	(dpl),y
   1289  081c		       f0 0c		      beq	iLST3	;end of this line 0 value
   1290  081e		       8c 28 2c 	      sty	tempIlY
   1291  0821		       20 e3 1b 	      jsr	VOUTCH
   1292  0824		       ac 28 2c 	      ldy	tempIlY
   1293  0827		       c8		      iny
   1294  0828		       d0 f0		      bne	iLSTl2	;do next char
   1295  082a							;
   1296  082a							; End of this line.  Print CR/LF, then move to the
   1297  082a							; next line.
   1298  082a							;
   1299  082a		       c8	   iLST3      iny		;Move to next line
   1300  082b		       18		      clc		;Clear the carry flag
   1301  082c		       98		      tya		;Current Offset
   1302  082d		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  082f		       85 59		      sta	dpl	;Save the new value
   1304  0831		       a5 5a		      lda	dpl+1	;Next byte
   1305  0833		       69 00		      adc	#0	;ad in the carry if any
   1306  0835		       85 5a		      sta	dpl+1	;Save it
   1307  0837							;
   1308  0837							; Have to manually do CR/LF so it uses the vectored
   1309  0837							; output function.
   1310  0837							;
   1311  0837		       a9 0d		      lda	#CR
   1312  0839		       20 e3 1b 	      jsr	VOUTCH
   1313  083c		       a9 0a		      lda	#LF
   1314  083e		       20 e3 1b 	      jsr	VOUTCH
   1315  0841		       4c f2 07 	      jmp	iLSTloop	;do next line
   1316  0844							;
   1317  0844		       20 c9 1b    iLstdone   jsr	SetOutConsole
   1318  0847		       4c bb 02 	      jmp	NextIL
   1319  084a							;
   1320  084a							;=====================================================
   1321  084a							; Get a line of text into LINBUF.  Terminate with a
   1322  084a							; null byte.
   1323  084a							;
   1324  084a				   iGETLINE
   1325  084a		       a9 3e		      lda	#'>	;prompt character
   1326  084c		       a6 00		      ldx	0	;Wait for read to complete
   1327  084e		       20 7a 18 	      jsr	GetLine
   1328  0851							;
   1329  0851		       a9 00		      lda	#0
   1330  0853		       85 5b		      sta	RunMode
   1331  0855				   iGetParseLine
   1332  0855							;		  lda	  CUROFF
   1333  0855							;		  pha
   1334  0855							;		  jsr	  ParseInputLine
   1335  0855							;		  pha
   1336  0855							;		  sta	  CUROFF
   1337  0855		       4c bb 02 	      jmp	NextIL
   1338  0858							;
   1339  0858							;=====================================================
   1340  0858							; This is called when the input buffer contains a line
   1341  0858							; typed in by the user that starts with a line number.
   1342  0858							; Insert the line into the program or delete the line
   1343  0858							; if there is nothing after the line number,
   1344  0858							;
   1345  0858		       a0 00	   iINSRT     ldy	#0
   1346  085a		       20 0f 18 	      jsr	getDecimal	;convert line #
   1347  085d		       20 91 1a 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1348  0860		       8c 29 2c 	      sty	offset	;Save the start of the program line text
   1349  0863							;
   1350  0863							; Now find the line OR the next higher line OR the
   1351  0863							; end of the program.
   1352  0863							;
   1353  0863		       20 a9 17 	      jsr	findLine	; Look for the line number in the current program
   1354  0866							; Returns Z and curptr point to the line if found
   1355  0866							; Returns C and curptr at next higher line if not found and there is a higher line
   1356  0866							; Returns ZC clear and curptr to end of program if higher than all other lines
   1357  0866							;
   1358  0866							; If the line exists, it needs to be removed.
   1359  0866							;
   1360  0866		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1361  0868							;
   1362  0868							; Get length of line to be removed, we fall thru to here if we find a matching line
   1363  0868							;
   1364  0868							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1365  0868		       a0 00		      ldy	#0
   1366  086a		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1367  086c		       a8		      tay
   1368  086d							;If it is equal we delete the line and replace it, get length
   1369  086d							;then adjust all program line after up or down depending on len of line
   1370  086d							;If next higher then just move everythimg down by length bytes
   1371  086d							;This call will return how many bytes in the line we found
   1372  086d		       8c 2a 2c 	      sty	lineLength	;Save the length of the line we found
   1373  0870							;
   1374  0870							; Compute the new end of the program first.
   1375  0870							;
   1376  0870		       38		      sec		;Set the carry bit
   1377  0871		       ad 2f 2c 	      lda	ProgramEnd	;Get low byte of program end
   1378  0874		       ed 2a 2c 	      sbc	lineLength	;Subtract the length of the current line
   1379  0877		       8d 2f 2c 	      sta	ProgramEnd	;save it
   1380  087a		       ad 30 2c 	      lda	ProgramEnd+1
   1381  087d		       e9 00		      sbc	#0	;Process the carry
   1382  087f		       8d 30 2c 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1383  0882							;
   1384  0882							; Copy CURPTR into R1 for working
   1385  0882							;
   1386  0882		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1387  0884		       85 54		      sta	R1
   1388  0886		       a5 50		      lda	CURPTR+1
   1389  0888		       85 55		      sta	R1+1
   1390  088a							;
   1391  088a							; See if we're at the end.
   1392  088a							;
   1393  088a		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1394  088c		       cd 2f 2c 	      cmp	ProgramEnd
   1395  088f		       d0 07		      bne	InsDelLoop
   1396  0891		       a5 55		      lda	R1+1
   1397  0893		       cd 30 2c 	      cmp	ProgramEnd+1
   1398  0896		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1399  0898							;
   1400  0898							; Move one byte, move to next location.
   1401  0898							;
   1402  0898		       ac 2a 2c    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1403  089b		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1404  089d		       b1 54		      lda	(R1),y
   1405  089f		       a0 00		      ldy	#0
   1406  08a1		       91 54		      sta	(R1),y
   1407  08a3		       e6 54		      inc	R1
   1408  08a5		       d0 e3		      bne	InsDelChk
   1409  08a7		       e6 55		      inc	R1+1
   1410  08a9		       4c 8a 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1411  08ac							;
   1412  08ac							; Deletion is done.
   1413  08ac							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1414  08ac							;
   1415  08ac		       ac 29 2c    insert2    ldy	offset	; get back ptr  Get the current offset
   1416  08af		       b9 90 2b 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1417  08b2		       f0 5f		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1418  08b4							;
   1419  08b4							; CURPTR points to where the line will be inserted.
   1420  08b4							;
   1421  08b4		       20 34 19 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1422  08b7							;
   1423  08b7		       ad 2f 2c 	      lda	ProgramEnd	;Load the start address for the copy
   1424  08ba							;At this point curptr still contains the location we will insert data
   1425  08ba		       85 5c		      sta	FROM
   1426  08bc		       ad 30 2c 	      lda	ProgramEnd+1
   1427  08bf		       85 5d		      sta	FROM+1
   1428  08c1							;
   1429  08c1		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1430  08c3		       b1 5c		      lda	(FROM),y
   1431  08c5		       ac 2a 2c 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1432  08c8		       91 5c		      sta	(FROM),y	;Save the new byte
   1433  08ca							;
   1434  08ca		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1435  08cc		       c5 4f		      cmp	CURPTR
   1436  08ce		       d0 06		      bne	mvUpMore
   1437  08d0		       a5 5d		      lda	FROM+1
   1438  08d2		       c5 50		      cmp	CURPTR+1
   1439  08d4		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1440  08d6							;
   1441  08d6							; Not done yet
   1442  08d6							;
   1443  08d6		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1444  08d8		       d0 02		      bne	mvUpMore2
   1445  08da		       c6 5d		      dec	FROM+1
   1446  08dc		       c6 5c	   mvUpMore2  dec	FROM
   1447  08de		       4c c1 08 	      jmp	mvup1	;Loop until everything is moved
   1448  08e1							;
   1449  08e1							; All done with copy.
   1450  08e1							;
   1451  08e1				   mvUpDone
   1452  08e1		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1453  08e2		       ad 2a 2c 	      lda	lineLength	;Number of bytes to copy from line buff
   1454  08e5		       6d 2f 2c 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1455  08e8		       8d 2f 2c 	      sta	ProgramEnd
   1456  08eb		       ad 30 2c 	      lda	ProgramEnd+1
   1457  08ee		       69 00		      adc	#0
   1458  08f0		       8d 30 2c 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1459  08f3							;
   1460  08f3							;===================jlit use length before line newline
   1461  08f3
   1462  08f3		       a0 00		      ldy	#0	;Set offset of copy
   1463  08f5		       ad 2a 2c 	      lda	lineLength	;We will insert the actual length of the line first
   1464  08f8		       91 4f		      sta	(CURPTR),y	;Store the length
   1465  08fa		       c8		      iny
   1466  08fb		       a5 52		      lda	R0	;Store the line number next
   1467  08fd		       91 4f		      sta	(CURPTR),y
   1468  08ff		       c8		      iny
   1469  0900		       a5 53		      lda	R0+1
   1470  0902		       91 4f		      sta	(CURPTR),y
   1471  0904		       c8		      iny
   1472  0905							;
   1473  0905		       ae 29 2c 	      ldx	offset	;Load the offset into line buffer in page zero
   1474  0908		       bd 90 2b    mvUpLoop2  lda	LINBUF,x	;get a byte
   1475  090b		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1476  090d		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1477  090f		       e8		      inx
   1478  0910		       c8		      iny
   1479  0911		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1480  0913							;
   1481  0913		       4c bb 02    mvUpFini   jmp	NextIL
   1482  0916							;
   1483  0916							;=====================================================
   1484  0916							; Pops the top value of the ILPC stack and stores it
   1485  0916							; in ILPC.  Ie, return from an IL subroutine.
   1486  0916							;
   1487  0916		       20 97 17    iRTN       jsr	popILPC
   1488  0919		       4c bb 02 	      jmp	NextIL
   1489  091c							;
   1490  091c							;=====================================================
   1491  091c							; NLINE print a newline
   1492  091c							;
   1493  091c		       20 9a 1a    iNLINE     jsr	CRLF	;user supplied sub
   1494  091f		       4c bb 02 	      jmp	NextIL
   1495  0922							;
   1496  0922							;=====================================================
   1497  0922							; This saves the current ILPC value on the stack, then
   1498  0922							; jumps to the address specified by the next two bytes.
   1499  0922							;
   1500  0922		       20 7a 17    iCALL      jsr	pushILPC	;save ILPC
   1501  0925		       90 03		      bcc	iJMP
   1502  0927		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   1503  092a							;
   1504  092a							; Jmp to a specific location in the IL code.  The new
   1505  092a							; address immediately follows the opcode.
   1506  092a							;
   1507  092a		       20 60 17    iJMP       jsr	getILWord
   1508  092d		       86 43		      stx	ILPC
   1509  092f		       85 44		      sta	ILPC+1
   1510  0931		       4c bb 02 	      jmp	NextIL
   1511  0934
   1512  0934
   1513  0934							;
   1514  0934							;=====================================================
   1515  0934							; Push the next two bytes onto the arithmetic stack.
   1516  0934							;
   1517  0934		       20 64 17    iSetR2     jsr	getILByte
   1518  0937		       85 58		      sta	R2
   1519  0939		       4c bb 02 	      jmp	NextIL
   1520  093c							;
   1521  093c							;=====================================================
   1522  093c							; Push the next two bytes onto the arithmetic stack.
   1523  093c							;
   1524  093c		       20 60 17    iLIT       jsr	getILWord
   1525  093f		       86 52		      stx	R0
   1526  0941		       85 53		      sta	R0+1
   1527  0943		       20 5d 19 	      jsr	pushR0
   1528  0946		       4c bb 02 	      jmp	NextIL
   1529  0949							;
   1530  0949							;=====================================================
   1531  0949							; Initialize all variables for a single task.	Ie, set to zero.
   1532  0949							;
   1533  0949		       98	   subVINIT   tya
   1534  094a		       48		      pha
   1535  094b
   1536  094b		       a9 00		      lda	#0
   1537  094d		       a0 00		      ldy	#0
   1538  094f		       91 41	   Vinit2     sta	(VARIABLES),y
   1539  0951		       c8		      iny
   1540  0952		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1541  0954		       90 f9		      bcc	Vinit2
   1542  0956
   1543  0956		       68		      pla
   1544  0957		       a8		      tay
   1545  0958		       60		      rts
   1546  0959
   1547  0959		       20 49 09    iVINIT     jsr	subVINIT
   1548  095c		       4c bb 02 	      jmp	NextIL
   1549  095f							;
   1550  095f							;=====================================================
   1551  095f							; Set the address of the error handler.  After any
   1552  095f							; error, set to the ILPC to the specified location.
   1553  095f							;
   1554  095f		       20 60 17    iERRGOTO   jsr	getILWord
   1555  0962		       8e 1a 2c 	      stx	errGoto
   1556  0965		       8d 1b 2c 	      sta	errGoto+1
   1557  0968		       4c bb 02 	      jmp	NextIL
   1558  096b							;
   1559  096b							;=====================================================
   1560  096b							; TST is followed by an 8 bit signed offset, then a
   1561  096b							; null terminated string.  Compare the string against
   1562  096b							; the string starting at (CURPTR),CUROFF.  If the
   1563  096b							; strings match, continue executing the next IL
   1564  096b							; opcode.  Else, add the offset to ILPC.
   1565  096b							;
   1566  096b		       20 64 17    iTST       jsr	getILByte	;Get the relative jump address
   1567  096e		       8d 29 2c 	      sta	offset	;save it to use if test faile
   1568  0971		       20 47 19 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1569  0974
   1570  0974		       a4 51		      ldy	CUROFF
   1571  0976		       84 59		      sty	dpl	;save for later
   1572  0978							;
   1573  0978		       20 64 17    iTSTloop   jsr	getILByte	;get next char
   1574  097b		       f0 11		      beq	iTSTm	;match!
   1575  097d		       a4 59		      ldy	dpl
   1576  097f		       d1 4f		      cmp	(CURPTR),y
   1577  0981		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1578  0983		       09 20		      ora	#$20	; lets allow lowercase as well
   1579  0985		       d1 4f		      cmp	(CURPTR),y
   1580  0987		       d0 23		      bne	iTSTfail	;mismatch
   1581  0989		       c8	   iTSTUpper  iny
   1582  098a		       84 59		      sty	dpl
   1583  098c		       d0 ea		      bne	iTSTloop
   1584  098e							;
   1585  098e							; It's a match!  Clean up a bit.
   1586  098e							;
   1587  098e		       a4 59	   iTSTm      ldy	dpl
   1588  0990		       84 51		      sty	CUROFF
   1589  0992		       4c bb 02 	      jmp	NextIL
   1590  0995
   1591  0995							; Test for a single quote string
   1592  0995		       20 64 17    iTSTStr    jsr	getILByte
   1593  0998		       8d 29 2c 	      sta	offset
   1594  099b		       20 47 19 	      jsr	saveIL
   1595  099e		       a4 51		      ldy	CUROFF
   1596  09a0		       a9 22		      lda	#'"
   1597  09a2		       d1 4f		      cmp	(CURPTR),y
   1598  09a4		       d0 06		      bne	iTSTfail
   1599  09a6		       c8		      iny
   1600  09a7		       84 51		      sty	CUROFF
   1601  09a9		       4c de 02 	      jmp	NextILStr
   1602  09ac							;
   1603  09ac							; Not a match, reset ILPC and then move to the
   1604  09ac							; offset.
   1605  09ac							;
   1606  09ac		       20 52 19    iTSTfail   jsr	restoreIL
   1607  09af		       4c 0c 0b 	      jmp	tstBranch
   1608  09b2							;
   1609  09b2							;=================================================JLIT=
   1610  09b2							; Test if we have a let statement without the let keyword
   1611  09b2		       20 64 17    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1612  09b5		       8d 29 2c 	      sta	offset	; Save the jump offset for fails
   1613  09b8		       20 47 19 	      jsr	saveIL	; save to restore when done if fail
   1614  09bb
   1615  09bb		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1616  09bd		       20 91 1a 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1617  09c0		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1618  09c1		       20 91 1a 	      jsr	SkipSpaces	; skip any SkipSpaces
   1619  09c4		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1620  09c6		       c9 3d		      cmp	#'=	; check if equals
   1621  09c8		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1622  09ca		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1623  09cc		       d0 de		      bne	iTSTfail	; return it failed
   1624  09ce
   1625  09ce				   iTSTLETGOOD
   1626  09ce		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1627  09d1
   1628  09d1							;=================================================JLIT=
   1629  09d1							;
   1630  09d1		       20 64 17    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1631  09d4		       8d 29 2c 	      sta	offset	; Save the jump offset for fails
   1632  09d7		       20 47 19 	      jsr	saveIL	; save to restore when done if fail
   1633  09da		       20 60 17 	      jsr	getILWord	; Get a word into RO
   1634  09dd		       86 52		      stx	R0
   1635  09df		       85 53		      sta	R0+1
   1636  09e1		       20 64 17 	      jsr	getILByte	; Get byte into A
   1637  09e4		       a0 00		      ldy	#0
   1638  09e6		       d1 52		      cmp	(R0),y
   1639  09e8		       d0 03		      bne	iTSTByteNotEqual
   1640  09ea		       4c ac 09 	      jmp	iTSTfail
   1641  09ed
   1642  09ed				   iTSTByteNotEqual
   1643  09ed		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1644  09f0
   1645  09f0
   1646  09f0							;================================================jLIT=
   1647  09f0							;Test for end of line
   1648  09f0							;
   1649  09f0		       20 64 17    iTSTDONE   jsr	getILByte
   1650  09f3		       8d 29 2c 	      sta	offset
   1651  09f6		       20 47 19 	      jsr	saveIL
   1652  09f9		       a4 51		      ldy	CUROFF
   1653  09fb		       84 59		      sty	dpl
   1654  09fd		       20 91 1a 	      jsr	SkipSpaces
   1655  0a00		       b1 4f		      lda	(CURPTR),y
   1656  0a02		       f0 0b		      beq	iTSTDONEtrue
   1657  0a04		       c9 3a		      cmp	#COLON
   1658  0a06		       f0 07		      beq	iTSTDONEtrue
   1659  0a08		       a4 59		      ldy	dpl
   1660  0a0a		       84 51		      sty	CUROFF
   1661  0a0c		       4c ac 09 	      jmp	iTSTfail
   1662  0a0f							;
   1663  0a0f							; Advance to the next line
   1664  0a0f							;
   1665  0a0f				   iTSTDONEtrue
   1666  0a0f		       4c bb 02 	      jmp	NextIL
   1667  0a12
   1668  0a12		       4c 0c 0b    tstBranchLink jmp	tstBranch
   1669  0a15							;
   1670  0a15							;=====================================================
   1671  0a15							; Inc and dec a variable , faster than a = a + 1
   1672  0a15				   iINCVAR
   1673  0a15		       20 e1 19 	      jsr	popR0
   1674  0a18		       a0 00		      ldy	#0
   1675  0a1a		       18		      clc
   1676  0a1b		       a9 01		      lda	#1
   1677  0a1d		       71 52		      adc	(R0),y
   1678  0a1f		       91 52		      sta	(R0),y
   1679  0a21		       90 07		      bcc	iINCDONE
   1680  0a23		       c8		      iny
   1681  0a24		       a9 00		      lda	#0
   1682  0a26		       71 52		      adc	(R0),y
   1683  0a28		       91 52		      sta	(R0),y
   1684  0a2a				   iINCDONE
   1685  0a2a		       4c bb 02 	      jmp	NextIL
   1686  0a2d				   iDECVAR
   1687  0a2d		       20 e1 19 	      jsr	popR0
   1688  0a30		       a0 00		      ldy	#0
   1689  0a32		       38		      sec
   1690  0a33		       b1 52		      lda	(R0),y
   1691  0a35		       e9 01		      sbc	#1
   1692  0a37		       91 52		      sta	(R0),y
   1693  0a39		       c8		      iny
   1694  0a3a		       b1 52		      lda	(R0),y
   1695  0a3c		       e9 00		      sbc	#0
   1696  0a3e		       91 52		      sta	(R0),y
   1697  0a40		       4c bb 02 	      jmp	NextIL
   1698  0a43
   1699  0a43
   1700  0a43							;
   1701  0a43							;=====================================================
   1702  0a43							; TSTV is followed by an 8 bit signed offset.	If the
   1703  0a43							; value at (CURPTR),CUROFF appears to be a variable
   1704  0a43							; name, move to the next IL statement.  Else, add the
   1705  0a43							; offset to ILPC. Converted to use actual absolute memory addresses
   1706  0a43							; TSTVT Looks for the task context
   1707  0a43							;
   1708  0a43		       20 f9 19    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1709  0a46		       a9 00		      lda	#0
   1710  0a48		       85 58		      sta	R2
   1711  0a4a		       f0 04		      beq	iTSTVV
   1712  0a4c
   1713  0a4c		       a9 01	   iTSTV      lda	#1
   1714  0a4e		       85 58		      sta	R2
   1715  0a50
   1716  0a50		       20 64 17    iTSTVV     jsr	getILByte	;offset
   1717  0a53		       8d 29 2c 	      sta	offset
   1718  0a56							;
   1719  0a56		       a4 51		      ldy	CUROFF
   1720  0a58		       20 91 1a 	      jsr	SkipSpaces
   1721  0a5b		       b1 4f		      lda	(CURPTR),y
   1722  0a5d		       d0 03		      bne	iTSTVnext
   1723  0a5f		       4c 12 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1724  0a62							;
   1725  0a62				   iTSTVnext
   1726  0a62		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1727  0a64		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1728  0a66
   1729  0a66		       c9 23		      cmp	#'#	; parameters passed to this task
   1730  0a68		       f0 53		      beq	iTSTVParm
   1731  0a6a
   1732  0a6a		       c9 5e		      cmp	#'^	; task exit code
   1733  0a6c		       d0 04		      bne	iTSTV_A2Z
   1734  0a6e		       a9 19		      lda	#TASKEXITCODE
   1735  0a70		       d0 10		      bne	iTSTVContinue
   1736  0a72
   1737  0a72				   iTSTV_A2Z
   1738  0a72		       09 20		      ora	#$20	;make lower then upper
   1739  0a74		       49 20		      eor	#$20	;allow lower case here
   1740  0a76		       c9 41		      cmp	#'A
   1741  0a78		       90 98		      bcc	tstBranchLink
   1742  0a7a		       c9 5b		      cmp	#'Z+1
   1743  0a7c		       b0 94		      bcs	tstBranchLink
   1744  0a7e
   1745  0a7e
   1746  0a7e							;
   1747  0a7e							; The condition is true, so convert to an index, push
   1748  0a7e							; it onto the stack and continue running.
   1749  0a7e							;
   1750  0a7e		       38		      sec
   1751  0a7f		       e9 41		      sbc	#'A	;index is zero based
   1752  0a81		       0a		      asl		;multiply by two
   1753  0a82
   1754  0a82				   iTSTVContinue
   1755  0a82		       c8		      iny
   1756  0a83		       84 51		      sty	CUROFF	;it is a valid variable
   1757  0a85		       48		      pha
   1758  0a86		       a5 58		      lda	R2
   1759  0a88		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1760  0a8a
   1761  0a8a		       20 47 17 	      jsr	ipc_getcontext	; Get the other tasks variables
   1762  0a8d		       a0 01		      ldy	#VARIABLEPOS
   1763  0a8f		       b1 56		      lda	(MQ),y
   1764  0a91		       85 52		      sta	R0
   1765  0a93		       c8		      iny
   1766  0a94		       b1 56		      lda	(MQ),y
   1767  0a96		       85 53		      sta	R0+1
   1768  0a98		       4c a3 0a 	      jmp	iTSTVAddOffset
   1769  0a9b
   1770  0a9b				   iTSTVLocalValue
   1771  0a9b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1772  0a9d		       85 52		      sta	R0
   1773  0a9f		       a5 42		      lda	VARIABLES+1
   1774  0aa1		       85 53		      sta	R0+1
   1775  0aa3
   1776  0aa3				   iTSTVAddOffset
   1777  0aa3		       68		      pla
   1778  0aa4		       85 54		      sta	R1
   1779  0aa6		       a9 00		      lda	#0
   1780  0aa8		       85 55		      sta	R1+1
   1781  0aaa
   1782  0aaa				   iTSTVcontinue
   1783  0aaa
   1784  0aaa		       4c 8b 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1785  0aad
   1786  0aad							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1787  0aad							; an array of integer values
   1788  0aad				   iTSTVat
   1789  0aad		       c8		      iny
   1790  0aae		       84 51		      sty	CUROFF	;it is a valid variable
   1791  0ab0		       ad 2f 2c 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1792  0ab3		       85 52		      sta	R0
   1793  0ab5		       ad 30 2c 	      lda	ProgramEnd+1
   1794  0ab8		       85 53		      sta	R0+1
   1795  0aba		       4c 03 07 	      jmp	pushR0nextIl	;place this onto the stack
   1796  0abd
   1797  0abd							; When we get parameters passed we can access them using the # variable with[]
   1798  0abd							; example #[0] #[1] etc, we dont check yet if there is too many
   1799  0abd				   iTSTVParm
   1800  0abd		       c8		      iny
   1801  0abe		       84 51		      sty	CUROFF	;it is a valid variable
   1802  0ac0		       a5 48		      lda	MATHSTACK
   1803  0ac2		       85 52		      sta	R0
   1804  0ac4		       a5 49		      lda	MATHSTACK+1
   1805  0ac6		       85 53		      sta	R0+1
   1806  0ac8		       4c 03 07 	      jmp	pushR0nextIl
   1807  0acb
   1808  0acb							;
   1809  0acb							;=====================================================
   1810  0acb							; TSTL seems basically the same as TSTN, but leave the
   1811  0acb							; value in R0 instead of pushing onto stack.
   1812  0acb							; This tests for a valid line number
   1813  0acb							;
   1814  0acb		       20 64 17    iTSTL      jsr	getILByte
   1815  0ace		       8d 29 2c 	      sta	offset
   1816  0ad1							;
   1817  0ad1		       a4 51		      ldy	CUROFF
   1818  0ad3		       20 91 1a 	      jsr	SkipSpaces
   1819  0ad6		       b1 4f		      lda	(CURPTR),y
   1820  0ad8							;
   1821  0ad8		       c9 30		      cmp	#'0
   1822  0ada		       90 30		      bcc	tstBranch
   1823  0adc		       c9 3a		      cmp	#'9+1
   1824  0ade		       b0 2c		      bcs	tstBranch
   1825  0ae0							;
   1826  0ae0							; It's a digit, so convert to a number.
   1827  0ae0							;
   1828  0ae0		       20 0f 18 	      jsr	getDecimal
   1829  0ae3		       4c bb 02 	      jmp	NextIL
   1830  0ae6							;
   1831  0ae6							;=====================================================
   1832  0ae6							; TSTN checks for a number.  This is very simplistic;
   1833  0ae6							; if the character is a digit, assume it's a number.
   1834  0ae6							; Convert to a number and push it onto the stack.
   1835  0ae6							;
   1836  0ae6		       20 64 17    iTSTN      jsr	getILByte
   1837  0ae9		       8d 29 2c 	      sta	offset
   1838  0aec							;
   1839  0aec		       a4 51		      ldy	CUROFF
   1840  0aee		       20 91 1a 	      jsr	SkipSpaces
   1841  0af1		       b1 4f		      lda	(CURPTR),y
   1842  0af3		       f0 17		      beq	tstBranch
   1843  0af5		       c9 2d		      cmp	#'-	;negative?
   1844  0af7		       f0 08		      beq	iTSTN_1
   1845  0af9		       c9 30		      cmp	#'0
   1846  0afb		       90 0f		      bcc	tstBranch
   1847  0afd		       c9 3a		      cmp	#'9+1
   1848  0aff		       b0 0b		      bcs	tstBranch
   1849  0b01							;
   1850  0b01							; It's a digit, so convert to a number.
   1851  0b01							;
   1852  0b01				   iTSTN_1
   1853  0b01		       20 0f 18 	      jsr	getDecimal
   1854  0b04		       84 51		      sty	CUROFF
   1855  0b06		       20 5d 19 	      jsr	pushR0	;save onto stack
   1856  0b09		       4c bb 02 	      jmp	NextIL
   1857  0b0c
   1858  0b0c							;
   1859  0b0c							; Common jump point for all TSTx instructions that
   1860  0b0c							; fail to meet the requirements.  This takes the
   1861  0b0c							; offset and adds/subtracts to/from ILPC.
   1862  0b0c							;
   1863  0b0c		       ad 29 2c    tstBranch  lda	offset	;get signed offset
   1864  0b0f		       10 0e		      bpl	tstPositive
   1865  0b11							;
   1866  0b11							; Do negative branch.	Do sign extension.
   1867  0b11							;
   1868  0b11		       18	   tstNegative clc
   1869  0b12		       65 43		      adc	ILPC
   1870  0b14		       85 43		      sta	ILPC
   1871  0b16							;		  bcc	  tstBothDone
   1872  0b16							;		  dec	  ILPC+1
   1873  0b16							;		  jmp	  NextIL
   1874  0b16
   1875  0b16		       a5 44		      lda	ILPC+1
   1876  0b18		       69 ff		      adc	#$ff
   1877  0b1a		       85 44		      sta	ILPC+1
   1878  0b1c		       4c bb 02 	      jmp	NextIL	;keep going
   1879  0b1f							;
   1880  0b1f		       18	   tstPositive clc
   1881  0b20		       65 43		      adc	ILPC
   1882  0b22		       85 43		      sta	ILPC
   1883  0b24		       90 02		      bcc	tstBothDone
   1884  0b26		       e6 44		      inc	ILPC+1
   1885  0b28				   tstBothDone
   1886  0b28		       4c bb 02 	      jmp	NextIL
   1887  0b2b
   1888  0b2b							;
   1889  0b2b							;====================================================
   1890  0b2b							; Test for IRQ pending, and test if a break key pressed
   1891  0b2b							; Yes I know but this handles all sorts of irq/break issues
   1892  0b2b							;
   1893  0b2b		       20 64 17    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1894  0b2e		       8d 29 2c 	      sta	offset	; Store the not true jump address offset
   1895  0b31		       20 36 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1896  0b34		       d0 03		      bne	irqNo	; z not set of no break found
   1897  0b36		       4c 01 06 	      jmp	iFIN	; Exit out of run mode
   1898  0b39		       ad d1 22    irqNo      lda	IRQPending
   1899  0b3c		       f0 ce		      beq	tstBranch
   1900  0b3e		       c9 01		      cmp	#1	; only do this if set to first time
   1901  0b40		       d0 ca		      bne	tstBranch
   1902  0b42		       78		      sei		; disable the interupt until ireturn resets it
   1903  0b43		       ee d1 22    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1904  0b46		       20 77 19 	      jsr	pushLN	; Push the next line to be executed
   1905  0b49		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1906  0b4b		       ad d2 22 	      lda	IRQEntry	; Get the line number to branch to
   1907  0b4e		       85 4f		      sta	CURPTR	; put line number into r0
   1908  0b50		       ad d3 22 	      lda	IRQEntry+1
   1909  0b53		       85 50		      sta	CURPTR+1
   1910  0b55		       a9 03		      lda	#3	; Point to first byte of program text
   1911  0b57		       85 51		      sta	CUROFF
   1912  0b59		       4c bb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1913  0b5c
   1914  0b5c		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1915  0b5e		       a9 00		      lda	#0	; stop the execution
   1916  0b60		       4c 18 06 	      jmp	iErr2
   1917  0b63							;
   1918  0b63
   1919  0b63							;=====================================================
   1920  0b63							; This places the number of free bytes on top of the
   1921  0b63							; stack.
   1922  0b63							;
   1923  0b63		       20 ca 12    iFREE      jsr	MemFree
   1924  0b66		       20 5d 19 	      jsr	pushR0
   1925  0b69		       4c bb 02 	      jmp	NextIL
   1926  0b6c							;
   1927  0b6c							;=====================================================
   1928  0b6c							; Generate a random number from 0-FFFF and then MOD
   1929  0b6c							; it with the value on top of stack.  Leaves number on
   1930  0b6c							; stack
   1931  0b6c							;
   1932  0b6c		       20 f9 19    iRANDOM    jsr	popR1	;mod value
   1933  0b6f							;
   1934  0b6f							; If the value is zero, just return a one.
   1935  0b6f							;
   1936  0b6f		       a5 54		      lda	R1
   1937  0b71		       05 55		      ora	R1+1
   1938  0b73		       f0 4a		      beq	irandom1
   1939  0b75							;
   1940  0b75		       ad 20 2c 	      lda	random+1
   1941  0b78		       8d 1d 2c 	      sta	rtemp1
   1942  0b7b		       ad 1f 2c 	      lda	random
   1943  0b7e		       0a		      asl
   1944  0b7f		       2e 1d 2c 	      rol	rtemp1
   1945  0b82		       0a		      asl
   1946  0b83		       2e 1d 2c 	      rol	rtemp1
   1947  0b86		       18		      clc
   1948  0b87		       6d 1f 2c 	      adc	random
   1949  0b8a
   1950  0b8a		       48		      pha
   1951  0b8b
   1952  0b8b		       ad 1d 2c 	      lda	rtemp1
   1953  0b8e		       6d 20 2c 	      adc	random+1
   1954  0b91		       8d 20 2c 	      sta	random+1
   1955  0b94
   1956  0b94		       68		      pla
   1957  0b95
   1958  0b95		       69 11		      adc	#$11
   1959  0b97		       8d 1f 2c 	      sta	random
   1960  0b9a		       ad 20 2c 	      lda	random+1
   1961  0b9d		       69 36		      adc	#$36
   1962  0b9f		       8d 20 2c 	      sta	random+1
   1963  0ba2
   1964  0ba2		       ad 1f 2c 	      lda	random
   1965  0ba5		       85 52		      sta	R0
   1966  0ba7		       ad 20 2c 	      lda	random+1
   1967  0baa		       29 7f		      and	#$7f	;make positive
   1968  0bac		       85 53		      sta	R0+1
   1969  0bae							;
   1970  0bae							; R0 contains the number and R1 contains the max value.
   1971  0bae							;
   1972  0bae		       20 29 07 	      jsr	iDivNoPop
   1973  0bb1		       20 62 1a 	      jsr	RestoreSigns
   1974  0bb4		       a5 56		      lda	MQ
   1975  0bb6		       85 52		      sta	R0
   1976  0bb8		       a5 57		      lda	MQ+1
   1977  0bba		       85 53		      sta	R0+1
   1978  0bbc		       4c 03 07 	      jmp	pushR0nextIl
   1979  0bbf				   irandom1
   1980  0bbf		       a9 00		      lda	#0
   1981  0bc1		       85 53		      sta	R0+1
   1982  0bc3		       a9 01		      lda	#1
   1983  0bc5		       85 52		      sta	R0
   1984  0bc7		       4c 03 07 	      jmp	pushR0nextIl
   1985  0bca
   1986  0bca							; The following replaced by call to division/modulo
   1987  0bca							;iRANDOM_2	lda	R0
   1988  0bca							;		cmp	R1
   1989  0bca							;		bne	iRANDOM_1
   1990  0bca							;		lda	R0+1
   1991  0bca							;		cmp	R1+1
   1992  0bca							;		bne	iRANDOM_1	;need to subtract
   1993  0bca							;
   1994  0bca							; Subtract R1 from R0
   1995  0bca							;
   1996  0bca							;iRANDOM_sub	sec
   1997  0bca							;		lda	R0
   1998  0bca							;		sbc	R1
   1999  0bca							;		sta	R0
   2000  0bca							;		lda	R0+1
   2001  0bca							;		sbc	R1+1
   2002  0bca							;		sta	R0+1
   2003  0bca							;		jmp	iRANDOM_2
   2004  0bca							;
   2005  0bca							; See if R1 > R0.  If so, branch to subtract.
   2006  0bca							;
   2007  0bca							;iRANDOM_1	lda	R0
   2008  0bca							;		cmp	R1
   2009  0bca							;		lda	R0+1
   2010  0bca							;		sbc	R1+1
   2011  0bca							;		bvc	iRANDOM_4
   2012  0bca							;		eor	#$80
   2013  0bca							;iRANDOM_4	bpl	iRANDOM_sub
   2014  0bca							;
   2015  0bca							; All done.  Almost.  Add one, then push the result.
   2016  0bca							;
   2017  0bca							;irandom1	inc	R0
   2018  0bca							;		bne	iRANDOM_3
   2019  0bca							;		inc	R0+1
   2020  0bca							;iRANDOM_3
   2021  0bca							;		  jsr	pushR0	;return value
   2022  0bca							;		jmp	NextIL
   2023  0bca							;
   2024  0bca							; Poke a value into a memory location
   2025  0bca		       8c 25 2c    iPOKEMEMORY sty	tempy
   2026  0bcd		       20 e1 19 	      jsr	popR0
   2027  0bd0		       20 f9 19 	      jsr	popR1
   2028  0bd3		       a0 00		      ldy	#0
   2029  0bd5		       a5 52		      lda	R0
   2030  0bd7		       91 54		      sta	(R1),y
   2031  0bd9		       ac 25 2c 	      ldy	tempy
   2032  0bdc		       4c bb 02 	      jmp	NextIL
   2033  0bdf							;
   2034  0bdf							; Get a value from a memory location
   2035  0bdf							;
   2036  0bdf		       8c 25 2c    iPEEKMEMORY sty	tempy
   2037  0be2		       20 e1 19 	      jsr	popR0
   2038  0be5		       a0 00		      ldy	#0
   2039  0be7		       b1 52		      lda	(R0),y
   2040  0be9		       ac 25 2c 	      ldy	tempy
   2041  0bec		       85 52		      sta	R0
   2042  0bee		       a9 00		      lda	#0
   2043  0bf0		       85 53		      sta	R0+1
   2044  0bf2		       4c 03 07 	      jmp	pushR0nextIl
   2045  0bf5							;
   2046  0bf5							; Call to address return what ever is in a to the stack
   2047  0bf5							; func2 will load a value into a before the call
   2048  0bf5		       20 f9 19    iCallFunc  jsr	popR1
   2049  0bf8		       a5 54		      lda	R1
   2050  0bfa		       20 06 0c 	      jsr	iCallRtn
   2051  0bfd		       85 52		      sta	R0
   2052  0bff		       a9 00		      lda	#0
   2053  0c01		       85 53		      sta	R0+1
   2054  0c03		       20 03 07 	      jsr	pushR0nextIl
   2055  0c06				   iCallRtn
   2056  0c06		       20 e1 19 	      jsr	popR0
   2057  0c09		       6c 52 00 	      jmp	(R0)
   2058  0c0c
   2059  0c0c
   2060  0c0c							;===========================================jlit======
   2061  0c0c							;Get a character from the terminal convert to value
   2062  0c0c							;leave the number on top of the stack
   2063  0c0c							;
   2064  0c0c				   iGETCHAR
   2065  0c0c		       20 e6 1b 	      jsr	VGETCH
   2066  0c0f					      if	CTMON65
   2067  0c0f		       48		      pha
   2068  0c10		       20 e3 1b 	      jsr	VOUTCH	;echo echo echo
   2069  0c13		       68		      pla
   2070  0c14					      endif
   2071  0c14		       85 52		      sta	R0
   2072  0c16		       a9 00		      lda	#0
   2073  0c18		       85 53		      sta	R0+1
   2074  0c1a		       20 5d 19 	      jsr	pushR0
   2075  0c1d							;
   2076  0c1d		       4c bb 02 	      jmp	NextIL
   2077  0c20							;===========================================jusilostintim======
   2078  0c20							;Put a character to the terminal convert to
   2079  0c20							;
   2080  0c20		       20 e1 19    iPUTCHAR   jsr	popR0
   2081  0c23		       a5 52		      lda	R0
   2082  0c25		       20 e3 1b 	      jsr	VOUTCH
   2083  0c28		       4c bb 02 	      jmp	NextIL
   2084  0c2b							;=====================================================
   2085  0c2b							; Put the number on the stack out as hex, suppress leading 0
   2086  0c2b				   iHexOut
   2087  0c2b		       20 e1 19 	      jsr	popR0
   2088  0c2e		       a5 53		      lda	R0+1
   2089  0c30		       f0 03		      beq	iHexSecondByte
   2090  0c32		       20 88 12 	      jsr	OUTHEX
   2091  0c35				   iHexSecondByte
   2092  0c35		       a5 52		      lda	R0
   2093  0c37		       20 88 12 	      jsr	OUTHEX
   2094  0c3a		       4c bb 02 	      jmp	NextIL
   2095  0c3d							;
   2096  0c3d							;=====================================================
   2097  0c3d							; Replace TOS with its absolute value.
   2098  0c3d							;
   2099  0c3d		       20 e1 19    iABS       jsr	popR0
   2100  0c40		       a5 53		      lda	R0+1
   2101  0c42		       10 10		      bpl	iABS_1	;already positive
   2102  0c44		       49 ff		      eor	#$ff
   2103  0c46		       85 53		      sta	R0+1
   2104  0c48		       a5 52		      lda	R0
   2105  0c4a		       49 ff		      eor	#$ff
   2106  0c4c		       85 52		      sta	R0
   2107  0c4e		       e6 52		      inc	R0
   2108  0c50		       d0 02		      bne	iABS_1
   2109  0c52		       e6 53		      inc	R0+1
   2110  0c54		       4c 03 07    iABS_1     jmp	pushR0nextIl
   2111  0c57
   2112  0c57							;
   2113  0c57							;================================================================
   2114  0c57							; The set of logical operators
   2115  0c57				   iLogAnd
   2116  0c57		       20 e1 19 	      jsr	popR0
   2117  0c5a		       20 f9 19 	      jsr	popR1
   2118  0c5d		       a5 52		      lda	R0
   2119  0c5f		       25 54		      and	R1
   2120  0c61		       85 52		      sta	R0
   2121  0c63		       a5 53		      lda	R0+1
   2122  0c65		       25 55		      and	R1+1
   2123  0c67		       85 53		      sta	R0+1
   2124  0c69		       4c 03 07 	      jmp	pushR0nextIl
   2125  0c6c				   iLogOr
   2126  0c6c		       20 e1 19 	      jsr	popR0
   2127  0c6f		       20 f9 19 	      jsr	popR1
   2128  0c72		       a5 52		      lda	R0
   2129  0c74		       05 54		      ora	R1
   2130  0c76		       85 52		      sta	R0
   2131  0c78		       a5 53		      lda	R0+1
   2132  0c7a		       05 55		      ora	R1+1
   2133  0c7c		       85 53		      sta	R0+1
   2134  0c7e		       4c 03 07 	      jmp	pushR0nextIl
   2135  0c81				   iLogXor
   2136  0c81		       20 e1 19 	      jsr	popR0
   2137  0c84		       20 f9 19 	      jsr	popR1
   2138  0c87		       a5 52		      lda	R0
   2139  0c89		       45 54		      eor	R1
   2140  0c8b		       85 52		      sta	R0
   2141  0c8d		       a5 53		      lda	R0+1
   2142  0c8f		       45 55		      eor	R1+1
   2143  0c91		       85 53		      sta	R0+1
   2144  0c93		       4c 03 07 	      jmp	pushR0nextIl
   2145  0c96				   iLogNot
   2146  0c96		       20 e1 19 	      jsr	popR0
   2147  0c99		       a5 52		      lda	R0
   2148  0c9b		       49 ff		      eor	#$FF
   2149  0c9d		       85 52		      sta	R0
   2150  0c9f		       a5 53		      lda	R0+1
   2151  0ca1		       49 ff		      eor	#$FF
   2152  0ca3		       85 53		      sta	R0+1
   2153  0ca5		       4c 03 07 	      jmp	pushR0nextIl
   2154  0ca8
   2155  0ca8				   iTruth
   2156  0ca8		       a9 ff		      lda	#$FF
   2157  0caa		       85 52		      sta	R0
   2158  0cac		       85 53		      sta	R0+1
   2159  0cae		       4c 03 07 	      jmp	pushR0nextIl
   2160  0cb1				   iFalse
   2161  0cb1		       a9 00		      lda	#$00
   2162  0cb3		       85 52		      sta	R0
   2163  0cb5		       85 53		      sta	R0+1
   2164  0cb7		       4c 03 07 	      jmp	pushR0nextIl
   2165  0cba
   2166  0cba							;================================================================
   2167  0cba							;Set the IRQ service rtn line number
   2168  0cba							;
   2169  0cba		       78	   iSetIrq    sei		; disable the interupts
   2170  0cbb		       a9 00		      lda	#0	; Zero the Status flag
   2171  0cbd		       8d d0 22 	      sta	IRQStatus
   2172  0cc0		       20 e1 19 	      jsr	popR0	; get the line number
   2173  0cc3		       a5 52		      lda	R0
   2174  0cc5		       05 53		      ora	R0+1
   2175  0cc7		       f0 20		      beq	iSetExt	; if it is zero disable all
   2176  0cc9		       20 77 19 	      jsr	pushLN	; Save the current line pointer
   2177  0ccc		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2178  0cce		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   2179  0cd1				   iSetIrqOk
   2180  0cd1		       20 a9 17 	      jsr	findLine	; Find the IRQ func Line Pointer
   2181  0cd4		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2182  0cd6		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2183  0cd8		       8d d3 22 	      sta	IRQEntry+1
   2184  0cdb		       a5 4f		      lda	CURPTR
   2185  0cdd		       8d d2 22 	      sta	IRQEntry
   2186  0ce0		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2187  0ce2		       8d d0 22 	      sta	IRQStatus
   2188  0ce5		       20 9c 19 	      jsr	popLN	; Restore the old line number
   2189  0ce8		       58		      cli		; Enable the interupts
   2190  0ce9		       4c bb 02    iSetExt    jmp	NextIL
   2191  0cec
   2192  0cec		       20 9c 19    iSetIrqErr jsr	popLN
   2193  0cef		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2194  0cf1		       a9 00		      lda	#0
   2195  0cf3		       4c 18 06 	      jmp	iErr2
   2196  0cf6							;
   2197  0cf6		       20 e1 19    iTRACEPROG jsr	popR0
   2198  0cf9		       a5 52		      lda	R0
   2199  0cfb		       85 40		      sta	ILTrace
   2200  0cfd		       4c bb 02 	      jmp	NextIL
   2201  0d00
   2202  0d00							;=====================================================
   2203  0d00							; Define start of non page zero data
   2204 U2c37 ????				      seg.u	TBData
   2205 U22bf					      org	PROGEND
   2206 U22bf							;=================================================================
   2207 U22bf							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U22bf					      include	"tokenizer.asm"
      1  0d00					      seg	Code
      2  0d00		       ff ff ff ff DEBUGPARSER equ	TRUE	; Print debugging information
      3  0d00
      4  0d00							; Define the types of tokens found, and identifiers
      5  0d00		       00 80	   KeywordsMax equ	128	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0d00		       00 80	   tVa	      equ	128	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0d00		       00 82	   tVb	      equ	130	; Variables 128 - 157	$80-$9D
      8  0d00		       00 9b	   tVhat      equ	155	; Variable ^
      9  0d00		       00 9c	   tVhash     equ	156	; Variable #
     10  0d00		       00 9d	   tVat       equ	157	; Variable @ = 0
     11  0d00
     12  0d00		       00 a0	   tInteger   equ	160	; all tokenized integers start with 251 as first byte
     13  0d00		       00 a1	   tString    equ	161	; String all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     14  0d00		       00 a2	   tByte      equ	162	; Unsigned byte value
     15  0d00		       00 a3	   tArray     equ	163	; Identifies Array Type, the byte following defines the length of each element
     16  0d00							; Arrays of string are arrays of pointers 2 bytes
     17  0d00		       00 a4	   tPointer   equ	164	; Pointer to another variable
     18  0d00		       00 a5	   tVariable  equ	165	; Variable index  = A-Z and ^ variables
     19  0d00		       00 a7	   tIndirect  equ	167	; Points to an address that points to the data
     20  0d00
     21  0d00		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     22  0d00							;  +($F0), <($F1),=($F2),<=($F3), >($F4), <>($F5), >=($F6), -($F7), /($F8), %($F9), *($FA), (($FB), )($FC)
     23  0d00							;  240 - 252
     24  0d00		       00 ff	   tError     equ	255	; Error should never happen
     25  0d00							;
     26  0d00							; Keyword table contains 48 keywords
     27  0d00				   KeyWordTable
      0  0d00					      db	"leT"	; 1, we only have 0 at end of program or line
      1  0d00		       6c 65 54 	      .byte.b	"leT"
      0  0d03					      db	"inC"
      1  0d03		       69 6e 43 	      .byte.b	"inC"
      0  0d06					      db	"deC"
      1  0d06		       64 65 43 	      .byte.b	"deC"
      0  0d09					      db	"ireturN"
      1  0d09		       69 72 65 74*	      .byte.b	"ireturN"
      0  0d10					      db	"iF"
      1  0d10		       69 46		      .byte.b	"iF"
      0  0d12					      db	"theN"
      1  0d12		       74 68 65 4e	      .byte.b	"theN"
      0  0d16					      db	"gotO"
      1  0d16		       67 6f 74 4f	      .byte.b	"gotO"
      0  0d1a					      db	"gosuB"
      1  0d1a		       67 6f 73 75*	      .byte.b	"gosuB"
      0  0d1f					      db	"returN"
      1  0d1f		       72 65 74 75*	      .byte.b	"returN"
      0  0d25					      db	"reM"
      1  0d25		       72 65 4d 	      .byte.b	"reM"
      0  0d28					      db	"prinT"
      1  0d28		       70 72 69 6e*	      .byte.b	"prinT"
     39  0d28		       00 0b	   kPrint     equ	11	; sould be entry for print
      0  0d2d					      db	"taskE"
      1  0d2d		       74 61 73 6b*	      .byte.b	"taskE"
      0  0d32					      db	"taskN"
      1  0d32		       74 61 73 6b*	      .byte.b	"taskN"
      0  0d37					      db	"taskW"
      1  0d37		       74 61 73 6b*	      .byte.b	"taskW"
      0  0d3c					      db	"pokE"
      1  0d3c		       70 6f 6b 45	      .byte.b	"pokE"
      0  0d40					      db	"putcH"
      1  0d40		       70 75 74 63*	      .byte.b	"putcH"
      0  0d45					      db	"clS"
      1  0d45		       63 6c 53 	      .byte.b	"clS"
      0  0d48					      db	"inpuT"
      1  0d48		       69 6e 70 75*	      .byte.b	"inpuT"
      0  0d4d					      db	"enD"
      1  0d4d		       65 6e 44 	      .byte.b	"enD"
      0  0d50					      db	"irQ"
      1  0d50		       69 72 51 	      .byte.b	"irQ"
      0  0d53					      db	"kilL"
      1  0d53		       6b 69 6c 4c	      .byte.b	"kilL"
      0  0d57					      db	"lisT"
      1  0d57		       6c 69 73 54	      .byte.b	"lisT"
      0  0d5b					      db	"ruN"
      1  0d5b		       72 75 4e 	      .byte.b	"ruN"
      0  0d5e					      db	"neW"
      1  0d5e		       6e 65 57 	      .byte.b	"neW"
      0  0d61					      db	"slicE"
      1  0d61		       73 6c 69 63*	      .byte.b	"slicE"
      0  0d66					      db	"tracE"
      1  0d66		       74 72 61 63*	      .byte.b	"tracE"
      0  0d6b					      db	"exiT"
      1  0d6b		       65 78 69 54	      .byte.b	"exiT"
      0  0d6f					      db	"savE"
      1  0d6f		       73 61 76 45	      .byte.b	"savE"
      0  0d73					      db	"loaD"
      1  0d73		       6c 6f 61 44	      .byte.b	"loaD"
      0  0d77					      db	"erasE"
      1  0d77		       65 72 61 73*	      .byte.b	"erasE"
      0  0d7c					      db	"noT"
      1  0d7c		       6e 6f 54 	      .byte.b	"noT"
      0  0d7f					      db	"oR"
      1  0d7f		       6f 52		      .byte.b	"oR"
      0  0d81					      db	"xoR"
      1  0d81		       78 6f 52 	      .byte.b	"xoR"
      0  0d84					      db	"anD"
      1  0d84		       61 6e 44 	      .byte.b	"anD"
      0  0d87					      db	"truE"
      1  0d87		       74 72 75 45	      .byte.b	"truE"
      0  0d8b					      db	"falsE"
      1  0d8b		       66 61 6c 73*	      .byte.b	"falsE"
     65  0d90							;functions returning values
      0  0d90					      db	"freE"
      1  0d90		       66 72 65 45	      .byte.b	"freE"
      0  0d94					      db	"getcH"
      1  0d94		       67 65 74 63*	      .byte.b	"getcH"
      0  0d99					      db	"peeK"
      1  0d99		       70 65 65 4b	      .byte.b	"peeK"
      0  0d9d					      db	"tasK"
      1  0d9d		       74 61 73 4b	      .byte.b	"tasK"
      0  0da1					      db	"ipcc"
      1  0da1		       69 70 63 63	      .byte.b	"ipcc"
      0  0da5					      db	"ipcS"
      1  0da5		       69 70 63 53	      .byte.b	"ipcS"
      0  0da9					      db	"ipcR"
      1  0da9		       69 70 63 52	      .byte.b	"ipcR"
      0  0dad					      db	"rnD"
      1  0dad		       72 6e 44 	      .byte.b	"rnD"
      0  0db0					      db	"staT"
      1  0db0		       73 74 61 54	      .byte.b	"staT"
      0  0db4					      db	"abS"
      1  0db4		       61 62 53 	      .byte.b	"abS"
      0  0db7					      db	"calL"
      1  0db7		       63 61 6c 4c	      .byte.b	"calL"
      0  0dbb					      db	"gofN"
      1  0dbb		       67 6f 66 4e	      .byte.b	"gofN"
      0  0dbf					      db	0,0
      1  0dbf		       00 00		      .byte.b	0,0
     79  0dbf		       0d c1	   KeyWordTableEnd equ	*
     80  0dbf		       00 c1	   KeyWordTableLength equ	* - KeyWordTable
     81  0dc1		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
     82  0ec1		       00 00 00    printStorage ds	3
     83  0ec4							;==================================================================================================================
     84  0ec4							; Read accross the inputline and output to TOKENBUFFER
     85  0ec4							; Format   byte      Description
     86  0ec4							;	     0	      length of line 1-255
     87  0ec4							;	    0-1       Line Number
     88  0ec4							;	    Tokens and litteral values encoded into the line
     89  0ec4							;
     90  0ec4							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
     91  0ec4							;  if fails then test for keywords
     92  0ec4							;  if fails then test for variables and arrays
     93  0ec4							;  if fails check for operators + - < > = % / * ()
     94  0ec4				   ParseInputLine
     95  0ec4					      if	DEBUGPARSER
     96  0ec4		       20 6c 1c 	      jsr	SetOutDebug
     97  0ec7		       20 85 10 	      jsr	DebugClearBuffer
     98  0eca					      endif
     99  0eca		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    100  0ecc		       20 0f 18 	      jsr	getDecimal	; Check for a line number, none is ok too
    101  0ecf		       84 51		      sty	CUROFF
    102  0ed1		       20 ce 10 	      jsr	R02TOKEN	; Move R0 to token buffer
    103  0ed4
    104  0ed4				   ParseInputLoop
    105  0ed4		       a4 51		      ldy	CUROFF
    106  0ed6		       20 91 1a 	      jsr	SkipSpaces	; Skip any spaces
    107  0ed9		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    108  0edb		       b9 90 2b 	      lda	LINBUF,y	; Check for end of line
    109  0ede		       f0 2d		      beq	ParseComplete	; Finish token buffer and return
    110  0ee0
    111  0ee0				   ParseForString
    112  0ee0		       20 81 0f 	      jsr	ParseString	; Check for a string
    113  0ee3		       90 ef		      bcc	ParseInputLoop	; It was a string
    114  0ee5
    115  0ee5				   ParseForKey
    116  0ee5		       20 1c 0f 	      jsr	ParseLookupKey	; Check for a keyword value
    117  0ee8		       b0 02		      bcs	ParseForNumber	; Go look for a number
    118  0eea		       90 e8		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    119  0eec
    120  0eec				   ParseForNumber
    121  0eec		       20 ab 0f 	      jsr	ParseNumeric	; Check for a numeric value
    122  0eef		       b0 02		      bcs	ParseForOp	; Check for some form of operator
    123  0ef1		       90 e1		      bcc	ParseInputLoop	; Go Back for next element
    124  0ef3
    125  0ef3				   ParseForOp
    126  0ef3		       20 1c 10 	      jsr	ParseForOperator
    127  0ef6		       b0 02		      bcs	ParseForVar	; Check for variables
    128  0ef8		       d0 da		      bne	ParseInputLoop
    129  0efa
    130  0efa				   ParseForVar
    131  0efa		       20 97 10 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    132  0efd		       b0 02		      bcs	ParseKeepChar	; If we can match nothing then error get output
    133  0eff		       90 d3		      bcc	ParseInputLoop
    134  0f01
    135  0f01				   ParseKeepChar		; if it does not parse just keep it safe
    136  0f01		       b9 90 2b 	      lda	LINBUF,y
    137  0f04		       9d c1 0d 	      sta	TOKENBUFFER,x
    138  0f07		       e8		      inx
    139  0f08		       c8		      iny
    140  0f09		       84 51		      sty	CUROFF
    141  0f0b		       d0 c7		      bne	ParseInputLoop
    142  0f0d
    143  0f0d				   ParseComplete
    144  0f0d		       8e c1 0d 	      stx	TOKENBUFFER	; Place size into buffer start
    145  0f10		       a9 00		      lda	#0
    146  0f12		       9d c1 0d 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    147  0f15					      if	DEBUGPARSER
    148  0f15		       20 eb 10 	      jsr	PrintProgramLine
    149  0f18		       20 c9 1b 	      jsr	SetOutConsole
    150  0f1b					      endif
    151  0f1b		       60		      rts
    152  0f1c
    153  0f1c							;==================================================================================================================
    154  0f1c							; Look at curptr, curpos and check for a valid KeyWord
    155  0f1c							; A contains the index value. c is clear
    156  0f1c							;		     not found c set  A undefined
    157  0f1c							; X is prerserved
    158  0f1c							;
    159  0f1c				   ParseLookupKey
    160  0f1c		       86 58		      stx	R2
    161  0f1e		       a4 51		      ldy	CUROFF
    162  0f20		       a2 00		      ldx	#0
    163  0f22		       a9 01		      lda	#1
    164  0f24		       85 52		      sta	R0	; at the end this will contain the index of the keyword
    165  0f26					      if	DEBUGPARSER
    166  0f26		       20 5a 10 	      jsr	DebugKeyword
    167  0f29					      endif
    168  0f29		       a9 3f		      lda	#'?	; check for fast form of print
    169  0f2b		       d9 90 2b 	      cmp	LINBUF,y
    170  0f2e		       d0 04		      bne	ParseLookupLoop	; Skip to loop if not ?
    171  0f30		       a9 0b		      lda	#kPrint	; Number for print
    172  0f32		       d0 25		      bne	ParseKeySpecial	; Get out with the special case
    173  0f34
    174  0f34				   ParseLookupLoop
    175  0f34		       bd 00 0d 	      lda	KeyWordTable,x	; Check both upper and lower characters
    176  0f37		       29 df		      and	#%11011111	; Force Keyword to upper case
    177  0f39		       d9 90 2b 	      cmp	LINBUF,y
    178  0f3c		       f0 07		      beq	ParseNextLetter
    179  0f3e		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    180  0f40		       d9 90 2b 	      cmp	LINBUF,y
    181  0f43		       d0 1f		      bne	ParseNextEntry
    182  0f45
    183  0f45				   ParseNextLetter
    184  0f45		       bd 00 0d 	      lda	KeyWordTable,x	; Check if we just processed the last letter
    185  0f48		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    186  0f4a		       f0 0b		      beq	ParseKeyFound
    187  0f4c		       e8		      inx
    188  0f4d		       c8		      iny
    189  0f4e		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    190  0f50		       d9 90 2b 	      cmp	LINBUF,y
    191  0f53		       f0 0f		      beq	ParseNextEntry	; End of buffer but no keyword
    192  0f55		       d0 dd		      bne	ParseLookupLoop
    193  0f57
    194  0f57				   ParseKeyFound
    195  0f57		       a5 52		      lda	R0
    196  0f59
    197  0f59				   ParseKeySpecial
    198  0f59		       c8		      iny		;point past the last character
    199  0f5a		       84 51		      sty	CUROFF
    200  0f5c		       a6 58		      ldx	R2	; preserved the X pointer
    201  0f5e		       9d c1 0d 	      sta	TOKENBUFFER,x
    202  0f61		       e8		      inx
    203  0f62		       18		      clc
    204  0f63		       60		      rts
    205  0f64
    206  0f64							; Move forward to the next entry in table
    207  0f64				   ParseNextEntry
    208  0f64		       bd 00 0d 	      lda	KeyWordTable,x
    209  0f67		       29 20		      and	#%00100000
    210  0f69		       f0 03		      beq	ParseEndOfEntry
    211  0f6b		       e8		      inx
    212  0f6c		       d0 f6		      bne	ParseNextEntry
    213  0f6e
    214  0f6e				   ParseEndOfEntry
    215  0f6e		       e8		      inx
    216  0f6f					      if	DEBUGPARSER
    217  0f6f		       20 5a 10 	      jsr	DebugKeyword
    218  0f72					      endif
    219  0f72		       e6 52		      inc	R0	; Point to next index
    220  0f74		       a4 51		      ldy	CUROFF	; Restore Y to start of the parse
    221  0f76		       bd 00 0d 	      lda	KeyWordTable,x
    222  0f79		       f0 02		      beq	ParseNoneFound
    223  0f7b		       d0 b7		      bne	ParseLookupLoop
    224  0f7d
    225  0f7d				   ParseNoneFound
    226  0f7d		       a6 58		      ldx	R2
    227  0f7f		       38		      sec
    228  0f80		       60		      rts
    229  0f81
    230  0f81							;=========================================================================================================
    231  0f81							;ParseString Parse a quotes string
    232  0f81							; on input X = outbuf position
    233  0f81							; y = inbuf position
    234  0f81							; Copies string to output buffer, updates x and y
    235  0f81				   ParseString
    236  0f81		       a4 51		      ldy	CUROFF
    237  0f83		       a9 a1		      lda	#tString
    238  0f85		       9d c1 0d 	      sta	TOKENBUFFER,X
    239  0f88		       b9 90 2b 	      lda	LINBUF,y
    240  0f8b		       c9 22		      cmp	#'"
    241  0f8d		       d0 1a		      bne	ParseStringInvalid
    242  0f8f		       e8		      inx
    243  0f90		       9d c1 0d 	      sta	TOKENBUFFER,x
    244  0f93		       e8		      inx
    245  0f94		       c8		      iny
    246  0f95
    247  0f95				   ParseStringLoop
    248  0f95		       b9 90 2b 	      lda	LINBUF,y
    249  0f98		       9d c1 0d 	      sta	TOKENBUFFER,x
    250  0f9b		       c9 22		      cmp	#'"
    251  0f9d		       f0 04		      beq	ParseStringDone
    252  0f9f		       c8		      iny
    253  0fa0		       e8		      inx
    254  0fa1		       d0 f2		      bne	ParseStringLoop
    255  0fa3
    256  0fa3				   ParseStringDone
    257  0fa3		       e8		      inx
    258  0fa4		       c8		      iny
    259  0fa5		       84 51		      sty	CUROFF
    260  0fa7		       18		      clc
    261  0fa8		       60		      rts
    262  0fa9
    263  0fa9				   ParseStringInvalid
    264  0fa9		       38		      sec
    265  0faa		       60		      rts
    266  0fab
    267  0fab							;=========================================================================================================
    268  0fab							; Get numeric values and return value in RO and type in a
    269  0fab							;
    270  0fab				   ParseNumeric
    271  0fab		       a4 51		      ldy	CUROFF
    272  0fad		       b9 90 2b 	      lda	LINBUF,y
    273  0fb0		       c9 30		      cmp	#'0
    274  0fb2		       90 33		      bcc	ParseNumInvalid
    275  0fb4		       c9 3a		      cmp	#'9+1
    276  0fb6		       b0 2f		      bcs	ParseNumInvalid
    277  0fb8		       86 58		      stx	R2
    278  0fba		       20 0f 18 	      jsr	getDecimal
    279  0fbd		       a6 58		      ldx	R2
    280  0fbf		       84 51		      sty	CUROFF
    281  0fc1		       a5 53		      lda	R0+1
    282  0fc3		       f0 14		      beq	ParseByteValue
    283  0fc5
    284  0fc5				   ParseIntegerValue
    285  0fc5		       a9 a0		      lda	#tInteger
    286  0fc7		       9d c1 0d 	      sta	TOKENBUFFER,x
    287  0fca		       e8		      inx
    288  0fcb		       a5 52		      lda	R0
    289  0fcd		       9d c1 0d 	      sta	TOKENBUFFER,x
    290  0fd0		       e8		      inx
    291  0fd1		       a5 53		      lda	R0+1
    292  0fd3		       9d c1 0d 	      sta	TOKENBUFFER,X
    293  0fd6		       e8		      inx
    294  0fd7		       18		      clc
    295  0fd8		       60		      rts
    296  0fd9
    297  0fd9				   ParseByteValue
    298  0fd9		       a9 a2		      lda	#tByte
    299  0fdb		       9d c1 0d 	      sta	TOKENBUFFER,x
    300  0fde		       e8		      inx
    301  0fdf		       a5 52		      lda	R0
    302  0fe1		       9d c1 0d 	      sta	TOKENBUFFER,x
    303  0fe4		       e8		      inx
    304  0fe5		       18		      clc
    305  0fe6		       60		      rts
    306  0fe7
    307  0fe7				   ParseNumInvalid		;Not a valid Numeric
    308  0fe7		       38		      sec
    309  0fe8		       60		      rts
    310  0fe9
    311  0fe9							;=========================================================================================================
    312  0fe9							;Parse for operators
    313  0fe9							; +($F0), <($F1),=($F2),<=($F3), >($F4), <>($F5), >=($F6), -($F7), /($F8), %($F9), *($FA), (($FB), )($FC)
    314  0fe9							; on exit the A has the oper code, c is clear
    315  0fe9							;		 not found then c is set
    316  0fe9							;	x is preserved
    317  0fe9							;
    318  0fe9		       3c 3e 3c 3d*Operators  BYTE.b	"<>","<=",">=",'+,0,'<,0,'=,0,">",0,"-",0,"/",0,"%",0,"*",0,"(",0,")",0,",",0,";",0,"[",0,"]",0
    319  0fe9		       00 22	   OperatorLen equ	*-Operators
    320  100b
    321  100b		       f5 f3 f6 f0*OperValues BYTE.b	$F5,$F3,$F6,$F0,$F1,$F2,$F4,$F7,$F8,$F9,$FA,$E0,$E1,$E2,$E3,$E4,$E5
    322  100b		       00 11	   OPCount    equ	* - OperValues
    323  101c
    324  101c				   ParseForOperator
    325  101c		       86 58		      stx	R2
    326  101e		       a4 51		      ldy	CUROFF
    327  1020		       a6 00		      ldx	0
    328  1022					      if	DEBUGPARSER
    329  1022		       20 71 10 	      jsr	DebugPrintOP
    330  1025					      endif
    331  1025				   ParseOpLoop
    332  1025		       bd e9 0f 	      lda	Operators,x
    333  1028		       d9 90 2b 	      cmp	LINBUF,y
    334  102b		       d0 1c		      bne	ParseOpNext
    335  102d		       c8		      iny
    336  102e		       bd ea 0f 	      lda	Operators+1,x
    337  1031		       f0 06		      beq	ParseOpFoundSingle
    338  1033		       d9 90 2b 	      cmp	LINBUF,y
    339  1036		       d0 11		      bne	ParseOpNext
    340  1038
    341  1038				   ParseOpFound
    342  1038		       c8		      iny
    343  1039
    344  1039				   ParseOpFoundSingle
    345  1039		       84 51		      sty	CUROFF
    346  103b
    347  103b		       8a		      txa
    348  103c		       4a		      lsr
    349  103d		       aa		      tax
    350  103e		       bd 0b 10 	      lda	OperValues,x
    351  1041		       a6 58		      ldx	R2
    352  1043		       9d c1 0d 	      sta	TOKENBUFFER,x
    353  1046		       e8		      inx
    354  1047		       18		      clc
    355  1048		       60		      rts
    356  1049
    357  1049				   ParseOpNext
    358  1049		       e8		      inx
    359  104a		       e8		      inx
    360  104b		       e0 22		      cpx	#OperatorLen
    361  104d		       b0 07		      bcs	ParseOpNotFound
    362  104f					      if	DEBUGPARSER
    363  104f		       20 71 10 	      jsr	DebugPrintOP
    364  1052					      endif
    365  1052		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    366  1054		       d0 cf		      bne	ParseOpLoop
    367  1056
    368  1056				   ParseOpNotFound
    369  1056		       a6 58		      ldx	R2
    370  1058		       38		      sec
    371  1059		       60		      rts
    372  105a							;=========================================================================================================
    373  105a					      if	DEBUGPARSER
    374  105a							;Print the text of a keyword
    375  105a							;Input x = offset into table
    376  105a				   DebugKeyword
    377  105a		       48		      pha
    378  105b		       8a		      txa
    379  105c		       48		      pha
    380  105d				   DebugKeyLoop
    381  105d		       bd 00 0d 	      lda	KeyWordTable,x
    382  1060		       20 e3 1b 	      jsr	VOUTCH
    383  1063		       29 20		      and	#%00100000
    384  1065		       f0 03		      beq	DebugKeyDone
    385  1067		       e8		      inx
    386  1068		       d0 f3		      bne	DebugKeyLoop
    387  106a
    388  106a				   DebugKeyDone
    389  106a		       20 9a 1a 	      jsr	CRLF
    390  106d		       68		      pla
    391  106e		       aa		      tax
    392  106f		       68		      pla
    393  1070		       60		      rts
    394  1071							;========================================
    395  1071				   DebugPrintOP
    396  1071		       48		      pha
    397  1072		       bd e9 0f 	      lda	Operators,x
    398  1075		       20 e3 1b 	      jsr	VOUTCH
    399  1078		       bd ea 0f 	      lda	Operators+1,x
    400  107b		       f0 03		      beq	DbgPrtOpDone
    401  107d		       20 e3 1b 	      jsr	VOUTCH
    402  1080
    403  1080				   DbgPrtOpDone
    404  1080		       20 9a 1a 	      jsr	CRLF
    405  1083		       68		      pla
    406  1084		       60		      rts
    407  1085							;=======================================
    408  1085				   DebugClearBuffer
    409  1085		       8a		      txa
    410  1086		       48		      pha
    411  1087		       a2 ff		      ldx	#$FF
    412  1089		       a9 00		      lda	#0
    413  108b				   DebugClrLoop
    414  108b		       9d c1 0d 	      sta	TOKENBUFFER,x
    415  108e		       ca		      dex
    416  108f		       d0 fa		      bne	DebugClrLoop
    417  1091		       9d c1 0d 	      sta	TOKENBUFFER,x
    418  1094		       68		      pla
    419  1095		       aa		      tax
    420  1096		       60		      rts
    421  1097					      endif
    422  1097
    423  1097
    424  1097							;=========================================================================================================
    425  1097							; Parse for variables A-Z @, ^  x!x x[op]
    426  1097				   ParseForVariable
    427  1097		       a4 51		      ldy	CUROFF
    428  1099		       b9 90 2b 	      lda	LINBUF,y
    429  109c		       c9 5e		      cmp	#'^	; is it an exit code
    430  109e		       d0 04		      bne	ParseVarMem
    431  10a0		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    432  10a2		       d0 1f		      bne	ParseVarSpecial
    433  10a4
    434  10a4				   ParseVarMem
    435  10a4		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    436  10a6		       d0 04		      bne	ParseVarStack
    437  10a8		       a9 9d		      lda	#tVat
    438  10aa		       d0 17		      bne	ParseVarSpecial
    439  10ac
    440  10ac				   ParseVarStack
    441  10ac		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    442  10ae		       d0 04		      bne	ParseVarLetters
    443  10b0		       a9 9c		      lda	#tVhash
    444  10b2		       d0 0f		      bne	ParseVarSpecial
    445  10b4
    446  10b4				   ParseVarLetters
    447  10b4		       29 df		      and	#%11011111	; Force upper case
    448  10b6		       c9 41		      cmp	#'A
    449  10b8		       90 12		      bcc	ParseVarInvalid
    450  10ba		       c9 5b		      cmp	#'Z+1
    451  10bc		       b0 0e		      bcs	ParseVarInvalid
    452  10be							;
    453  10be							; The condition is true, so convert to an index, push
    454  10be							; it onto the stack and continue running.
    455  10be							;
    456  10be		       38		      sec
    457  10bf		       e9 41		      sbc	#'A	;index is zero based
    458  10c1		       09 80		      ora	#$80
    459  10c3
    460  10c3				   ParseVarSpecial
    461  10c3		       9d c1 0d 	      sta	TOKENBUFFER,x
    462  10c6		       e8		      inx
    463  10c7		       c8		      iny
    464  10c8		       84 51		      sty	CUROFF
    465  10ca		       18		      clc
    466  10cb		       60		      rts
    467  10cc
    468  10cc				   ParseVarInvalid
    469  10cc		       38		      sec
    470  10cd		       60		      rts
    471  10ce
    472  10ce
    473  10ce							;=========================================================================================================
    474  10ce							; Transfer R0 to the TOKENBUFFER
    475  10ce							;
    476  10ce				   R02TOKEN
    477  10ce		       a5 52		      lda	R0
    478  10d0		       9d c1 0d 	      sta	TOKENBUFFER,x
    479  10d3		       e8		      inx
    480  10d4		       a5 53		      lda	R0+1
    481  10d6		       9d c1 0d 	      sta	TOKENBUFFER,x
    482  10d9		       e8		      inx
    483  10da		       18		      clc
    484  10db		       60		      rts
    485  10dc				   TOKEN2R0
    486  10dc		       b9 c1 0d 	      lda	TOKENBUFFER,y
    487  10df		       85 52		      sta	R0
    488  10e1		       c8		      iny
    489  10e2		       ca		      dex
    490  10e3		       b9 c1 0d 	      lda	TOKENBUFFER,y
    491  10e6		       c8		      iny
    492  10e7		       ca		      dex
    493  10e8		       85 53		      sta	R0+1
    494  10ea		       60		      rts
    495  10eb
    496  10eb							;==========================================================================================================
    497  10eb							; Decode and print a line of grogram text
    498  10eb							; Prints line number from R0 upto line number in R1 if r1 is 0 then prints to end
    499  10eb							; if R0 and R1 = 0 then print entire program.
    500  10eb							;
    501  10eb				   PrintProgramLine
    502  10eb		       8e c1 0e 	      stx	printStorage
    503  10ee		       8c c2 0e 	      sty	printStorage+1
    504  10f1
    505  10f1		       a0 01		      ldy	#1	; index into the token buffer
    506  10f3		       84 58		      sty	R2	; print unsigned decimal
    507  10f5		       ae c1 0d 	      ldx	TOKENBUFFER	; get number of bytes
    508  10f8		       ca		      dex		; Deduct the length byte
    509  10f9		       20 dc 10 	      jsr	TOKEN2R0	; Print the line number
    510  10fc		       20 d6 11 	      jsr	PrintDecimal
    511  10ff		       a9 20		      lda	#$20
    512  1101		       20 e3 1b 	      jsr	VOUTCH
    513  1104
    514  1104				   PrintProgLoop
    515  1104		       b9 c1 0d 	      lda	TOKENBUFFER,y	; Get a character
    516  1107		       f0 3c		      beq	PrintProgramComplete
    517  1109		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    518  110b		       f0 44		      beq	PrintKeyword	; It uses the index in a to find a keyword
    519  110d
    520  110d				   PrintProgVars
    521  110d		       b9 c1 0d 	      lda	TOKENBUFFER,y
    522  1110		       29 e0		      and	#$E0	; Check for operators and punctuation
    523  1112		       c9 e0		      cmp	#$E0
    524  1114		       f0 6e		      beq	PrintProgOperator
    525  1116		       b9 c1 0d 	      lda	TOKENBUFFER,y
    526  1119		       c9 9e		      cmp	#$9D+1
    527  111b		       90 32		      bcc	PrintProgVariableVec
    528  111d		       c8		      iny		; we have a numerical value
    529  111e		       ca		      dex
    530  111f		       48		      pha
    531  1120		       a9 00		      lda	#0
    532  1122		       85 53		      sta	R0+1
    533  1124		       85 58		      sta	R2	; Set to print signed number
    534  1126		       b9 c1 0d 	      lda	TOKENBUFFER,y
    535  1129		       85 52		      sta	R0
    536  112b		       68		      pla
    537  112c		       c9 a0		      cmp	#tInteger
    538  112e		       d0 07		      bne	PrintProgNumDone
    539  1130		       c8		      iny
    540  1131		       ca		      dex
    541  1132		       b9 c1 0d 	      lda	TOKENBUFFER,y
    542  1135		       85 53		      sta	R0+1
    543  1137
    544  1137				   PrintProgNumDone
    545  1137		       c8		      iny
    546  1138		       ca		      dex
    547  1139		       20 d6 11 	      jsr	PrintDecimal
    548  113c
    549  113c				   PrintProgNext
    550  113c		       a9 20		      lda	#$20
    551  113e		       20 e3 1b 	      jsr	VOUTCH
    552  1141				   PrintProgSkipSpace
    553  1141		       e0 00		      cpx	#0
    554  1143		       d0 bf		      bne	PrintProgLoop
    555  1145				   PrintProgramComplete
    556  1145		       20 9a 1a 	      jsr	CRLF
    557  1148
    558  1148		       ae c1 0e 	      ldx	printStorage
    559  114b		       ac c2 0e 	      ldy	printStorage+1
    560  114e
    561  114e		       60		      rts
    562  114f
    563  114f				   PrintProgVariableVec
    564  114f		       90 5d		      bcc	PrintProgVariable
    565  1151							;===============================================================================================================
    566  1151				   PrintKeyword
    567  1151		       b9 c1 0d 	      lda	TOKENBUFFER,y
    568  1154		       ca		      dex
    569  1155		       c8		      iny
    570  1156		       85 52		      sta	R0	; the counter save area
    571  1158		       8e c3 0e 	      stx	printStorage+2
    572  115b		       a2 00		      ldx	#0
    573  115d				   PrintKeyLoop
    574  115d		       c6 52		      dec	R0	; Keyword indexes are 1 relative, adjust to zero relative
    575  115f		       a9 00		      lda	#0
    576  1161		       c5 52		      cmp	R0
    577  1163		       f0 0a		      Beq	PrintKeyFound	; We have the correct index, now print it
    578  1165				   PrintKeyNext
    579  1165		       bd 00 0d 	      lda	KeyWordTable,x
    580  1168		       e8		      inx		; Point to next byte always
    581  1169		       29 20		      and	#%00100000
    582  116b		       f0 f0		      beq	PrintKeyLoop
    583  116d		       d0 f6		      bne	PrintKeyNext
    584  116f
    585  116f				   PrintKeyFound
    586  116f		       bd 00 0d 	      lda	KeyWordTable,x
    587  1172		       48		      pha
    588  1173		       09 20		      ora	#%00100000
    589  1175		       20 e3 1b 	      jsr	VOUTCH
    590  1178		       e8		      inx
    591  1179		       68		      pla
    592  117a		       29 20		      and	#%00100000
    593  117c		       d0 f1		      bne	PrintKeyFound
    594  117e
    595  117e		       ae c3 0e 	      ldx	printStorage+2
    596  1181		       4c 3c 11 	      jmp	PrintProgNext
    597  1184							;==================================================================================================================
    598  1184							;Print Variable, number or operator
    599  1184				   PrintProgOperator
    600  1184		       b9 c1 0d 	      lda	TOKENBUFFER,y
    601  1187		       c8		      iny
    602  1188		       ca		      dex
    603  1189		       8e c3 0e 	      stx	printStorage+2
    604  118c		       a2 00		      ldx	#0
    605  118e				   PrintOprLoop
    606  118e		       dd 0b 10 	      cmp	OperValues,x
    607  1191		       f0 03		      beq	PrintOprFound
    608  1193		       e8		      inx
    609  1194		       d0 f8		      bne	PrintOprLoop
    610  1196				   PrintOprFound
    611  1196		       8a		      txa
    612  1197		       0a		      asl
    613  1198		       aa		      tax
    614  1199		       bd e9 0f 	      lda	Operators,x
    615  119c		       20 e3 1b 	      jsr	VOUTCH
    616  119f		       e8		      inx
    617  11a0		       bd e9 0f 	      lda	Operators,x
    618  11a3		       f0 03		      beq	PrintOprDone
    619  11a5		       20 e3 1b 	      jsr	VOUTCH
    620  11a8				   PrintOprDone
    621  11a8		       ae c3 0e 	      ldx	printStorage+2
    622  11ab		       4c 3c 11 	      jmp	PrintProgNext
    623  11ae
    624  11ae							;=================================================================================================================
    625  11ae							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    626  11ae							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    627  11ae							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    628  11ae							;tVhat 	    equ     155 		   ; Variable ^
    629  11ae							;tVhash	    equ     156 		   ; Variable #
    630  11ae							;tVat		    equ     157 		   ; Variable @ = 0
    631  11ae				   PrintProgVariable
    632  11ae		       b9 c1 0d 	      lda	TOKENBUFFER,y
    633  11b1		       c8		      iny
    634  11b2		       ca		      dex
    635  11b3		       c5 9b		      cmp	tVhat
    636  11b5		       d0 04		      bne	PrintProgChkHash
    637  11b7		       a9 5e		      lda	#'^
    638  11b9		       d0 15		      bne	PrintTheVar
    639  11bb				   PrintProgChkHash
    640  11bb		       c5 9c		      cmp	tVhash
    641  11bd		       d0 04		      bne	PrintProgChkAt
    642  11bf		       a9 23		      lda	#'#
    643  11c1		       d0 0d		      bne	PrintTheVar
    644  11c3				   PrintProgChkAt
    645  11c3		       c5 9d		      cmp	tVat
    646  11c5		       d0 04		      bne	PrintProgVarLetter
    647  11c7		       a9 40		      lda	#'@
    648  11c9		       d0 05		      bne	PrintTheVar
    649  11cb				   PrintProgVarLetter
    650  11cb		       29 7f		      and	#%01111111
    651  11cd		       18		      clc
    652  11ce		       69 41		      adc	#'A
    653  11d0				   PrintTheVar
    654  11d0		       20 e3 1b 	      jsr	VOUTCH
    655  11d3		       4c 3c 11 	      jmp	PrintProgNext
    656  11d6
    657  11d6
    658  11d6
    659  11d6
    660  11d6
    661  11d6
    662  11d6
    663  11d6
    664  11d6
    665  11d6
    666  11d6
    667  11d6
    668  11d6
    669  11d6
    670  11d6
    671  11d6
    672  11d6
    673  11d6
    674  11d6
    675  11d6
    676  11d6
    677  11d6
    678  11d6
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  11d6					      include	"print.asm"
      1  11d6					      Seg	Code
      2  11d6							;---------------------------
      3  11d6							; Print 24-bit decimal number or  16bit unsigned
      4  11d6							; ---------------------------
      5  11d6							; On entry, R0=number to print
      6  11d6							;	     Defaults to pad=0 , y=21 default
      7  11d6							;	     R2 = 1 unsigned 16 bit
      8  11d6							;	     R2 = 0 Signed   16 bit
      9  11d6
     10  11d6							; On entry at PrintDecPadded:
     11  11d6							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  11d6
     13  11d6							; On exit,  A,X,Y,num,pad corrupted
     14  11d6							; Size      129 bytes, Table 24 bytes	--- total 153
     15  11d6							; -----------------------------------------------------------------
     16  11d6
     17  11d6				   PrintDecimal
     18  11d6		       8a		      TXA
     19  11d7		       48		      pha
     20  11d8		       98		      tya
     21  11d9		       48		      pha
     22  11da		       a9 00		      lda	#0
     23  11dc		       8d 6f 12 	      sta	pad
     24  11df		       a0 15		      LDY	#21	; Offset to powers of ten
     25  11e1		       4c e7 11 	      JMP	PrintDo
     26  11e4
     27  11e4				   PrintDecPadded
     28  11e4		       8e 6f 12 	      stx	pad
     29  11e7
     30  11e7				   PrintDo
     31  11e7		       a9 00		      lda	#0
     32  11e9		       85 54		      sta	R1
     33  11eb
     34  11eb		       a5 58		      lda	R2
     35  11ed		       d0 29		      bne	PrintPos
     36  11ef
     37  11ef		       a5 53		      lda	R0+1	;MSB has sign
     38  11f1		       10 25		      bpl	PrintPos	;it's a positive number;
     39  11f3
     40  11f3
     41  11f3							; Negative numbers need more work.  Invert all the bits,
     42  11f3							; then add one.
     43  11f3
     44  11f3		       a9 2d		      lda	#'-
     45  11f5		       20 e3 1b 	      jsr	VOUTCH	;print the negative sign
     46  11f8
     47  11f8		       a9 ff		      lda	#$FF
     48  11fa		       85 54		      sta	R1
     49  11fc		       a5 52		      lda	R0	;invert bits
     50  11fe		       49 ff		      eor	#$ff
     51  1200		       85 52		      sta	R0
     52  1202		       a5 53		      lda	R0+1
     53  1204		       49 ff		      eor	#$ff
     54  1206		       85 53		      sta	R0+1
     55  1208		       a5 54		      lda	R1
     56  120a		       49 ff		      eor	#$ff
     57  120c		       85 54		      sta	R1
     58  120e		       e6 52		      inc	R0	;add one
     59  1210		       d0 06		      bne	PrintPos
     60  1212		       e6 53		      inc	R0+1
     61  1214		       d0 02		      bne	PrintPos
     62  1216		       e6 54		      inc	R1
     63  1218				   PrintPos
     64  1218
     65  1218				   PrDec24Lp1
     66  1218		       a2 ff		      LDX	#$FF
     67  121a		       38		      SEC		; Start with digit=-1
     68  121b				   PrDec24Lp2
     69  121b		       a5 52		      LDA	R0+0
     70  121d		       f9 70 12 	      SBC	PrDec24Tens+0,Y
     71  1220		       85 52		      STA	R0+0	; Subtract current tens
     72  1222		       a5 53		      LDA	R0+1
     73  1224		       f9 71 12 	      SBC	PrDec24Tens+1,Y
     74  1227		       85 53		      STA	R0+1
     75  1229		       a5 54		      LDA	R0+2
     76  122b		       f9 72 12 	      SBC	PrDec24Tens+2,Y
     77  122e		       85 54		      STA	R0+2
     78  1230		       e8		      INX
     79  1231		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  1233		       a5 52		      LDA	R0+0
     81  1235		       79 70 12 	      ADC	PrDec24Tens+0,Y
     82  1238		       85 52		      STA	R0+0	; Add current tens back in
     83  123a		       a5 53		      LDA	R0+1
     84  123c		       79 71 12 	      ADC	PrDec24Tens+1,Y
     85  123f		       85 53		      STA	R0+1
     86  1241		       a5 54		      LDA	R0+2
     87  1243		       79 72 12 	      ADC	PrDec24Tens+2,Y
     88  1246		       85 54		      STA	R0+2
     89  1248		       8a		      TXA
     90  1249		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  124b		       ad 6f 12 	      LDA	pad
     92  124e		       d0 09		      BNE	PrDec24Print
     93  1250		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  1252				   PrDec24Digit
     95  1252		       a2 30		      LDX	#'0
     96  1254		       8e 6f 12 	      STX	pad	; No more zero padding
     97  1257		       09 30		      ORA	#'0	; Print this digit
     98  1259				   PrDec24Print
     99  1259		       20 e3 1b 	      JSR	VOUTCH
    100  125c				   PrDec24Next
    101  125c		       88		      DEY
    102  125d		       88		      DEY
    103  125e		       88		      DEY
    104  125f		       f0 07		      beq	PrDec24LastDigit
    105  1261		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  1263		       68		      pla
    107  1264		       a8		      tay
    108  1265		       68		      pla
    109  1266		       aa		      tax
    110  1267		       60		      RTS
    111  1268				   PrDec24LastDigit
    112  1268		       a2 30		      LDX	#'0
    113  126a		       8e 6f 12 	      STX	pad	; No more zero padding
    114  126d		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  126f
      0  126f				   pad	      db	0
      1  126f		       00		      .byte.b	0
    117  1270				   PrDec24Tens
      0  1270					      dw	1
      1  1270		       01 00		      .word.w	1
      0  1272					      db	1 / 65536
      1  1272		       00		      .byte.b	1 / 65536
      0  1273					      dw	10
      1  1273		       0a 00		      .word.w	10
      0  1275					      db	10 / 65536
      1  1275		       00		      .byte.b	10 / 65536
      0  1276					      dw	100
      1  1276		       64 00		      .word.w	100
      0  1278					      db	100 / 65536
      1  1278		       00		      .byte.b	100 / 65536
      0  1279					      dw	1000
      1  1279		       e8 03		      .word.w	1000
      0  127b					      db	1000 / 65536
      1  127b		       00		      .byte.b	1000 / 65536
      0  127c					      dw	10000
      1  127c		       10 27		      .word.w	10000
      0  127e					      db	10000 / 65536
      1  127e		       00		      .byte.b	10000 / 65536
      0  127f					      dw	100000
      1  127f		       a0 86		      .word.w	100000
      0  1281					      db	100000 / 65536
      1  1281		       01		      .byte.b	100000 / 65536
      0  1282					      dw	1000000
      1  1282		       40 42		      .word.w	1000000
      0  1284					      db	1000000 / 65536
      1  1284		       0f		      .byte.b	1000000 / 65536
      0  1285					      dw	10000000
      1  1285		       80 96		      .word.w	10000000
      0  1287					      db	10000000 / 65536
      1  1287		       98		      .byte.b	10000000 / 65536
    134  1288							;=====================================================
    135  1288							; Print character in A as two hex digits to the
    136  1288
    137  1288
    138  1288		       48	   HexToOut   pha		;save return value
    139  1289		       48		      pha
    140  128a		       4a		      lsr		;a  ;move top nibble to bottom
    141  128b		       4a		      lsr		;a
    142  128c		       4a		      lsr		;a
    143  128d		       4a		      lsr		;a
    144  128e		       20 97 12 	      jsr	hexta	;output nibble
    145  1291		       68		      pla
    146  1292		       20 97 12 	      jsr	hexta
    147  1295		       68		      pla		;restore
    148  1296		       60		      rts
    149  1297							;
    150  1297		       29 0f	   hexta      and	#%0001111
    151  1299		       c9 0a		      cmp	#$0a
    152  129b		       18		      clc
    153  129c		       30 02		      bmi	hexta1
    154  129e		       69 07		      adc	#7
    155  12a0		       69 30	   hexta1     adc	#'0	;then fall into...
    156  12a2		       4c e3 1b 	      jmp	VOUTCH
    157  12a5							;
    158  12a5							;==================================================================================================
    159  12a5							; Size of print functions
    160  12a5		       00 cf	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  12a5					      include	"mem.asm"
      1  12a5							;===================================================================
      2  12a5							;This file contains the memory allocation and free functions
      3  12a5							;in herant in this is the management of free memory in the system
      4  12a5							; the interface to these functions
      5  12a5							; a,x returns or provides the low hi bytes of the managed addresses
      6  12a5							; This uses the programend, to memory end as the area to manage
      7  12a5							;===================================================================
      8  12a5					      Seg	Code
      9  12a5							;=====================================================
     10  12a5							;Pointers for memory Management
     11  12a5							;Allocated block are not chained but can be followed for all memory by the associated length
     12  12a5							; Mem block format is
     13  12a5							;	 0-1   pointer to next block for free blocks
     14  12a5							;	 0-1   for allocated blocks
     15  12a5							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  12a5							;	   1   refrence counter ... lol only up to 256 but it is something
     17  12a5							;	 2-3   length constant for exevy type of memory block
     18  12a5							; Memory is recombined as it is released
     19  12a5							; The memory manager is not interupted durring allocation
     20  12a5							; or freeing of memory
     21  12a5							; Memory is allocated from the highest memory address towards
     22  12a5							; the lowest memory address. meeting the Basic program end.
     23  12a5							;====================================================
     24  12a5							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  12a5							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  12a5							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  12a5							;=====================================================
     28  12a5				   MemInit
     29  12a5		       a9 37		      lda	#FreeMemStart&$FF
     30  12a7		       8d 2d 2c 	      sta	ProgramStart
     31  12aa		       8d 2f 2c 	      sta	ProgramEnd
     32  12ad		       a9 2c		      lda	#FreeMemStart>>8
     33  12af		       8d 2e 2c 	      sta	ProgramStart+1
     34  12b2		       8d 30 2c 	      sta	ProgramEnd+1
     35  12b5
     36  12b5		       20 bf 12 	      jsr	GetSizes
     37  12b8		       20 ca 12 	      jsr	MemFree
     38  12bb		       20 e2 12 	      jsr	MemUsed
     39  12be				   MemInitEnd
     40  12be		       60		      rts
     41  12bf
     42  12bf
     43  12bf							;
     44  12bf							;=====================================================
     45  12bf							; This function might go away eventually, but was
     46  12bf							; added to provide data for other pieces of code.
     47  12bf							; It has some ties to the operating environment that
     48  12bf							; will need to be customized for the target system.
     49  12bf							;
     50  12bf				   GetSizes
     51  12bf							;
     52  12bf							; Here is machine specific code to get the highest
     53  12bf							; memory location that can be used by BASIC.
     54  12bf							;
     55  12bf				  -	      if	ProgramStart < $2000
     56  12bf				  -	      lda	#$ff
     57  12bf				  -	      sta	HighMem	;$13ff for KIM-1
     58  12bf				  -	      sta	MemFreeList
     59  12bf				  -	      lda	#$DE	;#$13
     60  12bf				  -	      sta	HighMem+1
     61  12bf				  -	      sta	MemFreeList+1
     62  12bf					      else
     63  12bf		       a9 ff		      lda	#$ff
     64  12c1		       8d 31 2c 	      sta	HighMem	;$CFFF otherwise
     65  12c4		       a9 cf		      lda	#$cf
     66  12c6		       8d 32 2c 	      sta	HighMem+1
     67  12c9					      endif
     68  12c9		       60		      rts
     69  12ca							;
     70  12ca							; This computes the available memory remaining.
     71  12ca							;
     72  12ca				   MemFree
     73  12ca		       38		      sec
     74  12cb		       ad 31 2c 	      lda	HighMem
     75  12ce		       ed 2f 2c 	      sbc	ProgramEnd
     76  12d1		       8d 35 2c 	      sta	FreeMem
     77  12d4		       85 52		      sta	R0
     78  12d6		       ad 32 2c 	      lda	HighMem+1
     79  12d9		       ed 30 2c 	      sbc	ProgramEnd+1
     80  12dc		       8d 36 2c 	      sta	FreeMem+1
     81  12df		       85 53		      sta	R0+1
     82  12e1		       60		      rts
     83  12e2							;
     84  12e2							; This computes the size of the current user program.
     85  12e2							;
     86  12e2				   MemUsed
     87  12e2		       38		      sec
     88  12e3		       ad 2f 2c 	      lda	ProgramEnd
     89  12e6		       ed 2d 2c 	      sbc	ProgramStart
     90  12e9		       8d 33 2c 	      sta	UsedMem
     91  12ec		       85 52		      sta	R0
     92  12ee		       ad 30 2c 	      lda	ProgramEnd+1
     93  12f1		       ed 2e 2c 	      sbc	ProgramStart+1
     94  12f4		       8d 34 2c 	      sta	UsedMem+1
     95  12f7		       85 53		      sta	R0+1
     96  12f9							;
     97  12f9		       60		      rts
     98  12fa
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  12fa					      include	"gosub.asm"
      1  12fa					      seg	Code
      2  12fa
      3  12fa							; Gosub and return related functions
      4  12fa							;==========================================================
      5  12fa							; Push the current math stack frame onto the gosub stack
      6  12fa				   iPushMathStack
      7  12fa		       98		      tya
      8  12fb		       48		      pha
      9  12fc		       a4 4d		      ldy	GOSUBSTACKPTR
     10  12fe		       a5 4a		      lda	MATHSTACKPTR
     11  1300		       91 4b		      sta	(GOSUBSTACK),y
     12  1302		       a9 00		      lda	#0
     13  1304		       c8		      iny
     14  1305		       91 4b		      sta	(GOSUBSTACK),y
     15  1307		       c8		      iny
     16  1308		       91 4b		      sta	(GOSUBSTACK),y
     17  130a		       c8		      iny
     18  130b		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  130d		       91 4b		      sta	(GOSUBSTACK),y
     20  130f		       c8		      iny
     21  1310		       84 4d		      sty	GOSUBSTACKPTR
     22  1312		       68		      pla
     23  1313		       a8		      tay
     24  1314		       4c bb 02 	      jmp	NextIL
     25  1317							;
     26  1317							;==========================================================
     27  1317							; Increment parameter count. Assume Stack frame is top of stack
     28  1317				   iIncParmCount
     29  1317		       98		      tya
     30  1318		       48		      pha
     31  1319		       a4 4d		      ldy	GOSUBSTACKPTR
     32  131b		       88		      dey
     33  131c		       88		      dey
     34  131d		       88		      dey
     35  131e		       b1 4b		      lda	(GOSUBSTACK),y
     36  1320		       aa		      tax
     37  1321		       e8		      inx
     38  1322		       8a		      txa
     39  1323		       91 4b		      sta	(GOSUBSTACK),y
     40  1325		       68		      pla
     41  1326		       a8		      tay
     42  1327		       4c bb 02 	      jmp	NextIL
     43  132a							;
     44  132a							;==========================================================
     45  132a							;Restore the math stack frame
     46  132a		       20 30 13    iPopMathStack jsr	PopMathStackNow
     47  132d		       4c bb 02 	      jmp	NextIL
     48  1330
     49  1330				   PopMathStackNow
     50  1330		       98		      tya
     51  1331		       48		      pha
     52  1332
     53  1332		       a4 4d		      ldy	GOSUBSTACKPTR
     54  1334		       88		      dey
     55  1335		       b1 4b		      lda	(GOSUBSTACK),y
     56  1337		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  1339		       d0 09		      bne	iPopMathStackNoFrame
     58  133b		       88		      dey
     59  133c		       88		      dey
     60  133d		       88		      dey
     61  133e		       b1 4b		      lda	(GOSUBSTACK),y
     62  1340		       85 4a		      sta	MATHSTACKPTR
     63  1342		       84 4d		      sty	GOSUBSTACKPTR
     64  1344
     65  1344				   iPopMathStackNoFrame
     66  1344
     67  1344		       68		      pla
     68  1345		       a8		      tay
     69  1346		       60		      rts
     70  1347
     71  1347
     72  1347							;==========================================================
     73  1347							; Push the current math stack information onto the gosub stack
     74  1347				   iSaveMathStack
     75  1347		       98		      tya
     76  1348		       48		      pha
     77  1349		       a4 4d		      ldy	GOSUBSTACKPTR
     78  134b		       a5 4a		      lda	MATHSTACKPTR
     79  134d		       91 4b		      sta	(GOSUBSTACK),y
     80  134f		       a5 48		      lda	MATHSTACK
     81  1351		       c8		      iny
     82  1352
     83  1352		       91 4b		      sta	(GOSUBSTACK),y
     84  1354		       c8		      iny
     85  1355
     86  1355		       a5 49		      lda	MATHSTACK+1
     87  1357		       91 4b		      sta	(GOSUBSTACK),y
     88  1359		       c8		      iny
     89  135a
     90  135a		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  135c		       91 4b		      sta	(GOSUBSTACK),y
     92  135e		       c8		      iny
     93  135f
     94  135f		       84 4d		      sty	GOSUBSTACKPTR
     95  1361		       68		      pla
     96  1362		       a8		      tay
     97  1363		       4c bb 02 	      jmp	NextIL
     98  1366							;
     99  1366							;==========================================================
    100  1366							;Restore the math stack information from the gosub stack
    101  1366				   iRestoreMathStack
    102  1366		       98		      tya
    103  1367		       48		      pha
    104  1368
    105  1368		       a5 4a		      lda	MATHSTACKPTR
    106  136a		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  136c
    108  136c		       a4 4d		      ldy	GOSUBSTACKPTR
    109  136e		       88		      dey
    110  136f		       b1 4b		      lda	(GOSUBSTACK),y
    111  1371		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  1373		       d0 16		      bne	iPopMathStack_Err
    113  1375		       88		      dey
    114  1376		       b1 4b		      lda	(GOSUBSTACK),y
    115  1378		       85 49		      sta	MATHSTACK+1
    116  137a		       88		      dey
    117  137b		       b1 4b		      lda	(GOSUBSTACK),y
    118  137d		       85 48		      sta	MATHSTACK
    119  137f		       88		      dey
    120  1380		       b1 4b		      lda	(GOSUBSTACK),y
    121  1382		       85 4a		      sta	MATHSTACKPTR
    122  1384		       84 4d		      sty	GOSUBSTACKPTR
    123  1386		       68		      pla
    124  1387		       a8		      tay
    125  1388		       4c bb 02 	      jmp	NextIL
    126  138b
    127  138b				   iPopMathStack_Err
    128  138b		       a9 00		      lda	#0
    129  138d		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  138f		       4c 18 06 	      jmp	iErr2
    131  1392							;=========================================
    132  1392							; For functions and tasks the variable address of # means
    133  1392							; a passed parameter so #[0] is the first parameter etc
    134  1392							; will try for a better way later
    135  1392
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  1392					      include	"tasks.asm"
      1  1392							;=====================================================
      2  1392							; Tiny Basic IL task management
      3  1392							; Data required by task management
      4  1392							; currently each context is about 30 bytes and is swapped
      5  1392							; into and out of page zero on each task switch....
      6  1392							; LOL yes it is slow, but works for this iteration.
      7  1392							;
      8  1392
      9  1392					      Seg	Code
     10  1392							;=====================================================
     11  1392							; Sets the pointers to the math,IL and gosub stacks
     12  1392							; Creates the initial Context for each task slot
     13  1392				   taskSetStacks
     14  1392		       a9 d4		      lda	#mathStack&$FF
     15  1394		       85 48		      sta	MATHSTACK
     16  1396		       a9 23		      lda	#mathStack>>8
     17  1398		       85 49		      sta	MATHSTACK+1
     18  139a
     19  139a		       a9 64		      lda	#ilStack&$ff
     20  139c		       85 45		      sta	ILSTACK
     21  139e		       a9 25		      lda	#ilStack>>8
     22  13a0		       85 46		      sta	ILSTACK+1
     23  13a2
     24  13a2		       a9 f4		      lda	#gosubStack&$FF
     25  13a4		       85 4b		      sta	GOSUBSTACK
     26  13a6		       a9 26		      lda	#gosubStack>>8
     27  13a8		       85 4c		      sta	GOSUBSTACK+1
     28  13aa
     29  13aa		       a9 74		      lda	#variableStack&$FF
     30  13ac		       85 41		      sta	VARIABLES
     31  13ae		       a9 29		      lda	#variableStack>>8
     32  13b0		       85 42		      sta	VARIABLES+1
     33  13b2		       a2 0a		      ldx	#TASKCOUNT
     34  13b4		       a0 00		      ldy	#0
     35  13b6		       20 41 16 	      jsr	ContextSave
     36  13b9
     37  13b9		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  13bb		       b0 3a		      bcs	taskSetDone
     39  13bd
     40  13bd		       a5 4b		      lda	GOSUBSTACK
     41  13bf		       18		      clc
     42  13c0		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  13c2		       85 4b		      sta	GOSUBSTACK
     44  13c4		       a5 4c		      lda	GOSUBSTACK+1
     45  13c6		       69 00		      adc	#0
     46  13c8		       85 4c		      sta	GOSUBSTACK+1
     47  13ca
     48  13ca		       a5 45		      lda	ILSTACK	; must be less than 256
     49  13cc		       18		      clc
     50  13cd		       69 28		      adc	#ILSTACKSIZE*2
     51  13cf		       85 45		      sta	ILSTACK
     52  13d1		       a5 46		      lda	ILSTACK+1
     53  13d3		       69 00		      adc	#0
     54  13d5		       85 46		      sta	ILSTACK+1
     55  13d7
     56  13d7		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  13d9		       18		      clc
     58  13da		       69 28		      adc	#MATHSTACKSIZE*2
     59  13dc		       85 48		      sta	MATHSTACK
     60  13de		       a5 49		      lda	MATHSTACK+1
     61  13e0		       69 00		      adc	#0
     62  13e2		       85 49		      sta	MATHSTACK+1
     63  13e4
     64  13e4		       a5 41		      lda	VARIABLES	; must be less than 256
     65  13e6		       18		      clc
     66  13e7		       69 36		      adc	#VARIABLESSIZE*2
     67  13e9		       85 41		      sta	VARIABLES
     68  13eb		       a5 42		      lda	VARIABLES+1
     69  13ed		       69 00		      adc	#0
     70  13ef		       85 42		      sta	VARIABLES+1
     71  13f1
     72  13f1		       20 41 16 	      jsr	ContextSave
     73  13f4		       4c b9 13 	      jmp	taskSetLoop
     74  13f7
     75  13f7				   taskSetDone
     76  13f7		       a0 00		      ldy	#0	; reload the main loop context
     77  13f9		       20 50 16 	      jsr	ContextLoad
     78  13fc		       60		      rts
     79  13fd							;
     80  13fd							;=====================================================
     81  13fd							; In some error cases the math stacks may be left pointing to the wrong stack
     82  13fd							; This function will reset those stack addresses but not the actual pointer
     83  13fd				   taskResetStacks
     84  13fd		       a0 00		      ldy	#0
     85  13ff		       20 50 16 	      jsr	ContextLoad
     86  1402		       4c 92 13 	      jmp	taskSetStacks
     87  1405							;
     88  1405							;=====================================================
     89  1405							; Clear all task entries and task stacks
     90  1405		       98	   taskReset  tya		; Save Y
     91  1406		       48		      pha
     92  1407		       a9 01		      lda	#1
     93  1409		       8d d3 23 	      sta	taskCounter	; Set number of active tasks to 1
     94  140c		       ac d4 22 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  140f		       c0 00		      cpy	#0	; check if we are the main context
     96  1411		       f0 08		      beq	taskResetCont	; if we are just continue
     97  1413
     98  1413		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  1415		       8c d4 22 	      sty	taskPtr
    100  1418		       20 50 16 	      jsr	ContextLoad	; load the System Task context
    101  141b				   taskResetCont
    102  141b		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  141d
    104  141d				   taskResetLoop
    105  141d		       a9 00		      lda	#TASKINACTIVE
    106  141f		       99 d5 22 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  1422		       18		      clc
    108  1423		       98		      tya
    109  1424		       69 19		      adc	#CONTEXTLEN+1
    110  1426		       a8		      tay
    111  1427		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  1429		       90 f2		      bcc	taskResetLoop	; Go for more
    113  142b
    114  142b				   taskResetComplete
    115  142b
    116  142b		       68		      pla		; Restore y
    117  142c		       a8		      tay
    118  142d		       60		      rts
    119  142e
    120  142e							;
    121  142e							;======================================================
    122  142e							; iTaskSwitch	 switch to new task if not interrupt and
    123  142e							;		 count is exceded for task time slice gets here
    124  142e							;		 when time slice has reached zero
    125  142e							;
    126  142e		       98	   iTaskSwitch tya
    127  142f		       48		      pha
    128  1430
    129  1430		       ad d1 23 	      lda	taskResetValue	; Always reset the counter value
    130  1433		       8d cf 23 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  1436		       ce d0 23 	      dec	taskCurrentCycles+1	; dec high order byte
    132  1439		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  143b
    134  143b		       ad d2 23 	      lda	taskResetValue+1
    135  143e		       8d d0 23 	      sta	taskCurrentCycles+1
    136  1441
    137  1441		       ad d1 22 	      lda	IRQPending	; Skip this if we are processing an irq
    138  1444		       0d 2b 2c 	      ora	taskIOPending	; If set then don't switch
    139  1447		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  1449
    141  1449		       ad d3 23    iTaskMain  lda	taskCounter	; Number of tasks
    142  144c		       c9 01		      cmp	#1	; if there is only one task must be main
    143  144e		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  1450
    145  1450		       ac d4 22 	      ldy	taskPtr	; check if we have not just ended some other task
    146  1453		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  1455		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  1457							;
    149  1457							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  1457							;
    151  1457				   itasknext
    152  1457		       ac d4 22 	      ldy	taskPtr
    153  145a		       20 41 16 	      jsr	ContextSave	; Save the current context, y points to next context
    154  145d				   itaskLoop
    155  145d		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  145f		       90 04		      bcc	iTaskNextChk
    157  1461
    158  1461		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  1463		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  1465
    161  1465				   iTaskNextChk
    162  1465		       b9 d5 22 	      lda	taskTable,y	; there is always at least one entry in table
    163  1468		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  146a		       18	   iTaskNext  clc
    165  146b		       98		      tya
    166  146c		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  146e		       a8		      tay
    168  146f		       4c 5d 14 	      jmp	itaskLoop	; Check for busy entry
    169  1472
    170  1472		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  1474		       59 d5 22 	      eor	taskTable,y	; Check for anything waiting io
    172  1477		       d0 f1		      bne	iTaskNext
    173  1479		       20 50 16 	      jsr	ContextLoad	; load the next context
    174  147c		       8c d4 22 	      sty	taskPtr	; update the task pointer
    175  147f
    176  147f				   iTaskSwitchDone
    177  147f		       68		      pla
    178  1480		       a8		      tay
    179  1481		       60		      rts
    180  1482							;
    181  1482							;================================================================
    182  1482							; Task Set task number to line number to start
    183  1482							; Task Table structure:
    184  1482							;    byte 0	-   Active inactive
    185  1482							;    byte 1-2	-   Basic code line pointer
    186  1482							;    byte 3	-   Offset on current line
    187  1482		       98	   iTaskSet   tya		;preserve Y
    188  1483		       48		      pha		; push a
    189  1484
    190  1484		       20 e1 19 	      jsr	popR0	; Get the line number to be saved
    191  1487
    192  1487		       ac d4 22 	      ldy	taskPtr	; find out where we are
    193  148a		       20 41 16 	      jsr	ContextSave	; Save the current context
    194  148d
    195  148d							;Find the pointer to the line we need to start at
    196  148d		       20 a9 17 	      jsr	findLine	; Get the offset of the line to start task at
    197  1490		       f0 0b		      beq	iTaskCont
    198  1492
    199  1492		       ac d4 22 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  1495		       20 50 16 	      jsr	ContextLoad
    201  1498
    202  1498		       68		      pla		; pop a - exit
    203  1499		       a8		      tay
    204  149a		       4c ec 0c 	      jmp	iSetIrqErr	; Bad line number provided
    205  149d
    206  149d				   iTaskCont
    207  149d		       20 13 16 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  14a0		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  14a2
    210  14a2		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  14a4		       99 d5 22 	      sta	taskTable,y	; new task as active
    212  14a7
    213  14a7		       a5 4f		      lda	CURPTR
    214  14a9		       48		      pha		; push a
    215  14aa		       a5 50		      lda	CURPTR+1
    216  14ac		       48		      pha		; push a
    217  14ad
    218  14ad		       20 50 16 	      jsr	ContextLoad	; load the context of the new task
    219  14b0
    220  14b0		       68		      pla		; pop a
    221  14b1		       85 50		      sta	CURPTR+1
    222  14b3		       68		      pla		; pop a
    223  14b4		       85 4f		      sta	CURPTR
    224  14b6		       a9 03		      lda	#3	; Offset to first instruction
    225  14b8		       85 51		      sta	CUROFF
    226  14ba
    227  14ba		       a9 00		      lda	#0
    228  14bc		       85 47		      sta	ILSTACKPTR
    229  14be		       85 4a		      sta	MATHSTACKPTR
    230  14c0		       85 4d		      sta	GOSUBSTACKPTR
    231  14c2		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  14c4		       85 4e		      sta	MESSAGEPTR
    233  14c6
    234  14c6		       20 49 09 	      jsr	subVINIT	; Clear the variables
    235  14c9
    236  14c9		       a9 01		      lda	#STMT&$FF
    237  14cb		       85 43		      sta	ILPC
    238  14cd		       a9 1e		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  14cf		       85 44		      sta	ILPC+1
    240  14d1
    241  14d1		       98		      tya		; Save the new context offset to return to user
    242  14d2		       48		      pha		; push a
    243  14d3
    244  14d3		       20 41 16    itaskSetSave jsr	ContextSave	; save the updated context
    245  14d6		       ee d3 23 	      inc	taskCounter	; Update the number of Tasks running
    246  14d9
    247  14d9		       ac d4 22 	      ldy	taskPtr
    248  14dc		       20 50 16 	      jsr	ContextLoad	; restore the original context
    249  14df
    250  14df		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  14e1		       85 53		      sta	R0+1
    252  14e3		       68		      pla		; Get the task pid we stored				 ; pop a
    253  14e4		       85 52		      sta	R0	; Get the table entry value
    254  14e6
    255  14e6		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  14e7		       a8		      tay
    257  14e8
    258  14e8		       4c 03 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  14eb				   iTaskNoEmpty
    260  14eb		       ac d4 22 	      ldy	taskPtr
    261  14ee		       20 50 16 	      jsr	ContextLoad
    262  14f1
    263  14f1		       68		      pla		; pop a    -- exit
    264  14f2		       a8		      tay
    265  14f3
    266  14f3		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  14f5		       a9 00		      lda	#0
    268  14f7		       4c 18 06 	      jmp	iErr2
    269  14fa							;
    270  14fa							;===============================================================
    271  14fa							; Run the task whos PID is on the stack, preserve the stack
    272  14fa							;
    273  14fa				   iTaskEnable
    274  14fa		       98		      tya
    275  14fb		       48		      pha
    276  14fc		       20 f9 19 	      jsr	popR1
    277  14ff		       20 c7 19 	      jsr	pushR1
    278  1502		       20 47 17 	      jsr	ipc_getcontext	; get context pointer into mq
    279  1505		       a0 00		      ldy	#0
    280  1507		       b1 56		      lda	(MQ),y
    281  1509		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  150b		       09 80		      ora	#TASKACTIVE
    283  150d		       91 56		      sta	(MQ),y
    284  150f		       68		      pla
    285  1510		       a8		      tay
    286  1511		       4c bb 02 	      jmp	NextIL
    287  1514
    288  1514							;
    289  1514							;===============================================================
    290  1514							; Suspend the task whos PID  is on the stack, preserve the stack
    291  1514							;
    292  1514				   iTaskSuspend
    293  1514		       98		      tya
    294  1515		       48		      pha
    295  1516		       20 f9 19 	      jsr	popR1
    296  1519		       20 c7 19 	      jsr	pushR1
    297  151c		       20 47 17 	      jsr	ipc_getcontext	; get context pointer into mq
    298  151f		       a0 00		      ldy	#0
    299  1521		       b1 56		      lda	(MQ),y
    300  1523		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  1525		       09 80		      ora	#TASKACTIVE
    302  1527		       68		      pla
    303  1528		       a8		      tay
    304  1529		       4c bb 02 	      jmp	NextIL
    305  152c
    306  152c							;================================================================
    307  152c							; Returns task Status
    308  152c				   iTaskStat
    309  152c		       98		      tya
    310  152d		       48		      pha
    311  152e		       20 40 15 	      jsr	iTaskValid	; returns pointer to task entry
    312  1531		       b9 d5 22 	      lda	taskTable,y
    313  1534		       f0 05		      beq	iTaskStatExit
    314  1536		       68		      pla
    315  1537		       a8		      tay
    316  1538		       4c a8 0c 	      jmp	iTruth
    317  153b				   iTaskStatExit
    318  153b		       68		      pla
    319  153c		       a8		      tay
    320  153d		       4c b1 0c 	      jmp	iFalse
    321  1540
    322  1540							;
    323  1540							;================================================================
    324  1540							; Validate the task number on top of the stack
    325  1540							; on exit y points to the requested task entry
    326  1540							;
    327  1540		       20 e1 19    iTaskValid jsr	popR0	; get result of the multiply
    328  1543		       a5 53		      lda	R0+1
    329  1545		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  1547		       a5 52		      lda	R0
    331  1549		       c9 fa		      cmp	#TASKTABLELEN
    332  154b		       90 09		      bcc	iTaskIsValid
    333  154d
    334  154d		       68	   iTaskValidErr pla		;remove return address
    335  154e		       68		      pla
    336  154f		       a2 10		      ldx	#ERR_INVALID_PID
    337  1551		       a9 00		      lda	#0
    338  1553		       4c 18 06 	      jmp	iErr2
    339  1556
    340  1556		       a8	   iTaskIsValid tay
    341  1557		       60		      rts
    342  1558							;
    343  1558							;================================================================
    344  1558							; Kill a running task, do nothing if already stopped
    345  1558		       20 40 15    iTaskKill  jsr	iTaskValid
    346  155b		       a9 00		      lda	#0
    347  155d		       99 d5 22 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  1560							;
    349  1560							;================================================================
    350  1560							;Skip to next task
    351  1560				   iNTask
    352  1560		       a9 01		      lda	#1
    353  1562		       8d cf 23 	      sta	taskCurrentCycles
    354  1565		       8d d0 23 	      sta	taskCurrentCycles+1
    355  1568		       4c bb 02 	      jmp	NextIL
    356  156b							;
    357  156b							;=======================================================
    358  156b							; Wait for a task to complete
    359  156b				   iWTASK
    360  156b		       20 64 17 	      jsr	getILByte
    361  156e		       8d 29 2c 	      sta	offset
    362  1571							;
    363  1571		       20 47 19 	      jsr	saveIL	;in case of failure
    364  1574
    365  1574		       20 40 15 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  1577		       b9 d5 22 	      lda	taskTable,y
    367  157a		       d0 03		      bne	iWTASKWAIT
    368  157c				   iWTASKEXITED
    369  157c		       4c bb 02 	      jmp	NextIL
    370  157f				   iWTASKWAIT
    371  157f		       20 5d 19 	      jsr	pushR0	; Push R0 back onto the stack
    372  1582		       a9 01		      lda	#1
    373  1584		       8d cf 23 	      sta	taskCurrentCycles	; Give up the cycles
    374  1587		       8d d0 23 	      sta	taskCurrentCycles+1
    375  158a		       20 52 19 	      jsr	restoreIL
    376  158d		       4c 0c 0b 	      jmp	tstBranch
    377  1590							;
    378  1590							;=======================================================
    379  1590							; Set task io lock
    380  1590		       ee 2b 2c    iStartIO   inc	taskIOPending
    381  1593		       4c bb 02 	      jmp	NextIL
    382  1596							;
    383  1596							;=======================================================
    384  1596							; Release the io lock
    385  1596		       ad 2b 2c    iEndIO     lda	taskIOPending
    386  1599		       f0 03		      beq	iEndIOExit
    387  159b		       ce 2b 2c 	      dec	taskIOPending
    388  159e		       4c bb 02    iEndIOExit jmp	NextIL
    389  15a1							;
    390  15a1							;===============================================================
    391  15a1							; Return the task PID
    392  15a1				   iTASKPID
    393  15a1		       a9 00		      lda	#0
    394  15a3		       85 53		      sta	R0+1
    395  15a5		       ad d4 22 	      lda	taskPtr
    396  15a8		       85 52		      sta	R0
    397  15aa		       4c 03 07 	      jmp	pushR0nextIl
    398  15ad							;
    399  15ad							;================================================================
    400  15ad							; Terminate a task
    401  15ad		       ac d4 22    iETask     ldy	taskPtr
    402  15b0		       c0 00		      cpy	#0
    403  15b2		       d0 03		      bne	iETaskCont
    404  15b4		       4c 01 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  15b7				   iETaskCont
    406  15b7		       a9 00		      lda	#TASKINACTIVE
    407  15b9		       99 d5 22 	      sta	taskTable,y	; mark entry as free
    408  15bc		       ce d3 23 	      dec	taskCounter	; reduce the number of active tasks
    409  15bf		       a9 01		      lda	#1
    410  15c1		       8d cf 23 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  15c4		       8d d0 23 	      sta	taskCurrentCycles+1
    412  15c7		       20 2e 16 	      jsr	TaskSetExitCode
    413  15ca				   iETaskExit
    414  15ca		       4c bb 02 	      jmp	NextIL
    415  15cd							;================================================================
    416  15cd							; make the current tasks math stack equal another tasks stack
    417  15cd							; The task to get is stored on the math stack
    418  15cd
    419  15cd				   iTaskGetMathStack
    420  15cd		       20 5b 1c 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  15d0		       20 47 17 	      jsr	ipc_getcontext	; MQ now has the context address
    422  15d3		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  15d5		       b1 56		      lda	(MQ),y
    424  15d7		       85 4a		      sta	MATHSTACKPTR
    425  15d9		       a0 08		      ldy	#MATHSTACKPOS
    426  15db		       b1 56		      lda	(MQ),y
    427  15dd		       85 48		      sta	MATHSTACK
    428  15df		       c8		      iny
    429  15e0		       b1 56		      lda	(MQ),y
    430  15e2		       85 49		      sta	MATHSTACK+1
    431  15e4		       4c bb 02 	      jmp	NextIL
    432  15e7							;==================================================================
    433  15e7							; Updates the tasks math stack pointer with contents of R2
    434  15e7							; PID is on top of the stack
    435  15e7				   iTaskPutMathPtr
    436  15e7		       20 5b 1c 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  15ea		       20 47 17 	      jsr	ipc_getcontext	; MQ now has the context address
    438  15ed		       a5 58		      lda	R2
    439  15ef		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  15f1		       91 56		      sta	(MQ),y
    441  15f3		       4c bb 02 	      jmp	NextIL
    442  15f6							;
    443  15f6							;================================================================
    444  15f6							; Set the time slice for each task
    445  15f6				   iSLICE
    446  15f6		       20 e1 19 	      jsr	popR0
    447  15f9		       a5 52		      lda	R0
    448  15fb		       8d d1 23 	      sta	taskResetValue
    449  15fe		       a5 53		      lda	R0+1
    450  1600		       8d d2 23 	      sta	taskResetValue+1
    451  1603		       d0 0b		      bne	iSliceSet
    452  1605		       ee d2 23 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  1608		       a9 01		      lda	#1
    454  160a		       8d cf 23 	      sta	taskCurrentCycles
    455  160d		       8d d0 23 	      sta	taskCurrentCycles+1
    456  1610				   iSliceSet
    457  1610		       4c bb 02 	      jmp	NextIL
    458  1613							;================================================================
    459  1613							; Find an empty slot in the taskTable
    460  1613							; Return the index in y
    461  1613							; on exit   c set if an empty slot is found
    462  1613							;	     c clear if not found
    463  1613							;================================================================
    464  1613							;
    465  1613		       ad d3 23    TaskEmpty  lda	taskCounter
    466  1616		       c9 0a		      cmp	#TASKCOUNT
    467  1618		       b0 10		      bcs	TaskNoSlot
    468  161a		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  161c				   TaskLoop
    470  161c		       b9 d5 22 	      lda	taskTable,y
    471  161f		       f0 0b		      beq	TaskEmptyFnd
    472  1621		       98		      tya
    473  1622		       18		      clc
    474  1623		       69 19		      adc	#CONTEXTLEN+1
    475  1625		       a8		      tay
    476  1626		       c0 fa		      cpy	#TASKTABLELEN
    477  1628		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  162a				   TaskNoSlot
    479  162a		       18		      clc
    480  162b		       60		      rts
    481  162c				   TaskEmptyFnd
    482  162c		       38		      sec
    483  162d		       60		      rts
    484  162e							;====================================================
    485  162e							; Set the task exit code called from the return command
    486  162e							; on entry stack top hold exit value
    487  162e				   TaskSetExitCode
    488  162e		       98		      tya
    489  162f		       48		      pha
    490  1630		       20 e1 19 	      jsr	popR0
    491  1633		       a0 19		      ldy	#TASKEXITCODE
    492  1635		       a5 52		      lda	R0
    493  1637		       91 41		      sta	(VARIABLES),y
    494  1639		       c8		      iny
    495  163a		       a5 53		      lda	R0+1
    496  163c		       91 41		      sta	(VARIABLES),y
    497  163e		       68		      pla
    498  163f		       98		      tya
    499  1640		       60		      rts
    500  1641
    501  1641							;
    502  1641							;=====================================================
    503  1641							; Save Context Store the context to the TASK Table
    504  1641							; on entry y contains the task table entry to save to
    505  1641							; on exit y points to next task table entry
    506  1641							;	   x contains the number of bytes copied
    507  1641		       a2 00	   ContextSave ldx	#0
    508  1643		       c8		      iny		;inc past the task flags
    509  1644		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  1646		       99 d5 22 	      sta	taskTable,y
    511  1649		       c8		      iny
    512  164a		       e8		      inx
    513  164b		       e0 18		      cpx	#CONTEXTLEN
    514  164d		       90 f5		      bcc	ContextSvLoop
    515  164f		       60		      rts
    516  1650							;
    517  1650							; Load Context transfer context from task table to the Current Context
    518  1650							; on entry y contains the task table entry to transfer
    519  1650							; on exit y points to the original task table entry
    520  1650							;	   x contains the number of byts copied
    521  1650		       98	   ContextLoad tya
    522  1651		       48		      pha
    523  1652		       a2 00		      ldx	#0
    524  1654		       c8		      iny		;inc past the task flags
    525  1655		       b9 d5 22    ContextLDLoop lda	taskTable,y
    526  1658		       95 41		      sta	CONTEXT,x
    527  165a		       c8		      iny
    528  165b		       e8		      inx
    529  165c		       e0 18		      cpx	#CONTEXTLEN
    530  165e		       90 f5		      bcc	ContextLDLoop
    531  1660		       68		      pla
    532  1661		       a8		      tay
    533  1662		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  1663					      include	"ipc.asm"
      1  1663							;======================================================
      2  1663							; Inter process communications.
      3  1663							; Tasks may write/read integer messages among
      4  1663							; them selves.
      5  1663							; This uses each tasks gosub stack as a message queue
      6  1663							; Gosub calls start at the highest address and the
      7  1663							; msg queue starts at the highest address.
      8  1663							;
      9  1663							;======================================================
     10  1663							; ipcs   - Send msg to another task or many tasks
     11  1663							; on entry  math stack contains the  top PID
     12  1663							;				      2ND Message value
     13  1663							; on exit   math stack contain top True-good or False-failed
     14  1663							;
     15  1663							; it may not be sent if queue is full
     16  1663							;
     17  1663							; a = ipcs(<message-expression>,<task PID-expression>)
     18  1663							;
     19  1663				   iIPCS
     20  1663		       98		      tya
     21  1664		       48		      pha
     22  1665		       20 cc 16 	      jsr	ipc_enqueue
     23  1668		       b0 08		      bcs	iIPC_BAD
     24  166a		       20 4d 1c 	      jsr	pushTrue
     25  166d		       68		      pla
     26  166e		       a8		      tay
     27  166f		       4c bb 02 	      jmp	NextIL
     28  1672				   iIPC_BAD
     29  1672		       68		      pla
     30  1673		       a8		      tay
     31  1674		       20 57 1c 	      jsr	pushFalse
     32  1677		       4c bb 02 	      jmp	NextIL
     33  167a
     34  167a							;======================================================
     35  167a							; ipcr   - Recieve msg from task
     36  167a							; on exit  the message value is returned from message queue
     37  167a							;	    message -1	is reserved meaning no entry found
     38  167a							; The provided variable contains the pid of the sending
     39  167a							; task. This is optional. This always waits for a message
     40  167a							; before returning.
     41  167a							;
     42  167a							; a = ipcr(<variable name>)
     43  167a							;
     44  167a				   iIPCR
     45  167a		       98		      tya
     46  167b		       48		      pha
     47  167c		       20 0e 17 	      jsr	ipc_dequeue
     48  167f		       b0 05		      bcs	iIPCR_Q_Empty
     49  1681		       68		      pla
     50  1682		       a8		      tay
     51  1683		       4c bb 02 	      jmp	NextIL
     52  1686				   iIPCR_Q_Empty
     53  1686		       68		      pla
     54  1687		       a8		      tay
     55  1688		       20 4d 1c 	      jsr	pushTrue	; puts -1 on the stack
     56  168b		       4c bb 02 	      jmp	NextIL
     57  168e
     58  168e							;=======================================================
     59  168e							; ipcc   - Check if message available
     60  168e							; on exit  Stack contains number of messages
     61  168e							;
     62  168e							; a = ipcc()
     63  168e							;
     64  168e				   iIPCC
     65  168e		       98		      tya
     66  168f		       48		      pha
     67  1690		       20 b9 16 	      jsr	ipc_queue_count
     68  1693		       20 5d 19 	      jsr	pushR0	; return the count
     69  1696		       68		      pla
     70  1697		       a8		      tay
     71  1698		       4c bb 02 	      jmp	NextIL
     72  169b
     73  169b							;=======================================================
     74  169b							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  169b				   iIPCIO
     76  169b		       98		      tya
     77  169c		       48		      pha
     78  169d		       20 b9 16 	      jsr	ipc_queue_count
     79  16a0		       a5 52		      lda	R0
     80  16a2		       d0 10		      bne	iIPCIO_No_Halt
     81  16a4		       a9 01		      lda	#1
     82  16a6		       8d cf 23 	      sta	taskCurrentCycles	; force a task switch
     83  16a9		       a9 01		      lda	#TASKWAITIPC
     84  16ab		       ac d4 22 	      ldy	taskPtr
     85  16ae		       19 d5 22 	      ora	taskTable,y
     86  16b1		       99 d5 22 	      sta	taskTable,y
     87  16b4
     88  16b4				   iIPCIO_No_Halt
     89  16b4		       68		      pla
     90  16b5		       a8		      tay
     91  16b6		       4c bb 02 	      jmp	NextIL
     92  16b9							;======================================================
     93  16b9							;ipc_queue_count
     94  16b9				   ipc_queue_count
     95  16b9		       a5 4e		      lda	MESSAGEPTR
     96  16bb		       18		      clc
     97  16bc		       4a		      lsr		; divide by 4
     98  16bd		       4a		      lsr
     99  16be		       85 52		      sta	R0	; store into R0
    100  16c0		       a9 10		      lda	#GOSUBSTACKSIZE
    101  16c2		       38		      sec
    102  16c3		       e5 52		      sbc	R0	; Get how many entries on queue
    103  16c5		       85 52		      sta	R0
    104  16c7		       a9 00		      lda	#0
    105  16c9		       85 53		      sta	R0+1
    106  16cb		       60		      rts
    107  16cc							;=======================================================
    108  16cc							; Support functions for messaging
    109  16cc							;
    110  16cc							; Enqueue message -> onto PID's MSG Q
    111  16cc							; on entry top of stack contains the PID
    112  16cc							;	    second contains the Message of the task
    113  16cc							; on exit contains c set if failed
    114  16cc							;		    c cleared if success
    115  16cc							;		    PID's MSG Q PTR points to the message
    116  16cc							;
    117  16cc				   ipc_enqueue
    118  16cc		       20 f9 19 	      jsr	popR1	; Get the pid
    119  16cf		       20 47 17 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  16d2
    121  16d2		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  16d4		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  16d6		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  16d8		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  16da		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  16dc
    127  16dc
    128  16dc							; Get the PID'S stack address into R0
    129  16dc		       a0 0b		      ldy	#GOSUBSTKPOS
    130  16de		       b1 56		      lda	(MQ),y
    131  16e0		       85 52		      sta	R0
    132  16e2		       c8		      iny
    133  16e3		       b1 56		      lda	(MQ),y
    134  16e5		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  16e7
    136  16e7							; Set y to point to the msg q entry
    137  16e7		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  16e9		       b1 56		      lda	(MQ),y	; Get the index
    139  16eb		       a8		      tay		; Set y to queue offset
    140  16ec
    141  16ec							; enqueue the message
    142  16ec		       88		      dey		; First byte to save to
    143  16ed		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  16ef		       91 52		      sta	(R0),y	; Set the entry type
    145  16f1
    146  16f1		       88		      dey
    147  16f2		       ad d4 22 	      lda	taskPtr	; Store the PID into queue
    148  16f5		       91 52		      sta	(R0),y
    149  16f7		       20 f9 19 	      jsr	popR1	; Get the actual message value
    150  16fa		       20 55 17 	      jsr	ipc_pushR1	; Store Message value into queue
    151  16fd
    152  16fd		       98		      tya		; Save the new q ptr
    153  16fe		       a0 0e		      ldy	#MSGPTRPOS
    154  1700		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1702		       a0 00		      ldy	#0	; points to context root
    156  1704		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1706		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1708		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  170a		       18		      clc
    160  170b		       60		      rts
    161  170c				   ipc_enq_full
    162  170c		       38		      sec
    163  170d		       60		      rts
    164  170e							;=============================================================
    165  170e							; De-queue for message stack -> local tasks msg q
    166  170e							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  170e							;  message into
    168  170e							;  on exit   math stack contains value of message
    169  170e							;				  Variable if provided is pid
    170  170e				   ipc_dequeue
    171  170e		       20 10 1a 	      jsr	popMQ	; Variable address to put PID into
    172  1711
    173  1711		       a4 4e		      ldy	MESSAGEPTR
    174  1713		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1715		       b0 2e		      bcs	ipc_deq_empty
    176  1717		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1719		       85 52		      sta	R0
    178  171b		       c8		      iny
    179  171c		       b1 4b		      lda	(GOSUBSTACK),y
    180  171e		       85 53		      sta	R0+1
    181  1720		       c8		      iny
    182  1721		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1723		       85 54		      sta	R1
    184  1725		       c8		      iny
    185  1726		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1728		       c8		      iny
    187  1729		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  172b
    189  172b		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  172d		       d0 16		      bne	ipc_deq_empty
    191  172f
    192  172f		       20 5d 19 	      jsr	pushR0	; place value on stack
    193  1732
    194  1732		       a5 56		      lda	MQ
    195  1734		       05 57		      ora	MQ+1
    196  1736		       f0 0b		      beq	ipc_deq_done
    197  1738		       a5 54		      lda	R1
    198  173a		       a0 00		      ldy	#0
    199  173c		       91 56		      sta	(MQ),y
    200  173e		       c8		      iny
    201  173f		       a9 00		      lda	#0
    202  1741		       91 56		      sta	(MQ),y
    203  1743				   ipc_deq_done
    204  1743		       18		      clc
    205  1744		       60		      rts
    206  1745
    207  1745				   ipc_deq_empty
    208  1745		       38		      sec
    209  1746		       60		      rts
    210  1747
    211  1747							;=============================================
    212  1747							;  Get the context address into MQ from R1 with
    213  1747							;  context/index/pid
    214  1747				   ipc_getcontext
    215  1747		       18		      clc		; Get pointer to Task context
    216  1748		       a9 d5		      lda	#taskTable&$FF	; change ptr to address
    217  174a		       65 54		      adc	R1
    218  174c		       85 56		      sta	MQ
    219  174e		       a9 22		      lda	#taskTable>>8
    220  1750		       65 55		      adc	R1+1
    221  1752		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1754		       60		      rts
    223  1755							;
    224  1755							;==============================================
    225  1755							;Push R1 onto the stack
    226  1755							;on entry y = next entry
    227  1755							;R0 points to the stack space
    228  1755							;on exit y points to next free byte
    229  1755				   ipc_pushR1
    230  1755		       88		      dey
    231  1756		       a5 55		      lda	R1+1	; PID first
    232  1758		       91 52		      sta	(R0),y
    233  175a		       88		      dey
    234  175b		       a5 54		      lda	R1
    235  175d		       91 52		      sta	(R0),y
    236  175f		       60		      rts
    237  1760
    238  1760
    239  1760
    240  1760
    241  1760
    242  1760
    243  1760
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1760					      include	"support.asm"
      1  1760							;
      2  1760							;=====================================================
      3  1760							;=====================================================
      4  1760							;=====================================================
      5  1760							; This marks the start of support functions used by
      6  1760							; the IL opcodes.  These are support functions, NOT
      7  1760							; the IL code.
      8  1760							;=====================================================
      9  1760							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1760							;=====================================================
     11  1760					      Seg	Code
     12  1760							;=====================================================
     13  1760							; This gets the next two bytes pointed to by ILPC and
     14  1760							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1760							; is advanced by two, and Y contains 0 on return.
     16  1760
     17  1760							;
     18  1760		       20 64 17    getILWord  jsr	getILByte	;LSB
     19  1763		       aa		      tax
     20  1764							;
     21  1764							;=====================================================
     22  1764							; This gets the next byte pointed to by ILPC and
     23  1764							; returns it in A.  On return, X is unchanged but Y
     24  1764							; contains 0.
     25  1764							;
     26  1764		       a0 00	   getILByte  ldy	#0
     27  1766		       b1 43		      lda	(ILPC),y	;get byte
     28  1768		       08		      php		;save status
     29  1769		       e6 43		      inc	ILPC	;inc LSB
     30  176b		       d0 02		      bne	getILb2	;branch if no overflow
     31  176d		       e6 44		      inc	ILPC+1	;inc MSB
     32  176f		       28	   getILb2    plp		;restore status
     33  1770		       60		      rts
     34  1771							;
     35  1771							;=====================================================
     36  1771							; Decrement ILPC by one.
     37  1771							;
     38  1771		       a5 43	   decIL      lda	ILPC
     39  1773		       d0 02		      bne	decIL2
     40  1775		       c6 44		      dec	ILPC+1
     41  1777		       c6 43	   decIL2     dec	ILPC
     42  1779		       60		      rts
     43  177a							;
     44  177a							;=====================================================
     45  177a							; Push the ILPC onto the return stack.  Actually, this
     46  177a							; pushes the address of ILPC+2 since that's the next
     47  177a							; address to execute.
     48  177a							;
     49  177a		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  177c		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  177e		       b0 15		      bcs	pushErr
     52  1780		       a5 43		      lda	ILPC
     53  1782		       18		      clc
     54  1783		       69 02		      adc	#2
     55  1785		       91 45		      sta	(ILSTACK),y
     56  1787		       08		      php		;save C bit
     57  1788		       c8		      iny
     58  1789		       a5 44		      lda	ILPC+1
     59  178b		       28		      plp		;restore C
     60  178c		       69 00		      adc	#0
     61  178e		       91 45		      sta	(ILSTACK),y
     62  1790		       c8		      iny
     63  1791		       84 47		      sty	ILSTACKPTR
     64  1793		       18		      clc
     65  1794		       60		      rts
     66  1795				   pushErr
     67  1795		       38		      sec
     68  1796		       60		      rts
     69  1797							;
     70  1797							;=====================================================
     71  1797							; Pull the top entry from return stack and put into
     72  1797							; ILPC.
     73  1797							;
     74  1797		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1799		       f0 fa		      beq	pushErr
     76  179b		       88		      dey
     77  179c		       b1 45		      lda	(ILSTACK),y
     78  179e		       85 44		      sta	ILPC+1
     79  17a0		       88		      dey
     80  17a1		       b1 45		      lda	(ILSTACK),y
     81  17a3		       85 43		      sta	ILPC
     82  17a5		       84 47		      sty	ILSTACKPTR
     83  17a7		       18		      clc
     84  17a8		       60		      rts
     85  17a9							;
     86  17a9							;=====================================================
     87  17a9							; This searches for a specific line number that is in
     88  17a9							; R0.	There are three possible return conditions:
     89  17a9							; Line numbers are now the third byte, the first byte is now **************
     90  17a9							; a pointer to the next line, of course no longer that 53 byte
     91  17a9							; per line.
     92  17a9							;
     93  17a9							; Exact match was found:
     94  17a9							;    * Z set
     95  17a9							;    * CURPTR points to two-byte line number for that
     96  17a9							;	line.
     97  17a9							;
     98  17a9							; Next highest line found:
     99  17a9							;    * Z cleared
    100  17a9							;    * C set
    101  17a9							;    * CURPTR points to two-byte line number for that
    102  17a9							;	line.
    103  17a9							;
    104  17a9							; End of program reached:
    105  17a9							;    * Z cleared
    106  17a9							;    * C cleared
    107  17a9							;    * CURPTR points to first free byte at end of
    108  17a9							;	program.  Ie, it has save value as PROGRAMEND.
    109  17a9							;
    110  17a9							; A, X, and Y are all undefined on return.
    111  17a9							;
    112  17a9
    113  17a9				   findLine
    114  17a9		       ad 2d 2c 	      lda	ProgramStart	;Start of program -> CURPTR
    115  17ac		       85 4f		      sta	CURPTR
    116  17ae		       ad 2e 2c 	      lda	ProgramStart+1
    117  17b1		       85 50		      sta	CURPTR+1
    118  17b3							;
    119  17b3							; At end of code?
    120  17b3							;
    121  17b3				   iXFER1
    122  17b3		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  17b5		       cd 2f 2c 	      cmp	ProgramEnd	; at end of program then stop run
    124  17b8		       d0 0b		      bne	xfer2	; not end
    125  17ba		       a5 50		      lda	CURPTR+1
    126  17bc		       cd 30 2c 	      cmp	ProgramEnd+1
    127  17bf		       d0 04		      bne	xfer2	;Not at end
    128  17c1							;
    129  17c1							; Line not found and the end of the program was
    130  17c1							; reached.  Return Z and C both clear.
    131  17c1							;
    132  17c1		       a9 01		      lda	#1	;clear Z
    133  17c3		       18		      clc		;clear C
    134  17c4		       60		      rts
    135  17c5							;
    136  17c5							; Check for an exact line number match
    137  17c5							;
    138  17c5		       a5 52	   xfer2      lda	R0
    139  17c7		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  17c9		       d1 4f		      cmp	(CURPTR),y
    141  17cb		       d0 08		      bne	xfernotit
    142  17cd		       c8		      iny
    143  17ce		       a5 53		      lda	R0+1
    144  17d0		       d1 4f		      cmp	(CURPTR),y
    145  17d2		       d0 01		      bne	xfernotit	; not a matching line number
    146  17d4							;
    147  17d4							; This is exactly the line we want.
    148  17d4							;
    149  17d4		       60		      rts		;it matches exactly
    150  17d5							;
    151  17d5							; See if this line is greater than the one we're
    152  17d5							; searching for.
    153  17d5							;
    154  17d5		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  17d7		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  17d9		       c5 53		      cmp	R0+1
    157  17db		       90 0b		      bcc	xfer3
    158  17dd		       d0 07		      bne	xfer4
    159  17df		       88		      dey
    160  17e0		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  17e2		       c5 52		      cmp	R0
    162  17e4		       90 02		      bcc	xfer3
    163  17e6							;
    164  17e6							; This line is greater than the one we want, so
    165  17e6							; return Z clear and C set.
    166  17e6							;
    167  17e6		       38	   xfer4      sec		;We found a line number greater
    168  17e7		       60		      rts		;both conditions set
    169  17e8							;
    170  17e8							; Not the line (or droid) we're looking for.  Move to
    171  17e8							; the next line.
    172  17e8							;
    173  17e8		       20 ee 17    xfer3      jsr	FindNextLine
    174  17eb		       4c b3 17 	      jmp	iXFER1
    175  17ee							;
    176  17ee							;=====================================================
    177  17ee							; This advances CURPTR to the next line.  If there
    178  17ee							; are no more lines, this leaves CURPTR equal to
    179  17ee							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  17ee							; CURPTR is pointing to a valid line on entry.  This
    181  17ee							; pointer points to the two-byte line number.
    182  17ee							; Update this points to the 1 byte line length  ****************
    183  17ee							;
    184  17ee				   FindNextLine
    185  17ee		       a0 03		      ldy	#3	;skip line number and length byte
    186  17f0		       84 51		      sty	CUROFF	;this is the new offset
    187  17f2		       a0 00		      ldy	#0
    188  17f4		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  17f6		       18		      clc
    190  17f7		       65 4f		      adc	CURPTR
    191  17f9		       85 4f		      sta	CURPTR
    192  17fb		       a5 50		      lda	CURPTR+1
    193  17fd		       69 00		      adc	#0
    194  17ff		       85 50		      sta	CURPTR+1
    195  1801		       60	   FindNext4  rts
    196  1802							;
    197  1802							;=====================================================
    198  1802							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1802							; if they are equal, Z clear if not.
    200  1802							;
    201  1802		       a5 4f	   AtEnd      lda	CURPTR
    202  1804		       cd 2f 2c 	      cmp	ProgramEnd
    203  1807		       d0 05		      bne	atendexit
    204  1809		       a5 50		      lda	CURPTR+1
    205  180b		       cd 30 2c 	      cmp	ProgramEnd+1
    206  180e		       60	   atendexit  rts
    207  180f							;
    208  180f
    209  180f							;
    210  180f							;=====================================================
    211  180f							; Convert an ASCII string to a number.  On input,
    212  180f							; (CURPTR),Y points to the first digit.  This gets
    213  180f							; digit-by-digit until finding a non-number.  Returns
    214  180f							; Y pointing to the non-digit, and R0 contains the
    215  180f							; number.  This does NOT check for valid ranges, so
    216  180f							; a value like "123456789" will produce something,
    217  180f							; but not what you had expected.
    218  180f							;
    219  180f		       a9 00	   getDecimal lda	#0
    220  1811		       85 52		      sta	R0
    221  1813		       85 53		      sta	R0+1
    222  1815		       85 59		      sta	dpl	;temporary negative flag
    223  1817							;
    224  1817							; See if it's negative...
    225  1817							;
    226  1817							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1817		       b1 4f		      lda	(CURPTR),y
    228  1819		       c9 2d		      cmp	#'-
    229  181b		       d0 02		      bne	getDecLoop
    230  181d		       e6 59		      inc	dpl	;it's negative
    231  181f							;
    232  181f		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1821		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1823		       c9 30		      cmp	#'0
    235  1825		       90 36		      bcc	getDdone
    236  1827		       c9 3a		      cmp	#'9+1
    237  1829		       b0 32		      bcs	getDdone
    238  182b		       38		      sec
    239  182c		       e9 30		      sbc	#'0	;convert to binary
    240  182e		       48		      pha
    241  182f							;
    242  182f							; Now multiply R0 by 10.  Remember that
    243  182f							; 2*N + 8*N = 10*N.
    244  182f							;
    245  182f		       06 52		      asl	R0
    246  1831		       26 53		      rol	R0+1	;*2
    247  1833		       a5 52		      lda	R0
    248  1835		       85 54		      sta	R1
    249  1837		       a5 53		      lda	R0+1
    250  1839		       85 55		      sta	R1+1
    251  183b		       06 52		      asl	R0
    252  183d		       26 53		      rol	R0+1	;*4
    253  183f		       06 52		      asl	R0
    254  1841		       26 53		      rol	R0+1	;*8
    255  1843		       18		      clc		;now add the partial sums...
    256  1844		       a5 52		      lda	R0	;...to get *10
    257  1846		       65 54		      adc	R1
    258  1848		       85 52		      sta	R0
    259  184a		       a5 53		      lda	R0+1
    260  184c		       65 55		      adc	R1+1
    261  184e		       85 53		      sta	R0+1
    262  1850							;
    263  1850							; Add in the new digit
    264  1850							;
    265  1850		       68		      pla
    266  1851		       18		      clc
    267  1852		       65 52		      adc	R0
    268  1854		       85 52		      sta	R0
    269  1856		       90 02		      bcc	getD2
    270  1858		       e6 53		      inc	R0+1
    271  185a							;
    272  185a							; Move to next character
    273  185a							;
    274  185a		       c8	   getD2      iny
    275  185b		       d0 c2		      bne	getDecLoop
    276  185d							;
    277  185d							; All done with digits, so now deal with it being
    278  185d							; negative.  If zero, then don't check for negative
    279  185d							; flag.  Ie, -0 is stored as 0.
    280  185d							;
    281  185d		       a5 52	   getDdone   lda	R0
    282  185f		       05 53		      ora	R0+1
    283  1861		       f0 16		      beq	getDone2	;zero
    284  1863		       a5 59		      lda	dpl
    285  1865		       f0 12		      beq	getDone2	;positive
    286  1867							;
    287  1867							; Invert all the bits, then add one.
    288  1867							;
    289  1867		       a5 52		      lda	R0
    290  1869		       49 ff		      eor	#$ff
    291  186b		       85 52		      sta	R0
    292  186d		       a5 53		      lda	R0+1
    293  186f		       49 ff		      eor	#$ff
    294  1871		       85 53		      sta	R0+1
    295  1873							;
    296  1873		       e6 52		      inc	R0
    297  1875		       d0 02		      bne	getDone2
    298  1877		       e6 53		      inc	R0+1
    299  1879				   getDone2
    300  1879							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1879							;lda	  R0
    302  1879							;sta	  $0010
    303  1879							;lda	  R0+1
    304  1879							;sta	  $0011
    305  1879							;lda	  dpl
    306  1879							;sta	  $012
    307  1879
    308  1879		       60		      rts
    309  187a
    310  187a							;=====================================================
    311  187a							; Gets a line of input into LINBUF.
    312  187a							;
    313  187a							; On entry:
    314  187a							;    A contains the prompt character, or 0 if none.
    315  187a							;    X = 1 Background read
    316  187a							;    x = 0 Forground read with wait
    317  187a							;
    318  187a							; On exit:
    319  187a							;    CURPTR points to LINBUF
    320  187a							;    LINBUF contains the line with 0 at the end.
    321  187a							;    Y has offset to first non-space character
    322  187a							;    CURROFF has the same as Y.
    323  187a							;
    324  187a		       20 c9 18    GetLine    jsr	ReadPrompt
    325  187d		       e0 00		      cpx	#0
    326  187f		       f0 14		      beq	GetLineRetry
    327  1881		       ae d4 22 	      ldx	taskPtr
    328  1884		       bd d5 22 	      lda	taskTable,x
    329  1887		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1889		       d0 3d		      bne	taskWaitingIO
    331  188b		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  188d		       9d d5 22 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1890		       ce c8 18 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1893		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1895
    336  1895							;
    337  1895							; Now read a line and wait for the CR
    338  1895							;
    339  1895				   GetLineRetry
    340  1895		       a9 00		      lda	#0	;Wait for input to complete
    341  1897		       20 e1 18 	      jsr	ReadLine
    342  189a
    343  189a							;
    344  189a							; Point to the line we just read
    345  189a							; Set the current pointer to point to the input line
    346  189a							;
    347  189a		       a0 00	   ReadComplete ldy	#0
    348  189c		       84 51		      sty	CUROFF
    349  189e		       a2 90		      ldx	#LINBUF&$ff
    350  18a0		       86 4f		      stx	CURPTR
    351  18a2		       a2 2b		      ldx	#LINBUF>>8
    352  18a4		       86 50		      stx	CURPTR+1
    353  18a6							;
    354  18a6							; Output a CR/LF
    355  18a6							;
    356  18a6		       20 9a 1a 	      jsr	CRLF
    357  18a9							;
    358  18a9							; If a blank line, prompt again.
    359  18a9							;
    360  18a9		       20 91 1a 	      jsr	SkipSpaces
    361  18ac		       b1 4f		      lda	(CURPTR),y
    362  18ae		       d0 10		      bne	GetLineDone	;We have data then exit
    363  18b0		       20 cc 18 	      jsr	ReadPromptRetry
    364  18b3		       ae d4 22 	      ldx	taskPtr	;if this task is waiting for IO
    365  18b6		       bd d5 22 	      lda	taskTable,x	;then get out, wait for line to
    366  18b9		       29 40		      and	#TASKWAITIO	;Complete again
    367  18bb		       d0 0b		      bne	taskWaitingIO
    368  18bd		       4c 95 18 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  18c0
    370  18c0				   GetLineDone
    371  18c0		       ae d4 22 	      ldx	taskPtr
    372  18c3		       a9 80		      lda	#TASKACTIVE
    373  18c5		       9d d5 22 	      sta	taskTable,x	;IO is complete
    374  18c8
    375  18c8				   taskWaitingIO
    376  18c8		       60		      rts
    377  18c9
    378  18c9							;
    379  18c9							;=======================================================================
    380  18c9							; Display the prompt character
    381  18c9							; On entry
    382  18c9							;	    A contains the prompt character
    383  18c9							; On exit
    384  18c9							;	    The readbuffer index is reset to 0
    385  18c9							;
    386  18c9		       8d 17 2c    ReadPrompt sta	promptChar
    387  18cc
    388  18cc							;
    389  18cc							; Prompt
    390  18cc							;
    391  18cc
    392  18cc		       ad 17 2c    ReadPromptRetry lda	promptChar
    393  18cf		       09 00		      ora	#0	;any prompt?
    394  18d1		       f0 08		      beq	getlinenp
    395  18d3		       20 e3 1b 	      jsr	VOUTCH
    396  18d6		       a9 20		      lda	#$20
    397  18d8		       20 e3 1b 	      jsr	VOUTCH	;Space after prompt
    398  18db							;
    399  18db		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  18dd		       8e 14 2c 	      stx	getlinx
    401  18e0		       60		      rts
    402  18e1							;
    403  18e1							;===============================================================
    404  18e1							; This fuction is the driver for the line input
    405  18e1							; on call if a = 0 then it waits for all input
    406  18e1							;	      a = 1 then nowait for input
    407  18e1							; On exit
    408  18e1							;		       c clear if not complete line
    409  18e1							;		       c set if it was a complete line
    410  18e1
    411  18e1				   ReadLine
    412  18e1		       8d 16 2c 	      sta	inputNoWait
    413  18e4		       c9 00		      cmp	#0
    414  18e6		       f0 05		      beq	getline1
    415  18e8		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  18eb		       f0 2b		      beq	GetLineNoWait
    417  18ed		       20 e6 1b    getline1   jsr	VGETCH
    418  18f0					      if	CTMON65
    419  18f0		       48		      pha
    420  18f1		       20 e3 1b 	      jsr	VOUTCH	;echo echo echo
    421  18f4		       68		      pla
    422  18f5					      endif
    423  18f5		       c9 0d		      cmp	#CR
    424  18f7		       f0 15		      beq	getlind	;end of line
    425  18f9		       c9 08		      cmp	#BS	;backspace?
    426  18fb		       f0 1d		      beq	getlinebs
    427  18fd		       ae 14 2c 	      ldx	getlinx
    428  1900		       9d 90 2b 	      sta	LINBUF,x
    429  1903		       e8		      inx
    430  1904		       8e 14 2c 	      stx	getlinx
    431  1907		       ad 16 2c 	      lda	inputNoWait
    432  190a		       f0 e1		      beq	getline1
    433  190c		       d0 0a		      bne	GetLineNoWait
    434  190e							;
    435  190e							; CR was hit
    436  190e							;
    437  190e		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1910		       ae 14 2c 	      ldx	getlinx
    439  1913		       9d 90 2b 	      sta	LINBUF,x
    440  1916
    441  1916		       38		      sec		; Carry set then cr received
    442  1917		       60		      rts
    443  1918
    444  1918				   GetLineNoWait
    445  1918		       18		      clc		; Carry clear no end of line
    446  1919		       60		      rts
    447  191a							;
    448  191a							; Backspace was hit
    449  191a							;
    450  191a		       ae 14 2c    getlinebs  ldx	getlinx
    451  191d		       f0 0e		      beq	getlineEOL	;at start of line
    452  191f		       ca		      dex
    453  1920		       8e 14 2c 	      stx	getlinx
    454  1923		       20 e9 1b    getlinepbs jsr	puts
      0  1926					      db	27,"[K",0
      1  1926		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  192a		       4c ed 18 	      jmp	getline1
    457  192d		       a9 20	   getlineEOL lda	#SPACE
    458  192f		       20 e3 1b 	      jsr	VOUTCH
    459  1932		       d0 ef		      bne	getlinepbs
    460  1934							;
    461  1934							;=====================================================
    462  1934							; Count the length of the line currently in LINBUF
    463  1934							; starting at offset Y.  Returns the length in X.  The
    464  1934							; starting offset in Y should point past the ASCII
    465  1934							; line number.  Also counts the trailing NULL and two
    466  1934							; extra bytes for where the line number will be.
    467  1934							; Update must now include leading length byte not the null at end ****************
    468  1934							;
    469  1934				   getLineLength
    470  1934		       a2 00		      ldx	#0	;size
    471  1936		       b9 90 2b    getLineL2  lda	LINBUF,y
    472  1939		       f0 04		      beq	getLineL3
    473  193b		       c8		      iny
    474  193c		       e8		      inx
    475  193d		       d0 f7		      bne	getLineL2
    476  193f		       e8	   getLineL3  inx		;count null at end
    477  1940		       e8		      inx		;line number LSB
    478  1941		       e8		      inx		;MSB
    479  1942		       e8		      inx		;change: count new leading line length
    480  1943		       8e 2a 2c 	      stx	lineLength
    481  1946		       60		      rts
    482  1947							;
    483  1947							;=====================================================
    484  1947							; Count the length of the line pointed to by CURPTR.
    485  1947							; This also counts the line number and the terminating
    486  1947							; null.  Ie, this string returns 8:
    487  1947							;
    488  1947							; <lineLow><lineHi>Hello<null>
    489  1947							;
    490  1947							; Another way of looking at it: add the return value
    491  1947							; to the CURPTR and it'll point to the next line's
    492  1947							; line number.  Returns the value in Y.
    493  1947							; Update to ject get the leading byte length ********************
    494  1947							;
    495  1947							;getCURPTRLength
    496  1947							;		ldy	CURPTR
    497  1947							;		ldy	#3	;change: skip line number and leading length byte
    498  1947							;getCLineL2	lda	(CURPTR),y
    499  1947							;		beq	getCLineL3
    500  1947							;		iny
    501  1947							;		bne	getCLineL2
    502  1947							;getCLineL3	iny		;count null at end
    503  1947							;		rts
    504  1947
    505  1947							;
    506  1947							;=====================================================
    507  1947							; This saves ILPC.  This saves to a single save area,
    508  1947							; so it can't be called more than once.
    509  1947							;
    510  1947		       a5 43	   saveIL     lda	ILPC
    511  1949		       8d 26 2c 	      sta	tempIL
    512  194c		       a5 44		      lda	ILPC+1
    513  194e		       8d 27 2c 	      sta	tempIL+1
    514  1951		       60		      rts
    515  1952							;
    516  1952							;=====================================================
    517  1952							; This restores ILPC.
    518  1952							;
    519  1952		       ad 26 2c    restoreIL  lda	tempIL
    520  1955		       85 43		      sta	ILPC
    521  1957		       ad 27 2c 	      lda	tempIL+1
    522  195a		       85 44		      sta	ILPC+1
    523  195c		       60		      rts
    524  195d							;
    525  195d							;=====================================================
    526  195d							; This pushes R0 onto the stack.
    527  195d							;
    528  195d		       8c 1d 2c    pushR0     sty	rtemp1
    529  1960		       a4 4a		      ldy	MATHSTACKPTR
    530  1962		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1964		       b0 34		      bcs	pusherr
    532  1966		       a5 52		      lda	R0
    533  1968		       91 48		      sta	(MATHSTACK),y
    534  196a		       c8		      iny
    535  196b		       a5 53		      lda	R0+1
    536  196d		       91 48		      sta	(MATHSTACK),y
    537  196f		       c8		      iny
    538  1970		       84 4a		      sty	MATHSTACKPTR
    539  1972		       ac 1d 2c 	      ldy	rtemp1
    540  1975		       18		      clc
    541  1976		       60		      rts
    542  1977
    543  1977							;=====================================================
    544  1977							; This pushes curptr basic current line onto the call stack.
    545  1977							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1977
    547  1977				   pushLN
    548  1977		       8c 1d 2c 	      sty	rtemp1
    549  197a		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  197c		       c5 4d		      cmp	GOSUBSTACKPTR
    551  197e		       90 1a		      bcc	pusherr	; No error
    552  1980		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  1982		       a2 00		      ldx	#0	; Start of bytes to copy
    554  1984				   pushLoop
    555  1984		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  1986		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  1988		       c8		      iny		; Next destination
    558  1989		       e8		      inx		; Next Source byte
    559  198a		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  198c		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  198e
    562  198e		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  1990		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  1992		       c8		      iny		; Next entry
    565  1993
    566  1993		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  1995		       ac 1d 2c 	      ldy	rtemp1
    568  1998		       18		      clc
    569  1999		       60		      rts
    570  199a				   pusherr
    571  199a		       38		      sec
    572  199b		       60		      rts
    573  199c							;=====================================================
    574  199c							; This pops Top Off gosub call Stack and
    575  199c							; places it in CURPTR/CUROFF.
    576  199c							; This checks if the type = 1 GOSUB
    577  199c							; if not it removes what ever is on the stack
    578  199c							; until it finds the next return. Allowing
    579  199c							; a return from within a for/next
    580  199c		       8c 1d 2c    popLN      sty	rtemp1
    581  199f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  19a1		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  19a3
    584  19a3				   popContinue
    585  19a3		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  19a5		       90 18		      bcc	poperr	; Process an error
    587  19a7
    588  19a7		       88		      dey		; Position to read entry type
    589  19a8		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  19aa		       c9 01		      cmp	#1	; Type is a gosub entry
    591  19ac		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  19ae
    593  19ae				   popLoop
    594  19ae		       88		      dey
    595  19af		       ca		      dex
    596  19b0		       b1 4b		      lda	(GOSUBSTACK),y
    597  19b2		       95 4f		      sta	CURPTR,x
    598  19b4		       e0 00		      cpx	#0
    599  19b6		       d0 f6		      bne	popLoop	; Loop until all moved
    600  19b8
    601  19b8
    602  19b8		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  19ba		       ac 1d 2c 	      ldy	rtemp1
    604  19bd		       18		      clc
    605  19be		       60		      rts
    606  19bf
    607  19bf		       38	   poperr     sec
    608  19c0		       60		      rts
    609  19c1
    610  19c1		       88	   popSkipEntry dey
    611  19c2		       88		      dey
    612  19c3		       88		      dey
    613  19c4		       4c a3 19 	      jmp	popContinue
    614  19c7
    615  19c7							;
    616  19c7							;=====================================================
    617  19c7							; This pushes R1 onto the stack
    618  19c7							;
    619  19c7		       8c 1d 2c    pushR1     sty	rtemp1
    620  19ca		       a4 4a		      ldy	MATHSTACKPTR
    621  19cc		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  19ce		       b0 ef		      bcs	poperr
    623  19d0		       a5 54		      lda	R1
    624  19d2		       91 48		      sta	(MATHSTACK),y
    625  19d4		       c8		      iny
    626  19d5		       a5 55		      lda	R1+1
    627  19d7		       91 48		      sta	(MATHSTACK),y
    628  19d9		       c8		      iny
    629  19da		       84 4a		      sty	MATHSTACKPTR
    630  19dc		       ac 1d 2c 	      ldy	rtemp1
    631  19df		       18		      clc
    632  19e0		       60		      rts
    633  19e1							;
    634  19e1							;=====================================================
    635  19e1							; This pops Top Of Stack and places it in R0.
    636  19e1							;
    637  19e1		       8c 1d 2c    popR0      sty	rtemp1
    638  19e4		       a4 4a		      ldy	MATHSTACKPTR
    639  19e6		       f0 d7		      beq	poperr
    640  19e8		       88		      dey
    641  19e9		       b1 48		      lda	(MATHSTACK),y
    642  19eb		       85 53		      sta	R0+1
    643  19ed		       88		      dey
    644  19ee		       b1 48		      lda	(MATHSTACK),y
    645  19f0		       85 52		      sta	R0
    646  19f2		       84 4a		      sty	MATHSTACKPTR
    647  19f4		       ac 1d 2c 	      ldy	rtemp1
    648  19f7		       18		      clc
    649  19f8		       60		      rts
    650  19f9
    651  19f9							;
    652  19f9							;=====================================================
    653  19f9							; This pops TOS and places it in R1.
    654  19f9							;
    655  19f9		       8c 1d 2c    popR1      sty	rtemp1
    656  19fc		       a4 4a		      ldy	MATHSTACKPTR
    657  19fe		       f0 bf		      beq	poperr
    658  1a00		       88		      dey
    659  1a01		       b1 48		      lda	(MATHSTACK),y
    660  1a03		       85 55		      sta	R1+1
    661  1a05		       88		      dey
    662  1a06		       b1 48		      lda	(MATHSTACK),y
    663  1a08		       85 54		      sta	R1
    664  1a0a		       84 4a		      sty	MATHSTACKPTR
    665  1a0c		       ac 1d 2c 	      ldy	rtemp1
    666  1a0f		       60		      rts
    667  1a10							;
    668  1a10							;=====================================================
    669  1a10							; This pops TOS and places it in MQ.
    670  1a10							;
    671  1a10		       8c 1d 2c    popMQ      sty	rtemp1
    672  1a13		       a4 4a		      ldy	MATHSTACKPTR
    673  1a15		       f0 a8		      beq	poperr
    674  1a17		       88		      dey
    675  1a18		       b1 48		      lda	(MATHSTACK),y
    676  1a1a		       85 57		      sta	MQ+1
    677  1a1c		       88		      dey
    678  1a1d		       b1 48		      lda	(MATHSTACK),y
    679  1a1f		       85 56		      sta	MQ
    680  1a21		       84 4a		      sty	MATHSTACKPTR
    681  1a23		       ac 1d 2c 	      ldy	rtemp1
    682  1a26		       60		      rts
    683  1a27							;
    684  1a27							;=====================================================
    685  1a27							; This assists with multiplication and division by
    686  1a27							; looking at R0 and R1 and saving a flag as to what
    687  1a27							; sign the result will be.  Math is always done on
    688  1a27							; positive numbers, so this converts negative numbers
    689  1a27							; into positives.  On exit, R0 and R1 are both
    690  1a27							; positive.  If the signs were different then 'signs'
    691  1a27							; will be non-zero.
    692  1a27							;
    693  1a27		       a9 00	   SaveSigns  lda	#0
    694  1a29		       8d 1c 2c 	      sta	sign	;assume positive
    695  1a2c		       a5 53		      lda	R0+1	;MSB
    696  1a2e		       10 13		      bpl	SaveSigns1
    697  1a30		       ee 1c 2c 	      inc	sign	;it's negative
    698  1a33		       49 ff		      eor	#$ff	;flip bits
    699  1a35		       85 53		      sta	R0+1
    700  1a37		       a5 52		      lda	R0
    701  1a39		       49 ff		      eor	#$ff
    702  1a3b		       85 52		      sta	R0
    703  1a3d		       e6 52		      inc	R0
    704  1a3f		       d0 02		      bne	SaveSigns1
    705  1a41		       e6 53		      inc	R0+1
    706  1a43		       a5 55	   SaveSigns1 lda	R1+1
    707  1a45		       10 1a		      bpl	SaveSigns2
    708  1a47		       48		      pha
    709  1a48		       ad 1c 2c 	      lda	sign
    710  1a4b		       49 01		      eor	#1
    711  1a4d		       8d 1c 2c 	      sta	sign
    712  1a50		       68		      pla
    713  1a51		       49 ff		      eor	#$ff	;flip bits
    714  1a53		       85 55		      sta	R1+1
    715  1a55		       a5 54		      lda	R1
    716  1a57		       49 ff		      eor	#$ff
    717  1a59		       85 54		      sta	R1
    718  1a5b		       e6 54		      inc	R1
    719  1a5d		       d0 02		      bne	SaveSigns2
    720  1a5f		       e6 55		      inc	R1+1
    721  1a61		       60	   SaveSigns2 rts
    722  1a62							;
    723  1a62							;=====================================================
    724  1a62							; This looks at the value of 'signs' and will convert
    725  1a62							; both R0 and R1 to negative if set.
    726  1a62							;
    727  1a62				   RestoreSigns
    728  1a62		       ad 1c 2c 	      lda	sign
    729  1a65		       f0 28		      beq	restoresigns2
    730  1a67							;
    731  1a67		       a5 52		      lda	R0
    732  1a69		       d0 02		      bne	restoresigns3
    733  1a6b		       c6 53		      dec	R0+1
    734  1a6d				   restoresigns3
    735  1a6d		       c6 52		      dec	R0
    736  1a6f		       a5 52		      lda	R0
    737  1a71		       49 ff		      eor	#$ff
    738  1a73		       85 52		      sta	R0
    739  1a75		       a5 53		      lda	R0+1
    740  1a77		       49 ff		      eor	#$ff
    741  1a79		       85 53		      sta	R0+1
    742  1a7b							;
    743  1a7b		       a5 54		      lda	R1
    744  1a7d		       d0 02		      bne	restoresigns4
    745  1a7f		       c6 55		      dec	R1+1
    746  1a81				   restoresigns4
    747  1a81		       c6 54		      dec	R1
    748  1a83		       a5 54		      lda	R1
    749  1a85		       49 ff		      eor	#$ff
    750  1a87		       85 54		      sta	R1
    751  1a89		       a5 55		      lda	R1+1
    752  1a8b		       49 ff		      eor	#$ff
    753  1a8d		       85 55		      sta	R1+1
    754  1a8f							;
    755  1a8f				   restoresigns2
    756  1a8f		       60		      rts
    757  1a90							;
    758  1a90							;=====================================================
    759  1a90							; Skip over spaces.  Returns Y with the offset to
    760  1a90							; either the last character in the line, or the first
    761  1a90							; non-space character.
    762  1a90							;
    763  1a90
    764  1a90		       c8	   skipsp2    iny
    765  1a91		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  1a93		       f0 04		      beq	Skip3	;end of line
    767  1a95		       c9 20		      cmp	#SPACE
    768  1a97		       f0 f7		      beq	skipsp2
    769  1a99		       60	   Skip3      rts
    770  1a9a							;*********************************************************
    771  1a9a							; Output a CR/LF combination to the console.  Preserves
    772  1a9a							; all registers.
    773  1a9a							;
    774  1a9a		       48	   tbcrlf     pha
    775  1a9b		       a9 0d		      lda	#CR
    776  1a9d		       20 e3 1b 	      jsr	VOUTCH
    777  1aa0		       a9 0a		      lda	#LF
    778  1aa2		       20 e3 1b 	      jsr	VOUTCH
    779  1aa5		       68		      pla
    780  1aa6		       60		      rts
    781  1aa7							;
    782  1aa7							;=====================================================
    783  1aa7							; Some logic to print the Line of basic code being executed
    784  1aa7		       24 40	   idbgBasic  bit	ILTrace
    785  1aa9		       50 70		      bvc	dbgBasicNone
    786  1aab		       98		      tya
    787  1aac		       48		      pha
    788  1aad		       20 6c 1c 	      jsr	SetOutDebug
    789  1ab0		       20 0c 1c 	      jsr	PrtPrgLine
    790  1ab3		       20 9a 1a 	      jsr	CRLF
    791  1ab6		       a5 40		      lda	ILTrace
    792  1ab8		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  1aba		       f0 5a		      beq	dbgBasicDone
    794  1abc		       20 77 1c 	      jsr	SetInDebug
    795  1abf		       20 e9 1b 	      jsr	puts
      0  1ac2					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1ac2		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1aff				   dbgBasicLoop
    798  1aff		       20 e6 1b 	      jsr	VGETCH
    799  1b02		       20 9a 1a 	      jsr	CRLF
    800  1b05		       20 d6 1b 	      jsr	SetInConsole
    801  1b08
    802  1b08		       c9 73		      cmp	#'s	; Quit program
    803  1b0a		       f0 12		      beq	dbgBasicStop
    804  1b0c
    805  1b0c		       c9 64		      cmp	#'d	; Display Variables
    806  1b0e		       d0 06		      bne	dbgBasicDone
    807  1b10
    808  1b10		       20 9b 1c 	      jsr	PrintAllVars
    809  1b13		       18		      clc
    810  1b14		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1b16
    812  1b16		       20 c9 1b    dbgBasicDone jsr	SetOutConsole
    813  1b19		       68		      pla
    814  1b1a		       a8		      tay
    815  1b1b		       4c bb 02    dbgBasicNone jmp	NextIL
    816  1b1e
    817  1b1e				   dbgBasicStop
    818  1b1e		       20 c9 1b 	      jsr	SetOutConsole
    819  1b21		       68		      pla
    820  1b22		       a8		      tay
    821  1b23		       4c 01 06 	      jmp	iFIN
    822  1b26							;
    823  1b26							;=====================================================
    824  1b26							; This is some debug logic which displays the current
    825  1b26							; value of the ILPC and the line buffer.
    826  1b26							;
    827  1b26		       24 40	   dbgLine    bit	ILTrace
    828  1b28		       30 01		      bmi	dbgPrt
    829  1b2a		       60		      rts
    830  1b2b				   dbgPrt
    831  1b2b		       20 6c 1c 	      jsr	SetOutDebug
    832  1b2e		       20 e9 1b 	      jsr	puts
      0  1b31					      db	"ILPC: ",0
      1  1b31		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  1b38		       a5 44		      lda	ILPC+1
    835  1b3a		       20 88 12 	      jsr	OUTHEX
    836  1b3d		       a5 43		      lda	ILPC
    837  1b3f		       20 88 12 	      jsr	OUTHEX
    838  1b42		       a9 20		      lda	#SPACE
    839  1b44		       20 e3 1b 	      jsr	VOUTCH
    840  1b47		       a0 00		      ldy	#0
    841  1b49		       b1 43		      lda	(ILPC),y
    842  1b4b		       20 88 12 	      jsr	OUTHEX
    843  1b4e							;
    844  1b4e							; Display the CURPTR value and offset
    845  1b4e							;
    846  1b4e		       20 e9 1b 	      jsr	puts
      0  1b51					      db	", CURPTR: ",0
      1  1b51		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  1b5c		       a5 50		      lda	CURPTR+1
    849  1b5e		       20 88 12 	      jsr	OUTHEX
    850  1b61		       a5 4f		      lda	CURPTR
    851  1b63		       20 88 12 	      jsr	OUTHEX
    852  1b66		       a9 2b		      lda	#'+
    853  1b68		       20 e3 1b 	      jsr	VOUTCH
    854  1b6b		       a5 51		      lda	CUROFF
    855  1b6d		       20 88 12 	      jsr	OUTHEX
    856  1b70							;
    857  1b70		       20 9a 1a 	      jsr	CRLF
    858  1b73		       20 c9 1b 	      jsr	SetOutConsole
    859  1b76		       20 a9 1b 	      jsr	ILChkRange
    860  1b79		       b0 02		      bcs	dbgLineErr
    861  1b7b		       18		      clc
    862  1b7c		       60		      rts
    863  1b7d
    864  1b7d				   dbgLineErr
    865  1b7d		       20 6c 1c 	      jsr	SetOutDebug
    866  1b80		       20 e9 1b 	      jsr	puts
      0  1b83					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1b83		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  1ba4		       20 c9 1b 	      jsr	SetOutConsole
    869  1ba7		       38		      sec
    870  1ba8		       60		      rts
    871  1ba9
    872  1ba9		       a5 44	   ILChkRange lda	ILPC+1
    873  1bab		       c9 1d		      cmp	#IL>>8
    874  1bad		       90 18		      bcc	ILBadRange
    875  1baf		       d0 06		      bne	ILChkHigh
    876  1bb1
    877  1bb1		       a5 43		      lda	ILPC
    878  1bb3		       c9 f3		      cmp	#IL&$ff
    879  1bb5		       90 10		      bcc	ILBadRange
    880  1bb7
    881  1bb7		       a5 44	   ILChkHigh  lda	ILPC+1
    882  1bb9		       c9 22		      cmp	#ILEND>>8
    883  1bbb		       90 08		      bcc	ILGoodRange
    884  1bbd		       d0 08		      bne	ILBadRange
    885  1bbf
    886  1bbf		       a5 43		      lda	ILPC
    887  1bc1		       c9 bf		      cmp	#ILEND&$ff
    888  1bc3		       b0 02		      bcs	ILBadRange
    889  1bc5
    890  1bc5		       18	   ILGoodRange clc
    891  1bc6		       60		      rts
    892  1bc7				   ILBadRange
    893  1bc7		       38		      sec
    894  1bc8		       60		      rts
    895  1bc9
    896  1bc9
    897  1bc9							;=====================================================
    898  1bc9							; Set output vector to the console output function
    899  1bc9							;
    900  1bc9				   SetOutConsole
    901  1bc9		       48		      pha
    902  1bca		       a9 0c		      lda	#OUTCH&$ff
    903  1bcc		       8d 21 2c 	      sta	BOutVec
    904  1bcf		       a9 f0		      lda	#OUTCH>>8
    905  1bd1		       8d 22 2c 	      sta	BOutVec+1
    906  1bd4		       68		      pla
    907  1bd5		       60		      rts
    908  1bd6
    909  1bd6				   SetInConsole
    910  1bd6		       48		      pha
    911  1bd7		       a9 09		      lda	#GETCH&$ff
    912  1bd9		       8d 23 2c 	      sta	BInVec
    913  1bdc		       a9 f0		      lda	#GETCH>>8
    914  1bde		       8d 24 2c 	      sta	BInVec+1
    915  1be1		       68		      pla
    916  1be2		       60		      rts
    917  1be3
    918  1be3							;=====================================================
    919  1be3							; Jump to the output/input function in BOutVec/BInVec
    920  1be3							;
    921  1be3		       6c 21 2c    VOUTCH     jmp	(BOutVec)
    922  1be6		       6c 23 2c    VGETCH     jmp	(BInVec)
    923  1be9							;
    924  1be9							;=====================================================
    925  1be9							; Print the string that immediately follows the JSR to
    926  1be9							; this function.  Stops when a null byte is found,
    927  1be9							; then returns to the instruction immediately
    928  1be9							; following the null.
    929  1be9							;
    930  1be9							; Thanks to Ross Archer for this code.
    931  1be9							; http://www.6502.org/source/io/primm.htm
    932  1be9							;
    933  1be9
    934  1be9		       68	   tbputs     pla		;Get the low part of "return" address
    935  1bea							;(data start address)
    936  1bea		       85 5e		      sta	PrtFrom
    937  1bec		       68		      pla
    938  1bed		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    939  1bef							;(data start address)
    940  1bef							;Note: actually we're pointing one short
    941  1bef		       a0 01	   PSINB      ldy	#1
    942  1bf1		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    943  1bf3		       e6 5e		      inc	PrtFrom	;update the pointer
    944  1bf5		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    945  1bf7		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    946  1bf9		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    947  1bfb							;   Accumulator
    948  1bfb		       f0 06		      beq	PSIX1	;don't print the final NULL
    949  1bfd		       20 e3 1b 	      jsr	VOUTCH	;write it out
    950  1c00		       4c ef 1b 	      jmp	PSINB	;back around
    951  1c03		       e6 5e	   PSIX1      inc	PrtFrom
    952  1c05		       d0 02		      bne	PSIX2
    953  1c07		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    954  1c09		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    955  1c0c
    956  1c0c							;
    957  1c0c
    958  1c0c							;====================================================
    959  1c0c		       2c 25	   PrtTerm    equ	tempy
    960  1c0c
    961  1c0c							; on exit Print Y has the offset to use
    962  1c0c							; input y =	 addr low
    963  1c0c							;	 x =	 addr high
    964  1c0c							;	 a =	 termination string
    965  1c0c
    966  1c0c				   PrtPrgLine
    967  1c0c		       a9 00		      lda	#0
    968  1c0e		       8d 25 2c 	      sta	PrtTerm
    969  1c11		       f0 05		      beq	PrtPrgText
    970  1c13
    971  1c13		       a9 22	   PrtQuoted  lda	#'"
    972  1c15		       8d 25 2c 	      sta	PrtTerm
    973  1c18
    974  1c18		       a4 51	   PrtPrgText ldy	CUROFF
    975  1c1a		       a5 4f		      lda	CURPTR
    976  1c1c		       85 5e		      sta	PrtFrom
    977  1c1e		       a5 50		      lda	CURPTR+1
    978  1c20		       85 5f		      sta	PrtFrom+1
    979  1c22		       4c 2e 1c 	      jmp	PrtLoop
    980  1c25
    981  1c25							; Print a string pointed to by x= h, y=l terminated by a
    982  1c25							; Return y as the length
    983  1c25
    984  1c25		       86 5f	   PrtStr     stx	PrtFrom+1
    985  1c27		       84 5e		      sty	PrtFrom
    986  1c29		       8d 25 2c 	      sta	PrtTerm
    987  1c2c		       a0 00		      ldy	#0
    988  1c2e							;
    989  1c2e							; On entry here ptrfrom and prtterm point to area to print
    990  1c2e							;
    991  1c2e		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    992  1c30		       cd 25 2c 	      cmp	PrtTerm
    993  1c33		       f0 0b		      beq	PrtEnd
    994  1c35		       c9 00		      cmp	#0	; always end if 0 is found
    995  1c37		       f0 07		      beq	PrtEnd
    996  1c39		       20 e3 1b 	      jsr	VOUTCH
    997  1c3c		       c8		      iny
    998  1c3d		       4c 2e 1c 	      jmp	PrtLoop
    999  1c40		       c8	   PrtEnd     iny		;return byte after the copy
   1000  1c41		       60		      rts
   1001  1c42
   1002  1c42							;====================================================
   1003  1c42							;Clear the terminal assume it is ansii or vt100
   1004  1c42							;
   1005  1c42				   iCLEARSCREEN
   1006  1c42		       20 e9 1b 	      jsr	puts
      0  1c45					      db	$1b,'[,'2,'J,0
      1  1c45		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
   1008  1c4a		       4c bb 02 	      jmp	NextIL
   1009  1c4d
   1010  1c4d							;====================================================
   1011  1c4d							; Push true and false onto math stack
   1012  1c4d				   pushTrue
   1013  1c4d		       a9 ff		      lda	#$ff
   1014  1c4f		       85 52	   pushTF     sta	R0
   1015  1c51		       85 53		      sta	R0+1
   1016  1c53		       20 5d 19 	      jsr	pushR0
   1017  1c56		       60		      rts
   1018  1c57		       a9 00	   pushFalse  lda	#0
   1019  1c59		       f0 f4		      beq	pushTF
   1020  1c5b
   1021  1c5b							;======================================================
   1022  1c5b							; Copy stack top to R1
   1023  1c5b				   CopyStackR1
   1024  1c5b		       98		      tya
   1025  1c5c		       48		      pha
   1026  1c5d		       a4 4a		      ldy	MATHSTACKPTR
   1027  1c5f		       88		      dey
   1028  1c60		       b1 48		      lda	(MATHSTACK),y
   1029  1c62		       85 55		      sta	R1+1
   1030  1c64		       88		      dey
   1031  1c65		       b1 48		      lda	(MATHSTACK),y
   1032  1c67		       85 54		      sta	R1
   1033  1c69		       68		      pla
   1034  1c6a		       a8		      tay
   1035  1c6b		       60		      rts
   1036  1c6c
   1037  1c6c
   1038  1c6c							;====================================================
   1039  1c6c							;Swap the out debug call for standard calls
   1040  1c6c
   1041  1c6c				   SetOutDebug
   1042  1c6c					      if	USEDEBUGPORT
   1043  1c6c		       a9 8c		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1044  1c6e		       8d 21 2c 	      sta	BOutVec
   1045  1c71		       a9 1c		      lda	#OUTDEBUG>>8
   1046  1c73		       8d 22 2c 	      sta	BOutVec+1
   1047  1c76					      endif
   1048  1c76		       60		      rts
   1049  1c77				   SetInDebug
   1050  1c77					      if	USEDEBUGPORT
   1051  1c77		       a9 90		      lda	#INDEBUG&$ff
   1052  1c79		       8d 23 2c 	      sta	BInVec
   1053  1c7c		       a9 1c		      lda	#INDEBUG>>8
   1054  1c7e		       8d 24 2c 	      sta	BInVec+1
   1055  1c81					      endif
   1056  1c81		       60		      rts
   1057  1c82							;
   1058  1c82							;====================================================
   1059  1c82							; Output to the debug console
   1060  1c82							;     x = high address byte
   1061  1c82							;     y = low address byte
   1062  1c82							;     a = Terminator for string
   1063  1c82				   DebugWrite
   1064  1c82		       20 6c 1c 	      jsr	SetOutDebug
   1065  1c85		       20 25 1c 	      jsr	PrtStr
   1066  1c88		       20 c9 1b 	      jsr	SetOutConsole
   1067  1c8b		       60		      rts
   1068  1c8c
   1069  1c8c				   OUTDEBUG
   1070  1c8c		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1071  1c8f		       60		      RTS
   1072  1c90
   1073  1c90		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1074  1c93		       29 01		      and	#$01
   1075  1c95		       f0 f9		      beq	INDEBUG
   1076  1c97		       ad 21 e0 	      lda	DEBUGPORT+1
   1077  1c9a		       60		      rts
   1078  1c9b							;
   1079  1c9b							;=======================================================
   1080  1c9b							; Print all Variables
   1081  1c9b				   PrintAllVars
   1082  1c9b		       a0 00		      ldy	#0
   1083  1c9d		       a9 41		      lda	#'A
   1084  1c9f				   PrintAllVarsLoop
   1085  1c9f		       48		      pha
   1086  1ca0		       b1 41		      lda	(VARIABLES),y
   1087  1ca2		       85 52		      sta	R0
   1088  1ca4		       c8		      iny
   1089  1ca5		       b1 41		      lda	(VARIABLES),y
   1090  1ca7		       85 53		      sta	R0+1
   1091  1ca9
   1092  1ca9		       68		      pla		;get the current letter
   1093  1caa		       48		      pha
   1094  1cab		       20 e3 1b 	      jsr	VOUTCH
   1095  1cae		       20 e9 1b 	      jsr	puts
      0  1cb1					      db	"=",0
      1  1cb1		       3d 00		      .byte.b	"=",0
   1097  1cb3		       68		      pla
   1098  1cb4		       aa		      tax
   1099  1cb5		       e8		      inx
   1100  1cb6		       8a		      txa
   1101  1cb7		       48		      pha		;
   1102  1cb8
   1103  1cb8		       98		      tya
   1104  1cb9		       48		      pha
   1105  1cba		       20 d6 11 	      jsr	PrintDecimal
   1106  1cbd		       20 e9 1b 	      jsr	puts
      0  1cc0					      db	" ",0
      1  1cc0		       20 00		      .byte.b	" ",0
   1108  1cc2		       68		      pla
   1109  1cc3		       a8		      tay
   1110  1cc4		       c8		      iny
   1111  1cc5		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1112  1cc7		       90 d6		      bcc	PrintAllVarsLoop
   1113  1cc9		       20 9a 1a 	      jsr	CRLF
   1114  1ccc
   1115  1ccc		       68		      pla
   1116  1ccd		       60		      rts
   1117  1cce
   1118  1cce
   1119  1cce
   1120  1cce
   1121  1cce
   1122  1cce
   1123  1cce
   1124  1cce
   1125  1cce
   1126  1cce
   1127  1cce
   1128  1cce
   1129  1cce
   1130  1cce
   1131  1cce
   1132  1cce
   1133  1cce
   1134  1cce
   1135  1cce
------- FILE mytb.asm
   2215  1cce
   2216  1cce					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  1cce					      include	"storage.asm"
      1  1cce							;
      2  1cce							;=====================================================
      3  1cce							;=====================================================
      4  1cce							;=====================================================
      5  1cce							; This file contains the functions for saving and
      6  1cce							; restoring programs from some sort of mass storage
      7  1cce							; device.  This particular version is for using the
      8  1cce							; Corsham Tech SD Card System.
      9  1cce							;=====================================================
     10  1cce							;=====================================================
     11  1cce							;=====================================================
     12  1cce
     13 U22bf					      seg.u	TBData
     14 U22bf		       00	   diskBufLength ds	1
     15 U22c0		       00	   diskBufOffset ds	1
     16 U22c1		       00 00 00 00*DiskFileName ds	14
     17 U22cf
     18  1cce					      SEG	Code
     19  1cce
     20  1cce							;
     21  1cce							;=====================================================
     22  1cce							; Open a file for reading as a program.  The next
     23  1cce							; thing on the line should be the filename.
     24  1cce							;
     25  1cce				   iOPENREAD
     26  1cce					      if	XKIM || CTMON65
     27  1cce		       a4 51		      ldy	CUROFF
     28  1cd0		       b1 4f		      lda	(CURPTR),y
     29  1cd2		       d0 07		      bne	iOPENfn	;might be filename
     30  1cd4							;
     31  1cd4							; No filename supplied.
     32  1cd4							;
     33  1cd4		       a9 00	   iOPENnofn  lda	#0
     34  1cd6		       a2 09		      ldx	#ERR_NO_FILENAME
     35  1cd8		       4c 18 06 	      jmp	iErr2
     36  1cdb							;
     37  1cdb							; Add the offset into the buffer start
     38  1cdb							;
     39  1cdb		       18	   iOPENfn    clc
     40  1cdc		       98		      tya
     41  1cdd		       65 4f		      adc	CURPTR
     42  1cdf		       a8		      tay		;LSB
     43  1ce0		       a5 50		      lda	CURPTR+1
     44  1ce2		       69 00		      adc	#0
     45  1ce4		       aa		      tax
     46  1ce5		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  1ce8		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1cea							;
     49  1cea							; Open failed
     50  1cea							;
     51  1cea		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1cec		       a9 00	   Rdfail2    lda	#0
     53  1cee		       4c 18 06 	      jmp	iErr2
     54  1cf1							;
     55  1cf1							; Clear counts and offsets so the next read will
     56  1cf1							; cause the file to be read.
     57  1cf1							;
     58  1cf1		       a9 00	   Ropenok    lda	#0
     59  1cf3		       8d c0 22 	      sta	diskBufOffset
     60  1cf6		       8d bf 22 	      sta	diskBufLength
     61  1cf9		       4c bb 02 	      jmp	NextIL
     62  1cfc					      endif
     63  1cfc
     64  1cfc							;
     65  1cfc							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1cfc							;Remove a file from the disk
     67  1cfc				   iRMFILE
     68  1cfc					      if	XKIM || CTMON65
     69  1cfc		       a4 51		      ldy	CUROFF
     70  1cfe		       b1 4f		      lda	(CURPTR),y
     71  1d00		       f0 19		      beq	iRMnofn
     72  1d02							;
     73  1d02		       18		      clc
     74  1d03		       98		      tya
     75  1d04		       65 4f		      adc	CURPTR
     76  1d06		       a8		      tay		;LSB
     77  1d07		       a5 50		      lda	CURPTR+1
     78  1d09		       69 00		      adc	#0
     79  1d0b		       aa		      tax
     80  1d0c		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1d0f		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1d11		       a9 00		      lda	#0
     83  1d13		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1d15		       4c 18 06 	      jmp	iErr2
     85  1d18		       4c bb 02    wrmOk      jmp	NextIL
     86  1d1b
     87  1d1b							; No filename supplied.
     88  1d1b							;
     89  1d1b		       a9 00	   iRMnofn    lda	#0
     90  1d1d		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1d1f		       4c 18 06 	      jmp	iErr2
     92  1d22					      endif
     93  1d22							;
     94  1d22							;=====================================================
     95  1d22				   iOPENWRITE
     96  1d22					      if	XKIM || CTMON65
     97  1d22		       a4 51		      ldy	CUROFF
     98  1d24		       b1 4f		      lda	(CURPTR),y
     99  1d26		       f0 f3		      beq	iRMnofn
    100  1d28							;
    101  1d28		       18		      clc
    102  1d29		       98		      tya
    103  1d2a		       65 4f		      adc	CURPTR
    104  1d2c		       a8		      tay		;LSB
    105  1d2d		       a5 50		      lda	CURPTR+1
    106  1d2f		       69 00		      adc	#0
    107  1d31		       aa		      tax
    108  1d32		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1d35		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1d37							;
    111  1d37							; Open failed
    112  1d37							;
    113  1d37		       a9 00	   Wdfail     lda	#0
    114  1d39		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1d3b		       4c 18 06 	      jmp	iErr2
    116  1d3e							;
    117  1d3e		       4c bb 02    Wopenok    jmp	NextIL
    118  1d41					      endif
    119  1d41							;
    120  1d41							;=====================================================
    121  1d41							; Gets a line of input from the disk file and puts it
    122  1d41							; into LINBUF.
    123  1d41							;
    124  1d41							; On exit:
    125  1d41							;    CURPTR points to LINBUF
    126  1d41							;    LINBUF contains the line with 0 at the end.
    127  1d41							;    Y has offset to first non-space character
    128  1d41							;    CURROFF has the same as Y.
    129  1d41							;
    130  1d41				   iDGETLINE
    131  1d41					      if	XKIM || CTMON65
    132  1d41		       a2 90		      ldx	#LINBUF&$ff
    133  1d43		       86 4f		      stx	CURPTR
    134  1d45		       a2 2b		      ldx	#LINBUF>>8
    135  1d47		       86 50		      stx	CURPTR+1
    136  1d49							;
    137  1d49		       a2 00		      ldx	#0	;offset
    138  1d4b		       8e 14 2c    iDgetLoop  stx	getlinx
    139  1d4e		       20 ac 1d 	      jsr	getNextFileByte
    140  1d51		       b0 16		      bcs	iGetEOF
    141  1d53		       c9 0d		      cmp	#CR
    142  1d55		       f0 0d		      beq	iGetEOL
    143  1d57		       c9 0a		      cmp	#LF
    144  1d59		       f0 09		      beq	iGetEOL
    145  1d5b		       ae 14 2c 	      ldx	getlinx
    146  1d5e		       9d 90 2b 	      sta	LINBUF,x
    147  1d61		       e8		      inx
    148  1d62		       d0 e7		      bne	iDgetLoop
    149  1d64							;
    150  1d64							; Handle end of line.	If the line has nothing, loop
    151  1d64							; back and get another line.
    152  1d64							;
    153  1d64		       ae 14 2c    iGetEOL    ldx	getlinx	;blank line?
    154  1d67		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  1d69							;
    156  1d69							; This can fall through when there is a line, or
    157  1d69							; called directly when EOF is encountered.
    158  1d69							;
    159  1d69		       ae 14 2c    iGetEOF    ldx	getlinx
    160  1d6c		       a9 00		      lda	#0
    161  1d6e		       9d 90 2b 	      sta	LINBUF,x
    162  1d71		       85 51		      sta	CUROFF
    163  1d73		       a0 00		      ldy	#0
    164  1d75		       20 91 1a 	      jsr	SkipSpaces
    165  1d78		       4c bb 02 	      jmp	NextIL
    166  1d7b					      endif
    167  1d7b
    168  1d7b							;
    169  1d7b							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  1d7b							; DISK
    171  1d7b							;
    172  1d7b				   iDDIR
    173  1d7b					      if	XKIM || CTMON65
    174  1d7b		       20 30 f0 	      jsr	DiskDir
    175  1d7e							;
    176  1d7e							; Get/Display each entry
    177  1d7e							;
    178  1d7e		       a2 22	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  1d80		       a0 c1		      ldy	#DiskFileName&$ff
    180  1d82		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  1d85		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  1d87		       20 e9 1b 	      jsr	puts
      0  1d8a					      db	"   ",0
      1  1d8a		       20 20 20 00	      .byte.b	"   ",0
    184  1d8e							; Print the line to the console
    185  1d8e		       a2 22		      ldx	#DiskFileName>>8	;pointer to buffer
    186  1d90		       a0 c1		      ldy	#DiskFileName&$ff
    187  1d92		       a5 00		      lda	0
    188  1d94		       20 25 1c 	      jsr	PrtStr	;else print name
    189  1d97		       20 18 f0 	      jsr	crlf
    190  1d9a
    191  1d9a		       4c 7e 1d 	      jmp	DiskDirLoop	;do next entry
    192  1d9d
    193  1d9d		       4c bb 02    DiskDirEnd jmp	NextIL
    194  1da0					      endif
    195  1da0							;
    196  1da0							;=====================================================
    197  1da0							; Does a LIST to a Disk file.
    198  1da0							;
    199  1da0				   iDLIST
    200  1da0					      if	XKIM || CTMON65
    201  1da0		       20 db 1d 	      jsr	SetOutDisk
    202  1da3		       4c e8 07 	      jmp	iLST2
    203  1da6					      endif
    204  1da6							;
    205  1da6							;=====================================================
    206  1da6							; Closes any pending disk file.  Okay to call if there
    207  1da6							; is no open file.
    208  1da6							;
    209  1da6				   iDCLOSE
    210  1da6					      if	XKIM || CTMON65
    211  1da6		       20 42 f0 	      jsr	DiskClose
    212  1da9		       4c bb 02 	      jmp	NextIL
    213  1dac					      endif
    214  1dac							;
    215  1dac							;=====================================================
    216  1dac							; This gets the next byte from an open disk file.  If
    217  1dac							; there are no more bytes left, this returns C set.
    218  1dac							; Else, C is clear and A contains the character.
    219  1dac							;
    220  1dac				   getNextFileByte
    221  1dac					      if	XKIM || CTMON65
    222  1dac		       ae c0 22 	      ldx	diskBufOffset
    223  1daf		       ec bf 22 	      cpx	diskBufLength
    224  1db2		       d0 14		      bne	hasdata	;branch if still data
    225  1db4							;
    226  1db4							; There is no data left in the buffer, so read a
    227  1db4							; block from the SD system.
    228  1db4							;
    229  1db4		       a9 84		      lda	#BUFFER_SIZE
    230  1db6		       a2 df		      ldx	#buffer>>8
    231  1db8		       a0 0a		      ldy	#buffer&$ff
    232  1dba		       20 3c f0 	      jsr	DiskRead
    233  1dbd		       b0 12		      bcs	getNextEof
    234  1dbf							;
    235  1dbf							; A contains the number of bytes actually read.
    236  1dbf							;
    237  1dbf		       8d bf 22 	      sta	diskBufLength	;save length
    238  1dc2		       c9 00		      cmp	#0	;shouldn't happen
    239  1dc4		       f0 0b		      beq	getNextEof
    240  1dc6							;
    241  1dc6		       a2 00		      ldx	#0
    242  1dc8		       bd 0a df    hasdata    lda	buffer,x
    243  1dcb		       e8		      inx
    244  1dcc		       8e c0 22 	      stx	diskBufOffset
    245  1dcf		       18		      clc
    246  1dd0		       60		      rts
    247  1dd1							;
    248  1dd1		       a9 00	   getNextEof lda	#0
    249  1dd3		       8d c0 22 	      sta	diskBufOffset
    250  1dd6		       8d bf 22 	      sta	diskBufLength
    251  1dd9		       38		      sec
    252  1dda		       60		      rts
    253  1ddb							;
    254  1ddb							;=====================================================
    255  1ddb							; Set output vector to the disk output function
    256  1ddb							;
    257  1ddb		       a9 e6	   SetOutDisk lda	#DOUT&$ff
    258  1ddd		       8d 21 2c 	      sta	BOutVec
    259  1de0		       a9 1d		      lda	#DOUT/256
    260  1de2		       8d 22 2c 	      sta	BOutVec+1
    261  1de5		       60		      rts
    262  1de6							;
    263  1de6							;=====================================================
    264  1de6
    265  1de6		       8d 0a df    DOUT       sta	buffer
    266  1de9		       a9 01		      lda	#1
    267  1deb		       a0 0a		      ldy	#buffer&$ff
    268  1ded		       a2 df		      ldx	#buffer>>8
    269  1def		       20 3f f0 	      jsr	DiskWrite
    270  1df2							;
    271  1df2							; need error checking here
    272  1df2							;
    273  1df2		       60		      rts
    274  1df3					      endif
    275  1df3
    276  1df3
------- FILE mytb.asm
   2218  1df3					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1df3					      include	"IL.inc"
      1  1df3
      2  1df3							;=====================================================
      3  1df3							; IL.inc
      4  1df3							; These are macros for IL instructions
      5  1df3							;
      6  1df3					      mac	dw
      7  1df3					      .word	{0}
      8  1df3					      endm
      9  1df3					      mac	db
     10  1df3					      .byte	{0}
     11  1df3					      endm
     12  1df3					      macro	xinit
     13  1df3					      db	0
     14  1df3					      endm		;reset the il to start clear all
     15  1df3							;
     16  1df3					      macro	done
     17  1df3					      db	1
     18  1df3					      endm		;print an error if not end of line
     19  1df3							;
     20  1df3					      macro	prs
     21  1df3					      db	2
     22  1df3					      endm		;print a quoted string
     23  1df3							;
     24  1df3					      macro	prn
     25  1df3					      db	3
     26  1df3					      endm		;print a number
     27  1df3							;
     28  1df3					      macro	spc
     29  1df3					      db	4
     30  1df3					      endm		;print space til new tabstop
     31  1df3							;
     32  1df3					      macro	nline
     33  1df3					      db	5
     34  1df3					      endm		;print a new line crlf
     35  1df3							;
     36  1df3							; My NXT is a bit different in that it takes one
     37  1df3							; parameter, which is an address.  If the BASIC
     38  1df3							; program is currently running then move to the
     39  1df3							; next line and continue execution.  However, if
     40  1df3							; in direct mode, jump to the specified IL label.
     41  1df3							;
     42  1df3					      macro	nxt
     43  1df3					      db	6
     44  1df3					      dw	{1}	; addr
     45  1df3					      endm		; addr
     46  1df3							;
     47  1df3					      macro	xfer
     48  1df3					      db	7
     49  1df3					      endm
     50  1df3							;
     51  1df3					      macro	sav
     52  1df3					      db	8
     53  1df3					      db	{1}
     54  1df3					      endm
     55  1df3							;
     56  1df3					      macro	rstr
     57  1df3					      db	9
     58  1df3					      endm
     59  1df3							;
     60  1df3					      macro	cmpr
     61  1df3					      db	10
     62  1df3					      endm
     63  1df3							;
     64  1df3					      macro	innum
     65  1df3					      db	11
     66  1df3					      endm
     67  1df3							;
     68  1df3					      macro	fin
     69  1df3					      db	12
     70  1df3					      endm
     71  1df3							;
     72  1df3							; ERR is followed by an error number.	The error
     73  1df3							; code is printed along with the line number.
     74  1df3							; Control is passed to the statement set with
     75  1df3							; the ERRGOTO statement.
     76  1df3							;
     77  1df3					      macro	errmsg
     78  1df3					      db	13
     79  1df3					      dw	{1}	;ecode
     80  1df3					      endm		;ecode
     81  1df3							;
     82  1df3					      macro	add
     83  1df3					      db	14
     84  1df3					      endm
     85  1df3							;
     86  1df3					      macro	sub
     87  1df3					      db	15
     88  1df3					      endm
     89  1df3							;
     90  1df3					      macro	neg
     91  1df3					      db	16
     92  1df3					      endm
     93  1df3							;
     94  1df3					      macro	mul
     95  1df3					      db	17
     96  1df3					      endm
     97  1df3							;
     98  1df3					      macro	div
     99  1df3					      db	18
    100  1df3					      endm
    101  1df3							;
    102  1df3					      macro	store
    103  1df3					      db	19
    104  1df3					      endm
    105  1df3							;
    106  1df3					      macro	ind
    107  1df3					      db	20
    108  1df3					      endm
    109  1df3							;
    110  1df3					      macro	lst
    111  1df3					      db	21
    112  1df3					      endm
    113  1df3							;
    114  1df3					      macro	init
    115  1df3					      db	22
    116  1df3					      endm
    117  1df3							;
    118  1df3					      macro	getline
    119  1df3					      db	23
    120  1df3					      endm
    121  1df3							;
    122  1df3					      macro	insert
    123  1df3					      db	24
    124  1df3					      endm
    125  1df3							;
    126  1df3					      macro	rtn
    127  1df3					      db	25
    128  1df3					      endm
    129  1df3							;
    130  1df3					      macro	exit
    131  1df3					      db	26
    132  1df3					      endm
    133  1df3							;
    134  1df3					      macro	lit
    135  1df3					      db	27
    136  1df3					      dw	{1}	;value
    137  1df3					      endm		; value LIT
    138  1df3							;
    139  1df3					      macro	call
    140  1df3					      db	28
    141  1df3					      dw	{1}	;addr
    142  1df3					      endm		;addr
    143  1df3							;
    144  1df3							; IJMP will set the IL PC to the specified value.
    145  1df3							;
    146  1df3					      macro	ijmp
    147  1df3					      db	29
    148  1df3					      dw	{1}	;addr
    149  1df3					      endm		;addr
    150  1df3							;
    151  1df3					      macro	vinit
    152  1df3					      db	30
    153  1df3					      endm
    154  1df3							;
    155  1df3							; ERRGOTO sets the point in the code where the IL
    156  1df3							; interpreter will go after any error.
    157  1df3							;
    158  1df3					      macro	errgoto
    159  1df3					      db	31
    160  1df3					      dw	{1}	;addr
    161  1df3					      endm		;addr
    162  1df3							;
    163  1df3					      macro	tst
    164  1df3					      db	32
    165  1df3					      db	({1}-*)-1	;(addr-*)-1
    166  1df3					      db	{2},0	;string,0
    167  1df3					      endm		;addr,string
    168  1df3							;
    169  1df3					      macro	tstv
    170  1df3					      db	33
    171  1df3					      db	({1}-*)-1	;(addr-*)-1
    172  1df3					      endm		;addr
    173  1df3							;
    174  1df3					      macro	tstl
    175  1df3					      db	34
    176  1df3					      db	({1}-*)-1	;(addr-*)-1
    177  1df3					      endm		;addr
    178  1df3							;
    179  1df3					      macro	tstn
    180  1df3					      db	35
    181  1df3					      db	({1}-*)-1	;(addr-*)-1
    182  1df3					      endm		;addr
    183  1df3							;
    184  1df3							; FREE returns the amount of free RAM on top of
    185  1df3							; the stack.  This is the amount of room the user
    186  1df3							; program has available.
    187  1df3							;
    188  1df3					      macro	free
    189  1df3					      db	36
    190  1df3					      endm
    191  1df3							;
    192  1df3							; RANDOM takes the top item off the stack and
    193  1df3							; replaces it with a random number that is
    194  1df3							; MOD the initial value.  Ie, if the TOS is
    195  1df3							; 42 then RANDOM returns a value from 0 to 41.
    196  1df3							;
    197  1df3					      macro	random
    198  1df3					      db	37
    199  1df3					      endm
    200  1df3							;
    201  1df3							; ABS will replace the top of stack with the
    202  1df3							; absolute value.
    203  1df3							;
    204  1df3					      macro	abs
    205  1df3					      db	38
    206  1df3					      endm
    207  1df3							;
    208  1df3							; OPENREAD opens a file for reading, as in getting
    209  1df3							; statements from it.
    210  1df3							;
    211  1df3					      macro	openread
    212  1df3					      db	39
    213  1df3					      endm
    214  1df3							;
    215  1df3							; OPENWRITE opens a file for writing, as in saving
    216  1df3							; the current program to it.
    217  1df3							;
    218  1df3					      macro	openwrite
    219  1df3					      db	40
    220  1df3					      endm
    221  1df3							;
    222  1df3							; DCLOSE closes any open disk file.
    223  1df3							;
    224  1df3					      macro	dclose
    225  1df3					      db	41
    226  1df3					      endm
    227  1df3							;
    228  1df3							; DGETLINE gets one line from the disk file and puts it
    229  1df3							; into LINBUFF.
    230  1df3							;
    231  1df3					      macro	dgetline
    232  1df3					      db	42
    233  1df3					      endm
    234  1df3							;
    235  1df3							; DLIST saves the program to an open disk file.
    236  1df3							;
    237  1df3					      macro	dlist
    238  1df3					      db	43
    239  1df3					      endm
    240  1df3							; DDIR list the current directory
    241  1df3							;
    242  1df3					      macro	ddir
    243  1df3					      db	44
    244  1df3					      endm
    245  1df3
    246  1df3							; RMFILE remove a fle from disk
    247  1df3					      macro	rmfile
    248  1df3					      db	45
    249  1df3					      endm
    250  1df3
    251  1df3							; CLEARSCREEN clear the screen
    252  1df3					      macro	clearscreen
    253  1df3					      db	46
    254  1df3					      endm
    255  1df3							; POKEMEM Poke value into memory
    256  1df3					      macro	pokemem
    257  1df3					      db	47
    258  1df3					      endm
    259  1df3							; PEEKMEM peek at value in memory
    260  1df3					      macro	peekmem
    261  1df3					      db	48
    262  1df3					      endm
    263  1df3							; TSTLET Test if the statement is a let without the keyword let
    264  1df3					      macro	tstlet
    265  1df3					      db	49
    266  1df3					      db	({1}-*)-1	;(addr-*)-1
    267  1df3					      endm		;addr
    268  1df3							; TSTDONE if we reach the end of a statement
    269  1df3					      macro	tstdone
    270  1df3					      db	50
    271  1df3					      db	({1}-*)-1	;(addr-*)-1
    272  1df3					      endm		;addr
    273  1df3							; GETCHAR	get a character from the input line leave it in RO
    274  1df3					      macro	getchar
    275  1df3					      db	51
    276  1df3					      endm
    277  1df3							; PUTCHAR	Put a character to the terminal
    278  1df3					      macro	putchar
    279  1df3					      db	52
    280  1df3					      endm
    281  1df3							; Call		Call a machine function return a to stack
    282  1df3					      macro	callfunc
    283  1df3					      db	53
    284  1df3					      endm
    285  1df3
    286  1df3							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1df3					      macro	ibranch
    288  1df3					      db	54
    289  1df3					      endm
    290  1df3
    291  1df3							; TSTSTR	 Tests for the open quote in a string
    292  1df3					      macro	tststr
    293  1df3					      db	55
    294  1df3					      db	({1}-*)-1	;(addr-*)-1
    295  1df3					      endm
    296  1df3							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1df3					      macro	setirq
    298  1df3					      db	56
    299  1df3					      endm
    300  1df3
    301  1df3							; TSTIRQ	Test for irq pending,
    302  1df3							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1df3					      macro	tstirq
    304  1df3					      db	57
    305  1df3					      db	({1}-*)-1	;(addr-*)-1
    306  1df3					      endm
    307  1df3
    308  1df3							; IRET    return from interupt service
    309  1df3					      macro	iret
    310  1df3					      db	58
    311  1df3					      endm
    312  1df3
    313  1df3							; INSTR   read a string from the input
    314  1df3					      macro	instr
    315  1df3					      db	59
    316  1df3					      endm
    317  1df3
    318  1df3							; MODULO Returns the remainder of the division
    319  1df3					      macro	modulo
    320  1df3					      db	60
    321  1df3					      endm
    322  1df3							; Set a task line
    323  1df3					      macro	taskcreate
    324  1df3					      db	61
    325  1df3					      endm
    326  1df3							; End a task
    327  1df3					      macro	etask
    328  1df3					      db	62
    329  1df3					      endm
    330  1df3							; Skip to next task
    331  1df3					      macro	ntask
    332  1df3					      db	63
    333  1df3					      endm
    334  1df3							; Subscript
    335  1df3					      macro	subscript
    336  1df3					      db	64
    337  1df3					      endm
    338  1df3							; KILL Task
    339  1df3					      macro	taskkill
    340  1df3					      db	65
    341  1df3					      endm
    342  1df3							; STAT Task
    343  1df3					      macro	taskstat
    344  1df3					      db	66
    345  1df3					      endm
    346  1df3							;  output value as hex
    347  1df3					      macro	hexprt
    348  1df3					      db	67
    349  1df3					      endm
    350  1df3							;  Read in background has completed
    351  1df3					      macro	readcomplete
    352  1df3					      db	68
    353  1df3					      endm
    354  1df3							;  ReadInput line
    355  1df3					      macro	readstart
    356  1df3					      db	69
    357  1df3					      endm
    358  1df3							; Startio request
    359  1df3					      macro	startio
    360  1df3					      db	70
    361  1df3					      endm
    362  1df3							; Endio
    363  1df3					      macro	endio
    364  1df3					      db	71
    365  1df3					      endm
    366  1df3							; Logical not
    367  1df3					      macro	lognot
    368  1df3					      db	72
    369  1df3					      endm
    370  1df3							; Logical OR
    371  1df3					      macro	logor
    372  1df3					      db	73
    373  1df3					      endm
    374  1df3							;Logical and
    375  1df3					      macro	logand
    376  1df3					      db	74
    377  1df3					      endm
    378  1df3							;Logical XOR
    379  1df3					      macro	logxor
    380  1df3					      db	75
    381  1df3					      endm
    382  1df3							;Wait for task to complete, or list of tasks
    383  1df3					      macro	wtask
    384  1df3					      db	76
    385  1df3					      db	({1}-*)-1	;(addr-*)-1
    386  1df3					      endm
    387  1df3							;Get the current task id
    388  1df3					      MACRO	taskpid
    389  1df3					      db	77
    390  1df3					      endm
    391  1df3							;Trace the basic execution
    392  1df3					      Macro	traceprogram
    393  1df3					      db	78
    394  1df3					      endm
    395  1df3							;Do a basic program Trace
    396  1df3					      Macro	debugbasic
    397  1df3					      db	79
    398  1df3					      endm
    399  1df3
    400  1df3							; Inter Process communications instructions
    401  1df3					      Macro	ipcsend
    402  1df3					      db	80
    403  1df3					      endm
    404  1df3					      Macro	ipcreceive
    405  1df3					      db	81
    406  1df3					      endm
    407  1df3					      Macro	ipccheck
    408  1df3					      db	82
    409  1df3					      endm
    410  1df3					      Macro	ipcio
    411  1df3					      db	83
    412  1df3					      endm
    413  1df3					      Macro	pushmathstack
    414  1df3					      db	84
    415  1df3					      endm
    416  1df3					      Macro	popmathstack
    417  1df3					      db	85
    418  1df3					      endm
    419  1df3					      Macro	savemathstack
    420  1df3					      db	86
    421  1df3					      endm
    422  1df3					      Macro	restoremathstack
    423  1df3					      db	87
    424  1df3					      endm
    425  1df3					      Macro	incparmcount
    426  1df3					      db	88
    427  1df3					      endm
    428  1df3					      Macro	taskgetmathstack
    429  1df3					      db	89
    430  1df3					      endm
    431  1df3					      Macro	taskenable
    432  1df3					      db	90
    433  1df3					      endm
    434  1df3					      Macro	tasksuspend
    435  1df3					      db	91
    436  1df3					      endm
    437  1df3					      Macro	taskputmathptr
    438  1df3					      db	92
    439  1df3					      endm
    440  1df3							; Test for an extension type of variable that allows access to a tasks variables
    441  1df3							; Using  PID!<Var name>
    442  1df3					      Macro	tstvt
    443  1df3					      db	93
    444  1df3					      db	({1}-*)-1	;(addr-*)-1
    445  1df3					      endm
    446  1df3
    447  1df3							; Provide access to R2 for the IL program
    448  1df3					      Macro	setr2
    449  1df3					      db	94
    450  1df3					      db	{1}	; R2 is only one byte
    451  1df3					      endm
    452  1df3							;Move stack top to temp
    453  1df3					      Macro	stk2tmp
    454  1df3					      db	95
    455  1df3					      endm
    456  1df3
    457  1df3					      Macro	tmp2stk
    458  1df3					      db	96
    459  1df3					      endm
    460  1df3
    461  1df3					      Macro	tstbyte
    462  1df3					      db	97
    463  1df3					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1df3					      dw	{2}	; address to check
    465  1df3					      db	{3}	; Value to compare
    466  1df3					      endm
    467  1df3
    468  1df3					      Macro	incvar
    469  1df3					      db	98
    470  1df3					      endm
    471  1df3					      Macro	decvar
    472  1df3					      db	99
    473  1df3					      endm
    474  1df3
    475  1df3					      Macro	slice
    476  1df3					      db	100
    477  1df3					      endm
    478  1df3
    479  1df3
    480  1df3
------- FILE mytb.asm
   2220  1df3							;
   2221  1df3				  -	      if	FIXED
   2222  1df3				  -	      org	$1000
   2223  1df3					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1df3					      include	"basic.il"
      1  1df3							;LET
      2  1df3							;=====================================================
      3  1df3							;=====================================================
      4  1df3					      seg	Code
      5  1df3							;=====================================================
      6  1df3							; This is the IL of the BASIC (or whatever) language.
      7  1df3							; Because of the way macros are implemented by as65,
      8  1df3							; labels can't be on the same line as a macro
      9  1df3							; invocation, so that's why labels are on separate
     10  1df3							; lines.
     11  1df3							;
     12  1df3		       1d f3	   IL	      equ	*
     13  1df3
     14  1df3							;THE IL CONTROL SECTION
     15  1df3
     16  1df3				   START
      0  1df3					      INIT		;INITIALIZE
      0  1df3					      db	22
      1  1df3		       16		      .byte.b	22
      0  1df4					      NLINE		;WRITE CRLF
      0  1df4					      db	5
      1  1df4		       05		      .byte.b	5
      0  1df5					      ERRGOTO	CO	;where to go after an error
      0  1df5					      db	31
      1  1df5		       1f		      .byte.b	31
      0  1df6					      dw	CO
      1  1df6		       f9 1d		      .word.w	CO
      0  1df8					      VINIT		;clear all variables
      0  1df8					      db	30
      1  1df8		       1e		      .byte.b	30
     21  1df9							;
     22  1df9							; This is where we jump to get a line of commands or
     23  1df9							; a program from the user.
     24  1df9							;
     25  1df9				   CO
      0  1df9					      GETLINE		;WRITE PROMPT AND GET LINE
      0  1df9					      db	23
      1  1df9		       17		      .byte.b	23
      0  1dfa					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1dfa					      db	34
      1  1dfa		       22		      .byte.b	34
      0  1dfb					      db	(XEC-*)-1
      1  1dfb		       04		      .byte.b	(XEC-*)-1
      0  1dfc					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1dfc					      db	24
      1  1dfc		       18		      .byte.b	24
      0  1dfd					      IJMP	CO
      0  1dfd					      db	29
      1  1dfd		       1d		      .byte.b	29
      0  1dfe					      dw	CO
      1  1dfe		       f9 1d		      .word.w	CO
     30  1e00				   XEC
      0  1e00					      XINIT		;INITIALIZE
      0  1e00					      db	0
      1  1e00		       00		      .byte.b	0
     32  1e01							;============================================================================
     33  1e01							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1e01							;
     35  1e01				   STMT
      0  1e01					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1e01					      db	79
      1  1e01		       4f		      .byte.b	79
      0  1e02					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1e02					      db	57
      1  1e02		       39		      .byte.b	57
      0  1e03					      db	(notirq-*)-1
      1  1e03		       00		      .byte.b	(notirq-*)-1
     38  1e04							;==========================================================================================
     39  1e04							; Process a let statement implied or explicit.
     40  1e04							;
     41  1e04				   notirq
      0  1e04					      TSTLET	LET	;Test if second field is = or []
      0  1e04					      db	49
      1  1e04		       31		      .byte.b	49
      0  1e05					      db	(LET-*)-1
      1  1e05		       03		      .byte.b	(LET-*)-1
      0  1e06					      IJMP	DOLET	;allow the default to be let
      0  1e06					      db	29
      1  1e06		       1d		      .byte.b	29
      0  1e07					      dw	DOLET
      1  1e07		       0f 1e		      .word.w	DOLET
     44  1e09				   LET
      0  1e09					      TST	S1,"LET"	;IS STATEMENT A LET
      0  1e09					      db	32
      1  1e09		       20		      .byte.b	32
      0  1e0a					      db	(S1-*)-1
      1  1e0a		       21		      .byte.b	(S1-*)-1
      0  1e0b					      db	"LET",0
      1  1e0b		       4c 45 54 00	      .byte.b	"LET",0
     46  1e0f				   DOLET
      0  1e0f					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1e0f					      db	33
      1  1e0f		       21		      .byte.b	33
      0  1e10					      db	(ERRVEC-*)-1
      1  1e10		       ea		      .byte.b	(ERRVEC-*)-1
      0  1e11					      TST	LETBE,"["
      0  1e11					      db	32
      1  1e11		       20		      .byte.b	32
      0  1e12					      db	(LETBE-*)-1
      1  1e12		       0a		      .byte.b	(LETBE-*)-1
      0  1e13					      db	"[",0
      1  1e13		       5b 00		      .byte.b	"[",0
      0  1e15					      CALL	EXPR
      0  1e15					      db	28
      1  1e15		       1c		      .byte.b	28
      0  1e16					      dw	EXPR
      1  1e16		       9e 20		      .word.w	EXPR
      0  1e18					      TST	ERRVEC,"]"
      0  1e18					      db	32
      1  1e18		       20		      .byte.b	32
      0  1e19					      db	(ERRVEC-*)-1
      1  1e19		       e1		      .byte.b	(ERRVEC-*)-1
      0  1e1a					      db	"]",0
      1  1e1a		       5d 00		      .byte.b	"]",0
      0  1e1c					      SUBSCRIPT
      0  1e1c					      db	64
      1  1e1c		       40		      .byte.b	64
     52  1e1d				   LETBE
      0  1e1d					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1e1d					      db	32
      1  1e1d		       20		      .byte.b	32
      0  1e1e					      db	(ERRVEC-*)-1
      1  1e1e		       dc		      .byte.b	(ERRVEC-*)-1
      0  1e1f					      db	"=",0
      1  1e1f		       3d 00		      .byte.b	"=",0
      0  1e21					      CALL	EXPR	;PLACE EXPR VALUE ON MathSTK
      0  1e21					      db	28
      1  1e21		       1c		      .byte.b	28
      0  1e22					      dw	EXPR
      1  1e22		       9e 20		      .word.w	EXPR
      0  1e24					      DONE		;REPORT ERROR IF NOT NEXT
      0  1e24					      db	1
      1  1e24		       01		      .byte.b	1
      0  1e25					      STORE		;STORE RESULT
      0  1e25					      db	19
      1  1e25		       13		      .byte.b	19
      0  1e26					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1e26					      db	6
      1  1e26		       06		      .byte.b	6
      0  1e27					      dw	CO
      1  1e27		       f9 1d		      .word.w	CO
      0  1e29					      IJMP	STMT
      0  1e29					      db	29
      1  1e29		       1d		      .byte.b	29
      0  1e2a					      dw	STMT
      1  1e2a		       01 1e		      .word.w	STMT
     59  1e2c							;=============================================================
     60  1e2c							; Inc or dec a variable
     61  1e2c				   S1
      0  1e2c					      TST	S1Dec,"INC"	;Increment variable
      0  1e2c					      db	32
      1  1e2c		       20		      .byte.b	32
      0  1e2d					      db	(S1Dec-*)-1
      1  1e2d		       0e		      .byte.b	(S1Dec-*)-1
      0  1e2e					      db	"INC",0
      1  1e2e		       49 4e 43 00	      .byte.b	"INC",0
      0  1e32					      TSTV	ERRVEC
      0  1e32					      db	33
      1  1e32		       21		      .byte.b	33
      0  1e33					      db	(ERRVEC-*)-1
      1  1e33		       c7		      .byte.b	(ERRVEC-*)-1
      0  1e34					      INCVAR
      0  1e34					      db	98
      1  1e34		       62		      .byte.b	98
      0  1e35					      DONE
      0  1e35					      db	1
      1  1e35		       01		      .byte.b	1
      0  1e36					      NXT	CO
      0  1e36					      db	6
      1  1e36		       06		      .byte.b	6
      0  1e37					      dw	CO
      1  1e37		       f9 1d		      .word.w	CO
      0  1e39					      IJMP	STMT
      0  1e39					      db	29
      1  1e39		       1d		      .byte.b	29
      0  1e3a					      dw	STMT
      1  1e3a		       01 1e		      .word.w	STMT
     68  1e3c				   S1Dec
      0  1e3c					      TST	S1Iret,"DEC"	;Dec variable
      0  1e3c					      db	32
      1  1e3c		       20		      .byte.b	32
      0  1e3d					      db	(S1Iret-*)-1
      1  1e3d		       0e		      .byte.b	(S1Iret-*)-1
      0  1e3e					      db	"DEC",0
      1  1e3e		       44 45 43 00	      .byte.b	"DEC",0
      0  1e42					      TSTV	ERRVEC
      0  1e42					      db	33
      1  1e42		       21		      .byte.b	33
      0  1e43					      db	(ERRVEC-*)-1
      1  1e43		       b7		      .byte.b	(ERRVEC-*)-1
      0  1e44					      DECVAR
      0  1e44					      db	99
      1  1e44		       63		      .byte.b	99
      0  1e45					      DONE
      0  1e45					      db	1
      1  1e45		       01		      .byte.b	1
      0  1e46					      NXT	CO
      0  1e46					      db	6
      1  1e46		       06		      .byte.b	6
      0  1e47					      dw	CO
      1  1e47		       f9 1d		      .word.w	CO
      0  1e49					      IJMP	STMT
      0  1e49					      db	29
      1  1e49		       1d		      .byte.b	29
      0  1e4a					      dw	STMT
      1  1e4a		       01 1e		      .word.w	STMT
     75  1e4c							;====================================================================
     76  1e4c							; iret or ireturn, Return from interupt process
     77  1e4c							;
     78  1e4c				   S1Iret
      0  1e4c					      TST	S1S1,"IRET"	;test return from interupt
      0  1e4c					      db	32
      1  1e4c		       20		      .byte.b	32
      0  1e4d					      db	(S1S1-*)-1
      1  1e4d		       10		      .byte.b	(S1S1-*)-1
      0  1e4e					      db	"IRET",0
      1  1e4e		       49 52 45 54*	      .byte.b	"IRET",0
      0  1e53					      TST	S1Sa,"URN"
      0  1e53					      db	32
      1  1e53		       20		      .byte.b	32
      0  1e54					      db	(S1Sa-*)-1
      1  1e54		       04		      .byte.b	(S1Sa-*)-1
      0  1e55					      db	"URN",0
      1  1e55		       55 52 4e 00	      .byte.b	"URN",0
     81  1e59				   S1Sa
      0  1e59					      DONE		;Must be only thing on the line
      0  1e59					      db	1
      1  1e59		       01		      .byte.b	1
      0  1e5a					      IRET		;RESTORE LINE NUMBER OF CALL
      0  1e5a					      db	58
      1  1e5a		       3a		      .byte.b	58
      0  1e5b					      IJMP	STMT
      0  1e5b					      db	29
      1  1e5b		       1d		      .byte.b	29
      0  1e5c					      dw	STMT
      1  1e5c		       01 1e		      .word.w	STMT
     85  1e5e							;=======================================================================
     86  1e5e							;Process if statement, if true then process all statements until end of line reached
     87  1e5e				   S1S1
      0  1e5e					      TST	S1Z,"IF"	;IF STATEMENT
      0  1e5e					      db	32
      1  1e5e		       20		      .byte.b	32
      0  1e5f					      db	(S1Z-*)-1
      1  1e5f		       11		      .byte.b	(S1Z-*)-1
      0  1e60					      db	"IF",0
      1  1e60		       49 46 00 	      .byte.b	"IF",0
      0  1e63					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1e63					      db	28
      1  1e63		       1c		      .byte.b	28
      0  1e64					      dw	EXPR
      1  1e64		       9e 20		      .word.w	EXPR
      0  1e66					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  1e66					      db	32
      1  1e66		       20		      .byte.b	32
      0  1e67					      db	(S1W-*)-1
      1  1e67		       05		      .byte.b	(S1W-*)-1
      0  1e68					      db	"THEN",0
      1  1e68		       54 48 45 4e*	      .byte.b	"THEN",0
     91  1e6d				   S1W
      0  1e6d					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1e6d					      db	54
      1  1e6d		       36		      .byte.b	54
      0  1e6e					      IJMP	STMT
      0  1e6e					      db	29
      1  1e6e		       1d		      .byte.b	29
      0  1e6f					      dw	STMT
      1  1e6f		       01 1e		      .word.w	STMT
     94  1e71							;===============================================================
     95  1e71							; Test for GO
     96  1e71				   S1Z
      0  1e71					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1e71					      db	32
      1  1e71		       20		      .byte.b	32
      0  1e72					      db	(S2b-*)-1
      1  1e72		       19		      .byte.b	(S2b-*)-1
      0  1e73					      db	"GO",0
      1  1e73		       47 4f 00 	      .byte.b	"GO",0
     98  1e76							;================================================================
     99  1e76							; process a goto
      0  1e76					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  1e76					      db	32
      1  1e76		       20		      .byte.b	32
      0  1e77					      db	(S2-*)-1
      1  1e77		       07		      .byte.b	(S2-*)-1
      0  1e78					      db	"TO",0
      1  1e78		       54 4f 00 	      .byte.b	"TO",0
      0  1e7b					      CALL	EXPR	;GET LABEL
      0  1e7b					      db	28
      1  1e7b		       1c		      .byte.b	28
      0  1e7c					      dw	EXPR
      1  1e7c		       9e 20		      .word.w	EXPR
      0  1e7e					      XFER		;SET UP AND JUMP
      0  1e7e					      db	7
      1  1e7e		       07		      .byte.b	7
    103  1e7f				   S2
    104  1e7f							;===========================================================================
    105  1e7f							; Process gosub / function
    106  1e7f							;
      0  1e7f					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1e7f					      db	32
      1  1e7f		       20		      .byte.b	32
      0  1e80					      db	(ERRVEC-*)-1
      1  1e80		       7a		      .byte.b	(ERRVEC-*)-1
      0  1e81					      db	"SUB",0
      1  1e81		       53 55 42 00	      .byte.b	"SUB",0
      0  1e85					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  1e85					      db	28
      1  1e85		       1c		      .byte.b	28
      0  1e86					      dw	GOSUBSTATEMENT
      1  1e86		       a5 22		      .word.w	GOSUBSTATEMENT
      0  1e88					      DONE		;ERROR IF CR NOT NEXT
      0  1e88					      db	1
      1  1e88		       01		      .byte.b	1
      0  1e89					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  1e89					      db	8
      1  1e89		       08		      .byte.b	8
      0  1e8a					      db	GOSUB_RTN
      1  1e8a		       01		      .byte.b	GOSUB_RTN
      0  1e8b					      XFER		;AND JUMP
      0  1e8b					      db	7
      1  1e8b		       07		      .byte.b	7
    112  1e8c							;
    113  1e8c							; End of gosub processing
    114  1e8c							;==========================================================================
    115  1e8c							; Return from a gosub
    116  1e8c				   S2b
      0  1e8c					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1e8c					      db	32
      1  1e8c		       20		      .byte.b	32
      0  1e8d					      db	(S3-*)-1
      1  1e8d		       36		      .byte.b	(S3-*)-1
      0  1e8e					      db	"RE",0
      1  1e8e		       52 45 00 	      .byte.b	"RE",0
      0  1e91					      TST	S2a,"T"
      0  1e91					      db	32
      1  1e91		       20		      .byte.b	32
      0  1e92					      db	(S2a-*)-1
      1  1e92		       27		      .byte.b	(S2a-*)-1
      0  1e93					      db	"T",0
      1  1e93		       54 00		      .byte.b	"T",0
      0  1e95					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  1e95					      db	32
      1  1e95		       20		      .byte.b	32
      0  1e96					      db	(S2aa-*)-1
      1  1e96		       04		      .byte.b	(S2aa-*)-1
      0  1e97					      db	"URN",0
      1  1e97		       55 52 4e 00	      .byte.b	"URN",0
    120  1e9b				   S2aa
      0  1e9b					      SETR2	0	; Default no return value
      0  1e9b					      db	94
      1  1e9b		       5e		      .byte.b	94
      0  1e9c					      db	0
      1  1e9c		       00		      .byte.b	0
      0  1e9d					      TST	S2RetDone,"("	; Check if we will return some value
      0  1e9d					      db	32
      1  1e9d		       20		      .byte.b	32
      0  1e9e					      db	(S2RetDone-*)-1
      1  1e9e		       0b		      .byte.b	(S2RetDone-*)-1
      0  1e9f					      db	"(",0
      1  1e9f		       28 00		      .byte.b	"(",0
      0  1ea1					      SETR2	1	; Indicate a return value provided
      0  1ea1					      db	94
      1  1ea1		       5e		      .byte.b	94
      0  1ea2					      db	1
      1  1ea2		       01		      .byte.b	1
      0  1ea3					      CALL	EXPR
      0  1ea3					      db	28
      1  1ea3		       1c		      .byte.b	28
      0  1ea4					      dw	EXPR
      1  1ea4		       9e 20		      .word.w	EXPR
      0  1ea6					      TST	ERRVEC,")"	; Now a value is on the stack
      0  1ea6					      db	32
      1  1ea6		       20		      .byte.b	32
      0  1ea7					      db	(ERRVEC-*)-1
      1  1ea7		       53		      .byte.b	(ERRVEC-*)-1
      0  1ea8					      db	")",0
      1  1ea8		       29 00		      .byte.b	")",0
    126  1eaa
    127  1eaa				   S2RetDone
      0  1eaa					      DONE		; MUST BE CR or :
      0  1eaa					      db	1
      1  1eaa		       01		      .byte.b	1
      0  1eab					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  1eab					      db	9
      1  1eab		       09		      .byte.b	9
      0  1eac					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  1eac					      db	97
      1  1eac		       61		      .byte.b	97
      0  1ead					      db	(S2RetFunc-*)-1
      1  1ead		       09		      .byte.b	(S2RetFunc-*)-1
      0  1eae					      dw	R2
      1  1eae		       58 00		      .word.w	R2
      0  1eb0					      db	1
      1  1eb0		       01		      .byte.b	1
      0  1eb1					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  1eb1					      db	6
      1  1eb1		       06		      .byte.b	6
      0  1eb2					      dw	CO
      1  1eb2		       f9 1d		      .word.w	CO
      0  1eb4					      IJMP	STMT
      0  1eb4					      db	29
      1  1eb4		       1d		      .byte.b	29
      0  1eb5					      dw	STMT
      1  1eb5		       01 1e		      .word.w	STMT
    133  1eb7				   S2RetFunc
      0  1eb7					      IJMP	GOFNRet	; Back into the Function
      0  1eb7					      db	29
      1  1eb7		       1d		      .byte.b	29
      0  1eb8					      dw	GOFNRet
      1  1eb8		       7b 22		      .word.w	GOFNRet
    135  1eba							;
    136  1eba							; End of return from gosub
    137  1eba							;============================================================================
    138  1eba							; Process REM statement
    139  1eba							;
    140  1eba				   S2a
      0  1eba					      TST	S3,"M"	;REMark.  Skip rest of line
      0  1eba					      db	32
      1  1eba		       20		      .byte.b	32
      0  1ebb					      db	(S3-*)-1
      1  1ebb		       08		      .byte.b	(S3-*)-1
      0  1ebc					      db	"M",0
      1  1ebc		       4d 00		      .byte.b	"M",0
      0  1ebe					      NXT	CO
      0  1ebe					      db	6
      1  1ebe		       06		      .byte.b	6
      0  1ebf					      dw	CO
      1  1ebf		       f9 1d		      .word.w	CO
      0  1ec1					      IJMP	STMT
      0  1ec1					      db	29
      1  1ec1		       1d		      .byte.b	29
      0  1ec2					      dw	STMT
      1  1ec2		       01 1e		      .word.w	STMT
    144  1ec4							;============================================================================
    145  1ec4							; Print statement
    146  1ec4							;
    147  1ec4				   S3
      0  1ec4					      TST	S3a,"?"	; ? symonym for print
      0  1ec4					      db	32
      1  1ec4		       20		      .byte.b	32
      0  1ec5					      db	(S3a-*)-1
      1  1ec5		       05		      .byte.b	(S3a-*)-1
      0  1ec6					      db	"?",0
      1  1ec6		       3f 00		      .byte.b	"?",0
      0  1ec8					      IJMP	S4S
      0  1ec8					      db	29
      1  1ec8		       1d		      .byte.b	29
      0  1ec9					      dw	S4S
      1  1ec9		       d6 1e		      .word.w	S4S
    150  1ecb				   S3a
      0  1ecb					      TST	S8,"PR"	;allow short form of print
      0  1ecb					      db	32
      1  1ecb		       20		      .byte.b	32
      0  1ecc					      db	(S8-*)-1
      1  1ecc		       5b		      .byte.b	(S8-*)-1
      0  1ecd					      db	"PR",0
      1  1ecd		       50 52 00 	      .byte.b	"PR",0
      0  1ed0					      TST	S4S,"INT"	;PRINT
      0  1ed0					      db	32
      1  1ed0		       20		      .byte.b	32
      0  1ed1					      db	(S4S-*)-1
      1  1ed1		       04		      .byte.b	(S4S-*)-1
      0  1ed2					      db	"INT",0
      1  1ed2		       49 4e 54 00	      .byte.b	"INT",0
    153  1ed6				   S4S
      0  1ed6					      STARTIO		;Lock task until io completes
      0  1ed6					      db	70
      1  1ed6		       46		      .byte.b	70
    155  1ed7				   S4
      0  1ed7					      TSTDONE	S4a	;Test if we just want crlf printed
      0  1ed7					      db	50
      1  1ed7		       32		      .byte.b	50
      0  1ed8					      db	(S4a-*)-1
      1  1ed8		       03		      .byte.b	(S4a-*)-1
      0  1ed9					      IJMP	S6
      0  1ed9					      db	29
      1  1ed9		       1d		      .byte.b	29
      0  1eda					      dw	S6
      1  1eda		       f2 1e		      .word.w	S6
    158  1edc
    159  1edc				   S4a
      0  1edc					      TSTSTR	S7	;TEST FOR QUOTED String
      0  1edc					      db	55
      1  1edc		       37		      .byte.b	55
      0  1edd					      db	(S7-*)-1
      1  1edd		       21		      .byte.b	(S7-*)-1
      0  1ede					      PRS		;PRINT STRING
      0  1ede					      db	2
      1  1ede		       02		      .byte.b	2
    162  1edf				   S5
      0  1edf					      TST	S6A,COMMA	;IS THERE MORE?
      0  1edf					      db	32
      1  1edf		       20		      .byte.b	32
      0  1ee0					      db	(S6A-*)-1
      1  1ee0		       08		      .byte.b	(S6A-*)-1
      0  1ee1					      db	COMMA,0
      1  1ee1		       2c 00		      .byte.b	COMMA,0
      0  1ee3					      SPC		;SPACE TO NEXT ZONE
      0  1ee3					      db	4
      1  1ee3		       04		      .byte.b	4
      0  1ee4					      TSTDONE	S4	;Not end of line jump back
      0  1ee4					      db	50
      1  1ee4		       32		      .byte.b	50
      0  1ee5					      db	(S4-*)-1
      1  1ee5		       f1		      .byte.b	(S4-*)-1
      0  1ee6					      IJMP	S6Z	;YES JUMP BACK
      0  1ee6					      db	29
      1  1ee6		       1d		      .byte.b	29
      0  1ee7					      dw	S6Z
      1  1ee7		       f4 1e		      .word.w	S6Z
    167  1ee9
    168  1ee9							;
    169  1ee9							; If a semicolon, don't do anything.
    170  1ee9							;
    171  1ee9				   S6A
      0  1ee9					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  1ee9					      db	32
      1  1ee9		       20		      .byte.b	32
      0  1eea					      db	(S6-*)-1
      1  1eea		       07		      .byte.b	(S6-*)-1
      0  1eeb					      db	SEMICOLON,0
      1  1eeb		       3b 00		      .byte.b	SEMICOLON,0
      0  1eed					      TSTDONE	S4	;Jump Back if not end of line
      0  1eed					      db	50
      1  1eed		       32		      .byte.b	50
      0  1eee					      db	(S4-*)-1
      1  1eee		       e8		      .byte.b	(S4-*)-1
      0  1eef					      IJMP	S6Z
      0  1eef					      db	29
      1  1eef		       1d		      .byte.b	29
      0  1ef0					      dw	S6Z
      1  1ef0		       f4 1e		      .word.w	S6Z
    175  1ef2				   S6
      0  1ef2					      DONE		;ERROR IF CR NOT NEXT
      0  1ef2					      db	1
      1  1ef2		       01		      .byte.b	1
      0  1ef3					      NLINE
      0  1ef3					      db	5
      1  1ef3		       05		      .byte.b	5
    178  1ef4				   S6Z
      0  1ef4					      ENDIO		;release task io completed
      0  1ef4					      db	71
      1  1ef4		       47		      .byte.b	71
      0  1ef5					      NXT	CO	;exit here if , or ; at end of print
      0  1ef5					      db	6
      1  1ef5		       06		      .byte.b	6
      0  1ef6					      dw	CO
      1  1ef6		       f9 1d		      .word.w	CO
      0  1ef8					      IJMP	STMT
      0  1ef8					      db	29
      1  1ef8		       1d		      .byte.b	29
      0  1ef9					      dw	STMT
      1  1ef9		       01 1e		      .word.w	STMT
    182  1efb							;
    183  1efb							; A jump for code too far away for relative branch
    184  1efb							;
    185  1efb				   ERRVEC
      0  1efb					      ENDIO
      0  1efb					      db	71
      1  1efb		       47		      .byte.b	71
      0  1efc					      IJMP	UNKNOWN
      0  1efc					      db	29
      1  1efc		       1d		      .byte.b	29
      0  1efd					      dw	UNKNOWN
      1  1efd		       9a 20		      .word.w	UNKNOWN
    188  1eff							;
    189  1eff							; Get here if there is an expression to print
    190  1eff				   S7
      0  1eff					      TST	S7AUnsigned,"$"
      0  1eff					      db	32
      1  1eff		       20		      .byte.b	32
      0  1f00					      db	(S7AUnsigned-*)-1
      1  1f00		       09		      .byte.b	(S7AUnsigned-*)-1
      0  1f01					      db	"$",0
      1  1f01		       24 00		      .byte.b	"$",0
      0  1f03					      CALL	EXPR
      0  1f03					      db	28
      1  1f03		       1c		      .byte.b	28
      0  1f04					      dw	EXPR
      1  1f04		       9e 20		      .word.w	EXPR
      0  1f06					      HEXPRT
      0  1f06					      db	67
      1  1f06		       43		      .byte.b	67
      0  1f07					      IJMP	S5
      0  1f07					      db	29
      1  1f07		       1d		      .byte.b	29
      0  1f08					      dw	S5
      1  1f08		       df 1e		      .word.w	S5
    195  1f0a
    196  1f0a				   S7AUnsigned
    197  1f0a
      0  1f0a					      TST	S7A,"%"
      0  1f0a					      db	32
      1  1f0a		       20		      .byte.b	32
      0  1f0b					      db	(S7A-*)-1
      1  1f0b		       0b		      .byte.b	(S7A-*)-1
      0  1f0c					      db	"%",0
      1  1f0c		       25 00		      .byte.b	"%",0
      0  1f0e					      CALL	EXPR
      0  1f0e					      db	28
      1  1f0e		       1c		      .byte.b	28
      0  1f0f					      dw	EXPR
      1  1f0f		       9e 20		      .word.w	EXPR
      0  1f11					      SETR2	1
      0  1f11					      db	94
      1  1f11		       5e		      .byte.b	94
      0  1f12					      db	1
      1  1f12		       01		      .byte.b	1
      0  1f13					      PRN
      0  1f13					      db	3
      1  1f13		       03		      .byte.b	3
      0  1f14					      IJMP	S5
      0  1f14					      db	29
      1  1f14		       1d		      .byte.b	29
      0  1f15					      dw	S5
      1  1f15		       df 1e		      .word.w	S5
    203  1f17
    204  1f17				   S7A
    205  1f17
      0  1f17					      CALL	EXPR
      0  1f17					      db	28
      1  1f17		       1c		      .byte.b	28
      0  1f18					      dw	EXPR
      1  1f18		       9e 20		      .word.w	EXPR
      0  1f1a					      TST	S7B,"$"
      0  1f1a					      db	32
      1  1f1a		       20		      .byte.b	32
      0  1f1b					      db	(S7B-*)-1
      1  1f1b		       06		      .byte.b	(S7B-*)-1
      0  1f1c					      db	"$",0
      1  1f1c		       24 00		      .byte.b	"$",0
      0  1f1e					      PUTCHAR
      0  1f1e					      db	52
      1  1f1e		       34		      .byte.b	52
      0  1f1f					      IJMP	S5
      0  1f1f					      db	29
      1  1f1f		       1d		      .byte.b	29
      0  1f20					      dw	S5
      1  1f20		       df 1e		      .word.w	S5
    210  1f22
    211  1f22				   S7B
      0  1f22					      SETR2	0
      0  1f22					      db	94
      1  1f22		       5e		      .byte.b	94
      0  1f23					      db	0
      1  1f23		       00		      .byte.b	0
      0  1f24					      PRN		;PRINT IT
      0  1f24					      db	3
      1  1f24		       03		      .byte.b	3
      0  1f25					      IJMP	S5	;IS THERE MORE?
      0  1f25					      db	29
      1  1f25		       1d		      .byte.b	29
      0  1f26					      dw	S5
      1  1f26		       df 1e		      .word.w	S5
    215  1f28							;
    216  1f28							;===========================================================
    217  1f28							; PROCESS ALL THE TAST STATEMENTS
    218  1f28							;
    219  1f28				   S8
      0  1f28					      TST	S8a1,"TASK"	; Any Task Command
      0  1f28					      db	32
      1  1f28		       20		      .byte.b	32
      0  1f29					      db	(S8a1-*)-1
      1  1f29		       4b		      .byte.b	(S8a1-*)-1
      0  1f2a					      db	"TASK",0
      1  1f2a		       54 41 53 4b*	      .byte.b	"TASK",0
    221  1f2f							;==========================================================
    222  1f2f							; End of TASK process
    223  1f2f							;
      0  1f2f					      TST	S8G,"E"
      0  1f2f					      db	32
      1  1f2f		       20		      .byte.b	32
      0  1f30					      db	(S8G-*)-1
      1  1f30		       1a		      .byte.b	(S8G-*)-1
      0  1f31					      db	"E",0
      1  1f31		       45 00		      .byte.b	"E",0
      0  1f33					      TST	S8NoParm,"("
      0  1f33					      db	32
      1  1f33		       20		      .byte.b	32
      0  1f34					      db	(S8NoParm-*)-1
      1  1f34		       0e		      .byte.b	(S8NoParm-*)-1
      0  1f35					      db	"(",0
      1  1f35		       28 00		      .byte.b	"(",0
      0  1f37					      CALL	EXPR
      0  1f37					      db	28
      1  1f37		       1c		      .byte.b	28
      0  1f38					      dw	EXPR
      1  1f38		       9e 20		      .word.w	EXPR
      0  1f3a					      TST	UNKNOWNLnk,")"
      0  1f3a					      db	32
      1  1f3a		       20		      .byte.b	32
      0  1f3b					      db	(UNKNOWNLnk-*)-1
      1  1f3b		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1f3c					      db	")",0
      1  1f3c		       29 00		      .byte.b	")",0
      0  1f3e					      ETASK
      0  1f3e					      db	62
      1  1f3e		       3e		      .byte.b	62
      0  1f3f					      DONE
      0  1f3f					      db	1
      1  1f3f		       01		      .byte.b	1
      0  1f40					      IJMP	STMT
      0  1f40					      db	29
      1  1f40		       1d		      .byte.b	29
      0  1f41					      dw	STMT
      1  1f41		       01 1e		      .word.w	STMT
    231  1f43				   S8NoParm
      0  1f43					      LIT	0
      0  1f43					      db	27
      1  1f43		       1b		      .byte.b	27
      0  1f44					      dw	0
      1  1f44		       00 00		      .word.w	0
      0  1f46					      ETASK
      0  1f46					      db	62
      1  1f46		       3e		      .byte.b	62
      0  1f47					      DONE		; Must be last thing on a line
      0  1f47					      db	1
      1  1f47		       01		      .byte.b	1
      0  1f48					      IJMP	STMT
      0  1f48					      db	29
      1  1f48		       1d		      .byte.b	29
      0  1f49					      dw	STMT
      1  1f49		       01 1e		      .word.w	STMT
    236  1f4b							;
    237  1f4b							;===========================================================
    238  1f4b							; The task gives up the rest of the cycles
    239  1f4b				   S8G
      0  1f4b					      TST	S8a,"N"	;Next task
      0  1f4b					      db	32
      1  1f4b		       20		      .byte.b	32
      0  1f4c					      db	(S8a-*)-1
      1  1f4c		       09		      .byte.b	(S8a-*)-1
      0  1f4d					      db	"N",0
      1  1f4d		       4e 00		      .byte.b	"N",0
      0  1f4f					      NTASK
      0  1f4f					      db	63
      1  1f4f		       3f		      .byte.b	63
      0  1f50					      NXT	CO	;Next statement to execute
      0  1f50					      db	6
      1  1f50		       06		      .byte.b	6
      0  1f51					      dw	CO
      1  1f51		       f9 1d		      .word.w	CO
      0  1f53					      IJMP	STMT
      0  1f53					      db	29
      1  1f53		       1d		      .byte.b	29
      0  1f54					      dw	STMT
      1  1f54		       01 1e		      .word.w	STMT
    244  1f56							;
    245  1f56							;===========================================================
    246  1f56							; Waits for a task or list of tasks to complete
    247  1f56				   S8a
      0  1f56					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1f56					      db	32
      1  1f56		       20		      .byte.b	32
      0  1f57					      db	(S8TASKNO-*)-1
      1  1f57		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1f58					      db	"W(",0
      1  1f58		       57 28 00 	      .byte.b	"W(",0
    249  1f5b				   S8TSK
      0  1f5b					      Call	EXPR	;Gets the PID of task to wait for
      0  1f5b					      db	28
      1  1f5b		       1c		      .byte.b	28
      0  1f5c					      dw	EXPR
      1  1f5c		       9e 20		      .word.w	EXPR
    251  1f5e				   S8LOOP
      0  1f5e					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1f5e					      db	76
      1  1f5e		       4c		      .byte.b	76
      0  1f5f					      db	(S8LOOP-*)-1
      1  1f5f		       fe		      .byte.b	(S8LOOP-*)-1
      0  1f60					      TST	S8aa,COMMA	;Checks for more tasks
      0  1f60					      db	32
      1  1f60		       20		      .byte.b	32
      0  1f61					      db	(S8aa-*)-1
      1  1f61		       05		      .byte.b	(S8aa-*)-1
      0  1f62					      db	COMMA,0
      1  1f62		       2c 00		      .byte.b	COMMA,0
      0  1f64					      IJMP	S8TSK	;Go for the next task number
      0  1f64					      db	29
      1  1f64		       1d		      .byte.b	29
      0  1f65					      dw	S8TSK
      1  1f65		       5b 1f		      .word.w	S8TSK
    255  1f67				   S8aa
      0  1f67					      TST	S8TASKNO,")"	;end of list
      0  1f67					      db	32
      1  1f67		       20		      .byte.b	32
      0  1f68					      db	(S8TASKNO-*)-1
      1  1f68		       09		      .byte.b	(S8TASKNO-*)-1
      0  1f69					      db	")",0
      1  1f69		       29 00		      .byte.b	")",0
      0  1f6b					      DONE
      0  1f6b					      db	1
      1  1f6b		       01		      .byte.b	1
      0  1f6c					      NXT	CO
      0  1f6c					      db	6
      1  1f6c		       06		      .byte.b	6
      0  1f6d					      dw	CO
      1  1f6d		       f9 1d		      .word.w	CO
      0  1f6f					      IJMP	STMT	;Next Statement
      0  1f6f					      db	29
      1  1f6f		       1d		      .byte.b	29
      0  1f70					      dw	STMT
      1  1f70		       01 1e		      .word.w	STMT
    260  1f72				   S8TASKNO
    261  1f72
    262  1f72				   UNKNOWNLnk
      0  1f72					      iJMP	UNKNOWN
      0  1f72					      db	29
      1  1f72		       1d		      .byte.b	29
      0  1f73					      dw	UNKNOWN
      1  1f73		       9a 20		      .word.w	UNKNOWN
    264  1f75
    265  1f75							;
    266  1f75							;===========================================================
    267  1f75							; Update a memory location with a value
    268  1f75							;  Use @[offset] to write a word value to memory
    269  1f75							;
    270  1f75				   S8a1
      0  1f75					      TST	S8b,"POKE("	; Poke a value into memory
      0  1f75					      db	32
      1  1f75		       20		      .byte.b	32
      0  1f76					      db	(S8b-*)-1
      1  1f76		       1c		      .byte.b	(S8b-*)-1
      0  1f77					      db	"POKE(",0
      1  1f77		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1f7d					      CALL	EXPR	; Get address to write to
      0  1f7d					      db	28
      1  1f7d		       1c		      .byte.b	28
      0  1f7e					      dw	EXPR
      1  1f7e		       9e 20		      .word.w	EXPR
      0  1f80					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1f80					      db	32
      1  1f80		       20		      .byte.b	32
      0  1f81					      db	(UNKNOWNV-*)-1
      1  1f81		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1f82					      db	COMMA,0
      1  1f82		       2c 00		      .byte.b	COMMA,0
      0  1f84					      CALL	EXPR	; Get the value to poke
      0  1f84					      db	28
      1  1f84		       1c		      .byte.b	28
      0  1f85					      dw	EXPR
      1  1f85		       9e 20		      .word.w	EXPR
      0  1f87					      TST	UNKNOWNV,")"	; closing bracket
      0  1f87					      db	32
      1  1f87		       20		      .byte.b	32
      0  1f88					      db	(UNKNOWNV-*)-1
      1  1f88		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1f89					      db	")",0
      1  1f89		       29 00		      .byte.b	")",0
      0  1f8b					      POKEMEM
      0  1f8b					      db	47
      1  1f8b		       2f		      .byte.b	47
      0  1f8c					      DONE
      0  1f8c					      db	1
      1  1f8c		       01		      .byte.b	1
      0  1f8d					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1f8d					      db	6
      1  1f8d		       06		      .byte.b	6
      0  1f8e					      dw	CO
      1  1f8e		       f9 1d		      .word.w	CO
      0  1f90					      IJMP	STMT
      0  1f90					      db	29
      1  1f90		       1d		      .byte.b	29
      0  1f91					      dw	STMT
      1  1f91		       01 1e		      .word.w	STMT
    280  1f93							;================================================================
    281  1f93							; Write a single byte to the output device
    282  1f93							;
    283  1f93				   S8b
      0  1f93					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1f93					      db	32
      1  1f93		       20		      .byte.b	32
      0  1f94					      db	(S8c-*)-1
      1  1f94		       11		      .byte.b	(S8c-*)-1
      0  1f95					      db	"PUTCH",0
      1  1f95		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1f9b					      CALL	EXPR
      0  1f9b					      db	28
      1  1f9b		       1c		      .byte.b	28
      0  1f9c					      dw	EXPR
      1  1f9c		       9e 20		      .word.w	EXPR
      0  1f9e					      PUTCHAR
      0  1f9e					      db	52
      1  1f9e		       34		      .byte.b	52
      0  1f9f					      DONE
      0  1f9f					      db	1
      1  1f9f		       01		      .byte.b	1
      0  1fa0					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1fa0					      db	6
      1  1fa0		       06		      .byte.b	6
      0  1fa1					      dw	CO
      1  1fa1		       f9 1d		      .word.w	CO
      0  1fa3					      IJMP	STMT
      0  1fa3					      db	29
      1  1fa3		       1d		      .byte.b	29
      0  1fa4					      dw	STMT
      1  1fa4		       01 1e		      .word.w	STMT
    290  1fa6							;================================================================
    291  1fa6							; Clear the screen lines
    292  1fa6							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    293  1fa6							;
    294  1fa6				   S8c
      0  1fa6					      TST	S9,"CLS"	;Clear the screen
      0  1fa6					      db	32
      1  1fa6		       20		      .byte.b	32
      0  1fa7					      db	(S9-*)-1
      1  1fa7		       0b		      .byte.b	(S9-*)-1
      0  1fa8					      db	"CLS",0
      1  1fa8		       43 4c 53 00	      .byte.b	"CLS",0
      0  1fac					      CLEARSCREEN
      0  1fac					      db	46
      1  1fac		       2e		      .byte.b	46
      0  1fad					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1fad					      db	6
      1  1fad		       06		      .byte.b	6
      0  1fae					      dw	CO
      1  1fae		       f9 1d		      .word.w	CO
      0  1fb0					      IJMP	STMT
      0  1fb0					      db	29
      1  1fb0		       1d		      .byte.b	29
      0  1fb1					      dw	STMT
      1  1fb1		       01 1e		      .word.w	STMT
    299  1fb3							;==================================================================
    300  1fb3							; Get input from the terminal
    301  1fb3							;   Reads from the currently active input device
    302  1fb3							;
    303  1fb3				   S9
      0  1fb3					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1fb3					      db	32
      1  1fb3		       20		      .byte.b	32
      0  1fb4					      db	(S13-*)-1
      1  1fb4		       2a		      .byte.b	(S13-*)-1
      0  1fb5					      db	"INPUT",0
      1  1fb5		       49 4e 50 55*	      .byte.b	"INPUT",0
    305  1fbb				   S10
      0  1fbb					      TSTSTR	S10A	;If there is a string print the prompt
      0  1fbb					      db	55
      1  1fbb		       37		      .byte.b	55
      0  1fbc					      db	(S10A-*)-1
      1  1fbc		       05		      .byte.b	(S10A-*)-1
      0  1fbd					      PRS
      0  1fbd					      db	2
      1  1fbd		       02		      .byte.b	2
      0  1fbe					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1fbe					      db	32
      1  1fbe		       20		      .byte.b	32
      0  1fbf					      db	(S10Z-*)-1
      1  1fbf		       15		      .byte.b	(S10Z-*)-1
      0  1fc0					      db	SEMICOLON,0
      1  1fc0		       3b 00		      .byte.b	SEMICOLON,0
    309  1fc2				   S10A
      0  1fc2					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1fc2					      db	33
      1  1fc2		       21		      .byte.b	33
      0  1fc3					      db	(UNKNOWN-*)-1
      1  1fc3		       d6		      .byte.b	(UNKNOWN-*)-1
      0  1fc4					      TST	S10A1,DOLLAR
      0  1fc4					      db	32
      1  1fc4		       20		      .byte.b	32
      0  1fc5					      db	(S10A1-*)-1
      1  1fc5		       06		      .byte.b	(S10A1-*)-1
      0  1fc6					      db	DOLLAR,0
      1  1fc6		       24 00		      .byte.b	DOLLAR,0
      0  1fc8					      INSTR		;Move character From tty to AESTK
      0  1fc8					      db	59
      1  1fc8		       3b		      .byte.b	59
      0  1fc9					      IJMP	S10A2
      0  1fc9					      db	29
      1  1fc9		       1d		      .byte.b	29
      0  1fca					      dw	S10A2
      1  1fca		       cd 1f		      .word.w	S10A2
    314  1fcc				   S10A1
      0  1fcc					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1fcc					      db	11
      1  1fcc		       0b		      .byte.b	11
    316  1fcd				   S10A2
      0  1fcd					      STORE		;STORE IT
      0  1fcd					      db	19
      1  1fcd		       13		      .byte.b	19
      0  1fce					      TST	S11,COMMA	;IS THERE MORE?
      0  1fce					      db	32
      1  1fce		       20		      .byte.b	32
      0  1fcf					      db	(S11-*)-1
      1  1fcf		       08		      .byte.b	(S11-*)-1
      0  1fd0					      db	COMMA,0
      1  1fd0		       2c 00		      .byte.b	COMMA,0
      0  1fd2					      IJMP	S10	;YES
      0  1fd2					      db	29
      1  1fd2		       1d		      .byte.b	29
      0  1fd3					      dw	S10
      1  1fd3		       bb 1f		      .word.w	S10
    320  1fd5				   S10Z
      0  1fd5					      iJMP	UNKNOWN
      0  1fd5					      db	29
      1  1fd5		       1d		      .byte.b	29
      0  1fd6					      dw	UNKNOWN
      1  1fd6		       9a 20		      .word.w	UNKNOWN
    322  1fd8				   S11
      0  1fd8					      DONE		;MUST BE CR
      0  1fd8					      db	1
      1  1fd8		       01		      .byte.b	1
      0  1fd9					      NXT	CO	;SEQUENCE TO NEXT
      0  1fd9					      db	6
      1  1fd9		       06		      .byte.b	6
      0  1fda					      dw	CO
      1  1fda		       f9 1d		      .word.w	CO
      0  1fdc					      IJMP	STMT
      0  1fdc					      db	29
      1  1fdc		       1d		      .byte.b	29
      0  1fdd					      dw	STMT
      1  1fdd		       01 1e		      .word.w	STMT
    326  1fdf							;=====================================================================
    327  1fdf							; End of program, return to command line process
    328  1fdf							; Main Task may also use taske or return to stopped
    329  1fdf							;
    330  1fdf				   S13
      0  1fdf					      TST	S14,"END"
      0  1fdf					      db	32
      1  1fdf		       20		      .byte.b	32
      0  1fe0					      db	(S14-*)-1
      1  1fe0		       08		      .byte.b	(S14-*)-1
      0  1fe1					      db	"END",0
      1  1fe1		       45 4e 44 00	      .byte.b	"END",0
      0  1fe5					      FIN
      0  1fe5					      db	12
      1  1fe5		       0c		      .byte.b	12
    333  1fe6
    334  1fe6				   UNKNOWNV
      0  1fe6					      IJMP	UNKNOWN
      0  1fe6					      db	29
      1  1fe6		       1d		      .byte.b	29
      0  1fe7					      dw	UNKNOWN
      1  1fe7		       9a 20		      .word.w	UNKNOWN
    336  1fe9							;====================================================================
    337  1fe9							; IRQ <IRQ-HANDLER-Line expression>
    338  1fe9							;   Specify a line number subroutine to call when an interupt is processed
    339  1fe9							;   These subroutines must use iret to return.
    340  1fe9							;
    341  1fe9				   S14
      0  1fe9					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  1fe9					      db	32
      1  1fe9		       20		      .byte.b	32
      0  1fea					      db	(S14Z-*)-1
      1  1fea		       0f		      .byte.b	(S14Z-*)-1
      0  1feb					      db	"IRQ",0
      1  1feb		       49 52 51 00	      .byte.b	"IRQ",0
      0  1fef					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1fef					      db	28
      1  1fef		       1c		      .byte.b	28
      0  1ff0					      dw	EXPR
      1  1ff0		       9e 20		      .word.w	EXPR
      0  1ff2					      DONE		;must be CR
      0  1ff2					      db	1
      1  1ff2		       01		      .byte.b	1
      0  1ff3					      SETIRQ		;Set the line number now
      0  1ff3					      db	56
      1  1ff3		       38		      .byte.b	56
      0  1ff4					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1ff4					      db	6
      1  1ff4		       06		      .byte.b	6
      0  1ff5					      dw	CO
      1  1ff5		       f9 1d		      .word.w	CO
      0  1ff7					      IJMP	STMT
      0  1ff7					      db	29
      1  1ff7		       1d		      .byte.b	29
      0  1ff8					      dw	STMT
      1  1ff8		       01 1e		      .word.w	STMT
    348  1ffa
    349  1ffa							;=========================================================================
    350  1ffa							; KILL PID-expression	 kill a running task
    351  1ffa							;  ignored of task has already stopped
    352  1ffa							;
    353  1ffa				   S14Z
      0  1ffa					      TST	S14S1,"KILL"	; Kill A running Task
      0  1ffa					      db	32
      1  1ffa		       20		      .byte.b	32
      0  1ffb					      db	(S14S1-*)-1
      1  1ffb		       10		      .byte.b	(S14S1-*)-1
      0  1ffc					      db	"KILL",0
      1  1ffc		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  2001					      CALL	EXPR
      0  2001					      db	28
      1  2001		       1c		      .byte.b	28
      0  2002					      dw	EXPR
      1  2002		       9e 20		      .word.w	EXPR
      0  2004					      DONE
      0  2004					      db	1
      1  2004		       01		      .byte.b	1
      0  2005					      TASKKILL
      0  2005					      db	65
      1  2005		       41		      .byte.b	65
      0  2006					      NXT	CO
      0  2006					      db	6
      1  2006		       06		      .byte.b	6
      0  2007					      dw	CO
      1  2007		       f9 1d		      .word.w	CO
      0  2009					      IJMP	STMT
      0  2009					      db	29
      1  2009		       1d		      .byte.b	29
      0  200a					      dw	STMT
      1  200a		       01 1e		      .word.w	STMT
    360  200c
    361  200c							;============================================================================
    362  200c							; List all program lines
    363  200c							;
    364  200c				   S14S1
      0  200c					      TST	S15,"LIST"	;LIST COMMAND
      0  200c					      db	32
      1  200c		       20		      .byte.b	32
      0  200d					      db	(S15-*)-1
      1  200d		       0a		      .byte.b	(S15-*)-1
      0  200e					      db	"LIST",0
      1  200e		       4c 49 53 54*	      .byte.b	"LIST",0
      0  2013					      DONE
      0  2013					      db	1
      1  2013		       01		      .byte.b	1
      0  2014					      LST
      0  2014					      db	21
      1  2014		       15		      .byte.b	21
      0  2015					      IJMP	CO
      0  2015					      db	29
      1  2015		       1d		      .byte.b	29
      0  2016					      dw	CO
      1  2016		       f9 1d		      .word.w	CO
    369  2018							;=======================================================================
    370  2018							;RUN begin to executed the program in memory
    371  2018							;
    372  2018				   S15
      0  2018					      TST	S16,"RUN"	;RUN COMMAND
      0  2018					      db	32
      1  2018		       20		      .byte.b	32
      0  2019					      db	(S16-*)-1
      1  2019		       0d		      .byte.b	(S16-*)-1
      0  201a					      db	"RUN",0
      1  201a		       52 55 4e 00	      .byte.b	"RUN",0
      0  201e					      DONE
      0  201e					      db	1
      1  201e		       01		      .byte.b	1
      0  201f					      VINIT		;clear variables
      0  201f					      db	30
      1  201f		       1e		      .byte.b	30
      0  2020					      LIT	1	;GOTO line 1
      0  2020					      db	27
      1  2020		       1b		      .byte.b	27
      0  2021					      dw	1
      1  2021		       01 00		      .word.w	1
      0  2023					      XFER		;Bob's addition
      0  2023					      db	7
      1  2023		       07		      .byte.b	7
    378  2024							; EXIT
      0  2024					      IJMP	STMT	;and run!
      0  2024					      db	29
      1  2024		       1d		      .byte.b	29
      0  2025					      dw	STMT
      1  2025		       01 1e		      .word.w	STMT
    380  2027							;=========================================================================
    381  2027							;Clear the program memory, delete all proram lines
    382  2027							;
    383  2027				   S16
      0  2027					      TST	S16A,"NEW"	;clear program
      0  2027					      db	32
      1  2027		       20		      .byte.b	32
      0  2028					      db	(S16A-*)-1
      1  2028		       08		      .byte.b	(S16A-*)-1
      0  2029					      db	"NEW",0
      1  2029		       4e 45 57 00	      .byte.b	"NEW",0
      0  202d					      DONE
      0  202d					      db	1
      1  202d		       01		      .byte.b	1
      0  202e					      IJMP	START
      0  202e					      db	29
      1  202e		       1d		      .byte.b	29
      0  202f					      dw	START
      1  202f		       f3 1d		      .word.w	START
    387  2031
    388  2031							;========================================================================
    389  2031							; Slice(slice legth expression)
    390  2031							;   set the length of time between task switches
    391  2031							;
    392  2031				   S16A
      0  2031					      TST	S16Trace,"SLICE"
      0  2031					      db	32
      1  2031		       20		      .byte.b	32
      0  2032					      db	(S16Trace-*)-1
      1  2032		       11		      .byte.b	(S16Trace-*)-1
      0  2033					      db	"SLICE",0
      1  2033		       53 4c 49 43*	      .byte.b	"SLICE",0
      0  2039					      CALL	EXPR
      0  2039					      db	28
      1  2039		       1c		      .byte.b	28
      0  203a					      dw	EXPR
      1  203a		       9e 20		      .word.w	EXPR
      0  203c					      SLICE
      0  203c					      db	100
      1  203c		       64		      .byte.b	100
      0  203d					      DONE
      0  203d					      db	1
      1  203d		       01		      .byte.b	1
      0  203e					      NXT	CO
      0  203e					      db	6
      1  203e		       06		      .byte.b	6
      0  203f					      dw	CO
      1  203f		       f9 1d		      .word.w	CO
      0  2041					      IJMP	STMT
      0  2041					      db	29
      1  2041		       1d		      .byte.b	29
      0  2042					      dw	STMT
      1  2042		       01 1e		      .word.w	STMT
    399  2044							;==========================================================================
    400  2044							; Turn off and on the thrace functions
    401  2044							; a debug terminal needs to be available
    402  2044							; Trace( Trace flag expression)
    403  2044							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    404  2044							;	for individual lines of basic code. These can be combined
    405  2044				   S16Trace
      0  2044					      TST	S17A,"TRACE("	;Are we going to trace
      0  2044					      db	32
      1  2044		       20		      .byte.b	32
      0  2045					      db	(S17A-*)-1
      1  2045		       16		      .byte.b	(S17A-*)-1
      0  2046					      db	"TRACE(",0
      1  2046		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  204d					      CALL	EXPR
      0  204d					      db	28
      1  204d		       1c		      .byte.b	28
      0  204e					      dw	EXPR
      1  204e		       9e 20		      .word.w	EXPR
      0  2050					      TST	UNKNOWN,")"
      0  2050					      db	32
      1  2050		       20		      .byte.b	32
      0  2051					      db	(UNKNOWN-*)-1
      1  2051		       48		      .byte.b	(UNKNOWN-*)-1
      0  2052					      db	")",0
      1  2052		       29 00		      .byte.b	")",0
      0  2054					      TRACEPROGRAM
      0  2054					      db	78
      1  2054		       4e		      .byte.b	78
      0  2055					      DONE
      0  2055					      db	1
      1  2055		       01		      .byte.b	1
      0  2056					      NXT	CO
      0  2056					      db	6
      1  2056		       06		      .byte.b	6
      0  2057					      dw	CO
      1  2057		       f9 1d		      .word.w	CO
      0  2059					      IJMP	STMT
      0  2059					      db	29
      1  2059		       1d		      .byte.b	29
      0  205a					      dw	STMT
      1  205a		       01 1e		      .word.w	STMT
    413  205c							;=====================================================================
    414  205c							; Exit basic to machine monitor
    415  205c							;
    416  205c				   S17A
      0  205c					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  205c					      db	32
      1  205c		       20		      .byte.b	32
      0  205d					      db	(S17B-*)-1
      1  205d		       06		      .byte.b	(S17B-*)-1
      0  205e					      db	"EXIT",0
      1  205e		       45 58 49 54*	      .byte.b	"EXIT",0
      0  2063					      EXIT
      0  2063					      db	26
      1  2063		       1a		      .byte.b	26
    419  2064
    420  2064							;=======================================================================
    421  2064							; Commands related to saving/restoring programs
    422  2064							; to/from mass storage.
    423  2064							;
    424  2064				   S17B
    425  2064					      if	(XKIM || CTMON65) && DISK_ACCESS
    426  2064
      0  2064					      TST	S17C,"SAVE"
      0  2064					      db	32
      1  2064		       20		      .byte.b	32
      0  2065					      db	(S17C-*)-1
      1  2065		       0b		      .byte.b	(S17C-*)-1
      0  2066					      db	"SAVE",0
      1  2066		       53 41 56 45*	      .byte.b	"SAVE",0
      0  206b					      OPENWRITE
      0  206b					      db	40
      1  206b		       28		      .byte.b	40
      0  206c					      DLIST
      0  206c					      db	43
      1  206c		       2b		      .byte.b	43
      0  206d					      DCLOSE
      0  206d					      db	41
      1  206d		       29		      .byte.b	41
      0  206e					      IJMP	CO
      0  206e					      db	29
      1  206e		       1d		      .byte.b	29
      0  206f					      dw	CO
      1  206f		       f9 1d		      .word.w	CO
    432  2071
    433  2071				   S17C
      0  2071					      TST	S18,"LOAD"
      0  2071					      db	32
      1  2071		       20		      .byte.b	32
      0  2072					      db	(S18-*)-1
      1  2072		       11		      .byte.b	(S18-*)-1
      0  2073					      db	"LOAD",0
      1  2073		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  2078					      OPENREAD
      0  2078					      db	39
      1  2078		       27		      .byte.b	39
    436  2079				   S17CLP
      0  2079					      DGETLINE		;get line from file
      0  2079					      db	42
      1  2079		       2a		      .byte.b	42
      0  207a					      TSTL	S17EOL	;no line num means EOL
      0  207a					      db	34
      1  207a		       22		      .byte.b	34
      0  207b					      db	(S17EOL-*)-1
      1  207b		       04		      .byte.b	(S17EOL-*)-1
      0  207c					      INSERT		;put it into the program
      0  207c					      db	24
      1  207c		       18		      .byte.b	24
      0  207d					      IJMP	S17CLP	;keep going
      0  207d					      db	29
      1  207d		       1d		      .byte.b	29
      0  207e					      dw	S17CLP
      1  207e		       79 20		      .word.w	S17CLP
    441  2080				   S17EOL
      0  2080					      DCLOSE		;close disk file
      0  2080					      db	41
      1  2080		       29		      .byte.b	41
      0  2081					      IJMP	CO	;back to start
      0  2081					      db	29
      1  2081		       1d		      .byte.b	29
      0  2082					      dw	CO
      1  2082		       f9 1d		      .word.w	CO
    444  2084
    445  2084				   S18
      0  2084					      TST	S19,"DIR"
      0  2084					      db	32
      1  2084		       20		      .byte.b	32
      0  2085					      db	(S19-*)-1
      1  2085		       08		      .byte.b	(S19-*)-1
      0  2086					      db	"DIR",0
      1  2086		       44 49 52 00	      .byte.b	"DIR",0
      0  208a					      DDIR		;Display the directory content
      0  208a					      db	44
      1  208a		       2c		      .byte.b	44
      0  208b					      IJMP	CO
      0  208b					      db	29
      1  208b		       1d		      .byte.b	29
      0  208c					      dw	CO
      1  208c		       f9 1d		      .word.w	CO
    449  208e
      0  208e				   S19	      TST	UNKNOWN,"ERASE"
      0  208e					      db	32
      1  208e		       20		      .byte.b	32
      0  208f					      db	(UNKNOWN-*)-1
      1  208f		       0a		      .byte.b	(UNKNOWN-*)-1
      0  2090					      db	"ERASE",0
      1  2090		       45 52 41 53*	      .byte.b	"ERASE",0
      0  2096					      RMFILE		;Erase the file from the disk
      0  2096					      db	45
      1  2096		       2d		      .byte.b	45
      0  2097					      IJMP	CO
      0  2097					      db	29
      1  2097		       1d		      .byte.b	29
      0  2098					      dw	CO
      1  2098		       f9 1d		      .word.w	CO
    453  209a
    454  209a					      endif
    455  209a
    456  209a							;
    457  209a							; Else, unknown command.
    458  209a							;
    459  209a				   UNKNOWN
      0  209a					      ENDIO
      0  209a					      db	71
      1  209a		       47		      .byte.b	71
      0  209b					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  209b					      db	13
      1  209b		       0d		      .byte.b	13
      0  209c					      dw	ERR_SYNTAX
      1  209c		       05 00		      .word.w	ERR_SYNTAX
    462  209e
    463  209e							;=======================================================
    464  209e							; Process Expresions, precidence is represented by the
    465  209e							; various call levels
    466  209e							;
    467  209e				   EXPR
      0  209e					      TST	EXPRLOGS,"NOT"
      0  209e					      db	32
      1  209e		       20		      .byte.b	32
      0  209f					      db	(EXPRLOGS-*)-1
      1  209f		       09		      .byte.b	(EXPRLOGS-*)-1
      0  20a0					      db	"NOT",0
      1  20a0		       4e 4f 54 00	      .byte.b	"NOT",0
      0  20a4					      Call	EXPR
      0  20a4					      db	28
      1  20a4		       1c		      .byte.b	28
      0  20a5					      dw	EXPR
      1  20a5		       9e 20		      .word.w	EXPR
      0  20a7					      LOGNOT
      0  20a7					      db	72
      1  20a7		       48		      .byte.b	72
      0  20a8					      RTN
      0  20a8					      db	25
      1  20a8		       19		      .byte.b	25
    472  20a9
    473  20a9							;=========================================================
    474  20a9							;Look for logical operators
    475  20a9				   EXPRLOGS
      0  20a9					      Call	EXPRCMP
      0  20a9					      db	28
      1  20a9		       1c		      .byte.b	28
      0  20aa					      dw	EXPRCMP
      1  20aa		       cd 20		      .word.w	EXPRCMP
      0  20ac					      TST	iLOG1,"AND"
      0  20ac					      db	32
      1  20ac		       20		      .byte.b	32
      0  20ad					      db	(iLOG1-*)-1
      1  20ad		       09		      .byte.b	(iLOG1-*)-1
      0  20ae					      db	"AND",0
      1  20ae		       41 4e 44 00	      .byte.b	"AND",0
      0  20b2					      Call	EXPR
      0  20b2					      db	28
      1  20b2		       1c		      .byte.b	28
      0  20b3					      dw	EXPR
      1  20b3		       9e 20		      .word.w	EXPR
      0  20b5					      LOGAND
      0  20b5					      db	74
      1  20b5		       4a		      .byte.b	74
      0  20b6					      RTN
      0  20b6					      db	25
      1  20b6		       19		      .byte.b	25
    481  20b7				   iLOG1
      0  20b7					      TST	iLOG2,"OR"
      0  20b7					      db	32
      1  20b7		       20		      .byte.b	32
      0  20b8					      db	(iLOG2-*)-1
      1  20b8		       08		      .byte.b	(iLOG2-*)-1
      0  20b9					      db	"OR",0
      1  20b9		       4f 52 00 	      .byte.b	"OR",0
      0  20bc					      Call	EXPR
      0  20bc					      db	28
      1  20bc		       1c		      .byte.b	28
      0  20bd					      dw	EXPR
      1  20bd		       9e 20		      .word.w	EXPR
      0  20bf					      LOGOR
      0  20bf					      db	73
      1  20bf		       49		      .byte.b	73
      0  20c0					      RTN
      0  20c0					      db	25
      1  20c0		       19		      .byte.b	25
    486  20c1				   iLOG2
      0  20c1					      TST	iLOG3,"XOR"
      0  20c1					      db	32
      1  20c1		       20		      .byte.b	32
      0  20c2					      db	(iLOG3-*)-1
      1  20c2		       09		      .byte.b	(iLOG3-*)-1
      0  20c3					      db	"XOR",0
      1  20c3		       58 4f 52 00	      .byte.b	"XOR",0
      0  20c7					      Call	EXPR
      0  20c7					      db	28
      1  20c7		       1c		      .byte.b	28
      0  20c8					      dw	EXPR
      1  20c8		       9e 20		      .word.w	EXPR
      0  20ca					      LOGXOR
      0  20ca					      db	75
      1  20ca		       4b		      .byte.b	75
      0  20cb					      RTN
      0  20cb					      db	25
      1  20cb		       19		      .byte.b	25
    491  20cc				   iLOG3
      0  20cc					      RTN
      0  20cc					      db	25
      1  20cc		       19		      .byte.b	25
    493  20cd
    494  20cd				   EXPRCMP
      0  20cd					      Call	EXPR2	; get the first expression
      0  20cd					      db	28
      1  20cd		       1c		      .byte.b	28
      0  20ce					      dw	EXPR2
      1  20ce		       19 21		      .word.w	EXPR2
      0  20d0					      TST	iR0,"="
      0  20d0					      db	32
      1  20d0		       20		      .byte.b	32
      0  20d1					      db	(iR0-*)-1
      1  20d1		       08		      .byte.b	(iR0-*)-1
      0  20d2					      db	"=",0
      1  20d2		       3d 00		      .byte.b	"=",0
      0  20d4					      LIT	2	;=
      0  20d4					      db	27
      1  20d4		       1b		      .byte.b	27
      0  20d5					      dw	2
      1  20d5		       02 00		      .word.w	2
      0  20d7					      IJMP	iRFound
      0  20d7					      db	29
      1  20d7		       1d		      .byte.b	29
      0  20d8					      dw	iRFound
      1  20d8		       13 21		      .word.w	iRFound
    499  20da				   iR0
      0  20da					      TST	iR4,"<"
      0  20da					      db	32
      1  20da		       20		      .byte.b	32
      0  20db					      db	(iR4-*)-1
      1  20db		       1c		      .byte.b	(iR4-*)-1
      0  20dc					      db	"<",0
      1  20dc		       3c 00		      .byte.b	"<",0
      0  20de					      TST	iR1,"="
      0  20de					      db	32
      1  20de		       20		      .byte.b	32
      0  20df					      db	(iR1-*)-1
      1  20df		       08		      .byte.b	(iR1-*)-1
      0  20e0					      db	"=",0
      1  20e0		       3d 00		      .byte.b	"=",0
      0  20e2					      LIT	3	;<=
      0  20e2					      db	27
      1  20e2		       1b		      .byte.b	27
      0  20e3					      dw	3
      1  20e3		       03 00		      .word.w	3
      0  20e5					      IJMP	iRFound
      0  20e5					      db	29
      1  20e5		       1d		      .byte.b	29
      0  20e6					      dw	iRFound
      1  20e6		       13 21		      .word.w	iRFound
    504  20e8				   iR1
      0  20e8					      TST	iR3,">"
      0  20e8					      db	32
      1  20e8		       20		      .byte.b	32
      0  20e9					      db	(iR3-*)-1
      1  20e9		       08		      .byte.b	(iR3-*)-1
      0  20ea					      db	">",0
      1  20ea		       3e 00		      .byte.b	">",0
      0  20ec					      LIT	5	;<>
      0  20ec					      db	27
      1  20ec		       1b		      .byte.b	27
      0  20ed					      dw	5
      1  20ed		       05 00		      .word.w	5
      0  20ef					      IJMP	iRFound
      0  20ef					      db	29
      1  20ef		       1d		      .byte.b	29
      0  20f0					      dw	iRFound
      1  20f0		       13 21		      .word.w	iRFound
    508  20f2				   iR3
      0  20f2					      LIT	1	;<
      0  20f2					      db	27
      1  20f2		       1b		      .byte.b	27
      0  20f3					      dw	1
      1  20f3		       01 00		      .word.w	1
      0  20f5					      IJMP	iRFound
      0  20f5					      db	29
      1  20f5		       1d		      .byte.b	29
      0  20f6					      dw	iRFound
      1  20f6		       13 21		      .word.w	iRFound
    511  20f8				   iR4
      0  20f8					      TST	iRDone,">"
      0  20f8					      db	32
      1  20f8		       20		      .byte.b	32
      0  20f9					      db	(iRDone-*)-1
      1  20f9		       1e		      .byte.b	(iRDone-*)-1
      0  20fa					      db	">",0
      1  20fa		       3e 00		      .byte.b	">",0
      0  20fc					      TST	iR5,"="
      0  20fc					      db	32
      1  20fc		       20		      .byte.b	32
      0  20fd					      db	(iR5-*)-1
      1  20fd		       08		      .byte.b	(iR5-*)-1
      0  20fe					      db	"=",0
      1  20fe		       3d 00		      .byte.b	"=",0
      0  2100					      LIT	6	;>=
      0  2100					      db	27
      1  2100		       1b		      .byte.b	27
      0  2101					      dw	6
      1  2101		       06 00		      .word.w	6
      0  2103					      IJMP	iRFound
      0  2103					      db	29
      1  2103		       1d		      .byte.b	29
      0  2104					      dw	iRFound
      1  2104		       13 21		      .word.w	iRFound
    516  2106				   iR5
      0  2106					      TST	iR6,"<"
      0  2106					      db	32
      1  2106		       20		      .byte.b	32
      0  2107					      db	(iR6-*)-1
      1  2107		       08		      .byte.b	(iR6-*)-1
      0  2108					      db	"<",0
      1  2108		       3c 00		      .byte.b	"<",0
      0  210a					      LIT	1
      0  210a					      db	27
      1  210a		       1b		      .byte.b	27
      0  210b					      dw	1
      1  210b		       01 00		      .word.w	1
      0  210d					      IJMP	iRFound	;(This line originally omitted)
      0  210d					      db	29
      1  210d		       1d		      .byte.b	29
      0  210e					      dw	iRFound
      1  210e		       13 21		      .word.w	iRFound
    520  2110				   iR6
      0  2110					      LIT	4	;>
      0  2110					      db	27
      1  2110		       1b		      .byte.b	27
      0  2111					      dw	4
      1  2111		       04 00		      .word.w	4
    522  2113				   iRFound
      0  2113					      Call	EXPR	; get the right side of the expression
      0  2113					      db	28
      1  2113		       1c		      .byte.b	28
      0  2114					      dw	EXPR
      1  2114		       9e 20		      .word.w	EXPR
      0  2116					      CMPR		; Push the value of the true false onto the stack
      0  2116					      db	10
      1  2116		       0a		      .byte.b	10
      0  2117					      RTN
      0  2117					      db	25
      1  2117		       19		      .byte.b	25
    526  2118
    527  2118				   iRDone
      0  2118					      RTN
      0  2118					      db	25
      1  2118		       19		      .byte.b	25
    529  2119
    530  2119				   EXPR2
      0  2119					      TST	E0,"-"	; Look for leading - to negate term
      0  2119					      db	32
      1  2119		       20		      .byte.b	32
      0  211a					      db	(E0-*)-1
      1  211a		       09		      .byte.b	(E0-*)-1
      0  211b					      db	"-",0
      1  211b		       2d 00		      .byte.b	"-",0
      0  211d					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  211d					      db	28
      1  211d		       1c		      .byte.b	28
      0  211e					      dw	TERM
      1  211e		       42 21		      .word.w	TERM
      0  2120					      NEG		; Make value negated
      0  2120					      db	16
      1  2120		       10		      .byte.b	16
      0  2121					      IJMP	E1	; We have Left term process operators next
      0  2121					      db	29
      1  2121		       1d		      .byte.b	29
      0  2122					      dw	E1
      1  2122		       2b 21		      .word.w	E1
    535  2124				   E0
      0  2124					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  2124					      db	32
      1  2124		       20		      .byte.b	32
      0  2125					      db	(E1A-*)-1
      1  2125		       02		      .byte.b	(E1A-*)-1
      0  2126					      db	"+",0
      1  2126		       2b 00		      .byte.b	"+",0
    537  2128				   E1A
      0  2128					      CALL	TERM	; Get the left term if it was not negated
      0  2128					      db	28
      1  2128		       1c		      .byte.b	28
      0  2129					      dw	TERM
      1  2129		       42 21		      .word.w	TERM
    539  212b				   E1
      0  212b					      TST	E2,"+"	; Check if we are adding left term to something
      0  212b					      db	32
      1  212b		       20		      .byte.b	32
      0  212c					      db	(E2-*)-1
      1  212c		       09		      .byte.b	(E2-*)-1
      0  212d					      db	"+",0
      1  212d		       2b 00		      .byte.b	"+",0
      0  212f					      CALL	TERM	; if adding then get the right side term
      0  212f					      db	28
      1  212f		       1c		      .byte.b	28
      0  2130					      dw	TERM
      1  2130		       42 21		      .word.w	TERM
      0  2132					      ADD		; Add it to left term
      0  2132					      db	14
      1  2132		       0e		      .byte.b	14
      0  2133					      IJMP	E1	; look for next + or -
      0  2133					      db	29
      1  2133		       1d		      .byte.b	29
      0  2134					      dw	E1
      1  2134		       2b 21		      .word.w	E1
    544  2136				   E2
      0  2136					      TST	E3,"-"	; Check if we are subtractig something
      0  2136					      db	32
      1  2136		       20		      .byte.b	32
      0  2137					      db	(E3-*)-1
      1  2137		       09		      .byte.b	(E3-*)-1
      0  2138					      db	"-",0
      1  2138		       2d 00		      .byte.b	"-",0
      0  213a					      CALL	TERM	; get right side to subtract Diffrence
      0  213a					      db	28
      1  213a		       1c		      .byte.b	28
      0  213b					      dw	TERM
      1  213b		       42 21		      .word.w	TERM
      0  213d					      SUB		; Subtract the value
      0  213d					      db	15
      1  213d		       0f		      .byte.b	15
      0  213e					      IJMP	E1	; Look for next + or -
      0  213e					      db	29
      1  213e		       1d		      .byte.b	29
      0  213f					      dw	E1
      1  213f		       2b 21		      .word.w	E1
    549  2141				   E3			; Finish processing the expression
      0  2141					      RTN		; We are finished processing the Expression
      0  2141					      db	25
      1  2141		       19		      .byte.b	25
    551  2142							;
    552  2142							; Get one of the terms of an expression
    553  2142							;
    554  2142				   TERM
      0  2142					      CALL	FACT	; Get a value
      0  2142					      db	28
      1  2142		       1c		      .byte.b	28
      0  2143					      dw	FACT
      1  2143		       6a 21		      .word.w	FACT
    556  2145				   T0			; Check for higher precidence operators
      0  2145					      TST	T1,"*"	; Check for *
      0  2145					      db	32
      1  2145		       20		      .byte.b	32
      0  2146					      db	(T1-*)-1
      1  2146		       09		      .byte.b	(T1-*)-1
      0  2147					      db	"*",0
      1  2147		       2a 00		      .byte.b	"*",0
      0  2149					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  2149					      db	28
      1  2149		       1c		      .byte.b	28
      0  214a					      dw	FACT
      1  214a		       6a 21		      .word.w	FACT
      0  214c					      MUL		; Multiply factors
      0  214c					      db	17
      1  214c		       11		      .byte.b	17
      0  214d					      IJMP	T0	; Check for * or /
      0  214d					      db	29
      1  214d		       1d		      .byte.b	29
      0  214e					      dw	T0
      1  214e		       45 21		      .word.w	T0
    561  2150				   T1
      0  2150					      TST	T2,"/"	; Check for a division
      0  2150					      db	32
      1  2150		       20		      .byte.b	32
      0  2151					      db	(T2-*)-1
      1  2151		       09		      .byte.b	(T2-*)-1
      0  2152					      db	"/",0
      1  2152		       2f 00		      .byte.b	"/",0
      0  2154					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2154					      db	28
      1  2154		       1c		      .byte.b	28
      0  2155					      dw	FACT
      1  2155		       6a 21		      .word.w	FACT
      0  2157					      DIV		; do division
      0  2157					      db	18
      1  2157		       12		      .byte.b	18
      0  2158					      IJMP	T0	; check for more * or /
      0  2158					      db	29
      1  2158		       1d		      .byte.b	29
      0  2159					      dw	T0
      1  2159		       45 21		      .word.w	T0
    566  215b				   T2
      0  215b					      TST	T3,"%"	; Check for a division
      0  215b					      db	32
      1  215b		       20		      .byte.b	32
      0  215c					      db	(T3-*)-1
      1  215c		       09		      .byte.b	(T3-*)-1
      0  215d					      db	"%",0
      1  215d		       25 00		      .byte.b	"%",0
      0  215f					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  215f					      db	28
      1  215f		       1c		      .byte.b	28
      0  2160					      dw	FACT
      1  2160		       6a 21		      .word.w	FACT
      0  2162					      MODULO		; do division for remainder
      0  2162					      db	60
      1  2162		       3c		      .byte.b	60
      0  2163					      IJMP	T0	; check for more * or / or %
      0  2163					      db	29
      1  2163		       1d		      .byte.b	29
      0  2164					      dw	T0
      1  2164		       45 21		      .word.w	T0
    571  2166				   T3			; Finish processing the Term
      0  2166					      RTN
      0  2166					      db	25
      1  2166		       19		      .byte.b	25
    573  2167
    574  2167				   UNKNOWNVEC
      0  2167					      IJMP	UNKNOWN
      0  2167					      db	29
      1  2167		       1d		      .byte.b	29
      0  2168					      dw	UNKNOWN
      1  2168		       9a 20		      .word.w	UNKNOWN
    576  216a
    577  216a							;=============================================================================================
    578  216a							; Factor an expression.  Always test for functions
    579  216a							; first or else they'll be confused for variables.
    580  216a							;
    581  216a				   FACT
      0  216a					      TST	F1AA,"TRUE"
      0  216a					      db	32
      1  216a		       20		      .byte.b	32
      0  216b					      db	(F1AA-*)-1
      1  216b		       09		      .byte.b	(F1AA-*)-1
      0  216c					      db	"TRUE",0
      1  216c		       54 52 55 45*	      .byte.b	"TRUE",0
      0  2171					      LIT	-1
      0  2171					      db	27
      1  2171		       1b		      .byte.b	27
      0  2172					      dw	-1
      1  2172		       ff ff		      .word.w	-1
      0  2174					      RTN
      0  2174					      db	25
      1  2174		       19		      .byte.b	25
    585  2175				   F1AA
      0  2175					      TST	F1AB,"FALSE"
      0  2175					      db	32
      1  2175		       20		      .byte.b	32
      0  2176					      db	(F1AB-*)-1
      1  2176		       0a		      .byte.b	(F1AB-*)-1
      0  2177					      db	"FALSE",0
      1  2177		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  217d					      LIT	0
      0  217d					      db	27
      1  217d		       1b		      .byte.b	27
      0  217e					      dw	0
      1  217e		       00 00		      .word.w	0
      0  2180					      RTN
      0  2180					      db	25
      1  2180		       19		      .byte.b	25
    589  2181							;==================================================================================
    590  2181							; Returns the amount of free SPACE
    591  2181							;
    592  2181				   F1AB
      0  2181					      TST	F1A,"FREE()"
      0  2181					      db	32
      1  2181		       20		      .byte.b	32
      0  2182					      db	(F1A-*)-1
      1  2182		       09		      .byte.b	(F1A-*)-1
      0  2183					      db	"FREE()",0
      1  2183		       46 52 45 45*	      .byte.b	"FREE()",0
      0  218a					      FREE
      0  218a					      db	36
      1  218a		       24		      .byte.b	36
      0  218b					      RTN
      0  218b					      db	25
      1  218b		       19		      .byte.b	25
    596  218c							;===================================================================================
    597  218c							; getch() read a character from the input device
    598  218c							;
    599  218c				   F1A
      0  218c					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  218c					      db	32
      1  218c		       20		      .byte.b	32
      0  218d					      db	(F1A2-*)-1
      1  218d		       0a		      .byte.b	(F1A2-*)-1
      0  218e					      db	"GETCH()",0
      1  218e		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  2196					      GETCHAR
      0  2196					      db	51
      1  2196		       33		      .byte.b	51
      0  2197					      RTN
      0  2197					      db	25
      1  2197		       19		      .byte.b	25
    603  2198							;====================================================================================
    604  2198							; peek(mem address) return the value of a byte in memory
    605  2198							; @[offset] return a word value from offset -- see tstv
    606  2198							;
    607  2198				   F1A2
      0  2198					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  2198					      db	32
      1  2198		       20		      .byte.b	32
      0  2199					      db	(F2AZ-*)-1
      1  2199		       0f		      .byte.b	(F2AZ-*)-1
      0  219a					      db	"PEEK(",0
      1  219a		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  21a0					      CALL	EXPR	;Get the address to write to
      0  21a0					      db	28
      1  21a0		       1c		      .byte.b	28
      0  21a1					      dw	EXPR
      1  21a1		       9e 20		      .word.w	EXPR
      0  21a3					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  21a3					      db	32
      1  21a3		       20		      .byte.b	32
      0  21a4					      db	(UNKNOWNVEC-*)-1
      1  21a4		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  21a5					      db	")",0
      1  21a5		       29 00		      .byte.b	")",0
      0  21a7					      PEEKMEM
      0  21a7					      db	48
      1  21a7		       30		      .byte.b	48
      0  21a8					      RTN
      0  21a8					      db	25
      1  21a8		       19		      .byte.b	25
    613  21a9							;=======================================================================================
    614  21a9							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    615  21a9							;
    616  21a9				   F2AZ
      0  21a9					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  21a9					      db	32
      1  21a9		       20		      .byte.b	32
      0  21aa					      db	(F2AZ1-*)-1
      1  21aa		       22		      .byte.b	(F2AZ1-*)-1
      0  21ab					      db	"TASK(",0
      1  21ab		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  21b1					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  21b1					      db	28
      1  21b1		       1c		      .byte.b	28
      0  21b2					      dw	EXPR
      1  21b2		       9e 20		      .word.w	EXPR
      0  21b4					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  21b4					      db	61
      1  21b4		       3d		      .byte.b	61
      0  21b5					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  21b5					      db	32
      1  21b5		       20		      .byte.b	32
      0  21b6					      db	(F2AZNoParms-*)-1
      1  21b6		       10		      .byte.b	(F2AZNoParms-*)-1
      0  21b7					      db	COMMA,0
      1  21b7		       2c 00		      .byte.b	COMMA,0
      0  21b9					      SAVEMATHSTACK		;Push The mathstack
      0  21b9					      db	86
      1  21b9		       56		      .byte.b	86
      0  21ba					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  21ba					      db	89
      1  21ba		       59		      .byte.b	89
    623  21bb				   F2AZLOOP
      0  21bb					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  21bb					      db	28
      1  21bb		       1c		      .byte.b	28
      0  21bc					      dw	EXPR
      1  21bc		       9e 20		      .word.w	EXPR
      0  21be					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  21be					      db	32
      1  21be		       20		      .byte.b	32
      0  21bf					      db	(F2AZEndParm-*)-1
      1  21bf		       05		      .byte.b	(F2AZEndParm-*)-1
      0  21c0					      db	COMMA,0
      1  21c0		       2c 00		      .byte.b	COMMA,0
      0  21c2					      IJMP	F2AZLOOP	;check for more
      0  21c2					      db	29
      1  21c2		       1d		      .byte.b	29
      0  21c3					      dw	F2AZLOOP
      1  21c3		       bb 21		      .word.w	F2AZLOOP
    627  21c5				   F2AZEndParm
      0  21c5					      RESTOREMATHSTACK		;Back to normal stack
      0  21c5					      db	87
      1  21c5		       57		      .byte.b	87
      0  21c6					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  21c6					      db	92
      1  21c6		       5c		      .byte.b	92
    630  21c7				   F2AZNoParms
      0  21c7					      TST	UNKNOWNVEC,")"	;must be )
      0  21c7					      db	32
      1  21c7		       20		      .byte.b	32
      0  21c8					      db	(UNKNOWNVEC-*)-1
      1  21c8		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  21c9					      db	")",0
      1  21c9		       29 00		      .byte.b	")",0
      0  21cb					      TASKENABLE		;Enable the task to execute
      0  21cb					      db	90
      1  21cb		       5a		      .byte.b	90
      0  21cc					      RTN		;Returns the Task number
      0  21cc					      db	25
      1  21cc		       19		      .byte.b	25
    634  21cd							;=========================================================================================
    635  21cd							; Check for IPC interproccess instructions
    636  21cd							;   IPCS  - Send a message
    637  21cd							;
    638  21cd				   F2AZ1
      0  21cd					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  21cd					      db	32
      1  21cd		       20		      .byte.b	32
      0  21ce					      db	(F2A-*)-1
      1  21ce		       3c		      .byte.b	(F2A-*)-1
      0  21cf					      db	"IPC",0
      1  21cf		       49 50 43 00	      .byte.b	"IPC",0
      0  21d3					      TST	F2AZa,"S("	;IPCS - send a message
      0  21d3					      db	32
      1  21d3		       20		      .byte.b	32
      0  21d4					      db	(F2AZa-*)-1
      1  21d4		       13		      .byte.b	(F2AZa-*)-1
      0  21d5					      db	"S(",0
      1  21d5		       53 28 00 	      .byte.b	"S(",0
      0  21d8					      CALL	EXPR	;Get the message value
      0  21d8					      db	28
      1  21d8		       1c		      .byte.b	28
      0  21d9					      dw	EXPR
      1  21d9		       9e 20		      .word.w	EXPR
      0  21db					      TST	UNKNOWNVEC,COMMA
      0  21db					      db	32
      1  21db		       20		      .byte.b	32
      0  21dc					      db	(UNKNOWNVEC-*)-1
      1  21dc		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  21dd					      db	COMMA,0
      1  21dd		       2c 00		      .byte.b	COMMA,0
      0  21df					      CALL	EXPR	;Get pid of task to send to
      0  21df					      db	28
      1  21df		       1c		      .byte.b	28
      0  21e0					      dw	EXPR
      1  21e0		       9e 20		      .word.w	EXPR
      0  21e2					      TST	UNKNOWNVEC,")"
      0  21e2					      db	32
      1  21e2		       20		      .byte.b	32
      0  21e3					      db	(UNKNOWNVEC-*)-1
      1  21e3		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  21e4					      db	")",0
      1  21e4		       29 00		      .byte.b	")",0
      0  21e6					      IPCSEND		;Send msg and clear pid msg pending
      0  21e6					      db	80
      1  21e6		       50		      .byte.b	80
      0  21e7					      RTN
      0  21e7					      db	25
      1  21e7		       19		      .byte.b	25
    647  21e8							;================================================================================
    648  21e8							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    649  21e8							;
    650  21e8				   F2AZa
      0  21e8					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  21e8					      db	32
      1  21e8		       20		      .byte.b	32
      0  21e9					      db	(F2AZb-*)-1
      1  21e9		       16		      .byte.b	(F2AZb-*)-1
      0  21ea					      db	"R(",0
      1  21ea		       52 28 00 	      .byte.b	"R(",0
      0  21ed					      TST	F2AZa1,")"
      0  21ed					      db	32
      1  21ed		       20		      .byte.b	32
      0  21ee					      db	(F2AZa1-*)-1
      1  21ee		       08		      .byte.b	(F2AZa1-*)-1
      0  21ef					      db	")",0
      1  21ef		       29 00		      .byte.b	")",0
      0  21f1					      LIT	0	;We dont want the pid returned to us
      0  21f1					      db	27
      1  21f1		       1b		      .byte.b	27
      0  21f2					      dw	0
      1  21f2		       00 00		      .word.w	0
      0  21f4					      IPCIO		;Set the io bit and suspend the task till message
      0  21f4					      db	83
      1  21f4		       53		      .byte.b	83
      0  21f5					      IPCRECEIVE		;Get the message
      0  21f5					      db	81
      1  21f5		       51		      .byte.b	81
      0  21f6					      RTN
      0  21f6					      db	25
      1  21f6		       19		      .byte.b	25
    657  21f7				   F2AZa1
      0  21f7					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  21f7					      db	33
      1  21f7		       21		      .byte.b	33
      0  21f8					      db	(UNKNOWNVEC-*)-1
      1  21f8		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  21f9					      TST	UNKNOWNVEC,")"
      0  21f9					      db	32
      1  21f9		       20		      .byte.b	32
      0  21fa					      db	(UNKNOWNVEC-*)-1
      1  21fa		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  21fb					      db	")",0
      1  21fb		       29 00		      .byte.b	")",0
      0  21fd					      IPCIO		;Set the io bit and exit task till message
      0  21fd					      db	83
      1  21fd		       53		      .byte.b	83
      0  21fe					      IPCRECEIVE		;Get the message
      0  21fe					      db	81
      1  21fe		       51		      .byte.b	81
      0  21ff					      RTN
      0  21ff					      db	25
      1  21ff		       19		      .byte.b	25
    663  2200							;===============================================================================
    664  2200							; IPCC ---- check if a message is available
    665  2200				   F2AZb
      0  2200					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  2200					      db	32
      1  2200		       20		      .byte.b	32
      0  2201					      db	(UNKNOWNVEC-*)-1
      1  2201		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  2202					      db	"C()",0
      1  2202		       43 28 29 00	      .byte.b	"C()",0
      0  2206					      IPCCHECK
      0  2206					      db	82
      1  2206		       52		      .byte.b	82
      0  2207					      RTN
      0  2207					      db	25
      1  2207		       19		      .byte.b	25
    669  2208
    670  2208				   UNKNOWNID
      0  2208					      IJMP	UNKNOWN
      0  2208					      db	29
      1  2208		       1d		      .byte.b	29
      0  2209					      dw	UNKNOWN
      1  2209		       9a 20		      .word.w	UNKNOWN
    672  220b							;============================================================
    673  220b							; RND() is supposed to have an argument but if none
    674  220b							; was provided, just assume a large value.
    675  220b							;
    676  220b				   F2A
      0  220b					      TST	F2B,"RND("
      0  220b					      db	32
      1  220b		       20		      .byte.b	32
      0  220c					      db	(F2B-*)-1
      1  220c		       17		      .byte.b	(F2B-*)-1
      0  220d					      db	"RND(",0
      1  220d		       52 4e 44 28*	      .byte.b	"RND(",0
      0  2212					      TST	F2A1,")"
      0  2212					      db	32
      1  2212		       20		      .byte.b	32
      0  2213					      db	(F2A1-*)-1
      1  2213		       07		      .byte.b	(F2A1-*)-1
      0  2214					      db	")",0
      1  2214		       29 00		      .byte.b	")",0
      0  2216					      LIT	32766
      0  2216					      db	27
      1  2216		       1b		      .byte.b	27
      0  2217					      dw	32766
      1  2217		       fe 7f		      .word.w	32766
      0  2219					      RANDOM
      0  2219					      db	37
      1  2219		       25		      .byte.b	37
      0  221a					      RTN
      0  221a					      db	25
      1  221a		       19		      .byte.b	25
    682  221b
    683  221b				   F2A1
      0  221b					      CALL	FACT	;GET RANGE
      0  221b					      db	28
      1  221b		       1c		      .byte.b	28
      0  221c					      dw	FACT
      1  221c		       6a 21		      .word.w	FACT
      0  221e					      TST	UNKNOWNVEC,")"
      0  221e					      db	32
      1  221e		       20		      .byte.b	32
      0  221f					      db	(UNKNOWNVEC-*)-1
      1  221f		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  2220					      db	")",0
      1  2220		       29 00		      .byte.b	")",0
      0  2222					      RANDOM
      0  2222					      db	37
      1  2222		       25		      .byte.b	37
      0  2223					      RTN
      0  2223					      db	25
      1  2223		       19		      .byte.b	25
    688  2224							;==========================================================
    689  2224							;	Return absolute value of expresion
    690  2224							;
    691  2224				   F2B
      0  2224					      TST	F2B2,"ABS("
      0  2224					      db	32
      1  2224		       20		      .byte.b	32
      0  2225					      db	(F2B2-*)-1
      1  2225		       0e		      .byte.b	(F2B2-*)-1
      0  2226					      db	"ABS(",0
      1  2226		       41 42 53 28*	      .byte.b	"ABS(",0
      0  222b					      CALL	EXPR	;get value
      0  222b					      db	28
      1  222b		       1c		      .byte.b	28
      0  222c					      dw	EXPR
      1  222c		       9e 20		      .word.w	EXPR
      0  222e					      TST	UNKNOWNVEC,")"
      0  222e					      db	32
      1  222e		       20		      .byte.b	32
      0  222f					      db	(UNKNOWNVEC-*)-1
      1  222f		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  2230					      db	")",0
      1  2230		       29 00		      .byte.b	")",0
      0  2232					      ABS
      0  2232					      db	38
      1  2232		       26		      .byte.b	38
      0  2233					      RTN
      0  2233					      db	25
      1  2233		       19		      .byte.b	25
    697  2234							;============================================================
    698  2234							;     Return the the status of a task, provide the PID
    699  2234							;
    700  2234				   F2B2
      0  2234					      TST	F2Z,"STAT("
      0  2234					      db	32
      1  2234		       20		      .byte.b	32
      0  2235					      db	(F2Z-*)-1
      1  2235		       0f		      .byte.b	(F2Z-*)-1
      0  2236					      db	"STAT(",0
      1  2236		       53 54 41 54*	      .byte.b	"STAT(",0
      0  223c					      Call	EXPR
      0  223c					      db	28
      1  223c		       1c		      .byte.b	28
      0  223d					      dw	EXPR
      1  223d		       9e 20		      .word.w	EXPR
      0  223f					      TST	UNKNOWNVEC,")"
      0  223f					      db	32
      1  223f		       20		      .byte.b	32
      0  2240					      db	(UNKNOWNVEC-*)-1
      1  2240		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  2241					      db	")",0
      1  2241		       29 00		      .byte.b	")",0
      0  2243					      TASKSTAT
      0  2243					      db	66
      1  2243		       42		      .byte.b	66
      0  2244					      RTN
      0  2244					      db	25
      1  2244		       19		      .byte.b	25
    706  2245				   F2Z
      0  2245					      TST	F2ZA,"PID"
      0  2245					      db	32
      1  2245		       20		      .byte.b	32
      0  2246					      db	(F2ZA-*)-1
      1  2246		       06		      .byte.b	(F2ZA-*)-1
      0  2247					      db	"PID",0
      1  2247		       50 49 44 00	      .byte.b	"PID",0
      0  224b					      TASKPID
      0  224b					      db	77
      1  224b		       4d		      .byte.b	77
      0  224c					      RTN
      0  224c					      db	25
      1  224c		       19		      .byte.b	25
    710  224d							;===========================================================================
    711  224d							; Call a machine function, provide the address to call and optionally
    712  224d							; the value to be passed in reg A
    713  224d				   F2ZA
      0  224d					      TST	F2FUNC,"CALL("	;call machine function
      0  224d					      db	32
      1  224d		       20		      .byte.b	32
      0  224e					      db	(F2FUNC-*)-1
      1  224e		       1f		      .byte.b	(F2FUNC-*)-1
      0  224f					      db	"CALL(",0
      1  224f		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  2255					      CALL	EXPR
      0  2255					      db	28
      1  2255		       1c		      .byte.b	28
      0  2256					      dw	EXPR
      1  2256		       9e 20		      .word.w	EXPR
      0  2258					      TST	F2B2A,COMMA
      0  2258					      db	32
      1  2258		       20		      .byte.b	32
      0  2259					      db	(F2B2A-*)-1
      1  2259		       0b		      .byte.b	(F2B2A-*)-1
      0  225a					      db	COMMA,0
      1  225a		       2c 00		      .byte.b	COMMA,0
      0  225c					      CALL	EXPR
      0  225c					      db	28
      1  225c		       1c		      .byte.b	28
      0  225d					      dw	EXPR
      1  225d		       9e 20		      .word.w	EXPR
      0  225f					      TST	UNKNOWNVEC,")"
      0  225f					      db	32
      1  225f		       20		      .byte.b	32
      0  2260					      db	(UNKNOWNVEC-*)-1
      1  2260		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  2261					      db	")",0
      1  2261		       29 00		      .byte.b	")",0
      0  2263					      CALLFUNC
      0  2263					      db	53
      1  2263		       35		      .byte.b	53
      0  2264					      RTN
      0  2264					      db	25
      1  2264		       19		      .byte.b	25
    721  2265							; Run the gosub within this function
    722  2265				   F2B2A
      0  2265					      TST	UNKNOWNID,")"
      0  2265					      db	32
      1  2265		       20		      .byte.b	32
      0  2266					      db	(UNKNOWNID-*)-1
      1  2266		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  2267					      db	")",0
      1  2267		       29 00		      .byte.b	")",0
      0  2269					      LIT	0	; No parameter passed so just load zero to A
      0  2269					      db	27
      1  2269		       1b		      .byte.b	27
      0  226a					      dw	0
      1  226a		       00 00		      .word.w	0
      0  226c					      CALLFUNC
      0  226c					      db	53
      1  226c		       35		      .byte.b	53
      0  226d					      RTN
      0  226d					      db	25
      1  226d		       19		      .byte.b	25
    727  226e							;===========================================================================
    728  226e							; Same as gosub but expects a return value
    729  226e							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    730  226e							;
      0  226e				   F2FUNC     TST	F2C,"GOFN"
      0  226e					      db	32
      1  226e		       20		      .byte.b	32
      0  226f					      db	(F2C-*)-1
      1  226f		       0c		      .byte.b	(F2C-*)-1
      0  2270					      db	"GOFN",0
      1  2270		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  2275					      Call	GOSUBSTATEMENT
      0  2275					      db	28
      1  2275		       1c		      .byte.b	28
      0  2276					      dw	GOSUBSTATEMENT
      1  2276		       a5 22		      .word.w	GOSUBSTATEMENT
      0  2278					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  2278					      db	8
      1  2278		       08		      .byte.b	8
      0  2279					      db	GOSUB_RTN_VALUE
      1  2279		       81		      .byte.b	GOSUB_RTN_VALUE
      0  227a					      XFER
      0  227a					      db	7
      1  227a		       07		      .byte.b	7
    735  227b				   GOFNRet
      0  227b					      RTN
      0  227b					      db	25
      1  227b		       19		      .byte.b	25
    737  227c							;=============================================================================
    738  227c							; See if this is just a simple variable
    739  227c							;  Allow a subscript for any variable
    740  227c							;
    741  227c				   F2C
      0  227c					      TSTV	F0
      0  227c					      db	33
      1  227c		       21		      .byte.b	33
      0  227d					      db	(F0-*)-1
      1  227d		       15		      .byte.b	(F0-*)-1
      0  227e					      TST	F2CLocalTask,"!"
      0  227e					      db	32
      1  227e		       20		      .byte.b	32
      0  227f					      db	(F2CLocalTask-*)-1
      1  227f		       05		      .byte.b	(F2CLocalTask-*)-1
      0  2280					      db	"!",0
      1  2280		       21 00		      .byte.b	"!",0
      0  2282					      IND		; we just got a pid
      0  2282					      db	20
      1  2282		       14		      .byte.b	20
      0  2283					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  2283					      db	93
      1  2283		       5d		      .byte.b	93
      0  2284					      db	(UNKNOWNID-*)-1
      1  2284		       83		      .byte.b	(UNKNOWNID-*)-1
    746  2285
    747  2285				   F2CLocalTask
      0  2285					      TST	F2C1,"["
      0  2285					      db	32
      1  2285		       20		      .byte.b	32
      0  2286					      db	(F2C1-*)-1
      1  2286		       0a		      .byte.b	(F2C1-*)-1
      0  2287					      db	"[",0
      1  2287		       5b 00		      .byte.b	"[",0
      0  2289					      CALL	EXPR
      0  2289					      db	28
      1  2289		       1c		      .byte.b	28
      0  228a					      dw	EXPR
      1  228a		       9e 20		      .word.w	EXPR
      0  228c					      TST	UNKNOWNID,"]"
      0  228c					      db	32
      1  228c		       20		      .byte.b	32
      0  228d					      db	(UNKNOWNID-*)-1
      1  228d		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  228e					      db	"]",0
      1  228e		       5d 00		      .byte.b	"]",0
      0  2290					      SUBSCRIPT
      0  2290					      db	64
      1  2290		       40		      .byte.b	64
    752  2291				   F2C1
      0  2291					      IND		;YES, GET THE VALUE.
      0  2291					      db	20
      1  2291		       14		      .byte.b	20
      0  2292					      RTN
      0  2292					      db	25
      1  2292		       19		      .byte.b	25
    755  2293							;=================================================================================
    756  2293							;Finally check for a number !
    757  2293							;
    758  2293				   F0
      0  2293					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  2293					      db	35
      1  2293		       23		      .byte.b	35
      0  2294					      db	(F1-*)-1
      1  2294		       01		      .byte.b	(F1-*)-1
      0  2295					      RTN
      0  2295					      db	25
      1  2295		       19		      .byte.b	25
    761  2296				   F1
      0  2296					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  2296					      db	32
      1  2296		       20		      .byte.b	32
      0  2297					      db	(F2RTN-*)-1
      1  2297		       09		      .byte.b	(F2RTN-*)-1
      0  2298					      db	"(",0
      1  2298		       28 00		      .byte.b	"(",0
      0  229a					      CALL	EXPR
      0  229a					      db	28
      1  229a		       1c		      .byte.b	28
      0  229b					      dw	EXPR
      1  229b		       9e 20		      .word.w	EXPR
      0  229d					      TST	F2,")"
      0  229d					      db	32
      1  229d		       20		      .byte.b	32
      0  229e					      db	(F2-*)-1
      1  229e		       03		      .byte.b	(F2-*)-1
      0  229f					      db	")",0
      1  229f		       29 00		      .byte.b	")",0
    765  22a1				   F2RTN
      0  22a1					      RTN
      0  22a1					      db	25
      1  22a1		       19		      .byte.b	25
    767  22a2
    768  22a2				   F2
      0  22a2					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  22a2					      db	13
      1  22a2		       0d		      .byte.b	13
      0  22a3					      dw	ERR_SYNTAX
      1  22a3		       05 00		      .word.w	ERR_SYNTAX
    770  22a5							;
    771  22a5							;=============================================================
    772  22a5							; Gosub can be both a Function and a Subroutine
    773  22a5				   GOSUBSTATEMENT
      0  22a5					      CALL	EXPR	;GET DESTINATION
      0  22a5					      db	28
      1  22a5		       1c		      .byte.b	28
      0  22a6					      dw	EXPR
      1  22a6		       9e 20		      .word.w	EXPR
      0  22a8					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  22a8					      db	32
      1  22a8		       20		      .byte.b	32
      0  22a9					      db	(GOSUBDONE-*)-1
      1  22a9		       14		      .byte.b	(GOSUBDONE-*)-1
      0  22aa					      db	"(",0
      1  22aa		       28 00		      .byte.b	"(",0
      0  22ac					      STK2TMP		;Transfer stack top to temp
      0  22ac					      db	95
      1  22ac		       5f		      .byte.b	95
      0  22ad					      PUSHMATHSTACK		;Record stack frame for return
      0  22ad					      db	84
      1  22ad		       54		      .byte.b	84
    778  22ae				   GOSUBLOOP
      0  22ae					      CALL	EXPR	; Allows what ever fits onto stack
      0  22ae					      db	28
      1  22ae		       1c		      .byte.b	28
      0  22af					      dw	EXPR
      1  22af		       9e 20		      .word.w	EXPR
      0  22b1					      INCPARMCOUNT
      0  22b1					      db	88
      1  22b1		       58		      .byte.b	88
      0  22b2					      TST	GOSUBParmDONE,COMMA
      0  22b2					      db	32
      1  22b2		       20		      .byte.b	32
      0  22b3					      db	(GOSUBParmDONE-*)-1
      1  22b3		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  22b4					      db	COMMA,0
      1  22b4		       2c 00		      .byte.b	COMMA,0
      0  22b6					      IJMP	GOSUBLOOP
      0  22b6					      db	29
      1  22b6		       1d		      .byte.b	29
      0  22b7					      dw	GOSUBLOOP
      1  22b7		       ae 22		      .word.w	GOSUBLOOP
    783  22b9				   GOSUBParmDONE
      0  22b9					      TST	F2,")"
      0  22b9					      db	32
      1  22b9		       20		      .byte.b	32
      0  22ba					      db	(F2-*)-1
      1  22ba		       e7		      .byte.b	(F2-*)-1
      0  22bb					      db	")",0
      1  22bb		       29 00		      .byte.b	")",0
      0  22bd					      TMP2STK		;Restore line to goto
      0  22bd					      db	96
      1  22bd		       60		      .byte.b	96
    786  22be				   GOSUBDONE
      0  22be					      RTN
      0  22be					      db	25
      1  22be		       19		      .byte.b	25
    788  22bf
    789  22bf		       22 bf	   ILEND      equ	*
------- FILE mytb.asm
   2225  22bf		       22 bf	   PROGEND    equ	*
   2226  22bf
   2227  22bf
   2228  22bf							;=====================================================
   2229  22bf							; Define start of non page zero data
   2230 U22cf					      seg.u	TBData
   2231 U22cf
   2232 U22cf							;=====================================================
   2233 U22cf							; These are storage items not in page zero.
   2234 U22cf							;
   2235 U22cf							; IRQ BASIC Code Service RTN Support
      0 U22cf				   SaveIrqReg db	0	; Store current setting
      1 U22cf		       00		      .byte.b	0
      0 U22d0				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U22d0		       00		      .byte.b	0
      0 U22d1				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U22d1		       00		      .byte.b	0
      0 U22d2				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U22d2		       00 00		      .byte.b	0,0
   2240 U22d4
   2241 U22d4							;
   2242 U22d4							;==================================================================================================
   2243 U22d4							; Task Management information
   2244 U22d4							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2245 U22d4							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2246 U22d4							; Task switchs happen at the beginning of the next Basic command line
   2247 U22d4							; It will not happen during an input or output operations
   2248 U22d4							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2249 U22d4							; Task Zero is always the root task, main line program
   2250 U22d4							;
   2251 U22d4							; Layout is repeated for each configured task
   2252 U22d4							; Task Table Byte   use masks follow
   2253 U22d4		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2254 U22d4		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2255 U22d4		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2256 U22d4		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2257 U22d4		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2258 U22d4
   2259 U22d4		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2260 U22d5		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2261 U22d5		       23 cf	   TASKTABLEEND equ	*	; End of task table
   2262 U22d5		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2263 U23cf
   2264 U23cf							;Task Cycle Counter and reset count
   2265 U23cf		       00 00	   taskCurrentCycles ds	2
   2266 U23d1		       00 00	   taskResetValue ds	2
   2267 U23d3		       00	   taskCounter ds	1	; Count of active tasks
   2268 U23d4
   2269 U23d4							;
   2270 U23d4							; Math stack and IL call and Gosub/For-next return stack definitions
   2271 U23d4							;
   2272 U23d4		       23 d4	   STACKSTART equ	*
   2273 U23d4		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2274 U2564		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2275 U26f4		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2276 U2974		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2277 U2974		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2278 U2974		       2b 90	   STACKEND   equ	*
   2279 U2974		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2280 U2b90							;
   2281 U2b90							;
   2282 U2b90		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2283 U2c14		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2284 U2c15		       00	   printtx    ds	1	;temp X for print funcs
   2285 U2c16		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2286 U2c17		       00	   promptChar ds	1	;the character to use for a prompt
   2287 U2c18		       00	   diddigit   ds	1	;for leading zero suppression
   2288 U2c19		       00	   putsy      ds	1
   2289 U2c1a		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2290 U2c1c		       00	   sign       ds	1	;0 = positive, else negative
   2291 U2c1d		       00 00	   rtemp1     ds	2	;Temp for x and y
   2292 U2c1f		       00 00	   random     ds	2
   2293 U2c21		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2294 U2c23		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2295 U2c25		       00	   tempy      ds	1	;temp y storage
   2296 U2c26
   2297 U2c26							; Moved from page zero as one clock cycle diff gives more space on page zero
   2298 U2c26		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2299 U2c28		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2300 U2c29		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2301 U2c2a		       00	   lineLength ds	1	;Length of current line
   2302 U2c2b
   2303 U2c2b		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2304 U2c2c		       00	   taskRDPending ds	1	; 1 = background read is pending
   2305 U2c2d
   2306 U2c2d				  -	      if	XKIM
   2307 U2c2d				  -buffer     ds	BUFFER_SIZE
   2308 U2c2d					      endif
   2309 U2c2d							;
   2310 U2c2d							; PROGRAMEND is the end of the user's BASIC program.
   2311 U2c2d							; More precisely, it is one byte past the end.  Or,
   2312 U2c2d							; it's where the next line added to the end will be
   2313 U2c2d							; placed.
   2314 U2c2d							;
   2315 U2c2d		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2316 U2c2f		       00 00	   ProgramEnd ds	2	; End of users basic program
   2317 U2c31		       00 00	   HighMem    ds	2	; highest location
   2318 U2c33		       00 00	   UsedMem    ds	2	; size of user program
   2319 U2c35		       00 00	   FreeMem    ds	2	; amount of free memory
   2320 U2c37							;
   2321 U2c37							;=====================================================
   2322 U2c37							; This is the start of the user's BASIC program space.
   2323 U2c37							;
   2324 U2c37							; PERSONAL GOAL: This should be no larger than $0DFF.
   2325 U2c37							;		  0200-05FF = 1K
   2326 U2c37							;		  0200-09FF = 2K
   2327 U2c37							;		  0200-0DFF = 3K
   2328 U2c37							;		  0200-11FF = 4K
   2329 U2c37							;		  0200-13FF = 4.5K
   2330 U2c37							;
   2331 U2c37				  -	      if	FIXED
   2332 U2c37				  -	      org	$2000
   2333 U2c37					      endif
   2334 U2c37
   2335 U2c37		       2c 37	   FreeMemStart equ	*
   2336 U2c37							;/*
   2337 U2c37							;	if	CTMON65 || XKIM
   2338 U2c37							;		SEG Code
   2339 U2c37							;		org	AutoRun
   2340 U2c37							;		dw	TBasicCold
   2341 U2c37							;	endif
   2342 U2c37							;*/
   2343 U2c37					      end
