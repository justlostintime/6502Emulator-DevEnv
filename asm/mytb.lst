------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2edc				   input      processor	6502
      2 U2edc ????						;=====================================================
      3 U2edc ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2edc ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2edc ????						; Free Time. Now abiut 6K Full OS features.
      6 U2edc ????						;
      7 U2edc ????						; While working on the Corsham Technologies KIM Clone
      8 U2edc ????						; project, I wanted to include a TINY BASIC since that
      9 U2edc ????						; was a highly desirable feature of early computers.
     10 U2edc ????						;
     11 U2edc ????						; Rather than negotiating copyright issues for
     12 U2edc ????						; existing BASICs, I decided to just write one from
     13 U2edc ????						; scratch.
     14 U2edc ????						;
     15 U2edc ????						; 10/07/2017
     16 U2edc ????						;
     17 U2edc ????						; This implements a stripped down Tiny BASIC
     18 U2edc ????						; interpreter using the Interpretive Language (IL)
     19 U2edc ????						; method as described in the first few issues of
     20 U2edc ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2edc ????						; to write various languages simply by changing the
     22 U2edc ????						; IL code rather than the interpreter itself.
     23 U2edc ????						;
     24 U2edc ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2edc ????						;		* Fixed major bug in findLine that
     26 U2edc ????						;		  caused corrupted lines, crashes, etc.
     27 U2edc ????						;		* If no parameter given to RND, assume
     28 U2edc ????						;		  32766.
     29 U2edc ????						;		* No more error 5 when a program
     30 U2edc ????						;		  reaches the end without an END.
     31 U2edc ????						;
     32 U2edc ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2edc ????						;		 * Unexpanded version to play with everything
     34 U2edc ????						;		 * Add some usefull system level functions
     35 U2edc ????						;		 * allow a larger number of tiny basic formats
     36 U2edc ????						;		 * Add byte at start of line holding length
     37 U2edc ????						;		   for faster execution of goto and gosub
     38 U2edc ????						;		 * Re-added gosub
     39 U2edc ????						;		 * allow ; or , at end if print stmt
     40 U2edc ????						;		   without CRLF being added.
     41 U2edc ????						;		 * Added extended function erase to
     42 U2edc ????						;		   use the extended ctmon65 rm file
     43 U2edc ????						;		 * Fix quoted text to not have to backtrack
     44 U2edc ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2edc ????						;		 * Add concurrency features
     46 U2edc ????						;
     47 U2edc ????						; www.corshamtech.com
     48 U2edc ????						; bob@corshamtech.com
     49 U2edc ????						; JustLostInTime@gmail.com
     50 U2edc ????						;
     51 U2edc ????						;=====================================================
     52 U2edc ????						;
     53 U2edc ????						; Create TRUE and FALSE values for conditionals.
     54 U2edc ????						;
     55 U2edc ????
     56 U2edc ????	       00 00	   FALSE      equ	0
     57 U2edc ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2edc ????						;
     59 U2edc ????						;---------------------------------------------------------
     60 U2edc ????						; One of these must be set to indicate which environment
     61 U2edc ????						; Tiny BASIC will be running in.  Here are the current
     62 U2edc ????						; environments:
     63 U2edc ????						;
     64 U2edc ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2edc ????						; more K of RAM.
     66 U2edc ????						;
     67 U2edc ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2edc ????						; which enhances, without replacing, the standard KIM
     69 U2edc ????						; monitor.  It gives access to routines to save/load files
     70 U2edc ????						; to a micro SD card.
     71 U2edc ????						;
     72 U2edc ????						; CTMON65 is a from-scratch monitor written for the
     73 U2edc ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2edc ????						; easily be ported to other systems.  It has support for
     75 U2edc ????						; using a micro SD card for file storage/retrieval.
     76 U2edc ????						;
     77 U2edc ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2edc ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2edc ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2edc ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2edc ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2edc ????						;
     83 U2edc ????						;   Need to define some macros for the dasm assembler
     84 U2edc ????						;
     85 U2edc ????				      MACRO	dw
     86 U2edc ????				      .word	{0}
     87 U2edc ????				      ENDM
     88 U2edc ????
     89 U2edc ????				      MACRO	db
     90 U2edc ????				      .byte	{0}
     91 U2edc ????				      ENDM
     92 U2edc ????
     93 U2edc ????						;
     94 U2edc ????						; If set, include disk functions.
     95 U2edc ????						;
     96 U2edc ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2edc ????						;
     98 U2edc ????						; If ILTRACE is set then dump out the address of every
     99 U2edc ????						; IL opcode before executing it.
    100 U2edc ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2edc ????						;
    102 U2edc ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2edc ????						;
    104 U2edc ????						; If FIXED is set, put the IL code and the user
    105 U2edc ????						; program space at fixed locations in memory.	This is
    106 U2edc ????						; meant only for debugging.
    107 U2edc ????						;
    108 U2edc ????	       00 00	   FIXED      equ	FALSE
    109 U2edc ????						;
    110 U2edc ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2edc ????						; BASIC, so keep this small!
    112 U2edc ????						;
    113 U2edc ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2edc ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2edc ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2edc ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2edc ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2edc ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2edc ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2edc ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2edc ????						;
    122 U2edc ????						; Gosub entry types
    123 U2edc ????
    124 U2edc ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2edc ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2edc ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2edc ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2edc ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2edc ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2edc ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2edc ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2edc ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2edc ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2edc ????						;
    135 U2edc ????						; Common ASCII constants
    136 U2edc ????						;
    137 U2edc ????	       00 07	   BEL	      equ	$07
    138 U2edc ????	       00 08	   BS	      equ	$08
    139 U2edc ????	       00 09	   TAB	      equ	$09
    140 U2edc ????	       00 0a	   LF	      equ	$0A
    141 U2edc ????	       00 0d	   CR	      equ	$0D
    142 U2edc ????	       00 22	   quote      equ	$22
    143 U2edc ????	       00 20	   SPACE      equ	$20
    144 U2edc ????	       00 2c	   COMMA      equ	',
    145 U2edc ????	       00 3b	   SEMICOLON  equ	';
    146 U2edc ????	       00 3a	   COLON      equ	':
    147 U2edc ????	       00 24	   DOLLAR     equ	'$
    148 U2edc ????						;
    149 U2edc ????						; These are error codes
    150 U2edc ????						;
    151 U2edc ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2edc ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2edc ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2edc ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2edc ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2edc ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2edc ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2edc ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2edc ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2edc ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2edc ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2edc ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2edc ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2edc ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2edc ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2edc ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2edc ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2edc ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2edc ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2edc ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    171 U2edc ????						;
    172 U2edc ????						;=====================================================
    173 U2edc ????						; Zero page storage.
    174 U2edc ????						;
    175 U00f6 ????				      SEG.U	ZEROPAGE
    176 U0040					      org	$0040
    177 U0040
    178 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    179 U0041
    180 U0041							; The context is used to locate a task switch
    181 U0041							; it copies from here till all task fields are saved/swapped
    182 U0041							; The max number of tasks is 256 / context length
    183 U0041							; All positions POS values are plus one task table incldues
    184 U0041							; a leading status byte .
    185 U0041							;
    186 U0041		       00 41	   CONTEXT    equ	*
    187 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    188 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    189 U0043		       00 00	   ILPC       ds	2	; IL program counter
    190 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    191 U0047		       00	   ILSTACKPTR ds	1
    192 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    193 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    194 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    195 U004a		       00	   MATHSTACKPTR ds	1
    196 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    197 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    198 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    199 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    200 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    201 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    202 U004f							;
    203 U004f							; CURPTR is a pointer to curent BASIC line being
    204 U004f							; executed.  Always points to start of line, CUROFF
    205 U004f							; is the offset to the current character.
    206 U004f							; The order of these fields is important
    207 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    208 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    209 U0052							;
    210 U0052							;The order of these fields in important
    211 U0052
    212 U0052							;
    213 U0052							; R0, R1 and MQ are used for arithmetic operations and
    214 U0052							; general use.
    215 U0052							;
    216 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    217 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    218 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    219 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    220 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    221 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    222 U0056		       00 00	   MQ	      ds	2	;used for some math
    223 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    224 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    225 U0058		       00 59	   REGISTERSEND equ	*
    226 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    227 U0059
    228 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    229 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    230 U0059
    231 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    232 U005b							;
    233 U005b							; This is zero if in immediate mode, or non-zero
    234 U005b							; if currently running a program.  Any input from
    235 U005b							; the main loop clears this, and the XFER IL
    236 U005b							; statement will set it.
    237 U005b							;
    238 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    239 U005c							;
    240 U005c							; Used for line insertion/removal.
    241 U005c							;
    242 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    243 U005e
    244 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    245 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    246 U005e							;
    247 U005e		       00 00	   PrtFrom    ds	2	; FROM
    248 U0060							;
    249 U0060							;=====================================================
    250 U0060							;Pointers for memory Management
    251 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    252 U0060							; Mem block format is
    253 U0060							;	 0-1   pointer to next block for free blocks
    254 U0060							;	 0-1   for allocated blocks
    255 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    256 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    257 U0060							;	 2-3   length constant for exevy type of memory block
    258 U0060							; Memory is recombined as it is released
    259 U0060							; The memory manager is not interupted durring allocation
    260 U0060							; or freeing of memory
    261 U0060							;====================================================
    262 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    263 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    264 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    265 U0066							;
    266 U0066							;=====================================================
    267 U0066							;
    268  2532 ????				      SEG	Code
    269  0200					      org	$0200
    270  0200							;
    271  0200							; Cold start is at $0200.  Warm start is at $0203.
    272  0200							;
    273  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    274  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    275  0206							;
    276  0206							; These are the user-supplied vectors to I/O routines.
    277  0206							; If you want, you can just patch these in the binary
    278  0206							; file, but it would be better to change the source
    279  0206							; code.
    280  0206							;
    281  0206				  -	      if	KIM
    282  0206				  -OUTCH      jmp	$1ea0	;output char in A
    283  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    284  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    285  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    286  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    287  0206					      endif
    288  0206				  -	      if	XKIM
    289  0206				  -	      include	"xkim.inc"
    290  0206				  -	      SEG	Code
    291  0206				  -OUTCH      jmp	$1ea0
    292  0206				  -GETCH      jmp	xkGETCH
    293  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    294  0206				  -OUTHEX     jmp	xkPRTBYT
    295  0206				  -MONITOR    jmp	extKIM
    296  0206				  -puts       equ	putsil
    297  0206				  -BUFFER_SIZE equ	132
    298  0206					      endif
    299  0206
    300  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    302 Udf8e
    303  0206					      SEG	Code
    304  0206							;
    305  0206		       f0 0c	   OUTCH      equ	cout
    306  0206		       f0 09	   GETCH      equ	cin
    307  0206		       1d 74	   CRLF       equ	tbcrlf
    308  0206		       14 bf	   OUTHEX     equ	HexToOut
    309  0206		       f0 03	   MONITOR    equ	WARM
    310  0206		       f0 0f	   ISCHAR     equ	cstatus
    311  0206		       14 dc	   puts       equ	tbputs
    312  0206					      endif
    313  0206							;
    314  0206		       20 a3 1e    cold2      jsr	SetOutConsole
    315  0209		       20 b0 1e 	      jsr	SetInConsole
    316  020c		       20 dc 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    320  0243							;
    321  0243		       20 71 15 	      jsr	MemInit	;setup the free space available
    322  0246
    323  0246		       a9 01	   calcstack  lda	#1
    324  0248		       8d 78 26 	      sta	taskCounter	; Initialize number of tasks to 1
    325  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    326  024d		       8d 7a 25 	      sta	taskTable	; mark the main task as active
    327  0250		       20 5e 16 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    328  0253		       a9 5c		      lda	#IL&$ff
    329  0255		       85 43		      sta	ILPC
    330  0257		       a9 21		      lda	#IL>>8
    331  0259		       85 44		      sta	ILPC+1
    332  025b							;
    333  025b							;		  lda	  ProgramStart		     ; user prog
    334  025b							;		  sta	  ProgramEnd
    335  025b							;		  lda	  ProgramStart+1
    336  025b							;		  sta	  ProgramEnd+1
    337  025b							;
    338  025b							;  Init time slices defaults
    339  025b		       a9 02		      lda	#TASKCYCLESHIGH
    340  025d		       8d 77 26 	      sta	taskResetValue+1
    341  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    342  0262		       8d 76 26 	      sta	taskResetValue
    343  0265							;
    344  0265							; Initialize the pseudo-random number sequence...
    345  0265							;
    346  0265		       a9 5a		      lda	#$5a
    347  0267		       8d c2 2e 	      sta	rtemp1
    348  026a		       a9 9d		      lda	#%10011101
    349  026c		       8d c4 2e 	      sta	random
    350  026f		       a9 5b		      lda	#%01011011
    351  0271		       8d c5 2e 	      sta	random+1
    352  0274							;
    353  0274							;   Insert a Basic irq handler for the basic Language
    354  0274		       a9 81		      lda	#ServiceIrq&$ff
    355  0276		       8d 00 df 	      sta	IRQvec
    356  0279		       a9 02		      lda	#ServiceIrq>>8
    357  027b		       8d 01 df 	      sta	IRQvec+1
    358  027e		       4c a6 02 	      jmp	coldtwo
    359  0281
    360  0281							;
    361  0281							; This is the Basic IRQ handler
    362  0281		       48	   ServiceIrq pha
    363  0282		       ad 75 25 	      lda	IRQStatus
    364  0285		       f0 0a		      BEQ	RetIrq
    365  0287		       ad 76 25 	      lda	IRQPending
    366  028a		       d0 05		      bne	RetIrq
    367  028c		       a9 01		      lda	#1
    368  028e		       8d 76 25 	      sta	IRQPending
    369  0291		       68	   RetIrq     pla
    370  0292		       40		      rti
    371  0293							;
    372  0293							;
    373  0293							; This is the warm start entry point
    374  0293							;
    375  0293		       20 a3 1e    warm2      jsr	SetOutConsole
    376  0296		       20 b0 1e 	      jsr	SetInConsole
    377  0299		       20 74 1d 	      jsr	CRLF
    378  029c		       ad bf 2e 	      lda	errGoto
    379  029f		       85 43		      sta	ILPC
    380  02a1		       ad c0 2e 	      lda	errGoto+1
    381  02a4		       85 44		      sta	ILPC+1
    382  02a6							;
    383  02a6							; And continue with both starts here
    384  02a6							;
    385  02a6				   coldtwo
    386  02a6							;
    387  02a6							; The ILTrace flag is now run-time settable.
    388  02a6							;
    389  02a6		       a9 00		      lda	#ILTRACE&$ff
    390  02a8		       85 40		      sta	ILTrace
    391  02aa							;
    392  02aa
    393  02aa		       a9 00		      lda	#0
    394  02ac		       85 5b		      sta	RunMode
    395  02ae		       8d 35 2e 	      sta	LINBUF
    396  02b1
    397  02b1							; Clear everything from the stacks
    398  02b1
    399  02b1		       8d d0 2e 	      sta	taskIOPending	; No one waiting for io
    400  02b4		       8d d1 2e 	      sta	taskRDPending	; No one waiting for bg io
    401  02b7
    402  02b7		       20 d1 16 	      jsr	taskReset
    403  02ba							;
    404  02ba		       a9 35		      lda	#LINBUF&$ff
    405  02bc		       85 4f		      sta	CURPTR
    406  02be		       a9 2e		      lda	#LINBUF>>8
    407  02c0		       85 50		      sta	CURPTR+1	;fall through...
    408  02c2
    409  02c2							;=====================================================
    410  02c2							; This is the top of the IL interpreter.  This fetches
    411  02c2							; and executes the instruction currently pointed to
    412  02c2							; by ILPC and adjusts ILPC to point to the next
    413  02c2							; instruction to execute.
    414  02c2							;
    415  02c2		       ce 74 26    NextIL     dec	taskCurrentCycles
    416  02c5		       d0 03		      bne	NextIlNow
    417  02c7		       20 fa 16 	      jsr	iTaskSwitch	;check for a task switch
    418  02ca		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    419  02cc		       f0 03		      beq	NextIL2	;Skip if no bits set
    420  02ce
    421  02ce		       20 00 1e 	      jsr	dbgLine	;Print the IL trace information
    422  02d1
    423  02d1		       a4 51	   NextIL2    ldy	CUROFF
    424  02d3							;		  jsr	  SkipSpaces
    425  02d3							;		  sty	  CUROFF
    426  02d3							;Task IO Management
    427  02d3		       ad d1 2e 	      lda	taskRDPending	; if it is zero then Nothing pending
    428  02d6		       f0 08		      beq	NextILStr
    429  02d8		       20 ad 1b 	      jsr	ReadLine	; else Pending and poll keyboard
    430  02db		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    431  02dd		       ce d1 2e 	      dec	taskRDPending	; Carry is set if CR has been recieved
    432  02e0							;
    433  02e0		       20 30 1a    NextILStr  jsr	getILByte
    434  02e3							;
    435  02e3							; When the handler is called, these are the conditions
    436  02e3							; of several important items:
    437  02e3							;
    438  02e3							;    (ILPC) will point to the byte AFTER the IL
    439  02e3							;    opcode being executed.
    440  02e3							;
    441  02e3							;    (CURPTR),CUROFF will point to the start of the
    442  02e3							;    next word in the input buffer.  Ie, the next word
    443  02e3							;    in the user program.
    444  02e3							;
    445  02e3		       0a		      asl
    446  02e4		       c9 d8		      cmp	#ILTBLend-ILTBL+2
    447  02e6		       90 33		      bcc	ILgood
    448  02e8							;
    449  02e8							; This handles an illegal IL opcode.  This is serious
    450  02e8							; and there's no way to recover.
    451  02e8							;
    452  02e8		       20 dc 14    ILbad      jsr	puts
      0  02eb					      db	CR,LF
      1  02eb		       0d 0a		      .byte.b	CR,LF
      0  02ed					      db	"Illegal IL "
      1  02ed		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f8					      db	0
      1  02f8		       00		      .byte.b	0
    456  02f9							;
    457  02f9							; Well this is awkward, we need to back up the IL
    458  02f9							; by one since it no longer points to the current
    459  02f9							; opcode.
    460  02f9							;
    461  02f9		       20 3d 1a 	      jsr	decIL
    462  02fc							;
    463  02fc		       a0 00		      ldy	#0
    464  02fe		       b1 43		      lda	(ILPC),y
    465  0300		       20 bf 14 	      jsr	OUTHEX
    466  0303		       20 dc 14 	      jsr	puts
      0  0306					      db	" at ",0
      1  0306		       20 61 74 20*	      .byte.b	" at ",0
    468  030b		       a5 44		      lda	ILPC+1
    469  030d		       20 bf 14 	      jsr	OUTHEX
    470  0310		       a5 43		      lda	ILPC
    471  0312		       20 bf 14 	      jsr	OUTHEX
    472  0315		       20 74 1d 	      jsr	CRLF
    473  0318		       4c 03 f0 	      jmp	MONITOR
    474  031b							;
    475  031b							; Just jump to the address (ILPC),y.  Have to do
    476  031b							; some goofy stuff.
    477  031b							;
    478  031b		       a8	   ILgood     tay		;move index into Y
    479  031c		       b9 29 03 	      lda	ILTBL,y
    480  031f		       85 59		      sta	dpl
    481  0321		       b9 2a 03 	      lda	ILTBL+1,y
    482  0324		       85 5a		      sta	dpl+1
    483  0326		       6c 59 00 	      jmp	(dpl)	;go to handler
    484  0329							;
    485  0329							;=====================================================
    486  0329							; This is the IL jump table.  The IL opcode is
    487  0329							; mulitplied by two, then looked-up in this table.
    488  0329							; There is absolutely nothing special about the order
    489  0329							; of entries here... they all decode at exactly the
    490  0329							; same speed.	However the entry number must match the
    491  0329							; values in IL.inc.
    492  0329							;
    493  0329				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0329					      include	"ilvectortable.asm"
      1  0329					      seg	Code
      2  0329
      0  0329					      dw	iXINIT	;0
      1  0329		       37 04		      .word.w	iXINIT
      0  032b					      dw	iDONE	;1
      1  032b		       52 04		      .word.w	iDONE
      0  032d					      dw	iPRS	;2
      1  032d		       6b 04		      .word.w	iPRS
      0  032f					      dw	iPRN	;3
      1  032f		       73 04		      .word.w	iPRN
      0  0331					      dw	iSPC	;4
      1  0331		       7c 04		      .word.w	iSPC
      0  0333					      dw	iNLINE	;5
      1  0333		       1b 09		      .word.w	iNLINE
      0  0335					      dw	iNXT	;6
      1  0335		       84 04		      .word.w	iNXT
      0  0337					      dw	iXFER	;7
      1  0337		       b1 04		      .word.w	iXFER
      0  0339					      dw	iSAV	;8
      1  0339		       de 04		      .word.w	iSAV
      0  033b					      dw	iRSTR	;9
      1  033b		       24 05		      .word.w	iRSTR
      0  033d					      dw	iCMPR	;10
      1  033d		       72 05		      .word.w	iCMPR
      0  033f					      dw	iINNUM	;11
      1  033f		       f5 05		      .word.w	iINNUM
      0  0341					      dw	iFIN	;12
      1  0341		       2d 06		      .word.w	iFIN
      0  0343					      dw	iERR	;13
      1  0343		       41 06		      .word.w	iERR
      0  0345					      dw	iADD	;14
      1  0345		       b1 06		      .word.w	iADD
      0  0347					      dw	iSUB	;15
      1  0347		       c7 06		      .word.w	iSUB
      0  0349					      dw	iNEG	;16
      1  0349		       dd 06		      .word.w	iNEG
      0  034b					      dw	iMUL	;17
      1  034b		       f5 06		      .word.w	iMUL
      0  034d					      dw	iDIV	;18
      1  034d		       35 07		      .word.w	iDIV
      0  034f					      dw	iSTORE	;19
      1  034f		       8b 07		      .word.w	iSTORE
      0  0351					      dw	iIND	;20
      1  0351		       a3 07		      .word.w	iIND
      0  0353					      dw	iLST	;21
      1  0353		       11 08		      .word.w	iLST
      0  0355					      dw	iINIT	;22
      1  0355		       ff 03		      .word.w	iINIT
      0  0357					      dw	iGETLINE	;23
      1  0357		       47 08		      .word.w	iGETLINE
      0  0359					      dw	iINSRT	;24
      1  0359		       64 08		      .word.w	iINSRT
      0  035b					      dw	iRTN	;25
      1  035b		       15 09		      .word.w	iRTN
      0  035d					      dw	MONITOR	;26
      1  035d		       03 f0		      .word.w	MONITOR
      0  035f					      dw	iLIT	;27
      1  035f		       3b 09		      .word.w	iLIT
      0  0361					      dw	iCALL	;28
      1  0361		       21 09		      .word.w	iCALL
      0  0363					      dw	iJMP	;29
      1  0363		       29 09		      .word.w	iJMP
      0  0365					      dw	iVINIT	;30
      1  0365		       58 09		      .word.w	iVINIT
      0  0367					      dw	iERRGOTO	;31
      1  0367		       5e 09		      .word.w	iERRGOTO
      0  0369					      dw	iTST	;32
      1  0369		       6a 09		      .word.w	iTST
      0  036b					      dw	iTSTV	;33
      1  036b		       8f 0a		      .word.w	iTSTV
      0  036d					      dw	iTSTL	;34
      1  036d		       06 0b		      .word.w	iTSTL
      0  036f					      dw	iTSTN	;35
      1  036f		       21 0b		      .word.w	iTSTN
      0  0371					      dw	iFREE	;36
      1  0371		       d2 0b		      .word.w	iFREE
      0  0373					      dw	iRANDOM	;37
      1  0373		       db 0b		      .word.w	iRANDOM
      0  0375					      dw	iABS	;38
      1  0375		       ac 0c		      .word.w	iABS
     42  0377							;
     43  0377							; Disk functions.  There must be pointers
     44  0377							; to functions even if no disk is supported.
     45  0377							; Makes things easier in IL.inc.
     46  0377							;
     47  0377					      if	DISK_ACCESS
      0  0377					      dw	iOPENREAD	;39
      1  0377		       b4 1f		      .word.w	iOPENREAD
      0  0379					      dw	iOPENWRITE	;40
      1  0379		       15 20		      .word.w	iOPENWRITE
      0  037b					      dw	iDCLOSE	;41
      1  037b		       99 20		      .word.w	iDCLOSE
      0  037d					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037d		       27 20		      .word.w	iDGETLINE
      0  037f					      dw	iDLIST	;43 Did you remember your towel?
      1  037f		       93 20		      .word.w	iDLIST
      0  0381					      dw	iDDIR	;44
      1  0381		       6e 20		      .word.w	iDDIR
      0  0383					      dw	iRMFILE	;45
      1  0383		       03 20		      .word.w	iRMFILE
     55  0385				  -	      else
     56  0385				  -	      dw	NextIL	;39
     57  0385				  -	      dw	NextIL	;40
     58  0385				  -	      dw	NextIL	;41
     59  0385				  -	      dw	NextIL	;42
     60  0385				  -	      dw	NextIL	;43
     61  0385				  -	      dw	NextIL	;44
     62  0385				  -	      dw	NextIL	;45
     63  0385					      endif
     64  0385							;
      0  0385					      dw	iCLEARSCREEN	;46
      1  0385		       c3 1e		      .word.w	iCLEARSCREEN
      0  0387					      dw	iPOKEMEMORY	;47
      1  0387		       39 0c		      .word.w	iPOKEMEMORY
      0  0389					      dw	iPEEKMEMORY	;48
      1  0389		       4e 0c		      .word.w	iPEEKMEMORY
      0  038b					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  038b		       b1 09		      .word.w	iTSTLET
      0  038d					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038d		       36 0a		      .word.w	iTSTDONE
      0  038f					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038f		       7b 0c		      .word.w	iGETCHAR
      0  0391					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0391		       8f 0c		      .word.w	iPUTCHAR
      0  0393					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0393		       64 0c		      .word.w	iCallFunc
      0  0395					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0395		       c3 05		      .word.w	iBranch
      0  0397					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0397		       94 09		      .word.w	iTSTStr
      0  0399					      dw	iSetIrq	;56	   sets the irq handler
      1  0399		       29 0d		      .word.w	iSetIrq
      0  039b					      dw	iTstIrq	;57	   test if irq is pending
      1  039b		       98 0b		      .word.w	iTstIrq
      0  039d					      dw	iRET	;58	   return from interupt
      1  039d		       12 05		      .word.w	iRET
      0  039f					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039f		       0e 06		      .word.w	iINSTR
      0  03a1					      dw	iMOD	;60	   returns remainder of division
      1  03a1		       3e 07		      .word.w	iMOD
      0  03a3					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a3		       4e 17		      .word.w	iTaskSet
      0  03a5					      dw	iETask	;62	   Terminates a task
      1  03a5		       79 18		      .word.w	iETask
      0  03a7					      dw	iNTask	;63	   goto next task
      1  03a7		       2c 18		      .word.w	iNTask
      0  03a9					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a9		       b8 07		      .word.w	iArray
      0  03ab					      dw	iTaskKill	;65	   kill a running task
      1  03ab		       24 18		      .word.w	iTaskKill
      0  03ad					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ad		       f8 17		      .word.w	iTaskStat
      0  03af					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03af		       9a 0c		      .word.w	iHexOut
      0  03b1					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b1		       df 05		      .word.w	iReadComplete
      0  03b3					      dw	iReadStart	;69	   Called to start a background read request
      1  03b3		       d5 05		      .word.w	iReadStart
      0  03b5					      dw	iStartIO	;70	   Lock task until io complete
      1  03b5		       5c 18		      .word.w	iStartIO
      0  03b7					      dw	iEndIO	;71	   release task lock for io
      1  03b7		       62 18		      .word.w	iEndIO
      0  03b9					      dw	iLogNot	;72	   Logical not
      1  03b9		       05 0d		      .word.w	iLogNot
      0  03bb					      dw	iLogOr	;73	   Logical Or
      1  03bb		       db 0c		      .word.w	iLogOr
      0  03bd					      dw	iLogAnd	;74	   Logical And
      1  03bd		       c6 0c		      .word.w	iLogAnd
      0  03bf					      dw	iLogXor	;75	   Logical Xor
      1  03bf		       f0 0c		      .word.w	iLogXor
      0  03c1					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c1		       37 18		      .word.w	iWTASK
      0  03c3					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c3		       6d 18		      .word.w	iTASKPID
      0  03c5					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c5		       67 0d		      .word.w	iTRACEPROG
      0  03c7					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c7		       81 1d		      .word.w	idbgBasic
      0  03c9					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c9		       2f 19		      .word.w	iIPCS
      0  03cb					      dw	iIPCR	;81	   Recieve a message from a task
      1  03cb		       46 19		      .word.w	iIPCR
      0  03cd					      dw	iIPCC	;82	   Check if any message available for task
      1  03cd		       5a 19		      .word.w	iIPCC
      0  03cf					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cf		       67 19		      .word.w	iIPCIO
      0  03d1					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d1		       c6 15		      .word.w	iPushMathStack
      0  03d3					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d3		       f6 15		      .word.w	iPopMathStack
      0  03d5					      dw	iSaveMathStack	;86	   Save all math info
      1  03d5		       13 16		      .word.w	iSaveMathStack
      0  03d7					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d7		       32 16		      .word.w	iRestoreMathStack
      0  03d9					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d9		       e3 15		      .word.w	iIncParmCount
      0  03db					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03db		       99 18		      .word.w	iTaskGetMathStack
      0  03dd					      dw	iTaskEnable	;90	   enable a suspended task
      1  03dd		       c6 17		      .word.w	iTaskEnable
      0  03df					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03df		       e0 17		      .word.w	iTaskSuspend
      0  03e1					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e1		       b3 18		      .word.w	iTaskPutMathPtr
      0  03e3					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e3		       86 0a		      .word.w	iTSTVT
      0  03e5					      dw	iSetR2	;94
      1  03e5		       33 09		      .word.w	iSetR2
      0  03e7					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e7		       f0 04		      .word.w	iStk2Tmp
      0  03e9					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e9		       01 05		      .word.w	iTmp2Stk
      0  03eb					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03eb		       d2 09		      .word.w	iTSTBYTE
      0  03ed					      dw	iINCVAR	;98	   Increment variable
      1  03ed		       58 0a		      .word.w	iINCVAR
      0  03ef					      dw	iDECVAR	;99	   Decrement variable
      1  03ef		       70 0a		      .word.w	iDECVAR
      0  03f1					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f1		       c2 18		      .word.w	iSLICE
      0  03f3					      dw	iTSTB	;101	   Test if byte equals
      1  03f3		       f1 09		      .word.w	iTSTB
      0  03f5					      dw	iTSTW	;102	   Test If word equals
      1  03f5		       0c 0a		      .word.w	iTSTW
      0  03f7					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03f7		       84 13		      .word.w	iOnGoto
      0  03f9					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f9		       b5 13		      .word.w	iTSTRELOP
      0  03fb					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03fb		       aa 04		      .word.w	iRepeatLine
      0  03fd					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch is is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03fd		       dc 13		      .word.w	iTSTBRANCH
    126  03ff
------- FILE mytb.asm
    495  03ff		       03 ff	   ILTBLend   equ	*
    496  03ff							;
    497  03ff							;=====================================================
    498  03ff							;=====================================================
    499  03ff							;=====================================================
    500  03ff							; This marks the start of the handlers for IL opcodes.
    501  03ff							;=====================================================
    502  03ff							;=====================================================
    503  03ff							;=====================================================
    504  03ff							;
    505  03ff							;
    506  03ff		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    507  0401		       85 47		      sta	ILSTACKPTR
    508  0403		       85 4a		      sta	MATHSTACKPTR
    509  0405		       85 4d		      sta	GOSUBSTACKPTR
    510  0407		       a9 40		      lda	#GOSUBSTACKSIZE*4
    511  0409		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    512  040b							;
    513  040b		       ad d2 2e 	      lda	ProgramStart	;user prog
    514  040e		       85 4f		      sta	CURPTR
    515  0410		       8d 7b 25 	      sta	taskTable+1
    516  0413		       8d d4 2e 	      sta	ProgramEnd
    517  0416		       ad d3 2e 	      lda	ProgramStart+1
    518  0419		       85 50		      sta	CURPTR+1
    519  041b		       8d 7c 25 	      sta	taskTable+2
    520  041e		       8d d5 2e 	      sta	ProgramEnd+1
    521  0421		       a9 80		      lda	#TASKACTIVE
    522  0423		       8d 7a 25 	      sta	taskTable	;Mark the first slot as active
    523  0426		       a9 01		      lda	#1
    524  0428		       8d 78 26 	      sta	taskCounter	;there is always one task / Main task
    525  042b		       ad 76 26 	      lda	taskResetValue
    526  042e		       8d 74 26 	      sta	taskCurrentCycles	; set up the task switch counts
    527  0431		       ad 77 26 	      lda	taskResetValue+1
    528  0434		       8d 75 26 	      sta	taskCurrentCycles+1
    529  0437							;
    530  0437							; fall into XINIT...
    531  0437							;
    532  0437							;=====================================================
    533  0437							; This initializes for the start of the next line of
    534  0437							; BASIC text.
    535  0437							;
    536  0437		       78	   iXINIT     sei		;ensure interupts are off
    537  0438		       20 d1 16 	      jsr	taskReset	;Clear the task table
    538  043b		       8d 76 25 	      sta	IRQPending	; reset the irq pending
    539  043e		       8d 75 25 	      sta	IRQStatus	; Make sure irqs are off
    540  0441
    541  0441		       4c c2 02    goodExit   jmp	NextIL
    542  0444							;
    543  0444							;=====================================================
    544  0444							; This check if the escape key has been entered
    545  0444							; then changes out of run mode. z Set if esc found
    546  0444				   BreakSet
    547  0444		       20 0f f0 	      jsr	ISCHAR
    548  0447		       f0 06		      beq	BreakNo
    549  0449		       20 c0 1e 	      jsr	VGETCH
    550  044c		       c9 1b		      cmp	#$1B
    551  044e		       60		      rts
    552  044f				   BreakNo
    553  044f		       a9 01		      lda	#1
    554  0451		       60		      rts
    555  0452
    556  0452							;
    557  0452
    558  0452							;=====================================================
    559  0452							; Verify there is nothing else on this input line.
    560  0452							; If there is, generate an error.
    561  0452							;
    562  0452		       a4 51	   iDONE      ldy	CUROFF
    563  0454		       b1 4f		      lda	(CURPTR),y
    564  0456		       f0 10		      beq	doneadv
    565  0458		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    566  045a		       d0 05		      bne	idoneErr
    567  045c		       84 51		      sty	CUROFF
    568  045e		       4c c2 02 	      jmp	NextIL	; continue on this line
    569  0461
    570  0461				   idoneErr
    571  0461		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  0463		       a9 00		      lda	#0
    573  0465		       4c 44 06 	      jmp	iErr2
    574  0468							;
    575  0468							; Advance to the next line
    576  0468							;
    577  0468				   doneadv
    578  0468		       4c c2 02 	      jmp	NextIL
    579  046b							;
    580  046b							;=====================================================
    581  046b							; Print the string until a closing quote
    582  046b							;
    583  046b				   iPRS
    584  046b		       20 06 15 	      jsr	PrtQuoted
    585  046e		       84 51		      sty	CUROFF
    586  0470		       4c c2 02 	      jmp	NextIL
    587  0473							;
    588  0473							;=====================================================
    589  0473							; Pop the top off the stack and print it as a signed
    590  0473							; decimal number.
    591  0473							;
    592  0473				   iPRN
    593  0473		       20 bb 1c 	      jsr	popR0
    594  0476		       20 0d 14 	      jsr	PrintDecimal
    595  0479		       4c c2 02 	      jmp	NextIL
    596  047c							;
    597  047c							;=====================================================
    598  047c							; Space to next zone.	Currently the code does not
    599  047c							; keep track of which column the output is on, so
    600  047c							; just print a tab.
    601  047c							;
    602  047c				   iSPC
    603  047c		       a9 09		      lda	#TAB
    604  047e		       20 bd 1e 	      jsr	VOUTCH
    605  0481		       4c c2 02 	      jmp	NextIL
    606  0484							;
    607  0484							;=====================================================
    608  0484							; If in immediate mode, jump to the address following
    609  0484							; the NXT instruction.  Else move to the next line of
    610  0484							; user code and continue.
    611  0484							;
    612  0484		       a5 5b	   iNXT       lda	RunMode
    613  0486		       d0 03		      bne	iNxtRun	;in run mode
    614  0488							;
    615  0488							; Get address and jump to it.
    616  0488							;
    617  0488		       4c 29 09 	      jmp	iJMP
    618  048b							;
    619  048b				   iNxtRun
    620  048b		       a4 51		      ldy	CUROFF
    621  048d		       b1 4f		      lda	(CURPTR),y
    622  048f		       c9 e6		      cmp	#oColon
    623  0491		       d0 06		      bne	iNxtRunGo
    624  0493		       c8		      iny
    625  0494		       84 51		      sty	CUROFF
    626  0496		       4c a4 04 	      jmp	iNxtRun2
    627  0499
    628  0499				   iNxtRunGo
    629  0499		       20 ba 1a 	      jsr	FindNextLine
    630  049c		       20 ce 1a 	      jsr	AtEnd
    631  049f		       d0 03		      bne	iNxtRun2	;not at end
    632  04a1							;
    633  04a1							; At the end of the program.  Pretend an END statement
    634  04a1							; was found.
    635  04a1							;
    636  04a1		       4c 2d 06    iFINv      jmp	iFIN
    637  04a4							;
    638  04a4		       20 2c 1a    iNxtRun2   jsr	getILWord	;ignore next word
    639  04a7		       4c c2 02 	      jmp	NextIL
    640  04aa							;=====================================================
    641  04aa							;Repeat the same line against
    642  04aa		       a0 03	   iRepeatLine ldy	#3
    643  04ac		       84 51		      sty	CUROFF
    644  04ae		       4c c2 02 	      jmp	NextIL
    645  04b1							;
    646  04b1							;=====================================================
    647  04b1							; XFER takes the number on top of the stack and looks
    648  04b1							; for that line in the program, or the next line
    649  04b1							; higher.  Ie, if it's 1 but there is no line 1, then
    650  04b1							; find the next one after that.
    651  04b1							;
    652  04b1		       20 bb 1c    iXFER      jsr	popR0
    653  04b4		       20 75 1a 	      jsr	findLine
    654  04b7		       20 ce 1a    iXFER2     jsr	AtEnd	;at end of user program?
    655  04ba		       f0 e5		      beq	iFINv
    656  04bc		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    657  04be		       84 51		      sty	CUROFF
    658  04c0		       a9 ff		      lda	#$ff
    659  04c2		       85 5b		      sta	RunMode
    660  04c4							;
    661  04c4							; Transfer IL to STMT.  I don't like having this
    662  04c4							; hard-coded; fix it.
    663  04c4							;
    664  04c4		       a9 6a		      lda	#STMT&$ff
    665  04c6		       85 43		      sta	ILPC
    666  04c8		       a9 21		      lda	#STMT>>8
    667  04ca		       85 44		      sta	ILPC+1
    668  04cc		       4c c2 02 	      jmp	NextIL
    669  04cf							;
    670  04cf							; Run
    671  04cf							;
    672  04cf				   iXferok
    673  04cf		       a9 ff		      lda	#$ff
    674  04d1		       85 5b		      sta	RunMode	;we're running
    675  04d3							;
    676  04d3							; Need a more elegant way to do this
    677  04d3							;
    678  04d3		       a9 6a		      lda	#STMT&$ff
    679  04d5		       85 43		      sta	ILPC
    680  04d7		       a9 21		      lda	#STMT>>8
    681  04d9		       85 44		      sta	ILPC+1
    682  04db		       4c c2 02 	      jmp	NextIL
    683  04de							;
    684  04de							;=====================================================
    685  04de							; Save the pointer to the next line to the call stack.
    686  04de							;
    687  04de		       20 30 1a    iSAV       jsr	getILByte
    688  04e1		       20 43 1c 	      jsr	pushLN
    689  04e4		       b0 03		      bcs	iSAVErr
    690  04e6		       4c c2 02 	      jmp	NextIL
    691  04e9
    692  04e9		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04eb		       a9 00	   iSAVErr2   lda	#0
    694  04ed		       4c 44 06 	      jmp	iErr2
    695  04f0							;====================================================
    696  04f0							; Move stack top to and from temp area
    697  04f0				   iStk2Tmp
    698  04f0		       20 bb 1c 	      jsr	popR0
    699  04f3		       a5 52		      lda	R0
    700  04f5		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04f7		       91 41		      sta	(VARIABLES),y
    702  04f9		       c8		      iny
    703  04fa		       a5 53		      lda	R0+1
    704  04fc		       91 41		      sta	(VARIABLES),y
    705  04fe		       4c c2 02 	      jmp	NextIL
    706  0501
    707  0501		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  0503		       b1 41		      lda	(VARIABLES),y
    709  0505		       85 52		      sta	R0
    710  0507		       c8		      iny
    711  0508		       b1 41		      lda	(VARIABLES),y
    712  050a		       85 53		      sta	R0+1
    713  050c		       20 29 1c 	      jsr	pushR0
    714  050f		       4c c2 02 	      jmp	NextIL
    715  0512							;
    716  0512							;=====================================================
    717  0512							; Pop the next line from the call stack.
    718  0512							;
    719  0512		       20 6c 1c    iRET       jsr	popLN
    720  0515		       b0 d2		      bcs	iSAVErr
    721  0517		       a0 03		      ldy	#3
    722  0519		       84 51		      sty	CUROFF
    723  051b		       a9 00		      lda	#0
    724  051d		       8d 76 25 	      sta	IRQPending
    725  0520		       58		      cli
    726  0521		       4c c2 02 	      jmp	NextIL
    727  0524							;
    728  0524							;=====================================================
    729  0524							; On entry il, branch to if function
    730  0524							;	    il+1, value to be returned or not true or false
    731  0524							;
    732  0524							; Return from GOSUB function
    733  0524							;
    734  0524		       20 30 1a    iRSTR      jsr	getILByte	; get where to go if gosub is a fucntion
    735  0527		       8d ce 2e 	      sta	offset
    736  052a		       20 13 1c 	      jsr	saveIL	; for later jump if needed
    737  052d
    738  052d		       20 6c 1c 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    739  0530		       85 54		      sta	R1	; keep the type of call returning from
    740  0532		       b0 2a		      bcs	iRSTRErr	; stack underflow error possible
    741  0534
    742  0534		       20 30 1a 	      jsr	getILByte	; get if a value is being returned
    743  0537		       48		      pha		; save if a value was passed to be returned
    744  0538		       c9 00		      cmp	#0	; yes attemping to return a value
    745  053a		       f0 03		      beq	iRSTRPOP	; no value to return
    746  053c		       20 bb 1c 	      jsr	popR0	; Get the value from the stack save if needed
    747  053f				   iRSTRPOP
    748  053f		       20 fc 15 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    749  0542		       a5 54		      lda	R1	; called as a statement ?
    750  0544		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    751  0546		       f0 12		      beq	iRSTRExit
    752  0548		       68		      pla		; get back if value returned or not
    753  0549		       c9 01		      cmp	#1	; we have a value to return
    754  054b		       f0 04		      beq	iRSTRVALUE
    755  054d
    756  054d		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    757  054f		       d0 9a		      bne	iSAVErr2
    758  0551
    759  0551				   iRSTRVALUE
    760  0551		       20 29 1c 	      jsr	pushR0	; return value back to top of stack
    761  0554		       20 1e 1c 	      jsr	restoreIL	; get the correct il
    762  0557		       4c 79 0b 	      jmp	tstBranch	; And called as a function
    763  055a
    764  055a				   iRSTRExit
    765  055a		       68		      pla		; throw away the return value if provided
    766  055b		       4c c2 02 	      jmp	NextIL
    767  055e
    768  055e				   iRSTRNORETURNVALUE
    769  055e
    770  055e
    771  055e		       ad 79 25    iRSTRErr   lda	taskPtr	; Check if this is task zero
    772  0561		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    773  0563		       a5 56		      lda	MQ
    774  0565		       d0 03		      bne	taskRet
    775  0567		       20 d8 1e 	      jsr	pushFalse	; the result code by default is 0
    776  056a				   taskRet
    777  056a		       4c 79 18 	      jmp	iETask	; not task zero then do a task end instead
    778  056d				   taskZeroEnd
    779  056d		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    780  056f		       4c eb 04 	      jmp	iSAVErr2
    781  0572							;
    782  0572							;=====================================================
    783  0572							; Compare items on stack.  Okay, so on input there are
    784  0572							; three things on the stack
    785  0572							;
    786  0572							;    EXPR2 <- Top of stack
    787  0572							;    OP    <- relational operator, next on stack
    788  0572							;    EXPR1 <- last item on stack
    789  0572							;
    790  0572							; Comparison is: EXPR1 <operator> EXPR2
    791  0572							;
    792  0572							; Operator is one of...
    793  0572							;
    794  0572							;    2 is =
    795  0572							;    1 is <
    796  0572							;    3 is <=
    797  0572							;    5 is <>
    798  0572							;    4 is >
    799  0572							;    6 is >=
    800  0572							;
    801  0572							; Those are bit-mapped:
    802  0572							;
    803  0572							;    xxxxxGEL
    804  0572							;
    805  0572							;    G = Greater than
    806  0572							;    E = Equal
    807  0572							;    L = Less than
    808  0572							;
    809  0572							; If the comparison is false, do a NXT, ie, move to the
    810  0572							; next line and continue.  If true, continue executing
    811  0572							; on this line.
    812  0572							;
    813  0572		       00 01	   REL_LT     equ	%001
    814  0572		       00 02	   REL_EQUAL  equ	%010
    815  0572		       00 04	   REL_GT     equ	%100
    816  0572							;
    817  0572		       20 d3 1c    iCMPR      jsr	popR1
    818  0575		       20 ea 1c 	      jsr	popMQ	;operator in MQ
    819  0578		       20 bb 1c 	      jsr	popR0
    820  057b		       20 84 05 	      jsr	iCMPRsub
    821  057e		       20 29 1c 	      jsr	pushR0
    822  0581		       4c c2 02 	      jmp	NextIL
    823  0584							;
    824  0584							; See if they are equal or not
    825  0584							;
    826  0584				   iCMPRsub		; Called by internal functions
    827  0584
    828  0584		       a5 52		      lda	R0
    829  0586		       c5 54		      cmp	R1
    830  0588		       d0 0a		      bne	iCMPRnoteq	;try not equal
    831  058a		       a5 53		      lda	R0+1
    832  058c		       c5 55		      cmp	R1+1
    833  058e		       d0 04		      bne	iCMPRnoteq
    834  0590							;
    835  0590							; Equal, set the flag in MQ+1
    836  0590							;
    837  0590		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    838  0592		       d0 14		      bne	iCMPcom	;Exit it is equal
    839  0594							;
    840  0594							; See if EXPR1 (R0) < EXPR2 (R1)
    841  0594							; See www.6502.org/tutorials/compare_beyond.html
    842  0594							;
    843  0594				   iCMPRnoteq
    844  0594		       a5 52		      lda	R0
    845  0596		       c5 54		      cmp	R1
    846  0598		       a5 53		      lda	R0+1
    847  059a		       e5 55		      sbc	R1+1
    848  059c		       50 02		      bvc	iCMPR_2
    849  059e		       49 80		      eor	#$80
    850  05a0		       30 04	   iCMPR_2    bmi	iCMPlt
    851  05a2		       a9 04		      lda	#REL_GT
    852  05a4		       d0 02		      bne	iCMPcom
    853  05a6		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    854  05a8
    855  05a8		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    856  05aa							;
    857  05aa							; Now compare the end result with what the caller
    858  05aa							; was looking for.
    859  05aa							;
    860  05aa		       25 56		      and	MQ
    861  05ac		       f0 0c		      beq	iCMPno	; no match
    862  05ae		       a9 ff		      lda	#$FF	; true is $ffff
    863  05b0		       85 52		      sta	R0
    864  05b2		       85 53		      sta	R0+1
    865  05b4		       d0 0c		      bne	iCMPDone
    866  05b6							;
    867  05b6							; R0 > R1
    868  05b6							;
    869  05b6		       a9 04	   iCMPgt     lda	#REL_GT
    870  05b8		       d0 ee		      bne	iCMPcom
    871  05ba				   iCMPno
    872  05ba		       a9 00		      lda	#0
    873  05bc		       85 52		      sta	R0
    874  05be		       a9 00		      lda	#0
    875  05c0		       85 53		      sta	R0+1
    876  05c2
    877  05c2				   iCMPDone
    878  05c2		       60		      rts
    879  05c3
    880  05c3							;
    881  05c3							; if Not a match, so jump to the next line of code.
    882  05c3							; Branches based upon value on top of the stack
    883  05c3				   iBranch
    884  05c3		       20 bb 1c 	      jsr	popR0
    885  05c6		       a5 52		      lda	R0
    886  05c8		       05 53		      ora	R0+1
    887  05ca		       f0 03		      beq	iBranchFalse	; not true
    888  05cc		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    889  05cf							;
    890  05cf				   iBranchFalse
    891  05cf		       20 ba 1a 	      jsr	FindNextLine
    892  05d2		       4c b7 04 	      jmp	iXFER2
    893  05d5							;
    894  05d5							;=====================================================
    895  05d5							; Start a read of data in background
    896  05d5				   iReadStart
    897  05d5		       a9 3f		      lda	#'?	; Prompt with question mark
    898  05d7		       a6 01		      ldx	1	; Indicate to start read in background
    899  05d9		       20 46 1b 	      jsr	GetLine	; Call the getline to start read
    900  05dc		       4c c2 02 	      jmp	NextIL	; next instruction
    901  05df							;
    902  05df							;=====================================================
    903  05df							; Complete the read and return the curptr, curoff pointing to data
    904  05df				   iReadComplete
    905  05df		       a9 01		      lda	#GOSUB_RTN
    906  05e1		       20 43 1c 	      jsr	pushLN
    907  05e4		       90 03		      bcc	iReadOk
    908  05e6		       4c cb 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    909  05e9				   iReadOk
    910  05e9		       20 66 1b 	      jsr	ReadComplete
    911  05ec		       4c c2 02 	      jmp	NextIL
    912  05ef		       20 6c 1c 	      jsr	popLN
    913  05f2		       4c c2 02 	      jmp	NextIL
    914  05f5							;=====================================================
    915  05f5							; Get a line of text from the user, convert to a
    916  05f5							; number, leave on top of stack.
    917  05f5							;
    918  05f5				   iINNUM
    919  05f5		       a9 01		      lda	#GOSUB_RTN
    920  05f7		       20 43 1c 	      jsr	pushLN
    921  05fa		       b0 ea		      bcs	iReadErr	; Stack over flow error
    922  05fc							;
    923  05fc		       a9 3f		      lda	#'?
    924  05fe		       a2 00		      ldx	#0	;Wait for complete
    925  0600		       20 46 1b 	      jsr	GetLine
    926  0603		       20 db 1a 	      jsr	getDecimal
    927  0606		       20 29 1c 	      jsr	pushR0	;put onto stack
    928  0609		       b0 db		      bcs	iReadErr	;StackOverflow error
    929  060b							;
    930  060b		       4c 27 06 	      jmp	ExitIn
    931  060e							;
    932  060e							;=====================================================
    933  060e							; Get a line of text from the user, convert to a
    934  060e							; character value , leave on top of stack. up to 2 characters
    935  060e							;
    936  060e				   iINSTR
    937  060e		       a9 01		      lda	#GOSUB_RTN
    938  0610		       20 43 1c 	      jsr	pushLN
    939  0613		       b0 d1		      bcs	iReadErr	; Stack overflow error
    940  0615		       a9 3f		      lda	#'?
    941  0617		       a2 00		      ldx	#0	;wait for read complete
    942  0619		       20 46 1b 	      jsr	GetLine
    943  061c		       b1 4f		      lda	(CURPTR),y
    944  061e		       85 52		      sta	R0
    945  0620		       a9 00		      lda	#0
    946  0622		       85 53		      sta	R0+1
    947  0624		       20 29 1c 	      jsr	pushR0	;put onto stack
    948  0627				   ExitIn
    949  0627		       20 6c 1c 	      jsr	popLN
    950  062a		       4c c2 02 	      jmp	NextIL
    951  062d							;
    952  062d							;
    953  062d							;=====================================================
    954  062d							; Stop the currently running program.	Actually very
    955  062d							; simple to do... clear the RunMode flag, then set the
    956  062d							; ILPC to the standard handler and continue running.
    957  062d							;
    958  062d		       a9 00	   iFIN       lda	#0
    959  062f		       85 5b		      sta	RunMode
    960  0631		       20 d1 16 	      jsr	taskReset
    961  0634							;
    962  0634		       ad bf 2e 	      lda	errGoto
    963  0637		       85 43		      sta	ILPC
    964  0639		       ad c0 2e 	      lda	errGoto+1
    965  063c		       85 44		      sta	ILPC+1
    966  063e		       4c c2 02 	      jmp	NextIL
    967  0641							;
    968  0641							;=====================================================
    969  0641							; Handle the ERR opcode.  Following the instruction is
    970  0641							; a 16 bit error number.  Print an error message, and
    971  0641							; if we're in run mode, print the line number.  Stop
    972  0641							; program execution and return to the initial state.
    973  0641							;
    974  0641		       20 2c 1a    iERR       jsr	getILWord	;get err code
    975  0644							;
    976  0644							; Enter here with the error code in X (LSB) and A (MSB).
    977  0644							;
    978  0644		       86 52	   iErr2      stx	R0
    979  0646		       85 53		      sta	R0+1
    980  0648							;
    981  0648		       20 dc 14 	      jsr	puts
      0  064b					      db	CR,LF,"Error ",0
      1  064b		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    983  0654		       20 0d 14 	      jsr	PrintDecimal
    984  0657							;
    985  0657		       a5 5b		      lda	RunMode	;running?
    986  0659		       f0 3b		      beq	iERR3	;nope
    987  065b		       20 dc 14 	      jsr	puts
      0  065e					      db	" at line ",0
      1  065e		       20 61 74 20*	      .byte.b	" at line ",0
    989  0668		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    990  066a				   iErr2a
    991  066a		       b1 4f		      lda	(CURPTR),y
    992  066c		       85 52		      sta	R0
    993  066e		       c8		      iny
    994  066f		       b1 4f		      lda	(CURPTR),y
    995  0671		       85 53		      sta	R0+1
    996  0673		       20 0d 14 	      jsr	PrintDecimal
    997  0676		       20 dc 14 	      jsr	puts
      0  0679					      db	":",0
      1  0679		       3a 00		      .byte.b	":",0
    999  067b		       a9 00		      lda	#0
   1000  067d		       85 53		      sta	R0+1
   1001  067f		       a5 51		      lda	CUROFF
   1002  0681		       18		      clc
   1003  0682		       e9 03		      sbc	#3
   1004  0684		       85 52		      sta	R0
   1005  0686		       20 0d 14 	      jsr	PrintDecimal
   1006  0689		       20 dc 14 	      jsr	puts
      0  068c					      db	":",0
      1  068c		       3a 00		      .byte.b	":",0
   1008  068e		       ad 79 25 	      lda	taskPtr
   1009  0691		       85 52		      sta	R0
   1010  0693		       20 0d 14 	      jsr	PrintDecimal
   1011  0696							;
   1012  0696		       20 74 1d    iERR3      jsr	CRLF
   1013  0699		       20 c9 16 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1014  069c		       a9 00		      lda	#0
   1015  069e		       85 5b		      sta	RunMode	;fall through...
   1016  06a0							;
   1017  06a0							;=====================================================
   1018  06a0							; Reset the IL to be back at the idle loop.  Does not
   1019  06a0							; clear variables so the user can see what state
   1020  06a0							; the program is in.
   1021  06a0							;
   1022  06a0		       a9 00	   ResetIL    lda	#0
   1023  06a2		       85 47		      sta	ILSTACKPTR
   1024  06a4		       ad bf 2e 	      lda	errGoto
   1025  06a7		       85 43		      sta	ILPC
   1026  06a9		       ad c0 2e 	      lda	errGoto+1
   1027  06ac		       85 44		      sta	ILPC+1
   1028  06ae		       4c c2 02 	      jmp	NextIL
   1029  06b1
   1030  06b1							;
   1031  06b1							;=====================================================
   1032  06b1							; Pop two items off stack, add them, then place the
   1033  06b1							; result back onto the stack.
   1034  06b1							;
   1035  06b1		       20 bb 1c    iADD       jsr	popR0
   1036  06b4		       20 d3 1c 	      jsr	popR1
   1037  06b7				   iADDfast
   1038  06b7		       18		      clc
   1039  06b8		       a5 52		      lda	R0
   1040  06ba		       65 54		      adc	R1
   1041  06bc		       85 52		      sta	R0
   1042  06be		       a5 53		      lda	R0+1
   1043  06c0		       65 55		      adc	R1+1
   1044  06c2		       85 53		      sta	R0+1
   1045  06c4		       4c 2f 07 	      jmp	pushR0nextIl
   1046  06c7							;
   1047  06c7							;=====================================================
   1048  06c7							; Pop two items off the stack.  Subtract the top of
   1049  06c7							; stack from the lower entry.
   1050  06c7							;
   1051  06c7		       20 d3 1c    iSUB       jsr	popR1
   1052  06ca		       20 bb 1c 	      jsr	popR0
   1053  06cd		       38		      sec
   1054  06ce		       a5 52		      lda	R0
   1055  06d0		       e5 54		      sbc	R1
   1056  06d2		       85 52		      sta	R0
   1057  06d4		       a5 53		      lda	R0+1
   1058  06d6		       e5 55		      sbc	R1+1
   1059  06d8		       85 53		      sta	R0+1
   1060  06da		       4c 2f 07 	      jmp	pushR0nextIl
   1061  06dd							;
   1062  06dd							;=====================================================
   1063  06dd							; Negate the top of stack.
   1064  06dd							;
   1065  06dd		       20 bb 1c    iNEG       jsr	popR0
   1066  06e0		       a5 52		      lda	R0
   1067  06e2		       49 ff		      eor	#$ff
   1068  06e4		       85 52		      sta	R0
   1069  06e6		       a5 53		      lda	R0+1
   1070  06e8		       49 ff		      eor	#$ff
   1071  06ea		       85 53		      sta	R0+1
   1072  06ec		       e6 52		      inc	R0
   1073  06ee		       d0 02		      bne	iNEG2
   1074  06f0		       e6 53		      inc	R0+1
   1075  06f2		       4c 2f 07    iNEG2      jmp	pushR0nextIl
   1076  06f5							;
   1077  06f5							;=====================================================
   1078  06f5							; Multiply top two items on the stack, put the results
   1079  06f5							; on top.  This uses the algorithm documented on page
   1080  06f5							; 115 of "Microprocessor Programming for Computer
   1081  06f5							; Hobbyists" by Neill Graham.
   1082  06f5							;
   1083  06f5		       20 fb 06    iMUL       jsr	iMultiply
   1084  06f8		       4c c2 02 	      jmp	NextIL
   1085  06fb
   1086  06fb				   iMultiply
   1087  06fb		       20 bb 1c 	      jsr	popR0	;AC
   1088  06fe		       20 d3 1c 	      jsr	popR1	;OP
   1089  0701							;
   1090  0701		       a5 52		      lda	R0
   1091  0703		       85 56		      sta	MQ
   1092  0705		       a5 53		      lda	R0+1
   1093  0707		       85 57		      sta	MQ+1
   1094  0709		       a9 00		      lda	#0	;clear result
   1095  070b		       85 52		      sta	R0
   1096  070d		       85 53		      sta	R0+1
   1097  070f							;
   1098  070f		       a2 10		      ldx	#16	;number of bits in value
   1099  0711		       06 52	   multloop   asl	R0
   1100  0713		       26 53		      rol	R0+1
   1101  0715		       06 56		      asl	MQ
   1102  0717		       26 57		      rol	MQ+1
   1103  0719		       90 0d		      bcc	multno	;skip add if no carry
   1104  071b							;
   1105  071b							; Add R1 back into R0
   1106  071b							;
   1107  071b		       18		      clc
   1108  071c		       a5 52		      lda	R0
   1109  071e		       65 54		      adc	R1
   1110  0720		       85 52		      sta	R0
   1111  0722		       a5 53		      lda	R0+1
   1112  0724		       65 55		      adc	R1+1
   1113  0726		       85 53		      sta	R0+1
   1114  0728							;
   1115  0728		       ca	   multno     dex		;did all bits yet?
   1116  0729		       d0 e6		      bne	multloop
   1117  072b		       20 29 1c 	      jsr	pushR0	;OP
   1118  072e		       60		      rts
   1119  072f							;
   1120  072f				   pushR0nextIl
   1121  072f		       20 29 1c 	      jsr	pushR0	;OP
   1122  0732		       4c c2 02 	      jmp	NextIL
   1123  0735							;
   1124  0735							;=====================================================
   1125  0735							; Divide the top of stack into the next to top item.
   1126  0735							; Leave results on stack.  Taken from:
   1127  0735							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1128  0735							;
   1129  0735							; R0 = R0 / R1
   1130  0735							; Remainder is in MQ
   1131  0735							;
   1132  0735		       20 4f 07    iDIV       jsr	iDoDiv
   1133  0738		       20 3c 1d 	      jsr	RestoreSigns
   1134  073b		       4c 2f 07 	      jmp	pushR0nextIl
   1135  073e
   1136  073e		       20 4f 07    iMOD       jsr	iDoDiv
   1137  0741		       20 3c 1d 	      jsr	RestoreSigns
   1138  0744		       a5 56		      lda	MQ
   1139  0746		       85 52		      sta	R0
   1140  0748		       a5 57		      lda	MQ+1
   1141  074a		       85 53		      sta	R0+1
   1142  074c		       4c 2f 07 	      jmp	pushR0nextIl
   1143  074f
   1144  074f				   iDoDiv
   1145  074f		       20 d3 1c 	      jsr	popR1
   1146  0752		       20 bb 1c 	      jsr	popR0
   1147  0755							;
   1148  0755							; Check for divide by zero
   1149  0755							;
   1150  0755
   1151  0755				   iDivNoPop
   1152  0755		       a5 54		      lda	R1
   1153  0757		       05 55		      ora	R1+1
   1154  0759		       f0 29		      beq	divby0
   1155  075b							;
   1156  075b		       20 01 1d 	      jsr	SaveSigns
   1157  075e		       a9 00		      lda	#0	;preset remainder to 0
   1158  0760		       85 56		      sta	MQ
   1159  0762		       85 57		      sta	MQ+1
   1160  0764		       a2 10		      ldx	#16	;repeat for each bit: ...
   1161  0766				   divloop
   1162  0766		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1163  0768		       26 53		      rol	R0+1
   1164  076a		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1165  076c		       26 57		      rol	MQ+1
   1166  076e		       a5 56		      lda	MQ
   1167  0770		       38		      sec
   1168  0771		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1169  0773		       a8		      tay		;lb result -> Y, for we may need it later
   1170  0774		       a5 57		      lda	MQ+1
   1171  0776		       e5 55		      sbc	R1+1
   1172  0778		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1173  077a
   1174  077a		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1175  077c		       84 56		      sty	MQ
   1176  077e		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1177  0780
   1178  0780		       ca	   skip       dex
   1179  0781		       d0 e3		      bne	divloop
   1180  0783		       60		      rts
   1181  0784							;
   1182  0784							; Indicate divide-by-zero error
   1183  0784							;
   1184  0784		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1185  0786		       a9 00		      lda	#0
   1186  0788		       4c 44 06 	      jmp	iErr2
   1187  078b							;
   1188  078b							;=====================================================
   1189  078b							; This pops the top two items off the stack.  The top
   1190  078b							; item is a data value and the other is an ABSOLUTE address.
   1191  078b							;Save the value into that address.
   1192  078b							;
   1193  078b		       98	   iSTORE     tya
   1194  078c		       48		      pha
   1195  078d		       20 bb 1c 	      jsr	popR0	;data
   1196  0790		       20 d3 1c 	      jsr	popR1	;Storage location
   1197  0793		       a0 00		      ldy	#0
   1198  0795		       a5 52		      lda	R0
   1199  0797		       91 54		      sta	(R1),y
   1200  0799		       a5 53		      lda	R0+1
   1201  079b		       c8		      iny
   1202  079c		       91 54		      sta	(R1),y
   1203  079e		       68		      pla
   1204  079f		       a8		      tay
   1205  07a0		       4c c2 02 	      jmp	NextIL
   1206  07a3							;
   1207  07a3							;=====================================================
   1208  07a3							; Replaces the top of stack with the variable whose
   1209  07a3							; absolute address it represents.
   1210  07a3							;
   1211  07a3		       98	   iIND       tya
   1212  07a4		       48		      pha
   1213  07a5		       20 d3 1c 	      jsr	popR1
   1214  07a8		       a0 00		      ldy	#0
   1215  07aa		       b1 54		      lda	(R1),y
   1216  07ac		       85 52		      sta	R0
   1217  07ae		       c8		      iny
   1218  07af		       b1 54		      lda	(R1),y
   1219  07b1		       85 53		      sta	R0+1
   1220  07b3		       68		      pla
   1221  07b4		       a8		      tay
   1222  07b5		       4c 2f 07 	      jmp	pushR0nextIl
   1223  07b8							;
   1224  07b8							;=====================================================
   1225  07b8							; Get the array index from top of stack get Current variable
   1226  07b8							; address from next on stack, add the offset
   1227  07b8							; push the result back onto the stack
   1228  07b8				   iArray
   1229  07b8		       20 bb 1c 	      jsr	popR0	; Get the array index
   1230  07bb		       20 d3 1c 	      jsr	popR1	; Get the Variable address
   1231  07be
   1232  07be		       18		      clc		; Multiplythe value by 2
   1233  07bf		       26 52		      rol	R0	; Do the multiply
   1234  07c1		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1235  07c3		       18		      clc
   1236  07c4		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1237  07c6		       65 52		      adc	R0
   1238  07c8		       85 52		      sta	R0
   1239  07ca		       a5 55		      lda	R1+1
   1240  07cc		       65 53		      adc	R0+1
   1241  07ce		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1242  07d0		       20 29 1c 	      jsr	pushR0	; Push R0 assume it is correct
   1243  07d3
   1244  07d3		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1245  07d5		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1246  07d7		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1247  07d9		       a5 55		      lda	R1+1
   1248  07db		       c5 42		      cmp	VARIABLES+1
   1249  07dd		       d0 1c		      bne	iArrayAtTest
   1250  07df		       18		      clc
   1251  07e0		       a9 34		      lda	#52	; add the max offset that is valid
   1252  07e2		       65 54		      adc	R1	; update to be the largest offset that is valid
   1253  07e4		       85 54		      sta	R1
   1254  07e6		       a9 00		      lda	#0
   1255  07e8		       65 55		      adc	R1+1
   1256  07ea		       85 55		      sta	R1+1
   1257  07ec				   iArrayVerify 		; try to enforce some sanity to using arrays
   1258  07ec		       a5 53		      lda	R0+1
   1259  07ee		       c5 55		      cmp	R1+1
   1260  07f0		       d0 04		      bne	iArrayDecide
   1261  07f2		       a5 52		      lda	R0
   1262  07f4		       c5 54		      cmp	R1
   1263  07f6				   iArrayDecide
   1264  07f6		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1265  07f8		       4c c2 02 	      jmp	NextIL
   1266  07fb
   1267  07fb				   iArrayAtTest
   1268  07fb		       ad d6 2e 	      lda	HighMem
   1269  07fe		       85 54		      sta	R1
   1270  0800		       ad d7 2e 	      lda	HighMem+1
   1271  0803		       85 55		      sta	R1+1
   1272  0805		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1273  0807
   1274  0807							; Get here if array index is out of range
   1275  0807		       20 bb 1c    iArrayError jsr	popR0
   1276  080a		       a9 00		      lda	#0
   1277  080c		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1278  080e		       4c 44 06 	      jmp	iErr2
   1279  0811							;
   1280  0811							;=====================================================
   1281  0811							; List the current BASIC program in memory.  Uses R0,
   1282  0811							; tempIly, and dpl.
   1283  0811							;
   1284  0811		       20 a3 1e    iLST       jsr	SetOutConsole
   1285  0814		       ad d2 2e    iLST2      lda	ProgramStart
   1286  0817		       85 59		      sta	dpl
   1287  0819		       ad d3 2e 	      lda	ProgramStart+1
   1288  081c		       85 5a		      sta	dpl+1
   1289  081e							;
   1290  081e							; dpl/dph point to the current line.  See if we're at
   1291  081e							; the end of the program.
   1292  081e							;
   1293  081e		       a5 59	   iLSTloop   lda	dpl
   1294  0820		       cd d4 2e 	      cmp	ProgramEnd
   1295  0823		       d0 07		      bne	iLstNotEnd
   1296  0825		       a5 5a		      lda	dpl+1
   1297  0827		       cd d5 2e 	      cmp	ProgramEnd+1
   1298  082a		       f0 15		      beq	iLstdone
   1299  082c							;
   1300  082c		       20 2c 12    iLstNotEnd jsr	PrintProgramLine
   1301  082f							;		  ldy	  #1		  ;Change:  Skip first byte length
   1302  082f							;		  lda	  (dpl),y	  ;line number LSB
   1303  082f							;		  sta	  R0
   1304  082f							;		  iny
   1305  082f							;		  lda	  (dpl),y		 ;line number MSB
   1306  082f							;		  sta	  R0+1
   1307  082f							;		  iny
   1308  082f							;		  sty	  tempIlY
   1309  082f							;		  jsr	  PrintDecimal
   1310  082f							;		  lda	  #SPACE
   1311  082f							;		  jsr	  VOUTCH
   1312  082f							;		  ldy	  tempIlY
   1313  082f							;iLSTl2	  lda	  (dpl),y
   1314  082f							;		  beq	  iLST3 	  ;end of this line 0 value
   1315  082f							;		  sty	  tempIlY
   1316  082f							;		  jsr	  VOUTCH
   1317  082f							;		  ldy	  tempIlY
   1318  082f							;		  iny
   1319  082f							;		  bne	  iLSTl2	  ;do next char
   1320  082f							;
   1321  082f							; End of this line.  Print CR/LF, then move to the
   1322  082f							; next line.
   1323  082f							;
   1324  082f		       a0 00	   iLST3      ldy	#0	;Move to next line
   1325  0831		       b1 59		      lda	(dpl),y	;Current line length
   1326  0833		       18		      clc		;Clear the carry flag
   1327  0834							;		  tya
   1328  0834		       65 59		      adc	dpl	;Add the offset to the pointer
   1329  0836		       85 59		      sta	dpl	;Save the new value
   1330  0838		       a5 5a		      lda	dpl+1	;Next byte
   1331  083a		       69 00		      adc	#0	;ad in the carry if any
   1332  083c		       85 5a		      sta	dpl+1	;Save it
   1333  083e							;
   1334  083e							; Have to manually do CR/LF so it uses the vectored
   1335  083e							; output function.
   1336  083e							;
   1337  083e							;		  lda	  #CR
   1338  083e							;		  jsr	  VOUTCH
   1339  083e							;		  lda	  #LF
   1340  083e							;		  jsr	  VOUTCH
   1341  083e		       4c 1e 08 	      jmp	iLSTloop	;do next line
   1342  0841							;
   1343  0841		       20 a3 1e    iLstdone   jsr	SetOutConsole
   1344  0844		       4c c2 02 	      jmp	NextIL
   1345  0847							;
   1346  0847							;=====================================================
   1347  0847							; Get a line of text into LINBUF.  Terminate with a
   1348  0847							; null byte.
   1349  0847							;
   1350  0847				   iGETLINE
   1351  0847		       a9 3e		      lda	#'>	;prompt character
   1352  0849		       a6 00		      ldx	0	;Wait for read to complete
   1353  084b		       20 46 1b 	      jsr	GetLine
   1354  084e							;
   1355  084e		       a9 00		      lda	#0
   1356  0850		       85 5b		      sta	RunMode
   1357  0852				   iGetParseLine
   1358  0852							; lda	   CUROFF
   1359  0852							; pha
   1360  0852		       20 ba 0f 	      jsr	ParseInputLine
   1361  0855							; pla
   1362  0855							;  sta     CUROFF
   1363  0855		       a9 b7		      lda	#TOKENBUFFER&$FF
   1364  0857		       85 4f		      sta	CURPTR
   1365  0859		       a9 0e		      lda	#TOKENBUFFER>>8
   1366  085b		       85 50		      sta	CURPTR+1
   1367  085d		       a9 01		      lda	#1
   1368  085f		       85 51		      sta	CUROFF
   1369  0861		       4c c2 02 	      jmp	NextIL
   1370  0864							;
   1371  0864							;=====================================================
   1372  0864							; This is called when the input buffer contains a line
   1373  0864							; typed in by the user that starts with a line number.
   1374  0864							; Insert the line into the program or delete the line
   1375  0864							; if there is nothing after the line number,
   1376  0864							;
   1377  0864				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1378  0864		       ad b8 0e 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1379  0867		       85 52		      sta	R0	; place the number into R0
   1380  0869		       ad b9 0e 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1381  086c		       85 53		      STA	R0+1	; Place it into
   1382  086e							;
   1383  086e							; Now find the line OR the next higher line OR the
   1384  086e							; end of the program.
   1385  086e							;
   1386  086e		       20 75 1a 	      jsr	findLine	; Look for the line number in the current program
   1387  0871							; Returns Z and curptr point to the line if found
   1388  0871							; Returns C and curptr at next higher line if not found and there is a higher line
   1389  0871							; Returns ZC clear and curptr to end of program if higher than all other lines
   1390  0871							;
   1391  0871							; If the line exists, it needs to be removed.
   1392  0871							;
   1393  0871		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1394  0873							;
   1395  0873							; Get length of line to be removed, we fall thru to here if we find a matching line
   1396  0873							;
   1397  0873							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1398  0873		       a0 00		      ldy	#0
   1399  0875		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1400  0877		       a8		      tay
   1401  0878							;If it is equal we delete the line and replace it, get length
   1402  0878							;then adjust all program line after up or down depending on len of line
   1403  0878							;If next higher then just move everythimg down by length bytes
   1404  0878							;This call will return how many bytes in the line we found
   1405  0878		       8c cf 2e 	      sty	lineLength	;Save the length of the line we found
   1406  087b							;
   1407  087b							; Compute the new end of the program first.
   1408  087b							;
   1409  087b		       38		      sec		;Set the carry bit
   1410  087c		       ad d4 2e 	      lda	ProgramEnd	;Get low byte of program end
   1411  087f		       ed cf 2e 	      sbc	lineLength	;Subtract the length of the current line
   1412  0882		       8d d4 2e 	      sta	ProgramEnd	;save it
   1413  0885		       ad d5 2e 	      lda	ProgramEnd+1
   1414  0888		       e9 00		      sbc	#0	;Process the carry
   1415  088a		       8d d5 2e 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1416  088d							;
   1417  088d							; Copy CURPTR into R1 for working
   1418  088d							;
   1419  088d		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1420  088f		       85 54		      sta	R1
   1421  0891		       a5 50		      lda	CURPTR+1
   1422  0893		       85 55		      sta	R1+1
   1423  0895							;
   1424  0895							; See if we're at the end.
   1425  0895							;
   1426  0895		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1427  0897		       cd d4 2e 	      cmp	ProgramEnd
   1428  089a		       d0 07		      bne	InsDelLoop
   1429  089c		       a5 55		      lda	R1+1
   1430  089e		       cd d5 2e 	      cmp	ProgramEnd+1
   1431  08a1		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1432  08a3							;
   1433  08a3							; Move one byte, move to next location.
   1434  08a3							;
   1435  08a3		       ac cf 2e    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1436  08a6		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1437  08a8		       b1 54		      lda	(R1),y
   1438  08aa		       a0 00		      ldy	#0
   1439  08ac		       91 54		      sta	(R1),y
   1440  08ae		       e6 54		      inc	R1
   1441  08b0		       d0 e3		      bne	InsDelChk
   1442  08b2		       e6 55		      inc	R1+1
   1443  08b4		       4c 95 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1444  08b7							;
   1445  08b7							; Deletion is done.
   1446  08b7							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1447  08b7							;
   1448  08b7				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1449  08b7		       ad b7 0e 	      lda	TOKENBUFFER	; Get the length
   1450  08ba		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1451  08bc							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1452  08bc		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1453  08be							;
   1454  08be							; CURPTR points to where the line will be inserted.
   1455  08be							;
   1456  08be							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1457  08be		       ae b7 0e 	      ldx	TOKENBUFFER
   1458  08c1		       8e cf 2e 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1459  08c4							;
   1460  08c4		       ad d4 2e 	      lda	ProgramEnd	;Load the start address for the copy
   1461  08c7							;At this point curptr still contains the location we will insert data
   1462  08c7		       85 5c		      sta	FROM
   1463  08c9		       ad d5 2e 	      lda	ProgramEnd+1
   1464  08cc		       85 5d		      sta	FROM+1
   1465  08ce							;
   1466  08ce		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1467  08d0		       b1 5c		      lda	(FROM),y
   1468  08d2		       ac cf 2e 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1469  08d5		       91 5c		      sta	(FROM),y	;Save the new byte
   1470  08d7							;
   1471  08d7		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1472  08d9		       c5 4f		      cmp	CURPTR
   1473  08db		       d0 06		      bne	mvUpMore
   1474  08dd		       a5 5d		      lda	FROM+1
   1475  08df		       c5 50		      cmp	CURPTR+1
   1476  08e1		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1477  08e3							;
   1478  08e3							; Not done yet
   1479  08e3							;
   1480  08e3		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1481  08e5		       d0 02		      bne	mvUpMore2
   1482  08e7		       c6 5d		      dec	FROM+1
   1483  08e9		       c6 5c	   mvUpMore2  dec	FROM
   1484  08eb		       4c ce 08 	      jmp	mvup1	;Loop until everything is moved
   1485  08ee							;
   1486  08ee							; All done with copy.
   1487  08ee							;
   1488  08ee				   mvUpDone
   1489  08ee		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1490  08ef		       ad cf 2e 	      lda	lineLength	;Number of bytes to copy from line buff
   1491  08f2		       6d d4 2e 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1492  08f5		       8d d4 2e 	      sta	ProgramEnd
   1493  08f8		       ad d5 2e 	      lda	ProgramEnd+1
   1494  08fb		       69 00		      adc	#0
   1495  08fd		       8d d5 2e 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1496  0900							;
   1497  0900							;===================jlit use length before line newline
   1498  0900
   1499  0900		       a0 00		      ldy	#0	;Set offset of copy
   1500  0902							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1501  0902							;		  sta	  (CURPTR),y	  ;Store the length
   1502  0902							;		  iny
   1503  0902							;		  lda	  R0		  ;Store the line number next
   1504  0902							;		  sta	  (CURPTR),y
   1505  0902							;		  iny
   1506  0902							;		  lda	  R0+1
   1507  0902							;		  sta	  (CURPTR),y
   1508  0902							;		  iny
   1509  0902							;
   1510  0902							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1511  0902		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1512  0904				   mvUpLoop2
   1513  0904							;		  lda	  LINBUF,x	 ;get a byte
   1514  0904		       bd b7 0e 	      lda	TOKENBUFFER,x	;get a byte
   1515  0907		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1516  0909
   1517  0909		       e8		      inx
   1518  090a		       ec b7 0e 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1519  090d		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1520  090f		       c8		      iny
   1521  0910		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1522  0912							;
   1523  0912		       4c c2 02    mvUpFini   jmp	NextIL
   1524  0915							;
   1525  0915							;=====================================================
   1526  0915							; Pops the top value of the ILPC stack and stores it
   1527  0915							; in ILPC.  Ie, return from an IL subroutine.
   1528  0915							;
   1529  0915		       20 63 1a    iRTN       jsr	popILPC
   1530  0918		       4c c2 02 	      jmp	NextIL
   1531  091b							;
   1532  091b							;=====================================================
   1533  091b							; NLINE print a newline
   1534  091b							;
   1535  091b		       20 74 1d    iNLINE     jsr	CRLF	;user supplied sub
   1536  091e		       4c c2 02 	      jmp	NextIL
   1537  0921							;
   1538  0921							;=====================================================
   1539  0921							; This saves the current ILPC value on the stack, then
   1540  0921							; jumps to the address specified by the next two bytes.
   1541  0921							;
   1542  0921		       20 46 1a    iCALL      jsr	pushILPC	;save ILPC
   1543  0924		       90 03		      bcc	iJMP
   1544  0926		       4c cb 0b 	      jmp	ErrStkOver	; Check if there was an error
   1545  0929							;
   1546  0929							; Jmp to a specific location in the IL code.  The new
   1547  0929							; address immediately follows the opcode.
   1548  0929							;
   1549  0929		       20 2c 1a    iJMP       jsr	getILWord
   1550  092c		       86 43		      stx	ILPC
   1551  092e		       85 44		      sta	ILPC+1
   1552  0930		       4c c2 02 	      jmp	NextIL
   1553  0933
   1554  0933
   1555  0933							;
   1556  0933							;=====================================================
   1557  0933							; Push the next two bytes onto the arithmetic stack.
   1558  0933							;
   1559  0933		       20 30 1a    iSetR2     jsr	getILByte
   1560  0936		       85 58		      sta	R2
   1561  0938		       4c c2 02 	      jmp	NextIL
   1562  093b							;
   1563  093b							;=====================================================
   1564  093b							; Push the next two bytes onto the arithmetic stack.
   1565  093b							;
   1566  093b		       20 2c 1a    iLIT       jsr	getILWord
   1567  093e		       86 52		      stx	R0
   1568  0940		       85 53		      sta	R0+1
   1569  0942		       20 29 1c 	      jsr	pushR0
   1570  0945		       4c c2 02 	      jmp	NextIL
   1571  0948							;
   1572  0948							;=====================================================
   1573  0948							; Initialize all variables for a single task.	Ie, set to zero.
   1574  0948							;
   1575  0948		       98	   subVINIT   tya
   1576  0949		       48		      pha
   1577  094a
   1578  094a		       a9 00		      lda	#0
   1579  094c		       a0 00		      ldy	#0
   1580  094e		       91 41	   Vinit2     sta	(VARIABLES),y
   1581  0950		       c8		      iny
   1582  0951		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1583  0953		       90 f9		      bcc	Vinit2
   1584  0955
   1585  0955		       68		      pla
   1586  0956		       a8		      tay
   1587  0957		       60		      rts
   1588  0958
   1589  0958		       20 48 09    iVINIT     jsr	subVINIT
   1590  095b		       4c c2 02 	      jmp	NextIL
   1591  095e							;
   1592  095e							;=====================================================
   1593  095e							; Set the address of the error handler.  After any
   1594  095e							; error, set to the ILPC to the specified location.
   1595  095e							;
   1596  095e		       20 2c 1a    iERRGOTO   jsr	getILWord
   1597  0961		       8e bf 2e 	      stx	errGoto
   1598  0964		       8d c0 2e 	      sta	errGoto+1
   1599  0967		       4c c2 02 	      jmp	NextIL
   1600  096a							;
   1601  096a							;=====================================================
   1602  096a							; TST is followed by an 8 bit signed offset, then a
   1603  096a							; null terminated string.  Compare the string against
   1604  096a							; the string starting at (CURPTR),CUROFF.  If the
   1605  096a							; strings match, continue executing the next IL
   1606  096a							; opcode.  Else, add the offset to ILPC.
   1607  096a							;
   1608  096a		       20 30 1a    iTST       jsr	getILByte	;Get the relative jump address
   1609  096d		       8d ce 2e 	      sta	offset	;save it to use if test faile
   1610  0970		       20 13 1c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1611  0973
   1612  0973		       a4 51		      ldy	CUROFF
   1613  0975		       84 59		      sty	dpl	;save for later
   1614  0977							;
   1615  0977		       20 30 1a    iTSTloop   jsr	getILByte	;get next char
   1616  097a		       f0 11		      beq	iTSTm	;match!
   1617  097c		       a4 59		      ldy	dpl
   1618  097e		       d1 4f		      cmp	(CURPTR),y
   1619  0980		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1620  0982		       09 20		      ora	#$20	; lets allow lowercase as well
   1621  0984		       d1 4f		      cmp	(CURPTR),y
   1622  0986		       d0 23		      bne	iTSTfail	;mismatch
   1623  0988		       c8	   iTSTUpper  iny
   1624  0989		       84 59		      sty	dpl
   1625  098b		       d0 ea		      bne	iTSTloop
   1626  098d							;
   1627  098d							; It's a match!  Clean up a bit.
   1628  098d							;
   1629  098d		       a4 59	   iTSTm      ldy	dpl
   1630  098f		       84 51		      sty	CUROFF
   1631  0991		       4c c2 02 	      jmp	NextIL
   1632  0994
   1633  0994							; Test for a single quote string
   1634  0994		       20 30 1a    iTSTStr    jsr	getILByte
   1635  0997		       8d ce 2e 	      sta	offset
   1636  099a		       20 13 1c 	      jsr	saveIL
   1637  099d		       a4 51		      ldy	CUROFF
   1638  099f		       a9 22		      lda	#'"
   1639  09a1		       d1 4f		      cmp	(CURPTR),y
   1640  09a3		       d0 06		      bne	iTSTfail
   1641  09a5		       c8		      iny
   1642  09a6		       84 51		      sty	CUROFF
   1643  09a8		       4c e0 02 	      jmp	NextILStr
   1644  09ab							;
   1645  09ab							; Not a match, reset ILPC and then move to the
   1646  09ab							; offset.
   1647  09ab							;
   1648  09ab		       20 1e 1c    iTSTfail   jsr	restoreIL
   1649  09ae		       4c 79 0b 	      jmp	tstBranch
   1650  09b1							;
   1651  09b1							;=================================================JLIT=
   1652  09b1							; Test if we have a let statement without the let keyword
   1653  09b1		       20 30 1a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1654  09b4		       8d ce 2e 	      sta	offset	; Save the jump offset for fails
   1655  09b7		       20 13 1c 	      jsr	saveIL	; save to restore when done if fail
   1656  09ba
   1657  09ba		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1658  09bc		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1659  09be		       c9 01		      cmp	#kLet	; Is it a let keyword
   1660  09c0		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1661  09c2		       c9 80		      cmp	#tVa	; lets check for a variable
   1662  09c4		       90 e5		      bcc	iTSTfail	; Less than variable range
   1663  09c6		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1664  09c8		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1665  09ca		       b0 df		      bcs	iTSTfail	; return it failed
   1666  09cc
   1667  09cc				   iTSTLETGOOD
   1668  09cc		       c8		      iny
   1669  09cd		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1670  09cf				   iTSTGOODVAR
   1671  09cf		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1672  09d2
   1673  09d2							;=================================================JLIT=
   1674  09d2							; Test a byte at an indirect address
   1675  09d2							; fails if byte is not equal to the value at the address
   1676  09d2							; The tests an indirect byte and branches if true
   1677  09d2		       20 30 1a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1678  09d5		       8d ce 2e 	      sta	offset	; Save the jump offset for fails
   1679  09d8		       20 13 1c 	      jsr	saveIL	; save to restore when done if fail
   1680  09db		       20 2c 1a 	      jsr	getILWord	; Get a word into RO
   1681  09de		       86 52		      stx	R0
   1682  09e0		       85 53		      sta	R0+1
   1683  09e2		       20 30 1a 	      jsr	getILByte	; Get byte into A
   1684  09e5		       a0 00		      ldy	#0
   1685  09e7		       d1 52		      cmp	(R0),y
   1686  09e9		       d0 03		      bne	iTSTByteNotEqual
   1687  09eb		       4c ab 09 	      jmp	iTSTfail
   1688  09ee
   1689  09ee				   iTSTByteNotEqual
   1690  09ee		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1691  09f1
   1692  09f1							;=================================================JLIT=
   1693  09f1							; Test a byte	branch if it fails
   1694  09f1		       20 30 1a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1695  09f4		       8d ce 2e 	      sta	offset	; Save the jump offset for fails
   1696  09f7		       20 13 1c 	      jsr	saveIL	; save to restore when done if fail
   1697  09fa		       20 30 1a 	      jsr	getILByte	; Get a word into RO
   1698  09fd		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1699  09ff		       d1 4f		      cmp	(CURPTR),y
   1700  0a01		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1701  0a03		       4c ab 09 	      jmp	iTSTfail	; REcover and move on to next test
   1702  0a06
   1703  0a06				   iTSTBMatch
   1704  0a06		       c8		      iny
   1705  0a07		       84 51		      sty	CUROFF	; Point to the next byte
   1706  0a09		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1707  0a0c
   1708  0a0c							;=================================================JLIT=
   1709  0a0c							; Test a byte	branch if it fails
   1710  0a0c		       20 30 1a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1711  0a0f		       8d ce 2e 	      sta	offset	; Save the jump offset for fails
   1712  0a12		       20 13 1c 	      jsr	saveIL	; save to restore when done if fail
   1713  0a15		       20 2c 1a 	      jsr	getILWord	; Get a word into RO
   1714  0a18		       86 52		      stx	R0
   1715  0a1a		       85 53		      sta	R0+1
   1716  0a1c		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1717  0a1e		       8a		      txa
   1718  0a1f		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1719  0a21		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1720  0a23		       4c ab 09 	      jmp	iTSTfail	; REcover and move on to next test
   1721  0a26		       c8	   iTSTWM1    iny
   1722  0a27		       a5 53		      lda	R0+1
   1723  0a29		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1724  0a2b		       f0 03		      beq	iTSTWMatch
   1725  0a2d		       4c ab 09 	      jmp	iTSTfail
   1726  0a30
   1727  0a30				   iTSTWMatch
   1728  0a30		       c8		      iny
   1729  0a31		       84 51		      sty	CUROFF
   1730  0a33		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1731  0a36
   1732  0a36							;================================================jLIT=
   1733  0a36							;Test for end of line
   1734  0a36							;
   1735  0a36				   iTSTDONE
   1736  0a36		       20 30 1a 	      jsr	getILByte
   1737  0a39		       8d ce 2e 	      sta	offset
   1738  0a3c		       20 13 1c 	      jsr	saveIL
   1739  0a3f		       a4 51		      ldy	CUROFF
   1740  0a41		       84 59		      sty	dpl
   1741  0a43		       b1 4f		      lda	(CURPTR),y
   1742  0a45		       f0 0b		      beq	iTSTDONEtrue
   1743  0a47		       c9 e6		      cmp	#oColon
   1744  0a49		       f0 07		      beq	iTSTDONEtrue
   1745  0a4b		       a4 59		      ldy	dpl
   1746  0a4d		       84 51		      sty	CUROFF
   1747  0a4f		       4c ab 09 	      jmp	iTSTfail
   1748  0a52							;
   1749  0a52							; Advance to the next line
   1750  0a52							;
   1751  0a52				   iTSTDONEtrue
   1752  0a52		       4c c2 02 	      jmp	NextIL
   1753  0a55
   1754  0a55		       4c 79 0b    tstBranchLink jmp	tstBranch
   1755  0a58							;
   1756  0a58							;=====================================================
   1757  0a58							; Inc and dec a variable , faster than a = a + 1
   1758  0a58				   iINCVAR
   1759  0a58		       20 bb 1c 	      jsr	popR0
   1760  0a5b		       a0 00		      ldy	#0
   1761  0a5d		       18		      clc
   1762  0a5e		       a9 01		      lda	#1
   1763  0a60		       71 52		      adc	(R0),y
   1764  0a62		       91 52		      sta	(R0),y
   1765  0a64		       90 07		      bcc	iINCDONE
   1766  0a66		       c8		      iny
   1767  0a67		       a9 00		      lda	#0
   1768  0a69		       71 52		      adc	(R0),y
   1769  0a6b		       91 52		      sta	(R0),y
   1770  0a6d				   iINCDONE
   1771  0a6d		       4c c2 02 	      jmp	NextIL
   1772  0a70
   1773  0a70				   iDECVAR
   1774  0a70		       20 bb 1c 	      jsr	popR0
   1775  0a73		       a0 00		      ldy	#0
   1776  0a75		       38		      sec
   1777  0a76		       b1 52		      lda	(R0),y
   1778  0a78		       e9 01		      sbc	#1
   1779  0a7a		       91 52		      sta	(R0),y
   1780  0a7c		       c8		      iny
   1781  0a7d		       b1 52		      lda	(R0),y
   1782  0a7f		       e9 00		      sbc	#0
   1783  0a81		       91 52		      sta	(R0),y
   1784  0a83		       4c c2 02 	      jmp	NextIL
   1785  0a86
   1786  0a86
   1787  0a86							;
   1788  0a86							;=====================================================
   1789  0a86							; TSTV is followed by an 8 bit signed offset.	If the
   1790  0a86							; value at (CURPTR),CUROFF appears to be a variable
   1791  0a86							; name, move to the next IL statement.  Else, add the
   1792  0a86							; offset to ILPC. Converted to use actual absolute memory addresses
   1793  0a86							; TSTVT Looks for the task context
   1794  0a86							;
   1795  0a86		       20 d3 1c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1796  0a89		       a9 00		      lda	#0
   1797  0a8b		       85 58		      sta	R2
   1798  0a8d		       f0 04		      beq	iTSTVV
   1799  0a8f
   1800  0a8f		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1801  0a91		       85 58		      sta	R2
   1802  0a93
   1803  0a93		       20 30 1a    iTSTVV     jsr	getILByte	;offset
   1804  0a96		       8d ce 2e 	      sta	offset
   1805  0a99							;
   1806  0a99		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1807  0a9b		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1808  0a9d		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1809  0a9f		       4c 55 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1810  0aa2							;
   1811  0aa2				   iTSTVnext
   1812  0aa2		       c9 9d		      cmp	#tVat	;allow access to all unused memory as an array or integers
   1813  0aa4		       f0 42		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1814  0aa6
   1815  0aa6		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1816  0aa8		       f0 4e		      beq	iTSTVParm
   1817  0aaa
   1818  0aaa		       c9 9b		      cmp	#tVhat	; task exit code
   1819  0aac		       d0 04		      bne	iTSTV_A2Z
   1820  0aae		       a9 19		      lda	#TASKEXITCODE
   1821  0ab0		       d0 0b		      bne	iTSTVContinue
   1822  0ab2
   1823  0ab2				   iTSTV_A2Z
   1824  0ab2
   1825  0ab2		       c9 80		      cmp	#tVa
   1826  0ab4		       90 9f		      bcc	tstBranchLink
   1827  0ab6		       c9 9a		      cmp	#tVz+1
   1828  0ab8		       b0 9b		      bcs	tstBranchLink
   1829  0aba
   1830  0aba
   1831  0aba							;
   1832  0aba							; The condition is true, so convert to an index, push
   1833  0aba							; it onto the stack and continue running.
   1834  0aba							;
   1835  0aba		       29 7f		      and	#%01111111	;Mask off the high bit
   1836  0abc		       0a		      asl		;multiply by two
   1837  0abd
   1838  0abd				   iTSTVContinue
   1839  0abd		       c8		      iny
   1840  0abe		       84 51		      sty	CUROFF	;it is a valid variable
   1841  0ac0		       48		      pha
   1842  0ac1		       a5 58		      lda	R2
   1843  0ac3		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1844  0ac5
   1845  0ac5		       20 13 1a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1846  0ac8		       a0 01		      ldy	#VARIABLEPOS
   1847  0aca		       b1 56		      lda	(MQ),y
   1848  0acc		       85 52		      sta	R0
   1849  0ace		       c8		      iny
   1850  0acf		       b1 56		      lda	(MQ),y
   1851  0ad1		       85 53		      sta	R0+1
   1852  0ad3		       4c de 0a 	      jmp	iTSTVAddOffset
   1853  0ad6
   1854  0ad6				   iTSTVLocalValue
   1855  0ad6		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1856  0ad8		       85 52		      sta	R0
   1857  0ada		       a5 42		      lda	VARIABLES+1
   1858  0adc		       85 53		      sta	R0+1
   1859  0ade
   1860  0ade				   iTSTVAddOffset
   1861  0ade		       68		      pla
   1862  0adf		       85 54		      sta	R1
   1863  0ae1		       a9 00		      lda	#0
   1864  0ae3		       85 55		      sta	R1+1
   1865  0ae5
   1866  0ae5				   iTSTVcontinue
   1867  0ae5
   1868  0ae5		       4c b7 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1869  0ae8
   1870  0ae8							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1871  0ae8							; an array of integer values
   1872  0ae8				   iTSTVat
   1873  0ae8		       c8		      iny
   1874  0ae9		       84 51		      sty	CUROFF	;it is a valid variable
   1875  0aeb		       ad d4 2e 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1876  0aee		       85 52		      sta	R0
   1877  0af0		       ad d5 2e 	      lda	ProgramEnd+1
   1878  0af3		       85 53		      sta	R0+1
   1879  0af5		       4c 2f 07 	      jmp	pushR0nextIl	;place this onto the stack
   1880  0af8
   1881  0af8							; When we get parameters passed we can access them using the # variable with[]
   1882  0af8							; example #[0] #[1] etc, we dont check yet if there is too many
   1883  0af8				   iTSTVParm
   1884  0af8		       c8		      iny
   1885  0af9		       84 51		      sty	CUROFF	;it is a valid variable
   1886  0afb		       a5 48		      lda	MATHSTACK
   1887  0afd		       85 52		      sta	R0
   1888  0aff		       a5 49		      lda	MATHSTACK+1
   1889  0b01		       85 53		      sta	R0+1
   1890  0b03		       4c 2f 07 	      jmp	pushR0nextIl
   1891  0b06
   1892  0b06							;
   1893  0b06							;=====================================================
   1894  0b06							; TSTL seems basically the same as TSTN, but leave the
   1895  0b06							; value in R0 instead of pushing onto stack.
   1896  0b06							; This tests for a valid line number
   1897  0b06							;
   1898  0b06		       20 30 1a    iTSTL      jsr	getILByte
   1899  0b09		       8d ce 2e 	      sta	offset
   1900  0b0c							;
   1901  0b0c		       a4 51		      ldy	CUROFF
   1902  0b0e		       b1 4f		      lda	(CURPTR),y
   1903  0b10		       c8		      iny
   1904  0b11		       11 4f		      ora	(CURPTR),y
   1905  0b13		       f0 06		      beq	iTSTLNotLineNo
   1906  0b15
   1907  0b15
   1908  0b15							; In Both cases we need to point to the first usefull byte to process.
   1909  0b15		       c8		      iny
   1910  0b16		       84 51		      sty	CUROFF
   1911  0b18		       4c c2 02 	      jmp	NextIL
   1912  0b1b				   iTSTLNotLineNo
   1913  0b1b		       c8		      iny
   1914  0b1c		       84 51		      sty	CUROFF
   1915  0b1e		       4c 79 0b 	      jmp	tstBranch
   1916  0b21
   1917  0b21							;
   1918  0b21							;=====================================================
   1919  0b21							; TSTN checks for a number.  This is very simplistic;
   1920  0b21							; if the character is a digit, assume it's a number.
   1921  0b21							; Convert to a number and push it onto the stack.
   1922  0b21							;
   1923  0b21		       20 30 1a    iTSTN      jsr	getILByte
   1924  0b24		       8d ce 2e 	      sta	offset
   1925  0b27							;
   1926  0b27		       a9 00		      lda	#0
   1927  0b29		       85 59		      sta	dpl
   1928  0b2b		       a4 51		      ldy	CUROFF
   1929  0b2d				   chkType
   1930  0b2d		       b1 4f		      lda	(CURPTR),y
   1931  0b2f		       c9 a2		      cmp	#tByte
   1932  0b31		       f0 0e		      beq	chkByte
   1933  0b33		       c9 a1		      cmp	#tInteger
   1934  0b35		       f0 16		      beq	chkInteger
   1935  0b37		       c9 eb		      cmp	#oMinus
   1936  0b39		       d0 3e		      bne	tstBranch
   1937  0b3b		       e6 59		      inc	dpl
   1938  0b3d		       c8		      iny
   1939  0b3e		       4c 2d 0b 	      jmp	chkType
   1940  0b41
   1941  0b41				   chkByte
   1942  0b41		       a9 00		      lda	#0
   1943  0b43		       85 53		      sta	R0+1
   1944  0b45		       c8		      iny
   1945  0b46		       b1 4f		      lda	(CURPTR),y
   1946  0b48		       85 52		      sta	R0
   1947  0b4a		       c8		      iny
   1948  0b4b		       d0 0b		      bne	iTSTN_1
   1949  0b4d
   1950  0b4d				   chkInteger
   1951  0b4d		       c8		      iny
   1952  0b4e		       b1 4f		      lda	(CURPTR),y
   1953  0b50		       85 52		      sta	R0
   1954  0b52		       c8		      iny
   1955  0b53		       b1 4f		      lda	(CURPTR),y
   1956  0b55		       85 53		      sta	R0+1
   1957  0b57		       c8		      iny
   1958  0b58							;
   1959  0b58							; Check if it is negative and make it so
   1960  0b58							;
   1961  0b58				   iTSTN_1
   1962  0b58		       84 51		      sty	CUROFF
   1963  0b5a
   1964  0b5a		       a5 59		      lda	dpl
   1965  0b5c		       f0 18		      beq	iTSTN_2	;positive
   1966  0b5e							;
   1967  0b5e		       a5 52		      lda	R0
   1968  0b60		       05 53		      ora	R0+1
   1969  0b62		       f0 12		      beq	iTSTN_2	;zero
   1970  0b64
   1971  0b64							; Invert all the bits, then add one.
   1972  0b64							;
   1973  0b64		       a5 52		      lda	R0
   1974  0b66		       49 ff		      eor	#$ff
   1975  0b68		       85 52		      sta	R0
   1976  0b6a		       a5 53		      lda	R0+1
   1977  0b6c		       49 ff		      eor	#$ff
   1978  0b6e		       85 53		      sta	R0+1
   1979  0b70							;
   1980  0b70		       e6 52		      inc	R0
   1981  0b72		       d0 02		      bne	iTSTN_2
   1982  0b74		       e6 53		      inc	R0+1
   1983  0b76				   iTSTN_2
   1984  0b76		       20 2f 07 	      jsr	pushR0nextIl	;save onto stack
   1985  0b79
   1986  0b79							;
   1987  0b79							; Common jump point for all TSTx instructions that
   1988  0b79							; fail to meet the requirements.  This takes the
   1989  0b79							; offset and adds/subtracts to/from ILPC.
   1990  0b79							;
   1991  0b79		       ad ce 2e    tstBranch  lda	offset	;get signed offset
   1992  0b7c		       10 0e		      bpl	tstPositive
   1993  0b7e							;
   1994  0b7e							; Do negative branch.	Do sign extension.
   1995  0b7e							;
   1996  0b7e		       18	   tstNegative clc
   1997  0b7f		       65 43		      adc	ILPC
   1998  0b81		       85 43		      sta	ILPC
   1999  0b83							;		  bcc	  tstBothDone
   2000  0b83							;		  dec	  ILPC+1
   2001  0b83							;		  jmp	  NextIL
   2002  0b83
   2003  0b83		       a5 44		      lda	ILPC+1
   2004  0b85		       69 ff		      adc	#$ff
   2005  0b87		       85 44		      sta	ILPC+1
   2006  0b89		       4c c2 02 	      jmp	NextIL	;keep going
   2007  0b8c							;
   2008  0b8c		       18	   tstPositive clc
   2009  0b8d		       65 43		      adc	ILPC
   2010  0b8f		       85 43		      sta	ILPC
   2011  0b91		       90 02		      bcc	tstBothDone
   2012  0b93		       e6 44		      inc	ILPC+1
   2013  0b95				   tstBothDone
   2014  0b95		       4c c2 02 	      jmp	NextIL
   2015  0b98
   2016  0b98							;
   2017  0b98							;====================================================
   2018  0b98							; Test for IRQ pending, and test if a break key pressed
   2019  0b98							; Yes I know but this handles all sorts of irq/break issues
   2020  0b98							;
   2021  0b98		       20 30 1a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2022  0b9b		       8d ce 2e 	      sta	offset	; Store the not true jump address offset
   2023  0b9e		       20 44 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2024  0ba1		       d0 03		      bne	irqNo	; z not set of no break found
   2025  0ba3		       4c 2d 06 	      jmp	iFIN	; Exit out of run mode
   2026  0ba6		       ad 76 25    irqNo      lda	IRQPending
   2027  0ba9		       f0 ce		      beq	tstBranch
   2028  0bab		       c9 01		      cmp	#1	; only do this if set to first time
   2029  0bad		       d0 ca		      bne	tstBranch
   2030  0baf		       78		      sei		; disable the interupt until ireturn resets it
   2031  0bb0		       ee 76 25    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2032  0bb3		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2033  0bb5		       20 43 1c 	      jsr	pushLN	; Push the next line to be executed
   2034  0bb8		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2035  0bba		       ad 77 25 	      lda	IRQEntry	; Get the line number to branch to
   2036  0bbd		       85 4f		      sta	CURPTR	; put line number into r0
   2037  0bbf		       ad 78 25 	      lda	IRQEntry+1
   2038  0bc2		       85 50		      sta	CURPTR+1
   2039  0bc4		       a9 03		      lda	#3	; Point to first byte of program text
   2040  0bc6		       85 51		      sta	CUROFF
   2041  0bc8		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2042  0bcb
   2043  0bcb		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2044  0bcd		       a9 00		      lda	#0	; stop the execution
   2045  0bcf		       4c 44 06 	      jmp	iErr2
   2046  0bd2							;
   2047  0bd2
   2048  0bd2							;=====================================================
   2049  0bd2							; This places the number of free bytes on top of the
   2050  0bd2							; stack.
   2051  0bd2							;
   2052  0bd2		       20 96 15    iFREE      jsr	MemFree
   2053  0bd5		       20 29 1c 	      jsr	pushR0
   2054  0bd8		       4c c2 02 	      jmp	NextIL
   2055  0bdb							;
   2056  0bdb							;=====================================================
   2057  0bdb							; Generate a random number from 0-FFFF and then MOD
   2058  0bdb							; it with the value on top of stack.  Leaves number on
   2059  0bdb							; stack
   2060  0bdb							;
   2061  0bdb		       20 d3 1c    iRANDOM    jsr	popR1	;mod value
   2062  0bde							;
   2063  0bde							; If the value is zero, just return a one.
   2064  0bde							;
   2065  0bde		       a5 54		      lda	R1
   2066  0be0		       05 55		      ora	R1+1
   2067  0be2		       f0 4a		      beq	irandom1
   2068  0be4							;
   2069  0be4		       ad c5 2e 	      lda	random+1
   2070  0be7		       8d c2 2e 	      sta	rtemp1
   2071  0bea		       ad c4 2e 	      lda	random
   2072  0bed		       0a		      asl
   2073  0bee		       2e c2 2e 	      rol	rtemp1
   2074  0bf1		       0a		      asl
   2075  0bf2		       2e c2 2e 	      rol	rtemp1
   2076  0bf5		       18		      clc
   2077  0bf6		       6d c4 2e 	      adc	random
   2078  0bf9
   2079  0bf9		       48		      pha
   2080  0bfa
   2081  0bfa		       ad c2 2e 	      lda	rtemp1
   2082  0bfd		       6d c5 2e 	      adc	random+1
   2083  0c00		       8d c5 2e 	      sta	random+1
   2084  0c03
   2085  0c03		       68		      pla
   2086  0c04
   2087  0c04		       69 11		      adc	#$11
   2088  0c06		       8d c4 2e 	      sta	random
   2089  0c09		       ad c5 2e 	      lda	random+1
   2090  0c0c		       69 36		      adc	#$36
   2091  0c0e		       8d c5 2e 	      sta	random+1
   2092  0c11
   2093  0c11		       ad c4 2e 	      lda	random
   2094  0c14		       85 52		      sta	R0
   2095  0c16		       ad c5 2e 	      lda	random+1
   2096  0c19		       29 7f		      and	#$7f	;make positive
   2097  0c1b		       85 53		      sta	R0+1
   2098  0c1d							;
   2099  0c1d							; R0 contains the number and R1 contains the max value.
   2100  0c1d							;
   2101  0c1d		       20 55 07 	      jsr	iDivNoPop
   2102  0c20		       20 3c 1d 	      jsr	RestoreSigns
   2103  0c23		       a5 56		      lda	MQ
   2104  0c25		       85 52		      sta	R0
   2105  0c27		       a5 57		      lda	MQ+1
   2106  0c29		       85 53		      sta	R0+1
   2107  0c2b		       4c 2f 07 	      jmp	pushR0nextIl
   2108  0c2e				   irandom1
   2109  0c2e		       a9 00		      lda	#0
   2110  0c30		       85 53		      sta	R0+1
   2111  0c32		       a9 01		      lda	#1
   2112  0c34		       85 52		      sta	R0
   2113  0c36		       4c 2f 07 	      jmp	pushR0nextIl
   2114  0c39
   2115  0c39							; The following replaced by call to division/modulo
   2116  0c39							;iRANDOM_2	lda	R0
   2117  0c39							;		cmp	R1
   2118  0c39							;		bne	iRANDOM_1
   2119  0c39							;		lda	R0+1
   2120  0c39							;		cmp	R1+1
   2121  0c39							;		bne	iRANDOM_1	;need to subtract
   2122  0c39							;
   2123  0c39							; Subtract R1 from R0
   2124  0c39							;
   2125  0c39							;iRANDOM_sub	sec
   2126  0c39							;		lda	R0
   2127  0c39							;		sbc	R1
   2128  0c39							;		sta	R0
   2129  0c39							;		lda	R0+1
   2130  0c39							;		sbc	R1+1
   2131  0c39							;		sta	R0+1
   2132  0c39							;		jmp	iRANDOM_2
   2133  0c39							;
   2134  0c39							; See if R1 > R0.  If so, branch to subtract.
   2135  0c39							;
   2136  0c39							;iRANDOM_1	lda	R0
   2137  0c39							;		cmp	R1
   2138  0c39							;		lda	R0+1
   2139  0c39							;		sbc	R1+1
   2140  0c39							;		bvc	iRANDOM_4
   2141  0c39							;		eor	#$80
   2142  0c39							;iRANDOM_4	bpl	iRANDOM_sub
   2143  0c39							;
   2144  0c39							; All done.  Almost.  Add one, then push the result.
   2145  0c39							;
   2146  0c39							;irandom1	inc	R0
   2147  0c39							;		bne	iRANDOM_3
   2148  0c39							;		inc	R0+1
   2149  0c39							;iRANDOM_3
   2150  0c39							;		  jsr	pushR0	;return value
   2151  0c39							;		jmp	NextIL
   2152  0c39							;
   2153  0c39							; Poke a value into a memory location
   2154  0c39		       8c ca 2e    iPOKEMEMORY sty	tempy
   2155  0c3c		       20 bb 1c 	      jsr	popR0
   2156  0c3f		       20 d3 1c 	      jsr	popR1
   2157  0c42		       a0 00		      ldy	#0
   2158  0c44		       a5 52		      lda	R0
   2159  0c46		       91 54		      sta	(R1),y
   2160  0c48		       ac ca 2e 	      ldy	tempy
   2161  0c4b		       4c c2 02 	      jmp	NextIL
   2162  0c4e							;
   2163  0c4e							; Get a value from a memory location
   2164  0c4e							;
   2165  0c4e		       8c ca 2e    iPEEKMEMORY sty	tempy
   2166  0c51		       20 bb 1c 	      jsr	popR0
   2167  0c54		       a0 00		      ldy	#0
   2168  0c56		       b1 52		      lda	(R0),y
   2169  0c58		       ac ca 2e 	      ldy	tempy
   2170  0c5b		       85 52		      sta	R0
   2171  0c5d		       a9 00		      lda	#0
   2172  0c5f		       85 53		      sta	R0+1
   2173  0c61		       4c 2f 07 	      jmp	pushR0nextIl
   2174  0c64							;
   2175  0c64							; Call to address return what ever is in a to the stack
   2176  0c64							; func2 will load a value into a before the call
   2177  0c64		       20 d3 1c    iCallFunc  jsr	popR1
   2178  0c67		       a5 54		      lda	R1
   2179  0c69		       20 75 0c 	      jsr	iCallRtn
   2180  0c6c		       85 52		      sta	R0
   2181  0c6e		       a9 00		      lda	#0
   2182  0c70		       85 53		      sta	R0+1
   2183  0c72		       20 2f 07 	      jsr	pushR0nextIl
   2184  0c75				   iCallRtn
   2185  0c75		       20 bb 1c 	      jsr	popR0
   2186  0c78		       6c 52 00 	      jmp	(R0)
   2187  0c7b
   2188  0c7b
   2189  0c7b							;===========================================jlit======
   2190  0c7b							;Get a character from the terminal convert to value
   2191  0c7b							;leave the number on top of the stack
   2192  0c7b							;
   2193  0c7b				   iGETCHAR
   2194  0c7b		       20 c0 1e 	      jsr	VGETCH
   2195  0c7e					      if	CTMON65
   2196  0c7e		       48		      pha
   2197  0c7f		       20 bd 1e 	      jsr	VOUTCH	;echo echo echo
   2198  0c82		       68		      pla
   2199  0c83					      endif
   2200  0c83		       85 52		      sta	R0
   2201  0c85		       a9 00		      lda	#0
   2202  0c87		       85 53		      sta	R0+1
   2203  0c89		       20 29 1c 	      jsr	pushR0
   2204  0c8c							;
   2205  0c8c		       4c c2 02 	      jmp	NextIL
   2206  0c8f							;===========================================jusilostintim======
   2207  0c8f							;Put a character to the terminal convert to
   2208  0c8f							;
   2209  0c8f		       20 bb 1c    iPUTCHAR   jsr	popR0
   2210  0c92		       a5 52		      lda	R0
   2211  0c94		       20 bd 1e 	      jsr	VOUTCH
   2212  0c97		       4c c2 02 	      jmp	NextIL
   2213  0c9a							;=====================================================
   2214  0c9a							; Put the number on the stack out as hex, suppress leading 0
   2215  0c9a				   iHexOut
   2216  0c9a		       20 bb 1c 	      jsr	popR0
   2217  0c9d		       a5 53		      lda	R0+1
   2218  0c9f		       f0 03		      beq	iHexSecondByte
   2219  0ca1		       20 bf 14 	      jsr	OUTHEX
   2220  0ca4				   iHexSecondByte
   2221  0ca4		       a5 52		      lda	R0
   2222  0ca6		       20 bf 14 	      jsr	OUTHEX
   2223  0ca9		       4c c2 02 	      jmp	NextIL
   2224  0cac							;
   2225  0cac							;=====================================================
   2226  0cac							; Replace TOS with its absolute value.
   2227  0cac							;
   2228  0cac		       20 bb 1c    iABS       jsr	popR0
   2229  0caf		       a5 53		      lda	R0+1
   2230  0cb1		       10 10		      bpl	iABS_1	;already positive
   2231  0cb3		       49 ff		      eor	#$ff
   2232  0cb5		       85 53		      sta	R0+1
   2233  0cb7		       a5 52		      lda	R0
   2234  0cb9		       49 ff		      eor	#$ff
   2235  0cbb		       85 52		      sta	R0
   2236  0cbd		       e6 52		      inc	R0
   2237  0cbf		       d0 02		      bne	iABS_1
   2238  0cc1		       e6 53		      inc	R0+1
   2239  0cc3		       4c 2f 07    iABS_1     jmp	pushR0nextIl
   2240  0cc6
   2241  0cc6							;
   2242  0cc6							;================================================================
   2243  0cc6							; The set of logical operators
   2244  0cc6				   iLogAnd
   2245  0cc6		       20 bb 1c 	      jsr	popR0
   2246  0cc9		       20 d3 1c 	      jsr	popR1
   2247  0ccc		       a5 52		      lda	R0
   2248  0cce		       25 54		      and	R1
   2249  0cd0		       85 52		      sta	R0
   2250  0cd2		       a5 53		      lda	R0+1
   2251  0cd4		       25 55		      and	R1+1
   2252  0cd6		       85 53		      sta	R0+1
   2253  0cd8		       4c 2f 07 	      jmp	pushR0nextIl
   2254  0cdb				   iLogOr
   2255  0cdb		       20 bb 1c 	      jsr	popR0
   2256  0cde		       20 d3 1c 	      jsr	popR1
   2257  0ce1		       a5 52		      lda	R0
   2258  0ce3		       05 54		      ora	R1
   2259  0ce5		       85 52		      sta	R0
   2260  0ce7		       a5 53		      lda	R0+1
   2261  0ce9		       05 55		      ora	R1+1
   2262  0ceb		       85 53		      sta	R0+1
   2263  0ced		       4c 2f 07 	      jmp	pushR0nextIl
   2264  0cf0				   iLogXor
   2265  0cf0		       20 bb 1c 	      jsr	popR0
   2266  0cf3		       20 d3 1c 	      jsr	popR1
   2267  0cf6		       a5 52		      lda	R0
   2268  0cf8		       45 54		      eor	R1
   2269  0cfa		       85 52		      sta	R0
   2270  0cfc		       a5 53		      lda	R0+1
   2271  0cfe		       45 55		      eor	R1+1
   2272  0d00		       85 53		      sta	R0+1
   2273  0d02		       4c 2f 07 	      jmp	pushR0nextIl
   2274  0d05				   iLogNot
   2275  0d05		       20 bb 1c 	      jsr	popR0
   2276  0d08		       a5 52		      lda	R0
   2277  0d0a		       49 ff		      eor	#$FF
   2278  0d0c		       85 52		      sta	R0
   2279  0d0e		       a5 53		      lda	R0+1
   2280  0d10		       49 ff		      eor	#$FF
   2281  0d12		       85 53		      sta	R0+1
   2282  0d14		       4c 2f 07 	      jmp	pushR0nextIl
   2283  0d17
   2284  0d17				   iTruth
   2285  0d17		       a9 ff		      lda	#$FF
   2286  0d19		       85 52		      sta	R0
   2287  0d1b		       85 53		      sta	R0+1
   2288  0d1d		       4c 2f 07 	      jmp	pushR0nextIl
   2289  0d20				   iFalse
   2290  0d20		       a9 00		      lda	#$00
   2291  0d22		       85 52		      sta	R0
   2292  0d24		       85 53		      sta	R0+1
   2293  0d26		       4c 2f 07 	      jmp	pushR0nextIl
   2294  0d29
   2295  0d29							;================================================================
   2296  0d29							;Set the IRQ service rtn line number
   2297  0d29							;
   2298  0d29		       78	   iSetIrq    sei		; disable the interupts
   2299  0d2a		       a9 00		      lda	#0	; Zero the Status flag
   2300  0d2c		       8d 75 25 	      sta	IRQStatus
   2301  0d2f		       20 bb 1c 	      jsr	popR0	; get the line number
   2302  0d32		       a5 52		      lda	R0
   2303  0d34		       05 53		      ora	R0+1
   2304  0d36		       f0 22		      beq	iSetExt	; if it is zero disable all
   2305  0d38		       a9 01		      lda	#GOSUB_RTN	; default push type
   2306  0d3a		       20 43 1c 	      jsr	pushLN	; Save the current line pointer
   2307  0d3d		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2308  0d3f		       4c cb 0b 	      jmp	ErrStkOver	; Check if there was an error
   2309  0d42				   iSetIrqOk
   2310  0d42		       20 75 1a 	      jsr	findLine	; Find the IRQ func Line Pointer
   2311  0d45		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2312  0d47		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2313  0d49		       8d 78 25 	      sta	IRQEntry+1
   2314  0d4c		       a5 4f		      lda	CURPTR
   2315  0d4e		       8d 77 25 	      sta	IRQEntry
   2316  0d51		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2317  0d53		       8d 75 25 	      sta	IRQStatus
   2318  0d56		       20 6c 1c 	      jsr	popLN	; Restore the old line number
   2319  0d59		       58		      cli		; Enable the interupts
   2320  0d5a		       4c c2 02    iSetExt    jmp	NextIL
   2321  0d5d
   2322  0d5d		       20 6c 1c    iSetIrqErr jsr	popLN
   2323  0d60		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2324  0d62		       a9 00		      lda	#0
   2325  0d64		       4c 44 06 	      jmp	iErr2
   2326  0d67							;
   2327  0d67		       20 bb 1c    iTRACEPROG jsr	popR0
   2328  0d6a		       a5 52		      lda	R0
   2329  0d6c		       85 40		      sta	ILTrace
   2330  0d6e		       4c c2 02 	      jmp	NextIL
   2331  0d71
   2332  0d71							;=====================================================
   2333  0d71							; Define start of non page zero data
   2334 U2edc ????				      seg.u	TBData
   2335 U2532					      org	PROGEND
   2336 U2532							;=================================================================
   2337 U2532							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U2532					      include	"tokenizer.asm"
      1  0d71					      seg	Code
      2  0d71		       ff ff ff ff DEBUGPARSER equ	TRUE	; Print debugging information
      3  0d71
      4  0d71							; Define the types of tokens found, and identifiers
      5  0d71		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0d71		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0d71		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0d71		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0d71
     10  0d71		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0d71		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0d71		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0d71
     14  0d71
     15  0d71		       00 a0	   tString    equ	$A0	; String all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0d71		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0d71		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0d71		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0d71							; Arrays of string are arrays of pointers 2 bytes
     20  0d71		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0d71		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0d71
     23  0d71		       3c 3e	   Operators  BYTE.b	"<>"
     24  0d73		       3c 3d		      BYTE.b	"<="
     25  0d75		       3e 3d		      BYTE.b	">="
     26  0d77		       3c 00		      BYTE.b	"<",0
     27  0d79		       3d 00		      BYTE.b	"=",0
     28  0d7b		       3e 00		      BYTE.b	">",0
     29  0d7d		       2b 00		      BYTE.b	"+",0
     30  0d7f		       2d 00		      BYTE.b	"-",0
     31  0d81		       2f 00		      BYTE.b	"/",0
     32  0d83		       25 00		      BYTE.b	"%",0
     33  0d85		       2a 00		      BYTE.b	"*",0
     34  0d87		       28 00		      BYTE.b	"(",0
     35  0d89		       29 00		      BYTE.b	")",0
     36  0d8b		       2c 00		      BYTE.b	",",0
     37  0d8d		       3b 00		      BYTE.b	";",0
     38  0d8f		       5b 00		      BYTE.b	"[",0
     39  0d91		       5d 00		      BYTE.b	"]",0
     40  0d93		       3a 00		      BYTE.b	":",0
     41  0d95		       24 00		      BYTE.b	"$",0
     42  0d97		       21 00		      BYTE.b	"!",0
     43  0d99		       3f 00		      BYTE.b	"?",0
     44  0d9b		       2e 00		      BYTE.b	".",0
     45  0d9d		       00 00		      BYTE.b	0,0
     46  0d9f
     47  0d9f		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     48  0da5		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     49  0daa		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     50  0db0		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     51  0db5
     52  0db5		       00 0b	   oQuestion  equ	kPrint
     53  0db5
     54  0db5		       00 f1	   oLess      equ	$F1
     55  0db5		       00 f2	   oEqual     equ	$F2
     56  0db5		       00 f3	   oLessEqual equ	$F3
     57  0db5		       00 f4	   oGreater   equ	$F4
     58  0db5		       00 f5	   oNotEqual  equ	$F5
     59  0db5		       00 f6	   oGreaterEqual equ	$F6
     60  0db5
     61  0db5		       00 e0	   oLeftBracket equ	$E0
     62  0db5		       00 e1	   oRightBracket equ	$E1
     63  0db5		       00 e2	   oComma     equ	$E2
     64  0db5		       00 e3	   oSemiColon equ	$E3
     65  0db5		       00 e4	   oLeftSQBracket equ	$E4
     66  0db5		       00 e5	   oRightSQBracket equ	$E5
     67  0db5		       00 e6	   oColon     equ	$E6
     68  0db5		       00 e7	   oDollar    equ	$E7
     69  0db5		       00 e8	   oBang      equ	$E8
     70  0db5		       00 e9	   oPeriod    equ	$E9
     71  0db5
     72  0db5
     73  0db5		       00 ea	   oPlus      equ	$EA
     74  0db5		       00 eb	   oMinus     equ	$EB
     75  0db5		       00 ec	   oDivide    equ	$EC
     76  0db5		       00 ed	   oModulo    equ	$ED
     77  0db5		       00 ee	   oMultiply  equ	$EE
     78  0db5
     79  0db5		       00 ed	   oPercent   equ	oModulo
     80  0db5
     81  0db5		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     82  0db5
     83  0db5		       00 ff	   tError     equ	$FF	; Error should never happen
     84  0db5							;============================================================================================
     85  0db5							; Keyword and seperator values
     86  0db5				   '
     87  0db5		       00 01	   kBeginKey  equ	kLet
     88  0db5							;
     89  0db5		       00 01	   kLet       equ	1
     90  0db5		       00 02	   kInc       equ	kLet+1
     91  0db5		       00 03	   kDec       equ	kInc+1
     92  0db5		       00 04	   kIreturn   equ	kDec+1
     93  0db5		       00 05	   kIf	      equ	kIreturn+1
     94  0db5		       00 06	   kThen      equ	kIf+1
     95  0db5		       00 07	   kGoto      equ	kThen+1
     96  0db5		       00 08	   kGosub     equ	kGoto+1
     97  0db5		       00 09	   kReturn    equ	kGosub+1
     98  0db5		       00 0a	   kRem       equ	kReturn+1
     99  0db5		       00 0b	   kPrint     equ	kRem+1
    100  0db5		       00 0c	   kTaske     equ	kPrint+1
    101  0db5		       00 0d	   kTaskn     equ	kTaske+1
    102  0db5		       00 0e	   kTaskw     equ	kTaskn+1
    103  0db5		       00 0f	   kPoke      equ	kTaskw+1
    104  0db5		       00 10	   kPutch     equ	kPoke+1
    105  0db5		       00 11	   kCls       equ	kPutch+1
    106  0db5		       00 12	   kInput     equ	kCls+1
    107  0db5		       00 13	   kEnd       equ	kInput+1
    108  0db5		       00 14	   kIrq       equ	kEnd+1
    109  0db5		       00 15	   kKill      equ	kIrq+1
    110  0db5		       00 16	   kList      equ	kKill+1
    111  0db5		       00 17	   kRun       equ	kList+1
    112  0db5		       00 18	   kNew       equ	kRun+1
    113  0db5		       00 19	   kSlice     equ	kNew+1
    114  0db5		       00 1a	   kTrace     equ	kSlice+1
    115  0db5		       00 1b	   kExit      equ	kTrace+1
    116  0db5		       00 1c	   kSave      equ	kExit+1
    117  0db5		       00 1d	   kLoad      equ	kSave+1
    118  0db5		       00 1e	   kErase     equ	kLoad+1
    119  0db5		       00 1f	   kDir       equ	kErase+1
    120  0db5							;
    121  0db5							; End of actual key words
    122  0db5							;
    123  0db5		       00 1e	   kKeyCount  equ	kDir-kBeginKey
    124  0db5							;
    125  0db5							; Logical operators
    126  0db5							;
    127  0db5		       00 20	   kNot       equ	kDir+1
    128  0db5		       00 21	   kOr	      equ	kNot+1
    129  0db5		       00 22	   kXor       equ	kOr+1
    130  0db5		       00 23	   kAnd       equ	kXor+1
    131  0db5
    132  0db5							; numeric functions
    133  0db5							;
    134  0db5		       00 24	   kBeginFunc equ	kTrue
    135  0db5							;
    136  0db5							; Truth operators
    137  0db5							;
    138  0db5		       00 24	   kTrue      equ	kAnd+1
    139  0db5		       00 25	   kFalse     equ	kTrue+1
    140  0db5							; Functions
    141  0db5		       00 26	   kFree      equ	kFalse+1
    142  0db5		       00 27	   kGetch     equ	kFree+1
    143  0db5		       00 28	   kPeek      equ	kGetch+1
    144  0db5		       00 29	   kTask      equ	kPeek+1
    145  0db5		       00 2a	   kIpcc      equ	kTask+1
    146  0db5		       00 2b	   kIpcs      equ	kIpcc+1
    147  0db5		       00 2c	   kIpcr      equ	kIpcs+1
    148  0db5		       00 2d	   kRnd       equ	kIpcr+1
    149  0db5		       00 2e	   kStat      equ	kRnd+1
    150  0db5		       00 2f	   kAbs       equ	kStat+1
    151  0db5		       00 30	   kCall      equ	kAbs+1
    152  0db5		       00 31	   kGofn      equ	kCall+1
    153  0db5		       00 32	   kPid       equ	kGofn+1
    154  0db5							;
    155  0db5		       00 0e	   kFuncCount equ	kPid - kBeginFunc
    156  0db5
    157  0db5							;
    158  0db5							; Keyword table contains 49 keywords
    159  0db5				   KeyWordTable
      0  0db5					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0db5		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0db9					      db	kInc,"inC"
      1  0db9		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0dbd					      db	kDec,"deC"
      1  0dbd		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0dc1					      db	kIreturn,"ireturN"
      1  0dc1		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0dc9					      db	kIf,"iF"
      1  0dc9		       05 69 46 	      .byte.b	kIf,"iF"
      0  0dcc					      db	kThen,"theN"
      1  0dcc		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0dd1					      db	kGoto,"gotO"
      1  0dd1		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0dd6					      db	kGosub,"gosuB"
      1  0dd6		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0ddc					      db	kReturn,"returN"
      1  0ddc		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0de3					      db	kRem,"reM"
      1  0de3		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0de7					      db	kPrint,"prinT"
      1  0de7		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0ded					      db	kTaske,"taskE"
      1  0ded		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0df3					      db	kTaskn,"taskN"
      1  0df3		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0df9					      db	kTaskw,"taskW"
      1  0df9		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0dff					      db	kPoke,"pokE"
      1  0dff		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0e04					      db	kPutch,"putcH"
      1  0e04		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0e0a					      db	kCls,"clS"
      1  0e0a		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0e0e					      db	kInput,"inpuT"
      1  0e0e		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0e14					      db	kEnd,"enD"
      1  0e14		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0e18					      db	kIrq,"irQ"
      1  0e18		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0e1c					      db	kKill,"kilL"
      1  0e1c		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0e21					      db	kList,"lisT"
      1  0e21		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0e26					      db	kRun,"ruN"
      1  0e26		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0e2a					      db	kNew,"neW"
      1  0e2a		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0e2e					      db	kSlice,"slicE"
      1  0e2e		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0e34					      db	kTrace,"tracE"
      1  0e34		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0e3a					      db	kExit,"exiT"
      1  0e3a		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0e3f					      db	kSave,"savE"
      1  0e3f		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0e44					      db	kLoad,"loaD"
      1  0e44		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0e49					      db	kErase,"erasE"
      1  0e49		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0e4f					      db	kDir,"diR"
      1  0e4f		       1f 64 69 52	      .byte.b	kDir,"diR"
    191  0e53							;Short form for statements:
      0  0e53					      db	kIreturn,"ireT"
      1  0e53		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0e58					      db	kReturn,"reT"
      1  0e58		       09 72 65 54	      .byte.b	kReturn,"reT"
    194  0e5c
    195  0e5c							;Logical and truth operators
      0  0e5c					      db	kNot,"noT"
      1  0e5c		       20 6e 6f 54	      .byte.b	kNot,"noT"
      0  0e60					      db	kOr,"oR"
      1  0e60		       21 6f 52 	      .byte.b	kOr,"oR"
      0  0e63					      db	kXor,"xoR"
      1  0e63		       22 78 6f 52	      .byte.b	kXor,"xoR"
      0  0e67					      db	kAnd,"anD"
      1  0e67		       23 61 6e 44	      .byte.b	kAnd,"anD"
    200  0e6b							; Truth values
      0  0e6b					      db	kTrue,"truE"
      1  0e6b		       24 74 72 75*	      .byte.b	kTrue,"truE"
      0  0e70					      db	kFalse,"falsE"
      1  0e70		       25 66 61 6c*	      .byte.b	kFalse,"falsE"
    203  0e76
    204  0e76							;functions returning values
    205  0e76
      0  0e76					      db	kFree,"freE"
      1  0e76		       26 66 72 65*	      .byte.b	kFree,"freE"
      0  0e7b					      db	kGetch,"getcH"
      1  0e7b		       27 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0e81					      db	kPeek,"peeK"
      1  0e81		       28 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0e86					      db	kTask,"tasK"
      1  0e86		       29 74 61 73*	      .byte.b	kTask,"tasK"
      0  0e8b					      db	kIpcc,"ipcC"
      1  0e8b		       2a 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0e90					      db	kIpcs,"ipcS"
      1  0e90		       2b 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0e95					      db	kIpcr,"ipcR"
      1  0e95		       2c 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0e9a					      db	kRnd,"rnD"
      1  0e9a		       2d 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0e9e					      db	kStat,"staT"
      1  0e9e		       2e 73 74 61*	      .byte.b	kStat,"staT"
      0  0ea3					      db	kAbs,"abS"
      1  0ea3		       2f 61 62 53	      .byte.b	kAbs,"abS"
      0  0ea7					      db	kCall,"calL"
      1  0ea7		       30 63 61 6c*	      .byte.b	kCall,"calL"
      0  0eac					      db	kGofn,"gofN"
      1  0eac		       31 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0eb1					      db	kPid,"piD"
      1  0eb1		       32 70 69 44	      .byte.b	kPid,"piD"
      0  0eb5					      db	0,0
      1  0eb5		       00 00		      .byte.b	0,0
    220  0eb7
    221  0eb7		       0e b7	   KeyWordTableEnd equ	*
    222  0eb7		       01 02	   KeyWordTableLength equ	* - KeyWordTable
    223  0eb7		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    224  0fb7		       00 00 00    printStorage ds	3
    225  0fba							;==================================================================================================================
    226  0fba							; Read accross the inputline and output to TOKENBUFFER
    227  0fba							; Format   byte      Description
    228  0fba							;	     0	      length of line 1-255
    229  0fba							;	    0-1       Line Number
    230  0fba							;	    Tokens and litteral values encoded into the line
    231  0fba							;
    232  0fba							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    233  0fba							;  if fails then test for keywords
    234  0fba							;  if fails then test for variables and arrays
    235  0fba							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    236  0fba
    237  0fba				   ParseInputLine
    238  0fba					      if	DEBUGPARSER
    239  0fba		       20 f1 1e 	      jsr	SetOutDebug
    240  0fbd		       20 81 11 	      jsr	DebugClearBuffer
    241  0fc0					      endif
    242  0fc0		       a5 51		      lda	CUROFF
    243  0fc2		       48		      pha
    244  0fc3		       8a		      txa
    245  0fc4		       48		      pha
    246  0fc5		       98		      tya
    247  0fc6		       48		      pha
    248  0fc7		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    249  0fc9		       20 db 1a 	      jsr	getDecimal	; Check for a line number, none is ok too
    250  0fcc		       84 51		      sty	CUROFF
    251  0fce		       20 f8 11 	      jsr	R02TOKEN	; Move R0 to token buffer
    252  0fd1
    253  0fd1				   ParseInputLoop
    254  0fd1		       a4 51		      ldy	CUROFF
    255  0fd3		       20 6b 1d 	      jsr	SkipSpaces	; Skip any spaces
    256  0fd6		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    257  0fd8		       b9 35 2e 	      lda	LINBUF,y	; Check for end of line
    258  0fdb		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    259  0fdd
    260  0fdd				   ParseForNumber
    261  0fdd		       20 e2 10 	      jsr	ParseNumeric	; Check for a numeric value
    262  0fe0		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    263  0fe2
    264  0fe2				   ParseForString
    265  0fe2		       20 b8 10 	      jsr	ParseString	; Check for a string
    266  0fe5		       90 ea		      bcc	ParseInputLoop	; It was a string
    267  0fe7
    268  0fe7				   ParseForOp
    269  0fe7		       20 20 11 	      jsr	ParseForOperator	; Check for operator or punctuation
    270  0fea		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    271  0fec
    272  0fec				   ParseForKey
    273  0fec		       20 19 10 	      jsr	ParseLookupKey	; Check for a keyword value
    274  0fef		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    275  0ff1
    276  0ff1				   ParseForVar
    277  0ff1		       20 c1 11 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    278  0ff4		       90 db		      bcc	ParseInputLoop
    279  0ff6
    280  0ff6				   ParseKeepChar		; if it does not parse just keep it safe
    281  0ff6		       b9 35 2e 	      lda	LINBUF,y
    282  0ff9		       9d b7 0e 	      sta	TOKENBUFFER,x
    283  0ffc		       e8		      inx
    284  0ffd		       c8		      iny
    285  0ffe		       84 51		      sty	CUROFF
    286  1000		       d0 cf		      bne	ParseInputLoop
    287  1002
    288  1002				   ParseComplete
    289  1002		       a9 00		      lda	#0
    290  1004		       9d b7 0e 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    291  1007		       e8		      inx
    292  1008		       8e b7 0e 	      stx	TOKENBUFFER	; Place size including null into buffer start
    293  100b
    294  100b		       68		      pla
    295  100c		       a8		      tay
    296  100d		       68		      pla
    297  100e		       aa		      tax
    298  100f		       68		      pla
    299  1010		       85 51		      sta	CUROFF
    300  1012
    301  1012					      if	DEBUGPARSER
    302  1012
    303  1012		       20 93 11 	      jsr	printTokenBuffer
    304  1015							;jsr	  DebugPrintProgramLine
    305  1015		       20 1f 1f 	      jsr	SetOutDebugEnd
    306  1018
    307  1018					      endif
    308  1018		       60		      rts
    309  1019
    310  1019							;==================================================================================================================
    311  1019							; Look at curptr, curpos and check for a valid KeyWord
    312  1019							; A contains the index value. c is clear
    313  1019							;		     not found c set  A undefined
    314  1019							; X is prerserved
    315  1019							;
    316  1019				   ParseLookupKey
    317  1019		       86 58		      stx	R2
    318  101b		       a0 00		      ldy	#0
    319  101d		       a9 b5		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    320  101f		       85 54		      sta	R1
    321  1021		       a9 0d		      lda	#KeyWordTable>>8
    322  1023		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    323  1025		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    324  1027		       85 52		      sta	R0	; Save until next keyword
    325  1029		       c8		      iny		; Point to first character of keyword
    326  102a		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    327  102c
    328  102c					      if	DEBUGPARSER
    329  102c							;    jsr DebugKeyword
    330  102c					      endif
    331  102c
    332  102c				   ParseLookupLoop
    333  102c		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    334  102e		       29 df		      and	#%11011111	; Force Keyword to upper case
    335  1030		       dd 35 2e 	      cmp	LINBUF,x	; Check the input buffer
    336  1033		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    337  1035		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    338  1037		       dd 35 2e 	      cmp	LINBUF,x	; Compare value to upercase
    339  103a		       d0 30		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    340  103c
    341  103c				   ParseNextLetter
    342  103c		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    343  103e		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    344  1040		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    345  1042		       e8		      inx		; Point to next char in the input buffer
    346  1043		       c8		      iny		; Point to the next character in the Keyword table
    347  1044		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    348  1046		       dd 35 2e 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    349  1049		       f0 21		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    350  104b		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    351  104d
    352  104d				   ParseKeyFound
    353  104d		       a5 52		      lda	R0	; get the keyword index
    354  104f
    355  104f				   ParseKeyDone
    356  104f		       e8		      inx		; point past the last character
    357  1050		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    358  1052		       a6 58		      ldx	R2	; Restore the original x pointer
    359  1054		       9d b7 0e 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    360  1057		       e8		      inx		; Point to next position in the output buffer
    361  1058		       86 58		      stx	R2	; Save next position in buffer
    362  105a		       c9 0a		      cmp	#kRem	; remark statement
    363  105c		       f0 36		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    364  105e		       c9 07		      cmp	#kGoto
    365  1060		       f0 46		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    366  1062		       c9 08		      cmp	#kGosub
    367  1064		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    368  1066		       c9 31		      cmp	#kGofn
    369  1068		       f0 3e		      beq	ParseHandleBranches	; Handle the gosub branch address
    370  106a
    371  106a		       18		      clc		; C flag clear, we found it
    372  106b		       60		      rts
    373  106c
    374  106c							; Move forward to the next entry in table
    375  106c				   ParseNextEntry
    376  106c		       b1 54		      lda	(R1),y	; Get the next character in the token
    377  106e		       29 20		      and	#%00100000	; Is it the last character
    378  1070		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    379  1072		       c8		      iny		; Point to next char in the entry
    380  1073		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    381  1075
    382  1075				   ParseEndOfEntry
    383  1075		       c8		      iny		; Point to the byte after the last character
    384  1076		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    385  1077		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    386  1078		       65 54		      adc	R1
    387  107a		       85 54		      sta	R1
    388  107c		       a5 55		      lda	R1+1
    389  107e		       69 00		      adc	#0
    390  1080		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    391  1082		       a0 00		      ldy	#0	; Reset the index back to zero
    392  1084		       b1 54		      lda	(R1),y	; get keyword value
    393  1086		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    394  1088		       85 52		      sta	R0	; save the next token value
    395  108a		       c8		      iny		; Inc past token value
    396  108b
    397  108b					      if	DEBUGPARSER
    398  108b							;    jsr DebugKeyword
    399  108b					      endif
    400  108b		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    401  108d		       4c 2c 10 	      jmp	ParseLookupLoop	; branch back for next key word
    402  1090
    403  1090				   ParseNoneFound
    404  1090		       a6 58		      ldx	R2	; it did not faind one, restore x to position in output buffer
    405  1092		       38		      sec		; c clear, not found
    406  1093		       60		      rts
    407  1094
    408  1094							;===============================================================================
    409  1094							; Move everything from current position until the end of line into the token buffer
    410  1094							;
    411  1094		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    412  1096		       a6 58		      ldx	R2	; where to place in the buffer
    413  1098				   ParseMoveLoop
    414  1098		       b9 35 2e 	      lda	LINBUF,y	; get the next byte
    415  109b		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    416  109d		       9d b7 0e 	      sta	TOKENBUFFER,x	; save the byte
    417  10a0		       c8		      iny
    418  10a1		       e8		      inx
    419  10a2		       d0 f4		      bne	ParseMoveLoop
    420  10a4				   ParseMoveDone
    421  10a4		       84 51		      sty	CUROFF
    422  10a6		       18		      clc
    423  10a7		       60		      rts
    424  10a8							;================================================================================================
    425  10a8							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    426  10a8							; transfer to a memory address
    427  10a8				   ParseHandleBranches
    428  10a8		       a6 58		      ldx	R2
    429  10aa		       a9 00		      lda	#0
    430  10ac		       9d b7 0e 	      sta	TOKENBUFFER,x
    431  10af		       e8		      inx
    432  10b0		       9d b7 0e 	      sta	TOKENBUFFER,x
    433  10b3		       e8		      inx
    434  10b4		       86 58		      stx	R2
    435  10b6		       18		      clc
    436  10b7		       60		      rts
    437  10b8
    438  10b8							;=========================================================================================================
    439  10b8							;ParseString Parse a quotes string
    440  10b8							; on input X = outbuf position
    441  10b8							; y = inbuf position
    442  10b8							; Copies string to output buffer, updates x and y
    443  10b8				   ParseString
    444  10b8		       a4 51		      ldy	CUROFF
    445  10ba		       a9 a0		      lda	#tString
    446  10bc		       9d b7 0e 	      sta	TOKENBUFFER,X
    447  10bf		       b9 35 2e 	      lda	LINBUF,y
    448  10c2		       c9 22		      cmp	#'"
    449  10c4		       d0 1a		      bne	ParseStringInvalid
    450  10c6		       e8		      inx
    451  10c7		       9d b7 0e 	      sta	TOKENBUFFER,x
    452  10ca		       e8		      inx
    453  10cb		       c8		      iny
    454  10cc
    455  10cc				   ParseStringLoop
    456  10cc		       b9 35 2e 	      lda	LINBUF,y
    457  10cf		       9d b7 0e 	      sta	TOKENBUFFER,x
    458  10d2		       c9 22		      cmp	#'"
    459  10d4		       f0 04		      beq	ParseStringDone
    460  10d6		       c8		      iny
    461  10d7		       e8		      inx
    462  10d8		       d0 f2		      bne	ParseStringLoop
    463  10da
    464  10da				   ParseStringDone
    465  10da		       e8		      inx
    466  10db		       c8		      iny
    467  10dc		       84 51		      sty	CUROFF
    468  10de		       18		      clc
    469  10df		       60		      rts
    470  10e0
    471  10e0				   ParseStringInvalid
    472  10e0		       38		      sec
    473  10e1		       60		      rts
    474  10e2
    475  10e2							;=========================================================================================================
    476  10e2							; Get numeric values and return value in RO and type in a
    477  10e2							;
    478  10e2				   ParseNumeric
    479  10e2		       a4 51		      ldy	CUROFF
    480  10e4		       b9 35 2e 	      lda	LINBUF,y
    481  10e7		       c9 30		      cmp	#'0
    482  10e9		       90 33		      bcc	ParseNumInvalid
    483  10eb		       c9 3a		      cmp	#'9+1
    484  10ed		       b0 2f		      bcs	ParseNumInvalid
    485  10ef		       86 58		      stx	R2
    486  10f1		       20 db 1a 	      jsr	getDecimal
    487  10f4		       a6 58		      ldx	R2
    488  10f6		       84 51		      sty	CUROFF
    489  10f8		       a5 53		      lda	R0+1
    490  10fa		       f0 14		      beq	ParseByteValue
    491  10fc
    492  10fc				   ParseIntegerValue
    493  10fc		       a9 a1		      lda	#tInteger
    494  10fe		       9d b7 0e 	      sta	TOKENBUFFER,x
    495  1101		       e8		      inx
    496  1102		       a5 52		      lda	R0
    497  1104		       9d b7 0e 	      sta	TOKENBUFFER,x
    498  1107		       e8		      inx
    499  1108		       a5 53		      lda	R0+1
    500  110a		       9d b7 0e 	      sta	TOKENBUFFER,X
    501  110d		       e8		      inx
    502  110e		       18		      clc
    503  110f		       60		      rts
    504  1110
    505  1110				   ParseByteValue
    506  1110		       a9 a2		      lda	#tByte
    507  1112		       9d b7 0e 	      sta	TOKENBUFFER,x
    508  1115		       e8		      inx
    509  1116		       a5 52		      lda	R0
    510  1118		       9d b7 0e 	      sta	TOKENBUFFER,x
    511  111b		       e8		      inx
    512  111c		       18		      clc
    513  111d		       60		      rts
    514  111e
    515  111e				   ParseNumInvalid		;Not a valid Numeric
    516  111e		       38		      sec
    517  111f		       60		      rts
    518  1120
    519  1120							;=========================================================================================================
    520  1120							;Parse for operators and seperators
    521  1120							; on exit the A has the oper code, c is clear
    522  1120							;		 not found then c is set
    523  1120							;	x is preserved
    524  1120							;
    525  1120				   ParseForOperator
    526  1120		       86 58		      stx	R2
    527  1122		       a4 51		      ldy	CUROFF
    528  1124		       a2 00		      ldx	#0
    529  1126					      if	DEBUGPARSER
    530  1126							;	jsr    DebugPrintOP
    531  1126					      endif
    532  1126
    533  1126				   ParseOpLoop
    534  1126		       bd 71 0d 	      lda	Operators,x	; First byte of operator
    535  1129		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    536  112b
    537  112b		       d9 35 2e 	      cmp	LINBUF,y	; Check the first byte
    538  112e		       d0 1c		      bne	ParseOpNext
    539  1130
    540  1130		       c8		      iny
    541  1131
    542  1131		       bd 72 0d 	      lda	Operators+1,x
    543  1134		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    544  1136
    545  1136		       d9 35 2e 	      cmp	LINBUF,y
    546  1139		       d0 11		      bne	ParseOpNext
    547  113b
    548  113b				   ParseOpFound
    549  113b		       c8		      iny
    550  113c
    551  113c				   ParseOpFoundSingle
    552  113c		       84 51		      sty	CUROFF
    553  113e
    554  113e		       8a		      txa
    555  113f		       4a		      lsr
    556  1140		       aa		      tax
    557  1141		       bd 9f 0d 	      lda	OperValues,x
    558  1144		       a6 58		      ldx	R2
    559  1146		       9d b7 0e 	      sta	TOKENBUFFER,x
    560  1149		       e8		      inx
    561  114a		       18		      clc
    562  114b		       60		      rts
    563  114c
    564  114c				   ParseOpNext
    565  114c		       e8		      inx
    566  114d		       e8		      inx
    567  114e
    568  114e					      if	DEBUGPARSER
    569  114e							;	 jsr	DebugPrintOP
    570  114e					      endif
    571  114e		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    572  1150		       4c 26 11 	      jmp	ParseOpLoop
    573  1153
    574  1153				   ParseOpNotFound
    575  1153		       a6 58		      ldx	R2
    576  1155		       38		      sec
    577  1156		       60		      rts
    578  1157							;=========================================================================================================
    579  1157					      if	DEBUGPARSER
    580  1157							;Print the text of a keyword
    581  1157							;Input R1    = offset into table
    582  1157				   DebugKeyword
    583  1157		       98		      tya
    584  1158		       48		      pha
    585  1159		       a0 01		      ldy	#1
    586  115b				   DebugKeyLoop
    587  115b		       b1 54		      lda	(R1),y
    588  115d		       20 bd 1e 	      jsr	VOUTCH
    589  1160		       29 20		      and	#%00100000
    590  1162		       f0 03		      beq	DebugKeyDone
    591  1164		       c8		      iny
    592  1165		       d0 f4		      bne	DebugKeyLoop
    593  1167
    594  1167				   DebugKeyDone
    595  1167		       20 74 1d 	      jsr	CRLF
    596  116a		       68		      pla
    597  116b		       a8		      tay
    598  116c		       60		      rts
    599  116d							;========================================
    600  116d				   DebugPrintOP
    601  116d		       48		      pha
    602  116e		       bd 71 0d 	      lda	Operators,x
    603  1171		       20 bd 1e 	      jsr	VOUTCH
    604  1174		       bd 72 0d 	      lda	Operators+1,x
    605  1177		       f0 03		      beq	DbgPrtOpDone
    606  1179		       20 bd 1e 	      jsr	VOUTCH
    607  117c
    608  117c				   DbgPrtOpDone
    609  117c		       20 74 1d 	      jsr	CRLF
    610  117f		       68		      pla
    611  1180		       60		      rts
    612  1181							;=======================================
    613  1181				   DebugClearBuffer
    614  1181		       8a		      txa
    615  1182		       48		      pha
    616  1183		       a2 ff		      ldx	#$FF
    617  1185		       a9 00		      lda	#0
    618  1187				   DebugClrLoop
    619  1187		       9d b7 0e 	      sta	TOKENBUFFER,x
    620  118a		       ca		      dex
    621  118b		       d0 fa		      bne	DebugClrLoop
    622  118d		       9d b7 0e 	      sta	TOKENBUFFER,x
    623  1190		       68		      pla
    624  1191		       aa		      tax
    625  1192		       60		      rts
    626  1193
    627  1193							;=====================================================
    628  1193							; Print the parser buffer as hex values
    629  1193				   printTokenBuffer
    630  1193		       8e b7 0f 	      stx	printStorage
    631  1196		       8c b8 0f 	      sty	printStorage+1
    632  1199		       8d b9 0f 	      sta	printStorage+2
    633  119c
    634  119c		       ae b7 0e 	      ldx	TOKENBUFFER	; get the length of the buffer
    635  119f		       e8		      inx		; we want to show the last zero byte
    636  11a0		       a0 00		      ldy	#0
    637  11a2
    638  11a2				   printHexLoop
    639  11a2		       b9 b7 0e 	      lda	TOKENBUFFER,y	; get the character
    640  11a5		       20 bf 14 	      jsr	HexToOut	; print it
    641  11a8		       a9 20		      lda	#$20
    642  11aa		       20 bd 1e 	      jsr	VOUTCH
    643  11ad		       c8		      iny
    644  11ae		       ca		      dex
    645  11af		       e0 00		      cpx	#0
    646  11b1		       d0 ef		      bne	printHexLoop
    647  11b3		       20 74 1d 	      jsr	CRLF
    648  11b6
    649  11b6		       ac b8 0f 	      ldy	printStorage+1
    650  11b9		       ae b7 0f 	      ldx	printStorage
    651  11bc		       ad b9 0f 	      lda	printStorage+2
    652  11bf				   printHexDone
    653  11bf		       18		      clc
    654  11c0		       60		      rts
    655  11c1					      endif
    656  11c1
    657  11c1
    658  11c1							;=========================================================================================================
    659  11c1							; Parse for variables A-Z @, ^  x!x x[op]
    660  11c1				   ParseForVariable
    661  11c1		       a4 51		      ldy	CUROFF
    662  11c3		       b9 35 2e 	      lda	LINBUF,y
    663  11c6		       c9 5e		      cmp	#'^	; is it an exit code
    664  11c8		       d0 04		      bne	ParseVarMem
    665  11ca		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    666  11cc		       d0 1f		      bne	ParseVarSpecial
    667  11ce
    668  11ce				   ParseVarMem
    669  11ce		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    670  11d0		       d0 04		      bne	ParseVarStack
    671  11d2		       a9 9d		      lda	#tVat
    672  11d4		       d0 17		      bne	ParseVarSpecial
    673  11d6
    674  11d6				   ParseVarStack
    675  11d6		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    676  11d8		       d0 04		      bne	ParseVarLetters
    677  11da		       a9 9c		      lda	#tVhash
    678  11dc		       d0 0f		      bne	ParseVarSpecial
    679  11de
    680  11de				   ParseVarLetters
    681  11de		       29 df		      and	#%11011111	; Force upper case
    682  11e0		       c9 41		      cmp	#'A
    683  11e2		       90 12		      bcc	ParseVarInvalid
    684  11e4		       c9 5b		      cmp	#'Z+1
    685  11e6		       b0 0e		      bcs	ParseVarInvalid
    686  11e8							;
    687  11e8							; The condition is true, so convert to an index, push
    688  11e8							; it onto the stack and continue running.
    689  11e8							;
    690  11e8		       38		      sec
    691  11e9		       e9 41		      sbc	#'A	;index is zero based
    692  11eb		       09 80		      ora	#$80
    693  11ed
    694  11ed				   ParseVarSpecial
    695  11ed		       9d b7 0e 	      sta	TOKENBUFFER,x
    696  11f0		       e8		      inx
    697  11f1		       c8		      iny
    698  11f2		       84 51		      sty	CUROFF
    699  11f4		       18		      clc
    700  11f5		       60		      rts
    701  11f6
    702  11f6				   ParseVarInvalid
    703  11f6		       38		      sec
    704  11f7		       60		      rts
    705  11f8
    706  11f8
    707  11f8							;=========================================================================================================
    708  11f8							; Transfer R0 to the TOKENBUFFER
    709  11f8							;
    710  11f8				   R02TOKEN
    711  11f8		       a5 52		      lda	R0
    712  11fa		       9d b7 0e 	      sta	TOKENBUFFER,x
    713  11fd		       e8		      inx
    714  11fe		       a5 53		      lda	R0+1
    715  1200		       9d b7 0e 	      sta	TOKENBUFFER,x
    716  1203		       e8		      inx
    717  1204		       18		      clc
    718  1205		       60		      rts
    719  1206							;=========================================================================
    720  1206							; Transfer word in Token Buffer to R0
    721  1206				   TOKEN2R0
    722  1206		       b9 b7 0e 	      lda	TOKENBUFFER,y
    723  1209		       85 52		      sta	R0
    724  120b		       c8		      iny
    725  120c		       ca		      dex
    726  120d		       b9 b7 0e 	      lda	TOKENBUFFER,y
    727  1210		       c8		      iny
    728  1211		       ca		      dex
    729  1212		       85 53		      sta	R0+1
    730  1214		       60		      rts
    731  1215							;==========================================================================
    732  1215							; Transfer	Display Buffer position to R0
    733  1215							;
    734  1215				   DPL2R0
    735  1215		       b1 59		      lda	(dpl),y
    736  1217		       85 52		      sta	R0
    737  1219		       c8		      iny
    738  121a		       ca		      dex
    739  121b		       b1 59		      lda	(dpl),y
    740  121d		       c8		      iny
    741  121e		       ca		      dex
    742  121f		       85 53		      sta	R0+1
    743  1221		       60		      rts
    744  1222
    745  1222							;==========================================================================================================
    746  1222							;Debug   Print a Program Line from compile buffer
    747  1222							;
    748  1222				   DebugPrintProgramLine
    749  1222		       48		      pha
    750  1223		       a9 b7		      lda	#TOKENBUFFER&$FF
    751  1225		       85 59		      sta	dpl
    752  1227		       a9 0e		      lda	#TOKENBUFFER>>8
    753  1229		       85 5a		      sta	dpl+1
    754  122b		       68		      pla
    755  122c
    756  122c							; Decode and print a line of program text
    757  122c							; on entry	 dpl points to line of code to print
    758  122c							; on exit	 no change in reg of dpl
    759  122c							;
    760  122c				   PrintProgramLine
    761  122c
    762  122c		       8e b7 0f 	      stx	printStorage
    763  122f		       8c b8 0f 	      sty	printStorage+1
    764  1232		       48		      pha
    765  1233
    766  1233		       a0 01		      ldy	#1	; index into the token buffer
    767  1235		       84 58		      sty	R2	; print unsigned decimal
    768  1237		       a0 00		      ldy	#0
    769  1239		       b1 59		      lda	(dpl),y	; get number of bytes
    770  123b		       aa		      tax		; place pointer into x
    771  123c		       c8		      iny
    772  123d		       ca		      dex		; Deduct the length byte
    773  123e		       20 15 12 	      jsr	DPL2R0	; Print the line number
    774  1241		       20 0d 14 	      jsr	PrintDecimal
    775  1244		       a9 20		      lda	#$20
    776  1246		       20 bd 1e 	      jsr	VOUTCH
    777  1249
    778  1249				   PrintProgLoop
    779  1249		       b1 59		      lda	(dpl),y	; Get a character
    780  124b		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    781  124d		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    782  124f		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    783  1251
    784  1251				   PrintProgVars
    785  1251		       b1 59		      lda	(dpl),y
    786  1253		       29 e0		      and	#$E0	; Check for operators and punctuation
    787  1255		       c9 e0		      cmp	#$E0
    788  1257		       f0 6b		      beq	PrintProgOperatorVect
    789  1259
    790  1259		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    791  125b		       c9 9e		      cmp	#$9D+1
    792  125d		       90 62		      bcc	PrintProgVariableVec
    793  125f		       29 a0		      and	#$A0	; Check for a valid datatype
    794  1261		       c9 a0		      cmp	#$A0
    795  1263		       f0 06		      beq	PrintDataType	; if not just print the character
    796  1265		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    797  1267		       ca		      dex		; Ok we are processing it
    798  1268		       c8		      iny
    799  1269		       d0 25		      bne	PrintContinue	; Print and do the next character
    800  126b
    801  126b				   PrintDataType
    802  126b		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    803  126d		       c9 a0		      cmp	#tString
    804  126f		       f0 31		      beq	PrintStringVariable
    805  1271
    806  1271				   PrintProgNumber
    807  1271		       c8		      iny		; we have a numerical integer value
    808  1272		       ca		      dex
    809  1273		       48		      pha
    810  1274		       a9 00		      lda	#0
    811  1276		       85 53		      sta	R0+1
    812  1278		       85 58		      sta	R2	; Set to print signed number
    813  127a		       b1 59		      lda	(dpl),y
    814  127c		       85 52		      sta	R0
    815  127e		       68		      pla
    816  127f		       c9 a1		      cmp	#tInteger
    817  1281		       d0 06		      bne	PrintProgNumDone
    818  1283		       c8		      iny
    819  1284		       ca		      dex
    820  1285		       b1 59		      lda	(dpl),y
    821  1287		       85 53		      sta	R0+1
    822  1289
    823  1289				   PrintProgNumDone
    824  1289		       c8		      iny
    825  128a		       ca		      dex
    826  128b		       20 0d 14 	      jsr	PrintDecimal
    827  128e
    828  128e				   PrintProgNext
    829  128e		       a9 20		      lda	#$20
    830  1290				   PrintContinue
    831  1290		       20 bd 1e 	      jsr	VOUTCH
    832  1293				   PrintProgSkipSpace
    833  1293		       e0 00		      cpx	#0
    834  1295		       d0 b2		      bne	PrintProgLoop
    835  1297				   PrintProgramComplete
    836  1297		       20 74 1d 	      jsr	CRLF
    837  129a
    838  129a		       ae b7 0f 	      ldx	printStorage
    839  129d		       ac b8 0f 	      ldy	printStorage+1
    840  12a0		       68		      pla
    841  12a1
    842  12a1		       60		      rts
    843  12a2							;=================================================================================================================
    844  12a2							; Print a string variable including the quotes
    845  12a2							; On Input	 y is offset into buffer
    846  12a2							; On Exit	 y is updated to new offset
    847  12a2
    848  12a2				   PrintStringVariable
    849  12a2		       c8		      iny
    850  12a3		       a9 22		      lda	#'"
    851  12a5		       20 bd 1e 	      jsr	VOUTCH
    852  12a8		       c8		      iny
    853  12a9		       a5 59		      lda	dpl
    854  12ab		       85 5e		      sta	PrtFrom
    855  12ad		       a5 5a		      lda	dpl+1
    856  12af		       85 5f		      sta	PrtFrom+1
    857  12b1		       a9 22		      lda	#'"
    858  12b3		       8d ca 2e 	      sta	PrtTerm
    859  12b6		       20 2a 15 	      jsr	PrtLoop
    860  12b9		       a9 22		      lda	#'"
    861  12bb		       20 bd 1e 	      jsr	VOUTCH
    862  12be		       4c 8e 12 	      jmp	PrintProgNext
    863  12c1
    864  12c1				   PrintProgVariableVec
    865  12c1		       4c 5d 13 	      jmp	PrintProgVariable
    866  12c4
    867  12c4				   PrintProgOperatorVect
    868  12c4		       4c 34 13 	      jmp	PrintProgOperator
    869  12c7							;===============================================================================================================
    870  12c7							; On entry dpl points to the buffer we are printing from
    871  12c7							;	    y	current offset into the dpl buffer
    872  12c7							; all registers preserved
    873  12c7							;
    874  12c7				   PrintKeyword
    875  12c7
    876  12c7		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    877  12c9		       85 52		      sta	R0	; The value we are looking for
    878  12cb		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    879  12cd		       f0 08		      beq	PrintKeyBranch
    880  12cf		       c9 08		      cmp	#kGosub
    881  12d1		       f0 04		      beq	PrintKeyBranch
    882  12d3		       c9 31		      cmp	#kGofn
    883  12d5		       d0 04		      bne	PrintKeySkipped
    884  12d7				   PrintKeyBranch
    885  12d7		       c8		      iny		; Skip the compiled memory address
    886  12d8		       c8		      iny
    887  12d9		       ca		      dex		; Change number of bytes to print
    888  12da		       ca		      dex		; Remove the bytes to print
    889  12db
    890  12db				   PrintKeySkipped
    891  12db		       c8		      iny		; Inc y to point to the next char to be printed
    892  12dc		       ca		      dex		; Reduce number of bytes to print
    893  12dd		       98		      tya		; Save y and x for the return
    894  12de		       48		      pha
    895  12df		       8a		      txa
    896  12e0		       48		      pha
    897  12e1
    898  12e1		       a9 b5		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    899  12e3		       85 54		      sta	R1
    900  12e5		       a9 0d		      lda	#KeyWordTable>>8
    901  12e7		       85 55		      sta	R1+1
    902  12e9
    903  12e9
    904  12e9				   PrintKeyLoop
    905  12e9		       a0 00		      ldy	#0	; Index into the keyword entry
    906  12eb		       b1 54		      lda	(R1),y	; Get token value for this entry
    907  12ed		       c8		      iny		; Point to first byte of key
    908  12ee		       c5 52		      cmp	R0	; Compare to the token we are looking for
    909  12f0		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    910  12f2
    911  12f2				   PrintKeyNext
    912  12f2		       b1 54		      lda	(R1),y	; Get key letter
    913  12f4		       c8		      iny		; Point to next byte always
    914  12f5		       29 20		      and	#%00100000	; Check for last character in key work
    915  12f7		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    916  12f9
    917  12f9		       98		      tya		; Trabsfer y to a for the addition
    918  12fa		       18		      clc		; Table > 256 bytes
    919  12fb		       65 54		      adc	R1
    920  12fd		       85 54		      sta	R1
    921  12ff		       a9 00		      lda	#0
    922  1301		       65 55		      adc	R1+1
    923  1303		       85 55		      sta	R1+1
    924  1305		       4c e9 12 	      jmp	PrintKeyLoop
    925  1308
    926  1308				   PrintKeyFound
    927  1308		       b1 54		      lda	(R1),y	; letter from key table
    928  130a		       48		      pha		; Save it for later check
    929  130b		       09 20		      ora	#%00100000	; Force it to lower case
    930  130d		       20 bd 1e 	      jsr	VOUTCH	; Print it out
    931  1310		       c8		      iny		; Point to next character
    932  1311		       68		      pla		; Restore the value
    933  1312		       29 20		      and	#%00100000	; Check if it was last char in keyword
    934  1314		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    935  1316
    936  1316		       68		      pla		; Restore the x and y values
    937  1317		       aa		      tax
    938  1318		       68		      pla
    939  1319		       a8		      tay
    940  131a
    941  131a				   PrintChkRem
    942  131a		       a9 0a		      lda	#kRem
    943  131c		       c5 52		      cmp	R0
    944  131e		       d0 11		      bne	PrintKeyDone
    945  1320				   PrintKeyRem
    946  1320		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    947  1322		       85 5e		      sta	PrtFrom
    948  1324		       a5 5a		      lda	dpl+1
    949  1326		       85 5f		      sta	PrtFrom+1
    950  1328		       a9 00		      lda	#0
    951  132a		       8d ca 2e 	      sta	PrtTerm
    952  132d		       20 2a 15 	      jsr	PrtLoop
    953  1330		       88		      dey		; point back to the terminating null value
    954  1331				   PrintKeyDone
    955  1331		       4c 8e 12 	      jmp	PrintProgNext
    956  1334							;==================================================================================================================
    957  1334							;Print Variable, number or operator
    958  1334				   PrintProgOperator
    959  1334		       b1 59		      lda	(dpl),y
    960  1336		       c8		      iny
    961  1337		       ca		      dex
    962  1338		       8e b9 0f 	      stx	printStorage+2
    963  133b		       a2 00		      ldx	#0
    964  133d				   PrintOprLoop
    965  133d		       dd 9f 0d 	      cmp	OperValues,x
    966  1340		       f0 03		      beq	PrintOprFound
    967  1342		       e8		      inx
    968  1343		       d0 f8		      bne	PrintOprLoop
    969  1345				   PrintOprFound
    970  1345		       8a		      txa
    971  1346		       0a		      asl
    972  1347		       aa		      tax
    973  1348		       bd 71 0d 	      lda	Operators,x
    974  134b		       20 bd 1e 	      jsr	VOUTCH
    975  134e		       e8		      inx
    976  134f		       bd 71 0d 	      lda	Operators,x
    977  1352		       f0 03		      beq	PrintOprDone
    978  1354		       20 bd 1e 	      jsr	VOUTCH
    979  1357				   PrintOprDone
    980  1357		       ae b9 0f 	      ldx	printStorage+2
    981  135a		       4c 8e 12 	      jmp	PrintProgNext
    982  135d
    983  135d							;=================================================================================================================
    984  135d							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    985  135d							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    986  135d							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    987  135d							;tVhat 	    equ     155 		   ; Variable ^
    988  135d							;tVhash	    equ     156 		   ; Variable #
    989  135d							;tVat		    equ     157 		   ; Variable @ = 0
    990  135d				   PrintProgVariable
    991  135d		       b1 59		      lda	(dpl),y
    992  135f		       c8		      iny
    993  1360		       ca		      dex
    994  1361		       c9 9b		      cmp	#tVhat
    995  1363		       d0 04		      bne	PrintProgChkHash
    996  1365		       a9 5e		      lda	#'^
    997  1367		       d0 15		      bne	PrintTheVar
    998  1369				   PrintProgChkHash
    999  1369		       c9 9c		      cmp	#tVhash
   1000  136b		       d0 04		      bne	PrintProgChkAt
   1001  136d		       a9 23		      lda	#'#
   1002  136f		       d0 0d		      bne	PrintTheVar
   1003  1371				   PrintProgChkAt
   1004  1371		       c9 9d		      cmp	#tVat
   1005  1373		       d0 04		      bne	PrintProgVarLetter
   1006  1375		       a9 40		      lda	#'@
   1007  1377		       d0 05		      bne	PrintTheVar
   1008  1379				   PrintProgVarLetter
   1009  1379		       29 7f		      and	#%01111111
   1010  137b		       18		      clc
   1011  137c		       69 41		      adc	#'A
   1012  137e				   PrintTheVar
   1013  137e		       20 bd 1e 	      jsr	VOUTCH
   1014  1381		       4c 8e 12 	      jmp	PrintProgNext
   1015  1384
   1016  1384							;=========================================================================
   1017  1384							; Read an IL byte lookit up in the table, of words
   1018  1384							; set the next ilpc to point to that address
   1019  1384							; if not found then do ussual filter stuff
   1020  1384							; ongoto ilvectortable, not found address
   1021  1384		       20 2c 1a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
   1022  1387		       86 52		      stx	R0
   1023  1389		       85 53		      sta	R0+1
   1024  138b
   1025  138b		       a4 51		      ldy	CUROFF
   1026  138d		       b1 4f		      lda	(CURPTR),y	; get the operation byte
   1027  138f		       a0 00		      ldy	#0
   1028  1391		       38		      sec
   1029  1392		       f1 52		      sbc	(R0),y	; Subract the base value
   1030  1394		       c8		      iny
   1031  1395		       d1 52		      cmp	(R0),y	; Check if we are in range
   1032  1397		       b0 12		      bcs	iOnGotoInvalid
   1033  1399		       e6 51		      inc	CUROFF	; Save the offset
   1034  139b
   1035  139b		       0a		      asl
   1036  139c		       a8		      tay		; Turn into vector
   1037  139d		       c8		      iny		; Inc must include the table base and entry count
   1038  139e		       c8		      iny
   1039  139f
   1040  139f		       b1 52		      lda	(R0),y
   1041  13a1		       85 43		      sta	ILPC
   1042  13a3		       c8		      iny
   1043  13a4		       b1 52		      lda	(R0),y
   1044  13a6		       85 44		      sta	ILPC+1
   1045  13a8		       4c c2 02 	      jmp	NextIL
   1046  13ab
   1047  13ab				   iOnGotoInvalid
   1048  13ab		       20 2c 1a 	      jsr	getILWord
   1049  13ae		       86 43		      stx	ILPC
   1050  13b0		       85 44		      sta	ILPC+1
   1051  13b2		       4c c2 02 	      jmp	NextIL
   1052  13b5							;
   1053  13b5							;==========================================================================================
   1054  13b5							; Test the token for relop and push the value onto the stack if true
   1055  13b5							;
   1056  13b5				   iTSTRELOP
   1057  13b5		       20 30 1a 	      jsr	getILByte
   1058  13b8		       8d ce 2e 	      sta	offset
   1059  13bb
   1060  13bb		       a4 51		      ldy	CUROFF
   1061  13bd		       b1 4f		      lda	(CURPTR),y
   1062  13bf		       48		      pha
   1063  13c0		       29 f0		      and	#$F0
   1064  13c2		       c9 f0		      cmp	#$F0
   1065  13c4		       d0 12		      bne	iTSTRELOPNOT
   1066  13c6		       68		      pla
   1067  13c7		       29 0f		      and	#$0F	; get the actual value
   1068  13c9		       85 52		      sta	R0	; save it for later
   1069  13cb		       a9 00		      lda	#0
   1070  13cd		       85 53		      sta	R0+1
   1071  13cf		       20 29 1c 	      jsr	pushR0
   1072  13d2		       c8		      iny
   1073  13d3		       84 51		      sty	CUROFF	; save the y pointer
   1074  13d5		       4c c2 02 	      jmp	NextIL
   1075  13d8
   1076  13d8				   iTSTRELOPNOT
   1077  13d8		       68		      pla
   1078  13d9		       4c 79 0b 	      jmp	tstBranch
   1079  13dc
   1080  13dc							;
   1081  13dc							;===================================================================================================
   1082  13dc							; Test the token and following info for precompiled address information
   1083  13dc							; skip it if zero, transfer and skip next integer value if not zero
   1084  13dc							; used by both gosub, goto and gofN
   1085  13dc							;
   1086  13dc				   iTSTBRANCH
   1087  13dc		       20 30 1a 	      jsr	getILByte
   1088  13df		       8d ce 2e 	      sta	offset
   1089  13e2		       a4 51		      ldy	CUROFF
   1090  13e4		       b1 4f		      lda	(CURPTR),y
   1091  13e6		       85 52		      sta	R0
   1092  13e8		       c8		      iny
   1093  13e9		       11 4f		      ora	(CURPTR),y
   1094  13eb		       f0 1a		      beq	iTSTBRANCHNOCOMPILE
   1095  13ed		       b1 4f		      lda	(CURPTR),y
   1096  13ef		       85 53		      sta	R0+1
   1097  13f1		       c8		      iny
   1098  13f2		       b1 4f		      lda	(CURPTR),y
   1099  13f4		       c9 a2		      cmp	#tByte
   1100  13f6		       f0 05		      beq	ITSTBRANCHBYTE
   1101  13f8		       c9 a1		      cmp	#tInteger
   1102  13fa		       d0 0c		      bne	iTSTBRANCHNOCNOI
   1103  13fc		       c8		      iny		; skip type indicator for
   1104  13fd				   ITSTBRANCHBYTE
   1105  13fd		       c8		      iny		; skip first byte of value line number
   1106  13fe		       c8		      iny		; Skip second byte of line number
   1107  13ff
   1108  13ff				   iTSTBRANCHVALID
   1109  13ff		       84 51		      sty	CUROFF
   1110  1401		       20 29 1c 	      jsr	pushR0	; place transfer address on top of stack
   1111  1404		       4c 79 0b 	      jmp	tstBranch
   1112  1407
   1113  1407				   iTSTBRANCHNOCOMPILE
   1114  1407		       c8		      iny
   1115  1408
   1116  1408				   iTSTBRANCHNOCNOI
   1117  1408		       84 51		      sty	CUROFF
   1118  140a		       4c c2 02 	      jmp	NextIL
   1119  140d
   1120  140d
   1121  140d
   1122  140d
   1123  140d
   1124  140d
   1125  140d
   1126  140d
   1127  140d
   1128  140d
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  140d					      include	"print.asm"
      1  140d					      Seg	Code
      2  140d							;---------------------------
      3  140d							; Print 24-bit decimal number or  16bit unsigned
      4  140d							; ---------------------------
      5  140d							; On entry, R0=number to print
      6  140d							;	     Defaults to pad=0 , y=21 default
      7  140d							;	     R2 = 1 unsigned 16 bit
      8  140d							;	     R2 = 0 Signed   16 bit
      9  140d
     10  140d							; On entry at PrintDecPadded:
     11  140d							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  140d
     13  140d							; On exit,  A,X,Y,num,pad corrupted
     14  140d							; Size      129 bytes, Table 24 bytes	--- total 153
     15  140d							; -----------------------------------------------------------------
     16  140d
     17  140d				   PrintDecimal
     18  140d		       8a		      TXA
     19  140e		       48		      pha
     20  140f		       98		      tya
     21  1410		       48		      pha
     22  1411		       a9 00		      lda	#0
     23  1413		       8d a6 14 	      sta	pad
     24  1416		       a0 15		      LDY	#21	; Offset to powers of ten
     25  1418		       4c 1e 14 	      JMP	PrintDo
     26  141b
     27  141b				   PrintDecPadded
     28  141b		       8e a6 14 	      stx	pad
     29  141e
     30  141e				   PrintDo
     31  141e		       a9 00		      lda	#0
     32  1420		       85 54		      sta	R1
     33  1422
     34  1422		       a5 58		      lda	R2
     35  1424		       d0 29		      bne	PrintPos
     36  1426
     37  1426		       a5 53		      lda	R0+1	;MSB has sign
     38  1428		       10 25		      bpl	PrintPos	;it's a positive number;
     39  142a
     40  142a
     41  142a							; Negative numbers need more work.  Invert all the bits,
     42  142a							; then add one.
     43  142a
     44  142a		       a9 2d		      lda	#'-
     45  142c		       20 bd 1e 	      jsr	VOUTCH	;print the negative sign
     46  142f
     47  142f		       a9 ff		      lda	#$FF
     48  1431		       85 54		      sta	R1
     49  1433		       a5 52		      lda	R0	;invert bits
     50  1435		       49 ff		      eor	#$ff
     51  1437		       85 52		      sta	R0
     52  1439		       a5 53		      lda	R0+1
     53  143b		       49 ff		      eor	#$ff
     54  143d		       85 53		      sta	R0+1
     55  143f		       a5 54		      lda	R1
     56  1441		       49 ff		      eor	#$ff
     57  1443		       85 54		      sta	R1
     58  1445		       e6 52		      inc	R0	;add one
     59  1447		       d0 06		      bne	PrintPos
     60  1449		       e6 53		      inc	R0+1
     61  144b		       d0 02		      bne	PrintPos
     62  144d		       e6 54		      inc	R1
     63  144f				   PrintPos
     64  144f
     65  144f				   PrDec24Lp1
     66  144f		       a2 ff		      LDX	#$FF
     67  1451		       38		      SEC		; Start with digit=-1
     68  1452				   PrDec24Lp2
     69  1452		       a5 52		      LDA	R0+0
     70  1454		       f9 a7 14 	      SBC	PrDec24Tens+0,Y
     71  1457		       85 52		      STA	R0+0	; Subtract current tens
     72  1459		       a5 53		      LDA	R0+1
     73  145b		       f9 a8 14 	      SBC	PrDec24Tens+1,Y
     74  145e		       85 53		      STA	R0+1
     75  1460		       a5 54		      LDA	R0+2
     76  1462		       f9 a9 14 	      SBC	PrDec24Tens+2,Y
     77  1465		       85 54		      STA	R0+2
     78  1467		       e8		      INX
     79  1468		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  146a		       a5 52		      LDA	R0+0
     81  146c		       79 a7 14 	      ADC	PrDec24Tens+0,Y
     82  146f		       85 52		      STA	R0+0	; Add current tens back in
     83  1471		       a5 53		      LDA	R0+1
     84  1473		       79 a8 14 	      ADC	PrDec24Tens+1,Y
     85  1476		       85 53		      STA	R0+1
     86  1478		       a5 54		      LDA	R0+2
     87  147a		       79 a9 14 	      ADC	PrDec24Tens+2,Y
     88  147d		       85 54		      STA	R0+2
     89  147f		       8a		      TXA
     90  1480		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  1482		       ad a6 14 	      LDA	pad
     92  1485		       d0 09		      BNE	PrDec24Print
     93  1487		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  1489				   PrDec24Digit
     95  1489		       a2 30		      LDX	#'0
     96  148b		       8e a6 14 	      STX	pad	; No more zero padding
     97  148e		       09 30		      ORA	#'0	; Print this digit
     98  1490				   PrDec24Print
     99  1490		       20 bd 1e 	      JSR	VOUTCH
    100  1493				   PrDec24Next
    101  1493		       88		      DEY
    102  1494		       88		      DEY
    103  1495		       88		      DEY
    104  1496		       f0 07		      beq	PrDec24LastDigit
    105  1498		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  149a		       68		      pla
    107  149b		       a8		      tay
    108  149c		       68		      pla
    109  149d		       aa		      tax
    110  149e		       60		      RTS
    111  149f				   PrDec24LastDigit
    112  149f		       a2 30		      LDX	#'0
    113  14a1		       8e a6 14 	      STX	pad	; No more zero padding
    114  14a4		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  14a6
      0  14a6				   pad	      db	0
      1  14a6		       00		      .byte.b	0
    117  14a7				   PrDec24Tens
      0  14a7					      dw	1
      1  14a7		       01 00		      .word.w	1
      0  14a9					      db	1 / 65536
      1  14a9		       00		      .byte.b	1 / 65536
      0  14aa					      dw	10
      1  14aa		       0a 00		      .word.w	10
      0  14ac					      db	10 / 65536
      1  14ac		       00		      .byte.b	10 / 65536
      0  14ad					      dw	100
      1  14ad		       64 00		      .word.w	100
      0  14af					      db	100 / 65536
      1  14af		       00		      .byte.b	100 / 65536
      0  14b0					      dw	1000
      1  14b0		       e8 03		      .word.w	1000
      0  14b2					      db	1000 / 65536
      1  14b2		       00		      .byte.b	1000 / 65536
      0  14b3					      dw	10000
      1  14b3		       10 27		      .word.w	10000
      0  14b5					      db	10000 / 65536
      1  14b5		       00		      .byte.b	10000 / 65536
      0  14b6					      dw	100000
      1  14b6		       a0 86		      .word.w	100000
      0  14b8					      db	100000 / 65536
      1  14b8		       01		      .byte.b	100000 / 65536
      0  14b9					      dw	1000000
      1  14b9		       40 42		      .word.w	1000000
      0  14bb					      db	1000000 / 65536
      1  14bb		       0f		      .byte.b	1000000 / 65536
      0  14bc					      dw	10000000
      1  14bc		       80 96		      .word.w	10000000
      0  14be					      db	10000000 / 65536
      1  14be		       98		      .byte.b	10000000 / 65536
    134  14bf							;=====================================================
    135  14bf							; Print character in A as two hex digits to the
    136  14bf
    137  14bf		       48	   HexToOut   pha		;save return value
    138  14c0		       48		      pha
    139  14c1		       4a		      lsr		;a  ;move top nibble to bottom
    140  14c2		       4a		      lsr		;a
    141  14c3		       4a		      lsr		;a
    142  14c4		       4a		      lsr		;a
    143  14c5		       20 ce 14 	      jsr	hexta	;output nibble
    144  14c8		       68		      pla
    145  14c9		       20 ce 14 	      jsr	hexta
    146  14cc		       68		      pla		;restore
    147  14cd		       60		      rts
    148  14ce							;
    149  14ce		       29 0f	   hexta      and	#%0001111
    150  14d0		       c9 0a		      cmp	#$0a
    151  14d2		       18		      clc
    152  14d3		       30 02		      bmi	hexta1
    153  14d5		       69 07		      adc	#7
    154  14d7		       69 30	   hexta1     adc	#'0	;then fall into...
    155  14d9		       4c bd 1e 	      jmp	VOUTCH
    156  14dc							;
    157  14dc							;=====================================================
    158  14dc							; Print the string that immediately follows the JSR to
    159  14dc							; this function.  Stops when a null byte is found,
    160  14dc							; then returns to the instruction immediately
    161  14dc							; following the null.
    162  14dc							;
    163  14dc							; Thanks to Ross Archer for this code.
    164  14dc							; http://www.6502.org/source/io/primm.htm
    165  14dc							;
    166  14dc
    167  14dc		       68	   tbputs     pla		;Get the low part of "return" address
    168  14dd							;(data start address)
    169  14dd		       85 5e		      sta	PrtFrom
    170  14df		       68		      pla
    171  14e0		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    172  14e2							;(data start address)
    173  14e2							;Note: actually we're pointing one short
    174  14e2		       a0 01	   PSINB      ldy	#1
    175  14e4		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    176  14e6		       e6 5e		      inc	PrtFrom	;update the pointer
    177  14e8		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    178  14ea		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    179  14ec		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    180  14ee							;   Accumulator
    181  14ee		       f0 06		      beq	PSIX1	;don't print the final NULL
    182  14f0		       20 bd 1e 	      jsr	VOUTCH	;write it out
    183  14f3		       4c e2 14 	      jmp	PSINB	;back around
    184  14f6		       e6 5e	   PSIX1      inc	PrtFrom
    185  14f8		       d0 02		      bne	PSIX2
    186  14fa		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    187  14fc		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    188  14ff
    189  14ff							;+
    190  14ff							;====================================================
    191  14ff		       2e ca	   PrtTerm    equ	tempy
    192  14ff
    193  14ff							; on exit Print Y has the offset to use
    194  14ff							; input y =	 addr low
    195  14ff							;	 x =	 addr high
    196  14ff							;	 a =	 termination string
    197  14ff
    198  14ff				   PrtPrgLine
    199  14ff		       a9 00		      lda	#0
    200  1501		       8d ca 2e 	      sta	PrtTerm
    201  1504		       f0 0e		      beq	PrtPrgText
    202  1506
    203  1506				   PrtQuoted
    204  1506		       a9 22		      lda	#'"
    205  1508		       a4 51		      ldy	CUROFF
    206  150a		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    207  150c		       d0 03		      bne	PrtNoInc
    208  150e		       c8		      iny
    209  150f		       84 51		      sty	CUROFF
    210  1511				   PrtNoInc
    211  1511		       8d ca 2e 	      sta	PrtTerm
    212  1514
    213  1514		       a4 51	   PrtPrgText ldy	CUROFF
    214  1516		       a5 4f		      lda	CURPTR
    215  1518		       85 5e		      sta	PrtFrom
    216  151a		       a5 50		      lda	CURPTR+1
    217  151c		       85 5f		      sta	PrtFrom+1
    218  151e		       4c 2a 15 	      jmp	PrtLoop
    219  1521
    220  1521							; Print a string pointed to by x= h, y=l terminated by a
    221  1521							; Return y as the length
    222  1521
    223  1521		       86 5f	   PrtStr     stx	PrtFrom+1
    224  1523		       84 5e		      sty	PrtFrom
    225  1525		       8d ca 2e 	      sta	PrtTerm
    226  1528		       a0 00		      ldy	#0
    227  152a							;
    228  152a							; On entry here ptrfrom and prtterm point to area to print
    229  152a							;
    230  152a		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    231  152c		       cd ca 2e 	      cmp	PrtTerm
    232  152f		       f0 0b		      beq	PrtEnd
    233  1531		       c9 00		      cmp	#0	; always end if 0 is found
    234  1533		       f0 07		      beq	PrtEnd
    235  1535		       20 bd 1e 	      jsr	VOUTCH
    236  1538		       c8		      iny
    237  1539		       4c 2a 15 	      jmp	PrtLoop
    238  153c		       c8	   PrtEnd     iny		;return byte after the copy
    239  153d		       60		      rts
    240  153e
    241  153e							;
    242  153e							;=======================================================
    243  153e							; Print all Variables
    244  153e				   PrintAllVars
    245  153e		       a0 00		      ldy	#0
    246  1540		       a9 41		      lda	#'A
    247  1542				   PrintAllVarsLoop
    248  1542		       48		      pha
    249  1543		       b1 41		      lda	(VARIABLES),y
    250  1545		       85 52		      sta	R0
    251  1547		       c8		      iny
    252  1548		       b1 41		      lda	(VARIABLES),y
    253  154a		       85 53		      sta	R0+1
    254  154c
    255  154c		       68		      pla		;get the current letter
    256  154d		       48		      pha
    257  154e		       20 bd 1e 	      jsr	VOUTCH
    258  1551		       20 dc 14 	      jsr	puts
      0  1554					      db	"=",0
      1  1554		       3d 00		      .byte.b	"=",0
    260  1556		       68		      pla
    261  1557		       aa		      tax
    262  1558		       e8		      inx
    263  1559		       8a		      txa
    264  155a		       48		      pha		;
    265  155b
    266  155b		       98		      tya
    267  155c		       48		      pha
    268  155d		       20 0d 14 	      jsr	PrintDecimal
    269  1560		       20 dc 14 	      jsr	puts
      0  1563					      db	" ",0
      1  1563		       20 00		      .byte.b	" ",0
    271  1565		       68		      pla
    272  1566		       a8		      tay
    273  1567		       c8		      iny
    274  1568		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    275  156a		       90 d6		      bcc	PrintAllVarsLoop
    276  156c		       20 74 1d 	      jsr	CRLF
    277  156f
    278  156f		       68		      pla
    279  1570		       60		      rts
    280  1571
    281  1571							;==================================================================================================
    282  1571							; Size of print functions
    283  1571		       01 64	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  1571					      include	"mem.asm"
      1  1571							;===================================================================
      2  1571							;This file contains the memory allocation and free functions
      3  1571							;in herant in this is the management of free memory in the system
      4  1571							; the interface to these functions
      5  1571							; a,x returns or provides the low hi bytes of the managed addresses
      6  1571							; This uses the programend, to memory end as the area to manage
      7  1571							;===================================================================
      8  1571					      Seg	Code
      9  1571							;=====================================================
     10  1571							;Pointers for memory Management
     11  1571							;Allocated block are not chained but can be followed for all memory by the associated length
     12  1571							; Mem block format is
     13  1571							;	 0-1   pointer to next block for free blocks
     14  1571							;	 0-1   for allocated blocks
     15  1571							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  1571							;	   1   refrence counter ... lol only up to 256 but it is something
     17  1571							;	 2-3   length constant for exevy type of memory block
     18  1571							; Memory is recombined as it is released
     19  1571							; The memory manager is not interupted durring allocation
     20  1571							; or freeing of memory
     21  1571							; Memory is allocated from the highest memory address towards
     22  1571							; the lowest memory address. meeting the Basic program end.
     23  1571							;====================================================
     24  1571							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  1571							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  1571							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  1571							;=====================================================
     28  1571				   MemInit
     29  1571		       a9 dc		      lda	#FreeMemStart&$FF
     30  1573		       8d d2 2e 	      sta	ProgramStart
     31  1576		       8d d4 2e 	      sta	ProgramEnd
     32  1579		       a9 2e		      lda	#FreeMemStart>>8
     33  157b		       8d d3 2e 	      sta	ProgramStart+1
     34  157e		       8d d5 2e 	      sta	ProgramEnd+1
     35  1581
     36  1581		       20 8b 15 	      jsr	GetSizes
     37  1584		       20 96 15 	      jsr	MemFree
     38  1587		       20 ae 15 	      jsr	MemUsed
     39  158a				   MemInitEnd
     40  158a		       60		      rts
     41  158b
     42  158b
     43  158b							;
     44  158b							;=====================================================
     45  158b							; This function might go away eventually, but was
     46  158b							; added to provide data for other pieces of code.
     47  158b							; It has some ties to the operating environment that
     48  158b							; will need to be customized for the target system.
     49  158b							;
     50  158b				   GetSizes
     51  158b							;
     52  158b							; Here is machine specific code to get the highest
     53  158b							; memory location that can be used by BASIC.
     54  158b							;
     55  158b				  -	      if	ProgramStart < $2000
     56  158b				  -	      lda	#$ff
     57  158b				  -	      sta	HighMem	;$13ff for KIM-1
     58  158b				  -	      sta	MemFreeList
     59  158b				  -	      lda	#$DE	;#$13
     60  158b				  -	      sta	HighMem+1
     61  158b				  -	      sta	MemFreeList+1
     62  158b					      else
     63  158b		       a9 ff		      lda	#$ff
     64  158d		       8d d6 2e 	      sta	HighMem	;$CFFF otherwise
     65  1590		       a9 cf		      lda	#$cf
     66  1592		       8d d7 2e 	      sta	HighMem+1
     67  1595					      endif
     68  1595		       60		      rts
     69  1596							;
     70  1596							; This computes the available memory remaining.
     71  1596							;
     72  1596				   MemFree
     73  1596		       38		      sec
     74  1597		       ad d6 2e 	      lda	HighMem
     75  159a		       ed d4 2e 	      sbc	ProgramEnd
     76  159d		       8d da 2e 	      sta	FreeMem
     77  15a0		       85 52		      sta	R0
     78  15a2		       ad d7 2e 	      lda	HighMem+1
     79  15a5		       ed d5 2e 	      sbc	ProgramEnd+1
     80  15a8		       8d db 2e 	      sta	FreeMem+1
     81  15ab		       85 53		      sta	R0+1
     82  15ad		       60		      rts
     83  15ae							;
     84  15ae							; This computes the size of the current user program.
     85  15ae							;
     86  15ae				   MemUsed
     87  15ae		       38		      sec
     88  15af		       ad d4 2e 	      lda	ProgramEnd
     89  15b2		       ed d2 2e 	      sbc	ProgramStart
     90  15b5		       8d d8 2e 	      sta	UsedMem
     91  15b8		       85 52		      sta	R0
     92  15ba		       ad d5 2e 	      lda	ProgramEnd+1
     93  15bd		       ed d3 2e 	      sbc	ProgramStart+1
     94  15c0		       8d d9 2e 	      sta	UsedMem+1
     95  15c3		       85 53		      sta	R0+1
     96  15c5							;
     97  15c5		       60		      rts
     98  15c6
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  15c6					      include	"gosub.asm"
      1  15c6					      seg	Code
      2  15c6
      3  15c6							; Gosub and return related functions
      4  15c6							;==========================================================
      5  15c6							; Push the current math stack frame onto the gosub stack
      6  15c6				   iPushMathStack
      7  15c6		       98		      tya
      8  15c7		       48		      pha
      9  15c8		       a4 4d		      ldy	GOSUBSTACKPTR
     10  15ca		       a5 4a		      lda	MATHSTACKPTR
     11  15cc		       91 4b		      sta	(GOSUBSTACK),y
     12  15ce		       a9 00		      lda	#0
     13  15d0		       c8		      iny
     14  15d1		       91 4b		      sta	(GOSUBSTACK),y
     15  15d3		       c8		      iny
     16  15d4		       91 4b		      sta	(GOSUBSTACK),y
     17  15d6		       c8		      iny
     18  15d7		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  15d9		       91 4b		      sta	(GOSUBSTACK),y
     20  15db		       c8		      iny
     21  15dc		       84 4d		      sty	GOSUBSTACKPTR
     22  15de		       68		      pla
     23  15df		       a8		      tay
     24  15e0		       4c c2 02 	      jmp	NextIL
     25  15e3							;
     26  15e3							;==========================================================
     27  15e3							; Increment parameter count. Assume Stack frame is top of stack
     28  15e3				   iIncParmCount
     29  15e3		       98		      tya
     30  15e4		       48		      pha
     31  15e5		       a4 4d		      ldy	GOSUBSTACKPTR
     32  15e7		       88		      dey
     33  15e8		       88		      dey
     34  15e9		       88		      dey
     35  15ea		       b1 4b		      lda	(GOSUBSTACK),y
     36  15ec		       aa		      tax
     37  15ed		       e8		      inx
     38  15ee		       8a		      txa
     39  15ef		       91 4b		      sta	(GOSUBSTACK),y
     40  15f1		       68		      pla
     41  15f2		       a8		      tay
     42  15f3		       4c c2 02 	      jmp	NextIL
     43  15f6							;
     44  15f6							;==========================================================
     45  15f6							;Restore the math stack frame
     46  15f6		       20 fc 15    iPopMathStack jsr	PopMathStackNow
     47  15f9		       4c c2 02 	      jmp	NextIL
     48  15fc
     49  15fc				   PopMathStackNow
     50  15fc		       98		      tya
     51  15fd		       48		      pha
     52  15fe
     53  15fe		       a4 4d		      ldy	GOSUBSTACKPTR
     54  1600		       88		      dey
     55  1601		       b1 4b		      lda	(GOSUBSTACK),y
     56  1603		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  1605		       d0 09		      bne	iPopMathStackNoFrame
     58  1607		       88		      dey
     59  1608		       88		      dey
     60  1609		       88		      dey
     61  160a		       b1 4b		      lda	(GOSUBSTACK),y
     62  160c		       85 4a		      sta	MATHSTACKPTR
     63  160e		       84 4d		      sty	GOSUBSTACKPTR
     64  1610
     65  1610				   iPopMathStackNoFrame
     66  1610
     67  1610		       68		      pla
     68  1611		       a8		      tay
     69  1612		       60		      rts
     70  1613
     71  1613
     72  1613							;==========================================================
     73  1613							; Push the current math stack information onto the gosub stack
     74  1613				   iSaveMathStack
     75  1613		       98		      tya
     76  1614		       48		      pha
     77  1615		       a4 4d		      ldy	GOSUBSTACKPTR
     78  1617		       a5 4a		      lda	MATHSTACKPTR
     79  1619		       91 4b		      sta	(GOSUBSTACK),y
     80  161b		       a5 48		      lda	MATHSTACK
     81  161d		       c8		      iny
     82  161e
     83  161e		       91 4b		      sta	(GOSUBSTACK),y
     84  1620		       c8		      iny
     85  1621
     86  1621		       a5 49		      lda	MATHSTACK+1
     87  1623		       91 4b		      sta	(GOSUBSTACK),y
     88  1625		       c8		      iny
     89  1626
     90  1626		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  1628		       91 4b		      sta	(GOSUBSTACK),y
     92  162a		       c8		      iny
     93  162b
     94  162b		       84 4d		      sty	GOSUBSTACKPTR
     95  162d		       68		      pla
     96  162e		       a8		      tay
     97  162f		       4c c2 02 	      jmp	NextIL
     98  1632							;
     99  1632							;==========================================================
    100  1632							;Restore the math stack information from the gosub stack
    101  1632				   iRestoreMathStack
    102  1632		       98		      tya
    103  1633		       48		      pha
    104  1634
    105  1634		       a5 4a		      lda	MATHSTACKPTR
    106  1636		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  1638
    108  1638		       a4 4d		      ldy	GOSUBSTACKPTR
    109  163a		       88		      dey
    110  163b		       b1 4b		      lda	(GOSUBSTACK),y
    111  163d		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  163f		       d0 16		      bne	iPopMathStack_Err
    113  1641		       88		      dey
    114  1642		       b1 4b		      lda	(GOSUBSTACK),y
    115  1644		       85 49		      sta	MATHSTACK+1
    116  1646		       88		      dey
    117  1647		       b1 4b		      lda	(GOSUBSTACK),y
    118  1649		       85 48		      sta	MATHSTACK
    119  164b		       88		      dey
    120  164c		       b1 4b		      lda	(GOSUBSTACK),y
    121  164e		       85 4a		      sta	MATHSTACKPTR
    122  1650		       84 4d		      sty	GOSUBSTACKPTR
    123  1652		       68		      pla
    124  1653		       a8		      tay
    125  1654		       4c c2 02 	      jmp	NextIL
    126  1657
    127  1657				   iPopMathStack_Err
    128  1657		       a9 00		      lda	#0
    129  1659		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  165b		       4c 44 06 	      jmp	iErr2
    131  165e							;=========================================
    132  165e							; For functions and tasks the variable address of # means
    133  165e							; a passed parameter so #[0] is the first parameter etc
    134  165e							; will try for a better way later
    135  165e
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  165e					      include	"tasks.asm"
      1  165e							;=====================================================
      2  165e							; Tiny Basic IL task management
      3  165e							; Data required by task management
      4  165e							; currently each context is about 30 bytes and is swapped
      5  165e							; into and out of page zero on each task switch....
      6  165e							; LOL yes it is slow, but works for this iteration.
      7  165e							;
      8  165e
      9  165e					      Seg	Code
     10  165e							;=====================================================
     11  165e							; Sets the pointers to the math,IL and gosub stacks
     12  165e							; Creates the initial Context for each task slot
     13  165e				   taskSetStacks
     14  165e		       a9 79		      lda	#mathStack&$FF
     15  1660		       85 48		      sta	MATHSTACK
     16  1662		       a9 26		      lda	#mathStack>>8
     17  1664		       85 49		      sta	MATHSTACK+1
     18  1666
     19  1666		       a9 09		      lda	#ilStack&$ff
     20  1668		       85 45		      sta	ILSTACK
     21  166a		       a9 28		      lda	#ilStack>>8
     22  166c		       85 46		      sta	ILSTACK+1
     23  166e
     24  166e		       a9 99		      lda	#gosubStack&$FF
     25  1670		       85 4b		      sta	GOSUBSTACK
     26  1672		       a9 29		      lda	#gosubStack>>8
     27  1674		       85 4c		      sta	GOSUBSTACK+1
     28  1676
     29  1676		       a9 19		      lda	#variableStack&$FF
     30  1678		       85 41		      sta	VARIABLES
     31  167a		       a9 2c		      lda	#variableStack>>8
     32  167c		       85 42		      sta	VARIABLES+1
     33  167e		       a2 0a		      ldx	#TASKCOUNT
     34  1680		       a0 00		      ldy	#0
     35  1682		       20 0d 19 	      jsr	ContextSave
     36  1685
     37  1685		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  1687		       b0 3a		      bcs	taskSetDone
     39  1689
     40  1689		       a5 4b		      lda	GOSUBSTACK
     41  168b		       18		      clc
     42  168c		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  168e		       85 4b		      sta	GOSUBSTACK
     44  1690		       a5 4c		      lda	GOSUBSTACK+1
     45  1692		       69 00		      adc	#0
     46  1694		       85 4c		      sta	GOSUBSTACK+1
     47  1696
     48  1696		       a5 45		      lda	ILSTACK	; must be less than 256
     49  1698		       18		      clc
     50  1699		       69 28		      adc	#ILSTACKSIZE*2
     51  169b		       85 45		      sta	ILSTACK
     52  169d		       a5 46		      lda	ILSTACK+1
     53  169f		       69 00		      adc	#0
     54  16a1		       85 46		      sta	ILSTACK+1
     55  16a3
     56  16a3		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  16a5		       18		      clc
     58  16a6		       69 28		      adc	#MATHSTACKSIZE*2
     59  16a8		       85 48		      sta	MATHSTACK
     60  16aa		       a5 49		      lda	MATHSTACK+1
     61  16ac		       69 00		      adc	#0
     62  16ae		       85 49		      sta	MATHSTACK+1
     63  16b0
     64  16b0		       a5 41		      lda	VARIABLES	; must be less than 256
     65  16b2		       18		      clc
     66  16b3		       69 36		      adc	#VARIABLESSIZE*2
     67  16b5		       85 41		      sta	VARIABLES
     68  16b7		       a5 42		      lda	VARIABLES+1
     69  16b9		       69 00		      adc	#0
     70  16bb		       85 42		      sta	VARIABLES+1
     71  16bd
     72  16bd		       20 0d 19 	      jsr	ContextSave
     73  16c0		       4c 85 16 	      jmp	taskSetLoop
     74  16c3
     75  16c3				   taskSetDone
     76  16c3		       a0 00		      ldy	#0	; reload the main loop context
     77  16c5		       20 1c 19 	      jsr	ContextLoad
     78  16c8		       60		      rts
     79  16c9							;
     80  16c9							;=====================================================
     81  16c9							; In some error cases the math stacks may be left pointing to the wrong stack
     82  16c9							; This function will reset those stack addresses but not the actual pointer
     83  16c9				   taskResetStacks
     84  16c9		       a0 00		      ldy	#0
     85  16cb		       20 1c 19 	      jsr	ContextLoad
     86  16ce		       4c 5e 16 	      jmp	taskSetStacks
     87  16d1							;
     88  16d1							;=====================================================
     89  16d1							; Clear all task entries and task stacks
     90  16d1		       98	   taskReset  tya		; Save Y
     91  16d2		       48		      pha
     92  16d3		       a9 01		      lda	#1
     93  16d5		       8d 78 26 	      sta	taskCounter	; Set number of active tasks to 1
     94  16d8		       ac 79 25 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  16db		       c0 00		      cpy	#0	; check if we are the main context
     96  16dd		       f0 08		      beq	taskResetCont	; if we are just continue
     97  16df
     98  16df		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  16e1		       8c 79 25 	      sty	taskPtr
    100  16e4		       20 1c 19 	      jsr	ContextLoad	; load the System Task context
    101  16e7				   taskResetCont
    102  16e7		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  16e9
    104  16e9				   taskResetLoop
    105  16e9		       a9 00		      lda	#TASKINACTIVE
    106  16eb		       99 7a 25 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  16ee		       18		      clc
    108  16ef		       98		      tya
    109  16f0		       69 19		      adc	#CONTEXTLEN+1
    110  16f2		       a8		      tay
    111  16f3		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  16f5		       90 f2		      bcc	taskResetLoop	; Go for more
    113  16f7
    114  16f7				   taskResetComplete
    115  16f7
    116  16f7		       68		      pla		; Restore y
    117  16f8		       a8		      tay
    118  16f9		       60		      rts
    119  16fa
    120  16fa							;
    121  16fa							;======================================================
    122  16fa							; iTaskSwitch	 switch to new task if not interrupt and
    123  16fa							;		 count is exceded for task time slice gets here
    124  16fa							;		 when time slice has reached zero
    125  16fa							;
    126  16fa		       98	   iTaskSwitch tya
    127  16fb		       48		      pha
    128  16fc
    129  16fc		       ad 76 26 	      lda	taskResetValue	; Always reset the counter value
    130  16ff		       8d 74 26 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  1702		       ce 75 26 	      dec	taskCurrentCycles+1	; dec high order byte
    132  1705		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  1707
    134  1707		       ad 77 26 	      lda	taskResetValue+1
    135  170a		       8d 75 26 	      sta	taskCurrentCycles+1
    136  170d
    137  170d		       ad 76 25 	      lda	IRQPending	; Skip this if we are processing an irq
    138  1710		       0d d0 2e 	      ora	taskIOPending	; If set then don't switch
    139  1713		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  1715
    141  1715		       ad 78 26    iTaskMain  lda	taskCounter	; Number of tasks
    142  1718		       c9 01		      cmp	#1	; if there is only one task must be main
    143  171a		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  171c
    145  171c		       ac 79 25 	      ldy	taskPtr	; check if we have not just ended some other task
    146  171f		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  1721		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  1723							;
    149  1723							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  1723							;
    151  1723				   itasknext
    152  1723		       ac 79 25 	      ldy	taskPtr
    153  1726		       20 0d 19 	      jsr	ContextSave	; Save the current context, y points to next context
    154  1729				   itaskLoop
    155  1729		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  172b		       90 04		      bcc	iTaskNextChk
    157  172d
    158  172d		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  172f		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  1731
    161  1731				   iTaskNextChk
    162  1731		       b9 7a 25 	      lda	taskTable,y	; there is always at least one entry in table
    163  1734		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  1736		       18	   iTaskNext  clc
    165  1737		       98		      tya
    166  1738		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  173a		       a8		      tay
    168  173b		       4c 29 17 	      jmp	itaskLoop	; Check for busy entry
    169  173e
    170  173e		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  1740		       59 7a 25 	      eor	taskTable,y	; Check for anything waiting io
    172  1743		       d0 f1		      bne	iTaskNext
    173  1745		       20 1c 19 	      jsr	ContextLoad	; load the next context
    174  1748		       8c 79 25 	      sty	taskPtr	; update the task pointer
    175  174b
    176  174b				   iTaskSwitchDone
    177  174b		       68		      pla
    178  174c		       a8		      tay
    179  174d		       60		      rts
    180  174e							;
    181  174e							;================================================================
    182  174e							; Task Set task number to line number to start
    183  174e							; Task Table structure:
    184  174e							;    byte 0	-   Active inactive
    185  174e							;    byte 1-2	-   Basic code line pointer
    186  174e							;    byte 3	-   Offset on current line
    187  174e		       98	   iTaskSet   tya		;preserve Y
    188  174f		       48		      pha		; push a
    189  1750
    190  1750		       20 bb 1c 	      jsr	popR0	; Get the line number to be saved
    191  1753
    192  1753		       ac 79 25 	      ldy	taskPtr	; find out where we are
    193  1756		       20 0d 19 	      jsr	ContextSave	; Save the current context
    194  1759
    195  1759							;Find the pointer to the line we need to start at
    196  1759		       20 75 1a 	      jsr	findLine	; Get the offset of the line to start task at
    197  175c		       f0 0b		      beq	iTaskCont
    198  175e
    199  175e		       ac 79 25 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  1761		       20 1c 19 	      jsr	ContextLoad
    201  1764
    202  1764		       68		      pla		; pop a - exit
    203  1765		       a8		      tay
    204  1766		       4c 5d 0d 	      jmp	iSetIrqErr	; Bad line number provided
    205  1769
    206  1769				   iTaskCont
    207  1769		       20 df 18 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  176c		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  176e
    210  176e		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  1770		       99 7a 25 	      sta	taskTable,y	; new task as active
    212  1773
    213  1773		       a5 4f		      lda	CURPTR
    214  1775		       48		      pha		; push a
    215  1776		       a5 50		      lda	CURPTR+1
    216  1778		       48		      pha		; push a
    217  1779
    218  1779		       20 1c 19 	      jsr	ContextLoad	; load the context of the new task
    219  177c
    220  177c		       68		      pla		; pop a
    221  177d		       85 50		      sta	CURPTR+1
    222  177f		       68		      pla		; pop a
    223  1780		       85 4f		      sta	CURPTR
    224  1782		       a9 03		      lda	#3	; Offset to first instruction
    225  1784		       85 51		      sta	CUROFF
    226  1786
    227  1786		       a9 00		      lda	#0
    228  1788		       85 47		      sta	ILSTACKPTR
    229  178a		       85 4a		      sta	MATHSTACKPTR
    230  178c		       85 4d		      sta	GOSUBSTACKPTR
    231  178e		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  1790		       85 4e		      sta	MESSAGEPTR
    233  1792
    234  1792		       20 48 09 	      jsr	subVINIT	; Clear the variables
    235  1795
    236  1795		       a9 6a		      lda	#STMT&$FF
    237  1797		       85 43		      sta	ILPC
    238  1799		       a9 21		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  179b		       85 44		      sta	ILPC+1
    240  179d
    241  179d		       98		      tya		; Save the new context offset to return to user
    242  179e		       48		      pha		; push a
    243  179f
    244  179f		       20 0d 19    itaskSetSave jsr	ContextSave	; save the updated context
    245  17a2		       ee 78 26 	      inc	taskCounter	; Update the number of Tasks running
    246  17a5
    247  17a5		       ac 79 25 	      ldy	taskPtr
    248  17a8		       20 1c 19 	      jsr	ContextLoad	; restore the original context
    249  17ab
    250  17ab		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  17ad		       85 53		      sta	R0+1
    252  17af		       68		      pla		; Get the task pid we stored				 ; pop a
    253  17b0		       85 52		      sta	R0	; Get the table entry value
    254  17b2
    255  17b2		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  17b3		       a8		      tay
    257  17b4
    258  17b4		       4c 2f 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  17b7				   iTaskNoEmpty
    260  17b7		       ac 79 25 	      ldy	taskPtr
    261  17ba		       20 1c 19 	      jsr	ContextLoad
    262  17bd
    263  17bd		       68		      pla		; pop a    -- exit
    264  17be		       a8		      tay
    265  17bf
    266  17bf		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  17c1		       a9 00		      lda	#0
    268  17c3		       4c 44 06 	      jmp	iErr2
    269  17c6							;
    270  17c6							;===============================================================
    271  17c6							; Run the task whos PID is on the stack, preserve the stack
    272  17c6							;
    273  17c6				   iTaskEnable
    274  17c6		       98		      tya
    275  17c7		       48		      pha
    276  17c8		       20 d3 1c 	      jsr	popR1
    277  17cb		       20 a1 1c 	      jsr	pushR1
    278  17ce		       20 13 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    279  17d1		       a0 00		      ldy	#0
    280  17d3		       b1 56		      lda	(MQ),y
    281  17d5		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  17d7		       09 80		      ora	#TASKACTIVE
    283  17d9		       91 56		      sta	(MQ),y
    284  17db		       68		      pla
    285  17dc		       a8		      tay
    286  17dd		       4c c2 02 	      jmp	NextIL
    287  17e0
    288  17e0							;
    289  17e0							;===============================================================
    290  17e0							; Suspend the task whos PID  is on the stack, preserve the stack
    291  17e0							;
    292  17e0				   iTaskSuspend
    293  17e0		       98		      tya
    294  17e1		       48		      pha
    295  17e2		       20 d3 1c 	      jsr	popR1
    296  17e5		       20 a1 1c 	      jsr	pushR1
    297  17e8		       20 13 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    298  17eb		       a0 00		      ldy	#0
    299  17ed		       b1 56		      lda	(MQ),y
    300  17ef		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  17f1		       09 80		      ora	#TASKACTIVE
    302  17f3		       68		      pla
    303  17f4		       a8		      tay
    304  17f5		       4c c2 02 	      jmp	NextIL
    305  17f8
    306  17f8							;================================================================
    307  17f8							; Returns task Status
    308  17f8				   iTaskStat
    309  17f8		       98		      tya
    310  17f9		       48		      pha
    311  17fa		       20 0c 18 	      jsr	iTaskValid	; returns pointer to task entry
    312  17fd		       b9 7a 25 	      lda	taskTable,y
    313  1800		       f0 05		      beq	iTaskStatExit
    314  1802		       68		      pla
    315  1803		       a8		      tay
    316  1804		       4c 17 0d 	      jmp	iTruth
    317  1807				   iTaskStatExit
    318  1807		       68		      pla
    319  1808		       a8		      tay
    320  1809		       4c 20 0d 	      jmp	iFalse
    321  180c
    322  180c							;
    323  180c							;================================================================
    324  180c							; Validate the task number on top of the stack
    325  180c							; on exit y points to the requested task entry
    326  180c							;
    327  180c		       20 bb 1c    iTaskValid jsr	popR0	; get result of the multiply
    328  180f		       a5 53		      lda	R0+1
    329  1811		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  1813		       a5 52		      lda	R0
    331  1815		       c9 fa		      cmp	#TASKTABLELEN
    332  1817		       90 09		      bcc	iTaskIsValid
    333  1819
    334  1819		       68	   iTaskValidErr pla		;remove return address
    335  181a		       68		      pla
    336  181b		       a2 10		      ldx	#ERR_INVALID_PID
    337  181d		       a9 00		      lda	#0
    338  181f		       4c 44 06 	      jmp	iErr2
    339  1822
    340  1822		       a8	   iTaskIsValid tay
    341  1823		       60		      rts
    342  1824							;
    343  1824							;================================================================
    344  1824							; Kill a running task, do nothing if already stopped
    345  1824		       20 0c 18    iTaskKill  jsr	iTaskValid
    346  1827		       a9 00		      lda	#0
    347  1829		       99 7a 25 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  182c							;
    349  182c							;================================================================
    350  182c							;Skip to next task
    351  182c				   iNTask
    352  182c		       a9 01		      lda	#1
    353  182e		       8d 74 26 	      sta	taskCurrentCycles
    354  1831		       8d 75 26 	      sta	taskCurrentCycles+1
    355  1834		       4c c2 02 	      jmp	NextIL
    356  1837							;
    357  1837							;=======================================================
    358  1837							; Wait for a task to complete
    359  1837				   iWTASK
    360  1837		       20 30 1a 	      jsr	getILByte
    361  183a		       8d ce 2e 	      sta	offset
    362  183d							;
    363  183d		       20 13 1c 	      jsr	saveIL	;in case of failure
    364  1840
    365  1840		       20 0c 18 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  1843		       b9 7a 25 	      lda	taskTable,y
    367  1846		       d0 03		      bne	iWTASKWAIT
    368  1848				   iWTASKEXITED
    369  1848		       4c c2 02 	      jmp	NextIL
    370  184b				   iWTASKWAIT
    371  184b		       20 29 1c 	      jsr	pushR0	; Push R0 back onto the stack
    372  184e		       a9 01		      lda	#1
    373  1850		       8d 74 26 	      sta	taskCurrentCycles	; Give up the cycles
    374  1853		       8d 75 26 	      sta	taskCurrentCycles+1
    375  1856		       20 1e 1c 	      jsr	restoreIL
    376  1859		       4c 79 0b 	      jmp	tstBranch
    377  185c							;
    378  185c							;=======================================================
    379  185c							; Set task io lock
    380  185c		       ee d0 2e    iStartIO   inc	taskIOPending
    381  185f		       4c c2 02 	      jmp	NextIL
    382  1862							;
    383  1862							;=======================================================
    384  1862							; Release the io lock
    385  1862		       ad d0 2e    iEndIO     lda	taskIOPending
    386  1865		       f0 03		      beq	iEndIOExit
    387  1867		       ce d0 2e 	      dec	taskIOPending
    388  186a		       4c c2 02    iEndIOExit jmp	NextIL
    389  186d							;
    390  186d							;===============================================================
    391  186d							; Return the task PID
    392  186d				   iTASKPID
    393  186d		       a9 00		      lda	#0
    394  186f		       85 53		      sta	R0+1
    395  1871		       ad 79 25 	      lda	taskPtr
    396  1874		       85 52		      sta	R0
    397  1876		       4c 2f 07 	      jmp	pushR0nextIl
    398  1879							;
    399  1879							;================================================================
    400  1879							; Terminate a task
    401  1879		       ac 79 25    iETask     ldy	taskPtr
    402  187c		       c0 00		      cpy	#0
    403  187e		       d0 03		      bne	iETaskCont
    404  1880		       4c 2d 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  1883				   iETaskCont
    406  1883		       a9 00		      lda	#TASKINACTIVE
    407  1885		       99 7a 25 	      sta	taskTable,y	; mark entry as free
    408  1888		       ce 78 26 	      dec	taskCounter	; reduce the number of active tasks
    409  188b		       a9 01		      lda	#1
    410  188d		       8d 74 26 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  1890		       8d 75 26 	      sta	taskCurrentCycles+1
    412  1893		       20 fa 18 	      jsr	TaskSetExitCode
    413  1896				   iETaskExit
    414  1896		       4c c2 02 	      jmp	NextIL
    415  1899							;================================================================
    416  1899							; make the current tasks math stack equal another tasks stack
    417  1899							; The task to get is stored on the math stack
    418  1899
    419  1899				   iTaskGetMathStack
    420  1899		       20 dc 1e 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  189c		       20 13 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    422  189f		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  18a1		       b1 56		      lda	(MQ),y
    424  18a3		       85 4a		      sta	MATHSTACKPTR
    425  18a5		       a0 08		      ldy	#MATHSTACKPOS
    426  18a7		       b1 56		      lda	(MQ),y
    427  18a9		       85 48		      sta	MATHSTACK
    428  18ab		       c8		      iny
    429  18ac		       b1 56		      lda	(MQ),y
    430  18ae		       85 49		      sta	MATHSTACK+1
    431  18b0		       4c c2 02 	      jmp	NextIL
    432  18b3							;==================================================================
    433  18b3							; Updates the tasks math stack pointer with contents of R2
    434  18b3							; PID is on top of the stack
    435  18b3				   iTaskPutMathPtr
    436  18b3		       20 dc 1e 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  18b6		       20 13 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    438  18b9		       a5 58		      lda	R2
    439  18bb		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  18bd		       91 56		      sta	(MQ),y
    441  18bf		       4c c2 02 	      jmp	NextIL
    442  18c2							;
    443  18c2							;================================================================
    444  18c2							; Set the time slice for each task
    445  18c2				   iSLICE
    446  18c2		       20 bb 1c 	      jsr	popR0
    447  18c5		       a5 52		      lda	R0
    448  18c7		       8d 76 26 	      sta	taskResetValue
    449  18ca		       a5 53		      lda	R0+1
    450  18cc		       8d 77 26 	      sta	taskResetValue+1
    451  18cf		       d0 0b		      bne	iSliceSet
    452  18d1		       ee 77 26 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  18d4		       a9 01		      lda	#1
    454  18d6		       8d 74 26 	      sta	taskCurrentCycles
    455  18d9		       8d 75 26 	      sta	taskCurrentCycles+1
    456  18dc				   iSliceSet
    457  18dc		       4c c2 02 	      jmp	NextIL
    458  18df							;================================================================
    459  18df							; Find an empty slot in the taskTable
    460  18df							; Return the index in y
    461  18df							; on exit   c set if an empty slot is found
    462  18df							;	     c clear if not found
    463  18df							;================================================================
    464  18df							;
    465  18df		       ad 78 26    TaskEmpty  lda	taskCounter
    466  18e2		       c9 0a		      cmp	#TASKCOUNT
    467  18e4		       b0 10		      bcs	TaskNoSlot
    468  18e6		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  18e8				   TaskLoop
    470  18e8		       b9 7a 25 	      lda	taskTable,y
    471  18eb		       f0 0b		      beq	TaskEmptyFnd
    472  18ed		       98		      tya
    473  18ee		       18		      clc
    474  18ef		       69 19		      adc	#CONTEXTLEN+1
    475  18f1		       a8		      tay
    476  18f2		       c0 fa		      cpy	#TASKTABLELEN
    477  18f4		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  18f6				   TaskNoSlot
    479  18f6		       18		      clc
    480  18f7		       60		      rts
    481  18f8				   TaskEmptyFnd
    482  18f8		       38		      sec
    483  18f9		       60		      rts
    484  18fa							;====================================================
    485  18fa							; Set the task exit code called from the return command
    486  18fa							; on entry stack top hold exit value
    487  18fa				   TaskSetExitCode
    488  18fa		       98		      tya
    489  18fb		       48		      pha
    490  18fc		       20 bb 1c 	      jsr	popR0
    491  18ff		       a0 19		      ldy	#TASKEXITCODE
    492  1901		       a5 52		      lda	R0
    493  1903		       91 41		      sta	(VARIABLES),y
    494  1905		       c8		      iny
    495  1906		       a5 53		      lda	R0+1
    496  1908		       91 41		      sta	(VARIABLES),y
    497  190a		       68		      pla
    498  190b		       98		      tya
    499  190c		       60		      rts
    500  190d
    501  190d							;
    502  190d							;=====================================================
    503  190d							; Save Context Store the context to the TASK Table
    504  190d							; on entry y contains the task table entry to save to
    505  190d							; on exit y points to next task table entry
    506  190d							;	   x contains the number of bytes copied
    507  190d		       a2 00	   ContextSave ldx	#0
    508  190f		       c8		      iny		;inc past the task flags
    509  1910		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  1912		       99 7a 25 	      sta	taskTable,y
    511  1915		       c8		      iny
    512  1916		       e8		      inx
    513  1917		       e0 18		      cpx	#CONTEXTLEN
    514  1919		       90 f5		      bcc	ContextSvLoop
    515  191b		       60		      rts
    516  191c							;
    517  191c							; Load Context transfer context from task table to the Current Context
    518  191c							; on entry y contains the task table entry to transfer
    519  191c							; on exit y points to the original task table entry
    520  191c							;	   x contains the number of byts copied
    521  191c		       98	   ContextLoad tya
    522  191d		       48		      pha
    523  191e		       a2 00		      ldx	#0
    524  1920		       c8		      iny		;inc past the task flags
    525  1921		       b9 7a 25    ContextLDLoop lda	taskTable,y
    526  1924		       95 41		      sta	CONTEXT,x
    527  1926		       c8		      iny
    528  1927		       e8		      inx
    529  1928		       e0 18		      cpx	#CONTEXTLEN
    530  192a		       90 f5		      bcc	ContextLDLoop
    531  192c		       68		      pla
    532  192d		       a8		      tay
    533  192e		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  192f					      include	"ipc.asm"
      1  192f							;======================================================
      2  192f							; Inter process communications.
      3  192f							; Tasks may write/read integer messages among
      4  192f							; them selves.
      5  192f							; This uses each tasks gosub stack as a message queue
      6  192f							; Gosub calls start at the highest address and the
      7  192f							; msg queue starts at the highest address.
      8  192f							;
      9  192f							;======================================================
     10  192f							; ipcs   - Send msg to another task or many tasks
     11  192f							; on entry  math stack contains the  top PID
     12  192f							;				      2ND Message value
     13  192f							; on exit   math stack contain top True-good or False-failed
     14  192f							;
     15  192f							; it may not be sent if queue is full
     16  192f							;
     17  192f							; a = ipcs(<message-expression>,<task PID-expression>)
     18  192f							;
     19  192f				   iIPCS
     20  192f		       98		      tya
     21  1930		       48		      pha
     22  1931		       20 98 19 	      jsr	ipc_enqueue
     23  1934		       b0 08		      bcs	iIPC_BAD
     24  1936		       20 ce 1e 	      jsr	pushTrue
     25  1939		       68		      pla
     26  193a		       a8		      tay
     27  193b		       4c c2 02 	      jmp	NextIL
     28  193e				   iIPC_BAD
     29  193e		       68		      pla
     30  193f		       a8		      tay
     31  1940		       20 d8 1e 	      jsr	pushFalse
     32  1943		       4c c2 02 	      jmp	NextIL
     33  1946
     34  1946							;======================================================
     35  1946							; ipcr   - Recieve msg from task
     36  1946							; on exit  the message value is returned from message queue
     37  1946							;	    message -1	is reserved meaning no entry found
     38  1946							; The provided variable contains the pid of the sending
     39  1946							; task. This is optional. This always waits for a message
     40  1946							; before returning.
     41  1946							;
     42  1946							; a = ipcr(<variable name>)
     43  1946							;
     44  1946				   iIPCR
     45  1946		       98		      tya
     46  1947		       48		      pha
     47  1948		       20 da 19 	      jsr	ipc_dequeue
     48  194b		       b0 05		      bcs	iIPCR_Q_Empty
     49  194d		       68		      pla
     50  194e		       a8		      tay
     51  194f		       4c c2 02 	      jmp	NextIL
     52  1952				   iIPCR_Q_Empty
     53  1952		       68		      pla
     54  1953		       a8		      tay
     55  1954		       20 ce 1e 	      jsr	pushTrue	; puts -1 on the stack
     56  1957		       4c c2 02 	      jmp	NextIL
     57  195a
     58  195a							;=======================================================
     59  195a							; ipcc   - Check if message available
     60  195a							; on exit  Stack contains number of messages
     61  195a							;
     62  195a							; a = ipcc()
     63  195a							;
     64  195a				   iIPCC
     65  195a		       98		      tya
     66  195b		       48		      pha
     67  195c		       20 85 19 	      jsr	ipc_queue_count
     68  195f		       20 29 1c 	      jsr	pushR0	; return the count
     69  1962		       68		      pla
     70  1963		       a8		      tay
     71  1964		       4c c2 02 	      jmp	NextIL
     72  1967
     73  1967							;=======================================================
     74  1967							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  1967				   iIPCIO
     76  1967		       98		      tya
     77  1968		       48		      pha
     78  1969		       20 85 19 	      jsr	ipc_queue_count
     79  196c		       a5 52		      lda	R0
     80  196e		       d0 10		      bne	iIPCIO_No_Halt
     81  1970		       a9 01		      lda	#1
     82  1972		       8d 74 26 	      sta	taskCurrentCycles	; force a task switch
     83  1975		       a9 01		      lda	#TASKWAITIPC
     84  1977		       ac 79 25 	      ldy	taskPtr
     85  197a		       19 7a 25 	      ora	taskTable,y
     86  197d		       99 7a 25 	      sta	taskTable,y
     87  1980
     88  1980				   iIPCIO_No_Halt
     89  1980		       68		      pla
     90  1981		       a8		      tay
     91  1982		       4c c2 02 	      jmp	NextIL
     92  1985							;======================================================
     93  1985							;ipc_queue_count
     94  1985				   ipc_queue_count
     95  1985		       a5 4e		      lda	MESSAGEPTR
     96  1987		       18		      clc
     97  1988		       4a		      lsr		; divide by 4
     98  1989		       4a		      lsr
     99  198a		       85 52		      sta	R0	; store into R0
    100  198c		       a9 10		      lda	#GOSUBSTACKSIZE
    101  198e		       38		      sec
    102  198f		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1991		       85 52		      sta	R0
    104  1993		       a9 00		      lda	#0
    105  1995		       85 53		      sta	R0+1
    106  1997		       60		      rts
    107  1998							;=======================================================
    108  1998							; Support functions for messaging
    109  1998							;
    110  1998							; Enqueue message -> onto PID's MSG Q
    111  1998							; on entry top of stack contains the PID
    112  1998							;	    second contains the Message of the task
    113  1998							; on exit contains c set if failed
    114  1998							;		    c cleared if success
    115  1998							;		    PID's MSG Q PTR points to the message
    116  1998							;
    117  1998				   ipc_enqueue
    118  1998		       20 d3 1c 	      jsr	popR1	; Get the pid
    119  199b		       20 13 1a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  199e
    121  199e		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  19a0		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  19a2		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  19a4		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  19a6		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  19a8
    127  19a8
    128  19a8							; Get the PID'S stack address into R0
    129  19a8		       a0 0b		      ldy	#GOSUBSTKPOS
    130  19aa		       b1 56		      lda	(MQ),y
    131  19ac		       85 52		      sta	R0
    132  19ae		       c8		      iny
    133  19af		       b1 56		      lda	(MQ),y
    134  19b1		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  19b3
    136  19b3							; Set y to point to the msg q entry
    137  19b3		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  19b5		       b1 56		      lda	(MQ),y	; Get the index
    139  19b7		       a8		      tay		; Set y to queue offset
    140  19b8
    141  19b8							; enqueue the message
    142  19b8		       88		      dey		; First byte to save to
    143  19b9		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  19bb		       91 52		      sta	(R0),y	; Set the entry type
    145  19bd
    146  19bd		       88		      dey
    147  19be		       ad 79 25 	      lda	taskPtr	; Store the PID into queue
    148  19c1		       91 52		      sta	(R0),y
    149  19c3		       20 d3 1c 	      jsr	popR1	; Get the actual message value
    150  19c6		       20 21 1a 	      jsr	ipc_pushR1	; Store Message value into queue
    151  19c9
    152  19c9		       98		      tya		; Save the new q ptr
    153  19ca		       a0 0e		      ldy	#MSGPTRPOS
    154  19cc		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  19ce		       a0 00		      ldy	#0	; points to context root
    156  19d0		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  19d2		       51 56		      eor	(MQ),y	; Turn off the bit
    158  19d4		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  19d6		       18		      clc
    160  19d7		       60		      rts
    161  19d8				   ipc_enq_full
    162  19d8		       38		      sec
    163  19d9		       60		      rts
    164  19da							;=============================================================
    165  19da							; De-queue for message stack -> local tasks msg q
    166  19da							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  19da							;  message into
    168  19da							;  on exit   math stack contains value of message
    169  19da							;				  Variable if provided is pid
    170  19da				   ipc_dequeue
    171  19da		       20 ea 1c 	      jsr	popMQ	; Variable address to put PID into
    172  19dd
    173  19dd		       a4 4e		      ldy	MESSAGEPTR
    174  19df		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  19e1		       b0 2e		      bcs	ipc_deq_empty
    176  19e3		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  19e5		       85 52		      sta	R0
    178  19e7		       c8		      iny
    179  19e8		       b1 4b		      lda	(GOSUBSTACK),y
    180  19ea		       85 53		      sta	R0+1
    181  19ec		       c8		      iny
    182  19ed		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  19ef		       85 54		      sta	R1
    184  19f1		       c8		      iny
    185  19f2		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  19f4		       c8		      iny
    187  19f5		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  19f7
    189  19f7		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  19f9		       d0 16		      bne	ipc_deq_empty
    191  19fb
    192  19fb		       20 29 1c 	      jsr	pushR0	; place value on stack
    193  19fe
    194  19fe		       a5 56		      lda	MQ
    195  1a00		       05 57		      ora	MQ+1
    196  1a02		       f0 0b		      beq	ipc_deq_done
    197  1a04		       a5 54		      lda	R1
    198  1a06		       a0 00		      ldy	#0
    199  1a08		       91 56		      sta	(MQ),y
    200  1a0a		       c8		      iny
    201  1a0b		       a9 00		      lda	#0
    202  1a0d		       91 56		      sta	(MQ),y
    203  1a0f				   ipc_deq_done
    204  1a0f		       18		      clc
    205  1a10		       60		      rts
    206  1a11
    207  1a11				   ipc_deq_empty
    208  1a11		       38		      sec
    209  1a12		       60		      rts
    210  1a13
    211  1a13							;=============================================
    212  1a13							;  Get the context address into MQ from R1 with
    213  1a13							;  context/index/pid
    214  1a13				   ipc_getcontext
    215  1a13		       18		      clc		; Get pointer to Task context
    216  1a14		       a9 7a		      lda	#taskTable&$FF	; change ptr to address
    217  1a16		       65 54		      adc	R1
    218  1a18		       85 56		      sta	MQ
    219  1a1a		       a9 25		      lda	#taskTable>>8
    220  1a1c		       65 55		      adc	R1+1
    221  1a1e		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1a20		       60		      rts
    223  1a21							;
    224  1a21							;==============================================
    225  1a21							;Push R1 onto the stack
    226  1a21							;on entry y = next entry
    227  1a21							;R0 points to the stack space
    228  1a21							;on exit y points to next free byte
    229  1a21				   ipc_pushR1
    230  1a21		       88		      dey
    231  1a22		       a5 55		      lda	R1+1	; PID first
    232  1a24		       91 52		      sta	(R0),y
    233  1a26		       88		      dey
    234  1a27		       a5 54		      lda	R1
    235  1a29		       91 52		      sta	(R0),y
    236  1a2b		       60		      rts
    237  1a2c
    238  1a2c
    239  1a2c
    240  1a2c
    241  1a2c
    242  1a2c
    243  1a2c
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1a2c					      include	"support.asm"
      1  1a2c							;
      2  1a2c							;=====================================================
      3  1a2c							;=====================================================
      4  1a2c							;=====================================================
      5  1a2c							; This marks the start of support functions used by
      6  1a2c							; the IL opcodes.  These are support functions, NOT
      7  1a2c							; the IL code.
      8  1a2c							;=====================================================
      9  1a2c							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1a2c							;=====================================================
     11  1a2c					      Seg	Code
     12  1a2c							;=====================================================
     13  1a2c							; This gets the next two bytes pointed to by ILPC and
     14  1a2c							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1a2c							; is advanced by two, and Y contains 0 on return.
     16  1a2c
     17  1a2c							;
     18  1a2c		       20 30 1a    getILWord  jsr	getILByte	;LSB
     19  1a2f		       aa		      tax
     20  1a30							;
     21  1a30							;=====================================================
     22  1a30							; This gets the next byte pointed to by ILPC and
     23  1a30							; returns it in A.  On return, X is unchanged but Y
     24  1a30							; contains 0.
     25  1a30							;
     26  1a30		       a0 00	   getILByte  ldy	#0
     27  1a32		       b1 43		      lda	(ILPC),y	;get byte
     28  1a34		       08		      php		;save status
     29  1a35		       e6 43		      inc	ILPC	;inc LSB
     30  1a37		       d0 02		      bne	getILb2	;branch if no overflow
     31  1a39		       e6 44		      inc	ILPC+1	;inc MSB
     32  1a3b		       28	   getILb2    plp		;restore status
     33  1a3c		       60		      rts
     34  1a3d							;
     35  1a3d							;=====================================================
     36  1a3d							; Decrement ILPC by one.
     37  1a3d							;
     38  1a3d		       a5 43	   decIL      lda	ILPC
     39  1a3f		       d0 02		      bne	decIL2
     40  1a41		       c6 44		      dec	ILPC+1
     41  1a43		       c6 43	   decIL2     dec	ILPC
     42  1a45		       60		      rts
     43  1a46							;
     44  1a46							;=====================================================
     45  1a46							; Push the ILPC onto the return stack.  Actually, this
     46  1a46							; pushes the address of ILPC+2 since that's the next
     47  1a46							; address to execute.
     48  1a46							;
     49  1a46		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  1a48		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  1a4a		       b0 15		      bcs	pushErr
     52  1a4c		       a5 43		      lda	ILPC
     53  1a4e		       18		      clc
     54  1a4f		       69 02		      adc	#2
     55  1a51		       91 45		      sta	(ILSTACK),y
     56  1a53		       08		      php		;save C bit
     57  1a54		       c8		      iny
     58  1a55		       a5 44		      lda	ILPC+1
     59  1a57		       28		      plp		;restore C
     60  1a58		       69 00		      adc	#0
     61  1a5a		       91 45		      sta	(ILSTACK),y
     62  1a5c		       c8		      iny
     63  1a5d		       84 47		      sty	ILSTACKPTR
     64  1a5f		       18		      clc
     65  1a60		       60		      rts
     66  1a61				   pushErr
     67  1a61		       38		      sec
     68  1a62		       60		      rts
     69  1a63							;
     70  1a63							;=====================================================
     71  1a63							; Pull the top entry from return stack and put into
     72  1a63							; ILPC.
     73  1a63							;
     74  1a63		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1a65		       f0 fa		      beq	pushErr
     76  1a67		       88		      dey
     77  1a68		       b1 45		      lda	(ILSTACK),y
     78  1a6a		       85 44		      sta	ILPC+1
     79  1a6c		       88		      dey
     80  1a6d		       b1 45		      lda	(ILSTACK),y
     81  1a6f		       85 43		      sta	ILPC
     82  1a71		       84 47		      sty	ILSTACKPTR
     83  1a73		       18		      clc
     84  1a74		       60		      rts
     85  1a75							;
     86  1a75							;=====================================================
     87  1a75							; This searches for a specific line number that is in
     88  1a75							; R0.	There are three possible return conditions:
     89  1a75							; Line numbers are now the third byte, the first byte is now **************
     90  1a75							; a pointer to the next line, of course no longer that 53 byte
     91  1a75							; per line.
     92  1a75							;
     93  1a75							; Exact match was found:
     94  1a75							;    * Z set
     95  1a75							;    * CURPTR points to two-byte line number for that
     96  1a75							;	line.
     97  1a75							;
     98  1a75							; Next highest line found:
     99  1a75							;    * Z cleared
    100  1a75							;    * C set
    101  1a75							;    * CURPTR points to two-byte line number for that
    102  1a75							;	line.
    103  1a75							;
    104  1a75							; End of program reached:
    105  1a75							;    * Z cleared
    106  1a75							;    * C cleared
    107  1a75							;    * CURPTR points to first free byte at end of
    108  1a75							;	program.  Ie, it has save value as PROGRAMEND.
    109  1a75							;
    110  1a75							; A, X, and Y are all undefined on return.
    111  1a75							;
    112  1a75
    113  1a75				   findLine
    114  1a75		       ad d2 2e 	      lda	ProgramStart	;Start of program -> CURPTR
    115  1a78		       85 4f		      sta	CURPTR
    116  1a7a		       ad d3 2e 	      lda	ProgramStart+1
    117  1a7d		       85 50		      sta	CURPTR+1
    118  1a7f							;
    119  1a7f							; At end of code?
    120  1a7f							;
    121  1a7f				   iXFER1
    122  1a7f		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1a81		       cd d4 2e 	      cmp	ProgramEnd	; at end of program then stop run
    124  1a84		       d0 0b		      bne	xfer2	; not end
    125  1a86		       a5 50		      lda	CURPTR+1
    126  1a88		       cd d5 2e 	      cmp	ProgramEnd+1
    127  1a8b		       d0 04		      bne	xfer2	;Not at end
    128  1a8d							;
    129  1a8d							; Line not found and the end of the program was
    130  1a8d							; reached.  Return Z and C both clear.
    131  1a8d							;
    132  1a8d		       a9 01		      lda	#1	;clear Z
    133  1a8f		       18		      clc		;clear C
    134  1a90		       60		      rts
    135  1a91							;
    136  1a91							; Check for an exact line number match
    137  1a91							;
    138  1a91		       a5 52	   xfer2      lda	R0
    139  1a93		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1a95		       d1 4f		      cmp	(CURPTR),y
    141  1a97		       d0 08		      bne	xfernotit
    142  1a99		       c8		      iny
    143  1a9a		       a5 53		      lda	R0+1
    144  1a9c		       d1 4f		      cmp	(CURPTR),y
    145  1a9e		       d0 01		      bne	xfernotit	; not a matching line number
    146  1aa0							;
    147  1aa0							; This is exactly the line we want.
    148  1aa0							;
    149  1aa0		       60		      rts		;it matches exactly
    150  1aa1							;
    151  1aa1							; See if this line is greater than the one we're
    152  1aa1							; searching for.
    153  1aa1							;
    154  1aa1		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1aa3		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1aa5		       c5 53		      cmp	R0+1
    157  1aa7		       90 0b		      bcc	xfer3
    158  1aa9		       d0 07		      bne	xfer4
    159  1aab		       88		      dey
    160  1aac		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1aae		       c5 52		      cmp	R0
    162  1ab0		       90 02		      bcc	xfer3
    163  1ab2							;
    164  1ab2							; This line is greater than the one we want, so
    165  1ab2							; return Z clear and C set.
    166  1ab2							;
    167  1ab2		       38	   xfer4      sec		;We found a line number greater
    168  1ab3		       60		      rts		;both conditions set
    169  1ab4							;
    170  1ab4							; Not the line (or droid) we're looking for.  Move to
    171  1ab4							; the next line.
    172  1ab4							;
    173  1ab4		       20 ba 1a    xfer3      jsr	FindNextLine
    174  1ab7		       4c 7f 1a 	      jmp	iXFER1
    175  1aba							;
    176  1aba							;=====================================================
    177  1aba							; This advances CURPTR to the next line.  If there
    178  1aba							; are no more lines, this leaves CURPTR equal to
    179  1aba							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1aba							; CURPTR is pointing to a valid line on entry.  This
    181  1aba							; pointer points to the two-byte line number.
    182  1aba							; Update this points to the 1 byte line length  ****************
    183  1aba							;
    184  1aba				   FindNextLine
    185  1aba		       a0 03		      ldy	#3	;skip line number and length byte
    186  1abc		       84 51		      sty	CUROFF	;this is the new offset
    187  1abe		       a0 00		      ldy	#0
    188  1ac0		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1ac2		       18		      clc
    190  1ac3		       65 4f		      adc	CURPTR
    191  1ac5		       85 4f		      sta	CURPTR
    192  1ac7		       a5 50		      lda	CURPTR+1
    193  1ac9		       69 00		      adc	#0
    194  1acb		       85 50		      sta	CURPTR+1
    195  1acd		       60	   FindNext4  rts
    196  1ace							;
    197  1ace							;=====================================================
    198  1ace							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1ace							; if they are equal, Z clear if not.
    200  1ace							;
    201  1ace		       a5 4f	   AtEnd      lda	CURPTR
    202  1ad0		       cd d4 2e 	      cmp	ProgramEnd
    203  1ad3		       d0 05		      bne	atendexit
    204  1ad5		       a5 50		      lda	CURPTR+1
    205  1ad7		       cd d5 2e 	      cmp	ProgramEnd+1
    206  1ada		       60	   atendexit  rts
    207  1adb							;
    208  1adb
    209  1adb							;
    210  1adb							;=====================================================
    211  1adb							; Convert an ASCII string to a number.  On input,
    212  1adb							; (CURPTR),Y points to the first digit.  This gets
    213  1adb							; digit-by-digit until finding a non-number.  Returns
    214  1adb							; Y pointing to the non-digit, and R0 contains the
    215  1adb							; number.  This does NOT check for valid ranges, so
    216  1adb							; a value like "123456789" will produce something,
    217  1adb							; but not what you had expected.
    218  1adb							;
    219  1adb		       a9 00	   getDecimal lda	#0
    220  1add		       85 52		      sta	R0
    221  1adf		       85 53		      sta	R0+1
    222  1ae1		       85 59		      sta	dpl	;temporary negative flag
    223  1ae3							;
    224  1ae3							; See if it's negative...
    225  1ae3							;
    226  1ae3							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1ae3		       b1 4f		      lda	(CURPTR),y
    228  1ae5		       c9 2d		      cmp	#'-
    229  1ae7		       d0 02		      bne	getDecLoop
    230  1ae9		       e6 59		      inc	dpl	;it's negative
    231  1aeb							;
    232  1aeb		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1aed		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1aef		       c9 30		      cmp	#'0
    235  1af1		       90 36		      bcc	getDdone
    236  1af3		       c9 3a		      cmp	#'9+1
    237  1af5		       b0 32		      bcs	getDdone
    238  1af7		       38		      sec
    239  1af8		       e9 30		      sbc	#'0	;convert to binary
    240  1afa		       48		      pha
    241  1afb							;
    242  1afb							; Now multiply R0 by 10.  Remember that
    243  1afb							; 2*N + 8*N = 10*N.
    244  1afb							;
    245  1afb		       06 52		      asl	R0
    246  1afd		       26 53		      rol	R0+1	;*2
    247  1aff		       a5 52		      lda	R0
    248  1b01		       85 54		      sta	R1
    249  1b03		       a5 53		      lda	R0+1
    250  1b05		       85 55		      sta	R1+1
    251  1b07		       06 52		      asl	R0
    252  1b09		       26 53		      rol	R0+1	;*4
    253  1b0b		       06 52		      asl	R0
    254  1b0d		       26 53		      rol	R0+1	;*8
    255  1b0f		       18		      clc		;now add the partial sums...
    256  1b10		       a5 52		      lda	R0	;...to get *10
    257  1b12		       65 54		      adc	R1
    258  1b14		       85 52		      sta	R0
    259  1b16		       a5 53		      lda	R0+1
    260  1b18		       65 55		      adc	R1+1
    261  1b1a		       85 53		      sta	R0+1
    262  1b1c							;
    263  1b1c							; Add in the new digit
    264  1b1c							;
    265  1b1c		       68		      pla
    266  1b1d		       18		      clc
    267  1b1e		       65 52		      adc	R0
    268  1b20		       85 52		      sta	R0
    269  1b22		       90 02		      bcc	getD2
    270  1b24		       e6 53		      inc	R0+1
    271  1b26							;
    272  1b26							; Move to next character
    273  1b26							;
    274  1b26		       c8	   getD2      iny
    275  1b27		       d0 c2		      bne	getDecLoop
    276  1b29							;
    277  1b29							; All done with digits, so now deal with it being
    278  1b29							; negative.  If zero, then don't check for negative
    279  1b29							; flag.  Ie, -0 is stored as 0.
    280  1b29							;
    281  1b29		       a5 52	   getDdone   lda	R0
    282  1b2b		       05 53		      ora	R0+1
    283  1b2d		       f0 16		      beq	getDone2	;zero
    284  1b2f		       a5 59		      lda	dpl
    285  1b31		       f0 12		      beq	getDone2	;positive
    286  1b33							;
    287  1b33							; Invert all the bits, then add one.
    288  1b33							;
    289  1b33		       a5 52		      lda	R0
    290  1b35		       49 ff		      eor	#$ff
    291  1b37		       85 52		      sta	R0
    292  1b39		       a5 53		      lda	R0+1
    293  1b3b		       49 ff		      eor	#$ff
    294  1b3d		       85 53		      sta	R0+1
    295  1b3f							;
    296  1b3f		       e6 52		      inc	R0
    297  1b41		       d0 02		      bne	getDone2
    298  1b43		       e6 53		      inc	R0+1
    299  1b45				   getDone2
    300  1b45							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1b45							;lda	  R0
    302  1b45							;sta	  $0010
    303  1b45							;lda	  R0+1
    304  1b45							;sta	  $0011
    305  1b45							;lda	  dpl
    306  1b45							;sta	  $012
    307  1b45
    308  1b45		       60		      rts
    309  1b46
    310  1b46							;=====================================================
    311  1b46							; Gets a line of input into LINBUF.
    312  1b46							;
    313  1b46							; On entry:
    314  1b46							;    A contains the prompt character, or 0 if none.
    315  1b46							;    X = 1 Background read
    316  1b46							;    x = 0 Forground read with wait
    317  1b46							;
    318  1b46							; On exit:
    319  1b46							;    CURPTR points to LINBUF
    320  1b46							;    LINBUF contains the line with 0 at the end.
    321  1b46							;    Y has offset to first non-space character
    322  1b46							;    CURROFF has the same as Y.
    323  1b46							;
    324  1b46		       20 95 1b    GetLine    jsr	ReadPrompt
    325  1b49		       e0 00		      cpx	#0
    326  1b4b		       f0 14		      beq	GetLineRetry
    327  1b4d		       ae 79 25 	      ldx	taskPtr
    328  1b50		       bd 7a 25 	      lda	taskTable,x
    329  1b53		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1b55		       d0 3d		      bne	taskWaitingIO
    331  1b57		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1b59		       9d 7a 25 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1b5c		       ce 94 1b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1b5f		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1b61
    336  1b61							;
    337  1b61							; Now read a line and wait for the CR
    338  1b61							;
    339  1b61				   GetLineRetry
    340  1b61		       a9 00		      lda	#0	;Wait for input to complete
    341  1b63		       20 ad 1b 	      jsr	ReadLine
    342  1b66
    343  1b66							;
    344  1b66							; Point to the line we just read
    345  1b66							; Set the current pointer to point to the input line
    346  1b66							;
    347  1b66		       a0 00	   ReadComplete ldy	#0
    348  1b68		       84 51		      sty	CUROFF
    349  1b6a		       a2 35		      ldx	#LINBUF&$ff
    350  1b6c		       86 4f		      stx	CURPTR
    351  1b6e		       a2 2e		      ldx	#LINBUF>>8
    352  1b70		       86 50		      stx	CURPTR+1
    353  1b72							;
    354  1b72							; Output a CR/LF
    355  1b72							;
    356  1b72		       20 74 1d 	      jsr	CRLF
    357  1b75							;
    358  1b75							; If a blank line, prompt again.
    359  1b75							;
    360  1b75		       20 6b 1d 	      jsr	SkipSpaces
    361  1b78		       b1 4f		      lda	(CURPTR),y
    362  1b7a		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1b7c		       20 98 1b 	      jsr	ReadPromptRetry
    364  1b7f		       ae 79 25 	      ldx	taskPtr	;if this task is waiting for IO
    365  1b82		       bd 7a 25 	      lda	taskTable,x	;then get out, wait for line to
    366  1b85		       29 40		      and	#TASKWAITIO	;Complete again
    367  1b87		       d0 0b		      bne	taskWaitingIO
    368  1b89		       4c 61 1b 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1b8c
    370  1b8c				   GetLineDone
    371  1b8c		       ae 79 25 	      ldx	taskPtr
    372  1b8f		       a9 80		      lda	#TASKACTIVE
    373  1b91		       9d 7a 25 	      sta	taskTable,x	;IO is complete
    374  1b94
    375  1b94				   taskWaitingIO
    376  1b94		       60		      rts
    377  1b95
    378  1b95							;
    379  1b95							;=======================================================================
    380  1b95							; Display the prompt character
    381  1b95							; On entry
    382  1b95							;	    A contains the prompt character
    383  1b95							; On exit
    384  1b95							;	    The readbuffer index is reset to 0
    385  1b95							;
    386  1b95		       8d bc 2e    ReadPrompt sta	promptChar
    387  1b98
    388  1b98							;
    389  1b98							; Prompt
    390  1b98							;
    391  1b98
    392  1b98		       ad bc 2e    ReadPromptRetry lda	promptChar
    393  1b9b		       09 00		      ora	#0	;any prompt?
    394  1b9d		       f0 08		      beq	getlinenp
    395  1b9f		       20 bd 1e 	      jsr	VOUTCH
    396  1ba2		       a9 20		      lda	#$20
    397  1ba4		       20 bd 1e 	      jsr	VOUTCH	;Space after prompt
    398  1ba7							;
    399  1ba7		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1ba9		       8e b9 2e 	      stx	getlinx
    401  1bac		       60		      rts
    402  1bad							;
    403  1bad							;===============================================================
    404  1bad							; This fuction is the driver for the line input
    405  1bad							; on call if a = 0 then it waits for all input
    406  1bad							;	      a = 1 then nowait for input
    407  1bad							; On exit
    408  1bad							;		       c clear if not complete line
    409  1bad							;		       c set if it was a complete line
    410  1bad
    411  1bad				   ReadLine
    412  1bad		       8d bb 2e 	      sta	inputNoWait
    413  1bb0		       c9 00		      cmp	#0
    414  1bb2		       f0 05		      beq	getline1
    415  1bb4		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1bb7		       f0 2b		      beq	GetLineNoWait
    417  1bb9		       20 c0 1e    getline1   jsr	VGETCH
    418  1bbc					      if	CTMON65
    419  1bbc		       48		      pha
    420  1bbd		       20 bd 1e 	      jsr	VOUTCH	;echo echo echo
    421  1bc0		       68		      pla
    422  1bc1					      endif
    423  1bc1		       c9 0d		      cmp	#CR
    424  1bc3		       f0 15		      beq	getlind	;end of line
    425  1bc5		       c9 08		      cmp	#BS	;backspace?
    426  1bc7		       f0 1d		      beq	getlinebs
    427  1bc9		       ae b9 2e 	      ldx	getlinx
    428  1bcc		       9d 35 2e 	      sta	LINBUF,x
    429  1bcf		       e8		      inx
    430  1bd0		       8e b9 2e 	      stx	getlinx
    431  1bd3		       ad bb 2e 	      lda	inputNoWait
    432  1bd6		       f0 e1		      beq	getline1
    433  1bd8		       d0 0a		      bne	GetLineNoWait
    434  1bda							;
    435  1bda							; CR was hit
    436  1bda							;
    437  1bda		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1bdc		       ae b9 2e 	      ldx	getlinx
    439  1bdf		       9d 35 2e 	      sta	LINBUF,x
    440  1be2
    441  1be2		       38		      sec		; Carry set then cr received
    442  1be3		       60		      rts
    443  1be4
    444  1be4				   GetLineNoWait
    445  1be4		       18		      clc		; Carry clear no end of line
    446  1be5		       60		      rts
    447  1be6							;
    448  1be6							; Backspace was hit
    449  1be6							;
    450  1be6		       ae b9 2e    getlinebs  ldx	getlinx
    451  1be9		       f0 0e		      beq	getlineEOL	;at start of line
    452  1beb		       ca		      dex
    453  1bec		       8e b9 2e 	      stx	getlinx
    454  1bef		       20 dc 14    getlinepbs jsr	puts
      0  1bf2					      db	27,"[K",0
      1  1bf2		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1bf6		       4c b9 1b 	      jmp	getline1
    457  1bf9		       a9 20	   getlineEOL lda	#SPACE
    458  1bfb		       20 bd 1e 	      jsr	VOUTCH
    459  1bfe		       d0 ef		      bne	getlinepbs
    460  1c00							;
    461  1c00							;=====================================================
    462  1c00							; Count the length of the line currently in LINBUF
    463  1c00							; starting at offset Y.  Returns the length in X.  The
    464  1c00							; starting offset in Y should point past the ASCII
    465  1c00							; line number.  Also counts the trailing NULL and two
    466  1c00							; extra bytes for where the line number will be.
    467  1c00							; Update must now include leading length byte not the null at end ****************
    468  1c00							;
    469  1c00				   getLineLength
    470  1c00		       a2 00		      ldx	#0	;size
    471  1c02		       b9 35 2e    getLineL2  lda	LINBUF,y
    472  1c05		       f0 04		      beq	getLineL3
    473  1c07		       c8		      iny
    474  1c08		       e8		      inx
    475  1c09		       d0 f7		      bne	getLineL2
    476  1c0b		       e8	   getLineL3  inx		;count null at end
    477  1c0c		       e8		      inx		;line number LSB
    478  1c0d		       e8		      inx		;MSB
    479  1c0e		       e8		      inx		;change: count new leading line length
    480  1c0f		       8e cf 2e 	      stx	lineLength
    481  1c12		       60		      rts
    482  1c13							;
    483  1c13							;=====================================================
    484  1c13							; Count the length of the line pointed to by CURPTR.
    485  1c13							; This also counts the line number and the terminating
    486  1c13							; null.  Ie, this string returns 8:
    487  1c13							;
    488  1c13							; <lineLow><lineHi>Hello<null>
    489  1c13							;
    490  1c13							; Another way of looking at it: add the return value
    491  1c13							; to the CURPTR and it'll point to the next line's
    492  1c13							; line number.  Returns the value in Y.
    493  1c13							; Update to ject get the leading byte length ********************
    494  1c13							;
    495  1c13							;getCURPTRLength
    496  1c13							;		ldy	CURPTR
    497  1c13							;		ldy	#3	;change: skip line number and leading length byte
    498  1c13							;getCLineL2	lda	(CURPTR),y
    499  1c13							;		beq	getCLineL3
    500  1c13							;		iny
    501  1c13							;		bne	getCLineL2
    502  1c13							;getCLineL3	iny		;count null at end
    503  1c13							;		rts
    504  1c13
    505  1c13							;
    506  1c13							;=====================================================
    507  1c13							; This saves ILPC.  This saves to a single save area,
    508  1c13							; so it can't be called more than once.
    509  1c13							;
    510  1c13		       a5 43	   saveIL     lda	ILPC
    511  1c15		       8d cb 2e 	      sta	tempIL
    512  1c18		       a5 44		      lda	ILPC+1
    513  1c1a		       8d cc 2e 	      sta	tempIL+1
    514  1c1d		       60		      rts
    515  1c1e							;
    516  1c1e							;=====================================================
    517  1c1e							; This restores ILPC.
    518  1c1e							;
    519  1c1e		       ad cb 2e    restoreIL  lda	tempIL
    520  1c21		       85 43		      sta	ILPC
    521  1c23		       ad cc 2e 	      lda	tempIL+1
    522  1c26		       85 44		      sta	ILPC+1
    523  1c28		       60		      rts
    524  1c29							;
    525  1c29							;=====================================================
    526  1c29							; This pushes R0 onto the stack.
    527  1c29							;
    528  1c29		       8c c2 2e    pushR0     sty	rtemp1
    529  1c2c		       a4 4a		      ldy	MATHSTACKPTR
    530  1c2e		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1c30		       b0 38		      bcs	pusherr
    532  1c32		       a5 52		      lda	R0
    533  1c34		       91 48		      sta	(MATHSTACK),y
    534  1c36		       c8		      iny
    535  1c37		       a5 53		      lda	R0+1
    536  1c39		       91 48		      sta	(MATHSTACK),y
    537  1c3b		       c8		      iny
    538  1c3c		       84 4a		      sty	MATHSTACKPTR
    539  1c3e		       ac c2 2e 	      ldy	rtemp1
    540  1c41		       18		      clc
    541  1c42		       60		      rts
    542  1c43
    543  1c43							;=====================================================
    544  1c43							; This pushes curptr basic current line onto the call stack.
    545  1c43							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1c43
    547  1c43				   pushLN
    548  1c43		       8d c3 2e 	      STA	rtemp1+1	; Store type of push being done
    549  1c46		       8c c2 2e 	      sty	rtemp1
    550  1c49		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  1c4b		       c5 4d		      cmp	GOSUBSTACKPTR
    552  1c4d		       90 1b		      bcc	pusherr	; No error
    553  1c4f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  1c51		       a2 00		      ldx	#0	; Start of bytes to copy
    555  1c53				   pushLoop
    556  1c53		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  1c55		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  1c57		       c8		      iny		; Next destination
    559  1c58		       e8		      inx		; Next Source byte
    560  1c59		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  1c5b		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  1c5d
    563  1c5d		       ad c3 2e    pushDone   lda	rtemp1+1	; Type of stack entry
    564  1c60		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  1c62		       c8		      iny		; Next entry
    566  1c63
    567  1c63		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  1c65		       ac c2 2e 	      ldy	rtemp1
    569  1c68		       18		      clc
    570  1c69		       60		      rts
    571  1c6a				   pusherr
    572  1c6a		       38		      sec
    573  1c6b		       60		      rts
    574  1c6c							;=====================================================
    575  1c6c							; This pops Top Off gosub call Stack and
    576  1c6c							; places it in CURPTR/CUROFF.
    577  1c6c							; This checks if the type = 1 GOSUB
    578  1c6c							; if not it removes what ever is on the stack
    579  1c6c							; until it finds the next return. Allowing
    580  1c6c							; a return from within a for/next
    581  1c6c							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  1c6c		       8c c2 2e    popLN      sty	rtemp1
    583  1c6f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  1c71		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  1c73
    586  1c73				   popContinue
    587  1c73		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  1c75		       90 22		      bcc	poperr	; Process an error
    589  1c77
    590  1c77		       88		      dey		; Position to read entry type
    591  1c78		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  1c7a		       8d c3 2e 	      sta	rtemp1+1	; Save to be returned
    593  1c7d		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  1c7f		       f0 04		      beq	popLoop	; Restore the line
    595  1c81		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  1c83		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  1c85
    598  1c85				   popLoop
    599  1c85		       88		      dey
    600  1c86		       ca		      dex
    601  1c87		       b1 4b		      lda	(GOSUBSTACK),y
    602  1c89		       95 4f		      sta	CURPTR,x
    603  1c8b		       e0 00		      cpx	#0
    604  1c8d		       d0 f6		      bne	popLoop	; Loop until all moved
    605  1c8f
    606  1c8f
    607  1c8f		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  1c91		       ac c2 2e 	      ldy	rtemp1
    609  1c94		       ad c3 2e 	      lda	rtemp1+1	; get the type of return
    610  1c97		       18		      clc
    611  1c98		       60		      rts
    612  1c99
    613  1c99		       38	   poperr     sec
    614  1c9a		       60		      rts
    615  1c9b
    616  1c9b		       88	   popSkipEntry dey
    617  1c9c		       88		      dey
    618  1c9d		       88		      dey
    619  1c9e		       4c 73 1c 	      jmp	popContinue
    620  1ca1
    621  1ca1							;
    622  1ca1							;=====================================================
    623  1ca1							; This pushes R1 onto the stack
    624  1ca1							;
    625  1ca1		       8c c2 2e    pushR1     sty	rtemp1
    626  1ca4		       a4 4a		      ldy	MATHSTACKPTR
    627  1ca6		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  1ca8		       b0 ef		      bcs	poperr
    629  1caa		       a5 54		      lda	R1
    630  1cac		       91 48		      sta	(MATHSTACK),y
    631  1cae		       c8		      iny
    632  1caf		       a5 55		      lda	R1+1
    633  1cb1		       91 48		      sta	(MATHSTACK),y
    634  1cb3		       c8		      iny
    635  1cb4		       84 4a		      sty	MATHSTACKPTR
    636  1cb6		       ac c2 2e 	      ldy	rtemp1
    637  1cb9		       18		      clc
    638  1cba		       60		      rts
    639  1cbb							;
    640  1cbb							;=====================================================
    641  1cbb							; This pops Top Of Stack and places it in R0.
    642  1cbb							;
    643  1cbb		       8c c2 2e    popR0      sty	rtemp1
    644  1cbe		       a4 4a		      ldy	MATHSTACKPTR
    645  1cc0		       f0 d7		      beq	poperr
    646  1cc2		       88		      dey
    647  1cc3		       b1 48		      lda	(MATHSTACK),y
    648  1cc5		       85 53		      sta	R0+1
    649  1cc7		       88		      dey
    650  1cc8		       b1 48		      lda	(MATHSTACK),y
    651  1cca		       85 52		      sta	R0
    652  1ccc		       84 4a		      sty	MATHSTACKPTR
    653  1cce		       ac c2 2e 	      ldy	rtemp1
    654  1cd1		       18		      clc
    655  1cd2		       60		      rts
    656  1cd3
    657  1cd3							;
    658  1cd3							;=====================================================
    659  1cd3							; This pops TOS and places it in R1.
    660  1cd3							;
    661  1cd3		       8c c2 2e    popR1      sty	rtemp1
    662  1cd6		       a4 4a		      ldy	MATHSTACKPTR
    663  1cd8		       f0 bf		      beq	poperr
    664  1cda		       88		      dey
    665  1cdb		       b1 48		      lda	(MATHSTACK),y
    666  1cdd		       85 55		      sta	R1+1
    667  1cdf		       88		      dey
    668  1ce0		       b1 48		      lda	(MATHSTACK),y
    669  1ce2		       85 54		      sta	R1
    670  1ce4		       84 4a		      sty	MATHSTACKPTR
    671  1ce6		       ac c2 2e 	      ldy	rtemp1
    672  1ce9		       60		      rts
    673  1cea							;
    674  1cea							;=====================================================
    675  1cea							; This pops TOS and places it in MQ.
    676  1cea							;
    677  1cea		       8c c2 2e    popMQ      sty	rtemp1
    678  1ced		       a4 4a		      ldy	MATHSTACKPTR
    679  1cef		       f0 a8		      beq	poperr
    680  1cf1		       88		      dey
    681  1cf2		       b1 48		      lda	(MATHSTACK),y
    682  1cf4		       85 57		      sta	MQ+1
    683  1cf6		       88		      dey
    684  1cf7		       b1 48		      lda	(MATHSTACK),y
    685  1cf9		       85 56		      sta	MQ
    686  1cfb		       84 4a		      sty	MATHSTACKPTR
    687  1cfd		       ac c2 2e 	      ldy	rtemp1
    688  1d00		       60		      rts
    689  1d01							;
    690  1d01							;=====================================================
    691  1d01							; This assists with multiplication and division by
    692  1d01							; looking at R0 and R1 and saving a flag as to what
    693  1d01							; sign the result will be.  Math is always done on
    694  1d01							; positive numbers, so this converts negative numbers
    695  1d01							; into positives.  On exit, R0 and R1 are both
    696  1d01							; positive.  If the signs were different then 'signs'
    697  1d01							; will be non-zero.
    698  1d01							;
    699  1d01		       a9 00	   SaveSigns  lda	#0
    700  1d03		       8d c1 2e 	      sta	sign	;assume positive
    701  1d06		       a5 53		      lda	R0+1	;MSB
    702  1d08		       10 13		      bpl	SaveSigns1
    703  1d0a		       ee c1 2e 	      inc	sign	;it's negative
    704  1d0d		       49 ff		      eor	#$ff	;flip bits
    705  1d0f		       85 53		      sta	R0+1
    706  1d11		       a5 52		      lda	R0
    707  1d13		       49 ff		      eor	#$ff
    708  1d15		       85 52		      sta	R0
    709  1d17		       e6 52		      inc	R0
    710  1d19		       d0 02		      bne	SaveSigns1
    711  1d1b		       e6 53		      inc	R0+1
    712  1d1d		       a5 55	   SaveSigns1 lda	R1+1
    713  1d1f		       10 1a		      bpl	SaveSigns2
    714  1d21		       48		      pha
    715  1d22		       ad c1 2e 	      lda	sign
    716  1d25		       49 01		      eor	#1
    717  1d27		       8d c1 2e 	      sta	sign
    718  1d2a		       68		      pla
    719  1d2b		       49 ff		      eor	#$ff	;flip bits
    720  1d2d		       85 55		      sta	R1+1
    721  1d2f		       a5 54		      lda	R1
    722  1d31		       49 ff		      eor	#$ff
    723  1d33		       85 54		      sta	R1
    724  1d35		       e6 54		      inc	R1
    725  1d37		       d0 02		      bne	SaveSigns2
    726  1d39		       e6 55		      inc	R1+1
    727  1d3b		       60	   SaveSigns2 rts
    728  1d3c							;
    729  1d3c							;=====================================================
    730  1d3c							; This looks at the value of 'signs' and will convert
    731  1d3c							; both R0 and R1 to negative if set.
    732  1d3c							;
    733  1d3c				   RestoreSigns
    734  1d3c		       ad c1 2e 	      lda	sign
    735  1d3f		       f0 28		      beq	restoresigns2
    736  1d41							;
    737  1d41		       a5 52		      lda	R0
    738  1d43		       d0 02		      bne	restoresigns3
    739  1d45		       c6 53		      dec	R0+1
    740  1d47				   restoresigns3
    741  1d47		       c6 52		      dec	R0
    742  1d49		       a5 52		      lda	R0
    743  1d4b		       49 ff		      eor	#$ff
    744  1d4d		       85 52		      sta	R0
    745  1d4f		       a5 53		      lda	R0+1
    746  1d51		       49 ff		      eor	#$ff
    747  1d53		       85 53		      sta	R0+1
    748  1d55							;
    749  1d55		       a5 54		      lda	R1
    750  1d57		       d0 02		      bne	restoresigns4
    751  1d59		       c6 55		      dec	R1+1
    752  1d5b				   restoresigns4
    753  1d5b		       c6 54		      dec	R1
    754  1d5d		       a5 54		      lda	R1
    755  1d5f		       49 ff		      eor	#$ff
    756  1d61		       85 54		      sta	R1
    757  1d63		       a5 55		      lda	R1+1
    758  1d65		       49 ff		      eor	#$ff
    759  1d67		       85 55		      sta	R1+1
    760  1d69							;
    761  1d69				   restoresigns2
    762  1d69		       60		      rts
    763  1d6a							;
    764  1d6a							;=====================================================
    765  1d6a							; Skip over spaces.  Returns Y with the offset to
    766  1d6a							; either the last character in the line, or the first
    767  1d6a							; non-space character.
    768  1d6a							;
    769  1d6a
    770  1d6a		       c8	   skipsp2    iny
    771  1d6b		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  1d6d		       f0 04		      beq	Skip3	;end of line
    773  1d6f		       c9 20		      cmp	#SPACE
    774  1d71		       f0 f7		      beq	skipsp2
    775  1d73		       60	   Skip3      rts
    776  1d74							;*********************************************************
    777  1d74							; Output a CR/LF combination to the console.  Preserves
    778  1d74							; all registers.
    779  1d74							;
    780  1d74		       48	   tbcrlf     pha
    781  1d75		       a9 0d		      lda	#CR
    782  1d77		       20 bd 1e 	      jsr	VOUTCH
    783  1d7a		       a9 0a		      lda	#LF
    784  1d7c		       20 bd 1e 	      jsr	VOUTCH
    785  1d7f		       68		      pla
    786  1d80		       60		      rts
    787  1d81							;
    788  1d81							;=====================================================
    789  1d81							; Some logic to print the Line of basic code being executed
    790  1d81		       24 40	   idbgBasic  bit	ILTrace
    791  1d83		       50 70		      bvc	dbgBasicNone
    792  1d85		       98		      tya
    793  1d86		       48		      pha
    794  1d87		       20 f1 1e 	      jsr	SetOutDebug
    795  1d8a		       20 ff 14 	      jsr	PrtPrgLine
    796  1d8d		       20 74 1d 	      jsr	CRLF
    797  1d90		       a5 40		      lda	ILTrace
    798  1d92		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    799  1d94		       f0 5a		      beq	dbgBasicDone
    800  1d96		       20 08 1f 	      jsr	SetInDebug
    801  1d99		       20 dc 14 	      jsr	puts
      0  1d9c					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1d9c		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    803  1dd9				   dbgBasicLoop
    804  1dd9		       20 c0 1e 	      jsr	VGETCH
    805  1ddc		       20 74 1d 	      jsr	CRLF
    806  1ddf		       20 2c 1f 	      jsr	SetInDebugEnd
    807  1de2
    808  1de2		       c9 73		      cmp	#'s	; Quit program
    809  1de4		       f0 12		      beq	dbgBasicStop
    810  1de6
    811  1de6		       c9 64		      cmp	#'d	; Display Variables
    812  1de8		       d0 06		      bne	dbgBasicDone
    813  1dea
    814  1dea		       20 3e 15 	      jsr	PrintAllVars
    815  1ded		       18		      clc
    816  1dee		       90 e9		      bcc	dbgBasicLoop	; Next char
    817  1df0
    818  1df0		       20 1f 1f    dbgBasicDone jsr	SetOutDebugEnd
    819  1df3		       68		      pla
    820  1df4		       a8		      tay
    821  1df5		       4c c2 02    dbgBasicNone jmp	NextIL
    822  1df8
    823  1df8				   dbgBasicStop
    824  1df8		       20 1f 1f 	      jsr	SetOutDebugEnd
    825  1dfb		       68		      pla
    826  1dfc		       a8		      tay
    827  1dfd		       4c 2d 06 	      jmp	iFIN
    828  1e00							;
    829  1e00							;=====================================================
    830  1e00							; This is some debug logic which displays the current
    831  1e00							; value of the ILPC and the line buffer.
    832  1e00							;
    833  1e00		       24 40	   dbgLine    bit	ILTrace
    834  1e02		       30 01		      bmi	dbgPrt
    835  1e04		       60		      rts
    836  1e05				   dbgPrt
    837  1e05		       20 f1 1e 	      jsr	SetOutDebug
    838  1e08		       20 dc 14 	      jsr	puts
      0  1e0b					      db	"ILPC: ",0
      1  1e0b		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    840  1e12		       a5 44		      lda	ILPC+1
    841  1e14		       20 bf 14 	      jsr	OUTHEX
    842  1e17		       a5 43		      lda	ILPC
    843  1e19		       20 bf 14 	      jsr	OUTHEX
    844  1e1c		       a9 20		      lda	#SPACE
    845  1e1e		       20 bd 1e 	      jsr	VOUTCH
    846  1e21		       a0 00		      ldy	#0
    847  1e23		       b1 43		      lda	(ILPC),y
    848  1e25		       20 bf 14 	      jsr	OUTHEX
    849  1e28							;
    850  1e28							; Display the CURPTR value and offset
    851  1e28							;
    852  1e28		       20 dc 14 	      jsr	puts
      0  1e2b					      db	", CURPTR: ",0
      1  1e2b		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    854  1e36		       a5 50		      lda	CURPTR+1
    855  1e38		       20 bf 14 	      jsr	OUTHEX
    856  1e3b		       a5 4f		      lda	CURPTR
    857  1e3d		       20 bf 14 	      jsr	OUTHEX
    858  1e40		       a9 2b		      lda	#'+
    859  1e42		       20 bd 1e 	      jsr	VOUTCH
    860  1e45		       a5 51		      lda	CUROFF
    861  1e47		       20 bf 14 	      jsr	OUTHEX
    862  1e4a							;
    863  1e4a		       20 74 1d 	      jsr	CRLF
    864  1e4d		       20 1f 1f 	      jsr	SetOutDebugEnd
    865  1e50		       20 83 1e 	      jsr	ILChkRange
    866  1e53		       b0 02		      bcs	dbgLineErr
    867  1e55		       18		      clc
    868  1e56		       60		      rts
    869  1e57
    870  1e57				   dbgLineErr
    871  1e57		       20 f1 1e 	      jsr	SetOutDebug
    872  1e5a		       20 dc 14 	      jsr	puts
      0  1e5d					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1e5d		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    874  1e7e		       20 1f 1f 	      jsr	SetOutDebugEnd
    875  1e81		       38		      sec
    876  1e82		       60		      rts
    877  1e83
    878  1e83		       a5 44	   ILChkRange lda	ILPC+1
    879  1e85		       c9 21		      cmp	#IL>>8
    880  1e87		       90 18		      bcc	ILBadRange
    881  1e89		       d0 06		      bne	ILChkHigh
    882  1e8b
    883  1e8b		       a5 43		      lda	ILPC
    884  1e8d		       c9 5c		      cmp	#IL&$ff
    885  1e8f		       90 10		      bcc	ILBadRange
    886  1e91
    887  1e91		       a5 44	   ILChkHigh  lda	ILPC+1
    888  1e93		       c9 25		      cmp	#ILEND>>8
    889  1e95		       90 08		      bcc	ILGoodRange
    890  1e97		       d0 08		      bne	ILBadRange
    891  1e99
    892  1e99		       a5 43		      lda	ILPC
    893  1e9b		       c9 32		      cmp	#ILEND&$ff
    894  1e9d		       b0 02		      bcs	ILBadRange
    895  1e9f
    896  1e9f		       18	   ILGoodRange clc
    897  1ea0		       60		      rts
    898  1ea1				   ILBadRange
    899  1ea1		       38		      sec
    900  1ea2		       60		      rts
    901  1ea3
    902  1ea3
    903  1ea3							;=====================================================
    904  1ea3							; Set output vector to the console output function
    905  1ea3							;
    906  1ea3				   SetOutConsole
    907  1ea3		       48		      pha
    908  1ea4		       a9 0c		      lda	#OUTCH&$ff
    909  1ea6		       8d c6 2e 	      sta	BOutVec
    910  1ea9		       a9 f0		      lda	#OUTCH>>8
    911  1eab		       8d c7 2e 	      sta	BOutVec+1
    912  1eae		       68		      pla
    913  1eaf		       60		      rts
    914  1eb0
    915  1eb0				   SetInConsole
    916  1eb0		       48		      pha
    917  1eb1		       a9 09		      lda	#GETCH&$ff
    918  1eb3		       8d c8 2e 	      sta	BInVec
    919  1eb6		       a9 f0		      lda	#GETCH>>8
    920  1eb8		       8d c9 2e 	      sta	BInVec+1
    921  1ebb		       68		      pla
    922  1ebc		       60		      rts
    923  1ebd
    924  1ebd							;=====================================================
    925  1ebd							; Jump to the output/input function in BOutVec/BInVec
    926  1ebd							;
    927  1ebd		       6c c6 2e    VOUTCH     jmp	(BOutVec)
    928  1ec0		       6c c8 2e    VGETCH     jmp	(BInVec)
    929  1ec3
    930  1ec3
    931  1ec3							;====================================================
    932  1ec3							;Clear the terminal assume it is ansii or vt100
    933  1ec3							;
    934  1ec3				   iCLEARSCREEN
    935  1ec3		       20 dc 14 	      jsr	puts
      0  1ec6					      db	$1b,'[,'2,'J,0
      1  1ec6		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    937  1ecb		       4c c2 02 	      jmp	NextIL
    938  1ece
    939  1ece							;====================================================
    940  1ece							; Push true and false onto math stack
    941  1ece				   pushTrue
    942  1ece		       a9 ff		      lda	#$ff
    943  1ed0		       85 52	   pushTF     sta	R0
    944  1ed2		       85 53		      sta	R0+1
    945  1ed4		       20 29 1c 	      jsr	pushR0
    946  1ed7		       60		      rts
    947  1ed8		       a9 00	   pushFalse  lda	#0
    948  1eda		       f0 f4		      beq	pushTF
    949  1edc
    950  1edc							;======================================================
    951  1edc							; Copy stack top to R1
    952  1edc				   CopyStackR1
    953  1edc		       98		      tya
    954  1edd		       48		      pha
    955  1ede		       a4 4a		      ldy	MATHSTACKPTR
    956  1ee0		       88		      dey
    957  1ee1		       b1 48		      lda	(MATHSTACK),y
    958  1ee3		       85 55		      sta	R1+1
    959  1ee5		       88		      dey
    960  1ee6		       b1 48		      lda	(MATHSTACK),y
    961  1ee8		       85 54		      sta	R1
    962  1eea		       68		      pla
    963  1eeb		       a8		      tay
    964  1eec		       60		      rts
    965  1eed
    966  1eed
    967  1eed							;====================================================
    968  1eed							;Swap the out debug call for standard calls
    969  1eed					      if	USEDEBUGPORT
    970  1eed		       00 00	   DebugIOSave ds	2
    971  1eef		       00 00	   DebugInSave ds	2
    972  1ef1					      endif
    973  1ef1				   SetOutDebug
    974  1ef1					      if	USEDEBUGPORT
    975  1ef1		       ad c6 2e 	      lda	BOutVec
    976  1ef4		       8d ed 1e 	      sta	DebugIOSave
    977  1ef7		       ad c7 2e 	      lda	BOutVec+1
    978  1efa		       8d ee 1e 	      sta	DebugIOSave+1
    979  1efd		       a9 43		      lda	#OUTDEBUG&$ff	; Put the Debug output
    980  1eff		       8d c6 2e 	      sta	BOutVec
    981  1f02		       a9 1f		      lda	#OUTDEBUG>>8
    982  1f04		       8d c7 2e 	      sta	BOutVec+1
    983  1f07					      endif
    984  1f07		       60		      rts
    985  1f08				   SetInDebug
    986  1f08					      if	USEDEBUGPORT
    987  1f08		       ad c8 2e 	      lda	BInVec
    988  1f0b		       8d ef 1e 	      sta	DebugInSave
    989  1f0e		       ad c9 2e 	      lda	BInVec+1
    990  1f11		       8d f0 1e 	      sta	DebugInSave+1
    991  1f14		       a9 47		      lda	#INDEBUG&$ff
    992  1f16		       8d c8 2e 	      sta	BInVec
    993  1f19		       a9 1f		      lda	#INDEBUG>>8
    994  1f1b		       8d c9 2e 	      sta	BInVec+1
    995  1f1e					      endif
    996  1f1e		       60		      rts
    997  1f1f				   SetOutDebugEnd
    998  1f1f					      if	USEDEBUGPORT
    999  1f1f		       ad ed 1e 	      lda	DebugIOSave
   1000  1f22		       8d c6 2e 	      sta	BOutVec
   1001  1f25		       ad ee 1e 	      lda	DebugIOSave+1
   1002  1f28		       8d c7 2e 	      sta	BOutVec+1
   1003  1f2b					      endif
   1004  1f2b		       60		      rts
   1005  1f2c				   SetInDebugEnd
   1006  1f2c					      if	USEDEBUGPORT
   1007  1f2c		       ad ef 1e 	      lda	DebugInSave
   1008  1f2f		       8d c8 2e 	      sta	BInVec
   1009  1f32		       ad ee 1e 	      lda	DebugIOSave+1
   1010  1f35		       8d c9 2e 	      sta	BInVec+1
   1011  1f38					      endif
   1012  1f38		       60		      rts
   1013  1f39							;
   1014  1f39							;====================================================
   1015  1f39							; Output to the debug console
   1016  1f39							;     x = high address byte
   1017  1f39							;     y = low address byte
   1018  1f39							;     a = Terminator for string
   1019  1f39				   DebugWrite
   1020  1f39		       20 f1 1e 	      jsr	SetOutDebug
   1021  1f3c		       20 21 15 	      jsr	PrtStr
   1022  1f3f		       20 1f 1f 	      jsr	SetOutDebugEnd
   1023  1f42		       60		      rts
   1024  1f43
   1025  1f43				   OUTDEBUG
   1026  1f43		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1027  1f46		       60		      RTS
   1028  1f47
   1029  1f47		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1030  1f4a		       29 01		      and	#$01
   1031  1f4c		       f0 f9		      beq	INDEBUG
   1032  1f4e		       ad 21 e0 	      lda	DEBUGPORT+1
   1033  1f51		       60		      rts
   1034  1f52
   1035  1f52							;======================================================================
   1036  1f52							;Copy Quoted string to buffer, terminate with 0 byte
   1037  1f52							; R0  Source tring points to tString type
   1038  1f52							; x is terminator
   1039  1f52							; R1 points to destinition location
   1040  1f52							; On exit R0 contains length of copy Plus Term and leading bytes
   1041  1f52
   1042  1f52				   qstrcpy
   1043  1f52		       20 29 1c 	      jsr	pushR0
   1044  1f55		       20 a2 1f 	      jsr	IncR0	; point past the tString
   1045  1f58		       20 a2 1f 	      jsr	IncR0	; Point Past the opening "
   1046  1f5b		       a2 22		      ldx	#'"	; copy Termination
   1047  1f5d		       20 77 1f 	      jsr	pstrcpy
   1048  1f60		       20 a2 1f 	      jsr	IncR0	; point to "
   1049  1f63		       20 a2 1f 	      jsr	IncR0	; Point to next free byte
   1050  1f66		       20 d3 1c 	      jsr	popR1
   1051  1f69		       38		      sec
   1052  1f6a		       a5 52		      lda	R0
   1053  1f6c		       e5 54		      sbc	R1
   1054  1f6e		       85 52		      sta	R0
   1055  1f70		       a5 53		      lda	R0+1
   1056  1f72		       e5 55		      sbc	R1+1
   1057  1f74		       85 53		      sta	R0+1
   1058  1f76		       60		      rts
   1059  1f77
   1060  1f77							;=========================================================================
   1061  1f77							;Copy string from R0 to R1, terminator in x
   1062  1f77							; On exit    R0 contains the length of the copy
   1063  1f77				   pstrcpy
   1064  1f77		       a0 00		      ldy	#0
   1065  1f79		       86 58		      stx	R2
   1066  1f7b
   1067  1f7b				   strcpyLoop
   1068  1f7b		       b1 52		      lda	(R0),y
   1069  1f7d		       c5 58		      cmp	R2
   1070  1f7f		       f0 0a		      beq	strcpyDone
   1071  1f81		       91 54		      sta	(R1),y
   1072  1f83		       20 a2 1f 	      jsr	IncR0
   1073  1f86		       20 90 1f 	      jsr	IncR1
   1074  1f89		       90 f0		      bcc	strcpyLoop
   1075  1f8b				   strcpyDone
   1076  1f8b		       a9 00		      lda	#0
   1077  1f8d		       91 54		      sta	(R1),y
   1078  1f8f
   1079  1f8f		       60		      rts
   1080  1f90
   1081  1f90							;=========================================================================
   1082  1f90							; on exit c is set on overflow
   1083  1f90				   IncR1
   1084  1f90		       48		      pha
   1085  1f91		       18		      clc
   1086  1f92		       a9 01		      lda	#1
   1087  1f94		       65 54		      adc	R1
   1088  1f96		       85 54		      sta	R1
   1089  1f98		       90 06		      bcc	IncR1Done
   1090  1f9a		       a9 00		      lda	#0
   1091  1f9c		       65 55		      adc	R1+1
   1092  1f9e		       85 55		      sta	R1+1
   1093  1fa0				   IncR1Done
   1094  1fa0		       68		      pla
   1095  1fa1		       60		      rts
   1096  1fa2							;=========================================================================
   1097  1fa2							; on exit c is set on overflow
   1098  1fa2				   IncR0
   1099  1fa2		       48		      pha
   1100  1fa3		       18		      clc
   1101  1fa4		       a9 01		      lda	#1
   1102  1fa6		       65 52		      adc	R0
   1103  1fa8		       85 52		      sta	R0
   1104  1faa		       90 06		      bcc	IncR0Done
   1105  1fac		       a9 00		      lda	#0
   1106  1fae		       65 53		      adc	R0+1
   1107  1fb0		       85 53		      sta	R0+1
   1108  1fb2				   IncR0Done
   1109  1fb2		       68		      pla
   1110  1fb3		       60		      rts
   1111  1fb4
   1112  1fb4
   1113  1fb4
   1114  1fb4
   1115  1fb4
   1116  1fb4
   1117  1fb4
   1118  1fb4
   1119  1fb4
   1120  1fb4
   1121  1fb4
   1122  1fb4
   1123  1fb4
   1124  1fb4
   1125  1fb4
   1126  1fb4
------- FILE mytb.asm
   2345  1fb4
   2346  1fb4					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  1fb4					      include	"storage.asm"
      1  1fb4							;
      2  1fb4							;=====================================================
      3  1fb4							;=====================================================
      4  1fb4							;=====================================================
      5  1fb4							; This file contains the functions for saving and
      6  1fb4							; restoring programs from some sort of mass storage
      7  1fb4							; device.  This particular version is for using the
      8  1fb4							; Corsham Tech SD Card System.
      9  1fb4							;=====================================================
     10  1fb4							;=====================================================
     11  1fb4							;=====================================================
     12  1fb4
     13 U2532					      seg.u	TBData
     14 U2532		       00	   diskBufLength ds	1
     15 U2533		       00	   diskBufOffset ds	1
     16 U2534		       00 00 00 00*DiskFileName ds	64
     17 U2574
     18  1fb4					      SEG	Code
     19  1fb4
     20  1fb4							;
     21  1fb4							;=====================================================
     22  1fb4							; Open a file for reading as a program.  The next
     23  1fb4							; thing on the line should be the filename.
     24  1fb4							;
     25  1fb4				   iOPENREAD
     26  1fb4					      if	XKIM || CTMON65
     27  1fb4		       20 ce 1f 	      jsr	setFileName	;Set the file name to open
     28  1fb7		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  1fba		       90 07		      bcc	Ropenok	;branch if opened ok
     30  1fbc							;
     31  1fbc							; Open failed
     32  1fbc							;
     33  1fbc		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  1fbe		       a9 00	   Rdfail2    lda	#0
     35  1fc0		       4c 44 06 	      jmp	iErr2
     36  1fc3							;
     37  1fc3							; Clear counts and offsets so the next read will
     38  1fc3							; cause the file to be read.
     39  1fc3							;
     40  1fc3		       a9 00	   Ropenok    lda	#0
     41  1fc5		       8d 33 25 	      sta	diskBufOffset
     42  1fc8		       8d 32 25 	      sta	diskBufLength
     43  1fcb		       4c c2 02 	      jmp	NextIL
     44  1fce					      endif
     45  1fce
     46  1fce							;===============================================================
     47  1fce							; Set file name
     48  1fce				   setFileName
     49  1fce		       a4 51		      ldy	CUROFF
     50  1fd0		       b1 4f		      lda	(CURPTR),y
     51  1fd2		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  1fd4		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  1fd6
     54  1fd6		       18		      clc
     55  1fd7		       98		      tya
     56  1fd8		       65 4f		      adc	CURPTR
     57  1fda		       85 52		      sta	R0	;LSB
     58  1fdc		       a5 50		      lda	CURPTR+1
     59  1fde		       69 00		      adc	#0
     60  1fe0		       85 53		      sta	R0+1
     61  1fe2		       a9 34		      lda	#DiskFileName&$ff
     62  1fe4		       85 54		      sta	R1
     63  1fe6		       a9 25		      lda	#DiskFileName>>8
     64  1fe8		       85 55		      sta	R1+1
     65  1fea		       20 52 1f 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  1fed		       a5 52		      lda	R0
     67  1fef		       18		      clc
     68  1ff0		       65 51		      adc	CUROFF	; add the current offset
     69  1ff2		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  1ff4
     71  1ff4		       a0 34		      ldy	#DiskFileName&$ff
     72  1ff6		       a2 25		      ldx	#DiskFileName>>8
     73  1ff8		       18		      clc
     74  1ff9		       60		      rts
     75  1ffa
     76  1ffa				   setFileNameNotFound
     77  1ffa		       68		      pla
     78  1ffb		       68		      pla		; remove the return address from the stack
     79  1ffc		       a9 00		      lda	#0
     80  1ffe		       a2 09		      ldx	#ERR_NO_FILENAME
     81  2000		       4c 44 06 	      jmp	iErr2
     82  2003
     83  2003							;
     84  2003							;==============================JUSTLOSTINTIME 08/02/2022========
     85  2003							;Remove a file from the disk
     86  2003				   iRMFILE
     87  2003					      if	XKIM || CTMON65
     88  2003		       20 ce 1f 	      jsr	setFileName
     89  2006		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  2009		       90 07		      bcc	wrmOk	;branch if removed ok
     91  200b		       a9 00		      lda	#0
     92  200d		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  200f		       4c 44 06 	      jmp	iErr2
     94  2012				   wrmOk
     95  2012		       4c c2 02 	      jmp	NextIL
     96  2015
     97  2015					      endif
     98  2015							;
     99  2015							;=====================================================
    100  2015				   iOPENWRITE
    101  2015					      if	XKIM || CTMON65
    102  2015		       20 ce 1f 	      jsr	setFileName
    103  2018		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  201b		       90 07		      bcc	Wopenok	;branch if opened ok
    105  201d							;
    106  201d							; Open failed
    107  201d							;
    108  201d		       a9 00	   Wdfail     lda	#0
    109  201f		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  2021		       4c 44 06 	      jmp	iErr2
    111  2024							;
    112  2024		       4c c2 02    Wopenok    jmp	NextIL
    113  2027					      endif
    114  2027							;
    115  2027							;=====================================================
    116  2027							; Gets a line of input from the disk file and puts it
    117  2027							; into LINBUF.
    118  2027							;
    119  2027							; On exit:
    120  2027							;    CURPTR points to LINBUF
    121  2027							;    LINBUF contains the line with 0 at the end.
    122  2027							;    Y has offset to first non-space character
    123  2027							;    CURROFF has the same as Y.
    124  2027							;
    125  2027				   iDGETLINE
    126  2027					      if	XKIM || CTMON65
    127  2027		       a2 35		      ldx	#LINBUF&$ff
    128  2029		       86 4f		      stx	CURPTR
    129  202b		       a2 2e		      ldx	#LINBUF>>8
    130  202d		       86 50		      stx	CURPTR+1
    131  202f							;
    132  202f		       a2 00		      ldx	#0	;offset
    133  2031		       8e b9 2e    iDgetLoop  stx	getlinx
    134  2034		       20 9f 20 	      jsr	getNextFileByte
    135  2037		       b0 16		      bcs	iGetEOF
    136  2039		       c9 0d		      cmp	#CR
    137  203b		       f0 0d		      beq	iGetEOL
    138  203d		       c9 0a		      cmp	#LF
    139  203f		       f0 09		      beq	iGetEOL
    140  2041		       ae b9 2e 	      ldx	getlinx
    141  2044		       9d 35 2e 	      sta	LINBUF,x
    142  2047		       e8		      inx
    143  2048		       d0 e7		      bne	iDgetLoop
    144  204a							;
    145  204a							; Handle end of line.	If the line has nothing, loop
    146  204a							; back and get another line.
    147  204a							;
    148  204a		       ae b9 2e    iGetEOL    ldx	getlinx	;blank line?
    149  204d		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  204f							;
    151  204f							; This can fall through when there is a line, or
    152  204f							; called directly when EOF is encountered.
    153  204f							;
    154  204f		       ae b9 2e    iGetEOF    ldx	getlinx
    155  2052		       a9 00		      lda	#0
    156  2054		       9d 35 2e 	      sta	LINBUF,x
    157  2057		       a0 00		      ldy	#0
    158  2059		       20 6b 1d 	      jsr	SkipSpaces
    159  205c		       20 ba 0f 	      jsr	ParseInputLine
    160  205f		       a9 b7		      lda	#TOKENBUFFER&$ff
    161  2061		       85 4f		      sta	CURPTR
    162  2063		       a9 0e		      lda	#TOKENBUFFER>>8
    163  2065		       85 50		      sta	CURPTR+1
    164  2067		       a9 01		      lda	#1
    165  2069		       85 51		      sta	CUROFF
    166  206b		       4c c2 02 	      jmp	NextIL
    167  206e					      endif
    168  206e
    169  206e							;
    170  206e							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  206e							; DISK
    172  206e							;
    173  206e				   iDDIR
    174  206e					      if	XKIM || CTMON65
    175  206e		       20 30 f0 	      jsr	DiskDir
    176  2071							;
    177  2071							; Get/Display each entry
    178  2071							;
    179  2071		       a2 25	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  2073		       a0 34		      ldy	#DiskFileName&$ff
    181  2075		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  2078		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  207a		       20 dc 14 	      jsr	puts
      0  207d					      db	"   ",0
      1  207d		       20 20 20 00	      .byte.b	"   ",0
    185  2081							; Print the line to the console
    186  2081		       a2 25		      ldx	#DiskFileName>>8	;pointer to buffer
    187  2083		       a0 34		      ldy	#DiskFileName&$ff
    188  2085		       a5 00		      lda	0
    189  2087		       20 21 15 	      jsr	PrtStr	;else print name
    190  208a		       20 18 f0 	      jsr	crlf
    191  208d
    192  208d		       4c 71 20 	      jmp	DiskDirLoop	;do next entry
    193  2090
    194  2090		       4c c2 02    DiskDirEnd jmp	NextIL
    195  2093					      endif
    196  2093							;
    197  2093							;=====================================================
    198  2093							; Does a LIST to a Disk file.
    199  2093							;
    200  2093				   iDLIST
    201  2093					      if	XKIM || CTMON65
    202  2093		       20 ce 20 	      jsr	SetOutDisk
    203  2096		       4c 14 08 	      jmp	iLST2
    204  2099					      endif
    205  2099							;
    206  2099							;=====================================================
    207  2099							; Closes any pending disk file.  Okay to call if there
    208  2099							; is no open file.
    209  2099							;
    210  2099				   iDCLOSE
    211  2099					      if	XKIM || CTMON65
    212  2099		       20 42 f0 	      jsr	DiskClose
    213  209c		       4c c2 02 	      jmp	NextIL
    214  209f					      endif
    215  209f							;
    216  209f							;=====================================================
    217  209f							; This gets the next byte from an open disk file.  If
    218  209f							; there are no more bytes left, this returns C set.
    219  209f							; Else, C is clear and A contains the character.
    220  209f							;
    221  209f				   getNextFileByte
    222  209f					      if	XKIM || CTMON65
    223  209f		       ae 33 25 	      ldx	diskBufOffset
    224  20a2		       ec 32 25 	      cpx	diskBufLength
    225  20a5		       d0 14		      bne	hasdata	;branch if still data
    226  20a7							;
    227  20a7							; There is no data left in the buffer, so read a
    228  20a7							; block from the SD system.
    229  20a7							;
    230  20a7		       a9 84		      lda	#BUFFER_SIZE
    231  20a9		       a2 df		      ldx	#buffer>>8
    232  20ab		       a0 0a		      ldy	#buffer&$ff
    233  20ad		       20 3c f0 	      jsr	DiskRead
    234  20b0		       b0 12		      bcs	getNextEof
    235  20b2							;
    236  20b2							; A contains the number of bytes actually read.
    237  20b2							;
    238  20b2		       8d 32 25 	      sta	diskBufLength	;save length
    239  20b5		       c9 00		      cmp	#0	;shouldn't happen
    240  20b7		       f0 0b		      beq	getNextEof
    241  20b9							;
    242  20b9		       a2 00		      ldx	#0
    243  20bb		       bd 0a df    hasdata    lda	buffer,x
    244  20be		       e8		      inx
    245  20bf		       8e 33 25 	      stx	diskBufOffset
    246  20c2		       18		      clc
    247  20c3		       60		      rts
    248  20c4							;
    249  20c4		       a9 00	   getNextEof lda	#0
    250  20c6		       8d 33 25 	      sta	diskBufOffset
    251  20c9		       8d 32 25 	      sta	diskBufLength
    252  20cc		       38		      sec
    253  20cd		       60		      rts
    254  20ce							;
    255  20ce							;=====================================================
    256  20ce							; Set output vector to the disk output function
    257  20ce							;
    258  20ce		       a9 d9	   SetOutDisk lda	#DOUT&$ff
    259  20d0		       8d c6 2e 	      sta	BOutVec
    260  20d3		       a9 20		      lda	#DOUT/256
    261  20d5		       8d c7 2e 	      sta	BOutVec+1
    262  20d8		       60		      rts
    263  20d9							;
    264  20d9							;=====================================================
    265  20d9
    266  20d9		       8e 34 25    DOUT       stx	DiskFileName
    267  20dc		       8c 35 25 	      sty	DiskFileName+1
    268  20df		       8d 0a df 	      sta	buffer
    269  20e2		       a9 01		      lda	#1
    270  20e4		       a0 0a		      ldy	#buffer&$ff
    271  20e6		       a2 df		      ldx	#buffer>>8
    272  20e8		       20 3f f0 	      jsr	DiskWrite
    273  20eb		       ae 34 25 	      ldx	DiskFileName
    274  20ee		       ac 35 25 	      ldy	DiskFileName+1
    275  20f1
    276  20f1							;
    277  20f1							; need error checking here
    278  20f1							;
    279  20f1		       60		      rts
    280  20f2					      endif
    281  20f2
    282  20f2
------- FILE mytb.asm
   2348  20f2					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  20f2					      include	"IL.inc"
      1  20f2
      2  20f2							;=====================================================
      3  20f2							; IL.inc
      4  20f2							; These are macros for IL instructions
      5  20f2							;
      6  20f2					      mac	dw
      7  20f2					      .word	{0}
      8  20f2					      endm
      9  20f2					      mac	db
     10  20f2					      .byte	{0}
     11  20f2					      endm
     12  20f2					      macro	xinit
     13  20f2					      db	0
     14  20f2					      endm		;reset the il to start clear all
     15  20f2							;
     16  20f2					      macro	done
     17  20f2					      db	1
     18  20f2					      endm		;print an error if not end of line
     19  20f2							;
     20  20f2					      macro	prs
     21  20f2					      db	2
     22  20f2					      endm		;print a quoted string
     23  20f2							;
     24  20f2					      macro	prn
     25  20f2					      db	3
     26  20f2					      endm		;print a number
     27  20f2							;
     28  20f2					      macro	spc
     29  20f2					      db	4
     30  20f2					      endm		;print space til new tabstop
     31  20f2							;
     32  20f2					      macro	nline
     33  20f2					      db	5
     34  20f2					      endm		;print a new line crlf
     35  20f2							;
     36  20f2							; My NXT is a bit different in that it takes one
     37  20f2							; parameter, which is an address.  If the BASIC
     38  20f2							; program is currently running then move to the
     39  20f2							; next line and continue execution.  However, if
     40  20f2							; in direct mode, jump to the specified IL label.
     41  20f2							;
     42  20f2					      macro	nxt
     43  20f2					      db	6
     44  20f2					      dw	{1}	; addr
     45  20f2					      endm		; addr
     46  20f2							;
     47  20f2					      macro	xfer
     48  20f2					      db	7
     49  20f2					      endm
     50  20f2							;
     51  20f2					      macro	sav
     52  20f2					      db	8
     53  20f2					      db	{1}
     54  20f2					      endm
     55  20f2							;
     56  20f2							;  Passed jump if function called, and true false value returned
     57  20f2					      macro	rstr
     58  20f2					      db	9
     59  20f2					      db	({1}-*)-1	;(addr-*)-1
     60  20f2					      db	{2}
     61  20f2					      endm
     62  20f2							;
     63  20f2					      macro	cmpr
     64  20f2					      db	10
     65  20f2					      endm
     66  20f2							;
     67  20f2					      macro	innum
     68  20f2					      db	11
     69  20f2					      endm
     70  20f2							;
     71  20f2					      macro	fin
     72  20f2					      db	12
     73  20f2					      endm
     74  20f2							;
     75  20f2							; ERR is followed by an error number.	The error
     76  20f2							; code is printed along with the line number.
     77  20f2							; Control is passed to the statement set with
     78  20f2							; the ERRGOTO statement.
     79  20f2							;
     80  20f2					      macro	errmsg
     81  20f2					      db	13
     82  20f2					      dw	{1}	;ecode
     83  20f2					      endm		;ecode
     84  20f2							;
     85  20f2					      macro	add
     86  20f2					      db	14
     87  20f2					      endm
     88  20f2							;
     89  20f2					      macro	sub
     90  20f2					      db	15
     91  20f2					      endm
     92  20f2							;
     93  20f2					      macro	neg
     94  20f2					      db	16
     95  20f2					      endm
     96  20f2							;
     97  20f2					      macro	mul
     98  20f2					      db	17
     99  20f2					      endm
    100  20f2							;
    101  20f2					      macro	div
    102  20f2					      db	18
    103  20f2					      endm
    104  20f2							;
    105  20f2					      macro	store
    106  20f2					      db	19
    107  20f2					      endm
    108  20f2							;
    109  20f2					      macro	ind
    110  20f2					      db	20
    111  20f2					      endm
    112  20f2							;
    113  20f2					      macro	lst
    114  20f2					      db	21
    115  20f2					      endm
    116  20f2							;
    117  20f2					      macro	init
    118  20f2					      db	22
    119  20f2					      endm
    120  20f2							;
    121  20f2					      macro	getline
    122  20f2					      db	23
    123  20f2					      endm
    124  20f2							;
    125  20f2					      macro	insert
    126  20f2					      db	24
    127  20f2					      endm
    128  20f2							;
    129  20f2					      macro	rtn
    130  20f2					      db	25
    131  20f2					      endm
    132  20f2							;
    133  20f2					      macro	exit
    134  20f2					      db	26
    135  20f2					      endm
    136  20f2							;
    137  20f2					      macro	lit
    138  20f2					      db	27
    139  20f2					      dw	{1}	;value
    140  20f2					      endm		; value LIT
    141  20f2							;
    142  20f2					      macro	call
    143  20f2					      db	28
    144  20f2					      dw	{1}	;addr
    145  20f2					      endm		;addr
    146  20f2							;
    147  20f2							; IJMP will set the IL PC to the specified value.
    148  20f2							;
    149  20f2					      macro	ijmp
    150  20f2					      db	29
    151  20f2					      dw	{1}	;addr
    152  20f2					      endm		;addr
    153  20f2							;
    154  20f2					      macro	vinit
    155  20f2					      db	30
    156  20f2					      endm
    157  20f2							;
    158  20f2							; ERRGOTO sets the point in the code where the IL
    159  20f2							; interpreter will go after any error.
    160  20f2							;
    161  20f2					      macro	errgoto
    162  20f2					      db	31
    163  20f2					      dw	{1}	;addr
    164  20f2					      endm		;addr
    165  20f2							;
    166  20f2					      macro	tst
    167  20f2					      db	32
    168  20f2					      db	({1}-*)-1	;(addr-*)-1
    169  20f2					      db	{2},0	;string,0
    170  20f2					      endm		;addr,string
    171  20f2							;
    172  20f2					      macro	tstv
    173  20f2					      db	33
    174  20f2					      db	({1}-*)-1	;(addr-*)-1
    175  20f2					      endm		;addr
    176  20f2							;
    177  20f2					      macro	tstl
    178  20f2					      db	34
    179  20f2					      db	({1}-*)-1	;(addr-*)-1
    180  20f2					      endm		;addr
    181  20f2							;
    182  20f2					      macro	tstn
    183  20f2					      db	35
    184  20f2					      db	({1}-*)-1	;(addr-*)-1
    185  20f2					      endm		;addr
    186  20f2							;
    187  20f2							; FREE returns the amount of free RAM on top of
    188  20f2							; the stack.  This is the amount of room the user
    189  20f2							; program has available.
    190  20f2							;
    191  20f2					      macro	free
    192  20f2					      db	36
    193  20f2					      endm
    194  20f2							;
    195  20f2							; RANDOM takes the top item off the stack and
    196  20f2							; replaces it with a random number that is
    197  20f2							; MOD the initial value.  Ie, if the TOS is
    198  20f2							; 42 then RANDOM returns a value from 0 to 41.
    199  20f2							;
    200  20f2					      macro	random
    201  20f2					      db	37
    202  20f2					      endm
    203  20f2							;
    204  20f2							; ABS will replace the top of stack with the
    205  20f2							; absolute value.
    206  20f2							;
    207  20f2					      macro	abs
    208  20f2					      db	38
    209  20f2					      endm
    210  20f2							;
    211  20f2							; OPENREAD opens a file for reading, as in getting
    212  20f2							; statements from it.
    213  20f2							;
    214  20f2					      macro	openread
    215  20f2					      db	39
    216  20f2					      endm
    217  20f2							;
    218  20f2							; OPENWRITE opens a file for writing, as in saving
    219  20f2							; the current program to it.
    220  20f2							;
    221  20f2					      macro	openwrite
    222  20f2					      db	40
    223  20f2					      endm
    224  20f2							;
    225  20f2							; DCLOSE closes any open disk file.
    226  20f2							;
    227  20f2					      macro	dclose
    228  20f2					      db	41
    229  20f2					      endm
    230  20f2							;
    231  20f2							; DGETLINE gets one line from the disk file and puts it
    232  20f2							; into LINBUFF.
    233  20f2							;
    234  20f2					      macro	dgetline
    235  20f2					      db	42
    236  20f2					      endm
    237  20f2							;
    238  20f2							; DLIST saves the program to an open disk file.
    239  20f2							;
    240  20f2					      macro	dlist
    241  20f2					      db	43
    242  20f2					      endm
    243  20f2							; DDIR list the current directory
    244  20f2							;
    245  20f2					      macro	ddir
    246  20f2					      db	44
    247  20f2					      endm
    248  20f2
    249  20f2							; RMFILE remove a fle from disk
    250  20f2					      macro	rmfile
    251  20f2					      db	45
    252  20f2					      endm
    253  20f2
    254  20f2							; CLEARSCREEN clear the screen
    255  20f2					      macro	clearscreen
    256  20f2					      db	46
    257  20f2					      endm
    258  20f2							; POKEMEM Poke value into memory
    259  20f2					      macro	pokemem
    260  20f2					      db	47
    261  20f2					      endm
    262  20f2							; PEEKMEM peek at value in memory
    263  20f2					      macro	peekmem
    264  20f2					      db	48
    265  20f2					      endm
    266  20f2							; TSTLET Test if the statement is a let without the keyword let
    267  20f2					      macro	tstlet
    268  20f2					      db	49
    269  20f2					      db	({1}-*)-1	;(addr-*)-1
    270  20f2					      endm		;addr
    271  20f2							; TSTDONE if we reach the end of a statement
    272  20f2					      macro	tstdone
    273  20f2					      db	50
    274  20f2					      db	({1}-*)-1	;(addr-*)-1
    275  20f2					      endm		;addr
    276  20f2							; GETCHAR	get a character from the input line leave it in RO
    277  20f2					      macro	getchar
    278  20f2					      db	51
    279  20f2					      endm
    280  20f2							; PUTCHAR	Put a character to the terminal
    281  20f2					      macro	putchar
    282  20f2					      db	52
    283  20f2					      endm
    284  20f2							; Call		Call a machine function return a to stack
    285  20f2					      macro	callfunc
    286  20f2					      db	53
    287  20f2					      endm
    288  20f2
    289  20f2							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    290  20f2					      macro	ibranch
    291  20f2					      db	54
    292  20f2					      endm
    293  20f2
    294  20f2							; TSTSTR	 Tests for the open quote in a string
    295  20f2					      macro	tststr
    296  20f2					      db	55
    297  20f2					      db	({1}-*)-1	;(addr-*)-1
    298  20f2					      endm
    299  20f2							; SETIRQ	Sets the line number to run when an irq happens irq 550
    300  20f2					      macro	setirq
    301  20f2					      db	56
    302  20f2					      endm
    303  20f2
    304  20f2							; TSTIRQ	Test for irq pending,
    305  20f2							;		if so push the IRQ LINE NUMBER into RO, onto stack
    306  20f2					      macro	tstirq
    307  20f2					      db	57
    308  20f2					      db	({1}-*)-1	;(addr-*)-1
    309  20f2					      endm
    310  20f2
    311  20f2							; IRET    return from interupt service
    312  20f2					      macro	iret
    313  20f2					      db	58
    314  20f2					      endm
    315  20f2
    316  20f2							; INSTR   read a string from the input
    317  20f2					      macro	instr
    318  20f2					      db	59
    319  20f2					      endm
    320  20f2
    321  20f2							; MODULO Returns the remainder of the division
    322  20f2					      macro	modulo
    323  20f2					      db	60
    324  20f2					      endm
    325  20f2							; Set a task line
    326  20f2					      macro	taskcreate
    327  20f2					      db	61
    328  20f2					      endm
    329  20f2							; End a task
    330  20f2					      macro	etask
    331  20f2					      db	62
    332  20f2					      endm
    333  20f2							; Skip to next task
    334  20f2					      macro	ntask
    335  20f2					      db	63
    336  20f2					      endm
    337  20f2							; Subscript
    338  20f2					      macro	subscript
    339  20f2					      db	64
    340  20f2					      endm
    341  20f2							; KILL Task
    342  20f2					      macro	taskkill
    343  20f2					      db	65
    344  20f2					      endm
    345  20f2							; STAT Task
    346  20f2					      macro	taskstat
    347  20f2					      db	66
    348  20f2					      endm
    349  20f2							;  output value as hex
    350  20f2					      macro	hexprt
    351  20f2					      db	67
    352  20f2					      endm
    353  20f2							;  Read in background has completed
    354  20f2					      macro	readcomplete
    355  20f2					      db	68
    356  20f2					      endm
    357  20f2							;  ReadInput line
    358  20f2					      macro	readstart
    359  20f2					      db	69
    360  20f2					      endm
    361  20f2							; Startio request
    362  20f2					      macro	startio
    363  20f2					      db	70
    364  20f2					      endm
    365  20f2							; Endio
    366  20f2					      macro	endio
    367  20f2					      db	71
    368  20f2					      endm
    369  20f2							; Logical not
    370  20f2					      macro	lognot
    371  20f2					      db	72
    372  20f2					      endm
    373  20f2							; Logical OR
    374  20f2					      macro	logor
    375  20f2					      db	73
    376  20f2					      endm
    377  20f2							;Logical and
    378  20f2					      macro	logand
    379  20f2					      db	74
    380  20f2					      endm
    381  20f2							;Logical XOR
    382  20f2					      macro	logxor
    383  20f2					      db	75
    384  20f2					      endm
    385  20f2							;Wait for task to complete, or list of tasks
    386  20f2					      macro	wtask
    387  20f2					      db	76
    388  20f2					      db	({1}-*)-1	;(addr-*)-1
    389  20f2					      endm
    390  20f2							;Get the current task id
    391  20f2					      MACRO	taskpid
    392  20f2					      db	77
    393  20f2					      endm
    394  20f2							;Trace the basic execution
    395  20f2					      Macro	traceprogram
    396  20f2					      db	78
    397  20f2					      endm
    398  20f2							;Do a basic program Trace
    399  20f2					      Macro	debugbasic
    400  20f2					      db	79
    401  20f2					      endm
    402  20f2
    403  20f2							; Inter Process communications instructions
    404  20f2					      Macro	ipcsend
    405  20f2					      db	80
    406  20f2					      endm
    407  20f2					      Macro	ipcreceive
    408  20f2					      db	81
    409  20f2					      endm
    410  20f2					      Macro	ipccheck
    411  20f2					      db	82
    412  20f2					      endm
    413  20f2					      Macro	ipcio
    414  20f2					      db	83
    415  20f2					      endm
    416  20f2					      Macro	pushmathstack
    417  20f2					      db	84
    418  20f2					      endm
    419  20f2					      Macro	popmathstack
    420  20f2					      db	85
    421  20f2					      endm
    422  20f2					      Macro	savemathstack
    423  20f2					      db	86
    424  20f2					      endm
    425  20f2					      Macro	restoremathstack
    426  20f2					      db	87
    427  20f2					      endm
    428  20f2					      Macro	incparmcount
    429  20f2					      db	88
    430  20f2					      endm
    431  20f2					      Macro	taskgetmathstack
    432  20f2					      db	89
    433  20f2					      endm
    434  20f2					      Macro	taskenable
    435  20f2					      db	90
    436  20f2					      endm
    437  20f2					      Macro	tasksuspend
    438  20f2					      db	91
    439  20f2					      endm
    440  20f2					      Macro	taskputmathptr
    441  20f2					      db	92
    442  20f2					      endm
    443  20f2							; Test for an extension type of variable that allows access to a tasks variables
    444  20f2							; Using  PID!<Var name>
    445  20f2					      Macro	tstvt
    446  20f2					      db	93
    447  20f2					      db	({1}-*)-1	;(addr-*)-1
    448  20f2					      endm
    449  20f2
    450  20f2							; Provide access to R2 for the IL program
    451  20f2					      Macro	setr2
    452  20f2					      db	94
    453  20f2					      db	{1}	; R2 is only one byte
    454  20f2					      endm
    455  20f2							;Move stack top to temp
    456  20f2					      Macro	stk2tmp
    457  20f2					      db	95
    458  20f2					      endm
    459  20f2
    460  20f2					      Macro	tmp2stk
    461  20f2					      db	96
    462  20f2					      endm
    463  20f2
    464  20f2					      Macro	tstbyte
    465  20f2					      db	97
    466  20f2					      db	({1}-*)-1	; (addr-*)-1 goto if match
    467  20f2					      dw	{2}	; address to check
    468  20f2					      db	{3}	; Value to compare
    469  20f2					      endm
    470  20f2
    471  20f2					      Macro	incvar
    472  20f2					      db	98
    473  20f2					      endm
    474  20f2					      Macro	decvar
    475  20f2					      db	99
    476  20f2					      endm
    477  20f2
    478  20f2					      Macro	slice
    479  20f2					      db	100
    480  20f2					      endm
    481  20f2
    482  20f2					      Macro	tstb
    483  20f2					      db	101
    484  20f2					      db	({1}-*)-1
    485  20f2					      db	{2}
    486  20f2					      endm
    487  20f2
    488  20f2					      Macro	tstw
    489  20f2					      db	102
    490  20f2					      db	({1}-*)-1
    491  20f2					      dw	{2}
    492  20f2					      endm
    493  20f2
    494  20f2					      Macro	ongoto
    495  20f2					      db	103
    496  20f2					      dw	{1}
    497  20f2					      dw	{2}
    498  20f2					      endm
    499  20f2
    500  20f2					      Macro	tstrelop
    501  20f2					      db	104
    502  20f2					      db	({1}-*)-1
    503  20f2					      endm
    504  20f2
    505  20f2
    506  20f2					      Macro	repeatline
    507  20f2					      db	105
    508  20f2					      endm
    509  20f2
    510  20f2							; Check for a precompiled branch, will take branch if precompiled value present
    511  20f2					      Macro	tstbranch
    512  20f2					      db	106
    513  20f2					      db	({1}-*)-1
    514  20f2					      endm
------- FILE mytb.asm
   2350  20f2							;
   2351  20f2				  -	      if	FIXED
   2352  20f2				  -	      org	$1000
   2353  20f2					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  20f2					      include	"basic.il"
      1  20f2					      seg	Code
      2  20f2							; on goto table
      3  20f2							; format :   first byte is value Base, subtracted from value found
      4  20f2							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  20f2				   BasicStmts
      0  20f2					      db	kBeginKey,kKeyCount+1	; Base address of table, length of table
      1  20f2		       01 1f		      .byte.b	kBeginKey,kKeyCount+1
      0  20f4					      dw	ekLet
      1  20f4		       6f 21		      .word.w	ekLet
      0  20f6					      dw	ekInc
      1  20f6		       9a 21		      .word.w	ekInc
      0  20f8					      dw	ekDec
      1  20f8		       ad 21		      .word.w	ekDec
      0  20fa					      dw	ekIreturn
      1  20fa		       c0 21		      .word.w	ekIreturn
      0  20fc					      dw	ekIf
      1  20fc		       c8 21		      .word.w	ekIf
      0  20fe					      dw	ekThen
      1  20fe		       ce 21		      .word.w	ekThen
      0  2100					      dw	ekGoto
      1  2100		       d5 21		      .word.w	ekGoto
      0  2102					      dw	ekGosub
      1  2102		       e5 21		      .word.w	ekGosub
      0  2104					      dw	ekReturn
      1  2104		       ef 21		      .word.w	ekReturn
      0  2106					      dw	ekRem
      1  2106		       12 22		      .word.w	ekRem
      0  2108					      dw	ekPrint	; should be entry for print
      1  2108		       1b 22		      .word.w	ekPrint
      0  210a					      dw	ekTaske
      1  210a		       6b 22		      .word.w	ekTaske
      0  210c					      dw	ekTaskn
      1  210c		       84 22		      .word.w	ekTaskn
      0  210e					      dw	ekTaskw
      1  210e		       8e 22		      .word.w	ekTaskw
      0  2110					      dw	ekPoke
      1  2110		       ac 22		      .word.w	ekPoke
      0  2112					      dw	ekPutch
      1  2112		       c6 22		      .word.w	ekPutch
      0  2114					      dw	ekCls
      1  2114		       d4 22		      .word.w	ekCls
      0  2116					      dw	ekInput
      1  2116		       de 22		      .word.w	ekInput
      0  2118					      dw	ekEnd
      1  2118		       03 23		      .word.w	ekEnd
      0  211a					      dw	ekIrq
      1  211a		       0a 23		      .word.w	ekIrq
      0  211c					      dw	ekKill
      1  211c		       18 23		      .word.w	ekKill
      0  211e					      dw	ekList
      1  211e		       26 23		      .word.w	ekList
      0  2120					      dw	ekRun
      1  2120		       2e 23		      .word.w	ekRun
      0  2122					      dw	ekNew
      1  2122		       3a 23		      .word.w	ekNew
      0  2124					      dw	ekSlice
      1  2124		       41 23		      .word.w	ekSlice
      0  2126					      dw	ekTrace
      1  2126		       4f 23		      .word.w	ekTrace
      0  2128					      dw	ekExit
      1  2128		       63 23		      .word.w	ekExit
      0  212a					      dw	ekSave
      1  212a		       67 23		      .word.w	ekSave
      0  212c					      dw	ekLoad
      1  212c		       70 23		      .word.w	ekLoad
      0  212e					      dw	ekErase
      1  212e		       86 23		      .word.w	ekErase
      0  2130					      dw	ekDir
      1  2130		       7f 23		      .word.w	ekDir
     38  2132							;
     39  2132							; Logical operators
      0  2132				   BasicLogical db	kNot,4
      1  2132		       20 04		      .byte.b	kNot,4
      0  2134					      dw	ekNot
      1  2134		       91 23		      .word.w	ekNot
     42  2136
      0  2136					      dw	ekOr
      1  2136		       a4 23		      .word.w	ekOr
      0  2138					      dw	ekXor
      1  2138		       ac 23		      .word.w	ekXor
      0  213a					      dw	ekAnd
      1  213a		       9c 23		      .word.w	ekAnd
     46  213c
     47  213c							;functions returning values
     48  213c
      0  213c				   BasicFuncs db	kBeginFunc,kFuncCount
      1  213c		       24 0e		      .byte.b	kBeginFunc,kFuncCount
      0  213e					      dw	ekTrue
      1  213e		       0f 24		      .word.w	ekTrue
      0  2140					      dw	ekFalse
      1  2140		       16 24		      .word.w	ekFalse
      0  2142					      dw	ekFree
      1  2142		       1d 24		      .word.w	ekFree
      0  2144					      dw	ekGetch
      1  2144		       28 24		      .word.w	ekGetch
      0  2146					      dw	ekPeek
      1  2146		       33 24		      .word.w	ekPeek
      0  2148					      dw	ekTask
      1  2148		       41 24		      .word.w	ekTask
      0  214a					      dw	ekIpcc
      1  214a		       8c 24		      .word.w	ekIpcc
      0  214c					      dw	ekIpcs
      1  214c		       60 24		      .word.w	ekIpcs
      0  214e					      dw	ekIpcr
      1  214e		       74 24		      .word.w	ekIpcr
      0  2150					      dw	ekRnd
      1  2150		       9a 24		      .word.w	ekRnd
      0  2152					      dw	ekStat
      1  2152		       be 24		      .word.w	ekStat
      0  2154					      dw	ekAbs
      1  2154		       b0 24		      .word.w	ekAbs
      0  2156					      dw	ekCall
      1  2156		       d1 24		      .word.w	ekCall
      0  2158					      dw	ekGofn
      1  2158		       ed 24		      .word.w	ekGofn
      0  215a					      dw	ekPid
      1  215a		       cc 24		      .word.w	ekPid
     65  215c
     66  215c
     67  215c							;=====================================================
     68  215c							; This is the IL of the BASIC (or whatever) language.
     69  215c							; Because of the way macros are implemented by as65,
     70  215c							; labels can't be on the same line as a macro
     71  215c							; invocation, so that's why labels are on separate
     72  215c							; lines.
     73  215c							;
     74  215c		       21 5c	   IL	      equ	*
     75  215c
     76  215c							;THE IL CONTROL SECTION
     77  215c
     78  215c				   START
      0  215c					      INIT		;INITIALIZE
      0  215c					      db	22
      1  215c		       16		      .byte.b	22
      0  215d					      NLINE		;WRITE CRLF
      0  215d					      db	5
      1  215d		       05		      .byte.b	5
      0  215e					      ERRGOTO	CO	;where to go after an error
      0  215e					      db	31
      1  215e		       1f		      .byte.b	31
      0  215f					      dw	CO
      1  215f		       62 21		      .word.w	CO
      0  2161					      VINIT		;clear all variables
      0  2161					      db	30
      1  2161		       1e		      .byte.b	30
     83  2162							;
     84  2162							; This is where we jump to get a line of commands or
     85  2162							; a program from the user.
     86  2162							;
     87  2162				   CO
      0  2162					      GETLINE		;WRITE PROMPT AND GET LINE
      0  2162					      db	23
      1  2162		       17		      .byte.b	23
      0  2163					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  2163					      db	34
      1  2163		       22		      .byte.b	34
      0  2164					      db	(XEC-*)-1
      1  2164		       04		      .byte.b	(XEC-*)-1
      0  2165					      INSERT		;INSERT IT (MAY BE DELETE)
      0  2165					      db	24
      1  2165		       18		      .byte.b	24
      0  2166					      IJMP	CO
      0  2166					      db	29
      1  2166		       1d		      .byte.b	29
      0  2167					      dw	CO
      1  2167		       62 21		      .word.w	CO
     92  2169				   XEC
      0  2169					      XINIT		;INITIALIZE
      0  2169					      db	0
      1  2169		       00		      .byte.b	0
     94  216a							;============================================================================
     95  216a							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     96  216a							;
     97  216a				   STMT
      0  216a					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  216a					      db	79
      1  216a		       4f		      .byte.b	79
      0  216b					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  216b					      db	57
      1  216b		       39		      .byte.b	57
      0  216c					      db	(notirq-*)-1
      1  216c		       00		      .byte.b	(notirq-*)-1
    100  216d							;==========================================================================================
    101  216d							; Process a let statement implied or explicit.
    102  216d							;
    103  216d				   notirq
      0  216d					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  216d					      db	49
      1  216d		       31		      .byte.b	49
      0  216e					      db	(DoVector-*)-1
      1  216e		       23		      .byte.b	(DoVector-*)-1
    105  216f				   ekLet
      0  216f					      TSTV	ERRVEC2	; YES, PLACE VAR ADDRESS ON AESTK
      0  216f					      db	33
      1  216f		       21		      .byte.b	33
      0  2170					      db	(ERRVEC2-*)-1
      1  2170		       1e		      .byte.b	(ERRVEC2-*)-1
      0  2171					      TSTB	LETSQBRACKET,oEqual	; (This line originally omitted)
      0  2171					      db	101
      1  2171		       65		      .byte.b	101
      0  2172					      db	(LETSQBRACKET-*)-1
      1  2172		       04		      .byte.b	(LETSQBRACKET-*)-1
      0  2173					      db	oEqual
      1  2173		       f2		      .byte.b	oEqual
      0  2174					      IJMP	LETBE
      0  2174					      db	29
      1  2174		       1d		      .byte.b	29
      0  2175					      dw	LETBE
      1  2175		       84 21		      .word.w	LETBE
    109  2177
    110  2177				   LETSQBRACKET 		; is this an array access ?
    111  2177
      0  2177					      TSTB	ERRVEC2,oLeftSQBracket	; [
      0  2177					      db	101
      1  2177		       65		      .byte.b	101
      0  2178					      db	(ERRVEC2-*)-1
      1  2178		       16		      .byte.b	(ERRVEC2-*)-1
      0  2179					      db	oLeftSQBracket
      1  2179		       e4		      .byte.b	oLeftSQBracket
      0  217a					      CALL	EXPR
      0  217a					      db	28
      1  217a		       1c		      .byte.b	28
      0  217b					      dw	EXPR
      1  217b		       8e 23		      .word.w	EXPR
      0  217d					      TSTB	ERRVEC2,oRightSQBracket	; ]
      0  217d					      db	101
      1  217d		       65		      .byte.b	101
      0  217e					      db	(ERRVEC2-*)-1
      1  217e		       10		      .byte.b	(ERRVEC2-*)-1
      0  217f					      db	oRightSQBracket
      1  217f		       e5		      .byte.b	oRightSQBracket
      0  2180					      SUBSCRIPT
      0  2180					      db	64
      1  2180		       40		      .byte.b	64
      0  2181					      TSTB	ERRVEC2,oEqual	; (This line originally omitted)
      0  2181					      db	101
      1  2181		       65		      .byte.b	101
      0  2182					      db	(ERRVEC2-*)-1
      1  2182		       0c		      .byte.b	(ERRVEC2-*)-1
      0  2183					      db	oEqual
      1  2183		       f2		      .byte.b	oEqual
    117  2184				   LETBE
    118  2184
      0  2184					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  2184					      db	28
      1  2184		       1c		      .byte.b	28
      0  2185					      dw	EXPR
      1  2185		       8e 23		      .word.w	EXPR
      0  2187					      DONE		; REPORT ERROR IF NOT NEXT
      0  2187					      db	1
      1  2187		       01		      .byte.b	1
      0  2188					      STORE		; STORE RESULT
      0  2188					      db	19
      1  2188		       13		      .byte.b	19
      0  2189					      NXT	CO	; AND SEQUENCE TO NEXT
      0  2189					      db	6
      1  2189		       06		      .byte.b	6
      0  218a					      dw	CO
      1  218a		       62 21		      .word.w	CO
      0  218c					      IJMP	STMT
      0  218c					      db	29
      1  218c		       1d		      .byte.b	29
      0  218d					      dw	STMT
      1  218d		       6a 21		      .word.w	STMT
    124  218f				   ERRVEC2
      0  218f					      IJMP	UNKNOWN
      0  218f					      db	29
      1  218f		       1d		      .byte.b	29
      0  2190					      dw	UNKNOWN
      1  2190		       8a 23		      .word.w	UNKNOWN
    126  2192							;=============================================================
    127  2192							;Branch on a valid statement start
    128  2192				   DoVector
      0  2192					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  2192					      db	103
      1  2192		       67		      .byte.b	103
      0  2193					      dw	BasicStmts
      1  2193		       f2 20		      .word.w	BasicStmts
      0  2195					      dw	UNKNOWN
      1  2195		       8a 23		      .word.w	UNKNOWN
    130  2197							;This will never return here!
    131  2197							;=============================================================
    132  2197							; Inc or dec a variable
    133  2197				   S1
      0  2197					      TSTB	S1Dec,kInc	; Increment variable
      0  2197					      db	101
      1  2197		       65		      .byte.b	101
      0  2198					      db	(S1Dec-*)-1
      1  2198		       11		      .byte.b	(S1Dec-*)-1
      0  2199					      db	kInc
      1  2199		       02		      .byte.b	kInc
    135  219a				   ekInc
      0  219a					      TSTV	ERRVEC2	; Verify we have a variable
      0  219a					      db	33
      1  219a		       21		      .byte.b	33
      0  219b					      db	(ERRVEC2-*)-1
      1  219b		       f3		      .byte.b	(ERRVEC2-*)-1
      0  219c					      TSTB	eDoInc,oBang	; Allow to inc or dec other tasks variables
      0  219c					      db	101
      1  219c		       65		      .byte.b	101
      0  219d					      db	(eDoInc-*)-1
      1  219d		       04		      .byte.b	(eDoInc-*)-1
      0  219e					      db	oBang
      1  219e		       e8		      .byte.b	oBang
      0  219f					      IND		; we just got a pid
      0  219f					      db	20
      1  219f		       14		      .byte.b	20
      0  21a0					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  21a0					      db	93
      1  21a0		       5d		      .byte.b	93
      0  21a1					      db	(ERRVEC2-*)-1
      1  21a1		       ed		      .byte.b	(ERRVEC2-*)-1
    140  21a2				   eDoInc
      0  21a2					      INCVAR		; Do the increment of the variable
      0  21a2					      db	98
      1  21a2		       62		      .byte.b	98
      0  21a3					      DONE		; Test for end of line or end of statement ":"
      0  21a3					      db	1
      1  21a3		       01		      .byte.b	1
      0  21a4					      NXT	CO	; Get the next statement, branch CO if end of program
      0  21a4					      db	6
      1  21a4		       06		      .byte.b	6
      0  21a5					      dw	CO
      1  21a5		       62 21		      .word.w	CO
      0  21a7					      IJMP	STMT	; Process the next statement
      0  21a7					      db	29
      1  21a7		       1d		      .byte.b	29
      0  21a8					      dw	STMT
      1  21a8		       6a 21		      .word.w	STMT
    145  21aa				   S1Dec
      0  21aa					      TSTB	S1Iret,kDec	; Dec variable
      0  21aa					      db	101
      1  21aa		       65		      .byte.b	101
      0  21ab					      db	(S1Iret-*)-1
      1  21ab		       11		      .byte.b	(S1Iret-*)-1
      0  21ac					      db	kDec
      1  21ac		       03		      .byte.b	kDec
    147  21ad				   ekDec
      0  21ad					      TSTV	ERRVEC2	; Must be followed by a variable
      0  21ad					      db	33
      1  21ad		       21		      .byte.b	33
      0  21ae					      db	(ERRVEC2-*)-1
      1  21ae		       e0		      .byte.b	(ERRVEC2-*)-1
      0  21af					      TSTB	eDoDec,oBang	; Allow to inc or dec other tasks variables
      0  21af					      db	101
      1  21af		       65		      .byte.b	101
      0  21b0					      db	(eDoDec-*)-1
      1  21b0		       04		      .byte.b	(eDoDec-*)-1
      0  21b1					      db	oBang
      1  21b1		       e8		      .byte.b	oBang
      0  21b2					      IND		; we just got a pid
      0  21b2					      db	20
      1  21b2		       14		      .byte.b	20
      0  21b3					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  21b3					      db	93
      1  21b3		       5d		      .byte.b	93
      0  21b4					      db	(ERRVEC2-*)-1
      1  21b4		       da		      .byte.b	(ERRVEC2-*)-1
    152  21b5				   eDoDec
      0  21b5					      DECVAR		; Decrement the actual variable
      0  21b5					      db	99
      1  21b5		       63		      .byte.b	99
      0  21b6					      DONE		; Test if end of line or : statement
      0  21b6					      db	1
      1  21b6		       01		      .byte.b	1
      0  21b7					      NXT	CO	; If at end of program then got the console
      0  21b7					      db	6
      1  21b7		       06		      .byte.b	6
      0  21b8					      dw	CO
      1  21b8		       62 21		      .word.w	CO
      0  21ba					      IJMP	STMT	; Process the next statement of command line
      0  21ba					      db	29
      1  21ba		       1d		      .byte.b	29
      0  21bb					      dw	STMT
      1  21bb		       6a 21		      .word.w	STMT
    157  21bd							;=============================================================================================================================
    158  21bd							; iret or ireturn, Return from interupt process
    159  21bd							;
    160  21bd				   S1Iret
      0  21bd					      TSTB	S1S1,kIreturn	; test return from interupt
      0  21bd					      db	101
      1  21bd		       65		      .byte.b	101
      0  21be					      db	(S1S1-*)-1
      1  21be		       06		      .byte.b	(S1S1-*)-1
      0  21bf					      db	kIreturn
      1  21bf		       04		      .byte.b	kIreturn
    162  21c0				   S1Sa
    163  21c0				   ekIreturn
      0  21c0					      DONE		; Must be only thing on the line
      0  21c0					      db	1
      1  21c0		       01		      .byte.b	1
      0  21c1					      IRET		; RESTORE LINE NUMBER OF CALL
      0  21c1					      db	58
      1  21c1		       3a		      .byte.b	58
      0  21c2					      IJMP	STMT
      0  21c2					      db	29
      1  21c2		       1d		      .byte.b	29
      0  21c3					      dw	STMT
      1  21c3		       6a 21		      .word.w	STMT
    167  21c5							;==============================================================================================================================
    168  21c5							;Process if statement, if true then process all statements until end of line reached
    169  21c5				   S1S1
      0  21c5					      TSTB	S1Z,kIf	; IF STATEMENT
      0  21c5					      db	101
      1  21c5		       65		      .byte.b	101
      0  21c6					      db	(S1Z-*)-1
      1  21c6		       0b		      .byte.b	(S1Z-*)-1
      0  21c7					      db	kIf
      1  21c7		       05		      .byte.b	kIf
    171  21c8				   ekIf
      0  21c8					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  21c8					      db	28
      1  21c8		       1c		      .byte.b	28
      0  21c9					      dw	EXPR
      1  21c9		       8e 23		      .word.w	EXPR
      0  21cb					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  21cb					      db	101
      1  21cb		       65		      .byte.b	101
      0  21cc					      db	(S1W-*)-1
      1  21cc		       01		      .byte.b	(S1W-*)-1
      0  21cd					      db	kThen
      1  21cd		       06		      .byte.b	kThen
    174  21ce				   ekThen
    175  21ce				   S1W
      0  21ce					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  21ce					      db	54
      1  21ce		       36		      .byte.b	54
      0  21cf					      IJMP	STMT
      0  21cf					      db	29
      1  21cf		       1d		      .byte.b	29
      0  21d0					      dw	STMT
      1  21d0		       6a 21		      .word.w	STMT
    178  21d2							;===============================================================================================================================
    179  21d2							; Test for GOTO
    180  21d2				   S1Z
      0  21d2					      TSTB	S2,kGoto	; YES...TO, OR...SUB
      0  21d2					      db	101
      1  21d2		       65		      .byte.b	101
      0  21d3					      db	(S2-*)-1
      1  21d3		       0e		      .byte.b	(S2-*)-1
      0  21d4					      db	kGoto
      1  21d4		       07		      .byte.b	kGoto
    182  21d5
    183  21d5				   ekGoto
      0  21d5					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  21d5					      db	106
      1  21d5		       6a		      .byte.b	106
      0  21d6					      db	(ekGotoCompiled-*)-1
      1  21d6		       0a		      .byte.b	(ekGotoCompiled-*)-1
    185  21d7							; Else we have the address ad just goto that address
      0  21d7					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  21d7					      db	101
      1  21d7		       65		      .byte.b	101
      0  21d8					      db	(ekGotoLine-*)-1
      1  21d8		       05		      .byte.b	(ekGotoLine-*)-1
      0  21d9					      db	oPeriod
      1  21d9		       e9		      .byte.b	oPeriod
      0  21da					      REPEATLINE		; Repeat the same line again
      0  21da					      db	105
      1  21da		       69		      .byte.b	105
      0  21db					      IJMP	STMT	; Go do the statement
      0  21db					      db	29
      1  21db		       1d		      .byte.b	29
      0  21dc					      dw	STMT
      1  21dc		       6a 21		      .word.w	STMT
    189  21de
    190  21de				   ekGotoLine
      0  21de					      CALL	EXPR	; GET LABEL
      0  21de					      db	28
      1  21de		       1c		      .byte.b	28
      0  21df					      dw	EXPR
      1  21df		       8e 23		      .word.w	EXPR
    192  21e1
    193  21e1				   ekGotoCompiled
      0  21e1					      XFER		; SET UP AND JUMP
      0  21e1					      db	7
      1  21e1		       07		      .byte.b	7
    195  21e2
    196  21e2							;===============================================================================================================================
    197  21e2							; Process gosub / function
    198  21e2							;
    199  21e2				   S2
      0  21e2					      TSTB	S2b,kGosub	; ERROR IF NO MATCH
      0  21e2					      db	101
      1  21e2		       65		      .byte.b	101
      0  21e3					      db	(S2b-*)-1
      1  21e3		       08		      .byte.b	(S2b-*)-1
      0  21e4					      db	kGosub
      1  21e4		       08		      .byte.b	kGosub
    201  21e5				   ekGosub
      0  21e5					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  21e5					      db	28
      1  21e5		       1c		      .byte.b	28
      0  21e6					      dw	GOSUBSTATEMENT
      1  21e6		       19 25		      .word.w	GOSUBSTATEMENT
      0  21e8					      DONE		; ERROR IF CR NOT NEXT
      0  21e8					      db	1
      1  21e8		       01		      .byte.b	1
      0  21e9					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  21e9					      db	8
      1  21e9		       08		      .byte.b	8
      0  21ea					      db	GOSUB_RTN
      1  21ea		       01		      .byte.b	GOSUB_RTN
      0  21eb					      XFER		; AND JUMP to sub rtn
      0  21eb					      db	7
      1  21eb		       07		      .byte.b	7
    206  21ec							;
    207  21ec							; End of gosub processing
    208  21ec							;===============================================================================================================================
    209  21ec							; Return from a gosub
    210  21ec				   S2b
      0  21ec					      TSTB	S2a,kReturn	; Speed up pocessing but more memory
      0  21ec					      db	101
      1  21ec		       65		      .byte.b	101
      0  21ed					      db	(S2a-*)-1
      1  21ed		       21		      .byte.b	(S2a-*)-1
      0  21ee					      db	kReturn
      1  21ee		       09		      .byte.b	kReturn
    212  21ef				   ekReturn
      0  21ef					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  21ef					      db	101
      1  21ef		       65		      .byte.b	101
      0  21f0					      db	(S2NoReturnValue-*)-1
      1  21f0		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  21f1					      db	oLeftBracket
      1  21f1		       e0		      .byte.b	oLeftBracket
      0  21f2					      CALL	EXPR
      0  21f2					      db	28
      1  21f2		       1c		      .byte.b	28
      0  21f3					      dw	EXPR
      1  21f3		       8e 23		      .word.w	EXPR
      0  21f5					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  21f5					      db	101
      1  21f5		       65		      .byte.b	101
      0  21f6					      db	(ERRVEC2-*)-1
      1  21f6		       98		      .byte.b	(ERRVEC2-*)-1
      0  21f7					      db	oRightBracket
      1  21f7		       e1		      .byte.b	oRightBracket
      0  21f8					      DONE
      0  21f8					      db	1
      1  21f8		       01		      .byte.b	1
      0  21f9					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  21f9					      db	9
      1  21f9		       09		      .byte.b	9
      0  21fa					      db	(S2RetFunc-*)-1
      1  21fa		       11		      .byte.b	(S2RetFunc-*)-1
      0  21fb					      db	1
      1  21fb		       01		      .byte.b	1
      0  21fc					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  21fc					      db	6
      1  21fc		       06		      .byte.b	6
      0  21fd					      dw	CO
      1  21fd		       62 21		      .word.w	CO
      0  21ff					      IJMP	STMT	; Process the new statement
      0  21ff					      db	29
      1  21ff		       1d		      .byte.b	29
      0  2200					      dw	STMT
      1  2200		       6a 21		      .word.w	STMT
    220  2202
    221  2202				   S2NoReturnValue
      0  2202					      DONE
      0  2202					      db	1
      1  2202		       01		      .byte.b	1
      0  2203					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  2203					      db	9
      1  2203		       09		      .byte.b	9
      0  2204					      db	(S2RetFunc-*)-1
      1  2204		       07		      .byte.b	(S2RetFunc-*)-1
      0  2205					      db	0
      1  2205		       00		      .byte.b	0
      0  2206					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  2206					      db	6
      1  2206		       06		      .byte.b	6
      0  2207					      dw	CO
      1  2207		       62 21		      .word.w	CO
      0  2209					      IJMP	STMT	; Process the new statement
      0  2209					      db	29
      1  2209		       1d		      .byte.b	29
      0  220a					      dw	STMT
      1  220a		       6a 21		      .word.w	STMT
    226  220c
    227  220c				   S2RetFunc
      0  220c					      IJMP	GOFNRet	; Back into the Function
      0  220c					      db	29
      1  220c		       1d		      .byte.b	29
      0  220d					      dw	GOFNRet
      1  220d		       f3 24		      .word.w	GOFNRet
    229  220f							;
    230  220f							; End of return from gosub
    231  220f							;==================================================================================================================================
    232  220f							; Process REM statement
    233  220f							;
    234  220f				   S2a
      0  220f					      TSTB	S3,kRem	; REMark.  Skip rest of line
      0  220f					      db	101
      1  220f		       65		      .byte.b	101
      0  2210					      db	(S3-*)-1
      1  2210		       07		      .byte.b	(S3-*)-1
      0  2211					      db	kRem
      1  2211		       0a		      .byte.b	kRem
    236  2212				   ekRem
      0  2212					      NXT	CO	; The rest of the line is ignored
      0  2212					      db	6
      1  2212		       06		      .byte.b	6
      0  2213					      dw	CO
      1  2213		       62 21		      .word.w	CO
      0  2215					      IJMP	STMT	; Process the next statement
      0  2215					      db	29
      1  2215		       1d		      .byte.b	29
      0  2216					      dw	STMT
      1  2216		       6a 21		      .word.w	STMT
    239  2218							;==================================================================================================================================
    240  2218							; Print statement
    241  2218							;
    242  2218				   S3
      0  2218					      TSTB	S8,kPrint	; ? or Print symonym for print
      0  2218					      db	101
      1  2218		       65		      .byte.b	101
      0  2219					      db	(S8-*)-1
      1  2219		       4e		      .byte.b	(S8-*)-1
      0  221a					      db	kPrint
      1  221a		       0b		      .byte.b	kPrint
    244  221b				   ekPrint
      0  221b					      STARTIO		; Lock task until io completes
      0  221b					      db	70
      1  221b		       46		      .byte.b	70
    246  221c				   S4
      0  221c					      TSTDONE	S4a	; Test if we just want crlf printed
      0  221c					      db	50
      1  221c		       32		      .byte.b	50
      0  221d					      db	(S4a-*)-1
      1  221d		       03		      .byte.b	(S4a-*)-1
      0  221e					      IJMP	S6
      0  221e					      db	29
      1  221e		       1d		      .byte.b	29
      0  221f					      dw	S6
      1  221f		       36 22		      .word.w	S6
    249  2221
    250  2221				   S4a
      0  2221					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  2221					      db	101
      1  2221		       65		      .byte.b	101
      0  2222					      db	(S7-*)-1
      1  2222		       1f		      .byte.b	(S7-*)-1
      0  2223					      db	tString
      1  2223		       a0		      .byte.b	tString
      0  2224					      PRS		; PRINT STRING
      0  2224					      db	2
      1  2224		       02		      .byte.b	2
    253  2225				   S5
      0  2225					      TSTB	S6A,oComma	; IS THERE MORE?
      0  2225					      db	101
      1  2225		       65		      .byte.b	101
      0  2226					      db	(S6A-*)-1
      1  2226		       07		      .byte.b	(S6A-*)-1
      0  2227					      db	oComma
      1  2227		       e2		      .byte.b	oComma
      0  2228					      SPC		; SPACE TO NEXT ZONE
      0  2228					      db	4
      1  2228		       04		      .byte.b	4
      0  2229					      TSTDONE	S4	; Not end of line jump back
      0  2229					      db	50
      1  2229		       32		      .byte.b	50
      0  222a					      db	(S4-*)-1
      1  222a		       f1		      .byte.b	(S4-*)-1
      0  222b					      IJMP	S6Z	; YES JUMP BACK
      0  222b					      db	29
      1  222b		       1d		      .byte.b	29
      0  222c					      dw	S6Z
      1  222c		       38 22		      .word.w	S6Z
    258  222e
    259  222e							;
    260  222e							; If a semicolon, don't do anything.
    261  222e							;
    262  222e				   S6A
      0  222e					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  222e					      db	101
      1  222e		       65		      .byte.b	101
      0  222f					      db	(S6-*)-1
      1  222f		       06		      .byte.b	(S6-*)-1
      0  2230					      db	oSemiColon
      1  2230		       e3		      .byte.b	oSemiColon
      0  2231					      TSTDONE	S4	; Jump Back if not end of line
      0  2231					      db	50
      1  2231		       32		      .byte.b	50
      0  2232					      db	(S4-*)-1
      1  2232		       e9		      .byte.b	(S4-*)-1
      0  2233					      IJMP	S6Z
      0  2233					      db	29
      1  2233		       1d		      .byte.b	29
      0  2234					      dw	S6Z
      1  2234		       38 22		      .word.w	S6Z
    266  2236
    267  2236				   S6
    268  2236
      0  2236					      DONE		; ERROR IF CR NOT NEXT
      0  2236					      db	1
      1  2236		       01		      .byte.b	1
      0  2237					      NLINE
      0  2237					      db	5
      1  2237		       05		      .byte.b	5
    271  2238				   S6Z
      0  2238					      ENDIO		; release task io completed
      0  2238					      db	71
      1  2238		       47		      .byte.b	71
      0  2239					      NXT	CO	; exit here if , or ; at end of print
      0  2239					      db	6
      1  2239		       06		      .byte.b	6
      0  223a					      dw	CO
      1  223a		       62 21		      .word.w	CO
      0  223c					      IJMP	STMT
      0  223c					      db	29
      1  223c		       1d		      .byte.b	29
      0  223d					      dw	STMT
      1  223d		       6a 21		      .word.w	STMT
    275  223f							;
    276  223f							; A jump for code too far away for relative branch
    277  223f							;
    278  223f				   ERRVEC
      0  223f					      IJMP	UNKNOWN
      0  223f					      db	29
      1  223f		       1d		      .byte.b	29
      0  2240					      dw	UNKNOWN
      1  2240		       8a 23		      .word.w	UNKNOWN
    280  2242							;
    281  2242							; Get here if there is an expression to print
    282  2242				   S7
      0  2242					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  2242					      db	101
      1  2242		       65		      .byte.b	101
      0  2243					      db	(S7AUnsigned-*)-1
      1  2243		       08		      .byte.b	(S7AUnsigned-*)-1
      0  2244					      db	oDollar
      1  2244		       e7		      .byte.b	oDollar
      0  2245					      CALL	EXPR
      0  2245					      db	28
      1  2245		       1c		      .byte.b	28
      0  2246					      dw	EXPR
      1  2246		       8e 23		      .word.w	EXPR
      0  2248					      HEXPRT
      0  2248					      db	67
      1  2248		       43		      .byte.b	67
      0  2249					      IJMP	S5
      0  2249					      db	29
      1  2249		       1d		      .byte.b	29
      0  224a					      dw	S5
      1  224a		       25 22		      .word.w	S5
    287  224c
    288  224c				   S7AUnsigned
    289  224c
      0  224c					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  224c					      db	101
      1  224c		       65		      .byte.b	101
      0  224d					      db	(S7A-*)-1
      1  224d		       0a		      .byte.b	(S7A-*)-1
      0  224e					      db	oPercent
      1  224e		       ed		      .byte.b	oPercent
      0  224f					      CALL	EXPR
      0  224f					      db	28
      1  224f		       1c		      .byte.b	28
      0  2250					      dw	EXPR
      1  2250		       8e 23		      .word.w	EXPR
      0  2252					      SETR2	1
      0  2252					      db	94
      1  2252		       5e		      .byte.b	94
      0  2253					      db	1
      1  2253		       01		      .byte.b	1
      0  2254					      PRN
      0  2254					      db	3
      1  2254		       03		      .byte.b	3
      0  2255					      IJMP	S5
      0  2255					      db	29
      1  2255		       1d		      .byte.b	29
      0  2256					      dw	S5
      1  2256		       25 22		      .word.w	S5
    295  2258
    296  2258				   S7A
    297  2258
      0  2258					      CALL	EXPR
      0  2258					      db	28
      1  2258		       1c		      .byte.b	28
      0  2259					      dw	EXPR
      1  2259		       8e 23		      .word.w	EXPR
      0  225b					      TSTB	S7B,oDollar	; Print the value as a single character
      0  225b					      db	101
      1  225b		       65		      .byte.b	101
      0  225c					      db	(S7B-*)-1
      1  225c		       05		      .byte.b	(S7B-*)-1
      0  225d					      db	oDollar
      1  225d		       e7		      .byte.b	oDollar
      0  225e					      PUTCHAR
      0  225e					      db	52
      1  225e		       34		      .byte.b	52
      0  225f					      IJMP	S5
      0  225f					      db	29
      1  225f		       1d		      .byte.b	29
      0  2260					      dw	S5
      1  2260		       25 22		      .word.w	S5
    302  2262
    303  2262				   S7B
      0  2262					      SETR2	0	; Print the value as a signed number
      0  2262					      db	94
      1  2262		       5e		      .byte.b	94
      0  2263					      db	0
      1  2263		       00		      .byte.b	0
      0  2264					      PRN		; PRINT IT
      0  2264					      db	3
      1  2264		       03		      .byte.b	3
      0  2265					      IJMP	S5	; IS THERE MORE?
      0  2265					      db	29
      1  2265		       1d		      .byte.b	29
      0  2266					      dw	S5
      1  2266		       25 22		      .word.w	S5
    307  2268							;
    308  2268							;===========================================================
    309  2268							; PROCESS ALL THE TAST STATEMENTS
    310  2268							;
    311  2268				   S8
      0  2268					      TSTB	S8G,kTaske	; End Task
      0  2268					      db	101
      1  2268		       65		      .byte.b	101
      0  2269					      db	(S8G-*)-1
      1  2269		       17		      .byte.b	(S8G-*)-1
      0  226a					      db	kTaske
      1  226a		       0c		      .byte.b	kTaske
    313  226b				   ekTaske
      0  226b					      TSTB	S8NoParm,oLeftBracket
      0  226b					      db	101
      1  226b		       65		      .byte.b	101
      0  226c					      db	(S8NoParm-*)-1
      1  226c		       0c		      .byte.b	(S8NoParm-*)-1
      0  226d					      db	oLeftBracket
      1  226d		       e0		      .byte.b	oLeftBracket
      0  226e					      CALL	EXPR
      0  226e					      db	28
      1  226e		       1c		      .byte.b	28
      0  226f					      dw	EXPR
      1  226f		       8e 23		      .word.w	EXPR
      0  2271					      TSTB	UNKNOWNLnk,oRightBracket
      0  2271					      db	101
      1  2271		       65		      .byte.b	101
      0  2272					      db	(UNKNOWNLnk-*)-1
      1  2272		       33		      .byte.b	(UNKNOWNLnk-*)-1
      0  2273					      db	oRightBracket
      1  2273		       e1		      .byte.b	oRightBracket
      0  2274					      ETASK
      0  2274					      db	62
      1  2274		       3e		      .byte.b	62
      0  2275					      DONE
      0  2275					      db	1
      1  2275		       01		      .byte.b	1
      0  2276					      IJMP	STMT
      0  2276					      db	29
      1  2276		       1d		      .byte.b	29
      0  2277					      dw	STMT
      1  2277		       6a 21		      .word.w	STMT
    320  2279				   S8NoParm
      0  2279					      LIT	0
      0  2279					      db	27
      1  2279		       1b		      .byte.b	27
      0  227a					      dw	0
      1  227a		       00 00		      .word.w	0
      0  227c					      ETASK
      0  227c					      db	62
      1  227c		       3e		      .byte.b	62
      0  227d					      DONE		; Must be last thing on a line
      0  227d					      db	1
      1  227d		       01		      .byte.b	1
      0  227e					      IJMP	STMT
      0  227e					      db	29
      1  227e		       1d		      .byte.b	29
      0  227f					      dw	STMT
      1  227f		       6a 21		      .word.w	STMT
    325  2281							;
    326  2281							;===========================================================
    327  2281							; The task gives up the rest of the cycles
    328  2281				   S8G
      0  2281					      TSTB	S8a,kTaskn	;Next task
      0  2281					      db	101
      1  2281		       65		      .byte.b	101
      0  2282					      db	(S8a-*)-1
      1  2282		       08		      .byte.b	(S8a-*)-1
      0  2283					      db	kTaskn
      1  2283		       0d		      .byte.b	kTaskn
    330  2284				   ekTaskn
      0  2284					      NTASK
      0  2284					      db	63
      1  2284		       3f		      .byte.b	63
      0  2285					      NXT	CO	;Next statement to execute
      0  2285					      db	6
      1  2285		       06		      .byte.b	6
      0  2286					      dw	CO
      1  2286		       62 21		      .word.w	CO
      0  2288					      IJMP	STMT
      0  2288					      db	29
      1  2288		       1d		      .byte.b	29
      0  2289					      dw	STMT
      1  2289		       6a 21		      .word.w	STMT
    334  228b							;
    335  228b							;===========================================================
    336  228b							; Waits for a task or list of tasks to complete
    337  228b				   S8a
      0  228b					      TSTB	S8a1,kTaskw	;Wait for tasks
      0  228b					      db	101
      1  228b		       65		      .byte.b	101
      0  228c					      db	(S8a1-*)-1
      1  228c		       1c		      .byte.b	(S8a1-*)-1
      0  228d					      db	kTaskw
      1  228d		       0e		      .byte.b	kTaskw
    339  228e				   ekTaskw
      0  228e					      TSTB	UNKNOWNLnk,oLeftBracket
      0  228e					      db	101
      1  228e		       65		      .byte.b	101
      0  228f					      db	(UNKNOWNLnk-*)-1
      1  228f		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  2290					      db	oLeftBracket
      1  2290		       e0		      .byte.b	oLeftBracket
    341  2291				   S8TSK
      0  2291					      Call	EXPR	;Gets the PID of task to wait for
      0  2291					      db	28
      1  2291		       1c		      .byte.b	28
      0  2292					      dw	EXPR
      1  2292		       8e 23		      .word.w	EXPR
    343  2294				   S8LOOP
      0  2294					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  2294					      db	76
      1  2294		       4c		      .byte.b	76
      0  2295					      db	(S8LOOP-*)-1
      1  2295		       fe		      .byte.b	(S8LOOP-*)-1
      0  2296					      TSTB	S8aa,oComma	;Checks for more tasks
      0  2296					      db	101
      1  2296		       65		      .byte.b	101
      0  2297					      db	(S8aa-*)-1
      1  2297		       04		      .byte.b	(S8aa-*)-1
      0  2298					      db	oComma
      1  2298		       e2		      .byte.b	oComma
      0  2299					      IJMP	S8TSK	;Go for the next task number
      0  2299					      db	29
      1  2299		       1d		      .byte.b	29
      0  229a					      dw	S8TSK
      1  229a		       91 22		      .word.w	S8TSK
    347  229c				   S8aa
      0  229c					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  229c					      db	101
      1  229c		       65		      .byte.b	101
      0  229d					      db	(UNKNOWNLnk-*)-1
      1  229d		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  229e					      db	oRightBracket
      1  229e		       e1		      .byte.b	oRightBracket
      0  229f					      DONE
      0  229f					      db	1
      1  229f		       01		      .byte.b	1
      0  22a0					      NXT	CO
      0  22a0					      db	6
      1  22a0		       06		      .byte.b	6
      0  22a1					      dw	CO
      1  22a1		       62 21		      .word.w	CO
      0  22a3					      IJMP	STMT	;Next Statement
      0  22a3					      db	29
      1  22a3		       1d		      .byte.b	29
      0  22a4					      dw	STMT
      1  22a4		       6a 21		      .word.w	STMT
    352  22a6
    353  22a6
    354  22a6
    355  22a6				   UNKNOWNLnk
      0  22a6					      iJMP	UNKNOWN
      0  22a6					      db	29
      1  22a6		       1d		      .byte.b	29
      0  22a7					      dw	UNKNOWN
      1  22a7		       8a 23		      .word.w	UNKNOWN
    357  22a9
    358  22a9							;
    359  22a9							;===========================================================
    360  22a9							; Update a memory location with a value
    361  22a9							;  Use @[offset] to write a word value to memory
    362  22a9							;
    363  22a9				   S8a1
      0  22a9					      TSTB	S8b,kPoke	; Poke a value into memory
      0  22a9					      db	101
      1  22a9		       65		      .byte.b	101
      0  22aa					      db	(S8b-*)-1
      1  22aa		       18		      .byte.b	(S8b-*)-1
      0  22ab					      db	kPoke
      1  22ab		       0f		      .byte.b	kPoke
    365  22ac				   ekPoke
      0  22ac					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  22ac					      db	101
      1  22ac		       65		      .byte.b	101
      0  22ad					      db	(UNKNOWNV-*)-1
      1  22ad		       56		      .byte.b	(UNKNOWNV-*)-1
      0  22ae					      db	oLeftBracket
      1  22ae		       e0		      .byte.b	oLeftBracket
      0  22af					      CALL	EXPR	; Get address to write to
      0  22af					      db	28
      1  22af		       1c		      .byte.b	28
      0  22b0					      dw	EXPR
      1  22b0		       8e 23		      .word.w	EXPR
      0  22b2					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  22b2					      db	101
      1  22b2		       65		      .byte.b	101
      0  22b3					      db	(UNKNOWNV-*)-1
      1  22b3		       50		      .byte.b	(UNKNOWNV-*)-1
      0  22b4					      db	oComma
      1  22b4		       e2		      .byte.b	oComma
      0  22b5					      CALL	EXPR	; Get the value to poke
      0  22b5					      db	28
      1  22b5		       1c		      .byte.b	28
      0  22b6					      dw	EXPR
      1  22b6		       8e 23		      .word.w	EXPR
      0  22b8					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  22b8					      db	101
      1  22b8		       65		      .byte.b	101
      0  22b9					      db	(UNKNOWNV-*)-1
      1  22b9		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  22ba					      db	oRightBracket
      1  22ba		       e1		      .byte.b	oRightBracket
      0  22bb					      POKEMEM
      0  22bb					      db	47
      1  22bb		       2f		      .byte.b	47
      0  22bc					      DONE
      0  22bc					      db	1
      1  22bc		       01		      .byte.b	1
      0  22bd					      NXT	CO	;AND SEQUENCE TO NEXT
      0  22bd					      db	6
      1  22bd		       06		      .byte.b	6
      0  22be					      dw	CO
      1  22be		       62 21		      .word.w	CO
      0  22c0					      IJMP	STMT
      0  22c0					      db	29
      1  22c0		       1d		      .byte.b	29
      0  22c1					      dw	STMT
      1  22c1		       6a 21		      .word.w	STMT
    375  22c3							;================================================================
    376  22c3							; Write a single byte to the output device
    377  22c3							;
    378  22c3				   S8b
      0  22c3					      TSTB	S8c,kPutch	;Put a char to the terminal
      0  22c3					      db	101
      1  22c3		       65		      .byte.b	101
      0  22c4					      db	(S8c-*)-1
      1  22c4		       0c		      .byte.b	(S8c-*)-1
      0  22c5					      db	kPutch
      1  22c5		       10		      .byte.b	kPutch
    380  22c6				   ekPutch
      0  22c6					      CALL	EXPR
      0  22c6					      db	28
      1  22c6		       1c		      .byte.b	28
      0  22c7					      dw	EXPR
      1  22c7		       8e 23		      .word.w	EXPR
      0  22c9					      PUTCHAR
      0  22c9					      db	52
      1  22c9		       34		      .byte.b	52
      0  22ca					      DONE
      0  22ca					      db	1
      1  22ca		       01		      .byte.b	1
      0  22cb					      NXT	CO	;AND SEQUENCE TO NEXT
      0  22cb					      db	6
      1  22cb		       06		      .byte.b	6
      0  22cc					      dw	CO
      1  22cc		       62 21		      .word.w	CO
      0  22ce					      IJMP	STMT
      0  22ce					      db	29
      1  22ce		       1d		      .byte.b	29
      0  22cf					      dw	STMT
      1  22cf		       6a 21		      .word.w	STMT
    386  22d1							;================================================================
    387  22d1							; Clear the screen lines
    388  22d1							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    389  22d1							;
    390  22d1				   S8c
      0  22d1					      TSTB	S9,kCls	;Clear the screen
      0  22d1					      db	101
      1  22d1		       65		      .byte.b	101
      0  22d2					      db	(S9-*)-1
      1  22d2		       08		      .byte.b	(S9-*)-1
      0  22d3					      db	kCls
      1  22d3		       11		      .byte.b	kCls
    392  22d4				   ekCls
      0  22d4					      CLEARSCREEN
      0  22d4					      db	46
      1  22d4		       2e		      .byte.b	46
      0  22d5					      NXT	CO	;AND SEQUENCE TO NEXT
      0  22d5					      db	6
      1  22d5		       06		      .byte.b	6
      0  22d6					      dw	CO
      1  22d6		       62 21		      .word.w	CO
      0  22d8					      IJMP	STMT
      0  22d8					      db	29
      1  22d8		       1d		      .byte.b	29
      0  22d9					      dw	STMT
      1  22d9		       6a 21		      .word.w	STMT
    396  22db							;==================================================================
    397  22db							; Get input from the terminal
    398  22db							;   Reads from the currently active input device
    399  22db							;
    400  22db				   S9
      0  22db					      TSTB	S13,kInput	;INPUT STATEMENT
      0  22db					      db	101
      1  22db		       65		      .byte.b	101
      0  22dc					      db	(S13-*)-1
      1  22dc		       23		      .byte.b	(S13-*)-1
      0  22dd					      db	kInput
      1  22dd		       12		      .byte.b	kInput
    402  22de				   ekInput
    403  22de				   S10
      0  22de					      TSTB	S10A,tString	;If there is a string print the prompt
      0  22de					      db	101
      1  22de		       65		      .byte.b	101
      0  22df					      db	(S10A-*)-1
      1  22df		       05		      .byte.b	(S10A-*)-1
      0  22e0					      db	tString
      1  22e0		       a0		      .byte.b	tString
      0  22e1					      PRS
      0  22e1					      db	2
      1  22e1		       02		      .byte.b	2
      0  22e2					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  22e2					      db	101
      1  22e2		       65		      .byte.b	101
      0  22e3					      db	(S10Z-*)-1
      1  22e3		       12		      .byte.b	(S10Z-*)-1
      0  22e4					      db	oSemiColon
      1  22e4		       e3		      .byte.b	oSemiColon
    407  22e5				   S10A
      0  22e5					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  22e5					      db	33
      1  22e5		       21		      .byte.b	33
      0  22e6					      db	(UNKNOWN-*)-1
      1  22e6		       a3		      .byte.b	(UNKNOWN-*)-1
      0  22e7					      TSTB	S10A1,oDollar
      0  22e7					      db	101
      1  22e7		       65		      .byte.b	101
      0  22e8					      db	(S10A1-*)-1
      1  22e8		       05		      .byte.b	(S10A1-*)-1
      0  22e9					      db	oDollar
      1  22e9		       e7		      .byte.b	oDollar
      0  22ea					      INSTR		;Move character From tty to AESTK
      0  22ea					      db	59
      1  22ea		       3b		      .byte.b	59
      0  22eb					      IJMP	S10A2
      0  22eb					      db	29
      1  22eb		       1d		      .byte.b	29
      0  22ec					      dw	S10A2
      1  22ec		       ef 22		      .word.w	S10A2
    412  22ee				   S10A1
      0  22ee					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  22ee					      db	11
      1  22ee		       0b		      .byte.b	11
    414  22ef				   S10A2
      0  22ef					      STORE		;STORE IT
      0  22ef					      db	19
      1  22ef		       13		      .byte.b	19
      0  22f0					      TSTB	S11,oComma	;IS THERE MORE?
      0  22f0					      db	101
      1  22f0		       65		      .byte.b	101
      0  22f1					      db	(S11-*)-1
      1  22f1		       07		      .byte.b	(S11-*)-1
      0  22f2					      db	oComma
      1  22f2		       e2		      .byte.b	oComma
      0  22f3					      IJMP	S10	;YES
      0  22f3					      db	29
      1  22f3		       1d		      .byte.b	29
      0  22f4					      dw	S10
      1  22f4		       de 22		      .word.w	S10
    418  22f6				   S10Z
      0  22f6					      iJMP	UNKNOWN
      0  22f6					      db	29
      1  22f6		       1d		      .byte.b	29
      0  22f7					      dw	UNKNOWN
      1  22f7		       8a 23		      .word.w	UNKNOWN
    420  22f9				   S11
      0  22f9					      DONE		;MUST BE CR
      0  22f9					      db	1
      1  22f9		       01		      .byte.b	1
      0  22fa					      NXT	CO	;SEQUENCE TO NEXT
      0  22fa					      db	6
      1  22fa		       06		      .byte.b	6
      0  22fb					      dw	CO
      1  22fb		       62 21		      .word.w	CO
      0  22fd					      IJMP	STMT
      0  22fd					      db	29
      1  22fd		       1d		      .byte.b	29
      0  22fe					      dw	STMT
      1  22fe		       6a 21		      .word.w	STMT
    424  2300							;=====================================================================
    425  2300							; End of program, return to command line process
    426  2300							; Main Task may also use taske or return to stopped
    427  2300							;
    428  2300				   S13
      0  2300					      TSTB	S14,kEnd
      0  2300					      db	101
      1  2300		       65		      .byte.b	101
      0  2301					      db	(S14-*)-1
      1  2301		       05		      .byte.b	(S14-*)-1
      0  2302					      db	kEnd
      1  2302		       13		      .byte.b	kEnd
    430  2303				   ekEnd
      0  2303					      FIN
      0  2303					      db	12
      1  2303		       0c		      .byte.b	12
    432  2304
    433  2304				   UNKNOWNV
      0  2304					      IJMP	UNKNOWN
      0  2304					      db	29
      1  2304		       1d		      .byte.b	29
      0  2305					      dw	UNKNOWN
      1  2305		       8a 23		      .word.w	UNKNOWN
    435  2307							;====================================================================
    436  2307							; IRQ <IRQ-HANDLER-Line expression>
    437  2307							;   Specify a line number subroutine to call when an interupt is processed
    438  2307							;   These subroutines must use iret to return.
    439  2307							;
    440  2307				   S14
      0  2307					      TSTB	S14Z,kIrq	;Check if we are setting IRQ HANDLER
      0  2307					      db	101
      1  2307		       65		      .byte.b	101
      0  2308					      db	(S14Z-*)-1
      1  2308		       0c		      .byte.b	(S14Z-*)-1
      0  2309					      db	kIrq
      1  2309		       14		      .byte.b	kIrq
    442  230a				   ekIrq
      0  230a					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  230a					      db	28
      1  230a		       1c		      .byte.b	28
      0  230b					      dw	EXPR
      1  230b		       8e 23		      .word.w	EXPR
      0  230d					      DONE		;must be CR
      0  230d					      db	1
      1  230d		       01		      .byte.b	1
      0  230e					      SETIRQ		;Set the line number now
      0  230e					      db	56
      1  230e		       38		      .byte.b	56
      0  230f					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  230f					      db	6
      1  230f		       06		      .byte.b	6
      0  2310					      dw	CO
      1  2310		       62 21		      .word.w	CO
      0  2312					      IJMP	STMT
      0  2312					      db	29
      1  2312		       1d		      .byte.b	29
      0  2313					      dw	STMT
      1  2313		       6a 21		      .word.w	STMT
    448  2315
    449  2315							;=========================================================================
    450  2315							; KILL PID-expression	 kill a running task
    451  2315							;  ignored of task has already stopped
    452  2315							;
    453  2315				   S14Z
      0  2315					      TSTB	S14S1,kKill	; Kill A running Task
      0  2315					      db	101
      1  2315		       65		      .byte.b	101
      0  2316					      db	(S14S1-*)-1
      1  2316		       0c		      .byte.b	(S14S1-*)-1
      0  2317					      db	kKill
      1  2317		       15		      .byte.b	kKill
    455  2318				   ekKill
      0  2318					      CALL	EXPR
      0  2318					      db	28
      1  2318		       1c		      .byte.b	28
      0  2319					      dw	EXPR
      1  2319		       8e 23		      .word.w	EXPR
      0  231b					      DONE
      0  231b					      db	1
      1  231b		       01		      .byte.b	1
      0  231c					      TASKKILL
      0  231c					      db	65
      1  231c		       41		      .byte.b	65
      0  231d					      NXT	CO
      0  231d					      db	6
      1  231d		       06		      .byte.b	6
      0  231e					      dw	CO
      1  231e		       62 21		      .word.w	CO
      0  2320					      IJMP	STMT
      0  2320					      db	29
      1  2320		       1d		      .byte.b	29
      0  2321					      dw	STMT
      1  2321		       6a 21		      .word.w	STMT
    461  2323
    462  2323							;============================================================================
    463  2323							; List all program lines
    464  2323							;
    465  2323				   S14S1
      0  2323					      TSTB	S15,kList	;LIST COMMAND
      0  2323					      db	101
      1  2323		       65		      .byte.b	101
      0  2324					      db	(S15-*)-1
      1  2324		       06		      .byte.b	(S15-*)-1
      0  2325					      db	kList
      1  2325		       16		      .byte.b	kList
    467  2326				   ekList
      0  2326					      DONE
      0  2326					      db	1
      1  2326		       01		      .byte.b	1
      0  2327					      LST
      0  2327					      db	21
      1  2327		       15		      .byte.b	21
      0  2328					      IJMP	CO
      0  2328					      db	29
      1  2328		       1d		      .byte.b	29
      0  2329					      dw	CO
      1  2329		       62 21		      .word.w	CO
    471  232b							;=======================================================================
    472  232b							;RUN begin to executed the program in memory
    473  232b							;
    474  232b				   S15
      0  232b					      TSTB	S16,kRun	;RUN COMMAND
      0  232b					      db	101
      1  232b		       65		      .byte.b	101
      0  232c					      db	(S16-*)-1
      1  232c		       0a		      .byte.b	(S16-*)-1
      0  232d					      db	kRun
      1  232d		       17		      .byte.b	kRun
    476  232e				   ekRun
      0  232e					      DONE
      0  232e					      db	1
      1  232e		       01		      .byte.b	1
      0  232f					      VINIT		;clear variables
      0  232f					      db	30
      1  232f		       1e		      .byte.b	30
      0  2330					      LIT	1	;GOTO line 1
      0  2330					      db	27
      1  2330		       1b		      .byte.b	27
      0  2331					      dw	1
      1  2331		       01 00		      .word.w	1
      0  2333					      XFER		;Bob's addition
      0  2333					      db	7
      1  2333		       07		      .byte.b	7
    481  2334							; EXIT
      0  2334					      IJMP	STMT	;and run!
      0  2334					      db	29
      1  2334		       1d		      .byte.b	29
      0  2335					      dw	STMT
      1  2335		       6a 21		      .word.w	STMT
    483  2337							;=========================================================================
    484  2337							;Clear the program memory, delete all proram lines
    485  2337							;
    486  2337				   S16
      0  2337					      TSTB	S16A,kNew	;clear program
      0  2337					      db	101
      1  2337		       65		      .byte.b	101
      0  2338					      db	(S16A-*)-1
      1  2338		       05		      .byte.b	(S16A-*)-1
      0  2339					      db	kNew
      1  2339		       18		      .byte.b	kNew
    488  233a				   ekNew
      0  233a					      DONE
      0  233a					      db	1
      1  233a		       01		      .byte.b	1
      0  233b					      IJMP	START
      0  233b					      db	29
      1  233b		       1d		      .byte.b	29
      0  233c					      dw	START
      1  233c		       5c 21		      .word.w	START
    491  233e
    492  233e							;========================================================================
    493  233e							; Slice(slice legth expression)
    494  233e							;   set the length of time between task switches
    495  233e							;
    496  233e				   S16A
      0  233e					      TSTB	S16Trace,kSlice
      0  233e					      db	101
      1  233e		       65		      .byte.b	101
      0  233f					      db	(S16Trace-*)-1
      1  233f		       0c		      .byte.b	(S16Trace-*)-1
      0  2340					      db	kSlice
      1  2340		       19		      .byte.b	kSlice
    498  2341				   ekSlice
      0  2341					      CALL	EXPR
      0  2341					      db	28
      1  2341		       1c		      .byte.b	28
      0  2342					      dw	EXPR
      1  2342		       8e 23		      .word.w	EXPR
      0  2344					      SLICE
      0  2344					      db	100
      1  2344		       64		      .byte.b	100
      0  2345					      DONE
      0  2345					      db	1
      1  2345		       01		      .byte.b	1
      0  2346					      NXT	CO
      0  2346					      db	6
      1  2346		       06		      .byte.b	6
      0  2347					      dw	CO
      1  2347		       62 21		      .word.w	CO
      0  2349					      IJMP	STMT
      0  2349					      db	29
      1  2349		       1d		      .byte.b	29
      0  234a					      dw	STMT
      1  234a		       6a 21		      .word.w	STMT
    504  234c							;==========================================================================
    505  234c							; Turn off and on the thrace functions
    506  234c							; a debug terminal needs to be available
    507  234c							; Trace( Trace flag expression)
    508  234c							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    509  234c							;	for individual lines of basic code. These can be combined
    510  234c				   S16Trace
      0  234c					      TSTB	S17A,kTrace
      0  234c					      db	101
      1  234c		       65		      .byte.b	101
      0  234d					      db	(S17A-*)-1
      1  234d		       12		      .byte.b	(S17A-*)-1
      0  234e					      db	kTrace
      1  234e		       1a		      .byte.b	kTrace
    512  234f				   ekTrace
      0  234f					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  234f					      db	101
      1  234f		       65		      .byte.b	101
      0  2350					      db	(UNKNOWN-*)-1
      1  2350		       39		      .byte.b	(UNKNOWN-*)-1
      0  2351					      db	oLeftBracket
      1  2351		       e0		      .byte.b	oLeftBracket
      0  2352					      CALL	EXPR
      0  2352					      db	28
      1  2352		       1c		      .byte.b	28
      0  2353					      dw	EXPR
      1  2353		       8e 23		      .word.w	EXPR
      0  2355					      TSTB	UNKNOWN,oRightBracket
      0  2355					      db	101
      1  2355		       65		      .byte.b	101
      0  2356					      db	(UNKNOWN-*)-1
      1  2356		       33		      .byte.b	(UNKNOWN-*)-1
      0  2357					      db	oRightBracket
      1  2357		       e1		      .byte.b	oRightBracket
      0  2358					      TRACEPROGRAM
      0  2358					      db	78
      1  2358		       4e		      .byte.b	78
      0  2359					      DONE
      0  2359					      db	1
      1  2359		       01		      .byte.b	1
      0  235a					      NXT	CO
      0  235a					      db	6
      1  235a		       06		      .byte.b	6
      0  235b					      dw	CO
      1  235b		       62 21		      .word.w	CO
      0  235d					      IJMP	STMT
      0  235d					      db	29
      1  235d		       1d		      .byte.b	29
      0  235e					      dw	STMT
      1  235e		       6a 21		      .word.w	STMT
    520  2360							;=====================================================================
    521  2360							; Exit basic to machine monitor
    522  2360							;
    523  2360				   S17A
      0  2360					      TSTB	S17B,kExit	;allow them to exit BASIC
      0  2360					      db	101
      1  2360		       65		      .byte.b	101
      0  2361					      db	(S17B-*)-1
      1  2361		       02		      .byte.b	(S17B-*)-1
      0  2362					      db	kExit
      1  2362		       1b		      .byte.b	kExit
    525  2363				   ekExit
      0  2363					      EXIT
      0  2363					      db	26
      1  2363		       1a		      .byte.b	26
    527  2364
    528  2364							;=======================================================================
    529  2364							; Commands related to saving/restoring programs
    530  2364							; to/from mass storage.
    531  2364							;
    532  2364				   S17B
    533  2364					      if	(XKIM || CTMON65) && DISK_ACCESS
    534  2364
      0  2364					      TSTB	S17C,kSave
      0  2364					      db	101
      1  2364		       65		      .byte.b	101
      0  2365					      db	(S17C-*)-1
      1  2365		       07		      .byte.b	(S17C-*)-1
      0  2366					      db	kSave
      1  2366		       1c		      .byte.b	kSave
    536  2367				   ekSave
      0  2367					      OPENWRITE
      0  2367					      db	40
      1  2367		       28		      .byte.b	40
      0  2368					      DLIST
      0  2368					      db	43
      1  2368		       2b		      .byte.b	43
      0  2369					      DCLOSE
      0  2369					      db	41
      1  2369		       29		      .byte.b	41
      0  236a					      IJMP	CO
      0  236a					      db	29
      1  236a		       1d		      .byte.b	29
      0  236b					      dw	CO
      1  236b		       62 21		      .word.w	CO
    541  236d
    542  236d				   S17C
      0  236d					      TSTB	S18,kLoad
      0  236d					      db	101
      1  236d		       65		      .byte.b	101
      0  236e					      db	(S18-*)-1
      1  236e		       0d		      .byte.b	(S18-*)-1
      0  236f					      db	kLoad
      1  236f		       1d		      .byte.b	kLoad
    544  2370				   ekLoad
      0  2370					      OPENREAD
      0  2370					      db	39
      1  2370		       27		      .byte.b	39
    546  2371				   S17CLP
      0  2371					      DGETLINE		;get line from file
      0  2371					      db	42
      1  2371		       2a		      .byte.b	42
      0  2372					      TSTL	S17EOL	;no line num means EOL
      0  2372					      db	34
      1  2372		       22		      .byte.b	34
      0  2373					      db	(S17EOL-*)-1
      1  2373		       04		      .byte.b	(S17EOL-*)-1
      0  2374					      INSERT		;put it into the program
      0  2374					      db	24
      1  2374		       18		      .byte.b	24
      0  2375					      IJMP	S17CLP	;keep going
      0  2375					      db	29
      1  2375		       1d		      .byte.b	29
      0  2376					      dw	S17CLP
      1  2376		       71 23		      .word.w	S17CLP
    551  2378				   S17EOL
      0  2378					      DCLOSE		;close disk file
      0  2378					      db	41
      1  2378		       29		      .byte.b	41
      0  2379					      IJMP	CO	;back to start
      0  2379					      db	29
      1  2379		       1d		      .byte.b	29
      0  237a					      dw	CO
      1  237a		       62 21		      .word.w	CO
    554  237c
    555  237c				   S18
      0  237c					      TSTB	S19,kDir
      0  237c					      db	101
      1  237c		       65		      .byte.b	101
      0  237d					      db	(S19-*)-1
      1  237d		       05		      .byte.b	(S19-*)-1
      0  237e					      db	kDir
      1  237e		       1f		      .byte.b	kDir
    557  237f				   ekDir
      0  237f					      DDIR		;Display the directory content
      0  237f					      db	44
      1  237f		       2c		      .byte.b	44
      0  2380					      IJMP	CO
      0  2380					      db	29
      1  2380		       1d		      .byte.b	29
      0  2381					      dw	CO
      1  2381		       62 21		      .word.w	CO
    560  2383							;=========================================================================
    561  2383							; Erase a file from disk
    562  2383							;
      0  2383				   S19	      TSTB	UNKNOWN,kErase
      0  2383					      db	101
      1  2383		       65		      .byte.b	101
      0  2384					      db	(UNKNOWN-*)-1
      1  2384		       05		      .byte.b	(UNKNOWN-*)-1
      0  2385					      db	kErase
      1  2385		       1e		      .byte.b	kErase
    564  2386				   ekErase
      0  2386					      RMFILE		;Erase the file from the disk
      0  2386					      db	45
      1  2386		       2d		      .byte.b	45
      0  2387					      IJMP	CO
      0  2387					      db	29
      1  2387		       1d		      .byte.b	29
      0  2388					      dw	CO
      1  2388		       62 21		      .word.w	CO
    567  238a
    568  238a					      endif
    569  238a
    570  238a							;
    571  238a							; Else, unknown command.
    572  238a							;
    573  238a				   UNKNOWN
      0  238a					      ENDIO
      0  238a					      db	71
      1  238a		       47		      .byte.b	71
    575  238b
    576  238b				   NotKnownStatement
    577  238b
      0  238b					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  238b					      db	13
      1  238b		       0d		      .byte.b	13
      0  238c					      dw	ERR_SYNTAX
      1  238c		       05 00		      .word.w	ERR_SYNTAX
    579  238e
    580  238e							;=======================================================
    581  238e							; Process Expresions, precidence is represented by the
    582  238e							; various call levels
    583  238e							;
    584  238e				   EXPR
      0  238e					      TSTB	EXPRLOGS,kNot
      0  238e					      db	101
      1  238e		       65		      .byte.b	101
      0  238f					      db	(EXPRLOGS-*)-1
      1  238f		       06		      .byte.b	(EXPRLOGS-*)-1
      0  2390					      db	kNot
      1  2390		       20		      .byte.b	kNot
    586  2391				   ekNot
      0  2391					      Call	EXPR
      0  2391					      db	28
      1  2391		       1c		      .byte.b	28
      0  2392					      dw	EXPR
      1  2392		       8e 23		      .word.w	EXPR
      0  2394					      LOGNOT
      0  2394					      db	72
      1  2394		       48		      .byte.b	72
      0  2395					      RTN
      0  2395					      db	25
      1  2395		       19		      .byte.b	25
    590  2396
    591  2396							;=========================================================
    592  2396							;Look for logical operators
    593  2396				   EXPRLOGS
      0  2396					      Call	EXPRCMP
      0  2396					      db	28
      1  2396		       1c		      .byte.b	28
      0  2397					      dw	EXPRCMP
      1  2397		       b1 23		      .word.w	EXPRCMP
      0  2399					      TSTB	iLOG1,kAnd
      0  2399					      db	101
      1  2399		       65		      .byte.b	101
      0  239a					      db	(iLOG1-*)-1
      1  239a		       06		      .byte.b	(iLOG1-*)-1
      0  239b					      db	kAnd
      1  239b		       23		      .byte.b	kAnd
    596  239c				   ekAnd
      0  239c					      Call	EXPR
      0  239c					      db	28
      1  239c		       1c		      .byte.b	28
      0  239d					      dw	EXPR
      1  239d		       8e 23		      .word.w	EXPR
      0  239f					      LOGAND
      0  239f					      db	74
      1  239f		       4a		      .byte.b	74
      0  23a0					      RTN
      0  23a0					      db	25
      1  23a0		       19		      .byte.b	25
    600  23a1				   iLOG1
      0  23a1					      TSTB	iLOG2,kOr
      0  23a1					      db	101
      1  23a1		       65		      .byte.b	101
      0  23a2					      db	(iLOG2-*)-1
      1  23a2		       06		      .byte.b	(iLOG2-*)-1
      0  23a3					      db	kOr
      1  23a3		       21		      .byte.b	kOr
    602  23a4				   ekOr
      0  23a4					      Call	EXPR
      0  23a4					      db	28
      1  23a4		       1c		      .byte.b	28
      0  23a5					      dw	EXPR
      1  23a5		       8e 23		      .word.w	EXPR
      0  23a7					      LOGOR
      0  23a7					      db	73
      1  23a7		       49		      .byte.b	73
      0  23a8					      RTN
      0  23a8					      db	25
      1  23a8		       19		      .byte.b	25
    606  23a9				   iLOG2
      0  23a9					      TSTB	iLOG3,kXor
      0  23a9					      db	101
      1  23a9		       65		      .byte.b	101
      0  23aa					      db	(iLOG3-*)-1
      1  23aa		       05		      .byte.b	(iLOG3-*)-1
      0  23ab					      db	kXor
      1  23ab		       22		      .byte.b	kXor
    608  23ac				   ekXor
      0  23ac					      Call	EXPR
      0  23ac					      db	28
      1  23ac		       1c		      .byte.b	28
      0  23ad					      dw	EXPR
      1  23ad		       8e 23		      .word.w	EXPR
      0  23af					      LOGXOR
      0  23af					      db	75
      1  23af		       4b		      .byte.b	75
    611  23b0				   iLOG3
      0  23b0					      RTN
      0  23b0					      db	25
      1  23b0		       19		      .byte.b	25
    613  23b1
    614  23b1				   EXPRCMP
      0  23b1					      Call	EXPR2	; get the first expression
      0  23b1					      db	28
      1  23b1		       1c		      .byte.b	28
      0  23b2					      dw	EXPR2
      1  23b2		       bc 23		      .word.w	EXPR2
      0  23b4					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  23b4					      db	104
      1  23b4		       68		      .byte.b	104
      0  23b5					      db	(iRDone-*)-1
      1  23b5		       05		      .byte.b	(iRDone-*)-1
    617  23b6							;	  TSTB	     iR0,oEqual
    618  23b6							;	  LIT	     2		     ;=
    619  23b6							;	  IJMP	     iRFound
    620  23b6							;iR0:
    621  23b6							;	  TSTB	      iR1,oLessEqual
    622  23b6							;	  LIT	      3 	      ;<=
    623  23b6							;	  IJMP	     iRFound
    624  23b6							;iR1:
    625  23b6							;	  TSTB	     iR3,oNotEqual
    626  23b6							;	  LIT	     5		      ;<>
    627  23b6							;	      IJMP	  iRFound
    628  23b6							;iR3:
    629  23b6							;	  TSTB	     iR4,oLess
    630  23b6							;	  LIT	     1		     ;<
    631  23b6							;	      IJMP	  iRFound
    632  23b6							;iR4:
    633  23b6							;	  TST	     iR5,oGreaterEqual
    634  23b6							;	  LIT	     6		     ;>=
    635  23b6							;	      IJMP	  iRFound
    636  23b6							;iR5:
    637  23b6							;	  TSTB	     iRDone,oGreater
    638  23b6							;	  LIT	     4		     ;>
    639  23b6				   iRFound
      0  23b6					      Call	EXPR	; get the right side of the expression
      0  23b6					      db	28
      1  23b6		       1c		      .byte.b	28
      0  23b7					      dw	EXPR
      1  23b7		       8e 23		      .word.w	EXPR
      0  23b9					      CMPR		; Push the value of the true false onto the stack
      0  23b9					      db	10
      1  23b9		       0a		      .byte.b	10
      0  23ba					      RTN
      0  23ba					      db	25
      1  23ba		       19		      .byte.b	25
    643  23bb
    644  23bb				   iRDone
      0  23bb					      RTN
      0  23bb					      db	25
      1  23bb		       19		      .byte.b	25
    646  23bc
    647  23bc				   EXPR2
      0  23bc					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  23bc					      db	101
      1  23bc		       65		      .byte.b	101
      0  23bd					      db	(E0-*)-1
      1  23bd		       08		      .byte.b	(E0-*)-1
      0  23be					      db	oMinus
      1  23be		       eb		      .byte.b	oMinus
      0  23bf					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  23bf					      db	28
      1  23bf		       1c		      .byte.b	28
      0  23c0					      dw	TERM
      1  23c0		       e2 23		      .word.w	TERM
      0  23c2					      NEG		; Make value negated
      0  23c2					      db	16
      1  23c2		       10		      .byte.b	16
      0  23c3					      IJMP	E1	; We have Left term process operators next
      0  23c3					      db	29
      1  23c3		       1d		      .byte.b	29
      0  23c4					      dw	E1
      1  23c4		       cc 23		      .word.w	E1
    652  23c6				   E0
      0  23c6					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  23c6					      db	101
      1  23c6		       65		      .byte.b	101
      0  23c7					      db	(E1A-*)-1
      1  23c7		       01		      .byte.b	(E1A-*)-1
      0  23c8					      db	oPlus
      1  23c8		       ea		      .byte.b	oPlus
    654  23c9				   E1A
      0  23c9					      CALL	TERM	; Get the left term if it was not negated
      0  23c9					      db	28
      1  23c9		       1c		      .byte.b	28
      0  23ca					      dw	TERM
      1  23ca		       e2 23		      .word.w	TERM
    656  23cc				   E1
      0  23cc					      TST	E2,oPlus	; Check if we are adding left term to something
      0  23cc					      db	32
      1  23cc		       20		      .byte.b	32
      0  23cd					      db	(E2-*)-1
      1  23cd		       09		      .byte.b	(E2-*)-1
      0  23ce					      db	oPlus,0
      1  23ce		       ea 00		      .byte.b	oPlus,0
      0  23d0					      CALL	TERM	; if adding then get the right side term
      0  23d0					      db	28
      1  23d0		       1c		      .byte.b	28
      0  23d1					      dw	TERM
      1  23d1		       e2 23		      .word.w	TERM
      0  23d3					      ADD		; Add it to left term
      0  23d3					      db	14
      1  23d3		       0e		      .byte.b	14
      0  23d4					      IJMP	E1	; look for next + or -
      0  23d4					      db	29
      1  23d4		       1d		      .byte.b	29
      0  23d5					      dw	E1
      1  23d5		       cc 23		      .word.w	E1
    661  23d7				   E2
      0  23d7					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  23d7					      db	101
      1  23d7		       65		      .byte.b	101
      0  23d8					      db	(E3-*)-1
      1  23d8		       08		      .byte.b	(E3-*)-1
      0  23d9					      db	oMinus
      1  23d9		       eb		      .byte.b	oMinus
      0  23da					      CALL	TERM	; get right side to subtract Diffrence
      0  23da					      db	28
      1  23da		       1c		      .byte.b	28
      0  23db					      dw	TERM
      1  23db		       e2 23		      .word.w	TERM
      0  23dd					      SUB		; Subtract the value
      0  23dd					      db	15
      1  23dd		       0f		      .byte.b	15
      0  23de					      IJMP	E1	; Look for next + or -
      0  23de					      db	29
      1  23de		       1d		      .byte.b	29
      0  23df					      dw	E1
      1  23df		       cc 23		      .word.w	E1
    666  23e1				   E3			; Finish processing the expression
      0  23e1					      RTN		; We are finished processing the Expression
      0  23e1					      db	25
      1  23e1		       19		      .byte.b	25
    668  23e2							;
    669  23e2							; Get one of the terms of an expression
    670  23e2							;
    671  23e2				   TERM
      0  23e2					      CALL	FACT	; Get a value
      0  23e2					      db	28
      1  23e2		       1c		      .byte.b	28
      0  23e3					      dw	FACT
      1  23e3		       07 24		      .word.w	FACT
    673  23e5				   T0			; Check for higher precidence operators
      0  23e5					      TSTB	T1,oMultiply	; Check for *
      0  23e5					      db	101
      1  23e5		       65		      .byte.b	101
      0  23e6					      db	(T1-*)-1
      1  23e6		       08		      .byte.b	(T1-*)-1
      0  23e7					      db	oMultiply
      1  23e7		       ee		      .byte.b	oMultiply
      0  23e8					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  23e8					      db	28
      1  23e8		       1c		      .byte.b	28
      0  23e9					      dw	FACT
      1  23e9		       07 24		      .word.w	FACT
      0  23eb					      MUL		; Multiply factors
      0  23eb					      db	17
      1  23eb		       11		      .byte.b	17
      0  23ec					      IJMP	T0	; Check for * or /
      0  23ec					      db	29
      1  23ec		       1d		      .byte.b	29
      0  23ed					      dw	T0
      1  23ed		       e5 23		      .word.w	T0
    678  23ef				   T1
      0  23ef					      TSTB	T2,oDivide	; Check for a division
      0  23ef					      db	101
      1  23ef		       65		      .byte.b	101
      0  23f0					      db	(T2-*)-1
      1  23f0		       08		      .byte.b	(T2-*)-1
      0  23f1					      db	oDivide
      1  23f1		       ec		      .byte.b	oDivide
      0  23f2					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  23f2					      db	28
      1  23f2		       1c		      .byte.b	28
      0  23f3					      dw	FACT
      1  23f3		       07 24		      .word.w	FACT
      0  23f5					      DIV		; do division
      0  23f5					      db	18
      1  23f5		       12		      .byte.b	18
      0  23f6					      IJMP	T0	; check for more * or /
      0  23f6					      db	29
      1  23f6		       1d		      .byte.b	29
      0  23f7					      dw	T0
      1  23f7		       e5 23		      .word.w	T0
    683  23f9				   T2
      0  23f9					      TSTB	T3,oModulo	; Check for a division
      0  23f9					      db	101
      1  23f9		       65		      .byte.b	101
      0  23fa					      db	(T3-*)-1
      1  23fa		       08		      .byte.b	(T3-*)-1
      0  23fb					      db	oModulo
      1  23fb		       ed		      .byte.b	oModulo
      0  23fc					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  23fc					      db	28
      1  23fc		       1c		      .byte.b	28
      0  23fd					      dw	FACT
      1  23fd		       07 24		      .word.w	FACT
      0  23ff					      MODULO		; do division for remainder
      0  23ff					      db	60
      1  23ff		       3c		      .byte.b	60
      0  2400					      IJMP	T0	; check for more * or / or %
      0  2400					      db	29
      1  2400		       1d		      .byte.b	29
      0  2401					      dw	T0
      1  2401		       e5 23		      .word.w	T0
    688  2403				   T3			; Finish processing the Term
      0  2403					      RTN
      0  2403					      db	25
      1  2403		       19		      .byte.b	25
    690  2404
    691  2404				   UNKNOWNVEC
      0  2404					      IJMP	UNKNOWN
      0  2404					      db	29
      1  2404		       1d		      .byte.b	29
      0  2405					      dw	UNKNOWN
      1  2405		       8a 23		      .word.w	UNKNOWN
    693  2407
    694  2407							;=============================================================================================
    695  2407							; Factor an expression.  Always test for functions
    696  2407							; first or else they'll be confused for variables.
    697  2407							;
    698  2407				   FACT
      0  2407					      OnGoto	BasicFuncs,FactNumber
      0  2407					      db	103
      1  2407		       67		      .byte.b	103
      0  2408					      dw	BasicFuncs
      1  2408		       3c 21		      .word.w	BasicFuncs
      0  240a					      dw	FactNumber
      1  240a		       f4 24		      .word.w	FactNumber
    700  240c
    701  240c				   FACTCONTINUE
      0  240c					      TSTB	F1AA,kTrue
      0  240c					      db	101
      1  240c		       65		      .byte.b	101
      0  240d					      db	(F1AA-*)-1
      1  240d		       05		      .byte.b	(F1AA-*)-1
      0  240e					      db	kTrue
      1  240e		       24		      .byte.b	kTrue
    703  240f				   ekTrue
      0  240f					      LIT	-1
      0  240f					      db	27
      1  240f		       1b		      .byte.b	27
      0  2410					      dw	-1
      1  2410		       ff ff		      .word.w	-1
      0  2412					      RTN
      0  2412					      db	25
      1  2412		       19		      .byte.b	25
    706  2413				   F1AA
      0  2413					      TSTB	F1AB,kFalse
      0  2413					      db	101
      1  2413		       65		      .byte.b	101
      0  2414					      db	(F1AB-*)-1
      1  2414		       05		      .byte.b	(F1AB-*)-1
      0  2415					      db	kFalse
      1  2415		       25		      .byte.b	kFalse
    708  2416				   ekFalse
      0  2416					      LIT	0
      0  2416					      db	27
      1  2416		       1b		      .byte.b	27
      0  2417					      dw	0
      1  2417		       00 00		      .word.w	0
      0  2419					      RTN
      0  2419					      db	25
      1  2419		       19		      .byte.b	25
    711  241a							;==================================================================================
    712  241a							; Returns the amount of free SPACE
    713  241a							;
    714  241a				   F1AB
      0  241a					      TSTB	F1A,kFree
      0  241a					      db	101
      1  241a		       65		      .byte.b	101
      0  241b					      db	(F1A-*)-1
      1  241b		       09		      .byte.b	(F1A-*)-1
      0  241c					      db	kFree
      1  241c		       26		      .byte.b	kFree
    716  241d				   ekFree
      0  241d					      TSTB	UNKNOWNVEC,oLeftBracket
      0  241d					      db	101
      1  241d		       65		      .byte.b	101
      0  241e					      db	(UNKNOWNVEC-*)-1
      1  241e		       e5		      .byte.b	(UNKNOWNVEC-*)-1
      0  241f					      db	oLeftBracket
      1  241f		       e0		      .byte.b	oLeftBracket
      0  2420					      TSTB	UNKNOWNVEC,oRightBracket
      0  2420					      db	101
      1  2420		       65		      .byte.b	101
      0  2421					      db	(UNKNOWNVEC-*)-1
      1  2421		       e2		      .byte.b	(UNKNOWNVEC-*)-1
      0  2422					      db	oRightBracket
      1  2422		       e1		      .byte.b	oRightBracket
      0  2423					      FREE
      0  2423					      db	36
      1  2423		       24		      .byte.b	36
      0  2424					      RTN
      0  2424					      db	25
      1  2424		       19		      .byte.b	25
    721  2425							;===================================================================================
    722  2425							; getch() read a character from the input device
    723  2425							;
    724  2425				   F1A
      0  2425					      TSTB	F1A2,kGetch	; read char from the terminal
      0  2425					      db	101
      1  2425		       65		      .byte.b	101
      0  2426					      db	(F1A2-*)-1
      1  2426		       09		      .byte.b	(F1A2-*)-1
      0  2427					      db	kGetch
      1  2427		       27		      .byte.b	kGetch
    726  2428				   ekGetch
      0  2428					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2428					      db	101
      1  2428		       65		      .byte.b	101
      0  2429					      db	(UNKNOWNVEC-*)-1
      1  2429		       da		      .byte.b	(UNKNOWNVEC-*)-1
      0  242a					      db	oLeftBracket
      1  242a		       e0		      .byte.b	oLeftBracket
      0  242b					      TSTB	UNKNOWNVEC,oRightBracket
      0  242b					      db	101
      1  242b		       65		      .byte.b	101
      0  242c					      db	(UNKNOWNVEC-*)-1
      1  242c		       d7		      .byte.b	(UNKNOWNVEC-*)-1
      0  242d					      db	oRightBracket
      1  242d		       e1		      .byte.b	oRightBracket
      0  242e					      GETCHAR
      0  242e					      db	51
      1  242e		       33		      .byte.b	51
      0  242f					      RTN
      0  242f					      db	25
      1  242f		       19		      .byte.b	25
    731  2430							;====================================================================================
    732  2430							; peek(mem address) return the value of a byte in memory
    733  2430							; @[offset] return a word value from offset -- see tstv
    734  2430							;
    735  2430				   F1A2
      0  2430					      TSTB	F2AZ,kPeek	;Return a value from memory
      0  2430					      db	101
      1  2430		       65		      .byte.b	101
      0  2431					      db	(F2AZ-*)-1
      1  2431		       0c		      .byte.b	(F2AZ-*)-1
      0  2432					      db	kPeek
      1  2432		       28		      .byte.b	kPeek
    737  2433				   ekPeek
      0  2433					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2433					      db	101
      1  2433		       65		      .byte.b	101
      0  2434					      db	(UNKNOWNVEC-*)-1
      1  2434		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  2435					      db	oLeftBracket
      1  2435		       e0		      .byte.b	oLeftBracket
      0  2436					      CALL	EXPR	;Get the address to write to
      0  2436					      db	28
      1  2436		       1c		      .byte.b	28
      0  2437					      dw	EXPR
      1  2437		       8e 23		      .word.w	EXPR
      0  2439					      TSTB	UNKNOWNVEC,oRightBracket
      0  2439					      db	101
      1  2439		       65		      .byte.b	101
      0  243a					      db	(UNKNOWNVEC-*)-1
      1  243a		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  243b					      db	oRightBracket
      1  243b		       e1		      .byte.b	oRightBracket
      0  243c					      PEEKMEM
      0  243c					      db	48
      1  243c		       30		      .byte.b	48
      0  243d					      RTN
      0  243d					      db	25
      1  243d		       19		      .byte.b	25
    743  243e							;=======================================================================================
    744  243e							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    745  243e							;
    746  243e				   F2AZ
      0  243e					      TSTB	F2AZ1,kTask	;Check if we are setting a task start
      0  243e					      db	101
      1  243e		       65		      .byte.b	101
      0  243f					      db	(F2AZ1-*)-1
      1  243f		       1d		      .byte.b	(F2AZ1-*)-1
      0  2440					      db	kTask
      1  2440		       29		      .byte.b	kTask
    748  2441				   ekTask
      0  2441					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2441					      db	101
      1  2441		       65		      .byte.b	101
      0  2442					      db	(UNKNOWNVEC-*)-1
      1  2442		       c1		      .byte.b	(UNKNOWNVEC-*)-1
      0  2443					      db	oLeftBracket
      1  2443		       e0		      .byte.b	oLeftBracket
      0  2444					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2444					      db	28
      1  2444		       1c		      .byte.b	28
      0  2445					      dw	EXPR
      1  2445		       8e 23		      .word.w	EXPR
      0  2447					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  2447					      db	61
      1  2447		       3d		      .byte.b	61
      0  2448					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  2448					      db	101
      1  2448		       65		      .byte.b	101
      0  2449					      db	(F2AZNoParms-*)-1
      1  2449		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  244a					      db	oComma
      1  244a		       e2		      .byte.b	oComma
      0  244b					      SAVEMATHSTACK		;Push The mathstack
      0  244b					      db	86
      1  244b		       56		      .byte.b	86
      0  244c					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  244c					      db	89
      1  244c		       59		      .byte.b	89
    755  244d				   F2AZLOOP
      0  244d					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  244d					      db	28
      1  244d		       1c		      .byte.b	28
      0  244e					      dw	EXPR
      1  244e		       8e 23		      .word.w	EXPR
      0  2450					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  2450					      db	101
      1  2450		       65		      .byte.b	101
      0  2451					      db	(F2AZEndParm-*)-1
      1  2451		       04		      .byte.b	(F2AZEndParm-*)-1
      0  2452					      db	oComma
      1  2452		       e2		      .byte.b	oComma
      0  2453					      IJMP	F2AZLOOP	;check for more
      0  2453					      db	29
      1  2453		       1d		      .byte.b	29
      0  2454					      dw	F2AZLOOP
      1  2454		       4d 24		      .word.w	F2AZLOOP
    759  2456				   F2AZEndParm
      0  2456					      RESTOREMATHSTACK		;Back to normal stack
      0  2456					      db	87
      1  2456		       57		      .byte.b	87
      0  2457					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  2457					      db	92
      1  2457		       5c		      .byte.b	92
    762  2458				   F2AZNoParms
      0  2458					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  2458					      db	101
      1  2458		       65		      .byte.b	101
      0  2459					      db	(UNKNOWNVEC-*)-1
      1  2459		       aa		      .byte.b	(UNKNOWNVEC-*)-1
      0  245a					      db	oRightBracket
      1  245a		       e1		      .byte.b	oRightBracket
      0  245b					      TASKENABLE		;Enable the task to execute
      0  245b					      db	90
      1  245b		       5a		      .byte.b	90
      0  245c					      RTN		;Returns the Task number
      0  245c					      db	25
      1  245c		       19		      .byte.b	25
    766  245d							;=========================================================================================
    767  245d							; Check for IPC interproccess instructions
    768  245d							;   IPCS  - Send a message
    769  245d							;
    770  245d				   F2AZ1
      0  245d					      TSTB	F2AZa,kIpcs	;Test if one of the IPC functions
      0  245d					      db	101
      1  245d		       65		      .byte.b	101
      0  245e					      db	(F2AZa-*)-1
      1  245e		       12		      .byte.b	(F2AZa-*)-1
      0  245f					      db	kIpcs
      1  245f		       2b		      .byte.b	kIpcs
    772  2460				   ekIpcs
      0  2460					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2460					      db	101
      1  2460		       65		      .byte.b	101
      0  2461					      db	(UNKNOWNVEC-*)-1
      1  2461		       a2		      .byte.b	(UNKNOWNVEC-*)-1
      0  2462					      db	oLeftBracket
      1  2462		       e0		      .byte.b	oLeftBracket
      0  2463					      CALL	EXPR	;Get the message value
      0  2463					      db	28
      1  2463		       1c		      .byte.b	28
      0  2464					      dw	EXPR
      1  2464		       8e 23		      .word.w	EXPR
      0  2466					      TSTB	UNKNOWNVEC,oComma
      0  2466					      db	101
      1  2466		       65		      .byte.b	101
      0  2467					      db	(UNKNOWNVEC-*)-1
      1  2467		       9c		      .byte.b	(UNKNOWNVEC-*)-1
      0  2468					      db	oComma
      1  2468		       e2		      .byte.b	oComma
      0  2469					      CALL	EXPR	;Get pid of task to send to
      0  2469					      db	28
      1  2469		       1c		      .byte.b	28
      0  246a					      dw	EXPR
      1  246a		       8e 23		      .word.w	EXPR
      0  246c					      TSTB	UNKNOWNVEC,oRightBracket
      0  246c					      db	101
      1  246c		       65		      .byte.b	101
      0  246d					      db	(UNKNOWNVEC-*)-1
      1  246d		       96		      .byte.b	(UNKNOWNVEC-*)-1
      0  246e					      db	oRightBracket
      1  246e		       e1		      .byte.b	oRightBracket
      0  246f					      IPCSEND		;Send msg and clear pid msg pending
      0  246f					      db	80
      1  246f		       50		      .byte.b	80
      0  2470					      RTN
      0  2470					      db	25
      1  2470		       19		      .byte.b	25
    780  2471							;================================================================================
    781  2471							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    782  2471							;
    783  2471				   F2AZa
      0  2471					      TSTB	F2AZb,kIpcr	;IPCR recieve a message , wait if none
      0  2471					      db	101
      1  2471		       65		      .byte.b	101
      0  2472					      db	(F2AZb-*)-1
      1  2472		       15		      .byte.b	(F2AZb-*)-1
      0  2473					      db	kIpcr
      1  2473		       2c		      .byte.b	kIpcr
    785  2474				   ekIpcr
      0  2474					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2474					      db	101
      1  2474		       65		      .byte.b	101
      0  2475					      db	(UNKNOWNVEC-*)-1
      1  2475		       8e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2476					      db	oLeftBracket
      1  2476		       e0		      .byte.b	oLeftBracket
      0  2477					      TSTB	F2AZa1,oRightBracket
      0  2477					      db	101
      1  2477		       65		      .byte.b	101
      0  2478					      db	(F2AZa1-*)-1
      1  2478		       07		      .byte.b	(F2AZa1-*)-1
      0  2479					      db	oRightBracket
      1  2479		       e1		      .byte.b	oRightBracket
      0  247a					      LIT	0	;We dont want the pid returned to us
      0  247a					      db	27
      1  247a		       1b		      .byte.b	27
      0  247b					      dw	0
      1  247b		       00 00		      .word.w	0
      0  247d					      IPCIO		;Set the io bit and suspend the task till message
      0  247d					      db	83
      1  247d		       53		      .byte.b	83
      0  247e					      IPCRECEIVE		;Get the message
      0  247e					      db	81
      1  247e		       51		      .byte.b	81
      0  247f					      RTN
      0  247f					      db	25
      1  247f		       19		      .byte.b	25
    792  2480				   F2AZa1
      0  2480					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  2480					      db	33
      1  2480		       21		      .byte.b	33
      0  2481					      db	(UNKNOWNVEC-*)-1
      1  2481		       82		      .byte.b	(UNKNOWNVEC-*)-1
      0  2482					      TSTB	UNKNOWNVEC,oRightBracket
      0  2482					      db	101
      1  2482		       65		      .byte.b	101
      0  2483					      db	(UNKNOWNVEC-*)-1
      1  2483		       80		      .byte.b	(UNKNOWNVEC-*)-1
      0  2484					      db	oRightBracket
      1  2484		       e1		      .byte.b	oRightBracket
      0  2485					      IPCIO		;Set the io bit and exit task till message
      0  2485					      db	83
      1  2485		       53		      .byte.b	83
      0  2486					      IPCRECEIVE		;Get the message
      0  2486					      db	81
      1  2486		       51		      .byte.b	81
      0  2487					      RTN
      0  2487					      db	25
      1  2487		       19		      .byte.b	25
    798  2488							;===============================================================================
    799  2488							; IPCC ---- check if a message is available
    800  2488				   F2AZb
      0  2488					      TST	F2A,kIpcc	;Returns number of messages on the message queue
      0  2488					      db	32
      1  2488		       20		      .byte.b	32
      0  2489					      db	(F2A-*)-1
      1  2489		       0d		      .byte.b	(F2A-*)-1
      0  248a					      db	kIpcc,0
      1  248a		       2a 00		      .byte.b	kIpcc,0
    802  248c				   ekIpcc
      0  248c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  248c					      db	101
      1  248c		       65		      .byte.b	101
      0  248d					      db	(UNKNOWNVEC-*)-1
      1  248d		       76		      .byte.b	(UNKNOWNVEC-*)-1
      0  248e					      db	oLeftBracket
      1  248e		       e0		      .byte.b	oLeftBracket
      0  248f					      TSTB	UNKNOWNVEC,oRightBracket
      0  248f					      db	101
      1  248f		       65		      .byte.b	101
      0  2490					      db	(UNKNOWNVEC-*)-1
      1  2490		       73		      .byte.b	(UNKNOWNVEC-*)-1
      0  2491					      db	oRightBracket
      1  2491		       e1		      .byte.b	oRightBracket
      0  2492					      IPCCHECK
      0  2492					      db	82
      1  2492		       52		      .byte.b	82
      0  2493					      RTN
      0  2493					      db	25
      1  2493		       19		      .byte.b	25
    807  2494
    808  2494				   UNKNOWNID
      0  2494					      IJMP	UNKNOWN
      0  2494					      db	29
      1  2494		       1d		      .byte.b	29
      0  2495					      dw	UNKNOWN
      1  2495		       8a 23		      .word.w	UNKNOWN
    810  2497							;============================================================
    811  2497							; RND() is supposed to have an argument but if none
    812  2497							; was provided, just assume a large value.
    813  2497							;
    814  2497				   F2A
      0  2497					      TSTB	F2B,kRnd
      0  2497					      db	101
      1  2497		       65		      .byte.b	101
      0  2498					      db	(F2B-*)-1
      1  2498		       14		      .byte.b	(F2B-*)-1
      0  2499					      db	kRnd
      1  2499		       2d		      .byte.b	kRnd
    816  249a				   ekRnd
      0  249a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  249a					      db	101
      1  249a		       65		      .byte.b	101
      0  249b					      db	(UNKNOWNVEC-*)-1
      1  249b		       68		      .byte.b	(UNKNOWNVEC-*)-1
      0  249c					      db	oLeftBracket
      1  249c		       e0		      .byte.b	oLeftBracket
      0  249d					      TSTB	F2A1,oRightBracket
      0  249d					      db	101
      1  249d		       65		      .byte.b	101
      0  249e					      db	(F2A1-*)-1
      1  249e		       06		      .byte.b	(F2A1-*)-1
      0  249f					      db	oRightBracket
      1  249f		       e1		      .byte.b	oRightBracket
      0  24a0					      LIT	32766
      0  24a0					      db	27
      1  24a0		       1b		      .byte.b	27
      0  24a1					      dw	32766
      1  24a1		       fe 7f		      .word.w	32766
      0  24a3					      RANDOM
      0  24a3					      db	37
      1  24a3		       25		      .byte.b	37
      0  24a4					      RTN
      0  24a4					      db	25
      1  24a4		       19		      .byte.b	25
    822  24a5
    823  24a5				   F2A1
      0  24a5					      CALL	FACT	;GET RANGE
      0  24a5					      db	28
      1  24a5		       1c		      .byte.b	28
      0  24a6					      dw	FACT
      1  24a6		       07 24		      .word.w	FACT
      0  24a8					      TSTB	UNKNOWNVEC,oRightBracket
      0  24a8					      db	101
      1  24a8		       65		      .byte.b	101
      0  24a9					      db	(UNKNOWNVEC-*)-1
      1  24a9		       5a		      .byte.b	(UNKNOWNVEC-*)-1
      0  24aa					      db	oRightBracket
      1  24aa		       e1		      .byte.b	oRightBracket
      0  24ab					      RANDOM
      0  24ab					      db	37
      1  24ab		       25		      .byte.b	37
      0  24ac					      RTN
      0  24ac					      db	25
      1  24ac		       19		      .byte.b	25
    828  24ad							;==========================================================
    829  24ad							;	Return absolute value of expresion
    830  24ad							;
    831  24ad				   F2B
      0  24ad					      TSTB	F2B2,kAbs
      0  24ad					      db	101
      1  24ad		       65		      .byte.b	101
      0  24ae					      db	(F2B2-*)-1
      1  24ae		       0c		      .byte.b	(F2B2-*)-1
      0  24af					      db	kAbs
      1  24af		       2f		      .byte.b	kAbs
    833  24b0				   ekAbs
      0  24b0					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24b0					      db	101
      1  24b0		       65		      .byte.b	101
      0  24b1					      db	(UNKNOWNVEC-*)-1
      1  24b1		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  24b2					      db	oLeftBracket
      1  24b2		       e0		      .byte.b	oLeftBracket
      0  24b3					      CALL	EXPR	;get value
      0  24b3					      db	28
      1  24b3		       1c		      .byte.b	28
      0  24b4					      dw	EXPR
      1  24b4		       8e 23		      .word.w	EXPR
      0  24b6					      TSTB	UNKNOWNVEC,oRightBracket
      0  24b6					      db	101
      1  24b6		       65		      .byte.b	101
      0  24b7					      db	(UNKNOWNVEC-*)-1
      1  24b7		       4c		      .byte.b	(UNKNOWNVEC-*)-1
      0  24b8					      db	oRightBracket
      1  24b8		       e1		      .byte.b	oRightBracket
      0  24b9					      ABS
      0  24b9					      db	38
      1  24b9		       26		      .byte.b	38
      0  24ba					      RTN
      0  24ba					      db	25
      1  24ba		       19		      .byte.b	25
    839  24bb							;============================================================
    840  24bb							;     Return the the status of a task, provide the PID
    841  24bb							;
    842  24bb				   F2B2
      0  24bb					      TSTB	F2Z,kStat
      0  24bb					      db	101
      1  24bb		       65		      .byte.b	101
      0  24bc					      db	(F2Z-*)-1
      1  24bc		       0c		      .byte.b	(F2Z-*)-1
      0  24bd					      db	kStat
      1  24bd		       2e		      .byte.b	kStat
    844  24be				   ekStat
      0  24be					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24be					      db	101
      1  24be		       65		      .byte.b	101
      0  24bf					      db	(UNKNOWNVEC-*)-1
      1  24bf		       44		      .byte.b	(UNKNOWNVEC-*)-1
      0  24c0					      db	oLeftBracket
      1  24c0		       e0		      .byte.b	oLeftBracket
      0  24c1					      Call	EXPR
      0  24c1					      db	28
      1  24c1		       1c		      .byte.b	28
      0  24c2					      dw	EXPR
      1  24c2		       8e 23		      .word.w	EXPR
      0  24c4					      TSTB	UNKNOWNVEC,oRightBracket
      0  24c4					      db	101
      1  24c4		       65		      .byte.b	101
      0  24c5					      db	(UNKNOWNVEC-*)-1
      1  24c5		       3e		      .byte.b	(UNKNOWNVEC-*)-1
      0  24c6					      db	oRightBracket
      1  24c6		       e1		      .byte.b	oRightBracket
      0  24c7					      TASKSTAT
      0  24c7					      db	66
      1  24c7		       42		      .byte.b	66
      0  24c8					      RTN
      0  24c8					      db	25
      1  24c8		       19		      .byte.b	25
    850  24c9				   F2Z
      0  24c9					      TSTB	F2ZA,kPid
      0  24c9					      db	101
      1  24c9		       65		      .byte.b	101
      0  24ca					      db	(F2ZA-*)-1
      1  24ca		       03		      .byte.b	(F2ZA-*)-1
      0  24cb					      db	kPid
      1  24cb		       32		      .byte.b	kPid
    852  24cc				   ekPid
      0  24cc					      TASKPID
      0  24cc					      db	77
      1  24cc		       4d		      .byte.b	77
      0  24cd					      RTN
      0  24cd					      db	25
      1  24cd		       19		      .byte.b	25
    855  24ce							;===========================================================================
    856  24ce							; Call a machine function, provide the address to call and optionally
    857  24ce							; the value to be passed in reg A
    858  24ce				   F2ZA
      0  24ce					      TSTB	F2FUNC,kCall	;call machine function
      0  24ce					      db	101
      1  24ce		       65		      .byte.b	101
      0  24cf					      db	(F2FUNC-*)-1
      1  24cf		       1a		      .byte.b	(F2FUNC-*)-1
      0  24d0					      db	kCall
      1  24d0		       30		      .byte.b	kCall
    860  24d1				   ekCall
      0  24d1					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24d1					      db	101
      1  24d1		       65		      .byte.b	101
      0  24d2					      db	(UNKNOWNVEC-*)-1
      1  24d2		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  24d3					      db	oLeftBracket
      1  24d3		       e0		      .byte.b	oLeftBracket
      0  24d4					      CALL	EXPR
      0  24d4					      db	28
      1  24d4		       1c		      .byte.b	28
      0  24d5					      dw	EXPR
      1  24d5		       8e 23		      .word.w	EXPR
      0  24d7					      TSTB	F2B2A,oComma
      0  24d7					      db	101
      1  24d7		       65		      .byte.b	101
      0  24d8					      db	(F2B2A-*)-1
      1  24d8		       09		      .byte.b	(F2B2A-*)-1
      0  24d9					      db	oComma
      1  24d9		       e2		      .byte.b	oComma
      0  24da					      CALL	EXPR
      0  24da					      db	28
      1  24da		       1c		      .byte.b	28
      0  24db					      dw	EXPR
      1  24db		       8e 23		      .word.w	EXPR
      0  24dd					      TSTB	UNKNOWNVEC,oRightBracket
      0  24dd					      db	101
      1  24dd		       65		      .byte.b	101
      0  24de					      db	(UNKNOWNVEC-*)-1
      1  24de		       25		      .byte.b	(UNKNOWNVEC-*)-1
      0  24df					      db	oRightBracket
      1  24df		       e1		      .byte.b	oRightBracket
      0  24e0					      CALLFUNC
      0  24e0					      db	53
      1  24e0		       35		      .byte.b	53
      0  24e1					      RTN
      0  24e1					      db	25
      1  24e1		       19		      .byte.b	25
    868  24e2							; Run the gosub within this function
    869  24e2				   F2B2A
      0  24e2					      TSTB	UNKNOWNID,oRightBracket
      0  24e2					      db	101
      1  24e2		       65		      .byte.b	101
      0  24e3					      db	(UNKNOWNID-*)-1
      1  24e3		       b0		      .byte.b	(UNKNOWNID-*)-1
      0  24e4					      db	oRightBracket
      1  24e4		       e1		      .byte.b	oRightBracket
      0  24e5					      LIT	0	; No parameter passed so just load zero to A
      0  24e5					      db	27
      1  24e5		       1b		      .byte.b	27
      0  24e6					      dw	0
      1  24e6		       00 00		      .word.w	0
      0  24e8					      CALLFUNC
      0  24e8					      db	53
      1  24e8		       35		      .byte.b	53
      0  24e9					      RTN
      0  24e9					      db	25
      1  24e9		       19		      .byte.b	25
    874  24ea							;===========================================================================
    875  24ea							; Same as gosub but expects a return value
    876  24ea							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    877  24ea							;
      0  24ea				   F2FUNC     TSTB	F2C,kGofn
      0  24ea					      db	101
      1  24ea		       65		      .byte.b	101
      0  24eb					      db	(F2C-*)-1
      1  24eb		       19		      .byte.b	(F2C-*)-1
      0  24ec					      db	kGofn
      1  24ec		       31		      .byte.b	kGofn
    879  24ed				   ekGofn
      0  24ed					      Call	GOSUBSTATEMENT
      0  24ed					      db	28
      1  24ed		       1c		      .byte.b	28
      0  24ee					      dw	GOSUBSTATEMENT
      1  24ee		       19 25		      .word.w	GOSUBSTATEMENT
      0  24f0					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  24f0					      db	8
      1  24f0		       08		      .byte.b	8
      0  24f1					      db	GOSUB_RTN_VALUE
      1  24f1		       81		      .byte.b	GOSUB_RTN_VALUE
      0  24f2					      XFER
      0  24f2					      db	7
      1  24f2		       07		      .byte.b	7
    883  24f3
    884  24f3				   GOFNRet
      0  24f3					      RTN
      0  24f3					      db	25
      1  24f3		       19		      .byte.b	25
    886  24f4
    887  24f4							;=================================================================================
    888  24f4							;Check for a number !
    889  24f4							;
    890  24f4				   F0
    891  24f4				   FactNumber
      0  24f4					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  24f4					      db	35
      1  24f4		       23		      .byte.b	35
      0  24f5					      db	(FactVariable-*)-1
      1  24f5		       0f		      .byte.b	(FactVariable-*)-1
      0  24f6					      RTN
      0  24f6					      db	25
      1  24f6		       19		      .byte.b	25
    894  24f7				   F1
      0  24f7					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  24f7					      db	101
      1  24f7		       65		      .byte.b	101
      0  24f8					      db	(F2RTN-*)-1
      1  24f8		       08		      .byte.b	(F2RTN-*)-1
      0  24f9					      db	oLeftBracket
      1  24f9		       e0		      .byte.b	oLeftBracket
      0  24fa					      CALL	EXPR
      0  24fa					      db	28
      1  24fa		       1c		      .byte.b	28
      0  24fb					      dw	EXPR
      1  24fb		       8e 23		      .word.w	EXPR
      0  24fd					      TST	F2,oRightBracket
      0  24fd					      db	32
      1  24fd		       20		      .byte.b	32
      0  24fe					      db	(F2-*)-1
      1  24fe		       03		      .byte.b	(F2-*)-1
      0  24ff					      db	oRightBracket,0
      1  24ff		       e1 00		      .byte.b	oRightBracket,0
    898  2501				   F2RTN
      0  2501					      RTN
      0  2501					      db	25
      1  2501		       19		      .byte.b	25
    900  2502
    901  2502				   F2
      0  2502					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  2502					      db	13
      1  2502		       0d		      .byte.b	13
      0  2503					      dw	ERR_SYNTAX
      1  2503		       05 00		      .word.w	ERR_SYNTAX
    903  2505							;
    904  2505							;=============================================================================
    905  2505							; See if this is just a simple variable
    906  2505							;  Allow a subscript for any variable
    907  2505							;
    908  2505				   F2C
    909  2505
    910  2505				   FactVariable
      0  2505					      TSTV	F1
      0  2505					      db	33
      1  2505		       21		      .byte.b	33
      0  2506					      db	(F1-*)-1
      1  2506		       f0		      .byte.b	(F1-*)-1
      0  2507					      TSTB	F2CLocalTask,oBang
      0  2507					      db	101
      1  2507		       65		      .byte.b	101
      0  2508					      db	(F2CLocalTask-*)-1
      1  2508		       04		      .byte.b	(F2CLocalTask-*)-1
      0  2509					      db	oBang
      1  2509		       e8		      .byte.b	oBang
      0  250a					      IND		; we just got a pid
      0  250a					      db	20
      1  250a		       14		      .byte.b	20
      0  250b					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  250b					      db	93
      1  250b		       5d		      .byte.b	93
      0  250c					      db	(UNKNOWNID-*)-1
      1  250c		       87		      .byte.b	(UNKNOWNID-*)-1
    915  250d
    916  250d				   F2CLocalTask
      0  250d					      TSTB	F2C1,oLeftSQBracket
      0  250d					      db	101
      1  250d		       65		      .byte.b	101
      0  250e					      db	(F2C1-*)-1
      1  250e		       08		      .byte.b	(F2C1-*)-1
      0  250f					      db	oLeftSQBracket
      1  250f		       e4		      .byte.b	oLeftSQBracket
      0  2510					      CALL	EXPR
      0  2510					      db	28
      1  2510		       1c		      .byte.b	28
      0  2511					      dw	EXPR
      1  2511		       8e 23		      .word.w	EXPR
      0  2513					      TSTB	UNKNOWNID,oRightSQBracket
      0  2513					      db	101
      1  2513		       65		      .byte.b	101
      0  2514					      db	(UNKNOWNID-*)-1
      1  2514		       7f		      .byte.b	(UNKNOWNID-*)-1
      0  2515					      db	oRightSQBracket
      1  2515		       e5		      .byte.b	oRightSQBracket
      0  2516					      SUBSCRIPT
      0  2516					      db	64
      1  2516		       40		      .byte.b	64
    921  2517				   F2C1
      0  2517					      IND		; YES, GET THE VALUE.
      0  2517					      db	20
      1  2517		       14		      .byte.b	20
      0  2518					      RTN
      0  2518					      db	25
      1  2518		       19		      .byte.b	25
    924  2519
    925  2519							;=============================================================
    926  2519							; Gosub can be both a Function and a Subroutine
    927  2519				   GOSUBSTATEMENT
      0  2519					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  2519					      db	106
      1  2519		       6a		      .byte.b	106
      0  251a					      db	(GOSUBCOMPILED-*)-1
      1  251a		       03		      .byte.b	(GOSUBCOMPILED-*)-1
      0  251b					      CALL	EXPR	; GET DESTINATION
      0  251b					      db	28
      1  251b		       1c		      .byte.b	28
      0  251c					      dw	EXPR
      1  251c		       8e 23		      .word.w	EXPR
    930  251e				   GOSUBCOMPILED
      0  251e					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  251e					      db	101
      1  251e		       65		      .byte.b	101
      0  251f					      db	(GOSUBDONE-*)-1
      1  251f		       11		      .byte.b	(GOSUBDONE-*)-1
      0  2520					      db	oLeftBracket
      1  2520		       e0		      .byte.b	oLeftBracket
      0  2521					      STK2TMP		;Transfer stack top to temp
      0  2521					      db	95
      1  2521		       5f		      .byte.b	95
      0  2522					      PUSHMATHSTACK		;Record stack frame for return
      0  2522					      db	84
      1  2522		       54		      .byte.b	84
    934  2523				   GOSUBLOOP
      0  2523					      CALL	EXPR	; Allows what ever fits onto stack
      0  2523					      db	28
      1  2523		       1c		      .byte.b	28
      0  2524					      dw	EXPR
      1  2524		       8e 23		      .word.w	EXPR
      0  2526					      INCPARMCOUNT
      0  2526					      db	88
      1  2526		       58		      .byte.b	88
      0  2527					      TSTB	GOSUBParmDONE,oComma
      0  2527					      db	101
      1  2527		       65		      .byte.b	101
      0  2528					      db	(GOSUBParmDONE-*)-1
      1  2528		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  2529					      db	oComma
      1  2529		       e2		      .byte.b	oComma
      0  252a					      IJMP	GOSUBLOOP
      0  252a					      db	29
      1  252a		       1d		      .byte.b	29
      0  252b					      dw	GOSUBLOOP
      1  252b		       23 25		      .word.w	GOSUBLOOP
    939  252d				   GOSUBParmDONE
      0  252d					      TSTB	F2,oRightBracket
      0  252d					      db	101
      1  252d		       65		      .byte.b	101
      0  252e					      db	(F2-*)-1
      1  252e		       d3		      .byte.b	(F2-*)-1
      0  252f					      db	oRightBracket
      1  252f		       e1		      .byte.b	oRightBracket
      0  2530					      TMP2STK		; Restore line to goto
      0  2530					      db	96
      1  2530		       60		      .byte.b	96
    942  2531				   GOSUBDONE
      0  2531					      RTN
      0  2531					      db	25
      1  2531		       19		      .byte.b	25
    944  2532
    945  2532		       25 32	   ILEND      equ	*
------- FILE mytb.asm
   2355  2532		       25 32	   PROGEND    equ	*
   2356  2532
   2357  2532
   2358  2532							;=====================================================
   2359  2532							; Define start of non page zero data
   2360 U2574					      seg.u	TBData
   2361 U2574
   2362 U2574							;=====================================================
   2363 U2574							; These are storage items not in page zero.
   2364 U2574							;
   2365 U2574							; IRQ BASIC Code Service RTN Support
      0 U2574				   SaveIrqReg db	0	; Store current setting
      1 U2574		       00		      .byte.b	0
      0 U2575				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U2575		       00		      .byte.b	0
      0 U2576				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U2576		       00		      .byte.b	0
      0 U2577				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U2577		       00 00		      .byte.b	0,0
   2370 U2579
   2371 U2579							;
   2372 U2579							;==================================================================================================
   2373 U2579							; Task Management information
   2374 U2579							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2375 U2579							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2376 U2579							; Task switchs happen at the beginning of the next Basic command line
   2377 U2579							; It will not happen during an input or output operations
   2378 U2579							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2379 U2579							; Task Zero is always the root task, main line program
   2380 U2579							;
   2381 U2579							; Layout is repeated for each configured task
   2382 U2579							; Task Table Byte   use masks follow
   2383 U2579		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2384 U2579		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2385 U2579		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2386 U2579		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2387 U2579		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2388 U2579
   2389 U2579		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2390 U257a		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2391 U257a		       26 74	   TASKTABLEEND equ	*	; End of task table
   2392 U257a		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2393 U2674
   2394 U2674							;Task Cycle Counter and reset count
   2395 U2674		       00 00	   taskCurrentCycles ds	2
   2396 U2676		       00 00	   taskResetValue ds	2
   2397 U2678		       00	   taskCounter ds	1	; Count of active tasks
   2398 U2679
   2399 U2679							;
   2400 U2679							; Math stack and IL call and Gosub/For-next return stack definitions
   2401 U2679							;
   2402 U2679		       26 79	   STACKSTART equ	*
   2403 U2679		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	; Stack used for math expressions
   2404 U2809		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	; stack used by the IL for calls and returns
   2405 U2999		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	; stack size for gosub stacks
   2406 U2c19		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	; Stack of variables, 26 A-Z-task exit code
   2407 U2c19		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2408 U2c19		       2e 35	   STACKEND   equ	*
   2409 U2c19		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2410 U2e35							;
   2411 U2e35							;
   2412 U2e35		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2413 U2eb9		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2414 U2eba		       00	   printtx    ds	1	;temp X for print funcs
   2415 U2ebb		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2416 U2ebc		       00	   promptChar ds	1	;the character to use for a prompt
   2417 U2ebd		       00	   diddigit   ds	1	;for leading zero suppression
   2418 U2ebe		       00	   putsy      ds	1
   2419 U2ebf		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2420 U2ec1		       00	   sign       ds	1	;0 = positive, else negative
   2421 U2ec2		       00 00	   rtemp1     ds	2	;Temp for x and y
   2422 U2ec4		       00 00	   random     ds	2
   2423 U2ec6		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2424 U2ec8		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2425 U2eca		       00	   tempy      ds	1	;temp y storage
   2426 U2ecb
   2427 U2ecb							; Moved from page zero as one clock cycle diff gives more space on page zero
   2428 U2ecb		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2429 U2ecd		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2430 U2ece		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2431 U2ecf		       00	   lineLength ds	1	;Length of current line
   2432 U2ed0
   2433 U2ed0		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2434 U2ed1		       00	   taskRDPending ds	1	; 1 = background read is pending
   2435 U2ed2
   2436 U2ed2				  -	      if	XKIM
   2437 U2ed2				  -buffer     ds	BUFFER_SIZE
   2438 U2ed2					      endif
   2439 U2ed2							;
   2440 U2ed2							; PROGRAMEND is the end of the user's BASIC program.
   2441 U2ed2							; More precisely, it is one byte past the end.  Or,
   2442 U2ed2							; it's where the next line added to the end will be
   2443 U2ed2							; placed.
   2444 U2ed2							;
   2445 U2ed2		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2446 U2ed4		       00 00	   ProgramEnd ds	2	; End of users basic program
   2447 U2ed6		       00 00	   HighMem    ds	2	; highest location
   2448 U2ed8		       00 00	   UsedMem    ds	2	; size of user program
   2449 U2eda		       00 00	   FreeMem    ds	2	; amount of free memory
   2450 U2edc							;
   2451 U2edc							;=====================================================
   2452 U2edc							; This is the start of the user's BASIC program space.
   2453 U2edc							;
   2454 U2edc							; PERSONAL GOAL: This should be no larger than $0DFF.
   2455 U2edc							;		  0200-05FF = 1K
   2456 U2edc							;		  0200-09FF = 2K
   2457 U2edc							;		  0200-0DFF = 3K
   2458 U2edc							;		  0200-11FF = 4K
   2459 U2edc							;		  0200-13FF = 4.5K
   2460 U2edc							;
   2461 U2edc				  -	      if	FIXED
   2462 U2edc				  -	      org	$2000
   2463 U2edc					      endif
   2464 U2edc
   2465 U2edc		       2e dc	   FreeMemStart equ	*
   2466 U2edc							;/*
   2467 U2edc							;	if	CTMON65 || XKIM
   2468 U2edc							;		SEG Code
   2469 U2edc							;		org	AutoRun
   2470 U2edc							;		dw	TBasicCold
   2471 U2edc							;	endif
   2472 U2edc							;*/
   2473 U2edc					      end
