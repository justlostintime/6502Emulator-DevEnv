------- FILE mytb.asm LEVEL 1 PASS 6
      1 U260e				   input      processor	6502
      2 U260e ????						;=====================================================
      3 U260e ????						; Concurrent Tiny Basic, no longer Tiny
      4 U260e ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U260e ????						; Free Time. Now abiut 6K Full OS features.
      6 U260e ????						;
      7 U260e ????						; While working on the Corsham Technologies KIM Clone
      8 U260e ????						; project, I wanted to include a TINY BASIC since that
      9 U260e ????						; was a highly desirable feature of early computers.
     10 U260e ????						;
     11 U260e ????						; Rather than negotiating copyright issues for
     12 U260e ????						; existing BASICs, I decided to just write one from
     13 U260e ????						; scratch.
     14 U260e ????						;
     15 U260e ????						; 10/07/2017
     16 U260e ????						;
     17 U260e ????						; This implements a stripped down Tiny BASIC
     18 U260e ????						; interpreter using the Interpretive Language (IL)
     19 U260e ????						; method as described in the first few issues of
     20 U260e ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U260e ????						; to write various languages simply by changing the
     22 U260e ????						; IL code rather than the interpreter itself.
     23 U260e ????						;
     24 U260e ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U260e ????						;		* Fixed major bug in findLine that
     26 U260e ????						;		  caused corrupted lines, crashes, etc.
     27 U260e ????						;		* If no parameter given to RND, assume
     28 U260e ????						;		  32766.
     29 U260e ????						;		* No more error 5 when a program
     30 U260e ????						;		  reaches the end without an END.
     31 U260e ????						;
     32 U260e ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U260e ????						;		 * Unexpanded version to play with everything
     34 U260e ????						;		 * Add some usefull system level functions
     35 U260e ????						;		 * allow a larger number of tiny basic formats
     36 U260e ????						;		 * Add byte at start of line holding length
     37 U260e ????						;		   for faster execution of goto and gosub
     38 U260e ????						;		 * Re-added gosub
     39 U260e ????						;		 * allow ; or , at end if print stmt
     40 U260e ????						;		   without CRLF being added.
     41 U260e ????						;		 * Added extended function erase to
     42 U260e ????						;		   use the extended ctmon65 rm file
     43 U260e ????						;		 * Fix quoted text to not have to backtrack
     44 U260e ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U260e ????						;		 * Add concurrency features
     46 U260e ????						;
     47 U260e ????						; www.corshamtech.com
     48 U260e ????						; bob@corshamtech.com
     49 U260e ????						; JustLostInTime@gmail.com
     50 U260e ????						;
     51 U260e ????						;=====================================================
     52 U260e ????						;
     53 U260e ????						; Create TRUE and FALSE values for conditionals.
     54 U260e ????						;
     55 U260e ????
     56 U260e ????	       00 00	   FALSE      equ	0
     57 U260e ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U260e ????						;
     59 U260e ????						;---------------------------------------------------------
     60 U260e ????						; One of these must be set to indicate which environment
     61 U260e ????						; Tiny BASIC will be running in.  Here are the current
     62 U260e ????						; environments:
     63 U260e ????						;
     64 U260e ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U260e ????						; more K of RAM.
     66 U260e ????						;
     67 U260e ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U260e ????						; which enhances, without replacing, the standard KIM
     69 U260e ????						; monitor.  It gives access to routines to save/load files
     70 U260e ????						; to a micro SD card.
     71 U260e ????						;
     72 U260e ????						; CTMON65 is a from-scratch monitor written for the
     73 U260e ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U260e ????						; easily be ported to other systems.  It has support for
     75 U260e ????						; using a micro SD card for file storage/retrieval.
     76 U260e ????						;
     77 U260e ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U260e ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U260e ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U260e ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U260e ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U260e ????						;
     83 U260e ????						;   Need to define some macros for the dasm assembler
     84 U260e ????						;
     85 U260e ????				      MACRO	dw
     86 U260e ????				      .word	{0}
     87 U260e ????				      ENDM
     88 U260e ????
     89 U260e ????				      MACRO	db
     90 U260e ????				      .byte	{0}
     91 U260e ????				      ENDM
     92 U260e ????
     93 U260e ????						;
     94 U260e ????						; If set, include disk functions.
     95 U260e ????						;
     96 U260e ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U260e ????						;
     98 U260e ????						; If ILTRACE is set then dump out the address of every
     99 U260e ????						; IL opcode before executing it.
    100 U260e ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U260e ????						;
    102 U260e ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U260e ????						;
    104 U260e ????						; If FIXED is set, put the IL code and the user
    105 U260e ????						; program space at fixed locations in memory.	This is
    106 U260e ????						; meant only for debugging.
    107 U260e ????						;
    108 U260e ????	       00 00	   FIXED      equ	FALSE
    109 U260e ????						;
    110 U260e ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U260e ????						; BASIC, so keep this small!
    112 U260e ????						;
    113 U260e ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U260e ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U260e ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U260e ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U260e ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U260e ????	       00 c8	   TASKCYCLESDEFAULT equ	200	;Default Task Switch 0-255 uses a single byte
    119 U260e ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    120 U260e ????						;
    121 U260e ????						; Gosub entry types
    122 U260e ????
    123 U260e ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    124 U260e ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    125 U260e ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    126 U260e ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    127 U260e ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    128 U260e ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    129 U260e ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    130 U260e ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    131 U260e ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    132 U260e ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    133 U260e ????						;
    134 U260e ????						; Common ASCII constants
    135 U260e ????						;
    136 U260e ????	       00 07	   BEL	      equ	$07
    137 U260e ????	       00 08	   BS	      equ	$08
    138 U260e ????	       00 09	   TAB	      equ	$09
    139 U260e ????	       00 0a	   LF	      equ	$0A
    140 U260e ????	       00 0d	   CR	      equ	$0D
    141 U260e ????	       00 22	   quote      equ	$22
    142 U260e ????	       00 20	   SPACE      equ	$20
    143 U260e ????	       00 2c	   COMMA      equ	',
    144 U260e ????	       00 3b	   SEMICOLON  equ	';
    145 U260e ????	       00 3a	   COLON      equ	':
    146 U260e ????	       00 24	   DOLLAR     equ	'$
    147 U260e ????						;
    148 U260e ????						; These are error codes
    149 U260e ????						;
    150 U260e ????	       00 00	   ERR_NONE   equ	0	;No Errror
    151 U260e ????	       00 01	   ERR_EXPR   equ	1	;expression error
    152 U260e ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    153 U260e ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    154 U260e ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    155 U260e ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    156 U260e ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    157 U260e ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    158 U260e ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    159 U260e ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    160 U260e ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    161 U260e ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    162 U260e ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    163 U260e ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    164 U260e ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    165 U260e ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    166 U260e ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    167 U260e ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    168 U260e ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack fram was expected not found
    169 U260e ????						;
    170 U260e ????						;=====================================================
    171 U260e ????						; Zero page storage.
    172 U260e ????						;
    173 U00f6 ????				      SEG.U	ZEROPAGE
    174 U0040					      org	$0040
    175 U0040
    176 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    177 U0041
    178 U0041							; The context is used to locate a task switch
    179 U0041							; it copies from here till all task fields are saved/swapped
    180 U0041							; The max number of tasks is 256 / context length
    181 U0041							; All positions POS values are plus one task table incldues
    182 U0041							; a leading status byte .
    183 U0041							;
    184 U0041		       00 41	   CONTEXT    equ	*
    185 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    186 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    187 U0043		       00 00	   ILPC       ds	2	; IL program counter
    188 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    189 U0047		       00	   ILSTACKPTR ds	1
    190 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    191 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    192 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    193 U004a		       00	   MATHSTACKPTR ds	1
    194 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    195 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    196 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    197 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    198 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    199 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    200 U004f							;
    201 U004f							; CURPTR is a pointer to curent BASIC line being
    202 U004f							; executed.  Always points to start of line, CUROFF
    203 U004f							; is the offset to the current character.
    204 U004f							; The order of these fields is important
    205 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    206 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    207 U0052							;
    208 U0052							;The order of these fields in important
    209 U0052
    210 U0052							;
    211 U0052							; R0, R1 and MQ are used for arithmetic operations and
    212 U0052							; general use.
    213 U0052							;
    214 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    215 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    216 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    217 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    218 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    219 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    220 U0056		       00 00	   MQ	      ds	2	;used for some math
    221 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    222 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    223 U0058		       00 59	   REGISTERSEND equ	*
    224 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    225 U0059
    226 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    227 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    228 U0059
    229 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    230 U005b		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    231 U005d		       00	   tempIlY    ds	1	;Temp IL Y register storage
    232 U005e		       00	   offset     ds	1	;IL Offset to next inst when test fails
    233 U005f		       00	   lineLength ds	1	;Length of current line
    234 U0060
    235 U0060		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
    236 U0061		       00	   taskRDPending ds	1	; 1 = background read is pending
    237 U0062
    238 U0062							;
    239 U0062							; This is zero if in immediate mode, or non-zero
    240 U0062							; if currently running a program.  Any input from
    241 U0062							; the main loop clears this, and the XFER IL
    242 U0062							; statement will set it.
    243 U0062							;
    244 U0062		       00	   RunMode    ds	1	;Basic program is running or stop
    245 U0063							;
    246 U0063							; Used for line insertion/removal.
    247 U0063							;
    248 U0063		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    249 U0065
    250 U0065							; THE ADDRESS USED BY THE PRINTER FUNCTION
    251 U0065							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    252 U0065							;
    253 U0065		       00 00	   PrtFrom    ds	2	; FROM
    254 U0067							;
    255 U0067
    256 U0067							;
    257 U0067							;=====================================================
    258 U0067							;
    259  1ca1 ????				      SEG	Code
    260  0200					      org	$0200
    261  0200							;
    262  0200							; Cold start is at $0200.  Warm start is at $0203.
    263  0200							;
    264  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    265  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    266  0206							;
    267  0206							; These are the user-supplied vectors to I/O routines.
    268  0206							; If you want, you can just patch these in the binary
    269  0206							; file, but it would be better to change the source
    270  0206							; code.
    271  0206							;
    272  0206				  -	      if	KIM
    273  0206				  -OUTCH      jmp	$1ea0	;output char in A
    274  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    275  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    276  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    277  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    278  0206					      endif
    279  0206				  -	      if	XKIM
    280  0206				  -	      include	"xkim.inc"
    281  0206				  -	      SEG	Code
    282  0206				  -OUTCH      jmp	$1ea0
    283  0206				  -GETCH      jmp	xkGETCH
    284  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    285  0206				  -OUTHEX     jmp	xkPRTBYT
    286  0206				  -MONITOR    jmp	extKIM
    287  0206				  -puts       equ	putsil
    288  0206				  -BUFFER_SIZE equ	132
    289  0206					      endif
    290  0206
    291  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0067					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    293 Udf8e
    294  0206					      SEG	Code
    295  0206							;
    296  0206		       f0 0c	   OUTCH      equ	cout
    297  0206		       f0 09	   GETCH      equ	cin
    298  0206		       14 6f	   CRLF       equ	tbcrlf
    299  0206		       16 4a	   OUTHEX     equ	HexToOut
    300  0206		       f0 03	   MONITOR    equ	WARM
    301  0206		       f0 0f	   ISCHAR     equ	cstatus
    302  0206		       15 f1	   puts       equ	tbputs
    303  0206					      endif
    304  0206							;
    305  0206		       20 d1 15    cold2      jsr	SetOutConsole
    306  0209		       20 de 15 	      jsr	SetInConsole
    307  020c		       20 f1 15 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    311  023c							;
    312  023c		       20 9e 15 	      jsr	GetSizes	;setup the free space available
    313  023f
    314  023f		       a9 01	   calcstack  lda	#1
    315  0241		       8d b3 1d 	      sta	taskCounter	; Initialize number of tasks to 1
    316  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    317  0246		       8d b7 1c 	      sta	taskTable	; mark the main task as active
    318  0249		       20 3b 0d 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    319  024c		       a9 18		      lda	#IL&$ff
    320  024e		       85 43		      sta	ILPC
    321  0250		       a9 18		      lda	#IL>>8
    322  0252		       85 44		      sta	ILPC+1
    323  0254							;
    324  0254		       a9 0e		      lda	#ProgramStart&$ff	; user prog
    325  0256		       8d 06 26 	      sta	PROGRAMEND
    326  0259		       a9 26		      lda	#ProgramStart>>8
    327  025b		       8d 07 26 	      sta	PROGRAMEND+1
    328  025e							;
    329  025e							; Initialize the pseudo-random number sequence...
    330  025e							;
    331  025e		       a9 5a		      lda	#$5a
    332  0260		       8d fd 25 	      sta	rtemp1
    333  0263		       a9 9d		      lda	#%10011101
    334  0265		       8d ff 25 	      sta	random
    335  0268		       a9 5b		      lda	#%01011011
    336  026a		       8d 00 26 	      sta	random+1
    337  026d							;
    338  026d							;   Insert a Basic irq handler for the basic Language
    339  026d		       a9 7a		      lda	#ServiceIrq&$ff
    340  026f		       8d 00 df 	      sta	IRQvec
    341  0272		       a9 02		      lda	#ServiceIrq>>8
    342  0274		       8d 01 df 	      sta	IRQvec+1
    343  0277		       4c 9f 02 	      jmp	coldtwo
    344  027a
    345  027a							;
    346  027a							; This is the Basic IRQ handler
    347  027a		       48	   ServiceIrq pha
    348  027b		       ad b2 1c 	      lda	IRQStatus
    349  027e		       f0 0a		      BEQ	RetIrq
    350  0280		       ad b3 1c 	      lda	IRQPending
    351  0283		       d0 05		      bne	RetIrq
    352  0285		       a9 01		      lda	#1
    353  0287		       8d b3 1c 	      sta	IRQPending
    354  028a		       68	   RetIrq     pla
    355  028b		       40		      rti
    356  028c							;
    357  028c							;
    358  028c							; This is the warm start entry point
    359  028c							;
    360  028c		       20 d1 15    warm2      jsr	SetOutConsole
    361  028f		       20 de 15 	      jsr	SetInConsole
    362  0292		       20 6f 14 	      jsr	CRLF
    363  0295		       ad fa 25 	      lda	errGoto
    364  0298		       85 43		      sta	ILPC
    365  029a		       ad fb 25 	      lda	errGoto+1
    366  029d		       85 44		      sta	ILPC+1
    367  029f							;
    368  029f							; And continue with both starts here
    369  029f							;
    370  029f				   coldtwo
    371  029f							;
    372  029f							; The ILTrace flag is now run-time settable.
    373  029f							;
    374  029f		       a9 00		      lda	#ILTRACE&$ff
    375  02a1		       85 40		      sta	ILTrace
    376  02a3							;
    377  02a3
    378  02a3		       a9 00		      lda	#0
    379  02a5		       85 62		      sta	RunMode
    380  02a7		       8d 70 25 	      sta	LINBUF
    381  02aa
    382  02aa							; Clear everything from the stacks
    383  02aa
    384  02aa		       85 60		      sta	taskIOPending	; No one waiting for io
    385  02ac		       85 61		      sta	taskRDPending	; No one waiting for bg io
    386  02ae
    387  02ae		       20 ae 0d 	      jsr	taskReset
    388  02b1							;
    389  02b1		       a9 70		      lda	#LINBUF&$ff
    390  02b3		       85 4f		      sta	CURPTR
    391  02b5		       a9 25		      lda	#LINBUF>>8
    392  02b7		       85 50		      sta	CURPTR+1	;fall through...
    393  02b9
    394  02b9							;=====================================================
    395  02b9							; This is the top of the IL interpreter.  This fetches
    396  02b9							; and executes the instruction currently pointed to
    397  02b9							; by ILPC and adjusts ILPC to point to the next
    398  02b9							; instruction to execute.
    399  02b9							;
    400  02b9		       ce b1 1d    NextIL     dec	taskCurrentCycles
    401  02bc		       d0 03		      bne	NextIlNow
    402  02be		       20 d7 0d 	      jsr	iTaskSwitch	;check for a task switch
    403  02c1		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    404  02c3		       f0 03		      beq	NextIL2	;Skip if no bits set
    405  02c5
    406  02c5		       20 fb 14 	      jsr	dbgLine	;Print the IL trace information
    407  02c8
    408  02c8		       a4 51	   NextIL2    ldy	CUROFF
    409  02ca		       20 66 14 	      jsr	SkipSpaces
    410  02cd		       84 51		      sty	CUROFF
    411  02cf							;Task IO Management
    412  02cf		       a5 61		      lda	taskRDPending	; if it is zero then Nothing pending
    413  02d1		       f0 07		      beq	NextILStr
    414  02d3		       20 bb 12 	      jsr	ReadLine	; else Pending and poll keyboard
    415  02d6		       90 02		      bcc	NextILStr	; if carry is clear then no end of line yet
    416  02d8		       c6 61		      dec	taskRDPending	; Carry is set if CR has been recieved
    417  02da							;
    418  02da		       20 d6 10    NextILStr  jsr	getILByte
    419  02dd							;
    420  02dd							; When the handler is called, these are the conditions
    421  02dd							; of several important items:
    422  02dd							;
    423  02dd							;    (ILPC) will point to the byte AFTER the IL
    424  02dd							;    opcode being executed.
    425  02dd							;
    426  02dd							;    (CURPTR),CUROFF will point to the start of the
    427  02dd							;    next word in the input buffer.  Ie, the next word
    428  02dd							;    in the user program.
    429  02dd							;
    430  02dd		       0a		      asl
    431  02de		       c9 c6		      cmp	#ILTBLend-ILTBL+2
    432  02e0		       90 33		      bcc	ILgood
    433  02e2							;
    434  02e2							; This handles an illegal IL opcode.  This is serious
    435  02e2							; and there's no way to recover.
    436  02e2							;
    437  02e2		       20 f1 15    ILbad      jsr	puts
      0  02e5					      db	CR,LF
      1  02e5		       0d 0a		      .byte.b	CR,LF
      0  02e7					      db	"Illegal IL "
      1  02e7		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f2					      db	0
      1  02f2		       00		      .byte.b	0
    441  02f3							;
    442  02f3							; Well this is awkward, we need to back up the IL
    443  02f3							; by one since it no longer points to the current
    444  02f3							; opcode.
    445  02f3							;
    446  02f3		       20 e3 10 	      jsr	decIL
    447  02f6							;
    448  02f6		       a0 00		      ldy	#0
    449  02f8		       b1 43		      lda	(ILPC),y
    450  02fa		       20 4a 16 	      jsr	OUTHEX
    451  02fd		       20 f1 15 	      jsr	puts
      0  0300					      db	" at ",0
      1  0300		       20 61 74 20*	      .byte.b	" at ",0
    453  0305		       a5 44		      lda	ILPC+1
    454  0307		       20 4a 16 	      jsr	OUTHEX
    455  030a		       a5 43		      lda	ILPC
    456  030c		       20 4a 16 	      jsr	OUTHEX
    457  030f		       20 6f 14 	      jsr	CRLF
    458  0312		       4c 03 f0 	      jmp	MONITOR
    459  0315							;
    460  0315							; Just jump to the address (ILPC),y.  Have to do
    461  0315							; some goofy stuff.
    462  0315							;
    463  0315		       a8	   ILgood     tay		;move index into Y
    464  0316		       b9 23 03 	      lda	ILTBL,y
    465  0319		       85 59		      sta	dpl
    466  031b		       b9 24 03 	      lda	ILTBL+1,y
    467  031e		       85 5a		      sta	dpl+1
    468  0320		       6c 59 00 	      jmp	(dpl)	;go to handler
    469  0323							;
    470  0323							;=====================================================
    471  0323							; This is the IL jump table.  The IL opcode is
    472  0323							; mulitplied by two, then looked-up in this table.
    473  0323							; There is absolutely nothing special about the order
    474  0323							; of entries here... they all decode at exactly the
    475  0323							; same speed.	However the entry number must match the
    476  0323							; values in IL.inc.
    477  0323							;
    478  0323				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0323					      include	"ilvectortable.asm"
      1  0323					      seg	Code
      2  0323
      0  0323					      dw	iXINIT	;0
      1  0323		       19 04		      .word.w	iXINIT
      0  0325					      dw	iDONE	;1
      1  0325		       34 04		      .word.w	iDONE
      0  0327					      dw	iPRS	;2
      1  0327		       50 04		      .word.w	iPRS
      0  0329					      dw	iPRN	;3
      1  0329		       5a 04		      .word.w	iPRN
      0  032b					      dw	iSPC	;4
      1  032b		       63 04		      .word.w	iSPC
      0  032d					      dw	iNLINE	;5
      1  032d		       f7 08		      .word.w	iNLINE
      0  032f					      dw	iNXT	;6
      1  032f		       6b 04		      .word.w	iNXT
      0  0331					      dw	iXFER	;7
      1  0331		       97 04		      .word.w	iXFER
      0  0333					      dw	iSAV	;8
      1  0333		       c4 04		      .word.w	iSAV
      0  0335					      dw	iRSTR	;9
      1  0335		       07 05		      .word.w	iRSTR
      0  0337					      dw	iCMPR	;10
      1  0337		       36 05		      .word.w	iCMPR
      0  0339					      dw	iINNUM	;11
      1  0339		       b7 05		      .word.w	iINNUM
      0  033b					      dw	iFIN	;12
      1  033b		       eb 05		      .word.w	iFIN
      0  033d					      dw	iERR	;13
      1  033d		       ff 05		      .word.w	iERR
      0  033f					      dw	iADD	;14
      1  033f		       6f 06		      .word.w	iADD
      0  0341					      dw	iSUB	;15
      1  0341		       85 06		      .word.w	iSUB
      0  0343					      dw	iNEG	;16
      1  0343		       9b 06		      .word.w	iNEG
      0  0345					      dw	iMUL	;17
      1  0345		       b3 06		      .word.w	iMUL
      0  0347					      dw	iDIV	;18
      1  0347		       f3 06		      .word.w	iDIV
      0  0349					      dw	iSTORE	;19
      1  0349		       49 07		      .word.w	iSTORE
      0  034b					      dw	iIND	;20
      1  034b		       61 07		      .word.w	iIND
      0  034d					      dw	iLST	;21
      1  034d		       cf 07		      .word.w	iLST
      0  034f					      dw	iINIT	;22
      1  034f		       e7 03		      .word.w	iINIT
      0  0351					      dw	iGETLINE	;23
      1  0351		       2e 08		      .word.w	iGETLINE
      0  0353					      dw	iINSRT	;24
      1  0353		       3c 08		      .word.w	iINSRT
      0  0355					      dw	iRTN	;25
      1  0355		       f1 08		      .word.w	iRTN
      0  0357					      dw	MONITOR	;26
      1  0357		       03 f0		      .word.w	MONITOR
      0  0359					      dw	iLIT	;27
      1  0359		       17 09		      .word.w	iLIT
      0  035b					      dw	iCALL	;28
      1  035b		       fd 08		      .word.w	iCALL
      0  035d					      dw	iJMP	;29
      1  035d		       05 09		      .word.w	iJMP
      0  035f					      dw	iVINIT	;30
      1  035f		       34 09		      .word.w	iVINIT
      0  0361					      dw	iERRGOTO	;31
      1  0361		       3a 09		      .word.w	iERRGOTO
      0  0363					      dw	iTST	;32
      1  0363		       46 09		      .word.w	iTST
      0  0365					      dw	iTSTV	;33
      1  0365		       f4 09		      .word.w	iTSTV
      0  0367					      dw	iTSTL	;34
      1  0367		       72 0a		      .word.w	iTSTL
      0  0369					      dw	iTSTN	;35
      1  0369		       8c 0a		      .word.w	iTSTN
      0  036b					      dw	iFREE	;36
      1  036b		       06 0b		      .word.w	iFREE
      0  036d					      dw	iRANDOM	;37
      1  036d		       0f 0b		      .word.w	iRANDOM
      0  036f					      dw	iABS	;38
      1  036f		       e0 0b		      .word.w	iABS
     42  0371							;
     43  0371							; Disk functions.  There must be pointers
     44  0371							; to functions even if no disk is supported.
     45  0371							; Makes things easier in IL.inc.
     46  0371							;
     47  0371					      if	DISK_ACCESS
      0  0371					      dw	iOPENREAD	;39
      1  0371		       f3 16		      .word.w	iOPENREAD
      0  0373					      dw	iOPENWRITE	;40
      1  0373		       47 17		      .word.w	iOPENWRITE
      0  0375					      dw	iDCLOSE	;41
      1  0375		       cb 17		      .word.w	iDCLOSE
      0  0377					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0377		       66 17		      .word.w	iDGETLINE
      0  0379					      dw	iDLIST	;43 Did you remeber your towel?
      1  0379		       c5 17		      .word.w	iDLIST
      0  037b					      dw	iDDIR	;44
      1  037b		       a0 17		      .word.w	iDDIR
      0  037d					      dw	iRMFILE	;45
      1  037d		       21 17		      .word.w	iRMFILE
     55  037f				  -	      else
     56  037f				  -	      dw	NextIL	;39
     57  037f				  -	      dw	NextIL	;40
     58  037f				  -	      dw	NextIL	;41
     59  037f				  -	      dw	NextIL	;42
     60  037f				  -	      dw	NextIL	;43
     61  037f				  -	      dw	NextIL	;44
     62  037f				  -	      dw	NextIL	;45
     63  037f					      endif
     64  037f							;
      0  037f					      dw	iCLEARSCREEN	;46
      1  037f		       67 16		      .word.w	iCLEARSCREEN
      0  0381					      dw	iPOKEMEMORY	;47
      1  0381		       6d 0b		      .word.w	iPOKEMEMORY
      0  0383					      dw	iPEEKMEMORY	;48
      1  0383		       82 0b		      .word.w	iPEEKMEMORY
      0  0385					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0385		       8b 09		      .word.w	iTSTLET
      0  0387					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0387		       c7 09		      .word.w	iTSTDONE
      0  0389					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0389		       af 0b		      .word.w	iGETCHAR
      0  038b					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038b		       c3 0b		      .word.w	iPUTCHAR
      0  038d					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038d		       98 0b		      .word.w	iCallFunc
      0  038f					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038f		       87 05		      .word.w	iBranch
      0  0391					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0391		       6f 09		      .word.w	iTSTStr
      0  0393					      dw	iSetIrq	;56	   sets the irq handler
      1  0393		       5d 0c		      .word.w	iSetIrq
      0  0395					      dw	iTstIrq	;57	   test if irq is pending
      1  0395		       cf 0a		      .word.w	iTstIrq
      0  0397					      dw	iRET	;58	   return from interupt
      1  0397		       f5 04		      .word.w	iRET
      0  0399					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0399		       ce 05		      .word.w	iINSTR
      0  039b					      dw	iMOD	;60	   returns remainder of division
      1  039b		       fc 06		      .word.w	iMOD
      0  039d					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039d		       1f 0e		      .word.w	iTaskSet
      0  039f					      dw	iETask	;62	   Terminates a task
      1  039f		       40 0f		      .word.w	iETask
      0  03a1					      dw	iNTask	;63	   goto next task
      1  03a1		       fd 0e		      .word.w	iNTask
      0  03a3					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a3		       76 07		      .word.w	iArray
      0  03a5					      dw	iTaskKill	;65	   kill a running task
      1  03a5		       f5 0e		      .word.w	iTaskKill
      0  03a7					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a7		       c9 0e		      .word.w	iTaskStat
      0  03a9					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a9		       ce 0b		      .word.w	iHexOut
      0  03ab					      dw	iReadComplete	;68	   Called after a background read completes
      1  03ab		       a3 05		      .word.w	iReadComplete
      0  03ad					      dw	iReadStart	;69	   Called to start a background read request
      1  03ad		       99 05		      .word.w	iReadStart
      0  03af					      dw	iStartIO	;70	   Lock task until io complete
      1  03af		       26 0f		      .word.w	iStartIO
      0  03b1					      dw	iEndIO	;71	   release task lock for io
      1  03b1		       2b 0f		      .word.w	iEndIO
      0  03b3					      dw	iLogNot	;72	   Logical not
      1  03b3		       39 0c		      .word.w	iLogNot
      0  03b5					      dw	iLogOr	;73	   Logical Or
      1  03b5		       0f 0c		      .word.w	iLogOr
      0  03b7					      dw	iLogAnd	;74	   Logical And
      1  03b7		       fa 0b		      .word.w	iLogAnd
      0  03b9					      dw	iLogXor	;75	   Logical Xor
      1  03b9		       24 0c		      .word.w	iLogXor
      0  03bb					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bb		       05 0f		      .word.w	iWTASK
      0  03bd					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03bd		       34 0f		      .word.w	iTASKPID
      0  03bf					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bf		       99 0c		      .word.w	iTRACEPROG
      0  03c1					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c1		       7c 14		      .word.w	idbgBasic
      0  03c3					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c3		       d6 0f		      .word.w	iIPCS
      0  03c5					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c5		       ed 0f		      .word.w	iIPCR
      0  03c7					      dw	iIPCC	;82	   Check if any message available for task
      1  03c7		       01 10		      .word.w	iIPCC
      0  03c9					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c9		       0e 10		      .word.w	iIPCIO
      0  03cb					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cb		       a3 0c		      .word.w	iPushMathStack
      0  03cd					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03cd		       d3 0c		      .word.w	iPopMathStack
      0  03cf					      dw	iSaveMathStack	;86	   Save all math info
      1  03cf		       f0 0c		      .word.w	iSaveMathStack
      0  03d1					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d1		       0f 0d		      .word.w	iRestoreMathStack
      0  03d3					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d3		       c0 0c		      .word.w	iIncParmCount
      0  03d5					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d5		       5d 0f		      .word.w	iTaskGetMathStack
      0  03d7					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d7		       97 0e		      .word.w	iTaskEnable
      0  03d9					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d9		       b1 0e		      .word.w	iTaskSuspend
      0  03db					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03db		       77 0f		      .word.w	iTaskPutMathPtr
      0  03dd					      dw	iTSTVT	;93	   test for another tasks variable
      1  03dd		       eb 09		      .word.w	iTSTVT
      0  03df					      dw	iSetR2	;94
      1  03df		       0f 09		      .word.w	iSetR2
      0  03e1					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e1		       d3 04		      .word.w	iStk2Tmp
      0  03e3					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e3		       e4 04		      .word.w	iTmp2Stk
      0  03e5					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e5		       a9 09		      .word.w	iTSTBYTE
    117  03e7
------- FILE mytb.asm
    480  03e7		       03 e7	   ILTBLend   equ	*
    481  03e7							;
    482  03e7							;=====================================================
    483  03e7							;=====================================================
    484  03e7							;=====================================================
    485  03e7							; This marks the start of the handlers for IL opcodes.
    486  03e7							;=====================================================
    487  03e7							;=====================================================
    488  03e7							;=====================================================
    489  03e7							;
    490  03e7							;
    491  03e7		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    492  03e9		       85 47		      sta	ILSTACKPTR
    493  03eb		       85 4a		      sta	MATHSTACKPTR
    494  03ed		       85 4d		      sta	GOSUBSTACKPTR
    495  03ef		       a9 40		      lda	#GOSUBSTACKSIZE*4
    496  03f1		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    497  03f3							;
    498  03f3		       a9 0e		      lda	#ProgramStart&$ff	;user prog
    499  03f5		       85 4f		      sta	CURPTR
    500  03f7		       8d b8 1c 	      sta	taskTable+1
    501  03fa		       8d 06 26 	      sta	PROGRAMEND
    502  03fd		       a9 26		      lda	#ProgramStart>>8
    503  03ff		       85 50		      sta	CURPTR+1
    504  0401		       8d b9 1c 	      sta	taskTable+2
    505  0404		       8d 07 26 	      sta	PROGRAMEND+1
    506  0407		       a9 80		      lda	#TASKACTIVE
    507  0409		       8d b7 1c 	      sta	taskTable	;Mark the first slot as active
    508  040c		       a9 01		      lda	#1
    509  040e		       8d b3 1d 	      sta	taskCounter	;there is always one task / Main task
    510  0411		       a9 c8		      lda	#TASKCYCLESDEFAULT
    511  0413		       8d b2 1d 	      sta	taskResetValue
    512  0416		       8d b1 1d 	      sta	taskCurrentCycles	; set up the task switch counts
    513  0419							;
    514  0419							; fall into XINIT...
    515  0419							;
    516  0419							;=====================================================
    517  0419							; This initializes for the start of the next line of
    518  0419							; BASIC text.
    519  0419							;
    520  0419		       78	   iXINIT     sei		;ensure interupts are off
    521  041a		       20 ae 0d 	      jsr	taskReset	;Clear the task table
    522  041d		       8d b3 1c 	      sta	IRQPending	; reset the irq pending
    523  0420		       8d b2 1c 	      sta	IRQStatus	; Make sure irqs are off
    524  0423
    525  0423		       4c b9 02    goodExit   jmp	NextIL
    526  0426							;
    527  0426							;=====================================================
    528  0426							; This check if the escape key has been entered
    529  0426							; then changes out of run mode. z Set if esc found
    530  0426				   BreakSet
    531  0426		       20 0f f0 	      jsr	ISCHAR
    532  0429		       f0 06		      beq	BreakNo
    533  042b		       20 ee 15 	      jsr	VGETCH
    534  042e		       c9 1b		      cmp	#$1B
    535  0430		       60		      rts
    536  0431				   BreakNo
    537  0431		       a9 01		      lda	#1
    538  0433		       60		      rts
    539  0434
    540  0434							;
    541  0434
    542  0434							;=====================================================
    543  0434							; Verify there is nothing else on this input line.
    544  0434							; If there is, generate an error.
    545  0434							;
    546  0434		       a4 51	   iDONE      ldy	CUROFF
    547  0436		       20 66 14 	      jsr	SkipSpaces
    548  0439		       b1 4f		      lda	(CURPTR),y
    549  043b		       f0 10		      beq	doneadv
    550  043d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    551  043f		       d0 05		      bne	idoneErr
    552  0441		       84 51		      sty	CUROFF
    553  0443		       4c b9 02 	      jmp	NextIL	; continue on this line
    554  0446
    555  0446				   idoneErr
    556  0446		       a2 04		      ldx	#ERR_EXTRA_STUFF
    557  0448		       a9 00		      lda	#0
    558  044a		       4c 02 06 	      jmp	iErr2
    559  044d							;
    560  044d							; Advance to the next line
    561  044d							;
    562  044d				   doneadv
    563  044d							;		 jsr	 FindNext2
    564  044d		       4c b9 02 	      jmp	NextIL
    565  0450							;
    566  0450							;=====================================================
    567  0450							; Print the string until a closing quote
    568  0450							;
    569  0450		       a4 51	   iPRS       ldy	CUROFF
    570  0452							;
    571  0452							; Odd logic here.  The main loop skipped any leading
    572  0452							; whitespace inside the quoted text, so move back to
    573  0452							; the quote, then move forward again.
    574  0452							;
    575  0452		       20 1b 16 	      jsr	PrtQuoted
    576  0455		       84 51		      sty	CUROFF
    577  0457		       4c b9 02 	      jmp	NextIL
    578  045a							;
    579  045a							;=====================================================
    580  045a							; Pop the top off the stack and print it as a signed
    581  045a							; decimal number.
    582  045a							;
    583  045a		       20 b6 13    iPRN       jsr	popR0
    584  045d		       20 7d 11 	      jsr	PrintDecimal
    585  0460		       4c b9 02 	      jmp	NextIL
    586  0463							;
    587  0463							;=====================================================
    588  0463							; Space to next zone.	Currently the code does not
    589  0463							; keep track of which column the output is on, so
    590  0463							; just print a tab.
    591  0463							;
    592  0463		       a9 09	   iSPC       lda	#TAB
    593  0465		       20 eb 15 	      jsr	VOUTCH
    594  0468		       4c b9 02 	      jmp	NextIL
    595  046b							;
    596  046b							;=====================================================
    597  046b							; If in immediate mode, jump to the address following
    598  046b							; the NXT instruction.  Else move to the next line of
    599  046b							; user code and continue.
    600  046b							;
    601  046b		       a5 62	   iNXT       lda	RunMode
    602  046d		       d0 03		      bne	iNxtRun	;in run mode
    603  046f							;
    604  046f							; Get address and jump to it.
    605  046f							;
    606  046f		       4c 05 09 	      jmp	iJMP
    607  0472							;
    608  0472				   iNxtRun
    609  0472		       a4 51		      ldy	CUROFF
    610  0474		       20 66 14 	      jsr	SkipSpaces
    611  0477		       b1 4f		      lda	(CURPTR),y
    612  0479		       c9 3a		      cmp	#COLON
    613  047b		       d0 09		      bne	iNxtRunGo
    614  047d		       c8		      iny
    615  047e		       20 66 14 	      jsr	SkipSpaces
    616  0481		       84 51		      sty	CUROFF
    617  0483		       4c 91 04 	      jmp	iNxtRun2
    618  0486
    619  0486				   iNxtRunGo
    620  0486		       20 5e 11 	      jsr	FindNextLine
    621  0489		       20 70 11 	      jsr	AtEnd
    622  048c		       d0 03		      bne	iNxtRun2	;not at end
    623  048e							;
    624  048e							; At the end of the program.  Pretend an END statement
    625  048e							; was found.
    626  048e							;
    627  048e		       4c eb 05    iFINv      jmp	iFIN
    628  0491							;
    629  0491		       20 d2 10    iNxtRun2   jsr	getILWord	;ignore next word
    630  0494		       4c b9 02 	      jmp	NextIL
    631  0497							;
    632  0497							;=====================================================
    633  0497							; XFER takes the number on top of the stack and looks
    634  0497							; for that line in the program, or the next line
    635  0497							; higher.  Ie, if it's 1 but there is no line 1, then
    636  0497							; find the next one after that.
    637  0497							;
    638  0497		       20 b6 13    iXFER      jsr	popR0
    639  049a		       20 1b 11 	      jsr	findLine
    640  049d		       20 70 11    iXFER2     jsr	AtEnd	;at end of user program?
    641  04a0		       f0 ec		      beq	iFINv
    642  04a2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    643  04a4		       84 51		      sty	CUROFF
    644  04a6		       a9 ff		      lda	#$ff
    645  04a8		       85 62		      sta	RunMode
    646  04aa							;
    647  04aa							; Transfer IL to STMT.  I don't like having this
    648  04aa							; hard-coded; fix it.
    649  04aa							;
    650  04aa		       a9 26		      lda	#STMT&$ff
    651  04ac		       85 43		      sta	ILPC
    652  04ae		       a9 18		      lda	#STMT>>8
    653  04b0		       85 44		      sta	ILPC+1
    654  04b2		       4c b9 02 	      jmp	NextIL
    655  04b5							;
    656  04b5							; Run
    657  04b5							;
    658  04b5				   iXferok
    659  04b5		       a9 ff		      lda	#$ff
    660  04b7		       85 62		      sta	RunMode	;we're running
    661  04b9							;
    662  04b9							; Need a more elegant way to do this
    663  04b9							;
    664  04b9		       a9 26		      lda	#STMT&$ff
    665  04bb		       85 43		      sta	ILPC
    666  04bd		       a9 18		      lda	#STMT>>8
    667  04bf		       85 44		      sta	ILPC+1
    668  04c1		       4c b9 02 	      jmp	NextIL
    669  04c4							;
    670  04c4							;=====================================================
    671  04c4							; Save the pointer to the next line to the call stack.
    672  04c4							;
    673  04c4		       20 4c 13    iSAV       jsr	pushLN
    674  04c7		       b0 03		      bcs	iSAVErr
    675  04c9		       4c b9 02 	      jmp	NextIL
    676  04cc
    677  04cc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    678  04ce		       a9 00	   iSAVErr2   lda	#0
    679  04d0		       4c 02 06 	      jmp	iErr2
    680  04d3							;====================================================
    681  04d3							; Move stack top to and from temp area
    682  04d3				   iStk2Tmp
    683  04d3		       20 b6 13 	      jsr	popR0
    684  04d6		       a5 52		      lda	R0
    685  04d8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    686  04da		       91 41		      sta	(VARIABLES),y
    687  04dc		       c8		      iny
    688  04dd		       a5 53		      lda	R0+1
    689  04df		       91 41		      sta	(VARIABLES),y
    690  04e1		       4c b9 02 	      jmp	NextIL
    691  04e4
    692  04e4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    693  04e6		       b1 41		      lda	(VARIABLES),y
    694  04e8		       85 52		      sta	R0
    695  04ea		       c8		      iny
    696  04eb		       b1 41		      lda	(VARIABLES),y
    697  04ed		       85 53		      sta	R0+1
    698  04ef		       20 32 13 	      jsr	pushR0
    699  04f2		       4c b9 02 	      jmp	NextIL
    700  04f5							;
    701  04f5							;=====================================================
    702  04f5							; Pop the next line from the call stack.
    703  04f5							;
    704  04f5		       20 71 13    iRET       jsr	popLN
    705  04f8		       b0 d2		      bcs	iSAVErr
    706  04fa		       a0 03		      ldy	#3
    707  04fc		       84 51		      sty	CUROFF
    708  04fe		       a9 00		      lda	#0
    709  0500		       8d b3 1c 	      sta	IRQPending
    710  0503		       58		      cli
    711  0504		       4c b9 02 	      jmp	NextIL
    712  0507							;
    713  0507							;=====================================================
    714  0507							; Return from GOSUB function
    715  0507							;
    716  0507		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    717  0509		       88		      dey
    718  050a		       b1 4b		      lda	(GOSUBSTACK),y
    719  050c		       c9 81		      cmp	#GOSUB_RTN_VALUE
    720  050e		       d0 04		      bne	iRSTRNoValue
    721  0510		       a9 01		      lda	#1
    722  0512		       d0 02		      bne	iRSTRExit
    723  0514				   iRSTRNoValue
    724  0514		       a9 00		      lda	#0
    725  0516				   iRSTRExit
    726  0516		       85 58		      sta	R2
    727  0518		       20 71 13 	      jsr	popLN
    728  051b		       b0 06		      bcs	iRSTRErr
    729  051d		       20 d9 0c 	      jsr	PopMathStackNow
    730  0520		       4c b9 02 	      jmp	NextIL
    731  0523
    732  0523		       ad b6 1c    iRSTRErr   lda	taskPtr	; Check if this is task zero
    733  0526		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    734  0528		       a5 58		      lda	R2
    735  052a		       d0 03		      bne	taskRet
    736  052c		       20 7c 16 	      jsr	pushFalse	; the result code by default is 0
    737  052f				   taskRet
    738  052f		       4c 40 0f 	      jmp	iETask	; not task zero then do a task end instead
    739  0532				   taskZeroEnd
    740  0532		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    741  0534		       d0 98		      bne	iSAVErr2
    742  0536							;
    743  0536							;=====================================================
    744  0536							; Compare items on stack.  Okay, so on input there are
    745  0536							; three things on the stack
    746  0536							;
    747  0536							;    EXPR2 <- Top of stack
    748  0536							;    OP    <- relational operator, next on stack
    749  0536							;    EXPR1 <- last item on stack
    750  0536							;
    751  0536							; Comparison is: EXPR1 <operator> EXPR2
    752  0536							;
    753  0536							; Operator is one of...
    754  0536							;
    755  0536							;    2 is =
    756  0536							;    1 is <
    757  0536							;    3 is <=
    758  0536							;    5 is <>
    759  0536							;    4 is >
    760  0536							;    6 is >=
    761  0536							;
    762  0536							; Those are bit-mapped:
    763  0536							;
    764  0536							;    xxxxxGEL
    765  0536							;
    766  0536							;    G = Greater than
    767  0536							;    E = Equal
    768  0536							;    L = Less than
    769  0536							;
    770  0536							; If the comparison is false, do a NXT, ie, move to the
    771  0536							; next line and continue.  If true, continue executing
    772  0536							; on this line.
    773  0536							;
    774  0536		       00 01	   REL_LT     equ	%001
    775  0536		       00 02	   REL_EQUAL  equ	%010
    776  0536		       00 04	   REL_GT     equ	%100
    777  0536							;
    778  0536		       20 ce 13    iCMPR      jsr	popR1
    779  0539		       20 e5 13 	      jsr	popMQ	;operator in MQ
    780  053c		       20 b6 13 	      jsr	popR0
    781  053f		       20 48 05 	      jsr	iCMPRsub
    782  0542		       20 32 13 	      jsr	pushR0
    783  0545		       4c b9 02 	      jmp	NextIL
    784  0548							;
    785  0548							; See if they are equal or not
    786  0548							;
    787  0548				   iCMPRsub		; Called by internal functions
    788  0548
    789  0548		       a5 52		      lda	R0
    790  054a		       c5 54		      cmp	R1
    791  054c		       d0 0a		      bne	iCMPRnoteq	;try not equal
    792  054e		       a5 53		      lda	R0+1
    793  0550		       c5 55		      cmp	R1+1
    794  0552		       d0 04		      bne	iCMPRnoteq
    795  0554							;
    796  0554							; Equal, set the flag in MQ+1
    797  0554							;
    798  0554		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    799  0556		       d0 14		      bne	iCMPcom	;Exit it is equal
    800  0558							;
    801  0558							; See if EXPR1 (R0) < EXPR2 (R1)
    802  0558							; See www.6502.org/tutorials/compare_beyond.html
    803  0558							;
    804  0558				   iCMPRnoteq
    805  0558		       a5 52		      lda	R0
    806  055a		       c5 54		      cmp	R1
    807  055c		       a5 53		      lda	R0+1
    808  055e		       e5 55		      sbc	R1+1
    809  0560		       50 02		      bvc	iCMPR_2
    810  0562		       49 80		      eor	#$80
    811  0564		       30 04	   iCMPR_2    bmi	iCMPlt
    812  0566		       a9 04		      lda	#REL_GT
    813  0568		       d0 02		      bne	iCMPcom
    814  056a		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    815  056c
    816  056c		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    817  056e							;
    818  056e							; Now compare the end result with what the caller
    819  056e							; was looking for.
    820  056e							;
    821  056e		       25 56		      and	MQ
    822  0570		       f0 0c		      beq	iCMPno	; no match
    823  0572		       a9 ff		      lda	#$FF	; true is $ffff
    824  0574		       85 52		      sta	R0
    825  0576		       85 53		      sta	R0+1
    826  0578		       d0 0c		      bne	iCMPDone
    827  057a							;
    828  057a							; R0 > R1
    829  057a							;
    830  057a		       a9 04	   iCMPgt     lda	#REL_GT
    831  057c		       d0 ee		      bne	iCMPcom
    832  057e				   iCMPno
    833  057e		       a9 00		      lda	#0
    834  0580		       85 52		      sta	R0
    835  0582		       a9 00		      lda	#0
    836  0584		       85 53		      sta	R0+1
    837  0586
    838  0586				   iCMPDone
    839  0586		       60		      rts
    840  0587
    841  0587							;
    842  0587							; if Not a match, so jump to the next line of code.
    843  0587							; Branches based upon value on top of the stack
    844  0587				   iBranch
    845  0587		       20 b6 13 	      jsr	popR0
    846  058a		       a5 52		      lda	R0
    847  058c		       05 53		      ora	R0+1
    848  058e		       f0 03		      beq	iBranchFalse	; not true
    849  0590		       4c b9 02 	      jmp	NextIL	; It is true if any value not zero
    850  0593							;
    851  0593				   iBranchFalse
    852  0593		       20 5e 11 	      jsr	FindNextLine
    853  0596		       4c 9d 04 	      jmp	iXFER2
    854  0599							;
    855  0599							;=====================================================
    856  0599							; Start a read of data in background
    857  0599				   iReadStart
    858  0599		       a9 3f		      lda	#'?	; Prompt with question mark
    859  059b		       a6 01		      ldx	1	; Indicate to start read in background
    860  059d		       20 54 12 	      jsr	GetLine	; Call the getline to start read
    861  05a0		       4c b9 02 	      jmp	NextIL	; next instruction
    862  05a3							;
    863  05a3							;=====================================================
    864  05a3							; Complete the read and return the curptr, curoff pointing to data
    865  05a3				   iReadComplete
    866  05a3		       20 4c 13 	      jsr	pushLN
    867  05a6		       90 03		      bcc	iReadOk
    868  05a8		       4c ff 0a    iReadErr   jmp	ErrStkOver	; Check if there was an error
    869  05ab				   iReadOk
    870  05ab		       20 74 12 	      jsr	ReadComplete
    871  05ae		       4c b9 02 	      jmp	NextIL
    872  05b1		       20 71 13 	      jsr	popLN
    873  05b4		       4c b9 02 	      jmp	NextIL
    874  05b7							;=====================================================
    875  05b7							; Get a line of text from the user, convert to a
    876  05b7							; number, leave on top of stack.
    877  05b7							;
    878  05b7				   iINNUM
    879  05b7		       20 4c 13 	      jsr	pushLN
    880  05ba		       b0 ec		      bcs	iReadErr	; Stack over flow error
    881  05bc							;
    882  05bc		       a9 3f		      lda	#'?
    883  05be		       a2 00		      ldx	#0	;Wait for complete
    884  05c0		       20 54 12 	      jsr	GetLine
    885  05c3		       20 e9 11 	      jsr	getDecimal
    886  05c6		       20 32 13 	      jsr	pushR0	;put onto stack
    887  05c9		       b0 dd		      bcs	iReadErr	;StackOverflow error
    888  05cb							;
    889  05cb		       4c e5 05 	      jmp	ExitIn
    890  05ce							;
    891  05ce							;=====================================================
    892  05ce							; Get a line of text from the user, convert to a
    893  05ce							; character value , leave on top of stack. up to 2 characters
    894  05ce							;
    895  05ce				   iINSTR
    896  05ce		       20 4c 13 	      jsr	pushLN
    897  05d1		       b0 d5		      bcs	iReadErr	; Stack overflow error
    898  05d3		       a9 3f		      lda	#'?
    899  05d5		       a2 00		      ldx	#0	;wait for read complete
    900  05d7		       20 54 12 	      jsr	GetLine
    901  05da		       b1 4f		      lda	(CURPTR),y
    902  05dc		       85 52		      sta	R0
    903  05de		       a9 00		      lda	#0
    904  05e0		       85 53		      sta	R0+1
    905  05e2		       20 32 13 	      jsr	pushR0	;put onto stack
    906  05e5				   ExitIn
    907  05e5		       20 71 13 	      jsr	popLN
    908  05e8		       4c b9 02 	      jmp	NextIL
    909  05eb							;
    910  05eb							;
    911  05eb							;=====================================================
    912  05eb							; Stop the currently running program.	Actually very
    913  05eb							; simple to do... clear the RunMode flag, then set the
    914  05eb							; ILPC to the standard handler and continue running.
    915  05eb							;
    916  05eb		       a9 00	   iFIN       lda	#0
    917  05ed		       85 62		      sta	RunMode
    918  05ef		       20 ae 0d 	      jsr	taskReset
    919  05f2							;
    920  05f2		       ad fa 25 	      lda	errGoto
    921  05f5		       85 43		      sta	ILPC
    922  05f7		       ad fb 25 	      lda	errGoto+1
    923  05fa		       85 44		      sta	ILPC+1
    924  05fc		       4c b9 02 	      jmp	NextIL
    925  05ff							;
    926  05ff							;=====================================================
    927  05ff							; Handle the ERR opcode.  Following the instruction is
    928  05ff							; a 16 bit error number.  Print an error message, and
    929  05ff							; if we're in run mode, print the line number.  Stop
    930  05ff							; program execution and return to the initial state.
    931  05ff							;
    932  05ff		       20 d2 10    iERR       jsr	getILWord	;get err code
    933  0602							;
    934  0602							; Enter here with the error code in X (LSB) and A (MSB).
    935  0602							;
    936  0602		       86 52	   iErr2      stx	R0
    937  0604		       85 53		      sta	R0+1
    938  0606							;
    939  0606		       20 f1 15 	      jsr	puts
      0  0609					      db	CR,LF,"Error ",0
      1  0609		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    941  0612		       20 7d 11 	      jsr	PrintDecimal
    942  0615							;
    943  0615		       a5 62		      lda	RunMode	;running?
    944  0617		       f0 3b		      beq	iERR3	;nope
    945  0619		       20 f1 15 	      jsr	puts
      0  061c					      db	" at line ",0
      1  061c		       20 61 74 20*	      .byte.b	" at line ",0
    947  0626		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    948  0628				   iErr2a
    949  0628		       b1 4f		      lda	(CURPTR),y
    950  062a		       85 52		      sta	R0
    951  062c		       c8		      iny
    952  062d		       b1 4f		      lda	(CURPTR),y
    953  062f		       85 53		      sta	R0+1
    954  0631		       20 7d 11 	      jsr	PrintDecimal
    955  0634		       20 f1 15 	      jsr	puts
      0  0637					      db	":",0
      1  0637		       3a 00		      .byte.b	":",0
    957  0639		       a9 00		      lda	#0
    958  063b		       85 53		      sta	R0+1
    959  063d		       a5 51		      lda	CUROFF
    960  063f		       18		      clc
    961  0640		       e9 03		      sbc	#3
    962  0642		       85 52		      sta	R0
    963  0644		       20 7d 11 	      jsr	PrintDecimal
    964  0647		       20 f1 15 	      jsr	puts
      0  064a					      db	":",0
      1  064a		       3a 00		      .byte.b	":",0
    966  064c		       ad b6 1c 	      lda	taskPtr
    967  064f		       85 52		      sta	R0
    968  0651		       20 7d 11 	      jsr	PrintDecimal
    969  0654							;
    970  0654		       20 6f 14    iERR3      jsr	CRLF
    971  0657		       20 a6 0d 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    972  065a		       a9 00		      lda	#0
    973  065c		       85 62		      sta	RunMode	;fall through...
    974  065e							;
    975  065e							;=====================================================
    976  065e							; Reset the IL to be back at the idle loop.  Does not
    977  065e							; clear variables so the user can see what state
    978  065e							; the program is in.
    979  065e							;
    980  065e		       a9 00	   ResetIL    lda	#0
    981  0660		       85 47		      sta	ILSTACKPTR
    982  0662		       ad fa 25 	      lda	errGoto
    983  0665		       85 43		      sta	ILPC
    984  0667		       ad fb 25 	      lda	errGoto+1
    985  066a		       85 44		      sta	ILPC+1
    986  066c		       4c b9 02 	      jmp	NextIL
    987  066f
    988  066f							;
    989  066f							;=====================================================
    990  066f							; Pop two items off stack, add them, then place the
    991  066f							; result back onto the stack.
    992  066f							;
    993  066f		       20 b6 13    iADD       jsr	popR0
    994  0672		       20 ce 13 	      jsr	popR1
    995  0675				   iADDfast
    996  0675		       18		      clc
    997  0676		       a5 52		      lda	R0
    998  0678		       65 54		      adc	R1
    999  067a		       85 52		      sta	R0
   1000  067c		       a5 53		      lda	R0+1
   1001  067e		       65 55		      adc	R1+1
   1002  0680		       85 53		      sta	R0+1
   1003  0682		       4c ed 06 	      jmp	pushR0nextIl
   1004  0685							;
   1005  0685							;=====================================================
   1006  0685							; Pop two items off the stack.  Subtract the top of
   1007  0685							; stack from the lower entry.
   1008  0685							;
   1009  0685		       20 ce 13    iSUB       jsr	popR1
   1010  0688		       20 b6 13 	      jsr	popR0
   1011  068b		       38		      sec
   1012  068c		       a5 52		      lda	R0
   1013  068e		       e5 54		      sbc	R1
   1014  0690		       85 52		      sta	R0
   1015  0692		       a5 53		      lda	R0+1
   1016  0694		       e5 55		      sbc	R1+1
   1017  0696		       85 53		      sta	R0+1
   1018  0698		       4c ed 06 	      jmp	pushR0nextIl
   1019  069b							;
   1020  069b							;=====================================================
   1021  069b							; Negate the top of stack.
   1022  069b							;
   1023  069b		       20 b6 13    iNEG       jsr	popR0
   1024  069e		       a5 52		      lda	R0
   1025  06a0		       49 ff		      eor	#$ff
   1026  06a2		       85 52		      sta	R0
   1027  06a4		       a5 53		      lda	R0+1
   1028  06a6		       49 ff		      eor	#$ff
   1029  06a8		       85 53		      sta	R0+1
   1030  06aa		       e6 52		      inc	R0
   1031  06ac		       d0 02		      bne	iNEG2
   1032  06ae		       e6 53		      inc	R0+1
   1033  06b0		       4c ed 06    iNEG2      jmp	pushR0nextIl
   1034  06b3							;
   1035  06b3							;=====================================================
   1036  06b3							; Multiply top two items on the stack, put the results
   1037  06b3							; on top.  This uses the algorithm documented on page
   1038  06b3							; 115 of "Microprocessor Programming for Computer
   1039  06b3							; Hobbyists" by Neill Graham.
   1040  06b3							;
   1041  06b3		       20 b9 06    iMUL       jsr	iMultiply
   1042  06b6		       4c b9 02 	      jmp	NextIL
   1043  06b9
   1044  06b9				   iMultiply
   1045  06b9		       20 b6 13 	      jsr	popR0	;AC
   1046  06bc		       20 ce 13 	      jsr	popR1	;OP
   1047  06bf							;
   1048  06bf		       a5 52		      lda	R0
   1049  06c1		       85 56		      sta	MQ
   1050  06c3		       a5 53		      lda	R0+1
   1051  06c5		       85 57		      sta	MQ+1
   1052  06c7		       a9 00		      lda	#0	;clear result
   1053  06c9		       85 52		      sta	R0
   1054  06cb		       85 53		      sta	R0+1
   1055  06cd							;
   1056  06cd		       a2 10		      ldx	#16	;number of bits in value
   1057  06cf		       06 52	   multloop   asl	R0
   1058  06d1		       26 53		      rol	R0+1
   1059  06d3		       06 56		      asl	MQ
   1060  06d5		       26 57		      rol	MQ+1
   1061  06d7		       90 0d		      bcc	multno	;skip add if no carry
   1062  06d9							;
   1063  06d9							; Add R1 back into R0
   1064  06d9							;
   1065  06d9		       18		      clc
   1066  06da		       a5 52		      lda	R0
   1067  06dc		       65 54		      adc	R1
   1068  06de		       85 52		      sta	R0
   1069  06e0		       a5 53		      lda	R0+1
   1070  06e2		       65 55		      adc	R1+1
   1071  06e4		       85 53		      sta	R0+1
   1072  06e6							;
   1073  06e6		       ca	   multno     dex		;did all bits yet?
   1074  06e7		       d0 e6		      bne	multloop
   1075  06e9		       20 32 13 	      jsr	pushR0	;OP
   1076  06ec		       60		      rts
   1077  06ed							;
   1078  06ed				   pushR0nextIl
   1079  06ed		       20 32 13 	      jsr	pushR0	;OP
   1080  06f0		       4c b9 02 	      jmp	NextIL
   1081  06f3							;
   1082  06f3							;=====================================================
   1083  06f3							; Divide the top of stack into the next to top item.
   1084  06f3							; Leave results on stack.  Taken from:
   1085  06f3							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1086  06f3							;
   1087  06f3							; R0 = R0 / R1
   1088  06f3							; Remainder is in MQ
   1089  06f3							;
   1090  06f3		       20 0d 07    iDIV       jsr	iDoDiv
   1091  06f6		       20 37 14 	      jsr	RestoreSigns
   1092  06f9		       4c ed 06 	      jmp	pushR0nextIl
   1093  06fc
   1094  06fc		       20 0d 07    iMOD       jsr	iDoDiv
   1095  06ff		       20 37 14 	      jsr	RestoreSigns
   1096  0702		       a5 56		      lda	MQ
   1097  0704		       85 52		      sta	R0
   1098  0706		       a5 57		      lda	MQ+1
   1099  0708		       85 53		      sta	R0+1
   1100  070a		       4c ed 06 	      jmp	pushR0nextIl
   1101  070d
   1102  070d				   iDoDiv
   1103  070d		       20 ce 13 	      jsr	popR1
   1104  0710		       20 b6 13 	      jsr	popR0
   1105  0713							;
   1106  0713							; Check for divide by zero
   1107  0713							;
   1108  0713
   1109  0713				   iDivNoPop
   1110  0713		       a5 54		      lda	R1
   1111  0715		       05 55		      ora	R1+1
   1112  0717		       f0 29		      beq	divby0
   1113  0719							;
   1114  0719		       20 fc 13 	      jsr	SaveSigns
   1115  071c		       a9 00		      lda	#0	;preset remainder to 0
   1116  071e		       85 56		      sta	MQ
   1117  0720		       85 57		      sta	MQ+1
   1118  0722		       a2 10		      ldx	#16	;repeat for each bit: ...
   1119  0724				   divloop
   1120  0724		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1121  0726		       26 53		      rol	R0+1
   1122  0728		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1123  072a		       26 57		      rol	MQ+1
   1124  072c		       a5 56		      lda	MQ
   1125  072e		       38		      sec
   1126  072f		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1127  0731		       a8		      tay		;lb result -> Y, for we may need it later
   1128  0732		       a5 57		      lda	MQ+1
   1129  0734		       e5 55		      sbc	R1+1
   1130  0736		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1131  0738
   1132  0738		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1133  073a		       84 56		      sty	MQ
   1134  073c		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1135  073e
   1136  073e		       ca	   skip       dex
   1137  073f		       d0 e3		      bne	divloop
   1138  0741		       60		      rts
   1139  0742							;
   1140  0742							; Indicate divide-by-zero error
   1141  0742							;
   1142  0742		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1143  0744		       a9 00		      lda	#0
   1144  0746		       4c 02 06 	      jmp	iErr2
   1145  0749							;
   1146  0749							;=====================================================
   1147  0749							; This pops the top two items off the stack.  The top
   1148  0749							; item is a data value and the other is an ABSOLUTE address.
   1149  0749							;Save the value into that address.
   1150  0749							;
   1151  0749		       98	   iSTORE     tya
   1152  074a		       48		      pha
   1153  074b		       20 b6 13 	      jsr	popR0	;data
   1154  074e		       20 ce 13 	      jsr	popR1	;Storage location
   1155  0751		       a0 00		      ldy	#0
   1156  0753		       a5 52		      lda	R0
   1157  0755		       91 54		      sta	(R1),y
   1158  0757		       a5 53		      lda	R0+1
   1159  0759		       c8		      iny
   1160  075a		       91 54		      sta	(R1),y
   1161  075c		       68		      pla
   1162  075d		       a8		      tay
   1163  075e		       4c b9 02 	      jmp	NextIL
   1164  0761							;
   1165  0761							;=====================================================
   1166  0761							; Replaces the top of stack with the variable whose
   1167  0761							; absolute address it represents.
   1168  0761							;
   1169  0761		       98	   iIND       tya
   1170  0762		       48		      pha
   1171  0763		       20 ce 13 	      jsr	popR1
   1172  0766		       a0 00		      ldy	#0
   1173  0768		       b1 54		      lda	(R1),y
   1174  076a		       85 52		      sta	R0
   1175  076c		       c8		      iny
   1176  076d		       b1 54		      lda	(R1),y
   1177  076f		       85 53		      sta	R0+1
   1178  0771		       68		      pla
   1179  0772		       a8		      tay
   1180  0773		       4c ed 06 	      jmp	pushR0nextIl
   1181  0776							;
   1182  0776							;=====================================================
   1183  0776							; Get the array index from top of stack get Current variable
   1184  0776							; address from next on stack, add the offset
   1185  0776							; push the result back onto the stack
   1186  0776				   iArray
   1187  0776		       20 b6 13 	      jsr	popR0	; Get the array index
   1188  0779		       20 ce 13 	      jsr	popR1	; Get the Variable address
   1189  077c
   1190  077c		       18		      clc		; Multiplythe value by 2
   1191  077d		       26 52		      rol	R0	; Do the multiply
   1192  077f		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1193  0781		       18		      clc
   1194  0782		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1195  0784		       65 52		      adc	R0
   1196  0786		       85 52		      sta	R0
   1197  0788		       a5 55		      lda	R1+1
   1198  078a		       65 53		      adc	R0+1
   1199  078c		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1200  078e		       20 32 13 	      jsr	pushR0	; Push R0 assume it is correct
   1201  0791
   1202  0791		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1203  0793		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1204  0795		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1205  0797		       a5 55		      lda	R1+1
   1206  0799		       c5 42		      cmp	VARIABLES+1
   1207  079b		       d0 1c		      bne	iArrayAtTest
   1208  079d		       18		      clc
   1209  079e		       a9 34		      lda	#52	; add the max offset that is valid
   1210  07a0		       65 54		      adc	R1	; update to be the largest offset that is valid
   1211  07a2		       85 54		      sta	R1
   1212  07a4		       a9 00		      lda	#0
   1213  07a6		       65 55		      adc	R1+1
   1214  07a8		       85 55		      sta	R1+1
   1215  07aa				   iArrayVerify 		; try to enforce some sanity to using arrays
   1216  07aa		       a5 53		      lda	R0+1
   1217  07ac		       c5 55		      cmp	R1+1
   1218  07ae		       d0 04		      bne	iArrayDecide
   1219  07b0		       a5 52		      lda	R0
   1220  07b2		       c5 54		      cmp	R1
   1221  07b4				   iArrayDecide
   1222  07b4		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1223  07b6		       4c b9 02 	      jmp	NextIL
   1224  07b9
   1225  07b9				   iArrayAtTest
   1226  07b9		       ad 08 26 	      lda	HighMem
   1227  07bc		       85 54		      sta	R1
   1228  07be		       ad 09 26 	      lda	HighMem+1
   1229  07c1		       85 55		      sta	R1+1
   1230  07c3		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1231  07c5
   1232  07c5							; Get here if array index is out of range
   1233  07c5		       20 b6 13    iArrayError jsr	popR0
   1234  07c8		       a9 00		      lda	#0
   1235  07ca		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1236  07cc		       4c 02 06 	      jmp	iErr2
   1237  07cf							;
   1238  07cf							;=====================================================
   1239  07cf							; List the current BASIC program in memory.  Uses R0,
   1240  07cf							; tempIly, and dpl.
   1241  07cf							;
   1242  07cf		       20 d1 15    iLST       jsr	SetOutConsole
   1243  07d2		       a9 0e	   iLST2      lda	#ProgramStart&$ff
   1244  07d4		       85 59		      sta	dpl
   1245  07d6		       a9 26		      lda	#ProgramStart>>8
   1246  07d8		       85 5a		      sta	dpl+1
   1247  07da							;
   1248  07da							; dpl/dph point to the current line.  See if we're at
   1249  07da							; the end of the program.
   1250  07da							;
   1251  07da		       a5 59	   iLSTloop   lda	dpl
   1252  07dc		       cd 06 26 	      cmp	PROGRAMEND
   1253  07df		       d0 07		      bne	iLstNotEnd
   1254  07e1		       a5 5a		      lda	dpl+1
   1255  07e3		       cd 07 26 	      cmp	PROGRAMEND+1
   1256  07e6		       f0 40		      beq	iLstdone
   1257  07e8							;
   1258  07e8		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1259  07ea		       b1 59		      lda	(dpl),y	;line number LSB
   1260  07ec		       85 52		      sta	R0
   1261  07ee		       c8		      iny
   1262  07ef		       b1 59		      lda	(dpl),y	;line number MSB
   1263  07f1		       85 53		      sta	R0+1
   1264  07f3		       c8		      iny
   1265  07f4		       84 5d		      sty	tempIlY
   1266  07f6		       20 7d 11 	      jsr	PrintDecimal
   1267  07f9		       a9 20		      lda	#SPACE
   1268  07fb		       20 eb 15 	      jsr	VOUTCH
   1269  07fe		       a4 5d		      ldy	tempIlY
   1270  0800		       b1 59	   iLSTl2     lda	(dpl),y
   1271  0802		       f0 0a		      beq	iLST3	;end of this line 0 value
   1272  0804		       84 5d		      sty	tempIlY
   1273  0806		       20 eb 15 	      jsr	VOUTCH
   1274  0809		       a4 5d		      ldy	tempIlY
   1275  080b		       c8		      iny
   1276  080c		       d0 f2		      bne	iLSTl2	;do next char
   1277  080e							;
   1278  080e							; End of this line.  Print CR/LF, then move to the
   1279  080e							; next line.
   1280  080e							;
   1281  080e		       c8	   iLST3      iny		;Move to next line
   1282  080f		       18		      clc		;Clear the carry flag
   1283  0810		       98		      tya		;Current Offset
   1284  0811		       65 59		      adc	dpl	;Add the offset to the pointer
   1285  0813		       85 59		      sta	dpl	;Save the new value
   1286  0815		       a5 5a		      lda	dpl+1	;Next byte
   1287  0817		       69 00		      adc	#0	;ad in the carry if any
   1288  0819		       85 5a		      sta	dpl+1	;Save it
   1289  081b							;
   1290  081b							; Have to manually do CR/LF so it uses the vectored
   1291  081b							; output function.
   1292  081b							;
   1293  081b		       a9 0d		      lda	#CR
   1294  081d		       20 eb 15 	      jsr	VOUTCH
   1295  0820		       a9 0a		      lda	#LF
   1296  0822		       20 eb 15 	      jsr	VOUTCH
   1297  0825		       4c da 07 	      jmp	iLSTloop	;do next line
   1298  0828							;
   1299  0828		       20 d1 15    iLstdone   jsr	SetOutConsole
   1300  082b		       4c b9 02 	      jmp	NextIL
   1301  082e							;
   1302  082e							;=====================================================
   1303  082e							; Get a line of text into LINBUF.  Terminate with a
   1304  082e							; null byte.
   1305  082e							;
   1306  082e				   iGETLINE
   1307  082e		       a9 3e		      lda	#'>	;prompt character
   1308  0830		       a6 00		      ldx	0	;Wait for read to complete
   1309  0832		       20 54 12 	      jsr	GetLine
   1310  0835							;
   1311  0835		       a9 00		      lda	#0
   1312  0837		       85 62		      sta	RunMode
   1313  0839		       4c b9 02 	      jmp	NextIL
   1314  083c							;
   1315  083c							;=====================================================
   1316  083c							; This is called when the input buffer contains a line
   1317  083c							; typed in by the user that starts with a line number.
   1318  083c							; Insert the line into the program or delete the line
   1319  083c							; if there is nothing after the line number,
   1320  083c							;
   1321  083c		       a0 00	   iINSRT     ldy	#0
   1322  083e		       20 e9 11 	      jsr	getDecimal	;convert line #
   1323  0841		       20 66 14 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1324  0844		       84 5e		      sty	offset	;Save the start of the program line text
   1325  0846							;
   1326  0846							; Now find the line OR the next higher line OR the
   1327  0846							; end of the program.
   1328  0846							;
   1329  0846		       20 1b 11 	      jsr	findLine	; Look for the line number in the current program
   1330  0849							; Returns Z and curptr point to the line if found
   1331  0849							; Returns C and curptr at next higher line if not found and there is a higher line
   1332  0849							; Returns ZC clear and curptr to end of program if higher than all other lines
   1333  0849							;
   1334  0849							; If the line exists, it needs to be removed.
   1335  0849							;
   1336  0849		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1337  084b							;
   1338  084b							; Get length of line to be removed, we fall thru to here if we find a matching line
   1339  084b							;
   1340  084b							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1341  084b		       a0 00		      ldy	#0
   1342  084d		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1343  084f		       a8		      tay
   1344  0850							;If it is equal we delete the line and replace it, get length
   1345  0850							;then adjust all program line after up or down depending on len of line
   1346  0850							;If next higher then just move everythimg down by length bytes
   1347  0850							;This call will return how many bytes in the line we found
   1348  0850		       84 5f		      sty	lineLength	;Save the length of the line we found
   1349  0852							;
   1350  0852							; Compute the new end of the program first.
   1351  0852							;
   1352  0852		       38		      sec		;Set the carry bit
   1353  0853		       ad 06 26 	      lda	PROGRAMEND	;Get low byte of program end
   1354  0856		       e5 5f		      sbc	lineLength	;Subtract the length of the current line
   1355  0858		       8d 06 26 	      sta	PROGRAMEND	;save it
   1356  085b		       ad 07 26 	      lda	PROGRAMEND+1
   1357  085e		       e9 00		      sbc	#0	;Process the carry
   1358  0860		       8d 07 26 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1359  0863							;
   1360  0863							; Copy CURPTR into R1 for working
   1361  0863							;
   1362  0863		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1363  0865		       85 54		      sta	R1
   1364  0867		       a5 50		      lda	CURPTR+1
   1365  0869		       85 55		      sta	R1+1
   1366  086b							;
   1367  086b							; See if we're at the end.
   1368  086b							;
   1369  086b		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1370  086d		       cd 06 26 	      cmp	PROGRAMEND
   1371  0870		       d0 07		      bne	InsDelLoop
   1372  0872		       a5 55		      lda	R1+1
   1373  0874		       cd 07 26 	      cmp	PROGRAMEND+1
   1374  0877		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1375  0879							;
   1376  0879							; Move one byte, move to next location.
   1377  0879							;
   1378  0879		       a4 5f	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1379  087b		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1380  087d		       b1 54		      lda	(R1),y
   1381  087f		       a0 00		      ldy	#0
   1382  0881		       91 54		      sta	(R1),y
   1383  0883		       e6 54		      inc	R1
   1384  0885		       d0 e4		      bne	InsDelChk
   1385  0887		       e6 55		      inc	R1+1
   1386  0889		       4c 6b 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1387  088c							;
   1388  088c							; Deletion is done.
   1389  088c							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1390  088c							;
   1391  088c		       a4 5e	   insert2    ldy	offset	;get back ptr	Get the current offset
   1392  088e		       b9 70 25 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1393  0891		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1394  0893							;
   1395  0893							; CURPTR points to where the line will be inserted.
   1396  0893							;
   1397  0893		       20 0e 13 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1398  0896							;
   1399  0896		       ad 06 26 	      lda	PROGRAMEND	;Load the start address for the copy
   1400  0899							;At this point curptr still contains the location we will insert data
   1401  0899		       85 63		      sta	FROM
   1402  089b		       ad 07 26 	      lda	PROGRAMEND+1
   1403  089e		       85 64		      sta	FROM+1
   1404  08a0							;
   1405  08a0		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1406  08a2		       b1 63		      lda	(FROM),y
   1407  08a4		       a4 5f		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1408  08a6		       91 63		      sta	(FROM),y	;Save the new byte
   1409  08a8							;
   1410  08a8		       a5 63		      lda	FROM	;Check if we have copies the last byte
   1411  08aa		       c5 4f		      cmp	CURPTR
   1412  08ac		       d0 06		      bne	mvUpMore
   1413  08ae		       a5 64		      lda	FROM+1
   1414  08b0		       c5 50		      cmp	CURPTR+1
   1415  08b2		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1416  08b4							;
   1417  08b4							; Not done yet
   1418  08b4							;
   1419  08b4		       a5 63	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1420  08b6		       d0 02		      bne	mvUpMore2
   1421  08b8		       c6 64		      dec	FROM+1
   1422  08ba		       c6 63	   mvUpMore2  dec	FROM
   1423  08bc		       4c a0 08 	      jmp	mvup1	;Loop until everything is moved
   1424  08bf							;
   1425  08bf							; All done with copy.
   1426  08bf							;
   1427  08bf		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1428  08c0		       a5 5f		      lda	lineLength	;Number of bytes to copy from line buff
   1429  08c2		       6d 06 26 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1430  08c5		       8d 06 26 	      sta	PROGRAMEND
   1431  08c8		       ad 07 26 	      lda	PROGRAMEND+1
   1432  08cb		       69 00		      adc	#0
   1433  08cd		       8d 07 26 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1434  08d0							;
   1435  08d0							;===================jlit use length before line newline
   1436  08d0
   1437  08d0		       a0 00		      ldy	#0	;Set offset of copy
   1438  08d2		       a5 5f		      lda	lineLength	;We will insert the actual length of the line first
   1439  08d4		       91 4f		      sta	(CURPTR),y	;Store the length
   1440  08d6		       c8		      iny
   1441  08d7		       a5 52		      lda	R0	;Store the line number next
   1442  08d9		       91 4f		      sta	(CURPTR),y
   1443  08db		       c8		      iny
   1444  08dc		       a5 53		      lda	R0+1
   1445  08de		       91 4f		      sta	(CURPTR),y
   1446  08e0		       c8		      iny
   1447  08e1							;
   1448  08e1		       a6 5e		      ldx	offset	;Load the offset into line buffer in page zero
   1449  08e3		       bd 70 25    mvUpLoop2  lda	LINBUF,x	;get a byte
   1450  08e6		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1451  08e8		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1452  08ea		       e8		      inx
   1453  08eb		       c8		      iny
   1454  08ec		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1455  08ee							;
   1456  08ee		       4c b9 02    mvUpFini   jmp	NextIL
   1457  08f1							;
   1458  08f1							;=====================================================
   1459  08f1							; Pops the top value of the ILPC stack and stores it
   1460  08f1							; in ILPC.  Ie, return from an IL subroutine.
   1461  08f1							;
   1462  08f1		       20 09 11    iRTN       jsr	popILPC
   1463  08f4		       4c b9 02 	      jmp	NextIL
   1464  08f7							;
   1465  08f7							;=====================================================
   1466  08f7							; NLINE print a newline
   1467  08f7							;
   1468  08f7		       20 6f 14    iNLINE     jsr	CRLF	;user supplied sub
   1469  08fa		       4c b9 02 	      jmp	NextIL
   1470  08fd							;
   1471  08fd							;=====================================================
   1472  08fd							; This saves the current ILPC value on the stack, then
   1473  08fd							; jumps to the address specified by the next two bytes.
   1474  08fd							;
   1475  08fd		       20 ec 10    iCALL      jsr	pushILPC	;save ILPC
   1476  0900		       90 03		      bcc	iJMP
   1477  0902		       4c ff 0a 	      jmp	ErrStkOver	; Check if there was an error
   1478  0905							;
   1479  0905							; Jmp to a specific location in the IL code.  The new
   1480  0905							; address immediately follows the opcode.
   1481  0905							;
   1482  0905		       20 d2 10    iJMP       jsr	getILWord
   1483  0908		       86 43		      stx	ILPC
   1484  090a		       85 44		      sta	ILPC+1
   1485  090c		       4c b9 02 	      jmp	NextIL
   1486  090f
   1487  090f
   1488  090f							;
   1489  090f							;=====================================================
   1490  090f							; Push the next two bytes onto the arithmetic stack.
   1491  090f							;
   1492  090f		       20 d6 10    iSetR2     jsr	getILByte
   1493  0912		       86 58		      stx	R2
   1494  0914		       4c b9 02 	      jmp	NextIL
   1495  0917							;
   1496  0917							;=====================================================
   1497  0917							; Push the next two bytes onto the arithmetic stack.
   1498  0917							;
   1499  0917		       20 d2 10    iLIT       jsr	getILWord
   1500  091a		       86 52		      stx	R0
   1501  091c		       85 53		      sta	R0+1
   1502  091e		       20 32 13 	      jsr	pushR0
   1503  0921		       4c b9 02 	      jmp	NextIL
   1504  0924							;
   1505  0924							;=====================================================
   1506  0924							; Initialize all variables for a single task.	Ie, set to zero.
   1507  0924							;
   1508  0924		       98	   subVINIT   tya
   1509  0925		       48		      pha
   1510  0926
   1511  0926		       a9 00		      lda	#0
   1512  0928		       a0 00		      ldy	#0
   1513  092a		       91 41	   Vinit2     sta	(VARIABLES),y
   1514  092c		       c8		      iny
   1515  092d		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1516  092f		       90 f9		      bcc	Vinit2
   1517  0931
   1518  0931		       68		      pla
   1519  0932		       a8		      tay
   1520  0933		       60		      rts
   1521  0934
   1522  0934		       20 24 09    iVINIT     jsr	subVINIT
   1523  0937		       4c b9 02 	      jmp	NextIL
   1524  093a							;
   1525  093a							;=====================================================
   1526  093a							; Set the address of the error handler.  After any
   1527  093a							; error, set to the ILPC to the specified location.
   1528  093a							;
   1529  093a		       20 d2 10    iERRGOTO   jsr	getILWord
   1530  093d		       8e fa 25 	      stx	errGoto
   1531  0940		       8d fb 25 	      sta	errGoto+1
   1532  0943		       4c b9 02 	      jmp	NextIL
   1533  0946							;
   1534  0946							;=====================================================
   1535  0946							; TST is followed by an 8 bit signed offset, then a
   1536  0946							; null terminated string.  Compare the string against
   1537  0946							; the string starting at (CURPTR),CUROFF.  If the
   1538  0946							; strings match, continue executing the next IL
   1539  0946							; opcode.  Else, add the offset to ILPC.
   1540  0946							;
   1541  0946		       20 d6 10    iTST       jsr	getILByte	;Get the relative jump address
   1542  0949		       85 5e		      sta	offset	;save it to use if test faile
   1543  094b		       20 20 13 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1544  094e
   1545  094e		       a4 51		      ldy	CUROFF
   1546  0950		       84 59		      sty	dpl	;save for later
   1547  0952							;
   1548  0952		       20 d6 10    iTSTloop   jsr	getILByte	;get next char
   1549  0955		       f0 11		      beq	iTSTm	;match!
   1550  0957		       a4 59		      ldy	dpl
   1551  0959		       d1 4f		      cmp	(CURPTR),y
   1552  095b		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1553  095d		       09 20		      ora	#$20	; lets allow lowercase as well
   1554  095f		       d1 4f		      cmp	(CURPTR),y
   1555  0961		       d0 22		      bne	iTSTfail	;mismatch
   1556  0963		       c8	   iTSTUpper  iny
   1557  0964		       84 59		      sty	dpl
   1558  0966		       d0 ea		      bne	iTSTloop
   1559  0968							;
   1560  0968							; It's a match!  Clean up a bit.
   1561  0968							;
   1562  0968		       a4 59	   iTSTm      ldy	dpl
   1563  096a		       84 51		      sty	CUROFF
   1564  096c		       4c b9 02 	      jmp	NextIL
   1565  096f
   1566  096f							; Test for a single quote string
   1567  096f		       20 d6 10    iTSTStr    jsr	getILByte
   1568  0972		       85 5e		      sta	offset
   1569  0974		       20 20 13 	      jsr	saveIL
   1570  0977		       a4 51		      ldy	CUROFF
   1571  0979		       a9 22		      lda	#'"
   1572  097b		       d1 4f		      cmp	(CURPTR),y
   1573  097d		       d0 06		      bne	iTSTfail
   1574  097f		       c8		      iny
   1575  0980		       84 51		      sty	CUROFF
   1576  0982		       4c da 02 	      jmp	NextILStr
   1577  0985							;
   1578  0985							; Not a match, reset ILPC and then move to the
   1579  0985							; offset.
   1580  0985							;
   1581  0985		       20 29 13    iTSTfail   jsr	restoreIL
   1582  0988		       4c b1 0a 	      jmp	tstBranch
   1583  098b							;
   1584  098b							;=================================================JLIT=
   1585  098b							; Test if we have a let statement without the let keyword
   1586  098b		       20 d6 10    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1587  098e		       85 5e		      sta	offset	; Save the jump offset for fails
   1588  0990		       20 20 13 	      jsr	saveIL	; save to restore when done if fail
   1589  0993
   1590  0993		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1591  0995		       20 66 14 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1592  0998		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1593  0999		       20 66 14 	      jsr	SkipSpaces	; skip any SkipSpaces
   1594  099c		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1595  099e		       c9 3d		      cmp	#'=	; check if equals
   1596  09a0		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1597  09a2		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1598  09a4		       d0 df		      bne	iTSTfail	; return it failed
   1599  09a6
   1600  09a6				   iTSTLETGOOD
   1601  09a6		       4c b9 02 	      jmp	NextIL	; Then next instruction
   1602  09a9
   1603  09a9							;=================================================JLIT=
   1604  09a9							;
   1605  09a9		       20 d6 10    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1606  09ac		       85 5e		      sta	offset	; Save the jump offset for fails
   1607  09ae		       20 20 13 	      jsr	saveIL	; save to restore when done if fail
   1608  09b1		       20 d2 10 	      jsr	getILWord	; Get a word into RO
   1609  09b4		       86 52		      stx	R0
   1610  09b6		       85 53		      sta	R0+1
   1611  09b8		       20 d6 10 	      jsr	getILByte	; Get byte into A
   1612  09bb		       a0 00		      ldy	#0
   1613  09bd		       d1 52		      cmp	(R0),y
   1614  09bf		       d0 03		      bne	iTSTByteNotEqual
   1615  09c1		       4c 85 09 	      jmp	iTSTfail
   1616  09c4
   1617  09c4				   iTSTByteNotEqual
   1618  09c4		       4c b9 02 	      jmp	NextIL	; Then next instruction
   1619  09c7
   1620  09c7
   1621  09c7							;================================================jLIT=
   1622  09c7							;Test for end of line
   1623  09c7							;
   1624  09c7		       20 d6 10    iTSTDONE   jsr	getILByte
   1625  09ca		       85 5e		      sta	offset
   1626  09cc		       20 20 13 	      jsr	saveIL
   1627  09cf		       a4 51		      ldy	CUROFF
   1628  09d1		       84 59		      sty	dpl
   1629  09d3		       20 66 14 	      jsr	SkipSpaces
   1630  09d6		       b1 4f		      lda	(CURPTR),y
   1631  09d8		       f0 0b		      beq	iTSTDONEtrue
   1632  09da		       c9 3a		      cmp	#COLON
   1633  09dc		       f0 07		      beq	iTSTDONEtrue
   1634  09de		       a4 59		      ldy	dpl
   1635  09e0		       84 51		      sty	CUROFF
   1636  09e2		       4c 85 09 	      jmp	iTSTfail
   1637  09e5							;
   1638  09e5							; Advance to the next line
   1639  09e5							;
   1640  09e5				   iTSTDONEtrue
   1641  09e5		       4c b9 02 	      jmp	NextIL
   1642  09e8
   1643  09e8		       4c b1 0a    tstBranchLink jmp	tstBranch
   1644  09eb							;
   1645  09eb							;=====================================================
   1646  09eb							; TSTV is followed by an 8 bit signed offset.	If the
   1647  09eb							; value at (CURPTR),CUROFF appears to be a variable
   1648  09eb							; name, move to the next IL statement.  Else, add the
   1649  09eb							; offset to ILPC. Converted to use actual absolute memory addresses
   1650  09eb							; TSTVT Looks for the task context
   1651  09eb							;
   1652  09eb		       20 ce 13    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1653  09ee		       a9 00		      lda	#0
   1654  09f0		       85 58		      sta	R2
   1655  09f2		       f0 04		      beq	iTSTVV
   1656  09f4
   1657  09f4		       a9 01	   iTSTV      lda	#1
   1658  09f6		       85 58		      sta	R2
   1659  09f8
   1660  09f8		       20 d6 10    iTSTVV     jsr	getILByte	;offset
   1661  09fb		       85 5e		      sta	offset
   1662  09fd							;
   1663  09fd		       a4 51		      ldy	CUROFF
   1664  09ff		       20 66 14 	      jsr	SkipSpaces
   1665  0a02		       b1 4f		      lda	(CURPTR),y
   1666  0a04		       d0 03		      bne	iTSTVnext
   1667  0a06		       4c e8 09 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1668  0a09							;
   1669  0a09				   iTSTVnext
   1670  0a09		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1671  0a0b		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1672  0a0d
   1673  0a0d		       c9 23		      cmp	#'#	; parameters passed to this task
   1674  0a0f		       f0 53		      beq	iTSTVParm
   1675  0a11
   1676  0a11		       c9 5e		      cmp	#'^	; task exit code
   1677  0a13		       d0 04		      bne	iTSTV_A2Z
   1678  0a15		       a9 19		      lda	#TASKEXITCODE
   1679  0a17		       d0 10		      bne	iTSTVContinue
   1680  0a19
   1681  0a19				   iTSTV_A2Z
   1682  0a19		       09 20		      ora	#$20	;make lower then upper
   1683  0a1b		       49 20		      eor	#$20	;allow lower case here
   1684  0a1d		       c9 41		      cmp	#'A
   1685  0a1f		       90 c7		      bcc	tstBranchLink
   1686  0a21		       c9 5b		      cmp	#'Z+1
   1687  0a23		       b0 c3		      bcs	tstBranchLink
   1688  0a25
   1689  0a25
   1690  0a25							;
   1691  0a25							; The condition is true, so convert to an index, push
   1692  0a25							; it onto the stack and continue running.
   1693  0a25							;
   1694  0a25		       38		      sec
   1695  0a26		       e9 41		      sbc	#'A	;index is zero based
   1696  0a28		       0a		      asl		;multiply by two
   1697  0a29
   1698  0a29				   iTSTVContinue
   1699  0a29		       c8		      iny
   1700  0a2a		       84 51		      sty	CUROFF	;it is a valid variable
   1701  0a2c		       48		      pha
   1702  0a2d		       a5 58		      lda	R2
   1703  0a2f		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1704  0a31
   1705  0a31		       20 b9 10 	      jsr	ipc_getcontext	; Get the other tasks variables
   1706  0a34		       a0 01		      ldy	#VARIABLEPOS
   1707  0a36		       b1 56		      lda	(MQ),y
   1708  0a38		       85 52		      sta	R0
   1709  0a3a		       c8		      iny
   1710  0a3b		       b1 56		      lda	(MQ),y
   1711  0a3d		       85 53		      sta	R0+1
   1712  0a3f		       4c 4a 0a 	      jmp	iTSTVAddOffset
   1713  0a42
   1714  0a42				   iTSTVLocalValue
   1715  0a42		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1716  0a44		       85 52		      sta	R0
   1717  0a46		       a5 42		      lda	VARIABLES+1
   1718  0a48		       85 53		      sta	R0+1
   1719  0a4a
   1720  0a4a				   iTSTVAddOffset
   1721  0a4a		       68		      pla
   1722  0a4b		       85 54		      sta	R1
   1723  0a4d		       a9 00		      lda	#0
   1724  0a4f		       85 55		      sta	R1+1
   1725  0a51
   1726  0a51				   iTSTVcontinue
   1727  0a51
   1728  0a51		       4c 75 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1729  0a54
   1730  0a54							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1731  0a54							; an array of integer values
   1732  0a54				   iTSTVat
   1733  0a54		       c8		      iny
   1734  0a55		       84 51		      sty	CUROFF	;it is a valid variable
   1735  0a57		       ad 06 26 	      lda	PROGRAMEND	;set flag to let evaluator to use PROGRAMEND as the root
   1736  0a5a		       85 52		      sta	R0
   1737  0a5c		       ad 07 26 	      lda	PROGRAMEND+1
   1738  0a5f		       85 53		      sta	R0+1
   1739  0a61		       4c ed 06 	      jmp	pushR0nextIl	;place this onto the stack
   1740  0a64
   1741  0a64							; When we get parameters passed we can access them using the # variable with[]
   1742  0a64							; example #[0] #[1] etc, we dont check yet if there is too many
   1743  0a64				   iTSTVParm
   1744  0a64		       c8		      iny
   1745  0a65		       84 51		      sty	CUROFF	;it is a valid variable
   1746  0a67		       a5 48		      lda	MATHSTACK
   1747  0a69		       85 52		      sta	R0
   1748  0a6b		       a5 49		      lda	MATHSTACK+1
   1749  0a6d		       85 53		      sta	R0+1
   1750  0a6f		       4c ed 06 	      jmp	pushR0nextIl
   1751  0a72
   1752  0a72							;
   1753  0a72							;=====================================================
   1754  0a72							; TSTL seems basically the same as TSTN, but leave the
   1755  0a72							; value in R0 instead of pushing onto stack.
   1756  0a72							; This tests for a valid line number
   1757  0a72							;
   1758  0a72		       20 d6 10    iTSTL      jsr	getILByte
   1759  0a75		       85 5e		      sta	offset
   1760  0a77							;
   1761  0a77		       a4 51		      ldy	CUROFF
   1762  0a79		       20 66 14 	      jsr	SkipSpaces
   1763  0a7c		       b1 4f		      lda	(CURPTR),y
   1764  0a7e							;
   1765  0a7e		       c9 30		      cmp	#'0
   1766  0a80		       90 2f		      bcc	tstBranch
   1767  0a82		       c9 3a		      cmp	#'9+1
   1768  0a84		       b0 2b		      bcs	tstBranch
   1769  0a86							;
   1770  0a86							; It's a digit, so convert to a number.
   1771  0a86							;
   1772  0a86		       20 e9 11 	      jsr	getDecimal
   1773  0a89		       4c b9 02 	      jmp	NextIL
   1774  0a8c							;
   1775  0a8c							;=====================================================
   1776  0a8c							; TSTN checks for a number.  This is very simplistic;
   1777  0a8c							; if the character is a digit, assume it's a number.
   1778  0a8c							; Convert to a number and push it onto the stack.
   1779  0a8c							;
   1780  0a8c		       20 d6 10    iTSTN      jsr	getILByte
   1781  0a8f		       85 5e		      sta	offset
   1782  0a91							;
   1783  0a91		       a4 51		      ldy	CUROFF
   1784  0a93		       20 66 14 	      jsr	SkipSpaces
   1785  0a96		       b1 4f		      lda	(CURPTR),y
   1786  0a98		       f0 17		      beq	tstBranch
   1787  0a9a		       c9 2d		      cmp	#'-	;negative?
   1788  0a9c		       f0 08		      beq	iTSTN_1
   1789  0a9e		       c9 30		      cmp	#'0
   1790  0aa0		       90 0f		      bcc	tstBranch
   1791  0aa2		       c9 3a		      cmp	#'9+1
   1792  0aa4		       b0 0b		      bcs	tstBranch
   1793  0aa6							;
   1794  0aa6							; It's a digit, so convert to a number.
   1795  0aa6							;
   1796  0aa6				   iTSTN_1
   1797  0aa6		       20 e9 11 	      jsr	getDecimal
   1798  0aa9		       84 51		      sty	CUROFF
   1799  0aab		       20 32 13 	      jsr	pushR0	;save onto stack
   1800  0aae		       4c b9 02 	      jmp	NextIL
   1801  0ab1
   1802  0ab1							;
   1803  0ab1							; Common jump point for all TSTx instructions that
   1804  0ab1							; fail to meet the requirements.  This takes the
   1805  0ab1							; offset and adds/subtracts to/from ILPC.
   1806  0ab1							;
   1807  0ab1		       a5 5e	   tstBranch  lda	offset	;get signed offset
   1808  0ab3		       10 0e		      bpl	tstPositive
   1809  0ab5							;
   1810  0ab5							; Do negative branch.	Do sign extension.
   1811  0ab5							;
   1812  0ab5		       18	   tstNegative clc
   1813  0ab6		       65 43		      adc	ILPC
   1814  0ab8		       85 43		      sta	ILPC
   1815  0aba							;		  bcc	  tstBothDone
   1816  0aba							;		  dec	  ILPC+1
   1817  0aba							;		  jmp	  NextIL
   1818  0aba
   1819  0aba		       a5 44		      lda	ILPC+1
   1820  0abc		       69 ff		      adc	#$ff
   1821  0abe		       85 44		      sta	ILPC+1
   1822  0ac0		       4c b9 02 	      jmp	NextIL	;keep going
   1823  0ac3							;
   1824  0ac3		       18	   tstPositive clc
   1825  0ac4		       65 43		      adc	ILPC
   1826  0ac6		       85 43		      sta	ILPC
   1827  0ac8		       90 02		      bcc	tstBothDone
   1828  0aca		       e6 44		      inc	ILPC+1
   1829  0acc				   tstBothDone
   1830  0acc		       4c b9 02 	      jmp	NextIL
   1831  0acf
   1832  0acf							;
   1833  0acf							;====================================================
   1834  0acf							; Test for IRQ pending, and test if a break key pressed
   1835  0acf							; Yes I know but this handles all sorts of irq/break issues
   1836  0acf							;
   1837  0acf		       20 d6 10    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1838  0ad2		       85 5e		      sta	offset	; Store the not true jump address offset
   1839  0ad4		       20 26 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1840  0ad7		       d0 03		      bne	irqNo	; z not set of no break found
   1841  0ad9		       4c eb 05 	      jmp	iFIN	; Exit out of run mode
   1842  0adc		       ad b3 1c    irqNo      lda	IRQPending
   1843  0adf		       f0 d0		      beq	tstBranch
   1844  0ae1		       c9 01		      cmp	#1	; only do this if set to first time
   1845  0ae3		       d0 cc		      bne	tstBranch
   1846  0ae5		       78		      sei		; disable the interupt until ireturn resets it
   1847  0ae6		       ee b3 1c    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1848  0ae9		       20 4c 13 	      jsr	pushLN	; Push the next line to be executed
   1849  0aec		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1850  0aee		       ad b4 1c 	      lda	IRQEntry	; Get the line number to branch to
   1851  0af1		       85 4f		      sta	CURPTR	; put line number into r0
   1852  0af3		       ad b5 1c 	      lda	IRQEntry+1
   1853  0af6		       85 50		      sta	CURPTR+1
   1854  0af8		       a9 03		      lda	#3	; Point to first byte of program text
   1855  0afa		       85 51		      sta	CUROFF
   1856  0afc		       4c b9 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1857  0aff
   1858  0aff		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1859  0b01		       a9 00		      lda	#0	; stop the execution
   1860  0b03		       4c 02 06 	      jmp	iErr2
   1861  0b06							;
   1862  0b06
   1863  0b06							;=====================================================
   1864  0b06							; This places the number of free bytes on top of the
   1865  0b06							; stack.
   1866  0b06							;
   1867  0b06		       20 9e 15    iFREE      jsr	GetSizes
   1868  0b09		       20 32 13 	      jsr	pushR0
   1869  0b0c		       4c b9 02 	      jmp	NextIL
   1870  0b0f							;
   1871  0b0f							;=====================================================
   1872  0b0f							; Generate a random number from 0-FFFF and then MOD
   1873  0b0f							; it with the value on top of stack.  Leaves number on
   1874  0b0f							; stack
   1875  0b0f							;
   1876  0b0f		       20 ce 13    iRANDOM    jsr	popR1	;mod value
   1877  0b12							;
   1878  0b12							; If the value is zero, just return a one.
   1879  0b12							;
   1880  0b12		       a5 54		      lda	R1
   1881  0b14		       05 55		      ora	R1+1
   1882  0b16		       f0 4a		      beq	irandom1
   1883  0b18							;
   1884  0b18		       ad 00 26 	      lda	random+1
   1885  0b1b		       8d fd 25 	      sta	rtemp1
   1886  0b1e		       ad ff 25 	      lda	random
   1887  0b21		       0a		      asl
   1888  0b22		       2e fd 25 	      rol	rtemp1
   1889  0b25		       0a		      asl
   1890  0b26		       2e fd 25 	      rol	rtemp1
   1891  0b29		       18		      clc
   1892  0b2a		       6d ff 25 	      adc	random
   1893  0b2d
   1894  0b2d		       48		      pha
   1895  0b2e
   1896  0b2e		       ad fd 25 	      lda	rtemp1
   1897  0b31		       6d 00 26 	      adc	random+1
   1898  0b34		       8d 00 26 	      sta	random+1
   1899  0b37
   1900  0b37		       68		      pla
   1901  0b38
   1902  0b38		       69 11		      adc	#$11
   1903  0b3a		       8d ff 25 	      sta	random
   1904  0b3d		       ad 00 26 	      lda	random+1
   1905  0b40		       69 36		      adc	#$36
   1906  0b42		       8d 00 26 	      sta	random+1
   1907  0b45
   1908  0b45		       ad ff 25 	      lda	random
   1909  0b48		       85 52		      sta	R0
   1910  0b4a		       ad 00 26 	      lda	random+1
   1911  0b4d		       29 7f		      and	#$7f	;make positive
   1912  0b4f		       85 53		      sta	R0+1
   1913  0b51							;
   1914  0b51							; R0 contains the number and R1 contains the max value.
   1915  0b51							;
   1916  0b51		       20 13 07 	      jsr	iDivNoPop
   1917  0b54		       20 37 14 	      jsr	RestoreSigns
   1918  0b57		       a5 56		      lda	MQ
   1919  0b59		       85 52		      sta	R0
   1920  0b5b		       a5 57		      lda	MQ+1
   1921  0b5d		       85 53		      sta	R0+1
   1922  0b5f		       4c ed 06 	      jmp	pushR0nextIl
   1923  0b62				   irandom1
   1924  0b62		       a9 00		      lda	#0
   1925  0b64		       85 53		      sta	R0+1
   1926  0b66		       a9 01		      lda	#1
   1927  0b68		       85 52		      sta	R0
   1928  0b6a		       4c ed 06 	      jmp	pushR0nextIl
   1929  0b6d
   1930  0b6d							; The following replaced by call to division/modulo
   1931  0b6d							;iRANDOM_2	lda	R0
   1932  0b6d							;		cmp	R1
   1933  0b6d							;		bne	iRANDOM_1
   1934  0b6d							;		lda	R0+1
   1935  0b6d							;		cmp	R1+1
   1936  0b6d							;		bne	iRANDOM_1	;need to subtract
   1937  0b6d							;
   1938  0b6d							; Subtract R1 from R0
   1939  0b6d							;
   1940  0b6d							;iRANDOM_sub	sec
   1941  0b6d							;		lda	R0
   1942  0b6d							;		sbc	R1
   1943  0b6d							;		sta	R0
   1944  0b6d							;		lda	R0+1
   1945  0b6d							;		sbc	R1+1
   1946  0b6d							;		sta	R0+1
   1947  0b6d							;		jmp	iRANDOM_2
   1948  0b6d							;
   1949  0b6d							; See if R1 > R0.  If so, branch to subtract.
   1950  0b6d							;
   1951  0b6d							;iRANDOM_1	lda	R0
   1952  0b6d							;		cmp	R1
   1953  0b6d							;		lda	R0+1
   1954  0b6d							;		sbc	R1+1
   1955  0b6d							;		bvc	iRANDOM_4
   1956  0b6d							;		eor	#$80
   1957  0b6d							;iRANDOM_4	bpl	iRANDOM_sub
   1958  0b6d							;
   1959  0b6d							; All done.  Almost.  Add one, then push the result.
   1960  0b6d							;
   1961  0b6d							;irandom1	inc	R0
   1962  0b6d							;		bne	iRANDOM_3
   1963  0b6d							;		inc	R0+1
   1964  0b6d							;iRANDOM_3
   1965  0b6d							;		  jsr	pushR0	;return value
   1966  0b6d							;		jmp	NextIL
   1967  0b6d							;
   1968  0b6d							; Poke a value into a memory location
   1969  0b6d		       8c 05 26    iPOKEMEMORY sty	tempy
   1970  0b70		       20 b6 13 	      jsr	popR0
   1971  0b73		       20 ce 13 	      jsr	popR1
   1972  0b76		       a0 00		      ldy	#0
   1973  0b78		       a5 52		      lda	R0
   1974  0b7a		       91 54		      sta	(R1),y
   1975  0b7c		       ac 05 26 	      ldy	tempy
   1976  0b7f		       4c b9 02 	      jmp	NextIL
   1977  0b82							;
   1978  0b82							; Get a value from a memory location
   1979  0b82							;
   1980  0b82		       8c 05 26    iPEEKMEMORY sty	tempy
   1981  0b85		       20 b6 13 	      jsr	popR0
   1982  0b88		       a0 00		      ldy	#0
   1983  0b8a		       b1 52		      lda	(R0),y
   1984  0b8c		       ac 05 26 	      ldy	tempy
   1985  0b8f		       85 52		      sta	R0
   1986  0b91		       a9 00		      lda	#0
   1987  0b93		       85 53		      sta	R0+1
   1988  0b95		       4c ed 06 	      jmp	pushR0nextIl
   1989  0b98							;
   1990  0b98							; Call to address return what ever is in a to the stack
   1991  0b98							; func2 will load a value into a before the call
   1992  0b98		       20 ce 13    iCallFunc  jsr	popR1
   1993  0b9b		       a5 54		      lda	R1
   1994  0b9d		       20 a9 0b 	      jsr	iCallRtn
   1995  0ba0		       85 52		      sta	R0
   1996  0ba2		       a9 00		      lda	#0
   1997  0ba4		       85 53		      sta	R0+1
   1998  0ba6		       20 ed 06 	      jsr	pushR0nextIl
   1999  0ba9				   iCallRtn
   2000  0ba9		       20 b6 13 	      jsr	popR0
   2001  0bac		       6c 52 00 	      jmp	(R0)
   2002  0baf
   2003  0baf
   2004  0baf							;===========================================jlit======
   2005  0baf							;Get a character from the terminal convert to value
   2006  0baf							;leave the number on top of the stack
   2007  0baf							;
   2008  0baf				   iGETCHAR
   2009  0baf		       20 ee 15 	      jsr	VGETCH
   2010  0bb2					      if	CTMON65
   2011  0bb2		       48		      pha
   2012  0bb3		       20 eb 15 	      jsr	VOUTCH	;echo echo echo
   2013  0bb6		       68		      pla
   2014  0bb7					      endif
   2015  0bb7		       85 52		      sta	R0
   2016  0bb9		       a9 00		      lda	#0
   2017  0bbb		       85 53		      sta	R0+1
   2018  0bbd		       20 32 13 	      jsr	pushR0
   2019  0bc0							;
   2020  0bc0		       4c b9 02 	      jmp	NextIL
   2021  0bc3							;===========================================jusilostintim======
   2022  0bc3							;Put a character to the terminal convert to
   2023  0bc3							;
   2024  0bc3		       20 b6 13    iPUTCHAR   jsr	popR0
   2025  0bc6		       a5 52		      lda	R0
   2026  0bc8		       20 eb 15 	      jsr	VOUTCH
   2027  0bcb		       4c b9 02 	      jmp	NextIL
   2028  0bce							;=====================================================
   2029  0bce							; Put the number on the stack out as hex, suppress leading 0
   2030  0bce				   iHexOut
   2031  0bce		       20 b6 13 	      jsr	popR0
   2032  0bd1		       a5 53		      lda	R0+1
   2033  0bd3		       f0 03		      beq	iHexSecondByte
   2034  0bd5		       20 4a 16 	      jsr	OUTHEX
   2035  0bd8				   iHexSecondByte
   2036  0bd8		       a5 52		      lda	R0
   2037  0bda		       20 4a 16 	      jsr	OUTHEX
   2038  0bdd		       4c b9 02 	      jmp	NextIL
   2039  0be0							;
   2040  0be0							;=====================================================
   2041  0be0							; Replace TOS with its absolute value.
   2042  0be0							;
   2043  0be0		       20 b6 13    iABS       jsr	popR0
   2044  0be3		       a5 53		      lda	R0+1
   2045  0be5		       10 10		      bpl	iABS_1	;already positive
   2046  0be7		       49 ff		      eor	#$ff
   2047  0be9		       85 53		      sta	R0+1
   2048  0beb		       a5 52		      lda	R0
   2049  0bed		       49 ff		      eor	#$ff
   2050  0bef		       85 52		      sta	R0
   2051  0bf1		       e6 52		      inc	R0
   2052  0bf3		       d0 02		      bne	iABS_1
   2053  0bf5		       e6 53		      inc	R0+1
   2054  0bf7		       4c ed 06    iABS_1     jmp	pushR0nextIl
   2055  0bfa
   2056  0bfa							;
   2057  0bfa							;================================================================
   2058  0bfa							; The set of logical operators
   2059  0bfa				   iLogAnd
   2060  0bfa		       20 b6 13 	      jsr	popR0
   2061  0bfd		       20 ce 13 	      jsr	popR1
   2062  0c00		       a5 52		      lda	R0
   2063  0c02		       25 54		      and	R1
   2064  0c04		       85 52		      sta	R0
   2065  0c06		       a5 53		      lda	R0+1
   2066  0c08		       25 55		      and	R1+1
   2067  0c0a		       85 53		      sta	R0+1
   2068  0c0c		       4c ed 06 	      jmp	pushR0nextIl
   2069  0c0f				   iLogOr
   2070  0c0f		       20 b6 13 	      jsr	popR0
   2071  0c12		       20 ce 13 	      jsr	popR1
   2072  0c15		       a5 52		      lda	R0
   2073  0c17		       05 54		      ora	R1
   2074  0c19		       85 52		      sta	R0
   2075  0c1b		       a5 53		      lda	R0+1
   2076  0c1d		       05 55		      ora	R1+1
   2077  0c1f		       85 53		      sta	R0+1
   2078  0c21		       4c ed 06 	      jmp	pushR0nextIl
   2079  0c24				   iLogXor
   2080  0c24		       20 b6 13 	      jsr	popR0
   2081  0c27		       20 ce 13 	      jsr	popR1
   2082  0c2a		       a5 52		      lda	R0
   2083  0c2c		       45 54		      eor	R1
   2084  0c2e		       85 52		      sta	R0
   2085  0c30		       a5 53		      lda	R0+1
   2086  0c32		       45 55		      eor	R1+1
   2087  0c34		       85 53		      sta	R0+1
   2088  0c36		       4c ed 06 	      jmp	pushR0nextIl
   2089  0c39				   iLogNot
   2090  0c39		       20 b6 13 	      jsr	popR0
   2091  0c3c		       a5 52		      lda	R0
   2092  0c3e		       49 ff		      eor	#$FF
   2093  0c40		       85 52		      sta	R0
   2094  0c42		       a5 53		      lda	R0+1
   2095  0c44		       49 ff		      eor	#$FF
   2096  0c46		       85 53		      sta	R0+1
   2097  0c48		       4c ed 06 	      jmp	pushR0nextIl
   2098  0c4b
   2099  0c4b				   iTruth
   2100  0c4b		       a9 ff		      lda	#$FF
   2101  0c4d		       85 52		      sta	R0
   2102  0c4f		       85 53		      sta	R0+1
   2103  0c51		       4c ed 06 	      jmp	pushR0nextIl
   2104  0c54				   iFalse
   2105  0c54		       a9 00		      lda	#$00
   2106  0c56		       85 52		      sta	R0
   2107  0c58		       85 53		      sta	R0+1
   2108  0c5a		       4c ed 06 	      jmp	pushR0nextIl
   2109  0c5d
   2110  0c5d							;================================================================
   2111  0c5d							;Set the IRQ service rtn line number
   2112  0c5d							;
   2113  0c5d		       78	   iSetIrq    sei		; disable the interupts
   2114  0c5e		       a9 00		      lda	#0	; Zero the Status flag
   2115  0c60		       8d b2 1c 	      sta	IRQStatus
   2116  0c63		       20 b6 13 	      jsr	popR0	; get the line number
   2117  0c66		       a5 52		      lda	R0
   2118  0c68		       05 53		      ora	R0+1
   2119  0c6a		       f0 20		      beq	iSetExt	; if it is zero disable all
   2120  0c6c		       20 4c 13 	      jsr	pushLN	; Save the current line pointer
   2121  0c6f		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2122  0c71		       4c ff 0a 	      jmp	ErrStkOver	; Check if there was an error
   2123  0c74				   iSetIrqOk
   2124  0c74		       20 1b 11 	      jsr	findLine	; Find the IRQ func Line Pointer
   2125  0c77		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2126  0c79		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2127  0c7b		       8d b5 1c 	      sta	IRQEntry+1
   2128  0c7e		       a5 4f		      lda	CURPTR
   2129  0c80		       8d b4 1c 	      sta	IRQEntry
   2130  0c83		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2131  0c85		       8d b2 1c 	      sta	IRQStatus
   2132  0c88		       20 71 13 	      jsr	popLN	; Restore the old line number
   2133  0c8b		       58		      cli		; Enable the interupts
   2134  0c8c		       4c b9 02    iSetExt    jmp	NextIL
   2135  0c8f
   2136  0c8f		       20 71 13    iSetIrqErr jsr	popLN
   2137  0c92		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2138  0c94		       a9 00		      lda	#0
   2139  0c96		       4c 02 06 	      jmp	iErr2
   2140  0c99							;
   2141  0c99		       20 b6 13    iTRACEPROG jsr	popR0
   2142  0c9c		       a5 52		      lda	R0
   2143  0c9e		       85 40		      sta	ILTrace
   2144  0ca0		       4c b9 02 	      jmp	NextIL
   2145  0ca3
   2146  0ca3							;=====================================================
   2147  0ca3							; Define start of non page zero data
   2148 U260e ????				      seg.u	TBData
   2149 U1ca1					      org	PROGEND
   2150 U1ca1							;=================================================================
   2151 U1ca1							;
------- FILE gosub.asm LEVEL 2 PASS 6
      0 U1ca1					      include	"gosub.asm"
      1  0ca3					      seg	Code
      2  0ca3
      3  0ca3							; Gosub and return related functions
      4  0ca3							;==========================================================
      5  0ca3							; Push the current math stack frame onto the gosub stack
      6  0ca3				   iPushMathStack
      7  0ca3		       98		      tya
      8  0ca4		       48		      pha
      9  0ca5		       a4 4d		      ldy	GOSUBSTACKPTR
     10  0ca7		       a5 4a		      lda	MATHSTACKPTR
     11  0ca9		       91 4b		      sta	(GOSUBSTACK),y
     12  0cab		       a9 00		      lda	#0
     13  0cad		       c8		      iny
     14  0cae		       91 4b		      sta	(GOSUBSTACK),y
     15  0cb0		       c8		      iny
     16  0cb1		       91 4b		      sta	(GOSUBSTACK),y
     17  0cb3		       c8		      iny
     18  0cb4		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  0cb6		       91 4b		      sta	(GOSUBSTACK),y
     20  0cb8		       c8		      iny
     21  0cb9		       84 4d		      sty	GOSUBSTACKPTR
     22  0cbb		       68		      pla
     23  0cbc		       a8		      tay
     24  0cbd		       4c b9 02 	      jmp	NextIL
     25  0cc0							;
     26  0cc0							;==========================================================
     27  0cc0							; Increment parameter count. Assume Stack frame is top of stack
     28  0cc0				   iIncParmCount
     29  0cc0		       98		      tya
     30  0cc1		       48		      pha
     31  0cc2		       a4 4d		      ldy	GOSUBSTACKPTR
     32  0cc4		       88		      dey
     33  0cc5		       88		      dey
     34  0cc6		       88		      dey
     35  0cc7		       b1 4b		      lda	(GOSUBSTACK),y
     36  0cc9		       aa		      tax
     37  0cca		       e8		      inx
     38  0ccb		       8a		      txa
     39  0ccc		       91 4b		      sta	(GOSUBSTACK),y
     40  0cce		       68		      pla
     41  0ccf		       a8		      tay
     42  0cd0		       4c b9 02 	      jmp	NextIL
     43  0cd3							;
     44  0cd3							;==========================================================
     45  0cd3							;Restore the math stack frame
     46  0cd3		       20 d9 0c    iPopMathStack jsr	PopMathStackNow
     47  0cd6		       4c b9 02 	      jmp	NextIL
     48  0cd9
     49  0cd9				   PopMathStackNow
     50  0cd9		       98		      tya
     51  0cda		       48		      pha
     52  0cdb
     53  0cdb		       a4 4d		      ldy	GOSUBSTACKPTR
     54  0cdd		       88		      dey
     55  0cde		       b1 4b		      lda	(GOSUBSTACK),y
     56  0ce0		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  0ce2		       d0 09		      bne	iPopMathStackNoFrame
     58  0ce4		       88		      dey
     59  0ce5		       88		      dey
     60  0ce6		       88		      dey
     61  0ce7		       b1 4b		      lda	(GOSUBSTACK),y
     62  0ce9		       85 4a		      sta	MATHSTACKPTR
     63  0ceb		       84 4d		      sty	GOSUBSTACKPTR
     64  0ced
     65  0ced				   iPopMathStackNoFrame
     66  0ced
     67  0ced		       68		      pla
     68  0cee		       a8		      tay
     69  0cef		       60		      rts
     70  0cf0
     71  0cf0
     72  0cf0							;==========================================================
     73  0cf0							; Push the current math stack information onto the gosub stack
     74  0cf0				   iSaveMathStack
     75  0cf0		       98		      tya
     76  0cf1		       48		      pha
     77  0cf2		       a4 4d		      ldy	GOSUBSTACKPTR
     78  0cf4		       a5 4a		      lda	MATHSTACKPTR
     79  0cf6		       91 4b		      sta	(GOSUBSTACK),y
     80  0cf8		       a5 48		      lda	MATHSTACK
     81  0cfa		       c8		      iny
     82  0cfb
     83  0cfb		       91 4b		      sta	(GOSUBSTACK),y
     84  0cfd		       c8		      iny
     85  0cfe
     86  0cfe		       a5 49		      lda	MATHSTACK+1
     87  0d00		       91 4b		      sta	(GOSUBSTACK),y
     88  0d02		       c8		      iny
     89  0d03
     90  0d03		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  0d05		       91 4b		      sta	(GOSUBSTACK),y
     92  0d07		       c8		      iny
     93  0d08
     94  0d08		       84 4d		      sty	GOSUBSTACKPTR
     95  0d0a		       68		      pla
     96  0d0b		       a8		      tay
     97  0d0c		       4c b9 02 	      jmp	NextIL
     98  0d0f							;
     99  0d0f							;==========================================================
    100  0d0f							;Restore the math stack information from the gosub stack
    101  0d0f				   iRestoreMathStack
    102  0d0f		       98		      tya
    103  0d10		       48		      pha
    104  0d11
    105  0d11		       a5 4a		      lda	MATHSTACKPTR
    106  0d13		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  0d15
    108  0d15		       a4 4d		      ldy	GOSUBSTACKPTR
    109  0d17		       88		      dey
    110  0d18		       b1 4b		      lda	(GOSUBSTACK),y
    111  0d1a		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  0d1c		       d0 16		      bne	iPopMathStack_Err
    113  0d1e		       88		      dey
    114  0d1f		       b1 4b		      lda	(GOSUBSTACK),y
    115  0d21		       85 49		      sta	MATHSTACK+1
    116  0d23		       88		      dey
    117  0d24		       b1 4b		      lda	(GOSUBSTACK),y
    118  0d26		       85 48		      sta	MATHSTACK
    119  0d28		       88		      dey
    120  0d29		       b1 4b		      lda	(GOSUBSTACK),y
    121  0d2b		       85 4a		      sta	MATHSTACKPTR
    122  0d2d		       84 4d		      sty	GOSUBSTACKPTR
    123  0d2f		       68		      pla
    124  0d30		       a8		      tay
    125  0d31		       4c b9 02 	      jmp	NextIL
    126  0d34
    127  0d34				   iPopMathStack_Err
    128  0d34		       a9 00		      lda	#0
    129  0d36		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  0d38		       4c 02 06 	      jmp	iErr2
    131  0d3b							;=========================================
    132  0d3b							; For functions and tasks the variable address of # means
    133  0d3b							; a passed parameter so #[0] is the first parameter etc
    134  0d3b							; will try for a better way later
    135  0d3b
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  0d3b					      include	"tasks.asm"
      1  0d3b							;=====================================================
      2  0d3b							; Tiny Basic IL task management
      3  0d3b							; Data required by task management
      4  0d3b							; currently each context is about 30 bytes and is swapped
      5  0d3b							; into and out of page zero on each task switch....
      6  0d3b							; LOL yes it is slow, but works for this itteration.
      7  0d3b							;
      8  0d3b
      9  0d3b					      Seg	Code
     10  0d3b							;=====================================================
     11  0d3b							; Sets the pointers to the math,IL and gosub stacks
     12  0d3b							; Creates the initial Context for each task slot
     13  0d3b				   taskSetStacks
     14  0d3b		       a9 b4		      lda	#mathStack&$FF
     15  0d3d		       85 48		      sta	MATHSTACK
     16  0d3f		       a9 1d		      lda	#mathStack>>8
     17  0d41		       85 49		      sta	MATHSTACK+1
     18  0d43
     19  0d43		       a9 44		      lda	#ilStack&$ff
     20  0d45		       85 45		      sta	ILSTACK
     21  0d47		       a9 1f		      lda	#ilStack>>8
     22  0d49		       85 46		      sta	ILSTACK+1
     23  0d4b
     24  0d4b		       a9 d4		      lda	#gosubStack&$FF
     25  0d4d		       85 4b		      sta	GOSUBSTACK
     26  0d4f		       a9 20		      lda	#gosubStack>>8
     27  0d51		       85 4c		      sta	GOSUBSTACK+1
     28  0d53
     29  0d53		       a9 54		      lda	#variableStack&$FF
     30  0d55		       85 41		      sta	VARIABLES
     31  0d57		       a9 23		      lda	#variableStack>>8
     32  0d59		       85 42		      sta	VARIABLES+1
     33  0d5b		       a2 0a		      ldx	#TASKCOUNT
     34  0d5d		       a0 00		      ldy	#0
     35  0d5f		       20 b4 0f 	      jsr	ContextSave
     36  0d62
     37  0d62		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  0d64		       b0 3a		      bcs	taskSetDone
     39  0d66
     40  0d66		       a5 4b		      lda	GOSUBSTACK
     41  0d68		       18		      clc
     42  0d69		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  0d6b		       85 4b		      sta	GOSUBSTACK
     44  0d6d		       a5 4c		      lda	GOSUBSTACK+1
     45  0d6f		       69 00		      adc	#0
     46  0d71		       85 4c		      sta	GOSUBSTACK+1
     47  0d73
     48  0d73		       a5 45		      lda	ILSTACK	; must be less than 256
     49  0d75		       18		      clc
     50  0d76		       69 28		      adc	#ILSTACKSIZE*2
     51  0d78		       85 45		      sta	ILSTACK
     52  0d7a		       a5 46		      lda	ILSTACK+1
     53  0d7c		       69 00		      adc	#0
     54  0d7e		       85 46		      sta	ILSTACK+1
     55  0d80
     56  0d80		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  0d82		       18		      clc
     58  0d83		       69 28		      adc	#MATHSTACKSIZE*2
     59  0d85		       85 48		      sta	MATHSTACK
     60  0d87		       a5 49		      lda	MATHSTACK+1
     61  0d89		       69 00		      adc	#0
     62  0d8b		       85 49		      sta	MATHSTACK+1
     63  0d8d
     64  0d8d		       a5 41		      lda	VARIABLES	; must be less than 256
     65  0d8f		       18		      clc
     66  0d90		       69 36		      adc	#VARIABLESSIZE*2
     67  0d92		       85 41		      sta	VARIABLES
     68  0d94		       a5 42		      lda	VARIABLES+1
     69  0d96		       69 00		      adc	#0
     70  0d98		       85 42		      sta	VARIABLES+1
     71  0d9a
     72  0d9a		       20 b4 0f 	      jsr	ContextSave
     73  0d9d		       4c 62 0d 	      jmp	taskSetLoop
     74  0da0
     75  0da0				   taskSetDone
     76  0da0		       a0 00		      ldy	#0	; reload the main loop context
     77  0da2		       20 c3 0f 	      jsr	ContextLoad
     78  0da5		       60		      rts
     79  0da6							;
     80  0da6							;=====================================================
     81  0da6							; In some error cases the math stacks may be left pointing to the wrong stack
     82  0da6							; This function will reset those stack addresses but not the actual pointer
     83  0da6				   taskResetStacks
     84  0da6		       a0 00		      ldy	#0
     85  0da8		       20 c3 0f 	      jsr	ContextLoad
     86  0dab		       4c 3b 0d 	      jmp	taskSetStacks
     87  0dae							;
     88  0dae							;=====================================================
     89  0dae							; Clear all task entries and task stacks
     90  0dae		       98	   taskReset  tya		; Save Y
     91  0daf		       48		      pha
     92  0db0		       a9 01		      lda	#1
     93  0db2		       8d b3 1d 	      sta	taskCounter	; Set number of active tasks to 1
     94  0db5		       ac b6 1c 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  0db8		       c0 00		      cpy	#0	; check if we are the main context
     96  0dba		       f0 08		      beq	taskResetCont	; if we are just continue
     97  0dbc
     98  0dbc		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  0dbe		       8c b6 1c 	      sty	taskPtr
    100  0dc1		       20 c3 0f 	      jsr	ContextLoad	; load the System Task context
    101  0dc4				   taskResetCont
    102  0dc4		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  0dc6
    104  0dc6				   taskResetLoop
    105  0dc6		       a9 00		      lda	#TASKINACTIVE
    106  0dc8		       99 b7 1c 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  0dcb		       18		      clc
    108  0dcc		       98		      tya
    109  0dcd		       69 19		      adc	#CONTEXTLEN+1
    110  0dcf		       a8		      tay
    111  0dd0		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  0dd2		       90 f2		      bcc	taskResetLoop	; Go for more
    113  0dd4
    114  0dd4				   taskResetComplete
    115  0dd4
    116  0dd4		       68		      pla		; Restore y
    117  0dd5		       a8		      tay
    118  0dd6		       60		      rts
    119  0dd7
    120  0dd7							;
    121  0dd7							;======================================================
    122  0dd7							; iTaskSwitch	 switch to new task if not interrupt and
    123  0dd7							;		 count is exceded for task time slice gets here
    124  0dd7							;		 when time slice has reached zero
    125  0dd7							;
    126  0dd7		       98	   iTaskSwitch tya
    127  0dd8		       48		      pha
    128  0dd9		       ad b2 1d 	      lda	taskResetValue	; Always reset the counter value
    129  0ddc		       8d b1 1d 	      sta	taskCurrentCycles	; Update the counter with the new value
    130  0ddf
    131  0ddf		       ad b3 1c 	      lda	IRQPending	; Skip this if we are processing an irq
    132  0de2		       05 60		      ora	taskIOPending	; If set then don't switch
    133  0de4		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    134  0de6
    135  0de6		       ad b3 1d    iTaskMain  lda	taskCounter	; Number of tasks
    136  0de9		       c9 01		      cmp	#1	; if there is only one task must be main
    137  0deb		       d0 07		      bne	itasknext	; if it some other number continue to next
    138  0ded
    139  0ded		       ac b6 1c 	      ldy	taskPtr	; check if we have not just ended some other task
    140  0df0		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    141  0df2		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    142  0df4							;
    143  0df4							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    144  0df4							;
    145  0df4				   itasknext
    146  0df4		       ac b6 1c 	      ldy	taskPtr
    147  0df7		       20 b4 0f 	      jsr	ContextSave	; Save the current context, y points to next context
    148  0dfa				   itaskLoop
    149  0dfa		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    150  0dfc		       90 04		      bcc	iTaskNextChk
    151  0dfe
    152  0dfe		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    153  0e00		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    154  0e02
    155  0e02				   iTaskNextChk
    156  0e02		       b9 b7 1c 	      lda	taskTable,y	; there is always at least one entry in table
    157  0e05		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    158  0e07		       18	   iTaskNext  clc
    159  0e08		       98		      tya
    160  0e09		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    161  0e0b		       a8		      tay
    162  0e0c		       4c fa 0d 	      jmp	itaskLoop	; Check for busy entry
    163  0e0f
    164  0e0f		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    165  0e11		       59 b7 1c 	      eor	taskTable,y	; Check for anything waiting io
    166  0e14		       d0 f1		      bne	iTaskNext
    167  0e16		       20 c3 0f 	      jsr	ContextLoad	; load the next context
    168  0e19		       8c b6 1c 	      sty	taskPtr	; update the task pointer
    169  0e1c
    170  0e1c				   iTaskSwitchDone
    171  0e1c		       68		      pla
    172  0e1d		       a8		      tay
    173  0e1e		       60		      rts
    174  0e1f							;
    175  0e1f							;================================================================
    176  0e1f							; Task Set task number to line number to start
    177  0e1f							; Task Table structure:
    178  0e1f							;    byte 0	-   Active inactive
    179  0e1f							;    byte 1-2	-   Basic code line pointer
    180  0e1f							;    byte 3	-   Offset on current line
    181  0e1f		       98	   iTaskSet   tya		;preserve Y
    182  0e20		       48		      pha		; push a
    183  0e21
    184  0e21		       20 b6 13 	      jsr	popR0	; Get the line number to be saved
    185  0e24
    186  0e24		       ac b6 1c 	      ldy	taskPtr	; find out where we are
    187  0e27		       20 b4 0f 	      jsr	ContextSave	; Save the current context
    188  0e2a
    189  0e2a							;Find the pointer to the line we need to start at
    190  0e2a		       20 1b 11 	      jsr	findLine	; Get the offset of the line to start task at
    191  0e2d		       f0 0b		      beq	iTaskCont
    192  0e2f
    193  0e2f		       ac b6 1c 	      ldy	taskPtr	; Restore the original Context Error Exit
    194  0e32		       20 c3 0f 	      jsr	ContextLoad
    195  0e35
    196  0e35		       68		      pla		; pop a - exit
    197  0e36		       a8		      tay
    198  0e37		       4c 8f 0c 	      jmp	iSetIrqErr	; Bad line number provided
    199  0e3a
    200  0e3a				   iTaskCont
    201  0e3a		       20 86 0f 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    202  0e3d		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    203  0e3f
    204  0e3f		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    205  0e41		       99 b7 1c 	      sta	taskTable,y	; new task as active
    206  0e44
    207  0e44		       a5 4f		      lda	CURPTR
    208  0e46		       48		      pha		; push a
    209  0e47		       a5 50		      lda	CURPTR+1
    210  0e49		       48		      pha		; push a
    211  0e4a
    212  0e4a		       20 c3 0f 	      jsr	ContextLoad	; load the context of the new task
    213  0e4d
    214  0e4d		       68		      pla		; pop a
    215  0e4e		       85 50		      sta	CURPTR+1
    216  0e50		       68		      pla		; pop a
    217  0e51		       85 4f		      sta	CURPTR
    218  0e53		       a9 03		      lda	#3	; Offset to first instruction
    219  0e55		       85 51		      sta	CUROFF
    220  0e57
    221  0e57		       a9 00		      lda	#0
    222  0e59		       85 47		      sta	ILSTACKPTR
    223  0e5b		       85 4a		      sta	MATHSTACKPTR
    224  0e5d		       85 4d		      sta	GOSUBSTACKPTR
    225  0e5f		       a9 40		      lda	#GOSUBSTACKSIZE*4
    226  0e61		       85 4e		      sta	MESSAGEPTR
    227  0e63
    228  0e63		       20 24 09 	      jsr	subVINIT	; Clear the variables
    229  0e66
    230  0e66		       a9 26		      lda	#STMT&$FF
    231  0e68		       85 43		      sta	ILPC
    232  0e6a		       a9 18		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    233  0e6c		       85 44		      sta	ILPC+1
    234  0e6e
    235  0e6e		       98		      tya		; Save the new context offset to return to user
    236  0e6f		       48		      pha		; push a
    237  0e70
    238  0e70		       20 b4 0f    itaskSetSave jsr	ContextSave	; save the updated context
    239  0e73		       ee b3 1d 	      inc	taskCounter	; Update the number of Tasks running
    240  0e76
    241  0e76		       ac b6 1c 	      ldy	taskPtr
    242  0e79		       20 c3 0f 	      jsr	ContextLoad	; restore the original context
    243  0e7c
    244  0e7c		       a9 00		      lda	#0	; Set the R0 upper to zero
    245  0e7e		       85 53		      sta	R0+1
    246  0e80		       68		      pla		; Get the task pid we stored				 ; pop a
    247  0e81		       85 52		      sta	R0	; Get the table entry value
    248  0e83
    249  0e83		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    250  0e84		       a8		      tay
    251  0e85
    252  0e85		       4c ed 06 	      jmp	pushR0nextIl	; Push R0 and continue
    253  0e88				   iTaskNoEmpty
    254  0e88		       ac b6 1c 	      ldy	taskPtr
    255  0e8b		       20 c3 0f 	      jsr	ContextLoad
    256  0e8e
    257  0e8e		       68		      pla		; pop a    -- exit
    258  0e8f		       a8		      tay
    259  0e90
    260  0e90		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    261  0e92		       a9 00		      lda	#0
    262  0e94		       4c 02 06 	      jmp	iErr2
    263  0e97							;
    264  0e97							;===============================================================
    265  0e97							; Run the task whos PID is on the stack, preserve the stack
    266  0e97							;
    267  0e97				   iTaskEnable
    268  0e97		       98		      tya
    269  0e98		       48		      pha
    270  0e99		       20 ce 13 	      jsr	popR1
    271  0e9c		       20 9c 13 	      jsr	pushR1
    272  0e9f		       20 b9 10 	      jsr	ipc_getcontext	; get context pointer into mq
    273  0ea2		       a0 00		      ldy	#0
    274  0ea4		       b1 56		      lda	(MQ),y
    275  0ea6		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    276  0ea8		       09 80		      ora	#TASKACTIVE
    277  0eaa		       91 56		      sta	(MQ),y
    278  0eac		       68		      pla
    279  0ead		       a8		      tay
    280  0eae		       4c b9 02 	      jmp	NextIL
    281  0eb1
    282  0eb1							;
    283  0eb1							;===============================================================
    284  0eb1							; Suspend the task whos PID  is on the stack, preserve the stack
    285  0eb1							;
    286  0eb1				   iTaskSuspend
    287  0eb1		       98		      tya
    288  0eb2		       48		      pha
    289  0eb3		       20 ce 13 	      jsr	popR1
    290  0eb6		       20 9c 13 	      jsr	pushR1
    291  0eb9		       20 b9 10 	      jsr	ipc_getcontext	; get context pointer into mq
    292  0ebc		       a0 00		      ldy	#0
    293  0ebe		       b1 56		      lda	(MQ),y
    294  0ec0		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    295  0ec2		       09 80		      ora	#TASKACTIVE
    296  0ec4		       68		      pla
    297  0ec5		       a8		      tay
    298  0ec6		       4c b9 02 	      jmp	NextIL
    299  0ec9
    300  0ec9							;================================================================
    301  0ec9							; Returns task Status
    302  0ec9				   iTaskStat
    303  0ec9		       98		      tya
    304  0eca		       48		      pha
    305  0ecb		       20 dd 0e 	      jsr	iTaskValid	; returns pointer to task entry
    306  0ece		       b9 b7 1c 	      lda	taskTable,y
    307  0ed1		       f0 05		      beq	iTaskStatExit
    308  0ed3		       68		      pla
    309  0ed4		       a8		      tay
    310  0ed5		       4c 4b 0c 	      jmp	iTruth
    311  0ed8				   iTaskStatExit
    312  0ed8		       68		      pla
    313  0ed9		       a8		      tay
    314  0eda		       4c 54 0c 	      jmp	iFalse
    315  0edd
    316  0edd							;
    317  0edd							;================================================================
    318  0edd							; Validate the task number on top of the stack
    319  0edd							; on exit y points to the requested task entry
    320  0edd							;
    321  0edd		       20 b6 13    iTaskValid jsr	popR0	; get result of the multiply
    322  0ee0		       a5 53		      lda	R0+1
    323  0ee2		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    324  0ee4		       a5 52		      lda	R0
    325  0ee6		       c9 fa		      cmp	#TASKTABLELEN
    326  0ee8		       90 09		      bcc	iTaskIsValid
    327  0eea
    328  0eea		       68	   iTaskValidErr pla		;remove return address
    329  0eeb		       68		      pla
    330  0eec		       a2 10		      ldx	#ERR_INVALID_PID
    331  0eee		       a9 00		      lda	#0
    332  0ef0		       4c 02 06 	      jmp	iErr2
    333  0ef3
    334  0ef3		       a8	   iTaskIsValid tay
    335  0ef4		       60		      rts
    336  0ef5							;
    337  0ef5							;================================================================
    338  0ef5							; Kill a running task, do nothing if already stopped
    339  0ef5		       20 dd 0e    iTaskKill  jsr	iTaskValid
    340  0ef8		       a9 00		      lda	#0
    341  0efa		       99 b7 1c 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    342  0efd							;
    343  0efd							;================================================================
    344  0efd							;Skip to next task
    345  0efd				   iNTask
    346  0efd		       a9 01		      lda	#1
    347  0eff		       8d b1 1d 	      sta	taskCurrentCycles
    348  0f02		       4c b9 02 	      jmp	NextIL
    349  0f05							;
    350  0f05							;=======================================================
    351  0f05							; Wait for a task to complete
    352  0f05				   iWTASK
    353  0f05		       20 d6 10 	      jsr	getILByte
    354  0f08		       85 5e		      sta	offset
    355  0f0a							;
    356  0f0a		       20 20 13 	      jsr	saveIL	;in case of failure
    357  0f0d
    358  0f0d		       20 dd 0e 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    359  0f10		       b9 b7 1c 	      lda	taskTable,y
    360  0f13		       d0 03		      bne	iWTASKWAIT
    361  0f15				   iWTASKEXITED
    362  0f15		       4c b9 02 	      jmp	NextIL
    363  0f18				   iWTASKWAIT
    364  0f18		       20 32 13 	      jsr	pushR0	; Push R0 back onto the stack
    365  0f1b		       a9 01		      lda	#1
    366  0f1d		       8d b1 1d 	      sta	taskCurrentCycles	; Give up the cycles
    367  0f20
    368  0f20		       20 29 13 	      jsr	restoreIL
    369  0f23		       4c b1 0a 	      jmp	tstBranch
    370  0f26							;
    371  0f26							;=======================================================
    372  0f26							; Set task io lock
    373  0f26		       e6 60	   iStartIO   inc	taskIOPending
    374  0f28		       4c b9 02 	      jmp	NextIL
    375  0f2b							;
    376  0f2b							;=======================================================
    377  0f2b							; Release the io lock
    378  0f2b		       a5 60	   iEndIO     lda	taskIOPending
    379  0f2d		       f0 02		      beq	iEndIOExit
    380  0f2f		       c6 60		      dec	taskIOPending
    381  0f31		       4c b9 02    iEndIOExit jmp	NextIL
    382  0f34							;
    383  0f34							;===============================================================
    384  0f34							; Return the task PID
    385  0f34				   iTASKPID
    386  0f34		       a9 00		      lda	#0
    387  0f36		       85 53		      sta	R0+1
    388  0f38		       ad b6 1c 	      lda	taskPtr
    389  0f3b		       85 52		      sta	R0
    390  0f3d		       4c ed 06 	      jmp	pushR0nextIl
    391  0f40							;
    392  0f40							;================================================================
    393  0f40							; Terminate a task
    394  0f40		       ac b6 1c    iETask     ldy	taskPtr
    395  0f43		       c0 00		      cpy	#0
    396  0f45		       d0 03		      bne	iETaskCont
    397  0f47		       4c eb 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    398  0f4a				   iETaskCont
    399  0f4a		       a9 00		      lda	#TASKINACTIVE
    400  0f4c		       99 b7 1c 	      sta	taskTable,y	; mark entry as free
    401  0f4f		       ce b3 1d 	      dec	taskCounter	; reduce the number of active tasks
    402  0f52		       a9 01		      lda	#1
    403  0f54		       8d b1 1d 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    404  0f57		       20 a1 0f 	      jsr	TaskSetExitCode
    405  0f5a				   iETaskExit
    406  0f5a		       4c b9 02 	      jmp	NextIL
    407  0f5d							;================================================================
    408  0f5d							; make the current tasks math stack equal another tasks stack
    409  0f5d							; The task to get is stored on the math stack
    410  0f5d
    411  0f5d				   iTaskGetMathStack
    412  0f5d		       20 80 16 	      jsr	CopyStackR1	; Get the top of stack to R1
    413  0f60		       20 b9 10 	      jsr	ipc_getcontext	; MQ now has the context address
    414  0f63		       a0 0a		      ldy	#MATHSTACKPTRPOS
    415  0f65		       b1 56		      lda	(MQ),y
    416  0f67		       85 4a		      sta	MATHSTACKPTR
    417  0f69		       a0 08		      ldy	#MATHSTACKPOS
    418  0f6b		       b1 56		      lda	(MQ),y
    419  0f6d		       85 48		      sta	MATHSTACK
    420  0f6f		       c8		      iny
    421  0f70		       b1 56		      lda	(MQ),y
    422  0f72		       85 49		      sta	MATHSTACK+1
    423  0f74		       4c b9 02 	      jmp	NextIL
    424  0f77							;==================================================================
    425  0f77							; Updates the tasks math stack pointer with contents of R2
    426  0f77							; PID is on top of the stack
    427  0f77				   iTaskPutMathPtr
    428  0f77		       20 80 16 	      jsr	CopyStackR1	; Get the top of stack to R1
    429  0f7a		       20 b9 10 	      jsr	ipc_getcontext	; MQ now has the context address
    430  0f7d		       a5 58		      lda	R2
    431  0f7f		       a0 0a		      ldy	#MATHSTACKPTRPOS
    432  0f81		       91 56		      sta	(MQ),y
    433  0f83		       4c b9 02 	      jmp	NextIL
    434  0f86							;================================================================
    435  0f86							; Find an empty slot in the taskTable
    436  0f86							; Return the index in y
    437  0f86							; on exit   c set if an empty slot is found
    438  0f86							;	     c clear if not found
    439  0f86							;================================================================
    440  0f86							;
    441  0f86		       ad b3 1d    TaskEmpty  lda	taskCounter
    442  0f89		       c9 0a		      cmp	#TASKCOUNT
    443  0f8b		       b0 10		      bcs	TaskNoSlot
    444  0f8d		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    445  0f8f				   TaskLoop
    446  0f8f		       b9 b7 1c 	      lda	taskTable,y
    447  0f92		       f0 0b		      beq	TaskEmptyFnd
    448  0f94		       98		      tya
    449  0f95		       18		      clc
    450  0f96		       69 19		      adc	#CONTEXTLEN+1
    451  0f98		       a8		      tay
    452  0f99		       c0 fa		      cpy	#TASKTABLELEN
    453  0f9b		       90 f2		      bcc	TaskLoop	; Y is never zero
    454  0f9d				   TaskNoSlot
    455  0f9d		       18		      clc
    456  0f9e		       60		      rts
    457  0f9f				   TaskEmptyFnd
    458  0f9f		       38		      sec
    459  0fa0		       60		      rts
    460  0fa1							;====================================================
    461  0fa1							; Set the task exit code called from the return command
    462  0fa1							; on entry stack top hold exit value
    463  0fa1				   TaskSetExitCode
    464  0fa1		       98		      tya
    465  0fa2		       48		      pha
    466  0fa3		       20 b6 13 	      jsr	popR0
    467  0fa6		       a0 19		      ldy	#TASKEXITCODE
    468  0fa8		       a5 52		      lda	R0
    469  0faa		       91 41		      sta	(VARIABLES),y
    470  0fac		       c8		      iny
    471  0fad		       a5 53		      lda	R0+1
    472  0faf		       91 41		      sta	(VARIABLES),y
    473  0fb1		       68		      pla
    474  0fb2		       98		      tya
    475  0fb3		       60		      rts
    476  0fb4
    477  0fb4							;
    478  0fb4							;=====================================================
    479  0fb4							; Save Context Store the context to the TASK Table
    480  0fb4							; on entry y contains the task table entry to save to
    481  0fb4							; on exit y points to next task table entry
    482  0fb4							;	   x contains the number of bytes copied
    483  0fb4		       a2 00	   ContextSave ldx	#0
    484  0fb6		       c8		      iny		;inc past the task flags
    485  0fb7		       b5 41	   ContextSvLoop lda	CONTEXT,x
    486  0fb9		       99 b7 1c 	      sta	taskTable,y
    487  0fbc		       c8		      iny
    488  0fbd		       e8		      inx
    489  0fbe		       e0 18		      cpx	#CONTEXTLEN
    490  0fc0		       90 f5		      bcc	ContextSvLoop
    491  0fc2		       60		      rts
    492  0fc3							;
    493  0fc3							; Load Context transfer context from task table to the Current Context
    494  0fc3							; on entry y contains the task table entry to transfer
    495  0fc3							; on exit y points to the original task table entry
    496  0fc3							;	   x contains the number of byts copied
    497  0fc3		       98	   ContextLoad tya
    498  0fc4		       48		      pha
    499  0fc5		       a2 00		      ldx	#0
    500  0fc7		       c8		      iny		;inc past the task flags
    501  0fc8		       b9 b7 1c    ContextLDLoop lda	taskTable,y
    502  0fcb		       95 41		      sta	CONTEXT,x
    503  0fcd		       c8		      iny
    504  0fce		       e8		      inx
    505  0fcf		       e0 18		      cpx	#CONTEXTLEN
    506  0fd1		       90 f5		      bcc	ContextLDLoop
    507  0fd3		       68		      pla
    508  0fd4		       a8		      tay
    509  0fd5		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  0fd6					      include	"ipc.asm"
      1  0fd6							;======================================================
      2  0fd6							; Inter process communications.
      3  0fd6							; Tasks may write/read integer messages among
      4  0fd6							; them selves.
      5  0fd6							; This uses each tasks gosub stack as a message queue
      6  0fd6							; Gosub calls start at the highest address and the
      7  0fd6							; msg queue starts at the highest address.
      8  0fd6							;
      9  0fd6							;======================================================
     10  0fd6							; ipcs   - Send msg to another task or many tasks
     11  0fd6							; on entry  math stack contains the  top PID
     12  0fd6							;				      2ND Message value
     13  0fd6							; on exit   math stack contain top True-good or False-failed
     14  0fd6							;
     15  0fd6							; it may not be sent if queue is full
     16  0fd6							;
     17  0fd6							; a = ipcs(<message-expression>,<task PID-expression>)
     18  0fd6							;
     19  0fd6				   iIPCS
     20  0fd6		       98		      tya
     21  0fd7		       48		      pha
     22  0fd8		       20 3f 10 	      jsr	ipc_enqueue
     23  0fdb		       b0 08		      bcs	iIPC_BAD
     24  0fdd		       20 72 16 	      jsr	pushTrue
     25  0fe0		       68		      pla
     26  0fe1		       a8		      tay
     27  0fe2		       4c b9 02 	      jmp	NextIL
     28  0fe5				   iIPC_BAD
     29  0fe5		       68		      pla
     30  0fe6		       a8		      tay
     31  0fe7		       20 7c 16 	      jsr	pushFalse
     32  0fea		       4c b9 02 	      jmp	NextIL
     33  0fed
     34  0fed							;======================================================
     35  0fed							; ipcr   - Recieve msg from task
     36  0fed							; on exit  the message value is returned from message queue
     37  0fed							;	    message -1	is reserved meaning no entry found
     38  0fed							; The provided variable contains the pid of the sending
     39  0fed							; task. This is optional. This always waits for a message
     40  0fed							; before returning.
     41  0fed							;
     42  0fed							; a = ipcr(<variable name>)
     43  0fed							;
     44  0fed				   iIPCR
     45  0fed		       98		      tya
     46  0fee		       48		      pha
     47  0fef		       20 80 10 	      jsr	ipc_dequeue
     48  0ff2		       b0 05		      bcs	iIPCR_Q_Empty
     49  0ff4		       68		      pla
     50  0ff5		       a8		      tay
     51  0ff6		       4c b9 02 	      jmp	NextIL
     52  0ff9				   iIPCR_Q_Empty
     53  0ff9		       68		      pla
     54  0ffa		       a8		      tay
     55  0ffb		       20 72 16 	      jsr	pushTrue	; puts -1 on the stack
     56  0ffe		       4c b9 02 	      jmp	NextIL
     57  1001
     58  1001							;=======================================================
     59  1001							; ipcc   - Check if message available
     60  1001							; on exit  Stack contains number of messages
     61  1001							;
     62  1001							; a = ipcc()
     63  1001							;
     64  1001				   iIPCC
     65  1001		       98		      tya
     66  1002		       48		      pha
     67  1003		       20 2c 10 	      jsr	ipc_queue_count
     68  1006		       20 32 13 	      jsr	pushR0	; return the count
     69  1009		       68		      pla
     70  100a		       a8		      tay
     71  100b		       4c b9 02 	      jmp	NextIL
     72  100e
     73  100e							;=======================================================
     74  100e							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  100e				   iIPCIO
     76  100e		       98		      tya
     77  100f		       48		      pha
     78  1010		       20 2c 10 	      jsr	ipc_queue_count
     79  1013		       a5 52		      lda	R0
     80  1015		       d0 10		      bne	iIPCIO_No_Halt
     81  1017		       a9 01		      lda	#1
     82  1019		       8d b1 1d 	      sta	taskCurrentCycles	; force a task switch
     83  101c		       a9 01		      lda	#TASKWAITIPC
     84  101e		       ac b6 1c 	      ldy	taskPtr
     85  1021		       19 b7 1c 	      ora	taskTable,y
     86  1024		       99 b7 1c 	      sta	taskTable,y
     87  1027
     88  1027				   iIPCIO_No_Halt
     89  1027		       68		      pla
     90  1028		       a8		      tay
     91  1029		       4c b9 02 	      jmp	NextIL
     92  102c							;======================================================
     93  102c							;ipc_queue_count
     94  102c				   ipc_queue_count
     95  102c		       a5 4e		      lda	MESSAGEPTR
     96  102e		       18		      clc
     97  102f		       4a		      lsr		; divide by 4
     98  1030		       4a		      lsr
     99  1031		       85 52		      sta	R0	; store into R0
    100  1033		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1035		       38		      sec
    102  1036		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1038		       85 52		      sta	R0
    104  103a		       a9 00		      lda	#0
    105  103c		       85 53		      sta	R0+1
    106  103e		       60		      rts
    107  103f							;=======================================================
    108  103f							; Support functions for messaging
    109  103f							;
    110  103f							; Enqueue message -> onto PID's MSG Q
    111  103f							; on entry top of stack contains the PID
    112  103f							;	    second contains the Message of the task
    113  103f							; on exit contains c set if failed
    114  103f							;		    c cleared if success
    115  103f							;		    PID's MSG Q PTR points to the message
    116  103f							;
    117  103f				   ipc_enqueue
    118  103f		       20 ce 13 	      jsr	popR1	; Get the pid
    119  1042		       20 b9 10 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1045
    121  1045		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1047		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1049		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  104b		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  104d		       b0 2f		      bcs	ipc_enq_full	; Exit with queue full message
    126  104f
    127  104f
    128  104f							; Get the PID'S stack address into R0
    129  104f		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1051		       b1 56		      lda	(MQ),y
    131  1053		       85 52		      sta	R0
    132  1055		       c8		      iny
    133  1056		       b1 56		      lda	(MQ),y
    134  1058		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  105a
    136  105a							; Set y to point to the msg q entry
    137  105a		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  105c		       b1 56		      lda	(MQ),y	; Get the index
    139  105e		       a8		      tay		; Set y to queue offset
    140  105f
    141  105f							; enqueue the message
    142  105f		       88		      dey		; First byte to save to
    143  1060		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1062		       91 52		      sta	(R0),y	; Set the entry type
    145  1064
    146  1064		       88		      dey
    147  1065		       a5 54		      lda	R1	; Store the PID into queue
    148  1067		       91 52		      sta	(R0),y
    149  1069		       20 ce 13 	      jsr	popR1	; Get the actual message value
    150  106c		       20 c7 10 	      jsr	ipc_pushR1	; Store Message value into queue
    151  106f
    152  106f		       98		      tya		; Save the new q ptr
    153  1070		       a0 0e		      ldy	#MSGPTRPOS
    154  1072		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1074		       a0 00		      ldy	#0	; points to context root
    156  1076		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1078		       51 56		      eor	(MQ),y	; Turn off the bit
    158  107a		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  107c		       18		      clc
    160  107d		       60		      rts
    161  107e				   ipc_enq_full
    162  107e		       38		      sec
    163  107f		       60		      rts
    164  1080							;=============================================================
    165  1080							; De-queue for message stack -> local tasks msg q
    166  1080							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1080							;  message into
    168  1080							;  on exit   math stack contains value of message
    169  1080							;				  Variable if provided is pid
    170  1080				   ipc_dequeue
    171  1080		       20 e5 13 	      jsr	popMQ	; Variable address to put PID into
    172  1083
    173  1083		       a4 4e		      ldy	MESSAGEPTR
    174  1085		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1087		       b0 2e		      bcs	ipc_deq_empty
    176  1089		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  108b		       85 52		      sta	R0
    178  108d		       c8		      iny
    179  108e		       b1 4b		      lda	(GOSUBSTACK),y
    180  1090		       85 53		      sta	R0+1
    181  1092		       c8		      iny
    182  1093		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1095		       85 54		      sta	R1
    184  1097		       c8		      iny
    185  1098		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  109a		       c8		      iny
    187  109b		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  109d
    189  109d		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  109f		       d0 16		      bne	ipc_deq_empty
    191  10a1
    192  10a1		       20 32 13 	      jsr	pushR0	; place value on stack
    193  10a4
    194  10a4		       a5 56		      lda	MQ
    195  10a6		       05 57		      ora	MQ+1
    196  10a8		       f0 0b		      beq	ipc_deq_done
    197  10aa		       a5 54		      lda	R1
    198  10ac		       a0 00		      ldy	#0
    199  10ae		       91 56		      sta	(MQ),y
    200  10b0		       c8		      iny
    201  10b1		       a9 00		      lda	#0
    202  10b3		       91 56		      sta	(MQ),y
    203  10b5				   ipc_deq_done
    204  10b5		       18		      clc
    205  10b6		       60		      rts
    206  10b7
    207  10b7				   ipc_deq_empty
    208  10b7		       38		      sec
    209  10b8		       60		      rts
    210  10b9
    211  10b9							;=============================================
    212  10b9							;  Get the context address into MQ from R1 with
    213  10b9							;  context/index/pid
    214  10b9				   ipc_getcontext
    215  10b9		       18		      clc		; Get pointer to Task context
    216  10ba		       a9 b7		      lda	#taskTable&$FF	; change ptr to address
    217  10bc		       65 54		      adc	R1
    218  10be		       85 56		      sta	MQ
    219  10c0		       a9 1c		      lda	#taskTable>>8
    220  10c2		       65 55		      adc	R1+1
    221  10c4		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  10c6		       60		      rts
    223  10c7							;
    224  10c7							;==============================================
    225  10c7							;Push R1 onto the stack
    226  10c7							;on entry y = next entry
    227  10c7							;R0 points to the stack space
    228  10c7							;on exit y points to next free byte
    229  10c7				   ipc_pushR1
    230  10c7		       88		      dey
    231  10c8		       a5 55		      lda	R1+1	; PID first
    232  10ca		       91 52		      sta	(R0),y
    233  10cc		       88		      dey
    234  10cd		       a5 54		      lda	R1
    235  10cf		       91 52		      sta	(R0),y
    236  10d1		       60		      rts
    237  10d2
    238  10d2
    239  10d2
    240  10d2
    241  10d2
    242  10d2
    243  10d2
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  10d2					      include	"support.asm"
      1  10d2							;
      2  10d2							;=====================================================
      3  10d2							;=====================================================
      4  10d2							;=====================================================
      5  10d2							; This marks the start of support functions used by
      6  10d2							; the IL opcodes.  These are support functions, NOT
      7  10d2							; the IL code.
      8  10d2							;=====================================================
      9  10d2							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  10d2							;=====================================================
     11  10d2					      Seg	Code
     12  10d2							;=====================================================
     13  10d2							; This gets the next two bytes pointed to by ILPC and
     14  10d2							; returns them; X contains LSB, A contains MSB.  ILPC
     15  10d2							; is advanced by two, and Y contains 0 on return.
     16  10d2
     17  10d2							;
     18  10d2		       20 d6 10    getILWord  jsr	getILByte	;LSB
     19  10d5		       aa		      tax
     20  10d6							;
     21  10d6							;=====================================================
     22  10d6							; This gets the next byte pointed to by ILPC and
     23  10d6							; returns it in A.  On return, X is unchanged but Y
     24  10d6							; contains 0.
     25  10d6							;
     26  10d6		       a0 00	   getILByte  ldy	#0
     27  10d8		       b1 43		      lda	(ILPC),y	;get byte
     28  10da		       08		      php		;save status
     29  10db		       e6 43		      inc	ILPC	;inc LSB
     30  10dd		       d0 02		      bne	getILb2	;branch if no overflow
     31  10df		       e6 44		      inc	ILPC+1	;inc MSB
     32  10e1		       28	   getILb2    plp		;restore status
     33  10e2		       60		      rts
     34  10e3							;
     35  10e3							;=====================================================
     36  10e3							; Decrement ILPC by one.
     37  10e3							;
     38  10e3		       a5 43	   decIL      lda	ILPC
     39  10e5		       d0 02		      bne	decIL2
     40  10e7		       c6 44		      dec	ILPC+1
     41  10e9		       c6 43	   decIL2     dec	ILPC
     42  10eb		       60		      rts
     43  10ec							;
     44  10ec							;=====================================================
     45  10ec							; Push the ILPC onto the return stack.  Actually, this
     46  10ec							; pushes the address of ILPC+2 since that's the next
     47  10ec							; address to execute.
     48  10ec							;
     49  10ec		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  10ee		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  10f0		       b0 15		      bcs	pushErr
     52  10f2		       a5 43		      lda	ILPC
     53  10f4		       18		      clc
     54  10f5		       69 02		      adc	#2
     55  10f7		       91 45		      sta	(ILSTACK),y
     56  10f9		       08		      php		;save C bit
     57  10fa		       c8		      iny
     58  10fb		       a5 44		      lda	ILPC+1
     59  10fd		       28		      plp		;restore C
     60  10fe		       69 00		      adc	#0
     61  1100		       91 45		      sta	(ILSTACK),y
     62  1102		       c8		      iny
     63  1103		       84 47		      sty	ILSTACKPTR
     64  1105		       18		      clc
     65  1106		       60		      rts
     66  1107				   pushErr
     67  1107		       38		      sec
     68  1108		       60		      rts
     69  1109							;
     70  1109							;=====================================================
     71  1109							; Pull the top entry from return stack and put into
     72  1109							; ILPC.
     73  1109							;
     74  1109		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  110b		       f0 fa		      beq	pushErr
     76  110d		       88		      dey
     77  110e		       b1 45		      lda	(ILSTACK),y
     78  1110		       85 44		      sta	ILPC+1
     79  1112		       88		      dey
     80  1113		       b1 45		      lda	(ILSTACK),y
     81  1115		       85 43		      sta	ILPC
     82  1117		       84 47		      sty	ILSTACKPTR
     83  1119		       18		      clc
     84  111a		       60		      rts
     85  111b							;
     86  111b							;=====================================================
     87  111b							; This searches for a specific line number that is in
     88  111b							; R0.	There are three possible return conditions:
     89  111b							; Line numbers are now the third byte, the first byte is now **************
     90  111b							; a pointer to the next line, of course no longer that 53 byte
     91  111b							; per line.
     92  111b							;
     93  111b							; Exact match was found:
     94  111b							;    * Z set
     95  111b							;    * CURPTR points to two-byte line number for that
     96  111b							;	line.
     97  111b							;
     98  111b							; Next highest line found:
     99  111b							;    * Z cleared
    100  111b							;    * C set
    101  111b							;    * CURPTR points to two-byte line number for that
    102  111b							;	line.
    103  111b							;
    104  111b							; End of program reached:
    105  111b							;    * Z cleared
    106  111b							;    * C cleared
    107  111b							;    * CURPTR points to first free byte at end of
    108  111b							;	program.  Ie, it has save value as PROGRAMEND.
    109  111b							;
    110  111b							; A, X, and Y are all undefined on return.
    111  111b							;
    112  111b
    113  111b				   findLine
    114  111b		       a9 0e		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    115  111d		       85 4f		      sta	CURPTR
    116  111f		       a9 26		      lda	#ProgramStart>>8
    117  1121		       85 50		      sta	CURPTR+1
    118  1123							;
    119  1123							; At end of code?
    120  1123							;
    121  1123				   iXFER1
    122  1123		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1125		       cd 06 26 	      cmp	PROGRAMEND	; at end of program then stop run
    124  1128		       d0 0b		      bne	xfer2	; not end
    125  112a		       a5 50		      lda	CURPTR+1
    126  112c		       cd 07 26 	      cmp	PROGRAMEND+1
    127  112f		       d0 04		      bne	xfer2	;Not at end
    128  1131							;
    129  1131							; Line not found and the end of the program was
    130  1131							; reached.  Return Z and C both clear.
    131  1131							;
    132  1131		       a9 01		      lda	#1	;clear Z
    133  1133		       18		      clc		;clear C
    134  1134		       60		      rts
    135  1135							;
    136  1135							; Check for an exact line number match
    137  1135							;
    138  1135		       a5 52	   xfer2      lda	R0
    139  1137		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1139		       d1 4f		      cmp	(CURPTR),y
    141  113b		       d0 08		      bne	xfernotit
    142  113d		       c8		      iny
    143  113e		       a5 53		      lda	R0+1
    144  1140		       d1 4f		      cmp	(CURPTR),y
    145  1142		       d0 01		      bne	xfernotit	; not a matching line number
    146  1144							;
    147  1144							; This is exactly the line we want.
    148  1144							;
    149  1144		       60		      rts		;it matches exactly
    150  1145							;
    151  1145							; See if this line is greater than the one we're
    152  1145							; searching for.
    153  1145							;
    154  1145		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    155  1147		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1149		       c5 53		      cmp	R0+1
    157  114b		       90 0b		      bcc	xfer3
    158  114d		       d0 07		      bne	xfer4
    159  114f		       88		      dey
    160  1150		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1152		       c5 52		      cmp	R0
    162  1154		       90 02		      bcc	xfer3
    163  1156							;
    164  1156							; This line is greater than the one we want, so
    165  1156							; return Z clear and C set.
    166  1156							;
    167  1156		       38	   xfer4      sec		;We found a line number greater
    168  1157		       60		      rts		;both conditions set
    169  1158							;
    170  1158							; Not the line (or droid) we're looking for.  Move to
    171  1158							; the next line.
    172  1158							;
    173  1158		       20 5e 11    xfer3      jsr	FindNextLine
    174  115b		       4c 23 11 	      jmp	iXFER1
    175  115e							;
    176  115e							;=====================================================
    177  115e							; This advances CURPTR to the next line.  If there
    178  115e							; are no more lines, this leaves CURPTR equal to
    179  115e							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  115e							; CURPTR is pointing to a valid line on entry.  This
    181  115e							; pointer points to the two-byte line number.
    182  115e							; Update this points to the 1 byte line length  ****************
    183  115e							;
    184  115e				   FindNextLine
    185  115e		       a0 03		      ldy	#3	;skip line number and length byte
    186  1160		       84 51		      sty	CUROFF	;this is the new offset
    187  1162		       a0 00		      ldy	#0
    188  1164		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1166		       18		      clc
    190  1167		       65 4f		      adc	CURPTR
    191  1169		       85 4f		      sta	CURPTR
    192  116b		       90 02		      bcc	FindNext4	;exit
    193  116d		       e6 50		      inc	CURPTR+1
    194  116f		       60	   FindNext4  rts
    195  1170							;
    196  1170							;=====================================================
    197  1170							; This compares CURPTR to PROGRAMEND and returns Z set
    198  1170							; if they are equal, Z clear if not.
    199  1170							;
    200  1170		       a5 4f	   AtEnd      lda	CURPTR
    201  1172		       cd 06 26 	      cmp	PROGRAMEND
    202  1175		       d0 05		      bne	atendexit
    203  1177		       a5 50		      lda	CURPTR+1
    204  1179		       cd 07 26 	      cmp	PROGRAMEND+1
    205  117c		       60	   atendexit  rts
    206  117d							;
    207  117d							;=====================================================
    208  117d							; Print the contents of R0 as a signed decimal number.
    209  117d							; Does leading zero suppression.
    210  117d							;
    211  117d				   PrintDecimal
    212  117d		       a5 53		      lda	R0+1	;MSB has sign
    213  117f		       10 17		      bpl	pplus	;it's a positive number
    214  1181							;
    215  1181							; Negative numbers need more work.  Invert all the bits,
    216  1181							; then add one.
    217  1181							;
    218  1181		       a9 2d		      lda	#'-
    219  1183		       20 eb 15 	      jsr	VOUTCH	;print the negative sign
    220  1186							;
    221  1186		       a5 52		      lda	R0	;invert bits
    222  1188		       49 ff		      eor	#$ff
    223  118a		       85 52		      sta	R0
    224  118c		       a5 53		      lda	R0+1
    225  118e		       49 ff		      eor	#$ff
    226  1190		       85 53		      sta	R0+1
    227  1192		       e6 52		      inc	R0	;add one
    228  1194		       d0 02		      bne	pplus
    229  1196		       e6 53		      inc	R0+1
    230  1198							;
    231  1198							; Print the value in R0 as a positive number.
    232  1198							;
    233  1198		       a2 00	   pplus      ldx	#0	;start of subtraction table
    234  119a		       8e f8 25 	      stx	diddigit	;no digits yet
    235  119d		       a0 00	   pploop     ldy	#0	;result of division
    236  119f		       a5 52	   pploop2    lda	R0	;LSB
    237  11a1		       38		      sec
    238  11a2		       fd e1 11 	      sbc	dectable,x
    239  11a5		       85 52		      sta	R0
    240  11a7		       a5 53		      lda	R0+1
    241  11a9		       fd e2 11 	      sbc	dectable+1,x
    242  11ac		       10 2e		      bpl	pplusok	;no underflow
    243  11ae							;
    244  11ae							; Else, underflow.  Add back in the LSB of the
    245  11ae							; table to R0.
    246  11ae							;
    247  11ae		       18		      clc
    248  11af		       a5 52		      lda	R0
    249  11b1		       7d e1 11 	      adc	dectable,x
    250  11b4		       85 52		      sta	R0
    251  11b6							;
    252  11b6							; Print the value in Y.  Actually, see if Y is zero and
    253  11b6							; whether any digit has been printed yet.  If Y isn't
    254  11b6							; zero or we've printed a digit, go ahead and print.
    255  11b6							;
    256  11b6		       8e f5 25 	      stx	printtx
    257  11b9		       98		      tya
    258  11ba		       09 00		      ora	#0	;set flags
    259  11bc		       d0 05		      bne	pprintit	;non-zero, print
    260  11be							;
    261  11be		       ad f8 25 	      lda	diddigit
    262  11c1		       f0 09		      beq	pprintno	;don't print
    263  11c3							;
    264  11c3		       98	   pprintit   tya
    265  11c4		       09 30		      ora	#'0
    266  11c6		       8d f8 25 	      sta	diddigit
    267  11c9		       20 eb 15 	      jsr	VOUTCH
    268  11cc		       ae f5 25    pprintno   ldx	printtx
    269  11cf							;
    270  11cf							; Move to the next table entry
    271  11cf							;
    272  11cf		       e8		      inx
    273  11d0		       e8		      inx
    274  11d1		       e0 08		      cpx	#dectableend-dectable
    275  11d3		       d0 c8		      bne	pploop	;not at end
    276  11d5							;
    277  11d5							; At the end.	R0 contains the final value
    278  11d5							; to print.
    279  11d5							;
    280  11d5		       a5 52		      lda	R0
    281  11d7		       09 30		      ora	#'0
    282  11d9		       4c eb 15 	      jmp	VOUTCH
    283  11dc							;
    284  11dc							; Finish doing the subtraction.
    285  11dc							;
    286  11dc		       85 53	   pplusok    sta	R0+1
    287  11de		       c8		      iny
    288  11df		       d0 be		      bne	pploop2
    289  11e1							;
    290  11e1							; Table of powers-of-ten
    291  11e1							;
      0  11e1				   dectable   dw	10000
      1  11e1		       10 27		      .word.w	10000
      0  11e3					      dw	1000
      1  11e3		       e8 03		      .word.w	1000
      0  11e5					      dw	100
      1  11e5		       64 00		      .word.w	100
      0  11e7					      dw	10
      1  11e7		       0a 00		      .word.w	10
    296  11e7		       11 e9	   dectableend equ	*
    297  11e9							;
    298  11e9							;=====================================================
    299  11e9							; Convert an ASCII string to a number.  On input,
    300  11e9							; (CURPTR),Y points to the first digit.  This gets
    301  11e9							; digit-by-digit until finding a non-number.  Returns
    302  11e9							; Y pointing to the non-digit, and R0 contains the
    303  11e9							; number.  This does NOT check for valid ranges, so
    304  11e9							; a value like "123456789" will produce something,
    305  11e9							; but not what you had expected.
    306  11e9							;
    307  11e9		       a9 00	   getDecimal lda	#0
    308  11eb		       85 52		      sta	R0
    309  11ed		       85 53		      sta	R0+1
    310  11ef		       85 59		      sta	dpl	;temporary negative flag
    311  11f1							;
    312  11f1							; See if it's negative...
    313  11f1							;
    314  11f1							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    315  11f1		       b1 4f		      lda	(CURPTR),y
    316  11f3		       c9 2d		      cmp	#'-
    317  11f5		       d0 02		      bne	getDecLoop
    318  11f7		       e6 59		      inc	dpl	;it's negative
    319  11f9							;
    320  11f9		       b1 4f	   getDecLoop lda	(CURPTR),y
    321  11fb		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    322  11fd		       c9 30		      cmp	#'0
    323  11ff		       90 36		      bcc	getDdone
    324  1201		       c9 3a		      cmp	#'9+1
    325  1203		       b0 32		      bcs	getDdone
    326  1205		       38		      sec
    327  1206		       e9 30		      sbc	#'0	;convert to binary
    328  1208		       48		      pha
    329  1209							;
    330  1209							; Now multiply R0 by 10.  Remember that
    331  1209							; 2*N + 8*N = 10*N.
    332  1209							;
    333  1209		       06 52		      asl	R0
    334  120b		       26 53		      rol	R0+1	;*2
    335  120d		       a5 52		      lda	R0
    336  120f		       85 54		      sta	R1
    337  1211		       a5 53		      lda	R0+1
    338  1213		       85 55		      sta	R1+1
    339  1215		       06 52		      asl	R0
    340  1217		       26 53		      rol	R0+1	;*4
    341  1219		       06 52		      asl	R0
    342  121b		       26 53		      rol	R0+1	;*8
    343  121d		       18		      clc		;now add the partial sums...
    344  121e		       a5 52		      lda	R0	;...to get *10
    345  1220		       65 54		      adc	R1
    346  1222		       85 52		      sta	R0
    347  1224		       a5 53		      lda	R0+1
    348  1226		       65 55		      adc	R1+1
    349  1228		       85 53		      sta	R0+1
    350  122a							;
    351  122a							; Add in the new digit
    352  122a							;
    353  122a		       68		      pla
    354  122b		       18		      clc
    355  122c		       65 52		      adc	R0
    356  122e		       85 52		      sta	R0
    357  1230		       90 02		      bcc	getD2
    358  1232		       e6 53		      inc	R0+1
    359  1234							;
    360  1234							; Move to next character
    361  1234							;
    362  1234		       c8	   getD2      iny
    363  1235		       d0 c2		      bne	getDecLoop
    364  1237							;
    365  1237							; All done with digits, so now deal with it being
    366  1237							; negative.  If zero, then don't check for negative
    367  1237							; flag.  Ie, -0 is stored as 0.
    368  1237							;
    369  1237		       a5 52	   getDdone   lda	R0
    370  1239		       05 53		      ora	R0+1
    371  123b		       f0 16		      beq	getDone2	;zero
    372  123d		       a5 59		      lda	dpl
    373  123f		       f0 12		      beq	getDone2	;positive
    374  1241							;
    375  1241							; Invert all the bits, then add one.
    376  1241							;
    377  1241		       a5 52		      lda	R0
    378  1243		       49 ff		      eor	#$ff
    379  1245		       85 52		      sta	R0
    380  1247		       a5 53		      lda	R0+1
    381  1249		       49 ff		      eor	#$ff
    382  124b		       85 53		      sta	R0+1
    383  124d							;
    384  124d		       e6 52		      inc	R0
    385  124f		       d0 02		      bne	getDone2
    386  1251		       e6 53		      inc	R0+1
    387  1253				   getDone2
    388  1253							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    389  1253							;lda	  R0
    390  1253							;sta	  $0010
    391  1253							;lda	  R0+1
    392  1253							;sta	  $0011
    393  1253							;lda	  dpl
    394  1253							;sta	  $012
    395  1253
    396  1253		       60		      rts
    397  1254
    398  1254							;=====================================================
    399  1254							; Gets a line of input into LINBUF.
    400  1254							;
    401  1254							; On entry:
    402  1254							;    A contains the prompt character, or 0 if none.
    403  1254							;    X = 1 Background read
    404  1254							;    x = 0 Forground read with wait
    405  1254							;
    406  1254							; On exit:
    407  1254							;    CURPTR points to LINBUF
    408  1254							;    LINBUF contains the line with 0 at the end.
    409  1254							;    Y has offset to first non-space character
    410  1254							;    CURROFF has the same as Y.
    411  1254							;
    412  1254		       20 a3 12    GetLine    jsr	ReadPrompt
    413  1257		       e0 00		      cpx	#0
    414  1259		       f0 14		      beq	GetLineRetry
    415  125b		       ae b6 1c 	      ldx	taskPtr
    416  125e		       bd b7 1c 	      lda	taskTable,x
    417  1261		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    418  1263		       d0 3d		      bne	taskWaitingIO
    419  1265		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    420  1267		       9d b7 1c 	      sta	taskTable,x	;Mark the state for task as waiting io
    421  126a		       ce a2 12 	      dec	taskWaitingIO	;Start polling the input and make task wait
    422  126d		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    423  126f
    424  126f							;
    425  126f							; Now read a line and wait for the CR
    426  126f							;
    427  126f				   GetLineRetry
    428  126f		       a9 00		      lda	#0	;Wait for input to complete
    429  1271		       20 bb 12 	      jsr	ReadLine
    430  1274
    431  1274							;
    432  1274							; Point to the line we just read
    433  1274							; Set the current pointer to point to the input line
    434  1274							;
    435  1274		       a0 00	   ReadComplete ldy	#0
    436  1276		       84 51		      sty	CUROFF
    437  1278		       a2 70		      ldx	#LINBUF&$ff
    438  127a		       86 4f		      stx	CURPTR
    439  127c		       a2 25		      ldx	#LINBUF>>8
    440  127e		       86 50		      stx	CURPTR+1
    441  1280							;
    442  1280							; Output a CR/LF
    443  1280							;
    444  1280		       20 6f 14 	      jsr	CRLF
    445  1283							;
    446  1283							; If a blank line, prompt again.
    447  1283							;
    448  1283		       20 66 14 	      jsr	SkipSpaces
    449  1286		       b1 4f		      lda	(CURPTR),y
    450  1288		       d0 10		      bne	GetLineDone	;We have data then exit
    451  128a		       20 a6 12 	      jsr	ReadPromptRetry
    452  128d		       ae b6 1c 	      ldx	taskPtr	;if this task is waiting for IO
    453  1290		       bd b7 1c 	      lda	taskTable,x	;then get out, wait for line to
    454  1293		       29 40		      and	#TASKWAITIO	;Complete again
    455  1295		       d0 0b		      bne	taskWaitingIO
    456  1297		       4c 6f 12 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    457  129a
    458  129a				   GetLineDone
    459  129a		       ae b6 1c 	      ldx	taskPtr
    460  129d		       a9 80		      lda	#TASKACTIVE
    461  129f		       9d b7 1c 	      sta	taskTable,x	;IO is complete
    462  12a2
    463  12a2				   taskWaitingIO
    464  12a2		       60		      rts
    465  12a3
    466  12a3							;
    467  12a3							;=======================================================================
    468  12a3							; Display the prompt character
    469  12a3							; On entry
    470  12a3							;	    A contains the prompt character
    471  12a3							; On exit
    472  12a3							;	    The readbuffer index is reset to 0
    473  12a3							;
    474  12a3		       8d f7 25    ReadPrompt sta	promptChar
    475  12a6
    476  12a6							;
    477  12a6							; Prompt
    478  12a6							;
    479  12a6
    480  12a6		       ad f7 25    ReadPromptRetry lda	promptChar
    481  12a9		       09 00		      ora	#0	;any prompt?
    482  12ab		       f0 08		      beq	getlinenp
    483  12ad		       20 eb 15 	      jsr	VOUTCH
    484  12b0		       a9 20		      lda	#$20
    485  12b2		       20 eb 15 	      jsr	VOUTCH	;Space after prompt
    486  12b5							;
    487  12b5		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    488  12b7		       8e f4 25 	      stx	getlinx
    489  12ba		       60		      rts
    490  12bb							;
    491  12bb							;===============================================================
    492  12bb							; This fuction is the driver for the line input
    493  12bb							; on call if a = 0 then it waits for all input
    494  12bb							;	      a = 1 then nowait for input
    495  12bb							; On exit
    496  12bb							;		       c clear if not complete line
    497  12bb							;		       c set if it was a complete line
    498  12bb
    499  12bb				   ReadLine
    500  12bb		       8d f6 25 	      sta	inputNoWait
    501  12be		       c9 00		      cmp	#0
    502  12c0		       f0 05		      beq	getline1
    503  12c2		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    504  12c5		       f0 2b		      beq	GetLineNoWait
    505  12c7		       20 ee 15    getline1   jsr	VGETCH
    506  12ca					      if	CTMON65
    507  12ca		       48		      pha
    508  12cb		       20 eb 15 	      jsr	VOUTCH	;echo echo echo
    509  12ce		       68		      pla
    510  12cf					      endif
    511  12cf		       c9 0d		      cmp	#CR
    512  12d1		       f0 15		      beq	getlind	;end of line
    513  12d3		       c9 08		      cmp	#BS	;backspace?
    514  12d5		       f0 1d		      beq	getlinebs
    515  12d7		       ae f4 25 	      ldx	getlinx
    516  12da		       9d 70 25 	      sta	LINBUF,x
    517  12dd		       e8		      inx
    518  12de		       8e f4 25 	      stx	getlinx
    519  12e1		       ad f6 25 	      lda	inputNoWait
    520  12e4		       f0 e1		      beq	getline1
    521  12e6		       d0 0a		      bne	GetLineNoWait
    522  12e8							;
    523  12e8							; CR was hit
    524  12e8							;
    525  12e8		       a9 00	   getlind    lda	#0	; set the end pf buffer
    526  12ea		       ae f4 25 	      ldx	getlinx
    527  12ed		       9d 70 25 	      sta	LINBUF,x
    528  12f0
    529  12f0		       38		      sec		; Carry set then cr received
    530  12f1		       60		      rts
    531  12f2
    532  12f2				   GetLineNoWait
    533  12f2		       18		      clc		; Carry clear no end of line
    534  12f3		       60		      rts
    535  12f4							;
    536  12f4							; Backspace was hit
    537  12f4							;
    538  12f4		       ae f4 25    getlinebs  ldx	getlinx
    539  12f7		       f0 0e		      beq	getlineEOL	;at start of line
    540  12f9		       ca		      dex
    541  12fa		       8e f4 25 	      stx	getlinx
    542  12fd		       20 f1 15    getlinepbs jsr	puts
      0  1300					      db	27,"[K",0
      1  1300		       1b 5b 4b 00	      .byte.b	27,"[K",0
    544  1304		       4c c7 12 	      jmp	getline1
    545  1307		       a9 20	   getlineEOL lda	#SPACE
    546  1309		       20 eb 15 	      jsr	VOUTCH
    547  130c		       d0 ef		      bne	getlinepbs
    548  130e							;
    549  130e							;=====================================================
    550  130e							; Count the length of the line currently in LINBUF
    551  130e							; starting at offset Y.  Returns the length in X.  The
    552  130e							; starting offset in Y should point past the ASCII
    553  130e							; line number.  Also counts the trailing NULL and two
    554  130e							; extra bytes for where the line number will be.
    555  130e							; Update must now include leading length byte not the null at end ****************
    556  130e							;
    557  130e				   getLineLength
    558  130e		       a2 00		      ldx	#0	;size
    559  1310		       b9 70 25    getLineL2  lda	LINBUF,y
    560  1313		       f0 04		      beq	getLineL3
    561  1315		       c8		      iny
    562  1316		       e8		      inx
    563  1317		       d0 f7		      bne	getLineL2
    564  1319		       e8	   getLineL3  inx		;count null at end
    565  131a		       e8		      inx		;line number LSB
    566  131b		       e8		      inx		;MSB
    567  131c		       e8		      inx		;change: count new leading line length
    568  131d		       86 5f		      stx	lineLength
    569  131f		       60		      rts
    570  1320							;
    571  1320							;=====================================================
    572  1320							; Count the length of the line pointed to by CURPTR.
    573  1320							; This also counts the line number and the terminating
    574  1320							; null.  Ie, this string returns 8:
    575  1320							;
    576  1320							; <lineLow><lineHi>Hello<null>
    577  1320							;
    578  1320							; Another way of looking at it: add the return value
    579  1320							; to the CURPTR and it'll point to the next line's
    580  1320							; line number.  Returns the value in Y.
    581  1320							; Update to ject get the leading byte length ********************
    582  1320							;
    583  1320							;getCURPTRLength
    584  1320							;		ldy	CURPTR
    585  1320							;		ldy	#3	;change: skip line number and leading length byte
    586  1320							;getCLineL2	lda	(CURPTR),y
    587  1320							;		beq	getCLineL3
    588  1320							;		iny
    589  1320							;		bne	getCLineL2
    590  1320							;getCLineL3	iny		;count null at end
    591  1320							;		rts
    592  1320
    593  1320							;
    594  1320							;=====================================================
    595  1320							; This saves ILPC.  This saves to a single save area,
    596  1320							; so it can't be called more than once.
    597  1320							;
    598  1320		       a5 43	   saveIL     lda	ILPC
    599  1322		       85 5b		      sta	tempIL
    600  1324		       a5 44		      lda	ILPC+1
    601  1326		       85 5c		      sta	tempIL+1
    602  1328		       60		      rts
    603  1329							;
    604  1329							;=====================================================
    605  1329							; This restores ILPC.
    606  1329							;
    607  1329		       a5 5b	   restoreIL  lda	tempIL
    608  132b		       85 43		      sta	ILPC
    609  132d		       a5 5c		      lda	tempIL+1
    610  132f		       85 44		      sta	ILPC+1
    611  1331		       60		      rts
    612  1332							;
    613  1332							;=====================================================
    614  1332							; This pushes R0 onto the stack.
    615  1332							;
    616  1332		       8c fd 25    pushR0     sty	rtemp1
    617  1335		       a4 4a		      ldy	MATHSTACKPTR
    618  1337		       c0 28		      cpy	#MATHSTACKSIZE<<1
    619  1339		       b0 34		      bcs	pusherr
    620  133b		       a5 52		      lda	R0
    621  133d		       91 48		      sta	(MATHSTACK),y
    622  133f		       c8		      iny
    623  1340		       a5 53		      lda	R0+1
    624  1342		       91 48		      sta	(MATHSTACK),y
    625  1344		       c8		      iny
    626  1345		       84 4a		      sty	MATHSTACKPTR
    627  1347		       ac fd 25 	      ldy	rtemp1
    628  134a		       18		      clc
    629  134b		       60		      rts
    630  134c
    631  134c							;=====================================================
    632  134c							; This pushes curptr basic current line onto the call stack.
    633  134c							; and CUROFF. Also marks entry type as 1 = GOSUB
    634  134c
    635  134c				   pushLN
    636  134c		       8c fd 25 	      sty	rtemp1
    637  134f		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    638  1351		       c5 4d		      cmp	GOSUBSTACKPTR
    639  1353		       90 1a		      bcc	pusherr	; No error
    640  1355		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    641  1357		       a2 00		      ldx	#0	; Start of bytes to copy
    642  1359				   pushLoop
    643  1359		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    644  135b		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    645  135d		       c8		      iny		; Next destination
    646  135e		       e8		      inx		; Next Source byte
    647  135f		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    648  1361		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    649  1363
    650  1363		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    651  1365		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    652  1367		       c8		      iny		; Next entry
    653  1368
    654  1368		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    655  136a		       ac fd 25 	      ldy	rtemp1
    656  136d		       18		      clc
    657  136e		       60		      rts
    658  136f				   pusherr
    659  136f		       38		      sec
    660  1370		       60		      rts
    661  1371							;=====================================================
    662  1371							; This pops Top Off gosub call Stack and
    663  1371							; places it in CURPTR/CUROFF.
    664  1371							; This checks if the type = 1 GOSUB
    665  1371							; if not it removes what ever is on the stack
    666  1371							; until it finds the next return. Allowing
    667  1371							; a return from within a for/next
    668  1371		       8c fd 25    popLN      sty	rtemp1
    669  1374		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    670  1376		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    671  1378
    672  1378				   popContinue
    673  1378		       c0 04		      cpy	#4	; if less than 4 on stack then error
    674  137a		       90 18		      bcc	poperr	; Process an error
    675  137c
    676  137c		       88		      dey		; Position to read entry type
    677  137d		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    678  137f		       c9 01		      cmp	#1	; Type is a gosub entry
    679  1381		       d0 13		      bne	popSkipEntry	; No then just skip this
    680  1383
    681  1383				   popLoop
    682  1383		       88		      dey
    683  1384		       ca		      dex
    684  1385		       b1 4b		      lda	(GOSUBSTACK),y
    685  1387		       95 4f		      sta	CURPTR,x
    686  1389		       e0 00		      cpx	#0
    687  138b		       d0 f6		      bne	popLoop	; Loop until all moved
    688  138d
    689  138d
    690  138d		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    691  138f		       ac fd 25 	      ldy	rtemp1
    692  1392		       18		      clc
    693  1393		       60		      rts
    694  1394
    695  1394		       38	   poperr     sec
    696  1395		       60		      rts
    697  1396
    698  1396		       88	   popSkipEntry dey
    699  1397		       88		      dey
    700  1398		       88		      dey
    701  1399		       4c 78 13 	      jmp	popContinue
    702  139c
    703  139c							;
    704  139c							;=====================================================
    705  139c							; This pushes R1 onto the stack
    706  139c							;
    707  139c		       8c fd 25    pushR1     sty	rtemp1
    708  139f		       a4 4a		      ldy	MATHSTACKPTR
    709  13a1		       c0 28		      cpy	#MATHSTACKSIZE<<1
    710  13a3		       b0 ef		      bcs	poperr
    711  13a5		       a5 54		      lda	R1
    712  13a7		       91 48		      sta	(MATHSTACK),y
    713  13a9		       c8		      iny
    714  13aa		       a5 55		      lda	R1+1
    715  13ac		       91 48		      sta	(MATHSTACK),y
    716  13ae		       c8		      iny
    717  13af		       84 4a		      sty	MATHSTACKPTR
    718  13b1		       ac fd 25 	      ldy	rtemp1
    719  13b4		       18		      clc
    720  13b5		       60		      rts
    721  13b6							;
    722  13b6							;=====================================================
    723  13b6							; This pops Top Of Stack and places it in R0.
    724  13b6							;
    725  13b6		       8c fd 25    popR0      sty	rtemp1
    726  13b9		       a4 4a		      ldy	MATHSTACKPTR
    727  13bb		       f0 d7		      beq	poperr
    728  13bd		       88		      dey
    729  13be		       b1 48		      lda	(MATHSTACK),y
    730  13c0		       85 53		      sta	R0+1
    731  13c2		       88		      dey
    732  13c3		       b1 48		      lda	(MATHSTACK),y
    733  13c5		       85 52		      sta	R0
    734  13c7		       84 4a		      sty	MATHSTACKPTR
    735  13c9		       ac fd 25 	      ldy	rtemp1
    736  13cc		       18		      clc
    737  13cd		       60		      rts
    738  13ce
    739  13ce							;
    740  13ce							;=====================================================
    741  13ce							; This pops TOS and places it in R1.
    742  13ce							;
    743  13ce		       8c fd 25    popR1      sty	rtemp1
    744  13d1		       a4 4a		      ldy	MATHSTACKPTR
    745  13d3		       f0 bf		      beq	poperr
    746  13d5		       88		      dey
    747  13d6		       b1 48		      lda	(MATHSTACK),y
    748  13d8		       85 55		      sta	R1+1
    749  13da		       88		      dey
    750  13db		       b1 48		      lda	(MATHSTACK),y
    751  13dd		       85 54		      sta	R1
    752  13df		       84 4a		      sty	MATHSTACKPTR
    753  13e1		       ac fd 25 	      ldy	rtemp1
    754  13e4		       60		      rts
    755  13e5							;
    756  13e5							;=====================================================
    757  13e5							; This pops TOS and places it in MQ.
    758  13e5							;
    759  13e5		       8c fd 25    popMQ      sty	rtemp1
    760  13e8		       a4 4a		      ldy	MATHSTACKPTR
    761  13ea		       f0 a8		      beq	poperr
    762  13ec		       88		      dey
    763  13ed		       b1 48		      lda	(MATHSTACK),y
    764  13ef		       85 57		      sta	MQ+1
    765  13f1		       88		      dey
    766  13f2		       b1 48		      lda	(MATHSTACK),y
    767  13f4		       85 56		      sta	MQ
    768  13f6		       84 4a		      sty	MATHSTACKPTR
    769  13f8		       ac fd 25 	      ldy	rtemp1
    770  13fb		       60		      rts
    771  13fc							;
    772  13fc							;=====================================================
    773  13fc							; This assists with multiplication and division by
    774  13fc							; looking at R0 and R1 and saving a flag as to what
    775  13fc							; sign the result will be.  Math is always done on
    776  13fc							; positive numbers, so this converts negative numbers
    777  13fc							; into positives.  On exit, R0 and R1 are both
    778  13fc							; positive.  If the signs were different then 'signs'
    779  13fc							; will be non-zero.
    780  13fc							;
    781  13fc		       a9 00	   SaveSigns  lda	#0
    782  13fe		       8d fc 25 	      sta	sign	;assume positive
    783  1401		       a5 53		      lda	R0+1	;MSB
    784  1403		       10 13		      bpl	SaveSigns1
    785  1405		       ee fc 25 	      inc	sign	;it's negative
    786  1408		       49 ff		      eor	#$ff	;flip bits
    787  140a		       85 53		      sta	R0+1
    788  140c		       a5 52		      lda	R0
    789  140e		       49 ff		      eor	#$ff
    790  1410		       85 52		      sta	R0
    791  1412		       e6 52		      inc	R0
    792  1414		       d0 02		      bne	SaveSigns1
    793  1416		       e6 53		      inc	R0+1
    794  1418		       a5 55	   SaveSigns1 lda	R1+1
    795  141a		       10 1a		      bpl	SaveSigns2
    796  141c		       48		      pha
    797  141d		       ad fc 25 	      lda	sign
    798  1420		       49 01		      eor	#1
    799  1422		       8d fc 25 	      sta	sign
    800  1425		       68		      pla
    801  1426		       49 ff		      eor	#$ff	;flip bits
    802  1428		       85 55		      sta	R1+1
    803  142a		       a5 54		      lda	R1
    804  142c		       49 ff		      eor	#$ff
    805  142e		       85 54		      sta	R1
    806  1430		       e6 54		      inc	R1
    807  1432		       d0 02		      bne	SaveSigns2
    808  1434		       e6 55		      inc	R1+1
    809  1436		       60	   SaveSigns2 rts
    810  1437							;
    811  1437							;=====================================================
    812  1437							; This looks at the value of 'signs' and will convert
    813  1437							; both R0 and R1 to negative if set.
    814  1437							;
    815  1437				   RestoreSigns
    816  1437		       ad fc 25 	      lda	sign
    817  143a		       f0 28		      beq	restoresigns2
    818  143c							;
    819  143c		       a5 52		      lda	R0
    820  143e		       d0 02		      bne	restoresigns3
    821  1440		       c6 53		      dec	R0+1
    822  1442				   restoresigns3
    823  1442		       c6 52		      dec	R0
    824  1444		       a5 52		      lda	R0
    825  1446		       49 ff		      eor	#$ff
    826  1448		       85 52		      sta	R0
    827  144a		       a5 53		      lda	R0+1
    828  144c		       49 ff		      eor	#$ff
    829  144e		       85 53		      sta	R0+1
    830  1450							;
    831  1450		       a5 54		      lda	R1
    832  1452		       d0 02		      bne	restoresigns4
    833  1454		       c6 55		      dec	R1+1
    834  1456				   restoresigns4
    835  1456		       c6 54		      dec	R1
    836  1458		       a5 54		      lda	R1
    837  145a		       49 ff		      eor	#$ff
    838  145c		       85 54		      sta	R1
    839  145e		       a5 55		      lda	R1+1
    840  1460		       49 ff		      eor	#$ff
    841  1462		       85 55		      sta	R1+1
    842  1464							;
    843  1464				   restoresigns2
    844  1464		       60		      rts
    845  1465							;
    846  1465							;=====================================================
    847  1465							; Skip over spaces.  Returns Y with the offset to
    848  1465							; either the last character in the line, or the first
    849  1465							; non-space character.
    850  1465							;
    851  1465
    852  1465		       c8	   skipsp2    iny
    853  1466		       b1 4f	   SkipSpaces lda	(CURPTR),y
    854  1468		       f0 04		      beq	Skip3	;end of line
    855  146a		       c9 20		      cmp	#SPACE
    856  146c		       f0 f7		      beq	skipsp2
    857  146e		       60	   Skip3      rts
    858  146f							;*********************************************************
    859  146f							; Output a CR/LF combination to the console.  Preserves
    860  146f							; all registers.
    861  146f							;
    862  146f		       48	   tbcrlf     pha
    863  1470		       a9 0d		      lda	#CR
    864  1472		       20 eb 15 	      jsr	VOUTCH
    865  1475		       a9 0a		      lda	#LF
    866  1477		       20 eb 15 	      jsr	VOUTCH
    867  147a		       68		      pla
    868  147b		       60		      rts
    869  147c							;
    870  147c							;=====================================================
    871  147c							; Some logic to print the Line of basic code being executed
    872  147c		       24 40	   idbgBasic  bit	ILTrace
    873  147e		       50 70		      bvc	dbgBasicNone
    874  1480		       98		      tya
    875  1481		       48		      pha
    876  1482		       20 91 16 	      jsr	SetOutDebug
    877  1485		       20 14 16 	      jsr	PrtPrgLine
    878  1488		       20 6f 14 	      jsr	CRLF
    879  148b		       a5 40		      lda	ILTrace
    880  148d		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    881  148f		       f0 5a		      beq	dbgBasicDone
    882  1491		       20 9c 16 	      jsr	SetInDebug
    883  1494		       20 f1 15 	      jsr	puts
      0  1497					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1497		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    885  14d4				   dbgBasicLoop
    886  14d4		       20 ee 15 	      jsr	VGETCH
    887  14d7		       20 6f 14 	      jsr	CRLF
    888  14da		       20 de 15 	      jsr	SetInConsole
    889  14dd
    890  14dd		       c9 73		      cmp	#'s	; Quit program
    891  14df		       f0 12		      beq	dbgBasicStop
    892  14e1
    893  14e1		       c9 64		      cmp	#'d	; Display Variables
    894  14e3		       d0 06		      bne	dbgBasicDone
    895  14e5
    896  14e5		       20 c0 16 	      jsr	PrintAllVars
    897  14e8		       18		      clc
    898  14e9		       90 e9		      bcc	dbgBasicLoop	; Next char
    899  14eb
    900  14eb		       20 d1 15    dbgBasicDone jsr	SetOutConsole
    901  14ee		       68		      pla
    902  14ef		       a8		      tay
    903  14f0		       4c b9 02    dbgBasicNone jmp	NextIL
    904  14f3
    905  14f3				   dbgBasicStop
    906  14f3		       20 d1 15 	      jsr	SetOutConsole
    907  14f6		       68		      pla
    908  14f7		       a8		      tay
    909  14f8		       4c eb 05 	      jmp	iFIN
    910  14fb							;
    911  14fb							;=====================================================
    912  14fb							; This is some debug logic which displays the current
    913  14fb							; value of the ILPC and the line buffer.
    914  14fb							;
    915  14fb		       24 40	   dbgLine    bit	ILTrace
    916  14fd		       30 01		      bmi	dbgPrt
    917  14ff		       60		      rts
    918  1500				   dbgPrt
    919  1500		       20 91 16 	      jsr	SetOutDebug
    920  1503		       20 f1 15 	      jsr	puts
      0  1506					      db	"ILPC: ",0
      1  1506		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    922  150d		       a5 44		      lda	ILPC+1
    923  150f		       20 4a 16 	      jsr	OUTHEX
    924  1512		       a5 43		      lda	ILPC
    925  1514		       20 4a 16 	      jsr	OUTHEX
    926  1517		       a9 20		      lda	#SPACE
    927  1519		       20 eb 15 	      jsr	VOUTCH
    928  151c		       a0 00		      ldy	#0
    929  151e		       b1 43		      lda	(ILPC),y
    930  1520		       20 4a 16 	      jsr	OUTHEX
    931  1523							;
    932  1523							; Display the CURPTR value and offset
    933  1523							;
    934  1523		       20 f1 15 	      jsr	puts
      0  1526					      db	", CURPTR: ",0
      1  1526		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    936  1531		       a5 50		      lda	CURPTR+1
    937  1533		       20 4a 16 	      jsr	OUTHEX
    938  1536		       a5 4f		      lda	CURPTR
    939  1538		       20 4a 16 	      jsr	OUTHEX
    940  153b		       a9 2b		      lda	#'+
    941  153d		       20 eb 15 	      jsr	VOUTCH
    942  1540		       a5 51		      lda	CUROFF
    943  1542		       20 4a 16 	      jsr	OUTHEX
    944  1545							;
    945  1545		       20 6f 14 	      jsr	CRLF
    946  1548		       20 d1 15 	      jsr	SetOutConsole
    947  154b		       20 7e 15 	      jsr	ILChkRange
    948  154e		       b0 02		      bcs	dbgLineErr
    949  1550		       18		      clc
    950  1551		       60		      rts
    951  1552
    952  1552				   dbgLineErr
    953  1552		       20 91 16 	      jsr	SetOutDebug
    954  1555		       20 f1 15 	      jsr	puts
      0  1558					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1558		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    956  1579		       20 d1 15 	      jsr	SetOutConsole
    957  157c		       38		      sec
    958  157d		       60		      rts
    959  157e
    960  157e		       a5 44	   ILChkRange lda	ILPC+1
    961  1580		       c9 18		      cmp	#IL>>8
    962  1582		       90 18		      bcc	ILBadRange
    963  1584		       d0 06		      bne	ILChkHigh
    964  1586
    965  1586		       a5 43		      lda	ILPC
    966  1588		       c9 18		      cmp	#IL&$ff
    967  158a		       90 10		      bcc	ILBadRange
    968  158c
    969  158c		       a5 44	   ILChkHigh  lda	ILPC+1
    970  158e		       c9 1c		      cmp	#ILEND>>8
    971  1590		       90 08		      bcc	ILGoodRange
    972  1592		       d0 08		      bne	ILBadRange
    973  1594
    974  1594		       a5 43		      lda	ILPC
    975  1596		       c9 a1		      cmp	#ILEND&$ff
    976  1598		       b0 02		      bcs	ILBadRange
    977  159a
    978  159a		       18	   ILGoodRange clc
    979  159b		       60		      rts
    980  159c				   ILBadRange
    981  159c		       38		      sec
    982  159d		       60		      rts
    983  159e
    984  159e							;
    985  159e							;=====================================================
    986  159e							; This function might go away eventually, but was
    987  159e							; added to provide data for other pieces of code.
    988  159e							; It has some ties to the operating environment that
    989  159e							; will need to be customized for the target system.
    990  159e							;
    991  159e				   GetSizes
    992  159e							;
    993  159e							; Here is machine specific code to get the highest
    994  159e							; memory location that can be used by BASIC.
    995  159e							;
    996  159e				  -	      if	ProgramStart < $2000
    997  159e				  -	      lda	#$ff
    998  159e				  -	      sta	HighMem	;$13ff for KIM-1
    999  159e				  -	      lda	#$DE	;#$13
   1000  159e				  -	      sta	HighMem+1
   1001  159e					      else
   1002  159e		       a9 ff		      lda	#$ff
   1003  15a0		       8d 08 26 	      sta	HighMem	;$CFFF otherwise
   1004  15a3		       a9 cf		      lda	#$cf
   1005  15a5		       8d 09 26 	      sta	HighMem+1
   1006  15a8					      endif
   1007  15a8							;
   1008  15a8							; This computes the available memory remaining.
   1009  15a8							;
   1010  15a8		       38		      sec
   1011  15a9		       ad 08 26 	      lda	HighMem
   1012  15ac		       ed 06 26 	      sbc	PROGRAMEND
   1013  15af		       8d 0c 26 	      sta	FreeMem
   1014  15b2		       85 52		      sta	R0
   1015  15b4		       ad 09 26 	      lda	HighMem+1
   1016  15b7		       ed 07 26 	      sbc	PROGRAMEND+1
   1017  15ba		       8d 0d 26 	      sta	FreeMem+1
   1018  15bd		       85 53		      sta	R0+1
   1019  15bf							;
   1020  15bf							; This computes the size of the current user program.
   1021  15bf							;
   1022  15bf		       38		      sec
   1023  15c0		       ad 06 26 	      lda	PROGRAMEND
   1024  15c3		       e9 0e		      sbc	#ProgramStart&$ff
   1025  15c5		       8d 0a 26 	      sta	UsedMem
   1026  15c8		       ad 07 26 	      lda	PROGRAMEND+1
   1027  15cb		       e9 26		      sbc	#ProgramStart>>8
   1028  15cd		       8d 0b 26 	      sta	UsedMem+1
   1029  15d0							;
   1030  15d0		       60		      rts
   1031  15d1							;
   1032  15d1							;=====================================================
   1033  15d1							; Set output vector to the console output function
   1034  15d1							;
   1035  15d1				   SetOutConsole
   1036  15d1		       48		      pha
   1037  15d2		       a9 0c		      lda	#OUTCH&$ff
   1038  15d4		       8d 01 26 	      sta	BOutVec
   1039  15d7		       a9 f0		      lda	#OUTCH>>8
   1040  15d9		       8d 02 26 	      sta	BOutVec+1
   1041  15dc		       68		      pla
   1042  15dd		       60		      rts
   1043  15de
   1044  15de				   SetInConsole
   1045  15de		       48		      pha
   1046  15df		       a9 09		      lda	#GETCH&$ff
   1047  15e1		       8d 03 26 	      sta	BInVec
   1048  15e4		       a9 f0		      lda	#GETCH>>8
   1049  15e6		       8d 04 26 	      sta	BInVec+1
   1050  15e9		       68		      pla
   1051  15ea		       60		      rts
   1052  15eb
   1053  15eb							;=====================================================
   1054  15eb							; Jump to the output/input function in BOutVec/BInVec
   1055  15eb							;
   1056  15eb		       6c 01 26    VOUTCH     jmp	(BOutVec)
   1057  15ee		       6c 03 26    VGETCH     jmp	(BInVec)
   1058  15f1							;
   1059  15f1							;=====================================================
   1060  15f1							; Print the string that immediately follows the JSR to
   1061  15f1							; this function.  Stops when a null byte is found,
   1062  15f1							; then returns to the instruction immediately
   1063  15f1							; following the null.
   1064  15f1							;
   1065  15f1							; Thanks to Ross Archer for this code.
   1066  15f1							; http://www.6502.org/source/io/primm.htm
   1067  15f1							;
   1068  15f1
   1069  15f1		       68	   tbputs     pla		;Get the low part of "return" address
   1070  15f2							;(data start address)
   1071  15f2		       85 65		      sta	PrtFrom
   1072  15f4		       68		      pla
   1073  15f5		       85 66		      sta	PrtFrom+1	;Get the high part of "return" address
   1074  15f7							;(data start address)
   1075  15f7							;Note: actually we're pointing one short
   1076  15f7		       a0 01	   PSINB      ldy	#1
   1077  15f9		       b1 65		      lda	(PrtFrom),y	;Get the next string character
   1078  15fb		       e6 65		      inc	PrtFrom	;update the pointer
   1079  15fd		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
   1080  15ff		       e6 66		      inc	PrtFrom+1	;account for page crossing
   1081  1601		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
   1082  1603							;   Accumulator
   1083  1603		       f0 06		      beq	PSIX1	;don't print the final NULL
   1084  1605		       20 eb 15 	      jsr	VOUTCH	;write it out
   1085  1608		       4c f7 15 	      jmp	PSINB	;back around
   1086  160b		       e6 65	   PSIX1      inc	PrtFrom
   1087  160d		       d0 02		      bne	PSIX2
   1088  160f		       e6 66		      inc	PrtFrom+1	;account for page crossing
   1089  1611		       6c 65 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
   1090  1614
   1091  1614							;
   1092  1614
   1093  1614							;====================================================
   1094  1614		       26 05	   PrtTerm    equ	tempy
   1095  1614
   1096  1614							; on exit Print Y has the offset to use
   1097  1614							; input y =	 addr low
   1098  1614							;	 x =	 addr high
   1099  1614							;	 a =	 termination string
   1100  1614
   1101  1614				   PrtPrgLine
   1102  1614		       a9 00		      lda	#0
   1103  1616		       8d 05 26 	      sta	PrtTerm
   1104  1619		       f0 05		      beq	PrtPrgText
   1105  161b
   1106  161b		       a9 22	   PrtQuoted  lda	#'"
   1107  161d		       8d 05 26 	      sta	PrtTerm
   1108  1620
   1109  1620		       a4 51	   PrtPrgText ldy	CUROFF
   1110  1622		       a5 4f		      lda	CURPTR
   1111  1624		       85 65		      sta	PrtFrom
   1112  1626		       a5 50		      lda	CURPTR+1
   1113  1628		       85 66		      sta	PrtFrom+1
   1114  162a		       4c 36 16 	      jmp	PrtLoop
   1115  162d
   1116  162d							; Print a string pointed to by x= h, y=l terminated by a
   1117  162d							; Return y as the length
   1118  162d
   1119  162d		       86 66	   PrtStr     stx	PrtFrom+1
   1120  162f		       84 65		      sty	PrtFrom
   1121  1631		       8d 05 26 	      sta	PrtTerm
   1122  1634		       a0 00		      ldy	#0
   1123  1636							;
   1124  1636							; On entry here ptrfrom and prtterm point to area to print
   1125  1636							;
   1126  1636		       b1 65	   PrtLoop    lda	(PrtFrom),y
   1127  1638		       cd 05 26 	      cmp	PrtTerm
   1128  163b		       f0 0b		      beq	PrtEnd
   1129  163d		       c9 00		      cmp	#0	; always end if 0 is found
   1130  163f		       f0 07		      beq	PrtEnd
   1131  1641		       20 eb 15 	      jsr	VOUTCH
   1132  1644		       c8		      iny
   1133  1645		       4c 36 16 	      jmp	PrtLoop
   1134  1648		       c8	   PrtEnd     iny		;return byte after the copy
   1135  1649		       60		      rts
   1136  164a							;=====================================================
   1137  164a							; Print character in A as two hex digits to the
   1138  164a							; current output device (console or file).
   1139  164a							;
   1140  164a		       48	   HexToOut   pha		;save return value
   1141  164b		       48		      pha
   1142  164c		       4a		      lsr		;a  ;move top nibble to bottom
   1143  164d		       4a		      lsr		;a
   1144  164e		       4a		      lsr		;a
   1145  164f		       4a		      lsr		;a
   1146  1650		       20 59 16 	      jsr	hexta	;output nibble
   1147  1653		       68		      pla
   1148  1654		       20 59 16 	      jsr	hexta
   1149  1657		       68		      pla		;restore
   1150  1658		       60		      rts
   1151  1659							;
   1152  1659		       29 0f	   hexta      and	#%0001111
   1153  165b		       c9 0a		      cmp	#$0a
   1154  165d		       18		      clc
   1155  165e		       30 02		      bmi	hexta1
   1156  1660		       69 07		      adc	#7
   1157  1662		       69 30	   hexta1     adc	#'0	;then fall into...
   1158  1664		       4c eb 15 	      jmp	VOUTCH
   1159  1667							;====================================================
   1160  1667							;Clear the terminal assume it is ansii or vt100
   1161  1667							;
   1162  1667				   iCLEARSCREEN
   1163  1667		       20 f1 15 	      jsr	puts
      0  166a					      db	$1b,'[,'3,'J,0
      1  166a		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
   1165  166f		       4c b9 02 	      jmp	NextIL
   1166  1672
   1167  1672							;====================================================
   1168  1672							; Push true and false onto math stack
   1169  1672				   pushTrue
   1170  1672		       a9 ff		      lda	#$ff
   1171  1674		       85 52	   pushTF     sta	R0
   1172  1676		       85 53		      sta	R0+1
   1173  1678		       20 32 13 	      jsr	pushR0
   1174  167b		       60		      rts
   1175  167c		       a9 00	   pushFalse  lda	#0
   1176  167e		       f0 f4		      beq	pushTF
   1177  1680
   1178  1680							;======================================================
   1179  1680							; Copy stack top to R1
   1180  1680				   CopyStackR1
   1181  1680		       98		      tya
   1182  1681		       48		      pha
   1183  1682		       a4 4a		      ldy	MATHSTACKPTR
   1184  1684		       88		      dey
   1185  1685		       b1 48		      lda	(MATHSTACK),y
   1186  1687		       85 55		      sta	R1+1
   1187  1689		       88		      dey
   1188  168a		       b1 48		      lda	(MATHSTACK),y
   1189  168c		       85 54		      sta	R1
   1190  168e		       68		      pla
   1191  168f		       a8		      tay
   1192  1690		       60		      rts
   1193  1691
   1194  1691
   1195  1691							;====================================================
   1196  1691							;Swap the out debug call for standard calls
   1197  1691
   1198  1691				   SetOutDebug
   1199  1691					      if	USEDEBUGPORT
   1200  1691		       a9 b1		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1201  1693		       8d 01 26 	      sta	BOutVec
   1202  1696		       a9 16		      lda	#OUTDEBUG>>8
   1203  1698		       8d 02 26 	      sta	BOutVec+1
   1204  169b					      endif
   1205  169b		       60		      rts
   1206  169c				   SetInDebug
   1207  169c					      if	USEDEBUGPORT
   1208  169c		       a9 b5		      lda	#INDEBUG&$ff
   1209  169e		       8d 03 26 	      sta	BInVec
   1210  16a1		       a9 16		      lda	#INDEBUG>>8
   1211  16a3		       8d 04 26 	      sta	BInVec+1
   1212  16a6					      endif
   1213  16a6		       60		      rts
   1214  16a7							;
   1215  16a7							;====================================================
   1216  16a7							; Output to the debug console
   1217  16a7							;     x = high address byte
   1218  16a7							;     y = low address byte
   1219  16a7							;     a = Terminator for string
   1220  16a7				   DebugWrite
   1221  16a7		       20 91 16 	      jsr	SetOutDebug
   1222  16aa		       20 2d 16 	      jsr	PrtStr
   1223  16ad		       20 d1 15 	      jsr	SetOutConsole
   1224  16b0		       60		      rts
   1225  16b1
   1226  16b1				   OUTDEBUG
   1227  16b1		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1228  16b4		       60		      RTS
   1229  16b5
   1230  16b5		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1231  16b8		       29 01		      and	#$01
   1232  16ba		       f0 f9		      beq	INDEBUG
   1233  16bc		       ad 21 e0 	      lda	DEBUGPORT+1
   1234  16bf		       60		      rts
   1235  16c0							;
   1236  16c0							;=======================================================
   1237  16c0							; Print all Variables
   1238  16c0				   PrintAllVars
   1239  16c0		       a0 00		      ldy	#0
   1240  16c2		       a9 41		      lda	#'A
   1241  16c4				   PrintAllVarsLoop
   1242  16c4		       48		      pha
   1243  16c5		       b1 41		      lda	(VARIABLES),y
   1244  16c7		       85 52		      sta	R0
   1245  16c9		       c8		      iny
   1246  16ca		       b1 41		      lda	(VARIABLES),y
   1247  16cc		       85 53		      sta	R0+1
   1248  16ce
   1249  16ce		       68		      pla		;get the current letter
   1250  16cf		       48		      pha
   1251  16d0		       20 eb 15 	      jsr	VOUTCH
   1252  16d3		       20 f1 15 	      jsr	puts
      0  16d6					      db	"=",0
      1  16d6		       3d 00		      .byte.b	"=",0
   1254  16d8		       68		      pla
   1255  16d9		       aa		      tax
   1256  16da		       e8		      inx
   1257  16db		       8a		      txa
   1258  16dc		       48		      pha		;
   1259  16dd
   1260  16dd		       98		      tya
   1261  16de		       48		      pha
   1262  16df		       20 7d 11 	      jsr	PrintDecimal
   1263  16e2		       20 f1 15 	      jsr	puts
      0  16e5					      db	" ",0
      1  16e5		       20 00		      .byte.b	" ",0
   1265  16e7		       68		      pla
   1266  16e8		       a8		      tay
   1267  16e9		       c8		      iny
   1268  16ea		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1269  16ec		       90 d6		      bcc	PrintAllVarsLoop
   1270  16ee		       20 6f 14 	      jsr	CRLF
   1271  16f1
   1272  16f1		       68		      pla
   1273  16f2		       60		      rts
   1274  16f3
   1275  16f3
   1276  16f3
   1277  16f3
   1278  16f3
   1279  16f3
   1280  16f3
   1281  16f3
   1282  16f3
   1283  16f3
   1284  16f3
   1285  16f3
   1286  16f3
   1287  16f3
   1288  16f3
   1289  16f3
   1290  16f3
   1291  16f3
   1292  16f3
------- FILE mytb.asm
   2156  16f3
   2157  16f3					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  16f3					      include	"storage.asm"
      1  16f3							;
      2  16f3							;=====================================================
      3  16f3							;=====================================================
      4  16f3							;=====================================================
      5  16f3							; This file contains the functions for saving and
      6  16f3							; restoring programs from some sort of mass storage
      7  16f3							; device.  This particular version is for using the
      8  16f3							; Corsham Tech SD Card System.
      9  16f3							;=====================================================
     10  16f3							;=====================================================
     11  16f3							;=====================================================
     12  16f3
     13 U1ca1					      seg.u	TBData
     14 U1ca1		       00	   diskBufLength ds	1
     15 U1ca2		       00	   diskBufOffset ds	1
     16 U1ca3		       00 00 00 00*DiskFileName ds	14
     17 U1cb1
     18  16f3					      SEG	Code
     19  16f3
     20  16f3							;
     21  16f3							;=====================================================
     22  16f3							; Open a file for reading as a program.  The next
     23  16f3							; thing on the line should be the filename.
     24  16f3							;
     25  16f3				   iOPENREAD
     26  16f3					      if	XKIM || CTMON65
     27  16f3		       a4 51		      ldy	CUROFF
     28  16f5		       b1 4f		      lda	(CURPTR),y
     29  16f7		       d0 07		      bne	iOPENfn	;might be filename
     30  16f9							;
     31  16f9							; No filename supplied.
     32  16f9							;
     33  16f9		       a9 00	   iOPENnofn  lda	#0
     34  16fb		       a2 09		      ldx	#ERR_NO_FILENAME
     35  16fd		       4c 02 06 	      jmp	iErr2
     36  1700							;
     37  1700							; Add the offset into the buffer start
     38  1700							;
     39  1700		       18	   iOPENfn    clc
     40  1701		       98		      tya
     41  1702		       65 4f		      adc	CURPTR
     42  1704		       a8		      tay		;LSB
     43  1705		       a5 50		      lda	CURPTR+1
     44  1707		       69 00		      adc	#0
     45  1709		       aa		      tax
     46  170a		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  170d		       90 07		      bcc	Ropenok	;branch if opened ok
     48  170f							;
     49  170f							; Open failed
     50  170f							;
     51  170f		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1711		       a9 00	   Rdfail2    lda	#0
     53  1713		       4c 02 06 	      jmp	iErr2
     54  1716							;
     55  1716							; Clear counts and offsets so the next read will
     56  1716							; cause the file to be read.
     57  1716							;
     58  1716		       a9 00	   Ropenok    lda	#0
     59  1718		       8d a2 1c 	      sta	diskBufOffset
     60  171b		       8d a1 1c 	      sta	diskBufLength
     61  171e		       4c b9 02 	      jmp	NextIL
     62  1721					      endif
     63  1721
     64  1721							;
     65  1721							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1721							;Remove a file from the disk
     67  1721				   iRMFILE
     68  1721					      if	XKIM || CTMON65
     69  1721		       a4 51		      ldy	CUROFF
     70  1723		       b1 4f		      lda	(CURPTR),y
     71  1725		       f0 19		      beq	iRMnofn
     72  1727							;
     73  1727		       18		      clc
     74  1728		       98		      tya
     75  1729		       65 4f		      adc	CURPTR
     76  172b		       a8		      tay		;LSB
     77  172c		       a5 50		      lda	CURPTR+1
     78  172e		       69 00		      adc	#0
     79  1730		       aa		      tax
     80  1731		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1734		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1736		       a9 00		      lda	#0
     83  1738		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  173a		       4c 02 06 	      jmp	iErr2
     85  173d		       4c b9 02    wrmOk      jmp	NextIL
     86  1740
     87  1740							; No filename supplied.
     88  1740							;
     89  1740		       a9 00	   iRMnofn    lda	#0
     90  1742		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1744		       4c 02 06 	      jmp	iErr2
     92  1747					      endif
     93  1747							;
     94  1747							;=====================================================
     95  1747				   iOPENWRITE
     96  1747					      if	XKIM || CTMON65
     97  1747		       a4 51		      ldy	CUROFF
     98  1749		       b1 4f		      lda	(CURPTR),y
     99  174b		       f0 f3		      beq	iRMnofn
    100  174d							;
    101  174d		       18		      clc
    102  174e		       98		      tya
    103  174f		       65 4f		      adc	CURPTR
    104  1751		       a8		      tay		;LSB
    105  1752		       a5 50		      lda	CURPTR+1
    106  1754		       69 00		      adc	#0
    107  1756		       aa		      tax
    108  1757		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  175a		       90 07		      bcc	Wopenok	;branch if opened ok
    110  175c							;
    111  175c							; Open failed
    112  175c							;
    113  175c		       a9 00	   Wdfail     lda	#0
    114  175e		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1760		       4c 02 06 	      jmp	iErr2
    116  1763							;
    117  1763		       4c b9 02    Wopenok    jmp	NextIL
    118  1766					      endif
    119  1766							;
    120  1766							;=====================================================
    121  1766							; Gets a line of input from the disk file and puts it
    122  1766							; into LINBUF.
    123  1766							;
    124  1766							; On exit:
    125  1766							;    CURPTR points to LINBUF
    126  1766							;    LINBUF contains the line with 0 at the end.
    127  1766							;    Y has offset to first non-space character
    128  1766							;    CURROFF has the same as Y.
    129  1766							;
    130  1766				   iDGETLINE
    131  1766					      if	XKIM || CTMON65
    132  1766		       a2 70		      ldx	#LINBUF&$ff
    133  1768		       86 4f		      stx	CURPTR
    134  176a		       a2 25		      ldx	#LINBUF>>8
    135  176c		       86 50		      stx	CURPTR+1
    136  176e							;
    137  176e		       a2 00		      ldx	#0	;offset
    138  1770		       8e f4 25    iDgetLoop  stx	getlinx
    139  1773		       20 d1 17 	      jsr	getNextFileByte
    140  1776		       b0 16		      bcs	iGetEOF
    141  1778		       c9 0d		      cmp	#CR
    142  177a		       f0 0d		      beq	iGetEOL
    143  177c		       c9 0a		      cmp	#LF
    144  177e		       f0 09		      beq	iGetEOL
    145  1780		       ae f4 25 	      ldx	getlinx
    146  1783		       9d 70 25 	      sta	LINBUF,x
    147  1786		       e8		      inx
    148  1787		       d0 e7		      bne	iDgetLoop
    149  1789							;
    150  1789							; Handle end of line.	If the line has nothing, loop
    151  1789							; back and get another line.
    152  1789							;
    153  1789		       ae f4 25    iGetEOL    ldx	getlinx	;blank line?
    154  178c		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  178e							;
    156  178e							; This can fall through when there is a line, or
    157  178e							; called directly when EOF is encountered.
    158  178e							;
    159  178e		       ae f4 25    iGetEOF    ldx	getlinx
    160  1791		       a9 00		      lda	#0
    161  1793		       9d 70 25 	      sta	LINBUF,x
    162  1796		       85 51		      sta	CUROFF
    163  1798		       a0 00		      ldy	#0
    164  179a		       20 66 14 	      jsr	SkipSpaces
    165  179d		       4c b9 02 	      jmp	NextIL
    166  17a0					      endif
    167  17a0
    168  17a0							;
    169  17a0							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  17a0							; DISK
    171  17a0							;
    172  17a0				   iDDIR
    173  17a0					      if	XKIM || CTMON65
    174  17a0		       20 30 f0 	      jsr	DiskDir
    175  17a3							;
    176  17a3							; Get/Display each entry
    177  17a3							;
    178  17a3		       a2 1c	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  17a5		       a0 a3		      ldy	#DiskFileName&$ff
    180  17a7		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  17aa		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  17ac		       20 f1 15 	      jsr	puts
      0  17af					      db	"   ",0
      1  17af		       20 20 20 00	      .byte.b	"   ",0
    184  17b3							; Print the line to the console
    185  17b3		       a2 1c		      ldx	#DiskFileName>>8	;pointer to buffer
    186  17b5		       a0 a3		      ldy	#DiskFileName&$ff
    187  17b7		       a5 00		      lda	0
    188  17b9		       20 2d 16 	      jsr	PrtStr	;else print name
    189  17bc		       20 18 f0 	      jsr	crlf
    190  17bf
    191  17bf		       4c a3 17 	      jmp	DiskDirLoop	;do next entry
    192  17c2
    193  17c2		       4c b9 02    DiskDirEnd jmp	NextIL
    194  17c5					      endif
    195  17c5							;
    196  17c5							;=====================================================
    197  17c5							; Does a LIST to a Disk file.
    198  17c5							;
    199  17c5				   iDLIST
    200  17c5					      if	XKIM || CTMON65
    201  17c5		       20 00 18 	      jsr	SetOutDisk
    202  17c8		       4c d2 07 	      jmp	iLST2
    203  17cb					      endif
    204  17cb							;
    205  17cb							;=====================================================
    206  17cb							; Closes any pending disk file.  Okay to call if there
    207  17cb							; is no open file.
    208  17cb							;
    209  17cb				   iDCLOSE
    210  17cb					      if	XKIM || CTMON65
    211  17cb		       20 42 f0 	      jsr	DiskClose
    212  17ce		       4c b9 02 	      jmp	NextIL
    213  17d1					      endif
    214  17d1							;
    215  17d1							;=====================================================
    216  17d1							; This gets the next byte from an open disk file.  If
    217  17d1							; there are no more bytes left, this returns C set.
    218  17d1							; Else, C is clear and A contains the character.
    219  17d1							;
    220  17d1				   getNextFileByte
    221  17d1					      if	XKIM || CTMON65
    222  17d1		       ae a2 1c 	      ldx	diskBufOffset
    223  17d4		       ec a1 1c 	      cpx	diskBufLength
    224  17d7		       d0 14		      bne	hasdata	;branch if still data
    225  17d9							;
    226  17d9							; There is no data left in the buffer, so read a
    227  17d9							; block from the SD system.
    228  17d9							;
    229  17d9		       a9 84		      lda	#BUFFER_SIZE
    230  17db		       a2 df		      ldx	#buffer>>8
    231  17dd		       a0 0a		      ldy	#buffer&$ff
    232  17df		       20 3c f0 	      jsr	DiskRead
    233  17e2		       b0 12		      bcs	getNextEof
    234  17e4							;
    235  17e4							; A contains the number of bytes actually read.
    236  17e4							;
    237  17e4		       8d a1 1c 	      sta	diskBufLength	;save length
    238  17e7		       c9 00		      cmp	#0	;shouldn't happen
    239  17e9		       f0 0b		      beq	getNextEof
    240  17eb							;
    241  17eb		       a2 00		      ldx	#0
    242  17ed		       bd 0a df    hasdata    lda	buffer,x
    243  17f0		       e8		      inx
    244  17f1		       8e a2 1c 	      stx	diskBufOffset
    245  17f4		       18		      clc
    246  17f5		       60		      rts
    247  17f6							;
    248  17f6		       a9 00	   getNextEof lda	#0
    249  17f8		       8d a2 1c 	      sta	diskBufOffset
    250  17fb		       8d a1 1c 	      sta	diskBufLength
    251  17fe		       38		      sec
    252  17ff		       60		      rts
    253  1800							;
    254  1800							;=====================================================
    255  1800							; Set output vector to the disk output function
    256  1800							;
    257  1800		       a9 0b	   SetOutDisk lda	#DOUT&$ff
    258  1802		       8d 01 26 	      sta	BOutVec
    259  1805		       a9 18		      lda	#DOUT/256
    260  1807		       8d 02 26 	      sta	BOutVec+1
    261  180a		       60		      rts
    262  180b							;
    263  180b							;=====================================================
    264  180b
    265  180b		       8d 0a df    DOUT       sta	buffer
    266  180e		       a9 01		      lda	#1
    267  1810		       a0 0a		      ldy	#buffer&$ff
    268  1812		       a2 df		      ldx	#buffer>>8
    269  1814		       20 3f f0 	      jsr	DiskWrite
    270  1817							;
    271  1817							; need error checking here
    272  1817							;
    273  1817		       60		      rts
    274  1818					      endif
    275  1818
    276  1818
------- FILE mytb.asm
   2159  1818					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1818					      include	"IL.inc"
      1  1818
      2  1818							;=====================================================
      3  1818							; IL.inc
      4  1818							; These are macros for IL instructions
      5  1818							;
      6  1818					      mac	dw
      7  1818					      .word	{0}
      8  1818					      endm
      9  1818					      mac	db
     10  1818					      .byte	{0}
     11  1818					      endm
     12  1818					      macro	xinit
     13  1818					      db	0
     14  1818					      endm		;reset the il to start clear all
     15  1818							;
     16  1818					      macro	done
     17  1818					      db	1
     18  1818					      endm		;print an error if not end of line
     19  1818							;
     20  1818					      macro	prs
     21  1818					      db	2
     22  1818					      endm		;print a quoted string
     23  1818							;
     24  1818					      macro	prn
     25  1818					      db	3
     26  1818					      endm		;print a number
     27  1818							;
     28  1818					      macro	spc
     29  1818					      db	4
     30  1818					      endm		;print space til new tabstop
     31  1818							;
     32  1818					      macro	nline
     33  1818					      db	5
     34  1818					      endm		;print a new line crlf
     35  1818							;
     36  1818							; My NXT is a bit different in that it takes one
     37  1818							; parameter, which is an address.  If the BASIC
     38  1818							; program is currently running then move to the
     39  1818							; next line and continue execution.  However, if
     40  1818							; in direct mode, jump to the specified IL label.
     41  1818							;
     42  1818					      macro	nxt
     43  1818					      db	6
     44  1818					      dw	{1}	; addr
     45  1818					      endm		; addr
     46  1818							;
     47  1818					      macro	xfer
     48  1818					      db	7
     49  1818					      endm
     50  1818							;
     51  1818					      macro	sav
     52  1818					      db	8
     53  1818					      db	{1}
     54  1818					      endm
     55  1818							;
     56  1818					      macro	rstr
     57  1818					      db	9
     58  1818					      endm
     59  1818							;
     60  1818					      macro	cmpr
     61  1818					      db	10
     62  1818					      endm
     63  1818							;
     64  1818					      macro	innum
     65  1818					      db	11
     66  1818					      endm
     67  1818							;
     68  1818					      macro	fin
     69  1818					      db	12
     70  1818					      endm
     71  1818							;
     72  1818							; ERR is followed by an error number.	The error
     73  1818							; code is printed along with the line number.
     74  1818							; Control is passed to the statement set with
     75  1818							; the ERRGOTO statement.
     76  1818							;
     77  1818					      macro	errmsg
     78  1818					      db	13
     79  1818					      dw	{1}	;ecode
     80  1818					      endm		;ecode
     81  1818							;
     82  1818					      macro	add
     83  1818					      db	14
     84  1818					      endm
     85  1818							;
     86  1818					      macro	sub
     87  1818					      db	15
     88  1818					      endm
     89  1818							;
     90  1818					      macro	neg
     91  1818					      db	16
     92  1818					      endm
     93  1818							;
     94  1818					      macro	mul
     95  1818					      db	17
     96  1818					      endm
     97  1818							;
     98  1818					      macro	div
     99  1818					      db	18
    100  1818					      endm
    101  1818							;
    102  1818					      macro	store
    103  1818					      db	19
    104  1818					      endm
    105  1818							;
    106  1818					      macro	ind
    107  1818					      db	20
    108  1818					      endm
    109  1818							;
    110  1818					      macro	lst
    111  1818					      db	21
    112  1818					      endm
    113  1818							;
    114  1818					      macro	init
    115  1818					      db	22
    116  1818					      endm
    117  1818							;
    118  1818					      macro	getline
    119  1818					      db	23
    120  1818					      endm
    121  1818							;
    122  1818					      macro	insert
    123  1818					      db	24
    124  1818					      endm
    125  1818							;
    126  1818					      macro	rtn
    127  1818					      db	25
    128  1818					      endm
    129  1818							;
    130  1818					      macro	exit
    131  1818					      db	26
    132  1818					      endm
    133  1818							;
    134  1818					      macro	lit
    135  1818					      db	27
    136  1818					      dw	{1}	;value
    137  1818					      endm		; value LIT
    138  1818							;
    139  1818					      macro	call
    140  1818					      db	28
    141  1818					      dw	{1}	;addr
    142  1818					      endm		;addr
    143  1818							;
    144  1818							; IJMP will set the IL PC to the specified value.
    145  1818							;
    146  1818					      macro	ijmp
    147  1818					      db	29
    148  1818					      dw	{1}	;addr
    149  1818					      endm		;addr
    150  1818							;
    151  1818					      macro	vinit
    152  1818					      db	30
    153  1818					      endm
    154  1818							;
    155  1818							; ERRGOTO sets the point in the code where the IL
    156  1818							; interpreter will go after any error.
    157  1818							;
    158  1818					      macro	errgoto
    159  1818					      db	31
    160  1818					      dw	{1}	;addr
    161  1818					      endm		;addr
    162  1818							;
    163  1818					      macro	tst
    164  1818					      db	32
    165  1818					      db	({1}-*)-1	;(addr-*)-1
    166  1818					      db	{2},0	;string,0
    167  1818					      endm		;addr,string
    168  1818							;
    169  1818					      macro	tstv
    170  1818					      db	33
    171  1818					      db	({1}-*)-1	;(addr-*)-1
    172  1818					      endm		;addr
    173  1818							;
    174  1818					      macro	tstl
    175  1818					      db	34
    176  1818					      db	({1}-*)-1	;(addr-*)-1
    177  1818					      endm		;addr
    178  1818							;
    179  1818					      macro	tstn
    180  1818					      db	35
    181  1818					      db	({1}-*)-1	;(addr-*)-1
    182  1818					      endm		;addr
    183  1818							;
    184  1818							; FREE returns the amount of free RAM on top of
    185  1818							; the stack.  This is the amount of room the user
    186  1818							; program has available.
    187  1818							;
    188  1818					      macro	free
    189  1818					      db	36
    190  1818					      endm
    191  1818							;
    192  1818							; RANDOM takes the top item off the stack and
    193  1818							; replaces it with a random number that is
    194  1818							; MOD the initial value.  Ie, if the TOS is
    195  1818							; 42 then RANDOM returns a value from 0 to 41.
    196  1818							;
    197  1818					      macro	random
    198  1818					      db	37
    199  1818					      endm
    200  1818							;
    201  1818							; ABS will replace the top of stack with the
    202  1818							; absolute value.
    203  1818							;
    204  1818					      macro	abs
    205  1818					      db	38
    206  1818					      endm
    207  1818							;
    208  1818							; OPENREAD opens a file for reading, as in getting
    209  1818							; statements from it.
    210  1818							;
    211  1818					      macro	openread
    212  1818					      db	39
    213  1818					      endm
    214  1818							;
    215  1818							; OPENWRITE opens a file for writing, as in saving
    216  1818							; the current program to it.
    217  1818							;
    218  1818					      macro	openwrite
    219  1818					      db	40
    220  1818					      endm
    221  1818							;
    222  1818							; DCLOSE closes any open disk file.
    223  1818							;
    224  1818					      macro	dclose
    225  1818					      db	41
    226  1818					      endm
    227  1818							;
    228  1818							; DGETLINE gets one line from the disk file and puts it
    229  1818							; into LINBUFF.
    230  1818							;
    231  1818					      macro	dgetline
    232  1818					      db	42
    233  1818					      endm
    234  1818							;
    235  1818							; DLIST saves the program to an open disk file.
    236  1818							;
    237  1818					      macro	dlist
    238  1818					      db	43
    239  1818					      endm
    240  1818							; DDIR list the current directory
    241  1818							;
    242  1818					      macro	ddir
    243  1818					      db	44
    244  1818					      endm
    245  1818
    246  1818							; RMFILE remove a fle from disk
    247  1818					      macro	rmfile
    248  1818					      db	45
    249  1818					      endm
    250  1818
    251  1818							; CLEARSCREEN clear the screen
    252  1818					      macro	clearscreen
    253  1818					      db	46
    254  1818					      endm
    255  1818							; POKEMEM Poke value into memory
    256  1818					      macro	pokemem
    257  1818					      db	47
    258  1818					      endm
    259  1818							; PEEKMEM peek at value in memory
    260  1818					      macro	peekmem
    261  1818					      db	48
    262  1818					      endm
    263  1818							; TSTLET Test if the statement is a let without the keyword let
    264  1818					      macro	tstlet
    265  1818					      db	49
    266  1818					      db	({1}-*)-1	;(addr-*)-1
    267  1818					      endm		;addr
    268  1818							; TSTDONE if we reach the end of a statement
    269  1818					      macro	tstdone
    270  1818					      db	50
    271  1818					      db	({1}-*)-1	;(addr-*)-1
    272  1818					      endm		;addr
    273  1818							; GETCHAR	get a character from the input line leave it in RO
    274  1818					      macro	getchar
    275  1818					      db	51
    276  1818					      endm
    277  1818							; PUTCHAR	Put a character to the terminal
    278  1818					      macro	putchar
    279  1818					      db	52
    280  1818					      endm
    281  1818							; Call		Call a machine function return a to stack
    282  1818					      macro	callfunc
    283  1818					      db	53
    284  1818					      endm
    285  1818
    286  1818							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1818					      macro	ibranch
    288  1818					      db	54
    289  1818					      endm
    290  1818
    291  1818							; TSTSTR	 Tests for the open quote in a string
    292  1818					      macro	tststr
    293  1818					      db	55
    294  1818					      db	({1}-*)-1	;(addr-*)-1
    295  1818					      endm
    296  1818							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1818					      macro	setirq
    298  1818					      db	56
    299  1818					      endm
    300  1818
    301  1818							; TSTIRQ	Test for irq pending,
    302  1818							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1818					      macro	tstirq
    304  1818					      db	57
    305  1818					      db	({1}-*)-1	;(addr-*)-1
    306  1818					      endm
    307  1818
    308  1818							; IRET    return from interupt service
    309  1818					      macro	iret
    310  1818					      db	58
    311  1818					      endm
    312  1818
    313  1818							; INSTR   read a string from the input
    314  1818					      macro	instr
    315  1818					      db	59
    316  1818					      endm
    317  1818
    318  1818							; MODULO Returns the remainder of the division
    319  1818					      macro	modulo
    320  1818					      db	60
    321  1818					      endm
    322  1818							; Set a task line
    323  1818					      macro	taskcreate
    324  1818					      db	61
    325  1818					      endm
    326  1818							; End a task
    327  1818					      macro	etask
    328  1818					      db	62
    329  1818					      endm
    330  1818							; Skip to next task
    331  1818					      macro	ntask
    332  1818					      db	63
    333  1818					      endm
    334  1818							; Subscript
    335  1818					      macro	subscript
    336  1818					      db	64
    337  1818					      endm
    338  1818							; KILL Task
    339  1818					      macro	taskkill
    340  1818					      db	65
    341  1818					      endm
    342  1818							; STAT Task
    343  1818					      macro	taskstat
    344  1818					      db	66
    345  1818					      endm
    346  1818							;  output value as hex
    347  1818					      macro	hexprt
    348  1818					      db	67
    349  1818					      endm
    350  1818							;  Read in background has completed
    351  1818					      macro	readcomplete
    352  1818					      db	68
    353  1818					      endm
    354  1818							;  ReadInput line
    355  1818					      macro	readstart
    356  1818					      db	69
    357  1818					      endm
    358  1818							; Startio request
    359  1818					      macro	startio
    360  1818					      db	70
    361  1818					      endm
    362  1818							; Endio
    363  1818					      macro	endio
    364  1818					      db	71
    365  1818					      endm
    366  1818							; Logical not
    367  1818					      macro	lognot
    368  1818					      db	72
    369  1818					      endm
    370  1818							; Logical OR
    371  1818					      macro	logor
    372  1818					      db	73
    373  1818					      endm
    374  1818							;Logical and
    375  1818					      macro	logand
    376  1818					      db	74
    377  1818					      endm
    378  1818							;Logical XOR
    379  1818					      macro	logxor
    380  1818					      db	75
    381  1818					      endm
    382  1818							;Wait for task to complete, or list of tasks
    383  1818					      macro	wtask
    384  1818					      db	76
    385  1818					      db	({1}-*)-1	;(addr-*)-1
    386  1818					      endm
    387  1818							;Get the current task id
    388  1818					      MACRO	taskpid
    389  1818					      db	77
    390  1818					      endm
    391  1818							;Trace the basic execution
    392  1818					      Macro	traceprogram
    393  1818					      db	78
    394  1818					      endm
    395  1818							;Do a basic program Trace
    396  1818					      Macro	debugbasic
    397  1818					      db	79
    398  1818					      endm
    399  1818
    400  1818							; Inter Process communications instructions
    401  1818					      Macro	ipcsend
    402  1818					      db	80
    403  1818					      endm
    404  1818					      Macro	ipcreceive
    405  1818					      db	81
    406  1818					      endm
    407  1818					      Macro	ipccheck
    408  1818					      db	82
    409  1818					      endm
    410  1818					      Macro	ipcio
    411  1818					      db	83
    412  1818					      endm
    413  1818					      Macro	pushmathstack
    414  1818					      db	84
    415  1818					      endm
    416  1818					      Macro	popmathstack
    417  1818					      db	85
    418  1818					      endm
    419  1818					      Macro	savemathstack
    420  1818					      db	86
    421  1818					      endm
    422  1818					      Macro	restoremathstack
    423  1818					      db	87
    424  1818					      endm
    425  1818					      Macro	incparmcount
    426  1818					      db	88
    427  1818					      endm
    428  1818					      Macro	taskgetmathstack
    429  1818					      db	89
    430  1818					      endm
    431  1818					      Macro	taskenable
    432  1818					      db	90
    433  1818					      endm
    434  1818					      Macro	tasksuspend
    435  1818					      db	91
    436  1818					      endm
    437  1818					      Macro	taskputmathptr
    438  1818					      db	92
    439  1818					      endm
    440  1818							; Test for an extension type of variable that allows access to a tasks variables
    441  1818							; Using  PID!<Var name>
    442  1818					      Macro	tstvt
    443  1818					      db	93
    444  1818					      db	({1}-*)-1	;(addr-*)-1
    445  1818					      endm
    446  1818
    447  1818							; Provide access to R2 for the IL program
    448  1818					      Macro	setr2
    449  1818					      db	94
    450  1818					      db	{1}	; R2 is only one byte
    451  1818					      endm
    452  1818							;Move stack top to temp
    453  1818					      Macro	stk2tmp
    454  1818					      db	95
    455  1818					      endm
    456  1818
    457  1818					      Macro	tmp2stk
    458  1818					      db	96
    459  1818					      endm
    460  1818
    461  1818					      Macro	tstbyte
    462  1818					      db	97
    463  1818					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1818					      dw	{2}	; address to check
    465  1818					      db	{3}	; Value to compare
    466  1818					      endm
    467  1818
    468  1818
------- FILE mytb.asm
   2161  1818							;
   2162  1818				  -	      if	FIXED
   2163  1818				  -	      org	$1000
   2164  1818					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1818					      include	"basic.il"
      1  1818							;LET
      2  1818							;=====================================================
      3  1818							;=====================================================
      4  1818					      seg	Code
      5  1818							;=====================================================
      6  1818							; This is the IL of the BASIC (or whatever) language.
      7  1818							; Because of the way macros are implemented by as65,
      8  1818							; labels can't be on the same line as a macro
      9  1818							; invocation, so that's why labels are on separate
     10  1818							; lines.
     11  1818							;
     12  1818		       18 18	   IL	      equ	*
     13  1818
     14  1818							;THE IL CONTROL SECTION
     15  1818
     16  1818				   START
      0  1818					      INIT		;INITIALIZE
      0  1818					      db	22
      1  1818		       16		      .byte.b	22
      0  1819					      NLINE		;WRITE CRLF
      0  1819					      db	5
      1  1819		       05		      .byte.b	5
      0  181a					      ERRGOTO	CO	;where to go after an error
      0  181a					      db	31
      1  181a		       1f		      .byte.b	31
      0  181b					      dw	CO
      1  181b		       1e 18		      .word.w	CO
      0  181d					      VINIT		;clear all variables
      0  181d					      db	30
      1  181d		       1e		      .byte.b	30
     21  181e							;
     22  181e							; This is where we jump to get a line of commands or
     23  181e							; a program from the user.
     24  181e							;
     25  181e				   CO
      0  181e					      GETLINE		;WRITE PROMPT AND GET LINE
      0  181e					      db	23
      1  181e		       17		      .byte.b	23
      0  181f					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  181f					      db	34
      1  181f		       22		      .byte.b	34
      0  1820					      db	(XEC-*)-1
      1  1820		       04		      .byte.b	(XEC-*)-1
      0  1821					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1821					      db	24
      1  1821		       18		      .byte.b	24
      0  1822					      IJMP	CO
      0  1822					      db	29
      1  1822		       1d		      .byte.b	29
      0  1823					      dw	CO
      1  1823		       1e 18		      .word.w	CO
     30  1825				   XEC
      0  1825					      XINIT		;INITIALIZE
      0  1825					      db	0
      1  1825		       00		      .byte.b	0
     32  1826
     33  1826							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1826				   STMT
      0  1826					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1826					      db	79
      1  1826		       4f		      .byte.b	79
      0  1827					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1827					      db	57
      1  1827		       39		      .byte.b	57
      0  1828					      db	(notirq-*)-1
      1  1828		       00		      .byte.b	(notirq-*)-1
     37  1829				   notirq
      0  1829					      TSTLET	LET	;Test if second field is =
      0  1829					      db	49
      1  1829		       31		      .byte.b	49
      0  182a					      db	(LET-*)-1
      1  182a		       03		      .byte.b	(LET-*)-1
      0  182b					      IJMP	DOLET	;allow the default to be let
      0  182b					      db	29
      1  182b		       1d		      .byte.b	29
      0  182c					      dw	DOLET
      1  182c		       34 18		      .word.w	DOLET
     40  182e				   LET
      0  182e					      TST	S1,"LET"	;IS STATEMENT A LET
      0  182e					      db	32
      1  182e		       20		      .byte.b	32
      0  182f					      db	(S1-*)-1
      1  182f		       21		      .byte.b	(S1-*)-1
      0  1830					      db	"LET",0
      1  1830		       4c 45 54 00	      .byte.b	"LET",0
     42  1834				   DOLET
      0  1834					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1834					      db	33
      1  1834		       21		      .byte.b	33
      0  1835					      db	(ERRVEC-*)-1
      1  1835		       ca		      .byte.b	(ERRVEC-*)-1
      0  1836					      TST	LETBE,"["
      0  1836					      db	32
      1  1836		       20		      .byte.b	32
      0  1837					      db	(LETBE-*)-1
      1  1837		       0a		      .byte.b	(LETBE-*)-1
      0  1838					      db	"[",0
      1  1838		       5b 00		      .byte.b	"[",0
      0  183a					      CALL	EXPR
      0  183a					      db	28
      1  183a		       1c		      .byte.b	28
      0  183b					      dw	EXPR
      1  183b		       81 1a		      .word.w	EXPR
      0  183d					      TST	ERRVEC,"]"
      0  183d					      db	32
      1  183d		       20		      .byte.b	32
      0  183e					      db	(ERRVEC-*)-1
      1  183e		       c1		      .byte.b	(ERRVEC-*)-1
      0  183f					      db	"]",0
      1  183f		       5d 00		      .byte.b	"]",0
      0  1841					      SUBSCRIPT
      0  1841					      db	64
      1  1841		       40		      .byte.b	64
     48  1842				   LETBE
      0  1842					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1842					      db	32
      1  1842		       20		      .byte.b	32
      0  1843					      db	(ERRVEC-*)-1
      1  1843		       bc		      .byte.b	(ERRVEC-*)-1
      0  1844					      db	"=",0
      1  1844		       3d 00		      .byte.b	"=",0
      0  1846					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  1846					      db	28
      1  1846		       1c		      .byte.b	28
      0  1847					      dw	EXPR
      1  1847		       81 1a		      .word.w	EXPR
      0  1849					      DONE		;REPORT ERROR IF NOT NEXT
      0  1849					      db	1
      1  1849		       01		      .byte.b	1
      0  184a					      STORE		;STORE RESULT
      0  184a					      db	19
      1  184a		       13		      .byte.b	19
      0  184b					      NXT	CO	;AND SEQUENCE TO NEXT
      0  184b					      db	6
      1  184b		       06		      .byte.b	6
      0  184c					      dw	CO
      1  184c		       1e 18		      .word.w	CO
      0  184e					      IJMP	STMT
      0  184e					      db	29
      1  184e		       1d		      .byte.b	29
      0  184f					      dw	STMT
      1  184f		       26 18		      .word.w	STMT
     55  1851				   S1
      0  1851					      TST	S1S1,"IRET"	;test return from interupt
      0  1851					      db	32
      1  1851		       20		      .byte.b	32
      0  1852					      db	(S1S1-*)-1
      1  1852		       10		      .byte.b	(S1S1-*)-1
      0  1853					      db	"IRET",0
      1  1853		       49 52 45 54*	      .byte.b	"IRET",0
      0  1858					      TST	S1Sa,"URN"
      0  1858					      db	32
      1  1858		       20		      .byte.b	32
      0  1859					      db	(S1Sa-*)-1
      1  1859		       04		      .byte.b	(S1Sa-*)-1
      0  185a					      db	"URN",0
      1  185a		       55 52 4e 00	      .byte.b	"URN",0
     58  185e				   S1Sa
      0  185e					      DONE		;Must be only thing on the line
      0  185e					      db	1
      1  185e		       01		      .byte.b	1
      0  185f					      IRET		;RESTORE LINE NUMBER OF CALL
      0  185f					      db	58
      1  185f		       3a		      .byte.b	58
      0  1860					      IJMP	STMT
      0  1860					      db	29
      1  1860		       1d		      .byte.b	29
      0  1861					      dw	STMT
      1  1861		       26 18		      .word.w	STMT
     62  1863
     63  1863				   S1S1
      0  1863					      TST	S1Z,"IF"	;IF STATEMENT
      0  1863					      db	32
      1  1863		       20		      .byte.b	32
      0  1864					      db	(S1Z-*)-1
      1  1864		       11		      .byte.b	(S1Z-*)-1
      0  1865					      db	"IF",0
      1  1865		       49 46 00 	      .byte.b	"IF",0
      0  1868					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1868					      db	28
      1  1868		       1c		      .byte.b	28
      0  1869					      dw	EXPR
      1  1869		       81 1a		      .word.w	EXPR
      0  186b					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  186b					      db	32
      1  186b		       20		      .byte.b	32
      0  186c					      db	(S1W-*)-1
      1  186c		       05		      .byte.b	(S1W-*)-1
      0  186d					      db	"THEN",0
      1  186d		       54 48 45 4e*	      .byte.b	"THEN",0
     67  1872				   S1W
      0  1872					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1872					      db	54
      1  1872		       36		      .byte.b	54
      0  1873					      IJMP	STMT
      0  1873					      db	29
      1  1873		       1d		      .byte.b	29
      0  1874					      dw	STMT
      1  1874		       26 18		      .word.w	STMT
     70  1876
     71  1876				   S1Z
      0  1876					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1876					      db	32
      1  1876		       20		      .byte.b	32
      0  1877					      db	(S2b-*)-1
      1  1877		       19		      .byte.b	(S2b-*)-1
      0  1878					      db	"GO",0
      1  1878		       47 4f 00 	      .byte.b	"GO",0
      0  187b					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  187b					      db	32
      1  187b		       20		      .byte.b	32
      0  187c					      db	(S2-*)-1
      1  187c		       07		      .byte.b	(S2-*)-1
      0  187d					      db	"TO",0
      1  187d		       54 4f 00 	      .byte.b	"TO",0
      0  1880					      CALL	EXPR	;GET LABEL
      0  1880					      db	28
      1  1880		       1c		      .byte.b	28
      0  1881					      dw	EXPR
      1  1881		       81 1a		      .word.w	EXPR
      0  1883					      XFER		;SET UP AND JUMP
      0  1883					      db	7
      1  1883		       07		      .byte.b	7
     76  1884				   S2
     77  1884							;===========================================================================
     78  1884							; Process gosub / function
     79  1884							;
      0  1884					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1884					      db	32
      1  1884		       20		      .byte.b	32
      0  1885					      db	(ERRVEC-*)-1
      1  1885		       7a		      .byte.b	(ERRVEC-*)-1
      0  1886					      db	"SUB",0
      1  1886		       53 55 42 00	      .byte.b	"SUB",0
      0  188a					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  188a					      db	28
      1  188a		       1c		      .byte.b	28
      0  188b					      dw	GOSUBSTATEMENT
      1  188b		       87 1c		      .word.w	GOSUBSTATEMENT
      0  188d					      DONE		;ERROR IF CR NOT NEXT
      0  188d					      db	1
      1  188d		       01		      .byte.b	1
      0  188e					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  188e					      db	8
      1  188e		       08		      .byte.b	8
      0  188f					      db	GOSUB_RTN
      1  188f		       01		      .byte.b	GOSUB_RTN
      0  1890					      XFER		;AND JUMP
      0  1890					      db	7
      1  1890		       07		      .byte.b	7
     85  1891							;
     86  1891							; End of gosub processing
     87  1891							;==========================================================================
     88  1891							; Return from a gosub
     89  1891				   S2b
      0  1891					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1891					      db	32
      1  1891		       20		      .byte.b	32
      0  1892					      db	(S3-*)-1
      1  1892		       36		      .byte.b	(S3-*)-1
      0  1893					      db	"RE",0
      1  1893		       52 45 00 	      .byte.b	"RE",0
      0  1896					      TST	S2a,"T"
      0  1896					      db	32
      1  1896		       20		      .byte.b	32
      0  1897					      db	(S2a-*)-1
      1  1897		       27		      .byte.b	(S2a-*)-1
      0  1898					      db	"T",0
      1  1898		       54 00		      .byte.b	"T",0
      0  189a					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  189a					      db	32
      1  189a		       20		      .byte.b	32
      0  189b					      db	(S2aa-*)-1
      1  189b		       04		      .byte.b	(S2aa-*)-1
      0  189c					      db	"URN",0
      1  189c		       55 52 4e 00	      .byte.b	"URN",0
     93  18a0				   S2aa
      0  18a0					      SETR2	0	; Default no return value
      0  18a0					      db	94
      1  18a0		       5e		      .byte.b	94
      0  18a1					      db	0
      1  18a1		       00		      .byte.b	0
      0  18a2					      TST	S2RetDone,"("	; Check if we will return some value
      0  18a2					      db	32
      1  18a2		       20		      .byte.b	32
      0  18a3					      db	(S2RetDone-*)-1
      1  18a3		       0b		      .byte.b	(S2RetDone-*)-1
      0  18a4					      db	"(",0
      1  18a4		       28 00		      .byte.b	"(",0
      0  18a6					      SETR2	1	; Indicate a return value provided
      0  18a6					      db	94
      1  18a6		       5e		      .byte.b	94
      0  18a7					      db	1
      1  18a7		       01		      .byte.b	1
      0  18a8					      CALL	EXPR
      0  18a8					      db	28
      1  18a8		       1c		      .byte.b	28
      0  18a9					      dw	EXPR
      1  18a9		       81 1a		      .word.w	EXPR
      0  18ab					      TST	ERRVEC,")"	; Now a value is on the stack
      0  18ab					      db	32
      1  18ab		       20		      .byte.b	32
      0  18ac					      db	(ERRVEC-*)-1
      1  18ac		       53		      .byte.b	(ERRVEC-*)-1
      0  18ad					      db	")",0
      1  18ad		       29 00		      .byte.b	")",0
     99  18af
    100  18af				   S2RetDone
      0  18af					      DONE		; MUST BE CR or :
      0  18af					      db	1
      1  18af		       01		      .byte.b	1
      0  18b0					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  18b0					      db	9
      1  18b0		       09		      .byte.b	9
      0  18b1					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  18b1					      db	97
      1  18b1		       61		      .byte.b	97
      0  18b2					      db	(S2RetFunc-*)-1
      1  18b2		       09		      .byte.b	(S2RetFunc-*)-1
      0  18b3					      dw	R2
      1  18b3		       58 00		      .word.w	R2
      0  18b5					      db	1
      1  18b5		       01		      .byte.b	1
      0  18b6					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  18b6					      db	6
      1  18b6		       06		      .byte.b	6
      0  18b7					      dw	CO
      1  18b7		       1e 18		      .word.w	CO
      0  18b9					      IJMP	STMT
      0  18b9					      db	29
      1  18b9		       1d		      .byte.b	29
      0  18ba					      dw	STMT
      1  18ba		       26 18		      .word.w	STMT
    106  18bc				   S2RetFunc
      0  18bc					      IJMP	GOFNRet	; Back into the Function
      0  18bc					      db	29
      1  18bc		       1d		      .byte.b	29
      0  18bd					      dw	GOFNRet
      1  18bd		       5d 1c		      .word.w	GOFNRet
    108  18bf							;
    109  18bf							; End of return from gosub
    110  18bf							;============================================================================
    111  18bf							; Process REM statement
    112  18bf				   S2a
      0  18bf					      TST	S3,"M"	;REMark.  Skip rest of line
      0  18bf					      db	32
      1  18bf		       20		      .byte.b	32
      0  18c0					      db	(S3-*)-1
      1  18c0		       08		      .byte.b	(S3-*)-1
      0  18c1					      db	"M",0
      1  18c1		       4d 00		      .byte.b	"M",0
      0  18c3					      NXT	CO
      0  18c3					      db	6
      1  18c3		       06		      .byte.b	6
      0  18c4					      dw	CO
      1  18c4		       1e 18		      .word.w	CO
      0  18c6					      IJMP	STMT
      0  18c6					      db	29
      1  18c6		       1d		      .byte.b	29
      0  18c7					      dw	STMT
      1  18c7		       26 18		      .word.w	STMT
    116  18c9
    117  18c9				   S3
      0  18c9					      TST	S3a,"?"	; ? symonym for print
      0  18c9					      db	32
      1  18c9		       20		      .byte.b	32
      0  18ca					      db	(S3a-*)-1
      1  18ca		       05		      .byte.b	(S3a-*)-1
      0  18cb					      db	"?",0
      1  18cb		       3f 00		      .byte.b	"?",0
      0  18cd					      IJMP	S4S
      0  18cd					      db	29
      1  18cd		       1d		      .byte.b	29
      0  18ce					      dw	S4S
      1  18ce		       db 18		      .word.w	S4S
    120  18d0				   S3a
      0  18d0					      TST	S8,"PR"	;allow short form of print
      0  18d0					      db	32
      1  18d0		       20		      .byte.b	32
      0  18d1					      db	(S8-*)-1
      1  18d1		       4c		      .byte.b	(S8-*)-1
      0  18d2					      db	"PR",0
      1  18d2		       50 52 00 	      .byte.b	"PR",0
      0  18d5					      TST	S4S,"INT"	;PRINT
      0  18d5					      db	32
      1  18d5		       20		      .byte.b	32
      0  18d6					      db	(S4S-*)-1
      1  18d6		       04		      .byte.b	(S4S-*)-1
      0  18d7					      db	"INT",0
      1  18d7		       49 4e 54 00	      .byte.b	"INT",0
    123  18db				   S4S
      0  18db					      STARTIO		;Lock task until io completes
      0  18db					      db	70
      1  18db		       46		      .byte.b	70
    125  18dc				   S4
      0  18dc					      TSTDONE	S4a	;Test if we just want crlf printed
      0  18dc					      db	50
      1  18dc		       32		      .byte.b	50
      0  18dd					      db	(S4a-*)-1
      1  18dd		       03		      .byte.b	(S4a-*)-1
      0  18de					      IJMP	S6
      0  18de					      db	29
      1  18de		       1d		      .byte.b	29
      0  18df					      dw	S6
      1  18df		       f7 18		      .word.w	S6
    128  18e1
    129  18e1				   S4a
      0  18e1					      TSTSTR	S7	;TEST FOR QUOTED String
      0  18e1					      db	55
      1  18e1		       37		      .byte.b	55
      0  18e2					      db	(S7-*)-1
      1  18e2		       21		      .byte.b	(S7-*)-1
      0  18e3					      PRS		;PRINT STRING
      0  18e3					      db	2
      1  18e3		       02		      .byte.b	2
    132  18e4				   S5
      0  18e4					      TST	S6A,COMMA	;IS THERE MORE?
      0  18e4					      db	32
      1  18e4		       20		      .byte.b	32
      0  18e5					      db	(S6A-*)-1
      1  18e5		       08		      .byte.b	(S6A-*)-1
      0  18e6					      db	COMMA,0
      1  18e6		       2c 00		      .byte.b	COMMA,0
      0  18e8					      SPC		;SPACE TO NEXT ZONE
      0  18e8					      db	4
      1  18e8		       04		      .byte.b	4
      0  18e9					      TSTDONE	S4	;Not end of line jump back
      0  18e9					      db	50
      1  18e9		       32		      .byte.b	50
      0  18ea					      db	(S4-*)-1
      1  18ea		       f1		      .byte.b	(S4-*)-1
      0  18eb					      IJMP	S6Z	;YES JUMP BACK
      0  18eb					      db	29
      1  18eb		       1d		      .byte.b	29
      0  18ec					      dw	S6Z
      1  18ec		       f9 18		      .word.w	S6Z
    137  18ee
    138  18ee							;
    139  18ee							; If a semicolon, don't do anything.
    140  18ee							;
    141  18ee				   S6A
      0  18ee					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  18ee					      db	32
      1  18ee		       20		      .byte.b	32
      0  18ef					      db	(S6-*)-1
      1  18ef		       07		      .byte.b	(S6-*)-1
      0  18f0					      db	SEMICOLON,0
      1  18f0		       3b 00		      .byte.b	SEMICOLON,0
      0  18f2					      TSTDONE	S4	;Jump Back if not end of line
      0  18f2					      db	50
      1  18f2		       32		      .byte.b	50
      0  18f3					      db	(S4-*)-1
      1  18f3		       e8		      .byte.b	(S4-*)-1
      0  18f4					      IJMP	S6Z
      0  18f4					      db	29
      1  18f4		       1d		      .byte.b	29
      0  18f5					      dw	S6Z
      1  18f5		       f9 18		      .word.w	S6Z
    145  18f7				   S6
      0  18f7					      DONE		;ERROR IF CR NOT NEXT
      0  18f7					      db	1
      1  18f7		       01		      .byte.b	1
      0  18f8					      NLINE
      0  18f8					      db	5
      1  18f8		       05		      .byte.b	5
    148  18f9				   S6Z
      0  18f9					      ENDIO		;release task io completed
      0  18f9					      db	71
      1  18f9		       47		      .byte.b	71
      0  18fa					      NXT	CO	;exit here if , or ; at end of print
      0  18fa					      db	6
      1  18fa		       06		      .byte.b	6
      0  18fb					      dw	CO
      1  18fb		       1e 18		      .word.w	CO
      0  18fd					      IJMP	STMT
      0  18fd					      db	29
      1  18fd		       1d		      .byte.b	29
      0  18fe					      dw	STMT
      1  18fe		       26 18		      .word.w	STMT
    152  1900							;
    153  1900							; A jump for code too far away for relative branch
    154  1900							;
    155  1900				   ERRVEC
      0  1900					      ENDIO
      0  1900					      db	71
      1  1900		       47		      .byte.b	71
      0  1901					      IJMP	UNKNOWN
      0  1901					      db	29
      1  1901		       1d		      .byte.b	29
      0  1902					      dw	UNKNOWN
      1  1902		       7d 1a		      .word.w	UNKNOWN
    158  1904							;
    159  1904							; Get here if there is an expression to print
    160  1904				   S7
      0  1904					      TST	S7A,"$"
      0  1904					      db	32
      1  1904		       20		      .byte.b	32
      0  1905					      db	(S7A-*)-1
      1  1905		       09		      .byte.b	(S7A-*)-1
      0  1906					      db	"$",0
      1  1906		       24 00		      .byte.b	"$",0
      0  1908					      CALL	EXPR
      0  1908					      db	28
      1  1908		       1c		      .byte.b	28
      0  1909					      dw	EXPR
      1  1909		       81 1a		      .word.w	EXPR
      0  190b					      HEXPRT
      0  190b					      db	67
      1  190b		       43		      .byte.b	67
      0  190c					      IJMP	S5
      0  190c					      db	29
      1  190c		       1d		      .byte.b	29
      0  190d					      dw	S5
      1  190d		       e4 18		      .word.w	S5
    165  190f				   S7A
      0  190f					      CALL	EXPR
      0  190f					      db	28
      1  190f		       1c		      .byte.b	28
      0  1910					      dw	EXPR
      1  1910		       81 1a		      .word.w	EXPR
      0  1912					      TST	S7B,"$"
      0  1912					      db	32
      1  1912		       20		      .byte.b	32
      0  1913					      db	(S7B-*)-1
      1  1913		       06		      .byte.b	(S7B-*)-1
      0  1914					      db	"$",0
      1  1914		       24 00		      .byte.b	"$",0
      0  1916					      PUTCHAR
      0  1916					      db	52
      1  1916		       34		      .byte.b	52
      0  1917					      IJMP	S5
      0  1917					      db	29
      1  1917		       1d		      .byte.b	29
      0  1918					      dw	S5
      1  1918		       e4 18		      .word.w	S5
    170  191a				   S7B
      0  191a					      PRN		;PRINT IT
      0  191a					      db	3
      1  191a		       03		      .byte.b	3
      0  191b					      IJMP	S5	;IS THERE MORE?
      0  191b					      db	29
      1  191b		       1d		      .byte.b	29
      0  191c					      dw	S5
      1  191c		       e4 18		      .word.w	S5
    173  191e							;
    174  191e							;===========================================================
    175  191e							; End of TASK process
    176  191e				   S8
      0  191e					      TST	S8a1,"TASK"	; Any Task COmmand
      0  191e					      db	32
      1  191e		       20		      .byte.b	32
      0  191f					      db	(S8a1-*)-1
      1  191f		       4b		      .byte.b	(S8a1-*)-1
      0  1920					      db	"TASK",0
      1  1920		       54 41 53 4b*	      .byte.b	"TASK",0
      0  1925					      TST	S8G,"E"
      0  1925					      db	32
      1  1925		       20		      .byte.b	32
      0  1926					      db	(S8G-*)-1
      1  1926		       1a		      .byte.b	(S8G-*)-1
      0  1927					      db	"E",0
      1  1927		       45 00		      .byte.b	"E",0
      0  1929					      TST	S8NoParm,"("
      0  1929					      db	32
      1  1929		       20		      .byte.b	32
      0  192a					      db	(S8NoParm-*)-1
      1  192a		       0e		      .byte.b	(S8NoParm-*)-1
      0  192b					      db	"(",0
      1  192b		       28 00		      .byte.b	"(",0
      0  192d					      CALL	EXPR
      0  192d					      db	28
      1  192d		       1c		      .byte.b	28
      0  192e					      dw	EXPR
      1  192e		       81 1a		      .word.w	EXPR
      0  1930					      TST	UNKNOWNLnk,")"
      0  1930					      db	32
      1  1930		       20		      .byte.b	32
      0  1931					      db	(UNKNOWNLnk-*)-1
      1  1931		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1932					      db	")",0
      1  1932		       29 00		      .byte.b	")",0
      0  1934					      ETASK
      0  1934					      db	62
      1  1934		       3e		      .byte.b	62
      0  1935					      DONE
      0  1935					      db	1
      1  1935		       01		      .byte.b	1
      0  1936					      IJMP	STMT
      0  1936					      db	29
      1  1936		       1d		      .byte.b	29
      0  1937					      dw	STMT
      1  1937		       26 18		      .word.w	STMT
    185  1939				   S8NoParm
      0  1939					      LIT	0
      0  1939					      db	27
      1  1939		       1b		      .byte.b	27
      0  193a					      dw	0
      1  193a		       00 00		      .word.w	0
      0  193c					      ETASK
      0  193c					      db	62
      1  193c		       3e		      .byte.b	62
      0  193d					      DONE		; Must be last thing on a line
      0  193d					      db	1
      1  193d		       01		      .byte.b	1
      0  193e					      IJMP	STMT
      0  193e					      db	29
      1  193e		       1d		      .byte.b	29
      0  193f					      dw	STMT
      1  193f		       26 18		      .word.w	STMT
    190  1941							;
    191  1941							;===========================================================
    192  1941							; The task gives up the rest of the cycles
    193  1941				   S8G
      0  1941					      TST	S8a,"N"	;Next task
      0  1941					      db	32
      1  1941		       20		      .byte.b	32
      0  1942					      db	(S8a-*)-1
      1  1942		       09		      .byte.b	(S8a-*)-1
      0  1943					      db	"N",0
      1  1943		       4e 00		      .byte.b	"N",0
      0  1945					      NTASK
      0  1945					      db	63
      1  1945		       3f		      .byte.b	63
      0  1946					      NXT	CO	;Next statement to execute
      0  1946					      db	6
      1  1946		       06		      .byte.b	6
      0  1947					      dw	CO
      1  1947		       1e 18		      .word.w	CO
      0  1949					      IJMP	STMT
      0  1949					      db	29
      1  1949		       1d		      .byte.b	29
      0  194a					      dw	STMT
      1  194a		       26 18		      .word.w	STMT
    198  194c							;
    199  194c							;===========================================================
    200  194c							; Waits for a task or list of tasks to complete
    201  194c				   S8a
      0  194c					      TST	S8TASKNO,"W("	;Wait for tasks
      0  194c					      db	32
      1  194c		       20		      .byte.b	32
      0  194d					      db	(S8TASKNO-*)-1
      1  194d		       1a		      .byte.b	(S8TASKNO-*)-1
      0  194e					      db	"W(",0
      1  194e		       57 28 00 	      .byte.b	"W(",0
    203  1951				   S8TSK
      0  1951					      Call	EXPR	;Gets the PID of task to wait for
      0  1951					      db	28
      1  1951		       1c		      .byte.b	28
      0  1952					      dw	EXPR
      1  1952		       81 1a		      .word.w	EXPR
    205  1954				   S8LOOP
      0  1954					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1954					      db	76
      1  1954		       4c		      .byte.b	76
      0  1955					      db	(S8LOOP-*)-1
      1  1955		       fe		      .byte.b	(S8LOOP-*)-1
      0  1956					      TST	S8aa,COMMA	;Checks for more tasks
      0  1956					      db	32
      1  1956		       20		      .byte.b	32
      0  1957					      db	(S8aa-*)-1
      1  1957		       05		      .byte.b	(S8aa-*)-1
      0  1958					      db	COMMA,0
      1  1958		       2c 00		      .byte.b	COMMA,0
      0  195a					      IJMP	S8TSK	;Go for the next task number
      0  195a					      db	29
      1  195a		       1d		      .byte.b	29
      0  195b					      dw	S8TSK
      1  195b		       51 19		      .word.w	S8TSK
    209  195d				   S8aa
      0  195d					      TST	S8TASKNO,")"	;end of list
      0  195d					      db	32
      1  195d		       20		      .byte.b	32
      0  195e					      db	(S8TASKNO-*)-1
      1  195e		       09		      .byte.b	(S8TASKNO-*)-1
      0  195f					      db	")",0
      1  195f		       29 00		      .byte.b	")",0
      0  1961					      DONE
      0  1961					      db	1
      1  1961		       01		      .byte.b	1
      0  1962					      NXT	CO
      0  1962					      db	6
      1  1962		       06		      .byte.b	6
      0  1963					      dw	CO
      1  1963		       1e 18		      .word.w	CO
      0  1965					      IJMP	STMT	;Next Statement
      0  1965					      db	29
      1  1965		       1d		      .byte.b	29
      0  1966					      dw	STMT
      1  1966		       26 18		      .word.w	STMT
    214  1968				   S8TASKNO
    215  1968
    216  1968				   UNKNOWNLnk
      0  1968					      iJMP	UNKNOWN
      0  1968					      db	29
      1  1968		       1d		      .byte.b	29
      0  1969					      dw	UNKNOWN
      1  1969		       7d 1a		      .word.w	UNKNOWN
    218  196b
    219  196b							;
    220  196b							;===========================================================
    221  196b							; Update a memory location with a value
    222  196b				   S8a1
      0  196b					      TST	S8b,"POKE("	; Poke a value into memory
      0  196b					      db	32
      1  196b		       20		      .byte.b	32
      0  196c					      db	(S8b-*)-1
      1  196c		       1c		      .byte.b	(S8b-*)-1
      0  196d					      db	"POKE(",0
      1  196d		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1973					      CALL	EXPR	; Get address to write to
      0  1973					      db	28
      1  1973		       1c		      .byte.b	28
      0  1974					      dw	EXPR
      1  1974		       81 1a		      .word.w	EXPR
      0  1976					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1976					      db	32
      1  1976		       20		      .byte.b	32
      0  1977					      db	(UNKNOWNV-*)-1
      1  1977		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1978					      db	COMMA,0
      1  1978		       2c 00		      .byte.b	COMMA,0
      0  197a					      CALL	EXPR	; Get the value to poke
      0  197a					      db	28
      1  197a		       1c		      .byte.b	28
      0  197b					      dw	EXPR
      1  197b		       81 1a		      .word.w	EXPR
      0  197d					      TST	UNKNOWNV,")"	; closing bracket
      0  197d					      db	32
      1  197d		       20		      .byte.b	32
      0  197e					      db	(UNKNOWNV-*)-1
      1  197e		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  197f					      db	")",0
      1  197f		       29 00		      .byte.b	")",0
      0  1981					      POKEMEM
      0  1981					      db	47
      1  1981		       2f		      .byte.b	47
      0  1982					      DONE
      0  1982					      db	1
      1  1982		       01		      .byte.b	1
      0  1983					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1983					      db	6
      1  1983		       06		      .byte.b	6
      0  1984					      dw	CO
      1  1984		       1e 18		      .word.w	CO
      0  1986					      IJMP	STMT
      0  1986					      db	29
      1  1986		       1d		      .byte.b	29
      0  1987					      dw	STMT
      1  1987		       26 18		      .word.w	STMT
    232  1989
    233  1989				   S8b
      0  1989					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1989					      db	32
      1  1989		       20		      .byte.b	32
      0  198a					      db	(S8c-*)-1
      1  198a		       11		      .byte.b	(S8c-*)-1
      0  198b					      db	"PUTCH",0
      1  198b		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1991					      CALL	EXPR
      0  1991					      db	28
      1  1991		       1c		      .byte.b	28
      0  1992					      dw	EXPR
      1  1992		       81 1a		      .word.w	EXPR
      0  1994					      PUTCHAR
      0  1994					      db	52
      1  1994		       34		      .byte.b	52
      0  1995					      DONE
      0  1995					      db	1
      1  1995		       01		      .byte.b	1
      0  1996					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1996					      db	6
      1  1996		       06		      .byte.b	6
      0  1997					      dw	CO
      1  1997		       1e 18		      .word.w	CO
      0  1999					      IJMP	STMT
      0  1999					      db	29
      1  1999		       1d		      .byte.b	29
      0  199a					      dw	STMT
      1  199a		       26 18		      .word.w	STMT
    240  199c				   S8c
      0  199c					      TST	S9,"CLS"	;Clear the screen
      0  199c					      db	32
      1  199c		       20		      .byte.b	32
      0  199d					      db	(S9-*)-1
      1  199d		       0b		      .byte.b	(S9-*)-1
      0  199e					      db	"CLS",0
      1  199e		       43 4c 53 00	      .byte.b	"CLS",0
      0  19a2					      CLEARSCREEN
      0  19a2					      db	46
      1  19a2		       2e		      .byte.b	46
      0  19a3					      NXT	CO	;AND SEQUENCE TO NEXT
      0  19a3					      db	6
      1  19a3		       06		      .byte.b	6
      0  19a4					      dw	CO
      1  19a4		       1e 18		      .word.w	CO
      0  19a6					      IJMP	STMT
      0  19a6					      db	29
      1  19a6		       1d		      .byte.b	29
      0  19a7					      dw	STMT
      1  19a7		       26 18		      .word.w	STMT
    245  19a9				   S9
      0  19a9					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  19a9					      db	32
      1  19a9		       20		      .byte.b	32
      0  19aa					      db	(S13-*)-1
      1  19aa		       2a		      .byte.b	(S13-*)-1
      0  19ab					      db	"INPUT",0
      1  19ab		       49 4e 50 55*	      .byte.b	"INPUT",0
    247  19b1				   S10
      0  19b1					      TSTSTR	S10A	;If there is a string print the prompt
      0  19b1					      db	55
      1  19b1		       37		      .byte.b	55
      0  19b2					      db	(S10A-*)-1
      1  19b2		       05		      .byte.b	(S10A-*)-1
      0  19b3					      PRS
      0  19b3					      db	2
      1  19b3		       02		      .byte.b	2
      0  19b4					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  19b4					      db	32
      1  19b4		       20		      .byte.b	32
      0  19b5					      db	(S10Z-*)-1
      1  19b5		       15		      .byte.b	(S10Z-*)-1
      0  19b6					      db	SEMICOLON,0
      1  19b6		       3b 00		      .byte.b	SEMICOLON,0
    251  19b8				   S10A
      0  19b8					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  19b8					      db	33
      1  19b8		       21		      .byte.b	33
      0  19b9					      db	(UNKNOWN-*)-1
      1  19b9		       c3		      .byte.b	(UNKNOWN-*)-1
      0  19ba					      TST	S10A1,DOLLAR
      0  19ba					      db	32
      1  19ba		       20		      .byte.b	32
      0  19bb					      db	(S10A1-*)-1
      1  19bb		       06		      .byte.b	(S10A1-*)-1
      0  19bc					      db	DOLLAR,0
      1  19bc		       24 00		      .byte.b	DOLLAR,0
      0  19be					      INSTR		;Move character From tty to AESTK
      0  19be					      db	59
      1  19be		       3b		      .byte.b	59
      0  19bf					      IJMP	S10A2
      0  19bf					      db	29
      1  19bf		       1d		      .byte.b	29
      0  19c0					      dw	S10A2
      1  19c0		       c3 19		      .word.w	S10A2
    256  19c2				   S10A1
      0  19c2					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  19c2					      db	11
      1  19c2		       0b		      .byte.b	11
    258  19c3				   S10A2
      0  19c3					      STORE		;STORE IT
      0  19c3					      db	19
      1  19c3		       13		      .byte.b	19
      0  19c4					      TST	S11,COMMA	;IS THERE MORE?
      0  19c4					      db	32
      1  19c4		       20		      .byte.b	32
      0  19c5					      db	(S11-*)-1
      1  19c5		       08		      .byte.b	(S11-*)-1
      0  19c6					      db	COMMA,0
      1  19c6		       2c 00		      .byte.b	COMMA,0
      0  19c8					      IJMP	S10	;YES
      0  19c8					      db	29
      1  19c8		       1d		      .byte.b	29
      0  19c9					      dw	S10
      1  19c9		       b1 19		      .word.w	S10
    262  19cb				   S10Z
      0  19cb					      iJMP	UNKNOWN
      0  19cb					      db	29
      1  19cb		       1d		      .byte.b	29
      0  19cc					      dw	UNKNOWN
      1  19cc		       7d 1a		      .word.w	UNKNOWN
    264  19ce				   S11
      0  19ce					      DONE		;MUST BE CR
      0  19ce					      db	1
      1  19ce		       01		      .byte.b	1
      0  19cf					      NXT	CO	;SEQUENCE TO NEXT
      0  19cf					      db	6
      1  19cf		       06		      .byte.b	6
      0  19d0					      dw	CO
      1  19d0		       1e 18		      .word.w	CO
      0  19d2					      IJMP	STMT
      0  19d2					      db	29
      1  19d2		       1d		      .byte.b	29
      0  19d3					      dw	STMT
      1  19d3		       26 18		      .word.w	STMT
    268  19d5				   S13
      0  19d5					      TST	S14,"END"
      0  19d5					      db	32
      1  19d5		       20		      .byte.b	32
      0  19d6					      db	(S14-*)-1
      1  19d6		       08		      .byte.b	(S14-*)-1
      0  19d7					      db	"END",0
      1  19d7		       45 4e 44 00	      .byte.b	"END",0
      0  19db					      FIN
      0  19db					      db	12
      1  19db		       0c		      .byte.b	12
    271  19dc
    272  19dc				   UNKNOWNV
      0  19dc					      IJMP	UNKNOWN
      0  19dc					      db	29
      1  19dc		       1d		      .byte.b	29
      0  19dd					      dw	UNKNOWN
      1  19dd		       7d 1a		      .word.w	UNKNOWN
    274  19df
    275  19df				   S14
      0  19df					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  19df					      db	32
      1  19df		       20		      .byte.b	32
      0  19e0					      db	(S14Z-*)-1
      1  19e0		       0f		      .byte.b	(S14Z-*)-1
      0  19e1					      db	"IRQ",0
      1  19e1		       49 52 51 00	      .byte.b	"IRQ",0
      0  19e5					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  19e5					      db	28
      1  19e5		       1c		      .byte.b	28
      0  19e6					      dw	EXPR
      1  19e6		       81 1a		      .word.w	EXPR
      0  19e8					      DONE		;must be CR
      0  19e8					      db	1
      1  19e8		       01		      .byte.b	1
      0  19e9					      SETIRQ		;Set the line number now
      0  19e9					      db	56
      1  19e9		       38		      .byte.b	56
      0  19ea					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  19ea					      db	6
      1  19ea		       06		      .byte.b	6
      0  19eb					      dw	CO
      1  19eb		       1e 18		      .word.w	CO
      0  19ed					      IJMP	STMT
      0  19ed					      db	29
      1  19ed		       1d		      .byte.b	29
      0  19ee					      dw	STMT
      1  19ee		       26 18		      .word.w	STMT
    282  19f0
    283  19f0				   S14Z
      0  19f0					      TST	S14S1,"KILL"	; Kill A running Task
      0  19f0					      db	32
      1  19f0		       20		      .byte.b	32
      0  19f1					      db	(S14S1-*)-1
      1  19f1		       10		      .byte.b	(S14S1-*)-1
      0  19f2					      db	"KILL",0
      1  19f2		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  19f7					      CALL	EXPR
      0  19f7					      db	28
      1  19f7		       1c		      .byte.b	28
      0  19f8					      dw	EXPR
      1  19f8		       81 1a		      .word.w	EXPR
      0  19fa					      DONE
      0  19fa					      db	1
      1  19fa		       01		      .byte.b	1
      0  19fb					      TASKKILL
      0  19fb					      db	65
      1  19fb		       41		      .byte.b	65
      0  19fc					      NXT	CO
      0  19fc					      db	6
      1  19fc		       06		      .byte.b	6
      0  19fd					      dw	CO
      1  19fd		       1e 18		      .word.w	CO
      0  19ff					      IJMP	STMT
      0  19ff					      db	29
      1  19ff		       1d		      .byte.b	29
      0  1a00					      dw	STMT
      1  1a00		       26 18		      .word.w	STMT
    290  1a02
    291  1a02				   S14S1
      0  1a02					      TST	S15,"LIST"	;LIST COMMAND
      0  1a02					      db	32
      1  1a02		       20		      .byte.b	32
      0  1a03					      db	(S15-*)-1
      1  1a03		       0a		      .byte.b	(S15-*)-1
      0  1a04					      db	"LIST",0
      1  1a04		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1a09					      DONE
      0  1a09					      db	1
      1  1a09		       01		      .byte.b	1
      0  1a0a					      LST
      0  1a0a					      db	21
      1  1a0a		       15		      .byte.b	21
      0  1a0b					      IJMP	CO
      0  1a0b					      db	29
      1  1a0b		       1d		      .byte.b	29
      0  1a0c					      dw	CO
      1  1a0c		       1e 18		      .word.w	CO
    296  1a0e				   S15
      0  1a0e					      TST	S16,"RUN"	;RUN COMMAND
      0  1a0e					      db	32
      1  1a0e		       20		      .byte.b	32
      0  1a0f					      db	(S16-*)-1
      1  1a0f		       0d		      .byte.b	(S16-*)-1
      0  1a10					      db	"RUN",0
      1  1a10		       52 55 4e 00	      .byte.b	"RUN",0
      0  1a14					      DONE
      0  1a14					      db	1
      1  1a14		       01		      .byte.b	1
      0  1a15					      VINIT		;clear variables
      0  1a15					      db	30
      1  1a15		       1e		      .byte.b	30
      0  1a16					      LIT	1	;GOTO line 1
      0  1a16					      db	27
      1  1a16		       1b		      .byte.b	27
      0  1a17					      dw	1
      1  1a17		       01 00		      .word.w	1
      0  1a19					      XFER		;Bob's addition
      0  1a19					      db	7
      1  1a19		       07		      .byte.b	7
    302  1a1a							; EXIT
      0  1a1a					      IJMP	STMT	;and run!
      0  1a1a					      db	29
      1  1a1a		       1d		      .byte.b	29
      0  1a1b					      dw	STMT
      1  1a1b		       26 18		      .word.w	STMT
    304  1a1d				   S16
      0  1a1d					      TST	S16A,"NEW"	;clear program
      0  1a1d					      db	32
      1  1a1d		       20		      .byte.b	32
      0  1a1e					      db	(S16A-*)-1
      1  1a1e		       08		      .byte.b	(S16A-*)-1
      0  1a1f					      db	"NEW",0
      1  1a1f		       4e 45 57 00	      .byte.b	"NEW",0
      0  1a23					      DONE
      0  1a23					      db	1
      1  1a23		       01		      .byte.b	1
      0  1a24					      IJMP	START
      0  1a24					      db	29
      1  1a24		       1d		      .byte.b	29
      0  1a25					      dw	START
      1  1a25		       18 18		      .word.w	START
    308  1a27
    309  1a27				   S16A
      0  1a27					      TST	S17A,"TRACE("	;Are we going to trace
      0  1a27					      db	32
      1  1a27		       20		      .byte.b	32
      0  1a28					      db	(S17A-*)-1
      1  1a28		       16		      .byte.b	(S17A-*)-1
      0  1a29					      db	"TRACE(",0
      1  1a29		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  1a30					      CALL	EXPR
      0  1a30					      db	28
      1  1a30		       1c		      .byte.b	28
      0  1a31					      dw	EXPR
      1  1a31		       81 1a		      .word.w	EXPR
      0  1a33					      TST	UNKNOWN,")"
      0  1a33					      db	32
      1  1a33		       20		      .byte.b	32
      0  1a34					      db	(UNKNOWN-*)-1
      1  1a34		       48		      .byte.b	(UNKNOWN-*)-1
      0  1a35					      db	")",0
      1  1a35		       29 00		      .byte.b	")",0
      0  1a37					      TRACEPROGRAM
      0  1a37					      db	78
      1  1a37		       4e		      .byte.b	78
      0  1a38					      DONE
      0  1a38					      db	1
      1  1a38		       01		      .byte.b	1
      0  1a39					      NXT	CO
      0  1a39					      db	6
      1  1a39		       06		      .byte.b	6
      0  1a3a					      dw	CO
      1  1a3a		       1e 18		      .word.w	CO
      0  1a3c					      IJMP	STMT
      0  1a3c					      db	29
      1  1a3c		       1d		      .byte.b	29
      0  1a3d					      dw	STMT
      1  1a3d		       26 18		      .word.w	STMT
    317  1a3f
    318  1a3f				   S17A
      0  1a3f					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1a3f					      db	32
      1  1a3f		       20		      .byte.b	32
      0  1a40					      db	(S17B-*)-1
      1  1a40		       06		      .byte.b	(S17B-*)-1
      0  1a41					      db	"EXIT",0
      1  1a41		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1a46					      EXIT
      0  1a46					      db	26
      1  1a46		       1a		      .byte.b	26
    321  1a47
    322  1a47							;
    323  1a47							; Commands related to saving/restoring programs
    324  1a47							; to/from mass storage.
    325  1a47							;
    326  1a47				   S17B
    327  1a47					      if	(XKIM || CTMON65) && DISK_ACCESS
    328  1a47
      0  1a47					      TST	S17C,"SAVE"
      0  1a47					      db	32
      1  1a47		       20		      .byte.b	32
      0  1a48					      db	(S17C-*)-1
      1  1a48		       0b		      .byte.b	(S17C-*)-1
      0  1a49					      db	"SAVE",0
      1  1a49		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1a4e					      OPENWRITE
      0  1a4e					      db	40
      1  1a4e		       28		      .byte.b	40
      0  1a4f					      DLIST
      0  1a4f					      db	43
      1  1a4f		       2b		      .byte.b	43
      0  1a50					      DCLOSE
      0  1a50					      db	41
      1  1a50		       29		      .byte.b	41
      0  1a51					      IJMP	CO
      0  1a51					      db	29
      1  1a51		       1d		      .byte.b	29
      0  1a52					      dw	CO
      1  1a52		       1e 18		      .word.w	CO
    334  1a54
    335  1a54				   S17C
      0  1a54					      TST	S18,"LOAD"
      0  1a54					      db	32
      1  1a54		       20		      .byte.b	32
      0  1a55					      db	(S18-*)-1
      1  1a55		       11		      .byte.b	(S18-*)-1
      0  1a56					      db	"LOAD",0
      1  1a56		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1a5b					      OPENREAD
      0  1a5b					      db	39
      1  1a5b		       27		      .byte.b	39
    338  1a5c				   S17CLP
      0  1a5c					      DGETLINE		;get line from file
      0  1a5c					      db	42
      1  1a5c		       2a		      .byte.b	42
      0  1a5d					      TSTL	S17EOL	;no line num means EOL
      0  1a5d					      db	34
      1  1a5d		       22		      .byte.b	34
      0  1a5e					      db	(S17EOL-*)-1
      1  1a5e		       04		      .byte.b	(S17EOL-*)-1
      0  1a5f					      INSERT		;put it into the program
      0  1a5f					      db	24
      1  1a5f		       18		      .byte.b	24
      0  1a60					      IJMP	S17CLP	;keep going
      0  1a60					      db	29
      1  1a60		       1d		      .byte.b	29
      0  1a61					      dw	S17CLP
      1  1a61		       5c 1a		      .word.w	S17CLP
    343  1a63				   S17EOL
      0  1a63					      DCLOSE		;close disk file
      0  1a63					      db	41
      1  1a63		       29		      .byte.b	41
      0  1a64					      IJMP	CO	;back to start
      0  1a64					      db	29
      1  1a64		       1d		      .byte.b	29
      0  1a65					      dw	CO
      1  1a65		       1e 18		      .word.w	CO
    346  1a67
    347  1a67				   S18
      0  1a67					      TST	S19,"DIR"
      0  1a67					      db	32
      1  1a67		       20		      .byte.b	32
      0  1a68					      db	(S19-*)-1
      1  1a68		       08		      .byte.b	(S19-*)-1
      0  1a69					      db	"DIR",0
      1  1a69		       44 49 52 00	      .byte.b	"DIR",0
      0  1a6d					      DDIR		;Display the directory content
      0  1a6d					      db	44
      1  1a6d		       2c		      .byte.b	44
      0  1a6e					      IJMP	CO
      0  1a6e					      db	29
      1  1a6e		       1d		      .byte.b	29
      0  1a6f					      dw	CO
      1  1a6f		       1e 18		      .word.w	CO
    351  1a71					      endif
    352  1a71
      0  1a71				   S19	      TST	UNKNOWN,"ERASE"
      0  1a71					      db	32
      1  1a71		       20		      .byte.b	32
      0  1a72					      db	(UNKNOWN-*)-1
      1  1a72		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1a73					      db	"ERASE",0
      1  1a73		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1a79					      RMFILE		;Erase the file from the disk
      0  1a79					      db	45
      1  1a79		       2d		      .byte.b	45
      0  1a7a					      IJMP	CO
      0  1a7a					      db	29
      1  1a7a		       1d		      .byte.b	29
      0  1a7b					      dw	CO
      1  1a7b		       1e 18		      .word.w	CO
    356  1a7b					      endif
    357  1a7d
    358  1a7d							;
    359  1a7d							; Else, unknown command.
    360  1a7d							;
    361  1a7d				   UNKNOWN
      0  1a7d					      ENDIO
      0  1a7d					      db	71
      1  1a7d		       47		      .byte.b	71
      0  1a7e					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1a7e					      db	13
      1  1a7e		       0d		      .byte.b	13
      0  1a7f					      dw	ERR_SYNTAX
      1  1a7f		       05 00		      .word.w	ERR_SYNTAX
    364  1a81
    365  1a81							;-----------------------------------------------------
    366  1a81				   EXPR
      0  1a81					      TST	EXPRNOT,"NOT"
      0  1a81					      db	32
      1  1a81		       20		      .byte.b	32
      0  1a82					      db	(EXPRNOT-*)-1
      1  1a82		       09		      .byte.b	(EXPRNOT-*)-1
      0  1a83					      db	"NOT",0
      1  1a83		       4e 4f 54 00	      .byte.b	"NOT",0
      0  1a87					      Call	EXPR
      0  1a87					      db	28
      1  1a87		       1c		      .byte.b	28
      0  1a88					      dw	EXPR
      1  1a88		       81 1a		      .word.w	EXPR
      0  1a8a					      LOGNOT
      0  1a8a					      db	72
      1  1a8a		       48		      .byte.b	72
      0  1a8b					      RTN
      0  1a8b					      db	25
      1  1a8b		       19		      .byte.b	25
    371  1a8c				   EXPRNOT
    372  1a8c
    373  1a8c				   EXPRLOGS
      0  1a8c					      Call	EXPRCMP
      0  1a8c					      db	28
      1  1a8c		       1c		      .byte.b	28
      0  1a8d					      dw	EXPRCMP
      1  1a8d		       b0 1a		      .word.w	EXPRCMP
      0  1a8f					      TST	iLOG1,"AND"
      0  1a8f					      db	32
      1  1a8f		       20		      .byte.b	32
      0  1a90					      db	(iLOG1-*)-1
      1  1a90		       09		      .byte.b	(iLOG1-*)-1
      0  1a91					      db	"AND",0
      1  1a91		       41 4e 44 00	      .byte.b	"AND",0
      0  1a95					      Call	EXPR
      0  1a95					      db	28
      1  1a95		       1c		      .byte.b	28
      0  1a96					      dw	EXPR
      1  1a96		       81 1a		      .word.w	EXPR
      0  1a98					      LOGAND
      0  1a98					      db	74
      1  1a98		       4a		      .byte.b	74
      0  1a99					      RTN
      0  1a99					      db	25
      1  1a99		       19		      .byte.b	25
    379  1a9a				   iLOG1
      0  1a9a					      TST	iLOG2,"OR"
      0  1a9a					      db	32
      1  1a9a		       20		      .byte.b	32
      0  1a9b					      db	(iLOG2-*)-1
      1  1a9b		       08		      .byte.b	(iLOG2-*)-1
      0  1a9c					      db	"OR",0
      1  1a9c		       4f 52 00 	      .byte.b	"OR",0
      0  1a9f					      Call	EXPR
      0  1a9f					      db	28
      1  1a9f		       1c		      .byte.b	28
      0  1aa0					      dw	EXPR
      1  1aa0		       81 1a		      .word.w	EXPR
      0  1aa2					      LOGOR
      0  1aa2					      db	73
      1  1aa2		       49		      .byte.b	73
      0  1aa3					      RTN
      0  1aa3					      db	25
      1  1aa3		       19		      .byte.b	25
    384  1aa4				   iLOG2
      0  1aa4					      TST	iLOG3,"XOR"
      0  1aa4					      db	32
      1  1aa4		       20		      .byte.b	32
      0  1aa5					      db	(iLOG3-*)-1
      1  1aa5		       09		      .byte.b	(iLOG3-*)-1
      0  1aa6					      db	"XOR",0
      1  1aa6		       58 4f 52 00	      .byte.b	"XOR",0
      0  1aaa					      Call	EXPR
      0  1aaa					      db	28
      1  1aaa		       1c		      .byte.b	28
      0  1aab					      dw	EXPR
      1  1aab		       81 1a		      .word.w	EXPR
      0  1aad					      LOGXOR
      0  1aad					      db	75
      1  1aad		       4b		      .byte.b	75
      0  1aae					      RTN
      0  1aae					      db	25
      1  1aae		       19		      .byte.b	25
    389  1aaf				   iLOG3
      0  1aaf					      RTN
      0  1aaf					      db	25
      1  1aaf		       19		      .byte.b	25
    391  1ab0
    392  1ab0				   EXPRCMP
      0  1ab0					      Call	EXPR2	; get the first expression
      0  1ab0					      db	28
      1  1ab0		       1c		      .byte.b	28
      0  1ab1					      dw	EXPR2
      1  1ab1		       fb 1a		      .word.w	EXPR2
      0  1ab3					      TST	iR0,"="
      0  1ab3					      db	32
      1  1ab3		       20		      .byte.b	32
      0  1ab4					      db	(iR0-*)-1
      1  1ab4		       08		      .byte.b	(iR0-*)-1
      0  1ab5					      db	"=",0
      1  1ab5		       3d 00		      .byte.b	"=",0
      0  1ab7					      LIT	2	;=
      0  1ab7					      db	27
      1  1ab7		       1b		      .byte.b	27
      0  1ab8					      dw	2
      1  1ab8		       02 00		      .word.w	2
      0  1aba					      IJMP	iRFound
      0  1aba					      db	29
      1  1aba		       1d		      .byte.b	29
      0  1abb					      dw	iRFound
      1  1abb		       f6 1a		      .word.w	iRFound
    397  1abd				   iR0
      0  1abd					      TST	iR4,"<"
      0  1abd					      db	32
      1  1abd		       20		      .byte.b	32
      0  1abe					      db	(iR4-*)-1
      1  1abe		       1c		      .byte.b	(iR4-*)-1
      0  1abf					      db	"<",0
      1  1abf		       3c 00		      .byte.b	"<",0
      0  1ac1					      TST	iR1,"="
      0  1ac1					      db	32
      1  1ac1		       20		      .byte.b	32
      0  1ac2					      db	(iR1-*)-1
      1  1ac2		       08		      .byte.b	(iR1-*)-1
      0  1ac3					      db	"=",0
      1  1ac3		       3d 00		      .byte.b	"=",0
      0  1ac5					      LIT	3	;<=
      0  1ac5					      db	27
      1  1ac5		       1b		      .byte.b	27
      0  1ac6					      dw	3
      1  1ac6		       03 00		      .word.w	3
      0  1ac8					      IJMP	iRFound
      0  1ac8					      db	29
      1  1ac8		       1d		      .byte.b	29
      0  1ac9					      dw	iRFound
      1  1ac9		       f6 1a		      .word.w	iRFound
    402  1acb				   iR1
      0  1acb					      TST	iR3,">"
      0  1acb					      db	32
      1  1acb		       20		      .byte.b	32
      0  1acc					      db	(iR3-*)-1
      1  1acc		       08		      .byte.b	(iR3-*)-1
      0  1acd					      db	">",0
      1  1acd		       3e 00		      .byte.b	">",0
      0  1acf					      LIT	5	;<>
      0  1acf					      db	27
      1  1acf		       1b		      .byte.b	27
      0  1ad0					      dw	5
      1  1ad0		       05 00		      .word.w	5
      0  1ad2					      IJMP	iRFound
      0  1ad2					      db	29
      1  1ad2		       1d		      .byte.b	29
      0  1ad3					      dw	iRFound
      1  1ad3		       f6 1a		      .word.w	iRFound
    406  1ad5				   iR3
      0  1ad5					      LIT	1	;<
      0  1ad5					      db	27
      1  1ad5		       1b		      .byte.b	27
      0  1ad6					      dw	1
      1  1ad6		       01 00		      .word.w	1
      0  1ad8					      IJMP	iRFound
      0  1ad8					      db	29
      1  1ad8		       1d		      .byte.b	29
      0  1ad9					      dw	iRFound
      1  1ad9		       f6 1a		      .word.w	iRFound
    409  1adb				   iR4
      0  1adb					      TST	iRDone,">"
      0  1adb					      db	32
      1  1adb		       20		      .byte.b	32
      0  1adc					      db	(iRDone-*)-1
      1  1adc		       1d		      .byte.b	(iRDone-*)-1
      0  1add					      db	">",0
      1  1add		       3e 00		      .byte.b	">",0
      0  1adf					      TST	iR5,"="
      0  1adf					      db	32
      1  1adf		       20		      .byte.b	32
      0  1ae0					      db	(iR5-*)-1
      1  1ae0		       08		      .byte.b	(iR5-*)-1
      0  1ae1					      db	"=",0
      1  1ae1		       3d 00		      .byte.b	"=",0
      0  1ae3					      LIT	6	;>=
      0  1ae3					      db	27
      1  1ae3		       1b		      .byte.b	27
      0  1ae4					      dw	6
      1  1ae4		       06 00		      .word.w	6
      0  1ae6					      IJMP	iRFound
      0  1ae6					      db	29
      1  1ae6		       1d		      .byte.b	29
      0  1ae7					      dw	iRFound
      1  1ae7		       f6 1a		      .word.w	iRFound
    414  1ae9				   iR5
      0  1ae9					      TST	iR6,"<"
      0  1ae9					      db	32
      1  1ae9		       20		      .byte.b	32
      0  1aea					      db	(iR6-*)-1
      1  1aea		       08		      .byte.b	(iR6-*)-1
      0  1aeb					      db	"<",0
      1  1aeb		       3c 00		      .byte.b	"<",0
      0  1aed					      LIT	1
      0  1aed					      db	27
      1  1aed		       1b		      .byte.b	27
      0  1aee					      dw	1
      1  1aee		       01 00		      .word.w	1
      0  1af0					      IJMP	iRFound	;(This line originally omitted)
      0  1af0					      db	29
      1  1af0		       1d		      .byte.b	29
      0  1af1					      dw	iRFound
      1  1af1		       f6 1a		      .word.w	iRFound
    418  1af3				   iR6
      0  1af3					      LIT	4	;>
      0  1af3					      db	27
      1  1af3		       1b		      .byte.b	27
      0  1af4					      dw	4
      1  1af4		       04 00		      .word.w	4
    420  1af6				   iRFound
      0  1af6					      Call	EXPR2	; get the right side of the expression
      0  1af6					      db	28
      1  1af6		       1c		      .byte.b	28
      0  1af7					      dw	EXPR2
      1  1af7		       fb 1a		      .word.w	EXPR2
      0  1af9					      CMPR		; Push the value of the true false onto the stack
      0  1af9					      db	10
      1  1af9		       0a		      .byte.b	10
    423  1afa
    424  1afa				   iRDone
      0  1afa					      RTN
      0  1afa					      db	25
      1  1afa		       19		      .byte.b	25
    426  1afb
    427  1afb				   EXPR2
      0  1afb					      TST	E0,"-"	; Look for leading - to negate term
      0  1afb					      db	32
      1  1afb		       20		      .byte.b	32
      0  1afc					      db	(E0-*)-1
      1  1afc		       09		      .byte.b	(E0-*)-1
      0  1afd					      db	"-",0
      1  1afd		       2d 00		      .byte.b	"-",0
      0  1aff					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1aff					      db	28
      1  1aff		       1c		      .byte.b	28
      0  1b00					      dw	TERM
      1  1b00		       24 1b		      .word.w	TERM
      0  1b02					      NEG		; Make value negated
      0  1b02					      db	16
      1  1b02		       10		      .byte.b	16
      0  1b03					      IJMP	E1	; We have Left term process operators next
      0  1b03					      db	29
      1  1b03		       1d		      .byte.b	29
      0  1b04					      dw	E1
      1  1b04		       0d 1b		      .word.w	E1
    432  1b06				   E0
      0  1b06					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1b06					      db	32
      1  1b06		       20		      .byte.b	32
      0  1b07					      db	(E1A-*)-1
      1  1b07		       02		      .byte.b	(E1A-*)-1
      0  1b08					      db	"+",0
      1  1b08		       2b 00		      .byte.b	"+",0
    434  1b0a				   E1A
      0  1b0a					      CALL	TERM	; Get the left term if it was not negated
      0  1b0a					      db	28
      1  1b0a		       1c		      .byte.b	28
      0  1b0b					      dw	TERM
      1  1b0b		       24 1b		      .word.w	TERM
    436  1b0d				   E1
      0  1b0d					      TST	E2,"+"	; Check if we are adding left term to something
      0  1b0d					      db	32
      1  1b0d		       20		      .byte.b	32
      0  1b0e					      db	(E2-*)-1
      1  1b0e		       09		      .byte.b	(E2-*)-1
      0  1b0f					      db	"+",0
      1  1b0f		       2b 00		      .byte.b	"+",0
      0  1b11					      CALL	TERM	; if adding then get the right side term
      0  1b11					      db	28
      1  1b11		       1c		      .byte.b	28
      0  1b12					      dw	TERM
      1  1b12		       24 1b		      .word.w	TERM
      0  1b14					      ADD		; Add it to left term
      0  1b14					      db	14
      1  1b14		       0e		      .byte.b	14
      0  1b15					      IJMP	E1	; look for next + or -
      0  1b15					      db	29
      1  1b15		       1d		      .byte.b	29
      0  1b16					      dw	E1
      1  1b16		       0d 1b		      .word.w	E1
    441  1b18				   E2
      0  1b18					      TST	E3,"-"	; Check if we are subtractig something
      0  1b18					      db	32
      1  1b18		       20		      .byte.b	32
      0  1b19					      db	(E3-*)-1
      1  1b19		       09		      .byte.b	(E3-*)-1
      0  1b1a					      db	"-",0
      1  1b1a		       2d 00		      .byte.b	"-",0
      0  1b1c					      CALL	TERM	; get right side to subtract Diffrence
      0  1b1c					      db	28
      1  1b1c		       1c		      .byte.b	28
      0  1b1d					      dw	TERM
      1  1b1d		       24 1b		      .word.w	TERM
      0  1b1f					      SUB		; Subtract the value
      0  1b1f					      db	15
      1  1b1f		       0f		      .byte.b	15
      0  1b20					      IJMP	E1	; Look for next + or -
      0  1b20					      db	29
      1  1b20		       1d		      .byte.b	29
      0  1b21					      dw	E1
      1  1b21		       0d 1b		      .word.w	E1
    446  1b23				   E3			; Finish processing the expression
      0  1b23					      RTN		; We are finished processing the Expression
      0  1b23					      db	25
      1  1b23		       19		      .byte.b	25
    448  1b24							;
    449  1b24							; Get one of the terms of an expression
    450  1b24							;
    451  1b24				   TERM
      0  1b24					      CALL	FACT	; Get a value
      0  1b24					      db	28
      1  1b24		       1c		      .byte.b	28
      0  1b25					      dw	FACT
      1  1b25		       4c 1b		      .word.w	FACT
    453  1b27				   T0			; Check for higher precidence operators
      0  1b27					      TST	T1,"*"	; Check for *
      0  1b27					      db	32
      1  1b27		       20		      .byte.b	32
      0  1b28					      db	(T1-*)-1
      1  1b28		       09		      .byte.b	(T1-*)-1
      0  1b29					      db	"*",0
      1  1b29		       2a 00		      .byte.b	"*",0
      0  1b2b					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1b2b					      db	28
      1  1b2b		       1c		      .byte.b	28
      0  1b2c					      dw	FACT
      1  1b2c		       4c 1b		      .word.w	FACT
      0  1b2e					      MUL		; Multiply factors
      0  1b2e					      db	17
      1  1b2e		       11		      .byte.b	17
      0  1b2f					      IJMP	T0	; Check for * or /
      0  1b2f					      db	29
      1  1b2f		       1d		      .byte.b	29
      0  1b30					      dw	T0
      1  1b30		       27 1b		      .word.w	T0
    458  1b32				   T1
      0  1b32					      TST	T2,"/"	; Check for a division
      0  1b32					      db	32
      1  1b32		       20		      .byte.b	32
      0  1b33					      db	(T2-*)-1
      1  1b33		       09		      .byte.b	(T2-*)-1
      0  1b34					      db	"/",0
      1  1b34		       2f 00		      .byte.b	"/",0
      0  1b36					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1b36					      db	28
      1  1b36		       1c		      .byte.b	28
      0  1b37					      dw	FACT
      1  1b37		       4c 1b		      .word.w	FACT
      0  1b39					      DIV		; do division
      0  1b39					      db	18
      1  1b39		       12		      .byte.b	18
      0  1b3a					      IJMP	T0	; check for more * or /
      0  1b3a					      db	29
      1  1b3a		       1d		      .byte.b	29
      0  1b3b					      dw	T0
      1  1b3b		       27 1b		      .word.w	T0
    463  1b3d				   T2
      0  1b3d					      TST	T3,"%"	; Check for a division
      0  1b3d					      db	32
      1  1b3d		       20		      .byte.b	32
      0  1b3e					      db	(T3-*)-1
      1  1b3e		       09		      .byte.b	(T3-*)-1
      0  1b3f					      db	"%",0
      1  1b3f		       25 00		      .byte.b	"%",0
      0  1b41					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1b41					      db	28
      1  1b41		       1c		      .byte.b	28
      0  1b42					      dw	FACT
      1  1b42		       4c 1b		      .word.w	FACT
      0  1b44					      MODULO		; do division for remainder
      0  1b44					      db	60
      1  1b44		       3c		      .byte.b	60
      0  1b45					      IJMP	T0	; check for more * or / or %
      0  1b45					      db	29
      1  1b45		       1d		      .byte.b	29
      0  1b46					      dw	T0
      1  1b46		       27 1b		      .word.w	T0
    468  1b48				   T3			; Finish processing the Term
      0  1b48					      RTN
      0  1b48					      db	25
      1  1b48		       19		      .byte.b	25
    470  1b49
    471  1b49				   UNKNOWNVEC
      0  1b49					      IJMP	UNKNOWN
      0  1b49					      db	29
      1  1b49		       1d		      .byte.b	29
      0  1b4a					      dw	UNKNOWN
      1  1b4a		       7d 1a		      .word.w	UNKNOWN
    473  1b4c
    474  1b4c							;
    475  1b4c							; Factor an expression.  Always test for functions
    476  1b4c							; first or else they'll be confused for variables.
    477  1b4c							;
    478  1b4c				   FACT
      0  1b4c					      TST	F1AA,"TRUE"
      0  1b4c					      db	32
      1  1b4c		       20		      .byte.b	32
      0  1b4d					      db	(F1AA-*)-1
      1  1b4d		       09		      .byte.b	(F1AA-*)-1
      0  1b4e					      db	"TRUE",0
      1  1b4e		       54 52 55 45*	      .byte.b	"TRUE",0
      0  1b53					      LIT	-1
      0  1b53					      db	27
      1  1b53		       1b		      .byte.b	27
      0  1b54					      dw	-1
      1  1b54		       ff ff		      .word.w	-1
      0  1b56					      RTN
      0  1b56					      db	25
      1  1b56		       19		      .byte.b	25
    482  1b57				   F1AA
      0  1b57					      TST	F1AB,"FALSE"
      0  1b57					      db	32
      1  1b57		       20		      .byte.b	32
      0  1b58					      db	(F1AB-*)-1
      1  1b58		       0a		      .byte.b	(F1AB-*)-1
      0  1b59					      db	"FALSE",0
      1  1b59		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1b5f					      LIT	0
      0  1b5f					      db	27
      1  1b5f		       1b		      .byte.b	27
      0  1b60					      dw	0
      1  1b60		       00 00		      .word.w	0
      0  1b62					      RTN
      0  1b62					      db	25
      1  1b62		       19		      .byte.b	25
    486  1b63				   F1AB
      0  1b63					      TST	F1A,"FREE()"
      0  1b63					      db	32
      1  1b63		       20		      .byte.b	32
      0  1b64					      db	(F1A-*)-1
      1  1b64		       09		      .byte.b	(F1A-*)-1
      0  1b65					      db	"FREE()",0
      1  1b65		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1b6c					      FREE
      0  1b6c					      db	36
      1  1b6c		       24		      .byte.b	36
      0  1b6d					      RTN
      0  1b6d					      db	25
      1  1b6d		       19		      .byte.b	25
    490  1b6e				   F1A
      0  1b6e					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1b6e					      db	32
      1  1b6e		       20		      .byte.b	32
      0  1b6f					      db	(F1A2-*)-1
      1  1b6f		       0a		      .byte.b	(F1A2-*)-1
      0  1b70					      db	"GETCH()",0
      1  1b70		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1b78					      GETCHAR
      0  1b78					      db	51
      1  1b78		       33		      .byte.b	51
      0  1b79					      RTN
      0  1b79					      db	25
      1  1b79		       19		      .byte.b	25
    494  1b7a				   F1A2
      0  1b7a					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1b7a					      db	32
      1  1b7a		       20		      .byte.b	32
      0  1b7b					      db	(F2AZ-*)-1
      1  1b7b		       0f		      .byte.b	(F2AZ-*)-1
      0  1b7c					      db	"PEEK(",0
      1  1b7c		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1b82					      CALL	EXPR	;Get the address to write to
      0  1b82					      db	28
      1  1b82		       1c		      .byte.b	28
      0  1b83					      dw	EXPR
      1  1b83		       81 1a		      .word.w	EXPR
      0  1b85					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  1b85					      db	32
      1  1b85		       20		      .byte.b	32
      0  1b86					      db	(UNKNOWNVEC-*)-1
      1  1b86		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  1b87					      db	")",0
      1  1b87		       29 00		      .byte.b	")",0
      0  1b89					      PEEKMEM
      0  1b89					      db	48
      1  1b89		       30		      .byte.b	48
      0  1b8a					      RTN
      0  1b8a					      db	25
      1  1b8a		       19		      .byte.b	25
    500  1b8b				   F2AZ
      0  1b8b					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  1b8b					      db	32
      1  1b8b		       20		      .byte.b	32
      0  1b8c					      db	(F2AZ1-*)-1
      1  1b8c		       22		      .byte.b	(F2AZ1-*)-1
      0  1b8d					      db	"TASK(",0
      1  1b8d		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1b93					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1b93					      db	28
      1  1b93		       1c		      .byte.b	28
      0  1b94					      dw	EXPR
      1  1b94		       81 1a		      .word.w	EXPR
      0  1b96					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  1b96					      db	61
      1  1b96		       3d		      .byte.b	61
      0  1b97					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  1b97					      db	32
      1  1b97		       20		      .byte.b	32
      0  1b98					      db	(F2AZNoParms-*)-1
      1  1b98		       10		      .byte.b	(F2AZNoParms-*)-1
      0  1b99					      db	COMMA,0
      1  1b99		       2c 00		      .byte.b	COMMA,0
      0  1b9b					      SAVEMATHSTACK		;Push The mathstack
      0  1b9b					      db	86
      1  1b9b		       56		      .byte.b	86
      0  1b9c					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  1b9c					      db	89
      1  1b9c		       59		      .byte.b	89
    507  1b9d				   F2AZLOOP
      0  1b9d					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  1b9d					      db	28
      1  1b9d		       1c		      .byte.b	28
      0  1b9e					      dw	EXPR
      1  1b9e		       81 1a		      .word.w	EXPR
      0  1ba0					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  1ba0					      db	32
      1  1ba0		       20		      .byte.b	32
      0  1ba1					      db	(F2AZEndParm-*)-1
      1  1ba1		       05		      .byte.b	(F2AZEndParm-*)-1
      0  1ba2					      db	COMMA,0
      1  1ba2		       2c 00		      .byte.b	COMMA,0
      0  1ba4					      IJMP	F2AZLOOP	;check for more
      0  1ba4					      db	29
      1  1ba4		       1d		      .byte.b	29
      0  1ba5					      dw	F2AZLOOP
      1  1ba5		       9d 1b		      .word.w	F2AZLOOP
    511  1ba7				   F2AZEndParm
      0  1ba7					      RESTOREMATHSTACK		;Back to normal stack
      0  1ba7					      db	87
      1  1ba7		       57		      .byte.b	87
      0  1ba8					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  1ba8					      db	92
      1  1ba8		       5c		      .byte.b	92
    514  1ba9				   F2AZNoParms
      0  1ba9					      TST	UNKNOWNVEC,")"	;must be )
      0  1ba9					      db	32
      1  1ba9		       20		      .byte.b	32
      0  1baa					      db	(UNKNOWNVEC-*)-1
      1  1baa		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bab					      db	")",0
      1  1bab		       29 00		      .byte.b	")",0
      0  1bad					      TASKENABLE		;Enable the task to execute
      0  1bad					      db	90
      1  1bad		       5a		      .byte.b	90
      0  1bae					      RTN		;Returns the Task number
      0  1bae					      db	25
      1  1bae		       19		      .byte.b	25
    518  1baf				   F2AZ1
      0  1baf					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  1baf					      db	32
      1  1baf		       20		      .byte.b	32
      0  1bb0					      db	(F2A-*)-1
      1  1bb0		       3c		      .byte.b	(F2A-*)-1
      0  1bb1					      db	"IPC",0
      1  1bb1		       49 50 43 00	      .byte.b	"IPC",0
      0  1bb5					      TST	F2AZa,"S("	;IPCS - send a message
      0  1bb5					      db	32
      1  1bb5		       20		      .byte.b	32
      0  1bb6					      db	(F2AZa-*)-1
      1  1bb6		       13		      .byte.b	(F2AZa-*)-1
      0  1bb7					      db	"S(",0
      1  1bb7		       53 28 00 	      .byte.b	"S(",0
      0  1bba					      CALL	EXPR	;Get the message value
      0  1bba					      db	28
      1  1bba		       1c		      .byte.b	28
      0  1bbb					      dw	EXPR
      1  1bbb		       81 1a		      .word.w	EXPR
      0  1bbd					      TST	UNKNOWNVEC,COMMA
      0  1bbd					      db	32
      1  1bbd		       20		      .byte.b	32
      0  1bbe					      db	(UNKNOWNVEC-*)-1
      1  1bbe		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bbf					      db	COMMA,0
      1  1bbf		       2c 00		      .byte.b	COMMA,0
      0  1bc1					      CALL	EXPR	;Get pid of task to send to
      0  1bc1					      db	28
      1  1bc1		       1c		      .byte.b	28
      0  1bc2					      dw	EXPR
      1  1bc2		       81 1a		      .word.w	EXPR
      0  1bc4					      TST	UNKNOWNVEC,")"
      0  1bc4					      db	32
      1  1bc4		       20		      .byte.b	32
      0  1bc5					      db	(UNKNOWNVEC-*)-1
      1  1bc5		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bc6					      db	")",0
      1  1bc6		       29 00		      .byte.b	")",0
      0  1bc8					      IPCSEND		;Send msg and clear pid msg pending
      0  1bc8					      db	80
      1  1bc8		       50		      .byte.b	80
      0  1bc9					      RTN
      0  1bc9					      db	25
      1  1bc9		       19		      .byte.b	25
    527  1bca				   F2AZa
      0  1bca					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  1bca					      db	32
      1  1bca		       20		      .byte.b	32
      0  1bcb					      db	(F2AZb-*)-1
      1  1bcb		       16		      .byte.b	(F2AZb-*)-1
      0  1bcc					      db	"R(",0
      1  1bcc		       52 28 00 	      .byte.b	"R(",0
      0  1bcf					      TST	F2AZa1,")"
      0  1bcf					      db	32
      1  1bcf		       20		      .byte.b	32
      0  1bd0					      db	(F2AZa1-*)-1
      1  1bd0		       08		      .byte.b	(F2AZa1-*)-1
      0  1bd1					      db	")",0
      1  1bd1		       29 00		      .byte.b	")",0
      0  1bd3					      LIT	0	;We dont want the pid returned to us
      0  1bd3					      db	27
      1  1bd3		       1b		      .byte.b	27
      0  1bd4					      dw	0
      1  1bd4		       00 00		      .word.w	0
      0  1bd6					      IPCIO		;Set the io bit and suspend the task till message
      0  1bd6					      db	83
      1  1bd6		       53		      .byte.b	83
      0  1bd7					      IPCRECEIVE		;Get the message
      0  1bd7					      db	81
      1  1bd7		       51		      .byte.b	81
      0  1bd8					      RTN
      0  1bd8					      db	25
      1  1bd8		       19		      .byte.b	25
    534  1bd9				   F2AZa1
      0  1bd9					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  1bd9					      db	33
      1  1bd9		       21		      .byte.b	33
      0  1bda					      db	(UNKNOWNVEC-*)-1
      1  1bda		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bdb					      TST	UNKNOWNVEC,")"
      0  1bdb					      db	32
      1  1bdb		       20		      .byte.b	32
      0  1bdc					      db	(UNKNOWNVEC-*)-1
      1  1bdc		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  1bdd					      db	")",0
      1  1bdd		       29 00		      .byte.b	")",0
      0  1bdf					      IPCIO		;Set the io bit and exit task till message
      0  1bdf					      db	83
      1  1bdf		       53		      .byte.b	83
      0  1be0					      IPCRECEIVE		;Get the message
      0  1be0					      db	81
      1  1be0		       51		      .byte.b	81
      0  1be1					      RTN
      0  1be1					      db	25
      1  1be1		       19		      .byte.b	25
    540  1be2				   F2AZb
      0  1be2					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  1be2					      db	32
      1  1be2		       20		      .byte.b	32
      0  1be3					      db	(UNKNOWNVEC-*)-1
      1  1be3		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1be4					      db	"C()",0
      1  1be4		       43 28 29 00	      .byte.b	"C()",0
      0  1be8					      IPCCHECK
      0  1be8					      db	82
      1  1be8		       52		      .byte.b	82
      0  1be9					      RTN
      0  1be9					      db	25
      1  1be9		       19		      .byte.b	25
    544  1bea
    545  1bea				   UNKNOWNID
      0  1bea					      IJMP	UNKNOWN
      0  1bea					      db	29
      1  1bea		       1d		      .byte.b	29
      0  1beb					      dw	UNKNOWN
      1  1beb		       7d 1a		      .word.w	UNKNOWN
    547  1bed							;
    548  1bed							; RND() is supposed to have an argument but if none
    549  1bed							; was provided, just assume a large value.
    550  1bed							;
    551  1bed				   F2A
      0  1bed					      TST	F2B,"RND("
      0  1bed					      db	32
      1  1bed		       20		      .byte.b	32
      0  1bee					      db	(F2B-*)-1
      1  1bee		       17		      .byte.b	(F2B-*)-1
      0  1bef					      db	"RND(",0
      1  1bef		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1bf4					      TST	F2A1,")"
      0  1bf4					      db	32
      1  1bf4		       20		      .byte.b	32
      0  1bf5					      db	(F2A1-*)-1
      1  1bf5		       07		      .byte.b	(F2A1-*)-1
      0  1bf6					      db	")",0
      1  1bf6		       29 00		      .byte.b	")",0
      0  1bf8					      LIT	32766
      0  1bf8					      db	27
      1  1bf8		       1b		      .byte.b	27
      0  1bf9					      dw	32766
      1  1bf9		       fe 7f		      .word.w	32766
      0  1bfb					      RANDOM
      0  1bfb					      db	37
      1  1bfb		       25		      .byte.b	37
      0  1bfc					      RTN
      0  1bfc					      db	25
      1  1bfc		       19		      .byte.b	25
    557  1bfd
    558  1bfd				   F2A1
      0  1bfd					      CALL	FACT	;GET RANGE
      0  1bfd					      db	28
      1  1bfd		       1c		      .byte.b	28
      0  1bfe					      dw	FACT
      1  1bfe		       4c 1b		      .word.w	FACT
      0  1c00					      TST	UNKNOWNVEC,")"
      0  1c00					      db	32
      1  1c00		       20		      .byte.b	32
      0  1c01					      db	(UNKNOWNVEC-*)-1
      1  1c01		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c02					      db	")",0
      1  1c02		       29 00		      .byte.b	")",0
      0  1c04					      RANDOM
      0  1c04					      db	37
      1  1c04		       25		      .byte.b	37
      0  1c05					      RTN
      0  1c05					      db	25
      1  1c05		       19		      .byte.b	25
    563  1c06
    564  1c06				   F2B
      0  1c06					      TST	F2B2,"ABS("
      0  1c06					      db	32
      1  1c06		       20		      .byte.b	32
      0  1c07					      db	(F2B2-*)-1
      1  1c07		       0e		      .byte.b	(F2B2-*)-1
      0  1c08					      db	"ABS(",0
      1  1c08		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1c0d					      CALL	EXPR	;get value
      0  1c0d					      db	28
      1  1c0d		       1c		      .byte.b	28
      0  1c0e					      dw	EXPR
      1  1c0e		       81 1a		      .word.w	EXPR
      0  1c10					      TST	UNKNOWNVEC,")"
      0  1c10					      db	32
      1  1c10		       20		      .byte.b	32
      0  1c11					      db	(UNKNOWNVEC-*)-1
      1  1c11		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c12					      db	")",0
      1  1c12		       29 00		      .byte.b	")",0
      0  1c14					      ABS
      0  1c14					      db	38
      1  1c14		       26		      .byte.b	38
      0  1c15					      RTN
      0  1c15					      db	25
      1  1c15		       19		      .byte.b	25
    570  1c16
    571  1c16				   F2B2
      0  1c16					      TST	F2Z,"STAT("
      0  1c16					      db	32
      1  1c16		       20		      .byte.b	32
      0  1c17					      db	(F2Z-*)-1
      1  1c17		       0f		      .byte.b	(F2Z-*)-1
      0  1c18					      db	"STAT(",0
      1  1c18		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1c1e					      Call	EXPR
      0  1c1e					      db	28
      1  1c1e		       1c		      .byte.b	28
      0  1c1f					      dw	EXPR
      1  1c1f		       81 1a		      .word.w	EXPR
      0  1c21					      TST	UNKNOWNVEC,")"
      0  1c21					      db	32
      1  1c21		       20		      .byte.b	32
      0  1c22					      db	(UNKNOWNVEC-*)-1
      1  1c22		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c23					      db	")",0
      1  1c23		       29 00		      .byte.b	")",0
      0  1c25					      TASKSTAT
      0  1c25					      db	66
      1  1c25		       42		      .byte.b	66
      0  1c26					      RTN
      0  1c26					      db	25
      1  1c26		       19		      .byte.b	25
    577  1c27				   F2Z
      0  1c27					      TST	F2ZA,"PID"
      0  1c27					      db	32
      1  1c27		       20		      .byte.b	32
      0  1c28					      db	(F2ZA-*)-1
      1  1c28		       06		      .byte.b	(F2ZA-*)-1
      0  1c29					      db	"PID",0
      1  1c29		       50 49 44 00	      .byte.b	"PID",0
      0  1c2d					      TASKPID
      0  1c2d					      db	77
      1  1c2d		       4d		      .byte.b	77
      0  1c2e					      RTN
      0  1c2e					      db	25
      1  1c2e		       19		      .byte.b	25
    581  1c2f				   F2ZA
      0  1c2f					      TST	F2FUNC,"CALL("	;call machine function
      0  1c2f					      db	32
      1  1c2f		       20		      .byte.b	32
      0  1c30					      db	(F2FUNC-*)-1
      1  1c30		       1f		      .byte.b	(F2FUNC-*)-1
      0  1c31					      db	"CALL(",0
      1  1c31		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1c37					      CALL	EXPR
      0  1c37					      db	28
      1  1c37		       1c		      .byte.b	28
      0  1c38					      dw	EXPR
      1  1c38		       81 1a		      .word.w	EXPR
      0  1c3a					      TST	F2B2A,COMMA
      0  1c3a					      db	32
      1  1c3a		       20		      .byte.b	32
      0  1c3b					      db	(F2B2A-*)-1
      1  1c3b		       0b		      .byte.b	(F2B2A-*)-1
      0  1c3c					      db	COMMA,0
      1  1c3c		       2c 00		      .byte.b	COMMA,0
      0  1c3e					      CALL	EXPR
      0  1c3e					      db	28
      1  1c3e		       1c		      .byte.b	28
      0  1c3f					      dw	EXPR
      1  1c3f		       81 1a		      .word.w	EXPR
      0  1c41					      TST	UNKNOWNVEC,")"
      0  1c41					      db	32
      1  1c41		       20		      .byte.b	32
      0  1c42					      db	(UNKNOWNVEC-*)-1
      1  1c42		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c43					      db	")",0
      1  1c43		       29 00		      .byte.b	")",0
      0  1c45					      CALLFUNC
      0  1c45					      db	53
      1  1c45		       35		      .byte.b	53
      0  1c46					      RTN
      0  1c46					      db	25
      1  1c46		       19		      .byte.b	25
    589  1c47							; Run the gosub within this function
    590  1c47				   F2B2A
      0  1c47					      TST	UNKNOWNID,")"
      0  1c47					      db	32
      1  1c47		       20		      .byte.b	32
      0  1c48					      db	(UNKNOWNID-*)-1
      1  1c48		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  1c49					      db	")",0
      1  1c49		       29 00		      .byte.b	")",0
      0  1c4b					      LIT	0
      0  1c4b					      db	27
      1  1c4b		       1b		      .byte.b	27
      0  1c4c					      dw	0
      1  1c4c		       00 00		      .word.w	0
      0  1c4e					      CALLFUNC
      0  1c4e					      db	53
      1  1c4e		       35		      .byte.b	53
      0  1c4f					      RTN
      0  1c4f					      db	25
      1  1c4f		       19		      .byte.b	25
    595  1c50
      0  1c50				   F2FUNC     TST	F2C,"GOFN"
      0  1c50					      db	32
      1  1c50		       20		      .byte.b	32
      0  1c51					      db	(F2C-*)-1
      1  1c51		       0c		      .byte.b	(F2C-*)-1
      0  1c52					      db	"GOFN",0
      1  1c52		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  1c57					      Call	GOSUBSTATEMENT
      0  1c57					      db	28
      1  1c57		       1c		      .byte.b	28
      0  1c58					      dw	GOSUBSTATEMENT
      1  1c58		       87 1c		      .word.w	GOSUBSTATEMENT
      0  1c5a					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  1c5a					      db	8
      1  1c5a		       08		      .byte.b	8
      0  1c5b					      db	GOSUB_RTN_VALUE
      1  1c5b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  1c5c					      XFER
      0  1c5c					      db	7
      1  1c5c		       07		      .byte.b	7
    600  1c5d				   GOFNRet
      0  1c5d					      RTN
      0  1c5d					      db	25
      1  1c5d		       19		      .byte.b	25
    602  1c5e				   F2C
      0  1c5e					      TSTV	F0
      0  1c5e					      db	33
      1  1c5e		       21		      .byte.b	33
      0  1c5f					      db	(F0-*)-1
      1  1c5f		       15		      .byte.b	(F0-*)-1
      0  1c60					      TST	F2CLocalTask,"!"
      0  1c60					      db	32
      1  1c60		       20		      .byte.b	32
      0  1c61					      db	(F2CLocalTask-*)-1
      1  1c61		       05		      .byte.b	(F2CLocalTask-*)-1
      0  1c62					      db	"!",0
      1  1c62		       21 00		      .byte.b	"!",0
      0  1c64					      IND		; we just got a pid
      0  1c64					      db	20
      1  1c64		       14		      .byte.b	20
      0  1c65					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  1c65					      db	93
      1  1c65		       5d		      .byte.b	93
      0  1c66					      db	(UNKNOWNID-*)-1
      1  1c66		       83		      .byte.b	(UNKNOWNID-*)-1
    607  1c67
    608  1c67				   F2CLocalTask
      0  1c67					      TST	F2C1,"["
      0  1c67					      db	32
      1  1c67		       20		      .byte.b	32
      0  1c68					      db	(F2C1-*)-1
      1  1c68		       0a		      .byte.b	(F2C1-*)-1
      0  1c69					      db	"[",0
      1  1c69		       5b 00		      .byte.b	"[",0
      0  1c6b					      CALL	EXPR
      0  1c6b					      db	28
      1  1c6b		       1c		      .byte.b	28
      0  1c6c					      dw	EXPR
      1  1c6c		       81 1a		      .word.w	EXPR
      0  1c6e					      TST	UNKNOWNID,"]"
      0  1c6e					      db	32
      1  1c6e		       20		      .byte.b	32
      0  1c6f					      db	(UNKNOWNID-*)-1
      1  1c6f		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  1c70					      db	"]",0
      1  1c70		       5d 00		      .byte.b	"]",0
      0  1c72					      SUBSCRIPT
      0  1c72					      db	64
      1  1c72		       40		      .byte.b	64
    613  1c73				   F2C1
      0  1c73					      IND		;YES, GET THE VALUE.
      0  1c73					      db	20
      1  1c73		       14		      .byte.b	20
      0  1c74					      RTN
      0  1c74					      db	25
      1  1c74		       19		      .byte.b	25
    616  1c75				   F0
      0  1c75					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1c75					      db	35
      1  1c75		       23		      .byte.b	35
      0  1c76					      db	(F1-*)-1
      1  1c76		       01		      .byte.b	(F1-*)-1
      0  1c77					      RTN
      0  1c77					      db	25
      1  1c77		       19		      .byte.b	25
    619  1c78				   F1
      0  1c78					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  1c78					      db	32
      1  1c78		       20		      .byte.b	32
      0  1c79					      db	(F2RTN-*)-1
      1  1c79		       09		      .byte.b	(F2RTN-*)-1
      0  1c7a					      db	"(",0
      1  1c7a		       28 00		      .byte.b	"(",0
      0  1c7c					      CALL	EXPR
      0  1c7c					      db	28
      1  1c7c		       1c		      .byte.b	28
      0  1c7d					      dw	EXPR
      1  1c7d		       81 1a		      .word.w	EXPR
      0  1c7f					      TST	F2,")"
      0  1c7f					      db	32
      1  1c7f		       20		      .byte.b	32
      0  1c80					      db	(F2-*)-1
      1  1c80		       03		      .byte.b	(F2-*)-1
      0  1c81					      db	")",0
      1  1c81		       29 00		      .byte.b	")",0
    623  1c83				   F2RTN
      0  1c83					      RTN
      0  1c83					      db	25
      1  1c83		       19		      .byte.b	25
    625  1c84
    626  1c84				   F2
      0  1c84					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1c84					      db	13
      1  1c84		       0d		      .byte.b	13
      0  1c85					      dw	ERR_SYNTAX
      1  1c85		       05 00		      .word.w	ERR_SYNTAX
    628  1c87							;
    629  1c87							;=============================================================
    630  1c87							; Gosub can be both a Function and a Subroutine
    631  1c87				   GOSUBSTATEMENT
      0  1c87					      CALL	EXPR	;GET DESTINATION
      0  1c87					      db	28
      1  1c87		       1c		      .byte.b	28
      0  1c88					      dw	EXPR
      1  1c88		       81 1a		      .word.w	EXPR
      0  1c8a					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  1c8a					      db	32
      1  1c8a		       20		      .byte.b	32
      0  1c8b					      db	(GOSUBDONE-*)-1
      1  1c8b		       14		      .byte.b	(GOSUBDONE-*)-1
      0  1c8c					      db	"(",0
      1  1c8c		       28 00		      .byte.b	"(",0
      0  1c8e					      STK2TMP		;Transfer stack top to temp
      0  1c8e					      db	95
      1  1c8e		       5f		      .byte.b	95
      0  1c8f					      PUSHMATHSTACK		;Record stack frame for return
      0  1c8f					      db	84
      1  1c8f		       54		      .byte.b	84
    636  1c90				   GOSUBLOOP
      0  1c90					      CALL	EXPR	; Allows what ever fits onto stack
      0  1c90					      db	28
      1  1c90		       1c		      .byte.b	28
      0  1c91					      dw	EXPR
      1  1c91		       81 1a		      .word.w	EXPR
      0  1c93					      INCPARMCOUNT
      0  1c93					      db	88
      1  1c93		       58		      .byte.b	88
      0  1c94					      TST	GOSUBParmDONE,COMMA
      0  1c94					      db	32
      1  1c94		       20		      .byte.b	32
      0  1c95					      db	(GOSUBParmDONE-*)-1
      1  1c95		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  1c96					      db	COMMA,0
      1  1c96		       2c 00		      .byte.b	COMMA,0
      0  1c98					      IJMP	GOSUBLOOP
      0  1c98					      db	29
      1  1c98		       1d		      .byte.b	29
      0  1c99					      dw	GOSUBLOOP
      1  1c99		       90 1c		      .word.w	GOSUBLOOP
    641  1c9b				   GOSUBParmDONE
      0  1c9b					      TST	F2,")"
      0  1c9b					      db	32
      1  1c9b		       20		      .byte.b	32
      0  1c9c					      db	(F2-*)-1
      1  1c9c		       e7		      .byte.b	(F2-*)-1
      0  1c9d					      db	")",0
      1  1c9d		       29 00		      .byte.b	")",0
      0  1c9f					      TMP2STK		;Restore line to goto
      0  1c9f					      db	96
      1  1c9f		       60		      .byte.b	96
    644  1ca0				   GOSUBDONE
      0  1ca0					      RTN
      0  1ca0					      db	25
      1  1ca0		       19		      .byte.b	25
    646  1ca1
    647  1ca1		       1c a1	   ILEND      equ	*
------- FILE mytb.asm
   2166  1ca1		       1c a1	   PROGEND    equ	*
   2167  1ca1
   2168  1ca1
   2169  1ca1							;=====================================================
   2170  1ca1							; Define start of non page zero data
   2171 U1cb1					      seg.u	TBData
   2172 U1cb1
   2173 U1cb1							;=====================================================
   2174 U1cb1							; These are storage items not in page zero.
   2175 U1cb1							;
   2176 U1cb1							; IRQ BASIC Code Service RTN Support
      0 U1cb1				   SaveIrqReg db	0	; Store current setting
      1 U1cb1		       00		      .byte.b	0
      0 U1cb2				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1cb2		       00		      .byte.b	0
      0 U1cb3				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1cb3		       00		      .byte.b	0
      0 U1cb4				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1cb4		       00 00		      .byte.b	0,0
   2181 U1cb6
   2182 U1cb6							;
   2183 U1cb6							;==================================================================================================
   2184 U1cb6							; Task Management information
   2185 U1cb6							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2186 U1cb6							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2187 U1cb6							; Task switchs happen at the beginning of the next Basic command line
   2188 U1cb6							; It will not happen during an input or output operations
   2189 U1cb6							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2190 U1cb6							; Task Zero is always the root task, main line program
   2191 U1cb6							;
   2192 U1cb6							; Layout is repeated for each configured task
   2193 U1cb6							; Task Table Byte   use masks follow
   2194 U1cb6		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2195 U1cb6		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2196 U1cb6		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2197 U1cb6		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2198 U1cb6		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2199 U1cb6
   2200 U1cb6		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2201 U1cb7		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2202 U1cb7		       1d b1	   TASKTABLEEND equ	*	; End of task table
   2203 U1cb7		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2204 U1db1
   2205 U1db1							;Task Cycle Counter and reset count
   2206 U1db1		       00	   taskCurrentCycles ds	1
   2207 U1db2		       00	   taskResetValue ds	1
   2208 U1db3		       00	   taskCounter ds	1	; Count of active tasks
   2209 U1db4
   2210 U1db4							;
   2211 U1db4							; Math stack and IL call and Gosub/For-next return stack definitions
   2212 U1db4							;
   2213 U1db4		       1d b4	   STACKSTART equ	*
   2214 U1db4		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2215 U1f44		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2216 U20d4		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2217 U2354		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2218 U2354		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2219 U2354		       25 70	   STACKEND   equ	*
   2220 U2354		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2221 U2570							;
   2222 U2570							;
   2223 U2570		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2224 U25f4		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2225 U25f5		       00	   printtx    ds	1	;temp X for print funcs
   2226 U25f6		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2227 U25f7		       00	   promptChar ds	1	;the character to use for a prompt
   2228 U25f8		       00	   diddigit   ds	1	;for leading zero suppression
   2229 U25f9		       00	   putsy      ds	1
   2230 U25fa		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2231 U25fc		       00	   sign       ds	1	;0 = positive, else negative
   2232 U25fd		       00 00	   rtemp1     ds	2	;Temp for x and y
   2233 U25ff		       00 00	   random     ds	2
   2234 U2601		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2235 U2603		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2236 U2605		       00	   tempy      ds	1	;temp y storage
   2237 U2606				  -	      if	XKIM
   2238 U2606				  -buffer     ds	BUFFER_SIZE
   2239 U2606					      endif
   2240 U2606							;
   2241 U2606							; PROGRAMEND is the end of the user's BASIC program.
   2242 U2606							; More precisely, it is one byte past the end.  Or,
   2243 U2606							; it's where the next line added to the end will be
   2244 U2606							; placed.
   2245 U2606							;
   2246 U2606		       00 00	   PROGRAMEND ds	2	; End of users basic program
   2247 U2608		       00 00	   HighMem    ds	2	; highest location
   2248 U260a		       00 00	   UsedMem    ds	2	; size of user program
   2249 U260c		       00 00	   FreeMem    ds	2	; amount of free memory
   2250 U260e							;
   2251 U260e							;=====================================================
   2252 U260e							; This is the start of the user's BASIC program space.
   2253 U260e							;
   2254 U260e							; PERSONAL GOAL: This should be no larger than $0DFF.
   2255 U260e							;		  0200-05FF = 1K
   2256 U260e							;		  0200-09FF = 2K
   2257 U260e							;		  0200-0DFF = 3K
   2258 U260e							;		  0200-11FF = 4K
   2259 U260e							;		  0200-13FF = 4.5K
   2260 U260e							;
   2261 U260e				  -	      if	FIXED
   2262 U260e				  -	      org	$2000
   2263 U260e					      endif
   2264 U260e		       26 0e	   ProgramStart equ	*
   2265 U260e							;/*
   2266 U260e							;	if	CTMON65 || XKIM
   2267 U260e							;		SEG Code
   2268 U260e							;		org	AutoRun
   2269 U260e							;		dw	TBasicCold
   2270 U260e							;	endif
   2271 U260e							;*/
   2272 U260e					      end
