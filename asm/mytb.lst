------- FILE mytb.asm LEVEL 1 PASS 6
      1 U275b				   input      processor	6502
      2 U275b ????						;=====================================================
      3 U275b ????						; Concurrent Tiny Basic, no longer Tiny
      4 U275b ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U275b ????						; Free Time. Now abiut 6K Full OS features.
      6 U275b ????						;
      7 U275b ????						; While working on the Corsham Technologies KIM Clone
      8 U275b ????						; project, I wanted to include a TINY BASIC since that
      9 U275b ????						; was a highly desirable feature of early computers.
     10 U275b ????						;
     11 U275b ????						; Rather than negotiating copyright issues for
     12 U275b ????						; existing BASICs, I decided to just write one from
     13 U275b ????						; scratch.
     14 U275b ????						;
     15 U275b ????						; 10/07/2017
     16 U275b ????						;
     17 U275b ????						; This implements a stripped down Tiny BASIC
     18 U275b ????						; interpreter using the Interpretive Language (IL)
     19 U275b ????						; method as described in the first few issues of
     20 U275b ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U275b ????						; to write various languages simply by changing the
     22 U275b ????						; IL code rather than the interpreter itself.
     23 U275b ????						;
     24 U275b ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U275b ????						;		* Fixed major bug in findLine that
     26 U275b ????						;		  caused corrupted lines, crashes, etc.
     27 U275b ????						;		* If no parameter given to RND, assume
     28 U275b ????						;		  32766.
     29 U275b ????						;		* No more error 5 when a program
     30 U275b ????						;		  reaches the end without an END.
     31 U275b ????						;
     32 U275b ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U275b ????						;		 * Unexpanded version to play with everything
     34 U275b ????						;		 * Add some usefull system level functions
     35 U275b ????						;		 * allow a larger number of tiny basic formats
     36 U275b ????						;		 * Add byte at start of line holding length
     37 U275b ????						;		   for faster execution of goto and gosub
     38 U275b ????						;		 * Re-added gosub
     39 U275b ????						;		 * allow ; or , at end if print stmt
     40 U275b ????						;		   without CRLF being added.
     41 U275b ????						;		 * Added extended function erase to
     42 U275b ????						;		   use the extended ctmon65 rm file
     43 U275b ????						;		 * Fix quoted text to not have to backtrack
     44 U275b ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U275b ????						;		 * Add concurrency features
     46 U275b ????						;
     47 U275b ????						; www.corshamtech.com
     48 U275b ????						; bob@corshamtech.com
     49 U275b ????						; JustLostInTime@gmail.com
     50 U275b ????						;
     51 U275b ????						;=====================================================
     52 U275b ????						;
     53 U275b ????						; Create TRUE and FALSE values for conditionals.
     54 U275b ????						;
     55 U275b ????
     56 U275b ????	       00 00	   FALSE      equ	0
     57 U275b ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U275b ????						;
     59 U275b ????						;---------------------------------------------------------
     60 U275b ????						; One of these must be set to indicate which environment
     61 U275b ????						; Tiny BASIC will be running in.  Here are the current
     62 U275b ????						; environments:
     63 U275b ????						;
     64 U275b ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U275b ????						; more K of RAM.
     66 U275b ????						;
     67 U275b ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U275b ????						; which enhances, without replacing, the standard KIM
     69 U275b ????						; monitor.  It gives access to routines to save/load files
     70 U275b ????						; to a micro SD card.
     71 U275b ????						;
     72 U275b ????						; CTMON65 is a from-scratch monitor written for the
     73 U275b ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U275b ????						; easily be ported to other systems.  It has support for
     75 U275b ????						; using a micro SD card for file storage/retrieval.
     76 U275b ????						;
     77 U275b ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U275b ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U275b ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U275b ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U275b ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U275b ????						;
     83 U275b ????						;   Need to define some macros for the dasm assembler
     84 U275b ????						;
     85 U275b ????				      MACRO	dw
     86 U275b ????				      .word	{0}
     87 U275b ????				      ENDM
     88 U275b ????
     89 U275b ????				      MACRO	db
     90 U275b ????				      .byte	{0}
     91 U275b ????				      ENDM
     92 U275b ????
     93 U275b ????						;
     94 U275b ????						; If set, include disk functions.
     95 U275b ????						;
     96 U275b ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U275b ????						;
     98 U275b ????						; If ILTRACE is set then dump out the address of every
     99 U275b ????						; IL opcode before executing it.
    100 U275b ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U275b ????						;
    102 U275b ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U275b ????						;
    104 U275b ????						; If FIXED is set, put the IL code and the user
    105 U275b ????						; program space at fixed locations in memory.	This is
    106 U275b ????						; meant only for debugging.
    107 U275b ????						;
    108 U275b ????	       00 00	   FIXED      equ	FALSE
    109 U275b ????						;
    110 U275b ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U275b ????						; BASIC, so keep this small!
    112 U275b ????						;
    113 U275b ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U275b ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U275b ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U275b ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U275b ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U275b ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U275b ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U275b ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U275b ????						;
    122 U275b ????						; Gosub entry types
    123 U275b ????
    124 U275b ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U275b ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U275b ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U275b ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U275b ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U275b ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U275b ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U275b ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U275b ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U275b ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U275b ????						;
    135 U275b ????						; Common ASCII constants
    136 U275b ????						;
    137 U275b ????	       00 07	   BEL	      equ	$07
    138 U275b ????	       00 08	   BS	      equ	$08
    139 U275b ????	       00 09	   TAB	      equ	$09
    140 U275b ????	       00 0a	   LF	      equ	$0A
    141 U275b ????	       00 0d	   CR	      equ	$0D
    142 U275b ????	       00 22	   quote      equ	$22
    143 U275b ????	       00 20	   SPACE      equ	$20
    144 U275b ????	       00 2c	   COMMA      equ	',
    145 U275b ????	       00 3b	   SEMICOLON  equ	';
    146 U275b ????	       00 3a	   COLON      equ	':
    147 U275b ????	       00 24	   DOLLAR     equ	'$
    148 U275b ????						;
    149 U275b ????						; These are error codes
    150 U275b ????						;
    151 U275b ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U275b ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U275b ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U275b ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U275b ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U275b ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U275b ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U275b ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U275b ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U275b ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U275b ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U275b ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U275b ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U275b ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U275b ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U275b ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U275b ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U275b ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U275b ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U275b ????						;
    171 U275b ????						;=====================================================
    172 U275b ????						; Zero page storage.
    173 U275b ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  1de3 ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       15 be	   CRLF       equ	tbcrlf
    307  0206		       0d ac	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       17 0d	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 ed 16    cold2      jsr	SetOutConsole
    314  0209		       20 fa 16 	      jsr	SetInConsole
    315  020c		       20 0d 17 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    319  023c							;
    320  023c		       20 c9 0d 	      jsr	MemInit	;setup the free space available
    321  023f
    322  023f		       a9 01	   calcstack  lda	#1
    323  0241		       8d f7 1e 	      sta	taskCounter	; Initialize number of tasks to 1
    324  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  0246		       8d f9 1d 	      sta	taskTable	; mark the main task as active
    326  0249		       20 b6 0e 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  024c		       a9 17		      lda	#IL&$ff
    328  024e		       85 43		      sta	ILPC
    329  0250		       a9 19		      lda	#IL>>8
    330  0252		       85 44		      sta	ILPC+1
    331  0254							;
    332  0254							;		  lda	  ProgramStart		     ; user prog
    333  0254							;		  sta	  ProgramEnd
    334  0254							;		  lda	  ProgramStart+1
    335  0254							;		  sta	  ProgramEnd+1
    336  0254							;
    337  0254							;  Init time slices defaults
    338  0254		       a9 02		      lda	#TASKCYCLESHIGH
    339  0256		       8d f6 1e 	      sta	taskResetValue+1
    340  0259		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  025b		       8d f5 1e 	      sta	taskResetValue
    342  025e							;
    343  025e							; Initialize the pseudo-random number sequence...
    344  025e							;
    345  025e		       a9 5a		      lda	#$5a
    346  0260		       8d 41 27 	      sta	rtemp1
    347  0263		       a9 9d		      lda	#%10011101
    348  0265		       8d 43 27 	      sta	random
    349  0268		       a9 5b		      lda	#%01011011
    350  026a		       8d 44 27 	      sta	random+1
    351  026d							;
    352  026d							;   Insert a Basic irq handler for the basic Language
    353  026d		       a9 7a		      lda	#ServiceIrq&$ff
    354  026f		       8d 00 df 	      sta	IRQvec
    355  0272		       a9 02		      lda	#ServiceIrq>>8
    356  0274		       8d 01 df 	      sta	IRQvec+1
    357  0277		       4c 9f 02 	      jmp	coldtwo
    358  027a
    359  027a							;
    360  027a							; This is the Basic IRQ handler
    361  027a		       48	   ServiceIrq pha
    362  027b		       ad f4 1d 	      lda	IRQStatus
    363  027e		       f0 0a		      BEQ	RetIrq
    364  0280		       ad f5 1d 	      lda	IRQPending
    365  0283		       d0 05		      bne	RetIrq
    366  0285		       a9 01		      lda	#1
    367  0287		       8d f5 1d 	      sta	IRQPending
    368  028a		       68	   RetIrq     pla
    369  028b		       40		      rti
    370  028c							;
    371  028c							;
    372  028c							; This is the warm start entry point
    373  028c							;
    374  028c		       20 ed 16    warm2      jsr	SetOutConsole
    375  028f		       20 fa 16 	      jsr	SetInConsole
    376  0292		       20 be 15 	      jsr	CRLF
    377  0295		       ad 3e 27 	      lda	errGoto
    378  0298		       85 43		      sta	ILPC
    379  029a		       ad 3f 27 	      lda	errGoto+1
    380  029d		       85 44		      sta	ILPC+1
    381  029f							;
    382  029f							; And continue with both starts here
    383  029f							;
    384  029f				   coldtwo
    385  029f							;
    386  029f							; The ILTrace flag is now run-time settable.
    387  029f							;
    388  029f		       a9 00		      lda	#ILTRACE&$ff
    389  02a1		       85 40		      sta	ILTrace
    390  02a3							;
    391  02a3
    392  02a3		       a9 00		      lda	#0
    393  02a5		       85 5b		      sta	RunMode
    394  02a7		       8d b4 26 	      sta	LINBUF
    395  02aa
    396  02aa							; Clear everything from the stacks
    397  02aa
    398  02aa		       8d 4f 27 	      sta	taskIOPending	; No one waiting for io
    399  02ad		       8d 50 27 	      sta	taskRDPending	; No one waiting for bg io
    400  02b0
    401  02b0		       20 29 0f 	      jsr	taskReset
    402  02b3							;
    403  02b3		       a9 b4		      lda	#LINBUF&$ff
    404  02b5		       85 4f		      sta	CURPTR
    405  02b7		       a9 26		      lda	#LINBUF>>8
    406  02b9		       85 50		      sta	CURPTR+1	;fall through...
    407  02bb
    408  02bb							;=====================================================
    409  02bb							; This is the top of the IL interpreter.  This fetches
    410  02bb							; and executes the instruction currently pointed to
    411  02bb							; by ILPC and adjusts ILPC to point to the next
    412  02bb							; instruction to execute.
    413  02bb							;
    414  02bb		       ce f3 1e    NextIL     dec	taskCurrentCycles
    415  02be		       d0 03		      bne	NextIlNow
    416  02c0		       20 52 0f 	      jsr	iTaskSwitch	;check for a task switch
    417  02c3		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02c5		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02c7
    420  02c7		       20 4a 16 	      jsr	dbgLine	;Print the IL trace information
    421  02ca
    422  02ca		       a4 51	   NextIL2    ldy	CUROFF
    423  02cc		       20 b5 15 	      jsr	SkipSpaces
    424  02cf		       84 51		      sty	CUROFF
    425  02d1							;Task IO Management
    426  02d1		       ad 50 27 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d4		       f0 08		      beq	NextILStr
    428  02d6		       20 05 14 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02d9		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02db		       ce 50 27 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02de							;
    432  02de		       20 88 12    NextILStr  jsr	getILByte
    433  02e1							;
    434  02e1							; When the handler is called, these are the conditions
    435  02e1							; of several important items:
    436  02e1							;
    437  02e1							;    (ILPC) will point to the byte AFTER the IL
    438  02e1							;    opcode being executed.
    439  02e1							;
    440  02e1							;    (CURPTR),CUROFF will point to the start of the
    441  02e1							;    next word in the input buffer.  Ie, the next word
    442  02e1							;    in the user program.
    443  02e1							;
    444  02e1		       0a		      asl
    445  02e2		       c9 cc		      cmp	#ILTBLend-ILTBL+2
    446  02e4		       90 33		      bcc	ILgood
    447  02e6							;
    448  02e6							; This handles an illegal IL opcode.  This is serious
    449  02e6							; and there's no way to recover.
    450  02e6							;
    451  02e6		       20 0d 17    ILbad      jsr	puts
      0  02e9					      db	CR,LF
      1  02e9		       0d 0a		      .byte.b	CR,LF
      0  02eb					      db	"Illegal IL "
      1  02eb		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f6					      db	0
      1  02f6		       00		      .byte.b	0
    455  02f7							;
    456  02f7							; Well this is awkward, we need to back up the IL
    457  02f7							; by one since it no longer points to the current
    458  02f7							; opcode.
    459  02f7							;
    460  02f7		       20 95 12 	      jsr	decIL
    461  02fa							;
    462  02fa		       a0 00		      ldy	#0
    463  02fc		       b1 43		      lda	(ILPC),y
    464  02fe		       20 ac 0d 	      jsr	OUTHEX
    465  0301		       20 0d 17 	      jsr	puts
      0  0304					      db	" at ",0
      1  0304		       20 61 74 20*	      .byte.b	" at ",0
    467  0309		       a5 44		      lda	ILPC+1
    468  030b		       20 ac 0d 	      jsr	OUTHEX
    469  030e		       a5 43		      lda	ILPC
    470  0310		       20 ac 0d 	      jsr	OUTHEX
    471  0313		       20 be 15 	      jsr	CRLF
    472  0316		       4c 03 f0 	      jmp	MONITOR
    473  0319							;
    474  0319							; Just jump to the address (ILPC),y.  Have to do
    475  0319							; some goofy stuff.
    476  0319							;
    477  0319		       a8	   ILgood     tay		;move index into Y
    478  031a		       b9 27 03 	      lda	ILTBL,y
    479  031d		       85 59		      sta	dpl
    480  031f		       b9 28 03 	      lda	ILTBL+1,y
    481  0322		       85 5a		      sta	dpl+1
    482  0324		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0327							;
    484  0327							;=====================================================
    485  0327							; This is the IL jump table.  The IL opcode is
    486  0327							; mulitplied by two, then looked-up in this table.
    487  0327							; There is absolutely nothing special about the order
    488  0327							; of entries here... they all decode at exactly the
    489  0327							; same speed.	However the entry number must match the
    490  0327							; values in IL.inc.
    491  0327							;
    492  0327				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0327					      include	"ilvectortable.asm"
      1  0327					      seg	Code
      2  0327
      0  0327					      dw	iXINIT	;0
      1  0327		       29 04		      .word.w	iXINIT
      0  0329					      dw	iDONE	;1
      1  0329		       44 04		      .word.w	iDONE
      0  032b					      dw	iPRS	;2
      1  032b		       60 04		      .word.w	iPRS
      0  032d					      dw	iPRN	;3
      1  032d		       6a 04		      .word.w	iPRN
      0  032f					      dw	iSPC	;4
      1  032f		       73 04		      .word.w	iSPC
      0  0331					      dw	iNLINE	;5
      1  0331		       1e 09		      .word.w	iNLINE
      0  0333					      dw	iNXT	;6
      1  0333		       7b 04		      .word.w	iNXT
      0  0335					      dw	iXFER	;7
      1  0335		       a7 04		      .word.w	iXFER
      0  0337					      dw	iSAV	;8
      1  0337		       d4 04		      .word.w	iSAV
      0  0339					      dw	iRSTR	;9
      1  0339		       17 05		      .word.w	iRSTR
      0  033b					      dw	iCMPR	;10
      1  033b		       4c 05		      .word.w	iCMPR
      0  033d					      dw	iINNUM	;11
      1  033d		       cd 05		      .word.w	iINNUM
      0  033f					      dw	iFIN	;12
      1  033f		       01 06		      .word.w	iFIN
      0  0341					      dw	iERR	;13
      1  0341		       15 06		      .word.w	iERR
      0  0343					      dw	iADD	;14
      1  0343		       85 06		      .word.w	iADD
      0  0345					      dw	iSUB	;15
      1  0345		       9b 06		      .word.w	iSUB
      0  0347					      dw	iNEG	;16
      1  0347		       b1 06		      .word.w	iNEG
      0  0349					      dw	iMUL	;17
      1  0349		       c9 06		      .word.w	iMUL
      0  034b					      dw	iDIV	;18
      1  034b		       09 07		      .word.w	iDIV
      0  034d					      dw	iSTORE	;19
      1  034d		       5f 07		      .word.w	iSTORE
      0  034f					      dw	iIND	;20
      1  034f		       77 07		      .word.w	iIND
      0  0351					      dw	iLST	;21
      1  0351		       e5 07		      .word.w	iLST
      0  0353					      dw	iINIT	;22
      1  0353		       f1 03		      .word.w	iINIT
      0  0355					      dw	iGETLINE	;23
      1  0355		       4a 08		      .word.w	iGETLINE
      0  0357					      dw	iINSRT	;24
      1  0357		       5a 08		      .word.w	iINSRT
      0  0359					      dw	iRTN	;25
      1  0359		       18 09		      .word.w	iRTN
      0  035b					      dw	MONITOR	;26
      1  035b		       03 f0		      .word.w	MONITOR
      0  035d					      dw	iLIT	;27
      1  035d		       3e 09		      .word.w	iLIT
      0  035f					      dw	iCALL	;28
      1  035f		       24 09		      .word.w	iCALL
      0  0361					      dw	iJMP	;29
      1  0361		       2c 09		      .word.w	iJMP
      0  0363					      dw	iVINIT	;30
      1  0363		       5b 09		      .word.w	iVINIT
      0  0365					      dw	iERRGOTO	;31
      1  0365		       61 09		      .word.w	iERRGOTO
      0  0367					      dw	iTST	;32
      1  0367		       6d 09		      .word.w	iTST
      0  0369					      dw	iTSTV	;33
      1  0369		       4e 0a		      .word.w	iTSTV
      0  036b					      dw	iTSTL	;34
      1  036b		       cd 0a		      .word.w	iTSTL
      0  036d					      dw	iTSTN	;35
      1  036d		       e8 0a		      .word.w	iTSTN
      0  036f					      dw	iFREE	;36
      1  036f		       65 0b		      .word.w	iFREE
      0  0371					      dw	iRANDOM	;37
      1  0371		       6e 0b		      .word.w	iRANDOM
      0  0373					      dw	iABS	;38
      1  0373		       3f 0c		      .word.w	iABS
     42  0375							;
     43  0375							; Disk functions.  There must be pointers
     44  0375							; to functions even if no disk is supported.
     45  0375							; Makes things easier in IL.inc.
     46  0375							;
     47  0375					      if	DISK_ACCESS
      0  0375					      dw	iOPENREAD	;39
      1  0375		       f2 17		      .word.w	iOPENREAD
      0  0377					      dw	iOPENWRITE	;40
      1  0377		       46 18		      .word.w	iOPENWRITE
      0  0379					      dw	iDCLOSE	;41
      1  0379		       ca 18		      .word.w	iDCLOSE
      0  037b					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037b		       65 18		      .word.w	iDGETLINE
      0  037d					      dw	iDLIST	;43 Did you remeber your towel?
      1  037d		       c4 18		      .word.w	iDLIST
      0  037f					      dw	iDDIR	;44
      1  037f		       9f 18		      .word.w	iDDIR
      0  0381					      dw	iRMFILE	;45
      1  0381		       20 18		      .word.w	iRMFILE
     55  0383				  -	      else
     56  0383				  -	      dw	NextIL	;39
     57  0383				  -	      dw	NextIL	;40
     58  0383				  -	      dw	NextIL	;41
     59  0383				  -	      dw	NextIL	;42
     60  0383				  -	      dw	NextIL	;43
     61  0383				  -	      dw	NextIL	;44
     62  0383				  -	      dw	NextIL	;45
     63  0383					      endif
     64  0383							;
      0  0383					      dw	iCLEARSCREEN	;46
      1  0383		       66 17		      .word.w	iCLEARSCREEN
      0  0385					      dw	iPOKEMEMORY	;47
      1  0385		       cc 0b		      .word.w	iPOKEMEMORY
      0  0387					      dw	iPEEKMEMORY	;48
      1  0387		       e1 0b		      .word.w	iPEEKMEMORY
      0  0389					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0389		       b4 09		      .word.w	iTSTLET
      0  038b					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038b		       f2 09		      .word.w	iTSTDONE
      0  038d					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038d		       0e 0c		      .word.w	iGETCHAR
      0  038f					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038f		       22 0c		      .word.w	iPUTCHAR
      0  0391					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0391		       f7 0b		      .word.w	iCallFunc
      0  0393					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0393		       9d 05		      .word.w	iBranch
      0  0395					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0395		       97 09		      .word.w	iTSTStr
      0  0397					      dw	iSetIrq	;56	   sets the irq handler
      1  0397		       bc 0c		      .word.w	iSetIrq
      0  0399					      dw	iTstIrq	;57	   test if irq is pending
      1  0399		       2d 0b		      .word.w	iTstIrq
      0  039b					      dw	iRET	;58	   return from interupt
      1  039b		       05 05		      .word.w	iRET
      0  039d					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039d		       e4 05		      .word.w	iINSTR
      0  039f					      dw	iMOD	;60	   returns remainder of division
      1  039f		       12 07		      .word.w	iMOD
      0  03a1					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a1		       a6 0f		      .word.w	iTaskSet
      0  03a3					      dw	iETask	;62	   Terminates a task
      1  03a3		       d1 10		      .word.w	iETask
      0  03a5					      dw	iNTask	;63	   goto next task
      1  03a5		       84 10		      .word.w	iNTask
      0  03a7					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a7		       8c 07		      .word.w	iArray
      0  03a9					      dw	iTaskKill	;65	   kill a running task
      1  03a9		       7c 10		      .word.w	iTaskKill
      0  03ab					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ab		       50 10		      .word.w	iTaskStat
      0  03ad					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03ad		       2d 0c		      .word.w	iHexOut
      0  03af					      dw	iReadComplete	;68	   Called after a background read completes
      1  03af		       b9 05		      .word.w	iReadComplete
      0  03b1					      dw	iReadStart	;69	   Called to start a background read request
      1  03b1		       af 05		      .word.w	iReadStart
      0  03b3					      dw	iStartIO	;70	   Lock task until io complete
      1  03b3		       b4 10		      .word.w	iStartIO
      0  03b5					      dw	iEndIO	;71	   release task lock for io
      1  03b5		       ba 10		      .word.w	iEndIO
      0  03b7					      dw	iLogNot	;72	   Logical not
      1  03b7		       98 0c		      .word.w	iLogNot
      0  03b9					      dw	iLogOr	;73	   Logical Or
      1  03b9		       6e 0c		      .word.w	iLogOr
      0  03bb					      dw	iLogAnd	;74	   Logical And
      1  03bb		       59 0c		      .word.w	iLogAnd
      0  03bd					      dw	iLogXor	;75	   Logical Xor
      1  03bd		       83 0c		      .word.w	iLogXor
      0  03bf					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bf		       8f 10		      .word.w	iWTASK
      0  03c1					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c1		       c5 10		      .word.w	iTASKPID
      0  03c3					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c3		       f8 0c		      .word.w	iTRACEPROG
      0  03c5					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c5		       cb 15		      .word.w	idbgBasic
      0  03c7					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c7		       87 11		      .word.w	iIPCS
      0  03c9					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c9		       9e 11		      .word.w	iIPCR
      0  03cb					      dw	iIPCC	;82	   Check if any message available for task
      1  03cb		       b2 11		      .word.w	iIPCC
      0  03cd					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cd		       bf 11		      .word.w	iIPCIO
      0  03cf					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cf		       1e 0e		      .word.w	iPushMathStack
      0  03d1					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d1		       4e 0e		      .word.w	iPopMathStack
      0  03d3					      dw	iSaveMathStack	;86	   Save all math info
      1  03d3		       6b 0e		      .word.w	iSaveMathStack
      0  03d5					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d5		       8a 0e		      .word.w	iRestoreMathStack
      0  03d7					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d7		       3b 0e		      .word.w	iIncParmCount
      0  03d9					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d9		       f1 10		      .word.w	iTaskGetMathStack
      0  03db					      dw	iTaskEnable	;90	   enable a suspended task
      1  03db		       1e 10		      .word.w	iTaskEnable
      0  03dd					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03dd		       38 10		      .word.w	iTaskSuspend
      0  03df					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03df		       0b 11		      .word.w	iTaskPutMathPtr
      0  03e1					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e1		       45 0a		      .word.w	iTSTVT
      0  03e3					      dw	iSetR2	;94
      1  03e3		       36 09		      .word.w	iSetR2
      0  03e5					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e5		       e3 04		      .word.w	iStk2Tmp
      0  03e7					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e7		       f4 04		      .word.w	iTmp2Stk
      0  03e9					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e9		       d3 09		      .word.w	iTSTBYTE
      0  03eb					      dw	iINCVAR	;98	   Increment variable
      1  03eb		       17 0a		      .word.w	iINCVAR
      0  03ed					      dw	iDECVAR	;99	   Decrement variable
      1  03ed		       2f 0a		      .word.w	iDECVAR
      0  03ef					      dw	iSLICE	;100	   set the time slice for tasks
      1  03ef		       1a 11		      .word.w	iSLICE
    120  03f1
------- FILE mytb.asm
    494  03f1		       03 f1	   ILTBLend   equ	*
    495  03f1							;
    496  03f1							;=====================================================
    497  03f1							;=====================================================
    498  03f1							;=====================================================
    499  03f1							; This marks the start of the handlers for IL opcodes.
    500  03f1							;=====================================================
    501  03f1							;=====================================================
    502  03f1							;=====================================================
    503  03f1							;
    504  03f1							;
    505  03f1		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03f3		       85 47		      sta	ILSTACKPTR
    507  03f5		       85 4a		      sta	MATHSTACKPTR
    508  03f7		       85 4d		      sta	GOSUBSTACKPTR
    509  03f9		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  03fb		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  03fd							;
    512  03fd		       ad 51 27 	      lda	ProgramStart	;user prog
    513  0400		       85 4f		      sta	CURPTR
    514  0402		       8d fa 1d 	      sta	taskTable+1
    515  0405		       8d 53 27 	      sta	ProgramEnd
    516  0408		       ad 52 27 	      lda	ProgramStart+1
    517  040b		       85 50		      sta	CURPTR+1
    518  040d		       8d fb 1d 	      sta	taskTable+2
    519  0410		       8d 54 27 	      sta	ProgramEnd+1
    520  0413		       a9 80		      lda	#TASKACTIVE
    521  0415		       8d f9 1d 	      sta	taskTable	;Mark the first slot as active
    522  0418		       a9 01		      lda	#1
    523  041a		       8d f7 1e 	      sta	taskCounter	;there is always one task / Main task
    524  041d		       ad f5 1e 	      lda	taskResetValue
    525  0420		       8d f3 1e 	      sta	taskCurrentCycles	; set up the task switch counts
    526  0423		       ad f6 1e 	      lda	taskResetValue+1
    527  0426		       8d f4 1e 	      sta	taskCurrentCycles+1
    528  0429							;
    529  0429							; fall into XINIT...
    530  0429							;
    531  0429							;=====================================================
    532  0429							; This initializes for the start of the next line of
    533  0429							; BASIC text.
    534  0429							;
    535  0429		       78	   iXINIT     sei		;ensure interupts are off
    536  042a		       20 29 0f 	      jsr	taskReset	;Clear the task table
    537  042d		       8d f5 1d 	      sta	IRQPending	; reset the irq pending
    538  0430		       8d f4 1d 	      sta	IRQStatus	; Make sure irqs are off
    539  0433
    540  0433		       4c bb 02    goodExit   jmp	NextIL
    541  0436							;
    542  0436							;=====================================================
    543  0436							; This check if the escape key has been entered
    544  0436							; then changes out of run mode. z Set if esc found
    545  0436				   BreakSet
    546  0436		       20 0f f0 	      jsr	ISCHAR
    547  0439		       f0 06		      beq	BreakNo
    548  043b		       20 0a 17 	      jsr	VGETCH
    549  043e		       c9 1b		      cmp	#$1B
    550  0440		       60		      rts
    551  0441				   BreakNo
    552  0441		       a9 01		      lda	#1
    553  0443		       60		      rts
    554  0444
    555  0444							;
    556  0444
    557  0444							;=====================================================
    558  0444							; Verify there is nothing else on this input line.
    559  0444							; If there is, generate an error.
    560  0444							;
    561  0444		       a4 51	   iDONE      ldy	CUROFF
    562  0446		       20 b5 15 	      jsr	SkipSpaces
    563  0449		       b1 4f		      lda	(CURPTR),y
    564  044b		       f0 10		      beq	doneadv
    565  044d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    566  044f		       d0 05		      bne	idoneErr
    567  0451		       84 51		      sty	CUROFF
    568  0453		       4c bb 02 	      jmp	NextIL	; continue on this line
    569  0456
    570  0456				   idoneErr
    571  0456		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  0458		       a9 00		      lda	#0
    573  045a		       4c 18 06 	      jmp	iErr2
    574  045d							;
    575  045d							; Advance to the next line
    576  045d							;
    577  045d				   doneadv
    578  045d							;		 jsr	 FindNext2
    579  045d		       4c bb 02 	      jmp	NextIL
    580  0460							;
    581  0460							;=====================================================
    582  0460							; Print the string until a closing quote
    583  0460							;
    584  0460		       a4 51	   iPRS       ldy	CUROFF
    585  0462							;
    586  0462							; Odd logic here.  The main loop skipped any leading
    587  0462							; whitespace inside the quoted text, so move back to
    588  0462							; the quote, then move forward again.
    589  0462							;
    590  0462		       20 37 17 	      jsr	PrtQuoted
    591  0465		       84 51		      sty	CUROFF
    592  0467		       4c bb 02 	      jmp	NextIL
    593  046a							;
    594  046a							;=====================================================
    595  046a							; Pop the top off the stack and print it as a signed
    596  046a							; decimal number.
    597  046a							;
    598  046a		       20 05 15    iPRN       jsr	popR0
    599  046d		       20 02 0d 	      jsr	PrintDecimal
    600  0470		       4c bb 02 	      jmp	NextIL
    601  0473							;
    602  0473							;=====================================================
    603  0473							; Space to next zone.	Currently the code does not
    604  0473							; keep track of which column the output is on, so
    605  0473							; just print a tab.
    606  0473							;
    607  0473		       a9 09	   iSPC       lda	#TAB
    608  0475		       20 07 17 	      jsr	VOUTCH
    609  0478		       4c bb 02 	      jmp	NextIL
    610  047b							;
    611  047b							;=====================================================
    612  047b							; If in immediate mode, jump to the address following
    613  047b							; the NXT instruction.  Else move to the next line of
    614  047b							; user code and continue.
    615  047b							;
    616  047b		       a5 5b	   iNXT       lda	RunMode
    617  047d		       d0 03		      bne	iNxtRun	;in run mode
    618  047f							;
    619  047f							; Get address and jump to it.
    620  047f							;
    621  047f		       4c 2c 09 	      jmp	iJMP
    622  0482							;
    623  0482				   iNxtRun
    624  0482		       a4 51		      ldy	CUROFF
    625  0484		       20 b5 15 	      jsr	SkipSpaces
    626  0487		       b1 4f		      lda	(CURPTR),y
    627  0489		       c9 3a		      cmp	#COLON
    628  048b		       d0 09		      bne	iNxtRunGo
    629  048d		       c8		      iny
    630  048e		       20 b5 15 	      jsr	SkipSpaces
    631  0491		       84 51		      sty	CUROFF
    632  0493		       4c a1 04 	      jmp	iNxtRun2
    633  0496
    634  0496				   iNxtRunGo
    635  0496		       20 12 13 	      jsr	FindNextLine
    636  0499		       20 26 13 	      jsr	AtEnd
    637  049c		       d0 03		      bne	iNxtRun2	;not at end
    638  049e							;
    639  049e							; At the end of the program.  Pretend an END statement
    640  049e							; was found.
    641  049e							;
    642  049e		       4c 01 06    iFINv      jmp	iFIN
    643  04a1							;
    644  04a1		       20 84 12    iNxtRun2   jsr	getILWord	;ignore next word
    645  04a4		       4c bb 02 	      jmp	NextIL
    646  04a7							;
    647  04a7							;=====================================================
    648  04a7							; XFER takes the number on top of the stack and looks
    649  04a7							; for that line in the program, or the next line
    650  04a7							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04a7							; find the next one after that.
    652  04a7							;
    653  04a7		       20 05 15    iXFER      jsr	popR0
    654  04aa		       20 cd 12 	      jsr	findLine
    655  04ad		       20 26 13    iXFER2     jsr	AtEnd	;at end of user program?
    656  04b0		       f0 ec		      beq	iFINv
    657  04b2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    658  04b4		       84 51		      sty	CUROFF
    659  04b6		       a9 ff		      lda	#$ff
    660  04b8		       85 5b		      sta	RunMode
    661  04ba							;
    662  04ba							; Transfer IL to STMT.  I don't like having this
    663  04ba							; hard-coded; fix it.
    664  04ba							;
    665  04ba		       a9 25		      lda	#STMT&$ff
    666  04bc		       85 43		      sta	ILPC
    667  04be		       a9 19		      lda	#STMT>>8
    668  04c0		       85 44		      sta	ILPC+1
    669  04c2		       4c bb 02 	      jmp	NextIL
    670  04c5							;
    671  04c5							; Run
    672  04c5							;
    673  04c5				   iXferok
    674  04c5		       a9 ff		      lda	#$ff
    675  04c7		       85 5b		      sta	RunMode	;we're running
    676  04c9							;
    677  04c9							; Need a more elegant way to do this
    678  04c9							;
    679  04c9		       a9 25		      lda	#STMT&$ff
    680  04cb		       85 43		      sta	ILPC
    681  04cd		       a9 19		      lda	#STMT>>8
    682  04cf		       85 44		      sta	ILPC+1
    683  04d1		       4c bb 02 	      jmp	NextIL
    684  04d4							;
    685  04d4							;=====================================================
    686  04d4							; Save the pointer to the next line to the call stack.
    687  04d4							;
    688  04d4		       20 9b 14    iSAV       jsr	pushLN
    689  04d7		       b0 03		      bcs	iSAVErr
    690  04d9		       4c bb 02 	      jmp	NextIL
    691  04dc
    692  04dc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04de		       a9 00	   iSAVErr2   lda	#0
    694  04e0		       4c 18 06 	      jmp	iErr2
    695  04e3							;====================================================
    696  04e3							; Move stack top to and from temp area
    697  04e3				   iStk2Tmp
    698  04e3		       20 05 15 	      jsr	popR0
    699  04e6		       a5 52		      lda	R0
    700  04e8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04ea		       91 41		      sta	(VARIABLES),y
    702  04ec		       c8		      iny
    703  04ed		       a5 53		      lda	R0+1
    704  04ef		       91 41		      sta	(VARIABLES),y
    705  04f1		       4c bb 02 	      jmp	NextIL
    706  04f4
    707  04f4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  04f6		       b1 41		      lda	(VARIABLES),y
    709  04f8		       85 52		      sta	R0
    710  04fa		       c8		      iny
    711  04fb		       b1 41		      lda	(VARIABLES),y
    712  04fd		       85 53		      sta	R0+1
    713  04ff		       20 81 14 	      jsr	pushR0
    714  0502		       4c bb 02 	      jmp	NextIL
    715  0505							;
    716  0505							;=====================================================
    717  0505							; Pop the next line from the call stack.
    718  0505							;
    719  0505		       20 c0 14    iRET       jsr	popLN
    720  0508		       b0 d2		      bcs	iSAVErr
    721  050a		       a0 03		      ldy	#3
    722  050c		       84 51		      sty	CUROFF
    723  050e		       a9 00		      lda	#0
    724  0510		       8d f5 1d 	      sta	IRQPending
    725  0513		       58		      cli
    726  0514		       4c bb 02 	      jmp	NextIL
    727  0517							;
    728  0517							;=====================================================
    729  0517							; Return from GOSUB function
    730  0517							;
    731  0517		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    732  0519		       f0 0f		      beq	iRSTRNoValue
    733  051b		       a5 58		      lda	R2
    734  051d		       85 56		      sta	MQ
    735  051f		       88		      dey
    736  0520		       b1 4b		      lda	(GOSUBSTACK),y
    737  0522		       c9 81		      cmp	#GOSUB_RTN_VALUE
    738  0524		       d0 04		      bne	iRSTRNoValue
    739  0526		       a9 01		      lda	#1
    740  0528		       d0 02		      bne	iRSTRExit
    741  052a				   iRSTRNoValue
    742  052a		       a9 00		      lda	#0
    743  052c				   iRSTRExit
    744  052c		       85 58		      sta	R2
    745  052e		       20 c0 14 	      jsr	popLN
    746  0531		       b0 06		      bcs	iRSTRErr
    747  0533		       20 54 0e 	      jsr	PopMathStackNow
    748  0536		       4c bb 02 	      jmp	NextIL
    749  0539
    750  0539		       ad f8 1d    iRSTRErr   lda	taskPtr	; Check if this is task zero
    751  053c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    752  053e		       a5 56		      lda	MQ
    753  0540		       d0 03		      bne	taskRet
    754  0542		       20 7b 17 	      jsr	pushFalse	; the result code by default is 0
    755  0545				   taskRet
    756  0545		       4c d1 10 	      jmp	iETask	; not task zero then do a task end instead
    757  0548				   taskZeroEnd
    758  0548		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    759  054a		       d0 92		      bne	iSAVErr2
    760  054c							;
    761  054c							;=====================================================
    762  054c							; Compare items on stack.  Okay, so on input there are
    763  054c							; three things on the stack
    764  054c							;
    765  054c							;    EXPR2 <- Top of stack
    766  054c							;    OP    <- relational operator, next on stack
    767  054c							;    EXPR1 <- last item on stack
    768  054c							;
    769  054c							; Comparison is: EXPR1 <operator> EXPR2
    770  054c							;
    771  054c							; Operator is one of...
    772  054c							;
    773  054c							;    2 is =
    774  054c							;    1 is <
    775  054c							;    3 is <=
    776  054c							;    5 is <>
    777  054c							;    4 is >
    778  054c							;    6 is >=
    779  054c							;
    780  054c							; Those are bit-mapped:
    781  054c							;
    782  054c							;    xxxxxGEL
    783  054c							;
    784  054c							;    G = Greater than
    785  054c							;    E = Equal
    786  054c							;    L = Less than
    787  054c							;
    788  054c							; If the comparison is false, do a NXT, ie, move to the
    789  054c							; next line and continue.  If true, continue executing
    790  054c							; on this line.
    791  054c							;
    792  054c		       00 01	   REL_LT     equ	%001
    793  054c		       00 02	   REL_EQUAL  equ	%010
    794  054c		       00 04	   REL_GT     equ	%100
    795  054c							;
    796  054c		       20 1d 15    iCMPR      jsr	popR1
    797  054f		       20 34 15 	      jsr	popMQ	;operator in MQ
    798  0552		       20 05 15 	      jsr	popR0
    799  0555		       20 5e 05 	      jsr	iCMPRsub
    800  0558		       20 81 14 	      jsr	pushR0
    801  055b		       4c bb 02 	      jmp	NextIL
    802  055e							;
    803  055e							; See if they are equal or not
    804  055e							;
    805  055e				   iCMPRsub		; Called by internal functions
    806  055e
    807  055e		       a5 52		      lda	R0
    808  0560		       c5 54		      cmp	R1
    809  0562		       d0 0a		      bne	iCMPRnoteq	;try not equal
    810  0564		       a5 53		      lda	R0+1
    811  0566		       c5 55		      cmp	R1+1
    812  0568		       d0 04		      bne	iCMPRnoteq
    813  056a							;
    814  056a							; Equal, set the flag in MQ+1
    815  056a							;
    816  056a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    817  056c		       d0 14		      bne	iCMPcom	;Exit it is equal
    818  056e							;
    819  056e							; See if EXPR1 (R0) < EXPR2 (R1)
    820  056e							; See www.6502.org/tutorials/compare_beyond.html
    821  056e							;
    822  056e				   iCMPRnoteq
    823  056e		       a5 52		      lda	R0
    824  0570		       c5 54		      cmp	R1
    825  0572		       a5 53		      lda	R0+1
    826  0574		       e5 55		      sbc	R1+1
    827  0576		       50 02		      bvc	iCMPR_2
    828  0578		       49 80		      eor	#$80
    829  057a		       30 04	   iCMPR_2    bmi	iCMPlt
    830  057c		       a9 04		      lda	#REL_GT
    831  057e		       d0 02		      bne	iCMPcom
    832  0580		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    833  0582
    834  0582		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    835  0584							;
    836  0584							; Now compare the end result with what the caller
    837  0584							; was looking for.
    838  0584							;
    839  0584		       25 56		      and	MQ
    840  0586		       f0 0c		      beq	iCMPno	; no match
    841  0588		       a9 ff		      lda	#$FF	; true is $ffff
    842  058a		       85 52		      sta	R0
    843  058c		       85 53		      sta	R0+1
    844  058e		       d0 0c		      bne	iCMPDone
    845  0590							;
    846  0590							; R0 > R1
    847  0590							;
    848  0590		       a9 04	   iCMPgt     lda	#REL_GT
    849  0592		       d0 ee		      bne	iCMPcom
    850  0594				   iCMPno
    851  0594		       a9 00		      lda	#0
    852  0596		       85 52		      sta	R0
    853  0598		       a9 00		      lda	#0
    854  059a		       85 53		      sta	R0+1
    855  059c
    856  059c				   iCMPDone
    857  059c		       60		      rts
    858  059d
    859  059d							;
    860  059d							; if Not a match, so jump to the next line of code.
    861  059d							; Branches based upon value on top of the stack
    862  059d				   iBranch
    863  059d		       20 05 15 	      jsr	popR0
    864  05a0		       a5 52		      lda	R0
    865  05a2		       05 53		      ora	R0+1
    866  05a4		       f0 03		      beq	iBranchFalse	; not true
    867  05a6		       4c bb 02 	      jmp	NextIL	; It is true if any value not zero
    868  05a9							;
    869  05a9				   iBranchFalse
    870  05a9		       20 12 13 	      jsr	FindNextLine
    871  05ac		       4c ad 04 	      jmp	iXFER2
    872  05af							;
    873  05af							;=====================================================
    874  05af							; Start a read of data in background
    875  05af				   iReadStart
    876  05af		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05b1		       a6 01		      ldx	1	; Indicate to start read in background
    878  05b3		       20 9e 13 	      jsr	GetLine	; Call the getline to start read
    879  05b6		       4c bb 02 	      jmp	NextIL	; next instruction
    880  05b9							;
    881  05b9							;=====================================================
    882  05b9							; Complete the read and return the curptr, curoff pointing to data
    883  05b9				   iReadComplete
    884  05b9		       20 9b 14 	      jsr	pushLN
    885  05bc		       90 03		      bcc	iReadOk
    886  05be		       4c 5e 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    887  05c1				   iReadOk
    888  05c1		       20 be 13 	      jsr	ReadComplete
    889  05c4		       4c bb 02 	      jmp	NextIL
    890  05c7		       20 c0 14 	      jsr	popLN
    891  05ca		       4c bb 02 	      jmp	NextIL
    892  05cd							;=====================================================
    893  05cd							; Get a line of text from the user, convert to a
    894  05cd							; number, leave on top of stack.
    895  05cd							;
    896  05cd				   iINNUM
    897  05cd		       20 9b 14 	      jsr	pushLN
    898  05d0		       b0 ec		      bcs	iReadErr	; Stack over flow error
    899  05d2							;
    900  05d2		       a9 3f		      lda	#'?
    901  05d4		       a2 00		      ldx	#0	;Wait for complete
    902  05d6		       20 9e 13 	      jsr	GetLine
    903  05d9		       20 33 13 	      jsr	getDecimal
    904  05dc		       20 81 14 	      jsr	pushR0	;put onto stack
    905  05df		       b0 dd		      bcs	iReadErr	;StackOverflow error
    906  05e1							;
    907  05e1		       4c fb 05 	      jmp	ExitIn
    908  05e4							;
    909  05e4							;=====================================================
    910  05e4							; Get a line of text from the user, convert to a
    911  05e4							; character value , leave on top of stack. up to 2 characters
    912  05e4							;
    913  05e4				   iINSTR
    914  05e4		       20 9b 14 	      jsr	pushLN
    915  05e7		       b0 d5		      bcs	iReadErr	; Stack overflow error
    916  05e9		       a9 3f		      lda	#'?
    917  05eb		       a2 00		      ldx	#0	;wait for read complete
    918  05ed		       20 9e 13 	      jsr	GetLine
    919  05f0		       b1 4f		      lda	(CURPTR),y
    920  05f2		       85 52		      sta	R0
    921  05f4		       a9 00		      lda	#0
    922  05f6		       85 53		      sta	R0+1
    923  05f8		       20 81 14 	      jsr	pushR0	;put onto stack
    924  05fb				   ExitIn
    925  05fb		       20 c0 14 	      jsr	popLN
    926  05fe		       4c bb 02 	      jmp	NextIL
    927  0601							;
    928  0601							;
    929  0601							;=====================================================
    930  0601							; Stop the currently running program.	Actually very
    931  0601							; simple to do... clear the RunMode flag, then set the
    932  0601							; ILPC to the standard handler and continue running.
    933  0601							;
    934  0601		       a9 00	   iFIN       lda	#0
    935  0603		       85 5b		      sta	RunMode
    936  0605		       20 29 0f 	      jsr	taskReset
    937  0608							;
    938  0608		       ad 3e 27 	      lda	errGoto
    939  060b		       85 43		      sta	ILPC
    940  060d		       ad 3f 27 	      lda	errGoto+1
    941  0610		       85 44		      sta	ILPC+1
    942  0612		       4c bb 02 	      jmp	NextIL
    943  0615							;
    944  0615							;=====================================================
    945  0615							; Handle the ERR opcode.  Following the instruction is
    946  0615							; a 16 bit error number.  Print an error message, and
    947  0615							; if we're in run mode, print the line number.  Stop
    948  0615							; program execution and return to the initial state.
    949  0615							;
    950  0615		       20 84 12    iERR       jsr	getILWord	;get err code
    951  0618							;
    952  0618							; Enter here with the error code in X (LSB) and A (MSB).
    953  0618							;
    954  0618		       86 52	   iErr2      stx	R0
    955  061a		       85 53		      sta	R0+1
    956  061c							;
    957  061c		       20 0d 17 	      jsr	puts
      0  061f					      db	CR,LF,"Error ",0
      1  061f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    959  0628		       20 02 0d 	      jsr	PrintDecimal
    960  062b							;
    961  062b		       a5 5b		      lda	RunMode	;running?
    962  062d		       f0 3b		      beq	iERR3	;nope
    963  062f		       20 0d 17 	      jsr	puts
      0  0632					      db	" at line ",0
      1  0632		       20 61 74 20*	      .byte.b	" at line ",0
    965  063c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    966  063e				   iErr2a
    967  063e		       b1 4f		      lda	(CURPTR),y
    968  0640		       85 52		      sta	R0
    969  0642		       c8		      iny
    970  0643		       b1 4f		      lda	(CURPTR),y
    971  0645		       85 53		      sta	R0+1
    972  0647		       20 02 0d 	      jsr	PrintDecimal
    973  064a		       20 0d 17 	      jsr	puts
      0  064d					      db	":",0
      1  064d		       3a 00		      .byte.b	":",0
    975  064f		       a9 00		      lda	#0
    976  0651		       85 53		      sta	R0+1
    977  0653		       a5 51		      lda	CUROFF
    978  0655		       18		      clc
    979  0656		       e9 03		      sbc	#3
    980  0658		       85 52		      sta	R0
    981  065a		       20 02 0d 	      jsr	PrintDecimal
    982  065d		       20 0d 17 	      jsr	puts
      0  0660					      db	":",0
      1  0660		       3a 00		      .byte.b	":",0
    984  0662		       ad f8 1d 	      lda	taskPtr
    985  0665		       85 52		      sta	R0
    986  0667		       20 02 0d 	      jsr	PrintDecimal
    987  066a							;
    988  066a		       20 be 15    iERR3      jsr	CRLF
    989  066d		       20 21 0f 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    990  0670		       a9 00		      lda	#0
    991  0672		       85 5b		      sta	RunMode	;fall through...
    992  0674							;
    993  0674							;=====================================================
    994  0674							; Reset the IL to be back at the idle loop.  Does not
    995  0674							; clear variables so the user can see what state
    996  0674							; the program is in.
    997  0674							;
    998  0674		       a9 00	   ResetIL    lda	#0
    999  0676		       85 47		      sta	ILSTACKPTR
   1000  0678		       ad 3e 27 	      lda	errGoto
   1001  067b		       85 43		      sta	ILPC
   1002  067d		       ad 3f 27 	      lda	errGoto+1
   1003  0680		       85 44		      sta	ILPC+1
   1004  0682		       4c bb 02 	      jmp	NextIL
   1005  0685
   1006  0685							;
   1007  0685							;=====================================================
   1008  0685							; Pop two items off stack, add them, then place the
   1009  0685							; result back onto the stack.
   1010  0685							;
   1011  0685		       20 05 15    iADD       jsr	popR0
   1012  0688		       20 1d 15 	      jsr	popR1
   1013  068b				   iADDfast
   1014  068b		       18		      clc
   1015  068c		       a5 52		      lda	R0
   1016  068e		       65 54		      adc	R1
   1017  0690		       85 52		      sta	R0
   1018  0692		       a5 53		      lda	R0+1
   1019  0694		       65 55		      adc	R1+1
   1020  0696		       85 53		      sta	R0+1
   1021  0698		       4c 03 07 	      jmp	pushR0nextIl
   1022  069b							;
   1023  069b							;=====================================================
   1024  069b							; Pop two items off the stack.  Subtract the top of
   1025  069b							; stack from the lower entry.
   1026  069b							;
   1027  069b		       20 1d 15    iSUB       jsr	popR1
   1028  069e		       20 05 15 	      jsr	popR0
   1029  06a1		       38		      sec
   1030  06a2		       a5 52		      lda	R0
   1031  06a4		       e5 54		      sbc	R1
   1032  06a6		       85 52		      sta	R0
   1033  06a8		       a5 53		      lda	R0+1
   1034  06aa		       e5 55		      sbc	R1+1
   1035  06ac		       85 53		      sta	R0+1
   1036  06ae		       4c 03 07 	      jmp	pushR0nextIl
   1037  06b1							;
   1038  06b1							;=====================================================
   1039  06b1							; Negate the top of stack.
   1040  06b1							;
   1041  06b1		       20 05 15    iNEG       jsr	popR0
   1042  06b4		       a5 52		      lda	R0
   1043  06b6		       49 ff		      eor	#$ff
   1044  06b8		       85 52		      sta	R0
   1045  06ba		       a5 53		      lda	R0+1
   1046  06bc		       49 ff		      eor	#$ff
   1047  06be		       85 53		      sta	R0+1
   1048  06c0		       e6 52		      inc	R0
   1049  06c2		       d0 02		      bne	iNEG2
   1050  06c4		       e6 53		      inc	R0+1
   1051  06c6		       4c 03 07    iNEG2      jmp	pushR0nextIl
   1052  06c9							;
   1053  06c9							;=====================================================
   1054  06c9							; Multiply top two items on the stack, put the results
   1055  06c9							; on top.  This uses the algorithm documented on page
   1056  06c9							; 115 of "Microprocessor Programming for Computer
   1057  06c9							; Hobbyists" by Neill Graham.
   1058  06c9							;
   1059  06c9		       20 cf 06    iMUL       jsr	iMultiply
   1060  06cc		       4c bb 02 	      jmp	NextIL
   1061  06cf
   1062  06cf				   iMultiply
   1063  06cf		       20 05 15 	      jsr	popR0	;AC
   1064  06d2		       20 1d 15 	      jsr	popR1	;OP
   1065  06d5							;
   1066  06d5		       a5 52		      lda	R0
   1067  06d7		       85 56		      sta	MQ
   1068  06d9		       a5 53		      lda	R0+1
   1069  06db		       85 57		      sta	MQ+1
   1070  06dd		       a9 00		      lda	#0	;clear result
   1071  06df		       85 52		      sta	R0
   1072  06e1		       85 53		      sta	R0+1
   1073  06e3							;
   1074  06e3		       a2 10		      ldx	#16	;number of bits in value
   1075  06e5		       06 52	   multloop   asl	R0
   1076  06e7		       26 53		      rol	R0+1
   1077  06e9		       06 56		      asl	MQ
   1078  06eb		       26 57		      rol	MQ+1
   1079  06ed		       90 0d		      bcc	multno	;skip add if no carry
   1080  06ef							;
   1081  06ef							; Add R1 back into R0
   1082  06ef							;
   1083  06ef		       18		      clc
   1084  06f0		       a5 52		      lda	R0
   1085  06f2		       65 54		      adc	R1
   1086  06f4		       85 52		      sta	R0
   1087  06f6		       a5 53		      lda	R0+1
   1088  06f8		       65 55		      adc	R1+1
   1089  06fa		       85 53		      sta	R0+1
   1090  06fc							;
   1091  06fc		       ca	   multno     dex		;did all bits yet?
   1092  06fd		       d0 e6		      bne	multloop
   1093  06ff		       20 81 14 	      jsr	pushR0	;OP
   1094  0702		       60		      rts
   1095  0703							;
   1096  0703				   pushR0nextIl
   1097  0703		       20 81 14 	      jsr	pushR0	;OP
   1098  0706		       4c bb 02 	      jmp	NextIL
   1099  0709							;
   1100  0709							;=====================================================
   1101  0709							; Divide the top of stack into the next to top item.
   1102  0709							; Leave results on stack.  Taken from:
   1103  0709							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1104  0709							;
   1105  0709							; R0 = R0 / R1
   1106  0709							; Remainder is in MQ
   1107  0709							;
   1108  0709		       20 23 07    iDIV       jsr	iDoDiv
   1109  070c		       20 86 15 	      jsr	RestoreSigns
   1110  070f		       4c 03 07 	      jmp	pushR0nextIl
   1111  0712
   1112  0712		       20 23 07    iMOD       jsr	iDoDiv
   1113  0715		       20 86 15 	      jsr	RestoreSigns
   1114  0718		       a5 56		      lda	MQ
   1115  071a		       85 52		      sta	R0
   1116  071c		       a5 57		      lda	MQ+1
   1117  071e		       85 53		      sta	R0+1
   1118  0720		       4c 03 07 	      jmp	pushR0nextIl
   1119  0723
   1120  0723				   iDoDiv
   1121  0723		       20 1d 15 	      jsr	popR1
   1122  0726		       20 05 15 	      jsr	popR0
   1123  0729							;
   1124  0729							; Check for divide by zero
   1125  0729							;
   1126  0729
   1127  0729				   iDivNoPop
   1128  0729		       a5 54		      lda	R1
   1129  072b		       05 55		      ora	R1+1
   1130  072d		       f0 29		      beq	divby0
   1131  072f							;
   1132  072f		       20 4b 15 	      jsr	SaveSigns
   1133  0732		       a9 00		      lda	#0	;preset remainder to 0
   1134  0734		       85 56		      sta	MQ
   1135  0736		       85 57		      sta	MQ+1
   1136  0738		       a2 10		      ldx	#16	;repeat for each bit: ...
   1137  073a				   divloop
   1138  073a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1139  073c		       26 53		      rol	R0+1
   1140  073e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1141  0740		       26 57		      rol	MQ+1
   1142  0742		       a5 56		      lda	MQ
   1143  0744		       38		      sec
   1144  0745		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1145  0747		       a8		      tay		;lb result -> Y, for we may need it later
   1146  0748		       a5 57		      lda	MQ+1
   1147  074a		       e5 55		      sbc	R1+1
   1148  074c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1149  074e
   1150  074e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1151  0750		       84 56		      sty	MQ
   1152  0752		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1153  0754
   1154  0754		       ca	   skip       dex
   1155  0755		       d0 e3		      bne	divloop
   1156  0757		       60		      rts
   1157  0758							;
   1158  0758							; Indicate divide-by-zero error
   1159  0758							;
   1160  0758		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1161  075a		       a9 00		      lda	#0
   1162  075c		       4c 18 06 	      jmp	iErr2
   1163  075f							;
   1164  075f							;=====================================================
   1165  075f							; This pops the top two items off the stack.  The top
   1166  075f							; item is a data value and the other is an ABSOLUTE address.
   1167  075f							;Save the value into that address.
   1168  075f							;
   1169  075f		       98	   iSTORE     tya
   1170  0760		       48		      pha
   1171  0761		       20 05 15 	      jsr	popR0	;data
   1172  0764		       20 1d 15 	      jsr	popR1	;Storage location
   1173  0767		       a0 00		      ldy	#0
   1174  0769		       a5 52		      lda	R0
   1175  076b		       91 54		      sta	(R1),y
   1176  076d		       a5 53		      lda	R0+1
   1177  076f		       c8		      iny
   1178  0770		       91 54		      sta	(R1),y
   1179  0772		       68		      pla
   1180  0773		       a8		      tay
   1181  0774		       4c bb 02 	      jmp	NextIL
   1182  0777							;
   1183  0777							;=====================================================
   1184  0777							; Replaces the top of stack with the variable whose
   1185  0777							; absolute address it represents.
   1186  0777							;
   1187  0777		       98	   iIND       tya
   1188  0778		       48		      pha
   1189  0779		       20 1d 15 	      jsr	popR1
   1190  077c		       a0 00		      ldy	#0
   1191  077e		       b1 54		      lda	(R1),y
   1192  0780		       85 52		      sta	R0
   1193  0782		       c8		      iny
   1194  0783		       b1 54		      lda	(R1),y
   1195  0785		       85 53		      sta	R0+1
   1196  0787		       68		      pla
   1197  0788		       a8		      tay
   1198  0789		       4c 03 07 	      jmp	pushR0nextIl
   1199  078c							;
   1200  078c							;=====================================================
   1201  078c							; Get the array index from top of stack get Current variable
   1202  078c							; address from next on stack, add the offset
   1203  078c							; push the result back onto the stack
   1204  078c				   iArray
   1205  078c		       20 05 15 	      jsr	popR0	; Get the array index
   1206  078f		       20 1d 15 	      jsr	popR1	; Get the Variable address
   1207  0792
   1208  0792		       18		      clc		; Multiplythe value by 2
   1209  0793		       26 52		      rol	R0	; Do the multiply
   1210  0795		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1211  0797		       18		      clc
   1212  0798		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1213  079a		       65 52		      adc	R0
   1214  079c		       85 52		      sta	R0
   1215  079e		       a5 55		      lda	R1+1
   1216  07a0		       65 53		      adc	R0+1
   1217  07a2		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1218  07a4		       20 81 14 	      jsr	pushR0	; Push R0 assume it is correct
   1219  07a7
   1220  07a7		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1221  07a9		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1222  07ab		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1223  07ad		       a5 55		      lda	R1+1
   1224  07af		       c5 42		      cmp	VARIABLES+1
   1225  07b1		       d0 1c		      bne	iArrayAtTest
   1226  07b3		       18		      clc
   1227  07b4		       a9 34		      lda	#52	; add the max offset that is valid
   1228  07b6		       65 54		      adc	R1	; update to be the largest offset that is valid
   1229  07b8		       85 54		      sta	R1
   1230  07ba		       a9 00		      lda	#0
   1231  07bc		       65 55		      adc	R1+1
   1232  07be		       85 55		      sta	R1+1
   1233  07c0				   iArrayVerify 		; try to enforce some sanity to using arrays
   1234  07c0		       a5 53		      lda	R0+1
   1235  07c2		       c5 55		      cmp	R1+1
   1236  07c4		       d0 04		      bne	iArrayDecide
   1237  07c6		       a5 52		      lda	R0
   1238  07c8		       c5 54		      cmp	R1
   1239  07ca				   iArrayDecide
   1240  07ca		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1241  07cc		       4c bb 02 	      jmp	NextIL
   1242  07cf
   1243  07cf				   iArrayAtTest
   1244  07cf		       ad 55 27 	      lda	HighMem
   1245  07d2		       85 54		      sta	R1
   1246  07d4		       ad 56 27 	      lda	HighMem+1
   1247  07d7		       85 55		      sta	R1+1
   1248  07d9		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1249  07db
   1250  07db							; Get here if array index is out of range
   1251  07db		       20 05 15    iArrayError jsr	popR0
   1252  07de		       a9 00		      lda	#0
   1253  07e0		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1254  07e2		       4c 18 06 	      jmp	iErr2
   1255  07e5							;
   1256  07e5							;=====================================================
   1257  07e5							; List the current BASIC program in memory.  Uses R0,
   1258  07e5							; tempIly, and dpl.
   1259  07e5							;
   1260  07e5		       20 ed 16    iLST       jsr	SetOutConsole
   1261  07e8		       ad 51 27    iLST2      lda	ProgramStart
   1262  07eb		       85 59		      sta	dpl
   1263  07ed		       ad 52 27 	      lda	ProgramStart+1
   1264  07f0		       85 5a		      sta	dpl+1
   1265  07f2							;
   1266  07f2							; dpl/dph point to the current line.  See if we're at
   1267  07f2							; the end of the program.
   1268  07f2							;
   1269  07f2		       a5 59	   iLSTloop   lda	dpl
   1270  07f4		       cd 53 27 	      cmp	ProgramEnd
   1271  07f7		       d0 07		      bne	iLstNotEnd
   1272  07f9		       a5 5a		      lda	dpl+1
   1273  07fb		       cd 54 27 	      cmp	ProgramEnd+1
   1274  07fe		       f0 44		      beq	iLstdone
   1275  0800							;
   1276  0800		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1277  0802		       b1 59		      lda	(dpl),y	;line number LSB
   1278  0804		       85 52		      sta	R0
   1279  0806		       c8		      iny
   1280  0807		       b1 59		      lda	(dpl),y	;line number MSB
   1281  0809		       85 53		      sta	R0+1
   1282  080b		       c8		      iny
   1283  080c		       8c 4c 27 	      sty	tempIlY
   1284  080f		       20 02 0d 	      jsr	PrintDecimal
   1285  0812		       a9 20		      lda	#SPACE
   1286  0814		       20 07 17 	      jsr	VOUTCH
   1287  0817		       ac 4c 27 	      ldy	tempIlY
   1288  081a		       b1 59	   iLSTl2     lda	(dpl),y
   1289  081c		       f0 0c		      beq	iLST3	;end of this line 0 value
   1290  081e		       8c 4c 27 	      sty	tempIlY
   1291  0821		       20 07 17 	      jsr	VOUTCH
   1292  0824		       ac 4c 27 	      ldy	tempIlY
   1293  0827		       c8		      iny
   1294  0828		       d0 f0		      bne	iLSTl2	;do next char
   1295  082a							;
   1296  082a							; End of this line.  Print CR/LF, then move to the
   1297  082a							; next line.
   1298  082a							;
   1299  082a		       c8	   iLST3      iny		;Move to next line
   1300  082b		       18		      clc		;Clear the carry flag
   1301  082c		       98		      tya		;Current Offset
   1302  082d		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  082f		       85 59		      sta	dpl	;Save the new value
   1304  0831		       a5 5a		      lda	dpl+1	;Next byte
   1305  0833		       69 00		      adc	#0	;ad in the carry if any
   1306  0835		       85 5a		      sta	dpl+1	;Save it
   1307  0837							;
   1308  0837							; Have to manually do CR/LF so it uses the vectored
   1309  0837							; output function.
   1310  0837							;
   1311  0837		       a9 0d		      lda	#CR
   1312  0839		       20 07 17 	      jsr	VOUTCH
   1313  083c		       a9 0a		      lda	#LF
   1314  083e		       20 07 17 	      jsr	VOUTCH
   1315  0841		       4c f2 07 	      jmp	iLSTloop	;do next line
   1316  0844							;
   1317  0844		       20 ed 16    iLstdone   jsr	SetOutConsole
   1318  0847		       4c bb 02 	      jmp	NextIL
   1319  084a							;
   1320  084a							;=====================================================
   1321  084a							; Get a line of text into LINBUF.  Terminate with a
   1322  084a							; null byte.
   1323  084a							;
   1324  084a				   iGETLINE
   1325  084a		       a9 3e		      lda	#'>	;prompt character
   1326  084c		       a6 00		      ldx	0	;Wait for read to complete
   1327  084e		       20 9e 13 	      jsr	GetLine
   1328  0851							;
   1329  0851		       a9 00		      lda	#0
   1330  0853		       85 5b		      sta	RunMode
   1331  0855		       85 51		      sta	CUROFF
   1332  0857		       4c bb 02 	      jmp	NextIL
   1333  085a							;
   1334  085a							;=====================================================
   1335  085a							; This is called when the input buffer contains a line
   1336  085a							; typed in by the user that starts with a line number.
   1337  085a							; Insert the line into the program or delete the line
   1338  085a							; if there is nothing after the line number,
   1339  085a							;
   1340  085a		       a0 00	   iINSRT     ldy	#0
   1341  085c		       20 33 13 	      jsr	getDecimal	;convert line #
   1342  085f		       20 b5 15 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1343  0862		       8c 4d 27 	      sty	offset	;Save the start of the program line text
   1344  0865							;
   1345  0865							; Now find the line OR the next higher line OR the
   1346  0865							; end of the program.
   1347  0865							;
   1348  0865		       20 cd 12 	      jsr	findLine	; Look for the line number in the current program
   1349  0868							; Returns Z and curptr point to the line if found
   1350  0868							; Returns C and curptr at next higher line if not found and there is a higher line
   1351  0868							; Returns ZC clear and curptr to end of program if higher than all other lines
   1352  0868							;
   1353  0868							; If the line exists, it needs to be removed.
   1354  0868							;
   1355  0868		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1356  086a							;
   1357  086a							; Get length of line to be removed, we fall thru to here if we find a matching line
   1358  086a							;
   1359  086a							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1360  086a		       a0 00		      ldy	#0
   1361  086c		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1362  086e		       a8		      tay
   1363  086f							;If it is equal we delete the line and replace it, get length
   1364  086f							;then adjust all program line after up or down depending on len of line
   1365  086f							;If next higher then just move everythimg down by length bytes
   1366  086f							;This call will return how many bytes in the line we found
   1367  086f		       8c 4e 27 	      sty	lineLength	;Save the length of the line we found
   1368  0872							;
   1369  0872							; Compute the new end of the program first.
   1370  0872							;
   1371  0872		       38		      sec		;Set the carry bit
   1372  0873		       ad 53 27 	      lda	ProgramEnd	;Get low byte of program end
   1373  0876		       ed 4e 27 	      sbc	lineLength	;Subtract the length of the current line
   1374  0879		       8d 53 27 	      sta	ProgramEnd	;save it
   1375  087c		       ad 54 27 	      lda	ProgramEnd+1
   1376  087f		       e9 00		      sbc	#0	;Process the carry
   1377  0881		       8d 54 27 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1378  0884							;
   1379  0884							; Copy CURPTR into R1 for working
   1380  0884							;
   1381  0884		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1382  0886		       85 54		      sta	R1
   1383  0888		       a5 50		      lda	CURPTR+1
   1384  088a		       85 55		      sta	R1+1
   1385  088c							;
   1386  088c							; See if we're at the end.
   1387  088c							;
   1388  088c		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1389  088e		       cd 53 27 	      cmp	ProgramEnd
   1390  0891		       d0 07		      bne	InsDelLoop
   1391  0893		       a5 55		      lda	R1+1
   1392  0895		       cd 54 27 	      cmp	ProgramEnd+1
   1393  0898		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1394  089a							;
   1395  089a							; Move one byte, move to next location.
   1396  089a							;
   1397  089a		       ac 4e 27    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1398  089d		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1399  089f		       b1 54		      lda	(R1),y
   1400  08a1		       a0 00		      ldy	#0
   1401  08a3		       91 54		      sta	(R1),y
   1402  08a5		       e6 54		      inc	R1
   1403  08a7		       d0 e3		      bne	InsDelChk
   1404  08a9		       e6 55		      inc	R1+1
   1405  08ab		       4c 8c 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1406  08ae							;
   1407  08ae							; Deletion is done.
   1408  08ae							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1409  08ae							;
   1410  08ae		       ac 4d 27    insert2    ldy	offset	; get back ptr  Get the current offset
   1411  08b1		       b9 b4 26 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1412  08b4		       f0 5f		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1413  08b6							;
   1414  08b6							; CURPTR points to where the line will be inserted.
   1415  08b6							;
   1416  08b6		       20 58 14 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1417  08b9							;
   1418  08b9		       ad 53 27 	      lda	ProgramEnd	;Load the start address for the copy
   1419  08bc							;At this point curptr still contains the location we will insert data
   1420  08bc		       85 5c		      sta	FROM
   1421  08be		       ad 54 27 	      lda	ProgramEnd+1
   1422  08c1		       85 5d		      sta	FROM+1
   1423  08c3							;
   1424  08c3		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1425  08c5		       b1 5c		      lda	(FROM),y
   1426  08c7		       ac 4e 27 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1427  08ca		       91 5c		      sta	(FROM),y	;Save the new byte
   1428  08cc							;
   1429  08cc		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1430  08ce		       c5 4f		      cmp	CURPTR
   1431  08d0		       d0 06		      bne	mvUpMore
   1432  08d2		       a5 5d		      lda	FROM+1
   1433  08d4		       c5 50		      cmp	CURPTR+1
   1434  08d6		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1435  08d8							;
   1436  08d8							; Not done yet
   1437  08d8							;
   1438  08d8		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1439  08da		       d0 02		      bne	mvUpMore2
   1440  08dc		       c6 5d		      dec	FROM+1
   1441  08de		       c6 5c	   mvUpMore2  dec	FROM
   1442  08e0		       4c c3 08 	      jmp	mvup1	;Loop until everything is moved
   1443  08e3							;
   1444  08e3							; All done with copy.
   1445  08e3							;
   1446  08e3				   mvUpDone
   1447  08e3		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1448  08e4		       ad 4e 27 	      lda	lineLength	;Number of bytes to copy from line buff
   1449  08e7		       6d 53 27 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1450  08ea		       8d 53 27 	      sta	ProgramEnd
   1451  08ed		       ad 54 27 	      lda	ProgramEnd+1
   1452  08f0		       69 00		      adc	#0
   1453  08f2		       8d 54 27 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1454  08f5							;
   1455  08f5							;===================jlit use length before line newline
   1456  08f5
   1457  08f5		       a0 00		      ldy	#0	;Set offset of copy
   1458  08f7		       ad 4e 27 	      lda	lineLength	;We will insert the actual length of the line first
   1459  08fa		       91 4f		      sta	(CURPTR),y	;Store the length
   1460  08fc		       c8		      iny
   1461  08fd		       a5 52		      lda	R0	;Store the line number next
   1462  08ff		       91 4f		      sta	(CURPTR),y
   1463  0901		       c8		      iny
   1464  0902		       a5 53		      lda	R0+1
   1465  0904		       91 4f		      sta	(CURPTR),y
   1466  0906		       c8		      iny
   1467  0907							;
   1468  0907		       ae 4d 27 	      ldx	offset	;Load the offset into line buffer in page zero
   1469  090a		       bd b4 26    mvUpLoop2  lda	LINBUF,x	;get a byte
   1470  090d		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1471  090f		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1472  0911		       e8		      inx
   1473  0912		       c8		      iny
   1474  0913		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1475  0915							;
   1476  0915		       4c bb 02    mvUpFini   jmp	NextIL
   1477  0918							;
   1478  0918							;=====================================================
   1479  0918							; Pops the top value of the ILPC stack and stores it
   1480  0918							; in ILPC.  Ie, return from an IL subroutine.
   1481  0918							;
   1482  0918		       20 bb 12    iRTN       jsr	popILPC
   1483  091b		       4c bb 02 	      jmp	NextIL
   1484  091e							;
   1485  091e							;=====================================================
   1486  091e							; NLINE print a newline
   1487  091e							;
   1488  091e		       20 be 15    iNLINE     jsr	CRLF	;user supplied sub
   1489  0921		       4c bb 02 	      jmp	NextIL
   1490  0924							;
   1491  0924							;=====================================================
   1492  0924							; This saves the current ILPC value on the stack, then
   1493  0924							; jumps to the address specified by the next two bytes.
   1494  0924							;
   1495  0924		       20 9e 12    iCALL      jsr	pushILPC	;save ILPC
   1496  0927		       90 03		      bcc	iJMP
   1497  0929		       4c 5e 0b 	      jmp	ErrStkOver	; Check if there was an error
   1498  092c							;
   1499  092c							; Jmp to a specific location in the IL code.  The new
   1500  092c							; address immediately follows the opcode.
   1501  092c							;
   1502  092c		       20 84 12    iJMP       jsr	getILWord
   1503  092f		       86 43		      stx	ILPC
   1504  0931		       85 44		      sta	ILPC+1
   1505  0933		       4c bb 02 	      jmp	NextIL
   1506  0936
   1507  0936
   1508  0936							;
   1509  0936							;=====================================================
   1510  0936							; Push the next two bytes onto the arithmetic stack.
   1511  0936							;
   1512  0936		       20 88 12    iSetR2     jsr	getILByte
   1513  0939		       85 58		      sta	R2
   1514  093b		       4c bb 02 	      jmp	NextIL
   1515  093e							;
   1516  093e							;=====================================================
   1517  093e							; Push the next two bytes onto the arithmetic stack.
   1518  093e							;
   1519  093e		       20 84 12    iLIT       jsr	getILWord
   1520  0941		       86 52		      stx	R0
   1521  0943		       85 53		      sta	R0+1
   1522  0945		       20 81 14 	      jsr	pushR0
   1523  0948		       4c bb 02 	      jmp	NextIL
   1524  094b							;
   1525  094b							;=====================================================
   1526  094b							; Initialize all variables for a single task.	Ie, set to zero.
   1527  094b							;
   1528  094b		       98	   subVINIT   tya
   1529  094c		       48		      pha
   1530  094d
   1531  094d		       a9 00		      lda	#0
   1532  094f		       a0 00		      ldy	#0
   1533  0951		       91 41	   Vinit2     sta	(VARIABLES),y
   1534  0953		       c8		      iny
   1535  0954		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1536  0956		       90 f9		      bcc	Vinit2
   1537  0958
   1538  0958		       68		      pla
   1539  0959		       a8		      tay
   1540  095a		       60		      rts
   1541  095b
   1542  095b		       20 4b 09    iVINIT     jsr	subVINIT
   1543  095e		       4c bb 02 	      jmp	NextIL
   1544  0961							;
   1545  0961							;=====================================================
   1546  0961							; Set the address of the error handler.  After any
   1547  0961							; error, set to the ILPC to the specified location.
   1548  0961							;
   1549  0961		       20 84 12    iERRGOTO   jsr	getILWord
   1550  0964		       8e 3e 27 	      stx	errGoto
   1551  0967		       8d 3f 27 	      sta	errGoto+1
   1552  096a		       4c bb 02 	      jmp	NextIL
   1553  096d							;
   1554  096d							;=====================================================
   1555  096d							; TST is followed by an 8 bit signed offset, then a
   1556  096d							; null terminated string.  Compare the string against
   1557  096d							; the string starting at (CURPTR),CUROFF.  If the
   1558  096d							; strings match, continue executing the next IL
   1559  096d							; opcode.  Else, add the offset to ILPC.
   1560  096d							;
   1561  096d		       20 88 12    iTST       jsr	getILByte	;Get the relative jump address
   1562  0970		       8d 4d 27 	      sta	offset	;save it to use if test faile
   1563  0973		       20 6b 14 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1564  0976
   1565  0976		       a4 51		      ldy	CUROFF
   1566  0978		       84 59		      sty	dpl	;save for later
   1567  097a							;
   1568  097a		       20 88 12    iTSTloop   jsr	getILByte	;get next char
   1569  097d		       f0 11		      beq	iTSTm	;match!
   1570  097f		       a4 59		      ldy	dpl
   1571  0981		       d1 4f		      cmp	(CURPTR),y
   1572  0983		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1573  0985		       09 20		      ora	#$20	; lets allow lowercase as well
   1574  0987		       d1 4f		      cmp	(CURPTR),y
   1575  0989		       d0 23		      bne	iTSTfail	;mismatch
   1576  098b		       c8	   iTSTUpper  iny
   1577  098c		       84 59		      sty	dpl
   1578  098e		       d0 ea		      bne	iTSTloop
   1579  0990							;
   1580  0990							; It's a match!  Clean up a bit.
   1581  0990							;
   1582  0990		       a4 59	   iTSTm      ldy	dpl
   1583  0992		       84 51		      sty	CUROFF
   1584  0994		       4c bb 02 	      jmp	NextIL
   1585  0997
   1586  0997							; Test for a single quote string
   1587  0997		       20 88 12    iTSTStr    jsr	getILByte
   1588  099a		       8d 4d 27 	      sta	offset
   1589  099d		       20 6b 14 	      jsr	saveIL
   1590  09a0		       a4 51		      ldy	CUROFF
   1591  09a2		       a9 22		      lda	#'"
   1592  09a4		       d1 4f		      cmp	(CURPTR),y
   1593  09a6		       d0 06		      bne	iTSTfail
   1594  09a8		       c8		      iny
   1595  09a9		       84 51		      sty	CUROFF
   1596  09ab		       4c de 02 	      jmp	NextILStr
   1597  09ae							;
   1598  09ae							; Not a match, reset ILPC and then move to the
   1599  09ae							; offset.
   1600  09ae							;
   1601  09ae		       20 76 14    iTSTfail   jsr	restoreIL
   1602  09b1		       4c 0e 0b 	      jmp	tstBranch
   1603  09b4							;
   1604  09b4							;=================================================JLIT=
   1605  09b4							; Test if we have a let statement without the let keyword
   1606  09b4		       20 88 12    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1607  09b7		       8d 4d 27 	      sta	offset	; Save the jump offset for fails
   1608  09ba		       20 6b 14 	      jsr	saveIL	; save to restore when done if fail
   1609  09bd
   1610  09bd		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1611  09bf		       20 b5 15 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1612  09c2		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1613  09c3		       20 b5 15 	      jsr	SkipSpaces	; skip any SkipSpaces
   1614  09c6		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1615  09c8		       c9 3d		      cmp	#'=	; check if equals
   1616  09ca		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1617  09cc		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1618  09ce		       d0 de		      bne	iTSTfail	; return it failed
   1619  09d0
   1620  09d0				   iTSTLETGOOD
   1621  09d0		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1622  09d3
   1623  09d3							;=================================================JLIT=
   1624  09d3							;
   1625  09d3		       20 88 12    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1626  09d6		       8d 4d 27 	      sta	offset	; Save the jump offset for fails
   1627  09d9		       20 6b 14 	      jsr	saveIL	; save to restore when done if fail
   1628  09dc		       20 84 12 	      jsr	getILWord	; Get a word into RO
   1629  09df		       86 52		      stx	R0
   1630  09e1		       85 53		      sta	R0+1
   1631  09e3		       20 88 12 	      jsr	getILByte	; Get byte into A
   1632  09e6		       a0 00		      ldy	#0
   1633  09e8		       d1 52		      cmp	(R0),y
   1634  09ea		       d0 03		      bne	iTSTByteNotEqual
   1635  09ec		       4c ae 09 	      jmp	iTSTfail
   1636  09ef
   1637  09ef				   iTSTByteNotEqual
   1638  09ef		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1639  09f2
   1640  09f2
   1641  09f2							;================================================jLIT=
   1642  09f2							;Test for end of line
   1643  09f2							;
   1644  09f2		       20 88 12    iTSTDONE   jsr	getILByte
   1645  09f5		       8d 4d 27 	      sta	offset
   1646  09f8		       20 6b 14 	      jsr	saveIL
   1647  09fb		       a4 51		      ldy	CUROFF
   1648  09fd		       84 59		      sty	dpl
   1649  09ff		       20 b5 15 	      jsr	SkipSpaces
   1650  0a02		       b1 4f		      lda	(CURPTR),y
   1651  0a04		       f0 0b		      beq	iTSTDONEtrue
   1652  0a06		       c9 3a		      cmp	#COLON
   1653  0a08		       f0 07		      beq	iTSTDONEtrue
   1654  0a0a		       a4 59		      ldy	dpl
   1655  0a0c		       84 51		      sty	CUROFF
   1656  0a0e		       4c ae 09 	      jmp	iTSTfail
   1657  0a11							;
   1658  0a11							; Advance to the next line
   1659  0a11							;
   1660  0a11				   iTSTDONEtrue
   1661  0a11		       4c bb 02 	      jmp	NextIL
   1662  0a14
   1663  0a14		       4c 0e 0b    tstBranchLink jmp	tstBranch
   1664  0a17							;
   1665  0a17							;=====================================================
   1666  0a17							; Inc and dec a variable , faster than a = a + 1
   1667  0a17				   iINCVAR
   1668  0a17		       20 05 15 	      jsr	popR0
   1669  0a1a		       a0 00		      ldy	#0
   1670  0a1c		       18		      clc
   1671  0a1d		       a9 01		      lda	#1
   1672  0a1f		       71 52		      adc	(R0),y
   1673  0a21		       91 52		      sta	(R0),y
   1674  0a23		       90 07		      bcc	iINCDONE
   1675  0a25		       c8		      iny
   1676  0a26		       a9 00		      lda	#0
   1677  0a28		       71 52		      adc	(R0),y
   1678  0a2a		       91 52		      sta	(R0),y
   1679  0a2c				   iINCDONE
   1680  0a2c		       4c bb 02 	      jmp	NextIL
   1681  0a2f				   iDECVAR
   1682  0a2f		       20 05 15 	      jsr	popR0
   1683  0a32		       a0 00		      ldy	#0
   1684  0a34		       38		      sec
   1685  0a35		       b1 52		      lda	(R0),y
   1686  0a37		       e9 01		      sbc	#1
   1687  0a39		       91 52		      sta	(R0),y
   1688  0a3b		       c8		      iny
   1689  0a3c		       b1 52		      lda	(R0),y
   1690  0a3e		       69 00		      adc	#0
   1691  0a40		       91 52		      sta	(R0),y
   1692  0a42		       4c bb 02 	      jmp	NextIL
   1693  0a45
   1694  0a45
   1695  0a45							;
   1696  0a45							;=====================================================
   1697  0a45							; TSTV is followed by an 8 bit signed offset.	If the
   1698  0a45							; value at (CURPTR),CUROFF appears to be a variable
   1699  0a45							; name, move to the next IL statement.  Else, add the
   1700  0a45							; offset to ILPC. Converted to use actual absolute memory addresses
   1701  0a45							; TSTVT Looks for the task context
   1702  0a45							;
   1703  0a45		       20 1d 15    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1704  0a48		       a9 00		      lda	#0
   1705  0a4a		       85 58		      sta	R2
   1706  0a4c		       f0 04		      beq	iTSTVV
   1707  0a4e
   1708  0a4e		       a9 01	   iTSTV      lda	#1
   1709  0a50		       85 58		      sta	R2
   1710  0a52
   1711  0a52		       20 88 12    iTSTVV     jsr	getILByte	;offset
   1712  0a55		       8d 4d 27 	      sta	offset
   1713  0a58							;
   1714  0a58		       a4 51		      ldy	CUROFF
   1715  0a5a		       20 b5 15 	      jsr	SkipSpaces
   1716  0a5d		       b1 4f		      lda	(CURPTR),y
   1717  0a5f		       d0 03		      bne	iTSTVnext
   1718  0a61		       4c 14 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1719  0a64							;
   1720  0a64				   iTSTVnext
   1721  0a64		       c9 40		      cmp	#'@	;allow access to all unused memory as an array of integers
   1722  0a66		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1723  0a68
   1724  0a68		       c9 23		      cmp	#'#	; parameters passed to this task
   1725  0a6a		       f0 53		      beq	iTSTVParm
   1726  0a6c
   1727  0a6c		       c9 5e		      cmp	#'^	; task exit code
   1728  0a6e		       d0 04		      bne	iTSTV_A2Z
   1729  0a70		       a9 19		      lda	#TASKEXITCODE
   1730  0a72		       d0 10		      bne	iTSTVContinue
   1731  0a74
   1732  0a74				   iTSTV_A2Z
   1733  0a74		       09 20		      ora	#$20	;make lower then upper
   1734  0a76		       49 20		      eor	#$20	;allow lower case here
   1735  0a78		       c9 41		      cmp	#'A
   1736  0a7a		       90 98		      bcc	tstBranchLink
   1737  0a7c		       c9 5b		      cmp	#'Z+1
   1738  0a7e		       b0 94		      bcs	tstBranchLink
   1739  0a80
   1740  0a80
   1741  0a80							;
   1742  0a80							; The condition is true, so convert to an index, push
   1743  0a80							; it onto the stack and continue running.
   1744  0a80							;
   1745  0a80		       38		      sec
   1746  0a81		       e9 41		      sbc	#'A	;index is zero based
   1747  0a83		       0a		      asl		;multiply by two
   1748  0a84
   1749  0a84				   iTSTVContinue
   1750  0a84		       c8		      iny
   1751  0a85		       84 51		      sty	CUROFF	;it is a valid variable
   1752  0a87		       48		      pha
   1753  0a88		       a5 58		      lda	R2
   1754  0a8a		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1755  0a8c
   1756  0a8c		       20 6b 12 	      jsr	ipc_getcontext	; Get the other tasks variables
   1757  0a8f		       a0 01		      ldy	#VARIABLEPOS
   1758  0a91		       b1 56		      lda	(MQ),y
   1759  0a93		       85 52		      sta	R0
   1760  0a95		       c8		      iny
   1761  0a96		       b1 56		      lda	(MQ),y
   1762  0a98		       85 53		      sta	R0+1
   1763  0a9a		       4c a5 0a 	      jmp	iTSTVAddOffset
   1764  0a9d
   1765  0a9d				   iTSTVLocalValue
   1766  0a9d		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1767  0a9f		       85 52		      sta	R0
   1768  0aa1		       a5 42		      lda	VARIABLES+1
   1769  0aa3		       85 53		      sta	R0+1
   1770  0aa5
   1771  0aa5				   iTSTVAddOffset
   1772  0aa5		       68		      pla
   1773  0aa6		       85 54		      sta	R1
   1774  0aa8		       a9 00		      lda	#0
   1775  0aaa		       85 55		      sta	R1+1
   1776  0aac
   1777  0aac				   iTSTVcontinue
   1778  0aac
   1779  0aac		       4c 8b 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1780  0aaf
   1781  0aaf							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1782  0aaf							; an array of integer values
   1783  0aaf				   iTSTVat
   1784  0aaf		       c8		      iny
   1785  0ab0		       84 51		      sty	CUROFF	;it is a valid variable
   1786  0ab2		       ad 53 27 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1787  0ab5		       85 52		      sta	R0
   1788  0ab7		       ad 54 27 	      lda	ProgramEnd+1
   1789  0aba		       85 53		      sta	R0+1
   1790  0abc		       4c 03 07 	      jmp	pushR0nextIl	;place this onto the stack
   1791  0abf
   1792  0abf							; When we get parameters passed we can access them using the # variable with[]
   1793  0abf							; example #[0] #[1] etc, we dont check yet if there is too many
   1794  0abf				   iTSTVParm
   1795  0abf		       c8		      iny
   1796  0ac0		       84 51		      sty	CUROFF	;it is a valid variable
   1797  0ac2		       a5 48		      lda	MATHSTACK
   1798  0ac4		       85 52		      sta	R0
   1799  0ac6		       a5 49		      lda	MATHSTACK+1
   1800  0ac8		       85 53		      sta	R0+1
   1801  0aca		       4c 03 07 	      jmp	pushR0nextIl
   1802  0acd
   1803  0acd							;
   1804  0acd							;=====================================================
   1805  0acd							; TSTL seems basically the same as TSTN, but leave the
   1806  0acd							; value in R0 instead of pushing onto stack.
   1807  0acd							; This tests for a valid line number
   1808  0acd							;
   1809  0acd		       20 88 12    iTSTL      jsr	getILByte
   1810  0ad0		       8d 4d 27 	      sta	offset
   1811  0ad3							;
   1812  0ad3		       a4 51		      ldy	CUROFF
   1813  0ad5		       20 b5 15 	      jsr	SkipSpaces
   1814  0ad8		       b1 4f		      lda	(CURPTR),y
   1815  0ada							;
   1816  0ada		       c9 30		      cmp	#'0
   1817  0adc		       90 30		      bcc	tstBranch
   1818  0ade		       c9 3a		      cmp	#'9+1
   1819  0ae0		       b0 2c		      bcs	tstBranch
   1820  0ae2							;
   1821  0ae2							; It's a digit, so convert to a number.
   1822  0ae2							;
   1823  0ae2		       20 33 13 	      jsr	getDecimal
   1824  0ae5		       4c bb 02 	      jmp	NextIL
   1825  0ae8							;
   1826  0ae8							;=====================================================
   1827  0ae8							; TSTN checks for a number.  This is very simplistic;
   1828  0ae8							; if the character is a digit, assume it's a number.
   1829  0ae8							; Convert to a number and push it onto the stack.
   1830  0ae8							;
   1831  0ae8		       20 88 12    iTSTN      jsr	getILByte
   1832  0aeb		       8d 4d 27 	      sta	offset
   1833  0aee							;
   1834  0aee		       a4 51		      ldy	CUROFF
   1835  0af0		       20 b5 15 	      jsr	SkipSpaces
   1836  0af3		       b1 4f		      lda	(CURPTR),y
   1837  0af5		       f0 17		      beq	tstBranch
   1838  0af7		       c9 2d		      cmp	#'-	;negative?
   1839  0af9		       f0 08		      beq	iTSTN_1
   1840  0afb		       c9 30		      cmp	#'0
   1841  0afd		       90 0f		      bcc	tstBranch
   1842  0aff		       c9 3a		      cmp	#'9+1
   1843  0b01		       b0 0b		      bcs	tstBranch
   1844  0b03							;
   1845  0b03							; It's a digit, so convert to a number.
   1846  0b03							;
   1847  0b03				   iTSTN_1
   1848  0b03		       20 33 13 	      jsr	getDecimal
   1849  0b06		       84 51		      sty	CUROFF
   1850  0b08		       20 81 14 	      jsr	pushR0	;save onto stack
   1851  0b0b		       4c bb 02 	      jmp	NextIL
   1852  0b0e
   1853  0b0e							;
   1854  0b0e							; Common jump point for all TSTx instructions that
   1855  0b0e							; fail to meet the requirements.  This takes the
   1856  0b0e							; offset and adds/subtracts to/from ILPC.
   1857  0b0e							;
   1858  0b0e		       ad 4d 27    tstBranch  lda	offset	;get signed offset
   1859  0b11		       10 0e		      bpl	tstPositive
   1860  0b13							;
   1861  0b13							; Do negative branch.	Do sign extension.
   1862  0b13							;
   1863  0b13		       18	   tstNegative clc
   1864  0b14		       65 43		      adc	ILPC
   1865  0b16		       85 43		      sta	ILPC
   1866  0b18							;		  bcc	  tstBothDone
   1867  0b18							;		  dec	  ILPC+1
   1868  0b18							;		  jmp	  NextIL
   1869  0b18
   1870  0b18		       a5 44		      lda	ILPC+1
   1871  0b1a		       69 ff		      adc	#$ff
   1872  0b1c		       85 44		      sta	ILPC+1
   1873  0b1e		       4c bb 02 	      jmp	NextIL	;keep going
   1874  0b21							;
   1875  0b21		       18	   tstPositive clc
   1876  0b22		       65 43		      adc	ILPC
   1877  0b24		       85 43		      sta	ILPC
   1878  0b26		       90 02		      bcc	tstBothDone
   1879  0b28		       e6 44		      inc	ILPC+1
   1880  0b2a				   tstBothDone
   1881  0b2a		       4c bb 02 	      jmp	NextIL
   1882  0b2d
   1883  0b2d							;
   1884  0b2d							;====================================================
   1885  0b2d							; Test for IRQ pending, and test if a break key pressed
   1886  0b2d							; Yes I know but this handles all sorts of irq/break issues
   1887  0b2d							;
   1888  0b2d		       20 88 12    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1889  0b30		       8d 4d 27 	      sta	offset	; Store the not true jump address offset
   1890  0b33		       20 36 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1891  0b36		       d0 03		      bne	irqNo	; z not set of no break found
   1892  0b38		       4c 01 06 	      jmp	iFIN	; Exit out of run mode
   1893  0b3b		       ad f5 1d    irqNo      lda	IRQPending
   1894  0b3e		       f0 ce		      beq	tstBranch
   1895  0b40		       c9 01		      cmp	#1	; only do this if set to first time
   1896  0b42		       d0 ca		      bne	tstBranch
   1897  0b44		       78		      sei		; disable the interupt until ireturn resets it
   1898  0b45		       ee f5 1d    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1899  0b48		       20 9b 14 	      jsr	pushLN	; Push the next line to be executed
   1900  0b4b		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1901  0b4d		       ad f6 1d 	      lda	IRQEntry	; Get the line number to branch to
   1902  0b50		       85 4f		      sta	CURPTR	; put line number into r0
   1903  0b52		       ad f7 1d 	      lda	IRQEntry+1
   1904  0b55		       85 50		      sta	CURPTR+1
   1905  0b57		       a9 03		      lda	#3	; Point to first byte of program text
   1906  0b59		       85 51		      sta	CUROFF
   1907  0b5b		       4c bb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1908  0b5e
   1909  0b5e		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1910  0b60		       a9 00		      lda	#0	; stop the execution
   1911  0b62		       4c 18 06 	      jmp	iErr2
   1912  0b65							;
   1913  0b65
   1914  0b65							;=====================================================
   1915  0b65							; This places the number of free bytes on top of the
   1916  0b65							; stack.
   1917  0b65							;
   1918  0b65		       20 ee 0d    iFREE      jsr	MemFree
   1919  0b68		       20 81 14 	      jsr	pushR0
   1920  0b6b		       4c bb 02 	      jmp	NextIL
   1921  0b6e							;
   1922  0b6e							;=====================================================
   1923  0b6e							; Generate a random number from 0-FFFF and then MOD
   1924  0b6e							; it with the value on top of stack.  Leaves number on
   1925  0b6e							; stack
   1926  0b6e							;
   1927  0b6e		       20 1d 15    iRANDOM    jsr	popR1	;mod value
   1928  0b71							;
   1929  0b71							; If the value is zero, just return a one.
   1930  0b71							;
   1931  0b71		       a5 54		      lda	R1
   1932  0b73		       05 55		      ora	R1+1
   1933  0b75		       f0 4a		      beq	irandom1
   1934  0b77							;
   1935  0b77		       ad 44 27 	      lda	random+1
   1936  0b7a		       8d 41 27 	      sta	rtemp1
   1937  0b7d		       ad 43 27 	      lda	random
   1938  0b80		       0a		      asl
   1939  0b81		       2e 41 27 	      rol	rtemp1
   1940  0b84		       0a		      asl
   1941  0b85		       2e 41 27 	      rol	rtemp1
   1942  0b88		       18		      clc
   1943  0b89		       6d 43 27 	      adc	random
   1944  0b8c
   1945  0b8c		       48		      pha
   1946  0b8d
   1947  0b8d		       ad 41 27 	      lda	rtemp1
   1948  0b90		       6d 44 27 	      adc	random+1
   1949  0b93		       8d 44 27 	      sta	random+1
   1950  0b96
   1951  0b96		       68		      pla
   1952  0b97
   1953  0b97		       69 11		      adc	#$11
   1954  0b99		       8d 43 27 	      sta	random
   1955  0b9c		       ad 44 27 	      lda	random+1
   1956  0b9f		       69 36		      adc	#$36
   1957  0ba1		       8d 44 27 	      sta	random+1
   1958  0ba4
   1959  0ba4		       ad 43 27 	      lda	random
   1960  0ba7		       85 52		      sta	R0
   1961  0ba9		       ad 44 27 	      lda	random+1
   1962  0bac		       29 7f		      and	#$7f	;make positive
   1963  0bae		       85 53		      sta	R0+1
   1964  0bb0							;
   1965  0bb0							; R0 contains the number and R1 contains the max value.
   1966  0bb0							;
   1967  0bb0		       20 29 07 	      jsr	iDivNoPop
   1968  0bb3		       20 86 15 	      jsr	RestoreSigns
   1969  0bb6		       a5 56		      lda	MQ
   1970  0bb8		       85 52		      sta	R0
   1971  0bba		       a5 57		      lda	MQ+1
   1972  0bbc		       85 53		      sta	R0+1
   1973  0bbe		       4c 03 07 	      jmp	pushR0nextIl
   1974  0bc1				   irandom1
   1975  0bc1		       a9 00		      lda	#0
   1976  0bc3		       85 53		      sta	R0+1
   1977  0bc5		       a9 01		      lda	#1
   1978  0bc7		       85 52		      sta	R0
   1979  0bc9		       4c 03 07 	      jmp	pushR0nextIl
   1980  0bcc
   1981  0bcc							; The following replaced by call to division/modulo
   1982  0bcc							;iRANDOM_2	lda	R0
   1983  0bcc							;		cmp	R1
   1984  0bcc							;		bne	iRANDOM_1
   1985  0bcc							;		lda	R0+1
   1986  0bcc							;		cmp	R1+1
   1987  0bcc							;		bne	iRANDOM_1	;need to subtract
   1988  0bcc							;
   1989  0bcc							; Subtract R1 from R0
   1990  0bcc							;
   1991  0bcc							;iRANDOM_sub	sec
   1992  0bcc							;		lda	R0
   1993  0bcc							;		sbc	R1
   1994  0bcc							;		sta	R0
   1995  0bcc							;		lda	R0+1
   1996  0bcc							;		sbc	R1+1
   1997  0bcc							;		sta	R0+1
   1998  0bcc							;		jmp	iRANDOM_2
   1999  0bcc							;
   2000  0bcc							; See if R1 > R0.  If so, branch to subtract.
   2001  0bcc							;
   2002  0bcc							;iRANDOM_1	lda	R0
   2003  0bcc							;		cmp	R1
   2004  0bcc							;		lda	R0+1
   2005  0bcc							;		sbc	R1+1
   2006  0bcc							;		bvc	iRANDOM_4
   2007  0bcc							;		eor	#$80
   2008  0bcc							;iRANDOM_4	bpl	iRANDOM_sub
   2009  0bcc							;
   2010  0bcc							; All done.  Almost.  Add one, then push the result.
   2011  0bcc							;
   2012  0bcc							;irandom1	inc	R0
   2013  0bcc							;		bne	iRANDOM_3
   2014  0bcc							;		inc	R0+1
   2015  0bcc							;iRANDOM_3
   2016  0bcc							;		  jsr	pushR0	;return value
   2017  0bcc							;		jmp	NextIL
   2018  0bcc							;
   2019  0bcc							; Poke a value into a memory location
   2020  0bcc		       8c 49 27    iPOKEMEMORY sty	tempy
   2021  0bcf		       20 05 15 	      jsr	popR0
   2022  0bd2		       20 1d 15 	      jsr	popR1
   2023  0bd5		       a0 00		      ldy	#0
   2024  0bd7		       a5 52		      lda	R0
   2025  0bd9		       91 54		      sta	(R1),y
   2026  0bdb		       ac 49 27 	      ldy	tempy
   2027  0bde		       4c bb 02 	      jmp	NextIL
   2028  0be1							;
   2029  0be1							; Get a value from a memory location
   2030  0be1							;
   2031  0be1		       8c 49 27    iPEEKMEMORY sty	tempy
   2032  0be4		       20 05 15 	      jsr	popR0
   2033  0be7		       a0 00		      ldy	#0
   2034  0be9		       b1 52		      lda	(R0),y
   2035  0beb		       ac 49 27 	      ldy	tempy
   2036  0bee		       85 52		      sta	R0
   2037  0bf0		       a9 00		      lda	#0
   2038  0bf2		       85 53		      sta	R0+1
   2039  0bf4		       4c 03 07 	      jmp	pushR0nextIl
   2040  0bf7							;
   2041  0bf7							; Call to address return what ever is in a to the stack
   2042  0bf7							; func2 will load a value into a before the call
   2043  0bf7		       20 1d 15    iCallFunc  jsr	popR1
   2044  0bfa		       a5 54		      lda	R1
   2045  0bfc		       20 08 0c 	      jsr	iCallRtn
   2046  0bff		       85 52		      sta	R0
   2047  0c01		       a9 00		      lda	#0
   2048  0c03		       85 53		      sta	R0+1
   2049  0c05		       20 03 07 	      jsr	pushR0nextIl
   2050  0c08				   iCallRtn
   2051  0c08		       20 05 15 	      jsr	popR0
   2052  0c0b		       6c 52 00 	      jmp	(R0)
   2053  0c0e
   2054  0c0e
   2055  0c0e							;===========================================jlit======
   2056  0c0e							;Get a character from the terminal convert to value
   2057  0c0e							;leave the number on top of the stack
   2058  0c0e							;
   2059  0c0e				   iGETCHAR
   2060  0c0e		       20 0a 17 	      jsr	VGETCH
   2061  0c11					      if	CTMON65
   2062  0c11		       48		      pha
   2063  0c12		       20 07 17 	      jsr	VOUTCH	;echo echo echo
   2064  0c15		       68		      pla
   2065  0c16					      endif
   2066  0c16		       85 52		      sta	R0
   2067  0c18		       a9 00		      lda	#0
   2068  0c1a		       85 53		      sta	R0+1
   2069  0c1c		       20 81 14 	      jsr	pushR0
   2070  0c1f							;
   2071  0c1f		       4c bb 02 	      jmp	NextIL
   2072  0c22							;===========================================jusilostintim======
   2073  0c22							;Put a character to the terminal convert to
   2074  0c22							;
   2075  0c22		       20 05 15    iPUTCHAR   jsr	popR0
   2076  0c25		       a5 52		      lda	R0
   2077  0c27		       20 07 17 	      jsr	VOUTCH
   2078  0c2a		       4c bb 02 	      jmp	NextIL
   2079  0c2d							;=====================================================
   2080  0c2d							; Put the number on the stack out as hex, suppress leading 0
   2081  0c2d				   iHexOut
   2082  0c2d		       20 05 15 	      jsr	popR0
   2083  0c30		       a5 53		      lda	R0+1
   2084  0c32		       f0 03		      beq	iHexSecondByte
   2085  0c34		       20 ac 0d 	      jsr	OUTHEX
   2086  0c37				   iHexSecondByte
   2087  0c37		       a5 52		      lda	R0
   2088  0c39		       20 ac 0d 	      jsr	OUTHEX
   2089  0c3c		       4c bb 02 	      jmp	NextIL
   2090  0c3f							;
   2091  0c3f							;=====================================================
   2092  0c3f							; Replace TOS with its absolute value.
   2093  0c3f							;
   2094  0c3f		       20 05 15    iABS       jsr	popR0
   2095  0c42		       a5 53		      lda	R0+1
   2096  0c44		       10 10		      bpl	iABS_1	;already positive
   2097  0c46		       49 ff		      eor	#$ff
   2098  0c48		       85 53		      sta	R0+1
   2099  0c4a		       a5 52		      lda	R0
   2100  0c4c		       49 ff		      eor	#$ff
   2101  0c4e		       85 52		      sta	R0
   2102  0c50		       e6 52		      inc	R0
   2103  0c52		       d0 02		      bne	iABS_1
   2104  0c54		       e6 53		      inc	R0+1
   2105  0c56		       4c 03 07    iABS_1     jmp	pushR0nextIl
   2106  0c59
   2107  0c59							;
   2108  0c59							;================================================================
   2109  0c59							; The set of logical operators
   2110  0c59				   iLogAnd
   2111  0c59		       20 05 15 	      jsr	popR0
   2112  0c5c		       20 1d 15 	      jsr	popR1
   2113  0c5f		       a5 52		      lda	R0
   2114  0c61		       25 54		      and	R1
   2115  0c63		       85 52		      sta	R0
   2116  0c65		       a5 53		      lda	R0+1
   2117  0c67		       25 55		      and	R1+1
   2118  0c69		       85 53		      sta	R0+1
   2119  0c6b		       4c 03 07 	      jmp	pushR0nextIl
   2120  0c6e				   iLogOr
   2121  0c6e		       20 05 15 	      jsr	popR0
   2122  0c71		       20 1d 15 	      jsr	popR1
   2123  0c74		       a5 52		      lda	R0
   2124  0c76		       05 54		      ora	R1
   2125  0c78		       85 52		      sta	R0
   2126  0c7a		       a5 53		      lda	R0+1
   2127  0c7c		       05 55		      ora	R1+1
   2128  0c7e		       85 53		      sta	R0+1
   2129  0c80		       4c 03 07 	      jmp	pushR0nextIl
   2130  0c83				   iLogXor
   2131  0c83		       20 05 15 	      jsr	popR0
   2132  0c86		       20 1d 15 	      jsr	popR1
   2133  0c89		       a5 52		      lda	R0
   2134  0c8b		       45 54		      eor	R1
   2135  0c8d		       85 52		      sta	R0
   2136  0c8f		       a5 53		      lda	R0+1
   2137  0c91		       45 55		      eor	R1+1
   2138  0c93		       85 53		      sta	R0+1
   2139  0c95		       4c 03 07 	      jmp	pushR0nextIl
   2140  0c98				   iLogNot
   2141  0c98		       20 05 15 	      jsr	popR0
   2142  0c9b		       a5 52		      lda	R0
   2143  0c9d		       49 ff		      eor	#$FF
   2144  0c9f		       85 52		      sta	R0
   2145  0ca1		       a5 53		      lda	R0+1
   2146  0ca3		       49 ff		      eor	#$FF
   2147  0ca5		       85 53		      sta	R0+1
   2148  0ca7		       4c 03 07 	      jmp	pushR0nextIl
   2149  0caa
   2150  0caa				   iTruth
   2151  0caa		       a9 ff		      lda	#$FF
   2152  0cac		       85 52		      sta	R0
   2153  0cae		       85 53		      sta	R0+1
   2154  0cb0		       4c 03 07 	      jmp	pushR0nextIl
   2155  0cb3				   iFalse
   2156  0cb3		       a9 00		      lda	#$00
   2157  0cb5		       85 52		      sta	R0
   2158  0cb7		       85 53		      sta	R0+1
   2159  0cb9		       4c 03 07 	      jmp	pushR0nextIl
   2160  0cbc
   2161  0cbc							;================================================================
   2162  0cbc							;Set the IRQ service rtn line number
   2163  0cbc							;
   2164  0cbc		       78	   iSetIrq    sei		; disable the interupts
   2165  0cbd		       a9 00		      lda	#0	; Zero the Status flag
   2166  0cbf		       8d f4 1d 	      sta	IRQStatus
   2167  0cc2		       20 05 15 	      jsr	popR0	; get the line number
   2168  0cc5		       a5 52		      lda	R0
   2169  0cc7		       05 53		      ora	R0+1
   2170  0cc9		       f0 20		      beq	iSetExt	; if it is zero disable all
   2171  0ccb		       20 9b 14 	      jsr	pushLN	; Save the current line pointer
   2172  0cce		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2173  0cd0		       4c 5e 0b 	      jmp	ErrStkOver	; Check if there was an error
   2174  0cd3				   iSetIrqOk
   2175  0cd3		       20 cd 12 	      jsr	findLine	; Find the IRQ func Line Pointer
   2176  0cd6		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2177  0cd8		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2178  0cda		       8d f7 1d 	      sta	IRQEntry+1
   2179  0cdd		       a5 4f		      lda	CURPTR
   2180  0cdf		       8d f6 1d 	      sta	IRQEntry
   2181  0ce2		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2182  0ce4		       8d f4 1d 	      sta	IRQStatus
   2183  0ce7		       20 c0 14 	      jsr	popLN	; Restore the old line number
   2184  0cea		       58		      cli		; Enable the interupts
   2185  0ceb		       4c bb 02    iSetExt    jmp	NextIL
   2186  0cee
   2187  0cee		       20 c0 14    iSetIrqErr jsr	popLN
   2188  0cf1		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2189  0cf3		       a9 00		      lda	#0
   2190  0cf5		       4c 18 06 	      jmp	iErr2
   2191  0cf8							;
   2192  0cf8		       20 05 15    iTRACEPROG jsr	popR0
   2193  0cfb		       a5 52		      lda	R0
   2194  0cfd		       85 40		      sta	ILTrace
   2195  0cff		       4c bb 02 	      jmp	NextIL
   2196  0d02
   2197  0d02							;=====================================================
   2198  0d02							; Define start of non page zero data
   2199 U275b ????				      seg.u	TBData
   2200 U1de3					      org	PROGEND
   2201 U1de3							;=================================================================
   2202 U1de3							;
------- FILE print.asm LEVEL 2 PASS 6
      0 U1de3					      include	"print.asm"
      1  0d02					      Seg	Code
      2  0d02							;---------------------------
      3  0d02							; Print 24-bit decimal number or  16bit unsigned
      4  0d02							; ---------------------------
      5  0d02							; On entry, R0=number to print
      6  0d02							;	     Defaults to pad=0 , y=21 default
      7  0d02							;	     R2 = 1 unsigned 16 bit
      8  0d02							;	     R2 = 0 Signed   16 bit
      9  0d02
     10  0d02							; On entry at PrintDecPadded:
     11  0d02							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  0d02
     13  0d02							; On exit,  A,X,Y,num,pad corrupted
     14  0d02							; Size      129 bytes, Table 24 bytes	--- total 153
     15  0d02							; -----------------------------------------------------------------
     16  0d02
     17  0d02				   PrintDecimal
     18  0d02		       a9 00		      lda	#0
     19  0d04		       8d 93 0d 	      sta	pad
     20  0d07		       a0 15		      LDY	#21	; Offset to powers of ten
     21  0d09		       4c 0f 0d 	      JMP	PrintDo
     22  0d0c
     23  0d0c				   PrintDecPadded
     24  0d0c		       8e 93 0d 	      stx	pad
     25  0d0f
     26  0d0f				   PrintDo
     27  0d0f		       a9 00		      lda	#0
     28  0d11		       85 54		      sta	R1
     29  0d13
     30  0d13		       a5 58		      lda	R2
     31  0d15		       d0 29		      bne	PrintPos
     32  0d17
     33  0d17		       a5 53		      lda	R0+1	;MSB has sign
     34  0d19		       10 25		      bpl	PrintPos	;it's a positive number;
     35  0d1b
     36  0d1b
     37  0d1b							; Negative numbers need more work.  Invert all the bits,
     38  0d1b							; then add one.
     39  0d1b
     40  0d1b		       a9 2d		      lda	#'-
     41  0d1d		       20 07 17 	      jsr	VOUTCH	;print the negative sign
     42  0d20
     43  0d20		       a9 ff		      lda	#$FF
     44  0d22		       85 54		      sta	R1
     45  0d24		       a5 52		      lda	R0	;invert bits
     46  0d26		       49 ff		      eor	#$ff
     47  0d28		       85 52		      sta	R0
     48  0d2a		       a5 53		      lda	R0+1
     49  0d2c		       49 ff		      eor	#$ff
     50  0d2e		       85 53		      sta	R0+1
     51  0d30		       a5 54		      lda	R1
     52  0d32		       49 ff		      eor	#$ff
     53  0d34		       85 54		      sta	R1
     54  0d36		       e6 52		      inc	R0	;add one
     55  0d38		       d0 06		      bne	PrintPos
     56  0d3a		       e6 53		      inc	R0+1
     57  0d3c		       d0 02		      bne	PrintPos
     58  0d3e		       e6 54		      inc	R1
     59  0d40				   PrintPos
     60  0d40
     61  0d40				   PrDec24Lp1
     62  0d40		       a2 ff		      LDX	#$FF
     63  0d42		       38		      SEC		; Start with digit=-1
     64  0d43				   PrDec24Lp2
     65  0d43		       a5 52		      LDA	R0+0
     66  0d45		       f9 94 0d 	      SBC	PrDec24Tens+0,Y
     67  0d48		       85 52		      STA	R0+0	; Subtract current tens
     68  0d4a		       a5 53		      LDA	R0+1
     69  0d4c		       f9 95 0d 	      SBC	PrDec24Tens+1,Y
     70  0d4f		       85 53		      STA	R0+1
     71  0d51		       a5 54		      LDA	R0+2
     72  0d53		       f9 96 0d 	      SBC	PrDec24Tens+2,Y
     73  0d56		       85 54		      STA	R0+2
     74  0d58		       e8		      INX
     75  0d59		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     76  0d5b		       a5 52		      LDA	R0+0
     77  0d5d		       79 94 0d 	      ADC	PrDec24Tens+0,Y
     78  0d60		       85 52		      STA	R0+0	; Add current tens back in
     79  0d62		       a5 53		      LDA	R0+1
     80  0d64		       79 95 0d 	      ADC	PrDec24Tens+1,Y
     81  0d67		       85 53		      STA	R0+1
     82  0d69		       a5 54		      LDA	R0+2
     83  0d6b		       79 96 0d 	      ADC	PrDec24Tens+2,Y
     84  0d6e		       85 54		      STA	R0+2
     85  0d70		       8a		      TXA
     86  0d71		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     87  0d73		       ad 93 0d 	      LDA	pad
     88  0d76		       d0 09		      BNE	PrDec24Print
     89  0d78		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     90  0d7a				   PrDec24Digit
     91  0d7a		       a2 30		      LDX	#'0
     92  0d7c		       8e 93 0d 	      STX	pad	; No more zero padding
     93  0d7f		       09 30		      ORA	#'0	; Print this digit
     94  0d81				   PrDec24Print
     95  0d81		       20 07 17 	      JSR	VOUTCH
     96  0d84				   PrDec24Next
     97  0d84		       88		      DEY
     98  0d85		       88		      DEY
     99  0d86		       88		      DEY
    100  0d87		       f0 03		      beq	PrDec24LastDigit
    101  0d89		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    102  0d8b		       60		      RTS
    103  0d8c				   PrDec24LastDigit
    104  0d8c		       a2 30		      LDX	#'0
    105  0d8e		       8e 93 0d 	      STX	pad	; No more zero padding
    106  0d91		       d0 ad		      BNE	PrDec24Lp1	; Loop for last digit
    107  0d93
      0  0d93				   pad	      db	0
      1  0d93		       00		      .byte.b	0
    109  0d94				   PrDec24Tens
      0  0d94					      dw	1
      1  0d94		       01 00		      .word.w	1
      0  0d96					      db	1 / 65536
      1  0d96		       00		      .byte.b	1 / 65536
      0  0d97					      dw	10
      1  0d97		       0a 00		      .word.w	10
      0  0d99					      db	10 / 65536
      1  0d99		       00		      .byte.b	10 / 65536
      0  0d9a					      dw	100
      1  0d9a		       64 00		      .word.w	100
      0  0d9c					      db	100 / 65536
      1  0d9c		       00		      .byte.b	100 / 65536
      0  0d9d					      dw	1000
      1  0d9d		       e8 03		      .word.w	1000
      0  0d9f					      db	1000 / 65536
      1  0d9f		       00		      .byte.b	1000 / 65536
      0  0da0					      dw	10000
      1  0da0		       10 27		      .word.w	10000
      0  0da2					      db	10000 / 65536
      1  0da2		       00		      .byte.b	10000 / 65536
      0  0da3					      dw	100000
      1  0da3		       a0 86		      .word.w	100000
      0  0da5					      db	100000 / 65536
      1  0da5		       01		      .byte.b	100000 / 65536
      0  0da6					      dw	1000000
      1  0da6		       40 42		      .word.w	1000000
      0  0da8					      db	1000000 / 65536
      1  0da8		       0f		      .byte.b	1000000 / 65536
      0  0da9					      dw	10000000
      1  0da9		       80 96		      .word.w	10000000
      0  0dab					      db	10000000 / 65536
      1  0dab		       98		      .byte.b	10000000 / 65536
    126  0dac							;=====================================================
    127  0dac							; Print character in A as two hex digits to the
    128  0dac
    129  0dac
    130  0dac		       48	   HexToOut   pha		;save return value
    131  0dad		       48		      pha
    132  0dae		       4a		      lsr		;a  ;move top nibble to bottom
    133  0daf		       4a		      lsr		;a
    134  0db0		       4a		      lsr		;a
    135  0db1		       4a		      lsr		;a
    136  0db2		       20 bb 0d 	      jsr	hexta	;output nibble
    137  0db5		       68		      pla
    138  0db6		       20 bb 0d 	      jsr	hexta
    139  0db9		       68		      pla		;restore
    140  0dba		       60		      rts
    141  0dbb							;
    142  0dbb		       29 0f	   hexta      and	#%0001111
    143  0dbd		       c9 0a		      cmp	#$0a
    144  0dbf		       18		      clc
    145  0dc0		       30 02		      bmi	hexta1
    146  0dc2		       69 07		      adc	#7
    147  0dc4		       69 30	   hexta1     adc	#'0	;then fall into...
    148  0dc6		       4c 07 17 	      jmp	VOUTCH
    149  0dc9							;
    150  0dc9							;==================================================================================================
    151  0dc9							; Size of print functions
    152  0dc9		       00 c7	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  0dc9					      include	"mem.asm"
      1  0dc9							;===================================================================
      2  0dc9							;This file contains the memory allocation and free functions
      3  0dc9							;in herant in this is the management of free memory in the system
      4  0dc9							; the interface to these functions
      5  0dc9							; a,x returns or provides the low hi bytes of the managed addresses
      6  0dc9							; This uses the programend, to memory end as the area to manage
      7  0dc9							;===================================================================
      8  0dc9					      Seg	Code
      9  0dc9							;=====================================================
     10  0dc9							;Pointers for memory Management
     11  0dc9							;Allocated block are not chained but can be followed for all memory by the associated length
     12  0dc9							; Mem block format is
     13  0dc9							;	 0-1   pointer to next block for free blocks
     14  0dc9							;	 0-1   for allocated blocks
     15  0dc9							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  0dc9							;	   1   refrence counter ... lol only up to 256 but it is something
     17  0dc9							;	 2-3   length constant for exevy type of memory block
     18  0dc9							; Memory is recombined as it is released
     19  0dc9							; The memory manager is not interupted durring allocation
     20  0dc9							; or freeing of memory
     21  0dc9							; Memory is allocated from the highest memory address towards
     22  0dc9							; the lowest memory address. meeting the Basic program end.
     23  0dc9							;====================================================
     24  0dc9							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  0dc9							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  0dc9							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  0dc9							;=====================================================
     28  0dc9				   MemInit
     29  0dc9		       a9 5b		      lda	#FreeMemStart&$FF
     30  0dcb		       8d 51 27 	      sta	ProgramStart
     31  0dce		       8d 53 27 	      sta	ProgramEnd
     32  0dd1		       a9 27		      lda	#FreeMemStart>>8
     33  0dd3		       8d 52 27 	      sta	ProgramStart+1
     34  0dd6		       8d 54 27 	      sta	ProgramEnd+1
     35  0dd9
     36  0dd9		       20 e3 0d 	      jsr	GetSizes
     37  0ddc		       20 ee 0d 	      jsr	MemFree
     38  0ddf		       20 06 0e 	      jsr	MemUsed
     39  0de2				   MemInitEnd
     40  0de2		       60		      rts
     41  0de3
     42  0de3
     43  0de3							;
     44  0de3							;=====================================================
     45  0de3							; This function might go away eventually, but was
     46  0de3							; added to provide data for other pieces of code.
     47  0de3							; It has some ties to the operating environment that
     48  0de3							; will need to be customized for the target system.
     49  0de3							;
     50  0de3				   GetSizes
     51  0de3							;
     52  0de3							; Here is machine specific code to get the highest
     53  0de3							; memory location that can be used by BASIC.
     54  0de3							;
     55  0de3				  -	      if	ProgramStart < $2000
     56  0de3				  -	      lda	#$ff
     57  0de3				  -	      sta	HighMem	;$13ff for KIM-1
     58  0de3				  -	      sta	MemFreeList
     59  0de3				  -	      lda	#$DE	;#$13
     60  0de3				  -	      sta	HighMem+1
     61  0de3				  -	      sta	MemFreeList+1
     62  0de3					      else
     63  0de3		       a9 ff		      lda	#$ff
     64  0de5		       8d 55 27 	      sta	HighMem	;$CFFF otherwise
     65  0de8		       a9 cf		      lda	#$cf
     66  0dea		       8d 56 27 	      sta	HighMem+1
     67  0ded					      endif
     68  0ded		       60		      rts
     69  0dee							;
     70  0dee							; This computes the available memory remaining.
     71  0dee							;
     72  0dee				   MemFree
     73  0dee		       38		      sec
     74  0def		       ad 55 27 	      lda	HighMem
     75  0df2		       ed 53 27 	      sbc	ProgramEnd
     76  0df5		       8d 59 27 	      sta	FreeMem
     77  0df8		       85 52		      sta	R0
     78  0dfa		       ad 56 27 	      lda	HighMem+1
     79  0dfd		       ed 54 27 	      sbc	ProgramEnd+1
     80  0e00		       8d 5a 27 	      sta	FreeMem+1
     81  0e03		       85 53		      sta	R0+1
     82  0e05		       60		      rts
     83  0e06							;
     84  0e06							; This computes the size of the current user program.
     85  0e06							;
     86  0e06				   MemUsed
     87  0e06		       38		      sec
     88  0e07		       ad 53 27 	      lda	ProgramEnd
     89  0e0a		       ed 51 27 	      sbc	ProgramStart
     90  0e0d		       8d 57 27 	      sta	UsedMem
     91  0e10		       85 52		      sta	R0
     92  0e12		       ad 54 27 	      lda	ProgramEnd+1
     93  0e15		       ed 52 27 	      sbc	ProgramStart+1
     94  0e18		       8d 58 27 	      sta	UsedMem+1
     95  0e1b		       85 53		      sta	R0+1
     96  0e1d							;
     97  0e1d		       60		      rts
     98  0e1e
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  0e1e					      include	"gosub.asm"
      1  0e1e					      seg	Code
      2  0e1e
      3  0e1e							; Gosub and return related functions
      4  0e1e							;==========================================================
      5  0e1e							; Push the current math stack frame onto the gosub stack
      6  0e1e				   iPushMathStack
      7  0e1e		       98		      tya
      8  0e1f		       48		      pha
      9  0e20		       a4 4d		      ldy	GOSUBSTACKPTR
     10  0e22		       a5 4a		      lda	MATHSTACKPTR
     11  0e24		       91 4b		      sta	(GOSUBSTACK),y
     12  0e26		       a9 00		      lda	#0
     13  0e28		       c8		      iny
     14  0e29		       91 4b		      sta	(GOSUBSTACK),y
     15  0e2b		       c8		      iny
     16  0e2c		       91 4b		      sta	(GOSUBSTACK),y
     17  0e2e		       c8		      iny
     18  0e2f		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  0e31		       91 4b		      sta	(GOSUBSTACK),y
     20  0e33		       c8		      iny
     21  0e34		       84 4d		      sty	GOSUBSTACKPTR
     22  0e36		       68		      pla
     23  0e37		       a8		      tay
     24  0e38		       4c bb 02 	      jmp	NextIL
     25  0e3b							;
     26  0e3b							;==========================================================
     27  0e3b							; Increment parameter count. Assume Stack frame is top of stack
     28  0e3b				   iIncParmCount
     29  0e3b		       98		      tya
     30  0e3c		       48		      pha
     31  0e3d		       a4 4d		      ldy	GOSUBSTACKPTR
     32  0e3f		       88		      dey
     33  0e40		       88		      dey
     34  0e41		       88		      dey
     35  0e42		       b1 4b		      lda	(GOSUBSTACK),y
     36  0e44		       aa		      tax
     37  0e45		       e8		      inx
     38  0e46		       8a		      txa
     39  0e47		       91 4b		      sta	(GOSUBSTACK),y
     40  0e49		       68		      pla
     41  0e4a		       a8		      tay
     42  0e4b		       4c bb 02 	      jmp	NextIL
     43  0e4e							;
     44  0e4e							;==========================================================
     45  0e4e							;Restore the math stack frame
     46  0e4e		       20 54 0e    iPopMathStack jsr	PopMathStackNow
     47  0e51		       4c bb 02 	      jmp	NextIL
     48  0e54
     49  0e54				   PopMathStackNow
     50  0e54		       98		      tya
     51  0e55		       48		      pha
     52  0e56
     53  0e56		       a4 4d		      ldy	GOSUBSTACKPTR
     54  0e58		       88		      dey
     55  0e59		       b1 4b		      lda	(GOSUBSTACK),y
     56  0e5b		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  0e5d		       d0 09		      bne	iPopMathStackNoFrame
     58  0e5f		       88		      dey
     59  0e60		       88		      dey
     60  0e61		       88		      dey
     61  0e62		       b1 4b		      lda	(GOSUBSTACK),y
     62  0e64		       85 4a		      sta	MATHSTACKPTR
     63  0e66		       84 4d		      sty	GOSUBSTACKPTR
     64  0e68
     65  0e68				   iPopMathStackNoFrame
     66  0e68
     67  0e68		       68		      pla
     68  0e69		       a8		      tay
     69  0e6a		       60		      rts
     70  0e6b
     71  0e6b
     72  0e6b							;==========================================================
     73  0e6b							; Push the current math stack information onto the gosub stack
     74  0e6b				   iSaveMathStack
     75  0e6b		       98		      tya
     76  0e6c		       48		      pha
     77  0e6d		       a4 4d		      ldy	GOSUBSTACKPTR
     78  0e6f		       a5 4a		      lda	MATHSTACKPTR
     79  0e71		       91 4b		      sta	(GOSUBSTACK),y
     80  0e73		       a5 48		      lda	MATHSTACK
     81  0e75		       c8		      iny
     82  0e76
     83  0e76		       91 4b		      sta	(GOSUBSTACK),y
     84  0e78		       c8		      iny
     85  0e79
     86  0e79		       a5 49		      lda	MATHSTACK+1
     87  0e7b		       91 4b		      sta	(GOSUBSTACK),y
     88  0e7d		       c8		      iny
     89  0e7e
     90  0e7e		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  0e80		       91 4b		      sta	(GOSUBSTACK),y
     92  0e82		       c8		      iny
     93  0e83
     94  0e83		       84 4d		      sty	GOSUBSTACKPTR
     95  0e85		       68		      pla
     96  0e86		       a8		      tay
     97  0e87		       4c bb 02 	      jmp	NextIL
     98  0e8a							;
     99  0e8a							;==========================================================
    100  0e8a							;Restore the math stack information from the gosub stack
    101  0e8a				   iRestoreMathStack
    102  0e8a		       98		      tya
    103  0e8b		       48		      pha
    104  0e8c
    105  0e8c		       a5 4a		      lda	MATHSTACKPTR
    106  0e8e		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  0e90
    108  0e90		       a4 4d		      ldy	GOSUBSTACKPTR
    109  0e92		       88		      dey
    110  0e93		       b1 4b		      lda	(GOSUBSTACK),y
    111  0e95		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  0e97		       d0 16		      bne	iPopMathStack_Err
    113  0e99		       88		      dey
    114  0e9a		       b1 4b		      lda	(GOSUBSTACK),y
    115  0e9c		       85 49		      sta	MATHSTACK+1
    116  0e9e		       88		      dey
    117  0e9f		       b1 4b		      lda	(GOSUBSTACK),y
    118  0ea1		       85 48		      sta	MATHSTACK
    119  0ea3		       88		      dey
    120  0ea4		       b1 4b		      lda	(GOSUBSTACK),y
    121  0ea6		       85 4a		      sta	MATHSTACKPTR
    122  0ea8		       84 4d		      sty	GOSUBSTACKPTR
    123  0eaa		       68		      pla
    124  0eab		       a8		      tay
    125  0eac		       4c bb 02 	      jmp	NextIL
    126  0eaf
    127  0eaf				   iPopMathStack_Err
    128  0eaf		       a9 00		      lda	#0
    129  0eb1		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  0eb3		       4c 18 06 	      jmp	iErr2
    131  0eb6							;=========================================
    132  0eb6							; For functions and tasks the variable address of # means
    133  0eb6							; a passed parameter so #[0] is the first parameter etc
    134  0eb6							; will try for a better way later
    135  0eb6
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  0eb6					      include	"tasks.asm"
      1  0eb6							;=====================================================
      2  0eb6							; Tiny Basic IL task management
      3  0eb6							; Data required by task management
      4  0eb6							; currently each context is about 30 bytes and is swapped
      5  0eb6							; into and out of page zero on each task switch....
      6  0eb6							; LOL yes it is slow, but works for this iteration.
      7  0eb6							;
      8  0eb6
      9  0eb6					      Seg	Code
     10  0eb6							;=====================================================
     11  0eb6							; Sets the pointers to the math,IL and gosub stacks
     12  0eb6							; Creates the initial Context for each task slot
     13  0eb6				   taskSetStacks
     14  0eb6		       a9 f8		      lda	#mathStack&$FF
     15  0eb8		       85 48		      sta	MATHSTACK
     16  0eba		       a9 1e		      lda	#mathStack>>8
     17  0ebc		       85 49		      sta	MATHSTACK+1
     18  0ebe
     19  0ebe		       a9 88		      lda	#ilStack&$ff
     20  0ec0		       85 45		      sta	ILSTACK
     21  0ec2		       a9 20		      lda	#ilStack>>8
     22  0ec4		       85 46		      sta	ILSTACK+1
     23  0ec6
     24  0ec6		       a9 18		      lda	#gosubStack&$FF
     25  0ec8		       85 4b		      sta	GOSUBSTACK
     26  0eca		       a9 22		      lda	#gosubStack>>8
     27  0ecc		       85 4c		      sta	GOSUBSTACK+1
     28  0ece
     29  0ece		       a9 98		      lda	#variableStack&$FF
     30  0ed0		       85 41		      sta	VARIABLES
     31  0ed2		       a9 24		      lda	#variableStack>>8
     32  0ed4		       85 42		      sta	VARIABLES+1
     33  0ed6		       a2 0a		      ldx	#TASKCOUNT
     34  0ed8		       a0 00		      ldy	#0
     35  0eda		       20 65 11 	      jsr	ContextSave
     36  0edd
     37  0edd		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  0edf		       b0 3a		      bcs	taskSetDone
     39  0ee1
     40  0ee1		       a5 4b		      lda	GOSUBSTACK
     41  0ee3		       18		      clc
     42  0ee4		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  0ee6		       85 4b		      sta	GOSUBSTACK
     44  0ee8		       a5 4c		      lda	GOSUBSTACK+1
     45  0eea		       69 00		      adc	#0
     46  0eec		       85 4c		      sta	GOSUBSTACK+1
     47  0eee
     48  0eee		       a5 45		      lda	ILSTACK	; must be less than 256
     49  0ef0		       18		      clc
     50  0ef1		       69 28		      adc	#ILSTACKSIZE*2
     51  0ef3		       85 45		      sta	ILSTACK
     52  0ef5		       a5 46		      lda	ILSTACK+1
     53  0ef7		       69 00		      adc	#0
     54  0ef9		       85 46		      sta	ILSTACK+1
     55  0efb
     56  0efb		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  0efd		       18		      clc
     58  0efe		       69 28		      adc	#MATHSTACKSIZE*2
     59  0f00		       85 48		      sta	MATHSTACK
     60  0f02		       a5 49		      lda	MATHSTACK+1
     61  0f04		       69 00		      adc	#0
     62  0f06		       85 49		      sta	MATHSTACK+1
     63  0f08
     64  0f08		       a5 41		      lda	VARIABLES	; must be less than 256
     65  0f0a		       18		      clc
     66  0f0b		       69 36		      adc	#VARIABLESSIZE*2
     67  0f0d		       85 41		      sta	VARIABLES
     68  0f0f		       a5 42		      lda	VARIABLES+1
     69  0f11		       69 00		      adc	#0
     70  0f13		       85 42		      sta	VARIABLES+1
     71  0f15
     72  0f15		       20 65 11 	      jsr	ContextSave
     73  0f18		       4c dd 0e 	      jmp	taskSetLoop
     74  0f1b
     75  0f1b				   taskSetDone
     76  0f1b		       a0 00		      ldy	#0	; reload the main loop context
     77  0f1d		       20 74 11 	      jsr	ContextLoad
     78  0f20		       60		      rts
     79  0f21							;
     80  0f21							;=====================================================
     81  0f21							; In some error cases the math stacks may be left pointing to the wrong stack
     82  0f21							; This function will reset those stack addresses but not the actual pointer
     83  0f21				   taskResetStacks
     84  0f21		       a0 00		      ldy	#0
     85  0f23		       20 74 11 	      jsr	ContextLoad
     86  0f26		       4c b6 0e 	      jmp	taskSetStacks
     87  0f29							;
     88  0f29							;=====================================================
     89  0f29							; Clear all task entries and task stacks
     90  0f29		       98	   taskReset  tya		; Save Y
     91  0f2a		       48		      pha
     92  0f2b		       a9 01		      lda	#1
     93  0f2d		       8d f7 1e 	      sta	taskCounter	; Set number of active tasks to 1
     94  0f30		       ac f8 1d 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  0f33		       c0 00		      cpy	#0	; check if we are the main context
     96  0f35		       f0 08		      beq	taskResetCont	; if we are just continue
     97  0f37
     98  0f37		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  0f39		       8c f8 1d 	      sty	taskPtr
    100  0f3c		       20 74 11 	      jsr	ContextLoad	; load the System Task context
    101  0f3f				   taskResetCont
    102  0f3f		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  0f41
    104  0f41				   taskResetLoop
    105  0f41		       a9 00		      lda	#TASKINACTIVE
    106  0f43		       99 f9 1d 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  0f46		       18		      clc
    108  0f47		       98		      tya
    109  0f48		       69 19		      adc	#CONTEXTLEN+1
    110  0f4a		       a8		      tay
    111  0f4b		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  0f4d		       90 f2		      bcc	taskResetLoop	; Go for more
    113  0f4f
    114  0f4f				   taskResetComplete
    115  0f4f
    116  0f4f		       68		      pla		; Restore y
    117  0f50		       a8		      tay
    118  0f51		       60		      rts
    119  0f52
    120  0f52							;
    121  0f52							;======================================================
    122  0f52							; iTaskSwitch	 switch to new task if not interrupt and
    123  0f52							;		 count is exceded for task time slice gets here
    124  0f52							;		 when time slice has reached zero
    125  0f52							;
    126  0f52		       98	   iTaskSwitch tya
    127  0f53		       48		      pha
    128  0f54
    129  0f54		       ad f5 1e 	      lda	taskResetValue	; Always reset the counter value
    130  0f57		       8d f3 1e 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  0f5a		       ce f4 1e 	      dec	taskCurrentCycles+1	; dec high order byte
    132  0f5d		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  0f5f
    134  0f5f		       ad f6 1e 	      lda	taskResetValue+1
    135  0f62		       8d f4 1e 	      sta	taskCurrentCycles+1
    136  0f65
    137  0f65		       ad f5 1d 	      lda	IRQPending	; Skip this if we are processing an irq
    138  0f68		       0d 4f 27 	      ora	taskIOPending	; If set then don't switch
    139  0f6b		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  0f6d
    141  0f6d		       ad f7 1e    iTaskMain  lda	taskCounter	; Number of tasks
    142  0f70		       c9 01		      cmp	#1	; if there is only one task must be main
    143  0f72		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  0f74
    145  0f74		       ac f8 1d 	      ldy	taskPtr	; check if we have not just ended some other task
    146  0f77		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  0f79		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  0f7b							;
    149  0f7b							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  0f7b							;
    151  0f7b				   itasknext
    152  0f7b		       ac f8 1d 	      ldy	taskPtr
    153  0f7e		       20 65 11 	      jsr	ContextSave	; Save the current context, y points to next context
    154  0f81				   itaskLoop
    155  0f81		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  0f83		       90 04		      bcc	iTaskNextChk
    157  0f85
    158  0f85		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  0f87		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  0f89
    161  0f89				   iTaskNextChk
    162  0f89		       b9 f9 1d 	      lda	taskTable,y	; there is always at least one entry in table
    163  0f8c		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  0f8e		       18	   iTaskNext  clc
    165  0f8f		       98		      tya
    166  0f90		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  0f92		       a8		      tay
    168  0f93		       4c 81 0f 	      jmp	itaskLoop	; Check for busy entry
    169  0f96
    170  0f96		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  0f98		       59 f9 1d 	      eor	taskTable,y	; Check for anything waiting io
    172  0f9b		       d0 f1		      bne	iTaskNext
    173  0f9d		       20 74 11 	      jsr	ContextLoad	; load the next context
    174  0fa0		       8c f8 1d 	      sty	taskPtr	; update the task pointer
    175  0fa3
    176  0fa3				   iTaskSwitchDone
    177  0fa3		       68		      pla
    178  0fa4		       a8		      tay
    179  0fa5		       60		      rts
    180  0fa6							;
    181  0fa6							;================================================================
    182  0fa6							; Task Set task number to line number to start
    183  0fa6							; Task Table structure:
    184  0fa6							;    byte 0	-   Active inactive
    185  0fa6							;    byte 1-2	-   Basic code line pointer
    186  0fa6							;    byte 3	-   Offset on current line
    187  0fa6		       98	   iTaskSet   tya		;preserve Y
    188  0fa7		       48		      pha		; push a
    189  0fa8
    190  0fa8		       20 05 15 	      jsr	popR0	; Get the line number to be saved
    191  0fab
    192  0fab		       ac f8 1d 	      ldy	taskPtr	; find out where we are
    193  0fae		       20 65 11 	      jsr	ContextSave	; Save the current context
    194  0fb1
    195  0fb1							;Find the pointer to the line we need to start at
    196  0fb1		       20 cd 12 	      jsr	findLine	; Get the offset of the line to start task at
    197  0fb4		       f0 0b		      beq	iTaskCont
    198  0fb6
    199  0fb6		       ac f8 1d 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  0fb9		       20 74 11 	      jsr	ContextLoad
    201  0fbc
    202  0fbc		       68		      pla		; pop a - exit
    203  0fbd		       a8		      tay
    204  0fbe		       4c ee 0c 	      jmp	iSetIrqErr	; Bad line number provided
    205  0fc1
    206  0fc1				   iTaskCont
    207  0fc1		       20 37 11 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  0fc4		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  0fc6
    210  0fc6		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  0fc8		       99 f9 1d 	      sta	taskTable,y	; new task as active
    212  0fcb
    213  0fcb		       a5 4f		      lda	CURPTR
    214  0fcd		       48		      pha		; push a
    215  0fce		       a5 50		      lda	CURPTR+1
    216  0fd0		       48		      pha		; push a
    217  0fd1
    218  0fd1		       20 74 11 	      jsr	ContextLoad	; load the context of the new task
    219  0fd4
    220  0fd4		       68		      pla		; pop a
    221  0fd5		       85 50		      sta	CURPTR+1
    222  0fd7		       68		      pla		; pop a
    223  0fd8		       85 4f		      sta	CURPTR
    224  0fda		       a9 03		      lda	#3	; Offset to first instruction
    225  0fdc		       85 51		      sta	CUROFF
    226  0fde
    227  0fde		       a9 00		      lda	#0
    228  0fe0		       85 47		      sta	ILSTACKPTR
    229  0fe2		       85 4a		      sta	MATHSTACKPTR
    230  0fe4		       85 4d		      sta	GOSUBSTACKPTR
    231  0fe6		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  0fe8		       85 4e		      sta	MESSAGEPTR
    233  0fea
    234  0fea		       20 4b 09 	      jsr	subVINIT	; Clear the variables
    235  0fed
    236  0fed		       a9 25		      lda	#STMT&$FF
    237  0fef		       85 43		      sta	ILPC
    238  0ff1		       a9 19		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  0ff3		       85 44		      sta	ILPC+1
    240  0ff5
    241  0ff5		       98		      tya		; Save the new context offset to return to user
    242  0ff6		       48		      pha		; push a
    243  0ff7
    244  0ff7		       20 65 11    itaskSetSave jsr	ContextSave	; save the updated context
    245  0ffa		       ee f7 1e 	      inc	taskCounter	; Update the number of Tasks running
    246  0ffd
    247  0ffd		       ac f8 1d 	      ldy	taskPtr
    248  1000		       20 74 11 	      jsr	ContextLoad	; restore the original context
    249  1003
    250  1003		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  1005		       85 53		      sta	R0+1
    252  1007		       68		      pla		; Get the task pid we stored				 ; pop a
    253  1008		       85 52		      sta	R0	; Get the table entry value
    254  100a
    255  100a		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  100b		       a8		      tay
    257  100c
    258  100c		       4c 03 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  100f				   iTaskNoEmpty
    260  100f		       ac f8 1d 	      ldy	taskPtr
    261  1012		       20 74 11 	      jsr	ContextLoad
    262  1015
    263  1015		       68		      pla		; pop a    -- exit
    264  1016		       a8		      tay
    265  1017
    266  1017		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  1019		       a9 00		      lda	#0
    268  101b		       4c 18 06 	      jmp	iErr2
    269  101e							;
    270  101e							;===============================================================
    271  101e							; Run the task whos PID is on the stack, preserve the stack
    272  101e							;
    273  101e				   iTaskEnable
    274  101e		       98		      tya
    275  101f		       48		      pha
    276  1020		       20 1d 15 	      jsr	popR1
    277  1023		       20 eb 14 	      jsr	pushR1
    278  1026		       20 6b 12 	      jsr	ipc_getcontext	; get context pointer into mq
    279  1029		       a0 00		      ldy	#0
    280  102b		       b1 56		      lda	(MQ),y
    281  102d		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  102f		       09 80		      ora	#TASKACTIVE
    283  1031		       91 56		      sta	(MQ),y
    284  1033		       68		      pla
    285  1034		       a8		      tay
    286  1035		       4c bb 02 	      jmp	NextIL
    287  1038
    288  1038							;
    289  1038							;===============================================================
    290  1038							; Suspend the task whos PID  is on the stack, preserve the stack
    291  1038							;
    292  1038				   iTaskSuspend
    293  1038		       98		      tya
    294  1039		       48		      pha
    295  103a		       20 1d 15 	      jsr	popR1
    296  103d		       20 eb 14 	      jsr	pushR1
    297  1040		       20 6b 12 	      jsr	ipc_getcontext	; get context pointer into mq
    298  1043		       a0 00		      ldy	#0
    299  1045		       b1 56		      lda	(MQ),y
    300  1047		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  1049		       09 80		      ora	#TASKACTIVE
    302  104b		       68		      pla
    303  104c		       a8		      tay
    304  104d		       4c bb 02 	      jmp	NextIL
    305  1050
    306  1050							;================================================================
    307  1050							; Returns task Status
    308  1050				   iTaskStat
    309  1050		       98		      tya
    310  1051		       48		      pha
    311  1052		       20 64 10 	      jsr	iTaskValid	; returns pointer to task entry
    312  1055		       b9 f9 1d 	      lda	taskTable,y
    313  1058		       f0 05		      beq	iTaskStatExit
    314  105a		       68		      pla
    315  105b		       a8		      tay
    316  105c		       4c aa 0c 	      jmp	iTruth
    317  105f				   iTaskStatExit
    318  105f		       68		      pla
    319  1060		       a8		      tay
    320  1061		       4c b3 0c 	      jmp	iFalse
    321  1064
    322  1064							;
    323  1064							;================================================================
    324  1064							; Validate the task number on top of the stack
    325  1064							; on exit y points to the requested task entry
    326  1064							;
    327  1064		       20 05 15    iTaskValid jsr	popR0	; get result of the multiply
    328  1067		       a5 53		      lda	R0+1
    329  1069		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  106b		       a5 52		      lda	R0
    331  106d		       c9 fa		      cmp	#TASKTABLELEN
    332  106f		       90 09		      bcc	iTaskIsValid
    333  1071
    334  1071		       68	   iTaskValidErr pla		;remove return address
    335  1072		       68		      pla
    336  1073		       a2 10		      ldx	#ERR_INVALID_PID
    337  1075		       a9 00		      lda	#0
    338  1077		       4c 18 06 	      jmp	iErr2
    339  107a
    340  107a		       a8	   iTaskIsValid tay
    341  107b		       60		      rts
    342  107c							;
    343  107c							;================================================================
    344  107c							; Kill a running task, do nothing if already stopped
    345  107c		       20 64 10    iTaskKill  jsr	iTaskValid
    346  107f		       a9 00		      lda	#0
    347  1081		       99 f9 1d 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  1084							;
    349  1084							;================================================================
    350  1084							;Skip to next task
    351  1084				   iNTask
    352  1084		       a9 01		      lda	#1
    353  1086		       8d f3 1e 	      sta	taskCurrentCycles
    354  1089		       8d f4 1e 	      sta	taskCurrentCycles+1
    355  108c		       4c bb 02 	      jmp	NextIL
    356  108f							;
    357  108f							;=======================================================
    358  108f							; Wait for a task to complete
    359  108f				   iWTASK
    360  108f		       20 88 12 	      jsr	getILByte
    361  1092		       8d 4d 27 	      sta	offset
    362  1095							;
    363  1095		       20 6b 14 	      jsr	saveIL	;in case of failure
    364  1098
    365  1098		       20 64 10 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  109b		       b9 f9 1d 	      lda	taskTable,y
    367  109e		       d0 03		      bne	iWTASKWAIT
    368  10a0				   iWTASKEXITED
    369  10a0		       4c bb 02 	      jmp	NextIL
    370  10a3				   iWTASKWAIT
    371  10a3		       20 81 14 	      jsr	pushR0	; Push R0 back onto the stack
    372  10a6		       a9 01		      lda	#1
    373  10a8		       8d f3 1e 	      sta	taskCurrentCycles	; Give up the cycles
    374  10ab		       8d f4 1e 	      sta	taskCurrentCycles+1
    375  10ae		       20 76 14 	      jsr	restoreIL
    376  10b1		       4c 0e 0b 	      jmp	tstBranch
    377  10b4							;
    378  10b4							;=======================================================
    379  10b4							; Set task io lock
    380  10b4		       ee 4f 27    iStartIO   inc	taskIOPending
    381  10b7		       4c bb 02 	      jmp	NextIL
    382  10ba							;
    383  10ba							;=======================================================
    384  10ba							; Release the io lock
    385  10ba		       ad 4f 27    iEndIO     lda	taskIOPending
    386  10bd		       f0 03		      beq	iEndIOExit
    387  10bf		       ce 4f 27 	      dec	taskIOPending
    388  10c2		       4c bb 02    iEndIOExit jmp	NextIL
    389  10c5							;
    390  10c5							;===============================================================
    391  10c5							; Return the task PID
    392  10c5				   iTASKPID
    393  10c5		       a9 00		      lda	#0
    394  10c7		       85 53		      sta	R0+1
    395  10c9		       ad f8 1d 	      lda	taskPtr
    396  10cc		       85 52		      sta	R0
    397  10ce		       4c 03 07 	      jmp	pushR0nextIl
    398  10d1							;
    399  10d1							;================================================================
    400  10d1							; Terminate a task
    401  10d1		       ac f8 1d    iETask     ldy	taskPtr
    402  10d4		       c0 00		      cpy	#0
    403  10d6		       d0 03		      bne	iETaskCont
    404  10d8		       4c 01 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  10db				   iETaskCont
    406  10db		       a9 00		      lda	#TASKINACTIVE
    407  10dd		       99 f9 1d 	      sta	taskTable,y	; mark entry as free
    408  10e0		       ce f7 1e 	      dec	taskCounter	; reduce the number of active tasks
    409  10e3		       a9 01		      lda	#1
    410  10e5		       8d f3 1e 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  10e8		       8d f4 1e 	      sta	taskCurrentCycles+1
    412  10eb		       20 52 11 	      jsr	TaskSetExitCode
    413  10ee				   iETaskExit
    414  10ee		       4c bb 02 	      jmp	NextIL
    415  10f1							;================================================================
    416  10f1							; make the current tasks math stack equal another tasks stack
    417  10f1							; The task to get is stored on the math stack
    418  10f1
    419  10f1				   iTaskGetMathStack
    420  10f1		       20 7f 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  10f4		       20 6b 12 	      jsr	ipc_getcontext	; MQ now has the context address
    422  10f7		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  10f9		       b1 56		      lda	(MQ),y
    424  10fb		       85 4a		      sta	MATHSTACKPTR
    425  10fd		       a0 08		      ldy	#MATHSTACKPOS
    426  10ff		       b1 56		      lda	(MQ),y
    427  1101		       85 48		      sta	MATHSTACK
    428  1103		       c8		      iny
    429  1104		       b1 56		      lda	(MQ),y
    430  1106		       85 49		      sta	MATHSTACK+1
    431  1108		       4c bb 02 	      jmp	NextIL
    432  110b							;==================================================================
    433  110b							; Updates the tasks math stack pointer with contents of R2
    434  110b							; PID is on top of the stack
    435  110b				   iTaskPutMathPtr
    436  110b		       20 7f 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  110e		       20 6b 12 	      jsr	ipc_getcontext	; MQ now has the context address
    438  1111		       a5 58		      lda	R2
    439  1113		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  1115		       91 56		      sta	(MQ),y
    441  1117		       4c bb 02 	      jmp	NextIL
    442  111a							;
    443  111a							;================================================================
    444  111a							; Set the time slice for each task
    445  111a				   iSLICE
    446  111a		       20 05 15 	      jsr	popR0
    447  111d		       a5 52		      lda	R0
    448  111f		       8d f5 1e 	      sta	taskResetValue
    449  1122		       a5 53		      lda	R0+1
    450  1124		       8d f6 1e 	      sta	taskResetValue+1
    451  1127		       d0 0b		      bne	iSliceSet
    452  1129		       ee f6 1e 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  112c		       a9 01		      lda	#1
    454  112e		       8d f3 1e 	      sta	taskCurrentCycles
    455  1131		       8d f4 1e 	      sta	taskCurrentCycles+1
    456  1134				   iSliceSet
    457  1134		       4c bb 02 	      jmp	NextIL
    458  1137							;================================================================
    459  1137							; Find an empty slot in the taskTable
    460  1137							; Return the index in y
    461  1137							; on exit   c set if an empty slot is found
    462  1137							;	     c clear if not found
    463  1137							;================================================================
    464  1137							;
    465  1137		       ad f7 1e    TaskEmpty  lda	taskCounter
    466  113a		       c9 0a		      cmp	#TASKCOUNT
    467  113c		       b0 10		      bcs	TaskNoSlot
    468  113e		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  1140				   TaskLoop
    470  1140		       b9 f9 1d 	      lda	taskTable,y
    471  1143		       f0 0b		      beq	TaskEmptyFnd
    472  1145		       98		      tya
    473  1146		       18		      clc
    474  1147		       69 19		      adc	#CONTEXTLEN+1
    475  1149		       a8		      tay
    476  114a		       c0 fa		      cpy	#TASKTABLELEN
    477  114c		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  114e				   TaskNoSlot
    479  114e		       18		      clc
    480  114f		       60		      rts
    481  1150				   TaskEmptyFnd
    482  1150		       38		      sec
    483  1151		       60		      rts
    484  1152							;====================================================
    485  1152							; Set the task exit code called from the return command
    486  1152							; on entry stack top hold exit value
    487  1152				   TaskSetExitCode
    488  1152		       98		      tya
    489  1153		       48		      pha
    490  1154		       20 05 15 	      jsr	popR0
    491  1157		       a0 19		      ldy	#TASKEXITCODE
    492  1159		       a5 52		      lda	R0
    493  115b		       91 41		      sta	(VARIABLES),y
    494  115d		       c8		      iny
    495  115e		       a5 53		      lda	R0+1
    496  1160		       91 41		      sta	(VARIABLES),y
    497  1162		       68		      pla
    498  1163		       98		      tya
    499  1164		       60		      rts
    500  1165
    501  1165							;
    502  1165							;=====================================================
    503  1165							; Save Context Store the context to the TASK Table
    504  1165							; on entry y contains the task table entry to save to
    505  1165							; on exit y points to next task table entry
    506  1165							;	   x contains the number of bytes copied
    507  1165		       a2 00	   ContextSave ldx	#0
    508  1167		       c8		      iny		;inc past the task flags
    509  1168		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  116a		       99 f9 1d 	      sta	taskTable,y
    511  116d		       c8		      iny
    512  116e		       e8		      inx
    513  116f		       e0 18		      cpx	#CONTEXTLEN
    514  1171		       90 f5		      bcc	ContextSvLoop
    515  1173		       60		      rts
    516  1174							;
    517  1174							; Load Context transfer context from task table to the Current Context
    518  1174							; on entry y contains the task table entry to transfer
    519  1174							; on exit y points to the original task table entry
    520  1174							;	   x contains the number of byts copied
    521  1174		       98	   ContextLoad tya
    522  1175		       48		      pha
    523  1176		       a2 00		      ldx	#0
    524  1178		       c8		      iny		;inc past the task flags
    525  1179		       b9 f9 1d    ContextLDLoop lda	taskTable,y
    526  117c		       95 41		      sta	CONTEXT,x
    527  117e		       c8		      iny
    528  117f		       e8		      inx
    529  1180		       e0 18		      cpx	#CONTEXTLEN
    530  1182		       90 f5		      bcc	ContextLDLoop
    531  1184		       68		      pla
    532  1185		       a8		      tay
    533  1186		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  1187					      include	"ipc.asm"
      1  1187							;======================================================
      2  1187							; Inter process communications.
      3  1187							; Tasks may write/read integer messages among
      4  1187							; them selves.
      5  1187							; This uses each tasks gosub stack as a message queue
      6  1187							; Gosub calls start at the highest address and the
      7  1187							; msg queue starts at the highest address.
      8  1187							;
      9  1187							;======================================================
     10  1187							; ipcs   - Send msg to another task or many tasks
     11  1187							; on entry  math stack contains the  top PID
     12  1187							;				      2ND Message value
     13  1187							; on exit   math stack contain top True-good or False-failed
     14  1187							;
     15  1187							; it may not be sent if queue is full
     16  1187							;
     17  1187							; a = ipcs(<message-expression>,<task PID-expression>)
     18  1187							;
     19  1187				   iIPCS
     20  1187		       98		      tya
     21  1188		       48		      pha
     22  1189		       20 f0 11 	      jsr	ipc_enqueue
     23  118c		       b0 08		      bcs	iIPC_BAD
     24  118e		       20 71 17 	      jsr	pushTrue
     25  1191		       68		      pla
     26  1192		       a8		      tay
     27  1193		       4c bb 02 	      jmp	NextIL
     28  1196				   iIPC_BAD
     29  1196		       68		      pla
     30  1197		       a8		      tay
     31  1198		       20 7b 17 	      jsr	pushFalse
     32  119b		       4c bb 02 	      jmp	NextIL
     33  119e
     34  119e							;======================================================
     35  119e							; ipcr   - Recieve msg from task
     36  119e							; on exit  the message value is returned from message queue
     37  119e							;	    message -1	is reserved meaning no entry found
     38  119e							; The provided variable contains the pid of the sending
     39  119e							; task. This is optional. This always waits for a message
     40  119e							; before returning.
     41  119e							;
     42  119e							; a = ipcr(<variable name>)
     43  119e							;
     44  119e				   iIPCR
     45  119e		       98		      tya
     46  119f		       48		      pha
     47  11a0		       20 32 12 	      jsr	ipc_dequeue
     48  11a3		       b0 05		      bcs	iIPCR_Q_Empty
     49  11a5		       68		      pla
     50  11a6		       a8		      tay
     51  11a7		       4c bb 02 	      jmp	NextIL
     52  11aa				   iIPCR_Q_Empty
     53  11aa		       68		      pla
     54  11ab		       a8		      tay
     55  11ac		       20 71 17 	      jsr	pushTrue	; puts -1 on the stack
     56  11af		       4c bb 02 	      jmp	NextIL
     57  11b2
     58  11b2							;=======================================================
     59  11b2							; ipcc   - Check if message available
     60  11b2							; on exit  Stack contains number of messages
     61  11b2							;
     62  11b2							; a = ipcc()
     63  11b2							;
     64  11b2				   iIPCC
     65  11b2		       98		      tya
     66  11b3		       48		      pha
     67  11b4		       20 dd 11 	      jsr	ipc_queue_count
     68  11b7		       20 81 14 	      jsr	pushR0	; return the count
     69  11ba		       68		      pla
     70  11bb		       a8		      tay
     71  11bc		       4c bb 02 	      jmp	NextIL
     72  11bf
     73  11bf							;=======================================================
     74  11bf							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  11bf				   iIPCIO
     76  11bf		       98		      tya
     77  11c0		       48		      pha
     78  11c1		       20 dd 11 	      jsr	ipc_queue_count
     79  11c4		       a5 52		      lda	R0
     80  11c6		       d0 10		      bne	iIPCIO_No_Halt
     81  11c8		       a9 01		      lda	#1
     82  11ca		       8d f3 1e 	      sta	taskCurrentCycles	; force a task switch
     83  11cd		       a9 01		      lda	#TASKWAITIPC
     84  11cf		       ac f8 1d 	      ldy	taskPtr
     85  11d2		       19 f9 1d 	      ora	taskTable,y
     86  11d5		       99 f9 1d 	      sta	taskTable,y
     87  11d8
     88  11d8				   iIPCIO_No_Halt
     89  11d8		       68		      pla
     90  11d9		       a8		      tay
     91  11da		       4c bb 02 	      jmp	NextIL
     92  11dd							;======================================================
     93  11dd							;ipc_queue_count
     94  11dd				   ipc_queue_count
     95  11dd		       a5 4e		      lda	MESSAGEPTR
     96  11df		       18		      clc
     97  11e0		       4a		      lsr		; divide by 4
     98  11e1		       4a		      lsr
     99  11e2		       85 52		      sta	R0	; store into R0
    100  11e4		       a9 10		      lda	#GOSUBSTACKSIZE
    101  11e6		       38		      sec
    102  11e7		       e5 52		      sbc	R0	; Get how many entries on queue
    103  11e9		       85 52		      sta	R0
    104  11eb		       a9 00		      lda	#0
    105  11ed		       85 53		      sta	R0+1
    106  11ef		       60		      rts
    107  11f0							;=======================================================
    108  11f0							; Support functions for messaging
    109  11f0							;
    110  11f0							; Enqueue message -> onto PID's MSG Q
    111  11f0							; on entry top of stack contains the PID
    112  11f0							;	    second contains the Message of the task
    113  11f0							; on exit contains c set if failed
    114  11f0							;		    c cleared if success
    115  11f0							;		    PID's MSG Q PTR points to the message
    116  11f0							;
    117  11f0				   ipc_enqueue
    118  11f0		       20 1d 15 	      jsr	popR1	; Get the pid
    119  11f3		       20 6b 12 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  11f6
    121  11f6		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  11f8		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  11fa		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  11fc		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  11fe		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1200
    127  1200
    128  1200							; Get the PID'S stack address into R0
    129  1200		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1202		       b1 56		      lda	(MQ),y
    131  1204		       85 52		      sta	R0
    132  1206		       c8		      iny
    133  1207		       b1 56		      lda	(MQ),y
    134  1209		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  120b
    136  120b							; Set y to point to the msg q entry
    137  120b		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  120d		       b1 56		      lda	(MQ),y	; Get the index
    139  120f		       a8		      tay		; Set y to queue offset
    140  1210
    141  1210							; enqueue the message
    142  1210		       88		      dey		; First byte to save to
    143  1211		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1213		       91 52		      sta	(R0),y	; Set the entry type
    145  1215
    146  1215		       88		      dey
    147  1216		       ad f8 1d 	      lda	taskPtr	; Store the PID into queue
    148  1219		       91 52		      sta	(R0),y
    149  121b		       20 1d 15 	      jsr	popR1	; Get the actual message value
    150  121e		       20 79 12 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1221
    152  1221		       98		      tya		; Save the new q ptr
    153  1222		       a0 0e		      ldy	#MSGPTRPOS
    154  1224		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1226		       a0 00		      ldy	#0	; points to context root
    156  1228		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  122a		       51 56		      eor	(MQ),y	; Turn off the bit
    158  122c		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  122e		       18		      clc
    160  122f		       60		      rts
    161  1230				   ipc_enq_full
    162  1230		       38		      sec
    163  1231		       60		      rts
    164  1232							;=============================================================
    165  1232							; De-queue for message stack -> local tasks msg q
    166  1232							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1232							;  message into
    168  1232							;  on exit   math stack contains value of message
    169  1232							;				  Variable if provided is pid
    170  1232				   ipc_dequeue
    171  1232		       20 34 15 	      jsr	popMQ	; Variable address to put PID into
    172  1235
    173  1235		       a4 4e		      ldy	MESSAGEPTR
    174  1237		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1239		       b0 2e		      bcs	ipc_deq_empty
    176  123b		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  123d		       85 52		      sta	R0
    178  123f		       c8		      iny
    179  1240		       b1 4b		      lda	(GOSUBSTACK),y
    180  1242		       85 53		      sta	R0+1
    181  1244		       c8		      iny
    182  1245		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1247		       85 54		      sta	R1
    184  1249		       c8		      iny
    185  124a		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  124c		       c8		      iny
    187  124d		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  124f
    189  124f		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1251		       d0 16		      bne	ipc_deq_empty
    191  1253
    192  1253		       20 81 14 	      jsr	pushR0	; place value on stack
    193  1256
    194  1256		       a5 56		      lda	MQ
    195  1258		       05 57		      ora	MQ+1
    196  125a		       f0 0b		      beq	ipc_deq_done
    197  125c		       a5 54		      lda	R1
    198  125e		       a0 00		      ldy	#0
    199  1260		       91 56		      sta	(MQ),y
    200  1262		       c8		      iny
    201  1263		       a9 00		      lda	#0
    202  1265		       91 56		      sta	(MQ),y
    203  1267				   ipc_deq_done
    204  1267		       18		      clc
    205  1268		       60		      rts
    206  1269
    207  1269				   ipc_deq_empty
    208  1269		       38		      sec
    209  126a		       60		      rts
    210  126b
    211  126b							;=============================================
    212  126b							;  Get the context address into MQ from R1 with
    213  126b							;  context/index/pid
    214  126b				   ipc_getcontext
    215  126b		       18		      clc		; Get pointer to Task context
    216  126c		       a9 f9		      lda	#taskTable&$FF	; change ptr to address
    217  126e		       65 54		      adc	R1
    218  1270		       85 56		      sta	MQ
    219  1272		       a9 1d		      lda	#taskTable>>8
    220  1274		       65 55		      adc	R1+1
    221  1276		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1278		       60		      rts
    223  1279							;
    224  1279							;==============================================
    225  1279							;Push R1 onto the stack
    226  1279							;on entry y = next entry
    227  1279							;R0 points to the stack space
    228  1279							;on exit y points to next free byte
    229  1279				   ipc_pushR1
    230  1279		       88		      dey
    231  127a		       a5 55		      lda	R1+1	; PID first
    232  127c		       91 52		      sta	(R0),y
    233  127e		       88		      dey
    234  127f		       a5 54		      lda	R1
    235  1281		       91 52		      sta	(R0),y
    236  1283		       60		      rts
    237  1284
    238  1284
    239  1284
    240  1284
    241  1284
    242  1284
    243  1284
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1284					      include	"support.asm"
      1  1284							;
      2  1284							;=====================================================
      3  1284							;=====================================================
      4  1284							;=====================================================
      5  1284							; This marks the start of support functions used by
      6  1284							; the IL opcodes.  These are support functions, NOT
      7  1284							; the IL code.
      8  1284							;=====================================================
      9  1284							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1284							;=====================================================
     11  1284					      Seg	Code
     12  1284							;=====================================================
     13  1284							; This gets the next two bytes pointed to by ILPC and
     14  1284							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1284							; is advanced by two, and Y contains 0 on return.
     16  1284
     17  1284							;
     18  1284		       20 88 12    getILWord  jsr	getILByte	;LSB
     19  1287		       aa		      tax
     20  1288							;
     21  1288							;=====================================================
     22  1288							; This gets the next byte pointed to by ILPC and
     23  1288							; returns it in A.  On return, X is unchanged but Y
     24  1288							; contains 0.
     25  1288							;
     26  1288		       a0 00	   getILByte  ldy	#0
     27  128a		       b1 43		      lda	(ILPC),y	;get byte
     28  128c		       08		      php		;save status
     29  128d		       e6 43		      inc	ILPC	;inc LSB
     30  128f		       d0 02		      bne	getILb2	;branch if no overflow
     31  1291		       e6 44		      inc	ILPC+1	;inc MSB
     32  1293		       28	   getILb2    plp		;restore status
     33  1294		       60		      rts
     34  1295							;
     35  1295							;=====================================================
     36  1295							; Decrement ILPC by one.
     37  1295							;
     38  1295		       a5 43	   decIL      lda	ILPC
     39  1297		       d0 02		      bne	decIL2
     40  1299		       c6 44		      dec	ILPC+1
     41  129b		       c6 43	   decIL2     dec	ILPC
     42  129d		       60		      rts
     43  129e							;
     44  129e							;=====================================================
     45  129e							; Push the ILPC onto the return stack.  Actually, this
     46  129e							; pushes the address of ILPC+2 since that's the next
     47  129e							; address to execute.
     48  129e							;
     49  129e		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  12a0		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  12a2		       b0 15		      bcs	pushErr
     52  12a4		       a5 43		      lda	ILPC
     53  12a6		       18		      clc
     54  12a7		       69 02		      adc	#2
     55  12a9		       91 45		      sta	(ILSTACK),y
     56  12ab		       08		      php		;save C bit
     57  12ac		       c8		      iny
     58  12ad		       a5 44		      lda	ILPC+1
     59  12af		       28		      plp		;restore C
     60  12b0		       69 00		      adc	#0
     61  12b2		       91 45		      sta	(ILSTACK),y
     62  12b4		       c8		      iny
     63  12b5		       84 47		      sty	ILSTACKPTR
     64  12b7		       18		      clc
     65  12b8		       60		      rts
     66  12b9				   pushErr
     67  12b9		       38		      sec
     68  12ba		       60		      rts
     69  12bb							;
     70  12bb							;=====================================================
     71  12bb							; Pull the top entry from return stack and put into
     72  12bb							; ILPC.
     73  12bb							;
     74  12bb		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  12bd		       f0 fa		      beq	pushErr
     76  12bf		       88		      dey
     77  12c0		       b1 45		      lda	(ILSTACK),y
     78  12c2		       85 44		      sta	ILPC+1
     79  12c4		       88		      dey
     80  12c5		       b1 45		      lda	(ILSTACK),y
     81  12c7		       85 43		      sta	ILPC
     82  12c9		       84 47		      sty	ILSTACKPTR
     83  12cb		       18		      clc
     84  12cc		       60		      rts
     85  12cd							;
     86  12cd							;=====================================================
     87  12cd							; This searches for a specific line number that is in
     88  12cd							; R0.	There are three possible return conditions:
     89  12cd							; Line numbers are now the third byte, the first byte is now **************
     90  12cd							; a pointer to the next line, of course no longer that 254 bytes
     91  12cd							; per line.
     92  12cd							;
     93  12cd							; Exact match was found:
     94  12cd							;    * Z set
     95  12cd							;    * CURPTR points to two-byte line number for that
     96  12cd							;	line.
     97  12cd							;
     98  12cd							; Next highest line found:
     99  12cd							;    * Z cleared
    100  12cd							;    * C set
    101  12cd							;    * CURPTR points to two-byte line number for that
    102  12cd							;	line.
    103  12cd							;
    104  12cd							; End of program reached:
    105  12cd							;    * Z cleared
    106  12cd							;    * C cleared
    107  12cd							;    * CURPTR points to first free byte at end of
    108  12cd							;	program.  Ie, it has save value as PROGRAMEND.
    109  12cd							;
    110  12cd							; A, X, and Y are all undefined on return.
    111  12cd							;
    112  12cd
    113  12cd				   findLine
    114  12cd		       ad 51 27 	      lda	ProgramStart	;Start of program -> CURPTR
    115  12d0		       85 4f		      sta	CURPTR
    116  12d2		       ad 52 27 	      lda	ProgramStart+1
    117  12d5		       85 50		      sta	CURPTR+1
    118  12d7							;
    119  12d7							; At end of code?
    120  12d7							;
    121  12d7				   iXFER1
    122  12d7		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  12d9		       cd 53 27 	      cmp	ProgramEnd	; at end of program then stop run
    124  12dc		       d0 0b		      bne	xfer2	; not end
    125  12de		       a5 50		      lda	CURPTR+1
    126  12e0		       cd 54 27 	      cmp	ProgramEnd+1
    127  12e3		       d0 04		      bne	xfer2	;Not at end
    128  12e5							;
    129  12e5							; Line not found and the end of the program was
    130  12e5							; reached.  Return Z and C both clear.
    131  12e5							;
    132  12e5		       a9 01		      lda	#1	;clear Z
    133  12e7		       18		      clc		;clear C
    134  12e8		       60		      rts
    135  12e9							;
    136  12e9							; Check for an exact line number match
    137  12e9							;
    138  12e9		       a5 52	   xfer2      lda	R0
    139  12eb		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  12ed		       d1 4f		      cmp	(CURPTR),y
    141  12ef		       d0 08		      bne	xfernotit
    142  12f1		       c8		      iny
    143  12f2		       a5 53		      lda	R0+1
    144  12f4		       d1 4f		      cmp	(CURPTR),y
    145  12f6		       d0 01		      bne	xfernotit	; not a matching line number
    146  12f8							;
    147  12f8							; This is exactly the line we want.
    148  12f8							;
    149  12f8		       60		      rts		;it matches exactly
    150  12f9							;
    151  12f9							; See if this line is greater than the one we're
    152  12f9							; searching for.
    153  12f9							;
    154  12f9		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  12fb		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  12fd		       c5 53		      cmp	R0+1
    157  12ff		       90 0b		      bcc	xfer3
    158  1301		       d0 07		      bne	xfer4
    159  1303		       88		      dey
    160  1304		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1306		       c5 52		      cmp	R0
    162  1308		       90 02		      bcc	xfer3
    163  130a							;
    164  130a							; This line is greater than the one we want, so
    165  130a							; return Z clear and C set.
    166  130a							;
    167  130a		       38	   xfer4      sec		;We found a line number greater
    168  130b		       60		      rts		;both conditions set
    169  130c							;
    170  130c							; Not the line (or droid) we're looking for.  Move to
    171  130c							; the next line.
    172  130c							;
    173  130c		       20 12 13    xfer3      jsr	FindNextLine
    174  130f		       4c d7 12 	      jmp	iXFER1
    175  1312							;
    176  1312							;=====================================================
    177  1312							; This advances CURPTR to the next line.  If there
    178  1312							; are no more lines, this leaves CURPTR equal to
    179  1312							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1312							; CURPTR is pointing to a valid line on entry.  This
    181  1312							; pointer points to the two-byte line number.
    182  1312							; Update this points to the 1 byte line length  ****************
    183  1312							;
    184  1312				   FindNextLine
    185  1312		       a0 03		      ldy	#3	;skip line number and length byte
    186  1314		       84 51		      sty	CUROFF	;this is the new offset
    187  1316		       a0 00		      ldy	#0
    188  1318		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  131a		       18		      clc
    190  131b		       65 4f		      adc	CURPTR
    191  131d		       85 4f		      sta	CURPTR
    192  131f		       a5 50		      lda	CURPTR+1
    193  1321		       69 00		      adc	#0
    194  1323		       85 50		      sta	CURPTR+1
    195  1325		       60	   FindNext4  rts
    196  1326							;
    197  1326							;=====================================================
    198  1326							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1326							; if they are equal, Z clear if not.
    200  1326							;
    201  1326		       a5 4f	   AtEnd      lda	CURPTR
    202  1328		       cd 53 27 	      cmp	ProgramEnd
    203  132b		       d0 05		      bne	atendexit
    204  132d		       a5 50		      lda	CURPTR+1
    205  132f		       cd 54 27 	      cmp	ProgramEnd+1
    206  1332		       60	   atendexit  rts
    207  1333							;
    208  1333
    209  1333							;
    210  1333							;=====================================================
    211  1333							; Convert an ASCII string to a number.  On input,
    212  1333							; (CURPTR),Y points to the first digit.  This gets
    213  1333							; digit-by-digit until finding a non-number.  Returns
    214  1333							; Y pointing to the non-digit, and R0 contains the
    215  1333							; number.  This does NOT check for valid ranges, so
    216  1333							; a value like "123456789" will produce something,
    217  1333							; but not what you had expected.
    218  1333							;
    219  1333		       a9 00	   getDecimal lda	#0
    220  1335		       85 52		      sta	R0
    221  1337		       85 53		      sta	R0+1
    222  1339		       85 59		      sta	dpl	;temporary negative flag
    223  133b							;
    224  133b							; See if it's negative...
    225  133b							;
    226  133b							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  133b		       b1 4f		      lda	(CURPTR),y
    228  133d		       c9 2d		      cmp	#'-
    229  133f		       d0 02		      bne	getDecLoop
    230  1341		       e6 59		      inc	dpl	;it's negative
    231  1343							;
    232  1343		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1345		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1347		       c9 30		      cmp	#'0
    235  1349		       90 36		      bcc	getDdone
    236  134b		       c9 3a		      cmp	#'9+1
    237  134d		       b0 32		      bcs	getDdone
    238  134f		       38		      sec
    239  1350		       e9 30		      sbc	#'0	;convert to binary
    240  1352		       48		      pha
    241  1353							;
    242  1353							; Now multiply R0 by 10.  Remember that
    243  1353							; 2*N + 8*N = 10*N.
    244  1353							;
    245  1353		       06 52		      asl	R0
    246  1355		       26 53		      rol	R0+1	;*2
    247  1357		       a5 52		      lda	R0
    248  1359		       85 54		      sta	R1
    249  135b		       a5 53		      lda	R0+1
    250  135d		       85 55		      sta	R1+1
    251  135f		       06 52		      asl	R0
    252  1361		       26 53		      rol	R0+1	;*4
    253  1363		       06 52		      asl	R0
    254  1365		       26 53		      rol	R0+1	;*8
    255  1367		       18		      clc		;now add the partial sums...
    256  1368		       a5 52		      lda	R0	;...to get *10
    257  136a		       65 54		      adc	R1
    258  136c		       85 52		      sta	R0
    259  136e		       a5 53		      lda	R0+1
    260  1370		       65 55		      adc	R1+1
    261  1372		       85 53		      sta	R0+1
    262  1374							;
    263  1374							; Add in the new digit
    264  1374							;
    265  1374		       68		      pla
    266  1375		       18		      clc
    267  1376		       65 52		      adc	R0
    268  1378		       85 52		      sta	R0
    269  137a		       90 02		      bcc	getD2
    270  137c		       e6 53		      inc	R0+1
    271  137e							;
    272  137e							; Move to next character
    273  137e							;
    274  137e		       c8	   getD2      iny
    275  137f		       d0 c2		      bne	getDecLoop
    276  1381							;
    277  1381							; All done with digits, so now deal with it being
    278  1381							; negative.  If zero, then don't check for negative
    279  1381							; flag.  Ie, -0 is stored as 0.
    280  1381							;
    281  1381		       a5 52	   getDdone   lda	R0
    282  1383		       05 53		      ora	R0+1
    283  1385		       f0 16		      beq	getDone2	;zero
    284  1387		       a5 59		      lda	dpl
    285  1389		       f0 12		      beq	getDone2	;positive
    286  138b							;
    287  138b							; Invert all the bits, then add one.
    288  138b							;
    289  138b		       a5 52		      lda	R0
    290  138d		       49 ff		      eor	#$ff
    291  138f		       85 52		      sta	R0
    292  1391		       a5 53		      lda	R0+1
    293  1393		       49 ff		      eor	#$ff
    294  1395		       85 53		      sta	R0+1
    295  1397							;
    296  1397		       e6 52		      inc	R0
    297  1399		       d0 02		      bne	getDone2
    298  139b		       e6 53		      inc	R0+1
    299  139d				   getDone2
    300  139d							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  139d							;lda	  R0
    302  139d							;sta	  $0010
    303  139d							;lda	  R0+1
    304  139d							;sta	  $0011
    305  139d							;lda	  dpl
    306  139d							;sta	  $012
    307  139d
    308  139d		       60		      rts
    309  139e
    310  139e							;=====================================================
    311  139e							; Gets a line of input into LINBUF.
    312  139e							;
    313  139e							; On entry:
    314  139e							;    A contains the prompt character, or 0 if none.
    315  139e							;    X = 1 Background read
    316  139e							;    x = 0 Forground read with wait
    317  139e							;
    318  139e							; On exit:
    319  139e							;    CURPTR points to LINBUF
    320  139e							;    LINBUF contains the line with 0 at the end.
    321  139e							;    Y has offset to first non-space character
    322  139e							;    CURROFF has the same as Y.
    323  139e							;
    324  139e		       20 ed 13    GetLine    jsr	ReadPrompt
    325  13a1		       e0 00		      cpx	#0
    326  13a3		       f0 14		      beq	GetLineRetry
    327  13a5		       ae f8 1d 	      ldx	taskPtr
    328  13a8		       bd f9 1d 	      lda	taskTable,x
    329  13ab		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  13ad		       d0 3d		      bne	taskWaitingIO
    331  13af		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  13b1		       9d f9 1d 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  13b4		       ce ec 13 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  13b7		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  13b9
    336  13b9							;
    337  13b9							; Now read a line and wait for the CR
    338  13b9							;
    339  13b9				   GetLineRetry
    340  13b9		       a9 00		      lda	#0	;Wait for input to complete
    341  13bb		       20 05 14 	      jsr	ReadLine
    342  13be
    343  13be							;
    344  13be							; Point to the line we just read
    345  13be							; Set the current pointer to point to the input line
    346  13be							;
    347  13be		       a0 00	   ReadComplete ldy	#0
    348  13c0		       84 51		      sty	CUROFF
    349  13c2		       a2 b4		      ldx	#LINBUF&$ff
    350  13c4		       86 4f		      stx	CURPTR
    351  13c6		       a2 26		      ldx	#LINBUF>>8
    352  13c8		       86 50		      stx	CURPTR+1
    353  13ca							;
    354  13ca							; Output a CR/LF
    355  13ca							;
    356  13ca		       20 be 15 	      jsr	CRLF
    357  13cd							;
    358  13cd							; If a blank line, prompt again.
    359  13cd							;
    360  13cd		       20 b5 15 	      jsr	SkipSpaces
    361  13d0		       b1 4f		      lda	(CURPTR),y
    362  13d2		       d0 10		      bne	GetLineDone	;We have data then exit
    363  13d4		       20 f0 13 	      jsr	ReadPromptRetry
    364  13d7		       ae f8 1d 	      ldx	taskPtr	;if this task is waiting for IO
    365  13da		       bd f9 1d 	      lda	taskTable,x	;then get out, wait for line to
    366  13dd		       29 40		      and	#TASKWAITIO	;Complete again
    367  13df		       d0 0b		      bne	taskWaitingIO
    368  13e1		       4c b9 13 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  13e4
    370  13e4				   GetLineDone
    371  13e4		       ae f8 1d 	      ldx	taskPtr
    372  13e7		       a9 80		      lda	#TASKACTIVE
    373  13e9		       9d f9 1d 	      sta	taskTable,x	;IO is complete
    374  13ec
    375  13ec				   taskWaitingIO
    376  13ec		       60		      rts
    377  13ed
    378  13ed							;
    379  13ed							;=======================================================================
    380  13ed							; Display the prompt character
    381  13ed							; On entry
    382  13ed							;	    A contains the prompt character
    383  13ed							; On exit
    384  13ed							;	    The readbuffer index is reset to 0
    385  13ed							;
    386  13ed		       8d 3b 27    ReadPrompt sta	promptChar
    387  13f0
    388  13f0							;
    389  13f0							; Prompt
    390  13f0							;
    391  13f0
    392  13f0		       ad 3b 27    ReadPromptRetry lda	promptChar
    393  13f3		       09 00		      ora	#0	;any prompt?
    394  13f5		       f0 08		      beq	getlinenp
    395  13f7		       20 07 17 	      jsr	VOUTCH
    396  13fa		       a9 20		      lda	#$20
    397  13fc		       20 07 17 	      jsr	VOUTCH	;Space after prompt
    398  13ff							;
    399  13ff		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1401		       8e 38 27 	      stx	getlinx
    401  1404		       60		      rts
    402  1405							;
    403  1405							;===============================================================
    404  1405							; This fuction is the driver for the line input
    405  1405							; on call if a = 0 then it waits for all input
    406  1405							;	      a = 1 then nowait for input
    407  1405							; On exit
    408  1405							;		       c clear if not complete line
    409  1405							;		       c set if it was a complete line
    410  1405
    411  1405				   ReadLine
    412  1405		       8d 3a 27 	      sta	inputNoWait
    413  1408		       c9 00		      cmp	#0
    414  140a		       f0 05		      beq	getline1
    415  140c		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  140f		       f0 2b		      beq	GetLineNoWait
    417  1411		       20 0a 17    getline1   jsr	VGETCH
    418  1414					      if	CTMON65
    419  1414		       48		      pha
    420  1415		       20 07 17 	      jsr	VOUTCH	;echo echo echo
    421  1418		       68		      pla
    422  1419					      endif
    423  1419		       c9 0d		      cmp	#CR
    424  141b		       f0 15		      beq	getlind	;end of line
    425  141d		       c9 08		      cmp	#BS	;backspace?
    426  141f		       f0 1d		      beq	getlinebs
    427  1421		       ae 38 27 	      ldx	getlinx
    428  1424		       9d b4 26 	      sta	LINBUF,x
    429  1427		       e8		      inx
    430  1428		       8e 38 27 	      stx	getlinx
    431  142b		       ad 3a 27 	      lda	inputNoWait
    432  142e		       f0 e1		      beq	getline1
    433  1430		       d0 0a		      bne	GetLineNoWait
    434  1432							;
    435  1432							; CR was hit
    436  1432							;
    437  1432		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1434		       ae 38 27 	      ldx	getlinx
    439  1437		       9d b4 26 	      sta	LINBUF,x
    440  143a
    441  143a		       38		      sec		; Carry set then cr received
    442  143b		       60		      rts
    443  143c
    444  143c				   GetLineNoWait
    445  143c		       18		      clc		; Carry clear no end of line
    446  143d		       60		      rts
    447  143e							;
    448  143e							; Backspace was hit
    449  143e							;
    450  143e		       ae 38 27    getlinebs  ldx	getlinx
    451  1441		       f0 0e		      beq	getlineEOL	;at start of line
    452  1443		       ca		      dex
    453  1444		       8e 38 27 	      stx	getlinx
    454  1447		       20 0d 17    getlinepbs jsr	puts
      0  144a					      db	27,"[K",0
      1  144a		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  144e		       4c 11 14 	      jmp	getline1
    457  1451		       a9 20	   getlineEOL lda	#SPACE
    458  1453		       20 07 17 	      jsr	VOUTCH
    459  1456		       d0 ef		      bne	getlinepbs
    460  1458							;
    461  1458							;=====================================================
    462  1458							; Count the length of the line currently in LINBUF
    463  1458							; starting at offset Y.  Returns the length in X.  The
    464  1458							; starting offset in Y should point past the ASCII
    465  1458							; line number.  Also counts the trailing NULL and two
    466  1458							; extra bytes for where the line number will be.
    467  1458							; Update must now include leading length byte not the null at end ****************
    468  1458							;
    469  1458				   getLineLength
    470  1458		       a2 00		      ldx	#0	;size
    471  145a		       b9 b4 26    getLineL2  lda	LINBUF,y
    472  145d		       f0 04		      beq	getLineL3
    473  145f		       c8		      iny
    474  1460		       e8		      inx
    475  1461		       d0 f7		      bne	getLineL2
    476  1463		       e8	   getLineL3  inx		;count null at end
    477  1464		       e8		      inx		;line number LSB
    478  1465		       e8		      inx		;MSB
    479  1466		       e8		      inx		;change: count new leading line length
    480  1467		       8e 4e 27 	      stx	lineLength
    481  146a		       60		      rts
    482  146b							;
    483  146b							;=====================================================
    484  146b							; Count the length of the line pointed to by CURPTR.
    485  146b							; This also counts the line number and the terminating
    486  146b							; null.  Ie, this string returns 8:
    487  146b							;
    488  146b							; <lineLow><lineHi>Hello<null>
    489  146b							;
    490  146b							; Another way of looking at it: add the return value
    491  146b							; to the CURPTR and it'll point to the next line's
    492  146b							; line number.  Returns the value in Y.
    493  146b							; Update to ject get the leading byte length ********************
    494  146b							;
    495  146b							;getCURPTRLength
    496  146b							;		ldy	CURPTR
    497  146b							;		ldy	#3	;change: skip line number and leading length byte
    498  146b							;getCLineL2	lda	(CURPTR),y
    499  146b							;		beq	getCLineL3
    500  146b							;		iny
    501  146b							;		bne	getCLineL2
    502  146b							;getCLineL3	iny		;count null at end
    503  146b							;		rts
    504  146b
    505  146b							;
    506  146b							;=====================================================
    507  146b							; This saves ILPC.  This saves to a single save area,
    508  146b							; so it can't be called more than once.
    509  146b							;
    510  146b		       a5 43	   saveIL     lda	ILPC
    511  146d		       8d 4a 27 	      sta	tempIL
    512  1470		       a5 44		      lda	ILPC+1
    513  1472		       8d 4b 27 	      sta	tempIL+1
    514  1475		       60		      rts
    515  1476							;
    516  1476							;=====================================================
    517  1476							; This restores ILPC.
    518  1476							;
    519  1476		       ad 4a 27    restoreIL  lda	tempIL
    520  1479		       85 43		      sta	ILPC
    521  147b		       ad 4b 27 	      lda	tempIL+1
    522  147e		       85 44		      sta	ILPC+1
    523  1480		       60		      rts
    524  1481							;
    525  1481							;=====================================================
    526  1481							; This pushes R0 onto the stack.
    527  1481							;
    528  1481		       8c 41 27    pushR0     sty	rtemp1
    529  1484		       a4 4a		      ldy	MATHSTACKPTR
    530  1486		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1488		       b0 34		      bcs	pusherr
    532  148a		       a5 52		      lda	R0
    533  148c		       91 48		      sta	(MATHSTACK),y
    534  148e		       c8		      iny
    535  148f		       a5 53		      lda	R0+1
    536  1491		       91 48		      sta	(MATHSTACK),y
    537  1493		       c8		      iny
    538  1494		       84 4a		      sty	MATHSTACKPTR
    539  1496		       ac 41 27 	      ldy	rtemp1
    540  1499		       18		      clc
    541  149a		       60		      rts
    542  149b
    543  149b							;=====================================================
    544  149b							; This pushes curptr basic current line onto the call stack.
    545  149b							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  149b
    547  149b				   pushLN
    548  149b		       8c 41 27 	      sty	rtemp1
    549  149e		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  14a0		       c5 4d		      cmp	GOSUBSTACKPTR
    551  14a2		       90 1a		      bcc	pusherr	; No error
    552  14a4		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  14a6		       a2 00		      ldx	#0	; Start of bytes to copy
    554  14a8				   pushLoop
    555  14a8		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  14aa		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  14ac		       c8		      iny		; Next destination
    558  14ad		       e8		      inx		; Next Source byte
    559  14ae		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  14b0		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  14b2
    562  14b2		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  14b4		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  14b6		       c8		      iny		; Next entry
    565  14b7
    566  14b7		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  14b9		       ac 41 27 	      ldy	rtemp1
    568  14bc		       18		      clc
    569  14bd		       60		      rts
    570  14be				   pusherr
    571  14be		       38		      sec
    572  14bf		       60		      rts
    573  14c0							;=====================================================
    574  14c0							; This pops Top Off gosub call Stack and
    575  14c0							; places it in CURPTR/CUROFF.
    576  14c0							; This checks if the type = 1 GOSUB
    577  14c0							; if not it removes what ever is on the stack
    578  14c0							; until it finds the next return. Allowing
    579  14c0							; a return from within a for/next
    580  14c0		       8c 41 27    popLN      sty	rtemp1
    581  14c3		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  14c5		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  14c7
    584  14c7				   popContinue
    585  14c7		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  14c9		       90 18		      bcc	poperr	; Process an error
    587  14cb
    588  14cb		       88		      dey		; Position to read entry type
    589  14cc		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  14ce		       c9 01		      cmp	#1	; Type is a gosub entry
    591  14d0		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  14d2
    593  14d2				   popLoop
    594  14d2		       88		      dey
    595  14d3		       ca		      dex
    596  14d4		       b1 4b		      lda	(GOSUBSTACK),y
    597  14d6		       95 4f		      sta	CURPTR,x
    598  14d8		       e0 00		      cpx	#0
    599  14da		       d0 f6		      bne	popLoop	; Loop until all moved
    600  14dc
    601  14dc
    602  14dc		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  14de		       ac 41 27 	      ldy	rtemp1
    604  14e1		       18		      clc
    605  14e2		       60		      rts
    606  14e3
    607  14e3		       38	   poperr     sec
    608  14e4		       60		      rts
    609  14e5
    610  14e5		       88	   popSkipEntry dey
    611  14e6		       88		      dey
    612  14e7		       88		      dey
    613  14e8		       4c c7 14 	      jmp	popContinue
    614  14eb
    615  14eb							;
    616  14eb							;=====================================================
    617  14eb							; This pushes R1 onto the stack
    618  14eb							;
    619  14eb		       8c 41 27    pushR1     sty	rtemp1
    620  14ee		       a4 4a		      ldy	MATHSTACKPTR
    621  14f0		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  14f2		       b0 ef		      bcs	poperr
    623  14f4		       a5 54		      lda	R1
    624  14f6		       91 48		      sta	(MATHSTACK),y
    625  14f8		       c8		      iny
    626  14f9		       a5 55		      lda	R1+1
    627  14fb		       91 48		      sta	(MATHSTACK),y
    628  14fd		       c8		      iny
    629  14fe		       84 4a		      sty	MATHSTACKPTR
    630  1500		       ac 41 27 	      ldy	rtemp1
    631  1503		       18		      clc
    632  1504		       60		      rts
    633  1505							;
    634  1505							;=====================================================
    635  1505							; This pops Top Of Stack and places it in R0.
    636  1505							;
    637  1505		       8c 41 27    popR0      sty	rtemp1
    638  1508		       a4 4a		      ldy	MATHSTACKPTR
    639  150a		       f0 d7		      beq	poperr
    640  150c		       88		      dey
    641  150d		       b1 48		      lda	(MATHSTACK),y
    642  150f		       85 53		      sta	R0+1
    643  1511		       88		      dey
    644  1512		       b1 48		      lda	(MATHSTACK),y
    645  1514		       85 52		      sta	R0
    646  1516		       84 4a		      sty	MATHSTACKPTR
    647  1518		       ac 41 27 	      ldy	rtemp1
    648  151b		       18		      clc
    649  151c		       60		      rts
    650  151d
    651  151d							;
    652  151d							;=====================================================
    653  151d							; This pops TOS and places it in R1.
    654  151d							;
    655  151d		       8c 41 27    popR1      sty	rtemp1
    656  1520		       a4 4a		      ldy	MATHSTACKPTR
    657  1522		       f0 bf		      beq	poperr
    658  1524		       88		      dey
    659  1525		       b1 48		      lda	(MATHSTACK),y
    660  1527		       85 55		      sta	R1+1
    661  1529		       88		      dey
    662  152a		       b1 48		      lda	(MATHSTACK),y
    663  152c		       85 54		      sta	R1
    664  152e		       84 4a		      sty	MATHSTACKPTR
    665  1530		       ac 41 27 	      ldy	rtemp1
    666  1533		       60		      rts
    667  1534							;
    668  1534							;=====================================================
    669  1534							; This pops TOS and places it in MQ.
    670  1534							;
    671  1534		       8c 41 27    popMQ      sty	rtemp1
    672  1537		       a4 4a		      ldy	MATHSTACKPTR
    673  1539		       f0 a8		      beq	poperr
    674  153b		       88		      dey
    675  153c		       b1 48		      lda	(MATHSTACK),y
    676  153e		       85 57		      sta	MQ+1
    677  1540		       88		      dey
    678  1541		       b1 48		      lda	(MATHSTACK),y
    679  1543		       85 56		      sta	MQ
    680  1545		       84 4a		      sty	MATHSTACKPTR
    681  1547		       ac 41 27 	      ldy	rtemp1
    682  154a		       60		      rts
    683  154b							;
    684  154b							;=====================================================
    685  154b							; This assists with multiplication and division by
    686  154b							; looking at R0 and R1 and saving a flag as to what
    687  154b							; sign the result will be.  Math is always done on
    688  154b							; positive numbers, so this converts negative numbers
    689  154b							; into positives.  On exit, R0 and R1 are both
    690  154b							; positive.  If the signs were different then 'signs'
    691  154b							; will be non-zero.
    692  154b							;
    693  154b		       a9 00	   SaveSigns  lda	#0
    694  154d		       8d 40 27 	      sta	sign	;assume positive
    695  1550		       a5 53		      lda	R0+1	;MSB
    696  1552		       10 13		      bpl	SaveSigns1
    697  1554		       ee 40 27 	      inc	sign	;it's negative
    698  1557		       49 ff		      eor	#$ff	;flip bits
    699  1559		       85 53		      sta	R0+1
    700  155b		       a5 52		      lda	R0
    701  155d		       49 ff		      eor	#$ff
    702  155f		       85 52		      sta	R0
    703  1561		       e6 52		      inc	R0
    704  1563		       d0 02		      bne	SaveSigns1
    705  1565		       e6 53		      inc	R0+1
    706  1567		       a5 55	   SaveSigns1 lda	R1+1
    707  1569		       10 1a		      bpl	SaveSigns2
    708  156b		       48		      pha
    709  156c		       ad 40 27 	      lda	sign
    710  156f		       49 01		      eor	#1
    711  1571		       8d 40 27 	      sta	sign
    712  1574		       68		      pla
    713  1575		       49 ff		      eor	#$ff	;flip bits
    714  1577		       85 55		      sta	R1+1
    715  1579		       a5 54		      lda	R1
    716  157b		       49 ff		      eor	#$ff
    717  157d		       85 54		      sta	R1
    718  157f		       e6 54		      inc	R1
    719  1581		       d0 02		      bne	SaveSigns2
    720  1583		       e6 55		      inc	R1+1
    721  1585		       60	   SaveSigns2 rts
    722  1586							;
    723  1586							;=====================================================
    724  1586							; This looks at the value of 'signs' and will convert
    725  1586							; both R0 and R1 to negative if set.
    726  1586							;
    727  1586				   RestoreSigns
    728  1586		       ad 40 27 	      lda	sign
    729  1589		       f0 28		      beq	restoresigns2
    730  158b							;
    731  158b		       a5 52		      lda	R0
    732  158d		       d0 02		      bne	restoresigns3
    733  158f		       c6 53		      dec	R0+1
    734  1591				   restoresigns3
    735  1591		       c6 52		      dec	R0
    736  1593		       a5 52		      lda	R0
    737  1595		       49 ff		      eor	#$ff
    738  1597		       85 52		      sta	R0
    739  1599		       a5 53		      lda	R0+1
    740  159b		       49 ff		      eor	#$ff
    741  159d		       85 53		      sta	R0+1
    742  159f							;
    743  159f		       a5 54		      lda	R1
    744  15a1		       d0 02		      bne	restoresigns4
    745  15a3		       c6 55		      dec	R1+1
    746  15a5				   restoresigns4
    747  15a5		       c6 54		      dec	R1
    748  15a7		       a5 54		      lda	R1
    749  15a9		       49 ff		      eor	#$ff
    750  15ab		       85 54		      sta	R1
    751  15ad		       a5 55		      lda	R1+1
    752  15af		       49 ff		      eor	#$ff
    753  15b1		       85 55		      sta	R1+1
    754  15b3							;
    755  15b3				   restoresigns2
    756  15b3		       60		      rts
    757  15b4							;
    758  15b4							;=====================================================
    759  15b4							; Skip over spaces.  Returns Y with the offset to
    760  15b4							; either the last character in the line, or the first
    761  15b4							; non-space character.
    762  15b4							;
    763  15b4
    764  15b4		       c8	   skipsp2    iny
    765  15b5		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  15b7		       f0 04		      beq	Skip3	;end of line
    767  15b9		       c9 20		      cmp	#SPACE
    768  15bb		       f0 f7		      beq	skipsp2
    769  15bd		       60	   Skip3      rts
    770  15be							;*********************************************************
    771  15be							; Output a CR/LF combination to the console.  Preserves
    772  15be							; all registers.
    773  15be							;
    774  15be		       48	   tbcrlf     pha
    775  15bf		       a9 0d		      lda	#CR
    776  15c1		       20 07 17 	      jsr	VOUTCH
    777  15c4		       a9 0a		      lda	#LF
    778  15c6		       20 07 17 	      jsr	VOUTCH
    779  15c9		       68		      pla
    780  15ca		       60		      rts
    781  15cb							;
    782  15cb							;=====================================================
    783  15cb							; Some logic to print the Line of basic code being executed
    784  15cb		       24 40	   idbgBasic  bit	ILTrace
    785  15cd		       50 70		      bvc	dbgBasicNone
    786  15cf		       98		      tya
    787  15d0		       48		      pha
    788  15d1		       20 90 17 	      jsr	SetOutDebug
    789  15d4		       20 30 17 	      jsr	PrtPrgLine
    790  15d7		       20 be 15 	      jsr	CRLF
    791  15da		       a5 40		      lda	ILTrace
    792  15dc		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  15de		       f0 5a		      beq	dbgBasicDone
    794  15e0		       20 9b 17 	      jsr	SetInDebug
    795  15e3		       20 0d 17 	      jsr	puts
      0  15e6					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  15e6		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1623				   dbgBasicLoop
    798  1623		       20 0a 17 	      jsr	VGETCH
    799  1626		       20 be 15 	      jsr	CRLF
    800  1629		       20 fa 16 	      jsr	SetInConsole
    801  162c
    802  162c		       c9 73		      cmp	#'s	; Quit program
    803  162e		       f0 12		      beq	dbgBasicStop
    804  1630
    805  1630		       c9 64		      cmp	#'d	; Display Variables
    806  1632		       d0 06		      bne	dbgBasicDone
    807  1634
    808  1634		       20 bf 17 	      jsr	PrintAllVars
    809  1637		       18		      clc
    810  1638		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  163a
    812  163a		       20 ed 16    dbgBasicDone jsr	SetOutConsole
    813  163d		       68		      pla
    814  163e		       a8		      tay
    815  163f		       4c bb 02    dbgBasicNone jmp	NextIL
    816  1642
    817  1642				   dbgBasicStop
    818  1642		       20 ed 16 	      jsr	SetOutConsole
    819  1645		       68		      pla
    820  1646		       a8		      tay
    821  1647		       4c 01 06 	      jmp	iFIN
    822  164a							;
    823  164a							;=====================================================
    824  164a							; This is some debug logic which displays the current
    825  164a							; value of the ILPC and the line buffer.
    826  164a							;
    827  164a		       24 40	   dbgLine    bit	ILTrace
    828  164c		       30 01		      bmi	dbgPrt
    829  164e		       60		      rts
    830  164f				   dbgPrt
    831  164f		       20 90 17 	      jsr	SetOutDebug
    832  1652		       20 0d 17 	      jsr	puts
      0  1655					      db	"ILPC: ",0
      1  1655		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  165c		       a5 44		      lda	ILPC+1
    835  165e		       20 ac 0d 	      jsr	OUTHEX
    836  1661		       a5 43		      lda	ILPC
    837  1663		       20 ac 0d 	      jsr	OUTHEX
    838  1666		       a9 20		      lda	#SPACE
    839  1668		       20 07 17 	      jsr	VOUTCH
    840  166b		       a0 00		      ldy	#0
    841  166d		       b1 43		      lda	(ILPC),y
    842  166f		       20 ac 0d 	      jsr	OUTHEX
    843  1672							;
    844  1672							; Display the CURPTR value and offset
    845  1672							;
    846  1672		       20 0d 17 	      jsr	puts
      0  1675					      db	", CURPTR: ",0
      1  1675		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  1680		       a5 50		      lda	CURPTR+1
    849  1682		       20 ac 0d 	      jsr	OUTHEX
    850  1685		       a5 4f		      lda	CURPTR
    851  1687		       20 ac 0d 	      jsr	OUTHEX
    852  168a		       a9 2b		      lda	#'+
    853  168c		       20 07 17 	      jsr	VOUTCH
    854  168f		       a5 51		      lda	CUROFF
    855  1691		       20 ac 0d 	      jsr	OUTHEX
    856  1694							;
    857  1694		       20 be 15 	      jsr	CRLF
    858  1697		       20 ed 16 	      jsr	SetOutConsole
    859  169a		       20 cd 16 	      jsr	ILChkRange
    860  169d		       b0 02		      bcs	dbgLineErr
    861  169f		       18		      clc
    862  16a0		       60		      rts
    863  16a1
    864  16a1				   dbgLineErr
    865  16a1		       20 90 17 	      jsr	SetOutDebug
    866  16a4		       20 0d 17 	      jsr	puts
      0  16a7					      db	"Outside Valid IL Address Range",CR,LF,0
      1  16a7		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  16c8		       20 ed 16 	      jsr	SetOutConsole
    869  16cb		       38		      sec
    870  16cc		       60		      rts
    871  16cd
    872  16cd		       a5 44	   ILChkRange lda	ILPC+1
    873  16cf		       c9 19		      cmp	#IL>>8
    874  16d1		       90 18		      bcc	ILBadRange
    875  16d3		       d0 06		      bne	ILChkHigh
    876  16d5
    877  16d5		       a5 43		      lda	ILPC
    878  16d7		       c9 17		      cmp	#IL&$ff
    879  16d9		       90 10		      bcc	ILBadRange
    880  16db
    881  16db		       a5 44	   ILChkHigh  lda	ILPC+1
    882  16dd		       c9 1d		      cmp	#ILEND>>8
    883  16df		       90 08		      bcc	ILGoodRange
    884  16e1		       d0 08		      bne	ILBadRange
    885  16e3
    886  16e3		       a5 43		      lda	ILPC
    887  16e5		       c9 e3		      cmp	#ILEND&$ff
    888  16e7		       b0 02		      bcs	ILBadRange
    889  16e9
    890  16e9		       18	   ILGoodRange clc
    891  16ea		       60		      rts
    892  16eb				   ILBadRange
    893  16eb		       38		      sec
    894  16ec		       60		      rts
    895  16ed
    896  16ed
    897  16ed							;=====================================================
    898  16ed							; Set output vector to the console output function
    899  16ed							;
    900  16ed				   SetOutConsole
    901  16ed		       48		      pha
    902  16ee		       a9 0c		      lda	#OUTCH&$ff
    903  16f0		       8d 45 27 	      sta	BOutVec
    904  16f3		       a9 f0		      lda	#OUTCH>>8
    905  16f5		       8d 46 27 	      sta	BOutVec+1
    906  16f8		       68		      pla
    907  16f9		       60		      rts
    908  16fa
    909  16fa				   SetInConsole
    910  16fa		       48		      pha
    911  16fb		       a9 09		      lda	#GETCH&$ff
    912  16fd		       8d 47 27 	      sta	BInVec
    913  1700		       a9 f0		      lda	#GETCH>>8
    914  1702		       8d 48 27 	      sta	BInVec+1
    915  1705		       68		      pla
    916  1706		       60		      rts
    917  1707
    918  1707							;=====================================================
    919  1707							; Jump to the output/input function in BOutVec/BInVec
    920  1707							;
    921  1707		       6c 45 27    VOUTCH     jmp	(BOutVec)
    922  170a		       6c 47 27    VGETCH     jmp	(BInVec)
    923  170d							;
    924  170d							;=====================================================
    925  170d							; Print the string that immediately follows the JSR to
    926  170d							; this function.  Stops when a null byte is found,
    927  170d							; then returns to the instruction immediately
    928  170d							; following the null.
    929  170d							;
    930  170d							; Thanks to Ross Archer for this code.
    931  170d							; http://www.6502.org/source/io/primm.htm
    932  170d							;
    933  170d
    934  170d		       68	   tbputs     pla		;Get the low part of "return" address
    935  170e							;(data start address)
    936  170e		       85 5e		      sta	PrtFrom
    937  1710		       68		      pla
    938  1711		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    939  1713							;(data start address)
    940  1713							;Note: actually we're pointing one short
    941  1713		       a0 01	   PSINB      ldy	#1
    942  1715		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    943  1717		       e6 5e		      inc	PrtFrom	;update the pointer
    944  1719		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    945  171b		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    946  171d		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    947  171f							;   Accumulator
    948  171f		       f0 06		      beq	PSIX1	;don't print the final NULL
    949  1721		       20 07 17 	      jsr	VOUTCH	;write it out
    950  1724		       4c 13 17 	      jmp	PSINB	;back around
    951  1727		       e6 5e	   PSIX1      inc	PrtFrom
    952  1729		       d0 02		      bne	PSIX2
    953  172b		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    954  172d		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    955  1730
    956  1730							;
    957  1730
    958  1730							;====================================================
    959  1730		       27 49	   PrtTerm    equ	tempy
    960  1730
    961  1730							; on exit Print Y has the offset to use
    962  1730							; input y =	 addr low
    963  1730							;	 x =	 addr high
    964  1730							;	 a =	 termination string
    965  1730
    966  1730				   PrtPrgLine
    967  1730		       a9 00		      lda	#0
    968  1732		       8d 49 27 	      sta	PrtTerm
    969  1735		       f0 05		      beq	PrtPrgText
    970  1737
    971  1737		       a9 22	   PrtQuoted  lda	#'"
    972  1739		       8d 49 27 	      sta	PrtTerm
    973  173c
    974  173c		       a4 51	   PrtPrgText ldy	CUROFF
    975  173e		       a5 4f		      lda	CURPTR
    976  1740		       85 5e		      sta	PrtFrom
    977  1742		       a5 50		      lda	CURPTR+1
    978  1744		       85 5f		      sta	PrtFrom+1
    979  1746		       4c 52 17 	      jmp	PrtLoop
    980  1749
    981  1749							; Print a string pointed to by x= h, y=l terminated by a
    982  1749							; Return y as the length
    983  1749
    984  1749		       86 5f	   PrtStr     stx	PrtFrom+1
    985  174b		       84 5e		      sty	PrtFrom
    986  174d		       8d 49 27 	      sta	PrtTerm
    987  1750		       a0 00		      ldy	#0
    988  1752							;
    989  1752							; On entry here ptrfrom and prtterm point to area to print
    990  1752							;
    991  1752		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    992  1754		       cd 49 27 	      cmp	PrtTerm
    993  1757		       f0 0b		      beq	PrtEnd
    994  1759		       c9 00		      cmp	#0	; always end if 0 is found
    995  175b		       f0 07		      beq	PrtEnd
    996  175d		       20 07 17 	      jsr	VOUTCH
    997  1760		       c8		      iny
    998  1761		       4c 52 17 	      jmp	PrtLoop
    999  1764		       c8	   PrtEnd     iny		;return byte after the copy
   1000  1765		       60		      rts
   1001  1766
   1002  1766							;====================================================
   1003  1766							;Clear the terminal assume it is ansii or vt100
   1004  1766							;
   1005  1766				   iCLEARSCREEN
   1006  1766		       20 0d 17 	      jsr	puts
      0  1769					      db	$1b,'[,'2,'J,0
      1  1769		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
   1008  176e		       4c bb 02 	      jmp	NextIL
   1009  1771
   1010  1771							;====================================================
   1011  1771							; Push true and false onto math stack
   1012  1771				   pushTrue
   1013  1771		       a9 ff		      lda	#$ff
   1014  1773		       85 52	   pushTF     sta	R0
   1015  1775		       85 53		      sta	R0+1
   1016  1777		       20 81 14 	      jsr	pushR0
   1017  177a		       60		      rts
   1018  177b		       a9 00	   pushFalse  lda	#0
   1019  177d		       f0 f4		      beq	pushTF
   1020  177f
   1021  177f							;======================================================
   1022  177f							; Copy stack top to R1
   1023  177f				   CopyStackR1
   1024  177f		       98		      tya
   1025  1780		       48		      pha
   1026  1781		       a4 4a		      ldy	MATHSTACKPTR
   1027  1783		       88		      dey
   1028  1784		       b1 48		      lda	(MATHSTACK),y
   1029  1786		       85 55		      sta	R1+1
   1030  1788		       88		      dey
   1031  1789		       b1 48		      lda	(MATHSTACK),y
   1032  178b		       85 54		      sta	R1
   1033  178d		       68		      pla
   1034  178e		       a8		      tay
   1035  178f		       60		      rts
   1036  1790
   1037  1790
   1038  1790							;====================================================
   1039  1790							;Swap the out debug call for standard calls
   1040  1790
   1041  1790				   SetOutDebug
   1042  1790					      if	USEDEBUGPORT
   1043  1790		       a9 b0		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1044  1792		       8d 45 27 	      sta	BOutVec
   1045  1795		       a9 17		      lda	#OUTDEBUG>>8
   1046  1797		       8d 46 27 	      sta	BOutVec+1
   1047  179a					      endif
   1048  179a		       60		      rts
   1049  179b				   SetInDebug
   1050  179b					      if	USEDEBUGPORT
   1051  179b		       a9 b4		      lda	#INDEBUG&$ff
   1052  179d		       8d 47 27 	      sta	BInVec
   1053  17a0		       a9 17		      lda	#INDEBUG>>8
   1054  17a2		       8d 48 27 	      sta	BInVec+1
   1055  17a5					      endif
   1056  17a5		       60		      rts
   1057  17a6							;
   1058  17a6							;====================================================
   1059  17a6							; Output to the debug console
   1060  17a6							;     x = high address byte
   1061  17a6							;     y = low address byte
   1062  17a6							;     a = Terminator for string
   1063  17a6				   DebugWrite
   1064  17a6		       20 90 17 	      jsr	SetOutDebug
   1065  17a9		       20 49 17 	      jsr	PrtStr
   1066  17ac		       20 ed 16 	      jsr	SetOutConsole
   1067  17af		       60		      rts
   1068  17b0
   1069  17b0				   OUTDEBUG
   1070  17b0		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1071  17b3		       60		      RTS
   1072  17b4
   1073  17b4		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1074  17b7		       29 01		      and	#$01
   1075  17b9		       f0 f9		      beq	INDEBUG
   1076  17bb		       ad 21 e0 	      lda	DEBUGPORT+1
   1077  17be		       60		      rts
   1078  17bf							;
   1079  17bf							;=======================================================
   1080  17bf							; Print all Variables
   1081  17bf				   PrintAllVars
   1082  17bf		       a0 00		      ldy	#0
   1083  17c1		       a9 41		      lda	#'A
   1084  17c3				   PrintAllVarsLoop
   1085  17c3		       48		      pha
   1086  17c4		       b1 41		      lda	(VARIABLES),y
   1087  17c6		       85 52		      sta	R0
   1088  17c8		       c8		      iny
   1089  17c9		       b1 41		      lda	(VARIABLES),y
   1090  17cb		       85 53		      sta	R0+1
   1091  17cd
   1092  17cd		       68		      pla		;get the current letter
   1093  17ce		       48		      pha
   1094  17cf		       20 07 17 	      jsr	VOUTCH
   1095  17d2		       20 0d 17 	      jsr	puts
      0  17d5					      db	"=",0
      1  17d5		       3d 00		      .byte.b	"=",0
   1097  17d7		       68		      pla
   1098  17d8		       aa		      tax
   1099  17d9		       e8		      inx
   1100  17da		       8a		      txa
   1101  17db		       48		      pha		;
   1102  17dc
   1103  17dc		       98		      tya
   1104  17dd		       48		      pha
   1105  17de		       20 02 0d 	      jsr	PrintDecimal
   1106  17e1		       20 0d 17 	      jsr	puts
      0  17e4					      db	" ",0
      1  17e4		       20 00		      .byte.b	" ",0
   1108  17e6		       68		      pla
   1109  17e7		       a8		      tay
   1110  17e8		       c8		      iny
   1111  17e9		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1112  17eb		       90 d6		      bcc	PrintAllVarsLoop
   1113  17ed		       20 be 15 	      jsr	CRLF
   1114  17f0
   1115  17f0		       68		      pla
   1116  17f1		       60		      rts
   1117  17f2
   1118  17f2
   1119  17f2
   1120  17f2
   1121  17f2
   1122  17f2
   1123  17f2
   1124  17f2
   1125  17f2
   1126  17f2
   1127  17f2
   1128  17f2
   1129  17f2
   1130  17f2
   1131  17f2
   1132  17f2
   1133  17f2
   1134  17f2
   1135  17f2
------- FILE mytb.asm
   2209  17f2
   2210  17f2					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  17f2					      include	"storage.asm"
      1  17f2							;
      2  17f2							;=====================================================
      3  17f2							;=====================================================
      4  17f2							;=====================================================
      5  17f2							; This file contains the functions for saving and
      6  17f2							; restoring programs from some sort of mass storage
      7  17f2							; device.  This particular version is for using the
      8  17f2							; Corsham Tech SD Card System.
      9  17f2							;=====================================================
     10  17f2							;=====================================================
     11  17f2							;=====================================================
     12  17f2
     13 U1de3					      seg.u	TBData
     14 U1de3		       00	   diskBufLength ds	1
     15 U1de4		       00	   diskBufOffset ds	1
     16 U1de5		       00 00 00 00*DiskFileName ds	14
     17 U1df3
     18  17f2					      SEG	Code
     19  17f2
     20  17f2							;
     21  17f2							;=====================================================
     22  17f2							; Open a file for reading as a program.  The next
     23  17f2							; thing on the line should be the filename.
     24  17f2							;
     25  17f2				   iOPENREAD
     26  17f2					      if	XKIM || CTMON65
     27  17f2		       a4 51		      ldy	CUROFF
     28  17f4		       b1 4f		      lda	(CURPTR),y
     29  17f6		       d0 07		      bne	iOPENfn	;might be filename
     30  17f8							;
     31  17f8							; No filename supplied.
     32  17f8							;
     33  17f8		       a9 00	   iOPENnofn  lda	#0
     34  17fa		       a2 09		      ldx	#ERR_NO_FILENAME
     35  17fc		       4c 18 06 	      jmp	iErr2
     36  17ff							;
     37  17ff							; Add the offset into the buffer start
     38  17ff							;
     39  17ff		       18	   iOPENfn    clc
     40  1800		       98		      tya
     41  1801		       65 4f		      adc	CURPTR
     42  1803		       a8		      tay		;LSB
     43  1804		       a5 50		      lda	CURPTR+1
     44  1806		       69 00		      adc	#0
     45  1808		       aa		      tax
     46  1809		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  180c		       90 07		      bcc	Ropenok	;branch if opened ok
     48  180e							;
     49  180e							; Open failed
     50  180e							;
     51  180e		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1810		       a9 00	   Rdfail2    lda	#0
     53  1812		       4c 18 06 	      jmp	iErr2
     54  1815							;
     55  1815							; Clear counts and offsets so the next read will
     56  1815							; cause the file to be read.
     57  1815							;
     58  1815		       a9 00	   Ropenok    lda	#0
     59  1817		       8d e4 1d 	      sta	diskBufOffset
     60  181a		       8d e3 1d 	      sta	diskBufLength
     61  181d		       4c bb 02 	      jmp	NextIL
     62  1820					      endif
     63  1820
     64  1820							;
     65  1820							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1820							;Remove a file from the disk
     67  1820				   iRMFILE
     68  1820					      if	XKIM || CTMON65
     69  1820		       a4 51		      ldy	CUROFF
     70  1822		       b1 4f		      lda	(CURPTR),y
     71  1824		       f0 19		      beq	iRMnofn
     72  1826							;
     73  1826		       18		      clc
     74  1827		       98		      tya
     75  1828		       65 4f		      adc	CURPTR
     76  182a		       a8		      tay		;LSB
     77  182b		       a5 50		      lda	CURPTR+1
     78  182d		       69 00		      adc	#0
     79  182f		       aa		      tax
     80  1830		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1833		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1835		       a9 00		      lda	#0
     83  1837		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1839		       4c 18 06 	      jmp	iErr2
     85  183c		       4c bb 02    wrmOk      jmp	NextIL
     86  183f
     87  183f							; No filename supplied.
     88  183f							;
     89  183f		       a9 00	   iRMnofn    lda	#0
     90  1841		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1843		       4c 18 06 	      jmp	iErr2
     92  1846					      endif
     93  1846							;
     94  1846							;=====================================================
     95  1846				   iOPENWRITE
     96  1846					      if	XKIM || CTMON65
     97  1846		       a4 51		      ldy	CUROFF
     98  1848		       b1 4f		      lda	(CURPTR),y
     99  184a		       f0 f3		      beq	iRMnofn
    100  184c							;
    101  184c		       18		      clc
    102  184d		       98		      tya
    103  184e		       65 4f		      adc	CURPTR
    104  1850		       a8		      tay		;LSB
    105  1851		       a5 50		      lda	CURPTR+1
    106  1853		       69 00		      adc	#0
    107  1855		       aa		      tax
    108  1856		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1859		       90 07		      bcc	Wopenok	;branch if opened ok
    110  185b							;
    111  185b							; Open failed
    112  185b							;
    113  185b		       a9 00	   Wdfail     lda	#0
    114  185d		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  185f		       4c 18 06 	      jmp	iErr2
    116  1862							;
    117  1862		       4c bb 02    Wopenok    jmp	NextIL
    118  1865					      endif
    119  1865							;
    120  1865							;=====================================================
    121  1865							; Gets a line of input from the disk file and puts it
    122  1865							; into LINBUF.
    123  1865							;
    124  1865							; On exit:
    125  1865							;    CURPTR points to LINBUF
    126  1865							;    LINBUF contains the line with 0 at the end.
    127  1865							;    Y has offset to first non-space character
    128  1865							;    CURROFF has the same as Y.
    129  1865							;
    130  1865				   iDGETLINE
    131  1865					      if	XKIM || CTMON65
    132  1865		       a2 b4		      ldx	#LINBUF&$ff
    133  1867		       86 4f		      stx	CURPTR
    134  1869		       a2 26		      ldx	#LINBUF>>8
    135  186b		       86 50		      stx	CURPTR+1
    136  186d							;
    137  186d		       a2 00		      ldx	#0	;offset
    138  186f		       8e 38 27    iDgetLoop  stx	getlinx
    139  1872		       20 d0 18 	      jsr	getNextFileByte
    140  1875		       b0 16		      bcs	iGetEOF
    141  1877		       c9 0d		      cmp	#CR
    142  1879		       f0 0d		      beq	iGetEOL
    143  187b		       c9 0a		      cmp	#LF
    144  187d		       f0 09		      beq	iGetEOL
    145  187f		       ae 38 27 	      ldx	getlinx
    146  1882		       9d b4 26 	      sta	LINBUF,x
    147  1885		       e8		      inx
    148  1886		       d0 e7		      bne	iDgetLoop
    149  1888							;
    150  1888							; Handle end of line.	If the line has nothing, loop
    151  1888							; back and get another line.
    152  1888							;
    153  1888		       ae 38 27    iGetEOL    ldx	getlinx	;blank line?
    154  188b		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  188d							;
    156  188d							; This can fall through when there is a line, or
    157  188d							; called directly when EOF is encountered.
    158  188d							;
    159  188d		       ae 38 27    iGetEOF    ldx	getlinx
    160  1890		       a9 00		      lda	#0
    161  1892		       9d b4 26 	      sta	LINBUF,x
    162  1895		       85 51		      sta	CUROFF
    163  1897		       a0 00		      ldy	#0
    164  1899		       20 b5 15 	      jsr	SkipSpaces
    165  189c		       4c bb 02 	      jmp	NextIL
    166  189f					      endif
    167  189f
    168  189f							;
    169  189f							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  189f							; DISK
    171  189f							;
    172  189f				   iDDIR
    173  189f					      if	XKIM || CTMON65
    174  189f		       20 30 f0 	      jsr	DiskDir
    175  18a2							;
    176  18a2							; Get/Display each entry
    177  18a2							;
    178  18a2		       a2 1d	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  18a4		       a0 e5		      ldy	#DiskFileName&$ff
    180  18a6		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  18a9		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  18ab		       20 0d 17 	      jsr	puts
      0  18ae					      db	"   ",0
      1  18ae		       20 20 20 00	      .byte.b	"   ",0
    184  18b2							; Print the line to the console
    185  18b2		       a2 1d		      ldx	#DiskFileName>>8	;pointer to buffer
    186  18b4		       a0 e5		      ldy	#DiskFileName&$ff
    187  18b6		       a5 00		      lda	0
    188  18b8		       20 49 17 	      jsr	PrtStr	;else print name
    189  18bb		       20 18 f0 	      jsr	crlf
    190  18be
    191  18be		       4c a2 18 	      jmp	DiskDirLoop	;do next entry
    192  18c1
    193  18c1		       4c bb 02    DiskDirEnd jmp	NextIL
    194  18c4					      endif
    195  18c4							;
    196  18c4							;=====================================================
    197  18c4							; Does a LIST to a Disk file.
    198  18c4							;
    199  18c4				   iDLIST
    200  18c4					      if	XKIM || CTMON65
    201  18c4		       20 ff 18 	      jsr	SetOutDisk
    202  18c7		       4c e8 07 	      jmp	iLST2
    203  18ca					      endif
    204  18ca							;
    205  18ca							;=====================================================
    206  18ca							; Closes any pending disk file.  Okay to call if there
    207  18ca							; is no open file.
    208  18ca							;
    209  18ca				   iDCLOSE
    210  18ca					      if	XKIM || CTMON65
    211  18ca		       20 42 f0 	      jsr	DiskClose
    212  18cd		       4c bb 02 	      jmp	NextIL
    213  18d0					      endif
    214  18d0							;
    215  18d0							;=====================================================
    216  18d0							; This gets the next byte from an open disk file.  If
    217  18d0							; there are no more bytes left, this returns C set.
    218  18d0							; Else, C is clear and A contains the character.
    219  18d0							;
    220  18d0				   getNextFileByte
    221  18d0					      if	XKIM || CTMON65
    222  18d0		       ae e4 1d 	      ldx	diskBufOffset
    223  18d3		       ec e3 1d 	      cpx	diskBufLength
    224  18d6		       d0 14		      bne	hasdata	;branch if still data
    225  18d8							;
    226  18d8							; There is no data left in the buffer, so read a
    227  18d8							; block from the SD system.
    228  18d8							;
    229  18d8		       a9 84		      lda	#BUFFER_SIZE
    230  18da		       a2 df		      ldx	#buffer>>8
    231  18dc		       a0 0a		      ldy	#buffer&$ff
    232  18de		       20 3c f0 	      jsr	DiskRead
    233  18e1		       b0 12		      bcs	getNextEof
    234  18e3							;
    235  18e3							; A contains the number of bytes actually read.
    236  18e3							;
    237  18e3		       8d e3 1d 	      sta	diskBufLength	;save length
    238  18e6		       c9 00		      cmp	#0	;shouldn't happen
    239  18e8		       f0 0b		      beq	getNextEof
    240  18ea							;
    241  18ea		       a2 00		      ldx	#0
    242  18ec		       bd 0a df    hasdata    lda	buffer,x
    243  18ef		       e8		      inx
    244  18f0		       8e e4 1d 	      stx	diskBufOffset
    245  18f3		       18		      clc
    246  18f4		       60		      rts
    247  18f5							;
    248  18f5		       a9 00	   getNextEof lda	#0
    249  18f7		       8d e4 1d 	      sta	diskBufOffset
    250  18fa		       8d e3 1d 	      sta	diskBufLength
    251  18fd		       38		      sec
    252  18fe		       60		      rts
    253  18ff							;
    254  18ff							;=====================================================
    255  18ff							; Set output vector to the disk output function
    256  18ff							;
    257  18ff		       a9 0a	   SetOutDisk lda	#DOUT&$ff
    258  1901		       8d 45 27 	      sta	BOutVec
    259  1904		       a9 19		      lda	#DOUT/256
    260  1906		       8d 46 27 	      sta	BOutVec+1
    261  1909		       60		      rts
    262  190a							;
    263  190a							;=====================================================
    264  190a
    265  190a		       8d 0a df    DOUT       sta	buffer
    266  190d		       a9 01		      lda	#1
    267  190f		       a0 0a		      ldy	#buffer&$ff
    268  1911		       a2 df		      ldx	#buffer>>8
    269  1913		       20 3f f0 	      jsr	DiskWrite
    270  1916							;
    271  1916							; need error checking here
    272  1916							;
    273  1916		       60		      rts
    274  1917					      endif
    275  1917
    276  1917
------- FILE mytb.asm
   2212  1917					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1917					      include	"IL.inc"
      1  1917
      2  1917							;=====================================================
      3  1917							; IL.inc
      4  1917							; These are macros for IL instructions
      5  1917							;
      6  1917					      mac	dw
      7  1917					      .word	{0}
      8  1917					      endm
      9  1917					      mac	db
     10  1917					      .byte	{0}
     11  1917					      endm
     12  1917					      macro	xinit
     13  1917					      db	0
     14  1917					      endm		;reset the il to start clear all
     15  1917							;
     16  1917					      macro	done
     17  1917					      db	1
     18  1917					      endm		;print an error if not end of line
     19  1917							;
     20  1917					      macro	prs
     21  1917					      db	2
     22  1917					      endm		;print a quoted string
     23  1917							;
     24  1917					      macro	prn
     25  1917					      db	3
     26  1917					      endm		;print a number
     27  1917							;
     28  1917					      macro	spc
     29  1917					      db	4
     30  1917					      endm		;print space til new tabstop
     31  1917							;
     32  1917					      macro	nline
     33  1917					      db	5
     34  1917					      endm		;print a new line crlf
     35  1917							;
     36  1917							; My NXT is a bit different in that it takes one
     37  1917							; parameter, which is an address.  If the BASIC
     38  1917							; program is currently running then move to the
     39  1917							; next line and continue execution.  However, if
     40  1917							; in direct mode, jump to the specified IL label.
     41  1917							;
     42  1917					      macro	nxt
     43  1917					      db	6
     44  1917					      dw	{1}	; addr
     45  1917					      endm		; addr
     46  1917							;
     47  1917					      macro	xfer
     48  1917					      db	7
     49  1917					      endm
     50  1917							;
     51  1917					      macro	sav
     52  1917					      db	8
     53  1917					      db	{1}
     54  1917					      endm
     55  1917							;
     56  1917					      macro	rstr
     57  1917					      db	9
     58  1917					      endm
     59  1917							;
     60  1917					      macro	cmpr
     61  1917					      db	10
     62  1917					      endm
     63  1917							;
     64  1917					      macro	innum
     65  1917					      db	11
     66  1917					      endm
     67  1917							;
     68  1917					      macro	fin
     69  1917					      db	12
     70  1917					      endm
     71  1917							;
     72  1917							; ERR is followed by an error number.	The error
     73  1917							; code is printed along with the line number.
     74  1917							; Control is passed to the statement set with
     75  1917							; the ERRGOTO statement.
     76  1917							;
     77  1917					      macro	errmsg
     78  1917					      db	13
     79  1917					      dw	{1}	;ecode
     80  1917					      endm		;ecode
     81  1917							;
     82  1917					      macro	add
     83  1917					      db	14
     84  1917					      endm
     85  1917							;
     86  1917					      macro	sub
     87  1917					      db	15
     88  1917					      endm
     89  1917							;
     90  1917					      macro	neg
     91  1917					      db	16
     92  1917					      endm
     93  1917							;
     94  1917					      macro	mul
     95  1917					      db	17
     96  1917					      endm
     97  1917							;
     98  1917					      macro	div
     99  1917					      db	18
    100  1917					      endm
    101  1917							;
    102  1917					      macro	store
    103  1917					      db	19
    104  1917					      endm
    105  1917							;
    106  1917					      macro	ind
    107  1917					      db	20
    108  1917					      endm
    109  1917							;
    110  1917					      macro	lst
    111  1917					      db	21
    112  1917					      endm
    113  1917							;
    114  1917					      macro	init
    115  1917					      db	22
    116  1917					      endm
    117  1917							;
    118  1917					      macro	getline
    119  1917					      db	23
    120  1917					      endm
    121  1917							;
    122  1917					      macro	insert
    123  1917					      db	24
    124  1917					      endm
    125  1917							;
    126  1917					      macro	rtn
    127  1917					      db	25
    128  1917					      endm
    129  1917							;
    130  1917					      macro	exit
    131  1917					      db	26
    132  1917					      endm
    133  1917							;
    134  1917					      macro	lit
    135  1917					      db	27
    136  1917					      dw	{1}	;value
    137  1917					      endm		; value LIT
    138  1917							;
    139  1917					      macro	call
    140  1917					      db	28
    141  1917					      dw	{1}	;addr
    142  1917					      endm		;addr
    143  1917							;
    144  1917							; IJMP will set the IL PC to the specified value.
    145  1917							;
    146  1917					      macro	ijmp
    147  1917					      db	29
    148  1917					      dw	{1}	;addr
    149  1917					      endm		;addr
    150  1917							;
    151  1917					      macro	vinit
    152  1917					      db	30
    153  1917					      endm
    154  1917							;
    155  1917							; ERRGOTO sets the point in the code where the IL
    156  1917							; interpreter will go after any error.
    157  1917							;
    158  1917					      macro	errgoto
    159  1917					      db	31
    160  1917					      dw	{1}	;addr
    161  1917					      endm		;addr
    162  1917							;
    163  1917					      macro	tst
    164  1917					      db	32
    165  1917					      db	({1}-*)-1	;(addr-*)-1
    166  1917					      db	{2},0	;string,0
    167  1917					      endm		;addr,string
    168  1917							;
    169  1917					      macro	tstv
    170  1917					      db	33
    171  1917					      db	({1}-*)-1	;(addr-*)-1
    172  1917					      endm		;addr
    173  1917							;
    174  1917					      macro	tstl
    175  1917					      db	34
    176  1917					      db	({1}-*)-1	;(addr-*)-1
    177  1917					      endm		;addr
    178  1917							;
    179  1917					      macro	tstn
    180  1917					      db	35
    181  1917					      db	({1}-*)-1	;(addr-*)-1
    182  1917					      endm		;addr
    183  1917							;
    184  1917							; FREE returns the amount of free RAM on top of
    185  1917							; the stack.  This is the amount of room the user
    186  1917							; program has available.
    187  1917							;
    188  1917					      macro	free
    189  1917					      db	36
    190  1917					      endm
    191  1917							;
    192  1917							; RANDOM takes the top item off the stack and
    193  1917							; replaces it with a random number that is
    194  1917							; MOD the initial value.  Ie, if the TOS is
    195  1917							; 42 then RANDOM returns a value from 0 to 41.
    196  1917							;
    197  1917					      macro	random
    198  1917					      db	37
    199  1917					      endm
    200  1917							;
    201  1917							; ABS will replace the top of stack with the
    202  1917							; absolute value.
    203  1917							;
    204  1917					      macro	abs
    205  1917					      db	38
    206  1917					      endm
    207  1917							;
    208  1917							; OPENREAD opens a file for reading, as in getting
    209  1917							; statements from it.
    210  1917							;
    211  1917					      macro	openread
    212  1917					      db	39
    213  1917					      endm
    214  1917							;
    215  1917							; OPENWRITE opens a file for writing, as in saving
    216  1917							; the current program to it.
    217  1917							;
    218  1917					      macro	openwrite
    219  1917					      db	40
    220  1917					      endm
    221  1917							;
    222  1917							; DCLOSE closes any open disk file.
    223  1917							;
    224  1917					      macro	dclose
    225  1917					      db	41
    226  1917					      endm
    227  1917							;
    228  1917							; DGETLINE gets one line from the disk file and puts it
    229  1917							; into LINBUFF.
    230  1917							;
    231  1917					      macro	dgetline
    232  1917					      db	42
    233  1917					      endm
    234  1917							;
    235  1917							; DLIST saves the program to an open disk file.
    236  1917							;
    237  1917					      macro	dlist
    238  1917					      db	43
    239  1917					      endm
    240  1917							; DDIR list the current directory
    241  1917							;
    242  1917					      macro	ddir
    243  1917					      db	44
    244  1917					      endm
    245  1917
    246  1917							; RMFILE remove a fle from disk
    247  1917					      macro	rmfile
    248  1917					      db	45
    249  1917					      endm
    250  1917
    251  1917							; CLEARSCREEN clear the screen
    252  1917					      macro	clearscreen
    253  1917					      db	46
    254  1917					      endm
    255  1917							; POKEMEM Poke value into memory
    256  1917					      macro	pokemem
    257  1917					      db	47
    258  1917					      endm
    259  1917							; PEEKMEM peek at value in memory
    260  1917					      macro	peekmem
    261  1917					      db	48
    262  1917					      endm
    263  1917							; TSTLET Test if the statement is a let without the keyword let
    264  1917					      macro	tstlet
    265  1917					      db	49
    266  1917					      db	({1}-*)-1	;(addr-*)-1
    267  1917					      endm		;addr
    268  1917							; TSTDONE if we reach the end of a statement
    269  1917					      macro	tstdone
    270  1917					      db	50
    271  1917					      db	({1}-*)-1	;(addr-*)-1
    272  1917					      endm		;addr
    273  1917							; GETCHAR	get a character from the input line leave it in RO
    274  1917					      macro	getchar
    275  1917					      db	51
    276  1917					      endm
    277  1917							; PUTCHAR	Put a character to the terminal
    278  1917					      macro	putchar
    279  1917					      db	52
    280  1917					      endm
    281  1917							; Call		Call a machine function return a to stack
    282  1917					      macro	callfunc
    283  1917					      db	53
    284  1917					      endm
    285  1917
    286  1917							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1917					      macro	ibranch
    288  1917					      db	54
    289  1917					      endm
    290  1917
    291  1917							; TSTSTR	 Tests for the open quote in a string
    292  1917					      macro	tststr
    293  1917					      db	55
    294  1917					      db	({1}-*)-1	;(addr-*)-1
    295  1917					      endm
    296  1917							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1917					      macro	setirq
    298  1917					      db	56
    299  1917					      endm
    300  1917
    301  1917							; TSTIRQ	Test for irq pending,
    302  1917							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1917					      macro	tstirq
    304  1917					      db	57
    305  1917					      db	({1}-*)-1	;(addr-*)-1
    306  1917					      endm
    307  1917
    308  1917							; IRET    return from interupt service
    309  1917					      macro	iret
    310  1917					      db	58
    311  1917					      endm
    312  1917
    313  1917							; INSTR   read a string from the input
    314  1917					      macro	instr
    315  1917					      db	59
    316  1917					      endm
    317  1917
    318  1917							; MODULO Returns the remainder of the division
    319  1917					      macro	modulo
    320  1917					      db	60
    321  1917					      endm
    322  1917							; Set a task line
    323  1917					      macro	taskcreate
    324  1917					      db	61
    325  1917					      endm
    326  1917							; End a task
    327  1917					      macro	etask
    328  1917					      db	62
    329  1917					      endm
    330  1917							; Skip to next task
    331  1917					      macro	ntask
    332  1917					      db	63
    333  1917					      endm
    334  1917							; Subscript
    335  1917					      macro	subscript
    336  1917					      db	64
    337  1917					      endm
    338  1917							; KILL Task
    339  1917					      macro	taskkill
    340  1917					      db	65
    341  1917					      endm
    342  1917							; STAT Task
    343  1917					      macro	taskstat
    344  1917					      db	66
    345  1917					      endm
    346  1917							;  output value as hex
    347  1917					      macro	hexprt
    348  1917					      db	67
    349  1917					      endm
    350  1917							;  Read in background has completed
    351  1917					      macro	readcomplete
    352  1917					      db	68
    353  1917					      endm
    354  1917							;  ReadInput line
    355  1917					      macro	readstart
    356  1917					      db	69
    357  1917					      endm
    358  1917							; Startio request
    359  1917					      macro	startio
    360  1917					      db	70
    361  1917					      endm
    362  1917							; Endio
    363  1917					      macro	endio
    364  1917					      db	71
    365  1917					      endm
    366  1917							; Logical not
    367  1917					      macro	lognot
    368  1917					      db	72
    369  1917					      endm
    370  1917							; Logical OR
    371  1917					      macro	logor
    372  1917					      db	73
    373  1917					      endm
    374  1917							;Logical and
    375  1917					      macro	logand
    376  1917					      db	74
    377  1917					      endm
    378  1917							;Logical XOR
    379  1917					      macro	logxor
    380  1917					      db	75
    381  1917					      endm
    382  1917							;Wait for task to complete, or list of tasks
    383  1917					      macro	wtask
    384  1917					      db	76
    385  1917					      db	({1}-*)-1	;(addr-*)-1
    386  1917					      endm
    387  1917							;Get the current task id
    388  1917					      MACRO	taskpid
    389  1917					      db	77
    390  1917					      endm
    391  1917							;Trace the basic execution
    392  1917					      Macro	traceprogram
    393  1917					      db	78
    394  1917					      endm
    395  1917							;Do a basic program Trace
    396  1917					      Macro	debugbasic
    397  1917					      db	79
    398  1917					      endm
    399  1917
    400  1917							; Inter Process communications instructions
    401  1917					      Macro	ipcsend
    402  1917					      db	80
    403  1917					      endm
    404  1917					      Macro	ipcreceive
    405  1917					      db	81
    406  1917					      endm
    407  1917					      Macro	ipccheck
    408  1917					      db	82
    409  1917					      endm
    410  1917					      Macro	ipcio
    411  1917					      db	83
    412  1917					      endm
    413  1917					      Macro	pushmathstack
    414  1917					      db	84
    415  1917					      endm
    416  1917					      Macro	popmathstack
    417  1917					      db	85
    418  1917					      endm
    419  1917					      Macro	savemathstack
    420  1917					      db	86
    421  1917					      endm
    422  1917					      Macro	restoremathstack
    423  1917					      db	87
    424  1917					      endm
    425  1917					      Macro	incparmcount
    426  1917					      db	88
    427  1917					      endm
    428  1917					      Macro	taskgetmathstack
    429  1917					      db	89
    430  1917					      endm
    431  1917					      Macro	taskenable
    432  1917					      db	90
    433  1917					      endm
    434  1917					      Macro	tasksuspend
    435  1917					      db	91
    436  1917					      endm
    437  1917					      Macro	taskputmathptr
    438  1917					      db	92
    439  1917					      endm
    440  1917							; Test for an extension type of variable that allows access to a tasks variables
    441  1917							; Using  PID!<Var name>
    442  1917					      Macro	tstvt
    443  1917					      db	93
    444  1917					      db	({1}-*)-1	;(addr-*)-1
    445  1917					      endm
    446  1917
    447  1917							; Provide access to R2 for the IL program
    448  1917					      Macro	setr2
    449  1917					      db	94
    450  1917					      db	{1}	; R2 is only one byte
    451  1917					      endm
    452  1917							;Move stack top to temp
    453  1917					      Macro	stk2tmp
    454  1917					      db	95
    455  1917					      endm
    456  1917
    457  1917					      Macro	tmp2stk
    458  1917					      db	96
    459  1917					      endm
    460  1917
    461  1917					      Macro	tstbyte
    462  1917					      db	97
    463  1917					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1917					      dw	{2}	; address to check
    465  1917					      db	{3}	; Value to compare
    466  1917					      endm
    467  1917
    468  1917					      Macro	incvar
    469  1917					      db	98
    470  1917					      endm
    471  1917					      Macro	decvar
    472  1917					      db	99
    473  1917					      endm
    474  1917
    475  1917					      Macro	slice
    476  1917					      db	100
    477  1917					      endm
    478  1917
    479  1917
    480  1917
------- FILE mytb.asm
   2214  1917							;
   2215  1917				  -	      if	FIXED
   2216  1917				  -	      org	$1000
   2217  1917					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1917					      include	"basic.il"
      1  1917							;LET
      2  1917							;=====================================================
      3  1917							;=====================================================
      4  1917					      seg	Code
      5  1917							;=====================================================
      6  1917							; This is the IL of the BASIC (or whatever) language.
      7  1917							; Because of the way macros are implemented by as65,
      8  1917							; labels can't be on the same line as a macro
      9  1917							; invocation, so that's why labels are on separate
     10  1917							; lines.
     11  1917							;
     12  1917		       19 17	   IL	      equ	*
     13  1917
     14  1917							;THE IL CONTROL SECTION
     15  1917
     16  1917				   START
      0  1917					      INIT		;INITIALIZE
      0  1917					      db	22
      1  1917		       16		      .byte.b	22
      0  1918					      NLINE		;WRITE CRLF
      0  1918					      db	5
      1  1918		       05		      .byte.b	5
      0  1919					      ERRGOTO	CO	;where to go after an error
      0  1919					      db	31
      1  1919		       1f		      .byte.b	31
      0  191a					      dw	CO
      1  191a		       1d 19		      .word.w	CO
      0  191c					      VINIT		;clear all variables
      0  191c					      db	30
      1  191c		       1e		      .byte.b	30
     21  191d							;
     22  191d							; This is where we jump to get a line of commands or
     23  191d							; a program from the user.
     24  191d							;
     25  191d				   CO
      0  191d					      GETLINE		;WRITE PROMPT AND GET LINE
      0  191d					      db	23
      1  191d		       17		      .byte.b	23
      0  191e					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  191e					      db	34
      1  191e		       22		      .byte.b	34
      0  191f					      db	(XEC-*)-1
      1  191f		       04		      .byte.b	(XEC-*)-1
      0  1920					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1920					      db	24
      1  1920		       18		      .byte.b	24
      0  1921					      IJMP	CO
      0  1921					      db	29
      1  1921		       1d		      .byte.b	29
      0  1922					      dw	CO
      1  1922		       1d 19		      .word.w	CO
     30  1924				   XEC
      0  1924					      XINIT		;INITIALIZE
      0  1924					      db	0
      1  1924		       00		      .byte.b	0
     32  1925							;============================================================================
     33  1925							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1925							;
     35  1925				   STMT
      0  1925					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1925					      db	79
      1  1925		       4f		      .byte.b	79
      0  1926					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1926					      db	57
      1  1926		       39		      .byte.b	57
      0  1927					      db	(notirq-*)-1
      1  1927		       00		      .byte.b	(notirq-*)-1
     38  1928							;==========================================================================================
     39  1928							; Process a let statement implied or explicit.
     40  1928							;
     41  1928				   notirq
      0  1928					      TSTLET	LET	;Test if second field is = or []
      0  1928					      db	49
      1  1928		       31		      .byte.b	49
      0  1929					      db	(LET-*)-1
      1  1929		       03		      .byte.b	(LET-*)-1
      0  192a					      IJMP	DOLET	;allow the default to be let
      0  192a					      db	29
      1  192a		       1d		      .byte.b	29
      0  192b					      dw	DOLET
      1  192b		       33 19		      .word.w	DOLET
     44  192d				   LET
      0  192d					      TST	S1,"LET"	;IS STATEMENT A LET
      0  192d					      db	32
      1  192d		       20		      .byte.b	32
      0  192e					      db	(S1-*)-1
      1  192e		       21		      .byte.b	(S1-*)-1
      0  192f					      db	"LET",0
      1  192f		       4c 45 54 00	      .byte.b	"LET",0
     46  1933				   DOLET
      0  1933					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1933					      db	33
      1  1933		       21		      .byte.b	33
      0  1934					      db	(ERRVEC-*)-1
      1  1934		       ea		      .byte.b	(ERRVEC-*)-1
      0  1935					      TST	LETBE,"["
      0  1935					      db	32
      1  1935		       20		      .byte.b	32
      0  1936					      db	(LETBE-*)-1
      1  1936		       0a		      .byte.b	(LETBE-*)-1
      0  1937					      db	"[",0
      1  1937		       5b 00		      .byte.b	"[",0
      0  1939					      CALL	EXPR
      0  1939					      db	28
      1  1939		       1c		      .byte.b	28
      0  193a					      dw	EXPR
      1  193a		       c2 1b		      .word.w	EXPR
      0  193c					      TST	ERRVEC,"]"
      0  193c					      db	32
      1  193c		       20		      .byte.b	32
      0  193d					      db	(ERRVEC-*)-1
      1  193d		       e1		      .byte.b	(ERRVEC-*)-1
      0  193e					      db	"]",0
      1  193e		       5d 00		      .byte.b	"]",0
      0  1940					      SUBSCRIPT
      0  1940					      db	64
      1  1940		       40		      .byte.b	64
     52  1941				   LETBE
      0  1941					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1941					      db	32
      1  1941		       20		      .byte.b	32
      0  1942					      db	(ERRVEC-*)-1
      1  1942		       dc		      .byte.b	(ERRVEC-*)-1
      0  1943					      db	"=",0
      1  1943		       3d 00		      .byte.b	"=",0
      0  1945					      CALL	EXPR	;PLACE EXPR VALUE ON MathSTK
      0  1945					      db	28
      1  1945		       1c		      .byte.b	28
      0  1946					      dw	EXPR
      1  1946		       c2 1b		      .word.w	EXPR
      0  1948					      DONE		;REPORT ERROR IF NOT NEXT
      0  1948					      db	1
      1  1948		       01		      .byte.b	1
      0  1949					      STORE		;STORE RESULT
      0  1949					      db	19
      1  1949		       13		      .byte.b	19
      0  194a					      NXT	CO	;AND SEQUENCE TO NEXT
      0  194a					      db	6
      1  194a		       06		      .byte.b	6
      0  194b					      dw	CO
      1  194b		       1d 19		      .word.w	CO
      0  194d					      IJMP	STMT
      0  194d					      db	29
      1  194d		       1d		      .byte.b	29
      0  194e					      dw	STMT
      1  194e		       25 19		      .word.w	STMT
     59  1950							;=============================================================
     60  1950							; Inc or dec a variable
     61  1950				   S1
      0  1950					      TST	S1Dec,"INC"	;Increment variable
      0  1950					      db	32
      1  1950		       20		      .byte.b	32
      0  1951					      db	(S1Dec-*)-1
      1  1951		       0e		      .byte.b	(S1Dec-*)-1
      0  1952					      db	"INC",0
      1  1952		       49 4e 43 00	      .byte.b	"INC",0
      0  1956					      TSTV	ERRVEC
      0  1956					      db	33
      1  1956		       21		      .byte.b	33
      0  1957					      db	(ERRVEC-*)-1
      1  1957		       c7		      .byte.b	(ERRVEC-*)-1
      0  1958					      INCVAR
      0  1958					      db	98
      1  1958		       62		      .byte.b	98
      0  1959					      DONE
      0  1959					      db	1
      1  1959		       01		      .byte.b	1
      0  195a					      NXT	CO
      0  195a					      db	6
      1  195a		       06		      .byte.b	6
      0  195b					      dw	CO
      1  195b		       1d 19		      .word.w	CO
      0  195d					      IJMP	STMT
      0  195d					      db	29
      1  195d		       1d		      .byte.b	29
      0  195e					      dw	STMT
      1  195e		       25 19		      .word.w	STMT
     68  1960				   S1Dec
      0  1960					      TST	S1Iret,"DEC"	;Dec variable
      0  1960					      db	32
      1  1960		       20		      .byte.b	32
      0  1961					      db	(S1Iret-*)-1
      1  1961		       0e		      .byte.b	(S1Iret-*)-1
      0  1962					      db	"DEC",0
      1  1962		       44 45 43 00	      .byte.b	"DEC",0
      0  1966					      TSTV	ERRVEC
      0  1966					      db	33
      1  1966		       21		      .byte.b	33
      0  1967					      db	(ERRVEC-*)-1
      1  1967		       b7		      .byte.b	(ERRVEC-*)-1
      0  1968					      DECVAR
      0  1968					      db	99
      1  1968		       63		      .byte.b	99
      0  1969					      DONE
      0  1969					      db	1
      1  1969		       01		      .byte.b	1
      0  196a					      NXT	CO
      0  196a					      db	6
      1  196a		       06		      .byte.b	6
      0  196b					      dw	CO
      1  196b		       1d 19		      .word.w	CO
      0  196d					      IJMP	STMT
      0  196d					      db	29
      1  196d		       1d		      .byte.b	29
      0  196e					      dw	STMT
      1  196e		       25 19		      .word.w	STMT
     75  1970							;====================================================================
     76  1970							; iret or ireturn, Return from interupt process
     77  1970							;
     78  1970				   S1Iret
      0  1970					      TST	S1S1,"IRET"	;test return from interupt
      0  1970					      db	32
      1  1970		       20		      .byte.b	32
      0  1971					      db	(S1S1-*)-1
      1  1971		       10		      .byte.b	(S1S1-*)-1
      0  1972					      db	"IRET",0
      1  1972		       49 52 45 54*	      .byte.b	"IRET",0
      0  1977					      TST	S1Sa,"URN"
      0  1977					      db	32
      1  1977		       20		      .byte.b	32
      0  1978					      db	(S1Sa-*)-1
      1  1978		       04		      .byte.b	(S1Sa-*)-1
      0  1979					      db	"URN",0
      1  1979		       55 52 4e 00	      .byte.b	"URN",0
     81  197d				   S1Sa
      0  197d					      DONE		;Must be only thing on the line
      0  197d					      db	1
      1  197d		       01		      .byte.b	1
      0  197e					      IRET		;RESTORE LINE NUMBER OF CALL
      0  197e					      db	58
      1  197e		       3a		      .byte.b	58
      0  197f					      IJMP	STMT
      0  197f					      db	29
      1  197f		       1d		      .byte.b	29
      0  1980					      dw	STMT
      1  1980		       25 19		      .word.w	STMT
     85  1982							;=======================================================================
     86  1982							;Process if statement, if true then process all statements until end of line reached
     87  1982				   S1S1
      0  1982					      TST	S1Z,"IF"	;IF STATEMENT
      0  1982					      db	32
      1  1982		       20		      .byte.b	32
      0  1983					      db	(S1Z-*)-1
      1  1983		       11		      .byte.b	(S1Z-*)-1
      0  1984					      db	"IF",0
      1  1984		       49 46 00 	      .byte.b	"IF",0
      0  1987					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1987					      db	28
      1  1987		       1c		      .byte.b	28
      0  1988					      dw	EXPR
      1  1988		       c2 1b		      .word.w	EXPR
      0  198a					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  198a					      db	32
      1  198a		       20		      .byte.b	32
      0  198b					      db	(S1W-*)-1
      1  198b		       05		      .byte.b	(S1W-*)-1
      0  198c					      db	"THEN",0
      1  198c		       54 48 45 4e*	      .byte.b	"THEN",0
     91  1991				   S1W
      0  1991					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1991					      db	54
      1  1991		       36		      .byte.b	54
      0  1992					      IJMP	STMT
      0  1992					      db	29
      1  1992		       1d		      .byte.b	29
      0  1993					      dw	STMT
      1  1993		       25 19		      .word.w	STMT
     94  1995							;===============================================================
     95  1995							; Test for GO
     96  1995				   S1Z
      0  1995					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1995					      db	32
      1  1995		       20		      .byte.b	32
      0  1996					      db	(S2b-*)-1
      1  1996		       19		      .byte.b	(S2b-*)-1
      0  1997					      db	"GO",0
      1  1997		       47 4f 00 	      .byte.b	"GO",0
     98  199a							;================================================================
     99  199a							; process a goto
      0  199a					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  199a					      db	32
      1  199a		       20		      .byte.b	32
      0  199b					      db	(S2-*)-1
      1  199b		       07		      .byte.b	(S2-*)-1
      0  199c					      db	"TO",0
      1  199c		       54 4f 00 	      .byte.b	"TO",0
      0  199f					      CALL	EXPR	;GET LABEL
      0  199f					      db	28
      1  199f		       1c		      .byte.b	28
      0  19a0					      dw	EXPR
      1  19a0		       c2 1b		      .word.w	EXPR
      0  19a2					      XFER		;SET UP AND JUMP
      0  19a2					      db	7
      1  19a2		       07		      .byte.b	7
    103  19a3				   S2
    104  19a3							;===========================================================================
    105  19a3							; Process gosub / function
    106  19a3							;
      0  19a3					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  19a3					      db	32
      1  19a3		       20		      .byte.b	32
      0  19a4					      db	(ERRVEC-*)-1
      1  19a4		       7a		      .byte.b	(ERRVEC-*)-1
      0  19a5					      db	"SUB",0
      1  19a5		       53 55 42 00	      .byte.b	"SUB",0
      0  19a9					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  19a9					      db	28
      1  19a9		       1c		      .byte.b	28
      0  19aa					      dw	GOSUBSTATEMENT
      1  19aa		       c9 1d		      .word.w	GOSUBSTATEMENT
      0  19ac					      DONE		;ERROR IF CR NOT NEXT
      0  19ac					      db	1
      1  19ac		       01		      .byte.b	1
      0  19ad					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  19ad					      db	8
      1  19ad		       08		      .byte.b	8
      0  19ae					      db	GOSUB_RTN
      1  19ae		       01		      .byte.b	GOSUB_RTN
      0  19af					      XFER		;AND JUMP
      0  19af					      db	7
      1  19af		       07		      .byte.b	7
    112  19b0							;
    113  19b0							; End of gosub processing
    114  19b0							;==========================================================================
    115  19b0							; Return from a gosub
    116  19b0				   S2b
      0  19b0					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  19b0					      db	32
      1  19b0		       20		      .byte.b	32
      0  19b1					      db	(S3-*)-1
      1  19b1		       36		      .byte.b	(S3-*)-1
      0  19b2					      db	"RE",0
      1  19b2		       52 45 00 	      .byte.b	"RE",0
      0  19b5					      TST	S2a,"T"
      0  19b5					      db	32
      1  19b5		       20		      .byte.b	32
      0  19b6					      db	(S2a-*)-1
      1  19b6		       27		      .byte.b	(S2a-*)-1
      0  19b7					      db	"T",0
      1  19b7		       54 00		      .byte.b	"T",0
      0  19b9					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  19b9					      db	32
      1  19b9		       20		      .byte.b	32
      0  19ba					      db	(S2aa-*)-1
      1  19ba		       04		      .byte.b	(S2aa-*)-1
      0  19bb					      db	"URN",0
      1  19bb		       55 52 4e 00	      .byte.b	"URN",0
    120  19bf				   S2aa
      0  19bf					      SETR2	0	; Default no return value
      0  19bf					      db	94
      1  19bf		       5e		      .byte.b	94
      0  19c0					      db	0
      1  19c0		       00		      .byte.b	0
      0  19c1					      TST	S2RetDone,"("	; Check if we will return some value
      0  19c1					      db	32
      1  19c1		       20		      .byte.b	32
      0  19c2					      db	(S2RetDone-*)-1
      1  19c2		       0b		      .byte.b	(S2RetDone-*)-1
      0  19c3					      db	"(",0
      1  19c3		       28 00		      .byte.b	"(",0
      0  19c5					      SETR2	1	; Indicate a return value provided
      0  19c5					      db	94
      1  19c5		       5e		      .byte.b	94
      0  19c6					      db	1
      1  19c6		       01		      .byte.b	1
      0  19c7					      CALL	EXPR
      0  19c7					      db	28
      1  19c7		       1c		      .byte.b	28
      0  19c8					      dw	EXPR
      1  19c8		       c2 1b		      .word.w	EXPR
      0  19ca					      TST	ERRVEC,")"	; Now a value is on the stack
      0  19ca					      db	32
      1  19ca		       20		      .byte.b	32
      0  19cb					      db	(ERRVEC-*)-1
      1  19cb		       53		      .byte.b	(ERRVEC-*)-1
      0  19cc					      db	")",0
      1  19cc		       29 00		      .byte.b	")",0
    126  19ce
    127  19ce				   S2RetDone
      0  19ce					      DONE		; MUST BE CR or :
      0  19ce					      db	1
      1  19ce		       01		      .byte.b	1
      0  19cf					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  19cf					      db	9
      1  19cf		       09		      .byte.b	9
      0  19d0					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  19d0					      db	97
      1  19d0		       61		      .byte.b	97
      0  19d1					      db	(S2RetFunc-*)-1
      1  19d1		       09		      .byte.b	(S2RetFunc-*)-1
      0  19d2					      dw	R2
      1  19d2		       58 00		      .word.w	R2
      0  19d4					      db	1
      1  19d4		       01		      .byte.b	1
      0  19d5					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  19d5					      db	6
      1  19d5		       06		      .byte.b	6
      0  19d6					      dw	CO
      1  19d6		       1d 19		      .word.w	CO
      0  19d8					      IJMP	STMT
      0  19d8					      db	29
      1  19d8		       1d		      .byte.b	29
      0  19d9					      dw	STMT
      1  19d9		       25 19		      .word.w	STMT
    133  19db				   S2RetFunc
      0  19db					      IJMP	GOFNRet	; Back into the Function
      0  19db					      db	29
      1  19db		       1d		      .byte.b	29
      0  19dc					      dw	GOFNRet
      1  19dc		       9f 1d		      .word.w	GOFNRet
    135  19de							;
    136  19de							; End of return from gosub
    137  19de							;============================================================================
    138  19de							; Process REM statement
    139  19de							;
    140  19de				   S2a
      0  19de					      TST	S3,"M"	;REMark.  Skip rest of line
      0  19de					      db	32
      1  19de		       20		      .byte.b	32
      0  19df					      db	(S3-*)-1
      1  19df		       08		      .byte.b	(S3-*)-1
      0  19e0					      db	"M",0
      1  19e0		       4d 00		      .byte.b	"M",0
      0  19e2					      NXT	CO
      0  19e2					      db	6
      1  19e2		       06		      .byte.b	6
      0  19e3					      dw	CO
      1  19e3		       1d 19		      .word.w	CO
      0  19e5					      IJMP	STMT
      0  19e5					      db	29
      1  19e5		       1d		      .byte.b	29
      0  19e6					      dw	STMT
      1  19e6		       25 19		      .word.w	STMT
    144  19e8							;============================================================================
    145  19e8							; Print statement
    146  19e8							;
    147  19e8				   S3
      0  19e8					      TST	S3a,"?"	; ? symonym for print
      0  19e8					      db	32
      1  19e8		       20		      .byte.b	32
      0  19e9					      db	(S3a-*)-1
      1  19e9		       05		      .byte.b	(S3a-*)-1
      0  19ea					      db	"?",0
      1  19ea		       3f 00		      .byte.b	"?",0
      0  19ec					      IJMP	S4S
      0  19ec					      db	29
      1  19ec		       1d		      .byte.b	29
      0  19ed					      dw	S4S
      1  19ed		       fa 19		      .word.w	S4S
    150  19ef				   S3a
      0  19ef					      TST	S8,"PR"	;allow short form of print
      0  19ef					      db	32
      1  19ef		       20		      .byte.b	32
      0  19f0					      db	(S8-*)-1
      1  19f0		       5b		      .byte.b	(S8-*)-1
      0  19f1					      db	"PR",0
      1  19f1		       50 52 00 	      .byte.b	"PR",0
      0  19f4					      TST	S4S,"INT"	;PRINT
      0  19f4					      db	32
      1  19f4		       20		      .byte.b	32
      0  19f5					      db	(S4S-*)-1
      1  19f5		       04		      .byte.b	(S4S-*)-1
      0  19f6					      db	"INT",0
      1  19f6		       49 4e 54 00	      .byte.b	"INT",0
    153  19fa				   S4S
      0  19fa					      STARTIO		;Lock task until io completes
      0  19fa					      db	70
      1  19fa		       46		      .byte.b	70
    155  19fb				   S4
      0  19fb					      TSTDONE	S4a	;Test if we just want crlf printed
      0  19fb					      db	50
      1  19fb		       32		      .byte.b	50
      0  19fc					      db	(S4a-*)-1
      1  19fc		       03		      .byte.b	(S4a-*)-1
      0  19fd					      IJMP	S6
      0  19fd					      db	29
      1  19fd		       1d		      .byte.b	29
      0  19fe					      dw	S6
      1  19fe		       16 1a		      .word.w	S6
    158  1a00
    159  1a00				   S4a
      0  1a00					      TSTSTR	S7	;TEST FOR QUOTED String
      0  1a00					      db	55
      1  1a00		       37		      .byte.b	55
      0  1a01					      db	(S7-*)-1
      1  1a01		       21		      .byte.b	(S7-*)-1
      0  1a02					      PRS		;PRINT STRING
      0  1a02					      db	2
      1  1a02		       02		      .byte.b	2
    162  1a03				   S5
      0  1a03					      TST	S6A,COMMA	;IS THERE MORE?
      0  1a03					      db	32
      1  1a03		       20		      .byte.b	32
      0  1a04					      db	(S6A-*)-1
      1  1a04		       08		      .byte.b	(S6A-*)-1
      0  1a05					      db	COMMA,0
      1  1a05		       2c 00		      .byte.b	COMMA,0
      0  1a07					      SPC		;SPACE TO NEXT ZONE
      0  1a07					      db	4
      1  1a07		       04		      .byte.b	4
      0  1a08					      TSTDONE	S4	;Not end of line jump back
      0  1a08					      db	50
      1  1a08		       32		      .byte.b	50
      0  1a09					      db	(S4-*)-1
      1  1a09		       f1		      .byte.b	(S4-*)-1
      0  1a0a					      IJMP	S6Z	;YES JUMP BACK
      0  1a0a					      db	29
      1  1a0a		       1d		      .byte.b	29
      0  1a0b					      dw	S6Z
      1  1a0b		       18 1a		      .word.w	S6Z
    167  1a0d
    168  1a0d							;
    169  1a0d							; If a semicolon, don't do anything.
    170  1a0d							;
    171  1a0d				   S6A
      0  1a0d					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  1a0d					      db	32
      1  1a0d		       20		      .byte.b	32
      0  1a0e					      db	(S6-*)-1
      1  1a0e		       07		      .byte.b	(S6-*)-1
      0  1a0f					      db	SEMICOLON,0
      1  1a0f		       3b 00		      .byte.b	SEMICOLON,0
      0  1a11					      TSTDONE	S4	;Jump Back if not end of line
      0  1a11					      db	50
      1  1a11		       32		      .byte.b	50
      0  1a12					      db	(S4-*)-1
      1  1a12		       e8		      .byte.b	(S4-*)-1
      0  1a13					      IJMP	S6Z
      0  1a13					      db	29
      1  1a13		       1d		      .byte.b	29
      0  1a14					      dw	S6Z
      1  1a14		       18 1a		      .word.w	S6Z
    175  1a16				   S6
      0  1a16					      DONE		;ERROR IF CR NOT NEXT
      0  1a16					      db	1
      1  1a16		       01		      .byte.b	1
      0  1a17					      NLINE
      0  1a17					      db	5
      1  1a17		       05		      .byte.b	5
    178  1a18				   S6Z
      0  1a18					      ENDIO		;release task io completed
      0  1a18					      db	71
      1  1a18		       47		      .byte.b	71
      0  1a19					      NXT	CO	;exit here if , or ; at end of print
      0  1a19					      db	6
      1  1a19		       06		      .byte.b	6
      0  1a1a					      dw	CO
      1  1a1a		       1d 19		      .word.w	CO
      0  1a1c					      IJMP	STMT
      0  1a1c					      db	29
      1  1a1c		       1d		      .byte.b	29
      0  1a1d					      dw	STMT
      1  1a1d		       25 19		      .word.w	STMT
    182  1a1f							;
    183  1a1f							; A jump for code too far away for relative branch
    184  1a1f							;
    185  1a1f				   ERRVEC
      0  1a1f					      ENDIO
      0  1a1f					      db	71
      1  1a1f		       47		      .byte.b	71
      0  1a20					      IJMP	UNKNOWN
      0  1a20					      db	29
      1  1a20		       1d		      .byte.b	29
      0  1a21					      dw	UNKNOWN
      1  1a21		       be 1b		      .word.w	UNKNOWN
    188  1a23							;
    189  1a23							; Get here if there is an expression to print
    190  1a23				   S7
      0  1a23					      TST	S7AUnsigned,"$"
      0  1a23					      db	32
      1  1a23		       20		      .byte.b	32
      0  1a24					      db	(S7AUnsigned-*)-1
      1  1a24		       09		      .byte.b	(S7AUnsigned-*)-1
      0  1a25					      db	"$",0
      1  1a25		       24 00		      .byte.b	"$",0
      0  1a27					      CALL	EXPR
      0  1a27					      db	28
      1  1a27		       1c		      .byte.b	28
      0  1a28					      dw	EXPR
      1  1a28		       c2 1b		      .word.w	EXPR
      0  1a2a					      HEXPRT
      0  1a2a					      db	67
      1  1a2a		       43		      .byte.b	67
      0  1a2b					      IJMP	S5
      0  1a2b					      db	29
      1  1a2b		       1d		      .byte.b	29
      0  1a2c					      dw	S5
      1  1a2c		       03 1a		      .word.w	S5
    195  1a2e
    196  1a2e				   S7AUnsigned
    197  1a2e
      0  1a2e					      TST	S7A,"%"
      0  1a2e					      db	32
      1  1a2e		       20		      .byte.b	32
      0  1a2f					      db	(S7A-*)-1
      1  1a2f		       0b		      .byte.b	(S7A-*)-1
      0  1a30					      db	"%",0
      1  1a30		       25 00		      .byte.b	"%",0
      0  1a32					      CALL	EXPR
      0  1a32					      db	28
      1  1a32		       1c		      .byte.b	28
      0  1a33					      dw	EXPR
      1  1a33		       c2 1b		      .word.w	EXPR
      0  1a35					      SETR2	1
      0  1a35					      db	94
      1  1a35		       5e		      .byte.b	94
      0  1a36					      db	1
      1  1a36		       01		      .byte.b	1
      0  1a37					      PRN
      0  1a37					      db	3
      1  1a37		       03		      .byte.b	3
      0  1a38					      IJMP	S5
      0  1a38					      db	29
      1  1a38		       1d		      .byte.b	29
      0  1a39					      dw	S5
      1  1a39		       03 1a		      .word.w	S5
    203  1a3b
    204  1a3b				   S7A
    205  1a3b
      0  1a3b					      CALL	EXPR
      0  1a3b					      db	28
      1  1a3b		       1c		      .byte.b	28
      0  1a3c					      dw	EXPR
      1  1a3c		       c2 1b		      .word.w	EXPR
      0  1a3e					      TST	S7B,"$"
      0  1a3e					      db	32
      1  1a3e		       20		      .byte.b	32
      0  1a3f					      db	(S7B-*)-1
      1  1a3f		       06		      .byte.b	(S7B-*)-1
      0  1a40					      db	"$",0
      1  1a40		       24 00		      .byte.b	"$",0
      0  1a42					      PUTCHAR
      0  1a42					      db	52
      1  1a42		       34		      .byte.b	52
      0  1a43					      IJMP	S5
      0  1a43					      db	29
      1  1a43		       1d		      .byte.b	29
      0  1a44					      dw	S5
      1  1a44		       03 1a		      .word.w	S5
    210  1a46
    211  1a46				   S7B
      0  1a46					      SETR2	0
      0  1a46					      db	94
      1  1a46		       5e		      .byte.b	94
      0  1a47					      db	0
      1  1a47		       00		      .byte.b	0
      0  1a48					      PRN		;PRINT IT
      0  1a48					      db	3
      1  1a48		       03		      .byte.b	3
      0  1a49					      IJMP	S5	;IS THERE MORE?
      0  1a49					      db	29
      1  1a49		       1d		      .byte.b	29
      0  1a4a					      dw	S5
      1  1a4a		       03 1a		      .word.w	S5
    215  1a4c							;
    216  1a4c							;===========================================================
    217  1a4c							; PROCESS ALL THE TAST STATEMENTS
    218  1a4c							;
    219  1a4c				   S8
      0  1a4c					      TST	S8a1,"TASK"	; Any Task Command
      0  1a4c					      db	32
      1  1a4c		       20		      .byte.b	32
      0  1a4d					      db	(S8a1-*)-1
      1  1a4d		       4b		      .byte.b	(S8a1-*)-1
      0  1a4e					      db	"TASK",0
      1  1a4e		       54 41 53 4b*	      .byte.b	"TASK",0
    221  1a53							;==========================================================
    222  1a53							; End of TASK process
    223  1a53							;
      0  1a53					      TST	S8G,"E"
      0  1a53					      db	32
      1  1a53		       20		      .byte.b	32
      0  1a54					      db	(S8G-*)-1
      1  1a54		       1a		      .byte.b	(S8G-*)-1
      0  1a55					      db	"E",0
      1  1a55		       45 00		      .byte.b	"E",0
      0  1a57					      TST	S8NoParm,"("
      0  1a57					      db	32
      1  1a57		       20		      .byte.b	32
      0  1a58					      db	(S8NoParm-*)-1
      1  1a58		       0e		      .byte.b	(S8NoParm-*)-1
      0  1a59					      db	"(",0
      1  1a59		       28 00		      .byte.b	"(",0
      0  1a5b					      CALL	EXPR
      0  1a5b					      db	28
      1  1a5b		       1c		      .byte.b	28
      0  1a5c					      dw	EXPR
      1  1a5c		       c2 1b		      .word.w	EXPR
      0  1a5e					      TST	UNKNOWNLnk,")"
      0  1a5e					      db	32
      1  1a5e		       20		      .byte.b	32
      0  1a5f					      db	(UNKNOWNLnk-*)-1
      1  1a5f		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1a60					      db	")",0
      1  1a60		       29 00		      .byte.b	")",0
      0  1a62					      ETASK
      0  1a62					      db	62
      1  1a62		       3e		      .byte.b	62
      0  1a63					      DONE
      0  1a63					      db	1
      1  1a63		       01		      .byte.b	1
      0  1a64					      IJMP	STMT
      0  1a64					      db	29
      1  1a64		       1d		      .byte.b	29
      0  1a65					      dw	STMT
      1  1a65		       25 19		      .word.w	STMT
    231  1a67				   S8NoParm
      0  1a67					      LIT	0
      0  1a67					      db	27
      1  1a67		       1b		      .byte.b	27
      0  1a68					      dw	0
      1  1a68		       00 00		      .word.w	0
      0  1a6a					      ETASK
      0  1a6a					      db	62
      1  1a6a		       3e		      .byte.b	62
      0  1a6b					      DONE		; Must be last thing on a line
      0  1a6b					      db	1
      1  1a6b		       01		      .byte.b	1
      0  1a6c					      IJMP	STMT
      0  1a6c					      db	29
      1  1a6c		       1d		      .byte.b	29
      0  1a6d					      dw	STMT
      1  1a6d		       25 19		      .word.w	STMT
    236  1a6f							;
    237  1a6f							;===========================================================
    238  1a6f							; The task gives up the rest of the cycles
    239  1a6f				   S8G
      0  1a6f					      TST	S8a,"N"	;Next task
      0  1a6f					      db	32
      1  1a6f		       20		      .byte.b	32
      0  1a70					      db	(S8a-*)-1
      1  1a70		       09		      .byte.b	(S8a-*)-1
      0  1a71					      db	"N",0
      1  1a71		       4e 00		      .byte.b	"N",0
      0  1a73					      NTASK
      0  1a73					      db	63
      1  1a73		       3f		      .byte.b	63
      0  1a74					      NXT	CO	;Next statement to execute
      0  1a74					      db	6
      1  1a74		       06		      .byte.b	6
      0  1a75					      dw	CO
      1  1a75		       1d 19		      .word.w	CO
      0  1a77					      IJMP	STMT
      0  1a77					      db	29
      1  1a77		       1d		      .byte.b	29
      0  1a78					      dw	STMT
      1  1a78		       25 19		      .word.w	STMT
    244  1a7a							;
    245  1a7a							;===========================================================
    246  1a7a							; Waits for a task or list of tasks to complete
    247  1a7a				   S8a
      0  1a7a					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1a7a					      db	32
      1  1a7a		       20		      .byte.b	32
      0  1a7b					      db	(S8TASKNO-*)-1
      1  1a7b		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1a7c					      db	"W(",0
      1  1a7c		       57 28 00 	      .byte.b	"W(",0
    249  1a7f				   S8TSK
      0  1a7f					      Call	EXPR	;Gets the PID of task to wait for
      0  1a7f					      db	28
      1  1a7f		       1c		      .byte.b	28
      0  1a80					      dw	EXPR
      1  1a80		       c2 1b		      .word.w	EXPR
    251  1a82				   S8LOOP
      0  1a82					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1a82					      db	76
      1  1a82		       4c		      .byte.b	76
      0  1a83					      db	(S8LOOP-*)-1
      1  1a83		       fe		      .byte.b	(S8LOOP-*)-1
      0  1a84					      TST	S8aa,COMMA	;Checks for more tasks
      0  1a84					      db	32
      1  1a84		       20		      .byte.b	32
      0  1a85					      db	(S8aa-*)-1
      1  1a85		       05		      .byte.b	(S8aa-*)-1
      0  1a86					      db	COMMA,0
      1  1a86		       2c 00		      .byte.b	COMMA,0
      0  1a88					      IJMP	S8TSK	;Go for the next task number
      0  1a88					      db	29
      1  1a88		       1d		      .byte.b	29
      0  1a89					      dw	S8TSK
      1  1a89		       7f 1a		      .word.w	S8TSK
    255  1a8b				   S8aa
      0  1a8b					      TST	S8TASKNO,")"	;end of list
      0  1a8b					      db	32
      1  1a8b		       20		      .byte.b	32
      0  1a8c					      db	(S8TASKNO-*)-1
      1  1a8c		       09		      .byte.b	(S8TASKNO-*)-1
      0  1a8d					      db	")",0
      1  1a8d		       29 00		      .byte.b	")",0
      0  1a8f					      DONE
      0  1a8f					      db	1
      1  1a8f		       01		      .byte.b	1
      0  1a90					      NXT	CO
      0  1a90					      db	6
      1  1a90		       06		      .byte.b	6
      0  1a91					      dw	CO
      1  1a91		       1d 19		      .word.w	CO
      0  1a93					      IJMP	STMT	;Next Statement
      0  1a93					      db	29
      1  1a93		       1d		      .byte.b	29
      0  1a94					      dw	STMT
      1  1a94		       25 19		      .word.w	STMT
    260  1a96				   S8TASKNO
    261  1a96
    262  1a96				   UNKNOWNLnk
      0  1a96					      iJMP	UNKNOWN
      0  1a96					      db	29
      1  1a96		       1d		      .byte.b	29
      0  1a97					      dw	UNKNOWN
      1  1a97		       be 1b		      .word.w	UNKNOWN
    264  1a99
    265  1a99							;
    266  1a99							;===========================================================
    267  1a99							; Update a memory location with a value
    268  1a99							;  Use @[offset] to write a word value to memory
    269  1a99							;
    270  1a99				   S8a1
      0  1a99					      TST	S8b,"POKE("	; Poke a value into memory
      0  1a99					      db	32
      1  1a99		       20		      .byte.b	32
      0  1a9a					      db	(S8b-*)-1
      1  1a9a		       1c		      .byte.b	(S8b-*)-1
      0  1a9b					      db	"POKE(",0
      1  1a9b		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1aa1					      CALL	EXPR	; Get address to write to
      0  1aa1					      db	28
      1  1aa1		       1c		      .byte.b	28
      0  1aa2					      dw	EXPR
      1  1aa2		       c2 1b		      .word.w	EXPR
      0  1aa4					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1aa4					      db	32
      1  1aa4		       20		      .byte.b	32
      0  1aa5					      db	(UNKNOWNV-*)-1
      1  1aa5		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1aa6					      db	COMMA,0
      1  1aa6		       2c 00		      .byte.b	COMMA,0
      0  1aa8					      CALL	EXPR	; Get the value to poke
      0  1aa8					      db	28
      1  1aa8		       1c		      .byte.b	28
      0  1aa9					      dw	EXPR
      1  1aa9		       c2 1b		      .word.w	EXPR
      0  1aab					      TST	UNKNOWNV,")"	; closing bracket
      0  1aab					      db	32
      1  1aab		       20		      .byte.b	32
      0  1aac					      db	(UNKNOWNV-*)-1
      1  1aac		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1aad					      db	")",0
      1  1aad		       29 00		      .byte.b	")",0
      0  1aaf					      POKEMEM
      0  1aaf					      db	47
      1  1aaf		       2f		      .byte.b	47
      0  1ab0					      DONE
      0  1ab0					      db	1
      1  1ab0		       01		      .byte.b	1
      0  1ab1					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1ab1					      db	6
      1  1ab1		       06		      .byte.b	6
      0  1ab2					      dw	CO
      1  1ab2		       1d 19		      .word.w	CO
      0  1ab4					      IJMP	STMT
      0  1ab4					      db	29
      1  1ab4		       1d		      .byte.b	29
      0  1ab5					      dw	STMT
      1  1ab5		       25 19		      .word.w	STMT
    280  1ab7							;================================================================
    281  1ab7							; Write a single byte to the output device
    282  1ab7							;
    283  1ab7				   S8b
      0  1ab7					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1ab7					      db	32
      1  1ab7		       20		      .byte.b	32
      0  1ab8					      db	(S8c-*)-1
      1  1ab8		       11		      .byte.b	(S8c-*)-1
      0  1ab9					      db	"PUTCH",0
      1  1ab9		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1abf					      CALL	EXPR
      0  1abf					      db	28
      1  1abf		       1c		      .byte.b	28
      0  1ac0					      dw	EXPR
      1  1ac0		       c2 1b		      .word.w	EXPR
      0  1ac2					      PUTCHAR
      0  1ac2					      db	52
      1  1ac2		       34		      .byte.b	52
      0  1ac3					      DONE
      0  1ac3					      db	1
      1  1ac3		       01		      .byte.b	1
      0  1ac4					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1ac4					      db	6
      1  1ac4		       06		      .byte.b	6
      0  1ac5					      dw	CO
      1  1ac5		       1d 19		      .word.w	CO
      0  1ac7					      IJMP	STMT
      0  1ac7					      db	29
      1  1ac7		       1d		      .byte.b	29
      0  1ac8					      dw	STMT
      1  1ac8		       25 19		      .word.w	STMT
    290  1aca							;================================================================
    291  1aca							; Clear the screen lines
    292  1aca							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    293  1aca							;
    294  1aca				   S8c
      0  1aca					      TST	S9,"CLS"	;Clear the screen
      0  1aca					      db	32
      1  1aca		       20		      .byte.b	32
      0  1acb					      db	(S9-*)-1
      1  1acb		       0b		      .byte.b	(S9-*)-1
      0  1acc					      db	"CLS",0
      1  1acc		       43 4c 53 00	      .byte.b	"CLS",0
      0  1ad0					      CLEARSCREEN
      0  1ad0					      db	46
      1  1ad0		       2e		      .byte.b	46
      0  1ad1					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1ad1					      db	6
      1  1ad1		       06		      .byte.b	6
      0  1ad2					      dw	CO
      1  1ad2		       1d 19		      .word.w	CO
      0  1ad4					      IJMP	STMT
      0  1ad4					      db	29
      1  1ad4		       1d		      .byte.b	29
      0  1ad5					      dw	STMT
      1  1ad5		       25 19		      .word.w	STMT
    299  1ad7							;==================================================================
    300  1ad7							; Get input from the terminal
    301  1ad7							;   Reads from the currently active input device
    302  1ad7							;
    303  1ad7				   S9
      0  1ad7					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1ad7					      db	32
      1  1ad7		       20		      .byte.b	32
      0  1ad8					      db	(S13-*)-1
      1  1ad8		       2a		      .byte.b	(S13-*)-1
      0  1ad9					      db	"INPUT",0
      1  1ad9		       49 4e 50 55*	      .byte.b	"INPUT",0
    305  1adf				   S10
      0  1adf					      TSTSTR	S10A	;If there is a string print the prompt
      0  1adf					      db	55
      1  1adf		       37		      .byte.b	55
      0  1ae0					      db	(S10A-*)-1
      1  1ae0		       05		      .byte.b	(S10A-*)-1
      0  1ae1					      PRS
      0  1ae1					      db	2
      1  1ae1		       02		      .byte.b	2
      0  1ae2					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1ae2					      db	32
      1  1ae2		       20		      .byte.b	32
      0  1ae3					      db	(S10Z-*)-1
      1  1ae3		       15		      .byte.b	(S10Z-*)-1
      0  1ae4					      db	SEMICOLON,0
      1  1ae4		       3b 00		      .byte.b	SEMICOLON,0
    309  1ae6				   S10A
      0  1ae6					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1ae6					      db	33
      1  1ae6		       21		      .byte.b	33
      0  1ae7					      db	(UNKNOWN-*)-1
      1  1ae7		       d6		      .byte.b	(UNKNOWN-*)-1
      0  1ae8					      TST	S10A1,DOLLAR
      0  1ae8					      db	32
      1  1ae8		       20		      .byte.b	32
      0  1ae9					      db	(S10A1-*)-1
      1  1ae9		       06		      .byte.b	(S10A1-*)-1
      0  1aea					      db	DOLLAR,0
      1  1aea		       24 00		      .byte.b	DOLLAR,0
      0  1aec					      INSTR		;Move character From tty to AESTK
      0  1aec					      db	59
      1  1aec		       3b		      .byte.b	59
      0  1aed					      IJMP	S10A2
      0  1aed					      db	29
      1  1aed		       1d		      .byte.b	29
      0  1aee					      dw	S10A2
      1  1aee		       f1 1a		      .word.w	S10A2
    314  1af0				   S10A1
      0  1af0					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1af0					      db	11
      1  1af0		       0b		      .byte.b	11
    316  1af1				   S10A2
      0  1af1					      STORE		;STORE IT
      0  1af1					      db	19
      1  1af1		       13		      .byte.b	19
      0  1af2					      TST	S11,COMMA	;IS THERE MORE?
      0  1af2					      db	32
      1  1af2		       20		      .byte.b	32
      0  1af3					      db	(S11-*)-1
      1  1af3		       08		      .byte.b	(S11-*)-1
      0  1af4					      db	COMMA,0
      1  1af4		       2c 00		      .byte.b	COMMA,0
      0  1af6					      IJMP	S10	;YES
      0  1af6					      db	29
      1  1af6		       1d		      .byte.b	29
      0  1af7					      dw	S10
      1  1af7		       df 1a		      .word.w	S10
    320  1af9				   S10Z
      0  1af9					      iJMP	UNKNOWN
      0  1af9					      db	29
      1  1af9		       1d		      .byte.b	29
      0  1afa					      dw	UNKNOWN
      1  1afa		       be 1b		      .word.w	UNKNOWN
    322  1afc				   S11
      0  1afc					      DONE		;MUST BE CR
      0  1afc					      db	1
      1  1afc		       01		      .byte.b	1
      0  1afd					      NXT	CO	;SEQUENCE TO NEXT
      0  1afd					      db	6
      1  1afd		       06		      .byte.b	6
      0  1afe					      dw	CO
      1  1afe		       1d 19		      .word.w	CO
      0  1b00					      IJMP	STMT
      0  1b00					      db	29
      1  1b00		       1d		      .byte.b	29
      0  1b01					      dw	STMT
      1  1b01		       25 19		      .word.w	STMT
    326  1b03							;=====================================================================
    327  1b03							; End of program, return to command line process
    328  1b03							; Main Task may also use taske or return to stopped
    329  1b03							;
    330  1b03				   S13
      0  1b03					      TST	S14,"END"
      0  1b03					      db	32
      1  1b03		       20		      .byte.b	32
      0  1b04					      db	(S14-*)-1
      1  1b04		       08		      .byte.b	(S14-*)-1
      0  1b05					      db	"END",0
      1  1b05		       45 4e 44 00	      .byte.b	"END",0
      0  1b09					      FIN
      0  1b09					      db	12
      1  1b09		       0c		      .byte.b	12
    333  1b0a
    334  1b0a				   UNKNOWNV
      0  1b0a					      IJMP	UNKNOWN
      0  1b0a					      db	29
      1  1b0a		       1d		      .byte.b	29
      0  1b0b					      dw	UNKNOWN
      1  1b0b		       be 1b		      .word.w	UNKNOWN
    336  1b0d							;====================================================================
    337  1b0d							; IRQ <IRQ-HANDLER-Line expression>
    338  1b0d							;   Specify a line number subroutine to call when an interupt is processed
    339  1b0d							;   These subroutines must use iret to return.
    340  1b0d							;
    341  1b0d				   S14
      0  1b0d					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  1b0d					      db	32
      1  1b0d		       20		      .byte.b	32
      0  1b0e					      db	(S14Z-*)-1
      1  1b0e		       0f		      .byte.b	(S14Z-*)-1
      0  1b0f					      db	"IRQ",0
      1  1b0f		       49 52 51 00	      .byte.b	"IRQ",0
      0  1b13					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1b13					      db	28
      1  1b13		       1c		      .byte.b	28
      0  1b14					      dw	EXPR
      1  1b14		       c2 1b		      .word.w	EXPR
      0  1b16					      DONE		;must be CR
      0  1b16					      db	1
      1  1b16		       01		      .byte.b	1
      0  1b17					      SETIRQ		;Set the line number now
      0  1b17					      db	56
      1  1b17		       38		      .byte.b	56
      0  1b18					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1b18					      db	6
      1  1b18		       06		      .byte.b	6
      0  1b19					      dw	CO
      1  1b19		       1d 19		      .word.w	CO
      0  1b1b					      IJMP	STMT
      0  1b1b					      db	29
      1  1b1b		       1d		      .byte.b	29
      0  1b1c					      dw	STMT
      1  1b1c		       25 19		      .word.w	STMT
    348  1b1e
    349  1b1e							;=========================================================================
    350  1b1e							; KILL PID-expression	 kill a running task
    351  1b1e							;  ignored of task has already stopped
    352  1b1e							;
    353  1b1e				   S14Z
      0  1b1e					      TST	S14S1,"KILL"	; Kill A running Task
      0  1b1e					      db	32
      1  1b1e		       20		      .byte.b	32
      0  1b1f					      db	(S14S1-*)-1
      1  1b1f		       10		      .byte.b	(S14S1-*)-1
      0  1b20					      db	"KILL",0
      1  1b20		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  1b25					      CALL	EXPR
      0  1b25					      db	28
      1  1b25		       1c		      .byte.b	28
      0  1b26					      dw	EXPR
      1  1b26		       c2 1b		      .word.w	EXPR
      0  1b28					      DONE
      0  1b28					      db	1
      1  1b28		       01		      .byte.b	1
      0  1b29					      TASKKILL
      0  1b29					      db	65
      1  1b29		       41		      .byte.b	65
      0  1b2a					      NXT	CO
      0  1b2a					      db	6
      1  1b2a		       06		      .byte.b	6
      0  1b2b					      dw	CO
      1  1b2b		       1d 19		      .word.w	CO
      0  1b2d					      IJMP	STMT
      0  1b2d					      db	29
      1  1b2d		       1d		      .byte.b	29
      0  1b2e					      dw	STMT
      1  1b2e		       25 19		      .word.w	STMT
    360  1b30
    361  1b30							;============================================================================
    362  1b30							; List all program lines
    363  1b30							;
    364  1b30				   S14S1
      0  1b30					      TST	S15,"LIST"	;LIST COMMAND
      0  1b30					      db	32
      1  1b30		       20		      .byte.b	32
      0  1b31					      db	(S15-*)-1
      1  1b31		       0a		      .byte.b	(S15-*)-1
      0  1b32					      db	"LIST",0
      1  1b32		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1b37					      DONE
      0  1b37					      db	1
      1  1b37		       01		      .byte.b	1
      0  1b38					      LST
      0  1b38					      db	21
      1  1b38		       15		      .byte.b	21
      0  1b39					      IJMP	CO
      0  1b39					      db	29
      1  1b39		       1d		      .byte.b	29
      0  1b3a					      dw	CO
      1  1b3a		       1d 19		      .word.w	CO
    369  1b3c							;=======================================================================
    370  1b3c							;RUN begin to executed the program in memory
    371  1b3c							;
    372  1b3c				   S15
      0  1b3c					      TST	S16,"RUN"	;RUN COMMAND
      0  1b3c					      db	32
      1  1b3c		       20		      .byte.b	32
      0  1b3d					      db	(S16-*)-1
      1  1b3d		       0d		      .byte.b	(S16-*)-1
      0  1b3e					      db	"RUN",0
      1  1b3e		       52 55 4e 00	      .byte.b	"RUN",0
      0  1b42					      DONE
      0  1b42					      db	1
      1  1b42		       01		      .byte.b	1
      0  1b43					      VINIT		;clear variables
      0  1b43					      db	30
      1  1b43		       1e		      .byte.b	30
      0  1b44					      LIT	1	;GOTO line 1
      0  1b44					      db	27
      1  1b44		       1b		      .byte.b	27
      0  1b45					      dw	1
      1  1b45		       01 00		      .word.w	1
      0  1b47					      XFER		;Bob's addition
      0  1b47					      db	7
      1  1b47		       07		      .byte.b	7
    378  1b48							; EXIT
      0  1b48					      IJMP	STMT	;and run!
      0  1b48					      db	29
      1  1b48		       1d		      .byte.b	29
      0  1b49					      dw	STMT
      1  1b49		       25 19		      .word.w	STMT
    380  1b4b							;=========================================================================
    381  1b4b							;Clear the program memory, delete all proram lines
    382  1b4b							;
    383  1b4b				   S16
      0  1b4b					      TST	S16A,"NEW"	;clear program
      0  1b4b					      db	32
      1  1b4b		       20		      .byte.b	32
      0  1b4c					      db	(S16A-*)-1
      1  1b4c		       08		      .byte.b	(S16A-*)-1
      0  1b4d					      db	"NEW",0
      1  1b4d		       4e 45 57 00	      .byte.b	"NEW",0
      0  1b51					      DONE
      0  1b51					      db	1
      1  1b51		       01		      .byte.b	1
      0  1b52					      IJMP	START
      0  1b52					      db	29
      1  1b52		       1d		      .byte.b	29
      0  1b53					      dw	START
      1  1b53		       17 19		      .word.w	START
    387  1b55
    388  1b55							;========================================================================
    389  1b55							; Slice(slice legth expression)
    390  1b55							;   set the length of time between task switches
    391  1b55							;
    392  1b55				   S16A
      0  1b55					      TST	S16Trace,"SLICE"
      0  1b55					      db	32
      1  1b55		       20		      .byte.b	32
      0  1b56					      db	(S16Trace-*)-1
      1  1b56		       11		      .byte.b	(S16Trace-*)-1
      0  1b57					      db	"SLICE",0
      1  1b57		       53 4c 49 43*	      .byte.b	"SLICE",0
      0  1b5d					      CALL	EXPR
      0  1b5d					      db	28
      1  1b5d		       1c		      .byte.b	28
      0  1b5e					      dw	EXPR
      1  1b5e		       c2 1b		      .word.w	EXPR
      0  1b60					      SLICE
      0  1b60					      db	100
      1  1b60		       64		      .byte.b	100
      0  1b61					      DONE
      0  1b61					      db	1
      1  1b61		       01		      .byte.b	1
      0  1b62					      NXT	CO
      0  1b62					      db	6
      1  1b62		       06		      .byte.b	6
      0  1b63					      dw	CO
      1  1b63		       1d 19		      .word.w	CO
      0  1b65					      IJMP	STMT
      0  1b65					      db	29
      1  1b65		       1d		      .byte.b	29
      0  1b66					      dw	STMT
      1  1b66		       25 19		      .word.w	STMT
    399  1b68							;==========================================================================
    400  1b68							; Turn off and on the thrace functions
    401  1b68							; a debug terminal needs to be available
    402  1b68							; Trace( Trace flag expression)
    403  1b68							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    404  1b68							;	for individual lines of basic code. These can be combined
    405  1b68				   S16Trace
      0  1b68					      TST	S17A,"TRACE("	;Are we going to trace
      0  1b68					      db	32
      1  1b68		       20		      .byte.b	32
      0  1b69					      db	(S17A-*)-1
      1  1b69		       16		      .byte.b	(S17A-*)-1
      0  1b6a					      db	"TRACE(",0
      1  1b6a		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  1b71					      CALL	EXPR
      0  1b71					      db	28
      1  1b71		       1c		      .byte.b	28
      0  1b72					      dw	EXPR
      1  1b72		       c2 1b		      .word.w	EXPR
      0  1b74					      TST	UNKNOWN,")"
      0  1b74					      db	32
      1  1b74		       20		      .byte.b	32
      0  1b75					      db	(UNKNOWN-*)-1
      1  1b75		       48		      .byte.b	(UNKNOWN-*)-1
      0  1b76					      db	")",0
      1  1b76		       29 00		      .byte.b	")",0
      0  1b78					      TRACEPROGRAM
      0  1b78					      db	78
      1  1b78		       4e		      .byte.b	78
      0  1b79					      DONE
      0  1b79					      db	1
      1  1b79		       01		      .byte.b	1
      0  1b7a					      NXT	CO
      0  1b7a					      db	6
      1  1b7a		       06		      .byte.b	6
      0  1b7b					      dw	CO
      1  1b7b		       1d 19		      .word.w	CO
      0  1b7d					      IJMP	STMT
      0  1b7d					      db	29
      1  1b7d		       1d		      .byte.b	29
      0  1b7e					      dw	STMT
      1  1b7e		       25 19		      .word.w	STMT
    413  1b80							;=====================================================================
    414  1b80							; Exit basic to machine monitor
    415  1b80							;
    416  1b80				   S17A
      0  1b80					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1b80					      db	32
      1  1b80		       20		      .byte.b	32
      0  1b81					      db	(S17B-*)-1
      1  1b81		       06		      .byte.b	(S17B-*)-1
      0  1b82					      db	"EXIT",0
      1  1b82		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1b87					      EXIT
      0  1b87					      db	26
      1  1b87		       1a		      .byte.b	26
    419  1b88
    420  1b88							;=======================================================================
    421  1b88							; Commands related to saving/restoring programs
    422  1b88							; to/from mass storage.
    423  1b88							;
    424  1b88				   S17B
    425  1b88					      if	(XKIM || CTMON65) && DISK_ACCESS
    426  1b88
      0  1b88					      TST	S17C,"SAVE"
      0  1b88					      db	32
      1  1b88		       20		      .byte.b	32
      0  1b89					      db	(S17C-*)-1
      1  1b89		       0b		      .byte.b	(S17C-*)-1
      0  1b8a					      db	"SAVE",0
      1  1b8a		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1b8f					      OPENWRITE
      0  1b8f					      db	40
      1  1b8f		       28		      .byte.b	40
      0  1b90					      DLIST
      0  1b90					      db	43
      1  1b90		       2b		      .byte.b	43
      0  1b91					      DCLOSE
      0  1b91					      db	41
      1  1b91		       29		      .byte.b	41
      0  1b92					      IJMP	CO
      0  1b92					      db	29
      1  1b92		       1d		      .byte.b	29
      0  1b93					      dw	CO
      1  1b93		       1d 19		      .word.w	CO
    432  1b95
    433  1b95				   S17C
      0  1b95					      TST	S18,"LOAD"
      0  1b95					      db	32
      1  1b95		       20		      .byte.b	32
      0  1b96					      db	(S18-*)-1
      1  1b96		       11		      .byte.b	(S18-*)-1
      0  1b97					      db	"LOAD",0
      1  1b97		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1b9c					      OPENREAD
      0  1b9c					      db	39
      1  1b9c		       27		      .byte.b	39
    436  1b9d				   S17CLP
      0  1b9d					      DGETLINE		;get line from file
      0  1b9d					      db	42
      1  1b9d		       2a		      .byte.b	42
      0  1b9e					      TSTL	S17EOL	;no line num means EOL
      0  1b9e					      db	34
      1  1b9e		       22		      .byte.b	34
      0  1b9f					      db	(S17EOL-*)-1
      1  1b9f		       04		      .byte.b	(S17EOL-*)-1
      0  1ba0					      INSERT		;put it into the program
      0  1ba0					      db	24
      1  1ba0		       18		      .byte.b	24
      0  1ba1					      IJMP	S17CLP	;keep going
      0  1ba1					      db	29
      1  1ba1		       1d		      .byte.b	29
      0  1ba2					      dw	S17CLP
      1  1ba2		       9d 1b		      .word.w	S17CLP
    441  1ba4				   S17EOL
      0  1ba4					      DCLOSE		;close disk file
      0  1ba4					      db	41
      1  1ba4		       29		      .byte.b	41
      0  1ba5					      IJMP	CO	;back to start
      0  1ba5					      db	29
      1  1ba5		       1d		      .byte.b	29
      0  1ba6					      dw	CO
      1  1ba6		       1d 19		      .word.w	CO
    444  1ba8
    445  1ba8				   S18
      0  1ba8					      TST	S19,"DIR"
      0  1ba8					      db	32
      1  1ba8		       20		      .byte.b	32
      0  1ba9					      db	(S19-*)-1
      1  1ba9		       08		      .byte.b	(S19-*)-1
      0  1baa					      db	"DIR",0
      1  1baa		       44 49 52 00	      .byte.b	"DIR",0
      0  1bae					      DDIR		;Display the directory content
      0  1bae					      db	44
      1  1bae		       2c		      .byte.b	44
      0  1baf					      IJMP	CO
      0  1baf					      db	29
      1  1baf		       1d		      .byte.b	29
      0  1bb0					      dw	CO
      1  1bb0		       1d 19		      .word.w	CO
    449  1bb2
      0  1bb2				   S19	      TST	UNKNOWN,"ERASE"
      0  1bb2					      db	32
      1  1bb2		       20		      .byte.b	32
      0  1bb3					      db	(UNKNOWN-*)-1
      1  1bb3		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1bb4					      db	"ERASE",0
      1  1bb4		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1bba					      RMFILE		;Erase the file from the disk
      0  1bba					      db	45
      1  1bba		       2d		      .byte.b	45
      0  1bbb					      IJMP	CO
      0  1bbb					      db	29
      1  1bbb		       1d		      .byte.b	29
      0  1bbc					      dw	CO
      1  1bbc		       1d 19		      .word.w	CO
    453  1bbe
    454  1bbe					      endif
    455  1bbe
    456  1bbe							;
    457  1bbe							; Else, unknown command.
    458  1bbe							;
    459  1bbe				   UNKNOWN
      0  1bbe					      ENDIO
      0  1bbe					      db	71
      1  1bbe		       47		      .byte.b	71
      0  1bbf					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1bbf					      db	13
      1  1bbf		       0d		      .byte.b	13
      0  1bc0					      dw	ERR_SYNTAX
      1  1bc0		       05 00		      .word.w	ERR_SYNTAX
    462  1bc2
    463  1bc2							;=======================================================
    464  1bc2							; Process Expresions, precidence is represented by the
    465  1bc2							; various call levels
    466  1bc2							;
    467  1bc2				   EXPR
      0  1bc2					      TST	EXPRLOGS,"NOT"
      0  1bc2					      db	32
      1  1bc2		       20		      .byte.b	32
      0  1bc3					      db	(EXPRLOGS-*)-1
      1  1bc3		       09		      .byte.b	(EXPRLOGS-*)-1
      0  1bc4					      db	"NOT",0
      1  1bc4		       4e 4f 54 00	      .byte.b	"NOT",0
      0  1bc8					      Call	EXPR
      0  1bc8					      db	28
      1  1bc8		       1c		      .byte.b	28
      0  1bc9					      dw	EXPR
      1  1bc9		       c2 1b		      .word.w	EXPR
      0  1bcb					      LOGNOT
      0  1bcb					      db	72
      1  1bcb		       48		      .byte.b	72
      0  1bcc					      RTN
      0  1bcc					      db	25
      1  1bcc		       19		      .byte.b	25
    472  1bcd
    473  1bcd							;=========================================================
    474  1bcd							;Look for logical operators
    475  1bcd				   EXPRLOGS
      0  1bcd					      Call	EXPRCMP
      0  1bcd					      db	28
      1  1bcd		       1c		      .byte.b	28
      0  1bce					      dw	EXPRCMP
      1  1bce		       f1 1b		      .word.w	EXPRCMP
      0  1bd0					      TST	iLOG1,"AND"
      0  1bd0					      db	32
      1  1bd0		       20		      .byte.b	32
      0  1bd1					      db	(iLOG1-*)-1
      1  1bd1		       09		      .byte.b	(iLOG1-*)-1
      0  1bd2					      db	"AND",0
      1  1bd2		       41 4e 44 00	      .byte.b	"AND",0
      0  1bd6					      Call	EXPR
      0  1bd6					      db	28
      1  1bd6		       1c		      .byte.b	28
      0  1bd7					      dw	EXPR
      1  1bd7		       c2 1b		      .word.w	EXPR
      0  1bd9					      LOGAND
      0  1bd9					      db	74
      1  1bd9		       4a		      .byte.b	74
      0  1bda					      RTN
      0  1bda					      db	25
      1  1bda		       19		      .byte.b	25
    481  1bdb				   iLOG1
      0  1bdb					      TST	iLOG2,"OR"
      0  1bdb					      db	32
      1  1bdb		       20		      .byte.b	32
      0  1bdc					      db	(iLOG2-*)-1
      1  1bdc		       08		      .byte.b	(iLOG2-*)-1
      0  1bdd					      db	"OR",0
      1  1bdd		       4f 52 00 	      .byte.b	"OR",0
      0  1be0					      Call	EXPR
      0  1be0					      db	28
      1  1be0		       1c		      .byte.b	28
      0  1be1					      dw	EXPR
      1  1be1		       c2 1b		      .word.w	EXPR
      0  1be3					      LOGOR
      0  1be3					      db	73
      1  1be3		       49		      .byte.b	73
      0  1be4					      RTN
      0  1be4					      db	25
      1  1be4		       19		      .byte.b	25
    486  1be5				   iLOG2
      0  1be5					      TST	iLOG3,"XOR"
      0  1be5					      db	32
      1  1be5		       20		      .byte.b	32
      0  1be6					      db	(iLOG3-*)-1
      1  1be6		       09		      .byte.b	(iLOG3-*)-1
      0  1be7					      db	"XOR",0
      1  1be7		       58 4f 52 00	      .byte.b	"XOR",0
      0  1beb					      Call	EXPR
      0  1beb					      db	28
      1  1beb		       1c		      .byte.b	28
      0  1bec					      dw	EXPR
      1  1bec		       c2 1b		      .word.w	EXPR
      0  1bee					      LOGXOR
      0  1bee					      db	75
      1  1bee		       4b		      .byte.b	75
      0  1bef					      RTN
      0  1bef					      db	25
      1  1bef		       19		      .byte.b	25
    491  1bf0				   iLOG3
      0  1bf0					      RTN
      0  1bf0					      db	25
      1  1bf0		       19		      .byte.b	25
    493  1bf1
    494  1bf1				   EXPRCMP
      0  1bf1					      Call	EXPR2	; get the first expression
      0  1bf1					      db	28
      1  1bf1		       1c		      .byte.b	28
      0  1bf2					      dw	EXPR2
      1  1bf2		       3d 1c		      .word.w	EXPR2
      0  1bf4					      TST	iR0,"="
      0  1bf4					      db	32
      1  1bf4		       20		      .byte.b	32
      0  1bf5					      db	(iR0-*)-1
      1  1bf5		       08		      .byte.b	(iR0-*)-1
      0  1bf6					      db	"=",0
      1  1bf6		       3d 00		      .byte.b	"=",0
      0  1bf8					      LIT	2	;=
      0  1bf8					      db	27
      1  1bf8		       1b		      .byte.b	27
      0  1bf9					      dw	2
      1  1bf9		       02 00		      .word.w	2
      0  1bfb					      IJMP	iRFound
      0  1bfb					      db	29
      1  1bfb		       1d		      .byte.b	29
      0  1bfc					      dw	iRFound
      1  1bfc		       37 1c		      .word.w	iRFound
    499  1bfe				   iR0
      0  1bfe					      TST	iR4,"<"
      0  1bfe					      db	32
      1  1bfe		       20		      .byte.b	32
      0  1bff					      db	(iR4-*)-1
      1  1bff		       1c		      .byte.b	(iR4-*)-1
      0  1c00					      db	"<",0
      1  1c00		       3c 00		      .byte.b	"<",0
      0  1c02					      TST	iR1,"="
      0  1c02					      db	32
      1  1c02		       20		      .byte.b	32
      0  1c03					      db	(iR1-*)-1
      1  1c03		       08		      .byte.b	(iR1-*)-1
      0  1c04					      db	"=",0
      1  1c04		       3d 00		      .byte.b	"=",0
      0  1c06					      LIT	3	;<=
      0  1c06					      db	27
      1  1c06		       1b		      .byte.b	27
      0  1c07					      dw	3
      1  1c07		       03 00		      .word.w	3
      0  1c09					      IJMP	iRFound
      0  1c09					      db	29
      1  1c09		       1d		      .byte.b	29
      0  1c0a					      dw	iRFound
      1  1c0a		       37 1c		      .word.w	iRFound
    504  1c0c				   iR1
      0  1c0c					      TST	iR3,">"
      0  1c0c					      db	32
      1  1c0c		       20		      .byte.b	32
      0  1c0d					      db	(iR3-*)-1
      1  1c0d		       08		      .byte.b	(iR3-*)-1
      0  1c0e					      db	">",0
      1  1c0e		       3e 00		      .byte.b	">",0
      0  1c10					      LIT	5	;<>
      0  1c10					      db	27
      1  1c10		       1b		      .byte.b	27
      0  1c11					      dw	5
      1  1c11		       05 00		      .word.w	5
      0  1c13					      IJMP	iRFound
      0  1c13					      db	29
      1  1c13		       1d		      .byte.b	29
      0  1c14					      dw	iRFound
      1  1c14		       37 1c		      .word.w	iRFound
    508  1c16				   iR3
      0  1c16					      LIT	1	;<
      0  1c16					      db	27
      1  1c16		       1b		      .byte.b	27
      0  1c17					      dw	1
      1  1c17		       01 00		      .word.w	1
      0  1c19					      IJMP	iRFound
      0  1c19					      db	29
      1  1c19		       1d		      .byte.b	29
      0  1c1a					      dw	iRFound
      1  1c1a		       37 1c		      .word.w	iRFound
    511  1c1c				   iR4
      0  1c1c					      TST	iRDone,">"
      0  1c1c					      db	32
      1  1c1c		       20		      .byte.b	32
      0  1c1d					      db	(iRDone-*)-1
      1  1c1d		       1e		      .byte.b	(iRDone-*)-1
      0  1c1e					      db	">",0
      1  1c1e		       3e 00		      .byte.b	">",0
      0  1c20					      TST	iR5,"="
      0  1c20					      db	32
      1  1c20		       20		      .byte.b	32
      0  1c21					      db	(iR5-*)-1
      1  1c21		       08		      .byte.b	(iR5-*)-1
      0  1c22					      db	"=",0
      1  1c22		       3d 00		      .byte.b	"=",0
      0  1c24					      LIT	6	;>=
      0  1c24					      db	27
      1  1c24		       1b		      .byte.b	27
      0  1c25					      dw	6
      1  1c25		       06 00		      .word.w	6
      0  1c27					      IJMP	iRFound
      0  1c27					      db	29
      1  1c27		       1d		      .byte.b	29
      0  1c28					      dw	iRFound
      1  1c28		       37 1c		      .word.w	iRFound
    516  1c2a				   iR5
      0  1c2a					      TST	iR6,"<"
      0  1c2a					      db	32
      1  1c2a		       20		      .byte.b	32
      0  1c2b					      db	(iR6-*)-1
      1  1c2b		       08		      .byte.b	(iR6-*)-1
      0  1c2c					      db	"<",0
      1  1c2c		       3c 00		      .byte.b	"<",0
      0  1c2e					      LIT	1
      0  1c2e					      db	27
      1  1c2e		       1b		      .byte.b	27
      0  1c2f					      dw	1
      1  1c2f		       01 00		      .word.w	1
      0  1c31					      IJMP	iRFound	;(This line originally omitted)
      0  1c31					      db	29
      1  1c31		       1d		      .byte.b	29
      0  1c32					      dw	iRFound
      1  1c32		       37 1c		      .word.w	iRFound
    520  1c34				   iR6
      0  1c34					      LIT	4	;>
      0  1c34					      db	27
      1  1c34		       1b		      .byte.b	27
      0  1c35					      dw	4
      1  1c35		       04 00		      .word.w	4
    522  1c37				   iRFound
      0  1c37					      Call	EXPR	; get the right side of the expression
      0  1c37					      db	28
      1  1c37		       1c		      .byte.b	28
      0  1c38					      dw	EXPR
      1  1c38		       c2 1b		      .word.w	EXPR
      0  1c3a					      CMPR		; Push the value of the true false onto the stack
      0  1c3a					      db	10
      1  1c3a		       0a		      .byte.b	10
      0  1c3b					      RTN
      0  1c3b					      db	25
      1  1c3b		       19		      .byte.b	25
    526  1c3c
    527  1c3c				   iRDone
      0  1c3c					      RTN
      0  1c3c					      db	25
      1  1c3c		       19		      .byte.b	25
    529  1c3d
    530  1c3d				   EXPR2
      0  1c3d					      TST	E0,"-"	; Look for leading - to negate term
      0  1c3d					      db	32
      1  1c3d		       20		      .byte.b	32
      0  1c3e					      db	(E0-*)-1
      1  1c3e		       09		      .byte.b	(E0-*)-1
      0  1c3f					      db	"-",0
      1  1c3f		       2d 00		      .byte.b	"-",0
      0  1c41					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1c41					      db	28
      1  1c41		       1c		      .byte.b	28
      0  1c42					      dw	TERM
      1  1c42		       66 1c		      .word.w	TERM
      0  1c44					      NEG		; Make value negated
      0  1c44					      db	16
      1  1c44		       10		      .byte.b	16
      0  1c45					      IJMP	E1	; We have Left term process operators next
      0  1c45					      db	29
      1  1c45		       1d		      .byte.b	29
      0  1c46					      dw	E1
      1  1c46		       4f 1c		      .word.w	E1
    535  1c48				   E0
      0  1c48					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1c48					      db	32
      1  1c48		       20		      .byte.b	32
      0  1c49					      db	(E1A-*)-1
      1  1c49		       02		      .byte.b	(E1A-*)-1
      0  1c4a					      db	"+",0
      1  1c4a		       2b 00		      .byte.b	"+",0
    537  1c4c				   E1A
      0  1c4c					      CALL	TERM	; Get the left term if it was not negated
      0  1c4c					      db	28
      1  1c4c		       1c		      .byte.b	28
      0  1c4d					      dw	TERM
      1  1c4d		       66 1c		      .word.w	TERM
    539  1c4f				   E1
      0  1c4f					      TST	E2,"+"	; Check if we are adding left term to something
      0  1c4f					      db	32
      1  1c4f		       20		      .byte.b	32
      0  1c50					      db	(E2-*)-1
      1  1c50		       09		      .byte.b	(E2-*)-1
      0  1c51					      db	"+",0
      1  1c51		       2b 00		      .byte.b	"+",0
      0  1c53					      CALL	TERM	; if adding then get the right side term
      0  1c53					      db	28
      1  1c53		       1c		      .byte.b	28
      0  1c54					      dw	TERM
      1  1c54		       66 1c		      .word.w	TERM
      0  1c56					      ADD		; Add it to left term
      0  1c56					      db	14
      1  1c56		       0e		      .byte.b	14
      0  1c57					      IJMP	E1	; look for next + or -
      0  1c57					      db	29
      1  1c57		       1d		      .byte.b	29
      0  1c58					      dw	E1
      1  1c58		       4f 1c		      .word.w	E1
    544  1c5a				   E2
      0  1c5a					      TST	E3,"-"	; Check if we are subtractig something
      0  1c5a					      db	32
      1  1c5a		       20		      .byte.b	32
      0  1c5b					      db	(E3-*)-1
      1  1c5b		       09		      .byte.b	(E3-*)-1
      0  1c5c					      db	"-",0
      1  1c5c		       2d 00		      .byte.b	"-",0
      0  1c5e					      CALL	TERM	; get right side to subtract Diffrence
      0  1c5e					      db	28
      1  1c5e		       1c		      .byte.b	28
      0  1c5f					      dw	TERM
      1  1c5f		       66 1c		      .word.w	TERM
      0  1c61					      SUB		; Subtract the value
      0  1c61					      db	15
      1  1c61		       0f		      .byte.b	15
      0  1c62					      IJMP	E1	; Look for next + or -
      0  1c62					      db	29
      1  1c62		       1d		      .byte.b	29
      0  1c63					      dw	E1
      1  1c63		       4f 1c		      .word.w	E1
    549  1c65				   E3			; Finish processing the expression
      0  1c65					      RTN		; We are finished processing the Expression
      0  1c65					      db	25
      1  1c65		       19		      .byte.b	25
    551  1c66							;
    552  1c66							; Get one of the terms of an expression
    553  1c66							;
    554  1c66				   TERM
      0  1c66					      CALL	FACT	; Get a value
      0  1c66					      db	28
      1  1c66		       1c		      .byte.b	28
      0  1c67					      dw	FACT
      1  1c67		       8e 1c		      .word.w	FACT
    556  1c69				   T0			; Check for higher precidence operators
      0  1c69					      TST	T1,"*"	; Check for *
      0  1c69					      db	32
      1  1c69		       20		      .byte.b	32
      0  1c6a					      db	(T1-*)-1
      1  1c6a		       09		      .byte.b	(T1-*)-1
      0  1c6b					      db	"*",0
      1  1c6b		       2a 00		      .byte.b	"*",0
      0  1c6d					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1c6d					      db	28
      1  1c6d		       1c		      .byte.b	28
      0  1c6e					      dw	FACT
      1  1c6e		       8e 1c		      .word.w	FACT
      0  1c70					      MUL		; Multiply factors
      0  1c70					      db	17
      1  1c70		       11		      .byte.b	17
      0  1c71					      IJMP	T0	; Check for * or /
      0  1c71					      db	29
      1  1c71		       1d		      .byte.b	29
      0  1c72					      dw	T0
      1  1c72		       69 1c		      .word.w	T0
    561  1c74				   T1
      0  1c74					      TST	T2,"/"	; Check for a division
      0  1c74					      db	32
      1  1c74		       20		      .byte.b	32
      0  1c75					      db	(T2-*)-1
      1  1c75		       09		      .byte.b	(T2-*)-1
      0  1c76					      db	"/",0
      1  1c76		       2f 00		      .byte.b	"/",0
      0  1c78					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c78					      db	28
      1  1c78		       1c		      .byte.b	28
      0  1c79					      dw	FACT
      1  1c79		       8e 1c		      .word.w	FACT
      0  1c7b					      DIV		; do division
      0  1c7b					      db	18
      1  1c7b		       12		      .byte.b	18
      0  1c7c					      IJMP	T0	; check for more * or /
      0  1c7c					      db	29
      1  1c7c		       1d		      .byte.b	29
      0  1c7d					      dw	T0
      1  1c7d		       69 1c		      .word.w	T0
    566  1c7f				   T2
      0  1c7f					      TST	T3,"%"	; Check for a division
      0  1c7f					      db	32
      1  1c7f		       20		      .byte.b	32
      0  1c80					      db	(T3-*)-1
      1  1c80		       09		      .byte.b	(T3-*)-1
      0  1c81					      db	"%",0
      1  1c81		       25 00		      .byte.b	"%",0
      0  1c83					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c83					      db	28
      1  1c83		       1c		      .byte.b	28
      0  1c84					      dw	FACT
      1  1c84		       8e 1c		      .word.w	FACT
      0  1c86					      MODULO		; do division for remainder
      0  1c86					      db	60
      1  1c86		       3c		      .byte.b	60
      0  1c87					      IJMP	T0	; check for more * or / or %
      0  1c87					      db	29
      1  1c87		       1d		      .byte.b	29
      0  1c88					      dw	T0
      1  1c88		       69 1c		      .word.w	T0
    571  1c8a				   T3			; Finish processing the Term
      0  1c8a					      RTN
      0  1c8a					      db	25
      1  1c8a		       19		      .byte.b	25
    573  1c8b
    574  1c8b				   UNKNOWNVEC
      0  1c8b					      IJMP	UNKNOWN
      0  1c8b					      db	29
      1  1c8b		       1d		      .byte.b	29
      0  1c8c					      dw	UNKNOWN
      1  1c8c		       be 1b		      .word.w	UNKNOWN
    576  1c8e
    577  1c8e							;=============================================================================================
    578  1c8e							; Factor an expression.  Always test for functions
    579  1c8e							; first or else they'll be confused for variables.
    580  1c8e							;
    581  1c8e				   FACT
      0  1c8e					      TST	F1AA,"TRUE"
      0  1c8e					      db	32
      1  1c8e		       20		      .byte.b	32
      0  1c8f					      db	(F1AA-*)-1
      1  1c8f		       09		      .byte.b	(F1AA-*)-1
      0  1c90					      db	"TRUE",0
      1  1c90		       54 52 55 45*	      .byte.b	"TRUE",0
      0  1c95					      LIT	-1
      0  1c95					      db	27
      1  1c95		       1b		      .byte.b	27
      0  1c96					      dw	-1
      1  1c96		       ff ff		      .word.w	-1
      0  1c98					      RTN
      0  1c98					      db	25
      1  1c98		       19		      .byte.b	25
    585  1c99				   F1AA
      0  1c99					      TST	F1AB,"FALSE"
      0  1c99					      db	32
      1  1c99		       20		      .byte.b	32
      0  1c9a					      db	(F1AB-*)-1
      1  1c9a		       0a		      .byte.b	(F1AB-*)-1
      0  1c9b					      db	"FALSE",0
      1  1c9b		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1ca1					      LIT	0
      0  1ca1					      db	27
      1  1ca1		       1b		      .byte.b	27
      0  1ca2					      dw	0
      1  1ca2		       00 00		      .word.w	0
      0  1ca4					      RTN
      0  1ca4					      db	25
      1  1ca4		       19		      .byte.b	25
    589  1ca5							;==================================================================================
    590  1ca5							; Returns the amount of free SPACE
    591  1ca5							;
    592  1ca5				   F1AB
      0  1ca5					      TST	F1A,"FREE()"
      0  1ca5					      db	32
      1  1ca5		       20		      .byte.b	32
      0  1ca6					      db	(F1A-*)-1
      1  1ca6		       09		      .byte.b	(F1A-*)-1
      0  1ca7					      db	"FREE()",0
      1  1ca7		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1cae					      FREE
      0  1cae					      db	36
      1  1cae		       24		      .byte.b	36
      0  1caf					      RTN
      0  1caf					      db	25
      1  1caf		       19		      .byte.b	25
    596  1cb0							;===================================================================================
    597  1cb0							; getch() read a character from the input device
    598  1cb0							;
    599  1cb0				   F1A
      0  1cb0					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1cb0					      db	32
      1  1cb0		       20		      .byte.b	32
      0  1cb1					      db	(F1A2-*)-1
      1  1cb1		       0a		      .byte.b	(F1A2-*)-1
      0  1cb2					      db	"GETCH()",0
      1  1cb2		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1cba					      GETCHAR
      0  1cba					      db	51
      1  1cba		       33		      .byte.b	51
      0  1cbb					      RTN
      0  1cbb					      db	25
      1  1cbb		       19		      .byte.b	25
    603  1cbc							;====================================================================================
    604  1cbc							; peek(mem address) return the value of a byte in memory
    605  1cbc							; @[offset] return a word value from offset -- see tstv
    606  1cbc							;
    607  1cbc				   F1A2
      0  1cbc					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1cbc					      db	32
      1  1cbc		       20		      .byte.b	32
      0  1cbd					      db	(F2AZ-*)-1
      1  1cbd		       0f		      .byte.b	(F2AZ-*)-1
      0  1cbe					      db	"PEEK(",0
      1  1cbe		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1cc4					      CALL	EXPR	;Get the address to write to
      0  1cc4					      db	28
      1  1cc4		       1c		      .byte.b	28
      0  1cc5					      dw	EXPR
      1  1cc5		       c2 1b		      .word.w	EXPR
      0  1cc7					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  1cc7					      db	32
      1  1cc7		       20		      .byte.b	32
      0  1cc8					      db	(UNKNOWNVEC-*)-1
      1  1cc8		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cc9					      db	")",0
      1  1cc9		       29 00		      .byte.b	")",0
      0  1ccb					      PEEKMEM
      0  1ccb					      db	48
      1  1ccb		       30		      .byte.b	48
      0  1ccc					      RTN
      0  1ccc					      db	25
      1  1ccc		       19		      .byte.b	25
    613  1ccd							;=======================================================================================
    614  1ccd							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    615  1ccd							;
    616  1ccd				   F2AZ
      0  1ccd					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  1ccd					      db	32
      1  1ccd		       20		      .byte.b	32
      0  1cce					      db	(F2AZ1-*)-1
      1  1cce		       22		      .byte.b	(F2AZ1-*)-1
      0  1ccf					      db	"TASK(",0
      1  1ccf		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1cd5					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1cd5					      db	28
      1  1cd5		       1c		      .byte.b	28
      0  1cd6					      dw	EXPR
      1  1cd6		       c2 1b		      .word.w	EXPR
      0  1cd8					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  1cd8					      db	61
      1  1cd8		       3d		      .byte.b	61
      0  1cd9					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  1cd9					      db	32
      1  1cd9		       20		      .byte.b	32
      0  1cda					      db	(F2AZNoParms-*)-1
      1  1cda		       10		      .byte.b	(F2AZNoParms-*)-1
      0  1cdb					      db	COMMA,0
      1  1cdb		       2c 00		      .byte.b	COMMA,0
      0  1cdd					      SAVEMATHSTACK		;Push The mathstack
      0  1cdd					      db	86
      1  1cdd		       56		      .byte.b	86
      0  1cde					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  1cde					      db	89
      1  1cde		       59		      .byte.b	89
    623  1cdf				   F2AZLOOP
      0  1cdf					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  1cdf					      db	28
      1  1cdf		       1c		      .byte.b	28
      0  1ce0					      dw	EXPR
      1  1ce0		       c2 1b		      .word.w	EXPR
      0  1ce2					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  1ce2					      db	32
      1  1ce2		       20		      .byte.b	32
      0  1ce3					      db	(F2AZEndParm-*)-1
      1  1ce3		       05		      .byte.b	(F2AZEndParm-*)-1
      0  1ce4					      db	COMMA,0
      1  1ce4		       2c 00		      .byte.b	COMMA,0
      0  1ce6					      IJMP	F2AZLOOP	;check for more
      0  1ce6					      db	29
      1  1ce6		       1d		      .byte.b	29
      0  1ce7					      dw	F2AZLOOP
      1  1ce7		       df 1c		      .word.w	F2AZLOOP
    627  1ce9				   F2AZEndParm
      0  1ce9					      RESTOREMATHSTACK		;Back to normal stack
      0  1ce9					      db	87
      1  1ce9		       57		      .byte.b	87
      0  1cea					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  1cea					      db	92
      1  1cea		       5c		      .byte.b	92
    630  1ceb				   F2AZNoParms
      0  1ceb					      TST	UNKNOWNVEC,")"	;must be )
      0  1ceb					      db	32
      1  1ceb		       20		      .byte.b	32
      0  1cec					      db	(UNKNOWNVEC-*)-1
      1  1cec		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1ced					      db	")",0
      1  1ced		       29 00		      .byte.b	")",0
      0  1cef					      TASKENABLE		;Enable the task to execute
      0  1cef					      db	90
      1  1cef		       5a		      .byte.b	90
      0  1cf0					      RTN		;Returns the Task number
      0  1cf0					      db	25
      1  1cf0		       19		      .byte.b	25
    634  1cf1							;=========================================================================================
    635  1cf1							; Check for IPC interproccess instructions
    636  1cf1							;   IPCS  - Send a message
    637  1cf1							;
    638  1cf1				   F2AZ1
      0  1cf1					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  1cf1					      db	32
      1  1cf1		       20		      .byte.b	32
      0  1cf2					      db	(F2A-*)-1
      1  1cf2		       3c		      .byte.b	(F2A-*)-1
      0  1cf3					      db	"IPC",0
      1  1cf3		       49 50 43 00	      .byte.b	"IPC",0
      0  1cf7					      TST	F2AZa,"S("	;IPCS - send a message
      0  1cf7					      db	32
      1  1cf7		       20		      .byte.b	32
      0  1cf8					      db	(F2AZa-*)-1
      1  1cf8		       13		      .byte.b	(F2AZa-*)-1
      0  1cf9					      db	"S(",0
      1  1cf9		       53 28 00 	      .byte.b	"S(",0
      0  1cfc					      CALL	EXPR	;Get the message value
      0  1cfc					      db	28
      1  1cfc		       1c		      .byte.b	28
      0  1cfd					      dw	EXPR
      1  1cfd		       c2 1b		      .word.w	EXPR
      0  1cff					      TST	UNKNOWNVEC,COMMA
      0  1cff					      db	32
      1  1cff		       20		      .byte.b	32
      0  1d00					      db	(UNKNOWNVEC-*)-1
      1  1d00		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d01					      db	COMMA,0
      1  1d01		       2c 00		      .byte.b	COMMA,0
      0  1d03					      CALL	EXPR	;Get pid of task to send to
      0  1d03					      db	28
      1  1d03		       1c		      .byte.b	28
      0  1d04					      dw	EXPR
      1  1d04		       c2 1b		      .word.w	EXPR
      0  1d06					      TST	UNKNOWNVEC,")"
      0  1d06					      db	32
      1  1d06		       20		      .byte.b	32
      0  1d07					      db	(UNKNOWNVEC-*)-1
      1  1d07		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d08					      db	")",0
      1  1d08		       29 00		      .byte.b	")",0
      0  1d0a					      IPCSEND		;Send msg and clear pid msg pending
      0  1d0a					      db	80
      1  1d0a		       50		      .byte.b	80
      0  1d0b					      RTN
      0  1d0b					      db	25
      1  1d0b		       19		      .byte.b	25
    647  1d0c							;================================================================================
    648  1d0c							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    649  1d0c							;
    650  1d0c				   F2AZa
      0  1d0c					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  1d0c					      db	32
      1  1d0c		       20		      .byte.b	32
      0  1d0d					      db	(F2AZb-*)-1
      1  1d0d		       16		      .byte.b	(F2AZb-*)-1
      0  1d0e					      db	"R(",0
      1  1d0e		       52 28 00 	      .byte.b	"R(",0
      0  1d11					      TST	F2AZa1,")"
      0  1d11					      db	32
      1  1d11		       20		      .byte.b	32
      0  1d12					      db	(F2AZa1-*)-1
      1  1d12		       08		      .byte.b	(F2AZa1-*)-1
      0  1d13					      db	")",0
      1  1d13		       29 00		      .byte.b	")",0
      0  1d15					      LIT	0	;We dont want the pid returned to us
      0  1d15					      db	27
      1  1d15		       1b		      .byte.b	27
      0  1d16					      dw	0
      1  1d16		       00 00		      .word.w	0
      0  1d18					      IPCIO		;Set the io bit and suspend the task till message
      0  1d18					      db	83
      1  1d18		       53		      .byte.b	83
      0  1d19					      IPCRECEIVE		;Get the message
      0  1d19					      db	81
      1  1d19		       51		      .byte.b	81
      0  1d1a					      RTN
      0  1d1a					      db	25
      1  1d1a		       19		      .byte.b	25
    657  1d1b				   F2AZa1
      0  1d1b					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  1d1b					      db	33
      1  1d1b		       21		      .byte.b	33
      0  1d1c					      db	(UNKNOWNVEC-*)-1
      1  1d1c		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d1d					      TST	UNKNOWNVEC,")"
      0  1d1d					      db	32
      1  1d1d		       20		      .byte.b	32
      0  1d1e					      db	(UNKNOWNVEC-*)-1
      1  1d1e		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d1f					      db	")",0
      1  1d1f		       29 00		      .byte.b	")",0
      0  1d21					      IPCIO		;Set the io bit and exit task till message
      0  1d21					      db	83
      1  1d21		       53		      .byte.b	83
      0  1d22					      IPCRECEIVE		;Get the message
      0  1d22					      db	81
      1  1d22		       51		      .byte.b	81
      0  1d23					      RTN
      0  1d23					      db	25
      1  1d23		       19		      .byte.b	25
    663  1d24							;===============================================================================
    664  1d24							; IPCC ---- check if a message is available
    665  1d24				   F2AZb
      0  1d24					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  1d24					      db	32
      1  1d24		       20		      .byte.b	32
      0  1d25					      db	(UNKNOWNVEC-*)-1
      1  1d25		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d26					      db	"C()",0
      1  1d26		       43 28 29 00	      .byte.b	"C()",0
      0  1d2a					      IPCCHECK
      0  1d2a					      db	82
      1  1d2a		       52		      .byte.b	82
      0  1d2b					      RTN
      0  1d2b					      db	25
      1  1d2b		       19		      .byte.b	25
    669  1d2c
    670  1d2c				   UNKNOWNID
      0  1d2c					      IJMP	UNKNOWN
      0  1d2c					      db	29
      1  1d2c		       1d		      .byte.b	29
      0  1d2d					      dw	UNKNOWN
      1  1d2d		       be 1b		      .word.w	UNKNOWN
    672  1d2f							;============================================================
    673  1d2f							; RND() is supposed to have an argument but if none
    674  1d2f							; was provided, just assume a large value.
    675  1d2f							;
    676  1d2f				   F2A
      0  1d2f					      TST	F2B,"RND("
      0  1d2f					      db	32
      1  1d2f		       20		      .byte.b	32
      0  1d30					      db	(F2B-*)-1
      1  1d30		       17		      .byte.b	(F2B-*)-1
      0  1d31					      db	"RND(",0
      1  1d31		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1d36					      TST	F2A1,")"
      0  1d36					      db	32
      1  1d36		       20		      .byte.b	32
      0  1d37					      db	(F2A1-*)-1
      1  1d37		       07		      .byte.b	(F2A1-*)-1
      0  1d38					      db	")",0
      1  1d38		       29 00		      .byte.b	")",0
      0  1d3a					      LIT	32766
      0  1d3a					      db	27
      1  1d3a		       1b		      .byte.b	27
      0  1d3b					      dw	32766
      1  1d3b		       fe 7f		      .word.w	32766
      0  1d3d					      RANDOM
      0  1d3d					      db	37
      1  1d3d		       25		      .byte.b	37
      0  1d3e					      RTN
      0  1d3e					      db	25
      1  1d3e		       19		      .byte.b	25
    682  1d3f
    683  1d3f				   F2A1
      0  1d3f					      CALL	FACT	;GET RANGE
      0  1d3f					      db	28
      1  1d3f		       1c		      .byte.b	28
      0  1d40					      dw	FACT
      1  1d40		       8e 1c		      .word.w	FACT
      0  1d42					      TST	UNKNOWNVEC,")"
      0  1d42					      db	32
      1  1d42		       20		      .byte.b	32
      0  1d43					      db	(UNKNOWNVEC-*)-1
      1  1d43		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d44					      db	")",0
      1  1d44		       29 00		      .byte.b	")",0
      0  1d46					      RANDOM
      0  1d46					      db	37
      1  1d46		       25		      .byte.b	37
      0  1d47					      RTN
      0  1d47					      db	25
      1  1d47		       19		      .byte.b	25
    688  1d48							;==========================================================
    689  1d48							;	Return absolute value of expresion
    690  1d48							;
    691  1d48				   F2B
      0  1d48					      TST	F2B2,"ABS("
      0  1d48					      db	32
      1  1d48		       20		      .byte.b	32
      0  1d49					      db	(F2B2-*)-1
      1  1d49		       0e		      .byte.b	(F2B2-*)-1
      0  1d4a					      db	"ABS(",0
      1  1d4a		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1d4f					      CALL	EXPR	;get value
      0  1d4f					      db	28
      1  1d4f		       1c		      .byte.b	28
      0  1d50					      dw	EXPR
      1  1d50		       c2 1b		      .word.w	EXPR
      0  1d52					      TST	UNKNOWNVEC,")"
      0  1d52					      db	32
      1  1d52		       20		      .byte.b	32
      0  1d53					      db	(UNKNOWNVEC-*)-1
      1  1d53		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d54					      db	")",0
      1  1d54		       29 00		      .byte.b	")",0
      0  1d56					      ABS
      0  1d56					      db	38
      1  1d56		       26		      .byte.b	38
      0  1d57					      RTN
      0  1d57					      db	25
      1  1d57		       19		      .byte.b	25
    697  1d58							;============================================================
    698  1d58							;     Return the the status of a task, provide the PID
    699  1d58							;
    700  1d58				   F2B2
      0  1d58					      TST	F2Z,"STAT("
      0  1d58					      db	32
      1  1d58		       20		      .byte.b	32
      0  1d59					      db	(F2Z-*)-1
      1  1d59		       0f		      .byte.b	(F2Z-*)-1
      0  1d5a					      db	"STAT(",0
      1  1d5a		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1d60					      Call	EXPR
      0  1d60					      db	28
      1  1d60		       1c		      .byte.b	28
      0  1d61					      dw	EXPR
      1  1d61		       c2 1b		      .word.w	EXPR
      0  1d63					      TST	UNKNOWNVEC,")"
      0  1d63					      db	32
      1  1d63		       20		      .byte.b	32
      0  1d64					      db	(UNKNOWNVEC-*)-1
      1  1d64		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d65					      db	")",0
      1  1d65		       29 00		      .byte.b	")",0
      0  1d67					      TASKSTAT
      0  1d67					      db	66
      1  1d67		       42		      .byte.b	66
      0  1d68					      RTN
      0  1d68					      db	25
      1  1d68		       19		      .byte.b	25
    706  1d69				   F2Z
      0  1d69					      TST	F2ZA,"PID"
      0  1d69					      db	32
      1  1d69		       20		      .byte.b	32
      0  1d6a					      db	(F2ZA-*)-1
      1  1d6a		       06		      .byte.b	(F2ZA-*)-1
      0  1d6b					      db	"PID",0
      1  1d6b		       50 49 44 00	      .byte.b	"PID",0
      0  1d6f					      TASKPID
      0  1d6f					      db	77
      1  1d6f		       4d		      .byte.b	77
      0  1d70					      RTN
      0  1d70					      db	25
      1  1d70		       19		      .byte.b	25
    710  1d71							;===========================================================================
    711  1d71							; Call a machine function, provide the address to call and optionally
    712  1d71							; the value to be passed in reg A
    713  1d71				   F2ZA
      0  1d71					      TST	F2FUNC,"CALL("	;call machine function
      0  1d71					      db	32
      1  1d71		       20		      .byte.b	32
      0  1d72					      db	(F2FUNC-*)-1
      1  1d72		       1f		      .byte.b	(F2FUNC-*)-1
      0  1d73					      db	"CALL(",0
      1  1d73		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1d79					      CALL	EXPR
      0  1d79					      db	28
      1  1d79		       1c		      .byte.b	28
      0  1d7a					      dw	EXPR
      1  1d7a		       c2 1b		      .word.w	EXPR
      0  1d7c					      TST	F2B2A,COMMA
      0  1d7c					      db	32
      1  1d7c		       20		      .byte.b	32
      0  1d7d					      db	(F2B2A-*)-1
      1  1d7d		       0b		      .byte.b	(F2B2A-*)-1
      0  1d7e					      db	COMMA,0
      1  1d7e		       2c 00		      .byte.b	COMMA,0
      0  1d80					      CALL	EXPR
      0  1d80					      db	28
      1  1d80		       1c		      .byte.b	28
      0  1d81					      dw	EXPR
      1  1d81		       c2 1b		      .word.w	EXPR
      0  1d83					      TST	UNKNOWNVEC,")"
      0  1d83					      db	32
      1  1d83		       20		      .byte.b	32
      0  1d84					      db	(UNKNOWNVEC-*)-1
      1  1d84		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d85					      db	")",0
      1  1d85		       29 00		      .byte.b	")",0
      0  1d87					      CALLFUNC
      0  1d87					      db	53
      1  1d87		       35		      .byte.b	53
      0  1d88					      RTN
      0  1d88					      db	25
      1  1d88		       19		      .byte.b	25
    721  1d89							; Run the gosub within this function
    722  1d89				   F2B2A
      0  1d89					      TST	UNKNOWNID,")"
      0  1d89					      db	32
      1  1d89		       20		      .byte.b	32
      0  1d8a					      db	(UNKNOWNID-*)-1
      1  1d8a		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  1d8b					      db	")",0
      1  1d8b		       29 00		      .byte.b	")",0
      0  1d8d					      LIT	0	; No parameter passed so just load zero to A
      0  1d8d					      db	27
      1  1d8d		       1b		      .byte.b	27
      0  1d8e					      dw	0
      1  1d8e		       00 00		      .word.w	0
      0  1d90					      CALLFUNC
      0  1d90					      db	53
      1  1d90		       35		      .byte.b	53
      0  1d91					      RTN
      0  1d91					      db	25
      1  1d91		       19		      .byte.b	25
    727  1d92							;===========================================================================
    728  1d92							; Same as gosub but expects a return value
    729  1d92							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    730  1d92							;
      0  1d92				   F2FUNC     TST	F2C,"GOFN"
      0  1d92					      db	32
      1  1d92		       20		      .byte.b	32
      0  1d93					      db	(F2C-*)-1
      1  1d93		       0c		      .byte.b	(F2C-*)-1
      0  1d94					      db	"GOFN",0
      1  1d94		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  1d99					      Call	GOSUBSTATEMENT
      0  1d99					      db	28
      1  1d99		       1c		      .byte.b	28
      0  1d9a					      dw	GOSUBSTATEMENT
      1  1d9a		       c9 1d		      .word.w	GOSUBSTATEMENT
      0  1d9c					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  1d9c					      db	8
      1  1d9c		       08		      .byte.b	8
      0  1d9d					      db	GOSUB_RTN_VALUE
      1  1d9d		       81		      .byte.b	GOSUB_RTN_VALUE
      0  1d9e					      XFER
      0  1d9e					      db	7
      1  1d9e		       07		      .byte.b	7
    735  1d9f				   GOFNRet
      0  1d9f					      RTN
      0  1d9f					      db	25
      1  1d9f		       19		      .byte.b	25
    737  1da0							;=============================================================================
    738  1da0							; See if this is just a simple variable
    739  1da0							;  Allow a subscript for any variable
    740  1da0							;
    741  1da0				   F2C
      0  1da0					      TSTV	F0
      0  1da0					      db	33
      1  1da0		       21		      .byte.b	33
      0  1da1					      db	(F0-*)-1
      1  1da1		       15		      .byte.b	(F0-*)-1
      0  1da2					      TST	F2CLocalTask,"!"
      0  1da2					      db	32
      1  1da2		       20		      .byte.b	32
      0  1da3					      db	(F2CLocalTask-*)-1
      1  1da3		       05		      .byte.b	(F2CLocalTask-*)-1
      0  1da4					      db	"!",0
      1  1da4		       21 00		      .byte.b	"!",0
      0  1da6					      IND		; we just got a pid
      0  1da6					      db	20
      1  1da6		       14		      .byte.b	20
      0  1da7					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  1da7					      db	93
      1  1da7		       5d		      .byte.b	93
      0  1da8					      db	(UNKNOWNID-*)-1
      1  1da8		       83		      .byte.b	(UNKNOWNID-*)-1
    746  1da9
    747  1da9				   F2CLocalTask
      0  1da9					      TST	F2C1,"["
      0  1da9					      db	32
      1  1da9		       20		      .byte.b	32
      0  1daa					      db	(F2C1-*)-1
      1  1daa		       0a		      .byte.b	(F2C1-*)-1
      0  1dab					      db	"[",0
      1  1dab		       5b 00		      .byte.b	"[",0
      0  1dad					      CALL	EXPR
      0  1dad					      db	28
      1  1dad		       1c		      .byte.b	28
      0  1dae					      dw	EXPR
      1  1dae		       c2 1b		      .word.w	EXPR
      0  1db0					      TST	UNKNOWNID,"]"
      0  1db0					      db	32
      1  1db0		       20		      .byte.b	32
      0  1db1					      db	(UNKNOWNID-*)-1
      1  1db1		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  1db2					      db	"]",0
      1  1db2		       5d 00		      .byte.b	"]",0
      0  1db4					      SUBSCRIPT
      0  1db4					      db	64
      1  1db4		       40		      .byte.b	64
    752  1db5				   F2C1
      0  1db5					      IND		;YES, GET THE VALUE.
      0  1db5					      db	20
      1  1db5		       14		      .byte.b	20
      0  1db6					      RTN
      0  1db6					      db	25
      1  1db6		       19		      .byte.b	25
    755  1db7							;=================================================================================
    756  1db7							;Finally check for a number !
    757  1db7							;
    758  1db7				   F0
      0  1db7					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1db7					      db	35
      1  1db7		       23		      .byte.b	35
      0  1db8					      db	(F1-*)-1
      1  1db8		       01		      .byte.b	(F1-*)-1
      0  1db9					      RTN
      0  1db9					      db	25
      1  1db9		       19		      .byte.b	25
    761  1dba				   F1
      0  1dba					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  1dba					      db	32
      1  1dba		       20		      .byte.b	32
      0  1dbb					      db	(F2RTN-*)-1
      1  1dbb		       09		      .byte.b	(F2RTN-*)-1
      0  1dbc					      db	"(",0
      1  1dbc		       28 00		      .byte.b	"(",0
      0  1dbe					      CALL	EXPR
      0  1dbe					      db	28
      1  1dbe		       1c		      .byte.b	28
      0  1dbf					      dw	EXPR
      1  1dbf		       c2 1b		      .word.w	EXPR
      0  1dc1					      TST	F2,")"
      0  1dc1					      db	32
      1  1dc1		       20		      .byte.b	32
      0  1dc2					      db	(F2-*)-1
      1  1dc2		       03		      .byte.b	(F2-*)-1
      0  1dc3					      db	")",0
      1  1dc3		       29 00		      .byte.b	")",0
    765  1dc5				   F2RTN
      0  1dc5					      RTN
      0  1dc5					      db	25
      1  1dc5		       19		      .byte.b	25
    767  1dc6
    768  1dc6				   F2
      0  1dc6					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1dc6					      db	13
      1  1dc6		       0d		      .byte.b	13
      0  1dc7					      dw	ERR_SYNTAX
      1  1dc7		       05 00		      .word.w	ERR_SYNTAX
    770  1dc9							;
    771  1dc9							;=============================================================
    772  1dc9							; Gosub can be both a Function and a Subroutine
    773  1dc9				   GOSUBSTATEMENT
      0  1dc9					      CALL	EXPR	;GET DESTINATION
      0  1dc9					      db	28
      1  1dc9		       1c		      .byte.b	28
      0  1dca					      dw	EXPR
      1  1dca		       c2 1b		      .word.w	EXPR
      0  1dcc					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  1dcc					      db	32
      1  1dcc		       20		      .byte.b	32
      0  1dcd					      db	(GOSUBDONE-*)-1
      1  1dcd		       14		      .byte.b	(GOSUBDONE-*)-1
      0  1dce					      db	"(",0
      1  1dce		       28 00		      .byte.b	"(",0
      0  1dd0					      STK2TMP		;Transfer stack top to temp
      0  1dd0					      db	95
      1  1dd0		       5f		      .byte.b	95
      0  1dd1					      PUSHMATHSTACK		;Record stack frame for return
      0  1dd1					      db	84
      1  1dd1		       54		      .byte.b	84
    778  1dd2				   GOSUBLOOP
      0  1dd2					      CALL	EXPR	; Allows what ever fits onto stack
      0  1dd2					      db	28
      1  1dd2		       1c		      .byte.b	28
      0  1dd3					      dw	EXPR
      1  1dd3		       c2 1b		      .word.w	EXPR
      0  1dd5					      INCPARMCOUNT
      0  1dd5					      db	88
      1  1dd5		       58		      .byte.b	88
      0  1dd6					      TST	GOSUBParmDONE,COMMA
      0  1dd6					      db	32
      1  1dd6		       20		      .byte.b	32
      0  1dd7					      db	(GOSUBParmDONE-*)-1
      1  1dd7		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  1dd8					      db	COMMA,0
      1  1dd8		       2c 00		      .byte.b	COMMA,0
      0  1dda					      IJMP	GOSUBLOOP
      0  1dda					      db	29
      1  1dda		       1d		      .byte.b	29
      0  1ddb					      dw	GOSUBLOOP
      1  1ddb		       d2 1d		      .word.w	GOSUBLOOP
    783  1ddd				   GOSUBParmDONE
      0  1ddd					      TST	F2,")"
      0  1ddd					      db	32
      1  1ddd		       20		      .byte.b	32
      0  1dde					      db	(F2-*)-1
      1  1dde		       e7		      .byte.b	(F2-*)-1
      0  1ddf					      db	")",0
      1  1ddf		       29 00		      .byte.b	")",0
      0  1de1					      TMP2STK		;Restore line to goto
      0  1de1					      db	96
      1  1de1		       60		      .byte.b	96
    786  1de2				   GOSUBDONE
      0  1de2					      RTN
      0  1de2					      db	25
      1  1de2		       19		      .byte.b	25
    788  1de3
    789  1de3		       1d e3	   ILEND      equ	*
------- FILE mytb.asm
   2219  1de3		       1d e3	   PROGEND    equ	*
   2220  1de3
   2221  1de3
   2222  1de3							;=====================================================
   2223  1de3							; Define start of non page zero data
   2224 U1df3					      seg.u	TBData
   2225 U1df3
   2226 U1df3							;=====================================================
   2227 U1df3							; These are storage items not in page zero.
   2228 U1df3							;
   2229 U1df3							; IRQ BASIC Code Service RTN Support
      0 U1df3				   SaveIrqReg db	0	; Store current setting
      1 U1df3		       00		      .byte.b	0
      0 U1df4				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1df4		       00		      .byte.b	0
      0 U1df5				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1df5		       00		      .byte.b	0
      0 U1df6				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1df6		       00 00		      .byte.b	0,0
   2234 U1df8
   2235 U1df8							;
   2236 U1df8							;==================================================================================================
   2237 U1df8							; Task Management information
   2238 U1df8							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2239 U1df8							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2240 U1df8							; Task switchs happen at the beginning of the next Basic command line
   2241 U1df8							; It will not happen during an input or output operations
   2242 U1df8							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2243 U1df8							; Task Zero is always the root task, main line program
   2244 U1df8							;
   2245 U1df8							; Layout is repeated for each configured task
   2246 U1df8							; Task Table Byte   use masks follow
   2247 U1df8		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2248 U1df8		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2249 U1df8		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2250 U1df8		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2251 U1df8		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2252 U1df8
   2253 U1df8		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2254 U1df9		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2255 U1df9		       1e f3	   TASKTABLEEND equ	*	; End of task table
   2256 U1df9		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2257 U1ef3
   2258 U1ef3							;Task Cycle Counter and reset count
   2259 U1ef3		       00 00	   taskCurrentCycles ds	2
   2260 U1ef5		       00 00	   taskResetValue ds	2
   2261 U1ef7		       00	   taskCounter ds	1	; Count of active tasks
   2262 U1ef8
   2263 U1ef8							;
   2264 U1ef8							; Math stack and IL call and Gosub/For-next return stack definitions
   2265 U1ef8							;
   2266 U1ef8		       1e f8	   STACKSTART equ	*
   2267 U1ef8		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2268 U2088		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2269 U2218		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2270 U2498		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2271 U2498		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2272 U2498		       26 b4	   STACKEND   equ	*
   2273 U2498		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2274 U26b4							;
   2275 U26b4							;
   2276 U26b4		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2277 U2738		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2278 U2739		       00	   printtx    ds	1	;temp X for print funcs
   2279 U273a		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2280 U273b		       00	   promptChar ds	1	;the character to use for a prompt
   2281 U273c		       00	   diddigit   ds	1	;for leading zero suppression
   2282 U273d		       00	   putsy      ds	1
   2283 U273e		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2284 U2740		       00	   sign       ds	1	;0 = positive, else negative
   2285 U2741		       00 00	   rtemp1     ds	2	;Temp for x and y
   2286 U2743		       00 00	   random     ds	2
   2287 U2745		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2288 U2747		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2289 U2749		       00	   tempy      ds	1	;temp y storage
   2290 U274a
   2291 U274a							; Moved from page zero as one clock cycle diff gives more space on page zero
   2292 U274a		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2293 U274c		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2294 U274d		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2295 U274e		       00	   lineLength ds	1	;Length of current line
   2296 U274f
   2297 U274f		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2298 U2750		       00	   taskRDPending ds	1	; 1 = background read is pending
   2299 U2751
   2300 U2751				  -	      if	XKIM
   2301 U2751				  -buffer     ds	BUFFER_SIZE
   2302 U2751					      endif
   2303 U2751							;
   2304 U2751							; PROGRAMEND is the end of the user's BASIC program.
   2305 U2751							; More precisely, it is one byte past the end.  Or,
   2306 U2751							; it's where the next line added to the end will be
   2307 U2751							; placed.
   2308 U2751							;
   2309 U2751		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2310 U2753		       00 00	   ProgramEnd ds	2	; End of users basic program
   2311 U2755		       00 00	   HighMem    ds	2	; highest location
   2312 U2757		       00 00	   UsedMem    ds	2	; size of user program
   2313 U2759		       00 00	   FreeMem    ds	2	; amount of free memory
   2314 U275b							;
   2315 U275b							;=====================================================
   2316 U275b							; This is the start of the user's BASIC program space.
   2317 U275b							;
   2318 U275b							; PERSONAL GOAL: This should be no larger than $0DFF.
   2319 U275b							;		  0200-05FF = 1K
   2320 U275b							;		  0200-09FF = 2K
   2321 U275b							;		  0200-0DFF = 3K
   2322 U275b							;		  0200-11FF = 4K
   2323 U275b							;		  0200-13FF = 4.5K
   2324 U275b							;
   2325 U275b				  -	      if	FIXED
   2326 U275b				  -	      org	$2000
   2327 U275b					      endif
   2328 U275b
   2329 U275b		       27 5b	   FreeMemStart equ	*
   2330 U275b							;/*
   2331 U275b							;	if	CTMON65 || XKIM
   2332 U275b							;		SEG Code
   2333 U275b							;		org	AutoRun
   2334 U275b							;		dw	TBasicCold
   2335 U275b							;	endif
   2336 U275b							;*/
   2337 U275b					      end
