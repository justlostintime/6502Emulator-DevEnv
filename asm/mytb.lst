------- FILE mytb.asm LEVEL 1 PASS 6
      1 U3126				   input      processor	6502
      2 U3126 ????						;=====================================================
      3 U3126 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U3126 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U3126 ????						; Free Time. Now abiut 6K Full OS features.
      6 U3126 ????						;
      7 U3126 ????						; While working on the Corsham Technologies KIM Clone
      8 U3126 ????						; project, I wanted to include a TINY BASIC since that
      9 U3126 ????						; was a highly desirable feature of early computers.
     10 U3126 ????						;
     11 U3126 ????						; Rather than negotiating copyright issues for
     12 U3126 ????						; existing BASICs, I decided to just write one from
     13 U3126 ????						; scratch.
     14 U3126 ????						;
     15 U3126 ????						; 10/07/2017
     16 U3126 ????						;
     17 U3126 ????						; This implements a stripped down Tiny BASIC
     18 U3126 ????						; interpreter using the Interpretive Language (IL)
     19 U3126 ????						; method as described in the first few issues of
     20 U3126 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U3126 ????						; to write various languages simply by changing the
     22 U3126 ????						; IL code rather than the interpreter itself.
     23 U3126 ????						;
     24 U3126 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U3126 ????						;		* Fixed major bug in findLine that
     26 U3126 ????						;		  caused corrupted lines, crashes, etc.
     27 U3126 ????						;		* If no parameter given to RND, assume
     28 U3126 ????						;		  32766.
     29 U3126 ????						;		* No more error 5 when a program
     30 U3126 ????						;		  reaches the end without an END.
     31 U3126 ????						;
     32 U3126 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U3126 ????						;		 * Unexpanded version to play with everything
     34 U3126 ????						;		 * Add some usefull system level functions
     35 U3126 ????						;		 * allow a larger number of tiny basic formats
     36 U3126 ????						;		 * Add byte at start of line holding length
     37 U3126 ????						;		   for faster execution of goto and gosub
     38 U3126 ????						;		 * Re-added gosub
     39 U3126 ????						;		 * allow ; or , at end if print stmt
     40 U3126 ????						;		   without CRLF being added.
     41 U3126 ????						;		 * Added extended function erase to
     42 U3126 ????						;		   use the extended ctmon65 rm file
     43 U3126 ????						;		 * Fix quoted text to not have to backtrack
     44 U3126 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U3126 ????						;		 * Add concurrency features
     46 U3126 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U3126 ????						;
     48 U3126 ????						; www.corshamtech.com
     49 U3126 ????						; bob@corshamtech.com
     50 U3126 ????						; JustLostInTime@gmail.com
     51 U3126 ????						;
     52 U3126 ????						;=====================================================
     53 U3126 ????						;
     54 U3126 ????						; Create TRUE and FALSE values for conditionals.
     55 U3126 ????						;
     56 U3126 ????
     57 U3126 ????	       00 00	   FALSE      equ	0
     58 U3126 ????	       ff ff ff ff TRUE       equ	~FALSE
     59 U3126 ????						;
     60 U3126 ????						;---------------------------------------------------------
     61 U3126 ????						; One of these must be set to indicate which environment
     62 U3126 ????						; Tiny BASIC will be running in.  Here are the current
     63 U3126 ????						; environments:
     64 U3126 ????						;
     65 U3126 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     66 U3126 ????						; more K of RAM.
     67 U3126 ????						;
     68 U3126 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     69 U3126 ????						; which enhances, without replacing, the standard KIM
     70 U3126 ????						; monitor.  It gives access to routines to save/load files
     71 U3126 ????						; to a micro SD card.
     72 U3126 ????						;
     73 U3126 ????						; CTMON65 is a from-scratch monitor written for the
     74 U3126 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     75 U3126 ????						; easily be ported to other systems.  It has support for
     76 U3126 ????						; using a micro SD card for file storage/retrieval.
     77 U3126 ????						;
     78 U3126 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     79 U3126 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     80 U3126 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     81 U3126 ????
     82 U3126 ????						;
     83 U3126 ????						;   Need to define some macros for the dasm assembler
     84 U3126 ????						;
     85 U3126 ????				      MACRO	dw
     86 U3126 ????				      .word	{0}
     87 U3126 ????				      ENDM
     88 U3126 ????
     89 U3126 ????				      MACRO	db
     90 U3126 ????				      .byte	{0}
     91 U3126 ????				      ENDM
     92 U3126 ????
     93 U3126 ????						;
     94 U3126 ????						; If set, include disk functions.
     95 U3126 ????						;
     96 U3126 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U3126 ????						;
     98 U3126 ????						; If ILTRACE is set then dump out the address of every
     99 U3126 ????						; IL opcode before executing it.
    100 U3126 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U3126 ????						;
    102 U3126 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U3126 ????						;
    104 U3126 ????						; If FIXED is set, put the IL code and the user
    105 U3126 ????						; program space at fixed locations in memory.	This is
    106 U3126 ????						; meant only for debugging.
    107 U3126 ????						;
    108 U3126 ????	       00 00	   FIXED      equ	FALSE
    109 U3126 ????						;
    110 U3126 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U3126 ????						; BASIC, so keep this small!
    112 U3126 ????						;
    113 U3126 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U3126 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U3126 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U3126 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U3126 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    118 U3126 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U3126 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U3126 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U3126 ????						;
    122 U3126 ????						; Gosub entry types
    123 U3126 ????
    124 U3126 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U3126 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U3126 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U3126 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U3126 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U3126 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U3126 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U3126 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U3126 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U3126 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U3126 ????						;
    135 U3126 ????						; Common ASCII constants
    136 U3126 ????						;
    137 U3126 ????	       00 07	   BEL	      equ	$07
    138 U3126 ????	       00 08	   BS	      equ	$08
    139 U3126 ????	       00 09	   TAB	      equ	$09
    140 U3126 ????	       00 0a	   LF	      equ	$0A
    141 U3126 ????	       00 0d	   CR	      equ	$0D
    142 U3126 ????	       00 22	   quote      equ	$22
    143 U3126 ????	       00 20	   SPACE      equ	$20
    144 U3126 ????	       00 2c	   COMMA      equ	',
    145 U3126 ????	       00 3b	   SEMICOLON  equ	';
    146 U3126 ????	       00 3a	   COLON      equ	':
    147 U3126 ????	       00 24	   DOLLAR     equ	'$
    148 U3126 ????						;
    149 U3126 ????						; These are error codes
    150 U3126 ????						;
    151 U3126 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U3126 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U3126 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U3126 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U3126 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U3126 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U3126 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U3126 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U3126 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U3126 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U3126 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U3126 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U3126 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U3126 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U3126 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U3126 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U3126 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U3126 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U3126 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U3126 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    171 U3126 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    172 U3126 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    173 U3126 ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    174 U3126 ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    175 U3126 ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    176 U3126 ????						;
    177 U3126 ????						;=====================================================
    178 U3126 ????						; Zero page storage.
    179 U3126 ????						;
    180 U00f6 ????				      SEG.U	ZEROPAGE
    181 U0040					      org	$0040
    182 U0040
    183 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    184 U0041
    185 U0041							; The context is used to locate a task switch
    186 U0041							; it copies from here till all task fields are saved/swapped
    187 U0041							; The max number of tasks is 256 / context length
    188 U0041							; All positions POS values are plus one task table incldues
    189 U0041							; a leading status byte .
    190 U0041							;
    191 U0041		       00 41	   CONTEXT    equ	*
    192 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    193 U0041
    194 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    195 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    196 U0043
    197 U0043		       00 00	   ILPC       ds	2	; IL program counter
    198 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    199 U0047		       00	   ILSTACKPTR ds	1
    200 U0048
    201 U0048
    202 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    203 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    204 U004a
    205 U004a
    206 U004a		       00	   MATHSTACKPTR ds	1
    207 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    208 U004b
    209 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    210 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT +1	; Get the offset to the gosub/msg stack
    211 U004d
    212 U004d
    213 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    214 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    215 U004e
    216 U004e
    217 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    218 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    219 U004f							;
    220 U004f							; CURPTR is a pointer to curent BASIC line being
    221 U004f							; executed.  Always points to start of line, CUROFF
    222 U004f							; is the offset to the current character.
    223 U004f							; The order of these fields is important
    224 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    225 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    226 U0052							;
    227 U0052							;The order of these fields in important
    228 U0052
    229 U0052							;
    230 U0052							; R0, R1 and MQ are used for arithmetic operations and
    231 U0052							; general use.
    232 U0052							;
    233 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    234 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    235 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    236 U0056		       00 00	   MQ	      ds	2	;used for some math
    237 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    238 U0058		       00 59	   REGISTERSEND equ	*
    239 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    240 U0059
    241 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    242 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    243 U0059
    244 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    245 U005b							;
    246 U005b							; This is zero if in immediate mode, or non-zero
    247 U005b							; if currently running a program.  Any input from
    248 U005b							; the main loop clears this, and the XFER IL
    249 U005b							; statement will set it.
    250 U005b							;
    251 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    252 U005c							;
    253 U005c							; Used for line insertion/removal.
    254 U005c							;
    255 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    256 U005e
    257 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    258 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    259 U005e							;
    260 U005e		       00 00	   PrtFrom    ds	2	; FROM
    261 U0060							;
    262 U0060							;=====================================================
    263 U0060							;Pointers for memory Management
    264 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    265 U0060							; Mem block format is
    266 U0060							;	 0-1   pointer to next block for free blocks
    267 U0060							;	 0-1   for allocated blocks
    268 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    269 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    270 U0060							;	 2-3   length constant for exevy type of memory block
    271 U0060							; Memory is recombined as it is released
    272 U0060							; The memory manager is not interupted durring allocation
    273 U0060							; or freeing of memory
    274 U0060							;====================================================
    275 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    276 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    277 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    278 U0066							;
    279 U0066							;=====================================================
    280 U0066							;
    281  277c ????				      SEG	Code
    282  0200					      org	$0200
    283  0200							;
    284  0200							; Cold start is at $0200.  Warm start is at $0203.
    285  0200							;
    286  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    287  0203		       4c 94 02    warm       jmp	warm2	;Entry point for worm restart
    288  0206							;
    289  0206							; These are the user-supplied vectors to I/O routines.
    290  0206							; If you want, you can just patch these in the binary
    291  0206							; file, but it would be better to change the source
    292  0206							; code.
    293  0206							;
    294  0206				  -	      if	KIM
    295  0206				  -OUTCH      jmp	$1ea0	;output char in A
    296  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    297  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    298  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    299  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    300  0206					      endif
    301  0206				  -	      if	XKIM
    302  0206				  -	      include	"xkim.inc"
    303  0206				  -	      SEG	Code
    304  0206				  -OUTCH      jmp	$1ea0
    305  0206				  -GETCH      jmp	xkGETCH
    306  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    307  0206				  -OUTHEX     jmp	xkPRTBYT
    308  0206				  -MONITOR    jmp	extKIM
    309  0206				  -puts       equ	putsil
    310  0206				  -BUFFER_SIZE equ	132
    311  0206					      endif
    312  0206
    313  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    315 Udf8e
    316  0206					      SEG	Code
    317  0206							;
    318  0206		       f0 0c	   OUTCH      equ	cout
    319  0206		       f0 09	   GETCH      equ	cin
    320  0206		       1f 33	   CRLF       equ	tbcrlf
    321  0206		       14 65	   OUTHEX     equ	HexToOut
    322  0206		       f0 03	   MONITOR    equ	WARM
    323  0206		       f0 0f	   ISCHAR     equ	cstatus
    324  0206		       14 82	   puts       equ	tbputs
    325  0206					      endif
    326  0206							;
    327  0206		       20 67 20    cold2      jsr	SetOutConsole
    328  0209		       20 74 20 	      jsr	SetInConsole
    329  020c		       20 82 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    333  0244							;
    334  0244		       20 76 16 	      jsr	MemInit	;setup the free space available
    335  0247
    336  0247		       a9 01	   calcstack  lda	#1
    337  0249		       8d c2 28 	      sta	taskCounter	; Initialize number of tasks to 1
    338  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    339  024e		       8d c4 27 	      sta	taskTable	; mark the main task as active
    340  0251		       20 e5 17 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    341  0254		       a9 67		      lda	#IL&$ff
    342  0256		       85 43		      sta	ILPC
    343  0258		       a9 23		      lda	#IL>>8
    344  025a		       85 44		      sta	ILPC+1
    345  025c							;
    346  025c							;		  lda	  ProgramStart		     ; user prog
    347  025c							;		  sta	  ProgramEnd
    348  025c							;		  lda	  ProgramStart+1
    349  025c							;		  sta	  ProgramEnd+1
    350  025c							;
    351  025c
    352  025c							;  Init time slices defaults
    353  025c		       a9 02		      lda	#TASKCYCLESHIGH
    354  025e		       8d c1 28 	      sta	taskResetValue+1
    355  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    356  0263		       8d c0 28 	      sta	taskResetValue
    357  0266							;
    358  0266							; Initialize the pseudo-random number sequence...
    359  0266							;
    360  0266		       a9 5a		      lda	#$5a
    361  0268		       8d 0c 31 	      sta	rtemp1
    362  026b		       a9 9d		      lda	#%10011101
    363  026d		       8d 0e 31 	      sta	random
    364  0270		       a9 5b		      lda	#%01011011
    365  0272		       8d 0f 31 	      sta	random+1
    366  0275							;
    367  0275							;   Insert a Basic irq handler for the basic Language
    368  0275		       a9 82		      lda	#ServiceIrq&$ff
    369  0277		       8d 00 df 	      sta	IRQvec
    370  027a		       a9 02		      lda	#ServiceIrq>>8
    371  027c		       8d 01 df 	      sta	IRQvec+1
    372  027f		       4c a7 02 	      jmp	coldtwo
    373  0282
    374  0282							;
    375  0282							; This is the Basic IRQ handler
    376  0282		       48	   ServiceIrq pha
    377  0283		       ad bf 27 	      lda	IRQStatus
    378  0286		       f0 0a		      BEQ	RetIrq
    379  0288		       ad c0 27 	      lda	IRQPending
    380  028b		       d0 05		      bne	RetIrq
    381  028d		       a9 01		      lda	#1
    382  028f		       8d c0 27 	      sta	IRQPending
    383  0292		       68	   RetIrq     pla
    384  0293		       40		      rti
    385  0294							;
    386  0294							;
    387  0294							; This is the warm start entry point
    388  0294							;
    389  0294		       20 67 20    warm2      jsr	SetOutConsole
    390  0297		       20 74 20 	      jsr	SetInConsole
    391  029a		       20 33 1f 	      jsr	CRLF
    392  029d		       ad 09 31 	      lda	errGoto
    393  02a0		       85 43		      sta	ILPC
    394  02a2		       ad 0a 31 	      lda	errGoto+1
    395  02a5		       85 44		      sta	ILPC+1
    396  02a7							;
    397  02a7							; And continue with both starts here
    398  02a7							;
    399  02a7				   coldtwo
    400  02a7							;
    401  02a7							; The ILTrace flag is now run-time settable.
    402  02a7							;
    403  02a7		       a9 00		      lda	#ILTRACE&$ff
    404  02a9		       85 40		      sta	ILTrace
    405  02ab							;
    406  02ab
    407  02ab		       a9 00		      lda	#0
    408  02ad		       85 5b		      sta	RunMode
    409  02af		       8d 7f 30 	      sta	LINBUF
    410  02b2
    411  02b2							; Clear everything from the stacks
    412  02b2
    413  02b2		       8d 1a 31 	      sta	taskIOPending	; No one waiting for io
    414  02b5		       8d 1b 31 	      sta	taskRDPending	; No one waiting for bg io
    415  02b8
    416  02b8		       20 58 18 	      jsr	taskReset
    417  02bb							;
    418  02bb		       a9 7f		      lda	#LINBUF&$ff
    419  02bd		       85 4f		      sta	CURPTR
    420  02bf		       a9 30		      lda	#LINBUF>>8
    421  02c1		       85 50		      sta	CURPTR+1	;fall through...
    422  02c3
    423  02c3							;=====================================================
    424  02c3							; This is the top of the IL interpreter.  This fetches
    425  02c3							; and executes the instruction currently pointed to
    426  02c3							; by ILPC and adjusts ILPC to point to the next
    427  02c3							; instruction to execute.
    428  02c3							;
    429  02c3				   NextIL
    430  02c3		       ba		      tsx		; Get the stack pointer value
    431  02c4		       e0 ff		      cpx	#$FF	; Should be empty
    432  02c6		       d0 26		      bne	ILbad	; Halt and catch fire now!
    433  02c8
    434  02c8		       ce be 28 	      dec	taskCurrentCycles
    435  02cb		       d0 03		      bne	NextIlNow
    436  02cd		       20 81 18 	      jsr	iTaskSwitch	;check for a task switch
    437  02d0		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    438  02d2		       f0 03		      beq	NextIL2	;Skip if no bits set
    439  02d4
    440  02d4		       20 c4 1f 	      jsr	dbgLine	;Print the IL trace information
    441  02d7
    442  02d7		       a4 51	   NextIL2    ldy	CUROFF
    443  02d9							;		  jsr	  SkipSpaces
    444  02d9							;		  sty	  CUROFF
    445  02d9							;Task IO Management
    446  02d9		       ad 1b 31 	      lda	taskRDPending	; if it is zero then Nothing pending
    447  02dc		       f0 08		      beq	NextILStr
    448  02de		       20 6c 1d 	      jsr	ReadLine	; else Pending and poll keyboard
    449  02e1		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    450  02e3		       ce 1b 31 	      dec	taskRDPending	; Carry is set if CR has been recieved
    451  02e6							;
    452  02e6		       20 ef 1b    NextILStr  jsr	getILByte
    453  02e9							;
    454  02e9							; When the handler is called, these are the conditions
    455  02e9							; of several important items:
    456  02e9							;
    457  02e9							;    (ILPC) will point to the byte AFTER the IL
    458  02e9							;    opcode being executed.
    459  02e9							;
    460  02e9							;    (CURPTR),CUROFF will point to the start of the
    461  02e9							;    next word in the input buffer.  Ie, the next word
    462  02e9							;    in the user program.
    463  02e9							;
    464  02e9		       0a		      asl
    465  02ea		       c9 e2		      cmp	#ILTBLend-ILTBL+2
    466  02ec		       90 33		      bcc	ILgood
    467  02ee							;
    468  02ee							; This handles an illegal IL opcode.  This is serious
    469  02ee							; and there's no way to recover.
    470  02ee							;
    471  02ee		       20 82 14    ILbad      jsr	puts
      0  02f1					      db	CR,LF
      1  02f1		       0d 0a		      .byte.b	CR,LF
      0  02f3					      db	"Illegal IL "
      1  02f3		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02fe					      db	0
      1  02fe		       00		      .byte.b	0
    475  02ff							;
    476  02ff							; Well this is awkward, we need to back up the IL
    477  02ff							; by one since it no longer points to the current
    478  02ff							; opcode.
    479  02ff							;
    480  02ff		       20 fc 1b 	      jsr	decIL
    481  0302							;
    482  0302		       a0 00		      ldy	#0
    483  0304		       b1 43		      lda	(ILPC),y
    484  0306		       20 65 14 	      jsr	OUTHEX
    485  0309		       20 82 14 	      jsr	puts
      0  030c					      db	" at ",0
      1  030c		       20 61 74 20*	      .byte.b	" at ",0
    487  0311		       a5 44		      lda	ILPC+1
    488  0313		       20 65 14 	      jsr	OUTHEX
    489  0316		       a5 43		      lda	ILPC
    490  0318		       20 65 14 	      jsr	OUTHEX
    491  031b		       20 33 1f 	      jsr	CRLF
    492  031e		       4c 03 f0 	      jmp	MONITOR
    493  0321							;
    494  0321							; Just jump to the address (ILPC),y.  Have to do
    495  0321							; some goofy stuff.
    496  0321							;
    497  0321		       a8	   ILgood     tay		;move index into Y
    498  0322		       b9 2f 03 	      lda	ILTBL,y
    499  0325		       85 59		      sta	dpl
    500  0327		       b9 30 03 	      lda	ILTBL+1,y
    501  032a		       85 5a		      sta	dpl+1
    502  032c		       6c 59 00 	      jmp	(dpl)	;go to handler
    503  032f							;
    504  032f							;=====================================================
    505  032f							; This is the IL jump table.  The IL opcode is
    506  032f							; mulitplied by two, then looked-up in this table.
    507  032f							; There is absolutely nothing special about the order
    508  032f							; of entries here... they all decode at exactly the
    509  032f							; same speed.	However the entry number must match the
    510  032f							; values in IL.inc.
    511  032f							;
    512  032f				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  032f					      include	"ilvectortable.asm"
      1  032f					      seg	Code
      2  032f
      0  032f					      dw	iXINIT	;0
      1  032f		       47 04		      .word.w	iXINIT
      0  0331					      dw	iDONE	;1
      1  0331		       62 04		      .word.w	iDONE
      0  0333					      dw	iPRS	;2
      1  0333		       79 04		      .word.w	iPRS
      0  0335					      dw	iPRN	;3
      1  0335		       81 04		      .word.w	iPRN
      0  0337					      dw	iSPC	;4
      1  0337		       8a 04		      .word.w	iSPC
      0  0339					      dw	iNLINE	;5
      1  0339		       55 09		      .word.w	iNLINE
      0  033b					      dw	iNXT	;6
      1  033b		       92 04		      .word.w	iNXT
      0  033d					      dw	iXFER	;7
      1  033d		       d4 04		      .word.w	iXFER
      0  033f					      dw	iSAV	;8
      1  033f		       f2 04		      .word.w	iSAV
      0  0341					      dw	iRSTR	;9
      1  0341		       38 05		      .word.w	iRSTR
      0  0343					      dw	iCMPR	;10
      1  0343		       86 05		      .word.w	iCMPR
      0  0345					      dw	iINNUM	;11
      1  0345		       05 06		      .word.w	iINNUM
      0  0347					      dw	iFIN	;12
      1  0347		       3d 06		      .word.w	iFIN
      0  0349					      dw	iERR	;13
      1  0349		       51 06		      .word.w	iERR
      0  034b					      dw	iADD	;14
      1  034b		       cb 06		      .word.w	iADD
      0  034d					      dw	iSUB	;15
      1  034d		       e1 06		      .word.w	iSUB
      0  034f					      dw	iNEG	;16
      1  034f		       f7 06		      .word.w	iNEG
      0  0351					      dw	iMUL	;17
      1  0351		       0f 07		      .word.w	iMUL
      0  0353					      dw	iDIV	;18
      1  0353		       4f 07		      .word.w	iDIV
      0  0355					      dw	iSTORE	;19
      1  0355		       a5 07		      .word.w	iSTORE
      0  0357					      dw	iIND	;20
      1  0357		       c3 07		      .word.w	iIND
      0  0359					      dw	iLST	;21
      1  0359		       4b 08		      .word.w	iLST
      0  035b					      dw	iINIT	;22
      1  035b		       0f 04		      .word.w	iINIT
      0  035d					      dw	iGETLINE	;23
      1  035d		       81 08		      .word.w	iGETLINE
      0  035f					      dw	iINSRT	;24
      1  035f		       9e 08		      .word.w	iINSRT
      0  0361					      dw	iRTN	;25
      1  0361		       4f 09		      .word.w	iRTN
      0  0363					      dw	MONITOR	;26
      1  0363		       03 f0		      .word.w	MONITOR
      0  0365					      dw	iLIT	;27
      1  0365		       75 09		      .word.w	iLIT
      0  0367					      dw	iCALL	;28
      1  0367		       5b 09		      .word.w	iCALL
      0  0369					      dw	iJMP	;29
      1  0369		       63 09		      .word.w	iJMP
      0  036b					      dw	iVINIT	;30
      1  036b		       92 09		      .word.w	iVINIT
      0  036d					      dw	iERRGOTO	;31
      1  036d		       9b 09		      .word.w	iERRGOTO
      0  036f					      dw	iTST	;32
      1  036f		       a7 09		      .word.w	iTST
      0  0371					      dw	iTSTV	;33
      1  0371		       cc 0a		      .word.w	iTSTV
      0  0373					      dw	iTSTL	;34
      1  0373		       50 0b		      .word.w	iTSTL
      0  0375					      dw	iTSTN	;35
      1  0375		       6b 0b		      .word.w	iTSTN
      0  0377					      dw	iFREE	;36
      1  0377		       1c 0c		      .word.w	iFREE
      0  0379					      dw	iRANDOM	;37
      1  0379		       25 0c		      .word.w	iRANDOM
      0  037b					      dw	iABS	;38
      1  037b		       f6 0c		      .word.w	iABS
     42  037d							;
     43  037d							; Disk functions.  There must be pointers
     44  037d							; to functions even if no disk is supported.
     45  037d							; Makes things easier in IL.inc.
     46  037d							;
     47  037d					      if	DISK_ACCESS
      0  037d					      dw	iOPENREAD	;39
      1  037d		       b7 21		      .word.w	iOPENREAD
      0  037f					      dw	iOPENWRITE	;40
      1  037f		       18 22		      .word.w	iOPENWRITE
      0  0381					      dw	iDCLOSE	;41
      1  0381		       9c 22		      .word.w	iDCLOSE
      0  0383					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0383		       2a 22		      .word.w	iDGETLINE
      0  0385					      dw	iDLIST	;43 Did you remember your towel?
      1  0385		       96 22		      .word.w	iDLIST
      0  0387					      dw	iDDIR	;44
      1  0387		       71 22		      .word.w	iDDIR
      0  0389					      dw	iRMFILE	;45
      1  0389		       06 22		      .word.w	iRMFILE
     55  038b				  -	      else
     56  038b				  -	      dw	NextIL	;39
     57  038b				  -	      dw	NextIL	;40
     58  038b				  -	      dw	NextIL	;41
     59  038b				  -	      dw	NextIL	;42
     60  038b				  -	      dw	NextIL	;43
     61  038b				  -	      dw	NextIL	;44
     62  038b				  -	      dw	NextIL	;45
     63  038b					      endif
     64  038b							;
      0  038b					      dw	iCLEARSCREEN	;46
      1  038b		       87 20		      .word.w	iCLEARSCREEN
      0  038d					      dw	iPOKEMEMORY	;47
      1  038d		       83 0c		      .word.w	iPOKEMEMORY
      0  038f					      dw	iPEEKMEMORY	;48
      1  038f		       98 0c		      .word.w	iPEEKMEMORY
      0  0391					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0391		       ee 09		      .word.w	iTSTLET
      0  0393					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0393		       73 0a		      .word.w	iTSTDONE
      0  0395					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0395		       c5 0c		      .word.w	iGETCHAR
      0  0397					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0397		       d9 0c		      .word.w	iPUTCHAR
      0  0399					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0399		       ae 0c		      .word.w	iCallFunc
      0  039b					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  039b		       d3 05		      .word.w	iBranch
      0  039d					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  039d		       d1 09		      .word.w	iTSTStr
      0  039f					      dw	iSetIrq	;56	   sets the irq handler
      1  039f		       73 0d		      .word.w	iSetIrq
      0  03a1					      dw	iTstIrq	;57	   test if irq is pending
      1  03a1		       e2 0b		      .word.w	iTstIrq
      0  03a3					      dw	iRET	;58	   return from interupt
      1  03a3		       26 05		      .word.w	iRET
      0  03a5					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03a5		       1e 06		      .word.w	iINSTR
      0  03a7					      dw	iMOD	;60	   returns remainder of division
      1  03a7		       58 07		      .word.w	iMOD
      0  03a9					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a9		       d5 18		      .word.w	iTaskSet
      0  03ab					      dw	iETask	;62	   Terminates a task
      1  03ab		       12 1a		      .word.w	iETask
      0  03ad					      dw	iNTask	;63	   goto next task
      1  03ad		       c5 19		      .word.w	iNTask
      0  03af					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03af		       e2 07		      .word.w	iArray
      0  03b1					      dw	iTaskKill	;65	   kill a running task
      1  03b1		       bd 19		      .word.w	iTaskKill
      0  03b3					      dw	iTaskStat	;66	   return the state of a task PID
      1  03b3		       91 19		      .word.w	iTaskStat
      0  03b5					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03b5		       e4 0c		      .word.w	iHexOut
      0  03b7					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b7		       ef 05		      .word.w	iReadComplete
      0  03b9					      dw	iReadStart	;69	   Called to start a background read request
      1  03b9		       e5 05		      .word.w	iReadStart
      0  03bb					      dw	iStartIO	;70	   Lock task until io complete
      1  03bb		       f5 19		      .word.w	iStartIO
      0  03bd					      dw	iEndIO	;71	   release task lock for io
      1  03bd		       fb 19		      .word.w	iEndIO
      0  03bf					      dw	iLogNot	;72	   Logical not
      1  03bf		       4f 0d		      .word.w	iLogNot
      0  03c1					      dw	iLogOr	;73	   Logical Or
      1  03c1		       25 0d		      .word.w	iLogOr
      0  03c3					      dw	iLogAnd	;74	   Logical And
      1  03c3		       10 0d		      .word.w	iLogAnd
      0  03c5					      dw	iLogXor	;75	   Logical Xor
      1  03c5		       3a 0d		      .word.w	iLogXor
      0  03c7					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c7		       d0 19		      .word.w	iWTASK
      0  03c9					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c9		       06 1a		      .word.w	iTASKPID
      0  03cb					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03cb		       b1 0d		      .word.w	iTRACEPROG
      0  03cd					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03cd		       40 1f		      .word.w	idbgBasic
      0  03cf					      dw	iIPCS	;80	   Sending a msg to a task
      1  03cf		       c8 1a		      .word.w	iIPCS
      0  03d1					      dw	iIPCR	;81	   Recieve a message from a task
      1  03d1		       df 1a		      .word.w	iIPCR
      0  03d3					      dw	iIPCC	;82	   Check if any message available for task
      1  03d3		       f3 1a		      .word.w	iIPCC
      0  03d5					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03d5		       00 1b		      .word.w	iIPCIO
      0  03d7					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d7		       4d 17		      .word.w	iPushMathStack
      0  03d9					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d9		       7d 17		      .word.w	iPopMathStack
      0  03db					      dw	iSaveMathStack	;86	   Save all math info
      1  03db		       9a 17		      .word.w	iSaveMathStack
      0  03dd					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03dd		       b9 17		      .word.w	iRestoreMathStack
      0  03df					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03df		       6a 17		      .word.w	iIncParmCount
      0  03e1					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03e1		       32 1a		      .word.w	iTaskGetMathStack
      0  03e3					      dw	iTaskEnable	;90	   enable a suspended task
      1  03e3		       5f 19		      .word.w	iTaskEnable
      0  03e5					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03e5		       79 19		      .word.w	iTaskSuspend
      0  03e7					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e7		       4c 1a		      .word.w	iTaskPutMathPtr
      0  03e9					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e9		       c3 0a		      .word.w	iTSTVT
      0  03eb					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03eb		       6d 09		      .word.w	iSetR2
      0  03ed					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03ed		       04 05		      .word.w	iStk2Tmp
      0  03ef					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03ef		       15 05		      .word.w	iTmp2Stk
      0  03f1					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03f1		       0f 0a		      .word.w	iTSTBYTE
      0  03f3					      dw	iINCVAR	;98	   Increment variable
      1  03f3		       95 0a		      .word.w	iINCVAR
      0  03f5					      dw	iDECVAR	;99	   Decrement variable
      1  03f5		       ad 0a		      .word.w	iDECVAR
      0  03f7					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f7		       5b 1a		      .word.w	iSLICE
      0  03f9					      dw	iTSTB	;101	   Test if byte equals
      1  03f9		       2e 0a		      .word.w	iTSTB
      0  03fb					      dw	iTSTW	;102	   Test If word equals
      1  03fb		       49 0a		      .word.w	iTSTW
      0  03fd					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03fd		       22 12		      .word.w	iOnGoto
      0  03ff					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03ff		       53 12		      .word.w	iTSTRELOP
      0  0401					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  0401		       b8 04		      .word.w	iRepeatLine
      0  0403					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  0403		       7a 12		      .word.w	iTSTBRANCH
      0  0405					      dw	iFastXfer	;107	   move top of stack to curptr
      1  0405		       bf 04		      .word.w	iFastXfer
      0  0407					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  0407		       fd 20		      .word.w	iSetTerminal
      0  0409					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  0409		       d0 07		      .word.w	iINDB
      0  040b					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  040b		       cb 16		      .word.w	iSetBlock
      0  040d					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  040d		       1d 17		      .word.w	iCopyBlock
    131  040f
------- FILE mytb.asm
    514  040f		       04 0f	   ILTBLend   equ	*
    515  040f							;
    516  040f							;=====================================================
    517  040f							;=====================================================
    518  040f							;=====================================================
    519  040f							; This marks the start of the handlers for IL opcodes.
    520  040f							;=====================================================
    521  040f							;=====================================================
    522  040f							;=====================================================
    523  040f							;
    524  040f							;
    525  040f		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    526  0411		       85 47		      sta	ILSTACKPTR
    527  0413		       85 4a		      sta	MATHSTACKPTR
    528  0415		       85 4d		      sta	GOSUBSTACKPTR
    529  0417		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    530  0419		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    531  041b							;
    532  041b		       ad 1c 31 	      lda	ProgramStart	; user prog
    533  041e		       85 4f		      sta	CURPTR
    534  0420		       8d c5 27 	      sta	taskTable+1
    535  0423		       8d 1e 31 	      sta	ProgramEnd
    536  0426		       ad 1d 31 	      lda	ProgramStart+1
    537  0429		       85 50		      sta	CURPTR+1
    538  042b		       8d c6 27 	      sta	taskTable+2
    539  042e		       8d 1f 31 	      sta	ProgramEnd+1
    540  0431		       a9 80		      lda	#TASKACTIVE
    541  0433		       8d c4 27 	      sta	taskTable	;Mark the first slot as active
    542  0436		       a9 01		      lda	#1
    543  0438		       8d c2 28 	      sta	taskCounter	;there is always one task / Main task
    544  043b		       ad c0 28 	      lda	taskResetValue
    545  043e		       8d be 28 	      sta	taskCurrentCycles	; set up the task switch counts
    546  0441		       ad c1 28 	      lda	taskResetValue+1
    547  0444		       8d bf 28 	      sta	taskCurrentCycles+1
    548  0447							;
    549  0447							; fall into XINIT...
    550  0447							;
    551  0447							;=====================================================
    552  0447							; This initializes for the start of the next line of
    553  0447							; BASIC text.
    554  0447							;
    555  0447		       78	   iXINIT     sei		;ensure interupts are off
    556  0448		       20 58 18 	      jsr	taskReset	;Clear the task table
    557  044b		       8d c0 27 	      sta	IRQPending	; reset the irq pending
    558  044e		       8d bf 27 	      sta	IRQStatus	; Make sure irqs are off
    559  0451
    560  0451		       4c c3 02    goodExit   jmp	NextIL
    561  0454							;
    562  0454							;=====================================================
    563  0454							; This check if the escape key has been entered
    564  0454							; then changes out of run mode. z Set if esc found
    565  0454				   BreakSet
    566  0454		       20 0f f0 	      jsr	ISCHAR
    567  0457		       f0 06		      beq	BreakNo
    568  0459		       20 84 20 	      jsr	VGETCH
    569  045c		       c9 1b		      cmp	#$1B
    570  045e		       60		      rts
    571  045f				   BreakNo
    572  045f		       a9 01		      lda	#1
    573  0461		       60		      rts
    574  0462
    575  0462							;
    576  0462
    577  0462							;=====================================================
    578  0462							; Verify there is nothing else on this input line.
    579  0462							; If there is, generate an error.
    580  0462							;
    581  0462		       a4 51	   iDONE      ldy	CUROFF
    582  0464		       b1 4f		      lda	(CURPTR),y
    583  0466		       f0 0e		      beq	doneadv
    584  0468		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    585  046a		       d0 03		      bne	idoneErr
    586  046c							;		  sty	  CUROFF
    587  046c		       4c c3 02 	      jmp	NextIL	; continue on this line
    588  046f
    589  046f				   idoneErr
    590  046f		       a2 04		      ldx	#ERR_EXTRA_STUFF
    591  0471		       a9 00		      lda	#0
    592  0473		       4c b0 06 	      jmp	iErr2
    593  0476							;
    594  0476							; Advance to the next line
    595  0476							;
    596  0476				   doneadv
    597  0476		       4c c3 02 	      jmp	NextIL
    598  0479							;
    599  0479							;=====================================================
    600  0479							; Print the string until a closing quote
    601  0479							;
    602  0479				   iPRS
    603  0479		       20 a5 14 	      jsr	PrtQuoted
    604  047c		       84 51		      sty	CUROFF
    605  047e		       4c c3 02 	      jmp	NextIL
    606  0481							;
    607  0481							;=====================================================
    608  0481							; Pop the top off the stack and print it as a signed
    609  0481							; decimal number.
    610  0481							;
    611  0481				   iPRN
    612  0481		       20 7a 1e 	      jsr	popR0
    613  0484		       20 b1 13 	      jsr	PrintDecimal
    614  0487		       4c c3 02 	      jmp	NextIL
    615  048a							;
    616  048a							;=====================================================
    617  048a							; Space to next zone.	Currently the code does not
    618  048a							; keep track of which column the output is on, so
    619  048a							; just print a tab.
    620  048a							;
    621  048a				   iSPC
    622  048a		       a9 09		      lda	#TAB
    623  048c		       20 81 20 	      jsr	VOUTCH
    624  048f		       4c c3 02 	      jmp	NextIL
    625  0492							;
    626  0492							;=====================================================
    627  0492							; If in immediate mode, jump to the address following
    628  0492							; the NXT instruction.  Else move to the next line of
    629  0492							; user code and continue.
    630  0492							;
    631  0492		       a5 5b	   iNXT       lda	RunMode
    632  0494		       d0 03		      bne	iNxtRun	;in run mode
    633  0496							;
    634  0496							; Get address and jump to it.
    635  0496							;
    636  0496		       4c 63 09 	      jmp	iJMP
    637  0499							;
    638  0499				   iNxtRun
    639  0499		       a4 51		      ldy	CUROFF
    640  049b		       b1 4f		      lda	(CURPTR),y
    641  049d		       c9 e6		      cmp	#oColon
    642  049f		       d0 06		      bne	iNxtRunGo
    643  04a1		       c8		      iny
    644  04a2		       84 51		      sty	CUROFF
    645  04a4		       4c b2 04 	      jmp	iNxtRun2
    646  04a7
    647  04a7				   iNxtRunGo
    648  04a7		       20 79 1c 	      jsr	FindNextLine
    649  04aa		       20 8d 1c 	      jsr	AtEnd
    650  04ad		       d0 03		      bne	iNxtRun2	;not at end
    651  04af							;
    652  04af							; At the end of the program.  Pretend an END statement
    653  04af							; was found.
    654  04af							;
    655  04af		       4c 3d 06    iFINv      jmp	iFIN
    656  04b2							;
    657  04b2		       20 eb 1b    iNxtRun2   jsr	getILWord	;ignore next word
    658  04b5		       4c c3 02 	      jmp	NextIL
    659  04b8							;=====================================================
    660  04b8							;Repeat the same line against
    661  04b8		       a0 03	   iRepeatLine ldy	#3
    662  04ba		       84 51		      sty	CUROFF
    663  04bc		       4c c3 02 	      jmp	NextIL
    664  04bf							;
    665  04bf							;=====================================================
    666  04bf							; XFER takes the number on top of the stack and looks
    667  04bf							; for that line in the program, or the next line
    668  04bf							; higher.  Ie, if it's 1 but there is no line 1, then
    669  04bf							; find the next one after that.
    670  04bf							;
    671  04bf				   iFastXfer
    672  04bf		       20 92 1e 	      jsr	popR1	; get type of transfer
    673  04c2		       a5 54		      lda	R1
    674  04c4		       f0 0e		      beq	iXFER
    675  04c6
    676  04c6		       20 7a 1e 	      jsr	popR0	; get where to transfer
    677  04c9		       a5 52		      lda	R0
    678  04cb		       85 4f		      sta	CURPTR
    679  04cd		       a5 53		      lda	R0+1
    680  04cf		       85 50		      sta	CURPTR+1
    681  04d1		       4c da 04 	      jmp	iXFER2
    682  04d4
    683  04d4				   iXFER
    684  04d4		       20 7a 1e 	      jsr	popR0
    685  04d7		       20 34 1c 	      jsr	findLine
    686  04da
    687  04da				   iXFER2
    688  04da		       20 8d 1c 	      jsr	AtEnd	;at end of user program?
    689  04dd		       f0 d0		      beq	iFINv
    690  04df
    691  04df		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    692  04e1		       84 51		      sty	CUROFF
    693  04e3
    694  04e3							;		  lda	  #$ff
    695  04e3							;		  sta	  RunMode
    696  04e3							;
    697  04e3							; Transfer IL to STMT.  I don't like having this
    698  04e3							; hard-coded; fix it.
    699  04e3							;
    700  04e3							;		  lda	  #STMT&$ff
    701  04e3							;		  sta	  ILPC
    702  04e3							;		  lda	  #STMT>>8
    703  04e3							;		  sta	  ILPC+1
    704  04e3							;		  jmp	  NextIL
    705  04e3							;
    706  04e3							; Run
    707  04e3							;
    708  04e3				   iXferok
    709  04e3		       a9 ff		      lda	#$ff
    710  04e5		       85 5b		      sta	RunMode	;we're running
    711  04e7							;
    712  04e7							; Need a more elegant way to do this
    713  04e7							;
    714  04e7		       a9 75		      lda	#STMT&$ff
    715  04e9		       85 43		      sta	ILPC
    716  04eb		       a9 23		      lda	#STMT>>8
    717  04ed		       85 44		      sta	ILPC+1
    718  04ef		       4c c3 02 	      jmp	NextIL
    719  04f2							;
    720  04f2							;=====================================================
    721  04f2							; Save the pointer to the next line to the call stack.
    722  04f2							;
    723  04f2		       20 ef 1b    iSAV       jsr	getILByte	; load type of gosub
    724  04f5		       20 02 1e 	      jsr	pushLN	; Type passed in A
    725  04f8		       b0 03		      bcs	iSAVErr
    726  04fa		       4c c3 02 	      jmp	NextIL
    727  04fd
    728  04fd		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    729  04ff		       a9 00	   iSAVErr2   lda	#0
    730  0501		       4c b0 06 	      jmp	iErr2
    731  0504							;====================================================
    732  0504							; Move stack top to and from temp area
    733  0504				   iStk2Tmp
    734  0504		       20 7a 1e 	      jsr	popR0
    735  0507		       a5 52		      lda	R0
    736  0509		       a0 34		      ldy	#TASKEXITCODE	; can also be used as temp
    737  050b		       91 41		      sta	(VARIABLES),y
    738  050d		       c8		      iny
    739  050e		       a5 53		      lda	R0+1
    740  0510		       91 41		      sta	(VARIABLES),y
    741  0512		       4c c3 02 	      jmp	NextIL
    742  0515
    743  0515		       a0 34	   iTmp2Stk   ldy	#TASKEXITCODE
    744  0517		       b1 41		      lda	(VARIABLES),y
    745  0519		       85 52		      sta	R0
    746  051b		       c8		      iny
    747  051c		       b1 41		      lda	(VARIABLES),y
    748  051e		       85 53		      sta	R0+1
    749  0520		       20 e8 1d 	      jsr	pushR0
    750  0523		       4c c3 02 	      jmp	NextIL
    751  0526							;
    752  0526							;=====================================================
    753  0526							; Pop the next line from the call stack.
    754  0526							;
    755  0526		       20 2b 1e    iRET       jsr	popLN
    756  0529		       b0 d2		      bcs	iSAVErr
    757  052b		       a0 03		      ldy	#3
    758  052d		       84 51		      sty	CUROFF
    759  052f		       a9 00		      lda	#0
    760  0531		       8d c0 27 	      sta	IRQPending
    761  0534		       58		      cli
    762  0535		       4c c3 02 	      jmp	NextIL
    763  0538							;
    764  0538							;=====================================================
    765  0538							; On entry il, branch to if function
    766  0538							;	    il+1, value to be returned or not true or false
    767  0538							;
    768  0538							; Return from GOSUB function
    769  0538							;
    770  0538		       20 ef 1b    iRSTR      jsr	getILByte	; get where to go if gosub is a fucntion
    771  053b		       8d 18 31 	      sta	offset
    772  053e		       20 d2 1d 	      jsr	saveIL	; for later jump if needed
    773  0541
    774  0541		       20 2b 1e 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    775  0544		       85 54		      sta	R1	; keep the type of call returning from
    776  0546		       b0 2a		      bcs	iRSTRErr	; stack underflow error possible
    777  0548
    778  0548		       20 ef 1b 	      jsr	getILByte	; get if a value is being returned
    779  054b		       48		      pha		; save if a value was passed to be returned
    780  054c		       c9 00		      cmp	#0	; yes attemping to return a value
    781  054e		       f0 03		      beq	iRSTRPOP	; no value to return
    782  0550		       20 7a 1e 	      jsr	popR0	; Get the value from the stack save if needed
    783  0553				   iRSTRPOP
    784  0553		       20 83 17 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    785  0556		       a5 54		      lda	R1	; called as a statement ?
    786  0558		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    787  055a		       f0 12		      beq	iRSTRExit
    788  055c		       68		      pla		; get back if value returned or not
    789  055d		       c9 01		      cmp	#1	; we have a value to return
    790  055f		       f0 04		      beq	iRSTRVALUE
    791  0561
    792  0561		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    793  0563		       d0 9a		      bne	iSAVErr2
    794  0565
    795  0565				   iRSTRVALUE
    796  0565		       20 e8 1d 	      jsr	pushR0	; return value back to top of stack
    797  0568		       20 dd 1d 	      jsr	restoreIL	; get the correct il
    798  056b		       4c c3 0b 	      jmp	tstBranch	; And called as a function
    799  056e
    800  056e				   iRSTRExit
    801  056e		       68		      pla		; throw away the return value if provided
    802  056f		       4c c3 02 	      jmp	NextIL
    803  0572
    804  0572				   iRSTRNORETURNVALUE
    805  0572
    806  0572
    807  0572		       ad c3 27    iRSTRErr   lda	taskPtr	; Check if this is task zero
    808  0575		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    809  0577		       a5 56		      lda	MQ
    810  0579		       d0 03		      bne	taskRet
    811  057b		       20 9c 20 	      jsr	pushFalse	; the result code by default is 0
    812  057e				   taskRet
    813  057e		       4c 12 1a 	      jmp	iETask	; not task zero then do a task end instead
    814  0581				   taskZeroEnd
    815  0581		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    816  0583		       4c ff 04 	      jmp	iSAVErr2
    817  0586							;
    818  0586							;=====================================================
    819  0586							; Compare items on stack.  Okay, so on input there are
    820  0586							; three things on the stack
    821  0586							;
    822  0586							;    EXPR2 <- Top of stack
    823  0586							;    OP    <- relational operator, next on stack
    824  0586							;    EXPR1 <- last item on stack
    825  0586							;
    826  0586							; Comparison is: EXPR1 <operator> EXPR2
    827  0586							;
    828  0586							; Operator is one of...
    829  0586							;
    830  0586							;    2 is =
    831  0586							;    1 is <
    832  0586							;    3 is <=
    833  0586							;    5 is <>
    834  0586							;    4 is >
    835  0586							;    6 is >=
    836  0586							;
    837  0586							; Those are bit-mapped:
    838  0586							;
    839  0586							;    xxxxxGEL
    840  0586							;
    841  0586							;    G = Greater than
    842  0586							;    E = Equal
    843  0586							;    L = Less than
    844  0586							;
    845  0586							; If the comparison is false, do a NXT, ie, move to the
    846  0586							; next line and continue.  If true, continue executing
    847  0586							; on this line.
    848  0586							;
    849  0586		       00 01	   REL_LT     equ	%001
    850  0586		       00 02	   REL_EQUAL  equ	%010
    851  0586		       00 04	   REL_GT     equ	%100
    852  0586							;
    853  0586		       20 92 1e    iCMPR      jsr	popR1
    854  0589		       20 a9 1e 	      jsr	popMQ	;operator in MQ
    855  058c		       20 7a 1e 	      jsr	popR0
    856  058f		       20 98 05 	      jsr	iCMPRsub
    857  0592		       20 e8 1d 	      jsr	pushR0
    858  0595		       4c c3 02 	      jmp	NextIL
    859  0598							;
    860  0598							; See if they are equal or not
    861  0598							;
    862  0598				   iCMPRsub		; Called by internal functions
    863  0598
    864  0598		       a5 52		      lda	R0
    865  059a		       c5 54		      cmp	R1
    866  059c		       d0 0a		      bne	iCMPRnoteq	;try not equal
    867  059e		       a5 53		      lda	R0+1
    868  05a0		       c5 55		      cmp	R1+1
    869  05a2		       d0 04		      bne	iCMPRnoteq
    870  05a4							;
    871  05a4							; Equal, set the flag in MQ+1
    872  05a4							;
    873  05a4		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    874  05a6		       d0 14		      bne	iCMPcom	;Exit it is equal
    875  05a8							;
    876  05a8							; See if EXPR1 (R0) < EXPR2 (R1)
    877  05a8							; See www.6502.org/tutorials/compare_beyond.html
    878  05a8							;
    879  05a8				   iCMPRnoteq
    880  05a8		       a5 52		      lda	R0
    881  05aa		       c5 54		      cmp	R1	; Sets the carry flag
    882  05ac		       a5 53		      lda	R0+1
    883  05ae		       e5 55		      sbc	R1+1
    884  05b0
    885  05b0		       50 02		      bvc	iCMPR_2	; branch if N eor V
    886  05b2		       49 80		      eor	#$80
    887  05b4
    888  05b4		       30 04	   iCMPR_2    bmi	iCMPlt
    889  05b6		       a9 04		      lda	#REL_GT
    890  05b8		       d0 02		      bne	iCMPcom
    891  05ba
    892  05ba		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    893  05bc
    894  05bc				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    895  05bc							;
    896  05bc							; Now compare the end result with what the caller
    897  05bc							; was looking for.
    898  05bc							;
    899  05bc		       25 56		      and	MQ
    900  05be		       f0 0c		      beq	iCMPno	; no match
    901  05c0		       a9 ff		      lda	#$FF	; true is $ffff
    902  05c2		       85 52		      sta	R0
    903  05c4		       85 53		      sta	R0+1
    904  05c6		       d0 0a		      bne	iCMPDone
    905  05c8							;
    906  05c8							; R0 > R1
    907  05c8							;
    908  05c8		       a9 04	   iCMPgt     lda	#REL_GT
    909  05ca		       d0 f0		      bne	iCMPcom
    910  05cc				   iCMPno
    911  05cc		       a9 00		      lda	#0
    912  05ce		       85 52		      sta	R0
    913  05d0		       85 53		      sta	R0+1
    914  05d2
    915  05d2				   iCMPDone
    916  05d2		       60		      rts
    917  05d3
    918  05d3							;
    919  05d3							; if Not a match, so jump to the next line of code.
    920  05d3							; Branches based upon value on top of the stack
    921  05d3				   iBranch
    922  05d3		       20 7a 1e 	      jsr	popR0
    923  05d6		       a5 52		      lda	R0
    924  05d8		       05 53		      ora	R0+1
    925  05da		       f0 03		      beq	iBranchFalse	; not true
    926  05dc		       4c c3 02 	      jmp	NextIL	; It is true if any value not zero
    927  05df							;
    928  05df				   iBranchFalse
    929  05df		       20 79 1c 	      jsr	FindNextLine
    930  05e2		       4c da 04 	      jmp	iXFER2
    931  05e5							;
    932  05e5							;=====================================================
    933  05e5							; Start a read of data in background
    934  05e5				   iReadStart
    935  05e5		       a9 3f		      lda	#'?	; Prompt with question mark
    936  05e7		       a6 01		      ldx	1	; Indicate to start read in background
    937  05e9		       20 05 1d 	      jsr	GetLine	; Call the getline to start read
    938  05ec		       4c c3 02 	      jmp	NextIL	; next instruction
    939  05ef							;
    940  05ef							;=====================================================
    941  05ef							; Complete the read and return the curptr, curoff pointing to data
    942  05ef				   iReadComplete
    943  05ef		       a9 01		      lda	#GOSUB_RTN
    944  05f1		       20 02 1e 	      jsr	pushLN
    945  05f4		       90 03		      bcc	iReadOk
    946  05f6		       4c 15 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    947  05f9				   iReadOk
    948  05f9		       20 25 1d 	      jsr	ReadComplete
    949  05fc		       4c c3 02 	      jmp	NextIL
    950  05ff		       20 2b 1e 	      jsr	popLN
    951  0602		       4c c3 02 	      jmp	NextIL
    952  0605							;=====================================================
    953  0605							; Get a line of text from the user, convert to a
    954  0605							; number, leave on top of stack.
    955  0605							;
    956  0605				   iINNUM
    957  0605		       a9 01		      lda	#GOSUB_RTN
    958  0607		       20 02 1e 	      jsr	pushLN
    959  060a		       b0 ea		      bcs	iReadErr	; Stack over flow error
    960  060c							;
    961  060c		       a9 3f		      lda	#'?
    962  060e		       a2 00		      ldx	#0	;Wait for complete
    963  0610		       20 05 1d 	      jsr	GetLine
    964  0613		       20 9a 1c 	      jsr	getDecimal
    965  0616		       20 e8 1d 	      jsr	pushR0	;put onto stack
    966  0619		       b0 db		      bcs	iReadErr	;StackOverflow error
    967  061b							;
    968  061b		       4c 37 06 	      jmp	ExitIn
    969  061e							;
    970  061e							;=====================================================
    971  061e							; Get a line of text from the user, convert to a
    972  061e							; character value , leave on top of stack. up to 2 characters
    973  061e							;
    974  061e				   iINSTR
    975  061e		       a9 01		      lda	#GOSUB_RTN
    976  0620		       20 02 1e 	      jsr	pushLN
    977  0623		       b0 d1		      bcs	iReadErr	; Stack overflow error
    978  0625		       a9 3f		      lda	#'?
    979  0627		       a2 00		      ldx	#0	;wait for read complete
    980  0629		       20 05 1d 	      jsr	GetLine
    981  062c		       b1 4f		      lda	(CURPTR),y
    982  062e		       85 52		      sta	R0
    983  0630		       a9 00		      lda	#0
    984  0632		       85 53		      sta	R0+1
    985  0634		       20 e8 1d 	      jsr	pushR0	;put onto stack
    986  0637				   ExitIn
    987  0637		       20 2b 1e 	      jsr	popLN
    988  063a		       4c c3 02 	      jmp	NextIL
    989  063d							;
    990  063d							;
    991  063d							;=====================================================
    992  063d							; Stop the currently running program.	Actually very
    993  063d							; simple to do... clear the RunMode flag, then set the
    994  063d							; ILPC to the standard handler and continue running.
    995  063d							;
    996  063d		       a9 00	   iFIN       lda	#0
    997  063f		       85 5b		      sta	RunMode
    998  0641		       20 58 18 	      jsr	taskReset
    999  0644							;
   1000  0644		       ad 09 31 	      lda	errGoto
   1001  0647		       85 43		      sta	ILPC
   1002  0649		       ad 0a 31 	      lda	errGoto+1
   1003  064c		       85 44		      sta	ILPC+1
   1004  064e		       4c c3 02 	      jmp	NextIL
   1005  0651							;
   1006  0651							;=====================================================
   1007  0651							; Handle the ERR opcode.  Following the instruction is
   1008  0651							; a 16 bit error number.  Print an error message, and
   1009  0651							; if we're in run mode, print the line number.  Stop
   1010  0651							; program execution and return to the initial state.
   1011  0651							;
   1012  0651		       20 eb 1b    iERR       jsr	getILWord	;get err code
   1013  0654		       20 5a 06 	      jsr	DisplayError
   1014  0657		       4c b3 06 	      jmp	iErrComplete
   1015  065a							;
   1016  065a							; Enter here with the error code in X (LSB) and A (MSB).
   1017  065a							;
   1018  065a				   DisplayError
   1019  065a		       86 52		      stx	R0
   1020  065c		       85 53		      sta	R0+1
   1021  065e							;
   1022  065e		       20 82 14 	      jsr	puts
      0  0661					      db	CR,LF,"Error ",0
      1  0661		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
   1024  066a		       20 b1 13 	      jsr	PrintDecimal
   1025  066d							;
   1026  066d		       a5 5b		      lda	RunMode	;running?
   1027  066f		       f0 3b		      beq	iERR3	;nope
   1028  0671		       20 82 14 	      jsr	puts
      0  0674					      db	" at line ",0
      1  0674		       20 61 74 20*	      .byte.b	" at line ",0
   1030  067e		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
   1031  0680				   iErr2a
   1032  0680		       b1 4f		      lda	(CURPTR),y
   1033  0682		       85 52		      sta	R0
   1034  0684		       c8		      iny
   1035  0685		       b1 4f		      lda	(CURPTR),y
   1036  0687		       85 53		      sta	R0+1
   1037  0689		       20 b1 13 	      jsr	PrintDecimal
   1038  068c		       20 82 14 	      jsr	puts
      0  068f					      db	":",0
      1  068f		       3a 00		      .byte.b	":",0
   1040  0691		       a9 00		      lda	#0
   1041  0693		       85 53		      sta	R0+1
   1042  0695		       a5 51		      lda	CUROFF
   1043  0697		       18		      clc
   1044  0698		       e9 03		      sbc	#3
   1045  069a		       85 52		      sta	R0
   1046  069c		       20 b1 13 	      jsr	PrintDecimal
   1047  069f		       20 82 14 	      jsr	puts
      0  06a2					      db	":",0
      1  06a2		       3a 00		      .byte.b	":",0
   1049  06a4		       ad c3 27 	      lda	taskPtr
   1050  06a7		       85 52		      sta	R0
   1051  06a9		       20 65 14 	      jsr	HexToOut
   1052  06ac							;
   1053  06ac				   iERR3
   1054  06ac		       20 33 1f 	      jsr	CRLF
   1055  06af		       60		      rts
   1056  06b0
   1057  06b0				   iErr2
   1058  06b0		       20 5a 06 	      jsr	DisplayError
   1059  06b3
   1060  06b3				   iErrComplete
   1061  06b3		       20 50 18 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1062  06b6		       a9 00		      lda	#0
   1063  06b8		       85 5b		      sta	RunMode	; fall through...
   1064  06ba							;
   1065  06ba							;=====================================================
   1066  06ba							; Reset the IL to be back at the idle loop.  Does not
   1067  06ba							; clear variables so the user can see what state
   1068  06ba							; the program is in.
   1069  06ba							;
   1070  06ba		       a9 00	   ResetIL    lda	#0
   1071  06bc		       85 47		      sta	ILSTACKPTR
   1072  06be		       ad 09 31 	      lda	errGoto
   1073  06c1		       85 43		      sta	ILPC
   1074  06c3		       ad 0a 31 	      lda	errGoto+1
   1075  06c6		       85 44		      sta	ILPC+1
   1076  06c8		       4c c3 02 	      jmp	NextIL
   1077  06cb
   1078  06cb							;
   1079  06cb							;=====================================================
   1080  06cb							; Pop two items off stack, add them, then place the
   1081  06cb							; result back onto the stack.
   1082  06cb							;
   1083  06cb		       20 7a 1e    iADD       jsr	popR0
   1084  06ce		       20 92 1e 	      jsr	popR1
   1085  06d1				   iADDfast
   1086  06d1		       18		      clc
   1087  06d2		       a5 52		      lda	R0
   1088  06d4		       65 54		      adc	R1
   1089  06d6		       85 52		      sta	R0
   1090  06d8		       a5 53		      lda	R0+1
   1091  06da		       65 55		      adc	R1+1
   1092  06dc		       85 53		      sta	R0+1
   1093  06de		       4c 49 07 	      jmp	pushR0nextIl
   1094  06e1							;
   1095  06e1							;=====================================================
   1096  06e1							; Pop two items off the stack.  Subtract the top of
   1097  06e1							; stack from the lower entry.
   1098  06e1							;
   1099  06e1		       20 92 1e    iSUB       jsr	popR1
   1100  06e4		       20 7a 1e 	      jsr	popR0
   1101  06e7		       38		      sec
   1102  06e8		       a5 52		      lda	R0
   1103  06ea		       e5 54		      sbc	R1
   1104  06ec		       85 52		      sta	R0
   1105  06ee		       a5 53		      lda	R0+1
   1106  06f0		       e5 55		      sbc	R1+1
   1107  06f2		       85 53		      sta	R0+1
   1108  06f4		       4c 49 07 	      jmp	pushR0nextIl
   1109  06f7							;
   1110  06f7							;=====================================================
   1111  06f7							; Negate the top of stack.
   1112  06f7							;
   1113  06f7		       20 7a 1e    iNEG       jsr	popR0
   1114  06fa		       a5 52		      lda	R0
   1115  06fc		       49 ff		      eor	#$ff
   1116  06fe		       85 52		      sta	R0
   1117  0700		       a5 53		      lda	R0+1
   1118  0702		       49 ff		      eor	#$ff
   1119  0704		       85 53		      sta	R0+1
   1120  0706		       e6 52		      inc	R0
   1121  0708		       d0 02		      bne	iNEG2
   1122  070a		       e6 53		      inc	R0+1
   1123  070c		       4c 49 07    iNEG2      jmp	pushR0nextIl
   1124  070f							;
   1125  070f							;=====================================================
   1126  070f							; Multiply top two items on the stack, put the results
   1127  070f							; on top.  This uses the algorithm documented on page
   1128  070f							; 115 of "Microprocessor Programming for Computer
   1129  070f							; Hobbyists" by Neill Graham.
   1130  070f							;
   1131  070f		       20 15 07    iMUL       jsr	iMultiply
   1132  0712		       4c c3 02 	      jmp	NextIL
   1133  0715
   1134  0715				   iMultiply
   1135  0715		       20 7a 1e 	      jsr	popR0	;AC
   1136  0718		       20 92 1e 	      jsr	popR1	;OP
   1137  071b							;
   1138  071b		       a5 52		      lda	R0
   1139  071d		       85 56		      sta	MQ
   1140  071f		       a5 53		      lda	R0+1
   1141  0721		       85 57		      sta	MQ+1
   1142  0723		       a9 00		      lda	#0	;clear result
   1143  0725		       85 52		      sta	R0
   1144  0727		       85 53		      sta	R0+1
   1145  0729							;
   1146  0729		       a2 10		      ldx	#16	;number of bits in value
   1147  072b		       06 52	   multloop   asl	R0
   1148  072d		       26 53		      rol	R0+1
   1149  072f		       06 56		      asl	MQ
   1150  0731		       26 57		      rol	MQ+1
   1151  0733		       90 0d		      bcc	multno	;skip add if no carry
   1152  0735							;
   1153  0735							; Add R1 back into R0
   1154  0735							;
   1155  0735		       18		      clc
   1156  0736		       a5 52		      lda	R0
   1157  0738		       65 54		      adc	R1
   1158  073a		       85 52		      sta	R0
   1159  073c		       a5 53		      lda	R0+1
   1160  073e		       65 55		      adc	R1+1
   1161  0740		       85 53		      sta	R0+1
   1162  0742							;
   1163  0742		       ca	   multno     dex		;did all bits yet?
   1164  0743		       d0 e6		      bne	multloop
   1165  0745		       20 e8 1d 	      jsr	pushR0	;OP
   1166  0748		       60		      rts
   1167  0749							;
   1168  0749				   pushR0nextIl
   1169  0749		       20 e8 1d 	      jsr	pushR0	;OP
   1170  074c		       4c c3 02 	      jmp	NextIL
   1171  074f							;
   1172  074f							;=====================================================
   1173  074f							; Divide the top of stack into the next to top item.
   1174  074f							; Leave results on stack.  Taken from:
   1175  074f							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1176  074f							;
   1177  074f							; R0 = R0 / R1
   1178  074f							; Remainder is in MQ
   1179  074f							;
   1180  074f		       20 69 07    iDIV       jsr	iDoDiv
   1181  0752		       20 fb 1e 	      jsr	RestoreSigns
   1182  0755		       4c 49 07 	      jmp	pushR0nextIl
   1183  0758
   1184  0758		       20 69 07    iMOD       jsr	iDoDiv
   1185  075b		       20 fb 1e 	      jsr	RestoreSigns
   1186  075e		       a5 56		      lda	MQ
   1187  0760		       85 52		      sta	R0
   1188  0762		       a5 57		      lda	MQ+1
   1189  0764		       85 53		      sta	R0+1
   1190  0766		       4c 49 07 	      jmp	pushR0nextIl
   1191  0769
   1192  0769				   iDoDiv
   1193  0769		       20 92 1e 	      jsr	popR1
   1194  076c		       20 7a 1e 	      jsr	popR0
   1195  076f							;
   1196  076f							; Check for divide by zero
   1197  076f							;
   1198  076f
   1199  076f				   iDivNoPop
   1200  076f		       a5 54		      lda	R1
   1201  0771		       05 55		      ora	R1+1
   1202  0773		       f0 29		      beq	divby0
   1203  0775							;
   1204  0775		       20 c0 1e 	      jsr	SaveSigns
   1205  0778		       a9 00		      lda	#0	;preset remainder to 0
   1206  077a		       85 56		      sta	MQ
   1207  077c		       85 57		      sta	MQ+1
   1208  077e		       a2 10		      ldx	#16	;repeat for each bit: ...
   1209  0780				   divloop
   1210  0780		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1211  0782		       26 53		      rol	R0+1
   1212  0784		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1213  0786		       26 57		      rol	MQ+1
   1214  0788		       a5 56		      lda	MQ
   1215  078a		       38		      sec
   1216  078b		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1217  078d		       a8		      tay		;lb result -> Y, for we may need it later
   1218  078e		       a5 57		      lda	MQ+1
   1219  0790		       e5 55		      sbc	R1+1
   1220  0792		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1221  0794
   1222  0794		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1223  0796		       84 56		      sty	MQ
   1224  0798		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1225  079a
   1226  079a		       ca	   skip       dex
   1227  079b		       d0 e3		      bne	divloop
   1228  079d		       60		      rts
   1229  079e							;
   1230  079e							; Indicate divide-by-zero error
   1231  079e							;
   1232  079e		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1233  07a0		       a9 00		      lda	#0
   1234  07a2		       4c b0 06 	      jmp	iErr2
   1235  07a5							;
   1236  07a5							;=====================================================
   1237  07a5							; This pops the top two items off the stack.  The top
   1238  07a5							; item is a data value and the other is an ABSOLUTE address.
   1239  07a5							; Save the value into that address.
   1240  07a5							;
   1241  07a5		       98	   iSTORE     tya
   1242  07a6		       48		      pha
   1243  07a7		       20 7a 1e 	      jsr	popR0	;data
   1244  07aa		       20 92 1e 	      jsr	popR1	;Storage location
   1245  07ad		       a0 01		      ldy	#1
   1246  07af		       a5 58		      lda	R2
   1247  07b1		       c9 a2		      cmp	#tByte
   1248  07b3		       f0 04		      beq	iStoreB
   1249  07b5				   iStoreW
   1250  07b5		       a5 53		      lda	R0+1
   1251  07b7		       91 54		      sta	(R1),y
   1252  07b9				   iStoreB
   1253  07b9		       a5 52		      lda	R0
   1254  07bb		       88		      dey
   1255  07bc		       91 54		      sta	(R1),y
   1256  07be		       68		      pla
   1257  07bf		       a8		      tay
   1258  07c0		       4c c3 02 	      jmp	NextIL
   1259  07c3							;
   1260  07c3							;=====================================================
   1261  07c3							; Replaces the top of stack with the Value
   1262  07c3							; of the variable  whose absolute address it represents.
   1263  07c3							;
   1264  07c3
   1265  07c3		       98	   iIND       tya
   1266  07c4		       48		      pha
   1267  07c5		       20 92 1e 	      jsr	popR1
   1268  07c8		       a0 01		      ldy	#1
   1269  07ca		       a5 58		      lda	R2
   1270  07cc		       c9 a1		      cmp	#tInteger
   1271  07ce		       f0 04		      beq	iINDW
   1272  07d0				   iINDB
   1273  07d0		       a9 00		      lda	#0
   1274  07d2		       f0 02		      BEQ	iINDC
   1275  07d4				   iINDW
   1276  07d4		       b1 54		      lda	(R1),y
   1277  07d6				   iINDC
   1278  07d6		       85 53		      sta	R0+1
   1279  07d8		       88		      dey
   1280  07d9		       b1 54		      lda	(R1),y
   1281  07db		       85 52		      sta	R0
   1282  07dd		       68		      pla
   1283  07de		       a8		      tay
   1284  07df		       4c 49 07 	      jmp	pushR0nextIl
   1285  07e2
   1286  07e2							;
   1287  07e2							;=====================================================
   1288  07e2							; Check which type of index to use byte or word and jmp to correct
   1289  07e2							; function
   1290  07e2				   iArray
   1291  07e2		       20 ef 1b 	      jsr	getILByte
   1292  07e5		       c9 a1		      cmp	#tInteger
   1293  07e7		       f0 09		      beq	iArrayW
   1294  07e9							;
   1295  07e9							;=====================================================
   1296  07e9							; Get from Byte array not Integer array
   1297  07e9				   iArrayB
   1298  07e9		       20 7a 1e 	      jsr	popR0	; Get the array index
   1299  07ec		       20 92 1e 	      jsr	popR1	; Get the Variable address
   1300  07ef		       4c fd 07 	      jmp	iArrayAll	; It will be a byte value
   1301  07f2
   1302  07f2							;=====================================================
   1303  07f2							; Get the array index from top of stack get Current variable
   1304  07f2							; address from next on stack, add the offset
   1305  07f2							; push the result back onto the stack
   1306  07f2				   iArrayW
   1307  07f2		       20 7a 1e 	      jsr	popR0	; Get the array index
   1308  07f5		       20 92 1e 	      jsr	popR1	; Get the Variable address
   1309  07f8
   1310  07f8		       18		      clc		; Multiplythe value by 2
   1311  07f9		       26 52		      rol	R0	; Do the multiply
   1312  07fb		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1313  07fd				   iArrayAll
   1314  07fd		       18		      clc
   1315  07fe		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1316  0800		       65 52		      adc	R0
   1317  0802		       85 52		      sta	R0
   1318  0804		       a5 55		      lda	R1+1
   1319  0806		       65 53		      adc	R0+1
   1320  0808		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1321  080a		       20 e8 1d 	      jsr	pushR0	; Push R0 assume it is correct
   1322  080d
   1323  080d		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1324  080f		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1325  0811		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1326  0813		       a5 55		      lda	R1+1
   1327  0815		       c5 42		      cmp	VARIABLES+1
   1328  0817		       d0 1c		      bne	iArrayAtTest
   1329  0819		       18		      clc
   1330  081a		       a9 34		      lda	#52	; add the max offset that is valid
   1331  081c		       65 54		      adc	R1	; update to be the largest offset that is valid
   1332  081e		       85 54		      sta	R1
   1333  0820		       a9 00		      lda	#0
   1334  0822		       65 55		      adc	R1+1
   1335  0824		       85 55		      sta	R1+1
   1336  0826				   iArrayVerify 		; try to enforce some sanity to using arrays
   1337  0826		       a5 53		      lda	R0+1
   1338  0828		       c5 55		      cmp	R1+1
   1339  082a		       d0 04		      bne	iArrayDecide
   1340  082c		       a5 52		      lda	R0
   1341  082e		       c5 54		      cmp	R1
   1342  0830				   iArrayDecide
   1343  0830		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1344  0832		       4c c3 02 	      jmp	NextIL
   1345  0835
   1346  0835				   iArrayAtTest
   1347  0835		       ad 20 31 	      lda	HighMem
   1348  0838		       85 54		      sta	R1
   1349  083a		       ad 21 31 	      lda	HighMem+1
   1350  083d		       85 55		      sta	R1+1
   1351  083f		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1352  0841
   1353  0841							; Get here if array index is out of range
   1354  0841		       20 7a 1e    iArrayError jsr	popR0
   1355  0844		       a9 00		      lda	#0
   1356  0846		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1357  0848		       4c b0 06 	      jmp	iErr2
   1358  084b							;
   1359  084b							;=====================================================
   1360  084b							; List the current BASIC program in memory.  Uses R0,
   1361  084b							; tempIly, and dpl.
   1362  084b							;
   1363  084b		       20 67 20    iLST       jsr	SetOutConsole
   1364  084e		       ad 1c 31    iLST2      lda	ProgramStart
   1365  0851		       85 59		      sta	dpl
   1366  0853		       ad 1d 31 	      lda	ProgramStart+1
   1367  0856		       85 5a		      sta	dpl+1
   1368  0858							;
   1369  0858							; dpl/dph point to the current line.  See if we're at
   1370  0858							; the end of the program.
   1371  0858							;
   1372  0858		       a5 59	   iLSTloop   lda	dpl
   1373  085a		       cd 1e 31 	      cmp	ProgramEnd
   1374  085d		       d0 07		      bne	iLstNotEnd
   1375  085f		       a5 5a		      lda	dpl+1
   1376  0861		       cd 1f 31 	      cmp	ProgramEnd+1
   1377  0864		       f0 15		      beq	iLstdone
   1378  0866							;
   1379  0866		       20 1a 15    iLstNotEnd jsr	PrintProgramLine
   1380  0869							;		  ldy	  #1		  ;Change:  Skip first byte length
   1381  0869							;		  lda	  (dpl),y	  ;line number LSB
   1382  0869							;		  sta	  R0
   1383  0869							;		  iny
   1384  0869							;		  lda	  (dpl),y		 ;line number MSB
   1385  0869							;		  sta	  R0+1
   1386  0869							;		  iny
   1387  0869							;		  sty	  tempIlY
   1388  0869							;		  jsr	  PrintDecimal
   1389  0869							;		  lda	  #SPACE
   1390  0869							;		  jsr	  VOUTCH
   1391  0869							;		  ldy	  tempIlY
   1392  0869							;iLSTl2	  lda	  (dpl),y
   1393  0869							;		  beq	  iLST3 	  ;end of this line 0 value
   1394  0869							;		  sty	  tempIlY
   1395  0869							;		  jsr	  VOUTCH
   1396  0869							;		  ldy	  tempIlY
   1397  0869							;		  iny
   1398  0869							;		  bne	  iLSTl2	  ;do next char
   1399  0869							;
   1400  0869							; End of this line.  Print CR/LF, then move to the
   1401  0869							; next line.
   1402  0869							;
   1403  0869		       a0 00	   iLST3      ldy	#0	;Move to next line
   1404  086b		       b1 59		      lda	(dpl),y	;Current line length
   1405  086d		       18		      clc		;Clear the carry flag
   1406  086e							;		  tya
   1407  086e		       65 59		      adc	dpl	;Add the offset to the pointer
   1408  0870		       85 59		      sta	dpl	;Save the new value
   1409  0872		       a5 5a		      lda	dpl+1	;Next byte
   1410  0874		       69 00		      adc	#0	;ad in the carry if any
   1411  0876		       85 5a		      sta	dpl+1	;Save it
   1412  0878							;
   1413  0878							; Have to manually do CR/LF so it uses the vectored
   1414  0878							; output function.
   1415  0878							;
   1416  0878							;		  lda	  #CR
   1417  0878							;		  jsr	  VOUTCH
   1418  0878							;		  lda	  #LF
   1419  0878							;		  jsr	  VOUTCH
   1420  0878		       4c 58 08 	      jmp	iLSTloop	;do next line
   1421  087b							;
   1422  087b		       20 67 20    iLstdone   jsr	SetOutConsole
   1423  087e		       4c c3 02 	      jmp	NextIL
   1424  0881							;
   1425  0881							;=====================================================
   1426  0881							; Get a line of text into LINBUF.  Terminate with a
   1427  0881							; null byte.
   1428  0881							;
   1429  0881				   iGETLINE
   1430  0881		       a9 3e		      lda	#'>	;prompt character
   1431  0883		       a6 00		      ldx	0	;Wait for read to complete
   1432  0885		       20 05 1d 	      jsr	GetLine
   1433  0888							;
   1434  0888		       a9 00		      lda	#0
   1435  088a		       85 5b		      sta	RunMode
   1436  088c				   iGetParseLine
   1437  088c							; lda	   CUROFF
   1438  088c							; pha
   1439  088c		       20 2c 10 	      jsr	ParseInputLine
   1440  088f							; pla
   1441  088f							;  sta     CUROFF
   1442  088f		       a9 29		      lda	#TOKENBUFFER&$FF
   1443  0891		       85 4f		      sta	CURPTR
   1444  0893		       a9 0f		      lda	#TOKENBUFFER>>8
   1445  0895		       85 50		      sta	CURPTR+1
   1446  0897		       a9 01		      lda	#1
   1447  0899		       85 51		      sta	CUROFF
   1448  089b		       4c c3 02 	      jmp	NextIL
   1449  089e							;
   1450  089e							;=====================================================
   1451  089e							; This is called when the input buffer contains a line
   1452  089e							; typed in by the user that starts with a line number.
   1453  089e							; Insert the line into the program or delete the line
   1454  089e							; if there is nothing after the line number,
   1455  089e							;
   1456  089e				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1457  089e		       ad 2a 0f 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1458  08a1		       85 52		      sta	R0	; place the number into R0
   1459  08a3		       ad 2b 0f 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1460  08a6		       85 53		      STA	R0+1	; Place it into
   1461  08a8							;
   1462  08a8							; Now find the line OR the next higher line OR the
   1463  08a8							; end of the program.
   1464  08a8							;
   1465  08a8		       20 34 1c 	      jsr	findLine	; Look for the line number in the current program
   1466  08ab							; Returns Z and curptr point to the line if found
   1467  08ab							; Returns C and curptr at next higher line if not found and there is a higher line
   1468  08ab							; Returns ZC clear and curptr to end of program if higher than all other lines
   1469  08ab							;
   1470  08ab							; If the line exists, it needs to be removed.
   1471  08ab							;
   1472  08ab		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1473  08ad							;
   1474  08ad							; Get length of line to be removed, we fall thru to here if we find a matching line
   1475  08ad							;
   1476  08ad							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1477  08ad		       a0 00		      ldy	#0
   1478  08af		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1479  08b1		       a8		      tay
   1480  08b2							;If it is equal we delete the line and replace it, get length
   1481  08b2							;then adjust all program line after up or down depending on len of line
   1482  08b2							;If next higher then just move everythimg down by length bytes
   1483  08b2							;This call will return how many bytes in the line we found
   1484  08b2		       8c 19 31 	      sty	lineLength	;Save the length of the line we found
   1485  08b5							;
   1486  08b5							; Compute the new end of the program first.
   1487  08b5							;
   1488  08b5		       38		      sec		;Set the carry bit
   1489  08b6		       ad 1e 31 	      lda	ProgramEnd	;Get low byte of program end
   1490  08b9		       ed 19 31 	      sbc	lineLength	;Subtract the length of the current line
   1491  08bc		       8d 1e 31 	      sta	ProgramEnd	;save it
   1492  08bf		       ad 1f 31 	      lda	ProgramEnd+1
   1493  08c2		       e9 00		      sbc	#0	;Process the carry
   1494  08c4		       8d 1f 31 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1495  08c7							;
   1496  08c7							; Copy CURPTR into R1 for working
   1497  08c7							;
   1498  08c7		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1499  08c9		       85 54		      sta	R1
   1500  08cb		       a5 50		      lda	CURPTR+1
   1501  08cd		       85 55		      sta	R1+1
   1502  08cf							;
   1503  08cf							; See if we're at the end.
   1504  08cf							;
   1505  08cf		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1506  08d1		       cd 1e 31 	      cmp	ProgramEnd
   1507  08d4		       d0 07		      bne	InsDelLoop
   1508  08d6		       a5 55		      lda	R1+1
   1509  08d8		       cd 1f 31 	      cmp	ProgramEnd+1
   1510  08db		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1511  08dd							;
   1512  08dd							; Move one byte, move to next location.
   1513  08dd							;
   1514  08dd		       ac 19 31    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1515  08e0		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1516  08e2		       b1 54		      lda	(R1),y
   1517  08e4		       a0 00		      ldy	#0
   1518  08e6		       91 54		      sta	(R1),y
   1519  08e8		       e6 54		      inc	R1
   1520  08ea		       d0 e3		      bne	InsDelChk
   1521  08ec		       e6 55		      inc	R1+1
   1522  08ee		       4c cf 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1523  08f1							;
   1524  08f1							; Deletion is done.
   1525  08f1							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1526  08f1							;
   1527  08f1				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1528  08f1		       ad 29 0f 	      lda	TOKENBUFFER	; Get the length
   1529  08f4		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1530  08f6							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1531  08f6		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1532  08f8							;
   1533  08f8							; CURPTR points to where the line will be inserted.
   1534  08f8							;
   1535  08f8							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1536  08f8		       ae 29 0f 	      ldx	TOKENBUFFER
   1537  08fb		       8e 19 31 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1538  08fe							;
   1539  08fe		       ad 1e 31 	      lda	ProgramEnd	;Load the start address for the copy
   1540  0901							;At this point curptr still contains the location we will insert data
   1541  0901		       85 5c		      sta	FROM
   1542  0903		       ad 1f 31 	      lda	ProgramEnd+1
   1543  0906		       85 5d		      sta	FROM+1
   1544  0908							;
   1545  0908		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1546  090a		       b1 5c		      lda	(FROM),y
   1547  090c		       ac 19 31 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1548  090f		       91 5c		      sta	(FROM),y	;Save the new byte
   1549  0911							;
   1550  0911		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1551  0913		       c5 4f		      cmp	CURPTR
   1552  0915		       d0 06		      bne	mvUpMore
   1553  0917		       a5 5d		      lda	FROM+1
   1554  0919		       c5 50		      cmp	CURPTR+1
   1555  091b		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1556  091d							;
   1557  091d							; Not done yet
   1558  091d							;
   1559  091d		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1560  091f		       d0 02		      bne	mvUpMore2
   1561  0921		       c6 5d		      dec	FROM+1
   1562  0923		       c6 5c	   mvUpMore2  dec	FROM
   1563  0925		       4c 08 09 	      jmp	mvup1	;Loop until everything is moved
   1564  0928							;
   1565  0928							; All done with copy.
   1566  0928							;
   1567  0928				   mvUpDone
   1568  0928		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1569  0929		       ad 19 31 	      lda	lineLength	;Number of bytes to copy from line buff
   1570  092c		       6d 1e 31 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1571  092f		       8d 1e 31 	      sta	ProgramEnd
   1572  0932		       ad 1f 31 	      lda	ProgramEnd+1
   1573  0935		       69 00		      adc	#0
   1574  0937		       8d 1f 31 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1575  093a							;
   1576  093a							;===================jlit use length before line newline
   1577  093a
   1578  093a		       a0 00		      ldy	#0	;Set offset of copy
   1579  093c							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1580  093c							;		  sta	  (CURPTR),y	  ;Store the length
   1581  093c							;		  iny
   1582  093c							;		  lda	  R0		  ;Store the line number next
   1583  093c							;		  sta	  (CURPTR),y
   1584  093c							;		  iny
   1585  093c							;		  lda	  R0+1
   1586  093c							;		  sta	  (CURPTR),y
   1587  093c							;		  iny
   1588  093c							;
   1589  093c							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1590  093c		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1591  093e				   mvUpLoop2
   1592  093e							;		  lda	  LINBUF,x	 ;get a byte
   1593  093e		       bd 29 0f 	      lda	TOKENBUFFER,x	;get a byte
   1594  0941		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1595  0943
   1596  0943		       e8		      inx
   1597  0944		       ec 29 0f 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1598  0947		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1599  0949		       c8		      iny
   1600  094a		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1601  094c							;
   1602  094c		       4c c3 02    mvUpFini   jmp	NextIL
   1603  094f							;
   1604  094f							;=====================================================
   1605  094f							; Pops the top value of the ILPC stack and stores it
   1606  094f							; in ILPC.  Ie, return from an IL subroutine.
   1607  094f							;
   1608  094f		       20 22 1c    iRTN       jsr	popILPC
   1609  0952		       4c c3 02 	      jmp	NextIL
   1610  0955							;
   1611  0955							;=====================================================
   1612  0955							; NLINE print a newline
   1613  0955							;
   1614  0955		       20 33 1f    iNLINE     jsr	CRLF	;user supplied sub
   1615  0958		       4c c3 02 	      jmp	NextIL
   1616  095b							;
   1617  095b							;=====================================================
   1618  095b							; This saves the current ILPC value on the stack, then
   1619  095b							; jumps to the address specified by the next two bytes.
   1620  095b							;
   1621  095b		       20 05 1c    iCALL      jsr	pushILPC	;save ILPC
   1622  095e		       90 03		      bcc	iJMP
   1623  0960		       4c 15 0c 	      jmp	ErrStkOver	; Check if there was an error
   1624  0963							;
   1625  0963							; Jmp to a specific location in the IL code.  The new
   1626  0963							; address immediately follows the opcode.
   1627  0963							;
   1628  0963		       20 eb 1b    iJMP       jsr	getILWord
   1629  0966		       86 43		      stx	ILPC
   1630  0968		       85 44		      sta	ILPC+1
   1631  096a		       4c c3 02 	      jmp	NextIL
   1632  096d
   1633  096d
   1634  096d							;
   1635  096d							;=====================================================
   1636  096d							; Push the next two bytes onto the arithmetic stack.
   1637  096d							;
   1638  096d		       20 ef 1b    iSetR2     jsr	getILByte
   1639  0970		       85 58		      sta	R2
   1640  0972		       4c c3 02 	      jmp	NextIL
   1641  0975							;
   1642  0975							;=====================================================
   1643  0975							; Push the next two bytes onto the arithmetic stack.
   1644  0975							;
   1645  0975		       20 eb 1b    iLIT       jsr	getILWord
   1646  0978		       86 52		      stx	R0
   1647  097a		       85 53		      sta	R0+1
   1648  097c		       20 e8 1d 	      jsr	pushR0
   1649  097f		       4c c3 02 	      jmp	NextIL
   1650  0982							;
   1651  0982							;=====================================================
   1652  0982							; Initialize all variables for a single task.	Ie, set to zero.
   1653  0982							;
   1654  0982		       98	   subVINIT   tya
   1655  0983		       48		      pha
   1656  0984
   1657  0984		       a9 00		      lda	#0
   1658  0986		       a0 00		      ldy	#0
   1659  0988		       91 41	   Vinit2     sta	(VARIABLES),y
   1660  098a		       c8		      iny
   1661  098b		       c0 34		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1662  098d		       90 f9		      bcc	Vinit2
   1663  098f
   1664  098f		       68		      pla
   1665  0990		       a8		      tay
   1666  0991		       60		      rts
   1667  0992
   1668  0992		       20 bc 12    iVINIT     jsr	Compile	; compile line numbers to memory pointers
   1669  0995		       20 82 09 	      jsr	subVINIT
   1670  0998		       4c c3 02 	      jmp	NextIL
   1671  099b							;
   1672  099b							;=====================================================
   1673  099b							; Set the address of the error handler.  After any
   1674  099b							; error, set to the ILPC to the specified location.
   1675  099b							;
   1676  099b		       20 eb 1b    iERRGOTO   jsr	getILWord
   1677  099e		       8e 09 31 	      stx	errGoto
   1678  09a1		       8d 0a 31 	      sta	errGoto+1
   1679  09a4		       4c c3 02 	      jmp	NextIL
   1680  09a7							;
   1681  09a7							;=====================================================
   1682  09a7							; TST is followed by an 8 bit signed offset, then a
   1683  09a7							; null terminated string.  Compare the string against
   1684  09a7							; the string starting at (CURPTR),CUROFF.  If the
   1685  09a7							; strings match, continue executing the next IL
   1686  09a7							; opcode.  Else, add the offset to ILPC.
   1687  09a7							;
   1688  09a7		       20 ef 1b    iTST       jsr	getILByte	;Get the relative jump address
   1689  09aa		       8d 18 31 	      sta	offset	;save it to use if test faile
   1690  09ad		       20 d2 1d 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1691  09b0
   1692  09b0		       a4 51		      ldy	CUROFF
   1693  09b2		       84 59		      sty	dpl	;save for later
   1694  09b4							;
   1695  09b4		       20 ef 1b    iTSTloop   jsr	getILByte	;get next char
   1696  09b7		       f0 11		      beq	iTSTm	;match!
   1697  09b9		       a4 59		      ldy	dpl
   1698  09bb		       d1 4f		      cmp	(CURPTR),y
   1699  09bd		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1700  09bf		       09 20		      ora	#$20	; lets allow lowercase as well
   1701  09c1		       d1 4f		      cmp	(CURPTR),y
   1702  09c3		       d0 23		      bne	iTSTfail	;mismatch
   1703  09c5		       c8	   iTSTUpper  iny
   1704  09c6		       84 59		      sty	dpl
   1705  09c8		       d0 ea		      bne	iTSTloop
   1706  09ca							;
   1707  09ca							; It's a match!  Clean up a bit.
   1708  09ca							;
   1709  09ca		       a4 59	   iTSTm      ldy	dpl
   1710  09cc		       84 51		      sty	CUROFF
   1711  09ce		       4c c3 02 	      jmp	NextIL
   1712  09d1
   1713  09d1							; Test for a single quote string
   1714  09d1		       20 ef 1b    iTSTStr    jsr	getILByte
   1715  09d4		       8d 18 31 	      sta	offset
   1716  09d7		       20 d2 1d 	      jsr	saveIL
   1717  09da		       a4 51		      ldy	CUROFF
   1718  09dc		       a9 22		      lda	#'"
   1719  09de		       d1 4f		      cmp	(CURPTR),y
   1720  09e0		       d0 06		      bne	iTSTfail
   1721  09e2		       c8		      iny
   1722  09e3		       84 51		      sty	CUROFF
   1723  09e5		       4c e6 02 	      jmp	NextILStr
   1724  09e8							;
   1725  09e8							; Not a match, reset ILPC and then move to the
   1726  09e8							; offset.
   1727  09e8							;
   1728  09e8		       20 dd 1d    iTSTfail   jsr	restoreIL
   1729  09eb		       4c c3 0b 	      jmp	tstBranch
   1730  09ee							;
   1731  09ee							;=================================================JLIT=
   1732  09ee							; Test if we have a let statement without the let keyword
   1733  09ee		       20 ef 1b    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1734  09f1		       8d 18 31 	      sta	offset	; Save the jump offset for fails
   1735  09f4		       20 d2 1d 	      jsr	saveIL	; save to restore when done if fail
   1736  09f7
   1737  09f7		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1738  09f9		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1739  09fb		       c9 01		      cmp	#kLet	; Is it a let keyword
   1740  09fd		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1741  09ff		       c9 80		      cmp	#tVa	; lets check for a variable
   1742  0a01		       90 e5		      bcc	iTSTfail	; Less than variable range
   1743  0a03		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1744  0a05		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1745  0a07		       b0 df		      bcs	iTSTfail	; return it failed
   1746  0a09
   1747  0a09				   iTSTLETGOOD
   1748  0a09		       c8		      iny
   1749  0a0a		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1750  0a0c				   iTSTGOODVAR
   1751  0a0c		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1752  0a0f
   1753  0a0f							;=================================================JLIT=
   1754  0a0f							; Test a byte at an indirect address
   1755  0a0f							; fails if byte is not equal to the value at the address
   1756  0a0f							; The tests an indirect byte and branches if true
   1757  0a0f		       20 ef 1b    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1758  0a12		       8d 18 31 	      sta	offset	; Save the jump offset for fails
   1759  0a15		       20 d2 1d 	      jsr	saveIL	; save to restore when done if fail
   1760  0a18		       20 eb 1b 	      jsr	getILWord	; Get a word into RO
   1761  0a1b		       86 52		      stx	R0
   1762  0a1d		       85 53		      sta	R0+1
   1763  0a1f		       20 ef 1b 	      jsr	getILByte	; Get byte into A
   1764  0a22		       a0 00		      ldy	#0
   1765  0a24		       d1 52		      cmp	(R0),y
   1766  0a26		       d0 03		      bne	iTSTByteNotEqual
   1767  0a28		       4c e8 09 	      jmp	iTSTfail
   1768  0a2b
   1769  0a2b				   iTSTByteNotEqual
   1770  0a2b		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1771  0a2e
   1772  0a2e							;=================================================JLIT=
   1773  0a2e							; Test a byte	branch if it fails
   1774  0a2e		       20 ef 1b    iTSTB      jsr	getILByte	; Get the relative offset byte
   1775  0a31		       8d 18 31 	      sta	offset	; Save the jump offset for fails
   1776  0a34		       20 d2 1d 	      jsr	saveIL	; save to restore when done if fail
   1777  0a37		       20 ef 1b 	      jsr	getILByte	; Get a byte into Acc
   1778  0a3a		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1779  0a3c		       d1 4f		      cmp	(CURPTR),y
   1780  0a3e		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1781  0a40		       4c e8 09 	      jmp	iTSTfail	; REcover and move on to next test
   1782  0a43
   1783  0a43				   iTSTBMatch
   1784  0a43		       c8		      iny
   1785  0a44		       84 51		      sty	CUROFF	; Point to the next byte
   1786  0a46		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1787  0a49
   1788  0a49							;=================================================JLIT=
   1789  0a49							; Test a byte	branch if it fails
   1790  0a49		       20 ef 1b    iTSTW      jsr	getILByte	; Get the relative offset byte
   1791  0a4c		       8d 18 31 	      sta	offset	; Save the jump offset for fails
   1792  0a4f		       20 d2 1d 	      jsr	saveIL	; save to restore when done if fail
   1793  0a52		       20 eb 1b 	      jsr	getILWord	; Get a word into RO
   1794  0a55		       86 52		      stx	R0
   1795  0a57		       85 53		      sta	R0+1
   1796  0a59		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1797  0a5b		       8a		      txa
   1798  0a5c		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1799  0a5e		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1800  0a60		       4c e8 09 	      jmp	iTSTfail	; REcover and move on to next test
   1801  0a63		       c8	   iTSTWM1    iny
   1802  0a64		       a5 53		      lda	R0+1
   1803  0a66		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1804  0a68		       f0 03		      beq	iTSTWMatch
   1805  0a6a		       4c e8 09 	      jmp	iTSTfail
   1806  0a6d
   1807  0a6d				   iTSTWMatch
   1808  0a6d		       c8		      iny
   1809  0a6e		       84 51		      sty	CUROFF
   1810  0a70		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1811  0a73
   1812  0a73							;================================================jLIT=
   1813  0a73							;Test for end of line
   1814  0a73							;
   1815  0a73				   iTSTDONE
   1816  0a73		       20 ef 1b 	      jsr	getILByte
   1817  0a76		       8d 18 31 	      sta	offset
   1818  0a79		       20 d2 1d 	      jsr	saveIL
   1819  0a7c		       a4 51		      ldy	CUROFF
   1820  0a7e		       84 59		      sty	dpl
   1821  0a80		       b1 4f		      lda	(CURPTR),y
   1822  0a82		       f0 0b		      beq	iTSTDONEtrue
   1823  0a84		       c9 e6		      cmp	#oColon
   1824  0a86		       f0 07		      beq	iTSTDONEtrue
   1825  0a88		       a4 59		      ldy	dpl
   1826  0a8a		       84 51		      sty	CUROFF
   1827  0a8c		       4c e8 09 	      jmp	iTSTfail
   1828  0a8f							;
   1829  0a8f							; Advance to the next line
   1830  0a8f							;
   1831  0a8f				   iTSTDONEtrue
   1832  0a8f		       4c c3 02 	      jmp	NextIL
   1833  0a92
   1834  0a92		       4c c3 0b    tstBranchLink jmp	tstBranch
   1835  0a95							;
   1836  0a95							;=====================================================
   1837  0a95							; Inc and dec a variable , faster than a = a + 1
   1838  0a95				   iINCVAR
   1839  0a95		       20 7a 1e 	      jsr	popR0
   1840  0a98		       a0 00		      ldy	#0
   1841  0a9a		       18		      clc
   1842  0a9b		       a9 01		      lda	#1
   1843  0a9d		       71 52		      adc	(R0),y
   1844  0a9f		       91 52		      sta	(R0),y
   1845  0aa1		       90 07		      bcc	iINCDONE
   1846  0aa3		       c8		      iny
   1847  0aa4		       a9 00		      lda	#0
   1848  0aa6		       71 52		      adc	(R0),y
   1849  0aa8		       91 52		      sta	(R0),y
   1850  0aaa				   iINCDONE
   1851  0aaa		       4c c3 02 	      jmp	NextIL
   1852  0aad
   1853  0aad				   iDECVAR
   1854  0aad		       20 7a 1e 	      jsr	popR0
   1855  0ab0		       a0 00		      ldy	#0
   1856  0ab2		       38		      sec
   1857  0ab3		       b1 52		      lda	(R0),y
   1858  0ab5		       e9 01		      sbc	#1
   1859  0ab7		       91 52		      sta	(R0),y
   1860  0ab9		       c8		      iny
   1861  0aba		       b1 52		      lda	(R0),y
   1862  0abc		       e9 00		      sbc	#0
   1863  0abe		       91 52		      sta	(R0),y
   1864  0ac0		       4c c3 02 	      jmp	NextIL
   1865  0ac3
   1866  0ac3
   1867  0ac3							;
   1868  0ac3							;=====================================================
   1869  0ac3							; TSTV is followed by an 8 bit signed offset.	If the
   1870  0ac3							; value at (CURPTR),CUROFF appears to be a variable
   1871  0ac3							; name, move to the next IL statement.  Else, add the
   1872  0ac3							; offset to ILPC. Converted to use actual absolute memory addresses
   1873  0ac3							; TSTVT Looks for the task context
   1874  0ac3							;
   1875  0ac3		       20 92 1e    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1876  0ac6		       a9 00		      lda	#0
   1877  0ac8		       85 58		      sta	R2
   1878  0aca		       f0 04		      beq	iTSTVV
   1879  0acc
   1880  0acc							; Test for simple variable
   1881  0acc		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1882  0ace		       85 58		      sta	R2
   1883  0ad0
   1884  0ad0		       20 ef 1b    iTSTVV     jsr	getILByte	;offset
   1885  0ad3		       8d 18 31 	      sta	offset
   1886  0ad6							;
   1887  0ad6		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1888  0ad8		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1889  0ada		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1890  0adc		       4c 92 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1891  0adf							;
   1892  0adf				   iTSTVnext
   1893  0adf		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1894  0ae1		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1895  0ae3
   1896  0ae3		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1897  0ae5		       f0 5b		      beq	iTSTVParm
   1898  0ae7
   1899  0ae7		       c9 9b		      cmp	#tVhat	; task exit code
   1900  0ae9		       d0 04		      bne	iTSTV_A2Z
   1901  0aeb		       a9 34		      lda	#TASKEXITCODE
   1902  0aed		       d0 0b		      bne	iTSTVContinue
   1903  0aef
   1904  0aef				   iTSTV_A2Z
   1905  0aef
   1906  0aef		       c9 80		      cmp	#tVa
   1907  0af1		       90 9f		      bcc	tstBranchLink
   1908  0af3		       c9 9a		      cmp	#tVz+1
   1909  0af5		       b0 9b		      bcs	tstBranchLink
   1910  0af7
   1911  0af7
   1912  0af7							;
   1913  0af7							; The condition is true, so convert to an index, push
   1914  0af7							; it onto the stack and continue running.
   1915  0af7							;
   1916  0af7		       29 7f		      and	#%01111111	; Mask off the high bit
   1917  0af9		       0a		      asl		; multiply by two
   1918  0afa
   1919  0afa				   iTSTVContinue
   1920  0afa		       c8		      iny
   1921  0afb		       84 51		      sty	CUROFF	; it is a valid variable
   1922  0afd		       48		      pha		; save the last variable pointer value
   1923  0afe		       a5 58		      lda	R2
   1924  0b00		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1925  0b02
   1926  0b02		       20 c4 1b 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1927  0b05		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1928  0b07
   1929  0b07		       68		      pla		; We have an invalid pid for getting variable value
   1930  0b08		       a2 10		      ldx	#ERR_INVALID_PID
   1931  0b0a		       a9 00		      lda	#0
   1932  0b0c		       4c b0 06 	      jmp	iErr2
   1933  0b0f
   1934  0b0f				   iTSTVGOODPID
   1935  0b0f		       20 ac 1b 	      jsr	ipc_getcontext	; Get the other tasks variables
   1936  0b12		       a0 01		      ldy	#VARIABLEPOS
   1937  0b14		       b1 56		      lda	(MQ),y
   1938  0b16		       85 52		      sta	R0
   1939  0b18		       c8		      iny
   1940  0b19		       b1 56		      lda	(MQ),y
   1941  0b1b		       85 53		      sta	R0+1
   1942  0b1d		       4c 28 0b 	      jmp	iTSTVAddOffset
   1943  0b20
   1944  0b20				   iTSTVLocalValue
   1945  0b20		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1946  0b22		       85 52		      sta	R0
   1947  0b24		       a5 42		      lda	VARIABLES+1
   1948  0b26		       85 53		      sta	R0+1
   1949  0b28
   1950  0b28				   iTSTVAddOffset
   1951  0b28		       68		      pla
   1952  0b29		       85 54		      sta	R1
   1953  0b2b		       a9 00		      lda	#0
   1954  0b2d		       85 55		      sta	R1+1
   1955  0b2f
   1956  0b2f				   iTSTVcontinue
   1957  0b2f
   1958  0b2f		       4c d1 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1959  0b32
   1960  0b32							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1961  0b32							; an array of integer values or byte.
   1962  0b32				   iTSTVat
   1963  0b32		       c8		      iny
   1964  0b33		       84 51		      sty	CUROFF	;it is a valid variable
   1965  0b35		       ad 1e 31 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1966  0b38		       85 52		      sta	R0
   1967  0b3a		       ad 1f 31 	      lda	ProgramEnd+1
   1968  0b3d		       85 53		      sta	R0+1
   1969  0b3f		       4c 49 07 	      jmp	pushR0nextIl	;place this onto the stack
   1970  0b42
   1971  0b42							; When we get parameters passed we can access them using the # variable with[]
   1972  0b42							; example #[0] #[1] etc, we dont check yet if there is too many
   1973  0b42				   iTSTVParm
   1974  0b42		       c8		      iny
   1975  0b43		       84 51		      sty	CUROFF	;it is a valid variable
   1976  0b45		       a5 48		      lda	MATHSTACK
   1977  0b47		       85 52		      sta	R0
   1978  0b49		       a5 49		      lda	MATHSTACK+1
   1979  0b4b		       85 53		      sta	R0+1
   1980  0b4d		       4c 49 07 	      jmp	pushR0nextIl
   1981  0b50
   1982  0b50							;
   1983  0b50							;=====================================================
   1984  0b50							; TSTL seems basically the same as TSTN, but leave the
   1985  0b50							; value in R0 instead of pushing onto stack.
   1986  0b50							; This tests for a valid line number
   1987  0b50							;
   1988  0b50		       20 ef 1b    iTSTL      jsr	getILByte
   1989  0b53		       8d 18 31 	      sta	offset
   1990  0b56							;
   1991  0b56		       a4 51		      ldy	CUROFF
   1992  0b58		       b1 4f		      lda	(CURPTR),y
   1993  0b5a		       c8		      iny
   1994  0b5b		       11 4f		      ora	(CURPTR),y
   1995  0b5d		       f0 06		      beq	iTSTLNotLineNo
   1996  0b5f
   1997  0b5f
   1998  0b5f							; In Both cases we need to point to the first usefull byte to process.
   1999  0b5f		       c8		      iny
   2000  0b60		       84 51		      sty	CUROFF
   2001  0b62		       4c c3 02 	      jmp	NextIL
   2002  0b65				   iTSTLNotLineNo
   2003  0b65		       c8		      iny
   2004  0b66		       84 51		      sty	CUROFF
   2005  0b68		       4c c3 0b 	      jmp	tstBranch
   2006  0b6b
   2007  0b6b							;
   2008  0b6b							;=====================================================
   2009  0b6b							; TSTN checks for a number.  This is very simplistic;
   2010  0b6b							; if the character is a digit, assume it's a number.
   2011  0b6b							; Convert to a number and push it onto the stack.
   2012  0b6b							;
   2013  0b6b		       20 ef 1b    iTSTN      jsr	getILByte
   2014  0b6e		       8d 18 31 	      sta	offset
   2015  0b71							;
   2016  0b71		       a9 00		      lda	#0
   2017  0b73		       85 59		      sta	dpl
   2018  0b75		       a4 51		      ldy	CUROFF
   2019  0b77				   chkType
   2020  0b77		       b1 4f		      lda	(CURPTR),y
   2021  0b79		       c9 a2		      cmp	#tByte
   2022  0b7b		       f0 0e		      beq	chkByte
   2023  0b7d		       c9 a1		      cmp	#tInteger
   2024  0b7f		       f0 16		      beq	chkInteger
   2025  0b81		       c9 eb		      cmp	#oMinus
   2026  0b83		       d0 3e		      bne	tstBranch
   2027  0b85		       e6 59		      inc	dpl
   2028  0b87		       c8		      iny
   2029  0b88		       4c 77 0b 	      jmp	chkType
   2030  0b8b
   2031  0b8b				   chkByte
   2032  0b8b		       a9 00		      lda	#0
   2033  0b8d		       85 53		      sta	R0+1
   2034  0b8f		       c8		      iny
   2035  0b90		       b1 4f		      lda	(CURPTR),y
   2036  0b92		       85 52		      sta	R0
   2037  0b94		       c8		      iny
   2038  0b95		       d0 0b		      bne	iTSTN_1
   2039  0b97
   2040  0b97				   chkInteger
   2041  0b97		       c8		      iny
   2042  0b98		       b1 4f		      lda	(CURPTR),y
   2043  0b9a		       85 52		      sta	R0
   2044  0b9c		       c8		      iny
   2045  0b9d		       b1 4f		      lda	(CURPTR),y
   2046  0b9f		       85 53		      sta	R0+1
   2047  0ba1		       c8		      iny
   2048  0ba2							;
   2049  0ba2							; Check if it is negative and make it so
   2050  0ba2							;
   2051  0ba2				   iTSTN_1
   2052  0ba2		       84 51		      sty	CUROFF
   2053  0ba4
   2054  0ba4		       a5 59		      lda	dpl
   2055  0ba6		       f0 18		      beq	iTSTN_2	;positive
   2056  0ba8							;
   2057  0ba8		       a5 52		      lda	R0
   2058  0baa		       05 53		      ora	R0+1
   2059  0bac		       f0 12		      beq	iTSTN_2	;zero
   2060  0bae
   2061  0bae							; Invert all the bits, then add one.
   2062  0bae							;
   2063  0bae		       a5 52		      lda	R0
   2064  0bb0		       49 ff		      eor	#$ff
   2065  0bb2		       85 52		      sta	R0
   2066  0bb4		       a5 53		      lda	R0+1
   2067  0bb6		       49 ff		      eor	#$ff
   2068  0bb8		       85 53		      sta	R0+1
   2069  0bba							;
   2070  0bba		       e6 52		      inc	R0
   2071  0bbc		       d0 02		      bne	iTSTN_2
   2072  0bbe		       e6 53		      inc	R0+1
   2073  0bc0				   iTSTN_2
   2074  0bc0		       4c 49 07 	      jmp	pushR0nextIl	;save onto stack
   2075  0bc3
   2076  0bc3							;
   2077  0bc3							; Common jump point for all TSTx instructions that
   2078  0bc3							; fail to meet the requirements.  This takes the
   2079  0bc3							; offset and adds/subtracts to/from ILPC.
   2080  0bc3							;
   2081  0bc3		       ad 18 31    tstBranch  lda	offset	;get signed offset
   2082  0bc6		       10 0e		      bpl	tstPositive
   2083  0bc8							;
   2084  0bc8							; Do negative branch.	Do sign extension.
   2085  0bc8							;
   2086  0bc8		       18	   tstNegative clc
   2087  0bc9		       65 43		      adc	ILPC
   2088  0bcb		       85 43		      sta	ILPC
   2089  0bcd							;		  bcc	  tstBothDone
   2090  0bcd							;		  dec	  ILPC+1
   2091  0bcd							;		  jmp	  NextIL
   2092  0bcd
   2093  0bcd		       a5 44		      lda	ILPC+1
   2094  0bcf		       69 ff		      adc	#$ff
   2095  0bd1		       85 44		      sta	ILPC+1
   2096  0bd3		       4c c3 02 	      jmp	NextIL	;keep going
   2097  0bd6							;
   2098  0bd6		       18	   tstPositive clc
   2099  0bd7		       65 43		      adc	ILPC
   2100  0bd9		       85 43		      sta	ILPC
   2101  0bdb		       90 02		      bcc	tstBothDone
   2102  0bdd		       e6 44		      inc	ILPC+1
   2103  0bdf				   tstBothDone
   2104  0bdf		       4c c3 02 	      jmp	NextIL
   2105  0be2
   2106  0be2							;
   2107  0be2							;====================================================
   2108  0be2							; Test for IRQ pending, and test if a break key pressed
   2109  0be2							; Yes I know but this handles all sorts of irq/break issues
   2110  0be2							;
   2111  0be2		       20 ef 1b    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2112  0be5		       8d 18 31 	      sta	offset	; Store the not true jump address offset
   2113  0be8		       20 54 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2114  0beb		       d0 03		      bne	irqNo	; z not set of no break found
   2115  0bed		       4c 3d 06 	      jmp	iFIN	; Exit out of run mode
   2116  0bf0		       ad c0 27    irqNo      lda	IRQPending
   2117  0bf3		       f0 ce		      beq	tstBranch
   2118  0bf5		       c9 01		      cmp	#1	; only do this if set to first time
   2119  0bf7		       d0 ca		      bne	tstBranch
   2120  0bf9		       78		      sei		; disable the interupt until ireturn resets it
   2121  0bfa		       ee c0 27    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2122  0bfd		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2123  0bff		       20 02 1e 	      jsr	pushLN	; Push the next line to be executed
   2124  0c02		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2125  0c04		       ad c1 27 	      lda	IRQEntry	; Get the line number to branch to
   2126  0c07		       85 4f		      sta	CURPTR	; put line number into r0
   2127  0c09		       ad c2 27 	      lda	IRQEntry+1
   2128  0c0c		       85 50		      sta	CURPTR+1
   2129  0c0e		       a9 03		      lda	#3	; Point to first byte of program text
   2130  0c10		       85 51		      sta	CUROFF
   2131  0c12		       4c c3 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2132  0c15
   2133  0c15		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2134  0c17		       a9 00		      lda	#0	; stop the execution
   2135  0c19		       4c b0 06 	      jmp	iErr2
   2136  0c1c							;
   2137  0c1c
   2138  0c1c							;=====================================================
   2139  0c1c							; This places the number of free bytes on top of the
   2140  0c1c							; stack.
   2141  0c1c							;
   2142  0c1c		       20 9b 16    iFREE      jsr	MemFree
   2143  0c1f		       20 e8 1d 	      jsr	pushR0
   2144  0c22		       4c c3 02 	      jmp	NextIL
   2145  0c25							;
   2146  0c25							;=====================================================
   2147  0c25							; Generate a random number from 0-FFFF and then MOD
   2148  0c25							; it with the value on top of stack.  Leaves number on
   2149  0c25							; stack
   2150  0c25							;
   2151  0c25		       20 92 1e    iRANDOM    jsr	popR1	;mod value
   2152  0c28							;
   2153  0c28							; If the value is zero, just return a one.
   2154  0c28							;
   2155  0c28		       a5 54		      lda	R1
   2156  0c2a		       05 55		      ora	R1+1
   2157  0c2c		       f0 4a		      beq	irandom1
   2158  0c2e							;
   2159  0c2e		       ad 0f 31 	      lda	random+1
   2160  0c31		       8d 0c 31 	      sta	rtemp1
   2161  0c34		       ad 0e 31 	      lda	random
   2162  0c37		       0a		      asl
   2163  0c38		       2e 0c 31 	      rol	rtemp1
   2164  0c3b		       0a		      asl
   2165  0c3c		       2e 0c 31 	      rol	rtemp1
   2166  0c3f		       18		      clc
   2167  0c40		       6d 0e 31 	      adc	random
   2168  0c43
   2169  0c43		       48		      pha
   2170  0c44
   2171  0c44		       ad 0c 31 	      lda	rtemp1
   2172  0c47		       6d 0f 31 	      adc	random+1
   2173  0c4a		       8d 0f 31 	      sta	random+1
   2174  0c4d
   2175  0c4d		       68		      pla
   2176  0c4e
   2177  0c4e		       69 11		      adc	#$11
   2178  0c50		       8d 0e 31 	      sta	random
   2179  0c53		       ad 0f 31 	      lda	random+1
   2180  0c56		       69 36		      adc	#$36
   2181  0c58		       8d 0f 31 	      sta	random+1
   2182  0c5b
   2183  0c5b		       ad 0e 31 	      lda	random
   2184  0c5e		       85 52		      sta	R0
   2185  0c60		       ad 0f 31 	      lda	random+1
   2186  0c63		       29 7f		      and	#$7f	;make positive
   2187  0c65		       85 53		      sta	R0+1
   2188  0c67							;
   2189  0c67							; R0 contains the number and R1 contains the max value.
   2190  0c67							;
   2191  0c67		       20 6f 07 	      jsr	iDivNoPop
   2192  0c6a		       20 fb 1e 	      jsr	RestoreSigns
   2193  0c6d		       a5 56		      lda	MQ
   2194  0c6f		       85 52		      sta	R0
   2195  0c71		       a5 57		      lda	MQ+1
   2196  0c73		       85 53		      sta	R0+1
   2197  0c75		       4c 49 07 	      jmp	pushR0nextIl
   2198  0c78				   irandom1
   2199  0c78		       a9 00		      lda	#0
   2200  0c7a		       85 53		      sta	R0+1
   2201  0c7c		       a9 01		      lda	#1
   2202  0c7e		       85 52		      sta	R0
   2203  0c80		       4c 49 07 	      jmp	pushR0nextIl
   2204  0c83
   2205  0c83							; The following replaced by call to division/modulo
   2206  0c83							;iRANDOM_2	lda	R0
   2207  0c83							;		cmp	R1
   2208  0c83							;		bne	iRANDOM_1
   2209  0c83							;		lda	R0+1
   2210  0c83							;		cmp	R1+1
   2211  0c83							;		bne	iRANDOM_1	;need to subtract
   2212  0c83							;
   2213  0c83							; Subtract R1 from R0
   2214  0c83							;
   2215  0c83							;iRANDOM_sub	sec
   2216  0c83							;		lda	R0
   2217  0c83							;		sbc	R1
   2218  0c83							;		sta	R0
   2219  0c83							;		lda	R0+1
   2220  0c83							;		sbc	R1+1
   2221  0c83							;		sta	R0+1
   2222  0c83							;		jmp	iRANDOM_2
   2223  0c83							;
   2224  0c83							; See if R1 > R0.  If so, branch to subtract.
   2225  0c83							;
   2226  0c83							;iRANDOM_1	lda	R0
   2227  0c83							;		cmp	R1
   2228  0c83							;		lda	R0+1
   2229  0c83							;		sbc	R1+1
   2230  0c83							;		bvc	iRANDOM_4
   2231  0c83							;		eor	#$80
   2232  0c83							;iRANDOM_4	bpl	iRANDOM_sub
   2233  0c83							;
   2234  0c83							; All done.  Almost.  Add one, then push the result.
   2235  0c83							;
   2236  0c83							;irandom1	inc	R0
   2237  0c83							;		bne	iRANDOM_3
   2238  0c83							;		inc	R0+1
   2239  0c83							;iRANDOM_3
   2240  0c83							;		  jsr	pushR0	;return value
   2241  0c83							;		jmp	NextIL
   2242  0c83							;
   2243  0c83							; Poke a value into a memory location
   2244  0c83		       8c 14 31    iPOKEMEMORY sty	tempy
   2245  0c86		       20 7a 1e 	      jsr	popR0
   2246  0c89		       20 92 1e 	      jsr	popR1
   2247  0c8c		       a0 00		      ldy	#0
   2248  0c8e		       a5 52		      lda	R0
   2249  0c90		       91 54		      sta	(R1),y
   2250  0c92		       ac 14 31 	      ldy	tempy
   2251  0c95		       4c c3 02 	      jmp	NextIL
   2252  0c98							;
   2253  0c98							; Get a value from a memory location
   2254  0c98							;
   2255  0c98		       8c 14 31    iPEEKMEMORY sty	tempy
   2256  0c9b		       20 7a 1e 	      jsr	popR0
   2257  0c9e		       a0 00		      ldy	#0
   2258  0ca0		       b1 52		      lda	(R0),y
   2259  0ca2		       ac 14 31 	      ldy	tempy
   2260  0ca5		       85 52		      sta	R0
   2261  0ca7		       a9 00		      lda	#0
   2262  0ca9		       85 53		      sta	R0+1
   2263  0cab		       4c 49 07 	      jmp	pushR0nextIl
   2264  0cae							;
   2265  0cae							; Call to address return what ever is in a to the stack
   2266  0cae							; func2 will load a value into a before the call
   2267  0cae		       20 92 1e    iCallFunc  jsr	popR1
   2268  0cb1		       a5 54		      lda	R1
   2269  0cb3		       20 bf 0c 	      jsr	iCallRtn
   2270  0cb6		       85 52		      sta	R0
   2271  0cb8		       a9 00		      lda	#0
   2272  0cba		       85 53		      sta	R0+1
   2273  0cbc		       20 49 07 	      jsr	pushR0nextIl
   2274  0cbf				   iCallRtn
   2275  0cbf		       20 7a 1e 	      jsr	popR0
   2276  0cc2		       6c 52 00 	      jmp	(R0)
   2277  0cc5
   2278  0cc5
   2279  0cc5							;===========================================jlit======
   2280  0cc5							;Get a character from the terminal convert to value
   2281  0cc5							;leave the number on top of the stack
   2282  0cc5							;
   2283  0cc5				   iGETCHAR
   2284  0cc5		       20 84 20 	      jsr	VGETCH
   2285  0cc8					      if	CTMON65
   2286  0cc8		       48		      pha
   2287  0cc9		       20 81 20 	      jsr	VOUTCH	;echo echo echo
   2288  0ccc		       68		      pla
   2289  0ccd					      endif
   2290  0ccd		       85 52		      sta	R0
   2291  0ccf		       a9 00		      lda	#0
   2292  0cd1		       85 53		      sta	R0+1
   2293  0cd3		       20 e8 1d 	      jsr	pushR0
   2294  0cd6							;
   2295  0cd6		       4c c3 02 	      jmp	NextIL
   2296  0cd9							;===========================================jusilostintim======
   2297  0cd9							;Put a character to the terminal convert to
   2298  0cd9							;
   2299  0cd9		       20 7a 1e    iPUTCHAR   jsr	popR0
   2300  0cdc		       a5 52		      lda	R0
   2301  0cde		       20 81 20 	      jsr	VOUTCH
   2302  0ce1		       4c c3 02 	      jmp	NextIL
   2303  0ce4							;=====================================================
   2304  0ce4							; Put the number on the stack out as hex, suppress leading 0
   2305  0ce4				   iHexOut
   2306  0ce4		       20 7a 1e 	      jsr	popR0
   2307  0ce7		       a5 53		      lda	R0+1
   2308  0ce9		       f0 03		      beq	iHexSecondByte
   2309  0ceb		       20 65 14 	      jsr	OUTHEX
   2310  0cee				   iHexSecondByte
   2311  0cee		       a5 52		      lda	R0
   2312  0cf0		       20 65 14 	      jsr	OUTHEX
   2313  0cf3		       4c c3 02 	      jmp	NextIL
   2314  0cf6							;
   2315  0cf6							;=====================================================
   2316  0cf6							; Replace TOS with its absolute value.
   2317  0cf6							;
   2318  0cf6		       20 7a 1e    iABS       jsr	popR0
   2319  0cf9		       a5 53		      lda	R0+1
   2320  0cfb		       10 10		      bpl	iABS_1	;already positive
   2321  0cfd		       49 ff		      eor	#$ff
   2322  0cff		       85 53		      sta	R0+1
   2323  0d01		       a5 52		      lda	R0
   2324  0d03		       49 ff		      eor	#$ff
   2325  0d05		       85 52		      sta	R0
   2326  0d07		       e6 52		      inc	R0
   2327  0d09		       d0 02		      bne	iABS_1
   2328  0d0b		       e6 53		      inc	R0+1
   2329  0d0d		       4c 49 07    iABS_1     jmp	pushR0nextIl
   2330  0d10
   2331  0d10							;
   2332  0d10							;================================================================
   2333  0d10							; The set of logical operators
   2334  0d10				   iLogAnd
   2335  0d10		       20 7a 1e 	      jsr	popR0
   2336  0d13		       20 92 1e 	      jsr	popR1
   2337  0d16		       a5 52		      lda	R0
   2338  0d18		       25 54		      and	R1
   2339  0d1a		       85 52		      sta	R0
   2340  0d1c		       a5 53		      lda	R0+1
   2341  0d1e		       25 55		      and	R1+1
   2342  0d20		       85 53		      sta	R0+1
   2343  0d22		       4c 49 07 	      jmp	pushR0nextIl
   2344  0d25				   iLogOr
   2345  0d25		       20 7a 1e 	      jsr	popR0
   2346  0d28		       20 92 1e 	      jsr	popR1
   2347  0d2b		       a5 52		      lda	R0
   2348  0d2d		       05 54		      ora	R1
   2349  0d2f		       85 52		      sta	R0
   2350  0d31		       a5 53		      lda	R0+1
   2351  0d33		       05 55		      ora	R1+1
   2352  0d35		       85 53		      sta	R0+1
   2353  0d37		       4c 49 07 	      jmp	pushR0nextIl
   2354  0d3a				   iLogXor
   2355  0d3a		       20 7a 1e 	      jsr	popR0
   2356  0d3d		       20 92 1e 	      jsr	popR1
   2357  0d40		       a5 52		      lda	R0
   2358  0d42		       45 54		      eor	R1
   2359  0d44		       85 52		      sta	R0
   2360  0d46		       a5 53		      lda	R0+1
   2361  0d48		       45 55		      eor	R1+1
   2362  0d4a		       85 53		      sta	R0+1
   2363  0d4c		       4c 49 07 	      jmp	pushR0nextIl
   2364  0d4f				   iLogNot
   2365  0d4f		       20 7a 1e 	      jsr	popR0
   2366  0d52		       a5 52		      lda	R0
   2367  0d54		       49 ff		      eor	#$FF
   2368  0d56		       85 52		      sta	R0
   2369  0d58		       a5 53		      lda	R0+1
   2370  0d5a		       49 ff		      eor	#$FF
   2371  0d5c		       85 53		      sta	R0+1
   2372  0d5e		       4c 49 07 	      jmp	pushR0nextIl
   2373  0d61
   2374  0d61				   iTruth
   2375  0d61		       a9 ff		      lda	#$FF
   2376  0d63		       85 52		      sta	R0
   2377  0d65		       85 53		      sta	R0+1
   2378  0d67		       4c 49 07 	      jmp	pushR0nextIl
   2379  0d6a				   iFalse
   2380  0d6a		       a9 00		      lda	#$00
   2381  0d6c		       85 52		      sta	R0
   2382  0d6e		       85 53		      sta	R0+1
   2383  0d70		       4c 49 07 	      jmp	pushR0nextIl
   2384  0d73
   2385  0d73							;================================================================
   2386  0d73							;Set the IRQ service rtn line number
   2387  0d73							;
   2388  0d73		       78	   iSetIrq    sei		; disable the interupts
   2389  0d74		       a9 00		      lda	#0	; Zero the Status flag
   2390  0d76		       8d bf 27 	      sta	IRQStatus
   2391  0d79		       20 7a 1e 	      jsr	popR0	; get the line number
   2392  0d7c		       a5 52		      lda	R0
   2393  0d7e		       05 53		      ora	R0+1
   2394  0d80		       f0 22		      beq	iSetExt	; if it is zero disable all
   2395  0d82		       a9 01		      lda	#GOSUB_RTN	; default push type
   2396  0d84		       20 02 1e 	      jsr	pushLN	; Save the current line pointer
   2397  0d87		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2398  0d89		       4c 15 0c 	      jmp	ErrStkOver	; Check if there was an error
   2399  0d8c				   iSetIrqOk
   2400  0d8c		       20 34 1c 	      jsr	findLine	; Find the IRQ func Line Pointer
   2401  0d8f		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2402  0d91		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2403  0d93		       8d c2 27 	      sta	IRQEntry+1
   2404  0d96		       a5 4f		      lda	CURPTR
   2405  0d98		       8d c1 27 	      sta	IRQEntry
   2406  0d9b		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2407  0d9d		       8d bf 27 	      sta	IRQStatus
   2408  0da0		       20 2b 1e 	      jsr	popLN	; Restore the old line number
   2409  0da3		       58		      cli		; Enable the interupts
   2410  0da4		       4c c3 02    iSetExt    jmp	NextIL
   2411  0da7
   2412  0da7		       20 2b 1e    iSetIrqErr jsr	popLN
   2413  0daa		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2414  0dac		       a9 00		      lda	#0
   2415  0dae		       4c b0 06 	      jmp	iErr2
   2416  0db1							;
   2417  0db1		       20 7a 1e    iTRACEPROG jsr	popR0
   2418  0db4		       a5 52		      lda	R0
   2419  0db6		       85 40		      sta	ILTrace
   2420  0db8		       4c c3 02 	      jmp	NextIL
   2421  0dbb
   2422  0dbb							;=====================================================
   2423  0dbb							; Define start of non page zero data
   2424 U3126 ????				      seg.u	TBData
   2425 U277c					      org	PROGEND
   2426 U277c							;=================================================================
   2427 U277c							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U277c					      include	"tokenizer.asm"
      1  0dbb					      seg	Code
      2  0dbb		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  0dbb
      4  0dbb							; Define the types of tokens found, and identifiers
      5  0dbb		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0dbb		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0dbb		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0dbb		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0dbb
     10  0dbb		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0dbb		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0dbb		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0dbb
     14  0dbb
     15  0dbb		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0dbb		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0dbb		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0dbb		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0dbb							; Arrays of string are arrays of pointers 2 bytes
     20  0dbb		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0dbb		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0dbb		       00 a7	   tUint      equ	$A7	; unsigned integer type
     23  0dbb
     24  0dbb		       3c 3e	   Operators  BYTE.b	"<>"
     25  0dbd		       3c 3d		      BYTE.b	"<="
     26  0dbf		       3e 3d		      BYTE.b	">="
     27  0dc1		       3c 00		      BYTE.b	"<",0
     28  0dc3		       3d 00		      BYTE.b	"=",0
     29  0dc5		       3e 00		      BYTE.b	">",0
     30  0dc7		       2b 00		      BYTE.b	"+",0
     31  0dc9		       2d 00		      BYTE.b	"-",0
     32  0dcb		       2f 00		      BYTE.b	"/",0
     33  0dcd		       25 00		      BYTE.b	"%",0
     34  0dcf		       2a 00		      BYTE.b	"*",0
     35  0dd1		       28 00		      BYTE.b	"(",0
     36  0dd3		       29 00		      BYTE.b	")",0
     37  0dd5		       2c 00		      BYTE.b	",",0
     38  0dd7		       3b 00		      BYTE.b	";",0
     39  0dd9		       5b 00		      BYTE.b	"[",0
     40  0ddb		       5d 00		      BYTE.b	"]",0
     41  0ddd		       3a 00		      BYTE.b	":",0
     42  0ddf		       24 00		      BYTE.b	"$",0
     43  0de1		       21 00		      BYTE.b	"!",0
     44  0de3		       3f 00		      BYTE.b	"?",0
     45  0de5		       2e 00		      BYTE.b	".",0
     46  0de7		       00 00		      BYTE.b	0,0
     47  0de9
     48  0de9		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     49  0def		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     50  0df4		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     51  0dfa		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     52  0dff
     53  0dff		       00 0b	   oQuestion  equ	kPrint
     54  0dff							;    2 is =
     55  0dff							;    1 is <
     56  0dff							;    3 is <=
     57  0dff							;    5 is <>
     58  0dff							;    4 is >
     59  0dff							;    6 is >=
     60  0dff		       00 f1	   oLess      equ	$F1
     61  0dff		       00 f2	   oEqual     equ	$F2
     62  0dff		       00 f3	   oLessEqual equ	$F3
     63  0dff		       00 f4	   oGreater   equ	$F4
     64  0dff		       00 f5	   oNotEqual  equ	$F5
     65  0dff		       00 f6	   oGreaterEqual equ	$F6
     66  0dff
     67  0dff		       00 e0	   oLeftBracket equ	$E0
     68  0dff		       00 e1	   oRightBracket equ	$E1
     69  0dff		       00 e2	   oComma     equ	$E2
     70  0dff		       00 e3	   oSemiColon equ	$E3
     71  0dff		       00 e4	   oLeftSQBracket equ	$E4
     72  0dff		       00 e5	   oRightSQBracket equ	$E5
     73  0dff		       00 e6	   oColon     equ	$E6
     74  0dff		       00 e7	   oDollar    equ	$E7
     75  0dff		       00 e8	   oBang      equ	$E8
     76  0dff		       00 e9	   oPeriod    equ	$E9
     77  0dff
     78  0dff
     79  0dff		       00 ea	   oPlus      equ	$EA
     80  0dff		       00 eb	   oMinus     equ	$EB
     81  0dff		       00 ec	   oDivide    equ	$EC
     82  0dff		       00 ed	   oModulo    equ	$ED
     83  0dff		       00 ee	   oMultiply  equ	$EE
     84  0dff
     85  0dff		       00 ed	   oPercent   equ	oModulo
     86  0dff
     87  0dff		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     88  0dff
     89  0dff		       00 ff	   tError     equ	$FF	; Error should never happen
     90  0dff							;============================================================================================
     91  0dff							; Keyword and seperator values
     92  0dff				   '
     93  0dff		       00 01	   kBeginKey  equ	kLet
     94  0dff							;
     95  0dff		       00 01	   kLet       equ	1
     96  0dff		       00 02	   kInc       equ	kLet+1
     97  0dff		       00 03	   kDec       equ	kInc+1
     98  0dff		       00 04	   kIreturn   equ	kDec+1
     99  0dff		       00 05	   kIf	      equ	kIreturn+1
    100  0dff		       00 06	   kThen      equ	kIf+1
    101  0dff		       00 07	   kGoto      equ	kThen+1
    102  0dff		       00 08	   kGosub     equ	kGoto+1
    103  0dff		       00 09	   kReturn    equ	kGosub+1
    104  0dff		       00 0a	   kRem       equ	kReturn+1
    105  0dff		       00 0b	   kPrint     equ	kRem+1
    106  0dff		       00 0c	   kTaske     equ	kPrint+1
    107  0dff		       00 0d	   kTaskn     equ	kTaske+1
    108  0dff		       00 0e	   kTaskw     equ	kTaskn+1
    109  0dff		       00 0f	   kPoke      equ	kTaskw+1
    110  0dff		       00 10	   kPutch     equ	kPoke+1
    111  0dff		       00 11	   kCls       equ	kPutch+1
    112  0dff		       00 12	   kInput     equ	kCls+1
    113  0dff		       00 13	   kEnd       equ	kInput+1
    114  0dff		       00 14	   kIrq       equ	kEnd+1
    115  0dff		       00 15	   kKill      equ	kIrq+1
    116  0dff		       00 16	   kList      equ	kKill+1
    117  0dff		       00 17	   kRun       equ	kList+1
    118  0dff		       00 18	   kNew       equ	kRun+1
    119  0dff		       00 19	   kSlice     equ	kNew+1
    120  0dff		       00 1a	   kTrace     equ	kSlice+1
    121  0dff		       00 1b	   kExit      equ	kTrace+1
    122  0dff		       00 1c	   kSave      equ	kExit+1
    123  0dff		       00 1d	   kLoad      equ	kSave+1
    124  0dff		       00 1e	   kErase     equ	kLoad+1
    125  0dff		       00 1f	   kDir       equ	kErase+1
    126  0dff		       00 20	   kSetTerm   equ	kDir+1
    127  0dff		       00 21	   kSetMemB   equ	kSetTerm+1
    128  0dff		       00 22	   kSetMemW   equ	kSetMemB+1
    129  0dff		       00 23	   kCopyMem   equ	kSetMemW+1
    130  0dff							;
    131  0dff							; End of actual key words
    132  0dff							;
    133  0dff		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    134  0dff							;
    135  0dff							; Logical operators
    136  0dff							;
    137  0dff		       00 24	   kNot       equ	kCopyMem+1
    138  0dff		       00 25	   kOr	      equ	kNot+1
    139  0dff		       00 26	   kXor       equ	kOr+1
    140  0dff		       00 27	   kAnd       equ	kXor+1
    141  0dff
    142  0dff							; numeric functions
    143  0dff							;
    144  0dff		       00 28	   kBeginFunc equ	kTrue
    145  0dff							;
    146  0dff							; Truth operators
    147  0dff							;
    148  0dff		       00 28	   kTrue      equ	kAnd+1
    149  0dff		       00 29	   kFalse     equ	kTrue+1
    150  0dff							; Functions
    151  0dff		       00 2a	   kFree      equ	kFalse+1
    152  0dff		       00 2b	   kGetch     equ	kFree+1
    153  0dff		       00 2c	   kPeek      equ	kGetch+1
    154  0dff		       00 2d	   kTask      equ	kPeek+1
    155  0dff		       00 2e	   kIpcc      equ	kTask+1
    156  0dff		       00 2f	   kIpcs      equ	kIpcc+1
    157  0dff		       00 30	   kIpcr      equ	kIpcs+1
    158  0dff		       00 31	   kRnd       equ	kIpcr+1
    159  0dff		       00 32	   kStat      equ	kRnd+1
    160  0dff		       00 33	   kAbs       equ	kStat+1
    161  0dff		       00 34	   kCall      equ	kAbs+1
    162  0dff		       00 35	   kGofn      equ	kCall+1
    163  0dff		       00 36	   kPid       equ	kGofn+1
    164  0dff		       00 37	   kAddr      equ	kPid+1
    165  0dff							;
    166  0dff		       00 10	   kFuncCount equ	((kAddr - kBeginFunc) + 1)
    167  0dff
    168  0dff							;
    169  0dff							; Keyword table contains 54 keywords
    170  0dff				   KeyWordTable
      0  0dff					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0dff		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0e03					      db	kInc,"inC"
      1  0e03		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0e07					      db	kDec,"deC"
      1  0e07		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0e0b					      db	kIreturn,"ireturN"
      1  0e0b		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0e13					      db	kIf,"iF"
      1  0e13		       05 69 46 	      .byte.b	kIf,"iF"
      0  0e16					      db	kThen,"theN"
      1  0e16		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0e1b					      db	kGoto,"gotO"
      1  0e1b		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0e20					      db	kGosub,"gosuB"
      1  0e20		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0e26					      db	kReturn,"returN"
      1  0e26		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0e2d					      db	kRem,"reM"
      1  0e2d		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0e31					      db	kPrint,"prinT"
      1  0e31		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0e37					      db	kTaske,"taskE"
      1  0e37		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0e3d					      db	kTaskn,"taskN"
      1  0e3d		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0e43					      db	kTaskw,"taskW"
      1  0e43		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0e49					      db	kPoke,"pokE"
      1  0e49		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0e4e					      db	kPutch,"putcH"
      1  0e4e		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0e54					      db	kCls,"clS"
      1  0e54		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0e58					      db	kInput,"inpuT"
      1  0e58		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0e5e					      db	kEnd,"enD"
      1  0e5e		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0e62					      db	kIrq,"irQ"
      1  0e62		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0e66					      db	kKill,"kilL"
      1  0e66		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0e6b					      db	kList,"lisT"
      1  0e6b		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0e70					      db	kRun,"ruN"
      1  0e70		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0e74					      db	kNew,"neW"
      1  0e74		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0e78					      db	kSlice,"slicE"
      1  0e78		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0e7e					      db	kTrace,"tracE"
      1  0e7e		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0e84					      db	kExit,"exiT"
      1  0e84		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0e89					      db	kSave,"savE"
      1  0e89		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0e8e					      db	kLoad,"loaD"
      1  0e8e		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0e93					      db	kErase,"erasE"
      1  0e93		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0e99					      db	kDir,"diR"
      1  0e99		       1f 64 69 52	      .byte.b	kDir,"diR"
    202  0e9d							;Short form for statements:
      0  0e9d					      db	kIreturn,"ireT"
      1  0e9d		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0ea2					      db	kReturn,"reT"
      1  0ea2		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  0ea6					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  0ea6		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  0ea9					      db	kSetTerm, "setterM"
      1  0ea9		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  0eb1					      db	kSetMemB, "setmemB"
      1  0eb1		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  0eb9					      db	kSetMemW, "setmemW"
      1  0eb9		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  0ec1					      db	kCopyMem, "copymeM"
      1  0ec1		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    210  0ec9
    211  0ec9							;Logical and truth operators
      0  0ec9					      db	kNot,"noT"
      1  0ec9		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  0ecd					      db	kOr,"oR"
      1  0ecd		       25 6f 52 	      .byte.b	kOr,"oR"
      0  0ed0					      db	kXor,"xoR"
      1  0ed0		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  0ed4					      db	kAnd,"anD"
      1  0ed4		       27 61 6e 44	      .byte.b	kAnd,"anD"
    216  0ed8							; Truth values
      0  0ed8					      db	kTrue,"truE"
      1  0ed8		       28 74 72 75*	      .byte.b	kTrue,"truE"
      0  0edd					      db	kFalse,"falsE"
      1  0edd		       29 66 61 6c*	      .byte.b	kFalse,"falsE"
    219  0ee3
    220  0ee3							;functions returning values
    221  0ee3
      0  0ee3					      db	kFree,"freE"
      1  0ee3		       2a 66 72 65*	      .byte.b	kFree,"freE"
      0  0ee8					      db	kGetch,"getcH"
      1  0ee8		       2b 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0eee					      db	kPeek,"peeK"
      1  0eee		       2c 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0ef3					      db	kTask,"tasK"
      1  0ef3		       2d 74 61 73*	      .byte.b	kTask,"tasK"
      0  0ef8					      db	kIpcc,"ipcC"
      1  0ef8		       2e 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0efd					      db	kIpcs,"ipcS"
      1  0efd		       2f 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0f02					      db	kIpcr,"ipcR"
      1  0f02		       30 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0f07					      db	kRnd,"rnD"
      1  0f07		       31 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0f0b					      db	kStat,"staT"
      1  0f0b		       32 73 74 61*	      .byte.b	kStat,"staT"
      0  0f10					      db	kAbs,"abS"
      1  0f10		       33 61 62 53	      .byte.b	kAbs,"abS"
      0  0f14					      db	kCall,"calL"
      1  0f14		       34 63 61 6c*	      .byte.b	kCall,"calL"
      0  0f19					      db	kGofn,"gofN"
      1  0f19		       35 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0f1e					      db	kPid,"piD"
      1  0f1e		       36 70 69 44	      .byte.b	kPid,"piD"
      0  0f22					      db	kAddr,"addR"
      1  0f22		       37 61 64 64*	      .byte.b	kAddr,"addR"
      0  0f27					      db	0,0
      1  0f27		       00 00		      .byte.b	0,0
    237  0f29
    238  0f29		       0f 29	   KeyWordTableEnd equ	*
    239  0f29		       01 2a	   KeyWordTableLength equ	* - KeyWordTable
    240  0f29		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    241  1029		       00 00 00    printStorage ds	3
    242  102c							;==================================================================================================================
    243  102c							; Read accross the inputline and output to TOKENBUFFER
    244  102c							; Format   byte      Description
    245  102c							;	     0	      length of line 1-255
    246  102c							;	    0-1       Line Number
    247  102c							;	    Tokens and litteral values encoded into the line
    248  102c							;
    249  102c							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    250  102c							;  if fails then test for keywords
    251  102c							;  if fails then test for variables and arrays
    252  102c							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    253  102c
    254  102c				   ParseInputLine
    255  102c				  -	      if	DEBUGPARSER
    256  102c				  -	      jsr	SetOutDebug
    257  102c				  -	      jsr	DebugClearBuffer
    258  102c					      endif
    259  102c		       a5 51		      lda	CUROFF
    260  102e		       48		      pha
    261  102f		       8a		      txa
    262  1030		       48		      pha
    263  1031		       98		      tya
    264  1032		       48		      pha
    265  1033		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    266  1035		       20 9a 1c 	      jsr	getDecimal	; Check for a line number, none is ok too
    267  1038		       84 51		      sty	CUROFF
    268  103a		       20 f8 11 	      jsr	R02TOKEN	; Move R0 to token buffer
    269  103d
    270  103d				   ParseInputLoop
    271  103d		       a4 51		      ldy	CUROFF
    272  103f		       20 2a 1f 	      jsr	SkipSpaces	; Skip any spaces
    273  1042		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    274  1044		       b9 7f 30 	      lda	LINBUF,y	; Check for end of line
    275  1047		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    276  1049
    277  1049				   ParseForNumber
    278  1049		       20 4c 11 	      jsr	ParseNumeric	; Check for a numeric value
    279  104c		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    280  104e
    281  104e				   ParseForString
    282  104e		       20 22 11 	      jsr	ParseString	; Check for a string
    283  1051		       90 ea		      bcc	ParseInputLoop	; It was a string
    284  1053
    285  1053				   ParseForOp
    286  1053		       20 8a 11 	      jsr	ParseForOperator	; Check for operator or punctuation
    287  1056		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    288  1058
    289  1058				   ParseForKey
    290  1058		       20 7f 10 	      jsr	ParseLookupKey	; Check for a keyword value
    291  105b		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    292  105d
    293  105d				   ParseForVar
    294  105d		       20 c1 11 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    295  1060		       90 db		      bcc	ParseInputLoop
    296  1062
    297  1062				   ParseKeepChar		; if it does not parse just keep it safe
    298  1062		       b9 7f 30 	      lda	LINBUF,y
    299  1065		       9d 29 0f 	      sta	TOKENBUFFER,x
    300  1068		       e8		      inx
    301  1069		       c8		      iny
    302  106a		       84 51		      sty	CUROFF
    303  106c		       d0 cf		      bne	ParseInputLoop
    304  106e
    305  106e				   ParseComplete
    306  106e		       a9 00		      lda	#0
    307  1070		       9d 29 0f 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    308  1073		       e8		      inx
    309  1074		       8e 29 0f 	      stx	TOKENBUFFER	; Place size including null into buffer start
    310  1077
    311  1077		       68		      pla
    312  1078		       a8		      tay
    313  1079		       68		      pla
    314  107a		       aa		      tax
    315  107b		       68		      pla
    316  107c		       85 51		      sta	CUROFF
    317  107e
    318  107e				  -	      if	DEBUGPARSER
    319  107e				  -
    320  107e				  -	      jsr	printTokenBuffer
    321  107e				  -			;jsr	  DebugPrintProgramLine
    322  107e				  -	      jsr	SetOutDebugEnd
    323  107e				  -
    324  107e					      endif
    325  107e		       60		      rts
    326  107f
    327  107f							;==================================================================================================================
    328  107f							; Look at curptr, curpos and check for a valid KeyWord
    329  107f							; A contains the index value. c is clear
    330  107f							;		     not found c set  A undefined
    331  107f							; X is prerserved
    332  107f							;
    333  107f				   ParseLookupKey
    334  107f		       86 58		      stx	R2
    335  1081		       a0 00		      ldy	#0
    336  1083		       a9 ff		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    337  1085		       85 54		      sta	R1
    338  1087		       a9 0d		      lda	#KeyWordTable>>8
    339  1089		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    340  108b		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    341  108d		       85 52		      sta	R0	; Save until next keyword
    342  108f		       c8		      iny		; Point to first character of keyword
    343  1090		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    344  1092
    345  1092				  -	      if	DEBUGPARSER
    346  1092				  -			;    jsr DebugKeyword
    347  1092					      endif
    348  1092
    349  1092				   ParseLookupLoop
    350  1092		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    351  1094		       29 df		      and	#%11011111	; Force Keyword to upper case
    352  1096		       dd 7f 30 	      cmp	LINBUF,x	; Check the input buffer
    353  1099		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    354  109b		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    355  109d		       dd 7f 30 	      cmp	LINBUF,x	; Compare value to upercase
    356  10a0		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    357  10a2
    358  10a2				   ParseNextLetter
    359  10a2		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    360  10a4		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    361  10a6		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    362  10a8		       e8		      inx		; Point to next char in the input buffer
    363  10a9		       c8		      iny		; Point to the next character in the Keyword table
    364  10aa		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    365  10ac		       dd 7f 30 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    366  10af		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    367  10b1		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    368  10b3
    369  10b3				   ParseKeyFound
    370  10b3		       a5 52		      lda	R0	; get the keyword index
    371  10b5
    372  10b5				   ParseKeyDone
    373  10b5		       e8		      inx		; point past the last character
    374  10b6		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    375  10b8		       a6 58		      ldx	R2	; Restore the original x pointer
    376  10ba		       9d 29 0f 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    377  10bd		       e8		      inx		; Point to next position in the output buffer
    378  10be		       86 58		      stx	R2	; Save next position in buffer
    379  10c0		       c9 0a		      cmp	#kRem	; remark statement
    380  10c2		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    381  10c4		       c9 07		      cmp	#kGoto
    382  10c6		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    383  10c8		       c9 08		      cmp	#kGosub
    384  10ca		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    385  10cc		       c9 35		      cmp	#kGofn
    386  10ce		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    387  10d0		       c9 2d		      cmp	#kTask
    388  10d2		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    389  10d4
    390  10d4		       18		      clc		; C flag clear, we found it
    391  10d5		       60		      rts
    392  10d6
    393  10d6							; Move forward to the next entry in table
    394  10d6				   ParseNextEntry
    395  10d6		       b1 54		      lda	(R1),y	; Get the next character in the token
    396  10d8		       29 20		      and	#%00100000	; Is it the last character
    397  10da		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    398  10dc		       c8		      iny		; Point to next char in the entry
    399  10dd		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    400  10df
    401  10df				   ParseEndOfEntry
    402  10df		       c8		      iny		; Point to the byte after the last character
    403  10e0		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    404  10e1		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    405  10e2		       65 54		      adc	R1
    406  10e4		       85 54		      sta	R1
    407  10e6		       a5 55		      lda	R1+1
    408  10e8		       69 00		      adc	#0
    409  10ea		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    410  10ec		       a0 00		      ldy	#0	; Reset the index back to zero
    411  10ee		       b1 54		      lda	(R1),y	; get keyword value
    412  10f0		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    413  10f2		       85 52		      sta	R0	; save the next token value
    414  10f4		       c8		      iny		; Inc past token value
    415  10f5
    416  10f5				  -	      if	DEBUGPARSER
    417  10f5				  -			;    jsr DebugKeyword
    418  10f5					      endif
    419  10f5		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    420  10f7		       4c 92 10 	      jmp	ParseLookupLoop	; branch back for next key word
    421  10fa
    422  10fa				   ParseNoneFound
    423  10fa		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    424  10fc		       38		      sec		; c clear, not found
    425  10fd		       60		      rts
    426  10fe
    427  10fe							;===============================================================================
    428  10fe							; Move everything from current position until the end of line into the token buffer
    429  10fe							;
    430  10fe		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    431  1100		       a6 58		      ldx	R2	; where to place in the buffer
    432  1102				   ParseMoveLoop
    433  1102		       b9 7f 30 	      lda	LINBUF,y	; get the next byte
    434  1105		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    435  1107		       9d 29 0f 	      sta	TOKENBUFFER,x	; save the byte
    436  110a		       c8		      iny
    437  110b		       e8		      inx
    438  110c		       d0 f4		      bne	ParseMoveLoop
    439  110e				   ParseMoveDone
    440  110e		       84 51		      sty	CUROFF
    441  1110		       18		      clc
    442  1111		       60		      rts
    443  1112							;================================================================================================
    444  1112							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    445  1112							; transfer to a memory address
    446  1112				   ParseHandleBranches
    447  1112		       a6 58		      ldx	R2
    448  1114		       a9 00		      lda	#0
    449  1116		       9d 29 0f 	      sta	TOKENBUFFER,x
    450  1119		       e8		      inx
    451  111a		       9d 29 0f 	      sta	TOKENBUFFER,x
    452  111d		       e8		      inx
    453  111e		       86 58		      stx	R2
    454  1120		       18		      clc
    455  1121		       60		      rts
    456  1122
    457  1122							;=========================================================================================================
    458  1122							;ParseString Parse a quotes string
    459  1122							; on input X = outbuf position
    460  1122							; y = inbuf position
    461  1122							; Copies string to output buffer, updates x and y
    462  1122				   ParseString
    463  1122		       a4 51		      ldy	CUROFF
    464  1124		       a9 a0		      lda	#tString
    465  1126		       9d 29 0f 	      sta	TOKENBUFFER,X
    466  1129		       b9 7f 30 	      lda	LINBUF,y
    467  112c		       c9 22		      cmp	#'"
    468  112e		       d0 1a		      bne	ParseStringInvalid
    469  1130		       e8		      inx
    470  1131		       9d 29 0f 	      sta	TOKENBUFFER,x
    471  1134		       e8		      inx
    472  1135		       c8		      iny
    473  1136
    474  1136				   ParseStringLoop
    475  1136		       b9 7f 30 	      lda	LINBUF,y
    476  1139		       9d 29 0f 	      sta	TOKENBUFFER,x
    477  113c		       c9 22		      cmp	#'"
    478  113e		       f0 04		      beq	ParseStringDone
    479  1140		       c8		      iny
    480  1141		       e8		      inx
    481  1142		       d0 f2		      bne	ParseStringLoop
    482  1144
    483  1144				   ParseStringDone
    484  1144		       e8		      inx
    485  1145		       c8		      iny
    486  1146		       84 51		      sty	CUROFF
    487  1148		       18		      clc
    488  1149		       60		      rts
    489  114a
    490  114a				   ParseStringInvalid
    491  114a		       38		      sec
    492  114b		       60		      rts
    493  114c
    494  114c							;=========================================================================================================
    495  114c							; Get numeric values and return value in RO and type in a
    496  114c							;
    497  114c				   ParseNumeric
    498  114c		       a4 51		      ldy	CUROFF
    499  114e		       b9 7f 30 	      lda	LINBUF,y
    500  1151		       c9 30		      cmp	#'0
    501  1153		       90 33		      bcc	ParseNumInvalid
    502  1155		       c9 3a		      cmp	#'9+1
    503  1157		       b0 2f		      bcs	ParseNumInvalid
    504  1159		       86 58		      stx	R2
    505  115b		       20 9a 1c 	      jsr	getDecimal
    506  115e		       a6 58		      ldx	R2
    507  1160		       84 51		      sty	CUROFF
    508  1162		       a5 53		      lda	R0+1
    509  1164		       f0 14		      beq	ParseByteValue
    510  1166
    511  1166				   ParseIntegerValue
    512  1166		       a9 a1		      lda	#tInteger
    513  1168		       9d 29 0f 	      sta	TOKENBUFFER,x
    514  116b		       e8		      inx
    515  116c		       a5 52		      lda	R0
    516  116e		       9d 29 0f 	      sta	TOKENBUFFER,x
    517  1171		       e8		      inx
    518  1172		       a5 53		      lda	R0+1
    519  1174		       9d 29 0f 	      sta	TOKENBUFFER,X
    520  1177		       e8		      inx
    521  1178		       18		      clc
    522  1179		       60		      rts
    523  117a
    524  117a				   ParseByteValue
    525  117a		       a9 a2		      lda	#tByte
    526  117c		       9d 29 0f 	      sta	TOKENBUFFER,x
    527  117f		       e8		      inx
    528  1180		       a5 52		      lda	R0
    529  1182		       9d 29 0f 	      sta	TOKENBUFFER,x
    530  1185		       e8		      inx
    531  1186		       18		      clc
    532  1187		       60		      rts
    533  1188
    534  1188				   ParseNumInvalid		;Not a valid Numeric
    535  1188		       38		      sec
    536  1189		       60		      rts
    537  118a
    538  118a							;=========================================================================================================
    539  118a							;Parse for operators and seperators
    540  118a							; on exit the A has the oper code, c is clear
    541  118a							;		 not found then c is set
    542  118a							;	x is preserved
    543  118a							;
    544  118a				   ParseForOperator
    545  118a		       86 58		      stx	R2
    546  118c		       a4 51		      ldy	CUROFF
    547  118e		       a2 00		      ldx	#0
    548  1190				  -	      if	DEBUGPARSER
    549  1190				  -			;	jsr    DebugPrintOP
    550  1190					      endif
    551  1190
    552  1190				   ParseOpLoop
    553  1190		       bd bb 0d 	      lda	Operators,x	; First byte of operator
    554  1193		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    555  1195
    556  1195		       d9 7f 30 	      cmp	LINBUF,y	; Check the first byte
    557  1198		       d0 1c		      bne	ParseOpNext
    558  119a
    559  119a		       c8		      iny
    560  119b
    561  119b		       bd bc 0d 	      lda	Operators+1,x
    562  119e		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    563  11a0
    564  11a0		       d9 7f 30 	      cmp	LINBUF,y
    565  11a3		       d0 11		      bne	ParseOpNext
    566  11a5
    567  11a5				   ParseOpFound
    568  11a5		       c8		      iny
    569  11a6
    570  11a6				   ParseOpFoundSingle
    571  11a6		       84 51		      sty	CUROFF
    572  11a8
    573  11a8		       8a		      txa
    574  11a9		       4a		      lsr
    575  11aa		       aa		      tax
    576  11ab		       bd e9 0d 	      lda	OperValues,x
    577  11ae		       a6 58		      ldx	R2
    578  11b0		       9d 29 0f 	      sta	TOKENBUFFER,x
    579  11b3		       e8		      inx
    580  11b4		       18		      clc
    581  11b5		       60		      rts
    582  11b6
    583  11b6				   ParseOpNext
    584  11b6		       e8		      inx
    585  11b7		       e8		      inx
    586  11b8
    587  11b8				  -	      if	DEBUGPARSER
    588  11b8				  -			;	 jsr	DebugPrintOP
    589  11b8					      endif
    590  11b8		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    591  11ba		       4c 90 11 	      jmp	ParseOpLoop
    592  11bd
    593  11bd				   ParseOpNotFound
    594  11bd		       a6 58		      ldx	R2
    595  11bf		       38		      sec
    596  11c0		       60		      rts
    597  11c1							;=========================================================================================================
    598  11c1				  -	      if	DEBUGPARSER
    599  11c1				  -			;Print the text of a keyword
    600  11c1				  -			;Input R1    = offset into table
    601  11c1				  -DebugKeyword
    602  11c1				  -	      tya
    603  11c1				  -	      pha
    604  11c1				  -	      ldy	#1
    605  11c1				  -DebugKeyLoop
    606  11c1				  -	      lda	(R1),y
    607  11c1				  -	      jsr	VOUTCH
    608  11c1				  -	      and	#%00100000
    609  11c1				  -	      beq	DebugKeyDone
    610  11c1				  -	      iny
    611  11c1				  -	      bne	DebugKeyLoop
    612  11c1				  -
    613  11c1				  -DebugKeyDone
    614  11c1				  -	      jsr	CRLF
    615  11c1				  -	      pla
    616  11c1				  -	      tay
    617  11c1				  -	      rts
    618  11c1				  -			;========================================
    619  11c1				  -DebugPrintOP
    620  11c1				  -	      pha
    621  11c1				  -	      lda	Operators,x
    622  11c1				  -	      jsr	VOUTCH
    623  11c1				  -	      lda	Operators+1,x
    624  11c1				  -	      beq	DbgPrtOpDone
    625  11c1				  -	      jsr	VOUTCH
    626  11c1				  -
    627  11c1				  -DbgPrtOpDone
    628  11c1				  -	      jsr	CRLF
    629  11c1				  -	      pla
    630  11c1				  -	      rts
    631  11c1				  -			;=======================================
    632  11c1				  -DebugClearBuffer
    633  11c1				  -	      txa
    634  11c1				  -	      pha
    635  11c1				  -	      ldx	#$FF
    636  11c1				  -	      lda	#0
    637  11c1				  -DebugClrLoop
    638  11c1				  -	      sta	TOKENBUFFER,x
    639  11c1				  -	      dex
    640  11c1				  -	      bne	DebugClrLoop
    641  11c1				  -	      sta	TOKENBUFFER,x
    642  11c1				  -	      pla
    643  11c1				  -	      tax
    644  11c1				  -	      rts
    645  11c1				  -
    646  11c1				  -			;=====================================================
    647  11c1				  -			; Print the parser buffer as hex values
    648  11c1				  -printTokenBuffer
    649  11c1				  -	      stx	printStorage
    650  11c1				  -	      sty	printStorage+1
    651  11c1				  -	      sta	printStorage+2
    652  11c1				  -
    653  11c1				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    654  11c1				  -	      inx		; we want to show the last zero byte
    655  11c1				  -	      ldy	#0
    656  11c1				  -
    657  11c1				  -printHexLoop
    658  11c1				  -	      lda	TOKENBUFFER,y	; get the character
    659  11c1				  -	      jsr	HexToOut	; print it
    660  11c1				  -	      lda	#$20
    661  11c1				  -	      jsr	VOUTCH
    662  11c1				  -	      iny
    663  11c1				  -	      dex
    664  11c1				  -	      cpx	#0
    665  11c1				  -	      bne	printHexLoop
    666  11c1				  -	      jsr	CRLF
    667  11c1				  -
    668  11c1				  -	      ldy	printStorage+1
    669  11c1				  -	      ldx	printStorage
    670  11c1				  -	      lda	printStorage+2
    671  11c1				  -printHexDone
    672  11c1				  -	      clc
    673  11c1				  -	      rts
    674  11c1					      endif
    675  11c1
    676  11c1
    677  11c1							;=========================================================================================================
    678  11c1							; Parse for variables A-Z @, ^  x!x x[op]
    679  11c1				   ParseForVariable
    680  11c1		       a4 51		      ldy	CUROFF
    681  11c3		       b9 7f 30 	      lda	LINBUF,y
    682  11c6		       c9 5e		      cmp	#'^	; is it an exit code
    683  11c8		       d0 04		      bne	ParseVarMem
    684  11ca		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    685  11cc		       d0 1f		      bne	ParseVarSpecial
    686  11ce
    687  11ce				   ParseVarMem
    688  11ce		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    689  11d0		       d0 04		      bne	ParseVarStack
    690  11d2		       a9 9d		      lda	#tVat
    691  11d4		       d0 17		      bne	ParseVarSpecial
    692  11d6
    693  11d6				   ParseVarStack
    694  11d6		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    695  11d8		       d0 04		      bne	ParseVarLetters
    696  11da		       a9 9c		      lda	#tVhash
    697  11dc		       d0 0f		      bne	ParseVarSpecial
    698  11de
    699  11de				   ParseVarLetters
    700  11de		       29 df		      and	#%11011111	; Force upper case
    701  11e0		       c9 41		      cmp	#'A
    702  11e2		       90 12		      bcc	ParseVarInvalid
    703  11e4		       c9 5b		      cmp	#'Z+1
    704  11e6		       b0 0e		      bcs	ParseVarInvalid
    705  11e8							;
    706  11e8							; The condition is true, so convert to an index, push
    707  11e8							; it onto the stack and continue running.
    708  11e8							;
    709  11e8		       38		      sec
    710  11e9		       e9 41		      sbc	#'A	;index is zero based
    711  11eb		       09 80		      ora	#$80
    712  11ed
    713  11ed				   ParseVarSpecial
    714  11ed		       9d 29 0f 	      sta	TOKENBUFFER,x
    715  11f0		       e8		      inx
    716  11f1		       c8		      iny
    717  11f2		       84 51		      sty	CUROFF
    718  11f4		       18		      clc
    719  11f5		       60		      rts
    720  11f6
    721  11f6				   ParseVarInvalid
    722  11f6		       38		      sec
    723  11f7		       60		      rts
    724  11f8
    725  11f8
    726  11f8							;=========================================================================================================
    727  11f8							; Transfer R0 to the TOKENBUFFER
    728  11f8							;
    729  11f8				   R02TOKEN
    730  11f8		       a5 52		      lda	R0
    731  11fa		       9d 29 0f 	      sta	TOKENBUFFER,x
    732  11fd		       e8		      inx
    733  11fe		       a5 53		      lda	R0+1
    734  1200		       9d 29 0f 	      sta	TOKENBUFFER,x
    735  1203		       e8		      inx
    736  1204		       18		      clc
    737  1205		       60		      rts
    738  1206							;=========================================================================
    739  1206							; Transfer word in Token Buffer to R0
    740  1206				   TOKEN2R0
    741  1206		       b9 29 0f 	      lda	TOKENBUFFER,y
    742  1209		       85 52		      sta	R0
    743  120b		       c8		      iny
    744  120c		       ca		      dex
    745  120d		       b9 29 0f 	      lda	TOKENBUFFER,y
    746  1210		       c8		      iny
    747  1211		       ca		      dex
    748  1212		       85 53		      sta	R0+1
    749  1214		       60		      rts
    750  1215							;==========================================================================
    751  1215							; Transfer	Display Buffer position to R0
    752  1215							;
    753  1215				   DPL2R0
    754  1215		       b1 59		      lda	(dpl),y
    755  1217		       85 52		      sta	R0
    756  1219		       c8		      iny
    757  121a		       ca		      dex
    758  121b		       b1 59		      lda	(dpl),y
    759  121d		       c8		      iny
    760  121e		       ca		      dex
    761  121f		       85 53		      sta	R0+1
    762  1221		       60		      rts
    763  1222
    764  1222
    765  1222							;=========================================================================
    766  1222							; Read an IL byte lookit up in the table, of words
    767  1222							; set the next ilpc to point to that address
    768  1222							; if not found then do ussual filter stuff
    769  1222							; ongoto ilvectortable, not found address
    770  1222		       20 eb 1b    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    771  1225		       86 52		      stx	R0
    772  1227		       85 53		      sta	R0+1
    773  1229
    774  1229		       a4 51		      ldy	CUROFF
    775  122b		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    776  122d		       a0 00		      ldy	#0
    777  122f		       38		      sec
    778  1230		       f1 52		      sbc	(R0),y	; Subract the base value
    779  1232		       c8		      iny
    780  1233		       d1 52		      cmp	(R0),y	; Check if we are in range
    781  1235		       b0 12		      bcs	iOnGotoInvalid
    782  1237		       e6 51		      inc	CUROFF	; Save the offset
    783  1239
    784  1239		       0a		      asl
    785  123a		       a8		      tay		; Turn into vector
    786  123b		       c8		      iny		; Inc must include the table base and entry count
    787  123c		       c8		      iny
    788  123d
    789  123d		       b1 52		      lda	(R0),y
    790  123f		       85 43		      sta	ILPC
    791  1241		       c8		      iny
    792  1242		       b1 52		      lda	(R0),y
    793  1244		       85 44		      sta	ILPC+1
    794  1246		       4c c3 02 	      jmp	NextIL
    795  1249
    796  1249				   iOnGotoInvalid
    797  1249		       20 eb 1b 	      jsr	getILWord
    798  124c		       86 43		      stx	ILPC
    799  124e		       85 44		      sta	ILPC+1
    800  1250		       4c c3 02 	      jmp	NextIL
    801  1253							;
    802  1253							;==========================================================================================
    803  1253							; Test the token for relop and push the value onto the stack if true
    804  1253							;
    805  1253				   iTSTRELOP
    806  1253		       20 ef 1b 	      jsr	getILByte
    807  1256		       8d 18 31 	      sta	offset
    808  1259
    809  1259		       a4 51		      ldy	CUROFF
    810  125b		       b1 4f		      lda	(CURPTR),y
    811  125d		       48		      pha
    812  125e		       29 f0		      and	#$F0
    813  1260		       c9 f0		      cmp	#$F0
    814  1262		       d0 12		      bne	iTSTRELOPNOT
    815  1264		       68		      pla
    816  1265		       29 0f		      and	#$0F	; get the actual value
    817  1267		       85 52		      sta	R0	; save it for later
    818  1269		       a9 00		      lda	#0
    819  126b		       85 53		      sta	R0+1
    820  126d		       20 e8 1d 	      jsr	pushR0
    821  1270		       c8		      iny
    822  1271		       84 51		      sty	CUROFF	; save the y pointer
    823  1273		       4c c3 02 	      jmp	NextIL
    824  1276
    825  1276				   iTSTRELOPNOT
    826  1276		       68		      pla
    827  1277		       4c c3 0b 	      jmp	tstBranch
    828  127a
    829  127a							;
    830  127a							;===================================================================================================
    831  127a							; Test the token and following info for precompiled address information
    832  127a							; skip it if zero, transfer and skip next integer value if not zero
    833  127a							; used by both gosub, goto and gofN
    834  127a							;
    835  127a				   iTSTBRANCH
    836  127a		       20 ef 1b 	      jsr	getILByte	; Get jump address if vector is valid
    837  127d		       8d 18 31 	      sta	offset	; Mark offset for later if vector found
    838  1280		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    839  1282		       88		      dey		; point back to the type of branch
    840  1283		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    841  1285		       48		      pha		; Save till needed
    842  1286		       c8		      iny		; back to memory vectors
    843  1287				   ITSTBRANCHCont
    844  1287		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    845  1289		       85 52		      sta	R0	; R0 will contain mem pointer of present
    846  128b		       c8		      iny		; Point to next byte of mem vector
    847  128c		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    848  128e		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    849  1290		       c8		      iny		; Point to the byte past memory vector
    850  1291		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    851  1293
    852  1293		       05 52		      ora	R0	; Get the second byte of the mem
    853  1295		       f0 21		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    854  1297		       68		      pla
    855  1298		       c9 2d		      cmp	#kTask	; Task defied with Task() so bypass the first bracket
    856  129a		       d0 07		      bne	iTSTBRANCHCont
    857  129c		       b1 4f		      lda	(CURPTR),y
    858  129e		       c9 e0		      cmp	#oLeftBracket
    859  12a0		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    860  12a2		       c8		      iny		; Increment past the bracket
    861  12a3				   iTSTBRANCHCont
    862  12a3		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    863  12a5		       c9 a2		      cmp	#tByte	; A byte value is valid
    864  12a7		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    865  12a9		       c9 a1		      cmp	#tInteger	; An integer value is valid
    866  12ab		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    867  12ad		       c8		      iny		; skip type indicator for
    868  12ae				   ITSTBRANCHBYTE
    869  12ae		       c8		      iny		; skip first byte of value line number
    870  12af		       c8		      iny		; Skip second byte of line number
    871  12b0
    872  12b0				   iTSTBRANCHVALID
    873  12b0		       84 51		      sty	CUROFF
    874  12b2		       20 e8 1d 	      jsr	pushR0	; place transfer address on top of stack
    875  12b5		       4c c3 0b 	      jmp	tstBranch
    876  12b8
    877  12b8				   iTSTBRANCHNoCompile
    878  12b8		       68		      pla
    879  12b9				   iTSTBRANCHErr
    880  12b9		       4c c3 02 	      jmp	NextIL
    881  12bc
    882  12bc
    883  12bc
    884  12bc
    885  12bc
    886  12bc
    887  12bc
    888  12bc
    889  12bc
    890  12bc
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  12bc					      include	"compile.asm"
      1  12bc					      Seg	Code
      2  12bc							;
      3  12bc							;=====================================================================
      4  12bc							; Scan the loaded program just before running and insert memory locations of each
      5  12bc							; line number branched to. goto gosub, gofn
      6  12bc							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  12bc				   Compile
      8  12bc		       a9 00		      lda	#0
      9  12be		       85 52		      sta	R0	; keep track of how many errors we find
     10  12c0		       a5 5b		      lda	RunMode
     11  12c2		       48		      pha
     12  12c3		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  12c5		       a5 4f		      lda	CURPTR
     14  12c7		       48		      pha
     15  12c8		       a5 50		      lda	CURPTR+1
     16  12ca		       48		      pha
     17  12cb		       a5 51		      lda	CUROFF
     18  12cd		       48		      pha
     19  12ce		       ad 1c 31 	      lda	ProgramStart
     20  12d1		       85 59		      sta	dpl
     21  12d3		       ad 1d 31 	      lda	ProgramStart+1
     22  12d6		       85 5a		      sta	dpl+1
     23  12d8
     24  12d8				   CompileLineStart
     25  12d8		       a5 59		      lda	dpl
     26  12da		       cd 1e 31 	      cmp	ProgramEnd
     27  12dd		       d0 07		      bne	CompileContinue
     28  12df		       a5 5a		      lda	dpl+1
     29  12e1		       cd 1f 31 	      cmp	ProgramEnd+1
     30  12e4		       f0 3f		      beq	CompileComplete
     31  12e6
     32  12e6				   CompileContinue
     33  12e6		       a0 03		      ldy	#3	; first real character in the line
     34  12e8
     35  12e8				   CompileLoop
     36  12e8		       b1 59		      lda	(dpl),y	; get the byte
     37  12ea		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  12ec		       c8		      iny		; Pass this byte
     39  12ed		       c9 07		      cmp	#kGoto
     40  12ef		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  12f1		       c9 08		      cmp	#kGosub
     42  12f3		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  12f5		       c9 35		      cmp	#kGofn
     44  12f7		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  12f9		       c9 2d		      cmp	#kTask
     46  12fb		       f0 4c		      beq	CompileField
     47  12fd		       c9 0a		      cmp	#kRem
     48  12ff		       f0 12		      beq	CompileRem	; Skip until end of line
     49  1301		       c9 a0		      cmp	#tString
     50  1303		       f0 2f		      beq	CompileString
     51  1305		       c9 a1		      cmp	#tInteger
     52  1307		       f0 06		      beq	CompileInteger
     53  1309		       c9 a2		      cmp	#tByte
     54  130b		       f0 03		      beq	CompileByte
     55  130d		       d0 d9		      bne	CompileLoop	; Next character
     56  130f
     57  130f				   CompileInteger
     58  130f		       c8		      iny
     59  1310				   CompileByte
     60  1310		       c8		      iny
     61  1311		       d0 d5		      bne	CompileLoop
     62  1313				   CompileRem
     63  1313				   CompileEndOfLine
     64  1313		       a0 00		      ldy	#0
     65  1315		       b1 59		      lda	(dpl),y
     66  1317		       18		      clc
     67  1318		       65 59		      adc	dpl
     68  131a		       85 59		      sta	dpl
     69  131c		       a9 00		      lda	#0
     70  131e		       65 5a		      adc	dpl+1
     71  1320		       85 5a		      sta	dpl+1
     72  1322
     73  1322		       4c d8 12 	      jmp	CompileLineStart
     74  1325
     75  1325				   CompileComplete
     76  1325		       68		      pla
     77  1326		       85 51		      sta	CUROFF
     78  1328		       68		      pla
     79  1329		       85 50		      sta	CURPTR+1
     80  132b		       68		      pla
     81  132c		       85 4f		      sta	CURPTR
     82  132e		       68		      pla
     83  132f		       85 5b		      sta	RunMode
     84  1331		       a5 52		      lda	R0	; returning the number of errors
     85  1333		       60		      rts
     86  1334
     87  1334
     88  1334				   CompileString
     89  1334		       c8		      iny		; point past first "
     90  1335				   CompileStringLoop
     91  1335		       b1 59		      lda	(dpl),y
     92  1337		       f0 0d		      beq	CompileStrDone2	; end of line
     93  1339		       c9 22		      cmp	#'"	; end of string
     94  133b		       f0 08		      beq	CompileStrDone
     95  133d		       c9 5c		      cmp	#'\	; escape character
     96  133f		       d0 01		      bne	CompileStrNext
     97  1341		       c8		      iny		; skip the escape character
     98  1342				   CompileStrNext
     99  1342		       c8		      iny		; Next character
    100  1343		       d0 f0		      bne	CompileStringLoop	; test for end
    101  1345				   CompileStrDone
    102  1345		       c8		      iny
    103  1346				   CompileStrDone2
    104  1346		       4c e8 12 	      Jmp	CompileLoop
    105  1349							;
    106  1349							;===============================================================
    107  1349							; on entry y points to storage location y+2 points to line number
    108  1349							; on exit y points to line number type
    109  1349
    110  1349		       85 52	   CompileField sta	R0
    111  134b		       98		      tya		; save the y pointer to store the memory value
    112  134c		       48		      pha
    113  134d		       c8		      iny		; Skip over the memory vector
    114  134e		       c8		      iny
    115  134f		       a5 52		      lda	R0
    116  1351		       c9 2d		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  1353		       d0 07		      bne	CompNoBracket
    118  1355
    119  1355		       b1 59		      lda	(dpl),y	; Lets make sure it is a )
    120  1357		       c9 e0		      cmp	#oLeftBracket
    121  1359		       d0 01		      bne	CompNoBracket	; in case of error
    122  135b		       c8		      iny		; skip the bracket
    123  135c
    124  135c				   CompNoBracket
    125  135c		       a9 00		      lda	#0	; In case the value is a byte
    126  135e		       85 53		      sta	R0+1
    127  1360
    128  1360		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  1362		       c9 a2		      cmp	#tByte
    130  1364		       f0 15		      beq	CompByteLoad
    131  1366		       c9 a1		      cmp	#tInteger
    132  1368		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  136a		       68		      pla
    134  136b		       4c e8 12 	      jmp	CompileLoop	; Ignore the saved stack
    135  136e				   CompIntLoad
    136  136e		       c8		      iny
    137  136f		       b1 59		      lda	(dpl),y
    138  1371		       85 52		      sta	R0
    139  1373		       c8		      iny
    140  1374		       b1 59		      lda	(dpl),y
    141  1376		       85 53		      sta	R0+1
    142  1378		       4c 80 13 	      jmp	CompFindLine
    143  137b				   CompByteLoad
    144  137b		       c8		      iny
    145  137c		       b1 59		      lda	(dpl),y
    146  137e		       85 52		      sta	R0
    147  1380				   CompFindLine
    148  1380		       20 34 1c 	      jsr	findLine
    149  1383		       f0 1d		      beq	CompFoundLine
    150  1385		       e6 52		      inc	R0	; number of errors
    151  1387
    152  1387		       a5 59		      lda	dpl
    153  1389		       85 4f		      sta	CURPTR
    154  138b		       a5 5a		      lda	dpl+1
    155  138d		       85 50		      sta	CURPTR+1
    156  138f		       84 51		      sty	CUROFF
    157  1391
    158  1391		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  1393		       a9 00		      lda	#0
    160  1395
    161  1395		       20 5a 06 	      jsr	DisplayError
    162  1398		       20 1a 15 	      jsr	PrintProgramLine
    163  139b
    164  139b		       68		      pla
    165  139c		       a8		      tay
    166  139d		       c8		      iny
    167  139e		       c8		      iny
    168  139f		       4c e8 12 	      jmp	CompileLoop
    169  13a2
    170  13a2				   CompFoundLine
    171  13a2		       68		      pla
    172  13a3		       a8		      tay
    173  13a4		       a5 4f		      lda	CURPTR
    174  13a6		       91 59		      sta	(dpl),y
    175  13a8		       c8		      iny
    176  13a9		       a5 50		      lda	CURPTR+1
    177  13ab		       91 59		      sta	(dpl),y
    178  13ad		       c8		      iny
    179  13ae		       4c e8 12 	      jmp	CompileLoop
    180  13b1
    181  13b1
    182  13b1
    183  13b1
    184  13b1
    185  13b1
    186  13b1
    187  13b1
    188  13b1
    189  13b1
    190  13b1
    191  13b1
    192  13b1
    193  13b1
    194  13b1
    195  13b1
    196  13b1
    197  13b1
    198  13b1
    199  13b1
    200  13b1
    201  13b1
    202  13b1
    203  13b1
    204  13b1
    205  13b1
    206  13b1
    207  13b1
    208  13b1
    209  13b1
    210  13b1
    211  13b1
    212  13b1
    213  13b1
    214  13b1
    215  13b1
    216  13b1
    217  13b1
    218  13b1
    219  13b1
    220  13b1
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  13b1					      include	"print.asm"
      1  13b1					      Seg	Code
      2  13b1							;---------------------------
      3  13b1							; Print 24-bit decimal number or  16bit unsigned
      4  13b1							; ---------------------------
      5  13b1							; On entry, R0=number to print
      6  13b1							;	     Defaults to pad=0 , y=21 default
      7  13b1							;	     R2 = 1 unsigned 16 bit
      8  13b1							;	     R2 = 0 Signed   16 bit
      9  13b1
     10  13b1							; On entry at PrintDecPadded:
     11  13b1							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  13b1
     13  13b1							; On exit,  A,X,Y,num,pad corrupted
     14  13b1							; Size      129 bytes, Table 24 bytes	--- total 153
     15  13b1							; -----------------------------------------------------------------
     16  13b1
     17  13b1				   PrintDecimal
     18  13b1		       8a		      TXA
     19  13b2		       48		      pha
     20  13b3		       98		      tya
     21  13b4		       48		      pha
     22  13b5		       a9 00		      lda	#0
     23  13b7		       8d 4c 14 	      sta	pad
     24  13ba		       a0 15		      LDY	#21	; Offset to powers of ten
     25  13bc		       4c c2 13 	      JMP	PrintDo
     26  13bf
     27  13bf				   PrintDecPadded
     28  13bf		       8e 4c 14 	      stx	pad
     29  13c2
     30  13c2				   PrintDo
     31  13c2		       a9 00		      lda	#0
     32  13c4		       85 54		      sta	R1
     33  13c6
     34  13c6		       a5 58		      lda	R2
     35  13c8		       c9 a7		      cmp	#tUint
     36  13ca		       f0 29		      beq	PrintPos
     37  13cc
     38  13cc		       a5 53		      lda	R0+1	;MSB has sign
     39  13ce		       10 25		      bpl	PrintPos	;it's a positive number;
     40  13d0
     41  13d0
     42  13d0							; Negative numbers need more work.  Invert all the bits,
     43  13d0							; then add one.
     44  13d0
     45  13d0		       a9 2d		      lda	#'-
     46  13d2		       20 81 20 	      jsr	VOUTCH	;print the negative sign
     47  13d5
     48  13d5		       a9 ff		      lda	#$FF
     49  13d7		       85 54		      sta	R1
     50  13d9		       a5 52		      lda	R0	;invert bits
     51  13db		       49 ff		      eor	#$ff
     52  13dd		       85 52		      sta	R0
     53  13df		       a5 53		      lda	R0+1
     54  13e1		       49 ff		      eor	#$ff
     55  13e3		       85 53		      sta	R0+1
     56  13e5		       a5 54		      lda	R1
     57  13e7		       49 ff		      eor	#$ff
     58  13e9		       85 54		      sta	R1
     59  13eb		       e6 52		      inc	R0	;add one
     60  13ed		       d0 06		      bne	PrintPos
     61  13ef		       e6 53		      inc	R0+1
     62  13f1		       d0 02		      bne	PrintPos
     63  13f3		       e6 54		      inc	R1
     64  13f5				   PrintPos
     65  13f5
     66  13f5				   PrDec24Lp1
     67  13f5		       a2 ff		      LDX	#$FF
     68  13f7		       38		      SEC		; Start with digit=-1
     69  13f8				   PrDec24Lp2
     70  13f8		       a5 52		      LDA	R0+0
     71  13fa		       f9 4d 14 	      SBC	PrDec24Tens+0,Y
     72  13fd		       85 52		      STA	R0+0	; Subtract current tens
     73  13ff		       a5 53		      LDA	R0+1
     74  1401		       f9 4e 14 	      SBC	PrDec24Tens+1,Y
     75  1404		       85 53		      STA	R0+1
     76  1406		       a5 54		      LDA	R0+2
     77  1408		       f9 4f 14 	      SBC	PrDec24Tens+2,Y
     78  140b		       85 54		      STA	R0+2
     79  140d		       e8		      INX
     80  140e		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  1410		       a5 52		      LDA	R0+0
     82  1412		       79 4d 14 	      ADC	PrDec24Tens+0,Y
     83  1415		       85 52		      STA	R0+0	; Add current tens back in
     84  1417		       a5 53		      LDA	R0+1
     85  1419		       79 4e 14 	      ADC	PrDec24Tens+1,Y
     86  141c		       85 53		      STA	R0+1
     87  141e		       a5 54		      LDA	R0+2
     88  1420		       79 4f 14 	      ADC	PrDec24Tens+2,Y
     89  1423		       85 54		      STA	R0+2
     90  1425		       8a		      TXA
     91  1426		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  1428		       ad 4c 14 	      LDA	pad
     93  142b		       d0 09		      BNE	PrDec24Print
     94  142d		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  142f				   PrDec24Digit
     96  142f		       a2 30		      LDX	#'0
     97  1431		       8e 4c 14 	      STX	pad	; No more zero padding
     98  1434		       09 30		      ORA	#'0	; Print this digit
     99  1436				   PrDec24Print
    100  1436		       20 81 20 	      JSR	VOUTCH
    101  1439				   PrDec24Next
    102  1439		       88		      DEY
    103  143a		       88		      DEY
    104  143b		       88		      DEY
    105  143c		       f0 07		      beq	PrDec24LastDigit
    106  143e		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  1440		       68		      pla
    108  1441		       a8		      tay
    109  1442		       68		      pla
    110  1443		       aa		      tax
    111  1444		       60		      RTS
    112  1445				   PrDec24LastDigit
    113  1445		       a2 30		      LDX	#'0
    114  1447		       8e 4c 14 	      STX	pad	; No more zero padding
    115  144a		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  144c
      0  144c				   pad	      db	0
      1  144c		       00		      .byte.b	0
    118  144d
    119  144d				   PrDec24Tens
      0  144d					      dw	1
      1  144d		       01 00		      .word.w	1
      0  144f					      db	(1 / 65536)
      1  144f		       00		      .byte.b	(1 / 65536)
      0  1450					      dw	10
      1  1450		       0a 00		      .word.w	10
      0  1452					      db	(10 / 65536)
      1  1452		       00		      .byte.b	(10 / 65536)
      0  1453					      dw	100
      1  1453		       64 00		      .word.w	100
      0  1455					      db	(100 / 65536)
      1  1455		       00		      .byte.b	(100 / 65536)
      0  1456					      dw	1000
      1  1456		       e8 03		      .word.w	1000
      0  1458					      db	(1000 / 65536)
      1  1458		       00		      .byte.b	(1000 / 65536)
      0  1459					      dw	10000
      1  1459		       10 27		      .word.w	10000
      0  145b					      db	(10000 / 65536)
      1  145b		       00		      .byte.b	(10000 / 65536)
      0  145c					      dw	100000
      1  145c		       a0 86		      .word.w	100000
      0  145e					      db	(100000 / 65536)
      1  145e		       01		      .byte.b	(100000 / 65536)
      0  145f					      dw	1000000
      1  145f		       40 42		      .word.w	1000000
      0  1461					      db	(1000000 / 65536)
      1  1461		       0f		      .byte.b	(1000000 / 65536)
      0  1462					      dw	10000000
      1  1462		       80 96		      .word.w	10000000
      0  1464					      db	(10000000 / 65536)
      1  1464		       98		      .byte.b	(10000000 / 65536)
    136  1465							;=====================================================
    137  1465							; Print character in A as two hex digits to the Console
    138  1465
    139  1465		       48	   HexToOut   pha		;save return value
    140  1466		       48		      pha
    141  1467		       4a		      lsr		;a  ;move top nibble to bottom
    142  1468		       4a		      lsr		;a
    143  1469		       4a		      lsr		;a
    144  146a		       4a		      lsr		;a
    145  146b		       20 74 14 	      jsr	hexta	;output nibble
    146  146e		       68		      pla
    147  146f		       20 74 14 	      jsr	hexta
    148  1472		       68		      pla		;restore
    149  1473		       60		      rts
    150  1474							;
    151  1474		       29 0f	   hexta      and	#%0001111
    152  1476		       c9 0a		      cmp	#$0a
    153  1478		       18		      clc
    154  1479		       30 02		      bmi	hexta1
    155  147b		       69 07		      adc	#7
    156  147d		       69 30	   hexta1     adc	#'0	;then fall into...
    157  147f		       4c 81 20 	      jmp	VOUTCH
    158  1482							;
    159  1482							;=====================================================
    160  1482							; Print the string that immediately follows the JSR to
    161  1482							; this function.  Stops when a null byte is found,
    162  1482							; then returns to the instruction immediately
    163  1482							; following the null.
    164  1482							;
    165  1482							; Thanks to Ross Archer for this code.
    166  1482							; http://www.6502.org/source/io/primm.htm
    167  1482							;
    168  1482
    169  1482		       68	   tbputs     pla		;Get the low part of "return" address
    170  1483							;(data start address)
    171  1483		       85 5e		      sta	PrtFrom
    172  1485		       68		      pla
    173  1486		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  1488							;(data start address)
    175  1488							;Note: actually we're pointing one short
    176  1488		       a0 01	   PSINB      ldy	#1
    177  148a		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  148c		       e6 5e		      inc	PrtFrom	;update the pointer
    179  148e		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  1490		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  1492		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  1494							;   Accumulator
    183  1494		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  1496		       20 81 20 	      jsr	VOUTCH	;write it out
    185  1499		       4c 88 14 	      jmp	PSINB	;back around
    186  149c		       e6 5e	   PSIX1      inc	PrtFrom
    187  149e		       d0 02		      bne	PSIX2
    188  14a0		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  14a2		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  14a5
    191  14a5							;+
    192  14a5							;====================================================
    193  14a5		       31 14	   PrtTerm    equ	tempy
    194  14a5
    195  14a5							; on exit Print Y has the offset to use
    196  14a5							; input y =	 addr low
    197  14a5							;	 x =	 addr high
    198  14a5							;	 a =	 termination string
    199  14a5
    200  14a5
    201  14a5				   PrtQuoted		; Print a quoted string from the current program space
    202  14a5		       a9 22		      lda	#'"
    203  14a7		       a4 51		      ldy	CUROFF
    204  14a9		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  14ab		       d0 03		      bne	PrtNoInc
    206  14ad		       c8		      iny
    207  14ae		       84 51		      sty	CUROFF
    208  14b0				   PrtNoInc
    209  14b0		       8d 14 31 	      sta	PrtTerm
    210  14b3
    211  14b3				   PrtPrgString 		; Print a terminated string from the static program space
    212  14b3		       a4 51		      ldy	CUROFF
    213  14b5		       a5 4f		      lda	CURPTR
    214  14b7		       85 5e		      sta	PrtFrom
    215  14b9		       a5 50		      lda	CURPTR+1
    216  14bb		       85 5f		      sta	PrtFrom+1
    217  14bd		       4c c9 14 	      jmp	PrtLoop
    218  14c0
    219  14c0							; Print a string pointed to by x= h, y=l terminated by a
    220  14c0							; Return y as the length
    221  14c0
    222  14c0		       86 5f	   PrtStr     stx	PrtFrom+1
    223  14c2		       84 5e		      sty	PrtFrom
    224  14c4		       8d 14 31 	      sta	PrtTerm
    225  14c7		       a0 00		      ldy	#0
    226  14c9							;
    227  14c9							; On entry here ptrfrom and prtterm point to area to print
    228  14c9							;
    229  14c9		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  14cb		       cd 14 31 	      cmp	PrtTerm
    231  14ce		       f0 0b		      beq	PrtEnd
    232  14d0		       c9 00		      cmp	#0	; always end if 0 is found
    233  14d2		       f0 07		      beq	PrtEnd
    234  14d4		       20 81 20 	      jsr	VOUTCH
    235  14d7		       c8		      iny
    236  14d8		       4c c9 14 	      jmp	PrtLoop
    237  14db		       c8	   PrtEnd     iny		;return byte after the copy
    238  14dc		       60		      rts
    239  14dd
    240  14dd							;
    241  14dd							;=======================================================
    242  14dd							; Print all Variables
    243  14dd				   PrintAllVars
    244  14dd		       a0 00		      ldy	#0
    245  14df		       a9 41		      lda	#'A
    246  14e1				   PrintAllVarsLoop
    247  14e1		       48		      pha
    248  14e2		       b1 41		      lda	(VARIABLES),y
    249  14e4		       85 52		      sta	R0
    250  14e6		       c8		      iny
    251  14e7		       b1 41		      lda	(VARIABLES),y
    252  14e9		       85 53		      sta	R0+1
    253  14eb
    254  14eb		       68		      pla		;get the current letter
    255  14ec		       48		      pha
    256  14ed		       20 81 20 	      jsr	VOUTCH
    257  14f0		       20 82 14 	      jsr	puts
      0  14f3					      db	"=",0
      1  14f3		       3d 00		      .byte.b	"=",0
    259  14f5		       68		      pla
    260  14f6		       aa		      tax
    261  14f7		       e8		      inx
    262  14f8		       8a		      txa
    263  14f9		       48		      pha		;
    264  14fa
    265  14fa		       98		      tya
    266  14fb		       48		      pha
    267  14fc		       20 b1 13 	      jsr	PrintDecimal
    268  14ff		       20 82 14 	      jsr	puts
      0  1502					      db	" ",0
      1  1502		       20 00		      .byte.b	" ",0
    270  1504		       68		      pla
    271  1505		       a8		      tay
    272  1506		       c8		      iny
    273  1507		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  1509		       90 d6		      bcc	PrintAllVarsLoop
    275  150b		       20 33 1f 	      jsr	CRLF
    276  150e
    277  150e		       68		      pla
    278  150f		       60		      rts
    279  1510							;==========================================================================================================
    280  1510							;Debug   Print a Program Line from compile buffer
    281  1510							;
    282  1510				   DebugPrintProgramLine
    283  1510		       48		      pha
    284  1511		       a9 29		      lda	#TOKENBUFFER&$FF
    285  1513		       85 59		      sta	dpl
    286  1515		       a9 0f		      lda	#TOKENBUFFER>>8
    287  1517		       85 5a		      sta	dpl+1
    288  1519		       68		      pla
    289  151a
    290  151a							; Decode and print a line of program text
    291  151a							; on entry	 dpl points to line of code to print
    292  151a							; on exit	 no change in reg or dpl
    293  151a							;
    294  151a				   PrintProgramLine
    295  151a
    296  151a		       8e 29 10 	      stx	printStorage
    297  151d		       8c 2a 10 	      sty	printStorage+1
    298  1520		       48		      pha
    299  1521
    300  1521		       a0 01		      ldy	#1	; index into the token buffer
    301  1523		       84 58		      sty	R2	; print unsigned decimal
    302  1525		       a0 00		      ldy	#0
    303  1527		       b1 59		      lda	(dpl),y	; get number of bytes
    304  1529		       aa		      tax		; place pointer into x
    305  152a		       c8		      iny
    306  152b		       ca		      dex		; Deduct the length byte
    307  152c		       20 15 12 	      jsr	DPL2R0	; Print the line number
    308  152f		       20 b1 13 	      jsr	PrintDecimal
    309  1532		       a9 20		      lda	#$20
    310  1534		       20 81 20 	      jsr	VOUTCH
    311  1537
    312  1537				   PrintProgLoop
    313  1537		       b1 59		      lda	(dpl),y	; Get a character
    314  1539		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  153b		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  153d		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  153f
    318  153f				   PrintProgVars
    319  153f		       b1 59		      lda	(dpl),y
    320  1541		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  1543		       c9 e0		      cmp	#$E0
    322  1545		       f0 6b		      beq	PrintProgOperatorVect
    323  1547
    324  1547		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  1549		       c9 9e		      cmp	#$9D+1
    326  154b		       90 62		      bcc	PrintProgVariableVec
    327  154d		       29 a0		      and	#$A0	; Check for a valid datatype
    328  154f		       c9 a0		      cmp	#$A0
    329  1551		       f0 06		      beq	PrintDataType	; if not just print the character
    330  1553		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  1555		       ca		      dex		; Ok we are processing it
    332  1556		       c8		      iny
    333  1557		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  1559
    335  1559				   PrintDataType
    336  1559		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  155b		       c9 a0		      cmp	#tString
    338  155d		       f0 31		      beq	PrintStringVariable
    339  155f
    340  155f				   PrintProgNumber
    341  155f		       c8		      iny		; we have a numerical integer value
    342  1560		       ca		      dex
    343  1561		       48		      pha
    344  1562		       a9 00		      lda	#0
    345  1564		       85 53		      sta	R0+1
    346  1566		       85 58		      sta	R2	; Set to print signed number
    347  1568		       b1 59		      lda	(dpl),y
    348  156a		       85 52		      sta	R0
    349  156c		       68		      pla
    350  156d		       c9 a1		      cmp	#tInteger
    351  156f		       d0 06		      bne	PrintProgNumDone
    352  1571		       c8		      iny
    353  1572		       ca		      dex
    354  1573		       b1 59		      lda	(dpl),y
    355  1575		       85 53		      sta	R0+1
    356  1577
    357  1577				   PrintProgNumDone
    358  1577		       c8		      iny
    359  1578		       ca		      dex
    360  1579		       20 b1 13 	      jsr	PrintDecimal
    361  157c
    362  157c				   PrintProgNext
    363  157c		       a9 20		      lda	#$20
    364  157e				   PrintContinue
    365  157e		       20 81 20 	      jsr	VOUTCH
    366  1581				   PrintProgSkipSpace
    367  1581		       e0 00		      cpx	#0
    368  1583		       d0 b2		      bne	PrintProgLoop
    369  1585				   PrintProgramComplete
    370  1585		       20 33 1f 	      jsr	CRLF
    371  1588
    372  1588		       ae 29 10 	      ldx	printStorage
    373  158b		       ac 2a 10 	      ldy	printStorage+1
    374  158e		       68		      pla
    375  158f
    376  158f		       60		      rts
    377  1590							;=================================================================================================================
    378  1590							; Print a string variable including the quotes
    379  1590							; On Input	 y is offset into buffer
    380  1590							; On Exit	 y is updated to new offset
    381  1590
    382  1590				   PrintStringVariable
    383  1590		       c8		      iny
    384  1591		       a9 22		      lda	#'"
    385  1593		       20 81 20 	      jsr	VOUTCH
    386  1596		       c8		      iny
    387  1597		       a5 59		      lda	dpl
    388  1599		       85 5e		      sta	PrtFrom
    389  159b		       a5 5a		      lda	dpl+1
    390  159d		       85 5f		      sta	PrtFrom+1
    391  159f		       a9 22		      lda	#'"
    392  15a1		       8d 14 31 	      sta	PrtTerm
    393  15a4		       20 c9 14 	      jsr	PrtLoop
    394  15a7		       a9 22		      lda	#'"
    395  15a9		       20 81 20 	      jsr	VOUTCH
    396  15ac		       4c 7c 15 	      jmp	PrintProgNext
    397  15af
    398  15af				   PrintProgVariableVec
    399  15af		       4c 4f 16 	      jmp	PrintProgVariable
    400  15b2
    401  15b2				   PrintProgOperatorVect
    402  15b2		       4c 26 16 	      jmp	PrintProgOperator
    403  15b5							;===============================================================================================================
    404  15b5							; On entry dpl points to the buffer we are printing from
    405  15b5							;	    y	current offset into the dpl buffer
    406  15b5							; all registers preserved
    407  15b5							;
    408  15b5				   PrintKeyword
    409  15b5
    410  15b5		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  15b7		       85 52		      sta	R0	; The value we are looking for
    412  15b9		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  15bb		       f0 0c		      beq	PrintKeyBranch
    414  15bd		       c9 08		      cmp	#kGosub
    415  15bf		       f0 08		      beq	PrintKeyBranch
    416  15c1		       c9 2d		      cmp	#kTask
    417  15c3		       f0 04		      beq	PrintKeyBranch
    418  15c5		       c9 35		      cmp	#kGofn
    419  15c7		       d0 04		      bne	PrintKeySkipped
    420  15c9				   PrintKeyBranch
    421  15c9		       c8		      iny		; Skip the compiled memory address
    422  15ca		       c8		      iny
    423  15cb		       ca		      dex		; Change number of bytes to print
    424  15cc		       ca		      dex		; Remove the bytes to print
    425  15cd
    426  15cd				   PrintKeySkipped
    427  15cd		       c8		      iny		; Inc y to point to the next char to be printed
    428  15ce		       ca		      dex		; Reduce number of bytes to print
    429  15cf		       98		      tya		; Save y and x for the return
    430  15d0		       48		      pha
    431  15d1		       8a		      txa
    432  15d2		       48		      pha
    433  15d3
    434  15d3		       a9 ff		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  15d5		       85 54		      sta	R1
    436  15d7		       a9 0d		      lda	#KeyWordTable>>8
    437  15d9		       85 55		      sta	R1+1
    438  15db
    439  15db
    440  15db				   PrintKeyLoop
    441  15db		       a0 00		      ldy	#0	; Index into the keyword entry
    442  15dd		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  15df		       c8		      iny		; Point to first byte of key
    444  15e0		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  15e2		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  15e4
    447  15e4				   PrintKeyNext
    448  15e4		       b1 54		      lda	(R1),y	; Get key letter
    449  15e6		       c8		      iny		; Point to next byte always
    450  15e7		       29 20		      and	#%00100000	; Check for last character in key work
    451  15e9		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  15eb
    453  15eb		       98		      tya		; Trabsfer y to a for the addition
    454  15ec		       18		      clc		; Table > 256 bytes
    455  15ed		       65 54		      adc	R1
    456  15ef		       85 54		      sta	R1
    457  15f1		       a9 00		      lda	#0
    458  15f3		       65 55		      adc	R1+1
    459  15f5		       85 55		      sta	R1+1
    460  15f7		       4c db 15 	      jmp	PrintKeyLoop
    461  15fa
    462  15fa				   PrintKeyFound
    463  15fa		       b1 54		      lda	(R1),y	; letter from key table
    464  15fc		       48		      pha		; Save it for later check
    465  15fd		       09 20		      ora	#%00100000	; Force it to lower case
    466  15ff		       20 81 20 	      jsr	VOUTCH	; Print it out
    467  1602		       c8		      iny		; Point to next character
    468  1603		       68		      pla		; Restore the value
    469  1604		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  1606		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  1608
    472  1608		       68		      pla		; Restore the x and y values
    473  1609		       aa		      tax
    474  160a		       68		      pla
    475  160b		       a8		      tay
    476  160c
    477  160c				   PrintChkRem
    478  160c		       a9 0a		      lda	#kRem
    479  160e		       c5 52		      cmp	R0
    480  1610		       d0 11		      bne	PrintKeyDone
    481  1612				   PrintKeyRem
    482  1612		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  1614		       85 5e		      sta	PrtFrom
    484  1616		       a5 5a		      lda	dpl+1
    485  1618		       85 5f		      sta	PrtFrom+1
    486  161a		       a9 00		      lda	#0
    487  161c		       8d 14 31 	      sta	PrtTerm
    488  161f		       20 c9 14 	      jsr	PrtLoop
    489  1622		       88		      dey		; point back to the terminating null value
    490  1623				   PrintKeyDone
    491  1623		       4c 7c 15 	      jmp	PrintProgNext
    492  1626							;==================================================================================================================
    493  1626							;Print Variable, number or operator
    494  1626				   PrintProgOperator
    495  1626		       b1 59		      lda	(dpl),y
    496  1628		       c8		      iny
    497  1629		       ca		      dex
    498  162a		       8e 2b 10 	      stx	printStorage+2
    499  162d		       a2 00		      ldx	#0
    500  162f				   PrintOprLoop
    501  162f		       dd e9 0d 	      cmp	OperValues,x
    502  1632		       f0 03		      beq	PrintOprFound
    503  1634		       e8		      inx
    504  1635		       d0 f8		      bne	PrintOprLoop
    505  1637				   PrintOprFound
    506  1637		       8a		      txa
    507  1638		       0a		      asl
    508  1639		       aa		      tax
    509  163a		       bd bb 0d 	      lda	Operators,x
    510  163d		       20 81 20 	      jsr	VOUTCH
    511  1640		       e8		      inx
    512  1641		       bd bb 0d 	      lda	Operators,x
    513  1644		       f0 03		      beq	PrintOprDone
    514  1646		       20 81 20 	      jsr	VOUTCH
    515  1649				   PrintOprDone
    516  1649		       ae 2b 10 	      ldx	printStorage+2
    517  164c		       4c 7c 15 	      jmp	PrintProgNext
    518  164f
    519  164f							;=================================================================================================================
    520  164f							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  164f							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  164f							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  164f							;tVhat 	    equ     155 		   ; Variable ^
    524  164f							;tVhash	    equ     156 		   ; Variable #
    525  164f							;tVat		    equ     157 		   ; Variable @ = 0
    526  164f				   PrintProgVariable
    527  164f		       b1 59		      lda	(dpl),y
    528  1651		       c8		      iny
    529  1652		       ca		      dex
    530  1653		       c9 9b		      cmp	#tVhat
    531  1655		       d0 04		      bne	PrintProgChkHash
    532  1657		       a9 5e		      lda	#'^
    533  1659		       d0 15		      bne	PrintTheVar
    534  165b				   PrintProgChkHash
    535  165b		       c9 9c		      cmp	#tVhash
    536  165d		       d0 04		      bne	PrintProgChkAt
    537  165f		       a9 23		      lda	#'#
    538  1661		       d0 0d		      bne	PrintTheVar
    539  1663				   PrintProgChkAt
    540  1663		       c9 9d		      cmp	#tVat
    541  1665		       d0 04		      bne	PrintProgVarLetter
    542  1667		       a9 40		      lda	#'@
    543  1669		       d0 05		      bne	PrintTheVar
    544  166b				   PrintProgVarLetter
    545  166b		       29 7f		      and	#%01111111
    546  166d		       18		      clc
    547  166e		       69 41		      adc	#'A
    548  1670				   PrintTheVar
    549  1670		       20 81 20 	      jsr	VOUTCH
    550  1673		       4c 7c 15 	      jmp	PrintProgNext
    551  1676
    552  1676
    553  1676							;==================================================================================================
    554  1676							; Size of print functions
    555  1676		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  1676					      include	"mem.asm"
      1  1676							;===================================================================
      2  1676							;This file contains the memory allocation and free functions
      3  1676							;in herant in this is the management of free memory in the system
      4  1676							; the interface to these functions
      5  1676							; a,x returns or provides the low hi bytes of the managed addresses
      6  1676							; This uses the programend, to memory end as the area to manage
      7  1676							;===================================================================
      8  1676					      Seg	Code
      9  1676							;=====================================================
     10  1676							;Pointers for memory Management
     11  1676							;Allocated block are not chained but can be followed for all memory by the associated length
     12  1676							; Mem block format is
     13  1676							;	 0-1   pointer to next block for free blocks
     14  1676							;	 0-1   for allocated blocks
     15  1676							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  1676							;	   1   refrence counter ... lol only up to 256 but it is something
     17  1676							;	 2-3   length constant for exevy type of memory block
     18  1676							; Memory is recombined as it is released
     19  1676							; The memory manager is not interupted durring allocation
     20  1676							; or freeing of memory
     21  1676							; Memory is allocated from the highest memory address towards
     22  1676							; the lowest memory address. meeting the Basic program end.
     23  1676							;====================================================
     24  1676							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  1676							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  1676							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  1676							;=====================================================
     28  1676				   MemInit
     29  1676		       a9 26		      lda	#FreeMemStart&$FF
     30  1678		       8d 1c 31 	      sta	ProgramStart
     31  167b		       8d 1e 31 	      sta	ProgramEnd
     32  167e		       a9 31		      lda	#FreeMemStart>>8
     33  1680		       8d 1d 31 	      sta	ProgramStart+1
     34  1683		       8d 1f 31 	      sta	ProgramEnd+1
     35  1686
     36  1686		       20 90 16 	      jsr	GetSizes
     37  1689		       20 9b 16 	      jsr	MemFree
     38  168c		       20 b3 16 	      jsr	MemUsed
     39  168f				   MemInitEnd
     40  168f		       60		      rts
     41  1690
     42  1690
     43  1690							;
     44  1690							;=====================================================
     45  1690							; This function might go away eventually, but was
     46  1690							; added to provide data for other pieces of code.
     47  1690							; It has some ties to the operating environment that
     48  1690							; will need to be customized for the target system.
     49  1690							;
     50  1690				   GetSizes
     51  1690							;
     52  1690							; Here is machine specific code to get the highest
     53  1690							; memory location that can be used by BASIC.
     54  1690							;
     55  1690				  -	      if	ProgramStart < $2000
     56  1690				  -	      lda	#$ff
     57  1690				  -	      sta	HighMem	;$13ff for KIM-1
     58  1690				  -	      sta	MemFreeList
     59  1690				  -	      lda	#$DE	;#$13
     60  1690				  -	      sta	HighMem+1
     61  1690				  -	      sta	MemFreeList+1
     62  1690					      else
     63  1690		       a9 ff		      lda	#$ff
     64  1692		       8d 20 31 	      sta	HighMem	;$CFFF otherwise
     65  1695		       a9 cf		      lda	#$cf
     66  1697		       8d 21 31 	      sta	HighMem+1
     67  169a					      endif
     68  169a		       60		      rts
     69  169b							;
     70  169b							; This computes the available memory remaining.
     71  169b							;
     72  169b				   MemFree
     73  169b		       38		      sec
     74  169c		       ad 20 31 	      lda	HighMem
     75  169f		       ed 1e 31 	      sbc	ProgramEnd
     76  16a2		       8d 24 31 	      sta	FreeMem
     77  16a5		       85 52		      sta	R0
     78  16a7		       ad 21 31 	      lda	HighMem+1
     79  16aa		       ed 1f 31 	      sbc	ProgramEnd+1
     80  16ad		       8d 25 31 	      sta	FreeMem+1
     81  16b0		       85 53		      sta	R0+1
     82  16b2		       60		      rts
     83  16b3							;
     84  16b3							; This computes the size of the current user program.
     85  16b3							;
     86  16b3				   MemUsed
     87  16b3		       38		      sec
     88  16b4		       ad 1e 31 	      lda	ProgramEnd
     89  16b7		       ed 1c 31 	      sbc	ProgramStart
     90  16ba		       8d 22 31 	      sta	UsedMem
     91  16bd		       85 52		      sta	R0
     92  16bf		       ad 1f 31 	      lda	ProgramEnd+1
     93  16c2		       ed 1d 31 	      sbc	ProgramStart+1
     94  16c5		       8d 23 31 	      sta	UsedMem+1
     95  16c8		       85 53		      sta	R0+1
     96  16ca							;
     97  16ca		       60		      rts
     98  16cb							;
     99  16cb							;=====================================================
    100  16cb							; Set a block of memory to a value
    101  16cb		       8a	   iSetBlock  txa
    102  16cc		       48		      pha
    103  16cd		       20 7a 1e 	      jsr	popR0	; the address to write to
    104  16d0		       a5 52		      lda	R0
    105  16d2		       85 59		      sta	dpl
    106  16d4		       a5 53		      lda	R0+1
    107  16d6		       85 5a		      sta	dpl+1
    108  16d8		       20 92 1e 	      jsr	popR1	; Number of bytes to write
    109  16db		       20 7a 1e 	      jsr	popR0	; Get the value to store into memory
    110  16de		       20 ef 1b 	      jsr	getILByte
    111  16e1		       85 58		      sta	R2	; store the data type into R2
    112  16e3		       c9 a1		      cmp	#tInteger
    113  16e5		       f0 08		      beq	memset	; skip this if we have an integer
    114  16e7		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    115  16e9		       a6 53		      ldx	R0+1
    116  16eb		       86 52		      stx	R0
    117  16ed		       85 53		      sta	R0+1
    118  16ef
    119  16ef				   memset
    120  16ef		       a0 00		      ldy	#0	; Set for length of block to copy
    121  16f1		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    122  16f3
    123  16f3		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    124  16f5		       c9 a2		      cmp	#tByte
    125  16f7		       f0 09		      beq	iSetBlockB
    126  16f9
    127  16f9		       a5 52	   iSetBlockW lda	R0
    128  16fb		       91 59		      sta	(dpl),y
    129  16fd		       20 10 17 	      jsr	iSetBlockEnd
    130  1700		       f0 09		      beq	iSetBlockComplete
    131  1702
    132  1702		       a5 53	   iSetBlockB lda	R0+1
    133  1704		       91 59		      sta	(dpl),y
    134  1706		       20 10 17 	      jsr	iSetBlockEnd
    135  1709		       d0 e8		      bne	iSetBlockLoop
    136  170b
    137  170b				   iSetBlockComplete
    138  170b		       68		      pla
    139  170c		       aa		      tax
    140  170d		       4c c3 02 	      jmp	NextIL
    141  1710							;
    142  1710							; Check if we have reached the end of the initialization/Copy
    143  1710							;
    144  1710		       c8	   iSetBlockEnd iny
    145  1711		       d0 03		      bne	iSetBlockEndChk
    146  1713		       e8		      inx
    147  1714		       e6 5a		      inc	dpl+1
    148  1716				   iSetBlockEndChk
    149  1716		       c4 54		      cpy	R1
    150  1718		       d0 02		      bne	iSetBlockEndExit
    151  171a		       e4 55		      cpx	R1+1
    152  171c				   iSetBlockEndExit
    153  171c		       60		      rts
    154  171d							;
    155  171d							;================================================================
    156  171d							; Copy a block of memory from one location to another
    157  171d							;
    158  171d		       8a	   iCopyBlock txa
    159  171e		       48		      pha
    160  171f		       20 7a 1e 	      jsr	popR0	; get the source address
    161  1722		       20 92 1e 	      jsr	popR1	; Destination address
    162  1725		       a5 54		      lda	R1
    163  1727		       85 59		      sta	dpl
    164  1729		       a5 55		      lda	R1+1
    165  172b		       85 5a		      sta	dpl+1
    166  172d		       20 92 1e 	      jsr	popR1	; Number of bytes to copy
    167  1730				   memcpy
    168  1730		       a2 00		      ldx	#0
    169  1732		       a0 00		      ldy	#0
    170  1734				   iCopyBlockLoop
    171  1734		       b1 52		      lda	(R0),y	;  Get the byte to copy
    172  1736		       91 59		      sta	(dpl),y	;  Store the byte
    173  1738		       c8		      iny
    174  1739		       d0 05		      bne	iCopyChkEnd
    175  173b		       e8		      inx
    176  173c		       e6 53		      inc	R0+1
    177  173e		       e6 5a		      inc	dpl+1
    178  1740		       c4 54	   iCopyChkEnd cpy	R1
    179  1742		       d0 f0		      bne	iCopyBlockLoop
    180  1744		       e4 55		      cpx	R1+1
    181  1746		       d0 ec		      bne	iCopyBlockLoop
    182  1748				   iCopyBlockDone
    183  1748		       68		      pla
    184  1749		       aa		      tax
    185  174a		       4c c3 02 	      jmp	NextIL
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  174d					      include	"gosub.asm"
      1  174d					      seg	Code
      2  174d
      3  174d							; Gosub and return related functions
      4  174d							;==========================================================
      5  174d							; Push the current math stack frame onto the gosub stack
      6  174d				   iPushMathStack
      7  174d		       98		      tya
      8  174e		       48		      pha
      9  174f		       a4 4d		      ldy	GOSUBSTACKPTR
     10  1751		       a5 4a		      lda	MATHSTACKPTR
     11  1753		       91 4b		      sta	(GOSUBSTACK),y
     12  1755		       a9 00		      lda	#0
     13  1757		       c8		      iny
     14  1758		       91 4b		      sta	(GOSUBSTACK),y
     15  175a		       c8		      iny
     16  175b		       91 4b		      sta	(GOSUBSTACK),y
     17  175d		       c8		      iny
     18  175e		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  1760		       91 4b		      sta	(GOSUBSTACK),y
     20  1762		       c8		      iny
     21  1763		       84 4d		      sty	GOSUBSTACKPTR
     22  1765		       68		      pla
     23  1766		       a8		      tay
     24  1767		       4c c3 02 	      jmp	NextIL
     25  176a							;
     26  176a							;==========================================================
     27  176a							; Increment parameter count. Assume Stack frame is top of stack
     28  176a				   iIncParmCount
     29  176a		       98		      tya
     30  176b		       48		      pha
     31  176c		       a4 4d		      ldy	GOSUBSTACKPTR
     32  176e		       88		      dey
     33  176f		       88		      dey
     34  1770		       88		      dey
     35  1771		       b1 4b		      lda	(GOSUBSTACK),y
     36  1773		       aa		      tax
     37  1774		       e8		      inx
     38  1775		       8a		      txa
     39  1776		       91 4b		      sta	(GOSUBSTACK),y
     40  1778		       68		      pla
     41  1779		       a8		      tay
     42  177a		       4c c3 02 	      jmp	NextIL
     43  177d							;
     44  177d							;==========================================================
     45  177d							;Restore the math stack frame
     46  177d		       20 83 17    iPopMathStack jsr	PopMathStackNow
     47  1780		       4c c3 02 	      jmp	NextIL
     48  1783
     49  1783				   PopMathStackNow
     50  1783		       98		      tya
     51  1784		       48		      pha
     52  1785
     53  1785		       a4 4d		      ldy	GOSUBSTACKPTR
     54  1787		       88		      dey
     55  1788		       b1 4b		      lda	(GOSUBSTACK),y
     56  178a		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  178c		       d0 09		      bne	iPopMathStackNoFrame
     58  178e		       88		      dey
     59  178f		       88		      dey
     60  1790		       88		      dey
     61  1791		       b1 4b		      lda	(GOSUBSTACK),y
     62  1793		       85 4a		      sta	MATHSTACKPTR
     63  1795		       84 4d		      sty	GOSUBSTACKPTR
     64  1797
     65  1797				   iPopMathStackNoFrame
     66  1797
     67  1797		       68		      pla
     68  1798		       a8		      tay
     69  1799		       60		      rts
     70  179a
     71  179a
     72  179a							;==========================================================
     73  179a							; Push the current math stack information onto the gosub stack
     74  179a				   iSaveMathStack
     75  179a		       98		      tya
     76  179b		       48		      pha
     77  179c		       a4 4d		      ldy	GOSUBSTACKPTR
     78  179e		       a5 4a		      lda	MATHSTACKPTR
     79  17a0		       91 4b		      sta	(GOSUBSTACK),y
     80  17a2		       a5 48		      lda	MATHSTACK
     81  17a4		       c8		      iny
     82  17a5
     83  17a5		       91 4b		      sta	(GOSUBSTACK),y
     84  17a7		       c8		      iny
     85  17a8
     86  17a8		       a5 49		      lda	MATHSTACK+1
     87  17aa		       91 4b		      sta	(GOSUBSTACK),y
     88  17ac		       c8		      iny
     89  17ad
     90  17ad		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  17af		       91 4b		      sta	(GOSUBSTACK),y
     92  17b1		       c8		      iny
     93  17b2
     94  17b2		       84 4d		      sty	GOSUBSTACKPTR
     95  17b4		       68		      pla
     96  17b5		       a8		      tay
     97  17b6		       4c c3 02 	      jmp	NextIL
     98  17b9							;
     99  17b9							;==========================================================
    100  17b9							;Restore the math stack information from the gosub stack
    101  17b9				   iRestoreMathStack
    102  17b9		       98		      tya
    103  17ba		       48		      pha
    104  17bb
    105  17bb		       a5 4a		      lda	MATHSTACKPTR
    106  17bd		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  17bf
    108  17bf		       a4 4d		      ldy	GOSUBSTACKPTR
    109  17c1		       88		      dey
    110  17c2		       b1 4b		      lda	(GOSUBSTACK),y
    111  17c4		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  17c6		       d0 16		      bne	iPopMathStack_Err
    113  17c8		       88		      dey
    114  17c9		       b1 4b		      lda	(GOSUBSTACK),y
    115  17cb		       85 49		      sta	MATHSTACK+1
    116  17cd		       88		      dey
    117  17ce		       b1 4b		      lda	(GOSUBSTACK),y
    118  17d0		       85 48		      sta	MATHSTACK
    119  17d2		       88		      dey
    120  17d3		       b1 4b		      lda	(GOSUBSTACK),y
    121  17d5		       85 4a		      sta	MATHSTACKPTR
    122  17d7		       84 4d		      sty	GOSUBSTACKPTR
    123  17d9		       68		      pla
    124  17da		       a8		      tay
    125  17db		       4c c3 02 	      jmp	NextIL
    126  17de
    127  17de				   iPopMathStack_Err
    128  17de		       a9 00		      lda	#0
    129  17e0		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  17e2		       4c b0 06 	      jmp	iErr2
    131  17e5							;=========================================
    132  17e5							; For functions and tasks the variable address of # means
    133  17e5							; a passed parameter so #[0] is the first parameter etc
    134  17e5							; will try for a better way later
    135  17e5
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  17e5					      include	"tasks.asm"
      1  17e5							;=====================================================
      2  17e5							; Tiny Basic IL task management
      3  17e5							; Data required by task management
      4  17e5							; currently each context is about 30 bytes and is swapped
      5  17e5							; into and out of page zero on each task switch....
      6  17e5							; LOL yes it is slow, but works for this iteration.
      7  17e5							;
      8  17e5
      9  17e5					      Seg	Code
     10  17e5							;=====================================================
     11  17e5							; Sets the pointers to the math,IL and gosub stacks
     12  17e5							; Creates the initial Context for each task slot
     13  17e5				   taskSetStacks
     14  17e5		       a9 c3		      lda	#mathStack&$FF
     15  17e7		       85 48		      sta	MATHSTACK
     16  17e9		       a9 28		      lda	#mathStack>>8
     17  17eb		       85 49		      sta	MATHSTACK+1
     18  17ed
     19  17ed		       a9 53		      lda	#ilStack&$ff
     20  17ef		       85 45		      sta	ILSTACK
     21  17f1		       a9 2a		      lda	#ilStack>>8
     22  17f3		       85 46		      sta	ILSTACK+1
     23  17f5
     24  17f5		       a9 e3		      lda	#gosubStack&$FF
     25  17f7		       85 4b		      sta	GOSUBSTACK
     26  17f9		       a9 2b		      lda	#gosubStack>>8
     27  17fb		       85 4c		      sta	GOSUBSTACK+1
     28  17fd
     29  17fd		       a9 63		      lda	#variableStack&$FF
     30  17ff		       85 41		      sta	VARIABLES
     31  1801		       a9 2e		      lda	#variableStack>>8
     32  1803		       85 42		      sta	VARIABLES+1
     33  1805		       a2 0a		      ldx	#TASKCOUNT
     34  1807		       a0 00		      ldy	#0
     35  1809		       20 a6 1a 	      jsr	ContextSave
     36  180c
     37  180c		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  180e		       b0 3a		      bcs	taskSetDone
     39  1810
     40  1810		       a5 4b		      lda	GOSUBSTACK
     41  1812		       18		      clc
     42  1813		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  1815		       85 4b		      sta	GOSUBSTACK
     44  1817		       a5 4c		      lda	GOSUBSTACK+1
     45  1819		       69 00		      adc	#0
     46  181b		       85 4c		      sta	GOSUBSTACK+1
     47  181d
     48  181d		       a5 45		      lda	ILSTACK	; must be less than 256
     49  181f		       18		      clc
     50  1820		       69 28		      adc	#ILSTACKSIZE*2
     51  1822		       85 45		      sta	ILSTACK
     52  1824		       a5 46		      lda	ILSTACK+1
     53  1826		       69 00		      adc	#0
     54  1828		       85 46		      sta	ILSTACK+1
     55  182a
     56  182a		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  182c		       18		      clc
     58  182d		       69 28		      adc	#MATHSTACKSIZE*2
     59  182f		       85 48		      sta	MATHSTACK
     60  1831		       a5 49		      lda	MATHSTACK+1
     61  1833		       69 00		      adc	#0
     62  1835		       85 49		      sta	MATHSTACK+1
     63  1837
     64  1837		       a5 41		      lda	VARIABLES	; must be less than 256
     65  1839		       18		      clc
     66  183a		       69 36		      adc	#VARIABLESSIZE*2
     67  183c		       85 41		      sta	VARIABLES
     68  183e		       a5 42		      lda	VARIABLES+1
     69  1840		       69 00		      adc	#0
     70  1842		       85 42		      sta	VARIABLES+1
     71  1844
     72  1844		       20 a6 1a 	      jsr	ContextSave
     73  1847		       4c 0c 18 	      jmp	taskSetLoop
     74  184a
     75  184a				   taskSetDone
     76  184a		       a0 00		      ldy	#0	; reload the main loop context
     77  184c		       20 b5 1a 	      jsr	ContextLoad
     78  184f		       60		      rts
     79  1850							;
     80  1850							;=====================================================
     81  1850							; In some error cases the math stacks may be left pointing to the wrong stack
     82  1850							; This function will reset those stack addresses but not the actual pointer
     83  1850				   taskResetStacks
     84  1850		       a0 00		      ldy	#0
     85  1852		       20 b5 1a 	      jsr	ContextLoad
     86  1855		       4c e5 17 	      jmp	taskSetStacks
     87  1858							;
     88  1858							;=====================================================
     89  1858							; Clear all task entries and task stacks
     90  1858		       98	   taskReset  tya		; Save Y
     91  1859		       48		      pha
     92  185a		       a9 01		      lda	#1
     93  185c		       8d c2 28 	      sta	taskCounter	; Set number of active tasks to 1
     94  185f		       ac c3 27 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  1862		       c0 00		      cpy	#0	; check if we are the main context
     96  1864		       f0 08		      beq	taskResetCont	; if we are just continue
     97  1866
     98  1866		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  1868		       8c c3 27 	      sty	taskPtr
    100  186b		       20 b5 1a 	      jsr	ContextLoad	; load the System Task context
    101  186e				   taskResetCont
    102  186e		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    103  1870
    104  1870				   taskResetLoop
    105  1870		       a9 00		      lda	#TASKINACTIVE
    106  1872		       99 c4 27 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  1875		       18		      clc
    108  1876		       98		      tya
    109  1877		       69 19		      adc	#CONTEXTLEN
    110  1879		       a8		      tay
    111  187a		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  187c		       90 f2		      bcc	taskResetLoop	; Go for more
    113  187e
    114  187e				   taskResetComplete
    115  187e
    116  187e		       68		      pla		; Restore y
    117  187f		       a8		      tay
    118  1880		       60		      rts
    119  1881
    120  1881							;
    121  1881							;======================================================
    122  1881							; iTaskSwitch	 switch to new task if not interrupt and
    123  1881							;		 count is exceded for task time slice gets here
    124  1881							;		 when time slice has reached zero
    125  1881							;
    126  1881		       98	   iTaskSwitch tya
    127  1882		       48		      pha
    128  1883
    129  1883		       ad c0 28 	      lda	taskResetValue	; Always reset the counter value
    130  1886		       8d be 28 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  1889		       ce bf 28 	      dec	taskCurrentCycles+1	; dec high order byte
    132  188c		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  188e
    134  188e		       ad c1 28 	      lda	taskResetValue+1
    135  1891		       8d bf 28 	      sta	taskCurrentCycles+1
    136  1894
    137  1894		       ad c0 27 	      lda	IRQPending	; Skip this if we are processing an irq
    138  1897		       0d 1a 31 	      ora	taskIOPending	; If set then don't switch
    139  189a		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  189c
    141  189c		       ad c2 28    iTaskMain  lda	taskCounter	; Number of tasks
    142  189f		       c9 01		      cmp	#1	; if there is only one task must be main
    143  18a1		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  18a3
    145  18a3		       ac c3 27 	      ldy	taskPtr	; check if we have not just ended some other task
    146  18a6		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  18a8		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  18aa							;
    149  18aa							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  18aa							;
    151  18aa				   itasknext
    152  18aa		       ac c3 27 	      ldy	taskPtr
    153  18ad		       20 a6 1a 	      jsr	ContextSave	; Save the current context, y points to next context
    154  18b0				   itaskLoop
    155  18b0		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  18b2		       90 04		      bcc	iTaskNextChk
    157  18b4
    158  18b4		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  18b6		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  18b8
    161  18b8				   iTaskNextChk
    162  18b8		       b9 c4 27 	      lda	taskTable,y	; there is always at least one entry in table
    163  18bb		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  18bd		       18	   iTaskNext  clc
    165  18be		       98		      tya
    166  18bf		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    167  18c1		       a8		      tay
    168  18c2		       4c b0 18 	      jmp	itaskLoop	; Check for busy entry
    169  18c5
    170  18c5		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  18c7		       59 c4 27 	      eor	taskTable,y	; Check for anything waiting io
    172  18ca		       d0 f1		      bne	iTaskNext
    173  18cc		       20 b5 1a 	      jsr	ContextLoad	; load the next context
    174  18cf		       8c c3 27 	      sty	taskPtr	; update the task pointer
    175  18d2
    176  18d2				   iTaskSwitchDone
    177  18d2		       68		      pla
    178  18d3		       a8		      tay
    179  18d4		       60		      rts
    180  18d5							;
    181  18d5							;================================================================
    182  18d5							; Task Set task number to line number to start
    183  18d5							; on entry stack contains, type of line description and  memvector or linenumber
    184  18d5							; Task Table structure:
    185  18d5							;    byte 0	-   Active inactive
    186  18d5							;    byte 1-2	-   Basic code line pointer
    187  18d5							;    byte 3	-   Offset on current line
    188  18d5		       98	   iTaskSet   tya		;preserve Y
    189  18d6		       48		      pha		; push a
    190  18d7		       20 92 1e 	      jsr	popR1	; Get if compiled or line number expression
    191  18da		       20 7a 1e 	      jsr	popR0	; Get the line number to be saved
    192  18dd
    193  18dd
    194  18dd
    195  18dd		       ac c3 27 	      ldy	taskPtr	; find out where we are
    196  18e0		       20 a6 1a 	      jsr	ContextSave	; Save the current context
    197  18e3
    198  18e3							;Find the pointer to the line we need to start at
    199  18e3		       a5 54		      lda	R1
    200  18e5		       f0 0b		      beq	iTaskLineNum
    201  18e7		       a5 52		      lda	R0
    202  18e9		       85 4f		      sta	CURPTR
    203  18eb		       a5 53		      lda	R0+1
    204  18ed		       85 50		      sta	CURPTR+1
    205  18ef		       4c 02 19 	      jmp	iTaskCont
    206  18f2
    207  18f2				   iTaskLineNum
    208  18f2		       20 34 1c 	      jsr	findLine	; Get the offset of the line to start task at
    209  18f5		       f0 0b		      beq	iTaskCont
    210  18f7
    211  18f7		       ac c3 27 	      ldy	taskPtr	; Restore the original Context Error Exit
    212  18fa		       20 b5 1a 	      jsr	ContextLoad
    213  18fd
    214  18fd		       68		      pla		; pop a - exit
    215  18fe		       a8		      tay
    216  18ff		       4c a7 0d 	      jmp	iSetIrqErr	; Bad line number provided
    217  1902
    218  1902				   iTaskCont
    219  1902		       20 78 1a 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    220  1905		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    221  1907
    222  1907		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    223  1909		       99 c4 27 	      sta	taskTable,y	; new task as active
    224  190c
    225  190c		       a5 4f		      lda	CURPTR
    226  190e		       48		      pha		; push a
    227  190f		       a5 50		      lda	CURPTR+1
    228  1911		       48		      pha		; push a
    229  1912
    230  1912		       20 b5 1a 	      jsr	ContextLoad	; load the context of the new task
    231  1915
    232  1915		       68		      pla		; pop a
    233  1916		       85 50		      sta	CURPTR+1
    234  1918		       68		      pla		; pop a
    235  1919		       85 4f		      sta	CURPTR
    236  191b		       a9 03		      lda	#3	; Offset to first instruction
    237  191d		       85 51		      sta	CUROFF
    238  191f
    239  191f		       a9 00		      lda	#0
    240  1921		       85 47		      sta	ILSTACKPTR
    241  1923		       85 4a		      sta	MATHSTACKPTR
    242  1925		       85 4d		      sta	GOSUBSTACKPTR
    243  1927		       a9 40		      lda	#GOSUBSTACKSIZE*4
    244  1929		       85 4e		      sta	MESSAGEPTR
    245  192b
    246  192b		       20 82 09 	      jsr	subVINIT	; Clear the variables
    247  192e
    248  192e		       a9 75		      lda	#STMT&$FF
    249  1930		       85 43		      sta	ILPC
    250  1932		       a9 23		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    251  1934		       85 44		      sta	ILPC+1
    252  1936
    253  1936		       98		      tya		; Save the new context offset to return to user
    254  1937		       48		      pha		; push a
    255  1938
    256  1938		       20 a6 1a    itaskSetSave jsr	ContextSave	; save the updated context
    257  193b		       ee c2 28 	      inc	taskCounter	; Update the number of Tasks running
    258  193e
    259  193e		       ac c3 27 	      ldy	taskPtr
    260  1941		       20 b5 1a 	      jsr	ContextLoad	; restore the original context
    261  1944
    262  1944		       a9 00		      lda	#0	; Set the R0 upper to zero
    263  1946		       85 53		      sta	R0+1
    264  1948		       68		      pla		; Get the task pid we stored				 ; pop a
    265  1949		       85 52		      sta	R0	; Get the table entry value
    266  194b
    267  194b		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    268  194c		       a8		      tay
    269  194d
    270  194d		       4c 49 07 	      jmp	pushR0nextIl	; Push R0 and continue
    271  1950				   iTaskNoEmpty
    272  1950		       ac c3 27 	      ldy	taskPtr
    273  1953		       20 b5 1a 	      jsr	ContextLoad
    274  1956
    275  1956		       68		      pla		; pop a    -- exit
    276  1957		       a8		      tay
    277  1958
    278  1958		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    279  195a		       a9 00		      lda	#0
    280  195c		       4c b0 06 	      jmp	iErr2
    281  195f							;
    282  195f							;===============================================================
    283  195f							; Run the task whos PID is on the stack, preserve the stack
    284  195f							;
    285  195f				   iTaskEnable
    286  195f		       98		      tya
    287  1960		       48		      pha
    288  1961		       20 92 1e 	      jsr	popR1
    289  1964		       20 60 1e 	      jsr	pushR1
    290  1967		       20 ac 1b 	      jsr	ipc_getcontext	; get context pointer into mq
    291  196a		       a0 00		      ldy	#0
    292  196c		       b1 56		      lda	(MQ),y
    293  196e		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    294  1970		       09 80		      ora	#TASKACTIVE
    295  1972		       91 56		      sta	(MQ),y
    296  1974		       68		      pla
    297  1975		       a8		      tay
    298  1976		       4c c3 02 	      jmp	NextIL
    299  1979
    300  1979							;
    301  1979							;===============================================================
    302  1979							; Suspend the task whos PID  is on the stack, preserve the stack
    303  1979							;
    304  1979				   iTaskSuspend
    305  1979		       98		      tya
    306  197a		       48		      pha
    307  197b		       20 92 1e 	      jsr	popR1
    308  197e		       20 60 1e 	      jsr	pushR1
    309  1981		       20 ac 1b 	      jsr	ipc_getcontext	; get context pointer into mq
    310  1984		       a0 00		      ldy	#0
    311  1986		       b1 56		      lda	(MQ),y
    312  1988		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    313  198a		       09 80		      ora	#TASKACTIVE
    314  198c		       68		      pla
    315  198d		       a8		      tay
    316  198e		       4c c3 02 	      jmp	NextIL
    317  1991
    318  1991							;================================================================
    319  1991							; Returns task Status
    320  1991				   iTaskStat
    321  1991		       98		      tya
    322  1992		       48		      pha
    323  1993		       20 a5 19 	      jsr	iTaskValid	; returns pointer to task entry
    324  1996		       b9 c4 27 	      lda	taskTable,y
    325  1999		       f0 05		      beq	iTaskStatExit
    326  199b		       68		      pla
    327  199c		       a8		      tay
    328  199d		       4c 61 0d 	      jmp	iTruth
    329  19a0				   iTaskStatExit
    330  19a0		       68		      pla
    331  19a1		       a8		      tay
    332  19a2		       4c 6a 0d 	      jmp	iFalse
    333  19a5
    334  19a5							;
    335  19a5							;================================================================
    336  19a5							; Validate the task number on top of the stack
    337  19a5							; on exit y points to the requested task entry
    338  19a5							;
    339  19a5		       20 7a 1e    iTaskValid jsr	popR0	; get result of the multiply
    340  19a8		       a5 53		      lda	R0+1
    341  19aa		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    342  19ac		       a5 52		      lda	R0
    343  19ae		       c9 fa		      cmp	#TASKTABLELEN
    344  19b0		       90 09		      bcc	iTaskIsValid
    345  19b2
    346  19b2		       68	   iTaskValidErr pla		;remove return address
    347  19b3		       68		      pla
    348  19b4		       a2 10		      ldx	#ERR_INVALID_PID
    349  19b6		       a9 00		      lda	#0
    350  19b8		       4c b0 06 	      jmp	iErr2
    351  19bb
    352  19bb		       a8	   iTaskIsValid tay
    353  19bc		       60		      rts
    354  19bd							;
    355  19bd							;================================================================
    356  19bd							; Kill a running task, do nothing if already stopped
    357  19bd		       20 a5 19    iTaskKill  jsr	iTaskValid
    358  19c0		       a9 00		      lda	#0
    359  19c2		       99 c4 27 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    360  19c5							;
    361  19c5							;================================================================
    362  19c5							;Skip to next task
    363  19c5				   iNTask
    364  19c5		       a9 01		      lda	#1
    365  19c7		       8d be 28 	      sta	taskCurrentCycles
    366  19ca		       8d bf 28 	      sta	taskCurrentCycles+1
    367  19cd		       4c c3 02 	      jmp	NextIL
    368  19d0							;
    369  19d0							;=======================================================
    370  19d0							; Wait for a task to complete
    371  19d0				   iWTASK
    372  19d0		       20 ef 1b 	      jsr	getILByte
    373  19d3		       8d 18 31 	      sta	offset
    374  19d6							;
    375  19d6		       20 d2 1d 	      jsr	saveIL	;in case of failure
    376  19d9
    377  19d9		       20 a5 19 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    378  19dc		       b9 c4 27 	      lda	taskTable,y
    379  19df		       d0 03		      bne	iWTASKWAIT
    380  19e1				   iWTASKEXITED
    381  19e1		       4c c3 02 	      jmp	NextIL
    382  19e4				   iWTASKWAIT
    383  19e4		       20 e8 1d 	      jsr	pushR0	; Push R0 back onto the stack
    384  19e7		       a9 01		      lda	#1
    385  19e9		       8d be 28 	      sta	taskCurrentCycles	; Give up the cycles
    386  19ec		       8d bf 28 	      sta	taskCurrentCycles+1
    387  19ef		       20 dd 1d 	      jsr	restoreIL
    388  19f2		       4c c3 0b 	      jmp	tstBranch
    389  19f5							;
    390  19f5							;=======================================================
    391  19f5							; Set task io lock
    392  19f5		       ee 1a 31    iStartIO   inc	taskIOPending
    393  19f8		       4c c3 02 	      jmp	NextIL
    394  19fb							;
    395  19fb							;=======================================================
    396  19fb							; Release the io lock
    397  19fb		       ad 1a 31    iEndIO     lda	taskIOPending
    398  19fe		       f0 03		      beq	iEndIOExit
    399  1a00		       ce 1a 31 	      dec	taskIOPending
    400  1a03		       4c c3 02    iEndIOExit jmp	NextIL
    401  1a06							;
    402  1a06							;===============================================================
    403  1a06							; Return the task PID
    404  1a06				   iTASKPID
    405  1a06		       a9 00		      lda	#0
    406  1a08		       85 53		      sta	R0+1
    407  1a0a		       ad c3 27 	      lda	taskPtr
    408  1a0d		       85 52		      sta	R0
    409  1a0f		       4c 49 07 	      jmp	pushR0nextIl
    410  1a12							;
    411  1a12							;================================================================
    412  1a12							; Terminate a task
    413  1a12		       ac c3 27    iETask     ldy	taskPtr
    414  1a15		       c0 00		      cpy	#0
    415  1a17		       d0 03		      bne	iETaskCont
    416  1a19		       4c 3d 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    417  1a1c				   iETaskCont
    418  1a1c		       a9 00		      lda	#TASKINACTIVE
    419  1a1e		       99 c4 27 	      sta	taskTable,y	; mark entry as free
    420  1a21		       ce c2 28 	      dec	taskCounter	; reduce the number of active tasks
    421  1a24		       a9 01		      lda	#1
    422  1a26		       8d be 28 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    423  1a29		       8d bf 28 	      sta	taskCurrentCycles+1
    424  1a2c		       20 93 1a 	      jsr	TaskSetExitCode
    425  1a2f				   iETaskExit
    426  1a2f		       4c c3 02 	      jmp	NextIL
    427  1a32							;================================================================
    428  1a32							; make the current tasks math stack equal another tasks stack
    429  1a32							; The task to get is stored on the math stack
    430  1a32
    431  1a32				   iTaskGetMathStack
    432  1a32		       20 a0 20 	      jsr	CopyStackR1	; Get the top of stack to R1
    433  1a35		       20 ac 1b 	      jsr	ipc_getcontext	; MQ now has the context address
    434  1a38		       a0 0a		      ldy	#MATHSTACKPTRPOS
    435  1a3a		       b1 56		      lda	(MQ),y
    436  1a3c		       85 4a		      sta	MATHSTACKPTR
    437  1a3e		       a0 08		      ldy	#MATHSTACKPOS
    438  1a40		       b1 56		      lda	(MQ),y
    439  1a42		       85 48		      sta	MATHSTACK
    440  1a44		       c8		      iny
    441  1a45		       b1 56		      lda	(MQ),y
    442  1a47		       85 49		      sta	MATHSTACK+1
    443  1a49		       4c c3 02 	      jmp	NextIL
    444  1a4c							;==================================================================
    445  1a4c							; Updates the tasks math stack pointer with contents of R2
    446  1a4c							; PID is on top of the stack
    447  1a4c				   iTaskPutMathPtr
    448  1a4c		       20 a0 20 	      jsr	CopyStackR1	; Get the top of stack to R1
    449  1a4f		       20 ac 1b 	      jsr	ipc_getcontext	; MQ now has the context address
    450  1a52		       a5 58		      lda	R2
    451  1a54		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  1a56		       91 56		      sta	(MQ),y
    453  1a58		       4c c3 02 	      jmp	NextIL
    454  1a5b							;
    455  1a5b							;================================================================
    456  1a5b							; Set the time slice for each task
    457  1a5b				   iSLICE
    458  1a5b		       20 7a 1e 	      jsr	popR0
    459  1a5e		       a5 52		      lda	R0
    460  1a60		       8d c0 28 	      sta	taskResetValue
    461  1a63		       a5 53		      lda	R0+1
    462  1a65		       8d c1 28 	      sta	taskResetValue+1
    463  1a68		       d0 0b		      bne	iSliceSet
    464  1a6a		       ee c1 28 	      inc	taskResetValue+1	; must be at least 1 high counter
    465  1a6d		       a9 01		      lda	#1
    466  1a6f		       8d be 28 	      sta	taskCurrentCycles
    467  1a72		       8d bf 28 	      sta	taskCurrentCycles+1
    468  1a75				   iSliceSet
    469  1a75		       4c c3 02 	      jmp	NextIL
    470  1a78							;================================================================
    471  1a78							; Find an empty slot in the taskTable
    472  1a78							; Return the index in y
    473  1a78							; on exit   c set if an empty slot is found
    474  1a78							;	     c clear if not found
    475  1a78							;================================================================
    476  1a78							;
    477  1a78		       ad c2 28    TaskEmpty  lda	taskCounter
    478  1a7b		       c9 0a		      cmp	#TASKCOUNT
    479  1a7d		       b0 10		      bcs	TaskNoSlot
    480  1a7f		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    481  1a81				   TaskLoop
    482  1a81		       b9 c4 27 	      lda	taskTable,y
    483  1a84		       f0 0b		      beq	TaskEmptyFnd
    484  1a86		       98		      tya
    485  1a87		       18		      clc
    486  1a88		       69 19		      adc	#CONTEXTLEN
    487  1a8a		       a8		      tay
    488  1a8b		       c0 fa		      cpy	#TASKTABLELEN
    489  1a8d		       90 f2		      bcc	TaskLoop	; Y is never zero
    490  1a8f				   TaskNoSlot
    491  1a8f		       18		      clc
    492  1a90		       60		      rts
    493  1a91				   TaskEmptyFnd
    494  1a91		       38		      sec
    495  1a92		       60		      rts
    496  1a93							;====================================================
    497  1a93							; Set the task exit code called from the return command
    498  1a93							; on entry stack top hold exit value
    499  1a93				   TaskSetExitCode
    500  1a93		       98		      tya
    501  1a94		       48		      pha
    502  1a95		       20 7a 1e 	      jsr	popR0
    503  1a98		       a0 34		      ldy	#TASKEXITCODE
    504  1a9a		       a5 52		      lda	R0
    505  1a9c		       91 41		      sta	(VARIABLES),y
    506  1a9e		       c8		      iny
    507  1a9f		       a5 53		      lda	R0+1
    508  1aa1		       91 41		      sta	(VARIABLES),y
    509  1aa3		       68		      pla
    510  1aa4		       98		      tya
    511  1aa5		       60		      rts
    512  1aa6
    513  1aa6							;
    514  1aa6							;=====================================================
    515  1aa6							; Save Context Store the context to the TASK Table
    516  1aa6							; on entry y contains the task table entry to save to
    517  1aa6							; on exit y points to next task table entry
    518  1aa6							;	   x contains the number of bytes copied
    519  1aa6		       a2 00	   ContextSave ldx	#0
    520  1aa8		       c8		      iny		;inc past the task flags
    521  1aa9		       b5 41	   ContextSvLoop lda	CONTEXT,x
    522  1aab		       99 c4 27 	      sta	taskTable,y
    523  1aae		       c8		      iny
    524  1aaf		       e8		      inx
    525  1ab0		       e0 18		      cpx	#[CONTEXTLEN-1]
    526  1ab2		       90 f5		      bcc	ContextSvLoop
    527  1ab4		       60		      rts
    528  1ab5							;
    529  1ab5							; Load Context transfer context from task table to the Current Context
    530  1ab5							; on entry y contains the task table entry to transfer
    531  1ab5							; on exit y points to the original task table entry
    532  1ab5							;	   x contains the number of byts copied
    533  1ab5		       98	   ContextLoad tya
    534  1ab6		       48		      pha
    535  1ab7		       a2 00		      ldx	#0
    536  1ab9		       c8		      iny		;inc past the task flags
    537  1aba		       b9 c4 27    ContextLDLoop lda	taskTable,y
    538  1abd		       95 41		      sta	CONTEXT,x
    539  1abf		       c8		      iny
    540  1ac0		       e8		      inx
    541  1ac1		       e0 18		      cpx	#[CONTEXTLEN-1]
    542  1ac3		       90 f5		      bcc	ContextLDLoop
    543  1ac5		       68		      pla
    544  1ac6		       a8		      tay
    545  1ac7		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  1ac8					      include	"ipc.asm"
      1  1ac8							;======================================================
      2  1ac8							; Inter process communications.
      3  1ac8							; Tasks may write/read integer messages among
      4  1ac8							; them selves.
      5  1ac8							; This uses each tasks gosub stack as a message queue
      6  1ac8							; Gosub calls start at the highest address and the
      7  1ac8							; msg queue starts at the highest address.
      8  1ac8							;
      9  1ac8							;======================================================
     10  1ac8							; ipcs   - Send msg to another task or many tasks
     11  1ac8							; on entry  math stack contains the  top PID
     12  1ac8							;				      2ND Message value
     13  1ac8							; on exit   math stack contain top True-good or False-failed
     14  1ac8							;
     15  1ac8							; it may not be sent if queue is full
     16  1ac8							;
     17  1ac8							; a = ipcs(<message-expression>,<task PID-expression>)
     18  1ac8							;
     19  1ac8				   iIPCS
     20  1ac8		       98		      tya
     21  1ac9		       48		      pha
     22  1aca		       20 31 1b 	      jsr	ipc_enqueue
     23  1acd		       b0 08		      bcs	iIPC_BAD
     24  1acf		       20 92 20 	      jsr	pushTrue
     25  1ad2		       68		      pla
     26  1ad3		       a8		      tay
     27  1ad4		       4c c3 02 	      jmp	NextIL
     28  1ad7				   iIPC_BAD
     29  1ad7		       68		      pla
     30  1ad8		       a8		      tay
     31  1ad9		       20 9c 20 	      jsr	pushFalse
     32  1adc		       4c c3 02 	      jmp	NextIL
     33  1adf
     34  1adf							;======================================================
     35  1adf							; ipcr   - Recieve msg from task
     36  1adf							; on exit  the message value is returned from message queue
     37  1adf							;	    message -1	is reserved meaning no entry found
     38  1adf							; The provided variable contains the pid of the sending
     39  1adf							; task. This is optional. This always waits for a message
     40  1adf							; before returning.
     41  1adf							;
     42  1adf							; a = ipcr(<variable name>)
     43  1adf							;
     44  1adf				   iIPCR
     45  1adf		       98		      tya
     46  1ae0		       48		      pha
     47  1ae1		       20 73 1b 	      jsr	ipc_dequeue
     48  1ae4		       b0 05		      bcs	iIPCR_Q_Empty
     49  1ae6		       68		      pla
     50  1ae7		       a8		      tay
     51  1ae8		       4c c3 02 	      jmp	NextIL
     52  1aeb				   iIPCR_Q_Empty
     53  1aeb		       68		      pla
     54  1aec		       a8		      tay
     55  1aed		       20 92 20 	      jsr	pushTrue	; puts -1 on the stack
     56  1af0		       4c c3 02 	      jmp	NextIL
     57  1af3
     58  1af3							;=======================================================
     59  1af3							; ipcc   - Check if message available
     60  1af3							; on exit  Stack contains number of messages
     61  1af3							;
     62  1af3							; a = ipcc()
     63  1af3							;
     64  1af3				   iIPCC
     65  1af3		       98		      tya
     66  1af4		       48		      pha
     67  1af5		       20 1e 1b 	      jsr	ipc_queue_count
     68  1af8		       20 e8 1d 	      jsr	pushR0	; return the count
     69  1afb		       68		      pla
     70  1afc		       a8		      tay
     71  1afd		       4c c3 02 	      jmp	NextIL
     72  1b00
     73  1b00							;=======================================================
     74  1b00							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  1b00				   iIPCIO
     76  1b00		       98		      tya
     77  1b01		       48		      pha
     78  1b02		       20 1e 1b 	      jsr	ipc_queue_count
     79  1b05		       a5 52		      lda	R0
     80  1b07		       d0 10		      bne	iIPCIO_No_Halt
     81  1b09		       a9 01		      lda	#1
     82  1b0b		       8d be 28 	      sta	taskCurrentCycles	; force a task switch
     83  1b0e		       a9 01		      lda	#TASKWAITIPC
     84  1b10		       ac c3 27 	      ldy	taskPtr
     85  1b13		       19 c4 27 	      ora	taskTable,y
     86  1b16		       99 c4 27 	      sta	taskTable,y
     87  1b19
     88  1b19				   iIPCIO_No_Halt
     89  1b19		       68		      pla
     90  1b1a		       a8		      tay
     91  1b1b		       4c c3 02 	      jmp	NextIL
     92  1b1e							;======================================================
     93  1b1e							;ipc_queue_count
     94  1b1e				   ipc_queue_count
     95  1b1e		       a5 4e		      lda	MESSAGEPTR
     96  1b20		       18		      clc
     97  1b21		       4a		      lsr		; divide by 4
     98  1b22		       4a		      lsr
     99  1b23		       85 52		      sta	R0	; store into R0
    100  1b25		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1b27		       38		      sec
    102  1b28		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1b2a		       85 52		      sta	R0
    104  1b2c		       a9 00		      lda	#0
    105  1b2e		       85 53		      sta	R0+1
    106  1b30		       60		      rts
    107  1b31							;=======================================================
    108  1b31							; Support functions for messaging
    109  1b31							;
    110  1b31							; Enqueue message -> onto PID's MSG Q
    111  1b31							; on entry top of stack contains the PID
    112  1b31							;	    second contains the Message of the task
    113  1b31							; on exit contains c set if failed
    114  1b31							;		    c cleared if success
    115  1b31							;		    PID's MSG Q PTR points to the message
    116  1b31							;
    117  1b31				   ipc_enqueue
    118  1b31		       20 92 1e 	      jsr	popR1	; Get the pid
    119  1b34		       20 ac 1b 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1b37
    121  1b37		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1b39		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1b3b		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1b3d		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1b3f		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1b41
    127  1b41
    128  1b41							; Get the PID'S stack address into R0
    129  1b41		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1b43		       b1 56		      lda	(MQ),y
    131  1b45		       85 52		      sta	R0
    132  1b47		       c8		      iny
    133  1b48		       b1 56		      lda	(MQ),y
    134  1b4a		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1b4c
    136  1b4c							; Set y to point to the msg q entry
    137  1b4c		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1b4e		       b1 56		      lda	(MQ),y	; Get the index
    139  1b50		       a8		      tay		; Set y to queue offset
    140  1b51
    141  1b51							; enqueue the message
    142  1b51		       88		      dey		; First byte to save to
    143  1b52		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1b54		       91 52		      sta	(R0),y	; Set the entry type
    145  1b56
    146  1b56		       88		      dey
    147  1b57		       ad c3 27 	      lda	taskPtr	; Store the PID into queue
    148  1b5a		       91 52		      sta	(R0),y
    149  1b5c		       20 92 1e 	      jsr	popR1	; Get the actual message value
    150  1b5f		       20 e0 1b 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1b62
    152  1b62		       98		      tya		; Save the new q ptr
    153  1b63		       a0 0e		      ldy	#MSGPTRPOS
    154  1b65		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1b67		       a0 00		      ldy	#0	; points to context root
    156  1b69		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1b6b		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1b6d		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1b6f		       18		      clc
    160  1b70		       60		      rts
    161  1b71				   ipc_enq_full
    162  1b71		       38		      sec
    163  1b72		       60		      rts
    164  1b73							;=============================================================
    165  1b73							; De-queue for message stack -> local tasks msg q
    166  1b73							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1b73							;  message into
    168  1b73							;  on exit   math stack contains value of message
    169  1b73							;				  Variable if provided is pid
    170  1b73				   ipc_dequeue
    171  1b73		       20 a9 1e 	      jsr	popMQ	; Variable address to put PID into
    172  1b76
    173  1b76		       a4 4e		      ldy	MESSAGEPTR
    174  1b78		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  1b7a		       b0 2e		      bcs	ipc_deq_empty
    176  1b7c		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1b7e		       85 52		      sta	R0
    178  1b80		       c8		      iny
    179  1b81		       b1 4b		      lda	(GOSUBSTACK),y
    180  1b83		       85 53		      sta	R0+1
    181  1b85		       c8		      iny
    182  1b86		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1b88		       85 54		      sta	R1
    184  1b8a		       c8		      iny
    185  1b8b		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1b8d		       c8		      iny
    187  1b8e		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1b90
    189  1b90		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1b92		       d0 16		      bne	ipc_deq_empty
    191  1b94
    192  1b94		       20 e8 1d 	      jsr	pushR0	; place value on stack
    193  1b97
    194  1b97		       a5 56		      lda	MQ
    195  1b99		       05 57		      ora	MQ+1
    196  1b9b		       f0 0b		      beq	ipc_deq_done
    197  1b9d		       a5 54		      lda	R1
    198  1b9f		       a0 00		      ldy	#0
    199  1ba1		       91 56		      sta	(MQ),y
    200  1ba3		       c8		      iny
    201  1ba4		       a9 00		      lda	#0
    202  1ba6		       91 56		      sta	(MQ),y
    203  1ba8				   ipc_deq_done
    204  1ba8		       18		      clc
    205  1ba9		       60		      rts
    206  1baa
    207  1baa				   ipc_deq_empty
    208  1baa		       38		      sec
    209  1bab		       60		      rts
    210  1bac
    211  1bac							;=============================================
    212  1bac							;  Get the context address into MQ from R1 with
    213  1bac							;  context/index/pid
    214  1bac				   ipc_getcontext
    215  1bac		       18		      clc		; Get pointer to Task context
    216  1bad		       a9 c4		      lda	#taskTable&$FF	; change ptr to address
    217  1baf		       65 54		      adc	R1
    218  1bb1		       85 56		      sta	MQ
    219  1bb3		       a9 27		      lda	#taskTable>>8
    220  1bb5		       65 55		      adc	R1+1
    221  1bb7		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1bb9		       60		      rts
    223  1bba							;
    224  1bba							;==============================================
    225  1bba							; on entry R1 has a context value,
    226  1bba							; on exit c is set if fails
    227  1bba							;
    228  1bba				   ipc_CONTEXTVALUES
      0  1bba					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  1bba		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  1bbe					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  1bbe		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  1bc2					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  1bc2		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  1bc4
    233  1bc4				   ipc_ValidateContext
    234  1bc4		       48		      pha
    235  1bc5		       8a		      txa
    236  1bc6		       48		      pha
    237  1bc7		       a5 55		      lda	R1+1
    238  1bc9		       d0 0e		      bne	ipc_Validate_Fail
    239  1bcb		       a2 00		      ldx	#0
    240  1bcd		       a5 54		      lda	R1
    241  1bcf				   ipc_ValidateLoop
    242  1bcf		       dd ba 1b 	      cmp	ipc_CONTEXTVALUES,x
    243  1bd2		       f0 09		      beq	ipc_Valid_Context
    244  1bd4		       e8		      inx
    245  1bd5		       e0 0a		      cpx	#TASKCOUNT
    246  1bd7		       90 f6		      bcc	ipc_ValidateLoop
    247  1bd9
    248  1bd9				   ipc_Validate_Fail
    249  1bd9		       68		      pla
    250  1bda		       aa		      tax
    251  1bdb		       68		      pla
      0  1bdc					      rtn
      0  1bdc					      db	25
      1  1bdc		       19		      .byte.b	25
    253  1bdd
    254  1bdd				   ipc_Valid_Context
    255  1bdd		       18		      clc
    256  1bde		       90 f9		      bcc	ipc_Validate_Fail
    257  1be0							;
    258  1be0							;==============================================
    259  1be0							;Push R1 onto the stack
    260  1be0							;on entry y = next entry
    261  1be0							;R0 points to the stack space
    262  1be0							;on exit y points to next free byte
    263  1be0				   ipc_pushR1
    264  1be0		       88		      dey
    265  1be1		       a5 55		      lda	R1+1	; PID first
    266  1be3		       91 52		      sta	(R0),y
    267  1be5		       88		      dey
    268  1be6		       a5 54		      lda	R1
    269  1be8		       91 52		      sta	(R0),y
    270  1bea		       60		      rts
    271  1beb
    272  1beb
    273  1beb
    274  1beb
    275  1beb
    276  1beb
    277  1beb
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1beb					      include	"support.asm"
      1  1beb							;
      2  1beb							;=====================================================
      3  1beb							;=====================================================
      4  1beb							;=====================================================
      5  1beb							; This marks the start of support functions used by
      6  1beb							; the IL opcodes.  These are support functions, NOT
      7  1beb							; the IL code.
      8  1beb							;=====================================================
      9  1beb							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1beb							;=====================================================
     11  1beb					      Seg	Code
     12  1beb							;=====================================================
     13  1beb							; This gets the next two bytes pointed to by ILPC and
     14  1beb							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1beb							; is advanced by two, and Y contains 0 on return.
     16  1beb
     17  1beb							;
     18  1beb		       20 ef 1b    getILWord  jsr	getILByte	;LSB
     19  1bee		       aa		      tax
     20  1bef							;
     21  1bef							;=====================================================
     22  1bef							; This gets the next byte pointed to by ILPC and
     23  1bef							; returns it in A.  On return, X is unchanged but Y
     24  1bef							; contains 0.
     25  1bef							;
     26  1bef		       a0 00	   getILByte  ldy	#0
     27  1bf1		       b1 43		      lda	(ILPC),y	;get byte
     28  1bf3		       08		      php		;save status
     29  1bf4		       e6 43		      inc	ILPC	;inc LSB
     30  1bf6		       d0 02		      bne	getILb2	;branch if no overflow
     31  1bf8		       e6 44		      inc	ILPC+1	;inc MSB
     32  1bfa		       28	   getILb2    plp		;restore status
     33  1bfb		       60		      rts
     34  1bfc							;
     35  1bfc							;=====================================================
     36  1bfc							; Decrement ILPC by one.
     37  1bfc							;
     38  1bfc		       a5 43	   decIL      lda	ILPC
     39  1bfe		       d0 02		      bne	decIL2
     40  1c00		       c6 44		      dec	ILPC+1
     41  1c02		       c6 43	   decIL2     dec	ILPC
     42  1c04		       60		      rts
     43  1c05							;
     44  1c05							;=====================================================
     45  1c05							; Push the ILPC onto the return stack.  Actually, this
     46  1c05							; pushes the address of ILPC+2 since that's the next
     47  1c05							; address to execute.
     48  1c05							;
     49  1c05		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  1c07		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  1c09		       b0 15		      bcs	pushErr
     52  1c0b		       a5 43		      lda	ILPC
     53  1c0d		       18		      clc
     54  1c0e		       69 02		      adc	#2
     55  1c10		       91 45		      sta	(ILSTACK),y
     56  1c12		       08		      php		;save C bit
     57  1c13		       c8		      iny
     58  1c14		       a5 44		      lda	ILPC+1
     59  1c16		       28		      plp		;restore C
     60  1c17		       69 00		      adc	#0
     61  1c19		       91 45		      sta	(ILSTACK),y
     62  1c1b		       c8		      iny
     63  1c1c		       84 47		      sty	ILSTACKPTR
     64  1c1e		       18		      clc
     65  1c1f		       60		      rts
     66  1c20				   pushErr
     67  1c20		       38		      sec
     68  1c21		       60		      rts
     69  1c22							;
     70  1c22							;=====================================================
     71  1c22							; Pull the top entry from return stack and put into
     72  1c22							; ILPC.
     73  1c22							;
     74  1c22		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1c24		       f0 fa		      beq	pushErr
     76  1c26		       88		      dey
     77  1c27		       b1 45		      lda	(ILSTACK),y
     78  1c29		       85 44		      sta	ILPC+1
     79  1c2b		       88		      dey
     80  1c2c		       b1 45		      lda	(ILSTACK),y
     81  1c2e		       85 43		      sta	ILPC
     82  1c30		       84 47		      sty	ILSTACKPTR
     83  1c32		       18		      clc
     84  1c33		       60		      rts
     85  1c34							;
     86  1c34							;=====================================================
     87  1c34							; This searches for a specific line number that is in
     88  1c34							; R0.	There are three possible return conditions:
     89  1c34							; Line numbers are now the third byte, the first byte is now
     90  1c34							; a pointer to the next line, of course no longer than 255 byte
     91  1c34							; per line.
     92  1c34							;
     93  1c34							; Exact match was found:
     94  1c34							;    * Z set
     95  1c34							;    * CURPTR points to two-byte line number for that
     96  1c34							;	line.
     97  1c34							;
     98  1c34							; Next highest line found:
     99  1c34							;    * Z cleared
    100  1c34							;    * C set
    101  1c34							;    * CURPTR points to two-byte line number for that
    102  1c34							;	line.
    103  1c34							;
    104  1c34							; End of program reached:
    105  1c34							;    * Z cleared
    106  1c34							;    * C cleared
    107  1c34							;    * CURPTR points to first free byte at end of
    108  1c34							;	program.  Ie, it has save value as PROGRAMEND.
    109  1c34							;
    110  1c34							; A, X, and Y are all undefined on return.
    111  1c34							;
    112  1c34
    113  1c34				   findLine
    114  1c34		       ad 1c 31 	      lda	ProgramStart	;Start of program -> CURPTR
    115  1c37		       85 4f		      sta	CURPTR
    116  1c39		       ad 1d 31 	      lda	ProgramStart+1
    117  1c3c		       85 50		      sta	CURPTR+1
    118  1c3e							;
    119  1c3e							; At end of code?
    120  1c3e							;
    121  1c3e				   iXFER1
    122  1c3e		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1c40		       cd 1e 31 	      cmp	ProgramEnd	; at end of program then stop run
    124  1c43		       d0 0b		      bne	xfer2	; not end
    125  1c45		       a5 50		      lda	CURPTR+1
    126  1c47		       cd 1f 31 	      cmp	ProgramEnd+1
    127  1c4a		       d0 04		      bne	xfer2	;Not at end
    128  1c4c							;
    129  1c4c							; Line not found and the end of the program was
    130  1c4c							; reached.  Return Z and C both clear.
    131  1c4c							;
    132  1c4c		       a9 01		      lda	#1	;clear Z
    133  1c4e		       18		      clc		;clear C
    134  1c4f		       60		      rts
    135  1c50							;
    136  1c50							; Check for an exact line number match
    137  1c50							;
    138  1c50		       a5 52	   xfer2      lda	R0
    139  1c52		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1c54		       d1 4f		      cmp	(CURPTR),y
    141  1c56		       d0 08		      bne	xfernotit
    142  1c58		       c8		      iny
    143  1c59		       a5 53		      lda	R0+1
    144  1c5b		       d1 4f		      cmp	(CURPTR),y
    145  1c5d		       d0 01		      bne	xfernotit	; not a matching line number
    146  1c5f							;
    147  1c5f							; This is exactly the line we want.
    148  1c5f							;
    149  1c5f		       60		      rts		;it matches exactly
    150  1c60							;
    151  1c60							; See if this line is greater than the one we're
    152  1c60							; searching for.
    153  1c60							;
    154  1c60		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1c62		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1c64		       c5 53		      cmp	R0+1
    157  1c66		       90 0b		      bcc	xfer3
    158  1c68		       d0 07		      bne	xfer4
    159  1c6a		       88		      dey
    160  1c6b		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1c6d		       c5 52		      cmp	R0
    162  1c6f		       90 02		      bcc	xfer3
    163  1c71							;
    164  1c71							; This line is greater than the one we want, so
    165  1c71							; return Z clear and C set.
    166  1c71							;
    167  1c71		       38	   xfer4      sec		;We found a line number greater
    168  1c72		       60		      rts		;both conditions set
    169  1c73							;
    170  1c73							; Not the line (or droid) we're looking for.  Move to
    171  1c73							; the next line.
    172  1c73							;
    173  1c73		       20 79 1c    xfer3      jsr	FindNextLine
    174  1c76		       4c 3e 1c 	      jmp	iXFER1
    175  1c79							;
    176  1c79							;=====================================================
    177  1c79							; This advances CURPTR to the next line.  If there
    178  1c79							; are no more lines, this leaves CURPTR equal to
    179  1c79							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1c79							; CURPTR is pointing to a valid line on entry.  This
    181  1c79							; pointer points to the two-byte line number.
    182  1c79							; Update this points to the 1 byte line length  ****************
    183  1c79							;
    184  1c79				   FindNextLine
    185  1c79		       a0 03		      ldy	#3	;skip line number and length byte
    186  1c7b		       84 51		      sty	CUROFF	;this is the new offset
    187  1c7d		       a0 00		      ldy	#0
    188  1c7f		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1c81		       18		      clc
    190  1c82		       65 4f		      adc	CURPTR
    191  1c84		       85 4f		      sta	CURPTR
    192  1c86		       a5 50		      lda	CURPTR+1
    193  1c88		       69 00		      adc	#0
    194  1c8a		       85 50		      sta	CURPTR+1
    195  1c8c		       60	   FindNext4  rts
    196  1c8d							;
    197  1c8d							;=====================================================
    198  1c8d							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1c8d							; if they are equal, Z clear if not.
    200  1c8d							;
    201  1c8d		       a5 4f	   AtEnd      lda	CURPTR
    202  1c8f		       cd 1e 31 	      cmp	ProgramEnd
    203  1c92		       d0 05		      bne	atendexit
    204  1c94		       a5 50		      lda	CURPTR+1
    205  1c96		       cd 1f 31 	      cmp	ProgramEnd+1
    206  1c99		       60	   atendexit  rts
    207  1c9a							;
    208  1c9a
    209  1c9a							;
    210  1c9a							;=====================================================
    211  1c9a							; Convert an ASCII string to a number.  On input,
    212  1c9a							; (CURPTR),Y points to the first digit.  This gets
    213  1c9a							; digit-by-digit until finding a non-number.  Returns
    214  1c9a							; Y pointing to the non-digit, and R0 contains the
    215  1c9a							; number.  This does NOT check for valid ranges, so
    216  1c9a							; a value like "123456789" will produce something,
    217  1c9a							; but not what you had expected.
    218  1c9a							;
    219  1c9a		       a9 00	   getDecimal lda	#0
    220  1c9c		       85 52		      sta	R0
    221  1c9e		       85 53		      sta	R0+1
    222  1ca0		       85 59		      sta	dpl	;temporary negative flag
    223  1ca2							;
    224  1ca2							; See if it's negative...
    225  1ca2							;
    226  1ca2							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1ca2		       b1 4f		      lda	(CURPTR),y
    228  1ca4		       c9 2d		      cmp	#'-
    229  1ca6		       d0 02		      bne	getDecLoop
    230  1ca8		       e6 59		      inc	dpl	;it's negative
    231  1caa							;
    232  1caa		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1cac		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1cae		       c9 30		      cmp	#'0
    235  1cb0		       90 36		      bcc	getDdone
    236  1cb2		       c9 3a		      cmp	#'9+1
    237  1cb4		       b0 32		      bcs	getDdone
    238  1cb6		       38		      sec
    239  1cb7		       e9 30		      sbc	#'0	;convert to binary
    240  1cb9		       48		      pha
    241  1cba							;
    242  1cba							; Now multiply R0 by 10.  Remember that
    243  1cba							; 2*N + 8*N = 10*N.
    244  1cba							;
    245  1cba		       06 52		      asl	R0
    246  1cbc		       26 53		      rol	R0+1	;*2
    247  1cbe		       a5 52		      lda	R0
    248  1cc0		       85 54		      sta	R1
    249  1cc2		       a5 53		      lda	R0+1
    250  1cc4		       85 55		      sta	R1+1
    251  1cc6		       06 52		      asl	R0
    252  1cc8		       26 53		      rol	R0+1	;*4
    253  1cca		       06 52		      asl	R0
    254  1ccc		       26 53		      rol	R0+1	;*8
    255  1cce		       18		      clc		;now add the partial sums...
    256  1ccf		       a5 52		      lda	R0	;...to get *10
    257  1cd1		       65 54		      adc	R1
    258  1cd3		       85 52		      sta	R0
    259  1cd5		       a5 53		      lda	R0+1
    260  1cd7		       65 55		      adc	R1+1
    261  1cd9		       85 53		      sta	R0+1
    262  1cdb							;
    263  1cdb							; Add in the new digit
    264  1cdb							;
    265  1cdb		       68		      pla
    266  1cdc		       18		      clc
    267  1cdd		       65 52		      adc	R0
    268  1cdf		       85 52		      sta	R0
    269  1ce1		       90 02		      bcc	getD2
    270  1ce3		       e6 53		      inc	R0+1
    271  1ce5							;
    272  1ce5							; Move to next character
    273  1ce5							;
    274  1ce5		       c8	   getD2      iny
    275  1ce6		       d0 c2		      bne	getDecLoop
    276  1ce8							;
    277  1ce8							; All done with digits, so now deal with it being
    278  1ce8							; negative.  If zero, then don't check for negative
    279  1ce8							; flag.  Ie, -0 is stored as 0.
    280  1ce8							;
    281  1ce8		       a5 52	   getDdone   lda	R0
    282  1cea		       05 53		      ora	R0+1
    283  1cec		       f0 16		      beq	getDone2	;zero
    284  1cee		       a5 59		      lda	dpl
    285  1cf0		       f0 12		      beq	getDone2	;positive
    286  1cf2							;
    287  1cf2							; Invert all the bits, then add one.
    288  1cf2							;
    289  1cf2		       a5 52		      lda	R0
    290  1cf4		       49 ff		      eor	#$ff
    291  1cf6		       85 52		      sta	R0
    292  1cf8		       a5 53		      lda	R0+1
    293  1cfa		       49 ff		      eor	#$ff
    294  1cfc		       85 53		      sta	R0+1
    295  1cfe							;
    296  1cfe		       e6 52		      inc	R0
    297  1d00		       d0 02		      bne	getDone2
    298  1d02		       e6 53		      inc	R0+1
    299  1d04				   getDone2
    300  1d04							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1d04							;lda	  R0
    302  1d04							;sta	  $0010
    303  1d04							;lda	  R0+1
    304  1d04							;sta	  $0011
    305  1d04							;lda	  dpl
    306  1d04							;sta	  $012
    307  1d04
    308  1d04		       60		      rts
    309  1d05
    310  1d05							;=====================================================
    311  1d05							; Gets a line of input into LINBUF.
    312  1d05							;
    313  1d05							; On entry:
    314  1d05							;    A contains the prompt character, or 0 if none.
    315  1d05							;    X = 1 Background read
    316  1d05							;    x = 0 Forground read with wait
    317  1d05							;
    318  1d05							; On exit:
    319  1d05							;    CURPTR points to LINBUF
    320  1d05							;    LINBUF contains the line with 0 at the end.
    321  1d05							;    Y has offset to first non-space character
    322  1d05							;    CURROFF has the same as Y.
    323  1d05							;
    324  1d05		       20 54 1d    GetLine    jsr	ReadPrompt
    325  1d08		       e0 00		      cpx	#0
    326  1d0a		       f0 14		      beq	GetLineRetry
    327  1d0c		       ae c3 27 	      ldx	taskPtr
    328  1d0f		       bd c4 27 	      lda	taskTable,x
    329  1d12		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1d14		       d0 3d		      bne	taskWaitingIO
    331  1d16		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1d18		       9d c4 27 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1d1b		       ce 53 1d 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1d1e		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1d20
    336  1d20							;
    337  1d20							; Now read a line and wait for the CR
    338  1d20							;
    339  1d20				   GetLineRetry
    340  1d20		       a9 00		      lda	#0	;Wait for input to complete
    341  1d22		       20 6c 1d 	      jsr	ReadLine
    342  1d25
    343  1d25							;
    344  1d25							; Point to the line we just read
    345  1d25							; Set the current pointer to point to the input line
    346  1d25							;
    347  1d25		       a0 00	   ReadComplete ldy	#0
    348  1d27		       84 51		      sty	CUROFF
    349  1d29		       a2 7f		      ldx	#LINBUF&$ff
    350  1d2b		       86 4f		      stx	CURPTR
    351  1d2d		       a2 30		      ldx	#LINBUF>>8
    352  1d2f		       86 50		      stx	CURPTR+1
    353  1d31							;
    354  1d31							; Output a CR/LF
    355  1d31							;
    356  1d31		       20 33 1f 	      jsr	CRLF
    357  1d34							;
    358  1d34							; If a blank line, prompt again.
    359  1d34							;
    360  1d34		       20 2a 1f 	      jsr	SkipSpaces
    361  1d37		       b1 4f		      lda	(CURPTR),y
    362  1d39		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1d3b		       20 57 1d 	      jsr	ReadPromptRetry
    364  1d3e		       ae c3 27 	      ldx	taskPtr	;if this task is waiting for IO
    365  1d41		       bd c4 27 	      lda	taskTable,x	;then get out, wait for line to
    366  1d44		       29 40		      and	#TASKWAITIO	;Complete again
    367  1d46		       d0 0b		      bne	taskWaitingIO
    368  1d48		       4c 20 1d 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1d4b
    370  1d4b				   GetLineDone
    371  1d4b		       ae c3 27 	      ldx	taskPtr
    372  1d4e		       a9 80		      lda	#TASKACTIVE
    373  1d50		       9d c4 27 	      sta	taskTable,x	;IO is complete
    374  1d53
    375  1d53				   taskWaitingIO
    376  1d53		       60		      rts
    377  1d54
    378  1d54							;
    379  1d54							;=======================================================================
    380  1d54							; Display the prompt character
    381  1d54							; On entry
    382  1d54							;	    A contains the prompt character
    383  1d54							; On exit
    384  1d54							;	    The readbuffer index is reset to 0
    385  1d54							;
    386  1d54		       8d 06 31    ReadPrompt sta	promptChar
    387  1d57
    388  1d57							;
    389  1d57							; Prompt
    390  1d57							;
    391  1d57
    392  1d57		       ad 06 31    ReadPromptRetry lda	promptChar
    393  1d5a		       09 00		      ora	#0	;any prompt?
    394  1d5c		       f0 08		      beq	getlinenp
    395  1d5e		       20 81 20 	      jsr	VOUTCH
    396  1d61		       a9 20		      lda	#$20
    397  1d63		       20 81 20 	      jsr	VOUTCH	;Space after prompt
    398  1d66							;
    399  1d66		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1d68		       8e 03 31 	      stx	getlinx
    401  1d6b		       60		      rts
    402  1d6c							;
    403  1d6c							;===============================================================
    404  1d6c							; This fuction is the driver for the line input
    405  1d6c							; on call if a = 0 then it waits for all input
    406  1d6c							;	      a = 1 then nowait for input
    407  1d6c							; On exit
    408  1d6c							;		       c clear if not complete line
    409  1d6c							;		       c set if it was a complete line
    410  1d6c
    411  1d6c				   ReadLine
    412  1d6c		       8d 05 31 	      sta	inputNoWait
    413  1d6f		       c9 00		      cmp	#0
    414  1d71		       f0 05		      beq	getline1
    415  1d73		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1d76		       f0 2b		      beq	GetLineNoWait
    417  1d78		       20 84 20    getline1   jsr	VGETCH
    418  1d7b					      if	CTMON65
    419  1d7b		       48		      pha
    420  1d7c		       20 81 20 	      jsr	VOUTCH	;echo echo echo
    421  1d7f		       68		      pla
    422  1d80					      endif
    423  1d80		       c9 0d		      cmp	#CR
    424  1d82		       f0 15		      beq	getlind	;end of line
    425  1d84		       c9 08		      cmp	#BS	;backspace?
    426  1d86		       f0 1d		      beq	getlinebs
    427  1d88		       ae 03 31 	      ldx	getlinx
    428  1d8b		       9d 7f 30 	      sta	LINBUF,x
    429  1d8e		       e8		      inx
    430  1d8f		       8e 03 31 	      stx	getlinx
    431  1d92		       ad 05 31 	      lda	inputNoWait
    432  1d95		       f0 e1		      beq	getline1
    433  1d97		       d0 0a		      bne	GetLineNoWait
    434  1d99							;
    435  1d99							; CR was hit
    436  1d99							;
    437  1d99		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1d9b		       ae 03 31 	      ldx	getlinx
    439  1d9e		       9d 7f 30 	      sta	LINBUF,x
    440  1da1
    441  1da1		       38		      sec		; Carry set then cr received
    442  1da2		       60		      rts
    443  1da3
    444  1da3				   GetLineNoWait
    445  1da3		       18		      clc		; Carry clear no end of line
    446  1da4		       60		      rts
    447  1da5							;
    448  1da5							; Backspace was hit
    449  1da5							;
    450  1da5		       ae 03 31    getlinebs  ldx	getlinx
    451  1da8		       f0 0e		      beq	getlineEOL	;at start of line
    452  1daa		       ca		      dex
    453  1dab		       8e 03 31 	      stx	getlinx
    454  1dae		       20 82 14    getlinepbs jsr	puts
      0  1db1					      db	27,"[K",0
      1  1db1		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1db5		       4c 78 1d 	      jmp	getline1
    457  1db8		       a9 20	   getlineEOL lda	#SPACE
    458  1dba		       20 81 20 	      jsr	VOUTCH
    459  1dbd		       d0 ef		      bne	getlinepbs
    460  1dbf							;
    461  1dbf							;=====================================================
    462  1dbf							; Count the length of the line currently in LINBUF
    463  1dbf							; starting at offset Y.  Returns the length in X.  The
    464  1dbf							; starting offset in Y should point past the ASCII
    465  1dbf							; line number.  Also counts the trailing NULL and two
    466  1dbf							; extra bytes for where the line number will be.
    467  1dbf							; Update must now include leading length byte not the null at end ****************
    468  1dbf							;
    469  1dbf				   getLineLength
    470  1dbf		       a2 00		      ldx	#0	;size
    471  1dc1		       b9 7f 30    getLineL2  lda	LINBUF,y
    472  1dc4		       f0 04		      beq	getLineL3
    473  1dc6		       c8		      iny
    474  1dc7		       e8		      inx
    475  1dc8		       d0 f7		      bne	getLineL2
    476  1dca		       e8	   getLineL3  inx		;count null at end
    477  1dcb		       e8		      inx		;line number LSB
    478  1dcc		       e8		      inx		;MSB
    479  1dcd		       e8		      inx		;change: count new leading line length
    480  1dce		       8e 19 31 	      stx	lineLength
    481  1dd1		       60		      rts
    482  1dd2							;
    483  1dd2							;=====================================================
    484  1dd2							; Count the length of the line pointed to by CURPTR.
    485  1dd2							; This also counts the line number and the terminating
    486  1dd2							; null.  Ie, this string returns 8:
    487  1dd2							;
    488  1dd2							; <lineLow><lineHi>Hello<null>
    489  1dd2							;
    490  1dd2							; Another way of looking at it: add the return value
    491  1dd2							; to the CURPTR and it'll point to the next line's
    492  1dd2							; line number.  Returns the value in Y.
    493  1dd2							; Update to ject get the leading byte length ********************
    494  1dd2							;
    495  1dd2							;getCURPTRLength
    496  1dd2							;		ldy	CURPTR
    497  1dd2							;		ldy	#3	;change: skip line number and leading length byte
    498  1dd2							;getCLineL2	lda	(CURPTR),y
    499  1dd2							;		beq	getCLineL3
    500  1dd2							;		iny
    501  1dd2							;		bne	getCLineL2
    502  1dd2							;getCLineL3	iny		;count null at end
    503  1dd2							;		rts
    504  1dd2
    505  1dd2							;
    506  1dd2							;=====================================================
    507  1dd2							; This saves ILPC.  This saves to a single save area,
    508  1dd2							; so it can't be called more than once.
    509  1dd2							;
    510  1dd2		       a5 43	   saveIL     lda	ILPC
    511  1dd4		       8d 15 31 	      sta	tempIL
    512  1dd7		       a5 44		      lda	ILPC+1
    513  1dd9		       8d 16 31 	      sta	tempIL+1
    514  1ddc		       60		      rts
    515  1ddd							;
    516  1ddd							;=====================================================
    517  1ddd							; This restores ILPC.
    518  1ddd							;
    519  1ddd		       ad 15 31    restoreIL  lda	tempIL
    520  1de0		       85 43		      sta	ILPC
    521  1de2		       ad 16 31 	      lda	tempIL+1
    522  1de5		       85 44		      sta	ILPC+1
    523  1de7		       60		      rts
    524  1de8							;
    525  1de8							;=====================================================
    526  1de8							; This pushes R0 onto the stack.
    527  1de8							;
    528  1de8		       8c 0c 31    pushR0     sty	rtemp1
    529  1deb		       a4 4a		      ldy	MATHSTACKPTR
    530  1ded		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1def		       b0 38		      bcs	pusherr
    532  1df1		       a5 52		      lda	R0
    533  1df3		       91 48		      sta	(MATHSTACK),y
    534  1df5		       c8		      iny
    535  1df6		       a5 53		      lda	R0+1
    536  1df8		       91 48		      sta	(MATHSTACK),y
    537  1dfa		       c8		      iny
    538  1dfb		       84 4a		      sty	MATHSTACKPTR
    539  1dfd		       ac 0c 31 	      ldy	rtemp1
    540  1e00		       18		      clc
    541  1e01		       60		      rts
    542  1e02
    543  1e02							;=====================================================
    544  1e02							; This pushes curptr basic current line onto the call stack.
    545  1e02							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1e02
    547  1e02				   pushLN
    548  1e02		       8d 0d 31 	      STA	rtemp1+1	; Store type of push being done
    549  1e05		       8c 0c 31 	      sty	rtemp1
    550  1e08		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  1e0a		       c5 4d		      cmp	GOSUBSTACKPTR
    552  1e0c		       90 1b		      bcc	pusherr	; No error
    553  1e0e		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  1e10		       a2 00		      ldx	#0	; Start of bytes to copy
    555  1e12				   pushLoop
    556  1e12		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  1e14		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  1e16		       c8		      iny		; Next destination
    559  1e17		       e8		      inx		; Next Source byte
    560  1e18		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  1e1a		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  1e1c
    563  1e1c		       ad 0d 31    pushDone   lda	rtemp1+1	; Type of stack entry
    564  1e1f		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  1e21		       c8		      iny		; Next entry
    566  1e22
    567  1e22		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  1e24		       ac 0c 31 	      ldy	rtemp1
    569  1e27		       18		      clc
    570  1e28		       60		      rts
    571  1e29				   pusherr
    572  1e29		       38		      sec
    573  1e2a		       60		      rts
    574  1e2b							;=====================================================
    575  1e2b							; This pops Top Off gosub call Stack and
    576  1e2b							; places it in CURPTR/CUROFF.
    577  1e2b							; This checks if the type = 1 GOSUB
    578  1e2b							; if not it removes what ever is on the stack
    579  1e2b							; until it finds the next return. Allowing
    580  1e2b							; a return from within a for/next
    581  1e2b							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  1e2b		       8c 0c 31    popLN      sty	rtemp1
    583  1e2e		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  1e30		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  1e32
    586  1e32				   popContinue
    587  1e32		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  1e34		       90 22		      bcc	poperr	; Process an error
    589  1e36
    590  1e36		       88		      dey		; Position to read entry type
    591  1e37		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  1e39		       8d 0d 31 	      sta	rtemp1+1	; Save to be returned
    593  1e3c		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  1e3e		       f0 04		      beq	popLoop	; Restore the line
    595  1e40		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  1e42		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  1e44
    598  1e44				   popLoop
    599  1e44		       88		      dey
    600  1e45		       ca		      dex
    601  1e46		       b1 4b		      lda	(GOSUBSTACK),y
    602  1e48		       95 4f		      sta	CURPTR,x
    603  1e4a		       e0 00		      cpx	#0
    604  1e4c		       d0 f6		      bne	popLoop	; Loop until all moved
    605  1e4e
    606  1e4e
    607  1e4e		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  1e50		       ac 0c 31 	      ldy	rtemp1
    609  1e53		       ad 0d 31 	      lda	rtemp1+1	; get the type of return
    610  1e56		       18		      clc
    611  1e57		       60		      rts
    612  1e58
    613  1e58		       38	   poperr     sec
    614  1e59		       60		      rts
    615  1e5a
    616  1e5a		       88	   popSkipEntry dey
    617  1e5b		       88		      dey
    618  1e5c		       88		      dey
    619  1e5d		       4c 32 1e 	      jmp	popContinue
    620  1e60
    621  1e60							;
    622  1e60							;=====================================================
    623  1e60							; This pushes R1 onto the stack
    624  1e60							;
    625  1e60		       8c 0c 31    pushR1     sty	rtemp1
    626  1e63		       a4 4a		      ldy	MATHSTACKPTR
    627  1e65		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  1e67		       b0 ef		      bcs	poperr
    629  1e69		       a5 54		      lda	R1
    630  1e6b		       91 48		      sta	(MATHSTACK),y
    631  1e6d		       c8		      iny
    632  1e6e		       a5 55		      lda	R1+1
    633  1e70		       91 48		      sta	(MATHSTACK),y
    634  1e72		       c8		      iny
    635  1e73		       84 4a		      sty	MATHSTACKPTR
    636  1e75		       ac 0c 31 	      ldy	rtemp1
    637  1e78		       18		      clc
    638  1e79		       60		      rts
    639  1e7a							;
    640  1e7a							;=====================================================
    641  1e7a							; This pops Top Of Stack and places it in R0.
    642  1e7a							;
    643  1e7a		       8c 0c 31    popR0      sty	rtemp1
    644  1e7d		       a4 4a		      ldy	MATHSTACKPTR
    645  1e7f		       f0 d7		      beq	poperr
    646  1e81		       88		      dey
    647  1e82		       b1 48		      lda	(MATHSTACK),y
    648  1e84		       85 53		      sta	R0+1
    649  1e86		       88		      dey
    650  1e87		       b1 48		      lda	(MATHSTACK),y
    651  1e89		       85 52		      sta	R0
    652  1e8b		       84 4a		      sty	MATHSTACKPTR
    653  1e8d		       ac 0c 31 	      ldy	rtemp1
    654  1e90		       18		      clc
    655  1e91		       60		      rts
    656  1e92
    657  1e92							;
    658  1e92							;=====================================================
    659  1e92							; This pops TOS and places it in R1.
    660  1e92							;
    661  1e92		       8c 0c 31    popR1      sty	rtemp1
    662  1e95		       a4 4a		      ldy	MATHSTACKPTR
    663  1e97		       f0 bf		      beq	poperr
    664  1e99		       88		      dey
    665  1e9a		       b1 48		      lda	(MATHSTACK),y
    666  1e9c		       85 55		      sta	R1+1
    667  1e9e		       88		      dey
    668  1e9f		       b1 48		      lda	(MATHSTACK),y
    669  1ea1		       85 54		      sta	R1
    670  1ea3		       84 4a		      sty	MATHSTACKPTR
    671  1ea5		       ac 0c 31 	      ldy	rtemp1
    672  1ea8		       60		      rts
    673  1ea9							;
    674  1ea9							;=====================================================
    675  1ea9							; This pops TOS and places it in MQ.
    676  1ea9							;
    677  1ea9		       8c 0c 31    popMQ      sty	rtemp1
    678  1eac		       a4 4a		      ldy	MATHSTACKPTR
    679  1eae		       f0 a8		      beq	poperr
    680  1eb0		       88		      dey
    681  1eb1		       b1 48		      lda	(MATHSTACK),y
    682  1eb3		       85 57		      sta	MQ+1
    683  1eb5		       88		      dey
    684  1eb6		       b1 48		      lda	(MATHSTACK),y
    685  1eb8		       85 56		      sta	MQ
    686  1eba		       84 4a		      sty	MATHSTACKPTR
    687  1ebc		       ac 0c 31 	      ldy	rtemp1
    688  1ebf		       60		      rts
    689  1ec0							;
    690  1ec0							;=====================================================
    691  1ec0							; This assists with multiplication and division by
    692  1ec0							; looking at R0 and R1 and saving a flag as to what
    693  1ec0							; sign the result will be.  Math is always done on
    694  1ec0							; positive numbers, so this converts negative numbers
    695  1ec0							; into positives.  On exit, R0 and R1 are both
    696  1ec0							; positive.  If the signs were different then 'signs'
    697  1ec0							; will be non-zero.
    698  1ec0							;
    699  1ec0		       a9 00	   SaveSigns  lda	#0
    700  1ec2		       8d 0b 31 	      sta	sign	;assume positive
    701  1ec5		       a5 53		      lda	R0+1	;MSB
    702  1ec7		       10 13		      bpl	SaveSigns1
    703  1ec9		       ee 0b 31 	      inc	sign	;it's negative
    704  1ecc		       49 ff		      eor	#$ff	;flip bits
    705  1ece		       85 53		      sta	R0+1
    706  1ed0		       a5 52		      lda	R0
    707  1ed2		       49 ff		      eor	#$ff
    708  1ed4		       85 52		      sta	R0
    709  1ed6		       e6 52		      inc	R0
    710  1ed8		       d0 02		      bne	SaveSigns1
    711  1eda		       e6 53		      inc	R0+1
    712  1edc		       a5 55	   SaveSigns1 lda	R1+1
    713  1ede		       10 1a		      bpl	SaveSigns2
    714  1ee0		       48		      pha
    715  1ee1		       ad 0b 31 	      lda	sign
    716  1ee4		       49 01		      eor	#1
    717  1ee6		       8d 0b 31 	      sta	sign
    718  1ee9		       68		      pla
    719  1eea		       49 ff		      eor	#$ff	;flip bits
    720  1eec		       85 55		      sta	R1+1
    721  1eee		       a5 54		      lda	R1
    722  1ef0		       49 ff		      eor	#$ff
    723  1ef2		       85 54		      sta	R1
    724  1ef4		       e6 54		      inc	R1
    725  1ef6		       d0 02		      bne	SaveSigns2
    726  1ef8		       e6 55		      inc	R1+1
    727  1efa		       60	   SaveSigns2 rts
    728  1efb							;
    729  1efb							;=====================================================
    730  1efb							; This looks at the value of 'signs' and will convert
    731  1efb							; both R0 and R1 to negative if set.
    732  1efb							;
    733  1efb				   RestoreSigns
    734  1efb		       ad 0b 31 	      lda	sign
    735  1efe		       f0 28		      beq	restoresigns2
    736  1f00							;
    737  1f00		       a5 52		      lda	R0
    738  1f02		       d0 02		      bne	restoresigns3
    739  1f04		       c6 53		      dec	R0+1
    740  1f06				   restoresigns3
    741  1f06		       c6 52		      dec	R0
    742  1f08		       a5 52		      lda	R0
    743  1f0a		       49 ff		      eor	#$ff
    744  1f0c		       85 52		      sta	R0
    745  1f0e		       a5 53		      lda	R0+1
    746  1f10		       49 ff		      eor	#$ff
    747  1f12		       85 53		      sta	R0+1
    748  1f14							;
    749  1f14		       a5 54		      lda	R1
    750  1f16		       d0 02		      bne	restoresigns4
    751  1f18		       c6 55		      dec	R1+1
    752  1f1a				   restoresigns4
    753  1f1a		       c6 54		      dec	R1
    754  1f1c		       a5 54		      lda	R1
    755  1f1e		       49 ff		      eor	#$ff
    756  1f20		       85 54		      sta	R1
    757  1f22		       a5 55		      lda	R1+1
    758  1f24		       49 ff		      eor	#$ff
    759  1f26		       85 55		      sta	R1+1
    760  1f28							;
    761  1f28				   restoresigns2
    762  1f28		       60		      rts
    763  1f29							;
    764  1f29							;=====================================================
    765  1f29							; Skip over spaces.  Returns Y with the offset to
    766  1f29							; either the last character in the line, or the first
    767  1f29							; non-space character.
    768  1f29							;
    769  1f29
    770  1f29		       c8	   skipsp2    iny
    771  1f2a		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  1f2c		       f0 04		      beq	Skip3	;end of line
    773  1f2e		       c9 20		      cmp	#SPACE
    774  1f30		       f0 f7		      beq	skipsp2
    775  1f32		       60	   Skip3      rts
    776  1f33							;*********************************************************
    777  1f33							; Output a CR/LF combination to the console.  Preserves
    778  1f33							; all registers.
    779  1f33							;
    780  1f33		       48	   tbcrlf     pha
    781  1f34		       a9 0d		      lda	#CR
    782  1f36		       20 81 20 	      jsr	VOUTCH
    783  1f39		       a9 0a		      lda	#LF
    784  1f3b		       20 81 20 	      jsr	VOUTCH
    785  1f3e		       68		      pla
    786  1f3f		       60		      rts
    787  1f40							;
    788  1f40							;=====================================================
    789  1f40							; Some logic to print the Line of basic code being executed
    790  1f40		       24 40	   idbgBasic  bit	ILTrace
    791  1f42		       50 75		      bvc	dbgBasicNone
    792  1f44		       98		      tya
    793  1f45		       48		      pha
    794  1f46		       20 b5 20 	      jsr	SetOutDebug
    795  1f49
    796  1f49		       a5 4f		      lda	CURPTR
    797  1f4b		       85 59		      sta	dpl
    798  1f4d		       a5 50		      lda	CURPTR+1
    799  1f4f		       85 5a		      sta	dpl+1
    800  1f51
    801  1f51		       20 1a 15 	      jsr	PrintProgramLine
    802  1f54
    803  1f54		       a5 40		      lda	ILTrace
    804  1f56		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  1f58		       f0 5a		      beq	dbgBasicDone
    806  1f5a		       20 cc 20 	      jsr	SetInDebug
    807  1f5d		       20 82 14 	      jsr	puts
      0  1f60					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1f60		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  1f9d				   dbgBasicLoop
    810  1f9d		       20 84 20 	      jsr	VGETCH
    811  1fa0		       20 33 1f 	      jsr	CRLF
    812  1fa3		       20 f0 20 	      jsr	SetInDebugEnd
    813  1fa6
    814  1fa6		       c9 73		      cmp	#'s	; Quit program
    815  1fa8		       f0 12		      beq	dbgBasicStop
    816  1faa
    817  1faa		       c9 64		      cmp	#'d	; Display Variables
    818  1fac		       d0 06		      bne	dbgBasicDone
    819  1fae
    820  1fae		       20 dd 14 	      jsr	PrintAllVars
    821  1fb1		       18		      clc
    822  1fb2		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  1fb4
    824  1fb4		       20 e3 20    dbgBasicDone jsr	SetOutDebugEnd
    825  1fb7		       68		      pla
    826  1fb8		       a8		      tay
    827  1fb9		       4c c3 02    dbgBasicNone jmp	NextIL
    828  1fbc
    829  1fbc				   dbgBasicStop
    830  1fbc		       20 e3 20 	      jsr	SetOutDebugEnd
    831  1fbf		       68		      pla
    832  1fc0		       a8		      tay
    833  1fc1		       4c 3d 06 	      jmp	iFIN
    834  1fc4							;
    835  1fc4							;=====================================================
    836  1fc4							; This is some debug logic which displays the current
    837  1fc4							; value of the ILPC and the line buffer.
    838  1fc4							;
    839  1fc4		       24 40	   dbgLine    bit	ILTrace
    840  1fc6		       30 01		      bmi	dbgPrt
    841  1fc8		       60		      rts
    842  1fc9				   dbgPrt
    843  1fc9		       20 b5 20 	      jsr	SetOutDebug
    844  1fcc		       20 82 14 	      jsr	puts
      0  1fcf					      db	"ILPC: ",0
      1  1fcf		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    846  1fd6		       a5 44		      lda	ILPC+1
    847  1fd8		       20 65 14 	      jsr	OUTHEX
    848  1fdb		       a5 43		      lda	ILPC
    849  1fdd		       20 65 14 	      jsr	OUTHEX
    850  1fe0		       a9 20		      lda	#SPACE
    851  1fe2		       20 81 20 	      jsr	VOUTCH
    852  1fe5		       a0 00		      ldy	#0
    853  1fe7		       b1 43		      lda	(ILPC),y
    854  1fe9		       20 65 14 	      jsr	OUTHEX
    855  1fec							;
    856  1fec							; Display the CURPTR value and offset
    857  1fec							;
    858  1fec		       20 82 14 	      jsr	puts
      0  1fef					      db	", CURPTR: ",0
      1  1fef		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    860  1ffa		       a5 50		      lda	CURPTR+1
    861  1ffc		       20 65 14 	      jsr	OUTHEX
    862  1fff		       a5 4f		      lda	CURPTR
    863  2001		       20 65 14 	      jsr	OUTHEX
    864  2004		       a9 2b		      lda	#'+
    865  2006		       20 81 20 	      jsr	VOUTCH
    866  2009		       a5 51		      lda	CUROFF
    867  200b		       20 65 14 	      jsr	OUTHEX
    868  200e							;
    869  200e		       20 33 1f 	      jsr	CRLF
    870  2011		       20 e3 20 	      jsr	SetOutDebugEnd
    871  2014		       20 47 20 	      jsr	ILChkRange
    872  2017		       b0 02		      bcs	dbgLineErr
    873  2019		       18		      clc
    874  201a		       60		      rts
    875  201b
    876  201b				   dbgLineErr
    877  201b		       20 b5 20 	      jsr	SetOutDebug
    878  201e		       20 82 14 	      jsr	puts
      0  2021					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2021		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    880  2042		       20 e3 20 	      jsr	SetOutDebugEnd
    881  2045		       38		      sec
    882  2046		       60		      rts
    883  2047
    884  2047		       a5 44	   ILChkRange lda	ILPC+1
    885  2049		       c9 23		      cmp	#IL>>8
    886  204b		       90 18		      bcc	ILBadRange
    887  204d		       d0 06		      bne	ILChkHigh
    888  204f
    889  204f		       a5 43		      lda	ILPC
    890  2051		       c9 67		      cmp	#IL&$ff
    891  2053		       90 10		      bcc	ILBadRange
    892  2055
    893  2055		       a5 44	   ILChkHigh  lda	ILPC+1
    894  2057		       c9 27		      cmp	#ILEND>>8
    895  2059		       90 08		      bcc	ILGoodRange
    896  205b		       d0 08		      bne	ILBadRange
    897  205d
    898  205d		       a5 43		      lda	ILPC
    899  205f		       c9 7c		      cmp	#ILEND&$ff
    900  2061		       b0 02		      bcs	ILBadRange
    901  2063
    902  2063		       18	   ILGoodRange clc
    903  2064		       60		      rts
    904  2065				   ILBadRange
    905  2065		       38		      sec
    906  2066		       60		      rts
    907  2067
    908  2067
    909  2067							;=====================================================
    910  2067							; Set output vector to the console output function
    911  2067							;
    912  2067				   SetOutConsole
    913  2067		       48		      pha
    914  2068		       a9 0c		      lda	#OUTCH&$ff
    915  206a		       8d 10 31 	      sta	BOutVec
    916  206d		       a9 f0		      lda	#OUTCH>>8
    917  206f		       8d 11 31 	      sta	BOutVec+1
    918  2072		       68		      pla
    919  2073		       60		      rts
    920  2074
    921  2074				   SetInConsole
    922  2074		       48		      pha
    923  2075		       a9 09		      lda	#GETCH&$ff
    924  2077		       8d 12 31 	      sta	BInVec
    925  207a		       a9 f0		      lda	#GETCH>>8
    926  207c		       8d 13 31 	      sta	BInVec+1
    927  207f		       68		      pla
    928  2080		       60		      rts
    929  2081
    930  2081							;=====================================================
    931  2081							; Jump to the output/input function in BOutVec/BInVec
    932  2081							;
    933  2081		       6c 10 31    VOUTCH     jmp	(BOutVec)
    934  2084		       6c 12 31    VGETCH     jmp	(BInVec)
    935  2087
    936  2087
    937  2087							;====================================================
    938  2087							;Clear the terminal assume it is ansii or vt100
    939  2087							;
    940  2087				   iCLEARSCREEN
    941  2087		       20 82 14 	      jsr	puts
      0  208a					      db	$1b,'[,'2,'J,0
      1  208a		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    943  208f		       4c c3 02 	      jmp	NextIL
    944  2092
    945  2092							;====================================================
    946  2092							; Push true and false onto math stack
    947  2092				   pushTrue
    948  2092		       a9 ff		      lda	#$ff
    949  2094		       85 52	   pushTF     sta	R0
    950  2096		       85 53		      sta	R0+1
    951  2098		       20 e8 1d 	      jsr	pushR0
    952  209b		       60		      rts
    953  209c		       a9 00	   pushFalse  lda	#0
    954  209e		       f0 f4		      beq	pushTF
    955  20a0
    956  20a0							;======================================================
    957  20a0							; Copy stack top to R1
    958  20a0				   CopyStackR1
    959  20a0		       98		      tya
    960  20a1		       48		      pha
    961  20a2		       a4 4a		      ldy	MATHSTACKPTR
    962  20a4		       88		      dey
    963  20a5		       b1 48		      lda	(MATHSTACK),y
    964  20a7		       85 55		      sta	R1+1
    965  20a9		       88		      dey
    966  20aa		       b1 48		      lda	(MATHSTACK),y
    967  20ac		       85 54		      sta	R1
    968  20ae		       68		      pla
    969  20af		       a8		      tay
    970  20b0		       60		      rts
    971  20b1
    972  20b1
    973  20b1							;====================================================
    974  20b1							;Swap the out debug call for standard calls
    975  20b1		       00 00	   DebugIOSave ds	2
    976  20b3		       00 00	   DebugInSave ds	2
    977  20b5				   SetOutDebug
    978  20b5		       ad 10 31 	      lda	BOutVec
    979  20b8		       8d b1 20 	      sta	DebugIOSave
    980  20bb		       ad 11 31 	      lda	BOutVec+1
    981  20be		       8d b2 20 	      sta	DebugIOSave+1
    982  20c1		       a9 46		      lda	#OUTDEBUG&$ff	; Put the Debug output
    983  20c3		       8d 10 31 	      sta	BOutVec
    984  20c6		       a9 21		      lda	#OUTDEBUG>>8
    985  20c8		       8d 11 31 	      sta	BOutVec+1
    986  20cb		       60		      rts
    987  20cc				   SetInDebug
    988  20cc		       ad 12 31 	      lda	BInVec
    989  20cf		       8d b3 20 	      sta	DebugInSave
    990  20d2		       ad 13 31 	      lda	BInVec+1
    991  20d5		       8d b4 20 	      sta	DebugInSave+1
    992  20d8		       a9 4a		      lda	#INDEBUG&$ff
    993  20da		       8d 12 31 	      sta	BInVec
    994  20dd		       a9 21		      lda	#INDEBUG>>8
    995  20df		       8d 13 31 	      sta	BInVec+1
    996  20e2		       60		      rts
    997  20e3				   SetOutDebugEnd
    998  20e3		       ad b1 20 	      lda	DebugIOSave
    999  20e6		       8d 10 31 	      sta	BOutVec
   1000  20e9		       ad b2 20 	      lda	DebugIOSave+1
   1001  20ec		       8d 11 31 	      sta	BOutVec+1
   1002  20ef		       60		      rts
   1003  20f0				   SetInDebugEnd
   1004  20f0		       ad b3 20 	      lda	DebugInSave
   1005  20f3		       8d 12 31 	      sta	BInVec
   1006  20f6		       ad b2 20 	      lda	DebugIOSave+1
   1007  20f9		       8d 13 31 	      sta	BInVec+1
   1008  20fc		       60		      rts
   1009  20fd							;
   1010  20fd							;====================================================
   1011  20fd							; Set the input and output terminal address
   1012  20fd							; The math stack stack byte is the output io slot
   1013  20fd							; The math stack  is the input io slot
   1014  20fd
   1015  20fd				   iSetTerminal
   1016  20fd		       20 7a 1e 	      jsr	popR0	; Process the output io addresses
   1017  2100		       20 28 21 	      jsr	CalcSlot
   1018  2103		       a5 52		      lda	R0
   1019  2105		       09 01		      ora	#1
   1020  2107		       8d 47 21 	      sta	TerminalOutputPort
   1021  210a		       a5 53		      lda	R0+1
   1022  210c		       8d 48 21 	      sta	TerminalOutputPort+1
   1023  210f
   1024  210f		       20 7a 1e 	      jsr	popR0	; Process the input io address
   1025  2112		       20 28 21 	      jsr	CalcSlot
   1026  2115		       a5 52		      lda	R0
   1027  2117		       8d 52 21 	      sta	TerminalInputPort
   1028  211a		       09 01		      ora	#1
   1029  211c		       8d 4b 21 	      sta	TerminalStatusPort
   1030  211f		       a5 53		      lda	R0+1
   1031  2121		       8d 53 21 	      sta	TerminalInputPort+1
   1032  2124		       8d 4c 21 	      sta	TerminalStatusPort+1
   1033  2127		       60		      rts
   1034  2128
   1035  2128							;===================================================
   1036  2128							; Calculate the slot address the the slot number
   1037  2128							; R0 contains the slot number 0-255
   1038  2128
   1039  2128				   CalcSlot
   1040  2128		       8a		      txa
   1041  2129		       48		      pha
   1042  212a		       a2 04		      ldx	#4
   1043  212c				   CalcSlotLoop
   1044  212c		       06 52		      asl	R0
   1045  212e		       26 53		      rol	R0+1
   1046  2130		       ca		      dex
   1047  2131		       d0 f9		      bne	CalcSlotLoop
   1048  2133		       a9 e0		      lda	#$E0
   1049  2135		       05 53		      ora	R0+1
   1050  2137		       85 53		      sta	R0+1
   1051  2139		       68		      pla
   1052  213a		       aa		      tax
   1053  213b		       60		      rts
   1054  213c							;
   1055  213c							;====================================================
   1056  213c							; Output to the Terminal/Debug console
   1057  213c							;     x = high address byte
   1058  213c							;     y = low address byte
   1059  213c							;     a = Terminator for string
   1060  213c				   TerminalWrite
   1061  213c				   DebugWrite
   1062  213c		       20 b5 20 	      jsr	SetOutDebug
   1063  213f		       20 c0 14 	      jsr	PrtStr
   1064  2142		       20 e3 20 	      jsr	SetOutDebugEnd
   1065  2145		       60		      rts
   1066  2146
   1067  2146				   OUTDEBUG
   1068  2146		       8d		      .byte.b	$8D	; STA
   1069  2147				   TerminalOutputPort
   1070  2147		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1071  2149		       60		      RTS
   1072  214a
   1073  214a				   TerminalRead
   1074  214a				   INDEBUG
   1075  214a		       ad		      .byte.b	$AD	; LDA
   1076  214b				   TerminalStatusPort
   1077  214b		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1078  214d
   1079  214d		       29 01		      and	#$01
   1080  214f		       f0 f9		      beq	INDEBUG
   1081  2151
   1082  2151		       ad		      .byte.b	$AD	; LDA
   1083  2152				   TerminalInputPort
   1084  2152		       21 e0	   DEBUGPORTIN .word.w	$E021
   1085  2154		       60		      rts
   1086  2155
   1087  2155							;======================================================================
   1088  2155							;Copy Quoted string to buffer, terminate with 0 byte
   1089  2155							; R0  Source tring points to tString type
   1090  2155							; x is terminator
   1091  2155							; R1 points to destinition location
   1092  2155							; On exit R0 contains length of copy Plus Term and leading bytes
   1093  2155
   1094  2155				   qstrcpy
   1095  2155		       20 e8 1d 	      jsr	pushR0
   1096  2158		       20 a5 21 	      jsr	IncR0	; point past the tString
   1097  215b		       20 a5 21 	      jsr	IncR0	; Point Past the opening "
   1098  215e		       a2 22		      ldx	#'"	; copy Termination
   1099  2160		       20 7a 21 	      jsr	pstrcpy
   1100  2163		       20 a5 21 	      jsr	IncR0	; point to "
   1101  2166		       20 a5 21 	      jsr	IncR0	; Point to next free byte
   1102  2169		       20 92 1e 	      jsr	popR1
   1103  216c		       38		      sec
   1104  216d		       a5 52		      lda	R0
   1105  216f		       e5 54		      sbc	R1
   1106  2171		       85 52		      sta	R0
   1107  2173		       a5 53		      lda	R0+1
   1108  2175		       e5 55		      sbc	R1+1
   1109  2177		       85 53		      sta	R0+1
   1110  2179		       60		      rts
   1111  217a
   1112  217a							;=========================================================================
   1113  217a							;Copy string from R0 to R1, terminator in x
   1114  217a							; On exit    R0 contains the length of the copy
   1115  217a				   pstrcpy
   1116  217a		       a0 00		      ldy	#0
   1117  217c		       86 58		      stx	R2
   1118  217e
   1119  217e				   strcpyLoop
   1120  217e		       b1 52		      lda	(R0),y
   1121  2180		       c5 58		      cmp	R2
   1122  2182		       f0 0a		      beq	strcpyDone
   1123  2184		       91 54		      sta	(R1),y
   1124  2186		       20 a5 21 	      jsr	IncR0
   1125  2189		       20 93 21 	      jsr	IncR1
   1126  218c		       90 f0		      bcc	strcpyLoop
   1127  218e				   strcpyDone
   1128  218e		       a9 00		      lda	#0
   1129  2190		       91 54		      sta	(R1),y
   1130  2192
   1131  2192		       60		      rts
   1132  2193
   1133  2193							;=========================================================================
   1134  2193							; on exit c is set on overflow
   1135  2193				   IncR1
   1136  2193		       48		      pha
   1137  2194		       18		      clc
   1138  2195		       a9 01		      lda	#1
   1139  2197		       65 54		      adc	R1
   1140  2199		       85 54		      sta	R1
   1141  219b		       90 06		      bcc	IncR1Done
   1142  219d		       a9 00		      lda	#0
   1143  219f		       65 55		      adc	R1+1
   1144  21a1		       85 55		      sta	R1+1
   1145  21a3				   IncR1Done
   1146  21a3		       68		      pla
   1147  21a4		       60		      rts
   1148  21a5							;=========================================================================
   1149  21a5							; on exit c is set on overflow
   1150  21a5				   IncR0
   1151  21a5		       48		      pha
   1152  21a6		       18		      clc
   1153  21a7		       a9 01		      lda	#1
   1154  21a9		       65 52		      adc	R0
   1155  21ab		       85 52		      sta	R0
   1156  21ad		       90 06		      bcc	IncR0Done
   1157  21af		       a9 00		      lda	#0
   1158  21b1		       65 53		      adc	R0+1
   1159  21b3		       85 53		      sta	R0+1
   1160  21b5				   IncR0Done
   1161  21b5		       68		      pla
   1162  21b6		       60		      rts
   1163  21b7
   1164  21b7
   1165  21b7
   1166  21b7
   1167  21b7
   1168  21b7
   1169  21b7
   1170  21b7
   1171  21b7
   1172  21b7
   1173  21b7
   1174  21b7
   1175  21b7
   1176  21b7
   1177  21b7
   1178  21b7
------- FILE mytb.asm
   2436  21b7
   2437  21b7					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  21b7					      include	"storage.asm"
      1  21b7							;
      2  21b7							;=====================================================
      3  21b7							;=====================================================
      4  21b7							;=====================================================
      5  21b7							; This file contains the functions for saving and
      6  21b7							; restoring programs from some sort of mass storage
      7  21b7							; device.  This particular version is for using the
      8  21b7							; Corsham Tech SD Card System.
      9  21b7							;=====================================================
     10  21b7							;=====================================================
     11  21b7							;=====================================================
     12  21b7
     13 U277c					      seg.u	TBData
     14 U277c		       00	   diskBufLength ds	1
     15 U277d		       00	   diskBufOffset ds	1
     16 U277e		       00 00 00 00*DiskFileName ds	64
     17 U27be
     18  21b7					      SEG	Code
     19  21b7
     20  21b7							;
     21  21b7							;=====================================================
     22  21b7							; Open a file for reading as a program.  The next
     23  21b7							; thing on the line should be the filename.
     24  21b7							;
     25  21b7				   iOPENREAD
     26  21b7					      if	XKIM || CTMON65
     27  21b7		       20 d1 21 	      jsr	setFileName	;Set the file name to open
     28  21ba		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  21bd		       90 07		      bcc	Ropenok	;branch if opened ok
     30  21bf							;
     31  21bf							; Open failed
     32  21bf							;
     33  21bf		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  21c1		       a9 00	   Rdfail2    lda	#0
     35  21c3		       4c b0 06 	      jmp	iErr2
     36  21c6							;
     37  21c6							; Clear counts and offsets so the next read will
     38  21c6							; cause the file to be read.
     39  21c6							;
     40  21c6		       a9 00	   Ropenok    lda	#0
     41  21c8		       8d 7d 27 	      sta	diskBufOffset
     42  21cb		       8d 7c 27 	      sta	diskBufLength
     43  21ce		       4c c3 02 	      jmp	NextIL
     44  21d1					      endif
     45  21d1
     46  21d1							;===============================================================
     47  21d1							; Set file name
     48  21d1				   setFileName
     49  21d1		       a4 51		      ldy	CUROFF
     50  21d3		       b1 4f		      lda	(CURPTR),y
     51  21d5		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  21d7		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  21d9
     54  21d9		       18		      clc
     55  21da		       98		      tya
     56  21db		       65 4f		      adc	CURPTR
     57  21dd		       85 52		      sta	R0	;LSB
     58  21df		       a5 50		      lda	CURPTR+1
     59  21e1		       69 00		      adc	#0
     60  21e3		       85 53		      sta	R0+1
     61  21e5		       a9 7e		      lda	#DiskFileName&$ff
     62  21e7		       85 54		      sta	R1
     63  21e9		       a9 27		      lda	#DiskFileName>>8
     64  21eb		       85 55		      sta	R1+1
     65  21ed		       20 55 21 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  21f0		       a5 52		      lda	R0
     67  21f2		       18		      clc
     68  21f3		       65 51		      adc	CUROFF	; add the current offset
     69  21f5		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  21f7
     71  21f7		       a0 7e		      ldy	#DiskFileName&$ff
     72  21f9		       a2 27		      ldx	#DiskFileName>>8
     73  21fb		       18		      clc
     74  21fc		       60		      rts
     75  21fd
     76  21fd				   setFileNameNotFound
     77  21fd		       68		      pla
     78  21fe		       68		      pla		; remove the return address from the stack
     79  21ff		       a9 00		      lda	#0
     80  2201		       a2 09		      ldx	#ERR_NO_FILENAME
     81  2203		       4c b0 06 	      jmp	iErr2
     82  2206
     83  2206							;
     84  2206							;==============================JUSTLOSTINTIME 08/02/2022========
     85  2206							;Remove a file from the disk
     86  2206				   iRMFILE
     87  2206					      if	XKIM || CTMON65
     88  2206		       20 d1 21 	      jsr	setFileName
     89  2209		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  220c		       90 07		      bcc	wrmOk	;branch if removed ok
     91  220e		       a9 00		      lda	#0
     92  2210		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  2212		       4c b0 06 	      jmp	iErr2
     94  2215				   wrmOk
     95  2215		       4c c3 02 	      jmp	NextIL
     96  2218
     97  2218					      endif
     98  2218							;
     99  2218							;=====================================================
    100  2218				   iOPENWRITE
    101  2218					      if	XKIM || CTMON65
    102  2218		       20 d1 21 	      jsr	setFileName
    103  221b		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  221e		       90 07		      bcc	Wopenok	;branch if opened ok
    105  2220							;
    106  2220							; Open failed
    107  2220							;
    108  2220		       a9 00	   Wdfail     lda	#0
    109  2222		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  2224		       4c b0 06 	      jmp	iErr2
    111  2227							;
    112  2227		       4c c3 02    Wopenok    jmp	NextIL
    113  222a					      endif
    114  222a							;
    115  222a							;=====================================================
    116  222a							; Gets a line of input from the disk file and puts it
    117  222a							; into LINBUF.
    118  222a							;
    119  222a							; On exit:
    120  222a							;    CURPTR points to LINBUF
    121  222a							;    LINBUF contains the line with 0 at the end.
    122  222a							;    Y has offset to first non-space character
    123  222a							;    CURROFF has the same as Y.
    124  222a							;
    125  222a				   iDGETLINE
    126  222a					      if	XKIM || CTMON65
    127  222a		       a2 7f		      ldx	#LINBUF&$ff
    128  222c		       86 4f		      stx	CURPTR
    129  222e		       a2 30		      ldx	#LINBUF>>8
    130  2230		       86 50		      stx	CURPTR+1
    131  2232							;
    132  2232		       a2 00		      ldx	#0	;offset
    133  2234		       8e 03 31    iDgetLoop  stx	getlinx
    134  2237		       20 a2 22 	      jsr	getNextFileByte
    135  223a		       b0 16		      bcs	iGetEOF
    136  223c		       c9 0d		      cmp	#CR
    137  223e		       f0 0d		      beq	iGetEOL
    138  2240		       c9 0a		      cmp	#LF
    139  2242		       f0 09		      beq	iGetEOL
    140  2244		       ae 03 31 	      ldx	getlinx
    141  2247		       9d 7f 30 	      sta	LINBUF,x
    142  224a		       e8		      inx
    143  224b		       d0 e7		      bne	iDgetLoop
    144  224d							;
    145  224d							; Handle end of line.	If the line has nothing, loop
    146  224d							; back and get another line.
    147  224d							;
    148  224d		       ae 03 31    iGetEOL    ldx	getlinx	;blank line?
    149  2250		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  2252							;
    151  2252							; This can fall through when there is a line, or
    152  2252							; called directly when EOF is encountered.
    153  2252							;
    154  2252		       ae 03 31    iGetEOF    ldx	getlinx
    155  2255		       a9 00		      lda	#0
    156  2257		       9d 7f 30 	      sta	LINBUF,x
    157  225a		       a0 00		      ldy	#0
    158  225c		       20 2a 1f 	      jsr	SkipSpaces
    159  225f		       20 2c 10 	      jsr	ParseInputLine
    160  2262		       a9 29		      lda	#TOKENBUFFER&$ff
    161  2264		       85 4f		      sta	CURPTR
    162  2266		       a9 0f		      lda	#TOKENBUFFER>>8
    163  2268		       85 50		      sta	CURPTR+1
    164  226a		       a9 01		      lda	#1
    165  226c		       85 51		      sta	CUROFF
    166  226e		       4c c3 02 	      jmp	NextIL
    167  2271					      endif
    168  2271
    169  2271							;
    170  2271							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  2271							; DISK
    172  2271							;
    173  2271				   iDDIR
    174  2271					      if	XKIM || CTMON65
    175  2271		       20 30 f0 	      jsr	DiskDir
    176  2274							;
    177  2274							; Get/Display each entry
    178  2274							;
    179  2274		       a2 27	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  2276		       a0 7e		      ldy	#DiskFileName&$ff
    181  2278		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  227b		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  227d		       20 82 14 	      jsr	puts
      0  2280					      db	"   ",0
      1  2280		       20 20 20 00	      .byte.b	"   ",0
    185  2284							; Print the line to the console
    186  2284		       a2 27		      ldx	#DiskFileName>>8	;pointer to buffer
    187  2286		       a0 7e		      ldy	#DiskFileName&$ff
    188  2288		       a5 00		      lda	0
    189  228a		       20 c0 14 	      jsr	PrtStr	;else print name
    190  228d		       20 18 f0 	      jsr	crlf
    191  2290
    192  2290		       4c 74 22 	      jmp	DiskDirLoop	;do next entry
    193  2293
    194  2293		       4c c3 02    DiskDirEnd jmp	NextIL
    195  2296					      endif
    196  2296							;
    197  2296							;=====================================================
    198  2296							; Does a LIST to a Disk file.
    199  2296							;
    200  2296				   iDLIST
    201  2296					      if	XKIM || CTMON65
    202  2296		       20 d1 22 	      jsr	SetOutDisk
    203  2299		       4c 4e 08 	      jmp	iLST2
    204  229c					      endif
    205  229c							;
    206  229c							;=====================================================
    207  229c							; Closes any pending disk file.  Okay to call if there
    208  229c							; is no open file.
    209  229c							;
    210  229c				   iDCLOSE
    211  229c					      if	XKIM || CTMON65
    212  229c		       20 42 f0 	      jsr	DiskClose
    213  229f		       4c c3 02 	      jmp	NextIL
    214  22a2					      endif
    215  22a2							;
    216  22a2							;=====================================================
    217  22a2							; This gets the next byte from an open disk file.  If
    218  22a2							; there are no more bytes left, this returns C set.
    219  22a2							; Else, C is clear and A contains the character.
    220  22a2							;
    221  22a2				   getNextFileByte
    222  22a2					      if	XKIM || CTMON65
    223  22a2		       ae 7d 27 	      ldx	diskBufOffset
    224  22a5		       ec 7c 27 	      cpx	diskBufLength
    225  22a8		       d0 14		      bne	hasdata	;branch if still data
    226  22aa							;
    227  22aa							; There is no data left in the buffer, so read a
    228  22aa							; block from the SD system.
    229  22aa							;
    230  22aa		       a9 84		      lda	#BUFFER_SIZE
    231  22ac		       a2 df		      ldx	#buffer>>8
    232  22ae		       a0 0a		      ldy	#buffer&$ff
    233  22b0		       20 3c f0 	      jsr	DiskRead
    234  22b3		       b0 12		      bcs	getNextEof
    235  22b5							;
    236  22b5							; A contains the number of bytes actually read.
    237  22b5							;
    238  22b5		       8d 7c 27 	      sta	diskBufLength	;save length
    239  22b8		       c9 00		      cmp	#0	;shouldn't happen
    240  22ba		       f0 0b		      beq	getNextEof
    241  22bc							;
    242  22bc		       a2 00		      ldx	#0
    243  22be		       bd 0a df    hasdata    lda	buffer,x
    244  22c1		       e8		      inx
    245  22c2		       8e 7d 27 	      stx	diskBufOffset
    246  22c5		       18		      clc
    247  22c6		       60		      rts
    248  22c7							;
    249  22c7		       a9 00	   getNextEof lda	#0
    250  22c9		       8d 7d 27 	      sta	diskBufOffset
    251  22cc		       8d 7c 27 	      sta	diskBufLength
    252  22cf		       38		      sec
    253  22d0		       60		      rts
    254  22d1							;
    255  22d1							;=====================================================
    256  22d1							; Set output vector to the disk output function
    257  22d1							;
    258  22d1		       a9 dc	   SetOutDisk lda	#DOUT&$ff
    259  22d3		       8d 10 31 	      sta	BOutVec
    260  22d6		       a9 22		      lda	#DOUT/256
    261  22d8		       8d 11 31 	      sta	BOutVec+1
    262  22db		       60		      rts
    263  22dc							;
    264  22dc							;=====================================================
    265  22dc
    266  22dc		       8e 7e 27    DOUT       stx	DiskFileName
    267  22df		       8c 7f 27 	      sty	DiskFileName+1
    268  22e2		       8d 0a df 	      sta	buffer
    269  22e5		       a9 01		      lda	#1
    270  22e7		       a0 0a		      ldy	#buffer&$ff
    271  22e9		       a2 df		      ldx	#buffer>>8
    272  22eb		       20 3f f0 	      jsr	DiskWrite
    273  22ee		       ae 7e 27 	      ldx	DiskFileName
    274  22f1		       ac 7f 27 	      ldy	DiskFileName+1
    275  22f4
    276  22f4							;
    277  22f4							; need error checking here
    278  22f4							;
    279  22f4		       60		      rts
    280  22f5					      endif
    281  22f5
    282  22f5
------- FILE mytb.asm
   2439  22f5					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  22f5					      include	"IL.inc"
      1  22f5
      2  22f5							;=====================================================
      3  22f5							; IL.inc
      4  22f5							; These are macros for IL instructions
      5  22f5							;
      6  22f5					      mac	dw
      7  22f5					      .word	{0}
      8  22f5					      endm
      9  22f5					      mac	db
     10  22f5					      .byte	{0}
     11  22f5					      endm
     12  22f5					      macro	xinit
     13  22f5					      db	0
     14  22f5					      endm		;reset the il to start clear all
     15  22f5							;
     16  22f5					      macro	done
     17  22f5					      db	1
     18  22f5					      endm		;print an error if not end of line
     19  22f5							;
     20  22f5					      macro	prs
     21  22f5					      db	2
     22  22f5					      endm		;print a quoted string
     23  22f5							;
     24  22f5					      macro	prn
     25  22f5					      db	3
     26  22f5					      endm		;print a number
     27  22f5							;
     28  22f5					      macro	spc
     29  22f5					      db	4
     30  22f5					      endm		;print space til new tabstop
     31  22f5							;
     32  22f5					      macro	nline
     33  22f5					      db	5
     34  22f5					      endm		;print a new line crlf
     35  22f5							;
     36  22f5							; My NXT is a bit different in that it takes one
     37  22f5							; parameter, which is an address.  If the BASIC
     38  22f5							; program is currently running then move to the
     39  22f5							; next line and continue execution.  However, if
     40  22f5							; in direct mode, jump to the specified IL label.
     41  22f5							;
     42  22f5					      macro	nxt
     43  22f5					      db	6
     44  22f5					      dw	{1}	; addr
     45  22f5					      endm		; addr
     46  22f5							;
     47  22f5					      macro	xfer
     48  22f5					      db	7
     49  22f5					      endm
     50  22f5							;
     51  22f5					      macro	sav
     52  22f5					      db	8
     53  22f5					      db	{1}
     54  22f5					      endm
     55  22f5							;
     56  22f5							;  Passed jump if function called, and true false value returned
     57  22f5					      macro	rstr
     58  22f5					      db	9
     59  22f5					      db	({1}-*)-1	;(addr-*)-1
     60  22f5					      db	{2}
     61  22f5					      endm
     62  22f5							;
     63  22f5					      macro	cmpr
     64  22f5					      db	10
     65  22f5					      endm
     66  22f5							;
     67  22f5					      macro	innum
     68  22f5					      db	11
     69  22f5					      endm
     70  22f5							;
     71  22f5					      macro	fin
     72  22f5					      db	12
     73  22f5					      endm
     74  22f5							;
     75  22f5							; ERR is followed by an error number.	The error
     76  22f5							; code is printed along with the line number.
     77  22f5							; Control is passed to the statement set with
     78  22f5							; the ERRGOTO statement.
     79  22f5							;
     80  22f5					      macro	errmsg
     81  22f5					      db	13
     82  22f5					      dw	{1}	;ecode
     83  22f5					      endm		;ecode
     84  22f5							;
     85  22f5					      macro	add
     86  22f5					      db	14
     87  22f5					      endm
     88  22f5							;
     89  22f5					      macro	sub
     90  22f5					      db	15
     91  22f5					      endm
     92  22f5							;
     93  22f5					      macro	neg
     94  22f5					      db	16
     95  22f5					      endm
     96  22f5							;
     97  22f5					      macro	mul
     98  22f5					      db	17
     99  22f5					      endm
    100  22f5							;
    101  22f5					      macro	div
    102  22f5					      db	18
    103  22f5					      endm
    104  22f5							;
    105  22f5					      macro	store
    106  22f5					      db	19
    107  22f5					      endm
    108  22f5							;
    109  22f5					      macro	ind
    110  22f5					      db	20
    111  22f5					      endm
    112  22f5							;
    113  22f5					      macro	lst
    114  22f5					      db	21
    115  22f5					      endm
    116  22f5							;
    117  22f5					      macro	init
    118  22f5					      db	22
    119  22f5					      endm
    120  22f5							;
    121  22f5					      macro	getline
    122  22f5					      db	23
    123  22f5					      endm
    124  22f5							;
    125  22f5					      macro	insert
    126  22f5					      db	24
    127  22f5					      endm
    128  22f5							;
    129  22f5					      macro	rtn
    130  22f5					      db	25
    131  22f5					      endm
    132  22f5							;
    133  22f5					      macro	exit
    134  22f5					      db	26
    135  22f5					      endm
    136  22f5							;
    137  22f5					      macro	lit
    138  22f5					      db	27
    139  22f5					      dw	{1}	;value
    140  22f5					      endm		; value LIT
    141  22f5							;
    142  22f5					      macro	call
    143  22f5					      db	28
    144  22f5					      dw	{1}	;addr
    145  22f5					      endm		;addr
    146  22f5							;
    147  22f5							; IJMP will set the IL PC to the specified value.
    148  22f5							;
    149  22f5					      macro	ijmp
    150  22f5					      db	29
    151  22f5					      dw	{1}	;addr
    152  22f5					      endm		;addr
    153  22f5							;
    154  22f5					      macro	vinit
    155  22f5					      db	30
    156  22f5					      endm
    157  22f5							;
    158  22f5							; ERRGOTO sets the point in the code where the IL
    159  22f5							; interpreter will go after any error.
    160  22f5							;
    161  22f5					      macro	errgoto
    162  22f5					      db	31
    163  22f5					      dw	{1}	;addr
    164  22f5					      endm		;addr
    165  22f5							;
    166  22f5					      macro	tst
    167  22f5					      db	32
    168  22f5					      db	({1}-*)-1	;(addr-*)-1
    169  22f5					      db	{2},0	;string,0
    170  22f5					      endm		;addr,string
    171  22f5							;
    172  22f5					      macro	tstv
    173  22f5					      db	33
    174  22f5					      db	({1}-*)-1	;(addr-*)-1
    175  22f5					      endm		;addr
    176  22f5							;
    177  22f5					      macro	tstl
    178  22f5					      db	34
    179  22f5					      db	({1}-*)-1	;(addr-*)-1
    180  22f5					      endm		;addr
    181  22f5							;
    182  22f5					      macro	tstn
    183  22f5					      db	35
    184  22f5					      db	({1}-*)-1	;(addr-*)-1
    185  22f5					      endm		;addr
    186  22f5							;
    187  22f5							; FREE returns the amount of free RAM on top of
    188  22f5							; the stack.  This is the amount of room the user
    189  22f5							; program has available.
    190  22f5							;
    191  22f5					      macro	free
    192  22f5					      db	36
    193  22f5					      endm
    194  22f5							;
    195  22f5							; RANDOM takes the top item off the stack and
    196  22f5							; replaces it with a random number that is
    197  22f5							; MOD the initial value.  Ie, if the TOS is
    198  22f5							; 42 then RANDOM returns a value from 0 to 41.
    199  22f5							;
    200  22f5					      macro	random
    201  22f5					      db	37
    202  22f5					      endm
    203  22f5							;
    204  22f5							; ABS will replace the top of stack with the
    205  22f5							; absolute value.
    206  22f5							;
    207  22f5					      macro	abs
    208  22f5					      db	38
    209  22f5					      endm
    210  22f5							;
    211  22f5							; OPENREAD opens a file for reading, as in getting
    212  22f5							; statements from it.
    213  22f5							;
    214  22f5					      macro	openread
    215  22f5					      db	39
    216  22f5					      endm
    217  22f5							;
    218  22f5							; OPENWRITE opens a file for writing, as in saving
    219  22f5							; the current program to it.
    220  22f5							;
    221  22f5					      macro	openwrite
    222  22f5					      db	40
    223  22f5					      endm
    224  22f5							;
    225  22f5							; DCLOSE closes any open disk file.
    226  22f5							;
    227  22f5					      macro	dclose
    228  22f5					      db	41
    229  22f5					      endm
    230  22f5							;
    231  22f5							; DGETLINE gets one line from the disk file and puts it
    232  22f5							; into LINBUFF.
    233  22f5							;
    234  22f5					      macro	dgetline
    235  22f5					      db	42
    236  22f5					      endm
    237  22f5							;
    238  22f5							; DLIST saves the program to an open disk file.
    239  22f5							;
    240  22f5					      macro	dlist
    241  22f5					      db	43
    242  22f5					      endm
    243  22f5							; DDIR list the current directory
    244  22f5							;
    245  22f5					      macro	ddir
    246  22f5					      db	44
    247  22f5					      endm
    248  22f5
    249  22f5							; RMFILE remove a fle from disk
    250  22f5					      macro	rmfile
    251  22f5					      db	45
    252  22f5					      endm
    253  22f5
    254  22f5							; CLEARSCREEN clear the screen
    255  22f5					      macro	clearscreen
    256  22f5					      db	46
    257  22f5					      endm
    258  22f5							; POKEMEM Poke value into memory
    259  22f5					      macro	pokemem
    260  22f5					      db	47
    261  22f5					      endm
    262  22f5							; PEEKMEM peek at value in memory
    263  22f5					      macro	peekmem
    264  22f5					      db	48
    265  22f5					      endm
    266  22f5							; TSTLET Test if the statement is a let without the keyword let
    267  22f5					      macro	tstlet
    268  22f5					      db	49
    269  22f5					      db	({1}-*)-1	;(addr-*)-1
    270  22f5					      endm		;addr
    271  22f5							; TSTDONE if we reach the end of a statement
    272  22f5					      macro	tstdone
    273  22f5					      db	50
    274  22f5					      db	({1}-*)-1	;(addr-*)-1
    275  22f5					      endm		;addr
    276  22f5							; GETCHAR	get a character from the input line leave it in RO
    277  22f5					      macro	getchar
    278  22f5					      db	51
    279  22f5					      endm
    280  22f5							; PUTCHAR	Put a character to the terminal
    281  22f5					      macro	putchar
    282  22f5					      db	52
    283  22f5					      endm
    284  22f5							; Call		Call a machine function return a to stack
    285  22f5					      macro	callfunc
    286  22f5					      db	53
    287  22f5					      endm
    288  22f5
    289  22f5							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    290  22f5					      macro	ibranch
    291  22f5					      db	54
    292  22f5					      endm
    293  22f5
    294  22f5							; TSTSTR	 Tests for the open quote in a string
    295  22f5					      macro	tststr
    296  22f5					      db	55
    297  22f5					      db	({1}-*)-1	;(addr-*)-1
    298  22f5					      endm
    299  22f5							; SETIRQ	Sets the line number to run when an irq happens irq 550
    300  22f5					      macro	setirq
    301  22f5					      db	56
    302  22f5					      endm
    303  22f5
    304  22f5							; TSTIRQ	Test for irq pending,
    305  22f5							;		if so push the IRQ LINE NUMBER into RO, onto stack
    306  22f5					      macro	tstirq
    307  22f5					      db	57
    308  22f5					      db	({1}-*)-1	;(addr-*)-1
    309  22f5					      endm
    310  22f5
    311  22f5							; IRET    return from interupt service
    312  22f5					      macro	iret
    313  22f5					      db	58
    314  22f5					      endm
    315  22f5
    316  22f5							; INSTR   read a string from the input
    317  22f5					      macro	instr
    318  22f5					      db	59
    319  22f5					      endm
    320  22f5
    321  22f5							; MODULO Returns the remainder of the division
    322  22f5					      macro	modulo
    323  22f5					      db	60
    324  22f5					      endm
    325  22f5							; Set a task line
    326  22f5					      macro	taskcreate
    327  22f5					      db	61
    328  22f5					      endm
    329  22f5							; End a task
    330  22f5					      macro	etask
    331  22f5					      db	62
    332  22f5					      endm
    333  22f5							; Skip to next task
    334  22f5					      macro	ntask
    335  22f5					      db	63
    336  22f5					      endm
    337  22f5							; Subscript
    338  22f5					      macro	subscript
    339  22f5					      db	64
    340  22f5					      db	{1}
    341  22f5					      endm
    342  22f5							; KILL Task
    343  22f5					      macro	taskkill
    344  22f5					      db	65
    345  22f5					      endm
    346  22f5							; STAT Task
    347  22f5					      macro	taskstat
    348  22f5					      db	66
    349  22f5					      endm
    350  22f5							;  output value as hex
    351  22f5					      macro	hexprt
    352  22f5					      db	67
    353  22f5					      endm
    354  22f5							;  Read in background has completed
    355  22f5					      macro	readcomplete
    356  22f5					      db	68
    357  22f5					      endm
    358  22f5							;  ReadInput line
    359  22f5					      macro	readstart
    360  22f5					      db	69
    361  22f5					      endm
    362  22f5							; Startio request
    363  22f5					      macro	startio
    364  22f5					      db	70
    365  22f5					      endm
    366  22f5							; Endio
    367  22f5					      macro	endio
    368  22f5					      db	71
    369  22f5					      endm
    370  22f5							; Logical not
    371  22f5					      macro	lognot
    372  22f5					      db	72
    373  22f5					      endm
    374  22f5							; Logical OR
    375  22f5					      macro	logor
    376  22f5					      db	73
    377  22f5					      endm
    378  22f5							;Logical and
    379  22f5					      macro	logand
    380  22f5					      db	74
    381  22f5					      endm
    382  22f5							;Logical XOR
    383  22f5					      macro	logxor
    384  22f5					      db	75
    385  22f5					      endm
    386  22f5							;Wait for task to complete, or list of tasks
    387  22f5					      macro	wtask
    388  22f5					      db	76
    389  22f5					      db	({1}-*)-1	;(addr-*)-1
    390  22f5					      endm
    391  22f5							;Get the current task id
    392  22f5					      MACRO	taskpid
    393  22f5					      db	77
    394  22f5					      endm
    395  22f5							;Trace the basic execution
    396  22f5					      Macro	traceprogram
    397  22f5					      db	78
    398  22f5					      endm
    399  22f5							;Do a basic program Trace
    400  22f5					      Macro	debugbasic
    401  22f5					      db	79
    402  22f5					      endm
    403  22f5
    404  22f5							; Inter Process communications instructions
    405  22f5					      Macro	ipcsend
    406  22f5					      db	80
    407  22f5					      endm
    408  22f5					      Macro	ipcreceive
    409  22f5					      db	81
    410  22f5					      endm
    411  22f5					      Macro	ipccheck
    412  22f5					      db	82
    413  22f5					      endm
    414  22f5					      Macro	ipcio
    415  22f5					      db	83
    416  22f5					      endm
    417  22f5					      Macro	pushmathstack
    418  22f5					      db	84
    419  22f5					      endm
    420  22f5					      Macro	popmathstack
    421  22f5					      db	85
    422  22f5					      endm
    423  22f5					      Macro	savemathstack
    424  22f5					      db	86
    425  22f5					      endm
    426  22f5					      Macro	restoremathstack
    427  22f5					      db	87
    428  22f5					      endm
    429  22f5					      Macro	incparmcount
    430  22f5					      db	88
    431  22f5					      endm
    432  22f5					      Macro	taskgetmathstack
    433  22f5					      db	89
    434  22f5					      endm
    435  22f5					      Macro	taskenable
    436  22f5					      db	90
    437  22f5					      endm
    438  22f5					      Macro	tasksuspend
    439  22f5					      db	91
    440  22f5					      endm
    441  22f5					      Macro	taskputmathptr
    442  22f5					      db	92
    443  22f5					      endm
    444  22f5							; Test for an extension type of variable that allows access to a tasks variables
    445  22f5							; Using  PID!<Var name>
    446  22f5					      Macro	tstvt
    447  22f5					      db	93
    448  22f5					      db	({1}-*)-1	;(addr-*)-1
    449  22f5					      endm
    450  22f5
    451  22f5							; Provide access to R2 for the IL program
    452  22f5					      Macro	setr2
    453  22f5					      db	94
    454  22f5					      db	{1}	; R2 is only one byte
    455  22f5					      endm
    456  22f5
    457  22f5							;Move stack top to temp
    458  22f5					      Macro	stk2tmp
    459  22f5					      db	95
    460  22f5					      endm
    461  22f5
    462  22f5					      Macro	tmp2stk
    463  22f5					      db	96
    464  22f5					      endm
    465  22f5
    466  22f5					      Macro	tstbyte
    467  22f5					      db	97
    468  22f5					      db	({1}-*)-1	; (addr-*)-1 goto if match
    469  22f5					      dw	{2}	; address to check
    470  22f5					      db	{3}	; Value to compare
    471  22f5					      endm
    472  22f5
    473  22f5					      Macro	incvar
    474  22f5					      db	98
    475  22f5					      endm
    476  22f5					      Macro	decvar
    477  22f5					      db	99
    478  22f5					      endm
    479  22f5
    480  22f5					      Macro	slice
    481  22f5					      db	100
    482  22f5					      endm
    483  22f5
    484  22f5					      Macro	tstb
    485  22f5					      db	101
    486  22f5					      db	({1}-*)-1
    487  22f5					      db	{2}
    488  22f5					      endm
    489  22f5
    490  22f5					      Macro	tstw
    491  22f5					      db	102
    492  22f5					      db	({1}-*)-1
    493  22f5					      dw	{2}
    494  22f5					      endm
    495  22f5
    496  22f5					      Macro	ongoto
    497  22f5					      db	103
    498  22f5					      dw	{1}
    499  22f5					      dw	{2}
    500  22f5					      endm
    501  22f5
    502  22f5					      Macro	tstrelop
    503  22f5					      db	104
    504  22f5					      db	({1}-*)-1
    505  22f5					      endm
    506  22f5
    507  22f5					      Macro	repeatline
    508  22f5					      db	105
    509  22f5					      endm
    510  22f5
    511  22f5							; Check for a precompiled branch, will take branch if precompiled value present
    512  22f5					      Macro	tstbranch
    513  22f5					      db	106
    514  22f5					      db	({1}-*)-1
    515  22f5					      endm
    516  22f5
    517  22f5					      Macro	fastxfer
    518  22f5					      db	107
    519  22f5					      endm
    520  22f5
    521  22f5							; Set all io to to a terminal for input output
    522  22f5							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    523  22f5							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    524  22f5					      Macro	setterminal
    525  22f5					      db	108
    526  22f5					      endm
    527  22f5
    528  22f5							;Fetch a single byte from memory
    529  22f5					      Macro	indb
    530  22f5					      db	109
    531  22f5					      endm
    532  22f5
    533  22f5							; Set a block of memory to a fixed value, byte or word
    534  22f5							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    535  22f5					      Macro	setblock
    536  22f5					      db	110
    537  22f5					      db	{1}	; the data type to initialize	tByte or tInteger
    538  22f5					      endm
    539  22f5
    540  22f5							; Copy a block of memory
    541  22f5							; Stack must contain source address, destination address, length in bytes
    542  22f5					      Macro	copyblock
    543  22f5					      db	111
    544  22f5					      endm
------- FILE mytb.asm
   2441  22f5							;
   2442  22f5				  -	      if	FIXED
   2443  22f5				  -	      org	$1000
   2444  22f5					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  22f5					      include	"basic.il"
      1  22f5					      seg	Code
      2  22f5							; on goto table
      3  22f5							; format :   first byte is value Base, subtracted from value found
      4  22f5							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  22f5				   BasicStmts
      0  22f5					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  22f5		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  22f7					      dw	ekLet
      1  22f7		       7a 23		      .word.w	ekLet
      0  22f9					      dw	ekInc
      1  22f9		       ac 23		      .word.w	ekInc
      0  22fb					      dw	ekDec
      1  22fb		       b9 23		      .word.w	ekDec
      0  22fd					      dw	ekIreturn
      1  22fd		       c6 23		      .word.w	ekIreturn
      0  22ff					      dw	ekIf
      1  22ff		       cb 23		      .word.w	ekIf
      0  2301					      dw	ekThen
      1  2301		       d1 23		      .word.w	ekThen
      0  2303					      dw	ekGoto
      1  2303		       d5 23		      .word.w	ekGoto
      0  2305					      dw	ekGosub
      1  2305		       e9 23		      .word.w	ekGosub
      0  2307					      dw	ekReturn
      1  2307		       f0 23		      .word.w	ekReturn
      0  2309					      dw	ekRem
      1  2309		       10 24		      .word.w	ekRem
      0  230b					      dw	ekPrint	; should be entry for print
      1  230b		       26 24		      .word.w	ekPrint
      0  230d					      dw	ekTaske
      1  230d		       73 24		      .word.w	ekTaske
      0  230f					      dw	ekTaskn
      1  230f		       89 24		      .word.w	ekTaskn
      0  2311					      dw	ekTaskw
      1  2311		       90 24		      .word.w	ekTaskw
      0  2313					      dw	ekPoke
      1  2313		       ab 24		      .word.w	ekPoke
      0  2315					      dw	ekPutch
      1  2315		       0d 25		      .word.w	ekPutch
      0  2317					      dw	ekCls
      1  2317		       18 25		      .word.w	ekCls
      0  2319					      dw	ekInput
      1  2319		       1f 25		      .word.w	ekInput
      0  231b					      dw	ekEnd
      1  231b		       48 25		      .word.w	ekEnd
      0  231d					      dw	ekIrq
      1  231d		       4c 25		      .word.w	ekIrq
      0  231f					      dw	ekKill
      1  231f		       57 25		      .word.w	ekKill
      0  2321					      dw	ekList
      1  2321		       62 25		      .word.w	ekList
      0  2323					      dw	ekRun
      1  2323		       67 25		      .word.w	ekRun
      0  2325					      dw	ekNew
      1  2325		       70 25		      .word.w	ekNew
      0  2327					      dw	ekSlice
      1  2327		       74 25		      .word.w	ekSlice
      0  2329					      dw	ekTrace
      1  2329		       7f 25		      .word.w	ekTrace
      0  232b					      dw	ekExit
      1  232b		       90 25		      .word.w	ekExit
      0  232d					      dw	ekSave
      1  232d		       91 25		      .word.w	ekSave
      0  232f					      dw	ekLoad
      1  232f		       97 25		      .word.w	ekLoad
      0  2331					      dw	ekErase
      1  2331		       aa 25		      .word.w	ekErase
      0  2333					      dw	ekDir
      1  2333		       a3 25		      .word.w	ekDir
      0  2335					      dw	ekSetTerm
      1  2335		       16 24		      .word.w	ekSetTerm
      0  2337					      dw	ekSetMemB
      1  2337		       c2 24		      .word.w	ekSetMemB
      0  2339					      dw	ekSetMemW
      1  2339		       ce 24		      .word.w	ekSetMemW
      0  233b					      dw	ekCopyMem
      1  233b		       f0 24		      .word.w	ekCopyMem
     42  233d							;
     43  233d							; Logical operators
      0  233d				   BasicLogical db	kOr,3
      1  233d		       25 03		      .byte.b	kOr,3
      0  233f					      dw	ekOr
      1  233f		       d5 25		      .word.w	ekOr
      0  2341					      dw	ekXor
      1  2341		       da 25		      .word.w	ekXor
      0  2343					      dw	ekAnd
      1  2343		       d0 25		      .word.w	ekAnd
     48  2345
     49  2345							;functions returning values
     50  2345
      0  2345				   BasicFuncs db	kBeginFunc,kFuncCount
      1  2345		       28 10		      .byte.b	kBeginFunc,kFuncCount
      0  2347					      dw	ekTrue
      1  2347		       3a 26		      .word.w	ekTrue
      0  2349					      dw	ekFalse
      1  2349		       3e 26		      .word.w	ekFalse
      0  234b					      dw	ekFree
      1  234b		       42 26		      .word.w	ekFree
      0  234d					      dw	ekGetch
      1  234d		       4a 26		      .word.w	ekGetch
      0  234f					      dw	ekPeek
      1  234f		       61 26		      .word.w	ekPeek
      0  2351					      dw	ekTask
      1  2351		       6c 26		      .word.w	ekTask
      0  2353					      dw	ekIpcc
      1  2353		       b8 26		      .word.w	ekIpcc
      0  2355					      dw	ekIpcs
      1  2355		       93 26		      .word.w	ekIpcs
      0  2357					      dw	ekIpcr
      1  2357		       a4 26		      .word.w	ekIpcr
      0  2359					      dw	ekRnd
      1  2359		       c3 26		      .word.w	ekRnd
      0  235b					      dw	ekStat
      1  235b		       e1 26		      .word.w	ekStat
      0  235d					      dw	ekAbs
      1  235d		       d6 26		      .word.w	ekAbs
      0  235f					      dw	ekCall
      1  235f		       ee 26		      .word.w	ekCall
      0  2361					      dw	ekGofn
      1  2361		       07 27		      .word.w	ekGofn
      0  2363					      dw	ekPid
      1  2363		       ec 26		      .word.w	ekPid
      0  2365					      dw	ekAddr
      1  2365		       52 26		      .word.w	ekAddr
     68  2367
     69  2367							;=====================================================
     70  2367							; This is the IL of the BASIC (or whatever) language.
     71  2367							; Because of the way macros are implemented by as65,
     72  2367							; labels can't be on the same line as a macro
     73  2367							; invocation, so that's why labels are on separate
     74  2367							; lines.
     75  2367							;
     76  2367		       23 67	   IL	      equ	*
     77  2367
     78  2367							;THE IL CONTROL SECTION
     79  2367
     80  2367				   START
      0  2367					      INIT		;INITIALIZE
      0  2367					      db	22
      1  2367		       16		      .byte.b	22
      0  2368					      NLINE		;WRITE CRLF
      0  2368					      db	5
      1  2368		       05		      .byte.b	5
      0  2369					      ERRGOTO	CO	;where to go after an error
      0  2369					      db	31
      1  2369		       1f		      .byte.b	31
      0  236a					      dw	CO
      1  236a		       6d 23		      .word.w	CO
      0  236c					      VINIT		;clear all variables
      0  236c					      db	30
      1  236c		       1e		      .byte.b	30
     85  236d							;
     86  236d							; This is where we jump to get a line of commands or
     87  236d							; a program from the user.
     88  236d							;
     89  236d				   CO
      0  236d					      GETLINE		;WRITE PROMPT AND GET LINE
      0  236d					      db	23
      1  236d		       17		      .byte.b	23
      0  236e					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  236e					      db	34
      1  236e		       22		      .byte.b	34
      0  236f					      db	(XEC-*)-1
      1  236f		       04		      .byte.b	(XEC-*)-1
      0  2370					      INSERT		;INSERT IT (MAY BE DELETE)
      0  2370					      db	24
      1  2370		       18		      .byte.b	24
      0  2371					      IJMP	CO
      0  2371					      db	29
      1  2371		       1d		      .byte.b	29
      0  2372					      dw	CO
      1  2372		       6d 23		      .word.w	CO
     94  2374				   XEC
      0  2374					      XINIT		;INITIALIZE
      0  2374					      db	0
      1  2374		       00		      .byte.b	0
     96  2375							;============================================================================
     97  2375							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     98  2375							;
     99  2375				   STMT
      0  2375					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  2375					      db	79
      1  2375		       4f		      .byte.b	79
      0  2376					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  2376					      db	57
      1  2376		       39		      .byte.b	57
      0  2377					      db	(notirq-*)-1
      1  2377		       00		      .byte.b	(notirq-*)-1
    102  2378							;==========================================================================================
    103  2378							; Process a let statement implied or explicit.
    104  2378							;
    105  2378				   notirq
      0  2378					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  2378					      db	49
      1  2378		       31		      .byte.b	49
      0  2379					      db	(DoVector-*)-1
      1  2379		       2d		      .byte.b	(DoVector-*)-1
    107  237a				   ekLet
      0  237a					      TSTV	DoVector	; Test for variable
      0  237a					      db	33
      1  237a		       21		      .byte.b	33
      0  237b					      db	(DoVector-*)-1
      1  237b		       2b		      .byte.b	(DoVector-*)-1
      0  237c					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  237c					      db	28
      1  237c		       1c		      .byte.b	28
      0  237d					      dw	FactVarPtrNoTst
      1  237d		       2a 27		      .word.w	FactVarPtrNoTst
    110  237f
    111  237f				   LETINDEX_ALL
      0  237f					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  237f					      db	101
      1  237f		       65		      .byte.b	101
      0  2380					      db	(ERRMissingEquals-*)-1
      1  2380		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  2381					      db	oEqual
      1  2381		       f2		      .byte.b	oEqual
    113  2382				   LETBE
      0  2382					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  2382					      db	97
      1  2382		       61		      .byte.b	97
      0  2383					      db	(LETAssignByte-*)-1
      1  2383		       10		      .byte.b	(LETAssignByte-*)-1
      0  2384					      dw	R2
      1  2384		       58 00		      .word.w	R2
      0  2386					      db	tByte
      1  2386		       a2		      .byte.b	tByte
      0  2387					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  2387					      db	28
      1  2387		       1c		      .byte.b	28
      0  2388					      dw	EXPR
      1  2388		       b2 25		      .word.w	EXPR
      0  238a					      DONE		; REPORT ERROR IF NOT NEXT
      0  238a					      db	1
      1  238a		       01		      .byte.b	1
      0  238b					      SETR2	tInteger	; Store an integer type
      0  238b					      db	94
      1  238b		       5e		      .byte.b	94
      0  238c					      db	tInteger
      1  238c		       a1		      .byte.b	tInteger
      0  238d					      STORE		; STORE RESULT at variable address
      0  238d					      db	19
      1  238d		       13		      .byte.b	19
      0  238e					      NXT	CO	; AND SEQUENCE TO NEXT
      0  238e					      db	6
      1  238e		       06		      .byte.b	6
      0  238f					      dw	CO
      1  238f		       6d 23		      .word.w	CO
      0  2391					      IJMP	STMT	; Next statement
      0  2391					      db	29
      1  2391		       1d		      .byte.b	29
      0  2392					      dw	STMT
      1  2392		       75 23		      .word.w	STMT
    121  2394
    122  2394				   LETAssignByte
      0  2394					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  2394					      db	28
      1  2394		       1c		      .byte.b	28
      0  2395					      dw	EXPR
      1  2395		       b2 25		      .word.w	EXPR
      0  2397					      DONE		; REPORT ERROR IF NOT NEXT
      0  2397					      db	1
      1  2397		       01		      .byte.b	1
      0  2398					      SETR2	tByte	; Set to store a byte value
      0  2398					      db	94
      1  2398		       5e		      .byte.b	94
      0  2399					      db	tByte
      1  2399		       a2		      .byte.b	tByte
      0  239a					      STORE		; STORE RESULT at variable address
      0  239a					      db	19
      1  239a		       13		      .byte.b	19
      0  239b					      NXT	CO	; AND SEQUENCE TO NEXT
      0  239b					      db	6
      1  239b		       06		      .byte.b	6
      0  239c					      dw	CO
      1  239c		       6d 23		      .word.w	CO
      0  239e					      IJMP	STMT	; Next statement
      0  239e					      db	29
      1  239e		       1d		      .byte.b	29
      0  239f					      dw	STMT
      1  239f		       75 23		      .word.w	STMT
    129  23a1
    130  23a1				   ERRMissingEquals
      0  23a1					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  23a1					      db	13
      1  23a1		       0d		      .byte.b	13
      0  23a2					      dw	ERR_MISSINGEQUALSIGN
      1  23a2		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    132  23a4
    133  23a4				   ERRVEC2
      0  23a4					      IJMP	UNKNOWN
      0  23a4					      db	29
      1  23a4		       1d		      .byte.b	29
      0  23a5					      dw	UNKNOWN
      1  23a5		       ae 25		      .word.w	UNKNOWN
    135  23a7							;=============================================================
    136  23a7							;Branch on a valid statement start
    137  23a7				   DoVector
      0  23a7					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  23a7					      db	103
      1  23a7		       67		      .byte.b	103
      0  23a8					      dw	BasicStmts
      1  23a8		       f5 22		      .word.w	BasicStmts
      0  23aa					      dw	UNKNOWN
      1  23aa		       ae 25		      .word.w	UNKNOWN
    139  23ac							;This will never return here!
    140  23ac							;=============================================================
    141  23ac							; Inc or dec a variable
    142  23ac							;S1:
    143  23ac							;	  TSTB	     S1Dec,kInc 		    ; Increment variable
    144  23ac				   ekInc
      0  23ac					      TSTV	ERRVEC2	; Verify we have a variable
      0  23ac					      db	33
      1  23ac		       21		      .byte.b	33
      0  23ad					      db	(ERRVEC2-*)-1
      1  23ad		       f6		      .byte.b	(ERRVEC2-*)-1
      0  23ae					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  23ae					      db	28
      1  23ae		       1c		      .byte.b	28
      0  23af					      dw	FactVarPtrNoTst
      1  23af		       2a 27		      .word.w	FactVarPtrNoTst
    147  23b1							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    148  23b1							;	  IND					    ; we just got a pid
    149  23b1							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    150  23b1				   eDoInc
      0  23b1					      INCVAR		; Do the increment of the variable
      0  23b1					      db	98
      1  23b1		       62		      .byte.b	98
      0  23b2					      DONE		; Test for end of line or end of statement ":"
      0  23b2					      db	1
      1  23b2		       01		      .byte.b	1
      0  23b3					      NXT	CO	; Get the next statement, branch CO if end of program
      0  23b3					      db	6
      1  23b3		       06		      .byte.b	6
      0  23b4					      dw	CO
      1  23b4		       6d 23		      .word.w	CO
      0  23b6					      IJMP	STMT	; Process the next statement
      0  23b6					      db	29
      1  23b6		       1d		      .byte.b	29
      0  23b7					      dw	STMT
      1  23b7		       75 23		      .word.w	STMT
    155  23b9							;S1Dec:
    156  23b9							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    157  23b9				   ekDec
      0  23b9					      TSTV	ERRVEC2	; Must be followed by a variable
      0  23b9					      db	33
      1  23b9		       21		      .byte.b	33
      0  23ba					      db	(ERRVEC2-*)-1
      1  23ba		       e9		      .byte.b	(ERRVEC2-*)-1
      0  23bb					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  23bb					      db	28
      1  23bb		       1c		      .byte.b	28
      0  23bc					      dw	FactVarPtrNoTst
      1  23bc		       2a 27		      .word.w	FactVarPtrNoTst
    160  23be							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    161  23be							;	  IND					    ; we just got a pid
    162  23be							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    163  23be				   eDoDec
      0  23be					      DECVAR		; Decrement the actual variable
      0  23be					      db	99
      1  23be		       63		      .byte.b	99
      0  23bf					      DONE		; Test if end of line or : statement
      0  23bf					      db	1
      1  23bf		       01		      .byte.b	1
      0  23c0					      NXT	CO	; If at end of program then got the console
      0  23c0					      db	6
      1  23c0		       06		      .byte.b	6
      0  23c1					      dw	CO
      1  23c1		       6d 23		      .word.w	CO
      0  23c3					      IJMP	STMT	; Process the next statement of command line
      0  23c3					      db	29
      1  23c3		       1d		      .byte.b	29
      0  23c4					      dw	STMT
      1  23c4		       75 23		      .word.w	STMT
    168  23c6							;=============================================================================================================================
    169  23c6							; iret or ireturn, Return from interupt process
    170  23c6							;
    171  23c6							;S1Iret:
    172  23c6							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    173  23c6							;S1Sa:
    174  23c6				   ekIreturn
      0  23c6					      DONE		; Must be only thing on the line
      0  23c6					      db	1
      1  23c6		       01		      .byte.b	1
      0  23c7					      IRET		; RESTORE LINE NUMBER OF CALL
      0  23c7					      db	58
      1  23c7		       3a		      .byte.b	58
      0  23c8					      IJMP	STMT
      0  23c8					      db	29
      1  23c8		       1d		      .byte.b	29
      0  23c9					      dw	STMT
      1  23c9		       75 23		      .word.w	STMT
    178  23cb							;==============================================================================================================================
    179  23cb							;Process if statement, if true then process all statements until end of line reached
    180  23cb							;S1S1:
    181  23cb							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    182  23cb				   ekIf
      0  23cb					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  23cb					      db	28
      1  23cb		       1c		      .byte.b	28
      0  23cc					      dw	EXPR
      1  23cc		       b2 25		      .word.w	EXPR
      0  23ce					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  23ce					      db	101
      1  23ce		       65		      .byte.b	101
      0  23cf					      db	(S1W-*)-1
      1  23cf		       01		      .byte.b	(S1W-*)-1
      0  23d0					      db	kThen
      1  23d0		       06		      .byte.b	kThen
    185  23d1				   ekThen
    186  23d1				   S1W
      0  23d1					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  23d1					      db	54
      1  23d1		       36		      .byte.b	54
      0  23d2					      IJMP	STMT
      0  23d2					      db	29
      1  23d2		       1d		      .byte.b	29
      0  23d3					      dw	STMT
      1  23d3		       75 23		      .word.w	STMT
    189  23d5							;===============================================================================================================================
    190  23d5							; Test for GOTO
    191  23d5							;S1Z:
    192  23d5							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    193  23d5							;
    194  23d5				   ekGoto
      0  23d5					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  23d5					      db	106
      1  23d5		       6a		      .byte.b	106
      0  23d6					      db	(ekGotoCompiled-*)-1
      1  23d6		       0e		      .byte.b	(ekGotoCompiled-*)-1
    196  23d7							; Else we have the address ad just goto that address
      0  23d7					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  23d7					      db	101
      1  23d7		       65		      .byte.b	101
      0  23d8					      db	(ekGotoLine-*)-1
      1  23d8		       05		      .byte.b	(ekGotoLine-*)-1
      0  23d9					      db	oPeriod
      1  23d9		       e9		      .byte.b	oPeriod
      0  23da					      REPEATLINE		; Repeat the same line again
      0  23da					      db	105
      1  23da		       69		      .byte.b	105
      0  23db					      IJMP	STMT	; Go do the statement
      0  23db					      db	29
      1  23db		       1d		      .byte.b	29
      0  23dc					      dw	STMT
      1  23dc		       75 23		      .word.w	STMT
    200  23de
    201  23de				   ekGotoLine
      0  23de					      CALL	EXPR	; GET LABEL
      0  23de					      db	28
      1  23de		       1c		      .byte.b	28
      0  23df					      dw	EXPR
      1  23df		       b2 25		      .word.w	EXPR
      0  23e1					      lit	0	; Place indicator for line num on stack
      0  23e1					      db	27
      1  23e1		       1b		      .byte.b	27
      0  23e2					      dw	0
      1  23e2		       00 00		      .word.w	0
      0  23e4					      FASTXFER
      0  23e4					      db	107
      1  23e4		       6b		      .byte.b	107
    205  23e5				   ekGotoCompiled
      0  23e5					      lit	1	; tell it that mempointer on the stack
      0  23e5					      db	27
      1  23e5		       1b		      .byte.b	27
      0  23e6					      dw	1
      1  23e6		       01 00		      .word.w	1
      0  23e8					      FASTXFER		; put top of stack into curptr
      0  23e8					      db	107
      1  23e8		       6b		      .byte.b	107
    208  23e9
    209  23e9							;===============================================================================================================================
    210  23e9							; Process gosub / function
    211  23e9							;
    212  23e9							;S2:
    213  23e9							;	  TSTB	     S2b,kGosub 		    ; ERROR IF NO MATCH
    214  23e9				   ekGosub
      0  23e9					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  23e9					      db	28
      1  23e9		       1c		      .byte.b	28
      0  23ea					      dw	GOSUBSTATEMENT
      1  23ea		       55 27		      .word.w	GOSUBSTATEMENT
      0  23ec					      DONE		; ERROR IF CR NOT NEXT
      0  23ec					      db	1
      1  23ec		       01		      .byte.b	1
      0  23ed					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  23ed					      db	8
      1  23ed		       08		      .byte.b	8
      0  23ee					      db	GOSUB_RTN
      1  23ee		       01		      .byte.b	GOSUB_RTN
      0  23ef					      FASTXFER		; AND JUMP to sub rtn
      0  23ef					      db	107
      1  23ef		       6b		      .byte.b	107
    219  23f0							;
    220  23f0							; End of gosub processing
    221  23f0							;===============================================================================================================================
    222  23f0							; Return from a gosub
    223  23f0							;S2b:
    224  23f0							;	  TSTB	    S2a,kReturn 		   ; Speed up pocessing but more memory
    225  23f0				   ekReturn
      0  23f0					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  23f0					      db	101
      1  23f0		       65		      .byte.b	101
      0  23f1					      db	(S2NoReturnValue-*)-1
      1  23f1		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  23f2					      db	oLeftBracket
      1  23f2		       e0		      .byte.b	oLeftBracket
      0  23f3					      CALL	EXPR
      0  23f3					      db	28
      1  23f3		       1c		      .byte.b	28
      0  23f4					      dw	EXPR
      1  23f4		       b2 25		      .word.w	EXPR
      0  23f6					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  23f6					      db	101
      1  23f6		       65		      .byte.b	101
      0  23f7					      db	(ERRVEC2-*)-1
      1  23f7		       ac		      .byte.b	(ERRVEC2-*)-1
      0  23f8					      db	oRightBracket
      1  23f8		       e1		      .byte.b	oRightBracket
      0  23f9					      DONE
      0  23f9					      db	1
      1  23f9		       01		      .byte.b	1
      0  23fa					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  23fa					      db	9
      1  23fa		       09		      .byte.b	9
      0  23fb					      db	(S2RetFunc-*)-1
      1  23fb		       11		      .byte.b	(S2RetFunc-*)-1
      0  23fc					      db	1
      1  23fc		       01		      .byte.b	1
      0  23fd					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  23fd					      db	6
      1  23fd		       06		      .byte.b	6
      0  23fe					      dw	CO
      1  23fe		       6d 23		      .word.w	CO
      0  2400					      IJMP	STMT	; Process the new statement
      0  2400					      db	29
      1  2400		       1d		      .byte.b	29
      0  2401					      dw	STMT
      1  2401		       75 23		      .word.w	STMT
    233  2403
    234  2403				   S2NoReturnValue
      0  2403					      DONE
      0  2403					      db	1
      1  2403		       01		      .byte.b	1
      0  2404					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  2404					      db	9
      1  2404		       09		      .byte.b	9
      0  2405					      db	(S2RetFunc-*)-1
      1  2405		       07		      .byte.b	(S2RetFunc-*)-1
      0  2406					      db	0
      1  2406		       00		      .byte.b	0
      0  2407					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  2407					      db	6
      1  2407		       06		      .byte.b	6
      0  2408					      dw	CO
      1  2408		       6d 23		      .word.w	CO
      0  240a					      IJMP	STMT	; Process the new statement
      0  240a					      db	29
      1  240a		       1d		      .byte.b	29
      0  240b					      dw	STMT
      1  240b		       75 23		      .word.w	STMT
    239  240d
    240  240d				   S2RetFunc
      0  240d					      IJMP	GOFNRet	; Back into the Function
      0  240d					      db	29
      1  240d		       1d		      .byte.b	29
      0  240e					      dw	GOFNRet
      1  240e		       0d 27		      .word.w	GOFNRet
    242  2410							;
    243  2410							; End of return from gosub
    244  2410							;==================================================================================================================================
    245  2410							; Process REM statement
    246  2410							;
    247  2410							;S2a:
    248  2410							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    249  2410				   ekRem
      0  2410					      NXT	CO	; The rest of the line is ignored
      0  2410					      db	6
      1  2410		       06		      .byte.b	6
      0  2411					      dw	CO
      1  2411		       6d 23		      .word.w	CO
      0  2413					      IJMP	STMT	; Process the next statement
      0  2413					      db	29
      1  2413		       1d		      .byte.b	29
      0  2414					      dw	STMT
      1  2414		       75 23		      .word.w	STMT
    252  2416							;====================================================================================================================================
    253  2416							; Set the Task input output slot each slot is 16 byte starting at e000
    254  2416							; so 0,1,...
    255  2416				   ekSetTerm
      0  2416					      CALL	EXPR
      0  2416					      db	28
      1  2416		       1c		      .byte.b	28
      0  2417					      dw	EXPR
      1  2417		       b2 25		      .word.w	EXPR
      0  2419					      TSTB	ERRVEC,oComma
      0  2419					      db	101
      1  2419		       65		      .byte.b	101
      0  241a					      db	(ERRVEC-*)-1
      1  241a		       2f		      .byte.b	(ERRVEC-*)-1
      0  241b					      db	oComma
      1  241b		       e2		      .byte.b	oComma
      0  241c					      CALL	EXPR
      0  241c					      db	28
      1  241c		       1c		      .byte.b	28
      0  241d					      dw	EXPR
      1  241d		       b2 25		      .word.w	EXPR
      0  241f					      SETTERMINAL
      0  241f					      db	108
      1  241f		       6c		      .byte.b	108
      0  2420					      NXT	CO	;Next statement to execute
      0  2420					      db	6
      1  2420		       06		      .byte.b	6
      0  2421					      dw	CO
      1  2421		       6d 23		      .word.w	CO
      0  2423					      IJMP	STMT
      0  2423					      db	29
      1  2423		       1d		      .byte.b	29
      0  2424					      dw	STMT
      1  2424		       75 23		      .word.w	STMT
    262  2426							;==================================================================================================================================
    263  2426							; Print statement
    264  2426							;
    265  2426							;S3:
    266  2426							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    267  2426				   ekPrint
      0  2426					      STARTIO		; Lock task until io completes
      0  2426					      db	70
      1  2426		       46		      .byte.b	70
    269  2427				   S4
      0  2427					      TSTDONE	S4a	; Test if we just want crlf printed
      0  2427					      db	50
      1  2427		       32		      .byte.b	50
      0  2428					      db	(S4a-*)-1
      1  2428		       03		      .byte.b	(S4a-*)-1
      0  2429					      IJMP	S6
      0  2429					      db	29
      1  2429		       1d		      .byte.b	29
      0  242a					      dw	S6
      1  242a		       41 24		      .word.w	S6
    272  242c
    273  242c				   S4a
      0  242c					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  242c					      db	101
      1  242c		       65		      .byte.b	101
      0  242d					      db	(S7-*)-1
      1  242d		       1f		      .byte.b	(S7-*)-1
      0  242e					      db	tString
      1  242e		       a0		      .byte.b	tString
      0  242f					      PRS		; PRINT STRING
      0  242f					      db	2
      1  242f		       02		      .byte.b	2
    276  2430				   S5
      0  2430					      TSTB	S6A,oComma	; IS THERE MORE?
      0  2430					      db	101
      1  2430		       65		      .byte.b	101
      0  2431					      db	(S6A-*)-1
      1  2431		       07		      .byte.b	(S6A-*)-1
      0  2432					      db	oComma
      1  2432		       e2		      .byte.b	oComma
      0  2433					      SPC		; SPACE TO NEXT ZONE
      0  2433					      db	4
      1  2433		       04		      .byte.b	4
      0  2434					      TSTDONE	S4	; Not end of line jump back
      0  2434					      db	50
      1  2434		       32		      .byte.b	50
      0  2435					      db	(S4-*)-1
      1  2435		       f1		      .byte.b	(S4-*)-1
      0  2436					      IJMP	S6Z	; YES JUMP BACK
      0  2436					      db	29
      1  2436		       1d		      .byte.b	29
      0  2437					      dw	S6Z
      1  2437		       43 24		      .word.w	S6Z
    281  2439
    282  2439							;
    283  2439							; If a semicolon, don't do anything.
    284  2439							;
    285  2439				   S6A
      0  2439					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  2439					      db	101
      1  2439		       65		      .byte.b	101
      0  243a					      db	(S6-*)-1
      1  243a		       06		      .byte.b	(S6-*)-1
      0  243b					      db	oSemiColon
      1  243b		       e3		      .byte.b	oSemiColon
      0  243c					      TSTDONE	S4	; Jump Back if not end of line
      0  243c					      db	50
      1  243c		       32		      .byte.b	50
      0  243d					      db	(S4-*)-1
      1  243d		       e9		      .byte.b	(S4-*)-1
      0  243e					      IJMP	S6Z
      0  243e					      db	29
      1  243e		       1d		      .byte.b	29
      0  243f					      dw	S6Z
      1  243f		       43 24		      .word.w	S6Z
    289  2441
    290  2441				   S6
    291  2441
      0  2441					      DONE		; ERROR IF CR NOT NEXT
      0  2441					      db	1
      1  2441		       01		      .byte.b	1
      0  2442					      NLINE
      0  2442					      db	5
      1  2442		       05		      .byte.b	5
    294  2443				   S6Z
      0  2443					      ENDIO		; release task io completed
      0  2443					      db	71
      1  2443		       47		      .byte.b	71
      0  2444					      NXT	CO	; exit here if , or ; at end of print
      0  2444					      db	6
      1  2444		       06		      .byte.b	6
      0  2445					      dw	CO
      1  2445		       6d 23		      .word.w	CO
      0  2447					      IJMP	STMT
      0  2447					      db	29
      1  2447		       1d		      .byte.b	29
      0  2448					      dw	STMT
      1  2448		       75 23		      .word.w	STMT
    298  244a							;
    299  244a							; A jump for code too far away for relative branch
    300  244a							;
    301  244a				   ERRVEC
      0  244a					      IJMP	UNKNOWN
      0  244a					      db	29
      1  244a		       1d		      .byte.b	29
      0  244b					      dw	UNKNOWN
      1  244b		       ae 25		      .word.w	UNKNOWN
    303  244d							;
    304  244d							; Get here if there is an expression to print
    305  244d				   S7
      0  244d					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  244d					      db	101
      1  244d		       65		      .byte.b	101
      0  244e					      db	(S7AUnsigned-*)-1
      1  244e		       08		      .byte.b	(S7AUnsigned-*)-1
      0  244f					      db	oDollar
      1  244f		       e7		      .byte.b	oDollar
      0  2450					      CALL	EXPR
      0  2450					      db	28
      1  2450		       1c		      .byte.b	28
      0  2451					      dw	EXPR
      1  2451		       b2 25		      .word.w	EXPR
      0  2453					      HEXPRT
      0  2453					      db	67
      1  2453		       43		      .byte.b	67
      0  2454					      IJMP	S5
      0  2454					      db	29
      1  2454		       1d		      .byte.b	29
      0  2455					      dw	S5
      1  2455		       30 24		      .word.w	S5
    310  2457
    311  2457				   S7AUnsigned
    312  2457
      0  2457					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  2457					      db	101
      1  2457		       65		      .byte.b	101
      0  2458					      db	(S7A-*)-1
      1  2458		       0a		      .byte.b	(S7A-*)-1
      0  2459					      db	oPercent
      1  2459		       ed		      .byte.b	oPercent
      0  245a					      CALL	EXPR
      0  245a					      db	28
      1  245a		       1c		      .byte.b	28
      0  245b					      dw	EXPR
      1  245b		       b2 25		      .word.w	EXPR
      0  245d					      SETR2	tUint
      0  245d					      db	94
      1  245d		       5e		      .byte.b	94
      0  245e					      db	tUint
      1  245e		       a7		      .byte.b	tUint
      0  245f					      PRN
      0  245f					      db	3
      1  245f		       03		      .byte.b	3
      0  2460					      IJMP	S5
      0  2460					      db	29
      1  2460		       1d		      .byte.b	29
      0  2461					      dw	S5
      1  2461		       30 24		      .word.w	S5
    318  2463
    319  2463				   S7A
    320  2463
      0  2463					      CALL	EXPR
      0  2463					      db	28
      1  2463		       1c		      .byte.b	28
      0  2464					      dw	EXPR
      1  2464		       b2 25		      .word.w	EXPR
      0  2466					      TSTB	S7B,oDollar	; Print the value as a single character
      0  2466					      db	101
      1  2466		       65		      .byte.b	101
      0  2467					      db	(S7B-*)-1
      1  2467		       05		      .byte.b	(S7B-*)-1
      0  2468					      db	oDollar
      1  2468		       e7		      .byte.b	oDollar
      0  2469					      PUTCHAR
      0  2469					      db	52
      1  2469		       34		      .byte.b	52
      0  246a					      IJMP	S5
      0  246a					      db	29
      1  246a		       1d		      .byte.b	29
      0  246b					      dw	S5
      1  246b		       30 24		      .word.w	S5
    325  246d
    326  246d				   S7B
      0  246d					      SETR2	tInteger	; Print the value as a signed number
      0  246d					      db	94
      1  246d		       5e		      .byte.b	94
      0  246e					      db	tInteger
      1  246e		       a1		      .byte.b	tInteger
      0  246f					      PRN		; PRINT IT
      0  246f					      db	3
      1  246f		       03		      .byte.b	3
      0  2470					      IJMP	S5	; IS THERE MORE?
      0  2470					      db	29
      1  2470		       1d		      .byte.b	29
      0  2471					      dw	S5
      1  2471		       30 24		      .word.w	S5
    330  2473							;
    331  2473							;===========================================================
    332  2473							; PROCESS ALL THE TASK STATEMENTS
    333  2473							;
    334  2473							;S8:
    335  2473							;	  TSTB	      S8G,kTaske		 ; End Task
    336  2473				   ekTaske
      0  2473					      TSTB	S8NoParm,oLeftBracket
      0  2473					      db	101
      1  2473		       65		      .byte.b	101
      0  2474					      db	(S8NoParm-*)-1
      1  2474		       0c		      .byte.b	(S8NoParm-*)-1
      0  2475					      db	oLeftBracket
      1  2475		       e0		      .byte.b	oLeftBracket
      0  2476					      CALL	EXPR
      0  2476					      db	28
      1  2476		       1c		      .byte.b	28
      0  2477					      dw	EXPR
      1  2477		       b2 25		      .word.w	EXPR
      0  2479					      TSTB	UNKNOWNLnk,oRightBracket
      0  2479					      db	101
      1  2479		       65		      .byte.b	101
      0  247a					      db	(UNKNOWNLnk-*)-1
      1  247a		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  247b					      db	oRightBracket
      1  247b		       e1		      .byte.b	oRightBracket
      0  247c					      ETASK
      0  247c					      db	62
      1  247c		       3e		      .byte.b	62
      0  247d					      DONE
      0  247d					      db	1
      1  247d		       01		      .byte.b	1
      0  247e					      IJMP	STMT
      0  247e					      db	29
      1  247e		       1d		      .byte.b	29
      0  247f					      dw	STMT
      1  247f		       75 23		      .word.w	STMT
    343  2481				   S8NoParm
      0  2481					      LIT	0
      0  2481					      db	27
      1  2481		       1b		      .byte.b	27
      0  2482					      dw	0
      1  2482		       00 00		      .word.w	0
      0  2484					      ETASK
      0  2484					      db	62
      1  2484		       3e		      .byte.b	62
      0  2485					      DONE		; Must be last thing on a line
      0  2485					      db	1
      1  2485		       01		      .byte.b	1
      0  2486					      IJMP	STMT
      0  2486					      db	29
      1  2486		       1d		      .byte.b	29
      0  2487					      dw	STMT
      1  2487		       75 23		      .word.w	STMT
    348  2489							;
    349  2489							;===========================================================
    350  2489							; The task gives up the rest of the cycles
    351  2489							;S8G:
    352  2489							;	  TSTB	      S8a,kTaskn	 ;Next task
    353  2489				   ekTaskn
      0  2489					      NTASK
      0  2489					      db	63
      1  2489		       3f		      .byte.b	63
      0  248a					      NXT	CO	;Next statement to execute
      0  248a					      db	6
      1  248a		       06		      .byte.b	6
      0  248b					      dw	CO
      1  248b		       6d 23		      .word.w	CO
      0  248d					      IJMP	STMT
      0  248d					      db	29
      1  248d		       1d		      .byte.b	29
      0  248e					      dw	STMT
      1  248e		       75 23		      .word.w	STMT
    357  2490							;
    358  2490							;===========================================================
    359  2490							; Waits for a task or list of tasks to complete
    360  2490							;S8a:
    361  2490							;	 TSTB	     S8a1,kTaskw		;Wait for tasks
    362  2490				   ekTaskw
      0  2490					      TSTB	UNKNOWNLnk,oLeftBracket
      0  2490					      db	101
      1  2490		       65		      .byte.b	101
      0  2491					      db	(UNKNOWNLnk-*)-1
      1  2491		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  2492					      db	oLeftBracket
      1  2492		       e0		      .byte.b	oLeftBracket
    364  2493				   S8TSK
      0  2493					      Call	EXPR	;Gets the PID of task to wait for
      0  2493					      db	28
      1  2493		       1c		      .byte.b	28
      0  2494					      dw	EXPR
      1  2494		       b2 25		      .word.w	EXPR
    366  2496				   S8LOOP
      0  2496					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  2496					      db	76
      1  2496		       4c		      .byte.b	76
      0  2497					      db	(S8LOOP-*)-1
      1  2497		       fe		      .byte.b	(S8LOOP-*)-1
      0  2498					      TSTB	S8aa,oComma	;Checks for more tasks
      0  2498					      db	101
      1  2498		       65		      .byte.b	101
      0  2499					      db	(S8aa-*)-1
      1  2499		       04		      .byte.b	(S8aa-*)-1
      0  249a					      db	oComma
      1  249a		       e2		      .byte.b	oComma
      0  249b					      IJMP	S8TSK	;Go for the next task number
      0  249b					      db	29
      1  249b		       1d		      .byte.b	29
      0  249c					      dw	S8TSK
      1  249c		       93 24		      .word.w	S8TSK
    370  249e				   S8aa
      0  249e					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  249e					      db	101
      1  249e		       65		      .byte.b	101
      0  249f					      db	(UNKNOWNLnk-*)-1
      1  249f		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  24a0					      db	oRightBracket
      1  24a0		       e1		      .byte.b	oRightBracket
      0  24a1					      DONE
      0  24a1					      db	1
      1  24a1		       01		      .byte.b	1
      0  24a2					      NXT	CO
      0  24a2					      db	6
      1  24a2		       06		      .byte.b	6
      0  24a3					      dw	CO
      1  24a3		       6d 23		      .word.w	CO
      0  24a5					      IJMP	STMT	;Next Statement
      0  24a5					      db	29
      1  24a5		       1d		      .byte.b	29
      0  24a6					      dw	STMT
      1  24a6		       75 23		      .word.w	STMT
    375  24a8
    376  24a8
    377  24a8
    378  24a8				   UNKNOWNLnk
      0  24a8					      iJMP	UNKNOWN
      0  24a8					      db	29
      1  24a8		       1d		      .byte.b	29
      0  24a9					      dw	UNKNOWN
      1  24a9		       ae 25		      .word.w	UNKNOWN
    380  24ab
    381  24ab							;
    382  24ab							;===========================================================
    383  24ab							; Update a memory location with a value
    384  24ab							;  Use @[offset] to write a word value to memory
    385  24ab							;
    386  24ab							;S8a1:
    387  24ab							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    388  24ab				   ekPoke
      0  24ab					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  24ab					      db	101
      1  24ab		       65		      .byte.b	101
      0  24ac					      db	(UNKNOWNV-*)-1
      1  24ac		       9c		      .byte.b	(UNKNOWNV-*)-1
      0  24ad					      db	oLeftBracket
      1  24ad		       e0		      .byte.b	oLeftBracket
      0  24ae					      CALL	EXPR	; Get address to write to
      0  24ae					      db	28
      1  24ae		       1c		      .byte.b	28
      0  24af					      dw	EXPR
      1  24af		       b2 25		      .word.w	EXPR
      0  24b1					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  24b1					      db	101
      1  24b1		       65		      .byte.b	101
      0  24b2					      db	(UNKNOWNV-*)-1
      1  24b2		       96		      .byte.b	(UNKNOWNV-*)-1
      0  24b3					      db	oComma
      1  24b3		       e2		      .byte.b	oComma
      0  24b4					      CALL	EXPR	; Get the value to poke
      0  24b4					      db	28
      1  24b4		       1c		      .byte.b	28
      0  24b5					      dw	EXPR
      1  24b5		       b2 25		      .word.w	EXPR
      0  24b7					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  24b7					      db	101
      1  24b7		       65		      .byte.b	101
      0  24b8					      db	(UNKNOWNV-*)-1
      1  24b8		       90		      .byte.b	(UNKNOWNV-*)-1
      0  24b9					      db	oRightBracket
      1  24b9		       e1		      .byte.b	oRightBracket
      0  24ba					      POKEMEM
      0  24ba					      db	47
      1  24ba		       2f		      .byte.b	47
      0  24bb					      DONE
      0  24bb					      db	1
      1  24bb		       01		      .byte.b	1
      0  24bc					      NXT	CO	;AND SEQUENCE TO NEXT
      0  24bc					      db	6
      1  24bc		       06		      .byte.b	6
      0  24bd					      dw	CO
      1  24bd		       6d 23		      .word.w	CO
      0  24bf					      IJMP	STMT
      0  24bf					      db	29
      1  24bf		       1d		      .byte.b	29
      0  24c0					      dw	STMT
      1  24c0		       75 23		      .word.w	STMT
    398  24c2							;
    399  24c2							;================================================================
    400  24c2							; Set a block of memory to a value word or byte
    401  24c2							; SetMem(Value, Length, Destination)
    402  24c2				   ekSetMemB
      0  24c2					      CALL	ekSetMem
      0  24c2					      db	28
      1  24c2		       1c		      .byte.b	28
      0  24c3					      dw	ekSetMem
      1  24c3		       da 24		      .word.w	ekSetMem
      0  24c5					      SETBLOCK	tByte	; set value as byte
      0  24c5					      db	110
      1  24c5		       6e		      .byte.b	110
      0  24c6					      db	tByte
      1  24c6		       a2		      .byte.b	tByte
      0  24c7					      DONE
      0  24c7					      db	1
      1  24c7		       01		      .byte.b	1
      0  24c8					      NXT	CO
      0  24c8					      db	6
      1  24c8		       06		      .byte.b	6
      0  24c9					      dw	CO
      1  24c9		       6d 23		      .word.w	CO
      0  24cb					      IJMP	STMT
      0  24cb					      db	29
      1  24cb		       1d		      .byte.b	29
      0  24cc					      dw	STMT
      1  24cc		       75 23		      .word.w	STMT
    408  24ce
    409  24ce				   ekSetMemW
      0  24ce					      CALL	ekSetMem
      0  24ce					      db	28
      1  24ce		       1c		      .byte.b	28
      0  24cf					      dw	ekSetMem
      1  24cf		       da 24		      .word.w	ekSetMem
      0  24d1					      SETBLOCK	tInteger	; set value as byte
      0  24d1					      db	110
      1  24d1		       6e		      .byte.b	110
      0  24d2					      db	tInteger
      1  24d2		       a1		      .byte.b	tInteger
      0  24d3					      DONE
      0  24d3					      db	1
      1  24d3		       01		      .byte.b	1
      0  24d4					      NXT	CO
      0  24d4					      db	6
      1  24d4		       06		      .byte.b	6
      0  24d5					      dw	CO
      1  24d5		       6d 23		      .word.w	CO
      0  24d7					      IJMP	STMT
      0  24d7					      db	29
      1  24d7		       1d		      .byte.b	29
      0  24d8					      dw	STMT
      1  24d8		       75 23		      .word.w	STMT
    415  24da
    416  24da				   ekSetMem
      0  24da					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  24da					      db	101
      1  24da		       65		      .byte.b	101
      0  24db					      db	(UNKNOWNV-*)-1
      1  24db		       6d		      .byte.b	(UNKNOWNV-*)-1
      0  24dc					      db	oLeftBracket
      1  24dc		       e0		      .byte.b	oLeftBracket
      0  24dd					      CALL	EXPR	; Value to set
      0  24dd					      db	28
      1  24dd		       1c		      .byte.b	28
      0  24de					      dw	EXPR
      1  24de		       b2 25		      .word.w	EXPR
      0  24e0					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  24e0					      db	101
      1  24e0		       65		      .byte.b	101
      0  24e1					      db	(UNKNOWNV-*)-1
      1  24e1		       67		      .byte.b	(UNKNOWNV-*)-1
      0  24e2					      db	oComma
      1  24e2		       e2		      .byte.b	oComma
      0  24e3					      CALL	EXPR	; Get The Length
      0  24e3					      db	28
      1  24e3		       1c		      .byte.b	28
      0  24e4					      dw	EXPR
      1  24e4		       b2 25		      .word.w	EXPR
      0  24e6					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  24e6					      db	101
      1  24e6		       65		      .byte.b	101
      0  24e7					      db	(UNKNOWNV-*)-1
      1  24e7		       61		      .byte.b	(UNKNOWNV-*)-1
      0  24e8					      db	oComma
      1  24e8		       e2		      .byte.b	oComma
      0  24e9					      CALL	EXPR	; GET the address to start at
      0  24e9					      db	28
      1  24e9		       1c		      .byte.b	28
      0  24ea					      dw	EXPR
      1  24ea		       b2 25		      .word.w	EXPR
      0  24ec					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  24ec					      db	101
      1  24ec		       65		      .byte.b	101
      0  24ed					      db	(UNKNOWNV-*)-1
      1  24ed		       5b		      .byte.b	(UNKNOWNV-*)-1
      0  24ee					      db	oRightBracket
      1  24ee		       e1		      .byte.b	oRightBracket
      0  24ef					      RTN
      0  24ef					      db	25
      1  24ef		       19		      .byte.b	25
    425  24f0							;
    426  24f0							;================================================================
    427  24f0							; Copy a block of memory
    428  24f0							; CopyMem(Length, Destination, Source)
    429  24f0				   ekCopyMem
      0  24f0					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  24f0					      db	101
      1  24f0		       65		      .byte.b	101
      0  24f1					      db	(UNKNOWNV-*)-1
      1  24f1		       57		      .byte.b	(UNKNOWNV-*)-1
      0  24f2					      db	oLeftBracket
      1  24f2		       e0		      .byte.b	oLeftBracket
      0  24f3					      CALL	EXPR	; Length
      0  24f3					      db	28
      1  24f3		       1c		      .byte.b	28
      0  24f4					      dw	EXPR
      1  24f4		       b2 25		      .word.w	EXPR
      0  24f6					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  24f6					      db	101
      1  24f6		       65		      .byte.b	101
      0  24f7					      db	(UNKNOWNV-*)-1
      1  24f7		       51		      .byte.b	(UNKNOWNV-*)-1
      0  24f8					      db	oComma
      1  24f8		       e2		      .byte.b	oComma
      0  24f9					      CALL	EXPR	; Destination
      0  24f9					      db	28
      1  24f9		       1c		      .byte.b	28
      0  24fa					      dw	EXPR
      1  24fa		       b2 25		      .word.w	EXPR
      0  24fc					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  24fc					      db	101
      1  24fc		       65		      .byte.b	101
      0  24fd					      db	(UNKNOWNV-*)-1
      1  24fd		       4b		      .byte.b	(UNKNOWNV-*)-1
      0  24fe					      db	oComma
      1  24fe		       e2		      .byte.b	oComma
      0  24ff					      CALL	EXPR	; Source
      0  24ff					      db	28
      1  24ff		       1c		      .byte.b	28
      0  2500					      dw	EXPR
      1  2500		       b2 25		      .word.w	EXPR
      0  2502					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  2502					      db	101
      1  2502		       65		      .byte.b	101
      0  2503					      db	(UNKNOWNV-*)-1
      1  2503		       45		      .byte.b	(UNKNOWNV-*)-1
      0  2504					      db	oRightBracket
      1  2504		       e1		      .byte.b	oRightBracket
      0  2505					      COPYBLOCK		; Copy the memory
      0  2505					      db	111
      1  2505		       6f		      .byte.b	111
      0  2506					      DONE
      0  2506					      db	1
      1  2506		       01		      .byte.b	1
      0  2507					      NXT	CO
      0  2507					      db	6
      1  2507		       06		      .byte.b	6
      0  2508					      dw	CO
      1  2508		       6d 23		      .word.w	CO
      0  250a					      IJMP	STMT
      0  250a					      db	29
      1  250a		       1d		      .byte.b	29
      0  250b					      dw	STMT
      1  250b		       75 23		      .word.w	STMT
    441  250d							;================================================================
    442  250d							; Write a single byte to the output device
    443  250d							;
    444  250d							;S8b:
    445  250d							;	  TSTB	      S8c,kPutch       ;Put a char to the terminal
    446  250d				   ekPutch
      0  250d					      CALL	EXPR
      0  250d					      db	28
      1  250d		       1c		      .byte.b	28
      0  250e					      dw	EXPR
      1  250e		       b2 25		      .word.w	EXPR
      0  2510					      PUTCHAR
      0  2510					      db	52
      1  2510		       34		      .byte.b	52
      0  2511					      DONE
      0  2511					      db	1
      1  2511		       01		      .byte.b	1
      0  2512					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2512					      db	6
      1  2512		       06		      .byte.b	6
      0  2513					      dw	CO
      1  2513		       6d 23		      .word.w	CO
      0  2515					      IJMP	STMT
      0  2515					      db	29
      1  2515		       1d		      .byte.b	29
      0  2516					      dw	STMT
      1  2516		       75 23		      .word.w	STMT
    452  2518							;================================================================
    453  2518							; Clear the screen lines
    454  2518							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    455  2518							;
    456  2518							;S8c
    457  2518							;	  TSTB	      S9,kCls	       ;Clear the screen
    458  2518				   ekCls
      0  2518					      CLEARSCREEN
      0  2518					      db	46
      1  2518		       2e		      .byte.b	46
      0  2519					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2519					      db	6
      1  2519		       06		      .byte.b	6
      0  251a					      dw	CO
      1  251a		       6d 23		      .word.w	CO
      0  251c					      IJMP	STMT
      0  251c					      db	29
      1  251c		       1d		      .byte.b	29
      0  251d					      dw	STMT
      1  251d		       75 23		      .word.w	STMT
    462  251f							;==================================================================
    463  251f							; Get input from the terminal
    464  251f							;   Reads from the currently active input device
    465  251f							;
    466  251f							;S9:
    467  251f							;	  TSTB	     S13,kInput 	      ;INPUT STATEMENT
    468  251f				   ekInput
    469  251f				   S10
      0  251f					      TSTB	S10A,tString	;If there is a string print the prompt
      0  251f					      db	101
      1  251f		       65		      .byte.b	101
      0  2520					      db	(S10A-*)-1
      1  2520		       05		      .byte.b	(S10A-*)-1
      0  2521					      db	tString
      1  2521		       a0		      .byte.b	tString
      0  2522					      PRS
      0  2522					      db	2
      1  2522		       02		      .byte.b	2
      0  2523					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  2523					      db	101
      1  2523		       65		      .byte.b	101
      0  2524					      db	(S10Z-*)-1
      1  2524		       19		      .byte.b	(S10Z-*)-1
      0  2525					      db	oSemiColon
      1  2525		       e3		      .byte.b	oSemiColon
    473  2526				   S10A
      0  2526					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  2526					      db	33
      1  2526		       21		      .byte.b	33
      0  2527					      db	(UNKNOWN-*)-1
      1  2527		       86		      .byte.b	(UNKNOWN-*)-1
      0  2528					      CALL	FactVarPtrNoTst
      0  2528					      db	28
      1  2528		       1c		      .byte.b	28
      0  2529					      dw	FactVarPtrNoTst
      1  2529		       2a 27		      .word.w	FactVarPtrNoTst
    476  252b							;	  TSTB	     S10ACONT,oBang	      ; Print from another task
    477  252b							;	  IND
    478  252b							;	  TSTVT      UNKNOWN
    479  252b
    480  252b				   S10ACONT
      0  252b					      TSTB	S10A1,oDollar
      0  252b					      db	101
      1  252b		       65		      .byte.b	101
      0  252c					      db	(S10A1-*)-1
      1  252c		       07		      .byte.b	(S10A1-*)-1
      0  252d					      db	oDollar
      1  252d		       e7		      .byte.b	oDollar
      0  252e					      INSTR		;Move character From tty to AESTK
      0  252e					      db	59
      1  252e		       3b		      .byte.b	59
      0  252f					      SETR2	tByte
      0  252f					      db	94
      1  252f		       5e		      .byte.b	94
      0  2530					      db	tByte
      1  2530		       a2		      .byte.b	tByte
      0  2531					      IJMP	S10A2
      0  2531					      db	29
      1  2531		       1d		      .byte.b	29
      0  2532					      dw	S10A2
      1  2532		       37 25		      .word.w	S10A2
    485  2534				   S10A1
      0  2534					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  2534					      db	11
      1  2534		       0b		      .byte.b	11
      0  2535					      SETR2	tInteger
      0  2535					      db	94
      1  2535		       5e		      .byte.b	94
      0  2536					      db	tInteger
      1  2536		       a1		      .byte.b	tInteger
    488  2537				   S10A2
      0  2537					      STORE		;STORE IT
      0  2537					      db	19
      1  2537		       13		      .byte.b	19
      0  2538					      TSTB	S11,oComma	;IS THERE MORE?
      0  2538					      db	101
      1  2538		       65		      .byte.b	101
      0  2539					      db	(S11-*)-1
      1  2539		       07		      .byte.b	(S11-*)-1
      0  253a					      db	oComma
      1  253a		       e2		      .byte.b	oComma
      0  253b					      IJMP	S10	;YES
      0  253b					      db	29
      1  253b		       1d		      .byte.b	29
      0  253c					      dw	S10
      1  253c		       1f 25		      .word.w	S10
    492  253e				   S10Z
      0  253e					      iJMP	UNKNOWN
      0  253e					      db	29
      1  253e		       1d		      .byte.b	29
      0  253f					      dw	UNKNOWN
      1  253f		       ae 25		      .word.w	UNKNOWN
    494  2541				   S11
      0  2541					      DONE		;MUST BE CR
      0  2541					      db	1
      1  2541		       01		      .byte.b	1
      0  2542					      NXT	CO	;SEQUENCE TO NEXT
      0  2542					      db	6
      1  2542		       06		      .byte.b	6
      0  2543					      dw	CO
      1  2543		       6d 23		      .word.w	CO
      0  2545					      IJMP	STMT
      0  2545					      db	29
      1  2545		       1d		      .byte.b	29
      0  2546					      dw	STMT
      1  2546		       75 23		      .word.w	STMT
    498  2548							;=====================================================================
    499  2548							; End of program, return to command line process
    500  2548							; Main Task may also use taske or return to stopped
    501  2548							;
    502  2548							;S13:
    503  2548							;	  TSTB	      S14,kEnd
    504  2548				   ekEnd
      0  2548					      FIN
      0  2548					      db	12
      1  2548		       0c		      .byte.b	12
    506  2549
    507  2549				   UNKNOWNV
      0  2549					      IJMP	UNKNOWN
      0  2549					      db	29
      1  2549		       1d		      .byte.b	29
      0  254a					      dw	UNKNOWN
      1  254a		       ae 25		      .word.w	UNKNOWN
    509  254c							;====================================================================
    510  254c							; IRQ <IRQ-HANDLER-Line expression>
    511  254c							;   Specify a line number subroutine to call when an interupt is processed
    512  254c							;   These subroutines must use iret to return.
    513  254c							;
    514  254c							;S14:
    515  254c							;	  TSTB	      S14Z,kIrq      ;Check if we are setting IRQ HANDLER
    516  254c				   ekIrq
      0  254c					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  254c					      db	28
      1  254c		       1c		      .byte.b	28
      0  254d					      dw	EXPR
      1  254d		       b2 25		      .word.w	EXPR
      0  254f					      DONE		;must be CR
      0  254f					      db	1
      1  254f		       01		      .byte.b	1
      0  2550					      SETIRQ		;Set the line number now
      0  2550					      db	56
      1  2550		       38		      .byte.b	56
      0  2551					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  2551					      db	6
      1  2551		       06		      .byte.b	6
      0  2552					      dw	CO
      1  2552		       6d 23		      .word.w	CO
      0  2554					      IJMP	STMT
      0  2554					      db	29
      1  2554		       1d		      .byte.b	29
      0  2555					      dw	STMT
      1  2555		       75 23		      .word.w	STMT
    522  2557
    523  2557							;=========================================================================
    524  2557							; KILL PID-expression	 kill a running task
    525  2557							;  ignored of task has already stopped
    526  2557							;
    527  2557							;S14Z:
    528  2557							;	  TSTB	     S14S1,kKill     ; Kill A running Task
    529  2557				   ekKill
      0  2557					      CALL	EXPR
      0  2557					      db	28
      1  2557		       1c		      .byte.b	28
      0  2558					      dw	EXPR
      1  2558		       b2 25		      .word.w	EXPR
      0  255a					      DONE
      0  255a					      db	1
      1  255a		       01		      .byte.b	1
      0  255b					      TASKKILL
      0  255b					      db	65
      1  255b		       41		      .byte.b	65
      0  255c					      NXT	CO
      0  255c					      db	6
      1  255c		       06		      .byte.b	6
      0  255d					      dw	CO
      1  255d		       6d 23		      .word.w	CO
      0  255f					      IJMP	STMT
      0  255f					      db	29
      1  255f		       1d		      .byte.b	29
      0  2560					      dw	STMT
      1  2560		       75 23		      .word.w	STMT
    535  2562
    536  2562							;============================================================================
    537  2562							; List all program lines
    538  2562							;
    539  2562							;S14S1:
    540  2562							;	  TSTB	      S15,kList      ;LIST COMMAND
    541  2562				   ekList
      0  2562					      DONE
      0  2562					      db	1
      1  2562		       01		      .byte.b	1
      0  2563					      LST
      0  2563					      db	21
      1  2563		       15		      .byte.b	21
      0  2564					      IJMP	CO
      0  2564					      db	29
      1  2564		       1d		      .byte.b	29
      0  2565					      dw	CO
      1  2565		       6d 23		      .word.w	CO
    545  2567							;=======================================================================
    546  2567							;RUN begin to executed the program in memory
    547  2567							;
    548  2567							;S15:
    549  2567							;	  TSTB	      S16,kRun	     ;RUN COMMAND
    550  2567				   ekRun
      0  2567					      DONE
      0  2567					      db	1
      1  2567		       01		      .byte.b	1
      0  2568					      VINIT		;clear variables compile the line numbers
      0  2568					      db	30
      1  2568		       1e		      .byte.b	30
      0  2569					      LIT	1	;GOTO line 1
      0  2569					      db	27
      1  2569		       1b		      .byte.b	27
      0  256a					      dw	1
      1  256a		       01 00		      .word.w	1
      0  256c					      XFER		;Bob's addition
      0  256c					      db	7
      1  256c		       07		      .byte.b	7
    555  256d							; EXIT
      0  256d					      IJMP	STMT	;and run!
      0  256d					      db	29
      1  256d		       1d		      .byte.b	29
      0  256e					      dw	STMT
      1  256e		       75 23		      .word.w	STMT
    557  2570							;=========================================================================
    558  2570							;Clear the program memory, delete all proram lines
    559  2570							;
    560  2570							;S16:
    561  2570							;	  TSTB	      S16A,kNew      ;clear program
    562  2570				   ekNew
      0  2570					      DONE
      0  2570					      db	1
      1  2570		       01		      .byte.b	1
      0  2571					      IJMP	START
      0  2571					      db	29
      1  2571		       1d		      .byte.b	29
      0  2572					      dw	START
      1  2572		       67 23		      .word.w	START
    565  2574
    566  2574							;========================================================================
    567  2574							; Slice(slice legth expression)
    568  2574							;   set the length of time between task switches
    569  2574							;
    570  2574							;S16A:
    571  2574							;	  TSTB	      S16Trace,kSlice
    572  2574				   ekSlice
      0  2574					      CALL	EXPR
      0  2574					      db	28
      1  2574		       1c		      .byte.b	28
      0  2575					      dw	EXPR
      1  2575		       b2 25		      .word.w	EXPR
      0  2577					      SLICE
      0  2577					      db	100
      1  2577		       64		      .byte.b	100
      0  2578					      DONE
      0  2578					      db	1
      1  2578		       01		      .byte.b	1
      0  2579					      NXT	CO
      0  2579					      db	6
      1  2579		       06		      .byte.b	6
      0  257a					      dw	CO
      1  257a		       6d 23		      .word.w	CO
      0  257c					      IJMP	STMT
      0  257c					      db	29
      1  257c		       1d		      .byte.b	29
      0  257d					      dw	STMT
      1  257d		       75 23		      .word.w	STMT
    578  257f							;==========================================================================
    579  257f							; Turn off and on the thrace functions
    580  257f							; a debug terminal needs to be available
    581  257f							; Trace( Trace flag expression)
    582  257f							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    583  257f							;	for individual lines of basic code. These can be combined
    584  257f							;S16Trace:
    585  257f							;	  TSTB	      S17A,kTrace
    586  257f				   ekTrace
      0  257f					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  257f					      db	101
      1  257f		       65		      .byte.b	101
      0  2580					      db	(UNKNOWN-*)-1
      1  2580		       2d		      .byte.b	(UNKNOWN-*)-1
      0  2581					      db	oLeftBracket
      1  2581		       e0		      .byte.b	oLeftBracket
      0  2582					      CALL	EXPR
      0  2582					      db	28
      1  2582		       1c		      .byte.b	28
      0  2583					      dw	EXPR
      1  2583		       b2 25		      .word.w	EXPR
      0  2585					      TSTB	UNKNOWN,oRightBracket
      0  2585					      db	101
      1  2585		       65		      .byte.b	101
      0  2586					      db	(UNKNOWN-*)-1
      1  2586		       27		      .byte.b	(UNKNOWN-*)-1
      0  2587					      db	oRightBracket
      1  2587		       e1		      .byte.b	oRightBracket
      0  2588					      TRACEPROGRAM
      0  2588					      db	78
      1  2588		       4e		      .byte.b	78
      0  2589					      DONE
      0  2589					      db	1
      1  2589		       01		      .byte.b	1
      0  258a					      NXT	CO
      0  258a					      db	6
      1  258a		       06		      .byte.b	6
      0  258b					      dw	CO
      1  258b		       6d 23		      .word.w	CO
      0  258d					      IJMP	STMT
      0  258d					      db	29
      1  258d		       1d		      .byte.b	29
      0  258e					      dw	STMT
      1  258e		       75 23		      .word.w	STMT
    594  2590							;=====================================================================
    595  2590							; Exit basic to machine monitor
    596  2590							;
    597  2590							;S17A:
    598  2590							;	  TSTB	      S17B,kExit      ;allow them to exit BASIC
    599  2590				   ekExit
      0  2590					      EXIT
      0  2590					      db	26
      1  2590		       1a		      .byte.b	26
    601  2591
    602  2591							;=======================================================================
    603  2591							; Commands related to saving/restoring programs
    604  2591							; to/from mass storage.
    605  2591							;=======================================================================
    606  2591							; Save a program file
    607  2591							;
    608  2591							;S17B:
    609  2591					      if	(XKIM || CTMON65) && DISK_ACCESS
    610  2591
    611  2591							;	  TSTB	      S17C,kSave
    612  2591				   ekSave
      0  2591					      OPENWRITE
      0  2591					      db	40
      1  2591		       28		      .byte.b	40
      0  2592					      DLIST
      0  2592					      db	43
      1  2592		       2b		      .byte.b	43
      0  2593					      DCLOSE
      0  2593					      db	41
      1  2593		       29		      .byte.b	41
      0  2594					      IJMP	CO
      0  2594					      db	29
      1  2594		       1d		      .byte.b	29
      0  2595					      dw	CO
      1  2595		       6d 23		      .word.w	CO
    617  2597							;=========================================================================
    618  2597							; Load a program file
    619  2597							;
    620  2597							;S17C:
    621  2597							;	  TSTB	      S18,kLoad
    622  2597				   ekLoad
      0  2597					      OPENREAD
      0  2597					      db	39
      1  2597		       27		      .byte.b	39
    624  2598				   S17CLP
      0  2598					      DGETLINE		;get line from file
      0  2598					      db	42
      1  2598		       2a		      .byte.b	42
      0  2599					      TSTL	S17EOL	;no line num means EOL
      0  2599					      db	34
      1  2599		       22		      .byte.b	34
      0  259a					      db	(S17EOL-*)-1
      1  259a		       04		      .byte.b	(S17EOL-*)-1
      0  259b					      INSERT		;put it into the program
      0  259b					      db	24
      1  259b		       18		      .byte.b	24
      0  259c					      IJMP	S17CLP	;keep going
      0  259c					      db	29
      1  259c		       1d		      .byte.b	29
      0  259d					      dw	S17CLP
      1  259d		       98 25		      .word.w	S17CLP
    629  259f				   S17EOL
      0  259f					      DCLOSE		;close disk file
      0  259f					      db	41
      1  259f		       29		      .byte.b	41
      0  25a0					      IJMP	CO	;back to start
      0  25a0					      db	29
      1  25a0		       1d		      .byte.b	29
      0  25a1					      dw	CO
      1  25a1		       6d 23		      .word.w	CO
    632  25a3							;=========================================================================
    633  25a3							; Display the directory content
    634  25a3							;
    635  25a3							;S18:
    636  25a3							;	  TSTB	      S19,kDir
    637  25a3				   ekDir
      0  25a3					      DDIR		;Display the directory content
      0  25a3					      db	44
      1  25a3		       2c		      .byte.b	44
      0  25a4					      IJMP	CO
      0  25a4					      db	29
      1  25a4		       1d		      .byte.b	29
      0  25a5					      dw	CO
      1  25a5		       6d 23		      .word.w	CO
    640  25a7							;=========================================================================
    641  25a7							; Erase a file from disk
    642  25a7							;
      0  25a7				   S19	      TSTB	UNKNOWN,kErase
      0  25a7					      db	101
      1  25a7		       65		      .byte.b	101
      0  25a8					      db	(UNKNOWN-*)-1
      1  25a8		       05		      .byte.b	(UNKNOWN-*)-1
      0  25a9					      db	kErase
      1  25a9		       1e		      .byte.b	kErase
    644  25aa				   ekErase
      0  25aa					      RMFILE		;Erase the file from the disk
      0  25aa					      db	45
      1  25aa		       2d		      .byte.b	45
      0  25ab					      IJMP	CO
      0  25ab					      db	29
      1  25ab		       1d		      .byte.b	29
      0  25ac					      dw	CO
      1  25ac		       6d 23		      .word.w	CO
    647  25ae
    648  25ae					      endif
    649  25ae
    650  25ae							;===========================================================================
    651  25ae							; Else, unknown command.
    652  25ae							;
    653  25ae				   UNKNOWN
      0  25ae					      ENDIO
      0  25ae					      db	71
      1  25ae		       47		      .byte.b	71
    655  25af
    656  25af				   NotKnownStatement
    657  25af
      0  25af					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  25af					      db	13
      1  25af		       0d		      .byte.b	13
      0  25b0					      dw	ERR_SYNTAX
      1  25b0		       05 00		      .word.w	ERR_SYNTAX
    659  25b2
    660  25b2							;=======================================================
    661  25b2							; Process Expresions, precidence is represented by the
    662  25b2							; various call levels
    663  25b2							;
      0  25b2				   EXPR       TSTB	EXPRNEXT,oLeftBracket
      0  25b2					      db	101
      1  25b2		       65		      .byte.b	101
      0  25b3					      db	(EXPRNEXT-*)-1
      1  25b3		       0c		      .byte.b	(EXPRNEXT-*)-1
      0  25b4					      db	oLeftBracket
      1  25b4		       e0		      .byte.b	oLeftBracket
      0  25b5					      Call	EXPR
      0  25b5					      db	28
      1  25b5		       1c		      .byte.b	28
      0  25b6					      dw	EXPR
      1  25b6		       b2 25		      .word.w	EXPR
      0  25b8					      TSTB	ExpectBrace,oRightBracket
      0  25b8					      db	101
      1  25b8		       65		      .byte.b	101
      0  25b9					      db	(ExpectBrace-*)-1
      1  25b9		       02		      .byte.b	(ExpectBrace-*)-1
      0  25ba					      db	oRightBracket
      1  25ba		       e1		      .byte.b	oRightBracket
      0  25bb					      RTN
      0  25bb					      db	25
      1  25bb		       19		      .byte.b	25
    668  25bc
    669  25bc				   ExpectBrace
      0  25bc					      ENDIO
      0  25bc					      db	71
      1  25bc		       47		      .byte.b	71
      0  25bd					      ERRMSG	ERR_CLOSINGBRACKET
      0  25bd					      db	13
      1  25bd		       0d		      .byte.b	13
      0  25be					      dw	ERR_CLOSINGBRACKET
      1  25be		       17 00		      .word.w	ERR_CLOSINGBRACKET
    672  25c0
    673  25c0				   EXPRNEXT
      0  25c0					      TSTB	EXPRLOGS,kNot
      0  25c0					      db	101
      1  25c0		       65		      .byte.b	101
      0  25c1					      db	(EXPRLOGS-*)-1
      1  25c1		       06		      .byte.b	(EXPRLOGS-*)-1
      0  25c2					      db	kNot
      1  25c2		       24		      .byte.b	kNot
    675  25c3				   ekNot
      0  25c3					      Call	EXPR
      0  25c3					      db	28
      1  25c3		       1c		      .byte.b	28
      0  25c4					      dw	EXPR
      1  25c4		       b2 25		      .word.w	EXPR
      0  25c6					      LOGNOT
      0  25c6					      db	72
      1  25c6		       48		      .byte.b	72
      0  25c7					      RTN
      0  25c7					      db	25
      1  25c7		       19		      .byte.b	25
    679  25c8
    680  25c8							;=========================================================
    681  25c8							;Look for logical operators
    682  25c8				   EXPRLOGS
      0  25c8					      Call	EXPRCMP
      0  25c8					      db	28
      1  25c8		       1c		      .byte.b	28
      0  25c9					      dw	EXPRCMP
      1  25c9		       df 25		      .word.w	EXPRCMP
      0  25cb					      OnGoto	BasicLogical,iLOG3
      0  25cb					      db	103
      1  25cb		       67		      .byte.b	103
      0  25cc					      dw	BasicLogical
      1  25cc		       3d 23		      .word.w	BasicLogical
      0  25ce					      dw	iLOG3
      1  25ce		       de 25		      .word.w	iLOG3
    685  25d0							;	  TSTB	     iLOG1,kAnd
    686  25d0				   ekAnd
      0  25d0					      Call	EXPR
      0  25d0					      db	28
      1  25d0		       1c		      .byte.b	28
      0  25d1					      dw	EXPR
      1  25d1		       b2 25		      .word.w	EXPR
      0  25d3					      LOGAND
      0  25d3					      db	74
      1  25d3		       4a		      .byte.b	74
      0  25d4					      RTN
      0  25d4					      db	25
      1  25d4		       19		      .byte.b	25
    690  25d5							;iLOG1:
    691  25d5							;	  TSTB	     iLOG2,kOr
    692  25d5				   ekOr
      0  25d5					      Call	EXPR
      0  25d5					      db	28
      1  25d5		       1c		      .byte.b	28
      0  25d6					      dw	EXPR
      1  25d6		       b2 25		      .word.w	EXPR
      0  25d8					      LOGOR
      0  25d8					      db	73
      1  25d8		       49		      .byte.b	73
      0  25d9					      RTN
      0  25d9					      db	25
      1  25d9		       19		      .byte.b	25
    696  25da							;iLOG2:
    697  25da							;	  TSTB	  iLOG3,kXor
    698  25da				   ekXor
      0  25da					      Call	EXPR
      0  25da					      db	28
      1  25da		       1c		      .byte.b	28
      0  25db					      dw	EXPR
      1  25db		       b2 25		      .word.w	EXPR
      0  25dd					      LOGXOR
      0  25dd					      db	75
      1  25dd		       4b		      .byte.b	75
    701  25de				   iLOG3
      0  25de					      RTN
      0  25de					      db	25
      1  25de		       19		      .byte.b	25
    703  25df							;========================================================================
    704  25df							; Process relational operators
    705  25df							;
    706  25df				   EXPRCMP
      0  25df					      Call	EXPR2	; get the first expression
      0  25df					      db	28
      1  25df		       1c		      .byte.b	28
      0  25e0					      dw	EXPR2
      1  25e0		       ea 25		      .word.w	EXPR2
      0  25e2					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  25e2					      db	104
      1  25e2		       68		      .byte.b	104
      0  25e3					      db	(iRDone-*)-1
      1  25e3		       05		      .byte.b	(iRDone-*)-1
    709  25e4							;	  TSTB	     iR0,oEqual
    710  25e4							;	  LIT	     2		     ;=
    711  25e4							;	  IJMP	     iRFound
    712  25e4							;iR0:
    713  25e4							;	  TSTB	      iR1,oLessEqual
    714  25e4							;	  LIT	      3 	      ;<=
    715  25e4							;	  IJMP	     iRFound
    716  25e4							;iR1:
    717  25e4							;	  TSTB	     iR3,oNotEqual
    718  25e4							;	  LIT	     5		      ;<>
    719  25e4							;	      IJMP	  iRFound
    720  25e4							;iR3:
    721  25e4							;	  TSTB	     iR4,oLess
    722  25e4							;	  LIT	     1		     ;<
    723  25e4							;	      IJMP	  iRFound
    724  25e4							;iR4:
    725  25e4							;	  TST	     iR5,oGreaterEqual
    726  25e4							;	  LIT	     6		     ;>=
    727  25e4							;	      IJMP	  iRFound
    728  25e4							;iR5:
    729  25e4							;	  TSTB	     iRDone,oGreater
    730  25e4							;	  LIT	     4		     ;>
    731  25e4				   iRFound
      0  25e4					      Call	EXPR	; get the right side of the expression
      0  25e4					      db	28
      1  25e4		       1c		      .byte.b	28
      0  25e5					      dw	EXPR
      1  25e5		       b2 25		      .word.w	EXPR
      0  25e7					      CMPR		; Push the value of the true false onto the stack
      0  25e7					      db	10
      1  25e7		       0a		      .byte.b	10
      0  25e8					      RTN
      0  25e8					      db	25
      1  25e8		       19		      .byte.b	25
    735  25e9
    736  25e9				   iRDone
      0  25e9					      RTN
      0  25e9					      db	25
      1  25e9		       19		      .byte.b	25
    738  25ea
    739  25ea				   EXPR2
      0  25ea					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  25ea					      db	101
      1  25ea		       65		      .byte.b	101
      0  25eb					      db	(E0-*)-1
      1  25eb		       08		      .byte.b	(E0-*)-1
      0  25ec					      db	oMinus
      1  25ec		       eb		      .byte.b	oMinus
      0  25ed					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  25ed					      db	28
      1  25ed		       1c		      .byte.b	28
      0  25ee					      dw	TERM
      1  25ee		       10 26		      .word.w	TERM
      0  25f0					      NEG		; Make value negated
      0  25f0					      db	16
      1  25f0		       10		      .byte.b	16
      0  25f1					      IJMP	E1	; We have Left term process operators next
      0  25f1					      db	29
      1  25f1		       1d		      .byte.b	29
      0  25f2					      dw	E1
      1  25f2		       fa 25		      .word.w	E1
    744  25f4				   E0
      0  25f4					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  25f4					      db	101
      1  25f4		       65		      .byte.b	101
      0  25f5					      db	(E1A-*)-1
      1  25f5		       01		      .byte.b	(E1A-*)-1
      0  25f6					      db	oPlus
      1  25f6		       ea		      .byte.b	oPlus
    746  25f7				   E1A
      0  25f7					      CALL	TERM	; Get the left term if it was not negated
      0  25f7					      db	28
      1  25f7		       1c		      .byte.b	28
      0  25f8					      dw	TERM
      1  25f8		       10 26		      .word.w	TERM
    748  25fa				   E1
      0  25fa					      TST	E2,oPlus	; Check if we are adding left term to something
      0  25fa					      db	32
      1  25fa		       20		      .byte.b	32
      0  25fb					      db	(E2-*)-1
      1  25fb		       09		      .byte.b	(E2-*)-1
      0  25fc					      db	oPlus,0
      1  25fc		       ea 00		      .byte.b	oPlus,0
      0  25fe					      CALL	TERM	; if adding then get the right side term
      0  25fe					      db	28
      1  25fe		       1c		      .byte.b	28
      0  25ff					      dw	TERM
      1  25ff		       10 26		      .word.w	TERM
      0  2601					      ADD		; Add it to left term
      0  2601					      db	14
      1  2601		       0e		      .byte.b	14
      0  2602					      IJMP	E1	; look for next + or -
      0  2602					      db	29
      1  2602		       1d		      .byte.b	29
      0  2603					      dw	E1
      1  2603		       fa 25		      .word.w	E1
    753  2605				   E2
      0  2605					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  2605					      db	101
      1  2605		       65		      .byte.b	101
      0  2606					      db	(E3-*)-1
      1  2606		       08		      .byte.b	(E3-*)-1
      0  2607					      db	oMinus
      1  2607		       eb		      .byte.b	oMinus
      0  2608					      CALL	TERM	; get right side to subtract Diffrence
      0  2608					      db	28
      1  2608		       1c		      .byte.b	28
      0  2609					      dw	TERM
      1  2609		       10 26		      .word.w	TERM
      0  260b					      SUB		; Subtract the value
      0  260b					      db	15
      1  260b		       0f		      .byte.b	15
      0  260c					      IJMP	E1	; Look for next + or -
      0  260c					      db	29
      1  260c		       1d		      .byte.b	29
      0  260d					      dw	E1
      1  260d		       fa 25		      .word.w	E1
    758  260f				   E3			; Finish processing the expression
      0  260f					      RTN		; We are finished processing the Expression
      0  260f					      db	25
      1  260f		       19		      .byte.b	25
    760  2610							;
    761  2610							; Get one of the terms of an expression
    762  2610							;
    763  2610				   TERM
      0  2610					      CALL	FACT	; Get a value
      0  2610					      db	28
      1  2610		       1c		      .byte.b	28
      0  2611					      dw	FACT
      1  2611		       35 26		      .word.w	FACT
    765  2613				   T0			; Check for higher precidence operators
      0  2613					      TSTB	T1,oMultiply	; Check for *
      0  2613					      db	101
      1  2613		       65		      .byte.b	101
      0  2614					      db	(T1-*)-1
      1  2614		       08		      .byte.b	(T1-*)-1
      0  2615					      db	oMultiply
      1  2615		       ee		      .byte.b	oMultiply
      0  2616					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  2616					      db	28
      1  2616		       1c		      .byte.b	28
      0  2617					      dw	FACT
      1  2617		       35 26		      .word.w	FACT
      0  2619					      MUL		; Multiply factors
      0  2619					      db	17
      1  2619		       11		      .byte.b	17
      0  261a					      IJMP	T0	; Check for * or /
      0  261a					      db	29
      1  261a		       1d		      .byte.b	29
      0  261b					      dw	T0
      1  261b		       13 26		      .word.w	T0
    770  261d				   T1
      0  261d					      TSTB	T2,oDivide	; Check for a division
      0  261d					      db	101
      1  261d		       65		      .byte.b	101
      0  261e					      db	(T2-*)-1
      1  261e		       08		      .byte.b	(T2-*)-1
      0  261f					      db	oDivide
      1  261f		       ec		      .byte.b	oDivide
      0  2620					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2620					      db	28
      1  2620		       1c		      .byte.b	28
      0  2621					      dw	FACT
      1  2621		       35 26		      .word.w	FACT
      0  2623					      DIV		; do division
      0  2623					      db	18
      1  2623		       12		      .byte.b	18
      0  2624					      IJMP	T0	; check for more * or /
      0  2624					      db	29
      1  2624		       1d		      .byte.b	29
      0  2625					      dw	T0
      1  2625		       13 26		      .word.w	T0
    775  2627				   T2
      0  2627					      TSTB	T3,oModulo	; Check for a division
      0  2627					      db	101
      1  2627		       65		      .byte.b	101
      0  2628					      db	(T3-*)-1
      1  2628		       08		      .byte.b	(T3-*)-1
      0  2629					      db	oModulo
      1  2629		       ed		      .byte.b	oModulo
      0  262a					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  262a					      db	28
      1  262a		       1c		      .byte.b	28
      0  262b					      dw	FACT
      1  262b		       35 26		      .word.w	FACT
      0  262d					      MODULO		; do division for remainder
      0  262d					      db	60
      1  262d		       3c		      .byte.b	60
      0  262e					      IJMP	T0	; check for more * or / or %
      0  262e					      db	29
      1  262e		       1d		      .byte.b	29
      0  262f					      dw	T0
      1  262f		       13 26		      .word.w	T0
    780  2631				   T3			; Finish processing the Term
      0  2631					      RTN
      0  2631					      db	25
      1  2631		       19		      .byte.b	25
    782  2632
    783  2632				   UNKNOWNVEC
      0  2632					      IJMP	UNKNOWN
      0  2632					      db	29
      1  2632		       1d		      .byte.b	29
      0  2633					      dw	UNKNOWN
      1  2633		       ae 25		      .word.w	UNKNOWN
    785  2635
    786  2635							;=============================================================================================
    787  2635							; Factor an expression.  Always test for functions
    788  2635							; first or else they'll be confused for variables.
    789  2635							;
    790  2635				   FACT
      0  2635					      OnGoto	BasicFuncs,FactNumber
      0  2635					      db	103
      1  2635		       67		      .byte.b	103
      0  2636					      dw	BasicFuncs
      1  2636		       45 23		      .word.w	BasicFuncs
      0  2638					      dw	FactNumber
      1  2638		       0e 27		      .word.w	FactNumber
    792  263a
    793  263a							;FACTCONTINUE:
    794  263a							;	  TSTB	     F1AA,kTrue
    795  263a				   ekTrue
      0  263a					      LIT	-1
      0  263a					      db	27
      1  263a		       1b		      .byte.b	27
      0  263b					      dw	-1
      1  263b		       ff ff		      .word.w	-1
      0  263d					      RTN
      0  263d					      db	25
      1  263d		       19		      .byte.b	25
    798  263e							;F1AA:
    799  263e							;	  TSTB	     F1AB,kFalse
    800  263e				   ekFalse
      0  263e					      LIT	0
      0  263e					      db	27
      1  263e		       1b		      .byte.b	27
      0  263f					      dw	0
      1  263f		       00 00		      .word.w	0
      0  2641					      RTN
      0  2641					      db	25
      1  2641		       19		      .byte.b	25
    803  2642							;==================================================================================
    804  2642							; Returns the amount of free SPACE
    805  2642							;
    806  2642							;F1AB
    807  2642							;	  TSTB	     F1A,kFree
    808  2642				   ekFree
      0  2642					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2642					      db	101
      1  2642		       65		      .byte.b	101
      0  2643					      db	(UNKNOWNVEC-*)-1
      1  2643		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  2644					      db	oLeftBracket
      1  2644		       e0		      .byte.b	oLeftBracket
      0  2645					      TSTB	UNKNOWNVEC,oRightBracket
      0  2645					      db	101
      1  2645		       65		      .byte.b	101
      0  2646					      db	(UNKNOWNVEC-*)-1
      1  2646		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  2647					      db	oRightBracket
      1  2647		       e1		      .byte.b	oRightBracket
      0  2648					      FREE
      0  2648					      db	36
      1  2648		       24		      .byte.b	36
      0  2649					      RTN
      0  2649					      db	25
      1  2649		       19		      .byte.b	25
    813  264a							;===================================================================================
    814  264a							; getch() read a character from the input device
    815  264a							;
    816  264a							;F1A:
    817  264a							;	  TSTB	     F1A2,kGetch		      ; read char from the terminal
    818  264a				   ekGetch
      0  264a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  264a					      db	101
      1  264a		       65		      .byte.b	101
      0  264b					      db	(UNKNOWNVEC-*)-1
      1  264b		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  264c					      db	oLeftBracket
      1  264c		       e0		      .byte.b	oLeftBracket
      0  264d					      TSTB	UNKNOWNVEC,oRightBracket
      0  264d					      db	101
      1  264d		       65		      .byte.b	101
      0  264e					      db	(UNKNOWNVEC-*)-1
      1  264e		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  264f					      db	oRightBracket
      1  264f		       e1		      .byte.b	oRightBracket
      0  2650					      GETCHAR
      0  2650					      db	51
      1  2650		       33		      .byte.b	51
      0  2651					      RTN
      0  2651					      db	25
      1  2651		       19		      .byte.b	25
    823  2652							;
    824  2652							;====================================================================================
    825  2652							; addr(variable definition)
    826  2652							; Returns the address of a variable on top of the stack
    827  2652				   ekAddr
      0  2652					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2652					      db	101
      1  2652		       65		      .byte.b	101
      0  2653					      db	(UNKNOWNVEC-*)-1
      1  2653		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  2654					      db	oLeftBracket
      1  2654		       e0		      .byte.b	oLeftBracket
      0  2655					      TSTV	ExpectedVariable
      0  2655					      db	33
      1  2655		       21		      .byte.b	33
      0  2656					      db	(ExpectedVariable-*)-1
      1  2656		       07		      .byte.b	(ExpectedVariable-*)-1
      0  2657					      CALL	FactVarPtrNoTst
      0  2657					      db	28
      1  2657		       1c		      .byte.b	28
      0  2658					      dw	FactVarPtrNoTst
      1  2658		       2a 27		      .word.w	FactVarPtrNoTst
      0  265a					      TSTB	UNKNOWNVEC,oRightBracket
      0  265a					      db	101
      1  265a		       65		      .byte.b	101
      0  265b					      db	(UNKNOWNVEC-*)-1
      1  265b		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  265c					      db	oRightBracket
      1  265c		       e1		      .byte.b	oRightBracket
      0  265d					      RTN
      0  265d					      db	25
      1  265d		       19		      .byte.b	25
    833  265e
    834  265e				   ExpectedVariable
      0  265e					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  265e					      db	13
      1  265e		       0d		      .byte.b	13
      0  265f					      dw	ERR_SYNTAX
      1  265f		       05 00		      .word.w	ERR_SYNTAX
    836  2661
    837  2661							;====================================================================================
    838  2661							; peek(mem address) return the value of a byte in memory
    839  2661							; @[offset] return a word value from offset -- see tstv
    840  2661							;
    841  2661							;F1A2:
    842  2661							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    843  2661				   ekPeek
      0  2661					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2661					      db	101
      1  2661		       65		      .byte.b	101
      0  2662					      db	(UNKNOWNVEC-*)-1
      1  2662		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  2663					      db	oLeftBracket
      1  2663		       e0		      .byte.b	oLeftBracket
      0  2664					      CALL	EXPR	;Get the address to write to
      0  2664					      db	28
      1  2664		       1c		      .byte.b	28
      0  2665					      dw	EXPR
      1  2665		       b2 25		      .word.w	EXPR
      0  2667					      TSTB	UNKNOWNVEC,oRightBracket
      0  2667					      db	101
      1  2667		       65		      .byte.b	101
      0  2668					      db	(UNKNOWNVEC-*)-1
      1  2668		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  2669					      db	oRightBracket
      1  2669		       e1		      .byte.b	oRightBracket
      0  266a					      PEEKMEM
      0  266a					      db	48
      1  266a		       30		      .byte.b	48
      0  266b					      RTN
      0  266b					      db	25
      1  266b		       19		      .byte.b	25
    849  266c							;=======================================================================================
    850  266c							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    851  266c							;
    852  266c							;F2AZ:
    853  266c							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    854  266c				   ekTask
      0  266c					      TSTBRANCH	ekTaskCompiled
      0  266c					      db	106
      1  266c		       6a		      .byte.b	106
      0  266d					      db	(ekTaskCompiled-*)-1
      1  266d		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  266e					      TSTB	UNKNOWNVEC,oLeftBracket
      0  266e					      db	101
      1  266e		       65		      .byte.b	101
      0  266f					      db	(UNKNOWNVEC-*)-1
      1  266f		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  2670					      db	oLeftBracket
      1  2670		       e0		      .byte.b	oLeftBracket
      0  2671					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2671					      db	28
      1  2671		       1c		      .byte.b	28
      0  2672					      dw	EXPR
      1  2672		       b2 25		      .word.w	EXPR
      0  2674					      lit	0
      0  2674					      db	27
      1  2674		       1b		      .byte.b	27
      0  2675					      dw	0
      1  2675		       00 00		      .word.w	0
      0  2677					      iJMP	ekTaskLinenum
      0  2677					      db	29
      1  2677		       1d		      .byte.b	29
      0  2678					      dw	ekTaskLinenum
      1  2678		       7d 26		      .word.w	ekTaskLinenum
    860  267a
    861  267a				   ekTaskCompiled
      0  267a					      lit	1
      0  267a					      db	27
      1  267a		       1b		      .byte.b	27
      0  267b					      dw	1
      1  267b		       01 00		      .word.w	1
    863  267d
    864  267d				   ekTaskLinenum
      0  267d					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  267d					      db	61
      1  267d		       3d		      .byte.b	61
      0  267e					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  267e					      db	101
      1  267e		       65		      .byte.b	101
      0  267f					      db	(F2AZNoParms-*)-1
      1  267f		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  2680					      db	oComma
      1  2680		       e2		      .byte.b	oComma
      0  2681					      SAVEMATHSTACK		;Push The mathstack
      0  2681					      db	86
      1  2681		       56		      .byte.b	86
      0  2682					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  2682					      db	89
      1  2682		       59		      .byte.b	89
    869  2683				   F2AZLOOP
      0  2683					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  2683					      db	28
      1  2683		       1c		      .byte.b	28
      0  2684					      dw	EXPR
      1  2684		       b2 25		      .word.w	EXPR
      0  2686					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  2686					      db	101
      1  2686		       65		      .byte.b	101
      0  2687					      db	(F2AZEndParm-*)-1
      1  2687		       04		      .byte.b	(F2AZEndParm-*)-1
      0  2688					      db	oComma
      1  2688		       e2		      .byte.b	oComma
      0  2689					      IJMP	F2AZLOOP	;check for more
      0  2689					      db	29
      1  2689		       1d		      .byte.b	29
      0  268a					      dw	F2AZLOOP
      1  268a		       83 26		      .word.w	F2AZLOOP
    873  268c
    874  268c				   F2AZEndParm
      0  268c					      RESTOREMATHSTACK		;Back to normal stack
      0  268c					      db	87
      1  268c		       57		      .byte.b	87
      0  268d					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  268d					      db	92
      1  268d		       5c		      .byte.b	92
    877  268e
    878  268e				   F2AZNoParms
      0  268e					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  268e					      db	101
      1  268e		       65		      .byte.b	101
      0  268f					      db	(UNKNOWNVEC-*)-1
      1  268f		       a2		      .byte.b	(UNKNOWNVEC-*)-1
      0  2690					      db	oRightBracket
      1  2690		       e1		      .byte.b	oRightBracket
    880  2691
      0  2691					      TASKENABLE		;Enable the task to execute
      0  2691					      db	90
      1  2691		       5a		      .byte.b	90
    882  2692
      0  2692					      RTN		;Returns the Task number
      0  2692					      db	25
      1  2692		       19		      .byte.b	25
    884  2693							;=========================================================================================
    885  2693							; Check for IPC interproccess instructions
    886  2693							;   IPCS  - Send a message
    887  2693							;
    888  2693							;F2AZ1:
    889  2693							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    890  2693				   ekIpcs
      0  2693					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2693					      db	101
      1  2693		       65		      .byte.b	101
      0  2694					      db	(UNKNOWNVEC-*)-1
      1  2694		       9d		      .byte.b	(UNKNOWNVEC-*)-1
      0  2695					      db	oLeftBracket
      1  2695		       e0		      .byte.b	oLeftBracket
      0  2696					      CALL	EXPR	;Get the message value
      0  2696					      db	28
      1  2696		       1c		      .byte.b	28
      0  2697					      dw	EXPR
      1  2697		       b2 25		      .word.w	EXPR
      0  2699					      TSTB	UNKNOWNVEC,oComma
      0  2699					      db	101
      1  2699		       65		      .byte.b	101
      0  269a					      db	(UNKNOWNVEC-*)-1
      1  269a		       97		      .byte.b	(UNKNOWNVEC-*)-1
      0  269b					      db	oComma
      1  269b		       e2		      .byte.b	oComma
      0  269c					      CALL	EXPR	;Get pid of task to send to
      0  269c					      db	28
      1  269c		       1c		      .byte.b	28
      0  269d					      dw	EXPR
      1  269d		       b2 25		      .word.w	EXPR
      0  269f					      TSTB	UNKNOWNVEC,oRightBracket
      0  269f					      db	101
      1  269f		       65		      .byte.b	101
      0  26a0					      db	(UNKNOWNVEC-*)-1
      1  26a0		       91		      .byte.b	(UNKNOWNVEC-*)-1
      0  26a1					      db	oRightBracket
      1  26a1		       e1		      .byte.b	oRightBracket
      0  26a2					      IPCSEND		;Send msg and clear pid msg pending
      0  26a2					      db	80
      1  26a2		       50		      .byte.b	80
      0  26a3					      RTN
      0  26a3					      db	25
      1  26a3		       19		      .byte.b	25
    898  26a4							;================================================================================
    899  26a4							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    900  26a4							;
    901  26a4							;F2AZa:
    902  26a4							;	  TSTB	      F2AZb,kIpcr		      ;IPCR recieve a message , wait if none
    903  26a4				   ekIpcr
      0  26a4					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  26a4					      db	101
      1  26a4		       65		      .byte.b	101
      0  26a5					      db	(UNKNOWNVEC-*)-1
      1  26a5		       8c		      .byte.b	(UNKNOWNVEC-*)-1
      0  26a6					      db	oLeftBracket
      1  26a6		       e0		      .byte.b	oLeftBracket
      0  26a7					      TSTB	F2AZa1,oRightBracket
      0  26a7					      db	101
      1  26a7		       65		      .byte.b	101
      0  26a8					      db	(F2AZa1-*)-1
      1  26a8		       07		      .byte.b	(F2AZa1-*)-1
      0  26a9					      db	oRightBracket
      1  26a9		       e1		      .byte.b	oRightBracket
      0  26aa					      LIT	0	;We dont want the pid returned to us
      0  26aa					      db	27
      1  26aa		       1b		      .byte.b	27
      0  26ab					      dw	0
      1  26ab		       00 00		      .word.w	0
      0  26ad					      IJMP	ekIpcrComplete
      0  26ad					      db	29
      1  26ad		       1d		      .byte.b	29
      0  26ae					      dw	ekIpcrComplete
      1  26ae		       b5 26		      .word.w	ekIpcrComplete
    908  26b0				   F2AZa1
      0  26b0					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  26b0					      db	33
      1  26b0		       21		      .byte.b	33
      0  26b1					      db	(UNKNOWNVEC-*)-1
      1  26b1		       80		      .byte.b	(UNKNOWNVEC-*)-1
      0  26b2					      TSTB	UNKNOWNVEC,oRightBracket
      0  26b2					      db	101
      1  26b2		       65		      .byte.b	101
      0  26b3					      db	(UNKNOWNVEC-*)-1
      1  26b3		       7e		      .byte.b	(UNKNOWNVEC-*)-1
      0  26b4					      db	oRightBracket
      1  26b4		       e1		      .byte.b	oRightBracket
    911  26b5
    912  26b5				   ekIpcrComplete
      0  26b5					      IPCIO		;Set the io bit and exit task till message
      0  26b5					      db	83
      1  26b5		       53		      .byte.b	83
      0  26b6					      IPCRECEIVE		;Get the message
      0  26b6					      db	81
      1  26b6		       51		      .byte.b	81
      0  26b7					      RTN
      0  26b7					      db	25
      1  26b7		       19		      .byte.b	25
    916  26b8							;===============================================================================
    917  26b8							; IPCC ---- check if a message is available
    918  26b8							;F2AZb:
    919  26b8							;	  TST	     F2A,kIpcc			      ;Returns number of messages on the message queue
    920  26b8				   ekIpcc
      0  26b8					      TSTB	UNKNOWNVEC,oLeftBracket
      0  26b8					      db	101
      1  26b8		       65		      .byte.b	101
      0  26b9					      db	(UNKNOWNVEC-*)-1
      1  26b9		       78		      .byte.b	(UNKNOWNVEC-*)-1
      0  26ba					      db	oLeftBracket
      1  26ba		       e0		      .byte.b	oLeftBracket
      0  26bb					      TSTB	UNKNOWNVEC,oRightBracket
      0  26bb					      db	101
      1  26bb		       65		      .byte.b	101
      0  26bc					      db	(UNKNOWNVEC-*)-1
      1  26bc		       75		      .byte.b	(UNKNOWNVEC-*)-1
      0  26bd					      db	oRightBracket
      1  26bd		       e1		      .byte.b	oRightBracket
      0  26be					      IPCCHECK
      0  26be					      db	82
      1  26be		       52		      .byte.b	82
      0  26bf					      RTN
      0  26bf					      db	25
      1  26bf		       19		      .byte.b	25
    925  26c0
    926  26c0				   UNKNOWNID
      0  26c0					      IJMP	UNKNOWN
      0  26c0					      db	29
      1  26c0		       1d		      .byte.b	29
      0  26c1					      dw	UNKNOWN
      1  26c1		       ae 25		      .word.w	UNKNOWN
    928  26c3							;============================================================
    929  26c3							; RND() is supposed to have an argument but if none
    930  26c3							; was provided, just assume a large value.
    931  26c3							;
    932  26c3							;F2A:
    933  26c3							;	  TSTB	      F2B,kRnd
    934  26c3				   ekRnd
      0  26c3					      TSTB	UNKNOWNVEC,oLeftBracket
      0  26c3					      db	101
      1  26c3		       65		      .byte.b	101
      0  26c4					      db	(UNKNOWNVEC-*)-1
      1  26c4		       6d		      .byte.b	(UNKNOWNVEC-*)-1
      0  26c5					      db	oLeftBracket
      1  26c5		       e0		      .byte.b	oLeftBracket
      0  26c6					      TSTB	F2A1,oRightBracket
      0  26c6					      db	101
      1  26c6		       65		      .byte.b	101
      0  26c7					      db	(F2A1-*)-1
      1  26c7		       06		      .byte.b	(F2A1-*)-1
      0  26c8					      db	oRightBracket
      1  26c8		       e1		      .byte.b	oRightBracket
      0  26c9					      LIT	32766
      0  26c9					      db	27
      1  26c9		       1b		      .byte.b	27
      0  26ca					      dw	32766
      1  26ca		       fe 7f		      .word.w	32766
      0  26cc					      RANDOM
      0  26cc					      db	37
      1  26cc		       25		      .byte.b	37
      0  26cd					      RTN
      0  26cd					      db	25
      1  26cd		       19		      .byte.b	25
    940  26ce
    941  26ce				   F2A1
      0  26ce					      CALL	EXPR	;GET RANGE
      0  26ce					      db	28
      1  26ce		       1c		      .byte.b	28
      0  26cf					      dw	EXPR
      1  26cf		       b2 25		      .word.w	EXPR
      0  26d1					      TSTB	UNKNOWNVEC,oRightBracket
      0  26d1					      db	101
      1  26d1		       65		      .byte.b	101
      0  26d2					      db	(UNKNOWNVEC-*)-1
      1  26d2		       5f		      .byte.b	(UNKNOWNVEC-*)-1
      0  26d3					      db	oRightBracket
      1  26d3		       e1		      .byte.b	oRightBracket
      0  26d4					      RANDOM
      0  26d4					      db	37
      1  26d4		       25		      .byte.b	37
      0  26d5					      RTN
      0  26d5					      db	25
      1  26d5		       19		      .byte.b	25
    946  26d6							;==========================================================
    947  26d6							;	Return absolute value of expresion
    948  26d6							;
    949  26d6							;F2B:
    950  26d6							;	  TSTB	      F2B2,kAbs
    951  26d6				   ekAbs
      0  26d6					      TSTB	UNKNOWNVEC,oLeftBracket
      0  26d6					      db	101
      1  26d6		       65		      .byte.b	101
      0  26d7					      db	(UNKNOWNVEC-*)-1
      1  26d7		       5a		      .byte.b	(UNKNOWNVEC-*)-1
      0  26d8					      db	oLeftBracket
      1  26d8		       e0		      .byte.b	oLeftBracket
      0  26d9					      CALL	EXPR	;get value
      0  26d9					      db	28
      1  26d9		       1c		      .byte.b	28
      0  26da					      dw	EXPR
      1  26da		       b2 25		      .word.w	EXPR
      0  26dc					      TSTB	UNKNOWNVEC,oRightBracket
      0  26dc					      db	101
      1  26dc		       65		      .byte.b	101
      0  26dd					      db	(UNKNOWNVEC-*)-1
      1  26dd		       54		      .byte.b	(UNKNOWNVEC-*)-1
      0  26de					      db	oRightBracket
      1  26de		       e1		      .byte.b	oRightBracket
      0  26df					      ABS
      0  26df					      db	38
      1  26df		       26		      .byte.b	38
      0  26e0					      RTN
      0  26e0					      db	25
      1  26e0		       19		      .byte.b	25
    957  26e1							;============================================================
    958  26e1							;     Return the the status of a task, provide the PID
    959  26e1							;
    960  26e1							;F2B2:
    961  26e1							;	  TSTB	      F2Z,kStat
    962  26e1				   ekStat
      0  26e1					      TSTB	UNKNOWNVEC,oLeftBracket
      0  26e1					      db	101
      1  26e1		       65		      .byte.b	101
      0  26e2					      db	(UNKNOWNVEC-*)-1
      1  26e2		       4f		      .byte.b	(UNKNOWNVEC-*)-1
      0  26e3					      db	oLeftBracket
      1  26e3		       e0		      .byte.b	oLeftBracket
      0  26e4					      Call	EXPR
      0  26e4					      db	28
      1  26e4		       1c		      .byte.b	28
      0  26e5					      dw	EXPR
      1  26e5		       b2 25		      .word.w	EXPR
      0  26e7					      TSTB	UNKNOWNVEC,oRightBracket
      0  26e7					      db	101
      1  26e7		       65		      .byte.b	101
      0  26e8					      db	(UNKNOWNVEC-*)-1
      1  26e8		       49		      .byte.b	(UNKNOWNVEC-*)-1
      0  26e9					      db	oRightBracket
      1  26e9		       e1		      .byte.b	oRightBracket
      0  26ea					      TASKSTAT
      0  26ea					      db	66
      1  26ea		       42		      .byte.b	66
      0  26eb					      RTN
      0  26eb					      db	25
      1  26eb		       19		      .byte.b	25
    968  26ec							;==============================================================
    969  26ec							; Return the current tasks pid
    970  26ec							;
    971  26ec							;F2Z:
    972  26ec							;	  TSTB	      F2ZA,kPid
    973  26ec				   ekPid
      0  26ec					      TASKPID
      0  26ec					      db	77
      1  26ec		       4d		      .byte.b	77
      0  26ed					      RTN
      0  26ed					      db	25
      1  26ed		       19		      .byte.b	25
    976  26ee							;===========================================================================
    977  26ee							; Call a machine function, provide the address to call and optionally
    978  26ee							; the value to be passed in reg A
    979  26ee							;F2ZA:
    980  26ee							;	  TSTB	       F2FUNC,kCall		       ;call machine function
    981  26ee				   ekCall
      0  26ee					      TSTB	UNKNOWNVEC,oLeftBracket
      0  26ee					      db	101
      1  26ee		       65		      .byte.b	101
      0  26ef					      db	(UNKNOWNVEC-*)-1
      1  26ef		       42		      .byte.b	(UNKNOWNVEC-*)-1
      0  26f0					      db	oLeftBracket
      1  26f0		       e0		      .byte.b	oLeftBracket
      0  26f1					      CALL	EXPR
      0  26f1					      db	28
      1  26f1		       1c		      .byte.b	28
      0  26f2					      dw	EXPR
      1  26f2		       b2 25		      .word.w	EXPR
      0  26f4					      TSTB	F2B2A,oComma
      0  26f4					      db	101
      1  26f4		       65		      .byte.b	101
      0  26f5					      db	(F2B2A-*)-1
      1  26f5		       09		      .byte.b	(F2B2A-*)-1
      0  26f6					      db	oComma
      1  26f6		       e2		      .byte.b	oComma
      0  26f7					      CALL	EXPR
      0  26f7					      db	28
      1  26f7		       1c		      .byte.b	28
      0  26f8					      dw	EXPR
      1  26f8		       b2 25		      .word.w	EXPR
      0  26fa					      TSTB	UNKNOWNVEC,oRightBracket
      0  26fa					      db	101
      1  26fa		       65		      .byte.b	101
      0  26fb					      db	(UNKNOWNVEC-*)-1
      1  26fb		       36		      .byte.b	(UNKNOWNVEC-*)-1
      0  26fc					      db	oRightBracket
      1  26fc		       e1		      .byte.b	oRightBracket
      0  26fd					      CALLFUNC
      0  26fd					      db	53
      1  26fd		       35		      .byte.b	53
      0  26fe					      RTN
      0  26fe					      db	25
      1  26fe		       19		      .byte.b	25
    989  26ff							; Run the gosub within this function
    990  26ff				   F2B2A
      0  26ff					      TSTB	UNKNOWNID,oRightBracket
      0  26ff					      db	101
      1  26ff		       65		      .byte.b	101
      0  2700					      db	(UNKNOWNID-*)-1
      1  2700		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  2701					      db	oRightBracket
      1  2701		       e1		      .byte.b	oRightBracket
      0  2702					      LIT	0	; No parameter passed so just load zero to A
      0  2702					      db	27
      1  2702		       1b		      .byte.b	27
      0  2703					      dw	0
      1  2703		       00 00		      .word.w	0
      0  2705					      CALLFUNC
      0  2705					      db	53
      1  2705		       35		      .byte.b	53
      0  2706					      RTN
      0  2706					      db	25
      1  2706		       19		      .byte.b	25
    995  2707							;===========================================================================
    996  2707							; Same as gosub but expects a return value
    997  2707							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    998  2707							;
    999  2707							;F2FUNC  TSTB	      F2C,kGofn
   1000  2707				   ekGofn
      0  2707					      Call	GOSUBSTATEMENT
      0  2707					      db	28
      1  2707		       1c		      .byte.b	28
      0  2708					      dw	GOSUBSTATEMENT
      1  2708		       55 27		      .word.w	GOSUBSTATEMENT
      0  270a					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  270a					      db	8
      1  270a		       08		      .byte.b	8
      0  270b					      db	GOSUB_RTN_VALUE
      1  270b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  270c					      FASTXFER
      0  270c					      db	107
      1  270c		       6b		      .byte.b	107
   1004  270d
   1005  270d				   GOFNRet
      0  270d					      RTN
      0  270d					      db	25
      1  270d		       19		      .byte.b	25
   1007  270e
   1008  270e							;=================================================================================
   1009  270e							;Check for a number !
   1010  270e							;
   1011  270e							;F0:
   1012  270e				   FactNumber
      0  270e					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  270e					      db	35
      1  270e		       23		      .byte.b	35
      0  270f					      db	(FactVariable-*)-1
      1  270f		       0f		      .byte.b	(FactVariable-*)-1
      0  2710					      RTN
      0  2710					      db	25
      1  2710		       19		      .byte.b	25
   1015  2711				   F1
      0  2711					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  2711					      db	101
      1  2711		       65		      .byte.b	101
      0  2712					      db	(F2RTN-*)-1
      1  2712		       08		      .byte.b	(F2RTN-*)-1
      0  2713					      db	oLeftBracket
      1  2713		       e0		      .byte.b	oLeftBracket
      0  2714					      CALL	EXPR
      0  2714					      db	28
      1  2714		       1c		      .byte.b	28
      0  2715					      dw	EXPR
      1  2715		       b2 25		      .word.w	EXPR
      0  2717					      TST	F2,oRightBracket
      0  2717					      db	32
      1  2717		       20		      .byte.b	32
      0  2718					      db	(F2-*)-1
      1  2718		       03		      .byte.b	(F2-*)-1
      0  2719					      db	oRightBracket,0
      1  2719		       e1 00		      .byte.b	oRightBracket,0
   1019  271b				   F2RTN
      0  271b					      RTN
      0  271b					      db	25
      1  271b		       19		      .byte.b	25
   1021  271c
   1022  271c				   F2
      0  271c					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  271c					      db	13
      1  271c		       0d		      .byte.b	13
      0  271d					      dw	ERR_SYNTAX
      1  271d		       05 00		      .word.w	ERR_SYNTAX
   1024  271f							;
   1025  271f							;=============================================================================
   1026  271f							; See if this is just a simple variable
   1027  271f							;  Allow a subscript for any variable
   1028  271f							;
   1029  271f							;F2C:
   1030  271f							;
   1031  271f				   FactVariable
      0  271f					      CALL	FactVarPTR
      0  271f					      db	28
      1  271f		       1c		      .byte.b	28
      0  2720					      dw	FactVarPTR
      1  2720		       26 27		      .word.w	FactVarPTR
      0  2722					      CALL	FactVariableValue
      0  2722					      db	28
      1  2722		       1c		      .byte.b	28
      0  2723					      dw	FactVariableValue
      1  2723		       53 27		      .word.w	FactVariableValue
      0  2725					      RTN
      0  2725					      db	25
      1  2725		       19		      .byte.b	25
   1035  2726
   1036  2726				   FactVarPTR
      0  2726					      SETR2	tInteger
      0  2726					      db	94
      1  2726		       5e		      .byte.b	94
      0  2727					      db	tInteger
      1  2727		       a1		      .byte.b	tInteger
      0  2728					      TSTV	F1
      0  2728					      db	33
      1  2728		       21		      .byte.b	33
      0  2729					      db	(F1-*)-1
      1  2729		       e7		      .byte.b	(F1-*)-1
   1039  272a
   1040  272a				   FactVarPtrNoTst
      0  272a					      TSTB	F2CLocalTask,oBang
      0  272a					      db	101
      1  272a		       65		      .byte.b	101
      0  272b					      db	(F2CLocalTask-*)-1
      1  272b		       04		      .byte.b	(F2CLocalTask-*)-1
      0  272c					      db	oBang
      1  272c		       e8		      .byte.b	oBang
      0  272d					      IND		; we just got a pid
      0  272d					      db	20
      1  272d		       14		      .byte.b	20
      0  272e					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  272e					      db	93
      1  272e		       5d		      .byte.b	93
      0  272f					      db	(UNKNOWNID-*)-1
      1  272f		       90		      .byte.b	(UNKNOWNID-*)-1
   1044  2730
   1045  2730				   F2CLocalTask
      0  2730					      SETR2	tInteger	; Sets the default type to integer
      0  2730					      db	94
      1  2730		       5e		      .byte.b	94
      0  2731					      db	tInteger
      1  2731		       a1		      .byte.b	tInteger
      0  2732					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  2732					      db	101
      1  2732		       65		      .byte.b	101
      0  2733					      db	(F2INTEGER-*)-1
      1  2733		       11		      .byte.b	(F2INTEGER-*)-1
      0  2734					      db	oDollar
      1  2734		       e7		      .byte.b	oDollar
      0  2735					      SETR2	tByte
      0  2735					      db	94
      1  2735		       5e		      .byte.b	94
      0  2736					      db	tByte
      1  2736		       a2		      .byte.b	tByte
      0  2737					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  2737					      db	101
      1  2737		       65		      .byte.b	101
      0  2738					      db	(F2PTRLOADED-*)-1
      1  2738		       19		      .byte.b	(F2PTRLOADED-*)-1
      0  2739					      db	oLeftSQBracket
      1  2739		       e4		      .byte.b	oLeftSQBracket
      0  273a					      CALL	EXPR
      0  273a					      db	28
      1  273a		       1c		      .byte.b	28
      0  273b					      dw	EXPR
      1  273b		       b2 25		      .word.w	EXPR
      0  273d					      TSTB	UNKNOWNID,oRightSQBracket
      0  273d					      db	101
      1  273d		       65		      .byte.b	101
      0  273e					      db	(UNKNOWNID-*)-1
      1  273e		       81		      .byte.b	(UNKNOWNID-*)-1
      0  273f					      db	oRightSQBracket
      1  273f		       e5		      .byte.b	oRightSQBracket
      0  2740					      SUBSCRIPT	tByte	; Byte type array
      0  2740					      db	64
      1  2740		       40		      .byte.b	64
      0  2741					      db	tByte
      1  2741		       a2		      .byte.b	tByte
      0  2742					      SETR2	tByte	; Set byte data type
      0  2742					      db	94
      1  2742		       5e		      .byte.b	94
      0  2743					      db	tByte
      1  2743		       a2		      .byte.b	tByte
      0  2744					      RTN
      0  2744					      db	25
      1  2744		       19		      .byte.b	25
   1055  2745
   1056  2745				   F2INTEGER
      0  2745					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  2745					      db	101
      1  2745		       65		      .byte.b	101
      0  2746					      db	(F2PTRLOADED-*)-1
      1  2746		       0b		      .byte.b	(F2PTRLOADED-*)-1
      0  2747					      db	oLeftSQBracket
      1  2747		       e4		      .byte.b	oLeftSQBracket
      0  2748					      CALL	EXPR
      0  2748					      db	28
      1  2748		       1c		      .byte.b	28
      0  2749					      dw	EXPR
      1  2749		       b2 25		      .word.w	EXPR
      0  274b					      TSTB	UNKNOWNID,oRightSQBracket
      0  274b					      db	101
      1  274b		       65		      .byte.b	101
      0  274c					      db	(UNKNOWNID-*)-1
      1  274c		       73		      .byte.b	(UNKNOWNID-*)-1
      0  274d					      db	oRightSQBracket
      1  274d		       e5		      .byte.b	oRightSQBracket
      0  274e					      SUBSCRIPT	tInteger	; Integer type array
      0  274e					      db	64
      1  274e		       40		      .byte.b	64
      0  274f					      db	tInteger
      1  274f		       a1		      .byte.b	tInteger
      0  2750					      SETR2	tInteger	; Set word datatype
      0  2750					      db	94
      1  2750		       5e		      .byte.b	94
      0  2751					      db	tInteger
      1  2751		       a1		      .byte.b	tInteger
   1062  2752				   F2PTRLOADED
      0  2752					      RTN
      0  2752					      db	25
      1  2752		       19		      .byte.b	25
   1064  2753
   1065  2753				   FactVariableValue
      0  2753					      IND		; YES, GET THE VALUE as word
      0  2753					      db	20
      1  2753		       14		      .byte.b	20
      0  2754					      RTN
      0  2754					      db	25
      1  2754		       19		      .byte.b	25
   1068  2755
   1069  2755							;=============================================================
   1070  2755							; Gosub can be both a Function and a Subroutine
   1071  2755				   GOSUBSTATEMENT
      0  2755					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  2755					      db	106
      1  2755		       6a		      .byte.b	106
      0  2756					      db	(GOSUBCOMPILED-*)-1
      1  2756		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  2757					      CALL	EXPR	; GET DESTINATION
      0  2757					      db	28
      1  2757		       1c		      .byte.b	28
      0  2758					      dw	EXPR
      1  2758		       b2 25		      .word.w	EXPR
      0  275a					      CALL	GOSUBCONT
      0  275a					      db	28
      1  275a		       1c		      .byte.b	28
      0  275b					      dw	GOSUBCONT
      1  275b		       68 27		      .word.w	GOSUBCONT
      0  275d					      lit	0	; mark as lookup on stack
      0  275d					      db	27
      1  275d		       1b		      .byte.b	27
      0  275e					      dw	0
      1  275e		       00 00		      .word.w	0
      0  2760					      RTN
      0  2760					      db	25
      1  2760		       19		      .byte.b	25
   1077  2761
   1078  2761				   GOSUBCOMPILED
      0  2761					      CALL	GOSUBCONT
      0  2761					      db	28
      1  2761		       1c		      .byte.b	28
      0  2762					      dw	GOSUBCONT
      1  2762		       68 27		      .word.w	GOSUBCONT
      0  2764					      lit	1	;mark as compiled on stack
      0  2764					      db	27
      1  2764		       1b		      .byte.b	27
      0  2765					      dw	1
      1  2765		       01 00		      .word.w	1
      0  2767					      RTN
      0  2767					      db	25
      1  2767		       19		      .byte.b	25
   1082  2768
   1083  2768				   GOSUBCONT
      0  2768					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  2768					      db	101
      1  2768		       65		      .byte.b	101
      0  2769					      db	(GOSUBDONE-*)-1
      1  2769		       11		      .byte.b	(GOSUBDONE-*)-1
      0  276a					      db	oLeftBracket
      1  276a		       e0		      .byte.b	oLeftBracket
      0  276b					      STK2TMP		;Transfer stack top to temp
      0  276b					      db	95
      1  276b		       5f		      .byte.b	95
      0  276c					      PUSHMATHSTACK		;Record stack frame for return
      0  276c					      db	84
      1  276c		       54		      .byte.b	84
   1087  276d				   GOSUBLOOP
      0  276d					      CALL	EXPR	; Allows what ever fits onto stack
      0  276d					      db	28
      1  276d		       1c		      .byte.b	28
      0  276e					      dw	EXPR
      1  276e		       b2 25		      .word.w	EXPR
      0  2770					      INCPARMCOUNT
      0  2770					      db	88
      1  2770		       58		      .byte.b	88
      0  2771					      TSTB	GOSUBParmDONE,oComma
      0  2771					      db	101
      1  2771		       65		      .byte.b	101
      0  2772					      db	(GOSUBParmDONE-*)-1
      1  2772		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  2773					      db	oComma
      1  2773		       e2		      .byte.b	oComma
      0  2774					      IJMP	GOSUBLOOP
      0  2774					      db	29
      1  2774		       1d		      .byte.b	29
      0  2775					      dw	GOSUBLOOP
      1  2775		       6d 27		      .word.w	GOSUBLOOP
   1092  2777				   GOSUBParmDONE
      0  2777					      TSTB	F2,oRightBracket
      0  2777					      db	101
      1  2777		       65		      .byte.b	101
      0  2778					      db	(F2-*)-1
      1  2778		       a3		      .byte.b	(F2-*)-1
      0  2779					      db	oRightBracket
      1  2779		       e1		      .byte.b	oRightBracket
      0  277a					      TMP2STK		; Restore line to goto
      0  277a					      db	96
      1  277a		       60		      .byte.b	96
   1095  277b				   GOSUBDONE
      0  277b					      RTN
      0  277b					      db	25
      1  277b		       19		      .byte.b	25
   1097  277c
   1098  277c		       27 7c	   ILEND      equ	*
------- FILE mytb.asm
   2446  277c		       27 7c	   PROGEND    equ	*
   2447  277c
   2448  277c
   2449  277c							;=====================================================
   2450  277c							; Define start of non page zero data
   2451 U27be					      seg.u	TBData
   2452 U27be
   2453 U27be							;=====================================================
   2454 U27be							; These are storage items not in page zero.
   2455 U27be							;
   2456 U27be							; IRQ BASIC Code Service RTN Support
      0 U27be				   SaveIrqReg db	0	; Store current setting
      1 U27be		       00		      .byte.b	0
      0 U27bf				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U27bf		       00		      .byte.b	0
      0 U27c0				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U27c0		       00		      .byte.b	0
      0 U27c1				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U27c1		       00 00		      .byte.b	0,0
   2461 U27c3
   2462 U27c3							;
   2463 U27c3							;==================================================================================================
   2464 U27c3							; Task Management information
   2465 U27c3							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2466 U27c3							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2467 U27c3							; Task switchs happen at the beginning of the next Basic command line
   2468 U27c3							; It will not happen during an input or output operations
   2469 U27c3							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2470 U27c3							; Task Zero is always the root task, main line program
   2471 U27c3							;
   2472 U27c3							; Layout is repeated for each configured task
   2473 U27c3							; Task Table Byte   use masks follow
   2474 U27c3		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2475 U27c3		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2476 U27c3		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2477 U27c3		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2478 U27c3		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2479 U27c3
   2480 U27c3		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2481 U27c4		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2482 U27c4		       28 be	   TASKTABLEEND equ	*	; End of task table
   2483 U27c4		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2484 U28be
   2485 U28be							;Task Cycle Counter and reset count
   2486 U28be		       00 00	   taskCurrentCycles ds	2
   2487 U28c0		       00 00	   taskResetValue ds	2
   2488 U28c2		       00	   taskCounter ds	1	; Count of active tasks
   2489 U28c3
   2490 U28c3							;
   2491 U28c3							; Math stack and IL call and Gosub/For-next return stack definitions
   2492 U28c3							;
   2493 U28c3		       28 c3	   STACKSTART equ	*
   2494 U28c3		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2495 U2a53		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2496 U2be3		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2497 U2e63		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code
   2498 U2e63		       00 34	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2499 U2e63		       30 7f	   STACKEND   equ	*
   2500 U2e63		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2501 U307f							;
   2502 U307f							;
   2503 U307f		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2504 U3103		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2505 U3104		       00	   printtx    ds	1	;temp X for print funcs
   2506 U3105		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2507 U3106		       00	   promptChar ds	1	;the character to use for a prompt
   2508 U3107		       00	   diddigit   ds	1	;for leading zero suppression
   2509 U3108		       00	   putsy      ds	1
   2510 U3109		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2511 U310b		       00	   sign       ds	1	;0 = positive, else negative
   2512 U310c		       00 00	   rtemp1     ds	2	;Temp for x and y
   2513 U310e		       00 00	   random     ds	2
   2514 U3110		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2515 U3112		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2516 U3114		       00	   tempy      ds	1	;temp y storage
   2517 U3115
   2518 U3115
   2519 U3115							; Moved from page zero as one clock cycle diff gives more space on page zero
   2520 U3115		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2521 U3117		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2522 U3118		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2523 U3119		       00	   lineLength ds	1	;Length of current line
   2524 U311a
   2525 U311a		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2526 U311b		       00	   taskRDPending ds	1	; 1 = background read is pending
   2527 U311c
   2528 U311c				  -	      if	XKIM
   2529 U311c				  -buffer     ds	BUFFER_SIZE
   2530 U311c					      endif
   2531 U311c							;
   2532 U311c							; PROGRAMEND is the end of the user's BASIC program.
   2533 U311c							; More precisely, it is one byte past the end.  Or,
   2534 U311c							; it's where the next line added to the end will be
   2535 U311c							; placed.
   2536 U311c							;
   2537 U311c		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2538 U311e		       00 00	   ProgramEnd ds	2	; End of users basic program
   2539 U3120		       00 00	   HighMem    ds	2	; highest location
   2540 U3122		       00 00	   UsedMem    ds	2	; size of user program
   2541 U3124		       00 00	   FreeMem    ds	2	; amount of free memory
   2542 U3126							;
   2543 U3126							;=====================================================
   2544 U3126							; This is the start of the user's BASIC program space.
   2545 U3126							;
   2546 U3126							; PERSONAL GOAL: This should be no larger than $0DFF.
   2547 U3126							;		  0200-05FF = 1K
   2548 U3126							;		  0200-09FF = 2K
   2549 U3126							;		  0200-0DFF = 3K
   2550 U3126							;		  0200-11FF = 4K
   2551 U3126							;		  0200-13FF = 4.5K
   2552 U3126							;
   2553 U3126				  -	      if	FIXED
   2554 U3126				  -	      org	$2000
   2555 U3126					      endif
   2556 U3126
   2557 U3126		       31 26	   FreeMemStart equ	*
   2558 U3126							;/*
   2559 U3126							;  if	  CTMON65 || XKIM
   2560 U3126							;	  SEG Code
   2561 U3126							;	  org	  AutoRun
   2562 U3126							;	  dw	  TBasicCold
   2563 U3126							;  endif
   2564 U3126							;*/
   2565 U3126					      end
