------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2747				   input      processor	6502
      2 U2747 ????						;=====================================================
      3 U2747 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2747 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2747 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2747 ????						;
      7 U2747 ????						; While working on the Corsham Technologies KIM Clone
      8 U2747 ????						; project, I wanted to include a TINY BASIC since that
      9 U2747 ????						; was a highly desirable feature of early computers.
     10 U2747 ????						;
     11 U2747 ????						; Rather than negotiating copyright issues for
     12 U2747 ????						; existing BASICs, I decided to just write one from
     13 U2747 ????						; scratch.
     14 U2747 ????						;
     15 U2747 ????						; 10/07/2017
     16 U2747 ????						;
     17 U2747 ????						; This implements a stripped down Tiny BASIC
     18 U2747 ????						; interpreter using the Interpretive Language (IL)
     19 U2747 ????						; method as described in the first few issues of
     20 U2747 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2747 ????						; to write various languages simply by changing the
     22 U2747 ????						; IL code rather than the interpreter itself.
     23 U2747 ????						;
     24 U2747 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2747 ????						;		* Fixed major bug in findLine that
     26 U2747 ????						;		  caused corrupted lines, crashes, etc.
     27 U2747 ????						;		* If no parameter given to RND, assume
     28 U2747 ????						;		  32766.
     29 U2747 ????						;		* No more error 5 when a program
     30 U2747 ????						;		  reaches the end without an END.
     31 U2747 ????						;
     32 U2747 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2747 ????						;		 * Unexpanded version to play with everything
     34 U2747 ????						;		 * Add some usefull system level functions
     35 U2747 ????						;		 * allow a larger number of tiny basic formats
     36 U2747 ????						;		 * Add byte at start of line holding length
     37 U2747 ????						;		   for faster execution of goto and gosub
     38 U2747 ????						;		 * Re-added gosub
     39 U2747 ????						;		 * allow ; or , at end if print stmt
     40 U2747 ????						;		   without CRLF being added.
     41 U2747 ????						;		 * Added extended function erase to
     42 U2747 ????						;		   use the extended ctmon65 rm file
     43 U2747 ????						;		 * Fix quoted text to not have to backtrack
     44 U2747 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2747 ????						;		 * Add concurrency features
     46 U2747 ????						;
     47 U2747 ????						; www.corshamtech.com
     48 U2747 ????						; bob@corshamtech.com
     49 U2747 ????						; JustLostInTime@gmail.com
     50 U2747 ????						;
     51 U2747 ????						;=====================================================
     52 U2747 ????						;
     53 U2747 ????						; Create TRUE and FALSE values for conditionals.
     54 U2747 ????						;
     55 U2747 ????
     56 U2747 ????	       00 00	   FALSE      equ	0
     57 U2747 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2747 ????						;
     59 U2747 ????						;---------------------------------------------------------
     60 U2747 ????						; One of these must be set to indicate which environment
     61 U2747 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2747 ????						; environments:
     63 U2747 ????						;
     64 U2747 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2747 ????						; more K of RAM.
     66 U2747 ????						;
     67 U2747 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2747 ????						; which enhances, without replacing, the standard KIM
     69 U2747 ????						; monitor.  It gives access to routines to save/load files
     70 U2747 ????						; to a micro SD card.
     71 U2747 ????						;
     72 U2747 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2747 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2747 ????						; easily be ported to other systems.  It has support for
     75 U2747 ????						; using a micro SD card for file storage/retrieval.
     76 U2747 ????						;
     77 U2747 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2747 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2747 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2747 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2747 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2747 ????						;
     83 U2747 ????						;   Need to define some macros for the dasm assembler
     84 U2747 ????						;
     85 U2747 ????				      MACRO	dw
     86 U2747 ????				      .word	{0}
     87 U2747 ????				      ENDM
     88 U2747 ????
     89 U2747 ????				      MACRO	db
     90 U2747 ????				      .byte	{0}
     91 U2747 ????				      ENDM
     92 U2747 ????
     93 U2747 ????						;
     94 U2747 ????						; If set, include disk functions.
     95 U2747 ????						;
     96 U2747 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2747 ????						;
     98 U2747 ????						; If ILTRACE is set then dump out the address of every
     99 U2747 ????						; IL opcode before executing it.
    100 U2747 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2747 ????						;
    102 U2747 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2747 ????						;
    104 U2747 ????						; If FIXED is set, put the IL code and the user
    105 U2747 ????						; program space at fixed locations in memory.	This is
    106 U2747 ????						; meant only for debugging.
    107 U2747 ????						;
    108 U2747 ????	       00 00	   FIXED      equ	FALSE
    109 U2747 ????						;
    110 U2747 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2747 ????						; BASIC, so keep this small!
    112 U2747 ????						;
    113 U2747 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2747 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2747 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2747 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2747 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2747 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2747 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2747 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2747 ????						;
    122 U2747 ????						; Gosub entry types
    123 U2747 ????
    124 U2747 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2747 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2747 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2747 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2747 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2747 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2747 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2747 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2747 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2747 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2747 ????						;
    135 U2747 ????						; Common ASCII constants
    136 U2747 ????						;
    137 U2747 ????	       00 07	   BEL	      equ	$07
    138 U2747 ????	       00 08	   BS	      equ	$08
    139 U2747 ????	       00 09	   TAB	      equ	$09
    140 U2747 ????	       00 0a	   LF	      equ	$0A
    141 U2747 ????	       00 0d	   CR	      equ	$0D
    142 U2747 ????	       00 22	   quote      equ	$22
    143 U2747 ????	       00 20	   SPACE      equ	$20
    144 U2747 ????	       00 2c	   COMMA      equ	',
    145 U2747 ????	       00 3b	   SEMICOLON  equ	';
    146 U2747 ????	       00 3a	   COLON      equ	':
    147 U2747 ????	       00 24	   DOLLAR     equ	'$
    148 U2747 ????						;
    149 U2747 ????						; These are error codes
    150 U2747 ????						;
    151 U2747 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2747 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2747 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2747 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2747 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2747 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2747 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2747 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2747 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2747 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2747 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2747 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2747 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2747 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2747 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2747 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2747 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2747 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2747 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2747 ????						;
    171 U2747 ????						;=====================================================
    172 U2747 ????						; Zero page storage.
    173 U2747 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  1dcf ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       15 ab	   CRLF       equ	tbcrlf
    307  0206		       0d 99	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       16 fa	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 da 16    cold2      jsr	SetOutConsole
    314  0209		       20 e7 16 	      jsr	SetInConsole
    315  020c		       20 fa 16 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    319  023c							;
    320  023c		       20 b6 0d 	      jsr	MemInit	;setup the free space available
    321  023f
    322  023f		       a9 01	   calcstack  lda	#1
    323  0241		       8d e3 1e 	      sta	taskCounter	; Initialize number of tasks to 1
    324  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  0246		       8d e5 1d 	      sta	taskTable	; mark the main task as active
    326  0249		       20 a3 0e 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  024c		       a9 04		      lda	#IL&$ff
    328  024e		       85 43		      sta	ILPC
    329  0250		       a9 19		      lda	#IL>>8
    330  0252		       85 44		      sta	ILPC+1
    331  0254							;
    332  0254							;		  lda	  ProgramStart		     ; user prog
    333  0254							;		  sta	  ProgramEnd
    334  0254							;		  lda	  ProgramStart+1
    335  0254							;		  sta	  ProgramEnd+1
    336  0254							;
    337  0254							;  Init time slices defaults
    338  0254		       a9 02		      lda	#TASKCYCLESHIGH
    339  0256		       8d e2 1e 	      sta	taskResetValue+1
    340  0259		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  025b		       8d e1 1e 	      sta	taskResetValue
    342  025e							;
    343  025e							; Initialize the pseudo-random number sequence...
    344  025e							;
    345  025e		       a9 5a		      lda	#$5a
    346  0260		       8d 2d 27 	      sta	rtemp1
    347  0263		       a9 9d		      lda	#%10011101
    348  0265		       8d 2f 27 	      sta	random
    349  0268		       a9 5b		      lda	#%01011011
    350  026a		       8d 30 27 	      sta	random+1
    351  026d							;
    352  026d							;   Insert a Basic irq handler for the basic Language
    353  026d		       a9 7a		      lda	#ServiceIrq&$ff
    354  026f		       8d 00 df 	      sta	IRQvec
    355  0272		       a9 02		      lda	#ServiceIrq>>8
    356  0274		       8d 01 df 	      sta	IRQvec+1
    357  0277		       4c 9f 02 	      jmp	coldtwo
    358  027a
    359  027a							;
    360  027a							; This is the Basic IRQ handler
    361  027a		       48	   ServiceIrq pha
    362  027b		       ad e0 1d 	      lda	IRQStatus
    363  027e		       f0 0a		      BEQ	RetIrq
    364  0280		       ad e1 1d 	      lda	IRQPending
    365  0283		       d0 05		      bne	RetIrq
    366  0285		       a9 01		      lda	#1
    367  0287		       8d e1 1d 	      sta	IRQPending
    368  028a		       68	   RetIrq     pla
    369  028b		       40		      rti
    370  028c							;
    371  028c							;
    372  028c							; This is the warm start entry point
    373  028c							;
    374  028c		       20 da 16    warm2      jsr	SetOutConsole
    375  028f		       20 e7 16 	      jsr	SetInConsole
    376  0292		       20 ab 15 	      jsr	CRLF
    377  0295		       ad 2a 27 	      lda	errGoto
    378  0298		       85 43		      sta	ILPC
    379  029a		       ad 2b 27 	      lda	errGoto+1
    380  029d		       85 44		      sta	ILPC+1
    381  029f							;
    382  029f							; And continue with both starts here
    383  029f							;
    384  029f				   coldtwo
    385  029f							;
    386  029f							; The ILTrace flag is now run-time settable.
    387  029f							;
    388  029f		       a9 00		      lda	#ILTRACE&$ff
    389  02a1		       85 40		      sta	ILTrace
    390  02a3							;
    391  02a3
    392  02a3		       a9 00		      lda	#0
    393  02a5		       85 5b		      sta	RunMode
    394  02a7		       8d a0 26 	      sta	LINBUF
    395  02aa
    396  02aa							; Clear everything from the stacks
    397  02aa
    398  02aa		       8d 3b 27 	      sta	taskIOPending	; No one waiting for io
    399  02ad		       8d 3c 27 	      sta	taskRDPending	; No one waiting for bg io
    400  02b0
    401  02b0		       20 16 0f 	      jsr	taskReset
    402  02b3							;
    403  02b3		       a9 a0		      lda	#LINBUF&$ff
    404  02b5		       85 4f		      sta	CURPTR
    405  02b7		       a9 26		      lda	#LINBUF>>8
    406  02b9		       85 50		      sta	CURPTR+1	;fall through...
    407  02bb
    408  02bb							;=====================================================
    409  02bb							; This is the top of the IL interpreter.  This fetches
    410  02bb							; and executes the instruction currently pointed to
    411  02bb							; by ILPC and adjusts ILPC to point to the next
    412  02bb							; instruction to execute.
    413  02bb							;
    414  02bb		       ce df 1e    NextIL     dec	taskCurrentCycles
    415  02be		       d0 03		      bne	NextIlNow
    416  02c0		       20 3f 0f 	      jsr	iTaskSwitch	;check for a task switch
    417  02c3		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02c5		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02c7
    420  02c7		       20 37 16 	      jsr	dbgLine	;Print the IL trace information
    421  02ca
    422  02ca		       a4 51	   NextIL2    ldy	CUROFF
    423  02cc		       20 a2 15 	      jsr	SkipSpaces
    424  02cf		       84 51		      sty	CUROFF
    425  02d1							;Task IO Management
    426  02d1		       ad 3c 27 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d4		       f0 08		      beq	NextILStr
    428  02d6		       20 f2 13 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02d9		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02db		       ce 3c 27 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02de							;
    432  02de		       20 75 12    NextILStr  jsr	getILByte
    433  02e1							;
    434  02e1							; When the handler is called, these are the conditions
    435  02e1							; of several important items:
    436  02e1							;
    437  02e1							;    (ILPC) will point to the byte AFTER the IL
    438  02e1							;    opcode being executed.
    439  02e1							;
    440  02e1							;    (CURPTR),CUROFF will point to the start of the
    441  02e1							;    next word in the input buffer.  Ie, the next word
    442  02e1							;    in the user program.
    443  02e1							;
    444  02e1		       0a		      asl
    445  02e2		       c9 cc		      cmp	#ILTBLend-ILTBL+2
    446  02e4		       90 33		      bcc	ILgood
    447  02e6							;
    448  02e6							; This handles an illegal IL opcode.  This is serious
    449  02e6							; and there's no way to recover.
    450  02e6							;
    451  02e6		       20 fa 16    ILbad      jsr	puts
      0  02e9					      db	CR,LF
      1  02e9		       0d 0a		      .byte.b	CR,LF
      0  02eb					      db	"Illegal IL "
      1  02eb		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f6					      db	0
      1  02f6		       00		      .byte.b	0
    455  02f7							;
    456  02f7							; Well this is awkward, we need to back up the IL
    457  02f7							; by one since it no longer points to the current
    458  02f7							; opcode.
    459  02f7							;
    460  02f7		       20 82 12 	      jsr	decIL
    461  02fa							;
    462  02fa		       a0 00		      ldy	#0
    463  02fc		       b1 43		      lda	(ILPC),y
    464  02fe		       20 99 0d 	      jsr	OUTHEX
    465  0301		       20 fa 16 	      jsr	puts
      0  0304					      db	" at ",0
      1  0304		       20 61 74 20*	      .byte.b	" at ",0
    467  0309		       a5 44		      lda	ILPC+1
    468  030b		       20 99 0d 	      jsr	OUTHEX
    469  030e		       a5 43		      lda	ILPC
    470  0310		       20 99 0d 	      jsr	OUTHEX
    471  0313		       20 ab 15 	      jsr	CRLF
    472  0316		       4c 03 f0 	      jmp	MONITOR
    473  0319							;
    474  0319							; Just jump to the address (ILPC),y.  Have to do
    475  0319							; some goofy stuff.
    476  0319							;
    477  0319		       a8	   ILgood     tay		;move index into Y
    478  031a		       b9 27 03 	      lda	ILTBL,y
    479  031d		       85 59		      sta	dpl
    480  031f		       b9 28 03 	      lda	ILTBL+1,y
    481  0322		       85 5a		      sta	dpl+1
    482  0324		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0327							;
    484  0327							;=====================================================
    485  0327							; This is the IL jump table.  The IL opcode is
    486  0327							; mulitplied by two, then looked-up in this table.
    487  0327							; There is absolutely nothing special about the order
    488  0327							; of entries here... they all decode at exactly the
    489  0327							; same speed.	However the entry number must match the
    490  0327							; values in IL.inc.
    491  0327							;
    492  0327				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0327					      include	"ilvectortable.asm"
      1  0327					      seg	Code
      2  0327
      0  0327					      dw	iXINIT	;0
      1  0327		       29 04		      .word.w	iXINIT
      0  0329					      dw	iDONE	;1
      1  0329		       44 04		      .word.w	iDONE
      0  032b					      dw	iPRS	;2
      1  032b		       60 04		      .word.w	iPRS
      0  032d					      dw	iPRN	;3
      1  032d		       6a 04		      .word.w	iPRN
      0  032f					      dw	iSPC	;4
      1  032f		       73 04		      .word.w	iSPC
      0  0331					      dw	iNLINE	;5
      1  0331		       1c 09		      .word.w	iNLINE
      0  0333					      dw	iNXT	;6
      1  0333		       7b 04		      .word.w	iNXT
      0  0335					      dw	iXFER	;7
      1  0335		       a7 04		      .word.w	iXFER
      0  0337					      dw	iSAV	;8
      1  0337		       d4 04		      .word.w	iSAV
      0  0339					      dw	iRSTR	;9
      1  0339		       17 05		      .word.w	iRSTR
      0  033b					      dw	iCMPR	;10
      1  033b		       4c 05		      .word.w	iCMPR
      0  033d					      dw	iINNUM	;11
      1  033d		       cd 05		      .word.w	iINNUM
      0  033f					      dw	iFIN	;12
      1  033f		       01 06		      .word.w	iFIN
      0  0341					      dw	iERR	;13
      1  0341		       15 06		      .word.w	iERR
      0  0343					      dw	iADD	;14
      1  0343		       85 06		      .word.w	iADD
      0  0345					      dw	iSUB	;15
      1  0345		       9b 06		      .word.w	iSUB
      0  0347					      dw	iNEG	;16
      1  0347		       b1 06		      .word.w	iNEG
      0  0349					      dw	iMUL	;17
      1  0349		       c9 06		      .word.w	iMUL
      0  034b					      dw	iDIV	;18
      1  034b		       09 07		      .word.w	iDIV
      0  034d					      dw	iSTORE	;19
      1  034d		       5f 07		      .word.w	iSTORE
      0  034f					      dw	iIND	;20
      1  034f		       77 07		      .word.w	iIND
      0  0351					      dw	iLST	;21
      1  0351		       e5 07		      .word.w	iLST
      0  0353					      dw	iINIT	;22
      1  0353		       f1 03		      .word.w	iINIT
      0  0355					      dw	iGETLINE	;23
      1  0355		       4a 08		      .word.w	iGETLINE
      0  0357					      dw	iINSRT	;24
      1  0357		       58 08		      .word.w	iINSRT
      0  0359					      dw	iRTN	;25
      1  0359		       16 09		      .word.w	iRTN
      0  035b					      dw	MONITOR	;26
      1  035b		       03 f0		      .word.w	MONITOR
      0  035d					      dw	iLIT	;27
      1  035d		       3c 09		      .word.w	iLIT
      0  035f					      dw	iCALL	;28
      1  035f		       22 09		      .word.w	iCALL
      0  0361					      dw	iJMP	;29
      1  0361		       2a 09		      .word.w	iJMP
      0  0363					      dw	iVINIT	;30
      1  0363		       59 09		      .word.w	iVINIT
      0  0365					      dw	iERRGOTO	;31
      1  0365		       5f 09		      .word.w	iERRGOTO
      0  0367					      dw	iTST	;32
      1  0367		       6b 09		      .word.w	iTST
      0  0369					      dw	iTSTV	;33
      1  0369		       4c 0a		      .word.w	iTSTV
      0  036b					      dw	iTSTL	;34
      1  036b		       cb 0a		      .word.w	iTSTL
      0  036d					      dw	iTSTN	;35
      1  036d		       e6 0a		      .word.w	iTSTN
      0  036f					      dw	iFREE	;36
      1  036f		       63 0b		      .word.w	iFREE
      0  0371					      dw	iRANDOM	;37
      1  0371		       6c 0b		      .word.w	iRANDOM
      0  0373					      dw	iABS	;38
      1  0373		       3d 0c		      .word.w	iABS
     42  0375							;
     43  0375							; Disk functions.  There must be pointers
     44  0375							; to functions even if no disk is supported.
     45  0375							; Makes things easier in IL.inc.
     46  0375							;
     47  0375					      if	DISK_ACCESS
      0  0375					      dw	iOPENREAD	;39
      1  0375		       df 17		      .word.w	iOPENREAD
      0  0377					      dw	iOPENWRITE	;40
      1  0377		       33 18		      .word.w	iOPENWRITE
      0  0379					      dw	iDCLOSE	;41
      1  0379		       b7 18		      .word.w	iDCLOSE
      0  037b					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037b		       52 18		      .word.w	iDGETLINE
      0  037d					      dw	iDLIST	;43 Did you remeber your towel?
      1  037d		       b1 18		      .word.w	iDLIST
      0  037f					      dw	iDDIR	;44
      1  037f		       8c 18		      .word.w	iDDIR
      0  0381					      dw	iRMFILE	;45
      1  0381		       0d 18		      .word.w	iRMFILE
     55  0383				  -	      else
     56  0383				  -	      dw	NextIL	;39
     57  0383				  -	      dw	NextIL	;40
     58  0383				  -	      dw	NextIL	;41
     59  0383				  -	      dw	NextIL	;42
     60  0383				  -	      dw	NextIL	;43
     61  0383				  -	      dw	NextIL	;44
     62  0383				  -	      dw	NextIL	;45
     63  0383					      endif
     64  0383							;
      0  0383					      dw	iCLEARSCREEN	;46
      1  0383		       53 17		      .word.w	iCLEARSCREEN
      0  0385					      dw	iPOKEMEMORY	;47
      1  0385		       ca 0b		      .word.w	iPOKEMEMORY
      0  0387					      dw	iPEEKMEMORY	;48
      1  0387		       df 0b		      .word.w	iPEEKMEMORY
      0  0389					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0389		       b2 09		      .word.w	iTSTLET
      0  038b					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038b		       f0 09		      .word.w	iTSTDONE
      0  038d					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038d		       0c 0c		      .word.w	iGETCHAR
      0  038f					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038f		       20 0c		      .word.w	iPUTCHAR
      0  0391					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0391		       f5 0b		      .word.w	iCallFunc
      0  0393					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0393		       9d 05		      .word.w	iBranch
      0  0395					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0395		       95 09		      .word.w	iTSTStr
      0  0397					      dw	iSetIrq	;56	   sets the irq handler
      1  0397		       ba 0c		      .word.w	iSetIrq
      0  0399					      dw	iTstIrq	;57	   test if irq is pending
      1  0399		       2b 0b		      .word.w	iTstIrq
      0  039b					      dw	iRET	;58	   return from interupt
      1  039b		       05 05		      .word.w	iRET
      0  039d					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039d		       e4 05		      .word.w	iINSTR
      0  039f					      dw	iMOD	;60	   returns remainder of division
      1  039f		       12 07		      .word.w	iMOD
      0  03a1					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a1		       93 0f		      .word.w	iTaskSet
      0  03a3					      dw	iETask	;62	   Terminates a task
      1  03a3		       be 10		      .word.w	iETask
      0  03a5					      dw	iNTask	;63	   goto next task
      1  03a5		       71 10		      .word.w	iNTask
      0  03a7					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a7		       8c 07		      .word.w	iArray
      0  03a9					      dw	iTaskKill	;65	   kill a running task
      1  03a9		       69 10		      .word.w	iTaskKill
      0  03ab					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ab		       3d 10		      .word.w	iTaskStat
      0  03ad					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03ad		       2b 0c		      .word.w	iHexOut
      0  03af					      dw	iReadComplete	;68	   Called after a background read completes
      1  03af		       b9 05		      .word.w	iReadComplete
      0  03b1					      dw	iReadStart	;69	   Called to start a background read request
      1  03b1		       af 05		      .word.w	iReadStart
      0  03b3					      dw	iStartIO	;70	   Lock task until io complete
      1  03b3		       a1 10		      .word.w	iStartIO
      0  03b5					      dw	iEndIO	;71	   release task lock for io
      1  03b5		       a7 10		      .word.w	iEndIO
      0  03b7					      dw	iLogNot	;72	   Logical not
      1  03b7		       96 0c		      .word.w	iLogNot
      0  03b9					      dw	iLogOr	;73	   Logical Or
      1  03b9		       6c 0c		      .word.w	iLogOr
      0  03bb					      dw	iLogAnd	;74	   Logical And
      1  03bb		       57 0c		      .word.w	iLogAnd
      0  03bd					      dw	iLogXor	;75	   Logical Xor
      1  03bd		       81 0c		      .word.w	iLogXor
      0  03bf					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bf		       7c 10		      .word.w	iWTASK
      0  03c1					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c1		       b2 10		      .word.w	iTASKPID
      0  03c3					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c3		       f6 0c		      .word.w	iTRACEPROG
      0  03c5					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c5		       b8 15		      .word.w	idbgBasic
      0  03c7					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c7		       74 11		      .word.w	iIPCS
      0  03c9					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c9		       8b 11		      .word.w	iIPCR
      0  03cb					      dw	iIPCC	;82	   Check if any message available for task
      1  03cb		       9f 11		      .word.w	iIPCC
      0  03cd					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cd		       ac 11		      .word.w	iIPCIO
      0  03cf					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cf		       0b 0e		      .word.w	iPushMathStack
      0  03d1					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d1		       3b 0e		      .word.w	iPopMathStack
      0  03d3					      dw	iSaveMathStack	;86	   Save all math info
      1  03d3		       58 0e		      .word.w	iSaveMathStack
      0  03d5					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d5		       77 0e		      .word.w	iRestoreMathStack
      0  03d7					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d7		       28 0e		      .word.w	iIncParmCount
      0  03d9					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d9		       de 10		      .word.w	iTaskGetMathStack
      0  03db					      dw	iTaskEnable	;90	   enable a suspended task
      1  03db		       0b 10		      .word.w	iTaskEnable
      0  03dd					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03dd		       25 10		      .word.w	iTaskSuspend
      0  03df					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03df		       f8 10		      .word.w	iTaskPutMathPtr
      0  03e1					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e1		       43 0a		      .word.w	iTSTVT
      0  03e3					      dw	iSetR2	;94
      1  03e3		       34 09		      .word.w	iSetR2
      0  03e5					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e5		       e3 04		      .word.w	iStk2Tmp
      0  03e7					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e7		       f4 04		      .word.w	iTmp2Stk
      0  03e9					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e9		       d1 09		      .word.w	iTSTBYTE
      0  03eb					      dw	iINCVAR	;98	   Increment variable
      1  03eb		       15 0a		      .word.w	iINCVAR
      0  03ed					      dw	iDECVAR	;99	   Decrement variable
      1  03ed		       2d 0a		      .word.w	iDECVAR
      0  03ef					      dw	iSLICE	;100	   set the time slice for tasks
      1  03ef		       07 11		      .word.w	iSLICE
    120  03f1
------- FILE mytb.asm
    494  03f1		       03 f1	   ILTBLend   equ	*
    495  03f1							;
    496  03f1							;=====================================================
    497  03f1							;=====================================================
    498  03f1							;=====================================================
    499  03f1							; This marks the start of the handlers for IL opcodes.
    500  03f1							;=====================================================
    501  03f1							;=====================================================
    502  03f1							;=====================================================
    503  03f1							;
    504  03f1							;
    505  03f1		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03f3		       85 47		      sta	ILSTACKPTR
    507  03f5		       85 4a		      sta	MATHSTACKPTR
    508  03f7		       85 4d		      sta	GOSUBSTACKPTR
    509  03f9		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  03fb		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  03fd							;
    512  03fd		       ad 3d 27 	      lda	ProgramStart	;user prog
    513  0400		       85 4f		      sta	CURPTR
    514  0402		       8d e6 1d 	      sta	taskTable+1
    515  0405		       8d 3f 27 	      sta	ProgramEnd
    516  0408		       ad 3e 27 	      lda	ProgramStart+1
    517  040b		       85 50		      sta	CURPTR+1
    518  040d		       8d e7 1d 	      sta	taskTable+2
    519  0410		       8d 40 27 	      sta	ProgramEnd+1
    520  0413		       a9 80		      lda	#TASKACTIVE
    521  0415		       8d e5 1d 	      sta	taskTable	;Mark the first slot as active
    522  0418		       a9 01		      lda	#1
    523  041a		       8d e3 1e 	      sta	taskCounter	;there is always one task / Main task
    524  041d		       ad e1 1e 	      lda	taskResetValue
    525  0420		       8d df 1e 	      sta	taskCurrentCycles	; set up the task switch counts
    526  0423		       ad e2 1e 	      lda	taskResetValue+1
    527  0426		       8d e0 1e 	      sta	taskCurrentCycles+1
    528  0429							;
    529  0429							; fall into XINIT...
    530  0429							;
    531  0429							;=====================================================
    532  0429							; This initializes for the start of the next line of
    533  0429							; BASIC text.
    534  0429							;
    535  0429		       78	   iXINIT     sei		;ensure interupts are off
    536  042a		       20 16 0f 	      jsr	taskReset	;Clear the task table
    537  042d		       8d e1 1d 	      sta	IRQPending	; reset the irq pending
    538  0430		       8d e0 1d 	      sta	IRQStatus	; Make sure irqs are off
    539  0433
    540  0433		       4c bb 02    goodExit   jmp	NextIL
    541  0436							;
    542  0436							;=====================================================
    543  0436							; This check if the escape key has been entered
    544  0436							; then changes out of run mode. z Set if esc found
    545  0436				   BreakSet
    546  0436		       20 0f f0 	      jsr	ISCHAR
    547  0439		       f0 06		      beq	BreakNo
    548  043b		       20 f7 16 	      jsr	VGETCH
    549  043e		       c9 1b		      cmp	#$1B
    550  0440		       60		      rts
    551  0441				   BreakNo
    552  0441		       a9 01		      lda	#1
    553  0443		       60		      rts
    554  0444
    555  0444							;
    556  0444
    557  0444							;=====================================================
    558  0444							; Verify there is nothing else on this input line.
    559  0444							; If there is, generate an error.
    560  0444							;
    561  0444		       a4 51	   iDONE      ldy	CUROFF
    562  0446		       20 a2 15 	      jsr	SkipSpaces
    563  0449		       b1 4f		      lda	(CURPTR),y
    564  044b		       f0 10		      beq	doneadv
    565  044d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    566  044f		       d0 05		      bne	idoneErr
    567  0451		       84 51		      sty	CUROFF
    568  0453		       4c bb 02 	      jmp	NextIL	; continue on this line
    569  0456
    570  0456				   idoneErr
    571  0456		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  0458		       a9 00		      lda	#0
    573  045a		       4c 18 06 	      jmp	iErr2
    574  045d							;
    575  045d							; Advance to the next line
    576  045d							;
    577  045d				   doneadv
    578  045d							;		 jsr	 FindNext2
    579  045d		       4c bb 02 	      jmp	NextIL
    580  0460							;
    581  0460							;=====================================================
    582  0460							; Print the string until a closing quote
    583  0460							;
    584  0460		       a4 51	   iPRS       ldy	CUROFF
    585  0462							;
    586  0462							; Odd logic here.  The main loop skipped any leading
    587  0462							; whitespace inside the quoted text, so move back to
    588  0462							; the quote, then move forward again.
    589  0462							;
    590  0462		       20 24 17 	      jsr	PrtQuoted
    591  0465		       84 51		      sty	CUROFF
    592  0467		       4c bb 02 	      jmp	NextIL
    593  046a							;
    594  046a							;=====================================================
    595  046a							; Pop the top off the stack and print it as a signed
    596  046a							; decimal number.
    597  046a							;
    598  046a		       20 f2 14    iPRN       jsr	popR0
    599  046d		       20 00 0d 	      jsr	PrintDecimal
    600  0470		       4c bb 02 	      jmp	NextIL
    601  0473							;
    602  0473							;=====================================================
    603  0473							; Space to next zone.	Currently the code does not
    604  0473							; keep track of which column the output is on, so
    605  0473							; just print a tab.
    606  0473							;
    607  0473		       a9 09	   iSPC       lda	#TAB
    608  0475		       20 f4 16 	      jsr	VOUTCH
    609  0478		       4c bb 02 	      jmp	NextIL
    610  047b							;
    611  047b							;=====================================================
    612  047b							; If in immediate mode, jump to the address following
    613  047b							; the NXT instruction.  Else move to the next line of
    614  047b							; user code and continue.
    615  047b							;
    616  047b		       a5 5b	   iNXT       lda	RunMode
    617  047d		       d0 03		      bne	iNxtRun	;in run mode
    618  047f							;
    619  047f							; Get address and jump to it.
    620  047f							;
    621  047f		       4c 2a 09 	      jmp	iJMP
    622  0482							;
    623  0482				   iNxtRun
    624  0482		       a4 51		      ldy	CUROFF
    625  0484		       20 a2 15 	      jsr	SkipSpaces
    626  0487		       b1 4f		      lda	(CURPTR),y
    627  0489		       c9 3a		      cmp	#COLON
    628  048b		       d0 09		      bne	iNxtRunGo
    629  048d		       c8		      iny
    630  048e		       20 a2 15 	      jsr	SkipSpaces
    631  0491		       84 51		      sty	CUROFF
    632  0493		       4c a1 04 	      jmp	iNxtRun2
    633  0496
    634  0496				   iNxtRunGo
    635  0496		       20 ff 12 	      jsr	FindNextLine
    636  0499		       20 13 13 	      jsr	AtEnd
    637  049c		       d0 03		      bne	iNxtRun2	;not at end
    638  049e							;
    639  049e							; At the end of the program.  Pretend an END statement
    640  049e							; was found.
    641  049e							;
    642  049e		       4c 01 06    iFINv      jmp	iFIN
    643  04a1							;
    644  04a1		       20 71 12    iNxtRun2   jsr	getILWord	;ignore next word
    645  04a4		       4c bb 02 	      jmp	NextIL
    646  04a7							;
    647  04a7							;=====================================================
    648  04a7							; XFER takes the number on top of the stack and looks
    649  04a7							; for that line in the program, or the next line
    650  04a7							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04a7							; find the next one after that.
    652  04a7							;
    653  04a7		       20 f2 14    iXFER      jsr	popR0
    654  04aa		       20 ba 12 	      jsr	findLine
    655  04ad		       20 13 13    iXFER2     jsr	AtEnd	;at end of user program?
    656  04b0		       f0 ec		      beq	iFINv
    657  04b2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    658  04b4		       84 51		      sty	CUROFF
    659  04b6		       a9 ff		      lda	#$ff
    660  04b8		       85 5b		      sta	RunMode
    661  04ba							;
    662  04ba							; Transfer IL to STMT.  I don't like having this
    663  04ba							; hard-coded; fix it.
    664  04ba							;
    665  04ba		       a9 12		      lda	#STMT&$ff
    666  04bc		       85 43		      sta	ILPC
    667  04be		       a9 19		      lda	#STMT>>8
    668  04c0		       85 44		      sta	ILPC+1
    669  04c2		       4c bb 02 	      jmp	NextIL
    670  04c5							;
    671  04c5							; Run
    672  04c5							;
    673  04c5				   iXferok
    674  04c5		       a9 ff		      lda	#$ff
    675  04c7		       85 5b		      sta	RunMode	;we're running
    676  04c9							;
    677  04c9							; Need a more elegant way to do this
    678  04c9							;
    679  04c9		       a9 12		      lda	#STMT&$ff
    680  04cb		       85 43		      sta	ILPC
    681  04cd		       a9 19		      lda	#STMT>>8
    682  04cf		       85 44		      sta	ILPC+1
    683  04d1		       4c bb 02 	      jmp	NextIL
    684  04d4							;
    685  04d4							;=====================================================
    686  04d4							; Save the pointer to the next line to the call stack.
    687  04d4							;
    688  04d4		       20 88 14    iSAV       jsr	pushLN
    689  04d7		       b0 03		      bcs	iSAVErr
    690  04d9		       4c bb 02 	      jmp	NextIL
    691  04dc
    692  04dc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04de		       a9 00	   iSAVErr2   lda	#0
    694  04e0		       4c 18 06 	      jmp	iErr2
    695  04e3							;====================================================
    696  04e3							; Move stack top to and from temp area
    697  04e3				   iStk2Tmp
    698  04e3		       20 f2 14 	      jsr	popR0
    699  04e6		       a5 52		      lda	R0
    700  04e8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04ea		       91 41		      sta	(VARIABLES),y
    702  04ec		       c8		      iny
    703  04ed		       a5 53		      lda	R0+1
    704  04ef		       91 41		      sta	(VARIABLES),y
    705  04f1		       4c bb 02 	      jmp	NextIL
    706  04f4
    707  04f4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  04f6		       b1 41		      lda	(VARIABLES),y
    709  04f8		       85 52		      sta	R0
    710  04fa		       c8		      iny
    711  04fb		       b1 41		      lda	(VARIABLES),y
    712  04fd		       85 53		      sta	R0+1
    713  04ff		       20 6e 14 	      jsr	pushR0
    714  0502		       4c bb 02 	      jmp	NextIL
    715  0505							;
    716  0505							;=====================================================
    717  0505							; Pop the next line from the call stack.
    718  0505							;
    719  0505		       20 ad 14    iRET       jsr	popLN
    720  0508		       b0 d2		      bcs	iSAVErr
    721  050a		       a0 03		      ldy	#3
    722  050c		       84 51		      sty	CUROFF
    723  050e		       a9 00		      lda	#0
    724  0510		       8d e1 1d 	      sta	IRQPending
    725  0513		       58		      cli
    726  0514		       4c bb 02 	      jmp	NextIL
    727  0517							;
    728  0517							;=====================================================
    729  0517							; Return from GOSUB function
    730  0517							;
    731  0517		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    732  0519		       f0 0f		      beq	iRSTRNoValue
    733  051b		       a5 58		      lda	R2
    734  051d		       85 56		      sta	MQ
    735  051f		       88		      dey
    736  0520		       b1 4b		      lda	(GOSUBSTACK),y
    737  0522		       c9 81		      cmp	#GOSUB_RTN_VALUE
    738  0524		       d0 04		      bne	iRSTRNoValue
    739  0526		       a9 01		      lda	#1
    740  0528		       d0 02		      bne	iRSTRExit
    741  052a				   iRSTRNoValue
    742  052a		       a9 00		      lda	#0
    743  052c				   iRSTRExit
    744  052c		       85 58		      sta	R2
    745  052e		       20 ad 14 	      jsr	popLN
    746  0531		       b0 06		      bcs	iRSTRErr
    747  0533		       20 41 0e 	      jsr	PopMathStackNow
    748  0536		       4c bb 02 	      jmp	NextIL
    749  0539
    750  0539		       ad e4 1d    iRSTRErr   lda	taskPtr	; Check if this is task zero
    751  053c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    752  053e		       a5 56		      lda	MQ
    753  0540		       d0 03		      bne	taskRet
    754  0542		       20 68 17 	      jsr	pushFalse	; the result code by default is 0
    755  0545				   taskRet
    756  0545		       4c be 10 	      jmp	iETask	; not task zero then do a task end instead
    757  0548				   taskZeroEnd
    758  0548		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    759  054a		       d0 92		      bne	iSAVErr2
    760  054c							;
    761  054c							;=====================================================
    762  054c							; Compare items on stack.  Okay, so on input there are
    763  054c							; three things on the stack
    764  054c							;
    765  054c							;    EXPR2 <- Top of stack
    766  054c							;    OP    <- relational operator, next on stack
    767  054c							;    EXPR1 <- last item on stack
    768  054c							;
    769  054c							; Comparison is: EXPR1 <operator> EXPR2
    770  054c							;
    771  054c							; Operator is one of...
    772  054c							;
    773  054c							;    2 is =
    774  054c							;    1 is <
    775  054c							;    3 is <=
    776  054c							;    5 is <>
    777  054c							;    4 is >
    778  054c							;    6 is >=
    779  054c							;
    780  054c							; Those are bit-mapped:
    781  054c							;
    782  054c							;    xxxxxGEL
    783  054c							;
    784  054c							;    G = Greater than
    785  054c							;    E = Equal
    786  054c							;    L = Less than
    787  054c							;
    788  054c							; If the comparison is false, do a NXT, ie, move to the
    789  054c							; next line and continue.  If true, continue executing
    790  054c							; on this line.
    791  054c							;
    792  054c		       00 01	   REL_LT     equ	%001
    793  054c		       00 02	   REL_EQUAL  equ	%010
    794  054c		       00 04	   REL_GT     equ	%100
    795  054c							;
    796  054c		       20 0a 15    iCMPR      jsr	popR1
    797  054f		       20 21 15 	      jsr	popMQ	;operator in MQ
    798  0552		       20 f2 14 	      jsr	popR0
    799  0555		       20 5e 05 	      jsr	iCMPRsub
    800  0558		       20 6e 14 	      jsr	pushR0
    801  055b		       4c bb 02 	      jmp	NextIL
    802  055e							;
    803  055e							; See if they are equal or not
    804  055e							;
    805  055e				   iCMPRsub		; Called by internal functions
    806  055e
    807  055e		       a5 52		      lda	R0
    808  0560		       c5 54		      cmp	R1
    809  0562		       d0 0a		      bne	iCMPRnoteq	;try not equal
    810  0564		       a5 53		      lda	R0+1
    811  0566		       c5 55		      cmp	R1+1
    812  0568		       d0 04		      bne	iCMPRnoteq
    813  056a							;
    814  056a							; Equal, set the flag in MQ+1
    815  056a							;
    816  056a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    817  056c		       d0 14		      bne	iCMPcom	;Exit it is equal
    818  056e							;
    819  056e							; See if EXPR1 (R0) < EXPR2 (R1)
    820  056e							; See www.6502.org/tutorials/compare_beyond.html
    821  056e							;
    822  056e				   iCMPRnoteq
    823  056e		       a5 52		      lda	R0
    824  0570		       c5 54		      cmp	R1
    825  0572		       a5 53		      lda	R0+1
    826  0574		       e5 55		      sbc	R1+1
    827  0576		       50 02		      bvc	iCMPR_2
    828  0578		       49 80		      eor	#$80
    829  057a		       30 04	   iCMPR_2    bmi	iCMPlt
    830  057c		       a9 04		      lda	#REL_GT
    831  057e		       d0 02		      bne	iCMPcom
    832  0580		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    833  0582
    834  0582		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    835  0584							;
    836  0584							; Now compare the end result with what the caller
    837  0584							; was looking for.
    838  0584							;
    839  0584		       25 56		      and	MQ
    840  0586		       f0 0c		      beq	iCMPno	; no match
    841  0588		       a9 ff		      lda	#$FF	; true is $ffff
    842  058a		       85 52		      sta	R0
    843  058c		       85 53		      sta	R0+1
    844  058e		       d0 0c		      bne	iCMPDone
    845  0590							;
    846  0590							; R0 > R1
    847  0590							;
    848  0590		       a9 04	   iCMPgt     lda	#REL_GT
    849  0592		       d0 ee		      bne	iCMPcom
    850  0594				   iCMPno
    851  0594		       a9 00		      lda	#0
    852  0596		       85 52		      sta	R0
    853  0598		       a9 00		      lda	#0
    854  059a		       85 53		      sta	R0+1
    855  059c
    856  059c				   iCMPDone
    857  059c		       60		      rts
    858  059d
    859  059d							;
    860  059d							; if Not a match, so jump to the next line of code.
    861  059d							; Branches based upon value on top of the stack
    862  059d				   iBranch
    863  059d		       20 f2 14 	      jsr	popR0
    864  05a0		       a5 52		      lda	R0
    865  05a2		       05 53		      ora	R0+1
    866  05a4		       f0 03		      beq	iBranchFalse	; not true
    867  05a6		       4c bb 02 	      jmp	NextIL	; It is true if any value not zero
    868  05a9							;
    869  05a9				   iBranchFalse
    870  05a9		       20 ff 12 	      jsr	FindNextLine
    871  05ac		       4c ad 04 	      jmp	iXFER2
    872  05af							;
    873  05af							;=====================================================
    874  05af							; Start a read of data in background
    875  05af				   iReadStart
    876  05af		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05b1		       a6 01		      ldx	1	; Indicate to start read in background
    878  05b3		       20 8b 13 	      jsr	GetLine	; Call the getline to start read
    879  05b6		       4c bb 02 	      jmp	NextIL	; next instruction
    880  05b9							;
    881  05b9							;=====================================================
    882  05b9							; Complete the read and return the curptr, curoff pointing to data
    883  05b9				   iReadComplete
    884  05b9		       20 88 14 	      jsr	pushLN
    885  05bc		       90 03		      bcc	iReadOk
    886  05be		       4c 5c 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    887  05c1				   iReadOk
    888  05c1		       20 ab 13 	      jsr	ReadComplete
    889  05c4		       4c bb 02 	      jmp	NextIL
    890  05c7		       20 ad 14 	      jsr	popLN
    891  05ca		       4c bb 02 	      jmp	NextIL
    892  05cd							;=====================================================
    893  05cd							; Get a line of text from the user, convert to a
    894  05cd							; number, leave on top of stack.
    895  05cd							;
    896  05cd				   iINNUM
    897  05cd		       20 88 14 	      jsr	pushLN
    898  05d0		       b0 ec		      bcs	iReadErr	; Stack over flow error
    899  05d2							;
    900  05d2		       a9 3f		      lda	#'?
    901  05d4		       a2 00		      ldx	#0	;Wait for complete
    902  05d6		       20 8b 13 	      jsr	GetLine
    903  05d9		       20 20 13 	      jsr	getDecimal
    904  05dc		       20 6e 14 	      jsr	pushR0	;put onto stack
    905  05df		       b0 dd		      bcs	iReadErr	;StackOverflow error
    906  05e1							;
    907  05e1		       4c fb 05 	      jmp	ExitIn
    908  05e4							;
    909  05e4							;=====================================================
    910  05e4							; Get a line of text from the user, convert to a
    911  05e4							; character value , leave on top of stack. up to 2 characters
    912  05e4							;
    913  05e4				   iINSTR
    914  05e4		       20 88 14 	      jsr	pushLN
    915  05e7		       b0 d5		      bcs	iReadErr	; Stack overflow error
    916  05e9		       a9 3f		      lda	#'?
    917  05eb		       a2 00		      ldx	#0	;wait for read complete
    918  05ed		       20 8b 13 	      jsr	GetLine
    919  05f0		       b1 4f		      lda	(CURPTR),y
    920  05f2		       85 52		      sta	R0
    921  05f4		       a9 00		      lda	#0
    922  05f6		       85 53		      sta	R0+1
    923  05f8		       20 6e 14 	      jsr	pushR0	;put onto stack
    924  05fb				   ExitIn
    925  05fb		       20 ad 14 	      jsr	popLN
    926  05fe		       4c bb 02 	      jmp	NextIL
    927  0601							;
    928  0601							;
    929  0601							;=====================================================
    930  0601							; Stop the currently running program.	Actually very
    931  0601							; simple to do... clear the RunMode flag, then set the
    932  0601							; ILPC to the standard handler and continue running.
    933  0601							;
    934  0601		       a9 00	   iFIN       lda	#0
    935  0603		       85 5b		      sta	RunMode
    936  0605		       20 16 0f 	      jsr	taskReset
    937  0608							;
    938  0608		       ad 2a 27 	      lda	errGoto
    939  060b		       85 43		      sta	ILPC
    940  060d		       ad 2b 27 	      lda	errGoto+1
    941  0610		       85 44		      sta	ILPC+1
    942  0612		       4c bb 02 	      jmp	NextIL
    943  0615							;
    944  0615							;=====================================================
    945  0615							; Handle the ERR opcode.  Following the instruction is
    946  0615							; a 16 bit error number.  Print an error message, and
    947  0615							; if we're in run mode, print the line number.  Stop
    948  0615							; program execution and return to the initial state.
    949  0615							;
    950  0615		       20 71 12    iERR       jsr	getILWord	;get err code
    951  0618							;
    952  0618							; Enter here with the error code in X (LSB) and A (MSB).
    953  0618							;
    954  0618		       86 52	   iErr2      stx	R0
    955  061a		       85 53		      sta	R0+1
    956  061c							;
    957  061c		       20 fa 16 	      jsr	puts
      0  061f					      db	CR,LF,"Error ",0
      1  061f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    959  0628		       20 00 0d 	      jsr	PrintDecimal
    960  062b							;
    961  062b		       a5 5b		      lda	RunMode	;running?
    962  062d		       f0 3b		      beq	iERR3	;nope
    963  062f		       20 fa 16 	      jsr	puts
      0  0632					      db	" at line ",0
      1  0632		       20 61 74 20*	      .byte.b	" at line ",0
    965  063c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    966  063e				   iErr2a
    967  063e		       b1 4f		      lda	(CURPTR),y
    968  0640		       85 52		      sta	R0
    969  0642		       c8		      iny
    970  0643		       b1 4f		      lda	(CURPTR),y
    971  0645		       85 53		      sta	R0+1
    972  0647		       20 00 0d 	      jsr	PrintDecimal
    973  064a		       20 fa 16 	      jsr	puts
      0  064d					      db	":",0
      1  064d		       3a 00		      .byte.b	":",0
    975  064f		       a9 00		      lda	#0
    976  0651		       85 53		      sta	R0+1
    977  0653		       a5 51		      lda	CUROFF
    978  0655		       18		      clc
    979  0656		       e9 03		      sbc	#3
    980  0658		       85 52		      sta	R0
    981  065a		       20 00 0d 	      jsr	PrintDecimal
    982  065d		       20 fa 16 	      jsr	puts
      0  0660					      db	":",0
      1  0660		       3a 00		      .byte.b	":",0
    984  0662		       ad e4 1d 	      lda	taskPtr
    985  0665		       85 52		      sta	R0
    986  0667		       20 00 0d 	      jsr	PrintDecimal
    987  066a							;
    988  066a		       20 ab 15    iERR3      jsr	CRLF
    989  066d		       20 0e 0f 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    990  0670		       a9 00		      lda	#0
    991  0672		       85 5b		      sta	RunMode	;fall through...
    992  0674							;
    993  0674							;=====================================================
    994  0674							; Reset the IL to be back at the idle loop.  Does not
    995  0674							; clear variables so the user can see what state
    996  0674							; the program is in.
    997  0674							;
    998  0674		       a9 00	   ResetIL    lda	#0
    999  0676		       85 47		      sta	ILSTACKPTR
   1000  0678		       ad 2a 27 	      lda	errGoto
   1001  067b		       85 43		      sta	ILPC
   1002  067d		       ad 2b 27 	      lda	errGoto+1
   1003  0680		       85 44		      sta	ILPC+1
   1004  0682		       4c bb 02 	      jmp	NextIL
   1005  0685
   1006  0685							;
   1007  0685							;=====================================================
   1008  0685							; Pop two items off stack, add them, then place the
   1009  0685							; result back onto the stack.
   1010  0685							;
   1011  0685		       20 f2 14    iADD       jsr	popR0
   1012  0688		       20 0a 15 	      jsr	popR1
   1013  068b				   iADDfast
   1014  068b		       18		      clc
   1015  068c		       a5 52		      lda	R0
   1016  068e		       65 54		      adc	R1
   1017  0690		       85 52		      sta	R0
   1018  0692		       a5 53		      lda	R0+1
   1019  0694		       65 55		      adc	R1+1
   1020  0696		       85 53		      sta	R0+1
   1021  0698		       4c 03 07 	      jmp	pushR0nextIl
   1022  069b							;
   1023  069b							;=====================================================
   1024  069b							; Pop two items off the stack.  Subtract the top of
   1025  069b							; stack from the lower entry.
   1026  069b							;
   1027  069b		       20 0a 15    iSUB       jsr	popR1
   1028  069e		       20 f2 14 	      jsr	popR0
   1029  06a1		       38		      sec
   1030  06a2		       a5 52		      lda	R0
   1031  06a4		       e5 54		      sbc	R1
   1032  06a6		       85 52		      sta	R0
   1033  06a8		       a5 53		      lda	R0+1
   1034  06aa		       e5 55		      sbc	R1+1
   1035  06ac		       85 53		      sta	R0+1
   1036  06ae		       4c 03 07 	      jmp	pushR0nextIl
   1037  06b1							;
   1038  06b1							;=====================================================
   1039  06b1							; Negate the top of stack.
   1040  06b1							;
   1041  06b1		       20 f2 14    iNEG       jsr	popR0
   1042  06b4		       a5 52		      lda	R0
   1043  06b6		       49 ff		      eor	#$ff
   1044  06b8		       85 52		      sta	R0
   1045  06ba		       a5 53		      lda	R0+1
   1046  06bc		       49 ff		      eor	#$ff
   1047  06be		       85 53		      sta	R0+1
   1048  06c0		       e6 52		      inc	R0
   1049  06c2		       d0 02		      bne	iNEG2
   1050  06c4		       e6 53		      inc	R0+1
   1051  06c6		       4c 03 07    iNEG2      jmp	pushR0nextIl
   1052  06c9							;
   1053  06c9							;=====================================================
   1054  06c9							; Multiply top two items on the stack, put the results
   1055  06c9							; on top.  This uses the algorithm documented on page
   1056  06c9							; 115 of "Microprocessor Programming for Computer
   1057  06c9							; Hobbyists" by Neill Graham.
   1058  06c9							;
   1059  06c9		       20 cf 06    iMUL       jsr	iMultiply
   1060  06cc		       4c bb 02 	      jmp	NextIL
   1061  06cf
   1062  06cf				   iMultiply
   1063  06cf		       20 f2 14 	      jsr	popR0	;AC
   1064  06d2		       20 0a 15 	      jsr	popR1	;OP
   1065  06d5							;
   1066  06d5		       a5 52		      lda	R0
   1067  06d7		       85 56		      sta	MQ
   1068  06d9		       a5 53		      lda	R0+1
   1069  06db		       85 57		      sta	MQ+1
   1070  06dd		       a9 00		      lda	#0	;clear result
   1071  06df		       85 52		      sta	R0
   1072  06e1		       85 53		      sta	R0+1
   1073  06e3							;
   1074  06e3		       a2 10		      ldx	#16	;number of bits in value
   1075  06e5		       06 52	   multloop   asl	R0
   1076  06e7		       26 53		      rol	R0+1
   1077  06e9		       06 56		      asl	MQ
   1078  06eb		       26 57		      rol	MQ+1
   1079  06ed		       90 0d		      bcc	multno	;skip add if no carry
   1080  06ef							;
   1081  06ef							; Add R1 back into R0
   1082  06ef							;
   1083  06ef		       18		      clc
   1084  06f0		       a5 52		      lda	R0
   1085  06f2		       65 54		      adc	R1
   1086  06f4		       85 52		      sta	R0
   1087  06f6		       a5 53		      lda	R0+1
   1088  06f8		       65 55		      adc	R1+1
   1089  06fa		       85 53		      sta	R0+1
   1090  06fc							;
   1091  06fc		       ca	   multno     dex		;did all bits yet?
   1092  06fd		       d0 e6		      bne	multloop
   1093  06ff		       20 6e 14 	      jsr	pushR0	;OP
   1094  0702		       60		      rts
   1095  0703							;
   1096  0703				   pushR0nextIl
   1097  0703		       20 6e 14 	      jsr	pushR0	;OP
   1098  0706		       4c bb 02 	      jmp	NextIL
   1099  0709							;
   1100  0709							;=====================================================
   1101  0709							; Divide the top of stack into the next to top item.
   1102  0709							; Leave results on stack.  Taken from:
   1103  0709							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1104  0709							;
   1105  0709							; R0 = R0 / R1
   1106  0709							; Remainder is in MQ
   1107  0709							;
   1108  0709		       20 23 07    iDIV       jsr	iDoDiv
   1109  070c		       20 73 15 	      jsr	RestoreSigns
   1110  070f		       4c 03 07 	      jmp	pushR0nextIl
   1111  0712
   1112  0712		       20 23 07    iMOD       jsr	iDoDiv
   1113  0715		       20 73 15 	      jsr	RestoreSigns
   1114  0718		       a5 56		      lda	MQ
   1115  071a		       85 52		      sta	R0
   1116  071c		       a5 57		      lda	MQ+1
   1117  071e		       85 53		      sta	R0+1
   1118  0720		       4c 03 07 	      jmp	pushR0nextIl
   1119  0723
   1120  0723				   iDoDiv
   1121  0723		       20 0a 15 	      jsr	popR1
   1122  0726		       20 f2 14 	      jsr	popR0
   1123  0729							;
   1124  0729							; Check for divide by zero
   1125  0729							;
   1126  0729
   1127  0729				   iDivNoPop
   1128  0729		       a5 54		      lda	R1
   1129  072b		       05 55		      ora	R1+1
   1130  072d		       f0 29		      beq	divby0
   1131  072f							;
   1132  072f		       20 38 15 	      jsr	SaveSigns
   1133  0732		       a9 00		      lda	#0	;preset remainder to 0
   1134  0734		       85 56		      sta	MQ
   1135  0736		       85 57		      sta	MQ+1
   1136  0738		       a2 10		      ldx	#16	;repeat for each bit: ...
   1137  073a				   divloop
   1138  073a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1139  073c		       26 53		      rol	R0+1
   1140  073e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1141  0740		       26 57		      rol	MQ+1
   1142  0742		       a5 56		      lda	MQ
   1143  0744		       38		      sec
   1144  0745		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1145  0747		       a8		      tay		;lb result -> Y, for we may need it later
   1146  0748		       a5 57		      lda	MQ+1
   1147  074a		       e5 55		      sbc	R1+1
   1148  074c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1149  074e
   1150  074e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1151  0750		       84 56		      sty	MQ
   1152  0752		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1153  0754
   1154  0754		       ca	   skip       dex
   1155  0755		       d0 e3		      bne	divloop
   1156  0757		       60		      rts
   1157  0758							;
   1158  0758							; Indicate divide-by-zero error
   1159  0758							;
   1160  0758		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1161  075a		       a9 00		      lda	#0
   1162  075c		       4c 18 06 	      jmp	iErr2
   1163  075f							;
   1164  075f							;=====================================================
   1165  075f							; This pops the top two items off the stack.  The top
   1166  075f							; item is a data value and the other is an ABSOLUTE address.
   1167  075f							;Save the value into that address.
   1168  075f							;
   1169  075f		       98	   iSTORE     tya
   1170  0760		       48		      pha
   1171  0761		       20 f2 14 	      jsr	popR0	;data
   1172  0764		       20 0a 15 	      jsr	popR1	;Storage location
   1173  0767		       a0 00		      ldy	#0
   1174  0769		       a5 52		      lda	R0
   1175  076b		       91 54		      sta	(R1),y
   1176  076d		       a5 53		      lda	R0+1
   1177  076f		       c8		      iny
   1178  0770		       91 54		      sta	(R1),y
   1179  0772		       68		      pla
   1180  0773		       a8		      tay
   1181  0774		       4c bb 02 	      jmp	NextIL
   1182  0777							;
   1183  0777							;=====================================================
   1184  0777							; Replaces the top of stack with the variable whose
   1185  0777							; absolute address it represents.
   1186  0777							;
   1187  0777		       98	   iIND       tya
   1188  0778		       48		      pha
   1189  0779		       20 0a 15 	      jsr	popR1
   1190  077c		       a0 00		      ldy	#0
   1191  077e		       b1 54		      lda	(R1),y
   1192  0780		       85 52		      sta	R0
   1193  0782		       c8		      iny
   1194  0783		       b1 54		      lda	(R1),y
   1195  0785		       85 53		      sta	R0+1
   1196  0787		       68		      pla
   1197  0788		       a8		      tay
   1198  0789		       4c 03 07 	      jmp	pushR0nextIl
   1199  078c							;
   1200  078c							;=====================================================
   1201  078c							; Get the array index from top of stack get Current variable
   1202  078c							; address from next on stack, add the offset
   1203  078c							; push the result back onto the stack
   1204  078c				   iArray
   1205  078c		       20 f2 14 	      jsr	popR0	; Get the array index
   1206  078f		       20 0a 15 	      jsr	popR1	; Get the Variable address
   1207  0792
   1208  0792		       18		      clc		; Multiplythe value by 2
   1209  0793		       26 52		      rol	R0	; Do the multiply
   1210  0795		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1211  0797		       18		      clc
   1212  0798		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1213  079a		       65 52		      adc	R0
   1214  079c		       85 52		      sta	R0
   1215  079e		       a5 55		      lda	R1+1
   1216  07a0		       65 53		      adc	R0+1
   1217  07a2		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1218  07a4		       20 6e 14 	      jsr	pushR0	; Push R0 assume it is correct
   1219  07a7
   1220  07a7		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1221  07a9		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1222  07ab		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1223  07ad		       a5 55		      lda	R1+1
   1224  07af		       c5 42		      cmp	VARIABLES+1
   1225  07b1		       d0 1c		      bne	iArrayAtTest
   1226  07b3		       18		      clc
   1227  07b4		       a9 34		      lda	#52	; add the max offset that is valid
   1228  07b6		       65 54		      adc	R1	; update to be the largest offset that is valid
   1229  07b8		       85 54		      sta	R1
   1230  07ba		       a9 00		      lda	#0
   1231  07bc		       65 55		      adc	R1+1
   1232  07be		       85 55		      sta	R1+1
   1233  07c0				   iArrayVerify 		; try to enforce some sanity to using arrays
   1234  07c0		       a5 53		      lda	R0+1
   1235  07c2		       c5 55		      cmp	R1+1
   1236  07c4		       d0 04		      bne	iArrayDecide
   1237  07c6		       a5 52		      lda	R0
   1238  07c8		       c5 54		      cmp	R1
   1239  07ca				   iArrayDecide
   1240  07ca		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1241  07cc		       4c bb 02 	      jmp	NextIL
   1242  07cf
   1243  07cf				   iArrayAtTest
   1244  07cf		       ad 41 27 	      lda	HighMem
   1245  07d2		       85 54		      sta	R1
   1246  07d4		       ad 42 27 	      lda	HighMem+1
   1247  07d7		       85 55		      sta	R1+1
   1248  07d9		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1249  07db
   1250  07db							; Get here if array index is out of range
   1251  07db		       20 f2 14    iArrayError jsr	popR0
   1252  07de		       a9 00		      lda	#0
   1253  07e0		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1254  07e2		       4c 18 06 	      jmp	iErr2
   1255  07e5							;
   1256  07e5							;=====================================================
   1257  07e5							; List the current BASIC program in memory.  Uses R0,
   1258  07e5							; tempIly, and dpl.
   1259  07e5							;
   1260  07e5		       20 da 16    iLST       jsr	SetOutConsole
   1261  07e8		       ad 3d 27    iLST2      lda	ProgramStart
   1262  07eb		       85 59		      sta	dpl
   1263  07ed		       ad 3e 27 	      lda	ProgramStart+1
   1264  07f0		       85 5a		      sta	dpl+1
   1265  07f2							;
   1266  07f2							; dpl/dph point to the current line.  See if we're at
   1267  07f2							; the end of the program.
   1268  07f2							;
   1269  07f2		       a5 59	   iLSTloop   lda	dpl
   1270  07f4		       cd 3f 27 	      cmp	ProgramEnd
   1271  07f7		       d0 07		      bne	iLstNotEnd
   1272  07f9		       a5 5a		      lda	dpl+1
   1273  07fb		       cd 40 27 	      cmp	ProgramEnd+1
   1274  07fe		       f0 44		      beq	iLstdone
   1275  0800							;
   1276  0800		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1277  0802		       b1 59		      lda	(dpl),y	;line number LSB
   1278  0804		       85 52		      sta	R0
   1279  0806		       c8		      iny
   1280  0807		       b1 59		      lda	(dpl),y	;line number MSB
   1281  0809		       85 53		      sta	R0+1
   1282  080b		       c8		      iny
   1283  080c		       8c 38 27 	      sty	tempIlY
   1284  080f		       20 00 0d 	      jsr	PrintDecimal
   1285  0812		       a9 20		      lda	#SPACE
   1286  0814		       20 f4 16 	      jsr	VOUTCH
   1287  0817		       ac 38 27 	      ldy	tempIlY
   1288  081a		       b1 59	   iLSTl2     lda	(dpl),y
   1289  081c		       f0 0c		      beq	iLST3	;end of this line 0 value
   1290  081e		       8c 38 27 	      sty	tempIlY
   1291  0821		       20 f4 16 	      jsr	VOUTCH
   1292  0824		       ac 38 27 	      ldy	tempIlY
   1293  0827		       c8		      iny
   1294  0828		       d0 f0		      bne	iLSTl2	;do next char
   1295  082a							;
   1296  082a							; End of this line.  Print CR/LF, then move to the
   1297  082a							; next line.
   1298  082a							;
   1299  082a		       c8	   iLST3      iny		;Move to next line
   1300  082b		       18		      clc		;Clear the carry flag
   1301  082c		       98		      tya		;Current Offset
   1302  082d		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  082f		       85 59		      sta	dpl	;Save the new value
   1304  0831		       a5 5a		      lda	dpl+1	;Next byte
   1305  0833		       69 00		      adc	#0	;ad in the carry if any
   1306  0835		       85 5a		      sta	dpl+1	;Save it
   1307  0837							;
   1308  0837							; Have to manually do CR/LF so it uses the vectored
   1309  0837							; output function.
   1310  0837							;
   1311  0837		       a9 0d		      lda	#CR
   1312  0839		       20 f4 16 	      jsr	VOUTCH
   1313  083c		       a9 0a		      lda	#LF
   1314  083e		       20 f4 16 	      jsr	VOUTCH
   1315  0841		       4c f2 07 	      jmp	iLSTloop	;do next line
   1316  0844							;
   1317  0844		       20 da 16    iLstdone   jsr	SetOutConsole
   1318  0847		       4c bb 02 	      jmp	NextIL
   1319  084a							;
   1320  084a							;=====================================================
   1321  084a							; Get a line of text into LINBUF.  Terminate with a
   1322  084a							; null byte.
   1323  084a							;
   1324  084a				   iGETLINE
   1325  084a		       a9 3e		      lda	#'>	;prompt character
   1326  084c		       a6 00		      ldx	0	;Wait for read to complete
   1327  084e		       20 8b 13 	      jsr	GetLine
   1328  0851							;
   1329  0851		       a9 00		      lda	#0
   1330  0853		       85 5b		      sta	RunMode
   1331  0855		       4c bb 02 	      jmp	NextIL
   1332  0858							;
   1333  0858							;=====================================================
   1334  0858							; This is called when the input buffer contains a line
   1335  0858							; typed in by the user that starts with a line number.
   1336  0858							; Insert the line into the program or delete the line
   1337  0858							; if there is nothing after the line number,
   1338  0858							;
   1339  0858		       a0 00	   iINSRT     ldy	#0
   1340  085a		       20 20 13 	      jsr	getDecimal	;convert line #
   1341  085d		       20 a2 15 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1342  0860		       8c 39 27 	      sty	offset	;Save the start of the program line text
   1343  0863							;
   1344  0863							; Now find the line OR the next higher line OR the
   1345  0863							; end of the program.
   1346  0863							;
   1347  0863		       20 ba 12 	      jsr	findLine	; Look for the line number in the current program
   1348  0866							; Returns Z and curptr point to the line if found
   1349  0866							; Returns C and curptr at next higher line if not found and there is a higher line
   1350  0866							; Returns ZC clear and curptr to end of program if higher than all other lines
   1351  0866							;
   1352  0866							; If the line exists, it needs to be removed.
   1353  0866							;
   1354  0866		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1355  0868							;
   1356  0868							; Get length of line to be removed, we fall thru to here if we find a matching line
   1357  0868							;
   1358  0868							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1359  0868		       a0 00		      ldy	#0
   1360  086a		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1361  086c		       a8		      tay
   1362  086d							;If it is equal we delete the line and replace it, get length
   1363  086d							;then adjust all program line after up or down depending on len of line
   1364  086d							;If next higher then just move everythimg down by length bytes
   1365  086d							;This call will return how many bytes in the line we found
   1366  086d		       8c 3a 27 	      sty	lineLength	;Save the length of the line we found
   1367  0870							;
   1368  0870							; Compute the new end of the program first.
   1369  0870							;
   1370  0870		       38		      sec		;Set the carry bit
   1371  0871		       ad 3f 27 	      lda	ProgramEnd	;Get low byte of program end
   1372  0874		       ed 3a 27 	      sbc	lineLength	;Subtract the length of the current line
   1373  0877		       8d 3f 27 	      sta	ProgramEnd	;save it
   1374  087a		       ad 40 27 	      lda	ProgramEnd+1
   1375  087d		       e9 00		      sbc	#0	;Process the carry
   1376  087f		       8d 40 27 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1377  0882							;
   1378  0882							; Copy CURPTR into R1 for working
   1379  0882							;
   1380  0882		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1381  0884		       85 54		      sta	R1
   1382  0886		       a5 50		      lda	CURPTR+1
   1383  0888		       85 55		      sta	R1+1
   1384  088a							;
   1385  088a							; See if we're at the end.
   1386  088a							;
   1387  088a		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1388  088c		       cd 3f 27 	      cmp	ProgramEnd
   1389  088f		       d0 07		      bne	InsDelLoop
   1390  0891		       a5 55		      lda	R1+1
   1391  0893		       cd 40 27 	      cmp	ProgramEnd+1
   1392  0896		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1393  0898							;
   1394  0898							; Move one byte, move to next location.
   1395  0898							;
   1396  0898		       ac 3a 27    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1397  089b		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1398  089d		       b1 54		      lda	(R1),y
   1399  089f		       a0 00		      ldy	#0
   1400  08a1		       91 54		      sta	(R1),y
   1401  08a3		       e6 54		      inc	R1
   1402  08a5		       d0 e3		      bne	InsDelChk
   1403  08a7		       e6 55		      inc	R1+1
   1404  08a9		       4c 8a 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1405  08ac							;
   1406  08ac							; Deletion is done.
   1407  08ac							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1408  08ac							;
   1409  08ac		       ac 39 27    insert2    ldy	offset	; get back ptr  Get the current offset
   1410  08af		       b9 a0 26 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1411  08b2		       f0 5f		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1412  08b4							;
   1413  08b4							; CURPTR points to where the line will be inserted.
   1414  08b4							;
   1415  08b4		       20 45 14 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1416  08b7							;
   1417  08b7		       ad 3f 27 	      lda	ProgramEnd	;Load the start address for the copy
   1418  08ba							;At this point curptr still contains the location we will insert data
   1419  08ba		       85 5c		      sta	FROM
   1420  08bc		       ad 40 27 	      lda	ProgramEnd+1
   1421  08bf		       85 5d		      sta	FROM+1
   1422  08c1							;
   1423  08c1		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1424  08c3		       b1 5c		      lda	(FROM),y
   1425  08c5		       ac 3a 27 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1426  08c8		       91 5c		      sta	(FROM),y	;Save the new byte
   1427  08ca							;
   1428  08ca		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1429  08cc		       c5 4f		      cmp	CURPTR
   1430  08ce		       d0 06		      bne	mvUpMore
   1431  08d0		       a5 5d		      lda	FROM+1
   1432  08d2		       c5 50		      cmp	CURPTR+1
   1433  08d4		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1434  08d6							;
   1435  08d6							; Not done yet
   1436  08d6							;
   1437  08d6		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1438  08d8		       d0 02		      bne	mvUpMore2
   1439  08da		       c6 5d		      dec	FROM+1
   1440  08dc		       c6 5c	   mvUpMore2  dec	FROM
   1441  08de		       4c c1 08 	      jmp	mvup1	;Loop until everything is moved
   1442  08e1							;
   1443  08e1							; All done with copy.
   1444  08e1							;
   1445  08e1				   mvUpDone
   1446  08e1		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1447  08e2		       ad 3a 27 	      lda	lineLength	;Number of bytes to copy from line buff
   1448  08e5		       6d 3f 27 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1449  08e8		       8d 3f 27 	      sta	ProgramEnd
   1450  08eb		       ad 40 27 	      lda	ProgramEnd+1
   1451  08ee		       69 00		      adc	#0
   1452  08f0		       8d 40 27 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1453  08f3							;
   1454  08f3							;===================jlit use length before line newline
   1455  08f3
   1456  08f3		       a0 00		      ldy	#0	;Set offset of copy
   1457  08f5		       ad 3a 27 	      lda	lineLength	;We will insert the actual length of the line first
   1458  08f8		       91 4f		      sta	(CURPTR),y	;Store the length
   1459  08fa		       c8		      iny
   1460  08fb		       a5 52		      lda	R0	;Store the line number next
   1461  08fd		       91 4f		      sta	(CURPTR),y
   1462  08ff		       c8		      iny
   1463  0900		       a5 53		      lda	R0+1
   1464  0902		       91 4f		      sta	(CURPTR),y
   1465  0904		       c8		      iny
   1466  0905							;
   1467  0905		       ae 39 27 	      ldx	offset	;Load the offset into line buffer in page zero
   1468  0908		       bd a0 26    mvUpLoop2  lda	LINBUF,x	;get a byte
   1469  090b		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1470  090d		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1471  090f		       e8		      inx
   1472  0910		       c8		      iny
   1473  0911		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1474  0913							;
   1475  0913		       4c bb 02    mvUpFini   jmp	NextIL
   1476  0916							;
   1477  0916							;=====================================================
   1478  0916							; Pops the top value of the ILPC stack and stores it
   1479  0916							; in ILPC.  Ie, return from an IL subroutine.
   1480  0916							;
   1481  0916		       20 a8 12    iRTN       jsr	popILPC
   1482  0919		       4c bb 02 	      jmp	NextIL
   1483  091c							;
   1484  091c							;=====================================================
   1485  091c							; NLINE print a newline
   1486  091c							;
   1487  091c		       20 ab 15    iNLINE     jsr	CRLF	;user supplied sub
   1488  091f		       4c bb 02 	      jmp	NextIL
   1489  0922							;
   1490  0922							;=====================================================
   1491  0922							; This saves the current ILPC value on the stack, then
   1492  0922							; jumps to the address specified by the next two bytes.
   1493  0922							;
   1494  0922		       20 8b 12    iCALL      jsr	pushILPC	;save ILPC
   1495  0925		       90 03		      bcc	iJMP
   1496  0927		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   1497  092a							;
   1498  092a							; Jmp to a specific location in the IL code.  The new
   1499  092a							; address immediately follows the opcode.
   1500  092a							;
   1501  092a		       20 71 12    iJMP       jsr	getILWord
   1502  092d		       86 43		      stx	ILPC
   1503  092f		       85 44		      sta	ILPC+1
   1504  0931		       4c bb 02 	      jmp	NextIL
   1505  0934
   1506  0934
   1507  0934							;
   1508  0934							;=====================================================
   1509  0934							; Push the next two bytes onto the arithmetic stack.
   1510  0934							;
   1511  0934		       20 75 12    iSetR2     jsr	getILByte
   1512  0937		       85 58		      sta	R2
   1513  0939		       4c bb 02 	      jmp	NextIL
   1514  093c							;
   1515  093c							;=====================================================
   1516  093c							; Push the next two bytes onto the arithmetic stack.
   1517  093c							;
   1518  093c		       20 71 12    iLIT       jsr	getILWord
   1519  093f		       86 52		      stx	R0
   1520  0941		       85 53		      sta	R0+1
   1521  0943		       20 6e 14 	      jsr	pushR0
   1522  0946		       4c bb 02 	      jmp	NextIL
   1523  0949							;
   1524  0949							;=====================================================
   1525  0949							; Initialize all variables for a single task.	Ie, set to zero.
   1526  0949							;
   1527  0949		       98	   subVINIT   tya
   1528  094a		       48		      pha
   1529  094b
   1530  094b		       a9 00		      lda	#0
   1531  094d		       a0 00		      ldy	#0
   1532  094f		       91 41	   Vinit2     sta	(VARIABLES),y
   1533  0951		       c8		      iny
   1534  0952		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1535  0954		       90 f9		      bcc	Vinit2
   1536  0956
   1537  0956		       68		      pla
   1538  0957		       a8		      tay
   1539  0958		       60		      rts
   1540  0959
   1541  0959		       20 49 09    iVINIT     jsr	subVINIT
   1542  095c		       4c bb 02 	      jmp	NextIL
   1543  095f							;
   1544  095f							;=====================================================
   1545  095f							; Set the address of the error handler.  After any
   1546  095f							; error, set to the ILPC to the specified location.
   1547  095f							;
   1548  095f		       20 71 12    iERRGOTO   jsr	getILWord
   1549  0962		       8e 2a 27 	      stx	errGoto
   1550  0965		       8d 2b 27 	      sta	errGoto+1
   1551  0968		       4c bb 02 	      jmp	NextIL
   1552  096b							;
   1553  096b							;=====================================================
   1554  096b							; TST is followed by an 8 bit signed offset, then a
   1555  096b							; null terminated string.  Compare the string against
   1556  096b							; the string starting at (CURPTR),CUROFF.  If the
   1557  096b							; strings match, continue executing the next IL
   1558  096b							; opcode.  Else, add the offset to ILPC.
   1559  096b							;
   1560  096b		       20 75 12    iTST       jsr	getILByte	;Get the relative jump address
   1561  096e		       8d 39 27 	      sta	offset	;save it to use if test faile
   1562  0971		       20 58 14 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1563  0974
   1564  0974		       a4 51		      ldy	CUROFF
   1565  0976		       84 59		      sty	dpl	;save for later
   1566  0978							;
   1567  0978		       20 75 12    iTSTloop   jsr	getILByte	;get next char
   1568  097b		       f0 11		      beq	iTSTm	;match!
   1569  097d		       a4 59		      ldy	dpl
   1570  097f		       d1 4f		      cmp	(CURPTR),y
   1571  0981		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1572  0983		       09 20		      ora	#$20	; lets allow lowercase as well
   1573  0985		       d1 4f		      cmp	(CURPTR),y
   1574  0987		       d0 23		      bne	iTSTfail	;mismatch
   1575  0989		       c8	   iTSTUpper  iny
   1576  098a		       84 59		      sty	dpl
   1577  098c		       d0 ea		      bne	iTSTloop
   1578  098e							;
   1579  098e							; It's a match!  Clean up a bit.
   1580  098e							;
   1581  098e		       a4 59	   iTSTm      ldy	dpl
   1582  0990		       84 51		      sty	CUROFF
   1583  0992		       4c bb 02 	      jmp	NextIL
   1584  0995
   1585  0995							; Test for a single quote string
   1586  0995		       20 75 12    iTSTStr    jsr	getILByte
   1587  0998		       8d 39 27 	      sta	offset
   1588  099b		       20 58 14 	      jsr	saveIL
   1589  099e		       a4 51		      ldy	CUROFF
   1590  09a0		       a9 22		      lda	#'"
   1591  09a2		       d1 4f		      cmp	(CURPTR),y
   1592  09a4		       d0 06		      bne	iTSTfail
   1593  09a6		       c8		      iny
   1594  09a7		       84 51		      sty	CUROFF
   1595  09a9		       4c de 02 	      jmp	NextILStr
   1596  09ac							;
   1597  09ac							; Not a match, reset ILPC and then move to the
   1598  09ac							; offset.
   1599  09ac							;
   1600  09ac		       20 63 14    iTSTfail   jsr	restoreIL
   1601  09af		       4c 0c 0b 	      jmp	tstBranch
   1602  09b2							;
   1603  09b2							;=================================================JLIT=
   1604  09b2							; Test if we have a let statement without the let keyword
   1605  09b2		       20 75 12    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1606  09b5		       8d 39 27 	      sta	offset	; Save the jump offset for fails
   1607  09b8		       20 58 14 	      jsr	saveIL	; save to restore when done if fail
   1608  09bb
   1609  09bb		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1610  09bd		       20 a2 15 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1611  09c0		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1612  09c1		       20 a2 15 	      jsr	SkipSpaces	; skip any SkipSpaces
   1613  09c4		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1614  09c6		       c9 3d		      cmp	#'=	; check if equals
   1615  09c8		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1616  09ca		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1617  09cc		       d0 de		      bne	iTSTfail	; return it failed
   1618  09ce
   1619  09ce				   iTSTLETGOOD
   1620  09ce		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1621  09d1
   1622  09d1							;=================================================JLIT=
   1623  09d1							;
   1624  09d1		       20 75 12    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1625  09d4		       8d 39 27 	      sta	offset	; Save the jump offset for fails
   1626  09d7		       20 58 14 	      jsr	saveIL	; save to restore when done if fail
   1627  09da		       20 71 12 	      jsr	getILWord	; Get a word into RO
   1628  09dd		       86 52		      stx	R0
   1629  09df		       85 53		      sta	R0+1
   1630  09e1		       20 75 12 	      jsr	getILByte	; Get byte into A
   1631  09e4		       a0 00		      ldy	#0
   1632  09e6		       d1 52		      cmp	(R0),y
   1633  09e8		       d0 03		      bne	iTSTByteNotEqual
   1634  09ea		       4c ac 09 	      jmp	iTSTfail
   1635  09ed
   1636  09ed				   iTSTByteNotEqual
   1637  09ed		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1638  09f0
   1639  09f0
   1640  09f0							;================================================jLIT=
   1641  09f0							;Test for end of line
   1642  09f0							;
   1643  09f0		       20 75 12    iTSTDONE   jsr	getILByte
   1644  09f3		       8d 39 27 	      sta	offset
   1645  09f6		       20 58 14 	      jsr	saveIL
   1646  09f9		       a4 51		      ldy	CUROFF
   1647  09fb		       84 59		      sty	dpl
   1648  09fd		       20 a2 15 	      jsr	SkipSpaces
   1649  0a00		       b1 4f		      lda	(CURPTR),y
   1650  0a02		       f0 0b		      beq	iTSTDONEtrue
   1651  0a04		       c9 3a		      cmp	#COLON
   1652  0a06		       f0 07		      beq	iTSTDONEtrue
   1653  0a08		       a4 59		      ldy	dpl
   1654  0a0a		       84 51		      sty	CUROFF
   1655  0a0c		       4c ac 09 	      jmp	iTSTfail
   1656  0a0f							;
   1657  0a0f							; Advance to the next line
   1658  0a0f							;
   1659  0a0f				   iTSTDONEtrue
   1660  0a0f		       4c bb 02 	      jmp	NextIL
   1661  0a12
   1662  0a12		       4c 0c 0b    tstBranchLink jmp	tstBranch
   1663  0a15							;
   1664  0a15							;=====================================================
   1665  0a15							; Inc and dec a variable , faster than a = a + 1
   1666  0a15				   iINCVAR
   1667  0a15		       20 f2 14 	      jsr	popR0
   1668  0a18		       a0 00		      ldy	#0
   1669  0a1a		       18		      clc
   1670  0a1b		       a9 01		      lda	#1
   1671  0a1d		       71 52		      adc	(R0),y
   1672  0a1f		       91 52		      sta	(R0),y
   1673  0a21		       90 07		      bcc	iINCDONE
   1674  0a23		       c8		      iny
   1675  0a24		       a9 00		      lda	#0
   1676  0a26		       71 52		      adc	(R0),y
   1677  0a28		       91 52		      sta	(R0),y
   1678  0a2a				   iINCDONE
   1679  0a2a		       4c bb 02 	      jmp	NextIL
   1680  0a2d				   iDECVAR
   1681  0a2d		       20 f2 14 	      jsr	popR0
   1682  0a30		       a0 00		      ldy	#0
   1683  0a32		       38		      sec
   1684  0a33		       b1 52		      lda	(R0),y
   1685  0a35		       e9 01		      sbc	#1
   1686  0a37		       91 52		      sta	(R0),y
   1687  0a39		       c8		      iny
   1688  0a3a		       b1 52		      lda	(R0),y
   1689  0a3c		       69 00		      adc	#0
   1690  0a3e		       91 52		      sta	(R0),y
   1691  0a40		       4c bb 02 	      jmp	NextIL
   1692  0a43
   1693  0a43
   1694  0a43							;
   1695  0a43							;=====================================================
   1696  0a43							; TSTV is followed by an 8 bit signed offset.	If the
   1697  0a43							; value at (CURPTR),CUROFF appears to be a variable
   1698  0a43							; name, move to the next IL statement.  Else, add the
   1699  0a43							; offset to ILPC. Converted to use actual absolute memory addresses
   1700  0a43							; TSTVT Looks for the task context
   1701  0a43							;
   1702  0a43		       20 0a 15    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1703  0a46		       a9 00		      lda	#0
   1704  0a48		       85 58		      sta	R2
   1705  0a4a		       f0 04		      beq	iTSTVV
   1706  0a4c
   1707  0a4c		       a9 01	   iTSTV      lda	#1
   1708  0a4e		       85 58		      sta	R2
   1709  0a50
   1710  0a50		       20 75 12    iTSTVV     jsr	getILByte	;offset
   1711  0a53		       8d 39 27 	      sta	offset
   1712  0a56							;
   1713  0a56		       a4 51		      ldy	CUROFF
   1714  0a58		       20 a2 15 	      jsr	SkipSpaces
   1715  0a5b		       b1 4f		      lda	(CURPTR),y
   1716  0a5d		       d0 03		      bne	iTSTVnext
   1717  0a5f		       4c 12 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1718  0a62							;
   1719  0a62				   iTSTVnext
   1720  0a62		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1721  0a64		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1722  0a66
   1723  0a66		       c9 23		      cmp	#'#	; parameters passed to this task
   1724  0a68		       f0 53		      beq	iTSTVParm
   1725  0a6a
   1726  0a6a		       c9 5e		      cmp	#'^	; task exit code
   1727  0a6c		       d0 04		      bne	iTSTV_A2Z
   1728  0a6e		       a9 19		      lda	#TASKEXITCODE
   1729  0a70		       d0 10		      bne	iTSTVContinue
   1730  0a72
   1731  0a72				   iTSTV_A2Z
   1732  0a72		       09 20		      ora	#$20	;make lower then upper
   1733  0a74		       49 20		      eor	#$20	;allow lower case here
   1734  0a76		       c9 41		      cmp	#'A
   1735  0a78		       90 98		      bcc	tstBranchLink
   1736  0a7a		       c9 5b		      cmp	#'Z+1
   1737  0a7c		       b0 94		      bcs	tstBranchLink
   1738  0a7e
   1739  0a7e
   1740  0a7e							;
   1741  0a7e							; The condition is true, so convert to an index, push
   1742  0a7e							; it onto the stack and continue running.
   1743  0a7e							;
   1744  0a7e		       38		      sec
   1745  0a7f		       e9 41		      sbc	#'A	;index is zero based
   1746  0a81		       0a		      asl		;multiply by two
   1747  0a82
   1748  0a82				   iTSTVContinue
   1749  0a82		       c8		      iny
   1750  0a83		       84 51		      sty	CUROFF	;it is a valid variable
   1751  0a85		       48		      pha
   1752  0a86		       a5 58		      lda	R2
   1753  0a88		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1754  0a8a
   1755  0a8a		       20 58 12 	      jsr	ipc_getcontext	; Get the other tasks variables
   1756  0a8d		       a0 01		      ldy	#VARIABLEPOS
   1757  0a8f		       b1 56		      lda	(MQ),y
   1758  0a91		       85 52		      sta	R0
   1759  0a93		       c8		      iny
   1760  0a94		       b1 56		      lda	(MQ),y
   1761  0a96		       85 53		      sta	R0+1
   1762  0a98		       4c a3 0a 	      jmp	iTSTVAddOffset
   1763  0a9b
   1764  0a9b				   iTSTVLocalValue
   1765  0a9b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1766  0a9d		       85 52		      sta	R0
   1767  0a9f		       a5 42		      lda	VARIABLES+1
   1768  0aa1		       85 53		      sta	R0+1
   1769  0aa3
   1770  0aa3				   iTSTVAddOffset
   1771  0aa3		       68		      pla
   1772  0aa4		       85 54		      sta	R1
   1773  0aa6		       a9 00		      lda	#0
   1774  0aa8		       85 55		      sta	R1+1
   1775  0aaa
   1776  0aaa				   iTSTVcontinue
   1777  0aaa
   1778  0aaa		       4c 8b 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1779  0aad
   1780  0aad							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1781  0aad							; an array of integer values
   1782  0aad				   iTSTVat
   1783  0aad		       c8		      iny
   1784  0aae		       84 51		      sty	CUROFF	;it is a valid variable
   1785  0ab0		       ad 3f 27 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1786  0ab3		       85 52		      sta	R0
   1787  0ab5		       ad 40 27 	      lda	ProgramEnd+1
   1788  0ab8		       85 53		      sta	R0+1
   1789  0aba		       4c 03 07 	      jmp	pushR0nextIl	;place this onto the stack
   1790  0abd
   1791  0abd							; When we get parameters passed we can access them using the # variable with[]
   1792  0abd							; example #[0] #[1] etc, we dont check yet if there is too many
   1793  0abd				   iTSTVParm
   1794  0abd		       c8		      iny
   1795  0abe		       84 51		      sty	CUROFF	;it is a valid variable
   1796  0ac0		       a5 48		      lda	MATHSTACK
   1797  0ac2		       85 52		      sta	R0
   1798  0ac4		       a5 49		      lda	MATHSTACK+1
   1799  0ac6		       85 53		      sta	R0+1
   1800  0ac8		       4c 03 07 	      jmp	pushR0nextIl
   1801  0acb
   1802  0acb							;
   1803  0acb							;=====================================================
   1804  0acb							; TSTL seems basically the same as TSTN, but leave the
   1805  0acb							; value in R0 instead of pushing onto stack.
   1806  0acb							; This tests for a valid line number
   1807  0acb							;
   1808  0acb		       20 75 12    iTSTL      jsr	getILByte
   1809  0ace		       8d 39 27 	      sta	offset
   1810  0ad1							;
   1811  0ad1		       a4 51		      ldy	CUROFF
   1812  0ad3		       20 a2 15 	      jsr	SkipSpaces
   1813  0ad6		       b1 4f		      lda	(CURPTR),y
   1814  0ad8							;
   1815  0ad8		       c9 30		      cmp	#'0
   1816  0ada		       90 30		      bcc	tstBranch
   1817  0adc		       c9 3a		      cmp	#'9+1
   1818  0ade		       b0 2c		      bcs	tstBranch
   1819  0ae0							;
   1820  0ae0							; It's a digit, so convert to a number.
   1821  0ae0							;
   1822  0ae0		       20 20 13 	      jsr	getDecimal
   1823  0ae3		       4c bb 02 	      jmp	NextIL
   1824  0ae6							;
   1825  0ae6							;=====================================================
   1826  0ae6							; TSTN checks for a number.  This is very simplistic;
   1827  0ae6							; if the character is a digit, assume it's a number.
   1828  0ae6							; Convert to a number and push it onto the stack.
   1829  0ae6							;
   1830  0ae6		       20 75 12    iTSTN      jsr	getILByte
   1831  0ae9		       8d 39 27 	      sta	offset
   1832  0aec							;
   1833  0aec		       a4 51		      ldy	CUROFF
   1834  0aee		       20 a2 15 	      jsr	SkipSpaces
   1835  0af1		       b1 4f		      lda	(CURPTR),y
   1836  0af3		       f0 17		      beq	tstBranch
   1837  0af5		       c9 2d		      cmp	#'-	;negative?
   1838  0af7		       f0 08		      beq	iTSTN_1
   1839  0af9		       c9 30		      cmp	#'0
   1840  0afb		       90 0f		      bcc	tstBranch
   1841  0afd		       c9 3a		      cmp	#'9+1
   1842  0aff		       b0 0b		      bcs	tstBranch
   1843  0b01							;
   1844  0b01							; It's a digit, so convert to a number.
   1845  0b01							;
   1846  0b01				   iTSTN_1
   1847  0b01		       20 20 13 	      jsr	getDecimal
   1848  0b04		       84 51		      sty	CUROFF
   1849  0b06		       20 6e 14 	      jsr	pushR0	;save onto stack
   1850  0b09		       4c bb 02 	      jmp	NextIL
   1851  0b0c
   1852  0b0c							;
   1853  0b0c							; Common jump point for all TSTx instructions that
   1854  0b0c							; fail to meet the requirements.  This takes the
   1855  0b0c							; offset and adds/subtracts to/from ILPC.
   1856  0b0c							;
   1857  0b0c		       ad 39 27    tstBranch  lda	offset	;get signed offset
   1858  0b0f		       10 0e		      bpl	tstPositive
   1859  0b11							;
   1860  0b11							; Do negative branch.	Do sign extension.
   1861  0b11							;
   1862  0b11		       18	   tstNegative clc
   1863  0b12		       65 43		      adc	ILPC
   1864  0b14		       85 43		      sta	ILPC
   1865  0b16							;		  bcc	  tstBothDone
   1866  0b16							;		  dec	  ILPC+1
   1867  0b16							;		  jmp	  NextIL
   1868  0b16
   1869  0b16		       a5 44		      lda	ILPC+1
   1870  0b18		       69 ff		      adc	#$ff
   1871  0b1a		       85 44		      sta	ILPC+1
   1872  0b1c		       4c bb 02 	      jmp	NextIL	;keep going
   1873  0b1f							;
   1874  0b1f		       18	   tstPositive clc
   1875  0b20		       65 43		      adc	ILPC
   1876  0b22		       85 43		      sta	ILPC
   1877  0b24		       90 02		      bcc	tstBothDone
   1878  0b26		       e6 44		      inc	ILPC+1
   1879  0b28				   tstBothDone
   1880  0b28		       4c bb 02 	      jmp	NextIL
   1881  0b2b
   1882  0b2b							;
   1883  0b2b							;====================================================
   1884  0b2b							; Test for IRQ pending, and test if a break key pressed
   1885  0b2b							; Yes I know but this handles all sorts of irq/break issues
   1886  0b2b							;
   1887  0b2b		       20 75 12    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1888  0b2e		       8d 39 27 	      sta	offset	; Store the not true jump address offset
   1889  0b31		       20 36 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1890  0b34		       d0 03		      bne	irqNo	; z not set of no break found
   1891  0b36		       4c 01 06 	      jmp	iFIN	; Exit out of run mode
   1892  0b39		       ad e1 1d    irqNo      lda	IRQPending
   1893  0b3c		       f0 ce		      beq	tstBranch
   1894  0b3e		       c9 01		      cmp	#1	; only do this if set to first time
   1895  0b40		       d0 ca		      bne	tstBranch
   1896  0b42		       78		      sei		; disable the interupt until ireturn resets it
   1897  0b43		       ee e1 1d    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1898  0b46		       20 88 14 	      jsr	pushLN	; Push the next line to be executed
   1899  0b49		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1900  0b4b		       ad e2 1d 	      lda	IRQEntry	; Get the line number to branch to
   1901  0b4e		       85 4f		      sta	CURPTR	; put line number into r0
   1902  0b50		       ad e3 1d 	      lda	IRQEntry+1
   1903  0b53		       85 50		      sta	CURPTR+1
   1904  0b55		       a9 03		      lda	#3	; Point to first byte of program text
   1905  0b57		       85 51		      sta	CUROFF
   1906  0b59		       4c bb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1907  0b5c
   1908  0b5c		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1909  0b5e		       a9 00		      lda	#0	; stop the execution
   1910  0b60		       4c 18 06 	      jmp	iErr2
   1911  0b63							;
   1912  0b63
   1913  0b63							;=====================================================
   1914  0b63							; This places the number of free bytes on top of the
   1915  0b63							; stack.
   1916  0b63							;
   1917  0b63		       20 db 0d    iFREE      jsr	MemFree
   1918  0b66		       20 6e 14 	      jsr	pushR0
   1919  0b69		       4c bb 02 	      jmp	NextIL
   1920  0b6c							;
   1921  0b6c							;=====================================================
   1922  0b6c							; Generate a random number from 0-FFFF and then MOD
   1923  0b6c							; it with the value on top of stack.  Leaves number on
   1924  0b6c							; stack
   1925  0b6c							;
   1926  0b6c		       20 0a 15    iRANDOM    jsr	popR1	;mod value
   1927  0b6f							;
   1928  0b6f							; If the value is zero, just return a one.
   1929  0b6f							;
   1930  0b6f		       a5 54		      lda	R1
   1931  0b71		       05 55		      ora	R1+1
   1932  0b73		       f0 4a		      beq	irandom1
   1933  0b75							;
   1934  0b75		       ad 30 27 	      lda	random+1
   1935  0b78		       8d 2d 27 	      sta	rtemp1
   1936  0b7b		       ad 2f 27 	      lda	random
   1937  0b7e		       0a		      asl
   1938  0b7f		       2e 2d 27 	      rol	rtemp1
   1939  0b82		       0a		      asl
   1940  0b83		       2e 2d 27 	      rol	rtemp1
   1941  0b86		       18		      clc
   1942  0b87		       6d 2f 27 	      adc	random
   1943  0b8a
   1944  0b8a		       48		      pha
   1945  0b8b
   1946  0b8b		       ad 2d 27 	      lda	rtemp1
   1947  0b8e		       6d 30 27 	      adc	random+1
   1948  0b91		       8d 30 27 	      sta	random+1
   1949  0b94
   1950  0b94		       68		      pla
   1951  0b95
   1952  0b95		       69 11		      adc	#$11
   1953  0b97		       8d 2f 27 	      sta	random
   1954  0b9a		       ad 30 27 	      lda	random+1
   1955  0b9d		       69 36		      adc	#$36
   1956  0b9f		       8d 30 27 	      sta	random+1
   1957  0ba2
   1958  0ba2		       ad 2f 27 	      lda	random
   1959  0ba5		       85 52		      sta	R0
   1960  0ba7		       ad 30 27 	      lda	random+1
   1961  0baa		       29 7f		      and	#$7f	;make positive
   1962  0bac		       85 53		      sta	R0+1
   1963  0bae							;
   1964  0bae							; R0 contains the number and R1 contains the max value.
   1965  0bae							;
   1966  0bae		       20 29 07 	      jsr	iDivNoPop
   1967  0bb1		       20 73 15 	      jsr	RestoreSigns
   1968  0bb4		       a5 56		      lda	MQ
   1969  0bb6		       85 52		      sta	R0
   1970  0bb8		       a5 57		      lda	MQ+1
   1971  0bba		       85 53		      sta	R0+1
   1972  0bbc		       4c 03 07 	      jmp	pushR0nextIl
   1973  0bbf				   irandom1
   1974  0bbf		       a9 00		      lda	#0
   1975  0bc1		       85 53		      sta	R0+1
   1976  0bc3		       a9 01		      lda	#1
   1977  0bc5		       85 52		      sta	R0
   1978  0bc7		       4c 03 07 	      jmp	pushR0nextIl
   1979  0bca
   1980  0bca							; The following replaced by call to division/modulo
   1981  0bca							;iRANDOM_2	lda	R0
   1982  0bca							;		cmp	R1
   1983  0bca							;		bne	iRANDOM_1
   1984  0bca							;		lda	R0+1
   1985  0bca							;		cmp	R1+1
   1986  0bca							;		bne	iRANDOM_1	;need to subtract
   1987  0bca							;
   1988  0bca							; Subtract R1 from R0
   1989  0bca							;
   1990  0bca							;iRANDOM_sub	sec
   1991  0bca							;		lda	R0
   1992  0bca							;		sbc	R1
   1993  0bca							;		sta	R0
   1994  0bca							;		lda	R0+1
   1995  0bca							;		sbc	R1+1
   1996  0bca							;		sta	R0+1
   1997  0bca							;		jmp	iRANDOM_2
   1998  0bca							;
   1999  0bca							; See if R1 > R0.  If so, branch to subtract.
   2000  0bca							;
   2001  0bca							;iRANDOM_1	lda	R0
   2002  0bca							;		cmp	R1
   2003  0bca							;		lda	R0+1
   2004  0bca							;		sbc	R1+1
   2005  0bca							;		bvc	iRANDOM_4
   2006  0bca							;		eor	#$80
   2007  0bca							;iRANDOM_4	bpl	iRANDOM_sub
   2008  0bca							;
   2009  0bca							; All done.  Almost.  Add one, then push the result.
   2010  0bca							;
   2011  0bca							;irandom1	inc	R0
   2012  0bca							;		bne	iRANDOM_3
   2013  0bca							;		inc	R0+1
   2014  0bca							;iRANDOM_3
   2015  0bca							;		  jsr	pushR0	;return value
   2016  0bca							;		jmp	NextIL
   2017  0bca							;
   2018  0bca							; Poke a value into a memory location
   2019  0bca		       8c 35 27    iPOKEMEMORY sty	tempy
   2020  0bcd		       20 f2 14 	      jsr	popR0
   2021  0bd0		       20 0a 15 	      jsr	popR1
   2022  0bd3		       a0 00		      ldy	#0
   2023  0bd5		       a5 52		      lda	R0
   2024  0bd7		       91 54		      sta	(R1),y
   2025  0bd9		       ac 35 27 	      ldy	tempy
   2026  0bdc		       4c bb 02 	      jmp	NextIL
   2027  0bdf							;
   2028  0bdf							; Get a value from a memory location
   2029  0bdf							;
   2030  0bdf		       8c 35 27    iPEEKMEMORY sty	tempy
   2031  0be2		       20 f2 14 	      jsr	popR0
   2032  0be5		       a0 00		      ldy	#0
   2033  0be7		       b1 52		      lda	(R0),y
   2034  0be9		       ac 35 27 	      ldy	tempy
   2035  0bec		       85 52		      sta	R0
   2036  0bee		       a9 00		      lda	#0
   2037  0bf0		       85 53		      sta	R0+1
   2038  0bf2		       4c 03 07 	      jmp	pushR0nextIl
   2039  0bf5							;
   2040  0bf5							; Call to address return what ever is in a to the stack
   2041  0bf5							; func2 will load a value into a before the call
   2042  0bf5		       20 0a 15    iCallFunc  jsr	popR1
   2043  0bf8		       a5 54		      lda	R1
   2044  0bfa		       20 06 0c 	      jsr	iCallRtn
   2045  0bfd		       85 52		      sta	R0
   2046  0bff		       a9 00		      lda	#0
   2047  0c01		       85 53		      sta	R0+1
   2048  0c03		       20 03 07 	      jsr	pushR0nextIl
   2049  0c06				   iCallRtn
   2050  0c06		       20 f2 14 	      jsr	popR0
   2051  0c09		       6c 52 00 	      jmp	(R0)
   2052  0c0c
   2053  0c0c
   2054  0c0c							;===========================================jlit======
   2055  0c0c							;Get a character from the terminal convert to value
   2056  0c0c							;leave the number on top of the stack
   2057  0c0c							;
   2058  0c0c				   iGETCHAR
   2059  0c0c		       20 f7 16 	      jsr	VGETCH
   2060  0c0f					      if	CTMON65
   2061  0c0f		       48		      pha
   2062  0c10		       20 f4 16 	      jsr	VOUTCH	;echo echo echo
   2063  0c13		       68		      pla
   2064  0c14					      endif
   2065  0c14		       85 52		      sta	R0
   2066  0c16		       a9 00		      lda	#0
   2067  0c18		       85 53		      sta	R0+1
   2068  0c1a		       20 6e 14 	      jsr	pushR0
   2069  0c1d							;
   2070  0c1d		       4c bb 02 	      jmp	NextIL
   2071  0c20							;===========================================jusilostintim======
   2072  0c20							;Put a character to the terminal convert to
   2073  0c20							;
   2074  0c20		       20 f2 14    iPUTCHAR   jsr	popR0
   2075  0c23		       a5 52		      lda	R0
   2076  0c25		       20 f4 16 	      jsr	VOUTCH
   2077  0c28		       4c bb 02 	      jmp	NextIL
   2078  0c2b							;=====================================================
   2079  0c2b							; Put the number on the stack out as hex, suppress leading 0
   2080  0c2b				   iHexOut
   2081  0c2b		       20 f2 14 	      jsr	popR0
   2082  0c2e		       a5 53		      lda	R0+1
   2083  0c30		       f0 03		      beq	iHexSecondByte
   2084  0c32		       20 99 0d 	      jsr	OUTHEX
   2085  0c35				   iHexSecondByte
   2086  0c35		       a5 52		      lda	R0
   2087  0c37		       20 99 0d 	      jsr	OUTHEX
   2088  0c3a		       4c bb 02 	      jmp	NextIL
   2089  0c3d							;
   2090  0c3d							;=====================================================
   2091  0c3d							; Replace TOS with its absolute value.
   2092  0c3d							;
   2093  0c3d		       20 f2 14    iABS       jsr	popR0
   2094  0c40		       a5 53		      lda	R0+1
   2095  0c42		       10 10		      bpl	iABS_1	;already positive
   2096  0c44		       49 ff		      eor	#$ff
   2097  0c46		       85 53		      sta	R0+1
   2098  0c48		       a5 52		      lda	R0
   2099  0c4a		       49 ff		      eor	#$ff
   2100  0c4c		       85 52		      sta	R0
   2101  0c4e		       e6 52		      inc	R0
   2102  0c50		       d0 02		      bne	iABS_1
   2103  0c52		       e6 53		      inc	R0+1
   2104  0c54		       4c 03 07    iABS_1     jmp	pushR0nextIl
   2105  0c57
   2106  0c57							;
   2107  0c57							;================================================================
   2108  0c57							; The set of logical operators
   2109  0c57				   iLogAnd
   2110  0c57		       20 f2 14 	      jsr	popR0
   2111  0c5a		       20 0a 15 	      jsr	popR1
   2112  0c5d		       a5 52		      lda	R0
   2113  0c5f		       25 54		      and	R1
   2114  0c61		       85 52		      sta	R0
   2115  0c63		       a5 53		      lda	R0+1
   2116  0c65		       25 55		      and	R1+1
   2117  0c67		       85 53		      sta	R0+1
   2118  0c69		       4c 03 07 	      jmp	pushR0nextIl
   2119  0c6c				   iLogOr
   2120  0c6c		       20 f2 14 	      jsr	popR0
   2121  0c6f		       20 0a 15 	      jsr	popR1
   2122  0c72		       a5 52		      lda	R0
   2123  0c74		       05 54		      ora	R1
   2124  0c76		       85 52		      sta	R0
   2125  0c78		       a5 53		      lda	R0+1
   2126  0c7a		       05 55		      ora	R1+1
   2127  0c7c		       85 53		      sta	R0+1
   2128  0c7e		       4c 03 07 	      jmp	pushR0nextIl
   2129  0c81				   iLogXor
   2130  0c81		       20 f2 14 	      jsr	popR0
   2131  0c84		       20 0a 15 	      jsr	popR1
   2132  0c87		       a5 52		      lda	R0
   2133  0c89		       45 54		      eor	R1
   2134  0c8b		       85 52		      sta	R0
   2135  0c8d		       a5 53		      lda	R0+1
   2136  0c8f		       45 55		      eor	R1+1
   2137  0c91		       85 53		      sta	R0+1
   2138  0c93		       4c 03 07 	      jmp	pushR0nextIl
   2139  0c96				   iLogNot
   2140  0c96		       20 f2 14 	      jsr	popR0
   2141  0c99		       a5 52		      lda	R0
   2142  0c9b		       49 ff		      eor	#$FF
   2143  0c9d		       85 52		      sta	R0
   2144  0c9f		       a5 53		      lda	R0+1
   2145  0ca1		       49 ff		      eor	#$FF
   2146  0ca3		       85 53		      sta	R0+1
   2147  0ca5		       4c 03 07 	      jmp	pushR0nextIl
   2148  0ca8
   2149  0ca8				   iTruth
   2150  0ca8		       a9 ff		      lda	#$FF
   2151  0caa		       85 52		      sta	R0
   2152  0cac		       85 53		      sta	R0+1
   2153  0cae		       4c 03 07 	      jmp	pushR0nextIl
   2154  0cb1				   iFalse
   2155  0cb1		       a9 00		      lda	#$00
   2156  0cb3		       85 52		      sta	R0
   2157  0cb5		       85 53		      sta	R0+1
   2158  0cb7		       4c 03 07 	      jmp	pushR0nextIl
   2159  0cba
   2160  0cba							;================================================================
   2161  0cba							;Set the IRQ service rtn line number
   2162  0cba							;
   2163  0cba		       78	   iSetIrq    sei		; disable the interupts
   2164  0cbb		       a9 00		      lda	#0	; Zero the Status flag
   2165  0cbd		       8d e0 1d 	      sta	IRQStatus
   2166  0cc0		       20 f2 14 	      jsr	popR0	; get the line number
   2167  0cc3		       a5 52		      lda	R0
   2168  0cc5		       05 53		      ora	R0+1
   2169  0cc7		       f0 20		      beq	iSetExt	; if it is zero disable all
   2170  0cc9		       20 88 14 	      jsr	pushLN	; Save the current line pointer
   2171  0ccc		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2172  0cce		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   2173  0cd1				   iSetIrqOk
   2174  0cd1		       20 ba 12 	      jsr	findLine	; Find the IRQ func Line Pointer
   2175  0cd4		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2176  0cd6		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2177  0cd8		       8d e3 1d 	      sta	IRQEntry+1
   2178  0cdb		       a5 4f		      lda	CURPTR
   2179  0cdd		       8d e2 1d 	      sta	IRQEntry
   2180  0ce0		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2181  0ce2		       8d e0 1d 	      sta	IRQStatus
   2182  0ce5		       20 ad 14 	      jsr	popLN	; Restore the old line number
   2183  0ce8		       58		      cli		; Enable the interupts
   2184  0ce9		       4c bb 02    iSetExt    jmp	NextIL
   2185  0cec
   2186  0cec		       20 ad 14    iSetIrqErr jsr	popLN
   2187  0cef		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2188  0cf1		       a9 00		      lda	#0
   2189  0cf3		       4c 18 06 	      jmp	iErr2
   2190  0cf6							;
   2191  0cf6		       20 f2 14    iTRACEPROG jsr	popR0
   2192  0cf9		       a5 52		      lda	R0
   2193  0cfb		       85 40		      sta	ILTrace
   2194  0cfd		       4c bb 02 	      jmp	NextIL
   2195  0d00
   2196  0d00							;=====================================================
   2197  0d00							; Define start of non page zero data
   2198 U2747 ????				      seg.u	TBData
   2199 U1dcf					      org	PROGEND
   2200 U1dcf							;=================================================================
   2201 U1dcf							;
------- FILE print.asm LEVEL 2 PASS 6
      0 U1dcf					      include	"print.asm"
      1  0d00					      Seg	Code
      2  0d00							;---------------------------
      3  0d00							; Print 24-bit decimal number, unsigned 16 bit integers as well
      4  0d00							; ---------------------------
      5  0d00							; On entry, R0=number to print
      6  0d00							;	     pad=0 or pad character (eg '0' or ' ')
      7  0d00							; On entry at PrDec24Lp1, positive numbers only
      8  0d00							;	     Y=(number of digits)*3-3, eg 21 for 8 digits
      9  0d00							; On exit,  A,X,Y,num,pad corrupted
     10  0d00							; Size      129 bytes, Table 24 bytes	--- total 153
     11  0d00							; -----------------------------------------------------------------
     12  0d00
     13  0d00				   PrintDecimal
     14  0d00		       a9 00		      lda	#0
     15  0d02		       85 54		      sta	R1
     16  0d04		       8d 80 0d 	      sta	pad
     17  0d07		       a5 58		      lda	R2
     18  0d09		       d0 29		      bne	PrintPos
     19  0d0b
     20  0d0b		       a5 53		      lda	R0+1	;MSB has sign
     21  0d0d		       10 25		      bpl	PrintPos	;it's a positive number;
     22  0d0f
     23  0d0f
     24  0d0f							; Negative numbers need more work.  Invert all the bits,
     25  0d0f							; then add one.
     26  0d0f
     27  0d0f		       a9 2d		      lda	#'-
     28  0d11		       20 f4 16 	      jsr	VOUTCH	;print the negative sign
     29  0d14
     30  0d14		       a9 ff		      lda	#$FF
     31  0d16		       85 54		      sta	R1
     32  0d18		       a5 52		      lda	R0	;invert bits
     33  0d1a		       49 ff		      eor	#$ff
     34  0d1c		       85 52		      sta	R0
     35  0d1e		       a5 53		      lda	R0+1
     36  0d20		       49 ff		      eor	#$ff
     37  0d22		       85 53		      sta	R0+1
     38  0d24		       a5 54		      lda	R1
     39  0d26		       49 ff		      eor	#$ff
     40  0d28		       85 54		      sta	R1
     41  0d2a		       e6 52		      inc	R0	;add one
     42  0d2c		       d0 06		      bne	PrintPos
     43  0d2e		       e6 53		      inc	R0+1
     44  0d30		       d0 02		      bne	PrintPos
     45  0d32		       e6 54		      inc	R1
     46  0d34				   PrintPos
     47  0d34		       a0 15		      LDY	#21	; Offset to powers of ten
     48  0d36				   PrDec24Lp1
     49  0d36		       a2 ff		      LDX	#$FF
     50  0d38		       38		      SEC		; Start with digit=-1
     51  0d39				   PrDec24Lp2
     52  0d39		       a5 52		      LDA	R0+0
     53  0d3b		       f9 81 0d 	      SBC	PrDec24Tens+0,Y
     54  0d3e		       85 52		      STA	R0+0	; Subtract current tens
     55  0d40		       a5 53		      LDA	R0+1
     56  0d42		       f9 82 0d 	      SBC	PrDec24Tens+1,Y
     57  0d45		       85 53		      STA	R0+1
     58  0d47		       a5 54		      LDA	R0+2
     59  0d49		       f9 83 0d 	      SBC	PrDec24Tens+2,Y
     60  0d4c		       85 54		      STA	R0+2
     61  0d4e		       e8		      INX
     62  0d4f		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     63  0d51		       a5 52		      LDA	R0+0
     64  0d53		       79 81 0d 	      ADC	PrDec24Tens+0,Y
     65  0d56		       85 52		      STA	R0+0	; Add current tens back in
     66  0d58		       a5 53		      LDA	R0+1
     67  0d5a		       79 82 0d 	      ADC	PrDec24Tens+1,Y
     68  0d5d		       85 53		      STA	R0+1
     69  0d5f		       a5 54		      LDA	R0+2
     70  0d61		       79 83 0d 	      ADC	PrDec24Tens+2,Y
     71  0d64		       85 54		      STA	R0+2
     72  0d66		       8a		      TXA
     73  0d67		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     74  0d69		       ad 80 0d 	      LDA	pad
     75  0d6c		       d0 09		      BNE	PrDec24Print
     76  0d6e		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     77  0d70				   PrDec24Digit
     78  0d70		       a2 30		      LDX	#'0
     79  0d72		       8e 80 0d 	      STX	pad	; No more zero padding
     80  0d75		       09 30		      ORA	#'0	; Print this digit
     81  0d77				   PrDec24Print
     82  0d77		       20 f4 16 	      JSR	VOUTCH
     83  0d7a				   PrDec24Next
     84  0d7a		       88		      DEY
     85  0d7b		       88		      DEY
     86  0d7c		       88		      DEY
     87  0d7d		       10 b7		      BPL	PrDec24Lp1	; Loop for next digit
     88  0d7f		       60		      RTS
      0  0d80				   pad	      db	0
      1  0d80		       00		      .byte.b	0
     90  0d81				   PrDec24Tens
      0  0d81					      dw	1
      1  0d81		       01 00		      .word.w	1
      0  0d83					      db	1 / 65536
      1  0d83		       00		      .byte.b	1 / 65536
      0  0d84					      dw	10
      1  0d84		       0a 00		      .word.w	10
      0  0d86					      db	10 / 65536
      1  0d86		       00		      .byte.b	10 / 65536
      0  0d87					      dw	100
      1  0d87		       64 00		      .word.w	100
      0  0d89					      db	100 / 65536
      1  0d89		       00		      .byte.b	100 / 65536
      0  0d8a					      dw	1000
      1  0d8a		       e8 03		      .word.w	1000
      0  0d8c					      db	1000 / 65536
      1  0d8c		       00		      .byte.b	1000 / 65536
      0  0d8d					      dw	10000
      1  0d8d		       10 27		      .word.w	10000
      0  0d8f					      db	10000 / 65536
      1  0d8f		       00		      .byte.b	10000 / 65536
      0  0d90					      dw	100000
      1  0d90		       a0 86		      .word.w	100000
      0  0d92					      db	100000 / 65536
      1  0d92		       01		      .byte.b	100000 / 65536
      0  0d93					      dw	1000000
      1  0d93		       40 42		      .word.w	1000000
      0  0d95					      db	1000000 / 65536
      1  0d95		       0f		      .byte.b	1000000 / 65536
      0  0d96					      dw	10000000
      1  0d96		       80 96		      .word.w	10000000
      0  0d98					      db	10000000 / 65536
      1  0d98		       98		      .byte.b	10000000 / 65536
    107  0d99							;=====================================================
    108  0d99							; Print character in A as two hex digits to the
    109  0d99
    110  0d99		       48	   HexToOut   pha		;save return value
    111  0d9a		       48		      pha
    112  0d9b		       4a		      lsr		;a  ;move top nibble to bottom
    113  0d9c		       4a		      lsr		;a
    114  0d9d		       4a		      lsr		;a
    115  0d9e		       4a		      lsr		;a
    116  0d9f		       20 a8 0d 	      jsr	hexta	;output nibble
    117  0da2		       68		      pla
    118  0da3		       20 a8 0d 	      jsr	hexta
    119  0da6		       68		      pla		;restore
    120  0da7		       60		      rts
    121  0da8							;
    122  0da8		       29 0f	   hexta      and	#%0001111
    123  0daa		       c9 0a		      cmp	#$0a
    124  0dac		       18		      clc
    125  0dad		       30 02		      bmi	hexta1
    126  0daf		       69 07		      adc	#7
    127  0db1		       69 30	   hexta1     adc	#'0	;then fall into...
    128  0db3		       4c f4 16 	      jmp	VOUTCH
    129  0db6							;
    130  0db6							;==================================================================================================
    131  0db6							; Size of print functions
    132  0db6		       00 b6	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  0db6					      include	"mem.asm"
      1  0db6							;===================================================================
      2  0db6							;This file contains the memory allocation and free functions
      3  0db6							;in herant in this is the management of free memory in the system
      4  0db6							; the interface to these functions
      5  0db6							; a,x returns or provides the low hi bytes of the managed addresses
      6  0db6							; This uses the programend, to memory end as the area to manage
      7  0db6							;===================================================================
      8  0db6					      Seg	Code
      9  0db6							;=====================================================
     10  0db6							;Pointers for memory Management
     11  0db6							;Allocated block are not chained but can be followed for all memory by the associated length
     12  0db6							; Mem block format is
     13  0db6							;	 0-1   pointer to next block for free blocks
     14  0db6							;	 0-1   for allocated blocks
     15  0db6							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  0db6							;	   1   refrence counter ... lol only up to 256 but it is something
     17  0db6							;	 2-3   length constant for exevy type of memory block
     18  0db6							; Memory is recombined as it is released
     19  0db6							; The memory manager is not interupted durring allocation
     20  0db6							; or freeing of memory
     21  0db6							; Memory is allocated from the highest memory address towards
     22  0db6							; the lowest memory address. meeting the Basic program end.
     23  0db6							;====================================================
     24  0db6							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  0db6							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  0db6							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  0db6							;=====================================================
     28  0db6				   MemInit
     29  0db6		       a9 47		      lda	#FreeMemStart&$FF
     30  0db8		       8d 3d 27 	      sta	ProgramStart
     31  0dbb		       8d 3f 27 	      sta	ProgramEnd
     32  0dbe		       a9 27		      lda	#FreeMemStart>>8
     33  0dc0		       8d 3e 27 	      sta	ProgramStart+1
     34  0dc3		       8d 40 27 	      sta	ProgramEnd+1
     35  0dc6
     36  0dc6		       20 d0 0d 	      jsr	GetSizes
     37  0dc9		       20 db 0d 	      jsr	MemFree
     38  0dcc		       20 f3 0d 	      jsr	MemUsed
     39  0dcf				   MemInitEnd
     40  0dcf		       60		      rts
     41  0dd0
     42  0dd0
     43  0dd0							;
     44  0dd0							;=====================================================
     45  0dd0							; This function might go away eventually, but was
     46  0dd0							; added to provide data for other pieces of code.
     47  0dd0							; It has some ties to the operating environment that
     48  0dd0							; will need to be customized for the target system.
     49  0dd0							;
     50  0dd0				   GetSizes
     51  0dd0							;
     52  0dd0							; Here is machine specific code to get the highest
     53  0dd0							; memory location that can be used by BASIC.
     54  0dd0							;
     55  0dd0				  -	      if	ProgramStart < $2000
     56  0dd0				  -	      lda	#$ff
     57  0dd0				  -	      sta	HighMem	;$13ff for KIM-1
     58  0dd0				  -	      sta	MemFreeList
     59  0dd0				  -	      lda	#$DE	;#$13
     60  0dd0				  -	      sta	HighMem+1
     61  0dd0				  -	      sta	MemFreeList+1
     62  0dd0					      else
     63  0dd0		       a9 ff		      lda	#$ff
     64  0dd2		       8d 41 27 	      sta	HighMem	;$CFFF otherwise
     65  0dd5		       a9 cf		      lda	#$cf
     66  0dd7		       8d 42 27 	      sta	HighMem+1
     67  0dda					      endif
     68  0dda		       60		      rts
     69  0ddb							;
     70  0ddb							; This computes the available memory remaining.
     71  0ddb							;
     72  0ddb				   MemFree
     73  0ddb		       38		      sec
     74  0ddc		       ad 41 27 	      lda	HighMem
     75  0ddf		       ed 3f 27 	      sbc	ProgramEnd
     76  0de2		       8d 45 27 	      sta	FreeMem
     77  0de5		       85 52		      sta	R0
     78  0de7		       ad 42 27 	      lda	HighMem+1
     79  0dea		       ed 40 27 	      sbc	ProgramEnd+1
     80  0ded		       8d 46 27 	      sta	FreeMem+1
     81  0df0		       85 53		      sta	R0+1
     82  0df2		       60		      rts
     83  0df3							;
     84  0df3							; This computes the size of the current user program.
     85  0df3							;
     86  0df3				   MemUsed
     87  0df3		       38		      sec
     88  0df4		       ad 3f 27 	      lda	ProgramEnd
     89  0df7		       ed 3d 27 	      sbc	ProgramStart
     90  0dfa		       8d 43 27 	      sta	UsedMem
     91  0dfd		       85 52		      sta	R0
     92  0dff		       ad 40 27 	      lda	ProgramEnd+1
     93  0e02		       ed 3e 27 	      sbc	ProgramStart+1
     94  0e05		       8d 44 27 	      sta	UsedMem+1
     95  0e08		       85 53		      sta	R0+1
     96  0e0a							;
     97  0e0a		       60		      rts
     98  0e0b
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  0e0b					      include	"gosub.asm"
      1  0e0b					      seg	Code
      2  0e0b
      3  0e0b							; Gosub and return related functions
      4  0e0b							;==========================================================
      5  0e0b							; Push the current math stack frame onto the gosub stack
      6  0e0b				   iPushMathStack
      7  0e0b		       98		      tya
      8  0e0c		       48		      pha
      9  0e0d		       a4 4d		      ldy	GOSUBSTACKPTR
     10  0e0f		       a5 4a		      lda	MATHSTACKPTR
     11  0e11		       91 4b		      sta	(GOSUBSTACK),y
     12  0e13		       a9 00		      lda	#0
     13  0e15		       c8		      iny
     14  0e16		       91 4b		      sta	(GOSUBSTACK),y
     15  0e18		       c8		      iny
     16  0e19		       91 4b		      sta	(GOSUBSTACK),y
     17  0e1b		       c8		      iny
     18  0e1c		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  0e1e		       91 4b		      sta	(GOSUBSTACK),y
     20  0e20		       c8		      iny
     21  0e21		       84 4d		      sty	GOSUBSTACKPTR
     22  0e23		       68		      pla
     23  0e24		       a8		      tay
     24  0e25		       4c bb 02 	      jmp	NextIL
     25  0e28							;
     26  0e28							;==========================================================
     27  0e28							; Increment parameter count. Assume Stack frame is top of stack
     28  0e28				   iIncParmCount
     29  0e28		       98		      tya
     30  0e29		       48		      pha
     31  0e2a		       a4 4d		      ldy	GOSUBSTACKPTR
     32  0e2c		       88		      dey
     33  0e2d		       88		      dey
     34  0e2e		       88		      dey
     35  0e2f		       b1 4b		      lda	(GOSUBSTACK),y
     36  0e31		       aa		      tax
     37  0e32		       e8		      inx
     38  0e33		       8a		      txa
     39  0e34		       91 4b		      sta	(GOSUBSTACK),y
     40  0e36		       68		      pla
     41  0e37		       a8		      tay
     42  0e38		       4c bb 02 	      jmp	NextIL
     43  0e3b							;
     44  0e3b							;==========================================================
     45  0e3b							;Restore the math stack frame
     46  0e3b		       20 41 0e    iPopMathStack jsr	PopMathStackNow
     47  0e3e		       4c bb 02 	      jmp	NextIL
     48  0e41
     49  0e41				   PopMathStackNow
     50  0e41		       98		      tya
     51  0e42		       48		      pha
     52  0e43
     53  0e43		       a4 4d		      ldy	GOSUBSTACKPTR
     54  0e45		       88		      dey
     55  0e46		       b1 4b		      lda	(GOSUBSTACK),y
     56  0e48		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  0e4a		       d0 09		      bne	iPopMathStackNoFrame
     58  0e4c		       88		      dey
     59  0e4d		       88		      dey
     60  0e4e		       88		      dey
     61  0e4f		       b1 4b		      lda	(GOSUBSTACK),y
     62  0e51		       85 4a		      sta	MATHSTACKPTR
     63  0e53		       84 4d		      sty	GOSUBSTACKPTR
     64  0e55
     65  0e55				   iPopMathStackNoFrame
     66  0e55
     67  0e55		       68		      pla
     68  0e56		       a8		      tay
     69  0e57		       60		      rts
     70  0e58
     71  0e58
     72  0e58							;==========================================================
     73  0e58							; Push the current math stack information onto the gosub stack
     74  0e58				   iSaveMathStack
     75  0e58		       98		      tya
     76  0e59		       48		      pha
     77  0e5a		       a4 4d		      ldy	GOSUBSTACKPTR
     78  0e5c		       a5 4a		      lda	MATHSTACKPTR
     79  0e5e		       91 4b		      sta	(GOSUBSTACK),y
     80  0e60		       a5 48		      lda	MATHSTACK
     81  0e62		       c8		      iny
     82  0e63
     83  0e63		       91 4b		      sta	(GOSUBSTACK),y
     84  0e65		       c8		      iny
     85  0e66
     86  0e66		       a5 49		      lda	MATHSTACK+1
     87  0e68		       91 4b		      sta	(GOSUBSTACK),y
     88  0e6a		       c8		      iny
     89  0e6b
     90  0e6b		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  0e6d		       91 4b		      sta	(GOSUBSTACK),y
     92  0e6f		       c8		      iny
     93  0e70
     94  0e70		       84 4d		      sty	GOSUBSTACKPTR
     95  0e72		       68		      pla
     96  0e73		       a8		      tay
     97  0e74		       4c bb 02 	      jmp	NextIL
     98  0e77							;
     99  0e77							;==========================================================
    100  0e77							;Restore the math stack information from the gosub stack
    101  0e77				   iRestoreMathStack
    102  0e77		       98		      tya
    103  0e78		       48		      pha
    104  0e79
    105  0e79		       a5 4a		      lda	MATHSTACKPTR
    106  0e7b		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  0e7d
    108  0e7d		       a4 4d		      ldy	GOSUBSTACKPTR
    109  0e7f		       88		      dey
    110  0e80		       b1 4b		      lda	(GOSUBSTACK),y
    111  0e82		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  0e84		       d0 16		      bne	iPopMathStack_Err
    113  0e86		       88		      dey
    114  0e87		       b1 4b		      lda	(GOSUBSTACK),y
    115  0e89		       85 49		      sta	MATHSTACK+1
    116  0e8b		       88		      dey
    117  0e8c		       b1 4b		      lda	(GOSUBSTACK),y
    118  0e8e		       85 48		      sta	MATHSTACK
    119  0e90		       88		      dey
    120  0e91		       b1 4b		      lda	(GOSUBSTACK),y
    121  0e93		       85 4a		      sta	MATHSTACKPTR
    122  0e95		       84 4d		      sty	GOSUBSTACKPTR
    123  0e97		       68		      pla
    124  0e98		       a8		      tay
    125  0e99		       4c bb 02 	      jmp	NextIL
    126  0e9c
    127  0e9c				   iPopMathStack_Err
    128  0e9c		       a9 00		      lda	#0
    129  0e9e		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  0ea0		       4c 18 06 	      jmp	iErr2
    131  0ea3							;=========================================
    132  0ea3							; For functions and tasks the variable address of # means
    133  0ea3							; a passed parameter so #[0] is the first parameter etc
    134  0ea3							; will try for a better way later
    135  0ea3
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  0ea3					      include	"tasks.asm"
      1  0ea3							;=====================================================
      2  0ea3							; Tiny Basic IL task management
      3  0ea3							; Data required by task management
      4  0ea3							; currently each context is about 30 bytes and is swapped
      5  0ea3							; into and out of page zero on each task switch....
      6  0ea3							; LOL yes it is slow, but works for this iteration.
      7  0ea3							;
      8  0ea3
      9  0ea3					      Seg	Code
     10  0ea3							;=====================================================
     11  0ea3							; Sets the pointers to the math,IL and gosub stacks
     12  0ea3							; Creates the initial Context for each task slot
     13  0ea3				   taskSetStacks
     14  0ea3		       a9 e4		      lda	#mathStack&$FF
     15  0ea5		       85 48		      sta	MATHSTACK
     16  0ea7		       a9 1e		      lda	#mathStack>>8
     17  0ea9		       85 49		      sta	MATHSTACK+1
     18  0eab
     19  0eab		       a9 74		      lda	#ilStack&$ff
     20  0ead		       85 45		      sta	ILSTACK
     21  0eaf		       a9 20		      lda	#ilStack>>8
     22  0eb1		       85 46		      sta	ILSTACK+1
     23  0eb3
     24  0eb3		       a9 04		      lda	#gosubStack&$FF
     25  0eb5		       85 4b		      sta	GOSUBSTACK
     26  0eb7		       a9 22		      lda	#gosubStack>>8
     27  0eb9		       85 4c		      sta	GOSUBSTACK+1
     28  0ebb
     29  0ebb		       a9 84		      lda	#variableStack&$FF
     30  0ebd		       85 41		      sta	VARIABLES
     31  0ebf		       a9 24		      lda	#variableStack>>8
     32  0ec1		       85 42		      sta	VARIABLES+1
     33  0ec3		       a2 0a		      ldx	#TASKCOUNT
     34  0ec5		       a0 00		      ldy	#0
     35  0ec7		       20 52 11 	      jsr	ContextSave
     36  0eca
     37  0eca		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  0ecc		       b0 3a		      bcs	taskSetDone
     39  0ece
     40  0ece		       a5 4b		      lda	GOSUBSTACK
     41  0ed0		       18		      clc
     42  0ed1		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  0ed3		       85 4b		      sta	GOSUBSTACK
     44  0ed5		       a5 4c		      lda	GOSUBSTACK+1
     45  0ed7		       69 00		      adc	#0
     46  0ed9		       85 4c		      sta	GOSUBSTACK+1
     47  0edb
     48  0edb		       a5 45		      lda	ILSTACK	; must be less than 256
     49  0edd		       18		      clc
     50  0ede		       69 28		      adc	#ILSTACKSIZE*2
     51  0ee0		       85 45		      sta	ILSTACK
     52  0ee2		       a5 46		      lda	ILSTACK+1
     53  0ee4		       69 00		      adc	#0
     54  0ee6		       85 46		      sta	ILSTACK+1
     55  0ee8
     56  0ee8		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  0eea		       18		      clc
     58  0eeb		       69 28		      adc	#MATHSTACKSIZE*2
     59  0eed		       85 48		      sta	MATHSTACK
     60  0eef		       a5 49		      lda	MATHSTACK+1
     61  0ef1		       69 00		      adc	#0
     62  0ef3		       85 49		      sta	MATHSTACK+1
     63  0ef5
     64  0ef5		       a5 41		      lda	VARIABLES	; must be less than 256
     65  0ef7		       18		      clc
     66  0ef8		       69 36		      adc	#VARIABLESSIZE*2
     67  0efa		       85 41		      sta	VARIABLES
     68  0efc		       a5 42		      lda	VARIABLES+1
     69  0efe		       69 00		      adc	#0
     70  0f00		       85 42		      sta	VARIABLES+1
     71  0f02
     72  0f02		       20 52 11 	      jsr	ContextSave
     73  0f05		       4c ca 0e 	      jmp	taskSetLoop
     74  0f08
     75  0f08				   taskSetDone
     76  0f08		       a0 00		      ldy	#0	; reload the main loop context
     77  0f0a		       20 61 11 	      jsr	ContextLoad
     78  0f0d		       60		      rts
     79  0f0e							;
     80  0f0e							;=====================================================
     81  0f0e							; In some error cases the math stacks may be left pointing to the wrong stack
     82  0f0e							; This function will reset those stack addresses but not the actual pointer
     83  0f0e				   taskResetStacks
     84  0f0e		       a0 00		      ldy	#0
     85  0f10		       20 61 11 	      jsr	ContextLoad
     86  0f13		       4c a3 0e 	      jmp	taskSetStacks
     87  0f16							;
     88  0f16							;=====================================================
     89  0f16							; Clear all task entries and task stacks
     90  0f16		       98	   taskReset  tya		; Save Y
     91  0f17		       48		      pha
     92  0f18		       a9 01		      lda	#1
     93  0f1a		       8d e3 1e 	      sta	taskCounter	; Set number of active tasks to 1
     94  0f1d		       ac e4 1d 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  0f20		       c0 00		      cpy	#0	; check if we are the main context
     96  0f22		       f0 08		      beq	taskResetCont	; if we are just continue
     97  0f24
     98  0f24		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  0f26		       8c e4 1d 	      sty	taskPtr
    100  0f29		       20 61 11 	      jsr	ContextLoad	; load the System Task context
    101  0f2c				   taskResetCont
    102  0f2c		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  0f2e
    104  0f2e				   taskResetLoop
    105  0f2e		       a9 00		      lda	#TASKINACTIVE
    106  0f30		       99 e5 1d 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  0f33		       18		      clc
    108  0f34		       98		      tya
    109  0f35		       69 19		      adc	#CONTEXTLEN+1
    110  0f37		       a8		      tay
    111  0f38		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  0f3a		       90 f2		      bcc	taskResetLoop	; Go for more
    113  0f3c
    114  0f3c				   taskResetComplete
    115  0f3c
    116  0f3c		       68		      pla		; Restore y
    117  0f3d		       a8		      tay
    118  0f3e		       60		      rts
    119  0f3f
    120  0f3f							;
    121  0f3f							;======================================================
    122  0f3f							; iTaskSwitch	 switch to new task if not interrupt and
    123  0f3f							;		 count is exceded for task time slice gets here
    124  0f3f							;		 when time slice has reached zero
    125  0f3f							;
    126  0f3f		       98	   iTaskSwitch tya
    127  0f40		       48		      pha
    128  0f41
    129  0f41		       ad e1 1e 	      lda	taskResetValue	; Always reset the counter value
    130  0f44		       8d df 1e 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  0f47		       ce e0 1e 	      dec	taskCurrentCycles+1	; dec high order byte
    132  0f4a		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  0f4c
    134  0f4c		       ad e2 1e 	      lda	taskResetValue+1
    135  0f4f		       8d e0 1e 	      sta	taskCurrentCycles+1
    136  0f52
    137  0f52		       ad e1 1d 	      lda	IRQPending	; Skip this if we are processing an irq
    138  0f55		       0d 3b 27 	      ora	taskIOPending	; If set then don't switch
    139  0f58		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  0f5a
    141  0f5a		       ad e3 1e    iTaskMain  lda	taskCounter	; Number of tasks
    142  0f5d		       c9 01		      cmp	#1	; if there is only one task must be main
    143  0f5f		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  0f61
    145  0f61		       ac e4 1d 	      ldy	taskPtr	; check if we have not just ended some other task
    146  0f64		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  0f66		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  0f68							;
    149  0f68							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  0f68							;
    151  0f68				   itasknext
    152  0f68		       ac e4 1d 	      ldy	taskPtr
    153  0f6b		       20 52 11 	      jsr	ContextSave	; Save the current context, y points to next context
    154  0f6e				   itaskLoop
    155  0f6e		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  0f70		       90 04		      bcc	iTaskNextChk
    157  0f72
    158  0f72		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  0f74		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  0f76
    161  0f76				   iTaskNextChk
    162  0f76		       b9 e5 1d 	      lda	taskTable,y	; there is always at least one entry in table
    163  0f79		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  0f7b		       18	   iTaskNext  clc
    165  0f7c		       98		      tya
    166  0f7d		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  0f7f		       a8		      tay
    168  0f80		       4c 6e 0f 	      jmp	itaskLoop	; Check for busy entry
    169  0f83
    170  0f83		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  0f85		       59 e5 1d 	      eor	taskTable,y	; Check for anything waiting io
    172  0f88		       d0 f1		      bne	iTaskNext
    173  0f8a		       20 61 11 	      jsr	ContextLoad	; load the next context
    174  0f8d		       8c e4 1d 	      sty	taskPtr	; update the task pointer
    175  0f90
    176  0f90				   iTaskSwitchDone
    177  0f90		       68		      pla
    178  0f91		       a8		      tay
    179  0f92		       60		      rts
    180  0f93							;
    181  0f93							;================================================================
    182  0f93							; Task Set task number to line number to start
    183  0f93							; Task Table structure:
    184  0f93							;    byte 0	-   Active inactive
    185  0f93							;    byte 1-2	-   Basic code line pointer
    186  0f93							;    byte 3	-   Offset on current line
    187  0f93		       98	   iTaskSet   tya		;preserve Y
    188  0f94		       48		      pha		; push a
    189  0f95
    190  0f95		       20 f2 14 	      jsr	popR0	; Get the line number to be saved
    191  0f98
    192  0f98		       ac e4 1d 	      ldy	taskPtr	; find out where we are
    193  0f9b		       20 52 11 	      jsr	ContextSave	; Save the current context
    194  0f9e
    195  0f9e							;Find the pointer to the line we need to start at
    196  0f9e		       20 ba 12 	      jsr	findLine	; Get the offset of the line to start task at
    197  0fa1		       f0 0b		      beq	iTaskCont
    198  0fa3
    199  0fa3		       ac e4 1d 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  0fa6		       20 61 11 	      jsr	ContextLoad
    201  0fa9
    202  0fa9		       68		      pla		; pop a - exit
    203  0faa		       a8		      tay
    204  0fab		       4c ec 0c 	      jmp	iSetIrqErr	; Bad line number provided
    205  0fae
    206  0fae				   iTaskCont
    207  0fae		       20 24 11 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  0fb1		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  0fb3
    210  0fb3		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  0fb5		       99 e5 1d 	      sta	taskTable,y	; new task as active
    212  0fb8
    213  0fb8		       a5 4f		      lda	CURPTR
    214  0fba		       48		      pha		; push a
    215  0fbb		       a5 50		      lda	CURPTR+1
    216  0fbd		       48		      pha		; push a
    217  0fbe
    218  0fbe		       20 61 11 	      jsr	ContextLoad	; load the context of the new task
    219  0fc1
    220  0fc1		       68		      pla		; pop a
    221  0fc2		       85 50		      sta	CURPTR+1
    222  0fc4		       68		      pla		; pop a
    223  0fc5		       85 4f		      sta	CURPTR
    224  0fc7		       a9 03		      lda	#3	; Offset to first instruction
    225  0fc9		       85 51		      sta	CUROFF
    226  0fcb
    227  0fcb		       a9 00		      lda	#0
    228  0fcd		       85 47		      sta	ILSTACKPTR
    229  0fcf		       85 4a		      sta	MATHSTACKPTR
    230  0fd1		       85 4d		      sta	GOSUBSTACKPTR
    231  0fd3		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  0fd5		       85 4e		      sta	MESSAGEPTR
    233  0fd7
    234  0fd7		       20 49 09 	      jsr	subVINIT	; Clear the variables
    235  0fda
    236  0fda		       a9 12		      lda	#STMT&$FF
    237  0fdc		       85 43		      sta	ILPC
    238  0fde		       a9 19		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  0fe0		       85 44		      sta	ILPC+1
    240  0fe2
    241  0fe2		       98		      tya		; Save the new context offset to return to user
    242  0fe3		       48		      pha		; push a
    243  0fe4
    244  0fe4		       20 52 11    itaskSetSave jsr	ContextSave	; save the updated context
    245  0fe7		       ee e3 1e 	      inc	taskCounter	; Update the number of Tasks running
    246  0fea
    247  0fea		       ac e4 1d 	      ldy	taskPtr
    248  0fed		       20 61 11 	      jsr	ContextLoad	; restore the original context
    249  0ff0
    250  0ff0		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  0ff2		       85 53		      sta	R0+1
    252  0ff4		       68		      pla		; Get the task pid we stored				 ; pop a
    253  0ff5		       85 52		      sta	R0	; Get the table entry value
    254  0ff7
    255  0ff7		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  0ff8		       a8		      tay
    257  0ff9
    258  0ff9		       4c 03 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  0ffc				   iTaskNoEmpty
    260  0ffc		       ac e4 1d 	      ldy	taskPtr
    261  0fff		       20 61 11 	      jsr	ContextLoad
    262  1002
    263  1002		       68		      pla		; pop a    -- exit
    264  1003		       a8		      tay
    265  1004
    266  1004		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  1006		       a9 00		      lda	#0
    268  1008		       4c 18 06 	      jmp	iErr2
    269  100b							;
    270  100b							;===============================================================
    271  100b							; Run the task whos PID is on the stack, preserve the stack
    272  100b							;
    273  100b				   iTaskEnable
    274  100b		       98		      tya
    275  100c		       48		      pha
    276  100d		       20 0a 15 	      jsr	popR1
    277  1010		       20 d8 14 	      jsr	pushR1
    278  1013		       20 58 12 	      jsr	ipc_getcontext	; get context pointer into mq
    279  1016		       a0 00		      ldy	#0
    280  1018		       b1 56		      lda	(MQ),y
    281  101a		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  101c		       09 80		      ora	#TASKACTIVE
    283  101e		       91 56		      sta	(MQ),y
    284  1020		       68		      pla
    285  1021		       a8		      tay
    286  1022		       4c bb 02 	      jmp	NextIL
    287  1025
    288  1025							;
    289  1025							;===============================================================
    290  1025							; Suspend the task whos PID  is on the stack, preserve the stack
    291  1025							;
    292  1025				   iTaskSuspend
    293  1025		       98		      tya
    294  1026		       48		      pha
    295  1027		       20 0a 15 	      jsr	popR1
    296  102a		       20 d8 14 	      jsr	pushR1
    297  102d		       20 58 12 	      jsr	ipc_getcontext	; get context pointer into mq
    298  1030		       a0 00		      ldy	#0
    299  1032		       b1 56		      lda	(MQ),y
    300  1034		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  1036		       09 80		      ora	#TASKACTIVE
    302  1038		       68		      pla
    303  1039		       a8		      tay
    304  103a		       4c bb 02 	      jmp	NextIL
    305  103d
    306  103d							;================================================================
    307  103d							; Returns task Status
    308  103d				   iTaskStat
    309  103d		       98		      tya
    310  103e		       48		      pha
    311  103f		       20 51 10 	      jsr	iTaskValid	; returns pointer to task entry
    312  1042		       b9 e5 1d 	      lda	taskTable,y
    313  1045		       f0 05		      beq	iTaskStatExit
    314  1047		       68		      pla
    315  1048		       a8		      tay
    316  1049		       4c a8 0c 	      jmp	iTruth
    317  104c				   iTaskStatExit
    318  104c		       68		      pla
    319  104d		       a8		      tay
    320  104e		       4c b1 0c 	      jmp	iFalse
    321  1051
    322  1051							;
    323  1051							;================================================================
    324  1051							; Validate the task number on top of the stack
    325  1051							; on exit y points to the requested task entry
    326  1051							;
    327  1051		       20 f2 14    iTaskValid jsr	popR0	; get result of the multiply
    328  1054		       a5 53		      lda	R0+1
    329  1056		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  1058		       a5 52		      lda	R0
    331  105a		       c9 fa		      cmp	#TASKTABLELEN
    332  105c		       90 09		      bcc	iTaskIsValid
    333  105e
    334  105e		       68	   iTaskValidErr pla		;remove return address
    335  105f		       68		      pla
    336  1060		       a2 10		      ldx	#ERR_INVALID_PID
    337  1062		       a9 00		      lda	#0
    338  1064		       4c 18 06 	      jmp	iErr2
    339  1067
    340  1067		       a8	   iTaskIsValid tay
    341  1068		       60		      rts
    342  1069							;
    343  1069							;================================================================
    344  1069							; Kill a running task, do nothing if already stopped
    345  1069		       20 51 10    iTaskKill  jsr	iTaskValid
    346  106c		       a9 00		      lda	#0
    347  106e		       99 e5 1d 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  1071							;
    349  1071							;================================================================
    350  1071							;Skip to next task
    351  1071				   iNTask
    352  1071		       a9 01		      lda	#1
    353  1073		       8d df 1e 	      sta	taskCurrentCycles
    354  1076		       8d e0 1e 	      sta	taskCurrentCycles+1
    355  1079		       4c bb 02 	      jmp	NextIL
    356  107c							;
    357  107c							;=======================================================
    358  107c							; Wait for a task to complete
    359  107c				   iWTASK
    360  107c		       20 75 12 	      jsr	getILByte
    361  107f		       8d 39 27 	      sta	offset
    362  1082							;
    363  1082		       20 58 14 	      jsr	saveIL	;in case of failure
    364  1085
    365  1085		       20 51 10 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  1088		       b9 e5 1d 	      lda	taskTable,y
    367  108b		       d0 03		      bne	iWTASKWAIT
    368  108d				   iWTASKEXITED
    369  108d		       4c bb 02 	      jmp	NextIL
    370  1090				   iWTASKWAIT
    371  1090		       20 6e 14 	      jsr	pushR0	; Push R0 back onto the stack
    372  1093		       a9 01		      lda	#1
    373  1095		       8d df 1e 	      sta	taskCurrentCycles	; Give up the cycles
    374  1098		       8d e0 1e 	      sta	taskCurrentCycles+1
    375  109b		       20 63 14 	      jsr	restoreIL
    376  109e		       4c 0c 0b 	      jmp	tstBranch
    377  10a1							;
    378  10a1							;=======================================================
    379  10a1							; Set task io lock
    380  10a1		       ee 3b 27    iStartIO   inc	taskIOPending
    381  10a4		       4c bb 02 	      jmp	NextIL
    382  10a7							;
    383  10a7							;=======================================================
    384  10a7							; Release the io lock
    385  10a7		       ad 3b 27    iEndIO     lda	taskIOPending
    386  10aa		       f0 03		      beq	iEndIOExit
    387  10ac		       ce 3b 27 	      dec	taskIOPending
    388  10af		       4c bb 02    iEndIOExit jmp	NextIL
    389  10b2							;
    390  10b2							;===============================================================
    391  10b2							; Return the task PID
    392  10b2				   iTASKPID
    393  10b2		       a9 00		      lda	#0
    394  10b4		       85 53		      sta	R0+1
    395  10b6		       ad e4 1d 	      lda	taskPtr
    396  10b9		       85 52		      sta	R0
    397  10bb		       4c 03 07 	      jmp	pushR0nextIl
    398  10be							;
    399  10be							;================================================================
    400  10be							; Terminate a task
    401  10be		       ac e4 1d    iETask     ldy	taskPtr
    402  10c1		       c0 00		      cpy	#0
    403  10c3		       d0 03		      bne	iETaskCont
    404  10c5		       4c 01 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  10c8				   iETaskCont
    406  10c8		       a9 00		      lda	#TASKINACTIVE
    407  10ca		       99 e5 1d 	      sta	taskTable,y	; mark entry as free
    408  10cd		       ce e3 1e 	      dec	taskCounter	; reduce the number of active tasks
    409  10d0		       a9 01		      lda	#1
    410  10d2		       8d df 1e 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  10d5		       8d e0 1e 	      sta	taskCurrentCycles+1
    412  10d8		       20 3f 11 	      jsr	TaskSetExitCode
    413  10db				   iETaskExit
    414  10db		       4c bb 02 	      jmp	NextIL
    415  10de							;================================================================
    416  10de							; make the current tasks math stack equal another tasks stack
    417  10de							; The task to get is stored on the math stack
    418  10de
    419  10de				   iTaskGetMathStack
    420  10de		       20 6c 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  10e1		       20 58 12 	      jsr	ipc_getcontext	; MQ now has the context address
    422  10e4		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  10e6		       b1 56		      lda	(MQ),y
    424  10e8		       85 4a		      sta	MATHSTACKPTR
    425  10ea		       a0 08		      ldy	#MATHSTACKPOS
    426  10ec		       b1 56		      lda	(MQ),y
    427  10ee		       85 48		      sta	MATHSTACK
    428  10f0		       c8		      iny
    429  10f1		       b1 56		      lda	(MQ),y
    430  10f3		       85 49		      sta	MATHSTACK+1
    431  10f5		       4c bb 02 	      jmp	NextIL
    432  10f8							;==================================================================
    433  10f8							; Updates the tasks math stack pointer with contents of R2
    434  10f8							; PID is on top of the stack
    435  10f8				   iTaskPutMathPtr
    436  10f8		       20 6c 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  10fb		       20 58 12 	      jsr	ipc_getcontext	; MQ now has the context address
    438  10fe		       a5 58		      lda	R2
    439  1100		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  1102		       91 56		      sta	(MQ),y
    441  1104		       4c bb 02 	      jmp	NextIL
    442  1107							;
    443  1107							;================================================================
    444  1107							; Set the time slice for each task
    445  1107				   iSLICE
    446  1107		       20 f2 14 	      jsr	popR0
    447  110a		       a5 52		      lda	R0
    448  110c		       8d e1 1e 	      sta	taskResetValue
    449  110f		       a5 53		      lda	R0+1
    450  1111		       8d e2 1e 	      sta	taskResetValue+1
    451  1114		       d0 0b		      bne	iSliceSet
    452  1116		       ee e2 1e 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  1119		       a9 01		      lda	#1
    454  111b		       8d df 1e 	      sta	taskCurrentCycles
    455  111e		       8d e0 1e 	      sta	taskCurrentCycles+1
    456  1121				   iSliceSet
    457  1121		       4c bb 02 	      jmp	NextIL
    458  1124							;================================================================
    459  1124							; Find an empty slot in the taskTable
    460  1124							; Return the index in y
    461  1124							; on exit   c set if an empty slot is found
    462  1124							;	     c clear if not found
    463  1124							;================================================================
    464  1124							;
    465  1124		       ad e3 1e    TaskEmpty  lda	taskCounter
    466  1127		       c9 0a		      cmp	#TASKCOUNT
    467  1129		       b0 10		      bcs	TaskNoSlot
    468  112b		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  112d				   TaskLoop
    470  112d		       b9 e5 1d 	      lda	taskTable,y
    471  1130		       f0 0b		      beq	TaskEmptyFnd
    472  1132		       98		      tya
    473  1133		       18		      clc
    474  1134		       69 19		      adc	#CONTEXTLEN+1
    475  1136		       a8		      tay
    476  1137		       c0 fa		      cpy	#TASKTABLELEN
    477  1139		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  113b				   TaskNoSlot
    479  113b		       18		      clc
    480  113c		       60		      rts
    481  113d				   TaskEmptyFnd
    482  113d		       38		      sec
    483  113e		       60		      rts
    484  113f							;====================================================
    485  113f							; Set the task exit code called from the return command
    486  113f							; on entry stack top hold exit value
    487  113f				   TaskSetExitCode
    488  113f		       98		      tya
    489  1140		       48		      pha
    490  1141		       20 f2 14 	      jsr	popR0
    491  1144		       a0 19		      ldy	#TASKEXITCODE
    492  1146		       a5 52		      lda	R0
    493  1148		       91 41		      sta	(VARIABLES),y
    494  114a		       c8		      iny
    495  114b		       a5 53		      lda	R0+1
    496  114d		       91 41		      sta	(VARIABLES),y
    497  114f		       68		      pla
    498  1150		       98		      tya
    499  1151		       60		      rts
    500  1152
    501  1152							;
    502  1152							;=====================================================
    503  1152							; Save Context Store the context to the TASK Table
    504  1152							; on entry y contains the task table entry to save to
    505  1152							; on exit y points to next task table entry
    506  1152							;	   x contains the number of bytes copied
    507  1152		       a2 00	   ContextSave ldx	#0
    508  1154		       c8		      iny		;inc past the task flags
    509  1155		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  1157		       99 e5 1d 	      sta	taskTable,y
    511  115a		       c8		      iny
    512  115b		       e8		      inx
    513  115c		       e0 18		      cpx	#CONTEXTLEN
    514  115e		       90 f5		      bcc	ContextSvLoop
    515  1160		       60		      rts
    516  1161							;
    517  1161							; Load Context transfer context from task table to the Current Context
    518  1161							; on entry y contains the task table entry to transfer
    519  1161							; on exit y points to the original task table entry
    520  1161							;	   x contains the number of byts copied
    521  1161		       98	   ContextLoad tya
    522  1162		       48		      pha
    523  1163		       a2 00		      ldx	#0
    524  1165		       c8		      iny		;inc past the task flags
    525  1166		       b9 e5 1d    ContextLDLoop lda	taskTable,y
    526  1169		       95 41		      sta	CONTEXT,x
    527  116b		       c8		      iny
    528  116c		       e8		      inx
    529  116d		       e0 18		      cpx	#CONTEXTLEN
    530  116f		       90 f5		      bcc	ContextLDLoop
    531  1171		       68		      pla
    532  1172		       a8		      tay
    533  1173		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  1174					      include	"ipc.asm"
      1  1174							;======================================================
      2  1174							; Inter process communications.
      3  1174							; Tasks may write/read integer messages among
      4  1174							; them selves.
      5  1174							; This uses each tasks gosub stack as a message queue
      6  1174							; Gosub calls start at the highest address and the
      7  1174							; msg queue starts at the highest address.
      8  1174							;
      9  1174							;======================================================
     10  1174							; ipcs   - Send msg to another task or many tasks
     11  1174							; on entry  math stack contains the  top PID
     12  1174							;				      2ND Message value
     13  1174							; on exit   math stack contain top True-good or False-failed
     14  1174							;
     15  1174							; it may not be sent if queue is full
     16  1174							;
     17  1174							; a = ipcs(<message-expression>,<task PID-expression>)
     18  1174							;
     19  1174				   iIPCS
     20  1174		       98		      tya
     21  1175		       48		      pha
     22  1176		       20 dd 11 	      jsr	ipc_enqueue
     23  1179		       b0 08		      bcs	iIPC_BAD
     24  117b		       20 5e 17 	      jsr	pushTrue
     25  117e		       68		      pla
     26  117f		       a8		      tay
     27  1180		       4c bb 02 	      jmp	NextIL
     28  1183				   iIPC_BAD
     29  1183		       68		      pla
     30  1184		       a8		      tay
     31  1185		       20 68 17 	      jsr	pushFalse
     32  1188		       4c bb 02 	      jmp	NextIL
     33  118b
     34  118b							;======================================================
     35  118b							; ipcr   - Recieve msg from task
     36  118b							; on exit  the message value is returned from message queue
     37  118b							;	    message -1	is reserved meaning no entry found
     38  118b							; The provided variable contains the pid of the sending
     39  118b							; task. This is optional. This always waits for a message
     40  118b							; before returning.
     41  118b							;
     42  118b							; a = ipcr(<variable name>)
     43  118b							;
     44  118b				   iIPCR
     45  118b		       98		      tya
     46  118c		       48		      pha
     47  118d		       20 1f 12 	      jsr	ipc_dequeue
     48  1190		       b0 05		      bcs	iIPCR_Q_Empty
     49  1192		       68		      pla
     50  1193		       a8		      tay
     51  1194		       4c bb 02 	      jmp	NextIL
     52  1197				   iIPCR_Q_Empty
     53  1197		       68		      pla
     54  1198		       a8		      tay
     55  1199		       20 5e 17 	      jsr	pushTrue	; puts -1 on the stack
     56  119c		       4c bb 02 	      jmp	NextIL
     57  119f
     58  119f							;=======================================================
     59  119f							; ipcc   - Check if message available
     60  119f							; on exit  Stack contains number of messages
     61  119f							;
     62  119f							; a = ipcc()
     63  119f							;
     64  119f				   iIPCC
     65  119f		       98		      tya
     66  11a0		       48		      pha
     67  11a1		       20 ca 11 	      jsr	ipc_queue_count
     68  11a4		       20 6e 14 	      jsr	pushR0	; return the count
     69  11a7		       68		      pla
     70  11a8		       a8		      tay
     71  11a9		       4c bb 02 	      jmp	NextIL
     72  11ac
     73  11ac							;=======================================================
     74  11ac							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  11ac				   iIPCIO
     76  11ac		       98		      tya
     77  11ad		       48		      pha
     78  11ae		       20 ca 11 	      jsr	ipc_queue_count
     79  11b1		       a5 52		      lda	R0
     80  11b3		       d0 10		      bne	iIPCIO_No_Halt
     81  11b5		       a9 01		      lda	#1
     82  11b7		       8d df 1e 	      sta	taskCurrentCycles	; force a task switch
     83  11ba		       a9 01		      lda	#TASKWAITIPC
     84  11bc		       ac e4 1d 	      ldy	taskPtr
     85  11bf		       19 e5 1d 	      ora	taskTable,y
     86  11c2		       99 e5 1d 	      sta	taskTable,y
     87  11c5
     88  11c5				   iIPCIO_No_Halt
     89  11c5		       68		      pla
     90  11c6		       a8		      tay
     91  11c7		       4c bb 02 	      jmp	NextIL
     92  11ca							;======================================================
     93  11ca							;ipc_queue_count
     94  11ca				   ipc_queue_count
     95  11ca		       a5 4e		      lda	MESSAGEPTR
     96  11cc		       18		      clc
     97  11cd		       4a		      lsr		; divide by 4
     98  11ce		       4a		      lsr
     99  11cf		       85 52		      sta	R0	; store into R0
    100  11d1		       a9 10		      lda	#GOSUBSTACKSIZE
    101  11d3		       38		      sec
    102  11d4		       e5 52		      sbc	R0	; Get how many entries on queue
    103  11d6		       85 52		      sta	R0
    104  11d8		       a9 00		      lda	#0
    105  11da		       85 53		      sta	R0+1
    106  11dc		       60		      rts
    107  11dd							;=======================================================
    108  11dd							; Support functions for messaging
    109  11dd							;
    110  11dd							; Enqueue message -> onto PID's MSG Q
    111  11dd							; on entry top of stack contains the PID
    112  11dd							;	    second contains the Message of the task
    113  11dd							; on exit contains c set if failed
    114  11dd							;		    c cleared if success
    115  11dd							;		    PID's MSG Q PTR points to the message
    116  11dd							;
    117  11dd				   ipc_enqueue
    118  11dd		       20 0a 15 	      jsr	popR1	; Get the pid
    119  11e0		       20 58 12 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  11e3
    121  11e3		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  11e5		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  11e7		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  11e9		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  11eb		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  11ed
    127  11ed
    128  11ed							; Get the PID'S stack address into R0
    129  11ed		       a0 0b		      ldy	#GOSUBSTKPOS
    130  11ef		       b1 56		      lda	(MQ),y
    131  11f1		       85 52		      sta	R0
    132  11f3		       c8		      iny
    133  11f4		       b1 56		      lda	(MQ),y
    134  11f6		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  11f8
    136  11f8							; Set y to point to the msg q entry
    137  11f8		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  11fa		       b1 56		      lda	(MQ),y	; Get the index
    139  11fc		       a8		      tay		; Set y to queue offset
    140  11fd
    141  11fd							; enqueue the message
    142  11fd		       88		      dey		; First byte to save to
    143  11fe		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1200		       91 52		      sta	(R0),y	; Set the entry type
    145  1202
    146  1202		       88		      dey
    147  1203		       ad e4 1d 	      lda	taskPtr	; Store the PID into queue
    148  1206		       91 52		      sta	(R0),y
    149  1208		       20 0a 15 	      jsr	popR1	; Get the actual message value
    150  120b		       20 66 12 	      jsr	ipc_pushR1	; Store Message value into queue
    151  120e
    152  120e		       98		      tya		; Save the new q ptr
    153  120f		       a0 0e		      ldy	#MSGPTRPOS
    154  1211		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1213		       a0 00		      ldy	#0	; points to context root
    156  1215		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1217		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1219		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  121b		       18		      clc
    160  121c		       60		      rts
    161  121d				   ipc_enq_full
    162  121d		       38		      sec
    163  121e		       60		      rts
    164  121f							;=============================================================
    165  121f							; De-queue for message stack -> local tasks msg q
    166  121f							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  121f							;  message into
    168  121f							;  on exit   math stack contains value of message
    169  121f							;				  Variable if provided is pid
    170  121f				   ipc_dequeue
    171  121f		       20 21 15 	      jsr	popMQ	; Variable address to put PID into
    172  1222
    173  1222		       a4 4e		      ldy	MESSAGEPTR
    174  1224		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1226		       b0 2e		      bcs	ipc_deq_empty
    176  1228		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  122a		       85 52		      sta	R0
    178  122c		       c8		      iny
    179  122d		       b1 4b		      lda	(GOSUBSTACK),y
    180  122f		       85 53		      sta	R0+1
    181  1231		       c8		      iny
    182  1232		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1234		       85 54		      sta	R1
    184  1236		       c8		      iny
    185  1237		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1239		       c8		      iny
    187  123a		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  123c
    189  123c		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  123e		       d0 16		      bne	ipc_deq_empty
    191  1240
    192  1240		       20 6e 14 	      jsr	pushR0	; place value on stack
    193  1243
    194  1243		       a5 56		      lda	MQ
    195  1245		       05 57		      ora	MQ+1
    196  1247		       f0 0b		      beq	ipc_deq_done
    197  1249		       a5 54		      lda	R1
    198  124b		       a0 00		      ldy	#0
    199  124d		       91 56		      sta	(MQ),y
    200  124f		       c8		      iny
    201  1250		       a9 00		      lda	#0
    202  1252		       91 56		      sta	(MQ),y
    203  1254				   ipc_deq_done
    204  1254		       18		      clc
    205  1255		       60		      rts
    206  1256
    207  1256				   ipc_deq_empty
    208  1256		       38		      sec
    209  1257		       60		      rts
    210  1258
    211  1258							;=============================================
    212  1258							;  Get the context address into MQ from R1 with
    213  1258							;  context/index/pid
    214  1258				   ipc_getcontext
    215  1258		       18		      clc		; Get pointer to Task context
    216  1259		       a9 e5		      lda	#taskTable&$FF	; change ptr to address
    217  125b		       65 54		      adc	R1
    218  125d		       85 56		      sta	MQ
    219  125f		       a9 1d		      lda	#taskTable>>8
    220  1261		       65 55		      adc	R1+1
    221  1263		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1265		       60		      rts
    223  1266							;
    224  1266							;==============================================
    225  1266							;Push R1 onto the stack
    226  1266							;on entry y = next entry
    227  1266							;R0 points to the stack space
    228  1266							;on exit y points to next free byte
    229  1266				   ipc_pushR1
    230  1266		       88		      dey
    231  1267		       a5 55		      lda	R1+1	; PID first
    232  1269		       91 52		      sta	(R0),y
    233  126b		       88		      dey
    234  126c		       a5 54		      lda	R1
    235  126e		       91 52		      sta	(R0),y
    236  1270		       60		      rts
    237  1271
    238  1271
    239  1271
    240  1271
    241  1271
    242  1271
    243  1271
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1271					      include	"support.asm"
      1  1271							;
      2  1271							;=====================================================
      3  1271							;=====================================================
      4  1271							;=====================================================
      5  1271							; This marks the start of support functions used by
      6  1271							; the IL opcodes.  These are support functions, NOT
      7  1271							; the IL code.
      8  1271							;=====================================================
      9  1271							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1271							;=====================================================
     11  1271					      Seg	Code
     12  1271							;=====================================================
     13  1271							; This gets the next two bytes pointed to by ILPC and
     14  1271							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1271							; is advanced by two, and Y contains 0 on return.
     16  1271
     17  1271							;
     18  1271		       20 75 12    getILWord  jsr	getILByte	;LSB
     19  1274		       aa		      tax
     20  1275							;
     21  1275							;=====================================================
     22  1275							; This gets the next byte pointed to by ILPC and
     23  1275							; returns it in A.  On return, X is unchanged but Y
     24  1275							; contains 0.
     25  1275							;
     26  1275		       a0 00	   getILByte  ldy	#0
     27  1277		       b1 43		      lda	(ILPC),y	;get byte
     28  1279		       08		      php		;save status
     29  127a		       e6 43		      inc	ILPC	;inc LSB
     30  127c		       d0 02		      bne	getILb2	;branch if no overflow
     31  127e		       e6 44		      inc	ILPC+1	;inc MSB
     32  1280		       28	   getILb2    plp		;restore status
     33  1281		       60		      rts
     34  1282							;
     35  1282							;=====================================================
     36  1282							; Decrement ILPC by one.
     37  1282							;
     38  1282		       a5 43	   decIL      lda	ILPC
     39  1284		       d0 02		      bne	decIL2
     40  1286		       c6 44		      dec	ILPC+1
     41  1288		       c6 43	   decIL2     dec	ILPC
     42  128a		       60		      rts
     43  128b							;
     44  128b							;=====================================================
     45  128b							; Push the ILPC onto the return stack.  Actually, this
     46  128b							; pushes the address of ILPC+2 since that's the next
     47  128b							; address to execute.
     48  128b							;
     49  128b		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  128d		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  128f		       b0 15		      bcs	pushErr
     52  1291		       a5 43		      lda	ILPC
     53  1293		       18		      clc
     54  1294		       69 02		      adc	#2
     55  1296		       91 45		      sta	(ILSTACK),y
     56  1298		       08		      php		;save C bit
     57  1299		       c8		      iny
     58  129a		       a5 44		      lda	ILPC+1
     59  129c		       28		      plp		;restore C
     60  129d		       69 00		      adc	#0
     61  129f		       91 45		      sta	(ILSTACK),y
     62  12a1		       c8		      iny
     63  12a2		       84 47		      sty	ILSTACKPTR
     64  12a4		       18		      clc
     65  12a5		       60		      rts
     66  12a6				   pushErr
     67  12a6		       38		      sec
     68  12a7		       60		      rts
     69  12a8							;
     70  12a8							;=====================================================
     71  12a8							; Pull the top entry from return stack and put into
     72  12a8							; ILPC.
     73  12a8							;
     74  12a8		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  12aa		       f0 fa		      beq	pushErr
     76  12ac		       88		      dey
     77  12ad		       b1 45		      lda	(ILSTACK),y
     78  12af		       85 44		      sta	ILPC+1
     79  12b1		       88		      dey
     80  12b2		       b1 45		      lda	(ILSTACK),y
     81  12b4		       85 43		      sta	ILPC
     82  12b6		       84 47		      sty	ILSTACKPTR
     83  12b8		       18		      clc
     84  12b9		       60		      rts
     85  12ba							;
     86  12ba							;=====================================================
     87  12ba							; This searches for a specific line number that is in
     88  12ba							; R0.	There are three possible return conditions:
     89  12ba							; Line numbers are now the third byte, the first byte is now **************
     90  12ba							; a pointer to the next line, of course no longer that 53 byte
     91  12ba							; per line.
     92  12ba							;
     93  12ba							; Exact match was found:
     94  12ba							;    * Z set
     95  12ba							;    * CURPTR points to two-byte line number for that
     96  12ba							;	line.
     97  12ba							;
     98  12ba							; Next highest line found:
     99  12ba							;    * Z cleared
    100  12ba							;    * C set
    101  12ba							;    * CURPTR points to two-byte line number for that
    102  12ba							;	line.
    103  12ba							;
    104  12ba							; End of program reached:
    105  12ba							;    * Z cleared
    106  12ba							;    * C cleared
    107  12ba							;    * CURPTR points to first free byte at end of
    108  12ba							;	program.  Ie, it has save value as PROGRAMEND.
    109  12ba							;
    110  12ba							; A, X, and Y are all undefined on return.
    111  12ba							;
    112  12ba
    113  12ba				   findLine
    114  12ba		       ad 3d 27 	      lda	ProgramStart	;Start of program -> CURPTR
    115  12bd		       85 4f		      sta	CURPTR
    116  12bf		       ad 3e 27 	      lda	ProgramStart+1
    117  12c2		       85 50		      sta	CURPTR+1
    118  12c4							;
    119  12c4							; At end of code?
    120  12c4							;
    121  12c4				   iXFER1
    122  12c4		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  12c6		       cd 3f 27 	      cmp	ProgramEnd	; at end of program then stop run
    124  12c9		       d0 0b		      bne	xfer2	; not end
    125  12cb		       a5 50		      lda	CURPTR+1
    126  12cd		       cd 40 27 	      cmp	ProgramEnd+1
    127  12d0		       d0 04		      bne	xfer2	;Not at end
    128  12d2							;
    129  12d2							; Line not found and the end of the program was
    130  12d2							; reached.  Return Z and C both clear.
    131  12d2							;
    132  12d2		       a9 01		      lda	#1	;clear Z
    133  12d4		       18		      clc		;clear C
    134  12d5		       60		      rts
    135  12d6							;
    136  12d6							; Check for an exact line number match
    137  12d6							;
    138  12d6		       a5 52	   xfer2      lda	R0
    139  12d8		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  12da		       d1 4f		      cmp	(CURPTR),y
    141  12dc		       d0 08		      bne	xfernotit
    142  12de		       c8		      iny
    143  12df		       a5 53		      lda	R0+1
    144  12e1		       d1 4f		      cmp	(CURPTR),y
    145  12e3		       d0 01		      bne	xfernotit	; not a matching line number
    146  12e5							;
    147  12e5							; This is exactly the line we want.
    148  12e5							;
    149  12e5		       60		      rts		;it matches exactly
    150  12e6							;
    151  12e6							; See if this line is greater than the one we're
    152  12e6							; searching for.
    153  12e6							;
    154  12e6		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  12e8		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  12ea		       c5 53		      cmp	R0+1
    157  12ec		       90 0b		      bcc	xfer3
    158  12ee		       d0 07		      bne	xfer4
    159  12f0		       88		      dey
    160  12f1		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  12f3		       c5 52		      cmp	R0
    162  12f5		       90 02		      bcc	xfer3
    163  12f7							;
    164  12f7							; This line is greater than the one we want, so
    165  12f7							; return Z clear and C set.
    166  12f7							;
    167  12f7		       38	   xfer4      sec		;We found a line number greater
    168  12f8		       60		      rts		;both conditions set
    169  12f9							;
    170  12f9							; Not the line (or droid) we're looking for.  Move to
    171  12f9							; the next line.
    172  12f9							;
    173  12f9		       20 ff 12    xfer3      jsr	FindNextLine
    174  12fc		       4c c4 12 	      jmp	iXFER1
    175  12ff							;
    176  12ff							;=====================================================
    177  12ff							; This advances CURPTR to the next line.  If there
    178  12ff							; are no more lines, this leaves CURPTR equal to
    179  12ff							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  12ff							; CURPTR is pointing to a valid line on entry.  This
    181  12ff							; pointer points to the two-byte line number.
    182  12ff							; Update this points to the 1 byte line length  ****************
    183  12ff							;
    184  12ff				   FindNextLine
    185  12ff		       a0 03		      ldy	#3	;skip line number and length byte
    186  1301		       84 51		      sty	CUROFF	;this is the new offset
    187  1303		       a0 00		      ldy	#0
    188  1305		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1307		       18		      clc
    190  1308		       65 4f		      adc	CURPTR
    191  130a		       85 4f		      sta	CURPTR
    192  130c		       a5 50		      lda	CURPTR+1
    193  130e		       69 00		      adc	#0
    194  1310		       85 50		      sta	CURPTR+1
    195  1312		       60	   FindNext4  rts
    196  1313							;
    197  1313							;=====================================================
    198  1313							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1313							; if they are equal, Z clear if not.
    200  1313							;
    201  1313		       a5 4f	   AtEnd      lda	CURPTR
    202  1315		       cd 3f 27 	      cmp	ProgramEnd
    203  1318		       d0 05		      bne	atendexit
    204  131a		       a5 50		      lda	CURPTR+1
    205  131c		       cd 40 27 	      cmp	ProgramEnd+1
    206  131f		       60	   atendexit  rts
    207  1320							;
    208  1320
    209  1320							;
    210  1320							;=====================================================
    211  1320							; Convert an ASCII string to a number.  On input,
    212  1320							; (CURPTR),Y points to the first digit.  This gets
    213  1320							; digit-by-digit until finding a non-number.  Returns
    214  1320							; Y pointing to the non-digit, and R0 contains the
    215  1320							; number.  This does NOT check for valid ranges, so
    216  1320							; a value like "123456789" will produce something,
    217  1320							; but not what you had expected.
    218  1320							;
    219  1320		       a9 00	   getDecimal lda	#0
    220  1322		       85 52		      sta	R0
    221  1324		       85 53		      sta	R0+1
    222  1326		       85 59		      sta	dpl	;temporary negative flag
    223  1328							;
    224  1328							; See if it's negative...
    225  1328							;
    226  1328							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1328		       b1 4f		      lda	(CURPTR),y
    228  132a		       c9 2d		      cmp	#'-
    229  132c		       d0 02		      bne	getDecLoop
    230  132e		       e6 59		      inc	dpl	;it's negative
    231  1330							;
    232  1330		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1332		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1334		       c9 30		      cmp	#'0
    235  1336		       90 36		      bcc	getDdone
    236  1338		       c9 3a		      cmp	#'9+1
    237  133a		       b0 32		      bcs	getDdone
    238  133c		       38		      sec
    239  133d		       e9 30		      sbc	#'0	;convert to binary
    240  133f		       48		      pha
    241  1340							;
    242  1340							; Now multiply R0 by 10.  Remember that
    243  1340							; 2*N + 8*N = 10*N.
    244  1340							;
    245  1340		       06 52		      asl	R0
    246  1342		       26 53		      rol	R0+1	;*2
    247  1344		       a5 52		      lda	R0
    248  1346		       85 54		      sta	R1
    249  1348		       a5 53		      lda	R0+1
    250  134a		       85 55		      sta	R1+1
    251  134c		       06 52		      asl	R0
    252  134e		       26 53		      rol	R0+1	;*4
    253  1350		       06 52		      asl	R0
    254  1352		       26 53		      rol	R0+1	;*8
    255  1354		       18		      clc		;now add the partial sums...
    256  1355		       a5 52		      lda	R0	;...to get *10
    257  1357		       65 54		      adc	R1
    258  1359		       85 52		      sta	R0
    259  135b		       a5 53		      lda	R0+1
    260  135d		       65 55		      adc	R1+1
    261  135f		       85 53		      sta	R0+1
    262  1361							;
    263  1361							; Add in the new digit
    264  1361							;
    265  1361		       68		      pla
    266  1362		       18		      clc
    267  1363		       65 52		      adc	R0
    268  1365		       85 52		      sta	R0
    269  1367		       90 02		      bcc	getD2
    270  1369		       e6 53		      inc	R0+1
    271  136b							;
    272  136b							; Move to next character
    273  136b							;
    274  136b		       c8	   getD2      iny
    275  136c		       d0 c2		      bne	getDecLoop
    276  136e							;
    277  136e							; All done with digits, so now deal with it being
    278  136e							; negative.  If zero, then don't check for negative
    279  136e							; flag.  Ie, -0 is stored as 0.
    280  136e							;
    281  136e		       a5 52	   getDdone   lda	R0
    282  1370		       05 53		      ora	R0+1
    283  1372		       f0 16		      beq	getDone2	;zero
    284  1374		       a5 59		      lda	dpl
    285  1376		       f0 12		      beq	getDone2	;positive
    286  1378							;
    287  1378							; Invert all the bits, then add one.
    288  1378							;
    289  1378		       a5 52		      lda	R0
    290  137a		       49 ff		      eor	#$ff
    291  137c		       85 52		      sta	R0
    292  137e		       a5 53		      lda	R0+1
    293  1380		       49 ff		      eor	#$ff
    294  1382		       85 53		      sta	R0+1
    295  1384							;
    296  1384		       e6 52		      inc	R0
    297  1386		       d0 02		      bne	getDone2
    298  1388		       e6 53		      inc	R0+1
    299  138a				   getDone2
    300  138a							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  138a							;lda	  R0
    302  138a							;sta	  $0010
    303  138a							;lda	  R0+1
    304  138a							;sta	  $0011
    305  138a							;lda	  dpl
    306  138a							;sta	  $012
    307  138a
    308  138a		       60		      rts
    309  138b
    310  138b							;=====================================================
    311  138b							; Gets a line of input into LINBUF.
    312  138b							;
    313  138b							; On entry:
    314  138b							;    A contains the prompt character, or 0 if none.
    315  138b							;    X = 1 Background read
    316  138b							;    x = 0 Forground read with wait
    317  138b							;
    318  138b							; On exit:
    319  138b							;    CURPTR points to LINBUF
    320  138b							;    LINBUF contains the line with 0 at the end.
    321  138b							;    Y has offset to first non-space character
    322  138b							;    CURROFF has the same as Y.
    323  138b							;
    324  138b		       20 da 13    GetLine    jsr	ReadPrompt
    325  138e		       e0 00		      cpx	#0
    326  1390		       f0 14		      beq	GetLineRetry
    327  1392		       ae e4 1d 	      ldx	taskPtr
    328  1395		       bd e5 1d 	      lda	taskTable,x
    329  1398		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  139a		       d0 3d		      bne	taskWaitingIO
    331  139c		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  139e		       9d e5 1d 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  13a1		       ce d9 13 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  13a4		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  13a6
    336  13a6							;
    337  13a6							; Now read a line and wait for the CR
    338  13a6							;
    339  13a6				   GetLineRetry
    340  13a6		       a9 00		      lda	#0	;Wait for input to complete
    341  13a8		       20 f2 13 	      jsr	ReadLine
    342  13ab
    343  13ab							;
    344  13ab							; Point to the line we just read
    345  13ab							; Set the current pointer to point to the input line
    346  13ab							;
    347  13ab		       a0 00	   ReadComplete ldy	#0
    348  13ad		       84 51		      sty	CUROFF
    349  13af		       a2 a0		      ldx	#LINBUF&$ff
    350  13b1		       86 4f		      stx	CURPTR
    351  13b3		       a2 26		      ldx	#LINBUF>>8
    352  13b5		       86 50		      stx	CURPTR+1
    353  13b7							;
    354  13b7							; Output a CR/LF
    355  13b7							;
    356  13b7		       20 ab 15 	      jsr	CRLF
    357  13ba							;
    358  13ba							; If a blank line, prompt again.
    359  13ba							;
    360  13ba		       20 a2 15 	      jsr	SkipSpaces
    361  13bd		       b1 4f		      lda	(CURPTR),y
    362  13bf		       d0 10		      bne	GetLineDone	;We have data then exit
    363  13c1		       20 dd 13 	      jsr	ReadPromptRetry
    364  13c4		       ae e4 1d 	      ldx	taskPtr	;if this task is waiting for IO
    365  13c7		       bd e5 1d 	      lda	taskTable,x	;then get out, wait for line to
    366  13ca		       29 40		      and	#TASKWAITIO	;Complete again
    367  13cc		       d0 0b		      bne	taskWaitingIO
    368  13ce		       4c a6 13 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  13d1
    370  13d1				   GetLineDone
    371  13d1		       ae e4 1d 	      ldx	taskPtr
    372  13d4		       a9 80		      lda	#TASKACTIVE
    373  13d6		       9d e5 1d 	      sta	taskTable,x	;IO is complete
    374  13d9
    375  13d9				   taskWaitingIO
    376  13d9		       60		      rts
    377  13da
    378  13da							;
    379  13da							;=======================================================================
    380  13da							; Display the prompt character
    381  13da							; On entry
    382  13da							;	    A contains the prompt character
    383  13da							; On exit
    384  13da							;	    The readbuffer index is reset to 0
    385  13da							;
    386  13da		       8d 27 27    ReadPrompt sta	promptChar
    387  13dd
    388  13dd							;
    389  13dd							; Prompt
    390  13dd							;
    391  13dd
    392  13dd		       ad 27 27    ReadPromptRetry lda	promptChar
    393  13e0		       09 00		      ora	#0	;any prompt?
    394  13e2		       f0 08		      beq	getlinenp
    395  13e4		       20 f4 16 	      jsr	VOUTCH
    396  13e7		       a9 20		      lda	#$20
    397  13e9		       20 f4 16 	      jsr	VOUTCH	;Space after prompt
    398  13ec							;
    399  13ec		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  13ee		       8e 24 27 	      stx	getlinx
    401  13f1		       60		      rts
    402  13f2							;
    403  13f2							;===============================================================
    404  13f2							; This fuction is the driver for the line input
    405  13f2							; on call if a = 0 then it waits for all input
    406  13f2							;	      a = 1 then nowait for input
    407  13f2							; On exit
    408  13f2							;		       c clear if not complete line
    409  13f2							;		       c set if it was a complete line
    410  13f2
    411  13f2				   ReadLine
    412  13f2		       8d 26 27 	      sta	inputNoWait
    413  13f5		       c9 00		      cmp	#0
    414  13f7		       f0 05		      beq	getline1
    415  13f9		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  13fc		       f0 2b		      beq	GetLineNoWait
    417  13fe		       20 f7 16    getline1   jsr	VGETCH
    418  1401					      if	CTMON65
    419  1401		       48		      pha
    420  1402		       20 f4 16 	      jsr	VOUTCH	;echo echo echo
    421  1405		       68		      pla
    422  1406					      endif
    423  1406		       c9 0d		      cmp	#CR
    424  1408		       f0 15		      beq	getlind	;end of line
    425  140a		       c9 08		      cmp	#BS	;backspace?
    426  140c		       f0 1d		      beq	getlinebs
    427  140e		       ae 24 27 	      ldx	getlinx
    428  1411		       9d a0 26 	      sta	LINBUF,x
    429  1414		       e8		      inx
    430  1415		       8e 24 27 	      stx	getlinx
    431  1418		       ad 26 27 	      lda	inputNoWait
    432  141b		       f0 e1		      beq	getline1
    433  141d		       d0 0a		      bne	GetLineNoWait
    434  141f							;
    435  141f							; CR was hit
    436  141f							;
    437  141f		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1421		       ae 24 27 	      ldx	getlinx
    439  1424		       9d a0 26 	      sta	LINBUF,x
    440  1427
    441  1427		       38		      sec		; Carry set then cr received
    442  1428		       60		      rts
    443  1429
    444  1429				   GetLineNoWait
    445  1429		       18		      clc		; Carry clear no end of line
    446  142a		       60		      rts
    447  142b							;
    448  142b							; Backspace was hit
    449  142b							;
    450  142b		       ae 24 27    getlinebs  ldx	getlinx
    451  142e		       f0 0e		      beq	getlineEOL	;at start of line
    452  1430		       ca		      dex
    453  1431		       8e 24 27 	      stx	getlinx
    454  1434		       20 fa 16    getlinepbs jsr	puts
      0  1437					      db	27,"[K",0
      1  1437		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  143b		       4c fe 13 	      jmp	getline1
    457  143e		       a9 20	   getlineEOL lda	#SPACE
    458  1440		       20 f4 16 	      jsr	VOUTCH
    459  1443		       d0 ef		      bne	getlinepbs
    460  1445							;
    461  1445							;=====================================================
    462  1445							; Count the length of the line currently in LINBUF
    463  1445							; starting at offset Y.  Returns the length in X.  The
    464  1445							; starting offset in Y should point past the ASCII
    465  1445							; line number.  Also counts the trailing NULL and two
    466  1445							; extra bytes for where the line number will be.
    467  1445							; Update must now include leading length byte not the null at end ****************
    468  1445							;
    469  1445				   getLineLength
    470  1445		       a2 00		      ldx	#0	;size
    471  1447		       b9 a0 26    getLineL2  lda	LINBUF,y
    472  144a		       f0 04		      beq	getLineL3
    473  144c		       c8		      iny
    474  144d		       e8		      inx
    475  144e		       d0 f7		      bne	getLineL2
    476  1450		       e8	   getLineL3  inx		;count null at end
    477  1451		       e8		      inx		;line number LSB
    478  1452		       e8		      inx		;MSB
    479  1453		       e8		      inx		;change: count new leading line length
    480  1454		       8e 3a 27 	      stx	lineLength
    481  1457		       60		      rts
    482  1458							;
    483  1458							;=====================================================
    484  1458							; Count the length of the line pointed to by CURPTR.
    485  1458							; This also counts the line number and the terminating
    486  1458							; null.  Ie, this string returns 8:
    487  1458							;
    488  1458							; <lineLow><lineHi>Hello<null>
    489  1458							;
    490  1458							; Another way of looking at it: add the return value
    491  1458							; to the CURPTR and it'll point to the next line's
    492  1458							; line number.  Returns the value in Y.
    493  1458							; Update to ject get the leading byte length ********************
    494  1458							;
    495  1458							;getCURPTRLength
    496  1458							;		ldy	CURPTR
    497  1458							;		ldy	#3	;change: skip line number and leading length byte
    498  1458							;getCLineL2	lda	(CURPTR),y
    499  1458							;		beq	getCLineL3
    500  1458							;		iny
    501  1458							;		bne	getCLineL2
    502  1458							;getCLineL3	iny		;count null at end
    503  1458							;		rts
    504  1458
    505  1458							;
    506  1458							;=====================================================
    507  1458							; This saves ILPC.  This saves to a single save area,
    508  1458							; so it can't be called more than once.
    509  1458							;
    510  1458		       a5 43	   saveIL     lda	ILPC
    511  145a		       8d 36 27 	      sta	tempIL
    512  145d		       a5 44		      lda	ILPC+1
    513  145f		       8d 37 27 	      sta	tempIL+1
    514  1462		       60		      rts
    515  1463							;
    516  1463							;=====================================================
    517  1463							; This restores ILPC.
    518  1463							;
    519  1463		       ad 36 27    restoreIL  lda	tempIL
    520  1466		       85 43		      sta	ILPC
    521  1468		       ad 37 27 	      lda	tempIL+1
    522  146b		       85 44		      sta	ILPC+1
    523  146d		       60		      rts
    524  146e							;
    525  146e							;=====================================================
    526  146e							; This pushes R0 onto the stack.
    527  146e							;
    528  146e		       8c 2d 27    pushR0     sty	rtemp1
    529  1471		       a4 4a		      ldy	MATHSTACKPTR
    530  1473		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1475		       b0 34		      bcs	pusherr
    532  1477		       a5 52		      lda	R0
    533  1479		       91 48		      sta	(MATHSTACK),y
    534  147b		       c8		      iny
    535  147c		       a5 53		      lda	R0+1
    536  147e		       91 48		      sta	(MATHSTACK),y
    537  1480		       c8		      iny
    538  1481		       84 4a		      sty	MATHSTACKPTR
    539  1483		       ac 2d 27 	      ldy	rtemp1
    540  1486		       18		      clc
    541  1487		       60		      rts
    542  1488
    543  1488							;=====================================================
    544  1488							; This pushes curptr basic current line onto the call stack.
    545  1488							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1488
    547  1488				   pushLN
    548  1488		       8c 2d 27 	      sty	rtemp1
    549  148b		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  148d		       c5 4d		      cmp	GOSUBSTACKPTR
    551  148f		       90 1a		      bcc	pusherr	; No error
    552  1491		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  1493		       a2 00		      ldx	#0	; Start of bytes to copy
    554  1495				   pushLoop
    555  1495		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  1497		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  1499		       c8		      iny		; Next destination
    558  149a		       e8		      inx		; Next Source byte
    559  149b		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  149d		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  149f
    562  149f		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  14a1		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  14a3		       c8		      iny		; Next entry
    565  14a4
    566  14a4		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  14a6		       ac 2d 27 	      ldy	rtemp1
    568  14a9		       18		      clc
    569  14aa		       60		      rts
    570  14ab				   pusherr
    571  14ab		       38		      sec
    572  14ac		       60		      rts
    573  14ad							;=====================================================
    574  14ad							; This pops Top Off gosub call Stack and
    575  14ad							; places it in CURPTR/CUROFF.
    576  14ad							; This checks if the type = 1 GOSUB
    577  14ad							; if not it removes what ever is on the stack
    578  14ad							; until it finds the next return. Allowing
    579  14ad							; a return from within a for/next
    580  14ad		       8c 2d 27    popLN      sty	rtemp1
    581  14b0		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  14b2		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  14b4
    584  14b4				   popContinue
    585  14b4		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  14b6		       90 18		      bcc	poperr	; Process an error
    587  14b8
    588  14b8		       88		      dey		; Position to read entry type
    589  14b9		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  14bb		       c9 01		      cmp	#1	; Type is a gosub entry
    591  14bd		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  14bf
    593  14bf				   popLoop
    594  14bf		       88		      dey
    595  14c0		       ca		      dex
    596  14c1		       b1 4b		      lda	(GOSUBSTACK),y
    597  14c3		       95 4f		      sta	CURPTR,x
    598  14c5		       e0 00		      cpx	#0
    599  14c7		       d0 f6		      bne	popLoop	; Loop until all moved
    600  14c9
    601  14c9
    602  14c9		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  14cb		       ac 2d 27 	      ldy	rtemp1
    604  14ce		       18		      clc
    605  14cf		       60		      rts
    606  14d0
    607  14d0		       38	   poperr     sec
    608  14d1		       60		      rts
    609  14d2
    610  14d2		       88	   popSkipEntry dey
    611  14d3		       88		      dey
    612  14d4		       88		      dey
    613  14d5		       4c b4 14 	      jmp	popContinue
    614  14d8
    615  14d8							;
    616  14d8							;=====================================================
    617  14d8							; This pushes R1 onto the stack
    618  14d8							;
    619  14d8		       8c 2d 27    pushR1     sty	rtemp1
    620  14db		       a4 4a		      ldy	MATHSTACKPTR
    621  14dd		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  14df		       b0 ef		      bcs	poperr
    623  14e1		       a5 54		      lda	R1
    624  14e3		       91 48		      sta	(MATHSTACK),y
    625  14e5		       c8		      iny
    626  14e6		       a5 55		      lda	R1+1
    627  14e8		       91 48		      sta	(MATHSTACK),y
    628  14ea		       c8		      iny
    629  14eb		       84 4a		      sty	MATHSTACKPTR
    630  14ed		       ac 2d 27 	      ldy	rtemp1
    631  14f0		       18		      clc
    632  14f1		       60		      rts
    633  14f2							;
    634  14f2							;=====================================================
    635  14f2							; This pops Top Of Stack and places it in R0.
    636  14f2							;
    637  14f2		       8c 2d 27    popR0      sty	rtemp1
    638  14f5		       a4 4a		      ldy	MATHSTACKPTR
    639  14f7		       f0 d7		      beq	poperr
    640  14f9		       88		      dey
    641  14fa		       b1 48		      lda	(MATHSTACK),y
    642  14fc		       85 53		      sta	R0+1
    643  14fe		       88		      dey
    644  14ff		       b1 48		      lda	(MATHSTACK),y
    645  1501		       85 52		      sta	R0
    646  1503		       84 4a		      sty	MATHSTACKPTR
    647  1505		       ac 2d 27 	      ldy	rtemp1
    648  1508		       18		      clc
    649  1509		       60		      rts
    650  150a
    651  150a							;
    652  150a							;=====================================================
    653  150a							; This pops TOS and places it in R1.
    654  150a							;
    655  150a		       8c 2d 27    popR1      sty	rtemp1
    656  150d		       a4 4a		      ldy	MATHSTACKPTR
    657  150f		       f0 bf		      beq	poperr
    658  1511		       88		      dey
    659  1512		       b1 48		      lda	(MATHSTACK),y
    660  1514		       85 55		      sta	R1+1
    661  1516		       88		      dey
    662  1517		       b1 48		      lda	(MATHSTACK),y
    663  1519		       85 54		      sta	R1
    664  151b		       84 4a		      sty	MATHSTACKPTR
    665  151d		       ac 2d 27 	      ldy	rtemp1
    666  1520		       60		      rts
    667  1521							;
    668  1521							;=====================================================
    669  1521							; This pops TOS and places it in MQ.
    670  1521							;
    671  1521		       8c 2d 27    popMQ      sty	rtemp1
    672  1524		       a4 4a		      ldy	MATHSTACKPTR
    673  1526		       f0 a8		      beq	poperr
    674  1528		       88		      dey
    675  1529		       b1 48		      lda	(MATHSTACK),y
    676  152b		       85 57		      sta	MQ+1
    677  152d		       88		      dey
    678  152e		       b1 48		      lda	(MATHSTACK),y
    679  1530		       85 56		      sta	MQ
    680  1532		       84 4a		      sty	MATHSTACKPTR
    681  1534		       ac 2d 27 	      ldy	rtemp1
    682  1537		       60		      rts
    683  1538							;
    684  1538							;=====================================================
    685  1538							; This assists with multiplication and division by
    686  1538							; looking at R0 and R1 and saving a flag as to what
    687  1538							; sign the result will be.  Math is always done on
    688  1538							; positive numbers, so this converts negative numbers
    689  1538							; into positives.  On exit, R0 and R1 are both
    690  1538							; positive.  If the signs were different then 'signs'
    691  1538							; will be non-zero.
    692  1538							;
    693  1538		       a9 00	   SaveSigns  lda	#0
    694  153a		       8d 2c 27 	      sta	sign	;assume positive
    695  153d		       a5 53		      lda	R0+1	;MSB
    696  153f		       10 13		      bpl	SaveSigns1
    697  1541		       ee 2c 27 	      inc	sign	;it's negative
    698  1544		       49 ff		      eor	#$ff	;flip bits
    699  1546		       85 53		      sta	R0+1
    700  1548		       a5 52		      lda	R0
    701  154a		       49 ff		      eor	#$ff
    702  154c		       85 52		      sta	R0
    703  154e		       e6 52		      inc	R0
    704  1550		       d0 02		      bne	SaveSigns1
    705  1552		       e6 53		      inc	R0+1
    706  1554		       a5 55	   SaveSigns1 lda	R1+1
    707  1556		       10 1a		      bpl	SaveSigns2
    708  1558		       48		      pha
    709  1559		       ad 2c 27 	      lda	sign
    710  155c		       49 01		      eor	#1
    711  155e		       8d 2c 27 	      sta	sign
    712  1561		       68		      pla
    713  1562		       49 ff		      eor	#$ff	;flip bits
    714  1564		       85 55		      sta	R1+1
    715  1566		       a5 54		      lda	R1
    716  1568		       49 ff		      eor	#$ff
    717  156a		       85 54		      sta	R1
    718  156c		       e6 54		      inc	R1
    719  156e		       d0 02		      bne	SaveSigns2
    720  1570		       e6 55		      inc	R1+1
    721  1572		       60	   SaveSigns2 rts
    722  1573							;
    723  1573							;=====================================================
    724  1573							; This looks at the value of 'signs' and will convert
    725  1573							; both R0 and R1 to negative if set.
    726  1573							;
    727  1573				   RestoreSigns
    728  1573		       ad 2c 27 	      lda	sign
    729  1576		       f0 28		      beq	restoresigns2
    730  1578							;
    731  1578		       a5 52		      lda	R0
    732  157a		       d0 02		      bne	restoresigns3
    733  157c		       c6 53		      dec	R0+1
    734  157e				   restoresigns3
    735  157e		       c6 52		      dec	R0
    736  1580		       a5 52		      lda	R0
    737  1582		       49 ff		      eor	#$ff
    738  1584		       85 52		      sta	R0
    739  1586		       a5 53		      lda	R0+1
    740  1588		       49 ff		      eor	#$ff
    741  158a		       85 53		      sta	R0+1
    742  158c							;
    743  158c		       a5 54		      lda	R1
    744  158e		       d0 02		      bne	restoresigns4
    745  1590		       c6 55		      dec	R1+1
    746  1592				   restoresigns4
    747  1592		       c6 54		      dec	R1
    748  1594		       a5 54		      lda	R1
    749  1596		       49 ff		      eor	#$ff
    750  1598		       85 54		      sta	R1
    751  159a		       a5 55		      lda	R1+1
    752  159c		       49 ff		      eor	#$ff
    753  159e		       85 55		      sta	R1+1
    754  15a0							;
    755  15a0				   restoresigns2
    756  15a0		       60		      rts
    757  15a1							;
    758  15a1							;=====================================================
    759  15a1							; Skip over spaces.  Returns Y with the offset to
    760  15a1							; either the last character in the line, or the first
    761  15a1							; non-space character.
    762  15a1							;
    763  15a1
    764  15a1		       c8	   skipsp2    iny
    765  15a2		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  15a4		       f0 04		      beq	Skip3	;end of line
    767  15a6		       c9 20		      cmp	#SPACE
    768  15a8		       f0 f7		      beq	skipsp2
    769  15aa		       60	   Skip3      rts
    770  15ab							;*********************************************************
    771  15ab							; Output a CR/LF combination to the console.  Preserves
    772  15ab							; all registers.
    773  15ab							;
    774  15ab		       48	   tbcrlf     pha
    775  15ac		       a9 0d		      lda	#CR
    776  15ae		       20 f4 16 	      jsr	VOUTCH
    777  15b1		       a9 0a		      lda	#LF
    778  15b3		       20 f4 16 	      jsr	VOUTCH
    779  15b6		       68		      pla
    780  15b7		       60		      rts
    781  15b8							;
    782  15b8							;=====================================================
    783  15b8							; Some logic to print the Line of basic code being executed
    784  15b8		       24 40	   idbgBasic  bit	ILTrace
    785  15ba		       50 70		      bvc	dbgBasicNone
    786  15bc		       98		      tya
    787  15bd		       48		      pha
    788  15be		       20 7d 17 	      jsr	SetOutDebug
    789  15c1		       20 1d 17 	      jsr	PrtPrgLine
    790  15c4		       20 ab 15 	      jsr	CRLF
    791  15c7		       a5 40		      lda	ILTrace
    792  15c9		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  15cb		       f0 5a		      beq	dbgBasicDone
    794  15cd		       20 88 17 	      jsr	SetInDebug
    795  15d0		       20 fa 16 	      jsr	puts
      0  15d3					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  15d3		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1610				   dbgBasicLoop
    798  1610		       20 f7 16 	      jsr	VGETCH
    799  1613		       20 ab 15 	      jsr	CRLF
    800  1616		       20 e7 16 	      jsr	SetInConsole
    801  1619
    802  1619		       c9 73		      cmp	#'s	; Quit program
    803  161b		       f0 12		      beq	dbgBasicStop
    804  161d
    805  161d		       c9 64		      cmp	#'d	; Display Variables
    806  161f		       d0 06		      bne	dbgBasicDone
    807  1621
    808  1621		       20 ac 17 	      jsr	PrintAllVars
    809  1624		       18		      clc
    810  1625		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1627
    812  1627		       20 da 16    dbgBasicDone jsr	SetOutConsole
    813  162a		       68		      pla
    814  162b		       a8		      tay
    815  162c		       4c bb 02    dbgBasicNone jmp	NextIL
    816  162f
    817  162f				   dbgBasicStop
    818  162f		       20 da 16 	      jsr	SetOutConsole
    819  1632		       68		      pla
    820  1633		       a8		      tay
    821  1634		       4c 01 06 	      jmp	iFIN
    822  1637							;
    823  1637							;=====================================================
    824  1637							; This is some debug logic which displays the current
    825  1637							; value of the ILPC and the line buffer.
    826  1637							;
    827  1637		       24 40	   dbgLine    bit	ILTrace
    828  1639		       30 01		      bmi	dbgPrt
    829  163b		       60		      rts
    830  163c				   dbgPrt
    831  163c		       20 7d 17 	      jsr	SetOutDebug
    832  163f		       20 fa 16 	      jsr	puts
      0  1642					      db	"ILPC: ",0
      1  1642		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  1649		       a5 44		      lda	ILPC+1
    835  164b		       20 99 0d 	      jsr	OUTHEX
    836  164e		       a5 43		      lda	ILPC
    837  1650		       20 99 0d 	      jsr	OUTHEX
    838  1653		       a9 20		      lda	#SPACE
    839  1655		       20 f4 16 	      jsr	VOUTCH
    840  1658		       a0 00		      ldy	#0
    841  165a		       b1 43		      lda	(ILPC),y
    842  165c		       20 99 0d 	      jsr	OUTHEX
    843  165f							;
    844  165f							; Display the CURPTR value and offset
    845  165f							;
    846  165f		       20 fa 16 	      jsr	puts
      0  1662					      db	", CURPTR: ",0
      1  1662		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  166d		       a5 50		      lda	CURPTR+1
    849  166f		       20 99 0d 	      jsr	OUTHEX
    850  1672		       a5 4f		      lda	CURPTR
    851  1674		       20 99 0d 	      jsr	OUTHEX
    852  1677		       a9 2b		      lda	#'+
    853  1679		       20 f4 16 	      jsr	VOUTCH
    854  167c		       a5 51		      lda	CUROFF
    855  167e		       20 99 0d 	      jsr	OUTHEX
    856  1681							;
    857  1681		       20 ab 15 	      jsr	CRLF
    858  1684		       20 da 16 	      jsr	SetOutConsole
    859  1687		       20 ba 16 	      jsr	ILChkRange
    860  168a		       b0 02		      bcs	dbgLineErr
    861  168c		       18		      clc
    862  168d		       60		      rts
    863  168e
    864  168e				   dbgLineErr
    865  168e		       20 7d 17 	      jsr	SetOutDebug
    866  1691		       20 fa 16 	      jsr	puts
      0  1694					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1694		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  16b5		       20 da 16 	      jsr	SetOutConsole
    869  16b8		       38		      sec
    870  16b9		       60		      rts
    871  16ba
    872  16ba		       a5 44	   ILChkRange lda	ILPC+1
    873  16bc		       c9 19		      cmp	#IL>>8
    874  16be		       90 18		      bcc	ILBadRange
    875  16c0		       d0 06		      bne	ILChkHigh
    876  16c2
    877  16c2		       a5 43		      lda	ILPC
    878  16c4		       c9 04		      cmp	#IL&$ff
    879  16c6		       90 10		      bcc	ILBadRange
    880  16c8
    881  16c8		       a5 44	   ILChkHigh  lda	ILPC+1
    882  16ca		       c9 1d		      cmp	#ILEND>>8
    883  16cc		       90 08		      bcc	ILGoodRange
    884  16ce		       d0 08		      bne	ILBadRange
    885  16d0
    886  16d0		       a5 43		      lda	ILPC
    887  16d2		       c9 cf		      cmp	#ILEND&$ff
    888  16d4		       b0 02		      bcs	ILBadRange
    889  16d6
    890  16d6		       18	   ILGoodRange clc
    891  16d7		       60		      rts
    892  16d8				   ILBadRange
    893  16d8		       38		      sec
    894  16d9		       60		      rts
    895  16da
    896  16da
    897  16da							;=====================================================
    898  16da							; Set output vector to the console output function
    899  16da							;
    900  16da				   SetOutConsole
    901  16da		       48		      pha
    902  16db		       a9 0c		      lda	#OUTCH&$ff
    903  16dd		       8d 31 27 	      sta	BOutVec
    904  16e0		       a9 f0		      lda	#OUTCH>>8
    905  16e2		       8d 32 27 	      sta	BOutVec+1
    906  16e5		       68		      pla
    907  16e6		       60		      rts
    908  16e7
    909  16e7				   SetInConsole
    910  16e7		       48		      pha
    911  16e8		       a9 09		      lda	#GETCH&$ff
    912  16ea		       8d 33 27 	      sta	BInVec
    913  16ed		       a9 f0		      lda	#GETCH>>8
    914  16ef		       8d 34 27 	      sta	BInVec+1
    915  16f2		       68		      pla
    916  16f3		       60		      rts
    917  16f4
    918  16f4							;=====================================================
    919  16f4							; Jump to the output/input function in BOutVec/BInVec
    920  16f4							;
    921  16f4		       6c 31 27    VOUTCH     jmp	(BOutVec)
    922  16f7		       6c 33 27    VGETCH     jmp	(BInVec)
    923  16fa							;
    924  16fa							;=====================================================
    925  16fa							; Print the string that immediately follows the JSR to
    926  16fa							; this function.  Stops when a null byte is found,
    927  16fa							; then returns to the instruction immediately
    928  16fa							; following the null.
    929  16fa							;
    930  16fa							; Thanks to Ross Archer for this code.
    931  16fa							; http://www.6502.org/source/io/primm.htm
    932  16fa							;
    933  16fa
    934  16fa		       68	   tbputs     pla		;Get the low part of "return" address
    935  16fb							;(data start address)
    936  16fb		       85 5e		      sta	PrtFrom
    937  16fd		       68		      pla
    938  16fe		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    939  1700							;(data start address)
    940  1700							;Note: actually we're pointing one short
    941  1700		       a0 01	   PSINB      ldy	#1
    942  1702		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    943  1704		       e6 5e		      inc	PrtFrom	;update the pointer
    944  1706		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    945  1708		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    946  170a		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    947  170c							;   Accumulator
    948  170c		       f0 06		      beq	PSIX1	;don't print the final NULL
    949  170e		       20 f4 16 	      jsr	VOUTCH	;write it out
    950  1711		       4c 00 17 	      jmp	PSINB	;back around
    951  1714		       e6 5e	   PSIX1      inc	PrtFrom
    952  1716		       d0 02		      bne	PSIX2
    953  1718		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    954  171a		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    955  171d
    956  171d							;
    957  171d
    958  171d							;====================================================
    959  171d		       27 35	   PrtTerm    equ	tempy
    960  171d
    961  171d							; on exit Print Y has the offset to use
    962  171d							; input y =	 addr low
    963  171d							;	 x =	 addr high
    964  171d							;	 a =	 termination string
    965  171d
    966  171d				   PrtPrgLine
    967  171d		       a9 00		      lda	#0
    968  171f		       8d 35 27 	      sta	PrtTerm
    969  1722		       f0 05		      beq	PrtPrgText
    970  1724
    971  1724		       a9 22	   PrtQuoted  lda	#'"
    972  1726		       8d 35 27 	      sta	PrtTerm
    973  1729
    974  1729		       a4 51	   PrtPrgText ldy	CUROFF
    975  172b		       a5 4f		      lda	CURPTR
    976  172d		       85 5e		      sta	PrtFrom
    977  172f		       a5 50		      lda	CURPTR+1
    978  1731		       85 5f		      sta	PrtFrom+1
    979  1733		       4c 3f 17 	      jmp	PrtLoop
    980  1736
    981  1736							; Print a string pointed to by x= h, y=l terminated by a
    982  1736							; Return y as the length
    983  1736
    984  1736		       86 5f	   PrtStr     stx	PrtFrom+1
    985  1738		       84 5e		      sty	PrtFrom
    986  173a		       8d 35 27 	      sta	PrtTerm
    987  173d		       a0 00		      ldy	#0
    988  173f							;
    989  173f							; On entry here ptrfrom and prtterm point to area to print
    990  173f							;
    991  173f		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    992  1741		       cd 35 27 	      cmp	PrtTerm
    993  1744		       f0 0b		      beq	PrtEnd
    994  1746		       c9 00		      cmp	#0	; always end if 0 is found
    995  1748		       f0 07		      beq	PrtEnd
    996  174a		       20 f4 16 	      jsr	VOUTCH
    997  174d		       c8		      iny
    998  174e		       4c 3f 17 	      jmp	PrtLoop
    999  1751		       c8	   PrtEnd     iny		;return byte after the copy
   1000  1752		       60		      rts
   1001  1753
   1002  1753							;====================================================
   1003  1753							;Clear the terminal assume it is ansii or vt100
   1004  1753							;
   1005  1753				   iCLEARSCREEN
   1006  1753		       20 fa 16 	      jsr	puts
      0  1756					      db	$1b,'[,'2,'J,0
      1  1756		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
   1008  175b		       4c bb 02 	      jmp	NextIL
   1009  175e
   1010  175e							;====================================================
   1011  175e							; Push true and false onto math stack
   1012  175e				   pushTrue
   1013  175e		       a9 ff		      lda	#$ff
   1014  1760		       85 52	   pushTF     sta	R0
   1015  1762		       85 53		      sta	R0+1
   1016  1764		       20 6e 14 	      jsr	pushR0
   1017  1767		       60		      rts
   1018  1768		       a9 00	   pushFalse  lda	#0
   1019  176a		       f0 f4		      beq	pushTF
   1020  176c
   1021  176c							;======================================================
   1022  176c							; Copy stack top to R1
   1023  176c				   CopyStackR1
   1024  176c		       98		      tya
   1025  176d		       48		      pha
   1026  176e		       a4 4a		      ldy	MATHSTACKPTR
   1027  1770		       88		      dey
   1028  1771		       b1 48		      lda	(MATHSTACK),y
   1029  1773		       85 55		      sta	R1+1
   1030  1775		       88		      dey
   1031  1776		       b1 48		      lda	(MATHSTACK),y
   1032  1778		       85 54		      sta	R1
   1033  177a		       68		      pla
   1034  177b		       a8		      tay
   1035  177c		       60		      rts
   1036  177d
   1037  177d
   1038  177d							;====================================================
   1039  177d							;Swap the out debug call for standard calls
   1040  177d
   1041  177d				   SetOutDebug
   1042  177d					      if	USEDEBUGPORT
   1043  177d		       a9 9d		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1044  177f		       8d 31 27 	      sta	BOutVec
   1045  1782		       a9 17		      lda	#OUTDEBUG>>8
   1046  1784		       8d 32 27 	      sta	BOutVec+1
   1047  1787					      endif
   1048  1787		       60		      rts
   1049  1788				   SetInDebug
   1050  1788					      if	USEDEBUGPORT
   1051  1788		       a9 a1		      lda	#INDEBUG&$ff
   1052  178a		       8d 33 27 	      sta	BInVec
   1053  178d		       a9 17		      lda	#INDEBUG>>8
   1054  178f		       8d 34 27 	      sta	BInVec+1
   1055  1792					      endif
   1056  1792		       60		      rts
   1057  1793							;
   1058  1793							;====================================================
   1059  1793							; Output to the debug console
   1060  1793							;     x = high address byte
   1061  1793							;     y = low address byte
   1062  1793							;     a = Terminator for string
   1063  1793				   DebugWrite
   1064  1793		       20 7d 17 	      jsr	SetOutDebug
   1065  1796		       20 36 17 	      jsr	PrtStr
   1066  1799		       20 da 16 	      jsr	SetOutConsole
   1067  179c		       60		      rts
   1068  179d
   1069  179d				   OUTDEBUG
   1070  179d		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1071  17a0		       60		      RTS
   1072  17a1
   1073  17a1		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1074  17a4		       29 01		      and	#$01
   1075  17a6		       f0 f9		      beq	INDEBUG
   1076  17a8		       ad 21 e0 	      lda	DEBUGPORT+1
   1077  17ab		       60		      rts
   1078  17ac							;
   1079  17ac							;=======================================================
   1080  17ac							; Print all Variables
   1081  17ac				   PrintAllVars
   1082  17ac		       a0 00		      ldy	#0
   1083  17ae		       a9 41		      lda	#'A
   1084  17b0				   PrintAllVarsLoop
   1085  17b0		       48		      pha
   1086  17b1		       b1 41		      lda	(VARIABLES),y
   1087  17b3		       85 52		      sta	R0
   1088  17b5		       c8		      iny
   1089  17b6		       b1 41		      lda	(VARIABLES),y
   1090  17b8		       85 53		      sta	R0+1
   1091  17ba
   1092  17ba		       68		      pla		;get the current letter
   1093  17bb		       48		      pha
   1094  17bc		       20 f4 16 	      jsr	VOUTCH
   1095  17bf		       20 fa 16 	      jsr	puts
      0  17c2					      db	"=",0
      1  17c2		       3d 00		      .byte.b	"=",0
   1097  17c4		       68		      pla
   1098  17c5		       aa		      tax
   1099  17c6		       e8		      inx
   1100  17c7		       8a		      txa
   1101  17c8		       48		      pha		;
   1102  17c9
   1103  17c9		       98		      tya
   1104  17ca		       48		      pha
   1105  17cb		       20 00 0d 	      jsr	PrintDecimal
   1106  17ce		       20 fa 16 	      jsr	puts
      0  17d1					      db	" ",0
      1  17d1		       20 00		      .byte.b	" ",0
   1108  17d3		       68		      pla
   1109  17d4		       a8		      tay
   1110  17d5		       c8		      iny
   1111  17d6		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1112  17d8		       90 d6		      bcc	PrintAllVarsLoop
   1113  17da		       20 ab 15 	      jsr	CRLF
   1114  17dd
   1115  17dd		       68		      pla
   1116  17de		       60		      rts
   1117  17df
   1118  17df
   1119  17df
   1120  17df
   1121  17df
   1122  17df
   1123  17df
   1124  17df
   1125  17df
   1126  17df
   1127  17df
   1128  17df
   1129  17df
   1130  17df
   1131  17df
   1132  17df
   1133  17df
   1134  17df
   1135  17df
------- FILE mytb.asm
   2208  17df
   2209  17df					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  17df					      include	"storage.asm"
      1  17df							;
      2  17df							;=====================================================
      3  17df							;=====================================================
      4  17df							;=====================================================
      5  17df							; This file contains the functions for saving and
      6  17df							; restoring programs from some sort of mass storage
      7  17df							; device.  This particular version is for using the
      8  17df							; Corsham Tech SD Card System.
      9  17df							;=====================================================
     10  17df							;=====================================================
     11  17df							;=====================================================
     12  17df
     13 U1dcf					      seg.u	TBData
     14 U1dcf		       00	   diskBufLength ds	1
     15 U1dd0		       00	   diskBufOffset ds	1
     16 U1dd1		       00 00 00 00*DiskFileName ds	14
     17 U1ddf
     18  17df					      SEG	Code
     19  17df
     20  17df							;
     21  17df							;=====================================================
     22  17df							; Open a file for reading as a program.  The next
     23  17df							; thing on the line should be the filename.
     24  17df							;
     25  17df				   iOPENREAD
     26  17df					      if	XKIM || CTMON65
     27  17df		       a4 51		      ldy	CUROFF
     28  17e1		       b1 4f		      lda	(CURPTR),y
     29  17e3		       d0 07		      bne	iOPENfn	;might be filename
     30  17e5							;
     31  17e5							; No filename supplied.
     32  17e5							;
     33  17e5		       a9 00	   iOPENnofn  lda	#0
     34  17e7		       a2 09		      ldx	#ERR_NO_FILENAME
     35  17e9		       4c 18 06 	      jmp	iErr2
     36  17ec							;
     37  17ec							; Add the offset into the buffer start
     38  17ec							;
     39  17ec		       18	   iOPENfn    clc
     40  17ed		       98		      tya
     41  17ee		       65 4f		      adc	CURPTR
     42  17f0		       a8		      tay		;LSB
     43  17f1		       a5 50		      lda	CURPTR+1
     44  17f3		       69 00		      adc	#0
     45  17f5		       aa		      tax
     46  17f6		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  17f9		       90 07		      bcc	Ropenok	;branch if opened ok
     48  17fb							;
     49  17fb							; Open failed
     50  17fb							;
     51  17fb		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  17fd		       a9 00	   Rdfail2    lda	#0
     53  17ff		       4c 18 06 	      jmp	iErr2
     54  1802							;
     55  1802							; Clear counts and offsets so the next read will
     56  1802							; cause the file to be read.
     57  1802							;
     58  1802		       a9 00	   Ropenok    lda	#0
     59  1804		       8d d0 1d 	      sta	diskBufOffset
     60  1807		       8d cf 1d 	      sta	diskBufLength
     61  180a		       4c bb 02 	      jmp	NextIL
     62  180d					      endif
     63  180d
     64  180d							;
     65  180d							;==============================JUSTLOSTINTIME 08/02/2022========
     66  180d							;Remove a file from the disk
     67  180d				   iRMFILE
     68  180d					      if	XKIM || CTMON65
     69  180d		       a4 51		      ldy	CUROFF
     70  180f		       b1 4f		      lda	(CURPTR),y
     71  1811		       f0 19		      beq	iRMnofn
     72  1813							;
     73  1813		       18		      clc
     74  1814		       98		      tya
     75  1815		       65 4f		      adc	CURPTR
     76  1817		       a8		      tay		;LSB
     77  1818		       a5 50		      lda	CURPTR+1
     78  181a		       69 00		      adc	#0
     79  181c		       aa		      tax
     80  181d		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1820		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1822		       a9 00		      lda	#0
     83  1824		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1826		       4c 18 06 	      jmp	iErr2
     85  1829		       4c bb 02    wrmOk      jmp	NextIL
     86  182c
     87  182c							; No filename supplied.
     88  182c							;
     89  182c		       a9 00	   iRMnofn    lda	#0
     90  182e		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1830		       4c 18 06 	      jmp	iErr2
     92  1833					      endif
     93  1833							;
     94  1833							;=====================================================
     95  1833				   iOPENWRITE
     96  1833					      if	XKIM || CTMON65
     97  1833		       a4 51		      ldy	CUROFF
     98  1835		       b1 4f		      lda	(CURPTR),y
     99  1837		       f0 f3		      beq	iRMnofn
    100  1839							;
    101  1839		       18		      clc
    102  183a		       98		      tya
    103  183b		       65 4f		      adc	CURPTR
    104  183d		       a8		      tay		;LSB
    105  183e		       a5 50		      lda	CURPTR+1
    106  1840		       69 00		      adc	#0
    107  1842		       aa		      tax
    108  1843		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1846		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1848							;
    111  1848							; Open failed
    112  1848							;
    113  1848		       a9 00	   Wdfail     lda	#0
    114  184a		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  184c		       4c 18 06 	      jmp	iErr2
    116  184f							;
    117  184f		       4c bb 02    Wopenok    jmp	NextIL
    118  1852					      endif
    119  1852							;
    120  1852							;=====================================================
    121  1852							; Gets a line of input from the disk file and puts it
    122  1852							; into LINBUF.
    123  1852							;
    124  1852							; On exit:
    125  1852							;    CURPTR points to LINBUF
    126  1852							;    LINBUF contains the line with 0 at the end.
    127  1852							;    Y has offset to first non-space character
    128  1852							;    CURROFF has the same as Y.
    129  1852							;
    130  1852				   iDGETLINE
    131  1852					      if	XKIM || CTMON65
    132  1852		       a2 a0		      ldx	#LINBUF&$ff
    133  1854		       86 4f		      stx	CURPTR
    134  1856		       a2 26		      ldx	#LINBUF>>8
    135  1858		       86 50		      stx	CURPTR+1
    136  185a							;
    137  185a		       a2 00		      ldx	#0	;offset
    138  185c		       8e 24 27    iDgetLoop  stx	getlinx
    139  185f		       20 bd 18 	      jsr	getNextFileByte
    140  1862		       b0 16		      bcs	iGetEOF
    141  1864		       c9 0d		      cmp	#CR
    142  1866		       f0 0d		      beq	iGetEOL
    143  1868		       c9 0a		      cmp	#LF
    144  186a		       f0 09		      beq	iGetEOL
    145  186c		       ae 24 27 	      ldx	getlinx
    146  186f		       9d a0 26 	      sta	LINBUF,x
    147  1872		       e8		      inx
    148  1873		       d0 e7		      bne	iDgetLoop
    149  1875							;
    150  1875							; Handle end of line.	If the line has nothing, loop
    151  1875							; back and get another line.
    152  1875							;
    153  1875		       ae 24 27    iGetEOL    ldx	getlinx	;blank line?
    154  1878		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  187a							;
    156  187a							; This can fall through when there is a line, or
    157  187a							; called directly when EOF is encountered.
    158  187a							;
    159  187a		       ae 24 27    iGetEOF    ldx	getlinx
    160  187d		       a9 00		      lda	#0
    161  187f		       9d a0 26 	      sta	LINBUF,x
    162  1882		       85 51		      sta	CUROFF
    163  1884		       a0 00		      ldy	#0
    164  1886		       20 a2 15 	      jsr	SkipSpaces
    165  1889		       4c bb 02 	      jmp	NextIL
    166  188c					      endif
    167  188c
    168  188c							;
    169  188c							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  188c							; DISK
    171  188c							;
    172  188c				   iDDIR
    173  188c					      if	XKIM || CTMON65
    174  188c		       20 30 f0 	      jsr	DiskDir
    175  188f							;
    176  188f							; Get/Display each entry
    177  188f							;
    178  188f		       a2 1d	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  1891		       a0 d1		      ldy	#DiskFileName&$ff
    180  1893		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  1896		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  1898		       20 fa 16 	      jsr	puts
      0  189b					      db	"   ",0
      1  189b		       20 20 20 00	      .byte.b	"   ",0
    184  189f							; Print the line to the console
    185  189f		       a2 1d		      ldx	#DiskFileName>>8	;pointer to buffer
    186  18a1		       a0 d1		      ldy	#DiskFileName&$ff
    187  18a3		       a5 00		      lda	0
    188  18a5		       20 36 17 	      jsr	PrtStr	;else print name
    189  18a8		       20 18 f0 	      jsr	crlf
    190  18ab
    191  18ab		       4c 8f 18 	      jmp	DiskDirLoop	;do next entry
    192  18ae
    193  18ae		       4c bb 02    DiskDirEnd jmp	NextIL
    194  18b1					      endif
    195  18b1							;
    196  18b1							;=====================================================
    197  18b1							; Does a LIST to a Disk file.
    198  18b1							;
    199  18b1				   iDLIST
    200  18b1					      if	XKIM || CTMON65
    201  18b1		       20 ec 18 	      jsr	SetOutDisk
    202  18b4		       4c e8 07 	      jmp	iLST2
    203  18b7					      endif
    204  18b7							;
    205  18b7							;=====================================================
    206  18b7							; Closes any pending disk file.  Okay to call if there
    207  18b7							; is no open file.
    208  18b7							;
    209  18b7				   iDCLOSE
    210  18b7					      if	XKIM || CTMON65
    211  18b7		       20 42 f0 	      jsr	DiskClose
    212  18ba		       4c bb 02 	      jmp	NextIL
    213  18bd					      endif
    214  18bd							;
    215  18bd							;=====================================================
    216  18bd							; This gets the next byte from an open disk file.  If
    217  18bd							; there are no more bytes left, this returns C set.
    218  18bd							; Else, C is clear and A contains the character.
    219  18bd							;
    220  18bd				   getNextFileByte
    221  18bd					      if	XKIM || CTMON65
    222  18bd		       ae d0 1d 	      ldx	diskBufOffset
    223  18c0		       ec cf 1d 	      cpx	diskBufLength
    224  18c3		       d0 14		      bne	hasdata	;branch if still data
    225  18c5							;
    226  18c5							; There is no data left in the buffer, so read a
    227  18c5							; block from the SD system.
    228  18c5							;
    229  18c5		       a9 84		      lda	#BUFFER_SIZE
    230  18c7		       a2 df		      ldx	#buffer>>8
    231  18c9		       a0 0a		      ldy	#buffer&$ff
    232  18cb		       20 3c f0 	      jsr	DiskRead
    233  18ce		       b0 12		      bcs	getNextEof
    234  18d0							;
    235  18d0							; A contains the number of bytes actually read.
    236  18d0							;
    237  18d0		       8d cf 1d 	      sta	diskBufLength	;save length
    238  18d3		       c9 00		      cmp	#0	;shouldn't happen
    239  18d5		       f0 0b		      beq	getNextEof
    240  18d7							;
    241  18d7		       a2 00		      ldx	#0
    242  18d9		       bd 0a df    hasdata    lda	buffer,x
    243  18dc		       e8		      inx
    244  18dd		       8e d0 1d 	      stx	diskBufOffset
    245  18e0		       18		      clc
    246  18e1		       60		      rts
    247  18e2							;
    248  18e2		       a9 00	   getNextEof lda	#0
    249  18e4		       8d d0 1d 	      sta	diskBufOffset
    250  18e7		       8d cf 1d 	      sta	diskBufLength
    251  18ea		       38		      sec
    252  18eb		       60		      rts
    253  18ec							;
    254  18ec							;=====================================================
    255  18ec							; Set output vector to the disk output function
    256  18ec							;
    257  18ec		       a9 f7	   SetOutDisk lda	#DOUT&$ff
    258  18ee		       8d 31 27 	      sta	BOutVec
    259  18f1		       a9 18		      lda	#DOUT/256
    260  18f3		       8d 32 27 	      sta	BOutVec+1
    261  18f6		       60		      rts
    262  18f7							;
    263  18f7							;=====================================================
    264  18f7
    265  18f7		       8d 0a df    DOUT       sta	buffer
    266  18fa		       a9 01		      lda	#1
    267  18fc		       a0 0a		      ldy	#buffer&$ff
    268  18fe		       a2 df		      ldx	#buffer>>8
    269  1900		       20 3f f0 	      jsr	DiskWrite
    270  1903							;
    271  1903							; need error checking here
    272  1903							;
    273  1903		       60		      rts
    274  1904					      endif
    275  1904
    276  1904
------- FILE mytb.asm
   2211  1904					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1904					      include	"IL.inc"
      1  1904
      2  1904							;=====================================================
      3  1904							; IL.inc
      4  1904							; These are macros for IL instructions
      5  1904							;
      6  1904					      mac	dw
      7  1904					      .word	{0}
      8  1904					      endm
      9  1904					      mac	db
     10  1904					      .byte	{0}
     11  1904					      endm
     12  1904					      macro	xinit
     13  1904					      db	0
     14  1904					      endm		;reset the il to start clear all
     15  1904							;
     16  1904					      macro	done
     17  1904					      db	1
     18  1904					      endm		;print an error if not end of line
     19  1904							;
     20  1904					      macro	prs
     21  1904					      db	2
     22  1904					      endm		;print a quoted string
     23  1904							;
     24  1904					      macro	prn
     25  1904					      db	3
     26  1904					      endm		;print a number
     27  1904							;
     28  1904					      macro	spc
     29  1904					      db	4
     30  1904					      endm		;print space til new tabstop
     31  1904							;
     32  1904					      macro	nline
     33  1904					      db	5
     34  1904					      endm		;print a new line crlf
     35  1904							;
     36  1904							; My NXT is a bit different in that it takes one
     37  1904							; parameter, which is an address.  If the BASIC
     38  1904							; program is currently running then move to the
     39  1904							; next line and continue execution.  However, if
     40  1904							; in direct mode, jump to the specified IL label.
     41  1904							;
     42  1904					      macro	nxt
     43  1904					      db	6
     44  1904					      dw	{1}	; addr
     45  1904					      endm		; addr
     46  1904							;
     47  1904					      macro	xfer
     48  1904					      db	7
     49  1904					      endm
     50  1904							;
     51  1904					      macro	sav
     52  1904					      db	8
     53  1904					      db	{1}
     54  1904					      endm
     55  1904							;
     56  1904					      macro	rstr
     57  1904					      db	9
     58  1904					      endm
     59  1904							;
     60  1904					      macro	cmpr
     61  1904					      db	10
     62  1904					      endm
     63  1904							;
     64  1904					      macro	innum
     65  1904					      db	11
     66  1904					      endm
     67  1904							;
     68  1904					      macro	fin
     69  1904					      db	12
     70  1904					      endm
     71  1904							;
     72  1904							; ERR is followed by an error number.	The error
     73  1904							; code is printed along with the line number.
     74  1904							; Control is passed to the statement set with
     75  1904							; the ERRGOTO statement.
     76  1904							;
     77  1904					      macro	errmsg
     78  1904					      db	13
     79  1904					      dw	{1}	;ecode
     80  1904					      endm		;ecode
     81  1904							;
     82  1904					      macro	add
     83  1904					      db	14
     84  1904					      endm
     85  1904							;
     86  1904					      macro	sub
     87  1904					      db	15
     88  1904					      endm
     89  1904							;
     90  1904					      macro	neg
     91  1904					      db	16
     92  1904					      endm
     93  1904							;
     94  1904					      macro	mul
     95  1904					      db	17
     96  1904					      endm
     97  1904							;
     98  1904					      macro	div
     99  1904					      db	18
    100  1904					      endm
    101  1904							;
    102  1904					      macro	store
    103  1904					      db	19
    104  1904					      endm
    105  1904							;
    106  1904					      macro	ind
    107  1904					      db	20
    108  1904					      endm
    109  1904							;
    110  1904					      macro	lst
    111  1904					      db	21
    112  1904					      endm
    113  1904							;
    114  1904					      macro	init
    115  1904					      db	22
    116  1904					      endm
    117  1904							;
    118  1904					      macro	getline
    119  1904					      db	23
    120  1904					      endm
    121  1904							;
    122  1904					      macro	insert
    123  1904					      db	24
    124  1904					      endm
    125  1904							;
    126  1904					      macro	rtn
    127  1904					      db	25
    128  1904					      endm
    129  1904							;
    130  1904					      macro	exit
    131  1904					      db	26
    132  1904					      endm
    133  1904							;
    134  1904					      macro	lit
    135  1904					      db	27
    136  1904					      dw	{1}	;value
    137  1904					      endm		; value LIT
    138  1904							;
    139  1904					      macro	call
    140  1904					      db	28
    141  1904					      dw	{1}	;addr
    142  1904					      endm		;addr
    143  1904							;
    144  1904							; IJMP will set the IL PC to the specified value.
    145  1904							;
    146  1904					      macro	ijmp
    147  1904					      db	29
    148  1904					      dw	{1}	;addr
    149  1904					      endm		;addr
    150  1904							;
    151  1904					      macro	vinit
    152  1904					      db	30
    153  1904					      endm
    154  1904							;
    155  1904							; ERRGOTO sets the point in the code where the IL
    156  1904							; interpreter will go after any error.
    157  1904							;
    158  1904					      macro	errgoto
    159  1904					      db	31
    160  1904					      dw	{1}	;addr
    161  1904					      endm		;addr
    162  1904							;
    163  1904					      macro	tst
    164  1904					      db	32
    165  1904					      db	({1}-*)-1	;(addr-*)-1
    166  1904					      db	{2},0	;string,0
    167  1904					      endm		;addr,string
    168  1904							;
    169  1904					      macro	tstv
    170  1904					      db	33
    171  1904					      db	({1}-*)-1	;(addr-*)-1
    172  1904					      endm		;addr
    173  1904							;
    174  1904					      macro	tstl
    175  1904					      db	34
    176  1904					      db	({1}-*)-1	;(addr-*)-1
    177  1904					      endm		;addr
    178  1904							;
    179  1904					      macro	tstn
    180  1904					      db	35
    181  1904					      db	({1}-*)-1	;(addr-*)-1
    182  1904					      endm		;addr
    183  1904							;
    184  1904							; FREE returns the amount of free RAM on top of
    185  1904							; the stack.  This is the amount of room the user
    186  1904							; program has available.
    187  1904							;
    188  1904					      macro	free
    189  1904					      db	36
    190  1904					      endm
    191  1904							;
    192  1904							; RANDOM takes the top item off the stack and
    193  1904							; replaces it with a random number that is
    194  1904							; MOD the initial value.  Ie, if the TOS is
    195  1904							; 42 then RANDOM returns a value from 0 to 41.
    196  1904							;
    197  1904					      macro	random
    198  1904					      db	37
    199  1904					      endm
    200  1904							;
    201  1904							; ABS will replace the top of stack with the
    202  1904							; absolute value.
    203  1904							;
    204  1904					      macro	abs
    205  1904					      db	38
    206  1904					      endm
    207  1904							;
    208  1904							; OPENREAD opens a file for reading, as in getting
    209  1904							; statements from it.
    210  1904							;
    211  1904					      macro	openread
    212  1904					      db	39
    213  1904					      endm
    214  1904							;
    215  1904							; OPENWRITE opens a file for writing, as in saving
    216  1904							; the current program to it.
    217  1904							;
    218  1904					      macro	openwrite
    219  1904					      db	40
    220  1904					      endm
    221  1904							;
    222  1904							; DCLOSE closes any open disk file.
    223  1904							;
    224  1904					      macro	dclose
    225  1904					      db	41
    226  1904					      endm
    227  1904							;
    228  1904							; DGETLINE gets one line from the disk file and puts it
    229  1904							; into LINBUFF.
    230  1904							;
    231  1904					      macro	dgetline
    232  1904					      db	42
    233  1904					      endm
    234  1904							;
    235  1904							; DLIST saves the program to an open disk file.
    236  1904							;
    237  1904					      macro	dlist
    238  1904					      db	43
    239  1904					      endm
    240  1904							; DDIR list the current directory
    241  1904							;
    242  1904					      macro	ddir
    243  1904					      db	44
    244  1904					      endm
    245  1904
    246  1904							; RMFILE remove a fle from disk
    247  1904					      macro	rmfile
    248  1904					      db	45
    249  1904					      endm
    250  1904
    251  1904							; CLEARSCREEN clear the screen
    252  1904					      macro	clearscreen
    253  1904					      db	46
    254  1904					      endm
    255  1904							; POKEMEM Poke value into memory
    256  1904					      macro	pokemem
    257  1904					      db	47
    258  1904					      endm
    259  1904							; PEEKMEM peek at value in memory
    260  1904					      macro	peekmem
    261  1904					      db	48
    262  1904					      endm
    263  1904							; TSTLET Test if the statement is a let without the keyword let
    264  1904					      macro	tstlet
    265  1904					      db	49
    266  1904					      db	({1}-*)-1	;(addr-*)-1
    267  1904					      endm		;addr
    268  1904							; TSTDONE if we reach the end of a statement
    269  1904					      macro	tstdone
    270  1904					      db	50
    271  1904					      db	({1}-*)-1	;(addr-*)-1
    272  1904					      endm		;addr
    273  1904							; GETCHAR	get a character from the input line leave it in RO
    274  1904					      macro	getchar
    275  1904					      db	51
    276  1904					      endm
    277  1904							; PUTCHAR	Put a character to the terminal
    278  1904					      macro	putchar
    279  1904					      db	52
    280  1904					      endm
    281  1904							; Call		Call a machine function return a to stack
    282  1904					      macro	callfunc
    283  1904					      db	53
    284  1904					      endm
    285  1904
    286  1904							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1904					      macro	ibranch
    288  1904					      db	54
    289  1904					      endm
    290  1904
    291  1904							; TSTSTR	 Tests for the open quote in a string
    292  1904					      macro	tststr
    293  1904					      db	55
    294  1904					      db	({1}-*)-1	;(addr-*)-1
    295  1904					      endm
    296  1904							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1904					      macro	setirq
    298  1904					      db	56
    299  1904					      endm
    300  1904
    301  1904							; TSTIRQ	Test for irq pending,
    302  1904							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1904					      macro	tstirq
    304  1904					      db	57
    305  1904					      db	({1}-*)-1	;(addr-*)-1
    306  1904					      endm
    307  1904
    308  1904							; IRET    return from interupt service
    309  1904					      macro	iret
    310  1904					      db	58
    311  1904					      endm
    312  1904
    313  1904							; INSTR   read a string from the input
    314  1904					      macro	instr
    315  1904					      db	59
    316  1904					      endm
    317  1904
    318  1904							; MODULO Returns the remainder of the division
    319  1904					      macro	modulo
    320  1904					      db	60
    321  1904					      endm
    322  1904							; Set a task line
    323  1904					      macro	taskcreate
    324  1904					      db	61
    325  1904					      endm
    326  1904							; End a task
    327  1904					      macro	etask
    328  1904					      db	62
    329  1904					      endm
    330  1904							; Skip to next task
    331  1904					      macro	ntask
    332  1904					      db	63
    333  1904					      endm
    334  1904							; Subscript
    335  1904					      macro	subscript
    336  1904					      db	64
    337  1904					      endm
    338  1904							; KILL Task
    339  1904					      macro	taskkill
    340  1904					      db	65
    341  1904					      endm
    342  1904							; STAT Task
    343  1904					      macro	taskstat
    344  1904					      db	66
    345  1904					      endm
    346  1904							;  output value as hex
    347  1904					      macro	hexprt
    348  1904					      db	67
    349  1904					      endm
    350  1904							;  Read in background has completed
    351  1904					      macro	readcomplete
    352  1904					      db	68
    353  1904					      endm
    354  1904							;  ReadInput line
    355  1904					      macro	readstart
    356  1904					      db	69
    357  1904					      endm
    358  1904							; Startio request
    359  1904					      macro	startio
    360  1904					      db	70
    361  1904					      endm
    362  1904							; Endio
    363  1904					      macro	endio
    364  1904					      db	71
    365  1904					      endm
    366  1904							; Logical not
    367  1904					      macro	lognot
    368  1904					      db	72
    369  1904					      endm
    370  1904							; Logical OR
    371  1904					      macro	logor
    372  1904					      db	73
    373  1904					      endm
    374  1904							;Logical and
    375  1904					      macro	logand
    376  1904					      db	74
    377  1904					      endm
    378  1904							;Logical XOR
    379  1904					      macro	logxor
    380  1904					      db	75
    381  1904					      endm
    382  1904							;Wait for task to complete, or list of tasks
    383  1904					      macro	wtask
    384  1904					      db	76
    385  1904					      db	({1}-*)-1	;(addr-*)-1
    386  1904					      endm
    387  1904							;Get the current task id
    388  1904					      MACRO	taskpid
    389  1904					      db	77
    390  1904					      endm
    391  1904							;Trace the basic execution
    392  1904					      Macro	traceprogram
    393  1904					      db	78
    394  1904					      endm
    395  1904							;Do a basic program Trace
    396  1904					      Macro	debugbasic
    397  1904					      db	79
    398  1904					      endm
    399  1904
    400  1904							; Inter Process communications instructions
    401  1904					      Macro	ipcsend
    402  1904					      db	80
    403  1904					      endm
    404  1904					      Macro	ipcreceive
    405  1904					      db	81
    406  1904					      endm
    407  1904					      Macro	ipccheck
    408  1904					      db	82
    409  1904					      endm
    410  1904					      Macro	ipcio
    411  1904					      db	83
    412  1904					      endm
    413  1904					      Macro	pushmathstack
    414  1904					      db	84
    415  1904					      endm
    416  1904					      Macro	popmathstack
    417  1904					      db	85
    418  1904					      endm
    419  1904					      Macro	savemathstack
    420  1904					      db	86
    421  1904					      endm
    422  1904					      Macro	restoremathstack
    423  1904					      db	87
    424  1904					      endm
    425  1904					      Macro	incparmcount
    426  1904					      db	88
    427  1904					      endm
    428  1904					      Macro	taskgetmathstack
    429  1904					      db	89
    430  1904					      endm
    431  1904					      Macro	taskenable
    432  1904					      db	90
    433  1904					      endm
    434  1904					      Macro	tasksuspend
    435  1904					      db	91
    436  1904					      endm
    437  1904					      Macro	taskputmathptr
    438  1904					      db	92
    439  1904					      endm
    440  1904							; Test for an extension type of variable that allows access to a tasks variables
    441  1904							; Using  PID!<Var name>
    442  1904					      Macro	tstvt
    443  1904					      db	93
    444  1904					      db	({1}-*)-1	;(addr-*)-1
    445  1904					      endm
    446  1904
    447  1904							; Provide access to R2 for the IL program
    448  1904					      Macro	setr2
    449  1904					      db	94
    450  1904					      db	{1}	; R2 is only one byte
    451  1904					      endm
    452  1904							;Move stack top to temp
    453  1904					      Macro	stk2tmp
    454  1904					      db	95
    455  1904					      endm
    456  1904
    457  1904					      Macro	tmp2stk
    458  1904					      db	96
    459  1904					      endm
    460  1904
    461  1904					      Macro	tstbyte
    462  1904					      db	97
    463  1904					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1904					      dw	{2}	; address to check
    465  1904					      db	{3}	; Value to compare
    466  1904					      endm
    467  1904
    468  1904					      Macro	incvar
    469  1904					      db	98
    470  1904					      endm
    471  1904					      Macro	decvar
    472  1904					      db	99
    473  1904					      endm
    474  1904
    475  1904					      Macro	slice
    476  1904					      db	100
    477  1904					      endm
    478  1904
    479  1904
    480  1904
------- FILE mytb.asm
   2213  1904							;
   2214  1904				  -	      if	FIXED
   2215  1904				  -	      org	$1000
   2216  1904					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1904					      include	"basic.il"
      1  1904							;LET
      2  1904							;=====================================================
      3  1904							;=====================================================
      4  1904					      seg	Code
      5  1904							;=====================================================
      6  1904							; This is the IL of the BASIC (or whatever) language.
      7  1904							; Because of the way macros are implemented by as65,
      8  1904							; labels can't be on the same line as a macro
      9  1904							; invocation, so that's why labels are on separate
     10  1904							; lines.
     11  1904							;
     12  1904		       19 04	   IL	      equ	*
     13  1904
     14  1904							;THE IL CONTROL SECTION
     15  1904
     16  1904				   START
      0  1904					      INIT		;INITIALIZE
      0  1904					      db	22
      1  1904		       16		      .byte.b	22
      0  1905					      NLINE		;WRITE CRLF
      0  1905					      db	5
      1  1905		       05		      .byte.b	5
      0  1906					      ERRGOTO	CO	;where to go after an error
      0  1906					      db	31
      1  1906		       1f		      .byte.b	31
      0  1907					      dw	CO
      1  1907		       0a 19		      .word.w	CO
      0  1909					      VINIT		;clear all variables
      0  1909					      db	30
      1  1909		       1e		      .byte.b	30
     21  190a							;
     22  190a							; This is where we jump to get a line of commands or
     23  190a							; a program from the user.
     24  190a							;
     25  190a				   CO
      0  190a					      GETLINE		;WRITE PROMPT AND GET LINE
      0  190a					      db	23
      1  190a		       17		      .byte.b	23
      0  190b					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  190b					      db	34
      1  190b		       22		      .byte.b	34
      0  190c					      db	(XEC-*)-1
      1  190c		       04		      .byte.b	(XEC-*)-1
      0  190d					      INSERT		;INSERT IT (MAY BE DELETE)
      0  190d					      db	24
      1  190d		       18		      .byte.b	24
      0  190e					      IJMP	CO
      0  190e					      db	29
      1  190e		       1d		      .byte.b	29
      0  190f					      dw	CO
      1  190f		       0a 19		      .word.w	CO
     30  1911				   XEC
      0  1911					      XINIT		;INITIALIZE
      0  1911					      db	0
      1  1911		       00		      .byte.b	0
     32  1912
     33  1912							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1912				   STMT
      0  1912					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1912					      db	79
      1  1912		       4f		      .byte.b	79
      0  1913					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1913					      db	57
      1  1913		       39		      .byte.b	57
      0  1914					      db	(notirq-*)-1
      1  1914		       00		      .byte.b	(notirq-*)-1
     37  1915				   notirq
      0  1915					      TSTLET	LET	;Test if second field is =
      0  1915					      db	49
      1  1915		       31		      .byte.b	49
      0  1916					      db	(LET-*)-1
      1  1916		       03		      .byte.b	(LET-*)-1
      0  1917					      IJMP	DOLET	;allow the default to be let
      0  1917					      db	29
      1  1917		       1d		      .byte.b	29
      0  1918					      dw	DOLET
      1  1918		       20 19		      .word.w	DOLET
     40  191a				   LET
      0  191a					      TST	S1,"LET"	;IS STATEMENT A LET
      0  191a					      db	32
      1  191a		       20		      .byte.b	32
      0  191b					      db	(S1-*)-1
      1  191b		       21		      .byte.b	(S1-*)-1
      0  191c					      db	"LET",0
      1  191c		       4c 45 54 00	      .byte.b	"LET",0
     42  1920				   DOLET
      0  1920					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1920					      db	33
      1  1920		       21		      .byte.b	33
      0  1921					      db	(ERRVEC-*)-1
      1  1921		       ea		      .byte.b	(ERRVEC-*)-1
      0  1922					      TST	LETBE,"["
      0  1922					      db	32
      1  1922		       20		      .byte.b	32
      0  1923					      db	(LETBE-*)-1
      1  1923		       0a		      .byte.b	(LETBE-*)-1
      0  1924					      db	"[",0
      1  1924		       5b 00		      .byte.b	"[",0
      0  1926					      CALL	EXPR
      0  1926					      db	28
      1  1926		       1c		      .byte.b	28
      0  1927					      dw	EXPR
      1  1927		       af 1b		      .word.w	EXPR
      0  1929					      TST	ERRVEC,"]"
      0  1929					      db	32
      1  1929		       20		      .byte.b	32
      0  192a					      db	(ERRVEC-*)-1
      1  192a		       e1		      .byte.b	(ERRVEC-*)-1
      0  192b					      db	"]",0
      1  192b		       5d 00		      .byte.b	"]",0
      0  192d					      SUBSCRIPT
      0  192d					      db	64
      1  192d		       40		      .byte.b	64
     48  192e				   LETBE
      0  192e					      TST	ERRVEC,"="	;(This line originally omitted)
      0  192e					      db	32
      1  192e		       20		      .byte.b	32
      0  192f					      db	(ERRVEC-*)-1
      1  192f		       dc		      .byte.b	(ERRVEC-*)-1
      0  1930					      db	"=",0
      1  1930		       3d 00		      .byte.b	"=",0
      0  1932					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  1932					      db	28
      1  1932		       1c		      .byte.b	28
      0  1933					      dw	EXPR
      1  1933		       af 1b		      .word.w	EXPR
      0  1935					      DONE		;REPORT ERROR IF NOT NEXT
      0  1935					      db	1
      1  1935		       01		      .byte.b	1
      0  1936					      STORE		;STORE RESULT
      0  1936					      db	19
      1  1936		       13		      .byte.b	19
      0  1937					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1937					      db	6
      1  1937		       06		      .byte.b	6
      0  1938					      dw	CO
      1  1938		       0a 19		      .word.w	CO
      0  193a					      IJMP	STMT
      0  193a					      db	29
      1  193a		       1d		      .byte.b	29
      0  193b					      dw	STMT
      1  193b		       12 19		      .word.w	STMT
     55  193d				   S1
      0  193d					      TST	S1Dec,"INC"	;Increment variable
      0  193d					      db	32
      1  193d		       20		      .byte.b	32
      0  193e					      db	(S1Dec-*)-1
      1  193e		       0e		      .byte.b	(S1Dec-*)-1
      0  193f					      db	"INC",0
      1  193f		       49 4e 43 00	      .byte.b	"INC",0
      0  1943					      TSTV	ERRVEC
      0  1943					      db	33
      1  1943		       21		      .byte.b	33
      0  1944					      db	(ERRVEC-*)-1
      1  1944		       c7		      .byte.b	(ERRVEC-*)-1
      0  1945					      INCVAR
      0  1945					      db	98
      1  1945		       62		      .byte.b	98
      0  1946					      DONE
      0  1946					      db	1
      1  1946		       01		      .byte.b	1
      0  1947					      NXT	CO
      0  1947					      db	6
      1  1947		       06		      .byte.b	6
      0  1948					      dw	CO
      1  1948		       0a 19		      .word.w	CO
      0  194a					      IJMP	STMT
      0  194a					      db	29
      1  194a		       1d		      .byte.b	29
      0  194b					      dw	STMT
      1  194b		       12 19		      .word.w	STMT
     62  194d				   S1Dec
      0  194d					      TST	S1Iret,"DEC"	;Increment variable
      0  194d					      db	32
      1  194d		       20		      .byte.b	32
      0  194e					      db	(S1Iret-*)-1
      1  194e		       0e		      .byte.b	(S1Iret-*)-1
      0  194f					      db	"DEC",0
      1  194f		       44 45 43 00	      .byte.b	"DEC",0
      0  1953					      TSTV	ERRVEC
      0  1953					      db	33
      1  1953		       21		      .byte.b	33
      0  1954					      db	(ERRVEC-*)-1
      1  1954		       b7		      .byte.b	(ERRVEC-*)-1
      0  1955					      DECVAR
      0  1955					      db	99
      1  1955		       63		      .byte.b	99
      0  1956					      DONE
      0  1956					      db	1
      1  1956		       01		      .byte.b	1
      0  1957					      NXT	CO
      0  1957					      db	6
      1  1957		       06		      .byte.b	6
      0  1958					      dw	CO
      1  1958		       0a 19		      .word.w	CO
      0  195a					      IJMP	STMT
      0  195a					      db	29
      1  195a		       1d		      .byte.b	29
      0  195b					      dw	STMT
      1  195b		       12 19		      .word.w	STMT
     69  195d				   S1Iret
      0  195d					      TST	S1S1,"IRET"	;test return from interupt
      0  195d					      db	32
      1  195d		       20		      .byte.b	32
      0  195e					      db	(S1S1-*)-1
      1  195e		       10		      .byte.b	(S1S1-*)-1
      0  195f					      db	"IRET",0
      1  195f		       49 52 45 54*	      .byte.b	"IRET",0
      0  1964					      TST	S1Sa,"URN"
      0  1964					      db	32
      1  1964		       20		      .byte.b	32
      0  1965					      db	(S1Sa-*)-1
      1  1965		       04		      .byte.b	(S1Sa-*)-1
      0  1966					      db	"URN",0
      1  1966		       55 52 4e 00	      .byte.b	"URN",0
     72  196a				   S1Sa
      0  196a					      DONE		;Must be only thing on the line
      0  196a					      db	1
      1  196a		       01		      .byte.b	1
      0  196b					      IRET		;RESTORE LINE NUMBER OF CALL
      0  196b					      db	58
      1  196b		       3a		      .byte.b	58
      0  196c					      IJMP	STMT
      0  196c					      db	29
      1  196c		       1d		      .byte.b	29
      0  196d					      dw	STMT
      1  196d		       12 19		      .word.w	STMT
     76  196f
     77  196f				   S1S1
      0  196f					      TST	S1Z,"IF"	;IF STATEMENT
      0  196f					      db	32
      1  196f		       20		      .byte.b	32
      0  1970					      db	(S1Z-*)-1
      1  1970		       11		      .byte.b	(S1Z-*)-1
      0  1971					      db	"IF",0
      1  1971		       49 46 00 	      .byte.b	"IF",0
      0  1974					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1974					      db	28
      1  1974		       1c		      .byte.b	28
      0  1975					      dw	EXPR
      1  1975		       af 1b		      .word.w	EXPR
      0  1977					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  1977					      db	32
      1  1977		       20		      .byte.b	32
      0  1978					      db	(S1W-*)-1
      1  1978		       05		      .byte.b	(S1W-*)-1
      0  1979					      db	"THEN",0
      1  1979		       54 48 45 4e*	      .byte.b	"THEN",0
     81  197e				   S1W
      0  197e					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  197e					      db	54
      1  197e		       36		      .byte.b	54
      0  197f					      IJMP	STMT
      0  197f					      db	29
      1  197f		       1d		      .byte.b	29
      0  1980					      dw	STMT
      1  1980		       12 19		      .word.w	STMT
     84  1982
     85  1982				   S1Z
      0  1982					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1982					      db	32
      1  1982		       20		      .byte.b	32
      0  1983					      db	(S2b-*)-1
      1  1983		       19		      .byte.b	(S2b-*)-1
      0  1984					      db	"GO",0
      1  1984		       47 4f 00 	      .byte.b	"GO",0
      0  1987					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  1987					      db	32
      1  1987		       20		      .byte.b	32
      0  1988					      db	(S2-*)-1
      1  1988		       07		      .byte.b	(S2-*)-1
      0  1989					      db	"TO",0
      1  1989		       54 4f 00 	      .byte.b	"TO",0
      0  198c					      CALL	EXPR	;GET LABEL
      0  198c					      db	28
      1  198c		       1c		      .byte.b	28
      0  198d					      dw	EXPR
      1  198d		       af 1b		      .word.w	EXPR
      0  198f					      XFER		;SET UP AND JUMP
      0  198f					      db	7
      1  198f		       07		      .byte.b	7
     90  1990				   S2
     91  1990							;===========================================================================
     92  1990							; Process gosub / function
     93  1990							;
      0  1990					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1990					      db	32
      1  1990		       20		      .byte.b	32
      0  1991					      db	(ERRVEC-*)-1
      1  1991		       7a		      .byte.b	(ERRVEC-*)-1
      0  1992					      db	"SUB",0
      1  1992		       53 55 42 00	      .byte.b	"SUB",0
      0  1996					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  1996					      db	28
      1  1996		       1c		      .byte.b	28
      0  1997					      dw	GOSUBSTATEMENT
      1  1997		       b5 1d		      .word.w	GOSUBSTATEMENT
      0  1999					      DONE		;ERROR IF CR NOT NEXT
      0  1999					      db	1
      1  1999		       01		      .byte.b	1
      0  199a					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  199a					      db	8
      1  199a		       08		      .byte.b	8
      0  199b					      db	GOSUB_RTN
      1  199b		       01		      .byte.b	GOSUB_RTN
      0  199c					      XFER		;AND JUMP
      0  199c					      db	7
      1  199c		       07		      .byte.b	7
     99  199d							;
    100  199d							; End of gosub processing
    101  199d							;==========================================================================
    102  199d							; Return from a gosub
    103  199d				   S2b
      0  199d					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  199d					      db	32
      1  199d		       20		      .byte.b	32
      0  199e					      db	(S3-*)-1
      1  199e		       36		      .byte.b	(S3-*)-1
      0  199f					      db	"RE",0
      1  199f		       52 45 00 	      .byte.b	"RE",0
      0  19a2					      TST	S2a,"T"
      0  19a2					      db	32
      1  19a2		       20		      .byte.b	32
      0  19a3					      db	(S2a-*)-1
      1  19a3		       27		      .byte.b	(S2a-*)-1
      0  19a4					      db	"T",0
      1  19a4		       54 00		      .byte.b	"T",0
      0  19a6					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  19a6					      db	32
      1  19a6		       20		      .byte.b	32
      0  19a7					      db	(S2aa-*)-1
      1  19a7		       04		      .byte.b	(S2aa-*)-1
      0  19a8					      db	"URN",0
      1  19a8		       55 52 4e 00	      .byte.b	"URN",0
    107  19ac				   S2aa
      0  19ac					      SETR2	0	; Default no return value
      0  19ac					      db	94
      1  19ac		       5e		      .byte.b	94
      0  19ad					      db	0
      1  19ad		       00		      .byte.b	0
      0  19ae					      TST	S2RetDone,"("	; Check if we will return some value
      0  19ae					      db	32
      1  19ae		       20		      .byte.b	32
      0  19af					      db	(S2RetDone-*)-1
      1  19af		       0b		      .byte.b	(S2RetDone-*)-1
      0  19b0					      db	"(",0
      1  19b0		       28 00		      .byte.b	"(",0
      0  19b2					      SETR2	1	; Indicate a return value provided
      0  19b2					      db	94
      1  19b2		       5e		      .byte.b	94
      0  19b3					      db	1
      1  19b3		       01		      .byte.b	1
      0  19b4					      CALL	EXPR
      0  19b4					      db	28
      1  19b4		       1c		      .byte.b	28
      0  19b5					      dw	EXPR
      1  19b5		       af 1b		      .word.w	EXPR
      0  19b7					      TST	ERRVEC,")"	; Now a value is on the stack
      0  19b7					      db	32
      1  19b7		       20		      .byte.b	32
      0  19b8					      db	(ERRVEC-*)-1
      1  19b8		       53		      .byte.b	(ERRVEC-*)-1
      0  19b9					      db	")",0
      1  19b9		       29 00		      .byte.b	")",0
    113  19bb
    114  19bb				   S2RetDone
      0  19bb					      DONE		; MUST BE CR or :
      0  19bb					      db	1
      1  19bb		       01		      .byte.b	1
      0  19bc					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  19bc					      db	9
      1  19bc		       09		      .byte.b	9
      0  19bd					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  19bd					      db	97
      1  19bd		       61		      .byte.b	97
      0  19be					      db	(S2RetFunc-*)-1
      1  19be		       09		      .byte.b	(S2RetFunc-*)-1
      0  19bf					      dw	R2
      1  19bf		       58 00		      .word.w	R2
      0  19c1					      db	1
      1  19c1		       01		      .byte.b	1
      0  19c2					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  19c2					      db	6
      1  19c2		       06		      .byte.b	6
      0  19c3					      dw	CO
      1  19c3		       0a 19		      .word.w	CO
      0  19c5					      IJMP	STMT
      0  19c5					      db	29
      1  19c5		       1d		      .byte.b	29
      0  19c6					      dw	STMT
      1  19c6		       12 19		      .word.w	STMT
    120  19c8				   S2RetFunc
      0  19c8					      IJMP	GOFNRet	; Back into the Function
      0  19c8					      db	29
      1  19c8		       1d		      .byte.b	29
      0  19c9					      dw	GOFNRet
      1  19c9		       8b 1d		      .word.w	GOFNRet
    122  19cb							;
    123  19cb							; End of return from gosub
    124  19cb							;============================================================================
    125  19cb							; Process REM statement
    126  19cb				   S2a
      0  19cb					      TST	S3,"M"	;REMark.  Skip rest of line
      0  19cb					      db	32
      1  19cb		       20		      .byte.b	32
      0  19cc					      db	(S3-*)-1
      1  19cc		       08		      .byte.b	(S3-*)-1
      0  19cd					      db	"M",0
      1  19cd		       4d 00		      .byte.b	"M",0
      0  19cf					      NXT	CO
      0  19cf					      db	6
      1  19cf		       06		      .byte.b	6
      0  19d0					      dw	CO
      1  19d0		       0a 19		      .word.w	CO
      0  19d2					      IJMP	STMT
      0  19d2					      db	29
      1  19d2		       1d		      .byte.b	29
      0  19d3					      dw	STMT
      1  19d3		       12 19		      .word.w	STMT
    130  19d5
    131  19d5				   S3
      0  19d5					      TST	S3a,"?"	; ? symonym for print
      0  19d5					      db	32
      1  19d5		       20		      .byte.b	32
      0  19d6					      db	(S3a-*)-1
      1  19d6		       05		      .byte.b	(S3a-*)-1
      0  19d7					      db	"?",0
      1  19d7		       3f 00		      .byte.b	"?",0
      0  19d9					      IJMP	S4S
      0  19d9					      db	29
      1  19d9		       1d		      .byte.b	29
      0  19da					      dw	S4S
      1  19da		       e7 19		      .word.w	S4S
    134  19dc				   S3a
      0  19dc					      TST	S8,"PR"	;allow short form of print
      0  19dc					      db	32
      1  19dc		       20		      .byte.b	32
      0  19dd					      db	(S8-*)-1
      1  19dd		       5b		      .byte.b	(S8-*)-1
      0  19de					      db	"PR",0
      1  19de		       50 52 00 	      .byte.b	"PR",0
      0  19e1					      TST	S4S,"INT"	;PRINT
      0  19e1					      db	32
      1  19e1		       20		      .byte.b	32
      0  19e2					      db	(S4S-*)-1
      1  19e2		       04		      .byte.b	(S4S-*)-1
      0  19e3					      db	"INT",0
      1  19e3		       49 4e 54 00	      .byte.b	"INT",0
    137  19e7				   S4S
      0  19e7					      STARTIO		;Lock task until io completes
      0  19e7					      db	70
      1  19e7		       46		      .byte.b	70
    139  19e8				   S4
      0  19e8					      TSTDONE	S4a	;Test if we just want crlf printed
      0  19e8					      db	50
      1  19e8		       32		      .byte.b	50
      0  19e9					      db	(S4a-*)-1
      1  19e9		       03		      .byte.b	(S4a-*)-1
      0  19ea					      IJMP	S6
      0  19ea					      db	29
      1  19ea		       1d		      .byte.b	29
      0  19eb					      dw	S6
      1  19eb		       03 1a		      .word.w	S6
    142  19ed
    143  19ed				   S4a
      0  19ed					      TSTSTR	S7	;TEST FOR QUOTED String
      0  19ed					      db	55
      1  19ed		       37		      .byte.b	55
      0  19ee					      db	(S7-*)-1
      1  19ee		       21		      .byte.b	(S7-*)-1
      0  19ef					      PRS		;PRINT STRING
      0  19ef					      db	2
      1  19ef		       02		      .byte.b	2
    146  19f0				   S5
      0  19f0					      TST	S6A,COMMA	;IS THERE MORE?
      0  19f0					      db	32
      1  19f0		       20		      .byte.b	32
      0  19f1					      db	(S6A-*)-1
      1  19f1		       08		      .byte.b	(S6A-*)-1
      0  19f2					      db	COMMA,0
      1  19f2		       2c 00		      .byte.b	COMMA,0
      0  19f4					      SPC		;SPACE TO NEXT ZONE
      0  19f4					      db	4
      1  19f4		       04		      .byte.b	4
      0  19f5					      TSTDONE	S4	;Not end of line jump back
      0  19f5					      db	50
      1  19f5		       32		      .byte.b	50
      0  19f6					      db	(S4-*)-1
      1  19f6		       f1		      .byte.b	(S4-*)-1
      0  19f7					      IJMP	S6Z	;YES JUMP BACK
      0  19f7					      db	29
      1  19f7		       1d		      .byte.b	29
      0  19f8					      dw	S6Z
      1  19f8		       05 1a		      .word.w	S6Z
    151  19fa
    152  19fa							;
    153  19fa							; If a semicolon, don't do anything.
    154  19fa							;
    155  19fa				   S6A
      0  19fa					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  19fa					      db	32
      1  19fa		       20		      .byte.b	32
      0  19fb					      db	(S6-*)-1
      1  19fb		       07		      .byte.b	(S6-*)-1
      0  19fc					      db	SEMICOLON,0
      1  19fc		       3b 00		      .byte.b	SEMICOLON,0
      0  19fe					      TSTDONE	S4	;Jump Back if not end of line
      0  19fe					      db	50
      1  19fe		       32		      .byte.b	50
      0  19ff					      db	(S4-*)-1
      1  19ff		       e8		      .byte.b	(S4-*)-1
      0  1a00					      IJMP	S6Z
      0  1a00					      db	29
      1  1a00		       1d		      .byte.b	29
      0  1a01					      dw	S6Z
      1  1a01		       05 1a		      .word.w	S6Z
    159  1a03				   S6
      0  1a03					      DONE		;ERROR IF CR NOT NEXT
      0  1a03					      db	1
      1  1a03		       01		      .byte.b	1
      0  1a04					      NLINE
      0  1a04					      db	5
      1  1a04		       05		      .byte.b	5
    162  1a05				   S6Z
      0  1a05					      ENDIO		;release task io completed
      0  1a05					      db	71
      1  1a05		       47		      .byte.b	71
      0  1a06					      NXT	CO	;exit here if , or ; at end of print
      0  1a06					      db	6
      1  1a06		       06		      .byte.b	6
      0  1a07					      dw	CO
      1  1a07		       0a 19		      .word.w	CO
      0  1a09					      IJMP	STMT
      0  1a09					      db	29
      1  1a09		       1d		      .byte.b	29
      0  1a0a					      dw	STMT
      1  1a0a		       12 19		      .word.w	STMT
    166  1a0c							;
    167  1a0c							; A jump for code too far away for relative branch
    168  1a0c							;
    169  1a0c				   ERRVEC
      0  1a0c					      ENDIO
      0  1a0c					      db	71
      1  1a0c		       47		      .byte.b	71
      0  1a0d					      IJMP	UNKNOWN
      0  1a0d					      db	29
      1  1a0d		       1d		      .byte.b	29
      0  1a0e					      dw	UNKNOWN
      1  1a0e		       ab 1b		      .word.w	UNKNOWN
    172  1a10							;
    173  1a10							; Get here if there is an expression to print
    174  1a10				   S7
      0  1a10					      TST	S7AUnsigned,"$"
      0  1a10					      db	32
      1  1a10		       20		      .byte.b	32
      0  1a11					      db	(S7AUnsigned-*)-1
      1  1a11		       09		      .byte.b	(S7AUnsigned-*)-1
      0  1a12					      db	"$",0
      1  1a12		       24 00		      .byte.b	"$",0
      0  1a14					      CALL	EXPR
      0  1a14					      db	28
      1  1a14		       1c		      .byte.b	28
      0  1a15					      dw	EXPR
      1  1a15		       af 1b		      .word.w	EXPR
      0  1a17					      HEXPRT
      0  1a17					      db	67
      1  1a17		       43		      .byte.b	67
      0  1a18					      IJMP	S5
      0  1a18					      db	29
      1  1a18		       1d		      .byte.b	29
      0  1a19					      dw	S5
      1  1a19		       f0 19		      .word.w	S5
    179  1a1b
    180  1a1b				   S7AUnsigned
    181  1a1b
      0  1a1b					      TST	S7A,"%"
      0  1a1b					      db	32
      1  1a1b		       20		      .byte.b	32
      0  1a1c					      db	(S7A-*)-1
      1  1a1c		       0b		      .byte.b	(S7A-*)-1
      0  1a1d					      db	"%",0
      1  1a1d		       25 00		      .byte.b	"%",0
      0  1a1f					      CALL	EXPR
      0  1a1f					      db	28
      1  1a1f		       1c		      .byte.b	28
      0  1a20					      dw	EXPR
      1  1a20		       af 1b		      .word.w	EXPR
      0  1a22					      SETR2	1
      0  1a22					      db	94
      1  1a22		       5e		      .byte.b	94
      0  1a23					      db	1
      1  1a23		       01		      .byte.b	1
      0  1a24					      PRN
      0  1a24					      db	3
      1  1a24		       03		      .byte.b	3
      0  1a25					      IJMP	S5
      0  1a25					      db	29
      1  1a25		       1d		      .byte.b	29
      0  1a26					      dw	S5
      1  1a26		       f0 19		      .word.w	S5
    187  1a28
    188  1a28				   S7A
    189  1a28
      0  1a28					      CALL	EXPR
      0  1a28					      db	28
      1  1a28		       1c		      .byte.b	28
      0  1a29					      dw	EXPR
      1  1a29		       af 1b		      .word.w	EXPR
      0  1a2b					      TST	S7B,"$"
      0  1a2b					      db	32
      1  1a2b		       20		      .byte.b	32
      0  1a2c					      db	(S7B-*)-1
      1  1a2c		       06		      .byte.b	(S7B-*)-1
      0  1a2d					      db	"$",0
      1  1a2d		       24 00		      .byte.b	"$",0
      0  1a2f					      PUTCHAR
      0  1a2f					      db	52
      1  1a2f		       34		      .byte.b	52
      0  1a30					      IJMP	S5
      0  1a30					      db	29
      1  1a30		       1d		      .byte.b	29
      0  1a31					      dw	S5
      1  1a31		       f0 19		      .word.w	S5
    194  1a33
    195  1a33				   S7B
      0  1a33					      SETR2	0
      0  1a33					      db	94
      1  1a33		       5e		      .byte.b	94
      0  1a34					      db	0
      1  1a34		       00		      .byte.b	0
      0  1a35					      PRN		;PRINT IT
      0  1a35					      db	3
      1  1a35		       03		      .byte.b	3
      0  1a36					      IJMP	S5	;IS THERE MORE?
      0  1a36					      db	29
      1  1a36		       1d		      .byte.b	29
      0  1a37					      dw	S5
      1  1a37		       f0 19		      .word.w	S5
    199  1a39							;
    200  1a39							;===========================================================
    201  1a39							; End of TASK process
    202  1a39				   S8
      0  1a39					      TST	S8a1,"TASK"	; Any Task COmmand
      0  1a39					      db	32
      1  1a39		       20		      .byte.b	32
      0  1a3a					      db	(S8a1-*)-1
      1  1a3a		       4b		      .byte.b	(S8a1-*)-1
      0  1a3b					      db	"TASK",0
      1  1a3b		       54 41 53 4b*	      .byte.b	"TASK",0
      0  1a40					      TST	S8G,"E"
      0  1a40					      db	32
      1  1a40		       20		      .byte.b	32
      0  1a41					      db	(S8G-*)-1
      1  1a41		       1a		      .byte.b	(S8G-*)-1
      0  1a42					      db	"E",0
      1  1a42		       45 00		      .byte.b	"E",0
      0  1a44					      TST	S8NoParm,"("
      0  1a44					      db	32
      1  1a44		       20		      .byte.b	32
      0  1a45					      db	(S8NoParm-*)-1
      1  1a45		       0e		      .byte.b	(S8NoParm-*)-1
      0  1a46					      db	"(",0
      1  1a46		       28 00		      .byte.b	"(",0
      0  1a48					      CALL	EXPR
      0  1a48					      db	28
      1  1a48		       1c		      .byte.b	28
      0  1a49					      dw	EXPR
      1  1a49		       af 1b		      .word.w	EXPR
      0  1a4b					      TST	UNKNOWNLnk,")"
      0  1a4b					      db	32
      1  1a4b		       20		      .byte.b	32
      0  1a4c					      db	(UNKNOWNLnk-*)-1
      1  1a4c		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1a4d					      db	")",0
      1  1a4d		       29 00		      .byte.b	")",0
      0  1a4f					      ETASK
      0  1a4f					      db	62
      1  1a4f		       3e		      .byte.b	62
      0  1a50					      DONE
      0  1a50					      db	1
      1  1a50		       01		      .byte.b	1
      0  1a51					      IJMP	STMT
      0  1a51					      db	29
      1  1a51		       1d		      .byte.b	29
      0  1a52					      dw	STMT
      1  1a52		       12 19		      .word.w	STMT
    211  1a54				   S8NoParm
      0  1a54					      LIT	0
      0  1a54					      db	27
      1  1a54		       1b		      .byte.b	27
      0  1a55					      dw	0
      1  1a55		       00 00		      .word.w	0
      0  1a57					      ETASK
      0  1a57					      db	62
      1  1a57		       3e		      .byte.b	62
      0  1a58					      DONE		; Must be last thing on a line
      0  1a58					      db	1
      1  1a58		       01		      .byte.b	1
      0  1a59					      IJMP	STMT
      0  1a59					      db	29
      1  1a59		       1d		      .byte.b	29
      0  1a5a					      dw	STMT
      1  1a5a		       12 19		      .word.w	STMT
    216  1a5c							;
    217  1a5c							;===========================================================
    218  1a5c							; The task gives up the rest of the cycles
    219  1a5c				   S8G
      0  1a5c					      TST	S8a,"N"	;Next task
      0  1a5c					      db	32
      1  1a5c		       20		      .byte.b	32
      0  1a5d					      db	(S8a-*)-1
      1  1a5d		       09		      .byte.b	(S8a-*)-1
      0  1a5e					      db	"N",0
      1  1a5e		       4e 00		      .byte.b	"N",0
      0  1a60					      NTASK
      0  1a60					      db	63
      1  1a60		       3f		      .byte.b	63
      0  1a61					      NXT	CO	;Next statement to execute
      0  1a61					      db	6
      1  1a61		       06		      .byte.b	6
      0  1a62					      dw	CO
      1  1a62		       0a 19		      .word.w	CO
      0  1a64					      IJMP	STMT
      0  1a64					      db	29
      1  1a64		       1d		      .byte.b	29
      0  1a65					      dw	STMT
      1  1a65		       12 19		      .word.w	STMT
    224  1a67							;
    225  1a67							;===========================================================
    226  1a67							; Waits for a task or list of tasks to complete
    227  1a67				   S8a
      0  1a67					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1a67					      db	32
      1  1a67		       20		      .byte.b	32
      0  1a68					      db	(S8TASKNO-*)-1
      1  1a68		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1a69					      db	"W(",0
      1  1a69		       57 28 00 	      .byte.b	"W(",0
    229  1a6c				   S8TSK
      0  1a6c					      Call	EXPR	;Gets the PID of task to wait for
      0  1a6c					      db	28
      1  1a6c		       1c		      .byte.b	28
      0  1a6d					      dw	EXPR
      1  1a6d		       af 1b		      .word.w	EXPR
    231  1a6f				   S8LOOP
      0  1a6f					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1a6f					      db	76
      1  1a6f		       4c		      .byte.b	76
      0  1a70					      db	(S8LOOP-*)-1
      1  1a70		       fe		      .byte.b	(S8LOOP-*)-1
      0  1a71					      TST	S8aa,COMMA	;Checks for more tasks
      0  1a71					      db	32
      1  1a71		       20		      .byte.b	32
      0  1a72					      db	(S8aa-*)-1
      1  1a72		       05		      .byte.b	(S8aa-*)-1
      0  1a73					      db	COMMA,0
      1  1a73		       2c 00		      .byte.b	COMMA,0
      0  1a75					      IJMP	S8TSK	;Go for the next task number
      0  1a75					      db	29
      1  1a75		       1d		      .byte.b	29
      0  1a76					      dw	S8TSK
      1  1a76		       6c 1a		      .word.w	S8TSK
    235  1a78				   S8aa
      0  1a78					      TST	S8TASKNO,")"	;end of list
      0  1a78					      db	32
      1  1a78		       20		      .byte.b	32
      0  1a79					      db	(S8TASKNO-*)-1
      1  1a79		       09		      .byte.b	(S8TASKNO-*)-1
      0  1a7a					      db	")",0
      1  1a7a		       29 00		      .byte.b	")",0
      0  1a7c					      DONE
      0  1a7c					      db	1
      1  1a7c		       01		      .byte.b	1
      0  1a7d					      NXT	CO
      0  1a7d					      db	6
      1  1a7d		       06		      .byte.b	6
      0  1a7e					      dw	CO
      1  1a7e		       0a 19		      .word.w	CO
      0  1a80					      IJMP	STMT	;Next Statement
      0  1a80					      db	29
      1  1a80		       1d		      .byte.b	29
      0  1a81					      dw	STMT
      1  1a81		       12 19		      .word.w	STMT
    240  1a83				   S8TASKNO
    241  1a83
    242  1a83				   UNKNOWNLnk
      0  1a83					      iJMP	UNKNOWN
      0  1a83					      db	29
      1  1a83		       1d		      .byte.b	29
      0  1a84					      dw	UNKNOWN
      1  1a84		       ab 1b		      .word.w	UNKNOWN
    244  1a86
    245  1a86							;
    246  1a86							;===========================================================
    247  1a86							; Update a memory location with a value
    248  1a86				   S8a1
      0  1a86					      TST	S8b,"POKE("	; Poke a value into memory
      0  1a86					      db	32
      1  1a86		       20		      .byte.b	32
      0  1a87					      db	(S8b-*)-1
      1  1a87		       1c		      .byte.b	(S8b-*)-1
      0  1a88					      db	"POKE(",0
      1  1a88		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1a8e					      CALL	EXPR	; Get address to write to
      0  1a8e					      db	28
      1  1a8e		       1c		      .byte.b	28
      0  1a8f					      dw	EXPR
      1  1a8f		       af 1b		      .word.w	EXPR
      0  1a91					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1a91					      db	32
      1  1a91		       20		      .byte.b	32
      0  1a92					      db	(UNKNOWNV-*)-1
      1  1a92		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1a93					      db	COMMA,0
      1  1a93		       2c 00		      .byte.b	COMMA,0
      0  1a95					      CALL	EXPR	; Get the value to poke
      0  1a95					      db	28
      1  1a95		       1c		      .byte.b	28
      0  1a96					      dw	EXPR
      1  1a96		       af 1b		      .word.w	EXPR
      0  1a98					      TST	UNKNOWNV,")"	; closing bracket
      0  1a98					      db	32
      1  1a98		       20		      .byte.b	32
      0  1a99					      db	(UNKNOWNV-*)-1
      1  1a99		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1a9a					      db	")",0
      1  1a9a		       29 00		      .byte.b	")",0
      0  1a9c					      POKEMEM
      0  1a9c					      db	47
      1  1a9c		       2f		      .byte.b	47
      0  1a9d					      DONE
      0  1a9d					      db	1
      1  1a9d		       01		      .byte.b	1
      0  1a9e					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1a9e					      db	6
      1  1a9e		       06		      .byte.b	6
      0  1a9f					      dw	CO
      1  1a9f		       0a 19		      .word.w	CO
      0  1aa1					      IJMP	STMT
      0  1aa1					      db	29
      1  1aa1		       1d		      .byte.b	29
      0  1aa2					      dw	STMT
      1  1aa2		       12 19		      .word.w	STMT
    258  1aa4
    259  1aa4				   S8b
      0  1aa4					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1aa4					      db	32
      1  1aa4		       20		      .byte.b	32
      0  1aa5					      db	(S8c-*)-1
      1  1aa5		       11		      .byte.b	(S8c-*)-1
      0  1aa6					      db	"PUTCH",0
      1  1aa6		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1aac					      CALL	EXPR
      0  1aac					      db	28
      1  1aac		       1c		      .byte.b	28
      0  1aad					      dw	EXPR
      1  1aad		       af 1b		      .word.w	EXPR
      0  1aaf					      PUTCHAR
      0  1aaf					      db	52
      1  1aaf		       34		      .byte.b	52
      0  1ab0					      DONE
      0  1ab0					      db	1
      1  1ab0		       01		      .byte.b	1
      0  1ab1					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1ab1					      db	6
      1  1ab1		       06		      .byte.b	6
      0  1ab2					      dw	CO
      1  1ab2		       0a 19		      .word.w	CO
      0  1ab4					      IJMP	STMT
      0  1ab4					      db	29
      1  1ab4		       1d		      .byte.b	29
      0  1ab5					      dw	STMT
      1  1ab5		       12 19		      .word.w	STMT
    266  1ab7				   S8c
      0  1ab7					      TST	S9,"CLS"	;Clear the screen
      0  1ab7					      db	32
      1  1ab7		       20		      .byte.b	32
      0  1ab8					      db	(S9-*)-1
      1  1ab8		       0b		      .byte.b	(S9-*)-1
      0  1ab9					      db	"CLS",0
      1  1ab9		       43 4c 53 00	      .byte.b	"CLS",0
      0  1abd					      CLEARSCREEN
      0  1abd					      db	46
      1  1abd		       2e		      .byte.b	46
      0  1abe					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1abe					      db	6
      1  1abe		       06		      .byte.b	6
      0  1abf					      dw	CO
      1  1abf		       0a 19		      .word.w	CO
      0  1ac1					      IJMP	STMT
      0  1ac1					      db	29
      1  1ac1		       1d		      .byte.b	29
      0  1ac2					      dw	STMT
      1  1ac2		       12 19		      .word.w	STMT
    271  1ac4				   S9
      0  1ac4					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1ac4					      db	32
      1  1ac4		       20		      .byte.b	32
      0  1ac5					      db	(S13-*)-1
      1  1ac5		       2a		      .byte.b	(S13-*)-1
      0  1ac6					      db	"INPUT",0
      1  1ac6		       49 4e 50 55*	      .byte.b	"INPUT",0
    273  1acc				   S10
      0  1acc					      TSTSTR	S10A	;If there is a string print the prompt
      0  1acc					      db	55
      1  1acc		       37		      .byte.b	55
      0  1acd					      db	(S10A-*)-1
      1  1acd		       05		      .byte.b	(S10A-*)-1
      0  1ace					      PRS
      0  1ace					      db	2
      1  1ace		       02		      .byte.b	2
      0  1acf					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1acf					      db	32
      1  1acf		       20		      .byte.b	32
      0  1ad0					      db	(S10Z-*)-1
      1  1ad0		       15		      .byte.b	(S10Z-*)-1
      0  1ad1					      db	SEMICOLON,0
      1  1ad1		       3b 00		      .byte.b	SEMICOLON,0
    277  1ad3				   S10A
      0  1ad3					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1ad3					      db	33
      1  1ad3		       21		      .byte.b	33
      0  1ad4					      db	(UNKNOWN-*)-1
      1  1ad4		       d6		      .byte.b	(UNKNOWN-*)-1
      0  1ad5					      TST	S10A1,DOLLAR
      0  1ad5					      db	32
      1  1ad5		       20		      .byte.b	32
      0  1ad6					      db	(S10A1-*)-1
      1  1ad6		       06		      .byte.b	(S10A1-*)-1
      0  1ad7					      db	DOLLAR,0
      1  1ad7		       24 00		      .byte.b	DOLLAR,0
      0  1ad9					      INSTR		;Move character From tty to AESTK
      0  1ad9					      db	59
      1  1ad9		       3b		      .byte.b	59
      0  1ada					      IJMP	S10A2
      0  1ada					      db	29
      1  1ada		       1d		      .byte.b	29
      0  1adb					      dw	S10A2
      1  1adb		       de 1a		      .word.w	S10A2
    282  1add				   S10A1
      0  1add					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1add					      db	11
      1  1add		       0b		      .byte.b	11
    284  1ade				   S10A2
      0  1ade					      STORE		;STORE IT
      0  1ade					      db	19
      1  1ade		       13		      .byte.b	19
      0  1adf					      TST	S11,COMMA	;IS THERE MORE?
      0  1adf					      db	32
      1  1adf		       20		      .byte.b	32
      0  1ae0					      db	(S11-*)-1
      1  1ae0		       08		      .byte.b	(S11-*)-1
      0  1ae1					      db	COMMA,0
      1  1ae1		       2c 00		      .byte.b	COMMA,0
      0  1ae3					      IJMP	S10	;YES
      0  1ae3					      db	29
      1  1ae3		       1d		      .byte.b	29
      0  1ae4					      dw	S10
      1  1ae4		       cc 1a		      .word.w	S10
    288  1ae6				   S10Z
      0  1ae6					      iJMP	UNKNOWN
      0  1ae6					      db	29
      1  1ae6		       1d		      .byte.b	29
      0  1ae7					      dw	UNKNOWN
      1  1ae7		       ab 1b		      .word.w	UNKNOWN
    290  1ae9				   S11
      0  1ae9					      DONE		;MUST BE CR
      0  1ae9					      db	1
      1  1ae9		       01		      .byte.b	1
      0  1aea					      NXT	CO	;SEQUENCE TO NEXT
      0  1aea					      db	6
      1  1aea		       06		      .byte.b	6
      0  1aeb					      dw	CO
      1  1aeb		       0a 19		      .word.w	CO
      0  1aed					      IJMP	STMT
      0  1aed					      db	29
      1  1aed		       1d		      .byte.b	29
      0  1aee					      dw	STMT
      1  1aee		       12 19		      .word.w	STMT
    294  1af0				   S13
      0  1af0					      TST	S14,"END"
      0  1af0					      db	32
      1  1af0		       20		      .byte.b	32
      0  1af1					      db	(S14-*)-1
      1  1af1		       08		      .byte.b	(S14-*)-1
      0  1af2					      db	"END",0
      1  1af2		       45 4e 44 00	      .byte.b	"END",0
      0  1af6					      FIN
      0  1af6					      db	12
      1  1af6		       0c		      .byte.b	12
    297  1af7
    298  1af7				   UNKNOWNV
      0  1af7					      IJMP	UNKNOWN
      0  1af7					      db	29
      1  1af7		       1d		      .byte.b	29
      0  1af8					      dw	UNKNOWN
      1  1af8		       ab 1b		      .word.w	UNKNOWN
    300  1afa
    301  1afa				   S14
      0  1afa					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  1afa					      db	32
      1  1afa		       20		      .byte.b	32
      0  1afb					      db	(S14Z-*)-1
      1  1afb		       0f		      .byte.b	(S14Z-*)-1
      0  1afc					      db	"IRQ",0
      1  1afc		       49 52 51 00	      .byte.b	"IRQ",0
      0  1b00					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1b00					      db	28
      1  1b00		       1c		      .byte.b	28
      0  1b01					      dw	EXPR
      1  1b01		       af 1b		      .word.w	EXPR
      0  1b03					      DONE		;must be CR
      0  1b03					      db	1
      1  1b03		       01		      .byte.b	1
      0  1b04					      SETIRQ		;Set the line number now
      0  1b04					      db	56
      1  1b04		       38		      .byte.b	56
      0  1b05					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1b05					      db	6
      1  1b05		       06		      .byte.b	6
      0  1b06					      dw	CO
      1  1b06		       0a 19		      .word.w	CO
      0  1b08					      IJMP	STMT
      0  1b08					      db	29
      1  1b08		       1d		      .byte.b	29
      0  1b09					      dw	STMT
      1  1b09		       12 19		      .word.w	STMT
    308  1b0b
    309  1b0b				   S14Z
      0  1b0b					      TST	S14S1,"KILL"	; Kill A running Task
      0  1b0b					      db	32
      1  1b0b		       20		      .byte.b	32
      0  1b0c					      db	(S14S1-*)-1
      1  1b0c		       10		      .byte.b	(S14S1-*)-1
      0  1b0d					      db	"KILL",0
      1  1b0d		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  1b12					      CALL	EXPR
      0  1b12					      db	28
      1  1b12		       1c		      .byte.b	28
      0  1b13					      dw	EXPR
      1  1b13		       af 1b		      .word.w	EXPR
      0  1b15					      DONE
      0  1b15					      db	1
      1  1b15		       01		      .byte.b	1
      0  1b16					      TASKKILL
      0  1b16					      db	65
      1  1b16		       41		      .byte.b	65
      0  1b17					      NXT	CO
      0  1b17					      db	6
      1  1b17		       06		      .byte.b	6
      0  1b18					      dw	CO
      1  1b18		       0a 19		      .word.w	CO
      0  1b1a					      IJMP	STMT
      0  1b1a					      db	29
      1  1b1a		       1d		      .byte.b	29
      0  1b1b					      dw	STMT
      1  1b1b		       12 19		      .word.w	STMT
    316  1b1d
    317  1b1d				   S14S1
      0  1b1d					      TST	S15,"LIST"	;LIST COMMAND
      0  1b1d					      db	32
      1  1b1d		       20		      .byte.b	32
      0  1b1e					      db	(S15-*)-1
      1  1b1e		       0a		      .byte.b	(S15-*)-1
      0  1b1f					      db	"LIST",0
      1  1b1f		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1b24					      DONE
      0  1b24					      db	1
      1  1b24		       01		      .byte.b	1
      0  1b25					      LST
      0  1b25					      db	21
      1  1b25		       15		      .byte.b	21
      0  1b26					      IJMP	CO
      0  1b26					      db	29
      1  1b26		       1d		      .byte.b	29
      0  1b27					      dw	CO
      1  1b27		       0a 19		      .word.w	CO
    322  1b29				   S15
      0  1b29					      TST	S16,"RUN"	;RUN COMMAND
      0  1b29					      db	32
      1  1b29		       20		      .byte.b	32
      0  1b2a					      db	(S16-*)-1
      1  1b2a		       0d		      .byte.b	(S16-*)-1
      0  1b2b					      db	"RUN",0
      1  1b2b		       52 55 4e 00	      .byte.b	"RUN",0
      0  1b2f					      DONE
      0  1b2f					      db	1
      1  1b2f		       01		      .byte.b	1
      0  1b30					      VINIT		;clear variables
      0  1b30					      db	30
      1  1b30		       1e		      .byte.b	30
      0  1b31					      LIT	1	;GOTO line 1
      0  1b31					      db	27
      1  1b31		       1b		      .byte.b	27
      0  1b32					      dw	1
      1  1b32		       01 00		      .word.w	1
      0  1b34					      XFER		;Bob's addition
      0  1b34					      db	7
      1  1b34		       07		      .byte.b	7
    328  1b35							; EXIT
      0  1b35					      IJMP	STMT	;and run!
      0  1b35					      db	29
      1  1b35		       1d		      .byte.b	29
      0  1b36					      dw	STMT
      1  1b36		       12 19		      .word.w	STMT
    330  1b38				   S16
      0  1b38					      TST	S16A,"NEW"	;clear program
      0  1b38					      db	32
      1  1b38		       20		      .byte.b	32
      0  1b39					      db	(S16A-*)-1
      1  1b39		       08		      .byte.b	(S16A-*)-1
      0  1b3a					      db	"NEW",0
      1  1b3a		       4e 45 57 00	      .byte.b	"NEW",0
      0  1b3e					      DONE
      0  1b3e					      db	1
      1  1b3e		       01		      .byte.b	1
      0  1b3f					      IJMP	START
      0  1b3f					      db	29
      1  1b3f		       1d		      .byte.b	29
      0  1b40					      dw	START
      1  1b40		       04 19		      .word.w	START
    334  1b42
    335  1b42				   S16A
      0  1b42					      TST	S16Trace,"SLICE"
      0  1b42					      db	32
      1  1b42		       20		      .byte.b	32
      0  1b43					      db	(S16Trace-*)-1
      1  1b43		       11		      .byte.b	(S16Trace-*)-1
      0  1b44					      db	"SLICE",0
      1  1b44		       53 4c 49 43*	      .byte.b	"SLICE",0
      0  1b4a					      CALL	EXPR
      0  1b4a					      db	28
      1  1b4a		       1c		      .byte.b	28
      0  1b4b					      dw	EXPR
      1  1b4b		       af 1b		      .word.w	EXPR
      0  1b4d					      SLICE
      0  1b4d					      db	100
      1  1b4d		       64		      .byte.b	100
      0  1b4e					      DONE
      0  1b4e					      db	1
      1  1b4e		       01		      .byte.b	1
      0  1b4f					      NXT	CO
      0  1b4f					      db	6
      1  1b4f		       06		      .byte.b	6
      0  1b50					      dw	CO
      1  1b50		       0a 19		      .word.w	CO
      0  1b52					      IJMP	STMT
      0  1b52					      db	29
      1  1b52		       1d		      .byte.b	29
      0  1b53					      dw	STMT
      1  1b53		       12 19		      .word.w	STMT
    342  1b55
    343  1b55				   S16Trace
      0  1b55					      TST	S17A,"TRACE("	;Are we going to trace
      0  1b55					      db	32
      1  1b55		       20		      .byte.b	32
      0  1b56					      db	(S17A-*)-1
      1  1b56		       16		      .byte.b	(S17A-*)-1
      0  1b57					      db	"TRACE(",0
      1  1b57		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  1b5e					      CALL	EXPR
      0  1b5e					      db	28
      1  1b5e		       1c		      .byte.b	28
      0  1b5f					      dw	EXPR
      1  1b5f		       af 1b		      .word.w	EXPR
      0  1b61					      TST	UNKNOWN,")"
      0  1b61					      db	32
      1  1b61		       20		      .byte.b	32
      0  1b62					      db	(UNKNOWN-*)-1
      1  1b62		       48		      .byte.b	(UNKNOWN-*)-1
      0  1b63					      db	")",0
      1  1b63		       29 00		      .byte.b	")",0
      0  1b65					      TRACEPROGRAM
      0  1b65					      db	78
      1  1b65		       4e		      .byte.b	78
      0  1b66					      DONE
      0  1b66					      db	1
      1  1b66		       01		      .byte.b	1
      0  1b67					      NXT	CO
      0  1b67					      db	6
      1  1b67		       06		      .byte.b	6
      0  1b68					      dw	CO
      1  1b68		       0a 19		      .word.w	CO
      0  1b6a					      IJMP	STMT
      0  1b6a					      db	29
      1  1b6a		       1d		      .byte.b	29
      0  1b6b					      dw	STMT
      1  1b6b		       12 19		      .word.w	STMT
    351  1b6d
    352  1b6d				   S17A
      0  1b6d					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1b6d					      db	32
      1  1b6d		       20		      .byte.b	32
      0  1b6e					      db	(S17B-*)-1
      1  1b6e		       06		      .byte.b	(S17B-*)-1
      0  1b6f					      db	"EXIT",0
      1  1b6f		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1b74					      EXIT
      0  1b74					      db	26
      1  1b74		       1a		      .byte.b	26
    355  1b75
    356  1b75							;
    357  1b75							; Commands related to saving/restoring programs
    358  1b75							; to/from mass storage.
    359  1b75							;
    360  1b75				   S17B
    361  1b75					      if	(XKIM || CTMON65) && DISK_ACCESS
    362  1b75
      0  1b75					      TST	S17C,"SAVE"
      0  1b75					      db	32
      1  1b75		       20		      .byte.b	32
      0  1b76					      db	(S17C-*)-1
      1  1b76		       0b		      .byte.b	(S17C-*)-1
      0  1b77					      db	"SAVE",0
      1  1b77		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1b7c					      OPENWRITE
      0  1b7c					      db	40
      1  1b7c		       28		      .byte.b	40
      0  1b7d					      DLIST
      0  1b7d					      db	43
      1  1b7d		       2b		      .byte.b	43
      0  1b7e					      DCLOSE
      0  1b7e					      db	41
      1  1b7e		       29		      .byte.b	41
      0  1b7f					      IJMP	CO
      0  1b7f					      db	29
      1  1b7f		       1d		      .byte.b	29
      0  1b80					      dw	CO
      1  1b80		       0a 19		      .word.w	CO
    368  1b82
    369  1b82				   S17C
      0  1b82					      TST	S18,"LOAD"
      0  1b82					      db	32
      1  1b82		       20		      .byte.b	32
      0  1b83					      db	(S18-*)-1
      1  1b83		       11		      .byte.b	(S18-*)-1
      0  1b84					      db	"LOAD",0
      1  1b84		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1b89					      OPENREAD
      0  1b89					      db	39
      1  1b89		       27		      .byte.b	39
    372  1b8a				   S17CLP
      0  1b8a					      DGETLINE		;get line from file
      0  1b8a					      db	42
      1  1b8a		       2a		      .byte.b	42
      0  1b8b					      TSTL	S17EOL	;no line num means EOL
      0  1b8b					      db	34
      1  1b8b		       22		      .byte.b	34
      0  1b8c					      db	(S17EOL-*)-1
      1  1b8c		       04		      .byte.b	(S17EOL-*)-1
      0  1b8d					      INSERT		;put it into the program
      0  1b8d					      db	24
      1  1b8d		       18		      .byte.b	24
      0  1b8e					      IJMP	S17CLP	;keep going
      0  1b8e					      db	29
      1  1b8e		       1d		      .byte.b	29
      0  1b8f					      dw	S17CLP
      1  1b8f		       8a 1b		      .word.w	S17CLP
    377  1b91				   S17EOL
      0  1b91					      DCLOSE		;close disk file
      0  1b91					      db	41
      1  1b91		       29		      .byte.b	41
      0  1b92					      IJMP	CO	;back to start
      0  1b92					      db	29
      1  1b92		       1d		      .byte.b	29
      0  1b93					      dw	CO
      1  1b93		       0a 19		      .word.w	CO
    380  1b95
    381  1b95				   S18
      0  1b95					      TST	S19,"DIR"
      0  1b95					      db	32
      1  1b95		       20		      .byte.b	32
      0  1b96					      db	(S19-*)-1
      1  1b96		       08		      .byte.b	(S19-*)-1
      0  1b97					      db	"DIR",0
      1  1b97		       44 49 52 00	      .byte.b	"DIR",0
      0  1b9b					      DDIR		;Display the directory content
      0  1b9b					      db	44
      1  1b9b		       2c		      .byte.b	44
      0  1b9c					      IJMP	CO
      0  1b9c					      db	29
      1  1b9c		       1d		      .byte.b	29
      0  1b9d					      dw	CO
      1  1b9d		       0a 19		      .word.w	CO
    385  1b9f					      endif
    386  1b9f
      0  1b9f				   S19	      TST	UNKNOWN,"ERASE"
      0  1b9f					      db	32
      1  1b9f		       20		      .byte.b	32
      0  1ba0					      db	(UNKNOWN-*)-1
      1  1ba0		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1ba1					      db	"ERASE",0
      1  1ba1		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1ba7					      RMFILE		;Erase the file from the disk
      0  1ba7					      db	45
      1  1ba7		       2d		      .byte.b	45
      0  1ba8					      IJMP	CO
      0  1ba8					      db	29
      1  1ba8		       1d		      .byte.b	29
      0  1ba9					      dw	CO
      1  1ba9		       0a 19		      .word.w	CO
    390  1ba9					      endif
    391  1bab
    392  1bab							;
    393  1bab							; Else, unknown command.
    394  1bab							;
    395  1bab				   UNKNOWN
      0  1bab					      ENDIO
      0  1bab					      db	71
      1  1bab		       47		      .byte.b	71
      0  1bac					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1bac					      db	13
      1  1bac		       0d		      .byte.b	13
      0  1bad					      dw	ERR_SYNTAX
      1  1bad		       05 00		      .word.w	ERR_SYNTAX
    398  1baf
    399  1baf							;-----------------------------------------------------
    400  1baf				   EXPR
      0  1baf					      TST	EXPRNOT,"NOT"
      0  1baf					      db	32
      1  1baf		       20		      .byte.b	32
      0  1bb0					      db	(EXPRNOT-*)-1
      1  1bb0		       09		      .byte.b	(EXPRNOT-*)-1
      0  1bb1					      db	"NOT",0
      1  1bb1		       4e 4f 54 00	      .byte.b	"NOT",0
      0  1bb5					      Call	EXPR
      0  1bb5					      db	28
      1  1bb5		       1c		      .byte.b	28
      0  1bb6					      dw	EXPR
      1  1bb6		       af 1b		      .word.w	EXPR
      0  1bb8					      LOGNOT
      0  1bb8					      db	72
      1  1bb8		       48		      .byte.b	72
      0  1bb9					      RTN
      0  1bb9					      db	25
      1  1bb9		       19		      .byte.b	25
    405  1bba				   EXPRNOT
    406  1bba
    407  1bba				   EXPRLOGS
      0  1bba					      Call	EXPRCMP
      0  1bba					      db	28
      1  1bba		       1c		      .byte.b	28
      0  1bbb					      dw	EXPRCMP
      1  1bbb		       de 1b		      .word.w	EXPRCMP
      0  1bbd					      TST	iLOG1,"AND"
      0  1bbd					      db	32
      1  1bbd		       20		      .byte.b	32
      0  1bbe					      db	(iLOG1-*)-1
      1  1bbe		       09		      .byte.b	(iLOG1-*)-1
      0  1bbf					      db	"AND",0
      1  1bbf		       41 4e 44 00	      .byte.b	"AND",0
      0  1bc3					      Call	EXPR
      0  1bc3					      db	28
      1  1bc3		       1c		      .byte.b	28
      0  1bc4					      dw	EXPR
      1  1bc4		       af 1b		      .word.w	EXPR
      0  1bc6					      LOGAND
      0  1bc6					      db	74
      1  1bc6		       4a		      .byte.b	74
      0  1bc7					      RTN
      0  1bc7					      db	25
      1  1bc7		       19		      .byte.b	25
    413  1bc8				   iLOG1
      0  1bc8					      TST	iLOG2,"OR"
      0  1bc8					      db	32
      1  1bc8		       20		      .byte.b	32
      0  1bc9					      db	(iLOG2-*)-1
      1  1bc9		       08		      .byte.b	(iLOG2-*)-1
      0  1bca					      db	"OR",0
      1  1bca		       4f 52 00 	      .byte.b	"OR",0
      0  1bcd					      Call	EXPR
      0  1bcd					      db	28
      1  1bcd		       1c		      .byte.b	28
      0  1bce					      dw	EXPR
      1  1bce		       af 1b		      .word.w	EXPR
      0  1bd0					      LOGOR
      0  1bd0					      db	73
      1  1bd0		       49		      .byte.b	73
      0  1bd1					      RTN
      0  1bd1					      db	25
      1  1bd1		       19		      .byte.b	25
    418  1bd2				   iLOG2
      0  1bd2					      TST	iLOG3,"XOR"
      0  1bd2					      db	32
      1  1bd2		       20		      .byte.b	32
      0  1bd3					      db	(iLOG3-*)-1
      1  1bd3		       09		      .byte.b	(iLOG3-*)-1
      0  1bd4					      db	"XOR",0
      1  1bd4		       58 4f 52 00	      .byte.b	"XOR",0
      0  1bd8					      Call	EXPR
      0  1bd8					      db	28
      1  1bd8		       1c		      .byte.b	28
      0  1bd9					      dw	EXPR
      1  1bd9		       af 1b		      .word.w	EXPR
      0  1bdb					      LOGXOR
      0  1bdb					      db	75
      1  1bdb		       4b		      .byte.b	75
      0  1bdc					      RTN
      0  1bdc					      db	25
      1  1bdc		       19		      .byte.b	25
    423  1bdd				   iLOG3
      0  1bdd					      RTN
      0  1bdd					      db	25
      1  1bdd		       19		      .byte.b	25
    425  1bde
    426  1bde				   EXPRCMP
      0  1bde					      Call	EXPR2	; get the first expression
      0  1bde					      db	28
      1  1bde		       1c		      .byte.b	28
      0  1bdf					      dw	EXPR2
      1  1bdf		       29 1c		      .word.w	EXPR2
      0  1be1					      TST	iR0,"="
      0  1be1					      db	32
      1  1be1		       20		      .byte.b	32
      0  1be2					      db	(iR0-*)-1
      1  1be2		       08		      .byte.b	(iR0-*)-1
      0  1be3					      db	"=",0
      1  1be3		       3d 00		      .byte.b	"=",0
      0  1be5					      LIT	2	;=
      0  1be5					      db	27
      1  1be5		       1b		      .byte.b	27
      0  1be6					      dw	2
      1  1be6		       02 00		      .word.w	2
      0  1be8					      IJMP	iRFound
      0  1be8					      db	29
      1  1be8		       1d		      .byte.b	29
      0  1be9					      dw	iRFound
      1  1be9		       24 1c		      .word.w	iRFound
    431  1beb				   iR0
      0  1beb					      TST	iR4,"<"
      0  1beb					      db	32
      1  1beb		       20		      .byte.b	32
      0  1bec					      db	(iR4-*)-1
      1  1bec		       1c		      .byte.b	(iR4-*)-1
      0  1bed					      db	"<",0
      1  1bed		       3c 00		      .byte.b	"<",0
      0  1bef					      TST	iR1,"="
      0  1bef					      db	32
      1  1bef		       20		      .byte.b	32
      0  1bf0					      db	(iR1-*)-1
      1  1bf0		       08		      .byte.b	(iR1-*)-1
      0  1bf1					      db	"=",0
      1  1bf1		       3d 00		      .byte.b	"=",0
      0  1bf3					      LIT	3	;<=
      0  1bf3					      db	27
      1  1bf3		       1b		      .byte.b	27
      0  1bf4					      dw	3
      1  1bf4		       03 00		      .word.w	3
      0  1bf6					      IJMP	iRFound
      0  1bf6					      db	29
      1  1bf6		       1d		      .byte.b	29
      0  1bf7					      dw	iRFound
      1  1bf7		       24 1c		      .word.w	iRFound
    436  1bf9				   iR1
      0  1bf9					      TST	iR3,">"
      0  1bf9					      db	32
      1  1bf9		       20		      .byte.b	32
      0  1bfa					      db	(iR3-*)-1
      1  1bfa		       08		      .byte.b	(iR3-*)-1
      0  1bfb					      db	">",0
      1  1bfb		       3e 00		      .byte.b	">",0
      0  1bfd					      LIT	5	;<>
      0  1bfd					      db	27
      1  1bfd		       1b		      .byte.b	27
      0  1bfe					      dw	5
      1  1bfe		       05 00		      .word.w	5
      0  1c00					      IJMP	iRFound
      0  1c00					      db	29
      1  1c00		       1d		      .byte.b	29
      0  1c01					      dw	iRFound
      1  1c01		       24 1c		      .word.w	iRFound
    440  1c03				   iR3
      0  1c03					      LIT	1	;<
      0  1c03					      db	27
      1  1c03		       1b		      .byte.b	27
      0  1c04					      dw	1
      1  1c04		       01 00		      .word.w	1
      0  1c06					      IJMP	iRFound
      0  1c06					      db	29
      1  1c06		       1d		      .byte.b	29
      0  1c07					      dw	iRFound
      1  1c07		       24 1c		      .word.w	iRFound
    443  1c09				   iR4
      0  1c09					      TST	iRDone,">"
      0  1c09					      db	32
      1  1c09		       20		      .byte.b	32
      0  1c0a					      db	(iRDone-*)-1
      1  1c0a		       1d		      .byte.b	(iRDone-*)-1
      0  1c0b					      db	">",0
      1  1c0b		       3e 00		      .byte.b	">",0
      0  1c0d					      TST	iR5,"="
      0  1c0d					      db	32
      1  1c0d		       20		      .byte.b	32
      0  1c0e					      db	(iR5-*)-1
      1  1c0e		       08		      .byte.b	(iR5-*)-1
      0  1c0f					      db	"=",0
      1  1c0f		       3d 00		      .byte.b	"=",0
      0  1c11					      LIT	6	;>=
      0  1c11					      db	27
      1  1c11		       1b		      .byte.b	27
      0  1c12					      dw	6
      1  1c12		       06 00		      .word.w	6
      0  1c14					      IJMP	iRFound
      0  1c14					      db	29
      1  1c14		       1d		      .byte.b	29
      0  1c15					      dw	iRFound
      1  1c15		       24 1c		      .word.w	iRFound
    448  1c17				   iR5
      0  1c17					      TST	iR6,"<"
      0  1c17					      db	32
      1  1c17		       20		      .byte.b	32
      0  1c18					      db	(iR6-*)-1
      1  1c18		       08		      .byte.b	(iR6-*)-1
      0  1c19					      db	"<",0
      1  1c19		       3c 00		      .byte.b	"<",0
      0  1c1b					      LIT	1
      0  1c1b					      db	27
      1  1c1b		       1b		      .byte.b	27
      0  1c1c					      dw	1
      1  1c1c		       01 00		      .word.w	1
      0  1c1e					      IJMP	iRFound	;(This line originally omitted)
      0  1c1e					      db	29
      1  1c1e		       1d		      .byte.b	29
      0  1c1f					      dw	iRFound
      1  1c1f		       24 1c		      .word.w	iRFound
    452  1c21				   iR6
      0  1c21					      LIT	4	;>
      0  1c21					      db	27
      1  1c21		       1b		      .byte.b	27
      0  1c22					      dw	4
      1  1c22		       04 00		      .word.w	4
    454  1c24				   iRFound
      0  1c24					      Call	EXPR2	; get the right side of the expression
      0  1c24					      db	28
      1  1c24		       1c		      .byte.b	28
      0  1c25					      dw	EXPR2
      1  1c25		       29 1c		      .word.w	EXPR2
      0  1c27					      CMPR		; Push the value of the true false onto the stack
      0  1c27					      db	10
      1  1c27		       0a		      .byte.b	10
    457  1c28
    458  1c28				   iRDone
      0  1c28					      RTN
      0  1c28					      db	25
      1  1c28		       19		      .byte.b	25
    460  1c29
    461  1c29				   EXPR2
      0  1c29					      TST	E0,"-"	; Look for leading - to negate term
      0  1c29					      db	32
      1  1c29		       20		      .byte.b	32
      0  1c2a					      db	(E0-*)-1
      1  1c2a		       09		      .byte.b	(E0-*)-1
      0  1c2b					      db	"-",0
      1  1c2b		       2d 00		      .byte.b	"-",0
      0  1c2d					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1c2d					      db	28
      1  1c2d		       1c		      .byte.b	28
      0  1c2e					      dw	TERM
      1  1c2e		       52 1c		      .word.w	TERM
      0  1c30					      NEG		; Make value negated
      0  1c30					      db	16
      1  1c30		       10		      .byte.b	16
      0  1c31					      IJMP	E1	; We have Left term process operators next
      0  1c31					      db	29
      1  1c31		       1d		      .byte.b	29
      0  1c32					      dw	E1
      1  1c32		       3b 1c		      .word.w	E1
    466  1c34				   E0
      0  1c34					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1c34					      db	32
      1  1c34		       20		      .byte.b	32
      0  1c35					      db	(E1A-*)-1
      1  1c35		       02		      .byte.b	(E1A-*)-1
      0  1c36					      db	"+",0
      1  1c36		       2b 00		      .byte.b	"+",0
    468  1c38				   E1A
      0  1c38					      CALL	TERM	; Get the left term if it was not negated
      0  1c38					      db	28
      1  1c38		       1c		      .byte.b	28
      0  1c39					      dw	TERM
      1  1c39		       52 1c		      .word.w	TERM
    470  1c3b				   E1
      0  1c3b					      TST	E2,"+"	; Check if we are adding left term to something
      0  1c3b					      db	32
      1  1c3b		       20		      .byte.b	32
      0  1c3c					      db	(E2-*)-1
      1  1c3c		       09		      .byte.b	(E2-*)-1
      0  1c3d					      db	"+",0
      1  1c3d		       2b 00		      .byte.b	"+",0
      0  1c3f					      CALL	TERM	; if adding then get the right side term
      0  1c3f					      db	28
      1  1c3f		       1c		      .byte.b	28
      0  1c40					      dw	TERM
      1  1c40		       52 1c		      .word.w	TERM
      0  1c42					      ADD		; Add it to left term
      0  1c42					      db	14
      1  1c42		       0e		      .byte.b	14
      0  1c43					      IJMP	E1	; look for next + or -
      0  1c43					      db	29
      1  1c43		       1d		      .byte.b	29
      0  1c44					      dw	E1
      1  1c44		       3b 1c		      .word.w	E1
    475  1c46				   E2
      0  1c46					      TST	E3,"-"	; Check if we are subtractig something
      0  1c46					      db	32
      1  1c46		       20		      .byte.b	32
      0  1c47					      db	(E3-*)-1
      1  1c47		       09		      .byte.b	(E3-*)-1
      0  1c48					      db	"-",0
      1  1c48		       2d 00		      .byte.b	"-",0
      0  1c4a					      CALL	TERM	; get right side to subtract Diffrence
      0  1c4a					      db	28
      1  1c4a		       1c		      .byte.b	28
      0  1c4b					      dw	TERM
      1  1c4b		       52 1c		      .word.w	TERM
      0  1c4d					      SUB		; Subtract the value
      0  1c4d					      db	15
      1  1c4d		       0f		      .byte.b	15
      0  1c4e					      IJMP	E1	; Look for next + or -
      0  1c4e					      db	29
      1  1c4e		       1d		      .byte.b	29
      0  1c4f					      dw	E1
      1  1c4f		       3b 1c		      .word.w	E1
    480  1c51				   E3			; Finish processing the expression
      0  1c51					      RTN		; We are finished processing the Expression
      0  1c51					      db	25
      1  1c51		       19		      .byte.b	25
    482  1c52							;
    483  1c52							; Get one of the terms of an expression
    484  1c52							;
    485  1c52				   TERM
      0  1c52					      CALL	FACT	; Get a value
      0  1c52					      db	28
      1  1c52		       1c		      .byte.b	28
      0  1c53					      dw	FACT
      1  1c53		       7a 1c		      .word.w	FACT
    487  1c55				   T0			; Check for higher precidence operators
      0  1c55					      TST	T1,"*"	; Check for *
      0  1c55					      db	32
      1  1c55		       20		      .byte.b	32
      0  1c56					      db	(T1-*)-1
      1  1c56		       09		      .byte.b	(T1-*)-1
      0  1c57					      db	"*",0
      1  1c57		       2a 00		      .byte.b	"*",0
      0  1c59					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1c59					      db	28
      1  1c59		       1c		      .byte.b	28
      0  1c5a					      dw	FACT
      1  1c5a		       7a 1c		      .word.w	FACT
      0  1c5c					      MUL		; Multiply factors
      0  1c5c					      db	17
      1  1c5c		       11		      .byte.b	17
      0  1c5d					      IJMP	T0	; Check for * or /
      0  1c5d					      db	29
      1  1c5d		       1d		      .byte.b	29
      0  1c5e					      dw	T0
      1  1c5e		       55 1c		      .word.w	T0
    492  1c60				   T1
      0  1c60					      TST	T2,"/"	; Check for a division
      0  1c60					      db	32
      1  1c60		       20		      .byte.b	32
      0  1c61					      db	(T2-*)-1
      1  1c61		       09		      .byte.b	(T2-*)-1
      0  1c62					      db	"/",0
      1  1c62		       2f 00		      .byte.b	"/",0
      0  1c64					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c64					      db	28
      1  1c64		       1c		      .byte.b	28
      0  1c65					      dw	FACT
      1  1c65		       7a 1c		      .word.w	FACT
      0  1c67					      DIV		; do division
      0  1c67					      db	18
      1  1c67		       12		      .byte.b	18
      0  1c68					      IJMP	T0	; check for more * or /
      0  1c68					      db	29
      1  1c68		       1d		      .byte.b	29
      0  1c69					      dw	T0
      1  1c69		       55 1c		      .word.w	T0
    497  1c6b				   T2
      0  1c6b					      TST	T3,"%"	; Check for a division
      0  1c6b					      db	32
      1  1c6b		       20		      .byte.b	32
      0  1c6c					      db	(T3-*)-1
      1  1c6c		       09		      .byte.b	(T3-*)-1
      0  1c6d					      db	"%",0
      1  1c6d		       25 00		      .byte.b	"%",0
      0  1c6f					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c6f					      db	28
      1  1c6f		       1c		      .byte.b	28
      0  1c70					      dw	FACT
      1  1c70		       7a 1c		      .word.w	FACT
      0  1c72					      MODULO		; do division for remainder
      0  1c72					      db	60
      1  1c72		       3c		      .byte.b	60
      0  1c73					      IJMP	T0	; check for more * or / or %
      0  1c73					      db	29
      1  1c73		       1d		      .byte.b	29
      0  1c74					      dw	T0
      1  1c74		       55 1c		      .word.w	T0
    502  1c76				   T3			; Finish processing the Term
      0  1c76					      RTN
      0  1c76					      db	25
      1  1c76		       19		      .byte.b	25
    504  1c77
    505  1c77				   UNKNOWNVEC
      0  1c77					      IJMP	UNKNOWN
      0  1c77					      db	29
      1  1c77		       1d		      .byte.b	29
      0  1c78					      dw	UNKNOWN
      1  1c78		       ab 1b		      .word.w	UNKNOWN
    507  1c7a
    508  1c7a							;
    509  1c7a							; Factor an expression.  Always test for functions
    510  1c7a							; first or else they'll be confused for variables.
    511  1c7a							;
    512  1c7a				   FACT
      0  1c7a					      TST	F1AA,"TRUE"
      0  1c7a					      db	32
      1  1c7a		       20		      .byte.b	32
      0  1c7b					      db	(F1AA-*)-1
      1  1c7b		       09		      .byte.b	(F1AA-*)-1
      0  1c7c					      db	"TRUE",0
      1  1c7c		       54 52 55 45*	      .byte.b	"TRUE",0
      0  1c81					      LIT	-1
      0  1c81					      db	27
      1  1c81		       1b		      .byte.b	27
      0  1c82					      dw	-1
      1  1c82		       ff ff		      .word.w	-1
      0  1c84					      RTN
      0  1c84					      db	25
      1  1c84		       19		      .byte.b	25
    516  1c85				   F1AA
      0  1c85					      TST	F1AB,"FALSE"
      0  1c85					      db	32
      1  1c85		       20		      .byte.b	32
      0  1c86					      db	(F1AB-*)-1
      1  1c86		       0a		      .byte.b	(F1AB-*)-1
      0  1c87					      db	"FALSE",0
      1  1c87		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1c8d					      LIT	0
      0  1c8d					      db	27
      1  1c8d		       1b		      .byte.b	27
      0  1c8e					      dw	0
      1  1c8e		       00 00		      .word.w	0
      0  1c90					      RTN
      0  1c90					      db	25
      1  1c90		       19		      .byte.b	25
    520  1c91				   F1AB
      0  1c91					      TST	F1A,"FREE()"
      0  1c91					      db	32
      1  1c91		       20		      .byte.b	32
      0  1c92					      db	(F1A-*)-1
      1  1c92		       09		      .byte.b	(F1A-*)-1
      0  1c93					      db	"FREE()",0
      1  1c93		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1c9a					      FREE
      0  1c9a					      db	36
      1  1c9a		       24		      .byte.b	36
      0  1c9b					      RTN
      0  1c9b					      db	25
      1  1c9b		       19		      .byte.b	25
    524  1c9c				   F1A
      0  1c9c					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1c9c					      db	32
      1  1c9c		       20		      .byte.b	32
      0  1c9d					      db	(F1A2-*)-1
      1  1c9d		       0a		      .byte.b	(F1A2-*)-1
      0  1c9e					      db	"GETCH()",0
      1  1c9e		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1ca6					      GETCHAR
      0  1ca6					      db	51
      1  1ca6		       33		      .byte.b	51
      0  1ca7					      RTN
      0  1ca7					      db	25
      1  1ca7		       19		      .byte.b	25
    528  1ca8				   F1A2
      0  1ca8					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1ca8					      db	32
      1  1ca8		       20		      .byte.b	32
      0  1ca9					      db	(F2AZ-*)-1
      1  1ca9		       0f		      .byte.b	(F2AZ-*)-1
      0  1caa					      db	"PEEK(",0
      1  1caa		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1cb0					      CALL	EXPR	;Get the address to write to
      0  1cb0					      db	28
      1  1cb0		       1c		      .byte.b	28
      0  1cb1					      dw	EXPR
      1  1cb1		       af 1b		      .word.w	EXPR
      0  1cb3					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  1cb3					      db	32
      1  1cb3		       20		      .byte.b	32
      0  1cb4					      db	(UNKNOWNVEC-*)-1
      1  1cb4		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cb5					      db	")",0
      1  1cb5		       29 00		      .byte.b	")",0
      0  1cb7					      PEEKMEM
      0  1cb7					      db	48
      1  1cb7		       30		      .byte.b	48
      0  1cb8					      RTN
      0  1cb8					      db	25
      1  1cb8		       19		      .byte.b	25
    534  1cb9				   F2AZ
      0  1cb9					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  1cb9					      db	32
      1  1cb9		       20		      .byte.b	32
      0  1cba					      db	(F2AZ1-*)-1
      1  1cba		       22		      .byte.b	(F2AZ1-*)-1
      0  1cbb					      db	"TASK(",0
      1  1cbb		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1cc1					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1cc1					      db	28
      1  1cc1		       1c		      .byte.b	28
      0  1cc2					      dw	EXPR
      1  1cc2		       af 1b		      .word.w	EXPR
      0  1cc4					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  1cc4					      db	61
      1  1cc4		       3d		      .byte.b	61
      0  1cc5					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  1cc5					      db	32
      1  1cc5		       20		      .byte.b	32
      0  1cc6					      db	(F2AZNoParms-*)-1
      1  1cc6		       10		      .byte.b	(F2AZNoParms-*)-1
      0  1cc7					      db	COMMA,0
      1  1cc7		       2c 00		      .byte.b	COMMA,0
      0  1cc9					      SAVEMATHSTACK		;Push The mathstack
      0  1cc9					      db	86
      1  1cc9		       56		      .byte.b	86
      0  1cca					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  1cca					      db	89
      1  1cca		       59		      .byte.b	89
    541  1ccb				   F2AZLOOP
      0  1ccb					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  1ccb					      db	28
      1  1ccb		       1c		      .byte.b	28
      0  1ccc					      dw	EXPR
      1  1ccc		       af 1b		      .word.w	EXPR
      0  1cce					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  1cce					      db	32
      1  1cce		       20		      .byte.b	32
      0  1ccf					      db	(F2AZEndParm-*)-1
      1  1ccf		       05		      .byte.b	(F2AZEndParm-*)-1
      0  1cd0					      db	COMMA,0
      1  1cd0		       2c 00		      .byte.b	COMMA,0
      0  1cd2					      IJMP	F2AZLOOP	;check for more
      0  1cd2					      db	29
      1  1cd2		       1d		      .byte.b	29
      0  1cd3					      dw	F2AZLOOP
      1  1cd3		       cb 1c		      .word.w	F2AZLOOP
    545  1cd5				   F2AZEndParm
      0  1cd5					      RESTOREMATHSTACK		;Back to normal stack
      0  1cd5					      db	87
      1  1cd5		       57		      .byte.b	87
      0  1cd6					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  1cd6					      db	92
      1  1cd6		       5c		      .byte.b	92
    548  1cd7				   F2AZNoParms
      0  1cd7					      TST	UNKNOWNVEC,")"	;must be )
      0  1cd7					      db	32
      1  1cd7		       20		      .byte.b	32
      0  1cd8					      db	(UNKNOWNVEC-*)-1
      1  1cd8		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cd9					      db	")",0
      1  1cd9		       29 00		      .byte.b	")",0
      0  1cdb					      TASKENABLE		;Enable the task to execute
      0  1cdb					      db	90
      1  1cdb		       5a		      .byte.b	90
      0  1cdc					      RTN		;Returns the Task number
      0  1cdc					      db	25
      1  1cdc		       19		      .byte.b	25
    552  1cdd				   F2AZ1
      0  1cdd					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  1cdd					      db	32
      1  1cdd		       20		      .byte.b	32
      0  1cde					      db	(F2A-*)-1
      1  1cde		       3c		      .byte.b	(F2A-*)-1
      0  1cdf					      db	"IPC",0
      1  1cdf		       49 50 43 00	      .byte.b	"IPC",0
      0  1ce3					      TST	F2AZa,"S("	;IPCS - send a message
      0  1ce3					      db	32
      1  1ce3		       20		      .byte.b	32
      0  1ce4					      db	(F2AZa-*)-1
      1  1ce4		       13		      .byte.b	(F2AZa-*)-1
      0  1ce5					      db	"S(",0
      1  1ce5		       53 28 00 	      .byte.b	"S(",0
      0  1ce8					      CALL	EXPR	;Get the message value
      0  1ce8					      db	28
      1  1ce8		       1c		      .byte.b	28
      0  1ce9					      dw	EXPR
      1  1ce9		       af 1b		      .word.w	EXPR
      0  1ceb					      TST	UNKNOWNVEC,COMMA
      0  1ceb					      db	32
      1  1ceb		       20		      .byte.b	32
      0  1cec					      db	(UNKNOWNVEC-*)-1
      1  1cec		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  1ced					      db	COMMA,0
      1  1ced		       2c 00		      .byte.b	COMMA,0
      0  1cef					      CALL	EXPR	;Get pid of task to send to
      0  1cef					      db	28
      1  1cef		       1c		      .byte.b	28
      0  1cf0					      dw	EXPR
      1  1cf0		       af 1b		      .word.w	EXPR
      0  1cf2					      TST	UNKNOWNVEC,")"
      0  1cf2					      db	32
      1  1cf2		       20		      .byte.b	32
      0  1cf3					      db	(UNKNOWNVEC-*)-1
      1  1cf3		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cf4					      db	")",0
      1  1cf4		       29 00		      .byte.b	")",0
      0  1cf6					      IPCSEND		;Send msg and clear pid msg pending
      0  1cf6					      db	80
      1  1cf6		       50		      .byte.b	80
      0  1cf7					      RTN
      0  1cf7					      db	25
      1  1cf7		       19		      .byte.b	25
    561  1cf8				   F2AZa
      0  1cf8					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  1cf8					      db	32
      1  1cf8		       20		      .byte.b	32
      0  1cf9					      db	(F2AZb-*)-1
      1  1cf9		       16		      .byte.b	(F2AZb-*)-1
      0  1cfa					      db	"R(",0
      1  1cfa		       52 28 00 	      .byte.b	"R(",0
      0  1cfd					      TST	F2AZa1,")"
      0  1cfd					      db	32
      1  1cfd		       20		      .byte.b	32
      0  1cfe					      db	(F2AZa1-*)-1
      1  1cfe		       08		      .byte.b	(F2AZa1-*)-1
      0  1cff					      db	")",0
      1  1cff		       29 00		      .byte.b	")",0
      0  1d01					      LIT	0	;We dont want the pid returned to us
      0  1d01					      db	27
      1  1d01		       1b		      .byte.b	27
      0  1d02					      dw	0
      1  1d02		       00 00		      .word.w	0
      0  1d04					      IPCIO		;Set the io bit and suspend the task till message
      0  1d04					      db	83
      1  1d04		       53		      .byte.b	83
      0  1d05					      IPCRECEIVE		;Get the message
      0  1d05					      db	81
      1  1d05		       51		      .byte.b	81
      0  1d06					      RTN
      0  1d06					      db	25
      1  1d06		       19		      .byte.b	25
    568  1d07				   F2AZa1
      0  1d07					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  1d07					      db	33
      1  1d07		       21		      .byte.b	33
      0  1d08					      db	(UNKNOWNVEC-*)-1
      1  1d08		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d09					      TST	UNKNOWNVEC,")"
      0  1d09					      db	32
      1  1d09		       20		      .byte.b	32
      0  1d0a					      db	(UNKNOWNVEC-*)-1
      1  1d0a		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d0b					      db	")",0
      1  1d0b		       29 00		      .byte.b	")",0
      0  1d0d					      IPCIO		;Set the io bit and exit task till message
      0  1d0d					      db	83
      1  1d0d		       53		      .byte.b	83
      0  1d0e					      IPCRECEIVE		;Get the message
      0  1d0e					      db	81
      1  1d0e		       51		      .byte.b	81
      0  1d0f					      RTN
      0  1d0f					      db	25
      1  1d0f		       19		      .byte.b	25
    574  1d10				   F2AZb
      0  1d10					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  1d10					      db	32
      1  1d10		       20		      .byte.b	32
      0  1d11					      db	(UNKNOWNVEC-*)-1
      1  1d11		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d12					      db	"C()",0
      1  1d12		       43 28 29 00	      .byte.b	"C()",0
      0  1d16					      IPCCHECK
      0  1d16					      db	82
      1  1d16		       52		      .byte.b	82
      0  1d17					      RTN
      0  1d17					      db	25
      1  1d17		       19		      .byte.b	25
    578  1d18
    579  1d18				   UNKNOWNID
      0  1d18					      IJMP	UNKNOWN
      0  1d18					      db	29
      1  1d18		       1d		      .byte.b	29
      0  1d19					      dw	UNKNOWN
      1  1d19		       ab 1b		      .word.w	UNKNOWN
    581  1d1b							;
    582  1d1b							; RND() is supposed to have an argument but if none
    583  1d1b							; was provided, just assume a large value.
    584  1d1b							;
    585  1d1b				   F2A
      0  1d1b					      TST	F2B,"RND("
      0  1d1b					      db	32
      1  1d1b		       20		      .byte.b	32
      0  1d1c					      db	(F2B-*)-1
      1  1d1c		       17		      .byte.b	(F2B-*)-1
      0  1d1d					      db	"RND(",0
      1  1d1d		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1d22					      TST	F2A1,")"
      0  1d22					      db	32
      1  1d22		       20		      .byte.b	32
      0  1d23					      db	(F2A1-*)-1
      1  1d23		       07		      .byte.b	(F2A1-*)-1
      0  1d24					      db	")",0
      1  1d24		       29 00		      .byte.b	")",0
      0  1d26					      LIT	32766
      0  1d26					      db	27
      1  1d26		       1b		      .byte.b	27
      0  1d27					      dw	32766
      1  1d27		       fe 7f		      .word.w	32766
      0  1d29					      RANDOM
      0  1d29					      db	37
      1  1d29		       25		      .byte.b	37
      0  1d2a					      RTN
      0  1d2a					      db	25
      1  1d2a		       19		      .byte.b	25
    591  1d2b
    592  1d2b				   F2A1
      0  1d2b					      CALL	FACT	;GET RANGE
      0  1d2b					      db	28
      1  1d2b		       1c		      .byte.b	28
      0  1d2c					      dw	FACT
      1  1d2c		       7a 1c		      .word.w	FACT
      0  1d2e					      TST	UNKNOWNVEC,")"
      0  1d2e					      db	32
      1  1d2e		       20		      .byte.b	32
      0  1d2f					      db	(UNKNOWNVEC-*)-1
      1  1d2f		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d30					      db	")",0
      1  1d30		       29 00		      .byte.b	")",0
      0  1d32					      RANDOM
      0  1d32					      db	37
      1  1d32		       25		      .byte.b	37
      0  1d33					      RTN
      0  1d33					      db	25
      1  1d33		       19		      .byte.b	25
    597  1d34
    598  1d34				   F2B
      0  1d34					      TST	F2B2,"ABS("
      0  1d34					      db	32
      1  1d34		       20		      .byte.b	32
      0  1d35					      db	(F2B2-*)-1
      1  1d35		       0e		      .byte.b	(F2B2-*)-1
      0  1d36					      db	"ABS(",0
      1  1d36		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1d3b					      CALL	EXPR	;get value
      0  1d3b					      db	28
      1  1d3b		       1c		      .byte.b	28
      0  1d3c					      dw	EXPR
      1  1d3c		       af 1b		      .word.w	EXPR
      0  1d3e					      TST	UNKNOWNVEC,")"
      0  1d3e					      db	32
      1  1d3e		       20		      .byte.b	32
      0  1d3f					      db	(UNKNOWNVEC-*)-1
      1  1d3f		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d40					      db	")",0
      1  1d40		       29 00		      .byte.b	")",0
      0  1d42					      ABS
      0  1d42					      db	38
      1  1d42		       26		      .byte.b	38
      0  1d43					      RTN
      0  1d43					      db	25
      1  1d43		       19		      .byte.b	25
    604  1d44
    605  1d44				   F2B2
      0  1d44					      TST	F2Z,"STAT("
      0  1d44					      db	32
      1  1d44		       20		      .byte.b	32
      0  1d45					      db	(F2Z-*)-1
      1  1d45		       0f		      .byte.b	(F2Z-*)-1
      0  1d46					      db	"STAT(",0
      1  1d46		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1d4c					      Call	EXPR
      0  1d4c					      db	28
      1  1d4c		       1c		      .byte.b	28
      0  1d4d					      dw	EXPR
      1  1d4d		       af 1b		      .word.w	EXPR
      0  1d4f					      TST	UNKNOWNVEC,")"
      0  1d4f					      db	32
      1  1d4f		       20		      .byte.b	32
      0  1d50					      db	(UNKNOWNVEC-*)-1
      1  1d50		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d51					      db	")",0
      1  1d51		       29 00		      .byte.b	")",0
      0  1d53					      TASKSTAT
      0  1d53					      db	66
      1  1d53		       42		      .byte.b	66
      0  1d54					      RTN
      0  1d54					      db	25
      1  1d54		       19		      .byte.b	25
    611  1d55				   F2Z
      0  1d55					      TST	F2ZA,"PID"
      0  1d55					      db	32
      1  1d55		       20		      .byte.b	32
      0  1d56					      db	(F2ZA-*)-1
      1  1d56		       06		      .byte.b	(F2ZA-*)-1
      0  1d57					      db	"PID",0
      1  1d57		       50 49 44 00	      .byte.b	"PID",0
      0  1d5b					      TASKPID
      0  1d5b					      db	77
      1  1d5b		       4d		      .byte.b	77
      0  1d5c					      RTN
      0  1d5c					      db	25
      1  1d5c		       19		      .byte.b	25
    615  1d5d				   F2ZA
      0  1d5d					      TST	F2FUNC,"CALL("	;call machine function
      0  1d5d					      db	32
      1  1d5d		       20		      .byte.b	32
      0  1d5e					      db	(F2FUNC-*)-1
      1  1d5e		       1f		      .byte.b	(F2FUNC-*)-1
      0  1d5f					      db	"CALL(",0
      1  1d5f		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1d65					      CALL	EXPR
      0  1d65					      db	28
      1  1d65		       1c		      .byte.b	28
      0  1d66					      dw	EXPR
      1  1d66		       af 1b		      .word.w	EXPR
      0  1d68					      TST	F2B2A,COMMA
      0  1d68					      db	32
      1  1d68		       20		      .byte.b	32
      0  1d69					      db	(F2B2A-*)-1
      1  1d69		       0b		      .byte.b	(F2B2A-*)-1
      0  1d6a					      db	COMMA,0
      1  1d6a		       2c 00		      .byte.b	COMMA,0
      0  1d6c					      CALL	EXPR
      0  1d6c					      db	28
      1  1d6c		       1c		      .byte.b	28
      0  1d6d					      dw	EXPR
      1  1d6d		       af 1b		      .word.w	EXPR
      0  1d6f					      TST	UNKNOWNVEC,")"
      0  1d6f					      db	32
      1  1d6f		       20		      .byte.b	32
      0  1d70					      db	(UNKNOWNVEC-*)-1
      1  1d70		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d71					      db	")",0
      1  1d71		       29 00		      .byte.b	")",0
      0  1d73					      CALLFUNC
      0  1d73					      db	53
      1  1d73		       35		      .byte.b	53
      0  1d74					      RTN
      0  1d74					      db	25
      1  1d74		       19		      .byte.b	25
    623  1d75							; Run the gosub within this function
    624  1d75				   F2B2A
      0  1d75					      TST	UNKNOWNID,")"
      0  1d75					      db	32
      1  1d75		       20		      .byte.b	32
      0  1d76					      db	(UNKNOWNID-*)-1
      1  1d76		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  1d77					      db	")",0
      1  1d77		       29 00		      .byte.b	")",0
      0  1d79					      LIT	0
      0  1d79					      db	27
      1  1d79		       1b		      .byte.b	27
      0  1d7a					      dw	0
      1  1d7a		       00 00		      .word.w	0
      0  1d7c					      CALLFUNC
      0  1d7c					      db	53
      1  1d7c		       35		      .byte.b	53
      0  1d7d					      RTN
      0  1d7d					      db	25
      1  1d7d		       19		      .byte.b	25
    629  1d7e
      0  1d7e				   F2FUNC     TST	F2C,"GOFN"
      0  1d7e					      db	32
      1  1d7e		       20		      .byte.b	32
      0  1d7f					      db	(F2C-*)-1
      1  1d7f		       0c		      .byte.b	(F2C-*)-1
      0  1d80					      db	"GOFN",0
      1  1d80		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  1d85					      Call	GOSUBSTATEMENT
      0  1d85					      db	28
      1  1d85		       1c		      .byte.b	28
      0  1d86					      dw	GOSUBSTATEMENT
      1  1d86		       b5 1d		      .word.w	GOSUBSTATEMENT
      0  1d88					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  1d88					      db	8
      1  1d88		       08		      .byte.b	8
      0  1d89					      db	GOSUB_RTN_VALUE
      1  1d89		       81		      .byte.b	GOSUB_RTN_VALUE
      0  1d8a					      XFER
      0  1d8a					      db	7
      1  1d8a		       07		      .byte.b	7
    634  1d8b				   GOFNRet
      0  1d8b					      RTN
      0  1d8b					      db	25
      1  1d8b		       19		      .byte.b	25
    636  1d8c				   F2C
      0  1d8c					      TSTV	F0
      0  1d8c					      db	33
      1  1d8c		       21		      .byte.b	33
      0  1d8d					      db	(F0-*)-1
      1  1d8d		       15		      .byte.b	(F0-*)-1
      0  1d8e					      TST	F2CLocalTask,"!"
      0  1d8e					      db	32
      1  1d8e		       20		      .byte.b	32
      0  1d8f					      db	(F2CLocalTask-*)-1
      1  1d8f		       05		      .byte.b	(F2CLocalTask-*)-1
      0  1d90					      db	"!",0
      1  1d90		       21 00		      .byte.b	"!",0
      0  1d92					      IND		; we just got a pid
      0  1d92					      db	20
      1  1d92		       14		      .byte.b	20
      0  1d93					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  1d93					      db	93
      1  1d93		       5d		      .byte.b	93
      0  1d94					      db	(UNKNOWNID-*)-1
      1  1d94		       83		      .byte.b	(UNKNOWNID-*)-1
    641  1d95
    642  1d95				   F2CLocalTask
      0  1d95					      TST	F2C1,"["
      0  1d95					      db	32
      1  1d95		       20		      .byte.b	32
      0  1d96					      db	(F2C1-*)-1
      1  1d96		       0a		      .byte.b	(F2C1-*)-1
      0  1d97					      db	"[",0
      1  1d97		       5b 00		      .byte.b	"[",0
      0  1d99					      CALL	EXPR
      0  1d99					      db	28
      1  1d99		       1c		      .byte.b	28
      0  1d9a					      dw	EXPR
      1  1d9a		       af 1b		      .word.w	EXPR
      0  1d9c					      TST	UNKNOWNID,"]"
      0  1d9c					      db	32
      1  1d9c		       20		      .byte.b	32
      0  1d9d					      db	(UNKNOWNID-*)-1
      1  1d9d		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  1d9e					      db	"]",0
      1  1d9e		       5d 00		      .byte.b	"]",0
      0  1da0					      SUBSCRIPT
      0  1da0					      db	64
      1  1da0		       40		      .byte.b	64
    647  1da1				   F2C1
      0  1da1					      IND		;YES, GET THE VALUE.
      0  1da1					      db	20
      1  1da1		       14		      .byte.b	20
      0  1da2					      RTN
      0  1da2					      db	25
      1  1da2		       19		      .byte.b	25
    650  1da3				   F0
      0  1da3					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1da3					      db	35
      1  1da3		       23		      .byte.b	35
      0  1da4					      db	(F1-*)-1
      1  1da4		       01		      .byte.b	(F1-*)-1
      0  1da5					      RTN
      0  1da5					      db	25
      1  1da5		       19		      .byte.b	25
    653  1da6				   F1
      0  1da6					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  1da6					      db	32
      1  1da6		       20		      .byte.b	32
      0  1da7					      db	(F2RTN-*)-1
      1  1da7		       09		      .byte.b	(F2RTN-*)-1
      0  1da8					      db	"(",0
      1  1da8		       28 00		      .byte.b	"(",0
      0  1daa					      CALL	EXPR
      0  1daa					      db	28
      1  1daa		       1c		      .byte.b	28
      0  1dab					      dw	EXPR
      1  1dab		       af 1b		      .word.w	EXPR
      0  1dad					      TST	F2,")"
      0  1dad					      db	32
      1  1dad		       20		      .byte.b	32
      0  1dae					      db	(F2-*)-1
      1  1dae		       03		      .byte.b	(F2-*)-1
      0  1daf					      db	")",0
      1  1daf		       29 00		      .byte.b	")",0
    657  1db1				   F2RTN
      0  1db1					      RTN
      0  1db1					      db	25
      1  1db1		       19		      .byte.b	25
    659  1db2
    660  1db2				   F2
      0  1db2					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1db2					      db	13
      1  1db2		       0d		      .byte.b	13
      0  1db3					      dw	ERR_SYNTAX
      1  1db3		       05 00		      .word.w	ERR_SYNTAX
    662  1db5							;
    663  1db5							;=============================================================
    664  1db5							; Gosub can be both a Function and a Subroutine
    665  1db5				   GOSUBSTATEMENT
      0  1db5					      CALL	EXPR	;GET DESTINATION
      0  1db5					      db	28
      1  1db5		       1c		      .byte.b	28
      0  1db6					      dw	EXPR
      1  1db6		       af 1b		      .word.w	EXPR
      0  1db8					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  1db8					      db	32
      1  1db8		       20		      .byte.b	32
      0  1db9					      db	(GOSUBDONE-*)-1
      1  1db9		       14		      .byte.b	(GOSUBDONE-*)-1
      0  1dba					      db	"(",0
      1  1dba		       28 00		      .byte.b	"(",0
      0  1dbc					      STK2TMP		;Transfer stack top to temp
      0  1dbc					      db	95
      1  1dbc		       5f		      .byte.b	95
      0  1dbd					      PUSHMATHSTACK		;Record stack frame for return
      0  1dbd					      db	84
      1  1dbd		       54		      .byte.b	84
    670  1dbe				   GOSUBLOOP
      0  1dbe					      CALL	EXPR	; Allows what ever fits onto stack
      0  1dbe					      db	28
      1  1dbe		       1c		      .byte.b	28
      0  1dbf					      dw	EXPR
      1  1dbf		       af 1b		      .word.w	EXPR
      0  1dc1					      INCPARMCOUNT
      0  1dc1					      db	88
      1  1dc1		       58		      .byte.b	88
      0  1dc2					      TST	GOSUBParmDONE,COMMA
      0  1dc2					      db	32
      1  1dc2		       20		      .byte.b	32
      0  1dc3					      db	(GOSUBParmDONE-*)-1
      1  1dc3		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  1dc4					      db	COMMA,0
      1  1dc4		       2c 00		      .byte.b	COMMA,0
      0  1dc6					      IJMP	GOSUBLOOP
      0  1dc6					      db	29
      1  1dc6		       1d		      .byte.b	29
      0  1dc7					      dw	GOSUBLOOP
      1  1dc7		       be 1d		      .word.w	GOSUBLOOP
    675  1dc9				   GOSUBParmDONE
      0  1dc9					      TST	F2,")"
      0  1dc9					      db	32
      1  1dc9		       20		      .byte.b	32
      0  1dca					      db	(F2-*)-1
      1  1dca		       e7		      .byte.b	(F2-*)-1
      0  1dcb					      db	")",0
      1  1dcb		       29 00		      .byte.b	")",0
      0  1dcd					      TMP2STK		;Restore line to goto
      0  1dcd					      db	96
      1  1dcd		       60		      .byte.b	96
    678  1dce				   GOSUBDONE
      0  1dce					      RTN
      0  1dce					      db	25
      1  1dce		       19		      .byte.b	25
    680  1dcf
    681  1dcf		       1d cf	   ILEND      equ	*
------- FILE mytb.asm
   2218  1dcf		       1d cf	   PROGEND    equ	*
   2219  1dcf
   2220  1dcf
   2221  1dcf							;=====================================================
   2222  1dcf							; Define start of non page zero data
   2223 U1ddf					      seg.u	TBData
   2224 U1ddf
   2225 U1ddf							;=====================================================
   2226 U1ddf							; These are storage items not in page zero.
   2227 U1ddf							;
   2228 U1ddf							; IRQ BASIC Code Service RTN Support
      0 U1ddf				   SaveIrqReg db	0	; Store current setting
      1 U1ddf		       00		      .byte.b	0
      0 U1de0				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1de0		       00		      .byte.b	0
      0 U1de1				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1de1		       00		      .byte.b	0
      0 U1de2				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1de2		       00 00		      .byte.b	0,0
   2233 U1de4
   2234 U1de4							;
   2235 U1de4							;==================================================================================================
   2236 U1de4							; Task Management information
   2237 U1de4							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2238 U1de4							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2239 U1de4							; Task switchs happen at the beginning of the next Basic command line
   2240 U1de4							; It will not happen during an input or output operations
   2241 U1de4							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2242 U1de4							; Task Zero is always the root task, main line program
   2243 U1de4							;
   2244 U1de4							; Layout is repeated for each configured task
   2245 U1de4							; Task Table Byte   use masks follow
   2246 U1de4		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2247 U1de4		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2248 U1de4		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2249 U1de4		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2250 U1de4		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2251 U1de4
   2252 U1de4		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2253 U1de5		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2254 U1de5		       1e df	   TASKTABLEEND equ	*	; End of task table
   2255 U1de5		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2256 U1edf
   2257 U1edf							;Task Cycle Counter and reset count
   2258 U1edf		       00 00	   taskCurrentCycles ds	2
   2259 U1ee1		       00 00	   taskResetValue ds	2
   2260 U1ee3		       00	   taskCounter ds	1	; Count of active tasks
   2261 U1ee4
   2262 U1ee4							;
   2263 U1ee4							; Math stack and IL call and Gosub/For-next return stack definitions
   2264 U1ee4							;
   2265 U1ee4		       1e e4	   STACKSTART equ	*
   2266 U1ee4		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2267 U2074		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2268 U2204		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2269 U2484		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2270 U2484		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2271 U2484		       26 a0	   STACKEND   equ	*
   2272 U2484		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2273 U26a0							;
   2274 U26a0							;
   2275 U26a0		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2276 U2724		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2277 U2725		       00	   printtx    ds	1	;temp X for print funcs
   2278 U2726		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2279 U2727		       00	   promptChar ds	1	;the character to use for a prompt
   2280 U2728		       00	   diddigit   ds	1	;for leading zero suppression
   2281 U2729		       00	   putsy      ds	1
   2282 U272a		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2283 U272c		       00	   sign       ds	1	;0 = positive, else negative
   2284 U272d		       00 00	   rtemp1     ds	2	;Temp for x and y
   2285 U272f		       00 00	   random     ds	2
   2286 U2731		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2287 U2733		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2288 U2735		       00	   tempy      ds	1	;temp y storage
   2289 U2736
   2290 U2736							; Moved from page zero as one clock cycle diff gives more space on page zero
   2291 U2736		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2292 U2738		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2293 U2739		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2294 U273a		       00	   lineLength ds	1	;Length of current line
   2295 U273b
   2296 U273b		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2297 U273c		       00	   taskRDPending ds	1	; 1 = background read is pending
   2298 U273d
   2299 U273d				  -	      if	XKIM
   2300 U273d				  -buffer     ds	BUFFER_SIZE
   2301 U273d					      endif
   2302 U273d							;
   2303 U273d							; PROGRAMEND is the end of the user's BASIC program.
   2304 U273d							; More precisely, it is one byte past the end.  Or,
   2305 U273d							; it's where the next line added to the end will be
   2306 U273d							; placed.
   2307 U273d							;
   2308 U273d		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2309 U273f		       00 00	   ProgramEnd ds	2	; End of users basic program
   2310 U2741		       00 00	   HighMem    ds	2	; highest location
   2311 U2743		       00 00	   UsedMem    ds	2	; size of user program
   2312 U2745		       00 00	   FreeMem    ds	2	; amount of free memory
   2313 U2747							;
   2314 U2747							;=====================================================
   2315 U2747							; This is the start of the user's BASIC program space.
   2316 U2747							;
   2317 U2747							; PERSONAL GOAL: This should be no larger than $0DFF.
   2318 U2747							;		  0200-05FF = 1K
   2319 U2747							;		  0200-09FF = 2K
   2320 U2747							;		  0200-0DFF = 3K
   2321 U2747							;		  0200-11FF = 4K
   2322 U2747							;		  0200-13FF = 4.5K
   2323 U2747							;
   2324 U2747				  -	      if	FIXED
   2325 U2747				  -	      org	$2000
   2326 U2747					      endif
   2327 U2747
   2328 U2747		       27 47	   FreeMemStart equ	*
   2329 U2747							;/*
   2330 U2747							;	if	CTMON65 || XKIM
   2331 U2747							;		SEG Code
   2332 U2747							;		org	AutoRun
   2333 U2747							;		dw	TBasicCold
   2334 U2747							;	endif
   2335 U2747							;*/
   2336 U2747					      end
