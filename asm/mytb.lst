------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2fce				   input      processor	6502
      2 U2fce ????						;=====================================================
      3 U2fce ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2fce ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2fce ????						; Free Time. Now abiut 6K Full OS features.
      6 U2fce ????						;
      7 U2fce ????						; While working on the Corsham Technologies KIM Clone
      8 U2fce ????						; project, I wanted to include a TINY BASIC since that
      9 U2fce ????						; was a highly desirable feature of early computers.
     10 U2fce ????						;
     11 U2fce ????						; Rather than negotiating copyright issues for
     12 U2fce ????						; existing BASICs, I decided to just write one from
     13 U2fce ????						; scratch.
     14 U2fce ????						;
     15 U2fce ????						; 10/07/2017
     16 U2fce ????						;
     17 U2fce ????						; This implements a stripped down Tiny BASIC
     18 U2fce ????						; interpreter using the Interpretive Language (IL)
     19 U2fce ????						; method as described in the first few issues of
     20 U2fce ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2fce ????						; to write various languages simply by changing the
     22 U2fce ????						; IL code rather than the interpreter itself.
     23 U2fce ????						;
     24 U2fce ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2fce ????						;		* Fixed major bug in findLine that
     26 U2fce ????						;		  caused corrupted lines, crashes, etc.
     27 U2fce ????						;		* If no parameter given to RND, assume
     28 U2fce ????						;		  32766.
     29 U2fce ????						;		* No more error 5 when a program
     30 U2fce ????						;		  reaches the end without an END.
     31 U2fce ????						;
     32 U2fce ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2fce ????						;		 * Unexpanded version to play with everything
     34 U2fce ????						;		 * Add some usefull system level functions
     35 U2fce ????						;		 * allow a larger number of tiny basic formats
     36 U2fce ????						;		 * Add byte at start of line holding length
     37 U2fce ????						;		   for faster execution of goto and gosub
     38 U2fce ????						;		 * Re-added gosub
     39 U2fce ????						;		 * allow ; or , at end if print stmt
     40 U2fce ????						;		   without CRLF being added.
     41 U2fce ????						;		 * Added extended function erase to
     42 U2fce ????						;		   use the extended ctmon65 rm file
     43 U2fce ????						;		 * Fix quoted text to not have to backtrack
     44 U2fce ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2fce ????						;		 * Add concurrency features
     46 U2fce ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U2fce ????						;
     48 U2fce ????						; www.corshamtech.com
     49 U2fce ????						; bob@corshamtech.com
     50 U2fce ????						; JustLostInTime@gmail.com
     51 U2fce ????						;
     52 U2fce ????						;=====================================================
     53 U2fce ????						;
     54 U2fce ????						; Create TRUE and FALSE values for conditionals.
     55 U2fce ????						;
     56 U2fce ????
     57 U2fce ????	       00 00	   FALSE      equ	0
     58 U2fce ????	       ff ff ff ff TRUE       equ	~FALSE
     59 U2fce ????						;
     60 U2fce ????						;---------------------------------------------------------
     61 U2fce ????						; One of these must be set to indicate which environment
     62 U2fce ????						; Tiny BASIC will be running in.  Here are the current
     63 U2fce ????						; environments:
     64 U2fce ????						;
     65 U2fce ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     66 U2fce ????						; more K of RAM.
     67 U2fce ????						;
     68 U2fce ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     69 U2fce ????						; which enhances, without replacing, the standard KIM
     70 U2fce ????						; monitor.  It gives access to routines to save/load files
     71 U2fce ????						; to a micro SD card.
     72 U2fce ????						;
     73 U2fce ????						; CTMON65 is a from-scratch monitor written for the
     74 U2fce ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     75 U2fce ????						; easily be ported to other systems.  It has support for
     76 U2fce ????						; using a micro SD card for file storage/retrieval.
     77 U2fce ????						;
     78 U2fce ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     79 U2fce ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     80 U2fce ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     81 U2fce ????
     82 U2fce ????						;
     83 U2fce ????						;   Need to define some macros for the dasm assembler
     84 U2fce ????						;
     85 U2fce ????				      MACRO	dw
     86 U2fce ????				      .word	{0}
     87 U2fce ????				      ENDM
     88 U2fce ????
     89 U2fce ????				      MACRO	db
     90 U2fce ????				      .byte	{0}
     91 U2fce ????				      ENDM
     92 U2fce ????
     93 U2fce ????						;
     94 U2fce ????						; If set, include disk functions.
     95 U2fce ????						;
     96 U2fce ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2fce ????						;
     98 U2fce ????						; If ILTRACE is set then dump out the address of every
     99 U2fce ????						; IL opcode before executing it.
    100 U2fce ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2fce ????						;
    102 U2fce ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2fce ????						;
    104 U2fce ????						; If FIXED is set, put the IL code and the user
    105 U2fce ????						; program space at fixed locations in memory.	This is
    106 U2fce ????						; meant only for debugging.
    107 U2fce ????						;
    108 U2fce ????	       00 00	   FIXED      equ	FALSE
    109 U2fce ????						;
    110 U2fce ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2fce ????						; BASIC, so keep this small!
    112 U2fce ????						;
    113 U2fce ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2fce ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2fce ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2fce ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2fce ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    118 U2fce ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2fce ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2fce ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2fce ????						;
    122 U2fce ????						; Gosub entry types
    123 U2fce ????
    124 U2fce ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2fce ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2fce ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2fce ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2fce ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2fce ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2fce ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2fce ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2fce ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2fce ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2fce ????						;
    135 U2fce ????						; Common ASCII constants
    136 U2fce ????						;
    137 U2fce ????	       00 07	   BEL	      equ	$07
    138 U2fce ????	       00 08	   BS	      equ	$08
    139 U2fce ????	       00 09	   TAB	      equ	$09
    140 U2fce ????	       00 0a	   LF	      equ	$0A
    141 U2fce ????	       00 0d	   CR	      equ	$0D
    142 U2fce ????	       00 22	   quote      equ	$22
    143 U2fce ????	       00 20	   SPACE      equ	$20
    144 U2fce ????	       00 2c	   COMMA      equ	',
    145 U2fce ????	       00 3b	   SEMICOLON  equ	';
    146 U2fce ????	       00 3a	   COLON      equ	':
    147 U2fce ????	       00 24	   DOLLAR     equ	'$
    148 U2fce ????						;
    149 U2fce ????						; These are error codes
    150 U2fce ????						;
    151 U2fce ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2fce ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2fce ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2fce ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2fce ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2fce ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2fce ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2fce ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2fce ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2fce ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2fce ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2fce ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2fce ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2fce ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2fce ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2fce ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2fce ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2fce ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2fce ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2fce ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    171 U2fce ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    172 U2fce ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    173 U2fce ????						;
    174 U2fce ????						;=====================================================
    175 U2fce ????						; Zero page storage.
    176 U2fce ????						;
    177 U00f6 ????				      SEG.U	ZEROPAGE
    178 U0040					      org	$0040
    179 U0040
    180 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    181 U0041
    182 U0041							; The context is used to locate a task switch
    183 U0041							; it copies from here till all task fields are saved/swapped
    184 U0041							; The max number of tasks is 256 / context length
    185 U0041							; All positions POS values are plus one task table incldues
    186 U0041							; a leading status byte .
    187 U0041							;
    188 U0041		       00 41	   CONTEXT    equ	*
    189 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    190 U0041
    191 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    192 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    193 U0043
    194 U0043		       00 00	   ILPC       ds	2	; IL program counter
    195 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    196 U0047		       00	   ILSTACKPTR ds	1
    197 U0048
    198 U0048
    199 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    200 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    201 U004a
    202 U004a
    203 U004a		       00	   MATHSTACKPTR ds	1
    204 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    205 U004b
    206 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    207 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT +1	; Get the offset to the gosub/msg stack
    208 U004d
    209 U004d
    210 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    211 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    212 U004e
    213 U004e
    214 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    215 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    216 U004f							;
    217 U004f							; CURPTR is a pointer to curent BASIC line being
    218 U004f							; executed.  Always points to start of line, CUROFF
    219 U004f							; is the offset to the current character.
    220 U004f							; The order of these fields is important
    221 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    222 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    223 U0052							;
    224 U0052							;The order of these fields in important
    225 U0052
    226 U0052							;
    227 U0052							; R0, R1 and MQ are used for arithmetic operations and
    228 U0052							; general use.
    229 U0052							;
    230 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    231 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    232 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    233 U0056		       00 00	   MQ	      ds	2	;used for some math
    234 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    235 U0058		       00 59	   REGISTERSEND equ	*
    236 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    237 U0059
    238 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    239 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    240 U0059
    241 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    242 U005b							;
    243 U005b							; This is zero if in immediate mode, or non-zero
    244 U005b							; if currently running a program.  Any input from
    245 U005b							; the main loop clears this, and the XFER IL
    246 U005b							; statement will set it.
    247 U005b							;
    248 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    249 U005c							;
    250 U005c							; Used for line insertion/removal.
    251 U005c							;
    252 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    253 U005e
    254 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    255 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    256 U005e							;
    257 U005e		       00 00	   PrtFrom    ds	2	; FROM
    258 U0060							;
    259 U0060							;=====================================================
    260 U0060							;Pointers for memory Management
    261 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    262 U0060							; Mem block format is
    263 U0060							;	 0-1   pointer to next block for free blocks
    264 U0060							;	 0-1   for allocated blocks
    265 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    266 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    267 U0060							;	 2-3   length constant for exevy type of memory block
    268 U0060							; Memory is recombined as it is released
    269 U0060							; The memory manager is not interupted durring allocation
    270 U0060							; or freeing of memory
    271 U0060							;====================================================
    272 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    273 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    274 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    275 U0066							;
    276 U0066							;=====================================================
    277 U0066							;
    278  2624 ????				      SEG	Code
    279  0200					      org	$0200
    280  0200							;
    281  0200							; Cold start is at $0200.  Warm start is at $0203.
    282  0200							;
    283  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    284  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    285  0206							;
    286  0206							; These are the user-supplied vectors to I/O routines.
    287  0206							; If you want, you can just patch these in the binary
    288  0206							; file, but it would be better to change the source
    289  0206							; code.
    290  0206							;
    291  0206				  -	      if	KIM
    292  0206				  -OUTCH      jmp	$1ea0	;output char in A
    293  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    294  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    295  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    296  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    297  0206					      endif
    298  0206				  -	      if	XKIM
    299  0206				  -	      include	"xkim.inc"
    300  0206				  -	      SEG	Code
    301  0206				  -OUTCH      jmp	$1ea0
    302  0206				  -GETCH      jmp	xkGETCH
    303  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    304  0206				  -OUTHEX     jmp	xkPRTBYT
    305  0206				  -MONITOR    jmp	extKIM
    306  0206				  -puts       equ	putsil
    307  0206				  -BUFFER_SIZE equ	132
    308  0206					      endif
    309  0206
    310  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    312 Udf8e
    313  0206					      SEG	Code
    314  0206							;
    315  0206		       f0 0c	   OUTCH      equ	cout
    316  0206		       f0 09	   GETCH      equ	cin
    317  0206		       1e 6c	   CRLF       equ	tbcrlf
    318  0206		       14 20	   OUTHEX     equ	HexToOut
    319  0206		       f0 03	   MONITOR    equ	WARM
    320  0206		       f0 0f	   ISCHAR     equ	cstatus
    321  0206		       14 3d	   puts       equ	tbputs
    322  0206					      endif
    323  0206							;
    324  0206		       20 a0 1f    cold2      jsr	SetOutConsole
    325  0209		       20 ad 1f 	      jsr	SetInConsole
    326  020c		       20 3d 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    330  0243							;
    331  0243		       20 31 16 	      jsr	MemInit	;setup the free space available
    332  0246
    333  0246		       a9 01	   calcstack  lda	#1
    334  0248		       8d 6a 27 	      sta	taskCounter	; Initialize number of tasks to 1
    335  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    336  024d		       8d 6c 26 	      sta	taskTable	; mark the main task as active
    337  0250		       20 1e 17 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    338  0253		       a9 96		      lda	#IL&$ff
    339  0255		       85 43		      sta	ILPC
    340  0257		       a9 22		      lda	#IL>>8
    341  0259		       85 44		      sta	ILPC+1
    342  025b							;
    343  025b							;		  lda	  ProgramStart		     ; user prog
    344  025b							;		  sta	  ProgramEnd
    345  025b							;		  lda	  ProgramStart+1
    346  025b							;		  sta	  ProgramEnd+1
    347  025b							;
    348  025b
    349  025b							;  Init time slices defaults
    350  025b		       a9 02		      lda	#TASKCYCLESHIGH
    351  025d		       8d 69 27 	      sta	taskResetValue+1
    352  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    353  0262		       8d 68 27 	      sta	taskResetValue
    354  0265							;
    355  0265							; Initialize the pseudo-random number sequence...
    356  0265							;
    357  0265		       a9 5a		      lda	#$5a
    358  0267		       8d b4 2f 	      sta	rtemp1
    359  026a		       a9 9d		      lda	#%10011101
    360  026c		       8d b6 2f 	      sta	random
    361  026f		       a9 5b		      lda	#%01011011
    362  0271		       8d b7 2f 	      sta	random+1
    363  0274							;
    364  0274							;   Insert a Basic irq handler for the basic Language
    365  0274		       a9 81		      lda	#ServiceIrq&$ff
    366  0276		       8d 00 df 	      sta	IRQvec
    367  0279		       a9 02		      lda	#ServiceIrq>>8
    368  027b		       8d 01 df 	      sta	IRQvec+1
    369  027e		       4c a6 02 	      jmp	coldtwo
    370  0281
    371  0281							;
    372  0281							; This is the Basic IRQ handler
    373  0281		       48	   ServiceIrq pha
    374  0282		       ad 67 26 	      lda	IRQStatus
    375  0285		       f0 0a		      BEQ	RetIrq
    376  0287		       ad 68 26 	      lda	IRQPending
    377  028a		       d0 05		      bne	RetIrq
    378  028c		       a9 01		      lda	#1
    379  028e		       8d 68 26 	      sta	IRQPending
    380  0291		       68	   RetIrq     pla
    381  0292		       40		      rti
    382  0293							;
    383  0293							;
    384  0293							; This is the warm start entry point
    385  0293							;
    386  0293		       20 a0 1f    warm2      jsr	SetOutConsole
    387  0296		       20 ad 1f 	      jsr	SetInConsole
    388  0299		       20 6c 1e 	      jsr	CRLF
    389  029c		       ad b1 2f 	      lda	errGoto
    390  029f		       85 43		      sta	ILPC
    391  02a1		       ad b2 2f 	      lda	errGoto+1
    392  02a4		       85 44		      sta	ILPC+1
    393  02a6							;
    394  02a6							; And continue with both starts here
    395  02a6							;
    396  02a6				   coldtwo
    397  02a6							;
    398  02a6							; The ILTrace flag is now run-time settable.
    399  02a6							;
    400  02a6		       a9 00		      lda	#ILTRACE&$ff
    401  02a8		       85 40		      sta	ILTrace
    402  02aa							;
    403  02aa
    404  02aa		       a9 00		      lda	#0
    405  02ac		       85 5b		      sta	RunMode
    406  02ae		       8d 27 2f 	      sta	LINBUF
    407  02b1
    408  02b1							; Clear everything from the stacks
    409  02b1
    410  02b1		       8d c2 2f 	      sta	taskIOPending	; No one waiting for io
    411  02b4		       8d c3 2f 	      sta	taskRDPending	; No one waiting for bg io
    412  02b7
    413  02b7		       20 91 17 	      jsr	taskReset
    414  02ba							;
    415  02ba		       a9 27		      lda	#LINBUF&$ff
    416  02bc		       85 4f		      sta	CURPTR
    417  02be		       a9 2f		      lda	#LINBUF>>8
    418  02c0		       85 50		      sta	CURPTR+1	;fall through...
    419  02c2
    420  02c2							;=====================================================
    421  02c2							; This is the top of the IL interpreter.  This fetches
    422  02c2							; and executes the instruction currently pointed to
    423  02c2							; by ILPC and adjusts ILPC to point to the next
    424  02c2							; instruction to execute.
    425  02c2							;
    426  02c2				   NextIL
    427  02c2		       ba		      tsx		; Get the stack pointer value
    428  02c3		       e0 ff		      cpx	#$FF	; Should be empty
    429  02c5		       d0 26		      bne	ILbad	; Halt and catch fire now!
    430  02c7
    431  02c7		       ce 66 27 	      dec	taskCurrentCycles
    432  02ca		       d0 03		      bne	NextIlNow
    433  02cc		       20 ba 17 	      jsr	iTaskSwitch	;check for a task switch
    434  02cf		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    435  02d1		       f0 03		      beq	NextIL2	;Skip if no bits set
    436  02d3
    437  02d3		       20 fd 1e 	      jsr	dbgLine	;Print the IL trace information
    438  02d6
    439  02d6		       a4 51	   NextIL2    ldy	CUROFF
    440  02d8							;		  jsr	  SkipSpaces
    441  02d8							;		  sty	  CUROFF
    442  02d8							;Task IO Management
    443  02d8		       ad c3 2f 	      lda	taskRDPending	; if it is zero then Nothing pending
    444  02db		       f0 08		      beq	NextILStr
    445  02dd		       20 a5 1c 	      jsr	ReadLine	; else Pending and poll keyboard
    446  02e0		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    447  02e2		       ce c3 2f 	      dec	taskRDPending	; Carry is set if CR has been recieved
    448  02e5							;
    449  02e5		       20 28 1b    NextILStr  jsr	getILByte
    450  02e8							;
    451  02e8							; When the handler is called, these are the conditions
    452  02e8							; of several important items:
    453  02e8							;
    454  02e8							;    (ILPC) will point to the byte AFTER the IL
    455  02e8							;    opcode being executed.
    456  02e8							;
    457  02e8							;    (CURPTR),CUROFF will point to the start of the
    458  02e8							;    next word in the input buffer.  Ie, the next word
    459  02e8							;    in the user program.
    460  02e8							;
    461  02e8		       0a		      asl
    462  02e9		       c9 dc		      cmp	#ILTBLend-ILTBL+2
    463  02eb		       90 33		      bcc	ILgood
    464  02ed							;
    465  02ed							; This handles an illegal IL opcode.  This is serious
    466  02ed							; and there's no way to recover.
    467  02ed							;
    468  02ed		       20 3d 14    ILbad      jsr	puts
      0  02f0					      db	CR,LF
      1  02f0		       0d 0a		      .byte.b	CR,LF
      0  02f2					      db	"Illegal IL "
      1  02f2		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02fd					      db	0
      1  02fd		       00		      .byte.b	0
    472  02fe							;
    473  02fe							; Well this is awkward, we need to back up the IL
    474  02fe							; by one since it no longer points to the current
    475  02fe							; opcode.
    476  02fe							;
    477  02fe		       20 35 1b 	      jsr	decIL
    478  0301							;
    479  0301		       a0 00		      ldy	#0
    480  0303		       b1 43		      lda	(ILPC),y
    481  0305		       20 20 14 	      jsr	OUTHEX
    482  0308		       20 3d 14 	      jsr	puts
      0  030b					      db	" at ",0
      1  030b		       20 61 74 20*	      .byte.b	" at ",0
    484  0310		       a5 44		      lda	ILPC+1
    485  0312		       20 20 14 	      jsr	OUTHEX
    486  0315		       a5 43		      lda	ILPC
    487  0317		       20 20 14 	      jsr	OUTHEX
    488  031a		       20 6c 1e 	      jsr	CRLF
    489  031d		       4c 03 f0 	      jmp	MONITOR
    490  0320							;
    491  0320							; Just jump to the address (ILPC),y.  Have to do
    492  0320							; some goofy stuff.
    493  0320							;
    494  0320		       a8	   ILgood     tay		;move index into Y
    495  0321		       b9 2e 03 	      lda	ILTBL,y
    496  0324		       85 59		      sta	dpl
    497  0326		       b9 2f 03 	      lda	ILTBL+1,y
    498  0329		       85 5a		      sta	dpl+1
    499  032b		       6c 59 00 	      jmp	(dpl)	;go to handler
    500  032e							;
    501  032e							;=====================================================
    502  032e							; This is the IL jump table.  The IL opcode is
    503  032e							; mulitplied by two, then looked-up in this table.
    504  032e							; There is absolutely nothing special about the order
    505  032e							; of entries here... they all decode at exactly the
    506  032e							; same speed.	However the entry number must match the
    507  032e							; values in IL.inc.
    508  032e							;
    509  032e				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  032e					      include	"ilvectortable.asm"
      1  032e					      seg	Code
      2  032e
      0  032e					      dw	iXINIT	;0
      1  032e		       40 04		      .word.w	iXINIT
      0  0330					      dw	iDONE	;1
      1  0330		       5b 04		      .word.w	iDONE
      0  0332					      dw	iPRS	;2
      1  0332		       72 04		      .word.w	iPRS
      0  0334					      dw	iPRN	;3
      1  0334		       7a 04		      .word.w	iPRN
      0  0336					      dw	iSPC	;4
      1  0336		       83 04		      .word.w	iSPC
      0  0338					      dw	iNLINE	;5
      1  0338		       37 09		      .word.w	iNLINE
      0  033a					      dw	iNXT	;6
      1  033a		       8b 04		      .word.w	iNXT
      0  033c					      dw	iXFER	;7
      1  033c		       cd 04		      .word.w	iXFER
      0  033e					      dw	iSAV	;8
      1  033e		       eb 04		      .word.w	iSAV
      0  0340					      dw	iRSTR	;9
      1  0340		       31 05		      .word.w	iRSTR
      0  0342					      dw	iCMPR	;10
      1  0342		       7f 05		      .word.w	iCMPR
      0  0344					      dw	iINNUM	;11
      1  0344		       fe 05		      .word.w	iINNUM
      0  0346					      dw	iFIN	;12
      1  0346		       36 06		      .word.w	iFIN
      0  0348					      dw	iERR	;13
      1  0348		       4a 06		      .word.w	iERR
      0  034a					      dw	iADD	;14
      1  034a		       c4 06		      .word.w	iADD
      0  034c					      dw	iSUB	;15
      1  034c		       da 06		      .word.w	iSUB
      0  034e					      dw	iNEG	;16
      1  034e		       f0 06		      .word.w	iNEG
      0  0350					      dw	iMUL	;17
      1  0350		       08 07		      .word.w	iMUL
      0  0352					      dw	iDIV	;18
      1  0352		       48 07		      .word.w	iDIV
      0  0354					      dw	iSTORE	;19
      1  0354		       9e 07		      .word.w	iSTORE
      0  0356					      dw	iIND	;20
      1  0356		       b6 07		      .word.w	iIND
      0  0358					      dw	iLST	;21
      1  0358		       2d 08		      .word.w	iLST
      0  035a					      dw	iINIT	;22
      1  035a		       08 04		      .word.w	iINIT
      0  035c					      dw	iGETLINE	;23
      1  035c		       63 08		      .word.w	iGETLINE
      0  035e					      dw	iINSRT	;24
      1  035e		       80 08		      .word.w	iINSRT
      0  0360					      dw	iRTN	;25
      1  0360		       31 09		      .word.w	iRTN
      0  0362					      dw	MONITOR	;26
      1  0362		       03 f0		      .word.w	MONITOR
      0  0364					      dw	iLIT	;27
      1  0364		       57 09		      .word.w	iLIT
      0  0366					      dw	iCALL	;28
      1  0366		       3d 09		      .word.w	iCALL
      0  0368					      dw	iJMP	;29
      1  0368		       45 09		      .word.w	iJMP
      0  036a					      dw	iVINIT	;30
      1  036a		       74 09		      .word.w	iVINIT
      0  036c					      dw	iERRGOTO	;31
      1  036c		       7d 09		      .word.w	iERRGOTO
      0  036e					      dw	iTST	;32
      1  036e		       89 09		      .word.w	iTST
      0  0370					      dw	iTSTV	;33
      1  0370		       ae 0a		      .word.w	iTSTV
      0  0372					      dw	iTSTL	;34
      1  0372		       32 0b		      .word.w	iTSTL
      0  0374					      dw	iTSTN	;35
      1  0374		       4d 0b		      .word.w	iTSTN
      0  0376					      dw	iFREE	;36
      1  0376		       fe 0b		      .word.w	iFREE
      0  0378					      dw	iRANDOM	;37
      1  0378		       07 0c		      .word.w	iRANDOM
      0  037a					      dw	iABS	;38
      1  037a		       d8 0c		      .word.w	iABS
     42  037c							;
     43  037c							; Disk functions.  There must be pointers
     44  037c							; to functions even if no disk is supported.
     45  037c							; Makes things easier in IL.inc.
     46  037c							;
     47  037c					      if	DISK_ACCESS
      0  037c					      dw	iOPENREAD	;39
      1  037c		       f0 20		      .word.w	iOPENREAD
      0  037e					      dw	iOPENWRITE	;40
      1  037e		       51 21		      .word.w	iOPENWRITE
      0  0380					      dw	iDCLOSE	;41
      1  0380		       d5 21		      .word.w	iDCLOSE
      0  0382					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0382		       63 21		      .word.w	iDGETLINE
      0  0384					      dw	iDLIST	;43 Did you remember your towel?
      1  0384		       cf 21		      .word.w	iDLIST
      0  0386					      dw	iDDIR	;44
      1  0386		       aa 21		      .word.w	iDDIR
      0  0388					      dw	iRMFILE	;45
      1  0388		       3f 21		      .word.w	iRMFILE
     55  038a				  -	      else
     56  038a				  -	      dw	NextIL	;39
     57  038a				  -	      dw	NextIL	;40
     58  038a				  -	      dw	NextIL	;41
     59  038a				  -	      dw	NextIL	;42
     60  038a				  -	      dw	NextIL	;43
     61  038a				  -	      dw	NextIL	;44
     62  038a				  -	      dw	NextIL	;45
     63  038a					      endif
     64  038a							;
      0  038a					      dw	iCLEARSCREEN	;46
      1  038a		       c0 1f		      .word.w	iCLEARSCREEN
      0  038c					      dw	iPOKEMEMORY	;47
      1  038c		       65 0c		      .word.w	iPOKEMEMORY
      0  038e					      dw	iPEEKMEMORY	;48
      1  038e		       7a 0c		      .word.w	iPEEKMEMORY
      0  0390					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0390		       d0 09		      .word.w	iTSTLET
      0  0392					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0392		       55 0a		      .word.w	iTSTDONE
      0  0394					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0394		       a7 0c		      .word.w	iGETCHAR
      0  0396					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0396		       bb 0c		      .word.w	iPUTCHAR
      0  0398					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0398		       90 0c		      .word.w	iCallFunc
      0  039a					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  039a		       cc 05		      .word.w	iBranch
      0  039c					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  039c		       b3 09		      .word.w	iTSTStr
      0  039e					      dw	iSetIrq	;56	   sets the irq handler
      1  039e		       55 0d		      .word.w	iSetIrq
      0  03a0					      dw	iTstIrq	;57	   test if irq is pending
      1  03a0		       c4 0b		      .word.w	iTstIrq
      0  03a2					      dw	iRET	;58	   return from interupt
      1  03a2		       1f 05		      .word.w	iRET
      0  03a4					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03a4		       17 06		      .word.w	iINSTR
      0  03a6					      dw	iMOD	;60	   returns remainder of division
      1  03a6		       51 07		      .word.w	iMOD
      0  03a8					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a8		       0e 18		      .word.w	iTaskSet
      0  03aa					      dw	iETask	;62	   Terminates a task
      1  03aa		       4b 19		      .word.w	iETask
      0  03ac					      dw	iNTask	;63	   goto next task
      1  03ac		       fe 18		      .word.w	iNTask
      0  03ae					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03ae		       d4 07		      .word.w	iArray
      0  03b0					      dw	iTaskKill	;65	   kill a running task
      1  03b0		       f6 18		      .word.w	iTaskKill
      0  03b2					      dw	iTaskStat	;66	   return the state of a task PID
      1  03b2		       ca 18		      .word.w	iTaskStat
      0  03b4					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03b4		       c6 0c		      .word.w	iHexOut
      0  03b6					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b6		       e8 05		      .word.w	iReadComplete
      0  03b8					      dw	iReadStart	;69	   Called to start a background read request
      1  03b8		       de 05		      .word.w	iReadStart
      0  03ba					      dw	iStartIO	;70	   Lock task until io complete
      1  03ba		       2e 19		      .word.w	iStartIO
      0  03bc					      dw	iEndIO	;71	   release task lock for io
      1  03bc		       34 19		      .word.w	iEndIO
      0  03be					      dw	iLogNot	;72	   Logical not
      1  03be		       31 0d		      .word.w	iLogNot
      0  03c0					      dw	iLogOr	;73	   Logical Or
      1  03c0		       07 0d		      .word.w	iLogOr
      0  03c2					      dw	iLogAnd	;74	   Logical And
      1  03c2		       f2 0c		      .word.w	iLogAnd
      0  03c4					      dw	iLogXor	;75	   Logical Xor
      1  03c4		       1c 0d		      .word.w	iLogXor
      0  03c6					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c6		       09 19		      .word.w	iWTASK
      0  03c8					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c8		       3f 19		      .word.w	iTASKPID
      0  03ca					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03ca		       93 0d		      .word.w	iTRACEPROG
      0  03cc					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03cc		       79 1e		      .word.w	idbgBasic
      0  03ce					      dw	iIPCS	;80	   Sending a msg to a task
      1  03ce		       01 1a		      .word.w	iIPCS
      0  03d0					      dw	iIPCR	;81	   Recieve a message from a task
      1  03d0		       18 1a		      .word.w	iIPCR
      0  03d2					      dw	iIPCC	;82	   Check if any message available for task
      1  03d2		       2c 1a		      .word.w	iIPCC
      0  03d4					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03d4		       39 1a		      .word.w	iIPCIO
      0  03d6					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d6		       86 16		      .word.w	iPushMathStack
      0  03d8					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d8		       b6 16		      .word.w	iPopMathStack
      0  03da					      dw	iSaveMathStack	;86	   Save all math info
      1  03da		       d3 16		      .word.w	iSaveMathStack
      0  03dc					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03dc		       f2 16		      .word.w	iRestoreMathStack
      0  03de					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03de		       a3 16		      .word.w	iIncParmCount
      0  03e0					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03e0		       6b 19		      .word.w	iTaskGetMathStack
      0  03e2					      dw	iTaskEnable	;90	   enable a suspended task
      1  03e2		       98 18		      .word.w	iTaskEnable
      0  03e4					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03e4		       b2 18		      .word.w	iTaskSuspend
      0  03e6					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e6		       85 19		      .word.w	iTaskPutMathPtr
      0  03e8					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e8		       a5 0a		      .word.w	iTSTVT
      0  03ea					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03ea		       4f 09		      .word.w	iSetR2
      0  03ec					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03ec		       fd 04		      .word.w	iStk2Tmp
      0  03ee					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03ee		       0e 05		      .word.w	iTmp2Stk
      0  03f0					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03f0		       f1 09		      .word.w	iTSTBYTE
      0  03f2					      dw	iINCVAR	;98	   Increment variable
      1  03f2		       77 0a		      .word.w	iINCVAR
      0  03f4					      dw	iDECVAR	;99	   Decrement variable
      1  03f4		       8f 0a		      .word.w	iDECVAR
      0  03f6					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f6		       94 19		      .word.w	iSLICE
      0  03f8					      dw	iTSTB	;101	   Test if byte equals
      1  03f8		       10 0a		      .word.w	iTSTB
      0  03fa					      dw	iTSTW	;102	   Test If word equals
      1  03fa		       2b 0a		      .word.w	iTSTW
      0  03fc					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03fc		       d4 12		      .word.w	iOnGoto
      0  03fe					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03fe		       05 13		      .word.w	iTSTRELOP
      0  0400					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  0400		       b1 04		      .word.w	iRepeatLine
      0  0402					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch is is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  0402		       2c 13		      .word.w	iTSTBRANCH
      0  0404					      dw	iFastXfer	;107	   move top of stack to curptr
      1  0404		       b8 04		      .word.w	iFastXfer
      0  0406					      dw	iSetTerminal	;108	   Set the Io Treminal to be used by print and input statements
      1  0406		       36 20		      .word.w	iSetTerminal
    128  0408
------- FILE mytb.asm
    511  0408		       04 08	   ILTBLend   equ	*
    512  0408							;
    513  0408							;=====================================================
    514  0408							;=====================================================
    515  0408							;=====================================================
    516  0408							; This marks the start of the handlers for IL opcodes.
    517  0408							;=====================================================
    518  0408							;=====================================================
    519  0408							;=====================================================
    520  0408							;
    521  0408							;
    522  0408		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    523  040a		       85 47		      sta	ILSTACKPTR
    524  040c		       85 4a		      sta	MATHSTACKPTR
    525  040e		       85 4d		      sta	GOSUBSTACKPTR
    526  0410		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    527  0412		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    528  0414							;
    529  0414		       ad c4 2f 	      lda	ProgramStart	; user prog
    530  0417		       85 4f		      sta	CURPTR
    531  0419		       8d 6d 26 	      sta	taskTable+1
    532  041c		       8d c6 2f 	      sta	ProgramEnd
    533  041f		       ad c5 2f 	      lda	ProgramStart+1
    534  0422		       85 50		      sta	CURPTR+1
    535  0424		       8d 6e 26 	      sta	taskTable+2
    536  0427		       8d c7 2f 	      sta	ProgramEnd+1
    537  042a		       a9 80		      lda	#TASKACTIVE
    538  042c		       8d 6c 26 	      sta	taskTable	;Mark the first slot as active
    539  042f		       a9 01		      lda	#1
    540  0431		       8d 6a 27 	      sta	taskCounter	;there is always one task / Main task
    541  0434		       ad 68 27 	      lda	taskResetValue
    542  0437		       8d 66 27 	      sta	taskCurrentCycles	; set up the task switch counts
    543  043a		       ad 69 27 	      lda	taskResetValue+1
    544  043d		       8d 67 27 	      sta	taskCurrentCycles+1
    545  0440							;
    546  0440							; fall into XINIT...
    547  0440							;
    548  0440							;=====================================================
    549  0440							; This initializes for the start of the next line of
    550  0440							; BASIC text.
    551  0440							;
    552  0440		       78	   iXINIT     sei		;ensure interupts are off
    553  0441		       20 91 17 	      jsr	taskReset	;Clear the task table
    554  0444		       8d 68 26 	      sta	IRQPending	; reset the irq pending
    555  0447		       8d 67 26 	      sta	IRQStatus	; Make sure irqs are off
    556  044a
    557  044a		       4c c2 02    goodExit   jmp	NextIL
    558  044d							;
    559  044d							;=====================================================
    560  044d							; This check if the escape key has been entered
    561  044d							; then changes out of run mode. z Set if esc found
    562  044d				   BreakSet
    563  044d		       20 0f f0 	      jsr	ISCHAR
    564  0450		       f0 06		      beq	BreakNo
    565  0452		       20 bd 1f 	      jsr	VGETCH
    566  0455		       c9 1b		      cmp	#$1B
    567  0457		       60		      rts
    568  0458				   BreakNo
    569  0458		       a9 01		      lda	#1
    570  045a		       60		      rts
    571  045b
    572  045b							;
    573  045b
    574  045b							;=====================================================
    575  045b							; Verify there is nothing else on this input line.
    576  045b							; If there is, generate an error.
    577  045b							;
    578  045b		       a4 51	   iDONE      ldy	CUROFF
    579  045d		       b1 4f		      lda	(CURPTR),y
    580  045f		       f0 0e		      beq	doneadv
    581  0461		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    582  0463		       d0 03		      bne	idoneErr
    583  0465							;		  sty	  CUROFF
    584  0465		       4c c2 02 	      jmp	NextIL	; continue on this line
    585  0468
    586  0468				   idoneErr
    587  0468		       a2 04		      ldx	#ERR_EXTRA_STUFF
    588  046a		       a9 00		      lda	#0
    589  046c		       4c a9 06 	      jmp	iErr2
    590  046f							;
    591  046f							; Advance to the next line
    592  046f							;
    593  046f				   doneadv
    594  046f		       4c c2 02 	      jmp	NextIL
    595  0472							;
    596  0472							;=====================================================
    597  0472							; Print the string until a closing quote
    598  0472							;
    599  0472				   iPRS
    600  0472		       20 60 14 	      jsr	PrtQuoted
    601  0475		       84 51		      sty	CUROFF
    602  0477		       4c c2 02 	      jmp	NextIL
    603  047a							;
    604  047a							;=====================================================
    605  047a							; Pop the top off the stack and print it as a signed
    606  047a							; decimal number.
    607  047a							;
    608  047a				   iPRN
    609  047a		       20 b3 1d 	      jsr	popR0
    610  047d		       20 6e 13 	      jsr	PrintDecimal
    611  0480		       4c c2 02 	      jmp	NextIL
    612  0483							;
    613  0483							;=====================================================
    614  0483							; Space to next zone.	Currently the code does not
    615  0483							; keep track of which column the output is on, so
    616  0483							; just print a tab.
    617  0483							;
    618  0483				   iSPC
    619  0483		       a9 09		      lda	#TAB
    620  0485		       20 ba 1f 	      jsr	VOUTCH
    621  0488		       4c c2 02 	      jmp	NextIL
    622  048b							;
    623  048b							;=====================================================
    624  048b							; If in immediate mode, jump to the address following
    625  048b							; the NXT instruction.  Else move to the next line of
    626  048b							; user code and continue.
    627  048b							;
    628  048b		       a5 5b	   iNXT       lda	RunMode
    629  048d		       d0 03		      bne	iNxtRun	;in run mode
    630  048f							;
    631  048f							; Get address and jump to it.
    632  048f							;
    633  048f		       4c 45 09 	      jmp	iJMP
    634  0492							;
    635  0492				   iNxtRun
    636  0492		       a4 51		      ldy	CUROFF
    637  0494		       b1 4f		      lda	(CURPTR),y
    638  0496		       c9 e6		      cmp	#oColon
    639  0498		       d0 06		      bne	iNxtRunGo
    640  049a		       c8		      iny
    641  049b		       84 51		      sty	CUROFF
    642  049d		       4c ab 04 	      jmp	iNxtRun2
    643  04a0
    644  04a0				   iNxtRunGo
    645  04a0		       20 b2 1b 	      jsr	FindNextLine
    646  04a3		       20 c6 1b 	      jsr	AtEnd
    647  04a6		       d0 03		      bne	iNxtRun2	;not at end
    648  04a8							;
    649  04a8							; At the end of the program.  Pretend an END statement
    650  04a8							; was found.
    651  04a8							;
    652  04a8		       4c 36 06    iFINv      jmp	iFIN
    653  04ab							;
    654  04ab		       20 24 1b    iNxtRun2   jsr	getILWord	;ignore next word
    655  04ae		       4c c2 02 	      jmp	NextIL
    656  04b1							;=====================================================
    657  04b1							;Repeat the same line against
    658  04b1		       a0 03	   iRepeatLine ldy	#3
    659  04b3		       84 51		      sty	CUROFF
    660  04b5		       4c c2 02 	      jmp	NextIL
    661  04b8							;
    662  04b8							;=====================================================
    663  04b8							; XFER takes the number on top of the stack and looks
    664  04b8							; for that line in the program, or the next line
    665  04b8							; higher.  Ie, if it's 1 but there is no line 1, then
    666  04b8							; find the next one after that.
    667  04b8							;
    668  04b8				   iFastXfer
    669  04b8		       20 cb 1d 	      jsr	popR1	; get type of transfer
    670  04bb		       a5 54		      lda	R1
    671  04bd		       f0 0e		      beq	iXFER
    672  04bf
    673  04bf		       20 b3 1d 	      jsr	popR0	; get where to transfer
    674  04c2		       a5 52		      lda	R0
    675  04c4		       85 4f		      sta	CURPTR
    676  04c6		       a5 53		      lda	R0+1
    677  04c8		       85 50		      sta	CURPTR+1
    678  04ca		       4c d3 04 	      jmp	iXFER2
    679  04cd
    680  04cd				   iXFER
    681  04cd		       20 b3 1d 	      jsr	popR0
    682  04d0		       20 6d 1b 	      jsr	findLine
    683  04d3
    684  04d3				   iXFER2
    685  04d3		       20 c6 1b 	      jsr	AtEnd	;at end of user program?
    686  04d6		       f0 d0		      beq	iFINv
    687  04d8
    688  04d8		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    689  04da		       84 51		      sty	CUROFF
    690  04dc
    691  04dc							;		  lda	  #$ff
    692  04dc							;		  sta	  RunMode
    693  04dc							;
    694  04dc							; Transfer IL to STMT.  I don't like having this
    695  04dc							; hard-coded; fix it.
    696  04dc							;
    697  04dc							;		  lda	  #STMT&$ff
    698  04dc							;		  sta	  ILPC
    699  04dc							;		  lda	  #STMT>>8
    700  04dc							;		  sta	  ILPC+1
    701  04dc							;		  jmp	  NextIL
    702  04dc							;
    703  04dc							; Run
    704  04dc							;
    705  04dc				   iXferok
    706  04dc		       a9 ff		      lda	#$ff
    707  04de		       85 5b		      sta	RunMode	;we're running
    708  04e0							;
    709  04e0							; Need a more elegant way to do this
    710  04e0							;
    711  04e0		       a9 a4		      lda	#STMT&$ff
    712  04e2		       85 43		      sta	ILPC
    713  04e4		       a9 22		      lda	#STMT>>8
    714  04e6		       85 44		      sta	ILPC+1
    715  04e8		       4c c2 02 	      jmp	NextIL
    716  04eb							;
    717  04eb							;=====================================================
    718  04eb							; Save the pointer to the next line to the call stack.
    719  04eb							;
    720  04eb		       20 28 1b    iSAV       jsr	getILByte	; load type of gosub
    721  04ee		       20 3b 1d 	      jsr	pushLN	; Type passed in A
    722  04f1		       b0 03		      bcs	iSAVErr
    723  04f3		       4c c2 02 	      jmp	NextIL
    724  04f6
    725  04f6		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    726  04f8		       a9 00	   iSAVErr2   lda	#0
    727  04fa		       4c a9 06 	      jmp	iErr2
    728  04fd							;====================================================
    729  04fd							; Move stack top to and from temp area
    730  04fd				   iStk2Tmp
    731  04fd		       20 b3 1d 	      jsr	popR0
    732  0500		       a5 52		      lda	R0
    733  0502		       a0 34		      ldy	#TASKEXITCODE	; can also be used as temp
    734  0504		       91 41		      sta	(VARIABLES),y
    735  0506		       c8		      iny
    736  0507		       a5 53		      lda	R0+1
    737  0509		       91 41		      sta	(VARIABLES),y
    738  050b		       4c c2 02 	      jmp	NextIL
    739  050e
    740  050e		       a0 34	   iTmp2Stk   ldy	#TASKEXITCODE
    741  0510		       b1 41		      lda	(VARIABLES),y
    742  0512		       85 52		      sta	R0
    743  0514		       c8		      iny
    744  0515		       b1 41		      lda	(VARIABLES),y
    745  0517		       85 53		      sta	R0+1
    746  0519		       20 21 1d 	      jsr	pushR0
    747  051c		       4c c2 02 	      jmp	NextIL
    748  051f							;
    749  051f							;=====================================================
    750  051f							; Pop the next line from the call stack.
    751  051f							;
    752  051f		       20 64 1d    iRET       jsr	popLN
    753  0522		       b0 d2		      bcs	iSAVErr
    754  0524		       a0 03		      ldy	#3
    755  0526		       84 51		      sty	CUROFF
    756  0528		       a9 00		      lda	#0
    757  052a		       8d 68 26 	      sta	IRQPending
    758  052d		       58		      cli
    759  052e		       4c c2 02 	      jmp	NextIL
    760  0531							;
    761  0531							;=====================================================
    762  0531							; On entry il, branch to if function
    763  0531							;	    il+1, value to be returned or not true or false
    764  0531							;
    765  0531							; Return from GOSUB function
    766  0531							;
    767  0531		       20 28 1b    iRSTR      jsr	getILByte	; get where to go if gosub is a fucntion
    768  0534		       8d c0 2f 	      sta	offset
    769  0537		       20 0b 1d 	      jsr	saveIL	; for later jump if needed
    770  053a
    771  053a		       20 64 1d 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    772  053d		       85 54		      sta	R1	; keep the type of call returning from
    773  053f		       b0 2a		      bcs	iRSTRErr	; stack underflow error possible
    774  0541
    775  0541		       20 28 1b 	      jsr	getILByte	; get if a value is being returned
    776  0544		       48		      pha		; save if a value was passed to be returned
    777  0545		       c9 00		      cmp	#0	; yes attemping to return a value
    778  0547		       f0 03		      beq	iRSTRPOP	; no value to return
    779  0549		       20 b3 1d 	      jsr	popR0	; Get the value from the stack save if needed
    780  054c				   iRSTRPOP
    781  054c		       20 bc 16 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    782  054f		       a5 54		      lda	R1	; called as a statement ?
    783  0551		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    784  0553		       f0 12		      beq	iRSTRExit
    785  0555		       68		      pla		; get back if value returned or not
    786  0556		       c9 01		      cmp	#1	; we have a value to return
    787  0558		       f0 04		      beq	iRSTRVALUE
    788  055a
    789  055a		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    790  055c		       d0 9a		      bne	iSAVErr2
    791  055e
    792  055e				   iRSTRVALUE
    793  055e		       20 21 1d 	      jsr	pushR0	; return value back to top of stack
    794  0561		       20 16 1d 	      jsr	restoreIL	; get the correct il
    795  0564		       4c a5 0b 	      jmp	tstBranch	; And called as a function
    796  0567
    797  0567				   iRSTRExit
    798  0567		       68		      pla		; throw away the return value if provided
    799  0568		       4c c2 02 	      jmp	NextIL
    800  056b
    801  056b				   iRSTRNORETURNVALUE
    802  056b
    803  056b
    804  056b		       ad 6b 26    iRSTRErr   lda	taskPtr	; Check if this is task zero
    805  056e		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    806  0570		       a5 56		      lda	MQ
    807  0572		       d0 03		      bne	taskRet
    808  0574		       20 d5 1f 	      jsr	pushFalse	; the result code by default is 0
    809  0577				   taskRet
    810  0577		       4c 4b 19 	      jmp	iETask	; not task zero then do a task end instead
    811  057a				   taskZeroEnd
    812  057a		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    813  057c		       4c f8 04 	      jmp	iSAVErr2
    814  057f							;
    815  057f							;=====================================================
    816  057f							; Compare items on stack.  Okay, so on input there are
    817  057f							; three things on the stack
    818  057f							;
    819  057f							;    EXPR2 <- Top of stack
    820  057f							;    OP    <- relational operator, next on stack
    821  057f							;    EXPR1 <- last item on stack
    822  057f							;
    823  057f							; Comparison is: EXPR1 <operator> EXPR2
    824  057f							;
    825  057f							; Operator is one of...
    826  057f							;
    827  057f							;    2 is =
    828  057f							;    1 is <
    829  057f							;    3 is <=
    830  057f							;    5 is <>
    831  057f							;    4 is >
    832  057f							;    6 is >=
    833  057f							;
    834  057f							; Those are bit-mapped:
    835  057f							;
    836  057f							;    xxxxxGEL
    837  057f							;
    838  057f							;    G = Greater than
    839  057f							;    E = Equal
    840  057f							;    L = Less than
    841  057f							;
    842  057f							; If the comparison is false, do a NXT, ie, move to the
    843  057f							; next line and continue.  If true, continue executing
    844  057f							; on this line.
    845  057f							;
    846  057f		       00 01	   REL_LT     equ	%001
    847  057f		       00 02	   REL_EQUAL  equ	%010
    848  057f		       00 04	   REL_GT     equ	%100
    849  057f							;
    850  057f		       20 cb 1d    iCMPR      jsr	popR1
    851  0582		       20 e2 1d 	      jsr	popMQ	;operator in MQ
    852  0585		       20 b3 1d 	      jsr	popR0
    853  0588		       20 91 05 	      jsr	iCMPRsub
    854  058b		       20 21 1d 	      jsr	pushR0
    855  058e		       4c c2 02 	      jmp	NextIL
    856  0591							;
    857  0591							; See if they are equal or not
    858  0591							;
    859  0591				   iCMPRsub		; Called by internal functions
    860  0591
    861  0591		       a5 52		      lda	R0
    862  0593		       c5 54		      cmp	R1
    863  0595		       d0 0a		      bne	iCMPRnoteq	;try not equal
    864  0597		       a5 53		      lda	R0+1
    865  0599		       c5 55		      cmp	R1+1
    866  059b		       d0 04		      bne	iCMPRnoteq
    867  059d							;
    868  059d							; Equal, set the flag in MQ+1
    869  059d							;
    870  059d		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    871  059f		       d0 14		      bne	iCMPcom	;Exit it is equal
    872  05a1							;
    873  05a1							; See if EXPR1 (R0) < EXPR2 (R1)
    874  05a1							; See www.6502.org/tutorials/compare_beyond.html
    875  05a1							;
    876  05a1				   iCMPRnoteq
    877  05a1		       a5 52		      lda	R0
    878  05a3		       c5 54		      cmp	R1	; Sets the carry flag
    879  05a5		       a5 53		      lda	R0+1
    880  05a7		       e5 55		      sbc	R1+1
    881  05a9
    882  05a9		       50 02		      bvc	iCMPR_2	; branch if N eor V
    883  05ab		       49 80		      eor	#$80
    884  05ad
    885  05ad		       30 04	   iCMPR_2    bmi	iCMPlt
    886  05af		       a9 04		      lda	#REL_GT
    887  05b1		       d0 02		      bne	iCMPcom
    888  05b3
    889  05b3		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    890  05b5
    891  05b5				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    892  05b5							;
    893  05b5							; Now compare the end result with what the caller
    894  05b5							; was looking for.
    895  05b5							;
    896  05b5		       25 56		      and	MQ
    897  05b7		       f0 0c		      beq	iCMPno	; no match
    898  05b9		       a9 ff		      lda	#$FF	; true is $ffff
    899  05bb		       85 52		      sta	R0
    900  05bd		       85 53		      sta	R0+1
    901  05bf		       d0 0a		      bne	iCMPDone
    902  05c1							;
    903  05c1							; R0 > R1
    904  05c1							;
    905  05c1		       a9 04	   iCMPgt     lda	#REL_GT
    906  05c3		       d0 f0		      bne	iCMPcom
    907  05c5				   iCMPno
    908  05c5		       a9 00		      lda	#0
    909  05c7		       85 52		      sta	R0
    910  05c9		       85 53		      sta	R0+1
    911  05cb
    912  05cb				   iCMPDone
    913  05cb		       60		      rts
    914  05cc
    915  05cc							;
    916  05cc							; if Not a match, so jump to the next line of code.
    917  05cc							; Branches based upon value on top of the stack
    918  05cc				   iBranch
    919  05cc		       20 b3 1d 	      jsr	popR0
    920  05cf		       a5 52		      lda	R0
    921  05d1		       05 53		      ora	R0+1
    922  05d3		       f0 03		      beq	iBranchFalse	; not true
    923  05d5		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    924  05d8							;
    925  05d8				   iBranchFalse
    926  05d8		       20 b2 1b 	      jsr	FindNextLine
    927  05db		       4c d3 04 	      jmp	iXFER2
    928  05de							;
    929  05de							;=====================================================
    930  05de							; Start a read of data in background
    931  05de				   iReadStart
    932  05de		       a9 3f		      lda	#'?	; Prompt with question mark
    933  05e0		       a6 01		      ldx	1	; Indicate to start read in background
    934  05e2		       20 3e 1c 	      jsr	GetLine	; Call the getline to start read
    935  05e5		       4c c2 02 	      jmp	NextIL	; next instruction
    936  05e8							;
    937  05e8							;=====================================================
    938  05e8							; Complete the read and return the curptr, curoff pointing to data
    939  05e8				   iReadComplete
    940  05e8		       a9 01		      lda	#GOSUB_RTN
    941  05ea		       20 3b 1d 	      jsr	pushLN
    942  05ed		       90 03		      bcc	iReadOk
    943  05ef		       4c f7 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    944  05f2				   iReadOk
    945  05f2		       20 5e 1c 	      jsr	ReadComplete
    946  05f5		       4c c2 02 	      jmp	NextIL
    947  05f8		       20 64 1d 	      jsr	popLN
    948  05fb		       4c c2 02 	      jmp	NextIL
    949  05fe							;=====================================================
    950  05fe							; Get a line of text from the user, convert to a
    951  05fe							; number, leave on top of stack.
    952  05fe							;
    953  05fe				   iINNUM
    954  05fe		       a9 01		      lda	#GOSUB_RTN
    955  0600		       20 3b 1d 	      jsr	pushLN
    956  0603		       b0 ea		      bcs	iReadErr	; Stack over flow error
    957  0605							;
    958  0605		       a9 3f		      lda	#'?
    959  0607		       a2 00		      ldx	#0	;Wait for complete
    960  0609		       20 3e 1c 	      jsr	GetLine
    961  060c		       20 d3 1b 	      jsr	getDecimal
    962  060f		       20 21 1d 	      jsr	pushR0	;put onto stack
    963  0612		       b0 db		      bcs	iReadErr	;StackOverflow error
    964  0614							;
    965  0614		       4c 30 06 	      jmp	ExitIn
    966  0617							;
    967  0617							;=====================================================
    968  0617							; Get a line of text from the user, convert to a
    969  0617							; character value , leave on top of stack. up to 2 characters
    970  0617							;
    971  0617				   iINSTR
    972  0617		       a9 01		      lda	#GOSUB_RTN
    973  0619		       20 3b 1d 	      jsr	pushLN
    974  061c		       b0 d1		      bcs	iReadErr	; Stack overflow error
    975  061e		       a9 3f		      lda	#'?
    976  0620		       a2 00		      ldx	#0	;wait for read complete
    977  0622		       20 3e 1c 	      jsr	GetLine
    978  0625		       b1 4f		      lda	(CURPTR),y
    979  0627		       85 52		      sta	R0
    980  0629		       a9 00		      lda	#0
    981  062b		       85 53		      sta	R0+1
    982  062d		       20 21 1d 	      jsr	pushR0	;put onto stack
    983  0630				   ExitIn
    984  0630		       20 64 1d 	      jsr	popLN
    985  0633		       4c c2 02 	      jmp	NextIL
    986  0636							;
    987  0636							;
    988  0636							;=====================================================
    989  0636							; Stop the currently running program.	Actually very
    990  0636							; simple to do... clear the RunMode flag, then set the
    991  0636							; ILPC to the standard handler and continue running.
    992  0636							;
    993  0636		       a9 00	   iFIN       lda	#0
    994  0638		       85 5b		      sta	RunMode
    995  063a		       20 91 17 	      jsr	taskReset
    996  063d							;
    997  063d		       ad b1 2f 	      lda	errGoto
    998  0640		       85 43		      sta	ILPC
    999  0642		       ad b2 2f 	      lda	errGoto+1
   1000  0645		       85 44		      sta	ILPC+1
   1001  0647		       4c c2 02 	      jmp	NextIL
   1002  064a							;
   1003  064a							;=====================================================
   1004  064a							; Handle the ERR opcode.  Following the instruction is
   1005  064a							; a 16 bit error number.  Print an error message, and
   1006  064a							; if we're in run mode, print the line number.  Stop
   1007  064a							; program execution and return to the initial state.
   1008  064a							;
   1009  064a		       20 24 1b    iERR       jsr	getILWord	;get err code
   1010  064d		       20 53 06 	      jsr	DisplayError
   1011  0650		       4c ac 06 	      jmp	iErrComplete
   1012  0653							;
   1013  0653							; Enter here with the error code in X (LSB) and A (MSB).
   1014  0653							;
   1015  0653				   DisplayError
   1016  0653		       86 52		      stx	R0
   1017  0655		       85 53		      sta	R0+1
   1018  0657							;
   1019  0657		       20 3d 14 	      jsr	puts
      0  065a					      db	CR,LF,"Error ",0
      1  065a		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
   1021  0663		       20 6e 13 	      jsr	PrintDecimal
   1022  0666							;
   1023  0666		       a5 5b		      lda	RunMode	;running?
   1024  0668		       f0 3b		      beq	iERR3	;nope
   1025  066a		       20 3d 14 	      jsr	puts
      0  066d					      db	" at line ",0
      1  066d		       20 61 74 20*	      .byte.b	" at line ",0
   1027  0677		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
   1028  0679				   iErr2a
   1029  0679		       b1 4f		      lda	(CURPTR),y
   1030  067b		       85 52		      sta	R0
   1031  067d		       c8		      iny
   1032  067e		       b1 4f		      lda	(CURPTR),y
   1033  0680		       85 53		      sta	R0+1
   1034  0682		       20 6e 13 	      jsr	PrintDecimal
   1035  0685		       20 3d 14 	      jsr	puts
      0  0688					      db	":",0
      1  0688		       3a 00		      .byte.b	":",0
   1037  068a		       a9 00		      lda	#0
   1038  068c		       85 53		      sta	R0+1
   1039  068e		       a5 51		      lda	CUROFF
   1040  0690		       18		      clc
   1041  0691		       e9 03		      sbc	#3
   1042  0693		       85 52		      sta	R0
   1043  0695		       20 6e 13 	      jsr	PrintDecimal
   1044  0698		       20 3d 14 	      jsr	puts
      0  069b					      db	":",0
      1  069b		       3a 00		      .byte.b	":",0
   1046  069d		       ad 6b 26 	      lda	taskPtr
   1047  06a0		       85 52		      sta	R0
   1048  06a2		       20 6e 13 	      jsr	PrintDecimal
   1049  06a5							;
   1050  06a5				   iERR3
   1051  06a5		       20 6c 1e 	      jsr	CRLF
   1052  06a8		       60		      rts
   1053  06a9
   1054  06a9				   iErr2
   1055  06a9		       20 53 06 	      jsr	DisplayError
   1056  06ac
   1057  06ac				   iErrComplete
   1058  06ac		       20 89 17 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1059  06af		       a9 00		      lda	#0
   1060  06b1		       85 5b		      sta	RunMode	; fall through...
   1061  06b3							;
   1062  06b3							;=====================================================
   1063  06b3							; Reset the IL to be back at the idle loop.  Does not
   1064  06b3							; clear variables so the user can see what state
   1065  06b3							; the program is in.
   1066  06b3							;
   1067  06b3		       a9 00	   ResetIL    lda	#0
   1068  06b5		       85 47		      sta	ILSTACKPTR
   1069  06b7		       ad b1 2f 	      lda	errGoto
   1070  06ba		       85 43		      sta	ILPC
   1071  06bc		       ad b2 2f 	      lda	errGoto+1
   1072  06bf		       85 44		      sta	ILPC+1
   1073  06c1		       4c c2 02 	      jmp	NextIL
   1074  06c4
   1075  06c4							;
   1076  06c4							;=====================================================
   1077  06c4							; Pop two items off stack, add them, then place the
   1078  06c4							; result back onto the stack.
   1079  06c4							;
   1080  06c4		       20 b3 1d    iADD       jsr	popR0
   1081  06c7		       20 cb 1d 	      jsr	popR1
   1082  06ca				   iADDfast
   1083  06ca		       18		      clc
   1084  06cb		       a5 52		      lda	R0
   1085  06cd		       65 54		      adc	R1
   1086  06cf		       85 52		      sta	R0
   1087  06d1		       a5 53		      lda	R0+1
   1088  06d3		       65 55		      adc	R1+1
   1089  06d5		       85 53		      sta	R0+1
   1090  06d7		       4c 42 07 	      jmp	pushR0nextIl
   1091  06da							;
   1092  06da							;=====================================================
   1093  06da							; Pop two items off the stack.  Subtract the top of
   1094  06da							; stack from the lower entry.
   1095  06da							;
   1096  06da		       20 cb 1d    iSUB       jsr	popR1
   1097  06dd		       20 b3 1d 	      jsr	popR0
   1098  06e0		       38		      sec
   1099  06e1		       a5 52		      lda	R0
   1100  06e3		       e5 54		      sbc	R1
   1101  06e5		       85 52		      sta	R0
   1102  06e7		       a5 53		      lda	R0+1
   1103  06e9		       e5 55		      sbc	R1+1
   1104  06eb		       85 53		      sta	R0+1
   1105  06ed		       4c 42 07 	      jmp	pushR0nextIl
   1106  06f0							;
   1107  06f0							;=====================================================
   1108  06f0							; Negate the top of stack.
   1109  06f0							;
   1110  06f0		       20 b3 1d    iNEG       jsr	popR0
   1111  06f3		       a5 52		      lda	R0
   1112  06f5		       49 ff		      eor	#$ff
   1113  06f7		       85 52		      sta	R0
   1114  06f9		       a5 53		      lda	R0+1
   1115  06fb		       49 ff		      eor	#$ff
   1116  06fd		       85 53		      sta	R0+1
   1117  06ff		       e6 52		      inc	R0
   1118  0701		       d0 02		      bne	iNEG2
   1119  0703		       e6 53		      inc	R0+1
   1120  0705		       4c 42 07    iNEG2      jmp	pushR0nextIl
   1121  0708							;
   1122  0708							;=====================================================
   1123  0708							; Multiply top two items on the stack, put the results
   1124  0708							; on top.  This uses the algorithm documented on page
   1125  0708							; 115 of "Microprocessor Programming for Computer
   1126  0708							; Hobbyists" by Neill Graham.
   1127  0708							;
   1128  0708		       20 0e 07    iMUL       jsr	iMultiply
   1129  070b		       4c c2 02 	      jmp	NextIL
   1130  070e
   1131  070e				   iMultiply
   1132  070e		       20 b3 1d 	      jsr	popR0	;AC
   1133  0711		       20 cb 1d 	      jsr	popR1	;OP
   1134  0714							;
   1135  0714		       a5 52		      lda	R0
   1136  0716		       85 56		      sta	MQ
   1137  0718		       a5 53		      lda	R0+1
   1138  071a		       85 57		      sta	MQ+1
   1139  071c		       a9 00		      lda	#0	;clear result
   1140  071e		       85 52		      sta	R0
   1141  0720		       85 53		      sta	R0+1
   1142  0722							;
   1143  0722		       a2 10		      ldx	#16	;number of bits in value
   1144  0724		       06 52	   multloop   asl	R0
   1145  0726		       26 53		      rol	R0+1
   1146  0728		       06 56		      asl	MQ
   1147  072a		       26 57		      rol	MQ+1
   1148  072c		       90 0d		      bcc	multno	;skip add if no carry
   1149  072e							;
   1150  072e							; Add R1 back into R0
   1151  072e							;
   1152  072e		       18		      clc
   1153  072f		       a5 52		      lda	R0
   1154  0731		       65 54		      adc	R1
   1155  0733		       85 52		      sta	R0
   1156  0735		       a5 53		      lda	R0+1
   1157  0737		       65 55		      adc	R1+1
   1158  0739		       85 53		      sta	R0+1
   1159  073b							;
   1160  073b		       ca	   multno     dex		;did all bits yet?
   1161  073c		       d0 e6		      bne	multloop
   1162  073e		       20 21 1d 	      jsr	pushR0	;OP
   1163  0741		       60		      rts
   1164  0742							;
   1165  0742				   pushR0nextIl
   1166  0742		       20 21 1d 	      jsr	pushR0	;OP
   1167  0745		       4c c2 02 	      jmp	NextIL
   1168  0748							;
   1169  0748							;=====================================================
   1170  0748							; Divide the top of stack into the next to top item.
   1171  0748							; Leave results on stack.  Taken from:
   1172  0748							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1173  0748							;
   1174  0748							; R0 = R0 / R1
   1175  0748							; Remainder is in MQ
   1176  0748							;
   1177  0748		       20 62 07    iDIV       jsr	iDoDiv
   1178  074b		       20 34 1e 	      jsr	RestoreSigns
   1179  074e		       4c 42 07 	      jmp	pushR0nextIl
   1180  0751
   1181  0751		       20 62 07    iMOD       jsr	iDoDiv
   1182  0754		       20 34 1e 	      jsr	RestoreSigns
   1183  0757		       a5 56		      lda	MQ
   1184  0759		       85 52		      sta	R0
   1185  075b		       a5 57		      lda	MQ+1
   1186  075d		       85 53		      sta	R0+1
   1187  075f		       4c 42 07 	      jmp	pushR0nextIl
   1188  0762
   1189  0762				   iDoDiv
   1190  0762		       20 cb 1d 	      jsr	popR1
   1191  0765		       20 b3 1d 	      jsr	popR0
   1192  0768							;
   1193  0768							; Check for divide by zero
   1194  0768							;
   1195  0768
   1196  0768				   iDivNoPop
   1197  0768		       a5 54		      lda	R1
   1198  076a		       05 55		      ora	R1+1
   1199  076c		       f0 29		      beq	divby0
   1200  076e							;
   1201  076e		       20 f9 1d 	      jsr	SaveSigns
   1202  0771		       a9 00		      lda	#0	;preset remainder to 0
   1203  0773		       85 56		      sta	MQ
   1204  0775		       85 57		      sta	MQ+1
   1205  0777		       a2 10		      ldx	#16	;repeat for each bit: ...
   1206  0779				   divloop
   1207  0779		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1208  077b		       26 53		      rol	R0+1
   1209  077d		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1210  077f		       26 57		      rol	MQ+1
   1211  0781		       a5 56		      lda	MQ
   1212  0783		       38		      sec
   1213  0784		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1214  0786		       a8		      tay		;lb result -> Y, for we may need it later
   1215  0787		       a5 57		      lda	MQ+1
   1216  0789		       e5 55		      sbc	R1+1
   1217  078b		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1218  078d
   1219  078d		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1220  078f		       84 56		      sty	MQ
   1221  0791		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1222  0793
   1223  0793		       ca	   skip       dex
   1224  0794		       d0 e3		      bne	divloop
   1225  0796		       60		      rts
   1226  0797							;
   1227  0797							; Indicate divide-by-zero error
   1228  0797							;
   1229  0797		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1230  0799		       a9 00		      lda	#0
   1231  079b		       4c a9 06 	      jmp	iErr2
   1232  079e							;
   1233  079e							;=====================================================
   1234  079e							; This pops the top two items off the stack.  The top
   1235  079e							; item is a data value and the other is an ABSOLUTE address.
   1236  079e							; Save the value into that address.
   1237  079e							;
   1238  079e		       98	   iSTORE     tya
   1239  079f		       48		      pha
   1240  07a0		       20 b3 1d 	      jsr	popR0	;data
   1241  07a3		       20 cb 1d 	      jsr	popR1	;Storage location
   1242  07a6		       a0 00		      ldy	#0
   1243  07a8		       a5 52		      lda	R0
   1244  07aa		       91 54		      sta	(R1),y
   1245  07ac		       a5 53		      lda	R0+1
   1246  07ae		       c8		      iny
   1247  07af		       91 54		      sta	(R1),y
   1248  07b1		       68		      pla
   1249  07b2		       a8		      tay
   1250  07b3		       4c c2 02 	      jmp	NextIL
   1251  07b6							;
   1252  07b6							;=====================================================
   1253  07b6							; Replaces the top of stack with the Value
   1254  07b6							; of the variable  whose absolute address it represents.
   1255  07b6							;
   1256  07b6		       98	   iIND       tya
   1257  07b7		       48		      pha
   1258  07b8		       20 cb 1d 	      jsr	popR1
   1259  07bb		       a0 00		      ldy	#0
   1260  07bd		       b1 54		      lda	(R1),y
   1261  07bf		       85 52		      sta	R0
   1262  07c1		       c8		      iny
   1263  07c2		       b1 54		      lda	(R1),y
   1264  07c4		       85 53		      sta	R0+1
   1265  07c6		       68		      pla
   1266  07c7		       a8		      tay
   1267  07c8		       4c 42 07 	      jmp	pushR0nextIl
   1268  07cb							;
   1269  07cb							;=====================================================
   1270  07cb							; Get from Byte array not Integer array
   1271  07cb				   iArrayB
   1272  07cb		       20 b3 1d 	      jsr	popR0	; Get the array index
   1273  07ce		       20 cb 1d 	      jsr	popR1	; Get the Variable address
   1274  07d1		       4c df 07 	      jmp	iArrayAll	; It will be a byte value
   1275  07d4
   1276  07d4							;=====================================================
   1277  07d4							; Get the array index from top of stack get Current variable
   1278  07d4							; address from next on stack, add the offset
   1279  07d4							; push the result back onto the stack
   1280  07d4				   iArray
   1281  07d4		       20 b3 1d 	      jsr	popR0	; Get the array index
   1282  07d7		       20 cb 1d 	      jsr	popR1	; Get the Variable address
   1283  07da
   1284  07da		       18		      clc		; Multiplythe value by 2
   1285  07db		       26 52		      rol	R0	; Do the multiply
   1286  07dd		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1287  07df				   iArrayAll
   1288  07df		       18		      clc
   1289  07e0		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1290  07e2		       65 52		      adc	R0
   1291  07e4		       85 52		      sta	R0
   1292  07e6		       a5 55		      lda	R1+1
   1293  07e8		       65 53		      adc	R0+1
   1294  07ea		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1295  07ec		       20 21 1d 	      jsr	pushR0	; Push R0 assume it is correct
   1296  07ef
   1297  07ef		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1298  07f1		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1299  07f3		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1300  07f5		       a5 55		      lda	R1+1
   1301  07f7		       c5 42		      cmp	VARIABLES+1
   1302  07f9		       d0 1c		      bne	iArrayAtTest
   1303  07fb		       18		      clc
   1304  07fc		       a9 34		      lda	#52	; add the max offset that is valid
   1305  07fe		       65 54		      adc	R1	; update to be the largest offset that is valid
   1306  0800		       85 54		      sta	R1
   1307  0802		       a9 00		      lda	#0
   1308  0804		       65 55		      adc	R1+1
   1309  0806		       85 55		      sta	R1+1
   1310  0808				   iArrayVerify 		; try to enforce some sanity to using arrays
   1311  0808		       a5 53		      lda	R0+1
   1312  080a		       c5 55		      cmp	R1+1
   1313  080c		       d0 04		      bne	iArrayDecide
   1314  080e		       a5 52		      lda	R0
   1315  0810		       c5 54		      cmp	R1
   1316  0812				   iArrayDecide
   1317  0812		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1318  0814		       4c c2 02 	      jmp	NextIL
   1319  0817
   1320  0817				   iArrayAtTest
   1321  0817		       ad c8 2f 	      lda	HighMem
   1322  081a		       85 54		      sta	R1
   1323  081c		       ad c9 2f 	      lda	HighMem+1
   1324  081f		       85 55		      sta	R1+1
   1325  0821		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1326  0823
   1327  0823							; Get here if array index is out of range
   1328  0823		       20 b3 1d    iArrayError jsr	popR0
   1329  0826		       a9 00		      lda	#0
   1330  0828		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1331  082a		       4c a9 06 	      jmp	iErr2
   1332  082d							;
   1333  082d							;=====================================================
   1334  082d							; List the current BASIC program in memory.  Uses R0,
   1335  082d							; tempIly, and dpl.
   1336  082d							;
   1337  082d		       20 a0 1f    iLST       jsr	SetOutConsole
   1338  0830		       ad c4 2f    iLST2      lda	ProgramStart
   1339  0833		       85 59		      sta	dpl
   1340  0835		       ad c5 2f 	      lda	ProgramStart+1
   1341  0838		       85 5a		      sta	dpl+1
   1342  083a							;
   1343  083a							; dpl/dph point to the current line.  See if we're at
   1344  083a							; the end of the program.
   1345  083a							;
   1346  083a		       a5 59	   iLSTloop   lda	dpl
   1347  083c		       cd c6 2f 	      cmp	ProgramEnd
   1348  083f		       d0 07		      bne	iLstNotEnd
   1349  0841		       a5 5a		      lda	dpl+1
   1350  0843		       cd c7 2f 	      cmp	ProgramEnd+1
   1351  0846		       f0 15		      beq	iLstdone
   1352  0848							;
   1353  0848		       20 d5 14    iLstNotEnd jsr	PrintProgramLine
   1354  084b							;		  ldy	  #1		  ;Change:  Skip first byte length
   1355  084b							;		  lda	  (dpl),y	  ;line number LSB
   1356  084b							;		  sta	  R0
   1357  084b							;		  iny
   1358  084b							;		  lda	  (dpl),y		 ;line number MSB
   1359  084b							;		  sta	  R0+1
   1360  084b							;		  iny
   1361  084b							;		  sty	  tempIlY
   1362  084b							;		  jsr	  PrintDecimal
   1363  084b							;		  lda	  #SPACE
   1364  084b							;		  jsr	  VOUTCH
   1365  084b							;		  ldy	  tempIlY
   1366  084b							;iLSTl2	  lda	  (dpl),y
   1367  084b							;		  beq	  iLST3 	  ;end of this line 0 value
   1368  084b							;		  sty	  tempIlY
   1369  084b							;		  jsr	  VOUTCH
   1370  084b							;		  ldy	  tempIlY
   1371  084b							;		  iny
   1372  084b							;		  bne	  iLSTl2	  ;do next char
   1373  084b							;
   1374  084b							; End of this line.  Print CR/LF, then move to the
   1375  084b							; next line.
   1376  084b							;
   1377  084b		       a0 00	   iLST3      ldy	#0	;Move to next line
   1378  084d		       b1 59		      lda	(dpl),y	;Current line length
   1379  084f		       18		      clc		;Clear the carry flag
   1380  0850							;		  tya
   1381  0850		       65 59		      adc	dpl	;Add the offset to the pointer
   1382  0852		       85 59		      sta	dpl	;Save the new value
   1383  0854		       a5 5a		      lda	dpl+1	;Next byte
   1384  0856		       69 00		      adc	#0	;ad in the carry if any
   1385  0858		       85 5a		      sta	dpl+1	;Save it
   1386  085a							;
   1387  085a							; Have to manually do CR/LF so it uses the vectored
   1388  085a							; output function.
   1389  085a							;
   1390  085a							;		  lda	  #CR
   1391  085a							;		  jsr	  VOUTCH
   1392  085a							;		  lda	  #LF
   1393  085a							;		  jsr	  VOUTCH
   1394  085a		       4c 3a 08 	      jmp	iLSTloop	;do next line
   1395  085d							;
   1396  085d		       20 a0 1f    iLstdone   jsr	SetOutConsole
   1397  0860		       4c c2 02 	      jmp	NextIL
   1398  0863							;
   1399  0863							;=====================================================
   1400  0863							; Get a line of text into LINBUF.  Terminate with a
   1401  0863							; null byte.
   1402  0863							;
   1403  0863				   iGETLINE
   1404  0863		       a9 3e		      lda	#'>	;prompt character
   1405  0865		       a6 00		      ldx	0	;Wait for read to complete
   1406  0867		       20 3e 1c 	      jsr	GetLine
   1407  086a							;
   1408  086a		       a9 00		      lda	#0
   1409  086c		       85 5b		      sta	RunMode
   1410  086e				   iGetParseLine
   1411  086e							; lda	   CUROFF
   1412  086e							; pha
   1413  086e		       20 de 10 	      jsr	ParseInputLine
   1414  0871							; pla
   1415  0871							;  sta     CUROFF
   1416  0871		       a9 db		      lda	#TOKENBUFFER&$FF
   1417  0873		       85 4f		      sta	CURPTR
   1418  0875		       a9 0f		      lda	#TOKENBUFFER>>8
   1419  0877		       85 50		      sta	CURPTR+1
   1420  0879		       a9 01		      lda	#1
   1421  087b		       85 51		      sta	CUROFF
   1422  087d		       4c c2 02 	      jmp	NextIL
   1423  0880							;
   1424  0880							;=====================================================
   1425  0880							; This is called when the input buffer contains a line
   1426  0880							; typed in by the user that starts with a line number.
   1427  0880							; Insert the line into the program or delete the line
   1428  0880							; if there is nothing after the line number,
   1429  0880							;
   1430  0880				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1431  0880		       ad dc 0f 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1432  0883		       85 52		      sta	R0	; place the number into R0
   1433  0885		       ad dd 0f 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1434  0888		       85 53		      STA	R0+1	; Place it into
   1435  088a							;
   1436  088a							; Now find the line OR the next higher line OR the
   1437  088a							; end of the program.
   1438  088a							;
   1439  088a		       20 6d 1b 	      jsr	findLine	; Look for the line number in the current program
   1440  088d							; Returns Z and curptr point to the line if found
   1441  088d							; Returns C and curptr at next higher line if not found and there is a higher line
   1442  088d							; Returns ZC clear and curptr to end of program if higher than all other lines
   1443  088d							;
   1444  088d							; If the line exists, it needs to be removed.
   1445  088d							;
   1446  088d		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1447  088f							;
   1448  088f							; Get length of line to be removed, we fall thru to here if we find a matching line
   1449  088f							;
   1450  088f							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1451  088f		       a0 00		      ldy	#0
   1452  0891		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1453  0893		       a8		      tay
   1454  0894							;If it is equal we delete the line and replace it, get length
   1455  0894							;then adjust all program line after up or down depending on len of line
   1456  0894							;If next higher then just move everythimg down by length bytes
   1457  0894							;This call will return how many bytes in the line we found
   1458  0894		       8c c1 2f 	      sty	lineLength	;Save the length of the line we found
   1459  0897							;
   1460  0897							; Compute the new end of the program first.
   1461  0897							;
   1462  0897		       38		      sec		;Set the carry bit
   1463  0898		       ad c6 2f 	      lda	ProgramEnd	;Get low byte of program end
   1464  089b		       ed c1 2f 	      sbc	lineLength	;Subtract the length of the current line
   1465  089e		       8d c6 2f 	      sta	ProgramEnd	;save it
   1466  08a1		       ad c7 2f 	      lda	ProgramEnd+1
   1467  08a4		       e9 00		      sbc	#0	;Process the carry
   1468  08a6		       8d c7 2f 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1469  08a9							;
   1470  08a9							; Copy CURPTR into R1 for working
   1471  08a9							;
   1472  08a9		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1473  08ab		       85 54		      sta	R1
   1474  08ad		       a5 50		      lda	CURPTR+1
   1475  08af		       85 55		      sta	R1+1
   1476  08b1							;
   1477  08b1							; See if we're at the end.
   1478  08b1							;
   1479  08b1		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1480  08b3		       cd c6 2f 	      cmp	ProgramEnd
   1481  08b6		       d0 07		      bne	InsDelLoop
   1482  08b8		       a5 55		      lda	R1+1
   1483  08ba		       cd c7 2f 	      cmp	ProgramEnd+1
   1484  08bd		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1485  08bf							;
   1486  08bf							; Move one byte, move to next location.
   1487  08bf							;
   1488  08bf		       ac c1 2f    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1489  08c2		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1490  08c4		       b1 54		      lda	(R1),y
   1491  08c6		       a0 00		      ldy	#0
   1492  08c8		       91 54		      sta	(R1),y
   1493  08ca		       e6 54		      inc	R1
   1494  08cc		       d0 e3		      bne	InsDelChk
   1495  08ce		       e6 55		      inc	R1+1
   1496  08d0		       4c b1 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1497  08d3							;
   1498  08d3							; Deletion is done.
   1499  08d3							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1500  08d3							;
   1501  08d3				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1502  08d3		       ad db 0f 	      lda	TOKENBUFFER	; Get the length
   1503  08d6		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1504  08d8							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1505  08d8		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1506  08da							;
   1507  08da							; CURPTR points to where the line will be inserted.
   1508  08da							;
   1509  08da							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1510  08da		       ae db 0f 	      ldx	TOKENBUFFER
   1511  08dd		       8e c1 2f 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1512  08e0							;
   1513  08e0		       ad c6 2f 	      lda	ProgramEnd	;Load the start address for the copy
   1514  08e3							;At this point curptr still contains the location we will insert data
   1515  08e3		       85 5c		      sta	FROM
   1516  08e5		       ad c7 2f 	      lda	ProgramEnd+1
   1517  08e8		       85 5d		      sta	FROM+1
   1518  08ea							;
   1519  08ea		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1520  08ec		       b1 5c		      lda	(FROM),y
   1521  08ee		       ac c1 2f 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1522  08f1		       91 5c		      sta	(FROM),y	;Save the new byte
   1523  08f3							;
   1524  08f3		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1525  08f5		       c5 4f		      cmp	CURPTR
   1526  08f7		       d0 06		      bne	mvUpMore
   1527  08f9		       a5 5d		      lda	FROM+1
   1528  08fb		       c5 50		      cmp	CURPTR+1
   1529  08fd		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1530  08ff							;
   1531  08ff							; Not done yet
   1532  08ff							;
   1533  08ff		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1534  0901		       d0 02		      bne	mvUpMore2
   1535  0903		       c6 5d		      dec	FROM+1
   1536  0905		       c6 5c	   mvUpMore2  dec	FROM
   1537  0907		       4c ea 08 	      jmp	mvup1	;Loop until everything is moved
   1538  090a							;
   1539  090a							; All done with copy.
   1540  090a							;
   1541  090a				   mvUpDone
   1542  090a		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1543  090b		       ad c1 2f 	      lda	lineLength	;Number of bytes to copy from line buff
   1544  090e		       6d c6 2f 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1545  0911		       8d c6 2f 	      sta	ProgramEnd
   1546  0914		       ad c7 2f 	      lda	ProgramEnd+1
   1547  0917		       69 00		      adc	#0
   1548  0919		       8d c7 2f 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1549  091c							;
   1550  091c							;===================jlit use length before line newline
   1551  091c
   1552  091c		       a0 00		      ldy	#0	;Set offset of copy
   1553  091e							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1554  091e							;		  sta	  (CURPTR),y	  ;Store the length
   1555  091e							;		  iny
   1556  091e							;		  lda	  R0		  ;Store the line number next
   1557  091e							;		  sta	  (CURPTR),y
   1558  091e							;		  iny
   1559  091e							;		  lda	  R0+1
   1560  091e							;		  sta	  (CURPTR),y
   1561  091e							;		  iny
   1562  091e							;
   1563  091e							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1564  091e		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1565  0920				   mvUpLoop2
   1566  0920							;		  lda	  LINBUF,x	 ;get a byte
   1567  0920		       bd db 0f 	      lda	TOKENBUFFER,x	;get a byte
   1568  0923		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1569  0925
   1570  0925		       e8		      inx
   1571  0926		       ec db 0f 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1572  0929		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1573  092b		       c8		      iny
   1574  092c		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1575  092e							;
   1576  092e		       4c c2 02    mvUpFini   jmp	NextIL
   1577  0931							;
   1578  0931							;=====================================================
   1579  0931							; Pops the top value of the ILPC stack and stores it
   1580  0931							; in ILPC.  Ie, return from an IL subroutine.
   1581  0931							;
   1582  0931		       20 5b 1b    iRTN       jsr	popILPC
   1583  0934		       4c c2 02 	      jmp	NextIL
   1584  0937							;
   1585  0937							;=====================================================
   1586  0937							; NLINE print a newline
   1587  0937							;
   1588  0937		       20 6c 1e    iNLINE     jsr	CRLF	;user supplied sub
   1589  093a		       4c c2 02 	      jmp	NextIL
   1590  093d							;
   1591  093d							;=====================================================
   1592  093d							; This saves the current ILPC value on the stack, then
   1593  093d							; jumps to the address specified by the next two bytes.
   1594  093d							;
   1595  093d		       20 3e 1b    iCALL      jsr	pushILPC	;save ILPC
   1596  0940		       90 03		      bcc	iJMP
   1597  0942		       4c f7 0b 	      jmp	ErrStkOver	; Check if there was an error
   1598  0945							;
   1599  0945							; Jmp to a specific location in the IL code.  The new
   1600  0945							; address immediately follows the opcode.
   1601  0945							;
   1602  0945		       20 24 1b    iJMP       jsr	getILWord
   1603  0948		       86 43		      stx	ILPC
   1604  094a		       85 44		      sta	ILPC+1
   1605  094c		       4c c2 02 	      jmp	NextIL
   1606  094f
   1607  094f
   1608  094f							;
   1609  094f							;=====================================================
   1610  094f							; Push the next two bytes onto the arithmetic stack.
   1611  094f							;
   1612  094f		       20 28 1b    iSetR2     jsr	getILByte
   1613  0952		       85 58		      sta	R2
   1614  0954		       4c c2 02 	      jmp	NextIL
   1615  0957							;
   1616  0957							;=====================================================
   1617  0957							; Push the next two bytes onto the arithmetic stack.
   1618  0957							;
   1619  0957		       20 24 1b    iLIT       jsr	getILWord
   1620  095a		       86 52		      stx	R0
   1621  095c		       85 53		      sta	R0+1
   1622  095e		       20 21 1d 	      jsr	pushR0
   1623  0961		       4c c2 02 	      jmp	NextIL
   1624  0964							;
   1625  0964							;=====================================================
   1626  0964							; Initialize all variables for a single task.	Ie, set to zero.
   1627  0964							;
   1628  0964		       98	   subVINIT   tya
   1629  0965		       48		      pha
   1630  0966
   1631  0966		       a9 00		      lda	#0
   1632  0968		       a0 00		      ldy	#0
   1633  096a		       91 41	   Vinit2     sta	(VARIABLES),y
   1634  096c		       c8		      iny
   1635  096d		       c0 34		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1636  096f		       90 f9		      bcc	Vinit2
   1637  0971
   1638  0971		       68		      pla
   1639  0972		       a8		      tay
   1640  0973		       60		      rts
   1641  0974
   1642  0974		       20 9d 0d    iVINIT     jsr	Compile	; compile line numbers to memory pointers
   1643  0977		       20 64 09 	      jsr	subVINIT
   1644  097a		       4c c2 02 	      jmp	NextIL
   1645  097d							;
   1646  097d							;=====================================================
   1647  097d							; Set the address of the error handler.  After any
   1648  097d							; error, set to the ILPC to the specified location.
   1649  097d							;
   1650  097d		       20 24 1b    iERRGOTO   jsr	getILWord
   1651  0980		       8e b1 2f 	      stx	errGoto
   1652  0983		       8d b2 2f 	      sta	errGoto+1
   1653  0986		       4c c2 02 	      jmp	NextIL
   1654  0989							;
   1655  0989							;=====================================================
   1656  0989							; TST is followed by an 8 bit signed offset, then a
   1657  0989							; null terminated string.  Compare the string against
   1658  0989							; the string starting at (CURPTR),CUROFF.  If the
   1659  0989							; strings match, continue executing the next IL
   1660  0989							; opcode.  Else, add the offset to ILPC.
   1661  0989							;
   1662  0989		       20 28 1b    iTST       jsr	getILByte	;Get the relative jump address
   1663  098c		       8d c0 2f 	      sta	offset	;save it to use if test faile
   1664  098f		       20 0b 1d 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1665  0992
   1666  0992		       a4 51		      ldy	CUROFF
   1667  0994		       84 59		      sty	dpl	;save for later
   1668  0996							;
   1669  0996		       20 28 1b    iTSTloop   jsr	getILByte	;get next char
   1670  0999		       f0 11		      beq	iTSTm	;match!
   1671  099b		       a4 59		      ldy	dpl
   1672  099d		       d1 4f		      cmp	(CURPTR),y
   1673  099f		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1674  09a1		       09 20		      ora	#$20	; lets allow lowercase as well
   1675  09a3		       d1 4f		      cmp	(CURPTR),y
   1676  09a5		       d0 23		      bne	iTSTfail	;mismatch
   1677  09a7		       c8	   iTSTUpper  iny
   1678  09a8		       84 59		      sty	dpl
   1679  09aa		       d0 ea		      bne	iTSTloop
   1680  09ac							;
   1681  09ac							; It's a match!  Clean up a bit.
   1682  09ac							;
   1683  09ac		       a4 59	   iTSTm      ldy	dpl
   1684  09ae		       84 51		      sty	CUROFF
   1685  09b0		       4c c2 02 	      jmp	NextIL
   1686  09b3
   1687  09b3							; Test for a single quote string
   1688  09b3		       20 28 1b    iTSTStr    jsr	getILByte
   1689  09b6		       8d c0 2f 	      sta	offset
   1690  09b9		       20 0b 1d 	      jsr	saveIL
   1691  09bc		       a4 51		      ldy	CUROFF
   1692  09be		       a9 22		      lda	#'"
   1693  09c0		       d1 4f		      cmp	(CURPTR),y
   1694  09c2		       d0 06		      bne	iTSTfail
   1695  09c4		       c8		      iny
   1696  09c5		       84 51		      sty	CUROFF
   1697  09c7		       4c e5 02 	      jmp	NextILStr
   1698  09ca							;
   1699  09ca							; Not a match, reset ILPC and then move to the
   1700  09ca							; offset.
   1701  09ca							;
   1702  09ca		       20 16 1d    iTSTfail   jsr	restoreIL
   1703  09cd		       4c a5 0b 	      jmp	tstBranch
   1704  09d0							;
   1705  09d0							;=================================================JLIT=
   1706  09d0							; Test if we have a let statement without the let keyword
   1707  09d0		       20 28 1b    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1708  09d3		       8d c0 2f 	      sta	offset	; Save the jump offset for fails
   1709  09d6		       20 0b 1d 	      jsr	saveIL	; save to restore when done if fail
   1710  09d9
   1711  09d9		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1712  09db		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1713  09dd		       c9 01		      cmp	#kLet	; Is it a let keyword
   1714  09df		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1715  09e1		       c9 80		      cmp	#tVa	; lets check for a variable
   1716  09e3		       90 e5		      bcc	iTSTfail	; Less than variable range
   1717  09e5		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1718  09e7		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1719  09e9		       b0 df		      bcs	iTSTfail	; return it failed
   1720  09eb
   1721  09eb				   iTSTLETGOOD
   1722  09eb		       c8		      iny
   1723  09ec		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1724  09ee				   iTSTGOODVAR
   1725  09ee		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1726  09f1
   1727  09f1							;=================================================JLIT=
   1728  09f1							; Test a byte at an indirect address
   1729  09f1							; fails if byte is not equal to the value at the address
   1730  09f1							; The tests an indirect byte and branches if true
   1731  09f1		       20 28 1b    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1732  09f4		       8d c0 2f 	      sta	offset	; Save the jump offset for fails
   1733  09f7		       20 0b 1d 	      jsr	saveIL	; save to restore when done if fail
   1734  09fa		       20 24 1b 	      jsr	getILWord	; Get a word into RO
   1735  09fd		       86 52		      stx	R0
   1736  09ff		       85 53		      sta	R0+1
   1737  0a01		       20 28 1b 	      jsr	getILByte	; Get byte into A
   1738  0a04		       a0 00		      ldy	#0
   1739  0a06		       d1 52		      cmp	(R0),y
   1740  0a08		       d0 03		      bne	iTSTByteNotEqual
   1741  0a0a		       4c ca 09 	      jmp	iTSTfail
   1742  0a0d
   1743  0a0d				   iTSTByteNotEqual
   1744  0a0d		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1745  0a10
   1746  0a10							;=================================================JLIT=
   1747  0a10							; Test a byte	branch if it fails
   1748  0a10		       20 28 1b    iTSTB      jsr	getILByte	; Get the relative offset byte
   1749  0a13		       8d c0 2f 	      sta	offset	; Save the jump offset for fails
   1750  0a16		       20 0b 1d 	      jsr	saveIL	; save to restore when done if fail
   1751  0a19		       20 28 1b 	      jsr	getILByte	; Get a word into RO
   1752  0a1c		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1753  0a1e		       d1 4f		      cmp	(CURPTR),y
   1754  0a20		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1755  0a22		       4c ca 09 	      jmp	iTSTfail	; REcover and move on to next test
   1756  0a25
   1757  0a25				   iTSTBMatch
   1758  0a25		       c8		      iny
   1759  0a26		       84 51		      sty	CUROFF	; Point to the next byte
   1760  0a28		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1761  0a2b
   1762  0a2b							;=================================================JLIT=
   1763  0a2b							; Test a byte	branch if it fails
   1764  0a2b		       20 28 1b    iTSTW      jsr	getILByte	; Get the relative offset byte
   1765  0a2e		       8d c0 2f 	      sta	offset	; Save the jump offset for fails
   1766  0a31		       20 0b 1d 	      jsr	saveIL	; save to restore when done if fail
   1767  0a34		       20 24 1b 	      jsr	getILWord	; Get a word into RO
   1768  0a37		       86 52		      stx	R0
   1769  0a39		       85 53		      sta	R0+1
   1770  0a3b		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1771  0a3d		       8a		      txa
   1772  0a3e		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1773  0a40		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1774  0a42		       4c ca 09 	      jmp	iTSTfail	; REcover and move on to next test
   1775  0a45		       c8	   iTSTWM1    iny
   1776  0a46		       a5 53		      lda	R0+1
   1777  0a48		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1778  0a4a		       f0 03		      beq	iTSTWMatch
   1779  0a4c		       4c ca 09 	      jmp	iTSTfail
   1780  0a4f
   1781  0a4f				   iTSTWMatch
   1782  0a4f		       c8		      iny
   1783  0a50		       84 51		      sty	CUROFF
   1784  0a52		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1785  0a55
   1786  0a55							;================================================jLIT=
   1787  0a55							;Test for end of line
   1788  0a55							;
   1789  0a55				   iTSTDONE
   1790  0a55		       20 28 1b 	      jsr	getILByte
   1791  0a58		       8d c0 2f 	      sta	offset
   1792  0a5b		       20 0b 1d 	      jsr	saveIL
   1793  0a5e		       a4 51		      ldy	CUROFF
   1794  0a60		       84 59		      sty	dpl
   1795  0a62		       b1 4f		      lda	(CURPTR),y
   1796  0a64		       f0 0b		      beq	iTSTDONEtrue
   1797  0a66		       c9 e6		      cmp	#oColon
   1798  0a68		       f0 07		      beq	iTSTDONEtrue
   1799  0a6a		       a4 59		      ldy	dpl
   1800  0a6c		       84 51		      sty	CUROFF
   1801  0a6e		       4c ca 09 	      jmp	iTSTfail
   1802  0a71							;
   1803  0a71							; Advance to the next line
   1804  0a71							;
   1805  0a71				   iTSTDONEtrue
   1806  0a71		       4c c2 02 	      jmp	NextIL
   1807  0a74
   1808  0a74		       4c a5 0b    tstBranchLink jmp	tstBranch
   1809  0a77							;
   1810  0a77							;=====================================================
   1811  0a77							; Inc and dec a variable , faster than a = a + 1
   1812  0a77				   iINCVAR
   1813  0a77		       20 b3 1d 	      jsr	popR0
   1814  0a7a		       a0 00		      ldy	#0
   1815  0a7c		       18		      clc
   1816  0a7d		       a9 01		      lda	#1
   1817  0a7f		       71 52		      adc	(R0),y
   1818  0a81		       91 52		      sta	(R0),y
   1819  0a83		       90 07		      bcc	iINCDONE
   1820  0a85		       c8		      iny
   1821  0a86		       a9 00		      lda	#0
   1822  0a88		       71 52		      adc	(R0),y
   1823  0a8a		       91 52		      sta	(R0),y
   1824  0a8c				   iINCDONE
   1825  0a8c		       4c c2 02 	      jmp	NextIL
   1826  0a8f
   1827  0a8f				   iDECVAR
   1828  0a8f		       20 b3 1d 	      jsr	popR0
   1829  0a92		       a0 00		      ldy	#0
   1830  0a94		       38		      sec
   1831  0a95		       b1 52		      lda	(R0),y
   1832  0a97		       e9 01		      sbc	#1
   1833  0a99		       91 52		      sta	(R0),y
   1834  0a9b		       c8		      iny
   1835  0a9c		       b1 52		      lda	(R0),y
   1836  0a9e		       e9 00		      sbc	#0
   1837  0aa0		       91 52		      sta	(R0),y
   1838  0aa2		       4c c2 02 	      jmp	NextIL
   1839  0aa5
   1840  0aa5
   1841  0aa5							;
   1842  0aa5							;=====================================================
   1843  0aa5							; TSTV is followed by an 8 bit signed offset.	If the
   1844  0aa5							; value at (CURPTR),CUROFF appears to be a variable
   1845  0aa5							; name, move to the next IL statement.  Else, add the
   1846  0aa5							; offset to ILPC. Converted to use actual absolute memory addresses
   1847  0aa5							; TSTVT Looks for the task context
   1848  0aa5							;
   1849  0aa5		       20 cb 1d    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1850  0aa8		       a9 00		      lda	#0
   1851  0aaa		       85 58		      sta	R2
   1852  0aac		       f0 04		      beq	iTSTVV
   1853  0aae
   1854  0aae		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1855  0ab0		       85 58		      sta	R2
   1856  0ab2
   1857  0ab2		       20 28 1b    iTSTVV     jsr	getILByte	;offset
   1858  0ab5		       8d c0 2f 	      sta	offset
   1859  0ab8							;
   1860  0ab8		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1861  0aba		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1862  0abc		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1863  0abe		       4c 74 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1864  0ac1							;
   1865  0ac1				   iTSTVnext
   1866  0ac1		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1867  0ac3		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1868  0ac5
   1869  0ac5		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1870  0ac7		       f0 5b		      beq	iTSTVParm
   1871  0ac9
   1872  0ac9		       c9 9b		      cmp	#tVhat	; task exit code
   1873  0acb		       d0 04		      bne	iTSTV_A2Z
   1874  0acd		       a9 34		      lda	#TASKEXITCODE
   1875  0acf		       d0 0b		      bne	iTSTVContinue
   1876  0ad1
   1877  0ad1				   iTSTV_A2Z
   1878  0ad1
   1879  0ad1		       c9 80		      cmp	#tVa
   1880  0ad3		       90 9f		      bcc	tstBranchLink
   1881  0ad5		       c9 9a		      cmp	#tVz+1
   1882  0ad7		       b0 9b		      bcs	tstBranchLink
   1883  0ad9
   1884  0ad9
   1885  0ad9							;
   1886  0ad9							; The condition is true, so convert to an index, push
   1887  0ad9							; it onto the stack and continue running.
   1888  0ad9							;
   1889  0ad9		       29 7f		      and	#%01111111	; Mask off the high bit
   1890  0adb		       0a		      asl		; multiply by two
   1891  0adc
   1892  0adc				   iTSTVContinue
   1893  0adc		       c8		      iny
   1894  0add		       84 51		      sty	CUROFF	; it is a valid variable
   1895  0adf		       48		      pha		; save the last variable pointer value
   1896  0ae0		       a5 58		      lda	R2
   1897  0ae2		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1898  0ae4
   1899  0ae4		       20 fd 1a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1900  0ae7		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1901  0ae9
   1902  0ae9		       68		      pla		; We have an invalid pid for getting variable value
   1903  0aea		       a2 10		      ldx	#ERR_INVALID_PID
   1904  0aec		       a9 00		      lda	#0
   1905  0aee		       4c a9 06 	      jmp	iErr2
   1906  0af1
   1907  0af1				   iTSTVGOODPID
   1908  0af1		       20 e5 1a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1909  0af4		       a0 01		      ldy	#VARIABLEPOS
   1910  0af6		       b1 56		      lda	(MQ),y
   1911  0af8		       85 52		      sta	R0
   1912  0afa		       c8		      iny
   1913  0afb		       b1 56		      lda	(MQ),y
   1914  0afd		       85 53		      sta	R0+1
   1915  0aff		       4c 0a 0b 	      jmp	iTSTVAddOffset
   1916  0b02
   1917  0b02				   iTSTVLocalValue
   1918  0b02		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1919  0b04		       85 52		      sta	R0
   1920  0b06		       a5 42		      lda	VARIABLES+1
   1921  0b08		       85 53		      sta	R0+1
   1922  0b0a
   1923  0b0a				   iTSTVAddOffset
   1924  0b0a		       68		      pla
   1925  0b0b		       85 54		      sta	R1
   1926  0b0d		       a9 00		      lda	#0
   1927  0b0f		       85 55		      sta	R1+1
   1928  0b11
   1929  0b11				   iTSTVcontinue
   1930  0b11
   1931  0b11		       4c ca 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1932  0b14
   1933  0b14							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1934  0b14							; an array of integer values
   1935  0b14				   iTSTVat
   1936  0b14		       c8		      iny
   1937  0b15		       84 51		      sty	CUROFF	;it is a valid variable
   1938  0b17		       ad c6 2f 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1939  0b1a		       85 52		      sta	R0
   1940  0b1c		       ad c7 2f 	      lda	ProgramEnd+1
   1941  0b1f		       85 53		      sta	R0+1
   1942  0b21		       4c 42 07 	      jmp	pushR0nextIl	;place this onto the stack
   1943  0b24
   1944  0b24							; When we get parameters passed we can access them using the # variable with[]
   1945  0b24							; example #[0] #[1] etc, we dont check yet if there is too many
   1946  0b24				   iTSTVParm
   1947  0b24		       c8		      iny
   1948  0b25		       84 51		      sty	CUROFF	;it is a valid variable
   1949  0b27		       a5 48		      lda	MATHSTACK
   1950  0b29		       85 52		      sta	R0
   1951  0b2b		       a5 49		      lda	MATHSTACK+1
   1952  0b2d		       85 53		      sta	R0+1
   1953  0b2f		       4c 42 07 	      jmp	pushR0nextIl
   1954  0b32
   1955  0b32							;
   1956  0b32							;=====================================================
   1957  0b32							; TSTL seems basically the same as TSTN, but leave the
   1958  0b32							; value in R0 instead of pushing onto stack.
   1959  0b32							; This tests for a valid line number
   1960  0b32							;
   1961  0b32		       20 28 1b    iTSTL      jsr	getILByte
   1962  0b35		       8d c0 2f 	      sta	offset
   1963  0b38							;
   1964  0b38		       a4 51		      ldy	CUROFF
   1965  0b3a		       b1 4f		      lda	(CURPTR),y
   1966  0b3c		       c8		      iny
   1967  0b3d		       11 4f		      ora	(CURPTR),y
   1968  0b3f		       f0 06		      beq	iTSTLNotLineNo
   1969  0b41
   1970  0b41
   1971  0b41							; In Both cases we need to point to the first usefull byte to process.
   1972  0b41		       c8		      iny
   1973  0b42		       84 51		      sty	CUROFF
   1974  0b44		       4c c2 02 	      jmp	NextIL
   1975  0b47				   iTSTLNotLineNo
   1976  0b47		       c8		      iny
   1977  0b48		       84 51		      sty	CUROFF
   1978  0b4a		       4c a5 0b 	      jmp	tstBranch
   1979  0b4d
   1980  0b4d							;
   1981  0b4d							;=====================================================
   1982  0b4d							; TSTN checks for a number.  This is very simplistic;
   1983  0b4d							; if the character is a digit, assume it's a number.
   1984  0b4d							; Convert to a number and push it onto the stack.
   1985  0b4d							;
   1986  0b4d		       20 28 1b    iTSTN      jsr	getILByte
   1987  0b50		       8d c0 2f 	      sta	offset
   1988  0b53							;
   1989  0b53		       a9 00		      lda	#0
   1990  0b55		       85 59		      sta	dpl
   1991  0b57		       a4 51		      ldy	CUROFF
   1992  0b59				   chkType
   1993  0b59		       b1 4f		      lda	(CURPTR),y
   1994  0b5b		       c9 a2		      cmp	#tByte
   1995  0b5d		       f0 0e		      beq	chkByte
   1996  0b5f		       c9 a1		      cmp	#tInteger
   1997  0b61		       f0 16		      beq	chkInteger
   1998  0b63		       c9 eb		      cmp	#oMinus
   1999  0b65		       d0 3e		      bne	tstBranch
   2000  0b67		       e6 59		      inc	dpl
   2001  0b69		       c8		      iny
   2002  0b6a		       4c 59 0b 	      jmp	chkType
   2003  0b6d
   2004  0b6d				   chkByte
   2005  0b6d		       a9 00		      lda	#0
   2006  0b6f		       85 53		      sta	R0+1
   2007  0b71		       c8		      iny
   2008  0b72		       b1 4f		      lda	(CURPTR),y
   2009  0b74		       85 52		      sta	R0
   2010  0b76		       c8		      iny
   2011  0b77		       d0 0b		      bne	iTSTN_1
   2012  0b79
   2013  0b79				   chkInteger
   2014  0b79		       c8		      iny
   2015  0b7a		       b1 4f		      lda	(CURPTR),y
   2016  0b7c		       85 52		      sta	R0
   2017  0b7e		       c8		      iny
   2018  0b7f		       b1 4f		      lda	(CURPTR),y
   2019  0b81		       85 53		      sta	R0+1
   2020  0b83		       c8		      iny
   2021  0b84							;
   2022  0b84							; Check if it is negative and make it so
   2023  0b84							;
   2024  0b84				   iTSTN_1
   2025  0b84		       84 51		      sty	CUROFF
   2026  0b86
   2027  0b86		       a5 59		      lda	dpl
   2028  0b88		       f0 18		      beq	iTSTN_2	;positive
   2029  0b8a							;
   2030  0b8a		       a5 52		      lda	R0
   2031  0b8c		       05 53		      ora	R0+1
   2032  0b8e		       f0 12		      beq	iTSTN_2	;zero
   2033  0b90
   2034  0b90							; Invert all the bits, then add one.
   2035  0b90							;
   2036  0b90		       a5 52		      lda	R0
   2037  0b92		       49 ff		      eor	#$ff
   2038  0b94		       85 52		      sta	R0
   2039  0b96		       a5 53		      lda	R0+1
   2040  0b98		       49 ff		      eor	#$ff
   2041  0b9a		       85 53		      sta	R0+1
   2042  0b9c							;
   2043  0b9c		       e6 52		      inc	R0
   2044  0b9e		       d0 02		      bne	iTSTN_2
   2045  0ba0		       e6 53		      inc	R0+1
   2046  0ba2				   iTSTN_2
   2047  0ba2		       4c 42 07 	      jmp	pushR0nextIl	;save onto stack
   2048  0ba5
   2049  0ba5							;
   2050  0ba5							; Common jump point for all TSTx instructions that
   2051  0ba5							; fail to meet the requirements.  This takes the
   2052  0ba5							; offset and adds/subtracts to/from ILPC.
   2053  0ba5							;
   2054  0ba5		       ad c0 2f    tstBranch  lda	offset	;get signed offset
   2055  0ba8		       10 0e		      bpl	tstPositive
   2056  0baa							;
   2057  0baa							; Do negative branch.	Do sign extension.
   2058  0baa							;
   2059  0baa		       18	   tstNegative clc
   2060  0bab		       65 43		      adc	ILPC
   2061  0bad		       85 43		      sta	ILPC
   2062  0baf							;		  bcc	  tstBothDone
   2063  0baf							;		  dec	  ILPC+1
   2064  0baf							;		  jmp	  NextIL
   2065  0baf
   2066  0baf		       a5 44		      lda	ILPC+1
   2067  0bb1		       69 ff		      adc	#$ff
   2068  0bb3		       85 44		      sta	ILPC+1
   2069  0bb5		       4c c2 02 	      jmp	NextIL	;keep going
   2070  0bb8							;
   2071  0bb8		       18	   tstPositive clc
   2072  0bb9		       65 43		      adc	ILPC
   2073  0bbb		       85 43		      sta	ILPC
   2074  0bbd		       90 02		      bcc	tstBothDone
   2075  0bbf		       e6 44		      inc	ILPC+1
   2076  0bc1				   tstBothDone
   2077  0bc1		       4c c2 02 	      jmp	NextIL
   2078  0bc4
   2079  0bc4							;
   2080  0bc4							;====================================================
   2081  0bc4							; Test for IRQ pending, and test if a break key pressed
   2082  0bc4							; Yes I know but this handles all sorts of irq/break issues
   2083  0bc4							;
   2084  0bc4		       20 28 1b    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2085  0bc7		       8d c0 2f 	      sta	offset	; Store the not true jump address offset
   2086  0bca		       20 4d 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2087  0bcd		       d0 03		      bne	irqNo	; z not set of no break found
   2088  0bcf		       4c 36 06 	      jmp	iFIN	; Exit out of run mode
   2089  0bd2		       ad 68 26    irqNo      lda	IRQPending
   2090  0bd5		       f0 ce		      beq	tstBranch
   2091  0bd7		       c9 01		      cmp	#1	; only do this if set to first time
   2092  0bd9		       d0 ca		      bne	tstBranch
   2093  0bdb		       78		      sei		; disable the interupt until ireturn resets it
   2094  0bdc		       ee 68 26    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2095  0bdf		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2096  0be1		       20 3b 1d 	      jsr	pushLN	; Push the next line to be executed
   2097  0be4		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2098  0be6		       ad 69 26 	      lda	IRQEntry	; Get the line number to branch to
   2099  0be9		       85 4f		      sta	CURPTR	; put line number into r0
   2100  0beb		       ad 6a 26 	      lda	IRQEntry+1
   2101  0bee		       85 50		      sta	CURPTR+1
   2102  0bf0		       a9 03		      lda	#3	; Point to first byte of program text
   2103  0bf2		       85 51		      sta	CUROFF
   2104  0bf4		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2105  0bf7
   2106  0bf7		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2107  0bf9		       a9 00		      lda	#0	; stop the execution
   2108  0bfb		       4c a9 06 	      jmp	iErr2
   2109  0bfe							;
   2110  0bfe
   2111  0bfe							;=====================================================
   2112  0bfe							; This places the number of free bytes on top of the
   2113  0bfe							; stack.
   2114  0bfe							;
   2115  0bfe		       20 56 16    iFREE      jsr	MemFree
   2116  0c01		       20 21 1d 	      jsr	pushR0
   2117  0c04		       4c c2 02 	      jmp	NextIL
   2118  0c07							;
   2119  0c07							;=====================================================
   2120  0c07							; Generate a random number from 0-FFFF and then MOD
   2121  0c07							; it with the value on top of stack.  Leaves number on
   2122  0c07							; stack
   2123  0c07							;
   2124  0c07		       20 cb 1d    iRANDOM    jsr	popR1	;mod value
   2125  0c0a							;
   2126  0c0a							; If the value is zero, just return a one.
   2127  0c0a							;
   2128  0c0a		       a5 54		      lda	R1
   2129  0c0c		       05 55		      ora	R1+1
   2130  0c0e		       f0 4a		      beq	irandom1
   2131  0c10							;
   2132  0c10		       ad b7 2f 	      lda	random+1
   2133  0c13		       8d b4 2f 	      sta	rtemp1
   2134  0c16		       ad b6 2f 	      lda	random
   2135  0c19		       0a		      asl
   2136  0c1a		       2e b4 2f 	      rol	rtemp1
   2137  0c1d		       0a		      asl
   2138  0c1e		       2e b4 2f 	      rol	rtemp1
   2139  0c21		       18		      clc
   2140  0c22		       6d b6 2f 	      adc	random
   2141  0c25
   2142  0c25		       48		      pha
   2143  0c26
   2144  0c26		       ad b4 2f 	      lda	rtemp1
   2145  0c29		       6d b7 2f 	      adc	random+1
   2146  0c2c		       8d b7 2f 	      sta	random+1
   2147  0c2f
   2148  0c2f		       68		      pla
   2149  0c30
   2150  0c30		       69 11		      adc	#$11
   2151  0c32		       8d b6 2f 	      sta	random
   2152  0c35		       ad b7 2f 	      lda	random+1
   2153  0c38		       69 36		      adc	#$36
   2154  0c3a		       8d b7 2f 	      sta	random+1
   2155  0c3d
   2156  0c3d		       ad b6 2f 	      lda	random
   2157  0c40		       85 52		      sta	R0
   2158  0c42		       ad b7 2f 	      lda	random+1
   2159  0c45		       29 7f		      and	#$7f	;make positive
   2160  0c47		       85 53		      sta	R0+1
   2161  0c49							;
   2162  0c49							; R0 contains the number and R1 contains the max value.
   2163  0c49							;
   2164  0c49		       20 68 07 	      jsr	iDivNoPop
   2165  0c4c		       20 34 1e 	      jsr	RestoreSigns
   2166  0c4f		       a5 56		      lda	MQ
   2167  0c51		       85 52		      sta	R0
   2168  0c53		       a5 57		      lda	MQ+1
   2169  0c55		       85 53		      sta	R0+1
   2170  0c57		       4c 42 07 	      jmp	pushR0nextIl
   2171  0c5a				   irandom1
   2172  0c5a		       a9 00		      lda	#0
   2173  0c5c		       85 53		      sta	R0+1
   2174  0c5e		       a9 01		      lda	#1
   2175  0c60		       85 52		      sta	R0
   2176  0c62		       4c 42 07 	      jmp	pushR0nextIl
   2177  0c65
   2178  0c65							; The following replaced by call to division/modulo
   2179  0c65							;iRANDOM_2	lda	R0
   2180  0c65							;		cmp	R1
   2181  0c65							;		bne	iRANDOM_1
   2182  0c65							;		lda	R0+1
   2183  0c65							;		cmp	R1+1
   2184  0c65							;		bne	iRANDOM_1	;need to subtract
   2185  0c65							;
   2186  0c65							; Subtract R1 from R0
   2187  0c65							;
   2188  0c65							;iRANDOM_sub	sec
   2189  0c65							;		lda	R0
   2190  0c65							;		sbc	R1
   2191  0c65							;		sta	R0
   2192  0c65							;		lda	R0+1
   2193  0c65							;		sbc	R1+1
   2194  0c65							;		sta	R0+1
   2195  0c65							;		jmp	iRANDOM_2
   2196  0c65							;
   2197  0c65							; See if R1 > R0.  If so, branch to subtract.
   2198  0c65							;
   2199  0c65							;iRANDOM_1	lda	R0
   2200  0c65							;		cmp	R1
   2201  0c65							;		lda	R0+1
   2202  0c65							;		sbc	R1+1
   2203  0c65							;		bvc	iRANDOM_4
   2204  0c65							;		eor	#$80
   2205  0c65							;iRANDOM_4	bpl	iRANDOM_sub
   2206  0c65							;
   2207  0c65							; All done.  Almost.  Add one, then push the result.
   2208  0c65							;
   2209  0c65							;irandom1	inc	R0
   2210  0c65							;		bne	iRANDOM_3
   2211  0c65							;		inc	R0+1
   2212  0c65							;iRANDOM_3
   2213  0c65							;		  jsr	pushR0	;return value
   2214  0c65							;		jmp	NextIL
   2215  0c65							;
   2216  0c65							; Poke a value into a memory location
   2217  0c65		       8c bc 2f    iPOKEMEMORY sty	tempy
   2218  0c68		       20 b3 1d 	      jsr	popR0
   2219  0c6b		       20 cb 1d 	      jsr	popR1
   2220  0c6e		       a0 00		      ldy	#0
   2221  0c70		       a5 52		      lda	R0
   2222  0c72		       91 54		      sta	(R1),y
   2223  0c74		       ac bc 2f 	      ldy	tempy
   2224  0c77		       4c c2 02 	      jmp	NextIL
   2225  0c7a							;
   2226  0c7a							; Get a value from a memory location
   2227  0c7a							;
   2228  0c7a		       8c bc 2f    iPEEKMEMORY sty	tempy
   2229  0c7d		       20 b3 1d 	      jsr	popR0
   2230  0c80		       a0 00		      ldy	#0
   2231  0c82		       b1 52		      lda	(R0),y
   2232  0c84		       ac bc 2f 	      ldy	tempy
   2233  0c87		       85 52		      sta	R0
   2234  0c89		       a9 00		      lda	#0
   2235  0c8b		       85 53		      sta	R0+1
   2236  0c8d		       4c 42 07 	      jmp	pushR0nextIl
   2237  0c90							;
   2238  0c90							; Call to address return what ever is in a to the stack
   2239  0c90							; func2 will load a value into a before the call
   2240  0c90		       20 cb 1d    iCallFunc  jsr	popR1
   2241  0c93		       a5 54		      lda	R1
   2242  0c95		       20 a1 0c 	      jsr	iCallRtn
   2243  0c98		       85 52		      sta	R0
   2244  0c9a		       a9 00		      lda	#0
   2245  0c9c		       85 53		      sta	R0+1
   2246  0c9e		       20 42 07 	      jsr	pushR0nextIl
   2247  0ca1				   iCallRtn
   2248  0ca1		       20 b3 1d 	      jsr	popR0
   2249  0ca4		       6c 52 00 	      jmp	(R0)
   2250  0ca7
   2251  0ca7
   2252  0ca7							;===========================================jlit======
   2253  0ca7							;Get a character from the terminal convert to value
   2254  0ca7							;leave the number on top of the stack
   2255  0ca7							;
   2256  0ca7				   iGETCHAR
   2257  0ca7		       20 bd 1f 	      jsr	VGETCH
   2258  0caa					      if	CTMON65
   2259  0caa		       48		      pha
   2260  0cab		       20 ba 1f 	      jsr	VOUTCH	;echo echo echo
   2261  0cae		       68		      pla
   2262  0caf					      endif
   2263  0caf		       85 52		      sta	R0
   2264  0cb1		       a9 00		      lda	#0
   2265  0cb3		       85 53		      sta	R0+1
   2266  0cb5		       20 21 1d 	      jsr	pushR0
   2267  0cb8							;
   2268  0cb8		       4c c2 02 	      jmp	NextIL
   2269  0cbb							;===========================================jusilostintim======
   2270  0cbb							;Put a character to the terminal convert to
   2271  0cbb							;
   2272  0cbb		       20 b3 1d    iPUTCHAR   jsr	popR0
   2273  0cbe		       a5 52		      lda	R0
   2274  0cc0		       20 ba 1f 	      jsr	VOUTCH
   2275  0cc3		       4c c2 02 	      jmp	NextIL
   2276  0cc6							;=====================================================
   2277  0cc6							; Put the number on the stack out as hex, suppress leading 0
   2278  0cc6				   iHexOut
   2279  0cc6		       20 b3 1d 	      jsr	popR0
   2280  0cc9		       a5 53		      lda	R0+1
   2281  0ccb		       f0 03		      beq	iHexSecondByte
   2282  0ccd		       20 20 14 	      jsr	OUTHEX
   2283  0cd0				   iHexSecondByte
   2284  0cd0		       a5 52		      lda	R0
   2285  0cd2		       20 20 14 	      jsr	OUTHEX
   2286  0cd5		       4c c2 02 	      jmp	NextIL
   2287  0cd8							;
   2288  0cd8							;=====================================================
   2289  0cd8							; Replace TOS with its absolute value.
   2290  0cd8							;
   2291  0cd8		       20 b3 1d    iABS       jsr	popR0
   2292  0cdb		       a5 53		      lda	R0+1
   2293  0cdd		       10 10		      bpl	iABS_1	;already positive
   2294  0cdf		       49 ff		      eor	#$ff
   2295  0ce1		       85 53		      sta	R0+1
   2296  0ce3		       a5 52		      lda	R0
   2297  0ce5		       49 ff		      eor	#$ff
   2298  0ce7		       85 52		      sta	R0
   2299  0ce9		       e6 52		      inc	R0
   2300  0ceb		       d0 02		      bne	iABS_1
   2301  0ced		       e6 53		      inc	R0+1
   2302  0cef		       4c 42 07    iABS_1     jmp	pushR0nextIl
   2303  0cf2
   2304  0cf2							;
   2305  0cf2							;================================================================
   2306  0cf2							; The set of logical operators
   2307  0cf2				   iLogAnd
   2308  0cf2		       20 b3 1d 	      jsr	popR0
   2309  0cf5		       20 cb 1d 	      jsr	popR1
   2310  0cf8		       a5 52		      lda	R0
   2311  0cfa		       25 54		      and	R1
   2312  0cfc		       85 52		      sta	R0
   2313  0cfe		       a5 53		      lda	R0+1
   2314  0d00		       25 55		      and	R1+1
   2315  0d02		       85 53		      sta	R0+1
   2316  0d04		       4c 42 07 	      jmp	pushR0nextIl
   2317  0d07				   iLogOr
   2318  0d07		       20 b3 1d 	      jsr	popR0
   2319  0d0a		       20 cb 1d 	      jsr	popR1
   2320  0d0d		       a5 52		      lda	R0
   2321  0d0f		       05 54		      ora	R1
   2322  0d11		       85 52		      sta	R0
   2323  0d13		       a5 53		      lda	R0+1
   2324  0d15		       05 55		      ora	R1+1
   2325  0d17		       85 53		      sta	R0+1
   2326  0d19		       4c 42 07 	      jmp	pushR0nextIl
   2327  0d1c				   iLogXor
   2328  0d1c		       20 b3 1d 	      jsr	popR0
   2329  0d1f		       20 cb 1d 	      jsr	popR1
   2330  0d22		       a5 52		      lda	R0
   2331  0d24		       45 54		      eor	R1
   2332  0d26		       85 52		      sta	R0
   2333  0d28		       a5 53		      lda	R0+1
   2334  0d2a		       45 55		      eor	R1+1
   2335  0d2c		       85 53		      sta	R0+1
   2336  0d2e		       4c 42 07 	      jmp	pushR0nextIl
   2337  0d31				   iLogNot
   2338  0d31		       20 b3 1d 	      jsr	popR0
   2339  0d34		       a5 52		      lda	R0
   2340  0d36		       49 ff		      eor	#$FF
   2341  0d38		       85 52		      sta	R0
   2342  0d3a		       a5 53		      lda	R0+1
   2343  0d3c		       49 ff		      eor	#$FF
   2344  0d3e		       85 53		      sta	R0+1
   2345  0d40		       4c 42 07 	      jmp	pushR0nextIl
   2346  0d43
   2347  0d43				   iTruth
   2348  0d43		       a9 ff		      lda	#$FF
   2349  0d45		       85 52		      sta	R0
   2350  0d47		       85 53		      sta	R0+1
   2351  0d49		       4c 42 07 	      jmp	pushR0nextIl
   2352  0d4c				   iFalse
   2353  0d4c		       a9 00		      lda	#$00
   2354  0d4e		       85 52		      sta	R0
   2355  0d50		       85 53		      sta	R0+1
   2356  0d52		       4c 42 07 	      jmp	pushR0nextIl
   2357  0d55
   2358  0d55							;================================================================
   2359  0d55							;Set the IRQ service rtn line number
   2360  0d55							;
   2361  0d55		       78	   iSetIrq    sei		; disable the interupts
   2362  0d56		       a9 00		      lda	#0	; Zero the Status flag
   2363  0d58		       8d 67 26 	      sta	IRQStatus
   2364  0d5b		       20 b3 1d 	      jsr	popR0	; get the line number
   2365  0d5e		       a5 52		      lda	R0
   2366  0d60		       05 53		      ora	R0+1
   2367  0d62		       f0 22		      beq	iSetExt	; if it is zero disable all
   2368  0d64		       a9 01		      lda	#GOSUB_RTN	; default push type
   2369  0d66		       20 3b 1d 	      jsr	pushLN	; Save the current line pointer
   2370  0d69		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2371  0d6b		       4c f7 0b 	      jmp	ErrStkOver	; Check if there was an error
   2372  0d6e				   iSetIrqOk
   2373  0d6e		       20 6d 1b 	      jsr	findLine	; Find the IRQ func Line Pointer
   2374  0d71		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2375  0d73		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2376  0d75		       8d 6a 26 	      sta	IRQEntry+1
   2377  0d78		       a5 4f		      lda	CURPTR
   2378  0d7a		       8d 69 26 	      sta	IRQEntry
   2379  0d7d		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2380  0d7f		       8d 67 26 	      sta	IRQStatus
   2381  0d82		       20 64 1d 	      jsr	popLN	; Restore the old line number
   2382  0d85		       58		      cli		; Enable the interupts
   2383  0d86		       4c c2 02    iSetExt    jmp	NextIL
   2384  0d89
   2385  0d89		       20 64 1d    iSetIrqErr jsr	popLN
   2386  0d8c		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2387  0d8e		       a9 00		      lda	#0
   2388  0d90		       4c a9 06 	      jmp	iErr2
   2389  0d93							;
   2390  0d93		       20 b3 1d    iTRACEPROG jsr	popR0
   2391  0d96		       a5 52		      lda	R0
   2392  0d98		       85 40		      sta	ILTrace
   2393  0d9a		       4c c2 02 	      jmp	NextIL
   2394  0d9d
   2395  0d9d							;=====================================================
   2396  0d9d							; Define start of non page zero data
   2397 U2fce ????				      seg.u	TBData
   2398 U2624					      org	PROGEND
   2399 U2624							;=================================================================
   2400 U2624							;
------- FILE compile.asm LEVEL 2 PASS 6
      0 U2624					      include	"compile.asm"
      1  0d9d					      Seg	Code
      2  0d9d							;
      3  0d9d							;=====================================================================
      4  0d9d							; Scan the loaded program just before running and insert memory locations of each
      5  0d9d							; line number branched to. goto gosub, gofn
      6  0d9d							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  0d9d				   Compile
      8  0d9d		       a9 00		      lda	#0
      9  0d9f		       85 52		      sta	R0	; keep track of how many errors we find
     10  0da1		       a5 5b		      lda	RunMode
     11  0da3		       48		      pha
     12  0da4		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  0da6		       a5 4f		      lda	CURPTR
     14  0da8		       48		      pha
     15  0da9		       a5 50		      lda	CURPTR+1
     16  0dab		       48		      pha
     17  0dac		       a5 51		      lda	CUROFF
     18  0dae		       48		      pha
     19  0daf		       ad c4 2f 	      lda	ProgramStart
     20  0db2		       85 59		      sta	dpl
     21  0db4		       ad c5 2f 	      lda	ProgramStart+1
     22  0db7		       85 5a		      sta	dpl+1
     23  0db9
     24  0db9				   CompileLineStart
     25  0db9		       a5 59		      lda	dpl
     26  0dbb		       cd c6 2f 	      cmp	ProgramEnd
     27  0dbe		       d0 07		      bne	CompileContinue
     28  0dc0		       a5 5a		      lda	dpl+1
     29  0dc2		       cd c7 2f 	      cmp	ProgramEnd+1
     30  0dc5		       f0 3f		      beq	CompileComplete
     31  0dc7
     32  0dc7				   CompileContinue
     33  0dc7		       a0 03		      ldy	#3	; first real character in the line
     34  0dc9
     35  0dc9				   CompileLoop
     36  0dc9		       b1 59		      lda	(dpl),y	; get the byte
     37  0dcb		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  0dcd		       c8		      iny		; Pass this byte
     39  0dce		       c9 07		      cmp	#kGoto
     40  0dd0		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  0dd2		       c9 08		      cmp	#kGosub
     42  0dd4		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  0dd6		       c9 31		      cmp	#kGofn
     44  0dd8		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  0dda		       c9 29		      cmp	#kTask
     46  0ddc		       f0 4c		      beq	CompileField
     47  0dde		       c9 0a		      cmp	#kRem
     48  0de0		       f0 12		      beq	CompileRem	; Skip until end of line
     49  0de2		       c9 a0		      cmp	#tString
     50  0de4		       f0 2f		      beq	CompileString
     51  0de6		       c9 a1		      cmp	#tInteger
     52  0de8		       f0 06		      beq	CompileInteger
     53  0dea		       c9 a2		      cmp	#tByte
     54  0dec		       f0 03		      beq	CompileByte
     55  0dee		       d0 d9		      bne	CompileLoop	; Next character
     56  0df0
     57  0df0				   CompileInteger
     58  0df0		       c8		      iny
     59  0df1				   CompileByte
     60  0df1		       c8		      iny
     61  0df2		       d0 d5		      bne	CompileLoop
     62  0df4				   CompileRem
     63  0df4				   CompileEndOfLine
     64  0df4		       a0 00		      ldy	#0
     65  0df6		       b1 59		      lda	(dpl),y
     66  0df8		       18		      clc
     67  0df9		       65 59		      adc	dpl
     68  0dfb		       85 59		      sta	dpl
     69  0dfd		       a9 00		      lda	#0
     70  0dff		       65 5a		      adc	dpl+1
     71  0e01		       85 5a		      sta	dpl+1
     72  0e03
     73  0e03		       4c b9 0d 	      jmp	CompileLineStart
     74  0e06
     75  0e06				   CompileComplete
     76  0e06		       68		      pla
     77  0e07		       85 51		      sta	CUROFF
     78  0e09		       68		      pla
     79  0e0a		       85 50		      sta	CURPTR+1
     80  0e0c		       68		      pla
     81  0e0d		       85 4f		      sta	CURPTR
     82  0e0f		       68		      pla
     83  0e10		       85 5b		      sta	RunMode
     84  0e12		       a5 52		      lda	R0	; returning the number of errors
     85  0e14		       60		      rts
     86  0e15
     87  0e15
     88  0e15				   CompileString
     89  0e15		       c8		      iny		; point past first "
     90  0e16				   CompileStringLoop
     91  0e16		       b1 59		      lda	(dpl),y
     92  0e18		       f0 0d		      beq	CompileStrDone2
     93  0e1a		       c9 22		      cmp	#'"	; end of string
     94  0e1c		       f0 08		      beq	CompileStrDone
     95  0e1e		       c9 5c		      cmp	#'\	; escape character
     96  0e20		       d0 01		      bne	CompileStrNext
     97  0e22		       c8		      iny
     98  0e23				   CompileStrNext
     99  0e23		       c8		      iny		; Next character
    100  0e24		       d0 f0		      bne	CompileStringLoop	; test for end
    101  0e26				   CompileStrDone
    102  0e26		       c8		      iny
    103  0e27				   CompileStrDone2
    104  0e27		       4c c9 0d 	      Jmp	CompileLoop
    105  0e2a							;
    106  0e2a							;===============================================================
    107  0e2a							; on entry y points to storage location y+2 points to line number
    108  0e2a							; on exit y points to line number type
    109  0e2a
    110  0e2a		       85 52	   CompileField sta	R0
    111  0e2c		       98		      tya		; save the y pointer to store the memory value
    112  0e2d		       48		      pha
    113  0e2e		       c8		      iny		; Skip over the memory vector
    114  0e2f		       c8		      iny
    115  0e30		       a5 52		      lda	R0
    116  0e32		       c9 29		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  0e34		       d0 07		      bne	CompNoBracket
    118  0e36
    119  0e36		       b1 59		      lda	(dpl),y	; Lets make sure it is a
    120  0e38		       c9 e0		      cmp	#oLeftBracket
    121  0e3a		       d0 01		      bne	CompNoBracket	; in case of error
    122  0e3c		       c8		      iny		; skip the bracket
    123  0e3d
    124  0e3d				   CompNoBracket
    125  0e3d		       a9 00		      lda	#0	; In case the value is a byte
    126  0e3f		       85 53		      sta	R0+1
    127  0e41
    128  0e41		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  0e43		       c9 a2		      cmp	#tByte
    130  0e45		       f0 15		      beq	CompByteLoad
    131  0e47		       c9 a1		      cmp	#tInteger
    132  0e49		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  0e4b		       68		      pla
    134  0e4c		       4c c9 0d 	      jmp	CompileLoop	; Ignore the saved stack
    135  0e4f				   CompIntLoad
    136  0e4f		       c8		      iny
    137  0e50		       b1 59		      lda	(dpl),y
    138  0e52		       85 52		      sta	R0
    139  0e54		       c8		      iny
    140  0e55		       b1 59		      lda	(dpl),y
    141  0e57		       85 53		      sta	R0+1
    142  0e59		       4c 61 0e 	      jmp	CompFindLine
    143  0e5c				   CompByteLoad
    144  0e5c		       c8		      iny
    145  0e5d		       b1 59		      lda	(dpl),y
    146  0e5f		       85 52		      sta	R0
    147  0e61				   CompFindLine
    148  0e61		       20 6d 1b 	      jsr	findLine
    149  0e64		       f0 1d		      beq	CompFoundLine
    150  0e66		       e6 52		      inc	R0	; number of errors
    151  0e68
    152  0e68		       a5 59		      lda	dpl
    153  0e6a		       85 4f		      sta	CURPTR
    154  0e6c		       a5 5a		      lda	dpl+1
    155  0e6e		       85 50		      sta	CURPTR+1
    156  0e70		       84 51		      sty	CUROFF
    157  0e72
    158  0e72		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  0e74		       a9 00		      lda	#0
    160  0e76
    161  0e76		       20 53 06 	      jsr	DisplayError
    162  0e79		       20 d5 14 	      jsr	PrintProgramLine
    163  0e7c
    164  0e7c		       68		      pla
    165  0e7d		       a8		      tay
    166  0e7e		       c8		      iny
    167  0e7f		       c8		      iny
    168  0e80		       4c c9 0d 	      jmp	CompileLoop
    169  0e83
    170  0e83				   CompFoundLine
    171  0e83		       68		      pla
    172  0e84		       a8		      tay
    173  0e85		       a5 4f		      lda	CURPTR
    174  0e87		       91 59		      sta	(dpl),y
    175  0e89		       c8		      iny
    176  0e8a		       a5 50		      lda	CURPTR+1
    177  0e8c		       91 59		      sta	(dpl),y
    178  0e8e		       c8		      iny
    179  0e8f		       4c c9 0d 	      jmp	CompileLoop
    180  0e92
    181  0e92
    182  0e92
    183  0e92
    184  0e92
    185  0e92
    186  0e92
    187  0e92
    188  0e92
    189  0e92
    190  0e92
    191  0e92
    192  0e92
    193  0e92
    194  0e92
    195  0e92
    196  0e92
    197  0e92
    198  0e92
    199  0e92
    200  0e92
    201  0e92
    202  0e92
    203  0e92
    204  0e92
    205  0e92
    206  0e92
    207  0e92
    208  0e92
    209  0e92
    210  0e92
    211  0e92
    212  0e92
    213  0e92
    214  0e92
    215  0e92
    216  0e92
    217  0e92
    218  0e92
    219  0e92
    220  0e92
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  0e92					      include	"tokenizer.asm"
      1  0e92					      seg	Code
      2  0e92		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  0e92
      4  0e92							; Define the types of tokens found, and identifiers
      5  0e92		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0e92		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0e92		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0e92		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0e92
     10  0e92		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0e92		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0e92		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0e92
     14  0e92
     15  0e92		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0e92		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0e92		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0e92		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0e92							; Arrays of string are arrays of pointers 2 bytes
     20  0e92		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0e92		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0e92
     23  0e92		       3c 3e	   Operators  BYTE.b	"<>"
     24  0e94		       3c 3d		      BYTE.b	"<="
     25  0e96		       3e 3d		      BYTE.b	">="
     26  0e98		       3c 00		      BYTE.b	"<",0
     27  0e9a		       3d 00		      BYTE.b	"=",0
     28  0e9c		       3e 00		      BYTE.b	">",0
     29  0e9e		       2b 00		      BYTE.b	"+",0
     30  0ea0		       2d 00		      BYTE.b	"-",0
     31  0ea2		       2f 00		      BYTE.b	"/",0
     32  0ea4		       25 00		      BYTE.b	"%",0
     33  0ea6		       2a 00		      BYTE.b	"*",0
     34  0ea8		       28 00		      BYTE.b	"(",0
     35  0eaa		       29 00		      BYTE.b	")",0
     36  0eac		       2c 00		      BYTE.b	",",0
     37  0eae		       3b 00		      BYTE.b	";",0
     38  0eb0		       5b 00		      BYTE.b	"[",0
     39  0eb2		       5d 00		      BYTE.b	"]",0
     40  0eb4		       3a 00		      BYTE.b	":",0
     41  0eb6		       24 00		      BYTE.b	"$",0
     42  0eb8		       21 00		      BYTE.b	"!",0
     43  0eba		       3f 00		      BYTE.b	"?",0
     44  0ebc		       2e 00		      BYTE.b	".",0
     45  0ebe		       00 00		      BYTE.b	0,0
     46  0ec0
     47  0ec0		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     48  0ec6		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     49  0ecb		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     50  0ed1		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     51  0ed6
     52  0ed6		       00 0b	   oQuestion  equ	kPrint
     53  0ed6							;    2 is =
     54  0ed6							;    1 is <
     55  0ed6							;    3 is <=
     56  0ed6							;    5 is <>
     57  0ed6							;    4 is >
     58  0ed6							;    6 is >=
     59  0ed6		       00 f1	   oLess      equ	$F1
     60  0ed6		       00 f2	   oEqual     equ	$F2
     61  0ed6		       00 f3	   oLessEqual equ	$F3
     62  0ed6		       00 f4	   oGreater   equ	$F4
     63  0ed6		       00 f5	   oNotEqual  equ	$F5
     64  0ed6		       00 f6	   oGreaterEqual equ	$F6
     65  0ed6
     66  0ed6		       00 e0	   oLeftBracket equ	$E0
     67  0ed6		       00 e1	   oRightBracket equ	$E1
     68  0ed6		       00 e2	   oComma     equ	$E2
     69  0ed6		       00 e3	   oSemiColon equ	$E3
     70  0ed6		       00 e4	   oLeftSQBracket equ	$E4
     71  0ed6		       00 e5	   oRightSQBracket equ	$E5
     72  0ed6		       00 e6	   oColon     equ	$E6
     73  0ed6		       00 e7	   oDollar    equ	$E7
     74  0ed6		       00 e8	   oBang      equ	$E8
     75  0ed6		       00 e9	   oPeriod    equ	$E9
     76  0ed6
     77  0ed6
     78  0ed6		       00 ea	   oPlus      equ	$EA
     79  0ed6		       00 eb	   oMinus     equ	$EB
     80  0ed6		       00 ec	   oDivide    equ	$EC
     81  0ed6		       00 ed	   oModulo    equ	$ED
     82  0ed6		       00 ee	   oMultiply  equ	$EE
     83  0ed6
     84  0ed6		       00 ed	   oPercent   equ	oModulo
     85  0ed6
     86  0ed6		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     87  0ed6
     88  0ed6		       00 ff	   tError     equ	$FF	; Error should never happen
     89  0ed6							;============================================================================================
     90  0ed6							; Keyword and seperator values
     91  0ed6				   '
     92  0ed6		       00 01	   kBeginKey  equ	kLet
     93  0ed6							;
     94  0ed6		       00 01	   kLet       equ	1
     95  0ed6		       00 02	   kInc       equ	kLet+1
     96  0ed6		       00 03	   kDec       equ	kInc+1
     97  0ed6		       00 04	   kIreturn   equ	kDec+1
     98  0ed6		       00 05	   kIf	      equ	kIreturn+1
     99  0ed6		       00 06	   kThen      equ	kIf+1
    100  0ed6		       00 07	   kGoto      equ	kThen+1
    101  0ed6		       00 08	   kGosub     equ	kGoto+1
    102  0ed6		       00 09	   kReturn    equ	kGosub+1
    103  0ed6		       00 0a	   kRem       equ	kReturn+1
    104  0ed6		       00 0b	   kPrint     equ	kRem+1
    105  0ed6		       00 0c	   kTaske     equ	kPrint+1
    106  0ed6		       00 0d	   kTaskn     equ	kTaske+1
    107  0ed6		       00 0e	   kTaskw     equ	kTaskn+1
    108  0ed6		       00 0f	   kPoke      equ	kTaskw+1
    109  0ed6		       00 10	   kPutch     equ	kPoke+1
    110  0ed6		       00 11	   kCls       equ	kPutch+1
    111  0ed6		       00 12	   kInput     equ	kCls+1
    112  0ed6		       00 13	   kEnd       equ	kInput+1
    113  0ed6		       00 14	   kIrq       equ	kEnd+1
    114  0ed6		       00 15	   kKill      equ	kIrq+1
    115  0ed6		       00 16	   kList      equ	kKill+1
    116  0ed6		       00 17	   kRun       equ	kList+1
    117  0ed6		       00 18	   kNew       equ	kRun+1
    118  0ed6		       00 19	   kSlice     equ	kNew+1
    119  0ed6		       00 1a	   kTrace     equ	kSlice+1
    120  0ed6		       00 1b	   kExit      equ	kTrace+1
    121  0ed6		       00 1c	   kSave      equ	kExit+1
    122  0ed6		       00 1d	   kLoad      equ	kSave+1
    123  0ed6		       00 1e	   kErase     equ	kLoad+1
    124  0ed6		       00 1f	   kDir       equ	kErase+1
    125  0ed6							;
    126  0ed6							; End of actual key words
    127  0ed6							;
    128  0ed6		       00 1e	   kKeyCount  equ	kDir-kBeginKey
    129  0ed6							;
    130  0ed6							; Logical operators
    131  0ed6							;
    132  0ed6		       00 20	   kNot       equ	kDir+1
    133  0ed6		       00 21	   kOr	      equ	kNot+1
    134  0ed6		       00 22	   kXor       equ	kOr+1
    135  0ed6		       00 23	   kAnd       equ	kXor+1
    136  0ed6
    137  0ed6							; numeric functions
    138  0ed6							;
    139  0ed6		       00 24	   kBeginFunc equ	kTrue
    140  0ed6							;
    141  0ed6							; Truth operators
    142  0ed6							;
    143  0ed6		       00 24	   kTrue      equ	kAnd+1
    144  0ed6		       00 25	   kFalse     equ	kTrue+1
    145  0ed6							; Functions
    146  0ed6		       00 26	   kFree      equ	kFalse+1
    147  0ed6		       00 27	   kGetch     equ	kFree+1
    148  0ed6		       00 28	   kPeek      equ	kGetch+1
    149  0ed6		       00 29	   kTask      equ	kPeek+1
    150  0ed6		       00 2a	   kIpcc      equ	kTask+1
    151  0ed6		       00 2b	   kIpcs      equ	kIpcc+1
    152  0ed6		       00 2c	   kIpcr      equ	kIpcs+1
    153  0ed6		       00 2d	   kRnd       equ	kIpcr+1
    154  0ed6		       00 2e	   kStat      equ	kRnd+1
    155  0ed6		       00 2f	   kAbs       equ	kStat+1
    156  0ed6		       00 30	   kCall      equ	kAbs+1
    157  0ed6		       00 31	   kGofn      equ	kCall+1
    158  0ed6		       00 32	   kPid       equ	kGofn+1
    159  0ed6							;
    160  0ed6		       00 0f	   kFuncCount equ	((kPid - kBeginFunc) + 1)
    161  0ed6
    162  0ed6							;
    163  0ed6							; Keyword table contains 49 keywords
    164  0ed6				   KeyWordTable
      0  0ed6					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0ed6		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0eda					      db	kInc,"inC"
      1  0eda		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0ede					      db	kDec,"deC"
      1  0ede		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0ee2					      db	kIreturn,"ireturN"
      1  0ee2		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0eea					      db	kIf,"iF"
      1  0eea		       05 69 46 	      .byte.b	kIf,"iF"
      0  0eed					      db	kThen,"theN"
      1  0eed		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0ef2					      db	kGoto,"gotO"
      1  0ef2		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0ef7					      db	kGosub,"gosuB"
      1  0ef7		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0efd					      db	kReturn,"returN"
      1  0efd		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0f04					      db	kRem,"reM"
      1  0f04		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0f08					      db	kPrint,"prinT"
      1  0f08		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0f0e					      db	kTaske,"taskE"
      1  0f0e		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0f14					      db	kTaskn,"taskN"
      1  0f14		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0f1a					      db	kTaskw,"taskW"
      1  0f1a		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0f20					      db	kPoke,"pokE"
      1  0f20		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0f25					      db	kPutch,"putcH"
      1  0f25		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0f2b					      db	kCls,"clS"
      1  0f2b		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0f2f					      db	kInput,"inpuT"
      1  0f2f		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0f35					      db	kEnd,"enD"
      1  0f35		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0f39					      db	kIrq,"irQ"
      1  0f39		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0f3d					      db	kKill,"kilL"
      1  0f3d		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0f42					      db	kList,"lisT"
      1  0f42		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0f47					      db	kRun,"ruN"
      1  0f47		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0f4b					      db	kNew,"neW"
      1  0f4b		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0f4f					      db	kSlice,"slicE"
      1  0f4f		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0f55					      db	kTrace,"tracE"
      1  0f55		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0f5b					      db	kExit,"exiT"
      1  0f5b		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0f60					      db	kSave,"savE"
      1  0f60		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0f65					      db	kLoad,"loaD"
      1  0f65		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0f6a					      db	kErase,"erasE"
      1  0f6a		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0f70					      db	kDir,"diR"
      1  0f70		       1f 64 69 52	      .byte.b	kDir,"diR"
    196  0f74							;Short form for statements:
      0  0f74					      db	kIreturn,"ireT"
      1  0f74		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0f79					      db	kReturn,"reT"
      1  0f79		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  0f7d					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  0f7d		       0b 70 52 	      .byte.b	kPrint,"pR"
    200  0f80
    201  0f80							;Logical and truth operators
      0  0f80					      db	kNot,"noT"
      1  0f80		       20 6e 6f 54	      .byte.b	kNot,"noT"
      0  0f84					      db	kOr,"oR"
      1  0f84		       21 6f 52 	      .byte.b	kOr,"oR"
      0  0f87					      db	kXor,"xoR"
      1  0f87		       22 78 6f 52	      .byte.b	kXor,"xoR"
      0  0f8b					      db	kAnd,"anD"
      1  0f8b		       23 61 6e 44	      .byte.b	kAnd,"anD"
    206  0f8f							; Truth values
      0  0f8f					      db	kTrue,"truE"
      1  0f8f		       24 74 72 75*	      .byte.b	kTrue,"truE"
      0  0f94					      db	kFalse,"falsE"
      1  0f94		       25 66 61 6c*	      .byte.b	kFalse,"falsE"
    209  0f9a
    210  0f9a							;functions returning values
    211  0f9a
      0  0f9a					      db	kFree,"freE"
      1  0f9a		       26 66 72 65*	      .byte.b	kFree,"freE"
      0  0f9f					      db	kGetch,"getcH"
      1  0f9f		       27 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0fa5					      db	kPeek,"peeK"
      1  0fa5		       28 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0faa					      db	kTask,"tasK"
      1  0faa		       29 74 61 73*	      .byte.b	kTask,"tasK"
      0  0faf					      db	kIpcc,"ipcC"
      1  0faf		       2a 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0fb4					      db	kIpcs,"ipcS"
      1  0fb4		       2b 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0fb9					      db	kIpcr,"ipcR"
      1  0fb9		       2c 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0fbe					      db	kRnd,"rnD"
      1  0fbe		       2d 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0fc2					      db	kStat,"staT"
      1  0fc2		       2e 73 74 61*	      .byte.b	kStat,"staT"
      0  0fc7					      db	kAbs,"abS"
      1  0fc7		       2f 61 62 53	      .byte.b	kAbs,"abS"
      0  0fcb					      db	kCall,"calL"
      1  0fcb		       30 63 61 6c*	      .byte.b	kCall,"calL"
      0  0fd0					      db	kGofn,"gofN"
      1  0fd0		       31 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0fd5					      db	kPid,"piD"
      1  0fd5		       32 70 69 44	      .byte.b	kPid,"piD"
      0  0fd9					      db	0,0
      1  0fd9		       00 00		      .byte.b	0,0
    226  0fdb
    227  0fdb		       0f db	   KeyWordTableEnd equ	*
    228  0fdb		       01 05	   KeyWordTableLength equ	* - KeyWordTable
    229  0fdb		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    230  10db		       00 00 00    printStorage ds	3
    231  10de							;==================================================================================================================
    232  10de							; Read accross the inputline and output to TOKENBUFFER
    233  10de							; Format   byte      Description
    234  10de							;	     0	      length of line 1-255
    235  10de							;	    0-1       Line Number
    236  10de							;	    Tokens and litteral values encoded into the line
    237  10de							;
    238  10de							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    239  10de							;  if fails then test for keywords
    240  10de							;  if fails then test for variables and arrays
    241  10de							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    242  10de
    243  10de				   ParseInputLine
    244  10de				  -	      if	DEBUGPARSER
    245  10de				  -	      jsr	SetOutDebug
    246  10de				  -	      jsr	DebugClearBuffer
    247  10de					      endif
    248  10de		       a5 51		      lda	CUROFF
    249  10e0		       48		      pha
    250  10e1		       8a		      txa
    251  10e2		       48		      pha
    252  10e3		       98		      tya
    253  10e4		       48		      pha
    254  10e5		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    255  10e7		       20 d3 1b 	      jsr	getDecimal	; Check for a line number, none is ok too
    256  10ea		       84 51		      sty	CUROFF
    257  10ec		       20 aa 12 	      jsr	R02TOKEN	; Move R0 to token buffer
    258  10ef
    259  10ef				   ParseInputLoop
    260  10ef		       a4 51		      ldy	CUROFF
    261  10f1		       20 63 1e 	      jsr	SkipSpaces	; Skip any spaces
    262  10f4		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    263  10f6		       b9 27 2f 	      lda	LINBUF,y	; Check for end of line
    264  10f9		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    265  10fb
    266  10fb				   ParseForNumber
    267  10fb		       20 fe 11 	      jsr	ParseNumeric	; Check for a numeric value
    268  10fe		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    269  1100
    270  1100				   ParseForString
    271  1100		       20 d4 11 	      jsr	ParseString	; Check for a string
    272  1103		       90 ea		      bcc	ParseInputLoop	; It was a string
    273  1105
    274  1105				   ParseForOp
    275  1105		       20 3c 12 	      jsr	ParseForOperator	; Check for operator or punctuation
    276  1108		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    277  110a
    278  110a				   ParseForKey
    279  110a		       20 31 11 	      jsr	ParseLookupKey	; Check for a keyword value
    280  110d		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    281  110f
    282  110f				   ParseForVar
    283  110f		       20 73 12 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    284  1112		       90 db		      bcc	ParseInputLoop
    285  1114
    286  1114				   ParseKeepChar		; if it does not parse just keep it safe
    287  1114		       b9 27 2f 	      lda	LINBUF,y
    288  1117		       9d db 0f 	      sta	TOKENBUFFER,x
    289  111a		       e8		      inx
    290  111b		       c8		      iny
    291  111c		       84 51		      sty	CUROFF
    292  111e		       d0 cf		      bne	ParseInputLoop
    293  1120
    294  1120				   ParseComplete
    295  1120		       a9 00		      lda	#0
    296  1122		       9d db 0f 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    297  1125		       e8		      inx
    298  1126		       8e db 0f 	      stx	TOKENBUFFER	; Place size including null into buffer start
    299  1129
    300  1129		       68		      pla
    301  112a		       a8		      tay
    302  112b		       68		      pla
    303  112c		       aa		      tax
    304  112d		       68		      pla
    305  112e		       85 51		      sta	CUROFF
    306  1130
    307  1130				  -	      if	DEBUGPARSER
    308  1130				  -
    309  1130				  -	      jsr	printTokenBuffer
    310  1130				  -			;jsr	  DebugPrintProgramLine
    311  1130				  -	      jsr	SetOutDebugEnd
    312  1130				  -
    313  1130					      endif
    314  1130		       60		      rts
    315  1131
    316  1131							;==================================================================================================================
    317  1131							; Look at curptr, curpos and check for a valid KeyWord
    318  1131							; A contains the index value. c is clear
    319  1131							;		     not found c set  A undefined
    320  1131							; X is prerserved
    321  1131							;
    322  1131				   ParseLookupKey
    323  1131		       86 58		      stx	R2
    324  1133		       a0 00		      ldy	#0
    325  1135		       a9 d6		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    326  1137		       85 54		      sta	R1
    327  1139		       a9 0e		      lda	#KeyWordTable>>8
    328  113b		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    329  113d		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    330  113f		       85 52		      sta	R0	; Save until next keyword
    331  1141		       c8		      iny		; Point to first character of keyword
    332  1142		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    333  1144
    334  1144				  -	      if	DEBUGPARSER
    335  1144				  -			;    jsr DebugKeyword
    336  1144					      endif
    337  1144
    338  1144				   ParseLookupLoop
    339  1144		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    340  1146		       29 df		      and	#%11011111	; Force Keyword to upper case
    341  1148		       dd 27 2f 	      cmp	LINBUF,x	; Check the input buffer
    342  114b		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    343  114d		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    344  114f		       dd 27 2f 	      cmp	LINBUF,x	; Compare value to upercase
    345  1152		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    346  1154
    347  1154				   ParseNextLetter
    348  1154		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    349  1156		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    350  1158		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    351  115a		       e8		      inx		; Point to next char in the input buffer
    352  115b		       c8		      iny		; Point to the next character in the Keyword table
    353  115c		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    354  115e		       dd 27 2f 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    355  1161		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    356  1163		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    357  1165
    358  1165				   ParseKeyFound
    359  1165		       a5 52		      lda	R0	; get the keyword index
    360  1167
    361  1167				   ParseKeyDone
    362  1167		       e8		      inx		; point past the last character
    363  1168		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    364  116a		       a6 58		      ldx	R2	; Restore the original x pointer
    365  116c		       9d db 0f 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    366  116f		       e8		      inx		; Point to next position in the output buffer
    367  1170		       86 58		      stx	R2	; Save next position in buffer
    368  1172		       c9 0a		      cmp	#kRem	; remark statement
    369  1174		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    370  1176		       c9 07		      cmp	#kGoto
    371  1178		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    372  117a		       c9 08		      cmp	#kGosub
    373  117c		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    374  117e		       c9 31		      cmp	#kGofn
    375  1180		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    376  1182		       c9 29		      cmp	#kTask
    377  1184		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    378  1186
    379  1186		       18		      clc		; C flag clear, we found it
    380  1187		       60		      rts
    381  1188
    382  1188							; Move forward to the next entry in table
    383  1188				   ParseNextEntry
    384  1188		       b1 54		      lda	(R1),y	; Get the next character in the token
    385  118a		       29 20		      and	#%00100000	; Is it the last character
    386  118c		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    387  118e		       c8		      iny		; Point to next char in the entry
    388  118f		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    389  1191
    390  1191				   ParseEndOfEntry
    391  1191		       c8		      iny		; Point to the byte after the last character
    392  1192		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    393  1193		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    394  1194		       65 54		      adc	R1
    395  1196		       85 54		      sta	R1
    396  1198		       a5 55		      lda	R1+1
    397  119a		       69 00		      adc	#0
    398  119c		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    399  119e		       a0 00		      ldy	#0	; Reset the index back to zero
    400  11a0		       b1 54		      lda	(R1),y	; get keyword value
    401  11a2		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    402  11a4		       85 52		      sta	R0	; save the next token value
    403  11a6		       c8		      iny		; Inc past token value
    404  11a7
    405  11a7				  -	      if	DEBUGPARSER
    406  11a7				  -			;    jsr DebugKeyword
    407  11a7					      endif
    408  11a7		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    409  11a9		       4c 44 11 	      jmp	ParseLookupLoop	; branch back for next key word
    410  11ac
    411  11ac				   ParseNoneFound
    412  11ac		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    413  11ae		       38		      sec		; c clear, not found
    414  11af		       60		      rts
    415  11b0
    416  11b0							;===============================================================================
    417  11b0							; Move everything from current position until the end of line into the token buffer
    418  11b0							;
    419  11b0		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    420  11b2		       a6 58		      ldx	R2	; where to place in the buffer
    421  11b4				   ParseMoveLoop
    422  11b4		       b9 27 2f 	      lda	LINBUF,y	; get the next byte
    423  11b7		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    424  11b9		       9d db 0f 	      sta	TOKENBUFFER,x	; save the byte
    425  11bc		       c8		      iny
    426  11bd		       e8		      inx
    427  11be		       d0 f4		      bne	ParseMoveLoop
    428  11c0				   ParseMoveDone
    429  11c0		       84 51		      sty	CUROFF
    430  11c2		       18		      clc
    431  11c3		       60		      rts
    432  11c4							;================================================================================================
    433  11c4							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    434  11c4							; transfer to a memory address
    435  11c4				   ParseHandleBranches
    436  11c4		       a6 58		      ldx	R2
    437  11c6		       a9 00		      lda	#0
    438  11c8		       9d db 0f 	      sta	TOKENBUFFER,x
    439  11cb		       e8		      inx
    440  11cc		       9d db 0f 	      sta	TOKENBUFFER,x
    441  11cf		       e8		      inx
    442  11d0		       86 58		      stx	R2
    443  11d2		       18		      clc
    444  11d3		       60		      rts
    445  11d4
    446  11d4							;=========================================================================================================
    447  11d4							;ParseString Parse a quotes string
    448  11d4							; on input X = outbuf position
    449  11d4							; y = inbuf position
    450  11d4							; Copies string to output buffer, updates x and y
    451  11d4				   ParseString
    452  11d4		       a4 51		      ldy	CUROFF
    453  11d6		       a9 a0		      lda	#tString
    454  11d8		       9d db 0f 	      sta	TOKENBUFFER,X
    455  11db		       b9 27 2f 	      lda	LINBUF,y
    456  11de		       c9 22		      cmp	#'"
    457  11e0		       d0 1a		      bne	ParseStringInvalid
    458  11e2		       e8		      inx
    459  11e3		       9d db 0f 	      sta	TOKENBUFFER,x
    460  11e6		       e8		      inx
    461  11e7		       c8		      iny
    462  11e8
    463  11e8				   ParseStringLoop
    464  11e8		       b9 27 2f 	      lda	LINBUF,y
    465  11eb		       9d db 0f 	      sta	TOKENBUFFER,x
    466  11ee		       c9 22		      cmp	#'"
    467  11f0		       f0 04		      beq	ParseStringDone
    468  11f2		       c8		      iny
    469  11f3		       e8		      inx
    470  11f4		       d0 f2		      bne	ParseStringLoop
    471  11f6
    472  11f6				   ParseStringDone
    473  11f6		       e8		      inx
    474  11f7		       c8		      iny
    475  11f8		       84 51		      sty	CUROFF
    476  11fa		       18		      clc
    477  11fb		       60		      rts
    478  11fc
    479  11fc				   ParseStringInvalid
    480  11fc		       38		      sec
    481  11fd		       60		      rts
    482  11fe
    483  11fe							;=========================================================================================================
    484  11fe							; Get numeric values and return value in RO and type in a
    485  11fe							;
    486  11fe				   ParseNumeric
    487  11fe		       a4 51		      ldy	CUROFF
    488  1200		       b9 27 2f 	      lda	LINBUF,y
    489  1203		       c9 30		      cmp	#'0
    490  1205		       90 33		      bcc	ParseNumInvalid
    491  1207		       c9 3a		      cmp	#'9+1
    492  1209		       b0 2f		      bcs	ParseNumInvalid
    493  120b		       86 58		      stx	R2
    494  120d		       20 d3 1b 	      jsr	getDecimal
    495  1210		       a6 58		      ldx	R2
    496  1212		       84 51		      sty	CUROFF
    497  1214		       a5 53		      lda	R0+1
    498  1216		       f0 14		      beq	ParseByteValue
    499  1218
    500  1218				   ParseIntegerValue
    501  1218		       a9 a1		      lda	#tInteger
    502  121a		       9d db 0f 	      sta	TOKENBUFFER,x
    503  121d		       e8		      inx
    504  121e		       a5 52		      lda	R0
    505  1220		       9d db 0f 	      sta	TOKENBUFFER,x
    506  1223		       e8		      inx
    507  1224		       a5 53		      lda	R0+1
    508  1226		       9d db 0f 	      sta	TOKENBUFFER,X
    509  1229		       e8		      inx
    510  122a		       18		      clc
    511  122b		       60		      rts
    512  122c
    513  122c				   ParseByteValue
    514  122c		       a9 a2		      lda	#tByte
    515  122e		       9d db 0f 	      sta	TOKENBUFFER,x
    516  1231		       e8		      inx
    517  1232		       a5 52		      lda	R0
    518  1234		       9d db 0f 	      sta	TOKENBUFFER,x
    519  1237		       e8		      inx
    520  1238		       18		      clc
    521  1239		       60		      rts
    522  123a
    523  123a				   ParseNumInvalid		;Not a valid Numeric
    524  123a		       38		      sec
    525  123b		       60		      rts
    526  123c
    527  123c							;=========================================================================================================
    528  123c							;Parse for operators and seperators
    529  123c							; on exit the A has the oper code, c is clear
    530  123c							;		 not found then c is set
    531  123c							;	x is preserved
    532  123c							;
    533  123c				   ParseForOperator
    534  123c		       86 58		      stx	R2
    535  123e		       a4 51		      ldy	CUROFF
    536  1240		       a2 00		      ldx	#0
    537  1242				  -	      if	DEBUGPARSER
    538  1242				  -			;	jsr    DebugPrintOP
    539  1242					      endif
    540  1242
    541  1242				   ParseOpLoop
    542  1242		       bd 92 0e 	      lda	Operators,x	; First byte of operator
    543  1245		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    544  1247
    545  1247		       d9 27 2f 	      cmp	LINBUF,y	; Check the first byte
    546  124a		       d0 1c		      bne	ParseOpNext
    547  124c
    548  124c		       c8		      iny
    549  124d
    550  124d		       bd 93 0e 	      lda	Operators+1,x
    551  1250		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    552  1252
    553  1252		       d9 27 2f 	      cmp	LINBUF,y
    554  1255		       d0 11		      bne	ParseOpNext
    555  1257
    556  1257				   ParseOpFound
    557  1257		       c8		      iny
    558  1258
    559  1258				   ParseOpFoundSingle
    560  1258		       84 51		      sty	CUROFF
    561  125a
    562  125a		       8a		      txa
    563  125b		       4a		      lsr
    564  125c		       aa		      tax
    565  125d		       bd c0 0e 	      lda	OperValues,x
    566  1260		       a6 58		      ldx	R2
    567  1262		       9d db 0f 	      sta	TOKENBUFFER,x
    568  1265		       e8		      inx
    569  1266		       18		      clc
    570  1267		       60		      rts
    571  1268
    572  1268				   ParseOpNext
    573  1268		       e8		      inx
    574  1269		       e8		      inx
    575  126a
    576  126a				  -	      if	DEBUGPARSER
    577  126a				  -			;	 jsr	DebugPrintOP
    578  126a					      endif
    579  126a		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    580  126c		       4c 42 12 	      jmp	ParseOpLoop
    581  126f
    582  126f				   ParseOpNotFound
    583  126f		       a6 58		      ldx	R2
    584  1271		       38		      sec
    585  1272		       60		      rts
    586  1273							;=========================================================================================================
    587  1273				  -	      if	DEBUGPARSER
    588  1273				  -			;Print the text of a keyword
    589  1273				  -			;Input R1    = offset into table
    590  1273				  -DebugKeyword
    591  1273				  -	      tya
    592  1273				  -	      pha
    593  1273				  -	      ldy	#1
    594  1273				  -DebugKeyLoop
    595  1273				  -	      lda	(R1),y
    596  1273				  -	      jsr	VOUTCH
    597  1273				  -	      and	#%00100000
    598  1273				  -	      beq	DebugKeyDone
    599  1273				  -	      iny
    600  1273				  -	      bne	DebugKeyLoop
    601  1273				  -
    602  1273				  -DebugKeyDone
    603  1273				  -	      jsr	CRLF
    604  1273				  -	      pla
    605  1273				  -	      tay
    606  1273				  -	      rts
    607  1273				  -			;========================================
    608  1273				  -DebugPrintOP
    609  1273				  -	      pha
    610  1273				  -	      lda	Operators,x
    611  1273				  -	      jsr	VOUTCH
    612  1273				  -	      lda	Operators+1,x
    613  1273				  -	      beq	DbgPrtOpDone
    614  1273				  -	      jsr	VOUTCH
    615  1273				  -
    616  1273				  -DbgPrtOpDone
    617  1273				  -	      jsr	CRLF
    618  1273				  -	      pla
    619  1273				  -	      rts
    620  1273				  -			;=======================================
    621  1273				  -DebugClearBuffer
    622  1273				  -	      txa
    623  1273				  -	      pha
    624  1273				  -	      ldx	#$FF
    625  1273				  -	      lda	#0
    626  1273				  -DebugClrLoop
    627  1273				  -	      sta	TOKENBUFFER,x
    628  1273				  -	      dex
    629  1273				  -	      bne	DebugClrLoop
    630  1273				  -	      sta	TOKENBUFFER,x
    631  1273				  -	      pla
    632  1273				  -	      tax
    633  1273				  -	      rts
    634  1273				  -
    635  1273				  -			;=====================================================
    636  1273				  -			; Print the parser buffer as hex values
    637  1273				  -printTokenBuffer
    638  1273				  -	      stx	printStorage
    639  1273				  -	      sty	printStorage+1
    640  1273				  -	      sta	printStorage+2
    641  1273				  -
    642  1273				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    643  1273				  -	      inx		; we want to show the last zero byte
    644  1273				  -	      ldy	#0
    645  1273				  -
    646  1273				  -printHexLoop
    647  1273				  -	      lda	TOKENBUFFER,y	; get the character
    648  1273				  -	      jsr	HexToOut	; print it
    649  1273				  -	      lda	#$20
    650  1273				  -	      jsr	VOUTCH
    651  1273				  -	      iny
    652  1273				  -	      dex
    653  1273				  -	      cpx	#0
    654  1273				  -	      bne	printHexLoop
    655  1273				  -	      jsr	CRLF
    656  1273				  -
    657  1273				  -	      ldy	printStorage+1
    658  1273				  -	      ldx	printStorage
    659  1273				  -	      lda	printStorage+2
    660  1273				  -printHexDone
    661  1273				  -	      clc
    662  1273				  -	      rts
    663  1273					      endif
    664  1273
    665  1273
    666  1273							;=========================================================================================================
    667  1273							; Parse for variables A-Z @, ^  x!x x[op]
    668  1273				   ParseForVariable
    669  1273		       a4 51		      ldy	CUROFF
    670  1275		       b9 27 2f 	      lda	LINBUF,y
    671  1278		       c9 5e		      cmp	#'^	; is it an exit code
    672  127a		       d0 04		      bne	ParseVarMem
    673  127c		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    674  127e		       d0 1f		      bne	ParseVarSpecial
    675  1280
    676  1280				   ParseVarMem
    677  1280		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    678  1282		       d0 04		      bne	ParseVarStack
    679  1284		       a9 9d		      lda	#tVat
    680  1286		       d0 17		      bne	ParseVarSpecial
    681  1288
    682  1288				   ParseVarStack
    683  1288		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    684  128a		       d0 04		      bne	ParseVarLetters
    685  128c		       a9 9c		      lda	#tVhash
    686  128e		       d0 0f		      bne	ParseVarSpecial
    687  1290
    688  1290				   ParseVarLetters
    689  1290		       29 df		      and	#%11011111	; Force upper case
    690  1292		       c9 41		      cmp	#'A
    691  1294		       90 12		      bcc	ParseVarInvalid
    692  1296		       c9 5b		      cmp	#'Z+1
    693  1298		       b0 0e		      bcs	ParseVarInvalid
    694  129a							;
    695  129a							; The condition is true, so convert to an index, push
    696  129a							; it onto the stack and continue running.
    697  129a							;
    698  129a		       38		      sec
    699  129b		       e9 41		      sbc	#'A	;index is zero based
    700  129d		       09 80		      ora	#$80
    701  129f
    702  129f				   ParseVarSpecial
    703  129f		       9d db 0f 	      sta	TOKENBUFFER,x
    704  12a2		       e8		      inx
    705  12a3		       c8		      iny
    706  12a4		       84 51		      sty	CUROFF
    707  12a6		       18		      clc
    708  12a7		       60		      rts
    709  12a8
    710  12a8				   ParseVarInvalid
    711  12a8		       38		      sec
    712  12a9		       60		      rts
    713  12aa
    714  12aa
    715  12aa							;=========================================================================================================
    716  12aa							; Transfer R0 to the TOKENBUFFER
    717  12aa							;
    718  12aa				   R02TOKEN
    719  12aa		       a5 52		      lda	R0
    720  12ac		       9d db 0f 	      sta	TOKENBUFFER,x
    721  12af		       e8		      inx
    722  12b0		       a5 53		      lda	R0+1
    723  12b2		       9d db 0f 	      sta	TOKENBUFFER,x
    724  12b5		       e8		      inx
    725  12b6		       18		      clc
    726  12b7		       60		      rts
    727  12b8							;=========================================================================
    728  12b8							; Transfer word in Token Buffer to R0
    729  12b8				   TOKEN2R0
    730  12b8		       b9 db 0f 	      lda	TOKENBUFFER,y
    731  12bb		       85 52		      sta	R0
    732  12bd		       c8		      iny
    733  12be		       ca		      dex
    734  12bf		       b9 db 0f 	      lda	TOKENBUFFER,y
    735  12c2		       c8		      iny
    736  12c3		       ca		      dex
    737  12c4		       85 53		      sta	R0+1
    738  12c6		       60		      rts
    739  12c7							;==========================================================================
    740  12c7							; Transfer	Display Buffer position to R0
    741  12c7							;
    742  12c7				   DPL2R0
    743  12c7		       b1 59		      lda	(dpl),y
    744  12c9		       85 52		      sta	R0
    745  12cb		       c8		      iny
    746  12cc		       ca		      dex
    747  12cd		       b1 59		      lda	(dpl),y
    748  12cf		       c8		      iny
    749  12d0		       ca		      dex
    750  12d1		       85 53		      sta	R0+1
    751  12d3		       60		      rts
    752  12d4
    753  12d4
    754  12d4							;=========================================================================
    755  12d4							; Read an IL byte lookit up in the table, of words
    756  12d4							; set the next ilpc to point to that address
    757  12d4							; if not found then do ussual filter stuff
    758  12d4							; ongoto ilvectortable, not found address
    759  12d4		       20 24 1b    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    760  12d7		       86 52		      stx	R0
    761  12d9		       85 53		      sta	R0+1
    762  12db
    763  12db		       a4 51		      ldy	CUROFF
    764  12dd		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    765  12df		       a0 00		      ldy	#0
    766  12e1		       38		      sec
    767  12e2		       f1 52		      sbc	(R0),y	; Subract the base value
    768  12e4		       c8		      iny
    769  12e5		       d1 52		      cmp	(R0),y	; Check if we are in range
    770  12e7		       b0 12		      bcs	iOnGotoInvalid
    771  12e9		       e6 51		      inc	CUROFF	; Save the offset
    772  12eb
    773  12eb		       0a		      asl
    774  12ec		       a8		      tay		; Turn into vector
    775  12ed		       c8		      iny		; Inc must include the table base and entry count
    776  12ee		       c8		      iny
    777  12ef
    778  12ef		       b1 52		      lda	(R0),y
    779  12f1		       85 43		      sta	ILPC
    780  12f3		       c8		      iny
    781  12f4		       b1 52		      lda	(R0),y
    782  12f6		       85 44		      sta	ILPC+1
    783  12f8		       4c c2 02 	      jmp	NextIL
    784  12fb
    785  12fb				   iOnGotoInvalid
    786  12fb		       20 24 1b 	      jsr	getILWord
    787  12fe		       86 43		      stx	ILPC
    788  1300		       85 44		      sta	ILPC+1
    789  1302		       4c c2 02 	      jmp	NextIL
    790  1305							;
    791  1305							;==========================================================================================
    792  1305							; Test the token for relop and push the value onto the stack if true
    793  1305							;
    794  1305				   iTSTRELOP
    795  1305		       20 28 1b 	      jsr	getILByte
    796  1308		       8d c0 2f 	      sta	offset
    797  130b
    798  130b		       a4 51		      ldy	CUROFF
    799  130d		       b1 4f		      lda	(CURPTR),y
    800  130f		       48		      pha
    801  1310		       29 f0		      and	#$F0
    802  1312		       c9 f0		      cmp	#$F0
    803  1314		       d0 12		      bne	iTSTRELOPNOT
    804  1316		       68		      pla
    805  1317		       29 0f		      and	#$0F	; get the actual value
    806  1319		       85 52		      sta	R0	; save it for later
    807  131b		       a9 00		      lda	#0
    808  131d		       85 53		      sta	R0+1
    809  131f		       20 21 1d 	      jsr	pushR0
    810  1322		       c8		      iny
    811  1323		       84 51		      sty	CUROFF	; save the y pointer
    812  1325		       4c c2 02 	      jmp	NextIL
    813  1328
    814  1328				   iTSTRELOPNOT
    815  1328		       68		      pla
    816  1329		       4c a5 0b 	      jmp	tstBranch
    817  132c
    818  132c							;
    819  132c							;===================================================================================================
    820  132c							; Test the token and following info for precompiled address information
    821  132c							; skip it if zero, transfer and skip next integer value if not zero
    822  132c							; used by both gosub, goto and gofN
    823  132c							;
    824  132c				   iTSTBRANCH
    825  132c		       20 28 1b 	      jsr	getILByte	; Get jump address if vector is valid
    826  132f		       8d c0 2f 	      sta	offset	; Mark offset for later if vector found
    827  1332		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    828  1334		       88		      dey		; point back to the type of branch
    829  1335		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    830  1337		       48		      pha		; Save till needed
    831  1338		       c8		      iny		; back to memory vectors
    832  1339				   ITSTBRANCHCont
    833  1339		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    834  133b		       85 52		      sta	R0	; R0 will contain mem pointer of present
    835  133d		       c8		      iny		; Point to next byte of mem vector
    836  133e		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    837  1340		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    838  1342		       c8		      iny		; Point to the byte past memory vector
    839  1343		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    840  1345
    841  1345		       05 52		      ora	R0	; Get the second byte of the mem
    842  1347		       f0 21		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    843  1349		       68		      pla
    844  134a		       c9 29		      cmp	#kTask	; Task defied with Task() so bypass the first bracket
    845  134c		       d0 07		      bne	iTSTBRANCHCont
    846  134e		       b1 4f		      lda	(CURPTR),y
    847  1350		       c9 e0		      cmp	#oLeftBracket
    848  1352		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    849  1354		       c8		      iny		; Increment past the bracket
    850  1355				   iTSTBRANCHCont
    851  1355		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    852  1357		       c9 a2		      cmp	#tByte	; A byte value is valid
    853  1359		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    854  135b		       c9 a1		      cmp	#tInteger	; An integer value is valid
    855  135d		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    856  135f		       c8		      iny		; skip type indicator for
    857  1360				   ITSTBRANCHBYTE
    858  1360		       c8		      iny		; skip first byte of value line number
    859  1361		       c8		      iny		; Skip second byte of line number
    860  1362
    861  1362				   iTSTBRANCHVALID
    862  1362		       84 51		      sty	CUROFF
    863  1364		       20 21 1d 	      jsr	pushR0	; place transfer address on top of stack
    864  1367		       4c a5 0b 	      jmp	tstBranch
    865  136a
    866  136a				   iTSTBRANCHNoCompile
    867  136a		       68		      pla
    868  136b				   iTSTBRANCHErr
    869  136b		       4c c2 02 	      jmp	NextIL
    870  136e
    871  136e
    872  136e
    873  136e
    874  136e
    875  136e
    876  136e
    877  136e
    878  136e
    879  136e
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  136e					      include	"print.asm"
      1  136e					      Seg	Code
      2  136e							;---------------------------
      3  136e							; Print 24-bit decimal number or  16bit unsigned
      4  136e							; ---------------------------
      5  136e							; On entry, R0=number to print
      6  136e							;	     Defaults to pad=0 , y=21 default
      7  136e							;	     R2 = 1 unsigned 16 bit
      8  136e							;	     R2 = 0 Signed   16 bit
      9  136e
     10  136e							; On entry at PrintDecPadded:
     11  136e							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  136e
     13  136e							; On exit,  A,X,Y,num,pad corrupted
     14  136e							; Size      129 bytes, Table 24 bytes	--- total 153
     15  136e							; -----------------------------------------------------------------
     16  136e
     17  136e				   PrintDecimal
     18  136e		       8a		      TXA
     19  136f		       48		      pha
     20  1370		       98		      tya
     21  1371		       48		      pha
     22  1372		       a9 00		      lda	#0
     23  1374		       8d 07 14 	      sta	pad
     24  1377		       a0 15		      LDY	#21	; Offset to powers of ten
     25  1379		       4c 7f 13 	      JMP	PrintDo
     26  137c
     27  137c				   PrintDecPadded
     28  137c		       8e 07 14 	      stx	pad
     29  137f
     30  137f				   PrintDo
     31  137f		       a9 00		      lda	#0
     32  1381		       85 54		      sta	R1
     33  1383
     34  1383		       a5 58		      lda	R2
     35  1385		       d0 29		      bne	PrintPos
     36  1387
     37  1387		       a5 53		      lda	R0+1	;MSB has sign
     38  1389		       10 25		      bpl	PrintPos	;it's a positive number;
     39  138b
     40  138b
     41  138b							; Negative numbers need more work.  Invert all the bits,
     42  138b							; then add one.
     43  138b
     44  138b		       a9 2d		      lda	#'-
     45  138d		       20 ba 1f 	      jsr	VOUTCH	;print the negative sign
     46  1390
     47  1390		       a9 ff		      lda	#$FF
     48  1392		       85 54		      sta	R1
     49  1394		       a5 52		      lda	R0	;invert bits
     50  1396		       49 ff		      eor	#$ff
     51  1398		       85 52		      sta	R0
     52  139a		       a5 53		      lda	R0+1
     53  139c		       49 ff		      eor	#$ff
     54  139e		       85 53		      sta	R0+1
     55  13a0		       a5 54		      lda	R1
     56  13a2		       49 ff		      eor	#$ff
     57  13a4		       85 54		      sta	R1
     58  13a6		       e6 52		      inc	R0	;add one
     59  13a8		       d0 06		      bne	PrintPos
     60  13aa		       e6 53		      inc	R0+1
     61  13ac		       d0 02		      bne	PrintPos
     62  13ae		       e6 54		      inc	R1
     63  13b0				   PrintPos
     64  13b0
     65  13b0				   PrDec24Lp1
     66  13b0		       a2 ff		      LDX	#$FF
     67  13b2		       38		      SEC		; Start with digit=-1
     68  13b3				   PrDec24Lp2
     69  13b3		       a5 52		      LDA	R0+0
     70  13b5		       f9 08 14 	      SBC	PrDec24Tens+0,Y
     71  13b8		       85 52		      STA	R0+0	; Subtract current tens
     72  13ba		       a5 53		      LDA	R0+1
     73  13bc		       f9 09 14 	      SBC	PrDec24Tens+1,Y
     74  13bf		       85 53		      STA	R0+1
     75  13c1		       a5 54		      LDA	R0+2
     76  13c3		       f9 0a 14 	      SBC	PrDec24Tens+2,Y
     77  13c6		       85 54		      STA	R0+2
     78  13c8		       e8		      INX
     79  13c9		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  13cb		       a5 52		      LDA	R0+0
     81  13cd		       79 08 14 	      ADC	PrDec24Tens+0,Y
     82  13d0		       85 52		      STA	R0+0	; Add current tens back in
     83  13d2		       a5 53		      LDA	R0+1
     84  13d4		       79 09 14 	      ADC	PrDec24Tens+1,Y
     85  13d7		       85 53		      STA	R0+1
     86  13d9		       a5 54		      LDA	R0+2
     87  13db		       79 0a 14 	      ADC	PrDec24Tens+2,Y
     88  13de		       85 54		      STA	R0+2
     89  13e0		       8a		      TXA
     90  13e1		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  13e3		       ad 07 14 	      LDA	pad
     92  13e6		       d0 09		      BNE	PrDec24Print
     93  13e8		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  13ea				   PrDec24Digit
     95  13ea		       a2 30		      LDX	#'0
     96  13ec		       8e 07 14 	      STX	pad	; No more zero padding
     97  13ef		       09 30		      ORA	#'0	; Print this digit
     98  13f1				   PrDec24Print
     99  13f1		       20 ba 1f 	      JSR	VOUTCH
    100  13f4				   PrDec24Next
    101  13f4		       88		      DEY
    102  13f5		       88		      DEY
    103  13f6		       88		      DEY
    104  13f7		       f0 07		      beq	PrDec24LastDigit
    105  13f9		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  13fb		       68		      pla
    107  13fc		       a8		      tay
    108  13fd		       68		      pla
    109  13fe		       aa		      tax
    110  13ff		       60		      RTS
    111  1400				   PrDec24LastDigit
    112  1400		       a2 30		      LDX	#'0
    113  1402		       8e 07 14 	      STX	pad	; No more zero padding
    114  1405		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  1407
      0  1407				   pad	      db	0
      1  1407		       00		      .byte.b	0
    117  1408
    118  1408				   PrDec24Tens
      0  1408					      dw	1
      1  1408		       01 00		      .word.w	1
      0  140a					      db	(1 / 65536)
      1  140a		       00		      .byte.b	(1 / 65536)
      0  140b					      dw	10
      1  140b		       0a 00		      .word.w	10
      0  140d					      db	(10 / 65536)
      1  140d		       00		      .byte.b	(10 / 65536)
      0  140e					      dw	100
      1  140e		       64 00		      .word.w	100
      0  1410					      db	(100 / 65536)
      1  1410		       00		      .byte.b	(100 / 65536)
      0  1411					      dw	1000
      1  1411		       e8 03		      .word.w	1000
      0  1413					      db	(1000 / 65536)
      1  1413		       00		      .byte.b	(1000 / 65536)
      0  1414					      dw	10000
      1  1414		       10 27		      .word.w	10000
      0  1416					      db	(10000 / 65536)
      1  1416		       00		      .byte.b	(10000 / 65536)
      0  1417					      dw	100000
      1  1417		       a0 86		      .word.w	100000
      0  1419					      db	(100000 / 65536)
      1  1419		       01		      .byte.b	(100000 / 65536)
      0  141a					      dw	1000000
      1  141a		       40 42		      .word.w	1000000
      0  141c					      db	(1000000 / 65536)
      1  141c		       0f		      .byte.b	(1000000 / 65536)
      0  141d					      dw	10000000
      1  141d		       80 96		      .word.w	10000000
      0  141f					      db	(10000000 / 65536)
      1  141f		       98		      .byte.b	(10000000 / 65536)
    135  1420							;=====================================================
    136  1420							; Print character in A as two hex digits to the Console
    137  1420
    138  1420		       48	   HexToOut   pha		;save return value
    139  1421		       48		      pha
    140  1422		       4a		      lsr		;a  ;move top nibble to bottom
    141  1423		       4a		      lsr		;a
    142  1424		       4a		      lsr		;a
    143  1425		       4a		      lsr		;a
    144  1426		       20 2f 14 	      jsr	hexta	;output nibble
    145  1429		       68		      pla
    146  142a		       20 2f 14 	      jsr	hexta
    147  142d		       68		      pla		;restore
    148  142e		       60		      rts
    149  142f							;
    150  142f		       29 0f	   hexta      and	#%0001111
    151  1431		       c9 0a		      cmp	#$0a
    152  1433		       18		      clc
    153  1434		       30 02		      bmi	hexta1
    154  1436		       69 07		      adc	#7
    155  1438		       69 30	   hexta1     adc	#'0	;then fall into...
    156  143a		       4c ba 1f 	      jmp	VOUTCH
    157  143d							;
    158  143d							;=====================================================
    159  143d							; Print the string that immediately follows the JSR to
    160  143d							; this function.  Stops when a null byte is found,
    161  143d							; then returns to the instruction immediately
    162  143d							; following the null.
    163  143d							;
    164  143d							; Thanks to Ross Archer for this code.
    165  143d							; http://www.6502.org/source/io/primm.htm
    166  143d							;
    167  143d
    168  143d		       68	   tbputs     pla		;Get the low part of "return" address
    169  143e							;(data start address)
    170  143e		       85 5e		      sta	PrtFrom
    171  1440		       68		      pla
    172  1441		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    173  1443							;(data start address)
    174  1443							;Note: actually we're pointing one short
    175  1443		       a0 01	   PSINB      ldy	#1
    176  1445		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    177  1447		       e6 5e		      inc	PrtFrom	;update the pointer
    178  1449		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    179  144b		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    180  144d		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    181  144f							;   Accumulator
    182  144f		       f0 06		      beq	PSIX1	;don't print the final NULL
    183  1451		       20 ba 1f 	      jsr	VOUTCH	;write it out
    184  1454		       4c 43 14 	      jmp	PSINB	;back around
    185  1457		       e6 5e	   PSIX1      inc	PrtFrom
    186  1459		       d0 02		      bne	PSIX2
    187  145b		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    188  145d		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    189  1460
    190  1460							;+
    191  1460							;====================================================
    192  1460		       2f bc	   PrtTerm    equ	tempy
    193  1460
    194  1460							; on exit Print Y has the offset to use
    195  1460							; input y =	 addr low
    196  1460							;	 x =	 addr high
    197  1460							;	 a =	 termination string
    198  1460
    199  1460
    200  1460				   PrtQuoted		; Print a quoted string from the current program space
    201  1460		       a9 22		      lda	#'"
    202  1462		       a4 51		      ldy	CUROFF
    203  1464		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    204  1466		       d0 03		      bne	PrtNoInc
    205  1468		       c8		      iny
    206  1469		       84 51		      sty	CUROFF
    207  146b				   PrtNoInc
    208  146b		       8d bc 2f 	      sta	PrtTerm
    209  146e
    210  146e				   PrtPrgString 		; Print a terminated string from the static program space
    211  146e		       a4 51		      ldy	CUROFF
    212  1470		       a5 4f		      lda	CURPTR
    213  1472		       85 5e		      sta	PrtFrom
    214  1474		       a5 50		      lda	CURPTR+1
    215  1476		       85 5f		      sta	PrtFrom+1
    216  1478		       4c 84 14 	      jmp	PrtLoop
    217  147b
    218  147b							; Print a string pointed to by x= h, y=l terminated by a
    219  147b							; Return y as the length
    220  147b
    221  147b		       86 5f	   PrtStr     stx	PrtFrom+1
    222  147d		       84 5e		      sty	PrtFrom
    223  147f		       8d bc 2f 	      sta	PrtTerm
    224  1482		       a0 00		      ldy	#0
    225  1484							;
    226  1484							; On entry here ptrfrom and prtterm point to area to print
    227  1484							;
    228  1484		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    229  1486		       cd bc 2f 	      cmp	PrtTerm
    230  1489		       f0 0b		      beq	PrtEnd
    231  148b		       c9 00		      cmp	#0	; always end if 0 is found
    232  148d		       f0 07		      beq	PrtEnd
    233  148f		       20 ba 1f 	      jsr	VOUTCH
    234  1492		       c8		      iny
    235  1493		       4c 84 14 	      jmp	PrtLoop
    236  1496		       c8	   PrtEnd     iny		;return byte after the copy
    237  1497		       60		      rts
    238  1498
    239  1498							;
    240  1498							;=======================================================
    241  1498							; Print all Variables
    242  1498				   PrintAllVars
    243  1498		       a0 00		      ldy	#0
    244  149a		       a9 41		      lda	#'A
    245  149c				   PrintAllVarsLoop
    246  149c		       48		      pha
    247  149d		       b1 41		      lda	(VARIABLES),y
    248  149f		       85 52		      sta	R0
    249  14a1		       c8		      iny
    250  14a2		       b1 41		      lda	(VARIABLES),y
    251  14a4		       85 53		      sta	R0+1
    252  14a6
    253  14a6		       68		      pla		;get the current letter
    254  14a7		       48		      pha
    255  14a8		       20 ba 1f 	      jsr	VOUTCH
    256  14ab		       20 3d 14 	      jsr	puts
      0  14ae					      db	"=",0
      1  14ae		       3d 00		      .byte.b	"=",0
    258  14b0		       68		      pla
    259  14b1		       aa		      tax
    260  14b2		       e8		      inx
    261  14b3		       8a		      txa
    262  14b4		       48		      pha		;
    263  14b5
    264  14b5		       98		      tya
    265  14b6		       48		      pha
    266  14b7		       20 6e 13 	      jsr	PrintDecimal
    267  14ba		       20 3d 14 	      jsr	puts
      0  14bd					      db	" ",0
      1  14bd		       20 00		      .byte.b	" ",0
    269  14bf		       68		      pla
    270  14c0		       a8		      tay
    271  14c1		       c8		      iny
    272  14c2		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    273  14c4		       90 d6		      bcc	PrintAllVarsLoop
    274  14c6		       20 6c 1e 	      jsr	CRLF
    275  14c9
    276  14c9		       68		      pla
    277  14ca		       60		      rts
    278  14cb							;==========================================================================================================
    279  14cb							;Debug   Print a Program Line from compile buffer
    280  14cb							;
    281  14cb				   DebugPrintProgramLine
    282  14cb		       48		      pha
    283  14cc		       a9 db		      lda	#TOKENBUFFER&$FF
    284  14ce		       85 59		      sta	dpl
    285  14d0		       a9 0f		      lda	#TOKENBUFFER>>8
    286  14d2		       85 5a		      sta	dpl+1
    287  14d4		       68		      pla
    288  14d5
    289  14d5							; Decode and print a line of program text
    290  14d5							; on entry	 dpl points to line of code to print
    291  14d5							; on exit	 no change in reg or dpl
    292  14d5							;
    293  14d5				   PrintProgramLine
    294  14d5
    295  14d5		       8e db 10 	      stx	printStorage
    296  14d8		       8c dc 10 	      sty	printStorage+1
    297  14db		       48		      pha
    298  14dc
    299  14dc		       a0 01		      ldy	#1	; index into the token buffer
    300  14de		       84 58		      sty	R2	; print unsigned decimal
    301  14e0		       a0 00		      ldy	#0
    302  14e2		       b1 59		      lda	(dpl),y	; get number of bytes
    303  14e4		       aa		      tax		; place pointer into x
    304  14e5		       c8		      iny
    305  14e6		       ca		      dex		; Deduct the length byte
    306  14e7		       20 c7 12 	      jsr	DPL2R0	; Print the line number
    307  14ea		       20 6e 13 	      jsr	PrintDecimal
    308  14ed		       a9 20		      lda	#$20
    309  14ef		       20 ba 1f 	      jsr	VOUTCH
    310  14f2
    311  14f2				   PrintProgLoop
    312  14f2		       b1 59		      lda	(dpl),y	; Get a character
    313  14f4		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    314  14f6		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    315  14f8		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    316  14fa
    317  14fa				   PrintProgVars
    318  14fa		       b1 59		      lda	(dpl),y
    319  14fc		       29 e0		      and	#$E0	; Check for operators and punctuation
    320  14fe		       c9 e0		      cmp	#$E0
    321  1500		       f0 6b		      beq	PrintProgOperatorVect
    322  1502
    323  1502		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    324  1504		       c9 9e		      cmp	#$9D+1
    325  1506		       90 62		      bcc	PrintProgVariableVec
    326  1508		       29 a0		      and	#$A0	; Check for a valid datatype
    327  150a		       c9 a0		      cmp	#$A0
    328  150c		       f0 06		      beq	PrintDataType	; if not just print the character
    329  150e		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    330  1510		       ca		      dex		; Ok we are processing it
    331  1511		       c8		      iny
    332  1512		       d0 25		      bne	PrintContinue	; Print and do the next character
    333  1514
    334  1514				   PrintDataType
    335  1514		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    336  1516		       c9 a0		      cmp	#tString
    337  1518		       f0 31		      beq	PrintStringVariable
    338  151a
    339  151a				   PrintProgNumber
    340  151a		       c8		      iny		; we have a numerical integer value
    341  151b		       ca		      dex
    342  151c		       48		      pha
    343  151d		       a9 00		      lda	#0
    344  151f		       85 53		      sta	R0+1
    345  1521		       85 58		      sta	R2	; Set to print signed number
    346  1523		       b1 59		      lda	(dpl),y
    347  1525		       85 52		      sta	R0
    348  1527		       68		      pla
    349  1528		       c9 a1		      cmp	#tInteger
    350  152a		       d0 06		      bne	PrintProgNumDone
    351  152c		       c8		      iny
    352  152d		       ca		      dex
    353  152e		       b1 59		      lda	(dpl),y
    354  1530		       85 53		      sta	R0+1
    355  1532
    356  1532				   PrintProgNumDone
    357  1532		       c8		      iny
    358  1533		       ca		      dex
    359  1534		       20 6e 13 	      jsr	PrintDecimal
    360  1537
    361  1537				   PrintProgNext
    362  1537		       a9 20		      lda	#$20
    363  1539				   PrintContinue
    364  1539		       20 ba 1f 	      jsr	VOUTCH
    365  153c				   PrintProgSkipSpace
    366  153c		       e0 00		      cpx	#0
    367  153e		       d0 b2		      bne	PrintProgLoop
    368  1540				   PrintProgramComplete
    369  1540		       20 6c 1e 	      jsr	CRLF
    370  1543
    371  1543		       ae db 10 	      ldx	printStorage
    372  1546		       ac dc 10 	      ldy	printStorage+1
    373  1549		       68		      pla
    374  154a
    375  154a		       60		      rts
    376  154b							;=================================================================================================================
    377  154b							; Print a string variable including the quotes
    378  154b							; On Input	 y is offset into buffer
    379  154b							; On Exit	 y is updated to new offset
    380  154b
    381  154b				   PrintStringVariable
    382  154b		       c8		      iny
    383  154c		       a9 22		      lda	#'"
    384  154e		       20 ba 1f 	      jsr	VOUTCH
    385  1551		       c8		      iny
    386  1552		       a5 59		      lda	dpl
    387  1554		       85 5e		      sta	PrtFrom
    388  1556		       a5 5a		      lda	dpl+1
    389  1558		       85 5f		      sta	PrtFrom+1
    390  155a		       a9 22		      lda	#'"
    391  155c		       8d bc 2f 	      sta	PrtTerm
    392  155f		       20 84 14 	      jsr	PrtLoop
    393  1562		       a9 22		      lda	#'"
    394  1564		       20 ba 1f 	      jsr	VOUTCH
    395  1567		       4c 37 15 	      jmp	PrintProgNext
    396  156a
    397  156a				   PrintProgVariableVec
    398  156a		       4c 0a 16 	      jmp	PrintProgVariable
    399  156d
    400  156d				   PrintProgOperatorVect
    401  156d		       4c e1 15 	      jmp	PrintProgOperator
    402  1570							;===============================================================================================================
    403  1570							; On entry dpl points to the buffer we are printing from
    404  1570							;	    y	current offset into the dpl buffer
    405  1570							; all registers preserved
    406  1570							;
    407  1570				   PrintKeyword
    408  1570
    409  1570		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    410  1572		       85 52		      sta	R0	; The value we are looking for
    411  1574		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    412  1576		       f0 0c		      beq	PrintKeyBranch
    413  1578		       c9 08		      cmp	#kGosub
    414  157a		       f0 08		      beq	PrintKeyBranch
    415  157c		       c9 29		      cmp	#kTask
    416  157e		       f0 04		      beq	PrintKeyBranch
    417  1580		       c9 31		      cmp	#kGofn
    418  1582		       d0 04		      bne	PrintKeySkipped
    419  1584				   PrintKeyBranch
    420  1584		       c8		      iny		; Skip the compiled memory address
    421  1585		       c8		      iny
    422  1586		       ca		      dex		; Change number of bytes to print
    423  1587		       ca		      dex		; Remove the bytes to print
    424  1588
    425  1588				   PrintKeySkipped
    426  1588		       c8		      iny		; Inc y to point to the next char to be printed
    427  1589		       ca		      dex		; Reduce number of bytes to print
    428  158a		       98		      tya		; Save y and x for the return
    429  158b		       48		      pha
    430  158c		       8a		      txa
    431  158d		       48		      pha
    432  158e
    433  158e		       a9 d6		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    434  1590		       85 54		      sta	R1
    435  1592		       a9 0e		      lda	#KeyWordTable>>8
    436  1594		       85 55		      sta	R1+1
    437  1596
    438  1596
    439  1596				   PrintKeyLoop
    440  1596		       a0 00		      ldy	#0	; Index into the keyword entry
    441  1598		       b1 54		      lda	(R1),y	; Get token value for this entry
    442  159a		       c8		      iny		; Point to first byte of key
    443  159b		       c5 52		      cmp	R0	; Compare to the token we are looking for
    444  159d		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    445  159f
    446  159f				   PrintKeyNext
    447  159f		       b1 54		      lda	(R1),y	; Get key letter
    448  15a1		       c8		      iny		; Point to next byte always
    449  15a2		       29 20		      and	#%00100000	; Check for last character in key work
    450  15a4		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    451  15a6
    452  15a6		       98		      tya		; Trabsfer y to a for the addition
    453  15a7		       18		      clc		; Table > 256 bytes
    454  15a8		       65 54		      adc	R1
    455  15aa		       85 54		      sta	R1
    456  15ac		       a9 00		      lda	#0
    457  15ae		       65 55		      adc	R1+1
    458  15b0		       85 55		      sta	R1+1
    459  15b2		       4c 96 15 	      jmp	PrintKeyLoop
    460  15b5
    461  15b5				   PrintKeyFound
    462  15b5		       b1 54		      lda	(R1),y	; letter from key table
    463  15b7		       48		      pha		; Save it for later check
    464  15b8		       09 20		      ora	#%00100000	; Force it to lower case
    465  15ba		       20 ba 1f 	      jsr	VOUTCH	; Print it out
    466  15bd		       c8		      iny		; Point to next character
    467  15be		       68		      pla		; Restore the value
    468  15bf		       29 20		      and	#%00100000	; Check if it was last char in keyword
    469  15c1		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    470  15c3
    471  15c3		       68		      pla		; Restore the x and y values
    472  15c4		       aa		      tax
    473  15c5		       68		      pla
    474  15c6		       a8		      tay
    475  15c7
    476  15c7				   PrintChkRem
    477  15c7		       a9 0a		      lda	#kRem
    478  15c9		       c5 52		      cmp	R0
    479  15cb		       d0 11		      bne	PrintKeyDone
    480  15cd				   PrintKeyRem
    481  15cd		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    482  15cf		       85 5e		      sta	PrtFrom
    483  15d1		       a5 5a		      lda	dpl+1
    484  15d3		       85 5f		      sta	PrtFrom+1
    485  15d5		       a9 00		      lda	#0
    486  15d7		       8d bc 2f 	      sta	PrtTerm
    487  15da		       20 84 14 	      jsr	PrtLoop
    488  15dd		       88		      dey		; point back to the terminating null value
    489  15de				   PrintKeyDone
    490  15de		       4c 37 15 	      jmp	PrintProgNext
    491  15e1							;==================================================================================================================
    492  15e1							;Print Variable, number or operator
    493  15e1				   PrintProgOperator
    494  15e1		       b1 59		      lda	(dpl),y
    495  15e3		       c8		      iny
    496  15e4		       ca		      dex
    497  15e5		       8e dd 10 	      stx	printStorage+2
    498  15e8		       a2 00		      ldx	#0
    499  15ea				   PrintOprLoop
    500  15ea		       dd c0 0e 	      cmp	OperValues,x
    501  15ed		       f0 03		      beq	PrintOprFound
    502  15ef		       e8		      inx
    503  15f0		       d0 f8		      bne	PrintOprLoop
    504  15f2				   PrintOprFound
    505  15f2		       8a		      txa
    506  15f3		       0a		      asl
    507  15f4		       aa		      tax
    508  15f5		       bd 92 0e 	      lda	Operators,x
    509  15f8		       20 ba 1f 	      jsr	VOUTCH
    510  15fb		       e8		      inx
    511  15fc		       bd 92 0e 	      lda	Operators,x
    512  15ff		       f0 03		      beq	PrintOprDone
    513  1601		       20 ba 1f 	      jsr	VOUTCH
    514  1604				   PrintOprDone
    515  1604		       ae dd 10 	      ldx	printStorage+2
    516  1607		       4c 37 15 	      jmp	PrintProgNext
    517  160a
    518  160a							;=================================================================================================================
    519  160a							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    520  160a							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    521  160a							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    522  160a							;tVhat 	    equ     155 		   ; Variable ^
    523  160a							;tVhash	    equ     156 		   ; Variable #
    524  160a							;tVat		    equ     157 		   ; Variable @ = 0
    525  160a				   PrintProgVariable
    526  160a		       b1 59		      lda	(dpl),y
    527  160c		       c8		      iny
    528  160d		       ca		      dex
    529  160e		       c9 9b		      cmp	#tVhat
    530  1610		       d0 04		      bne	PrintProgChkHash
    531  1612		       a9 5e		      lda	#'^
    532  1614		       d0 15		      bne	PrintTheVar
    533  1616				   PrintProgChkHash
    534  1616		       c9 9c		      cmp	#tVhash
    535  1618		       d0 04		      bne	PrintProgChkAt
    536  161a		       a9 23		      lda	#'#
    537  161c		       d0 0d		      bne	PrintTheVar
    538  161e				   PrintProgChkAt
    539  161e		       c9 9d		      cmp	#tVat
    540  1620		       d0 04		      bne	PrintProgVarLetter
    541  1622		       a9 40		      lda	#'@
    542  1624		       d0 05		      bne	PrintTheVar
    543  1626				   PrintProgVarLetter
    544  1626		       29 7f		      and	#%01111111
    545  1628		       18		      clc
    546  1629		       69 41		      adc	#'A
    547  162b				   PrintTheVar
    548  162b		       20 ba 1f 	      jsr	VOUTCH
    549  162e		       4c 37 15 	      jmp	PrintProgNext
    550  1631
    551  1631
    552  1631							;==================================================================================================
    553  1631							; Size of print functions
    554  1631		       02 c3	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  1631					      include	"mem.asm"
      1  1631							;===================================================================
      2  1631							;This file contains the memory allocation and free functions
      3  1631							;in herant in this is the management of free memory in the system
      4  1631							; the interface to these functions
      5  1631							; a,x returns or provides the low hi bytes of the managed addresses
      6  1631							; This uses the programend, to memory end as the area to manage
      7  1631							;===================================================================
      8  1631					      Seg	Code
      9  1631							;=====================================================
     10  1631							;Pointers for memory Management
     11  1631							;Allocated block are not chained but can be followed for all memory by the associated length
     12  1631							; Mem block format is
     13  1631							;	 0-1   pointer to next block for free blocks
     14  1631							;	 0-1   for allocated blocks
     15  1631							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  1631							;	   1   refrence counter ... lol only up to 256 but it is something
     17  1631							;	 2-3   length constant for exevy type of memory block
     18  1631							; Memory is recombined as it is released
     19  1631							; The memory manager is not interupted durring allocation
     20  1631							; or freeing of memory
     21  1631							; Memory is allocated from the highest memory address towards
     22  1631							; the lowest memory address. meeting the Basic program end.
     23  1631							;====================================================
     24  1631							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  1631							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  1631							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  1631							;=====================================================
     28  1631				   MemInit
     29  1631		       a9 ce		      lda	#FreeMemStart&$FF
     30  1633		       8d c4 2f 	      sta	ProgramStart
     31  1636		       8d c6 2f 	      sta	ProgramEnd
     32  1639		       a9 2f		      lda	#FreeMemStart>>8
     33  163b		       8d c5 2f 	      sta	ProgramStart+1
     34  163e		       8d c7 2f 	      sta	ProgramEnd+1
     35  1641
     36  1641		       20 4b 16 	      jsr	GetSizes
     37  1644		       20 56 16 	      jsr	MemFree
     38  1647		       20 6e 16 	      jsr	MemUsed
     39  164a				   MemInitEnd
     40  164a		       60		      rts
     41  164b
     42  164b
     43  164b							;
     44  164b							;=====================================================
     45  164b							; This function might go away eventually, but was
     46  164b							; added to provide data for other pieces of code.
     47  164b							; It has some ties to the operating environment that
     48  164b							; will need to be customized for the target system.
     49  164b							;
     50  164b				   GetSizes
     51  164b							;
     52  164b							; Here is machine specific code to get the highest
     53  164b							; memory location that can be used by BASIC.
     54  164b							;
     55  164b				  -	      if	ProgramStart < $2000
     56  164b				  -	      lda	#$ff
     57  164b				  -	      sta	HighMem	;$13ff for KIM-1
     58  164b				  -	      sta	MemFreeList
     59  164b				  -	      lda	#$DE	;#$13
     60  164b				  -	      sta	HighMem+1
     61  164b				  -	      sta	MemFreeList+1
     62  164b					      else
     63  164b		       a9 ff		      lda	#$ff
     64  164d		       8d c8 2f 	      sta	HighMem	;$CFFF otherwise
     65  1650		       a9 cf		      lda	#$cf
     66  1652		       8d c9 2f 	      sta	HighMem+1
     67  1655					      endif
     68  1655		       60		      rts
     69  1656							;
     70  1656							; This computes the available memory remaining.
     71  1656							;
     72  1656				   MemFree
     73  1656		       38		      sec
     74  1657		       ad c8 2f 	      lda	HighMem
     75  165a		       ed c6 2f 	      sbc	ProgramEnd
     76  165d		       8d cc 2f 	      sta	FreeMem
     77  1660		       85 52		      sta	R0
     78  1662		       ad c9 2f 	      lda	HighMem+1
     79  1665		       ed c7 2f 	      sbc	ProgramEnd+1
     80  1668		       8d cd 2f 	      sta	FreeMem+1
     81  166b		       85 53		      sta	R0+1
     82  166d		       60		      rts
     83  166e							;
     84  166e							; This computes the size of the current user program.
     85  166e							;
     86  166e				   MemUsed
     87  166e		       38		      sec
     88  166f		       ad c6 2f 	      lda	ProgramEnd
     89  1672		       ed c4 2f 	      sbc	ProgramStart
     90  1675		       8d ca 2f 	      sta	UsedMem
     91  1678		       85 52		      sta	R0
     92  167a		       ad c7 2f 	      lda	ProgramEnd+1
     93  167d		       ed c5 2f 	      sbc	ProgramStart+1
     94  1680		       8d cb 2f 	      sta	UsedMem+1
     95  1683		       85 53		      sta	R0+1
     96  1685							;
     97  1685		       60		      rts
     98  1686
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  1686					      include	"gosub.asm"
      1  1686					      seg	Code
      2  1686
      3  1686							; Gosub and return related functions
      4  1686							;==========================================================
      5  1686							; Push the current math stack frame onto the gosub stack
      6  1686				   iPushMathStack
      7  1686		       98		      tya
      8  1687		       48		      pha
      9  1688		       a4 4d		      ldy	GOSUBSTACKPTR
     10  168a		       a5 4a		      lda	MATHSTACKPTR
     11  168c		       91 4b		      sta	(GOSUBSTACK),y
     12  168e		       a9 00		      lda	#0
     13  1690		       c8		      iny
     14  1691		       91 4b		      sta	(GOSUBSTACK),y
     15  1693		       c8		      iny
     16  1694		       91 4b		      sta	(GOSUBSTACK),y
     17  1696		       c8		      iny
     18  1697		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  1699		       91 4b		      sta	(GOSUBSTACK),y
     20  169b		       c8		      iny
     21  169c		       84 4d		      sty	GOSUBSTACKPTR
     22  169e		       68		      pla
     23  169f		       a8		      tay
     24  16a0		       4c c2 02 	      jmp	NextIL
     25  16a3							;
     26  16a3							;==========================================================
     27  16a3							; Increment parameter count. Assume Stack frame is top of stack
     28  16a3				   iIncParmCount
     29  16a3		       98		      tya
     30  16a4		       48		      pha
     31  16a5		       a4 4d		      ldy	GOSUBSTACKPTR
     32  16a7		       88		      dey
     33  16a8		       88		      dey
     34  16a9		       88		      dey
     35  16aa		       b1 4b		      lda	(GOSUBSTACK),y
     36  16ac		       aa		      tax
     37  16ad		       e8		      inx
     38  16ae		       8a		      txa
     39  16af		       91 4b		      sta	(GOSUBSTACK),y
     40  16b1		       68		      pla
     41  16b2		       a8		      tay
     42  16b3		       4c c2 02 	      jmp	NextIL
     43  16b6							;
     44  16b6							;==========================================================
     45  16b6							;Restore the math stack frame
     46  16b6		       20 bc 16    iPopMathStack jsr	PopMathStackNow
     47  16b9		       4c c2 02 	      jmp	NextIL
     48  16bc
     49  16bc				   PopMathStackNow
     50  16bc		       98		      tya
     51  16bd		       48		      pha
     52  16be
     53  16be		       a4 4d		      ldy	GOSUBSTACKPTR
     54  16c0		       88		      dey
     55  16c1		       b1 4b		      lda	(GOSUBSTACK),y
     56  16c3		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  16c5		       d0 09		      bne	iPopMathStackNoFrame
     58  16c7		       88		      dey
     59  16c8		       88		      dey
     60  16c9		       88		      dey
     61  16ca		       b1 4b		      lda	(GOSUBSTACK),y
     62  16cc		       85 4a		      sta	MATHSTACKPTR
     63  16ce		       84 4d		      sty	GOSUBSTACKPTR
     64  16d0
     65  16d0				   iPopMathStackNoFrame
     66  16d0
     67  16d0		       68		      pla
     68  16d1		       a8		      tay
     69  16d2		       60		      rts
     70  16d3
     71  16d3
     72  16d3							;==========================================================
     73  16d3							; Push the current math stack information onto the gosub stack
     74  16d3				   iSaveMathStack
     75  16d3		       98		      tya
     76  16d4		       48		      pha
     77  16d5		       a4 4d		      ldy	GOSUBSTACKPTR
     78  16d7		       a5 4a		      lda	MATHSTACKPTR
     79  16d9		       91 4b		      sta	(GOSUBSTACK),y
     80  16db		       a5 48		      lda	MATHSTACK
     81  16dd		       c8		      iny
     82  16de
     83  16de		       91 4b		      sta	(GOSUBSTACK),y
     84  16e0		       c8		      iny
     85  16e1
     86  16e1		       a5 49		      lda	MATHSTACK+1
     87  16e3		       91 4b		      sta	(GOSUBSTACK),y
     88  16e5		       c8		      iny
     89  16e6
     90  16e6		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  16e8		       91 4b		      sta	(GOSUBSTACK),y
     92  16ea		       c8		      iny
     93  16eb
     94  16eb		       84 4d		      sty	GOSUBSTACKPTR
     95  16ed		       68		      pla
     96  16ee		       a8		      tay
     97  16ef		       4c c2 02 	      jmp	NextIL
     98  16f2							;
     99  16f2							;==========================================================
    100  16f2							;Restore the math stack information from the gosub stack
    101  16f2				   iRestoreMathStack
    102  16f2		       98		      tya
    103  16f3		       48		      pha
    104  16f4
    105  16f4		       a5 4a		      lda	MATHSTACKPTR
    106  16f6		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  16f8
    108  16f8		       a4 4d		      ldy	GOSUBSTACKPTR
    109  16fa		       88		      dey
    110  16fb		       b1 4b		      lda	(GOSUBSTACK),y
    111  16fd		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  16ff		       d0 16		      bne	iPopMathStack_Err
    113  1701		       88		      dey
    114  1702		       b1 4b		      lda	(GOSUBSTACK),y
    115  1704		       85 49		      sta	MATHSTACK+1
    116  1706		       88		      dey
    117  1707		       b1 4b		      lda	(GOSUBSTACK),y
    118  1709		       85 48		      sta	MATHSTACK
    119  170b		       88		      dey
    120  170c		       b1 4b		      lda	(GOSUBSTACK),y
    121  170e		       85 4a		      sta	MATHSTACKPTR
    122  1710		       84 4d		      sty	GOSUBSTACKPTR
    123  1712		       68		      pla
    124  1713		       a8		      tay
    125  1714		       4c c2 02 	      jmp	NextIL
    126  1717
    127  1717				   iPopMathStack_Err
    128  1717		       a9 00		      lda	#0
    129  1719		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  171b		       4c a9 06 	      jmp	iErr2
    131  171e							;=========================================
    132  171e							; For functions and tasks the variable address of # means
    133  171e							; a passed parameter so #[0] is the first parameter etc
    134  171e							; will try for a better way later
    135  171e
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  171e					      include	"tasks.asm"
      1  171e							;=====================================================
      2  171e							; Tiny Basic IL task management
      3  171e							; Data required by task management
      4  171e							; currently each context is about 30 bytes and is swapped
      5  171e							; into and out of page zero on each task switch....
      6  171e							; LOL yes it is slow, but works for this iteration.
      7  171e							;
      8  171e
      9  171e					      Seg	Code
     10  171e							;=====================================================
     11  171e							; Sets the pointers to the math,IL and gosub stacks
     12  171e							; Creates the initial Context for each task slot
     13  171e				   taskSetStacks
     14  171e		       a9 6b		      lda	#mathStack&$FF
     15  1720		       85 48		      sta	MATHSTACK
     16  1722		       a9 27		      lda	#mathStack>>8
     17  1724		       85 49		      sta	MATHSTACK+1
     18  1726
     19  1726		       a9 fb		      lda	#ilStack&$ff
     20  1728		       85 45		      sta	ILSTACK
     21  172a		       a9 28		      lda	#ilStack>>8
     22  172c		       85 46		      sta	ILSTACK+1
     23  172e
     24  172e		       a9 8b		      lda	#gosubStack&$FF
     25  1730		       85 4b		      sta	GOSUBSTACK
     26  1732		       a9 2a		      lda	#gosubStack>>8
     27  1734		       85 4c		      sta	GOSUBSTACK+1
     28  1736
     29  1736		       a9 0b		      lda	#variableStack&$FF
     30  1738		       85 41		      sta	VARIABLES
     31  173a		       a9 2d		      lda	#variableStack>>8
     32  173c		       85 42		      sta	VARIABLES+1
     33  173e		       a2 0a		      ldx	#TASKCOUNT
     34  1740		       a0 00		      ldy	#0
     35  1742		       20 df 19 	      jsr	ContextSave
     36  1745
     37  1745		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  1747		       b0 3a		      bcs	taskSetDone
     39  1749
     40  1749		       a5 4b		      lda	GOSUBSTACK
     41  174b		       18		      clc
     42  174c		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  174e		       85 4b		      sta	GOSUBSTACK
     44  1750		       a5 4c		      lda	GOSUBSTACK+1
     45  1752		       69 00		      adc	#0
     46  1754		       85 4c		      sta	GOSUBSTACK+1
     47  1756
     48  1756		       a5 45		      lda	ILSTACK	; must be less than 256
     49  1758		       18		      clc
     50  1759		       69 28		      adc	#ILSTACKSIZE*2
     51  175b		       85 45		      sta	ILSTACK
     52  175d		       a5 46		      lda	ILSTACK+1
     53  175f		       69 00		      adc	#0
     54  1761		       85 46		      sta	ILSTACK+1
     55  1763
     56  1763		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  1765		       18		      clc
     58  1766		       69 28		      adc	#MATHSTACKSIZE*2
     59  1768		       85 48		      sta	MATHSTACK
     60  176a		       a5 49		      lda	MATHSTACK+1
     61  176c		       69 00		      adc	#0
     62  176e		       85 49		      sta	MATHSTACK+1
     63  1770
     64  1770		       a5 41		      lda	VARIABLES	; must be less than 256
     65  1772		       18		      clc
     66  1773		       69 36		      adc	#VARIABLESSIZE*2
     67  1775		       85 41		      sta	VARIABLES
     68  1777		       a5 42		      lda	VARIABLES+1
     69  1779		       69 00		      adc	#0
     70  177b		       85 42		      sta	VARIABLES+1
     71  177d
     72  177d		       20 df 19 	      jsr	ContextSave
     73  1780		       4c 45 17 	      jmp	taskSetLoop
     74  1783
     75  1783				   taskSetDone
     76  1783		       a0 00		      ldy	#0	; reload the main loop context
     77  1785		       20 ee 19 	      jsr	ContextLoad
     78  1788		       60		      rts
     79  1789							;
     80  1789							;=====================================================
     81  1789							; In some error cases the math stacks may be left pointing to the wrong stack
     82  1789							; This function will reset those stack addresses but not the actual pointer
     83  1789				   taskResetStacks
     84  1789		       a0 00		      ldy	#0
     85  178b		       20 ee 19 	      jsr	ContextLoad
     86  178e		       4c 1e 17 	      jmp	taskSetStacks
     87  1791							;
     88  1791							;=====================================================
     89  1791							; Clear all task entries and task stacks
     90  1791		       98	   taskReset  tya		; Save Y
     91  1792		       48		      pha
     92  1793		       a9 01		      lda	#1
     93  1795		       8d 6a 27 	      sta	taskCounter	; Set number of active tasks to 1
     94  1798		       ac 6b 26 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  179b		       c0 00		      cpy	#0	; check if we are the main context
     96  179d		       f0 08		      beq	taskResetCont	; if we are just continue
     97  179f
     98  179f		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  17a1		       8c 6b 26 	      sty	taskPtr
    100  17a4		       20 ee 19 	      jsr	ContextLoad	; load the System Task context
    101  17a7				   taskResetCont
    102  17a7		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    103  17a9
    104  17a9				   taskResetLoop
    105  17a9		       a9 00		      lda	#TASKINACTIVE
    106  17ab		       99 6c 26 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  17ae		       18		      clc
    108  17af		       98		      tya
    109  17b0		       69 19		      adc	#CONTEXTLEN
    110  17b2		       a8		      tay
    111  17b3		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  17b5		       90 f2		      bcc	taskResetLoop	; Go for more
    113  17b7
    114  17b7				   taskResetComplete
    115  17b7
    116  17b7		       68		      pla		; Restore y
    117  17b8		       a8		      tay
    118  17b9		       60		      rts
    119  17ba
    120  17ba							;
    121  17ba							;======================================================
    122  17ba							; iTaskSwitch	 switch to new task if not interrupt and
    123  17ba							;		 count is exceded for task time slice gets here
    124  17ba							;		 when time slice has reached zero
    125  17ba							;
    126  17ba		       98	   iTaskSwitch tya
    127  17bb		       48		      pha
    128  17bc
    129  17bc		       ad 68 27 	      lda	taskResetValue	; Always reset the counter value
    130  17bf		       8d 66 27 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  17c2		       ce 67 27 	      dec	taskCurrentCycles+1	; dec high order byte
    132  17c5		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  17c7
    134  17c7		       ad 69 27 	      lda	taskResetValue+1
    135  17ca		       8d 67 27 	      sta	taskCurrentCycles+1
    136  17cd
    137  17cd		       ad 68 26 	      lda	IRQPending	; Skip this if we are processing an irq
    138  17d0		       0d c2 2f 	      ora	taskIOPending	; If set then don't switch
    139  17d3		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  17d5
    141  17d5		       ad 6a 27    iTaskMain  lda	taskCounter	; Number of tasks
    142  17d8		       c9 01		      cmp	#1	; if there is only one task must be main
    143  17da		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  17dc
    145  17dc		       ac 6b 26 	      ldy	taskPtr	; check if we have not just ended some other task
    146  17df		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  17e1		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  17e3							;
    149  17e3							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  17e3							;
    151  17e3				   itasknext
    152  17e3		       ac 6b 26 	      ldy	taskPtr
    153  17e6		       20 df 19 	      jsr	ContextSave	; Save the current context, y points to next context
    154  17e9				   itaskLoop
    155  17e9		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  17eb		       90 04		      bcc	iTaskNextChk
    157  17ed
    158  17ed		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  17ef		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  17f1
    161  17f1				   iTaskNextChk
    162  17f1		       b9 6c 26 	      lda	taskTable,y	; there is always at least one entry in table
    163  17f4		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  17f6		       18	   iTaskNext  clc
    165  17f7		       98		      tya
    166  17f8		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    167  17fa		       a8		      tay
    168  17fb		       4c e9 17 	      jmp	itaskLoop	; Check for busy entry
    169  17fe
    170  17fe		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  1800		       59 6c 26 	      eor	taskTable,y	; Check for anything waiting io
    172  1803		       d0 f1		      bne	iTaskNext
    173  1805		       20 ee 19 	      jsr	ContextLoad	; load the next context
    174  1808		       8c 6b 26 	      sty	taskPtr	; update the task pointer
    175  180b
    176  180b				   iTaskSwitchDone
    177  180b		       68		      pla
    178  180c		       a8		      tay
    179  180d		       60		      rts
    180  180e							;
    181  180e							;================================================================
    182  180e							; Task Set task number to line number to start
    183  180e							; on entry stack contains, type of line description and  memvector or linenumber
    184  180e							; Task Table structure:
    185  180e							;    byte 0	-   Active inactive
    186  180e							;    byte 1-2	-   Basic code line pointer
    187  180e							;    byte 3	-   Offset on current line
    188  180e		       98	   iTaskSet   tya		;preserve Y
    189  180f		       48		      pha		; push a
    190  1810		       20 cb 1d 	      jsr	popR1	; Get if compiled or line number expression
    191  1813		       20 b3 1d 	      jsr	popR0	; Get the line number to be saved
    192  1816
    193  1816
    194  1816
    195  1816		       ac 6b 26 	      ldy	taskPtr	; find out where we are
    196  1819		       20 df 19 	      jsr	ContextSave	; Save the current context
    197  181c
    198  181c							;Find the pointer to the line we need to start at
    199  181c		       a5 54		      lda	R1
    200  181e		       f0 0b		      beq	iTaskLineNum
    201  1820		       a5 52		      lda	R0
    202  1822		       85 4f		      sta	CURPTR
    203  1824		       a5 53		      lda	R0+1
    204  1826		       85 50		      sta	CURPTR+1
    205  1828		       4c 3b 18 	      jmp	iTaskCont
    206  182b
    207  182b				   iTaskLineNum
    208  182b		       20 6d 1b 	      jsr	findLine	; Get the offset of the line to start task at
    209  182e		       f0 0b		      beq	iTaskCont
    210  1830
    211  1830		       ac 6b 26 	      ldy	taskPtr	; Restore the original Context Error Exit
    212  1833		       20 ee 19 	      jsr	ContextLoad
    213  1836
    214  1836		       68		      pla		; pop a - exit
    215  1837		       a8		      tay
    216  1838		       4c 89 0d 	      jmp	iSetIrqErr	; Bad line number provided
    217  183b
    218  183b				   iTaskCont
    219  183b		       20 b1 19 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    220  183e		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    221  1840
    222  1840		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    223  1842		       99 6c 26 	      sta	taskTable,y	; new task as active
    224  1845
    225  1845		       a5 4f		      lda	CURPTR
    226  1847		       48		      pha		; push a
    227  1848		       a5 50		      lda	CURPTR+1
    228  184a		       48		      pha		; push a
    229  184b
    230  184b		       20 ee 19 	      jsr	ContextLoad	; load the context of the new task
    231  184e
    232  184e		       68		      pla		; pop a
    233  184f		       85 50		      sta	CURPTR+1
    234  1851		       68		      pla		; pop a
    235  1852		       85 4f		      sta	CURPTR
    236  1854		       a9 03		      lda	#3	; Offset to first instruction
    237  1856		       85 51		      sta	CUROFF
    238  1858
    239  1858		       a9 00		      lda	#0
    240  185a		       85 47		      sta	ILSTACKPTR
    241  185c		       85 4a		      sta	MATHSTACKPTR
    242  185e		       85 4d		      sta	GOSUBSTACKPTR
    243  1860		       a9 40		      lda	#GOSUBSTACKSIZE*4
    244  1862		       85 4e		      sta	MESSAGEPTR
    245  1864
    246  1864		       20 64 09 	      jsr	subVINIT	; Clear the variables
    247  1867
    248  1867		       a9 a4		      lda	#STMT&$FF
    249  1869		       85 43		      sta	ILPC
    250  186b		       a9 22		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    251  186d		       85 44		      sta	ILPC+1
    252  186f
    253  186f		       98		      tya		; Save the new context offset to return to user
    254  1870		       48		      pha		; push a
    255  1871
    256  1871		       20 df 19    itaskSetSave jsr	ContextSave	; save the updated context
    257  1874		       ee 6a 27 	      inc	taskCounter	; Update the number of Tasks running
    258  1877
    259  1877		       ac 6b 26 	      ldy	taskPtr
    260  187a		       20 ee 19 	      jsr	ContextLoad	; restore the original context
    261  187d
    262  187d		       a9 00		      lda	#0	; Set the R0 upper to zero
    263  187f		       85 53		      sta	R0+1
    264  1881		       68		      pla		; Get the task pid we stored				 ; pop a
    265  1882		       85 52		      sta	R0	; Get the table entry value
    266  1884
    267  1884		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    268  1885		       a8		      tay
    269  1886
    270  1886		       4c 42 07 	      jmp	pushR0nextIl	; Push R0 and continue
    271  1889				   iTaskNoEmpty
    272  1889		       ac 6b 26 	      ldy	taskPtr
    273  188c		       20 ee 19 	      jsr	ContextLoad
    274  188f
    275  188f		       68		      pla		; pop a    -- exit
    276  1890		       a8		      tay
    277  1891
    278  1891		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    279  1893		       a9 00		      lda	#0
    280  1895		       4c a9 06 	      jmp	iErr2
    281  1898							;
    282  1898							;===============================================================
    283  1898							; Run the task whos PID is on the stack, preserve the stack
    284  1898							;
    285  1898				   iTaskEnable
    286  1898		       98		      tya
    287  1899		       48		      pha
    288  189a		       20 cb 1d 	      jsr	popR1
    289  189d		       20 99 1d 	      jsr	pushR1
    290  18a0		       20 e5 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    291  18a3		       a0 00		      ldy	#0
    292  18a5		       b1 56		      lda	(MQ),y
    293  18a7		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    294  18a9		       09 80		      ora	#TASKACTIVE
    295  18ab		       91 56		      sta	(MQ),y
    296  18ad		       68		      pla
    297  18ae		       a8		      tay
    298  18af		       4c c2 02 	      jmp	NextIL
    299  18b2
    300  18b2							;
    301  18b2							;===============================================================
    302  18b2							; Suspend the task whos PID  is on the stack, preserve the stack
    303  18b2							;
    304  18b2				   iTaskSuspend
    305  18b2		       98		      tya
    306  18b3		       48		      pha
    307  18b4		       20 cb 1d 	      jsr	popR1
    308  18b7		       20 99 1d 	      jsr	pushR1
    309  18ba		       20 e5 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    310  18bd		       a0 00		      ldy	#0
    311  18bf		       b1 56		      lda	(MQ),y
    312  18c1		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    313  18c3		       09 80		      ora	#TASKACTIVE
    314  18c5		       68		      pla
    315  18c6		       a8		      tay
    316  18c7		       4c c2 02 	      jmp	NextIL
    317  18ca
    318  18ca							;================================================================
    319  18ca							; Returns task Status
    320  18ca				   iTaskStat
    321  18ca		       98		      tya
    322  18cb		       48		      pha
    323  18cc		       20 de 18 	      jsr	iTaskValid	; returns pointer to task entry
    324  18cf		       b9 6c 26 	      lda	taskTable,y
    325  18d2		       f0 05		      beq	iTaskStatExit
    326  18d4		       68		      pla
    327  18d5		       a8		      tay
    328  18d6		       4c 43 0d 	      jmp	iTruth
    329  18d9				   iTaskStatExit
    330  18d9		       68		      pla
    331  18da		       a8		      tay
    332  18db		       4c 4c 0d 	      jmp	iFalse
    333  18de
    334  18de							;
    335  18de							;================================================================
    336  18de							; Validate the task number on top of the stack
    337  18de							; on exit y points to the requested task entry
    338  18de							;
    339  18de		       20 b3 1d    iTaskValid jsr	popR0	; get result of the multiply
    340  18e1		       a5 53		      lda	R0+1
    341  18e3		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    342  18e5		       a5 52		      lda	R0
    343  18e7		       c9 fa		      cmp	#TASKTABLELEN
    344  18e9		       90 09		      bcc	iTaskIsValid
    345  18eb
    346  18eb		       68	   iTaskValidErr pla		;remove return address
    347  18ec		       68		      pla
    348  18ed		       a2 10		      ldx	#ERR_INVALID_PID
    349  18ef		       a9 00		      lda	#0
    350  18f1		       4c a9 06 	      jmp	iErr2
    351  18f4
    352  18f4		       a8	   iTaskIsValid tay
    353  18f5		       60		      rts
    354  18f6							;
    355  18f6							;================================================================
    356  18f6							; Kill a running task, do nothing if already stopped
    357  18f6		       20 de 18    iTaskKill  jsr	iTaskValid
    358  18f9		       a9 00		      lda	#0
    359  18fb		       99 6c 26 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    360  18fe							;
    361  18fe							;================================================================
    362  18fe							;Skip to next task
    363  18fe				   iNTask
    364  18fe		       a9 01		      lda	#1
    365  1900		       8d 66 27 	      sta	taskCurrentCycles
    366  1903		       8d 67 27 	      sta	taskCurrentCycles+1
    367  1906		       4c c2 02 	      jmp	NextIL
    368  1909							;
    369  1909							;=======================================================
    370  1909							; Wait for a task to complete
    371  1909				   iWTASK
    372  1909		       20 28 1b 	      jsr	getILByte
    373  190c		       8d c0 2f 	      sta	offset
    374  190f							;
    375  190f		       20 0b 1d 	      jsr	saveIL	;in case of failure
    376  1912
    377  1912		       20 de 18 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    378  1915		       b9 6c 26 	      lda	taskTable,y
    379  1918		       d0 03		      bne	iWTASKWAIT
    380  191a				   iWTASKEXITED
    381  191a		       4c c2 02 	      jmp	NextIL
    382  191d				   iWTASKWAIT
    383  191d		       20 21 1d 	      jsr	pushR0	; Push R0 back onto the stack
    384  1920		       a9 01		      lda	#1
    385  1922		       8d 66 27 	      sta	taskCurrentCycles	; Give up the cycles
    386  1925		       8d 67 27 	      sta	taskCurrentCycles+1
    387  1928		       20 16 1d 	      jsr	restoreIL
    388  192b		       4c a5 0b 	      jmp	tstBranch
    389  192e							;
    390  192e							;=======================================================
    391  192e							; Set task io lock
    392  192e		       ee c2 2f    iStartIO   inc	taskIOPending
    393  1931		       4c c2 02 	      jmp	NextIL
    394  1934							;
    395  1934							;=======================================================
    396  1934							; Release the io lock
    397  1934		       ad c2 2f    iEndIO     lda	taskIOPending
    398  1937		       f0 03		      beq	iEndIOExit
    399  1939		       ce c2 2f 	      dec	taskIOPending
    400  193c		       4c c2 02    iEndIOExit jmp	NextIL
    401  193f							;
    402  193f							;===============================================================
    403  193f							; Return the task PID
    404  193f				   iTASKPID
    405  193f		       a9 00		      lda	#0
    406  1941		       85 53		      sta	R0+1
    407  1943		       ad 6b 26 	      lda	taskPtr
    408  1946		       85 52		      sta	R0
    409  1948		       4c 42 07 	      jmp	pushR0nextIl
    410  194b							;
    411  194b							;================================================================
    412  194b							; Terminate a task
    413  194b		       ac 6b 26    iETask     ldy	taskPtr
    414  194e		       c0 00		      cpy	#0
    415  1950		       d0 03		      bne	iETaskCont
    416  1952		       4c 36 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    417  1955				   iETaskCont
    418  1955		       a9 00		      lda	#TASKINACTIVE
    419  1957		       99 6c 26 	      sta	taskTable,y	; mark entry as free
    420  195a		       ce 6a 27 	      dec	taskCounter	; reduce the number of active tasks
    421  195d		       a9 01		      lda	#1
    422  195f		       8d 66 27 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    423  1962		       8d 67 27 	      sta	taskCurrentCycles+1
    424  1965		       20 cc 19 	      jsr	TaskSetExitCode
    425  1968				   iETaskExit
    426  1968		       4c c2 02 	      jmp	NextIL
    427  196b							;================================================================
    428  196b							; make the current tasks math stack equal another tasks stack
    429  196b							; The task to get is stored on the math stack
    430  196b
    431  196b				   iTaskGetMathStack
    432  196b		       20 d9 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    433  196e		       20 e5 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    434  1971		       a0 0a		      ldy	#MATHSTACKPTRPOS
    435  1973		       b1 56		      lda	(MQ),y
    436  1975		       85 4a		      sta	MATHSTACKPTR
    437  1977		       a0 08		      ldy	#MATHSTACKPOS
    438  1979		       b1 56		      lda	(MQ),y
    439  197b		       85 48		      sta	MATHSTACK
    440  197d		       c8		      iny
    441  197e		       b1 56		      lda	(MQ),y
    442  1980		       85 49		      sta	MATHSTACK+1
    443  1982		       4c c2 02 	      jmp	NextIL
    444  1985							;==================================================================
    445  1985							; Updates the tasks math stack pointer with contents of R2
    446  1985							; PID is on top of the stack
    447  1985				   iTaskPutMathPtr
    448  1985		       20 d9 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    449  1988		       20 e5 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    450  198b		       a5 58		      lda	R2
    451  198d		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  198f		       91 56		      sta	(MQ),y
    453  1991		       4c c2 02 	      jmp	NextIL
    454  1994							;
    455  1994							;================================================================
    456  1994							; Set the time slice for each task
    457  1994				   iSLICE
    458  1994		       20 b3 1d 	      jsr	popR0
    459  1997		       a5 52		      lda	R0
    460  1999		       8d 68 27 	      sta	taskResetValue
    461  199c		       a5 53		      lda	R0+1
    462  199e		       8d 69 27 	      sta	taskResetValue+1
    463  19a1		       d0 0b		      bne	iSliceSet
    464  19a3		       ee 69 27 	      inc	taskResetValue+1	; must be at least 1 high counter
    465  19a6		       a9 01		      lda	#1
    466  19a8		       8d 66 27 	      sta	taskCurrentCycles
    467  19ab		       8d 67 27 	      sta	taskCurrentCycles+1
    468  19ae				   iSliceSet
    469  19ae		       4c c2 02 	      jmp	NextIL
    470  19b1							;================================================================
    471  19b1							; Find an empty slot in the taskTable
    472  19b1							; Return the index in y
    473  19b1							; on exit   c set if an empty slot is found
    474  19b1							;	     c clear if not found
    475  19b1							;================================================================
    476  19b1							;
    477  19b1		       ad 6a 27    TaskEmpty  lda	taskCounter
    478  19b4		       c9 0a		      cmp	#TASKCOUNT
    479  19b6		       b0 10		      bcs	TaskNoSlot
    480  19b8		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    481  19ba				   TaskLoop
    482  19ba		       b9 6c 26 	      lda	taskTable,y
    483  19bd		       f0 0b		      beq	TaskEmptyFnd
    484  19bf		       98		      tya
    485  19c0		       18		      clc
    486  19c1		       69 19		      adc	#CONTEXTLEN
    487  19c3		       a8		      tay
    488  19c4		       c0 fa		      cpy	#TASKTABLELEN
    489  19c6		       90 f2		      bcc	TaskLoop	; Y is never zero
    490  19c8				   TaskNoSlot
    491  19c8		       18		      clc
    492  19c9		       60		      rts
    493  19ca				   TaskEmptyFnd
    494  19ca		       38		      sec
    495  19cb		       60		      rts
    496  19cc							;====================================================
    497  19cc							; Set the task exit code called from the return command
    498  19cc							; on entry stack top hold exit value
    499  19cc				   TaskSetExitCode
    500  19cc		       98		      tya
    501  19cd		       48		      pha
    502  19ce		       20 b3 1d 	      jsr	popR0
    503  19d1		       a0 34		      ldy	#TASKEXITCODE
    504  19d3		       a5 52		      lda	R0
    505  19d5		       91 41		      sta	(VARIABLES),y
    506  19d7		       c8		      iny
    507  19d8		       a5 53		      lda	R0+1
    508  19da		       91 41		      sta	(VARIABLES),y
    509  19dc		       68		      pla
    510  19dd		       98		      tya
    511  19de		       60		      rts
    512  19df
    513  19df							;
    514  19df							;=====================================================
    515  19df							; Save Context Store the context to the TASK Table
    516  19df							; on entry y contains the task table entry to save to
    517  19df							; on exit y points to next task table entry
    518  19df							;	   x contains the number of bytes copied
    519  19df		       a2 00	   ContextSave ldx	#0
    520  19e1		       c8		      iny		;inc past the task flags
    521  19e2		       b5 41	   ContextSvLoop lda	CONTEXT,x
    522  19e4		       99 6c 26 	      sta	taskTable,y
    523  19e7		       c8		      iny
    524  19e8		       e8		      inx
    525  19e9		       e0 18		      cpx	#[CONTEXTLEN-1]
    526  19eb		       90 f5		      bcc	ContextSvLoop
    527  19ed		       60		      rts
    528  19ee							;
    529  19ee							; Load Context transfer context from task table to the Current Context
    530  19ee							; on entry y contains the task table entry to transfer
    531  19ee							; on exit y points to the original task table entry
    532  19ee							;	   x contains the number of byts copied
    533  19ee		       98	   ContextLoad tya
    534  19ef		       48		      pha
    535  19f0		       a2 00		      ldx	#0
    536  19f2		       c8		      iny		;inc past the task flags
    537  19f3		       b9 6c 26    ContextLDLoop lda	taskTable,y
    538  19f6		       95 41		      sta	CONTEXT,x
    539  19f8		       c8		      iny
    540  19f9		       e8		      inx
    541  19fa		       e0 18		      cpx	#[CONTEXTLEN-1]
    542  19fc		       90 f5		      bcc	ContextLDLoop
    543  19fe		       68		      pla
    544  19ff		       a8		      tay
    545  1a00		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  1a01					      include	"ipc.asm"
      1  1a01							;======================================================
      2  1a01							; Inter process communications.
      3  1a01							; Tasks may write/read integer messages among
      4  1a01							; them selves.
      5  1a01							; This uses each tasks gosub stack as a message queue
      6  1a01							; Gosub calls start at the highest address and the
      7  1a01							; msg queue starts at the highest address.
      8  1a01							;
      9  1a01							;======================================================
     10  1a01							; ipcs   - Send msg to another task or many tasks
     11  1a01							; on entry  math stack contains the  top PID
     12  1a01							;				      2ND Message value
     13  1a01							; on exit   math stack contain top True-good or False-failed
     14  1a01							;
     15  1a01							; it may not be sent if queue is full
     16  1a01							;
     17  1a01							; a = ipcs(<message-expression>,<task PID-expression>)
     18  1a01							;
     19  1a01				   iIPCS
     20  1a01		       98		      tya
     21  1a02		       48		      pha
     22  1a03		       20 6a 1a 	      jsr	ipc_enqueue
     23  1a06		       b0 08		      bcs	iIPC_BAD
     24  1a08		       20 cb 1f 	      jsr	pushTrue
     25  1a0b		       68		      pla
     26  1a0c		       a8		      tay
     27  1a0d		       4c c2 02 	      jmp	NextIL
     28  1a10				   iIPC_BAD
     29  1a10		       68		      pla
     30  1a11		       a8		      tay
     31  1a12		       20 d5 1f 	      jsr	pushFalse
     32  1a15		       4c c2 02 	      jmp	NextIL
     33  1a18
     34  1a18							;======================================================
     35  1a18							; ipcr   - Recieve msg from task
     36  1a18							; on exit  the message value is returned from message queue
     37  1a18							;	    message -1	is reserved meaning no entry found
     38  1a18							; The provided variable contains the pid of the sending
     39  1a18							; task. This is optional. This always waits for a message
     40  1a18							; before returning.
     41  1a18							;
     42  1a18							; a = ipcr(<variable name>)
     43  1a18							;
     44  1a18				   iIPCR
     45  1a18		       98		      tya
     46  1a19		       48		      pha
     47  1a1a		       20 ac 1a 	      jsr	ipc_dequeue
     48  1a1d		       b0 05		      bcs	iIPCR_Q_Empty
     49  1a1f		       68		      pla
     50  1a20		       a8		      tay
     51  1a21		       4c c2 02 	      jmp	NextIL
     52  1a24				   iIPCR_Q_Empty
     53  1a24		       68		      pla
     54  1a25		       a8		      tay
     55  1a26		       20 cb 1f 	      jsr	pushTrue	; puts -1 on the stack
     56  1a29		       4c c2 02 	      jmp	NextIL
     57  1a2c
     58  1a2c							;=======================================================
     59  1a2c							; ipcc   - Check if message available
     60  1a2c							; on exit  Stack contains number of messages
     61  1a2c							;
     62  1a2c							; a = ipcc()
     63  1a2c							;
     64  1a2c				   iIPCC
     65  1a2c		       98		      tya
     66  1a2d		       48		      pha
     67  1a2e		       20 57 1a 	      jsr	ipc_queue_count
     68  1a31		       20 21 1d 	      jsr	pushR0	; return the count
     69  1a34		       68		      pla
     70  1a35		       a8		      tay
     71  1a36		       4c c2 02 	      jmp	NextIL
     72  1a39
     73  1a39							;=======================================================
     74  1a39							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  1a39				   iIPCIO
     76  1a39		       98		      tya
     77  1a3a		       48		      pha
     78  1a3b		       20 57 1a 	      jsr	ipc_queue_count
     79  1a3e		       a5 52		      lda	R0
     80  1a40		       d0 10		      bne	iIPCIO_No_Halt
     81  1a42		       a9 01		      lda	#1
     82  1a44		       8d 66 27 	      sta	taskCurrentCycles	; force a task switch
     83  1a47		       a9 01		      lda	#TASKWAITIPC
     84  1a49		       ac 6b 26 	      ldy	taskPtr
     85  1a4c		       19 6c 26 	      ora	taskTable,y
     86  1a4f		       99 6c 26 	      sta	taskTable,y
     87  1a52
     88  1a52				   iIPCIO_No_Halt
     89  1a52		       68		      pla
     90  1a53		       a8		      tay
     91  1a54		       4c c2 02 	      jmp	NextIL
     92  1a57							;======================================================
     93  1a57							;ipc_queue_count
     94  1a57				   ipc_queue_count
     95  1a57		       a5 4e		      lda	MESSAGEPTR
     96  1a59		       18		      clc
     97  1a5a		       4a		      lsr		; divide by 4
     98  1a5b		       4a		      lsr
     99  1a5c		       85 52		      sta	R0	; store into R0
    100  1a5e		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1a60		       38		      sec
    102  1a61		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1a63		       85 52		      sta	R0
    104  1a65		       a9 00		      lda	#0
    105  1a67		       85 53		      sta	R0+1
    106  1a69		       60		      rts
    107  1a6a							;=======================================================
    108  1a6a							; Support functions for messaging
    109  1a6a							;
    110  1a6a							; Enqueue message -> onto PID's MSG Q
    111  1a6a							; on entry top of stack contains the PID
    112  1a6a							;	    second contains the Message of the task
    113  1a6a							; on exit contains c set if failed
    114  1a6a							;		    c cleared if success
    115  1a6a							;		    PID's MSG Q PTR points to the message
    116  1a6a							;
    117  1a6a				   ipc_enqueue
    118  1a6a		       20 cb 1d 	      jsr	popR1	; Get the pid
    119  1a6d		       20 e5 1a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1a70
    121  1a70		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1a72		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1a74		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1a76		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1a78		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1a7a
    127  1a7a
    128  1a7a							; Get the PID'S stack address into R0
    129  1a7a		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1a7c		       b1 56		      lda	(MQ),y
    131  1a7e		       85 52		      sta	R0
    132  1a80		       c8		      iny
    133  1a81		       b1 56		      lda	(MQ),y
    134  1a83		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1a85
    136  1a85							; Set y to point to the msg q entry
    137  1a85		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1a87		       b1 56		      lda	(MQ),y	; Get the index
    139  1a89		       a8		      tay		; Set y to queue offset
    140  1a8a
    141  1a8a							; enqueue the message
    142  1a8a		       88		      dey		; First byte to save to
    143  1a8b		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1a8d		       91 52		      sta	(R0),y	; Set the entry type
    145  1a8f
    146  1a8f		       88		      dey
    147  1a90		       ad 6b 26 	      lda	taskPtr	; Store the PID into queue
    148  1a93		       91 52		      sta	(R0),y
    149  1a95		       20 cb 1d 	      jsr	popR1	; Get the actual message value
    150  1a98		       20 19 1b 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1a9b
    152  1a9b		       98		      tya		; Save the new q ptr
    153  1a9c		       a0 0e		      ldy	#MSGPTRPOS
    154  1a9e		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1aa0		       a0 00		      ldy	#0	; points to context root
    156  1aa2		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1aa4		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1aa6		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1aa8		       18		      clc
    160  1aa9		       60		      rts
    161  1aaa				   ipc_enq_full
    162  1aaa		       38		      sec
    163  1aab		       60		      rts
    164  1aac							;=============================================================
    165  1aac							; De-queue for message stack -> local tasks msg q
    166  1aac							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1aac							;  message into
    168  1aac							;  on exit   math stack contains value of message
    169  1aac							;				  Variable if provided is pid
    170  1aac				   ipc_dequeue
    171  1aac		       20 e2 1d 	      jsr	popMQ	; Variable address to put PID into
    172  1aaf
    173  1aaf		       a4 4e		      ldy	MESSAGEPTR
    174  1ab1		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  1ab3		       b0 2e		      bcs	ipc_deq_empty
    176  1ab5		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1ab7		       85 52		      sta	R0
    178  1ab9		       c8		      iny
    179  1aba		       b1 4b		      lda	(GOSUBSTACK),y
    180  1abc		       85 53		      sta	R0+1
    181  1abe		       c8		      iny
    182  1abf		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1ac1		       85 54		      sta	R1
    184  1ac3		       c8		      iny
    185  1ac4		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1ac6		       c8		      iny
    187  1ac7		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1ac9
    189  1ac9		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1acb		       d0 16		      bne	ipc_deq_empty
    191  1acd
    192  1acd		       20 21 1d 	      jsr	pushR0	; place value on stack
    193  1ad0
    194  1ad0		       a5 56		      lda	MQ
    195  1ad2		       05 57		      ora	MQ+1
    196  1ad4		       f0 0b		      beq	ipc_deq_done
    197  1ad6		       a5 54		      lda	R1
    198  1ad8		       a0 00		      ldy	#0
    199  1ada		       91 56		      sta	(MQ),y
    200  1adc		       c8		      iny
    201  1add		       a9 00		      lda	#0
    202  1adf		       91 56		      sta	(MQ),y
    203  1ae1				   ipc_deq_done
    204  1ae1		       18		      clc
    205  1ae2		       60		      rts
    206  1ae3
    207  1ae3				   ipc_deq_empty
    208  1ae3		       38		      sec
    209  1ae4		       60		      rts
    210  1ae5
    211  1ae5							;=============================================
    212  1ae5							;  Get the context address into MQ from R1 with
    213  1ae5							;  context/index/pid
    214  1ae5				   ipc_getcontext
    215  1ae5		       18		      clc		; Get pointer to Task context
    216  1ae6		       a9 6c		      lda	#taskTable&$FF	; change ptr to address
    217  1ae8		       65 54		      adc	R1
    218  1aea		       85 56		      sta	MQ
    219  1aec		       a9 26		      lda	#taskTable>>8
    220  1aee		       65 55		      adc	R1+1
    221  1af0		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1af2		       60		      rts
    223  1af3							;
    224  1af3							;==============================================
    225  1af3							; on entry R1 has a context value,
    226  1af3							; on exit c is set if fails
    227  1af3							;
    228  1af3				   ipc_CONTEXTVALUES
      0  1af3					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  1af3		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  1af7					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  1af7		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  1afb					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  1afb		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  1afd
    233  1afd				   ipc_ValidateContext
    234  1afd		       48		      pha
    235  1afe		       8a		      txa
    236  1aff		       48		      pha
    237  1b00		       a5 55		      lda	R1+1
    238  1b02		       d0 0e		      bne	ipc_Validate_Fail
    239  1b04		       a2 00		      ldx	#0
    240  1b06		       a5 54		      lda	R1
    241  1b08				   ipc_ValidateLoop
    242  1b08		       dd f3 1a 	      cmp	ipc_CONTEXTVALUES,x
    243  1b0b		       f0 09		      beq	ipc_Valid_Context
    244  1b0d		       e8		      inx
    245  1b0e		       e0 0a		      cpx	#TASKCOUNT
    246  1b10		       90 f6		      bcc	ipc_ValidateLoop
    247  1b12
    248  1b12				   ipc_Validate_Fail
    249  1b12		       68		      pla
    250  1b13		       aa		      tax
    251  1b14		       68		      pla
      0  1b15					      rtn
      0  1b15					      db	25
      1  1b15		       19		      .byte.b	25
    253  1b16
    254  1b16				   ipc_Valid_Context
    255  1b16		       18		      clc
    256  1b17		       90 f9		      bcc	ipc_Validate_Fail
    257  1b19							;
    258  1b19							;==============================================
    259  1b19							;Push R1 onto the stack
    260  1b19							;on entry y = next entry
    261  1b19							;R0 points to the stack space
    262  1b19							;on exit y points to next free byte
    263  1b19				   ipc_pushR1
    264  1b19		       88		      dey
    265  1b1a		       a5 55		      lda	R1+1	; PID first
    266  1b1c		       91 52		      sta	(R0),y
    267  1b1e		       88		      dey
    268  1b1f		       a5 54		      lda	R1
    269  1b21		       91 52		      sta	(R0),y
    270  1b23		       60		      rts
    271  1b24
    272  1b24
    273  1b24
    274  1b24
    275  1b24
    276  1b24
    277  1b24
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1b24					      include	"support.asm"
      1  1b24							;
      2  1b24							;=====================================================
      3  1b24							;=====================================================
      4  1b24							;=====================================================
      5  1b24							; This marks the start of support functions used by
      6  1b24							; the IL opcodes.  These are support functions, NOT
      7  1b24							; the IL code.
      8  1b24							;=====================================================
      9  1b24							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1b24							;=====================================================
     11  1b24					      Seg	Code
     12  1b24							;=====================================================
     13  1b24							; This gets the next two bytes pointed to by ILPC and
     14  1b24							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1b24							; is advanced by two, and Y contains 0 on return.
     16  1b24
     17  1b24							;
     18  1b24		       20 28 1b    getILWord  jsr	getILByte	;LSB
     19  1b27		       aa		      tax
     20  1b28							;
     21  1b28							;=====================================================
     22  1b28							; This gets the next byte pointed to by ILPC and
     23  1b28							; returns it in A.  On return, X is unchanged but Y
     24  1b28							; contains 0.
     25  1b28							;
     26  1b28		       a0 00	   getILByte  ldy	#0
     27  1b2a		       b1 43		      lda	(ILPC),y	;get byte
     28  1b2c		       08		      php		;save status
     29  1b2d		       e6 43		      inc	ILPC	;inc LSB
     30  1b2f		       d0 02		      bne	getILb2	;branch if no overflow
     31  1b31		       e6 44		      inc	ILPC+1	;inc MSB
     32  1b33		       28	   getILb2    plp		;restore status
     33  1b34		       60		      rts
     34  1b35							;
     35  1b35							;=====================================================
     36  1b35							; Decrement ILPC by one.
     37  1b35							;
     38  1b35		       a5 43	   decIL      lda	ILPC
     39  1b37		       d0 02		      bne	decIL2
     40  1b39		       c6 44		      dec	ILPC+1
     41  1b3b		       c6 43	   decIL2     dec	ILPC
     42  1b3d		       60		      rts
     43  1b3e							;
     44  1b3e							;=====================================================
     45  1b3e							; Push the ILPC onto the return stack.  Actually, this
     46  1b3e							; pushes the address of ILPC+2 since that's the next
     47  1b3e							; address to execute.
     48  1b3e							;
     49  1b3e		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  1b40		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  1b42		       b0 15		      bcs	pushErr
     52  1b44		       a5 43		      lda	ILPC
     53  1b46		       18		      clc
     54  1b47		       69 02		      adc	#2
     55  1b49		       91 45		      sta	(ILSTACK),y
     56  1b4b		       08		      php		;save C bit
     57  1b4c		       c8		      iny
     58  1b4d		       a5 44		      lda	ILPC+1
     59  1b4f		       28		      plp		;restore C
     60  1b50		       69 00		      adc	#0
     61  1b52		       91 45		      sta	(ILSTACK),y
     62  1b54		       c8		      iny
     63  1b55		       84 47		      sty	ILSTACKPTR
     64  1b57		       18		      clc
     65  1b58		       60		      rts
     66  1b59				   pushErr
     67  1b59		       38		      sec
     68  1b5a		       60		      rts
     69  1b5b							;
     70  1b5b							;=====================================================
     71  1b5b							; Pull the top entry from return stack and put into
     72  1b5b							; ILPC.
     73  1b5b							;
     74  1b5b		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1b5d		       f0 fa		      beq	pushErr
     76  1b5f		       88		      dey
     77  1b60		       b1 45		      lda	(ILSTACK),y
     78  1b62		       85 44		      sta	ILPC+1
     79  1b64		       88		      dey
     80  1b65		       b1 45		      lda	(ILSTACK),y
     81  1b67		       85 43		      sta	ILPC
     82  1b69		       84 47		      sty	ILSTACKPTR
     83  1b6b		       18		      clc
     84  1b6c		       60		      rts
     85  1b6d							;
     86  1b6d							;=====================================================
     87  1b6d							; This searches for a specific line number that is in
     88  1b6d							; R0.	There are three possible return conditions:
     89  1b6d							; Line numbers are now the third byte, the first byte is now
     90  1b6d							; a pointer to the next line, of course no longer than 255 byte
     91  1b6d							; per line.
     92  1b6d							;
     93  1b6d							; Exact match was found:
     94  1b6d							;    * Z set
     95  1b6d							;    * CURPTR points to two-byte line number for that
     96  1b6d							;	line.
     97  1b6d							;
     98  1b6d							; Next highest line found:
     99  1b6d							;    * Z cleared
    100  1b6d							;    * C set
    101  1b6d							;    * CURPTR points to two-byte line number for that
    102  1b6d							;	line.
    103  1b6d							;
    104  1b6d							; End of program reached:
    105  1b6d							;    * Z cleared
    106  1b6d							;    * C cleared
    107  1b6d							;    * CURPTR points to first free byte at end of
    108  1b6d							;	program.  Ie, it has save value as PROGRAMEND.
    109  1b6d							;
    110  1b6d							; A, X, and Y are all undefined on return.
    111  1b6d							;
    112  1b6d
    113  1b6d				   findLine
    114  1b6d		       ad c4 2f 	      lda	ProgramStart	;Start of program -> CURPTR
    115  1b70		       85 4f		      sta	CURPTR
    116  1b72		       ad c5 2f 	      lda	ProgramStart+1
    117  1b75		       85 50		      sta	CURPTR+1
    118  1b77							;
    119  1b77							; At end of code?
    120  1b77							;
    121  1b77				   iXFER1
    122  1b77		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1b79		       cd c6 2f 	      cmp	ProgramEnd	; at end of program then stop run
    124  1b7c		       d0 0b		      bne	xfer2	; not end
    125  1b7e		       a5 50		      lda	CURPTR+1
    126  1b80		       cd c7 2f 	      cmp	ProgramEnd+1
    127  1b83		       d0 04		      bne	xfer2	;Not at end
    128  1b85							;
    129  1b85							; Line not found and the end of the program was
    130  1b85							; reached.  Return Z and C both clear.
    131  1b85							;
    132  1b85		       a9 01		      lda	#1	;clear Z
    133  1b87		       18		      clc		;clear C
    134  1b88		       60		      rts
    135  1b89							;
    136  1b89							; Check for an exact line number match
    137  1b89							;
    138  1b89		       a5 52	   xfer2      lda	R0
    139  1b8b		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1b8d		       d1 4f		      cmp	(CURPTR),y
    141  1b8f		       d0 08		      bne	xfernotit
    142  1b91		       c8		      iny
    143  1b92		       a5 53		      lda	R0+1
    144  1b94		       d1 4f		      cmp	(CURPTR),y
    145  1b96		       d0 01		      bne	xfernotit	; not a matching line number
    146  1b98							;
    147  1b98							; This is exactly the line we want.
    148  1b98							;
    149  1b98		       60		      rts		;it matches exactly
    150  1b99							;
    151  1b99							; See if this line is greater than the one we're
    152  1b99							; searching for.
    153  1b99							;
    154  1b99		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1b9b		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1b9d		       c5 53		      cmp	R0+1
    157  1b9f		       90 0b		      bcc	xfer3
    158  1ba1		       d0 07		      bne	xfer4
    159  1ba3		       88		      dey
    160  1ba4		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1ba6		       c5 52		      cmp	R0
    162  1ba8		       90 02		      bcc	xfer3
    163  1baa							;
    164  1baa							; This line is greater than the one we want, so
    165  1baa							; return Z clear and C set.
    166  1baa							;
    167  1baa		       38	   xfer4      sec		;We found a line number greater
    168  1bab		       60		      rts		;both conditions set
    169  1bac							;
    170  1bac							; Not the line (or droid) we're looking for.  Move to
    171  1bac							; the next line.
    172  1bac							;
    173  1bac		       20 b2 1b    xfer3      jsr	FindNextLine
    174  1baf		       4c 77 1b 	      jmp	iXFER1
    175  1bb2							;
    176  1bb2							;=====================================================
    177  1bb2							; This advances CURPTR to the next line.  If there
    178  1bb2							; are no more lines, this leaves CURPTR equal to
    179  1bb2							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1bb2							; CURPTR is pointing to a valid line on entry.  This
    181  1bb2							; pointer points to the two-byte line number.
    182  1bb2							; Update this points to the 1 byte line length  ****************
    183  1bb2							;
    184  1bb2				   FindNextLine
    185  1bb2		       a0 03		      ldy	#3	;skip line number and length byte
    186  1bb4		       84 51		      sty	CUROFF	;this is the new offset
    187  1bb6		       a0 00		      ldy	#0
    188  1bb8		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1bba		       18		      clc
    190  1bbb		       65 4f		      adc	CURPTR
    191  1bbd		       85 4f		      sta	CURPTR
    192  1bbf		       a5 50		      lda	CURPTR+1
    193  1bc1		       69 00		      adc	#0
    194  1bc3		       85 50		      sta	CURPTR+1
    195  1bc5		       60	   FindNext4  rts
    196  1bc6							;
    197  1bc6							;=====================================================
    198  1bc6							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1bc6							; if they are equal, Z clear if not.
    200  1bc6							;
    201  1bc6		       a5 4f	   AtEnd      lda	CURPTR
    202  1bc8		       cd c6 2f 	      cmp	ProgramEnd
    203  1bcb		       d0 05		      bne	atendexit
    204  1bcd		       a5 50		      lda	CURPTR+1
    205  1bcf		       cd c7 2f 	      cmp	ProgramEnd+1
    206  1bd2		       60	   atendexit  rts
    207  1bd3							;
    208  1bd3
    209  1bd3							;
    210  1bd3							;=====================================================
    211  1bd3							; Convert an ASCII string to a number.  On input,
    212  1bd3							; (CURPTR),Y points to the first digit.  This gets
    213  1bd3							; digit-by-digit until finding a non-number.  Returns
    214  1bd3							; Y pointing to the non-digit, and R0 contains the
    215  1bd3							; number.  This does NOT check for valid ranges, so
    216  1bd3							; a value like "123456789" will produce something,
    217  1bd3							; but not what you had expected.
    218  1bd3							;
    219  1bd3		       a9 00	   getDecimal lda	#0
    220  1bd5		       85 52		      sta	R0
    221  1bd7		       85 53		      sta	R0+1
    222  1bd9		       85 59		      sta	dpl	;temporary negative flag
    223  1bdb							;
    224  1bdb							; See if it's negative...
    225  1bdb							;
    226  1bdb							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1bdb		       b1 4f		      lda	(CURPTR),y
    228  1bdd		       c9 2d		      cmp	#'-
    229  1bdf		       d0 02		      bne	getDecLoop
    230  1be1		       e6 59		      inc	dpl	;it's negative
    231  1be3							;
    232  1be3		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1be5		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1be7		       c9 30		      cmp	#'0
    235  1be9		       90 36		      bcc	getDdone
    236  1beb		       c9 3a		      cmp	#'9+1
    237  1bed		       b0 32		      bcs	getDdone
    238  1bef		       38		      sec
    239  1bf0		       e9 30		      sbc	#'0	;convert to binary
    240  1bf2		       48		      pha
    241  1bf3							;
    242  1bf3							; Now multiply R0 by 10.  Remember that
    243  1bf3							; 2*N + 8*N = 10*N.
    244  1bf3							;
    245  1bf3		       06 52		      asl	R0
    246  1bf5		       26 53		      rol	R0+1	;*2
    247  1bf7		       a5 52		      lda	R0
    248  1bf9		       85 54		      sta	R1
    249  1bfb		       a5 53		      lda	R0+1
    250  1bfd		       85 55		      sta	R1+1
    251  1bff		       06 52		      asl	R0
    252  1c01		       26 53		      rol	R0+1	;*4
    253  1c03		       06 52		      asl	R0
    254  1c05		       26 53		      rol	R0+1	;*8
    255  1c07		       18		      clc		;now add the partial sums...
    256  1c08		       a5 52		      lda	R0	;...to get *10
    257  1c0a		       65 54		      adc	R1
    258  1c0c		       85 52		      sta	R0
    259  1c0e		       a5 53		      lda	R0+1
    260  1c10		       65 55		      adc	R1+1
    261  1c12		       85 53		      sta	R0+1
    262  1c14							;
    263  1c14							; Add in the new digit
    264  1c14							;
    265  1c14		       68		      pla
    266  1c15		       18		      clc
    267  1c16		       65 52		      adc	R0
    268  1c18		       85 52		      sta	R0
    269  1c1a		       90 02		      bcc	getD2
    270  1c1c		       e6 53		      inc	R0+1
    271  1c1e							;
    272  1c1e							; Move to next character
    273  1c1e							;
    274  1c1e		       c8	   getD2      iny
    275  1c1f		       d0 c2		      bne	getDecLoop
    276  1c21							;
    277  1c21							; All done with digits, so now deal with it being
    278  1c21							; negative.  If zero, then don't check for negative
    279  1c21							; flag.  Ie, -0 is stored as 0.
    280  1c21							;
    281  1c21		       a5 52	   getDdone   lda	R0
    282  1c23		       05 53		      ora	R0+1
    283  1c25		       f0 16		      beq	getDone2	;zero
    284  1c27		       a5 59		      lda	dpl
    285  1c29		       f0 12		      beq	getDone2	;positive
    286  1c2b							;
    287  1c2b							; Invert all the bits, then add one.
    288  1c2b							;
    289  1c2b		       a5 52		      lda	R0
    290  1c2d		       49 ff		      eor	#$ff
    291  1c2f		       85 52		      sta	R0
    292  1c31		       a5 53		      lda	R0+1
    293  1c33		       49 ff		      eor	#$ff
    294  1c35		       85 53		      sta	R0+1
    295  1c37							;
    296  1c37		       e6 52		      inc	R0
    297  1c39		       d0 02		      bne	getDone2
    298  1c3b		       e6 53		      inc	R0+1
    299  1c3d				   getDone2
    300  1c3d							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1c3d							;lda	  R0
    302  1c3d							;sta	  $0010
    303  1c3d							;lda	  R0+1
    304  1c3d							;sta	  $0011
    305  1c3d							;lda	  dpl
    306  1c3d							;sta	  $012
    307  1c3d
    308  1c3d		       60		      rts
    309  1c3e
    310  1c3e							;=====================================================
    311  1c3e							; Gets a line of input into LINBUF.
    312  1c3e							;
    313  1c3e							; On entry:
    314  1c3e							;    A contains the prompt character, or 0 if none.
    315  1c3e							;    X = 1 Background read
    316  1c3e							;    x = 0 Forground read with wait
    317  1c3e							;
    318  1c3e							; On exit:
    319  1c3e							;    CURPTR points to LINBUF
    320  1c3e							;    LINBUF contains the line with 0 at the end.
    321  1c3e							;    Y has offset to first non-space character
    322  1c3e							;    CURROFF has the same as Y.
    323  1c3e							;
    324  1c3e		       20 8d 1c    GetLine    jsr	ReadPrompt
    325  1c41		       e0 00		      cpx	#0
    326  1c43		       f0 14		      beq	GetLineRetry
    327  1c45		       ae 6b 26 	      ldx	taskPtr
    328  1c48		       bd 6c 26 	      lda	taskTable,x
    329  1c4b		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1c4d		       d0 3d		      bne	taskWaitingIO
    331  1c4f		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1c51		       9d 6c 26 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1c54		       ce 8c 1c 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1c57		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1c59
    336  1c59							;
    337  1c59							; Now read a line and wait for the CR
    338  1c59							;
    339  1c59				   GetLineRetry
    340  1c59		       a9 00		      lda	#0	;Wait for input to complete
    341  1c5b		       20 a5 1c 	      jsr	ReadLine
    342  1c5e
    343  1c5e							;
    344  1c5e							; Point to the line we just read
    345  1c5e							; Set the current pointer to point to the input line
    346  1c5e							;
    347  1c5e		       a0 00	   ReadComplete ldy	#0
    348  1c60		       84 51		      sty	CUROFF
    349  1c62		       a2 27		      ldx	#LINBUF&$ff
    350  1c64		       86 4f		      stx	CURPTR
    351  1c66		       a2 2f		      ldx	#LINBUF>>8
    352  1c68		       86 50		      stx	CURPTR+1
    353  1c6a							;
    354  1c6a							; Output a CR/LF
    355  1c6a							;
    356  1c6a		       20 6c 1e 	      jsr	CRLF
    357  1c6d							;
    358  1c6d							; If a blank line, prompt again.
    359  1c6d							;
    360  1c6d		       20 63 1e 	      jsr	SkipSpaces
    361  1c70		       b1 4f		      lda	(CURPTR),y
    362  1c72		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1c74		       20 90 1c 	      jsr	ReadPromptRetry
    364  1c77		       ae 6b 26 	      ldx	taskPtr	;if this task is waiting for IO
    365  1c7a		       bd 6c 26 	      lda	taskTable,x	;then get out, wait for line to
    366  1c7d		       29 40		      and	#TASKWAITIO	;Complete again
    367  1c7f		       d0 0b		      bne	taskWaitingIO
    368  1c81		       4c 59 1c 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1c84
    370  1c84				   GetLineDone
    371  1c84		       ae 6b 26 	      ldx	taskPtr
    372  1c87		       a9 80		      lda	#TASKACTIVE
    373  1c89		       9d 6c 26 	      sta	taskTable,x	;IO is complete
    374  1c8c
    375  1c8c				   taskWaitingIO
    376  1c8c		       60		      rts
    377  1c8d
    378  1c8d							;
    379  1c8d							;=======================================================================
    380  1c8d							; Display the prompt character
    381  1c8d							; On entry
    382  1c8d							;	    A contains the prompt character
    383  1c8d							; On exit
    384  1c8d							;	    The readbuffer index is reset to 0
    385  1c8d							;
    386  1c8d		       8d ae 2f    ReadPrompt sta	promptChar
    387  1c90
    388  1c90							;
    389  1c90							; Prompt
    390  1c90							;
    391  1c90
    392  1c90		       ad ae 2f    ReadPromptRetry lda	promptChar
    393  1c93		       09 00		      ora	#0	;any prompt?
    394  1c95		       f0 08		      beq	getlinenp
    395  1c97		       20 ba 1f 	      jsr	VOUTCH
    396  1c9a		       a9 20		      lda	#$20
    397  1c9c		       20 ba 1f 	      jsr	VOUTCH	;Space after prompt
    398  1c9f							;
    399  1c9f		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1ca1		       8e ab 2f 	      stx	getlinx
    401  1ca4		       60		      rts
    402  1ca5							;
    403  1ca5							;===============================================================
    404  1ca5							; This fuction is the driver for the line input
    405  1ca5							; on call if a = 0 then it waits for all input
    406  1ca5							;	      a = 1 then nowait for input
    407  1ca5							; On exit
    408  1ca5							;		       c clear if not complete line
    409  1ca5							;		       c set if it was a complete line
    410  1ca5
    411  1ca5				   ReadLine
    412  1ca5		       8d ad 2f 	      sta	inputNoWait
    413  1ca8		       c9 00		      cmp	#0
    414  1caa		       f0 05		      beq	getline1
    415  1cac		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1caf		       f0 2b		      beq	GetLineNoWait
    417  1cb1		       20 bd 1f    getline1   jsr	VGETCH
    418  1cb4					      if	CTMON65
    419  1cb4		       48		      pha
    420  1cb5		       20 ba 1f 	      jsr	VOUTCH	;echo echo echo
    421  1cb8		       68		      pla
    422  1cb9					      endif
    423  1cb9		       c9 0d		      cmp	#CR
    424  1cbb		       f0 15		      beq	getlind	;end of line
    425  1cbd		       c9 08		      cmp	#BS	;backspace?
    426  1cbf		       f0 1d		      beq	getlinebs
    427  1cc1		       ae ab 2f 	      ldx	getlinx
    428  1cc4		       9d 27 2f 	      sta	LINBUF,x
    429  1cc7		       e8		      inx
    430  1cc8		       8e ab 2f 	      stx	getlinx
    431  1ccb		       ad ad 2f 	      lda	inputNoWait
    432  1cce		       f0 e1		      beq	getline1
    433  1cd0		       d0 0a		      bne	GetLineNoWait
    434  1cd2							;
    435  1cd2							; CR was hit
    436  1cd2							;
    437  1cd2		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1cd4		       ae ab 2f 	      ldx	getlinx
    439  1cd7		       9d 27 2f 	      sta	LINBUF,x
    440  1cda
    441  1cda		       38		      sec		; Carry set then cr received
    442  1cdb		       60		      rts
    443  1cdc
    444  1cdc				   GetLineNoWait
    445  1cdc		       18		      clc		; Carry clear no end of line
    446  1cdd		       60		      rts
    447  1cde							;
    448  1cde							; Backspace was hit
    449  1cde							;
    450  1cde		       ae ab 2f    getlinebs  ldx	getlinx
    451  1ce1		       f0 0e		      beq	getlineEOL	;at start of line
    452  1ce3		       ca		      dex
    453  1ce4		       8e ab 2f 	      stx	getlinx
    454  1ce7		       20 3d 14    getlinepbs jsr	puts
      0  1cea					      db	27,"[K",0
      1  1cea		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1cee		       4c b1 1c 	      jmp	getline1
    457  1cf1		       a9 20	   getlineEOL lda	#SPACE
    458  1cf3		       20 ba 1f 	      jsr	VOUTCH
    459  1cf6		       d0 ef		      bne	getlinepbs
    460  1cf8							;
    461  1cf8							;=====================================================
    462  1cf8							; Count the length of the line currently in LINBUF
    463  1cf8							; starting at offset Y.  Returns the length in X.  The
    464  1cf8							; starting offset in Y should point past the ASCII
    465  1cf8							; line number.  Also counts the trailing NULL and two
    466  1cf8							; extra bytes for where the line number will be.
    467  1cf8							; Update must now include leading length byte not the null at end ****************
    468  1cf8							;
    469  1cf8				   getLineLength
    470  1cf8		       a2 00		      ldx	#0	;size
    471  1cfa		       b9 27 2f    getLineL2  lda	LINBUF,y
    472  1cfd		       f0 04		      beq	getLineL3
    473  1cff		       c8		      iny
    474  1d00		       e8		      inx
    475  1d01		       d0 f7		      bne	getLineL2
    476  1d03		       e8	   getLineL3  inx		;count null at end
    477  1d04		       e8		      inx		;line number LSB
    478  1d05		       e8		      inx		;MSB
    479  1d06		       e8		      inx		;change: count new leading line length
    480  1d07		       8e c1 2f 	      stx	lineLength
    481  1d0a		       60		      rts
    482  1d0b							;
    483  1d0b							;=====================================================
    484  1d0b							; Count the length of the line pointed to by CURPTR.
    485  1d0b							; This also counts the line number and the terminating
    486  1d0b							; null.  Ie, this string returns 8:
    487  1d0b							;
    488  1d0b							; <lineLow><lineHi>Hello<null>
    489  1d0b							;
    490  1d0b							; Another way of looking at it: add the return value
    491  1d0b							; to the CURPTR and it'll point to the next line's
    492  1d0b							; line number.  Returns the value in Y.
    493  1d0b							; Update to ject get the leading byte length ********************
    494  1d0b							;
    495  1d0b							;getCURPTRLength
    496  1d0b							;		ldy	CURPTR
    497  1d0b							;		ldy	#3	;change: skip line number and leading length byte
    498  1d0b							;getCLineL2	lda	(CURPTR),y
    499  1d0b							;		beq	getCLineL3
    500  1d0b							;		iny
    501  1d0b							;		bne	getCLineL2
    502  1d0b							;getCLineL3	iny		;count null at end
    503  1d0b							;		rts
    504  1d0b
    505  1d0b							;
    506  1d0b							;=====================================================
    507  1d0b							; This saves ILPC.  This saves to a single save area,
    508  1d0b							; so it can't be called more than once.
    509  1d0b							;
    510  1d0b		       a5 43	   saveIL     lda	ILPC
    511  1d0d		       8d bd 2f 	      sta	tempIL
    512  1d10		       a5 44		      lda	ILPC+1
    513  1d12		       8d be 2f 	      sta	tempIL+1
    514  1d15		       60		      rts
    515  1d16							;
    516  1d16							;=====================================================
    517  1d16							; This restores ILPC.
    518  1d16							;
    519  1d16		       ad bd 2f    restoreIL  lda	tempIL
    520  1d19		       85 43		      sta	ILPC
    521  1d1b		       ad be 2f 	      lda	tempIL+1
    522  1d1e		       85 44		      sta	ILPC+1
    523  1d20		       60		      rts
    524  1d21							;
    525  1d21							;=====================================================
    526  1d21							; This pushes R0 onto the stack.
    527  1d21							;
    528  1d21		       8c b4 2f    pushR0     sty	rtemp1
    529  1d24		       a4 4a		      ldy	MATHSTACKPTR
    530  1d26		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1d28		       b0 38		      bcs	pusherr
    532  1d2a		       a5 52		      lda	R0
    533  1d2c		       91 48		      sta	(MATHSTACK),y
    534  1d2e		       c8		      iny
    535  1d2f		       a5 53		      lda	R0+1
    536  1d31		       91 48		      sta	(MATHSTACK),y
    537  1d33		       c8		      iny
    538  1d34		       84 4a		      sty	MATHSTACKPTR
    539  1d36		       ac b4 2f 	      ldy	rtemp1
    540  1d39		       18		      clc
    541  1d3a		       60		      rts
    542  1d3b
    543  1d3b							;=====================================================
    544  1d3b							; This pushes curptr basic current line onto the call stack.
    545  1d3b							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1d3b
    547  1d3b				   pushLN
    548  1d3b		       8d b5 2f 	      STA	rtemp1+1	; Store type of push being done
    549  1d3e		       8c b4 2f 	      sty	rtemp1
    550  1d41		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  1d43		       c5 4d		      cmp	GOSUBSTACKPTR
    552  1d45		       90 1b		      bcc	pusherr	; No error
    553  1d47		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  1d49		       a2 00		      ldx	#0	; Start of bytes to copy
    555  1d4b				   pushLoop
    556  1d4b		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  1d4d		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  1d4f		       c8		      iny		; Next destination
    559  1d50		       e8		      inx		; Next Source byte
    560  1d51		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  1d53		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  1d55
    563  1d55		       ad b5 2f    pushDone   lda	rtemp1+1	; Type of stack entry
    564  1d58		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  1d5a		       c8		      iny		; Next entry
    566  1d5b
    567  1d5b		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  1d5d		       ac b4 2f 	      ldy	rtemp1
    569  1d60		       18		      clc
    570  1d61		       60		      rts
    571  1d62				   pusherr
    572  1d62		       38		      sec
    573  1d63		       60		      rts
    574  1d64							;=====================================================
    575  1d64							; This pops Top Off gosub call Stack and
    576  1d64							; places it in CURPTR/CUROFF.
    577  1d64							; This checks if the type = 1 GOSUB
    578  1d64							; if not it removes what ever is on the stack
    579  1d64							; until it finds the next return. Allowing
    580  1d64							; a return from within a for/next
    581  1d64							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  1d64		       8c b4 2f    popLN      sty	rtemp1
    583  1d67		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  1d69		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  1d6b
    586  1d6b				   popContinue
    587  1d6b		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  1d6d		       90 22		      bcc	poperr	; Process an error
    589  1d6f
    590  1d6f		       88		      dey		; Position to read entry type
    591  1d70		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  1d72		       8d b5 2f 	      sta	rtemp1+1	; Save to be returned
    593  1d75		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  1d77		       f0 04		      beq	popLoop	; Restore the line
    595  1d79		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  1d7b		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  1d7d
    598  1d7d				   popLoop
    599  1d7d		       88		      dey
    600  1d7e		       ca		      dex
    601  1d7f		       b1 4b		      lda	(GOSUBSTACK),y
    602  1d81		       95 4f		      sta	CURPTR,x
    603  1d83		       e0 00		      cpx	#0
    604  1d85		       d0 f6		      bne	popLoop	; Loop until all moved
    605  1d87
    606  1d87
    607  1d87		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  1d89		       ac b4 2f 	      ldy	rtemp1
    609  1d8c		       ad b5 2f 	      lda	rtemp1+1	; get the type of return
    610  1d8f		       18		      clc
    611  1d90		       60		      rts
    612  1d91
    613  1d91		       38	   poperr     sec
    614  1d92		       60		      rts
    615  1d93
    616  1d93		       88	   popSkipEntry dey
    617  1d94		       88		      dey
    618  1d95		       88		      dey
    619  1d96		       4c 6b 1d 	      jmp	popContinue
    620  1d99
    621  1d99							;
    622  1d99							;=====================================================
    623  1d99							; This pushes R1 onto the stack
    624  1d99							;
    625  1d99		       8c b4 2f    pushR1     sty	rtemp1
    626  1d9c		       a4 4a		      ldy	MATHSTACKPTR
    627  1d9e		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  1da0		       b0 ef		      bcs	poperr
    629  1da2		       a5 54		      lda	R1
    630  1da4		       91 48		      sta	(MATHSTACK),y
    631  1da6		       c8		      iny
    632  1da7		       a5 55		      lda	R1+1
    633  1da9		       91 48		      sta	(MATHSTACK),y
    634  1dab		       c8		      iny
    635  1dac		       84 4a		      sty	MATHSTACKPTR
    636  1dae		       ac b4 2f 	      ldy	rtemp1
    637  1db1		       18		      clc
    638  1db2		       60		      rts
    639  1db3							;
    640  1db3							;=====================================================
    641  1db3							; This pops Top Of Stack and places it in R0.
    642  1db3							;
    643  1db3		       8c b4 2f    popR0      sty	rtemp1
    644  1db6		       a4 4a		      ldy	MATHSTACKPTR
    645  1db8		       f0 d7		      beq	poperr
    646  1dba		       88		      dey
    647  1dbb		       b1 48		      lda	(MATHSTACK),y
    648  1dbd		       85 53		      sta	R0+1
    649  1dbf		       88		      dey
    650  1dc0		       b1 48		      lda	(MATHSTACK),y
    651  1dc2		       85 52		      sta	R0
    652  1dc4		       84 4a		      sty	MATHSTACKPTR
    653  1dc6		       ac b4 2f 	      ldy	rtemp1
    654  1dc9		       18		      clc
    655  1dca		       60		      rts
    656  1dcb
    657  1dcb							;
    658  1dcb							;=====================================================
    659  1dcb							; This pops TOS and places it in R1.
    660  1dcb							;
    661  1dcb		       8c b4 2f    popR1      sty	rtemp1
    662  1dce		       a4 4a		      ldy	MATHSTACKPTR
    663  1dd0		       f0 bf		      beq	poperr
    664  1dd2		       88		      dey
    665  1dd3		       b1 48		      lda	(MATHSTACK),y
    666  1dd5		       85 55		      sta	R1+1
    667  1dd7		       88		      dey
    668  1dd8		       b1 48		      lda	(MATHSTACK),y
    669  1dda		       85 54		      sta	R1
    670  1ddc		       84 4a		      sty	MATHSTACKPTR
    671  1dde		       ac b4 2f 	      ldy	rtemp1
    672  1de1		       60		      rts
    673  1de2							;
    674  1de2							;=====================================================
    675  1de2							; This pops TOS and places it in MQ.
    676  1de2							;
    677  1de2		       8c b4 2f    popMQ      sty	rtemp1
    678  1de5		       a4 4a		      ldy	MATHSTACKPTR
    679  1de7		       f0 a8		      beq	poperr
    680  1de9		       88		      dey
    681  1dea		       b1 48		      lda	(MATHSTACK),y
    682  1dec		       85 57		      sta	MQ+1
    683  1dee		       88		      dey
    684  1def		       b1 48		      lda	(MATHSTACK),y
    685  1df1		       85 56		      sta	MQ
    686  1df3		       84 4a		      sty	MATHSTACKPTR
    687  1df5		       ac b4 2f 	      ldy	rtemp1
    688  1df8		       60		      rts
    689  1df9							;
    690  1df9							;=====================================================
    691  1df9							; This assists with multiplication and division by
    692  1df9							; looking at R0 and R1 and saving a flag as to what
    693  1df9							; sign the result will be.  Math is always done on
    694  1df9							; positive numbers, so this converts negative numbers
    695  1df9							; into positives.  On exit, R0 and R1 are both
    696  1df9							; positive.  If the signs were different then 'signs'
    697  1df9							; will be non-zero.
    698  1df9							;
    699  1df9		       a9 00	   SaveSigns  lda	#0
    700  1dfb		       8d b3 2f 	      sta	sign	;assume positive
    701  1dfe		       a5 53		      lda	R0+1	;MSB
    702  1e00		       10 13		      bpl	SaveSigns1
    703  1e02		       ee b3 2f 	      inc	sign	;it's negative
    704  1e05		       49 ff		      eor	#$ff	;flip bits
    705  1e07		       85 53		      sta	R0+1
    706  1e09		       a5 52		      lda	R0
    707  1e0b		       49 ff		      eor	#$ff
    708  1e0d		       85 52		      sta	R0
    709  1e0f		       e6 52		      inc	R0
    710  1e11		       d0 02		      bne	SaveSigns1
    711  1e13		       e6 53		      inc	R0+1
    712  1e15		       a5 55	   SaveSigns1 lda	R1+1
    713  1e17		       10 1a		      bpl	SaveSigns2
    714  1e19		       48		      pha
    715  1e1a		       ad b3 2f 	      lda	sign
    716  1e1d		       49 01		      eor	#1
    717  1e1f		       8d b3 2f 	      sta	sign
    718  1e22		       68		      pla
    719  1e23		       49 ff		      eor	#$ff	;flip bits
    720  1e25		       85 55		      sta	R1+1
    721  1e27		       a5 54		      lda	R1
    722  1e29		       49 ff		      eor	#$ff
    723  1e2b		       85 54		      sta	R1
    724  1e2d		       e6 54		      inc	R1
    725  1e2f		       d0 02		      bne	SaveSigns2
    726  1e31		       e6 55		      inc	R1+1
    727  1e33		       60	   SaveSigns2 rts
    728  1e34							;
    729  1e34							;=====================================================
    730  1e34							; This looks at the value of 'signs' and will convert
    731  1e34							; both R0 and R1 to negative if set.
    732  1e34							;
    733  1e34				   RestoreSigns
    734  1e34		       ad b3 2f 	      lda	sign
    735  1e37		       f0 28		      beq	restoresigns2
    736  1e39							;
    737  1e39		       a5 52		      lda	R0
    738  1e3b		       d0 02		      bne	restoresigns3
    739  1e3d		       c6 53		      dec	R0+1
    740  1e3f				   restoresigns3
    741  1e3f		       c6 52		      dec	R0
    742  1e41		       a5 52		      lda	R0
    743  1e43		       49 ff		      eor	#$ff
    744  1e45		       85 52		      sta	R0
    745  1e47		       a5 53		      lda	R0+1
    746  1e49		       49 ff		      eor	#$ff
    747  1e4b		       85 53		      sta	R0+1
    748  1e4d							;
    749  1e4d		       a5 54		      lda	R1
    750  1e4f		       d0 02		      bne	restoresigns4
    751  1e51		       c6 55		      dec	R1+1
    752  1e53				   restoresigns4
    753  1e53		       c6 54		      dec	R1
    754  1e55		       a5 54		      lda	R1
    755  1e57		       49 ff		      eor	#$ff
    756  1e59		       85 54		      sta	R1
    757  1e5b		       a5 55		      lda	R1+1
    758  1e5d		       49 ff		      eor	#$ff
    759  1e5f		       85 55		      sta	R1+1
    760  1e61							;
    761  1e61				   restoresigns2
    762  1e61		       60		      rts
    763  1e62							;
    764  1e62							;=====================================================
    765  1e62							; Skip over spaces.  Returns Y with the offset to
    766  1e62							; either the last character in the line, or the first
    767  1e62							; non-space character.
    768  1e62							;
    769  1e62
    770  1e62		       c8	   skipsp2    iny
    771  1e63		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  1e65		       f0 04		      beq	Skip3	;end of line
    773  1e67		       c9 20		      cmp	#SPACE
    774  1e69		       f0 f7		      beq	skipsp2
    775  1e6b		       60	   Skip3      rts
    776  1e6c							;*********************************************************
    777  1e6c							; Output a CR/LF combination to the console.  Preserves
    778  1e6c							; all registers.
    779  1e6c							;
    780  1e6c		       48	   tbcrlf     pha
    781  1e6d		       a9 0d		      lda	#CR
    782  1e6f		       20 ba 1f 	      jsr	VOUTCH
    783  1e72		       a9 0a		      lda	#LF
    784  1e74		       20 ba 1f 	      jsr	VOUTCH
    785  1e77		       68		      pla
    786  1e78		       60		      rts
    787  1e79							;
    788  1e79							;=====================================================
    789  1e79							; Some logic to print the Line of basic code being executed
    790  1e79		       24 40	   idbgBasic  bit	ILTrace
    791  1e7b		       50 75		      bvc	dbgBasicNone
    792  1e7d		       98		      tya
    793  1e7e		       48		      pha
    794  1e7f		       20 ee 1f 	      jsr	SetOutDebug
    795  1e82
    796  1e82		       a5 4f		      lda	CURPTR
    797  1e84		       85 59		      sta	dpl
    798  1e86		       a5 50		      lda	CURPTR+1
    799  1e88		       85 5a		      sta	dpl+1
    800  1e8a
    801  1e8a		       20 d5 14 	      jsr	PrintProgramLine
    802  1e8d
    803  1e8d		       a5 40		      lda	ILTrace
    804  1e8f		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  1e91		       f0 5a		      beq	dbgBasicDone
    806  1e93		       20 05 20 	      jsr	SetInDebug
    807  1e96		       20 3d 14 	      jsr	puts
      0  1e99					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1e99		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  1ed6				   dbgBasicLoop
    810  1ed6		       20 bd 1f 	      jsr	VGETCH
    811  1ed9		       20 6c 1e 	      jsr	CRLF
    812  1edc		       20 29 20 	      jsr	SetInDebugEnd
    813  1edf
    814  1edf		       c9 73		      cmp	#'s	; Quit program
    815  1ee1		       f0 12		      beq	dbgBasicStop
    816  1ee3
    817  1ee3		       c9 64		      cmp	#'d	; Display Variables
    818  1ee5		       d0 06		      bne	dbgBasicDone
    819  1ee7
    820  1ee7		       20 98 14 	      jsr	PrintAllVars
    821  1eea		       18		      clc
    822  1eeb		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  1eed
    824  1eed		       20 1c 20    dbgBasicDone jsr	SetOutDebugEnd
    825  1ef0		       68		      pla
    826  1ef1		       a8		      tay
    827  1ef2		       4c c2 02    dbgBasicNone jmp	NextIL
    828  1ef5
    829  1ef5				   dbgBasicStop
    830  1ef5		       20 1c 20 	      jsr	SetOutDebugEnd
    831  1ef8		       68		      pla
    832  1ef9		       a8		      tay
    833  1efa		       4c 36 06 	      jmp	iFIN
    834  1efd							;
    835  1efd							;=====================================================
    836  1efd							; This is some debug logic which displays the current
    837  1efd							; value of the ILPC and the line buffer.
    838  1efd							;
    839  1efd		       24 40	   dbgLine    bit	ILTrace
    840  1eff		       30 01		      bmi	dbgPrt
    841  1f01		       60		      rts
    842  1f02				   dbgPrt
    843  1f02		       20 ee 1f 	      jsr	SetOutDebug
    844  1f05		       20 3d 14 	      jsr	puts
      0  1f08					      db	"ILPC: ",0
      1  1f08		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    846  1f0f		       a5 44		      lda	ILPC+1
    847  1f11		       20 20 14 	      jsr	OUTHEX
    848  1f14		       a5 43		      lda	ILPC
    849  1f16		       20 20 14 	      jsr	OUTHEX
    850  1f19		       a9 20		      lda	#SPACE
    851  1f1b		       20 ba 1f 	      jsr	VOUTCH
    852  1f1e		       a0 00		      ldy	#0
    853  1f20		       b1 43		      lda	(ILPC),y
    854  1f22		       20 20 14 	      jsr	OUTHEX
    855  1f25							;
    856  1f25							; Display the CURPTR value and offset
    857  1f25							;
    858  1f25		       20 3d 14 	      jsr	puts
      0  1f28					      db	", CURPTR: ",0
      1  1f28		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    860  1f33		       a5 50		      lda	CURPTR+1
    861  1f35		       20 20 14 	      jsr	OUTHEX
    862  1f38		       a5 4f		      lda	CURPTR
    863  1f3a		       20 20 14 	      jsr	OUTHEX
    864  1f3d		       a9 2b		      lda	#'+
    865  1f3f		       20 ba 1f 	      jsr	VOUTCH
    866  1f42		       a5 51		      lda	CUROFF
    867  1f44		       20 20 14 	      jsr	OUTHEX
    868  1f47							;
    869  1f47		       20 6c 1e 	      jsr	CRLF
    870  1f4a		       20 1c 20 	      jsr	SetOutDebugEnd
    871  1f4d		       20 80 1f 	      jsr	ILChkRange
    872  1f50		       b0 02		      bcs	dbgLineErr
    873  1f52		       18		      clc
    874  1f53		       60		      rts
    875  1f54
    876  1f54				   dbgLineErr
    877  1f54		       20 ee 1f 	      jsr	SetOutDebug
    878  1f57		       20 3d 14 	      jsr	puts
      0  1f5a					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1f5a		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    880  1f7b		       20 1c 20 	      jsr	SetOutDebugEnd
    881  1f7e		       38		      sec
    882  1f7f		       60		      rts
    883  1f80
    884  1f80		       a5 44	   ILChkRange lda	ILPC+1
    885  1f82		       c9 22		      cmp	#IL>>8
    886  1f84		       90 18		      bcc	ILBadRange
    887  1f86		       d0 06		      bne	ILChkHigh
    888  1f88
    889  1f88		       a5 43		      lda	ILPC
    890  1f8a		       c9 96		      cmp	#IL&$ff
    891  1f8c		       90 10		      bcc	ILBadRange
    892  1f8e
    893  1f8e		       a5 44	   ILChkHigh  lda	ILPC+1
    894  1f90		       c9 26		      cmp	#ILEND>>8
    895  1f92		       90 08		      bcc	ILGoodRange
    896  1f94		       d0 08		      bne	ILBadRange
    897  1f96
    898  1f96		       a5 43		      lda	ILPC
    899  1f98		       c9 24		      cmp	#ILEND&$ff
    900  1f9a		       b0 02		      bcs	ILBadRange
    901  1f9c
    902  1f9c		       18	   ILGoodRange clc
    903  1f9d		       60		      rts
    904  1f9e				   ILBadRange
    905  1f9e		       38		      sec
    906  1f9f		       60		      rts
    907  1fa0
    908  1fa0
    909  1fa0							;=====================================================
    910  1fa0							; Set output vector to the console output function
    911  1fa0							;
    912  1fa0				   SetOutConsole
    913  1fa0		       48		      pha
    914  1fa1		       a9 0c		      lda	#OUTCH&$ff
    915  1fa3		       8d b8 2f 	      sta	BOutVec
    916  1fa6		       a9 f0		      lda	#OUTCH>>8
    917  1fa8		       8d b9 2f 	      sta	BOutVec+1
    918  1fab		       68		      pla
    919  1fac		       60		      rts
    920  1fad
    921  1fad				   SetInConsole
    922  1fad		       48		      pha
    923  1fae		       a9 09		      lda	#GETCH&$ff
    924  1fb0		       8d ba 2f 	      sta	BInVec
    925  1fb3		       a9 f0		      lda	#GETCH>>8
    926  1fb5		       8d bb 2f 	      sta	BInVec+1
    927  1fb8		       68		      pla
    928  1fb9		       60		      rts
    929  1fba
    930  1fba							;=====================================================
    931  1fba							; Jump to the output/input function in BOutVec/BInVec
    932  1fba							;
    933  1fba		       6c b8 2f    VOUTCH     jmp	(BOutVec)
    934  1fbd		       6c ba 2f    VGETCH     jmp	(BInVec)
    935  1fc0
    936  1fc0
    937  1fc0							;====================================================
    938  1fc0							;Clear the terminal assume it is ansii or vt100
    939  1fc0							;
    940  1fc0				   iCLEARSCREEN
    941  1fc0		       20 3d 14 	      jsr	puts
      0  1fc3					      db	$1b,'[,'2,'J,0
      1  1fc3		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    943  1fc8		       4c c2 02 	      jmp	NextIL
    944  1fcb
    945  1fcb							;====================================================
    946  1fcb							; Push true and false onto math stack
    947  1fcb				   pushTrue
    948  1fcb		       a9 ff		      lda	#$ff
    949  1fcd		       85 52	   pushTF     sta	R0
    950  1fcf		       85 53		      sta	R0+1
    951  1fd1		       20 21 1d 	      jsr	pushR0
    952  1fd4		       60		      rts
    953  1fd5		       a9 00	   pushFalse  lda	#0
    954  1fd7		       f0 f4		      beq	pushTF
    955  1fd9
    956  1fd9							;======================================================
    957  1fd9							; Copy stack top to R1
    958  1fd9				   CopyStackR1
    959  1fd9		       98		      tya
    960  1fda		       48		      pha
    961  1fdb		       a4 4a		      ldy	MATHSTACKPTR
    962  1fdd		       88		      dey
    963  1fde		       b1 48		      lda	(MATHSTACK),y
    964  1fe0		       85 55		      sta	R1+1
    965  1fe2		       88		      dey
    966  1fe3		       b1 48		      lda	(MATHSTACK),y
    967  1fe5		       85 54		      sta	R1
    968  1fe7		       68		      pla
    969  1fe8		       a8		      tay
    970  1fe9		       60		      rts
    971  1fea
    972  1fea
    973  1fea							;====================================================
    974  1fea							;Swap the out debug call for standard calls
    975  1fea		       00 00	   DebugIOSave ds	2
    976  1fec		       00 00	   DebugInSave ds	2
    977  1fee				   SetOutDebug
    978  1fee		       ad b8 2f 	      lda	BOutVec
    979  1ff1		       8d ea 1f 	      sta	DebugIOSave
    980  1ff4		       ad b9 2f 	      lda	BOutVec+1
    981  1ff7		       8d eb 1f 	      sta	DebugIOSave+1
    982  1ffa		       a9 7f		      lda	#OUTDEBUG&$ff	; Put the Debug output
    983  1ffc		       8d b8 2f 	      sta	BOutVec
    984  1fff		       a9 20		      lda	#OUTDEBUG>>8
    985  2001		       8d b9 2f 	      sta	BOutVec+1
    986  2004		       60		      rts
    987  2005				   SetInDebug
    988  2005		       ad ba 2f 	      lda	BInVec
    989  2008		       8d ec 1f 	      sta	DebugInSave
    990  200b		       ad bb 2f 	      lda	BInVec+1
    991  200e		       8d ed 1f 	      sta	DebugInSave+1
    992  2011		       a9 83		      lda	#INDEBUG&$ff
    993  2013		       8d ba 2f 	      sta	BInVec
    994  2016		       a9 20		      lda	#INDEBUG>>8
    995  2018		       8d bb 2f 	      sta	BInVec+1
    996  201b		       60		      rts
    997  201c				   SetOutDebugEnd
    998  201c		       ad ea 1f 	      lda	DebugIOSave
    999  201f		       8d b8 2f 	      sta	BOutVec
   1000  2022		       ad eb 1f 	      lda	DebugIOSave+1
   1001  2025		       8d b9 2f 	      sta	BOutVec+1
   1002  2028		       60		      rts
   1003  2029				   SetInDebugEnd
   1004  2029		       ad ec 1f 	      lda	DebugInSave
   1005  202c		       8d ba 2f 	      sta	BInVec
   1006  202f		       ad eb 1f 	      lda	DebugIOSave+1
   1007  2032		       8d bb 2f 	      sta	BInVec+1
   1008  2035		       60		      rts
   1009  2036							;
   1010  2036							;====================================================
   1011  2036							; Set the input and output terminal address
   1012  2036							; The math stack stack byte is the output io slot
   1013  2036							; The math stack  is the input io slot
   1014  2036
   1015  2036				   iSetTerminal
   1016  2036		       20 b3 1d 	      jsr	popR0	; Process the output io addresses
   1017  2039		       20 61 20 	      jsr	CalcSlot
   1018  203c		       a5 52		      lda	R0
   1019  203e		       09 01		      ora	#1
   1020  2040		       8d 80 20 	      sta	TerminalOutputPort
   1021  2043		       a5 53		      lda	R0+1
   1022  2045		       8d 81 20 	      sta	TerminalOutputPort+1
   1023  2048
   1024  2048		       20 b3 1d 	      jsr	popR0	; Process the input io address
   1025  204b		       20 61 20 	      jsr	CalcSlot
   1026  204e		       a5 52		      lda	R0
   1027  2050		       8d 8b 20 	      sta	TerminalInputPort
   1028  2053		       09 01		      ora	#1
   1029  2055		       8d 84 20 	      sta	TerminalStatusPort
   1030  2058		       a5 53		      lda	R0+1
   1031  205a		       8d 8c 20 	      sta	TerminalInputPort+1
   1032  205d		       8d 85 20 	      sta	TerminalStatusPort+1
   1033  2060		       60		      rts
   1034  2061
   1035  2061							;===================================================
   1036  2061							; Calculate the slot address the the slot number
   1037  2061							; R0 contains the slot number 0-255
   1038  2061
   1039  2061				   CalcSlot
   1040  2061		       8a		      txa
   1041  2062		       48		      pha
   1042  2063		       a2 04		      ldx	#4
   1043  2065				   CalcSlotLoop
   1044  2065		       06 52		      asl	R0
   1045  2067		       26 53		      rol	R0+1
   1046  2069		       ca		      dex
   1047  206a		       d0 f9		      bne	CalcSlotLoop
   1048  206c		       a9 e0		      lda	#$E0
   1049  206e		       05 53		      ora	R0+1
   1050  2070		       85 53		      sta	R0+1
   1051  2072		       68		      pla
   1052  2073		       aa		      tax
   1053  2074		       60		      rts
   1054  2075							;
   1055  2075							;====================================================
   1056  2075							; Output to the Terminal/Debug console
   1057  2075							;     x = high address byte
   1058  2075							;     y = low address byte
   1059  2075							;     a = Terminator for string
   1060  2075				   TerminalWrite
   1061  2075				   DebugWrite
   1062  2075		       20 ee 1f 	      jsr	SetOutDebug
   1063  2078		       20 7b 14 	      jsr	PrtStr
   1064  207b		       20 1c 20 	      jsr	SetOutDebugEnd
   1065  207e		       60		      rts
   1066  207f
   1067  207f				   OUTDEBUG
   1068  207f		       8d		      .byte.b	$8D	; STA
   1069  2080				   TerminalOutputPort
   1070  2080		       01 e0	   DEBUGPORT  .word.w	$E001	; Dont check anything just output the byte
   1071  2082		       60		      RTS
   1072  2083
   1073  2083				   TerminalRead
   1074  2083				   INDEBUG
   1075  2083		       ad		      .byte.b	$AD	; LDA
   1076  2084				   TerminalStatusPort
   1077  2084		       00 e0	   DEBUGPORTSTATUS .word.w	$E000
   1078  2086
   1079  2086		       29 01		      and	#$01
   1080  2088		       f0 f9		      beq	INDEBUG
   1081  208a
   1082  208a		       ad		      .byte.b	$AD	; LDA
   1083  208b				   TerminalInputPort
   1084  208b		       01 e0	   DEBUGPORTIN .word.w	$E001
   1085  208d		       60		      rts
   1086  208e
   1087  208e							;======================================================================
   1088  208e							;Copy Quoted string to buffer, terminate with 0 byte
   1089  208e							; R0  Source tring points to tString type
   1090  208e							; x is terminator
   1091  208e							; R1 points to destinition location
   1092  208e							; On exit R0 contains length of copy Plus Term and leading bytes
   1093  208e
   1094  208e				   qstrcpy
   1095  208e		       20 21 1d 	      jsr	pushR0
   1096  2091		       20 de 20 	      jsr	IncR0	; point past the tString
   1097  2094		       20 de 20 	      jsr	IncR0	; Point Past the opening "
   1098  2097		       a2 22		      ldx	#'"	; copy Termination
   1099  2099		       20 b3 20 	      jsr	pstrcpy
   1100  209c		       20 de 20 	      jsr	IncR0	; point to "
   1101  209f		       20 de 20 	      jsr	IncR0	; Point to next free byte
   1102  20a2		       20 cb 1d 	      jsr	popR1
   1103  20a5		       38		      sec
   1104  20a6		       a5 52		      lda	R0
   1105  20a8		       e5 54		      sbc	R1
   1106  20aa		       85 52		      sta	R0
   1107  20ac		       a5 53		      lda	R0+1
   1108  20ae		       e5 55		      sbc	R1+1
   1109  20b0		       85 53		      sta	R0+1
   1110  20b2		       60		      rts
   1111  20b3
   1112  20b3							;=========================================================================
   1113  20b3							;Copy string from R0 to R1, terminator in x
   1114  20b3							; On exit    R0 contains the length of the copy
   1115  20b3				   pstrcpy
   1116  20b3		       a0 00		      ldy	#0
   1117  20b5		       86 58		      stx	R2
   1118  20b7
   1119  20b7				   strcpyLoop
   1120  20b7		       b1 52		      lda	(R0),y
   1121  20b9		       c5 58		      cmp	R2
   1122  20bb		       f0 0a		      beq	strcpyDone
   1123  20bd		       91 54		      sta	(R1),y
   1124  20bf		       20 de 20 	      jsr	IncR0
   1125  20c2		       20 cc 20 	      jsr	IncR1
   1126  20c5		       90 f0		      bcc	strcpyLoop
   1127  20c7				   strcpyDone
   1128  20c7		       a9 00		      lda	#0
   1129  20c9		       91 54		      sta	(R1),y
   1130  20cb
   1131  20cb		       60		      rts
   1132  20cc
   1133  20cc							;=========================================================================
   1134  20cc							; on exit c is set on overflow
   1135  20cc				   IncR1
   1136  20cc		       48		      pha
   1137  20cd		       18		      clc
   1138  20ce		       a9 01		      lda	#1
   1139  20d0		       65 54		      adc	R1
   1140  20d2		       85 54		      sta	R1
   1141  20d4		       90 06		      bcc	IncR1Done
   1142  20d6		       a9 00		      lda	#0
   1143  20d8		       65 55		      adc	R1+1
   1144  20da		       85 55		      sta	R1+1
   1145  20dc				   IncR1Done
   1146  20dc		       68		      pla
   1147  20dd		       60		      rts
   1148  20de							;=========================================================================
   1149  20de							; on exit c is set on overflow
   1150  20de				   IncR0
   1151  20de		       48		      pha
   1152  20df		       18		      clc
   1153  20e0		       a9 01		      lda	#1
   1154  20e2		       65 52		      adc	R0
   1155  20e4		       85 52		      sta	R0
   1156  20e6		       90 06		      bcc	IncR0Done
   1157  20e8		       a9 00		      lda	#0
   1158  20ea		       65 53		      adc	R0+1
   1159  20ec		       85 53		      sta	R0+1
   1160  20ee				   IncR0Done
   1161  20ee		       68		      pla
   1162  20ef		       60		      rts
   1163  20f0
   1164  20f0
   1165  20f0
   1166  20f0
   1167  20f0
   1168  20f0
   1169  20f0
   1170  20f0
   1171  20f0
   1172  20f0
   1173  20f0
   1174  20f0
   1175  20f0
   1176  20f0
   1177  20f0
   1178  20f0
------- FILE mytb.asm
   2409  20f0
   2410  20f0					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  20f0					      include	"storage.asm"
      1  20f0							;
      2  20f0							;=====================================================
      3  20f0							;=====================================================
      4  20f0							;=====================================================
      5  20f0							; This file contains the functions for saving and
      6  20f0							; restoring programs from some sort of mass storage
      7  20f0							; device.  This particular version is for using the
      8  20f0							; Corsham Tech SD Card System.
      9  20f0							;=====================================================
     10  20f0							;=====================================================
     11  20f0							;=====================================================
     12  20f0
     13 U2624					      seg.u	TBData
     14 U2624		       00	   diskBufLength ds	1
     15 U2625		       00	   diskBufOffset ds	1
     16 U2626		       00 00 00 00*DiskFileName ds	64
     17 U2666
     18  20f0					      SEG	Code
     19  20f0
     20  20f0							;
     21  20f0							;=====================================================
     22  20f0							; Open a file for reading as a program.  The next
     23  20f0							; thing on the line should be the filename.
     24  20f0							;
     25  20f0				   iOPENREAD
     26  20f0					      if	XKIM || CTMON65
     27  20f0		       20 0a 21 	      jsr	setFileName	;Set the file name to open
     28  20f3		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  20f6		       90 07		      bcc	Ropenok	;branch if opened ok
     30  20f8							;
     31  20f8							; Open failed
     32  20f8							;
     33  20f8		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  20fa		       a9 00	   Rdfail2    lda	#0
     35  20fc		       4c a9 06 	      jmp	iErr2
     36  20ff							;
     37  20ff							; Clear counts and offsets so the next read will
     38  20ff							; cause the file to be read.
     39  20ff							;
     40  20ff		       a9 00	   Ropenok    lda	#0
     41  2101		       8d 25 26 	      sta	diskBufOffset
     42  2104		       8d 24 26 	      sta	diskBufLength
     43  2107		       4c c2 02 	      jmp	NextIL
     44  210a					      endif
     45  210a
     46  210a							;===============================================================
     47  210a							; Set file name
     48  210a				   setFileName
     49  210a		       a4 51		      ldy	CUROFF
     50  210c		       b1 4f		      lda	(CURPTR),y
     51  210e		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  2110		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  2112
     54  2112		       18		      clc
     55  2113		       98		      tya
     56  2114		       65 4f		      adc	CURPTR
     57  2116		       85 52		      sta	R0	;LSB
     58  2118		       a5 50		      lda	CURPTR+1
     59  211a		       69 00		      adc	#0
     60  211c		       85 53		      sta	R0+1
     61  211e		       a9 26		      lda	#DiskFileName&$ff
     62  2120		       85 54		      sta	R1
     63  2122		       a9 26		      lda	#DiskFileName>>8
     64  2124		       85 55		      sta	R1+1
     65  2126		       20 8e 20 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  2129		       a5 52		      lda	R0
     67  212b		       18		      clc
     68  212c		       65 51		      adc	CUROFF	; add the current offset
     69  212e		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  2130
     71  2130		       a0 26		      ldy	#DiskFileName&$ff
     72  2132		       a2 26		      ldx	#DiskFileName>>8
     73  2134		       18		      clc
     74  2135		       60		      rts
     75  2136
     76  2136				   setFileNameNotFound
     77  2136		       68		      pla
     78  2137		       68		      pla		; remove the return address from the stack
     79  2138		       a9 00		      lda	#0
     80  213a		       a2 09		      ldx	#ERR_NO_FILENAME
     81  213c		       4c a9 06 	      jmp	iErr2
     82  213f
     83  213f							;
     84  213f							;==============================JUSTLOSTINTIME 08/02/2022========
     85  213f							;Remove a file from the disk
     86  213f				   iRMFILE
     87  213f					      if	XKIM || CTMON65
     88  213f		       20 0a 21 	      jsr	setFileName
     89  2142		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  2145		       90 07		      bcc	wrmOk	;branch if removed ok
     91  2147		       a9 00		      lda	#0
     92  2149		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  214b		       4c a9 06 	      jmp	iErr2
     94  214e				   wrmOk
     95  214e		       4c c2 02 	      jmp	NextIL
     96  2151
     97  2151					      endif
     98  2151							;
     99  2151							;=====================================================
    100  2151				   iOPENWRITE
    101  2151					      if	XKIM || CTMON65
    102  2151		       20 0a 21 	      jsr	setFileName
    103  2154		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  2157		       90 07		      bcc	Wopenok	;branch if opened ok
    105  2159							;
    106  2159							; Open failed
    107  2159							;
    108  2159		       a9 00	   Wdfail     lda	#0
    109  215b		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  215d		       4c a9 06 	      jmp	iErr2
    111  2160							;
    112  2160		       4c c2 02    Wopenok    jmp	NextIL
    113  2163					      endif
    114  2163							;
    115  2163							;=====================================================
    116  2163							; Gets a line of input from the disk file and puts it
    117  2163							; into LINBUF.
    118  2163							;
    119  2163							; On exit:
    120  2163							;    CURPTR points to LINBUF
    121  2163							;    LINBUF contains the line with 0 at the end.
    122  2163							;    Y has offset to first non-space character
    123  2163							;    CURROFF has the same as Y.
    124  2163							;
    125  2163				   iDGETLINE
    126  2163					      if	XKIM || CTMON65
    127  2163		       a2 27		      ldx	#LINBUF&$ff
    128  2165		       86 4f		      stx	CURPTR
    129  2167		       a2 2f		      ldx	#LINBUF>>8
    130  2169		       86 50		      stx	CURPTR+1
    131  216b							;
    132  216b		       a2 00		      ldx	#0	;offset
    133  216d		       8e ab 2f    iDgetLoop  stx	getlinx
    134  2170		       20 db 21 	      jsr	getNextFileByte
    135  2173		       b0 16		      bcs	iGetEOF
    136  2175		       c9 0d		      cmp	#CR
    137  2177		       f0 0d		      beq	iGetEOL
    138  2179		       c9 0a		      cmp	#LF
    139  217b		       f0 09		      beq	iGetEOL
    140  217d		       ae ab 2f 	      ldx	getlinx
    141  2180		       9d 27 2f 	      sta	LINBUF,x
    142  2183		       e8		      inx
    143  2184		       d0 e7		      bne	iDgetLoop
    144  2186							;
    145  2186							; Handle end of line.	If the line has nothing, loop
    146  2186							; back and get another line.
    147  2186							;
    148  2186		       ae ab 2f    iGetEOL    ldx	getlinx	;blank line?
    149  2189		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  218b							;
    151  218b							; This can fall through when there is a line, or
    152  218b							; called directly when EOF is encountered.
    153  218b							;
    154  218b		       ae ab 2f    iGetEOF    ldx	getlinx
    155  218e		       a9 00		      lda	#0
    156  2190		       9d 27 2f 	      sta	LINBUF,x
    157  2193		       a0 00		      ldy	#0
    158  2195		       20 63 1e 	      jsr	SkipSpaces
    159  2198		       20 de 10 	      jsr	ParseInputLine
    160  219b		       a9 db		      lda	#TOKENBUFFER&$ff
    161  219d		       85 4f		      sta	CURPTR
    162  219f		       a9 0f		      lda	#TOKENBUFFER>>8
    163  21a1		       85 50		      sta	CURPTR+1
    164  21a3		       a9 01		      lda	#1
    165  21a5		       85 51		      sta	CUROFF
    166  21a7		       4c c2 02 	      jmp	NextIL
    167  21aa					      endif
    168  21aa
    169  21aa							;
    170  21aa							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  21aa							; DISK
    172  21aa							;
    173  21aa				   iDDIR
    174  21aa					      if	XKIM || CTMON65
    175  21aa		       20 30 f0 	      jsr	DiskDir
    176  21ad							;
    177  21ad							; Get/Display each entry
    178  21ad							;
    179  21ad		       a2 26	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  21af		       a0 26		      ldy	#DiskFileName&$ff
    181  21b1		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  21b4		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  21b6		       20 3d 14 	      jsr	puts
      0  21b9					      db	"   ",0
      1  21b9		       20 20 20 00	      .byte.b	"   ",0
    185  21bd							; Print the line to the console
    186  21bd		       a2 26		      ldx	#DiskFileName>>8	;pointer to buffer
    187  21bf		       a0 26		      ldy	#DiskFileName&$ff
    188  21c1		       a5 00		      lda	0
    189  21c3		       20 7b 14 	      jsr	PrtStr	;else print name
    190  21c6		       20 18 f0 	      jsr	crlf
    191  21c9
    192  21c9		       4c ad 21 	      jmp	DiskDirLoop	;do next entry
    193  21cc
    194  21cc		       4c c2 02    DiskDirEnd jmp	NextIL
    195  21cf					      endif
    196  21cf							;
    197  21cf							;=====================================================
    198  21cf							; Does a LIST to a Disk file.
    199  21cf							;
    200  21cf				   iDLIST
    201  21cf					      if	XKIM || CTMON65
    202  21cf		       20 0a 22 	      jsr	SetOutDisk
    203  21d2		       4c 30 08 	      jmp	iLST2
    204  21d5					      endif
    205  21d5							;
    206  21d5							;=====================================================
    207  21d5							; Closes any pending disk file.  Okay to call if there
    208  21d5							; is no open file.
    209  21d5							;
    210  21d5				   iDCLOSE
    211  21d5					      if	XKIM || CTMON65
    212  21d5		       20 42 f0 	      jsr	DiskClose
    213  21d8		       4c c2 02 	      jmp	NextIL
    214  21db					      endif
    215  21db							;
    216  21db							;=====================================================
    217  21db							; This gets the next byte from an open disk file.  If
    218  21db							; there are no more bytes left, this returns C set.
    219  21db							; Else, C is clear and A contains the character.
    220  21db							;
    221  21db				   getNextFileByte
    222  21db					      if	XKIM || CTMON65
    223  21db		       ae 25 26 	      ldx	diskBufOffset
    224  21de		       ec 24 26 	      cpx	diskBufLength
    225  21e1		       d0 14		      bne	hasdata	;branch if still data
    226  21e3							;
    227  21e3							; There is no data left in the buffer, so read a
    228  21e3							; block from the SD system.
    229  21e3							;
    230  21e3		       a9 84		      lda	#BUFFER_SIZE
    231  21e5		       a2 df		      ldx	#buffer>>8
    232  21e7		       a0 0a		      ldy	#buffer&$ff
    233  21e9		       20 3c f0 	      jsr	DiskRead
    234  21ec		       b0 12		      bcs	getNextEof
    235  21ee							;
    236  21ee							; A contains the number of bytes actually read.
    237  21ee							;
    238  21ee		       8d 24 26 	      sta	diskBufLength	;save length
    239  21f1		       c9 00		      cmp	#0	;shouldn't happen
    240  21f3		       f0 0b		      beq	getNextEof
    241  21f5							;
    242  21f5		       a2 00		      ldx	#0
    243  21f7		       bd 0a df    hasdata    lda	buffer,x
    244  21fa		       e8		      inx
    245  21fb		       8e 25 26 	      stx	diskBufOffset
    246  21fe		       18		      clc
    247  21ff		       60		      rts
    248  2200							;
    249  2200		       a9 00	   getNextEof lda	#0
    250  2202		       8d 25 26 	      sta	diskBufOffset
    251  2205		       8d 24 26 	      sta	diskBufLength
    252  2208		       38		      sec
    253  2209		       60		      rts
    254  220a							;
    255  220a							;=====================================================
    256  220a							; Set output vector to the disk output function
    257  220a							;
    258  220a		       a9 15	   SetOutDisk lda	#DOUT&$ff
    259  220c		       8d b8 2f 	      sta	BOutVec
    260  220f		       a9 22		      lda	#DOUT/256
    261  2211		       8d b9 2f 	      sta	BOutVec+1
    262  2214		       60		      rts
    263  2215							;
    264  2215							;=====================================================
    265  2215
    266  2215		       8e 26 26    DOUT       stx	DiskFileName
    267  2218		       8c 27 26 	      sty	DiskFileName+1
    268  221b		       8d 0a df 	      sta	buffer
    269  221e		       a9 01		      lda	#1
    270  2220		       a0 0a		      ldy	#buffer&$ff
    271  2222		       a2 df		      ldx	#buffer>>8
    272  2224		       20 3f f0 	      jsr	DiskWrite
    273  2227		       ae 26 26 	      ldx	DiskFileName
    274  222a		       ac 27 26 	      ldy	DiskFileName+1
    275  222d
    276  222d							;
    277  222d							; need error checking here
    278  222d							;
    279  222d		       60		      rts
    280  222e					      endif
    281  222e
    282  222e
------- FILE mytb.asm
   2412  222e					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  222e					      include	"IL.inc"
      1  222e
      2  222e							;=====================================================
      3  222e							; IL.inc
      4  222e							; These are macros for IL instructions
      5  222e							;
      6  222e					      mac	dw
      7  222e					      .word	{0}
      8  222e					      endm
      9  222e					      mac	db
     10  222e					      .byte	{0}
     11  222e					      endm
     12  222e					      macro	xinit
     13  222e					      db	0
     14  222e					      endm		;reset the il to start clear all
     15  222e							;
     16  222e					      macro	done
     17  222e					      db	1
     18  222e					      endm		;print an error if not end of line
     19  222e							;
     20  222e					      macro	prs
     21  222e					      db	2
     22  222e					      endm		;print a quoted string
     23  222e							;
     24  222e					      macro	prn
     25  222e					      db	3
     26  222e					      endm		;print a number
     27  222e							;
     28  222e					      macro	spc
     29  222e					      db	4
     30  222e					      endm		;print space til new tabstop
     31  222e							;
     32  222e					      macro	nline
     33  222e					      db	5
     34  222e					      endm		;print a new line crlf
     35  222e							;
     36  222e							; My NXT is a bit different in that it takes one
     37  222e							; parameter, which is an address.  If the BASIC
     38  222e							; program is currently running then move to the
     39  222e							; next line and continue execution.  However, if
     40  222e							; in direct mode, jump to the specified IL label.
     41  222e							;
     42  222e					      macro	nxt
     43  222e					      db	6
     44  222e					      dw	{1}	; addr
     45  222e					      endm		; addr
     46  222e							;
     47  222e					      macro	xfer
     48  222e					      db	7
     49  222e					      endm
     50  222e							;
     51  222e					      macro	sav
     52  222e					      db	8
     53  222e					      db	{1}
     54  222e					      endm
     55  222e							;
     56  222e							;  Passed jump if function called, and true false value returned
     57  222e					      macro	rstr
     58  222e					      db	9
     59  222e					      db	({1}-*)-1	;(addr-*)-1
     60  222e					      db	{2}
     61  222e					      endm
     62  222e							;
     63  222e					      macro	cmpr
     64  222e					      db	10
     65  222e					      endm
     66  222e							;
     67  222e					      macro	innum
     68  222e					      db	11
     69  222e					      endm
     70  222e							;
     71  222e					      macro	fin
     72  222e					      db	12
     73  222e					      endm
     74  222e							;
     75  222e							; ERR is followed by an error number.	The error
     76  222e							; code is printed along with the line number.
     77  222e							; Control is passed to the statement set with
     78  222e							; the ERRGOTO statement.
     79  222e							;
     80  222e					      macro	errmsg
     81  222e					      db	13
     82  222e					      dw	{1}	;ecode
     83  222e					      endm		;ecode
     84  222e							;
     85  222e					      macro	add
     86  222e					      db	14
     87  222e					      endm
     88  222e							;
     89  222e					      macro	sub
     90  222e					      db	15
     91  222e					      endm
     92  222e							;
     93  222e					      macro	neg
     94  222e					      db	16
     95  222e					      endm
     96  222e							;
     97  222e					      macro	mul
     98  222e					      db	17
     99  222e					      endm
    100  222e							;
    101  222e					      macro	div
    102  222e					      db	18
    103  222e					      endm
    104  222e							;
    105  222e					      macro	store
    106  222e					      db	19
    107  222e					      endm
    108  222e							;
    109  222e					      macro	ind
    110  222e					      db	20
    111  222e					      endm
    112  222e							;
    113  222e					      macro	lst
    114  222e					      db	21
    115  222e					      endm
    116  222e							;
    117  222e					      macro	init
    118  222e					      db	22
    119  222e					      endm
    120  222e							;
    121  222e					      macro	getline
    122  222e					      db	23
    123  222e					      endm
    124  222e							;
    125  222e					      macro	insert
    126  222e					      db	24
    127  222e					      endm
    128  222e							;
    129  222e					      macro	rtn
    130  222e					      db	25
    131  222e					      endm
    132  222e							;
    133  222e					      macro	exit
    134  222e					      db	26
    135  222e					      endm
    136  222e							;
    137  222e					      macro	lit
    138  222e					      db	27
    139  222e					      dw	{1}	;value
    140  222e					      endm		; value LIT
    141  222e							;
    142  222e					      macro	call
    143  222e					      db	28
    144  222e					      dw	{1}	;addr
    145  222e					      endm		;addr
    146  222e							;
    147  222e							; IJMP will set the IL PC to the specified value.
    148  222e							;
    149  222e					      macro	ijmp
    150  222e					      db	29
    151  222e					      dw	{1}	;addr
    152  222e					      endm		;addr
    153  222e							;
    154  222e					      macro	vinit
    155  222e					      db	30
    156  222e					      endm
    157  222e							;
    158  222e							; ERRGOTO sets the point in the code where the IL
    159  222e							; interpreter will go after any error.
    160  222e							;
    161  222e					      macro	errgoto
    162  222e					      db	31
    163  222e					      dw	{1}	;addr
    164  222e					      endm		;addr
    165  222e							;
    166  222e					      macro	tst
    167  222e					      db	32
    168  222e					      db	({1}-*)-1	;(addr-*)-1
    169  222e					      db	{2},0	;string,0
    170  222e					      endm		;addr,string
    171  222e							;
    172  222e					      macro	tstv
    173  222e					      db	33
    174  222e					      db	({1}-*)-1	;(addr-*)-1
    175  222e					      endm		;addr
    176  222e							;
    177  222e					      macro	tstl
    178  222e					      db	34
    179  222e					      db	({1}-*)-1	;(addr-*)-1
    180  222e					      endm		;addr
    181  222e							;
    182  222e					      macro	tstn
    183  222e					      db	35
    184  222e					      db	({1}-*)-1	;(addr-*)-1
    185  222e					      endm		;addr
    186  222e							;
    187  222e							; FREE returns the amount of free RAM on top of
    188  222e							; the stack.  This is the amount of room the user
    189  222e							; program has available.
    190  222e							;
    191  222e					      macro	free
    192  222e					      db	36
    193  222e					      endm
    194  222e							;
    195  222e							; RANDOM takes the top item off the stack and
    196  222e							; replaces it with a random number that is
    197  222e							; MOD the initial value.  Ie, if the TOS is
    198  222e							; 42 then RANDOM returns a value from 0 to 41.
    199  222e							;
    200  222e					      macro	random
    201  222e					      db	37
    202  222e					      endm
    203  222e							;
    204  222e							; ABS will replace the top of stack with the
    205  222e							; absolute value.
    206  222e							;
    207  222e					      macro	abs
    208  222e					      db	38
    209  222e					      endm
    210  222e							;
    211  222e							; OPENREAD opens a file for reading, as in getting
    212  222e							; statements from it.
    213  222e							;
    214  222e					      macro	openread
    215  222e					      db	39
    216  222e					      endm
    217  222e							;
    218  222e							; OPENWRITE opens a file for writing, as in saving
    219  222e							; the current program to it.
    220  222e							;
    221  222e					      macro	openwrite
    222  222e					      db	40
    223  222e					      endm
    224  222e							;
    225  222e							; DCLOSE closes any open disk file.
    226  222e							;
    227  222e					      macro	dclose
    228  222e					      db	41
    229  222e					      endm
    230  222e							;
    231  222e							; DGETLINE gets one line from the disk file and puts it
    232  222e							; into LINBUFF.
    233  222e							;
    234  222e					      macro	dgetline
    235  222e					      db	42
    236  222e					      endm
    237  222e							;
    238  222e							; DLIST saves the program to an open disk file.
    239  222e							;
    240  222e					      macro	dlist
    241  222e					      db	43
    242  222e					      endm
    243  222e							; DDIR list the current directory
    244  222e							;
    245  222e					      macro	ddir
    246  222e					      db	44
    247  222e					      endm
    248  222e
    249  222e							; RMFILE remove a fle from disk
    250  222e					      macro	rmfile
    251  222e					      db	45
    252  222e					      endm
    253  222e
    254  222e							; CLEARSCREEN clear the screen
    255  222e					      macro	clearscreen
    256  222e					      db	46
    257  222e					      endm
    258  222e							; POKEMEM Poke value into memory
    259  222e					      macro	pokemem
    260  222e					      db	47
    261  222e					      endm
    262  222e							; PEEKMEM peek at value in memory
    263  222e					      macro	peekmem
    264  222e					      db	48
    265  222e					      endm
    266  222e							; TSTLET Test if the statement is a let without the keyword let
    267  222e					      macro	tstlet
    268  222e					      db	49
    269  222e					      db	({1}-*)-1	;(addr-*)-1
    270  222e					      endm		;addr
    271  222e							; TSTDONE if we reach the end of a statement
    272  222e					      macro	tstdone
    273  222e					      db	50
    274  222e					      db	({1}-*)-1	;(addr-*)-1
    275  222e					      endm		;addr
    276  222e							; GETCHAR	get a character from the input line leave it in RO
    277  222e					      macro	getchar
    278  222e					      db	51
    279  222e					      endm
    280  222e							; PUTCHAR	Put a character to the terminal
    281  222e					      macro	putchar
    282  222e					      db	52
    283  222e					      endm
    284  222e							; Call		Call a machine function return a to stack
    285  222e					      macro	callfunc
    286  222e					      db	53
    287  222e					      endm
    288  222e
    289  222e							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    290  222e					      macro	ibranch
    291  222e					      db	54
    292  222e					      endm
    293  222e
    294  222e							; TSTSTR	 Tests for the open quote in a string
    295  222e					      macro	tststr
    296  222e					      db	55
    297  222e					      db	({1}-*)-1	;(addr-*)-1
    298  222e					      endm
    299  222e							; SETIRQ	Sets the line number to run when an irq happens irq 550
    300  222e					      macro	setirq
    301  222e					      db	56
    302  222e					      endm
    303  222e
    304  222e							; TSTIRQ	Test for irq pending,
    305  222e							;		if so push the IRQ LINE NUMBER into RO, onto stack
    306  222e					      macro	tstirq
    307  222e					      db	57
    308  222e					      db	({1}-*)-1	;(addr-*)-1
    309  222e					      endm
    310  222e
    311  222e							; IRET    return from interupt service
    312  222e					      macro	iret
    313  222e					      db	58
    314  222e					      endm
    315  222e
    316  222e							; INSTR   read a string from the input
    317  222e					      macro	instr
    318  222e					      db	59
    319  222e					      endm
    320  222e
    321  222e							; MODULO Returns the remainder of the division
    322  222e					      macro	modulo
    323  222e					      db	60
    324  222e					      endm
    325  222e							; Set a task line
    326  222e					      macro	taskcreate
    327  222e					      db	61
    328  222e					      endm
    329  222e							; End a task
    330  222e					      macro	etask
    331  222e					      db	62
    332  222e					      endm
    333  222e							; Skip to next task
    334  222e					      macro	ntask
    335  222e					      db	63
    336  222e					      endm
    337  222e							; Subscript
    338  222e					      macro	subscript
    339  222e					      db	64
    340  222e					      db	{1}
    341  222e					      endm
    342  222e							; KILL Task
    343  222e					      macro	taskkill
    344  222e					      db	65
    345  222e					      endm
    346  222e							; STAT Task
    347  222e					      macro	taskstat
    348  222e					      db	66
    349  222e					      endm
    350  222e							;  output value as hex
    351  222e					      macro	hexprt
    352  222e					      db	67
    353  222e					      endm
    354  222e							;  Read in background has completed
    355  222e					      macro	readcomplete
    356  222e					      db	68
    357  222e					      endm
    358  222e							;  ReadInput line
    359  222e					      macro	readstart
    360  222e					      db	69
    361  222e					      endm
    362  222e							; Startio request
    363  222e					      macro	startio
    364  222e					      db	70
    365  222e					      endm
    366  222e							; Endio
    367  222e					      macro	endio
    368  222e					      db	71
    369  222e					      endm
    370  222e							; Logical not
    371  222e					      macro	lognot
    372  222e					      db	72
    373  222e					      endm
    374  222e							; Logical OR
    375  222e					      macro	logor
    376  222e					      db	73
    377  222e					      endm
    378  222e							;Logical and
    379  222e					      macro	logand
    380  222e					      db	74
    381  222e					      endm
    382  222e							;Logical XOR
    383  222e					      macro	logxor
    384  222e					      db	75
    385  222e					      endm
    386  222e							;Wait for task to complete, or list of tasks
    387  222e					      macro	wtask
    388  222e					      db	76
    389  222e					      db	({1}-*)-1	;(addr-*)-1
    390  222e					      endm
    391  222e							;Get the current task id
    392  222e					      MACRO	taskpid
    393  222e					      db	77
    394  222e					      endm
    395  222e							;Trace the basic execution
    396  222e					      Macro	traceprogram
    397  222e					      db	78
    398  222e					      endm
    399  222e							;Do a basic program Trace
    400  222e					      Macro	debugbasic
    401  222e					      db	79
    402  222e					      endm
    403  222e
    404  222e							; Inter Process communications instructions
    405  222e					      Macro	ipcsend
    406  222e					      db	80
    407  222e					      endm
    408  222e					      Macro	ipcreceive
    409  222e					      db	81
    410  222e					      endm
    411  222e					      Macro	ipccheck
    412  222e					      db	82
    413  222e					      endm
    414  222e					      Macro	ipcio
    415  222e					      db	83
    416  222e					      endm
    417  222e					      Macro	pushmathstack
    418  222e					      db	84
    419  222e					      endm
    420  222e					      Macro	popmathstack
    421  222e					      db	85
    422  222e					      endm
    423  222e					      Macro	savemathstack
    424  222e					      db	86
    425  222e					      endm
    426  222e					      Macro	restoremathstack
    427  222e					      db	87
    428  222e					      endm
    429  222e					      Macro	incparmcount
    430  222e					      db	88
    431  222e					      endm
    432  222e					      Macro	taskgetmathstack
    433  222e					      db	89
    434  222e					      endm
    435  222e					      Macro	taskenable
    436  222e					      db	90
    437  222e					      endm
    438  222e					      Macro	tasksuspend
    439  222e					      db	91
    440  222e					      endm
    441  222e					      Macro	taskputmathptr
    442  222e					      db	92
    443  222e					      endm
    444  222e							; Test for an extension type of variable that allows access to a tasks variables
    445  222e							; Using  PID!<Var name>
    446  222e					      Macro	tstvt
    447  222e					      db	93
    448  222e					      db	({1}-*)-1	;(addr-*)-1
    449  222e					      endm
    450  222e
    451  222e							; Provide access to R2 for the IL program
    452  222e					      Macro	setr2
    453  222e					      db	94
    454  222e					      db	{1}	; R2 is only one byte
    455  222e					      endm
    456  222e							;Move stack top to temp
    457  222e					      Macro	stk2tmp
    458  222e					      db	95
    459  222e					      endm
    460  222e
    461  222e					      Macro	tmp2stk
    462  222e					      db	96
    463  222e					      endm
    464  222e
    465  222e					      Macro	tstbyte
    466  222e					      db	97
    467  222e					      db	({1}-*)-1	; (addr-*)-1 goto if match
    468  222e					      dw	{2}	; address to check
    469  222e					      db	{3}	; Value to compare
    470  222e					      endm
    471  222e
    472  222e					      Macro	incvar
    473  222e					      db	98
    474  222e					      endm
    475  222e					      Macro	decvar
    476  222e					      db	99
    477  222e					      endm
    478  222e
    479  222e					      Macro	slice
    480  222e					      db	100
    481  222e					      endm
    482  222e
    483  222e					      Macro	tstb
    484  222e					      db	101
    485  222e					      db	({1}-*)-1
    486  222e					      db	{2}
    487  222e					      endm
    488  222e
    489  222e					      Macro	tstw
    490  222e					      db	102
    491  222e					      db	({1}-*)-1
    492  222e					      dw	{2}
    493  222e					      endm
    494  222e
    495  222e					      Macro	ongoto
    496  222e					      db	103
    497  222e					      dw	{1}
    498  222e					      dw	{2}
    499  222e					      endm
    500  222e
    501  222e					      Macro	tstrelop
    502  222e					      db	104
    503  222e					      db	({1}-*)-1
    504  222e					      endm
    505  222e
    506  222e					      Macro	repeatline
    507  222e					      db	105
    508  222e					      endm
    509  222e
    510  222e							; Check for a precompiled branch, will take branch if precompiled value present
    511  222e					      Macro	tstbranch
    512  222e					      db	106
    513  222e					      db	({1}-*)-1
    514  222e					      endm
    515  222e
    516  222e					      Macro	fastxfer
    517  222e					      db	107
    518  222e					      endm
    519  222e							; Set all io to to a terminal for input output
    520  222e							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    521  222e							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    522  222e					      Macro	setterminal
    523  222e					      db	108
    524  222e					      endm
------- FILE mytb.asm
   2414  222e							;
   2415  222e				  -	      if	FIXED
   2416  222e				  -	      org	$1000
   2417  222e					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  222e					      include	"basic.il"
      1  222e					      seg	Code
      2  222e							; on goto table
      3  222e							; format :   first byte is value Base, subtracted from value found
      4  222e							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  222e				   BasicStmts
      0  222e					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  222e		       01 1f		      .byte.b	kBeginKey,(kKeyCount+1)
      0  2230					      dw	ekLet
      1  2230		       a9 22		      .word.w	ekLet
      0  2232					      dw	ekInc
      1  2232		       e0 22		      .word.w	ekInc
      0  2234					      dw	ekDec
      1  2234		       f0 22		      .word.w	ekDec
      0  2236					      dw	ekIreturn
      1  2236		       00 23		      .word.w	ekIreturn
      0  2238					      dw	ekIf
      1  2238		       05 23		      .word.w	ekIf
      0  223a					      dw	ekThen
      1  223a		       0b 23		      .word.w	ekThen
      0  223c					      dw	ekGoto
      1  223c		       0f 23		      .word.w	ekGoto
      0  223e					      dw	ekGosub
      1  223e		       23 23		      .word.w	ekGosub
      0  2240					      dw	ekReturn
      1  2240		       2a 23		      .word.w	ekReturn
      0  2242					      dw	ekRem
      1  2242		       4a 23		      .word.w	ekRem
      0  2244					      dw	ekPrint	; should be entry for print
      1  2244		       50 23		      .word.w	ekPrint
      0  2246					      dw	ekTaske
      1  2246		       9d 23		      .word.w	ekTaske
      0  2248					      dw	ekTaskn
      1  2248		       b3 23		      .word.w	ekTaskn
      0  224a					      dw	ekTaskw
      1  224a		       ba 23		      .word.w	ekTaskw
      0  224c					      dw	ekPoke
      1  224c		       d5 23		      .word.w	ekPoke
      0  224e					      dw	ekPutch
      1  224e		       ec 23		      .word.w	ekPutch
      0  2250					      dw	ekCls
      1  2250		       f7 23		      .word.w	ekCls
      0  2252					      dw	ekInput
      1  2252		       fe 23		      .word.w	ekInput
      0  2254					      dw	ekEnd
      1  2254		       26 24		      .word.w	ekEnd
      0  2256					      dw	ekIrq
      1  2256		       2a 24		      .word.w	ekIrq
      0  2258					      dw	ekKill
      1  2258		       35 24		      .word.w	ekKill
      0  225a					      dw	ekList
      1  225a		       40 24		      .word.w	ekList
      0  225c					      dw	ekRun
      1  225c		       45 24		      .word.w	ekRun
      0  225e					      dw	ekNew
      1  225e		       4e 24		      .word.w	ekNew
      0  2260					      dw	ekSlice
      1  2260		       52 24		      .word.w	ekSlice
      0  2262					      dw	ekTrace
      1  2262		       5d 24		      .word.w	ekTrace
      0  2264					      dw	ekExit
      1  2264		       6e 24		      .word.w	ekExit
      0  2266					      dw	ekSave
      1  2266		       6f 24		      .word.w	ekSave
      0  2268					      dw	ekLoad
      1  2268		       75 24		      .word.w	ekLoad
      0  226a					      dw	ekErase
      1  226a		       88 24		      .word.w	ekErase
      0  226c					      dw	ekDir
      1  226c		       81 24		      .word.w	ekDir
     38  226e							;
     39  226e							; Logical operators
      0  226e				   BasicLogical db	kOr,3
      1  226e		       21 03		      .byte.b	kOr,3
      0  2270					      dw	ekOr
      1  2270		       a5 24		      .word.w	ekOr
      0  2272					      dw	ekXor
      1  2272		       aa 24		      .word.w	ekXor
      0  2274					      dw	ekAnd
      1  2274		       a0 24		      .word.w	ekAnd
     44  2276
     45  2276							;functions returning values
     46  2276
      0  2276				   BasicFuncs db	kBeginFunc,kFuncCount
      1  2276		       24 0f		      .byte.b	kBeginFunc,kFuncCount
      0  2278					      dw	ekTrue
      1  2278		       0a 25		      .word.w	ekTrue
      0  227a					      dw	ekFalse
      1  227a		       0e 25		      .word.w	ekFalse
      0  227c					      dw	ekFree
      1  227c		       12 25		      .word.w	ekFree
      0  227e					      dw	ekGetch
      1  227e		       1a 25		      .word.w	ekGetch
      0  2280					      dw	ekPeek
      1  2280		       22 25		      .word.w	ekPeek
      0  2282					      dw	ekTask
      1  2282		       2d 25		      .word.w	ekTask
      0  2284					      dw	ekIpcc
      1  2284		       79 25		      .word.w	ekIpcc
      0  2286					      dw	ekIpcs
      1  2286		       54 25		      .word.w	ekIpcs
      0  2288					      dw	ekIpcr
      1  2288		       65 25		      .word.w	ekIpcr
      0  228a					      dw	ekRnd
      1  228a		       84 25		      .word.w	ekRnd
      0  228c					      dw	ekStat
      1  228c		       a2 25		      .word.w	ekStat
      0  228e					      dw	ekAbs
      1  228e		       97 25		      .word.w	ekAbs
      0  2290					      dw	ekCall
      1  2290		       af 25		      .word.w	ekCall
      0  2292					      dw	ekGofn
      1  2292		       c8 25		      .word.w	ekGofn
      0  2294					      dw	ekPid
      1  2294		       ad 25		      .word.w	ekPid
     63  2296
     64  2296
     65  2296							;=====================================================
     66  2296							; This is the IL of the BASIC (or whatever) language.
     67  2296							; Because of the way macros are implemented by as65,
     68  2296							; labels can't be on the same line as a macro
     69  2296							; invocation, so that's why labels are on separate
     70  2296							; lines.
     71  2296							;
     72  2296		       22 96	   IL	      equ	*
     73  2296
     74  2296							;THE IL CONTROL SECTION
     75  2296
     76  2296				   START
      0  2296					      INIT		;INITIALIZE
      0  2296					      db	22
      1  2296		       16		      .byte.b	22
      0  2297					      NLINE		;WRITE CRLF
      0  2297					      db	5
      1  2297		       05		      .byte.b	5
      0  2298					      ERRGOTO	CO	;where to go after an error
      0  2298					      db	31
      1  2298		       1f		      .byte.b	31
      0  2299					      dw	CO
      1  2299		       9c 22		      .word.w	CO
      0  229b					      VINIT		;clear all variables
      0  229b					      db	30
      1  229b		       1e		      .byte.b	30
     81  229c							;
     82  229c							; This is where we jump to get a line of commands or
     83  229c							; a program from the user.
     84  229c							;
     85  229c				   CO
      0  229c					      GETLINE		;WRITE PROMPT AND GET LINE
      0  229c					      db	23
      1  229c		       17		      .byte.b	23
      0  229d					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  229d					      db	34
      1  229d		       22		      .byte.b	34
      0  229e					      db	(XEC-*)-1
      1  229e		       04		      .byte.b	(XEC-*)-1
      0  229f					      INSERT		;INSERT IT (MAY BE DELETE)
      0  229f					      db	24
      1  229f		       18		      .byte.b	24
      0  22a0					      IJMP	CO
      0  22a0					      db	29
      1  22a0		       1d		      .byte.b	29
      0  22a1					      dw	CO
      1  22a1		       9c 22		      .word.w	CO
     90  22a3				   XEC
      0  22a3					      XINIT		;INITIALIZE
      0  22a3					      db	0
      1  22a3		       00		      .byte.b	0
     92  22a4							;============================================================================
     93  22a4							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     94  22a4							;
     95  22a4				   STMT
      0  22a4					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  22a4					      db	79
      1  22a4		       4f		      .byte.b	79
      0  22a5					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  22a5					      db	57
      1  22a5		       39		      .byte.b	57
      0  22a6					      db	(notirq-*)-1
      1  22a6		       00		      .byte.b	(notirq-*)-1
     98  22a7							;==========================================================================================
     99  22a7							; Process a let statement implied or explicit.
    100  22a7							;
    101  22a7				   notirq
      0  22a7					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  22a7					      db	49
      1  22a7		       31		      .byte.b	49
      0  22a8					      db	(DoVector-*)-1
      1  22a8		       32		      .byte.b	(DoVector-*)-1
    103  22a9				   ekLet
      0  22a9					      TSTV	ERRVEC2	; YES, PLACE VAR ADDRESS ON AESTK
      0  22a9					      db	33
      1  22a9		       21		      .byte.b	33
      0  22aa					      db	(ERRVEC2-*)-1
      1  22aa		       2d		      .byte.b	(ERRVEC2-*)-1
      0  22ab					      TSTB	LETSCONT,oBang	; allow to assign to another Tasks Variable
      0  22ab					      db	101
      1  22ab		       65		      .byte.b	101
      0  22ac					      db	(LETSCONT-*)-1
      1  22ac		       04		      .byte.b	(LETSCONT-*)-1
      0  22ad					      db	oBang
      1  22ad		       e8		      .byte.b	oBang
      0  22ae					      IND
      0  22ae					      db	20
      1  22ae		       14		      .byte.b	20
      0  22af					      TSTVT	ERRVEC2
      0  22af					      db	93
      1  22af		       5d		      .byte.b	93
      0  22b0					      db	(ERRVEC2-*)-1
      1  22b0		       27		      .byte.b	(ERRVEC2-*)-1
    108  22b1
    109  22b1				   LETSCONT
      0  22b1					      TSTB	LETSQBRACKET,oEqual	; (This line originally omitted)
      0  22b1					      db	101
      1  22b1		       65		      .byte.b	101
      0  22b2					      db	(LETSQBRACKET-*)-1
      1  22b2		       04		      .byte.b	(LETSQBRACKET-*)-1
      0  22b3					      db	oEqual
      1  22b3		       f2		      .byte.b	oEqual
      0  22b4					      IJMP	LETBE
      0  22b4					      db	29
      1  22b4		       1d		      .byte.b	29
      0  22b5					      dw	LETBE
      1  22b5		       cd 22		      .word.w	LETBE
    112  22b7
    113  22b7				   LETSQBRACKET 		; is this an array access ?
    114  22b7
      0  22b7					      TSTB	ERRVEC2,oLeftSQBracket	; [
      0  22b7					      db	101
      1  22b7		       65		      .byte.b	101
      0  22b8					      db	(ERRVEC2-*)-1
      1  22b8		       1f		      .byte.b	(ERRVEC2-*)-1
      0  22b9					      db	oLeftSQBracket
      1  22b9		       e4		      .byte.b	oLeftSQBracket
      0  22ba					      CALL	EXPR
      0  22ba					      db	28
      1  22ba		       1c		      .byte.b	28
      0  22bb					      dw	EXPR
      1  22bb		       90 24		      .word.w	EXPR
      0  22bd					      TSTB	ERRVEC2,oRightSQBracket	; ]
      0  22bd					      db	101
      1  22bd		       65		      .byte.b	101
      0  22be					      db	(ERRVEC2-*)-1
      1  22be		       19		      .byte.b	(ERRVEC2-*)-1
      0  22bf					      db	oRightSQBracket
      1  22bf		       e5		      .byte.b	oRightSQBracket
      0  22c0					      TSTB	LETINDEX_INTEGER,oDollar
      0  22c0					      db	101
      1  22c0		       65		      .byte.b	101
      0  22c1					      db	(LETINDEX_INTEGER-*)-1
      1  22c1		       06		      .byte.b	(LETINDEX_INTEGER-*)-1
      0  22c2					      db	oDollar
      1  22c2		       e7		      .byte.b	oDollar
      0  22c3					      SUBSCRIPT	1
      0  22c3					      db	64
      1  22c3		       40		      .byte.b	64
      0  22c4					      db	1
      1  22c4		       01		      .byte.b	1
      0  22c5					      IJMP	LETINDEX_ALL
      0  22c5					      db	29
      1  22c5		       1d		      .byte.b	29
      0  22c6					      dw	LETINDEX_ALL
      1  22c6		       ca 22		      .word.w	LETINDEX_ALL
    121  22c8				   LETINDEX_INTEGER
      0  22c8					      SUBSCRIPT	0
      0  22c8					      db	64
      1  22c8		       40		      .byte.b	64
      0  22c9					      db	0
      1  22c9		       00		      .byte.b	0
    123  22ca
    124  22ca				   LETINDEX_ALL
      0  22ca					      TSTB	ERRVEC2,oEqual	; (This line originally omitted)
      0  22ca					      db	101
      1  22ca		       65		      .byte.b	101
      0  22cb					      db	(ERRVEC2-*)-1
      1  22cb		       0c		      .byte.b	(ERRVEC2-*)-1
      0  22cc					      db	oEqual
      1  22cc		       f2		      .byte.b	oEqual
    126  22cd				   LETBE
    127  22cd
      0  22cd					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  22cd					      db	28
      1  22cd		       1c		      .byte.b	28
      0  22ce					      dw	EXPR
      1  22ce		       90 24		      .word.w	EXPR
      0  22d0					      DONE		; REPORT ERROR IF NOT NEXT
      0  22d0					      db	1
      1  22d0		       01		      .byte.b	1
      0  22d1					      STORE		; STORE RESULT
      0  22d1					      db	19
      1  22d1		       13		      .byte.b	19
      0  22d2					      NXT	CO	; AND SEQUENCE TO NEXT
      0  22d2					      db	6
      1  22d2		       06		      .byte.b	6
      0  22d3					      dw	CO
      1  22d3		       9c 22		      .word.w	CO
      0  22d5					      IJMP	STMT
      0  22d5					      db	29
      1  22d5		       1d		      .byte.b	29
      0  22d6					      dw	STMT
      1  22d6		       a4 22		      .word.w	STMT
    133  22d8				   ERRVEC2
      0  22d8					      IJMP	UNKNOWN
      0  22d8					      db	29
      1  22d8		       1d		      .byte.b	29
      0  22d9					      dw	UNKNOWN
      1  22d9		       8c 24		      .word.w	UNKNOWN
    135  22db							;=============================================================
    136  22db							;Branch on a valid statement start
    137  22db				   DoVector
      0  22db					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  22db					      db	103
      1  22db		       67		      .byte.b	103
      0  22dc					      dw	BasicStmts
      1  22dc		       2e 22		      .word.w	BasicStmts
      0  22de					      dw	UNKNOWN
      1  22de		       8c 24		      .word.w	UNKNOWN
    139  22e0							;This will never return here!
    140  22e0							;=============================================================
    141  22e0							; Inc or dec a variable
    142  22e0							;S1:
    143  22e0							;	  TSTB	     S1Dec,kInc 		    ; Increment variable
    144  22e0				   ekInc
      0  22e0					      TSTV	ERRVEC2	; Verify we have a variable
      0  22e0					      db	33
      1  22e0		       21		      .byte.b	33
      0  22e1					      db	(ERRVEC2-*)-1
      1  22e1		       f6		      .byte.b	(ERRVEC2-*)-1
      0  22e2					      TSTB	eDoInc,oBang	; Allow to inc or dec other tasks variables
      0  22e2					      db	101
      1  22e2		       65		      .byte.b	101
      0  22e3					      db	(eDoInc-*)-1
      1  22e3		       04		      .byte.b	(eDoInc-*)-1
      0  22e4					      db	oBang
      1  22e4		       e8		      .byte.b	oBang
      0  22e5					      IND		; we just got a pid
      0  22e5					      db	20
      1  22e5		       14		      .byte.b	20
      0  22e6					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  22e6					      db	93
      1  22e6		       5d		      .byte.b	93
      0  22e7					      db	(ERRVEC2-*)-1
      1  22e7		       f0		      .byte.b	(ERRVEC2-*)-1
    149  22e8				   eDoInc
      0  22e8					      INCVAR		; Do the increment of the variable
      0  22e8					      db	98
      1  22e8		       62		      .byte.b	98
      0  22e9					      DONE		; Test for end of line or end of statement ":"
      0  22e9					      db	1
      1  22e9		       01		      .byte.b	1
      0  22ea					      NXT	CO	; Get the next statement, branch CO if end of program
      0  22ea					      db	6
      1  22ea		       06		      .byte.b	6
      0  22eb					      dw	CO
      1  22eb		       9c 22		      .word.w	CO
      0  22ed					      IJMP	STMT	; Process the next statement
      0  22ed					      db	29
      1  22ed		       1d		      .byte.b	29
      0  22ee					      dw	STMT
      1  22ee		       a4 22		      .word.w	STMT
    154  22f0							;S1Dec:
    155  22f0							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    156  22f0				   ekDec
      0  22f0					      TSTV	ERRVEC2	; Must be followed by a variable
      0  22f0					      db	33
      1  22f0		       21		      .byte.b	33
      0  22f1					      db	(ERRVEC2-*)-1
      1  22f1		       e6		      .byte.b	(ERRVEC2-*)-1
      0  22f2					      TSTB	eDoDec,oBang	; Allow to inc or dec other tasks variables
      0  22f2					      db	101
      1  22f2		       65		      .byte.b	101
      0  22f3					      db	(eDoDec-*)-1
      1  22f3		       04		      .byte.b	(eDoDec-*)-1
      0  22f4					      db	oBang
      1  22f4		       e8		      .byte.b	oBang
      0  22f5					      IND		; we just got a pid
      0  22f5					      db	20
      1  22f5		       14		      .byte.b	20
      0  22f6					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  22f6					      db	93
      1  22f6		       5d		      .byte.b	93
      0  22f7					      db	(ERRVEC2-*)-1
      1  22f7		       e0		      .byte.b	(ERRVEC2-*)-1
    161  22f8				   eDoDec
      0  22f8					      DECVAR		; Decrement the actual variable
      0  22f8					      db	99
      1  22f8		       63		      .byte.b	99
      0  22f9					      DONE		; Test if end of line or : statement
      0  22f9					      db	1
      1  22f9		       01		      .byte.b	1
      0  22fa					      NXT	CO	; If at end of program then got the console
      0  22fa					      db	6
      1  22fa		       06		      .byte.b	6
      0  22fb					      dw	CO
      1  22fb		       9c 22		      .word.w	CO
      0  22fd					      IJMP	STMT	; Process the next statement of command line
      0  22fd					      db	29
      1  22fd		       1d		      .byte.b	29
      0  22fe					      dw	STMT
      1  22fe		       a4 22		      .word.w	STMT
    166  2300							;=============================================================================================================================
    167  2300							; iret or ireturn, Return from interupt process
    168  2300							;
    169  2300							;S1Iret:
    170  2300							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    171  2300							;S1Sa:
    172  2300				   ekIreturn
      0  2300					      DONE		; Must be only thing on the line
      0  2300					      db	1
      1  2300		       01		      .byte.b	1
      0  2301					      IRET		; RESTORE LINE NUMBER OF CALL
      0  2301					      db	58
      1  2301		       3a		      .byte.b	58
      0  2302					      IJMP	STMT
      0  2302					      db	29
      1  2302		       1d		      .byte.b	29
      0  2303					      dw	STMT
      1  2303		       a4 22		      .word.w	STMT
    176  2305							;==============================================================================================================================
    177  2305							;Process if statement, if true then process all statements until end of line reached
    178  2305							;S1S1:
    179  2305							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    180  2305				   ekIf
      0  2305					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  2305					      db	28
      1  2305		       1c		      .byte.b	28
      0  2306					      dw	EXPR
      1  2306		       90 24		      .word.w	EXPR
      0  2308					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  2308					      db	101
      1  2308		       65		      .byte.b	101
      0  2309					      db	(S1W-*)-1
      1  2309		       01		      .byte.b	(S1W-*)-1
      0  230a					      db	kThen
      1  230a		       06		      .byte.b	kThen
    183  230b				   ekThen
    184  230b				   S1W
      0  230b					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  230b					      db	54
      1  230b		       36		      .byte.b	54
      0  230c					      IJMP	STMT
      0  230c					      db	29
      1  230c		       1d		      .byte.b	29
      0  230d					      dw	STMT
      1  230d		       a4 22		      .word.w	STMT
    187  230f							;===============================================================================================================================
    188  230f							; Test for GOTO
    189  230f							;S1Z:
    190  230f							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    191  230f							;
    192  230f				   ekGoto
      0  230f					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  230f					      db	106
      1  230f		       6a		      .byte.b	106
      0  2310					      db	(ekGotoCompiled-*)-1
      1  2310		       0e		      .byte.b	(ekGotoCompiled-*)-1
    194  2311							; Else we have the address ad just goto that address
      0  2311					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  2311					      db	101
      1  2311		       65		      .byte.b	101
      0  2312					      db	(ekGotoLine-*)-1
      1  2312		       05		      .byte.b	(ekGotoLine-*)-1
      0  2313					      db	oPeriod
      1  2313		       e9		      .byte.b	oPeriod
      0  2314					      REPEATLINE		; Repeat the same line again
      0  2314					      db	105
      1  2314		       69		      .byte.b	105
      0  2315					      IJMP	STMT	; Go do the statement
      0  2315					      db	29
      1  2315		       1d		      .byte.b	29
      0  2316					      dw	STMT
      1  2316		       a4 22		      .word.w	STMT
    198  2318
    199  2318				   ekGotoLine
      0  2318					      CALL	EXPR	; GET LABEL
      0  2318					      db	28
      1  2318		       1c		      .byte.b	28
      0  2319					      dw	EXPR
      1  2319		       90 24		      .word.w	EXPR
      0  231b					      lit	0	; Place indicator for line num on stack
      0  231b					      db	27
      1  231b		       1b		      .byte.b	27
      0  231c					      dw	0
      1  231c		       00 00		      .word.w	0
      0  231e					      FASTXFER
      0  231e					      db	107
      1  231e		       6b		      .byte.b	107
    203  231f				   ekGotoCompiled
      0  231f					      lit	1	; tell it that mempointer on the stack
      0  231f					      db	27
      1  231f		       1b		      .byte.b	27
      0  2320					      dw	1
      1  2320		       01 00		      .word.w	1
      0  2322					      FASTXFER		; put top of stack into curptr
      0  2322					      db	107
      1  2322		       6b		      .byte.b	107
    206  2323
    207  2323							;===============================================================================================================================
    208  2323							; Process gosub / function
    209  2323							;
    210  2323							;S2:
    211  2323							;	  TSTB	     S2b,kGosub 		    ; ERROR IF NO MATCH
    212  2323				   ekGosub
      0  2323					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  2323					      db	28
      1  2323		       1c		      .byte.b	28
      0  2324					      dw	GOSUBSTATEMENT
      1  2324		       fd 25		      .word.w	GOSUBSTATEMENT
      0  2326					      DONE		; ERROR IF CR NOT NEXT
      0  2326					      db	1
      1  2326		       01		      .byte.b	1
      0  2327					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  2327					      db	8
      1  2327		       08		      .byte.b	8
      0  2328					      db	GOSUB_RTN
      1  2328		       01		      .byte.b	GOSUB_RTN
      0  2329					      FASTXFER		; AND JUMP to sub rtn
      0  2329					      db	107
      1  2329		       6b		      .byte.b	107
    217  232a							;
    218  232a							; End of gosub processing
    219  232a							;===============================================================================================================================
    220  232a							; Return from a gosub
    221  232a							;S2b:
    222  232a							;	  TSTB	    S2a,kReturn 		   ; Speed up pocessing but more memory
    223  232a				   ekReturn
      0  232a					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  232a					      db	101
      1  232a		       65		      .byte.b	101
      0  232b					      db	(S2NoReturnValue-*)-1
      1  232b		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  232c					      db	oLeftBracket
      1  232c		       e0		      .byte.b	oLeftBracket
      0  232d					      CALL	EXPR
      0  232d					      db	28
      1  232d		       1c		      .byte.b	28
      0  232e					      dw	EXPR
      1  232e		       90 24		      .word.w	EXPR
      0  2330					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  2330					      db	101
      1  2330		       65		      .byte.b	101
      0  2331					      db	(ERRVEC2-*)-1
      1  2331		       a6		      .byte.b	(ERRVEC2-*)-1
      0  2332					      db	oRightBracket
      1  2332		       e1		      .byte.b	oRightBracket
      0  2333					      DONE
      0  2333					      db	1
      1  2333		       01		      .byte.b	1
      0  2334					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  2334					      db	9
      1  2334		       09		      .byte.b	9
      0  2335					      db	(S2RetFunc-*)-1
      1  2335		       11		      .byte.b	(S2RetFunc-*)-1
      0  2336					      db	1
      1  2336		       01		      .byte.b	1
      0  2337					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  2337					      db	6
      1  2337		       06		      .byte.b	6
      0  2338					      dw	CO
      1  2338		       9c 22		      .word.w	CO
      0  233a					      IJMP	STMT	; Process the new statement
      0  233a					      db	29
      1  233a		       1d		      .byte.b	29
      0  233b					      dw	STMT
      1  233b		       a4 22		      .word.w	STMT
    231  233d
    232  233d				   S2NoReturnValue
      0  233d					      DONE
      0  233d					      db	1
      1  233d		       01		      .byte.b	1
      0  233e					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  233e					      db	9
      1  233e		       09		      .byte.b	9
      0  233f					      db	(S2RetFunc-*)-1
      1  233f		       07		      .byte.b	(S2RetFunc-*)-1
      0  2340					      db	0
      1  2340		       00		      .byte.b	0
      0  2341					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  2341					      db	6
      1  2341		       06		      .byte.b	6
      0  2342					      dw	CO
      1  2342		       9c 22		      .word.w	CO
      0  2344					      IJMP	STMT	; Process the new statement
      0  2344					      db	29
      1  2344		       1d		      .byte.b	29
      0  2345					      dw	STMT
      1  2345		       a4 22		      .word.w	STMT
    237  2347
    238  2347				   S2RetFunc
      0  2347					      IJMP	GOFNRet	; Back into the Function
      0  2347					      db	29
      1  2347		       1d		      .byte.b	29
      0  2348					      dw	GOFNRet
      1  2348		       ce 25		      .word.w	GOFNRet
    240  234a							;
    241  234a							; End of return from gosub
    242  234a							;==================================================================================================================================
    243  234a							; Process REM statement
    244  234a							;
    245  234a							;S2a:
    246  234a							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    247  234a				   ekRem
      0  234a					      NXT	CO	; The rest of the line is ignored
      0  234a					      db	6
      1  234a		       06		      .byte.b	6
      0  234b					      dw	CO
      1  234b		       9c 22		      .word.w	CO
      0  234d					      IJMP	STMT	; Process the next statement
      0  234d					      db	29
      1  234d		       1d		      .byte.b	29
      0  234e					      dw	STMT
      1  234e		       a4 22		      .word.w	STMT
    250  2350							;==================================================================================================================================
    251  2350							; Print statement
    252  2350							;
    253  2350							;S3:
    254  2350							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    255  2350				   ekPrint
      0  2350					      STARTIO		; Lock task until io completes
      0  2350					      db	70
      1  2350		       46		      .byte.b	70
    257  2351				   S4
      0  2351					      TSTDONE	S4a	; Test if we just want crlf printed
      0  2351					      db	50
      1  2351		       32		      .byte.b	50
      0  2352					      db	(S4a-*)-1
      1  2352		       03		      .byte.b	(S4a-*)-1
      0  2353					      IJMP	S6
      0  2353					      db	29
      1  2353		       1d		      .byte.b	29
      0  2354					      dw	S6
      1  2354		       6b 23		      .word.w	S6
    260  2356
    261  2356				   S4a
      0  2356					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  2356					      db	101
      1  2356		       65		      .byte.b	101
      0  2357					      db	(S7-*)-1
      1  2357		       1f		      .byte.b	(S7-*)-1
      0  2358					      db	tString
      1  2358		       a0		      .byte.b	tString
      0  2359					      PRS		; PRINT STRING
      0  2359					      db	2
      1  2359		       02		      .byte.b	2
    264  235a				   S5
      0  235a					      TSTB	S6A,oComma	; IS THERE MORE?
      0  235a					      db	101
      1  235a		       65		      .byte.b	101
      0  235b					      db	(S6A-*)-1
      1  235b		       07		      .byte.b	(S6A-*)-1
      0  235c					      db	oComma
      1  235c		       e2		      .byte.b	oComma
      0  235d					      SPC		; SPACE TO NEXT ZONE
      0  235d					      db	4
      1  235d		       04		      .byte.b	4
      0  235e					      TSTDONE	S4	; Not end of line jump back
      0  235e					      db	50
      1  235e		       32		      .byte.b	50
      0  235f					      db	(S4-*)-1
      1  235f		       f1		      .byte.b	(S4-*)-1
      0  2360					      IJMP	S6Z	; YES JUMP BACK
      0  2360					      db	29
      1  2360		       1d		      .byte.b	29
      0  2361					      dw	S6Z
      1  2361		       6d 23		      .word.w	S6Z
    269  2363
    270  2363							;
    271  2363							; If a semicolon, don't do anything.
    272  2363							;
    273  2363				   S6A
      0  2363					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  2363					      db	101
      1  2363		       65		      .byte.b	101
      0  2364					      db	(S6-*)-1
      1  2364		       06		      .byte.b	(S6-*)-1
      0  2365					      db	oSemiColon
      1  2365		       e3		      .byte.b	oSemiColon
      0  2366					      TSTDONE	S4	; Jump Back if not end of line
      0  2366					      db	50
      1  2366		       32		      .byte.b	50
      0  2367					      db	(S4-*)-1
      1  2367		       e9		      .byte.b	(S4-*)-1
      0  2368					      IJMP	S6Z
      0  2368					      db	29
      1  2368		       1d		      .byte.b	29
      0  2369					      dw	S6Z
      1  2369		       6d 23		      .word.w	S6Z
    277  236b
    278  236b				   S6
    279  236b
      0  236b					      DONE		; ERROR IF CR NOT NEXT
      0  236b					      db	1
      1  236b		       01		      .byte.b	1
      0  236c					      NLINE
      0  236c					      db	5
      1  236c		       05		      .byte.b	5
    282  236d				   S6Z
      0  236d					      ENDIO		; release task io completed
      0  236d					      db	71
      1  236d		       47		      .byte.b	71
      0  236e					      NXT	CO	; exit here if , or ; at end of print
      0  236e					      db	6
      1  236e		       06		      .byte.b	6
      0  236f					      dw	CO
      1  236f		       9c 22		      .word.w	CO
      0  2371					      IJMP	STMT
      0  2371					      db	29
      1  2371		       1d		      .byte.b	29
      0  2372					      dw	STMT
      1  2372		       a4 22		      .word.w	STMT
    286  2374							;
    287  2374							; A jump for code too far away for relative branch
    288  2374							;
    289  2374				   ERRVEC
      0  2374					      IJMP	UNKNOWN
      0  2374					      db	29
      1  2374		       1d		      .byte.b	29
      0  2375					      dw	UNKNOWN
      1  2375		       8c 24		      .word.w	UNKNOWN
    291  2377							;
    292  2377							; Get here if there is an expression to print
    293  2377				   S7
      0  2377					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  2377					      db	101
      1  2377		       65		      .byte.b	101
      0  2378					      db	(S7AUnsigned-*)-1
      1  2378		       08		      .byte.b	(S7AUnsigned-*)-1
      0  2379					      db	oDollar
      1  2379		       e7		      .byte.b	oDollar
      0  237a					      CALL	EXPR
      0  237a					      db	28
      1  237a		       1c		      .byte.b	28
      0  237b					      dw	EXPR
      1  237b		       90 24		      .word.w	EXPR
      0  237d					      HEXPRT
      0  237d					      db	67
      1  237d		       43		      .byte.b	67
      0  237e					      IJMP	S5
      0  237e					      db	29
      1  237e		       1d		      .byte.b	29
      0  237f					      dw	S5
      1  237f		       5a 23		      .word.w	S5
    298  2381
    299  2381				   S7AUnsigned
    300  2381
      0  2381					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  2381					      db	101
      1  2381		       65		      .byte.b	101
      0  2382					      db	(S7A-*)-1
      1  2382		       0a		      .byte.b	(S7A-*)-1
      0  2383					      db	oPercent
      1  2383		       ed		      .byte.b	oPercent
      0  2384					      CALL	EXPR
      0  2384					      db	28
      1  2384		       1c		      .byte.b	28
      0  2385					      dw	EXPR
      1  2385		       90 24		      .word.w	EXPR
      0  2387					      SETR2	1
      0  2387					      db	94
      1  2387		       5e		      .byte.b	94
      0  2388					      db	1
      1  2388		       01		      .byte.b	1
      0  2389					      PRN
      0  2389					      db	3
      1  2389		       03		      .byte.b	3
      0  238a					      IJMP	S5
      0  238a					      db	29
      1  238a		       1d		      .byte.b	29
      0  238b					      dw	S5
      1  238b		       5a 23		      .word.w	S5
    306  238d
    307  238d				   S7A
    308  238d
      0  238d					      CALL	EXPR
      0  238d					      db	28
      1  238d		       1c		      .byte.b	28
      0  238e					      dw	EXPR
      1  238e		       90 24		      .word.w	EXPR
      0  2390					      TSTB	S7B,oDollar	; Print the value as a single character
      0  2390					      db	101
      1  2390		       65		      .byte.b	101
      0  2391					      db	(S7B-*)-1
      1  2391		       05		      .byte.b	(S7B-*)-1
      0  2392					      db	oDollar
      1  2392		       e7		      .byte.b	oDollar
      0  2393					      PUTCHAR
      0  2393					      db	52
      1  2393		       34		      .byte.b	52
      0  2394					      IJMP	S5
      0  2394					      db	29
      1  2394		       1d		      .byte.b	29
      0  2395					      dw	S5
      1  2395		       5a 23		      .word.w	S5
    313  2397
    314  2397				   S7B
      0  2397					      SETR2	0	; Print the value as a signed number
      0  2397					      db	94
      1  2397		       5e		      .byte.b	94
      0  2398					      db	0
      1  2398		       00		      .byte.b	0
      0  2399					      PRN		; PRINT IT
      0  2399					      db	3
      1  2399		       03		      .byte.b	3
      0  239a					      IJMP	S5	; IS THERE MORE?
      0  239a					      db	29
      1  239a		       1d		      .byte.b	29
      0  239b					      dw	S5
      1  239b		       5a 23		      .word.w	S5
    318  239d							;
    319  239d							;===========================================================
    320  239d							; PROCESS ALL THE TASK STATEMENTS
    321  239d							;
    322  239d							;S8:
    323  239d							;	  TSTB	      S8G,kTaske		 ; End Task
    324  239d				   ekTaske
      0  239d					      TSTB	S8NoParm,oLeftBracket
      0  239d					      db	101
      1  239d		       65		      .byte.b	101
      0  239e					      db	(S8NoParm-*)-1
      1  239e		       0c		      .byte.b	(S8NoParm-*)-1
      0  239f					      db	oLeftBracket
      1  239f		       e0		      .byte.b	oLeftBracket
      0  23a0					      CALL	EXPR
      0  23a0					      db	28
      1  23a0		       1c		      .byte.b	28
      0  23a1					      dw	EXPR
      1  23a1		       90 24		      .word.w	EXPR
      0  23a3					      TSTB	UNKNOWNLnk,oRightBracket
      0  23a3					      db	101
      1  23a3		       65		      .byte.b	101
      0  23a4					      db	(UNKNOWNLnk-*)-1
      1  23a4		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  23a5					      db	oRightBracket
      1  23a5		       e1		      .byte.b	oRightBracket
      0  23a6					      ETASK
      0  23a6					      db	62
      1  23a6		       3e		      .byte.b	62
      0  23a7					      DONE
      0  23a7					      db	1
      1  23a7		       01		      .byte.b	1
      0  23a8					      IJMP	STMT
      0  23a8					      db	29
      1  23a8		       1d		      .byte.b	29
      0  23a9					      dw	STMT
      1  23a9		       a4 22		      .word.w	STMT
    331  23ab				   S8NoParm
      0  23ab					      LIT	0
      0  23ab					      db	27
      1  23ab		       1b		      .byte.b	27
      0  23ac					      dw	0
      1  23ac		       00 00		      .word.w	0
      0  23ae					      ETASK
      0  23ae					      db	62
      1  23ae		       3e		      .byte.b	62
      0  23af					      DONE		; Must be last thing on a line
      0  23af					      db	1
      1  23af		       01		      .byte.b	1
      0  23b0					      IJMP	STMT
      0  23b0					      db	29
      1  23b0		       1d		      .byte.b	29
      0  23b1					      dw	STMT
      1  23b1		       a4 22		      .word.w	STMT
    336  23b3							;
    337  23b3							;===========================================================
    338  23b3							; The task gives up the rest of the cycles
    339  23b3							;S8G:
    340  23b3							;	  TSTB	      S8a,kTaskn	 ;Next task
    341  23b3				   ekTaskn
      0  23b3					      NTASK
      0  23b3					      db	63
      1  23b3		       3f		      .byte.b	63
      0  23b4					      NXT	CO	;Next statement to execute
      0  23b4					      db	6
      1  23b4		       06		      .byte.b	6
      0  23b5					      dw	CO
      1  23b5		       9c 22		      .word.w	CO
      0  23b7					      IJMP	STMT
      0  23b7					      db	29
      1  23b7		       1d		      .byte.b	29
      0  23b8					      dw	STMT
      1  23b8		       a4 22		      .word.w	STMT
    345  23ba							;
    346  23ba							;===========================================================
    347  23ba							; Waits for a task or list of tasks to complete
    348  23ba							;S8a:
    349  23ba							;	 TSTB	     S8a1,kTaskw		;Wait for tasks
    350  23ba				   ekTaskw
      0  23ba					      TSTB	UNKNOWNLnk,oLeftBracket
      0  23ba					      db	101
      1  23ba		       65		      .byte.b	101
      0  23bb					      db	(UNKNOWNLnk-*)-1
      1  23bb		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  23bc					      db	oLeftBracket
      1  23bc		       e0		      .byte.b	oLeftBracket
    352  23bd				   S8TSK
      0  23bd					      Call	EXPR	;Gets the PID of task to wait for
      0  23bd					      db	28
      1  23bd		       1c		      .byte.b	28
      0  23be					      dw	EXPR
      1  23be		       90 24		      .word.w	EXPR
    354  23c0				   S8LOOP
      0  23c0					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  23c0					      db	76
      1  23c0		       4c		      .byte.b	76
      0  23c1					      db	(S8LOOP-*)-1
      1  23c1		       fe		      .byte.b	(S8LOOP-*)-1
      0  23c2					      TSTB	S8aa,oComma	;Checks for more tasks
      0  23c2					      db	101
      1  23c2		       65		      .byte.b	101
      0  23c3					      db	(S8aa-*)-1
      1  23c3		       04		      .byte.b	(S8aa-*)-1
      0  23c4					      db	oComma
      1  23c4		       e2		      .byte.b	oComma
      0  23c5					      IJMP	S8TSK	;Go for the next task number
      0  23c5					      db	29
      1  23c5		       1d		      .byte.b	29
      0  23c6					      dw	S8TSK
      1  23c6		       bd 23		      .word.w	S8TSK
    358  23c8				   S8aa
      0  23c8					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  23c8					      db	101
      1  23c8		       65		      .byte.b	101
      0  23c9					      db	(UNKNOWNLnk-*)-1
      1  23c9		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  23ca					      db	oRightBracket
      1  23ca		       e1		      .byte.b	oRightBracket
      0  23cb					      DONE
      0  23cb					      db	1
      1  23cb		       01		      .byte.b	1
      0  23cc					      NXT	CO
      0  23cc					      db	6
      1  23cc		       06		      .byte.b	6
      0  23cd					      dw	CO
      1  23cd		       9c 22		      .word.w	CO
      0  23cf					      IJMP	STMT	;Next Statement
      0  23cf					      db	29
      1  23cf		       1d		      .byte.b	29
      0  23d0					      dw	STMT
      1  23d0		       a4 22		      .word.w	STMT
    363  23d2
    364  23d2
    365  23d2
    366  23d2				   UNKNOWNLnk
      0  23d2					      iJMP	UNKNOWN
      0  23d2					      db	29
      1  23d2		       1d		      .byte.b	29
      0  23d3					      dw	UNKNOWN
      1  23d3		       8c 24		      .word.w	UNKNOWN
    368  23d5
    369  23d5							;
    370  23d5							;===========================================================
    371  23d5							; Update a memory location with a value
    372  23d5							;  Use @[offset] to write a word value to memory
    373  23d5							;
    374  23d5							;S8a1:
    375  23d5							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    376  23d5				   ekPoke
      0  23d5					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  23d5					      db	101
      1  23d5		       65		      .byte.b	101
      0  23d6					      db	(UNKNOWNV-*)-1
      1  23d6		       50		      .byte.b	(UNKNOWNV-*)-1
      0  23d7					      db	oLeftBracket
      1  23d7		       e0		      .byte.b	oLeftBracket
      0  23d8					      CALL	EXPR	; Get address to write to
      0  23d8					      db	28
      1  23d8		       1c		      .byte.b	28
      0  23d9					      dw	EXPR
      1  23d9		       90 24		      .word.w	EXPR
      0  23db					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  23db					      db	101
      1  23db		       65		      .byte.b	101
      0  23dc					      db	(UNKNOWNV-*)-1
      1  23dc		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  23dd					      db	oComma
      1  23dd		       e2		      .byte.b	oComma
      0  23de					      CALL	EXPR	; Get the value to poke
      0  23de					      db	28
      1  23de		       1c		      .byte.b	28
      0  23df					      dw	EXPR
      1  23df		       90 24		      .word.w	EXPR
      0  23e1					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  23e1					      db	101
      1  23e1		       65		      .byte.b	101
      0  23e2					      db	(UNKNOWNV-*)-1
      1  23e2		       44		      .byte.b	(UNKNOWNV-*)-1
      0  23e3					      db	oRightBracket
      1  23e3		       e1		      .byte.b	oRightBracket
      0  23e4					      POKEMEM
      0  23e4					      db	47
      1  23e4		       2f		      .byte.b	47
      0  23e5					      DONE
      0  23e5					      db	1
      1  23e5		       01		      .byte.b	1
      0  23e6					      NXT	CO	;AND SEQUENCE TO NEXT
      0  23e6					      db	6
      1  23e6		       06		      .byte.b	6
      0  23e7					      dw	CO
      1  23e7		       9c 22		      .word.w	CO
      0  23e9					      IJMP	STMT
      0  23e9					      db	29
      1  23e9		       1d		      .byte.b	29
      0  23ea					      dw	STMT
      1  23ea		       a4 22		      .word.w	STMT
    386  23ec							;================================================================
    387  23ec							; Write a single byte to the output device
    388  23ec							;
    389  23ec							;S8b:
    390  23ec							;	  TSTB	      S8c,kPutch       ;Put a char to the terminal
    391  23ec				   ekPutch
      0  23ec					      CALL	EXPR
      0  23ec					      db	28
      1  23ec		       1c		      .byte.b	28
      0  23ed					      dw	EXPR
      1  23ed		       90 24		      .word.w	EXPR
      0  23ef					      PUTCHAR
      0  23ef					      db	52
      1  23ef		       34		      .byte.b	52
      0  23f0					      DONE
      0  23f0					      db	1
      1  23f0		       01		      .byte.b	1
      0  23f1					      NXT	CO	;AND SEQUENCE TO NEXT
      0  23f1					      db	6
      1  23f1		       06		      .byte.b	6
      0  23f2					      dw	CO
      1  23f2		       9c 22		      .word.w	CO
      0  23f4					      IJMP	STMT
      0  23f4					      db	29
      1  23f4		       1d		      .byte.b	29
      0  23f5					      dw	STMT
      1  23f5		       a4 22		      .word.w	STMT
    397  23f7							;================================================================
    398  23f7							; Clear the screen lines
    399  23f7							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    400  23f7							;
    401  23f7							;S8c
    402  23f7							;	  TSTB	      S9,kCls	       ;Clear the screen
    403  23f7				   ekCls
      0  23f7					      CLEARSCREEN
      0  23f7					      db	46
      1  23f7		       2e		      .byte.b	46
      0  23f8					      NXT	CO	;AND SEQUENCE TO NEXT
      0  23f8					      db	6
      1  23f8		       06		      .byte.b	6
      0  23f9					      dw	CO
      1  23f9		       9c 22		      .word.w	CO
      0  23fb					      IJMP	STMT
      0  23fb					      db	29
      1  23fb		       1d		      .byte.b	29
      0  23fc					      dw	STMT
      1  23fc		       a4 22		      .word.w	STMT
    407  23fe							;==================================================================
    408  23fe							; Get input from the terminal
    409  23fe							;   Reads from the currently active input device
    410  23fe							;
    411  23fe							;S9:
    412  23fe							;	  TSTB	     S13,kInput 	      ;INPUT STATEMENT
    413  23fe				   ekInput
    414  23fe				   S10
      0  23fe					      TSTB	S10A,tString	;If there is a string print the prompt
      0  23fe					      db	101
      1  23fe		       65		      .byte.b	101
      0  23ff					      db	(S10A-*)-1
      1  23ff		       05		      .byte.b	(S10A-*)-1
      0  2400					      db	tString
      1  2400		       a0		      .byte.b	tString
      0  2401					      PRS
      0  2401					      db	2
      1  2401		       02		      .byte.b	2
      0  2402					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  2402					      db	101
      1  2402		       65		      .byte.b	101
      0  2403					      db	(S10Z-*)-1
      1  2403		       18		      .byte.b	(S10Z-*)-1
      0  2404					      db	oSemiColon
      1  2404		       e3		      .byte.b	oSemiColon
    418  2405				   S10A
      0  2405					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  2405					      db	33
      1  2405		       21		      .byte.b	33
      0  2406					      db	(UNKNOWN-*)-1
      1  2406		       85		      .byte.b	(UNKNOWN-*)-1
      0  2407					      TSTB	S10ACONT,oBang	; Print from another task
      0  2407					      db	101
      1  2407		       65		      .byte.b	101
      0  2408					      db	(S10ACONT-*)-1
      1  2408		       04		      .byte.b	(S10ACONT-*)-1
      0  2409					      db	oBang
      1  2409		       e8		      .byte.b	oBang
      0  240a					      IND
      0  240a					      db	20
      1  240a		       14		      .byte.b	20
      0  240b					      TSTVT	UNKNOWN
      0  240b					      db	93
      1  240b		       5d		      .byte.b	93
      0  240c					      db	(UNKNOWN-*)-1
      1  240c		       7f		      .byte.b	(UNKNOWN-*)-1
    423  240d
    424  240d				   S10ACONT
      0  240d					      TSTB	S10A1,oDollar
      0  240d					      db	101
      1  240d		       65		      .byte.b	101
      0  240e					      db	(S10A1-*)-1
      1  240e		       05		      .byte.b	(S10A1-*)-1
      0  240f					      db	oDollar
      1  240f		       e7		      .byte.b	oDollar
      0  2410					      INSTR		;Move character From tty to AESTK
      0  2410					      db	59
      1  2410		       3b		      .byte.b	59
      0  2411					      IJMP	S10A2
      0  2411					      db	29
      1  2411		       1d		      .byte.b	29
      0  2412					      dw	S10A2
      1  2412		       15 24		      .word.w	S10A2
    428  2414				   S10A1
      0  2414					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  2414					      db	11
      1  2414		       0b		      .byte.b	11
    430  2415				   S10A2
      0  2415					      STORE		;STORE IT
      0  2415					      db	19
      1  2415		       13		      .byte.b	19
      0  2416					      TSTB	S11,oComma	;IS THERE MORE?
      0  2416					      db	101
      1  2416		       65		      .byte.b	101
      0  2417					      db	(S11-*)-1
      1  2417		       07		      .byte.b	(S11-*)-1
      0  2418					      db	oComma
      1  2418		       e2		      .byte.b	oComma
      0  2419					      IJMP	S10	;YES
      0  2419					      db	29
      1  2419		       1d		      .byte.b	29
      0  241a					      dw	S10
      1  241a		       fe 23		      .word.w	S10
    434  241c				   S10Z
      0  241c					      iJMP	UNKNOWN
      0  241c					      db	29
      1  241c		       1d		      .byte.b	29
      0  241d					      dw	UNKNOWN
      1  241d		       8c 24		      .word.w	UNKNOWN
    436  241f				   S11
      0  241f					      DONE		;MUST BE CR
      0  241f					      db	1
      1  241f		       01		      .byte.b	1
      0  2420					      NXT	CO	;SEQUENCE TO NEXT
      0  2420					      db	6
      1  2420		       06		      .byte.b	6
      0  2421					      dw	CO
      1  2421		       9c 22		      .word.w	CO
      0  2423					      IJMP	STMT
      0  2423					      db	29
      1  2423		       1d		      .byte.b	29
      0  2424					      dw	STMT
      1  2424		       a4 22		      .word.w	STMT
    440  2426							;=====================================================================
    441  2426							; End of program, return to command line process
    442  2426							; Main Task may also use taske or return to stopped
    443  2426							;
    444  2426							;S13:
    445  2426							;	  TSTB	      S14,kEnd
    446  2426				   ekEnd
      0  2426					      FIN
      0  2426					      db	12
      1  2426		       0c		      .byte.b	12
    448  2427
    449  2427				   UNKNOWNV
      0  2427					      IJMP	UNKNOWN
      0  2427					      db	29
      1  2427		       1d		      .byte.b	29
      0  2428					      dw	UNKNOWN
      1  2428		       8c 24		      .word.w	UNKNOWN
    451  242a							;====================================================================
    452  242a							; IRQ <IRQ-HANDLER-Line expression>
    453  242a							;   Specify a line number subroutine to call when an interupt is processed
    454  242a							;   These subroutines must use iret to return.
    455  242a							;
    456  242a							;S14:
    457  242a							;	  TSTB	      S14Z,kIrq      ;Check if we are setting IRQ HANDLER
    458  242a				   ekIrq
      0  242a					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  242a					      db	28
      1  242a		       1c		      .byte.b	28
      0  242b					      dw	EXPR
      1  242b		       90 24		      .word.w	EXPR
      0  242d					      DONE		;must be CR
      0  242d					      db	1
      1  242d		       01		      .byte.b	1
      0  242e					      SETIRQ		;Set the line number now
      0  242e					      db	56
      1  242e		       38		      .byte.b	56
      0  242f					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  242f					      db	6
      1  242f		       06		      .byte.b	6
      0  2430					      dw	CO
      1  2430		       9c 22		      .word.w	CO
      0  2432					      IJMP	STMT
      0  2432					      db	29
      1  2432		       1d		      .byte.b	29
      0  2433					      dw	STMT
      1  2433		       a4 22		      .word.w	STMT
    464  2435
    465  2435							;=========================================================================
    466  2435							; KILL PID-expression	 kill a running task
    467  2435							;  ignored of task has already stopped
    468  2435							;
    469  2435							;S14Z:
    470  2435							;	  TSTB	     S14S1,kKill     ; Kill A running Task
    471  2435				   ekKill
      0  2435					      CALL	EXPR
      0  2435					      db	28
      1  2435		       1c		      .byte.b	28
      0  2436					      dw	EXPR
      1  2436		       90 24		      .word.w	EXPR
      0  2438					      DONE
      0  2438					      db	1
      1  2438		       01		      .byte.b	1
      0  2439					      TASKKILL
      0  2439					      db	65
      1  2439		       41		      .byte.b	65
      0  243a					      NXT	CO
      0  243a					      db	6
      1  243a		       06		      .byte.b	6
      0  243b					      dw	CO
      1  243b		       9c 22		      .word.w	CO
      0  243d					      IJMP	STMT
      0  243d					      db	29
      1  243d		       1d		      .byte.b	29
      0  243e					      dw	STMT
      1  243e		       a4 22		      .word.w	STMT
    477  2440
    478  2440							;============================================================================
    479  2440							; List all program lines
    480  2440							;
    481  2440							;S14S1:
    482  2440							;	  TSTB	      S15,kList      ;LIST COMMAND
    483  2440				   ekList
      0  2440					      DONE
      0  2440					      db	1
      1  2440		       01		      .byte.b	1
      0  2441					      LST
      0  2441					      db	21
      1  2441		       15		      .byte.b	21
      0  2442					      IJMP	CO
      0  2442					      db	29
      1  2442		       1d		      .byte.b	29
      0  2443					      dw	CO
      1  2443		       9c 22		      .word.w	CO
    487  2445							;=======================================================================
    488  2445							;RUN begin to executed the program in memory
    489  2445							;
    490  2445							;S15:
    491  2445							;	  TSTB	      S16,kRun	     ;RUN COMMAND
    492  2445				   ekRun
      0  2445					      DONE
      0  2445					      db	1
      1  2445		       01		      .byte.b	1
      0  2446					      VINIT		;clear variables compile the line numbers
      0  2446					      db	30
      1  2446		       1e		      .byte.b	30
      0  2447					      LIT	1	;GOTO line 1
      0  2447					      db	27
      1  2447		       1b		      .byte.b	27
      0  2448					      dw	1
      1  2448		       01 00		      .word.w	1
      0  244a					      XFER		;Bob's addition
      0  244a					      db	7
      1  244a		       07		      .byte.b	7
    497  244b							; EXIT
      0  244b					      IJMP	STMT	;and run!
      0  244b					      db	29
      1  244b		       1d		      .byte.b	29
      0  244c					      dw	STMT
      1  244c		       a4 22		      .word.w	STMT
    499  244e							;=========================================================================
    500  244e							;Clear the program memory, delete all proram lines
    501  244e							;
    502  244e							;S16:
    503  244e							;	  TSTB	      S16A,kNew      ;clear program
    504  244e				   ekNew
      0  244e					      DONE
      0  244e					      db	1
      1  244e		       01		      .byte.b	1
      0  244f					      IJMP	START
      0  244f					      db	29
      1  244f		       1d		      .byte.b	29
      0  2450					      dw	START
      1  2450		       96 22		      .word.w	START
    507  2452
    508  2452							;========================================================================
    509  2452							; Slice(slice legth expression)
    510  2452							;   set the length of time between task switches
    511  2452							;
    512  2452							;S16A:
    513  2452							;	  TSTB	      S16Trace,kSlice
    514  2452				   ekSlice
      0  2452					      CALL	EXPR
      0  2452					      db	28
      1  2452		       1c		      .byte.b	28
      0  2453					      dw	EXPR
      1  2453		       90 24		      .word.w	EXPR
      0  2455					      SLICE
      0  2455					      db	100
      1  2455		       64		      .byte.b	100
      0  2456					      DONE
      0  2456					      db	1
      1  2456		       01		      .byte.b	1
      0  2457					      NXT	CO
      0  2457					      db	6
      1  2457		       06		      .byte.b	6
      0  2458					      dw	CO
      1  2458		       9c 22		      .word.w	CO
      0  245a					      IJMP	STMT
      0  245a					      db	29
      1  245a		       1d		      .byte.b	29
      0  245b					      dw	STMT
      1  245b		       a4 22		      .word.w	STMT
    520  245d							;==========================================================================
    521  245d							; Turn off and on the thrace functions
    522  245d							; a debug terminal needs to be available
    523  245d							; Trace( Trace flag expression)
    524  245d							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    525  245d							;	for individual lines of basic code. These can be combined
    526  245d							;S16Trace:
    527  245d							;	  TSTB	      S17A,kTrace
    528  245d				   ekTrace
      0  245d					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  245d					      db	101
      1  245d		       65		      .byte.b	101
      0  245e					      db	(UNKNOWN-*)-1
      1  245e		       2d		      .byte.b	(UNKNOWN-*)-1
      0  245f					      db	oLeftBracket
      1  245f		       e0		      .byte.b	oLeftBracket
      0  2460					      CALL	EXPR
      0  2460					      db	28
      1  2460		       1c		      .byte.b	28
      0  2461					      dw	EXPR
      1  2461		       90 24		      .word.w	EXPR
      0  2463					      TSTB	UNKNOWN,oRightBracket
      0  2463					      db	101
      1  2463		       65		      .byte.b	101
      0  2464					      db	(UNKNOWN-*)-1
      1  2464		       27		      .byte.b	(UNKNOWN-*)-1
      0  2465					      db	oRightBracket
      1  2465		       e1		      .byte.b	oRightBracket
      0  2466					      TRACEPROGRAM
      0  2466					      db	78
      1  2466		       4e		      .byte.b	78
      0  2467					      DONE
      0  2467					      db	1
      1  2467		       01		      .byte.b	1
      0  2468					      NXT	CO
      0  2468					      db	6
      1  2468		       06		      .byte.b	6
      0  2469					      dw	CO
      1  2469		       9c 22		      .word.w	CO
      0  246b					      IJMP	STMT
      0  246b					      db	29
      1  246b		       1d		      .byte.b	29
      0  246c					      dw	STMT
      1  246c		       a4 22		      .word.w	STMT
    536  246e							;=====================================================================
    537  246e							; Exit basic to machine monitor
    538  246e							;
    539  246e							;S17A:
    540  246e							;	  TSTB	      S17B,kExit      ;allow them to exit BASIC
    541  246e				   ekExit
      0  246e					      EXIT
      0  246e					      db	26
      1  246e		       1a		      .byte.b	26
    543  246f
    544  246f							;=======================================================================
    545  246f							; Commands related to saving/restoring programs
    546  246f							; to/from mass storage.
    547  246f							;=======================================================================
    548  246f							; Save a program file
    549  246f							;
    550  246f							;S17B:
    551  246f					      if	(XKIM || CTMON65) && DISK_ACCESS
    552  246f
    553  246f							;	  TSTB	      S17C,kSave
    554  246f				   ekSave
      0  246f					      OPENWRITE
      0  246f					      db	40
      1  246f		       28		      .byte.b	40
      0  2470					      DLIST
      0  2470					      db	43
      1  2470		       2b		      .byte.b	43
      0  2471					      DCLOSE
      0  2471					      db	41
      1  2471		       29		      .byte.b	41
      0  2472					      IJMP	CO
      0  2472					      db	29
      1  2472		       1d		      .byte.b	29
      0  2473					      dw	CO
      1  2473		       9c 22		      .word.w	CO
    559  2475							;=========================================================================
    560  2475							; Load a program file
    561  2475							;
    562  2475							;S17C:
    563  2475							;	  TSTB	      S18,kLoad
    564  2475				   ekLoad
      0  2475					      OPENREAD
      0  2475					      db	39
      1  2475		       27		      .byte.b	39
    566  2476				   S17CLP
      0  2476					      DGETLINE		;get line from file
      0  2476					      db	42
      1  2476		       2a		      .byte.b	42
      0  2477					      TSTL	S17EOL	;no line num means EOL
      0  2477					      db	34
      1  2477		       22		      .byte.b	34
      0  2478					      db	(S17EOL-*)-1
      1  2478		       04		      .byte.b	(S17EOL-*)-1
      0  2479					      INSERT		;put it into the program
      0  2479					      db	24
      1  2479		       18		      .byte.b	24
      0  247a					      IJMP	S17CLP	;keep going
      0  247a					      db	29
      1  247a		       1d		      .byte.b	29
      0  247b					      dw	S17CLP
      1  247b		       76 24		      .word.w	S17CLP
    571  247d				   S17EOL
      0  247d					      DCLOSE		;close disk file
      0  247d					      db	41
      1  247d		       29		      .byte.b	41
      0  247e					      IJMP	CO	;back to start
      0  247e					      db	29
      1  247e		       1d		      .byte.b	29
      0  247f					      dw	CO
      1  247f		       9c 22		      .word.w	CO
    574  2481							;=========================================================================
    575  2481							; Display the directory content
    576  2481							;
    577  2481							;S18:
    578  2481							;	  TSTB	      S19,kDir
    579  2481				   ekDir
      0  2481					      DDIR		;Display the directory content
      0  2481					      db	44
      1  2481		       2c		      .byte.b	44
      0  2482					      IJMP	CO
      0  2482					      db	29
      1  2482		       1d		      .byte.b	29
      0  2483					      dw	CO
      1  2483		       9c 22		      .word.w	CO
    582  2485							;=========================================================================
    583  2485							; Erase a file from disk
    584  2485							;
      0  2485				   S19	      TSTB	UNKNOWN,kErase
      0  2485					      db	101
      1  2485		       65		      .byte.b	101
      0  2486					      db	(UNKNOWN-*)-1
      1  2486		       05		      .byte.b	(UNKNOWN-*)-1
      0  2487					      db	kErase
      1  2487		       1e		      .byte.b	kErase
    586  2488				   ekErase
      0  2488					      RMFILE		;Erase the file from the disk
      0  2488					      db	45
      1  2488		       2d		      .byte.b	45
      0  2489					      IJMP	CO
      0  2489					      db	29
      1  2489		       1d		      .byte.b	29
      0  248a					      dw	CO
      1  248a		       9c 22		      .word.w	CO
    589  248c
    590  248c					      endif
    591  248c
    592  248c							;===========================================================================
    593  248c							; Else, unknown command.
    594  248c							;
    595  248c				   UNKNOWN
      0  248c					      ENDIO
      0  248c					      db	71
      1  248c		       47		      .byte.b	71
    597  248d
    598  248d				   NotKnownStatement
    599  248d
      0  248d					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  248d					      db	13
      1  248d		       0d		      .byte.b	13
      0  248e					      dw	ERR_SYNTAX
      1  248e		       05 00		      .word.w	ERR_SYNTAX
    601  2490
    602  2490							;=======================================================
    603  2490							; Process Expresions, precidence is represented by the
    604  2490							; various call levels
    605  2490							;
    606  2490				   EXPR
      0  2490					      TSTB	EXPRLOGS,kNot
      0  2490					      db	101
      1  2490		       65		      .byte.b	101
      0  2491					      db	(EXPRLOGS-*)-1
      1  2491		       06		      .byte.b	(EXPRLOGS-*)-1
      0  2492					      db	kNot
      1  2492		       20		      .byte.b	kNot
    608  2493				   ekNot
      0  2493					      Call	EXPR
      0  2493					      db	28
      1  2493		       1c		      .byte.b	28
      0  2494					      dw	EXPR
      1  2494		       90 24		      .word.w	EXPR
      0  2496					      LOGNOT
      0  2496					      db	72
      1  2496		       48		      .byte.b	72
      0  2497					      RTN
      0  2497					      db	25
      1  2497		       19		      .byte.b	25
    612  2498
    613  2498							;=========================================================
    614  2498							;Look for logical operators
    615  2498				   EXPRLOGS
      0  2498					      Call	EXPRCMP
      0  2498					      db	28
      1  2498		       1c		      .byte.b	28
      0  2499					      dw	EXPRCMP
      1  2499		       af 24		      .word.w	EXPRCMP
      0  249b					      OnGoto	BasicLogical,iLOG3
      0  249b					      db	103
      1  249b		       67		      .byte.b	103
      0  249c					      dw	BasicLogical
      1  249c		       6e 22		      .word.w	BasicLogical
      0  249e					      dw	iLOG3
      1  249e		       ae 24		      .word.w	iLOG3
    618  24a0							;	  TSTB	     iLOG1,kAnd
    619  24a0				   ekAnd
      0  24a0					      Call	EXPR
      0  24a0					      db	28
      1  24a0		       1c		      .byte.b	28
      0  24a1					      dw	EXPR
      1  24a1		       90 24		      .word.w	EXPR
      0  24a3					      LOGAND
      0  24a3					      db	74
      1  24a3		       4a		      .byte.b	74
      0  24a4					      RTN
      0  24a4					      db	25
      1  24a4		       19		      .byte.b	25
    623  24a5							;iLOG1:
    624  24a5							;	  TSTB	     iLOG2,kOr
    625  24a5				   ekOr
      0  24a5					      Call	EXPR
      0  24a5					      db	28
      1  24a5		       1c		      .byte.b	28
      0  24a6					      dw	EXPR
      1  24a6		       90 24		      .word.w	EXPR
      0  24a8					      LOGOR
      0  24a8					      db	73
      1  24a8		       49		      .byte.b	73
      0  24a9					      RTN
      0  24a9					      db	25
      1  24a9		       19		      .byte.b	25
    629  24aa							;iLOG2:
    630  24aa							;	  TSTB	  iLOG3,kXor
    631  24aa				   ekXor
      0  24aa					      Call	EXPR
      0  24aa					      db	28
      1  24aa		       1c		      .byte.b	28
      0  24ab					      dw	EXPR
      1  24ab		       90 24		      .word.w	EXPR
      0  24ad					      LOGXOR
      0  24ad					      db	75
      1  24ad		       4b		      .byte.b	75
    634  24ae				   iLOG3
      0  24ae					      RTN
      0  24ae					      db	25
      1  24ae		       19		      .byte.b	25
    636  24af							;========================================================================
    637  24af							; Process relational operators
    638  24af							;
    639  24af				   EXPRCMP
      0  24af					      Call	EXPR2	; get the first expression
      0  24af					      db	28
      1  24af		       1c		      .byte.b	28
      0  24b0					      dw	EXPR2
      1  24b0		       ba 24		      .word.w	EXPR2
      0  24b2					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  24b2					      db	104
      1  24b2		       68		      .byte.b	104
      0  24b3					      db	(iRDone-*)-1
      1  24b3		       05		      .byte.b	(iRDone-*)-1
    642  24b4							;	  TSTB	     iR0,oEqual
    643  24b4							;	  LIT	     2		     ;=
    644  24b4							;	  IJMP	     iRFound
    645  24b4							;iR0:
    646  24b4							;	  TSTB	      iR1,oLessEqual
    647  24b4							;	  LIT	      3 	      ;<=
    648  24b4							;	  IJMP	     iRFound
    649  24b4							;iR1:
    650  24b4							;	  TSTB	     iR3,oNotEqual
    651  24b4							;	  LIT	     5		      ;<>
    652  24b4							;	      IJMP	  iRFound
    653  24b4							;iR3:
    654  24b4							;	  TSTB	     iR4,oLess
    655  24b4							;	  LIT	     1		     ;<
    656  24b4							;	      IJMP	  iRFound
    657  24b4							;iR4:
    658  24b4							;	  TST	     iR5,oGreaterEqual
    659  24b4							;	  LIT	     6		     ;>=
    660  24b4							;	      IJMP	  iRFound
    661  24b4							;iR5:
    662  24b4							;	  TSTB	     iRDone,oGreater
    663  24b4							;	  LIT	     4		     ;>
    664  24b4				   iRFound
      0  24b4					      Call	EXPR	; get the right side of the expression
      0  24b4					      db	28
      1  24b4		       1c		      .byte.b	28
      0  24b5					      dw	EXPR
      1  24b5		       90 24		      .word.w	EXPR
      0  24b7					      CMPR		; Push the value of the true false onto the stack
      0  24b7					      db	10
      1  24b7		       0a		      .byte.b	10
      0  24b8					      RTN
      0  24b8					      db	25
      1  24b8		       19		      .byte.b	25
    668  24b9
    669  24b9				   iRDone
      0  24b9					      RTN
      0  24b9					      db	25
      1  24b9		       19		      .byte.b	25
    671  24ba
    672  24ba				   EXPR2
      0  24ba					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  24ba					      db	101
      1  24ba		       65		      .byte.b	101
      0  24bb					      db	(E0-*)-1
      1  24bb		       08		      .byte.b	(E0-*)-1
      0  24bc					      db	oMinus
      1  24bc		       eb		      .byte.b	oMinus
      0  24bd					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  24bd					      db	28
      1  24bd		       1c		      .byte.b	28
      0  24be					      dw	TERM
      1  24be		       e0 24		      .word.w	TERM
      0  24c0					      NEG		; Make value negated
      0  24c0					      db	16
      1  24c0		       10		      .byte.b	16
      0  24c1					      IJMP	E1	; We have Left term process operators next
      0  24c1					      db	29
      1  24c1		       1d		      .byte.b	29
      0  24c2					      dw	E1
      1  24c2		       ca 24		      .word.w	E1
    677  24c4				   E0
      0  24c4					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  24c4					      db	101
      1  24c4		       65		      .byte.b	101
      0  24c5					      db	(E1A-*)-1
      1  24c5		       01		      .byte.b	(E1A-*)-1
      0  24c6					      db	oPlus
      1  24c6		       ea		      .byte.b	oPlus
    679  24c7				   E1A
      0  24c7					      CALL	TERM	; Get the left term if it was not negated
      0  24c7					      db	28
      1  24c7		       1c		      .byte.b	28
      0  24c8					      dw	TERM
      1  24c8		       e0 24		      .word.w	TERM
    681  24ca				   E1
      0  24ca					      TST	E2,oPlus	; Check if we are adding left term to something
      0  24ca					      db	32
      1  24ca		       20		      .byte.b	32
      0  24cb					      db	(E2-*)-1
      1  24cb		       09		      .byte.b	(E2-*)-1
      0  24cc					      db	oPlus,0
      1  24cc		       ea 00		      .byte.b	oPlus,0
      0  24ce					      CALL	TERM	; if adding then get the right side term
      0  24ce					      db	28
      1  24ce		       1c		      .byte.b	28
      0  24cf					      dw	TERM
      1  24cf		       e0 24		      .word.w	TERM
      0  24d1					      ADD		; Add it to left term
      0  24d1					      db	14
      1  24d1		       0e		      .byte.b	14
      0  24d2					      IJMP	E1	; look for next + or -
      0  24d2					      db	29
      1  24d2		       1d		      .byte.b	29
      0  24d3					      dw	E1
      1  24d3		       ca 24		      .word.w	E1
    686  24d5				   E2
      0  24d5					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  24d5					      db	101
      1  24d5		       65		      .byte.b	101
      0  24d6					      db	(E3-*)-1
      1  24d6		       08		      .byte.b	(E3-*)-1
      0  24d7					      db	oMinus
      1  24d7		       eb		      .byte.b	oMinus
      0  24d8					      CALL	TERM	; get right side to subtract Diffrence
      0  24d8					      db	28
      1  24d8		       1c		      .byte.b	28
      0  24d9					      dw	TERM
      1  24d9		       e0 24		      .word.w	TERM
      0  24db					      SUB		; Subtract the value
      0  24db					      db	15
      1  24db		       0f		      .byte.b	15
      0  24dc					      IJMP	E1	; Look for next + or -
      0  24dc					      db	29
      1  24dc		       1d		      .byte.b	29
      0  24dd					      dw	E1
      1  24dd		       ca 24		      .word.w	E1
    691  24df				   E3			; Finish processing the expression
      0  24df					      RTN		; We are finished processing the Expression
      0  24df					      db	25
      1  24df		       19		      .byte.b	25
    693  24e0							;
    694  24e0							; Get one of the terms of an expression
    695  24e0							;
    696  24e0				   TERM
      0  24e0					      CALL	FACT	; Get a value
      0  24e0					      db	28
      1  24e0		       1c		      .byte.b	28
      0  24e1					      dw	FACT
      1  24e1		       05 25		      .word.w	FACT
    698  24e3				   T0			; Check for higher precidence operators
      0  24e3					      TSTB	T1,oMultiply	; Check for *
      0  24e3					      db	101
      1  24e3		       65		      .byte.b	101
      0  24e4					      db	(T1-*)-1
      1  24e4		       08		      .byte.b	(T1-*)-1
      0  24e5					      db	oMultiply
      1  24e5		       ee		      .byte.b	oMultiply
      0  24e6					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  24e6					      db	28
      1  24e6		       1c		      .byte.b	28
      0  24e7					      dw	FACT
      1  24e7		       05 25		      .word.w	FACT
      0  24e9					      MUL		; Multiply factors
      0  24e9					      db	17
      1  24e9		       11		      .byte.b	17
      0  24ea					      IJMP	T0	; Check for * or /
      0  24ea					      db	29
      1  24ea		       1d		      .byte.b	29
      0  24eb					      dw	T0
      1  24eb		       e3 24		      .word.w	T0
    703  24ed				   T1
      0  24ed					      TSTB	T2,oDivide	; Check for a division
      0  24ed					      db	101
      1  24ed		       65		      .byte.b	101
      0  24ee					      db	(T2-*)-1
      1  24ee		       08		      .byte.b	(T2-*)-1
      0  24ef					      db	oDivide
      1  24ef		       ec		      .byte.b	oDivide
      0  24f0					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  24f0					      db	28
      1  24f0		       1c		      .byte.b	28
      0  24f1					      dw	FACT
      1  24f1		       05 25		      .word.w	FACT
      0  24f3					      DIV		; do division
      0  24f3					      db	18
      1  24f3		       12		      .byte.b	18
      0  24f4					      IJMP	T0	; check for more * or /
      0  24f4					      db	29
      1  24f4		       1d		      .byte.b	29
      0  24f5					      dw	T0
      1  24f5		       e3 24		      .word.w	T0
    708  24f7				   T2
      0  24f7					      TSTB	T3,oModulo	; Check for a division
      0  24f7					      db	101
      1  24f7		       65		      .byte.b	101
      0  24f8					      db	(T3-*)-1
      1  24f8		       08		      .byte.b	(T3-*)-1
      0  24f9					      db	oModulo
      1  24f9		       ed		      .byte.b	oModulo
      0  24fa					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  24fa					      db	28
      1  24fa		       1c		      .byte.b	28
      0  24fb					      dw	FACT
      1  24fb		       05 25		      .word.w	FACT
      0  24fd					      MODULO		; do division for remainder
      0  24fd					      db	60
      1  24fd		       3c		      .byte.b	60
      0  24fe					      IJMP	T0	; check for more * or / or %
      0  24fe					      db	29
      1  24fe		       1d		      .byte.b	29
      0  24ff					      dw	T0
      1  24ff		       e3 24		      .word.w	T0
    713  2501				   T3			; Finish processing the Term
      0  2501					      RTN
      0  2501					      db	25
      1  2501		       19		      .byte.b	25
    715  2502
    716  2502				   UNKNOWNVEC
      0  2502					      IJMP	UNKNOWN
      0  2502					      db	29
      1  2502		       1d		      .byte.b	29
      0  2503					      dw	UNKNOWN
      1  2503		       8c 24		      .word.w	UNKNOWN
    718  2505
    719  2505							;=============================================================================================
    720  2505							; Factor an expression.  Always test for functions
    721  2505							; first or else they'll be confused for variables.
    722  2505							;
    723  2505				   FACT
      0  2505					      OnGoto	BasicFuncs,FactNumber
      0  2505					      db	103
      1  2505		       67		      .byte.b	103
      0  2506					      dw	BasicFuncs
      1  2506		       76 22		      .word.w	BasicFuncs
      0  2508					      dw	FactNumber
      1  2508		       cf 25		      .word.w	FactNumber
    725  250a
    726  250a							;FACTCONTINUE:
    727  250a							;	  TSTB	     F1AA,kTrue
    728  250a				   ekTrue
      0  250a					      LIT	-1
      0  250a					      db	27
      1  250a		       1b		      .byte.b	27
      0  250b					      dw	-1
      1  250b		       ff ff		      .word.w	-1
      0  250d					      RTN
      0  250d					      db	25
      1  250d		       19		      .byte.b	25
    731  250e							;F1AA:
    732  250e							;	  TSTB	     F1AB,kFalse
    733  250e				   ekFalse
      0  250e					      LIT	0
      0  250e					      db	27
      1  250e		       1b		      .byte.b	27
      0  250f					      dw	0
      1  250f		       00 00		      .word.w	0
      0  2511					      RTN
      0  2511					      db	25
      1  2511		       19		      .byte.b	25
    736  2512							;==================================================================================
    737  2512							; Returns the amount of free SPACE
    738  2512							;
    739  2512							;F1AB
    740  2512							;	  TSTB	     F1A,kFree
    741  2512				   ekFree
      0  2512					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2512					      db	101
      1  2512		       65		      .byte.b	101
      0  2513					      db	(UNKNOWNVEC-*)-1
      1  2513		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  2514					      db	oLeftBracket
      1  2514		       e0		      .byte.b	oLeftBracket
      0  2515					      TSTB	UNKNOWNVEC,oRightBracket
      0  2515					      db	101
      1  2515		       65		      .byte.b	101
      0  2516					      db	(UNKNOWNVEC-*)-1
      1  2516		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  2517					      db	oRightBracket
      1  2517		       e1		      .byte.b	oRightBracket
      0  2518					      FREE
      0  2518					      db	36
      1  2518		       24		      .byte.b	36
      0  2519					      RTN
      0  2519					      db	25
      1  2519		       19		      .byte.b	25
    746  251a							;===================================================================================
    747  251a							; getch() read a character from the input device
    748  251a							;
    749  251a							;F1A:
    750  251a							;	  TSTB	     F1A2,kGetch		      ; read char from the terminal
    751  251a				   ekGetch
      0  251a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  251a					      db	101
      1  251a		       65		      .byte.b	101
      0  251b					      db	(UNKNOWNVEC-*)-1
      1  251b		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  251c					      db	oLeftBracket
      1  251c		       e0		      .byte.b	oLeftBracket
      0  251d					      TSTB	UNKNOWNVEC,oRightBracket
      0  251d					      db	101
      1  251d		       65		      .byte.b	101
      0  251e					      db	(UNKNOWNVEC-*)-1
      1  251e		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  251f					      db	oRightBracket
      1  251f		       e1		      .byte.b	oRightBracket
      0  2520					      GETCHAR
      0  2520					      db	51
      1  2520		       33		      .byte.b	51
      0  2521					      RTN
      0  2521					      db	25
      1  2521		       19		      .byte.b	25
    756  2522							;====================================================================================
    757  2522							; peek(mem address) return the value of a byte in memory
    758  2522							; @[offset] return a word value from offset -- see tstv
    759  2522							;
    760  2522							;F1A2:
    761  2522							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    762  2522				   ekPeek
      0  2522					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2522					      db	101
      1  2522		       65		      .byte.b	101
      0  2523					      db	(UNKNOWNVEC-*)-1
      1  2523		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  2524					      db	oLeftBracket
      1  2524		       e0		      .byte.b	oLeftBracket
      0  2525					      CALL	EXPR	;Get the address to write to
      0  2525					      db	28
      1  2525		       1c		      .byte.b	28
      0  2526					      dw	EXPR
      1  2526		       90 24		      .word.w	EXPR
      0  2528					      TSTB	UNKNOWNVEC,oRightBracket
      0  2528					      db	101
      1  2528		       65		      .byte.b	101
      0  2529					      db	(UNKNOWNVEC-*)-1
      1  2529		       d8		      .byte.b	(UNKNOWNVEC-*)-1
      0  252a					      db	oRightBracket
      1  252a		       e1		      .byte.b	oRightBracket
      0  252b					      PEEKMEM
      0  252b					      db	48
      1  252b		       30		      .byte.b	48
      0  252c					      RTN
      0  252c					      db	25
      1  252c		       19		      .byte.b	25
    768  252d							;=======================================================================================
    769  252d							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    770  252d							;
    771  252d							;F2AZ:
    772  252d							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    773  252d				   ekTask
      0  252d					      TSTBRANCH	ekTaskCompiled
      0  252d					      db	106
      1  252d		       6a		      .byte.b	106
      0  252e					      db	(ekTaskCompiled-*)-1
      1  252e		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  252f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  252f					      db	101
      1  252f		       65		      .byte.b	101
      0  2530					      db	(UNKNOWNVEC-*)-1
      1  2530		       d1		      .byte.b	(UNKNOWNVEC-*)-1
      0  2531					      db	oLeftBracket
      1  2531		       e0		      .byte.b	oLeftBracket
      0  2532					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2532					      db	28
      1  2532		       1c		      .byte.b	28
      0  2533					      dw	EXPR
      1  2533		       90 24		      .word.w	EXPR
      0  2535					      lit	0
      0  2535					      db	27
      1  2535		       1b		      .byte.b	27
      0  2536					      dw	0
      1  2536		       00 00		      .word.w	0
      0  2538					      iJMP	ekTaskLinenum
      0  2538					      db	29
      1  2538		       1d		      .byte.b	29
      0  2539					      dw	ekTaskLinenum
      1  2539		       3e 25		      .word.w	ekTaskLinenum
    779  253b
    780  253b				   ekTaskCompiled
      0  253b					      lit	1
      0  253b					      db	27
      1  253b		       1b		      .byte.b	27
      0  253c					      dw	1
      1  253c		       01 00		      .word.w	1
    782  253e
    783  253e				   ekTaskLinenum
      0  253e					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  253e					      db	61
      1  253e		       3d		      .byte.b	61
      0  253f					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  253f					      db	101
      1  253f		       65		      .byte.b	101
      0  2540					      db	(F2AZNoParms-*)-1
      1  2540		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  2541					      db	oComma
      1  2541		       e2		      .byte.b	oComma
      0  2542					      SAVEMATHSTACK		;Push The mathstack
      0  2542					      db	86
      1  2542		       56		      .byte.b	86
      0  2543					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  2543					      db	89
      1  2543		       59		      .byte.b	89
    788  2544				   F2AZLOOP
      0  2544					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  2544					      db	28
      1  2544		       1c		      .byte.b	28
      0  2545					      dw	EXPR
      1  2545		       90 24		      .word.w	EXPR
      0  2547					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  2547					      db	101
      1  2547		       65		      .byte.b	101
      0  2548					      db	(F2AZEndParm-*)-1
      1  2548		       04		      .byte.b	(F2AZEndParm-*)-1
      0  2549					      db	oComma
      1  2549		       e2		      .byte.b	oComma
      0  254a					      IJMP	F2AZLOOP	;check for more
      0  254a					      db	29
      1  254a		       1d		      .byte.b	29
      0  254b					      dw	F2AZLOOP
      1  254b		       44 25		      .word.w	F2AZLOOP
    792  254d
    793  254d				   F2AZEndParm
      0  254d					      RESTOREMATHSTACK		;Back to normal stack
      0  254d					      db	87
      1  254d		       57		      .byte.b	87
      0  254e					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  254e					      db	92
      1  254e		       5c		      .byte.b	92
    796  254f
    797  254f				   F2AZNoParms
      0  254f					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  254f					      db	101
      1  254f		       65		      .byte.b	101
      0  2550					      db	(UNKNOWNVEC-*)-1
      1  2550		       b1		      .byte.b	(UNKNOWNVEC-*)-1
      0  2551					      db	oRightBracket
      1  2551		       e1		      .byte.b	oRightBracket
    799  2552
      0  2552					      TASKENABLE		;Enable the task to execute
      0  2552					      db	90
      1  2552		       5a		      .byte.b	90
    801  2553
      0  2553					      RTN		;Returns the Task number
      0  2553					      db	25
      1  2553		       19		      .byte.b	25
    803  2554							;=========================================================================================
    804  2554							; Check for IPC interproccess instructions
    805  2554							;   IPCS  - Send a message
    806  2554							;
    807  2554							;F2AZ1:
    808  2554							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    809  2554				   ekIpcs
      0  2554					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2554					      db	101
      1  2554		       65		      .byte.b	101
      0  2555					      db	(UNKNOWNVEC-*)-1
      1  2555		       ac		      .byte.b	(UNKNOWNVEC-*)-1
      0  2556					      db	oLeftBracket
      1  2556		       e0		      .byte.b	oLeftBracket
      0  2557					      CALL	EXPR	;Get the message value
      0  2557					      db	28
      1  2557		       1c		      .byte.b	28
      0  2558					      dw	EXPR
      1  2558		       90 24		      .word.w	EXPR
      0  255a					      TSTB	UNKNOWNVEC,oComma
      0  255a					      db	101
      1  255a		       65		      .byte.b	101
      0  255b					      db	(UNKNOWNVEC-*)-1
      1  255b		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  255c					      db	oComma
      1  255c		       e2		      .byte.b	oComma
      0  255d					      CALL	EXPR	;Get pid of task to send to
      0  255d					      db	28
      1  255d		       1c		      .byte.b	28
      0  255e					      dw	EXPR
      1  255e		       90 24		      .word.w	EXPR
      0  2560					      TSTB	UNKNOWNVEC,oRightBracket
      0  2560					      db	101
      1  2560		       65		      .byte.b	101
      0  2561					      db	(UNKNOWNVEC-*)-1
      1  2561		       a0		      .byte.b	(UNKNOWNVEC-*)-1
      0  2562					      db	oRightBracket
      1  2562		       e1		      .byte.b	oRightBracket
      0  2563					      IPCSEND		;Send msg and clear pid msg pending
      0  2563					      db	80
      1  2563		       50		      .byte.b	80
      0  2564					      RTN
      0  2564					      db	25
      1  2564		       19		      .byte.b	25
    817  2565							;================================================================================
    818  2565							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    819  2565							;
    820  2565							;F2AZa:
    821  2565							;	  TSTB	      F2AZb,kIpcr		      ;IPCR recieve a message , wait if none
    822  2565				   ekIpcr
      0  2565					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2565					      db	101
      1  2565		       65		      .byte.b	101
      0  2566					      db	(UNKNOWNVEC-*)-1
      1  2566		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  2567					      db	oLeftBracket
      1  2567		       e0		      .byte.b	oLeftBracket
      0  2568					      TSTB	F2AZa1,oRightBracket
      0  2568					      db	101
      1  2568		       65		      .byte.b	101
      0  2569					      db	(F2AZa1-*)-1
      1  2569		       07		      .byte.b	(F2AZa1-*)-1
      0  256a					      db	oRightBracket
      1  256a		       e1		      .byte.b	oRightBracket
      0  256b					      LIT	0	;We dont want the pid returned to us
      0  256b					      db	27
      1  256b		       1b		      .byte.b	27
      0  256c					      dw	0
      1  256c		       00 00		      .word.w	0
      0  256e					      IJMP	ekIpcrComplete
      0  256e					      db	29
      1  256e		       1d		      .byte.b	29
      0  256f					      dw	ekIpcrComplete
      1  256f		       76 25		      .word.w	ekIpcrComplete
    827  2571				   F2AZa1
      0  2571					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  2571					      db	33
      1  2571		       21		      .byte.b	33
      0  2572					      db	(UNKNOWNVEC-*)-1
      1  2572		       8f		      .byte.b	(UNKNOWNVEC-*)-1
      0  2573					      TSTB	UNKNOWNVEC,oRightBracket
      0  2573					      db	101
      1  2573		       65		      .byte.b	101
      0  2574					      db	(UNKNOWNVEC-*)-1
      1  2574		       8d		      .byte.b	(UNKNOWNVEC-*)-1
      0  2575					      db	oRightBracket
      1  2575		       e1		      .byte.b	oRightBracket
    830  2576
    831  2576				   ekIpcrComplete
      0  2576					      IPCIO		;Set the io bit and exit task till message
      0  2576					      db	83
      1  2576		       53		      .byte.b	83
      0  2577					      IPCRECEIVE		;Get the message
      0  2577					      db	81
      1  2577		       51		      .byte.b	81
      0  2578					      RTN
      0  2578					      db	25
      1  2578		       19		      .byte.b	25
    835  2579							;===============================================================================
    836  2579							; IPCC ---- check if a message is available
    837  2579							;F2AZb:
    838  2579							;	  TST	     F2A,kIpcc			      ;Returns number of messages on the message queue
    839  2579				   ekIpcc
      0  2579					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2579					      db	101
      1  2579		       65		      .byte.b	101
      0  257a					      db	(UNKNOWNVEC-*)-1
      1  257a		       87		      .byte.b	(UNKNOWNVEC-*)-1
      0  257b					      db	oLeftBracket
      1  257b		       e0		      .byte.b	oLeftBracket
      0  257c					      TSTB	UNKNOWNVEC,oRightBracket
      0  257c					      db	101
      1  257c		       65		      .byte.b	101
      0  257d					      db	(UNKNOWNVEC-*)-1
      1  257d		       84		      .byte.b	(UNKNOWNVEC-*)-1
      0  257e					      db	oRightBracket
      1  257e		       e1		      .byte.b	oRightBracket
      0  257f					      IPCCHECK
      0  257f					      db	82
      1  257f		       52		      .byte.b	82
      0  2580					      RTN
      0  2580					      db	25
      1  2580		       19		      .byte.b	25
    844  2581
    845  2581				   UNKNOWNID
      0  2581					      IJMP	UNKNOWN
      0  2581					      db	29
      1  2581		       1d		      .byte.b	29
      0  2582					      dw	UNKNOWN
      1  2582		       8c 24		      .word.w	UNKNOWN
    847  2584							;============================================================
    848  2584							; RND() is supposed to have an argument but if none
    849  2584							; was provided, just assume a large value.
    850  2584							;
    851  2584							;F2A:
    852  2584							;	  TSTB	      F2B,kRnd
    853  2584				   ekRnd
      0  2584					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2584					      db	101
      1  2584		       65		      .byte.b	101
      0  2585					      db	(UNKNOWNVEC-*)-1
      1  2585		       7c		      .byte.b	(UNKNOWNVEC-*)-1
      0  2586					      db	oLeftBracket
      1  2586		       e0		      .byte.b	oLeftBracket
      0  2587					      TSTB	F2A1,oRightBracket
      0  2587					      db	101
      1  2587		       65		      .byte.b	101
      0  2588					      db	(F2A1-*)-1
      1  2588		       06		      .byte.b	(F2A1-*)-1
      0  2589					      db	oRightBracket
      1  2589		       e1		      .byte.b	oRightBracket
      0  258a					      LIT	32766
      0  258a					      db	27
      1  258a		       1b		      .byte.b	27
      0  258b					      dw	32766
      1  258b		       fe 7f		      .word.w	32766
      0  258d					      RANDOM
      0  258d					      db	37
      1  258d		       25		      .byte.b	37
      0  258e					      RTN
      0  258e					      db	25
      1  258e		       19		      .byte.b	25
    859  258f
    860  258f				   F2A1
      0  258f					      CALL	EXPR	;GET RANGE
      0  258f					      db	28
      1  258f		       1c		      .byte.b	28
      0  2590					      dw	EXPR
      1  2590		       90 24		      .word.w	EXPR
      0  2592					      TSTB	UNKNOWNVEC,oRightBracket
      0  2592					      db	101
      1  2592		       65		      .byte.b	101
      0  2593					      db	(UNKNOWNVEC-*)-1
      1  2593		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2594					      db	oRightBracket
      1  2594		       e1		      .byte.b	oRightBracket
      0  2595					      RANDOM
      0  2595					      db	37
      1  2595		       25		      .byte.b	37
      0  2596					      RTN
      0  2596					      db	25
      1  2596		       19		      .byte.b	25
    865  2597							;==========================================================
    866  2597							;	Return absolute value of expresion
    867  2597							;
    868  2597							;F2B:
    869  2597							;	  TSTB	      F2B2,kAbs
    870  2597				   ekAbs
      0  2597					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2597					      db	101
      1  2597		       65		      .byte.b	101
      0  2598					      db	(UNKNOWNVEC-*)-1
      1  2598		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  2599					      db	oLeftBracket
      1  2599		       e0		      .byte.b	oLeftBracket
      0  259a					      CALL	EXPR	;get value
      0  259a					      db	28
      1  259a		       1c		      .byte.b	28
      0  259b					      dw	EXPR
      1  259b		       90 24		      .word.w	EXPR
      0  259d					      TSTB	UNKNOWNVEC,oRightBracket
      0  259d					      db	101
      1  259d		       65		      .byte.b	101
      0  259e					      db	(UNKNOWNVEC-*)-1
      1  259e		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  259f					      db	oRightBracket
      1  259f		       e1		      .byte.b	oRightBracket
      0  25a0					      ABS
      0  25a0					      db	38
      1  25a0		       26		      .byte.b	38
      0  25a1					      RTN
      0  25a1					      db	25
      1  25a1		       19		      .byte.b	25
    876  25a2							;============================================================
    877  25a2							;     Return the the status of a task, provide the PID
    878  25a2							;
    879  25a2							;F2B2:
    880  25a2							;	  TSTB	      F2Z,kStat
    881  25a2				   ekStat
      0  25a2					      TSTB	UNKNOWNVEC,oLeftBracket
      0  25a2					      db	101
      1  25a2		       65		      .byte.b	101
      0  25a3					      db	(UNKNOWNVEC-*)-1
      1  25a3		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  25a4					      db	oLeftBracket
      1  25a4		       e0		      .byte.b	oLeftBracket
      0  25a5					      Call	EXPR
      0  25a5					      db	28
      1  25a5		       1c		      .byte.b	28
      0  25a6					      dw	EXPR
      1  25a6		       90 24		      .word.w	EXPR
      0  25a8					      TSTB	UNKNOWNVEC,oRightBracket
      0  25a8					      db	101
      1  25a8		       65		      .byte.b	101
      0  25a9					      db	(UNKNOWNVEC-*)-1
      1  25a9		       58		      .byte.b	(UNKNOWNVEC-*)-1
      0  25aa					      db	oRightBracket
      1  25aa		       e1		      .byte.b	oRightBracket
      0  25ab					      TASKSTAT
      0  25ab					      db	66
      1  25ab		       42		      .byte.b	66
      0  25ac					      RTN
      0  25ac					      db	25
      1  25ac		       19		      .byte.b	25
    887  25ad							;==============================================================
    888  25ad							; Return the current tasks pid
    889  25ad							;
    890  25ad							;F2Z:
    891  25ad							;	  TSTB	      F2ZA,kPid
    892  25ad				   ekPid
      0  25ad					      TASKPID
      0  25ad					      db	77
      1  25ad		       4d		      .byte.b	77
      0  25ae					      RTN
      0  25ae					      db	25
      1  25ae		       19		      .byte.b	25
    895  25af							;===========================================================================
    896  25af							; Call a machine function, provide the address to call and optionally
    897  25af							; the value to be passed in reg A
    898  25af							;F2ZA:
    899  25af							;	  TSTB	       F2FUNC,kCall		       ;call machine function
    900  25af				   ekCall
      0  25af					      TSTB	UNKNOWNVEC,oLeftBracket
      0  25af					      db	101
      1  25af		       65		      .byte.b	101
      0  25b0					      db	(UNKNOWNVEC-*)-1
      1  25b0		       51		      .byte.b	(UNKNOWNVEC-*)-1
      0  25b1					      db	oLeftBracket
      1  25b1		       e0		      .byte.b	oLeftBracket
      0  25b2					      CALL	EXPR
      0  25b2					      db	28
      1  25b2		       1c		      .byte.b	28
      0  25b3					      dw	EXPR
      1  25b3		       90 24		      .word.w	EXPR
      0  25b5					      TSTB	F2B2A,oComma
      0  25b5					      db	101
      1  25b5		       65		      .byte.b	101
      0  25b6					      db	(F2B2A-*)-1
      1  25b6		       09		      .byte.b	(F2B2A-*)-1
      0  25b7					      db	oComma
      1  25b7		       e2		      .byte.b	oComma
      0  25b8					      CALL	EXPR
      0  25b8					      db	28
      1  25b8		       1c		      .byte.b	28
      0  25b9					      dw	EXPR
      1  25b9		       90 24		      .word.w	EXPR
      0  25bb					      TSTB	UNKNOWNVEC,oRightBracket
      0  25bb					      db	101
      1  25bb		       65		      .byte.b	101
      0  25bc					      db	(UNKNOWNVEC-*)-1
      1  25bc		       45		      .byte.b	(UNKNOWNVEC-*)-1
      0  25bd					      db	oRightBracket
      1  25bd		       e1		      .byte.b	oRightBracket
      0  25be					      CALLFUNC
      0  25be					      db	53
      1  25be		       35		      .byte.b	53
      0  25bf					      RTN
      0  25bf					      db	25
      1  25bf		       19		      .byte.b	25
    908  25c0							; Run the gosub within this function
    909  25c0				   F2B2A
      0  25c0					      TSTB	UNKNOWNID,oRightBracket
      0  25c0					      db	101
      1  25c0		       65		      .byte.b	101
      0  25c1					      db	(UNKNOWNID-*)-1
      1  25c1		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  25c2					      db	oRightBracket
      1  25c2		       e1		      .byte.b	oRightBracket
      0  25c3					      LIT	0	; No parameter passed so just load zero to A
      0  25c3					      db	27
      1  25c3		       1b		      .byte.b	27
      0  25c4					      dw	0
      1  25c4		       00 00		      .word.w	0
      0  25c6					      CALLFUNC
      0  25c6					      db	53
      1  25c6		       35		      .byte.b	53
      0  25c7					      RTN
      0  25c7					      db	25
      1  25c7		       19		      .byte.b	25
    914  25c8							;===========================================================================
    915  25c8							; Same as gosub but expects a return value
    916  25c8							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    917  25c8							;
    918  25c8							;F2FUNC  TSTB	      F2C,kGofn
    919  25c8				   ekGofn
      0  25c8					      Call	GOSUBSTATEMENT
      0  25c8					      db	28
      1  25c8		       1c		      .byte.b	28
      0  25c9					      dw	GOSUBSTATEMENT
      1  25c9		       fd 25		      .word.w	GOSUBSTATEMENT
      0  25cb					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  25cb					      db	8
      1  25cb		       08		      .byte.b	8
      0  25cc					      db	GOSUB_RTN_VALUE
      1  25cc		       81		      .byte.b	GOSUB_RTN_VALUE
      0  25cd					      FASTXFER
      0  25cd					      db	107
      1  25cd		       6b		      .byte.b	107
    923  25ce
    924  25ce				   GOFNRet
      0  25ce					      RTN
      0  25ce					      db	25
      1  25ce		       19		      .byte.b	25
    926  25cf
    927  25cf							;=================================================================================
    928  25cf							;Check for a number !
    929  25cf							;
    930  25cf							;F0:
    931  25cf				   FactNumber
      0  25cf					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  25cf					      db	35
      1  25cf		       23		      .byte.b	35
      0  25d0					      db	(FactVariable-*)-1
      1  25d0		       0f		      .byte.b	(FactVariable-*)-1
      0  25d1					      RTN
      0  25d1					      db	25
      1  25d1		       19		      .byte.b	25
    934  25d2				   F1
      0  25d2					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  25d2					      db	101
      1  25d2		       65		      .byte.b	101
      0  25d3					      db	(F2RTN-*)-1
      1  25d3		       08		      .byte.b	(F2RTN-*)-1
      0  25d4					      db	oLeftBracket
      1  25d4		       e0		      .byte.b	oLeftBracket
      0  25d5					      CALL	EXPR
      0  25d5					      db	28
      1  25d5		       1c		      .byte.b	28
      0  25d6					      dw	EXPR
      1  25d6		       90 24		      .word.w	EXPR
      0  25d8					      TST	F2,oRightBracket
      0  25d8					      db	32
      1  25d8		       20		      .byte.b	32
      0  25d9					      db	(F2-*)-1
      1  25d9		       03		      .byte.b	(F2-*)-1
      0  25da					      db	oRightBracket,0
      1  25da		       e1 00		      .byte.b	oRightBracket,0
    938  25dc				   F2RTN
      0  25dc					      RTN
      0  25dc					      db	25
      1  25dc		       19		      .byte.b	25
    940  25dd
    941  25dd				   F2
      0  25dd					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  25dd					      db	13
      1  25dd		       0d		      .byte.b	13
      0  25de					      dw	ERR_SYNTAX
      1  25de		       05 00		      .word.w	ERR_SYNTAX
    943  25e0							;
    944  25e0							;=============================================================================
    945  25e0							; See if this is just a simple variable
    946  25e0							;  Allow a subscript for any variable
    947  25e0							;
    948  25e0							;F2C:
    949  25e0							;
    950  25e0				   FactVariable
      0  25e0					      TSTV	F1
      0  25e0					      db	33
      1  25e0		       21		      .byte.b	33
      0  25e1					      db	(F1-*)-1
      1  25e1		       f0		      .byte.b	(F1-*)-1
      0  25e2					      TSTB	F2CLocalTask,oBang
      0  25e2					      db	101
      1  25e2		       65		      .byte.b	101
      0  25e3					      db	(F2CLocalTask-*)-1
      1  25e3		       04		      .byte.b	(F2CLocalTask-*)-1
      0  25e4					      db	oBang
      1  25e4		       e8		      .byte.b	oBang
      0  25e5					      IND		; we just got a pid
      0  25e5					      db	20
      1  25e5		       14		      .byte.b	20
      0  25e6					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  25e6					      db	93
      1  25e6		       5d		      .byte.b	93
      0  25e7					      db	(UNKNOWNID-*)-1
      1  25e7		       99		      .byte.b	(UNKNOWNID-*)-1
    955  25e8
    956  25e8				   F2CLocalTask
    957  25e8
      0  25e8					      TSTB	F2C1,oLeftSQBracket
      0  25e8					      db	101
      1  25e8		       65		      .byte.b	101
      0  25e9					      db	(F2C1-*)-1
      1  25e9		       11		      .byte.b	(F2C1-*)-1
      0  25ea					      db	oLeftSQBracket
      1  25ea		       e4		      .byte.b	oLeftSQBracket
      0  25eb					      CALL	EXPR
      0  25eb					      db	28
      1  25eb		       1c		      .byte.b	28
      0  25ec					      dw	EXPR
      1  25ec		       90 24		      .word.w	EXPR
      0  25ee					      TSTB	UNKNOWNID,oRightSQBracket
      0  25ee					      db	101
      1  25ee		       65		      .byte.b	101
      0  25ef					      db	(UNKNOWNID-*)-1
      1  25ef		       91		      .byte.b	(UNKNOWNID-*)-1
      0  25f0					      db	oRightSQBracket
      1  25f0		       e5		      .byte.b	oRightSQBracket
      0  25f1					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  25f1					      db	101
      1  25f1		       65		      .byte.b	101
      0  25f2					      db	(F2INTEGER-*)-1
      1  25f2		       06		      .byte.b	(F2INTEGER-*)-1
      0  25f3					      db	oDollar
      1  25f3		       e7		      .byte.b	oDollar
      0  25f4					      SUBSCRIPT	1	; Byte type array
      0  25f4					      db	64
      1  25f4		       40		      .byte.b	64
      0  25f5					      db	1
      1  25f5		       01		      .byte.b	1
      0  25f6					      IJMP	F2C1	; Get the value to top of stack
      0  25f6					      db	29
      1  25f6		       1d		      .byte.b	29
      0  25f7					      dw	F2C1
      1  25f7		       fb 25		      .word.w	F2C1
    964  25f9
    965  25f9				   F2INTEGER
      0  25f9					      SUBSCRIPT	0	; Integer type array
      0  25f9					      db	64
      1  25f9		       40		      .byte.b	64
      0  25fa					      db	0
      1  25fa		       00		      .byte.b	0
    967  25fb				   F2C1
      0  25fb					      IND		; YES, GET THE VALUE.
      0  25fb					      db	20
      1  25fb		       14		      .byte.b	20
      0  25fc					      RTN
      0  25fc					      db	25
      1  25fc		       19		      .byte.b	25
    970  25fd
    971  25fd							;=============================================================
    972  25fd							; Gosub can be both a Function and a Subroutine
    973  25fd				   GOSUBSTATEMENT
      0  25fd					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  25fd					      db	106
      1  25fd		       6a		      .byte.b	106
      0  25fe					      db	(GOSUBCOMPILED-*)-1
      1  25fe		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  25ff					      CALL	EXPR	; GET DESTINATION
      0  25ff					      db	28
      1  25ff		       1c		      .byte.b	28
      0  2600					      dw	EXPR
      1  2600		       90 24		      .word.w	EXPR
      0  2602					      CALL	GOSUBCONT
      0  2602					      db	28
      1  2602		       1c		      .byte.b	28
      0  2603					      dw	GOSUBCONT
      1  2603		       10 26		      .word.w	GOSUBCONT
      0  2605					      lit	0	; mark as lookup on stack
      0  2605					      db	27
      1  2605		       1b		      .byte.b	27
      0  2606					      dw	0
      1  2606		       00 00		      .word.w	0
      0  2608					      RTN
      0  2608					      db	25
      1  2608		       19		      .byte.b	25
    979  2609
    980  2609				   GOSUBCOMPILED
      0  2609					      CALL	GOSUBCONT
      0  2609					      db	28
      1  2609		       1c		      .byte.b	28
      0  260a					      dw	GOSUBCONT
      1  260a		       10 26		      .word.w	GOSUBCONT
      0  260c					      lit	1	;mark as compiled on stack
      0  260c					      db	27
      1  260c		       1b		      .byte.b	27
      0  260d					      dw	1
      1  260d		       01 00		      .word.w	1
      0  260f					      RTN
      0  260f					      db	25
      1  260f		       19		      .byte.b	25
    984  2610
    985  2610				   GOSUBCONT
      0  2610					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  2610					      db	101
      1  2610		       65		      .byte.b	101
      0  2611					      db	(GOSUBDONE-*)-1
      1  2611		       11		      .byte.b	(GOSUBDONE-*)-1
      0  2612					      db	oLeftBracket
      1  2612		       e0		      .byte.b	oLeftBracket
      0  2613					      STK2TMP		;Transfer stack top to temp
      0  2613					      db	95
      1  2613		       5f		      .byte.b	95
      0  2614					      PUSHMATHSTACK		;Record stack frame for return
      0  2614					      db	84
      1  2614		       54		      .byte.b	84
    989  2615				   GOSUBLOOP
      0  2615					      CALL	EXPR	; Allows what ever fits onto stack
      0  2615					      db	28
      1  2615		       1c		      .byte.b	28
      0  2616					      dw	EXPR
      1  2616		       90 24		      .word.w	EXPR
      0  2618					      INCPARMCOUNT
      0  2618					      db	88
      1  2618		       58		      .byte.b	88
      0  2619					      TSTB	GOSUBParmDONE,oComma
      0  2619					      db	101
      1  2619		       65		      .byte.b	101
      0  261a					      db	(GOSUBParmDONE-*)-1
      1  261a		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  261b					      db	oComma
      1  261b		       e2		      .byte.b	oComma
      0  261c					      IJMP	GOSUBLOOP
      0  261c					      db	29
      1  261c		       1d		      .byte.b	29
      0  261d					      dw	GOSUBLOOP
      1  261d		       15 26		      .word.w	GOSUBLOOP
    994  261f				   GOSUBParmDONE
      0  261f					      TSTB	F2,oRightBracket
      0  261f					      db	101
      1  261f		       65		      .byte.b	101
      0  2620					      db	(F2-*)-1
      1  2620		       bc		      .byte.b	(F2-*)-1
      0  2621					      db	oRightBracket
      1  2621		       e1		      .byte.b	oRightBracket
      0  2622					      TMP2STK		; Restore line to goto
      0  2622					      db	96
      1  2622		       60		      .byte.b	96
    997  2623				   GOSUBDONE
      0  2623					      RTN
      0  2623					      db	25
      1  2623		       19		      .byte.b	25
    999  2624
   1000  2624		       26 24	   ILEND      equ	*
------- FILE mytb.asm
   2419  2624		       26 24	   PROGEND    equ	*
   2420  2624
   2421  2624
   2422  2624							;=====================================================
   2423  2624							; Define start of non page zero data
   2424 U2666					      seg.u	TBData
   2425 U2666
   2426 U2666							;=====================================================
   2427 U2666							; These are storage items not in page zero.
   2428 U2666							;
   2429 U2666							; IRQ BASIC Code Service RTN Support
      0 U2666				   SaveIrqReg db	0	; Store current setting
      1 U2666		       00		      .byte.b	0
      0 U2667				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U2667		       00		      .byte.b	0
      0 U2668				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U2668		       00		      .byte.b	0
      0 U2669				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U2669		       00 00		      .byte.b	0,0
   2434 U266b
   2435 U266b							;
   2436 U266b							;==================================================================================================
   2437 U266b							; Task Management information
   2438 U266b							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2439 U266b							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2440 U266b							; Task switchs happen at the beginning of the next Basic command line
   2441 U266b							; It will not happen during an input or output operations
   2442 U266b							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2443 U266b							; Task Zero is always the root task, main line program
   2444 U266b							;
   2445 U266b							; Layout is repeated for each configured task
   2446 U266b							; Task Table Byte   use masks follow
   2447 U266b		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2448 U266b		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2449 U266b		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2450 U266b		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2451 U266b		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2452 U266b
   2453 U266b		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2454 U266c		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2455 U266c		       27 66	   TASKTABLEEND equ	*	; End of task table
   2456 U266c		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2457 U2766
   2458 U2766							;Task Cycle Counter and reset count
   2459 U2766		       00 00	   taskCurrentCycles ds	2
   2460 U2768		       00 00	   taskResetValue ds	2
   2461 U276a		       00	   taskCounter ds	1	; Count of active tasks
   2462 U276b
   2463 U276b							;
   2464 U276b							; Math stack and IL call and Gosub/For-next return stack definitions
   2465 U276b							;
   2466 U276b		       27 6b	   STACKSTART equ	*
   2467 U276b		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2468 U28fb		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2469 U2a8b		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2470 U2d0b		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code
   2471 U2d0b		       00 34	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2472 U2d0b		       2f 27	   STACKEND   equ	*
   2473 U2d0b		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2474 U2f27							;
   2475 U2f27							;
   2476 U2f27		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2477 U2fab		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2478 U2fac		       00	   printtx    ds	1	;temp X for print funcs
   2479 U2fad		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2480 U2fae		       00	   promptChar ds	1	;the character to use for a prompt
   2481 U2faf		       00	   diddigit   ds	1	;for leading zero suppression
   2482 U2fb0		       00	   putsy      ds	1
   2483 U2fb1		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2484 U2fb3		       00	   sign       ds	1	;0 = positive, else negative
   2485 U2fb4		       00 00	   rtemp1     ds	2	;Temp for x and y
   2486 U2fb6		       00 00	   random     ds	2
   2487 U2fb8		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2488 U2fba		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2489 U2fbc		       00	   tempy      ds	1	;temp y storage
   2490 U2fbd
   2491 U2fbd
   2492 U2fbd							; Moved from page zero as one clock cycle diff gives more space on page zero
   2493 U2fbd		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2494 U2fbf		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2495 U2fc0		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2496 U2fc1		       00	   lineLength ds	1	;Length of current line
   2497 U2fc2
   2498 U2fc2		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2499 U2fc3		       00	   taskRDPending ds	1	; 1 = background read is pending
   2500 U2fc4
   2501 U2fc4				  -	      if	XKIM
   2502 U2fc4				  -buffer     ds	BUFFER_SIZE
   2503 U2fc4					      endif
   2504 U2fc4							;
   2505 U2fc4							; PROGRAMEND is the end of the user's BASIC program.
   2506 U2fc4							; More precisely, it is one byte past the end.  Or,
   2507 U2fc4							; it's where the next line added to the end will be
   2508 U2fc4							; placed.
   2509 U2fc4							;
   2510 U2fc4		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2511 U2fc6		       00 00	   ProgramEnd ds	2	; End of users basic program
   2512 U2fc8		       00 00	   HighMem    ds	2	; highest location
   2513 U2fca		       00 00	   UsedMem    ds	2	; size of user program
   2514 U2fcc		       00 00	   FreeMem    ds	2	; amount of free memory
   2515 U2fce							;
   2516 U2fce							;=====================================================
   2517 U2fce							; This is the start of the user's BASIC program space.
   2518 U2fce							;
   2519 U2fce							; PERSONAL GOAL: This should be no larger than $0DFF.
   2520 U2fce							;		  0200-05FF = 1K
   2521 U2fce							;		  0200-09FF = 2K
   2522 U2fce							;		  0200-0DFF = 3K
   2523 U2fce							;		  0200-11FF = 4K
   2524 U2fce							;		  0200-13FF = 4.5K
   2525 U2fce							;
   2526 U2fce				  -	      if	FIXED
   2527 U2fce				  -	      org	$2000
   2528 U2fce					      endif
   2529 U2fce
   2530 U2fce		       2f ce	   FreeMemStart equ	*
   2531 U2fce							;/*
   2532 U2fce							;	if	CTMON65 || XKIM
   2533 U2fce							;		SEG Code
   2534 U2fce							;		org	AutoRun
   2535 U2fce							;		dw	TBasicCold
   2536 U2fce							;	endif
   2537 U2fce							;*/
   2538 U2fce					      end
