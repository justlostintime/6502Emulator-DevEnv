------- FILE mytb.asm LEVEL 1 PASS 4
      1 U1657				   input      processor	6502
      2 U1657 ????						;=====================================================
      3 U1657 ????						; Bob's Tiny BASIC
      4 U1657 ????						;
      5 U1657 ????						; While working on the Corsham Technologies KIM Clone
      6 U1657 ????						; project, I wanted to include a TINY BASIC since that
      7 U1657 ????						; was a highly desirable feature of early computers.
      8 U1657 ????						;
      9 U1657 ????						; Rather than negotiating copyright issues for
     10 U1657 ????						; existing BASICs, I decided to just write one from
     11 U1657 ????						; scratch.
     12 U1657 ????						;
     13 U1657 ????						; 10/07/2017
     14 U1657 ????						;
     15 U1657 ????						; This implements a stripped down Tiny BASIC
     16 U1657 ????						; interpreter using the Interpretive Language (IL)
     17 U1657 ????						; method as described in the first few issues of
     18 U1657 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1657 ????						; to write various languages simply by changing the
     20 U1657 ????						; IL code rather than the interpreter itself.
     21 U1657 ????						;
     22 U1657 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1657 ????						;		* Fixed major bug in findLine that
     24 U1657 ????						;		  caused corrupted lines, crashes, etc.
     25 U1657 ????						;		* If no parameter given to RND, assume
     26 U1657 ????						;		  32766.
     27 U1657 ????						;		* No more error 5 when a program
     28 U1657 ????						;		  reaches the end without an END.
     29 U1657 ????						;
     30 U1657 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U1657 ????						;		 * Add some usefull system level functions
     32 U1657 ????						;		 * allow a larger number of tiny basic formats
     33 U1657 ????						;		 * Add byte at start of line holding length
     34 U1657 ????						;		   for faster execution of goto and gosub
     35 U1657 ????						;		 * Re-added gosub
     36 U1657 ????						;		 * allow ; or , at end if print stmt
     37 U1657 ????						;		   without CRLF being added.
     38 U1657 ????						;		 * Added extended function erase to
     39 U1657 ????						;		   use the extended ctmon65 rm file
     40 U1657 ????						;		 * Fix quoted text to not have to backtrack
     41 U1657 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     42 U1657 ????						;
     43 U1657 ????						; www.corshamtech.com
     44 U1657 ????						; bob@corshamtech.com
     45 U1657 ????						; JustLostInTime@gmail.com
     46 U1657 ????						;
     47 U1657 ????						;=====================================================
     48 U1657 ????						;
     49 U1657 ????						; Create TRUE and FALSE values for conditionals.
     50 U1657 ????						;
     51 U1657 ????
     52 U1657 ????	       00 00	   FALSE      equ	0
     53 U1657 ????	       ff ff ff ff TRUE       equ	~FALSE
     54 U1657 ????						;
     55 U1657 ????						;---------------------------------------------------------
     56 U1657 ????						; One of these must be set to indicate which environment
     57 U1657 ????						; Tiny BASIC will be running in.  Here are the current
     58 U1657 ????						; environments:
     59 U1657 ????						;
     60 U1657 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     61 U1657 ????						; more K of RAM.
     62 U1657 ????						;
     63 U1657 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     64 U1657 ????						; which enhances, without replacing, the standard KIM
     65 U1657 ????						; monitor.  It gives access to routines to save/load files
     66 U1657 ????						; to a micro SD card.
     67 U1657 ????						;
     68 U1657 ????						; CTMON65 is a from-scratch monitor written for the
     69 U1657 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     70 U1657 ????						; easily be ported to other systems.  It has support for
     71 U1657 ????						; using a micro SD card for file storage/retrieval.
     72 U1657 ????						;
     73 U1657 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     74 U1657 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     75 U1657 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     76 U1657 ????						;
     77 U1657 ????						;   Need to define some macros for the dasm assembler
     78 U1657 ????						;
     79 U1657 ????				      MACRO	dw
     80 U1657 ????				      .word	{0}
     81 U1657 ????				      ENDM
     82 U1657 ????
     83 U1657 ????				      MACRO	db
     84 U1657 ????				      .byte	{0}
     85 U1657 ????				      ENDM
     86 U1657 ????
     87 U1657 ????						;
     88 U1657 ????						; If set, include disk functions.
     89 U1657 ????						;
     90 U1657 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     91 U1657 ????						;
     92 U1657 ????						; If ILTRACE is set then dump out the address of every
     93 U1657 ????						; IL opcode before executing it.
     94 U1657 ????						;
     95 U1657 ????	       00 00	   ILTRACE    equ	FALSE
     96 U1657 ????						;
     97 U1657 ????						; If FIXED is set, put the IL code and the user
     98 U1657 ????						; program space at fixed locations in memory.	This is
     99 U1657 ????						; meant only for debugging.
    100 U1657 ????						;
    101 U1657 ????	       00 00	   FIXED      equ	FALSE
    102 U1657 ????						;
    103 U1657 ????						; Sets the arithmetic stack depth.  This is *TINY*
    104 U1657 ????						; BASIC, so keep this small!
    105 U1657 ????						;
    106 U1657 ????	       00 14	   STACKSIZE  equ	20	;number of entries in math stack
    107 U1657 ????	       00 28	   ILSTACKSIZE equ	40	;number of entries in ilstack
    108 U1657 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub nesting max is 64 times TASKTABLE LENGTH must < 256
    109 U1657 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    110 U1657 ????	       00 14	   TASKCYCLESDEFAULT equ	20	;Default Task Switch 0-255 uses a single byte
    111 U1657 ????						;
    112 U1657 ????						; Common ASCII constants
    113 U1657 ????						;
    114 U1657 ????	       00 07	   BEL	      equ	$07
    115 U1657 ????	       00 08	   BS	      equ	$08
    116 U1657 ????	       00 09	   TAB	      equ	$09
    117 U1657 ????	       00 0a	   LF	      equ	$0A
    118 U1657 ????	       00 0d	   CR	      equ	$0D
    119 U1657 ????	       00 22	   quote      equ	$22
    120 U1657 ????	       00 20	   SPACE      equ	$20
    121 U1657 ????	       00 2c	   COMMA      equ	',
    122 U1657 ????	       00 3b	   SEMICOLON  equ	';
    123 U1657 ????	       00 3a	   COLON      equ	':
    124 U1657 ????	       00 24	   DOLLAR     equ	'$
    125 U1657 ????						;
    126 U1657 ????						; These are error codes
    127 U1657 ????						;
    128 U1657 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    129 U1657 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    130 U1657 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    131 U1657 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    132 U1657 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    133 U1657 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    134 U1657 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    135 U1657 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    136 U1657 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    137 U1657 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    138 U1657 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    139 U1657 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    140 U1657 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    141 U1657 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    142 U1657 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    143 U1657 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    144 U1657 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    145 U1657 ????						;
    146 U1657 ????						;=====================================================
    147 U1657 ????						; Zero page storage.
    148 U1657 ????						;
    149 U1657 ????				      SEG.U	Data
    150 U0040					      org	$0040
    151 U0040
    152 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    153 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    154 U0041		       00 75	   variablesEnd equ	*	;End of variable space
    155 U0075		       00 00	   ILPC       ds	2	;IL program counter
    156 U0077		       00 00	   dpl	      ds	2
    157 U0079		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    158 U007b		       00	   tempIlY    ds	1	;Temp IL Y register storage
    159 U007c		       00	   offset     ds	1	;IL Offset to next inst when test fails
    160 U007d		       00	   lineLength ds	1	;Length of current line
    161 U007e							;
    162 U007e							; CURPTR is a pointer to curent BASIC line being
    163 U007e							; executed.  Always points to start of line, CUROFF
    164 U007e							; is the offset to the current character.
    165 U007e							; The order of these fields is important
    166 U007e		       00 00	   CURPTR     ds	2	;Pointer to current Basic line
    167 U0080		       00	   CUROFF     ds	1	;Current offset in Basic Line
    168 U0081							;
    169 U0081							;The order of these fields in important
    170 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    171 U0083							;GoSubStackPtr 	  ds	  1	      ;current offset in the stack, moved to task table
    172 U0083
    173 U0083							;Defined in data segment here for refrence only
    174 U0083							;taskTable	  ds	  TASKCOUNT*4	     ; Task Table Offset and pointer to Basic code, active flag
    175 U0083							;taskGoStacks	  ds	  TASKCOUNT*4	     ; Table of assigned gosub stack locations and pointers
    176 U0083							;taskPtr	  ds	  1		     ; Current offset into task table 0, 4, 8, 12 ...
    177 U0083							;
    178 U0083
    179 U0083							;
    180 U0083							; R0 and R1 are used for arithmetic operations and
    181 U0083							; general use.
    182 U0083							;
    183 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    184 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    185 U0087							;
    186 U0087							; This is zero if in immediate mode, or non-zero
    187 U0087							; if currently running a program.  Any input from
    188 U0087							; the main loop clears this, and the XFER IL
    189 U0087							; statement will set it.
    190 U0087							;
    191 U0087		       00	   RunMode    ds	1	;Basic program is running or stop
    192 U0088							;
    193 U0088							; Used for line insertion/removal.
    194 U0088							;
    195 U0088		       00 00	   FROM       ds	2	;Used for basic prog insert/remove and print text
    196 U008a
    197 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    198 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    199 U008a							;
    200 U008a		       00 88	   PrtFrom    EQU	FROM
    201 U008a							;
    202 U008a
    203 U008a							;
    204 U008a							;=====================================================
    205 U008a							;
    206  14e8 ????				      SEG	Code
    207  0200					      org	$0200
    208  0200							;
    209  0200							; Cold start is at $0200.  Warm start is at $0203.
    210  0200							;
    211  0200		       4c 18 02    TBasicCold jmp	cold2	;jump around vectors
    212  0203		       4c c1 02    warm       jmp	warm2	;Entry point for worm restart
    213  0206							;
    214  0206							; These are the user-supplied vectors to I/O routines.
    215  0206							; If you want, you can just patch these in the binary
    216  0206							; file, but it would be better to change the source
    217  0206							; code.
    218  0206							;
    219  0206				  -	      if	KIM
    220  0206				  -OUTCH      jmp	$1ea0	;output char in A
    221  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    222  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    223  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    224  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    225  0206					      endif
    226  0206				  -	      if	XKIM
    227  0206				  -	      include	"xkim.inc"
    228  0206				  -	      SEG	Code
    229  0206				  -OUTCH      jmp	$1ea0
    230  0206				  -GETCH      jmp	xkGETCH
    231  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    232  0206				  -OUTHEX     jmp	xkPRTBYT
    233  0206				  -MONITOR    jmp	extKIM
    234  0206				  -puts       equ	putsil
    235  0206				  -BUFFER_SIZE equ	132
    236  0206					      endif
    237  0206
    238  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U00f6 ????				      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 U008a					      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    240  0206					      SEG	Code
    241  0206							;
    242  0206		       4c 0c f0    OUTCH      jmp	cout
    243  0209		       4c 09 f0    GETCH      jmp	cin
    244  020c		       4c 18 f0    CRLF       jmp	crlf
    245  020f		       4c 1b f0    OUTHEX     jmp	HexA
    246  0212		       4c 03 f0    MONITOR    jmp	WARM
    247  0215		       4c 0f f0    ISCHAR     jmp	cstatus
    248  0215		       f0 12	   puts       equ	putsil
    249  0218					      endif
    250  0218							;
    251  0218		       20 12 f0    cold2      jsr	puts
      0  021b					      db	CR,LF
      1  021b		       0d 0a		      .byte.b	CR,LF
      0  021d					      db	"Bob's Tiny BASIC v1.0.2 IRQs"
      1  021d		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs"
      0  0239					      db	CR,LF
      1  0239		       0d 0a		      .byte.b	CR,LF
      0  023b					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  023b		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0269					      db	CR,LF,0
      1  0269		       0d 0a 00 	      .byte.b	CR,LF,0
    257  026c							;
    258  026c		       20 fc 0f 	      jsr	GetSizes	;setup the free space available
    259  026f
    260  026f		       ad 51 16    calcstack  lda	HighMem
    261  0272		       18		      clc
    262  0273		       e9 e0		      sbc	#(GOSUBSTACKSIZE*3*TASKCOUNT)&$FF
    263  0275		       85 81		      sta	GOSUBSTACK
    264  0277		       ad 52 16 	      lda	HighMem+1
    265  027a		       e9 01		      sbc	#(GOSUBSTACKSIZE*3*TASKCOUNT)>>8
    266  027c		       85 82		      sta	GOSUBSTACK+1
    267  027e		       20 3c 04 	      jsr	taskSetGosubStack	; setup all the task stacks
    268  0281		       a9 9a		      lda	#IL&$ff
    269  0283		       85 75		      sta	ILPC
    270  0285		       a9 11		      lda	#IL>>8
    271  0287		       85 76		      sta	ILPC+1
    272  0289							;
    273  0289		       a9 57		      lda	#ProgramStart&$ff	;user prog
    274  028b		       8d 4f 16 	      sta	PROGRAMEND
    275  028e		       a9 16		      lda	#ProgramStart>>8
    276  0290		       8d 50 16 	      sta	PROGRAMEND+1
    277  0293							;
    278  0293							; Initialize the pseudo-random number sequence...
    279  0293							;
    280  0293		       a9 5a		      lda	#$5a
    281  0295		       8d 48 16 	      sta	rtemp1
    282  0298		       a9 9d		      lda	#%10011101
    283  029a		       8d 4a 16 	      sta	random
    284  029d		       a9 5b		      lda	#%01011011
    285  029f		       8d 4b 16 	      sta	random+1
    286  02a2							;
    287  02a2							;   Insert a Basic irq handler for the basic Language
    288  02a2		       a9 af		      lda	#ServiceIrq&$ff
    289  02a4		       8d 00 df 	      sta	IRQvec
    290  02a7		       a9 02		      lda	#ServiceIrq>>8
    291  02a9		       8d 01 df 	      sta	IRQvec+1
    292  02ac		       4c ce 02 	      jmp	coldtwo
    293  02af
    294  02af							;
    295  02af							; This is the Basic IRQ handler
    296  02af		       48	   ServiceIrq pha
    297  02b0		       ad e9 14 	      lda	IRQStatus
    298  02b3		       f0 0a		      BEQ	RetIrq
    299  02b5		       ad ea 14 	      lda	IRQPending
    300  02b8		       d0 05		      bne	RetIrq
    301  02ba		       a9 01		      lda	#1
    302  02bc		       8d ea 14 	      sta	IRQPending
    303  02bf		       68	   RetIrq     pla
    304  02c0		       40		      rti
    305  02c1							;
    306  02c1							;
    307  02c1							; This is the warm start entry point
    308  02c1							;
    309  02c1		       20 0c 02    warm2      jsr	CRLF
    310  02c4		       ad 43 16 	      lda	errGoto
    311  02c7		       85 75		      sta	ILPC
    312  02c9		       ad 44 16 	      lda	errGoto+1
    313  02cc		       85 76		      sta	ILPC+1
    314  02ce							;
    315  02ce							; And continue with both starts here
    316  02ce							;
    317  02ce		       20 2f 10    coldtwo    jsr	SetOutConsole
    318  02d1							;
    319  02d1							; The ILTrace flag is now run-time settable.
    320  02d1							;
    321  02d1		       a9 00		      lda	#ILTRACE&$ff
    322  02d3		       85 40		      sta	ILTrace
    323  02d5							;
    324  02d5		       a9 00		      lda	#0
    325  02d7		       85 87		      sta	RunMode
    326  02d9		       8d bb 15 	      sta	LINBUF
    327  02dc							; Clear everything from the stacks
    328  02dc		       8d 69 15 	      sta	mathStackPtr
    329  02df		       8d ba 15 	      sta	retStackPtr
    330  02e2							;		  sta	  GoSubStackPtr
    331  02e2		       20 3c 06 	      jsr	taskReset
    332  02e5							;
    333  02e5		       a9 bb		      lda	#LINBUF&$ff
    334  02e7		       85 7e		      sta	CURPTR
    335  02e9		       a9 15		      lda	#LINBUF>>8
    336  02eb		       85 7f		      sta	CURPTR+1	;fall through...
    337  02ed
    338  02ed							;=====================================================
    339  02ed							; This is the top of the IL interpreter.  This fetches
    340  02ed							; and executes the instruction currently pointed to
    341  02ed							; by ILPC and adjusts ILPC to point to the next
    342  02ed							; instruction to execute.
    343  02ed							;
    344  02ed		       a5 40	   NextIL     lda	ILTrace
    345  02ef		       f0 03		      beq	NextIL2
    346  02f1		       20 b7 0f 	      jsr	dbgLine
    347  02f4		       a4 80	   NextIL2    ldy	CUROFF
    348  02f6		       20 ae 0f 	      jsr	SkipSpaces
    349  02f9		       84 80		      sty	CUROFF
    350  02fb							;
    351  02fb		       20 8c 0c    NextILStr  jsr	getILByte
    352  02fe							;
    353  02fe							; When the handler is called, these are the conditions
    354  02fe							; of several important items:
    355  02fe							;
    356  02fe							;    (ILPC) will point to the byte AFTER the IL
    357  02fe							;    opcode being executed.
    358  02fe							;
    359  02fe							;    (CURPTR),CUROFF will point to the start of the
    360  02fe							;    next word in the input buffer.  Ie, the next word
    361  02fe							;    in the user program.
    362  02fe							;
    363  02fe		       0a		      asl
    364  02ff		       c9 8c		      cmp	#ILTBLend-ILTBL+2
    365  0301		       90 33		      bcc	ILgood
    366  0303							;
    367  0303							; This handles an illegal IL opcode.  This is serious
    368  0303							; and there's no way to recover.
    369  0303							;
    370  0303		       20 12 f0    ILbad      jsr	puts
      0  0306					      db	CR,LF
      1  0306		       0d 0a		      .byte.b	CR,LF
      0  0308					      db	"Illegal IL "
      1  0308		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  0313					      db	0
      1  0313		       00		      .byte.b	0
    374  0314							;
    375  0314							; Well this is awkward, we need to back up the IL
    376  0314							; by one since it no longer points to the current
    377  0314							; opcode.
    378  0314							;
    379  0314		       20 99 0c 	      jsr	decIL
    380  0317							;
    381  0317		       a0 00		      ldy	#0
    382  0319		       b1 75		      lda	(ILPC),y
    383  031b		       20 0f 02 	      jsr	OUTHEX
    384  031e		       20 12 f0 	      jsr	puts
      0  0321					      db	" at ",0
      1  0321		       20 61 74 20*	      .byte.b	" at ",0
    386  0326		       a5 76		      lda	ILPC+1
    387  0328		       20 0f 02 	      jsr	OUTHEX
    388  032b		       a5 75		      lda	ILPC
    389  032d		       20 0f 02 	      jsr	OUTHEX
    390  0330		       20 0c 02 	      jsr	CRLF
    391  0333		       4c 12 02 	      jmp	MONITOR
    392  0336							;
    393  0336							; Just jump to the address (ILPC),y.  Have to do
    394  0336							; some goofy stuff.
    395  0336							;
    396  0336		       a8	   ILgood     tay		;move index into Y
    397  0337		       b9 44 03 	      lda	ILTBL,y
    398  033a		       85 77		      sta	dpl
    399  033c		       b9 45 03 	      lda	ILTBL+1,y
    400  033f		       85 78		      sta	dpl+1
    401  0341		       6c 77 00 	      jmp	(dpl)	;go to handler
    402  0344							;
    403  0344							;=====================================================
    404  0344							; This is the IL jump table.  The IL opcode is
    405  0344							; mulitplied by two, then looked-up in this table.
    406  0344							; There is absolutely nothing special about the order
    407  0344							; of entries here... they all decode at exactly the
    408  0344							; same speed.	However the entry number must match the
    409  0344							; values in IL.inc.
    410  0344							;
      0  0344				   ILTBL      dw	iXINIT	;0
      1  0344		       fd 03		      .word.w	iXINIT
      0  0346					      dw	iDONE	;1
      1  0346		       79 04		      .word.w	iDONE
      0  0348					      dw	iPRS	;2
      1  0348		       95 04		      .word.w	iPRS
      0  034a					      dw	iPRN	;3
      1  034a		       9f 04		      .word.w	iPRN
      0  034c					      dw	iSPC	;4
      1  034c		       a8 04		      .word.w	iSPC
      0  034e					      dw	iNLINE	;5
      1  034e		       a5 08		      .word.w	iNLINE
      0  0350					      dw	iNXT	;6
      1  0350		       b0 04		      .word.w	iNXT
      0  0352					      dw	iXFER	;7
      1  0352		       dc 04		      .word.w	iXFER
      0  0354					      dw	iSAV	;8
      1  0354		       09 05		      .word.w	iSAV
      0  0356					      dw	iRSTR	;9
      1  0356		       2a 05		      .word.w	iRSTR
      0  0358					      dw	iCMPR	;10
      1  0358		       36 05		      .word.w	iCMPR
      0  035a					      dw	iINNUM	;11
      1  035a		       95 05		      .word.w	iINNUM
      0  035c					      dw	iFIN	;12
      1  035c		       bf 05		      .word.w	iFIN
      0  035e					      dw	iERR	;13
      1  035e		       d0 05		      .word.w	iERR
      0  0360					      dw	iADD	;14
      1  0360		       5c 06		      .word.w	iADD
      0  0362					      dw	iSUB	;15
      1  0362		       72 06		      .word.w	iSUB
      0  0364					      dw	iNEG	;16
      1  0364		       88 06		      .word.w	iNEG
      0  0366					      dw	iMUL	;17
      1  0366		       a0 06		      .word.w	iMUL
      0  0368					      dw	iDIV	;18
      1  0368		       da 06		      .word.w	iDIV
      0  036a					      dw	iSTORE	;19
      1  036a		       3a 07		      .word.w	iSTORE
      0  036c					      dw	iIND	;20
      1  036c		       4d 07		      .word.w	iIND
      0  036e					      dw	iLST	;21
      1  036e		       7f 07		      .word.w	iLST
      0  0370					      dw	iINIT	;22
      1  0370		       ce 03		      .word.w	iINIT
      0  0372					      dw	iGETLINE	;23
      1  0372		       de 07		      .word.w	iGETLINE
      0  0374					      dw	iINSRT	;24
      1  0374		       ea 07		      .word.w	iINSRT
      0  0376					      dw	iRTN	;25
      1  0376		       9f 08		      .word.w	iRTN
      0  0378					      dw	MONITOR	;26
      1  0378		       12 02		      .word.w	MONITOR
      0  037a					      dw	iLIT	;27
      1  037a		       b8 08		      .word.w	iLIT
      0  037c					      dw	iCALL	;28
      1  037c		       ab 08		      .word.w	iCALL
      0  037e					      dw	iJMP	;29
      1  037e		       ae 08		      .word.w	iJMP
      0  0380					      dw	iVINIT	;30
      1  0380		       c5 08		      .word.w	iVINIT
      0  0382					      dw	iERRGOTO	;31
      1  0382		       d3 08		      .word.w	iERRGOTO
      0  0384					      dw	iTST	;32
      1  0384		       df 08		      .word.w	iTST
      0  0386					      dw	iTSTV	;33
      1  0386		       64 09		      .word.w	iTSTV
      0  0388					      dw	iTSTL	;34
      1  0388		       8e 09		      .word.w	iTSTL
      0  038a					      dw	iTSTN	;35
      1  038a		       a8 09		      .word.w	iTSTN
      0  038c					      dw	iFREE	;36
      1  038c		       82 0a		      .word.w	iFREE
      0  038e					      dw	iRANDOM	;37
      1  038e		       8b 0a		      .word.w	iRANDOM
      0  0390					      dw	iABS	;38
      1  0390		       64 0b		      .word.w	iABS
    450  0392							;
    451  0392							; Disk functions.  There must be pointers
    452  0392							; to functions even if no disk is supported.
    453  0392							; Makes things easier in IL.inc.
    454  0392							;
    455  0392					      if	DISK_ACCESS
      0  0392					      dw	iOPENREAD	;39
      1  0392		       75 10		      .word.w	iOPENREAD
      0  0394					      dw	iOPENWRITE	;40
      1  0394		       c9 10		      .word.w	iOPENWRITE
      0  0396					      dw	iDCLOSE	;41
      1  0396		       4d 11		      .word.w	iDCLOSE
      0  0398					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0398		       e8 10		      .word.w	iDGETLINE
      0  039a					      dw	iDLIST	;43 Did you remeber your towel?
      1  039a		       47 11		      .word.w	iDLIST
      0  039c					      dw	iDDIR	;44
      1  039c		       22 11		      .word.w	iDDIR
      0  039e					      dw	iRMFILE	;45
      1  039e		       a3 10		      .word.w	iRMFILE
    463  03a0				  -	      else
    464  03a0				  -	      dw	NextIL	;39
    465  03a0				  -	      dw	NextIL	;40
    466  03a0				  -	      dw	NextIL	;41
    467  03a0				  -	      dw	NextIL	;42
    468  03a0				  -	      dw	NextIL	;43
    469  03a0				  -	      dw	NextIL	;44
    470  03a0				  -	      dw	NextIL	;45
    471  03a0					      endif
    472  03a0							;
      0  03a0					      dw	iCLEARSCREEN	;46
      1  03a0		       6a 10		      .word.w	iCLEARSCREEN
      0  03a2					      dw	iPOKEMEMORY	;47
      1  03a2		       eb 0a		      .word.w	iPOKEMEMORY
      0  03a4					      dw	iPEEKMEMORY	;48
      1  03a4		       00 0b		      .word.w	iPEEKMEMORY
      0  03a6					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03a6		       24 09		      .word.w	iTSTLET
      0  03a8					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  03a8		       43 09		      .word.w	iTSTDONE
      0  03aa					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03aa		       2d 0b		      .word.w	iGETCHAR
      0  03ac					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03ac		       47 0b		      .word.w	iPUTCHAR
      0  03ae					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03ae		       16 0b		      .word.w	iCallFunc
      0  03b0					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  03b0		       83 05		      .word.w	iBranch
      0  03b2					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03b2		       08 09		      .word.w	iTSTStr
      0  03b4					      dw	iSetIrq	;56	   sets the irq handler
      1  03b4		       7e 0b		      .word.w	iSetIrq
      0  03b6					      dw	iTstIrq	;57	   test if irq is pending
      1  03b6		       eb 09		      .word.w	iTstIrq
      0  03b8					      dw	iRET	;58	   return from interupt
      1  03b8		       18 05		      .word.w	iRET
      0  03ba					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03ba		       a6 05		      .word.w	iINSTR
      0  03bc					      dw	iMOD	;60	   returns remainder of division
      1  03bc		       e3 06		      .word.w	iMOD
      0  03be					      dw	iTaskSwitch	;61	   switch to the next BASIC program task
      1  03be		       22 0a		      .word.w	iTaskSwitch
      0  03c0					      dw	iTaskSet	;62	   sets a line number for the start of a task
      1  03c0		       b5 0b		      .word.w	iTaskSet
      0  03c2					      dw	iETask	;63	   Terminates a task
      1  03c2		       4d 0c		      .word.w	iETask
      0  03c4					      dw	iNTask	;64	   goto next task
      1  03c4		       45 0c		      .word.w	iNTask
      0  03c6					      dw	iArray	;65	   Allow Variable to have a subscript
      1  03c6		       5d 07		      .word.w	iArray
      0  03c8					      dw	iTaskKill	;66	   kill a running task
      1  03c8		       3d 0c		      .word.w	iTaskKill
      0  03ca					      dw	iTaskStat	;67	   return the state of a task PID
      1  03ca		       0f 0c		      .word.w	iTaskStat
      0  03cc					      dw	iHexOut	;68	   output the value on the stack as a hex string
      1  03cc		       52 0b		      .word.w	iHexOut
    496  03ce
    497  03ce		       03 ce	   ILTBLend   equ	*
    498  03ce							;
    499  03ce							;=====================================================
    500  03ce							;=====================================================
    501  03ce							;=====================================================
    502  03ce							; This marks the start of the handlers for IL opcodes.
    503  03ce							;=====================================================
    504  03ce							;=====================================================
    505  03ce							;=====================================================
    506  03ce							;
    507  03ce							;
    508  03ce		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    509  03d0		       8d ba 15 	      sta	retStackPtr
    510  03d3		       8d 69 15 	      sta	mathStackPtr
    511  03d6		       20 3c 06 	      jsr	taskReset
    512  03d9							;		  sta	  GoSubStackPtr
    513  03d9							;
    514  03d9		       a9 57		      lda	#ProgramStart&$ff	;user prog
    515  03db		       85 7e		      sta	CURPTR
    516  03dd		       8d ee 14 	      sta	taskTable+1
    517  03e0		       8d 4f 16 	      sta	PROGRAMEND
    518  03e3		       a9 16		      lda	#ProgramStart>>8
    519  03e5		       85 7f		      sta	CURPTR+1
    520  03e7		       8d ef 14 	      sta	taskTable+2
    521  03ea		       8d 50 16 	      sta	PROGRAMEND+1
    522  03ed		       a9 01		      lda	#1
    523  03ef		       8d ed 14 	      sta	taskTable	;Mark the first slot as active
    524  03f2		       8d 40 15 	      sta	taskCount	;there is always one task / Main task
    525  03f5		       a9 14		      lda	#TASKCYCLESDEFAULT
    526  03f7		       8d 3f 15 	      sta	taskResetValue
    527  03fa		       8d 3e 15 	      sta	taskCurrentCycles	; set up the task switch counts
    528  03fd							;
    529  03fd							; fall into XINIT...
    530  03fd							;
    531  03fd							;=====================================================
    532  03fd							; This initializes for the start of the next line of
    533  03fd							; BASIC text.
    534  03fd							;
    535  03fd		       78	   iXINIT     sei		;ensure interupts are off
    536  03fe		       a9 00		      lda	#0
    537  0400		       8d 69 15 	      sta	mathStackPtr	;clear math stack
    538  0403		       8d 3d 15 	      sta	taskPtr	;Set the first slot
    539  0406		       8d ea 14 	      sta	IRQPending	; reset the irq pending
    540  0409		       8d e9 14 	      sta	IRQStatus	; Make sure irqs are off
    541  040c		       a9 01		      lda	#1
    542  040e		       8d 40 15 	      sta	taskCount	;Number of actual tasks
    543  0411		       20 25 04 	      jsr	taskClear	;Clear the task table
    544  0414		       4c ed 02    goodExit   jmp	NextIL
    545  0417							;
    546  0417							;=====================================================
    547  0417							; This check if the escape key has been entered
    548  0417							; then changes out of run mode. z Set if esc found
    549  0417				   BreakSet
    550  0417		       20 15 02 	      jsr	ISCHAR
    551  041a		       f0 06		      beq	BreakNo
    552  041c		       20 09 02 	      jsr	GETCH
    553  041f		       c9 1b		      cmp	#$1B
    554  0421		       60		      rts
    555  0422				   BreakNo
    556  0422		       a9 01		      lda	#1
    557  0424		       60		      rts
    558  0425							;
    559  0425							;=====================================================
    560  0425							; Clear the task table
    561  0425				   taskClear
    562  0425		       98		      tya
    563  0426		       48		      pha
    564  0427		       a0 04		      ldy	#4
    565  0429		       a9 00		      lda	#0
    566  042b		       c0 28	   taskClearLoop cpy	#TASKCOUNT*4
    567  042d		       f0 0a		      beq	taskClearDone
    568  042f		       99 ed 14 	      sta	taskTable,y
    569  0432		       c8		      iny
    570  0433		       c8		      iny
    571  0434		       c8		      iny
    572  0435		       c8		      iny
    573  0436		       4c 2b 04 	      jmp	taskClearLoop
    574  0439		       68	   taskClearDone pla
    575  043a		       a8		      tay
    576  043b		       60		      rts
    577  043c
    578  043c							;
    579  043c							;=====================================================
    580  043c							; Sets the pointers to the gosub stacks
    581  043c				   taskSetGosubStack
    582  043c		       a2 0a		      ldx	#TASKCOUNT
    583  043e		       a0 00		      ldy	#0
    584  0440		       a5 81	   taskGoSetLoop lda	GOSUBSTACK
    585  0442		       99 15 15 	      sta	taskGoStacks,y
    586  0445		       a5 82		      lda	GOSUBSTACK+1
    587  0447		       99 16 15 	      sta	taskGoStacks+1,y
    588  044a		       c8		      iny
    589  044b		       c8		      iny
    590  044c		       c8		      iny
    591  044d		       c8		      iny
    592  044e		       ca		      dex
    593  044f		       f0 10		      beq	taskGoSetDone
    594  0451		       a9 30		      lda	#GOSUBSTACKSIZE*3	; must be less than 256
    595  0453		       18		      clc
    596  0454		       65 81		      adc	GOSUBSTACK
    597  0456		       85 81		      sta	GOSUBSTACK
    598  0458		       a9 00		      lda	#0
    599  045a		       65 82		      adc	GOSUBSTACK+1
    600  045c		       85 82		      sta	GOSUBSTACK+1
    601  045e		       4c 40 04 	      jmp	taskGoSetLoop
    602  0461
    603  0461				   taskGoSetDone
    604  0461		       ad 15 15 	      lda	taskGoStacks	; Restore the task 0 stack pointer
    605  0464		       85 81		      sta	GOSUBSTACK
    606  0466		       ad 16 15 	      lda	taskGoStacks+1
    607  0469		       85 82		      sta	GOSUBSTACK+1
    608  046b		       60		      rts
    609  046c
    610  046c							;
    611  046c							;========================================================
    612  046c							; Set the gosub stack pointer to the correct entry
    613  046c							;
    614  046c				   taskUpdateGosubStack
    615  046c		       ac 3d 15 	      ldy	taskPtr
    616  046f		       b9 15 15 	      lda	taskGoStacks,y
    617  0472		       85 81		      sta	GOSUBSTACK
    618  0474		       b9 16 15 	      lda	taskGoStacks+1,y
    619  0477		       85 82		      sta	GOSUBSTACK+1
    620  0479
    621  0479							;
    622  0479							;=====================================================
    623  0479							; Verify there is nothing else on this input line.
    624  0479							; If there is, generate an error.
    625  0479							;
    626  0479		       a4 80	   iDONE      ldy	CUROFF
    627  047b		       20 ae 0f 	      jsr	SkipSpaces
    628  047e		       b1 7e		      lda	(CURPTR),y
    629  0480		       f0 10		      beq	doneadv
    630  0482		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    631  0484		       d0 05		      bne	idoneErr
    632  0486		       84 80		      sty	CUROFF
    633  0488		       4c ed 02 	      jmp	NextIL	; continue on this line
    634  048b
    635  048b				   idoneErr
    636  048b		       a2 04		      ldx	#ERR_EXTRA_STUFF
    637  048d		       a9 00		      lda	#0
    638  048f		       4c d3 05 	      jmp	iErr2
    639  0492							;
    640  0492							; Advance to the next line
    641  0492							;
    642  0492				   doneadv
    643  0492							;		 jsr	 FindNext2
    644  0492		       4c ed 02 	      jmp	NextIL
    645  0495							;
    646  0495							;=====================================================
    647  0495							; Print the string until a closing quote
    648  0495							;
    649  0495		       a4 80	   iPRS       ldy	CUROFF
    650  0497							;
    651  0497							; Odd logic here.  The main loop skipped any leading
    652  0497							; whitespace inside the quoted text, so move back to
    653  0497							; the quote, then move forward again.
    654  0497							;
    655  0497		       20 3d 10 	      jsr	PrtQuoted
    656  049a		       84 80		      sty	CUROFF
    657  049c		       4c ed 02 	      jmp	NextIL
    658  049f							;
    659  049f							;=====================================================
    660  049f							; Pop the top off the stack and print it as a signed
    661  049f							; decimal number.
    662  049f							;
    663  049f		       20 09 0f    iPRN       jsr	popR0
    664  04a2		       20 31 0d 	      jsr	PrintDecimal
    665  04a5		       4c ed 02 	      jmp	NextIL
    666  04a8							;
    667  04a8							;=====================================================
    668  04a8							; Space to next zone.	Currently the code does not
    669  04a8							; keep track of which column the output is on, so
    670  04a8							; just print a tab.
    671  04a8							;
    672  04a8		       a9 09	   iSPC       lda	#TAB
    673  04aa		       20 06 02 	      jsr	OUTCH
    674  04ad		       4c ed 02 	      jmp	NextIL
    675  04b0							;
    676  04b0							;=====================================================
    677  04b0							; If in immediate mode, jump to the address following
    678  04b0							; the NXT instruction.  Else move to the next line of
    679  04b0							; user code and continue.
    680  04b0							;
    681  04b0		       a5 87	   iNXT       lda	RunMode
    682  04b2		       d0 03		      bne	iNxtRun	;in run mode
    683  04b4							;
    684  04b4							; Get address and jump to it.
    685  04b4							;
    686  04b4		       4c ae 08 	      jmp	iJMP
    687  04b7							;
    688  04b7				   iNxtRun
    689  04b7		       a4 80		      ldy	CUROFF
    690  04b9		       20 ae 0f 	      jsr	SkipSpaces
    691  04bc		       b1 7e		      lda	(CURPTR),y
    692  04be		       c9 3a		      cmp	#COLON
    693  04c0		       d0 09		      bne	iNxtRunGo
    694  04c2		       c8		      iny
    695  04c3		       20 ae 0f 	      jsr	SkipSpaces
    696  04c6		       84 80		      sty	CUROFF
    697  04c8		       4c d6 04 	      jmp	iNxtRun2
    698  04cb
    699  04cb				   iNxtRunGo
    700  04cb		       20 12 0d 	      jsr	FindNextLine
    701  04ce		       20 24 0d 	      jsr	AtEnd
    702  04d1		       d0 03		      bne	iNxtRun2	;not at end
    703  04d3							;
    704  04d3							; At the end of the program.  Pretend an END statement
    705  04d3							; was found.
    706  04d3							;
    707  04d3		       4c bf 05    iFINv      jmp	iFIN
    708  04d6							;
    709  04d6		       20 88 0c    iNxtRun2   jsr	getILWord	;ignore next word
    710  04d9		       4c ed 02 	      jmp	NextIL
    711  04dc							;
    712  04dc							;=====================================================
    713  04dc							; XFER takes the number on top of the stack and looks
    714  04dc							; for that line in the program, or the next line
    715  04dc							; higher.  Ie, if it's 1 but there is no line 1, then
    716  04dc							; find the next one after that.
    717  04dc							;
    718  04dc		       20 09 0f    iXFER      jsr	popR0
    719  04df		       20 cf 0c 	      jsr	findLine
    720  04e2		       20 24 0d    iXFER2     jsr	AtEnd	;at end of user program?
    721  04e5		       f0 ec		      beq	iFINv
    722  04e7		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    723  04e9		       84 80		      sty	CUROFF
    724  04eb		       a9 ff		      lda	#$ff
    725  04ed		       85 87		      sta	RunMode
    726  04ef							;
    727  04ef							; Transfer IL to STMT.  I don't like having this
    728  04ef							; hard-coded; fix it.
    729  04ef							;
    730  04ef		       a9 a8		      lda	#STMT&$ff
    731  04f1		       85 75		      sta	ILPC
    732  04f3		       a9 11		      lda	#STMT>>8
    733  04f5		       85 76		      sta	ILPC+1
    734  04f7		       4c ed 02 	      jmp	NextIL
    735  04fa							;
    736  04fa							; Run
    737  04fa							;
    738  04fa				   iXferok
    739  04fa		       a9 ff		      lda	#$ff
    740  04fc		       85 87		      sta	RunMode	;we're running
    741  04fe							;
    742  04fe							; Need a more elegant way to do this
    743  04fe							;
    744  04fe		       a9 a8		      lda	#STMT&$ff
    745  0500		       85 75		      sta	ILPC
    746  0502		       a9 11		      lda	#STMT>>8
    747  0504		       85 76		      sta	ILPC+1
    748  0506		       4c ed 02 	      jmp	NextIL
    749  0509							;
    750  0509							;=====================================================
    751  0509							; Save the pointer to the next line to the call stack.
    752  0509							;
    753  0509		       20 a8 0e    iSAV       jsr	pushLN
    754  050c		       b0 03		      bcs	iSAVErr
    755  050e		       4c ed 02 	      jmp	NextIL
    756  0511
    757  0511		       a2 0c	   iSAVErr    ldx	#12
    758  0513		       a9 00	   iSAVErr2   lda	#0
    759  0515		       4c d3 05 	      jmp	iErr2
    760  0518
    761  0518							;
    762  0518							;=====================================================
    763  0518							; Pop the next line from the call stack.
    764  0518							;
    765  0518		       20 cf 0e    iRET       jsr	popLN
    766  051b		       b0 f4		      bcs	iSAVErr
    767  051d		       a0 03		      ldy	#3
    768  051f		       84 80		      sty	CUROFF
    769  0521		       a9 00		      lda	#0
    770  0523		       8d ea 14 	      sta	IRQPending
    771  0526		       58		      cli
    772  0527		       4c ed 02 	      jmp	NextIL
    773  052a							;
    774  052a							;=====================================================
    775  052a							; Return from IL program call
    776  052a							;
    777  052a		       20 cf 0e    iRSTR      jsr	popLN
    778  052d		       b0 e2		      bcs	iSAVErr
    779  052f		       4c ed 02 	      jmp	NextIL
    780  0532
    781  0532		       a2 0b	   iRSTRErr   ldx	#11
    782  0534		       d0 dd		      bne	iSAVErr2
    783  0536							;
    784  0536							;=====================================================
    785  0536							; Compare items on stack.  Okay, so on input there are
    786  0536							; three things on the stack
    787  0536							;
    788  0536							;    EXPR2 <- Top of stack
    789  0536							;    OP    <- relational operator, next on stack
    790  0536							;    EXPR1 <- last item on stack
    791  0536							;
    792  0536							; Comparison is: EXPR1 <operator> EXPR2
    793  0536							;
    794  0536							; Operator is one of...
    795  0536							;
    796  0536							;    2 is =
    797  0536							;    1 is <
    798  0536							;    3 is <=
    799  0536							;    5 is <>
    800  0536							;    4 is >
    801  0536							;    6 is >=
    802  0536							;
    803  0536							; Those are bit-mapped:
    804  0536							;
    805  0536							;    xxxxxGEL
    806  0536							;
    807  0536							;    G = Greater than
    808  0536							;    E = Equal
    809  0536							;    L = Less than
    810  0536							;
    811  0536							; If the comparison is false, do a NXT, ie, move to the
    812  0536							; next line and continue.  If true, continue executing
    813  0536							; on this line.
    814  0536							;
    815  0536		       00 01	   REL_LT     equ	%001
    816  0536		       00 02	   REL_EQUAL  equ	%010
    817  0536		       00 04	   REL_GT     equ	%100
    818  0536							;
    819  0536		       20 1c 0f    iCMPR      jsr	popR1
    820  0539		       20 2f 0f 	      jsr	popMQ	;operator in MQ
    821  053c		       20 09 0f 	      jsr	popR0
    822  053f							;
    823  053f							; See if they are equal or not
    824  053f							;
    825  053f		       a5 83		      lda	R0
    826  0541		       c5 85		      cmp	R1
    827  0543		       d0 0a		      bne	iCMPRnoteq	;try not equal
    828  0545		       a5 84		      lda	R0+1
    829  0547		       c5 86		      cmp	R1+1
    830  0549		       d0 04		      bne	iCMPRnoteq
    831  054b							;
    832  054b							; Equal, set the flag in MQ+1
    833  054b							;
    834  054b		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    835  054d		       d0 14		      bne	iCMPcom	;Exit it is equal
    836  054f							;
    837  054f							; See if EXPR1 (R0) < EXPR2 (R1)
    838  054f							; See www.6502.org/tutorials/compare_beyond.html
    839  054f							;
    840  054f				   iCMPRnoteq
    841  054f		       a5 83		      lda	R0
    842  0551		       c5 85		      cmp	R1
    843  0553		       a5 84		      lda	R0+1
    844  0555		       e5 86		      sbc	R1+1
    845  0557		       50 02		      bvc	iCMPR_2
    846  0559		       49 80		      eor	#$80
    847  055b		       30 04	   iCMPR_2    bmi	iCMPlt
    848  055d		       a9 04		      lda	#REL_GT
    849  055f		       d0 02		      bne	iCMPcom
    850  0561		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    851  0563
    852  0563		       0d 46 16    iCMPcom    ora	MQ+1	; or with original mask
    853  0566							;
    854  0566							; Now compare the end result with what the caller
    855  0566							; was looking for.
    856  0566							;
    857  0566		       2d 45 16 	      and	MQ
    858  0569		       f0 0a		      beq	iCMPno	; no match
    859  056b		       a9 01		      lda	#1
    860  056d		       85 83		      sta	R0
    861  056f		       d0 08		      bne	iCMPDone
    862  0571							;
    863  0571							; R0 > R1
    864  0571							;
    865  0571		       a9 04	   iCMPgt     lda	#REL_GT
    866  0573		       d0 ee		      bne	iCMPcom
    867  0575				   iCMPno
    868  0575		       a9 00		      lda	#0
    869  0577		       85 83		      sta	R0
    870  0579
    871  0579				   iCMPDone
    872  0579		       a9 00		      lda	#0
    873  057b		       85 84		      sta	R0+1
    874  057d		       20 95 0e 	      jsr	pushR0
    875  0580		       4c ed 02 	      jmp	NextIL
    876  0583							;
    877  0583							; if Not a match, so jump to the next line of code.
    878  0583							; Branches based upon value on top of the stack
    879  0583				   iBranch
    880  0583		       20 09 0f 	      jsr	popR0
    881  0586		       a5 83		      lda	R0
    882  0588		       05 84		      ora	R0+1
    883  058a		       f0 03		      beq	iBranchFalse	; not true
    884  058c		       4c ed 02 	      jmp	NextIL	; It is true if any value not zero
    885  058f							;
    886  058f				   iBranchFalse
    887  058f		       20 12 0d 	      jsr	FindNextLine
    888  0592		       4c e2 04 	      jmp	iXFER2
    889  0595							;
    890  0595							;=====================================================
    891  0595							; Get a line of text from the user, convert to a
    892  0595							; number, leave on top of stack.
    893  0595							;
    894  0595				   iINNUM
    895  0595		       20 a8 0e 	      jsr	pushLN
    896  0598							;
    897  0598		       a9 3f		      lda	#'?
    898  059a		       20 14 0e 	      jsr	GetLine
    899  059d		       20 9d 0d 	      jsr	getDecimal
    900  05a0		       20 95 0e 	      jsr	pushR0	;put onto stack
    901  05a3							;
    902  05a3		       4c b9 05 	      jmp	ExitIn
    903  05a6							;
    904  05a6							;=====================================================
    905  05a6							; Get a line of text from the user, convert to a
    906  05a6							; String , leave on top of stack. up to 2 characters
    907  05a6							;
    908  05a6				   iINSTR
    909  05a6		       20 a8 0e 	      jsr	pushLN
    910  05a9		       a9 3f		      lda	#'?
    911  05ab		       20 14 0e 	      jsr	GetLine
    912  05ae		       b1 7e		      lda	(CURPTR),y
    913  05b0		       85 83		      sta	R0
    914  05b2		       a9 00		      lda	#0
    915  05b4		       85 84		      sta	R0+1
    916  05b6		       20 95 0e 	      jsr	pushR0	;put onto stack
    917  05b9				   ExitIn
    918  05b9		       20 cf 0e 	      jsr	popLN
    919  05bc		       4c ed 02 	      jmp	NextIL
    920  05bf							;
    921  05bf							;
    922  05bf							;=====================================================
    923  05bf							; Stop the currently running program.	Actually very
    924  05bf							; simple to do... clear the RunMode flag, then set the
    925  05bf							; ILPC to the standard handler and continue running.
    926  05bf							;
    927  05bf		       a9 00	   iFIN       lda	#0
    928  05c1		       85 87		      sta	RunMode
    929  05c3							;
    930  05c3		       ad 43 16 	      lda	errGoto
    931  05c6		       85 75		      sta	ILPC
    932  05c8		       ad 44 16 	      lda	errGoto+1
    933  05cb		       85 76		      sta	ILPC+1
    934  05cd		       4c ed 02 	      jmp	NextIL
    935  05d0							;
    936  05d0							;=====================================================
    937  05d0							; Handle the ERR opcode.  Following the instruction is
    938  05d0							; a 16 bit error number.  Print an error message, and
    939  05d0							; if we're in run mode, print the line number.  Stop
    940  05d0							; program execution and return to the initial state.
    941  05d0							;
    942  05d0		       20 88 0c    iERR       jsr	getILWord	;get err code
    943  05d3							;
    944  05d3							; Enter here with the error code in X (LSB) and A (MSB).
    945  05d3							;
    946  05d3		       86 83	   iErr2      stx	R0
    947  05d5		       85 84		      sta	R0+1
    948  05d7							;
    949  05d7		       20 12 f0 	      jsr	puts
      0  05da					      db	"Error ",0
      1  05da		       45 72 72 6f*	      .byte.b	"Error ",0
    951  05e1		       20 31 0d 	      jsr	PrintDecimal
    952  05e4							;
    953  05e4		       a5 87		      lda	RunMode	;running?
    954  05e6		       f0 3b		      beq	iERR3	;nope
    955  05e8		       20 12 f0 	      jsr	puts
      0  05eb					      db	" at line ",0
      1  05eb		       20 61 74 20*	      .byte.b	" at line ",0
    957  05f5		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    958  05f7				   iErr2a
    959  05f7		       b1 7e		      lda	(CURPTR),y
    960  05f9		       85 83		      sta	R0
    961  05fb		       c8		      iny
    962  05fc		       b1 7e		      lda	(CURPTR),y
    963  05fe		       85 84		      sta	R0+1
    964  0600		       20 31 0d 	      jsr	PrintDecimal
    965  0603		       20 12 f0 	      jsr	puts
      0  0606					      db	":",0
      1  0606		       3a 00		      .byte.b	":",0
    967  0608		       a9 00		      lda	#0
    968  060a		       85 84		      sta	R0+1
    969  060c		       a5 80		      lda	CUROFF
    970  060e		       18		      clc
    971  060f		       e9 03		      sbc	#3
    972  0611		       85 83		      sta	R0
    973  0613		       20 31 0d 	      jsr	PrintDecimal
    974  0616		       20 12 f0 	      jsr	puts
      0  0619					      db	":",0
      1  0619		       3a 00		      .byte.b	":",0
    976  061b		       ad 3d 15 	      lda	taskPtr
    977  061e		       85 83		      sta	R0
    978  0620		       20 31 0d 	      jsr	PrintDecimal
    979  0623							;
    980  0623		       20 0c 02    iERR3      jsr	CRLF
    981  0626		       a9 00		      lda	#0
    982  0628		       85 87		      sta	RunMode	;fall through...
    983  062a							;
    984  062a							;=====================================================
    985  062a							; Reset the IL to be back at the idle loop.  Does not
    986  062a							; clear variables so the user can see what state
    987  062a							; the program is in.
    988  062a							;
    989  062a		       a9 00	   ResetIL    lda	#0
    990  062c		       8d ba 15 	      sta	retStackPtr
    991  062f		       ad 43 16 	      lda	errGoto
    992  0632		       85 75		      sta	ILPC
    993  0634		       ad 44 16 	      lda	errGoto+1
    994  0637		       85 76		      sta	ILPC+1
    995  0639		       4c ed 02 	      jmp	NextIL
    996  063c
    997  063c							;
    998  063c							;=====================================================
    999  063c							; Clear all task entries and task gosub stacks
   1000  063c				   taskReset
   1001  063c		       a9 00		      lda	#0
   1002  063e		       a0 00		      ldy	#0
   1003  0640		       8d 3d 15 	      sta	taskPtr	; Set the active task to 0 MAIN
   1004  0643		       99 ed 14    taskResetLoop sta	taskTable,y	; clear any active tasks
   1005  0646		       99 17 15 	      sta	taskGoStacks+2,y	; clear all the task gosub pointers
   1006  0649		       c8		      iny
   1007  064a		       c8		      iny
   1008  064b		       c8		      iny
   1009  064c		       c8		      iny
   1010  064d		       c0 28		      cpy	#TASKCOUNT<<2
   1011  064f		       d0 f2		      bne	taskResetLoop
   1012  0651		       ad 15 15 	      lda	taskGoStacks	; ensure the main task stack is active
   1013  0654		       85 81		      sta	GOSUBSTACK
   1014  0656		       ad 16 15 	      lda	taskGoStacks+1
   1015  0659		       85 82		      sta	GOSUBSTACK+1
   1016  065b		       60		      rts
   1017  065c							;
   1018  065c							;=====================================================
   1019  065c							; Pop two items off stack, add them, then place the
   1020  065c							; result back onto the stack.
   1021  065c							;
   1022  065c		       20 09 0f    iADD       jsr	popR0
   1023  065f		       20 1c 0f 	      jsr	popR1
   1024  0662		       18		      clc
   1025  0663		       a5 83		      lda	R0
   1026  0665		       65 85		      adc	R1
   1027  0667		       85 83		      sta	R0
   1028  0669		       a5 84		      lda	R0+1
   1029  066b		       65 86		      adc	R1+1
   1030  066d		       85 84		      sta	R0+1
   1031  066f		       4c d4 06 	      jmp	pushR0nextIl
   1032  0672							;
   1033  0672							;=====================================================
   1034  0672							; Pop two items off the stack.  Subtract the top of
   1035  0672							; stack from the lower entry.
   1036  0672							;
   1037  0672		       20 1c 0f    iSUB       jsr	popR1
   1038  0675		       20 09 0f 	      jsr	popR0
   1039  0678		       38		      sec
   1040  0679		       a5 83		      lda	R0
   1041  067b		       e5 85		      sbc	R1
   1042  067d		       85 83		      sta	R0
   1043  067f		       a5 84		      lda	R0+1
   1044  0681		       e5 86		      sbc	R1+1
   1045  0683		       85 84		      sta	R0+1
   1046  0685		       4c d4 06 	      jmp	pushR0nextIl
   1047  0688							;
   1048  0688							;=====================================================
   1049  0688							; Negate the top of stack.
   1050  0688							;
   1051  0688		       20 09 0f    iNEG       jsr	popR0
   1052  068b		       a5 83		      lda	R0
   1053  068d		       49 ff		      eor	#$ff
   1054  068f		       85 83		      sta	R0
   1055  0691		       a5 84		      lda	R0+1
   1056  0693		       49 ff		      eor	#$ff
   1057  0695		       85 84		      sta	R0+1
   1058  0697		       e6 83		      inc	R0
   1059  0699		       d0 02		      bne	iNEG2
   1060  069b		       e6 84		      inc	R0+1
   1061  069d		       4c d4 06    iNEG2      jmp	pushR0nextIl
   1062  06a0							;
   1063  06a0							;=====================================================
   1064  06a0							; Multiply top two items on the stack, put the results
   1065  06a0							; on top.  This uses the algorithm documented on page
   1066  06a0							; 115 of "Microprocessor Programming for Computer
   1067  06a0							; Hobbyists" by Neill Graham.
   1068  06a0							;
   1069  06a0		       20 09 0f    iMUL       jsr	popR0	;AC
   1070  06a3		       20 1c 0f 	      jsr	popR1	;OP
   1071  06a6							;
   1072  06a6		       a5 83		      lda	R0
   1073  06a8		       8d 45 16 	      sta	MQ
   1074  06ab		       a5 84		      lda	R0+1
   1075  06ad		       8d 46 16 	      sta	MQ+1
   1076  06b0		       a9 00		      lda	#0	;clear result
   1077  06b2		       85 83		      sta	R0
   1078  06b4		       85 84		      sta	R0+1
   1079  06b6							;
   1080  06b6		       a2 10		      ldx	#16	;number of bits in value
   1081  06b8		       06 83	   multloop   asl	R0
   1082  06ba		       26 84		      rol	R0+1
   1083  06bc		       0e 45 16 	      asl	MQ
   1084  06bf		       2e 46 16 	      rol	MQ+1
   1085  06c2		       90 0d		      bcc	multno	;skip add if no carry
   1086  06c4							;
   1087  06c4							; Add R1 back into R0
   1088  06c4							;
   1089  06c4		       18		      clc
   1090  06c5		       a5 83		      lda	R0
   1091  06c7		       65 85		      adc	R1
   1092  06c9		       85 83		      sta	R0
   1093  06cb		       a5 84		      lda	R0+1
   1094  06cd		       65 86		      adc	R1+1
   1095  06cf		       85 84		      sta	R0+1
   1096  06d1							;
   1097  06d1		       ca	   multno     dex		;did all bits yet?
   1098  06d2		       d0 e4		      bne	multloop
   1099  06d4							;
   1100  06d4				   pushR0nextIl
   1101  06d4		       20 95 0e 	      jsr	pushR0	;OP
   1102  06d7		       4c ed 02 	      jmp	NextIL
   1103  06da							;
   1104  06da							;=====================================================
   1105  06da							; Divide the top of stack into the next to top item.
   1106  06da							; Leave results on stack.  Taken from:
   1107  06da							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1108  06da							;
   1109  06da							; R0 = R0 / R1
   1110  06da							; Remainder is in MQ
   1111  06da							;
   1112  06da		       20 f6 06    iDIV       jsr	iDoDiv
   1113  06dd		       20 7f 0f 	      jsr	RestoreSigns
   1114  06e0		       4c d4 06 	      jmp	pushR0nextIl
   1115  06e3
   1116  06e3		       20 f6 06    iMOD       jsr	iDoDiv
   1117  06e6		       20 7f 0f 	      jsr	RestoreSigns
   1118  06e9		       ad 45 16 	      lda	MQ
   1119  06ec		       85 83		      sta	R0
   1120  06ee		       ad 46 16 	      lda	MQ+1
   1121  06f1		       85 84		      sta	R0+1
   1122  06f3		       4c d4 06 	      jmp	pushR0nextIl
   1123  06f6
   1124  06f6				   iDoDiv
   1125  06f6		       20 1c 0f 	      jsr	popR1
   1126  06f9		       20 09 0f 	      jsr	popR0
   1127  06fc							;
   1128  06fc							; Check for divide by zero
   1129  06fc							;
   1130  06fc
   1131  06fc				   iDivNoPop
   1132  06fc		       a5 85		      lda	R1
   1133  06fe		       05 86		      ora	R1+1
   1134  0700		       f0 31		      beq	divby0
   1135  0702							;
   1136  0702		       20 44 0f 	      jsr	SaveSigns
   1137  0705		       a9 00		      lda	#0	;preset remainder to 0
   1138  0707		       8d 45 16 	      sta	MQ
   1139  070a		       8d 46 16 	      sta	MQ+1
   1140  070d		       a2 10		      ldx	#16	;repeat for each bit: ...
   1141  070f				   divloop
   1142  070f		       06 83		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1143  0711		       26 84		      rol	R0+1
   1144  0713		       2e 45 16 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1145  0716		       2e 46 16 	      rol	MQ+1
   1146  0719		       ad 45 16 	      lda	MQ
   1147  071c		       38		      sec
   1148  071d		       e5 85		      sbc	R1	;substract divisor to see if it fits in
   1149  071f		       a8		      tay		;lb result -> Y, for we may need it later
   1150  0720		       ad 46 16 	      lda	MQ+1
   1151  0723		       e5 86		      sbc	R1+1
   1152  0725		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1153  0727
   1154  0727		       8d 46 16 	      sta	MQ+1	;else save substraction result as new remainder,
   1155  072a		       8c 45 16 	      sty	MQ
   1156  072d		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1157  072f
   1158  072f		       ca	   skip       dex
   1159  0730		       d0 dd		      bne	divloop
   1160  0732		       60		      rts
   1161  0733							;
   1162  0733							; Indicate divide-by-zero error
   1163  0733							;
   1164  0733		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1165  0735		       a9 00		      lda	#0
   1166  0737		       4c d3 05 	      jmp	iErr2
   1167  073a							;
   1168  073a							;=====================================================
   1169  073a							; This pops the top two items off the stack.  The top
   1170  073a							; item is a data value and the other is an index into
   1171  073a							; the variable table.	Save the value into that entry.
   1172  073a							;
   1173  073a		       20 09 0f    iSTORE     jsr	popR0	;data
   1174  073d		       20 1c 0f 	      jsr	popR1	;index
   1175  0740		       a6 85		      ldx	R1	;get index
   1176  0742		       a5 83		      lda	R0
   1177  0744		       95 41		      sta	variables,x
   1178  0746		       a5 84		      lda	R0+1
   1179  0748		       95 42		      sta	variables+1,x
   1180  074a		       4c ed 02 	      jmp	NextIL
   1181  074d							;
   1182  074d							;=====================================================
   1183  074d							; Replaces the top of stack with the variable whose
   1184  074d							; index it represents.
   1185  074d							;
   1186  074d				   iIND
   1187  074d		       20 1c 0f 	      jsr	popR1
   1188  0750		       a6 85		      ldx	R1	;get index
   1189  0752		       b5 41		      lda	variables,x
   1190  0754		       85 83		      sta	R0
   1191  0756		       b5 42		      lda	variables+1,x
   1192  0758		       85 84		      sta	R0+1
   1193  075a		       4c d4 06 	      jmp	pushR0nextIl
   1194  075d							;
   1195  075d							;=====================================================
   1196  075d							; Get the array index from top of stack get Current variable
   1197  075d							; index from next on stack, add the offset
   1198  075d							; push the result back onto the stack
   1199  075d				   iArray
   1200  075d		       20 09 0f 	      jsr	popR0
   1201  0760		       20 1c 0f 	      jsr	popR1
   1202  0763		       c6 83		      dec	R0	; Basic array index starts at 1
   1203  0765		       a5 83		      lda	R0
   1204  0767		       18		      clc
   1205  0768		       2a		      rol
   1206  0769		       65 85		      adc	R1
   1207  076b		       c9 34		      cmp	#(26*2)
   1208  076d		       b0 09		      bcs	iArrayError
   1209  076f		       85 83		      sta	R0
   1210  0771		       a5 84		      lda	R0+1
   1211  0773		       d0 03		      bne	iArrayError
   1212  0775		       4c d4 06 	      jmp	pushR0nextIl
   1213  0778							; Get here if array index is out of range
   1214  0778				   iArrayError
   1215  0778		       a9 00		      lda	#0
   1216  077a		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1217  077c		       4c d3 05 	      jmp	iErr2
   1218  077f							;
   1219  077f							;=====================================================
   1220  077f							; List the current BASIC program in memory.  Uses R0,
   1221  077f							; tempIly, and dpl.
   1222  077f							;
   1223  077f		       20 2f 10    iLST       jsr	SetOutConsole
   1224  0782		       a9 57	   iLST2      lda	#ProgramStart&$ff
   1225  0784		       85 77		      sta	dpl
   1226  0786		       a9 16		      lda	#ProgramStart>>8
   1227  0788		       85 78		      sta	dpl+1
   1228  078a							;
   1229  078a							; dpl/dph point to the current line.  See if we're at
   1230  078a							; the end of the program.
   1231  078a							;
   1232  078a		       a5 77	   iLSTloop   lda	dpl
   1233  078c		       cd 4f 16 	      cmp	PROGRAMEND
   1234  078f		       d0 07		      bne	iLstNotEnd
   1235  0791		       a5 78		      lda	dpl+1
   1236  0793		       cd 50 16 	      cmp	PROGRAMEND+1
   1237  0796		       f0 40		      beq	iLstdone
   1238  0798							;
   1239  0798		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1240  079a		       b1 77		      lda	(dpl),y	;line number LSB
   1241  079c		       85 83		      sta	R0
   1242  079e		       c8		      iny
   1243  079f		       b1 77		      lda	(dpl),y	;line number MSB
   1244  07a1		       85 84		      sta	R0+1
   1245  07a3		       c8		      iny
   1246  07a4		       84 7b		      sty	tempIlY
   1247  07a6		       20 31 0d 	      jsr	PrintDecimal
   1248  07a9		       a9 20		      lda	#SPACE
   1249  07ab		       20 3a 10 	      jsr	VOUTCH
   1250  07ae		       a4 7b		      ldy	tempIlY
   1251  07b0		       b1 77	   iLSTl2     lda	(dpl),y
   1252  07b2		       f0 0a		      beq	iLST3	;end of this line 0 value
   1253  07b4		       84 7b		      sty	tempIlY
   1254  07b6		       20 3a 10 	      jsr	VOUTCH
   1255  07b9		       a4 7b		      ldy	tempIlY
   1256  07bb		       c8		      iny
   1257  07bc		       d0 f2		      bne	iLSTl2	;do next char
   1258  07be							;
   1259  07be							; End of this line.  Print CR/LF, then move to the
   1260  07be							; next line.
   1261  07be							;
   1262  07be		       c8	   iLST3      iny		;Move to next line
   1263  07bf		       18		      clc		;Clear the carry flag
   1264  07c0		       98		      tya		;Current Offset
   1265  07c1		       65 77		      adc	dpl	;Add the offset to the pointer
   1266  07c3		       85 77		      sta	dpl	;Save the new value
   1267  07c5		       a5 78		      lda	dpl+1	;Next byte
   1268  07c7		       69 00		      adc	#0	;ad in the carry if any
   1269  07c9		       85 78		      sta	dpl+1	;Save it
   1270  07cb							;
   1271  07cb							; Have to manually do CR/LF so it uses the vectored
   1272  07cb							; output function.
   1273  07cb							;
   1274  07cb		       a9 0d		      lda	#CR
   1275  07cd		       20 3a 10 	      jsr	VOUTCH
   1276  07d0		       a9 0a		      lda	#LF
   1277  07d2		       20 3a 10 	      jsr	VOUTCH
   1278  07d5		       4c 8a 07 	      jmp	iLSTloop	;do next line
   1279  07d8							;
   1280  07d8		       20 2f 10    iLstdone   jsr	SetOutConsole
   1281  07db		       4c ed 02 	      jmp	NextIL
   1282  07de							;
   1283  07de							;=====================================================
   1284  07de							; Get a line of text into LINBUF.  Terminate with a
   1285  07de							; null byte.
   1286  07de							;
   1287  07de		       a9 3e	   iGETLINE   lda	#'>	;prompt character
   1288  07e0		       20 14 0e 	      jsr	GetLine
   1289  07e3							;
   1290  07e3		       a9 00		      lda	#0
   1291  07e5		       85 87		      sta	RunMode
   1292  07e7		       4c ed 02 	      jmp	NextIL
   1293  07ea							;
   1294  07ea							;=====================================================
   1295  07ea							; This is called when the input buffer contains a line
   1296  07ea							; typed in by the user that starts with a line number.
   1297  07ea							; Insert the line into the program or delete the line
   1298  07ea							; if there is nothing after the line number,
   1299  07ea							;
   1300  07ea		       a0 00	   iINSRT     ldy	#0
   1301  07ec		       20 9d 0d 	      jsr	getDecimal	;convert line #
   1302  07ef		       20 ae 0f 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1303  07f2		       84 7c		      sty	offset	;Save the start of the program line text
   1304  07f4							;
   1305  07f4							; Now find the line OR the next higher line OR the
   1306  07f4							; end of the program.
   1307  07f4							;
   1308  07f4		       20 cf 0c 	      jsr	findLine	; Look for the line number in the current program
   1309  07f7							; Returns Z and curptr point to the line if found
   1310  07f7							; Returns C and curptr at next higher line if not found and there is a higher line
   1311  07f7							; Returns ZC clear and curptr to end of program if higher than all other lines
   1312  07f7							;
   1313  07f7							; If the line exists, it needs to be removed.
   1314  07f7							;
   1315  07f7		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1316  07f9							;
   1317  07f9							; Get length of line to be removed, we fall thru to here if we find a matching line
   1318  07f9							;
   1319  07f9							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1320  07f9		       a0 00		      ldy	#0
   1321  07fb		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1322  07fd		       a8		      tay
   1323  07fe							;If it is equal we delete the line and replace it, get length
   1324  07fe							;then adjust all program line after up or down depending on len of line
   1325  07fe							;If next higher then just move everythimg down by length bytes
   1326  07fe							;This call will return how many bytes in the line we found
   1327  07fe		       84 7d		      sty	lineLength	;Save the length of the line we found
   1328  0800							;
   1329  0800							; Compute the new end of the program first.
   1330  0800							;
   1331  0800		       38		      sec		;Set the carry bit
   1332  0801		       ad 4f 16 	      lda	PROGRAMEND	;Get low byte of program end
   1333  0804		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1334  0806		       8d 4f 16 	      sta	PROGRAMEND	;save it
   1335  0809		       ad 50 16 	      lda	PROGRAMEND+1
   1336  080c		       e9 00		      sbc	#0	;Process the carry
   1337  080e		       8d 50 16 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1338  0811							;
   1339  0811							; Copy CURPTR into R1 for working
   1340  0811							;
   1341  0811		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1342  0813		       85 85		      sta	R1
   1343  0815		       a5 7f		      lda	CURPTR+1
   1344  0817		       85 86		      sta	R1+1
   1345  0819							;
   1346  0819							; See if we're at the end.
   1347  0819							;
   1348  0819		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1349  081b		       cd 4f 16 	      cmp	PROGRAMEND
   1350  081e		       d0 07		      bne	InsDelLoop
   1351  0820		       a5 86		      lda	R1+1
   1352  0822		       cd 50 16 	      cmp	PROGRAMEND+1
   1353  0825		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1354  0827							;
   1355  0827							; Move one byte, move to next location.
   1356  0827							;
   1357  0827		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1358  0829		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1359  082b		       b1 85		      lda	(R1),y
   1360  082d		       a0 00		      ldy	#0
   1361  082f		       91 85		      sta	(R1),y
   1362  0831		       e6 85		      inc	R1
   1363  0833		       d0 e4		      bne	InsDelChk
   1364  0835		       e6 86		      inc	R1+1
   1365  0837		       4c 19 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1366  083a							;
   1367  083a							; Deletion is done.
   1368  083a							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1369  083a							;
   1370  083a		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1371  083c		       b9 bb 15 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1372  083f		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1373  0841							;
   1374  0841							; CURPTR points to where the line will be inserted.
   1375  0841							;
   1376  0841		       20 71 0e 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1377  0844							;
   1378  0844		       ad 4f 16 	      lda	PROGRAMEND	;Load the start address for the copy
   1379  0847							;At this point curptr still contains the location we will insert data
   1380  0847		       85 88		      sta	FROM
   1381  0849		       ad 50 16 	      lda	PROGRAMEND+1
   1382  084c		       85 89		      sta	FROM+1
   1383  084e							;
   1384  084e		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1385  0850		       b1 88		      lda	(FROM),y
   1386  0852		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1387  0854		       91 88		      sta	(FROM),y	;Save the new byte
   1388  0856							;
   1389  0856		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1390  0858		       c5 7e		      cmp	CURPTR
   1391  085a		       d0 06		      bne	mvUpMore
   1392  085c		       a5 89		      lda	FROM+1
   1393  085e		       c5 7f		      cmp	CURPTR+1
   1394  0860		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1395  0862							;
   1396  0862							; Not done yet
   1397  0862							;
   1398  0862		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1399  0864		       d0 02		      bne	mvUpMore2
   1400  0866		       c6 89		      dec	FROM+1
   1401  0868		       c6 88	   mvUpMore2  dec	FROM
   1402  086a		       4c 4e 08 	      jmp	mvup1	;Loop until everything is moved
   1403  086d							;
   1404  086d							; All done with copy.
   1405  086d							;
   1406  086d		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1407  086e		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1408  0870		       6d 4f 16 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1409  0873		       8d 4f 16 	      sta	PROGRAMEND
   1410  0876		       ad 50 16 	      lda	PROGRAMEND+1
   1411  0879		       69 00		      adc	#0
   1412  087b		       8d 50 16 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1413  087e							;
   1414  087e							;===================jlit use length before line newline
   1415  087e
   1416  087e		       a0 00		      ldy	#0	;Set offset of copy
   1417  0880		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1418  0882		       91 7e		      sta	(CURPTR),y	;Store the length
   1419  0884		       c8		      iny
   1420  0885		       a5 83		      lda	R0	;Store the line number next
   1421  0887		       91 7e		      sta	(CURPTR),y
   1422  0889		       c8		      iny
   1423  088a		       a5 84		      lda	R0+1
   1424  088c		       91 7e		      sta	(CURPTR),y
   1425  088e		       c8		      iny
   1426  088f							;
   1427  088f		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1428  0891		       bd bb 15    mvUpLoop2  lda	LINBUF,x	;get a byte
   1429  0894		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1430  0896		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1431  0898		       e8		      inx
   1432  0899		       c8		      iny
   1433  089a		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1434  089c							;
   1435  089c		       4c ed 02    mvUpFini   jmp	NextIL
   1436  089f							;
   1437  089f							;=====================================================
   1438  089f							; Pops the top value of the ILPC stack and stores it
   1439  089f							; in ILPC.  Ie, return from an IL subroutine.
   1440  089f							;
   1441  089f		       20 bc 0c    iRTN       jsr	popILPC
   1442  08a2		       4c ed 02 	      jmp	NextIL
   1443  08a5							;
   1444  08a5							;=====================================================
   1445  08a5							; NLINE print a newline
   1446  08a5							;
   1447  08a5		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1448  08a8		       4c ed 02 	      jmp	NextIL
   1449  08ab							;
   1450  08ab							;=====================================================
   1451  08ab							; This saves the current ILPC value on the stack, then
   1452  08ab							; jumps to the address specified by the next two bytes.
   1453  08ab							;
   1454  08ab		       20 a2 0c    iCALL      jsr	pushILPC	;save ILPC
   1455  08ae							;
   1456  08ae							; Jmp to a specific location in the IL code.  The new
   1457  08ae							; address immediately follows the opcode.
   1458  08ae							;
   1459  08ae		       20 88 0c    iJMP       jsr	getILWord
   1460  08b1		       86 75		      stx	ILPC
   1461  08b3		       85 76		      sta	ILPC+1
   1462  08b5		       4c ed 02 	      jmp	NextIL
   1463  08b8							;
   1464  08b8							;=====================================================
   1465  08b8							; Push the next two bytes onto the arithmetic stack.
   1466  08b8							;
   1467  08b8		       20 88 0c    iLIT       jsr	getILWord
   1468  08bb		       86 83		      stx	R0
   1469  08bd		       85 84		      sta	R0+1
   1470  08bf		       20 95 0e 	      jsr	pushR0
   1471  08c2		       4c ed 02 	      jmp	NextIL
   1472  08c5							;
   1473  08c5							;=====================================================
   1474  08c5							; Initialize all variables.  Ie, set to zero.
   1475  08c5							;
   1476  08c5		       a9 00	   iVINIT     lda	#0
   1477  08c7		       a2 00		      ldx	#0
   1478  08c9		       95 41	   Vinit2     sta	variables,x
   1479  08cb		       e8		      inx
   1480  08cc		       e0 34		      cpx	#variablesEnd-variables
   1481  08ce		       d0 f9		      bne	Vinit2
   1482  08d0		       4c ed 02 	      jmp	NextIL
   1483  08d3							;
   1484  08d3							;=====================================================
   1485  08d3							; Set the address of the error handler.  After any
   1486  08d3							; error, set to the ILPC to the specified location.
   1487  08d3							;
   1488  08d3		       20 88 0c    iERRGOTO   jsr	getILWord
   1489  08d6		       8e 43 16 	      stx	errGoto
   1490  08d9		       8d 44 16 	      sta	errGoto+1
   1491  08dc		       4c ed 02 	      jmp	NextIL
   1492  08df							;
   1493  08df							;=====================================================
   1494  08df							; TST is followed by an 8 bit signed offset, then a
   1495  08df							; null terminated string.  Compare the string against
   1496  08df							; the string starting at (CURPTR),CUROFF.  If the
   1497  08df							; strings match, continue executing the next IL
   1498  08df							; opcode.  Else, add the offset to ILPC.
   1499  08df							;
   1500  08df		       20 8c 0c    iTST       jsr	getILByte
   1501  08e2		       85 7c		      sta	offset
   1502  08e4							;
   1503  08e4		       20 83 0e 	      jsr	saveIL	;in case of failure
   1504  08e7		       a4 80		      ldy	CUROFF
   1505  08e9		       84 77		      sty	dpl	;save for later
   1506  08eb							;
   1507  08eb		       20 8c 0c    iTSTloop   jsr	getILByte	;get next char
   1508  08ee		       f0 11		      beq	iTSTm	;match!
   1509  08f0		       a4 77		      ldy	dpl
   1510  08f2		       d1 7e		      cmp	(CURPTR),y
   1511  08f4		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1512  08f6		       09 20		      ora	#$20	; lets allow lowercase as well
   1513  08f8		       d1 7e		      cmp	(CURPTR),y
   1514  08fa		       d0 22		      bne	iTSTfail	;mismatch
   1515  08fc		       c8	   iTSTUpper  iny
   1516  08fd		       84 77		      sty	dpl
   1517  08ff		       d0 ea		      bne	iTSTloop
   1518  0901							;
   1519  0901							; It's a match!  Clean up a bit.
   1520  0901							;
   1521  0901		       a4 77	   iTSTm      ldy	dpl
   1522  0903		       84 80		      sty	CUROFF
   1523  0905		       4c ed 02 	      jmp	NextIL
   1524  0908							; Test for a single quote
   1525  0908		       20 8c 0c    iTSTStr    jsr	getILByte
   1526  090b		       85 7c		      sta	offset
   1527  090d		       20 83 0e 	      jsr	saveIL
   1528  0910		       a4 80		      ldy	CUROFF
   1529  0912		       a9 22		      lda	#'"
   1530  0914		       d1 7e		      cmp	(CURPTR),y
   1531  0916		       d0 06		      bne	iTSTfail
   1532  0918		       c8		      iny
   1533  0919		       84 80		      sty	CUROFF
   1534  091b		       4c fb 02 	      jmp	NextILStr
   1535  091e							;
   1536  091e							; Not a match, reset ILPC and then move to the
   1537  091e							; offset.
   1538  091e							;
   1539  091e		       20 8c 0e    iTSTfail   jsr	restoreIL
   1540  0921		       4c cb 09 	      jmp	tstBranch
   1541  0924							;
   1542  0924							;=================================================JLIT=
   1543  0924							; Test if we have a let statement without the let keyword
   1544  0924		       20 8c 0c    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1545  0927		       85 7c		      sta	offset	; Save the jump offset for fails
   1546  0929		       20 83 0e 	      jsr	saveIL	; save to restore when done
   1547  092c		       a4 80		      ldy	CUROFF	; Get the current offset into the buffer
   1548  092e		       20 ae 0f 	      jsr	SkipSpaces	; move to first element on line
   1549  0931		       84 80		      sty	CUROFF	; Just remember skipped spaces
   1550  0933		       c8		      iny		; skip the Variable name
   1551  0934		       20 ae 0f 	      jsr	SkipSpaces	; skip any SkipSpaces
   1552  0937		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1553  0939		       c9 3d		      cmp	#'=	; check if equals
   1554  093b		       d0 e1		      bne	iTSTfail	; return it failed
   1555  093d		       20 8c 0e 	      jsr	restoreIL	; restore the IL anyway
   1556  0940		       4c ed 02 	      jmp	NextIL	; Then next instruction
   1557  0943
   1558  0943							;================================================jLIT=
   1559  0943							;Test for end of line
   1560  0943							;
   1561  0943		       20 8c 0c    iTSTDONE   jsr	getILByte
   1562  0946		       85 7c		      sta	offset
   1563  0948		       20 83 0e 	      jsr	saveIL
   1564  094b		       a4 80		      ldy	CUROFF
   1565  094d		       84 77		      sty	dpl
   1566  094f		       20 ae 0f 	      jsr	SkipSpaces
   1567  0952		       b1 7e		      lda	(CURPTR),y
   1568  0954		       f0 0b		      beq	iTSTDONEtrue
   1569  0956		       c9 3a		      cmp	#COLON
   1570  0958		       f0 07		      beq	iTSTDONEtrue
   1571  095a		       a4 77		      ldy	dpl
   1572  095c		       84 80		      sty	CUROFF
   1573  095e		       4c 1e 09 	      jmp	iTSTfail
   1574  0961							;
   1575  0961							; Advance to the next line
   1576  0961							;
   1577  0961				   iTSTDONEtrue
   1578  0961		       4c ed 02 	      jmp	NextIL
   1579  0964							;
   1580  0964							;=====================================================
   1581  0964							; TSTV is followed by an 8 bit signed offset.	If the
   1582  0964							; value at (CURPTR),CUROFF appears to be a variable
   1583  0964							; name, move to the next IL statement.  Else, add the
   1584  0964							; offset to ILPC.
   1585  0964							;
   1586  0964		       20 8c 0c    iTSTV      jsr	getILByte	;offset
   1587  0967		       85 7c		      sta	offset
   1588  0969							;
   1589  0969		       a4 80		      ldy	CUROFF
   1590  096b		       20 ae 0f 	      jsr	SkipSpaces
   1591  096e		       b1 7e		      lda	(CURPTR),y
   1592  0970							;
   1593  0970		       09 20		      ora	#$20	;make lower then upper
   1594  0972		       49 20		      eor	#$20	;allow lower case here
   1595  0974		       c9 41		      cmp	#'A
   1596  0976		       90 53		      bcc	tstBranch
   1597  0978		       c9 5b		      cmp	#'Z+1
   1598  097a		       b0 4f		      bcs	tstBranch
   1599  097c							;
   1600  097c							; The condition is true, so convert to an index, push
   1601  097c							; it onto the stack and continue running.
   1602  097c							;
   1603  097c		       38		      sec
   1604  097d		       e9 41		      sbc	#'A	;index is zero based
   1605  097f		       0a		      asl		;multiply by two
   1606  0980		       85 83		      sta	R0
   1607  0982		       a9 00		      lda	#0
   1608  0984		       85 84		      sta	R0+1
   1609  0986		       20 95 0e 	      jsr	pushR0	;put index onto stack
   1610  0989		       e6 80		      inc	CUROFF	;move to next input char
   1611  098b		       4c ed 02 	      jmp	NextIL
   1612  098e							;
   1613  098e							;=====================================================
   1614  098e							; TSTL seems basically the same as TSTN, but leave the
   1615  098e							; value in R0 instead of pushing onto stack.
   1616  098e							; This tests for a valid line number
   1617  098e							;
   1618  098e		       20 8c 0c    iTSTL      jsr	getILByte
   1619  0991		       85 7c		      sta	offset
   1620  0993							;
   1621  0993		       a4 80		      ldy	CUROFF
   1622  0995		       20 ae 0f 	      jsr	SkipSpaces
   1623  0998		       b1 7e		      lda	(CURPTR),y
   1624  099a							;
   1625  099a		       c9 30		      cmp	#'0
   1626  099c		       90 2d		      bcc	tstBranch
   1627  099e		       c9 3a		      cmp	#'9+1
   1628  09a0		       b0 29		      bcs	tstBranch
   1629  09a2							;
   1630  09a2							; It's a digit, so convert to a number.
   1631  09a2							;
   1632  09a2		       20 9d 0d 	      jsr	getDecimal
   1633  09a5		       4c ed 02 	      jmp	NextIL
   1634  09a8							;
   1635  09a8							;=====================================================
   1636  09a8							; TSTN checks for a number.  This is very simplistic;
   1637  09a8							; if the character is a digit, assume it's a number.
   1638  09a8							; Convert to a number and push it onto the stack.
   1639  09a8							;
   1640  09a8		       20 8c 0c    iTSTN      jsr	getILByte
   1641  09ab		       85 7c		      sta	offset
   1642  09ad							;
   1643  09ad		       a4 80		      ldy	CUROFF
   1644  09af		       20 ae 0f 	      jsr	SkipSpaces
   1645  09b2		       b1 7e		      lda	(CURPTR),y
   1646  09b4		       c9 2d		      cmp	#'-	;negative?
   1647  09b6		       f0 08		      beq	iTSTN_1
   1648  09b8		       c9 30		      cmp	#'0
   1649  09ba		       90 0f		      bcc	tstBranch
   1650  09bc		       c9 3a		      cmp	#'9+1
   1651  09be		       b0 0b		      bcs	tstBranch
   1652  09c0							;
   1653  09c0							; It's a digit, so convert to a number.
   1654  09c0							;
   1655  09c0		       20 9d 0d    iTSTN_1    jsr	getDecimal
   1656  09c3		       84 80		      sty	CUROFF
   1657  09c5		       20 95 0e 	      jsr	pushR0	;save onto stack
   1658  09c8		       4c ed 02 	      jmp	NextIL
   1659  09cb
   1660  09cb							;
   1661  09cb							; Common jump point for all TSTx instructions that
   1662  09cb							; fail to meet the requirements.  This takes the
   1663  09cb							; offset and adds/subtracts to/from ILPC.
   1664  09cb							;
   1665  09cb		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1666  09cd		       10 0e		      bpl	tstPositive
   1667  09cf							;
   1668  09cf							; Do negative branch.	Do sign extension.
   1669  09cf							;
   1670  09cf		       18		      clc
   1671  09d0		       65 75		      adc	ILPC
   1672  09d2		       85 75		      sta	ILPC
   1673  09d4		       a5 76		      lda	ILPC+1
   1674  09d6		       69 ff		      adc	#$ff
   1675  09d8		       85 76		      sta	ILPC+1
   1676  09da		       4c ed 02 	      jmp	NextIL	;keep going
   1677  09dd							;
   1678  09dd		       18	   tstPositive clc
   1679  09de		       65 75		      adc	ILPC
   1680  09e0		       85 75		      sta	ILPC
   1681  09e2		       a5 76		      lda	ILPC+1
   1682  09e4		       69 00		      adc	#0
   1683  09e6		       85 76		      sta	ILPC+1
   1684  09e8		       4c ed 02 	      jmp	NextIL
   1685  09eb
   1686  09eb							;
   1687  09eb							;====================================================
   1688  09eb							; Test for IRQ pending, and test if a break key pressed
   1689  09eb							; Yes I know but this handles all sorts of irq/break issues
   1690  09eb							;
   1691  09eb		       20 8c 0c    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1692  09ee		       85 7c		      sta	offset	; Store the not true jump address offset
   1693  09f0		       20 17 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1694  09f3		       d0 03		      bne	irqNo	; z not set of no break found
   1695  09f5		       4c bf 05 	      jmp	iFIN	; Exit out of run mode
   1696  09f8		       ad ea 14    irqNo      lda	IRQPending
   1697  09fb		       f0 ce		      beq	tstBranch
   1698  09fd		       c9 01		      cmp	#1	; only do this if set to first time
   1699  09ff		       d0 ca		      bne	tstBranch
   1700  0a01		       78		      sei		; disable the interupt until ireturn resets it
   1701  0a02		       ee ea 14    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1702  0a05		       20 a8 0e 	      jsr	pushLN	; Push the next line to be executed
   1703  0a08		       b0 11		      bcs	irqErra	; Check if there was an error
   1704  0a0a		       ad eb 14 	      lda	IRQEntry	; Get the line number to branch to
   1705  0a0d		       85 7e		      sta	CURPTR	; put line number into r0
   1706  0a0f		       ad ec 14 	      lda	IRQEntry+1
   1707  0a12		       85 7f		      sta	CURPTR+1
   1708  0a14		       a9 03		      lda	#3
   1709  0a16		       85 80		      sta	CUROFF
   1710  0a18		       4c ed 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1711  0a1b		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1712  0a1d		       a9 00		      lda	#0	; stop the execution
   1713  0a1f		       4c d3 05 	      jmp	iErr2
   1714  0a22							;
   1715  0a22							;================================================
   1716  0a22							; iTaskSwitch	 switch to new task if not interupt and
   1717  0a22							;		 count is excceded for task
   1718  0a22							;
   1719  0a22				   iTaskSwitch
   1720  0a22		       ad ea 14 	      lda	IRQPending	; Skip this if we are processing an irq
   1721  0a25		       d0 58		      bne	iTaskSwitchDone
   1722  0a27		       ad 40 15 	      lda	taskCount
   1723  0a2a		       c9 01		      cmp	#1	; if there is only one task must be main
   1724  0a2c		       d0 07		      bne	tasknext	; if it some other number continue to next
   1725  0a2e		       ac 3d 15 	      ldy	taskPtr	; check if we have not just ended some other task
   1726  0a31		       d0 02		      bne	tasknext	; if so then do a next anyway
   1727  0a33		       f0 4a		      beq	iTaskSwitchDone	; Skip this if main is only task
   1728  0a35				   tasknext
   1729  0a35		       ce 3e 15 	      dec	taskCurrentCycles	; Dec the current cycle count
   1730  0a38		       d0 45		      bne	iTaskSwitchDone	; Skip this if we are not end of cycle
   1731  0a3a		       ac 3d 15 	      ldy	taskPtr
   1732  0a3d		       a5 7e		      lda	CURPTR
   1733  0a3f		       99 ee 14 	      sta	taskTable+1,y
   1734  0a42		       a5 7f		      lda	CURPTR+1
   1735  0a44		       99 ef 14 	      sta	taskTable+2,y
   1736  0a47		       a5 80		      lda	CUROFF
   1737  0a49		       99 f0 14 	      sta	taskTable+3,y
   1738  0a4c				   taskLoop
   1739  0a4c		       c8		      iny
   1740  0a4d		       c8		      iny
   1741  0a4e		       c8		      iny
   1742  0a4f		       c8		      iny
   1743  0a50		       c0 24		      cpy	#(TASKCOUNT-1)<<2
   1744  0a52		       f0 04		      beq	TaskNextChk
   1745  0a54		       90 02		      bcc	TaskNextChk
   1746  0a56		       a0 00	   TaskResetTop ldy	#0
   1747  0a58				   TaskNextChk
   1748  0a58		       b9 ed 14 	      lda	taskTable,y	; there is always at least one entry in table
   1749  0a5b		       f0 ef		      beq	taskLoop	; get next slot if this one empty
   1750  0a5d		       b9 ee 14 	      lda	taskTable+1,y
   1751  0a60		       85 7e		      sta	CURPTR
   1752  0a62		       b9 ef 14 	      lda	taskTable+2,y
   1753  0a65		       85 7f		      sta	CURPTR+1
   1754  0a67		       b9 f0 14 	      lda	taskTable+3,y
   1755  0a6a		       85 80		      sta	CUROFF
   1756  0a6c		       b9 15 15 	      lda	taskGoStacks,y	; Point to correct stack
   1757  0a6f		       85 81		      sta	GOSUBSTACK
   1758  0a71		       b9 16 15 	      lda	taskGoStacks+1,y
   1759  0a74		       85 82		      sta	GOSUBSTACK+1
   1760  0a76		       8c 3d 15 	      sty	taskPtr
   1761  0a79		       ad 3f 15 	      lda	taskResetValue
   1762  0a7c		       8d 3e 15 	      sta	taskCurrentCycles
   1763  0a7f
   1764  0a7f				   iTaskSwitchDone
   1765  0a7f		       4c ed 02 	      jmp	NextIL
   1766  0a82							;
   1767  0a82							;=====================================================
   1768  0a82							; This places the number of free bytes on top of the
   1769  0a82							; stack.
   1770  0a82							;
   1771  0a82		       20 fc 0f    iFREE      jsr	GetSizes
   1772  0a85		       20 95 0e 	      jsr	pushR0
   1773  0a88		       4c ed 02 	      jmp	NextIL
   1774  0a8b							;
   1775  0a8b							;=====================================================
   1776  0a8b							; Generate a random number from 0-FFFF and then MOD
   1777  0a8b							; it with the value on top of stack.  Leaves number on
   1778  0a8b							; stack
   1779  0a8b							;
   1780  0a8b		       20 1c 0f    iRANDOM    jsr	popR1	;mod value
   1781  0a8e							;
   1782  0a8e							; If the value is zero, just return a one.
   1783  0a8e							;
   1784  0a8e		       a5 85		      lda	R1
   1785  0a90		       05 86		      ora	R1+1
   1786  0a92		       f0 4c		      beq	irandom1
   1787  0a94							;
   1788  0a94		       ad 4b 16 	      lda	random+1
   1789  0a97		       8d 48 16 	      sta	rtemp1
   1790  0a9a		       ad 4a 16 	      lda	random
   1791  0a9d		       0a		      asl
   1792  0a9e		       2e 48 16 	      rol	rtemp1
   1793  0aa1		       0a		      asl
   1794  0aa2		       2e 48 16 	      rol	rtemp1
   1795  0aa5		       18		      clc
   1796  0aa6		       6d 4a 16 	      adc	random
   1797  0aa9		       48		      pha
   1798  0aaa		       ad 48 16 	      lda	rtemp1
   1799  0aad		       6d 4b 16 	      adc	random+1
   1800  0ab0		       8d 4b 16 	      sta	random+1
   1801  0ab3		       68		      pla
   1802  0ab4		       69 11		      adc	#$11
   1803  0ab6		       8d 4a 16 	      sta	random
   1804  0ab9		       ad 4b 16 	      lda	random+1
   1805  0abc		       69 36		      adc	#$36
   1806  0abe		       8d 4b 16 	      sta	random+1
   1807  0ac1
   1808  0ac1		       ad 4a 16 	      lda	random
   1809  0ac4		       85 83		      sta	R0
   1810  0ac6		       ad 4b 16 	      lda	random+1
   1811  0ac9		       29 7f		      and	#$7f	;make positive
   1812  0acb		       85 84		      sta	R0+1
   1813  0acd							;
   1814  0acd							; R0 contains the number and R1 contains the max value.
   1815  0acd							;
   1816  0acd		       20 fc 06 	      jsr	iDivNoPop
   1817  0ad0		       20 7f 0f 	      jsr	RestoreSigns
   1818  0ad3		       ad 45 16 	      lda	MQ
   1819  0ad6		       85 83		      sta	R0
   1820  0ad8		       ad 46 16 	      lda	MQ+1
   1821  0adb		       85 84		      sta	R0+1
   1822  0add		       4c d4 06 	      jmp	pushR0nextIl
   1823  0ae0				   irandom1
   1824  0ae0		       a9 00		      lda	#0
   1825  0ae2		       85 84		      sta	R0+1
   1826  0ae4		       a9 01		      lda	#1
   1827  0ae6		       85 83		      sta	R0
   1828  0ae8		       4c d4 06 	      jmp	pushR0nextIl
   1829  0aeb
   1830  0aeb							; The following replaced by call to division/modulo
   1831  0aeb							;iRANDOM_2	lda	R0
   1832  0aeb							;		cmp	R1
   1833  0aeb							;		bne	iRANDOM_1
   1834  0aeb							;		lda	R0+1
   1835  0aeb							;		cmp	R1+1
   1836  0aeb							;		bne	iRANDOM_1	;need to subtract
   1837  0aeb							;
   1838  0aeb							; Subtract R1 from R0
   1839  0aeb							;
   1840  0aeb							;iRANDOM_sub	sec
   1841  0aeb							;		lda	R0
   1842  0aeb							;		sbc	R1
   1843  0aeb							;		sta	R0
   1844  0aeb							;		lda	R0+1
   1845  0aeb							;		sbc	R1+1
   1846  0aeb							;		sta	R0+1
   1847  0aeb							;		jmp	iRANDOM_2
   1848  0aeb							;
   1849  0aeb							; See if R1 > R0.  If so, branch to subtract.
   1850  0aeb							;
   1851  0aeb							;iRANDOM_1	lda	R0
   1852  0aeb							;		cmp	R1
   1853  0aeb							;		lda	R0+1
   1854  0aeb							;		sbc	R1+1
   1855  0aeb							;		bvc	iRANDOM_4
   1856  0aeb							;		eor	#$80
   1857  0aeb							;iRANDOM_4	bpl	iRANDOM_sub
   1858  0aeb							;
   1859  0aeb							; All done.  Almost.  Add one, then push the result.
   1860  0aeb							;
   1861  0aeb							;irandom1	inc	R0
   1862  0aeb							;		bne	iRANDOM_3
   1863  0aeb							;		inc	R0+1
   1864  0aeb							;iRANDOM_3
   1865  0aeb							;		  jsr	pushR0	;return value
   1866  0aeb							;		jmp	NextIL
   1867  0aeb							;
   1868  0aeb							; Poke a value into a memory location
   1869  0aeb		       8c 4e 16    iPOKEMEMORY sty	tempy
   1870  0aee		       20 09 0f 	      jsr	popR0
   1871  0af1		       20 1c 0f 	      jsr	popR1
   1872  0af4		       a0 00		      ldy	#0
   1873  0af6		       a5 83		      lda	R0
   1874  0af8		       91 85		      sta	(R1),y
   1875  0afa		       ac 4e 16 	      ldy	tempy
   1876  0afd		       4c ed 02 	      jmp	NextIL
   1877  0b00							;
   1878  0b00							; Get a value from a memory location
   1879  0b00							;
   1880  0b00		       8c 4e 16    iPEEKMEMORY sty	tempy
   1881  0b03		       20 09 0f 	      jsr	popR0
   1882  0b06		       a0 00		      ldy	#0
   1883  0b08		       b1 83		      lda	(R0),y
   1884  0b0a		       ac 4e 16 	      ldy	tempy
   1885  0b0d		       85 83		      sta	R0
   1886  0b0f		       a9 00		      lda	#0
   1887  0b11		       85 84		      sta	R0+1
   1888  0b13		       4c d4 06 	      jmp	pushR0nextIl
   1889  0b16							;
   1890  0b16							; Call to address return what ever is in a to the stack
   1891  0b16							; func2 will load a value into a before the call
   1892  0b16		       20 1c 0f    iCallFunc  jsr	popR1
   1893  0b19		       a5 85		      lda	R1
   1894  0b1b		       20 27 0b 	      jsr	iCallRtn
   1895  0b1e		       85 83		      sta	R0
   1896  0b20		       a9 00		      lda	#0
   1897  0b22		       85 84		      sta	R0+1
   1898  0b24		       20 d4 06 	      jsr	pushR0nextIl
   1899  0b27				   iCallRtn
   1900  0b27		       20 09 0f 	      jsr	popR0
   1901  0b2a		       6c 83 00 	      jmp	(R0)
   1902  0b2d
   1903  0b2d
   1904  0b2d							;===========================================jlit======
   1905  0b2d							;Get a character from the terminal convert to value
   1906  0b2d							;leave the number on top of the stack
   1907  0b2d							;
   1908  0b2d				   iGETCHAR
   1909  0b2d		       20 a8 0e 	      jsr	pushLN	;Save state befor getline
   1910  0b30		       20 09 02 	      jsr	GETCH
   1911  0b33					      if	CTMON65
   1912  0b33		       48		      pha
   1913  0b34		       20 0c f0 	      jsr	cout	;echo echo echo
   1914  0b37		       68		      pla
   1915  0b38					      endif
   1916  0b38		       85 83		      sta	R0
   1917  0b3a		       a9 00		      lda	#0
   1918  0b3c		       85 84		      sta	R0+1
   1919  0b3e		       20 95 0e 	      jsr	pushR0
   1920  0b41							;
   1921  0b41		       20 cf 0e 	      jsr	popLN
   1922  0b44		       4c ed 02 	      jmp	NextIL
   1923  0b47							;===========================================jlit======
   1924  0b47							;Put a character to the terminal convert to
   1925  0b47							;
   1926  0b47		       20 09 0f    iPUTCHAR   jsr	popR0
   1927  0b4a		       a5 83		      lda	R0
   1928  0b4c		       20 06 02 	      jsr	OUTCH
   1929  0b4f		       4c ed 02 	      jmp	NextIL
   1930  0b52							;=====================================================
   1931  0b52							; Put the number on the stack out as hex, suppress leading 0
   1932  0b52				   iHexOut
   1933  0b52		       20 09 0f 	      jsr	popR0
   1934  0b55		       a5 84		      lda	R0+1
   1935  0b57		       f0 03		      beq	iHexSecondByte
   1936  0b59		       20 0f 02 	      jsr	OUTHEX
   1937  0b5c				   iHexSecondByte
   1938  0b5c		       a5 83		      lda	R0
   1939  0b5e		       20 0f 02 	      jsr	OUTHEX
   1940  0b61		       4c ed 02 	      jmp	NextIL
   1941  0b64							;
   1942  0b64							;=====================================================
   1943  0b64							; Replace TOS with its absolute value.
   1944  0b64							;
   1945  0b64		       20 09 0f    iABS       jsr	popR0
   1946  0b67		       a5 84		      lda	R0+1
   1947  0b69		       10 10		      bpl	iABS_1	;already positive
   1948  0b6b		       49 ff		      eor	#$ff
   1949  0b6d		       85 84		      sta	R0+1
   1950  0b6f		       a5 83		      lda	R0
   1951  0b71		       49 ff		      eor	#$ff
   1952  0b73		       85 83		      sta	R0
   1953  0b75		       e6 83		      inc	R0
   1954  0b77		       d0 02		      bne	iABS_1
   1955  0b79		       e6 84		      inc	R0+1
   1956  0b7b		       4c d4 06    iABS_1     jmp	pushR0nextIl
   1957  0b7e
   1958  0b7e							;================================================================
   1959  0b7e							;Set the IRQ service rtn line number
   1960  0b7e							;
   1961  0b7e		       78	   iSetIrq    sei		; disable the interupts
   1962  0b7f		       a9 00		      lda	#0	; Zero the Status flag
   1963  0b81		       8d e9 14 	      sta	IRQStatus
   1964  0b84		       20 09 0f 	      jsr	popR0	; get the line number
   1965  0b87		       a5 83		      lda	R0
   1966  0b89		       05 84		      ora	R0+1
   1967  0b8b		       f0 1b		      beq	iSetExt	; if it is zero disable all
   1968  0b8d		       20 a8 0e 	      jsr	pushLN	; Save the current line pointer
   1969  0b90		       20 cf 0c 	      jsr	findLine	; Find the IRQ func Line Pointer
   1970  0b93		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   1971  0b95		       a5 7f		      lda	CURPTR+1	; Copy it to the Entry pointer
   1972  0b97		       8d ec 14 	      sta	IRQEntry+1
   1973  0b9a		       a5 7e		      lda	CURPTR
   1974  0b9c		       8d eb 14 	      sta	IRQEntry
   1975  0b9f		       a9 01		      lda	#1	; Indicate there is an irq gosub
   1976  0ba1		       8d e9 14 	      sta	IRQStatus
   1977  0ba4		       20 cf 0e 	      jsr	popLN	; Restore the old line number
   1978  0ba7		       58		      cli		; Enable the interupts
   1979  0ba8		       4c ed 02    iSetExt    jmp	NextIL
   1980  0bab
   1981  0bab		       20 cf 0e    iSetIrqErr jsr	popLN
   1982  0bae		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   1983  0bb0		       a9 00		      lda	#0
   1984  0bb2		       4c d3 05 	      jmp	iErr2
   1985  0bb5							;
   1986  0bb5							;================================================================
   1987  0bb5							; Task Set task number to line number to start
   1988  0bb5							; Task Table structure:
   1989  0bb5							;    byte 0	-   Active inactive 0 or 1
   1990  0bb5							;    byte 1-2	-   Basic code line pointer
   1991  0bb5							;    byte 3	-   Offset on current line
   1992  0bb5		       98	   iTaskSet   tya
   1993  0bb6		       48		      pha
   1994  0bb7		       20 a8 0e 	      jsr	pushLN	; Store the current line number
   1995  0bba		       20 09 0f 	      jsr	popR0	; Get the line number to be saved
   1996  0bbd		       a5 83		      lda	R0
   1997  0bbf		       05 84		      ora	R0+1
   1998  0bc1		       f0 46		      beq	iTaskRetCurrent
   1999  0bc3		       20 cf 0c 	      jsr	findLine	; Get the offset of the line to start task at
   2000  0bc6		       f0 05		      beq	iTaskCont
   2001  0bc8		       68		      pla
   2002  0bc9		       a8		      tay
   2003  0bca		       4c ab 0b 	      jmp	iSetIrqErr	; Bad line number provided
   2004  0bcd				   iTaskCont
   2005  0bcd		       20 71 0c 	      jsr	TaskEmpty	; Find an empty slot
   2006  0bd0		       f0 2b		      beq	iTaskNoEmpty	; There are no more empty slots
   2007  0bd2		       ee 40 15 	      inc	taskCount	; Update the number of Tasks running
   2008  0bd5		       a9 01		      lda	#1
   2009  0bd7		       99 ed 14 	      sta	taskTable,y	; Mark as busy/used
   2010  0bda		       a5 7e		      lda	CURPTR
   2011  0bdc		       99 ee 14 	      sta	taskTable+1,y
   2012  0bdf		       a5 7f		      lda	CURPTR+1
   2013  0be1		       99 ef 14 	      sta	taskTable+2,y
   2014  0be4		       a9 03		      lda	#3	; Offset to first instruction
   2015  0be6		       99 f0 14 	      sta	taskTable+3,y
   2016  0be9		       ee 40 15 	      inc	taskCount
   2017  0bec				   iTaskGetCurrent
   2018  0bec		       20 cf 0e 	      jsr	popLN
   2019  0bef		       98		      tya
   2020  0bf0		       4a		      lsr
   2021  0bf1		       4a		      lsr
   2022  0bf2		       85 83		      sta	R0	;Get the table entry value
   2023  0bf4		       a9 00		      lda	#0
   2024  0bf6		       85 84		      sta	R0+1
   2025  0bf8		       68		      pla
   2026  0bf9		       a8		      tay
   2027  0bfa		       4c d4 06 	      jmp	pushR0nextIl
   2028  0bfd				   iTaskNoEmpty
   2029  0bfd		       20 cf 0e 	      jsr	popLN
   2030  0c00		       68		      pla
   2031  0c01		       a8		      tay
   2032  0c02		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
   2033  0c04		       a9 00		      lda	#0
   2034  0c06		       4c d3 05 	      jmp	iErr2
   2035  0c09				   iTaskRetCurrent		;Get if task number is zero Current task
   2036  0c09		       ac 3d 15 	      ldy	taskPtr
   2037  0c0c		       4c ec 0b 	      jmp	iTaskGetCurrent
   2038  0c0f							;
   2039  0c0f							;================================================================
   2040  0c0f							; Returns task Status
   2041  0c0f				   iTaskStat
   2042  0c0f		       20 1e 0c 	      jsr	iTaskValid
   2043  0c12		       a9 00		      lda	#0
   2044  0c14		       85 84		      sta	R0+1
   2045  0c16		       b9 ed 14 	      lda	taskTable,y
   2046  0c19		       85 83		      sta	R0
   2047  0c1b		       4c d4 06 	      jmp	pushR0nextIl
   2048  0c1e							;
   2049  0c1e							;================================================================
   2050  0c1e							; Validate the task number on top of the stack
   2051  0c1e		       20 09 0f    iTaskValid jsr	popR0
   2052  0c21		       a5 84		      lda	R0+1
   2053  0c23		       d0 0d		      bne	iTaskValidErr
   2054  0c25		       a5 83		      lda	R0
   2055  0c27		       c9 00		      cmp	#0
   2056  0c29		       f0 07		      beq	iTaskValidErr
   2057  0c2b		       18		      clc
   2058  0c2c		       2a		      rol
   2059  0c2d		       2a		      rol
   2060  0c2e		       c9 28		      cmp	#TASKCOUNT<<2
   2061  0c30		       90 09		      bcc	iTaskIsValid
   2062  0c32
   2063  0c32		       68	   iTaskValidErr pla		;remove return address
   2064  0c33		       68		      pla
   2065  0c34		       a2 10		      ldx	#ERR_INVALID_PID
   2066  0c36		       a9 00		      lda	#0
   2067  0c38		       4c d3 05 	      jmp	iErr2
   2068  0c3b
   2069  0c3b		       a8	   iTaskIsValid tay
   2070  0c3c		       60		      rts
   2071  0c3d							;
   2072  0c3d							;================================================================
   2073  0c3d							; Kill a running task, do nothing if already stopped
   2074  0c3d		       20 1e 0c    iTaskKill  jsr	iTaskValid
   2075  0c40		       a9 00		      lda	#0
   2076  0c42		       99 ed 14 	      sta	taskTable,y	; Fall thru to go to next task
   2077  0c45							;
   2078  0c45							;================================================================
   2079  0c45							;Skip to next task
   2080  0c45				   iNTask
   2081  0c45		       a9 01		      lda	#1
   2082  0c47		       8d 3e 15 	      sta	taskCurrentCycles
   2083  0c4a		       4c ed 02 	      jmp	NextIL
   2084  0c4d							;
   2085  0c4d							;================================================================
   2086  0c4d							; Terminate a task
   2087  0c4d		       ac 3d 15    iETask     ldy	taskPtr
   2088  0c50		       c0 00		      cpy	#0
   2089  0c52		       d0 03		      bne	iETaskCont
   2090  0c54		       4c bf 05 	      jmp	iFIN	; if the main task does a ETASK then stop
   2091  0c57				   iETaskCont
   2092  0c57		       a9 00		      lda	#0
   2093  0c59		       99 ed 14 	      sta	taskTable,y	; mark entry as free
   2094  0c5c		       99 ee 14 	      sta	taskTable+1,y	; Clear the entry in the table
   2095  0c5f		       99 ef 14 	      sta	taskTable+2,y
   2096  0c62		       99 f0 14 	      sta	taskTable+3,y
   2097  0c65		       ce 40 15 	      dec	taskCount	; reduce the number of active tasks
   2098  0c68		       8d 3e 15 	      sta	taskCurrentCycles	; Set to zero
   2099  0c6b		       ee 3e 15 	      inc	taskCurrentCycles	; Make it 1 as rtn will dec and check
   2100  0c6e				   iETaskExit
   2101  0c6e		       4c ed 02 	      jmp	NextIL
   2102  0c71
   2103  0c71							;
   2104  0c71							;================================================================
   2105  0c71							;Find an empty slot in the taskTable
   2106  0c71							;Return the index in y
   2107  0c71							;================================================================
   2108  0c71							;
   2109  0c71				   TaskEmpty
   2110  0c71		       a0 04		      ldy	#4	;The first slot is always the main line
   2111  0c73				   TaskLoop
   2112  0c73		       b9 ed 14 	      lda	taskTable,y
   2113  0c76		       f0 0d		      beq	TaskEmptyFnd
   2114  0c78		       c8		      iny
   2115  0c79		       c8		      iny
   2116  0c7a		       c8		      iny
   2117  0c7b		       c8		      iny
   2118  0c7c		       c0 28		      cpy	#TASKCOUNT<<2	; Task
   2119  0c7e		       f0 02		      beq	TaskNoSlot	; No Empty Slots
   2120  0c80		       90 f1		      bcc	TaskLoop	; Y is never zero
   2121  0c82				   TaskNoSlot
   2122  0c82		       a9 00		      lda	#0	; Z set if not found
   2123  0c84		       60		      rts
   2124  0c85				   TaskEmptyFnd
   2125  0c85		       a9 01		      lda	#1
   2126  0c87		       60		      rts
   2127  0c88							;
   2128  0c88							;=================================================================
   2129  0c88							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0c88					      include	"support.asm"
      1  0c88							;
      2  0c88							;=====================================================
      3  0c88							;=====================================================
      4  0c88							;=====================================================
      5  0c88							; This marks the start of support functions used by
      6  0c88							; the IL opcodes.  These are support functions, NOT
      7  0c88							; the IL code.
      8  0c88							;=====================================================
      9  0c88		       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub nesting
     10  0c88							;=====================================================
     11  0c88					      Seg	Code
     12  0c88							;=====================================================
     13  0c88							; This gets the next two bytes pointed to by ILPC and
     14  0c88							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0c88							; is advanced by two, and Y contains 0 on return.
     16  0c88
     17  0c88							;
     18  0c88		       20 8c 0c    getILWord  jsr	getILByte	;LSB
     19  0c8b		       aa		      tax
     20  0c8c							;
     21  0c8c							;=====================================================
     22  0c8c							; This gets the next byte pointed to by ILPC and
     23  0c8c							; returns it in A.  On return, X is unchanged but Y
     24  0c8c							; contains 0.
     25  0c8c							;
     26  0c8c		       a0 00	   getILByte  ldy	#0
     27  0c8e		       b1 75		      lda	(ILPC),y	;get byte
     28  0c90		       08		      php		;save status
     29  0c91		       e6 75		      inc	ILPC	;inc LSB
     30  0c93		       d0 02		      bne	getILb2	;branch if no overflow
     31  0c95		       e6 76		      inc	ILPC+1	;inc MSB
     32  0c97		       28	   getILb2    plp		;restore status
     33  0c98		       60		      rts
     34  0c99							;
     35  0c99							;=====================================================
     36  0c99							; Decrement ILPC by one.
     37  0c99							;
     38  0c99		       a5 75	   decIL      lda	ILPC
     39  0c9b		       d0 02		      bne	decIL2
     40  0c9d		       c6 76		      dec	ILPC+1
     41  0c9f		       c6 75	   decIL2     dec	ILPC
     42  0ca1		       60		      rts
     43  0ca2							;
     44  0ca2							;=====================================================
     45  0ca2							; Push the ILPC onto the return stack.  Actually, this
     46  0ca2							; pushes the address of ILPC+2 since that's the next
     47  0ca2							; address to execute.
     48  0ca2							;
     49  0ca2		       ac ba 15    pushILPC   ldy	retStackPtr
     50  0ca5		       a5 75		      lda	ILPC
     51  0ca7		       18		      clc
     52  0ca8		       69 02		      adc	#2
     53  0caa		       99 6a 15 	      sta	retStack,y
     54  0cad		       08		      php		;save C bit
     55  0cae		       c8		      iny
     56  0caf		       a5 76		      lda	ILPC+1
     57  0cb1		       28		      plp		;restore C
     58  0cb2		       69 00		      adc	#0
     59  0cb4		       99 6a 15 	      sta	retStack,y
     60  0cb7		       c8		      iny
     61  0cb8		       8c ba 15 	      sty	retStackPtr
     62  0cbb		       60		      rts
     63  0cbc							;
     64  0cbc							;=====================================================
     65  0cbc							; Pull the top entry from return stack and put into
     66  0cbc							; ILPC.
     67  0cbc							;
     68  0cbc		       ac ba 15    popILPC    ldy	retStackPtr
     69  0cbf		       88		      dey
     70  0cc0		       b9 6a 15 	      lda	retStack,y
     71  0cc3		       85 76		      sta	ILPC+1
     72  0cc5		       88		      dey
     73  0cc6		       b9 6a 15 	      lda	retStack,y
     74  0cc9		       85 75		      sta	ILPC
     75  0ccb		       8c ba 15 	      sty	retStackPtr
     76  0cce		       60		      rts
     77  0ccf							;
     78  0ccf							;=====================================================
     79  0ccf							; This searches for a specific line number that is in
     80  0ccf							; R0.	There are three possible return conditions:
     81  0ccf							; Line numbers are now the third byte, the first byte is now **************
     82  0ccf							; a pointer to the next line, of course no longer that 53 byte
     83  0ccf							; per line.
     84  0ccf							;
     85  0ccf							; Exact match was found:
     86  0ccf							;    * Z set
     87  0ccf							;    * CURPTR points to two-byte line number for that
     88  0ccf							;	line.
     89  0ccf							;
     90  0ccf							; Next highest line found:
     91  0ccf							;    * Z cleared
     92  0ccf							;    * C set
     93  0ccf							;    * CURPTR points to two-byte line number for that
     94  0ccf							;	line.
     95  0ccf							;
     96  0ccf							; End of program reached:
     97  0ccf							;    * Z cleared
     98  0ccf							;    * C cleared
     99  0ccf							;    * CURPTR points to first free byte at end of
    100  0ccf							;	program.  Ie, it has save value as PROGRAMEND.
    101  0ccf							;
    102  0ccf							; A, X, and Y are all undefined on return.
    103  0ccf							;
    104  0ccf
    105  0ccf				   findLine
    106  0ccf		       a9 57		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    107  0cd1		       85 7e		      sta	CURPTR
    108  0cd3		       a9 16		      lda	#ProgramStart>>8
    109  0cd5		       85 7f		      sta	CURPTR+1
    110  0cd7							;
    111  0cd7							; At end of code?
    112  0cd7							;
    113  0cd7				   iXFER1
    114  0cd7		       a5 7e		      lda	CURPTR	; chk CURPTR = END PROGRAM
    115  0cd9		       cd 4f 16 	      cmp	PROGRAMEND	; at end of program then stop run
    116  0cdc		       d0 0b		      bne	xfer2	; not end
    117  0cde		       a5 7f		      lda	CURPTR+1
    118  0ce0		       cd 50 16 	      cmp	PROGRAMEND+1
    119  0ce3		       d0 04		      bne	xfer2	;Not at end
    120  0ce5							;
    121  0ce5							; Line not found and the end of the program was
    122  0ce5							; reached.  Return Z and C both clear.
    123  0ce5							;
    124  0ce5		       a9 01		      lda	#1	;clear Z
    125  0ce7		       18		      clc		;clear C
    126  0ce8		       60		      rts
    127  0ce9							;
    128  0ce9							; Check for an exact line number match
    129  0ce9							;
    130  0ce9		       a5 83	   xfer2      lda	R0
    131  0ceb		       a0 01		      ldy	#1	; changed to skip extra length byte
    132  0ced		       d1 7e		      cmp	(CURPTR),y
    133  0cef		       d0 08		      bne	xfernotit
    134  0cf1		       c8		      iny
    135  0cf2		       a5 84		      lda	R0+1
    136  0cf4		       d1 7e		      cmp	(CURPTR),y
    137  0cf6		       d0 01		      bne	xfernotit	; not a matching line number
    138  0cf8							;
    139  0cf8							; This is exactly the line we want.
    140  0cf8							;
    141  0cf8		       60		      rts		;it matches exactly
    142  0cf9							;
    143  0cf9							; See if this line is greater than the one we're
    144  0cf9							; searching for.
    145  0cf9							;
    146  0cf9		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    147  0cfb		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    148  0cfd		       c5 84		      cmp	R0+1
    149  0cff		       90 0b		      bcc	xfer3
    150  0d01		       d0 07		      bne	xfer4
    151  0d03		       88		      dey
    152  0d04		       b1 7e		      lda	(CURPTR),y	;compare LSB
    153  0d06		       c5 83		      cmp	R0
    154  0d08		       90 02		      bcc	xfer3
    155  0d0a							;
    156  0d0a							; This line is greater than the one we want, so
    157  0d0a							; return Z clear and C set.
    158  0d0a							;
    159  0d0a		       38	   xfer4      sec		;We found a line number greater
    160  0d0b		       60		      rts		;both conditions set
    161  0d0c							;
    162  0d0c							; Not the line (or droid) we're looking for.  Move to
    163  0d0c							; the next line.
    164  0d0c							;
    165  0d0c		       20 12 0d    xfer3      jsr	FindNextLine
    166  0d0f		       4c d7 0c 	      jmp	iXFER1
    167  0d12							;
    168  0d12							;=====================================================
    169  0d12							; This advances CURPTR to the next line.  If there
    170  0d12							; are no more lines, this leaves CURPTR equal to
    171  0d12							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    172  0d12							; CURPTR is pointing to a valid line on entry.  This
    173  0d12							; pointer points to the two-byte line number.
    174  0d12							; Update this points to the 1 byte line length  ****************
    175  0d12							;
    176  0d12				   FindNextLine
    177  0d12		       a0 03		      ldy	#3	;skip line number and length byte
    178  0d14		       84 80		      sty	CUROFF	;this is the new offset
    179  0d16		       a0 00		      ldy	#0
    180  0d18		       b1 7e		      lda	(CURPTR),y	;Get the length
    181  0d1a		       18		      clc
    182  0d1b		       65 7e		      adc	CURPTR
    183  0d1d		       85 7e		      sta	CURPTR
    184  0d1f		       90 02		      bcc	FindNext4	;exit
    185  0d21		       e6 7f		      inc	CURPTR+1
    186  0d23		       60	   FindNext4  rts
    187  0d24							;
    188  0d24							;=====================================================
    189  0d24							; This compares CURPTR to PROGRAMEND and returns Z set
    190  0d24							; if they are equal, Z clear if not.
    191  0d24							;
    192  0d24		       a5 7e	   AtEnd      lda	CURPTR
    193  0d26		       cd 4f 16 	      cmp	PROGRAMEND
    194  0d29		       d0 05		      bne	atendexit
    195  0d2b		       a5 7f		      lda	CURPTR+1
    196  0d2d		       cd 50 16 	      cmp	PROGRAMEND+1
    197  0d30		       60	   atendexit  rts
    198  0d31							;
    199  0d31							;=====================================================
    200  0d31							; Print the contents of R0 as a signed decimal number.
    201  0d31							; Does leading zero suppression.
    202  0d31							;
    203  0d31				   PrintDecimal
    204  0d31		       a5 84		      lda	R0+1	;MSB has sign
    205  0d33		       10 17		      bpl	pplus	;it's a positive number
    206  0d35							;
    207  0d35							; Negative numbers need more work.  Invert all the bits,
    208  0d35							; then add one.
    209  0d35							;
    210  0d35		       a9 2d		      lda	#'-
    211  0d37		       20 3a 10 	      jsr	VOUTCH	;print the negative sign
    212  0d3a							;
    213  0d3a		       a5 83		      lda	R0	;invert bits
    214  0d3c		       49 ff		      eor	#$ff
    215  0d3e		       85 83		      sta	R0
    216  0d40		       a5 84		      lda	R0+1
    217  0d42		       49 ff		      eor	#$ff
    218  0d44		       85 84		      sta	R0+1
    219  0d46		       e6 83		      inc	R0	;add one
    220  0d48		       d0 02		      bne	pplus
    221  0d4a		       e6 84		      inc	R0+1
    222  0d4c							;
    223  0d4c							; Print the value in R0 as a positive number.
    224  0d4c							;
    225  0d4c		       a2 00	   pplus      ldx	#0	;start of subtraction table
    226  0d4e		       8e 41 16 	      stx	diddigit	;no digits yet
    227  0d51		       a0 00	   pploop     ldy	#0	;result of division
    228  0d53		       a5 83	   pploop2    lda	R0	;LSB
    229  0d55		       38		      sec
    230  0d56		       fd 95 0d 	      sbc	dectable,x
    231  0d59		       85 83		      sta	R0
    232  0d5b		       a5 84		      lda	R0+1
    233  0d5d		       fd 96 0d 	      sbc	dectable+1,x
    234  0d60		       10 2e		      bpl	pplusok	;no underflow
    235  0d62							;
    236  0d62							; Else, underflow.  Add back in the LSB of the
    237  0d62							; table to R0.
    238  0d62							;
    239  0d62		       18		      clc
    240  0d63		       a5 83		      lda	R0
    241  0d65		       7d 95 0d 	      adc	dectable,x
    242  0d68		       85 83		      sta	R0
    243  0d6a							;
    244  0d6a							; Print the value in Y.  Actually, see if Y is zero and
    245  0d6a							; whether any digit has been printed yet.  If Y isn't
    246  0d6a							; zero or we've printed a digit, go ahead and print.
    247  0d6a							;
    248  0d6a		       8e 40 16 	      stx	printtx
    249  0d6d		       98		      tya
    250  0d6e		       09 00		      ora	#0	;set flags
    251  0d70		       d0 05		      bne	pprintit	;non-zero, print
    252  0d72							;
    253  0d72		       ad 41 16 	      lda	diddigit
    254  0d75		       f0 09		      beq	pprintno	;don't print
    255  0d77							;
    256  0d77		       98	   pprintit   tya
    257  0d78		       09 30		      ora	#'0
    258  0d7a		       8d 41 16 	      sta	diddigit
    259  0d7d		       20 3a 10 	      jsr	VOUTCH
    260  0d80		       ae 40 16    pprintno   ldx	printtx
    261  0d83							;
    262  0d83							; Move to the next table entry
    263  0d83							;
    264  0d83		       e8		      inx
    265  0d84		       e8		      inx
    266  0d85		       e0 08		      cpx	#dectableend-dectable
    267  0d87		       d0 c8		      bne	pploop	;not at end
    268  0d89							;
    269  0d89							; At the end.	R0 contains the final value
    270  0d89							; to print.
    271  0d89							;
    272  0d89		       a5 83		      lda	R0
    273  0d8b		       09 30		      ora	#'0
    274  0d8d		       4c 3a 10 	      jmp	VOUTCH
    275  0d90							;
    276  0d90							; Finish doing the subtraction.
    277  0d90							;
    278  0d90		       85 84	   pplusok    sta	R0+1
    279  0d92		       c8		      iny
    280  0d93		       d0 be		      bne	pploop2
    281  0d95							;
    282  0d95							; Table of powers-of-ten
    283  0d95							;
      0  0d95				   dectable   dw	10000
      1  0d95		       10 27		      .word.w	10000
      0  0d97					      dw	1000
      1  0d97		       e8 03		      .word.w	1000
      0  0d99					      dw	100
      1  0d99		       64 00		      .word.w	100
      0  0d9b					      dw	10
      1  0d9b		       0a 00		      .word.w	10
    288  0d9b		       0d 9d	   dectableend equ	*
    289  0d9d							;
    290  0d9d							;=====================================================
    291  0d9d							; Convert an ASCII string to a number.  On input,
    292  0d9d							; (CURPTR),Y points to the first digit.  This gets
    293  0d9d							; digit-by-digit until finding a non-number.  Returns
    294  0d9d							; Y pointing to the non-digit, and R0 contains the
    295  0d9d							; number.  This does NOT check for valid ranges, so
    296  0d9d							; a value like "123456789" will produce something,
    297  0d9d							; but not what you had expected.
    298  0d9d							;
    299  0d9d		       a9 00	   getDecimal lda	#0
    300  0d9f		       85 83		      sta	R0
    301  0da1		       85 84		      sta	R0+1
    302  0da3		       85 77		      sta	dpl	;temporary negative flag
    303  0da5							;
    304  0da5							; See if it's negative...
    305  0da5							;
    306  0da5		       84 13		      sty	$0013
    307  0da7		       b1 7e		      lda	(CURPTR),y
    308  0da9		       c9 2d		      cmp	#'-
    309  0dab		       d0 02		      bne	getDecLoop
    310  0dad		       e6 77		      inc	dpl	;it's negative
    311  0daf							;
    312  0daf		       b1 7e	   getDecLoop lda	(CURPTR),y
    313  0db1		       c9 30		      cmp	#'0
    314  0db3		       90 36		      bcc	getDdone
    315  0db5		       c9 3a		      cmp	#'9+1
    316  0db7		       b0 32		      bcs	getDdone
    317  0db9		       38		      sec
    318  0dba		       e9 30		      sbc	#'0	;convert to binary
    319  0dbc		       48		      pha
    320  0dbd							;
    321  0dbd							; Now multiply R0 by 10.  Remember that
    322  0dbd							; 2*N + 8*N = 10*N.
    323  0dbd							;
    324  0dbd		       06 83		      asl	R0
    325  0dbf		       26 84		      rol	R0+1	;*2
    326  0dc1		       a5 83		      lda	R0
    327  0dc3		       85 85		      sta	R1
    328  0dc5		       a5 84		      lda	R0+1
    329  0dc7		       85 86		      sta	R1+1
    330  0dc9		       06 83		      asl	R0
    331  0dcb		       26 84		      rol	R0+1	;*4
    332  0dcd		       06 83		      asl	R0
    333  0dcf		       26 84		      rol	R0+1	;*8
    334  0dd1		       18		      clc		;now add the partial sums...
    335  0dd2		       a5 83		      lda	R0	;...to get *10
    336  0dd4		       65 85		      adc	R1
    337  0dd6		       85 83		      sta	R0
    338  0dd8		       a5 84		      lda	R0+1
    339  0dda		       65 86		      adc	R1+1
    340  0ddc		       85 84		      sta	R0+1
    341  0dde							;
    342  0dde							; Add in the new digit
    343  0dde							;
    344  0dde		       68		      pla
    345  0ddf		       18		      clc
    346  0de0		       65 83		      adc	R0
    347  0de2		       85 83		      sta	R0
    348  0de4		       90 02		      bcc	getD2
    349  0de6		       e6 84		      inc	R0+1
    350  0de8							;
    351  0de8							; Move to next character
    352  0de8							;
    353  0de8		       c8	   getD2      iny
    354  0de9		       d0 c4		      bne	getDecLoop
    355  0deb							;
    356  0deb							; All done with digits, so now deal with it being
    357  0deb							; negative.  If zero, then don't check for negative
    358  0deb							; flag.  Ie, -0 is stored as 0.
    359  0deb							;
    360  0deb		       a5 83	   getDdone   lda	R0
    361  0ded		       05 84		      ora	R0+1
    362  0def		       f0 16		      beq	getDone2	;zero
    363  0df1		       a5 77		      lda	dpl
    364  0df3		       f0 12		      beq	getDone2	;positive
    365  0df5							;
    366  0df5							; Invert all the bits, then add one.
    367  0df5							;
    368  0df5		       a5 83		      lda	R0
    369  0df7		       49 ff		      eor	#$ff
    370  0df9		       85 83		      sta	R0
    371  0dfb		       a5 84		      lda	R0+1
    372  0dfd		       49 ff		      eor	#$ff
    373  0dff		       85 84		      sta	R0+1
    374  0e01							;
    375  0e01		       e6 83		      inc	R0
    376  0e03		       d0 02		      bne	getDone2
    377  0e05		       e6 84		      inc	R0+1
    378  0e07				   getDone2
    379  0e07		       a5 83		      lda	R0
    380  0e09		       85 10		      sta	$0010
    381  0e0b		       a5 84		      lda	R0+1
    382  0e0d		       85 11		      sta	$0011
    383  0e0f		       a5 77		      lda	dpl
    384  0e11		       85 12		      sta	$012
    385  0e13
    386  0e13		       60		      rts
    387  0e14							;
    388  0e14							;=====================================================
    389  0e14							; Print the string that immediately follows the JSR to
    390  0e14							; this function.  Stops when a null byte is found,
    391  0e14							; then returns to the instruction immediately
    392  0e14							; following the null.
    393  0e14							;
    394  0e14							; Thanks to Ross Archer for this code.
    395  0e14							; http://www.6502.org/source/io/primm.htm
    396  0e14							;
    397  0e14				  -	      if	KIM
    398  0e14				  -puts       sty	putsy
    399  0e14				  -	      pla		;low part of "return" address
    400  0e14				  -			;(data start address)
    401  0e14				  -	      sta	dpl
    402  0e14				  -	      pla
    403  0e14				  -	      sta	dpl+1	;high part of "return" address
    404  0e14				  -			;(data start address)
    405  0e14				  -			;Note: we're pointing one short
    406  0e14				  -psinb      ldy	#1
    407  0e14				  -	      lda	(dpl),y	;Get next string character
    408  0e14				  -	      inc	dpl	;update the pointer
    409  0e14				  -	      bne	psinc	;if not, we're pntng to next char
    410  0e14				  -	      inc	dpl+1	;account for page crossing
    411  0e14				  -psinc      ora	#0	;Set flags according to contents of
    412  0e14				  -			;   Accumulator
    413  0e14				  -	      beq	psix1	;don't print the final NULL
    414  0e14				  -	      jsr	OUTCH	;write it out
    415  0e14				  -	      jmp	psinb	;back around
    416  0e14				  -psix1      inc	dpl
    417  0e14				  -	      bne	psix2
    418  0e14				  -	      inc	dpl+1	;account for page crossing
    419  0e14				  -psix2      ldy	putsy
    420  0e14				  -	      jmp	(dpl)	;return to byte following NULL
    421  0e14					      endif
    422  0e14							;
    423  0e14							;=====================================================
    424  0e14							; Gets a line of input into LINBUF.
    425  0e14							;
    426  0e14							; On entry:
    427  0e14							;    A contains the prompt character, or 0 if none.
    428  0e14							;
    429  0e14							; On exit:
    430  0e14							;    CURPTR points to LINBUF
    431  0e14							;    LINBUF contains the line with 0 at the end.
    432  0e14							;    Y has offset to first non-space character
    433  0e14							;    CURROFF has the same as Y.
    434  0e14							;
    435  0e14		       a2 bb	   GetLine    ldx	#LINBUF&$ff
    436  0e16		       86 7e		      stx	CURPTR
    437  0e18		       a2 15		      ldx	#LINBUF>>8
    438  0e1a		       86 7f		      stx	CURPTR+1
    439  0e1c							;
    440  0e1c							; Prompt
    441  0e1c							;
    442  0e1c		       48		      pha		;save for retries
    443  0e1d		       68	   GetLinePr  pla		;restore
    444  0e1e		       48		      pha		;save again
    445  0e1f		       09 00		      ora	#0	;any prompt?
    446  0e21		       f0 08		      beq	getlinenp
    447  0e23		       20 06 02 	      jsr	OUTCH
    448  0e26		       a9 20		      lda	#$20
    449  0e28		       20 06 02 	      jsr	OUTCH	;space after prompt
    450  0e2b							;
    451  0e2b		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    452  0e2d		       8e 3f 16    getline1   stx	getlinx
    453  0e30		       20 09 02 	      jsr	GETCH
    454  0e33					      if	CTMON65
    455  0e33		       48		      pha
    456  0e34		       20 0c f0 	      jsr	cout	;echo echo echo
    457  0e37		       68		      pla
    458  0e38					      endif
    459  0e38		       c9 0d		      cmp	#CR
    460  0e3a		       f0 0d		      beq	getlind	;end of line
    461  0e3c		       c9 08		      cmp	#BS	;backspace?
    462  0e3e		       f0 21		      beq	getlinebs
    463  0e40		       ae 3f 16 	      ldx	getlinx
    464  0e43		       9d bb 15 	      sta	LINBUF,x
    465  0e46		       e8		      inx
    466  0e47		       d0 e4		      bne	getline1
    467  0e49							;
    468  0e49							; CR was hit
    469  0e49							;
    470  0e49		       a9 00	   getlind    lda	#0
    471  0e4b		       ae 3f 16 	      ldx	getlinx
    472  0e4e		       9d bb 15 	      sta	LINBUF,x
    473  0e51		       85 80		      sta	CUROFF
    474  0e53							;
    475  0e53							; Output a CR/LF
    476  0e53							;
    477  0e53		       20 0c 02 	      jsr	CRLF
    478  0e56							;
    479  0e56							; If a blank line, prompt again.
    480  0e56							;
    481  0e56		       a0 00		      ldy	#0
    482  0e58		       20 ae 0f 	      jsr	SkipSpaces
    483  0e5b		       b1 7e		      lda	(CURPTR),y
    484  0e5d		       f0 be		      beq	GetLinePr	;empty line
    485  0e5f		       68		      pla		;get rid of prompt char
    486  0e60		       60		      rts
    487  0e61							;
    488  0e61							; Backspace was hit
    489  0e61							;
    490  0e61		       ae 3f 16    getlinebs  ldx	getlinx
    491  0e64		       f0 c7		      beq	getline1	;at start of line
    492  0e66		       ca		      dex
    493  0e67		       20 12 f0 	      jsr	puts
      0  0e6a					      db	27,"[K",0
      1  0e6a		       1b 5b 4b 00	      .byte.b	27,"[K",0
    495  0e6e		       4c 2d 0e 	      jmp	getline1
    496  0e71							;
    497  0e71							;=====================================================
    498  0e71							; Count the length of the line currently in LINBUF
    499  0e71							; starting at offset Y.  Returns the length in X.  The
    500  0e71							; starting offset in Y should point past the ASCII
    501  0e71							; line number.  Also counts the trailing NULL and two
    502  0e71							; extra bytes for where the line number will be.
    503  0e71							; Update must now include leading length byte not the null at end ****************
    504  0e71							;
    505  0e71				   getLineLength
    506  0e71		       a2 00		      ldx	#0	;size
    507  0e73		       b9 bb 15    getLineL2  lda	LINBUF,y
    508  0e76		       f0 04		      beq	getLineL3
    509  0e78		       c8		      iny
    510  0e79		       e8		      inx
    511  0e7a		       d0 f7		      bne	getLineL2
    512  0e7c		       e8	   getLineL3  inx		;count null at end
    513  0e7d		       e8		      inx		;line number LSB
    514  0e7e		       e8		      inx		;MSB
    515  0e7f		       e8		      inx		;change: count new leading line length
    516  0e80		       86 7d		      stx	lineLength
    517  0e82		       60		      rts
    518  0e83							;
    519  0e83							;=====================================================
    520  0e83							; Count the length of the line pointed to by CURPTR.
    521  0e83							; This also counts the line number and the terminating
    522  0e83							; null.  Ie, this string returns 8:
    523  0e83							;
    524  0e83							; <lineLow><lineHi>Hello<null>
    525  0e83							;
    526  0e83							; Another way of looking at it: add the return value
    527  0e83							; to the CURPTR and it'll point to the next line's
    528  0e83							; line number.  Returns the value in Y.
    529  0e83							; Update to ject get the leading byte length ********************
    530  0e83							;
    531  0e83							;getCURPTRLength
    532  0e83							;		ldy	CURPTR
    533  0e83							;		ldy	#3	;change: skip line number and leading length byte
    534  0e83							;getCLineL2	lda	(CURPTR),y
    535  0e83							;		beq	getCLineL3
    536  0e83							;		iny
    537  0e83							;		bne	getCLineL2
    538  0e83							;getCLineL3	iny		;count null at end
    539  0e83							;		rts
    540  0e83							;
    541  0e83							;=====================================================
    542  0e83							; This saves ILPC.  This saves to a single save area,
    543  0e83							; so it can't be called more than once.
    544  0e83							;
    545  0e83		       a5 75	   saveIL     lda	ILPC
    546  0e85		       85 79		      sta	tempIL
    547  0e87		       a5 76		      lda	ILPC+1
    548  0e89		       85 7a		      sta	tempIL+1
    549  0e8b		       60		      rts
    550  0e8c							;
    551  0e8c							;=====================================================
    552  0e8c							; This restores ILPC.
    553  0e8c							;
    554  0e8c		       a5 79	   restoreIL  lda	tempIL
    555  0e8e		       85 75		      sta	ILPC
    556  0e90		       a5 7a		      lda	tempIL+1
    557  0e92		       85 76		      sta	ILPC+1
    558  0e94		       60		      rts
    559  0e95							;
    560  0e95							;=====================================================
    561  0e95							; This pushes R0 onto the stack.
    562  0e95							;
    563  0e95		       ae 69 15    pushR0     ldx	mathStackPtr
    564  0e98		       a5 83		      lda	R0
    565  0e9a		       9d 41 15 	      sta	mathStack,x
    566  0e9d		       e8		      inx
    567  0e9e		       a5 84		      lda	R0+1
    568  0ea0		       9d 41 15 	      sta	mathStack,x
    569  0ea3		       e8		      inx
    570  0ea4		       8e 69 15 	      stx	mathStackPtr
    571  0ea7		       60		      rts
    572  0ea8
    573  0ea8							;=====================================================
    574  0ea8							; This pushes curptr basic current line onto the call stack.
    575  0ea8
    576  0ea8				   pushLN
    577  0ea8		       8c 48 16 	      sty	rtemp1
    578  0eab		       ae 3d 15 	      ldx	taskPtr	; support tasks
    579  0eae		       bc 17 15 	      ldy	taskGoStacks+2,x
    580  0eb1							;		  ldy	  GoSubStackPtr
    581  0eb1		       c0 30		      cpy	#GOSUBSTACKSIZE*3
    582  0eb3		       f0 18		      beq	pusherr
    583  0eb5		       a2 00		      ldx	#0
    584  0eb7				   pushLoop
    585  0eb7		       b5 7e		      lda	CURPTR,x
    586  0eb9		       91 81		      sta	(GOSUBSTACK),y
    587  0ebb		       c8		      iny
    588  0ebc		       e8		      inx
    589  0ebd		       e0 03		      cpx	#3
    590  0ebf		       d0 f6		      bne	pushLoop
    591  0ec1		       ae 3d 15 	      ldx	taskPtr	; Support tasks
    592  0ec4		       98		      tya
    593  0ec5		       9d 17 15 	      sta	taskGoStacks+2,x
    594  0ec8							;		  sty	  GoSubStackPtr
    595  0ec8		       ac 48 16 	      ldy	rtemp1
    596  0ecb		       18		      clc
    597  0ecc		       60		      rts
    598  0ecd				   pusherr
    599  0ecd		       38		      sec
    600  0ece		       60		      rts
    601  0ecf							;=====================================================
    602  0ecf							; This pops Top Of gosub call Stack and
    603  0ecf							; laces it in CURPTR.
    604  0ecf							;
    605  0ecf		       8c 48 16    popLN      sty	rtemp1
    606  0ed2		       ae 3d 15 	      ldx	taskPtr
    607  0ed5		       bc 17 15 	      ldy	taskGoStacks+2,x
    608  0ed8							;		  ldy	  GoSubStackPtr
    609  0ed8		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    610  0eda		       c0 03		      cpy	#3	; if less than 3 on stack then error
    611  0edc		       90 16		      bcc	poperr	; Process an error
    612  0ede				   popLoop
    613  0ede		       88		      dey
    614  0edf		       ca		      dex
    615  0ee0		       b1 81		      lda	(GOSUBSTACK),y
    616  0ee2		       95 7e		      sta	CURPTR,x
    617  0ee4		       e0 00		      cpx	#$00
    618  0ee6		       d0 f6		      bne	popLoop
    619  0ee8		       ae 3d 15 	      ldx	taskPtr
    620  0eeb		       98		      tya
    621  0eec		       9d 17 15 	      sta	taskGoStacks+2,x
    622  0eef							;		  sty	  GoSubStackPtr
    623  0eef		       ac 48 16 	      ldy	rtemp1
    624  0ef2		       18		      clc
    625  0ef3		       60		      rts
    626  0ef4		       38	   poperr     sec
    627  0ef5		       60		      rts
    628  0ef6							;
    629  0ef6							;=====================================================
    630  0ef6							; This pushes R1 onto the stack
    631  0ef6							;
    632  0ef6		       ae 69 15    pushR1     ldx	mathStackPtr
    633  0ef9		       a5 85		      lda	R1
    634  0efb		       9d 41 15 	      sta	mathStack,x
    635  0efe		       e8		      inx
    636  0eff		       a5 86		      lda	R1+1
    637  0f01		       9d 41 15 	      sta	mathStack,x
    638  0f04		       e8		      inx
    639  0f05		       8e 69 15 	      stx	mathStackPtr
    640  0f08		       60		      rts
    641  0f09							;
    642  0f09							;=====================================================
    643  0f09							; This pops Top Of Stack and places it in R0.
    644  0f09							;
    645  0f09		       ae 69 15    popR0      ldx	mathStackPtr
    646  0f0c		       ca		      dex
    647  0f0d		       bd 41 15 	      lda	mathStack,x
    648  0f10		       85 84		      sta	R0+1
    649  0f12		       ca		      dex
    650  0f13		       bd 41 15 	      lda	mathStack,x
    651  0f16		       85 83		      sta	R0
    652  0f18		       8e 69 15 	      stx	mathStackPtr
    653  0f1b		       60		      rts
    654  0f1c
    655  0f1c							;
    656  0f1c							;=====================================================
    657  0f1c							; This pops TOS and places it in R1.
    658  0f1c							;
    659  0f1c		       ae 69 15    popR1      ldx	mathStackPtr
    660  0f1f		       ca		      dex
    661  0f20		       bd 41 15 	      lda	mathStack,x
    662  0f23		       85 86		      sta	R1+1
    663  0f25		       ca		      dex
    664  0f26		       bd 41 15 	      lda	mathStack,x
    665  0f29		       85 85		      sta	R1
    666  0f2b		       8e 69 15 	      stx	mathStackPtr
    667  0f2e		       60		      rts
    668  0f2f							;
    669  0f2f							;=====================================================
    670  0f2f							; This pops TOS and places it in MQ.
    671  0f2f							;
    672  0f2f		       ae 69 15    popMQ      ldx	mathStackPtr
    673  0f32		       ca		      dex
    674  0f33		       bd 41 15 	      lda	mathStack,x
    675  0f36		       8d 46 16 	      sta	MQ+1
    676  0f39		       ca		      dex
    677  0f3a		       bd 41 15 	      lda	mathStack,x
    678  0f3d		       8d 45 16 	      sta	MQ
    679  0f40		       8e 69 15 	      stx	mathStackPtr
    680  0f43		       60		      rts
    681  0f44							;
    682  0f44							;=====================================================
    683  0f44							; This assists with multiplication and division by
    684  0f44							; looking at R0 and R1 and saving a flag as to what
    685  0f44							; sign the result will be.  Math is always done on
    686  0f44							; positive numbers, so this converts negative numbers
    687  0f44							; into positives.  On exit, R0 and R1 are both
    688  0f44							; positive.  If the signs were different then 'signs'
    689  0f44							; will be non-zero.
    690  0f44							;
    691  0f44		       a9 00	   SaveSigns  lda	#0
    692  0f46		       8d 47 16 	      sta	sign	;assume positive
    693  0f49		       a5 84		      lda	R0+1	;MSB
    694  0f4b		       10 13		      bpl	SaveSigns1
    695  0f4d		       ee 47 16 	      inc	sign	;it's negative
    696  0f50		       49 ff		      eor	#$ff	;flip bits
    697  0f52		       85 84		      sta	R0+1
    698  0f54		       a5 83		      lda	R0
    699  0f56		       49 ff		      eor	#$ff
    700  0f58		       85 83		      sta	R0
    701  0f5a		       e6 83		      inc	R0
    702  0f5c		       d0 02		      bne	SaveSigns1
    703  0f5e		       e6 84		      inc	R0+1
    704  0f60		       a5 86	   SaveSigns1 lda	R1+1
    705  0f62		       10 1a		      bpl	SaveSigns2
    706  0f64		       48		      pha
    707  0f65		       ad 47 16 	      lda	sign
    708  0f68		       49 01		      eor	#1
    709  0f6a		       8d 47 16 	      sta	sign
    710  0f6d		       68		      pla
    711  0f6e		       49 ff		      eor	#$ff	;flip bits
    712  0f70		       85 86		      sta	R1+1
    713  0f72		       a5 85		      lda	R1
    714  0f74		       49 ff		      eor	#$ff
    715  0f76		       85 85		      sta	R1
    716  0f78		       e6 85		      inc	R1
    717  0f7a		       d0 02		      bne	SaveSigns2
    718  0f7c		       e6 86		      inc	R1+1
    719  0f7e		       60	   SaveSigns2 rts
    720  0f7f							;
    721  0f7f							;=====================================================
    722  0f7f							; This looks at the value of 'signs' and will convert
    723  0f7f							; both R0 and R1 to negative if set.
    724  0f7f							;
    725  0f7f				   RestoreSigns
    726  0f7f		       ad 47 16 	      lda	sign
    727  0f82		       f0 28		      beq	restoresigns2
    728  0f84							;
    729  0f84		       a5 83		      lda	R0
    730  0f86		       d0 02		      bne	restoresigns3
    731  0f88		       c6 84		      dec	R0+1
    732  0f8a				   restoresigns3
    733  0f8a		       c6 83		      dec	R0
    734  0f8c		       a5 83		      lda	R0
    735  0f8e		       49 ff		      eor	#$ff
    736  0f90		       85 83		      sta	R0
    737  0f92		       a5 84		      lda	R0+1
    738  0f94		       49 ff		      eor	#$ff
    739  0f96		       85 84		      sta	R0+1
    740  0f98							;
    741  0f98		       a5 85		      lda	R1
    742  0f9a		       d0 02		      bne	restoresigns4
    743  0f9c		       c6 86		      dec	R1+1
    744  0f9e				   restoresigns4
    745  0f9e		       c6 85		      dec	R1
    746  0fa0		       a5 85		      lda	R1
    747  0fa2		       49 ff		      eor	#$ff
    748  0fa4		       85 85		      sta	R1
    749  0fa6		       a5 86		      lda	R1+1
    750  0fa8		       49 ff		      eor	#$ff
    751  0faa		       85 86		      sta	R1+1
    752  0fac							;
    753  0fac				   restoresigns2
    754  0fac		       60		      rts
    755  0fad							;
    756  0fad							;=====================================================
    757  0fad							; Skip over spaces.  Returns Y with the offset to
    758  0fad							; either the last character in the line, or the first
    759  0fad							; non-space character.
    760  0fad							;
    761  0fad		       c8	   skipsp2    iny
    762  0fae		       b1 7e	   SkipSpaces lda	(CURPTR),y
    763  0fb0		       f0 04		      beq	Skip3	;end of line
    764  0fb2		       c9 20		      cmp	#SPACE
    765  0fb4		       f0 f7		      beq	skipsp2
    766  0fb6		       60	   Skip3      rts
    767  0fb7							;
    768  0fb7							;=====================================================
    769  0fb7							; This is some debug logic which displays the current
    770  0fb7							; value of the ILPC and the line buffer.
    771  0fb7							;
    772  0fb7		       20 12 f0    dbgLine    jsr	puts
      0  0fba					      db	"ILPC: ",0
      1  0fba		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    774  0fc1		       a5 76		      lda	ILPC+1
    775  0fc3		       20 0f 02 	      jsr	OUTHEX
    776  0fc6		       a5 75		      lda	ILPC
    777  0fc8		       20 0f 02 	      jsr	OUTHEX
    778  0fcb		       a9 20		      lda	#SPACE
    779  0fcd		       20 06 02 	      jsr	OUTCH
    780  0fd0		       a0 00		      ldy	#0
    781  0fd2		       b1 75		      lda	(ILPC),y
    782  0fd4		       20 0f 02 	      jsr	OUTHEX
    783  0fd7							;
    784  0fd7							; Display the CURPTR value and offset
    785  0fd7							;
    786  0fd7		       20 12 f0 	      jsr	puts
      0  0fda					      db	", CURPTR: ",0
      1  0fda		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    788  0fe5		       a5 7f		      lda	CURPTR+1
    789  0fe7		       20 0f 02 	      jsr	OUTHEX
    790  0fea		       a5 7e		      lda	CURPTR
    791  0fec		       20 0f 02 	      jsr	OUTHEX
    792  0fef		       a9 2b		      lda	#'+
    793  0ff1		       20 06 02 	      jsr	OUTCH
    794  0ff4		       a5 80		      lda	CUROFF
    795  0ff6		       20 0f 02 	      jsr	OUTHEX
    796  0ff9							;
    797  0ff9		       4c 0c 02 	      jmp	CRLF
    798  0ffc							;
    799  0ffc							;=====================================================
    800  0ffc							; This function might go away eventually, but was
    801  0ffc							; added to provide data for other pieces of code.
    802  0ffc							; It has some ties to the operating environment that
    803  0ffc							; will need to be customized for the target system.
    804  0ffc							;
    805  0ffc				   GetSizes
    806  0ffc							;
    807  0ffc							; Here is machine specific code to get the highest
    808  0ffc							; memory location that can be used by BASIC.
    809  0ffc							;
    810  0ffc					      if	ProgramStart < $2000
    811  0ffc		       a9 ff		      lda	#$ff
    812  0ffe		       8d 51 16 	      sta	HighMem	;$13ff for KIM-1
    813  1001		       a9 de		      lda	#$DE	;#$13
    814  1003		       8d 52 16 	      sta	HighMem+1
    815  1006				  -	      else
    816  1006				  -	      lda	#$ff
    817  1006				  -	      sta	HighMem	;$CFFF otherwise
    818  1006				  -	      lda	#$cf
    819  1006				  -	      sta	HighMem+1
    820  1006					      endif
    821  1006							;
    822  1006							; This computes the available memory remaining.
    823  1006							;
    824  1006		       38		      sec
    825  1007		       ad 51 16 	      lda	HighMem
    826  100a		       ed 4f 16 	      sbc	PROGRAMEND
    827  100d		       8d 55 16 	      sta	FreeMem
    828  1010		       85 83		      sta	R0
    829  1012		       ad 52 16 	      lda	HighMem+1
    830  1015		       ed 50 16 	      sbc	PROGRAMEND+1
    831  1018		       8d 56 16 	      sta	FreeMem+1
    832  101b		       85 84		      sta	R0+1
    833  101d							;
    834  101d							; This computes the size of the current user program.
    835  101d							;
    836  101d		       38		      sec
    837  101e		       ad 4f 16 	      lda	PROGRAMEND
    838  1021		       e9 57		      sbc	#ProgramStart&$ff
    839  1023		       8d 53 16 	      sta	UsedMem
    840  1026		       ad 50 16 	      lda	PROGRAMEND+1
    841  1029		       e9 16		      sbc	#ProgramStart>>8
    842  102b		       8d 54 16 	      sta	UsedMem+1
    843  102e							;
    844  102e		       60		      rts
    845  102f							;
    846  102f							;=====================================================
    847  102f							; Set output vector to the console output function
    848  102f							;
    849  102f				   SetOutConsole
    850  102f		       a9 06		      lda	#OUTCH&$ff
    851  1031		       8d 4c 16 	      sta	BOutVec
    852  1034		       a9 02		      lda	#OUTCH/256
    853  1036		       8d 4d 16 	      sta	BOutVec+1
    854  1039		       60		      rts
    855  103a							;
    856  103a							;=====================================================
    857  103a							; Jump to the output function in BOutVec
    858  103a							;
    859  103a		       6c 4c 16    VOUTCH     jmp	(BOutVec)
    860  103d
    861  103d							;====================================================
    862  103d		       16 48	   PrtTerm    equ	rtemp1
    863  103d
    864  103d							; Print Y has the offset to use
    865  103d		       a5 7e	   PrtQuoted  lda	CURPTR
    866  103f		       85 88		      sta	PrtFrom
    867  1041		       a5 7f		      lda	CURPTR+1
    868  1043		       85 89		      sta	PrtFrom+1
    869  1045		       a9 22		      lda	#'"
    870  1047		       8d 48 16 	      sta	PrtTerm
    871  104a		       4c 56 10 	      jmp	PrtLoop
    872  104d
    873  104d							; Print a string pointed to by x= h, y=l terminated by a
    874  104d							; Return y as the length
    875  104d
    876  104d		       86 89	   PrtStr     stx	PrtFrom+1
    877  104f		       84 88		      sty	PrtFrom
    878  1051		       8d 48 16 	      sta	PrtTerm
    879  1054		       a0 00		      ldy	#0
    880  1056
    881  1056		       b1 88	   PrtLoop    lda	(PrtFrom),y
    882  1058		       cd 48 16 	      cmp	PrtTerm
    883  105b		       f0 0b		      beq	PrtEnd
    884  105d		       c9 00		      cmp	#0	; always end if 0 is found
    885  105f		       f0 07		      beq	PrtEnd
    886  1061		       20 06 02 	      jsr	OUTCH
    887  1064		       c8		      iny
    888  1065		       4c 56 10 	      jmp	PrtLoop
    889  1068		       c8	   PrtEnd     iny		;return byte after the copy
    890  1069		       60		      rts
    891  106a
    892  106a							;====================================================
    893  106a							;Clear the terminal assume it is ansii or vt100
    894  106a							;
    895  106a				   iCLEARSCREEN
    896  106a		       20 12 f0 	      jsr	puts
      0  106d					      db	$1b,'[,'3,'J,0
      1  106d		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    898  1072		       4c ed 02 	      jmp	NextIL
------- FILE mytb.asm
   2131  1075					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  1075					      include	"storage.asm"
      1  1075							;
      2  1075							;=====================================================
      3  1075							;=====================================================
      4  1075							;=====================================================
      5  1075							; This file contains the functions for saving and
      6  1075							; restoring programs from some sort of mass storage
      7  1075							; device.  This particular version is for using the
      8  1075							; Corsham Tech SD Card System.
      9  1075							;=====================================================
     10  1075							;=====================================================
     11  1075							;=====================================================
     12  1075
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  1075					      SEG	Code
     19  1075
     20  1075							;
     21  1075							;=====================================================
     22  1075							; Open a file for reading as a program.  The next
     23  1075							; thing on the line should be the filename.
     24  1075							;
     25  1075				   iOPENREAD
     26  1075					      if	XKIM || CTMON65
     27  1075		       a4 80		      ldy	CUROFF
     28  1077		       b1 7e		      lda	(CURPTR),y
     29  1079		       d0 07		      bne	iOPENfn	;might be filename
     30  107b							;
     31  107b							; No filename supplied.
     32  107b							;
     33  107b		       a9 00	   iOPENnofn  lda	#0
     34  107d		       a2 09		      ldx	#ERR_NO_FILENAME
     35  107f		       4c d3 05 	      jmp	iErr2
     36  1082							;
     37  1082							; Add the offset into the buffer start
     38  1082							;
     39  1082		       18	   iOPENfn    clc
     40  1083		       98		      tya
     41  1084		       65 7e		      adc	CURPTR
     42  1086		       a8		      tay		;LSB
     43  1087		       a5 7f		      lda	CURPTR+1
     44  1089		       69 00		      adc	#0
     45  108b		       aa		      tax
     46  108c		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  108f		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1091							;
     49  1091							; Open failed
     50  1091							;
     51  1091		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1093		       a9 00	   Rdfail2    lda	#0
     53  1095		       4c d3 05 	      jmp	iErr2
     54  1098							;
     55  1098							; Clear counts and offsets so the next read will
     56  1098							; cause the file to be read.
     57  1098							;
     58  1098		       a9 00	   Ropenok    lda	#0
     59  109a		       8d 8f df 	      sta	diskBufOffset
     60  109d		       8d 8e df 	      sta	diskBufLength
     61  10a0		       4c ed 02 	      jmp	NextIL
     62  10a3					      endif
     63  10a3
     64  10a3							;
     65  10a3							;==============================jlit 08/02/2022========
     66  10a3							;Remove a file from the disk
     67  10a3				   iRMFILE
     68  10a3					      if	XKIM || CTMON65
     69  10a3		       a4 80		      ldy	CUROFF
     70  10a5		       b1 7e		      lda	(CURPTR),y
     71  10a7		       f0 19		      beq	iRMnofn
     72  10a9							;
     73  10a9		       18		      clc
     74  10aa		       98		      tya
     75  10ab		       65 7e		      adc	CURPTR
     76  10ad		       a8		      tay		;LSB
     77  10ae		       a5 7f		      lda	CURPTR+1
     78  10b0		       69 00		      adc	#0
     79  10b2		       aa		      tax
     80  10b3		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  10b6		       90 07		      bcc	wrmOk	;branch if removed ok
     82  10b8		       a9 00		      lda	#0
     83  10ba		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  10bc		       4c d3 05 	      jmp	iErr2
     85  10bf		       4c ed 02    wrmOk      jmp	NextIL
     86  10c2
     87  10c2							; No filename supplied.
     88  10c2							;
     89  10c2		       a9 00	   iRMnofn    lda	#0
     90  10c4		       a2 09		      ldx	#ERR_NO_FILENAME
     91  10c6		       4c d3 05 	      jmp	iErr2
     92  10c9					      endif
     93  10c9							;
     94  10c9							;=====================================================
     95  10c9				   iOPENWRITE
     96  10c9					      if	XKIM || CTMON65
     97  10c9		       a4 80		      ldy	CUROFF
     98  10cb		       b1 7e		      lda	(CURPTR),y
     99  10cd		       f0 f3		      beq	iRMnofn
    100  10cf							;
    101  10cf		       18		      clc
    102  10d0		       98		      tya
    103  10d1		       65 7e		      adc	CURPTR
    104  10d3		       a8		      tay		;LSB
    105  10d4		       a5 7f		      lda	CURPTR+1
    106  10d6		       69 00		      adc	#0
    107  10d8		       aa		      tax
    108  10d9		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  10dc		       90 07		      bcc	Wopenok	;branch if opened ok
    110  10de							;
    111  10de							; Open failed
    112  10de							;
    113  10de		       a9 00	   Wdfail     lda	#0
    114  10e0		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  10e2		       4c d3 05 	      jmp	iErr2
    116  10e5							;
    117  10e5		       4c ed 02    Wopenok    jmp	NextIL
    118  10e8					      endif
    119  10e8							;
    120  10e8							;=====================================================
    121  10e8							; Gets a line of input from the disk file and puts it
    122  10e8							; into LINBUF.
    123  10e8							;
    124  10e8							; On exit:
    125  10e8							;    CURPTR points to LINBUF
    126  10e8							;    LINBUF contains the line with 0 at the end.
    127  10e8							;    Y has offset to first non-space character
    128  10e8							;    CURROFF has the same as Y.
    129  10e8							;
    130  10e8				   iDGETLINE
    131  10e8					      if	XKIM || CTMON65
    132  10e8		       a2 bb		      ldx	#LINBUF&$ff
    133  10ea		       86 7e		      stx	CURPTR
    134  10ec		       a2 15		      ldx	#LINBUF>>8
    135  10ee		       86 7f		      stx	CURPTR+1
    136  10f0							;
    137  10f0		       a2 00		      ldx	#0	;offset
    138  10f2		       8e 3f 16    iDgetLoop  stx	getlinx
    139  10f5		       20 53 11 	      jsr	getNextFileByte
    140  10f8		       b0 16		      bcs	iGetEOF
    141  10fa		       c9 0d		      cmp	#CR
    142  10fc		       f0 0d		      beq	iGetEOL
    143  10fe		       c9 0a		      cmp	#LF
    144  1100		       f0 09		      beq	iGetEOL
    145  1102		       ae 3f 16 	      ldx	getlinx
    146  1105		       9d bb 15 	      sta	LINBUF,x
    147  1108		       e8		      inx
    148  1109		       d0 e7		      bne	iDgetLoop
    149  110b							;
    150  110b							; Handle end of line.	If the line has nothing, loop
    151  110b							; back and get another line.
    152  110b							;
    153  110b		       ae 3f 16    iGetEOL    ldx	getlinx	;blank line?
    154  110e		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  1110							;
    156  1110							; This can fall through when there is a line, or
    157  1110							; called directly when EOF is encountered.
    158  1110							;
    159  1110		       ae 3f 16    iGetEOF    ldx	getlinx
    160  1113		       a9 00		      lda	#0
    161  1115		       9d bb 15 	      sta	LINBUF,x
    162  1118		       85 80		      sta	CUROFF
    163  111a		       a0 00		      ldy	#0
    164  111c		       20 ae 0f 	      jsr	SkipSpaces
    165  111f		       4c ed 02 	      jmp	NextIL
    166  1122					      endif
    167  1122
    168  1122							;
    169  1122							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  1122							; DISK
    171  1122							;
    172  1122				   iDDIR
    173  1122					      if	XKIM || CTMON65
    174  1122		       20 30 f0 	      jsr	DiskDir
    175  1125							;
    176  1125							; Get/Display each entry
    177  1125							;
    178  1125		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  1127		       a0 90		      ldy	#DiskFileName&$ff
    180  1129		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  112c		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  112e		       20 12 f0 	      jsr	puts
      0  1131					      db	"   ",0
      1  1131		       20 20 20 00	      .byte.b	"   ",0
    184  1135							; Print the line to the console
    185  1135		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  1137		       a0 90		      ldy	#DiskFileName&$ff
    187  1139		       a5 00		      lda	0
    188  113b		       20 4d 10 	      jsr	PrtStr	;else print name
    189  113e		       20 18 f0 	      jsr	crlf
    190  1141
    191  1141		       4c 25 11 	      jmp	DiskDirLoop	;do next entry
    192  1144		       4c ed 02    DiskDirEnd jmp	NextIL
    193  1147					      endif
    194  1147							;
    195  1147							;=====================================================
    196  1147							; Does a LIST to a Disk file.
    197  1147							;
    198  1147				   iDLIST
    199  1147					      if	XKIM || CTMON65
    200  1147		       20 82 11 	      jsr	SetOutDisk
    201  114a		       4c 82 07 	      jmp	iLST2
    202  114d					      endif
    203  114d							;
    204  114d							;=====================================================
    205  114d							; Closes any pending disk file.  Okay to call if there
    206  114d							; is no open file.
    207  114d							;
    208  114d				   iDCLOSE
    209  114d					      if	XKIM || CTMON65
    210  114d		       20 42 f0 	      jsr	DiskClose
    211  1150		       4c ed 02 	      jmp	NextIL
    212  1153					      endif
    213  1153							;
    214  1153							;=====================================================
    215  1153							; This gets the next byte from an open disk file.  If
    216  1153							; there are no more bytes left, this returns C set.
    217  1153							; Else, C is clear and A contains the character.
    218  1153							;
    219  1153				   getNextFileByte
    220  1153					      if	XKIM || CTMON65
    221  1153		       ae 8f df 	      ldx	diskBufOffset
    222  1156		       ec 8e df 	      cpx	diskBufLength
    223  1159		       d0 14		      bne	hasdata	;branch if still data
    224  115b							;
    225  115b							; There is no data left in the buffer, so read a
    226  115b							; block from the SD system.
    227  115b							;
    228  115b		       a9 84		      lda	#BUFFER_SIZE
    229  115d		       a2 df		      ldx	#buffer>>8
    230  115f		       a0 0a		      ldy	#buffer&$ff
    231  1161		       20 3c f0 	      jsr	DiskRead
    232  1164		       b0 12		      bcs	getNextEof
    233  1166							;
    234  1166							; A contains the number of bytes actually read.
    235  1166							;
    236  1166		       8d 8e df 	      sta	diskBufLength	;save length
    237  1169		       c9 00		      cmp	#0	;shouldn't happen
    238  116b		       f0 0b		      beq	getNextEof
    239  116d							;
    240  116d		       a2 00		      ldx	#0
    241  116f		       bd 0a df    hasdata    lda	buffer,x
    242  1172		       e8		      inx
    243  1173		       8e 8f df 	      stx	diskBufOffset
    244  1176		       18		      clc
    245  1177		       60		      rts
    246  1178							;
    247  1178		       a9 00	   getNextEof lda	#0
    248  117a		       8d 8f df 	      sta	diskBufOffset
    249  117d		       8d 8e df 	      sta	diskBufLength
    250  1180		       38		      sec
    251  1181		       60		      rts
    252  1182							;
    253  1182							;=====================================================
    254  1182							; Set output vector to the disk output function
    255  1182							;
    256  1182		       a9 8d	   SetOutDisk lda	#DOUT&$ff
    257  1184		       8d 4c 16 	      sta	BOutVec
    258  1187		       a9 11		      lda	#DOUT/256
    259  1189		       8d 4d 16 	      sta	BOutVec+1
    260  118c		       60		      rts
    261  118d							;
    262  118d							;=====================================================
    263  118d
    264  118d		       8d 0a df    DOUT       sta	buffer
    265  1190		       a9 01		      lda	#1
    266  1192		       a0 0a		      ldy	#buffer&$ff
    267  1194		       a2 df		      ldx	#buffer/256
    268  1196		       20 3f f0 	      jsr	DiskWrite
    269  1199							;
    270  1199							; need error checking here
    271  1199							;
    272  1199		       60		      rts
    273  119a					      endif
    274  119a
    275  119a
------- FILE mytb.asm
   2133  119a					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  119a					      include	"IL.inc"
      1  119a
      2  119a							;=====================================================
      3  119a							; IL.inc
      4  119a							; These are macros for IL instructions
      5  119a							;
      6  119a					      mac	dw
      7  119a					      .word	{0}
      8  119a					      endm
      9  119a					      mac	db
     10  119a					      .byte	{0}
     11  119a					      endm
     12  119a					      macro	xinit
     13  119a					      db	0
     14  119a					      endm		;reset the il to start clear all
     15  119a							;
     16  119a					      macro	done
     17  119a					      db	1
     18  119a					      endm		;print an error if not end of line
     19  119a							;
     20  119a					      macro	prs
     21  119a					      db	2
     22  119a					      endm		;print a quoted string
     23  119a							;
     24  119a					      macro	prn
     25  119a					      db	3
     26  119a					      endm		;print a number
     27  119a							;
     28  119a					      macro	spc
     29  119a					      db	4
     30  119a					      endm		;print space til new tabstop
     31  119a							;
     32  119a					      macro	nline
     33  119a					      db	5
     34  119a					      endm		;print a new line crlf
     35  119a							;
     36  119a							; My NXT is a bit different in that it takes one
     37  119a							; parameter, which is an address.  If the BASIC
     38  119a							; program is currently running then move to the
     39  119a							; next line and continue execution.  However, if
     40  119a							; in direct mode, jump to the specified IL label.
     41  119a							;
     42  119a					      macro	nxt
     43  119a					      db	6
     44  119a					      dw	{1}	; addr
     45  119a					      endm		; addr
     46  119a							;
     47  119a					      macro	xfer
     48  119a					      db	7
     49  119a					      endm
     50  119a							;
     51  119a					      macro	sav
     52  119a					      db	8
     53  119a					      endm
     54  119a							;
     55  119a					      macro	rstr
     56  119a					      db	9
     57  119a					      endm
     58  119a							;
     59  119a					      macro	cmpr
     60  119a					      db	10
     61  119a					      endm
     62  119a							;
     63  119a					      macro	innum
     64  119a					      db	11
     65  119a					      endm
     66  119a							;
     67  119a					      macro	fin
     68  119a					      db	12
     69  119a					      endm
     70  119a							;
     71  119a							; ERR is followed by an error number.	The error
     72  119a							; code is printed along with the line number.
     73  119a							; Control is passed to the statement set with
     74  119a							; the ERRGOTO statement.
     75  119a							;
     76  119a					      macro	errmsg
     77  119a					      db	13
     78  119a					      dw	{1}	;ecode
     79  119a					      endm		;ecode
     80  119a							;
     81  119a					      macro	add
     82  119a					      db	14
     83  119a					      endm
     84  119a							;
     85  119a					      macro	sub
     86  119a					      db	15
     87  119a					      endm
     88  119a							;
     89  119a					      macro	neg
     90  119a					      db	16
     91  119a					      endm
     92  119a							;
     93  119a					      macro	mul
     94  119a					      db	17
     95  119a					      endm
     96  119a							;
     97  119a					      macro	div
     98  119a					      db	18
     99  119a					      endm
    100  119a							;
    101  119a					      macro	store
    102  119a					      db	19
    103  119a					      endm
    104  119a							;
    105  119a					      macro	ind
    106  119a					      db	20
    107  119a					      endm
    108  119a							;
    109  119a					      macro	lst
    110  119a					      db	21
    111  119a					      endm
    112  119a							;
    113  119a					      macro	init
    114  119a					      db	22
    115  119a					      endm
    116  119a							;
    117  119a					      macro	getline
    118  119a					      db	23
    119  119a					      endm
    120  119a							;
    121  119a					      macro	insert
    122  119a					      db	24
    123  119a					      endm
    124  119a							;
    125  119a					      macro	rtn
    126  119a					      db	25
    127  119a					      endm
    128  119a							;
    129  119a					      macro	exit
    130  119a					      db	26
    131  119a					      endm
    132  119a							;
    133  119a					      macro	lit
    134  119a					      db	27
    135  119a					      dw	{1}	;value
    136  119a					      endm		; value LIT
    137  119a							;
    138  119a					      macro	call
    139  119a					      db	28
    140  119a					      dw	{1}	;addr
    141  119a					      endm		;addr
    142  119a							;
    143  119a							; IJMP will set the IL PC to the specified value.
    144  119a							;
    145  119a					      macro	ijmp
    146  119a					      db	29
    147  119a					      dw	{1}	;addr
    148  119a					      endm		;addr
    149  119a							;
    150  119a					      macro	vinit
    151  119a					      db	30
    152  119a					      endm
    153  119a							;
    154  119a							; ERRGOTO sets the point in the code where the IL
    155  119a							; interpreter will go after any error.
    156  119a							;
    157  119a					      macro	errgoto
    158  119a					      db	31
    159  119a					      dw	{1}	;addr
    160  119a					      endm		;addr
    161  119a							;
    162  119a					      macro	tst
    163  119a					      db	32
    164  119a					      db	({1}-*)-1	;(addr-*)-1
    165  119a					      db	{2},0	;string,0
    166  119a					      endm		;addr,string
    167  119a							;
    168  119a					      macro	tstv
    169  119a					      db	33
    170  119a					      db	({1}-*)-1	;(addr-*)-1
    171  119a					      endm		;addr
    172  119a							;
    173  119a					      macro	tstl
    174  119a					      db	34
    175  119a					      db	({1}-*)-1	;(addr-*)-1
    176  119a					      endm		;addr
    177  119a							;
    178  119a					      macro	tstn
    179  119a					      db	35
    180  119a					      db	({1}-*)-1	;(addr-*)-1
    181  119a					      endm		;addr
    182  119a							;
    183  119a							; FREE returns the amount of free RAM on top of
    184  119a							; the stack.  This is the amount of room the user
    185  119a							; program has available.
    186  119a							;
    187  119a					      macro	free
    188  119a					      db	36
    189  119a					      endm
    190  119a							;
    191  119a							; RANDOM takes the top item off the stack and
    192  119a							; replaces it with a random number that is
    193  119a							; MOD the initial value.  Ie, if the TOS is
    194  119a							; 42 then RANDOM returns a value from 0 to 41.
    195  119a							;
    196  119a					      macro	random
    197  119a					      db	37
    198  119a					      endm
    199  119a							;
    200  119a							; ABS will replace the top of stack with the
    201  119a							; absolute value.
    202  119a							;
    203  119a					      macro	abs
    204  119a					      db	38
    205  119a					      endm
    206  119a							;
    207  119a							; OPENREAD opens a file for reading, as in getting
    208  119a							; statements from it.
    209  119a							;
    210  119a					      macro	openread
    211  119a					      db	39
    212  119a					      endm
    213  119a							;
    214  119a							; OPENWRITE opens a file for writing, as in saving
    215  119a							; the current program to it.
    216  119a							;
    217  119a					      macro	openwrite
    218  119a					      db	40
    219  119a					      endm
    220  119a							;
    221  119a							; DCLOSE closes any open disk file.
    222  119a							;
    223  119a					      macro	dclose
    224  119a					      db	41
    225  119a					      endm
    226  119a							;
    227  119a							; DGETLINE gets one line from the disk file and puts it
    228  119a							; into LINBUFF.
    229  119a							;
    230  119a					      macro	dgetline
    231  119a					      db	42
    232  119a					      endm
    233  119a							;
    234  119a							; DLIST saves the program to an open disk file.
    235  119a							;
    236  119a					      macro	dlist
    237  119a					      db	43
    238  119a					      endm
    239  119a							; DDIR list the current directory
    240  119a							;
    241  119a					      macro	ddir
    242  119a					      db	44
    243  119a					      endm
    244  119a
    245  119a							; RMFILE remove a fle from disk
    246  119a					      macro	rmfile
    247  119a					      db	45
    248  119a					      endm
    249  119a
    250  119a							; CLEARSCREEN clear the screen
    251  119a					      macro	clearscreen
    252  119a					      db	46
    253  119a					      endm
    254  119a							; POKEMEM Poke value into memory
    255  119a					      macro	pokemem
    256  119a					      db	47
    257  119a					      endm
    258  119a							; PEEKMEM peek at value in memory
    259  119a					      macro	peekmem
    260  119a					      db	48
    261  119a					      endm
    262  119a							; TSTLET Test if the statement is a let without the keyword let
    263  119a					      macro	tstlet
    264  119a					      db	49
    265  119a					      db	({1}-*)-1	;(addr-*)-1
    266  119a					      endm		;addr
    267  119a							; TSTDONE if we reach the end of a statement
    268  119a					      macro	tstdone
    269  119a					      db	50
    270  119a					      db	({1}-*)-1	;(addr-*)-1
    271  119a					      endm		;addr
    272  119a							; GETCHAR	get a character from the input line leave it in RO
    273  119a					      macro	getchar
    274  119a					      db	51
    275  119a					      endm
    276  119a							; PUTCHAR	Put a character to the terminal
    277  119a					      macro	putchar
    278  119a					      db	52
    279  119a					      endm
    280  119a							; Call		Call a machine function return a to stack
    281  119a					      macro	callfunc
    282  119a					      db	53
    283  119a					      endm
    284  119a
    285  119a							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    286  119a					      macro	ibranch
    287  119a					      db	54
    288  119a					      endm
    289  119a
    290  119a							; TSTSTR	 Tests for the open quote in a string
    291  119a					      macro	tststr
    292  119a					      db	55
    293  119a					      db	({1}-*)-1	;(addr-*)-1
    294  119a					      endm
    295  119a							; SETIRQ	Sets the line number to run when an irq happens irq 550
    296  119a					      macro	setirq
    297  119a					      db	56
    298  119a					      endm
    299  119a
    300  119a							; TSTIRQ	Test for irq pending,
    301  119a							;		if so push the IRQ LINE NUMBER into RO, onto stack
    302  119a					      macro	tstirq
    303  119a					      db	57
    304  119a					      db	({1}-*)-1	;(addr-*)-1
    305  119a					      endm
    306  119a
    307  119a							; IRET    return from interupt service
    308  119a					      macro	iret
    309  119a					      db	58
    310  119a					      endm
    311  119a
    312  119a							; INSTR   read a string from the input
    313  119a					      macro	instr
    314  119a					      db	59
    315  119a					      endm
    316  119a
    317  119a							; MODULO Returns the remainder of the division
    318  119a					      macro	modulo
    319  119a					      db	60
    320  119a					      endm
    321  119a							; Task Switch
    322  119a					      macro	taskswitch
    323  119a					      db	61
    324  119a					      endm
    325  119a							; Set a task line
    326  119a					      macro	settask
    327  119a					      db	62
    328  119a					      endm
    329  119a							; End a task
    330  119a					      macro	etask
    331  119a					      db	63
    332  119a					      endm
    333  119a							; Skip to next task
    334  119a					      macro	ntask
    335  119a					      db	64
    336  119a					      endm
    337  119a							; Subscript
    338  119a					      macro	subscript
    339  119a					      db	65
    340  119a					      endm
    341  119a							; KILL Task
    342  119a					      macro	taskkill
    343  119a					      db	66
    344  119a					      endm
    345  119a							; STAT Task
    346  119a					      macro	taskstat
    347  119a					      db	67
    348  119a					      endm
    349  119a							;  output value as hex
    350  119a					      macro	hexprt
    351  119a					      db	68
    352  119a					      endm
    353  119a
------- FILE mytb.asm
   2135  119a							;
   2136  119a				  -	      if	FIXED
   2137  119a				  -	      org	$1000
   2138  119a					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  119a					      include	"basic.il"
      1  119a							;LET
      2  119a							;=====================================================
      3  119a							;=====================================================
      4  119a							;=====================================================
      5  119a							; This is the IL of the BASIC (or whatever) language.
      6  119a							; Because of the way macros are implemented by as65,
      7  119a							; labels can't be on the same line as a macro
      8  119a							; invocation, so that's why labels are on separate
      9  119a							; lines.
     10  119a							;
     11  119a		       11 9a	   IL	      equ	*
     12  119a
     13  119a							;THE IL CONTROL SECTION
     14  119a
     15  119a				   START
      0  119a					      INIT		;INITIALIZE
      0  119a					      db	22
      1  119a		       16		      .byte.b	22
      0  119b					      NLINE		;WRITE CRLF
      0  119b					      db	5
      1  119b		       05		      .byte.b	5
      0  119c					      ERRGOTO	CO	;where to go after an error
      0  119c					      db	31
      1  119c		       1f		      .byte.b	31
      0  119d					      dw	CO
      1  119d		       a0 11		      .word.w	CO
      0  119f					      VINIT		;clear all variables
      0  119f					      db	30
      1  119f		       1e		      .byte.b	30
     20  11a0							;
     21  11a0							; This is where we jump to get a line of commands or
     22  11a0							; a program from the user.
     23  11a0							;
     24  11a0				   CO
      0  11a0					      GETLINE		;WRITE PROMPT AND GET LINE
      0  11a0					      db	23
      1  11a0		       17		      .byte.b	23
      0  11a1					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  11a1					      db	34
      1  11a1		       22		      .byte.b	34
      0  11a2					      db	(XEC-*)-1
      1  11a2		       04		      .byte.b	(XEC-*)-1
      0  11a3					      INSERT		;INSERT IT (MAY BE DELETE)
      0  11a3					      db	24
      1  11a3		       18		      .byte.b	24
      0  11a4					      IJMP	CO
      0  11a4					      db	29
      1  11a4		       1d		      .byte.b	29
      0  11a5					      dw	CO
      1  11a5		       a0 11		      .word.w	CO
     29  11a7				   XEC
      0  11a7					      XINIT		;INITIALIZE
      0  11a7					      db	0
      1  11a7		       00		      .byte.b	0
     31  11a8
     32  11a8							;STATEMENT EXECUTOR
     33  11a8				   STMT
      0  11a8					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  11a8					      db	57
      1  11a8		       39		      .byte.b	57
      0  11a9					      db	(notirq-*)-1
      1  11a9		       00		      .byte.b	(notirq-*)-1
     35  11aa				   notirq
      0  11aa					      TASKSWITCH		;if this is not a irq then check for task switch
      0  11aa					      db	61
      1  11aa		       3d		      .byte.b	61
      0  11ab					      TSTLET	LET	;Test if second field is =
      0  11ab					      db	49
      1  11ab		       31		      .byte.b	49
      0  11ac					      db	(LET-*)-1
      1  11ac		       03		      .byte.b	(LET-*)-1
      0  11ad					      IJMP	DOLET	;allow the default to be let
      0  11ad					      db	29
      1  11ad		       1d		      .byte.b	29
      0  11ae					      dw	DOLET
      1  11ae		       b6 11		      .word.w	DOLET
     39  11b0				   LET
      0  11b0					      TST	S1,"LET"	;IS STATEMENT A LET
      0  11b0					      db	32
      1  11b0		       20		      .byte.b	32
      0  11b1					      db	(S1-*)-1
      1  11b1		       21		      .byte.b	(S1-*)-1
      0  11b2					      db	"LET",0
      1  11b2		       4c 45 54 00	      .byte.b	"LET",0
     41  11b6				   DOLET
      0  11b6					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  11b6					      db	33
      1  11b6		       21		      .byte.b	33
      0  11b7					      db	(ERRVEC-*)-1
      1  11b7		       b0		      .byte.b	(ERRVEC-*)-1
      0  11b8					      TST	LETBE,"["
      0  11b8					      db	32
      1  11b8		       20		      .byte.b	32
      0  11b9					      db	(LETBE-*)-1
      1  11b9		       0a		      .byte.b	(LETBE-*)-1
      0  11ba					      db	"[",0
      1  11ba		       5b 00		      .byte.b	"[",0
      0  11bc					      CALL	EXPR
      0  11bc					      db	28
      1  11bc		       1c		      .byte.b	28
      0  11bd					      dw	EXPR
      1  11bd		       96 13		      .word.w	EXPR
      0  11bf					      TST	ERRVEC,"]"
      0  11bf					      db	32
      1  11bf		       20		      .byte.b	32
      0  11c0					      db	(ERRVEC-*)-1
      1  11c0		       a7		      .byte.b	(ERRVEC-*)-1
      0  11c1					      db	"]",0
      1  11c1		       5d 00		      .byte.b	"]",0
      0  11c3					      SUBSCRIPT
      0  11c3					      db	65
      1  11c3		       41		      .byte.b	65
     47  11c4				   LETBE
      0  11c4					      TST	ERRVEC,"="	;(This line originally omitted)
      0  11c4					      db	32
      1  11c4		       20		      .byte.b	32
      0  11c5					      db	(ERRVEC-*)-1
      1  11c5		       a2		      .byte.b	(ERRVEC-*)-1
      0  11c6					      db	"=",0
      1  11c6		       3d 00		      .byte.b	"=",0
      0  11c8					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  11c8					      db	28
      1  11c8		       1c		      .byte.b	28
      0  11c9					      dw	EXPR
      1  11c9		       96 13		      .word.w	EXPR
      0  11cb					      DONE		;REPORT ERROR IF NOT NEXT
      0  11cb					      db	1
      1  11cb		       01		      .byte.b	1
      0  11cc					      STORE		;STORE RESULT
      0  11cc					      db	19
      1  11cc		       13		      .byte.b	19
      0  11cd					      NXT	CO	;AND SEQUENCE TO NEXT
      0  11cd					      db	6
      1  11cd		       06		      .byte.b	6
      0  11ce					      dw	CO
      1  11ce		       a0 11		      .word.w	CO
      0  11d0					      IJMP	STMT
      0  11d0					      db	29
      1  11d0		       1d		      .byte.b	29
      0  11d1					      dw	STMT
      1  11d1		       a8 11		      .word.w	STMT
     54  11d3				   S1
      0  11d3					      TST	S1S1,"IRET"	;test return from interupt
      0  11d3					      db	32
      1  11d3		       20		      .byte.b	32
      0  11d4					      db	(S1S1-*)-1
      1  11d4		       10		      .byte.b	(S1S1-*)-1
      0  11d5					      db	"IRET",0
      1  11d5		       49 52 45 54*	      .byte.b	"IRET",0
      0  11da					      TST	S1Sa,"URN"
      0  11da					      db	32
      1  11da		       20		      .byte.b	32
      0  11db					      db	(S1Sa-*)-1
      1  11db		       04		      .byte.b	(S1Sa-*)-1
      0  11dc					      db	"URN",0
      1  11dc		       55 52 4e 00	      .byte.b	"URN",0
     57  11e0				   S1Sa
      0  11e0					      DONE		;Must be only thing on the line
      0  11e0					      db	1
      1  11e0		       01		      .byte.b	1
      0  11e1					      IRET		;RESTORE LINE NUMBER OF CALL
      0  11e1					      db	58
      1  11e1		       3a		      .byte.b	58
      0  11e2					      IJMP	STMT
      0  11e2					      db	29
      1  11e2		       1d		      .byte.b	29
      0  11e3					      dw	STMT
      1  11e3		       a8 11		      .word.w	STMT
     61  11e5
     62  11e5				   S1S1
      0  11e5					      TST	S1Z,"IF"	;IF STATEMENT
      0  11e5					      db	32
      1  11e5		       20		      .byte.b	32
      0  11e6					      db	(S1Z-*)-1
      1  11e6		       11		      .byte.b	(S1Z-*)-1
      0  11e7					      db	"IF",0
      1  11e7		       49 46 00 	      .byte.b	"IF",0
      0  11ea					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  11ea					      db	28
      1  11ea		       1c		      .byte.b	28
      0  11eb					      dw	EXPR
      1  11eb		       96 13		      .word.w	EXPR
      0  11ed					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  11ed					      db	32
      1  11ed		       20		      .byte.b	32
      0  11ee					      db	(S1W-*)-1
      1  11ee		       05		      .byte.b	(S1W-*)-1
      0  11ef					      db	"THEN",0
      1  11ef		       54 48 45 4e*	      .byte.b	"THEN",0
     66  11f4				   S1W
      0  11f4					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  11f4					      db	54
      1  11f4		       36		      .byte.b	54
      0  11f5					      IJMP	STMT
      0  11f5					      db	29
      1  11f5		       1d		      .byte.b	29
      0  11f6					      dw	STMT
      1  11f6		       a8 11		      .word.w	STMT
     69  11f8
     70  11f8				   S1Z
      0  11f8					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  11f8					      db	32
      1  11f8		       20		      .byte.b	32
      0  11f9					      db	(S2b-*)-1
      1  11f9		       18		      .byte.b	(S2b-*)-1
      0  11fa					      db	"GO",0
      1  11fa		       47 4f 00 	      .byte.b	"GO",0
      0  11fd					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  11fd					      db	32
      1  11fd		       20		      .byte.b	32
      0  11fe					      db	(S2-*)-1
      1  11fe		       07		      .byte.b	(S2-*)-1
      0  11ff					      db	"TO",0
      1  11ff		       54 4f 00 	      .byte.b	"TO",0
      0  1202					      CALL	EXPR	;GET LABEL
      0  1202					      db	28
      1  1202		       1c		      .byte.b	28
      0  1203					      dw	EXPR
      1  1203		       96 13		      .word.w	EXPR
      0  1205					      XFER		;SET UP AND JUMP
      0  1205					      db	7
      1  1205		       07		      .byte.b	7
     75  1206				   S2
      0  1206					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1206					      db	32
      1  1206		       20		      .byte.b	32
      0  1207					      db	(ERRVEC-*)-1
      1  1207		       60		      .byte.b	(ERRVEC-*)-1
      0  1208					      db	"SUB",0
      1  1208		       53 55 42 00	      .byte.b	"SUB",0
      0  120c					      CALL	EXPR	;GET DESTINATION
      0  120c					      db	28
      1  120c		       1c		      .byte.b	28
      0  120d					      dw	EXPR
      1  120d		       96 13		      .word.w	EXPR
      0  120f					      DONE		;ERROR IF CR NOT NEXT
      0  120f					      db	1
      1  120f		       01		      .byte.b	1
      0  1210					      SAV		;SAVE RETURN LINE
      0  1210					      db	8
      1  1210		       08		      .byte.b	8
      0  1211					      XFER		;AND JUMP
      0  1211					      db	7
      1  1211		       07		      .byte.b	7
     81  1212				   S2b
      0  1212					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1212					      db	32
      1  1212		       20		      .byte.b	32
      0  1213					      db	(S3-*)-1
      1  1213		       1f		      .byte.b	(S3-*)-1
      0  1214					      db	"RE",0
      1  1214		       52 45 00 	      .byte.b	"RE",0
      0  1217					      TST	S2a,"T"
      0  1217					      db	32
      1  1217		       20		      .byte.b	32
      0  1218					      db	(S2a-*)-1
      1  1218		       10		      .byte.b	(S2a-*)-1
      0  1219					      db	"T",0
      1  1219		       54 00		      .byte.b	"T",0
      0  121b					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  121b					      db	32
      1  121b		       20		      .byte.b	32
      0  121c					      db	(S2aa-*)-1
      1  121c		       04		      .byte.b	(S2aa-*)-1
      0  121d					      db	"URN",0
      1  121d		       55 52 4e 00	      .byte.b	"URN",0
     85  1221				   S2aa
      0  1221					      DONE		;MUST BE CR
      0  1221					      db	1
      1  1221		       01		      .byte.b	1
      0  1222					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  1222					      db	9
      1  1222		       09		      .byte.b	9
      0  1223					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1223					      db	6
      1  1223		       06		      .byte.b	6
      0  1224					      dw	CO
      1  1224		       a0 11		      .word.w	CO
      0  1226					      IJMP	STMT
      0  1226					      db	29
      1  1226		       1d		      .byte.b	29
      0  1227					      dw	STMT
      1  1227		       a8 11		      .word.w	STMT
     90  1229				   S2a
      0  1229					      TST	S3,"M"	;REMark.  Skip rest of line
      0  1229					      db	32
      1  1229		       20		      .byte.b	32
      0  122a					      db	(S3-*)-1
      1  122a		       08		      .byte.b	(S3-*)-1
      0  122b					      db	"M",0
      1  122b		       4d 00		      .byte.b	"M",0
      0  122d					      NXT	CO
      0  122d					      db	6
      1  122d		       06		      .byte.b	6
      0  122e					      dw	CO
      1  122e		       a0 11		      .word.w	CO
      0  1230					      IJMP	STMT
      0  1230					      db	29
      1  1230		       1d		      .byte.b	29
      0  1231					      dw	STMT
      1  1231		       a8 11		      .word.w	STMT
     94  1233
     95  1233				   S3
      0  1233					      TST	S3a,"?"	; ? symonym for print
      0  1233					      db	32
      1  1233		       20		      .byte.b	32
      0  1234					      db	(S3a-*)-1
      1  1234		       05		      .byte.b	(S3a-*)-1
      0  1235					      db	"?",0
      1  1235		       3f 00		      .byte.b	"?",0
      0  1237					      IJMP	S4
      0  1237					      db	29
      1  1237		       1d		      .byte.b	29
      0  1238					      dw	S4
      1  1238		       45 12		      .word.w	S4
     98  123a				   S3a
      0  123a					      TST	S8,"PR"	;allow short form of print
      0  123a					      db	32
      1  123a		       20		      .byte.b	32
      0  123b					      db	(S8-*)-1
      1  123b		       49		      .byte.b	(S8-*)-1
      0  123c					      db	"PR",0
      1  123c		       50 52 00 	      .byte.b	"PR",0
      0  123f					      TST	S4,"INT"	;PRINT
      0  123f					      db	32
      1  123f		       20		      .byte.b	32
      0  1240					      db	(S4-*)-1
      1  1240		       04		      .byte.b	(S4-*)-1
      0  1241					      db	"INT",0
      1  1241		       49 4e 54 00	      .byte.b	"INT",0
    101  1245				   S4
      0  1245					      TSTDONE	S4a	;Test if we just want crlf printed
      0  1245					      db	50
      1  1245		       32		      .byte.b	50
      0  1246					      db	(S4a-*)-1
      1  1246		       03		      .byte.b	(S4a-*)-1
      0  1247					      IJMP	S6
      0  1247					      db	29
      1  1247		       1d		      .byte.b	29
      0  1248					      dw	S6
      1  1248		       60 12		      .word.w	S6
    104  124a
    105  124a				   S4a
      0  124a					      TSTSTR	S7	;TEST FOR QUOTED String
      0  124a					      db	55
      1  124a		       37		      .byte.b	55
      0  124b					      db	(S7-*)-1
      1  124b		       1f		      .byte.b	(S7-*)-1
      0  124c					      PRS		;PRINT STRING
      0  124c					      db	2
      1  124c		       02		      .byte.b	2
    108  124d				   S5
      0  124d					      TST	S6A,COMMA	;IS THERE MORE?
      0  124d					      db	32
      1  124d		       20		      .byte.b	32
      0  124e					      db	(S6A-*)-1
      1  124e		       08		      .byte.b	(S6A-*)-1
      0  124f					      db	COMMA,0
      1  124f		       2c 00		      .byte.b	COMMA,0
      0  1251					      SPC		;SPACE TO NEXT ZONE
      0  1251					      db	4
      1  1251		       04		      .byte.b	4
      0  1252					      TSTDONE	S4	;Not end of line jump back
      0  1252					      db	50
      1  1252		       32		      .byte.b	50
      0  1253					      db	(S4-*)-1
      1  1253		       f1		      .byte.b	(S4-*)-1
      0  1254					      IJMP	S6Z	;YES JUMP BACK
      0  1254					      db	29
      1  1254		       1d		      .byte.b	29
      0  1255					      dw	S6Z
      1  1255		       62 12		      .word.w	S6Z
    113  1257
    114  1257							;
    115  1257							; If a semicolon, don't do anything.
    116  1257							;
    117  1257				   S6A
      0  1257					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  1257					      db	32
      1  1257		       20		      .byte.b	32
      0  1258					      db	(S6-*)-1
      1  1258		       07		      .byte.b	(S6-*)-1
      0  1259					      db	SEMICOLON,0
      1  1259		       3b 00		      .byte.b	SEMICOLON,0
      0  125b					      TSTDONE	S4	;Jump Back if not end of line
      0  125b					      db	50
      1  125b		       32		      .byte.b	50
      0  125c					      db	(S4-*)-1
      1  125c		       e8		      .byte.b	(S4-*)-1
      0  125d					      IJMP	S6Z
      0  125d					      db	29
      1  125d		       1d		      .byte.b	29
      0  125e					      dw	S6Z
      1  125e		       62 12		      .word.w	S6Z
    121  1260				   S6
      0  1260					      DONE		;ERROR IF CR NOT NEXT
      0  1260					      db	1
      1  1260		       01		      .byte.b	1
      0  1261					      NLINE
      0  1261					      db	5
      1  1261		       05		      .byte.b	5
    124  1262				   S6Z
      0  1262					      NXT	CO	;exit here if , or ; at end of print
      0  1262					      db	6
      1  1262		       06		      .byte.b	6
      0  1263					      dw	CO
      1  1263		       a0 11		      .word.w	CO
      0  1265					      IJMP	STMT
      0  1265					      db	29
      1  1265		       1d		      .byte.b	29
      0  1266					      dw	STMT
      1  1266		       a8 11		      .word.w	STMT
    127  1268							;
    128  1268							; A jump for code too far away for relative branch
    129  1268							;
    130  1268				   ERRVEC
      0  1268					      IJMP	UNKNOWN
      0  1268					      db	29
      1  1268		       1d		      .byte.b	29
      0  1269					      dw	UNKNOWN
      1  1269		       93 13		      .word.w	UNKNOWN
    132  126b							;
    133  126b							; Get here if there is an expression to print
    134  126b				   S7
      0  126b					      TST	S7A,"$"
      0  126b					      db	32
      1  126b		       20		      .byte.b	32
      0  126c					      db	(S7A-*)-1
      1  126c		       09		      .byte.b	(S7A-*)-1
      0  126d					      db	"$",0
      1  126d		       24 00		      .byte.b	"$",0
      0  126f					      CALL	EXPR
      0  126f					      db	28
      1  126f		       1c		      .byte.b	28
      0  1270					      dw	EXPR
      1  1270		       96 13		      .word.w	EXPR
      0  1272					      HEXPRT
      0  1272					      db	68
      1  1272		       44		      .byte.b	68
      0  1273					      IJMP	S5
      0  1273					      db	29
      1  1273		       1d		      .byte.b	29
      0  1274					      dw	S5
      1  1274		       4d 12		      .word.w	S5
    139  1276				   S7A
      0  1276					      CALL	EXPR
      0  1276					      db	28
      1  1276		       1c		      .byte.b	28
      0  1277					      dw	EXPR
      1  1277		       96 13		      .word.w	EXPR
      0  1279					      TST	S7B,"$"
      0  1279					      db	32
      1  1279		       20		      .byte.b	32
      0  127a					      db	(S7B-*)-1
      1  127a		       06		      .byte.b	(S7B-*)-1
      0  127b					      db	"$",0
      1  127b		       24 00		      .byte.b	"$",0
      0  127d					      PUTCHAR
      0  127d					      db	52
      1  127d		       34		      .byte.b	52
      0  127e					      IJMP	S5
      0  127e					      db	29
      1  127e		       1d		      .byte.b	29
      0  127f					      dw	S5
      1  127f		       4d 12		      .word.w	S5
    144  1281				   S7B
      0  1281					      PRN		;PRINT IT
      0  1281					      db	3
      1  1281		       03		      .byte.b	3
      0  1282					      IJMP	S5	;IS THERE MORE?
      0  1282					      db	29
      1  1282		       1d		      .byte.b	29
      0  1283					      dw	S5
      1  1283		       4d 12		      .word.w	S5
    147  1285							;
    148  1285							;===========================================================
    149  1285							; End of TASK process
    150  1285				   S8
      0  1285					      TST	S8G,"ETASK"	; End task
      0  1285					      db	32
      1  1285		       20		      .byte.b	32
      0  1286					      db	(S8G-*)-1
      1  1286		       0b		      .byte.b	(S8G-*)-1
      0  1287					      db	"ETASK",0
      1  1287		       45 54 41 53*	      .byte.b	"ETASK",0
      0  128d					      ETASK
      0  128d					      db	63
      1  128d		       3f		      .byte.b	63
      0  128e					      DONE		; Must be last thing on a line
      0  128e					      db	1
      1  128e		       01		      .byte.b	1
      0  128f					      IJMP	STMT
      0  128f					      db	29
      1  128f		       1d		      .byte.b	29
      0  1290					      dw	STMT
      1  1290		       a8 11		      .word.w	STMT
    155  1292							;
    156  1292							;===========================================================
    157  1292							; The task gives up the rest of the cycles
    158  1292				   S8G
      0  1292					      TST	S8a,"NTASK"	;Next task
      0  1292					      db	32
      1  1292		       20		      .byte.b	32
      0  1293					      db	(S8a-*)-1
      1  1293		       0d		      .byte.b	(S8a-*)-1
      0  1294					      db	"NTASK",0
      1  1294		       4e 54 41 53*	      .byte.b	"NTASK",0
      0  129a					      NTASK
      0  129a					      db	64
      1  129a		       40		      .byte.b	64
      0  129b					      NXT	CO	;Next statement to execute
      0  129b					      db	6
      1  129b		       06		      .byte.b	6
      0  129c					      dw	CO
      1  129c		       a0 11		      .word.w	CO
      0  129e					      IJMP	STMT
      0  129e					      db	29
      1  129e		       1d		      .byte.b	29
      0  129f					      dw	STMT
      1  129f		       a8 11		      .word.w	STMT
    163  12a1							;
    164  12a1							;===========================================================
    165  12a1							; Update a memory location with a value
    166  12a1				   S8a
      0  12a1					      TST	S8b,"POKE"	;Poke a value into memory
      0  12a1					      db	32
      1  12a1		       20		      .byte.b	32
      0  12a2					      db	(S8b-*)-1
      1  12a2		       17		      .byte.b	(S8b-*)-1
      0  12a3					      db	"POKE",0
      1  12a3		       50 4f 4b 45*	      .byte.b	"POKE",0
      0  12a8					      CALL	EXPR	;Get address to write to
      0  12a8					      db	28
      1  12a8		       1c		      .byte.b	28
      0  12a9					      dw	EXPR
      1  12a9		       96 13		      .word.w	EXPR
      0  12ab					      TST	UNKNOWN,COMMA	;Must have a coma
      0  12ab					      db	32
      1  12ab		       20		      .byte.b	32
      0  12ac					      db	(UNKNOWN-*)-1
      1  12ac		       e6		      .byte.b	(UNKNOWN-*)-1
      0  12ad					      db	COMMA,0
      1  12ad		       2c 00		      .byte.b	COMMA,0
      0  12af					      CALL	EXPR	;Get the value to poke
      0  12af					      db	28
      1  12af		       1c		      .byte.b	28
      0  12b0					      dw	EXPR
      1  12b0		       96 13		      .word.w	EXPR
      0  12b2					      POKEMEM
      0  12b2					      db	47
      1  12b2		       2f		      .byte.b	47
      0  12b3					      DONE
      0  12b3					      db	1
      1  12b3		       01		      .byte.b	1
      0  12b4					      NXT	CO	;AND SEQUENCE TO NEXT
      0  12b4					      db	6
      1  12b4		       06		      .byte.b	6
      0  12b5					      dw	CO
      1  12b5		       a0 11		      .word.w	CO
      0  12b7					      IJMP	STMT
      0  12b7					      db	29
      1  12b7		       1d		      .byte.b	29
      0  12b8					      dw	STMT
      1  12b8		       a8 11		      .word.w	STMT
    175  12ba
    176  12ba				   S8b
      0  12ba					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  12ba					      db	32
      1  12ba		       20		      .byte.b	32
      0  12bb					      db	(S8c-*)-1
      1  12bb		       11		      .byte.b	(S8c-*)-1
      0  12bc					      db	"PUTCH",0
      1  12bc		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  12c2					      CALL	EXPR
      0  12c2					      db	28
      1  12c2		       1c		      .byte.b	28
      0  12c3					      dw	EXPR
      1  12c3		       96 13		      .word.w	EXPR
      0  12c5					      PUTCHAR
      0  12c5					      db	52
      1  12c5		       34		      .byte.b	52
      0  12c6					      DONE
      0  12c6					      db	1
      1  12c6		       01		      .byte.b	1
      0  12c7					      NXT	CO	;AND SEQUENCE TO NEXT
      0  12c7					      db	6
      1  12c7		       06		      .byte.b	6
      0  12c8					      dw	CO
      1  12c8		       a0 11		      .word.w	CO
      0  12ca					      IJMP	STMT
      0  12ca					      db	29
      1  12ca		       1d		      .byte.b	29
      0  12cb					      dw	STMT
      1  12cb		       a8 11		      .word.w	STMT
    183  12cd				   S8c
      0  12cd					      TST	S9,"CLS"	;Clear the screen
      0  12cd					      db	32
      1  12cd		       20		      .byte.b	32
      0  12ce					      db	(S9-*)-1
      1  12ce		       0b		      .byte.b	(S9-*)-1
      0  12cf					      db	"CLS",0
      1  12cf		       43 4c 53 00	      .byte.b	"CLS",0
      0  12d3					      CLEARSCREEN
      0  12d3					      db	46
      1  12d3		       2e		      .byte.b	46
      0  12d4					      NXT	CO	;AND SEQUENCE TO NEXT
      0  12d4					      db	6
      1  12d4		       06		      .byte.b	6
      0  12d5					      dw	CO
      1  12d5		       a0 11		      .word.w	CO
      0  12d7					      IJMP	STMT
      0  12d7					      db	29
      1  12d7		       1d		      .byte.b	29
      0  12d8					      dw	STMT
      1  12d8		       a8 11		      .word.w	STMT
    188  12da				   S9
      0  12da					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  12da					      db	32
      1  12da		       20		      .byte.b	32
      0  12db					      db	(S13-*)-1
      1  12db		       2a		      .byte.b	(S13-*)-1
      0  12dc					      db	"INPUT",0
      1  12dc		       49 4e 50 55*	      .byte.b	"INPUT",0
    190  12e2				   S10
      0  12e2					      TSTSTR	S10A	;If there is a string print the prompt
      0  12e2					      db	55
      1  12e2		       37		      .byte.b	55
      0  12e3					      db	(S10A-*)-1
      1  12e3		       05		      .byte.b	(S10A-*)-1
      0  12e4					      PRS
      0  12e4					      db	2
      1  12e4		       02		      .byte.b	2
      0  12e5					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  12e5					      db	32
      1  12e5		       20		      .byte.b	32
      0  12e6					      db	(S10Z-*)-1
      1  12e6		       15		      .byte.b	(S10Z-*)-1
      0  12e7					      db	SEMICOLON,0
      1  12e7		       3b 00		      .byte.b	SEMICOLON,0
    194  12e9				   S10A
      0  12e9					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  12e9					      db	33
      1  12e9		       21		      .byte.b	33
      0  12ea					      db	(UNKNOWN-*)-1
      1  12ea		       a8		      .byte.b	(UNKNOWN-*)-1
      0  12eb					      TST	S10A1,DOLLAR
      0  12eb					      db	32
      1  12eb		       20		      .byte.b	32
      0  12ec					      db	(S10A1-*)-1
      1  12ec		       06		      .byte.b	(S10A1-*)-1
      0  12ed					      db	DOLLAR,0
      1  12ed		       24 00		      .byte.b	DOLLAR,0
      0  12ef					      INSTR
      0  12ef					      db	59
      1  12ef		       3b		      .byte.b	59
      0  12f0					      IJMP	S10A2
      0  12f0					      db	29
      1  12f0		       1d		      .byte.b	29
      0  12f1					      dw	S10A2
      1  12f1		       f4 12		      .word.w	S10A2
    199  12f3				   S10A1
      0  12f3					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  12f3					      db	11
      1  12f3		       0b		      .byte.b	11
    201  12f4				   S10A2
      0  12f4					      STORE		;STORE IT
      0  12f4					      db	19
      1  12f4		       13		      .byte.b	19
      0  12f5					      TST	S11,COMMA	;IS THERE MORE?
      0  12f5					      db	32
      1  12f5		       20		      .byte.b	32
      0  12f6					      db	(S11-*)-1
      1  12f6		       08		      .byte.b	(S11-*)-1
      0  12f7					      db	COMMA,0
      1  12f7		       2c 00		      .byte.b	COMMA,0
      0  12f9					      IJMP	S10	;YES
      0  12f9					      db	29
      1  12f9		       1d		      .byte.b	29
      0  12fa					      dw	S10
      1  12fa		       e2 12		      .word.w	S10
    205  12fc				   S10Z
      0  12fc					      iJMP	UNKNOWN
      0  12fc					      db	29
      1  12fc		       1d		      .byte.b	29
      0  12fd					      dw	UNKNOWN
      1  12fd		       93 13		      .word.w	UNKNOWN
    207  12ff				   S11
      0  12ff					      DONE		;MUST BE CR
      0  12ff					      db	1
      1  12ff		       01		      .byte.b	1
      0  1300					      NXT	CO	;SEQUENCE TO NEXT
      0  1300					      db	6
      1  1300		       06		      .byte.b	6
      0  1301					      dw	CO
      1  1301		       a0 11		      .word.w	CO
      0  1303					      IJMP	STMT
      0  1303					      db	29
      1  1303		       1d		      .byte.b	29
      0  1304					      dw	STMT
      1  1304		       a8 11		      .word.w	STMT
    211  1306				   S13
      0  1306					      TST	S14,"END"
      0  1306					      db	32
      1  1306		       20		      .byte.b	32
      0  1307					      db	(S14-*)-1
      1  1307		       05		      .byte.b	(S14-*)-1
      0  1308					      db	"END",0
      1  1308		       45 4e 44 00	      .byte.b	"END",0
      0  130c					      FIN
      0  130c					      db	12
      1  130c		       0c		      .byte.b	12
    214  130d
    215  130d				   S14
      0  130d					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  130d					      db	32
      1  130d		       20		      .byte.b	32
      0  130e					      db	(S14Z-*)-1
      1  130e		       0f		      .byte.b	(S14Z-*)-1
      0  130f					      db	"IRQ",0
      1  130f		       49 52 51 00	      .byte.b	"IRQ",0
      0  1313					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1313					      db	28
      1  1313		       1c		      .byte.b	28
      0  1314					      dw	EXPR
      1  1314		       96 13		      .word.w	EXPR
      0  1316					      DONE		;must be CR
      0  1316					      db	1
      1  1316		       01		      .byte.b	1
      0  1317					      SETIRQ		;Set the line number now
      0  1317					      db	56
      1  1317		       38		      .byte.b	56
      0  1318					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1318					      db	6
      1  1318		       06		      .byte.b	6
      0  1319					      dw	CO
      1  1319		       a0 11		      .word.w	CO
      0  131b					      IJMP	STMT
      0  131b					      db	29
      1  131b		       1d		      .byte.b	29
      0  131c					      dw	STMT
      1  131c		       a8 11		      .word.w	STMT
    222  131e
    223  131e				   S14Z
      0  131e					      TST	S14S1,"KILL"	; Kill A running Task
      0  131e					      db	32
      1  131e		       20		      .byte.b	32
      0  131f					      db	(S14S1-*)-1
      1  131f		       10		      .byte.b	(S14S1-*)-1
      0  1320					      db	"KILL",0
      1  1320		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  1325					      CALL	EXPR
      0  1325					      db	28
      1  1325		       1c		      .byte.b	28
      0  1326					      dw	EXPR
      1  1326		       96 13		      .word.w	EXPR
      0  1328					      DONE
      0  1328					      db	1
      1  1328		       01		      .byte.b	1
      0  1329					      TASKKILL
      0  1329					      db	66
      1  1329		       42		      .byte.b	66
      0  132a					      NXT	CO
      0  132a					      db	6
      1  132a		       06		      .byte.b	6
      0  132b					      dw	CO
      1  132b		       a0 11		      .word.w	CO
      0  132d					      IJMP	STMT
      0  132d					      db	29
      1  132d		       1d		      .byte.b	29
      0  132e					      dw	STMT
      1  132e		       a8 11		      .word.w	STMT
    230  1330
    231  1330				   S14S1
      0  1330					      TST	S15,"LIST"	;LIST COMMAND
      0  1330					      db	32
      1  1330		       20		      .byte.b	32
      0  1331					      db	(S15-*)-1
      1  1331		       0a		      .byte.b	(S15-*)-1
      0  1332					      db	"LIST",0
      1  1332		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1337					      DONE
      0  1337					      db	1
      1  1337		       01		      .byte.b	1
      0  1338					      LST
      0  1338					      db	21
      1  1338		       15		      .byte.b	21
      0  1339					      IJMP	CO
      0  1339					      db	29
      1  1339		       1d		      .byte.b	29
      0  133a					      dw	CO
      1  133a		       a0 11		      .word.w	CO
    236  133c				   S15
      0  133c					      TST	S16,"RUN"	;RUN COMMAND
      0  133c					      db	32
      1  133c		       20		      .byte.b	32
      0  133d					      db	(S16-*)-1
      1  133d		       0d		      .byte.b	(S16-*)-1
      0  133e					      db	"RUN",0
      1  133e		       52 55 4e 00	      .byte.b	"RUN",0
      0  1342					      DONE
      0  1342					      db	1
      1  1342		       01		      .byte.b	1
      0  1343					      VINIT		;clear variables
      0  1343					      db	30
      1  1343		       1e		      .byte.b	30
      0  1344					      LIT	1	;GOTO line 1
      0  1344					      db	27
      1  1344		       1b		      .byte.b	27
      0  1345					      dw	1
      1  1345		       01 00		      .word.w	1
      0  1347					      XFER		;Bob's addition
      0  1347					      db	7
      1  1347		       07		      .byte.b	7
    242  1348							; EXIT
      0  1348					      IJMP	STMT	;and run!
      0  1348					      db	29
      1  1348		       1d		      .byte.b	29
      0  1349					      dw	STMT
      1  1349		       a8 11		      .word.w	STMT
    244  134b				   S16
      0  134b					      TST	S17A,"NEW"	;clear program
      0  134b					      db	32
      1  134b		       20		      .byte.b	32
      0  134c					      db	(S17A-*)-1
      1  134c		       08		      .byte.b	(S17A-*)-1
      0  134d					      db	"NEW",0
      1  134d		       4e 45 57 00	      .byte.b	"NEW",0
      0  1351					      DONE
      0  1351					      db	1
      1  1351		       01		      .byte.b	1
      0  1352					      IJMP	START
      0  1352					      db	29
      1  1352		       1d		      .byte.b	29
      0  1353					      dw	START
      1  1353		       9a 11		      .word.w	START
    248  1355
    249  1355				   S17A
      0  1355					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1355					      db	32
      1  1355		       20		      .byte.b	32
      0  1356					      db	(S17B-*)-1
      1  1356		       06		      .byte.b	(S17B-*)-1
      0  1357					      db	"EXIT",0
      1  1357		       45 58 49 54*	      .byte.b	"EXIT",0
      0  135c					      EXIT
      0  135c					      db	26
      1  135c		       1a		      .byte.b	26
    252  135d
    253  135d							;
    254  135d							; Commands related to saving/restoring programs
    255  135d							; to/from mass storage.
    256  135d							;
    257  135d				   S17B
    258  135d					      if	(XKIM || CTMON65) && DISK_ACCESS
    259  135d
      0  135d					      TST	S17C,"SAVE"
      0  135d					      db	32
      1  135d		       20		      .byte.b	32
      0  135e					      db	(S17C-*)-1
      1  135e		       0b		      .byte.b	(S17C-*)-1
      0  135f					      db	"SAVE",0
      1  135f		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1364					      OPENWRITE
      0  1364					      db	40
      1  1364		       28		      .byte.b	40
      0  1365					      DLIST
      0  1365					      db	43
      1  1365		       2b		      .byte.b	43
      0  1366					      DCLOSE
      0  1366					      db	41
      1  1366		       29		      .byte.b	41
      0  1367					      IJMP	CO
      0  1367					      db	29
      1  1367		       1d		      .byte.b	29
      0  1368					      dw	CO
      1  1368		       a0 11		      .word.w	CO
    265  136a
    266  136a				   S17C
      0  136a					      TST	S18,"LOAD"
      0  136a					      db	32
      1  136a		       20		      .byte.b	32
      0  136b					      db	(S18-*)-1
      1  136b		       11		      .byte.b	(S18-*)-1
      0  136c					      db	"LOAD",0
      1  136c		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1371					      OPENREAD
      0  1371					      db	39
      1  1371		       27		      .byte.b	39
    269  1372				   S17CLP
      0  1372					      DGETLINE		;get line from file
      0  1372					      db	42
      1  1372		       2a		      .byte.b	42
      0  1373					      TSTL	S17EOL	;no line num means EOL
      0  1373					      db	34
      1  1373		       22		      .byte.b	34
      0  1374					      db	(S17EOL-*)-1
      1  1374		       04		      .byte.b	(S17EOL-*)-1
      0  1375					      INSERT		;put it into the program
      0  1375					      db	24
      1  1375		       18		      .byte.b	24
      0  1376					      IJMP	S17CLP	;keep going
      0  1376					      db	29
      1  1376		       1d		      .byte.b	29
      0  1377					      dw	S17CLP
      1  1377		       72 13		      .word.w	S17CLP
    274  1379				   S17EOL
      0  1379					      DCLOSE		;close disk file
      0  1379					      db	41
      1  1379		       29		      .byte.b	41
      0  137a					      IJMP	CO	;back to start
      0  137a					      db	29
      1  137a		       1d		      .byte.b	29
      0  137b					      dw	CO
      1  137b		       a0 11		      .word.w	CO
    277  137d
      0  137d				   S18	      TST	S19,"DIR"
      0  137d					      db	32
      1  137d		       20		      .byte.b	32
      0  137e					      db	(S19-*)-1
      1  137e		       08		      .byte.b	(S19-*)-1
      0  137f					      db	"DIR",0
      1  137f		       44 49 52 00	      .byte.b	"DIR",0
      0  1383					      DDIR		;Display the directory content
      0  1383					      db	44
      1  1383		       2c		      .byte.b	44
      0  1384					      IJMP	CO
      0  1384					      db	29
      1  1384		       1d		      .byte.b	29
      0  1385					      dw	CO
      1  1385		       a0 11		      .word.w	CO
    281  1387					      endif
    282  1387
      0  1387				   S19	      TST	UNKNOWN,"ERASE"
      0  1387					      db	32
      1  1387		       20		      .byte.b	32
      0  1388					      db	(UNKNOWN-*)-1
      1  1388		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1389					      db	"ERASE",0
      1  1389		       45 52 41 53*	      .byte.b	"ERASE",0
      0  138f					      RMFILE		;Erase the file from the disk
      0  138f					      db	45
      1  138f		       2d		      .byte.b	45
      0  1390					      IJMP	CO
      0  1390					      db	29
      1  1390		       1d		      .byte.b	29
      0  1391					      dw	CO
      1  1391		       a0 11		      .word.w	CO
    286  1391					      endif
    287  1393
    288  1393							;
    289  1393							; Else, unknown command.
    290  1393							;
    291  1393				   UNKNOWN
      0  1393					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1393					      db	13
      1  1393		       0d		      .byte.b	13
      0  1394					      dw	ERR_SYNTAX
      1  1394		       05 00		      .word.w	ERR_SYNTAX
    293  1396
    294  1396							;-----------------------------------------------------
    295  1396				   EXPR
      0  1396					      Call	EXPR2	; get the first expression
      0  1396					      db	28
      1  1396		       1c		      .byte.b	28
      0  1397					      dw	EXPR2
      1  1397		       e1 13		      .word.w	EXPR2
      0  1399					      TST	iR0,"="
      0  1399					      db	32
      1  1399		       20		      .byte.b	32
      0  139a					      db	(iR0-*)-1
      1  139a		       08		      .byte.b	(iR0-*)-1
      0  139b					      db	"=",0
      1  139b		       3d 00		      .byte.b	"=",0
      0  139d					      LIT	2	;=
      0  139d					      db	27
      1  139d		       1b		      .byte.b	27
      0  139e					      dw	2
      1  139e		       02 00		      .word.w	2
      0  13a0					      IJMP	iRFound
      0  13a0					      db	29
      1  13a0		       1d		      .byte.b	29
      0  13a1					      dw	iRFound
      1  13a1		       dc 13		      .word.w	iRFound
    300  13a3				   iR0
      0  13a3					      TST	iR4,"<"
      0  13a3					      db	32
      1  13a3		       20		      .byte.b	32
      0  13a4					      db	(iR4-*)-1
      1  13a4		       1c		      .byte.b	(iR4-*)-1
      0  13a5					      db	"<",0
      1  13a5		       3c 00		      .byte.b	"<",0
      0  13a7					      TST	iR1,"="
      0  13a7					      db	32
      1  13a7		       20		      .byte.b	32
      0  13a8					      db	(iR1-*)-1
      1  13a8		       08		      .byte.b	(iR1-*)-1
      0  13a9					      db	"=",0
      1  13a9		       3d 00		      .byte.b	"=",0
      0  13ab					      LIT	3	;<=
      0  13ab					      db	27
      1  13ab		       1b		      .byte.b	27
      0  13ac					      dw	3
      1  13ac		       03 00		      .word.w	3
      0  13ae					      IJMP	iRFound
      0  13ae					      db	29
      1  13ae		       1d		      .byte.b	29
      0  13af					      dw	iRFound
      1  13af		       dc 13		      .word.w	iRFound
    305  13b1				   iR1
      0  13b1					      TST	iR3,">"
      0  13b1					      db	32
      1  13b1		       20		      .byte.b	32
      0  13b2					      db	(iR3-*)-1
      1  13b2		       08		      .byte.b	(iR3-*)-1
      0  13b3					      db	">",0
      1  13b3		       3e 00		      .byte.b	">",0
      0  13b5					      LIT	5	;<>
      0  13b5					      db	27
      1  13b5		       1b		      .byte.b	27
      0  13b6					      dw	5
      1  13b6		       05 00		      .word.w	5
      0  13b8					      IJMP	iRFound
      0  13b8					      db	29
      1  13b8		       1d		      .byte.b	29
      0  13b9					      dw	iRFound
      1  13b9		       dc 13		      .word.w	iRFound
    309  13bb				   iR3
      0  13bb					      LIT	1	;<
      0  13bb					      db	27
      1  13bb		       1b		      .byte.b	27
      0  13bc					      dw	1
      1  13bc		       01 00		      .word.w	1
      0  13be					      IJMP	iRFound
      0  13be					      db	29
      1  13be		       1d		      .byte.b	29
      0  13bf					      dw	iRFound
      1  13bf		       dc 13		      .word.w	iRFound
    312  13c1				   iR4
      0  13c1					      TST	iRDone,">"
      0  13c1					      db	32
      1  13c1		       20		      .byte.b	32
      0  13c2					      db	(iRDone-*)-1
      1  13c2		       1d		      .byte.b	(iRDone-*)-1
      0  13c3					      db	">",0
      1  13c3		       3e 00		      .byte.b	">",0
      0  13c5					      TST	iR5,"="
      0  13c5					      db	32
      1  13c5		       20		      .byte.b	32
      0  13c6					      db	(iR5-*)-1
      1  13c6		       08		      .byte.b	(iR5-*)-1
      0  13c7					      db	"=",0
      1  13c7		       3d 00		      .byte.b	"=",0
      0  13c9					      LIT	6	;>=
      0  13c9					      db	27
      1  13c9		       1b		      .byte.b	27
      0  13ca					      dw	6
      1  13ca		       06 00		      .word.w	6
      0  13cc					      IJMP	iRFound
      0  13cc					      db	29
      1  13cc		       1d		      .byte.b	29
      0  13cd					      dw	iRFound
      1  13cd		       dc 13		      .word.w	iRFound
    317  13cf				   iR5
      0  13cf					      TST	iR6,"<"
      0  13cf					      db	32
      1  13cf		       20		      .byte.b	32
      0  13d0					      db	(iR6-*)-1
      1  13d0		       08		      .byte.b	(iR6-*)-1
      0  13d1					      db	"<",0
      1  13d1		       3c 00		      .byte.b	"<",0
      0  13d3					      LIT	1
      0  13d3					      db	27
      1  13d3		       1b		      .byte.b	27
      0  13d4					      dw	1
      1  13d4		       01 00		      .word.w	1
      0  13d6					      IJMP	iRFound	;(This line originally omitted)
      0  13d6					      db	29
      1  13d6		       1d		      .byte.b	29
      0  13d7					      dw	iRFound
      1  13d7		       dc 13		      .word.w	iRFound
    321  13d9				   iR6
      0  13d9					      LIT	4	;>
      0  13d9					      db	27
      1  13d9		       1b		      .byte.b	27
      0  13da					      dw	4
      1  13da		       04 00		      .word.w	4
    323  13dc				   iRFound
      0  13dc					      Call	EXPR2	; get the right side of the expression
      0  13dc					      db	28
      1  13dc		       1c		      .byte.b	28
      0  13dd					      dw	EXPR2
      1  13dd		       e1 13		      .word.w	EXPR2
      0  13df					      CMPR		; Push the value of the true false onto the stack
      0  13df					      db	10
      1  13df		       0a		      .byte.b	10
    326  13e0
    327  13e0				   iRDone
      0  13e0					      RTN
      0  13e0					      db	25
      1  13e0		       19		      .byte.b	25
    329  13e1
    330  13e1				   EXPR2
      0  13e1					      TST	E0,"-"	; Look for leading - to negate term
      0  13e1					      db	32
      1  13e1		       20		      .byte.b	32
      0  13e2					      db	(E0-*)-1
      1  13e2		       09		      .byte.b	(E0-*)-1
      0  13e3					      db	"-",0
      1  13e3		       2d 00		      .byte.b	"-",0
      0  13e5					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  13e5					      db	28
      1  13e5		       1c		      .byte.b	28
      0  13e6					      dw	TERM
      1  13e6		       0a 14		      .word.w	TERM
      0  13e8					      NEG		; Make value negated
      0  13e8					      db	16
      1  13e8		       10		      .byte.b	16
      0  13e9					      IJMP	E1	; We have Left term process operators next
      0  13e9					      db	29
      1  13e9		       1d		      .byte.b	29
      0  13ea					      dw	E1
      1  13ea		       f3 13		      .word.w	E1
    335  13ec				   E0
      0  13ec					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  13ec					      db	32
      1  13ec		       20		      .byte.b	32
      0  13ed					      db	(E1A-*)-1
      1  13ed		       02		      .byte.b	(E1A-*)-1
      0  13ee					      db	"+",0
      1  13ee		       2b 00		      .byte.b	"+",0
    337  13f0				   E1A
      0  13f0					      CALL	TERM	; Get the left term if it was not negated
      0  13f0					      db	28
      1  13f0		       1c		      .byte.b	28
      0  13f1					      dw	TERM
      1  13f1		       0a 14		      .word.w	TERM
    339  13f3				   E1
      0  13f3					      TST	E2,"+"	; Check if we are adding left term to something
      0  13f3					      db	32
      1  13f3		       20		      .byte.b	32
      0  13f4					      db	(E2-*)-1
      1  13f4		       09		      .byte.b	(E2-*)-1
      0  13f5					      db	"+",0
      1  13f5		       2b 00		      .byte.b	"+",0
      0  13f7					      CALL	TERM	; if adding then get the right side term
      0  13f7					      db	28
      1  13f7		       1c		      .byte.b	28
      0  13f8					      dw	TERM
      1  13f8		       0a 14		      .word.w	TERM
      0  13fa					      ADD		; Add it to left term
      0  13fa					      db	14
      1  13fa		       0e		      .byte.b	14
      0  13fb					      IJMP	E1	; look for next + or -
      0  13fb					      db	29
      1  13fb		       1d		      .byte.b	29
      0  13fc					      dw	E1
      1  13fc		       f3 13		      .word.w	E1
    344  13fe				   E2
      0  13fe					      TST	E3,"-"	; Check if we are subtractig something
      0  13fe					      db	32
      1  13fe		       20		      .byte.b	32
      0  13ff					      db	(E3-*)-1
      1  13ff		       09		      .byte.b	(E3-*)-1
      0  1400					      db	"-",0
      1  1400		       2d 00		      .byte.b	"-",0
      0  1402					      CALL	TERM	; get right side to subtract Diffrence
      0  1402					      db	28
      1  1402		       1c		      .byte.b	28
      0  1403					      dw	TERM
      1  1403		       0a 14		      .word.w	TERM
      0  1405					      SUB		; Subtract the value
      0  1405					      db	15
      1  1405		       0f		      .byte.b	15
      0  1406					      IJMP	E1	; Look for next + or -
      0  1406					      db	29
      1  1406		       1d		      .byte.b	29
      0  1407					      dw	E1
      1  1407		       f3 13		      .word.w	E1
    349  1409				   E3			; Finish processing the expression
      0  1409					      RTN		; We are finished processing the Expression
      0  1409					      db	25
      1  1409		       19		      .byte.b	25
    351  140a							;
    352  140a							; Get one of the terms of an expression
    353  140a							;
    354  140a				   TERM
      0  140a					      CALL	FACT	; Get a value
      0  140a					      db	28
      1  140a		       1c		      .byte.b	28
      0  140b					      dw	FACT
      1  140b		       32 14		      .word.w	FACT
    356  140d				   T0			; Check for higher precidence operators
      0  140d					      TST	T1,"*"	; Check for *
      0  140d					      db	32
      1  140d		       20		      .byte.b	32
      0  140e					      db	(T1-*)-1
      1  140e		       09		      .byte.b	(T1-*)-1
      0  140f					      db	"*",0
      1  140f		       2a 00		      .byte.b	"*",0
      0  1411					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1411					      db	28
      1  1411		       1c		      .byte.b	28
      0  1412					      dw	FACT
      1  1412		       32 14		      .word.w	FACT
      0  1414					      MUL		; Multiply factors
      0  1414					      db	17
      1  1414		       11		      .byte.b	17
      0  1415					      IJMP	T0	; Check for * or /
      0  1415					      db	29
      1  1415		       1d		      .byte.b	29
      0  1416					      dw	T0
      1  1416		       0d 14		      .word.w	T0
    361  1418				   T1
      0  1418					      TST	T2,"/"	; Check for a division
      0  1418					      db	32
      1  1418		       20		      .byte.b	32
      0  1419					      db	(T2-*)-1
      1  1419		       09		      .byte.b	(T2-*)-1
      0  141a					      db	"/",0
      1  141a		       2f 00		      .byte.b	"/",0
      0  141c					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  141c					      db	28
      1  141c		       1c		      .byte.b	28
      0  141d					      dw	FACT
      1  141d		       32 14		      .word.w	FACT
      0  141f					      DIV		; do division
      0  141f					      db	18
      1  141f		       12		      .byte.b	18
      0  1420					      IJMP	T0	; check for more * or /
      0  1420					      db	29
      1  1420		       1d		      .byte.b	29
      0  1421					      dw	T0
      1  1421		       0d 14		      .word.w	T0
    366  1423				   T2
      0  1423					      TST	T3,"%"	; Check for a division
      0  1423					      db	32
      1  1423		       20		      .byte.b	32
      0  1424					      db	(T3-*)-1
      1  1424		       09		      .byte.b	(T3-*)-1
      0  1425					      db	"%",0
      1  1425		       25 00		      .byte.b	"%",0
      0  1427					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1427					      db	28
      1  1427		       1c		      .byte.b	28
      0  1428					      dw	FACT
      1  1428		       32 14		      .word.w	FACT
      0  142a					      MODULO		; do division for remainder
      0  142a					      db	60
      1  142a		       3c		      .byte.b	60
      0  142b					      IJMP	T0	; check for more * or / or %
      0  142b					      db	29
      1  142b		       1d		      .byte.b	29
      0  142c					      dw	T0
      1  142c		       0d 14		      .word.w	T0
    371  142e				   T3			; Finish processing the Term
      0  142e					      RTN
      0  142e					      db	25
      1  142e		       19		      .byte.b	25
    373  142f
    374  142f				   UNKNOWNVEC
      0  142f					      IJMP	UNKNOWN
      0  142f					      db	29
      1  142f		       1d		      .byte.b	29
      0  1430					      dw	UNKNOWN
      1  1430		       93 13		      .word.w	UNKNOWN
    376  1432
    377  1432							;
    378  1432							; Factor an expression.  Always test for functions
    379  1432							; first or else they'll be confused for variables.
    380  1432							;
    381  1432				   FACT
      0  1432					      TST	F1A,"FREE()"
      0  1432					      db	32
      1  1432		       20		      .byte.b	32
      0  1433					      db	(F1A-*)-1
      1  1433		       09		      .byte.b	(F1A-*)-1
      0  1434					      db	"FREE()",0
      1  1434		       46 52 45 45*	      .byte.b	"FREE()",0
      0  143b					      FREE
      0  143b					      db	36
      1  143b		       24		      .byte.b	36
      0  143c					      RTN
      0  143c					      db	25
      1  143c		       19		      .byte.b	25
    385  143d				   F1A
      0  143d					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  143d					      db	32
      1  143d		       20		      .byte.b	32
      0  143e					      db	(F1A2-*)-1
      1  143e		       0a		      .byte.b	(F1A2-*)-1
      0  143f					      db	"GETCH()",0
      1  143f		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1447					      GETCHAR
      0  1447					      db	51
      1  1447		       33		      .byte.b	51
      0  1448					      RTN
      0  1448					      db	25
      1  1448		       19		      .byte.b	25
    389  1449				   F1A2
      0  1449					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1449					      db	32
      1  1449		       20		      .byte.b	32
      0  144a					      db	(F2AZ-*)-1
      1  144a		       0f		      .byte.b	(F2AZ-*)-1
      0  144b					      db	"PEEK(",0
      1  144b		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1451					      CALL	EXPR	;Get the address to write to
      0  1451					      db	28
      1  1451		       1c		      .byte.b	28
      0  1452					      dw	EXPR
      1  1452		       96 13		      .word.w	EXPR
      0  1454					      TST	UNKNOWN,")"	;Closing bracket
      0  1454					      db	32
      1  1454		       20		      .byte.b	32
      0  1455					      db	(UNKNOWN-*)-1
      1  1455		       3d		      .byte.b	(UNKNOWN-*)-1
      0  1456					      db	")",0
      1  1456		       29 00		      .byte.b	")",0
      0  1458					      PEEKMEM
      0  1458					      db	48
      1  1458		       30		      .byte.b	48
      0  1459					      RTN
      0  1459					      db	25
      1  1459		       19		      .byte.b	25
    395  145a				   F2AZ
      0  145a					      TST	F2A,"TASK("	;Check if we are setting a task start
      0  145a					      db	32
      1  145a		       20		      .byte.b	32
      0  145b					      db	(F2A-*)-1
      1  145b		       0f		      .byte.b	(F2A-*)-1
      0  145c					      db	"TASK(",0
      1  145c		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1462					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1462					      db	28
      1  1462		       1c		      .byte.b	28
      0  1463					      dw	EXPR
      1  1463		       96 13		      .word.w	EXPR
      0  1465					      TST	UNKNOWN,")"	;must be )
      0  1465					      db	32
      1  1465		       20		      .byte.b	32
      0  1466					      db	(UNKNOWN-*)-1
      1  1466		       2c		      .byte.b	(UNKNOWN-*)-1
      0  1467					      db	")",0
      1  1467		       29 00		      .byte.b	")",0
      0  1469					      SETTASK		;Set the Task up and start it
      0  1469					      db	62
      1  1469		       3e		      .byte.b	62
      0  146a					      RTN		;Returns the Task number
      0  146a					      db	25
      1  146a		       19		      .byte.b	25
    401  146b							;
    402  146b							; RND() is supposed to have an argument but if none
    403  146b							; was provided, just assume a large value.
    404  146b							;
    405  146b				   F2A
      0  146b					      TST	F2B,"RND("
      0  146b					      db	32
      1  146b		       20		      .byte.b	32
      0  146c					      db	(F2B-*)-1
      1  146c		       17		      .byte.b	(F2B-*)-1
      0  146d					      db	"RND(",0
      1  146d		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1472					      TST	F2A1,")"
      0  1472					      db	32
      1  1472		       20		      .byte.b	32
      0  1473					      db	(F2A1-*)-1
      1  1473		       07		      .byte.b	(F2A1-*)-1
      0  1474					      db	")",0
      1  1474		       29 00		      .byte.b	")",0
      0  1476					      LIT	32766
      0  1476					      db	27
      1  1476		       1b		      .byte.b	27
      0  1477					      dw	32766
      1  1477		       fe 7f		      .word.w	32766
      0  1479					      RANDOM
      0  1479					      db	37
      1  1479		       25		      .byte.b	37
      0  147a					      RTN
      0  147a					      db	25
      1  147a		       19		      .byte.b	25
    411  147b				   F2A1
      0  147b					      CALL	FACT	;GET RANGE
      0  147b					      db	28
      1  147b		       1c		      .byte.b	28
      0  147c					      dw	FACT
      1  147c		       32 14		      .word.w	FACT
      0  147e					      TST	UNKNOWN,")"
      0  147e					      db	32
      1  147e		       20		      .byte.b	32
      0  147f					      db	(UNKNOWN-*)-1
      1  147f		       13		      .byte.b	(UNKNOWN-*)-1
      0  1480					      db	")",0
      1  1480		       29 00		      .byte.b	")",0
      0  1482					      RANDOM
      0  1482					      db	37
      1  1482		       25		      .byte.b	37
      0  1483					      RTN
      0  1483					      db	25
      1  1483		       19		      .byte.b	25
    416  1484
    417  1484				   F2B
      0  1484					      TST	F2B2,"ABS("
      0  1484					      db	32
      1  1484		       20		      .byte.b	32
      0  1485					      db	(F2B2-*)-1
      1  1485		       0e		      .byte.b	(F2B2-*)-1
      0  1486					      db	"ABS(",0
      1  1486		       41 42 53 28*	      .byte.b	"ABS(",0
      0  148b					      CALL	FACT	;get value
      0  148b					      db	28
      1  148b		       1c		      .byte.b	28
      0  148c					      dw	FACT
      1  148c		       32 14		      .word.w	FACT
      0  148e					      TST	UNKNOWNVEC,")"
      0  148e					      db	32
      1  148e		       20		      .byte.b	32
      0  148f					      db	(UNKNOWNVEC-*)-1
      1  148f		       9f		      .byte.b	(UNKNOWNVEC-*)-1
      0  1490					      db	")",0
      1  1490		       29 00		      .byte.b	")",0
      0  1492					      ABS
      0  1492					      db	38
      1  1492		       26		      .byte.b	38
      0  1493					      RTN
      0  1493					      db	25
      1  1493		       19		      .byte.b	25
    423  1494
    424  1494				   F2B2
      0  1494					      TST	F2Z,"STAT("
      0  1494					      db	32
      1  1494		       20		      .byte.b	32
      0  1495					      db	(F2Z-*)-1
      1  1495		       0f		      .byte.b	(F2Z-*)-1
      0  1496					      db	"STAT(",0
      1  1496		       53 54 41 54*	      .byte.b	"STAT(",0
      0  149c					      Call	EXPR
      0  149c					      db	28
      1  149c		       1c		      .byte.b	28
      0  149d					      dw	EXPR
      1  149d		       96 13		      .word.w	EXPR
      0  149f					      TST	UNKNOWNVEC,")"
      0  149f					      db	32
      1  149f		       20		      .byte.b	32
      0  14a0					      db	(UNKNOWNVEC-*)-1
      1  14a0		       8e		      .byte.b	(UNKNOWNVEC-*)-1
      0  14a1					      db	")",0
      1  14a1		       29 00		      .byte.b	")",0
      0  14a3					      TASKSTAT
      0  14a3					      db	67
      1  14a3		       43		      .byte.b	67
      0  14a4					      RTN
      0  14a4					      db	25
      1  14a4		       19		      .byte.b	25
    430  14a5				   F2Z
      0  14a5					      TST	F2C,"CALL("	;call machine function
      0  14a5					      db	32
      1  14a5		       20		      .byte.b	32
      0  14a6					      db	(F2C-*)-1
      1  14a6		       1f		      .byte.b	(F2C-*)-1
      0  14a7					      db	"CALL(",0
      1  14a7		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  14ad					      CALL	EXPR
      0  14ad					      db	28
      1  14ad		       1c		      .byte.b	28
      0  14ae					      dw	EXPR
      1  14ae		       96 13		      .word.w	EXPR
      0  14b0					      TST	F2B2A,COMMA
      0  14b0					      db	32
      1  14b0		       20		      .byte.b	32
      0  14b1					      db	(F2B2A-*)-1
      1  14b1		       0b		      .byte.b	(F2B2A-*)-1
      0  14b2					      db	COMMA,0
      1  14b2		       2c 00		      .byte.b	COMMA,0
      0  14b4					      CALL	EXPR
      0  14b4					      db	28
      1  14b4		       1c		      .byte.b	28
      0  14b5					      dw	EXPR
      1  14b5		       96 13		      .word.w	EXPR
      0  14b7					      TST	UNKNOWNVEC,")"
      0  14b7					      db	32
      1  14b7		       20		      .byte.b	32
      0  14b8					      db	(UNKNOWNVEC-*)-1
      1  14b8		       76		      .byte.b	(UNKNOWNVEC-*)-1
      0  14b9					      db	")",0
      1  14b9		       29 00		      .byte.b	")",0
      0  14bb					      CALLFUNC
      0  14bb					      db	53
      1  14bb		       35		      .byte.b	53
      0  14bc					      RTN
      0  14bc					      db	25
      1  14bc		       19		      .byte.b	25
      0  14bd				   F2B2A      TST	UNKNOWNVEC,")"
      0  14bd					      db	32
      1  14bd		       20		      .byte.b	32
      0  14be					      db	(UNKNOWNVEC-*)-1
      1  14be		       70		      .byte.b	(UNKNOWNVEC-*)-1
      0  14bf					      db	")",0
      1  14bf		       29 00		      .byte.b	")",0
      0  14c1					      LIT	0
      0  14c1					      db	27
      1  14c1		       1b		      .byte.b	27
      0  14c2					      dw	0
      1  14c2		       00 00		      .word.w	0
      0  14c4					      CALLFUNC
      0  14c4					      db	53
      1  14c4		       35		      .byte.b	53
      0  14c5					      RTN
      0  14c5					      db	25
      1  14c5		       19		      .byte.b	25
    442  14c6				   F2C
      0  14c6					      TSTV	F0
      0  14c6					      db	33
      1  14c6		       21		      .byte.b	33
      0  14c7					      db	(F0-*)-1
      1  14c7		       0e		      .byte.b	(F0-*)-1
      0  14c8					      TST	F2C1,"["
      0  14c8					      db	32
      1  14c8		       20		      .byte.b	32
      0  14c9					      db	(F2C1-*)-1
      1  14c9		       0a		      .byte.b	(F2C1-*)-1
      0  14ca					      db	"[",0
      1  14ca		       5b 00		      .byte.b	"[",0
      0  14cc					      CALL	EXPR
      0  14cc					      db	28
      1  14cc		       1c		      .byte.b	28
      0  14cd					      dw	EXPR
      1  14cd		       96 13		      .word.w	EXPR
      0  14cf					      TST	UNKNOWNVEC,"]"
      0  14cf					      db	32
      1  14cf		       20		      .byte.b	32
      0  14d0					      db	(UNKNOWNVEC-*)-1
      1  14d0		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  14d1					      db	"]",0
      1  14d1		       5d 00		      .byte.b	"]",0
      0  14d3					      SUBSCRIPT
      0  14d3					      db	65
      1  14d3		       41		      .byte.b	65
    448  14d4				   F2C1
      0  14d4					      IND		;YES, GET THE VALUE.
      0  14d4					      db	20
      1  14d4		       14		      .byte.b	20
      0  14d5					      RTN
      0  14d5					      db	25
      1  14d5		       19		      .byte.b	25
    451  14d6				   F0
      0  14d6					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  14d6					      db	35
      1  14d6		       23		      .byte.b	35
      0  14d7					      db	(F1-*)-1
      1  14d7		       01		      .byte.b	(F1-*)-1
      0  14d8					      RTN
      0  14d8					      db	25
      1  14d8		       19		      .byte.b	25
    454  14d9				   F1
      0  14d9					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  14d9					      db	32
      1  14d9		       20		      .byte.b	32
      0  14da					      db	(F2A-*)-1
      1  14da		       90		      .byte.b	(F2A-*)-1
      0  14db					      db	"(",0
      1  14db		       28 00		      .byte.b	"(",0
      0  14dd					      CALL	EXPR
      0  14dd					      db	28
      1  14dd		       1c		      .byte.b	28
      0  14de					      dw	EXPR
      1  14de		       96 13		      .word.w	EXPR
      0  14e0					      TST	F2,")"
      0  14e0					      db	32
      1  14e0		       20		      .byte.b	32
      0  14e1					      db	(F2-*)-1
      1  14e1		       03		      .byte.b	(F2-*)-1
      0  14e2					      db	")",0
      1  14e2		       29 00		      .byte.b	")",0
      0  14e4					      RTN
      0  14e4					      db	25
      1  14e4		       19		      .byte.b	25
    459  14e5
    460  14e5				   F2
      0  14e5					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  14e5					      db	13
      1  14e5		       0d		      .byte.b	13
      0  14e6					      dw	ERR_SYNTAX
      1  14e6		       05 00		      .word.w	ERR_SYNTAX
    462  14e8
    463  14e8		       14 e8	   ILEND      equ	*
------- FILE mytb.asm
   2140  14e8		       14 e8	   PROGEND    equ	*
   2141  14e8
   2142  14e8							;=====================================================
   2143  14e8							;=====================================================
   2144  14e8							;=====================================================
   2145  14e8							; These are storage items not in page zero.
   2146  14e8							;
   2147 Udf9e					      seg.u	Data
   2148 U14e8					      org	PROGEND
   2149 U14e8							;
   2150 U14e8							; IRQ BASIC Code Service RTN Support
      0 U14e8				   SaveIrqReg db	0	; Store current setting
      1 U14e8		       00		      .byte.b	0
      0 U14e9				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U14e9		       00		      .byte.b	0
      0 U14ea				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U14ea		       00		      .byte.b	0
      0 U14eb				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U14eb		       00 00		      .byte.b	0,0
   2155 U14ed
   2156 U14ed							;
   2157 U14ed							;==================================================================================================
   2158 U14ed							; Task Management information
   2159 U14ed							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2160 U14ed							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2161 U14ed							; Task switchs happen at the beginning of the next Basic command line
   2162 U14ed							; It will not happen during an input or output operations
   2163 U14ed							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2164 U14ed							; Task Zero is always the root task, main line program
   2165 U14ed							;
   2166 U14ed		       00 00 00 00*taskTable  ds	TASKCOUNT*4	; Task Table Offset and pointer to Basic code, active flag
   2167 U1515		       00 00 00 00*taskGoStacks ds	TASKCOUNT*4	; Table of assigned gosub stack locations and pointers
   2168 U153d		       00	   taskPtr    ds	1	; Current offset into task table 0, 4, 8, 12 ...
   2169 U153e							;Task Cycle Counter and reset count
   2170 U153e		       00	   taskCurrentCycles ds	1
   2171 U153f		       00	   taskResetValue ds	1
   2172 U1540		       00	   taskCount  ds	1	; Count of active tasks
   2173 U1541							;
   2174 U1541							; Math stack and IL cal return stack definitions
   2175 U1541							;
   2176 U1541		       00 00 00 00*mathStack  ds	STACKSIZE*2	;Stack used for math expressions
   2177 U1569		       00	   mathStackPtr ds	1
   2178 U156a		       00 00 00 00*retStack   ds	ILSTACKSIZE*2	;stack used by the IL for calls and returns
   2179 U15ba		       00	   retStackPtr ds	1
   2180 U15bb
   2181 U15bb
   2182 U15bb
   2183 U15bb
   2184 U15bb							;
   2185 U15bb							;
   2186 U15bb		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2187 U163f		       00	   getlinx    ds	1
   2188 U1640		       00	   printtx    ds	1	;temp X for print funcs
   2189 U1641		       00	   diddigit   ds	1	;for leading zero suppression
   2190 U1642		       00	   putsy      ds	1
   2191 U1643		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2192 U1645		       00 00	   MQ	      ds	2	;used for some math
   2193 U1647		       00	   sign       ds	1	;0 = positive, else negative
   2194 U1648		       00 00	   rtemp1     ds	2	;Temp for x and y
   2195 U164a		       00 00	   random     ds	2
   2196 U164c		       00 00	   BOutVec    ds	2
   2197 U164e		       00	   tempy      ds	1	;temp y storage
   2198 U164f				  -	      if	XKIM
   2199 U164f				  -buffer     ds	BUFFER_SIZE
   2200 U164f					      endif
   2201 U164f							;
   2202 U164f							; PROGRAMEND is the end of the user's BASIC program.
   2203 U164f							; More precisely, it is one byte past the end.  Or,
   2204 U164f							; it's where the next line added to the end will be
   2205 U164f							; placed.
   2206 U164f							;
   2207 U164f		       00 00	   PROGRAMEND ds	2
   2208 U1651		       00 00	   HighMem    ds	2	;highest location
   2209 U1653		       00 00	   UsedMem    ds	2	;size of user program
   2210 U1655		       00 00	   FreeMem    ds	2	;amount of free memory
   2211 U1657							;
   2212 U1657							;=====================================================
   2213 U1657							; This is the start of the user's BASIC program space.
   2214 U1657							;
   2215 U1657							; PERSONAL GOAL: This should be no larger than $0DFF.
   2216 U1657							;		  0200-05FF = 1K
   2217 U1657							;		  0200-09FF = 2K
   2218 U1657							;		  0200-0DFF = 3K
   2219 U1657							;		  0200-11FF = 4K
   2220 U1657							;		  0200-13FF = 4.5K
   2221 U1657							;
   2222 U1657				  -	      if	FIXED
   2223 U1657				  -	      org	$2000
   2224 U1657					      endif
   2225 U1657		       16 57	   ProgramStart equ	*
   2226 U1657							;/*
   2227 U1657							;	if	CTMON65 || XKIM
   2228 U1657							;		SEG Code
   2229 U1657							;		org	AutoRun
   2230 U1657							;		dw	TBasicCold
   2231 U1657							;	endif
   2232 U1657							;*/
   2233 U1657					      end
