------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2fc9				   input      processor	6502
      2 U2fc9 ????						;=====================================================
      3 U2fc9 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2fc9 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2fc9 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2fc9 ????						;
      7 U2fc9 ????						; While working on the Corsham Technologies KIM Clone
      8 U2fc9 ????						; project, I wanted to include a TINY BASIC since that
      9 U2fc9 ????						; was a highly desirable feature of early computers.
     10 U2fc9 ????						;
     11 U2fc9 ????						; Rather than negotiating copyright issues for
     12 U2fc9 ????						; existing BASICs, I decided to just write one from
     13 U2fc9 ????						; scratch.
     14 U2fc9 ????						;
     15 U2fc9 ????						; 10/07/2017
     16 U2fc9 ????						;
     17 U2fc9 ????						; This implements a stripped down Tiny BASIC
     18 U2fc9 ????						; interpreter using the Interpretive Language (IL)
     19 U2fc9 ????						; method as described in the first few issues of
     20 U2fc9 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2fc9 ????						; to write various languages simply by changing the
     22 U2fc9 ????						; IL code rather than the interpreter itself.
     23 U2fc9 ????						;
     24 U2fc9 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2fc9 ????						;		* Fixed major bug in findLine that
     26 U2fc9 ????						;		  caused corrupted lines, crashes, etc.
     27 U2fc9 ????						;		* If no parameter given to RND, assume
     28 U2fc9 ????						;		  32766.
     29 U2fc9 ????						;		* No more error 5 when a program
     30 U2fc9 ????						;		  reaches the end without an END.
     31 U2fc9 ????						;
     32 U2fc9 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2fc9 ????						;		 * Unexpanded version to play with everything
     34 U2fc9 ????						;		 * Add some usefull system level functions
     35 U2fc9 ????						;		 * allow a larger number of tiny basic formats
     36 U2fc9 ????						;		 * Add byte at start of line holding length
     37 U2fc9 ????						;		   for faster execution of goto and gosub
     38 U2fc9 ????						;		 * Re-added gosub
     39 U2fc9 ????						;		 * allow ; or , at end if print stmt
     40 U2fc9 ????						;		   without CRLF being added.
     41 U2fc9 ????						;		 * Added extended function erase to
     42 U2fc9 ????						;		   use the extended ctmon65 rm file
     43 U2fc9 ????						;		 * Fix quoted text to not have to backtrack
     44 U2fc9 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2fc9 ????						;		 * Add concurrency features
     46 U2fc9 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U2fc9 ????						;
     48 U2fc9 ????						; www.corshamtech.com
     49 U2fc9 ????						; bob@corshamtech.com
     50 U2fc9 ????						; JustLostInTime@gmail.com
     51 U2fc9 ????						;
     52 U2fc9 ????						;=====================================================
     53 U2fc9 ????						;
     54 U2fc9 ????						; Create TRUE and FALSE values for conditionals.
     55 U2fc9 ????						;
     56 U2fc9 ????
     57 U2fc9 ????	       00 00	   FALSE      equ	0
     58 U2fc9 ????	       ff ff ff ff TRUE       equ	~FALSE
     59 U2fc9 ????						;
     60 U2fc9 ????						;---------------------------------------------------------
     61 U2fc9 ????						; One of these must be set to indicate which environment
     62 U2fc9 ????						; Tiny BASIC will be running in.  Here are the current
     63 U2fc9 ????						; environments:
     64 U2fc9 ????						;
     65 U2fc9 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     66 U2fc9 ????						; more K of RAM.
     67 U2fc9 ????						;
     68 U2fc9 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     69 U2fc9 ????						; which enhances, without replacing, the standard KIM
     70 U2fc9 ????						; monitor.  It gives access to routines to save/load files
     71 U2fc9 ????						; to a micro SD card.
     72 U2fc9 ????						;
     73 U2fc9 ????						; CTMON65 is a from-scratch monitor written for the
     74 U2fc9 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     75 U2fc9 ????						; easily be ported to other systems.  It has support for
     76 U2fc9 ????						; using a micro SD card for file storage/retrieval.
     77 U2fc9 ????						;
     78 U2fc9 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     79 U2fc9 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     80 U2fc9 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     81 U2fc9 ????
     82 U2fc9 ????						;
     83 U2fc9 ????						;   Need to define some macros for the dasm assembler
     84 U2fc9 ????						;
     85 U2fc9 ????				      MACRO	dw
     86 U2fc9 ????				      .word	{0}
     87 U2fc9 ????				      ENDM
     88 U2fc9 ????
     89 U2fc9 ????				      MACRO	db
     90 U2fc9 ????				      .byte	{0}
     91 U2fc9 ????				      ENDM
     92 U2fc9 ????
     93 U2fc9 ????						;
     94 U2fc9 ????						; If set, include disk functions.
     95 U2fc9 ????						;
     96 U2fc9 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2fc9 ????						;
     98 U2fc9 ????						; If ILTRACE is set then dump out the address of every
     99 U2fc9 ????						; IL opcode before executing it.
    100 U2fc9 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2fc9 ????						;
    102 U2fc9 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2fc9 ????						;
    104 U2fc9 ????						; If FIXED is set, put the IL code and the user
    105 U2fc9 ????						; program space at fixed locations in memory.	This is
    106 U2fc9 ????						; meant only for debugging.
    107 U2fc9 ????						;
    108 U2fc9 ????	       00 00	   FIXED      equ	FALSE
    109 U2fc9 ????						;
    110 U2fc9 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2fc9 ????						; BASIC, so keep this small!
    112 U2fc9 ????						;
    113 U2fc9 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2fc9 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2fc9 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2fc9 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2fc9 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    118 U2fc9 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2fc9 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2fc9 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2fc9 ????						;
    122 U2fc9 ????						; Gosub entry types
    123 U2fc9 ????
    124 U2fc9 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2fc9 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2fc9 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2fc9 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2fc9 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2fc9 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2fc9 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2fc9 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2fc9 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2fc9 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2fc9 ????						;
    135 U2fc9 ????						; Common ASCII constants
    136 U2fc9 ????						;
    137 U2fc9 ????	       00 07	   BEL	      equ	$07
    138 U2fc9 ????	       00 08	   BS	      equ	$08
    139 U2fc9 ????	       00 09	   TAB	      equ	$09
    140 U2fc9 ????	       00 0a	   LF	      equ	$0A
    141 U2fc9 ????	       00 0d	   CR	      equ	$0D
    142 U2fc9 ????	       00 22	   quote      equ	$22
    143 U2fc9 ????	       00 20	   SPACE      equ	$20
    144 U2fc9 ????	       00 2c	   COMMA      equ	',
    145 U2fc9 ????	       00 3b	   SEMICOLON  equ	';
    146 U2fc9 ????	       00 3a	   COLON      equ	':
    147 U2fc9 ????	       00 24	   DOLLAR     equ	'$
    148 U2fc9 ????						;
    149 U2fc9 ????						; These are error codes
    150 U2fc9 ????						;
    151 U2fc9 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2fc9 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2fc9 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2fc9 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2fc9 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2fc9 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2fc9 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2fc9 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2fc9 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2fc9 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2fc9 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2fc9 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2fc9 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2fc9 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2fc9 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2fc9 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2fc9 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2fc9 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2fc9 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2fc9 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    171 U2fc9 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    172 U2fc9 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    173 U2fc9 ????						;
    174 U2fc9 ????						;=====================================================
    175 U2fc9 ????						; Zero page storage.
    176 U2fc9 ????						;
    177 U00f6 ????				      SEG.U	ZEROPAGE
    178 U0040					      org	$0040
    179 U0040
    180 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    181 U0041
    182 U0041							; The context is used to locate a task switch
    183 U0041							; it copies from here till all task fields are saved/swapped
    184 U0041							; The max number of tasks is 256 / context length
    185 U0041							; All positions POS values are plus one task table incldues
    186 U0041							; a leading status byte .
    187 U0041							;
    188 U0041		       00 41	   CONTEXT    equ	*
    189 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    190 U0041
    191 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    192 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    193 U0043
    194 U0043		       00 00	   ILPC       ds	2	; IL program counter
    195 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    196 U0047		       00	   ILSTACKPTR ds	1
    197 U0048
    198 U0048
    199 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    200 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    201 U004a
    202 U004a
    203 U004a		       00	   MATHSTACKPTR ds	1
    204 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    205 U004b
    206 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    207 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT +1	; Get the offset to the gosub/msg stack
    208 U004d
    209 U004d
    210 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    211 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    212 U004e
    213 U004e
    214 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    215 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    216 U004f							;
    217 U004f							; CURPTR is a pointer to curent BASIC line being
    218 U004f							; executed.  Always points to start of line, CUROFF
    219 U004f							; is the offset to the current character.
    220 U004f							; The order of these fields is important
    221 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    222 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    223 U0052							;
    224 U0052							;The order of these fields in important
    225 U0052
    226 U0052							;
    227 U0052							; R0, R1 and MQ are used for arithmetic operations and
    228 U0052							; general use.
    229 U0052							;
    230 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    231 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    232 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    233 U0056		       00 00	   MQ	      ds	2	;used for some math
    234 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    235 U0058		       00 59	   REGISTERSEND equ	*
    236 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    237 U0059
    238 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    239 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    240 U0059
    241 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    242 U005b							;
    243 U005b							; This is zero if in immediate mode, or non-zero
    244 U005b							; if currently running a program.  Any input from
    245 U005b							; the main loop clears this, and the XFER IL
    246 U005b							; statement will set it.
    247 U005b							;
    248 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    249 U005c							;
    250 U005c							; Used for line insertion/removal.
    251 U005c							;
    252 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    253 U005e
    254 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    255 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    256 U005e							;
    257 U005e		       00 00	   PrtFrom    ds	2	; FROM
    258 U0060							;
    259 U0060							;=====================================================
    260 U0060							;Pointers for memory Management
    261 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    262 U0060							; Mem block format is
    263 U0060							;	 0-1   pointer to next block for free blocks
    264 U0060							;	 0-1   for allocated blocks
    265 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    266 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    267 U0060							;	 2-3   length constant for exevy type of memory block
    268 U0060							; Memory is recombined as it is released
    269 U0060							; The memory manager is not interupted durring allocation
    270 U0060							; or freeing of memory
    271 U0060							;====================================================
    272 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    273 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    274 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    275 U0066							;
    276 U0066							;=====================================================
    277 U0066							;
    278  261f ????				      SEG	Code
    279  0200					      org	$0200
    280  0200							;
    281  0200							; Cold start is at $0200.  Warm start is at $0203.
    282  0200							;
    283  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    284  0203		       4c 94 02    warm       jmp	warm2	;Entry point for worm restart
    285  0206							;
    286  0206							; These are the user-supplied vectors to I/O routines.
    287  0206							; If you want, you can just patch these in the binary
    288  0206							; file, but it would be better to change the source
    289  0206							; code.
    290  0206							;
    291  0206				  -	      if	KIM
    292  0206				  -OUTCH      jmp	$1ea0	;output char in A
    293  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    294  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    295  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    296  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    297  0206					      endif
    298  0206				  -	      if	XKIM
    299  0206				  -	      include	"xkim.inc"
    300  0206				  -	      SEG	Code
    301  0206				  -OUTCH      jmp	$1ea0
    302  0206				  -GETCH      jmp	xkGETCH
    303  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    304  0206				  -OUTHEX     jmp	xkPRTBYT
    305  0206				  -MONITOR    jmp	extKIM
    306  0206				  -puts       equ	putsil
    307  0206				  -BUFFER_SIZE equ	132
    308  0206					      endif
    309  0206
    310  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    312 Udf8e
    313  0206					      SEG	Code
    314  0206							;
    315  0206		       f0 0c	   OUTCH      equ	cout
    316  0206		       f0 09	   GETCH      equ	cin
    317  0206		       1e 74	   CRLF       equ	tbcrlf
    318  0206		       14 28	   OUTHEX     equ	HexToOut
    319  0206		       f0 03	   MONITOR    equ	WARM
    320  0206		       f0 0f	   ISCHAR     equ	cstatus
    321  0206		       14 45	   puts       equ	tbputs
    322  0206					      endif
    323  0206							;
    324  0206		       20 a8 1f    cold2      jsr	SetOutConsole
    325  0209		       20 b5 1f 	      jsr	SetInConsole
    326  020c		       20 45 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    330  0244							;
    331  0244		       20 39 16 	      jsr	MemInit	;setup the free space available
    332  0247
    333  0247		       a9 01	   calcstack  lda	#1
    334  0249		       8d 65 27 	      sta	taskCounter	; Initialize number of tasks to 1
    335  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    336  024e		       8d 67 26 	      sta	taskTable	; mark the main task as active
    337  0251		       20 26 17 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    338  0254		       a9 9e		      lda	#IL&$ff
    339  0256		       85 43		      sta	ILPC
    340  0258		       a9 22		      lda	#IL>>8
    341  025a		       85 44		      sta	ILPC+1
    342  025c							;
    343  025c							;		  lda	  ProgramStart		     ; user prog
    344  025c							;		  sta	  ProgramEnd
    345  025c							;		  lda	  ProgramStart+1
    346  025c							;		  sta	  ProgramEnd+1
    347  025c							;
    348  025c
    349  025c							;  Init time slices defaults
    350  025c		       a9 02		      lda	#TASKCYCLESHIGH
    351  025e		       8d 64 27 	      sta	taskResetValue+1
    352  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    353  0263		       8d 63 27 	      sta	taskResetValue
    354  0266							;
    355  0266							; Initialize the pseudo-random number sequence...
    356  0266							;
    357  0266		       a9 5a		      lda	#$5a
    358  0268		       8d af 2f 	      sta	rtemp1
    359  026b		       a9 9d		      lda	#%10011101
    360  026d		       8d b1 2f 	      sta	random
    361  0270		       a9 5b		      lda	#%01011011
    362  0272		       8d b2 2f 	      sta	random+1
    363  0275							;
    364  0275							;   Insert a Basic irq handler for the basic Language
    365  0275		       a9 82		      lda	#ServiceIrq&$ff
    366  0277		       8d 00 df 	      sta	IRQvec
    367  027a		       a9 02		      lda	#ServiceIrq>>8
    368  027c		       8d 01 df 	      sta	IRQvec+1
    369  027f		       4c a7 02 	      jmp	coldtwo
    370  0282
    371  0282							;
    372  0282							; This is the Basic IRQ handler
    373  0282		       48	   ServiceIrq pha
    374  0283		       ad 62 26 	      lda	IRQStatus
    375  0286		       f0 0a		      BEQ	RetIrq
    376  0288		       ad 63 26 	      lda	IRQPending
    377  028b		       d0 05		      bne	RetIrq
    378  028d		       a9 01		      lda	#1
    379  028f		       8d 63 26 	      sta	IRQPending
    380  0292		       68	   RetIrq     pla
    381  0293		       40		      rti
    382  0294							;
    383  0294							;
    384  0294							; This is the warm start entry point
    385  0294							;
    386  0294		       20 a8 1f    warm2      jsr	SetOutConsole
    387  0297		       20 b5 1f 	      jsr	SetInConsole
    388  029a		       20 74 1e 	      jsr	CRLF
    389  029d		       ad ac 2f 	      lda	errGoto
    390  02a0		       85 43		      sta	ILPC
    391  02a2		       ad ad 2f 	      lda	errGoto+1
    392  02a5		       85 44		      sta	ILPC+1
    393  02a7							;
    394  02a7							; And continue with both starts here
    395  02a7							;
    396  02a7				   coldtwo
    397  02a7							;
    398  02a7							; The ILTrace flag is now run-time settable.
    399  02a7							;
    400  02a7		       a9 00		      lda	#ILTRACE&$ff
    401  02a9		       85 40		      sta	ILTrace
    402  02ab							;
    403  02ab
    404  02ab		       a9 00		      lda	#0
    405  02ad		       85 5b		      sta	RunMode
    406  02af		       8d 22 2f 	      sta	LINBUF
    407  02b2
    408  02b2							; Clear everything from the stacks
    409  02b2
    410  02b2		       8d bd 2f 	      sta	taskIOPending	; No one waiting for io
    411  02b5		       8d be 2f 	      sta	taskRDPending	; No one waiting for bg io
    412  02b8
    413  02b8		       20 99 17 	      jsr	taskReset
    414  02bb							;
    415  02bb		       a9 22		      lda	#LINBUF&$ff
    416  02bd		       85 4f		      sta	CURPTR
    417  02bf		       a9 2f		      lda	#LINBUF>>8
    418  02c1		       85 50		      sta	CURPTR+1	;fall through...
    419  02c3
    420  02c3							;=====================================================
    421  02c3							; This is the top of the IL interpreter.  This fetches
    422  02c3							; and executes the instruction currently pointed to
    423  02c3							; by ILPC and adjusts ILPC to point to the next
    424  02c3							; instruction to execute.
    425  02c3							;
    426  02c3				   NextIL
    427  02c3		       ba		      tsx		; Get the stack pointer value
    428  02c4		       e0 ff		      cpx	#$FF	; Should be empty
    429  02c6		       d0 26		      bne	ILbad	; Halt and catch fire now!
    430  02c8
    431  02c8		       ce 61 27 	      dec	taskCurrentCycles
    432  02cb		       d0 03		      bne	NextIlNow
    433  02cd		       20 c2 17 	      jsr	iTaskSwitch	;check for a task switch
    434  02d0		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    435  02d2		       f0 03		      beq	NextIL2	;Skip if no bits set
    436  02d4
    437  02d4		       20 05 1f 	      jsr	dbgLine	;Print the IL trace information
    438  02d7
    439  02d7		       a4 51	   NextIL2    ldy	CUROFF
    440  02d9							;		  jsr	  SkipSpaces
    441  02d9							;		  sty	  CUROFF
    442  02d9							;Task IO Management
    443  02d9		       ad be 2f 	      lda	taskRDPending	; if it is zero then Nothing pending
    444  02dc		       f0 08		      beq	NextILStr
    445  02de		       20 ad 1c 	      jsr	ReadLine	; else Pending and poll keyboard
    446  02e1		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    447  02e3		       ce be 2f 	      dec	taskRDPending	; Carry is set if CR has been recieved
    448  02e6							;
    449  02e6		       20 30 1b    NextILStr  jsr	getILByte
    450  02e9							;
    451  02e9							; When the handler is called, these are the conditions
    452  02e9							; of several important items:
    453  02e9							;
    454  02e9							;    (ILPC) will point to the byte AFTER the IL
    455  02e9							;    opcode being executed.
    456  02e9							;
    457  02e9							;    (CURPTR),CUROFF will point to the start of the
    458  02e9							;    next word in the input buffer.  Ie, the next word
    459  02e9							;    in the user program.
    460  02e9							;
    461  02e9		       0a		      asl
    462  02ea		       c9 dc		      cmp	#ILTBLend-ILTBL+2
    463  02ec		       90 33		      bcc	ILgood
    464  02ee							;
    465  02ee							; This handles an illegal IL opcode.  This is serious
    466  02ee							; and there's no way to recover.
    467  02ee							;
    468  02ee		       20 45 14    ILbad      jsr	puts
      0  02f1					      db	CR,LF
      1  02f1		       0d 0a		      .byte.b	CR,LF
      0  02f3					      db	"Illegal IL "
      1  02f3		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02fe					      db	0
      1  02fe		       00		      .byte.b	0
    472  02ff							;
    473  02ff							; Well this is awkward, we need to back up the IL
    474  02ff							; by one since it no longer points to the current
    475  02ff							; opcode.
    476  02ff							;
    477  02ff		       20 3d 1b 	      jsr	decIL
    478  0302							;
    479  0302		       a0 00		      ldy	#0
    480  0304		       b1 43		      lda	(ILPC),y
    481  0306		       20 28 14 	      jsr	OUTHEX
    482  0309		       20 45 14 	      jsr	puts
      0  030c					      db	" at ",0
      1  030c		       20 61 74 20*	      .byte.b	" at ",0
    484  0311		       a5 44		      lda	ILPC+1
    485  0313		       20 28 14 	      jsr	OUTHEX
    486  0316		       a5 43		      lda	ILPC
    487  0318		       20 28 14 	      jsr	OUTHEX
    488  031b		       20 74 1e 	      jsr	CRLF
    489  031e		       4c 03 f0 	      jmp	MONITOR
    490  0321							;
    491  0321							; Just jump to the address (ILPC),y.  Have to do
    492  0321							; some goofy stuff.
    493  0321							;
    494  0321		       a8	   ILgood     tay		;move index into Y
    495  0322		       b9 2f 03 	      lda	ILTBL,y
    496  0325		       85 59		      sta	dpl
    497  0327		       b9 30 03 	      lda	ILTBL+1,y
    498  032a		       85 5a		      sta	dpl+1
    499  032c		       6c 59 00 	      jmp	(dpl)	;go to handler
    500  032f							;
    501  032f							;=====================================================
    502  032f							; This is the IL jump table.  The IL opcode is
    503  032f							; mulitplied by two, then looked-up in this table.
    504  032f							; There is absolutely nothing special about the order
    505  032f							; of entries here... they all decode at exactly the
    506  032f							; same speed.	However the entry number must match the
    507  032f							; values in IL.inc.
    508  032f							;
    509  032f				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  032f					      include	"ilvectortable.asm"
      1  032f					      seg	Code
      2  032f
      0  032f					      dw	iXINIT	;0
      1  032f		       41 04		      .word.w	iXINIT
      0  0331					      dw	iDONE	;1
      1  0331		       5c 04		      .word.w	iDONE
      0  0333					      dw	iPRS	;2
      1  0333		       73 04		      .word.w	iPRS
      0  0335					      dw	iPRN	;3
      1  0335		       7b 04		      .word.w	iPRN
      0  0337					      dw	iSPC	;4
      1  0337		       84 04		      .word.w	iSPC
      0  0339					      dw	iNLINE	;5
      1  0339		       3f 09		      .word.w	iNLINE
      0  033b					      dw	iNXT	;6
      1  033b		       8c 04		      .word.w	iNXT
      0  033d					      dw	iXFER	;7
      1  033d		       ce 04		      .word.w	iXFER
      0  033f					      dw	iSAV	;8
      1  033f		       ec 04		      .word.w	iSAV
      0  0341					      dw	iRSTR	;9
      1  0341		       32 05		      .word.w	iRSTR
      0  0343					      dw	iCMPR	;10
      1  0343		       80 05		      .word.w	iCMPR
      0  0345					      dw	iINNUM	;11
      1  0345		       ff 05		      .word.w	iINNUM
      0  0347					      dw	iFIN	;12
      1  0347		       37 06		      .word.w	iFIN
      0  0349					      dw	iERR	;13
      1  0349		       4b 06		      .word.w	iERR
      0  034b					      dw	iADD	;14
      1  034b		       c5 06		      .word.w	iADD
      0  034d					      dw	iSUB	;15
      1  034d		       db 06		      .word.w	iSUB
      0  034f					      dw	iNEG	;16
      1  034f		       f1 06		      .word.w	iNEG
      0  0351					      dw	iMUL	;17
      1  0351		       09 07		      .word.w	iMUL
      0  0353					      dw	iDIV	;18
      1  0353		       49 07		      .word.w	iDIV
      0  0355					      dw	iSTORE	;19
      1  0355		       9f 07		      .word.w	iSTORE
      0  0357					      dw	iIND	;20
      1  0357		       b7 07		      .word.w	iIND
      0  0359					      dw	iLST	;21
      1  0359		       35 08		      .word.w	iLST
      0  035b					      dw	iINIT	;22
      1  035b		       09 04		      .word.w	iINIT
      0  035d					      dw	iGETLINE	;23
      1  035d		       6b 08		      .word.w	iGETLINE
      0  035f					      dw	iINSRT	;24
      1  035f		       88 08		      .word.w	iINSRT
      0  0361					      dw	iRTN	;25
      1  0361		       39 09		      .word.w	iRTN
      0  0363					      dw	MONITOR	;26
      1  0363		       03 f0		      .word.w	MONITOR
      0  0365					      dw	iLIT	;27
      1  0365		       5f 09		      .word.w	iLIT
      0  0367					      dw	iCALL	;28
      1  0367		       45 09		      .word.w	iCALL
      0  0369					      dw	iJMP	;29
      1  0369		       4d 09		      .word.w	iJMP
      0  036b					      dw	iVINIT	;30
      1  036b		       7c 09		      .word.w	iVINIT
      0  036d					      dw	iERRGOTO	;31
      1  036d		       85 09		      .word.w	iERRGOTO
      0  036f					      dw	iTST	;32
      1  036f		       91 09		      .word.w	iTST
      0  0371					      dw	iTSTV	;33
      1  0371		       b6 0a		      .word.w	iTSTV
      0  0373					      dw	iTSTL	;34
      1  0373		       3a 0b		      .word.w	iTSTL
      0  0375					      dw	iTSTN	;35
      1  0375		       55 0b		      .word.w	iTSTN
      0  0377					      dw	iFREE	;36
      1  0377		       06 0c		      .word.w	iFREE
      0  0379					      dw	iRANDOM	;37
      1  0379		       0f 0c		      .word.w	iRANDOM
      0  037b					      dw	iABS	;38
      1  037b		       e0 0c		      .word.w	iABS
     42  037d							;
     43  037d							; Disk functions.  There must be pointers
     44  037d							; to functions even if no disk is supported.
     45  037d							; Makes things easier in IL.inc.
     46  037d							;
     47  037d					      if	DISK_ACCESS
      0  037d					      dw	iOPENREAD	;39
      1  037d		       f8 20		      .word.w	iOPENREAD
      0  037f					      dw	iOPENWRITE	;40
      1  037f		       59 21		      .word.w	iOPENWRITE
      0  0381					      dw	iDCLOSE	;41
      1  0381		       dd 21		      .word.w	iDCLOSE
      0  0383					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0383		       6b 21		      .word.w	iDGETLINE
      0  0385					      dw	iDLIST	;43 Did you remember your towel?
      1  0385		       d7 21		      .word.w	iDLIST
      0  0387					      dw	iDDIR	;44
      1  0387		       b2 21		      .word.w	iDDIR
      0  0389					      dw	iRMFILE	;45
      1  0389		       47 21		      .word.w	iRMFILE
     55  038b				  -	      else
     56  038b				  -	      dw	NextIL	;39
     57  038b				  -	      dw	NextIL	;40
     58  038b				  -	      dw	NextIL	;41
     59  038b				  -	      dw	NextIL	;42
     60  038b				  -	      dw	NextIL	;43
     61  038b				  -	      dw	NextIL	;44
     62  038b				  -	      dw	NextIL	;45
     63  038b					      endif
     64  038b							;
      0  038b					      dw	iCLEARSCREEN	;46
      1  038b		       c8 1f		      .word.w	iCLEARSCREEN
      0  038d					      dw	iPOKEMEMORY	;47
      1  038d		       6d 0c		      .word.w	iPOKEMEMORY
      0  038f					      dw	iPEEKMEMORY	;48
      1  038f		       82 0c		      .word.w	iPEEKMEMORY
      0  0391					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0391		       d8 09		      .word.w	iTSTLET
      0  0393					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0393		       5d 0a		      .word.w	iTSTDONE
      0  0395					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0395		       af 0c		      .word.w	iGETCHAR
      0  0397					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0397		       c3 0c		      .word.w	iPUTCHAR
      0  0399					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0399		       98 0c		      .word.w	iCallFunc
      0  039b					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  039b		       cd 05		      .word.w	iBranch
      0  039d					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  039d		       bb 09		      .word.w	iTSTStr
      0  039f					      dw	iSetIrq	;56	   sets the irq handler
      1  039f		       5d 0d		      .word.w	iSetIrq
      0  03a1					      dw	iTstIrq	;57	   test if irq is pending
      1  03a1		       cc 0b		      .word.w	iTstIrq
      0  03a3					      dw	iRET	;58	   return from interupt
      1  03a3		       20 05		      .word.w	iRET
      0  03a5					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03a5		       18 06		      .word.w	iINSTR
      0  03a7					      dw	iMOD	;60	   returns remainder of division
      1  03a7		       52 07		      .word.w	iMOD
      0  03a9					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a9		       16 18		      .word.w	iTaskSet
      0  03ab					      dw	iETask	;62	   Terminates a task
      1  03ab		       53 19		      .word.w	iETask
      0  03ad					      dw	iNTask	;63	   goto next task
      1  03ad		       06 19		      .word.w	iNTask
      0  03af					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03af		       cc 07		      .word.w	iArray
      0  03b1					      dw	iTaskKill	;65	   kill a running task
      1  03b1		       fe 18		      .word.w	iTaskKill
      0  03b3					      dw	iTaskStat	;66	   return the state of a task PID
      1  03b3		       d2 18		      .word.w	iTaskStat
      0  03b5					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03b5		       ce 0c		      .word.w	iHexOut
      0  03b7					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b7		       e9 05		      .word.w	iReadComplete
      0  03b9					      dw	iReadStart	;69	   Called to start a background read request
      1  03b9		       df 05		      .word.w	iReadStart
      0  03bb					      dw	iStartIO	;70	   Lock task until io complete
      1  03bb		       36 19		      .word.w	iStartIO
      0  03bd					      dw	iEndIO	;71	   release task lock for io
      1  03bd		       3c 19		      .word.w	iEndIO
      0  03bf					      dw	iLogNot	;72	   Logical not
      1  03bf		       39 0d		      .word.w	iLogNot
      0  03c1					      dw	iLogOr	;73	   Logical Or
      1  03c1		       0f 0d		      .word.w	iLogOr
      0  03c3					      dw	iLogAnd	;74	   Logical And
      1  03c3		       fa 0c		      .word.w	iLogAnd
      0  03c5					      dw	iLogXor	;75	   Logical Xor
      1  03c5		       24 0d		      .word.w	iLogXor
      0  03c7					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c7		       11 19		      .word.w	iWTASK
      0  03c9					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c9		       47 19		      .word.w	iTASKPID
      0  03cb					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03cb		       9b 0d		      .word.w	iTRACEPROG
      0  03cd					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03cd		       81 1e		      .word.w	idbgBasic
      0  03cf					      dw	iIPCS	;80	   Sending a msg to a task
      1  03cf		       09 1a		      .word.w	iIPCS
      0  03d1					      dw	iIPCR	;81	   Recieve a message from a task
      1  03d1		       20 1a		      .word.w	iIPCR
      0  03d3					      dw	iIPCC	;82	   Check if any message available for task
      1  03d3		       34 1a		      .word.w	iIPCC
      0  03d5					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03d5		       41 1a		      .word.w	iIPCIO
      0  03d7					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d7		       8e 16		      .word.w	iPushMathStack
      0  03d9					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d9		       be 16		      .word.w	iPopMathStack
      0  03db					      dw	iSaveMathStack	;86	   Save all math info
      1  03db		       db 16		      .word.w	iSaveMathStack
      0  03dd					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03dd		       fa 16		      .word.w	iRestoreMathStack
      0  03df					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03df		       ab 16		      .word.w	iIncParmCount
      0  03e1					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03e1		       73 19		      .word.w	iTaskGetMathStack
      0  03e3					      dw	iTaskEnable	;90	   enable a suspended task
      1  03e3		       a0 18		      .word.w	iTaskEnable
      0  03e5					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03e5		       ba 18		      .word.w	iTaskSuspend
      0  03e7					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e7		       8d 19		      .word.w	iTaskPutMathPtr
      0  03e9					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e9		       ad 0a		      .word.w	iTSTVT
      0  03eb					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03eb		       57 09		      .word.w	iSetR2
      0  03ed					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03ed		       fe 04		      .word.w	iStk2Tmp
      0  03ef					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03ef		       0f 05		      .word.w	iTmp2Stk
      0  03f1					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03f1		       f9 09		      .word.w	iTSTBYTE
      0  03f3					      dw	iINCVAR	;98	   Increment variable
      1  03f3		       7f 0a		      .word.w	iINCVAR
      0  03f5					      dw	iDECVAR	;99	   Decrement variable
      1  03f5		       97 0a		      .word.w	iDECVAR
      0  03f7					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f7		       9c 19		      .word.w	iSLICE
      0  03f9					      dw	iTSTB	;101	   Test if byte equals
      1  03f9		       18 0a		      .word.w	iTSTB
      0  03fb					      dw	iTSTW	;102	   Test If word equals
      1  03fb		       33 0a		      .word.w	iTSTW
      0  03fd					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03fd		       dc 12		      .word.w	iOnGoto
      0  03ff					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03ff		       0d 13		      .word.w	iTSTRELOP
      0  0401					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  0401		       b2 04		      .word.w	iRepeatLine
      0  0403					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch is is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  0403		       34 13		      .word.w	iTSTBRANCH
      0  0405					      dw	iFastXfer	;107	   move top of stack to curptr
      1  0405		       b9 04		      .word.w	iFastXfer
      0  0407					      dw	iSetTerminal	;108	   Set the Io Treminal to be used by print and input statements
      1  0407		       3e 20		      .word.w	iSetTerminal
    128  0409
------- FILE mytb.asm
    511  0409		       04 09	   ILTBLend   equ	*
    512  0409							;
    513  0409							;=====================================================
    514  0409							;=====================================================
    515  0409							;=====================================================
    516  0409							; This marks the start of the handlers for IL opcodes.
    517  0409							;=====================================================
    518  0409							;=====================================================
    519  0409							;=====================================================
    520  0409							;
    521  0409							;
    522  0409		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    523  040b		       85 47		      sta	ILSTACKPTR
    524  040d		       85 4a		      sta	MATHSTACKPTR
    525  040f		       85 4d		      sta	GOSUBSTACKPTR
    526  0411		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    527  0413		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    528  0415							;
    529  0415		       ad bf 2f 	      lda	ProgramStart	; user prog
    530  0418		       85 4f		      sta	CURPTR
    531  041a		       8d 68 26 	      sta	taskTable+1
    532  041d		       8d c1 2f 	      sta	ProgramEnd
    533  0420		       ad c0 2f 	      lda	ProgramStart+1
    534  0423		       85 50		      sta	CURPTR+1
    535  0425		       8d 69 26 	      sta	taskTable+2
    536  0428		       8d c2 2f 	      sta	ProgramEnd+1
    537  042b		       a9 80		      lda	#TASKACTIVE
    538  042d		       8d 67 26 	      sta	taskTable	;Mark the first slot as active
    539  0430		       a9 01		      lda	#1
    540  0432		       8d 65 27 	      sta	taskCounter	;there is always one task / Main task
    541  0435		       ad 63 27 	      lda	taskResetValue
    542  0438		       8d 61 27 	      sta	taskCurrentCycles	; set up the task switch counts
    543  043b		       ad 64 27 	      lda	taskResetValue+1
    544  043e		       8d 62 27 	      sta	taskCurrentCycles+1
    545  0441							;
    546  0441							; fall into XINIT...
    547  0441							;
    548  0441							;=====================================================
    549  0441							; This initializes for the start of the next line of
    550  0441							; BASIC text.
    551  0441							;
    552  0441		       78	   iXINIT     sei		;ensure interupts are off
    553  0442		       20 99 17 	      jsr	taskReset	;Clear the task table
    554  0445		       8d 63 26 	      sta	IRQPending	; reset the irq pending
    555  0448		       8d 62 26 	      sta	IRQStatus	; Make sure irqs are off
    556  044b
    557  044b		       4c c3 02    goodExit   jmp	NextIL
    558  044e							;
    559  044e							;=====================================================
    560  044e							; This check if the escape key has been entered
    561  044e							; then changes out of run mode. z Set if esc found
    562  044e				   BreakSet
    563  044e		       20 0f f0 	      jsr	ISCHAR
    564  0451		       f0 06		      beq	BreakNo
    565  0453		       20 c5 1f 	      jsr	VGETCH
    566  0456		       c9 1b		      cmp	#$1B
    567  0458		       60		      rts
    568  0459				   BreakNo
    569  0459		       a9 01		      lda	#1
    570  045b		       60		      rts
    571  045c
    572  045c							;
    573  045c
    574  045c							;=====================================================
    575  045c							; Verify there is nothing else on this input line.
    576  045c							; If there is, generate an error.
    577  045c							;
    578  045c		       a4 51	   iDONE      ldy	CUROFF
    579  045e		       b1 4f		      lda	(CURPTR),y
    580  0460		       f0 0e		      beq	doneadv
    581  0462		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    582  0464		       d0 03		      bne	idoneErr
    583  0466							;		  sty	  CUROFF
    584  0466		       4c c3 02 	      jmp	NextIL	; continue on this line
    585  0469
    586  0469				   idoneErr
    587  0469		       a2 04		      ldx	#ERR_EXTRA_STUFF
    588  046b		       a9 00		      lda	#0
    589  046d		       4c aa 06 	      jmp	iErr2
    590  0470							;
    591  0470							; Advance to the next line
    592  0470							;
    593  0470				   doneadv
    594  0470		       4c c3 02 	      jmp	NextIL
    595  0473							;
    596  0473							;=====================================================
    597  0473							; Print the string until a closing quote
    598  0473							;
    599  0473				   iPRS
    600  0473		       20 68 14 	      jsr	PrtQuoted
    601  0476		       84 51		      sty	CUROFF
    602  0478		       4c c3 02 	      jmp	NextIL
    603  047b							;
    604  047b							;=====================================================
    605  047b							; Pop the top off the stack and print it as a signed
    606  047b							; decimal number.
    607  047b							;
    608  047b				   iPRN
    609  047b		       20 bb 1d 	      jsr	popR0
    610  047e		       20 76 13 	      jsr	PrintDecimal
    611  0481		       4c c3 02 	      jmp	NextIL
    612  0484							;
    613  0484							;=====================================================
    614  0484							; Space to next zone.	Currently the code does not
    615  0484							; keep track of which column the output is on, so
    616  0484							; just print a tab.
    617  0484							;
    618  0484				   iSPC
    619  0484		       a9 09		      lda	#TAB
    620  0486		       20 c2 1f 	      jsr	VOUTCH
    621  0489		       4c c3 02 	      jmp	NextIL
    622  048c							;
    623  048c							;=====================================================
    624  048c							; If in immediate mode, jump to the address following
    625  048c							; the NXT instruction.  Else move to the next line of
    626  048c							; user code and continue.
    627  048c							;
    628  048c		       a5 5b	   iNXT       lda	RunMode
    629  048e		       d0 03		      bne	iNxtRun	;in run mode
    630  0490							;
    631  0490							; Get address and jump to it.
    632  0490							;
    633  0490		       4c 4d 09 	      jmp	iJMP
    634  0493							;
    635  0493				   iNxtRun
    636  0493		       a4 51		      ldy	CUROFF
    637  0495		       b1 4f		      lda	(CURPTR),y
    638  0497		       c9 e6		      cmp	#oColon
    639  0499		       d0 06		      bne	iNxtRunGo
    640  049b		       c8		      iny
    641  049c		       84 51		      sty	CUROFF
    642  049e		       4c ac 04 	      jmp	iNxtRun2
    643  04a1
    644  04a1				   iNxtRunGo
    645  04a1		       20 ba 1b 	      jsr	FindNextLine
    646  04a4		       20 ce 1b 	      jsr	AtEnd
    647  04a7		       d0 03		      bne	iNxtRun2	;not at end
    648  04a9							;
    649  04a9							; At the end of the program.  Pretend an END statement
    650  04a9							; was found.
    651  04a9							;
    652  04a9		       4c 37 06    iFINv      jmp	iFIN
    653  04ac							;
    654  04ac		       20 2c 1b    iNxtRun2   jsr	getILWord	;ignore next word
    655  04af		       4c c3 02 	      jmp	NextIL
    656  04b2							;=====================================================
    657  04b2							;Repeat the same line against
    658  04b2		       a0 03	   iRepeatLine ldy	#3
    659  04b4		       84 51		      sty	CUROFF
    660  04b6		       4c c3 02 	      jmp	NextIL
    661  04b9							;
    662  04b9							;=====================================================
    663  04b9							; XFER takes the number on top of the stack and looks
    664  04b9							; for that line in the program, or the next line
    665  04b9							; higher.  Ie, if it's 1 but there is no line 1, then
    666  04b9							; find the next one after that.
    667  04b9							;
    668  04b9				   iFastXfer
    669  04b9		       20 d3 1d 	      jsr	popR1	; get type of transfer
    670  04bc		       a5 54		      lda	R1
    671  04be		       f0 0e		      beq	iXFER
    672  04c0
    673  04c0		       20 bb 1d 	      jsr	popR0	; get where to transfer
    674  04c3		       a5 52		      lda	R0
    675  04c5		       85 4f		      sta	CURPTR
    676  04c7		       a5 53		      lda	R0+1
    677  04c9		       85 50		      sta	CURPTR+1
    678  04cb		       4c d4 04 	      jmp	iXFER2
    679  04ce
    680  04ce				   iXFER
    681  04ce		       20 bb 1d 	      jsr	popR0
    682  04d1		       20 75 1b 	      jsr	findLine
    683  04d4
    684  04d4				   iXFER2
    685  04d4		       20 ce 1b 	      jsr	AtEnd	;at end of user program?
    686  04d7		       f0 d0		      beq	iFINv
    687  04d9
    688  04d9		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    689  04db		       84 51		      sty	CUROFF
    690  04dd
    691  04dd							;		  lda	  #$ff
    692  04dd							;		  sta	  RunMode
    693  04dd							;
    694  04dd							; Transfer IL to STMT.  I don't like having this
    695  04dd							; hard-coded; fix it.
    696  04dd							;
    697  04dd							;		  lda	  #STMT&$ff
    698  04dd							;		  sta	  ILPC
    699  04dd							;		  lda	  #STMT>>8
    700  04dd							;		  sta	  ILPC+1
    701  04dd							;		  jmp	  NextIL
    702  04dd							;
    703  04dd							; Run
    704  04dd							;
    705  04dd				   iXferok
    706  04dd		       a9 ff		      lda	#$ff
    707  04df		       85 5b		      sta	RunMode	;we're running
    708  04e1							;
    709  04e1							; Need a more elegant way to do this
    710  04e1							;
    711  04e1		       a9 ac		      lda	#STMT&$ff
    712  04e3		       85 43		      sta	ILPC
    713  04e5		       a9 22		      lda	#STMT>>8
    714  04e7		       85 44		      sta	ILPC+1
    715  04e9		       4c c3 02 	      jmp	NextIL
    716  04ec							;
    717  04ec							;=====================================================
    718  04ec							; Save the pointer to the next line to the call stack.
    719  04ec							;
    720  04ec		       20 30 1b    iSAV       jsr	getILByte	; load type of gosub
    721  04ef		       20 43 1d 	      jsr	pushLN	; Type passed in A
    722  04f2		       b0 03		      bcs	iSAVErr
    723  04f4		       4c c3 02 	      jmp	NextIL
    724  04f7
    725  04f7		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    726  04f9		       a9 00	   iSAVErr2   lda	#0
    727  04fb		       4c aa 06 	      jmp	iErr2
    728  04fe							;====================================================
    729  04fe							; Move stack top to and from temp area
    730  04fe				   iStk2Tmp
    731  04fe		       20 bb 1d 	      jsr	popR0
    732  0501		       a5 52		      lda	R0
    733  0503		       a0 34		      ldy	#TASKEXITCODE	; can also be used as temp
    734  0505		       91 41		      sta	(VARIABLES),y
    735  0507		       c8		      iny
    736  0508		       a5 53		      lda	R0+1
    737  050a		       91 41		      sta	(VARIABLES),y
    738  050c		       4c c3 02 	      jmp	NextIL
    739  050f
    740  050f		       a0 34	   iTmp2Stk   ldy	#TASKEXITCODE
    741  0511		       b1 41		      lda	(VARIABLES),y
    742  0513		       85 52		      sta	R0
    743  0515		       c8		      iny
    744  0516		       b1 41		      lda	(VARIABLES),y
    745  0518		       85 53		      sta	R0+1
    746  051a		       20 29 1d 	      jsr	pushR0
    747  051d		       4c c3 02 	      jmp	NextIL
    748  0520							;
    749  0520							;=====================================================
    750  0520							; Pop the next line from the call stack.
    751  0520							;
    752  0520		       20 6c 1d    iRET       jsr	popLN
    753  0523		       b0 d2		      bcs	iSAVErr
    754  0525		       a0 03		      ldy	#3
    755  0527		       84 51		      sty	CUROFF
    756  0529		       a9 00		      lda	#0
    757  052b		       8d 63 26 	      sta	IRQPending
    758  052e		       58		      cli
    759  052f		       4c c3 02 	      jmp	NextIL
    760  0532							;
    761  0532							;=====================================================
    762  0532							; On entry il, branch to if function
    763  0532							;	    il+1, value to be returned or not true or false
    764  0532							;
    765  0532							; Return from GOSUB function
    766  0532							;
    767  0532		       20 30 1b    iRSTR      jsr	getILByte	; get where to go if gosub is a fucntion
    768  0535		       8d bb 2f 	      sta	offset
    769  0538		       20 13 1d 	      jsr	saveIL	; for later jump if needed
    770  053b
    771  053b		       20 6c 1d 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    772  053e		       85 54		      sta	R1	; keep the type of call returning from
    773  0540		       b0 2a		      bcs	iRSTRErr	; stack underflow error possible
    774  0542
    775  0542		       20 30 1b 	      jsr	getILByte	; get if a value is being returned
    776  0545		       48		      pha		; save if a value was passed to be returned
    777  0546		       c9 00		      cmp	#0	; yes attemping to return a value
    778  0548		       f0 03		      beq	iRSTRPOP	; no value to return
    779  054a		       20 bb 1d 	      jsr	popR0	; Get the value from the stack save if needed
    780  054d				   iRSTRPOP
    781  054d		       20 c4 16 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    782  0550		       a5 54		      lda	R1	; called as a statement ?
    783  0552		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    784  0554		       f0 12		      beq	iRSTRExit
    785  0556		       68		      pla		; get back if value returned or not
    786  0557		       c9 01		      cmp	#1	; we have a value to return
    787  0559		       f0 04		      beq	iRSTRVALUE
    788  055b
    789  055b		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    790  055d		       d0 9a		      bne	iSAVErr2
    791  055f
    792  055f				   iRSTRVALUE
    793  055f		       20 29 1d 	      jsr	pushR0	; return value back to top of stack
    794  0562		       20 1e 1d 	      jsr	restoreIL	; get the correct il
    795  0565		       4c ad 0b 	      jmp	tstBranch	; And called as a function
    796  0568
    797  0568				   iRSTRExit
    798  0568		       68		      pla		; throw away the return value if provided
    799  0569		       4c c3 02 	      jmp	NextIL
    800  056c
    801  056c				   iRSTRNORETURNVALUE
    802  056c
    803  056c
    804  056c		       ad 66 26    iRSTRErr   lda	taskPtr	; Check if this is task zero
    805  056f		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    806  0571		       a5 56		      lda	MQ
    807  0573		       d0 03		      bne	taskRet
    808  0575		       20 dd 1f 	      jsr	pushFalse	; the result code by default is 0
    809  0578				   taskRet
    810  0578		       4c 53 19 	      jmp	iETask	; not task zero then do a task end instead
    811  057b				   taskZeroEnd
    812  057b		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    813  057d		       4c f9 04 	      jmp	iSAVErr2
    814  0580							;
    815  0580							;=====================================================
    816  0580							; Compare items on stack.  Okay, so on input there are
    817  0580							; three things on the stack
    818  0580							;
    819  0580							;    EXPR2 <- Top of stack
    820  0580							;    OP    <- relational operator, next on stack
    821  0580							;    EXPR1 <- last item on stack
    822  0580							;
    823  0580							; Comparison is: EXPR1 <operator> EXPR2
    824  0580							;
    825  0580							; Operator is one of...
    826  0580							;
    827  0580							;    2 is =
    828  0580							;    1 is <
    829  0580							;    3 is <=
    830  0580							;    5 is <>
    831  0580							;    4 is >
    832  0580							;    6 is >=
    833  0580							;
    834  0580							; Those are bit-mapped:
    835  0580							;
    836  0580							;    xxxxxGEL
    837  0580							;
    838  0580							;    G = Greater than
    839  0580							;    E = Equal
    840  0580							;    L = Less than
    841  0580							;
    842  0580							; If the comparison is false, do a NXT, ie, move to the
    843  0580							; next line and continue.  If true, continue executing
    844  0580							; on this line.
    845  0580							;
    846  0580		       00 01	   REL_LT     equ	%001
    847  0580		       00 02	   REL_EQUAL  equ	%010
    848  0580		       00 04	   REL_GT     equ	%100
    849  0580							;
    850  0580		       20 d3 1d    iCMPR      jsr	popR1
    851  0583		       20 ea 1d 	      jsr	popMQ	;operator in MQ
    852  0586		       20 bb 1d 	      jsr	popR0
    853  0589		       20 92 05 	      jsr	iCMPRsub
    854  058c		       20 29 1d 	      jsr	pushR0
    855  058f		       4c c3 02 	      jmp	NextIL
    856  0592							;
    857  0592							; See if they are equal or not
    858  0592							;
    859  0592				   iCMPRsub		; Called by internal functions
    860  0592
    861  0592		       a5 52		      lda	R0
    862  0594		       c5 54		      cmp	R1
    863  0596		       d0 0a		      bne	iCMPRnoteq	;try not equal
    864  0598		       a5 53		      lda	R0+1
    865  059a		       c5 55		      cmp	R1+1
    866  059c		       d0 04		      bne	iCMPRnoteq
    867  059e							;
    868  059e							; Equal, set the flag in MQ+1
    869  059e							;
    870  059e		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    871  05a0		       d0 14		      bne	iCMPcom	;Exit it is equal
    872  05a2							;
    873  05a2							; See if EXPR1 (R0) < EXPR2 (R1)
    874  05a2							; See www.6502.org/tutorials/compare_beyond.html
    875  05a2							;
    876  05a2				   iCMPRnoteq
    877  05a2		       a5 52		      lda	R0
    878  05a4		       c5 54		      cmp	R1	; Sets the carry flag
    879  05a6		       a5 53		      lda	R0+1
    880  05a8		       e5 55		      sbc	R1+1
    881  05aa
    882  05aa		       50 02		      bvc	iCMPR_2	; branch if N eor V
    883  05ac		       49 80		      eor	#$80
    884  05ae
    885  05ae		       30 04	   iCMPR_2    bmi	iCMPlt
    886  05b0		       a9 04		      lda	#REL_GT
    887  05b2		       d0 02		      bne	iCMPcom
    888  05b4
    889  05b4		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    890  05b6
    891  05b6				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    892  05b6							;
    893  05b6							; Now compare the end result with what the caller
    894  05b6							; was looking for.
    895  05b6							;
    896  05b6		       25 56		      and	MQ
    897  05b8		       f0 0c		      beq	iCMPno	; no match
    898  05ba		       a9 ff		      lda	#$FF	; true is $ffff
    899  05bc		       85 52		      sta	R0
    900  05be		       85 53		      sta	R0+1
    901  05c0		       d0 0a		      bne	iCMPDone
    902  05c2							;
    903  05c2							; R0 > R1
    904  05c2							;
    905  05c2		       a9 04	   iCMPgt     lda	#REL_GT
    906  05c4		       d0 f0		      bne	iCMPcom
    907  05c6				   iCMPno
    908  05c6		       a9 00		      lda	#0
    909  05c8		       85 52		      sta	R0
    910  05ca		       85 53		      sta	R0+1
    911  05cc
    912  05cc				   iCMPDone
    913  05cc		       60		      rts
    914  05cd
    915  05cd							;
    916  05cd							; if Not a match, so jump to the next line of code.
    917  05cd							; Branches based upon value on top of the stack
    918  05cd				   iBranch
    919  05cd		       20 bb 1d 	      jsr	popR0
    920  05d0		       a5 52		      lda	R0
    921  05d2		       05 53		      ora	R0+1
    922  05d4		       f0 03		      beq	iBranchFalse	; not true
    923  05d6		       4c c3 02 	      jmp	NextIL	; It is true if any value not zero
    924  05d9							;
    925  05d9				   iBranchFalse
    926  05d9		       20 ba 1b 	      jsr	FindNextLine
    927  05dc		       4c d4 04 	      jmp	iXFER2
    928  05df							;
    929  05df							;=====================================================
    930  05df							; Start a read of data in background
    931  05df				   iReadStart
    932  05df		       a9 3f		      lda	#'?	; Prompt with question mark
    933  05e1		       a6 01		      ldx	1	; Indicate to start read in background
    934  05e3		       20 46 1c 	      jsr	GetLine	; Call the getline to start read
    935  05e6		       4c c3 02 	      jmp	NextIL	; next instruction
    936  05e9							;
    937  05e9							;=====================================================
    938  05e9							; Complete the read and return the curptr, curoff pointing to data
    939  05e9				   iReadComplete
    940  05e9		       a9 01		      lda	#GOSUB_RTN
    941  05eb		       20 43 1d 	      jsr	pushLN
    942  05ee		       90 03		      bcc	iReadOk
    943  05f0		       4c ff 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    944  05f3				   iReadOk
    945  05f3		       20 66 1c 	      jsr	ReadComplete
    946  05f6		       4c c3 02 	      jmp	NextIL
    947  05f9		       20 6c 1d 	      jsr	popLN
    948  05fc		       4c c3 02 	      jmp	NextIL
    949  05ff							;=====================================================
    950  05ff							; Get a line of text from the user, convert to a
    951  05ff							; number, leave on top of stack.
    952  05ff							;
    953  05ff				   iINNUM
    954  05ff		       a9 01		      lda	#GOSUB_RTN
    955  0601		       20 43 1d 	      jsr	pushLN
    956  0604		       b0 ea		      bcs	iReadErr	; Stack over flow error
    957  0606							;
    958  0606		       a9 3f		      lda	#'?
    959  0608		       a2 00		      ldx	#0	;Wait for complete
    960  060a		       20 46 1c 	      jsr	GetLine
    961  060d		       20 db 1b 	      jsr	getDecimal
    962  0610		       20 29 1d 	      jsr	pushR0	;put onto stack
    963  0613		       b0 db		      bcs	iReadErr	;StackOverflow error
    964  0615							;
    965  0615		       4c 31 06 	      jmp	ExitIn
    966  0618							;
    967  0618							;=====================================================
    968  0618							; Get a line of text from the user, convert to a
    969  0618							; character value , leave on top of stack. up to 2 characters
    970  0618							;
    971  0618				   iINSTR
    972  0618		       a9 01		      lda	#GOSUB_RTN
    973  061a		       20 43 1d 	      jsr	pushLN
    974  061d		       b0 d1		      bcs	iReadErr	; Stack overflow error
    975  061f		       a9 3f		      lda	#'?
    976  0621		       a2 00		      ldx	#0	;wait for read complete
    977  0623		       20 46 1c 	      jsr	GetLine
    978  0626		       b1 4f		      lda	(CURPTR),y
    979  0628		       85 52		      sta	R0
    980  062a		       a9 00		      lda	#0
    981  062c		       85 53		      sta	R0+1
    982  062e		       20 29 1d 	      jsr	pushR0	;put onto stack
    983  0631				   ExitIn
    984  0631		       20 6c 1d 	      jsr	popLN
    985  0634		       4c c3 02 	      jmp	NextIL
    986  0637							;
    987  0637							;
    988  0637							;=====================================================
    989  0637							; Stop the currently running program.	Actually very
    990  0637							; simple to do... clear the RunMode flag, then set the
    991  0637							; ILPC to the standard handler and continue running.
    992  0637							;
    993  0637		       a9 00	   iFIN       lda	#0
    994  0639		       85 5b		      sta	RunMode
    995  063b		       20 99 17 	      jsr	taskReset
    996  063e							;
    997  063e		       ad ac 2f 	      lda	errGoto
    998  0641		       85 43		      sta	ILPC
    999  0643		       ad ad 2f 	      lda	errGoto+1
   1000  0646		       85 44		      sta	ILPC+1
   1001  0648		       4c c3 02 	      jmp	NextIL
   1002  064b							;
   1003  064b							;=====================================================
   1004  064b							; Handle the ERR opcode.  Following the instruction is
   1005  064b							; a 16 bit error number.  Print an error message, and
   1006  064b							; if we're in run mode, print the line number.  Stop
   1007  064b							; program execution and return to the initial state.
   1008  064b							;
   1009  064b		       20 2c 1b    iERR       jsr	getILWord	;get err code
   1010  064e		       20 54 06 	      jsr	DisplayError
   1011  0651		       4c ad 06 	      jmp	iErrComplete
   1012  0654							;
   1013  0654							; Enter here with the error code in X (LSB) and A (MSB).
   1014  0654							;
   1015  0654				   DisplayError
   1016  0654		       86 52		      stx	R0
   1017  0656		       85 53		      sta	R0+1
   1018  0658							;
   1019  0658		       20 45 14 	      jsr	puts
      0  065b					      db	CR,LF,"Error ",0
      1  065b		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
   1021  0664		       20 76 13 	      jsr	PrintDecimal
   1022  0667							;
   1023  0667		       a5 5b		      lda	RunMode	;running?
   1024  0669		       f0 3b		      beq	iERR3	;nope
   1025  066b		       20 45 14 	      jsr	puts
      0  066e					      db	" at line ",0
      1  066e		       20 61 74 20*	      .byte.b	" at line ",0
   1027  0678		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
   1028  067a				   iErr2a
   1029  067a		       b1 4f		      lda	(CURPTR),y
   1030  067c		       85 52		      sta	R0
   1031  067e		       c8		      iny
   1032  067f		       b1 4f		      lda	(CURPTR),y
   1033  0681		       85 53		      sta	R0+1
   1034  0683		       20 76 13 	      jsr	PrintDecimal
   1035  0686		       20 45 14 	      jsr	puts
      0  0689					      db	":",0
      1  0689		       3a 00		      .byte.b	":",0
   1037  068b		       a9 00		      lda	#0
   1038  068d		       85 53		      sta	R0+1
   1039  068f		       a5 51		      lda	CUROFF
   1040  0691		       18		      clc
   1041  0692		       e9 03		      sbc	#3
   1042  0694		       85 52		      sta	R0
   1043  0696		       20 76 13 	      jsr	PrintDecimal
   1044  0699		       20 45 14 	      jsr	puts
      0  069c					      db	":",0
      1  069c		       3a 00		      .byte.b	":",0
   1046  069e		       ad 66 26 	      lda	taskPtr
   1047  06a1		       85 52		      sta	R0
   1048  06a3		       20 76 13 	      jsr	PrintDecimal
   1049  06a6							;
   1050  06a6				   iERR3
   1051  06a6		       20 74 1e 	      jsr	CRLF
   1052  06a9		       60		      rts
   1053  06aa
   1054  06aa				   iErr2
   1055  06aa		       20 54 06 	      jsr	DisplayError
   1056  06ad
   1057  06ad				   iErrComplete
   1058  06ad		       20 91 17 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1059  06b0		       a9 00		      lda	#0
   1060  06b2		       85 5b		      sta	RunMode	; fall through...
   1061  06b4							;
   1062  06b4							;=====================================================
   1063  06b4							; Reset the IL to be back at the idle loop.  Does not
   1064  06b4							; clear variables so the user can see what state
   1065  06b4							; the program is in.
   1066  06b4							;
   1067  06b4		       a9 00	   ResetIL    lda	#0
   1068  06b6		       85 47		      sta	ILSTACKPTR
   1069  06b8		       ad ac 2f 	      lda	errGoto
   1070  06bb		       85 43		      sta	ILPC
   1071  06bd		       ad ad 2f 	      lda	errGoto+1
   1072  06c0		       85 44		      sta	ILPC+1
   1073  06c2		       4c c3 02 	      jmp	NextIL
   1074  06c5
   1075  06c5							;
   1076  06c5							;=====================================================
   1077  06c5							; Pop two items off stack, add them, then place the
   1078  06c5							; result back onto the stack.
   1079  06c5							;
   1080  06c5		       20 bb 1d    iADD       jsr	popR0
   1081  06c8		       20 d3 1d 	      jsr	popR1
   1082  06cb				   iADDfast
   1083  06cb		       18		      clc
   1084  06cc		       a5 52		      lda	R0
   1085  06ce		       65 54		      adc	R1
   1086  06d0		       85 52		      sta	R0
   1087  06d2		       a5 53		      lda	R0+1
   1088  06d4		       65 55		      adc	R1+1
   1089  06d6		       85 53		      sta	R0+1
   1090  06d8		       4c 43 07 	      jmp	pushR0nextIl
   1091  06db							;
   1092  06db							;=====================================================
   1093  06db							; Pop two items off the stack.  Subtract the top of
   1094  06db							; stack from the lower entry.
   1095  06db							;
   1096  06db		       20 d3 1d    iSUB       jsr	popR1
   1097  06de		       20 bb 1d 	      jsr	popR0
   1098  06e1		       38		      sec
   1099  06e2		       a5 52		      lda	R0
   1100  06e4		       e5 54		      sbc	R1
   1101  06e6		       85 52		      sta	R0
   1102  06e8		       a5 53		      lda	R0+1
   1103  06ea		       e5 55		      sbc	R1+1
   1104  06ec		       85 53		      sta	R0+1
   1105  06ee		       4c 43 07 	      jmp	pushR0nextIl
   1106  06f1							;
   1107  06f1							;=====================================================
   1108  06f1							; Negate the top of stack.
   1109  06f1							;
   1110  06f1		       20 bb 1d    iNEG       jsr	popR0
   1111  06f4		       a5 52		      lda	R0
   1112  06f6		       49 ff		      eor	#$ff
   1113  06f8		       85 52		      sta	R0
   1114  06fa		       a5 53		      lda	R0+1
   1115  06fc		       49 ff		      eor	#$ff
   1116  06fe		       85 53		      sta	R0+1
   1117  0700		       e6 52		      inc	R0
   1118  0702		       d0 02		      bne	iNEG2
   1119  0704		       e6 53		      inc	R0+1
   1120  0706		       4c 43 07    iNEG2      jmp	pushR0nextIl
   1121  0709							;
   1122  0709							;=====================================================
   1123  0709							; Multiply top two items on the stack, put the results
   1124  0709							; on top.  This uses the algorithm documented on page
   1125  0709							; 115 of "Microprocessor Programming for Computer
   1126  0709							; Hobbyists" by Neill Graham.
   1127  0709							;
   1128  0709		       20 0f 07    iMUL       jsr	iMultiply
   1129  070c		       4c c3 02 	      jmp	NextIL
   1130  070f
   1131  070f				   iMultiply
   1132  070f		       20 bb 1d 	      jsr	popR0	;AC
   1133  0712		       20 d3 1d 	      jsr	popR1	;OP
   1134  0715							;
   1135  0715		       a5 52		      lda	R0
   1136  0717		       85 56		      sta	MQ
   1137  0719		       a5 53		      lda	R0+1
   1138  071b		       85 57		      sta	MQ+1
   1139  071d		       a9 00		      lda	#0	;clear result
   1140  071f		       85 52		      sta	R0
   1141  0721		       85 53		      sta	R0+1
   1142  0723							;
   1143  0723		       a2 10		      ldx	#16	;number of bits in value
   1144  0725		       06 52	   multloop   asl	R0
   1145  0727		       26 53		      rol	R0+1
   1146  0729		       06 56		      asl	MQ
   1147  072b		       26 57		      rol	MQ+1
   1148  072d		       90 0d		      bcc	multno	;skip add if no carry
   1149  072f							;
   1150  072f							; Add R1 back into R0
   1151  072f							;
   1152  072f		       18		      clc
   1153  0730		       a5 52		      lda	R0
   1154  0732		       65 54		      adc	R1
   1155  0734		       85 52		      sta	R0
   1156  0736		       a5 53		      lda	R0+1
   1157  0738		       65 55		      adc	R1+1
   1158  073a		       85 53		      sta	R0+1
   1159  073c							;
   1160  073c		       ca	   multno     dex		;did all bits yet?
   1161  073d		       d0 e6		      bne	multloop
   1162  073f		       20 29 1d 	      jsr	pushR0	;OP
   1163  0742		       60		      rts
   1164  0743							;
   1165  0743				   pushR0nextIl
   1166  0743		       20 29 1d 	      jsr	pushR0	;OP
   1167  0746		       4c c3 02 	      jmp	NextIL
   1168  0749							;
   1169  0749							;=====================================================
   1170  0749							; Divide the top of stack into the next to top item.
   1171  0749							; Leave results on stack.  Taken from:
   1172  0749							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1173  0749							;
   1174  0749							; R0 = R0 / R1
   1175  0749							; Remainder is in MQ
   1176  0749							;
   1177  0749		       20 63 07    iDIV       jsr	iDoDiv
   1178  074c		       20 3c 1e 	      jsr	RestoreSigns
   1179  074f		       4c 43 07 	      jmp	pushR0nextIl
   1180  0752
   1181  0752		       20 63 07    iMOD       jsr	iDoDiv
   1182  0755		       20 3c 1e 	      jsr	RestoreSigns
   1183  0758		       a5 56		      lda	MQ
   1184  075a		       85 52		      sta	R0
   1185  075c		       a5 57		      lda	MQ+1
   1186  075e		       85 53		      sta	R0+1
   1187  0760		       4c 43 07 	      jmp	pushR0nextIl
   1188  0763
   1189  0763				   iDoDiv
   1190  0763		       20 d3 1d 	      jsr	popR1
   1191  0766		       20 bb 1d 	      jsr	popR0
   1192  0769							;
   1193  0769							; Check for divide by zero
   1194  0769							;
   1195  0769
   1196  0769				   iDivNoPop
   1197  0769		       a5 54		      lda	R1
   1198  076b		       05 55		      ora	R1+1
   1199  076d		       f0 29		      beq	divby0
   1200  076f							;
   1201  076f		       20 01 1e 	      jsr	SaveSigns
   1202  0772		       a9 00		      lda	#0	;preset remainder to 0
   1203  0774		       85 56		      sta	MQ
   1204  0776		       85 57		      sta	MQ+1
   1205  0778		       a2 10		      ldx	#16	;repeat for each bit: ...
   1206  077a				   divloop
   1207  077a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1208  077c		       26 53		      rol	R0+1
   1209  077e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1210  0780		       26 57		      rol	MQ+1
   1211  0782		       a5 56		      lda	MQ
   1212  0784		       38		      sec
   1213  0785		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1214  0787		       a8		      tay		;lb result -> Y, for we may need it later
   1215  0788		       a5 57		      lda	MQ+1
   1216  078a		       e5 55		      sbc	R1+1
   1217  078c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1218  078e
   1219  078e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1220  0790		       84 56		      sty	MQ
   1221  0792		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1222  0794
   1223  0794		       ca	   skip       dex
   1224  0795		       d0 e3		      bne	divloop
   1225  0797		       60		      rts
   1226  0798							;
   1227  0798							; Indicate divide-by-zero error
   1228  0798							;
   1229  0798		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1230  079a		       a9 00		      lda	#0
   1231  079c		       4c aa 06 	      jmp	iErr2
   1232  079f							;
   1233  079f							;=====================================================
   1234  079f							; This pops the top two items off the stack.  The top
   1235  079f							; item is a data value and the other is an ABSOLUTE address.
   1236  079f							; Save the value into that address.
   1237  079f							;
   1238  079f		       98	   iSTORE     tya
   1239  07a0		       48		      pha
   1240  07a1		       20 bb 1d 	      jsr	popR0	;data
   1241  07a4		       20 d3 1d 	      jsr	popR1	;Storage location
   1242  07a7		       a0 00		      ldy	#0
   1243  07a9		       a5 52		      lda	R0
   1244  07ab		       91 54		      sta	(R1),y
   1245  07ad		       a5 53		      lda	R0+1
   1246  07af		       c8		      iny
   1247  07b0		       91 54		      sta	(R1),y
   1248  07b2		       68		      pla
   1249  07b3		       a8		      tay
   1250  07b4		       4c c3 02 	      jmp	NextIL
   1251  07b7							;
   1252  07b7							;=====================================================
   1253  07b7							; Replaces the top of stack with the Value
   1254  07b7							; of the variable  whose absolute address it represents.
   1255  07b7							;
   1256  07b7		       98	   iIND       tya
   1257  07b8		       48		      pha
   1258  07b9		       20 d3 1d 	      jsr	popR1
   1259  07bc		       a0 00		      ldy	#0
   1260  07be		       b1 54		      lda	(R1),y
   1261  07c0		       85 52		      sta	R0
   1262  07c2		       c8		      iny
   1263  07c3		       b1 54		      lda	(R1),y
   1264  07c5		       85 53		      sta	R0+1
   1265  07c7		       68		      pla
   1266  07c8		       a8		      tay
   1267  07c9		       4c 43 07 	      jmp	pushR0nextIl
   1268  07cc							;
   1269  07cc							;=====================================================
   1270  07cc							; Check which type of index to use byte or word and jmp to correct
   1271  07cc							; function
   1272  07cc				   iArray
   1273  07cc		       20 30 1b 	      jsr	getILByte
   1274  07cf		       c9 00		      cmp	#0
   1275  07d1		       f0 09		      beq	iArrayW
   1276  07d3							;
   1277  07d3							;=====================================================
   1278  07d3							; Get from Byte array not Integer array
   1279  07d3				   iArrayB
   1280  07d3		       20 bb 1d 	      jsr	popR0	; Get the array index
   1281  07d6		       20 d3 1d 	      jsr	popR1	; Get the Variable address
   1282  07d9		       4c e7 07 	      jmp	iArrayAll	; It will be a byte value
   1283  07dc
   1284  07dc							;=====================================================
   1285  07dc							; Get the array index from top of stack get Current variable
   1286  07dc							; address from next on stack, add the offset
   1287  07dc							; push the result back onto the stack
   1288  07dc				   iArrayW
   1289  07dc		       20 bb 1d 	      jsr	popR0	; Get the array index
   1290  07df		       20 d3 1d 	      jsr	popR1	; Get the Variable address
   1291  07e2
   1292  07e2		       18		      clc		; Multiplythe value by 2
   1293  07e3		       26 52		      rol	R0	; Do the multiply
   1294  07e5		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1295  07e7				   iArrayAll
   1296  07e7		       18		      clc
   1297  07e8		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1298  07ea		       65 52		      adc	R0
   1299  07ec		       85 52		      sta	R0
   1300  07ee		       a5 55		      lda	R1+1
   1301  07f0		       65 53		      adc	R0+1
   1302  07f2		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1303  07f4		       20 29 1d 	      jsr	pushR0	; Push R0 assume it is correct
   1304  07f7
   1305  07f7		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1306  07f9		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1307  07fb		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1308  07fd		       a5 55		      lda	R1+1
   1309  07ff		       c5 42		      cmp	VARIABLES+1
   1310  0801		       d0 1c		      bne	iArrayAtTest
   1311  0803		       18		      clc
   1312  0804		       a9 34		      lda	#52	; add the max offset that is valid
   1313  0806		       65 54		      adc	R1	; update to be the largest offset that is valid
   1314  0808		       85 54		      sta	R1
   1315  080a		       a9 00		      lda	#0
   1316  080c		       65 55		      adc	R1+1
   1317  080e		       85 55		      sta	R1+1
   1318  0810				   iArrayVerify 		; try to enforce some sanity to using arrays
   1319  0810		       a5 53		      lda	R0+1
   1320  0812		       c5 55		      cmp	R1+1
   1321  0814		       d0 04		      bne	iArrayDecide
   1322  0816		       a5 52		      lda	R0
   1323  0818		       c5 54		      cmp	R1
   1324  081a				   iArrayDecide
   1325  081a		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1326  081c		       4c c3 02 	      jmp	NextIL
   1327  081f
   1328  081f				   iArrayAtTest
   1329  081f		       ad c3 2f 	      lda	HighMem
   1330  0822		       85 54		      sta	R1
   1331  0824		       ad c4 2f 	      lda	HighMem+1
   1332  0827		       85 55		      sta	R1+1
   1333  0829		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1334  082b
   1335  082b							; Get here if array index is out of range
   1336  082b		       20 bb 1d    iArrayError jsr	popR0
   1337  082e		       a9 00		      lda	#0
   1338  0830		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1339  0832		       4c aa 06 	      jmp	iErr2
   1340  0835							;
   1341  0835							;=====================================================
   1342  0835							; List the current BASIC program in memory.  Uses R0,
   1343  0835							; tempIly, and dpl.
   1344  0835							;
   1345  0835		       20 a8 1f    iLST       jsr	SetOutConsole
   1346  0838		       ad bf 2f    iLST2      lda	ProgramStart
   1347  083b		       85 59		      sta	dpl
   1348  083d		       ad c0 2f 	      lda	ProgramStart+1
   1349  0840		       85 5a		      sta	dpl+1
   1350  0842							;
   1351  0842							; dpl/dph point to the current line.  See if we're at
   1352  0842							; the end of the program.
   1353  0842							;
   1354  0842		       a5 59	   iLSTloop   lda	dpl
   1355  0844		       cd c1 2f 	      cmp	ProgramEnd
   1356  0847		       d0 07		      bne	iLstNotEnd
   1357  0849		       a5 5a		      lda	dpl+1
   1358  084b		       cd c2 2f 	      cmp	ProgramEnd+1
   1359  084e		       f0 15		      beq	iLstdone
   1360  0850							;
   1361  0850		       20 dd 14    iLstNotEnd jsr	PrintProgramLine
   1362  0853							;		  ldy	  #1		  ;Change:  Skip first byte length
   1363  0853							;		  lda	  (dpl),y	  ;line number LSB
   1364  0853							;		  sta	  R0
   1365  0853							;		  iny
   1366  0853							;		  lda	  (dpl),y		 ;line number MSB
   1367  0853							;		  sta	  R0+1
   1368  0853							;		  iny
   1369  0853							;		  sty	  tempIlY
   1370  0853							;		  jsr	  PrintDecimal
   1371  0853							;		  lda	  #SPACE
   1372  0853							;		  jsr	  VOUTCH
   1373  0853							;		  ldy	  tempIlY
   1374  0853							;iLSTl2	  lda	  (dpl),y
   1375  0853							;		  beq	  iLST3 	  ;end of this line 0 value
   1376  0853							;		  sty	  tempIlY
   1377  0853							;		  jsr	  VOUTCH
   1378  0853							;		  ldy	  tempIlY
   1379  0853							;		  iny
   1380  0853							;		  bne	  iLSTl2	  ;do next char
   1381  0853							;
   1382  0853							; End of this line.  Print CR/LF, then move to the
   1383  0853							; next line.
   1384  0853							;
   1385  0853		       a0 00	   iLST3      ldy	#0	;Move to next line
   1386  0855		       b1 59		      lda	(dpl),y	;Current line length
   1387  0857		       18		      clc		;Clear the carry flag
   1388  0858							;		  tya
   1389  0858		       65 59		      adc	dpl	;Add the offset to the pointer
   1390  085a		       85 59		      sta	dpl	;Save the new value
   1391  085c		       a5 5a		      lda	dpl+1	;Next byte
   1392  085e		       69 00		      adc	#0	;ad in the carry if any
   1393  0860		       85 5a		      sta	dpl+1	;Save it
   1394  0862							;
   1395  0862							; Have to manually do CR/LF so it uses the vectored
   1396  0862							; output function.
   1397  0862							;
   1398  0862							;		  lda	  #CR
   1399  0862							;		  jsr	  VOUTCH
   1400  0862							;		  lda	  #LF
   1401  0862							;		  jsr	  VOUTCH
   1402  0862		       4c 42 08 	      jmp	iLSTloop	;do next line
   1403  0865							;
   1404  0865		       20 a8 1f    iLstdone   jsr	SetOutConsole
   1405  0868		       4c c3 02 	      jmp	NextIL
   1406  086b							;
   1407  086b							;=====================================================
   1408  086b							; Get a line of text into LINBUF.  Terminate with a
   1409  086b							; null byte.
   1410  086b							;
   1411  086b				   iGETLINE
   1412  086b		       a9 3e		      lda	#'>	;prompt character
   1413  086d		       a6 00		      ldx	0	;Wait for read to complete
   1414  086f		       20 46 1c 	      jsr	GetLine
   1415  0872							;
   1416  0872		       a9 00		      lda	#0
   1417  0874		       85 5b		      sta	RunMode
   1418  0876				   iGetParseLine
   1419  0876							; lda	   CUROFF
   1420  0876							; pha
   1421  0876		       20 e6 10 	      jsr	ParseInputLine
   1422  0879							; pla
   1423  0879							;  sta     CUROFF
   1424  0879		       a9 e3		      lda	#TOKENBUFFER&$FF
   1425  087b		       85 4f		      sta	CURPTR
   1426  087d		       a9 0f		      lda	#TOKENBUFFER>>8
   1427  087f		       85 50		      sta	CURPTR+1
   1428  0881		       a9 01		      lda	#1
   1429  0883		       85 51		      sta	CUROFF
   1430  0885		       4c c3 02 	      jmp	NextIL
   1431  0888							;
   1432  0888							;=====================================================
   1433  0888							; This is called when the input buffer contains a line
   1434  0888							; typed in by the user that starts with a line number.
   1435  0888							; Insert the line into the program or delete the line
   1436  0888							; if there is nothing after the line number,
   1437  0888							;
   1438  0888				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1439  0888		       ad e4 0f 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1440  088b		       85 52		      sta	R0	; place the number into R0
   1441  088d		       ad e5 0f 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1442  0890		       85 53		      STA	R0+1	; Place it into
   1443  0892							;
   1444  0892							; Now find the line OR the next higher line OR the
   1445  0892							; end of the program.
   1446  0892							;
   1447  0892		       20 75 1b 	      jsr	findLine	; Look for the line number in the current program
   1448  0895							; Returns Z and curptr point to the line if found
   1449  0895							; Returns C and curptr at next higher line if not found and there is a higher line
   1450  0895							; Returns ZC clear and curptr to end of program if higher than all other lines
   1451  0895							;
   1452  0895							; If the line exists, it needs to be removed.
   1453  0895							;
   1454  0895		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1455  0897							;
   1456  0897							; Get length of line to be removed, we fall thru to here if we find a matching line
   1457  0897							;
   1458  0897							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1459  0897		       a0 00		      ldy	#0
   1460  0899		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1461  089b		       a8		      tay
   1462  089c							;If it is equal we delete the line and replace it, get length
   1463  089c							;then adjust all program line after up or down depending on len of line
   1464  089c							;If next higher then just move everythimg down by length bytes
   1465  089c							;This call will return how many bytes in the line we found
   1466  089c		       8c bc 2f 	      sty	lineLength	;Save the length of the line we found
   1467  089f							;
   1468  089f							; Compute the new end of the program first.
   1469  089f							;
   1470  089f		       38		      sec		;Set the carry bit
   1471  08a0		       ad c1 2f 	      lda	ProgramEnd	;Get low byte of program end
   1472  08a3		       ed bc 2f 	      sbc	lineLength	;Subtract the length of the current line
   1473  08a6		       8d c1 2f 	      sta	ProgramEnd	;save it
   1474  08a9		       ad c2 2f 	      lda	ProgramEnd+1
   1475  08ac		       e9 00		      sbc	#0	;Process the carry
   1476  08ae		       8d c2 2f 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1477  08b1							;
   1478  08b1							; Copy CURPTR into R1 for working
   1479  08b1							;
   1480  08b1		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1481  08b3		       85 54		      sta	R1
   1482  08b5		       a5 50		      lda	CURPTR+1
   1483  08b7		       85 55		      sta	R1+1
   1484  08b9							;
   1485  08b9							; See if we're at the end.
   1486  08b9							;
   1487  08b9		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1488  08bb		       cd c1 2f 	      cmp	ProgramEnd
   1489  08be		       d0 07		      bne	InsDelLoop
   1490  08c0		       a5 55		      lda	R1+1
   1491  08c2		       cd c2 2f 	      cmp	ProgramEnd+1
   1492  08c5		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1493  08c7							;
   1494  08c7							; Move one byte, move to next location.
   1495  08c7							;
   1496  08c7		       ac bc 2f    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1497  08ca		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1498  08cc		       b1 54		      lda	(R1),y
   1499  08ce		       a0 00		      ldy	#0
   1500  08d0		       91 54		      sta	(R1),y
   1501  08d2		       e6 54		      inc	R1
   1502  08d4		       d0 e3		      bne	InsDelChk
   1503  08d6		       e6 55		      inc	R1+1
   1504  08d8		       4c b9 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1505  08db							;
   1506  08db							; Deletion is done.
   1507  08db							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1508  08db							;
   1509  08db				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1510  08db		       ad e3 0f 	      lda	TOKENBUFFER	; Get the length
   1511  08de		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1512  08e0							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1513  08e0		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1514  08e2							;
   1515  08e2							; CURPTR points to where the line will be inserted.
   1516  08e2							;
   1517  08e2							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1518  08e2		       ae e3 0f 	      ldx	TOKENBUFFER
   1519  08e5		       8e bc 2f 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1520  08e8							;
   1521  08e8		       ad c1 2f 	      lda	ProgramEnd	;Load the start address for the copy
   1522  08eb							;At this point curptr still contains the location we will insert data
   1523  08eb		       85 5c		      sta	FROM
   1524  08ed		       ad c2 2f 	      lda	ProgramEnd+1
   1525  08f0		       85 5d		      sta	FROM+1
   1526  08f2							;
   1527  08f2		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1528  08f4		       b1 5c		      lda	(FROM),y
   1529  08f6		       ac bc 2f 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1530  08f9		       91 5c		      sta	(FROM),y	;Save the new byte
   1531  08fb							;
   1532  08fb		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1533  08fd		       c5 4f		      cmp	CURPTR
   1534  08ff		       d0 06		      bne	mvUpMore
   1535  0901		       a5 5d		      lda	FROM+1
   1536  0903		       c5 50		      cmp	CURPTR+1
   1537  0905		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1538  0907							;
   1539  0907							; Not done yet
   1540  0907							;
   1541  0907		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1542  0909		       d0 02		      bne	mvUpMore2
   1543  090b		       c6 5d		      dec	FROM+1
   1544  090d		       c6 5c	   mvUpMore2  dec	FROM
   1545  090f		       4c f2 08 	      jmp	mvup1	;Loop until everything is moved
   1546  0912							;
   1547  0912							; All done with copy.
   1548  0912							;
   1549  0912				   mvUpDone
   1550  0912		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1551  0913		       ad bc 2f 	      lda	lineLength	;Number of bytes to copy from line buff
   1552  0916		       6d c1 2f 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1553  0919		       8d c1 2f 	      sta	ProgramEnd
   1554  091c		       ad c2 2f 	      lda	ProgramEnd+1
   1555  091f		       69 00		      adc	#0
   1556  0921		       8d c2 2f 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1557  0924							;
   1558  0924							;===================jlit use length before line newline
   1559  0924
   1560  0924		       a0 00		      ldy	#0	;Set offset of copy
   1561  0926							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1562  0926							;		  sta	  (CURPTR),y	  ;Store the length
   1563  0926							;		  iny
   1564  0926							;		  lda	  R0		  ;Store the line number next
   1565  0926							;		  sta	  (CURPTR),y
   1566  0926							;		  iny
   1567  0926							;		  lda	  R0+1
   1568  0926							;		  sta	  (CURPTR),y
   1569  0926							;		  iny
   1570  0926							;
   1571  0926							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1572  0926		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1573  0928				   mvUpLoop2
   1574  0928							;		  lda	  LINBUF,x	 ;get a byte
   1575  0928		       bd e3 0f 	      lda	TOKENBUFFER,x	;get a byte
   1576  092b		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1577  092d
   1578  092d		       e8		      inx
   1579  092e		       ec e3 0f 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1580  0931		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1581  0933		       c8		      iny
   1582  0934		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1583  0936							;
   1584  0936		       4c c3 02    mvUpFini   jmp	NextIL
   1585  0939							;
   1586  0939							;=====================================================
   1587  0939							; Pops the top value of the ILPC stack and stores it
   1588  0939							; in ILPC.  Ie, return from an IL subroutine.
   1589  0939							;
   1590  0939		       20 63 1b    iRTN       jsr	popILPC
   1591  093c		       4c c3 02 	      jmp	NextIL
   1592  093f							;
   1593  093f							;=====================================================
   1594  093f							; NLINE print a newline
   1595  093f							;
   1596  093f		       20 74 1e    iNLINE     jsr	CRLF	;user supplied sub
   1597  0942		       4c c3 02 	      jmp	NextIL
   1598  0945							;
   1599  0945							;=====================================================
   1600  0945							; This saves the current ILPC value on the stack, then
   1601  0945							; jumps to the address specified by the next two bytes.
   1602  0945							;
   1603  0945		       20 46 1b    iCALL      jsr	pushILPC	;save ILPC
   1604  0948		       90 03		      bcc	iJMP
   1605  094a		       4c ff 0b 	      jmp	ErrStkOver	; Check if there was an error
   1606  094d							;
   1607  094d							; Jmp to a specific location in the IL code.  The new
   1608  094d							; address immediately follows the opcode.
   1609  094d							;
   1610  094d		       20 2c 1b    iJMP       jsr	getILWord
   1611  0950		       86 43		      stx	ILPC
   1612  0952		       85 44		      sta	ILPC+1
   1613  0954		       4c c3 02 	      jmp	NextIL
   1614  0957
   1615  0957
   1616  0957							;
   1617  0957							;=====================================================
   1618  0957							; Push the next two bytes onto the arithmetic stack.
   1619  0957							;
   1620  0957		       20 30 1b    iSetR2     jsr	getILByte
   1621  095a		       85 58		      sta	R2
   1622  095c		       4c c3 02 	      jmp	NextIL
   1623  095f							;
   1624  095f							;=====================================================
   1625  095f							; Push the next two bytes onto the arithmetic stack.
   1626  095f							;
   1627  095f		       20 2c 1b    iLIT       jsr	getILWord
   1628  0962		       86 52		      stx	R0
   1629  0964		       85 53		      sta	R0+1
   1630  0966		       20 29 1d 	      jsr	pushR0
   1631  0969		       4c c3 02 	      jmp	NextIL
   1632  096c							;
   1633  096c							;=====================================================
   1634  096c							; Initialize all variables for a single task.	Ie, set to zero.
   1635  096c							;
   1636  096c		       98	   subVINIT   tya
   1637  096d		       48		      pha
   1638  096e
   1639  096e		       a9 00		      lda	#0
   1640  0970		       a0 00		      ldy	#0
   1641  0972		       91 41	   Vinit2     sta	(VARIABLES),y
   1642  0974		       c8		      iny
   1643  0975		       c0 34		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1644  0977		       90 f9		      bcc	Vinit2
   1645  0979
   1646  0979		       68		      pla
   1647  097a		       a8		      tay
   1648  097b		       60		      rts
   1649  097c
   1650  097c		       20 a5 0d    iVINIT     jsr	Compile	; compile line numbers to memory pointers
   1651  097f		       20 6c 09 	      jsr	subVINIT
   1652  0982		       4c c3 02 	      jmp	NextIL
   1653  0985							;
   1654  0985							;=====================================================
   1655  0985							; Set the address of the error handler.  After any
   1656  0985							; error, set to the ILPC to the specified location.
   1657  0985							;
   1658  0985		       20 2c 1b    iERRGOTO   jsr	getILWord
   1659  0988		       8e ac 2f 	      stx	errGoto
   1660  098b		       8d ad 2f 	      sta	errGoto+1
   1661  098e		       4c c3 02 	      jmp	NextIL
   1662  0991							;
   1663  0991							;=====================================================
   1664  0991							; TST is followed by an 8 bit signed offset, then a
   1665  0991							; null terminated string.  Compare the string against
   1666  0991							; the string starting at (CURPTR),CUROFF.  If the
   1667  0991							; strings match, continue executing the next IL
   1668  0991							; opcode.  Else, add the offset to ILPC.
   1669  0991							;
   1670  0991		       20 30 1b    iTST       jsr	getILByte	;Get the relative jump address
   1671  0994		       8d bb 2f 	      sta	offset	;save it to use if test faile
   1672  0997		       20 13 1d 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1673  099a
   1674  099a		       a4 51		      ldy	CUROFF
   1675  099c		       84 59		      sty	dpl	;save for later
   1676  099e							;
   1677  099e		       20 30 1b    iTSTloop   jsr	getILByte	;get next char
   1678  09a1		       f0 11		      beq	iTSTm	;match!
   1679  09a3		       a4 59		      ldy	dpl
   1680  09a5		       d1 4f		      cmp	(CURPTR),y
   1681  09a7		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1682  09a9		       09 20		      ora	#$20	; lets allow lowercase as well
   1683  09ab		       d1 4f		      cmp	(CURPTR),y
   1684  09ad		       d0 23		      bne	iTSTfail	;mismatch
   1685  09af		       c8	   iTSTUpper  iny
   1686  09b0		       84 59		      sty	dpl
   1687  09b2		       d0 ea		      bne	iTSTloop
   1688  09b4							;
   1689  09b4							; It's a match!  Clean up a bit.
   1690  09b4							;
   1691  09b4		       a4 59	   iTSTm      ldy	dpl
   1692  09b6		       84 51		      sty	CUROFF
   1693  09b8		       4c c3 02 	      jmp	NextIL
   1694  09bb
   1695  09bb							; Test for a single quote string
   1696  09bb		       20 30 1b    iTSTStr    jsr	getILByte
   1697  09be		       8d bb 2f 	      sta	offset
   1698  09c1		       20 13 1d 	      jsr	saveIL
   1699  09c4		       a4 51		      ldy	CUROFF
   1700  09c6		       a9 22		      lda	#'"
   1701  09c8		       d1 4f		      cmp	(CURPTR),y
   1702  09ca		       d0 06		      bne	iTSTfail
   1703  09cc		       c8		      iny
   1704  09cd		       84 51		      sty	CUROFF
   1705  09cf		       4c e6 02 	      jmp	NextILStr
   1706  09d2							;
   1707  09d2							; Not a match, reset ILPC and then move to the
   1708  09d2							; offset.
   1709  09d2							;
   1710  09d2		       20 1e 1d    iTSTfail   jsr	restoreIL
   1711  09d5		       4c ad 0b 	      jmp	tstBranch
   1712  09d8							;
   1713  09d8							;=================================================JLIT=
   1714  09d8							; Test if we have a let statement without the let keyword
   1715  09d8		       20 30 1b    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1716  09db		       8d bb 2f 	      sta	offset	; Save the jump offset for fails
   1717  09de		       20 13 1d 	      jsr	saveIL	; save to restore when done if fail
   1718  09e1
   1719  09e1		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1720  09e3		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1721  09e5		       c9 01		      cmp	#kLet	; Is it a let keyword
   1722  09e7		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1723  09e9		       c9 80		      cmp	#tVa	; lets check for a variable
   1724  09eb		       90 e5		      bcc	iTSTfail	; Less than variable range
   1725  09ed		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1726  09ef		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1727  09f1		       b0 df		      bcs	iTSTfail	; return it failed
   1728  09f3
   1729  09f3				   iTSTLETGOOD
   1730  09f3		       c8		      iny
   1731  09f4		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1732  09f6				   iTSTGOODVAR
   1733  09f6		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1734  09f9
   1735  09f9							;=================================================JLIT=
   1736  09f9							; Test a byte at an indirect address
   1737  09f9							; fails if byte is not equal to the value at the address
   1738  09f9							; The tests an indirect byte and branches if true
   1739  09f9		       20 30 1b    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1740  09fc		       8d bb 2f 	      sta	offset	; Save the jump offset for fails
   1741  09ff		       20 13 1d 	      jsr	saveIL	; save to restore when done if fail
   1742  0a02		       20 2c 1b 	      jsr	getILWord	; Get a word into RO
   1743  0a05		       86 52		      stx	R0
   1744  0a07		       85 53		      sta	R0+1
   1745  0a09		       20 30 1b 	      jsr	getILByte	; Get byte into A
   1746  0a0c		       a0 00		      ldy	#0
   1747  0a0e		       d1 52		      cmp	(R0),y
   1748  0a10		       d0 03		      bne	iTSTByteNotEqual
   1749  0a12		       4c d2 09 	      jmp	iTSTfail
   1750  0a15
   1751  0a15				   iTSTByteNotEqual
   1752  0a15		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1753  0a18
   1754  0a18							;=================================================JLIT=
   1755  0a18							; Test a byte	branch if it fails
   1756  0a18		       20 30 1b    iTSTB      jsr	getILByte	; Get the relative offset byte
   1757  0a1b		       8d bb 2f 	      sta	offset	; Save the jump offset for fails
   1758  0a1e		       20 13 1d 	      jsr	saveIL	; save to restore when done if fail
   1759  0a21		       20 30 1b 	      jsr	getILByte	; Get a word into RO
   1760  0a24		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1761  0a26		       d1 4f		      cmp	(CURPTR),y
   1762  0a28		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1763  0a2a		       4c d2 09 	      jmp	iTSTfail	; REcover and move on to next test
   1764  0a2d
   1765  0a2d				   iTSTBMatch
   1766  0a2d		       c8		      iny
   1767  0a2e		       84 51		      sty	CUROFF	; Point to the next byte
   1768  0a30		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1769  0a33
   1770  0a33							;=================================================JLIT=
   1771  0a33							; Test a byte	branch if it fails
   1772  0a33		       20 30 1b    iTSTW      jsr	getILByte	; Get the relative offset byte
   1773  0a36		       8d bb 2f 	      sta	offset	; Save the jump offset for fails
   1774  0a39		       20 13 1d 	      jsr	saveIL	; save to restore when done if fail
   1775  0a3c		       20 2c 1b 	      jsr	getILWord	; Get a word into RO
   1776  0a3f		       86 52		      stx	R0
   1777  0a41		       85 53		      sta	R0+1
   1778  0a43		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1779  0a45		       8a		      txa
   1780  0a46		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1781  0a48		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1782  0a4a		       4c d2 09 	      jmp	iTSTfail	; REcover and move on to next test
   1783  0a4d		       c8	   iTSTWM1    iny
   1784  0a4e		       a5 53		      lda	R0+1
   1785  0a50		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1786  0a52		       f0 03		      beq	iTSTWMatch
   1787  0a54		       4c d2 09 	      jmp	iTSTfail
   1788  0a57
   1789  0a57				   iTSTWMatch
   1790  0a57		       c8		      iny
   1791  0a58		       84 51		      sty	CUROFF
   1792  0a5a		       4c c3 02 	      jmp	NextIL	; Then next instruction
   1793  0a5d
   1794  0a5d							;================================================jLIT=
   1795  0a5d							;Test for end of line
   1796  0a5d							;
   1797  0a5d				   iTSTDONE
   1798  0a5d		       20 30 1b 	      jsr	getILByte
   1799  0a60		       8d bb 2f 	      sta	offset
   1800  0a63		       20 13 1d 	      jsr	saveIL
   1801  0a66		       a4 51		      ldy	CUROFF
   1802  0a68		       84 59		      sty	dpl
   1803  0a6a		       b1 4f		      lda	(CURPTR),y
   1804  0a6c		       f0 0b		      beq	iTSTDONEtrue
   1805  0a6e		       c9 e6		      cmp	#oColon
   1806  0a70		       f0 07		      beq	iTSTDONEtrue
   1807  0a72		       a4 59		      ldy	dpl
   1808  0a74		       84 51		      sty	CUROFF
   1809  0a76		       4c d2 09 	      jmp	iTSTfail
   1810  0a79							;
   1811  0a79							; Advance to the next line
   1812  0a79							;
   1813  0a79				   iTSTDONEtrue
   1814  0a79		       4c c3 02 	      jmp	NextIL
   1815  0a7c
   1816  0a7c		       4c ad 0b    tstBranchLink jmp	tstBranch
   1817  0a7f							;
   1818  0a7f							;=====================================================
   1819  0a7f							; Inc and dec a variable , faster than a = a + 1
   1820  0a7f				   iINCVAR
   1821  0a7f		       20 bb 1d 	      jsr	popR0
   1822  0a82		       a0 00		      ldy	#0
   1823  0a84		       18		      clc
   1824  0a85		       a9 01		      lda	#1
   1825  0a87		       71 52		      adc	(R0),y
   1826  0a89		       91 52		      sta	(R0),y
   1827  0a8b		       90 07		      bcc	iINCDONE
   1828  0a8d		       c8		      iny
   1829  0a8e		       a9 00		      lda	#0
   1830  0a90		       71 52		      adc	(R0),y
   1831  0a92		       91 52		      sta	(R0),y
   1832  0a94				   iINCDONE
   1833  0a94		       4c c3 02 	      jmp	NextIL
   1834  0a97
   1835  0a97				   iDECVAR
   1836  0a97		       20 bb 1d 	      jsr	popR0
   1837  0a9a		       a0 00		      ldy	#0
   1838  0a9c		       38		      sec
   1839  0a9d		       b1 52		      lda	(R0),y
   1840  0a9f		       e9 01		      sbc	#1
   1841  0aa1		       91 52		      sta	(R0),y
   1842  0aa3		       c8		      iny
   1843  0aa4		       b1 52		      lda	(R0),y
   1844  0aa6		       e9 00		      sbc	#0
   1845  0aa8		       91 52		      sta	(R0),y
   1846  0aaa		       4c c3 02 	      jmp	NextIL
   1847  0aad
   1848  0aad
   1849  0aad							;
   1850  0aad							;=====================================================
   1851  0aad							; TSTV is followed by an 8 bit signed offset.	If the
   1852  0aad							; value at (CURPTR),CUROFF appears to be a variable
   1853  0aad							; name, move to the next IL statement.  Else, add the
   1854  0aad							; offset to ILPC. Converted to use actual absolute memory addresses
   1855  0aad							; TSTVT Looks for the task context
   1856  0aad							;
   1857  0aad		       20 d3 1d    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1858  0ab0		       a9 00		      lda	#0
   1859  0ab2		       85 58		      sta	R2
   1860  0ab4		       f0 04		      beq	iTSTVV
   1861  0ab6
   1862  0ab6							; Test for simple variable
   1863  0ab6		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1864  0ab8		       85 58		      sta	R2
   1865  0aba
   1866  0aba		       20 30 1b    iTSTVV     jsr	getILByte	;offset
   1867  0abd		       8d bb 2f 	      sta	offset
   1868  0ac0							;
   1869  0ac0		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1870  0ac2		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1871  0ac4		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1872  0ac6		       4c 7c 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1873  0ac9							;
   1874  0ac9				   iTSTVnext
   1875  0ac9		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1876  0acb		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1877  0acd
   1878  0acd		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1879  0acf		       f0 5b		      beq	iTSTVParm
   1880  0ad1
   1881  0ad1		       c9 9b		      cmp	#tVhat	; task exit code
   1882  0ad3		       d0 04		      bne	iTSTV_A2Z
   1883  0ad5		       a9 34		      lda	#TASKEXITCODE
   1884  0ad7		       d0 0b		      bne	iTSTVContinue
   1885  0ad9
   1886  0ad9				   iTSTV_A2Z
   1887  0ad9
   1888  0ad9		       c9 80		      cmp	#tVa
   1889  0adb		       90 9f		      bcc	tstBranchLink
   1890  0add		       c9 9a		      cmp	#tVz+1
   1891  0adf		       b0 9b		      bcs	tstBranchLink
   1892  0ae1
   1893  0ae1
   1894  0ae1							;
   1895  0ae1							; The condition is true, so convert to an index, push
   1896  0ae1							; it onto the stack and continue running.
   1897  0ae1							;
   1898  0ae1		       29 7f		      and	#%01111111	; Mask off the high bit
   1899  0ae3		       0a		      asl		; multiply by two
   1900  0ae4
   1901  0ae4				   iTSTVContinue
   1902  0ae4		       c8		      iny
   1903  0ae5		       84 51		      sty	CUROFF	; it is a valid variable
   1904  0ae7		       48		      pha		; save the last variable pointer value
   1905  0ae8		       a5 58		      lda	R2
   1906  0aea		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1907  0aec
   1908  0aec		       20 05 1b 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1909  0aef		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1910  0af1
   1911  0af1		       68		      pla		; We have an invalid pid for getting variable value
   1912  0af2		       a2 10		      ldx	#ERR_INVALID_PID
   1913  0af4		       a9 00		      lda	#0
   1914  0af6		       4c aa 06 	      jmp	iErr2
   1915  0af9
   1916  0af9				   iTSTVGOODPID
   1917  0af9		       20 ed 1a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1918  0afc		       a0 01		      ldy	#VARIABLEPOS
   1919  0afe		       b1 56		      lda	(MQ),y
   1920  0b00		       85 52		      sta	R0
   1921  0b02		       c8		      iny
   1922  0b03		       b1 56		      lda	(MQ),y
   1923  0b05		       85 53		      sta	R0+1
   1924  0b07		       4c 12 0b 	      jmp	iTSTVAddOffset
   1925  0b0a
   1926  0b0a				   iTSTVLocalValue
   1927  0b0a		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1928  0b0c		       85 52		      sta	R0
   1929  0b0e		       a5 42		      lda	VARIABLES+1
   1930  0b10		       85 53		      sta	R0+1
   1931  0b12
   1932  0b12				   iTSTVAddOffset
   1933  0b12		       68		      pla
   1934  0b13		       85 54		      sta	R1
   1935  0b15		       a9 00		      lda	#0
   1936  0b17		       85 55		      sta	R1+1
   1937  0b19
   1938  0b19				   iTSTVcontinue
   1939  0b19
   1940  0b19		       4c cb 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1941  0b1c
   1942  0b1c							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1943  0b1c							; an array of integer values or byte.
   1944  0b1c				   iTSTVat
   1945  0b1c		       c8		      iny
   1946  0b1d		       84 51		      sty	CUROFF	;it is a valid variable
   1947  0b1f		       ad c1 2f 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1948  0b22		       85 52		      sta	R0
   1949  0b24		       ad c2 2f 	      lda	ProgramEnd+1
   1950  0b27		       85 53		      sta	R0+1
   1951  0b29		       4c 43 07 	      jmp	pushR0nextIl	;place this onto the stack
   1952  0b2c
   1953  0b2c							; When we get parameters passed we can access them using the # variable with[]
   1954  0b2c							; example #[0] #[1] etc, we dont check yet if there is too many
   1955  0b2c				   iTSTVParm
   1956  0b2c		       c8		      iny
   1957  0b2d		       84 51		      sty	CUROFF	;it is a valid variable
   1958  0b2f		       a5 48		      lda	MATHSTACK
   1959  0b31		       85 52		      sta	R0
   1960  0b33		       a5 49		      lda	MATHSTACK+1
   1961  0b35		       85 53		      sta	R0+1
   1962  0b37		       4c 43 07 	      jmp	pushR0nextIl
   1963  0b3a
   1964  0b3a							;
   1965  0b3a							;=====================================================
   1966  0b3a							; TSTL seems basically the same as TSTN, but leave the
   1967  0b3a							; value in R0 instead of pushing onto stack.
   1968  0b3a							; This tests for a valid line number
   1969  0b3a							;
   1970  0b3a		       20 30 1b    iTSTL      jsr	getILByte
   1971  0b3d		       8d bb 2f 	      sta	offset
   1972  0b40							;
   1973  0b40		       a4 51		      ldy	CUROFF
   1974  0b42		       b1 4f		      lda	(CURPTR),y
   1975  0b44		       c8		      iny
   1976  0b45		       11 4f		      ora	(CURPTR),y
   1977  0b47		       f0 06		      beq	iTSTLNotLineNo
   1978  0b49
   1979  0b49
   1980  0b49							; In Both cases we need to point to the first usefull byte to process.
   1981  0b49		       c8		      iny
   1982  0b4a		       84 51		      sty	CUROFF
   1983  0b4c		       4c c3 02 	      jmp	NextIL
   1984  0b4f				   iTSTLNotLineNo
   1985  0b4f		       c8		      iny
   1986  0b50		       84 51		      sty	CUROFF
   1987  0b52		       4c ad 0b 	      jmp	tstBranch
   1988  0b55
   1989  0b55							;
   1990  0b55							;=====================================================
   1991  0b55							; TSTN checks for a number.  This is very simplistic;
   1992  0b55							; if the character is a digit, assume it's a number.
   1993  0b55							; Convert to a number and push it onto the stack.
   1994  0b55							;
   1995  0b55		       20 30 1b    iTSTN      jsr	getILByte
   1996  0b58		       8d bb 2f 	      sta	offset
   1997  0b5b							;
   1998  0b5b		       a9 00		      lda	#0
   1999  0b5d		       85 59		      sta	dpl
   2000  0b5f		       a4 51		      ldy	CUROFF
   2001  0b61				   chkType
   2002  0b61		       b1 4f		      lda	(CURPTR),y
   2003  0b63		       c9 a2		      cmp	#tByte
   2004  0b65		       f0 0e		      beq	chkByte
   2005  0b67		       c9 a1		      cmp	#tInteger
   2006  0b69		       f0 16		      beq	chkInteger
   2007  0b6b		       c9 eb		      cmp	#oMinus
   2008  0b6d		       d0 3e		      bne	tstBranch
   2009  0b6f		       e6 59		      inc	dpl
   2010  0b71		       c8		      iny
   2011  0b72		       4c 61 0b 	      jmp	chkType
   2012  0b75
   2013  0b75				   chkByte
   2014  0b75		       a9 00		      lda	#0
   2015  0b77		       85 53		      sta	R0+1
   2016  0b79		       c8		      iny
   2017  0b7a		       b1 4f		      lda	(CURPTR),y
   2018  0b7c		       85 52		      sta	R0
   2019  0b7e		       c8		      iny
   2020  0b7f		       d0 0b		      bne	iTSTN_1
   2021  0b81
   2022  0b81				   chkInteger
   2023  0b81		       c8		      iny
   2024  0b82		       b1 4f		      lda	(CURPTR),y
   2025  0b84		       85 52		      sta	R0
   2026  0b86		       c8		      iny
   2027  0b87		       b1 4f		      lda	(CURPTR),y
   2028  0b89		       85 53		      sta	R0+1
   2029  0b8b		       c8		      iny
   2030  0b8c							;
   2031  0b8c							; Check if it is negative and make it so
   2032  0b8c							;
   2033  0b8c				   iTSTN_1
   2034  0b8c		       84 51		      sty	CUROFF
   2035  0b8e
   2036  0b8e		       a5 59		      lda	dpl
   2037  0b90		       f0 18		      beq	iTSTN_2	;positive
   2038  0b92							;
   2039  0b92		       a5 52		      lda	R0
   2040  0b94		       05 53		      ora	R0+1
   2041  0b96		       f0 12		      beq	iTSTN_2	;zero
   2042  0b98
   2043  0b98							; Invert all the bits, then add one.
   2044  0b98							;
   2045  0b98		       a5 52		      lda	R0
   2046  0b9a		       49 ff		      eor	#$ff
   2047  0b9c		       85 52		      sta	R0
   2048  0b9e		       a5 53		      lda	R0+1
   2049  0ba0		       49 ff		      eor	#$ff
   2050  0ba2		       85 53		      sta	R0+1
   2051  0ba4							;
   2052  0ba4		       e6 52		      inc	R0
   2053  0ba6		       d0 02		      bne	iTSTN_2
   2054  0ba8		       e6 53		      inc	R0+1
   2055  0baa				   iTSTN_2
   2056  0baa		       4c 43 07 	      jmp	pushR0nextIl	;save onto stack
   2057  0bad
   2058  0bad							;
   2059  0bad							; Common jump point for all TSTx instructions that
   2060  0bad							; fail to meet the requirements.  This takes the
   2061  0bad							; offset and adds/subtracts to/from ILPC.
   2062  0bad							;
   2063  0bad		       ad bb 2f    tstBranch  lda	offset	;get signed offset
   2064  0bb0		       10 0e		      bpl	tstPositive
   2065  0bb2							;
   2066  0bb2							; Do negative branch.	Do sign extension.
   2067  0bb2							;
   2068  0bb2		       18	   tstNegative clc
   2069  0bb3		       65 43		      adc	ILPC
   2070  0bb5		       85 43		      sta	ILPC
   2071  0bb7							;		  bcc	  tstBothDone
   2072  0bb7							;		  dec	  ILPC+1
   2073  0bb7							;		  jmp	  NextIL
   2074  0bb7
   2075  0bb7		       a5 44		      lda	ILPC+1
   2076  0bb9		       69 ff		      adc	#$ff
   2077  0bbb		       85 44		      sta	ILPC+1
   2078  0bbd		       4c c3 02 	      jmp	NextIL	;keep going
   2079  0bc0							;
   2080  0bc0		       18	   tstPositive clc
   2081  0bc1		       65 43		      adc	ILPC
   2082  0bc3		       85 43		      sta	ILPC
   2083  0bc5		       90 02		      bcc	tstBothDone
   2084  0bc7		       e6 44		      inc	ILPC+1
   2085  0bc9				   tstBothDone
   2086  0bc9		       4c c3 02 	      jmp	NextIL
   2087  0bcc
   2088  0bcc							;
   2089  0bcc							;====================================================
   2090  0bcc							; Test for IRQ pending, and test if a break key pressed
   2091  0bcc							; Yes I know but this handles all sorts of irq/break issues
   2092  0bcc							;
   2093  0bcc		       20 30 1b    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2094  0bcf		       8d bb 2f 	      sta	offset	; Store the not true jump address offset
   2095  0bd2		       20 4e 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2096  0bd5		       d0 03		      bne	irqNo	; z not set of no break found
   2097  0bd7		       4c 37 06 	      jmp	iFIN	; Exit out of run mode
   2098  0bda		       ad 63 26    irqNo      lda	IRQPending
   2099  0bdd		       f0 ce		      beq	tstBranch
   2100  0bdf		       c9 01		      cmp	#1	; only do this if set to first time
   2101  0be1		       d0 ca		      bne	tstBranch
   2102  0be3		       78		      sei		; disable the interupt until ireturn resets it
   2103  0be4		       ee 63 26    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2104  0be7		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2105  0be9		       20 43 1d 	      jsr	pushLN	; Push the next line to be executed
   2106  0bec		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2107  0bee		       ad 64 26 	      lda	IRQEntry	; Get the line number to branch to
   2108  0bf1		       85 4f		      sta	CURPTR	; put line number into r0
   2109  0bf3		       ad 65 26 	      lda	IRQEntry+1
   2110  0bf6		       85 50		      sta	CURPTR+1
   2111  0bf8		       a9 03		      lda	#3	; Point to first byte of program text
   2112  0bfa		       85 51		      sta	CUROFF
   2113  0bfc		       4c c3 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2114  0bff
   2115  0bff		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2116  0c01		       a9 00		      lda	#0	; stop the execution
   2117  0c03		       4c aa 06 	      jmp	iErr2
   2118  0c06							;
   2119  0c06
   2120  0c06							;=====================================================
   2121  0c06							; This places the number of free bytes on top of the
   2122  0c06							; stack.
   2123  0c06							;
   2124  0c06		       20 5e 16    iFREE      jsr	MemFree
   2125  0c09		       20 29 1d 	      jsr	pushR0
   2126  0c0c		       4c c3 02 	      jmp	NextIL
   2127  0c0f							;
   2128  0c0f							;=====================================================
   2129  0c0f							; Generate a random number from 0-FFFF and then MOD
   2130  0c0f							; it with the value on top of stack.  Leaves number on
   2131  0c0f							; stack
   2132  0c0f							;
   2133  0c0f		       20 d3 1d    iRANDOM    jsr	popR1	;mod value
   2134  0c12							;
   2135  0c12							; If the value is zero, just return a one.
   2136  0c12							;
   2137  0c12		       a5 54		      lda	R1
   2138  0c14		       05 55		      ora	R1+1
   2139  0c16		       f0 4a		      beq	irandom1
   2140  0c18							;
   2141  0c18		       ad b2 2f 	      lda	random+1
   2142  0c1b		       8d af 2f 	      sta	rtemp1
   2143  0c1e		       ad b1 2f 	      lda	random
   2144  0c21		       0a		      asl
   2145  0c22		       2e af 2f 	      rol	rtemp1
   2146  0c25		       0a		      asl
   2147  0c26		       2e af 2f 	      rol	rtemp1
   2148  0c29		       18		      clc
   2149  0c2a		       6d b1 2f 	      adc	random
   2150  0c2d
   2151  0c2d		       48		      pha
   2152  0c2e
   2153  0c2e		       ad af 2f 	      lda	rtemp1
   2154  0c31		       6d b2 2f 	      adc	random+1
   2155  0c34		       8d b2 2f 	      sta	random+1
   2156  0c37
   2157  0c37		       68		      pla
   2158  0c38
   2159  0c38		       69 11		      adc	#$11
   2160  0c3a		       8d b1 2f 	      sta	random
   2161  0c3d		       ad b2 2f 	      lda	random+1
   2162  0c40		       69 36		      adc	#$36
   2163  0c42		       8d b2 2f 	      sta	random+1
   2164  0c45
   2165  0c45		       ad b1 2f 	      lda	random
   2166  0c48		       85 52		      sta	R0
   2167  0c4a		       ad b2 2f 	      lda	random+1
   2168  0c4d		       29 7f		      and	#$7f	;make positive
   2169  0c4f		       85 53		      sta	R0+1
   2170  0c51							;
   2171  0c51							; R0 contains the number and R1 contains the max value.
   2172  0c51							;
   2173  0c51		       20 69 07 	      jsr	iDivNoPop
   2174  0c54		       20 3c 1e 	      jsr	RestoreSigns
   2175  0c57		       a5 56		      lda	MQ
   2176  0c59		       85 52		      sta	R0
   2177  0c5b		       a5 57		      lda	MQ+1
   2178  0c5d		       85 53		      sta	R0+1
   2179  0c5f		       4c 43 07 	      jmp	pushR0nextIl
   2180  0c62				   irandom1
   2181  0c62		       a9 00		      lda	#0
   2182  0c64		       85 53		      sta	R0+1
   2183  0c66		       a9 01		      lda	#1
   2184  0c68		       85 52		      sta	R0
   2185  0c6a		       4c 43 07 	      jmp	pushR0nextIl
   2186  0c6d
   2187  0c6d							; The following replaced by call to division/modulo
   2188  0c6d							;iRANDOM_2	lda	R0
   2189  0c6d							;		cmp	R1
   2190  0c6d							;		bne	iRANDOM_1
   2191  0c6d							;		lda	R0+1
   2192  0c6d							;		cmp	R1+1
   2193  0c6d							;		bne	iRANDOM_1	;need to subtract
   2194  0c6d							;
   2195  0c6d							; Subtract R1 from R0
   2196  0c6d							;
   2197  0c6d							;iRANDOM_sub	sec
   2198  0c6d							;		lda	R0
   2199  0c6d							;		sbc	R1
   2200  0c6d							;		sta	R0
   2201  0c6d							;		lda	R0+1
   2202  0c6d							;		sbc	R1+1
   2203  0c6d							;		sta	R0+1
   2204  0c6d							;		jmp	iRANDOM_2
   2205  0c6d							;
   2206  0c6d							; See if R1 > R0.  If so, branch to subtract.
   2207  0c6d							;
   2208  0c6d							;iRANDOM_1	lda	R0
   2209  0c6d							;		cmp	R1
   2210  0c6d							;		lda	R0+1
   2211  0c6d							;		sbc	R1+1
   2212  0c6d							;		bvc	iRANDOM_4
   2213  0c6d							;		eor	#$80
   2214  0c6d							;iRANDOM_4	bpl	iRANDOM_sub
   2215  0c6d							;
   2216  0c6d							; All done.  Almost.  Add one, then push the result.
   2217  0c6d							;
   2218  0c6d							;irandom1	inc	R0
   2219  0c6d							;		bne	iRANDOM_3
   2220  0c6d							;		inc	R0+1
   2221  0c6d							;iRANDOM_3
   2222  0c6d							;		  jsr	pushR0	;return value
   2223  0c6d							;		jmp	NextIL
   2224  0c6d							;
   2225  0c6d							; Poke a value into a memory location
   2226  0c6d		       8c b7 2f    iPOKEMEMORY sty	tempy
   2227  0c70		       20 bb 1d 	      jsr	popR0
   2228  0c73		       20 d3 1d 	      jsr	popR1
   2229  0c76		       a0 00		      ldy	#0
   2230  0c78		       a5 52		      lda	R0
   2231  0c7a		       91 54		      sta	(R1),y
   2232  0c7c		       ac b7 2f 	      ldy	tempy
   2233  0c7f		       4c c3 02 	      jmp	NextIL
   2234  0c82							;
   2235  0c82							; Get a value from a memory location
   2236  0c82							;
   2237  0c82		       8c b7 2f    iPEEKMEMORY sty	tempy
   2238  0c85		       20 bb 1d 	      jsr	popR0
   2239  0c88		       a0 00		      ldy	#0
   2240  0c8a		       b1 52		      lda	(R0),y
   2241  0c8c		       ac b7 2f 	      ldy	tempy
   2242  0c8f		       85 52		      sta	R0
   2243  0c91		       a9 00		      lda	#0
   2244  0c93		       85 53		      sta	R0+1
   2245  0c95		       4c 43 07 	      jmp	pushR0nextIl
   2246  0c98							;
   2247  0c98							; Call to address return what ever is in a to the stack
   2248  0c98							; func2 will load a value into a before the call
   2249  0c98		       20 d3 1d    iCallFunc  jsr	popR1
   2250  0c9b		       a5 54		      lda	R1
   2251  0c9d		       20 a9 0c 	      jsr	iCallRtn
   2252  0ca0		       85 52		      sta	R0
   2253  0ca2		       a9 00		      lda	#0
   2254  0ca4		       85 53		      sta	R0+1
   2255  0ca6		       20 43 07 	      jsr	pushR0nextIl
   2256  0ca9				   iCallRtn
   2257  0ca9		       20 bb 1d 	      jsr	popR0
   2258  0cac		       6c 52 00 	      jmp	(R0)
   2259  0caf
   2260  0caf
   2261  0caf							;===========================================jlit======
   2262  0caf							;Get a character from the terminal convert to value
   2263  0caf							;leave the number on top of the stack
   2264  0caf							;
   2265  0caf				   iGETCHAR
   2266  0caf		       20 c5 1f 	      jsr	VGETCH
   2267  0cb2					      if	CTMON65
   2268  0cb2		       48		      pha
   2269  0cb3		       20 c2 1f 	      jsr	VOUTCH	;echo echo echo
   2270  0cb6		       68		      pla
   2271  0cb7					      endif
   2272  0cb7		       85 52		      sta	R0
   2273  0cb9		       a9 00		      lda	#0
   2274  0cbb		       85 53		      sta	R0+1
   2275  0cbd		       20 29 1d 	      jsr	pushR0
   2276  0cc0							;
   2277  0cc0		       4c c3 02 	      jmp	NextIL
   2278  0cc3							;===========================================jusilostintim======
   2279  0cc3							;Put a character to the terminal convert to
   2280  0cc3							;
   2281  0cc3		       20 bb 1d    iPUTCHAR   jsr	popR0
   2282  0cc6		       a5 52		      lda	R0
   2283  0cc8		       20 c2 1f 	      jsr	VOUTCH
   2284  0ccb		       4c c3 02 	      jmp	NextIL
   2285  0cce							;=====================================================
   2286  0cce							; Put the number on the stack out as hex, suppress leading 0
   2287  0cce				   iHexOut
   2288  0cce		       20 bb 1d 	      jsr	popR0
   2289  0cd1		       a5 53		      lda	R0+1
   2290  0cd3		       f0 03		      beq	iHexSecondByte
   2291  0cd5		       20 28 14 	      jsr	OUTHEX
   2292  0cd8				   iHexSecondByte
   2293  0cd8		       a5 52		      lda	R0
   2294  0cda		       20 28 14 	      jsr	OUTHEX
   2295  0cdd		       4c c3 02 	      jmp	NextIL
   2296  0ce0							;
   2297  0ce0							;=====================================================
   2298  0ce0							; Replace TOS with its absolute value.
   2299  0ce0							;
   2300  0ce0		       20 bb 1d    iABS       jsr	popR0
   2301  0ce3		       a5 53		      lda	R0+1
   2302  0ce5		       10 10		      bpl	iABS_1	;already positive
   2303  0ce7		       49 ff		      eor	#$ff
   2304  0ce9		       85 53		      sta	R0+1
   2305  0ceb		       a5 52		      lda	R0
   2306  0ced		       49 ff		      eor	#$ff
   2307  0cef		       85 52		      sta	R0
   2308  0cf1		       e6 52		      inc	R0
   2309  0cf3		       d0 02		      bne	iABS_1
   2310  0cf5		       e6 53		      inc	R0+1
   2311  0cf7		       4c 43 07    iABS_1     jmp	pushR0nextIl
   2312  0cfa
   2313  0cfa							;
   2314  0cfa							;================================================================
   2315  0cfa							; The set of logical operators
   2316  0cfa				   iLogAnd
   2317  0cfa		       20 bb 1d 	      jsr	popR0
   2318  0cfd		       20 d3 1d 	      jsr	popR1
   2319  0d00		       a5 52		      lda	R0
   2320  0d02		       25 54		      and	R1
   2321  0d04		       85 52		      sta	R0
   2322  0d06		       a5 53		      lda	R0+1
   2323  0d08		       25 55		      and	R1+1
   2324  0d0a		       85 53		      sta	R0+1
   2325  0d0c		       4c 43 07 	      jmp	pushR0nextIl
   2326  0d0f				   iLogOr
   2327  0d0f		       20 bb 1d 	      jsr	popR0
   2328  0d12		       20 d3 1d 	      jsr	popR1
   2329  0d15		       a5 52		      lda	R0
   2330  0d17		       05 54		      ora	R1
   2331  0d19		       85 52		      sta	R0
   2332  0d1b		       a5 53		      lda	R0+1
   2333  0d1d		       05 55		      ora	R1+1
   2334  0d1f		       85 53		      sta	R0+1
   2335  0d21		       4c 43 07 	      jmp	pushR0nextIl
   2336  0d24				   iLogXor
   2337  0d24		       20 bb 1d 	      jsr	popR0
   2338  0d27		       20 d3 1d 	      jsr	popR1
   2339  0d2a		       a5 52		      lda	R0
   2340  0d2c		       45 54		      eor	R1
   2341  0d2e		       85 52		      sta	R0
   2342  0d30		       a5 53		      lda	R0+1
   2343  0d32		       45 55		      eor	R1+1
   2344  0d34		       85 53		      sta	R0+1
   2345  0d36		       4c 43 07 	      jmp	pushR0nextIl
   2346  0d39				   iLogNot
   2347  0d39		       20 bb 1d 	      jsr	popR0
   2348  0d3c		       a5 52		      lda	R0
   2349  0d3e		       49 ff		      eor	#$FF
   2350  0d40		       85 52		      sta	R0
   2351  0d42		       a5 53		      lda	R0+1
   2352  0d44		       49 ff		      eor	#$FF
   2353  0d46		       85 53		      sta	R0+1
   2354  0d48		       4c 43 07 	      jmp	pushR0nextIl
   2355  0d4b
   2356  0d4b				   iTruth
   2357  0d4b		       a9 ff		      lda	#$FF
   2358  0d4d		       85 52		      sta	R0
   2359  0d4f		       85 53		      sta	R0+1
   2360  0d51		       4c 43 07 	      jmp	pushR0nextIl
   2361  0d54				   iFalse
   2362  0d54		       a9 00		      lda	#$00
   2363  0d56		       85 52		      sta	R0
   2364  0d58		       85 53		      sta	R0+1
   2365  0d5a		       4c 43 07 	      jmp	pushR0nextIl
   2366  0d5d
   2367  0d5d							;================================================================
   2368  0d5d							;Set the IRQ service rtn line number
   2369  0d5d							;
   2370  0d5d		       78	   iSetIrq    sei		; disable the interupts
   2371  0d5e		       a9 00		      lda	#0	; Zero the Status flag
   2372  0d60		       8d 62 26 	      sta	IRQStatus
   2373  0d63		       20 bb 1d 	      jsr	popR0	; get the line number
   2374  0d66		       a5 52		      lda	R0
   2375  0d68		       05 53		      ora	R0+1
   2376  0d6a		       f0 22		      beq	iSetExt	; if it is zero disable all
   2377  0d6c		       a9 01		      lda	#GOSUB_RTN	; default push type
   2378  0d6e		       20 43 1d 	      jsr	pushLN	; Save the current line pointer
   2379  0d71		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2380  0d73		       4c ff 0b 	      jmp	ErrStkOver	; Check if there was an error
   2381  0d76				   iSetIrqOk
   2382  0d76		       20 75 1b 	      jsr	findLine	; Find the IRQ func Line Pointer
   2383  0d79		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2384  0d7b		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2385  0d7d		       8d 65 26 	      sta	IRQEntry+1
   2386  0d80		       a5 4f		      lda	CURPTR
   2387  0d82		       8d 64 26 	      sta	IRQEntry
   2388  0d85		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2389  0d87		       8d 62 26 	      sta	IRQStatus
   2390  0d8a		       20 6c 1d 	      jsr	popLN	; Restore the old line number
   2391  0d8d		       58		      cli		; Enable the interupts
   2392  0d8e		       4c c3 02    iSetExt    jmp	NextIL
   2393  0d91
   2394  0d91		       20 6c 1d    iSetIrqErr jsr	popLN
   2395  0d94		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2396  0d96		       a9 00		      lda	#0
   2397  0d98		       4c aa 06 	      jmp	iErr2
   2398  0d9b							;
   2399  0d9b		       20 bb 1d    iTRACEPROG jsr	popR0
   2400  0d9e		       a5 52		      lda	R0
   2401  0da0		       85 40		      sta	ILTrace
   2402  0da2		       4c c3 02 	      jmp	NextIL
   2403  0da5
   2404  0da5							;=====================================================
   2405  0da5							; Define start of non page zero data
   2406 U2fc9 ????				      seg.u	TBData
   2407 U261f					      org	PROGEND
   2408 U261f							;=================================================================
   2409 U261f							;
------- FILE compile.asm LEVEL 2 PASS 6
      0 U261f					      include	"compile.asm"
      1  0da5					      Seg	Code
      2  0da5							;
      3  0da5							;=====================================================================
      4  0da5							; Scan the loaded program just before running and insert memory locations of each
      5  0da5							; line number branched to. goto gosub, gofn
      6  0da5							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  0da5				   Compile
      8  0da5		       a9 00		      lda	#0
      9  0da7		       85 52		      sta	R0	; keep track of how many errors we find
     10  0da9		       a5 5b		      lda	RunMode
     11  0dab		       48		      pha
     12  0dac		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  0dae		       a5 4f		      lda	CURPTR
     14  0db0		       48		      pha
     15  0db1		       a5 50		      lda	CURPTR+1
     16  0db3		       48		      pha
     17  0db4		       a5 51		      lda	CUROFF
     18  0db6		       48		      pha
     19  0db7		       ad bf 2f 	      lda	ProgramStart
     20  0dba		       85 59		      sta	dpl
     21  0dbc		       ad c0 2f 	      lda	ProgramStart+1
     22  0dbf		       85 5a		      sta	dpl+1
     23  0dc1
     24  0dc1				   CompileLineStart
     25  0dc1		       a5 59		      lda	dpl
     26  0dc3		       cd c1 2f 	      cmp	ProgramEnd
     27  0dc6		       d0 07		      bne	CompileContinue
     28  0dc8		       a5 5a		      lda	dpl+1
     29  0dca		       cd c2 2f 	      cmp	ProgramEnd+1
     30  0dcd		       f0 3f		      beq	CompileComplete
     31  0dcf
     32  0dcf				   CompileContinue
     33  0dcf		       a0 03		      ldy	#3	; first real character in the line
     34  0dd1
     35  0dd1				   CompileLoop
     36  0dd1		       b1 59		      lda	(dpl),y	; get the byte
     37  0dd3		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  0dd5		       c8		      iny		; Pass this byte
     39  0dd6		       c9 07		      cmp	#kGoto
     40  0dd8		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  0dda		       c9 08		      cmp	#kGosub
     42  0ddc		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  0dde		       c9 31		      cmp	#kGofn
     44  0de0		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  0de2		       c9 29		      cmp	#kTask
     46  0de4		       f0 4c		      beq	CompileField
     47  0de6		       c9 0a		      cmp	#kRem
     48  0de8		       f0 12		      beq	CompileRem	; Skip until end of line
     49  0dea		       c9 a0		      cmp	#tString
     50  0dec		       f0 2f		      beq	CompileString
     51  0dee		       c9 a1		      cmp	#tInteger
     52  0df0		       f0 06		      beq	CompileInteger
     53  0df2		       c9 a2		      cmp	#tByte
     54  0df4		       f0 03		      beq	CompileByte
     55  0df6		       d0 d9		      bne	CompileLoop	; Next character
     56  0df8
     57  0df8				   CompileInteger
     58  0df8		       c8		      iny
     59  0df9				   CompileByte
     60  0df9		       c8		      iny
     61  0dfa		       d0 d5		      bne	CompileLoop
     62  0dfc				   CompileRem
     63  0dfc				   CompileEndOfLine
     64  0dfc		       a0 00		      ldy	#0
     65  0dfe		       b1 59		      lda	(dpl),y
     66  0e00		       18		      clc
     67  0e01		       65 59		      adc	dpl
     68  0e03		       85 59		      sta	dpl
     69  0e05		       a9 00		      lda	#0
     70  0e07		       65 5a		      adc	dpl+1
     71  0e09		       85 5a		      sta	dpl+1
     72  0e0b
     73  0e0b		       4c c1 0d 	      jmp	CompileLineStart
     74  0e0e
     75  0e0e				   CompileComplete
     76  0e0e		       68		      pla
     77  0e0f		       85 51		      sta	CUROFF
     78  0e11		       68		      pla
     79  0e12		       85 50		      sta	CURPTR+1
     80  0e14		       68		      pla
     81  0e15		       85 4f		      sta	CURPTR
     82  0e17		       68		      pla
     83  0e18		       85 5b		      sta	RunMode
     84  0e1a		       a5 52		      lda	R0	; returning the number of errors
     85  0e1c		       60		      rts
     86  0e1d
     87  0e1d
     88  0e1d				   CompileString
     89  0e1d		       c8		      iny		; point past first "
     90  0e1e				   CompileStringLoop
     91  0e1e		       b1 59		      lda	(dpl),y
     92  0e20		       f0 0d		      beq	CompileStrDone2
     93  0e22		       c9 22		      cmp	#'"	; end of string
     94  0e24		       f0 08		      beq	CompileStrDone
     95  0e26		       c9 5c		      cmp	#'\	; escape character
     96  0e28		       d0 01		      bne	CompileStrNext
     97  0e2a		       c8		      iny
     98  0e2b				   CompileStrNext
     99  0e2b		       c8		      iny		; Next character
    100  0e2c		       d0 f0		      bne	CompileStringLoop	; test for end
    101  0e2e				   CompileStrDone
    102  0e2e		       c8		      iny
    103  0e2f				   CompileStrDone2
    104  0e2f		       4c d1 0d 	      Jmp	CompileLoop
    105  0e32							;
    106  0e32							;===============================================================
    107  0e32							; on entry y points to storage location y+2 points to line number
    108  0e32							; on exit y points to line number type
    109  0e32
    110  0e32		       85 52	   CompileField sta	R0
    111  0e34		       98		      tya		; save the y pointer to store the memory value
    112  0e35		       48		      pha
    113  0e36		       c8		      iny		; Skip over the memory vector
    114  0e37		       c8		      iny
    115  0e38		       a5 52		      lda	R0
    116  0e3a		       c9 29		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  0e3c		       d0 07		      bne	CompNoBracket
    118  0e3e
    119  0e3e		       b1 59		      lda	(dpl),y	; Lets make sure it is a
    120  0e40		       c9 e0		      cmp	#oLeftBracket
    121  0e42		       d0 01		      bne	CompNoBracket	; in case of error
    122  0e44		       c8		      iny		; skip the bracket
    123  0e45
    124  0e45				   CompNoBracket
    125  0e45		       a9 00		      lda	#0	; In case the value is a byte
    126  0e47		       85 53		      sta	R0+1
    127  0e49
    128  0e49		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  0e4b		       c9 a2		      cmp	#tByte
    130  0e4d		       f0 15		      beq	CompByteLoad
    131  0e4f		       c9 a1		      cmp	#tInteger
    132  0e51		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  0e53		       68		      pla
    134  0e54		       4c d1 0d 	      jmp	CompileLoop	; Ignore the saved stack
    135  0e57				   CompIntLoad
    136  0e57		       c8		      iny
    137  0e58		       b1 59		      lda	(dpl),y
    138  0e5a		       85 52		      sta	R0
    139  0e5c		       c8		      iny
    140  0e5d		       b1 59		      lda	(dpl),y
    141  0e5f		       85 53		      sta	R0+1
    142  0e61		       4c 69 0e 	      jmp	CompFindLine
    143  0e64				   CompByteLoad
    144  0e64		       c8		      iny
    145  0e65		       b1 59		      lda	(dpl),y
    146  0e67		       85 52		      sta	R0
    147  0e69				   CompFindLine
    148  0e69		       20 75 1b 	      jsr	findLine
    149  0e6c		       f0 1d		      beq	CompFoundLine
    150  0e6e		       e6 52		      inc	R0	; number of errors
    151  0e70
    152  0e70		       a5 59		      lda	dpl
    153  0e72		       85 4f		      sta	CURPTR
    154  0e74		       a5 5a		      lda	dpl+1
    155  0e76		       85 50		      sta	CURPTR+1
    156  0e78		       84 51		      sty	CUROFF
    157  0e7a
    158  0e7a		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  0e7c		       a9 00		      lda	#0
    160  0e7e
    161  0e7e		       20 54 06 	      jsr	DisplayError
    162  0e81		       20 dd 14 	      jsr	PrintProgramLine
    163  0e84
    164  0e84		       68		      pla
    165  0e85		       a8		      tay
    166  0e86		       c8		      iny
    167  0e87		       c8		      iny
    168  0e88		       4c d1 0d 	      jmp	CompileLoop
    169  0e8b
    170  0e8b				   CompFoundLine
    171  0e8b		       68		      pla
    172  0e8c		       a8		      tay
    173  0e8d		       a5 4f		      lda	CURPTR
    174  0e8f		       91 59		      sta	(dpl),y
    175  0e91		       c8		      iny
    176  0e92		       a5 50		      lda	CURPTR+1
    177  0e94		       91 59		      sta	(dpl),y
    178  0e96		       c8		      iny
    179  0e97		       4c d1 0d 	      jmp	CompileLoop
    180  0e9a
    181  0e9a
    182  0e9a
    183  0e9a
    184  0e9a
    185  0e9a
    186  0e9a
    187  0e9a
    188  0e9a
    189  0e9a
    190  0e9a
    191  0e9a
    192  0e9a
    193  0e9a
    194  0e9a
    195  0e9a
    196  0e9a
    197  0e9a
    198  0e9a
    199  0e9a
    200  0e9a
    201  0e9a
    202  0e9a
    203  0e9a
    204  0e9a
    205  0e9a
    206  0e9a
    207  0e9a
    208  0e9a
    209  0e9a
    210  0e9a
    211  0e9a
    212  0e9a
    213  0e9a
    214  0e9a
    215  0e9a
    216  0e9a
    217  0e9a
    218  0e9a
    219  0e9a
    220  0e9a
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  0e9a					      include	"tokenizer.asm"
      1  0e9a					      seg	Code
      2  0e9a		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  0e9a
      4  0e9a							; Define the types of tokens found, and identifiers
      5  0e9a		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0e9a		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0e9a		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0e9a		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0e9a
     10  0e9a		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0e9a		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0e9a		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0e9a
     14  0e9a
     15  0e9a		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0e9a		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0e9a		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0e9a		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0e9a							; Arrays of string are arrays of pointers 2 bytes
     20  0e9a		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0e9a		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0e9a
     23  0e9a		       3c 3e	   Operators  BYTE.b	"<>"
     24  0e9c		       3c 3d		      BYTE.b	"<="
     25  0e9e		       3e 3d		      BYTE.b	">="
     26  0ea0		       3c 00		      BYTE.b	"<",0
     27  0ea2		       3d 00		      BYTE.b	"=",0
     28  0ea4		       3e 00		      BYTE.b	">",0
     29  0ea6		       2b 00		      BYTE.b	"+",0
     30  0ea8		       2d 00		      BYTE.b	"-",0
     31  0eaa		       2f 00		      BYTE.b	"/",0
     32  0eac		       25 00		      BYTE.b	"%",0
     33  0eae		       2a 00		      BYTE.b	"*",0
     34  0eb0		       28 00		      BYTE.b	"(",0
     35  0eb2		       29 00		      BYTE.b	")",0
     36  0eb4		       2c 00		      BYTE.b	",",0
     37  0eb6		       3b 00		      BYTE.b	";",0
     38  0eb8		       5b 00		      BYTE.b	"[",0
     39  0eba		       5d 00		      BYTE.b	"]",0
     40  0ebc		       3a 00		      BYTE.b	":",0
     41  0ebe		       24 00		      BYTE.b	"$",0
     42  0ec0		       21 00		      BYTE.b	"!",0
     43  0ec2		       3f 00		      BYTE.b	"?",0
     44  0ec4		       2e 00		      BYTE.b	".",0
     45  0ec6		       00 00		      BYTE.b	0,0
     46  0ec8
     47  0ec8		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     48  0ece		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     49  0ed3		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     50  0ed9		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     51  0ede
     52  0ede		       00 0b	   oQuestion  equ	kPrint
     53  0ede							;    2 is =
     54  0ede							;    1 is <
     55  0ede							;    3 is <=
     56  0ede							;    5 is <>
     57  0ede							;    4 is >
     58  0ede							;    6 is >=
     59  0ede		       00 f1	   oLess      equ	$F1
     60  0ede		       00 f2	   oEqual     equ	$F2
     61  0ede		       00 f3	   oLessEqual equ	$F3
     62  0ede		       00 f4	   oGreater   equ	$F4
     63  0ede		       00 f5	   oNotEqual  equ	$F5
     64  0ede		       00 f6	   oGreaterEqual equ	$F6
     65  0ede
     66  0ede		       00 e0	   oLeftBracket equ	$E0
     67  0ede		       00 e1	   oRightBracket equ	$E1
     68  0ede		       00 e2	   oComma     equ	$E2
     69  0ede		       00 e3	   oSemiColon equ	$E3
     70  0ede		       00 e4	   oLeftSQBracket equ	$E4
     71  0ede		       00 e5	   oRightSQBracket equ	$E5
     72  0ede		       00 e6	   oColon     equ	$E6
     73  0ede		       00 e7	   oDollar    equ	$E7
     74  0ede		       00 e8	   oBang      equ	$E8
     75  0ede		       00 e9	   oPeriod    equ	$E9
     76  0ede
     77  0ede
     78  0ede		       00 ea	   oPlus      equ	$EA
     79  0ede		       00 eb	   oMinus     equ	$EB
     80  0ede		       00 ec	   oDivide    equ	$EC
     81  0ede		       00 ed	   oModulo    equ	$ED
     82  0ede		       00 ee	   oMultiply  equ	$EE
     83  0ede
     84  0ede		       00 ed	   oPercent   equ	oModulo
     85  0ede
     86  0ede		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     87  0ede
     88  0ede		       00 ff	   tError     equ	$FF	; Error should never happen
     89  0ede							;============================================================================================
     90  0ede							; Keyword and seperator values
     91  0ede				   '
     92  0ede		       00 01	   kBeginKey  equ	kLet
     93  0ede							;
     94  0ede		       00 01	   kLet       equ	1
     95  0ede		       00 02	   kInc       equ	kLet+1
     96  0ede		       00 03	   kDec       equ	kInc+1
     97  0ede		       00 04	   kIreturn   equ	kDec+1
     98  0ede		       00 05	   kIf	      equ	kIreturn+1
     99  0ede		       00 06	   kThen      equ	kIf+1
    100  0ede		       00 07	   kGoto      equ	kThen+1
    101  0ede		       00 08	   kGosub     equ	kGoto+1
    102  0ede		       00 09	   kReturn    equ	kGosub+1
    103  0ede		       00 0a	   kRem       equ	kReturn+1
    104  0ede		       00 0b	   kPrint     equ	kRem+1
    105  0ede		       00 0c	   kTaske     equ	kPrint+1
    106  0ede		       00 0d	   kTaskn     equ	kTaske+1
    107  0ede		       00 0e	   kTaskw     equ	kTaskn+1
    108  0ede		       00 0f	   kPoke      equ	kTaskw+1
    109  0ede		       00 10	   kPutch     equ	kPoke+1
    110  0ede		       00 11	   kCls       equ	kPutch+1
    111  0ede		       00 12	   kInput     equ	kCls+1
    112  0ede		       00 13	   kEnd       equ	kInput+1
    113  0ede		       00 14	   kIrq       equ	kEnd+1
    114  0ede		       00 15	   kKill      equ	kIrq+1
    115  0ede		       00 16	   kList      equ	kKill+1
    116  0ede		       00 17	   kRun       equ	kList+1
    117  0ede		       00 18	   kNew       equ	kRun+1
    118  0ede		       00 19	   kSlice     equ	kNew+1
    119  0ede		       00 1a	   kTrace     equ	kSlice+1
    120  0ede		       00 1b	   kExit      equ	kTrace+1
    121  0ede		       00 1c	   kSave      equ	kExit+1
    122  0ede		       00 1d	   kLoad      equ	kSave+1
    123  0ede		       00 1e	   kErase     equ	kLoad+1
    124  0ede		       00 1f	   kDir       equ	kErase+1
    125  0ede							;
    126  0ede							; End of actual key words
    127  0ede							;
    128  0ede		       00 1e	   kKeyCount  equ	kDir-kBeginKey
    129  0ede							;
    130  0ede							; Logical operators
    131  0ede							;
    132  0ede		       00 20	   kNot       equ	kDir+1
    133  0ede		       00 21	   kOr	      equ	kNot+1
    134  0ede		       00 22	   kXor       equ	kOr+1
    135  0ede		       00 23	   kAnd       equ	kXor+1
    136  0ede
    137  0ede							; numeric functions
    138  0ede							;
    139  0ede		       00 24	   kBeginFunc equ	kTrue
    140  0ede							;
    141  0ede							; Truth operators
    142  0ede							;
    143  0ede		       00 24	   kTrue      equ	kAnd+1
    144  0ede		       00 25	   kFalse     equ	kTrue+1
    145  0ede							; Functions
    146  0ede		       00 26	   kFree      equ	kFalse+1
    147  0ede		       00 27	   kGetch     equ	kFree+1
    148  0ede		       00 28	   kPeek      equ	kGetch+1
    149  0ede		       00 29	   kTask      equ	kPeek+1
    150  0ede		       00 2a	   kIpcc      equ	kTask+1
    151  0ede		       00 2b	   kIpcs      equ	kIpcc+1
    152  0ede		       00 2c	   kIpcr      equ	kIpcs+1
    153  0ede		       00 2d	   kRnd       equ	kIpcr+1
    154  0ede		       00 2e	   kStat      equ	kRnd+1
    155  0ede		       00 2f	   kAbs       equ	kStat+1
    156  0ede		       00 30	   kCall      equ	kAbs+1
    157  0ede		       00 31	   kGofn      equ	kCall+1
    158  0ede		       00 32	   kPid       equ	kGofn+1
    159  0ede							;
    160  0ede		       00 0f	   kFuncCount equ	((kPid - kBeginFunc) + 1)
    161  0ede
    162  0ede							;
    163  0ede							; Keyword table contains 49 keywords
    164  0ede				   KeyWordTable
      0  0ede					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0ede		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0ee2					      db	kInc,"inC"
      1  0ee2		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0ee6					      db	kDec,"deC"
      1  0ee6		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0eea					      db	kIreturn,"ireturN"
      1  0eea		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0ef2					      db	kIf,"iF"
      1  0ef2		       05 69 46 	      .byte.b	kIf,"iF"
      0  0ef5					      db	kThen,"theN"
      1  0ef5		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0efa					      db	kGoto,"gotO"
      1  0efa		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0eff					      db	kGosub,"gosuB"
      1  0eff		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0f05					      db	kReturn,"returN"
      1  0f05		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0f0c					      db	kRem,"reM"
      1  0f0c		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0f10					      db	kPrint,"prinT"
      1  0f10		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0f16					      db	kTaske,"taskE"
      1  0f16		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0f1c					      db	kTaskn,"taskN"
      1  0f1c		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0f22					      db	kTaskw,"taskW"
      1  0f22		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0f28					      db	kPoke,"pokE"
      1  0f28		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0f2d					      db	kPutch,"putcH"
      1  0f2d		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0f33					      db	kCls,"clS"
      1  0f33		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0f37					      db	kInput,"inpuT"
      1  0f37		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0f3d					      db	kEnd,"enD"
      1  0f3d		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0f41					      db	kIrq,"irQ"
      1  0f41		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0f45					      db	kKill,"kilL"
      1  0f45		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0f4a					      db	kList,"lisT"
      1  0f4a		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0f4f					      db	kRun,"ruN"
      1  0f4f		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0f53					      db	kNew,"neW"
      1  0f53		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0f57					      db	kSlice,"slicE"
      1  0f57		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0f5d					      db	kTrace,"tracE"
      1  0f5d		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0f63					      db	kExit,"exiT"
      1  0f63		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0f68					      db	kSave,"savE"
      1  0f68		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0f6d					      db	kLoad,"loaD"
      1  0f6d		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0f72					      db	kErase,"erasE"
      1  0f72		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0f78					      db	kDir,"diR"
      1  0f78		       1f 64 69 52	      .byte.b	kDir,"diR"
    196  0f7c							;Short form for statements:
      0  0f7c					      db	kIreturn,"ireT"
      1  0f7c		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0f81					      db	kReturn,"reT"
      1  0f81		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  0f85					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  0f85		       0b 70 52 	      .byte.b	kPrint,"pR"
    200  0f88
    201  0f88							;Logical and truth operators
      0  0f88					      db	kNot,"noT"
      1  0f88		       20 6e 6f 54	      .byte.b	kNot,"noT"
      0  0f8c					      db	kOr,"oR"
      1  0f8c		       21 6f 52 	      .byte.b	kOr,"oR"
      0  0f8f					      db	kXor,"xoR"
      1  0f8f		       22 78 6f 52	      .byte.b	kXor,"xoR"
      0  0f93					      db	kAnd,"anD"
      1  0f93		       23 61 6e 44	      .byte.b	kAnd,"anD"
    206  0f97							; Truth values
      0  0f97					      db	kTrue,"truE"
      1  0f97		       24 74 72 75*	      .byte.b	kTrue,"truE"
      0  0f9c					      db	kFalse,"falsE"
      1  0f9c		       25 66 61 6c*	      .byte.b	kFalse,"falsE"
    209  0fa2
    210  0fa2							;functions returning values
    211  0fa2
      0  0fa2					      db	kFree,"freE"
      1  0fa2		       26 66 72 65*	      .byte.b	kFree,"freE"
      0  0fa7					      db	kGetch,"getcH"
      1  0fa7		       27 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0fad					      db	kPeek,"peeK"
      1  0fad		       28 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0fb2					      db	kTask,"tasK"
      1  0fb2		       29 74 61 73*	      .byte.b	kTask,"tasK"
      0  0fb7					      db	kIpcc,"ipcC"
      1  0fb7		       2a 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0fbc					      db	kIpcs,"ipcS"
      1  0fbc		       2b 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0fc1					      db	kIpcr,"ipcR"
      1  0fc1		       2c 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0fc6					      db	kRnd,"rnD"
      1  0fc6		       2d 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0fca					      db	kStat,"staT"
      1  0fca		       2e 73 74 61*	      .byte.b	kStat,"staT"
      0  0fcf					      db	kAbs,"abS"
      1  0fcf		       2f 61 62 53	      .byte.b	kAbs,"abS"
      0  0fd3					      db	kCall,"calL"
      1  0fd3		       30 63 61 6c*	      .byte.b	kCall,"calL"
      0  0fd8					      db	kGofn,"gofN"
      1  0fd8		       31 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0fdd					      db	kPid,"piD"
      1  0fdd		       32 70 69 44	      .byte.b	kPid,"piD"
      0  0fe1					      db	0,0
      1  0fe1		       00 00		      .byte.b	0,0
    226  0fe3
    227  0fe3		       0f e3	   KeyWordTableEnd equ	*
    228  0fe3		       01 05	   KeyWordTableLength equ	* - KeyWordTable
    229  0fe3		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    230  10e3		       00 00 00    printStorage ds	3
    231  10e6							;==================================================================================================================
    232  10e6							; Read accross the inputline and output to TOKENBUFFER
    233  10e6							; Format   byte      Description
    234  10e6							;	     0	      length of line 1-255
    235  10e6							;	    0-1       Line Number
    236  10e6							;	    Tokens and litteral values encoded into the line
    237  10e6							;
    238  10e6							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    239  10e6							;  if fails then test for keywords
    240  10e6							;  if fails then test for variables and arrays
    241  10e6							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    242  10e6
    243  10e6				   ParseInputLine
    244  10e6				  -	      if	DEBUGPARSER
    245  10e6				  -	      jsr	SetOutDebug
    246  10e6				  -	      jsr	DebugClearBuffer
    247  10e6					      endif
    248  10e6		       a5 51		      lda	CUROFF
    249  10e8		       48		      pha
    250  10e9		       8a		      txa
    251  10ea		       48		      pha
    252  10eb		       98		      tya
    253  10ec		       48		      pha
    254  10ed		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    255  10ef		       20 db 1b 	      jsr	getDecimal	; Check for a line number, none is ok too
    256  10f2		       84 51		      sty	CUROFF
    257  10f4		       20 b2 12 	      jsr	R02TOKEN	; Move R0 to token buffer
    258  10f7
    259  10f7				   ParseInputLoop
    260  10f7		       a4 51		      ldy	CUROFF
    261  10f9		       20 6b 1e 	      jsr	SkipSpaces	; Skip any spaces
    262  10fc		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    263  10fe		       b9 22 2f 	      lda	LINBUF,y	; Check for end of line
    264  1101		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    265  1103
    266  1103				   ParseForNumber
    267  1103		       20 06 12 	      jsr	ParseNumeric	; Check for a numeric value
    268  1106		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    269  1108
    270  1108				   ParseForString
    271  1108		       20 dc 11 	      jsr	ParseString	; Check for a string
    272  110b		       90 ea		      bcc	ParseInputLoop	; It was a string
    273  110d
    274  110d				   ParseForOp
    275  110d		       20 44 12 	      jsr	ParseForOperator	; Check for operator or punctuation
    276  1110		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    277  1112
    278  1112				   ParseForKey
    279  1112		       20 39 11 	      jsr	ParseLookupKey	; Check for a keyword value
    280  1115		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    281  1117
    282  1117				   ParseForVar
    283  1117		       20 7b 12 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    284  111a		       90 db		      bcc	ParseInputLoop
    285  111c
    286  111c				   ParseKeepChar		; if it does not parse just keep it safe
    287  111c		       b9 22 2f 	      lda	LINBUF,y
    288  111f		       9d e3 0f 	      sta	TOKENBUFFER,x
    289  1122		       e8		      inx
    290  1123		       c8		      iny
    291  1124		       84 51		      sty	CUROFF
    292  1126		       d0 cf		      bne	ParseInputLoop
    293  1128
    294  1128				   ParseComplete
    295  1128		       a9 00		      lda	#0
    296  112a		       9d e3 0f 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    297  112d		       e8		      inx
    298  112e		       8e e3 0f 	      stx	TOKENBUFFER	; Place size including null into buffer start
    299  1131
    300  1131		       68		      pla
    301  1132		       a8		      tay
    302  1133		       68		      pla
    303  1134		       aa		      tax
    304  1135		       68		      pla
    305  1136		       85 51		      sta	CUROFF
    306  1138
    307  1138				  -	      if	DEBUGPARSER
    308  1138				  -
    309  1138				  -	      jsr	printTokenBuffer
    310  1138				  -			;jsr	  DebugPrintProgramLine
    311  1138				  -	      jsr	SetOutDebugEnd
    312  1138				  -
    313  1138					      endif
    314  1138		       60		      rts
    315  1139
    316  1139							;==================================================================================================================
    317  1139							; Look at curptr, curpos and check for a valid KeyWord
    318  1139							; A contains the index value. c is clear
    319  1139							;		     not found c set  A undefined
    320  1139							; X is prerserved
    321  1139							;
    322  1139				   ParseLookupKey
    323  1139		       86 58		      stx	R2
    324  113b		       a0 00		      ldy	#0
    325  113d		       a9 de		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    326  113f		       85 54		      sta	R1
    327  1141		       a9 0e		      lda	#KeyWordTable>>8
    328  1143		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    329  1145		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    330  1147		       85 52		      sta	R0	; Save until next keyword
    331  1149		       c8		      iny		; Point to first character of keyword
    332  114a		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    333  114c
    334  114c				  -	      if	DEBUGPARSER
    335  114c				  -			;    jsr DebugKeyword
    336  114c					      endif
    337  114c
    338  114c				   ParseLookupLoop
    339  114c		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    340  114e		       29 df		      and	#%11011111	; Force Keyword to upper case
    341  1150		       dd 22 2f 	      cmp	LINBUF,x	; Check the input buffer
    342  1153		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    343  1155		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    344  1157		       dd 22 2f 	      cmp	LINBUF,x	; Compare value to upercase
    345  115a		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    346  115c
    347  115c				   ParseNextLetter
    348  115c		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    349  115e		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    350  1160		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    351  1162		       e8		      inx		; Point to next char in the input buffer
    352  1163		       c8		      iny		; Point to the next character in the Keyword table
    353  1164		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    354  1166		       dd 22 2f 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    355  1169		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    356  116b		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    357  116d
    358  116d				   ParseKeyFound
    359  116d		       a5 52		      lda	R0	; get the keyword index
    360  116f
    361  116f				   ParseKeyDone
    362  116f		       e8		      inx		; point past the last character
    363  1170		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    364  1172		       a6 58		      ldx	R2	; Restore the original x pointer
    365  1174		       9d e3 0f 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    366  1177		       e8		      inx		; Point to next position in the output buffer
    367  1178		       86 58		      stx	R2	; Save next position in buffer
    368  117a		       c9 0a		      cmp	#kRem	; remark statement
    369  117c		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    370  117e		       c9 07		      cmp	#kGoto
    371  1180		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    372  1182		       c9 08		      cmp	#kGosub
    373  1184		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    374  1186		       c9 31		      cmp	#kGofn
    375  1188		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    376  118a		       c9 29		      cmp	#kTask
    377  118c		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    378  118e
    379  118e		       18		      clc		; C flag clear, we found it
    380  118f		       60		      rts
    381  1190
    382  1190							; Move forward to the next entry in table
    383  1190				   ParseNextEntry
    384  1190		       b1 54		      lda	(R1),y	; Get the next character in the token
    385  1192		       29 20		      and	#%00100000	; Is it the last character
    386  1194		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    387  1196		       c8		      iny		; Point to next char in the entry
    388  1197		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    389  1199
    390  1199				   ParseEndOfEntry
    391  1199		       c8		      iny		; Point to the byte after the last character
    392  119a		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    393  119b		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    394  119c		       65 54		      adc	R1
    395  119e		       85 54		      sta	R1
    396  11a0		       a5 55		      lda	R1+1
    397  11a2		       69 00		      adc	#0
    398  11a4		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    399  11a6		       a0 00		      ldy	#0	; Reset the index back to zero
    400  11a8		       b1 54		      lda	(R1),y	; get keyword value
    401  11aa		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    402  11ac		       85 52		      sta	R0	; save the next token value
    403  11ae		       c8		      iny		; Inc past token value
    404  11af
    405  11af				  -	      if	DEBUGPARSER
    406  11af				  -			;    jsr DebugKeyword
    407  11af					      endif
    408  11af		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    409  11b1		       4c 4c 11 	      jmp	ParseLookupLoop	; branch back for next key word
    410  11b4
    411  11b4				   ParseNoneFound
    412  11b4		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    413  11b6		       38		      sec		; c clear, not found
    414  11b7		       60		      rts
    415  11b8
    416  11b8							;===============================================================================
    417  11b8							; Move everything from current position until the end of line into the token buffer
    418  11b8							;
    419  11b8		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    420  11ba		       a6 58		      ldx	R2	; where to place in the buffer
    421  11bc				   ParseMoveLoop
    422  11bc		       b9 22 2f 	      lda	LINBUF,y	; get the next byte
    423  11bf		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    424  11c1		       9d e3 0f 	      sta	TOKENBUFFER,x	; save the byte
    425  11c4		       c8		      iny
    426  11c5		       e8		      inx
    427  11c6		       d0 f4		      bne	ParseMoveLoop
    428  11c8				   ParseMoveDone
    429  11c8		       84 51		      sty	CUROFF
    430  11ca		       18		      clc
    431  11cb		       60		      rts
    432  11cc							;================================================================================================
    433  11cc							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    434  11cc							; transfer to a memory address
    435  11cc				   ParseHandleBranches
    436  11cc		       a6 58		      ldx	R2
    437  11ce		       a9 00		      lda	#0
    438  11d0		       9d e3 0f 	      sta	TOKENBUFFER,x
    439  11d3		       e8		      inx
    440  11d4		       9d e3 0f 	      sta	TOKENBUFFER,x
    441  11d7		       e8		      inx
    442  11d8		       86 58		      stx	R2
    443  11da		       18		      clc
    444  11db		       60		      rts
    445  11dc
    446  11dc							;=========================================================================================================
    447  11dc							;ParseString Parse a quotes string
    448  11dc							; on input X = outbuf position
    449  11dc							; y = inbuf position
    450  11dc							; Copies string to output buffer, updates x and y
    451  11dc				   ParseString
    452  11dc		       a4 51		      ldy	CUROFF
    453  11de		       a9 a0		      lda	#tString
    454  11e0		       9d e3 0f 	      sta	TOKENBUFFER,X
    455  11e3		       b9 22 2f 	      lda	LINBUF,y
    456  11e6		       c9 22		      cmp	#'"
    457  11e8		       d0 1a		      bne	ParseStringInvalid
    458  11ea		       e8		      inx
    459  11eb		       9d e3 0f 	      sta	TOKENBUFFER,x
    460  11ee		       e8		      inx
    461  11ef		       c8		      iny
    462  11f0
    463  11f0				   ParseStringLoop
    464  11f0		       b9 22 2f 	      lda	LINBUF,y
    465  11f3		       9d e3 0f 	      sta	TOKENBUFFER,x
    466  11f6		       c9 22		      cmp	#'"
    467  11f8		       f0 04		      beq	ParseStringDone
    468  11fa		       c8		      iny
    469  11fb		       e8		      inx
    470  11fc		       d0 f2		      bne	ParseStringLoop
    471  11fe
    472  11fe				   ParseStringDone
    473  11fe		       e8		      inx
    474  11ff		       c8		      iny
    475  1200		       84 51		      sty	CUROFF
    476  1202		       18		      clc
    477  1203		       60		      rts
    478  1204
    479  1204				   ParseStringInvalid
    480  1204		       38		      sec
    481  1205		       60		      rts
    482  1206
    483  1206							;=========================================================================================================
    484  1206							; Get numeric values and return value in RO and type in a
    485  1206							;
    486  1206				   ParseNumeric
    487  1206		       a4 51		      ldy	CUROFF
    488  1208		       b9 22 2f 	      lda	LINBUF,y
    489  120b		       c9 30		      cmp	#'0
    490  120d		       90 33		      bcc	ParseNumInvalid
    491  120f		       c9 3a		      cmp	#'9+1
    492  1211		       b0 2f		      bcs	ParseNumInvalid
    493  1213		       86 58		      stx	R2
    494  1215		       20 db 1b 	      jsr	getDecimal
    495  1218		       a6 58		      ldx	R2
    496  121a		       84 51		      sty	CUROFF
    497  121c		       a5 53		      lda	R0+1
    498  121e		       f0 14		      beq	ParseByteValue
    499  1220
    500  1220				   ParseIntegerValue
    501  1220		       a9 a1		      lda	#tInteger
    502  1222		       9d e3 0f 	      sta	TOKENBUFFER,x
    503  1225		       e8		      inx
    504  1226		       a5 52		      lda	R0
    505  1228		       9d e3 0f 	      sta	TOKENBUFFER,x
    506  122b		       e8		      inx
    507  122c		       a5 53		      lda	R0+1
    508  122e		       9d e3 0f 	      sta	TOKENBUFFER,X
    509  1231		       e8		      inx
    510  1232		       18		      clc
    511  1233		       60		      rts
    512  1234
    513  1234				   ParseByteValue
    514  1234		       a9 a2		      lda	#tByte
    515  1236		       9d e3 0f 	      sta	TOKENBUFFER,x
    516  1239		       e8		      inx
    517  123a		       a5 52		      lda	R0
    518  123c		       9d e3 0f 	      sta	TOKENBUFFER,x
    519  123f		       e8		      inx
    520  1240		       18		      clc
    521  1241		       60		      rts
    522  1242
    523  1242				   ParseNumInvalid		;Not a valid Numeric
    524  1242		       38		      sec
    525  1243		       60		      rts
    526  1244
    527  1244							;=========================================================================================================
    528  1244							;Parse for operators and seperators
    529  1244							; on exit the A has the oper code, c is clear
    530  1244							;		 not found then c is set
    531  1244							;	x is preserved
    532  1244							;
    533  1244				   ParseForOperator
    534  1244		       86 58		      stx	R2
    535  1246		       a4 51		      ldy	CUROFF
    536  1248		       a2 00		      ldx	#0
    537  124a				  -	      if	DEBUGPARSER
    538  124a				  -			;	jsr    DebugPrintOP
    539  124a					      endif
    540  124a
    541  124a				   ParseOpLoop
    542  124a		       bd 9a 0e 	      lda	Operators,x	; First byte of operator
    543  124d		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    544  124f
    545  124f		       d9 22 2f 	      cmp	LINBUF,y	; Check the first byte
    546  1252		       d0 1c		      bne	ParseOpNext
    547  1254
    548  1254		       c8		      iny
    549  1255
    550  1255		       bd 9b 0e 	      lda	Operators+1,x
    551  1258		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    552  125a
    553  125a		       d9 22 2f 	      cmp	LINBUF,y
    554  125d		       d0 11		      bne	ParseOpNext
    555  125f
    556  125f				   ParseOpFound
    557  125f		       c8		      iny
    558  1260
    559  1260				   ParseOpFoundSingle
    560  1260		       84 51		      sty	CUROFF
    561  1262
    562  1262		       8a		      txa
    563  1263		       4a		      lsr
    564  1264		       aa		      tax
    565  1265		       bd c8 0e 	      lda	OperValues,x
    566  1268		       a6 58		      ldx	R2
    567  126a		       9d e3 0f 	      sta	TOKENBUFFER,x
    568  126d		       e8		      inx
    569  126e		       18		      clc
    570  126f		       60		      rts
    571  1270
    572  1270				   ParseOpNext
    573  1270		       e8		      inx
    574  1271		       e8		      inx
    575  1272
    576  1272				  -	      if	DEBUGPARSER
    577  1272				  -			;	 jsr	DebugPrintOP
    578  1272					      endif
    579  1272		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    580  1274		       4c 4a 12 	      jmp	ParseOpLoop
    581  1277
    582  1277				   ParseOpNotFound
    583  1277		       a6 58		      ldx	R2
    584  1279		       38		      sec
    585  127a		       60		      rts
    586  127b							;=========================================================================================================
    587  127b				  -	      if	DEBUGPARSER
    588  127b				  -			;Print the text of a keyword
    589  127b				  -			;Input R1    = offset into table
    590  127b				  -DebugKeyword
    591  127b				  -	      tya
    592  127b				  -	      pha
    593  127b				  -	      ldy	#1
    594  127b				  -DebugKeyLoop
    595  127b				  -	      lda	(R1),y
    596  127b				  -	      jsr	VOUTCH
    597  127b				  -	      and	#%00100000
    598  127b				  -	      beq	DebugKeyDone
    599  127b				  -	      iny
    600  127b				  -	      bne	DebugKeyLoop
    601  127b				  -
    602  127b				  -DebugKeyDone
    603  127b				  -	      jsr	CRLF
    604  127b				  -	      pla
    605  127b				  -	      tay
    606  127b				  -	      rts
    607  127b				  -			;========================================
    608  127b				  -DebugPrintOP
    609  127b				  -	      pha
    610  127b				  -	      lda	Operators,x
    611  127b				  -	      jsr	VOUTCH
    612  127b				  -	      lda	Operators+1,x
    613  127b				  -	      beq	DbgPrtOpDone
    614  127b				  -	      jsr	VOUTCH
    615  127b				  -
    616  127b				  -DbgPrtOpDone
    617  127b				  -	      jsr	CRLF
    618  127b				  -	      pla
    619  127b				  -	      rts
    620  127b				  -			;=======================================
    621  127b				  -DebugClearBuffer
    622  127b				  -	      txa
    623  127b				  -	      pha
    624  127b				  -	      ldx	#$FF
    625  127b				  -	      lda	#0
    626  127b				  -DebugClrLoop
    627  127b				  -	      sta	TOKENBUFFER,x
    628  127b				  -	      dex
    629  127b				  -	      bne	DebugClrLoop
    630  127b				  -	      sta	TOKENBUFFER,x
    631  127b				  -	      pla
    632  127b				  -	      tax
    633  127b				  -	      rts
    634  127b				  -
    635  127b				  -			;=====================================================
    636  127b				  -			; Print the parser buffer as hex values
    637  127b				  -printTokenBuffer
    638  127b				  -	      stx	printStorage
    639  127b				  -	      sty	printStorage+1
    640  127b				  -	      sta	printStorage+2
    641  127b				  -
    642  127b				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    643  127b				  -	      inx		; we want to show the last zero byte
    644  127b				  -	      ldy	#0
    645  127b				  -
    646  127b				  -printHexLoop
    647  127b				  -	      lda	TOKENBUFFER,y	; get the character
    648  127b				  -	      jsr	HexToOut	; print it
    649  127b				  -	      lda	#$20
    650  127b				  -	      jsr	VOUTCH
    651  127b				  -	      iny
    652  127b				  -	      dex
    653  127b				  -	      cpx	#0
    654  127b				  -	      bne	printHexLoop
    655  127b				  -	      jsr	CRLF
    656  127b				  -
    657  127b				  -	      ldy	printStorage+1
    658  127b				  -	      ldx	printStorage
    659  127b				  -	      lda	printStorage+2
    660  127b				  -printHexDone
    661  127b				  -	      clc
    662  127b				  -	      rts
    663  127b					      endif
    664  127b
    665  127b
    666  127b							;=========================================================================================================
    667  127b							; Parse for variables A-Z @, ^  x!x x[op]
    668  127b				   ParseForVariable
    669  127b		       a4 51		      ldy	CUROFF
    670  127d		       b9 22 2f 	      lda	LINBUF,y
    671  1280		       c9 5e		      cmp	#'^	; is it an exit code
    672  1282		       d0 04		      bne	ParseVarMem
    673  1284		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    674  1286		       d0 1f		      bne	ParseVarSpecial
    675  1288
    676  1288				   ParseVarMem
    677  1288		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    678  128a		       d0 04		      bne	ParseVarStack
    679  128c		       a9 9d		      lda	#tVat
    680  128e		       d0 17		      bne	ParseVarSpecial
    681  1290
    682  1290				   ParseVarStack
    683  1290		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    684  1292		       d0 04		      bne	ParseVarLetters
    685  1294		       a9 9c		      lda	#tVhash
    686  1296		       d0 0f		      bne	ParseVarSpecial
    687  1298
    688  1298				   ParseVarLetters
    689  1298		       29 df		      and	#%11011111	; Force upper case
    690  129a		       c9 41		      cmp	#'A
    691  129c		       90 12		      bcc	ParseVarInvalid
    692  129e		       c9 5b		      cmp	#'Z+1
    693  12a0		       b0 0e		      bcs	ParseVarInvalid
    694  12a2							;
    695  12a2							; The condition is true, so convert to an index, push
    696  12a2							; it onto the stack and continue running.
    697  12a2							;
    698  12a2		       38		      sec
    699  12a3		       e9 41		      sbc	#'A	;index is zero based
    700  12a5		       09 80		      ora	#$80
    701  12a7
    702  12a7				   ParseVarSpecial
    703  12a7		       9d e3 0f 	      sta	TOKENBUFFER,x
    704  12aa		       e8		      inx
    705  12ab		       c8		      iny
    706  12ac		       84 51		      sty	CUROFF
    707  12ae		       18		      clc
    708  12af		       60		      rts
    709  12b0
    710  12b0				   ParseVarInvalid
    711  12b0		       38		      sec
    712  12b1		       60		      rts
    713  12b2
    714  12b2
    715  12b2							;=========================================================================================================
    716  12b2							; Transfer R0 to the TOKENBUFFER
    717  12b2							;
    718  12b2				   R02TOKEN
    719  12b2		       a5 52		      lda	R0
    720  12b4		       9d e3 0f 	      sta	TOKENBUFFER,x
    721  12b7		       e8		      inx
    722  12b8		       a5 53		      lda	R0+1
    723  12ba		       9d e3 0f 	      sta	TOKENBUFFER,x
    724  12bd		       e8		      inx
    725  12be		       18		      clc
    726  12bf		       60		      rts
    727  12c0							;=========================================================================
    728  12c0							; Transfer word in Token Buffer to R0
    729  12c0				   TOKEN2R0
    730  12c0		       b9 e3 0f 	      lda	TOKENBUFFER,y
    731  12c3		       85 52		      sta	R0
    732  12c5		       c8		      iny
    733  12c6		       ca		      dex
    734  12c7		       b9 e3 0f 	      lda	TOKENBUFFER,y
    735  12ca		       c8		      iny
    736  12cb		       ca		      dex
    737  12cc		       85 53		      sta	R0+1
    738  12ce		       60		      rts
    739  12cf							;==========================================================================
    740  12cf							; Transfer	Display Buffer position to R0
    741  12cf							;
    742  12cf				   DPL2R0
    743  12cf		       b1 59		      lda	(dpl),y
    744  12d1		       85 52		      sta	R0
    745  12d3		       c8		      iny
    746  12d4		       ca		      dex
    747  12d5		       b1 59		      lda	(dpl),y
    748  12d7		       c8		      iny
    749  12d8		       ca		      dex
    750  12d9		       85 53		      sta	R0+1
    751  12db		       60		      rts
    752  12dc
    753  12dc
    754  12dc							;=========================================================================
    755  12dc							; Read an IL byte lookit up in the table, of words
    756  12dc							; set the next ilpc to point to that address
    757  12dc							; if not found then do ussual filter stuff
    758  12dc							; ongoto ilvectortable, not found address
    759  12dc		       20 2c 1b    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    760  12df		       86 52		      stx	R0
    761  12e1		       85 53		      sta	R0+1
    762  12e3
    763  12e3		       a4 51		      ldy	CUROFF
    764  12e5		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    765  12e7		       a0 00		      ldy	#0
    766  12e9		       38		      sec
    767  12ea		       f1 52		      sbc	(R0),y	; Subract the base value
    768  12ec		       c8		      iny
    769  12ed		       d1 52		      cmp	(R0),y	; Check if we are in range
    770  12ef		       b0 12		      bcs	iOnGotoInvalid
    771  12f1		       e6 51		      inc	CUROFF	; Save the offset
    772  12f3
    773  12f3		       0a		      asl
    774  12f4		       a8		      tay		; Turn into vector
    775  12f5		       c8		      iny		; Inc must include the table base and entry count
    776  12f6		       c8		      iny
    777  12f7
    778  12f7		       b1 52		      lda	(R0),y
    779  12f9		       85 43		      sta	ILPC
    780  12fb		       c8		      iny
    781  12fc		       b1 52		      lda	(R0),y
    782  12fe		       85 44		      sta	ILPC+1
    783  1300		       4c c3 02 	      jmp	NextIL
    784  1303
    785  1303				   iOnGotoInvalid
    786  1303		       20 2c 1b 	      jsr	getILWord
    787  1306		       86 43		      stx	ILPC
    788  1308		       85 44		      sta	ILPC+1
    789  130a		       4c c3 02 	      jmp	NextIL
    790  130d							;
    791  130d							;==========================================================================================
    792  130d							; Test the token for relop and push the value onto the stack if true
    793  130d							;
    794  130d				   iTSTRELOP
    795  130d		       20 30 1b 	      jsr	getILByte
    796  1310		       8d bb 2f 	      sta	offset
    797  1313
    798  1313		       a4 51		      ldy	CUROFF
    799  1315		       b1 4f		      lda	(CURPTR),y
    800  1317		       48		      pha
    801  1318		       29 f0		      and	#$F0
    802  131a		       c9 f0		      cmp	#$F0
    803  131c		       d0 12		      bne	iTSTRELOPNOT
    804  131e		       68		      pla
    805  131f		       29 0f		      and	#$0F	; get the actual value
    806  1321		       85 52		      sta	R0	; save it for later
    807  1323		       a9 00		      lda	#0
    808  1325		       85 53		      sta	R0+1
    809  1327		       20 29 1d 	      jsr	pushR0
    810  132a		       c8		      iny
    811  132b		       84 51		      sty	CUROFF	; save the y pointer
    812  132d		       4c c3 02 	      jmp	NextIL
    813  1330
    814  1330				   iTSTRELOPNOT
    815  1330		       68		      pla
    816  1331		       4c ad 0b 	      jmp	tstBranch
    817  1334
    818  1334							;
    819  1334							;===================================================================================================
    820  1334							; Test the token and following info for precompiled address information
    821  1334							; skip it if zero, transfer and skip next integer value if not zero
    822  1334							; used by both gosub, goto and gofN
    823  1334							;
    824  1334				   iTSTBRANCH
    825  1334		       20 30 1b 	      jsr	getILByte	; Get jump address if vector is valid
    826  1337		       8d bb 2f 	      sta	offset	; Mark offset for later if vector found
    827  133a		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    828  133c		       88		      dey		; point back to the type of branch
    829  133d		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    830  133f		       48		      pha		; Save till needed
    831  1340		       c8		      iny		; back to memory vectors
    832  1341				   ITSTBRANCHCont
    833  1341		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    834  1343		       85 52		      sta	R0	; R0 will contain mem pointer of present
    835  1345		       c8		      iny		; Point to next byte of mem vector
    836  1346		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    837  1348		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    838  134a		       c8		      iny		; Point to the byte past memory vector
    839  134b		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    840  134d
    841  134d		       05 52		      ora	R0	; Get the second byte of the mem
    842  134f		       f0 21		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    843  1351		       68		      pla
    844  1352		       c9 29		      cmp	#kTask	; Task defied with Task() so bypass the first bracket
    845  1354		       d0 07		      bne	iTSTBRANCHCont
    846  1356		       b1 4f		      lda	(CURPTR),y
    847  1358		       c9 e0		      cmp	#oLeftBracket
    848  135a		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    849  135c		       c8		      iny		; Increment past the bracket
    850  135d				   iTSTBRANCHCont
    851  135d		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    852  135f		       c9 a2		      cmp	#tByte	; A byte value is valid
    853  1361		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    854  1363		       c9 a1		      cmp	#tInteger	; An integer value is valid
    855  1365		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    856  1367		       c8		      iny		; skip type indicator for
    857  1368				   ITSTBRANCHBYTE
    858  1368		       c8		      iny		; skip first byte of value line number
    859  1369		       c8		      iny		; Skip second byte of line number
    860  136a
    861  136a				   iTSTBRANCHVALID
    862  136a		       84 51		      sty	CUROFF
    863  136c		       20 29 1d 	      jsr	pushR0	; place transfer address on top of stack
    864  136f		       4c ad 0b 	      jmp	tstBranch
    865  1372
    866  1372				   iTSTBRANCHNoCompile
    867  1372		       68		      pla
    868  1373				   iTSTBRANCHErr
    869  1373		       4c c3 02 	      jmp	NextIL
    870  1376
    871  1376
    872  1376
    873  1376
    874  1376
    875  1376
    876  1376
    877  1376
    878  1376
    879  1376
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  1376					      include	"print.asm"
      1  1376					      Seg	Code
      2  1376							;---------------------------
      3  1376							; Print 24-bit decimal number or  16bit unsigned
      4  1376							; ---------------------------
      5  1376							; On entry, R0=number to print
      6  1376							;	     Defaults to pad=0 , y=21 default
      7  1376							;	     R2 = 1 unsigned 16 bit
      8  1376							;	     R2 = 0 Signed   16 bit
      9  1376
     10  1376							; On entry at PrintDecPadded:
     11  1376							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  1376
     13  1376							; On exit,  A,X,Y,num,pad corrupted
     14  1376							; Size      129 bytes, Table 24 bytes	--- total 153
     15  1376							; -----------------------------------------------------------------
     16  1376
     17  1376				   PrintDecimal
     18  1376		       8a		      TXA
     19  1377		       48		      pha
     20  1378		       98		      tya
     21  1379		       48		      pha
     22  137a		       a9 00		      lda	#0
     23  137c		       8d 0f 14 	      sta	pad
     24  137f		       a0 15		      LDY	#21	; Offset to powers of ten
     25  1381		       4c 87 13 	      JMP	PrintDo
     26  1384
     27  1384				   PrintDecPadded
     28  1384		       8e 0f 14 	      stx	pad
     29  1387
     30  1387				   PrintDo
     31  1387		       a9 00		      lda	#0
     32  1389		       85 54		      sta	R1
     33  138b
     34  138b		       a5 58		      lda	R2
     35  138d		       d0 29		      bne	PrintPos
     36  138f
     37  138f		       a5 53		      lda	R0+1	;MSB has sign
     38  1391		       10 25		      bpl	PrintPos	;it's a positive number;
     39  1393
     40  1393
     41  1393							; Negative numbers need more work.  Invert all the bits,
     42  1393							; then add one.
     43  1393
     44  1393		       a9 2d		      lda	#'-
     45  1395		       20 c2 1f 	      jsr	VOUTCH	;print the negative sign
     46  1398
     47  1398		       a9 ff		      lda	#$FF
     48  139a		       85 54		      sta	R1
     49  139c		       a5 52		      lda	R0	;invert bits
     50  139e		       49 ff		      eor	#$ff
     51  13a0		       85 52		      sta	R0
     52  13a2		       a5 53		      lda	R0+1
     53  13a4		       49 ff		      eor	#$ff
     54  13a6		       85 53		      sta	R0+1
     55  13a8		       a5 54		      lda	R1
     56  13aa		       49 ff		      eor	#$ff
     57  13ac		       85 54		      sta	R1
     58  13ae		       e6 52		      inc	R0	;add one
     59  13b0		       d0 06		      bne	PrintPos
     60  13b2		       e6 53		      inc	R0+1
     61  13b4		       d0 02		      bne	PrintPos
     62  13b6		       e6 54		      inc	R1
     63  13b8				   PrintPos
     64  13b8
     65  13b8				   PrDec24Lp1
     66  13b8		       a2 ff		      LDX	#$FF
     67  13ba		       38		      SEC		; Start with digit=-1
     68  13bb				   PrDec24Lp2
     69  13bb		       a5 52		      LDA	R0+0
     70  13bd		       f9 10 14 	      SBC	PrDec24Tens+0,Y
     71  13c0		       85 52		      STA	R0+0	; Subtract current tens
     72  13c2		       a5 53		      LDA	R0+1
     73  13c4		       f9 11 14 	      SBC	PrDec24Tens+1,Y
     74  13c7		       85 53		      STA	R0+1
     75  13c9		       a5 54		      LDA	R0+2
     76  13cb		       f9 12 14 	      SBC	PrDec24Tens+2,Y
     77  13ce		       85 54		      STA	R0+2
     78  13d0		       e8		      INX
     79  13d1		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  13d3		       a5 52		      LDA	R0+0
     81  13d5		       79 10 14 	      ADC	PrDec24Tens+0,Y
     82  13d8		       85 52		      STA	R0+0	; Add current tens back in
     83  13da		       a5 53		      LDA	R0+1
     84  13dc		       79 11 14 	      ADC	PrDec24Tens+1,Y
     85  13df		       85 53		      STA	R0+1
     86  13e1		       a5 54		      LDA	R0+2
     87  13e3		       79 12 14 	      ADC	PrDec24Tens+2,Y
     88  13e6		       85 54		      STA	R0+2
     89  13e8		       8a		      TXA
     90  13e9		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  13eb		       ad 0f 14 	      LDA	pad
     92  13ee		       d0 09		      BNE	PrDec24Print
     93  13f0		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  13f2				   PrDec24Digit
     95  13f2		       a2 30		      LDX	#'0
     96  13f4		       8e 0f 14 	      STX	pad	; No more zero padding
     97  13f7		       09 30		      ORA	#'0	; Print this digit
     98  13f9				   PrDec24Print
     99  13f9		       20 c2 1f 	      JSR	VOUTCH
    100  13fc				   PrDec24Next
    101  13fc		       88		      DEY
    102  13fd		       88		      DEY
    103  13fe		       88		      DEY
    104  13ff		       f0 07		      beq	PrDec24LastDigit
    105  1401		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  1403		       68		      pla
    107  1404		       a8		      tay
    108  1405		       68		      pla
    109  1406		       aa		      tax
    110  1407		       60		      RTS
    111  1408				   PrDec24LastDigit
    112  1408		       a2 30		      LDX	#'0
    113  140a		       8e 0f 14 	      STX	pad	; No more zero padding
    114  140d		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  140f
      0  140f				   pad	      db	0
      1  140f		       00		      .byte.b	0
    117  1410
    118  1410				   PrDec24Tens
      0  1410					      dw	1
      1  1410		       01 00		      .word.w	1
      0  1412					      db	(1 / 65536)
      1  1412		       00		      .byte.b	(1 / 65536)
      0  1413					      dw	10
      1  1413		       0a 00		      .word.w	10
      0  1415					      db	(10 / 65536)
      1  1415		       00		      .byte.b	(10 / 65536)
      0  1416					      dw	100
      1  1416		       64 00		      .word.w	100
      0  1418					      db	(100 / 65536)
      1  1418		       00		      .byte.b	(100 / 65536)
      0  1419					      dw	1000
      1  1419		       e8 03		      .word.w	1000
      0  141b					      db	(1000 / 65536)
      1  141b		       00		      .byte.b	(1000 / 65536)
      0  141c					      dw	10000
      1  141c		       10 27		      .word.w	10000
      0  141e					      db	(10000 / 65536)
      1  141e		       00		      .byte.b	(10000 / 65536)
      0  141f					      dw	100000
      1  141f		       a0 86		      .word.w	100000
      0  1421					      db	(100000 / 65536)
      1  1421		       01		      .byte.b	(100000 / 65536)
      0  1422					      dw	1000000
      1  1422		       40 42		      .word.w	1000000
      0  1424					      db	(1000000 / 65536)
      1  1424		       0f		      .byte.b	(1000000 / 65536)
      0  1425					      dw	10000000
      1  1425		       80 96		      .word.w	10000000
      0  1427					      db	(10000000 / 65536)
      1  1427		       98		      .byte.b	(10000000 / 65536)
    135  1428							;=====================================================
    136  1428							; Print character in A as two hex digits to the Console
    137  1428
    138  1428		       48	   HexToOut   pha		;save return value
    139  1429		       48		      pha
    140  142a		       4a		      lsr		;a  ;move top nibble to bottom
    141  142b		       4a		      lsr		;a
    142  142c		       4a		      lsr		;a
    143  142d		       4a		      lsr		;a
    144  142e		       20 37 14 	      jsr	hexta	;output nibble
    145  1431		       68		      pla
    146  1432		       20 37 14 	      jsr	hexta
    147  1435		       68		      pla		;restore
    148  1436		       60		      rts
    149  1437							;
    150  1437		       29 0f	   hexta      and	#%0001111
    151  1439		       c9 0a		      cmp	#$0a
    152  143b		       18		      clc
    153  143c		       30 02		      bmi	hexta1
    154  143e		       69 07		      adc	#7
    155  1440		       69 30	   hexta1     adc	#'0	;then fall into...
    156  1442		       4c c2 1f 	      jmp	VOUTCH
    157  1445							;
    158  1445							;=====================================================
    159  1445							; Print the string that immediately follows the JSR to
    160  1445							; this function.  Stops when a null byte is found,
    161  1445							; then returns to the instruction immediately
    162  1445							; following the null.
    163  1445							;
    164  1445							; Thanks to Ross Archer for this code.
    165  1445							; http://www.6502.org/source/io/primm.htm
    166  1445							;
    167  1445
    168  1445		       68	   tbputs     pla		;Get the low part of "return" address
    169  1446							;(data start address)
    170  1446		       85 5e		      sta	PrtFrom
    171  1448		       68		      pla
    172  1449		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    173  144b							;(data start address)
    174  144b							;Note: actually we're pointing one short
    175  144b		       a0 01	   PSINB      ldy	#1
    176  144d		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    177  144f		       e6 5e		      inc	PrtFrom	;update the pointer
    178  1451		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    179  1453		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    180  1455		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    181  1457							;   Accumulator
    182  1457		       f0 06		      beq	PSIX1	;don't print the final NULL
    183  1459		       20 c2 1f 	      jsr	VOUTCH	;write it out
    184  145c		       4c 4b 14 	      jmp	PSINB	;back around
    185  145f		       e6 5e	   PSIX1      inc	PrtFrom
    186  1461		       d0 02		      bne	PSIX2
    187  1463		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    188  1465		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    189  1468
    190  1468							;+
    191  1468							;====================================================
    192  1468		       2f b7	   PrtTerm    equ	tempy
    193  1468
    194  1468							; on exit Print Y has the offset to use
    195  1468							; input y =	 addr low
    196  1468							;	 x =	 addr high
    197  1468							;	 a =	 termination string
    198  1468
    199  1468
    200  1468				   PrtQuoted		; Print a quoted string from the current program space
    201  1468		       a9 22		      lda	#'"
    202  146a		       a4 51		      ldy	CUROFF
    203  146c		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    204  146e		       d0 03		      bne	PrtNoInc
    205  1470		       c8		      iny
    206  1471		       84 51		      sty	CUROFF
    207  1473				   PrtNoInc
    208  1473		       8d b7 2f 	      sta	PrtTerm
    209  1476
    210  1476				   PrtPrgString 		; Print a terminated string from the static program space
    211  1476		       a4 51		      ldy	CUROFF
    212  1478		       a5 4f		      lda	CURPTR
    213  147a		       85 5e		      sta	PrtFrom
    214  147c		       a5 50		      lda	CURPTR+1
    215  147e		       85 5f		      sta	PrtFrom+1
    216  1480		       4c 8c 14 	      jmp	PrtLoop
    217  1483
    218  1483							; Print a string pointed to by x= h, y=l terminated by a
    219  1483							; Return y as the length
    220  1483
    221  1483		       86 5f	   PrtStr     stx	PrtFrom+1
    222  1485		       84 5e		      sty	PrtFrom
    223  1487		       8d b7 2f 	      sta	PrtTerm
    224  148a		       a0 00		      ldy	#0
    225  148c							;
    226  148c							; On entry here ptrfrom and prtterm point to area to print
    227  148c							;
    228  148c		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    229  148e		       cd b7 2f 	      cmp	PrtTerm
    230  1491		       f0 0b		      beq	PrtEnd
    231  1493		       c9 00		      cmp	#0	; always end if 0 is found
    232  1495		       f0 07		      beq	PrtEnd
    233  1497		       20 c2 1f 	      jsr	VOUTCH
    234  149a		       c8		      iny
    235  149b		       4c 8c 14 	      jmp	PrtLoop
    236  149e		       c8	   PrtEnd     iny		;return byte after the copy
    237  149f		       60		      rts
    238  14a0
    239  14a0							;
    240  14a0							;=======================================================
    241  14a0							; Print all Variables
    242  14a0				   PrintAllVars
    243  14a0		       a0 00		      ldy	#0
    244  14a2		       a9 41		      lda	#'A
    245  14a4				   PrintAllVarsLoop
    246  14a4		       48		      pha
    247  14a5		       b1 41		      lda	(VARIABLES),y
    248  14a7		       85 52		      sta	R0
    249  14a9		       c8		      iny
    250  14aa		       b1 41		      lda	(VARIABLES),y
    251  14ac		       85 53		      sta	R0+1
    252  14ae
    253  14ae		       68		      pla		;get the current letter
    254  14af		       48		      pha
    255  14b0		       20 c2 1f 	      jsr	VOUTCH
    256  14b3		       20 45 14 	      jsr	puts
      0  14b6					      db	"=",0
      1  14b6		       3d 00		      .byte.b	"=",0
    258  14b8		       68		      pla
    259  14b9		       aa		      tax
    260  14ba		       e8		      inx
    261  14bb		       8a		      txa
    262  14bc		       48		      pha		;
    263  14bd
    264  14bd		       98		      tya
    265  14be		       48		      pha
    266  14bf		       20 76 13 	      jsr	PrintDecimal
    267  14c2		       20 45 14 	      jsr	puts
      0  14c5					      db	" ",0
      1  14c5		       20 00		      .byte.b	" ",0
    269  14c7		       68		      pla
    270  14c8		       a8		      tay
    271  14c9		       c8		      iny
    272  14ca		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    273  14cc		       90 d6		      bcc	PrintAllVarsLoop
    274  14ce		       20 74 1e 	      jsr	CRLF
    275  14d1
    276  14d1		       68		      pla
    277  14d2		       60		      rts
    278  14d3							;==========================================================================================================
    279  14d3							;Debug   Print a Program Line from compile buffer
    280  14d3							;
    281  14d3				   DebugPrintProgramLine
    282  14d3		       48		      pha
    283  14d4		       a9 e3		      lda	#TOKENBUFFER&$FF
    284  14d6		       85 59		      sta	dpl
    285  14d8		       a9 0f		      lda	#TOKENBUFFER>>8
    286  14da		       85 5a		      sta	dpl+1
    287  14dc		       68		      pla
    288  14dd
    289  14dd							; Decode and print a line of program text
    290  14dd							; on entry	 dpl points to line of code to print
    291  14dd							; on exit	 no change in reg or dpl
    292  14dd							;
    293  14dd				   PrintProgramLine
    294  14dd
    295  14dd		       8e e3 10 	      stx	printStorage
    296  14e0		       8c e4 10 	      sty	printStorage+1
    297  14e3		       48		      pha
    298  14e4
    299  14e4		       a0 01		      ldy	#1	; index into the token buffer
    300  14e6		       84 58		      sty	R2	; print unsigned decimal
    301  14e8		       a0 00		      ldy	#0
    302  14ea		       b1 59		      lda	(dpl),y	; get number of bytes
    303  14ec		       aa		      tax		; place pointer into x
    304  14ed		       c8		      iny
    305  14ee		       ca		      dex		; Deduct the length byte
    306  14ef		       20 cf 12 	      jsr	DPL2R0	; Print the line number
    307  14f2		       20 76 13 	      jsr	PrintDecimal
    308  14f5		       a9 20		      lda	#$20
    309  14f7		       20 c2 1f 	      jsr	VOUTCH
    310  14fa
    311  14fa				   PrintProgLoop
    312  14fa		       b1 59		      lda	(dpl),y	; Get a character
    313  14fc		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    314  14fe		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    315  1500		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    316  1502
    317  1502				   PrintProgVars
    318  1502		       b1 59		      lda	(dpl),y
    319  1504		       29 e0		      and	#$E0	; Check for operators and punctuation
    320  1506		       c9 e0		      cmp	#$E0
    321  1508		       f0 6b		      beq	PrintProgOperatorVect
    322  150a
    323  150a		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    324  150c		       c9 9e		      cmp	#$9D+1
    325  150e		       90 62		      bcc	PrintProgVariableVec
    326  1510		       29 a0		      and	#$A0	; Check for a valid datatype
    327  1512		       c9 a0		      cmp	#$A0
    328  1514		       f0 06		      beq	PrintDataType	; if not just print the character
    329  1516		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    330  1518		       ca		      dex		; Ok we are processing it
    331  1519		       c8		      iny
    332  151a		       d0 25		      bne	PrintContinue	; Print and do the next character
    333  151c
    334  151c				   PrintDataType
    335  151c		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    336  151e		       c9 a0		      cmp	#tString
    337  1520		       f0 31		      beq	PrintStringVariable
    338  1522
    339  1522				   PrintProgNumber
    340  1522		       c8		      iny		; we have a numerical integer value
    341  1523		       ca		      dex
    342  1524		       48		      pha
    343  1525		       a9 00		      lda	#0
    344  1527		       85 53		      sta	R0+1
    345  1529		       85 58		      sta	R2	; Set to print signed number
    346  152b		       b1 59		      lda	(dpl),y
    347  152d		       85 52		      sta	R0
    348  152f		       68		      pla
    349  1530		       c9 a1		      cmp	#tInteger
    350  1532		       d0 06		      bne	PrintProgNumDone
    351  1534		       c8		      iny
    352  1535		       ca		      dex
    353  1536		       b1 59		      lda	(dpl),y
    354  1538		       85 53		      sta	R0+1
    355  153a
    356  153a				   PrintProgNumDone
    357  153a		       c8		      iny
    358  153b		       ca		      dex
    359  153c		       20 76 13 	      jsr	PrintDecimal
    360  153f
    361  153f				   PrintProgNext
    362  153f		       a9 20		      lda	#$20
    363  1541				   PrintContinue
    364  1541		       20 c2 1f 	      jsr	VOUTCH
    365  1544				   PrintProgSkipSpace
    366  1544		       e0 00		      cpx	#0
    367  1546		       d0 b2		      bne	PrintProgLoop
    368  1548				   PrintProgramComplete
    369  1548		       20 74 1e 	      jsr	CRLF
    370  154b
    371  154b		       ae e3 10 	      ldx	printStorage
    372  154e		       ac e4 10 	      ldy	printStorage+1
    373  1551		       68		      pla
    374  1552
    375  1552		       60		      rts
    376  1553							;=================================================================================================================
    377  1553							; Print a string variable including the quotes
    378  1553							; On Input	 y is offset into buffer
    379  1553							; On Exit	 y is updated to new offset
    380  1553
    381  1553				   PrintStringVariable
    382  1553		       c8		      iny
    383  1554		       a9 22		      lda	#'"
    384  1556		       20 c2 1f 	      jsr	VOUTCH
    385  1559		       c8		      iny
    386  155a		       a5 59		      lda	dpl
    387  155c		       85 5e		      sta	PrtFrom
    388  155e		       a5 5a		      lda	dpl+1
    389  1560		       85 5f		      sta	PrtFrom+1
    390  1562		       a9 22		      lda	#'"
    391  1564		       8d b7 2f 	      sta	PrtTerm
    392  1567		       20 8c 14 	      jsr	PrtLoop
    393  156a		       a9 22		      lda	#'"
    394  156c		       20 c2 1f 	      jsr	VOUTCH
    395  156f		       4c 3f 15 	      jmp	PrintProgNext
    396  1572
    397  1572				   PrintProgVariableVec
    398  1572		       4c 12 16 	      jmp	PrintProgVariable
    399  1575
    400  1575				   PrintProgOperatorVect
    401  1575		       4c e9 15 	      jmp	PrintProgOperator
    402  1578							;===============================================================================================================
    403  1578							; On entry dpl points to the buffer we are printing from
    404  1578							;	    y	current offset into the dpl buffer
    405  1578							; all registers preserved
    406  1578							;
    407  1578				   PrintKeyword
    408  1578
    409  1578		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    410  157a		       85 52		      sta	R0	; The value we are looking for
    411  157c		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    412  157e		       f0 0c		      beq	PrintKeyBranch
    413  1580		       c9 08		      cmp	#kGosub
    414  1582		       f0 08		      beq	PrintKeyBranch
    415  1584		       c9 29		      cmp	#kTask
    416  1586		       f0 04		      beq	PrintKeyBranch
    417  1588		       c9 31		      cmp	#kGofn
    418  158a		       d0 04		      bne	PrintKeySkipped
    419  158c				   PrintKeyBranch
    420  158c		       c8		      iny		; Skip the compiled memory address
    421  158d		       c8		      iny
    422  158e		       ca		      dex		; Change number of bytes to print
    423  158f		       ca		      dex		; Remove the bytes to print
    424  1590
    425  1590				   PrintKeySkipped
    426  1590		       c8		      iny		; Inc y to point to the next char to be printed
    427  1591		       ca		      dex		; Reduce number of bytes to print
    428  1592		       98		      tya		; Save y and x for the return
    429  1593		       48		      pha
    430  1594		       8a		      txa
    431  1595		       48		      pha
    432  1596
    433  1596		       a9 de		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    434  1598		       85 54		      sta	R1
    435  159a		       a9 0e		      lda	#KeyWordTable>>8
    436  159c		       85 55		      sta	R1+1
    437  159e
    438  159e
    439  159e				   PrintKeyLoop
    440  159e		       a0 00		      ldy	#0	; Index into the keyword entry
    441  15a0		       b1 54		      lda	(R1),y	; Get token value for this entry
    442  15a2		       c8		      iny		; Point to first byte of key
    443  15a3		       c5 52		      cmp	R0	; Compare to the token we are looking for
    444  15a5		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    445  15a7
    446  15a7				   PrintKeyNext
    447  15a7		       b1 54		      lda	(R1),y	; Get key letter
    448  15a9		       c8		      iny		; Point to next byte always
    449  15aa		       29 20		      and	#%00100000	; Check for last character in key work
    450  15ac		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    451  15ae
    452  15ae		       98		      tya		; Trabsfer y to a for the addition
    453  15af		       18		      clc		; Table > 256 bytes
    454  15b0		       65 54		      adc	R1
    455  15b2		       85 54		      sta	R1
    456  15b4		       a9 00		      lda	#0
    457  15b6		       65 55		      adc	R1+1
    458  15b8		       85 55		      sta	R1+1
    459  15ba		       4c 9e 15 	      jmp	PrintKeyLoop
    460  15bd
    461  15bd				   PrintKeyFound
    462  15bd		       b1 54		      lda	(R1),y	; letter from key table
    463  15bf		       48		      pha		; Save it for later check
    464  15c0		       09 20		      ora	#%00100000	; Force it to lower case
    465  15c2		       20 c2 1f 	      jsr	VOUTCH	; Print it out
    466  15c5		       c8		      iny		; Point to next character
    467  15c6		       68		      pla		; Restore the value
    468  15c7		       29 20		      and	#%00100000	; Check if it was last char in keyword
    469  15c9		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    470  15cb
    471  15cb		       68		      pla		; Restore the x and y values
    472  15cc		       aa		      tax
    473  15cd		       68		      pla
    474  15ce		       a8		      tay
    475  15cf
    476  15cf				   PrintChkRem
    477  15cf		       a9 0a		      lda	#kRem
    478  15d1		       c5 52		      cmp	R0
    479  15d3		       d0 11		      bne	PrintKeyDone
    480  15d5				   PrintKeyRem
    481  15d5		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    482  15d7		       85 5e		      sta	PrtFrom
    483  15d9		       a5 5a		      lda	dpl+1
    484  15db		       85 5f		      sta	PrtFrom+1
    485  15dd		       a9 00		      lda	#0
    486  15df		       8d b7 2f 	      sta	PrtTerm
    487  15e2		       20 8c 14 	      jsr	PrtLoop
    488  15e5		       88		      dey		; point back to the terminating null value
    489  15e6				   PrintKeyDone
    490  15e6		       4c 3f 15 	      jmp	PrintProgNext
    491  15e9							;==================================================================================================================
    492  15e9							;Print Variable, number or operator
    493  15e9				   PrintProgOperator
    494  15e9		       b1 59		      lda	(dpl),y
    495  15eb		       c8		      iny
    496  15ec		       ca		      dex
    497  15ed		       8e e5 10 	      stx	printStorage+2
    498  15f0		       a2 00		      ldx	#0
    499  15f2				   PrintOprLoop
    500  15f2		       dd c8 0e 	      cmp	OperValues,x
    501  15f5		       f0 03		      beq	PrintOprFound
    502  15f7		       e8		      inx
    503  15f8		       d0 f8		      bne	PrintOprLoop
    504  15fa				   PrintOprFound
    505  15fa		       8a		      txa
    506  15fb		       0a		      asl
    507  15fc		       aa		      tax
    508  15fd		       bd 9a 0e 	      lda	Operators,x
    509  1600		       20 c2 1f 	      jsr	VOUTCH
    510  1603		       e8		      inx
    511  1604		       bd 9a 0e 	      lda	Operators,x
    512  1607		       f0 03		      beq	PrintOprDone
    513  1609		       20 c2 1f 	      jsr	VOUTCH
    514  160c				   PrintOprDone
    515  160c		       ae e5 10 	      ldx	printStorage+2
    516  160f		       4c 3f 15 	      jmp	PrintProgNext
    517  1612
    518  1612							;=================================================================================================================
    519  1612							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    520  1612							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    521  1612							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    522  1612							;tVhat 	    equ     155 		   ; Variable ^
    523  1612							;tVhash	    equ     156 		   ; Variable #
    524  1612							;tVat		    equ     157 		   ; Variable @ = 0
    525  1612				   PrintProgVariable
    526  1612		       b1 59		      lda	(dpl),y
    527  1614		       c8		      iny
    528  1615		       ca		      dex
    529  1616		       c9 9b		      cmp	#tVhat
    530  1618		       d0 04		      bne	PrintProgChkHash
    531  161a		       a9 5e		      lda	#'^
    532  161c		       d0 15		      bne	PrintTheVar
    533  161e				   PrintProgChkHash
    534  161e		       c9 9c		      cmp	#tVhash
    535  1620		       d0 04		      bne	PrintProgChkAt
    536  1622		       a9 23		      lda	#'#
    537  1624		       d0 0d		      bne	PrintTheVar
    538  1626				   PrintProgChkAt
    539  1626		       c9 9d		      cmp	#tVat
    540  1628		       d0 04		      bne	PrintProgVarLetter
    541  162a		       a9 40		      lda	#'@
    542  162c		       d0 05		      bne	PrintTheVar
    543  162e				   PrintProgVarLetter
    544  162e		       29 7f		      and	#%01111111
    545  1630		       18		      clc
    546  1631		       69 41		      adc	#'A
    547  1633				   PrintTheVar
    548  1633		       20 c2 1f 	      jsr	VOUTCH
    549  1636		       4c 3f 15 	      jmp	PrintProgNext
    550  1639
    551  1639
    552  1639							;==================================================================================================
    553  1639							; Size of print functions
    554  1639		       02 c3	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  1639					      include	"mem.asm"
      1  1639							;===================================================================
      2  1639							;This file contains the memory allocation and free functions
      3  1639							;in herant in this is the management of free memory in the system
      4  1639							; the interface to these functions
      5  1639							; a,x returns or provides the low hi bytes of the managed addresses
      6  1639							; This uses the programend, to memory end as the area to manage
      7  1639							;===================================================================
      8  1639					      Seg	Code
      9  1639							;=====================================================
     10  1639							;Pointers for memory Management
     11  1639							;Allocated block are not chained but can be followed for all memory by the associated length
     12  1639							; Mem block format is
     13  1639							;	 0-1   pointer to next block for free blocks
     14  1639							;	 0-1   for allocated blocks
     15  1639							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  1639							;	   1   refrence counter ... lol only up to 256 but it is something
     17  1639							;	 2-3   length constant for exevy type of memory block
     18  1639							; Memory is recombined as it is released
     19  1639							; The memory manager is not interupted durring allocation
     20  1639							; or freeing of memory
     21  1639							; Memory is allocated from the highest memory address towards
     22  1639							; the lowest memory address. meeting the Basic program end.
     23  1639							;====================================================
     24  1639							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  1639							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  1639							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  1639							;=====================================================
     28  1639				   MemInit
     29  1639		       a9 c9		      lda	#FreeMemStart&$FF
     30  163b		       8d bf 2f 	      sta	ProgramStart
     31  163e		       8d c1 2f 	      sta	ProgramEnd
     32  1641		       a9 2f		      lda	#FreeMemStart>>8
     33  1643		       8d c0 2f 	      sta	ProgramStart+1
     34  1646		       8d c2 2f 	      sta	ProgramEnd+1
     35  1649
     36  1649		       20 53 16 	      jsr	GetSizes
     37  164c		       20 5e 16 	      jsr	MemFree
     38  164f		       20 76 16 	      jsr	MemUsed
     39  1652				   MemInitEnd
     40  1652		       60		      rts
     41  1653
     42  1653
     43  1653							;
     44  1653							;=====================================================
     45  1653							; This function might go away eventually, but was
     46  1653							; added to provide data for other pieces of code.
     47  1653							; It has some ties to the operating environment that
     48  1653							; will need to be customized for the target system.
     49  1653							;
     50  1653				   GetSizes
     51  1653							;
     52  1653							; Here is machine specific code to get the highest
     53  1653							; memory location that can be used by BASIC.
     54  1653							;
     55  1653				  -	      if	ProgramStart < $2000
     56  1653				  -	      lda	#$ff
     57  1653				  -	      sta	HighMem	;$13ff for KIM-1
     58  1653				  -	      sta	MemFreeList
     59  1653				  -	      lda	#$DE	;#$13
     60  1653				  -	      sta	HighMem+1
     61  1653				  -	      sta	MemFreeList+1
     62  1653					      else
     63  1653		       a9 ff		      lda	#$ff
     64  1655		       8d c3 2f 	      sta	HighMem	;$CFFF otherwise
     65  1658		       a9 cf		      lda	#$cf
     66  165a		       8d c4 2f 	      sta	HighMem+1
     67  165d					      endif
     68  165d		       60		      rts
     69  165e							;
     70  165e							; This computes the available memory remaining.
     71  165e							;
     72  165e				   MemFree
     73  165e		       38		      sec
     74  165f		       ad c3 2f 	      lda	HighMem
     75  1662		       ed c1 2f 	      sbc	ProgramEnd
     76  1665		       8d c7 2f 	      sta	FreeMem
     77  1668		       85 52		      sta	R0
     78  166a		       ad c4 2f 	      lda	HighMem+1
     79  166d		       ed c2 2f 	      sbc	ProgramEnd+1
     80  1670		       8d c8 2f 	      sta	FreeMem+1
     81  1673		       85 53		      sta	R0+1
     82  1675		       60		      rts
     83  1676							;
     84  1676							; This computes the size of the current user program.
     85  1676							;
     86  1676				   MemUsed
     87  1676		       38		      sec
     88  1677		       ad c1 2f 	      lda	ProgramEnd
     89  167a		       ed bf 2f 	      sbc	ProgramStart
     90  167d		       8d c5 2f 	      sta	UsedMem
     91  1680		       85 52		      sta	R0
     92  1682		       ad c2 2f 	      lda	ProgramEnd+1
     93  1685		       ed c0 2f 	      sbc	ProgramStart+1
     94  1688		       8d c6 2f 	      sta	UsedMem+1
     95  168b		       85 53		      sta	R0+1
     96  168d							;
     97  168d		       60		      rts
     98  168e
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  168e					      include	"gosub.asm"
      1  168e					      seg	Code
      2  168e
      3  168e							; Gosub and return related functions
      4  168e							;==========================================================
      5  168e							; Push the current math stack frame onto the gosub stack
      6  168e				   iPushMathStack
      7  168e		       98		      tya
      8  168f		       48		      pha
      9  1690		       a4 4d		      ldy	GOSUBSTACKPTR
     10  1692		       a5 4a		      lda	MATHSTACKPTR
     11  1694		       91 4b		      sta	(GOSUBSTACK),y
     12  1696		       a9 00		      lda	#0
     13  1698		       c8		      iny
     14  1699		       91 4b		      sta	(GOSUBSTACK),y
     15  169b		       c8		      iny
     16  169c		       91 4b		      sta	(GOSUBSTACK),y
     17  169e		       c8		      iny
     18  169f		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  16a1		       91 4b		      sta	(GOSUBSTACK),y
     20  16a3		       c8		      iny
     21  16a4		       84 4d		      sty	GOSUBSTACKPTR
     22  16a6		       68		      pla
     23  16a7		       a8		      tay
     24  16a8		       4c c3 02 	      jmp	NextIL
     25  16ab							;
     26  16ab							;==========================================================
     27  16ab							; Increment parameter count. Assume Stack frame is top of stack
     28  16ab				   iIncParmCount
     29  16ab		       98		      tya
     30  16ac		       48		      pha
     31  16ad		       a4 4d		      ldy	GOSUBSTACKPTR
     32  16af		       88		      dey
     33  16b0		       88		      dey
     34  16b1		       88		      dey
     35  16b2		       b1 4b		      lda	(GOSUBSTACK),y
     36  16b4		       aa		      tax
     37  16b5		       e8		      inx
     38  16b6		       8a		      txa
     39  16b7		       91 4b		      sta	(GOSUBSTACK),y
     40  16b9		       68		      pla
     41  16ba		       a8		      tay
     42  16bb		       4c c3 02 	      jmp	NextIL
     43  16be							;
     44  16be							;==========================================================
     45  16be							;Restore the math stack frame
     46  16be		       20 c4 16    iPopMathStack jsr	PopMathStackNow
     47  16c1		       4c c3 02 	      jmp	NextIL
     48  16c4
     49  16c4				   PopMathStackNow
     50  16c4		       98		      tya
     51  16c5		       48		      pha
     52  16c6
     53  16c6		       a4 4d		      ldy	GOSUBSTACKPTR
     54  16c8		       88		      dey
     55  16c9		       b1 4b		      lda	(GOSUBSTACK),y
     56  16cb		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  16cd		       d0 09		      bne	iPopMathStackNoFrame
     58  16cf		       88		      dey
     59  16d0		       88		      dey
     60  16d1		       88		      dey
     61  16d2		       b1 4b		      lda	(GOSUBSTACK),y
     62  16d4		       85 4a		      sta	MATHSTACKPTR
     63  16d6		       84 4d		      sty	GOSUBSTACKPTR
     64  16d8
     65  16d8				   iPopMathStackNoFrame
     66  16d8
     67  16d8		       68		      pla
     68  16d9		       a8		      tay
     69  16da		       60		      rts
     70  16db
     71  16db
     72  16db							;==========================================================
     73  16db							; Push the current math stack information onto the gosub stack
     74  16db				   iSaveMathStack
     75  16db		       98		      tya
     76  16dc		       48		      pha
     77  16dd		       a4 4d		      ldy	GOSUBSTACKPTR
     78  16df		       a5 4a		      lda	MATHSTACKPTR
     79  16e1		       91 4b		      sta	(GOSUBSTACK),y
     80  16e3		       a5 48		      lda	MATHSTACK
     81  16e5		       c8		      iny
     82  16e6
     83  16e6		       91 4b		      sta	(GOSUBSTACK),y
     84  16e8		       c8		      iny
     85  16e9
     86  16e9		       a5 49		      lda	MATHSTACK+1
     87  16eb		       91 4b		      sta	(GOSUBSTACK),y
     88  16ed		       c8		      iny
     89  16ee
     90  16ee		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  16f0		       91 4b		      sta	(GOSUBSTACK),y
     92  16f2		       c8		      iny
     93  16f3
     94  16f3		       84 4d		      sty	GOSUBSTACKPTR
     95  16f5		       68		      pla
     96  16f6		       a8		      tay
     97  16f7		       4c c3 02 	      jmp	NextIL
     98  16fa							;
     99  16fa							;==========================================================
    100  16fa							;Restore the math stack information from the gosub stack
    101  16fa				   iRestoreMathStack
    102  16fa		       98		      tya
    103  16fb		       48		      pha
    104  16fc
    105  16fc		       a5 4a		      lda	MATHSTACKPTR
    106  16fe		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  1700
    108  1700		       a4 4d		      ldy	GOSUBSTACKPTR
    109  1702		       88		      dey
    110  1703		       b1 4b		      lda	(GOSUBSTACK),y
    111  1705		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  1707		       d0 16		      bne	iPopMathStack_Err
    113  1709		       88		      dey
    114  170a		       b1 4b		      lda	(GOSUBSTACK),y
    115  170c		       85 49		      sta	MATHSTACK+1
    116  170e		       88		      dey
    117  170f		       b1 4b		      lda	(GOSUBSTACK),y
    118  1711		       85 48		      sta	MATHSTACK
    119  1713		       88		      dey
    120  1714		       b1 4b		      lda	(GOSUBSTACK),y
    121  1716		       85 4a		      sta	MATHSTACKPTR
    122  1718		       84 4d		      sty	GOSUBSTACKPTR
    123  171a		       68		      pla
    124  171b		       a8		      tay
    125  171c		       4c c3 02 	      jmp	NextIL
    126  171f
    127  171f				   iPopMathStack_Err
    128  171f		       a9 00		      lda	#0
    129  1721		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  1723		       4c aa 06 	      jmp	iErr2
    131  1726							;=========================================
    132  1726							; For functions and tasks the variable address of # means
    133  1726							; a passed parameter so #[0] is the first parameter etc
    134  1726							; will try for a better way later
    135  1726
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  1726					      include	"tasks.asm"
      1  1726							;=====================================================
      2  1726							; Tiny Basic IL task management
      3  1726							; Data required by task management
      4  1726							; currently each context is about 30 bytes and is swapped
      5  1726							; into and out of page zero on each task switch....
      6  1726							; LOL yes it is slow, but works for this iteration.
      7  1726							;
      8  1726
      9  1726					      Seg	Code
     10  1726							;=====================================================
     11  1726							; Sets the pointers to the math,IL and gosub stacks
     12  1726							; Creates the initial Context for each task slot
     13  1726				   taskSetStacks
     14  1726		       a9 66		      lda	#mathStack&$FF
     15  1728		       85 48		      sta	MATHSTACK
     16  172a		       a9 27		      lda	#mathStack>>8
     17  172c		       85 49		      sta	MATHSTACK+1
     18  172e
     19  172e		       a9 f6		      lda	#ilStack&$ff
     20  1730		       85 45		      sta	ILSTACK
     21  1732		       a9 28		      lda	#ilStack>>8
     22  1734		       85 46		      sta	ILSTACK+1
     23  1736
     24  1736		       a9 86		      lda	#gosubStack&$FF
     25  1738		       85 4b		      sta	GOSUBSTACK
     26  173a		       a9 2a		      lda	#gosubStack>>8
     27  173c		       85 4c		      sta	GOSUBSTACK+1
     28  173e
     29  173e		       a9 06		      lda	#variableStack&$FF
     30  1740		       85 41		      sta	VARIABLES
     31  1742		       a9 2d		      lda	#variableStack>>8
     32  1744		       85 42		      sta	VARIABLES+1
     33  1746		       a2 0a		      ldx	#TASKCOUNT
     34  1748		       a0 00		      ldy	#0
     35  174a		       20 e7 19 	      jsr	ContextSave
     36  174d
     37  174d		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  174f		       b0 3a		      bcs	taskSetDone
     39  1751
     40  1751		       a5 4b		      lda	GOSUBSTACK
     41  1753		       18		      clc
     42  1754		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  1756		       85 4b		      sta	GOSUBSTACK
     44  1758		       a5 4c		      lda	GOSUBSTACK+1
     45  175a		       69 00		      adc	#0
     46  175c		       85 4c		      sta	GOSUBSTACK+1
     47  175e
     48  175e		       a5 45		      lda	ILSTACK	; must be less than 256
     49  1760		       18		      clc
     50  1761		       69 28		      adc	#ILSTACKSIZE*2
     51  1763		       85 45		      sta	ILSTACK
     52  1765		       a5 46		      lda	ILSTACK+1
     53  1767		       69 00		      adc	#0
     54  1769		       85 46		      sta	ILSTACK+1
     55  176b
     56  176b		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  176d		       18		      clc
     58  176e		       69 28		      adc	#MATHSTACKSIZE*2
     59  1770		       85 48		      sta	MATHSTACK
     60  1772		       a5 49		      lda	MATHSTACK+1
     61  1774		       69 00		      adc	#0
     62  1776		       85 49		      sta	MATHSTACK+1
     63  1778
     64  1778		       a5 41		      lda	VARIABLES	; must be less than 256
     65  177a		       18		      clc
     66  177b		       69 36		      adc	#VARIABLESSIZE*2
     67  177d		       85 41		      sta	VARIABLES
     68  177f		       a5 42		      lda	VARIABLES+1
     69  1781		       69 00		      adc	#0
     70  1783		       85 42		      sta	VARIABLES+1
     71  1785
     72  1785		       20 e7 19 	      jsr	ContextSave
     73  1788		       4c 4d 17 	      jmp	taskSetLoop
     74  178b
     75  178b				   taskSetDone
     76  178b		       a0 00		      ldy	#0	; reload the main loop context
     77  178d		       20 f6 19 	      jsr	ContextLoad
     78  1790		       60		      rts
     79  1791							;
     80  1791							;=====================================================
     81  1791							; In some error cases the math stacks may be left pointing to the wrong stack
     82  1791							; This function will reset those stack addresses but not the actual pointer
     83  1791				   taskResetStacks
     84  1791		       a0 00		      ldy	#0
     85  1793		       20 f6 19 	      jsr	ContextLoad
     86  1796		       4c 26 17 	      jmp	taskSetStacks
     87  1799							;
     88  1799							;=====================================================
     89  1799							; Clear all task entries and task stacks
     90  1799		       98	   taskReset  tya		; Save Y
     91  179a		       48		      pha
     92  179b		       a9 01		      lda	#1
     93  179d		       8d 65 27 	      sta	taskCounter	; Set number of active tasks to 1
     94  17a0		       ac 66 26 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  17a3		       c0 00		      cpy	#0	; check if we are the main context
     96  17a5		       f0 08		      beq	taskResetCont	; if we are just continue
     97  17a7
     98  17a7		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  17a9		       8c 66 26 	      sty	taskPtr
    100  17ac		       20 f6 19 	      jsr	ContextLoad	; load the System Task context
    101  17af				   taskResetCont
    102  17af		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    103  17b1
    104  17b1				   taskResetLoop
    105  17b1		       a9 00		      lda	#TASKINACTIVE
    106  17b3		       99 67 26 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  17b6		       18		      clc
    108  17b7		       98		      tya
    109  17b8		       69 19		      adc	#CONTEXTLEN
    110  17ba		       a8		      tay
    111  17bb		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  17bd		       90 f2		      bcc	taskResetLoop	; Go for more
    113  17bf
    114  17bf				   taskResetComplete
    115  17bf
    116  17bf		       68		      pla		; Restore y
    117  17c0		       a8		      tay
    118  17c1		       60		      rts
    119  17c2
    120  17c2							;
    121  17c2							;======================================================
    122  17c2							; iTaskSwitch	 switch to new task if not interrupt and
    123  17c2							;		 count is exceded for task time slice gets here
    124  17c2							;		 when time slice has reached zero
    125  17c2							;
    126  17c2		       98	   iTaskSwitch tya
    127  17c3		       48		      pha
    128  17c4
    129  17c4		       ad 63 27 	      lda	taskResetValue	; Always reset the counter value
    130  17c7		       8d 61 27 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  17ca		       ce 62 27 	      dec	taskCurrentCycles+1	; dec high order byte
    132  17cd		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  17cf
    134  17cf		       ad 64 27 	      lda	taskResetValue+1
    135  17d2		       8d 62 27 	      sta	taskCurrentCycles+1
    136  17d5
    137  17d5		       ad 63 26 	      lda	IRQPending	; Skip this if we are processing an irq
    138  17d8		       0d bd 2f 	      ora	taskIOPending	; If set then don't switch
    139  17db		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  17dd
    141  17dd		       ad 65 27    iTaskMain  lda	taskCounter	; Number of tasks
    142  17e0		       c9 01		      cmp	#1	; if there is only one task must be main
    143  17e2		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  17e4
    145  17e4		       ac 66 26 	      ldy	taskPtr	; check if we have not just ended some other task
    146  17e7		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  17e9		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  17eb							;
    149  17eb							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  17eb							;
    151  17eb				   itasknext
    152  17eb		       ac 66 26 	      ldy	taskPtr
    153  17ee		       20 e7 19 	      jsr	ContextSave	; Save the current context, y points to next context
    154  17f1				   itaskLoop
    155  17f1		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  17f3		       90 04		      bcc	iTaskNextChk
    157  17f5
    158  17f5		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  17f7		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  17f9
    161  17f9				   iTaskNextChk
    162  17f9		       b9 67 26 	      lda	taskTable,y	; there is always at least one entry in table
    163  17fc		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  17fe		       18	   iTaskNext  clc
    165  17ff		       98		      tya
    166  1800		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    167  1802		       a8		      tay
    168  1803		       4c f1 17 	      jmp	itaskLoop	; Check for busy entry
    169  1806
    170  1806		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  1808		       59 67 26 	      eor	taskTable,y	; Check for anything waiting io
    172  180b		       d0 f1		      bne	iTaskNext
    173  180d		       20 f6 19 	      jsr	ContextLoad	; load the next context
    174  1810		       8c 66 26 	      sty	taskPtr	; update the task pointer
    175  1813
    176  1813				   iTaskSwitchDone
    177  1813		       68		      pla
    178  1814		       a8		      tay
    179  1815		       60		      rts
    180  1816							;
    181  1816							;================================================================
    182  1816							; Task Set task number to line number to start
    183  1816							; on entry stack contains, type of line description and  memvector or linenumber
    184  1816							; Task Table structure:
    185  1816							;    byte 0	-   Active inactive
    186  1816							;    byte 1-2	-   Basic code line pointer
    187  1816							;    byte 3	-   Offset on current line
    188  1816		       98	   iTaskSet   tya		;preserve Y
    189  1817		       48		      pha		; push a
    190  1818		       20 d3 1d 	      jsr	popR1	; Get if compiled or line number expression
    191  181b		       20 bb 1d 	      jsr	popR0	; Get the line number to be saved
    192  181e
    193  181e
    194  181e
    195  181e		       ac 66 26 	      ldy	taskPtr	; find out where we are
    196  1821		       20 e7 19 	      jsr	ContextSave	; Save the current context
    197  1824
    198  1824							;Find the pointer to the line we need to start at
    199  1824		       a5 54		      lda	R1
    200  1826		       f0 0b		      beq	iTaskLineNum
    201  1828		       a5 52		      lda	R0
    202  182a		       85 4f		      sta	CURPTR
    203  182c		       a5 53		      lda	R0+1
    204  182e		       85 50		      sta	CURPTR+1
    205  1830		       4c 43 18 	      jmp	iTaskCont
    206  1833
    207  1833				   iTaskLineNum
    208  1833		       20 75 1b 	      jsr	findLine	; Get the offset of the line to start task at
    209  1836		       f0 0b		      beq	iTaskCont
    210  1838
    211  1838		       ac 66 26 	      ldy	taskPtr	; Restore the original Context Error Exit
    212  183b		       20 f6 19 	      jsr	ContextLoad
    213  183e
    214  183e		       68		      pla		; pop a - exit
    215  183f		       a8		      tay
    216  1840		       4c 91 0d 	      jmp	iSetIrqErr	; Bad line number provided
    217  1843
    218  1843				   iTaskCont
    219  1843		       20 b9 19 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    220  1846		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    221  1848
    222  1848		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    223  184a		       99 67 26 	      sta	taskTable,y	; new task as active
    224  184d
    225  184d		       a5 4f		      lda	CURPTR
    226  184f		       48		      pha		; push a
    227  1850		       a5 50		      lda	CURPTR+1
    228  1852		       48		      pha		; push a
    229  1853
    230  1853		       20 f6 19 	      jsr	ContextLoad	; load the context of the new task
    231  1856
    232  1856		       68		      pla		; pop a
    233  1857		       85 50		      sta	CURPTR+1
    234  1859		       68		      pla		; pop a
    235  185a		       85 4f		      sta	CURPTR
    236  185c		       a9 03		      lda	#3	; Offset to first instruction
    237  185e		       85 51		      sta	CUROFF
    238  1860
    239  1860		       a9 00		      lda	#0
    240  1862		       85 47		      sta	ILSTACKPTR
    241  1864		       85 4a		      sta	MATHSTACKPTR
    242  1866		       85 4d		      sta	GOSUBSTACKPTR
    243  1868		       a9 40		      lda	#GOSUBSTACKSIZE*4
    244  186a		       85 4e		      sta	MESSAGEPTR
    245  186c
    246  186c		       20 6c 09 	      jsr	subVINIT	; Clear the variables
    247  186f
    248  186f		       a9 ac		      lda	#STMT&$FF
    249  1871		       85 43		      sta	ILPC
    250  1873		       a9 22		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    251  1875		       85 44		      sta	ILPC+1
    252  1877
    253  1877		       98		      tya		; Save the new context offset to return to user
    254  1878		       48		      pha		; push a
    255  1879
    256  1879		       20 e7 19    itaskSetSave jsr	ContextSave	; save the updated context
    257  187c		       ee 65 27 	      inc	taskCounter	; Update the number of Tasks running
    258  187f
    259  187f		       ac 66 26 	      ldy	taskPtr
    260  1882		       20 f6 19 	      jsr	ContextLoad	; restore the original context
    261  1885
    262  1885		       a9 00		      lda	#0	; Set the R0 upper to zero
    263  1887		       85 53		      sta	R0+1
    264  1889		       68		      pla		; Get the task pid we stored				 ; pop a
    265  188a		       85 52		      sta	R0	; Get the table entry value
    266  188c
    267  188c		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    268  188d		       a8		      tay
    269  188e
    270  188e		       4c 43 07 	      jmp	pushR0nextIl	; Push R0 and continue
    271  1891				   iTaskNoEmpty
    272  1891		       ac 66 26 	      ldy	taskPtr
    273  1894		       20 f6 19 	      jsr	ContextLoad
    274  1897
    275  1897		       68		      pla		; pop a    -- exit
    276  1898		       a8		      tay
    277  1899
    278  1899		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    279  189b		       a9 00		      lda	#0
    280  189d		       4c aa 06 	      jmp	iErr2
    281  18a0							;
    282  18a0							;===============================================================
    283  18a0							; Run the task whos PID is on the stack, preserve the stack
    284  18a0							;
    285  18a0				   iTaskEnable
    286  18a0		       98		      tya
    287  18a1		       48		      pha
    288  18a2		       20 d3 1d 	      jsr	popR1
    289  18a5		       20 a1 1d 	      jsr	pushR1
    290  18a8		       20 ed 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    291  18ab		       a0 00		      ldy	#0
    292  18ad		       b1 56		      lda	(MQ),y
    293  18af		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    294  18b1		       09 80		      ora	#TASKACTIVE
    295  18b3		       91 56		      sta	(MQ),y
    296  18b5		       68		      pla
    297  18b6		       a8		      tay
    298  18b7		       4c c3 02 	      jmp	NextIL
    299  18ba
    300  18ba							;
    301  18ba							;===============================================================
    302  18ba							; Suspend the task whos PID  is on the stack, preserve the stack
    303  18ba							;
    304  18ba				   iTaskSuspend
    305  18ba		       98		      tya
    306  18bb		       48		      pha
    307  18bc		       20 d3 1d 	      jsr	popR1
    308  18bf		       20 a1 1d 	      jsr	pushR1
    309  18c2		       20 ed 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    310  18c5		       a0 00		      ldy	#0
    311  18c7		       b1 56		      lda	(MQ),y
    312  18c9		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    313  18cb		       09 80		      ora	#TASKACTIVE
    314  18cd		       68		      pla
    315  18ce		       a8		      tay
    316  18cf		       4c c3 02 	      jmp	NextIL
    317  18d2
    318  18d2							;================================================================
    319  18d2							; Returns task Status
    320  18d2				   iTaskStat
    321  18d2		       98		      tya
    322  18d3		       48		      pha
    323  18d4		       20 e6 18 	      jsr	iTaskValid	; returns pointer to task entry
    324  18d7		       b9 67 26 	      lda	taskTable,y
    325  18da		       f0 05		      beq	iTaskStatExit
    326  18dc		       68		      pla
    327  18dd		       a8		      tay
    328  18de		       4c 4b 0d 	      jmp	iTruth
    329  18e1				   iTaskStatExit
    330  18e1		       68		      pla
    331  18e2		       a8		      tay
    332  18e3		       4c 54 0d 	      jmp	iFalse
    333  18e6
    334  18e6							;
    335  18e6							;================================================================
    336  18e6							; Validate the task number on top of the stack
    337  18e6							; on exit y points to the requested task entry
    338  18e6							;
    339  18e6		       20 bb 1d    iTaskValid jsr	popR0	; get result of the multiply
    340  18e9		       a5 53		      lda	R0+1
    341  18eb		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    342  18ed		       a5 52		      lda	R0
    343  18ef		       c9 fa		      cmp	#TASKTABLELEN
    344  18f1		       90 09		      bcc	iTaskIsValid
    345  18f3
    346  18f3		       68	   iTaskValidErr pla		;remove return address
    347  18f4		       68		      pla
    348  18f5		       a2 10		      ldx	#ERR_INVALID_PID
    349  18f7		       a9 00		      lda	#0
    350  18f9		       4c aa 06 	      jmp	iErr2
    351  18fc
    352  18fc		       a8	   iTaskIsValid tay
    353  18fd		       60		      rts
    354  18fe							;
    355  18fe							;================================================================
    356  18fe							; Kill a running task, do nothing if already stopped
    357  18fe		       20 e6 18    iTaskKill  jsr	iTaskValid
    358  1901		       a9 00		      lda	#0
    359  1903		       99 67 26 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    360  1906							;
    361  1906							;================================================================
    362  1906							;Skip to next task
    363  1906				   iNTask
    364  1906		       a9 01		      lda	#1
    365  1908		       8d 61 27 	      sta	taskCurrentCycles
    366  190b		       8d 62 27 	      sta	taskCurrentCycles+1
    367  190e		       4c c3 02 	      jmp	NextIL
    368  1911							;
    369  1911							;=======================================================
    370  1911							; Wait for a task to complete
    371  1911				   iWTASK
    372  1911		       20 30 1b 	      jsr	getILByte
    373  1914		       8d bb 2f 	      sta	offset
    374  1917							;
    375  1917		       20 13 1d 	      jsr	saveIL	;in case of failure
    376  191a
    377  191a		       20 e6 18 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    378  191d		       b9 67 26 	      lda	taskTable,y
    379  1920		       d0 03		      bne	iWTASKWAIT
    380  1922				   iWTASKEXITED
    381  1922		       4c c3 02 	      jmp	NextIL
    382  1925				   iWTASKWAIT
    383  1925		       20 29 1d 	      jsr	pushR0	; Push R0 back onto the stack
    384  1928		       a9 01		      lda	#1
    385  192a		       8d 61 27 	      sta	taskCurrentCycles	; Give up the cycles
    386  192d		       8d 62 27 	      sta	taskCurrentCycles+1
    387  1930		       20 1e 1d 	      jsr	restoreIL
    388  1933		       4c ad 0b 	      jmp	tstBranch
    389  1936							;
    390  1936							;=======================================================
    391  1936							; Set task io lock
    392  1936		       ee bd 2f    iStartIO   inc	taskIOPending
    393  1939		       4c c3 02 	      jmp	NextIL
    394  193c							;
    395  193c							;=======================================================
    396  193c							; Release the io lock
    397  193c		       ad bd 2f    iEndIO     lda	taskIOPending
    398  193f		       f0 03		      beq	iEndIOExit
    399  1941		       ce bd 2f 	      dec	taskIOPending
    400  1944		       4c c3 02    iEndIOExit jmp	NextIL
    401  1947							;
    402  1947							;===============================================================
    403  1947							; Return the task PID
    404  1947				   iTASKPID
    405  1947		       a9 00		      lda	#0
    406  1949		       85 53		      sta	R0+1
    407  194b		       ad 66 26 	      lda	taskPtr
    408  194e		       85 52		      sta	R0
    409  1950		       4c 43 07 	      jmp	pushR0nextIl
    410  1953							;
    411  1953							;================================================================
    412  1953							; Terminate a task
    413  1953		       ac 66 26    iETask     ldy	taskPtr
    414  1956		       c0 00		      cpy	#0
    415  1958		       d0 03		      bne	iETaskCont
    416  195a		       4c 37 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    417  195d				   iETaskCont
    418  195d		       a9 00		      lda	#TASKINACTIVE
    419  195f		       99 67 26 	      sta	taskTable,y	; mark entry as free
    420  1962		       ce 65 27 	      dec	taskCounter	; reduce the number of active tasks
    421  1965		       a9 01		      lda	#1
    422  1967		       8d 61 27 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    423  196a		       8d 62 27 	      sta	taskCurrentCycles+1
    424  196d		       20 d4 19 	      jsr	TaskSetExitCode
    425  1970				   iETaskExit
    426  1970		       4c c3 02 	      jmp	NextIL
    427  1973							;================================================================
    428  1973							; make the current tasks math stack equal another tasks stack
    429  1973							; The task to get is stored on the math stack
    430  1973
    431  1973				   iTaskGetMathStack
    432  1973		       20 e1 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    433  1976		       20 ed 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    434  1979		       a0 0a		      ldy	#MATHSTACKPTRPOS
    435  197b		       b1 56		      lda	(MQ),y
    436  197d		       85 4a		      sta	MATHSTACKPTR
    437  197f		       a0 08		      ldy	#MATHSTACKPOS
    438  1981		       b1 56		      lda	(MQ),y
    439  1983		       85 48		      sta	MATHSTACK
    440  1985		       c8		      iny
    441  1986		       b1 56		      lda	(MQ),y
    442  1988		       85 49		      sta	MATHSTACK+1
    443  198a		       4c c3 02 	      jmp	NextIL
    444  198d							;==================================================================
    445  198d							; Updates the tasks math stack pointer with contents of R2
    446  198d							; PID is on top of the stack
    447  198d				   iTaskPutMathPtr
    448  198d		       20 e1 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    449  1990		       20 ed 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    450  1993		       a5 58		      lda	R2
    451  1995		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  1997		       91 56		      sta	(MQ),y
    453  1999		       4c c3 02 	      jmp	NextIL
    454  199c							;
    455  199c							;================================================================
    456  199c							; Set the time slice for each task
    457  199c				   iSLICE
    458  199c		       20 bb 1d 	      jsr	popR0
    459  199f		       a5 52		      lda	R0
    460  19a1		       8d 63 27 	      sta	taskResetValue
    461  19a4		       a5 53		      lda	R0+1
    462  19a6		       8d 64 27 	      sta	taskResetValue+1
    463  19a9		       d0 0b		      bne	iSliceSet
    464  19ab		       ee 64 27 	      inc	taskResetValue+1	; must be at least 1 high counter
    465  19ae		       a9 01		      lda	#1
    466  19b0		       8d 61 27 	      sta	taskCurrentCycles
    467  19b3		       8d 62 27 	      sta	taskCurrentCycles+1
    468  19b6				   iSliceSet
    469  19b6		       4c c3 02 	      jmp	NextIL
    470  19b9							;================================================================
    471  19b9							; Find an empty slot in the taskTable
    472  19b9							; Return the index in y
    473  19b9							; on exit   c set if an empty slot is found
    474  19b9							;	     c clear if not found
    475  19b9							;================================================================
    476  19b9							;
    477  19b9		       ad 65 27    TaskEmpty  lda	taskCounter
    478  19bc		       c9 0a		      cmp	#TASKCOUNT
    479  19be		       b0 10		      bcs	TaskNoSlot
    480  19c0		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    481  19c2				   TaskLoop
    482  19c2		       b9 67 26 	      lda	taskTable,y
    483  19c5		       f0 0b		      beq	TaskEmptyFnd
    484  19c7		       98		      tya
    485  19c8		       18		      clc
    486  19c9		       69 19		      adc	#CONTEXTLEN
    487  19cb		       a8		      tay
    488  19cc		       c0 fa		      cpy	#TASKTABLELEN
    489  19ce		       90 f2		      bcc	TaskLoop	; Y is never zero
    490  19d0				   TaskNoSlot
    491  19d0		       18		      clc
    492  19d1		       60		      rts
    493  19d2				   TaskEmptyFnd
    494  19d2		       38		      sec
    495  19d3		       60		      rts
    496  19d4							;====================================================
    497  19d4							; Set the task exit code called from the return command
    498  19d4							; on entry stack top hold exit value
    499  19d4				   TaskSetExitCode
    500  19d4		       98		      tya
    501  19d5		       48		      pha
    502  19d6		       20 bb 1d 	      jsr	popR0
    503  19d9		       a0 34		      ldy	#TASKEXITCODE
    504  19db		       a5 52		      lda	R0
    505  19dd		       91 41		      sta	(VARIABLES),y
    506  19df		       c8		      iny
    507  19e0		       a5 53		      lda	R0+1
    508  19e2		       91 41		      sta	(VARIABLES),y
    509  19e4		       68		      pla
    510  19e5		       98		      tya
    511  19e6		       60		      rts
    512  19e7
    513  19e7							;
    514  19e7							;=====================================================
    515  19e7							; Save Context Store the context to the TASK Table
    516  19e7							; on entry y contains the task table entry to save to
    517  19e7							; on exit y points to next task table entry
    518  19e7							;	   x contains the number of bytes copied
    519  19e7		       a2 00	   ContextSave ldx	#0
    520  19e9		       c8		      iny		;inc past the task flags
    521  19ea		       b5 41	   ContextSvLoop lda	CONTEXT,x
    522  19ec		       99 67 26 	      sta	taskTable,y
    523  19ef		       c8		      iny
    524  19f0		       e8		      inx
    525  19f1		       e0 18		      cpx	#[CONTEXTLEN-1]
    526  19f3		       90 f5		      bcc	ContextSvLoop
    527  19f5		       60		      rts
    528  19f6							;
    529  19f6							; Load Context transfer context from task table to the Current Context
    530  19f6							; on entry y contains the task table entry to transfer
    531  19f6							; on exit y points to the original task table entry
    532  19f6							;	   x contains the number of byts copied
    533  19f6		       98	   ContextLoad tya
    534  19f7		       48		      pha
    535  19f8		       a2 00		      ldx	#0
    536  19fa		       c8		      iny		;inc past the task flags
    537  19fb		       b9 67 26    ContextLDLoop lda	taskTable,y
    538  19fe		       95 41		      sta	CONTEXT,x
    539  1a00		       c8		      iny
    540  1a01		       e8		      inx
    541  1a02		       e0 18		      cpx	#[CONTEXTLEN-1]
    542  1a04		       90 f5		      bcc	ContextLDLoop
    543  1a06		       68		      pla
    544  1a07		       a8		      tay
    545  1a08		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  1a09					      include	"ipc.asm"
      1  1a09							;======================================================
      2  1a09							; Inter process communications.
      3  1a09							; Tasks may write/read integer messages among
      4  1a09							; them selves.
      5  1a09							; This uses each tasks gosub stack as a message queue
      6  1a09							; Gosub calls start at the highest address and the
      7  1a09							; msg queue starts at the highest address.
      8  1a09							;
      9  1a09							;======================================================
     10  1a09							; ipcs   - Send msg to another task or many tasks
     11  1a09							; on entry  math stack contains the  top PID
     12  1a09							;				      2ND Message value
     13  1a09							; on exit   math stack contain top True-good or False-failed
     14  1a09							;
     15  1a09							; it may not be sent if queue is full
     16  1a09							;
     17  1a09							; a = ipcs(<message-expression>,<task PID-expression>)
     18  1a09							;
     19  1a09				   iIPCS
     20  1a09		       98		      tya
     21  1a0a		       48		      pha
     22  1a0b		       20 72 1a 	      jsr	ipc_enqueue
     23  1a0e		       b0 08		      bcs	iIPC_BAD
     24  1a10		       20 d3 1f 	      jsr	pushTrue
     25  1a13		       68		      pla
     26  1a14		       a8		      tay
     27  1a15		       4c c3 02 	      jmp	NextIL
     28  1a18				   iIPC_BAD
     29  1a18		       68		      pla
     30  1a19		       a8		      tay
     31  1a1a		       20 dd 1f 	      jsr	pushFalse
     32  1a1d		       4c c3 02 	      jmp	NextIL
     33  1a20
     34  1a20							;======================================================
     35  1a20							; ipcr   - Recieve msg from task
     36  1a20							; on exit  the message value is returned from message queue
     37  1a20							;	    message -1	is reserved meaning no entry found
     38  1a20							; The provided variable contains the pid of the sending
     39  1a20							; task. This is optional. This always waits for a message
     40  1a20							; before returning.
     41  1a20							;
     42  1a20							; a = ipcr(<variable name>)
     43  1a20							;
     44  1a20				   iIPCR
     45  1a20		       98		      tya
     46  1a21		       48		      pha
     47  1a22		       20 b4 1a 	      jsr	ipc_dequeue
     48  1a25		       b0 05		      bcs	iIPCR_Q_Empty
     49  1a27		       68		      pla
     50  1a28		       a8		      tay
     51  1a29		       4c c3 02 	      jmp	NextIL
     52  1a2c				   iIPCR_Q_Empty
     53  1a2c		       68		      pla
     54  1a2d		       a8		      tay
     55  1a2e		       20 d3 1f 	      jsr	pushTrue	; puts -1 on the stack
     56  1a31		       4c c3 02 	      jmp	NextIL
     57  1a34
     58  1a34							;=======================================================
     59  1a34							; ipcc   - Check if message available
     60  1a34							; on exit  Stack contains number of messages
     61  1a34							;
     62  1a34							; a = ipcc()
     63  1a34							;
     64  1a34				   iIPCC
     65  1a34		       98		      tya
     66  1a35		       48		      pha
     67  1a36		       20 5f 1a 	      jsr	ipc_queue_count
     68  1a39		       20 29 1d 	      jsr	pushR0	; return the count
     69  1a3c		       68		      pla
     70  1a3d		       a8		      tay
     71  1a3e		       4c c3 02 	      jmp	NextIL
     72  1a41
     73  1a41							;=======================================================
     74  1a41							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  1a41				   iIPCIO
     76  1a41		       98		      tya
     77  1a42		       48		      pha
     78  1a43		       20 5f 1a 	      jsr	ipc_queue_count
     79  1a46		       a5 52		      lda	R0
     80  1a48		       d0 10		      bne	iIPCIO_No_Halt
     81  1a4a		       a9 01		      lda	#1
     82  1a4c		       8d 61 27 	      sta	taskCurrentCycles	; force a task switch
     83  1a4f		       a9 01		      lda	#TASKWAITIPC
     84  1a51		       ac 66 26 	      ldy	taskPtr
     85  1a54		       19 67 26 	      ora	taskTable,y
     86  1a57		       99 67 26 	      sta	taskTable,y
     87  1a5a
     88  1a5a				   iIPCIO_No_Halt
     89  1a5a		       68		      pla
     90  1a5b		       a8		      tay
     91  1a5c		       4c c3 02 	      jmp	NextIL
     92  1a5f							;======================================================
     93  1a5f							;ipc_queue_count
     94  1a5f				   ipc_queue_count
     95  1a5f		       a5 4e		      lda	MESSAGEPTR
     96  1a61		       18		      clc
     97  1a62		       4a		      lsr		; divide by 4
     98  1a63		       4a		      lsr
     99  1a64		       85 52		      sta	R0	; store into R0
    100  1a66		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1a68		       38		      sec
    102  1a69		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1a6b		       85 52		      sta	R0
    104  1a6d		       a9 00		      lda	#0
    105  1a6f		       85 53		      sta	R0+1
    106  1a71		       60		      rts
    107  1a72							;=======================================================
    108  1a72							; Support functions for messaging
    109  1a72							;
    110  1a72							; Enqueue message -> onto PID's MSG Q
    111  1a72							; on entry top of stack contains the PID
    112  1a72							;	    second contains the Message of the task
    113  1a72							; on exit contains c set if failed
    114  1a72							;		    c cleared if success
    115  1a72							;		    PID's MSG Q PTR points to the message
    116  1a72							;
    117  1a72				   ipc_enqueue
    118  1a72		       20 d3 1d 	      jsr	popR1	; Get the pid
    119  1a75		       20 ed 1a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1a78
    121  1a78		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1a7a		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1a7c		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1a7e		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1a80		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1a82
    127  1a82
    128  1a82							; Get the PID'S stack address into R0
    129  1a82		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1a84		       b1 56		      lda	(MQ),y
    131  1a86		       85 52		      sta	R0
    132  1a88		       c8		      iny
    133  1a89		       b1 56		      lda	(MQ),y
    134  1a8b		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1a8d
    136  1a8d							; Set y to point to the msg q entry
    137  1a8d		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1a8f		       b1 56		      lda	(MQ),y	; Get the index
    139  1a91		       a8		      tay		; Set y to queue offset
    140  1a92
    141  1a92							; enqueue the message
    142  1a92		       88		      dey		; First byte to save to
    143  1a93		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1a95		       91 52		      sta	(R0),y	; Set the entry type
    145  1a97
    146  1a97		       88		      dey
    147  1a98		       ad 66 26 	      lda	taskPtr	; Store the PID into queue
    148  1a9b		       91 52		      sta	(R0),y
    149  1a9d		       20 d3 1d 	      jsr	popR1	; Get the actual message value
    150  1aa0		       20 21 1b 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1aa3
    152  1aa3		       98		      tya		; Save the new q ptr
    153  1aa4		       a0 0e		      ldy	#MSGPTRPOS
    154  1aa6		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1aa8		       a0 00		      ldy	#0	; points to context root
    156  1aaa		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1aac		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1aae		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1ab0		       18		      clc
    160  1ab1		       60		      rts
    161  1ab2				   ipc_enq_full
    162  1ab2		       38		      sec
    163  1ab3		       60		      rts
    164  1ab4							;=============================================================
    165  1ab4							; De-queue for message stack -> local tasks msg q
    166  1ab4							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1ab4							;  message into
    168  1ab4							;  on exit   math stack contains value of message
    169  1ab4							;				  Variable if provided is pid
    170  1ab4				   ipc_dequeue
    171  1ab4		       20 ea 1d 	      jsr	popMQ	; Variable address to put PID into
    172  1ab7
    173  1ab7		       a4 4e		      ldy	MESSAGEPTR
    174  1ab9		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  1abb		       b0 2e		      bcs	ipc_deq_empty
    176  1abd		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1abf		       85 52		      sta	R0
    178  1ac1		       c8		      iny
    179  1ac2		       b1 4b		      lda	(GOSUBSTACK),y
    180  1ac4		       85 53		      sta	R0+1
    181  1ac6		       c8		      iny
    182  1ac7		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1ac9		       85 54		      sta	R1
    184  1acb		       c8		      iny
    185  1acc		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1ace		       c8		      iny
    187  1acf		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1ad1
    189  1ad1		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1ad3		       d0 16		      bne	ipc_deq_empty
    191  1ad5
    192  1ad5		       20 29 1d 	      jsr	pushR0	; place value on stack
    193  1ad8
    194  1ad8		       a5 56		      lda	MQ
    195  1ada		       05 57		      ora	MQ+1
    196  1adc		       f0 0b		      beq	ipc_deq_done
    197  1ade		       a5 54		      lda	R1
    198  1ae0		       a0 00		      ldy	#0
    199  1ae2		       91 56		      sta	(MQ),y
    200  1ae4		       c8		      iny
    201  1ae5		       a9 00		      lda	#0
    202  1ae7		       91 56		      sta	(MQ),y
    203  1ae9				   ipc_deq_done
    204  1ae9		       18		      clc
    205  1aea		       60		      rts
    206  1aeb
    207  1aeb				   ipc_deq_empty
    208  1aeb		       38		      sec
    209  1aec		       60		      rts
    210  1aed
    211  1aed							;=============================================
    212  1aed							;  Get the context address into MQ from R1 with
    213  1aed							;  context/index/pid
    214  1aed				   ipc_getcontext
    215  1aed		       18		      clc		; Get pointer to Task context
    216  1aee		       a9 67		      lda	#taskTable&$FF	; change ptr to address
    217  1af0		       65 54		      adc	R1
    218  1af2		       85 56		      sta	MQ
    219  1af4		       a9 26		      lda	#taskTable>>8
    220  1af6		       65 55		      adc	R1+1
    221  1af8		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1afa		       60		      rts
    223  1afb							;
    224  1afb							;==============================================
    225  1afb							; on entry R1 has a context value,
    226  1afb							; on exit c is set if fails
    227  1afb							;
    228  1afb				   ipc_CONTEXTVALUES
      0  1afb					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  1afb		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  1aff					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  1aff		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  1b03					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  1b03		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  1b05
    233  1b05				   ipc_ValidateContext
    234  1b05		       48		      pha
    235  1b06		       8a		      txa
    236  1b07		       48		      pha
    237  1b08		       a5 55		      lda	R1+1
    238  1b0a		       d0 0e		      bne	ipc_Validate_Fail
    239  1b0c		       a2 00		      ldx	#0
    240  1b0e		       a5 54		      lda	R1
    241  1b10				   ipc_ValidateLoop
    242  1b10		       dd fb 1a 	      cmp	ipc_CONTEXTVALUES,x
    243  1b13		       f0 09		      beq	ipc_Valid_Context
    244  1b15		       e8		      inx
    245  1b16		       e0 0a		      cpx	#TASKCOUNT
    246  1b18		       90 f6		      bcc	ipc_ValidateLoop
    247  1b1a
    248  1b1a				   ipc_Validate_Fail
    249  1b1a		       68		      pla
    250  1b1b		       aa		      tax
    251  1b1c		       68		      pla
      0  1b1d					      rtn
      0  1b1d					      db	25
      1  1b1d		       19		      .byte.b	25
    253  1b1e
    254  1b1e				   ipc_Valid_Context
    255  1b1e		       18		      clc
    256  1b1f		       90 f9		      bcc	ipc_Validate_Fail
    257  1b21							;
    258  1b21							;==============================================
    259  1b21							;Push R1 onto the stack
    260  1b21							;on entry y = next entry
    261  1b21							;R0 points to the stack space
    262  1b21							;on exit y points to next free byte
    263  1b21				   ipc_pushR1
    264  1b21		       88		      dey
    265  1b22		       a5 55		      lda	R1+1	; PID first
    266  1b24		       91 52		      sta	(R0),y
    267  1b26		       88		      dey
    268  1b27		       a5 54		      lda	R1
    269  1b29		       91 52		      sta	(R0),y
    270  1b2b		       60		      rts
    271  1b2c
    272  1b2c
    273  1b2c
    274  1b2c
    275  1b2c
    276  1b2c
    277  1b2c
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1b2c					      include	"support.asm"
      1  1b2c							;
      2  1b2c							;=====================================================
      3  1b2c							;=====================================================
      4  1b2c							;=====================================================
      5  1b2c							; This marks the start of support functions used by
      6  1b2c							; the IL opcodes.  These are support functions, NOT
      7  1b2c							; the IL code.
      8  1b2c							;=====================================================
      9  1b2c							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1b2c							;=====================================================
     11  1b2c					      Seg	Code
     12  1b2c							;=====================================================
     13  1b2c							; This gets the next two bytes pointed to by ILPC and
     14  1b2c							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1b2c							; is advanced by two, and Y contains 0 on return.
     16  1b2c
     17  1b2c							;
     18  1b2c		       20 30 1b    getILWord  jsr	getILByte	;LSB
     19  1b2f		       aa		      tax
     20  1b30							;
     21  1b30							;=====================================================
     22  1b30							; This gets the next byte pointed to by ILPC and
     23  1b30							; returns it in A.  On return, X is unchanged but Y
     24  1b30							; contains 0.
     25  1b30							;
     26  1b30		       a0 00	   getILByte  ldy	#0
     27  1b32		       b1 43		      lda	(ILPC),y	;get byte
     28  1b34		       08		      php		;save status
     29  1b35		       e6 43		      inc	ILPC	;inc LSB
     30  1b37		       d0 02		      bne	getILb2	;branch if no overflow
     31  1b39		       e6 44		      inc	ILPC+1	;inc MSB
     32  1b3b		       28	   getILb2    plp		;restore status
     33  1b3c		       60		      rts
     34  1b3d							;
     35  1b3d							;=====================================================
     36  1b3d							; Decrement ILPC by one.
     37  1b3d							;
     38  1b3d		       a5 43	   decIL      lda	ILPC
     39  1b3f		       d0 02		      bne	decIL2
     40  1b41		       c6 44		      dec	ILPC+1
     41  1b43		       c6 43	   decIL2     dec	ILPC
     42  1b45		       60		      rts
     43  1b46							;
     44  1b46							;=====================================================
     45  1b46							; Push the ILPC onto the return stack.  Actually, this
     46  1b46							; pushes the address of ILPC+2 since that's the next
     47  1b46							; address to execute.
     48  1b46							;
     49  1b46		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  1b48		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  1b4a		       b0 15		      bcs	pushErr
     52  1b4c		       a5 43		      lda	ILPC
     53  1b4e		       18		      clc
     54  1b4f		       69 02		      adc	#2
     55  1b51		       91 45		      sta	(ILSTACK),y
     56  1b53		       08		      php		;save C bit
     57  1b54		       c8		      iny
     58  1b55		       a5 44		      lda	ILPC+1
     59  1b57		       28		      plp		;restore C
     60  1b58		       69 00		      adc	#0
     61  1b5a		       91 45		      sta	(ILSTACK),y
     62  1b5c		       c8		      iny
     63  1b5d		       84 47		      sty	ILSTACKPTR
     64  1b5f		       18		      clc
     65  1b60		       60		      rts
     66  1b61				   pushErr
     67  1b61		       38		      sec
     68  1b62		       60		      rts
     69  1b63							;
     70  1b63							;=====================================================
     71  1b63							; Pull the top entry from return stack and put into
     72  1b63							; ILPC.
     73  1b63							;
     74  1b63		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1b65		       f0 fa		      beq	pushErr
     76  1b67		       88		      dey
     77  1b68		       b1 45		      lda	(ILSTACK),y
     78  1b6a		       85 44		      sta	ILPC+1
     79  1b6c		       88		      dey
     80  1b6d		       b1 45		      lda	(ILSTACK),y
     81  1b6f		       85 43		      sta	ILPC
     82  1b71		       84 47		      sty	ILSTACKPTR
     83  1b73		       18		      clc
     84  1b74		       60		      rts
     85  1b75							;
     86  1b75							;=====================================================
     87  1b75							; This searches for a specific line number that is in
     88  1b75							; R0.	There are three possible return conditions:
     89  1b75							; Line numbers are now the third byte, the first byte is now
     90  1b75							; a pointer to the next line, of course no longer than 255 byte
     91  1b75							; per line.
     92  1b75							;
     93  1b75							; Exact match was found:
     94  1b75							;    * Z set
     95  1b75							;    * CURPTR points to two-byte line number for that
     96  1b75							;	line.
     97  1b75							;
     98  1b75							; Next highest line found:
     99  1b75							;    * Z cleared
    100  1b75							;    * C set
    101  1b75							;    * CURPTR points to two-byte line number for that
    102  1b75							;	line.
    103  1b75							;
    104  1b75							; End of program reached:
    105  1b75							;    * Z cleared
    106  1b75							;    * C cleared
    107  1b75							;    * CURPTR points to first free byte at end of
    108  1b75							;	program.  Ie, it has save value as PROGRAMEND.
    109  1b75							;
    110  1b75							; A, X, and Y are all undefined on return.
    111  1b75							;
    112  1b75
    113  1b75				   findLine
    114  1b75		       ad bf 2f 	      lda	ProgramStart	;Start of program -> CURPTR
    115  1b78		       85 4f		      sta	CURPTR
    116  1b7a		       ad c0 2f 	      lda	ProgramStart+1
    117  1b7d		       85 50		      sta	CURPTR+1
    118  1b7f							;
    119  1b7f							; At end of code?
    120  1b7f							;
    121  1b7f				   iXFER1
    122  1b7f		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1b81		       cd c1 2f 	      cmp	ProgramEnd	; at end of program then stop run
    124  1b84		       d0 0b		      bne	xfer2	; not end
    125  1b86		       a5 50		      lda	CURPTR+1
    126  1b88		       cd c2 2f 	      cmp	ProgramEnd+1
    127  1b8b		       d0 04		      bne	xfer2	;Not at end
    128  1b8d							;
    129  1b8d							; Line not found and the end of the program was
    130  1b8d							; reached.  Return Z and C both clear.
    131  1b8d							;
    132  1b8d		       a9 01		      lda	#1	;clear Z
    133  1b8f		       18		      clc		;clear C
    134  1b90		       60		      rts
    135  1b91							;
    136  1b91							; Check for an exact line number match
    137  1b91							;
    138  1b91		       a5 52	   xfer2      lda	R0
    139  1b93		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1b95		       d1 4f		      cmp	(CURPTR),y
    141  1b97		       d0 08		      bne	xfernotit
    142  1b99		       c8		      iny
    143  1b9a		       a5 53		      lda	R0+1
    144  1b9c		       d1 4f		      cmp	(CURPTR),y
    145  1b9e		       d0 01		      bne	xfernotit	; not a matching line number
    146  1ba0							;
    147  1ba0							; This is exactly the line we want.
    148  1ba0							;
    149  1ba0		       60		      rts		;it matches exactly
    150  1ba1							;
    151  1ba1							; See if this line is greater than the one we're
    152  1ba1							; searching for.
    153  1ba1							;
    154  1ba1		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1ba3		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1ba5		       c5 53		      cmp	R0+1
    157  1ba7		       90 0b		      bcc	xfer3
    158  1ba9		       d0 07		      bne	xfer4
    159  1bab		       88		      dey
    160  1bac		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1bae		       c5 52		      cmp	R0
    162  1bb0		       90 02		      bcc	xfer3
    163  1bb2							;
    164  1bb2							; This line is greater than the one we want, so
    165  1bb2							; return Z clear and C set.
    166  1bb2							;
    167  1bb2		       38	   xfer4      sec		;We found a line number greater
    168  1bb3		       60		      rts		;both conditions set
    169  1bb4							;
    170  1bb4							; Not the line (or droid) we're looking for.  Move to
    171  1bb4							; the next line.
    172  1bb4							;
    173  1bb4		       20 ba 1b    xfer3      jsr	FindNextLine
    174  1bb7		       4c 7f 1b 	      jmp	iXFER1
    175  1bba							;
    176  1bba							;=====================================================
    177  1bba							; This advances CURPTR to the next line.  If there
    178  1bba							; are no more lines, this leaves CURPTR equal to
    179  1bba							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1bba							; CURPTR is pointing to a valid line on entry.  This
    181  1bba							; pointer points to the two-byte line number.
    182  1bba							; Update this points to the 1 byte line length  ****************
    183  1bba							;
    184  1bba				   FindNextLine
    185  1bba		       a0 03		      ldy	#3	;skip line number and length byte
    186  1bbc		       84 51		      sty	CUROFF	;this is the new offset
    187  1bbe		       a0 00		      ldy	#0
    188  1bc0		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1bc2		       18		      clc
    190  1bc3		       65 4f		      adc	CURPTR
    191  1bc5		       85 4f		      sta	CURPTR
    192  1bc7		       a5 50		      lda	CURPTR+1
    193  1bc9		       69 00		      adc	#0
    194  1bcb		       85 50		      sta	CURPTR+1
    195  1bcd		       60	   FindNext4  rts
    196  1bce							;
    197  1bce							;=====================================================
    198  1bce							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1bce							; if they are equal, Z clear if not.
    200  1bce							;
    201  1bce		       a5 4f	   AtEnd      lda	CURPTR
    202  1bd0		       cd c1 2f 	      cmp	ProgramEnd
    203  1bd3		       d0 05		      bne	atendexit
    204  1bd5		       a5 50		      lda	CURPTR+1
    205  1bd7		       cd c2 2f 	      cmp	ProgramEnd+1
    206  1bda		       60	   atendexit  rts
    207  1bdb							;
    208  1bdb
    209  1bdb							;
    210  1bdb							;=====================================================
    211  1bdb							; Convert an ASCII string to a number.  On input,
    212  1bdb							; (CURPTR),Y points to the first digit.  This gets
    213  1bdb							; digit-by-digit until finding a non-number.  Returns
    214  1bdb							; Y pointing to the non-digit, and R0 contains the
    215  1bdb							; number.  This does NOT check for valid ranges, so
    216  1bdb							; a value like "123456789" will produce something,
    217  1bdb							; but not what you had expected.
    218  1bdb							;
    219  1bdb		       a9 00	   getDecimal lda	#0
    220  1bdd		       85 52		      sta	R0
    221  1bdf		       85 53		      sta	R0+1
    222  1be1		       85 59		      sta	dpl	;temporary negative flag
    223  1be3							;
    224  1be3							; See if it's negative...
    225  1be3							;
    226  1be3							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1be3		       b1 4f		      lda	(CURPTR),y
    228  1be5		       c9 2d		      cmp	#'-
    229  1be7		       d0 02		      bne	getDecLoop
    230  1be9		       e6 59		      inc	dpl	;it's negative
    231  1beb							;
    232  1beb		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1bed		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1bef		       c9 30		      cmp	#'0
    235  1bf1		       90 36		      bcc	getDdone
    236  1bf3		       c9 3a		      cmp	#'9+1
    237  1bf5		       b0 32		      bcs	getDdone
    238  1bf7		       38		      sec
    239  1bf8		       e9 30		      sbc	#'0	;convert to binary
    240  1bfa		       48		      pha
    241  1bfb							;
    242  1bfb							; Now multiply R0 by 10.  Remember that
    243  1bfb							; 2*N + 8*N = 10*N.
    244  1bfb							;
    245  1bfb		       06 52		      asl	R0
    246  1bfd		       26 53		      rol	R0+1	;*2
    247  1bff		       a5 52		      lda	R0
    248  1c01		       85 54		      sta	R1
    249  1c03		       a5 53		      lda	R0+1
    250  1c05		       85 55		      sta	R1+1
    251  1c07		       06 52		      asl	R0
    252  1c09		       26 53		      rol	R0+1	;*4
    253  1c0b		       06 52		      asl	R0
    254  1c0d		       26 53		      rol	R0+1	;*8
    255  1c0f		       18		      clc		;now add the partial sums...
    256  1c10		       a5 52		      lda	R0	;...to get *10
    257  1c12		       65 54		      adc	R1
    258  1c14		       85 52		      sta	R0
    259  1c16		       a5 53		      lda	R0+1
    260  1c18		       65 55		      adc	R1+1
    261  1c1a		       85 53		      sta	R0+1
    262  1c1c							;
    263  1c1c							; Add in the new digit
    264  1c1c							;
    265  1c1c		       68		      pla
    266  1c1d		       18		      clc
    267  1c1e		       65 52		      adc	R0
    268  1c20		       85 52		      sta	R0
    269  1c22		       90 02		      bcc	getD2
    270  1c24		       e6 53		      inc	R0+1
    271  1c26							;
    272  1c26							; Move to next character
    273  1c26							;
    274  1c26		       c8	   getD2      iny
    275  1c27		       d0 c2		      bne	getDecLoop
    276  1c29							;
    277  1c29							; All done with digits, so now deal with it being
    278  1c29							; negative.  If zero, then don't check for negative
    279  1c29							; flag.  Ie, -0 is stored as 0.
    280  1c29							;
    281  1c29		       a5 52	   getDdone   lda	R0
    282  1c2b		       05 53		      ora	R0+1
    283  1c2d		       f0 16		      beq	getDone2	;zero
    284  1c2f		       a5 59		      lda	dpl
    285  1c31		       f0 12		      beq	getDone2	;positive
    286  1c33							;
    287  1c33							; Invert all the bits, then add one.
    288  1c33							;
    289  1c33		       a5 52		      lda	R0
    290  1c35		       49 ff		      eor	#$ff
    291  1c37		       85 52		      sta	R0
    292  1c39		       a5 53		      lda	R0+1
    293  1c3b		       49 ff		      eor	#$ff
    294  1c3d		       85 53		      sta	R0+1
    295  1c3f							;
    296  1c3f		       e6 52		      inc	R0
    297  1c41		       d0 02		      bne	getDone2
    298  1c43		       e6 53		      inc	R0+1
    299  1c45				   getDone2
    300  1c45							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1c45							;lda	  R0
    302  1c45							;sta	  $0010
    303  1c45							;lda	  R0+1
    304  1c45							;sta	  $0011
    305  1c45							;lda	  dpl
    306  1c45							;sta	  $012
    307  1c45
    308  1c45		       60		      rts
    309  1c46
    310  1c46							;=====================================================
    311  1c46							; Gets a line of input into LINBUF.
    312  1c46							;
    313  1c46							; On entry:
    314  1c46							;    A contains the prompt character, or 0 if none.
    315  1c46							;    X = 1 Background read
    316  1c46							;    x = 0 Forground read with wait
    317  1c46							;
    318  1c46							; On exit:
    319  1c46							;    CURPTR points to LINBUF
    320  1c46							;    LINBUF contains the line with 0 at the end.
    321  1c46							;    Y has offset to first non-space character
    322  1c46							;    CURROFF has the same as Y.
    323  1c46							;
    324  1c46		       20 95 1c    GetLine    jsr	ReadPrompt
    325  1c49		       e0 00		      cpx	#0
    326  1c4b		       f0 14		      beq	GetLineRetry
    327  1c4d		       ae 66 26 	      ldx	taskPtr
    328  1c50		       bd 67 26 	      lda	taskTable,x
    329  1c53		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1c55		       d0 3d		      bne	taskWaitingIO
    331  1c57		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1c59		       9d 67 26 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1c5c		       ce 94 1c 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1c5f		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1c61
    336  1c61							;
    337  1c61							; Now read a line and wait for the CR
    338  1c61							;
    339  1c61				   GetLineRetry
    340  1c61		       a9 00		      lda	#0	;Wait for input to complete
    341  1c63		       20 ad 1c 	      jsr	ReadLine
    342  1c66
    343  1c66							;
    344  1c66							; Point to the line we just read
    345  1c66							; Set the current pointer to point to the input line
    346  1c66							;
    347  1c66		       a0 00	   ReadComplete ldy	#0
    348  1c68		       84 51		      sty	CUROFF
    349  1c6a		       a2 22		      ldx	#LINBUF&$ff
    350  1c6c		       86 4f		      stx	CURPTR
    351  1c6e		       a2 2f		      ldx	#LINBUF>>8
    352  1c70		       86 50		      stx	CURPTR+1
    353  1c72							;
    354  1c72							; Output a CR/LF
    355  1c72							;
    356  1c72		       20 74 1e 	      jsr	CRLF
    357  1c75							;
    358  1c75							; If a blank line, prompt again.
    359  1c75							;
    360  1c75		       20 6b 1e 	      jsr	SkipSpaces
    361  1c78		       b1 4f		      lda	(CURPTR),y
    362  1c7a		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1c7c		       20 98 1c 	      jsr	ReadPromptRetry
    364  1c7f		       ae 66 26 	      ldx	taskPtr	;if this task is waiting for IO
    365  1c82		       bd 67 26 	      lda	taskTable,x	;then get out, wait for line to
    366  1c85		       29 40		      and	#TASKWAITIO	;Complete again
    367  1c87		       d0 0b		      bne	taskWaitingIO
    368  1c89		       4c 61 1c 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1c8c
    370  1c8c				   GetLineDone
    371  1c8c		       ae 66 26 	      ldx	taskPtr
    372  1c8f		       a9 80		      lda	#TASKACTIVE
    373  1c91		       9d 67 26 	      sta	taskTable,x	;IO is complete
    374  1c94
    375  1c94				   taskWaitingIO
    376  1c94		       60		      rts
    377  1c95
    378  1c95							;
    379  1c95							;=======================================================================
    380  1c95							; Display the prompt character
    381  1c95							; On entry
    382  1c95							;	    A contains the prompt character
    383  1c95							; On exit
    384  1c95							;	    The readbuffer index is reset to 0
    385  1c95							;
    386  1c95		       8d a9 2f    ReadPrompt sta	promptChar
    387  1c98
    388  1c98							;
    389  1c98							; Prompt
    390  1c98							;
    391  1c98
    392  1c98		       ad a9 2f    ReadPromptRetry lda	promptChar
    393  1c9b		       09 00		      ora	#0	;any prompt?
    394  1c9d		       f0 08		      beq	getlinenp
    395  1c9f		       20 c2 1f 	      jsr	VOUTCH
    396  1ca2		       a9 20		      lda	#$20
    397  1ca4		       20 c2 1f 	      jsr	VOUTCH	;Space after prompt
    398  1ca7							;
    399  1ca7		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1ca9		       8e a6 2f 	      stx	getlinx
    401  1cac		       60		      rts
    402  1cad							;
    403  1cad							;===============================================================
    404  1cad							; This fuction is the driver for the line input
    405  1cad							; on call if a = 0 then it waits for all input
    406  1cad							;	      a = 1 then nowait for input
    407  1cad							; On exit
    408  1cad							;		       c clear if not complete line
    409  1cad							;		       c set if it was a complete line
    410  1cad
    411  1cad				   ReadLine
    412  1cad		       8d a8 2f 	      sta	inputNoWait
    413  1cb0		       c9 00		      cmp	#0
    414  1cb2		       f0 05		      beq	getline1
    415  1cb4		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1cb7		       f0 2b		      beq	GetLineNoWait
    417  1cb9		       20 c5 1f    getline1   jsr	VGETCH
    418  1cbc					      if	CTMON65
    419  1cbc		       48		      pha
    420  1cbd		       20 c2 1f 	      jsr	VOUTCH	;echo echo echo
    421  1cc0		       68		      pla
    422  1cc1					      endif
    423  1cc1		       c9 0d		      cmp	#CR
    424  1cc3		       f0 15		      beq	getlind	;end of line
    425  1cc5		       c9 08		      cmp	#BS	;backspace?
    426  1cc7		       f0 1d		      beq	getlinebs
    427  1cc9		       ae a6 2f 	      ldx	getlinx
    428  1ccc		       9d 22 2f 	      sta	LINBUF,x
    429  1ccf		       e8		      inx
    430  1cd0		       8e a6 2f 	      stx	getlinx
    431  1cd3		       ad a8 2f 	      lda	inputNoWait
    432  1cd6		       f0 e1		      beq	getline1
    433  1cd8		       d0 0a		      bne	GetLineNoWait
    434  1cda							;
    435  1cda							; CR was hit
    436  1cda							;
    437  1cda		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1cdc		       ae a6 2f 	      ldx	getlinx
    439  1cdf		       9d 22 2f 	      sta	LINBUF,x
    440  1ce2
    441  1ce2		       38		      sec		; Carry set then cr received
    442  1ce3		       60		      rts
    443  1ce4
    444  1ce4				   GetLineNoWait
    445  1ce4		       18		      clc		; Carry clear no end of line
    446  1ce5		       60		      rts
    447  1ce6							;
    448  1ce6							; Backspace was hit
    449  1ce6							;
    450  1ce6		       ae a6 2f    getlinebs  ldx	getlinx
    451  1ce9		       f0 0e		      beq	getlineEOL	;at start of line
    452  1ceb		       ca		      dex
    453  1cec		       8e a6 2f 	      stx	getlinx
    454  1cef		       20 45 14    getlinepbs jsr	puts
      0  1cf2					      db	27,"[K",0
      1  1cf2		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1cf6		       4c b9 1c 	      jmp	getline1
    457  1cf9		       a9 20	   getlineEOL lda	#SPACE
    458  1cfb		       20 c2 1f 	      jsr	VOUTCH
    459  1cfe		       d0 ef		      bne	getlinepbs
    460  1d00							;
    461  1d00							;=====================================================
    462  1d00							; Count the length of the line currently in LINBUF
    463  1d00							; starting at offset Y.  Returns the length in X.  The
    464  1d00							; starting offset in Y should point past the ASCII
    465  1d00							; line number.  Also counts the trailing NULL and two
    466  1d00							; extra bytes for where the line number will be.
    467  1d00							; Update must now include leading length byte not the null at end ****************
    468  1d00							;
    469  1d00				   getLineLength
    470  1d00		       a2 00		      ldx	#0	;size
    471  1d02		       b9 22 2f    getLineL2  lda	LINBUF,y
    472  1d05		       f0 04		      beq	getLineL3
    473  1d07		       c8		      iny
    474  1d08		       e8		      inx
    475  1d09		       d0 f7		      bne	getLineL2
    476  1d0b		       e8	   getLineL3  inx		;count null at end
    477  1d0c		       e8		      inx		;line number LSB
    478  1d0d		       e8		      inx		;MSB
    479  1d0e		       e8		      inx		;change: count new leading line length
    480  1d0f		       8e bc 2f 	      stx	lineLength
    481  1d12		       60		      rts
    482  1d13							;
    483  1d13							;=====================================================
    484  1d13							; Count the length of the line pointed to by CURPTR.
    485  1d13							; This also counts the line number and the terminating
    486  1d13							; null.  Ie, this string returns 8:
    487  1d13							;
    488  1d13							; <lineLow><lineHi>Hello<null>
    489  1d13							;
    490  1d13							; Another way of looking at it: add the return value
    491  1d13							; to the CURPTR and it'll point to the next line's
    492  1d13							; line number.  Returns the value in Y.
    493  1d13							; Update to ject get the leading byte length ********************
    494  1d13							;
    495  1d13							;getCURPTRLength
    496  1d13							;		ldy	CURPTR
    497  1d13							;		ldy	#3	;change: skip line number and leading length byte
    498  1d13							;getCLineL2	lda	(CURPTR),y
    499  1d13							;		beq	getCLineL3
    500  1d13							;		iny
    501  1d13							;		bne	getCLineL2
    502  1d13							;getCLineL3	iny		;count null at end
    503  1d13							;		rts
    504  1d13
    505  1d13							;
    506  1d13							;=====================================================
    507  1d13							; This saves ILPC.  This saves to a single save area,
    508  1d13							; so it can't be called more than once.
    509  1d13							;
    510  1d13		       a5 43	   saveIL     lda	ILPC
    511  1d15		       8d b8 2f 	      sta	tempIL
    512  1d18		       a5 44		      lda	ILPC+1
    513  1d1a		       8d b9 2f 	      sta	tempIL+1
    514  1d1d		       60		      rts
    515  1d1e							;
    516  1d1e							;=====================================================
    517  1d1e							; This restores ILPC.
    518  1d1e							;
    519  1d1e		       ad b8 2f    restoreIL  lda	tempIL
    520  1d21		       85 43		      sta	ILPC
    521  1d23		       ad b9 2f 	      lda	tempIL+1
    522  1d26		       85 44		      sta	ILPC+1
    523  1d28		       60		      rts
    524  1d29							;
    525  1d29							;=====================================================
    526  1d29							; This pushes R0 onto the stack.
    527  1d29							;
    528  1d29		       8c af 2f    pushR0     sty	rtemp1
    529  1d2c		       a4 4a		      ldy	MATHSTACKPTR
    530  1d2e		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1d30		       b0 38		      bcs	pusherr
    532  1d32		       a5 52		      lda	R0
    533  1d34		       91 48		      sta	(MATHSTACK),y
    534  1d36		       c8		      iny
    535  1d37		       a5 53		      lda	R0+1
    536  1d39		       91 48		      sta	(MATHSTACK),y
    537  1d3b		       c8		      iny
    538  1d3c		       84 4a		      sty	MATHSTACKPTR
    539  1d3e		       ac af 2f 	      ldy	rtemp1
    540  1d41		       18		      clc
    541  1d42		       60		      rts
    542  1d43
    543  1d43							;=====================================================
    544  1d43							; This pushes curptr basic current line onto the call stack.
    545  1d43							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1d43
    547  1d43				   pushLN
    548  1d43		       8d b0 2f 	      STA	rtemp1+1	; Store type of push being done
    549  1d46		       8c af 2f 	      sty	rtemp1
    550  1d49		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  1d4b		       c5 4d		      cmp	GOSUBSTACKPTR
    552  1d4d		       90 1b		      bcc	pusherr	; No error
    553  1d4f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  1d51		       a2 00		      ldx	#0	; Start of bytes to copy
    555  1d53				   pushLoop
    556  1d53		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  1d55		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  1d57		       c8		      iny		; Next destination
    559  1d58		       e8		      inx		; Next Source byte
    560  1d59		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  1d5b		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  1d5d
    563  1d5d		       ad b0 2f    pushDone   lda	rtemp1+1	; Type of stack entry
    564  1d60		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  1d62		       c8		      iny		; Next entry
    566  1d63
    567  1d63		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  1d65		       ac af 2f 	      ldy	rtemp1
    569  1d68		       18		      clc
    570  1d69		       60		      rts
    571  1d6a				   pusherr
    572  1d6a		       38		      sec
    573  1d6b		       60		      rts
    574  1d6c							;=====================================================
    575  1d6c							; This pops Top Off gosub call Stack and
    576  1d6c							; places it in CURPTR/CUROFF.
    577  1d6c							; This checks if the type = 1 GOSUB
    578  1d6c							; if not it removes what ever is on the stack
    579  1d6c							; until it finds the next return. Allowing
    580  1d6c							; a return from within a for/next
    581  1d6c							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  1d6c		       8c af 2f    popLN      sty	rtemp1
    583  1d6f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  1d71		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  1d73
    586  1d73				   popContinue
    587  1d73		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  1d75		       90 22		      bcc	poperr	; Process an error
    589  1d77
    590  1d77		       88		      dey		; Position to read entry type
    591  1d78		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  1d7a		       8d b0 2f 	      sta	rtemp1+1	; Save to be returned
    593  1d7d		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  1d7f		       f0 04		      beq	popLoop	; Restore the line
    595  1d81		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  1d83		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  1d85
    598  1d85				   popLoop
    599  1d85		       88		      dey
    600  1d86		       ca		      dex
    601  1d87		       b1 4b		      lda	(GOSUBSTACK),y
    602  1d89		       95 4f		      sta	CURPTR,x
    603  1d8b		       e0 00		      cpx	#0
    604  1d8d		       d0 f6		      bne	popLoop	; Loop until all moved
    605  1d8f
    606  1d8f
    607  1d8f		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  1d91		       ac af 2f 	      ldy	rtemp1
    609  1d94		       ad b0 2f 	      lda	rtemp1+1	; get the type of return
    610  1d97		       18		      clc
    611  1d98		       60		      rts
    612  1d99
    613  1d99		       38	   poperr     sec
    614  1d9a		       60		      rts
    615  1d9b
    616  1d9b		       88	   popSkipEntry dey
    617  1d9c		       88		      dey
    618  1d9d		       88		      dey
    619  1d9e		       4c 73 1d 	      jmp	popContinue
    620  1da1
    621  1da1							;
    622  1da1							;=====================================================
    623  1da1							; This pushes R1 onto the stack
    624  1da1							;
    625  1da1		       8c af 2f    pushR1     sty	rtemp1
    626  1da4		       a4 4a		      ldy	MATHSTACKPTR
    627  1da6		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  1da8		       b0 ef		      bcs	poperr
    629  1daa		       a5 54		      lda	R1
    630  1dac		       91 48		      sta	(MATHSTACK),y
    631  1dae		       c8		      iny
    632  1daf		       a5 55		      lda	R1+1
    633  1db1		       91 48		      sta	(MATHSTACK),y
    634  1db3		       c8		      iny
    635  1db4		       84 4a		      sty	MATHSTACKPTR
    636  1db6		       ac af 2f 	      ldy	rtemp1
    637  1db9		       18		      clc
    638  1dba		       60		      rts
    639  1dbb							;
    640  1dbb							;=====================================================
    641  1dbb							; This pops Top Of Stack and places it in R0.
    642  1dbb							;
    643  1dbb		       8c af 2f    popR0      sty	rtemp1
    644  1dbe		       a4 4a		      ldy	MATHSTACKPTR
    645  1dc0		       f0 d7		      beq	poperr
    646  1dc2		       88		      dey
    647  1dc3		       b1 48		      lda	(MATHSTACK),y
    648  1dc5		       85 53		      sta	R0+1
    649  1dc7		       88		      dey
    650  1dc8		       b1 48		      lda	(MATHSTACK),y
    651  1dca		       85 52		      sta	R0
    652  1dcc		       84 4a		      sty	MATHSTACKPTR
    653  1dce		       ac af 2f 	      ldy	rtemp1
    654  1dd1		       18		      clc
    655  1dd2		       60		      rts
    656  1dd3
    657  1dd3							;
    658  1dd3							;=====================================================
    659  1dd3							; This pops TOS and places it in R1.
    660  1dd3							;
    661  1dd3		       8c af 2f    popR1      sty	rtemp1
    662  1dd6		       a4 4a		      ldy	MATHSTACKPTR
    663  1dd8		       f0 bf		      beq	poperr
    664  1dda		       88		      dey
    665  1ddb		       b1 48		      lda	(MATHSTACK),y
    666  1ddd		       85 55		      sta	R1+1
    667  1ddf		       88		      dey
    668  1de0		       b1 48		      lda	(MATHSTACK),y
    669  1de2		       85 54		      sta	R1
    670  1de4		       84 4a		      sty	MATHSTACKPTR
    671  1de6		       ac af 2f 	      ldy	rtemp1
    672  1de9		       60		      rts
    673  1dea							;
    674  1dea							;=====================================================
    675  1dea							; This pops TOS and places it in MQ.
    676  1dea							;
    677  1dea		       8c af 2f    popMQ      sty	rtemp1
    678  1ded		       a4 4a		      ldy	MATHSTACKPTR
    679  1def		       f0 a8		      beq	poperr
    680  1df1		       88		      dey
    681  1df2		       b1 48		      lda	(MATHSTACK),y
    682  1df4		       85 57		      sta	MQ+1
    683  1df6		       88		      dey
    684  1df7		       b1 48		      lda	(MATHSTACK),y
    685  1df9		       85 56		      sta	MQ
    686  1dfb		       84 4a		      sty	MATHSTACKPTR
    687  1dfd		       ac af 2f 	      ldy	rtemp1
    688  1e00		       60		      rts
    689  1e01							;
    690  1e01							;=====================================================
    691  1e01							; This assists with multiplication and division by
    692  1e01							; looking at R0 and R1 and saving a flag as to what
    693  1e01							; sign the result will be.  Math is always done on
    694  1e01							; positive numbers, so this converts negative numbers
    695  1e01							; into positives.  On exit, R0 and R1 are both
    696  1e01							; positive.  If the signs were different then 'signs'
    697  1e01							; will be non-zero.
    698  1e01							;
    699  1e01		       a9 00	   SaveSigns  lda	#0
    700  1e03		       8d ae 2f 	      sta	sign	;assume positive
    701  1e06		       a5 53		      lda	R0+1	;MSB
    702  1e08		       10 13		      bpl	SaveSigns1
    703  1e0a		       ee ae 2f 	      inc	sign	;it's negative
    704  1e0d		       49 ff		      eor	#$ff	;flip bits
    705  1e0f		       85 53		      sta	R0+1
    706  1e11		       a5 52		      lda	R0
    707  1e13		       49 ff		      eor	#$ff
    708  1e15		       85 52		      sta	R0
    709  1e17		       e6 52		      inc	R0
    710  1e19		       d0 02		      bne	SaveSigns1
    711  1e1b		       e6 53		      inc	R0+1
    712  1e1d		       a5 55	   SaveSigns1 lda	R1+1
    713  1e1f		       10 1a		      bpl	SaveSigns2
    714  1e21		       48		      pha
    715  1e22		       ad ae 2f 	      lda	sign
    716  1e25		       49 01		      eor	#1
    717  1e27		       8d ae 2f 	      sta	sign
    718  1e2a		       68		      pla
    719  1e2b		       49 ff		      eor	#$ff	;flip bits
    720  1e2d		       85 55		      sta	R1+1
    721  1e2f		       a5 54		      lda	R1
    722  1e31		       49 ff		      eor	#$ff
    723  1e33		       85 54		      sta	R1
    724  1e35		       e6 54		      inc	R1
    725  1e37		       d0 02		      bne	SaveSigns2
    726  1e39		       e6 55		      inc	R1+1
    727  1e3b		       60	   SaveSigns2 rts
    728  1e3c							;
    729  1e3c							;=====================================================
    730  1e3c							; This looks at the value of 'signs' and will convert
    731  1e3c							; both R0 and R1 to negative if set.
    732  1e3c							;
    733  1e3c				   RestoreSigns
    734  1e3c		       ad ae 2f 	      lda	sign
    735  1e3f		       f0 28		      beq	restoresigns2
    736  1e41							;
    737  1e41		       a5 52		      lda	R0
    738  1e43		       d0 02		      bne	restoresigns3
    739  1e45		       c6 53		      dec	R0+1
    740  1e47				   restoresigns3
    741  1e47		       c6 52		      dec	R0
    742  1e49		       a5 52		      lda	R0
    743  1e4b		       49 ff		      eor	#$ff
    744  1e4d		       85 52		      sta	R0
    745  1e4f		       a5 53		      lda	R0+1
    746  1e51		       49 ff		      eor	#$ff
    747  1e53		       85 53		      sta	R0+1
    748  1e55							;
    749  1e55		       a5 54		      lda	R1
    750  1e57		       d0 02		      bne	restoresigns4
    751  1e59		       c6 55		      dec	R1+1
    752  1e5b				   restoresigns4
    753  1e5b		       c6 54		      dec	R1
    754  1e5d		       a5 54		      lda	R1
    755  1e5f		       49 ff		      eor	#$ff
    756  1e61		       85 54		      sta	R1
    757  1e63		       a5 55		      lda	R1+1
    758  1e65		       49 ff		      eor	#$ff
    759  1e67		       85 55		      sta	R1+1
    760  1e69							;
    761  1e69				   restoresigns2
    762  1e69		       60		      rts
    763  1e6a							;
    764  1e6a							;=====================================================
    765  1e6a							; Skip over spaces.  Returns Y with the offset to
    766  1e6a							; either the last character in the line, or the first
    767  1e6a							; non-space character.
    768  1e6a							;
    769  1e6a
    770  1e6a		       c8	   skipsp2    iny
    771  1e6b		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  1e6d		       f0 04		      beq	Skip3	;end of line
    773  1e6f		       c9 20		      cmp	#SPACE
    774  1e71		       f0 f7		      beq	skipsp2
    775  1e73		       60	   Skip3      rts
    776  1e74							;*********************************************************
    777  1e74							; Output a CR/LF combination to the console.  Preserves
    778  1e74							; all registers.
    779  1e74							;
    780  1e74		       48	   tbcrlf     pha
    781  1e75		       a9 0d		      lda	#CR
    782  1e77		       20 c2 1f 	      jsr	VOUTCH
    783  1e7a		       a9 0a		      lda	#LF
    784  1e7c		       20 c2 1f 	      jsr	VOUTCH
    785  1e7f		       68		      pla
    786  1e80		       60		      rts
    787  1e81							;
    788  1e81							;=====================================================
    789  1e81							; Some logic to print the Line of basic code being executed
    790  1e81		       24 40	   idbgBasic  bit	ILTrace
    791  1e83		       50 75		      bvc	dbgBasicNone
    792  1e85		       98		      tya
    793  1e86		       48		      pha
    794  1e87		       20 f6 1f 	      jsr	SetOutDebug
    795  1e8a
    796  1e8a		       a5 4f		      lda	CURPTR
    797  1e8c		       85 59		      sta	dpl
    798  1e8e		       a5 50		      lda	CURPTR+1
    799  1e90		       85 5a		      sta	dpl+1
    800  1e92
    801  1e92		       20 dd 14 	      jsr	PrintProgramLine
    802  1e95
    803  1e95		       a5 40		      lda	ILTrace
    804  1e97		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  1e99		       f0 5a		      beq	dbgBasicDone
    806  1e9b		       20 0d 20 	      jsr	SetInDebug
    807  1e9e		       20 45 14 	      jsr	puts
      0  1ea1					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1ea1		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  1ede				   dbgBasicLoop
    810  1ede		       20 c5 1f 	      jsr	VGETCH
    811  1ee1		       20 74 1e 	      jsr	CRLF
    812  1ee4		       20 31 20 	      jsr	SetInDebugEnd
    813  1ee7
    814  1ee7		       c9 73		      cmp	#'s	; Quit program
    815  1ee9		       f0 12		      beq	dbgBasicStop
    816  1eeb
    817  1eeb		       c9 64		      cmp	#'d	; Display Variables
    818  1eed		       d0 06		      bne	dbgBasicDone
    819  1eef
    820  1eef		       20 a0 14 	      jsr	PrintAllVars
    821  1ef2		       18		      clc
    822  1ef3		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  1ef5
    824  1ef5		       20 24 20    dbgBasicDone jsr	SetOutDebugEnd
    825  1ef8		       68		      pla
    826  1ef9		       a8		      tay
    827  1efa		       4c c3 02    dbgBasicNone jmp	NextIL
    828  1efd
    829  1efd				   dbgBasicStop
    830  1efd		       20 24 20 	      jsr	SetOutDebugEnd
    831  1f00		       68		      pla
    832  1f01		       a8		      tay
    833  1f02		       4c 37 06 	      jmp	iFIN
    834  1f05							;
    835  1f05							;=====================================================
    836  1f05							; This is some debug logic which displays the current
    837  1f05							; value of the ILPC and the line buffer.
    838  1f05							;
    839  1f05		       24 40	   dbgLine    bit	ILTrace
    840  1f07		       30 01		      bmi	dbgPrt
    841  1f09		       60		      rts
    842  1f0a				   dbgPrt
    843  1f0a		       20 f6 1f 	      jsr	SetOutDebug
    844  1f0d		       20 45 14 	      jsr	puts
      0  1f10					      db	"ILPC: ",0
      1  1f10		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    846  1f17		       a5 44		      lda	ILPC+1
    847  1f19		       20 28 14 	      jsr	OUTHEX
    848  1f1c		       a5 43		      lda	ILPC
    849  1f1e		       20 28 14 	      jsr	OUTHEX
    850  1f21		       a9 20		      lda	#SPACE
    851  1f23		       20 c2 1f 	      jsr	VOUTCH
    852  1f26		       a0 00		      ldy	#0
    853  1f28		       b1 43		      lda	(ILPC),y
    854  1f2a		       20 28 14 	      jsr	OUTHEX
    855  1f2d							;
    856  1f2d							; Display the CURPTR value and offset
    857  1f2d							;
    858  1f2d		       20 45 14 	      jsr	puts
      0  1f30					      db	", CURPTR: ",0
      1  1f30		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    860  1f3b		       a5 50		      lda	CURPTR+1
    861  1f3d		       20 28 14 	      jsr	OUTHEX
    862  1f40		       a5 4f		      lda	CURPTR
    863  1f42		       20 28 14 	      jsr	OUTHEX
    864  1f45		       a9 2b		      lda	#'+
    865  1f47		       20 c2 1f 	      jsr	VOUTCH
    866  1f4a		       a5 51		      lda	CUROFF
    867  1f4c		       20 28 14 	      jsr	OUTHEX
    868  1f4f							;
    869  1f4f		       20 74 1e 	      jsr	CRLF
    870  1f52		       20 24 20 	      jsr	SetOutDebugEnd
    871  1f55		       20 88 1f 	      jsr	ILChkRange
    872  1f58		       b0 02		      bcs	dbgLineErr
    873  1f5a		       18		      clc
    874  1f5b		       60		      rts
    875  1f5c
    876  1f5c				   dbgLineErr
    877  1f5c		       20 f6 1f 	      jsr	SetOutDebug
    878  1f5f		       20 45 14 	      jsr	puts
      0  1f62					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1f62		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    880  1f83		       20 24 20 	      jsr	SetOutDebugEnd
    881  1f86		       38		      sec
    882  1f87		       60		      rts
    883  1f88
    884  1f88		       a5 44	   ILChkRange lda	ILPC+1
    885  1f8a		       c9 22		      cmp	#IL>>8
    886  1f8c		       90 18		      bcc	ILBadRange
    887  1f8e		       d0 06		      bne	ILChkHigh
    888  1f90
    889  1f90		       a5 43		      lda	ILPC
    890  1f92		       c9 9e		      cmp	#IL&$ff
    891  1f94		       90 10		      bcc	ILBadRange
    892  1f96
    893  1f96		       a5 44	   ILChkHigh  lda	ILPC+1
    894  1f98		       c9 26		      cmp	#ILEND>>8
    895  1f9a		       90 08		      bcc	ILGoodRange
    896  1f9c		       d0 08		      bne	ILBadRange
    897  1f9e
    898  1f9e		       a5 43		      lda	ILPC
    899  1fa0		       c9 1f		      cmp	#ILEND&$ff
    900  1fa2		       b0 02		      bcs	ILBadRange
    901  1fa4
    902  1fa4		       18	   ILGoodRange clc
    903  1fa5		       60		      rts
    904  1fa6				   ILBadRange
    905  1fa6		       38		      sec
    906  1fa7		       60		      rts
    907  1fa8
    908  1fa8
    909  1fa8							;=====================================================
    910  1fa8							; Set output vector to the console output function
    911  1fa8							;
    912  1fa8				   SetOutConsole
    913  1fa8		       48		      pha
    914  1fa9		       a9 0c		      lda	#OUTCH&$ff
    915  1fab		       8d b3 2f 	      sta	BOutVec
    916  1fae		       a9 f0		      lda	#OUTCH>>8
    917  1fb0		       8d b4 2f 	      sta	BOutVec+1
    918  1fb3		       68		      pla
    919  1fb4		       60		      rts
    920  1fb5
    921  1fb5				   SetInConsole
    922  1fb5		       48		      pha
    923  1fb6		       a9 09		      lda	#GETCH&$ff
    924  1fb8		       8d b5 2f 	      sta	BInVec
    925  1fbb		       a9 f0		      lda	#GETCH>>8
    926  1fbd		       8d b6 2f 	      sta	BInVec+1
    927  1fc0		       68		      pla
    928  1fc1		       60		      rts
    929  1fc2
    930  1fc2							;=====================================================
    931  1fc2							; Jump to the output/input function in BOutVec/BInVec
    932  1fc2							;
    933  1fc2		       6c b3 2f    VOUTCH     jmp	(BOutVec)
    934  1fc5		       6c b5 2f    VGETCH     jmp	(BInVec)
    935  1fc8
    936  1fc8
    937  1fc8							;====================================================
    938  1fc8							;Clear the terminal assume it is ansii or vt100
    939  1fc8							;
    940  1fc8				   iCLEARSCREEN
    941  1fc8		       20 45 14 	      jsr	puts
      0  1fcb					      db	$1b,'[,'2,'J,0
      1  1fcb		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    943  1fd0		       4c c3 02 	      jmp	NextIL
    944  1fd3
    945  1fd3							;====================================================
    946  1fd3							; Push true and false onto math stack
    947  1fd3				   pushTrue
    948  1fd3		       a9 ff		      lda	#$ff
    949  1fd5		       85 52	   pushTF     sta	R0
    950  1fd7		       85 53		      sta	R0+1
    951  1fd9		       20 29 1d 	      jsr	pushR0
    952  1fdc		       60		      rts
    953  1fdd		       a9 00	   pushFalse  lda	#0
    954  1fdf		       f0 f4		      beq	pushTF
    955  1fe1
    956  1fe1							;======================================================
    957  1fe1							; Copy stack top to R1
    958  1fe1				   CopyStackR1
    959  1fe1		       98		      tya
    960  1fe2		       48		      pha
    961  1fe3		       a4 4a		      ldy	MATHSTACKPTR
    962  1fe5		       88		      dey
    963  1fe6		       b1 48		      lda	(MATHSTACK),y
    964  1fe8		       85 55		      sta	R1+1
    965  1fea		       88		      dey
    966  1feb		       b1 48		      lda	(MATHSTACK),y
    967  1fed		       85 54		      sta	R1
    968  1fef		       68		      pla
    969  1ff0		       a8		      tay
    970  1ff1		       60		      rts
    971  1ff2
    972  1ff2
    973  1ff2							;====================================================
    974  1ff2							;Swap the out debug call for standard calls
    975  1ff2		       00 00	   DebugIOSave ds	2
    976  1ff4		       00 00	   DebugInSave ds	2
    977  1ff6				   SetOutDebug
    978  1ff6		       ad b3 2f 	      lda	BOutVec
    979  1ff9		       8d f2 1f 	      sta	DebugIOSave
    980  1ffc		       ad b4 2f 	      lda	BOutVec+1
    981  1fff		       8d f3 1f 	      sta	DebugIOSave+1
    982  2002		       a9 87		      lda	#OUTDEBUG&$ff	; Put the Debug output
    983  2004		       8d b3 2f 	      sta	BOutVec
    984  2007		       a9 20		      lda	#OUTDEBUG>>8
    985  2009		       8d b4 2f 	      sta	BOutVec+1
    986  200c		       60		      rts
    987  200d				   SetInDebug
    988  200d		       ad b5 2f 	      lda	BInVec
    989  2010		       8d f4 1f 	      sta	DebugInSave
    990  2013		       ad b6 2f 	      lda	BInVec+1
    991  2016		       8d f5 1f 	      sta	DebugInSave+1
    992  2019		       a9 8b		      lda	#INDEBUG&$ff
    993  201b		       8d b5 2f 	      sta	BInVec
    994  201e		       a9 20		      lda	#INDEBUG>>8
    995  2020		       8d b6 2f 	      sta	BInVec+1
    996  2023		       60		      rts
    997  2024				   SetOutDebugEnd
    998  2024		       ad f2 1f 	      lda	DebugIOSave
    999  2027		       8d b3 2f 	      sta	BOutVec
   1000  202a		       ad f3 1f 	      lda	DebugIOSave+1
   1001  202d		       8d b4 2f 	      sta	BOutVec+1
   1002  2030		       60		      rts
   1003  2031				   SetInDebugEnd
   1004  2031		       ad f4 1f 	      lda	DebugInSave
   1005  2034		       8d b5 2f 	      sta	BInVec
   1006  2037		       ad f3 1f 	      lda	DebugIOSave+1
   1007  203a		       8d b6 2f 	      sta	BInVec+1
   1008  203d		       60		      rts
   1009  203e							;
   1010  203e							;====================================================
   1011  203e							; Set the input and output terminal address
   1012  203e							; The math stack stack byte is the output io slot
   1013  203e							; The math stack  is the input io slot
   1014  203e
   1015  203e				   iSetTerminal
   1016  203e		       20 bb 1d 	      jsr	popR0	; Process the output io addresses
   1017  2041		       20 69 20 	      jsr	CalcSlot
   1018  2044		       a5 52		      lda	R0
   1019  2046		       09 01		      ora	#1
   1020  2048		       8d 88 20 	      sta	TerminalOutputPort
   1021  204b		       a5 53		      lda	R0+1
   1022  204d		       8d 89 20 	      sta	TerminalOutputPort+1
   1023  2050
   1024  2050		       20 bb 1d 	      jsr	popR0	; Process the input io address
   1025  2053		       20 69 20 	      jsr	CalcSlot
   1026  2056		       a5 52		      lda	R0
   1027  2058		       8d 93 20 	      sta	TerminalInputPort
   1028  205b		       09 01		      ora	#1
   1029  205d		       8d 8c 20 	      sta	TerminalStatusPort
   1030  2060		       a5 53		      lda	R0+1
   1031  2062		       8d 94 20 	      sta	TerminalInputPort+1
   1032  2065		       8d 8d 20 	      sta	TerminalStatusPort+1
   1033  2068		       60		      rts
   1034  2069
   1035  2069							;===================================================
   1036  2069							; Calculate the slot address the the slot number
   1037  2069							; R0 contains the slot number 0-255
   1038  2069
   1039  2069				   CalcSlot
   1040  2069		       8a		      txa
   1041  206a		       48		      pha
   1042  206b		       a2 04		      ldx	#4
   1043  206d				   CalcSlotLoop
   1044  206d		       06 52		      asl	R0
   1045  206f		       26 53		      rol	R0+1
   1046  2071		       ca		      dex
   1047  2072		       d0 f9		      bne	CalcSlotLoop
   1048  2074		       a9 e0		      lda	#$E0
   1049  2076		       05 53		      ora	R0+1
   1050  2078		       85 53		      sta	R0+1
   1051  207a		       68		      pla
   1052  207b		       aa		      tax
   1053  207c		       60		      rts
   1054  207d							;
   1055  207d							;====================================================
   1056  207d							; Output to the Terminal/Debug console
   1057  207d							;     x = high address byte
   1058  207d							;     y = low address byte
   1059  207d							;     a = Terminator for string
   1060  207d				   TerminalWrite
   1061  207d				   DebugWrite
   1062  207d		       20 f6 1f 	      jsr	SetOutDebug
   1063  2080		       20 83 14 	      jsr	PrtStr
   1064  2083		       20 24 20 	      jsr	SetOutDebugEnd
   1065  2086		       60		      rts
   1066  2087
   1067  2087				   OUTDEBUG
   1068  2087		       8d		      .byte.b	$8D	; STA
   1069  2088				   TerminalOutputPort
   1070  2088		       01 e0	   DEBUGPORT  .word.w	$E001	; Dont check anything just output the byte
   1071  208a		       60		      RTS
   1072  208b
   1073  208b				   TerminalRead
   1074  208b				   INDEBUG
   1075  208b		       ad		      .byte.b	$AD	; LDA
   1076  208c				   TerminalStatusPort
   1077  208c		       00 e0	   DEBUGPORTSTATUS .word.w	$E000
   1078  208e
   1079  208e		       29 01		      and	#$01
   1080  2090		       f0 f9		      beq	INDEBUG
   1081  2092
   1082  2092		       ad		      .byte.b	$AD	; LDA
   1083  2093				   TerminalInputPort
   1084  2093		       01 e0	   DEBUGPORTIN .word.w	$E001
   1085  2095		       60		      rts
   1086  2096
   1087  2096							;======================================================================
   1088  2096							;Copy Quoted string to buffer, terminate with 0 byte
   1089  2096							; R0  Source tring points to tString type
   1090  2096							; x is terminator
   1091  2096							; R1 points to destinition location
   1092  2096							; On exit R0 contains length of copy Plus Term and leading bytes
   1093  2096
   1094  2096				   qstrcpy
   1095  2096		       20 29 1d 	      jsr	pushR0
   1096  2099		       20 e6 20 	      jsr	IncR0	; point past the tString
   1097  209c		       20 e6 20 	      jsr	IncR0	; Point Past the opening "
   1098  209f		       a2 22		      ldx	#'"	; copy Termination
   1099  20a1		       20 bb 20 	      jsr	pstrcpy
   1100  20a4		       20 e6 20 	      jsr	IncR0	; point to "
   1101  20a7		       20 e6 20 	      jsr	IncR0	; Point to next free byte
   1102  20aa		       20 d3 1d 	      jsr	popR1
   1103  20ad		       38		      sec
   1104  20ae		       a5 52		      lda	R0
   1105  20b0		       e5 54		      sbc	R1
   1106  20b2		       85 52		      sta	R0
   1107  20b4		       a5 53		      lda	R0+1
   1108  20b6		       e5 55		      sbc	R1+1
   1109  20b8		       85 53		      sta	R0+1
   1110  20ba		       60		      rts
   1111  20bb
   1112  20bb							;=========================================================================
   1113  20bb							;Copy string from R0 to R1, terminator in x
   1114  20bb							; On exit    R0 contains the length of the copy
   1115  20bb				   pstrcpy
   1116  20bb		       a0 00		      ldy	#0
   1117  20bd		       86 58		      stx	R2
   1118  20bf
   1119  20bf				   strcpyLoop
   1120  20bf		       b1 52		      lda	(R0),y
   1121  20c1		       c5 58		      cmp	R2
   1122  20c3		       f0 0a		      beq	strcpyDone
   1123  20c5		       91 54		      sta	(R1),y
   1124  20c7		       20 e6 20 	      jsr	IncR0
   1125  20ca		       20 d4 20 	      jsr	IncR1
   1126  20cd		       90 f0		      bcc	strcpyLoop
   1127  20cf				   strcpyDone
   1128  20cf		       a9 00		      lda	#0
   1129  20d1		       91 54		      sta	(R1),y
   1130  20d3
   1131  20d3		       60		      rts
   1132  20d4
   1133  20d4							;=========================================================================
   1134  20d4							; on exit c is set on overflow
   1135  20d4				   IncR1
   1136  20d4		       48		      pha
   1137  20d5		       18		      clc
   1138  20d6		       a9 01		      lda	#1
   1139  20d8		       65 54		      adc	R1
   1140  20da		       85 54		      sta	R1
   1141  20dc		       90 06		      bcc	IncR1Done
   1142  20de		       a9 00		      lda	#0
   1143  20e0		       65 55		      adc	R1+1
   1144  20e2		       85 55		      sta	R1+1
   1145  20e4				   IncR1Done
   1146  20e4		       68		      pla
   1147  20e5		       60		      rts
   1148  20e6							;=========================================================================
   1149  20e6							; on exit c is set on overflow
   1150  20e6				   IncR0
   1151  20e6		       48		      pha
   1152  20e7		       18		      clc
   1153  20e8		       a9 01		      lda	#1
   1154  20ea		       65 52		      adc	R0
   1155  20ec		       85 52		      sta	R0
   1156  20ee		       90 06		      bcc	IncR0Done
   1157  20f0		       a9 00		      lda	#0
   1158  20f2		       65 53		      adc	R0+1
   1159  20f4		       85 53		      sta	R0+1
   1160  20f6				   IncR0Done
   1161  20f6		       68		      pla
   1162  20f7		       60		      rts
   1163  20f8
   1164  20f8
   1165  20f8
   1166  20f8
   1167  20f8
   1168  20f8
   1169  20f8
   1170  20f8
   1171  20f8
   1172  20f8
   1173  20f8
   1174  20f8
   1175  20f8
   1176  20f8
   1177  20f8
   1178  20f8
------- FILE mytb.asm
   2418  20f8
   2419  20f8					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  20f8					      include	"storage.asm"
      1  20f8							;
      2  20f8							;=====================================================
      3  20f8							;=====================================================
      4  20f8							;=====================================================
      5  20f8							; This file contains the functions for saving and
      6  20f8							; restoring programs from some sort of mass storage
      7  20f8							; device.  This particular version is for using the
      8  20f8							; Corsham Tech SD Card System.
      9  20f8							;=====================================================
     10  20f8							;=====================================================
     11  20f8							;=====================================================
     12  20f8
     13 U261f					      seg.u	TBData
     14 U261f		       00	   diskBufLength ds	1
     15 U2620		       00	   diskBufOffset ds	1
     16 U2621		       00 00 00 00*DiskFileName ds	64
     17 U2661
     18  20f8					      SEG	Code
     19  20f8
     20  20f8							;
     21  20f8							;=====================================================
     22  20f8							; Open a file for reading as a program.  The next
     23  20f8							; thing on the line should be the filename.
     24  20f8							;
     25  20f8				   iOPENREAD
     26  20f8					      if	XKIM || CTMON65
     27  20f8		       20 12 21 	      jsr	setFileName	;Set the file name to open
     28  20fb		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  20fe		       90 07		      bcc	Ropenok	;branch if opened ok
     30  2100							;
     31  2100							; Open failed
     32  2100							;
     33  2100		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  2102		       a9 00	   Rdfail2    lda	#0
     35  2104		       4c aa 06 	      jmp	iErr2
     36  2107							;
     37  2107							; Clear counts and offsets so the next read will
     38  2107							; cause the file to be read.
     39  2107							;
     40  2107		       a9 00	   Ropenok    lda	#0
     41  2109		       8d 20 26 	      sta	diskBufOffset
     42  210c		       8d 1f 26 	      sta	diskBufLength
     43  210f		       4c c3 02 	      jmp	NextIL
     44  2112					      endif
     45  2112
     46  2112							;===============================================================
     47  2112							; Set file name
     48  2112				   setFileName
     49  2112		       a4 51		      ldy	CUROFF
     50  2114		       b1 4f		      lda	(CURPTR),y
     51  2116		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  2118		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  211a
     54  211a		       18		      clc
     55  211b		       98		      tya
     56  211c		       65 4f		      adc	CURPTR
     57  211e		       85 52		      sta	R0	;LSB
     58  2120		       a5 50		      lda	CURPTR+1
     59  2122		       69 00		      adc	#0
     60  2124		       85 53		      sta	R0+1
     61  2126		       a9 21		      lda	#DiskFileName&$ff
     62  2128		       85 54		      sta	R1
     63  212a		       a9 26		      lda	#DiskFileName>>8
     64  212c		       85 55		      sta	R1+1
     65  212e		       20 96 20 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  2131		       a5 52		      lda	R0
     67  2133		       18		      clc
     68  2134		       65 51		      adc	CUROFF	; add the current offset
     69  2136		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  2138
     71  2138		       a0 21		      ldy	#DiskFileName&$ff
     72  213a		       a2 26		      ldx	#DiskFileName>>8
     73  213c		       18		      clc
     74  213d		       60		      rts
     75  213e
     76  213e				   setFileNameNotFound
     77  213e		       68		      pla
     78  213f		       68		      pla		; remove the return address from the stack
     79  2140		       a9 00		      lda	#0
     80  2142		       a2 09		      ldx	#ERR_NO_FILENAME
     81  2144		       4c aa 06 	      jmp	iErr2
     82  2147
     83  2147							;
     84  2147							;==============================JUSTLOSTINTIME 08/02/2022========
     85  2147							;Remove a file from the disk
     86  2147				   iRMFILE
     87  2147					      if	XKIM || CTMON65
     88  2147		       20 12 21 	      jsr	setFileName
     89  214a		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  214d		       90 07		      bcc	wrmOk	;branch if removed ok
     91  214f		       a9 00		      lda	#0
     92  2151		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  2153		       4c aa 06 	      jmp	iErr2
     94  2156				   wrmOk
     95  2156		       4c c3 02 	      jmp	NextIL
     96  2159
     97  2159					      endif
     98  2159							;
     99  2159							;=====================================================
    100  2159				   iOPENWRITE
    101  2159					      if	XKIM || CTMON65
    102  2159		       20 12 21 	      jsr	setFileName
    103  215c		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  215f		       90 07		      bcc	Wopenok	;branch if opened ok
    105  2161							;
    106  2161							; Open failed
    107  2161							;
    108  2161		       a9 00	   Wdfail     lda	#0
    109  2163		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  2165		       4c aa 06 	      jmp	iErr2
    111  2168							;
    112  2168		       4c c3 02    Wopenok    jmp	NextIL
    113  216b					      endif
    114  216b							;
    115  216b							;=====================================================
    116  216b							; Gets a line of input from the disk file and puts it
    117  216b							; into LINBUF.
    118  216b							;
    119  216b							; On exit:
    120  216b							;    CURPTR points to LINBUF
    121  216b							;    LINBUF contains the line with 0 at the end.
    122  216b							;    Y has offset to first non-space character
    123  216b							;    CURROFF has the same as Y.
    124  216b							;
    125  216b				   iDGETLINE
    126  216b					      if	XKIM || CTMON65
    127  216b		       a2 22		      ldx	#LINBUF&$ff
    128  216d		       86 4f		      stx	CURPTR
    129  216f		       a2 2f		      ldx	#LINBUF>>8
    130  2171		       86 50		      stx	CURPTR+1
    131  2173							;
    132  2173		       a2 00		      ldx	#0	;offset
    133  2175		       8e a6 2f    iDgetLoop  stx	getlinx
    134  2178		       20 e3 21 	      jsr	getNextFileByte
    135  217b		       b0 16		      bcs	iGetEOF
    136  217d		       c9 0d		      cmp	#CR
    137  217f		       f0 0d		      beq	iGetEOL
    138  2181		       c9 0a		      cmp	#LF
    139  2183		       f0 09		      beq	iGetEOL
    140  2185		       ae a6 2f 	      ldx	getlinx
    141  2188		       9d 22 2f 	      sta	LINBUF,x
    142  218b		       e8		      inx
    143  218c		       d0 e7		      bne	iDgetLoop
    144  218e							;
    145  218e							; Handle end of line.	If the line has nothing, loop
    146  218e							; back and get another line.
    147  218e							;
    148  218e		       ae a6 2f    iGetEOL    ldx	getlinx	;blank line?
    149  2191		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  2193							;
    151  2193							; This can fall through when there is a line, or
    152  2193							; called directly when EOF is encountered.
    153  2193							;
    154  2193		       ae a6 2f    iGetEOF    ldx	getlinx
    155  2196		       a9 00		      lda	#0
    156  2198		       9d 22 2f 	      sta	LINBUF,x
    157  219b		       a0 00		      ldy	#0
    158  219d		       20 6b 1e 	      jsr	SkipSpaces
    159  21a0		       20 e6 10 	      jsr	ParseInputLine
    160  21a3		       a9 e3		      lda	#TOKENBUFFER&$ff
    161  21a5		       85 4f		      sta	CURPTR
    162  21a7		       a9 0f		      lda	#TOKENBUFFER>>8
    163  21a9		       85 50		      sta	CURPTR+1
    164  21ab		       a9 01		      lda	#1
    165  21ad		       85 51		      sta	CUROFF
    166  21af		       4c c3 02 	      jmp	NextIL
    167  21b2					      endif
    168  21b2
    169  21b2							;
    170  21b2							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  21b2							; DISK
    172  21b2							;
    173  21b2				   iDDIR
    174  21b2					      if	XKIM || CTMON65
    175  21b2		       20 30 f0 	      jsr	DiskDir
    176  21b5							;
    177  21b5							; Get/Display each entry
    178  21b5							;
    179  21b5		       a2 26	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  21b7		       a0 21		      ldy	#DiskFileName&$ff
    181  21b9		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  21bc		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  21be		       20 45 14 	      jsr	puts
      0  21c1					      db	"   ",0
      1  21c1		       20 20 20 00	      .byte.b	"   ",0
    185  21c5							; Print the line to the console
    186  21c5		       a2 26		      ldx	#DiskFileName>>8	;pointer to buffer
    187  21c7		       a0 21		      ldy	#DiskFileName&$ff
    188  21c9		       a5 00		      lda	0
    189  21cb		       20 83 14 	      jsr	PrtStr	;else print name
    190  21ce		       20 18 f0 	      jsr	crlf
    191  21d1
    192  21d1		       4c b5 21 	      jmp	DiskDirLoop	;do next entry
    193  21d4
    194  21d4		       4c c3 02    DiskDirEnd jmp	NextIL
    195  21d7					      endif
    196  21d7							;
    197  21d7							;=====================================================
    198  21d7							; Does a LIST to a Disk file.
    199  21d7							;
    200  21d7				   iDLIST
    201  21d7					      if	XKIM || CTMON65
    202  21d7		       20 12 22 	      jsr	SetOutDisk
    203  21da		       4c 38 08 	      jmp	iLST2
    204  21dd					      endif
    205  21dd							;
    206  21dd							;=====================================================
    207  21dd							; Closes any pending disk file.  Okay to call if there
    208  21dd							; is no open file.
    209  21dd							;
    210  21dd				   iDCLOSE
    211  21dd					      if	XKIM || CTMON65
    212  21dd		       20 42 f0 	      jsr	DiskClose
    213  21e0		       4c c3 02 	      jmp	NextIL
    214  21e3					      endif
    215  21e3							;
    216  21e3							;=====================================================
    217  21e3							; This gets the next byte from an open disk file.  If
    218  21e3							; there are no more bytes left, this returns C set.
    219  21e3							; Else, C is clear and A contains the character.
    220  21e3							;
    221  21e3				   getNextFileByte
    222  21e3					      if	XKIM || CTMON65
    223  21e3		       ae 20 26 	      ldx	diskBufOffset
    224  21e6		       ec 1f 26 	      cpx	diskBufLength
    225  21e9		       d0 14		      bne	hasdata	;branch if still data
    226  21eb							;
    227  21eb							; There is no data left in the buffer, so read a
    228  21eb							; block from the SD system.
    229  21eb							;
    230  21eb		       a9 84		      lda	#BUFFER_SIZE
    231  21ed		       a2 df		      ldx	#buffer>>8
    232  21ef		       a0 0a		      ldy	#buffer&$ff
    233  21f1		       20 3c f0 	      jsr	DiskRead
    234  21f4		       b0 12		      bcs	getNextEof
    235  21f6							;
    236  21f6							; A contains the number of bytes actually read.
    237  21f6							;
    238  21f6		       8d 1f 26 	      sta	diskBufLength	;save length
    239  21f9		       c9 00		      cmp	#0	;shouldn't happen
    240  21fb		       f0 0b		      beq	getNextEof
    241  21fd							;
    242  21fd		       a2 00		      ldx	#0
    243  21ff		       bd 0a df    hasdata    lda	buffer,x
    244  2202		       e8		      inx
    245  2203		       8e 20 26 	      stx	diskBufOffset
    246  2206		       18		      clc
    247  2207		       60		      rts
    248  2208							;
    249  2208		       a9 00	   getNextEof lda	#0
    250  220a		       8d 20 26 	      sta	diskBufOffset
    251  220d		       8d 1f 26 	      sta	diskBufLength
    252  2210		       38		      sec
    253  2211		       60		      rts
    254  2212							;
    255  2212							;=====================================================
    256  2212							; Set output vector to the disk output function
    257  2212							;
    258  2212		       a9 1d	   SetOutDisk lda	#DOUT&$ff
    259  2214		       8d b3 2f 	      sta	BOutVec
    260  2217		       a9 22		      lda	#DOUT/256
    261  2219		       8d b4 2f 	      sta	BOutVec+1
    262  221c		       60		      rts
    263  221d							;
    264  221d							;=====================================================
    265  221d
    266  221d		       8e 21 26    DOUT       stx	DiskFileName
    267  2220		       8c 22 26 	      sty	DiskFileName+1
    268  2223		       8d 0a df 	      sta	buffer
    269  2226		       a9 01		      lda	#1
    270  2228		       a0 0a		      ldy	#buffer&$ff
    271  222a		       a2 df		      ldx	#buffer>>8
    272  222c		       20 3f f0 	      jsr	DiskWrite
    273  222f		       ae 21 26 	      ldx	DiskFileName
    274  2232		       ac 22 26 	      ldy	DiskFileName+1
    275  2235
    276  2235							;
    277  2235							; need error checking here
    278  2235							;
    279  2235		       60		      rts
    280  2236					      endif
    281  2236
    282  2236
------- FILE mytb.asm
   2421  2236					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  2236					      include	"IL.inc"
      1  2236
      2  2236							;=====================================================
      3  2236							; IL.inc
      4  2236							; These are macros for IL instructions
      5  2236							;
      6  2236					      mac	dw
      7  2236					      .word	{0}
      8  2236					      endm
      9  2236					      mac	db
     10  2236					      .byte	{0}
     11  2236					      endm
     12  2236					      macro	xinit
     13  2236					      db	0
     14  2236					      endm		;reset the il to start clear all
     15  2236							;
     16  2236					      macro	done
     17  2236					      db	1
     18  2236					      endm		;print an error if not end of line
     19  2236							;
     20  2236					      macro	prs
     21  2236					      db	2
     22  2236					      endm		;print a quoted string
     23  2236							;
     24  2236					      macro	prn
     25  2236					      db	3
     26  2236					      endm		;print a number
     27  2236							;
     28  2236					      macro	spc
     29  2236					      db	4
     30  2236					      endm		;print space til new tabstop
     31  2236							;
     32  2236					      macro	nline
     33  2236					      db	5
     34  2236					      endm		;print a new line crlf
     35  2236							;
     36  2236							; My NXT is a bit different in that it takes one
     37  2236							; parameter, which is an address.  If the BASIC
     38  2236							; program is currently running then move to the
     39  2236							; next line and continue execution.  However, if
     40  2236							; in direct mode, jump to the specified IL label.
     41  2236							;
     42  2236					      macro	nxt
     43  2236					      db	6
     44  2236					      dw	{1}	; addr
     45  2236					      endm		; addr
     46  2236							;
     47  2236					      macro	xfer
     48  2236					      db	7
     49  2236					      endm
     50  2236							;
     51  2236					      macro	sav
     52  2236					      db	8
     53  2236					      db	{1}
     54  2236					      endm
     55  2236							;
     56  2236							;  Passed jump if function called, and true false value returned
     57  2236					      macro	rstr
     58  2236					      db	9
     59  2236					      db	({1}-*)-1	;(addr-*)-1
     60  2236					      db	{2}
     61  2236					      endm
     62  2236							;
     63  2236					      macro	cmpr
     64  2236					      db	10
     65  2236					      endm
     66  2236							;
     67  2236					      macro	innum
     68  2236					      db	11
     69  2236					      endm
     70  2236							;
     71  2236					      macro	fin
     72  2236					      db	12
     73  2236					      endm
     74  2236							;
     75  2236							; ERR is followed by an error number.	The error
     76  2236							; code is printed along with the line number.
     77  2236							; Control is passed to the statement set with
     78  2236							; the ERRGOTO statement.
     79  2236							;
     80  2236					      macro	errmsg
     81  2236					      db	13
     82  2236					      dw	{1}	;ecode
     83  2236					      endm		;ecode
     84  2236							;
     85  2236					      macro	add
     86  2236					      db	14
     87  2236					      endm
     88  2236							;
     89  2236					      macro	sub
     90  2236					      db	15
     91  2236					      endm
     92  2236							;
     93  2236					      macro	neg
     94  2236					      db	16
     95  2236					      endm
     96  2236							;
     97  2236					      macro	mul
     98  2236					      db	17
     99  2236					      endm
    100  2236							;
    101  2236					      macro	div
    102  2236					      db	18
    103  2236					      endm
    104  2236							;
    105  2236					      macro	store
    106  2236					      db	19
    107  2236					      endm
    108  2236							;
    109  2236					      macro	ind
    110  2236					      db	20
    111  2236					      endm
    112  2236							;
    113  2236					      macro	lst
    114  2236					      db	21
    115  2236					      endm
    116  2236							;
    117  2236					      macro	init
    118  2236					      db	22
    119  2236					      endm
    120  2236							;
    121  2236					      macro	getline
    122  2236					      db	23
    123  2236					      endm
    124  2236							;
    125  2236					      macro	insert
    126  2236					      db	24
    127  2236					      endm
    128  2236							;
    129  2236					      macro	rtn
    130  2236					      db	25
    131  2236					      endm
    132  2236							;
    133  2236					      macro	exit
    134  2236					      db	26
    135  2236					      endm
    136  2236							;
    137  2236					      macro	lit
    138  2236					      db	27
    139  2236					      dw	{1}	;value
    140  2236					      endm		; value LIT
    141  2236							;
    142  2236					      macro	call
    143  2236					      db	28
    144  2236					      dw	{1}	;addr
    145  2236					      endm		;addr
    146  2236							;
    147  2236							; IJMP will set the IL PC to the specified value.
    148  2236							;
    149  2236					      macro	ijmp
    150  2236					      db	29
    151  2236					      dw	{1}	;addr
    152  2236					      endm		;addr
    153  2236							;
    154  2236					      macro	vinit
    155  2236					      db	30
    156  2236					      endm
    157  2236							;
    158  2236							; ERRGOTO sets the point in the code where the IL
    159  2236							; interpreter will go after any error.
    160  2236							;
    161  2236					      macro	errgoto
    162  2236					      db	31
    163  2236					      dw	{1}	;addr
    164  2236					      endm		;addr
    165  2236							;
    166  2236					      macro	tst
    167  2236					      db	32
    168  2236					      db	({1}-*)-1	;(addr-*)-1
    169  2236					      db	{2},0	;string,0
    170  2236					      endm		;addr,string
    171  2236							;
    172  2236					      macro	tstv
    173  2236					      db	33
    174  2236					      db	({1}-*)-1	;(addr-*)-1
    175  2236					      endm		;addr
    176  2236							;
    177  2236					      macro	tstl
    178  2236					      db	34
    179  2236					      db	({1}-*)-1	;(addr-*)-1
    180  2236					      endm		;addr
    181  2236							;
    182  2236					      macro	tstn
    183  2236					      db	35
    184  2236					      db	({1}-*)-1	;(addr-*)-1
    185  2236					      endm		;addr
    186  2236							;
    187  2236							; FREE returns the amount of free RAM on top of
    188  2236							; the stack.  This is the amount of room the user
    189  2236							; program has available.
    190  2236							;
    191  2236					      macro	free
    192  2236					      db	36
    193  2236					      endm
    194  2236							;
    195  2236							; RANDOM takes the top item off the stack and
    196  2236							; replaces it with a random number that is
    197  2236							; MOD the initial value.  Ie, if the TOS is
    198  2236							; 42 then RANDOM returns a value from 0 to 41.
    199  2236							;
    200  2236					      macro	random
    201  2236					      db	37
    202  2236					      endm
    203  2236							;
    204  2236							; ABS will replace the top of stack with the
    205  2236							; absolute value.
    206  2236							;
    207  2236					      macro	abs
    208  2236					      db	38
    209  2236					      endm
    210  2236							;
    211  2236							; OPENREAD opens a file for reading, as in getting
    212  2236							; statements from it.
    213  2236							;
    214  2236					      macro	openread
    215  2236					      db	39
    216  2236					      endm
    217  2236							;
    218  2236							; OPENWRITE opens a file for writing, as in saving
    219  2236							; the current program to it.
    220  2236							;
    221  2236					      macro	openwrite
    222  2236					      db	40
    223  2236					      endm
    224  2236							;
    225  2236							; DCLOSE closes any open disk file.
    226  2236							;
    227  2236					      macro	dclose
    228  2236					      db	41
    229  2236					      endm
    230  2236							;
    231  2236							; DGETLINE gets one line from the disk file and puts it
    232  2236							; into LINBUFF.
    233  2236							;
    234  2236					      macro	dgetline
    235  2236					      db	42
    236  2236					      endm
    237  2236							;
    238  2236							; DLIST saves the program to an open disk file.
    239  2236							;
    240  2236					      macro	dlist
    241  2236					      db	43
    242  2236					      endm
    243  2236							; DDIR list the current directory
    244  2236							;
    245  2236					      macro	ddir
    246  2236					      db	44
    247  2236					      endm
    248  2236
    249  2236							; RMFILE remove a fle from disk
    250  2236					      macro	rmfile
    251  2236					      db	45
    252  2236					      endm
    253  2236
    254  2236							; CLEARSCREEN clear the screen
    255  2236					      macro	clearscreen
    256  2236					      db	46
    257  2236					      endm
    258  2236							; POKEMEM Poke value into memory
    259  2236					      macro	pokemem
    260  2236					      db	47
    261  2236					      endm
    262  2236							; PEEKMEM peek at value in memory
    263  2236					      macro	peekmem
    264  2236					      db	48
    265  2236					      endm
    266  2236							; TSTLET Test if the statement is a let without the keyword let
    267  2236					      macro	tstlet
    268  2236					      db	49
    269  2236					      db	({1}-*)-1	;(addr-*)-1
    270  2236					      endm		;addr
    271  2236							; TSTDONE if we reach the end of a statement
    272  2236					      macro	tstdone
    273  2236					      db	50
    274  2236					      db	({1}-*)-1	;(addr-*)-1
    275  2236					      endm		;addr
    276  2236							; GETCHAR	get a character from the input line leave it in RO
    277  2236					      macro	getchar
    278  2236					      db	51
    279  2236					      endm
    280  2236							; PUTCHAR	Put a character to the terminal
    281  2236					      macro	putchar
    282  2236					      db	52
    283  2236					      endm
    284  2236							; Call		Call a machine function return a to stack
    285  2236					      macro	callfunc
    286  2236					      db	53
    287  2236					      endm
    288  2236
    289  2236							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    290  2236					      macro	ibranch
    291  2236					      db	54
    292  2236					      endm
    293  2236
    294  2236							; TSTSTR	 Tests for the open quote in a string
    295  2236					      macro	tststr
    296  2236					      db	55
    297  2236					      db	({1}-*)-1	;(addr-*)-1
    298  2236					      endm
    299  2236							; SETIRQ	Sets the line number to run when an irq happens irq 550
    300  2236					      macro	setirq
    301  2236					      db	56
    302  2236					      endm
    303  2236
    304  2236							; TSTIRQ	Test for irq pending,
    305  2236							;		if so push the IRQ LINE NUMBER into RO, onto stack
    306  2236					      macro	tstirq
    307  2236					      db	57
    308  2236					      db	({1}-*)-1	;(addr-*)-1
    309  2236					      endm
    310  2236
    311  2236							; IRET    return from interupt service
    312  2236					      macro	iret
    313  2236					      db	58
    314  2236					      endm
    315  2236
    316  2236							; INSTR   read a string from the input
    317  2236					      macro	instr
    318  2236					      db	59
    319  2236					      endm
    320  2236
    321  2236							; MODULO Returns the remainder of the division
    322  2236					      macro	modulo
    323  2236					      db	60
    324  2236					      endm
    325  2236							; Set a task line
    326  2236					      macro	taskcreate
    327  2236					      db	61
    328  2236					      endm
    329  2236							; End a task
    330  2236					      macro	etask
    331  2236					      db	62
    332  2236					      endm
    333  2236							; Skip to next task
    334  2236					      macro	ntask
    335  2236					      db	63
    336  2236					      endm
    337  2236							; Subscript
    338  2236					      macro	subscript
    339  2236					      db	64
    340  2236					      db	{1}
    341  2236					      endm
    342  2236							; KILL Task
    343  2236					      macro	taskkill
    344  2236					      db	65
    345  2236					      endm
    346  2236							; STAT Task
    347  2236					      macro	taskstat
    348  2236					      db	66
    349  2236					      endm
    350  2236							;  output value as hex
    351  2236					      macro	hexprt
    352  2236					      db	67
    353  2236					      endm
    354  2236							;  Read in background has completed
    355  2236					      macro	readcomplete
    356  2236					      db	68
    357  2236					      endm
    358  2236							;  ReadInput line
    359  2236					      macro	readstart
    360  2236					      db	69
    361  2236					      endm
    362  2236							; Startio request
    363  2236					      macro	startio
    364  2236					      db	70
    365  2236					      endm
    366  2236							; Endio
    367  2236					      macro	endio
    368  2236					      db	71
    369  2236					      endm
    370  2236							; Logical not
    371  2236					      macro	lognot
    372  2236					      db	72
    373  2236					      endm
    374  2236							; Logical OR
    375  2236					      macro	logor
    376  2236					      db	73
    377  2236					      endm
    378  2236							;Logical and
    379  2236					      macro	logand
    380  2236					      db	74
    381  2236					      endm
    382  2236							;Logical XOR
    383  2236					      macro	logxor
    384  2236					      db	75
    385  2236					      endm
    386  2236							;Wait for task to complete, or list of tasks
    387  2236					      macro	wtask
    388  2236					      db	76
    389  2236					      db	({1}-*)-1	;(addr-*)-1
    390  2236					      endm
    391  2236							;Get the current task id
    392  2236					      MACRO	taskpid
    393  2236					      db	77
    394  2236					      endm
    395  2236							;Trace the basic execution
    396  2236					      Macro	traceprogram
    397  2236					      db	78
    398  2236					      endm
    399  2236							;Do a basic program Trace
    400  2236					      Macro	debugbasic
    401  2236					      db	79
    402  2236					      endm
    403  2236
    404  2236							; Inter Process communications instructions
    405  2236					      Macro	ipcsend
    406  2236					      db	80
    407  2236					      endm
    408  2236					      Macro	ipcreceive
    409  2236					      db	81
    410  2236					      endm
    411  2236					      Macro	ipccheck
    412  2236					      db	82
    413  2236					      endm
    414  2236					      Macro	ipcio
    415  2236					      db	83
    416  2236					      endm
    417  2236					      Macro	pushmathstack
    418  2236					      db	84
    419  2236					      endm
    420  2236					      Macro	popmathstack
    421  2236					      db	85
    422  2236					      endm
    423  2236					      Macro	savemathstack
    424  2236					      db	86
    425  2236					      endm
    426  2236					      Macro	restoremathstack
    427  2236					      db	87
    428  2236					      endm
    429  2236					      Macro	incparmcount
    430  2236					      db	88
    431  2236					      endm
    432  2236					      Macro	taskgetmathstack
    433  2236					      db	89
    434  2236					      endm
    435  2236					      Macro	taskenable
    436  2236					      db	90
    437  2236					      endm
    438  2236					      Macro	tasksuspend
    439  2236					      db	91
    440  2236					      endm
    441  2236					      Macro	taskputmathptr
    442  2236					      db	92
    443  2236					      endm
    444  2236							; Test for an extension type of variable that allows access to a tasks variables
    445  2236							; Using  PID!<Var name>
    446  2236					      Macro	tstvt
    447  2236					      db	93
    448  2236					      db	({1}-*)-1	;(addr-*)-1
    449  2236					      endm
    450  2236
    451  2236							; Provide access to R2 for the IL program
    452  2236					      Macro	setr2
    453  2236					      db	94
    454  2236					      db	{1}	; R2 is only one byte
    455  2236					      endm
    456  2236							;Move stack top to temp
    457  2236					      Macro	stk2tmp
    458  2236					      db	95
    459  2236					      endm
    460  2236
    461  2236					      Macro	tmp2stk
    462  2236					      db	96
    463  2236					      endm
    464  2236
    465  2236					      Macro	tstbyte
    466  2236					      db	97
    467  2236					      db	({1}-*)-1	; (addr-*)-1 goto if match
    468  2236					      dw	{2}	; address to check
    469  2236					      db	{3}	; Value to compare
    470  2236					      endm
    471  2236
    472  2236					      Macro	incvar
    473  2236					      db	98
    474  2236					      endm
    475  2236					      Macro	decvar
    476  2236					      db	99
    477  2236					      endm
    478  2236
    479  2236					      Macro	slice
    480  2236					      db	100
    481  2236					      endm
    482  2236
    483  2236					      Macro	tstb
    484  2236					      db	101
    485  2236					      db	({1}-*)-1
    486  2236					      db	{2}
    487  2236					      endm
    488  2236
    489  2236					      Macro	tstw
    490  2236					      db	102
    491  2236					      db	({1}-*)-1
    492  2236					      dw	{2}
    493  2236					      endm
    494  2236
    495  2236					      Macro	ongoto
    496  2236					      db	103
    497  2236					      dw	{1}
    498  2236					      dw	{2}
    499  2236					      endm
    500  2236
    501  2236					      Macro	tstrelop
    502  2236					      db	104
    503  2236					      db	({1}-*)-1
    504  2236					      endm
    505  2236
    506  2236					      Macro	repeatline
    507  2236					      db	105
    508  2236					      endm
    509  2236
    510  2236							; Check for a precompiled branch, will take branch if precompiled value present
    511  2236					      Macro	tstbranch
    512  2236					      db	106
    513  2236					      db	({1}-*)-1
    514  2236					      endm
    515  2236
    516  2236					      Macro	fastxfer
    517  2236					      db	107
    518  2236					      endm
    519  2236							; Set all io to to a terminal for input output
    520  2236							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    521  2236							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    522  2236					      Macro	setterminal
    523  2236					      db	108
    524  2236					      endm
------- FILE mytb.asm
   2423  2236							;
   2424  2236				  -	      if	FIXED
   2425  2236				  -	      org	$1000
   2426  2236					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  2236					      include	"basic.il"
      1  2236					      seg	Code
      2  2236							; on goto table
      3  2236							; format :   first byte is value Base, subtracted from value found
      4  2236							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  2236				   BasicStmts
      0  2236					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  2236		       01 1f		      .byte.b	kBeginKey,(kKeyCount+1)
      0  2238					      dw	ekLet
      1  2238		       b1 22		      .word.w	ekLet
      0  223a					      dw	ekInc
      1  223a		       ca 22		      .word.w	ekInc
      0  223c					      dw	ekDec
      1  223c		       da 22		      .word.w	ekDec
      0  223e					      dw	ekIreturn
      1  223e		       ea 22		      .word.w	ekIreturn
      0  2240					      dw	ekIf
      1  2240		       ef 22		      .word.w	ekIf
      0  2242					      dw	ekThen
      1  2242		       f5 22		      .word.w	ekThen
      0  2244					      dw	ekGoto
      1  2244		       f9 22		      .word.w	ekGoto
      0  2246					      dw	ekGosub
      1  2246		       0d 23		      .word.w	ekGosub
      0  2248					      dw	ekReturn
      1  2248		       14 23		      .word.w	ekReturn
      0  224a					      dw	ekRem
      1  224a		       34 23		      .word.w	ekRem
      0  224c					      dw	ekPrint	; should be entry for print
      1  224c		       3a 23		      .word.w	ekPrint
      0  224e					      dw	ekTaske
      1  224e		       87 23		      .word.w	ekTaske
      0  2250					      dw	ekTaskn
      1  2250		       9d 23		      .word.w	ekTaskn
      0  2252					      dw	ekTaskw
      1  2252		       a4 23		      .word.w	ekTaskw
      0  2254					      dw	ekPoke
      1  2254		       bf 23		      .word.w	ekPoke
      0  2256					      dw	ekPutch
      1  2256		       d6 23		      .word.w	ekPutch
      0  2258					      dw	ekCls
      1  2258		       e1 23		      .word.w	ekCls
      0  225a					      dw	ekInput
      1  225a		       e8 23		      .word.w	ekInput
      0  225c					      dw	ekEnd
      1  225c		       10 24		      .word.w	ekEnd
      0  225e					      dw	ekIrq
      1  225e		       14 24		      .word.w	ekIrq
      0  2260					      dw	ekKill
      1  2260		       1f 24		      .word.w	ekKill
      0  2262					      dw	ekList
      1  2262		       2a 24		      .word.w	ekList
      0  2264					      dw	ekRun
      1  2264		       2f 24		      .word.w	ekRun
      0  2266					      dw	ekNew
      1  2266		       38 24		      .word.w	ekNew
      0  2268					      dw	ekSlice
      1  2268		       3c 24		      .word.w	ekSlice
      0  226a					      dw	ekTrace
      1  226a		       47 24		      .word.w	ekTrace
      0  226c					      dw	ekExit
      1  226c		       58 24		      .word.w	ekExit
      0  226e					      dw	ekSave
      1  226e		       59 24		      .word.w	ekSave
      0  2270					      dw	ekLoad
      1  2270		       5f 24		      .word.w	ekLoad
      0  2272					      dw	ekErase
      1  2272		       72 24		      .word.w	ekErase
      0  2274					      dw	ekDir
      1  2274		       6b 24		      .word.w	ekDir
     38  2276							;
     39  2276							; Logical operators
      0  2276				   BasicLogical db	kOr,3
      1  2276		       21 03		      .byte.b	kOr,3
      0  2278					      dw	ekOr
      1  2278		       8f 24		      .word.w	ekOr
      0  227a					      dw	ekXor
      1  227a		       94 24		      .word.w	ekXor
      0  227c					      dw	ekAnd
      1  227c		       8a 24		      .word.w	ekAnd
     44  227e
     45  227e							;functions returning values
     46  227e
      0  227e				   BasicFuncs db	kBeginFunc,kFuncCount
      1  227e		       24 0f		      .byte.b	kBeginFunc,kFuncCount
      0  2280					      dw	ekTrue
      1  2280		       f4 24		      .word.w	ekTrue
      0  2282					      dw	ekFalse
      1  2282		       f8 24		      .word.w	ekFalse
      0  2284					      dw	ekFree
      1  2284		       fc 24		      .word.w	ekFree
      0  2286					      dw	ekGetch
      1  2286		       04 25		      .word.w	ekGetch
      0  2288					      dw	ekPeek
      1  2288		       0c 25		      .word.w	ekPeek
      0  228a					      dw	ekTask
      1  228a		       17 25		      .word.w	ekTask
      0  228c					      dw	ekIpcc
      1  228c		       63 25		      .word.w	ekIpcc
      0  228e					      dw	ekIpcs
      1  228e		       3e 25		      .word.w	ekIpcs
      0  2290					      dw	ekIpcr
      1  2290		       4f 25		      .word.w	ekIpcr
      0  2292					      dw	ekRnd
      1  2292		       6e 25		      .word.w	ekRnd
      0  2294					      dw	ekStat
      1  2294		       8c 25		      .word.w	ekStat
      0  2296					      dw	ekAbs
      1  2296		       81 25		      .word.w	ekAbs
      0  2298					      dw	ekCall
      1  2298		       99 25		      .word.w	ekCall
      0  229a					      dw	ekGofn
      1  229a		       b2 25		      .word.w	ekGofn
      0  229c					      dw	ekPid
      1  229c		       97 25		      .word.w	ekPid
     63  229e
     64  229e
     65  229e							;=====================================================
     66  229e							; This is the IL of the BASIC (or whatever) language.
     67  229e							; Because of the way macros are implemented by as65,
     68  229e							; labels can't be on the same line as a macro
     69  229e							; invocation, so that's why labels are on separate
     70  229e							; lines.
     71  229e							;
     72  229e		       22 9e	   IL	      equ	*
     73  229e
     74  229e							;THE IL CONTROL SECTION
     75  229e
     76  229e				   START
      0  229e					      INIT		;INITIALIZE
      0  229e					      db	22
      1  229e		       16		      .byte.b	22
      0  229f					      NLINE		;WRITE CRLF
      0  229f					      db	5
      1  229f		       05		      .byte.b	5
      0  22a0					      ERRGOTO	CO	;where to go after an error
      0  22a0					      db	31
      1  22a0		       1f		      .byte.b	31
      0  22a1					      dw	CO
      1  22a1		       a4 22		      .word.w	CO
      0  22a3					      VINIT		;clear all variables
      0  22a3					      db	30
      1  22a3		       1e		      .byte.b	30
     81  22a4							;
     82  22a4							; This is where we jump to get a line of commands or
     83  22a4							; a program from the user.
     84  22a4							;
     85  22a4				   CO
      0  22a4					      GETLINE		;WRITE PROMPT AND GET LINE
      0  22a4					      db	23
      1  22a4		       17		      .byte.b	23
      0  22a5					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  22a5					      db	34
      1  22a5		       22		      .byte.b	34
      0  22a6					      db	(XEC-*)-1
      1  22a6		       04		      .byte.b	(XEC-*)-1
      0  22a7					      INSERT		;INSERT IT (MAY BE DELETE)
      0  22a7					      db	24
      1  22a7		       18		      .byte.b	24
      0  22a8					      IJMP	CO
      0  22a8					      db	29
      1  22a8		       1d		      .byte.b	29
      0  22a9					      dw	CO
      1  22a9		       a4 22		      .word.w	CO
     90  22ab				   XEC
      0  22ab					      XINIT		;INITIALIZE
      0  22ab					      db	0
      1  22ab		       00		      .byte.b	0
     92  22ac							;============================================================================
     93  22ac							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     94  22ac							;
     95  22ac				   STMT
      0  22ac					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  22ac					      db	79
      1  22ac		       4f		      .byte.b	79
      0  22ad					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  22ad					      db	57
      1  22ad		       39		      .byte.b	57
      0  22ae					      db	(notirq-*)-1
      1  22ae		       00		      .byte.b	(notirq-*)-1
     98  22af							;==========================================================================================
     99  22af							; Process a let statement implied or explicit.
    100  22af							;
    101  22af				   notirq
      0  22af					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  22af					      db	49
      1  22af		       31		      .byte.b	49
      0  22b0					      db	(DoVector-*)-1
      1  22b0		       14		      .byte.b	(DoVector-*)-1
    103  22b1				   ekLet
      0  22b1					      CALL	FactVarPTR	; get a pointer to the variable
      0  22b1					      db	28
      1  22b1		       1c		      .byte.b	28
      0  22b2					      dw	FactVarPTR
      1  22b2		       d1 25		      .word.w	FactVarPTR
    105  22b4							;	  TSTV	     ERRVEC2			    ; YES, PLACE VAR ADDRESS ON AESTK
    106  22b4							;	  TSTB	     LETSCONT,oBang		    ; allow to assign to another Tasks Variable
    107  22b4							;	  IND
    108  22b4							;	  TSTVT      ERRVEC2;
    109  22b4							;
    110  22b4							;LETSCONT:
    111  22b4							;	  TSTB	     LETSQBRACKET,oEqual	    ; (This line originally omitted)
    112  22b4							;	  IJMP	     LETBE;
    113  22b4							;
    114  22b4							;LETSQBRACKET: 				    ; is this an array access ?;
    115  22b4							;
    116  22b4							;	  TSTB	     ERRVEC2,oLeftSQBracket	     ; [
    117  22b4							;	  CALL	     EXPR
    118  22b4							;	  TSTB	     ERRVEC2,oRightSQBracket	     ; ]
    119  22b4							;	  TSTB	     LETINDEX_INTEGER,oDollar
    120  22b4							;	  SUBSCRIPT  1
    121  22b4							;	  IJMP	     LETINDEX_ALL
    122  22b4							;LETINDEX_INTEGER:
    123  22b4							;	  SUBSCRIPT  0
    124  22b4							;
    125  22b4				   LETINDEX_ALL
      0  22b4					      TSTB	ERRVEC2,oEqual	; (This line originally omitted)
      0  22b4					      db	101
      1  22b4		       65		      .byte.b	101
      0  22b5					      db	(ERRVEC2-*)-1
      1  22b5		       0c		      .byte.b	(ERRVEC2-*)-1
      0  22b6					      db	oEqual
      1  22b6		       f2		      .byte.b	oEqual
    127  22b7				   LETBE
    128  22b7
      0  22b7					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  22b7					      db	28
      1  22b7		       1c		      .byte.b	28
      0  22b8					      dw	EXPR
      1  22b8		       7a 24		      .word.w	EXPR
      0  22ba					      DONE		; REPORT ERROR IF NOT NEXT
      0  22ba					      db	1
      1  22ba		       01		      .byte.b	1
      0  22bb					      STORE		; STORE RESULT
      0  22bb					      db	19
      1  22bb		       13		      .byte.b	19
      0  22bc					      NXT	CO	; AND SEQUENCE TO NEXT
      0  22bc					      db	6
      1  22bc		       06		      .byte.b	6
      0  22bd					      dw	CO
      1  22bd		       a4 22		      .word.w	CO
      0  22bf					      IJMP	STMT
      0  22bf					      db	29
      1  22bf		       1d		      .byte.b	29
      0  22c0					      dw	STMT
      1  22c0		       ac 22		      .word.w	STMT
    134  22c2				   ERRVEC2
      0  22c2					      IJMP	UNKNOWN
      0  22c2					      db	29
      1  22c2		       1d		      .byte.b	29
      0  22c3					      dw	UNKNOWN
      1  22c3		       76 24		      .word.w	UNKNOWN
    136  22c5							;=============================================================
    137  22c5							;Branch on a valid statement start
    138  22c5				   DoVector
      0  22c5					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  22c5					      db	103
      1  22c5		       67		      .byte.b	103
      0  22c6					      dw	BasicStmts
      1  22c6		       36 22		      .word.w	BasicStmts
      0  22c8					      dw	UNKNOWN
      1  22c8		       76 24		      .word.w	UNKNOWN
    140  22ca							;This will never return here!
    141  22ca							;=============================================================
    142  22ca							; Inc or dec a variable
    143  22ca							;S1:
    144  22ca							;	  TSTB	     S1Dec,kInc 		    ; Increment variable
    145  22ca				   ekInc
      0  22ca					      TSTV	ERRVEC2	; Verify we have a variable
      0  22ca					      db	33
      1  22ca		       21		      .byte.b	33
      0  22cb					      db	(ERRVEC2-*)-1
      1  22cb		       f6		      .byte.b	(ERRVEC2-*)-1
      0  22cc					      TSTB	eDoInc,oBang	; Allow to inc or dec other tasks variables
      0  22cc					      db	101
      1  22cc		       65		      .byte.b	101
      0  22cd					      db	(eDoInc-*)-1
      1  22cd		       04		      .byte.b	(eDoInc-*)-1
      0  22ce					      db	oBang
      1  22ce		       e8		      .byte.b	oBang
      0  22cf					      IND		; we just got a pid
      0  22cf					      db	20
      1  22cf		       14		      .byte.b	20
      0  22d0					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  22d0					      db	93
      1  22d0		       5d		      .byte.b	93
      0  22d1					      db	(ERRVEC2-*)-1
      1  22d1		       f0		      .byte.b	(ERRVEC2-*)-1
    150  22d2				   eDoInc
      0  22d2					      INCVAR		; Do the increment of the variable
      0  22d2					      db	98
      1  22d2		       62		      .byte.b	98
      0  22d3					      DONE		; Test for end of line or end of statement ":"
      0  22d3					      db	1
      1  22d3		       01		      .byte.b	1
      0  22d4					      NXT	CO	; Get the next statement, branch CO if end of program
      0  22d4					      db	6
      1  22d4		       06		      .byte.b	6
      0  22d5					      dw	CO
      1  22d5		       a4 22		      .word.w	CO
      0  22d7					      IJMP	STMT	; Process the next statement
      0  22d7					      db	29
      1  22d7		       1d		      .byte.b	29
      0  22d8					      dw	STMT
      1  22d8		       ac 22		      .word.w	STMT
    155  22da							;S1Dec:
    156  22da							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    157  22da				   ekDec
      0  22da					      TSTV	ERRVEC2	; Must be followed by a variable
      0  22da					      db	33
      1  22da		       21		      .byte.b	33
      0  22db					      db	(ERRVEC2-*)-1
      1  22db		       e6		      .byte.b	(ERRVEC2-*)-1
      0  22dc					      TSTB	eDoDec,oBang	; Allow to inc or dec other tasks variables
      0  22dc					      db	101
      1  22dc		       65		      .byte.b	101
      0  22dd					      db	(eDoDec-*)-1
      1  22dd		       04		      .byte.b	(eDoDec-*)-1
      0  22de					      db	oBang
      1  22de		       e8		      .byte.b	oBang
      0  22df					      IND		; we just got a pid
      0  22df					      db	20
      1  22df		       14		      .byte.b	20
      0  22e0					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  22e0					      db	93
      1  22e0		       5d		      .byte.b	93
      0  22e1					      db	(ERRVEC2-*)-1
      1  22e1		       e0		      .byte.b	(ERRVEC2-*)-1
    162  22e2				   eDoDec
      0  22e2					      DECVAR		; Decrement the actual variable
      0  22e2					      db	99
      1  22e2		       63		      .byte.b	99
      0  22e3					      DONE		; Test if end of line or : statement
      0  22e3					      db	1
      1  22e3		       01		      .byte.b	1
      0  22e4					      NXT	CO	; If at end of program then got the console
      0  22e4					      db	6
      1  22e4		       06		      .byte.b	6
      0  22e5					      dw	CO
      1  22e5		       a4 22		      .word.w	CO
      0  22e7					      IJMP	STMT	; Process the next statement of command line
      0  22e7					      db	29
      1  22e7		       1d		      .byte.b	29
      0  22e8					      dw	STMT
      1  22e8		       ac 22		      .word.w	STMT
    167  22ea							;=============================================================================================================================
    168  22ea							; iret or ireturn, Return from interupt process
    169  22ea							;
    170  22ea							;S1Iret:
    171  22ea							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    172  22ea							;S1Sa:
    173  22ea				   ekIreturn
      0  22ea					      DONE		; Must be only thing on the line
      0  22ea					      db	1
      1  22ea		       01		      .byte.b	1
      0  22eb					      IRET		; RESTORE LINE NUMBER OF CALL
      0  22eb					      db	58
      1  22eb		       3a		      .byte.b	58
      0  22ec					      IJMP	STMT
      0  22ec					      db	29
      1  22ec		       1d		      .byte.b	29
      0  22ed					      dw	STMT
      1  22ed		       ac 22		      .word.w	STMT
    177  22ef							;==============================================================================================================================
    178  22ef							;Process if statement, if true then process all statements until end of line reached
    179  22ef							;S1S1:
    180  22ef							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    181  22ef				   ekIf
      0  22ef					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  22ef					      db	28
      1  22ef		       1c		      .byte.b	28
      0  22f0					      dw	EXPR
      1  22f0		       7a 24		      .word.w	EXPR
      0  22f2					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  22f2					      db	101
      1  22f2		       65		      .byte.b	101
      0  22f3					      db	(S1W-*)-1
      1  22f3		       01		      .byte.b	(S1W-*)-1
      0  22f4					      db	kThen
      1  22f4		       06		      .byte.b	kThen
    184  22f5				   ekThen
    185  22f5				   S1W
      0  22f5					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  22f5					      db	54
      1  22f5		       36		      .byte.b	54
      0  22f6					      IJMP	STMT
      0  22f6					      db	29
      1  22f6		       1d		      .byte.b	29
      0  22f7					      dw	STMT
      1  22f7		       ac 22		      .word.w	STMT
    188  22f9							;===============================================================================================================================
    189  22f9							; Test for GOTO
    190  22f9							;S1Z:
    191  22f9							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    192  22f9							;
    193  22f9				   ekGoto
      0  22f9					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  22f9					      db	106
      1  22f9		       6a		      .byte.b	106
      0  22fa					      db	(ekGotoCompiled-*)-1
      1  22fa		       0e		      .byte.b	(ekGotoCompiled-*)-1
    195  22fb							; Else we have the address ad just goto that address
      0  22fb					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  22fb					      db	101
      1  22fb		       65		      .byte.b	101
      0  22fc					      db	(ekGotoLine-*)-1
      1  22fc		       05		      .byte.b	(ekGotoLine-*)-1
      0  22fd					      db	oPeriod
      1  22fd		       e9		      .byte.b	oPeriod
      0  22fe					      REPEATLINE		; Repeat the same line again
      0  22fe					      db	105
      1  22fe		       69		      .byte.b	105
      0  22ff					      IJMP	STMT	; Go do the statement
      0  22ff					      db	29
      1  22ff		       1d		      .byte.b	29
      0  2300					      dw	STMT
      1  2300		       ac 22		      .word.w	STMT
    199  2302
    200  2302				   ekGotoLine
      0  2302					      CALL	EXPR	; GET LABEL
      0  2302					      db	28
      1  2302		       1c		      .byte.b	28
      0  2303					      dw	EXPR
      1  2303		       7a 24		      .word.w	EXPR
      0  2305					      lit	0	; Place indicator for line num on stack
      0  2305					      db	27
      1  2305		       1b		      .byte.b	27
      0  2306					      dw	0
      1  2306		       00 00		      .word.w	0
      0  2308					      FASTXFER
      0  2308					      db	107
      1  2308		       6b		      .byte.b	107
    204  2309				   ekGotoCompiled
      0  2309					      lit	1	; tell it that mempointer on the stack
      0  2309					      db	27
      1  2309		       1b		      .byte.b	27
      0  230a					      dw	1
      1  230a		       01 00		      .word.w	1
      0  230c					      FASTXFER		; put top of stack into curptr
      0  230c					      db	107
      1  230c		       6b		      .byte.b	107
    207  230d
    208  230d							;===============================================================================================================================
    209  230d							; Process gosub / function
    210  230d							;
    211  230d							;S2:
    212  230d							;	  TSTB	     S2b,kGosub 		    ; ERROR IF NO MATCH
    213  230d				   ekGosub
      0  230d					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  230d					      db	28
      1  230d		       1c		      .byte.b	28
      0  230e					      dw	GOSUBSTATEMENT
      1  230e		       f8 25		      .word.w	GOSUBSTATEMENT
      0  2310					      DONE		; ERROR IF CR NOT NEXT
      0  2310					      db	1
      1  2310		       01		      .byte.b	1
      0  2311					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  2311					      db	8
      1  2311		       08		      .byte.b	8
      0  2312					      db	GOSUB_RTN
      1  2312		       01		      .byte.b	GOSUB_RTN
      0  2313					      FASTXFER		; AND JUMP to sub rtn
      0  2313					      db	107
      1  2313		       6b		      .byte.b	107
    218  2314							;
    219  2314							; End of gosub processing
    220  2314							;===============================================================================================================================
    221  2314							; Return from a gosub
    222  2314							;S2b:
    223  2314							;	  TSTB	    S2a,kReturn 		   ; Speed up pocessing but more memory
    224  2314				   ekReturn
      0  2314					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  2314					      db	101
      1  2314		       65		      .byte.b	101
      0  2315					      db	(S2NoReturnValue-*)-1
      1  2315		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  2316					      db	oLeftBracket
      1  2316		       e0		      .byte.b	oLeftBracket
      0  2317					      CALL	EXPR
      0  2317					      db	28
      1  2317		       1c		      .byte.b	28
      0  2318					      dw	EXPR
      1  2318		       7a 24		      .word.w	EXPR
      0  231a					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  231a					      db	101
      1  231a		       65		      .byte.b	101
      0  231b					      db	(ERRVEC2-*)-1
      1  231b		       a6		      .byte.b	(ERRVEC2-*)-1
      0  231c					      db	oRightBracket
      1  231c		       e1		      .byte.b	oRightBracket
      0  231d					      DONE
      0  231d					      db	1
      1  231d		       01		      .byte.b	1
      0  231e					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  231e					      db	9
      1  231e		       09		      .byte.b	9
      0  231f					      db	(S2RetFunc-*)-1
      1  231f		       11		      .byte.b	(S2RetFunc-*)-1
      0  2320					      db	1
      1  2320		       01		      .byte.b	1
      0  2321					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  2321					      db	6
      1  2321		       06		      .byte.b	6
      0  2322					      dw	CO
      1  2322		       a4 22		      .word.w	CO
      0  2324					      IJMP	STMT	; Process the new statement
      0  2324					      db	29
      1  2324		       1d		      .byte.b	29
      0  2325					      dw	STMT
      1  2325		       ac 22		      .word.w	STMT
    232  2327
    233  2327				   S2NoReturnValue
      0  2327					      DONE
      0  2327					      db	1
      1  2327		       01		      .byte.b	1
      0  2328					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  2328					      db	9
      1  2328		       09		      .byte.b	9
      0  2329					      db	(S2RetFunc-*)-1
      1  2329		       07		      .byte.b	(S2RetFunc-*)-1
      0  232a					      db	0
      1  232a		       00		      .byte.b	0
      0  232b					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  232b					      db	6
      1  232b		       06		      .byte.b	6
      0  232c					      dw	CO
      1  232c		       a4 22		      .word.w	CO
      0  232e					      IJMP	STMT	; Process the new statement
      0  232e					      db	29
      1  232e		       1d		      .byte.b	29
      0  232f					      dw	STMT
      1  232f		       ac 22		      .word.w	STMT
    238  2331
    239  2331				   S2RetFunc
      0  2331					      IJMP	GOFNRet	; Back into the Function
      0  2331					      db	29
      1  2331		       1d		      .byte.b	29
      0  2332					      dw	GOFNRet
      1  2332		       b8 25		      .word.w	GOFNRet
    241  2334							;
    242  2334							; End of return from gosub
    243  2334							;==================================================================================================================================
    244  2334							; Process REM statement
    245  2334							;
    246  2334							;S2a:
    247  2334							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    248  2334				   ekRem
      0  2334					      NXT	CO	; The rest of the line is ignored
      0  2334					      db	6
      1  2334		       06		      .byte.b	6
      0  2335					      dw	CO
      1  2335		       a4 22		      .word.w	CO
      0  2337					      IJMP	STMT	; Process the next statement
      0  2337					      db	29
      1  2337		       1d		      .byte.b	29
      0  2338					      dw	STMT
      1  2338		       ac 22		      .word.w	STMT
    251  233a							;==================================================================================================================================
    252  233a							; Print statement
    253  233a							;
    254  233a							;S3:
    255  233a							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    256  233a				   ekPrint
      0  233a					      STARTIO		; Lock task until io completes
      0  233a					      db	70
      1  233a		       46		      .byte.b	70
    258  233b				   S4
      0  233b					      TSTDONE	S4a	; Test if we just want crlf printed
      0  233b					      db	50
      1  233b		       32		      .byte.b	50
      0  233c					      db	(S4a-*)-1
      1  233c		       03		      .byte.b	(S4a-*)-1
      0  233d					      IJMP	S6
      0  233d					      db	29
      1  233d		       1d		      .byte.b	29
      0  233e					      dw	S6
      1  233e		       55 23		      .word.w	S6
    261  2340
    262  2340				   S4a
      0  2340					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  2340					      db	101
      1  2340		       65		      .byte.b	101
      0  2341					      db	(S7-*)-1
      1  2341		       1f		      .byte.b	(S7-*)-1
      0  2342					      db	tString
      1  2342		       a0		      .byte.b	tString
      0  2343					      PRS		; PRINT STRING
      0  2343					      db	2
      1  2343		       02		      .byte.b	2
    265  2344				   S5
      0  2344					      TSTB	S6A,oComma	; IS THERE MORE?
      0  2344					      db	101
      1  2344		       65		      .byte.b	101
      0  2345					      db	(S6A-*)-1
      1  2345		       07		      .byte.b	(S6A-*)-1
      0  2346					      db	oComma
      1  2346		       e2		      .byte.b	oComma
      0  2347					      SPC		; SPACE TO NEXT ZONE
      0  2347					      db	4
      1  2347		       04		      .byte.b	4
      0  2348					      TSTDONE	S4	; Not end of line jump back
      0  2348					      db	50
      1  2348		       32		      .byte.b	50
      0  2349					      db	(S4-*)-1
      1  2349		       f1		      .byte.b	(S4-*)-1
      0  234a					      IJMP	S6Z	; YES JUMP BACK
      0  234a					      db	29
      1  234a		       1d		      .byte.b	29
      0  234b					      dw	S6Z
      1  234b		       57 23		      .word.w	S6Z
    270  234d
    271  234d							;
    272  234d							; If a semicolon, don't do anything.
    273  234d							;
    274  234d				   S6A
      0  234d					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  234d					      db	101
      1  234d		       65		      .byte.b	101
      0  234e					      db	(S6-*)-1
      1  234e		       06		      .byte.b	(S6-*)-1
      0  234f					      db	oSemiColon
      1  234f		       e3		      .byte.b	oSemiColon
      0  2350					      TSTDONE	S4	; Jump Back if not end of line
      0  2350					      db	50
      1  2350		       32		      .byte.b	50
      0  2351					      db	(S4-*)-1
      1  2351		       e9		      .byte.b	(S4-*)-1
      0  2352					      IJMP	S6Z
      0  2352					      db	29
      1  2352		       1d		      .byte.b	29
      0  2353					      dw	S6Z
      1  2353		       57 23		      .word.w	S6Z
    278  2355
    279  2355				   S6
    280  2355
      0  2355					      DONE		; ERROR IF CR NOT NEXT
      0  2355					      db	1
      1  2355		       01		      .byte.b	1
      0  2356					      NLINE
      0  2356					      db	5
      1  2356		       05		      .byte.b	5
    283  2357				   S6Z
      0  2357					      ENDIO		; release task io completed
      0  2357					      db	71
      1  2357		       47		      .byte.b	71
      0  2358					      NXT	CO	; exit here if , or ; at end of print
      0  2358					      db	6
      1  2358		       06		      .byte.b	6
      0  2359					      dw	CO
      1  2359		       a4 22		      .word.w	CO
      0  235b					      IJMP	STMT
      0  235b					      db	29
      1  235b		       1d		      .byte.b	29
      0  235c					      dw	STMT
      1  235c		       ac 22		      .word.w	STMT
    287  235e							;
    288  235e							; A jump for code too far away for relative branch
    289  235e							;
    290  235e				   ERRVEC
      0  235e					      IJMP	UNKNOWN
      0  235e					      db	29
      1  235e		       1d		      .byte.b	29
      0  235f					      dw	UNKNOWN
      1  235f		       76 24		      .word.w	UNKNOWN
    292  2361							;
    293  2361							; Get here if there is an expression to print
    294  2361				   S7
      0  2361					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  2361					      db	101
      1  2361		       65		      .byte.b	101
      0  2362					      db	(S7AUnsigned-*)-1
      1  2362		       08		      .byte.b	(S7AUnsigned-*)-1
      0  2363					      db	oDollar
      1  2363		       e7		      .byte.b	oDollar
      0  2364					      CALL	EXPR
      0  2364					      db	28
      1  2364		       1c		      .byte.b	28
      0  2365					      dw	EXPR
      1  2365		       7a 24		      .word.w	EXPR
      0  2367					      HEXPRT
      0  2367					      db	67
      1  2367		       43		      .byte.b	67
      0  2368					      IJMP	S5
      0  2368					      db	29
      1  2368		       1d		      .byte.b	29
      0  2369					      dw	S5
      1  2369		       44 23		      .word.w	S5
    299  236b
    300  236b				   S7AUnsigned
    301  236b
      0  236b					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  236b					      db	101
      1  236b		       65		      .byte.b	101
      0  236c					      db	(S7A-*)-1
      1  236c		       0a		      .byte.b	(S7A-*)-1
      0  236d					      db	oPercent
      1  236d		       ed		      .byte.b	oPercent
      0  236e					      CALL	EXPR
      0  236e					      db	28
      1  236e		       1c		      .byte.b	28
      0  236f					      dw	EXPR
      1  236f		       7a 24		      .word.w	EXPR
      0  2371					      SETR2	1
      0  2371					      db	94
      1  2371		       5e		      .byte.b	94
      0  2372					      db	1
      1  2372		       01		      .byte.b	1
      0  2373					      PRN
      0  2373					      db	3
      1  2373		       03		      .byte.b	3
      0  2374					      IJMP	S5
      0  2374					      db	29
      1  2374		       1d		      .byte.b	29
      0  2375					      dw	S5
      1  2375		       44 23		      .word.w	S5
    307  2377
    308  2377				   S7A
    309  2377
      0  2377					      CALL	EXPR
      0  2377					      db	28
      1  2377		       1c		      .byte.b	28
      0  2378					      dw	EXPR
      1  2378		       7a 24		      .word.w	EXPR
      0  237a					      TSTB	S7B,oDollar	; Print the value as a single character
      0  237a					      db	101
      1  237a		       65		      .byte.b	101
      0  237b					      db	(S7B-*)-1
      1  237b		       05		      .byte.b	(S7B-*)-1
      0  237c					      db	oDollar
      1  237c		       e7		      .byte.b	oDollar
      0  237d					      PUTCHAR
      0  237d					      db	52
      1  237d		       34		      .byte.b	52
      0  237e					      IJMP	S5
      0  237e					      db	29
      1  237e		       1d		      .byte.b	29
      0  237f					      dw	S5
      1  237f		       44 23		      .word.w	S5
    314  2381
    315  2381				   S7B
      0  2381					      SETR2	0	; Print the value as a signed number
      0  2381					      db	94
      1  2381		       5e		      .byte.b	94
      0  2382					      db	0
      1  2382		       00		      .byte.b	0
      0  2383					      PRN		; PRINT IT
      0  2383					      db	3
      1  2383		       03		      .byte.b	3
      0  2384					      IJMP	S5	; IS THERE MORE?
      0  2384					      db	29
      1  2384		       1d		      .byte.b	29
      0  2385					      dw	S5
      1  2385		       44 23		      .word.w	S5
    319  2387							;
    320  2387							;===========================================================
    321  2387							; PROCESS ALL THE TASK STATEMENTS
    322  2387							;
    323  2387							;S8:
    324  2387							;	  TSTB	      S8G,kTaske		 ; End Task
    325  2387				   ekTaske
      0  2387					      TSTB	S8NoParm,oLeftBracket
      0  2387					      db	101
      1  2387		       65		      .byte.b	101
      0  2388					      db	(S8NoParm-*)-1
      1  2388		       0c		      .byte.b	(S8NoParm-*)-1
      0  2389					      db	oLeftBracket
      1  2389		       e0		      .byte.b	oLeftBracket
      0  238a					      CALL	EXPR
      0  238a					      db	28
      1  238a		       1c		      .byte.b	28
      0  238b					      dw	EXPR
      1  238b		       7a 24		      .word.w	EXPR
      0  238d					      TSTB	UNKNOWNLnk,oRightBracket
      0  238d					      db	101
      1  238d		       65		      .byte.b	101
      0  238e					      db	(UNKNOWNLnk-*)-1
      1  238e		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  238f					      db	oRightBracket
      1  238f		       e1		      .byte.b	oRightBracket
      0  2390					      ETASK
      0  2390					      db	62
      1  2390		       3e		      .byte.b	62
      0  2391					      DONE
      0  2391					      db	1
      1  2391		       01		      .byte.b	1
      0  2392					      IJMP	STMT
      0  2392					      db	29
      1  2392		       1d		      .byte.b	29
      0  2393					      dw	STMT
      1  2393		       ac 22		      .word.w	STMT
    332  2395				   S8NoParm
      0  2395					      LIT	0
      0  2395					      db	27
      1  2395		       1b		      .byte.b	27
      0  2396					      dw	0
      1  2396		       00 00		      .word.w	0
      0  2398					      ETASK
      0  2398					      db	62
      1  2398		       3e		      .byte.b	62
      0  2399					      DONE		; Must be last thing on a line
      0  2399					      db	1
      1  2399		       01		      .byte.b	1
      0  239a					      IJMP	STMT
      0  239a					      db	29
      1  239a		       1d		      .byte.b	29
      0  239b					      dw	STMT
      1  239b		       ac 22		      .word.w	STMT
    337  239d							;
    338  239d							;===========================================================
    339  239d							; The task gives up the rest of the cycles
    340  239d							;S8G:
    341  239d							;	  TSTB	      S8a,kTaskn	 ;Next task
    342  239d				   ekTaskn
      0  239d					      NTASK
      0  239d					      db	63
      1  239d		       3f		      .byte.b	63
      0  239e					      NXT	CO	;Next statement to execute
      0  239e					      db	6
      1  239e		       06		      .byte.b	6
      0  239f					      dw	CO
      1  239f		       a4 22		      .word.w	CO
      0  23a1					      IJMP	STMT
      0  23a1					      db	29
      1  23a1		       1d		      .byte.b	29
      0  23a2					      dw	STMT
      1  23a2		       ac 22		      .word.w	STMT
    346  23a4							;
    347  23a4							;===========================================================
    348  23a4							; Waits for a task or list of tasks to complete
    349  23a4							;S8a:
    350  23a4							;	 TSTB	     S8a1,kTaskw		;Wait for tasks
    351  23a4				   ekTaskw
      0  23a4					      TSTB	UNKNOWNLnk,oLeftBracket
      0  23a4					      db	101
      1  23a4		       65		      .byte.b	101
      0  23a5					      db	(UNKNOWNLnk-*)-1
      1  23a5		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  23a6					      db	oLeftBracket
      1  23a6		       e0		      .byte.b	oLeftBracket
    353  23a7				   S8TSK
      0  23a7					      Call	EXPR	;Gets the PID of task to wait for
      0  23a7					      db	28
      1  23a7		       1c		      .byte.b	28
      0  23a8					      dw	EXPR
      1  23a8		       7a 24		      .word.w	EXPR
    355  23aa				   S8LOOP
      0  23aa					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  23aa					      db	76
      1  23aa		       4c		      .byte.b	76
      0  23ab					      db	(S8LOOP-*)-1
      1  23ab		       fe		      .byte.b	(S8LOOP-*)-1
      0  23ac					      TSTB	S8aa,oComma	;Checks for more tasks
      0  23ac					      db	101
      1  23ac		       65		      .byte.b	101
      0  23ad					      db	(S8aa-*)-1
      1  23ad		       04		      .byte.b	(S8aa-*)-1
      0  23ae					      db	oComma
      1  23ae		       e2		      .byte.b	oComma
      0  23af					      IJMP	S8TSK	;Go for the next task number
      0  23af					      db	29
      1  23af		       1d		      .byte.b	29
      0  23b0					      dw	S8TSK
      1  23b0		       a7 23		      .word.w	S8TSK
    359  23b2				   S8aa
      0  23b2					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  23b2					      db	101
      1  23b2		       65		      .byte.b	101
      0  23b3					      db	(UNKNOWNLnk-*)-1
      1  23b3		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  23b4					      db	oRightBracket
      1  23b4		       e1		      .byte.b	oRightBracket
      0  23b5					      DONE
      0  23b5					      db	1
      1  23b5		       01		      .byte.b	1
      0  23b6					      NXT	CO
      0  23b6					      db	6
      1  23b6		       06		      .byte.b	6
      0  23b7					      dw	CO
      1  23b7		       a4 22		      .word.w	CO
      0  23b9					      IJMP	STMT	;Next Statement
      0  23b9					      db	29
      1  23b9		       1d		      .byte.b	29
      0  23ba					      dw	STMT
      1  23ba		       ac 22		      .word.w	STMT
    364  23bc
    365  23bc
    366  23bc
    367  23bc				   UNKNOWNLnk
      0  23bc					      iJMP	UNKNOWN
      0  23bc					      db	29
      1  23bc		       1d		      .byte.b	29
      0  23bd					      dw	UNKNOWN
      1  23bd		       76 24		      .word.w	UNKNOWN
    369  23bf
    370  23bf							;
    371  23bf							;===========================================================
    372  23bf							; Update a memory location with a value
    373  23bf							;  Use @[offset] to write a word value to memory
    374  23bf							;
    375  23bf							;S8a1:
    376  23bf							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    377  23bf				   ekPoke
      0  23bf					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  23bf					      db	101
      1  23bf		       65		      .byte.b	101
      0  23c0					      db	(UNKNOWNV-*)-1
      1  23c0		       50		      .byte.b	(UNKNOWNV-*)-1
      0  23c1					      db	oLeftBracket
      1  23c1		       e0		      .byte.b	oLeftBracket
      0  23c2					      CALL	EXPR	; Get address to write to
      0  23c2					      db	28
      1  23c2		       1c		      .byte.b	28
      0  23c3					      dw	EXPR
      1  23c3		       7a 24		      .word.w	EXPR
      0  23c5					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  23c5					      db	101
      1  23c5		       65		      .byte.b	101
      0  23c6					      db	(UNKNOWNV-*)-1
      1  23c6		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  23c7					      db	oComma
      1  23c7		       e2		      .byte.b	oComma
      0  23c8					      CALL	EXPR	; Get the value to poke
      0  23c8					      db	28
      1  23c8		       1c		      .byte.b	28
      0  23c9					      dw	EXPR
      1  23c9		       7a 24		      .word.w	EXPR
      0  23cb					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  23cb					      db	101
      1  23cb		       65		      .byte.b	101
      0  23cc					      db	(UNKNOWNV-*)-1
      1  23cc		       44		      .byte.b	(UNKNOWNV-*)-1
      0  23cd					      db	oRightBracket
      1  23cd		       e1		      .byte.b	oRightBracket
      0  23ce					      POKEMEM
      0  23ce					      db	47
      1  23ce		       2f		      .byte.b	47
      0  23cf					      DONE
      0  23cf					      db	1
      1  23cf		       01		      .byte.b	1
      0  23d0					      NXT	CO	;AND SEQUENCE TO NEXT
      0  23d0					      db	6
      1  23d0		       06		      .byte.b	6
      0  23d1					      dw	CO
      1  23d1		       a4 22		      .word.w	CO
      0  23d3					      IJMP	STMT
      0  23d3					      db	29
      1  23d3		       1d		      .byte.b	29
      0  23d4					      dw	STMT
      1  23d4		       ac 22		      .word.w	STMT
    387  23d6							;================================================================
    388  23d6							; Write a single byte to the output device
    389  23d6							;
    390  23d6							;S8b:
    391  23d6							;	  TSTB	      S8c,kPutch       ;Put a char to the terminal
    392  23d6				   ekPutch
      0  23d6					      CALL	EXPR
      0  23d6					      db	28
      1  23d6		       1c		      .byte.b	28
      0  23d7					      dw	EXPR
      1  23d7		       7a 24		      .word.w	EXPR
      0  23d9					      PUTCHAR
      0  23d9					      db	52
      1  23d9		       34		      .byte.b	52
      0  23da					      DONE
      0  23da					      db	1
      1  23da		       01		      .byte.b	1
      0  23db					      NXT	CO	;AND SEQUENCE TO NEXT
      0  23db					      db	6
      1  23db		       06		      .byte.b	6
      0  23dc					      dw	CO
      1  23dc		       a4 22		      .word.w	CO
      0  23de					      IJMP	STMT
      0  23de					      db	29
      1  23de		       1d		      .byte.b	29
      0  23df					      dw	STMT
      1  23df		       ac 22		      .word.w	STMT
    398  23e1							;================================================================
    399  23e1							; Clear the screen lines
    400  23e1							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    401  23e1							;
    402  23e1							;S8c
    403  23e1							;	  TSTB	      S9,kCls	       ;Clear the screen
    404  23e1				   ekCls
      0  23e1					      CLEARSCREEN
      0  23e1					      db	46
      1  23e1		       2e		      .byte.b	46
      0  23e2					      NXT	CO	;AND SEQUENCE TO NEXT
      0  23e2					      db	6
      1  23e2		       06		      .byte.b	6
      0  23e3					      dw	CO
      1  23e3		       a4 22		      .word.w	CO
      0  23e5					      IJMP	STMT
      0  23e5					      db	29
      1  23e5		       1d		      .byte.b	29
      0  23e6					      dw	STMT
      1  23e6		       ac 22		      .word.w	STMT
    408  23e8							;==================================================================
    409  23e8							; Get input from the terminal
    410  23e8							;   Reads from the currently active input device
    411  23e8							;
    412  23e8							;S9:
    413  23e8							;	  TSTB	     S13,kInput 	      ;INPUT STATEMENT
    414  23e8				   ekInput
    415  23e8				   S10
      0  23e8					      TSTB	S10A,tString	;If there is a string print the prompt
      0  23e8					      db	101
      1  23e8		       65		      .byte.b	101
      0  23e9					      db	(S10A-*)-1
      1  23e9		       05		      .byte.b	(S10A-*)-1
      0  23ea					      db	tString
      1  23ea		       a0		      .byte.b	tString
      0  23eb					      PRS
      0  23eb					      db	2
      1  23eb		       02		      .byte.b	2
      0  23ec					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  23ec					      db	101
      1  23ec		       65		      .byte.b	101
      0  23ed					      db	(S10Z-*)-1
      1  23ed		       18		      .byte.b	(S10Z-*)-1
      0  23ee					      db	oSemiColon
      1  23ee		       e3		      .byte.b	oSemiColon
    419  23ef				   S10A
      0  23ef					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  23ef					      db	33
      1  23ef		       21		      .byte.b	33
      0  23f0					      db	(UNKNOWN-*)-1
      1  23f0		       85		      .byte.b	(UNKNOWN-*)-1
      0  23f1					      TSTB	S10ACONT,oBang	; Print from another task
      0  23f1					      db	101
      1  23f1		       65		      .byte.b	101
      0  23f2					      db	(S10ACONT-*)-1
      1  23f2		       04		      .byte.b	(S10ACONT-*)-1
      0  23f3					      db	oBang
      1  23f3		       e8		      .byte.b	oBang
      0  23f4					      IND
      0  23f4					      db	20
      1  23f4		       14		      .byte.b	20
      0  23f5					      TSTVT	UNKNOWN
      0  23f5					      db	93
      1  23f5		       5d		      .byte.b	93
      0  23f6					      db	(UNKNOWN-*)-1
      1  23f6		       7f		      .byte.b	(UNKNOWN-*)-1
    424  23f7
    425  23f7				   S10ACONT
      0  23f7					      TSTB	S10A1,oDollar
      0  23f7					      db	101
      1  23f7		       65		      .byte.b	101
      0  23f8					      db	(S10A1-*)-1
      1  23f8		       05		      .byte.b	(S10A1-*)-1
      0  23f9					      db	oDollar
      1  23f9		       e7		      .byte.b	oDollar
      0  23fa					      INSTR		;Move character From tty to AESTK
      0  23fa					      db	59
      1  23fa		       3b		      .byte.b	59
      0  23fb					      IJMP	S10A2
      0  23fb					      db	29
      1  23fb		       1d		      .byte.b	29
      0  23fc					      dw	S10A2
      1  23fc		       ff 23		      .word.w	S10A2
    429  23fe				   S10A1
      0  23fe					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  23fe					      db	11
      1  23fe		       0b		      .byte.b	11
    431  23ff				   S10A2
      0  23ff					      STORE		;STORE IT
      0  23ff					      db	19
      1  23ff		       13		      .byte.b	19
      0  2400					      TSTB	S11,oComma	;IS THERE MORE?
      0  2400					      db	101
      1  2400		       65		      .byte.b	101
      0  2401					      db	(S11-*)-1
      1  2401		       07		      .byte.b	(S11-*)-1
      0  2402					      db	oComma
      1  2402		       e2		      .byte.b	oComma
      0  2403					      IJMP	S10	;YES
      0  2403					      db	29
      1  2403		       1d		      .byte.b	29
      0  2404					      dw	S10
      1  2404		       e8 23		      .word.w	S10
    435  2406				   S10Z
      0  2406					      iJMP	UNKNOWN
      0  2406					      db	29
      1  2406		       1d		      .byte.b	29
      0  2407					      dw	UNKNOWN
      1  2407		       76 24		      .word.w	UNKNOWN
    437  2409				   S11
      0  2409					      DONE		;MUST BE CR
      0  2409					      db	1
      1  2409		       01		      .byte.b	1
      0  240a					      NXT	CO	;SEQUENCE TO NEXT
      0  240a					      db	6
      1  240a		       06		      .byte.b	6
      0  240b					      dw	CO
      1  240b		       a4 22		      .word.w	CO
      0  240d					      IJMP	STMT
      0  240d					      db	29
      1  240d		       1d		      .byte.b	29
      0  240e					      dw	STMT
      1  240e		       ac 22		      .word.w	STMT
    441  2410							;=====================================================================
    442  2410							; End of program, return to command line process
    443  2410							; Main Task may also use taske or return to stopped
    444  2410							;
    445  2410							;S13:
    446  2410							;	  TSTB	      S14,kEnd
    447  2410				   ekEnd
      0  2410					      FIN
      0  2410					      db	12
      1  2410		       0c		      .byte.b	12
    449  2411
    450  2411				   UNKNOWNV
      0  2411					      IJMP	UNKNOWN
      0  2411					      db	29
      1  2411		       1d		      .byte.b	29
      0  2412					      dw	UNKNOWN
      1  2412		       76 24		      .word.w	UNKNOWN
    452  2414							;====================================================================
    453  2414							; IRQ <IRQ-HANDLER-Line expression>
    454  2414							;   Specify a line number subroutine to call when an interupt is processed
    455  2414							;   These subroutines must use iret to return.
    456  2414							;
    457  2414							;S14:
    458  2414							;	  TSTB	      S14Z,kIrq      ;Check if we are setting IRQ HANDLER
    459  2414				   ekIrq
      0  2414					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2414					      db	28
      1  2414		       1c		      .byte.b	28
      0  2415					      dw	EXPR
      1  2415		       7a 24		      .word.w	EXPR
      0  2417					      DONE		;must be CR
      0  2417					      db	1
      1  2417		       01		      .byte.b	1
      0  2418					      SETIRQ		;Set the line number now
      0  2418					      db	56
      1  2418		       38		      .byte.b	56
      0  2419					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  2419					      db	6
      1  2419		       06		      .byte.b	6
      0  241a					      dw	CO
      1  241a		       a4 22		      .word.w	CO
      0  241c					      IJMP	STMT
      0  241c					      db	29
      1  241c		       1d		      .byte.b	29
      0  241d					      dw	STMT
      1  241d		       ac 22		      .word.w	STMT
    465  241f
    466  241f							;=========================================================================
    467  241f							; KILL PID-expression	 kill a running task
    468  241f							;  ignored of task has already stopped
    469  241f							;
    470  241f							;S14Z:
    471  241f							;	  TSTB	     S14S1,kKill     ; Kill A running Task
    472  241f				   ekKill
      0  241f					      CALL	EXPR
      0  241f					      db	28
      1  241f		       1c		      .byte.b	28
      0  2420					      dw	EXPR
      1  2420		       7a 24		      .word.w	EXPR
      0  2422					      DONE
      0  2422					      db	1
      1  2422		       01		      .byte.b	1
      0  2423					      TASKKILL
      0  2423					      db	65
      1  2423		       41		      .byte.b	65
      0  2424					      NXT	CO
      0  2424					      db	6
      1  2424		       06		      .byte.b	6
      0  2425					      dw	CO
      1  2425		       a4 22		      .word.w	CO
      0  2427					      IJMP	STMT
      0  2427					      db	29
      1  2427		       1d		      .byte.b	29
      0  2428					      dw	STMT
      1  2428		       ac 22		      .word.w	STMT
    478  242a
    479  242a							;============================================================================
    480  242a							; List all program lines
    481  242a							;
    482  242a							;S14S1:
    483  242a							;	  TSTB	      S15,kList      ;LIST COMMAND
    484  242a				   ekList
      0  242a					      DONE
      0  242a					      db	1
      1  242a		       01		      .byte.b	1
      0  242b					      LST
      0  242b					      db	21
      1  242b		       15		      .byte.b	21
      0  242c					      IJMP	CO
      0  242c					      db	29
      1  242c		       1d		      .byte.b	29
      0  242d					      dw	CO
      1  242d		       a4 22		      .word.w	CO
    488  242f							;=======================================================================
    489  242f							;RUN begin to executed the program in memory
    490  242f							;
    491  242f							;S15:
    492  242f							;	  TSTB	      S16,kRun	     ;RUN COMMAND
    493  242f				   ekRun
      0  242f					      DONE
      0  242f					      db	1
      1  242f		       01		      .byte.b	1
      0  2430					      VINIT		;clear variables compile the line numbers
      0  2430					      db	30
      1  2430		       1e		      .byte.b	30
      0  2431					      LIT	1	;GOTO line 1
      0  2431					      db	27
      1  2431		       1b		      .byte.b	27
      0  2432					      dw	1
      1  2432		       01 00		      .word.w	1
      0  2434					      XFER		;Bob's addition
      0  2434					      db	7
      1  2434		       07		      .byte.b	7
    498  2435							; EXIT
      0  2435					      IJMP	STMT	;and run!
      0  2435					      db	29
      1  2435		       1d		      .byte.b	29
      0  2436					      dw	STMT
      1  2436		       ac 22		      .word.w	STMT
    500  2438							;=========================================================================
    501  2438							;Clear the program memory, delete all proram lines
    502  2438							;
    503  2438							;S16:
    504  2438							;	  TSTB	      S16A,kNew      ;clear program
    505  2438				   ekNew
      0  2438					      DONE
      0  2438					      db	1
      1  2438		       01		      .byte.b	1
      0  2439					      IJMP	START
      0  2439					      db	29
      1  2439		       1d		      .byte.b	29
      0  243a					      dw	START
      1  243a		       9e 22		      .word.w	START
    508  243c
    509  243c							;========================================================================
    510  243c							; Slice(slice legth expression)
    511  243c							;   set the length of time between task switches
    512  243c							;
    513  243c							;S16A:
    514  243c							;	  TSTB	      S16Trace,kSlice
    515  243c				   ekSlice
      0  243c					      CALL	EXPR
      0  243c					      db	28
      1  243c		       1c		      .byte.b	28
      0  243d					      dw	EXPR
      1  243d		       7a 24		      .word.w	EXPR
      0  243f					      SLICE
      0  243f					      db	100
      1  243f		       64		      .byte.b	100
      0  2440					      DONE
      0  2440					      db	1
      1  2440		       01		      .byte.b	1
      0  2441					      NXT	CO
      0  2441					      db	6
      1  2441		       06		      .byte.b	6
      0  2442					      dw	CO
      1  2442		       a4 22		      .word.w	CO
      0  2444					      IJMP	STMT
      0  2444					      db	29
      1  2444		       1d		      .byte.b	29
      0  2445					      dw	STMT
      1  2445		       ac 22		      .word.w	STMT
    521  2447							;==========================================================================
    522  2447							; Turn off and on the thrace functions
    523  2447							; a debug terminal needs to be available
    524  2447							; Trace( Trace flag expression)
    525  2447							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    526  2447							;	for individual lines of basic code. These can be combined
    527  2447							;S16Trace:
    528  2447							;	  TSTB	      S17A,kTrace
    529  2447				   ekTrace
      0  2447					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  2447					      db	101
      1  2447		       65		      .byte.b	101
      0  2448					      db	(UNKNOWN-*)-1
      1  2448		       2d		      .byte.b	(UNKNOWN-*)-1
      0  2449					      db	oLeftBracket
      1  2449		       e0		      .byte.b	oLeftBracket
      0  244a					      CALL	EXPR
      0  244a					      db	28
      1  244a		       1c		      .byte.b	28
      0  244b					      dw	EXPR
      1  244b		       7a 24		      .word.w	EXPR
      0  244d					      TSTB	UNKNOWN,oRightBracket
      0  244d					      db	101
      1  244d		       65		      .byte.b	101
      0  244e					      db	(UNKNOWN-*)-1
      1  244e		       27		      .byte.b	(UNKNOWN-*)-1
      0  244f					      db	oRightBracket
      1  244f		       e1		      .byte.b	oRightBracket
      0  2450					      TRACEPROGRAM
      0  2450					      db	78
      1  2450		       4e		      .byte.b	78
      0  2451					      DONE
      0  2451					      db	1
      1  2451		       01		      .byte.b	1
      0  2452					      NXT	CO
      0  2452					      db	6
      1  2452		       06		      .byte.b	6
      0  2453					      dw	CO
      1  2453		       a4 22		      .word.w	CO
      0  2455					      IJMP	STMT
      0  2455					      db	29
      1  2455		       1d		      .byte.b	29
      0  2456					      dw	STMT
      1  2456		       ac 22		      .word.w	STMT
    537  2458							;=====================================================================
    538  2458							; Exit basic to machine monitor
    539  2458							;
    540  2458							;S17A:
    541  2458							;	  TSTB	      S17B,kExit      ;allow them to exit BASIC
    542  2458				   ekExit
      0  2458					      EXIT
      0  2458					      db	26
      1  2458		       1a		      .byte.b	26
    544  2459
    545  2459							;=======================================================================
    546  2459							; Commands related to saving/restoring programs
    547  2459							; to/from mass storage.
    548  2459							;=======================================================================
    549  2459							; Save a program file
    550  2459							;
    551  2459							;S17B:
    552  2459					      if	(XKIM || CTMON65) && DISK_ACCESS
    553  2459
    554  2459							;	  TSTB	      S17C,kSave
    555  2459				   ekSave
      0  2459					      OPENWRITE
      0  2459					      db	40
      1  2459		       28		      .byte.b	40
      0  245a					      DLIST
      0  245a					      db	43
      1  245a		       2b		      .byte.b	43
      0  245b					      DCLOSE
      0  245b					      db	41
      1  245b		       29		      .byte.b	41
      0  245c					      IJMP	CO
      0  245c					      db	29
      1  245c		       1d		      .byte.b	29
      0  245d					      dw	CO
      1  245d		       a4 22		      .word.w	CO
    560  245f							;=========================================================================
    561  245f							; Load a program file
    562  245f							;
    563  245f							;S17C:
    564  245f							;	  TSTB	      S18,kLoad
    565  245f				   ekLoad
      0  245f					      OPENREAD
      0  245f					      db	39
      1  245f		       27		      .byte.b	39
    567  2460				   S17CLP
      0  2460					      DGETLINE		;get line from file
      0  2460					      db	42
      1  2460		       2a		      .byte.b	42
      0  2461					      TSTL	S17EOL	;no line num means EOL
      0  2461					      db	34
      1  2461		       22		      .byte.b	34
      0  2462					      db	(S17EOL-*)-1
      1  2462		       04		      .byte.b	(S17EOL-*)-1
      0  2463					      INSERT		;put it into the program
      0  2463					      db	24
      1  2463		       18		      .byte.b	24
      0  2464					      IJMP	S17CLP	;keep going
      0  2464					      db	29
      1  2464		       1d		      .byte.b	29
      0  2465					      dw	S17CLP
      1  2465		       60 24		      .word.w	S17CLP
    572  2467				   S17EOL
      0  2467					      DCLOSE		;close disk file
      0  2467					      db	41
      1  2467		       29		      .byte.b	41
      0  2468					      IJMP	CO	;back to start
      0  2468					      db	29
      1  2468		       1d		      .byte.b	29
      0  2469					      dw	CO
      1  2469		       a4 22		      .word.w	CO
    575  246b							;=========================================================================
    576  246b							; Display the directory content
    577  246b							;
    578  246b							;S18:
    579  246b							;	  TSTB	      S19,kDir
    580  246b				   ekDir
      0  246b					      DDIR		;Display the directory content
      0  246b					      db	44
      1  246b		       2c		      .byte.b	44
      0  246c					      IJMP	CO
      0  246c					      db	29
      1  246c		       1d		      .byte.b	29
      0  246d					      dw	CO
      1  246d		       a4 22		      .word.w	CO
    583  246f							;=========================================================================
    584  246f							; Erase a file from disk
    585  246f							;
      0  246f				   S19	      TSTB	UNKNOWN,kErase
      0  246f					      db	101
      1  246f		       65		      .byte.b	101
      0  2470					      db	(UNKNOWN-*)-1
      1  2470		       05		      .byte.b	(UNKNOWN-*)-1
      0  2471					      db	kErase
      1  2471		       1e		      .byte.b	kErase
    587  2472				   ekErase
      0  2472					      RMFILE		;Erase the file from the disk
      0  2472					      db	45
      1  2472		       2d		      .byte.b	45
      0  2473					      IJMP	CO
      0  2473					      db	29
      1  2473		       1d		      .byte.b	29
      0  2474					      dw	CO
      1  2474		       a4 22		      .word.w	CO
    590  2476
    591  2476					      endif
    592  2476
    593  2476							;===========================================================================
    594  2476							; Else, unknown command.
    595  2476							;
    596  2476				   UNKNOWN
      0  2476					      ENDIO
      0  2476					      db	71
      1  2476		       47		      .byte.b	71
    598  2477
    599  2477				   NotKnownStatement
    600  2477
      0  2477					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  2477					      db	13
      1  2477		       0d		      .byte.b	13
      0  2478					      dw	ERR_SYNTAX
      1  2478		       05 00		      .word.w	ERR_SYNTAX
    602  247a
    603  247a							;=======================================================
    604  247a							; Process Expresions, precidence is represented by the
    605  247a							; various call levels
    606  247a							;
    607  247a				   EXPR
      0  247a					      TSTB	EXPRLOGS,kNot
      0  247a					      db	101
      1  247a		       65		      .byte.b	101
      0  247b					      db	(EXPRLOGS-*)-1
      1  247b		       06		      .byte.b	(EXPRLOGS-*)-1
      0  247c					      db	kNot
      1  247c		       20		      .byte.b	kNot
    609  247d				   ekNot
      0  247d					      Call	EXPR
      0  247d					      db	28
      1  247d		       1c		      .byte.b	28
      0  247e					      dw	EXPR
      1  247e		       7a 24		      .word.w	EXPR
      0  2480					      LOGNOT
      0  2480					      db	72
      1  2480		       48		      .byte.b	72
      0  2481					      RTN
      0  2481					      db	25
      1  2481		       19		      .byte.b	25
    613  2482
    614  2482							;=========================================================
    615  2482							;Look for logical operators
    616  2482				   EXPRLOGS
      0  2482					      Call	EXPRCMP
      0  2482					      db	28
      1  2482		       1c		      .byte.b	28
      0  2483					      dw	EXPRCMP
      1  2483		       99 24		      .word.w	EXPRCMP
      0  2485					      OnGoto	BasicLogical,iLOG3
      0  2485					      db	103
      1  2485		       67		      .byte.b	103
      0  2486					      dw	BasicLogical
      1  2486		       76 22		      .word.w	BasicLogical
      0  2488					      dw	iLOG3
      1  2488		       98 24		      .word.w	iLOG3
    619  248a							;	  TSTB	     iLOG1,kAnd
    620  248a				   ekAnd
      0  248a					      Call	EXPR
      0  248a					      db	28
      1  248a		       1c		      .byte.b	28
      0  248b					      dw	EXPR
      1  248b		       7a 24		      .word.w	EXPR
      0  248d					      LOGAND
      0  248d					      db	74
      1  248d		       4a		      .byte.b	74
      0  248e					      RTN
      0  248e					      db	25
      1  248e		       19		      .byte.b	25
    624  248f							;iLOG1:
    625  248f							;	  TSTB	     iLOG2,kOr
    626  248f				   ekOr
      0  248f					      Call	EXPR
      0  248f					      db	28
      1  248f		       1c		      .byte.b	28
      0  2490					      dw	EXPR
      1  2490		       7a 24		      .word.w	EXPR
      0  2492					      LOGOR
      0  2492					      db	73
      1  2492		       49		      .byte.b	73
      0  2493					      RTN
      0  2493					      db	25
      1  2493		       19		      .byte.b	25
    630  2494							;iLOG2:
    631  2494							;	  TSTB	  iLOG3,kXor
    632  2494				   ekXor
      0  2494					      Call	EXPR
      0  2494					      db	28
      1  2494		       1c		      .byte.b	28
      0  2495					      dw	EXPR
      1  2495		       7a 24		      .word.w	EXPR
      0  2497					      LOGXOR
      0  2497					      db	75
      1  2497		       4b		      .byte.b	75
    635  2498				   iLOG3
      0  2498					      RTN
      0  2498					      db	25
      1  2498		       19		      .byte.b	25
    637  2499							;========================================================================
    638  2499							; Process relational operators
    639  2499							;
    640  2499				   EXPRCMP
      0  2499					      Call	EXPR2	; get the first expression
      0  2499					      db	28
      1  2499		       1c		      .byte.b	28
      0  249a					      dw	EXPR2
      1  249a		       a4 24		      .word.w	EXPR2
      0  249c					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  249c					      db	104
      1  249c		       68		      .byte.b	104
      0  249d					      db	(iRDone-*)-1
      1  249d		       05		      .byte.b	(iRDone-*)-1
    643  249e							;	  TSTB	     iR0,oEqual
    644  249e							;	  LIT	     2		     ;=
    645  249e							;	  IJMP	     iRFound
    646  249e							;iR0:
    647  249e							;	  TSTB	      iR1,oLessEqual
    648  249e							;	  LIT	      3 	      ;<=
    649  249e							;	  IJMP	     iRFound
    650  249e							;iR1:
    651  249e							;	  TSTB	     iR3,oNotEqual
    652  249e							;	  LIT	     5		      ;<>
    653  249e							;	      IJMP	  iRFound
    654  249e							;iR3:
    655  249e							;	  TSTB	     iR4,oLess
    656  249e							;	  LIT	     1		     ;<
    657  249e							;	      IJMP	  iRFound
    658  249e							;iR4:
    659  249e							;	  TST	     iR5,oGreaterEqual
    660  249e							;	  LIT	     6		     ;>=
    661  249e							;	      IJMP	  iRFound
    662  249e							;iR5:
    663  249e							;	  TSTB	     iRDone,oGreater
    664  249e							;	  LIT	     4		     ;>
    665  249e				   iRFound
      0  249e					      Call	EXPR	; get the right side of the expression
      0  249e					      db	28
      1  249e		       1c		      .byte.b	28
      0  249f					      dw	EXPR
      1  249f		       7a 24		      .word.w	EXPR
      0  24a1					      CMPR		; Push the value of the true false onto the stack
      0  24a1					      db	10
      1  24a1		       0a		      .byte.b	10
      0  24a2					      RTN
      0  24a2					      db	25
      1  24a2		       19		      .byte.b	25
    669  24a3
    670  24a3				   iRDone
      0  24a3					      RTN
      0  24a3					      db	25
      1  24a3		       19		      .byte.b	25
    672  24a4
    673  24a4				   EXPR2
      0  24a4					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  24a4					      db	101
      1  24a4		       65		      .byte.b	101
      0  24a5					      db	(E0-*)-1
      1  24a5		       08		      .byte.b	(E0-*)-1
      0  24a6					      db	oMinus
      1  24a6		       eb		      .byte.b	oMinus
      0  24a7					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  24a7					      db	28
      1  24a7		       1c		      .byte.b	28
      0  24a8					      dw	TERM
      1  24a8		       ca 24		      .word.w	TERM
      0  24aa					      NEG		; Make value negated
      0  24aa					      db	16
      1  24aa		       10		      .byte.b	16
      0  24ab					      IJMP	E1	; We have Left term process operators next
      0  24ab					      db	29
      1  24ab		       1d		      .byte.b	29
      0  24ac					      dw	E1
      1  24ac		       b4 24		      .word.w	E1
    678  24ae				   E0
      0  24ae					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  24ae					      db	101
      1  24ae		       65		      .byte.b	101
      0  24af					      db	(E1A-*)-1
      1  24af		       01		      .byte.b	(E1A-*)-1
      0  24b0					      db	oPlus
      1  24b0		       ea		      .byte.b	oPlus
    680  24b1				   E1A
      0  24b1					      CALL	TERM	; Get the left term if it was not negated
      0  24b1					      db	28
      1  24b1		       1c		      .byte.b	28
      0  24b2					      dw	TERM
      1  24b2		       ca 24		      .word.w	TERM
    682  24b4				   E1
      0  24b4					      TST	E2,oPlus	; Check if we are adding left term to something
      0  24b4					      db	32
      1  24b4		       20		      .byte.b	32
      0  24b5					      db	(E2-*)-1
      1  24b5		       09		      .byte.b	(E2-*)-1
      0  24b6					      db	oPlus,0
      1  24b6		       ea 00		      .byte.b	oPlus,0
      0  24b8					      CALL	TERM	; if adding then get the right side term
      0  24b8					      db	28
      1  24b8		       1c		      .byte.b	28
      0  24b9					      dw	TERM
      1  24b9		       ca 24		      .word.w	TERM
      0  24bb					      ADD		; Add it to left term
      0  24bb					      db	14
      1  24bb		       0e		      .byte.b	14
      0  24bc					      IJMP	E1	; look for next + or -
      0  24bc					      db	29
      1  24bc		       1d		      .byte.b	29
      0  24bd					      dw	E1
      1  24bd		       b4 24		      .word.w	E1
    687  24bf				   E2
      0  24bf					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  24bf					      db	101
      1  24bf		       65		      .byte.b	101
      0  24c0					      db	(E3-*)-1
      1  24c0		       08		      .byte.b	(E3-*)-1
      0  24c1					      db	oMinus
      1  24c1		       eb		      .byte.b	oMinus
      0  24c2					      CALL	TERM	; get right side to subtract Diffrence
      0  24c2					      db	28
      1  24c2		       1c		      .byte.b	28
      0  24c3					      dw	TERM
      1  24c3		       ca 24		      .word.w	TERM
      0  24c5					      SUB		; Subtract the value
      0  24c5					      db	15
      1  24c5		       0f		      .byte.b	15
      0  24c6					      IJMP	E1	; Look for next + or -
      0  24c6					      db	29
      1  24c6		       1d		      .byte.b	29
      0  24c7					      dw	E1
      1  24c7		       b4 24		      .word.w	E1
    692  24c9				   E3			; Finish processing the expression
      0  24c9					      RTN		; We are finished processing the Expression
      0  24c9					      db	25
      1  24c9		       19		      .byte.b	25
    694  24ca							;
    695  24ca							; Get one of the terms of an expression
    696  24ca							;
    697  24ca				   TERM
      0  24ca					      CALL	FACT	; Get a value
      0  24ca					      db	28
      1  24ca		       1c		      .byte.b	28
      0  24cb					      dw	FACT
      1  24cb		       ef 24		      .word.w	FACT
    699  24cd				   T0			; Check for higher precidence operators
      0  24cd					      TSTB	T1,oMultiply	; Check for *
      0  24cd					      db	101
      1  24cd		       65		      .byte.b	101
      0  24ce					      db	(T1-*)-1
      1  24ce		       08		      .byte.b	(T1-*)-1
      0  24cf					      db	oMultiply
      1  24cf		       ee		      .byte.b	oMultiply
      0  24d0					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  24d0					      db	28
      1  24d0		       1c		      .byte.b	28
      0  24d1					      dw	FACT
      1  24d1		       ef 24		      .word.w	FACT
      0  24d3					      MUL		; Multiply factors
      0  24d3					      db	17
      1  24d3		       11		      .byte.b	17
      0  24d4					      IJMP	T0	; Check for * or /
      0  24d4					      db	29
      1  24d4		       1d		      .byte.b	29
      0  24d5					      dw	T0
      1  24d5		       cd 24		      .word.w	T0
    704  24d7				   T1
      0  24d7					      TSTB	T2,oDivide	; Check for a division
      0  24d7					      db	101
      1  24d7		       65		      .byte.b	101
      0  24d8					      db	(T2-*)-1
      1  24d8		       08		      .byte.b	(T2-*)-1
      0  24d9					      db	oDivide
      1  24d9		       ec		      .byte.b	oDivide
      0  24da					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  24da					      db	28
      1  24da		       1c		      .byte.b	28
      0  24db					      dw	FACT
      1  24db		       ef 24		      .word.w	FACT
      0  24dd					      DIV		; do division
      0  24dd					      db	18
      1  24dd		       12		      .byte.b	18
      0  24de					      IJMP	T0	; check for more * or /
      0  24de					      db	29
      1  24de		       1d		      .byte.b	29
      0  24df					      dw	T0
      1  24df		       cd 24		      .word.w	T0
    709  24e1				   T2
      0  24e1					      TSTB	T3,oModulo	; Check for a division
      0  24e1					      db	101
      1  24e1		       65		      .byte.b	101
      0  24e2					      db	(T3-*)-1
      1  24e2		       08		      .byte.b	(T3-*)-1
      0  24e3					      db	oModulo
      1  24e3		       ed		      .byte.b	oModulo
      0  24e4					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  24e4					      db	28
      1  24e4		       1c		      .byte.b	28
      0  24e5					      dw	FACT
      1  24e5		       ef 24		      .word.w	FACT
      0  24e7					      MODULO		; do division for remainder
      0  24e7					      db	60
      1  24e7		       3c		      .byte.b	60
      0  24e8					      IJMP	T0	; check for more * or / or %
      0  24e8					      db	29
      1  24e8		       1d		      .byte.b	29
      0  24e9					      dw	T0
      1  24e9		       cd 24		      .word.w	T0
    714  24eb				   T3			; Finish processing the Term
      0  24eb					      RTN
      0  24eb					      db	25
      1  24eb		       19		      .byte.b	25
    716  24ec
    717  24ec				   UNKNOWNVEC
      0  24ec					      IJMP	UNKNOWN
      0  24ec					      db	29
      1  24ec		       1d		      .byte.b	29
      0  24ed					      dw	UNKNOWN
      1  24ed		       76 24		      .word.w	UNKNOWN
    719  24ef
    720  24ef							;=============================================================================================
    721  24ef							; Factor an expression.  Always test for functions
    722  24ef							; first or else they'll be confused for variables.
    723  24ef							;
    724  24ef				   FACT
      0  24ef					      OnGoto	BasicFuncs,FactNumber
      0  24ef					      db	103
      1  24ef		       67		      .byte.b	103
      0  24f0					      dw	BasicFuncs
      1  24f0		       7e 22		      .word.w	BasicFuncs
      0  24f2					      dw	FactNumber
      1  24f2		       b9 25		      .word.w	FactNumber
    726  24f4
    727  24f4							;FACTCONTINUE:
    728  24f4							;	  TSTB	     F1AA,kTrue
    729  24f4				   ekTrue
      0  24f4					      LIT	-1
      0  24f4					      db	27
      1  24f4		       1b		      .byte.b	27
      0  24f5					      dw	-1
      1  24f5		       ff ff		      .word.w	-1
      0  24f7					      RTN
      0  24f7					      db	25
      1  24f7		       19		      .byte.b	25
    732  24f8							;F1AA:
    733  24f8							;	  TSTB	     F1AB,kFalse
    734  24f8				   ekFalse
      0  24f8					      LIT	0
      0  24f8					      db	27
      1  24f8		       1b		      .byte.b	27
      0  24f9					      dw	0
      1  24f9		       00 00		      .word.w	0
      0  24fb					      RTN
      0  24fb					      db	25
      1  24fb		       19		      .byte.b	25
    737  24fc							;==================================================================================
    738  24fc							; Returns the amount of free SPACE
    739  24fc							;
    740  24fc							;F1AB
    741  24fc							;	  TSTB	     F1A,kFree
    742  24fc				   ekFree
      0  24fc					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24fc					      db	101
      1  24fc		       65		      .byte.b	101
      0  24fd					      db	(UNKNOWNVEC-*)-1
      1  24fd		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  24fe					      db	oLeftBracket
      1  24fe		       e0		      .byte.b	oLeftBracket
      0  24ff					      TSTB	UNKNOWNVEC,oRightBracket
      0  24ff					      db	101
      1  24ff		       65		      .byte.b	101
      0  2500					      db	(UNKNOWNVEC-*)-1
      1  2500		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  2501					      db	oRightBracket
      1  2501		       e1		      .byte.b	oRightBracket
      0  2502					      FREE
      0  2502					      db	36
      1  2502		       24		      .byte.b	36
      0  2503					      RTN
      0  2503					      db	25
      1  2503		       19		      .byte.b	25
    747  2504							;===================================================================================
    748  2504							; getch() read a character from the input device
    749  2504							;
    750  2504							;F1A:
    751  2504							;	  TSTB	     F1A2,kGetch		      ; read char from the terminal
    752  2504				   ekGetch
      0  2504					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2504					      db	101
      1  2504		       65		      .byte.b	101
      0  2505					      db	(UNKNOWNVEC-*)-1
      1  2505		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  2506					      db	oLeftBracket
      1  2506		       e0		      .byte.b	oLeftBracket
      0  2507					      TSTB	UNKNOWNVEC,oRightBracket
      0  2507					      db	101
      1  2507		       65		      .byte.b	101
      0  2508					      db	(UNKNOWNVEC-*)-1
      1  2508		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  2509					      db	oRightBracket
      1  2509		       e1		      .byte.b	oRightBracket
      0  250a					      GETCHAR
      0  250a					      db	51
      1  250a		       33		      .byte.b	51
      0  250b					      RTN
      0  250b					      db	25
      1  250b		       19		      .byte.b	25
    757  250c							;====================================================================================
    758  250c							; peek(mem address) return the value of a byte in memory
    759  250c							; @[offset] return a word value from offset -- see tstv
    760  250c							;
    761  250c							;F1A2:
    762  250c							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    763  250c				   ekPeek
      0  250c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  250c					      db	101
      1  250c		       65		      .byte.b	101
      0  250d					      db	(UNKNOWNVEC-*)-1
      1  250d		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  250e					      db	oLeftBracket
      1  250e		       e0		      .byte.b	oLeftBracket
      0  250f					      CALL	EXPR	;Get the address to write to
      0  250f					      db	28
      1  250f		       1c		      .byte.b	28
      0  2510					      dw	EXPR
      1  2510		       7a 24		      .word.w	EXPR
      0  2512					      TSTB	UNKNOWNVEC,oRightBracket
      0  2512					      db	101
      1  2512		       65		      .byte.b	101
      0  2513					      db	(UNKNOWNVEC-*)-1
      1  2513		       d8		      .byte.b	(UNKNOWNVEC-*)-1
      0  2514					      db	oRightBracket
      1  2514		       e1		      .byte.b	oRightBracket
      0  2515					      PEEKMEM
      0  2515					      db	48
      1  2515		       30		      .byte.b	48
      0  2516					      RTN
      0  2516					      db	25
      1  2516		       19		      .byte.b	25
    769  2517							;=======================================================================================
    770  2517							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    771  2517							;
    772  2517							;F2AZ:
    773  2517							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    774  2517				   ekTask
      0  2517					      TSTBRANCH	ekTaskCompiled
      0  2517					      db	106
      1  2517		       6a		      .byte.b	106
      0  2518					      db	(ekTaskCompiled-*)-1
      1  2518		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  2519					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2519					      db	101
      1  2519		       65		      .byte.b	101
      0  251a					      db	(UNKNOWNVEC-*)-1
      1  251a		       d1		      .byte.b	(UNKNOWNVEC-*)-1
      0  251b					      db	oLeftBracket
      1  251b		       e0		      .byte.b	oLeftBracket
      0  251c					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  251c					      db	28
      1  251c		       1c		      .byte.b	28
      0  251d					      dw	EXPR
      1  251d		       7a 24		      .word.w	EXPR
      0  251f					      lit	0
      0  251f					      db	27
      1  251f		       1b		      .byte.b	27
      0  2520					      dw	0
      1  2520		       00 00		      .word.w	0
      0  2522					      iJMP	ekTaskLinenum
      0  2522					      db	29
      1  2522		       1d		      .byte.b	29
      0  2523					      dw	ekTaskLinenum
      1  2523		       28 25		      .word.w	ekTaskLinenum
    780  2525
    781  2525				   ekTaskCompiled
      0  2525					      lit	1
      0  2525					      db	27
      1  2525		       1b		      .byte.b	27
      0  2526					      dw	1
      1  2526		       01 00		      .word.w	1
    783  2528
    784  2528				   ekTaskLinenum
      0  2528					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  2528					      db	61
      1  2528		       3d		      .byte.b	61
      0  2529					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  2529					      db	101
      1  2529		       65		      .byte.b	101
      0  252a					      db	(F2AZNoParms-*)-1
      1  252a		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  252b					      db	oComma
      1  252b		       e2		      .byte.b	oComma
      0  252c					      SAVEMATHSTACK		;Push The mathstack
      0  252c					      db	86
      1  252c		       56		      .byte.b	86
      0  252d					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  252d					      db	89
      1  252d		       59		      .byte.b	89
    789  252e				   F2AZLOOP
      0  252e					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  252e					      db	28
      1  252e		       1c		      .byte.b	28
      0  252f					      dw	EXPR
      1  252f		       7a 24		      .word.w	EXPR
      0  2531					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  2531					      db	101
      1  2531		       65		      .byte.b	101
      0  2532					      db	(F2AZEndParm-*)-1
      1  2532		       04		      .byte.b	(F2AZEndParm-*)-1
      0  2533					      db	oComma
      1  2533		       e2		      .byte.b	oComma
      0  2534					      IJMP	F2AZLOOP	;check for more
      0  2534					      db	29
      1  2534		       1d		      .byte.b	29
      0  2535					      dw	F2AZLOOP
      1  2535		       2e 25		      .word.w	F2AZLOOP
    793  2537
    794  2537				   F2AZEndParm
      0  2537					      RESTOREMATHSTACK		;Back to normal stack
      0  2537					      db	87
      1  2537		       57		      .byte.b	87
      0  2538					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  2538					      db	92
      1  2538		       5c		      .byte.b	92
    797  2539
    798  2539				   F2AZNoParms
      0  2539					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  2539					      db	101
      1  2539		       65		      .byte.b	101
      0  253a					      db	(UNKNOWNVEC-*)-1
      1  253a		       b1		      .byte.b	(UNKNOWNVEC-*)-1
      0  253b					      db	oRightBracket
      1  253b		       e1		      .byte.b	oRightBracket
    800  253c
      0  253c					      TASKENABLE		;Enable the task to execute
      0  253c					      db	90
      1  253c		       5a		      .byte.b	90
    802  253d
      0  253d					      RTN		;Returns the Task number
      0  253d					      db	25
      1  253d		       19		      .byte.b	25
    804  253e							;=========================================================================================
    805  253e							; Check for IPC interproccess instructions
    806  253e							;   IPCS  - Send a message
    807  253e							;
    808  253e							;F2AZ1:
    809  253e							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    810  253e				   ekIpcs
      0  253e					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  253e					      db	101
      1  253e		       65		      .byte.b	101
      0  253f					      db	(UNKNOWNVEC-*)-1
      1  253f		       ac		      .byte.b	(UNKNOWNVEC-*)-1
      0  2540					      db	oLeftBracket
      1  2540		       e0		      .byte.b	oLeftBracket
      0  2541					      CALL	EXPR	;Get the message value
      0  2541					      db	28
      1  2541		       1c		      .byte.b	28
      0  2542					      dw	EXPR
      1  2542		       7a 24		      .word.w	EXPR
      0  2544					      TSTB	UNKNOWNVEC,oComma
      0  2544					      db	101
      1  2544		       65		      .byte.b	101
      0  2545					      db	(UNKNOWNVEC-*)-1
      1  2545		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  2546					      db	oComma
      1  2546		       e2		      .byte.b	oComma
      0  2547					      CALL	EXPR	;Get pid of task to send to
      0  2547					      db	28
      1  2547		       1c		      .byte.b	28
      0  2548					      dw	EXPR
      1  2548		       7a 24		      .word.w	EXPR
      0  254a					      TSTB	UNKNOWNVEC,oRightBracket
      0  254a					      db	101
      1  254a		       65		      .byte.b	101
      0  254b					      db	(UNKNOWNVEC-*)-1
      1  254b		       a0		      .byte.b	(UNKNOWNVEC-*)-1
      0  254c					      db	oRightBracket
      1  254c		       e1		      .byte.b	oRightBracket
      0  254d					      IPCSEND		;Send msg and clear pid msg pending
      0  254d					      db	80
      1  254d		       50		      .byte.b	80
      0  254e					      RTN
      0  254e					      db	25
      1  254e		       19		      .byte.b	25
    818  254f							;================================================================================
    819  254f							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    820  254f							;
    821  254f							;F2AZa:
    822  254f							;	  TSTB	      F2AZb,kIpcr		      ;IPCR recieve a message , wait if none
    823  254f				   ekIpcr
      0  254f					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  254f					      db	101
      1  254f		       65		      .byte.b	101
      0  2550					      db	(UNKNOWNVEC-*)-1
      1  2550		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  2551					      db	oLeftBracket
      1  2551		       e0		      .byte.b	oLeftBracket
      0  2552					      TSTB	F2AZa1,oRightBracket
      0  2552					      db	101
      1  2552		       65		      .byte.b	101
      0  2553					      db	(F2AZa1-*)-1
      1  2553		       07		      .byte.b	(F2AZa1-*)-1
      0  2554					      db	oRightBracket
      1  2554		       e1		      .byte.b	oRightBracket
      0  2555					      LIT	0	;We dont want the pid returned to us
      0  2555					      db	27
      1  2555		       1b		      .byte.b	27
      0  2556					      dw	0
      1  2556		       00 00		      .word.w	0
      0  2558					      IJMP	ekIpcrComplete
      0  2558					      db	29
      1  2558		       1d		      .byte.b	29
      0  2559					      dw	ekIpcrComplete
      1  2559		       60 25		      .word.w	ekIpcrComplete
    828  255b				   F2AZa1
      0  255b					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  255b					      db	33
      1  255b		       21		      .byte.b	33
      0  255c					      db	(UNKNOWNVEC-*)-1
      1  255c		       8f		      .byte.b	(UNKNOWNVEC-*)-1
      0  255d					      TSTB	UNKNOWNVEC,oRightBracket
      0  255d					      db	101
      1  255d		       65		      .byte.b	101
      0  255e					      db	(UNKNOWNVEC-*)-1
      1  255e		       8d		      .byte.b	(UNKNOWNVEC-*)-1
      0  255f					      db	oRightBracket
      1  255f		       e1		      .byte.b	oRightBracket
    831  2560
    832  2560				   ekIpcrComplete
      0  2560					      IPCIO		;Set the io bit and exit task till message
      0  2560					      db	83
      1  2560		       53		      .byte.b	83
      0  2561					      IPCRECEIVE		;Get the message
      0  2561					      db	81
      1  2561		       51		      .byte.b	81
      0  2562					      RTN
      0  2562					      db	25
      1  2562		       19		      .byte.b	25
    836  2563							;===============================================================================
    837  2563							; IPCC ---- check if a message is available
    838  2563							;F2AZb:
    839  2563							;	  TST	     F2A,kIpcc			      ;Returns number of messages on the message queue
    840  2563				   ekIpcc
      0  2563					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2563					      db	101
      1  2563		       65		      .byte.b	101
      0  2564					      db	(UNKNOWNVEC-*)-1
      1  2564		       87		      .byte.b	(UNKNOWNVEC-*)-1
      0  2565					      db	oLeftBracket
      1  2565		       e0		      .byte.b	oLeftBracket
      0  2566					      TSTB	UNKNOWNVEC,oRightBracket
      0  2566					      db	101
      1  2566		       65		      .byte.b	101
      0  2567					      db	(UNKNOWNVEC-*)-1
      1  2567		       84		      .byte.b	(UNKNOWNVEC-*)-1
      0  2568					      db	oRightBracket
      1  2568		       e1		      .byte.b	oRightBracket
      0  2569					      IPCCHECK
      0  2569					      db	82
      1  2569		       52		      .byte.b	82
      0  256a					      RTN
      0  256a					      db	25
      1  256a		       19		      .byte.b	25
    845  256b
    846  256b				   UNKNOWNID
      0  256b					      IJMP	UNKNOWN
      0  256b					      db	29
      1  256b		       1d		      .byte.b	29
      0  256c					      dw	UNKNOWN
      1  256c		       76 24		      .word.w	UNKNOWN
    848  256e							;============================================================
    849  256e							; RND() is supposed to have an argument but if none
    850  256e							; was provided, just assume a large value.
    851  256e							;
    852  256e							;F2A:
    853  256e							;	  TSTB	      F2B,kRnd
    854  256e				   ekRnd
      0  256e					      TSTB	UNKNOWNVEC,oLeftBracket
      0  256e					      db	101
      1  256e		       65		      .byte.b	101
      0  256f					      db	(UNKNOWNVEC-*)-1
      1  256f		       7c		      .byte.b	(UNKNOWNVEC-*)-1
      0  2570					      db	oLeftBracket
      1  2570		       e0		      .byte.b	oLeftBracket
      0  2571					      TSTB	F2A1,oRightBracket
      0  2571					      db	101
      1  2571		       65		      .byte.b	101
      0  2572					      db	(F2A1-*)-1
      1  2572		       06		      .byte.b	(F2A1-*)-1
      0  2573					      db	oRightBracket
      1  2573		       e1		      .byte.b	oRightBracket
      0  2574					      LIT	32766
      0  2574					      db	27
      1  2574		       1b		      .byte.b	27
      0  2575					      dw	32766
      1  2575		       fe 7f		      .word.w	32766
      0  2577					      RANDOM
      0  2577					      db	37
      1  2577		       25		      .byte.b	37
      0  2578					      RTN
      0  2578					      db	25
      1  2578		       19		      .byte.b	25
    860  2579
    861  2579				   F2A1
      0  2579					      CALL	EXPR	;GET RANGE
      0  2579					      db	28
      1  2579		       1c		      .byte.b	28
      0  257a					      dw	EXPR
      1  257a		       7a 24		      .word.w	EXPR
      0  257c					      TSTB	UNKNOWNVEC,oRightBracket
      0  257c					      db	101
      1  257c		       65		      .byte.b	101
      0  257d					      db	(UNKNOWNVEC-*)-1
      1  257d		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  257e					      db	oRightBracket
      1  257e		       e1		      .byte.b	oRightBracket
      0  257f					      RANDOM
      0  257f					      db	37
      1  257f		       25		      .byte.b	37
      0  2580					      RTN
      0  2580					      db	25
      1  2580		       19		      .byte.b	25
    866  2581							;==========================================================
    867  2581							;	Return absolute value of expresion
    868  2581							;
    869  2581							;F2B:
    870  2581							;	  TSTB	      F2B2,kAbs
    871  2581				   ekAbs
      0  2581					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2581					      db	101
      1  2581		       65		      .byte.b	101
      0  2582					      db	(UNKNOWNVEC-*)-1
      1  2582		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  2583					      db	oLeftBracket
      1  2583		       e0		      .byte.b	oLeftBracket
      0  2584					      CALL	EXPR	;get value
      0  2584					      db	28
      1  2584		       1c		      .byte.b	28
      0  2585					      dw	EXPR
      1  2585		       7a 24		      .word.w	EXPR
      0  2587					      TSTB	UNKNOWNVEC,oRightBracket
      0  2587					      db	101
      1  2587		       65		      .byte.b	101
      0  2588					      db	(UNKNOWNVEC-*)-1
      1  2588		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  2589					      db	oRightBracket
      1  2589		       e1		      .byte.b	oRightBracket
      0  258a					      ABS
      0  258a					      db	38
      1  258a		       26		      .byte.b	38
      0  258b					      RTN
      0  258b					      db	25
      1  258b		       19		      .byte.b	25
    877  258c							;============================================================
    878  258c							;     Return the the status of a task, provide the PID
    879  258c							;
    880  258c							;F2B2:
    881  258c							;	  TSTB	      F2Z,kStat
    882  258c				   ekStat
      0  258c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  258c					      db	101
      1  258c		       65		      .byte.b	101
      0  258d					      db	(UNKNOWNVEC-*)-1
      1  258d		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  258e					      db	oLeftBracket
      1  258e		       e0		      .byte.b	oLeftBracket
      0  258f					      Call	EXPR
      0  258f					      db	28
      1  258f		       1c		      .byte.b	28
      0  2590					      dw	EXPR
      1  2590		       7a 24		      .word.w	EXPR
      0  2592					      TSTB	UNKNOWNVEC,oRightBracket
      0  2592					      db	101
      1  2592		       65		      .byte.b	101
      0  2593					      db	(UNKNOWNVEC-*)-1
      1  2593		       58		      .byte.b	(UNKNOWNVEC-*)-1
      0  2594					      db	oRightBracket
      1  2594		       e1		      .byte.b	oRightBracket
      0  2595					      TASKSTAT
      0  2595					      db	66
      1  2595		       42		      .byte.b	66
      0  2596					      RTN
      0  2596					      db	25
      1  2596		       19		      .byte.b	25
    888  2597							;==============================================================
    889  2597							; Return the current tasks pid
    890  2597							;
    891  2597							;F2Z:
    892  2597							;	  TSTB	      F2ZA,kPid
    893  2597				   ekPid
      0  2597					      TASKPID
      0  2597					      db	77
      1  2597		       4d		      .byte.b	77
      0  2598					      RTN
      0  2598					      db	25
      1  2598		       19		      .byte.b	25
    896  2599							;===========================================================================
    897  2599							; Call a machine function, provide the address to call and optionally
    898  2599							; the value to be passed in reg A
    899  2599							;F2ZA:
    900  2599							;	  TSTB	       F2FUNC,kCall		       ;call machine function
    901  2599				   ekCall
      0  2599					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2599					      db	101
      1  2599		       65		      .byte.b	101
      0  259a					      db	(UNKNOWNVEC-*)-1
      1  259a		       51		      .byte.b	(UNKNOWNVEC-*)-1
      0  259b					      db	oLeftBracket
      1  259b		       e0		      .byte.b	oLeftBracket
      0  259c					      CALL	EXPR
      0  259c					      db	28
      1  259c		       1c		      .byte.b	28
      0  259d					      dw	EXPR
      1  259d		       7a 24		      .word.w	EXPR
      0  259f					      TSTB	F2B2A,oComma
      0  259f					      db	101
      1  259f		       65		      .byte.b	101
      0  25a0					      db	(F2B2A-*)-1
      1  25a0		       09		      .byte.b	(F2B2A-*)-1
      0  25a1					      db	oComma
      1  25a1		       e2		      .byte.b	oComma
      0  25a2					      CALL	EXPR
      0  25a2					      db	28
      1  25a2		       1c		      .byte.b	28
      0  25a3					      dw	EXPR
      1  25a3		       7a 24		      .word.w	EXPR
      0  25a5					      TSTB	UNKNOWNVEC,oRightBracket
      0  25a5					      db	101
      1  25a5		       65		      .byte.b	101
      0  25a6					      db	(UNKNOWNVEC-*)-1
      1  25a6		       45		      .byte.b	(UNKNOWNVEC-*)-1
      0  25a7					      db	oRightBracket
      1  25a7		       e1		      .byte.b	oRightBracket
      0  25a8					      CALLFUNC
      0  25a8					      db	53
      1  25a8		       35		      .byte.b	53
      0  25a9					      RTN
      0  25a9					      db	25
      1  25a9		       19		      .byte.b	25
    909  25aa							; Run the gosub within this function
    910  25aa				   F2B2A
      0  25aa					      TSTB	UNKNOWNID,oRightBracket
      0  25aa					      db	101
      1  25aa		       65		      .byte.b	101
      0  25ab					      db	(UNKNOWNID-*)-1
      1  25ab		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  25ac					      db	oRightBracket
      1  25ac		       e1		      .byte.b	oRightBracket
      0  25ad					      LIT	0	; No parameter passed so just load zero to A
      0  25ad					      db	27
      1  25ad		       1b		      .byte.b	27
      0  25ae					      dw	0
      1  25ae		       00 00		      .word.w	0
      0  25b0					      CALLFUNC
      0  25b0					      db	53
      1  25b0		       35		      .byte.b	53
      0  25b1					      RTN
      0  25b1					      db	25
      1  25b1		       19		      .byte.b	25
    915  25b2							;===========================================================================
    916  25b2							; Same as gosub but expects a return value
    917  25b2							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    918  25b2							;
    919  25b2							;F2FUNC  TSTB	      F2C,kGofn
    920  25b2				   ekGofn
      0  25b2					      Call	GOSUBSTATEMENT
      0  25b2					      db	28
      1  25b2		       1c		      .byte.b	28
      0  25b3					      dw	GOSUBSTATEMENT
      1  25b3		       f8 25		      .word.w	GOSUBSTATEMENT
      0  25b5					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  25b5					      db	8
      1  25b5		       08		      .byte.b	8
      0  25b6					      db	GOSUB_RTN_VALUE
      1  25b6		       81		      .byte.b	GOSUB_RTN_VALUE
      0  25b7					      FASTXFER
      0  25b7					      db	107
      1  25b7		       6b		      .byte.b	107
    924  25b8
    925  25b8				   GOFNRet
      0  25b8					      RTN
      0  25b8					      db	25
      1  25b8		       19		      .byte.b	25
    927  25b9
    928  25b9							;=================================================================================
    929  25b9							;Check for a number !
    930  25b9							;
    931  25b9							;F0:
    932  25b9				   FactNumber
      0  25b9					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  25b9					      db	35
      1  25b9		       23		      .byte.b	35
      0  25ba					      db	(FactVariable-*)-1
      1  25ba		       0f		      .byte.b	(FactVariable-*)-1
      0  25bb					      RTN
      0  25bb					      db	25
      1  25bb		       19		      .byte.b	25
    935  25bc				   F1
      0  25bc					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  25bc					      db	101
      1  25bc		       65		      .byte.b	101
      0  25bd					      db	(F2RTN-*)-1
      1  25bd		       08		      .byte.b	(F2RTN-*)-1
      0  25be					      db	oLeftBracket
      1  25be		       e0		      .byte.b	oLeftBracket
      0  25bf					      CALL	EXPR
      0  25bf					      db	28
      1  25bf		       1c		      .byte.b	28
      0  25c0					      dw	EXPR
      1  25c0		       7a 24		      .word.w	EXPR
      0  25c2					      TST	F2,oRightBracket
      0  25c2					      db	32
      1  25c2		       20		      .byte.b	32
      0  25c3					      db	(F2-*)-1
      1  25c3		       03		      .byte.b	(F2-*)-1
      0  25c4					      db	oRightBracket,0
      1  25c4		       e1 00		      .byte.b	oRightBracket,0
    939  25c6				   F2RTN
      0  25c6					      RTN
      0  25c6					      db	25
      1  25c6		       19		      .byte.b	25
    941  25c7
    942  25c7				   F2
      0  25c7					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  25c7					      db	13
      1  25c7		       0d		      .byte.b	13
      0  25c8					      dw	ERR_SYNTAX
      1  25c8		       05 00		      .word.w	ERR_SYNTAX
    944  25ca							;
    945  25ca							;=============================================================================
    946  25ca							; See if this is just a simple variable
    947  25ca							;  Allow a subscript for any variable
    948  25ca							;
    949  25ca							;F2C:
    950  25ca							;
    951  25ca				   FactVariable
      0  25ca					      CALL	FactVarPTR
      0  25ca					      db	28
      1  25ca		       1c		      .byte.b	28
      0  25cb					      dw	FactVarPTR
      1  25cb		       d1 25		      .word.w	FactVarPTR
      0  25cd					      CALL	FactVariableValue
      0  25cd					      db	28
      1  25cd		       1c		      .byte.b	28
      0  25ce					      dw	FactVariableValue
      1  25ce		       f6 25		      .word.w	FactVariableValue
      0  25d0					      RTN
      0  25d0					      db	25
      1  25d0		       19		      .byte.b	25
    955  25d1
    956  25d1				   FactVarPTR
      0  25d1					      TSTV	F1
      0  25d1					      db	33
      1  25d1		       21		      .byte.b	33
      0  25d2					      db	(F1-*)-1
      1  25d2		       e9		      .byte.b	(F1-*)-1
      0  25d3					      TSTB	F2CLocalTask,oBang
      0  25d3					      db	101
      1  25d3		       65		      .byte.b	101
      0  25d4					      db	(F2CLocalTask-*)-1
      1  25d4		       04		      .byte.b	(F2CLocalTask-*)-1
      0  25d5					      db	oBang
      1  25d5		       e8		      .byte.b	oBang
      0  25d6					      IND		; we just got a pid
      0  25d6					      db	20
      1  25d6		       14		      .byte.b	20
      0  25d7					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  25d7					      db	93
      1  25d7		       5d		      .byte.b	93
      0  25d8					      db	(UNKNOWNID-*)-1
      1  25d8		       92		      .byte.b	(UNKNOWNID-*)-1
    961  25d9
    962  25d9				   F2CLocalTask
    963  25d9
      0  25d9					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  25d9					      db	101
      1  25d9		       65		      .byte.b	101
      0  25da					      db	(F2INTEGER-*)-1
      1  25da		       0f		      .byte.b	(F2INTEGER-*)-1
      0  25db					      db	oDollar
      1  25db		       e7		      .byte.b	oDollar
      0  25dc					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  25dc					      db	101
      1  25dc		       65		      .byte.b	101
      0  25dd					      db	(F2PTRLOADED-*)-1
      1  25dd		       17		      .byte.b	(F2PTRLOADED-*)-1
      0  25de					      db	oLeftSQBracket
      1  25de		       e4		      .byte.b	oLeftSQBracket
      0  25df					      CALL	EXPR
      0  25df					      db	28
      1  25df		       1c		      .byte.b	28
      0  25e0					      dw	EXPR
      1  25e0		       7a 24		      .word.w	EXPR
      0  25e2					      TSTB	UNKNOWNID,oRightSQBracket
      0  25e2					      db	101
      1  25e2		       65		      .byte.b	101
      0  25e3					      db	(UNKNOWNID-*)-1
      1  25e3		       87		      .byte.b	(UNKNOWNID-*)-1
      0  25e4					      db	oRightSQBracket
      1  25e4		       e5		      .byte.b	oRightSQBracket
      0  25e5					      SUBSCRIPT	1	; Byte type array
      0  25e5					      db	64
      1  25e5		       40		      .byte.b	64
      0  25e6					      db	1
      1  25e6		       01		      .byte.b	1
      0  25e7					      IJMP	F2PTRLOADED	; Get the value to top of stack
      0  25e7					      db	29
      1  25e7		       1d		      .byte.b	29
      0  25e8					      dw	F2PTRLOADED
      1  25e8		       f5 25		      .word.w	F2PTRLOADED
    970  25ea
    971  25ea				   F2INTEGER
      0  25ea					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  25ea					      db	101
      1  25ea		       65		      .byte.b	101
      0  25eb					      db	(F2PTRLOADED-*)-1
      1  25eb		       09		      .byte.b	(F2PTRLOADED-*)-1
      0  25ec					      db	oLeftSQBracket
      1  25ec		       e4		      .byte.b	oLeftSQBracket
      0  25ed					      CALL	EXPR
      0  25ed					      db	28
      1  25ed		       1c		      .byte.b	28
      0  25ee					      dw	EXPR
      1  25ee		       7a 24		      .word.w	EXPR
      0  25f0					      TSTB	UNKNOWNID,oRightSQBracket
      0  25f0					      db	101
      1  25f0		       65		      .byte.b	101
      0  25f1					      db	(UNKNOWNID-*)-1
      1  25f1		       79		      .byte.b	(UNKNOWNID-*)-1
      0  25f2					      db	oRightSQBracket
      1  25f2		       e5		      .byte.b	oRightSQBracket
      0  25f3					      SUBSCRIPT	0	; Integer type array
      0  25f3					      db	64
      1  25f3		       40		      .byte.b	64
      0  25f4					      db	0
      1  25f4		       00		      .byte.b	0
    976  25f5
    977  25f5				   F2PTRLOADED
      0  25f5					      RTN
      0  25f5					      db	25
      1  25f5		       19		      .byte.b	25
    979  25f6
    980  25f6				   FactVariableValue
      0  25f6					      IND		; YES, GET THE VALUE.
      0  25f6					      db	20
      1  25f6		       14		      .byte.b	20
      0  25f7					      RTN
      0  25f7					      db	25
      1  25f7		       19		      .byte.b	25
    983  25f8
    984  25f8							;=============================================================
    985  25f8							; Gosub can be both a Function and a Subroutine
    986  25f8				   GOSUBSTATEMENT
      0  25f8					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  25f8					      db	106
      1  25f8		       6a		      .byte.b	106
      0  25f9					      db	(GOSUBCOMPILED-*)-1
      1  25f9		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  25fa					      CALL	EXPR	; GET DESTINATION
      0  25fa					      db	28
      1  25fa		       1c		      .byte.b	28
      0  25fb					      dw	EXPR
      1  25fb		       7a 24		      .word.w	EXPR
      0  25fd					      CALL	GOSUBCONT
      0  25fd					      db	28
      1  25fd		       1c		      .byte.b	28
      0  25fe					      dw	GOSUBCONT
      1  25fe		       0b 26		      .word.w	GOSUBCONT
      0  2600					      lit	0	; mark as lookup on stack
      0  2600					      db	27
      1  2600		       1b		      .byte.b	27
      0  2601					      dw	0
      1  2601		       00 00		      .word.w	0
      0  2603					      RTN
      0  2603					      db	25
      1  2603		       19		      .byte.b	25
    992  2604
    993  2604				   GOSUBCOMPILED
      0  2604					      CALL	GOSUBCONT
      0  2604					      db	28
      1  2604		       1c		      .byte.b	28
      0  2605					      dw	GOSUBCONT
      1  2605		       0b 26		      .word.w	GOSUBCONT
      0  2607					      lit	1	;mark as compiled on stack
      0  2607					      db	27
      1  2607		       1b		      .byte.b	27
      0  2608					      dw	1
      1  2608		       01 00		      .word.w	1
      0  260a					      RTN
      0  260a					      db	25
      1  260a		       19		      .byte.b	25
    997  260b
    998  260b				   GOSUBCONT
      0  260b					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  260b					      db	101
      1  260b		       65		      .byte.b	101
      0  260c					      db	(GOSUBDONE-*)-1
      1  260c		       11		      .byte.b	(GOSUBDONE-*)-1
      0  260d					      db	oLeftBracket
      1  260d		       e0		      .byte.b	oLeftBracket
      0  260e					      STK2TMP		;Transfer stack top to temp
      0  260e					      db	95
      1  260e		       5f		      .byte.b	95
      0  260f					      PUSHMATHSTACK		;Record stack frame for return
      0  260f					      db	84
      1  260f		       54		      .byte.b	84
   1002  2610				   GOSUBLOOP
      0  2610					      CALL	EXPR	; Allows what ever fits onto stack
      0  2610					      db	28
      1  2610		       1c		      .byte.b	28
      0  2611					      dw	EXPR
      1  2611		       7a 24		      .word.w	EXPR
      0  2613					      INCPARMCOUNT
      0  2613					      db	88
      1  2613		       58		      .byte.b	88
      0  2614					      TSTB	GOSUBParmDONE,oComma
      0  2614					      db	101
      1  2614		       65		      .byte.b	101
      0  2615					      db	(GOSUBParmDONE-*)-1
      1  2615		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  2616					      db	oComma
      1  2616		       e2		      .byte.b	oComma
      0  2617					      IJMP	GOSUBLOOP
      0  2617					      db	29
      1  2617		       1d		      .byte.b	29
      0  2618					      dw	GOSUBLOOP
      1  2618		       10 26		      .word.w	GOSUBLOOP
   1007  261a				   GOSUBParmDONE
      0  261a					      TSTB	F2,oRightBracket
      0  261a					      db	101
      1  261a		       65		      .byte.b	101
      0  261b					      db	(F2-*)-1
      1  261b		       ab		      .byte.b	(F2-*)-1
      0  261c					      db	oRightBracket
      1  261c		       e1		      .byte.b	oRightBracket
      0  261d					      TMP2STK		; Restore line to goto
      0  261d					      db	96
      1  261d		       60		      .byte.b	96
   1010  261e				   GOSUBDONE
      0  261e					      RTN
      0  261e					      db	25
      1  261e		       19		      .byte.b	25
   1012  261f
   1013  261f		       26 1f	   ILEND      equ	*
------- FILE mytb.asm
   2428  261f		       26 1f	   PROGEND    equ	*
   2429  261f
   2430  261f
   2431  261f							;=====================================================
   2432  261f							; Define start of non page zero data
   2433 U2661					      seg.u	TBData
   2434 U2661
   2435 U2661							;=====================================================
   2436 U2661							; These are storage items not in page zero.
   2437 U2661							;
   2438 U2661							; IRQ BASIC Code Service RTN Support
      0 U2661				   SaveIrqReg db	0	; Store current setting
      1 U2661		       00		      .byte.b	0
      0 U2662				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U2662		       00		      .byte.b	0
      0 U2663				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U2663		       00		      .byte.b	0
      0 U2664				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U2664		       00 00		      .byte.b	0,0
   2443 U2666
   2444 U2666							;
   2445 U2666							;==================================================================================================
   2446 U2666							; Task Management information
   2447 U2666							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2448 U2666							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2449 U2666							; Task switchs happen at the beginning of the next Basic command line
   2450 U2666							; It will not happen during an input or output operations
   2451 U2666							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2452 U2666							; Task Zero is always the root task, main line program
   2453 U2666							;
   2454 U2666							; Layout is repeated for each configured task
   2455 U2666							; Task Table Byte   use masks follow
   2456 U2666		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2457 U2666		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2458 U2666		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2459 U2666		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2460 U2666		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2461 U2666
   2462 U2666		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2463 U2667		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2464 U2667		       27 61	   TASKTABLEEND equ	*	; End of task table
   2465 U2667		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2466 U2761
   2467 U2761							;Task Cycle Counter and reset count
   2468 U2761		       00 00	   taskCurrentCycles ds	2
   2469 U2763		       00 00	   taskResetValue ds	2
   2470 U2765		       00	   taskCounter ds	1	; Count of active tasks
   2471 U2766
   2472 U2766							;
   2473 U2766							; Math stack and IL call and Gosub/For-next return stack definitions
   2474 U2766							;
   2475 U2766		       27 66	   STACKSTART equ	*
   2476 U2766		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2477 U28f6		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2478 U2a86		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2479 U2d06		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code
   2480 U2d06		       00 34	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2481 U2d06		       2f 22	   STACKEND   equ	*
   2482 U2d06		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2483 U2f22							;
   2484 U2f22							;
   2485 U2f22		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2486 U2fa6		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2487 U2fa7		       00	   printtx    ds	1	;temp X for print funcs
   2488 U2fa8		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2489 U2fa9		       00	   promptChar ds	1	;the character to use for a prompt
   2490 U2faa		       00	   diddigit   ds	1	;for leading zero suppression
   2491 U2fab		       00	   putsy      ds	1
   2492 U2fac		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2493 U2fae		       00	   sign       ds	1	;0 = positive, else negative
   2494 U2faf		       00 00	   rtemp1     ds	2	;Temp for x and y
   2495 U2fb1		       00 00	   random     ds	2
   2496 U2fb3		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2497 U2fb5		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2498 U2fb7		       00	   tempy      ds	1	;temp y storage
   2499 U2fb8
   2500 U2fb8
   2501 U2fb8							; Moved from page zero as one clock cycle diff gives more space on page zero
   2502 U2fb8		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2503 U2fba		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2504 U2fbb		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2505 U2fbc		       00	   lineLength ds	1	;Length of current line
   2506 U2fbd
   2507 U2fbd		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2508 U2fbe		       00	   taskRDPending ds	1	; 1 = background read is pending
   2509 U2fbf
   2510 U2fbf				  -	      if	XKIM
   2511 U2fbf				  -buffer     ds	BUFFER_SIZE
   2512 U2fbf					      endif
   2513 U2fbf							;
   2514 U2fbf							; PROGRAMEND is the end of the user's BASIC program.
   2515 U2fbf							; More precisely, it is one byte past the end.  Or,
   2516 U2fbf							; it's where the next line added to the end will be
   2517 U2fbf							; placed.
   2518 U2fbf							;
   2519 U2fbf		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2520 U2fc1		       00 00	   ProgramEnd ds	2	; End of users basic program
   2521 U2fc3		       00 00	   HighMem    ds	2	; highest location
   2522 U2fc5		       00 00	   UsedMem    ds	2	; size of user program
   2523 U2fc7		       00 00	   FreeMem    ds	2	; amount of free memory
   2524 U2fc9							;
   2525 U2fc9							;=====================================================
   2526 U2fc9							; This is the start of the user's BASIC program space.
   2527 U2fc9							;
   2528 U2fc9							; PERSONAL GOAL: This should be no larger than $0DFF.
   2529 U2fc9							;		  0200-05FF = 1K
   2530 U2fc9							;		  0200-09FF = 2K
   2531 U2fc9							;		  0200-0DFF = 3K
   2532 U2fc9							;		  0200-11FF = 4K
   2533 U2fc9							;		  0200-13FF = 4.5K
   2534 U2fc9							;
   2535 U2fc9				  -	      if	FIXED
   2536 U2fc9				  -	      org	$2000
   2537 U2fc9					      endif
   2538 U2fc9
   2539 U2fc9		       2f c9	   FreeMemStart equ	*
   2540 U2fc9							;/*
   2541 U2fc9							;	if	CTMON65 || XKIM
   2542 U2fc9							;		SEG Code
   2543 U2fc9							;		org	AutoRun
   2544 U2fc9							;		dw	TBasicCold
   2545 U2fc9							;	endif
   2546 U2fc9							;*/
   2547 U2fc9					      end
