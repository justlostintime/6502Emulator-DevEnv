------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2cd6				   input      processor	6502
      2 U2cd6 ????						;=====================================================
      3 U2cd6 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2cd6 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2cd6 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2cd6 ????						;
      7 U2cd6 ????						; While working on the Corsham Technologies KIM Clone
      8 U2cd6 ????						; project, I wanted to include a TINY BASIC since that
      9 U2cd6 ????						; was a highly desirable feature of early computers.
     10 U2cd6 ????						;
     11 U2cd6 ????						; Rather than negotiating copyright issues for
     12 U2cd6 ????						; existing BASICs, I decided to just write one from
     13 U2cd6 ????						; scratch.
     14 U2cd6 ????						;
     15 U2cd6 ????						; 10/07/2017
     16 U2cd6 ????						;
     17 U2cd6 ????						; This implements a stripped down Tiny BASIC
     18 U2cd6 ????						; interpreter using the Interpretive Language (IL)
     19 U2cd6 ????						; method as described in the first few issues of
     20 U2cd6 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2cd6 ????						; to write various languages simply by changing the
     22 U2cd6 ????						; IL code rather than the interpreter itself.
     23 U2cd6 ????						;
     24 U2cd6 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2cd6 ????						;		* Fixed major bug in findLine that
     26 U2cd6 ????						;		  caused corrupted lines, crashes, etc.
     27 U2cd6 ????						;		* If no parameter given to RND, assume
     28 U2cd6 ????						;		  32766.
     29 U2cd6 ????						;		* No more error 5 when a program
     30 U2cd6 ????						;		  reaches the end without an END.
     31 U2cd6 ????						;
     32 U2cd6 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2cd6 ????						;		 * Unexpanded version to play with everything
     34 U2cd6 ????						;		 * Add some usefull system level functions
     35 U2cd6 ????						;		 * allow a larger number of tiny basic formats
     36 U2cd6 ????						;		 * Add byte at start of line holding length
     37 U2cd6 ????						;		   for faster execution of goto and gosub
     38 U2cd6 ????						;		 * Re-added gosub
     39 U2cd6 ????						;		 * allow ; or , at end if print stmt
     40 U2cd6 ????						;		   without CRLF being added.
     41 U2cd6 ????						;		 * Added extended function erase to
     42 U2cd6 ????						;		   use the extended ctmon65 rm file
     43 U2cd6 ????						;		 * Fix quoted text to not have to backtrack
     44 U2cd6 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2cd6 ????						;		 * Add concurrency features
     46 U2cd6 ????						;
     47 U2cd6 ????						; www.corshamtech.com
     48 U2cd6 ????						; bob@corshamtech.com
     49 U2cd6 ????						; JustLostInTime@gmail.com
     50 U2cd6 ????						;
     51 U2cd6 ????						;=====================================================
     52 U2cd6 ????						;
     53 U2cd6 ????						; Create TRUE and FALSE values for conditionals.
     54 U2cd6 ????						;
     55 U2cd6 ????
     56 U2cd6 ????	       00 00	   FALSE      equ	0
     57 U2cd6 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2cd6 ????						;
     59 U2cd6 ????						;---------------------------------------------------------
     60 U2cd6 ????						; One of these must be set to indicate which environment
     61 U2cd6 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2cd6 ????						; environments:
     63 U2cd6 ????						;
     64 U2cd6 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2cd6 ????						; more K of RAM.
     66 U2cd6 ????						;
     67 U2cd6 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2cd6 ????						; which enhances, without replacing, the standard KIM
     69 U2cd6 ????						; monitor.  It gives access to routines to save/load files
     70 U2cd6 ????						; to a micro SD card.
     71 U2cd6 ????						;
     72 U2cd6 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2cd6 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2cd6 ????						; easily be ported to other systems.  It has support for
     75 U2cd6 ????						; using a micro SD card for file storage/retrieval.
     76 U2cd6 ????						;
     77 U2cd6 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2cd6 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2cd6 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2cd6 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2cd6 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2cd6 ????						;
     83 U2cd6 ????						;   Need to define some macros for the dasm assembler
     84 U2cd6 ????						;
     85 U2cd6 ????				      MACRO	dw
     86 U2cd6 ????				      .word	{0}
     87 U2cd6 ????				      ENDM
     88 U2cd6 ????
     89 U2cd6 ????				      MACRO	db
     90 U2cd6 ????				      .byte	{0}
     91 U2cd6 ????				      ENDM
     92 U2cd6 ????
     93 U2cd6 ????						;
     94 U2cd6 ????						; If set, include disk functions.
     95 U2cd6 ????						;
     96 U2cd6 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2cd6 ????						;
     98 U2cd6 ????						; If ILTRACE is set then dump out the address of every
     99 U2cd6 ????						; IL opcode before executing it.
    100 U2cd6 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2cd6 ????						;
    102 U2cd6 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2cd6 ????						;
    104 U2cd6 ????						; If FIXED is set, put the IL code and the user
    105 U2cd6 ????						; program space at fixed locations in memory.	This is
    106 U2cd6 ????						; meant only for debugging.
    107 U2cd6 ????						;
    108 U2cd6 ????	       00 00	   FIXED      equ	FALSE
    109 U2cd6 ????						;
    110 U2cd6 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2cd6 ????						; BASIC, so keep this small!
    112 U2cd6 ????						;
    113 U2cd6 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2cd6 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2cd6 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2cd6 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2cd6 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2cd6 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2cd6 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2cd6 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2cd6 ????						;
    122 U2cd6 ????						; Gosub entry types
    123 U2cd6 ????
    124 U2cd6 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2cd6 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2cd6 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2cd6 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2cd6 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2cd6 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2cd6 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2cd6 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2cd6 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2cd6 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2cd6 ????						;
    135 U2cd6 ????						; Common ASCII constants
    136 U2cd6 ????						;
    137 U2cd6 ????	       00 07	   BEL	      equ	$07
    138 U2cd6 ????	       00 08	   BS	      equ	$08
    139 U2cd6 ????	       00 09	   TAB	      equ	$09
    140 U2cd6 ????	       00 0a	   LF	      equ	$0A
    141 U2cd6 ????	       00 0d	   CR	      equ	$0D
    142 U2cd6 ????	       00 22	   quote      equ	$22
    143 U2cd6 ????	       00 20	   SPACE      equ	$20
    144 U2cd6 ????	       00 2c	   COMMA      equ	',
    145 U2cd6 ????	       00 3b	   SEMICOLON  equ	';
    146 U2cd6 ????	       00 3a	   COLON      equ	':
    147 U2cd6 ????	       00 24	   DOLLAR     equ	'$
    148 U2cd6 ????						;
    149 U2cd6 ????						; These are error codes
    150 U2cd6 ????						;
    151 U2cd6 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2cd6 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2cd6 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2cd6 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2cd6 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2cd6 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2cd6 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2cd6 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2cd6 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2cd6 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2cd6 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2cd6 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2cd6 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2cd6 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2cd6 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2cd6 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2cd6 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2cd6 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2cd6 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2cd6 ????						;
    171 U2cd6 ????						;=====================================================
    172 U2cd6 ????						; Zero page storage.
    173 U2cd6 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  235e ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       1b c2	   CRLF       equ	tbcrlf
    307  0206		       13 24	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       13 41	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 f1 1c    cold2      jsr	SetOutConsole
    314  0209		       20 fe 1c 	      jsr	SetInConsole
    315  020c		       20 41 13 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    319  0243							;
    320  0243		       20 cd 13 	      jsr	MemInit	;setup the free space available
    321  0246
    322  0246		       a9 01	   calcstack  lda	#1
    323  0248		       8d 72 24 	      sta	taskCounter	; Initialize number of tasks to 1
    324  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  024d		       8d 74 23 	      sta	taskTable	; mark the main task as active
    326  0250		       20 ba 14 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  0253		       a9 92		      lda	#IL&$ff
    328  0255		       85 43		      sta	ILPC
    329  0257		       a9 1e		      lda	#IL>>8
    330  0259		       85 44		      sta	ILPC+1
    331  025b							;
    332  025b							;		  lda	  ProgramStart		     ; user prog
    333  025b							;		  sta	  ProgramEnd
    334  025b							;		  lda	  ProgramStart+1
    335  025b							;		  sta	  ProgramEnd+1
    336  025b							;
    337  025b							;  Init time slices defaults
    338  025b		       a9 02		      lda	#TASKCYCLESHIGH
    339  025d		       8d 71 24 	      sta	taskResetValue+1
    340  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  0262		       8d 70 24 	      sta	taskResetValue
    342  0265							;
    343  0265							; Initialize the pseudo-random number sequence...
    344  0265							;
    345  0265		       a9 5a		      lda	#$5a
    346  0267		       8d bc 2c 	      sta	rtemp1
    347  026a		       a9 9d		      lda	#%10011101
    348  026c		       8d be 2c 	      sta	random
    349  026f		       a9 5b		      lda	#%01011011
    350  0271		       8d bf 2c 	      sta	random+1
    351  0274							;
    352  0274							;   Insert a Basic irq handler for the basic Language
    353  0274		       a9 81		      lda	#ServiceIrq&$ff
    354  0276		       8d 00 df 	      sta	IRQvec
    355  0279		       a9 02		      lda	#ServiceIrq>>8
    356  027b		       8d 01 df 	      sta	IRQvec+1
    357  027e		       4c a6 02 	      jmp	coldtwo
    358  0281
    359  0281							;
    360  0281							; This is the Basic IRQ handler
    361  0281		       48	   ServiceIrq pha
    362  0282		       ad 6f 23 	      lda	IRQStatus
    363  0285		       f0 0a		      BEQ	RetIrq
    364  0287		       ad 70 23 	      lda	IRQPending
    365  028a		       d0 05		      bne	RetIrq
    366  028c		       a9 01		      lda	#1
    367  028e		       8d 70 23 	      sta	IRQPending
    368  0291		       68	   RetIrq     pla
    369  0292		       40		      rti
    370  0293							;
    371  0293							;
    372  0293							; This is the warm start entry point
    373  0293							;
    374  0293		       20 f1 1c    warm2      jsr	SetOutConsole
    375  0296		       20 fe 1c 	      jsr	SetInConsole
    376  0299		       20 c2 1b 	      jsr	CRLF
    377  029c		       ad b9 2c 	      lda	errGoto
    378  029f		       85 43		      sta	ILPC
    379  02a1		       ad ba 2c 	      lda	errGoto+1
    380  02a4		       85 44		      sta	ILPC+1
    381  02a6							;
    382  02a6							; And continue with both starts here
    383  02a6							;
    384  02a6				   coldtwo
    385  02a6							;
    386  02a6							; The ILTrace flag is now run-time settable.
    387  02a6							;
    388  02a6		       a9 00		      lda	#ILTRACE&$ff
    389  02a8		       85 40		      sta	ILTrace
    390  02aa							;
    391  02aa
    392  02aa		       a9 00		      lda	#0
    393  02ac		       85 5b		      sta	RunMode
    394  02ae		       8d 2f 2c 	      sta	LINBUF
    395  02b1
    396  02b1							; Clear everything from the stacks
    397  02b1
    398  02b1		       8d ca 2c 	      sta	taskIOPending	; No one waiting for io
    399  02b4		       8d cb 2c 	      sta	taskRDPending	; No one waiting for bg io
    400  02b7
    401  02b7		       20 2d 15 	      jsr	taskReset
    402  02ba							;
    403  02ba		       a9 2f		      lda	#LINBUF&$ff
    404  02bc		       85 4f		      sta	CURPTR
    405  02be		       a9 2c		      lda	#LINBUF>>8
    406  02c0		       85 50		      sta	CURPTR+1	;fall through...
    407  02c2
    408  02c2							;=====================================================
    409  02c2							; This is the top of the IL interpreter.  This fetches
    410  02c2							; and executes the instruction currently pointed to
    411  02c2							; by ILPC and adjusts ILPC to point to the next
    412  02c2							; instruction to execute.
    413  02c2							;
    414  02c2		       ce 6e 24    NextIL     dec	taskCurrentCycles
    415  02c5		       d0 03		      bne	NextIlNow
    416  02c7		       20 56 15 	      jsr	iTaskSwitch	;check for a task switch
    417  02ca		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02cc		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02ce
    420  02ce		       20 4e 1c 	      jsr	dbgLine	;Print the IL trace information
    421  02d1
    422  02d1		       a4 51	   NextIL2    ldy	CUROFF
    423  02d3		       20 b9 1b 	      jsr	SkipSpaces
    424  02d6		       84 51		      sty	CUROFF
    425  02d8							;Task IO Management
    426  02d8		       ad cb 2c 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02db		       f0 08		      beq	NextILStr
    428  02dd		       20 09 1a 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02e0		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02e2		       ce cb 2c 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02e5							;
    432  02e5		       20 8c 18    NextILStr  jsr	getILByte
    433  02e8							;
    434  02e8							; When the handler is called, these are the conditions
    435  02e8							; of several important items:
    436  02e8							;
    437  02e8							;    (ILPC) will point to the byte AFTER the IL
    438  02e8							;    opcode being executed.
    439  02e8							;
    440  02e8							;    (CURPTR),CUROFF will point to the start of the
    441  02e8							;    next word in the input buffer.  Ie, the next word
    442  02e8							;    in the user program.
    443  02e8							;
    444  02e8		       0a		      asl
    445  02e9		       c9 cc		      cmp	#ILTBLend-ILTBL+2
    446  02eb		       90 33		      bcc	ILgood
    447  02ed							;
    448  02ed							; This handles an illegal IL opcode.  This is serious
    449  02ed							; and there's no way to recover.
    450  02ed							;
    451  02ed		       20 41 13    ILbad      jsr	puts
      0  02f0					      db	CR,LF
      1  02f0		       0d 0a		      .byte.b	CR,LF
      0  02f2					      db	"Illegal IL "
      1  02f2		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02fd					      db	0
      1  02fd		       00		      .byte.b	0
    455  02fe							;
    456  02fe							; Well this is awkward, we need to back up the IL
    457  02fe							; by one since it no longer points to the current
    458  02fe							; opcode.
    459  02fe							;
    460  02fe		       20 99 18 	      jsr	decIL
    461  0301							;
    462  0301		       a0 00		      ldy	#0
    463  0303		       b1 43		      lda	(ILPC),y
    464  0305		       20 24 13 	      jsr	OUTHEX
    465  0308		       20 41 13 	      jsr	puts
      0  030b					      db	" at ",0
      1  030b		       20 61 74 20*	      .byte.b	" at ",0
    467  0310		       a5 44		      lda	ILPC+1
    468  0312		       20 24 13 	      jsr	OUTHEX
    469  0315		       a5 43		      lda	ILPC
    470  0317		       20 24 13 	      jsr	OUTHEX
    471  031a		       20 c2 1b 	      jsr	CRLF
    472  031d		       4c 03 f0 	      jmp	MONITOR
    473  0320							;
    474  0320							; Just jump to the address (ILPC),y.  Have to do
    475  0320							; some goofy stuff.
    476  0320							;
    477  0320		       a8	   ILgood     tay		;move index into Y
    478  0321		       b9 2e 03 	      lda	ILTBL,y
    479  0324		       85 59		      sta	dpl
    480  0326		       b9 2f 03 	      lda	ILTBL+1,y
    481  0329		       85 5a		      sta	dpl+1
    482  032b		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  032e							;
    484  032e							;=====================================================
    485  032e							; This is the IL jump table.  The IL opcode is
    486  032e							; mulitplied by two, then looked-up in this table.
    487  032e							; There is absolutely nothing special about the order
    488  032e							; of entries here... they all decode at exactly the
    489  032e							; same speed.	However the entry number must match the
    490  032e							; values in IL.inc.
    491  032e							;
    492  032e				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  032e					      include	"ilvectortable.asm"
      1  032e					      seg	Code
      2  032e
      0  032e					      dw	iXINIT	;0
      1  032e		       30 04		      .word.w	iXINIT
      0  0330					      dw	iDONE	;1
      1  0330		       4b 04		      .word.w	iDONE
      0  0332					      dw	iPRS	;2
      1  0332		       67 04		      .word.w	iPRS
      0  0334					      dw	iPRN	;3
      1  0334		       71 04		      .word.w	iPRN
      0  0336					      dw	iSPC	;4
      1  0336		       7a 04		      .word.w	iSPC
      0  0338					      dw	iNLINE	;5
      1  0338		       2c 09		      .word.w	iNLINE
      0  033a					      dw	iNXT	;6
      1  033a		       82 04		      .word.w	iNXT
      0  033c					      dw	iXFER	;7
      1  033c		       ae 04		      .word.w	iXFER
      0  033e					      dw	iSAV	;8
      1  033e		       db 04		      .word.w	iSAV
      0  0340					      dw	iRSTR	;9
      1  0340		       1e 05		      .word.w	iRSTR
      0  0342					      dw	iCMPR	;10
      1  0342		       53 05		      .word.w	iCMPR
      0  0344					      dw	iINNUM	;11
      1  0344		       d4 05		      .word.w	iINNUM
      0  0346					      dw	iFIN	;12
      1  0346		       08 06		      .word.w	iFIN
      0  0348					      dw	iERR	;13
      1  0348		       1c 06		      .word.w	iERR
      0  034a					      dw	iADD	;14
      1  034a		       8c 06		      .word.w	iADD
      0  034c					      dw	iSUB	;15
      1  034c		       a2 06		      .word.w	iSUB
      0  034e					      dw	iNEG	;16
      1  034e		       b8 06		      .word.w	iNEG
      0  0350					      dw	iMUL	;17
      1  0350		       d0 06		      .word.w	iMUL
      0  0352					      dw	iDIV	;18
      1  0352		       10 07		      .word.w	iDIV
      0  0354					      dw	iSTORE	;19
      1  0354		       66 07		      .word.w	iSTORE
      0  0356					      dw	iIND	;20
      1  0356		       7e 07		      .word.w	iIND
      0  0358					      dw	iLST	;21
      1  0358		       ec 07		      .word.w	iLST
      0  035a					      dw	iINIT	;22
      1  035a		       f8 03		      .word.w	iINIT
      0  035c					      dw	iGETLINE	;23
      1  035c		       51 08		      .word.w	iGETLINE
      0  035e					      dw	iINSRT	;24
      1  035e		       68 08		      .word.w	iINSRT
      0  0360					      dw	iRTN	;25
      1  0360		       26 09		      .word.w	iRTN
      0  0362					      dw	MONITOR	;26
      1  0362		       03 f0		      .word.w	MONITOR
      0  0364					      dw	iLIT	;27
      1  0364		       4c 09		      .word.w	iLIT
      0  0366					      dw	iCALL	;28
      1  0366		       32 09		      .word.w	iCALL
      0  0368					      dw	iJMP	;29
      1  0368		       3a 09		      .word.w	iJMP
      0  036a					      dw	iVINIT	;30
      1  036a		       69 09		      .word.w	iVINIT
      0  036c					      dw	iERRGOTO	;31
      1  036c		       6f 09		      .word.w	iERRGOTO
      0  036e					      dw	iTST	;32
      1  036e		       7b 09		      .word.w	iTST
      0  0370					      dw	iTSTV	;33
      1  0370		       5c 0a		      .word.w	iTSTV
      0  0372					      dw	iTSTL	;34
      1  0372		       db 0a		      .word.w	iTSTL
      0  0374					      dw	iTSTN	;35
      1  0374		       f6 0a		      .word.w	iTSTN
      0  0376					      dw	iFREE	;36
      1  0376		       73 0b		      .word.w	iFREE
      0  0378					      dw	iRANDOM	;37
      1  0378		       7c 0b		      .word.w	iRANDOM
      0  037a					      dw	iABS	;38
      1  037a		       4d 0c		      .word.w	iABS
     42  037c							;
     43  037c							; Disk functions.  There must be pointers
     44  037c							; to functions even if no disk is supported.
     45  037c							; Makes things easier in IL.inc.
     46  037c							;
     47  037c					      if	DISK_ACCESS
      0  037c					      dw	iOPENREAD	;39
      1  037c		       6a 1d		      .word.w	iOPENREAD
      0  037e					      dw	iOPENWRITE	;40
      1  037e		       be 1d		      .word.w	iOPENWRITE
      0  0380					      dw	iDCLOSE	;41
      1  0380		       45 1e		      .word.w	iDCLOSE
      0  0382					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0382		       dd 1d		      .word.w	iDGETLINE
      0  0384					      dw	iDLIST	;43 Did you remeber your towel?
      1  0384		       3f 1e		      .word.w	iDLIST
      0  0386					      dw	iDDIR	;44
      1  0386		       1a 1e		      .word.w	iDDIR
      0  0388					      dw	iRMFILE	;45
      1  0388		       98 1d		      .word.w	iRMFILE
     55  038a				  -	      else
     56  038a				  -	      dw	NextIL	;39
     57  038a				  -	      dw	NextIL	;40
     58  038a				  -	      dw	NextIL	;41
     59  038a				  -	      dw	NextIL	;42
     60  038a				  -	      dw	NextIL	;43
     61  038a				  -	      dw	NextIL	;44
     62  038a				  -	      dw	NextIL	;45
     63  038a					      endif
     64  038a							;
      0  038a					      dw	iCLEARSCREEN	;46
      1  038a		       11 1d		      .word.w	iCLEARSCREEN
      0  038c					      dw	iPOKEMEMORY	;47
      1  038c		       da 0b		      .word.w	iPOKEMEMORY
      0  038e					      dw	iPEEKMEMORY	;48
      1  038e		       ef 0b		      .word.w	iPEEKMEMORY
      0  0390					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0390		       c2 09		      .word.w	iTSTLET
      0  0392					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0392		       00 0a		      .word.w	iTSTDONE
      0  0394					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0394		       1c 0c		      .word.w	iGETCHAR
      0  0396					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0396		       30 0c		      .word.w	iPUTCHAR
      0  0398					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0398		       05 0c		      .word.w	iCallFunc
      0  039a					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  039a		       a4 05		      .word.w	iBranch
      0  039c					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  039c		       a5 09		      .word.w	iTSTStr
      0  039e					      dw	iSetIrq	;56	   sets the irq handler
      1  039e		       ca 0c		      .word.w	iSetIrq
      0  03a0					      dw	iTstIrq	;57	   test if irq is pending
      1  03a0		       3b 0b		      .word.w	iTstIrq
      0  03a2					      dw	iRET	;58	   return from interupt
      1  03a2		       0c 05		      .word.w	iRET
      0  03a4					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03a4		       eb 05		      .word.w	iINSTR
      0  03a6					      dw	iMOD	;60	   returns remainder of division
      1  03a6		       19 07		      .word.w	iMOD
      0  03a8					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a8		       aa 15		      .word.w	iTaskSet
      0  03aa					      dw	iETask	;62	   Terminates a task
      1  03aa		       d5 16		      .word.w	iETask
      0  03ac					      dw	iNTask	;63	   goto next task
      1  03ac		       88 16		      .word.w	iNTask
      0  03ae					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03ae		       93 07		      .word.w	iArray
      0  03b0					      dw	iTaskKill	;65	   kill a running task
      1  03b0		       80 16		      .word.w	iTaskKill
      0  03b2					      dw	iTaskStat	;66	   return the state of a task PID
      1  03b2		       54 16		      .word.w	iTaskStat
      0  03b4					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03b4		       3b 0c		      .word.w	iHexOut
      0  03b6					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b6		       c0 05		      .word.w	iReadComplete
      0  03b8					      dw	iReadStart	;69	   Called to start a background read request
      1  03b8		       b6 05		      .word.w	iReadStart
      0  03ba					      dw	iStartIO	;70	   Lock task until io complete
      1  03ba		       b8 16		      .word.w	iStartIO
      0  03bc					      dw	iEndIO	;71	   release task lock for io
      1  03bc		       be 16		      .word.w	iEndIO
      0  03be					      dw	iLogNot	;72	   Logical not
      1  03be		       a6 0c		      .word.w	iLogNot
      0  03c0					      dw	iLogOr	;73	   Logical Or
      1  03c0		       7c 0c		      .word.w	iLogOr
      0  03c2					      dw	iLogAnd	;74	   Logical And
      1  03c2		       67 0c		      .word.w	iLogAnd
      0  03c4					      dw	iLogXor	;75	   Logical Xor
      1  03c4		       91 0c		      .word.w	iLogXor
      0  03c6					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c6		       93 16		      .word.w	iWTASK
      0  03c8					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c8		       c9 16		      .word.w	iTASKPID
      0  03ca					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03ca		       06 0d		      .word.w	iTRACEPROG
      0  03cc					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03cc		       cf 1b		      .word.w	idbgBasic
      0  03ce					      dw	iIPCS	;80	   Sending a msg to a task
      1  03ce		       8b 17		      .word.w	iIPCS
      0  03d0					      dw	iIPCR	;81	   Recieve a message from a task
      1  03d0		       a2 17		      .word.w	iIPCR
      0  03d2					      dw	iIPCC	;82	   Check if any message available for task
      1  03d2		       b6 17		      .word.w	iIPCC
      0  03d4					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03d4		       c3 17		      .word.w	iIPCIO
      0  03d6					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d6		       22 14		      .word.w	iPushMathStack
      0  03d8					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d8		       52 14		      .word.w	iPopMathStack
      0  03da					      dw	iSaveMathStack	;86	   Save all math info
      1  03da		       6f 14		      .word.w	iSaveMathStack
      0  03dc					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03dc		       8e 14		      .word.w	iRestoreMathStack
      0  03de					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03de		       3f 14		      .word.w	iIncParmCount
      0  03e0					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03e0		       f5 16		      .word.w	iTaskGetMathStack
      0  03e2					      dw	iTaskEnable	;90	   enable a suspended task
      1  03e2		       22 16		      .word.w	iTaskEnable
      0  03e4					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03e4		       3c 16		      .word.w	iTaskSuspend
      0  03e6					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e6		       0f 17		      .word.w	iTaskPutMathPtr
      0  03e8					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e8		       53 0a		      .word.w	iTSTVT
      0  03ea					      dw	iSetR2	;94
      1  03ea		       44 09		      .word.w	iSetR2
      0  03ec					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03ec		       ea 04		      .word.w	iStk2Tmp
      0  03ee					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03ee		       fb 04		      .word.w	iTmp2Stk
      0  03f0					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03f0		       e1 09		      .word.w	iTSTBYTE
      0  03f2					      dw	iINCVAR	;98	   Increment variable
      1  03f2		       25 0a		      .word.w	iINCVAR
      0  03f4					      dw	iDECVAR	;99	   Decrement variable
      1  03f4		       3d 0a		      .word.w	iDECVAR
      0  03f6					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f6		       1e 17		      .word.w	iSLICE
    120  03f8
------- FILE mytb.asm
    494  03f8		       03 f8	   ILTBLend   equ	*
    495  03f8							;
    496  03f8							;=====================================================
    497  03f8							;=====================================================
    498  03f8							;=====================================================
    499  03f8							; This marks the start of the handlers for IL opcodes.
    500  03f8							;=====================================================
    501  03f8							;=====================================================
    502  03f8							;=====================================================
    503  03f8							;
    504  03f8							;
    505  03f8		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03fa		       85 47		      sta	ILSTACKPTR
    507  03fc		       85 4a		      sta	MATHSTACKPTR
    508  03fe		       85 4d		      sta	GOSUBSTACKPTR
    509  0400		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  0402		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  0404							;
    512  0404		       ad cc 2c 	      lda	ProgramStart	;user prog
    513  0407		       85 4f		      sta	CURPTR
    514  0409		       8d 75 23 	      sta	taskTable+1
    515  040c		       8d ce 2c 	      sta	ProgramEnd
    516  040f		       ad cd 2c 	      lda	ProgramStart+1
    517  0412		       85 50		      sta	CURPTR+1
    518  0414		       8d 76 23 	      sta	taskTable+2
    519  0417		       8d cf 2c 	      sta	ProgramEnd+1
    520  041a		       a9 80		      lda	#TASKACTIVE
    521  041c		       8d 74 23 	      sta	taskTable	;Mark the first slot as active
    522  041f		       a9 01		      lda	#1
    523  0421		       8d 72 24 	      sta	taskCounter	;there is always one task / Main task
    524  0424		       ad 70 24 	      lda	taskResetValue
    525  0427		       8d 6e 24 	      sta	taskCurrentCycles	; set up the task switch counts
    526  042a		       ad 71 24 	      lda	taskResetValue+1
    527  042d		       8d 6f 24 	      sta	taskCurrentCycles+1
    528  0430							;
    529  0430							; fall into XINIT...
    530  0430							;
    531  0430							;=====================================================
    532  0430							; This initializes for the start of the next line of
    533  0430							; BASIC text.
    534  0430							;
    535  0430		       78	   iXINIT     sei		;ensure interupts are off
    536  0431		       20 2d 15 	      jsr	taskReset	;Clear the task table
    537  0434		       8d 70 23 	      sta	IRQPending	; reset the irq pending
    538  0437		       8d 6f 23 	      sta	IRQStatus	; Make sure irqs are off
    539  043a
    540  043a		       4c c2 02    goodExit   jmp	NextIL
    541  043d							;
    542  043d							;=====================================================
    543  043d							; This check if the escape key has been entered
    544  043d							; then changes out of run mode. z Set if esc found
    545  043d				   BreakSet
    546  043d		       20 0f f0 	      jsr	ISCHAR
    547  0440		       f0 06		      beq	BreakNo
    548  0442		       20 0e 1d 	      jsr	VGETCH
    549  0445		       c9 1b		      cmp	#$1B
    550  0447		       60		      rts
    551  0448				   BreakNo
    552  0448		       a9 01		      lda	#1
    553  044a		       60		      rts
    554  044b
    555  044b							;
    556  044b
    557  044b							;=====================================================
    558  044b							; Verify there is nothing else on this input line.
    559  044b							; If there is, generate an error.
    560  044b							;
    561  044b		       a4 51	   iDONE      ldy	CUROFF
    562  044d		       20 b9 1b 	      jsr	SkipSpaces
    563  0450		       b1 4f		      lda	(CURPTR),y
    564  0452		       f0 10		      beq	doneadv
    565  0454		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    566  0456		       d0 05		      bne	idoneErr
    567  0458		       84 51		      sty	CUROFF
    568  045a		       4c c2 02 	      jmp	NextIL	; continue on this line
    569  045d
    570  045d				   idoneErr
    571  045d		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  045f		       a9 00		      lda	#0
    573  0461		       4c 1f 06 	      jmp	iErr2
    574  0464							;
    575  0464							; Advance to the next line
    576  0464							;
    577  0464				   doneadv
    578  0464							;		 jsr	 FindNext2
    579  0464		       4c c2 02 	      jmp	NextIL
    580  0467							;
    581  0467							;=====================================================
    582  0467							; Print the string until a closing quote
    583  0467							;
    584  0467		       a4 51	   iPRS       ldy	CUROFF
    585  0469							;
    586  0469							; Odd logic here.  The main loop skipped any leading
    587  0469							; whitespace inside the quoted text, so move back to
    588  0469							; the quote, then move forward again.
    589  0469							;
    590  0469		       20 6b 13 	      jsr	PrtQuoted
    591  046c		       84 51		      sty	CUROFF
    592  046e		       4c c2 02 	      jmp	NextIL
    593  0471							;
    594  0471							;=====================================================
    595  0471							; Pop the top off the stack and print it as a signed
    596  0471							; decimal number.
    597  0471							;
    598  0471		       20 09 1b    iPRN       jsr	popR0
    599  0474		       20 72 12 	      jsr	PrintDecimal
    600  0477		       4c c2 02 	      jmp	NextIL
    601  047a							;
    602  047a							;=====================================================
    603  047a							; Space to next zone.	Currently the code does not
    604  047a							; keep track of which column the output is on, so
    605  047a							; just print a tab.
    606  047a							;
    607  047a		       a9 09	   iSPC       lda	#TAB
    608  047c		       20 0b 1d 	      jsr	VOUTCH
    609  047f		       4c c2 02 	      jmp	NextIL
    610  0482							;
    611  0482							;=====================================================
    612  0482							; If in immediate mode, jump to the address following
    613  0482							; the NXT instruction.  Else move to the next line of
    614  0482							; user code and continue.
    615  0482							;
    616  0482		       a5 5b	   iNXT       lda	RunMode
    617  0484		       d0 03		      bne	iNxtRun	;in run mode
    618  0486							;
    619  0486							; Get address and jump to it.
    620  0486							;
    621  0486		       4c 3a 09 	      jmp	iJMP
    622  0489							;
    623  0489				   iNxtRun
    624  0489		       a4 51		      ldy	CUROFF
    625  048b		       20 b9 1b 	      jsr	SkipSpaces
    626  048e		       b1 4f		      lda	(CURPTR),y
    627  0490		       c9 3a		      cmp	#COLON
    628  0492		       d0 09		      bne	iNxtRunGo
    629  0494		       c8		      iny
    630  0495		       20 b9 1b 	      jsr	SkipSpaces
    631  0498		       84 51		      sty	CUROFF
    632  049a		       4c a8 04 	      jmp	iNxtRun2
    633  049d
    634  049d				   iNxtRunGo
    635  049d		       20 16 19 	      jsr	FindNextLine
    636  04a0		       20 2a 19 	      jsr	AtEnd
    637  04a3		       d0 03		      bne	iNxtRun2	;not at end
    638  04a5							;
    639  04a5							; At the end of the program.  Pretend an END statement
    640  04a5							; was found.
    641  04a5							;
    642  04a5		       4c 08 06    iFINv      jmp	iFIN
    643  04a8							;
    644  04a8		       20 88 18    iNxtRun2   jsr	getILWord	;ignore next word
    645  04ab		       4c c2 02 	      jmp	NextIL
    646  04ae							;
    647  04ae							;=====================================================
    648  04ae							; XFER takes the number on top of the stack and looks
    649  04ae							; for that line in the program, or the next line
    650  04ae							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04ae							; find the next one after that.
    652  04ae							;
    653  04ae		       20 09 1b    iXFER      jsr	popR0
    654  04b1		       20 d1 18 	      jsr	findLine
    655  04b4		       20 2a 19    iXFER2     jsr	AtEnd	;at end of user program?
    656  04b7		       f0 ec		      beq	iFINv
    657  04b9		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    658  04bb		       84 51		      sty	CUROFF
    659  04bd		       a9 ff		      lda	#$ff
    660  04bf		       85 5b		      sta	RunMode
    661  04c1							;
    662  04c1							; Transfer IL to STMT.  I don't like having this
    663  04c1							; hard-coded; fix it.
    664  04c1							;
    665  04c1		       a9 a0		      lda	#STMT&$ff
    666  04c3		       85 43		      sta	ILPC
    667  04c5		       a9 1e		      lda	#STMT>>8
    668  04c7		       85 44		      sta	ILPC+1
    669  04c9		       4c c2 02 	      jmp	NextIL
    670  04cc							;
    671  04cc							; Run
    672  04cc							;
    673  04cc				   iXferok
    674  04cc		       a9 ff		      lda	#$ff
    675  04ce		       85 5b		      sta	RunMode	;we're running
    676  04d0							;
    677  04d0							; Need a more elegant way to do this
    678  04d0							;
    679  04d0		       a9 a0		      lda	#STMT&$ff
    680  04d2		       85 43		      sta	ILPC
    681  04d4		       a9 1e		      lda	#STMT>>8
    682  04d6		       85 44		      sta	ILPC+1
    683  04d8		       4c c2 02 	      jmp	NextIL
    684  04db							;
    685  04db							;=====================================================
    686  04db							; Save the pointer to the next line to the call stack.
    687  04db							;
    688  04db		       20 9f 1a    iSAV       jsr	pushLN
    689  04de		       b0 03		      bcs	iSAVErr
    690  04e0		       4c c2 02 	      jmp	NextIL
    691  04e3
    692  04e3		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04e5		       a9 00	   iSAVErr2   lda	#0
    694  04e7		       4c 1f 06 	      jmp	iErr2
    695  04ea							;====================================================
    696  04ea							; Move stack top to and from temp area
    697  04ea				   iStk2Tmp
    698  04ea		       20 09 1b 	      jsr	popR0
    699  04ed		       a5 52		      lda	R0
    700  04ef		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04f1		       91 41		      sta	(VARIABLES),y
    702  04f3		       c8		      iny
    703  04f4		       a5 53		      lda	R0+1
    704  04f6		       91 41		      sta	(VARIABLES),y
    705  04f8		       4c c2 02 	      jmp	NextIL
    706  04fb
    707  04fb		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  04fd		       b1 41		      lda	(VARIABLES),y
    709  04ff		       85 52		      sta	R0
    710  0501		       c8		      iny
    711  0502		       b1 41		      lda	(VARIABLES),y
    712  0504		       85 53		      sta	R0+1
    713  0506		       20 85 1a 	      jsr	pushR0
    714  0509		       4c c2 02 	      jmp	NextIL
    715  050c							;
    716  050c							;=====================================================
    717  050c							; Pop the next line from the call stack.
    718  050c							;
    719  050c		       20 c4 1a    iRET       jsr	popLN
    720  050f		       b0 d2		      bcs	iSAVErr
    721  0511		       a0 03		      ldy	#3
    722  0513		       84 51		      sty	CUROFF
    723  0515		       a9 00		      lda	#0
    724  0517		       8d 70 23 	      sta	IRQPending
    725  051a		       58		      cli
    726  051b		       4c c2 02 	      jmp	NextIL
    727  051e							;
    728  051e							;=====================================================
    729  051e							; Return from GOSUB function
    730  051e							;
    731  051e		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    732  0520		       f0 0f		      beq	iRSTRNoValue
    733  0522		       a5 58		      lda	R2
    734  0524		       85 56		      sta	MQ
    735  0526		       88		      dey
    736  0527		       b1 4b		      lda	(GOSUBSTACK),y
    737  0529		       c9 81		      cmp	#GOSUB_RTN_VALUE
    738  052b		       d0 04		      bne	iRSTRNoValue
    739  052d		       a9 01		      lda	#1
    740  052f		       d0 02		      bne	iRSTRExit
    741  0531				   iRSTRNoValue
    742  0531		       a9 00		      lda	#0
    743  0533				   iRSTRExit
    744  0533		       85 58		      sta	R2
    745  0535		       20 c4 1a 	      jsr	popLN
    746  0538		       b0 06		      bcs	iRSTRErr
    747  053a		       20 58 14 	      jsr	PopMathStackNow
    748  053d		       4c c2 02 	      jmp	NextIL
    749  0540
    750  0540		       ad 73 23    iRSTRErr   lda	taskPtr	; Check if this is task zero
    751  0543		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    752  0545		       a5 56		      lda	MQ
    753  0547		       d0 03		      bne	taskRet
    754  0549		       20 26 1d 	      jsr	pushFalse	; the result code by default is 0
    755  054c				   taskRet
    756  054c		       4c d5 16 	      jmp	iETask	; not task zero then do a task end instead
    757  054f				   taskZeroEnd
    758  054f		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    759  0551		       d0 92		      bne	iSAVErr2
    760  0553							;
    761  0553							;=====================================================
    762  0553							; Compare items on stack.  Okay, so on input there are
    763  0553							; three things on the stack
    764  0553							;
    765  0553							;    EXPR2 <- Top of stack
    766  0553							;    OP    <- relational operator, next on stack
    767  0553							;    EXPR1 <- last item on stack
    768  0553							;
    769  0553							; Comparison is: EXPR1 <operator> EXPR2
    770  0553							;
    771  0553							; Operator is one of...
    772  0553							;
    773  0553							;    2 is =
    774  0553							;    1 is <
    775  0553							;    3 is <=
    776  0553							;    5 is <>
    777  0553							;    4 is >
    778  0553							;    6 is >=
    779  0553							;
    780  0553							; Those are bit-mapped:
    781  0553							;
    782  0553							;    xxxxxGEL
    783  0553							;
    784  0553							;    G = Greater than
    785  0553							;    E = Equal
    786  0553							;    L = Less than
    787  0553							;
    788  0553							; If the comparison is false, do a NXT, ie, move to the
    789  0553							; next line and continue.  If true, continue executing
    790  0553							; on this line.
    791  0553							;
    792  0553		       00 01	   REL_LT     equ	%001
    793  0553		       00 02	   REL_EQUAL  equ	%010
    794  0553		       00 04	   REL_GT     equ	%100
    795  0553							;
    796  0553		       20 21 1b    iCMPR      jsr	popR1
    797  0556		       20 38 1b 	      jsr	popMQ	;operator in MQ
    798  0559		       20 09 1b 	      jsr	popR0
    799  055c		       20 65 05 	      jsr	iCMPRsub
    800  055f		       20 85 1a 	      jsr	pushR0
    801  0562		       4c c2 02 	      jmp	NextIL
    802  0565							;
    803  0565							; See if they are equal or not
    804  0565							;
    805  0565				   iCMPRsub		; Called by internal functions
    806  0565
    807  0565		       a5 52		      lda	R0
    808  0567		       c5 54		      cmp	R1
    809  0569		       d0 0a		      bne	iCMPRnoteq	;try not equal
    810  056b		       a5 53		      lda	R0+1
    811  056d		       c5 55		      cmp	R1+1
    812  056f		       d0 04		      bne	iCMPRnoteq
    813  0571							;
    814  0571							; Equal, set the flag in MQ+1
    815  0571							;
    816  0571		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    817  0573		       d0 14		      bne	iCMPcom	;Exit it is equal
    818  0575							;
    819  0575							; See if EXPR1 (R0) < EXPR2 (R1)
    820  0575							; See www.6502.org/tutorials/compare_beyond.html
    821  0575							;
    822  0575				   iCMPRnoteq
    823  0575		       a5 52		      lda	R0
    824  0577		       c5 54		      cmp	R1
    825  0579		       a5 53		      lda	R0+1
    826  057b		       e5 55		      sbc	R1+1
    827  057d		       50 02		      bvc	iCMPR_2
    828  057f		       49 80		      eor	#$80
    829  0581		       30 04	   iCMPR_2    bmi	iCMPlt
    830  0583		       a9 04		      lda	#REL_GT
    831  0585		       d0 02		      bne	iCMPcom
    832  0587		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    833  0589
    834  0589		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    835  058b							;
    836  058b							; Now compare the end result with what the caller
    837  058b							; was looking for.
    838  058b							;
    839  058b		       25 56		      and	MQ
    840  058d		       f0 0c		      beq	iCMPno	; no match
    841  058f		       a9 ff		      lda	#$FF	; true is $ffff
    842  0591		       85 52		      sta	R0
    843  0593		       85 53		      sta	R0+1
    844  0595		       d0 0c		      bne	iCMPDone
    845  0597							;
    846  0597							; R0 > R1
    847  0597							;
    848  0597		       a9 04	   iCMPgt     lda	#REL_GT
    849  0599		       d0 ee		      bne	iCMPcom
    850  059b				   iCMPno
    851  059b		       a9 00		      lda	#0
    852  059d		       85 52		      sta	R0
    853  059f		       a9 00		      lda	#0
    854  05a1		       85 53		      sta	R0+1
    855  05a3
    856  05a3				   iCMPDone
    857  05a3		       60		      rts
    858  05a4
    859  05a4							;
    860  05a4							; if Not a match, so jump to the next line of code.
    861  05a4							; Branches based upon value on top of the stack
    862  05a4				   iBranch
    863  05a4		       20 09 1b 	      jsr	popR0
    864  05a7		       a5 52		      lda	R0
    865  05a9		       05 53		      ora	R0+1
    866  05ab		       f0 03		      beq	iBranchFalse	; not true
    867  05ad		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    868  05b0							;
    869  05b0				   iBranchFalse
    870  05b0		       20 16 19 	      jsr	FindNextLine
    871  05b3		       4c b4 04 	      jmp	iXFER2
    872  05b6							;
    873  05b6							;=====================================================
    874  05b6							; Start a read of data in background
    875  05b6				   iReadStart
    876  05b6		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05b8		       a6 01		      ldx	1	; Indicate to start read in background
    878  05ba		       20 a2 19 	      jsr	GetLine	; Call the getline to start read
    879  05bd		       4c c2 02 	      jmp	NextIL	; next instruction
    880  05c0							;
    881  05c0							;=====================================================
    882  05c0							; Complete the read and return the curptr, curoff pointing to data
    883  05c0				   iReadComplete
    884  05c0		       20 9f 1a 	      jsr	pushLN
    885  05c3		       90 03		      bcc	iReadOk
    886  05c5		       4c 6c 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    887  05c8				   iReadOk
    888  05c8		       20 c2 19 	      jsr	ReadComplete
    889  05cb		       4c c2 02 	      jmp	NextIL
    890  05ce		       20 c4 1a 	      jsr	popLN
    891  05d1		       4c c2 02 	      jmp	NextIL
    892  05d4							;=====================================================
    893  05d4							; Get a line of text from the user, convert to a
    894  05d4							; number, leave on top of stack.
    895  05d4							;
    896  05d4				   iINNUM
    897  05d4		       20 9f 1a 	      jsr	pushLN
    898  05d7		       b0 ec		      bcs	iReadErr	; Stack over flow error
    899  05d9							;
    900  05d9		       a9 3f		      lda	#'?
    901  05db		       a2 00		      ldx	#0	;Wait for complete
    902  05dd		       20 a2 19 	      jsr	GetLine
    903  05e0		       20 37 19 	      jsr	getDecimal
    904  05e3		       20 85 1a 	      jsr	pushR0	;put onto stack
    905  05e6		       b0 dd		      bcs	iReadErr	;StackOverflow error
    906  05e8							;
    907  05e8		       4c 02 06 	      jmp	ExitIn
    908  05eb							;
    909  05eb							;=====================================================
    910  05eb							; Get a line of text from the user, convert to a
    911  05eb							; character value , leave on top of stack. up to 2 characters
    912  05eb							;
    913  05eb				   iINSTR
    914  05eb		       20 9f 1a 	      jsr	pushLN
    915  05ee		       b0 d5		      bcs	iReadErr	; Stack overflow error
    916  05f0		       a9 3f		      lda	#'?
    917  05f2		       a2 00		      ldx	#0	;wait for read complete
    918  05f4		       20 a2 19 	      jsr	GetLine
    919  05f7		       b1 4f		      lda	(CURPTR),y
    920  05f9		       85 52		      sta	R0
    921  05fb		       a9 00		      lda	#0
    922  05fd		       85 53		      sta	R0+1
    923  05ff		       20 85 1a 	      jsr	pushR0	;put onto stack
    924  0602				   ExitIn
    925  0602		       20 c4 1a 	      jsr	popLN
    926  0605		       4c c2 02 	      jmp	NextIL
    927  0608							;
    928  0608							;
    929  0608							;=====================================================
    930  0608							; Stop the currently running program.	Actually very
    931  0608							; simple to do... clear the RunMode flag, then set the
    932  0608							; ILPC to the standard handler and continue running.
    933  0608							;
    934  0608		       a9 00	   iFIN       lda	#0
    935  060a		       85 5b		      sta	RunMode
    936  060c		       20 2d 15 	      jsr	taskReset
    937  060f							;
    938  060f		       ad b9 2c 	      lda	errGoto
    939  0612		       85 43		      sta	ILPC
    940  0614		       ad ba 2c 	      lda	errGoto+1
    941  0617		       85 44		      sta	ILPC+1
    942  0619		       4c c2 02 	      jmp	NextIL
    943  061c							;
    944  061c							;=====================================================
    945  061c							; Handle the ERR opcode.  Following the instruction is
    946  061c							; a 16 bit error number.  Print an error message, and
    947  061c							; if we're in run mode, print the line number.  Stop
    948  061c							; program execution and return to the initial state.
    949  061c							;
    950  061c		       20 88 18    iERR       jsr	getILWord	;get err code
    951  061f							;
    952  061f							; Enter here with the error code in X (LSB) and A (MSB).
    953  061f							;
    954  061f		       86 52	   iErr2      stx	R0
    955  0621		       85 53		      sta	R0+1
    956  0623							;
    957  0623		       20 41 13 	      jsr	puts
      0  0626					      db	CR,LF,"Error ",0
      1  0626		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    959  062f		       20 72 12 	      jsr	PrintDecimal
    960  0632							;
    961  0632		       a5 5b		      lda	RunMode	;running?
    962  0634		       f0 3b		      beq	iERR3	;nope
    963  0636		       20 41 13 	      jsr	puts
      0  0639					      db	" at line ",0
      1  0639		       20 61 74 20*	      .byte.b	" at line ",0
    965  0643		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    966  0645				   iErr2a
    967  0645		       b1 4f		      lda	(CURPTR),y
    968  0647		       85 52		      sta	R0
    969  0649		       c8		      iny
    970  064a		       b1 4f		      lda	(CURPTR),y
    971  064c		       85 53		      sta	R0+1
    972  064e		       20 72 12 	      jsr	PrintDecimal
    973  0651		       20 41 13 	      jsr	puts
      0  0654					      db	":",0
      1  0654		       3a 00		      .byte.b	":",0
    975  0656		       a9 00		      lda	#0
    976  0658		       85 53		      sta	R0+1
    977  065a		       a5 51		      lda	CUROFF
    978  065c		       18		      clc
    979  065d		       e9 03		      sbc	#3
    980  065f		       85 52		      sta	R0
    981  0661		       20 72 12 	      jsr	PrintDecimal
    982  0664		       20 41 13 	      jsr	puts
      0  0667					      db	":",0
      1  0667		       3a 00		      .byte.b	":",0
    984  0669		       ad 73 23 	      lda	taskPtr
    985  066c		       85 52		      sta	R0
    986  066e		       20 72 12 	      jsr	PrintDecimal
    987  0671							;
    988  0671		       20 c2 1b    iERR3      jsr	CRLF
    989  0674		       20 25 15 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    990  0677		       a9 00		      lda	#0
    991  0679		       85 5b		      sta	RunMode	;fall through...
    992  067b							;
    993  067b							;=====================================================
    994  067b							; Reset the IL to be back at the idle loop.  Does not
    995  067b							; clear variables so the user can see what state
    996  067b							; the program is in.
    997  067b							;
    998  067b		       a9 00	   ResetIL    lda	#0
    999  067d		       85 47		      sta	ILSTACKPTR
   1000  067f		       ad b9 2c 	      lda	errGoto
   1001  0682		       85 43		      sta	ILPC
   1002  0684		       ad ba 2c 	      lda	errGoto+1
   1003  0687		       85 44		      sta	ILPC+1
   1004  0689		       4c c2 02 	      jmp	NextIL
   1005  068c
   1006  068c							;
   1007  068c							;=====================================================
   1008  068c							; Pop two items off stack, add them, then place the
   1009  068c							; result back onto the stack.
   1010  068c							;
   1011  068c		       20 09 1b    iADD       jsr	popR0
   1012  068f		       20 21 1b 	      jsr	popR1
   1013  0692				   iADDfast
   1014  0692		       18		      clc
   1015  0693		       a5 52		      lda	R0
   1016  0695		       65 54		      adc	R1
   1017  0697		       85 52		      sta	R0
   1018  0699		       a5 53		      lda	R0+1
   1019  069b		       65 55		      adc	R1+1
   1020  069d		       85 53		      sta	R0+1
   1021  069f		       4c 0a 07 	      jmp	pushR0nextIl
   1022  06a2							;
   1023  06a2							;=====================================================
   1024  06a2							; Pop two items off the stack.  Subtract the top of
   1025  06a2							; stack from the lower entry.
   1026  06a2							;
   1027  06a2		       20 21 1b    iSUB       jsr	popR1
   1028  06a5		       20 09 1b 	      jsr	popR0
   1029  06a8		       38		      sec
   1030  06a9		       a5 52		      lda	R0
   1031  06ab		       e5 54		      sbc	R1
   1032  06ad		       85 52		      sta	R0
   1033  06af		       a5 53		      lda	R0+1
   1034  06b1		       e5 55		      sbc	R1+1
   1035  06b3		       85 53		      sta	R0+1
   1036  06b5		       4c 0a 07 	      jmp	pushR0nextIl
   1037  06b8							;
   1038  06b8							;=====================================================
   1039  06b8							; Negate the top of stack.
   1040  06b8							;
   1041  06b8		       20 09 1b    iNEG       jsr	popR0
   1042  06bb		       a5 52		      lda	R0
   1043  06bd		       49 ff		      eor	#$ff
   1044  06bf		       85 52		      sta	R0
   1045  06c1		       a5 53		      lda	R0+1
   1046  06c3		       49 ff		      eor	#$ff
   1047  06c5		       85 53		      sta	R0+1
   1048  06c7		       e6 52		      inc	R0
   1049  06c9		       d0 02		      bne	iNEG2
   1050  06cb		       e6 53		      inc	R0+1
   1051  06cd		       4c 0a 07    iNEG2      jmp	pushR0nextIl
   1052  06d0							;
   1053  06d0							;=====================================================
   1054  06d0							; Multiply top two items on the stack, put the results
   1055  06d0							; on top.  This uses the algorithm documented on page
   1056  06d0							; 115 of "Microprocessor Programming for Computer
   1057  06d0							; Hobbyists" by Neill Graham.
   1058  06d0							;
   1059  06d0		       20 d6 06    iMUL       jsr	iMultiply
   1060  06d3		       4c c2 02 	      jmp	NextIL
   1061  06d6
   1062  06d6				   iMultiply
   1063  06d6		       20 09 1b 	      jsr	popR0	;AC
   1064  06d9		       20 21 1b 	      jsr	popR1	;OP
   1065  06dc							;
   1066  06dc		       a5 52		      lda	R0
   1067  06de		       85 56		      sta	MQ
   1068  06e0		       a5 53		      lda	R0+1
   1069  06e2		       85 57		      sta	MQ+1
   1070  06e4		       a9 00		      lda	#0	;clear result
   1071  06e6		       85 52		      sta	R0
   1072  06e8		       85 53		      sta	R0+1
   1073  06ea							;
   1074  06ea		       a2 10		      ldx	#16	;number of bits in value
   1075  06ec		       06 52	   multloop   asl	R0
   1076  06ee		       26 53		      rol	R0+1
   1077  06f0		       06 56		      asl	MQ
   1078  06f2		       26 57		      rol	MQ+1
   1079  06f4		       90 0d		      bcc	multno	;skip add if no carry
   1080  06f6							;
   1081  06f6							; Add R1 back into R0
   1082  06f6							;
   1083  06f6		       18		      clc
   1084  06f7		       a5 52		      lda	R0
   1085  06f9		       65 54		      adc	R1
   1086  06fb		       85 52		      sta	R0
   1087  06fd		       a5 53		      lda	R0+1
   1088  06ff		       65 55		      adc	R1+1
   1089  0701		       85 53		      sta	R0+1
   1090  0703							;
   1091  0703		       ca	   multno     dex		;did all bits yet?
   1092  0704		       d0 e6		      bne	multloop
   1093  0706		       20 85 1a 	      jsr	pushR0	;OP
   1094  0709		       60		      rts
   1095  070a							;
   1096  070a				   pushR0nextIl
   1097  070a		       20 85 1a 	      jsr	pushR0	;OP
   1098  070d		       4c c2 02 	      jmp	NextIL
   1099  0710							;
   1100  0710							;=====================================================
   1101  0710							; Divide the top of stack into the next to top item.
   1102  0710							; Leave results on stack.  Taken from:
   1103  0710							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1104  0710							;
   1105  0710							; R0 = R0 / R1
   1106  0710							; Remainder is in MQ
   1107  0710							;
   1108  0710		       20 2a 07    iDIV       jsr	iDoDiv
   1109  0713		       20 8a 1b 	      jsr	RestoreSigns
   1110  0716		       4c 0a 07 	      jmp	pushR0nextIl
   1111  0719
   1112  0719		       20 2a 07    iMOD       jsr	iDoDiv
   1113  071c		       20 8a 1b 	      jsr	RestoreSigns
   1114  071f		       a5 56		      lda	MQ
   1115  0721		       85 52		      sta	R0
   1116  0723		       a5 57		      lda	MQ+1
   1117  0725		       85 53		      sta	R0+1
   1118  0727		       4c 0a 07 	      jmp	pushR0nextIl
   1119  072a
   1120  072a				   iDoDiv
   1121  072a		       20 21 1b 	      jsr	popR1
   1122  072d		       20 09 1b 	      jsr	popR0
   1123  0730							;
   1124  0730							; Check for divide by zero
   1125  0730							;
   1126  0730
   1127  0730				   iDivNoPop
   1128  0730		       a5 54		      lda	R1
   1129  0732		       05 55		      ora	R1+1
   1130  0734		       f0 29		      beq	divby0
   1131  0736							;
   1132  0736		       20 4f 1b 	      jsr	SaveSigns
   1133  0739		       a9 00		      lda	#0	;preset remainder to 0
   1134  073b		       85 56		      sta	MQ
   1135  073d		       85 57		      sta	MQ+1
   1136  073f		       a2 10		      ldx	#16	;repeat for each bit: ...
   1137  0741				   divloop
   1138  0741		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1139  0743		       26 53		      rol	R0+1
   1140  0745		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1141  0747		       26 57		      rol	MQ+1
   1142  0749		       a5 56		      lda	MQ
   1143  074b		       38		      sec
   1144  074c		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1145  074e		       a8		      tay		;lb result -> Y, for we may need it later
   1146  074f		       a5 57		      lda	MQ+1
   1147  0751		       e5 55		      sbc	R1+1
   1148  0753		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1149  0755
   1150  0755		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1151  0757		       84 56		      sty	MQ
   1152  0759		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1153  075b
   1154  075b		       ca	   skip       dex
   1155  075c		       d0 e3		      bne	divloop
   1156  075e		       60		      rts
   1157  075f							;
   1158  075f							; Indicate divide-by-zero error
   1159  075f							;
   1160  075f		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1161  0761		       a9 00		      lda	#0
   1162  0763		       4c 1f 06 	      jmp	iErr2
   1163  0766							;
   1164  0766							;=====================================================
   1165  0766							; This pops the top two items off the stack.  The top
   1166  0766							; item is a data value and the other is an ABSOLUTE address.
   1167  0766							;Save the value into that address.
   1168  0766							;
   1169  0766		       98	   iSTORE     tya
   1170  0767		       48		      pha
   1171  0768		       20 09 1b 	      jsr	popR0	;data
   1172  076b		       20 21 1b 	      jsr	popR1	;Storage location
   1173  076e		       a0 00		      ldy	#0
   1174  0770		       a5 52		      lda	R0
   1175  0772		       91 54		      sta	(R1),y
   1176  0774		       a5 53		      lda	R0+1
   1177  0776		       c8		      iny
   1178  0777		       91 54		      sta	(R1),y
   1179  0779		       68		      pla
   1180  077a		       a8		      tay
   1181  077b		       4c c2 02 	      jmp	NextIL
   1182  077e							;
   1183  077e							;=====================================================
   1184  077e							; Replaces the top of stack with the variable whose
   1185  077e							; absolute address it represents.
   1186  077e							;
   1187  077e		       98	   iIND       tya
   1188  077f		       48		      pha
   1189  0780		       20 21 1b 	      jsr	popR1
   1190  0783		       a0 00		      ldy	#0
   1191  0785		       b1 54		      lda	(R1),y
   1192  0787		       85 52		      sta	R0
   1193  0789		       c8		      iny
   1194  078a		       b1 54		      lda	(R1),y
   1195  078c		       85 53		      sta	R0+1
   1196  078e		       68		      pla
   1197  078f		       a8		      tay
   1198  0790		       4c 0a 07 	      jmp	pushR0nextIl
   1199  0793							;
   1200  0793							;=====================================================
   1201  0793							; Get the array index from top of stack get Current variable
   1202  0793							; address from next on stack, add the offset
   1203  0793							; push the result back onto the stack
   1204  0793				   iArray
   1205  0793		       20 09 1b 	      jsr	popR0	; Get the array index
   1206  0796		       20 21 1b 	      jsr	popR1	; Get the Variable address
   1207  0799
   1208  0799		       18		      clc		; Multiplythe value by 2
   1209  079a		       26 52		      rol	R0	; Do the multiply
   1210  079c		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1211  079e		       18		      clc
   1212  079f		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1213  07a1		       65 52		      adc	R0
   1214  07a3		       85 52		      sta	R0
   1215  07a5		       a5 55		      lda	R1+1
   1216  07a7		       65 53		      adc	R0+1
   1217  07a9		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1218  07ab		       20 85 1a 	      jsr	pushR0	; Push R0 assume it is correct
   1219  07ae
   1220  07ae		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1221  07b0		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1222  07b2		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1223  07b4		       a5 55		      lda	R1+1
   1224  07b6		       c5 42		      cmp	VARIABLES+1
   1225  07b8		       d0 1c		      bne	iArrayAtTest
   1226  07ba		       18		      clc
   1227  07bb		       a9 34		      lda	#52	; add the max offset that is valid
   1228  07bd		       65 54		      adc	R1	; update to be the largest offset that is valid
   1229  07bf		       85 54		      sta	R1
   1230  07c1		       a9 00		      lda	#0
   1231  07c3		       65 55		      adc	R1+1
   1232  07c5		       85 55		      sta	R1+1
   1233  07c7				   iArrayVerify 		; try to enforce some sanity to using arrays
   1234  07c7		       a5 53		      lda	R0+1
   1235  07c9		       c5 55		      cmp	R1+1
   1236  07cb		       d0 04		      bne	iArrayDecide
   1237  07cd		       a5 52		      lda	R0
   1238  07cf		       c5 54		      cmp	R1
   1239  07d1				   iArrayDecide
   1240  07d1		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1241  07d3		       4c c2 02 	      jmp	NextIL
   1242  07d6
   1243  07d6				   iArrayAtTest
   1244  07d6		       ad d0 2c 	      lda	HighMem
   1245  07d9		       85 54		      sta	R1
   1246  07db		       ad d1 2c 	      lda	HighMem+1
   1247  07de		       85 55		      sta	R1+1
   1248  07e0		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1249  07e2
   1250  07e2							; Get here if array index is out of range
   1251  07e2		       20 09 1b    iArrayError jsr	popR0
   1252  07e5		       a9 00		      lda	#0
   1253  07e7		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1254  07e9		       4c 1f 06 	      jmp	iErr2
   1255  07ec							;
   1256  07ec							;=====================================================
   1257  07ec							; List the current BASIC program in memory.  Uses R0,
   1258  07ec							; tempIly, and dpl.
   1259  07ec							;
   1260  07ec		       20 f1 1c    iLST       jsr	SetOutConsole
   1261  07ef		       ad cc 2c    iLST2      lda	ProgramStart
   1262  07f2		       85 59		      sta	dpl
   1263  07f4		       ad cd 2c 	      lda	ProgramStart+1
   1264  07f7		       85 5a		      sta	dpl+1
   1265  07f9							;
   1266  07f9							; dpl/dph point to the current line.  See if we're at
   1267  07f9							; the end of the program.
   1268  07f9							;
   1269  07f9		       a5 59	   iLSTloop   lda	dpl
   1270  07fb		       cd ce 2c 	      cmp	ProgramEnd
   1271  07fe		       d0 07		      bne	iLstNotEnd
   1272  0800		       a5 5a		      lda	dpl+1
   1273  0802		       cd cf 2c 	      cmp	ProgramEnd+1
   1274  0805		       f0 44		      beq	iLstdone
   1275  0807							;
   1276  0807		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1277  0809		       b1 59		      lda	(dpl),y	;line number LSB
   1278  080b		       85 52		      sta	R0
   1279  080d		       c8		      iny
   1280  080e		       b1 59		      lda	(dpl),y	;line number MSB
   1281  0810		       85 53		      sta	R0+1
   1282  0812		       c8		      iny
   1283  0813		       8c c7 2c 	      sty	tempIlY
   1284  0816		       20 72 12 	      jsr	PrintDecimal
   1285  0819		       a9 20		      lda	#SPACE
   1286  081b		       20 0b 1d 	      jsr	VOUTCH
   1287  081e		       ac c7 2c 	      ldy	tempIlY
   1288  0821		       b1 59	   iLSTl2     lda	(dpl),y
   1289  0823		       f0 0c		      beq	iLST3	;end of this line 0 value
   1290  0825		       8c c7 2c 	      sty	tempIlY
   1291  0828		       20 0b 1d 	      jsr	VOUTCH
   1292  082b		       ac c7 2c 	      ldy	tempIlY
   1293  082e		       c8		      iny
   1294  082f		       d0 f0		      bne	iLSTl2	;do next char
   1295  0831							;
   1296  0831							; End of this line.  Print CR/LF, then move to the
   1297  0831							; next line.
   1298  0831							;
   1299  0831		       c8	   iLST3      iny		;Move to next line
   1300  0832		       18		      clc		;Clear the carry flag
   1301  0833		       98		      tya		;Current Offset
   1302  0834		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  0836		       85 59		      sta	dpl	;Save the new value
   1304  0838		       a5 5a		      lda	dpl+1	;Next byte
   1305  083a		       69 00		      adc	#0	;ad in the carry if any
   1306  083c		       85 5a		      sta	dpl+1	;Save it
   1307  083e							;
   1308  083e							; Have to manually do CR/LF so it uses the vectored
   1309  083e							; output function.
   1310  083e							;
   1311  083e		       a9 0d		      lda	#CR
   1312  0840		       20 0b 1d 	      jsr	VOUTCH
   1313  0843		       a9 0a		      lda	#LF
   1314  0845		       20 0b 1d 	      jsr	VOUTCH
   1315  0848		       4c f9 07 	      jmp	iLSTloop	;do next line
   1316  084b							;
   1317  084b		       20 f1 1c    iLstdone   jsr	SetOutConsole
   1318  084e		       4c c2 02 	      jmp	NextIL
   1319  0851							;
   1320  0851							;=====================================================
   1321  0851							; Get a line of text into LINBUF.  Terminate with a
   1322  0851							; null byte.
   1323  0851							;
   1324  0851				   iGETLINE
   1325  0851		       a9 3e		      lda	#'>	;prompt character
   1326  0853		       a6 00		      ldx	0	;Wait for read to complete
   1327  0855		       20 a2 19 	      jsr	GetLine
   1328  0858							;
   1329  0858		       a9 00		      lda	#0
   1330  085a		       85 5b		      sta	RunMode
   1331  085c				   iGetParseLine
   1332  085c		       a5 51		      lda	CUROFF
   1333  085e		       48		      pha
   1334  085f		       20 0a 0f 	      jsr	ParseInputLine
   1335  0862		       48		      pha
   1336  0863		       85 51		      sta	CUROFF
   1337  0865		       4c c2 02 	      jmp	NextIL
   1338  0868							;
   1339  0868							;=====================================================
   1340  0868							; This is called when the input buffer contains a line
   1341  0868							; typed in by the user that starts with a line number.
   1342  0868							; Insert the line into the program or delete the line
   1343  0868							; if there is nothing after the line number,
   1344  0868							;
   1345  0868		       a0 00	   iINSRT     ldy	#0
   1346  086a		       20 37 19 	      jsr	getDecimal	;convert line #
   1347  086d		       20 b9 1b 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1348  0870		       8c c8 2c 	      sty	offset	;Save the start of the program line text
   1349  0873							;
   1350  0873							; Now find the line OR the next higher line OR the
   1351  0873							; end of the program.
   1352  0873							;
   1353  0873		       20 d1 18 	      jsr	findLine	; Look for the line number in the current program
   1354  0876							; Returns Z and curptr point to the line if found
   1355  0876							; Returns C and curptr at next higher line if not found and there is a higher line
   1356  0876							; Returns ZC clear and curptr to end of program if higher than all other lines
   1357  0876							;
   1358  0876							; If the line exists, it needs to be removed.
   1359  0876							;
   1360  0876		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1361  0878							;
   1362  0878							; Get length of line to be removed, we fall thru to here if we find a matching line
   1363  0878							;
   1364  0878							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1365  0878		       a0 00		      ldy	#0
   1366  087a		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1367  087c		       a8		      tay
   1368  087d							;If it is equal we delete the line and replace it, get length
   1369  087d							;then adjust all program line after up or down depending on len of line
   1370  087d							;If next higher then just move everythimg down by length bytes
   1371  087d							;This call will return how many bytes in the line we found
   1372  087d		       8c c9 2c 	      sty	lineLength	;Save the length of the line we found
   1373  0880							;
   1374  0880							; Compute the new end of the program first.
   1375  0880							;
   1376  0880		       38		      sec		;Set the carry bit
   1377  0881		       ad ce 2c 	      lda	ProgramEnd	;Get low byte of program end
   1378  0884		       ed c9 2c 	      sbc	lineLength	;Subtract the length of the current line
   1379  0887		       8d ce 2c 	      sta	ProgramEnd	;save it
   1380  088a		       ad cf 2c 	      lda	ProgramEnd+1
   1381  088d		       e9 00		      sbc	#0	;Process the carry
   1382  088f		       8d cf 2c 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1383  0892							;
   1384  0892							; Copy CURPTR into R1 for working
   1385  0892							;
   1386  0892		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1387  0894		       85 54		      sta	R1
   1388  0896		       a5 50		      lda	CURPTR+1
   1389  0898		       85 55		      sta	R1+1
   1390  089a							;
   1391  089a							; See if we're at the end.
   1392  089a							;
   1393  089a		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1394  089c		       cd ce 2c 	      cmp	ProgramEnd
   1395  089f		       d0 07		      bne	InsDelLoop
   1396  08a1		       a5 55		      lda	R1+1
   1397  08a3		       cd cf 2c 	      cmp	ProgramEnd+1
   1398  08a6		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1399  08a8							;
   1400  08a8							; Move one byte, move to next location.
   1401  08a8							;
   1402  08a8		       ac c9 2c    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1403  08ab		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1404  08ad		       b1 54		      lda	(R1),y
   1405  08af		       a0 00		      ldy	#0
   1406  08b1		       91 54		      sta	(R1),y
   1407  08b3		       e6 54		      inc	R1
   1408  08b5		       d0 e3		      bne	InsDelChk
   1409  08b7		       e6 55		      inc	R1+1
   1410  08b9		       4c 9a 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1411  08bc							;
   1412  08bc							; Deletion is done.
   1413  08bc							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1414  08bc							;
   1415  08bc		       ac c8 2c    insert2    ldy	offset	; get back ptr  Get the current offset
   1416  08bf		       b9 2f 2c 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1417  08c2		       f0 5f		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1418  08c4							;
   1419  08c4							; CURPTR points to where the line will be inserted.
   1420  08c4							;
   1421  08c4		       20 5c 1a 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1422  08c7							;
   1423  08c7		       ad ce 2c 	      lda	ProgramEnd	;Load the start address for the copy
   1424  08ca							;At this point curptr still contains the location we will insert data
   1425  08ca		       85 5c		      sta	FROM
   1426  08cc		       ad cf 2c 	      lda	ProgramEnd+1
   1427  08cf		       85 5d		      sta	FROM+1
   1428  08d1							;
   1429  08d1		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1430  08d3		       b1 5c		      lda	(FROM),y
   1431  08d5		       ac c9 2c 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1432  08d8		       91 5c		      sta	(FROM),y	;Save the new byte
   1433  08da							;
   1434  08da		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1435  08dc		       c5 4f		      cmp	CURPTR
   1436  08de		       d0 06		      bne	mvUpMore
   1437  08e0		       a5 5d		      lda	FROM+1
   1438  08e2		       c5 50		      cmp	CURPTR+1
   1439  08e4		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1440  08e6							;
   1441  08e6							; Not done yet
   1442  08e6							;
   1443  08e6		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1444  08e8		       d0 02		      bne	mvUpMore2
   1445  08ea		       c6 5d		      dec	FROM+1
   1446  08ec		       c6 5c	   mvUpMore2  dec	FROM
   1447  08ee		       4c d1 08 	      jmp	mvup1	;Loop until everything is moved
   1448  08f1							;
   1449  08f1							; All done with copy.
   1450  08f1							;
   1451  08f1				   mvUpDone
   1452  08f1		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1453  08f2		       ad c9 2c 	      lda	lineLength	;Number of bytes to copy from line buff
   1454  08f5		       6d ce 2c 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1455  08f8		       8d ce 2c 	      sta	ProgramEnd
   1456  08fb		       ad cf 2c 	      lda	ProgramEnd+1
   1457  08fe		       69 00		      adc	#0
   1458  0900		       8d cf 2c 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1459  0903							;
   1460  0903							;===================jlit use length before line newline
   1461  0903
   1462  0903		       a0 00		      ldy	#0	;Set offset of copy
   1463  0905		       ad c9 2c 	      lda	lineLength	;We will insert the actual length of the line first
   1464  0908		       91 4f		      sta	(CURPTR),y	;Store the length
   1465  090a		       c8		      iny
   1466  090b		       a5 52		      lda	R0	;Store the line number next
   1467  090d		       91 4f		      sta	(CURPTR),y
   1468  090f		       c8		      iny
   1469  0910		       a5 53		      lda	R0+1
   1470  0912		       91 4f		      sta	(CURPTR),y
   1471  0914		       c8		      iny
   1472  0915							;
   1473  0915		       ae c8 2c 	      ldx	offset	;Load the offset into line buffer in page zero
   1474  0918		       bd 2f 2c    mvUpLoop2  lda	LINBUF,x	;get a byte
   1475  091b		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1476  091d		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1477  091f		       e8		      inx
   1478  0920		       c8		      iny
   1479  0921		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1480  0923							;
   1481  0923		       4c c2 02    mvUpFini   jmp	NextIL
   1482  0926							;
   1483  0926							;=====================================================
   1484  0926							; Pops the top value of the ILPC stack and stores it
   1485  0926							; in ILPC.  Ie, return from an IL subroutine.
   1486  0926							;
   1487  0926		       20 bf 18    iRTN       jsr	popILPC
   1488  0929		       4c c2 02 	      jmp	NextIL
   1489  092c							;
   1490  092c							;=====================================================
   1491  092c							; NLINE print a newline
   1492  092c							;
   1493  092c		       20 c2 1b    iNLINE     jsr	CRLF	;user supplied sub
   1494  092f		       4c c2 02 	      jmp	NextIL
   1495  0932							;
   1496  0932							;=====================================================
   1497  0932							; This saves the current ILPC value on the stack, then
   1498  0932							; jumps to the address specified by the next two bytes.
   1499  0932							;
   1500  0932		       20 a2 18    iCALL      jsr	pushILPC	;save ILPC
   1501  0935		       90 03		      bcc	iJMP
   1502  0937		       4c 6c 0b 	      jmp	ErrStkOver	; Check if there was an error
   1503  093a							;
   1504  093a							; Jmp to a specific location in the IL code.  The new
   1505  093a							; address immediately follows the opcode.
   1506  093a							;
   1507  093a		       20 88 18    iJMP       jsr	getILWord
   1508  093d		       86 43		      stx	ILPC
   1509  093f		       85 44		      sta	ILPC+1
   1510  0941		       4c c2 02 	      jmp	NextIL
   1511  0944
   1512  0944
   1513  0944							;
   1514  0944							;=====================================================
   1515  0944							; Push the next two bytes onto the arithmetic stack.
   1516  0944							;
   1517  0944		       20 8c 18    iSetR2     jsr	getILByte
   1518  0947		       85 58		      sta	R2
   1519  0949		       4c c2 02 	      jmp	NextIL
   1520  094c							;
   1521  094c							;=====================================================
   1522  094c							; Push the next two bytes onto the arithmetic stack.
   1523  094c							;
   1524  094c		       20 88 18    iLIT       jsr	getILWord
   1525  094f		       86 52		      stx	R0
   1526  0951		       85 53		      sta	R0+1
   1527  0953		       20 85 1a 	      jsr	pushR0
   1528  0956		       4c c2 02 	      jmp	NextIL
   1529  0959							;
   1530  0959							;=====================================================
   1531  0959							; Initialize all variables for a single task.	Ie, set to zero.
   1532  0959							;
   1533  0959		       98	   subVINIT   tya
   1534  095a		       48		      pha
   1535  095b
   1536  095b		       a9 00		      lda	#0
   1537  095d		       a0 00		      ldy	#0
   1538  095f		       91 41	   Vinit2     sta	(VARIABLES),y
   1539  0961		       c8		      iny
   1540  0962		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1541  0964		       90 f9		      bcc	Vinit2
   1542  0966
   1543  0966		       68		      pla
   1544  0967		       a8		      tay
   1545  0968		       60		      rts
   1546  0969
   1547  0969		       20 59 09    iVINIT     jsr	subVINIT
   1548  096c		       4c c2 02 	      jmp	NextIL
   1549  096f							;
   1550  096f							;=====================================================
   1551  096f							; Set the address of the error handler.  After any
   1552  096f							; error, set to the ILPC to the specified location.
   1553  096f							;
   1554  096f		       20 88 18    iERRGOTO   jsr	getILWord
   1555  0972		       8e b9 2c 	      stx	errGoto
   1556  0975		       8d ba 2c 	      sta	errGoto+1
   1557  0978		       4c c2 02 	      jmp	NextIL
   1558  097b							;
   1559  097b							;=====================================================
   1560  097b							; TST is followed by an 8 bit signed offset, then a
   1561  097b							; null terminated string.  Compare the string against
   1562  097b							; the string starting at (CURPTR),CUROFF.  If the
   1563  097b							; strings match, continue executing the next IL
   1564  097b							; opcode.  Else, add the offset to ILPC.
   1565  097b							;
   1566  097b		       20 8c 18    iTST       jsr	getILByte	;Get the relative jump address
   1567  097e		       8d c8 2c 	      sta	offset	;save it to use if test faile
   1568  0981		       20 6f 1a 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1569  0984
   1570  0984		       a4 51		      ldy	CUROFF
   1571  0986		       84 59		      sty	dpl	;save for later
   1572  0988							;
   1573  0988		       20 8c 18    iTSTloop   jsr	getILByte	;get next char
   1574  098b		       f0 11		      beq	iTSTm	;match!
   1575  098d		       a4 59		      ldy	dpl
   1576  098f		       d1 4f		      cmp	(CURPTR),y
   1577  0991		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1578  0993		       09 20		      ora	#$20	; lets allow lowercase as well
   1579  0995		       d1 4f		      cmp	(CURPTR),y
   1580  0997		       d0 23		      bne	iTSTfail	;mismatch
   1581  0999		       c8	   iTSTUpper  iny
   1582  099a		       84 59		      sty	dpl
   1583  099c		       d0 ea		      bne	iTSTloop
   1584  099e							;
   1585  099e							; It's a match!  Clean up a bit.
   1586  099e							;
   1587  099e		       a4 59	   iTSTm      ldy	dpl
   1588  09a0		       84 51		      sty	CUROFF
   1589  09a2		       4c c2 02 	      jmp	NextIL
   1590  09a5
   1591  09a5							; Test for a single quote string
   1592  09a5		       20 8c 18    iTSTStr    jsr	getILByte
   1593  09a8		       8d c8 2c 	      sta	offset
   1594  09ab		       20 6f 1a 	      jsr	saveIL
   1595  09ae		       a4 51		      ldy	CUROFF
   1596  09b0		       a9 22		      lda	#'"
   1597  09b2		       d1 4f		      cmp	(CURPTR),y
   1598  09b4		       d0 06		      bne	iTSTfail
   1599  09b6		       c8		      iny
   1600  09b7		       84 51		      sty	CUROFF
   1601  09b9		       4c e5 02 	      jmp	NextILStr
   1602  09bc							;
   1603  09bc							; Not a match, reset ILPC and then move to the
   1604  09bc							; offset.
   1605  09bc							;
   1606  09bc		       20 7a 1a    iTSTfail   jsr	restoreIL
   1607  09bf		       4c 1c 0b 	      jmp	tstBranch
   1608  09c2							;
   1609  09c2							;=================================================JLIT=
   1610  09c2							; Test if we have a let statement without the let keyword
   1611  09c2		       20 8c 18    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1612  09c5		       8d c8 2c 	      sta	offset	; Save the jump offset for fails
   1613  09c8		       20 6f 1a 	      jsr	saveIL	; save to restore when done if fail
   1614  09cb
   1615  09cb		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1616  09cd		       20 b9 1b 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1617  09d0		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1618  09d1		       20 b9 1b 	      jsr	SkipSpaces	; skip any SkipSpaces
   1619  09d4		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1620  09d6		       c9 3d		      cmp	#'=	; check if equals
   1621  09d8		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1622  09da		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1623  09dc		       d0 de		      bne	iTSTfail	; return it failed
   1624  09de
   1625  09de				   iTSTLETGOOD
   1626  09de		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1627  09e1
   1628  09e1							;=================================================JLIT=
   1629  09e1							;
   1630  09e1		       20 8c 18    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1631  09e4		       8d c8 2c 	      sta	offset	; Save the jump offset for fails
   1632  09e7		       20 6f 1a 	      jsr	saveIL	; save to restore when done if fail
   1633  09ea		       20 88 18 	      jsr	getILWord	; Get a word into RO
   1634  09ed		       86 52		      stx	R0
   1635  09ef		       85 53		      sta	R0+1
   1636  09f1		       20 8c 18 	      jsr	getILByte	; Get byte into A
   1637  09f4		       a0 00		      ldy	#0
   1638  09f6		       d1 52		      cmp	(R0),y
   1639  09f8		       d0 03		      bne	iTSTByteNotEqual
   1640  09fa		       4c bc 09 	      jmp	iTSTfail
   1641  09fd
   1642  09fd				   iTSTByteNotEqual
   1643  09fd		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1644  0a00
   1645  0a00
   1646  0a00							;================================================jLIT=
   1647  0a00							;Test for end of line
   1648  0a00							;
   1649  0a00		       20 8c 18    iTSTDONE   jsr	getILByte
   1650  0a03		       8d c8 2c 	      sta	offset
   1651  0a06		       20 6f 1a 	      jsr	saveIL
   1652  0a09		       a4 51		      ldy	CUROFF
   1653  0a0b		       84 59		      sty	dpl
   1654  0a0d		       20 b9 1b 	      jsr	SkipSpaces
   1655  0a10		       b1 4f		      lda	(CURPTR),y
   1656  0a12		       f0 0b		      beq	iTSTDONEtrue
   1657  0a14		       c9 3a		      cmp	#COLON
   1658  0a16		       f0 07		      beq	iTSTDONEtrue
   1659  0a18		       a4 59		      ldy	dpl
   1660  0a1a		       84 51		      sty	CUROFF
   1661  0a1c		       4c bc 09 	      jmp	iTSTfail
   1662  0a1f							;
   1663  0a1f							; Advance to the next line
   1664  0a1f							;
   1665  0a1f				   iTSTDONEtrue
   1666  0a1f		       4c c2 02 	      jmp	NextIL
   1667  0a22
   1668  0a22		       4c 1c 0b    tstBranchLink jmp	tstBranch
   1669  0a25							;
   1670  0a25							;=====================================================
   1671  0a25							; Inc and dec a variable , faster than a = a + 1
   1672  0a25				   iINCVAR
   1673  0a25		       20 09 1b 	      jsr	popR0
   1674  0a28		       a0 00		      ldy	#0
   1675  0a2a		       18		      clc
   1676  0a2b		       a9 01		      lda	#1
   1677  0a2d		       71 52		      adc	(R0),y
   1678  0a2f		       91 52		      sta	(R0),y
   1679  0a31		       90 07		      bcc	iINCDONE
   1680  0a33		       c8		      iny
   1681  0a34		       a9 00		      lda	#0
   1682  0a36		       71 52		      adc	(R0),y
   1683  0a38		       91 52		      sta	(R0),y
   1684  0a3a				   iINCDONE
   1685  0a3a		       4c c2 02 	      jmp	NextIL
   1686  0a3d				   iDECVAR
   1687  0a3d		       20 09 1b 	      jsr	popR0
   1688  0a40		       a0 00		      ldy	#0
   1689  0a42		       38		      sec
   1690  0a43		       b1 52		      lda	(R0),y
   1691  0a45		       e9 01		      sbc	#1
   1692  0a47		       91 52		      sta	(R0),y
   1693  0a49		       c8		      iny
   1694  0a4a		       b1 52		      lda	(R0),y
   1695  0a4c		       69 00		      adc	#0
   1696  0a4e		       91 52		      sta	(R0),y
   1697  0a50		       4c c2 02 	      jmp	NextIL
   1698  0a53
   1699  0a53
   1700  0a53							;
   1701  0a53							;=====================================================
   1702  0a53							; TSTV is followed by an 8 bit signed offset.	If the
   1703  0a53							; value at (CURPTR),CUROFF appears to be a variable
   1704  0a53							; name, move to the next IL statement.  Else, add the
   1705  0a53							; offset to ILPC. Converted to use actual absolute memory addresses
   1706  0a53							; TSTVT Looks for the task context
   1707  0a53							;
   1708  0a53		       20 21 1b    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1709  0a56		       a9 00		      lda	#0
   1710  0a58		       85 58		      sta	R2
   1711  0a5a		       f0 04		      beq	iTSTVV
   1712  0a5c
   1713  0a5c		       a9 01	   iTSTV      lda	#1
   1714  0a5e		       85 58		      sta	R2
   1715  0a60
   1716  0a60		       20 8c 18    iTSTVV     jsr	getILByte	;offset
   1717  0a63		       8d c8 2c 	      sta	offset
   1718  0a66							;
   1719  0a66		       a4 51		      ldy	CUROFF
   1720  0a68		       20 b9 1b 	      jsr	SkipSpaces
   1721  0a6b		       b1 4f		      lda	(CURPTR),y
   1722  0a6d		       d0 03		      bne	iTSTVnext
   1723  0a6f		       4c 22 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1724  0a72							;
   1725  0a72				   iTSTVnext
   1726  0a72		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1727  0a74		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1728  0a76
   1729  0a76		       c9 23		      cmp	#'#	; parameters passed to this task
   1730  0a78		       f0 53		      beq	iTSTVParm
   1731  0a7a
   1732  0a7a		       c9 5e		      cmp	#'^	; task exit code
   1733  0a7c		       d0 04		      bne	iTSTV_A2Z
   1734  0a7e		       a9 19		      lda	#TASKEXITCODE
   1735  0a80		       d0 10		      bne	iTSTVContinue
   1736  0a82
   1737  0a82				   iTSTV_A2Z
   1738  0a82		       09 20		      ora	#$20	;make lower then upper
   1739  0a84		       49 20		      eor	#$20	;allow lower case here
   1740  0a86		       c9 41		      cmp	#'A
   1741  0a88		       90 98		      bcc	tstBranchLink
   1742  0a8a		       c9 5b		      cmp	#'Z+1
   1743  0a8c		       b0 94		      bcs	tstBranchLink
   1744  0a8e
   1745  0a8e
   1746  0a8e							;
   1747  0a8e							; The condition is true, so convert to an index, push
   1748  0a8e							; it onto the stack and continue running.
   1749  0a8e							;
   1750  0a8e		       38		      sec
   1751  0a8f		       e9 41		      sbc	#'A	;index is zero based
   1752  0a91		       0a		      asl		;multiply by two
   1753  0a92
   1754  0a92				   iTSTVContinue
   1755  0a92		       c8		      iny
   1756  0a93		       84 51		      sty	CUROFF	;it is a valid variable
   1757  0a95		       48		      pha
   1758  0a96		       a5 58		      lda	R2
   1759  0a98		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1760  0a9a
   1761  0a9a		       20 6f 18 	      jsr	ipc_getcontext	; Get the other tasks variables
   1762  0a9d		       a0 01		      ldy	#VARIABLEPOS
   1763  0a9f		       b1 56		      lda	(MQ),y
   1764  0aa1		       85 52		      sta	R0
   1765  0aa3		       c8		      iny
   1766  0aa4		       b1 56		      lda	(MQ),y
   1767  0aa6		       85 53		      sta	R0+1
   1768  0aa8		       4c b3 0a 	      jmp	iTSTVAddOffset
   1769  0aab
   1770  0aab				   iTSTVLocalValue
   1771  0aab		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1772  0aad		       85 52		      sta	R0
   1773  0aaf		       a5 42		      lda	VARIABLES+1
   1774  0ab1		       85 53		      sta	R0+1
   1775  0ab3
   1776  0ab3				   iTSTVAddOffset
   1777  0ab3		       68		      pla
   1778  0ab4		       85 54		      sta	R1
   1779  0ab6		       a9 00		      lda	#0
   1780  0ab8		       85 55		      sta	R1+1
   1781  0aba
   1782  0aba				   iTSTVcontinue
   1783  0aba
   1784  0aba		       4c 92 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1785  0abd
   1786  0abd							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1787  0abd							; an array of integer values
   1788  0abd				   iTSTVat
   1789  0abd		       c8		      iny
   1790  0abe		       84 51		      sty	CUROFF	;it is a valid variable
   1791  0ac0		       ad ce 2c 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1792  0ac3		       85 52		      sta	R0
   1793  0ac5		       ad cf 2c 	      lda	ProgramEnd+1
   1794  0ac8		       85 53		      sta	R0+1
   1795  0aca		       4c 0a 07 	      jmp	pushR0nextIl	;place this onto the stack
   1796  0acd
   1797  0acd							; When we get parameters passed we can access them using the # variable with[]
   1798  0acd							; example #[0] #[1] etc, we dont check yet if there is too many
   1799  0acd				   iTSTVParm
   1800  0acd		       c8		      iny
   1801  0ace		       84 51		      sty	CUROFF	;it is a valid variable
   1802  0ad0		       a5 48		      lda	MATHSTACK
   1803  0ad2		       85 52		      sta	R0
   1804  0ad4		       a5 49		      lda	MATHSTACK+1
   1805  0ad6		       85 53		      sta	R0+1
   1806  0ad8		       4c 0a 07 	      jmp	pushR0nextIl
   1807  0adb
   1808  0adb							;
   1809  0adb							;=====================================================
   1810  0adb							; TSTL seems basically the same as TSTN, but leave the
   1811  0adb							; value in R0 instead of pushing onto stack.
   1812  0adb							; This tests for a valid line number
   1813  0adb							;
   1814  0adb		       20 8c 18    iTSTL      jsr	getILByte
   1815  0ade		       8d c8 2c 	      sta	offset
   1816  0ae1							;
   1817  0ae1		       a4 51		      ldy	CUROFF
   1818  0ae3		       20 b9 1b 	      jsr	SkipSpaces
   1819  0ae6		       b1 4f		      lda	(CURPTR),y
   1820  0ae8							;
   1821  0ae8		       c9 30		      cmp	#'0
   1822  0aea		       90 30		      bcc	tstBranch
   1823  0aec		       c9 3a		      cmp	#'9+1
   1824  0aee		       b0 2c		      bcs	tstBranch
   1825  0af0							;
   1826  0af0							; It's a digit, so convert to a number.
   1827  0af0							;
   1828  0af0		       20 37 19 	      jsr	getDecimal
   1829  0af3		       4c c2 02 	      jmp	NextIL
   1830  0af6							;
   1831  0af6							;=====================================================
   1832  0af6							; TSTN checks for a number.  This is very simplistic;
   1833  0af6							; if the character is a digit, assume it's a number.
   1834  0af6							; Convert to a number and push it onto the stack.
   1835  0af6							;
   1836  0af6		       20 8c 18    iTSTN      jsr	getILByte
   1837  0af9		       8d c8 2c 	      sta	offset
   1838  0afc							;
   1839  0afc		       a4 51		      ldy	CUROFF
   1840  0afe		       20 b9 1b 	      jsr	SkipSpaces
   1841  0b01		       b1 4f		      lda	(CURPTR),y
   1842  0b03		       f0 17		      beq	tstBranch
   1843  0b05		       c9 2d		      cmp	#'-	;negative?
   1844  0b07		       f0 08		      beq	iTSTN_1
   1845  0b09		       c9 30		      cmp	#'0
   1846  0b0b		       90 0f		      bcc	tstBranch
   1847  0b0d		       c9 3a		      cmp	#'9+1
   1848  0b0f		       b0 0b		      bcs	tstBranch
   1849  0b11							;
   1850  0b11							; It's a digit, so convert to a number.
   1851  0b11							;
   1852  0b11				   iTSTN_1
   1853  0b11		       20 37 19 	      jsr	getDecimal
   1854  0b14		       84 51		      sty	CUROFF
   1855  0b16		       20 85 1a 	      jsr	pushR0	;save onto stack
   1856  0b19		       4c c2 02 	      jmp	NextIL
   1857  0b1c
   1858  0b1c							;
   1859  0b1c							; Common jump point for all TSTx instructions that
   1860  0b1c							; fail to meet the requirements.  This takes the
   1861  0b1c							; offset and adds/subtracts to/from ILPC.
   1862  0b1c							;
   1863  0b1c		       ad c8 2c    tstBranch  lda	offset	;get signed offset
   1864  0b1f		       10 0e		      bpl	tstPositive
   1865  0b21							;
   1866  0b21							; Do negative branch.	Do sign extension.
   1867  0b21							;
   1868  0b21		       18	   tstNegative clc
   1869  0b22		       65 43		      adc	ILPC
   1870  0b24		       85 43		      sta	ILPC
   1871  0b26							;		  bcc	  tstBothDone
   1872  0b26							;		  dec	  ILPC+1
   1873  0b26							;		  jmp	  NextIL
   1874  0b26
   1875  0b26		       a5 44		      lda	ILPC+1
   1876  0b28		       69 ff		      adc	#$ff
   1877  0b2a		       85 44		      sta	ILPC+1
   1878  0b2c		       4c c2 02 	      jmp	NextIL	;keep going
   1879  0b2f							;
   1880  0b2f		       18	   tstPositive clc
   1881  0b30		       65 43		      adc	ILPC
   1882  0b32		       85 43		      sta	ILPC
   1883  0b34		       90 02		      bcc	tstBothDone
   1884  0b36		       e6 44		      inc	ILPC+1
   1885  0b38				   tstBothDone
   1886  0b38		       4c c2 02 	      jmp	NextIL
   1887  0b3b
   1888  0b3b							;
   1889  0b3b							;====================================================
   1890  0b3b							; Test for IRQ pending, and test if a break key pressed
   1891  0b3b							; Yes I know but this handles all sorts of irq/break issues
   1892  0b3b							;
   1893  0b3b		       20 8c 18    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1894  0b3e		       8d c8 2c 	      sta	offset	; Store the not true jump address offset
   1895  0b41		       20 3d 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1896  0b44		       d0 03		      bne	irqNo	; z not set of no break found
   1897  0b46		       4c 08 06 	      jmp	iFIN	; Exit out of run mode
   1898  0b49		       ad 70 23    irqNo      lda	IRQPending
   1899  0b4c		       f0 ce		      beq	tstBranch
   1900  0b4e		       c9 01		      cmp	#1	; only do this if set to first time
   1901  0b50		       d0 ca		      bne	tstBranch
   1902  0b52		       78		      sei		; disable the interupt until ireturn resets it
   1903  0b53		       ee 70 23    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1904  0b56		       20 9f 1a 	      jsr	pushLN	; Push the next line to be executed
   1905  0b59		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1906  0b5b		       ad 71 23 	      lda	IRQEntry	; Get the line number to branch to
   1907  0b5e		       85 4f		      sta	CURPTR	; put line number into r0
   1908  0b60		       ad 72 23 	      lda	IRQEntry+1
   1909  0b63		       85 50		      sta	CURPTR+1
   1910  0b65		       a9 03		      lda	#3	; Point to first byte of program text
   1911  0b67		       85 51		      sta	CUROFF
   1912  0b69		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1913  0b6c
   1914  0b6c		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1915  0b6e		       a9 00		      lda	#0	; stop the execution
   1916  0b70		       4c 1f 06 	      jmp	iErr2
   1917  0b73							;
   1918  0b73
   1919  0b73							;=====================================================
   1920  0b73							; This places the number of free bytes on top of the
   1921  0b73							; stack.
   1922  0b73							;
   1923  0b73		       20 f2 13    iFREE      jsr	MemFree
   1924  0b76		       20 85 1a 	      jsr	pushR0
   1925  0b79		       4c c2 02 	      jmp	NextIL
   1926  0b7c							;
   1927  0b7c							;=====================================================
   1928  0b7c							; Generate a random number from 0-FFFF and then MOD
   1929  0b7c							; it with the value on top of stack.  Leaves number on
   1930  0b7c							; stack
   1931  0b7c							;
   1932  0b7c		       20 21 1b    iRANDOM    jsr	popR1	;mod value
   1933  0b7f							;
   1934  0b7f							; If the value is zero, just return a one.
   1935  0b7f							;
   1936  0b7f		       a5 54		      lda	R1
   1937  0b81		       05 55		      ora	R1+1
   1938  0b83		       f0 4a		      beq	irandom1
   1939  0b85							;
   1940  0b85		       ad bf 2c 	      lda	random+1
   1941  0b88		       8d bc 2c 	      sta	rtemp1
   1942  0b8b		       ad be 2c 	      lda	random
   1943  0b8e		       0a		      asl
   1944  0b8f		       2e bc 2c 	      rol	rtemp1
   1945  0b92		       0a		      asl
   1946  0b93		       2e bc 2c 	      rol	rtemp1
   1947  0b96		       18		      clc
   1948  0b97		       6d be 2c 	      adc	random
   1949  0b9a
   1950  0b9a		       48		      pha
   1951  0b9b
   1952  0b9b		       ad bc 2c 	      lda	rtemp1
   1953  0b9e		       6d bf 2c 	      adc	random+1
   1954  0ba1		       8d bf 2c 	      sta	random+1
   1955  0ba4
   1956  0ba4		       68		      pla
   1957  0ba5
   1958  0ba5		       69 11		      adc	#$11
   1959  0ba7		       8d be 2c 	      sta	random
   1960  0baa		       ad bf 2c 	      lda	random+1
   1961  0bad		       69 36		      adc	#$36
   1962  0baf		       8d bf 2c 	      sta	random+1
   1963  0bb2
   1964  0bb2		       ad be 2c 	      lda	random
   1965  0bb5		       85 52		      sta	R0
   1966  0bb7		       ad bf 2c 	      lda	random+1
   1967  0bba		       29 7f		      and	#$7f	;make positive
   1968  0bbc		       85 53		      sta	R0+1
   1969  0bbe							;
   1970  0bbe							; R0 contains the number and R1 contains the max value.
   1971  0bbe							;
   1972  0bbe		       20 30 07 	      jsr	iDivNoPop
   1973  0bc1		       20 8a 1b 	      jsr	RestoreSigns
   1974  0bc4		       a5 56		      lda	MQ
   1975  0bc6		       85 52		      sta	R0
   1976  0bc8		       a5 57		      lda	MQ+1
   1977  0bca		       85 53		      sta	R0+1
   1978  0bcc		       4c 0a 07 	      jmp	pushR0nextIl
   1979  0bcf				   irandom1
   1980  0bcf		       a9 00		      lda	#0
   1981  0bd1		       85 53		      sta	R0+1
   1982  0bd3		       a9 01		      lda	#1
   1983  0bd5		       85 52		      sta	R0
   1984  0bd7		       4c 0a 07 	      jmp	pushR0nextIl
   1985  0bda
   1986  0bda							; The following replaced by call to division/modulo
   1987  0bda							;iRANDOM_2	lda	R0
   1988  0bda							;		cmp	R1
   1989  0bda							;		bne	iRANDOM_1
   1990  0bda							;		lda	R0+1
   1991  0bda							;		cmp	R1+1
   1992  0bda							;		bne	iRANDOM_1	;need to subtract
   1993  0bda							;
   1994  0bda							; Subtract R1 from R0
   1995  0bda							;
   1996  0bda							;iRANDOM_sub	sec
   1997  0bda							;		lda	R0
   1998  0bda							;		sbc	R1
   1999  0bda							;		sta	R0
   2000  0bda							;		lda	R0+1
   2001  0bda							;		sbc	R1+1
   2002  0bda							;		sta	R0+1
   2003  0bda							;		jmp	iRANDOM_2
   2004  0bda							;
   2005  0bda							; See if R1 > R0.  If so, branch to subtract.
   2006  0bda							;
   2007  0bda							;iRANDOM_1	lda	R0
   2008  0bda							;		cmp	R1
   2009  0bda							;		lda	R0+1
   2010  0bda							;		sbc	R1+1
   2011  0bda							;		bvc	iRANDOM_4
   2012  0bda							;		eor	#$80
   2013  0bda							;iRANDOM_4	bpl	iRANDOM_sub
   2014  0bda							;
   2015  0bda							; All done.  Almost.  Add one, then push the result.
   2016  0bda							;
   2017  0bda							;irandom1	inc	R0
   2018  0bda							;		bne	iRANDOM_3
   2019  0bda							;		inc	R0+1
   2020  0bda							;iRANDOM_3
   2021  0bda							;		  jsr	pushR0	;return value
   2022  0bda							;		jmp	NextIL
   2023  0bda							;
   2024  0bda							; Poke a value into a memory location
   2025  0bda		       8c c4 2c    iPOKEMEMORY sty	tempy
   2026  0bdd		       20 09 1b 	      jsr	popR0
   2027  0be0		       20 21 1b 	      jsr	popR1
   2028  0be3		       a0 00		      ldy	#0
   2029  0be5		       a5 52		      lda	R0
   2030  0be7		       91 54		      sta	(R1),y
   2031  0be9		       ac c4 2c 	      ldy	tempy
   2032  0bec		       4c c2 02 	      jmp	NextIL
   2033  0bef							;
   2034  0bef							; Get a value from a memory location
   2035  0bef							;
   2036  0bef		       8c c4 2c    iPEEKMEMORY sty	tempy
   2037  0bf2		       20 09 1b 	      jsr	popR0
   2038  0bf5		       a0 00		      ldy	#0
   2039  0bf7		       b1 52		      lda	(R0),y
   2040  0bf9		       ac c4 2c 	      ldy	tempy
   2041  0bfc		       85 52		      sta	R0
   2042  0bfe		       a9 00		      lda	#0
   2043  0c00		       85 53		      sta	R0+1
   2044  0c02		       4c 0a 07 	      jmp	pushR0nextIl
   2045  0c05							;
   2046  0c05							; Call to address return what ever is in a to the stack
   2047  0c05							; func2 will load a value into a before the call
   2048  0c05		       20 21 1b    iCallFunc  jsr	popR1
   2049  0c08		       a5 54		      lda	R1
   2050  0c0a		       20 16 0c 	      jsr	iCallRtn
   2051  0c0d		       85 52		      sta	R0
   2052  0c0f		       a9 00		      lda	#0
   2053  0c11		       85 53		      sta	R0+1
   2054  0c13		       20 0a 07 	      jsr	pushR0nextIl
   2055  0c16				   iCallRtn
   2056  0c16		       20 09 1b 	      jsr	popR0
   2057  0c19		       6c 52 00 	      jmp	(R0)
   2058  0c1c
   2059  0c1c
   2060  0c1c							;===========================================jlit======
   2061  0c1c							;Get a character from the terminal convert to value
   2062  0c1c							;leave the number on top of the stack
   2063  0c1c							;
   2064  0c1c				   iGETCHAR
   2065  0c1c		       20 0e 1d 	      jsr	VGETCH
   2066  0c1f					      if	CTMON65
   2067  0c1f		       48		      pha
   2068  0c20		       20 0b 1d 	      jsr	VOUTCH	;echo echo echo
   2069  0c23		       68		      pla
   2070  0c24					      endif
   2071  0c24		       85 52		      sta	R0
   2072  0c26		       a9 00		      lda	#0
   2073  0c28		       85 53		      sta	R0+1
   2074  0c2a		       20 85 1a 	      jsr	pushR0
   2075  0c2d							;
   2076  0c2d		       4c c2 02 	      jmp	NextIL
   2077  0c30							;===========================================jusilostintim======
   2078  0c30							;Put a character to the terminal convert to
   2079  0c30							;
   2080  0c30		       20 09 1b    iPUTCHAR   jsr	popR0
   2081  0c33		       a5 52		      lda	R0
   2082  0c35		       20 0b 1d 	      jsr	VOUTCH
   2083  0c38		       4c c2 02 	      jmp	NextIL
   2084  0c3b							;=====================================================
   2085  0c3b							; Put the number on the stack out as hex, suppress leading 0
   2086  0c3b				   iHexOut
   2087  0c3b		       20 09 1b 	      jsr	popR0
   2088  0c3e		       a5 53		      lda	R0+1
   2089  0c40		       f0 03		      beq	iHexSecondByte
   2090  0c42		       20 24 13 	      jsr	OUTHEX
   2091  0c45				   iHexSecondByte
   2092  0c45		       a5 52		      lda	R0
   2093  0c47		       20 24 13 	      jsr	OUTHEX
   2094  0c4a		       4c c2 02 	      jmp	NextIL
   2095  0c4d							;
   2096  0c4d							;=====================================================
   2097  0c4d							; Replace TOS with its absolute value.
   2098  0c4d							;
   2099  0c4d		       20 09 1b    iABS       jsr	popR0
   2100  0c50		       a5 53		      lda	R0+1
   2101  0c52		       10 10		      bpl	iABS_1	;already positive
   2102  0c54		       49 ff		      eor	#$ff
   2103  0c56		       85 53		      sta	R0+1
   2104  0c58		       a5 52		      lda	R0
   2105  0c5a		       49 ff		      eor	#$ff
   2106  0c5c		       85 52		      sta	R0
   2107  0c5e		       e6 52		      inc	R0
   2108  0c60		       d0 02		      bne	iABS_1
   2109  0c62		       e6 53		      inc	R0+1
   2110  0c64		       4c 0a 07    iABS_1     jmp	pushR0nextIl
   2111  0c67
   2112  0c67							;
   2113  0c67							;================================================================
   2114  0c67							; The set of logical operators
   2115  0c67				   iLogAnd
   2116  0c67		       20 09 1b 	      jsr	popR0
   2117  0c6a		       20 21 1b 	      jsr	popR1
   2118  0c6d		       a5 52		      lda	R0
   2119  0c6f		       25 54		      and	R1
   2120  0c71		       85 52		      sta	R0
   2121  0c73		       a5 53		      lda	R0+1
   2122  0c75		       25 55		      and	R1+1
   2123  0c77		       85 53		      sta	R0+1
   2124  0c79		       4c 0a 07 	      jmp	pushR0nextIl
   2125  0c7c				   iLogOr
   2126  0c7c		       20 09 1b 	      jsr	popR0
   2127  0c7f		       20 21 1b 	      jsr	popR1
   2128  0c82		       a5 52		      lda	R0
   2129  0c84		       05 54		      ora	R1
   2130  0c86		       85 52		      sta	R0
   2131  0c88		       a5 53		      lda	R0+1
   2132  0c8a		       05 55		      ora	R1+1
   2133  0c8c		       85 53		      sta	R0+1
   2134  0c8e		       4c 0a 07 	      jmp	pushR0nextIl
   2135  0c91				   iLogXor
   2136  0c91		       20 09 1b 	      jsr	popR0
   2137  0c94		       20 21 1b 	      jsr	popR1
   2138  0c97		       a5 52		      lda	R0
   2139  0c99		       45 54		      eor	R1
   2140  0c9b		       85 52		      sta	R0
   2141  0c9d		       a5 53		      lda	R0+1
   2142  0c9f		       45 55		      eor	R1+1
   2143  0ca1		       85 53		      sta	R0+1
   2144  0ca3		       4c 0a 07 	      jmp	pushR0nextIl
   2145  0ca6				   iLogNot
   2146  0ca6		       20 09 1b 	      jsr	popR0
   2147  0ca9		       a5 52		      lda	R0
   2148  0cab		       49 ff		      eor	#$FF
   2149  0cad		       85 52		      sta	R0
   2150  0caf		       a5 53		      lda	R0+1
   2151  0cb1		       49 ff		      eor	#$FF
   2152  0cb3		       85 53		      sta	R0+1
   2153  0cb5		       4c 0a 07 	      jmp	pushR0nextIl
   2154  0cb8
   2155  0cb8				   iTruth
   2156  0cb8		       a9 ff		      lda	#$FF
   2157  0cba		       85 52		      sta	R0
   2158  0cbc		       85 53		      sta	R0+1
   2159  0cbe		       4c 0a 07 	      jmp	pushR0nextIl
   2160  0cc1				   iFalse
   2161  0cc1		       a9 00		      lda	#$00
   2162  0cc3		       85 52		      sta	R0
   2163  0cc5		       85 53		      sta	R0+1
   2164  0cc7		       4c 0a 07 	      jmp	pushR0nextIl
   2165  0cca
   2166  0cca							;================================================================
   2167  0cca							;Set the IRQ service rtn line number
   2168  0cca							;
   2169  0cca		       78	   iSetIrq    sei		; disable the interupts
   2170  0ccb		       a9 00		      lda	#0	; Zero the Status flag
   2171  0ccd		       8d 6f 23 	      sta	IRQStatus
   2172  0cd0		       20 09 1b 	      jsr	popR0	; get the line number
   2173  0cd3		       a5 52		      lda	R0
   2174  0cd5		       05 53		      ora	R0+1
   2175  0cd7		       f0 20		      beq	iSetExt	; if it is zero disable all
   2176  0cd9		       20 9f 1a 	      jsr	pushLN	; Save the current line pointer
   2177  0cdc		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2178  0cde		       4c 6c 0b 	      jmp	ErrStkOver	; Check if there was an error
   2179  0ce1				   iSetIrqOk
   2180  0ce1		       20 d1 18 	      jsr	findLine	; Find the IRQ func Line Pointer
   2181  0ce4		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2182  0ce6		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2183  0ce8		       8d 72 23 	      sta	IRQEntry+1
   2184  0ceb		       a5 4f		      lda	CURPTR
   2185  0ced		       8d 71 23 	      sta	IRQEntry
   2186  0cf0		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2187  0cf2		       8d 6f 23 	      sta	IRQStatus
   2188  0cf5		       20 c4 1a 	      jsr	popLN	; Restore the old line number
   2189  0cf8		       58		      cli		; Enable the interupts
   2190  0cf9		       4c c2 02    iSetExt    jmp	NextIL
   2191  0cfc
   2192  0cfc		       20 c4 1a    iSetIrqErr jsr	popLN
   2193  0cff		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2194  0d01		       a9 00		      lda	#0
   2195  0d03		       4c 1f 06 	      jmp	iErr2
   2196  0d06							;
   2197  0d06		       20 09 1b    iTRACEPROG jsr	popR0
   2198  0d09		       a5 52		      lda	R0
   2199  0d0b		       85 40		      sta	ILTrace
   2200  0d0d		       4c c2 02 	      jmp	NextIL
   2201  0d10
   2202  0d10							;=====================================================
   2203  0d10							; Define start of non page zero data
   2204 U2cd6 ????				      seg.u	TBData
   2205 U235e					      org	PROGEND
   2206 U235e							;=================================================================
   2207 U235e							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U235e					      include	"tokenizer.asm"
      1  0d10					      seg	Code
      2  0d10		       ff ff ff ff DEBUGPARSER equ	TRUE	; Print debugging information
      3  0d10
      4  0d10							; Define the types of tokens found, and identifiers
      5  0d10		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0d10		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0d10		       00 82	   tVb	      equ	130	; Variables 128 - 157	$80-$9D
      8  0d10		       00 9b	   tVhat      equ	155	; Variable ^
      9  0d10		       00 9c	   tVhash     equ	156	; Variable #
     10  0d10		       00 9d	   tVat       equ	157	; Variable @ = 0
     11  0d10
     12  0d10
     13  0d10		       00 a0	   tString    equ	$A0	; String all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     14  0d10		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     15  0d10		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     16  0d10		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     17  0d10							; Arrays of string are arrays of pointers 2 bytes
     18  0d10		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     19  0d10		       00 a5	   tVariable  equ	$A5	; Variable index  = A-Z and ^ variables
     20  0d10		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     21  0d10
     22  0d10		       3c 3e 3c 3d*Operators  BYTE.b	"<>","<=",">=",'+,0,'<,0,'=,0,">",0,"-",0,"/",0,"%",0,"*",0,"(",0,")",0,",",0,";",0,"[",0,"]",0
     23  0d10		       00 22	   OperatorLen equ	*-Operators
     24  0d32
     25  0d32		       f5 f3 f6 f0*OperValues BYTE.b	$F5,$F3,$F6,$F0,$F1,$F2,$F4,$F7,$F8,$F9,$FA,$E0,$E1,$E2,$E3,$E4,$E5
     26  0d32		       00 11	   OPCount    equ	* - OperValues
     27  0d43
     28  0d43		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     29  0d43
     30  0d43		       00 ff	   tError     equ	$FF	; Error should never happen
     31  0d43							;
     32  0d43							; Keyword table contains 48 keywords
     33  0d43				   KeyWordTable
      0  0d43					      db	"leT"	; 1, we only have 0 at end of program or line
      1  0d43		       6c 65 54 	      .byte.b	"leT"
      0  0d46					      db	"inC"
      1  0d46		       69 6e 43 	      .byte.b	"inC"
      0  0d49					      db	"deC"
      1  0d49		       64 65 43 	      .byte.b	"deC"
      0  0d4c					      db	"ireturN"
      1  0d4c		       69 72 65 74*	      .byte.b	"ireturN"
      0  0d53					      db	"iF"
      1  0d53		       69 46		      .byte.b	"iF"
      0  0d55					      db	"theN"
      1  0d55		       74 68 65 4e	      .byte.b	"theN"
      0  0d59					      db	"gotO"
      1  0d59		       67 6f 74 4f	      .byte.b	"gotO"
      0  0d5d					      db	"gosuB"
      1  0d5d		       67 6f 73 75*	      .byte.b	"gosuB"
      0  0d62					      db	"returN"
      1  0d62		       72 65 74 75*	      .byte.b	"returN"
      0  0d68					      db	"reM"
      1  0d68		       72 65 4d 	      .byte.b	"reM"
     44  0d68		       00 0a	   kRem       equ	10
      0  0d6b					      db	"prinT"
      1  0d6b		       70 72 69 6e*	      .byte.b	"prinT"
     46  0d6b		       00 0b	   kPrint     equ	11	; should be entry for print
      0  0d70					      db	"taskE"
      1  0d70		       74 61 73 6b*	      .byte.b	"taskE"
      0  0d75					      db	"taskN"
      1  0d75		       74 61 73 6b*	      .byte.b	"taskN"
      0  0d7a					      db	"taskW"
      1  0d7a		       74 61 73 6b*	      .byte.b	"taskW"
      0  0d7f					      db	"pokE"
      1  0d7f		       70 6f 6b 45	      .byte.b	"pokE"
      0  0d83					      db	"putcH"
      1  0d83		       70 75 74 63*	      .byte.b	"putcH"
      0  0d88					      db	"clS"
      1  0d88		       63 6c 53 	      .byte.b	"clS"
      0  0d8b					      db	"inpuT"
      1  0d8b		       69 6e 70 75*	      .byte.b	"inpuT"
      0  0d90					      db	"enD"
      1  0d90		       65 6e 44 	      .byte.b	"enD"
      0  0d93					      db	"irQ"
      1  0d93		       69 72 51 	      .byte.b	"irQ"
      0  0d96					      db	"kilL"
      1  0d96		       6b 69 6c 4c	      .byte.b	"kilL"
      0  0d9a					      db	"lisT"
      1  0d9a		       6c 69 73 54	      .byte.b	"lisT"
      0  0d9e					      db	"ruN"
      1  0d9e		       72 75 4e 	      .byte.b	"ruN"
      0  0da1					      db	"neW"
      1  0da1		       6e 65 57 	      .byte.b	"neW"
      0  0da4					      db	"slicE"
      1  0da4		       73 6c 69 63*	      .byte.b	"slicE"
      0  0da9					      db	"tracE"
      1  0da9		       74 72 61 63*	      .byte.b	"tracE"
      0  0dae					      db	"exiT"
      1  0dae		       65 78 69 54	      .byte.b	"exiT"
      0  0db2					      db	"savE"
      1  0db2		       73 61 76 45	      .byte.b	"savE"
      0  0db6					      db	"loaD"
      1  0db6		       6c 6f 61 44	      .byte.b	"loaD"
      0  0dba					      db	"erasE"
      1  0dba		       65 72 61 73*	      .byte.b	"erasE"
      0  0dbf					      db	"noT"
      1  0dbf		       6e 6f 54 	      .byte.b	"noT"
      0  0dc2					      db	"oR"
      1  0dc2		       6f 52		      .byte.b	"oR"
      0  0dc4					      db	"xoR"
      1  0dc4		       78 6f 52 	      .byte.b	"xoR"
      0  0dc7					      db	"anD"
      1  0dc7		       61 6e 44 	      .byte.b	"anD"
      0  0dca					      db	"truE"
      1  0dca		       74 72 75 45	      .byte.b	"truE"
      0  0dce					      db	"falsE"
      1  0dce		       66 61 6c 73*	      .byte.b	"falsE"
      0  0dd3					      db	"diR"
      1  0dd3		       64 69 52 	      .byte.b	"diR"
     73  0dd6							;functions returning values
      0  0dd6					      db	"freE"
      1  0dd6		       66 72 65 45	      .byte.b	"freE"
      0  0dda					      db	"getcH"
      1  0dda		       67 65 74 63*	      .byte.b	"getcH"
      0  0ddf					      db	"peeK"
      1  0ddf		       70 65 65 4b	      .byte.b	"peeK"
      0  0de3					      db	"tasK"
      1  0de3		       74 61 73 4b	      .byte.b	"tasK"
      0  0de7					      db	"ipcc"
      1  0de7		       69 70 63 63	      .byte.b	"ipcc"
      0  0deb					      db	"ipcS"
      1  0deb		       69 70 63 53	      .byte.b	"ipcS"
      0  0def					      db	"ipcR"
      1  0def		       69 70 63 52	      .byte.b	"ipcR"
      0  0df3					      db	"rnD"
      1  0df3		       72 6e 44 	      .byte.b	"rnD"
      0  0df6					      db	"staT"
      1  0df6		       73 74 61 54	      .byte.b	"staT"
      0  0dfa					      db	"abS"
      1  0dfa		       61 62 53 	      .byte.b	"abS"
      0  0dfd					      db	"calL"
      1  0dfd		       63 61 6c 4c	      .byte.b	"calL"
      0  0e01					      db	"gofN"
      1  0e01		       67 6f 66 4e	      .byte.b	"gofN"
      0  0e05					      db	0,0
      1  0e05		       00 00		      .byte.b	0,0
     87  0e05		       0e 07	   KeyWordTableEnd equ	*
     88  0e05		       00 c4	   KeyWordTableLength equ	* - KeyWordTable
     89  0e07		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
     90  0f07		       00 00 00    printStorage ds	3
     91  0f0a							;==================================================================================================================
     92  0f0a							; Read accross the inputline and output to TOKENBUFFER
     93  0f0a							; Format   byte      Description
     94  0f0a							;	     0	      length of line 1-255
     95  0f0a							;	    0-1       Line Number
     96  0f0a							;	    Tokens and litteral values encoded into the line
     97  0f0a							;
     98  0f0a							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
     99  0f0a							;  if fails then test for keywords
    100  0f0a							;  if fails then test for variables and arrays
    101  0f0a							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    102  0f0a				   ParseInputLine
    103  0f0a					      if	DEBUGPARSER
    104  0f0a		       20 3b 1d 	      jsr	SetOutDebug
    105  0f0d		       20 b2 10 	      jsr	DebugClearBuffer
    106  0f10					      endif
    107  0f10		       a5 51		      lda	CUROFF
    108  0f12		       48		      pha
    109  0f13		       8a		      txa
    110  0f14		       48		      pha
    111  0f15		       98		      tya
    112  0f16		       48		      pha
    113  0f17		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    114  0f19		       20 37 19 	      jsr	getDecimal	; Check for a line number, none is ok too
    115  0f1c		       84 51		      sty	CUROFF
    116  0f1e		       20 29 11 	      jsr	R02TOKEN	; Move R0 to token buffer
    117  0f21
    118  0f21				   ParseInputLoop
    119  0f21		       a4 51		      ldy	CUROFF
    120  0f23		       20 b9 1b 	      jsr	SkipSpaces	; Skip any spaces
    121  0f26		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    122  0f28		       b9 2f 2c 	      lda	LINBUF,y	; Check for end of line
    123  0f2b		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    124  0f2d
    125  0f2d				   ParseForNumber
    126  0f2d		       20 11 10 	      jsr	ParseNumeric	; Check for a numeric value
    127  0f30		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    128  0f32
    129  0f32				   ParseForString
    130  0f32		       20 e7 0f 	      jsr	ParseString	; Check for a string
    131  0f35		       90 ea		      bcc	ParseInputLoop	; It was a string
    132  0f37
    133  0f37				   ParseForOp
    134  0f37		       20 4f 10 	      jsr	ParseForOperator	; Check for operator or punctuation
    135  0f3a		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    136  0f3c
    137  0f3c				   ParseForKey
    138  0f3c		       20 6b 0f 	      jsr	ParseLookupKey	; Check for a keyword value
    139  0f3f		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    140  0f41
    141  0f41				   ParseForVar
    142  0f41		       20 f2 10 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    143  0f44		       90 db		      bcc	ParseInputLoop
    144  0f46
    145  0f46				   ParseKeepChar		; if it does not parse just keep it safe
    146  0f46		       b9 2f 2c 	      lda	LINBUF,y
    147  0f49		       9d 07 0e 	      sta	TOKENBUFFER,x
    148  0f4c		       e8		      inx
    149  0f4d		       c8		      iny
    150  0f4e		       84 51		      sty	CUROFF
    151  0f50		       d0 cf		      bne	ParseInputLoop
    152  0f52
    153  0f52				   ParseComplete
    154  0f52		       8e 07 0e 	      stx	TOKENBUFFER	; Place size into buffer start
    155  0f55		       a9 00		      lda	#0
    156  0f57		       9d 07 0e 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    157  0f5a		       68		      pla
    158  0f5b		       a8		      tay
    159  0f5c		       68		      pla
    160  0f5d		       aa		      tax
    161  0f5e		       68		      pla
    162  0f5f		       85 51		      sta	CUROFF
    163  0f61					      if	DEBUGPARSER
    164  0f61
    165  0f61		       20 c4 10 	      jsr	printTokenBuffer
    166  0f64		       20 46 11 	      jsr	PrintProgramLine
    167  0f67		       20 f1 1c 	      jsr	SetOutConsole
    168  0f6a
    169  0f6a					      endif
    170  0f6a		       60		      rts
    171  0f6b
    172  0f6b							;==================================================================================================================
    173  0f6b							; Look at curptr, curpos and check for a valid KeyWord
    174  0f6b							; A contains the index value. c is clear
    175  0f6b							;		     not found c set  A undefined
    176  0f6b							; X is prerserved
    177  0f6b							;
    178  0f6b				   ParseLookupKey
    179  0f6b		       86 58		      stx	R2
    180  0f6d		       a4 51		      ldy	CUROFF
    181  0f6f		       a2 00		      ldx	#0
    182  0f71		       a9 01		      lda	#1
    183  0f73		       85 52		      sta	R0	; at the end this will contain the index of the keyword
    184  0f75					      if	DEBUGPARSER
    185  0f75							;  jsr DebugKeyword
    186  0f75					      endif
    187  0f75		       a9 3f		      lda	#'?	; check for fast form of print
    188  0f77		       d9 2f 2c 	      cmp	LINBUF,y
    189  0f7a		       d0 04		      bne	ParseLookupLoop	; Skip to loop if not ?
    190  0f7c		       a9 0b		      lda	#kPrint	; Number for print
    191  0f7e		       d0 29		      bne	ParseKeySpecial	; Get out with the special case
    192  0f80
    193  0f80				   ParseLookupLoop
    194  0f80		       bd 43 0d 	      lda	KeyWordTable,x	; Check both upper and lower characters
    195  0f83		       29 df		      and	#%11011111	; Force Keyword to upper case
    196  0f85		       d9 2f 2c 	      cmp	LINBUF,y
    197  0f88		       f0 07		      beq	ParseNextLetter
    198  0f8a		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    199  0f8c		       d9 2f 2c 	      cmp	LINBUF,y
    200  0f8f		       d0 23		      bne	ParseNextEntry
    201  0f91
    202  0f91				   ParseNextLetter
    203  0f91		       bd 43 0d 	      lda	KeyWordTable,x	; Check if we just processed the last letter
    204  0f94		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    205  0f96		       f0 0b		      beq	ParseKeyFound
    206  0f98		       e8		      inx
    207  0f99		       c8		      iny
    208  0f9a		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    209  0f9c		       d9 2f 2c 	      cmp	LINBUF,y
    210  0f9f		       f0 13		      beq	ParseNextEntry	; End of buffer but no keyword
    211  0fa1		       d0 dd		      bne	ParseLookupLoop
    212  0fa3
    213  0fa3				   ParseKeyFound
    214  0fa3		       a5 52		      lda	R0	; get the keyword index
    215  0fa5		       c9 0a		      cmp	#kRem	; remark statement
    216  0fa7		       f0 25		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    217  0fa9
    218  0fa9				   ParseKeySpecial
    219  0fa9		       c8		      iny		; point past the last character
    220  0faa		       84 51		      sty	CUROFF
    221  0fac		       a6 58		      ldx	R2	; preserved the X pointer
    222  0fae		       9d 07 0e 	      sta	TOKENBUFFER,x
    223  0fb1		       e8		      inx
    224  0fb2		       18		      clc
    225  0fb3		       60		      rts
    226  0fb4
    227  0fb4							; Move forward to the next entry in table
    228  0fb4				   ParseNextEntry
    229  0fb4		       bd 43 0d 	      lda	KeyWordTable,x
    230  0fb7		       29 20		      and	#%00100000
    231  0fb9		       f0 03		      beq	ParseEndOfEntry
    232  0fbb		       e8		      inx
    233  0fbc		       d0 f6		      bne	ParseNextEntry
    234  0fbe
    235  0fbe				   ParseEndOfEntry
    236  0fbe		       e8		      inx
    237  0fbf					      if	DEBUGPARSER
    238  0fbf							;    jsr DebugKeyword
    239  0fbf					      endif
    240  0fbf		       e6 52		      inc	R0	; Point to next index
    241  0fc1		       a4 51		      ldy	CUROFF	; Restore Y to start of the parse
    242  0fc3		       bd 43 0d 	      lda	KeyWordTable,x
    243  0fc6		       f0 02		      beq	ParseNoneFound
    244  0fc8		       d0 b6		      bne	ParseLookupLoop
    245  0fca
    246  0fca				   ParseNoneFound
    247  0fca		       a6 58		      ldx	R2
    248  0fcc		       38		      sec
    249  0fcd		       60		      rts
    250  0fce
    251  0fce							;===============================================================================
    252  0fce							; Move everything from current position until the end of line into the token buffer
    253  0fce							;
    254  0fce		       c8	   ParseMoveLine iny		; next byte to parse
    255  0fcf		       a6 58		      ldx	R2	; where to place in the buffer
    256  0fd1		       a5 52		      lda	R0
    257  0fd3		       9d 07 0e 	      sta	TOKENBUFFER,x	;Put the rem into the buffer
    258  0fd6		       e8		      inx		;Skip to next byte after the reM
    259  0fd7				   ParseMoveLoop
    260  0fd7		       b9 2f 2c 	      lda	LINBUF,y	; get the next byte
    261  0fda		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    262  0fdc		       9d 07 0e 	      sta	TOKENBUFFER,x	; save the byte
    263  0fdf		       c8		      iny
    264  0fe0		       e8		      inx
    265  0fe1		       d0 f4		      bne	ParseMoveLoop
    266  0fe3				   ParseMoveDone
    267  0fe3		       84 51		      sty	CUROFF
    268  0fe5		       18		      clc
    269  0fe6		       60		      rts
    270  0fe7
    271  0fe7							;=========================================================================================================
    272  0fe7							;ParseString Parse a quotes string
    273  0fe7							; on input X = outbuf position
    274  0fe7							; y = inbuf position
    275  0fe7							; Copies string to output buffer, updates x and y
    276  0fe7				   ParseString
    277  0fe7		       a4 51		      ldy	CUROFF
    278  0fe9		       a9 a0		      lda	#tString
    279  0feb		       9d 07 0e 	      sta	TOKENBUFFER,X
    280  0fee		       b9 2f 2c 	      lda	LINBUF,y
    281  0ff1		       c9 22		      cmp	#'"
    282  0ff3		       d0 1a		      bne	ParseStringInvalid
    283  0ff5		       e8		      inx
    284  0ff6		       9d 07 0e 	      sta	TOKENBUFFER,x
    285  0ff9		       e8		      inx
    286  0ffa		       c8		      iny
    287  0ffb
    288  0ffb				   ParseStringLoop
    289  0ffb		       b9 2f 2c 	      lda	LINBUF,y
    290  0ffe		       9d 07 0e 	      sta	TOKENBUFFER,x
    291  1001		       c9 22		      cmp	#'"
    292  1003		       f0 04		      beq	ParseStringDone
    293  1005		       c8		      iny
    294  1006		       e8		      inx
    295  1007		       d0 f2		      bne	ParseStringLoop
    296  1009
    297  1009				   ParseStringDone
    298  1009		       e8		      inx
    299  100a		       c8		      iny
    300  100b		       84 51		      sty	CUROFF
    301  100d		       18		      clc
    302  100e		       60		      rts
    303  100f
    304  100f				   ParseStringInvalid
    305  100f		       38		      sec
    306  1010		       60		      rts
    307  1011
    308  1011							;=========================================================================================================
    309  1011							; Get numeric values and return value in RO and type in a
    310  1011							;
    311  1011				   ParseNumeric
    312  1011		       a4 51		      ldy	CUROFF
    313  1013		       b9 2f 2c 	      lda	LINBUF,y
    314  1016		       c9 30		      cmp	#'0
    315  1018		       90 33		      bcc	ParseNumInvalid
    316  101a		       c9 3a		      cmp	#'9+1
    317  101c		       b0 2f		      bcs	ParseNumInvalid
    318  101e		       86 58		      stx	R2
    319  1020		       20 37 19 	      jsr	getDecimal
    320  1023		       a6 58		      ldx	R2
    321  1025		       84 51		      sty	CUROFF
    322  1027		       a5 53		      lda	R0+1
    323  1029		       f0 14		      beq	ParseByteValue
    324  102b
    325  102b				   ParseIntegerValue
    326  102b		       a9 a1		      lda	#tInteger
    327  102d		       9d 07 0e 	      sta	TOKENBUFFER,x
    328  1030		       e8		      inx
    329  1031		       a5 52		      lda	R0
    330  1033		       9d 07 0e 	      sta	TOKENBUFFER,x
    331  1036		       e8		      inx
    332  1037		       a5 53		      lda	R0+1
    333  1039		       9d 07 0e 	      sta	TOKENBUFFER,X
    334  103c		       e8		      inx
    335  103d		       18		      clc
    336  103e		       60		      rts
    337  103f
    338  103f				   ParseByteValue
    339  103f		       a9 a2		      lda	#tByte
    340  1041		       9d 07 0e 	      sta	TOKENBUFFER,x
    341  1044		       e8		      inx
    342  1045		       a5 52		      lda	R0
    343  1047		       9d 07 0e 	      sta	TOKENBUFFER,x
    344  104a		       e8		      inx
    345  104b		       18		      clc
    346  104c		       60		      rts
    347  104d
    348  104d				   ParseNumInvalid		;Not a valid Numeric
    349  104d		       38		      sec
    350  104e		       60		      rts
    351  104f
    352  104f							;=========================================================================================================
    353  104f							;Parse for operators
    354  104f							; +($F0), <($F1),=($F2),<=($F3), >($F4), <>($F5), >=($F6), -($F7), /($F8), %($F9), *($FA), (($FB), )($FC)
    355  104f							; on exit the A has the oper code, c is clear
    356  104f							;		 not found then c is set
    357  104f							;	x is preserved
    358  104f							;
    359  104f							;Operators: BYTE "<>","<=",">=",'+,0,'<,0,'=,0,">",0,"-",0,"/",0,"%",0,"*",0,"(",0,")",0,",",0,";",0,"[",0,"]",0
    360  104f							;OperatorLen equ *-Operators
    361  104f							;
    362  104f							;OperValues BYTE  $F5,$F3,$F6,$F0,$F1,$F2,$F4,$F7,$F8,$F9,$FA,$E0,$E1,$E2,$E3,$E4,$E5
    363  104f							;OPCount    equ   * - OperValues
    364  104f
    365  104f				   ParseForOperator
    366  104f		       86 58		      stx	R2
    367  1051		       a4 51		      ldy	CUROFF
    368  1053		       a6 00		      ldx	0
    369  1055					      if	DEBUGPARSER
    370  1055							; jsr	  DebugPrintOP
    371  1055					      endif
    372  1055				   ParseOpLoop
    373  1055		       bd 10 0d 	      lda	Operators,x
    374  1058		       d9 2f 2c 	      cmp	LINBUF,y
    375  105b		       d0 1c		      bne	ParseOpNext
    376  105d		       c8		      iny
    377  105e		       bd 11 0d 	      lda	Operators+1,x
    378  1061		       f0 06		      beq	ParseOpFoundSingle
    379  1063		       d9 2f 2c 	      cmp	LINBUF,y
    380  1066		       d0 11		      bne	ParseOpNext
    381  1068
    382  1068				   ParseOpFound
    383  1068		       c8		      iny
    384  1069
    385  1069				   ParseOpFoundSingle
    386  1069		       84 51		      sty	CUROFF
    387  106b
    388  106b		       8a		      txa
    389  106c		       4a		      lsr
    390  106d		       aa		      tax
    391  106e		       bd 32 0d 	      lda	OperValues,x
    392  1071		       a6 58		      ldx	R2
    393  1073		       9d 07 0e 	      sta	TOKENBUFFER,x
    394  1076		       e8		      inx
    395  1077		       18		      clc
    396  1078		       60		      rts
    397  1079
    398  1079				   ParseOpNext
    399  1079		       e8		      inx
    400  107a		       e8		      inx
    401  107b		       e0 22		      cpx	#OperatorLen
    402  107d		       b0 04		      bcs	ParseOpNotFound
    403  107f					      if	DEBUGPARSER
    404  107f							;   jsr    DebugPrintOP
    405  107f					      endif
    406  107f		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    407  1081		       d0 d2		      bne	ParseOpLoop
    408  1083
    409  1083				   ParseOpNotFound
    410  1083		       a6 58		      ldx	R2
    411  1085		       38		      sec
    412  1086		       60		      rts
    413  1087							;=========================================================================================================
    414  1087					      if	DEBUGPARSER
    415  1087							;Print the text of a keyword
    416  1087							;Input x = offset into table
    417  1087				   DebugKeyword
    418  1087		       48		      pha
    419  1088		       8a		      txa
    420  1089		       48		      pha
    421  108a				   DebugKeyLoop
    422  108a		       bd 43 0d 	      lda	KeyWordTable,x
    423  108d		       20 0b 1d 	      jsr	VOUTCH
    424  1090		       29 20		      and	#%00100000
    425  1092		       f0 03		      beq	DebugKeyDone
    426  1094		       e8		      inx
    427  1095		       d0 f3		      bne	DebugKeyLoop
    428  1097
    429  1097				   DebugKeyDone
    430  1097		       20 c2 1b 	      jsr	CRLF
    431  109a		       68		      pla
    432  109b		       aa		      tax
    433  109c		       68		      pla
    434  109d		       60		      rts
    435  109e							;========================================
    436  109e				   DebugPrintOP
    437  109e		       48		      pha
    438  109f		       bd 10 0d 	      lda	Operators,x
    439  10a2		       20 0b 1d 	      jsr	VOUTCH
    440  10a5		       bd 11 0d 	      lda	Operators+1,x
    441  10a8		       f0 03		      beq	DbgPrtOpDone
    442  10aa		       20 0b 1d 	      jsr	VOUTCH
    443  10ad
    444  10ad				   DbgPrtOpDone
    445  10ad		       20 c2 1b 	      jsr	CRLF
    446  10b0		       68		      pla
    447  10b1		       60		      rts
    448  10b2							;=======================================
    449  10b2				   DebugClearBuffer
    450  10b2		       8a		      txa
    451  10b3		       48		      pha
    452  10b4		       a2 ff		      ldx	#$FF
    453  10b6		       a9 00		      lda	#0
    454  10b8				   DebugClrLoop
    455  10b8		       9d 07 0e 	      sta	TOKENBUFFER,x
    456  10bb		       ca		      dex
    457  10bc		       d0 fa		      bne	DebugClrLoop
    458  10be		       9d 07 0e 	      sta	TOKENBUFFER,x
    459  10c1		       68		      pla
    460  10c2		       aa		      tax
    461  10c3		       60		      rts
    462  10c4
    463  10c4							;=====================================================
    464  10c4							; Print the parser buffer as hex values
    465  10c4				   printTokenBuffer
    466  10c4		       8e 07 0f 	      stx	printStorage
    467  10c7		       8c 08 0f 	      sty	printStorage+1
    468  10ca		       8d 09 0f 	      sta	printStorage+2
    469  10cd
    470  10cd		       ae 07 0e 	      ldx	TOKENBUFFER	; get the length of the buffer
    471  10d0		       e8		      inx		; we want to show the last zero byte
    472  10d1		       a0 00		      ldy	#0
    473  10d3
    474  10d3				   printHexLoop
    475  10d3		       b9 07 0e 	      lda	TOKENBUFFER,y	; get the character
    476  10d6		       20 24 13 	      jsr	HexToOut	; print it
    477  10d9		       a9 20		      lda	#$20
    478  10db		       20 0b 1d 	      jsr	VOUTCH
    479  10de		       c8		      iny
    480  10df		       ca		      dex
    481  10e0		       e0 00		      cpx	#0
    482  10e2		       d0 ef		      bne	printHexLoop
    483  10e4		       20 c2 1b 	      jsr	CRLF
    484  10e7
    485  10e7		       ac 08 0f 	      ldy	printStorage+1
    486  10ea		       ae 07 0f 	      ldx	printStorage
    487  10ed		       ad 09 0f 	      lda	printStorage+2
    488  10f0				   printHexDone
    489  10f0		       18		      clc
    490  10f1		       60		      rts
    491  10f2					      endif
    492  10f2
    493  10f2
    494  10f2							;=========================================================================================================
    495  10f2							; Parse for variables A-Z @, ^  x!x x[op]
    496  10f2				   ParseForVariable
    497  10f2		       a4 51		      ldy	CUROFF
    498  10f4		       b9 2f 2c 	      lda	LINBUF,y
    499  10f7		       c9 5e		      cmp	#'^	; is it an exit code
    500  10f9		       d0 04		      bne	ParseVarMem
    501  10fb		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    502  10fd		       d0 1f		      bne	ParseVarSpecial
    503  10ff
    504  10ff				   ParseVarMem
    505  10ff		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    506  1101		       d0 04		      bne	ParseVarStack
    507  1103		       a9 9d		      lda	#tVat
    508  1105		       d0 17		      bne	ParseVarSpecial
    509  1107
    510  1107				   ParseVarStack
    511  1107		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    512  1109		       d0 04		      bne	ParseVarLetters
    513  110b		       a9 9c		      lda	#tVhash
    514  110d		       d0 0f		      bne	ParseVarSpecial
    515  110f
    516  110f				   ParseVarLetters
    517  110f		       29 df		      and	#%11011111	; Force upper case
    518  1111		       c9 41		      cmp	#'A
    519  1113		       90 12		      bcc	ParseVarInvalid
    520  1115		       c9 5b		      cmp	#'Z+1
    521  1117		       b0 0e		      bcs	ParseVarInvalid
    522  1119							;
    523  1119							; The condition is true, so convert to an index, push
    524  1119							; it onto the stack and continue running.
    525  1119							;
    526  1119		       38		      sec
    527  111a		       e9 41		      sbc	#'A	;index is zero based
    528  111c		       09 80		      ora	#$80
    529  111e
    530  111e				   ParseVarSpecial
    531  111e		       9d 07 0e 	      sta	TOKENBUFFER,x
    532  1121		       e8		      inx
    533  1122		       c8		      iny
    534  1123		       84 51		      sty	CUROFF
    535  1125		       18		      clc
    536  1126		       60		      rts
    537  1127
    538  1127				   ParseVarInvalid
    539  1127		       38		      sec
    540  1128		       60		      rts
    541  1129
    542  1129
    543  1129							;=========================================================================================================
    544  1129							; Transfer R0 to the TOKENBUFFER
    545  1129							;
    546  1129				   R02TOKEN
    547  1129		       a5 52		      lda	R0
    548  112b		       9d 07 0e 	      sta	TOKENBUFFER,x
    549  112e		       e8		      inx
    550  112f		       a5 53		      lda	R0+1
    551  1131		       9d 07 0e 	      sta	TOKENBUFFER,x
    552  1134		       e8		      inx
    553  1135		       18		      clc
    554  1136		       60		      rts
    555  1137				   TOKEN2R0
    556  1137		       b9 07 0e 	      lda	TOKENBUFFER,y
    557  113a		       85 52		      sta	R0
    558  113c		       c8		      iny
    559  113d		       ca		      dex
    560  113e		       b9 07 0e 	      lda	TOKENBUFFER,y
    561  1141		       c8		      iny
    562  1142		       ca		      dex
    563  1143		       85 53		      sta	R0+1
    564  1145		       60		      rts
    565  1146
    566  1146							;==========================================================================================================
    567  1146							; Decode and print a line of grogram text
    568  1146							; Prints line number from R0 upto line number in R1 if r1 is 0 then prints to end
    569  1146							; if R0 and R1 = 0 then print entire program.
    570  1146							;
    571  1146				   PrintProgramLine
    572  1146
    573  1146		       8e 07 0f 	      stx	printStorage
    574  1149		       8c 08 0f 	      sty	printStorage+1
    575  114c		       48		      pha
    576  114d
    577  114d		       a0 01		      ldy	#1	; index into the token buffer
    578  114f		       84 58		      sty	R2	; print unsigned decimal
    579  1151		       ae 07 0e 	      ldx	TOKENBUFFER	; get number of bytes
    580  1154		       ca		      dex		; Deduct the length byte
    581  1155		       20 37 11 	      jsr	TOKEN2R0	; Print the line number
    582  1158		       20 72 12 	      jsr	PrintDecimal
    583  115b		       a9 20		      lda	#$20
    584  115d		       20 0b 1d 	      jsr	VOUTCH
    585  1160
    586  1160				   PrintProgLoop
    587  1160		       b9 07 0e 	      lda	TOKENBUFFER,y	; Get a character
    588  1163		       f0 40		      beq	PrintProgramComplete
    589  1165		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    590  1167		       f0 6c		      beq	PrintKeyword	; It uses the index in a to find a keyword
    591  1169
    592  1169				   PrintProgVars
    593  1169		       b9 07 0e 	      lda	TOKENBUFFER,y
    594  116c		       29 e0		      and	#$E0	; Check for operators and punctuation
    595  116e		       c9 e0		      cmp	#$E0
    596  1170		       f0 60		      beq	PrintProgOperatorVect
    597  1172		       b9 07 0e 	      lda	TOKENBUFFER,y
    598  1175		       c9 9e		      cmp	#$9D+1
    599  1177		       90 57		      bcc	PrintProgVariableVec
    600  1179		       c9 a0		      cmp	#tString
    601  117b		       f0 33		      beq	PrintStringVariable
    602  117d		       c8		      iny		; we have a numerical value
    603  117e		       ca		      dex
    604  117f		       48		      pha
    605  1180		       a9 00		      lda	#0
    606  1182		       85 53		      sta	R0+1
    607  1184		       85 58		      sta	R2	; Set to print signed number
    608  1186		       b9 07 0e 	      lda	TOKENBUFFER,y
    609  1189		       85 52		      sta	R0
    610  118b		       68		      pla
    611  118c		       c9 a1		      cmp	#tInteger
    612  118e		       d0 07		      bne	PrintProgNumDone
    613  1190		       c8		      iny
    614  1191		       ca		      dex
    615  1192		       b9 07 0e 	      lda	TOKENBUFFER,y
    616  1195		       85 53		      sta	R0+1
    617  1197
    618  1197				   PrintProgNumDone
    619  1197		       c8		      iny
    620  1198		       ca		      dex
    621  1199		       20 72 12 	      jsr	PrintDecimal
    622  119c
    623  119c				   PrintProgNext
    624  119c		       a9 20		      lda	#$20
    625  119e		       20 0b 1d 	      jsr	VOUTCH
    626  11a1				   PrintProgSkipSpace
    627  11a1		       e0 00		      cpx	#0
    628  11a3		       d0 bb		      bne	PrintProgLoop
    629  11a5				   PrintProgramComplete
    630  11a5		       20 c2 1b 	      jsr	CRLF
    631  11a8
    632  11a8		       ae 07 0f 	      ldx	printStorage
    633  11ab		       ac 08 0f 	      ldy	printStorage+1
    634  11ae		       68		      pla
    635  11af
    636  11af		       60		      rts
    637  11b0							;=================================================================================================================
    638  11b0							; Print a string variable including the quotes
    639  11b0				   PrintStringVariable
    640  11b0		       c8		      iny
    641  11b1		       a9 22		      lda	#'"
    642  11b3		       20 0b 1d 	      jsr	VOUTCH
    643  11b6		       c8		      iny
    644  11b7		       a9 07		      lda	#TOKENBUFFER&$FF
    645  11b9		       85 5e		      sta	PrtFrom
    646  11bb		       a9 0e		      lda	#TOKENBUFFER>>8
    647  11bd		       85 5f		      sta	PrtFrom+1
    648  11bf		       a9 22		      lda	#'"
    649  11c1		       8d c4 2c 	      sta	PrtTerm
    650  11c4		       20 86 13 	      jsr	PrtLoop
    651  11c7		       a9 22		      lda	#'"
    652  11c9		       20 0b 1d 	      jsr	VOUTCH
    653  11cc		       c8		      iny
    654  11cd		       4c 9c 11 	      jmp	PrintProgNext
    655  11d0
    656  11d0
    657  11d0				   PrintProgVariableVec
    658  11d0		       90 78		      bcc	PrintProgVariable
    659  11d2				   PrintProgOperatorVect
    660  11d2		       4c 20 12 	      jmp	PrintProgOperator
    661  11d5							;===============================================================================================================
    662  11d5				   PrintKeyword
    663  11d5
    664  11d5		       b9 07 0e 	      lda	TOKENBUFFER,y
    665  11d8		       ca		      dex
    666  11d9		       c8		      iny
    667  11da		       85 52		      sta	R0	; the counter save area
    668  11dc		       85 53		      sta	R0+1	; to refer to later if needed
    669  11de		       8e 09 0f 	      stx	printStorage+2
    670  11e1
    671  11e1		       a2 00		      ldx	#0
    672  11e3				   PrintKeyLoop
    673  11e3		       c6 52		      dec	R0	; Keyword indexes are 1 relative, adjust to zero relative
    674  11e5		       a9 00		      lda	#0
    675  11e7		       c5 52		      cmp	R0
    676  11e9		       f0 0a		      Beq	PrintKeyFound	; We have the correct index, now print it
    677  11eb				   PrintKeyNext
    678  11eb		       bd 43 0d 	      lda	KeyWordTable,x
    679  11ee		       e8		      inx		; Point to next byte always
    680  11ef		       29 20		      and	#%00100000
    681  11f1		       f0 f0		      beq	PrintKeyLoop
    682  11f3		       d0 f6		      bne	PrintKeyNext
    683  11f5
    684  11f5				   PrintKeyFound
    685  11f5		       bd 43 0d 	      lda	KeyWordTable,x
    686  11f8		       48		      pha
    687  11f9		       09 20		      ora	#%00100000
    688  11fb		       20 0b 1d 	      jsr	VOUTCH
    689  11fe		       e8		      inx
    690  11ff		       68		      pla
    691  1200		       29 20		      and	#%00100000
    692  1202		       d0 f1		      bne	PrintKeyFound
    693  1204		       ae 09 0f 	      ldx	printStorage+2
    694  1207				   PrintChkRem
    695  1207		       a9 0a		      lda	#kRem
    696  1209		       c5 53		      cmp	R0+1
    697  120b		       d0 10		      bne	PrintKeyDone
    698  120d				   PrintKeyRem
    699  120d		       a9 07		      lda	#TOKENBUFFER&$FF	; if it is a rem then we must print the entire line
    700  120f		       85 5e		      sta	PrtFrom
    701  1211		       a9 0e		      lda	#TOKENBUFFER>>8
    702  1213		       85 5f		      sta	PrtFrom+1
    703  1215		       a9 00		      lda	#0
    704  1217		       8d c4 2c 	      sta	PrtTerm
    705  121a		       20 86 13 	      jsr	PrtLoop
    706  121d				   PrintKeyDone
    707  121d		       4c 9c 11 	      jmp	PrintProgNext
    708  1220							;==================================================================================================================
    709  1220							;Print Variable, number or operator
    710  1220				   PrintProgOperator
    711  1220		       b9 07 0e 	      lda	TOKENBUFFER,y
    712  1223		       c8		      iny
    713  1224		       ca		      dex
    714  1225		       8e 09 0f 	      stx	printStorage+2
    715  1228		       a2 00		      ldx	#0
    716  122a				   PrintOprLoop
    717  122a		       dd 32 0d 	      cmp	OperValues,x
    718  122d		       f0 03		      beq	PrintOprFound
    719  122f		       e8		      inx
    720  1230		       d0 f8		      bne	PrintOprLoop
    721  1232				   PrintOprFound
    722  1232		       8a		      txa
    723  1233		       0a		      asl
    724  1234		       aa		      tax
    725  1235		       bd 10 0d 	      lda	Operators,x
    726  1238		       20 0b 1d 	      jsr	VOUTCH
    727  123b		       e8		      inx
    728  123c		       bd 10 0d 	      lda	Operators,x
    729  123f		       f0 03		      beq	PrintOprDone
    730  1241		       20 0b 1d 	      jsr	VOUTCH
    731  1244				   PrintOprDone
    732  1244		       ae 09 0f 	      ldx	printStorage+2
    733  1247		       4c 9c 11 	      jmp	PrintProgNext
    734  124a
    735  124a							;=================================================================================================================
    736  124a							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    737  124a							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    738  124a							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    739  124a							;tVhat 	    equ     155 		   ; Variable ^
    740  124a							;tVhash	    equ     156 		   ; Variable #
    741  124a							;tVat		    equ     157 		   ; Variable @ = 0
    742  124a				   PrintProgVariable
    743  124a		       b9 07 0e 	      lda	TOKENBUFFER,y
    744  124d		       c8		      iny
    745  124e		       ca		      dex
    746  124f		       c5 9b		      cmp	tVhat
    747  1251		       d0 04		      bne	PrintProgChkHash
    748  1253		       a9 5e		      lda	#'^
    749  1255		       d0 15		      bne	PrintTheVar
    750  1257				   PrintProgChkHash
    751  1257		       c5 9c		      cmp	tVhash
    752  1259		       d0 04		      bne	PrintProgChkAt
    753  125b		       a9 23		      lda	#'#
    754  125d		       d0 0d		      bne	PrintTheVar
    755  125f				   PrintProgChkAt
    756  125f		       c5 9d		      cmp	tVat
    757  1261		       d0 04		      bne	PrintProgVarLetter
    758  1263		       a9 40		      lda	#'@
    759  1265		       d0 05		      bne	PrintTheVar
    760  1267				   PrintProgVarLetter
    761  1267		       29 7f		      and	#%01111111
    762  1269		       18		      clc
    763  126a		       69 41		      adc	#'A
    764  126c				   PrintTheVar
    765  126c		       20 0b 1d 	      jsr	VOUTCH
    766  126f		       4c 9c 11 	      jmp	PrintProgNext
    767  1272
    768  1272
    769  1272
    770  1272
    771  1272
    772  1272
    773  1272
    774  1272
    775  1272
    776  1272
    777  1272
    778  1272
    779  1272
    780  1272
    781  1272
    782  1272
    783  1272
    784  1272
    785  1272
    786  1272
    787  1272
    788  1272
    789  1272
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  1272					      include	"print.asm"
      1  1272					      Seg	Code
      2  1272							;---------------------------
      3  1272							; Print 24-bit decimal number or  16bit unsigned
      4  1272							; ---------------------------
      5  1272							; On entry, R0=number to print
      6  1272							;	     Defaults to pad=0 , y=21 default
      7  1272							;	     R2 = 1 unsigned 16 bit
      8  1272							;	     R2 = 0 Signed   16 bit
      9  1272
     10  1272							; On entry at PrintDecPadded:
     11  1272							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  1272
     13  1272							; On exit,  A,X,Y,num,pad corrupted
     14  1272							; Size      129 bytes, Table 24 bytes	--- total 153
     15  1272							; -----------------------------------------------------------------
     16  1272
     17  1272				   PrintDecimal
     18  1272		       8a		      TXA
     19  1273		       48		      pha
     20  1274		       98		      tya
     21  1275		       48		      pha
     22  1276		       a9 00		      lda	#0
     23  1278		       8d 0b 13 	      sta	pad
     24  127b		       a0 15		      LDY	#21	; Offset to powers of ten
     25  127d		       4c 83 12 	      JMP	PrintDo
     26  1280
     27  1280				   PrintDecPadded
     28  1280		       8e 0b 13 	      stx	pad
     29  1283
     30  1283				   PrintDo
     31  1283		       a9 00		      lda	#0
     32  1285		       85 54		      sta	R1
     33  1287
     34  1287		       a5 58		      lda	R2
     35  1289		       d0 29		      bne	PrintPos
     36  128b
     37  128b		       a5 53		      lda	R0+1	;MSB has sign
     38  128d		       10 25		      bpl	PrintPos	;it's a positive number;
     39  128f
     40  128f
     41  128f							; Negative numbers need more work.  Invert all the bits,
     42  128f							; then add one.
     43  128f
     44  128f		       a9 2d		      lda	#'-
     45  1291		       20 0b 1d 	      jsr	VOUTCH	;print the negative sign
     46  1294
     47  1294		       a9 ff		      lda	#$FF
     48  1296		       85 54		      sta	R1
     49  1298		       a5 52		      lda	R0	;invert bits
     50  129a		       49 ff		      eor	#$ff
     51  129c		       85 52		      sta	R0
     52  129e		       a5 53		      lda	R0+1
     53  12a0		       49 ff		      eor	#$ff
     54  12a2		       85 53		      sta	R0+1
     55  12a4		       a5 54		      lda	R1
     56  12a6		       49 ff		      eor	#$ff
     57  12a8		       85 54		      sta	R1
     58  12aa		       e6 52		      inc	R0	;add one
     59  12ac		       d0 06		      bne	PrintPos
     60  12ae		       e6 53		      inc	R0+1
     61  12b0		       d0 02		      bne	PrintPos
     62  12b2		       e6 54		      inc	R1
     63  12b4				   PrintPos
     64  12b4
     65  12b4				   PrDec24Lp1
     66  12b4		       a2 ff		      LDX	#$FF
     67  12b6		       38		      SEC		; Start with digit=-1
     68  12b7				   PrDec24Lp2
     69  12b7		       a5 52		      LDA	R0+0
     70  12b9		       f9 0c 13 	      SBC	PrDec24Tens+0,Y
     71  12bc		       85 52		      STA	R0+0	; Subtract current tens
     72  12be		       a5 53		      LDA	R0+1
     73  12c0		       f9 0d 13 	      SBC	PrDec24Tens+1,Y
     74  12c3		       85 53		      STA	R0+1
     75  12c5		       a5 54		      LDA	R0+2
     76  12c7		       f9 0e 13 	      SBC	PrDec24Tens+2,Y
     77  12ca		       85 54		      STA	R0+2
     78  12cc		       e8		      INX
     79  12cd		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  12cf		       a5 52		      LDA	R0+0
     81  12d1		       79 0c 13 	      ADC	PrDec24Tens+0,Y
     82  12d4		       85 52		      STA	R0+0	; Add current tens back in
     83  12d6		       a5 53		      LDA	R0+1
     84  12d8		       79 0d 13 	      ADC	PrDec24Tens+1,Y
     85  12db		       85 53		      STA	R0+1
     86  12dd		       a5 54		      LDA	R0+2
     87  12df		       79 0e 13 	      ADC	PrDec24Tens+2,Y
     88  12e2		       85 54		      STA	R0+2
     89  12e4		       8a		      TXA
     90  12e5		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  12e7		       ad 0b 13 	      LDA	pad
     92  12ea		       d0 09		      BNE	PrDec24Print
     93  12ec		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  12ee				   PrDec24Digit
     95  12ee		       a2 30		      LDX	#'0
     96  12f0		       8e 0b 13 	      STX	pad	; No more zero padding
     97  12f3		       09 30		      ORA	#'0	; Print this digit
     98  12f5				   PrDec24Print
     99  12f5		       20 0b 1d 	      JSR	VOUTCH
    100  12f8				   PrDec24Next
    101  12f8		       88		      DEY
    102  12f9		       88		      DEY
    103  12fa		       88		      DEY
    104  12fb		       f0 07		      beq	PrDec24LastDigit
    105  12fd		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  12ff		       68		      pla
    107  1300		       a8		      tay
    108  1301		       68		      pla
    109  1302		       aa		      tax
    110  1303		       60		      RTS
    111  1304				   PrDec24LastDigit
    112  1304		       a2 30		      LDX	#'0
    113  1306		       8e 0b 13 	      STX	pad	; No more zero padding
    114  1309		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  130b
      0  130b				   pad	      db	0
      1  130b		       00		      .byte.b	0
    117  130c				   PrDec24Tens
      0  130c					      dw	1
      1  130c		       01 00		      .word.w	1
      0  130e					      db	1 / 65536
      1  130e		       00		      .byte.b	1 / 65536
      0  130f					      dw	10
      1  130f		       0a 00		      .word.w	10
      0  1311					      db	10 / 65536
      1  1311		       00		      .byte.b	10 / 65536
      0  1312					      dw	100
      1  1312		       64 00		      .word.w	100
      0  1314					      db	100 / 65536
      1  1314		       00		      .byte.b	100 / 65536
      0  1315					      dw	1000
      1  1315		       e8 03		      .word.w	1000
      0  1317					      db	1000 / 65536
      1  1317		       00		      .byte.b	1000 / 65536
      0  1318					      dw	10000
      1  1318		       10 27		      .word.w	10000
      0  131a					      db	10000 / 65536
      1  131a		       00		      .byte.b	10000 / 65536
      0  131b					      dw	100000
      1  131b		       a0 86		      .word.w	100000
      0  131d					      db	100000 / 65536
      1  131d		       01		      .byte.b	100000 / 65536
      0  131e					      dw	1000000
      1  131e		       40 42		      .word.w	1000000
      0  1320					      db	1000000 / 65536
      1  1320		       0f		      .byte.b	1000000 / 65536
      0  1321					      dw	10000000
      1  1321		       80 96		      .word.w	10000000
      0  1323					      db	10000000 / 65536
      1  1323		       98		      .byte.b	10000000 / 65536
    134  1324							;=====================================================
    135  1324							; Print character in A as two hex digits to the
    136  1324
    137  1324		       48	   HexToOut   pha		;save return value
    138  1325		       48		      pha
    139  1326		       4a		      lsr		;a  ;move top nibble to bottom
    140  1327		       4a		      lsr		;a
    141  1328		       4a		      lsr		;a
    142  1329		       4a		      lsr		;a
    143  132a		       20 33 13 	      jsr	hexta	;output nibble
    144  132d		       68		      pla
    145  132e		       20 33 13 	      jsr	hexta
    146  1331		       68		      pla		;restore
    147  1332		       60		      rts
    148  1333							;
    149  1333		       29 0f	   hexta      and	#%0001111
    150  1335		       c9 0a		      cmp	#$0a
    151  1337		       18		      clc
    152  1338		       30 02		      bmi	hexta1
    153  133a		       69 07		      adc	#7
    154  133c		       69 30	   hexta1     adc	#'0	;then fall into...
    155  133e		       4c 0b 1d 	      jmp	VOUTCH
    156  1341							;
    157  1341							;=====================================================
    158  1341							; Print the string that immediately follows the JSR to
    159  1341							; this function.  Stops when a null byte is found,
    160  1341							; then returns to the instruction immediately
    161  1341							; following the null.
    162  1341							;
    163  1341							; Thanks to Ross Archer for this code.
    164  1341							; http://www.6502.org/source/io/primm.htm
    165  1341							;
    166  1341
    167  1341		       68	   tbputs     pla		;Get the low part of "return" address
    168  1342							;(data start address)
    169  1342		       85 5e		      sta	PrtFrom
    170  1344		       68		      pla
    171  1345		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    172  1347							;(data start address)
    173  1347							;Note: actually we're pointing one short
    174  1347		       a0 01	   PSINB      ldy	#1
    175  1349		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    176  134b		       e6 5e		      inc	PrtFrom	;update the pointer
    177  134d		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    178  134f		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    179  1351		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    180  1353							;   Accumulator
    181  1353		       f0 06		      beq	PSIX1	;don't print the final NULL
    182  1355		       20 0b 1d 	      jsr	VOUTCH	;write it out
    183  1358		       4c 47 13 	      jmp	PSINB	;back around
    184  135b		       e6 5e	   PSIX1      inc	PrtFrom
    185  135d		       d0 02		      bne	PSIX2
    186  135f		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    187  1361		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    188  1364
    189  1364							;+
    190  1364							;====================================================
    191  1364		       2c c4	   PrtTerm    equ	tempy
    192  1364
    193  1364							; on exit Print Y has the offset to use
    194  1364							; input y =	 addr low
    195  1364							;	 x =	 addr high
    196  1364							;	 a =	 termination string
    197  1364
    198  1364				   PrtPrgLine
    199  1364		       a9 00		      lda	#0
    200  1366		       8d c4 2c 	      sta	PrtTerm
    201  1369		       f0 05		      beq	PrtPrgText
    202  136b
    203  136b		       a9 22	   PrtQuoted  lda	#'"
    204  136d		       8d c4 2c 	      sta	PrtTerm
    205  1370
    206  1370		       a4 51	   PrtPrgText ldy	CUROFF
    207  1372		       a5 4f		      lda	CURPTR
    208  1374		       85 5e		      sta	PrtFrom
    209  1376		       a5 50		      lda	CURPTR+1
    210  1378		       85 5f		      sta	PrtFrom+1
    211  137a		       4c 86 13 	      jmp	PrtLoop
    212  137d
    213  137d							; Print a string pointed to by x= h, y=l terminated by a
    214  137d							; Return y as the length
    215  137d
    216  137d		       86 5f	   PrtStr     stx	PrtFrom+1
    217  137f		       84 5e		      sty	PrtFrom
    218  1381		       8d c4 2c 	      sta	PrtTerm
    219  1384		       a0 00		      ldy	#0
    220  1386							;
    221  1386							; On entry here ptrfrom and prtterm point to area to print
    222  1386							;
    223  1386		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    224  1388		       cd c4 2c 	      cmp	PrtTerm
    225  138b		       f0 0b		      beq	PrtEnd
    226  138d		       c9 00		      cmp	#0	; always end if 0 is found
    227  138f		       f0 07		      beq	PrtEnd
    228  1391		       20 0b 1d 	      jsr	VOUTCH
    229  1394		       c8		      iny
    230  1395		       4c 86 13 	      jmp	PrtLoop
    231  1398		       c8	   PrtEnd     iny		;return byte after the copy
    232  1399		       60		      rts
    233  139a
    234  139a							;
    235  139a							;=======================================================
    236  139a							; Print all Variables
    237  139a				   PrintAllVars
    238  139a		       a0 00		      ldy	#0
    239  139c		       a9 41		      lda	#'A
    240  139e				   PrintAllVarsLoop
    241  139e		       48		      pha
    242  139f		       b1 41		      lda	(VARIABLES),y
    243  13a1		       85 52		      sta	R0
    244  13a3		       c8		      iny
    245  13a4		       b1 41		      lda	(VARIABLES),y
    246  13a6		       85 53		      sta	R0+1
    247  13a8
    248  13a8		       68		      pla		;get the current letter
    249  13a9		       48		      pha
    250  13aa		       20 0b 1d 	      jsr	VOUTCH
    251  13ad		       20 41 13 	      jsr	puts
      0  13b0					      db	"=",0
      1  13b0		       3d 00		      .byte.b	"=",0
    253  13b2		       68		      pla
    254  13b3		       aa		      tax
    255  13b4		       e8		      inx
    256  13b5		       8a		      txa
    257  13b6		       48		      pha		;
    258  13b7
    259  13b7		       98		      tya
    260  13b8		       48		      pha
    261  13b9		       20 72 12 	      jsr	PrintDecimal
    262  13bc		       20 41 13 	      jsr	puts
      0  13bf					      db	" ",0
      1  13bf		       20 00		      .byte.b	" ",0
    264  13c1		       68		      pla
    265  13c2		       a8		      tay
    266  13c3		       c8		      iny
    267  13c4		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    268  13c6		       90 d6		      bcc	PrintAllVarsLoop
    269  13c8		       20 c2 1b 	      jsr	CRLF
    270  13cb
    271  13cb		       68		      pla
    272  13cc		       60		      rts
    273  13cd
    274  13cd							;==================================================================================================
    275  13cd							; Size of print functions
    276  13cd		       01 5b	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  13cd					      include	"mem.asm"
      1  13cd							;===================================================================
      2  13cd							;This file contains the memory allocation and free functions
      3  13cd							;in herant in this is the management of free memory in the system
      4  13cd							; the interface to these functions
      5  13cd							; a,x returns or provides the low hi bytes of the managed addresses
      6  13cd							; This uses the programend, to memory end as the area to manage
      7  13cd							;===================================================================
      8  13cd					      Seg	Code
      9  13cd							;=====================================================
     10  13cd							;Pointers for memory Management
     11  13cd							;Allocated block are not chained but can be followed for all memory by the associated length
     12  13cd							; Mem block format is
     13  13cd							;	 0-1   pointer to next block for free blocks
     14  13cd							;	 0-1   for allocated blocks
     15  13cd							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  13cd							;	   1   refrence counter ... lol only up to 256 but it is something
     17  13cd							;	 2-3   length constant for exevy type of memory block
     18  13cd							; Memory is recombined as it is released
     19  13cd							; The memory manager is not interupted durring allocation
     20  13cd							; or freeing of memory
     21  13cd							; Memory is allocated from the highest memory address towards
     22  13cd							; the lowest memory address. meeting the Basic program end.
     23  13cd							;====================================================
     24  13cd							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  13cd							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  13cd							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  13cd							;=====================================================
     28  13cd				   MemInit
     29  13cd		       a9 d6		      lda	#FreeMemStart&$FF
     30  13cf		       8d cc 2c 	      sta	ProgramStart
     31  13d2		       8d ce 2c 	      sta	ProgramEnd
     32  13d5		       a9 2c		      lda	#FreeMemStart>>8
     33  13d7		       8d cd 2c 	      sta	ProgramStart+1
     34  13da		       8d cf 2c 	      sta	ProgramEnd+1
     35  13dd
     36  13dd		       20 e7 13 	      jsr	GetSizes
     37  13e0		       20 f2 13 	      jsr	MemFree
     38  13e3		       20 0a 14 	      jsr	MemUsed
     39  13e6				   MemInitEnd
     40  13e6		       60		      rts
     41  13e7
     42  13e7
     43  13e7							;
     44  13e7							;=====================================================
     45  13e7							; This function might go away eventually, but was
     46  13e7							; added to provide data for other pieces of code.
     47  13e7							; It has some ties to the operating environment that
     48  13e7							; will need to be customized for the target system.
     49  13e7							;
     50  13e7				   GetSizes
     51  13e7							;
     52  13e7							; Here is machine specific code to get the highest
     53  13e7							; memory location that can be used by BASIC.
     54  13e7							;
     55  13e7				  -	      if	ProgramStart < $2000
     56  13e7				  -	      lda	#$ff
     57  13e7				  -	      sta	HighMem	;$13ff for KIM-1
     58  13e7				  -	      sta	MemFreeList
     59  13e7				  -	      lda	#$DE	;#$13
     60  13e7				  -	      sta	HighMem+1
     61  13e7				  -	      sta	MemFreeList+1
     62  13e7					      else
     63  13e7		       a9 ff		      lda	#$ff
     64  13e9		       8d d0 2c 	      sta	HighMem	;$CFFF otherwise
     65  13ec		       a9 cf		      lda	#$cf
     66  13ee		       8d d1 2c 	      sta	HighMem+1
     67  13f1					      endif
     68  13f1		       60		      rts
     69  13f2							;
     70  13f2							; This computes the available memory remaining.
     71  13f2							;
     72  13f2				   MemFree
     73  13f2		       38		      sec
     74  13f3		       ad d0 2c 	      lda	HighMem
     75  13f6		       ed ce 2c 	      sbc	ProgramEnd
     76  13f9		       8d d4 2c 	      sta	FreeMem
     77  13fc		       85 52		      sta	R0
     78  13fe		       ad d1 2c 	      lda	HighMem+1
     79  1401		       ed cf 2c 	      sbc	ProgramEnd+1
     80  1404		       8d d5 2c 	      sta	FreeMem+1
     81  1407		       85 53		      sta	R0+1
     82  1409		       60		      rts
     83  140a							;
     84  140a							; This computes the size of the current user program.
     85  140a							;
     86  140a				   MemUsed
     87  140a		       38		      sec
     88  140b		       ad ce 2c 	      lda	ProgramEnd
     89  140e		       ed cc 2c 	      sbc	ProgramStart
     90  1411		       8d d2 2c 	      sta	UsedMem
     91  1414		       85 52		      sta	R0
     92  1416		       ad cf 2c 	      lda	ProgramEnd+1
     93  1419		       ed cd 2c 	      sbc	ProgramStart+1
     94  141c		       8d d3 2c 	      sta	UsedMem+1
     95  141f		       85 53		      sta	R0+1
     96  1421							;
     97  1421		       60		      rts
     98  1422
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  1422					      include	"gosub.asm"
      1  1422					      seg	Code
      2  1422
      3  1422							; Gosub and return related functions
      4  1422							;==========================================================
      5  1422							; Push the current math stack frame onto the gosub stack
      6  1422				   iPushMathStack
      7  1422		       98		      tya
      8  1423		       48		      pha
      9  1424		       a4 4d		      ldy	GOSUBSTACKPTR
     10  1426		       a5 4a		      lda	MATHSTACKPTR
     11  1428		       91 4b		      sta	(GOSUBSTACK),y
     12  142a		       a9 00		      lda	#0
     13  142c		       c8		      iny
     14  142d		       91 4b		      sta	(GOSUBSTACK),y
     15  142f		       c8		      iny
     16  1430		       91 4b		      sta	(GOSUBSTACK),y
     17  1432		       c8		      iny
     18  1433		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  1435		       91 4b		      sta	(GOSUBSTACK),y
     20  1437		       c8		      iny
     21  1438		       84 4d		      sty	GOSUBSTACKPTR
     22  143a		       68		      pla
     23  143b		       a8		      tay
     24  143c		       4c c2 02 	      jmp	NextIL
     25  143f							;
     26  143f							;==========================================================
     27  143f							; Increment parameter count. Assume Stack frame is top of stack
     28  143f				   iIncParmCount
     29  143f		       98		      tya
     30  1440		       48		      pha
     31  1441		       a4 4d		      ldy	GOSUBSTACKPTR
     32  1443		       88		      dey
     33  1444		       88		      dey
     34  1445		       88		      dey
     35  1446		       b1 4b		      lda	(GOSUBSTACK),y
     36  1448		       aa		      tax
     37  1449		       e8		      inx
     38  144a		       8a		      txa
     39  144b		       91 4b		      sta	(GOSUBSTACK),y
     40  144d		       68		      pla
     41  144e		       a8		      tay
     42  144f		       4c c2 02 	      jmp	NextIL
     43  1452							;
     44  1452							;==========================================================
     45  1452							;Restore the math stack frame
     46  1452		       20 58 14    iPopMathStack jsr	PopMathStackNow
     47  1455		       4c c2 02 	      jmp	NextIL
     48  1458
     49  1458				   PopMathStackNow
     50  1458		       98		      tya
     51  1459		       48		      pha
     52  145a
     53  145a		       a4 4d		      ldy	GOSUBSTACKPTR
     54  145c		       88		      dey
     55  145d		       b1 4b		      lda	(GOSUBSTACK),y
     56  145f		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  1461		       d0 09		      bne	iPopMathStackNoFrame
     58  1463		       88		      dey
     59  1464		       88		      dey
     60  1465		       88		      dey
     61  1466		       b1 4b		      lda	(GOSUBSTACK),y
     62  1468		       85 4a		      sta	MATHSTACKPTR
     63  146a		       84 4d		      sty	GOSUBSTACKPTR
     64  146c
     65  146c				   iPopMathStackNoFrame
     66  146c
     67  146c		       68		      pla
     68  146d		       a8		      tay
     69  146e		       60		      rts
     70  146f
     71  146f
     72  146f							;==========================================================
     73  146f							; Push the current math stack information onto the gosub stack
     74  146f				   iSaveMathStack
     75  146f		       98		      tya
     76  1470		       48		      pha
     77  1471		       a4 4d		      ldy	GOSUBSTACKPTR
     78  1473		       a5 4a		      lda	MATHSTACKPTR
     79  1475		       91 4b		      sta	(GOSUBSTACK),y
     80  1477		       a5 48		      lda	MATHSTACK
     81  1479		       c8		      iny
     82  147a
     83  147a		       91 4b		      sta	(GOSUBSTACK),y
     84  147c		       c8		      iny
     85  147d
     86  147d		       a5 49		      lda	MATHSTACK+1
     87  147f		       91 4b		      sta	(GOSUBSTACK),y
     88  1481		       c8		      iny
     89  1482
     90  1482		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  1484		       91 4b		      sta	(GOSUBSTACK),y
     92  1486		       c8		      iny
     93  1487
     94  1487		       84 4d		      sty	GOSUBSTACKPTR
     95  1489		       68		      pla
     96  148a		       a8		      tay
     97  148b		       4c c2 02 	      jmp	NextIL
     98  148e							;
     99  148e							;==========================================================
    100  148e							;Restore the math stack information from the gosub stack
    101  148e				   iRestoreMathStack
    102  148e		       98		      tya
    103  148f		       48		      pha
    104  1490
    105  1490		       a5 4a		      lda	MATHSTACKPTR
    106  1492		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  1494
    108  1494		       a4 4d		      ldy	GOSUBSTACKPTR
    109  1496		       88		      dey
    110  1497		       b1 4b		      lda	(GOSUBSTACK),y
    111  1499		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  149b		       d0 16		      bne	iPopMathStack_Err
    113  149d		       88		      dey
    114  149e		       b1 4b		      lda	(GOSUBSTACK),y
    115  14a0		       85 49		      sta	MATHSTACK+1
    116  14a2		       88		      dey
    117  14a3		       b1 4b		      lda	(GOSUBSTACK),y
    118  14a5		       85 48		      sta	MATHSTACK
    119  14a7		       88		      dey
    120  14a8		       b1 4b		      lda	(GOSUBSTACK),y
    121  14aa		       85 4a		      sta	MATHSTACKPTR
    122  14ac		       84 4d		      sty	GOSUBSTACKPTR
    123  14ae		       68		      pla
    124  14af		       a8		      tay
    125  14b0		       4c c2 02 	      jmp	NextIL
    126  14b3
    127  14b3				   iPopMathStack_Err
    128  14b3		       a9 00		      lda	#0
    129  14b5		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  14b7		       4c 1f 06 	      jmp	iErr2
    131  14ba							;=========================================
    132  14ba							; For functions and tasks the variable address of # means
    133  14ba							; a passed parameter so #[0] is the first parameter etc
    134  14ba							; will try for a better way later
    135  14ba
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  14ba					      include	"tasks.asm"
      1  14ba							;=====================================================
      2  14ba							; Tiny Basic IL task management
      3  14ba							; Data required by task management
      4  14ba							; currently each context is about 30 bytes and is swapped
      5  14ba							; into and out of page zero on each task switch....
      6  14ba							; LOL yes it is slow, but works for this iteration.
      7  14ba							;
      8  14ba
      9  14ba					      Seg	Code
     10  14ba							;=====================================================
     11  14ba							; Sets the pointers to the math,IL and gosub stacks
     12  14ba							; Creates the initial Context for each task slot
     13  14ba				   taskSetStacks
     14  14ba		       a9 73		      lda	#mathStack&$FF
     15  14bc		       85 48		      sta	MATHSTACK
     16  14be		       a9 24		      lda	#mathStack>>8
     17  14c0		       85 49		      sta	MATHSTACK+1
     18  14c2
     19  14c2		       a9 03		      lda	#ilStack&$ff
     20  14c4		       85 45		      sta	ILSTACK
     21  14c6		       a9 26		      lda	#ilStack>>8
     22  14c8		       85 46		      sta	ILSTACK+1
     23  14ca
     24  14ca		       a9 93		      lda	#gosubStack&$FF
     25  14cc		       85 4b		      sta	GOSUBSTACK
     26  14ce		       a9 27		      lda	#gosubStack>>8
     27  14d0		       85 4c		      sta	GOSUBSTACK+1
     28  14d2
     29  14d2		       a9 13		      lda	#variableStack&$FF
     30  14d4		       85 41		      sta	VARIABLES
     31  14d6		       a9 2a		      lda	#variableStack>>8
     32  14d8		       85 42		      sta	VARIABLES+1
     33  14da		       a2 0a		      ldx	#TASKCOUNT
     34  14dc		       a0 00		      ldy	#0
     35  14de		       20 69 17 	      jsr	ContextSave
     36  14e1
     37  14e1		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  14e3		       b0 3a		      bcs	taskSetDone
     39  14e5
     40  14e5		       a5 4b		      lda	GOSUBSTACK
     41  14e7		       18		      clc
     42  14e8		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  14ea		       85 4b		      sta	GOSUBSTACK
     44  14ec		       a5 4c		      lda	GOSUBSTACK+1
     45  14ee		       69 00		      adc	#0
     46  14f0		       85 4c		      sta	GOSUBSTACK+1
     47  14f2
     48  14f2		       a5 45		      lda	ILSTACK	; must be less than 256
     49  14f4		       18		      clc
     50  14f5		       69 28		      adc	#ILSTACKSIZE*2
     51  14f7		       85 45		      sta	ILSTACK
     52  14f9		       a5 46		      lda	ILSTACK+1
     53  14fb		       69 00		      adc	#0
     54  14fd		       85 46		      sta	ILSTACK+1
     55  14ff
     56  14ff		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  1501		       18		      clc
     58  1502		       69 28		      adc	#MATHSTACKSIZE*2
     59  1504		       85 48		      sta	MATHSTACK
     60  1506		       a5 49		      lda	MATHSTACK+1
     61  1508		       69 00		      adc	#0
     62  150a		       85 49		      sta	MATHSTACK+1
     63  150c
     64  150c		       a5 41		      lda	VARIABLES	; must be less than 256
     65  150e		       18		      clc
     66  150f		       69 36		      adc	#VARIABLESSIZE*2
     67  1511		       85 41		      sta	VARIABLES
     68  1513		       a5 42		      lda	VARIABLES+1
     69  1515		       69 00		      adc	#0
     70  1517		       85 42		      sta	VARIABLES+1
     71  1519
     72  1519		       20 69 17 	      jsr	ContextSave
     73  151c		       4c e1 14 	      jmp	taskSetLoop
     74  151f
     75  151f				   taskSetDone
     76  151f		       a0 00		      ldy	#0	; reload the main loop context
     77  1521		       20 78 17 	      jsr	ContextLoad
     78  1524		       60		      rts
     79  1525							;
     80  1525							;=====================================================
     81  1525							; In some error cases the math stacks may be left pointing to the wrong stack
     82  1525							; This function will reset those stack addresses but not the actual pointer
     83  1525				   taskResetStacks
     84  1525		       a0 00		      ldy	#0
     85  1527		       20 78 17 	      jsr	ContextLoad
     86  152a		       4c ba 14 	      jmp	taskSetStacks
     87  152d							;
     88  152d							;=====================================================
     89  152d							; Clear all task entries and task stacks
     90  152d		       98	   taskReset  tya		; Save Y
     91  152e		       48		      pha
     92  152f		       a9 01		      lda	#1
     93  1531		       8d 72 24 	      sta	taskCounter	; Set number of active tasks to 1
     94  1534		       ac 73 23 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  1537		       c0 00		      cpy	#0	; check if we are the main context
     96  1539		       f0 08		      beq	taskResetCont	; if we are just continue
     97  153b
     98  153b		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  153d		       8c 73 23 	      sty	taskPtr
    100  1540		       20 78 17 	      jsr	ContextLoad	; load the System Task context
    101  1543				   taskResetCont
    102  1543		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  1545
    104  1545				   taskResetLoop
    105  1545		       a9 00		      lda	#TASKINACTIVE
    106  1547		       99 74 23 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  154a		       18		      clc
    108  154b		       98		      tya
    109  154c		       69 19		      adc	#CONTEXTLEN+1
    110  154e		       a8		      tay
    111  154f		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  1551		       90 f2		      bcc	taskResetLoop	; Go for more
    113  1553
    114  1553				   taskResetComplete
    115  1553
    116  1553		       68		      pla		; Restore y
    117  1554		       a8		      tay
    118  1555		       60		      rts
    119  1556
    120  1556							;
    121  1556							;======================================================
    122  1556							; iTaskSwitch	 switch to new task if not interrupt and
    123  1556							;		 count is exceded for task time slice gets here
    124  1556							;		 when time slice has reached zero
    125  1556							;
    126  1556		       98	   iTaskSwitch tya
    127  1557		       48		      pha
    128  1558
    129  1558		       ad 70 24 	      lda	taskResetValue	; Always reset the counter value
    130  155b		       8d 6e 24 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  155e		       ce 6f 24 	      dec	taskCurrentCycles+1	; dec high order byte
    132  1561		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  1563
    134  1563		       ad 71 24 	      lda	taskResetValue+1
    135  1566		       8d 6f 24 	      sta	taskCurrentCycles+1
    136  1569
    137  1569		       ad 70 23 	      lda	IRQPending	; Skip this if we are processing an irq
    138  156c		       0d ca 2c 	      ora	taskIOPending	; If set then don't switch
    139  156f		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  1571
    141  1571		       ad 72 24    iTaskMain  lda	taskCounter	; Number of tasks
    142  1574		       c9 01		      cmp	#1	; if there is only one task must be main
    143  1576		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  1578
    145  1578		       ac 73 23 	      ldy	taskPtr	; check if we have not just ended some other task
    146  157b		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  157d		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  157f							;
    149  157f							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  157f							;
    151  157f				   itasknext
    152  157f		       ac 73 23 	      ldy	taskPtr
    153  1582		       20 69 17 	      jsr	ContextSave	; Save the current context, y points to next context
    154  1585				   itaskLoop
    155  1585		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  1587		       90 04		      bcc	iTaskNextChk
    157  1589
    158  1589		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  158b		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  158d
    161  158d				   iTaskNextChk
    162  158d		       b9 74 23 	      lda	taskTable,y	; there is always at least one entry in table
    163  1590		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  1592		       18	   iTaskNext  clc
    165  1593		       98		      tya
    166  1594		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  1596		       a8		      tay
    168  1597		       4c 85 15 	      jmp	itaskLoop	; Check for busy entry
    169  159a
    170  159a		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  159c		       59 74 23 	      eor	taskTable,y	; Check for anything waiting io
    172  159f		       d0 f1		      bne	iTaskNext
    173  15a1		       20 78 17 	      jsr	ContextLoad	; load the next context
    174  15a4		       8c 73 23 	      sty	taskPtr	; update the task pointer
    175  15a7
    176  15a7				   iTaskSwitchDone
    177  15a7		       68		      pla
    178  15a8		       a8		      tay
    179  15a9		       60		      rts
    180  15aa							;
    181  15aa							;================================================================
    182  15aa							; Task Set task number to line number to start
    183  15aa							; Task Table structure:
    184  15aa							;    byte 0	-   Active inactive
    185  15aa							;    byte 1-2	-   Basic code line pointer
    186  15aa							;    byte 3	-   Offset on current line
    187  15aa		       98	   iTaskSet   tya		;preserve Y
    188  15ab		       48		      pha		; push a
    189  15ac
    190  15ac		       20 09 1b 	      jsr	popR0	; Get the line number to be saved
    191  15af
    192  15af		       ac 73 23 	      ldy	taskPtr	; find out where we are
    193  15b2		       20 69 17 	      jsr	ContextSave	; Save the current context
    194  15b5
    195  15b5							;Find the pointer to the line we need to start at
    196  15b5		       20 d1 18 	      jsr	findLine	; Get the offset of the line to start task at
    197  15b8		       f0 0b		      beq	iTaskCont
    198  15ba
    199  15ba		       ac 73 23 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  15bd		       20 78 17 	      jsr	ContextLoad
    201  15c0
    202  15c0		       68		      pla		; pop a - exit
    203  15c1		       a8		      tay
    204  15c2		       4c fc 0c 	      jmp	iSetIrqErr	; Bad line number provided
    205  15c5
    206  15c5				   iTaskCont
    207  15c5		       20 3b 17 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  15c8		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  15ca
    210  15ca		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  15cc		       99 74 23 	      sta	taskTable,y	; new task as active
    212  15cf
    213  15cf		       a5 4f		      lda	CURPTR
    214  15d1		       48		      pha		; push a
    215  15d2		       a5 50		      lda	CURPTR+1
    216  15d4		       48		      pha		; push a
    217  15d5
    218  15d5		       20 78 17 	      jsr	ContextLoad	; load the context of the new task
    219  15d8
    220  15d8		       68		      pla		; pop a
    221  15d9		       85 50		      sta	CURPTR+1
    222  15db		       68		      pla		; pop a
    223  15dc		       85 4f		      sta	CURPTR
    224  15de		       a9 03		      lda	#3	; Offset to first instruction
    225  15e0		       85 51		      sta	CUROFF
    226  15e2
    227  15e2		       a9 00		      lda	#0
    228  15e4		       85 47		      sta	ILSTACKPTR
    229  15e6		       85 4a		      sta	MATHSTACKPTR
    230  15e8		       85 4d		      sta	GOSUBSTACKPTR
    231  15ea		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  15ec		       85 4e		      sta	MESSAGEPTR
    233  15ee
    234  15ee		       20 59 09 	      jsr	subVINIT	; Clear the variables
    235  15f1
    236  15f1		       a9 a0		      lda	#STMT&$FF
    237  15f3		       85 43		      sta	ILPC
    238  15f5		       a9 1e		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  15f7		       85 44		      sta	ILPC+1
    240  15f9
    241  15f9		       98		      tya		; Save the new context offset to return to user
    242  15fa		       48		      pha		; push a
    243  15fb
    244  15fb		       20 69 17    itaskSetSave jsr	ContextSave	; save the updated context
    245  15fe		       ee 72 24 	      inc	taskCounter	; Update the number of Tasks running
    246  1601
    247  1601		       ac 73 23 	      ldy	taskPtr
    248  1604		       20 78 17 	      jsr	ContextLoad	; restore the original context
    249  1607
    250  1607		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  1609		       85 53		      sta	R0+1
    252  160b		       68		      pla		; Get the task pid we stored				 ; pop a
    253  160c		       85 52		      sta	R0	; Get the table entry value
    254  160e
    255  160e		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  160f		       a8		      tay
    257  1610
    258  1610		       4c 0a 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  1613				   iTaskNoEmpty
    260  1613		       ac 73 23 	      ldy	taskPtr
    261  1616		       20 78 17 	      jsr	ContextLoad
    262  1619
    263  1619		       68		      pla		; pop a    -- exit
    264  161a		       a8		      tay
    265  161b
    266  161b		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  161d		       a9 00		      lda	#0
    268  161f		       4c 1f 06 	      jmp	iErr2
    269  1622							;
    270  1622							;===============================================================
    271  1622							; Run the task whos PID is on the stack, preserve the stack
    272  1622							;
    273  1622				   iTaskEnable
    274  1622		       98		      tya
    275  1623		       48		      pha
    276  1624		       20 21 1b 	      jsr	popR1
    277  1627		       20 ef 1a 	      jsr	pushR1
    278  162a		       20 6f 18 	      jsr	ipc_getcontext	; get context pointer into mq
    279  162d		       a0 00		      ldy	#0
    280  162f		       b1 56		      lda	(MQ),y
    281  1631		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  1633		       09 80		      ora	#TASKACTIVE
    283  1635		       91 56		      sta	(MQ),y
    284  1637		       68		      pla
    285  1638		       a8		      tay
    286  1639		       4c c2 02 	      jmp	NextIL
    287  163c
    288  163c							;
    289  163c							;===============================================================
    290  163c							; Suspend the task whos PID  is on the stack, preserve the stack
    291  163c							;
    292  163c				   iTaskSuspend
    293  163c		       98		      tya
    294  163d		       48		      pha
    295  163e		       20 21 1b 	      jsr	popR1
    296  1641		       20 ef 1a 	      jsr	pushR1
    297  1644		       20 6f 18 	      jsr	ipc_getcontext	; get context pointer into mq
    298  1647		       a0 00		      ldy	#0
    299  1649		       b1 56		      lda	(MQ),y
    300  164b		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  164d		       09 80		      ora	#TASKACTIVE
    302  164f		       68		      pla
    303  1650		       a8		      tay
    304  1651		       4c c2 02 	      jmp	NextIL
    305  1654
    306  1654							;================================================================
    307  1654							; Returns task Status
    308  1654				   iTaskStat
    309  1654		       98		      tya
    310  1655		       48		      pha
    311  1656		       20 68 16 	      jsr	iTaskValid	; returns pointer to task entry
    312  1659		       b9 74 23 	      lda	taskTable,y
    313  165c		       f0 05		      beq	iTaskStatExit
    314  165e		       68		      pla
    315  165f		       a8		      tay
    316  1660		       4c b8 0c 	      jmp	iTruth
    317  1663				   iTaskStatExit
    318  1663		       68		      pla
    319  1664		       a8		      tay
    320  1665		       4c c1 0c 	      jmp	iFalse
    321  1668
    322  1668							;
    323  1668							;================================================================
    324  1668							; Validate the task number on top of the stack
    325  1668							; on exit y points to the requested task entry
    326  1668							;
    327  1668		       20 09 1b    iTaskValid jsr	popR0	; get result of the multiply
    328  166b		       a5 53		      lda	R0+1
    329  166d		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  166f		       a5 52		      lda	R0
    331  1671		       c9 fa		      cmp	#TASKTABLELEN
    332  1673		       90 09		      bcc	iTaskIsValid
    333  1675
    334  1675		       68	   iTaskValidErr pla		;remove return address
    335  1676		       68		      pla
    336  1677		       a2 10		      ldx	#ERR_INVALID_PID
    337  1679		       a9 00		      lda	#0
    338  167b		       4c 1f 06 	      jmp	iErr2
    339  167e
    340  167e		       a8	   iTaskIsValid tay
    341  167f		       60		      rts
    342  1680							;
    343  1680							;================================================================
    344  1680							; Kill a running task, do nothing if already stopped
    345  1680		       20 68 16    iTaskKill  jsr	iTaskValid
    346  1683		       a9 00		      lda	#0
    347  1685		       99 74 23 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  1688							;
    349  1688							;================================================================
    350  1688							;Skip to next task
    351  1688				   iNTask
    352  1688		       a9 01		      lda	#1
    353  168a		       8d 6e 24 	      sta	taskCurrentCycles
    354  168d		       8d 6f 24 	      sta	taskCurrentCycles+1
    355  1690		       4c c2 02 	      jmp	NextIL
    356  1693							;
    357  1693							;=======================================================
    358  1693							; Wait for a task to complete
    359  1693				   iWTASK
    360  1693		       20 8c 18 	      jsr	getILByte
    361  1696		       8d c8 2c 	      sta	offset
    362  1699							;
    363  1699		       20 6f 1a 	      jsr	saveIL	;in case of failure
    364  169c
    365  169c		       20 68 16 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  169f		       b9 74 23 	      lda	taskTable,y
    367  16a2		       d0 03		      bne	iWTASKWAIT
    368  16a4				   iWTASKEXITED
    369  16a4		       4c c2 02 	      jmp	NextIL
    370  16a7				   iWTASKWAIT
    371  16a7		       20 85 1a 	      jsr	pushR0	; Push R0 back onto the stack
    372  16aa		       a9 01		      lda	#1
    373  16ac		       8d 6e 24 	      sta	taskCurrentCycles	; Give up the cycles
    374  16af		       8d 6f 24 	      sta	taskCurrentCycles+1
    375  16b2		       20 7a 1a 	      jsr	restoreIL
    376  16b5		       4c 1c 0b 	      jmp	tstBranch
    377  16b8							;
    378  16b8							;=======================================================
    379  16b8							; Set task io lock
    380  16b8		       ee ca 2c    iStartIO   inc	taskIOPending
    381  16bb		       4c c2 02 	      jmp	NextIL
    382  16be							;
    383  16be							;=======================================================
    384  16be							; Release the io lock
    385  16be		       ad ca 2c    iEndIO     lda	taskIOPending
    386  16c1		       f0 03		      beq	iEndIOExit
    387  16c3		       ce ca 2c 	      dec	taskIOPending
    388  16c6		       4c c2 02    iEndIOExit jmp	NextIL
    389  16c9							;
    390  16c9							;===============================================================
    391  16c9							; Return the task PID
    392  16c9				   iTASKPID
    393  16c9		       a9 00		      lda	#0
    394  16cb		       85 53		      sta	R0+1
    395  16cd		       ad 73 23 	      lda	taskPtr
    396  16d0		       85 52		      sta	R0
    397  16d2		       4c 0a 07 	      jmp	pushR0nextIl
    398  16d5							;
    399  16d5							;================================================================
    400  16d5							; Terminate a task
    401  16d5		       ac 73 23    iETask     ldy	taskPtr
    402  16d8		       c0 00		      cpy	#0
    403  16da		       d0 03		      bne	iETaskCont
    404  16dc		       4c 08 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  16df				   iETaskCont
    406  16df		       a9 00		      lda	#TASKINACTIVE
    407  16e1		       99 74 23 	      sta	taskTable,y	; mark entry as free
    408  16e4		       ce 72 24 	      dec	taskCounter	; reduce the number of active tasks
    409  16e7		       a9 01		      lda	#1
    410  16e9		       8d 6e 24 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  16ec		       8d 6f 24 	      sta	taskCurrentCycles+1
    412  16ef		       20 56 17 	      jsr	TaskSetExitCode
    413  16f2				   iETaskExit
    414  16f2		       4c c2 02 	      jmp	NextIL
    415  16f5							;================================================================
    416  16f5							; make the current tasks math stack equal another tasks stack
    417  16f5							; The task to get is stored on the math stack
    418  16f5
    419  16f5				   iTaskGetMathStack
    420  16f5		       20 2a 1d 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  16f8		       20 6f 18 	      jsr	ipc_getcontext	; MQ now has the context address
    422  16fb		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  16fd		       b1 56		      lda	(MQ),y
    424  16ff		       85 4a		      sta	MATHSTACKPTR
    425  1701		       a0 08		      ldy	#MATHSTACKPOS
    426  1703		       b1 56		      lda	(MQ),y
    427  1705		       85 48		      sta	MATHSTACK
    428  1707		       c8		      iny
    429  1708		       b1 56		      lda	(MQ),y
    430  170a		       85 49		      sta	MATHSTACK+1
    431  170c		       4c c2 02 	      jmp	NextIL
    432  170f							;==================================================================
    433  170f							; Updates the tasks math stack pointer with contents of R2
    434  170f							; PID is on top of the stack
    435  170f				   iTaskPutMathPtr
    436  170f		       20 2a 1d 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  1712		       20 6f 18 	      jsr	ipc_getcontext	; MQ now has the context address
    438  1715		       a5 58		      lda	R2
    439  1717		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  1719		       91 56		      sta	(MQ),y
    441  171b		       4c c2 02 	      jmp	NextIL
    442  171e							;
    443  171e							;================================================================
    444  171e							; Set the time slice for each task
    445  171e				   iSLICE
    446  171e		       20 09 1b 	      jsr	popR0
    447  1721		       a5 52		      lda	R0
    448  1723		       8d 70 24 	      sta	taskResetValue
    449  1726		       a5 53		      lda	R0+1
    450  1728		       8d 71 24 	      sta	taskResetValue+1
    451  172b		       d0 0b		      bne	iSliceSet
    452  172d		       ee 71 24 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  1730		       a9 01		      lda	#1
    454  1732		       8d 6e 24 	      sta	taskCurrentCycles
    455  1735		       8d 6f 24 	      sta	taskCurrentCycles+1
    456  1738				   iSliceSet
    457  1738		       4c c2 02 	      jmp	NextIL
    458  173b							;================================================================
    459  173b							; Find an empty slot in the taskTable
    460  173b							; Return the index in y
    461  173b							; on exit   c set if an empty slot is found
    462  173b							;	     c clear if not found
    463  173b							;================================================================
    464  173b							;
    465  173b		       ad 72 24    TaskEmpty  lda	taskCounter
    466  173e		       c9 0a		      cmp	#TASKCOUNT
    467  1740		       b0 10		      bcs	TaskNoSlot
    468  1742		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  1744				   TaskLoop
    470  1744		       b9 74 23 	      lda	taskTable,y
    471  1747		       f0 0b		      beq	TaskEmptyFnd
    472  1749		       98		      tya
    473  174a		       18		      clc
    474  174b		       69 19		      adc	#CONTEXTLEN+1
    475  174d		       a8		      tay
    476  174e		       c0 fa		      cpy	#TASKTABLELEN
    477  1750		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  1752				   TaskNoSlot
    479  1752		       18		      clc
    480  1753		       60		      rts
    481  1754				   TaskEmptyFnd
    482  1754		       38		      sec
    483  1755		       60		      rts
    484  1756							;====================================================
    485  1756							; Set the task exit code called from the return command
    486  1756							; on entry stack top hold exit value
    487  1756				   TaskSetExitCode
    488  1756		       98		      tya
    489  1757		       48		      pha
    490  1758		       20 09 1b 	      jsr	popR0
    491  175b		       a0 19		      ldy	#TASKEXITCODE
    492  175d		       a5 52		      lda	R0
    493  175f		       91 41		      sta	(VARIABLES),y
    494  1761		       c8		      iny
    495  1762		       a5 53		      lda	R0+1
    496  1764		       91 41		      sta	(VARIABLES),y
    497  1766		       68		      pla
    498  1767		       98		      tya
    499  1768		       60		      rts
    500  1769
    501  1769							;
    502  1769							;=====================================================
    503  1769							; Save Context Store the context to the TASK Table
    504  1769							; on entry y contains the task table entry to save to
    505  1769							; on exit y points to next task table entry
    506  1769							;	   x contains the number of bytes copied
    507  1769		       a2 00	   ContextSave ldx	#0
    508  176b		       c8		      iny		;inc past the task flags
    509  176c		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  176e		       99 74 23 	      sta	taskTable,y
    511  1771		       c8		      iny
    512  1772		       e8		      inx
    513  1773		       e0 18		      cpx	#CONTEXTLEN
    514  1775		       90 f5		      bcc	ContextSvLoop
    515  1777		       60		      rts
    516  1778							;
    517  1778							; Load Context transfer context from task table to the Current Context
    518  1778							; on entry y contains the task table entry to transfer
    519  1778							; on exit y points to the original task table entry
    520  1778							;	   x contains the number of byts copied
    521  1778		       98	   ContextLoad tya
    522  1779		       48		      pha
    523  177a		       a2 00		      ldx	#0
    524  177c		       c8		      iny		;inc past the task flags
    525  177d		       b9 74 23    ContextLDLoop lda	taskTable,y
    526  1780		       95 41		      sta	CONTEXT,x
    527  1782		       c8		      iny
    528  1783		       e8		      inx
    529  1784		       e0 18		      cpx	#CONTEXTLEN
    530  1786		       90 f5		      bcc	ContextLDLoop
    531  1788		       68		      pla
    532  1789		       a8		      tay
    533  178a		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  178b					      include	"ipc.asm"
      1  178b							;======================================================
      2  178b							; Inter process communications.
      3  178b							; Tasks may write/read integer messages among
      4  178b							; them selves.
      5  178b							; This uses each tasks gosub stack as a message queue
      6  178b							; Gosub calls start at the highest address and the
      7  178b							; msg queue starts at the highest address.
      8  178b							;
      9  178b							;======================================================
     10  178b							; ipcs   - Send msg to another task or many tasks
     11  178b							; on entry  math stack contains the  top PID
     12  178b							;				      2ND Message value
     13  178b							; on exit   math stack contain top True-good or False-failed
     14  178b							;
     15  178b							; it may not be sent if queue is full
     16  178b							;
     17  178b							; a = ipcs(<message-expression>,<task PID-expression>)
     18  178b							;
     19  178b				   iIPCS
     20  178b		       98		      tya
     21  178c		       48		      pha
     22  178d		       20 f4 17 	      jsr	ipc_enqueue
     23  1790		       b0 08		      bcs	iIPC_BAD
     24  1792		       20 1c 1d 	      jsr	pushTrue
     25  1795		       68		      pla
     26  1796		       a8		      tay
     27  1797		       4c c2 02 	      jmp	NextIL
     28  179a				   iIPC_BAD
     29  179a		       68		      pla
     30  179b		       a8		      tay
     31  179c		       20 26 1d 	      jsr	pushFalse
     32  179f		       4c c2 02 	      jmp	NextIL
     33  17a2
     34  17a2							;======================================================
     35  17a2							; ipcr   - Recieve msg from task
     36  17a2							; on exit  the message value is returned from message queue
     37  17a2							;	    message -1	is reserved meaning no entry found
     38  17a2							; The provided variable contains the pid of the sending
     39  17a2							; task. This is optional. This always waits for a message
     40  17a2							; before returning.
     41  17a2							;
     42  17a2							; a = ipcr(<variable name>)
     43  17a2							;
     44  17a2				   iIPCR
     45  17a2		       98		      tya
     46  17a3		       48		      pha
     47  17a4		       20 36 18 	      jsr	ipc_dequeue
     48  17a7		       b0 05		      bcs	iIPCR_Q_Empty
     49  17a9		       68		      pla
     50  17aa		       a8		      tay
     51  17ab		       4c c2 02 	      jmp	NextIL
     52  17ae				   iIPCR_Q_Empty
     53  17ae		       68		      pla
     54  17af		       a8		      tay
     55  17b0		       20 1c 1d 	      jsr	pushTrue	; puts -1 on the stack
     56  17b3		       4c c2 02 	      jmp	NextIL
     57  17b6
     58  17b6							;=======================================================
     59  17b6							; ipcc   - Check if message available
     60  17b6							; on exit  Stack contains number of messages
     61  17b6							;
     62  17b6							; a = ipcc()
     63  17b6							;
     64  17b6				   iIPCC
     65  17b6		       98		      tya
     66  17b7		       48		      pha
     67  17b8		       20 e1 17 	      jsr	ipc_queue_count
     68  17bb		       20 85 1a 	      jsr	pushR0	; return the count
     69  17be		       68		      pla
     70  17bf		       a8		      tay
     71  17c0		       4c c2 02 	      jmp	NextIL
     72  17c3
     73  17c3							;=======================================================
     74  17c3							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  17c3				   iIPCIO
     76  17c3		       98		      tya
     77  17c4		       48		      pha
     78  17c5		       20 e1 17 	      jsr	ipc_queue_count
     79  17c8		       a5 52		      lda	R0
     80  17ca		       d0 10		      bne	iIPCIO_No_Halt
     81  17cc		       a9 01		      lda	#1
     82  17ce		       8d 6e 24 	      sta	taskCurrentCycles	; force a task switch
     83  17d1		       a9 01		      lda	#TASKWAITIPC
     84  17d3		       ac 73 23 	      ldy	taskPtr
     85  17d6		       19 74 23 	      ora	taskTable,y
     86  17d9		       99 74 23 	      sta	taskTable,y
     87  17dc
     88  17dc				   iIPCIO_No_Halt
     89  17dc		       68		      pla
     90  17dd		       a8		      tay
     91  17de		       4c c2 02 	      jmp	NextIL
     92  17e1							;======================================================
     93  17e1							;ipc_queue_count
     94  17e1				   ipc_queue_count
     95  17e1		       a5 4e		      lda	MESSAGEPTR
     96  17e3		       18		      clc
     97  17e4		       4a		      lsr		; divide by 4
     98  17e5		       4a		      lsr
     99  17e6		       85 52		      sta	R0	; store into R0
    100  17e8		       a9 10		      lda	#GOSUBSTACKSIZE
    101  17ea		       38		      sec
    102  17eb		       e5 52		      sbc	R0	; Get how many entries on queue
    103  17ed		       85 52		      sta	R0
    104  17ef		       a9 00		      lda	#0
    105  17f1		       85 53		      sta	R0+1
    106  17f3		       60		      rts
    107  17f4							;=======================================================
    108  17f4							; Support functions for messaging
    109  17f4							;
    110  17f4							; Enqueue message -> onto PID's MSG Q
    111  17f4							; on entry top of stack contains the PID
    112  17f4							;	    second contains the Message of the task
    113  17f4							; on exit contains c set if failed
    114  17f4							;		    c cleared if success
    115  17f4							;		    PID's MSG Q PTR points to the message
    116  17f4							;
    117  17f4				   ipc_enqueue
    118  17f4		       20 21 1b 	      jsr	popR1	; Get the pid
    119  17f7		       20 6f 18 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  17fa
    121  17fa		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  17fc		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  17fe		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1800		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1802		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1804
    127  1804
    128  1804							; Get the PID'S stack address into R0
    129  1804		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1806		       b1 56		      lda	(MQ),y
    131  1808		       85 52		      sta	R0
    132  180a		       c8		      iny
    133  180b		       b1 56		      lda	(MQ),y
    134  180d		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  180f
    136  180f							; Set y to point to the msg q entry
    137  180f		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1811		       b1 56		      lda	(MQ),y	; Get the index
    139  1813		       a8		      tay		; Set y to queue offset
    140  1814
    141  1814							; enqueue the message
    142  1814		       88		      dey		; First byte to save to
    143  1815		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1817		       91 52		      sta	(R0),y	; Set the entry type
    145  1819
    146  1819		       88		      dey
    147  181a		       ad 73 23 	      lda	taskPtr	; Store the PID into queue
    148  181d		       91 52		      sta	(R0),y
    149  181f		       20 21 1b 	      jsr	popR1	; Get the actual message value
    150  1822		       20 7d 18 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1825
    152  1825		       98		      tya		; Save the new q ptr
    153  1826		       a0 0e		      ldy	#MSGPTRPOS
    154  1828		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  182a		       a0 00		      ldy	#0	; points to context root
    156  182c		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  182e		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1830		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1832		       18		      clc
    160  1833		       60		      rts
    161  1834				   ipc_enq_full
    162  1834		       38		      sec
    163  1835		       60		      rts
    164  1836							;=============================================================
    165  1836							; De-queue for message stack -> local tasks msg q
    166  1836							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1836							;  message into
    168  1836							;  on exit   math stack contains value of message
    169  1836							;				  Variable if provided is pid
    170  1836				   ipc_dequeue
    171  1836		       20 38 1b 	      jsr	popMQ	; Variable address to put PID into
    172  1839
    173  1839		       a4 4e		      ldy	MESSAGEPTR
    174  183b		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  183d		       b0 2e		      bcs	ipc_deq_empty
    176  183f		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1841		       85 52		      sta	R0
    178  1843		       c8		      iny
    179  1844		       b1 4b		      lda	(GOSUBSTACK),y
    180  1846		       85 53		      sta	R0+1
    181  1848		       c8		      iny
    182  1849		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  184b		       85 54		      sta	R1
    184  184d		       c8		      iny
    185  184e		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1850		       c8		      iny
    187  1851		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1853
    189  1853		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1855		       d0 16		      bne	ipc_deq_empty
    191  1857
    192  1857		       20 85 1a 	      jsr	pushR0	; place value on stack
    193  185a
    194  185a		       a5 56		      lda	MQ
    195  185c		       05 57		      ora	MQ+1
    196  185e		       f0 0b		      beq	ipc_deq_done
    197  1860		       a5 54		      lda	R1
    198  1862		       a0 00		      ldy	#0
    199  1864		       91 56		      sta	(MQ),y
    200  1866		       c8		      iny
    201  1867		       a9 00		      lda	#0
    202  1869		       91 56		      sta	(MQ),y
    203  186b				   ipc_deq_done
    204  186b		       18		      clc
    205  186c		       60		      rts
    206  186d
    207  186d				   ipc_deq_empty
    208  186d		       38		      sec
    209  186e		       60		      rts
    210  186f
    211  186f							;=============================================
    212  186f							;  Get the context address into MQ from R1 with
    213  186f							;  context/index/pid
    214  186f				   ipc_getcontext
    215  186f		       18		      clc		; Get pointer to Task context
    216  1870		       a9 74		      lda	#taskTable&$FF	; change ptr to address
    217  1872		       65 54		      adc	R1
    218  1874		       85 56		      sta	MQ
    219  1876		       a9 23		      lda	#taskTable>>8
    220  1878		       65 55		      adc	R1+1
    221  187a		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  187c		       60		      rts
    223  187d							;
    224  187d							;==============================================
    225  187d							;Push R1 onto the stack
    226  187d							;on entry y = next entry
    227  187d							;R0 points to the stack space
    228  187d							;on exit y points to next free byte
    229  187d				   ipc_pushR1
    230  187d		       88		      dey
    231  187e		       a5 55		      lda	R1+1	; PID first
    232  1880		       91 52		      sta	(R0),y
    233  1882		       88		      dey
    234  1883		       a5 54		      lda	R1
    235  1885		       91 52		      sta	(R0),y
    236  1887		       60		      rts
    237  1888
    238  1888
    239  1888
    240  1888
    241  1888
    242  1888
    243  1888
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1888					      include	"support.asm"
      1  1888							;
      2  1888							;=====================================================
      3  1888							;=====================================================
      4  1888							;=====================================================
      5  1888							; This marks the start of support functions used by
      6  1888							; the IL opcodes.  These are support functions, NOT
      7  1888							; the IL code.
      8  1888							;=====================================================
      9  1888							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1888							;=====================================================
     11  1888					      Seg	Code
     12  1888							;=====================================================
     13  1888							; This gets the next two bytes pointed to by ILPC and
     14  1888							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1888							; is advanced by two, and Y contains 0 on return.
     16  1888
     17  1888							;
     18  1888		       20 8c 18    getILWord  jsr	getILByte	;LSB
     19  188b		       aa		      tax
     20  188c							;
     21  188c							;=====================================================
     22  188c							; This gets the next byte pointed to by ILPC and
     23  188c							; returns it in A.  On return, X is unchanged but Y
     24  188c							; contains 0.
     25  188c							;
     26  188c		       a0 00	   getILByte  ldy	#0
     27  188e		       b1 43		      lda	(ILPC),y	;get byte
     28  1890		       08		      php		;save status
     29  1891		       e6 43		      inc	ILPC	;inc LSB
     30  1893		       d0 02		      bne	getILb2	;branch if no overflow
     31  1895		       e6 44		      inc	ILPC+1	;inc MSB
     32  1897		       28	   getILb2    plp		;restore status
     33  1898		       60		      rts
     34  1899							;
     35  1899							;=====================================================
     36  1899							; Decrement ILPC by one.
     37  1899							;
     38  1899		       a5 43	   decIL      lda	ILPC
     39  189b		       d0 02		      bne	decIL2
     40  189d		       c6 44		      dec	ILPC+1
     41  189f		       c6 43	   decIL2     dec	ILPC
     42  18a1		       60		      rts
     43  18a2							;
     44  18a2							;=====================================================
     45  18a2							; Push the ILPC onto the return stack.  Actually, this
     46  18a2							; pushes the address of ILPC+2 since that's the next
     47  18a2							; address to execute.
     48  18a2							;
     49  18a2		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  18a4		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  18a6		       b0 15		      bcs	pushErr
     52  18a8		       a5 43		      lda	ILPC
     53  18aa		       18		      clc
     54  18ab		       69 02		      adc	#2
     55  18ad		       91 45		      sta	(ILSTACK),y
     56  18af		       08		      php		;save C bit
     57  18b0		       c8		      iny
     58  18b1		       a5 44		      lda	ILPC+1
     59  18b3		       28		      plp		;restore C
     60  18b4		       69 00		      adc	#0
     61  18b6		       91 45		      sta	(ILSTACK),y
     62  18b8		       c8		      iny
     63  18b9		       84 47		      sty	ILSTACKPTR
     64  18bb		       18		      clc
     65  18bc		       60		      rts
     66  18bd				   pushErr
     67  18bd		       38		      sec
     68  18be		       60		      rts
     69  18bf							;
     70  18bf							;=====================================================
     71  18bf							; Pull the top entry from return stack and put into
     72  18bf							; ILPC.
     73  18bf							;
     74  18bf		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  18c1		       f0 fa		      beq	pushErr
     76  18c3		       88		      dey
     77  18c4		       b1 45		      lda	(ILSTACK),y
     78  18c6		       85 44		      sta	ILPC+1
     79  18c8		       88		      dey
     80  18c9		       b1 45		      lda	(ILSTACK),y
     81  18cb		       85 43		      sta	ILPC
     82  18cd		       84 47		      sty	ILSTACKPTR
     83  18cf		       18		      clc
     84  18d0		       60		      rts
     85  18d1							;
     86  18d1							;=====================================================
     87  18d1							; This searches for a specific line number that is in
     88  18d1							; R0.	There are three possible return conditions:
     89  18d1							; Line numbers are now the third byte, the first byte is now **************
     90  18d1							; a pointer to the next line, of course no longer that 53 byte
     91  18d1							; per line.
     92  18d1							;
     93  18d1							; Exact match was found:
     94  18d1							;    * Z set
     95  18d1							;    * CURPTR points to two-byte line number for that
     96  18d1							;	line.
     97  18d1							;
     98  18d1							; Next highest line found:
     99  18d1							;    * Z cleared
    100  18d1							;    * C set
    101  18d1							;    * CURPTR points to two-byte line number for that
    102  18d1							;	line.
    103  18d1							;
    104  18d1							; End of program reached:
    105  18d1							;    * Z cleared
    106  18d1							;    * C cleared
    107  18d1							;    * CURPTR points to first free byte at end of
    108  18d1							;	program.  Ie, it has save value as PROGRAMEND.
    109  18d1							;
    110  18d1							; A, X, and Y are all undefined on return.
    111  18d1							;
    112  18d1
    113  18d1				   findLine
    114  18d1		       ad cc 2c 	      lda	ProgramStart	;Start of program -> CURPTR
    115  18d4		       85 4f		      sta	CURPTR
    116  18d6		       ad cd 2c 	      lda	ProgramStart+1
    117  18d9		       85 50		      sta	CURPTR+1
    118  18db							;
    119  18db							; At end of code?
    120  18db							;
    121  18db				   iXFER1
    122  18db		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  18dd		       cd ce 2c 	      cmp	ProgramEnd	; at end of program then stop run
    124  18e0		       d0 0b		      bne	xfer2	; not end
    125  18e2		       a5 50		      lda	CURPTR+1
    126  18e4		       cd cf 2c 	      cmp	ProgramEnd+1
    127  18e7		       d0 04		      bne	xfer2	;Not at end
    128  18e9							;
    129  18e9							; Line not found and the end of the program was
    130  18e9							; reached.  Return Z and C both clear.
    131  18e9							;
    132  18e9		       a9 01		      lda	#1	;clear Z
    133  18eb		       18		      clc		;clear C
    134  18ec		       60		      rts
    135  18ed							;
    136  18ed							; Check for an exact line number match
    137  18ed							;
    138  18ed		       a5 52	   xfer2      lda	R0
    139  18ef		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  18f1		       d1 4f		      cmp	(CURPTR),y
    141  18f3		       d0 08		      bne	xfernotit
    142  18f5		       c8		      iny
    143  18f6		       a5 53		      lda	R0+1
    144  18f8		       d1 4f		      cmp	(CURPTR),y
    145  18fa		       d0 01		      bne	xfernotit	; not a matching line number
    146  18fc							;
    147  18fc							; This is exactly the line we want.
    148  18fc							;
    149  18fc		       60		      rts		;it matches exactly
    150  18fd							;
    151  18fd							; See if this line is greater than the one we're
    152  18fd							; searching for.
    153  18fd							;
    154  18fd		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  18ff		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1901		       c5 53		      cmp	R0+1
    157  1903		       90 0b		      bcc	xfer3
    158  1905		       d0 07		      bne	xfer4
    159  1907		       88		      dey
    160  1908		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  190a		       c5 52		      cmp	R0
    162  190c		       90 02		      bcc	xfer3
    163  190e							;
    164  190e							; This line is greater than the one we want, so
    165  190e							; return Z clear and C set.
    166  190e							;
    167  190e		       38	   xfer4      sec		;We found a line number greater
    168  190f		       60		      rts		;both conditions set
    169  1910							;
    170  1910							; Not the line (or droid) we're looking for.  Move to
    171  1910							; the next line.
    172  1910							;
    173  1910		       20 16 19    xfer3      jsr	FindNextLine
    174  1913		       4c db 18 	      jmp	iXFER1
    175  1916							;
    176  1916							;=====================================================
    177  1916							; This advances CURPTR to the next line.  If there
    178  1916							; are no more lines, this leaves CURPTR equal to
    179  1916							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1916							; CURPTR is pointing to a valid line on entry.  This
    181  1916							; pointer points to the two-byte line number.
    182  1916							; Update this points to the 1 byte line length  ****************
    183  1916							;
    184  1916				   FindNextLine
    185  1916		       a0 03		      ldy	#3	;skip line number and length byte
    186  1918		       84 51		      sty	CUROFF	;this is the new offset
    187  191a		       a0 00		      ldy	#0
    188  191c		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  191e		       18		      clc
    190  191f		       65 4f		      adc	CURPTR
    191  1921		       85 4f		      sta	CURPTR
    192  1923		       a5 50		      lda	CURPTR+1
    193  1925		       69 00		      adc	#0
    194  1927		       85 50		      sta	CURPTR+1
    195  1929		       60	   FindNext4  rts
    196  192a							;
    197  192a							;=====================================================
    198  192a							; This compares CURPTR to PROGRAMEND and returns Z set
    199  192a							; if they are equal, Z clear if not.
    200  192a							;
    201  192a		       a5 4f	   AtEnd      lda	CURPTR
    202  192c		       cd ce 2c 	      cmp	ProgramEnd
    203  192f		       d0 05		      bne	atendexit
    204  1931		       a5 50		      lda	CURPTR+1
    205  1933		       cd cf 2c 	      cmp	ProgramEnd+1
    206  1936		       60	   atendexit  rts
    207  1937							;
    208  1937
    209  1937							;
    210  1937							;=====================================================
    211  1937							; Convert an ASCII string to a number.  On input,
    212  1937							; (CURPTR),Y points to the first digit.  This gets
    213  1937							; digit-by-digit until finding a non-number.  Returns
    214  1937							; Y pointing to the non-digit, and R0 contains the
    215  1937							; number.  This does NOT check for valid ranges, so
    216  1937							; a value like "123456789" will produce something,
    217  1937							; but not what you had expected.
    218  1937							;
    219  1937		       a9 00	   getDecimal lda	#0
    220  1939		       85 52		      sta	R0
    221  193b		       85 53		      sta	R0+1
    222  193d		       85 59		      sta	dpl	;temporary negative flag
    223  193f							;
    224  193f							; See if it's negative...
    225  193f							;
    226  193f							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  193f		       b1 4f		      lda	(CURPTR),y
    228  1941		       c9 2d		      cmp	#'-
    229  1943		       d0 02		      bne	getDecLoop
    230  1945		       e6 59		      inc	dpl	;it's negative
    231  1947							;
    232  1947		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1949		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  194b		       c9 30		      cmp	#'0
    235  194d		       90 36		      bcc	getDdone
    236  194f		       c9 3a		      cmp	#'9+1
    237  1951		       b0 32		      bcs	getDdone
    238  1953		       38		      sec
    239  1954		       e9 30		      sbc	#'0	;convert to binary
    240  1956		       48		      pha
    241  1957							;
    242  1957							; Now multiply R0 by 10.  Remember that
    243  1957							; 2*N + 8*N = 10*N.
    244  1957							;
    245  1957		       06 52		      asl	R0
    246  1959		       26 53		      rol	R0+1	;*2
    247  195b		       a5 52		      lda	R0
    248  195d		       85 54		      sta	R1
    249  195f		       a5 53		      lda	R0+1
    250  1961		       85 55		      sta	R1+1
    251  1963		       06 52		      asl	R0
    252  1965		       26 53		      rol	R0+1	;*4
    253  1967		       06 52		      asl	R0
    254  1969		       26 53		      rol	R0+1	;*8
    255  196b		       18		      clc		;now add the partial sums...
    256  196c		       a5 52		      lda	R0	;...to get *10
    257  196e		       65 54		      adc	R1
    258  1970		       85 52		      sta	R0
    259  1972		       a5 53		      lda	R0+1
    260  1974		       65 55		      adc	R1+1
    261  1976		       85 53		      sta	R0+1
    262  1978							;
    263  1978							; Add in the new digit
    264  1978							;
    265  1978		       68		      pla
    266  1979		       18		      clc
    267  197a		       65 52		      adc	R0
    268  197c		       85 52		      sta	R0
    269  197e		       90 02		      bcc	getD2
    270  1980		       e6 53		      inc	R0+1
    271  1982							;
    272  1982							; Move to next character
    273  1982							;
    274  1982		       c8	   getD2      iny
    275  1983		       d0 c2		      bne	getDecLoop
    276  1985							;
    277  1985							; All done with digits, so now deal with it being
    278  1985							; negative.  If zero, then don't check for negative
    279  1985							; flag.  Ie, -0 is stored as 0.
    280  1985							;
    281  1985		       a5 52	   getDdone   lda	R0
    282  1987		       05 53		      ora	R0+1
    283  1989		       f0 16		      beq	getDone2	;zero
    284  198b		       a5 59		      lda	dpl
    285  198d		       f0 12		      beq	getDone2	;positive
    286  198f							;
    287  198f							; Invert all the bits, then add one.
    288  198f							;
    289  198f		       a5 52		      lda	R0
    290  1991		       49 ff		      eor	#$ff
    291  1993		       85 52		      sta	R0
    292  1995		       a5 53		      lda	R0+1
    293  1997		       49 ff		      eor	#$ff
    294  1999		       85 53		      sta	R0+1
    295  199b							;
    296  199b		       e6 52		      inc	R0
    297  199d		       d0 02		      bne	getDone2
    298  199f		       e6 53		      inc	R0+1
    299  19a1				   getDone2
    300  19a1							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  19a1							;lda	  R0
    302  19a1							;sta	  $0010
    303  19a1							;lda	  R0+1
    304  19a1							;sta	  $0011
    305  19a1							;lda	  dpl
    306  19a1							;sta	  $012
    307  19a1
    308  19a1		       60		      rts
    309  19a2
    310  19a2							;=====================================================
    311  19a2							; Gets a line of input into LINBUF.
    312  19a2							;
    313  19a2							; On entry:
    314  19a2							;    A contains the prompt character, or 0 if none.
    315  19a2							;    X = 1 Background read
    316  19a2							;    x = 0 Forground read with wait
    317  19a2							;
    318  19a2							; On exit:
    319  19a2							;    CURPTR points to LINBUF
    320  19a2							;    LINBUF contains the line with 0 at the end.
    321  19a2							;    Y has offset to first non-space character
    322  19a2							;    CURROFF has the same as Y.
    323  19a2							;
    324  19a2		       20 f1 19    GetLine    jsr	ReadPrompt
    325  19a5		       e0 00		      cpx	#0
    326  19a7		       f0 14		      beq	GetLineRetry
    327  19a9		       ae 73 23 	      ldx	taskPtr
    328  19ac		       bd 74 23 	      lda	taskTable,x
    329  19af		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  19b1		       d0 3d		      bne	taskWaitingIO
    331  19b3		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  19b5		       9d 74 23 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  19b8		       ce f0 19 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  19bb		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  19bd
    336  19bd							;
    337  19bd							; Now read a line and wait for the CR
    338  19bd							;
    339  19bd				   GetLineRetry
    340  19bd		       a9 00		      lda	#0	;Wait for input to complete
    341  19bf		       20 09 1a 	      jsr	ReadLine
    342  19c2
    343  19c2							;
    344  19c2							; Point to the line we just read
    345  19c2							; Set the current pointer to point to the input line
    346  19c2							;
    347  19c2		       a0 00	   ReadComplete ldy	#0
    348  19c4		       84 51		      sty	CUROFF
    349  19c6		       a2 2f		      ldx	#LINBUF&$ff
    350  19c8		       86 4f		      stx	CURPTR
    351  19ca		       a2 2c		      ldx	#LINBUF>>8
    352  19cc		       86 50		      stx	CURPTR+1
    353  19ce							;
    354  19ce							; Output a CR/LF
    355  19ce							;
    356  19ce		       20 c2 1b 	      jsr	CRLF
    357  19d1							;
    358  19d1							; If a blank line, prompt again.
    359  19d1							;
    360  19d1		       20 b9 1b 	      jsr	SkipSpaces
    361  19d4		       b1 4f		      lda	(CURPTR),y
    362  19d6		       d0 10		      bne	GetLineDone	;We have data then exit
    363  19d8		       20 f4 19 	      jsr	ReadPromptRetry
    364  19db		       ae 73 23 	      ldx	taskPtr	;if this task is waiting for IO
    365  19de		       bd 74 23 	      lda	taskTable,x	;then get out, wait for line to
    366  19e1		       29 40		      and	#TASKWAITIO	;Complete again
    367  19e3		       d0 0b		      bne	taskWaitingIO
    368  19e5		       4c bd 19 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  19e8
    370  19e8				   GetLineDone
    371  19e8		       ae 73 23 	      ldx	taskPtr
    372  19eb		       a9 80		      lda	#TASKACTIVE
    373  19ed		       9d 74 23 	      sta	taskTable,x	;IO is complete
    374  19f0
    375  19f0				   taskWaitingIO
    376  19f0		       60		      rts
    377  19f1
    378  19f1							;
    379  19f1							;=======================================================================
    380  19f1							; Display the prompt character
    381  19f1							; On entry
    382  19f1							;	    A contains the prompt character
    383  19f1							; On exit
    384  19f1							;	    The readbuffer index is reset to 0
    385  19f1							;
    386  19f1		       8d b6 2c    ReadPrompt sta	promptChar
    387  19f4
    388  19f4							;
    389  19f4							; Prompt
    390  19f4							;
    391  19f4
    392  19f4		       ad b6 2c    ReadPromptRetry lda	promptChar
    393  19f7		       09 00		      ora	#0	;any prompt?
    394  19f9		       f0 08		      beq	getlinenp
    395  19fb		       20 0b 1d 	      jsr	VOUTCH
    396  19fe		       a9 20		      lda	#$20
    397  1a00		       20 0b 1d 	      jsr	VOUTCH	;Space after prompt
    398  1a03							;
    399  1a03		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1a05		       8e b3 2c 	      stx	getlinx
    401  1a08		       60		      rts
    402  1a09							;
    403  1a09							;===============================================================
    404  1a09							; This fuction is the driver for the line input
    405  1a09							; on call if a = 0 then it waits for all input
    406  1a09							;	      a = 1 then nowait for input
    407  1a09							; On exit
    408  1a09							;		       c clear if not complete line
    409  1a09							;		       c set if it was a complete line
    410  1a09
    411  1a09				   ReadLine
    412  1a09		       8d b5 2c 	      sta	inputNoWait
    413  1a0c		       c9 00		      cmp	#0
    414  1a0e		       f0 05		      beq	getline1
    415  1a10		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1a13		       f0 2b		      beq	GetLineNoWait
    417  1a15		       20 0e 1d    getline1   jsr	VGETCH
    418  1a18					      if	CTMON65
    419  1a18		       48		      pha
    420  1a19		       20 0b 1d 	      jsr	VOUTCH	;echo echo echo
    421  1a1c		       68		      pla
    422  1a1d					      endif
    423  1a1d		       c9 0d		      cmp	#CR
    424  1a1f		       f0 15		      beq	getlind	;end of line
    425  1a21		       c9 08		      cmp	#BS	;backspace?
    426  1a23		       f0 1d		      beq	getlinebs
    427  1a25		       ae b3 2c 	      ldx	getlinx
    428  1a28		       9d 2f 2c 	      sta	LINBUF,x
    429  1a2b		       e8		      inx
    430  1a2c		       8e b3 2c 	      stx	getlinx
    431  1a2f		       ad b5 2c 	      lda	inputNoWait
    432  1a32		       f0 e1		      beq	getline1
    433  1a34		       d0 0a		      bne	GetLineNoWait
    434  1a36							;
    435  1a36							; CR was hit
    436  1a36							;
    437  1a36		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1a38		       ae b3 2c 	      ldx	getlinx
    439  1a3b		       9d 2f 2c 	      sta	LINBUF,x
    440  1a3e
    441  1a3e		       38		      sec		; Carry set then cr received
    442  1a3f		       60		      rts
    443  1a40
    444  1a40				   GetLineNoWait
    445  1a40		       18		      clc		; Carry clear no end of line
    446  1a41		       60		      rts
    447  1a42							;
    448  1a42							; Backspace was hit
    449  1a42							;
    450  1a42		       ae b3 2c    getlinebs  ldx	getlinx
    451  1a45		       f0 0e		      beq	getlineEOL	;at start of line
    452  1a47		       ca		      dex
    453  1a48		       8e b3 2c 	      stx	getlinx
    454  1a4b		       20 41 13    getlinepbs jsr	puts
      0  1a4e					      db	27,"[K",0
      1  1a4e		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1a52		       4c 15 1a 	      jmp	getline1
    457  1a55		       a9 20	   getlineEOL lda	#SPACE
    458  1a57		       20 0b 1d 	      jsr	VOUTCH
    459  1a5a		       d0 ef		      bne	getlinepbs
    460  1a5c							;
    461  1a5c							;=====================================================
    462  1a5c							; Count the length of the line currently in LINBUF
    463  1a5c							; starting at offset Y.  Returns the length in X.  The
    464  1a5c							; starting offset in Y should point past the ASCII
    465  1a5c							; line number.  Also counts the trailing NULL and two
    466  1a5c							; extra bytes for where the line number will be.
    467  1a5c							; Update must now include leading length byte not the null at end ****************
    468  1a5c							;
    469  1a5c				   getLineLength
    470  1a5c		       a2 00		      ldx	#0	;size
    471  1a5e		       b9 2f 2c    getLineL2  lda	LINBUF,y
    472  1a61		       f0 04		      beq	getLineL3
    473  1a63		       c8		      iny
    474  1a64		       e8		      inx
    475  1a65		       d0 f7		      bne	getLineL2
    476  1a67		       e8	   getLineL3  inx		;count null at end
    477  1a68		       e8		      inx		;line number LSB
    478  1a69		       e8		      inx		;MSB
    479  1a6a		       e8		      inx		;change: count new leading line length
    480  1a6b		       8e c9 2c 	      stx	lineLength
    481  1a6e		       60		      rts
    482  1a6f							;
    483  1a6f							;=====================================================
    484  1a6f							; Count the length of the line pointed to by CURPTR.
    485  1a6f							; This also counts the line number and the terminating
    486  1a6f							; null.  Ie, this string returns 8:
    487  1a6f							;
    488  1a6f							; <lineLow><lineHi>Hello<null>
    489  1a6f							;
    490  1a6f							; Another way of looking at it: add the return value
    491  1a6f							; to the CURPTR and it'll point to the next line's
    492  1a6f							; line number.  Returns the value in Y.
    493  1a6f							; Update to ject get the leading byte length ********************
    494  1a6f							;
    495  1a6f							;getCURPTRLength
    496  1a6f							;		ldy	CURPTR
    497  1a6f							;		ldy	#3	;change: skip line number and leading length byte
    498  1a6f							;getCLineL2	lda	(CURPTR),y
    499  1a6f							;		beq	getCLineL3
    500  1a6f							;		iny
    501  1a6f							;		bne	getCLineL2
    502  1a6f							;getCLineL3	iny		;count null at end
    503  1a6f							;		rts
    504  1a6f
    505  1a6f							;
    506  1a6f							;=====================================================
    507  1a6f							; This saves ILPC.  This saves to a single save area,
    508  1a6f							; so it can't be called more than once.
    509  1a6f							;
    510  1a6f		       a5 43	   saveIL     lda	ILPC
    511  1a71		       8d c5 2c 	      sta	tempIL
    512  1a74		       a5 44		      lda	ILPC+1
    513  1a76		       8d c6 2c 	      sta	tempIL+1
    514  1a79		       60		      rts
    515  1a7a							;
    516  1a7a							;=====================================================
    517  1a7a							; This restores ILPC.
    518  1a7a							;
    519  1a7a		       ad c5 2c    restoreIL  lda	tempIL
    520  1a7d		       85 43		      sta	ILPC
    521  1a7f		       ad c6 2c 	      lda	tempIL+1
    522  1a82		       85 44		      sta	ILPC+1
    523  1a84		       60		      rts
    524  1a85							;
    525  1a85							;=====================================================
    526  1a85							; This pushes R0 onto the stack.
    527  1a85							;
    528  1a85		       8c bc 2c    pushR0     sty	rtemp1
    529  1a88		       a4 4a		      ldy	MATHSTACKPTR
    530  1a8a		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1a8c		       b0 34		      bcs	pusherr
    532  1a8e		       a5 52		      lda	R0
    533  1a90		       91 48		      sta	(MATHSTACK),y
    534  1a92		       c8		      iny
    535  1a93		       a5 53		      lda	R0+1
    536  1a95		       91 48		      sta	(MATHSTACK),y
    537  1a97		       c8		      iny
    538  1a98		       84 4a		      sty	MATHSTACKPTR
    539  1a9a		       ac bc 2c 	      ldy	rtemp1
    540  1a9d		       18		      clc
    541  1a9e		       60		      rts
    542  1a9f
    543  1a9f							;=====================================================
    544  1a9f							; This pushes curptr basic current line onto the call stack.
    545  1a9f							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1a9f
    547  1a9f				   pushLN
    548  1a9f		       8c bc 2c 	      sty	rtemp1
    549  1aa2		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  1aa4		       c5 4d		      cmp	GOSUBSTACKPTR
    551  1aa6		       90 1a		      bcc	pusherr	; No error
    552  1aa8		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  1aaa		       a2 00		      ldx	#0	; Start of bytes to copy
    554  1aac				   pushLoop
    555  1aac		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  1aae		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  1ab0		       c8		      iny		; Next destination
    558  1ab1		       e8		      inx		; Next Source byte
    559  1ab2		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  1ab4		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  1ab6
    562  1ab6		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  1ab8		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  1aba		       c8		      iny		; Next entry
    565  1abb
    566  1abb		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  1abd		       ac bc 2c 	      ldy	rtemp1
    568  1ac0		       18		      clc
    569  1ac1		       60		      rts
    570  1ac2				   pusherr
    571  1ac2		       38		      sec
    572  1ac3		       60		      rts
    573  1ac4							;=====================================================
    574  1ac4							; This pops Top Off gosub call Stack and
    575  1ac4							; places it in CURPTR/CUROFF.
    576  1ac4							; This checks if the type = 1 GOSUB
    577  1ac4							; if not it removes what ever is on the stack
    578  1ac4							; until it finds the next return. Allowing
    579  1ac4							; a return from within a for/next
    580  1ac4		       8c bc 2c    popLN      sty	rtemp1
    581  1ac7		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  1ac9		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  1acb
    584  1acb				   popContinue
    585  1acb		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  1acd		       90 18		      bcc	poperr	; Process an error
    587  1acf
    588  1acf		       88		      dey		; Position to read entry type
    589  1ad0		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  1ad2		       c9 01		      cmp	#1	; Type is a gosub entry
    591  1ad4		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  1ad6
    593  1ad6				   popLoop
    594  1ad6		       88		      dey
    595  1ad7		       ca		      dex
    596  1ad8		       b1 4b		      lda	(GOSUBSTACK),y
    597  1ada		       95 4f		      sta	CURPTR,x
    598  1adc		       e0 00		      cpx	#0
    599  1ade		       d0 f6		      bne	popLoop	; Loop until all moved
    600  1ae0
    601  1ae0
    602  1ae0		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  1ae2		       ac bc 2c 	      ldy	rtemp1
    604  1ae5		       18		      clc
    605  1ae6		       60		      rts
    606  1ae7
    607  1ae7		       38	   poperr     sec
    608  1ae8		       60		      rts
    609  1ae9
    610  1ae9		       88	   popSkipEntry dey
    611  1aea		       88		      dey
    612  1aeb		       88		      dey
    613  1aec		       4c cb 1a 	      jmp	popContinue
    614  1aef
    615  1aef							;
    616  1aef							;=====================================================
    617  1aef							; This pushes R1 onto the stack
    618  1aef							;
    619  1aef		       8c bc 2c    pushR1     sty	rtemp1
    620  1af2		       a4 4a		      ldy	MATHSTACKPTR
    621  1af4		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  1af6		       b0 ef		      bcs	poperr
    623  1af8		       a5 54		      lda	R1
    624  1afa		       91 48		      sta	(MATHSTACK),y
    625  1afc		       c8		      iny
    626  1afd		       a5 55		      lda	R1+1
    627  1aff		       91 48		      sta	(MATHSTACK),y
    628  1b01		       c8		      iny
    629  1b02		       84 4a		      sty	MATHSTACKPTR
    630  1b04		       ac bc 2c 	      ldy	rtemp1
    631  1b07		       18		      clc
    632  1b08		       60		      rts
    633  1b09							;
    634  1b09							;=====================================================
    635  1b09							; This pops Top Of Stack and places it in R0.
    636  1b09							;
    637  1b09		       8c bc 2c    popR0      sty	rtemp1
    638  1b0c		       a4 4a		      ldy	MATHSTACKPTR
    639  1b0e		       f0 d7		      beq	poperr
    640  1b10		       88		      dey
    641  1b11		       b1 48		      lda	(MATHSTACK),y
    642  1b13		       85 53		      sta	R0+1
    643  1b15		       88		      dey
    644  1b16		       b1 48		      lda	(MATHSTACK),y
    645  1b18		       85 52		      sta	R0
    646  1b1a		       84 4a		      sty	MATHSTACKPTR
    647  1b1c		       ac bc 2c 	      ldy	rtemp1
    648  1b1f		       18		      clc
    649  1b20		       60		      rts
    650  1b21
    651  1b21							;
    652  1b21							;=====================================================
    653  1b21							; This pops TOS and places it in R1.
    654  1b21							;
    655  1b21		       8c bc 2c    popR1      sty	rtemp1
    656  1b24		       a4 4a		      ldy	MATHSTACKPTR
    657  1b26		       f0 bf		      beq	poperr
    658  1b28		       88		      dey
    659  1b29		       b1 48		      lda	(MATHSTACK),y
    660  1b2b		       85 55		      sta	R1+1
    661  1b2d		       88		      dey
    662  1b2e		       b1 48		      lda	(MATHSTACK),y
    663  1b30		       85 54		      sta	R1
    664  1b32		       84 4a		      sty	MATHSTACKPTR
    665  1b34		       ac bc 2c 	      ldy	rtemp1
    666  1b37		       60		      rts
    667  1b38							;
    668  1b38							;=====================================================
    669  1b38							; This pops TOS and places it in MQ.
    670  1b38							;
    671  1b38		       8c bc 2c    popMQ      sty	rtemp1
    672  1b3b		       a4 4a		      ldy	MATHSTACKPTR
    673  1b3d		       f0 a8		      beq	poperr
    674  1b3f		       88		      dey
    675  1b40		       b1 48		      lda	(MATHSTACK),y
    676  1b42		       85 57		      sta	MQ+1
    677  1b44		       88		      dey
    678  1b45		       b1 48		      lda	(MATHSTACK),y
    679  1b47		       85 56		      sta	MQ
    680  1b49		       84 4a		      sty	MATHSTACKPTR
    681  1b4b		       ac bc 2c 	      ldy	rtemp1
    682  1b4e		       60		      rts
    683  1b4f							;
    684  1b4f							;=====================================================
    685  1b4f							; This assists with multiplication and division by
    686  1b4f							; looking at R0 and R1 and saving a flag as to what
    687  1b4f							; sign the result will be.  Math is always done on
    688  1b4f							; positive numbers, so this converts negative numbers
    689  1b4f							; into positives.  On exit, R0 and R1 are both
    690  1b4f							; positive.  If the signs were different then 'signs'
    691  1b4f							; will be non-zero.
    692  1b4f							;
    693  1b4f		       a9 00	   SaveSigns  lda	#0
    694  1b51		       8d bb 2c 	      sta	sign	;assume positive
    695  1b54		       a5 53		      lda	R0+1	;MSB
    696  1b56		       10 13		      bpl	SaveSigns1
    697  1b58		       ee bb 2c 	      inc	sign	;it's negative
    698  1b5b		       49 ff		      eor	#$ff	;flip bits
    699  1b5d		       85 53		      sta	R0+1
    700  1b5f		       a5 52		      lda	R0
    701  1b61		       49 ff		      eor	#$ff
    702  1b63		       85 52		      sta	R0
    703  1b65		       e6 52		      inc	R0
    704  1b67		       d0 02		      bne	SaveSigns1
    705  1b69		       e6 53		      inc	R0+1
    706  1b6b		       a5 55	   SaveSigns1 lda	R1+1
    707  1b6d		       10 1a		      bpl	SaveSigns2
    708  1b6f		       48		      pha
    709  1b70		       ad bb 2c 	      lda	sign
    710  1b73		       49 01		      eor	#1
    711  1b75		       8d bb 2c 	      sta	sign
    712  1b78		       68		      pla
    713  1b79		       49 ff		      eor	#$ff	;flip bits
    714  1b7b		       85 55		      sta	R1+1
    715  1b7d		       a5 54		      lda	R1
    716  1b7f		       49 ff		      eor	#$ff
    717  1b81		       85 54		      sta	R1
    718  1b83		       e6 54		      inc	R1
    719  1b85		       d0 02		      bne	SaveSigns2
    720  1b87		       e6 55		      inc	R1+1
    721  1b89		       60	   SaveSigns2 rts
    722  1b8a							;
    723  1b8a							;=====================================================
    724  1b8a							; This looks at the value of 'signs' and will convert
    725  1b8a							; both R0 and R1 to negative if set.
    726  1b8a							;
    727  1b8a				   RestoreSigns
    728  1b8a		       ad bb 2c 	      lda	sign
    729  1b8d		       f0 28		      beq	restoresigns2
    730  1b8f							;
    731  1b8f		       a5 52		      lda	R0
    732  1b91		       d0 02		      bne	restoresigns3
    733  1b93		       c6 53		      dec	R0+1
    734  1b95				   restoresigns3
    735  1b95		       c6 52		      dec	R0
    736  1b97		       a5 52		      lda	R0
    737  1b99		       49 ff		      eor	#$ff
    738  1b9b		       85 52		      sta	R0
    739  1b9d		       a5 53		      lda	R0+1
    740  1b9f		       49 ff		      eor	#$ff
    741  1ba1		       85 53		      sta	R0+1
    742  1ba3							;
    743  1ba3		       a5 54		      lda	R1
    744  1ba5		       d0 02		      bne	restoresigns4
    745  1ba7		       c6 55		      dec	R1+1
    746  1ba9				   restoresigns4
    747  1ba9		       c6 54		      dec	R1
    748  1bab		       a5 54		      lda	R1
    749  1bad		       49 ff		      eor	#$ff
    750  1baf		       85 54		      sta	R1
    751  1bb1		       a5 55		      lda	R1+1
    752  1bb3		       49 ff		      eor	#$ff
    753  1bb5		       85 55		      sta	R1+1
    754  1bb7							;
    755  1bb7				   restoresigns2
    756  1bb7		       60		      rts
    757  1bb8							;
    758  1bb8							;=====================================================
    759  1bb8							; Skip over spaces.  Returns Y with the offset to
    760  1bb8							; either the last character in the line, or the first
    761  1bb8							; non-space character.
    762  1bb8							;
    763  1bb8
    764  1bb8		       c8	   skipsp2    iny
    765  1bb9		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  1bbb		       f0 04		      beq	Skip3	;end of line
    767  1bbd		       c9 20		      cmp	#SPACE
    768  1bbf		       f0 f7		      beq	skipsp2
    769  1bc1		       60	   Skip3      rts
    770  1bc2							;*********************************************************
    771  1bc2							; Output a CR/LF combination to the console.  Preserves
    772  1bc2							; all registers.
    773  1bc2							;
    774  1bc2		       48	   tbcrlf     pha
    775  1bc3		       a9 0d		      lda	#CR
    776  1bc5		       20 0b 1d 	      jsr	VOUTCH
    777  1bc8		       a9 0a		      lda	#LF
    778  1bca		       20 0b 1d 	      jsr	VOUTCH
    779  1bcd		       68		      pla
    780  1bce		       60		      rts
    781  1bcf							;
    782  1bcf							;=====================================================
    783  1bcf							; Some logic to print the Line of basic code being executed
    784  1bcf		       24 40	   idbgBasic  bit	ILTrace
    785  1bd1		       50 70		      bvc	dbgBasicNone
    786  1bd3		       98		      tya
    787  1bd4		       48		      pha
    788  1bd5		       20 3b 1d 	      jsr	SetOutDebug
    789  1bd8		       20 64 13 	      jsr	PrtPrgLine
    790  1bdb		       20 c2 1b 	      jsr	CRLF
    791  1bde		       a5 40		      lda	ILTrace
    792  1be0		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  1be2		       f0 5a		      beq	dbgBasicDone
    794  1be4		       20 46 1d 	      jsr	SetInDebug
    795  1be7		       20 41 13 	      jsr	puts
      0  1bea					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1bea		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1c27				   dbgBasicLoop
    798  1c27		       20 0e 1d 	      jsr	VGETCH
    799  1c2a		       20 c2 1b 	      jsr	CRLF
    800  1c2d		       20 fe 1c 	      jsr	SetInConsole
    801  1c30
    802  1c30		       c9 73		      cmp	#'s	; Quit program
    803  1c32		       f0 12		      beq	dbgBasicStop
    804  1c34
    805  1c34		       c9 64		      cmp	#'d	; Display Variables
    806  1c36		       d0 06		      bne	dbgBasicDone
    807  1c38
    808  1c38		       20 9a 13 	      jsr	PrintAllVars
    809  1c3b		       18		      clc
    810  1c3c		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1c3e
    812  1c3e		       20 f1 1c    dbgBasicDone jsr	SetOutConsole
    813  1c41		       68		      pla
    814  1c42		       a8		      tay
    815  1c43		       4c c2 02    dbgBasicNone jmp	NextIL
    816  1c46
    817  1c46				   dbgBasicStop
    818  1c46		       20 f1 1c 	      jsr	SetOutConsole
    819  1c49		       68		      pla
    820  1c4a		       a8		      tay
    821  1c4b		       4c 08 06 	      jmp	iFIN
    822  1c4e							;
    823  1c4e							;=====================================================
    824  1c4e							; This is some debug logic which displays the current
    825  1c4e							; value of the ILPC and the line buffer.
    826  1c4e							;
    827  1c4e		       24 40	   dbgLine    bit	ILTrace
    828  1c50		       30 01		      bmi	dbgPrt
    829  1c52		       60		      rts
    830  1c53				   dbgPrt
    831  1c53		       20 3b 1d 	      jsr	SetOutDebug
    832  1c56		       20 41 13 	      jsr	puts
      0  1c59					      db	"ILPC: ",0
      1  1c59		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  1c60		       a5 44		      lda	ILPC+1
    835  1c62		       20 24 13 	      jsr	OUTHEX
    836  1c65		       a5 43		      lda	ILPC
    837  1c67		       20 24 13 	      jsr	OUTHEX
    838  1c6a		       a9 20		      lda	#SPACE
    839  1c6c		       20 0b 1d 	      jsr	VOUTCH
    840  1c6f		       a0 00		      ldy	#0
    841  1c71		       b1 43		      lda	(ILPC),y
    842  1c73		       20 24 13 	      jsr	OUTHEX
    843  1c76							;
    844  1c76							; Display the CURPTR value and offset
    845  1c76							;
    846  1c76		       20 41 13 	      jsr	puts
      0  1c79					      db	", CURPTR: ",0
      1  1c79		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  1c84		       a5 50		      lda	CURPTR+1
    849  1c86		       20 24 13 	      jsr	OUTHEX
    850  1c89		       a5 4f		      lda	CURPTR
    851  1c8b		       20 24 13 	      jsr	OUTHEX
    852  1c8e		       a9 2b		      lda	#'+
    853  1c90		       20 0b 1d 	      jsr	VOUTCH
    854  1c93		       a5 51		      lda	CUROFF
    855  1c95		       20 24 13 	      jsr	OUTHEX
    856  1c98							;
    857  1c98		       20 c2 1b 	      jsr	CRLF
    858  1c9b		       20 f1 1c 	      jsr	SetOutConsole
    859  1c9e		       20 d1 1c 	      jsr	ILChkRange
    860  1ca1		       b0 02		      bcs	dbgLineErr
    861  1ca3		       18		      clc
    862  1ca4		       60		      rts
    863  1ca5
    864  1ca5				   dbgLineErr
    865  1ca5		       20 3b 1d 	      jsr	SetOutDebug
    866  1ca8		       20 41 13 	      jsr	puts
      0  1cab					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1cab		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  1ccc		       20 f1 1c 	      jsr	SetOutConsole
    869  1ccf		       38		      sec
    870  1cd0		       60		      rts
    871  1cd1
    872  1cd1		       a5 44	   ILChkRange lda	ILPC+1
    873  1cd3		       c9 1e		      cmp	#IL>>8
    874  1cd5		       90 18		      bcc	ILBadRange
    875  1cd7		       d0 06		      bne	ILChkHigh
    876  1cd9
    877  1cd9		       a5 43		      lda	ILPC
    878  1cdb		       c9 92		      cmp	#IL&$ff
    879  1cdd		       90 10		      bcc	ILBadRange
    880  1cdf
    881  1cdf		       a5 44	   ILChkHigh  lda	ILPC+1
    882  1ce1		       c9 23		      cmp	#ILEND>>8
    883  1ce3		       90 08		      bcc	ILGoodRange
    884  1ce5		       d0 08		      bne	ILBadRange
    885  1ce7
    886  1ce7		       a5 43		      lda	ILPC
    887  1ce9		       c9 5e		      cmp	#ILEND&$ff
    888  1ceb		       b0 02		      bcs	ILBadRange
    889  1ced
    890  1ced		       18	   ILGoodRange clc
    891  1cee		       60		      rts
    892  1cef				   ILBadRange
    893  1cef		       38		      sec
    894  1cf0		       60		      rts
    895  1cf1
    896  1cf1
    897  1cf1							;=====================================================
    898  1cf1							; Set output vector to the console output function
    899  1cf1							;
    900  1cf1				   SetOutConsole
    901  1cf1		       48		      pha
    902  1cf2		       a9 0c		      lda	#OUTCH&$ff
    903  1cf4		       8d c0 2c 	      sta	BOutVec
    904  1cf7		       a9 f0		      lda	#OUTCH>>8
    905  1cf9		       8d c1 2c 	      sta	BOutVec+1
    906  1cfc		       68		      pla
    907  1cfd		       60		      rts
    908  1cfe
    909  1cfe				   SetInConsole
    910  1cfe		       48		      pha
    911  1cff		       a9 09		      lda	#GETCH&$ff
    912  1d01		       8d c2 2c 	      sta	BInVec
    913  1d04		       a9 f0		      lda	#GETCH>>8
    914  1d06		       8d c3 2c 	      sta	BInVec+1
    915  1d09		       68		      pla
    916  1d0a		       60		      rts
    917  1d0b
    918  1d0b							;=====================================================
    919  1d0b							; Jump to the output/input function in BOutVec/BInVec
    920  1d0b							;
    921  1d0b		       6c c0 2c    VOUTCH     jmp	(BOutVec)
    922  1d0e		       6c c2 2c    VGETCH     jmp	(BInVec)
    923  1d11
    924  1d11
    925  1d11							;====================================================
    926  1d11							;Clear the terminal assume it is ansii or vt100
    927  1d11							;
    928  1d11				   iCLEARSCREEN
    929  1d11		       20 41 13 	      jsr	puts
      0  1d14					      db	$1b,'[,'2,'J,0
      1  1d14		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    931  1d19		       4c c2 02 	      jmp	NextIL
    932  1d1c
    933  1d1c							;====================================================
    934  1d1c							; Push true and false onto math stack
    935  1d1c				   pushTrue
    936  1d1c		       a9 ff		      lda	#$ff
    937  1d1e		       85 52	   pushTF     sta	R0
    938  1d20		       85 53		      sta	R0+1
    939  1d22		       20 85 1a 	      jsr	pushR0
    940  1d25		       60		      rts
    941  1d26		       a9 00	   pushFalse  lda	#0
    942  1d28		       f0 f4		      beq	pushTF
    943  1d2a
    944  1d2a							;======================================================
    945  1d2a							; Copy stack top to R1
    946  1d2a				   CopyStackR1
    947  1d2a		       98		      tya
    948  1d2b		       48		      pha
    949  1d2c		       a4 4a		      ldy	MATHSTACKPTR
    950  1d2e		       88		      dey
    951  1d2f		       b1 48		      lda	(MATHSTACK),y
    952  1d31		       85 55		      sta	R1+1
    953  1d33		       88		      dey
    954  1d34		       b1 48		      lda	(MATHSTACK),y
    955  1d36		       85 54		      sta	R1
    956  1d38		       68		      pla
    957  1d39		       a8		      tay
    958  1d3a		       60		      rts
    959  1d3b
    960  1d3b
    961  1d3b							;====================================================
    962  1d3b							;Swap the out debug call for standard calls
    963  1d3b
    964  1d3b				   SetOutDebug
    965  1d3b					      if	USEDEBUGPORT
    966  1d3b		       a9 5b		      lda	#OUTDEBUG&$ff	; Put the Debug output
    967  1d3d		       8d c0 2c 	      sta	BOutVec
    968  1d40		       a9 1d		      lda	#OUTDEBUG>>8
    969  1d42		       8d c1 2c 	      sta	BOutVec+1
    970  1d45					      endif
    971  1d45		       60		      rts
    972  1d46				   SetInDebug
    973  1d46					      if	USEDEBUGPORT
    974  1d46		       a9 5f		      lda	#INDEBUG&$ff
    975  1d48		       8d c2 2c 	      sta	BInVec
    976  1d4b		       a9 1d		      lda	#INDEBUG>>8
    977  1d4d		       8d c3 2c 	      sta	BInVec+1
    978  1d50					      endif
    979  1d50		       60		      rts
    980  1d51							;
    981  1d51							;====================================================
    982  1d51							; Output to the debug console
    983  1d51							;     x = high address byte
    984  1d51							;     y = low address byte
    985  1d51							;     a = Terminator for string
    986  1d51				   DebugWrite
    987  1d51		       20 3b 1d 	      jsr	SetOutDebug
    988  1d54		       20 7d 13 	      jsr	PrtStr
    989  1d57		       20 f1 1c 	      jsr	SetOutConsole
    990  1d5a		       60		      rts
    991  1d5b
    992  1d5b				   OUTDEBUG
    993  1d5b		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
    994  1d5e		       60		      RTS
    995  1d5f
    996  1d5f		       ad 20 e0    INDEBUG    lda	DEBUGPORT
    997  1d62		       29 01		      and	#$01
    998  1d64		       f0 f9		      beq	INDEBUG
    999  1d66		       ad 21 e0 	      lda	DEBUGPORT+1
   1000  1d69		       60		      rts
   1001  1d6a
   1002  1d6a
   1003  1d6a
   1004  1d6a
   1005  1d6a
   1006  1d6a
   1007  1d6a
   1008  1d6a
   1009  1d6a
   1010  1d6a
   1011  1d6a
   1012  1d6a
   1013  1d6a
   1014  1d6a
   1015  1d6a
   1016  1d6a
   1017  1d6a
   1018  1d6a
   1019  1d6a
------- FILE mytb.asm
   2215  1d6a
   2216  1d6a					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  1d6a					      include	"storage.asm"
      1  1d6a							;
      2  1d6a							;=====================================================
      3  1d6a							;=====================================================
      4  1d6a							;=====================================================
      5  1d6a							; This file contains the functions for saving and
      6  1d6a							; restoring programs from some sort of mass storage
      7  1d6a							; device.  This particular version is for using the
      8  1d6a							; Corsham Tech SD Card System.
      9  1d6a							;=====================================================
     10  1d6a							;=====================================================
     11  1d6a							;=====================================================
     12  1d6a
     13 U235e					      seg.u	TBData
     14 U235e		       00	   diskBufLength ds	1
     15 U235f		       00	   diskBufOffset ds	1
     16 U2360		       00 00 00 00*DiskFileName ds	14
     17 U236e
     18  1d6a					      SEG	Code
     19  1d6a
     20  1d6a							;
     21  1d6a							;=====================================================
     22  1d6a							; Open a file for reading as a program.  The next
     23  1d6a							; thing on the line should be the filename.
     24  1d6a							;
     25  1d6a				   iOPENREAD
     26  1d6a					      if	XKIM || CTMON65
     27  1d6a		       a4 51		      ldy	CUROFF
     28  1d6c		       b1 4f		      lda	(CURPTR),y
     29  1d6e		       d0 07		      bne	iOPENfn	;might be filename
     30  1d70							;
     31  1d70							; No filename supplied.
     32  1d70							;
     33  1d70		       a9 00	   iOPENnofn  lda	#0
     34  1d72		       a2 09		      ldx	#ERR_NO_FILENAME
     35  1d74		       4c 1f 06 	      jmp	iErr2
     36  1d77							;
     37  1d77							; Add the offset into the buffer start
     38  1d77							;
     39  1d77		       18	   iOPENfn    clc
     40  1d78		       98		      tya
     41  1d79		       65 4f		      adc	CURPTR
     42  1d7b		       a8		      tay		;LSB
     43  1d7c		       a5 50		      lda	CURPTR+1
     44  1d7e		       69 00		      adc	#0
     45  1d80		       aa		      tax
     46  1d81		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  1d84		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1d86							;
     49  1d86							; Open failed
     50  1d86							;
     51  1d86		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1d88		       a9 00	   Rdfail2    lda	#0
     53  1d8a		       4c 1f 06 	      jmp	iErr2
     54  1d8d							;
     55  1d8d							; Clear counts and offsets so the next read will
     56  1d8d							; cause the file to be read.
     57  1d8d							;
     58  1d8d		       a9 00	   Ropenok    lda	#0
     59  1d8f		       8d 5f 23 	      sta	diskBufOffset
     60  1d92		       8d 5e 23 	      sta	diskBufLength
     61  1d95		       4c c2 02 	      jmp	NextIL
     62  1d98					      endif
     63  1d98
     64  1d98							;
     65  1d98							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1d98							;Remove a file from the disk
     67  1d98				   iRMFILE
     68  1d98					      if	XKIM || CTMON65
     69  1d98		       a4 51		      ldy	CUROFF
     70  1d9a		       b1 4f		      lda	(CURPTR),y
     71  1d9c		       f0 19		      beq	iRMnofn
     72  1d9e							;
     73  1d9e		       18		      clc
     74  1d9f		       98		      tya
     75  1da0		       65 4f		      adc	CURPTR
     76  1da2		       a8		      tay		;LSB
     77  1da3		       a5 50		      lda	CURPTR+1
     78  1da5		       69 00		      adc	#0
     79  1da7		       aa		      tax
     80  1da8		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1dab		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1dad		       a9 00		      lda	#0
     83  1daf		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1db1		       4c 1f 06 	      jmp	iErr2
     85  1db4		       4c c2 02    wrmOk      jmp	NextIL
     86  1db7
     87  1db7							; No filename supplied.
     88  1db7							;
     89  1db7		       a9 00	   iRMnofn    lda	#0
     90  1db9		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1dbb		       4c 1f 06 	      jmp	iErr2
     92  1dbe					      endif
     93  1dbe							;
     94  1dbe							;=====================================================
     95  1dbe				   iOPENWRITE
     96  1dbe					      if	XKIM || CTMON65
     97  1dbe		       a4 51		      ldy	CUROFF
     98  1dc0		       b1 4f		      lda	(CURPTR),y
     99  1dc2		       f0 f3		      beq	iRMnofn
    100  1dc4							;
    101  1dc4		       18		      clc
    102  1dc5		       98		      tya
    103  1dc6		       65 4f		      adc	CURPTR
    104  1dc8		       a8		      tay		;LSB
    105  1dc9		       a5 50		      lda	CURPTR+1
    106  1dcb		       69 00		      adc	#0
    107  1dcd		       aa		      tax
    108  1dce		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1dd1		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1dd3							;
    111  1dd3							; Open failed
    112  1dd3							;
    113  1dd3		       a9 00	   Wdfail     lda	#0
    114  1dd5		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1dd7		       4c 1f 06 	      jmp	iErr2
    116  1dda							;
    117  1dda		       4c c2 02    Wopenok    jmp	NextIL
    118  1ddd					      endif
    119  1ddd							;
    120  1ddd							;=====================================================
    121  1ddd							; Gets a line of input from the disk file and puts it
    122  1ddd							; into LINBUF.
    123  1ddd							;
    124  1ddd							; On exit:
    125  1ddd							;    CURPTR points to LINBUF
    126  1ddd							;    LINBUF contains the line with 0 at the end.
    127  1ddd							;    Y has offset to first non-space character
    128  1ddd							;    CURROFF has the same as Y.
    129  1ddd							;
    130  1ddd				   iDGETLINE
    131  1ddd					      if	XKIM || CTMON65
    132  1ddd		       a2 2f		      ldx	#LINBUF&$ff
    133  1ddf		       86 4f		      stx	CURPTR
    134  1de1		       a2 2c		      ldx	#LINBUF>>8
    135  1de3		       86 50		      stx	CURPTR+1
    136  1de5							;
    137  1de5		       a2 00		      ldx	#0	;offset
    138  1de7		       8e b3 2c    iDgetLoop  stx	getlinx
    139  1dea		       20 4b 1e 	      jsr	getNextFileByte
    140  1ded		       b0 16		      bcs	iGetEOF
    141  1def		       c9 0d		      cmp	#CR
    142  1df1		       f0 0d		      beq	iGetEOL
    143  1df3		       c9 0a		      cmp	#LF
    144  1df5		       f0 09		      beq	iGetEOL
    145  1df7		       ae b3 2c 	      ldx	getlinx
    146  1dfa		       9d 2f 2c 	      sta	LINBUF,x
    147  1dfd		       e8		      inx
    148  1dfe		       d0 e7		      bne	iDgetLoop
    149  1e00							;
    150  1e00							; Handle end of line.	If the line has nothing, loop
    151  1e00							; back and get another line.
    152  1e00							;
    153  1e00		       ae b3 2c    iGetEOL    ldx	getlinx	;blank line?
    154  1e03		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  1e05							;
    156  1e05							; This can fall through when there is a line, or
    157  1e05							; called directly when EOF is encountered.
    158  1e05							;
    159  1e05		       ae b3 2c    iGetEOF    ldx	getlinx
    160  1e08		       a9 00		      lda	#0
    161  1e0a		       9d 2f 2c 	      sta	LINBUF,x
    162  1e0d		       85 51		      sta	CUROFF
    163  1e0f		       a0 00		      ldy	#0
    164  1e11		       20 b9 1b 	      jsr	SkipSpaces
    165  1e14		       20 0a 0f 	      jsr	ParseInputLine
    166  1e17		       4c c2 02 	      jmp	NextIL
    167  1e1a					      endif
    168  1e1a
    169  1e1a							;
    170  1e1a							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  1e1a							; DISK
    172  1e1a							;
    173  1e1a				   iDDIR
    174  1e1a					      if	XKIM || CTMON65
    175  1e1a		       20 30 f0 	      jsr	DiskDir
    176  1e1d							;
    177  1e1d							; Get/Display each entry
    178  1e1d							;
    179  1e1d		       a2 23	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  1e1f		       a0 60		      ldy	#DiskFileName&$ff
    181  1e21		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  1e24		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  1e26		       20 41 13 	      jsr	puts
      0  1e29					      db	"   ",0
      1  1e29		       20 20 20 00	      .byte.b	"   ",0
    185  1e2d							; Print the line to the console
    186  1e2d		       a2 23		      ldx	#DiskFileName>>8	;pointer to buffer
    187  1e2f		       a0 60		      ldy	#DiskFileName&$ff
    188  1e31		       a5 00		      lda	0
    189  1e33		       20 7d 13 	      jsr	PrtStr	;else print name
    190  1e36		       20 18 f0 	      jsr	crlf
    191  1e39
    192  1e39		       4c 1d 1e 	      jmp	DiskDirLoop	;do next entry
    193  1e3c
    194  1e3c		       4c c2 02    DiskDirEnd jmp	NextIL
    195  1e3f					      endif
    196  1e3f							;
    197  1e3f							;=====================================================
    198  1e3f							; Does a LIST to a Disk file.
    199  1e3f							;
    200  1e3f				   iDLIST
    201  1e3f					      if	XKIM || CTMON65
    202  1e3f		       20 7a 1e 	      jsr	SetOutDisk
    203  1e42		       4c ef 07 	      jmp	iLST2
    204  1e45					      endif
    205  1e45							;
    206  1e45							;=====================================================
    207  1e45							; Closes any pending disk file.  Okay to call if there
    208  1e45							; is no open file.
    209  1e45							;
    210  1e45				   iDCLOSE
    211  1e45					      if	XKIM || CTMON65
    212  1e45		       20 42 f0 	      jsr	DiskClose
    213  1e48		       4c c2 02 	      jmp	NextIL
    214  1e4b					      endif
    215  1e4b							;
    216  1e4b							;=====================================================
    217  1e4b							; This gets the next byte from an open disk file.  If
    218  1e4b							; there are no more bytes left, this returns C set.
    219  1e4b							; Else, C is clear and A contains the character.
    220  1e4b							;
    221  1e4b				   getNextFileByte
    222  1e4b					      if	XKIM || CTMON65
    223  1e4b		       ae 5f 23 	      ldx	diskBufOffset
    224  1e4e		       ec 5e 23 	      cpx	diskBufLength
    225  1e51		       d0 14		      bne	hasdata	;branch if still data
    226  1e53							;
    227  1e53							; There is no data left in the buffer, so read a
    228  1e53							; block from the SD system.
    229  1e53							;
    230  1e53		       a9 84		      lda	#BUFFER_SIZE
    231  1e55		       a2 df		      ldx	#buffer>>8
    232  1e57		       a0 0a		      ldy	#buffer&$ff
    233  1e59		       20 3c f0 	      jsr	DiskRead
    234  1e5c		       b0 12		      bcs	getNextEof
    235  1e5e							;
    236  1e5e							; A contains the number of bytes actually read.
    237  1e5e							;
    238  1e5e		       8d 5e 23 	      sta	diskBufLength	;save length
    239  1e61		       c9 00		      cmp	#0	;shouldn't happen
    240  1e63		       f0 0b		      beq	getNextEof
    241  1e65							;
    242  1e65		       a2 00		      ldx	#0
    243  1e67		       bd 0a df    hasdata    lda	buffer,x
    244  1e6a		       e8		      inx
    245  1e6b		       8e 5f 23 	      stx	diskBufOffset
    246  1e6e		       18		      clc
    247  1e6f		       60		      rts
    248  1e70							;
    249  1e70		       a9 00	   getNextEof lda	#0
    250  1e72		       8d 5f 23 	      sta	diskBufOffset
    251  1e75		       8d 5e 23 	      sta	diskBufLength
    252  1e78		       38		      sec
    253  1e79		       60		      rts
    254  1e7a							;
    255  1e7a							;=====================================================
    256  1e7a							; Set output vector to the disk output function
    257  1e7a							;
    258  1e7a		       a9 85	   SetOutDisk lda	#DOUT&$ff
    259  1e7c		       8d c0 2c 	      sta	BOutVec
    260  1e7f		       a9 1e		      lda	#DOUT/256
    261  1e81		       8d c1 2c 	      sta	BOutVec+1
    262  1e84		       60		      rts
    263  1e85							;
    264  1e85							;=====================================================
    265  1e85
    266  1e85		       8d 0a df    DOUT       sta	buffer
    267  1e88		       a9 01		      lda	#1
    268  1e8a		       a0 0a		      ldy	#buffer&$ff
    269  1e8c		       a2 df		      ldx	#buffer>>8
    270  1e8e		       20 3f f0 	      jsr	DiskWrite
    271  1e91							;
    272  1e91							; need error checking here
    273  1e91							;
    274  1e91		       60		      rts
    275  1e92					      endif
    276  1e92
    277  1e92
------- FILE mytb.asm
   2218  1e92					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1e92					      include	"IL.inc"
      1  1e92
      2  1e92							;=====================================================
      3  1e92							; IL.inc
      4  1e92							; These are macros for IL instructions
      5  1e92							;
      6  1e92					      mac	dw
      7  1e92					      .word	{0}
      8  1e92					      endm
      9  1e92					      mac	db
     10  1e92					      .byte	{0}
     11  1e92					      endm
     12  1e92					      macro	xinit
     13  1e92					      db	0
     14  1e92					      endm		;reset the il to start clear all
     15  1e92							;
     16  1e92					      macro	done
     17  1e92					      db	1
     18  1e92					      endm		;print an error if not end of line
     19  1e92							;
     20  1e92					      macro	prs
     21  1e92					      db	2
     22  1e92					      endm		;print a quoted string
     23  1e92							;
     24  1e92					      macro	prn
     25  1e92					      db	3
     26  1e92					      endm		;print a number
     27  1e92							;
     28  1e92					      macro	spc
     29  1e92					      db	4
     30  1e92					      endm		;print space til new tabstop
     31  1e92							;
     32  1e92					      macro	nline
     33  1e92					      db	5
     34  1e92					      endm		;print a new line crlf
     35  1e92							;
     36  1e92							; My NXT is a bit different in that it takes one
     37  1e92							; parameter, which is an address.  If the BASIC
     38  1e92							; program is currently running then move to the
     39  1e92							; next line and continue execution.  However, if
     40  1e92							; in direct mode, jump to the specified IL label.
     41  1e92							;
     42  1e92					      macro	nxt
     43  1e92					      db	6
     44  1e92					      dw	{1}	; addr
     45  1e92					      endm		; addr
     46  1e92							;
     47  1e92					      macro	xfer
     48  1e92					      db	7
     49  1e92					      endm
     50  1e92							;
     51  1e92					      macro	sav
     52  1e92					      db	8
     53  1e92					      db	{1}
     54  1e92					      endm
     55  1e92							;
     56  1e92					      macro	rstr
     57  1e92					      db	9
     58  1e92					      endm
     59  1e92							;
     60  1e92					      macro	cmpr
     61  1e92					      db	10
     62  1e92					      endm
     63  1e92							;
     64  1e92					      macro	innum
     65  1e92					      db	11
     66  1e92					      endm
     67  1e92							;
     68  1e92					      macro	fin
     69  1e92					      db	12
     70  1e92					      endm
     71  1e92							;
     72  1e92							; ERR is followed by an error number.	The error
     73  1e92							; code is printed along with the line number.
     74  1e92							; Control is passed to the statement set with
     75  1e92							; the ERRGOTO statement.
     76  1e92							;
     77  1e92					      macro	errmsg
     78  1e92					      db	13
     79  1e92					      dw	{1}	;ecode
     80  1e92					      endm		;ecode
     81  1e92							;
     82  1e92					      macro	add
     83  1e92					      db	14
     84  1e92					      endm
     85  1e92							;
     86  1e92					      macro	sub
     87  1e92					      db	15
     88  1e92					      endm
     89  1e92							;
     90  1e92					      macro	neg
     91  1e92					      db	16
     92  1e92					      endm
     93  1e92							;
     94  1e92					      macro	mul
     95  1e92					      db	17
     96  1e92					      endm
     97  1e92							;
     98  1e92					      macro	div
     99  1e92					      db	18
    100  1e92					      endm
    101  1e92							;
    102  1e92					      macro	store
    103  1e92					      db	19
    104  1e92					      endm
    105  1e92							;
    106  1e92					      macro	ind
    107  1e92					      db	20
    108  1e92					      endm
    109  1e92							;
    110  1e92					      macro	lst
    111  1e92					      db	21
    112  1e92					      endm
    113  1e92							;
    114  1e92					      macro	init
    115  1e92					      db	22
    116  1e92					      endm
    117  1e92							;
    118  1e92					      macro	getline
    119  1e92					      db	23
    120  1e92					      endm
    121  1e92							;
    122  1e92					      macro	insert
    123  1e92					      db	24
    124  1e92					      endm
    125  1e92							;
    126  1e92					      macro	rtn
    127  1e92					      db	25
    128  1e92					      endm
    129  1e92							;
    130  1e92					      macro	exit
    131  1e92					      db	26
    132  1e92					      endm
    133  1e92							;
    134  1e92					      macro	lit
    135  1e92					      db	27
    136  1e92					      dw	{1}	;value
    137  1e92					      endm		; value LIT
    138  1e92							;
    139  1e92					      macro	call
    140  1e92					      db	28
    141  1e92					      dw	{1}	;addr
    142  1e92					      endm		;addr
    143  1e92							;
    144  1e92							; IJMP will set the IL PC to the specified value.
    145  1e92							;
    146  1e92					      macro	ijmp
    147  1e92					      db	29
    148  1e92					      dw	{1}	;addr
    149  1e92					      endm		;addr
    150  1e92							;
    151  1e92					      macro	vinit
    152  1e92					      db	30
    153  1e92					      endm
    154  1e92							;
    155  1e92							; ERRGOTO sets the point in the code where the IL
    156  1e92							; interpreter will go after any error.
    157  1e92							;
    158  1e92					      macro	errgoto
    159  1e92					      db	31
    160  1e92					      dw	{1}	;addr
    161  1e92					      endm		;addr
    162  1e92							;
    163  1e92					      macro	tst
    164  1e92					      db	32
    165  1e92					      db	({1}-*)-1	;(addr-*)-1
    166  1e92					      db	{2},0	;string,0
    167  1e92					      endm		;addr,string
    168  1e92							;
    169  1e92					      macro	tstv
    170  1e92					      db	33
    171  1e92					      db	({1}-*)-1	;(addr-*)-1
    172  1e92					      endm		;addr
    173  1e92							;
    174  1e92					      macro	tstl
    175  1e92					      db	34
    176  1e92					      db	({1}-*)-1	;(addr-*)-1
    177  1e92					      endm		;addr
    178  1e92							;
    179  1e92					      macro	tstn
    180  1e92					      db	35
    181  1e92					      db	({1}-*)-1	;(addr-*)-1
    182  1e92					      endm		;addr
    183  1e92							;
    184  1e92							; FREE returns the amount of free RAM on top of
    185  1e92							; the stack.  This is the amount of room the user
    186  1e92							; program has available.
    187  1e92							;
    188  1e92					      macro	free
    189  1e92					      db	36
    190  1e92					      endm
    191  1e92							;
    192  1e92							; RANDOM takes the top item off the stack and
    193  1e92							; replaces it with a random number that is
    194  1e92							; MOD the initial value.  Ie, if the TOS is
    195  1e92							; 42 then RANDOM returns a value from 0 to 41.
    196  1e92							;
    197  1e92					      macro	random
    198  1e92					      db	37
    199  1e92					      endm
    200  1e92							;
    201  1e92							; ABS will replace the top of stack with the
    202  1e92							; absolute value.
    203  1e92							;
    204  1e92					      macro	abs
    205  1e92					      db	38
    206  1e92					      endm
    207  1e92							;
    208  1e92							; OPENREAD opens a file for reading, as in getting
    209  1e92							; statements from it.
    210  1e92							;
    211  1e92					      macro	openread
    212  1e92					      db	39
    213  1e92					      endm
    214  1e92							;
    215  1e92							; OPENWRITE opens a file for writing, as in saving
    216  1e92							; the current program to it.
    217  1e92							;
    218  1e92					      macro	openwrite
    219  1e92					      db	40
    220  1e92					      endm
    221  1e92							;
    222  1e92							; DCLOSE closes any open disk file.
    223  1e92							;
    224  1e92					      macro	dclose
    225  1e92					      db	41
    226  1e92					      endm
    227  1e92							;
    228  1e92							; DGETLINE gets one line from the disk file and puts it
    229  1e92							; into LINBUFF.
    230  1e92							;
    231  1e92					      macro	dgetline
    232  1e92					      db	42
    233  1e92					      endm
    234  1e92							;
    235  1e92							; DLIST saves the program to an open disk file.
    236  1e92							;
    237  1e92					      macro	dlist
    238  1e92					      db	43
    239  1e92					      endm
    240  1e92							; DDIR list the current directory
    241  1e92							;
    242  1e92					      macro	ddir
    243  1e92					      db	44
    244  1e92					      endm
    245  1e92
    246  1e92							; RMFILE remove a fle from disk
    247  1e92					      macro	rmfile
    248  1e92					      db	45
    249  1e92					      endm
    250  1e92
    251  1e92							; CLEARSCREEN clear the screen
    252  1e92					      macro	clearscreen
    253  1e92					      db	46
    254  1e92					      endm
    255  1e92							; POKEMEM Poke value into memory
    256  1e92					      macro	pokemem
    257  1e92					      db	47
    258  1e92					      endm
    259  1e92							; PEEKMEM peek at value in memory
    260  1e92					      macro	peekmem
    261  1e92					      db	48
    262  1e92					      endm
    263  1e92							; TSTLET Test if the statement is a let without the keyword let
    264  1e92					      macro	tstlet
    265  1e92					      db	49
    266  1e92					      db	({1}-*)-1	;(addr-*)-1
    267  1e92					      endm		;addr
    268  1e92							; TSTDONE if we reach the end of a statement
    269  1e92					      macro	tstdone
    270  1e92					      db	50
    271  1e92					      db	({1}-*)-1	;(addr-*)-1
    272  1e92					      endm		;addr
    273  1e92							; GETCHAR	get a character from the input line leave it in RO
    274  1e92					      macro	getchar
    275  1e92					      db	51
    276  1e92					      endm
    277  1e92							; PUTCHAR	Put a character to the terminal
    278  1e92					      macro	putchar
    279  1e92					      db	52
    280  1e92					      endm
    281  1e92							; Call		Call a machine function return a to stack
    282  1e92					      macro	callfunc
    283  1e92					      db	53
    284  1e92					      endm
    285  1e92
    286  1e92							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1e92					      macro	ibranch
    288  1e92					      db	54
    289  1e92					      endm
    290  1e92
    291  1e92							; TSTSTR	 Tests for the open quote in a string
    292  1e92					      macro	tststr
    293  1e92					      db	55
    294  1e92					      db	({1}-*)-1	;(addr-*)-1
    295  1e92					      endm
    296  1e92							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1e92					      macro	setirq
    298  1e92					      db	56
    299  1e92					      endm
    300  1e92
    301  1e92							; TSTIRQ	Test for irq pending,
    302  1e92							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1e92					      macro	tstirq
    304  1e92					      db	57
    305  1e92					      db	({1}-*)-1	;(addr-*)-1
    306  1e92					      endm
    307  1e92
    308  1e92							; IRET    return from interupt service
    309  1e92					      macro	iret
    310  1e92					      db	58
    311  1e92					      endm
    312  1e92
    313  1e92							; INSTR   read a string from the input
    314  1e92					      macro	instr
    315  1e92					      db	59
    316  1e92					      endm
    317  1e92
    318  1e92							; MODULO Returns the remainder of the division
    319  1e92					      macro	modulo
    320  1e92					      db	60
    321  1e92					      endm
    322  1e92							; Set a task line
    323  1e92					      macro	taskcreate
    324  1e92					      db	61
    325  1e92					      endm
    326  1e92							; End a task
    327  1e92					      macro	etask
    328  1e92					      db	62
    329  1e92					      endm
    330  1e92							; Skip to next task
    331  1e92					      macro	ntask
    332  1e92					      db	63
    333  1e92					      endm
    334  1e92							; Subscript
    335  1e92					      macro	subscript
    336  1e92					      db	64
    337  1e92					      endm
    338  1e92							; KILL Task
    339  1e92					      macro	taskkill
    340  1e92					      db	65
    341  1e92					      endm
    342  1e92							; STAT Task
    343  1e92					      macro	taskstat
    344  1e92					      db	66
    345  1e92					      endm
    346  1e92							;  output value as hex
    347  1e92					      macro	hexprt
    348  1e92					      db	67
    349  1e92					      endm
    350  1e92							;  Read in background has completed
    351  1e92					      macro	readcomplete
    352  1e92					      db	68
    353  1e92					      endm
    354  1e92							;  ReadInput line
    355  1e92					      macro	readstart
    356  1e92					      db	69
    357  1e92					      endm
    358  1e92							; Startio request
    359  1e92					      macro	startio
    360  1e92					      db	70
    361  1e92					      endm
    362  1e92							; Endio
    363  1e92					      macro	endio
    364  1e92					      db	71
    365  1e92					      endm
    366  1e92							; Logical not
    367  1e92					      macro	lognot
    368  1e92					      db	72
    369  1e92					      endm
    370  1e92							; Logical OR
    371  1e92					      macro	logor
    372  1e92					      db	73
    373  1e92					      endm
    374  1e92							;Logical and
    375  1e92					      macro	logand
    376  1e92					      db	74
    377  1e92					      endm
    378  1e92							;Logical XOR
    379  1e92					      macro	logxor
    380  1e92					      db	75
    381  1e92					      endm
    382  1e92							;Wait for task to complete, or list of tasks
    383  1e92					      macro	wtask
    384  1e92					      db	76
    385  1e92					      db	({1}-*)-1	;(addr-*)-1
    386  1e92					      endm
    387  1e92							;Get the current task id
    388  1e92					      MACRO	taskpid
    389  1e92					      db	77
    390  1e92					      endm
    391  1e92							;Trace the basic execution
    392  1e92					      Macro	traceprogram
    393  1e92					      db	78
    394  1e92					      endm
    395  1e92							;Do a basic program Trace
    396  1e92					      Macro	debugbasic
    397  1e92					      db	79
    398  1e92					      endm
    399  1e92
    400  1e92							; Inter Process communications instructions
    401  1e92					      Macro	ipcsend
    402  1e92					      db	80
    403  1e92					      endm
    404  1e92					      Macro	ipcreceive
    405  1e92					      db	81
    406  1e92					      endm
    407  1e92					      Macro	ipccheck
    408  1e92					      db	82
    409  1e92					      endm
    410  1e92					      Macro	ipcio
    411  1e92					      db	83
    412  1e92					      endm
    413  1e92					      Macro	pushmathstack
    414  1e92					      db	84
    415  1e92					      endm
    416  1e92					      Macro	popmathstack
    417  1e92					      db	85
    418  1e92					      endm
    419  1e92					      Macro	savemathstack
    420  1e92					      db	86
    421  1e92					      endm
    422  1e92					      Macro	restoremathstack
    423  1e92					      db	87
    424  1e92					      endm
    425  1e92					      Macro	incparmcount
    426  1e92					      db	88
    427  1e92					      endm
    428  1e92					      Macro	taskgetmathstack
    429  1e92					      db	89
    430  1e92					      endm
    431  1e92					      Macro	taskenable
    432  1e92					      db	90
    433  1e92					      endm
    434  1e92					      Macro	tasksuspend
    435  1e92					      db	91
    436  1e92					      endm
    437  1e92					      Macro	taskputmathptr
    438  1e92					      db	92
    439  1e92					      endm
    440  1e92							; Test for an extension type of variable that allows access to a tasks variables
    441  1e92							; Using  PID!<Var name>
    442  1e92					      Macro	tstvt
    443  1e92					      db	93
    444  1e92					      db	({1}-*)-1	;(addr-*)-1
    445  1e92					      endm
    446  1e92
    447  1e92							; Provide access to R2 for the IL program
    448  1e92					      Macro	setr2
    449  1e92					      db	94
    450  1e92					      db	{1}	; R2 is only one byte
    451  1e92					      endm
    452  1e92							;Move stack top to temp
    453  1e92					      Macro	stk2tmp
    454  1e92					      db	95
    455  1e92					      endm
    456  1e92
    457  1e92					      Macro	tmp2stk
    458  1e92					      db	96
    459  1e92					      endm
    460  1e92
    461  1e92					      Macro	tstbyte
    462  1e92					      db	97
    463  1e92					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1e92					      dw	{2}	; address to check
    465  1e92					      db	{3}	; Value to compare
    466  1e92					      endm
    467  1e92
    468  1e92					      Macro	incvar
    469  1e92					      db	98
    470  1e92					      endm
    471  1e92					      Macro	decvar
    472  1e92					      db	99
    473  1e92					      endm
    474  1e92
    475  1e92					      Macro	slice
    476  1e92					      db	100
    477  1e92					      endm
    478  1e92
    479  1e92
    480  1e92
------- FILE mytb.asm
   2220  1e92							;
   2221  1e92				  -	      if	FIXED
   2222  1e92				  -	      org	$1000
   2223  1e92					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1e92					      include	"basic.il"
      1  1e92							;LET
      2  1e92							;=====================================================
      3  1e92							;=====================================================
      4  1e92					      seg	Code
      5  1e92							;=====================================================
      6  1e92							; This is the IL of the BASIC (or whatever) language.
      7  1e92							; Because of the way macros are implemented by as65,
      8  1e92							; labels can't be on the same line as a macro
      9  1e92							; invocation, so that's why labels are on separate
     10  1e92							; lines.
     11  1e92							;
     12  1e92		       1e 92	   IL	      equ	*
     13  1e92
     14  1e92							;THE IL CONTROL SECTION
     15  1e92
     16  1e92				   START
      0  1e92					      INIT		;INITIALIZE
      0  1e92					      db	22
      1  1e92		       16		      .byte.b	22
      0  1e93					      NLINE		;WRITE CRLF
      0  1e93					      db	5
      1  1e93		       05		      .byte.b	5
      0  1e94					      ERRGOTO	CO	;where to go after an error
      0  1e94					      db	31
      1  1e94		       1f		      .byte.b	31
      0  1e95					      dw	CO
      1  1e95		       98 1e		      .word.w	CO
      0  1e97					      VINIT		;clear all variables
      0  1e97					      db	30
      1  1e97		       1e		      .byte.b	30
     21  1e98							;
     22  1e98							; This is where we jump to get a line of commands or
     23  1e98							; a program from the user.
     24  1e98							;
     25  1e98				   CO
      0  1e98					      GETLINE		;WRITE PROMPT AND GET LINE
      0  1e98					      db	23
      1  1e98		       17		      .byte.b	23
      0  1e99					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1e99					      db	34
      1  1e99		       22		      .byte.b	34
      0  1e9a					      db	(XEC-*)-1
      1  1e9a		       04		      .byte.b	(XEC-*)-1
      0  1e9b					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1e9b					      db	24
      1  1e9b		       18		      .byte.b	24
      0  1e9c					      IJMP	CO
      0  1e9c					      db	29
      1  1e9c		       1d		      .byte.b	29
      0  1e9d					      dw	CO
      1  1e9d		       98 1e		      .word.w	CO
     30  1e9f				   XEC
      0  1e9f					      XINIT		;INITIALIZE
      0  1e9f					      db	0
      1  1e9f		       00		      .byte.b	0
     32  1ea0							;============================================================================
     33  1ea0							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1ea0							;
     35  1ea0				   STMT
      0  1ea0					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1ea0					      db	79
      1  1ea0		       4f		      .byte.b	79
      0  1ea1					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1ea1					      db	57
      1  1ea1		       39		      .byte.b	57
      0  1ea2					      db	(notirq-*)-1
      1  1ea2		       00		      .byte.b	(notirq-*)-1
     38  1ea3							;==========================================================================================
     39  1ea3							; Process a let statement implied or explicit.
     40  1ea3							;
     41  1ea3				   notirq
      0  1ea3					      TSTLET	LET	;Test if second field is = or []
      0  1ea3					      db	49
      1  1ea3		       31		      .byte.b	49
      0  1ea4					      db	(LET-*)-1
      1  1ea4		       03		      .byte.b	(LET-*)-1
      0  1ea5					      IJMP	DOLET	;allow the default to be let
      0  1ea5					      db	29
      1  1ea5		       1d		      .byte.b	29
      0  1ea6					      dw	DOLET
      1  1ea6		       ae 1e		      .word.w	DOLET
     44  1ea8				   LET
      0  1ea8					      TST	S1,"LET"	;IS STATEMENT A LET
      0  1ea8					      db	32
      1  1ea8		       20		      .byte.b	32
      0  1ea9					      db	(S1-*)-1
      1  1ea9		       21		      .byte.b	(S1-*)-1
      0  1eaa					      db	"LET",0
      1  1eaa		       4c 45 54 00	      .byte.b	"LET",0
     46  1eae				   DOLET
      0  1eae					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1eae					      db	33
      1  1eae		       21		      .byte.b	33
      0  1eaf					      db	(ERRVEC-*)-1
      1  1eaf		       ea		      .byte.b	(ERRVEC-*)-1
      0  1eb0					      TST	LETBE,"["
      0  1eb0					      db	32
      1  1eb0		       20		      .byte.b	32
      0  1eb1					      db	(LETBE-*)-1
      1  1eb1		       0a		      .byte.b	(LETBE-*)-1
      0  1eb2					      db	"[",0
      1  1eb2		       5b 00		      .byte.b	"[",0
      0  1eb4					      CALL	EXPR
      0  1eb4					      db	28
      1  1eb4		       1c		      .byte.b	28
      0  1eb5					      dw	EXPR
      1  1eb5		       3d 21		      .word.w	EXPR
      0  1eb7					      TST	ERRVEC,"]"
      0  1eb7					      db	32
      1  1eb7		       20		      .byte.b	32
      0  1eb8					      db	(ERRVEC-*)-1
      1  1eb8		       e1		      .byte.b	(ERRVEC-*)-1
      0  1eb9					      db	"]",0
      1  1eb9		       5d 00		      .byte.b	"]",0
      0  1ebb					      SUBSCRIPT
      0  1ebb					      db	64
      1  1ebb		       40		      .byte.b	64
     52  1ebc				   LETBE
      0  1ebc					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1ebc					      db	32
      1  1ebc		       20		      .byte.b	32
      0  1ebd					      db	(ERRVEC-*)-1
      1  1ebd		       dc		      .byte.b	(ERRVEC-*)-1
      0  1ebe					      db	"=",0
      1  1ebe		       3d 00		      .byte.b	"=",0
      0  1ec0					      CALL	EXPR	;PLACE EXPR VALUE ON MathSTK
      0  1ec0					      db	28
      1  1ec0		       1c		      .byte.b	28
      0  1ec1					      dw	EXPR
      1  1ec1		       3d 21		      .word.w	EXPR
      0  1ec3					      DONE		;REPORT ERROR IF NOT NEXT
      0  1ec3					      db	1
      1  1ec3		       01		      .byte.b	1
      0  1ec4					      STORE		;STORE RESULT
      0  1ec4					      db	19
      1  1ec4		       13		      .byte.b	19
      0  1ec5					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1ec5					      db	6
      1  1ec5		       06		      .byte.b	6
      0  1ec6					      dw	CO
      1  1ec6		       98 1e		      .word.w	CO
      0  1ec8					      IJMP	STMT
      0  1ec8					      db	29
      1  1ec8		       1d		      .byte.b	29
      0  1ec9					      dw	STMT
      1  1ec9		       a0 1e		      .word.w	STMT
     59  1ecb							;=============================================================
     60  1ecb							; Inc or dec a variable
     61  1ecb				   S1
      0  1ecb					      TST	S1Dec,"INC"	;Increment variable
      0  1ecb					      db	32
      1  1ecb		       20		      .byte.b	32
      0  1ecc					      db	(S1Dec-*)-1
      1  1ecc		       0e		      .byte.b	(S1Dec-*)-1
      0  1ecd					      db	"INC",0
      1  1ecd		       49 4e 43 00	      .byte.b	"INC",0
      0  1ed1					      TSTV	ERRVEC
      0  1ed1					      db	33
      1  1ed1		       21		      .byte.b	33
      0  1ed2					      db	(ERRVEC-*)-1
      1  1ed2		       c7		      .byte.b	(ERRVEC-*)-1
      0  1ed3					      INCVAR
      0  1ed3					      db	98
      1  1ed3		       62		      .byte.b	98
      0  1ed4					      DONE
      0  1ed4					      db	1
      1  1ed4		       01		      .byte.b	1
      0  1ed5					      NXT	CO
      0  1ed5					      db	6
      1  1ed5		       06		      .byte.b	6
      0  1ed6					      dw	CO
      1  1ed6		       98 1e		      .word.w	CO
      0  1ed8					      IJMP	STMT
      0  1ed8					      db	29
      1  1ed8		       1d		      .byte.b	29
      0  1ed9					      dw	STMT
      1  1ed9		       a0 1e		      .word.w	STMT
     68  1edb				   S1Dec
      0  1edb					      TST	S1Iret,"DEC"	;Dec variable
      0  1edb					      db	32
      1  1edb		       20		      .byte.b	32
      0  1edc					      db	(S1Iret-*)-1
      1  1edc		       0e		      .byte.b	(S1Iret-*)-1
      0  1edd					      db	"DEC",0
      1  1edd		       44 45 43 00	      .byte.b	"DEC",0
      0  1ee1					      TSTV	ERRVEC
      0  1ee1					      db	33
      1  1ee1		       21		      .byte.b	33
      0  1ee2					      db	(ERRVEC-*)-1
      1  1ee2		       b7		      .byte.b	(ERRVEC-*)-1
      0  1ee3					      DECVAR
      0  1ee3					      db	99
      1  1ee3		       63		      .byte.b	99
      0  1ee4					      DONE
      0  1ee4					      db	1
      1  1ee4		       01		      .byte.b	1
      0  1ee5					      NXT	CO
      0  1ee5					      db	6
      1  1ee5		       06		      .byte.b	6
      0  1ee6					      dw	CO
      1  1ee6		       98 1e		      .word.w	CO
      0  1ee8					      IJMP	STMT
      0  1ee8					      db	29
      1  1ee8		       1d		      .byte.b	29
      0  1ee9					      dw	STMT
      1  1ee9		       a0 1e		      .word.w	STMT
     75  1eeb							;====================================================================
     76  1eeb							; iret or ireturn, Return from interupt process
     77  1eeb							;
     78  1eeb				   S1Iret
      0  1eeb					      TST	S1S1,"IRET"	;test return from interupt
      0  1eeb					      db	32
      1  1eeb		       20		      .byte.b	32
      0  1eec					      db	(S1S1-*)-1
      1  1eec		       10		      .byte.b	(S1S1-*)-1
      0  1eed					      db	"IRET",0
      1  1eed		       49 52 45 54*	      .byte.b	"IRET",0
      0  1ef2					      TST	S1Sa,"URN"
      0  1ef2					      db	32
      1  1ef2		       20		      .byte.b	32
      0  1ef3					      db	(S1Sa-*)-1
      1  1ef3		       04		      .byte.b	(S1Sa-*)-1
      0  1ef4					      db	"URN",0
      1  1ef4		       55 52 4e 00	      .byte.b	"URN",0
     81  1ef8				   S1Sa
      0  1ef8					      DONE		;Must be only thing on the line
      0  1ef8					      db	1
      1  1ef8		       01		      .byte.b	1
      0  1ef9					      IRET		;RESTORE LINE NUMBER OF CALL
      0  1ef9					      db	58
      1  1ef9		       3a		      .byte.b	58
      0  1efa					      IJMP	STMT
      0  1efa					      db	29
      1  1efa		       1d		      .byte.b	29
      0  1efb					      dw	STMT
      1  1efb		       a0 1e		      .word.w	STMT
     85  1efd							;=======================================================================
     86  1efd							;Process if statement, if true then process all statements until end of line reached
     87  1efd				   S1S1
      0  1efd					      TST	S1Z,"IF"	;IF STATEMENT
      0  1efd					      db	32
      1  1efd		       20		      .byte.b	32
      0  1efe					      db	(S1Z-*)-1
      1  1efe		       11		      .byte.b	(S1Z-*)-1
      0  1eff					      db	"IF",0
      1  1eff		       49 46 00 	      .byte.b	"IF",0
      0  1f02					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1f02					      db	28
      1  1f02		       1c		      .byte.b	28
      0  1f03					      dw	EXPR
      1  1f03		       3d 21		      .word.w	EXPR
      0  1f05					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  1f05					      db	32
      1  1f05		       20		      .byte.b	32
      0  1f06					      db	(S1W-*)-1
      1  1f06		       05		      .byte.b	(S1W-*)-1
      0  1f07					      db	"THEN",0
      1  1f07		       54 48 45 4e*	      .byte.b	"THEN",0
     91  1f0c				   S1W
      0  1f0c					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1f0c					      db	54
      1  1f0c		       36		      .byte.b	54
      0  1f0d					      IJMP	STMT
      0  1f0d					      db	29
      1  1f0d		       1d		      .byte.b	29
      0  1f0e					      dw	STMT
      1  1f0e		       a0 1e		      .word.w	STMT
     94  1f10							;===============================================================
     95  1f10							; Test for GO
     96  1f10				   S1Z
      0  1f10					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1f10					      db	32
      1  1f10		       20		      .byte.b	32
      0  1f11					      db	(S2b-*)-1
      1  1f11		       19		      .byte.b	(S2b-*)-1
      0  1f12					      db	"GO",0
      1  1f12		       47 4f 00 	      .byte.b	"GO",0
     98  1f15							;================================================================
     99  1f15							; process a goto
      0  1f15					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  1f15					      db	32
      1  1f15		       20		      .byte.b	32
      0  1f16					      db	(S2-*)-1
      1  1f16		       07		      .byte.b	(S2-*)-1
      0  1f17					      db	"TO",0
      1  1f17		       54 4f 00 	      .byte.b	"TO",0
      0  1f1a					      CALL	EXPR	;GET LABEL
      0  1f1a					      db	28
      1  1f1a		       1c		      .byte.b	28
      0  1f1b					      dw	EXPR
      1  1f1b		       3d 21		      .word.w	EXPR
      0  1f1d					      XFER		;SET UP AND JUMP
      0  1f1d					      db	7
      1  1f1d		       07		      .byte.b	7
    103  1f1e				   S2
    104  1f1e							;===========================================================================
    105  1f1e							; Process gosub / function
    106  1f1e							;
      0  1f1e					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1f1e					      db	32
      1  1f1e		       20		      .byte.b	32
      0  1f1f					      db	(ERRVEC-*)-1
      1  1f1f		       7a		      .byte.b	(ERRVEC-*)-1
      0  1f20					      db	"SUB",0
      1  1f20		       53 55 42 00	      .byte.b	"SUB",0
      0  1f24					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  1f24					      db	28
      1  1f24		       1c		      .byte.b	28
      0  1f25					      dw	GOSUBSTATEMENT
      1  1f25		       44 23		      .word.w	GOSUBSTATEMENT
      0  1f27					      DONE		;ERROR IF CR NOT NEXT
      0  1f27					      db	1
      1  1f27		       01		      .byte.b	1
      0  1f28					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  1f28					      db	8
      1  1f28		       08		      .byte.b	8
      0  1f29					      db	GOSUB_RTN
      1  1f29		       01		      .byte.b	GOSUB_RTN
      0  1f2a					      XFER		;AND JUMP
      0  1f2a					      db	7
      1  1f2a		       07		      .byte.b	7
    112  1f2b							;
    113  1f2b							; End of gosub processing
    114  1f2b							;==========================================================================
    115  1f2b							; Return from a gosub
    116  1f2b				   S2b
      0  1f2b					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1f2b					      db	32
      1  1f2b		       20		      .byte.b	32
      0  1f2c					      db	(S3-*)-1
      1  1f2c		       36		      .byte.b	(S3-*)-1
      0  1f2d					      db	"RE",0
      1  1f2d		       52 45 00 	      .byte.b	"RE",0
      0  1f30					      TST	S2a,"T"
      0  1f30					      db	32
      1  1f30		       20		      .byte.b	32
      0  1f31					      db	(S2a-*)-1
      1  1f31		       27		      .byte.b	(S2a-*)-1
      0  1f32					      db	"T",0
      1  1f32		       54 00		      .byte.b	"T",0
      0  1f34					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  1f34					      db	32
      1  1f34		       20		      .byte.b	32
      0  1f35					      db	(S2aa-*)-1
      1  1f35		       04		      .byte.b	(S2aa-*)-1
      0  1f36					      db	"URN",0
      1  1f36		       55 52 4e 00	      .byte.b	"URN",0
    120  1f3a				   S2aa
      0  1f3a					      SETR2	0	; Default no return value
      0  1f3a					      db	94
      1  1f3a		       5e		      .byte.b	94
      0  1f3b					      db	0
      1  1f3b		       00		      .byte.b	0
      0  1f3c					      TST	S2RetDone,"("	; Check if we will return some value
      0  1f3c					      db	32
      1  1f3c		       20		      .byte.b	32
      0  1f3d					      db	(S2RetDone-*)-1
      1  1f3d		       0b		      .byte.b	(S2RetDone-*)-1
      0  1f3e					      db	"(",0
      1  1f3e		       28 00		      .byte.b	"(",0
      0  1f40					      SETR2	1	; Indicate a return value provided
      0  1f40					      db	94
      1  1f40		       5e		      .byte.b	94
      0  1f41					      db	1
      1  1f41		       01		      .byte.b	1
      0  1f42					      CALL	EXPR
      0  1f42					      db	28
      1  1f42		       1c		      .byte.b	28
      0  1f43					      dw	EXPR
      1  1f43		       3d 21		      .word.w	EXPR
      0  1f45					      TST	ERRVEC,")"	; Now a value is on the stack
      0  1f45					      db	32
      1  1f45		       20		      .byte.b	32
      0  1f46					      db	(ERRVEC-*)-1
      1  1f46		       53		      .byte.b	(ERRVEC-*)-1
      0  1f47					      db	")",0
      1  1f47		       29 00		      .byte.b	")",0
    126  1f49
    127  1f49				   S2RetDone
      0  1f49					      DONE		; MUST BE CR or :
      0  1f49					      db	1
      1  1f49		       01		      .byte.b	1
      0  1f4a					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  1f4a					      db	9
      1  1f4a		       09		      .byte.b	9
      0  1f4b					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  1f4b					      db	97
      1  1f4b		       61		      .byte.b	97
      0  1f4c					      db	(S2RetFunc-*)-1
      1  1f4c		       09		      .byte.b	(S2RetFunc-*)-1
      0  1f4d					      dw	R2
      1  1f4d		       58 00		      .word.w	R2
      0  1f4f					      db	1
      1  1f4f		       01		      .byte.b	1
      0  1f50					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  1f50					      db	6
      1  1f50		       06		      .byte.b	6
      0  1f51					      dw	CO
      1  1f51		       98 1e		      .word.w	CO
      0  1f53					      IJMP	STMT
      0  1f53					      db	29
      1  1f53		       1d		      .byte.b	29
      0  1f54					      dw	STMT
      1  1f54		       a0 1e		      .word.w	STMT
    133  1f56				   S2RetFunc
      0  1f56					      IJMP	GOFNRet	; Back into the Function
      0  1f56					      db	29
      1  1f56		       1d		      .byte.b	29
      0  1f57					      dw	GOFNRet
      1  1f57		       1a 23		      .word.w	GOFNRet
    135  1f59							;
    136  1f59							; End of return from gosub
    137  1f59							;============================================================================
    138  1f59							; Process REM statement
    139  1f59							;
    140  1f59				   S2a
      0  1f59					      TST	S3,"M"	;REMark.  Skip rest of line
      0  1f59					      db	32
      1  1f59		       20		      .byte.b	32
      0  1f5a					      db	(S3-*)-1
      1  1f5a		       08		      .byte.b	(S3-*)-1
      0  1f5b					      db	"M",0
      1  1f5b		       4d 00		      .byte.b	"M",0
      0  1f5d					      NXT	CO
      0  1f5d					      db	6
      1  1f5d		       06		      .byte.b	6
      0  1f5e					      dw	CO
      1  1f5e		       98 1e		      .word.w	CO
      0  1f60					      IJMP	STMT
      0  1f60					      db	29
      1  1f60		       1d		      .byte.b	29
      0  1f61					      dw	STMT
      1  1f61		       a0 1e		      .word.w	STMT
    144  1f63							;============================================================================
    145  1f63							; Print statement
    146  1f63							;
    147  1f63				   S3
      0  1f63					      TST	S3a,"?"	; ? symonym for print
      0  1f63					      db	32
      1  1f63		       20		      .byte.b	32
      0  1f64					      db	(S3a-*)-1
      1  1f64		       05		      .byte.b	(S3a-*)-1
      0  1f65					      db	"?",0
      1  1f65		       3f 00		      .byte.b	"?",0
      0  1f67					      IJMP	S4S
      0  1f67					      db	29
      1  1f67		       1d		      .byte.b	29
      0  1f68					      dw	S4S
      1  1f68		       75 1f		      .word.w	S4S
    150  1f6a				   S3a
      0  1f6a					      TST	S8,"PR"	;allow short form of print
      0  1f6a					      db	32
      1  1f6a		       20		      .byte.b	32
      0  1f6b					      db	(S8-*)-1
      1  1f6b		       5b		      .byte.b	(S8-*)-1
      0  1f6c					      db	"PR",0
      1  1f6c		       50 52 00 	      .byte.b	"PR",0
      0  1f6f					      TST	S4S,"INT"	;PRINT
      0  1f6f					      db	32
      1  1f6f		       20		      .byte.b	32
      0  1f70					      db	(S4S-*)-1
      1  1f70		       04		      .byte.b	(S4S-*)-1
      0  1f71					      db	"INT",0
      1  1f71		       49 4e 54 00	      .byte.b	"INT",0
    153  1f75				   S4S
      0  1f75					      STARTIO		;Lock task until io completes
      0  1f75					      db	70
      1  1f75		       46		      .byte.b	70
    155  1f76				   S4
      0  1f76					      TSTDONE	S4a	;Test if we just want crlf printed
      0  1f76					      db	50
      1  1f76		       32		      .byte.b	50
      0  1f77					      db	(S4a-*)-1
      1  1f77		       03		      .byte.b	(S4a-*)-1
      0  1f78					      IJMP	S6
      0  1f78					      db	29
      1  1f78		       1d		      .byte.b	29
      0  1f79					      dw	S6
      1  1f79		       91 1f		      .word.w	S6
    158  1f7b
    159  1f7b				   S4a
      0  1f7b					      TSTSTR	S7	;TEST FOR QUOTED String
      0  1f7b					      db	55
      1  1f7b		       37		      .byte.b	55
      0  1f7c					      db	(S7-*)-1
      1  1f7c		       21		      .byte.b	(S7-*)-1
      0  1f7d					      PRS		;PRINT STRING
      0  1f7d					      db	2
      1  1f7d		       02		      .byte.b	2
    162  1f7e				   S5
      0  1f7e					      TST	S6A,COMMA	;IS THERE MORE?
      0  1f7e					      db	32
      1  1f7e		       20		      .byte.b	32
      0  1f7f					      db	(S6A-*)-1
      1  1f7f		       08		      .byte.b	(S6A-*)-1
      0  1f80					      db	COMMA,0
      1  1f80		       2c 00		      .byte.b	COMMA,0
      0  1f82					      SPC		;SPACE TO NEXT ZONE
      0  1f82					      db	4
      1  1f82		       04		      .byte.b	4
      0  1f83					      TSTDONE	S4	;Not end of line jump back
      0  1f83					      db	50
      1  1f83		       32		      .byte.b	50
      0  1f84					      db	(S4-*)-1
      1  1f84		       f1		      .byte.b	(S4-*)-1
      0  1f85					      IJMP	S6Z	;YES JUMP BACK
      0  1f85					      db	29
      1  1f85		       1d		      .byte.b	29
      0  1f86					      dw	S6Z
      1  1f86		       93 1f		      .word.w	S6Z
    167  1f88
    168  1f88							;
    169  1f88							; If a semicolon, don't do anything.
    170  1f88							;
    171  1f88				   S6A
      0  1f88					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  1f88					      db	32
      1  1f88		       20		      .byte.b	32
      0  1f89					      db	(S6-*)-1
      1  1f89		       07		      .byte.b	(S6-*)-1
      0  1f8a					      db	SEMICOLON,0
      1  1f8a		       3b 00		      .byte.b	SEMICOLON,0
      0  1f8c					      TSTDONE	S4	;Jump Back if not end of line
      0  1f8c					      db	50
      1  1f8c		       32		      .byte.b	50
      0  1f8d					      db	(S4-*)-1
      1  1f8d		       e8		      .byte.b	(S4-*)-1
      0  1f8e					      IJMP	S6Z
      0  1f8e					      db	29
      1  1f8e		       1d		      .byte.b	29
      0  1f8f					      dw	S6Z
      1  1f8f		       93 1f		      .word.w	S6Z
    175  1f91				   S6
      0  1f91					      DONE		;ERROR IF CR NOT NEXT
      0  1f91					      db	1
      1  1f91		       01		      .byte.b	1
      0  1f92					      NLINE
      0  1f92					      db	5
      1  1f92		       05		      .byte.b	5
    178  1f93				   S6Z
      0  1f93					      ENDIO		;release task io completed
      0  1f93					      db	71
      1  1f93		       47		      .byte.b	71
      0  1f94					      NXT	CO	;exit here if , or ; at end of print
      0  1f94					      db	6
      1  1f94		       06		      .byte.b	6
      0  1f95					      dw	CO
      1  1f95		       98 1e		      .word.w	CO
      0  1f97					      IJMP	STMT
      0  1f97					      db	29
      1  1f97		       1d		      .byte.b	29
      0  1f98					      dw	STMT
      1  1f98		       a0 1e		      .word.w	STMT
    182  1f9a							;
    183  1f9a							; A jump for code too far away for relative branch
    184  1f9a							;
    185  1f9a				   ERRVEC
      0  1f9a					      ENDIO
      0  1f9a					      db	71
      1  1f9a		       47		      .byte.b	71
      0  1f9b					      IJMP	UNKNOWN
      0  1f9b					      db	29
      1  1f9b		       1d		      .byte.b	29
      0  1f9c					      dw	UNKNOWN
      1  1f9c		       39 21		      .word.w	UNKNOWN
    188  1f9e							;
    189  1f9e							; Get here if there is an expression to print
    190  1f9e				   S7
      0  1f9e					      TST	S7AUnsigned,"$"
      0  1f9e					      db	32
      1  1f9e		       20		      .byte.b	32
      0  1f9f					      db	(S7AUnsigned-*)-1
      1  1f9f		       09		      .byte.b	(S7AUnsigned-*)-1
      0  1fa0					      db	"$",0
      1  1fa0		       24 00		      .byte.b	"$",0
      0  1fa2					      CALL	EXPR
      0  1fa2					      db	28
      1  1fa2		       1c		      .byte.b	28
      0  1fa3					      dw	EXPR
      1  1fa3		       3d 21		      .word.w	EXPR
      0  1fa5					      HEXPRT
      0  1fa5					      db	67
      1  1fa5		       43		      .byte.b	67
      0  1fa6					      IJMP	S5
      0  1fa6					      db	29
      1  1fa6		       1d		      .byte.b	29
      0  1fa7					      dw	S5
      1  1fa7		       7e 1f		      .word.w	S5
    195  1fa9
    196  1fa9				   S7AUnsigned
    197  1fa9
      0  1fa9					      TST	S7A,"%"
      0  1fa9					      db	32
      1  1fa9		       20		      .byte.b	32
      0  1faa					      db	(S7A-*)-1
      1  1faa		       0b		      .byte.b	(S7A-*)-1
      0  1fab					      db	"%",0
      1  1fab		       25 00		      .byte.b	"%",0
      0  1fad					      CALL	EXPR
      0  1fad					      db	28
      1  1fad		       1c		      .byte.b	28
      0  1fae					      dw	EXPR
      1  1fae		       3d 21		      .word.w	EXPR
      0  1fb0					      SETR2	1
      0  1fb0					      db	94
      1  1fb0		       5e		      .byte.b	94
      0  1fb1					      db	1
      1  1fb1		       01		      .byte.b	1
      0  1fb2					      PRN
      0  1fb2					      db	3
      1  1fb2		       03		      .byte.b	3
      0  1fb3					      IJMP	S5
      0  1fb3					      db	29
      1  1fb3		       1d		      .byte.b	29
      0  1fb4					      dw	S5
      1  1fb4		       7e 1f		      .word.w	S5
    203  1fb6
    204  1fb6				   S7A
    205  1fb6
      0  1fb6					      CALL	EXPR
      0  1fb6					      db	28
      1  1fb6		       1c		      .byte.b	28
      0  1fb7					      dw	EXPR
      1  1fb7		       3d 21		      .word.w	EXPR
      0  1fb9					      TST	S7B,"$"
      0  1fb9					      db	32
      1  1fb9		       20		      .byte.b	32
      0  1fba					      db	(S7B-*)-1
      1  1fba		       06		      .byte.b	(S7B-*)-1
      0  1fbb					      db	"$",0
      1  1fbb		       24 00		      .byte.b	"$",0
      0  1fbd					      PUTCHAR
      0  1fbd					      db	52
      1  1fbd		       34		      .byte.b	52
      0  1fbe					      IJMP	S5
      0  1fbe					      db	29
      1  1fbe		       1d		      .byte.b	29
      0  1fbf					      dw	S5
      1  1fbf		       7e 1f		      .word.w	S5
    210  1fc1
    211  1fc1				   S7B
      0  1fc1					      SETR2	0
      0  1fc1					      db	94
      1  1fc1		       5e		      .byte.b	94
      0  1fc2					      db	0
      1  1fc2		       00		      .byte.b	0
      0  1fc3					      PRN		;PRINT IT
      0  1fc3					      db	3
      1  1fc3		       03		      .byte.b	3
      0  1fc4					      IJMP	S5	;IS THERE MORE?
      0  1fc4					      db	29
      1  1fc4		       1d		      .byte.b	29
      0  1fc5					      dw	S5
      1  1fc5		       7e 1f		      .word.w	S5
    215  1fc7							;
    216  1fc7							;===========================================================
    217  1fc7							; PROCESS ALL THE TAST STATEMENTS
    218  1fc7							;
    219  1fc7				   S8
      0  1fc7					      TST	S8a1,"TASK"	; Any Task Command
      0  1fc7					      db	32
      1  1fc7		       20		      .byte.b	32
      0  1fc8					      db	(S8a1-*)-1
      1  1fc8		       4b		      .byte.b	(S8a1-*)-1
      0  1fc9					      db	"TASK",0
      1  1fc9		       54 41 53 4b*	      .byte.b	"TASK",0
    221  1fce							;==========================================================
    222  1fce							; End of TASK process
    223  1fce							;
      0  1fce					      TST	S8G,"E"
      0  1fce					      db	32
      1  1fce		       20		      .byte.b	32
      0  1fcf					      db	(S8G-*)-1
      1  1fcf		       1a		      .byte.b	(S8G-*)-1
      0  1fd0					      db	"E",0
      1  1fd0		       45 00		      .byte.b	"E",0
      0  1fd2					      TST	S8NoParm,"("
      0  1fd2					      db	32
      1  1fd2		       20		      .byte.b	32
      0  1fd3					      db	(S8NoParm-*)-1
      1  1fd3		       0e		      .byte.b	(S8NoParm-*)-1
      0  1fd4					      db	"(",0
      1  1fd4		       28 00		      .byte.b	"(",0
      0  1fd6					      CALL	EXPR
      0  1fd6					      db	28
      1  1fd6		       1c		      .byte.b	28
      0  1fd7					      dw	EXPR
      1  1fd7		       3d 21		      .word.w	EXPR
      0  1fd9					      TST	UNKNOWNLnk,")"
      0  1fd9					      db	32
      1  1fd9		       20		      .byte.b	32
      0  1fda					      db	(UNKNOWNLnk-*)-1
      1  1fda		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1fdb					      db	")",0
      1  1fdb		       29 00		      .byte.b	")",0
      0  1fdd					      ETASK
      0  1fdd					      db	62
      1  1fdd		       3e		      .byte.b	62
      0  1fde					      DONE
      0  1fde					      db	1
      1  1fde		       01		      .byte.b	1
      0  1fdf					      IJMP	STMT
      0  1fdf					      db	29
      1  1fdf		       1d		      .byte.b	29
      0  1fe0					      dw	STMT
      1  1fe0		       a0 1e		      .word.w	STMT
    231  1fe2				   S8NoParm
      0  1fe2					      LIT	0
      0  1fe2					      db	27
      1  1fe2		       1b		      .byte.b	27
      0  1fe3					      dw	0
      1  1fe3		       00 00		      .word.w	0
      0  1fe5					      ETASK
      0  1fe5					      db	62
      1  1fe5		       3e		      .byte.b	62
      0  1fe6					      DONE		; Must be last thing on a line
      0  1fe6					      db	1
      1  1fe6		       01		      .byte.b	1
      0  1fe7					      IJMP	STMT
      0  1fe7					      db	29
      1  1fe7		       1d		      .byte.b	29
      0  1fe8					      dw	STMT
      1  1fe8		       a0 1e		      .word.w	STMT
    236  1fea							;
    237  1fea							;===========================================================
    238  1fea							; The task gives up the rest of the cycles
    239  1fea				   S8G
      0  1fea					      TST	S8a,"N"	;Next task
      0  1fea					      db	32
      1  1fea		       20		      .byte.b	32
      0  1feb					      db	(S8a-*)-1
      1  1feb		       09		      .byte.b	(S8a-*)-1
      0  1fec					      db	"N",0
      1  1fec		       4e 00		      .byte.b	"N",0
      0  1fee					      NTASK
      0  1fee					      db	63
      1  1fee		       3f		      .byte.b	63
      0  1fef					      NXT	CO	;Next statement to execute
      0  1fef					      db	6
      1  1fef		       06		      .byte.b	6
      0  1ff0					      dw	CO
      1  1ff0		       98 1e		      .word.w	CO
      0  1ff2					      IJMP	STMT
      0  1ff2					      db	29
      1  1ff2		       1d		      .byte.b	29
      0  1ff3					      dw	STMT
      1  1ff3		       a0 1e		      .word.w	STMT
    244  1ff5							;
    245  1ff5							;===========================================================
    246  1ff5							; Waits for a task or list of tasks to complete
    247  1ff5				   S8a
      0  1ff5					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1ff5					      db	32
      1  1ff5		       20		      .byte.b	32
      0  1ff6					      db	(S8TASKNO-*)-1
      1  1ff6		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1ff7					      db	"W(",0
      1  1ff7		       57 28 00 	      .byte.b	"W(",0
    249  1ffa				   S8TSK
      0  1ffa					      Call	EXPR	;Gets the PID of task to wait for
      0  1ffa					      db	28
      1  1ffa		       1c		      .byte.b	28
      0  1ffb					      dw	EXPR
      1  1ffb		       3d 21		      .word.w	EXPR
    251  1ffd				   S8LOOP
      0  1ffd					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1ffd					      db	76
      1  1ffd		       4c		      .byte.b	76
      0  1ffe					      db	(S8LOOP-*)-1
      1  1ffe		       fe		      .byte.b	(S8LOOP-*)-1
      0  1fff					      TST	S8aa,COMMA	;Checks for more tasks
      0  1fff					      db	32
      1  1fff		       20		      .byte.b	32
      0  2000					      db	(S8aa-*)-1
      1  2000		       05		      .byte.b	(S8aa-*)-1
      0  2001					      db	COMMA,0
      1  2001		       2c 00		      .byte.b	COMMA,0
      0  2003					      IJMP	S8TSK	;Go for the next task number
      0  2003					      db	29
      1  2003		       1d		      .byte.b	29
      0  2004					      dw	S8TSK
      1  2004		       fa 1f		      .word.w	S8TSK
    255  2006				   S8aa
      0  2006					      TST	S8TASKNO,")"	;end of list
      0  2006					      db	32
      1  2006		       20		      .byte.b	32
      0  2007					      db	(S8TASKNO-*)-1
      1  2007		       09		      .byte.b	(S8TASKNO-*)-1
      0  2008					      db	")",0
      1  2008		       29 00		      .byte.b	")",0
      0  200a					      DONE
      0  200a					      db	1
      1  200a		       01		      .byte.b	1
      0  200b					      NXT	CO
      0  200b					      db	6
      1  200b		       06		      .byte.b	6
      0  200c					      dw	CO
      1  200c		       98 1e		      .word.w	CO
      0  200e					      IJMP	STMT	;Next Statement
      0  200e					      db	29
      1  200e		       1d		      .byte.b	29
      0  200f					      dw	STMT
      1  200f		       a0 1e		      .word.w	STMT
    260  2011				   S8TASKNO
    261  2011
    262  2011				   UNKNOWNLnk
      0  2011					      iJMP	UNKNOWN
      0  2011					      db	29
      1  2011		       1d		      .byte.b	29
      0  2012					      dw	UNKNOWN
      1  2012		       39 21		      .word.w	UNKNOWN
    264  2014
    265  2014							;
    266  2014							;===========================================================
    267  2014							; Update a memory location with a value
    268  2014							;  Use @[offset] to write a word value to memory
    269  2014							;
    270  2014				   S8a1
      0  2014					      TST	S8b,"POKE("	; Poke a value into memory
      0  2014					      db	32
      1  2014		       20		      .byte.b	32
      0  2015					      db	(S8b-*)-1
      1  2015		       1c		      .byte.b	(S8b-*)-1
      0  2016					      db	"POKE(",0
      1  2016		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  201c					      CALL	EXPR	; Get address to write to
      0  201c					      db	28
      1  201c		       1c		      .byte.b	28
      0  201d					      dw	EXPR
      1  201d		       3d 21		      .word.w	EXPR
      0  201f					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  201f					      db	32
      1  201f		       20		      .byte.b	32
      0  2020					      db	(UNKNOWNV-*)-1
      1  2020		       64		      .byte.b	(UNKNOWNV-*)-1
      0  2021					      db	COMMA,0
      1  2021		       2c 00		      .byte.b	COMMA,0
      0  2023					      CALL	EXPR	; Get the value to poke
      0  2023					      db	28
      1  2023		       1c		      .byte.b	28
      0  2024					      dw	EXPR
      1  2024		       3d 21		      .word.w	EXPR
      0  2026					      TST	UNKNOWNV,")"	; closing bracket
      0  2026					      db	32
      1  2026		       20		      .byte.b	32
      0  2027					      db	(UNKNOWNV-*)-1
      1  2027		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  2028					      db	")",0
      1  2028		       29 00		      .byte.b	")",0
      0  202a					      POKEMEM
      0  202a					      db	47
      1  202a		       2f		      .byte.b	47
      0  202b					      DONE
      0  202b					      db	1
      1  202b		       01		      .byte.b	1
      0  202c					      NXT	CO	;AND SEQUENCE TO NEXT
      0  202c					      db	6
      1  202c		       06		      .byte.b	6
      0  202d					      dw	CO
      1  202d		       98 1e		      .word.w	CO
      0  202f					      IJMP	STMT
      0  202f					      db	29
      1  202f		       1d		      .byte.b	29
      0  2030					      dw	STMT
      1  2030		       a0 1e		      .word.w	STMT
    280  2032							;================================================================
    281  2032							; Write a single byte to the output device
    282  2032							;
    283  2032				   S8b
      0  2032					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  2032					      db	32
      1  2032		       20		      .byte.b	32
      0  2033					      db	(S8c-*)-1
      1  2033		       11		      .byte.b	(S8c-*)-1
      0  2034					      db	"PUTCH",0
      1  2034		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  203a					      CALL	EXPR
      0  203a					      db	28
      1  203a		       1c		      .byte.b	28
      0  203b					      dw	EXPR
      1  203b		       3d 21		      .word.w	EXPR
      0  203d					      PUTCHAR
      0  203d					      db	52
      1  203d		       34		      .byte.b	52
      0  203e					      DONE
      0  203e					      db	1
      1  203e		       01		      .byte.b	1
      0  203f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  203f					      db	6
      1  203f		       06		      .byte.b	6
      0  2040					      dw	CO
      1  2040		       98 1e		      .word.w	CO
      0  2042					      IJMP	STMT
      0  2042					      db	29
      1  2042		       1d		      .byte.b	29
      0  2043					      dw	STMT
      1  2043		       a0 1e		      .word.w	STMT
    290  2045							;================================================================
    291  2045							; Clear the screen lines
    292  2045							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    293  2045							;
    294  2045				   S8c
      0  2045					      TST	S9,"CLS"	;Clear the screen
      0  2045					      db	32
      1  2045		       20		      .byte.b	32
      0  2046					      db	(S9-*)-1
      1  2046		       0b		      .byte.b	(S9-*)-1
      0  2047					      db	"CLS",0
      1  2047		       43 4c 53 00	      .byte.b	"CLS",0
      0  204b					      CLEARSCREEN
      0  204b					      db	46
      1  204b		       2e		      .byte.b	46
      0  204c					      NXT	CO	;AND SEQUENCE TO NEXT
      0  204c					      db	6
      1  204c		       06		      .byte.b	6
      0  204d					      dw	CO
      1  204d		       98 1e		      .word.w	CO
      0  204f					      IJMP	STMT
      0  204f					      db	29
      1  204f		       1d		      .byte.b	29
      0  2050					      dw	STMT
      1  2050		       a0 1e		      .word.w	STMT
    299  2052							;==================================================================
    300  2052							; Get input from the terminal
    301  2052							;   Reads from the currently active input device
    302  2052							;
    303  2052				   S9
      0  2052					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  2052					      db	32
      1  2052		       20		      .byte.b	32
      0  2053					      db	(S13-*)-1
      1  2053		       2a		      .byte.b	(S13-*)-1
      0  2054					      db	"INPUT",0
      1  2054		       49 4e 50 55*	      .byte.b	"INPUT",0
    305  205a				   S10
      0  205a					      TSTSTR	S10A	;If there is a string print the prompt
      0  205a					      db	55
      1  205a		       37		      .byte.b	55
      0  205b					      db	(S10A-*)-1
      1  205b		       05		      .byte.b	(S10A-*)-1
      0  205c					      PRS
      0  205c					      db	2
      1  205c		       02		      .byte.b	2
      0  205d					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  205d					      db	32
      1  205d		       20		      .byte.b	32
      0  205e					      db	(S10Z-*)-1
      1  205e		       15		      .byte.b	(S10Z-*)-1
      0  205f					      db	SEMICOLON,0
      1  205f		       3b 00		      .byte.b	SEMICOLON,0
    309  2061				   S10A
      0  2061					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  2061					      db	33
      1  2061		       21		      .byte.b	33
      0  2062					      db	(UNKNOWN-*)-1
      1  2062		       d6		      .byte.b	(UNKNOWN-*)-1
      0  2063					      TST	S10A1,DOLLAR
      0  2063					      db	32
      1  2063		       20		      .byte.b	32
      0  2064					      db	(S10A1-*)-1
      1  2064		       06		      .byte.b	(S10A1-*)-1
      0  2065					      db	DOLLAR,0
      1  2065		       24 00		      .byte.b	DOLLAR,0
      0  2067					      INSTR		;Move character From tty to AESTK
      0  2067					      db	59
      1  2067		       3b		      .byte.b	59
      0  2068					      IJMP	S10A2
      0  2068					      db	29
      1  2068		       1d		      .byte.b	29
      0  2069					      dw	S10A2
      1  2069		       6c 20		      .word.w	S10A2
    314  206b				   S10A1
      0  206b					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  206b					      db	11
      1  206b		       0b		      .byte.b	11
    316  206c				   S10A2
      0  206c					      STORE		;STORE IT
      0  206c					      db	19
      1  206c		       13		      .byte.b	19
      0  206d					      TST	S11,COMMA	;IS THERE MORE?
      0  206d					      db	32
      1  206d		       20		      .byte.b	32
      0  206e					      db	(S11-*)-1
      1  206e		       08		      .byte.b	(S11-*)-1
      0  206f					      db	COMMA,0
      1  206f		       2c 00		      .byte.b	COMMA,0
      0  2071					      IJMP	S10	;YES
      0  2071					      db	29
      1  2071		       1d		      .byte.b	29
      0  2072					      dw	S10
      1  2072		       5a 20		      .word.w	S10
    320  2074				   S10Z
      0  2074					      iJMP	UNKNOWN
      0  2074					      db	29
      1  2074		       1d		      .byte.b	29
      0  2075					      dw	UNKNOWN
      1  2075		       39 21		      .word.w	UNKNOWN
    322  2077				   S11
      0  2077					      DONE		;MUST BE CR
      0  2077					      db	1
      1  2077		       01		      .byte.b	1
      0  2078					      NXT	CO	;SEQUENCE TO NEXT
      0  2078					      db	6
      1  2078		       06		      .byte.b	6
      0  2079					      dw	CO
      1  2079		       98 1e		      .word.w	CO
      0  207b					      IJMP	STMT
      0  207b					      db	29
      1  207b		       1d		      .byte.b	29
      0  207c					      dw	STMT
      1  207c		       a0 1e		      .word.w	STMT
    326  207e							;=====================================================================
    327  207e							; End of program, return to command line process
    328  207e							; Main Task may also use taske or return to stopped
    329  207e							;
    330  207e				   S13
      0  207e					      TST	S14,"END"
      0  207e					      db	32
      1  207e		       20		      .byte.b	32
      0  207f					      db	(S14-*)-1
      1  207f		       08		      .byte.b	(S14-*)-1
      0  2080					      db	"END",0
      1  2080		       45 4e 44 00	      .byte.b	"END",0
      0  2084					      FIN
      0  2084					      db	12
      1  2084		       0c		      .byte.b	12
    333  2085
    334  2085				   UNKNOWNV
      0  2085					      IJMP	UNKNOWN
      0  2085					      db	29
      1  2085		       1d		      .byte.b	29
      0  2086					      dw	UNKNOWN
      1  2086		       39 21		      .word.w	UNKNOWN
    336  2088							;====================================================================
    337  2088							; IRQ <IRQ-HANDLER-Line expression>
    338  2088							;   Specify a line number subroutine to call when an interupt is processed
    339  2088							;   These subroutines must use iret to return.
    340  2088							;
    341  2088				   S14
      0  2088					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  2088					      db	32
      1  2088		       20		      .byte.b	32
      0  2089					      db	(S14Z-*)-1
      1  2089		       0f		      .byte.b	(S14Z-*)-1
      0  208a					      db	"IRQ",0
      1  208a		       49 52 51 00	      .byte.b	"IRQ",0
      0  208e					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  208e					      db	28
      1  208e		       1c		      .byte.b	28
      0  208f					      dw	EXPR
      1  208f		       3d 21		      .word.w	EXPR
      0  2091					      DONE		;must be CR
      0  2091					      db	1
      1  2091		       01		      .byte.b	1
      0  2092					      SETIRQ		;Set the line number now
      0  2092					      db	56
      1  2092		       38		      .byte.b	56
      0  2093					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  2093					      db	6
      1  2093		       06		      .byte.b	6
      0  2094					      dw	CO
      1  2094		       98 1e		      .word.w	CO
      0  2096					      IJMP	STMT
      0  2096					      db	29
      1  2096		       1d		      .byte.b	29
      0  2097					      dw	STMT
      1  2097		       a0 1e		      .word.w	STMT
    348  2099
    349  2099							;=========================================================================
    350  2099							; KILL PID-expression	 kill a running task
    351  2099							;  ignored of task has already stopped
    352  2099							;
    353  2099				   S14Z
      0  2099					      TST	S14S1,"KILL"	; Kill A running Task
      0  2099					      db	32
      1  2099		       20		      .byte.b	32
      0  209a					      db	(S14S1-*)-1
      1  209a		       10		      .byte.b	(S14S1-*)-1
      0  209b					      db	"KILL",0
      1  209b		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  20a0					      CALL	EXPR
      0  20a0					      db	28
      1  20a0		       1c		      .byte.b	28
      0  20a1					      dw	EXPR
      1  20a1		       3d 21		      .word.w	EXPR
      0  20a3					      DONE
      0  20a3					      db	1
      1  20a3		       01		      .byte.b	1
      0  20a4					      TASKKILL
      0  20a4					      db	65
      1  20a4		       41		      .byte.b	65
      0  20a5					      NXT	CO
      0  20a5					      db	6
      1  20a5		       06		      .byte.b	6
      0  20a6					      dw	CO
      1  20a6		       98 1e		      .word.w	CO
      0  20a8					      IJMP	STMT
      0  20a8					      db	29
      1  20a8		       1d		      .byte.b	29
      0  20a9					      dw	STMT
      1  20a9		       a0 1e		      .word.w	STMT
    360  20ab
    361  20ab							;============================================================================
    362  20ab							; List all program lines
    363  20ab							;
    364  20ab				   S14S1
      0  20ab					      TST	S15,"LIST"	;LIST COMMAND
      0  20ab					      db	32
      1  20ab		       20		      .byte.b	32
      0  20ac					      db	(S15-*)-1
      1  20ac		       0a		      .byte.b	(S15-*)-1
      0  20ad					      db	"LIST",0
      1  20ad		       4c 49 53 54*	      .byte.b	"LIST",0
      0  20b2					      DONE
      0  20b2					      db	1
      1  20b2		       01		      .byte.b	1
      0  20b3					      LST
      0  20b3					      db	21
      1  20b3		       15		      .byte.b	21
      0  20b4					      IJMP	CO
      0  20b4					      db	29
      1  20b4		       1d		      .byte.b	29
      0  20b5					      dw	CO
      1  20b5		       98 1e		      .word.w	CO
    369  20b7							;=======================================================================
    370  20b7							;RUN begin to executed the program in memory
    371  20b7							;
    372  20b7				   S15
      0  20b7					      TST	S16,"RUN"	;RUN COMMAND
      0  20b7					      db	32
      1  20b7		       20		      .byte.b	32
      0  20b8					      db	(S16-*)-1
      1  20b8		       0d		      .byte.b	(S16-*)-1
      0  20b9					      db	"RUN",0
      1  20b9		       52 55 4e 00	      .byte.b	"RUN",0
      0  20bd					      DONE
      0  20bd					      db	1
      1  20bd		       01		      .byte.b	1
      0  20be					      VINIT		;clear variables
      0  20be					      db	30
      1  20be		       1e		      .byte.b	30
      0  20bf					      LIT	1	;GOTO line 1
      0  20bf					      db	27
      1  20bf		       1b		      .byte.b	27
      0  20c0					      dw	1
      1  20c0		       01 00		      .word.w	1
      0  20c2					      XFER		;Bob's addition
      0  20c2					      db	7
      1  20c2		       07		      .byte.b	7
    378  20c3							; EXIT
      0  20c3					      IJMP	STMT	;and run!
      0  20c3					      db	29
      1  20c3		       1d		      .byte.b	29
      0  20c4					      dw	STMT
      1  20c4		       a0 1e		      .word.w	STMT
    380  20c6							;=========================================================================
    381  20c6							;Clear the program memory, delete all proram lines
    382  20c6							;
    383  20c6				   S16
      0  20c6					      TST	S16A,"NEW"	;clear program
      0  20c6					      db	32
      1  20c6		       20		      .byte.b	32
      0  20c7					      db	(S16A-*)-1
      1  20c7		       08		      .byte.b	(S16A-*)-1
      0  20c8					      db	"NEW",0
      1  20c8		       4e 45 57 00	      .byte.b	"NEW",0
      0  20cc					      DONE
      0  20cc					      db	1
      1  20cc		       01		      .byte.b	1
      0  20cd					      IJMP	START
      0  20cd					      db	29
      1  20cd		       1d		      .byte.b	29
      0  20ce					      dw	START
      1  20ce		       92 1e		      .word.w	START
    387  20d0
    388  20d0							;========================================================================
    389  20d0							; Slice(slice legth expression)
    390  20d0							;   set the length of time between task switches
    391  20d0							;
    392  20d0				   S16A
      0  20d0					      TST	S16Trace,"SLICE"
      0  20d0					      db	32
      1  20d0		       20		      .byte.b	32
      0  20d1					      db	(S16Trace-*)-1
      1  20d1		       11		      .byte.b	(S16Trace-*)-1
      0  20d2					      db	"SLICE",0
      1  20d2		       53 4c 49 43*	      .byte.b	"SLICE",0
      0  20d8					      CALL	EXPR
      0  20d8					      db	28
      1  20d8		       1c		      .byte.b	28
      0  20d9					      dw	EXPR
      1  20d9		       3d 21		      .word.w	EXPR
      0  20db					      SLICE
      0  20db					      db	100
      1  20db		       64		      .byte.b	100
      0  20dc					      DONE
      0  20dc					      db	1
      1  20dc		       01		      .byte.b	1
      0  20dd					      NXT	CO
      0  20dd					      db	6
      1  20dd		       06		      .byte.b	6
      0  20de					      dw	CO
      1  20de		       98 1e		      .word.w	CO
      0  20e0					      IJMP	STMT
      0  20e0					      db	29
      1  20e0		       1d		      .byte.b	29
      0  20e1					      dw	STMT
      1  20e1		       a0 1e		      .word.w	STMT
    399  20e3							;==========================================================================
    400  20e3							; Turn off and on the thrace functions
    401  20e3							; a debug terminal needs to be available
    402  20e3							; Trace( Trace flag expression)
    403  20e3							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    404  20e3							;	for individual lines of basic code. These can be combined
    405  20e3				   S16Trace
      0  20e3					      TST	S17A,"TRACE("	;Are we going to trace
      0  20e3					      db	32
      1  20e3		       20		      .byte.b	32
      0  20e4					      db	(S17A-*)-1
      1  20e4		       16		      .byte.b	(S17A-*)-1
      0  20e5					      db	"TRACE(",0
      1  20e5		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  20ec					      CALL	EXPR
      0  20ec					      db	28
      1  20ec		       1c		      .byte.b	28
      0  20ed					      dw	EXPR
      1  20ed		       3d 21		      .word.w	EXPR
      0  20ef					      TST	UNKNOWN,")"
      0  20ef					      db	32
      1  20ef		       20		      .byte.b	32
      0  20f0					      db	(UNKNOWN-*)-1
      1  20f0		       48		      .byte.b	(UNKNOWN-*)-1
      0  20f1					      db	")",0
      1  20f1		       29 00		      .byte.b	")",0
      0  20f3					      TRACEPROGRAM
      0  20f3					      db	78
      1  20f3		       4e		      .byte.b	78
      0  20f4					      DONE
      0  20f4					      db	1
      1  20f4		       01		      .byte.b	1
      0  20f5					      NXT	CO
      0  20f5					      db	6
      1  20f5		       06		      .byte.b	6
      0  20f6					      dw	CO
      1  20f6		       98 1e		      .word.w	CO
      0  20f8					      IJMP	STMT
      0  20f8					      db	29
      1  20f8		       1d		      .byte.b	29
      0  20f9					      dw	STMT
      1  20f9		       a0 1e		      .word.w	STMT
    413  20fb							;=====================================================================
    414  20fb							; Exit basic to machine monitor
    415  20fb							;
    416  20fb				   S17A
      0  20fb					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  20fb					      db	32
      1  20fb		       20		      .byte.b	32
      0  20fc					      db	(S17B-*)-1
      1  20fc		       06		      .byte.b	(S17B-*)-1
      0  20fd					      db	"EXIT",0
      1  20fd		       45 58 49 54*	      .byte.b	"EXIT",0
      0  2102					      EXIT
      0  2102					      db	26
      1  2102		       1a		      .byte.b	26
    419  2103
    420  2103							;=======================================================================
    421  2103							; Commands related to saving/restoring programs
    422  2103							; to/from mass storage.
    423  2103							;
    424  2103				   S17B
    425  2103					      if	(XKIM || CTMON65) && DISK_ACCESS
    426  2103
      0  2103					      TST	S17C,"SAVE"
      0  2103					      db	32
      1  2103		       20		      .byte.b	32
      0  2104					      db	(S17C-*)-1
      1  2104		       0b		      .byte.b	(S17C-*)-1
      0  2105					      db	"SAVE",0
      1  2105		       53 41 56 45*	      .byte.b	"SAVE",0
      0  210a					      OPENWRITE
      0  210a					      db	40
      1  210a		       28		      .byte.b	40
      0  210b					      DLIST
      0  210b					      db	43
      1  210b		       2b		      .byte.b	43
      0  210c					      DCLOSE
      0  210c					      db	41
      1  210c		       29		      .byte.b	41
      0  210d					      IJMP	CO
      0  210d					      db	29
      1  210d		       1d		      .byte.b	29
      0  210e					      dw	CO
      1  210e		       98 1e		      .word.w	CO
    432  2110
    433  2110				   S17C
      0  2110					      TST	S18,"LOAD"
      0  2110					      db	32
      1  2110		       20		      .byte.b	32
      0  2111					      db	(S18-*)-1
      1  2111		       11		      .byte.b	(S18-*)-1
      0  2112					      db	"LOAD",0
      1  2112		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  2117					      OPENREAD
      0  2117					      db	39
      1  2117		       27		      .byte.b	39
    436  2118				   S17CLP
      0  2118					      DGETLINE		;get line from file
      0  2118					      db	42
      1  2118		       2a		      .byte.b	42
      0  2119					      TSTL	S17EOL	;no line num means EOL
      0  2119					      db	34
      1  2119		       22		      .byte.b	34
      0  211a					      db	(S17EOL-*)-1
      1  211a		       04		      .byte.b	(S17EOL-*)-1
      0  211b					      INSERT		;put it into the program
      0  211b					      db	24
      1  211b		       18		      .byte.b	24
      0  211c					      IJMP	S17CLP	;keep going
      0  211c					      db	29
      1  211c		       1d		      .byte.b	29
      0  211d					      dw	S17CLP
      1  211d		       18 21		      .word.w	S17CLP
    441  211f				   S17EOL
      0  211f					      DCLOSE		;close disk file
      0  211f					      db	41
      1  211f		       29		      .byte.b	41
      0  2120					      IJMP	CO	;back to start
      0  2120					      db	29
      1  2120		       1d		      .byte.b	29
      0  2121					      dw	CO
      1  2121		       98 1e		      .word.w	CO
    444  2123
    445  2123				   S18
      0  2123					      TST	S19,"DIR"
      0  2123					      db	32
      1  2123		       20		      .byte.b	32
      0  2124					      db	(S19-*)-1
      1  2124		       08		      .byte.b	(S19-*)-1
      0  2125					      db	"DIR",0
      1  2125		       44 49 52 00	      .byte.b	"DIR",0
      0  2129					      DDIR		;Display the directory content
      0  2129					      db	44
      1  2129		       2c		      .byte.b	44
      0  212a					      IJMP	CO
      0  212a					      db	29
      1  212a		       1d		      .byte.b	29
      0  212b					      dw	CO
      1  212b		       98 1e		      .word.w	CO
    449  212d
      0  212d				   S19	      TST	UNKNOWN,"ERASE"
      0  212d					      db	32
      1  212d		       20		      .byte.b	32
      0  212e					      db	(UNKNOWN-*)-1
      1  212e		       0a		      .byte.b	(UNKNOWN-*)-1
      0  212f					      db	"ERASE",0
      1  212f		       45 52 41 53*	      .byte.b	"ERASE",0
      0  2135					      RMFILE		;Erase the file from the disk
      0  2135					      db	45
      1  2135		       2d		      .byte.b	45
      0  2136					      IJMP	CO
      0  2136					      db	29
      1  2136		       1d		      .byte.b	29
      0  2137					      dw	CO
      1  2137		       98 1e		      .word.w	CO
    453  2139
    454  2139					      endif
    455  2139
    456  2139							;
    457  2139							; Else, unknown command.
    458  2139							;
    459  2139				   UNKNOWN
      0  2139					      ENDIO
      0  2139					      db	71
      1  2139		       47		      .byte.b	71
      0  213a					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  213a					      db	13
      1  213a		       0d		      .byte.b	13
      0  213b					      dw	ERR_SYNTAX
      1  213b		       05 00		      .word.w	ERR_SYNTAX
    462  213d
    463  213d							;=======================================================
    464  213d							; Process Expresions, precidence is represented by the
    465  213d							; various call levels
    466  213d							;
    467  213d				   EXPR
      0  213d					      TST	EXPRLOGS,"NOT"
      0  213d					      db	32
      1  213d		       20		      .byte.b	32
      0  213e					      db	(EXPRLOGS-*)-1
      1  213e		       09		      .byte.b	(EXPRLOGS-*)-1
      0  213f					      db	"NOT",0
      1  213f		       4e 4f 54 00	      .byte.b	"NOT",0
      0  2143					      Call	EXPR
      0  2143					      db	28
      1  2143		       1c		      .byte.b	28
      0  2144					      dw	EXPR
      1  2144		       3d 21		      .word.w	EXPR
      0  2146					      LOGNOT
      0  2146					      db	72
      1  2146		       48		      .byte.b	72
      0  2147					      RTN
      0  2147					      db	25
      1  2147		       19		      .byte.b	25
    472  2148
    473  2148							;=========================================================
    474  2148							;Look for logical operators
    475  2148				   EXPRLOGS
      0  2148					      Call	EXPRCMP
      0  2148					      db	28
      1  2148		       1c		      .byte.b	28
      0  2149					      dw	EXPRCMP
      1  2149		       6c 21		      .word.w	EXPRCMP
      0  214b					      TST	iLOG1,"AND"
      0  214b					      db	32
      1  214b		       20		      .byte.b	32
      0  214c					      db	(iLOG1-*)-1
      1  214c		       09		      .byte.b	(iLOG1-*)-1
      0  214d					      db	"AND",0
      1  214d		       41 4e 44 00	      .byte.b	"AND",0
      0  2151					      Call	EXPR
      0  2151					      db	28
      1  2151		       1c		      .byte.b	28
      0  2152					      dw	EXPR
      1  2152		       3d 21		      .word.w	EXPR
      0  2154					      LOGAND
      0  2154					      db	74
      1  2154		       4a		      .byte.b	74
      0  2155					      RTN
      0  2155					      db	25
      1  2155		       19		      .byte.b	25
    481  2156				   iLOG1
      0  2156					      TST	iLOG2,"OR"
      0  2156					      db	32
      1  2156		       20		      .byte.b	32
      0  2157					      db	(iLOG2-*)-1
      1  2157		       08		      .byte.b	(iLOG2-*)-1
      0  2158					      db	"OR",0
      1  2158		       4f 52 00 	      .byte.b	"OR",0
      0  215b					      Call	EXPR
      0  215b					      db	28
      1  215b		       1c		      .byte.b	28
      0  215c					      dw	EXPR
      1  215c		       3d 21		      .word.w	EXPR
      0  215e					      LOGOR
      0  215e					      db	73
      1  215e		       49		      .byte.b	73
      0  215f					      RTN
      0  215f					      db	25
      1  215f		       19		      .byte.b	25
    486  2160				   iLOG2
      0  2160					      TST	iLOG3,"XOR"
      0  2160					      db	32
      1  2160		       20		      .byte.b	32
      0  2161					      db	(iLOG3-*)-1
      1  2161		       09		      .byte.b	(iLOG3-*)-1
      0  2162					      db	"XOR",0
      1  2162		       58 4f 52 00	      .byte.b	"XOR",0
      0  2166					      Call	EXPR
      0  2166					      db	28
      1  2166		       1c		      .byte.b	28
      0  2167					      dw	EXPR
      1  2167		       3d 21		      .word.w	EXPR
      0  2169					      LOGXOR
      0  2169					      db	75
      1  2169		       4b		      .byte.b	75
      0  216a					      RTN
      0  216a					      db	25
      1  216a		       19		      .byte.b	25
    491  216b				   iLOG3
      0  216b					      RTN
      0  216b					      db	25
      1  216b		       19		      .byte.b	25
    493  216c
    494  216c				   EXPRCMP
      0  216c					      Call	EXPR2	; get the first expression
      0  216c					      db	28
      1  216c		       1c		      .byte.b	28
      0  216d					      dw	EXPR2
      1  216d		       b8 21		      .word.w	EXPR2
      0  216f					      TST	iR0,"="
      0  216f					      db	32
      1  216f		       20		      .byte.b	32
      0  2170					      db	(iR0-*)-1
      1  2170		       08		      .byte.b	(iR0-*)-1
      0  2171					      db	"=",0
      1  2171		       3d 00		      .byte.b	"=",0
      0  2173					      LIT	2	;=
      0  2173					      db	27
      1  2173		       1b		      .byte.b	27
      0  2174					      dw	2
      1  2174		       02 00		      .word.w	2
      0  2176					      IJMP	iRFound
      0  2176					      db	29
      1  2176		       1d		      .byte.b	29
      0  2177					      dw	iRFound
      1  2177		       b2 21		      .word.w	iRFound
    499  2179				   iR0
      0  2179					      TST	iR4,"<"
      0  2179					      db	32
      1  2179		       20		      .byte.b	32
      0  217a					      db	(iR4-*)-1
      1  217a		       1c		      .byte.b	(iR4-*)-1
      0  217b					      db	"<",0
      1  217b		       3c 00		      .byte.b	"<",0
      0  217d					      TST	iR1,"="
      0  217d					      db	32
      1  217d		       20		      .byte.b	32
      0  217e					      db	(iR1-*)-1
      1  217e		       08		      .byte.b	(iR1-*)-1
      0  217f					      db	"=",0
      1  217f		       3d 00		      .byte.b	"=",0
      0  2181					      LIT	3	;<=
      0  2181					      db	27
      1  2181		       1b		      .byte.b	27
      0  2182					      dw	3
      1  2182		       03 00		      .word.w	3
      0  2184					      IJMP	iRFound
      0  2184					      db	29
      1  2184		       1d		      .byte.b	29
      0  2185					      dw	iRFound
      1  2185		       b2 21		      .word.w	iRFound
    504  2187				   iR1
      0  2187					      TST	iR3,">"
      0  2187					      db	32
      1  2187		       20		      .byte.b	32
      0  2188					      db	(iR3-*)-1
      1  2188		       08		      .byte.b	(iR3-*)-1
      0  2189					      db	">",0
      1  2189		       3e 00		      .byte.b	">",0
      0  218b					      LIT	5	;<>
      0  218b					      db	27
      1  218b		       1b		      .byte.b	27
      0  218c					      dw	5
      1  218c		       05 00		      .word.w	5
      0  218e					      IJMP	iRFound
      0  218e					      db	29
      1  218e		       1d		      .byte.b	29
      0  218f					      dw	iRFound
      1  218f		       b2 21		      .word.w	iRFound
    508  2191				   iR3
      0  2191					      LIT	1	;<
      0  2191					      db	27
      1  2191		       1b		      .byte.b	27
      0  2192					      dw	1
      1  2192		       01 00		      .word.w	1
      0  2194					      IJMP	iRFound
      0  2194					      db	29
      1  2194		       1d		      .byte.b	29
      0  2195					      dw	iRFound
      1  2195		       b2 21		      .word.w	iRFound
    511  2197				   iR4
      0  2197					      TST	iRDone,">"
      0  2197					      db	32
      1  2197		       20		      .byte.b	32
      0  2198					      db	(iRDone-*)-1
      1  2198		       1e		      .byte.b	(iRDone-*)-1
      0  2199					      db	">",0
      1  2199		       3e 00		      .byte.b	">",0
      0  219b					      TST	iR5,"="
      0  219b					      db	32
      1  219b		       20		      .byte.b	32
      0  219c					      db	(iR5-*)-1
      1  219c		       08		      .byte.b	(iR5-*)-1
      0  219d					      db	"=",0
      1  219d		       3d 00		      .byte.b	"=",0
      0  219f					      LIT	6	;>=
      0  219f					      db	27
      1  219f		       1b		      .byte.b	27
      0  21a0					      dw	6
      1  21a0		       06 00		      .word.w	6
      0  21a2					      IJMP	iRFound
      0  21a2					      db	29
      1  21a2		       1d		      .byte.b	29
      0  21a3					      dw	iRFound
      1  21a3		       b2 21		      .word.w	iRFound
    516  21a5				   iR5
      0  21a5					      TST	iR6,"<"
      0  21a5					      db	32
      1  21a5		       20		      .byte.b	32
      0  21a6					      db	(iR6-*)-1
      1  21a6		       08		      .byte.b	(iR6-*)-1
      0  21a7					      db	"<",0
      1  21a7		       3c 00		      .byte.b	"<",0
      0  21a9					      LIT	1
      0  21a9					      db	27
      1  21a9		       1b		      .byte.b	27
      0  21aa					      dw	1
      1  21aa		       01 00		      .word.w	1
      0  21ac					      IJMP	iRFound	;(This line originally omitted)
      0  21ac					      db	29
      1  21ac		       1d		      .byte.b	29
      0  21ad					      dw	iRFound
      1  21ad		       b2 21		      .word.w	iRFound
    520  21af				   iR6
      0  21af					      LIT	4	;>
      0  21af					      db	27
      1  21af		       1b		      .byte.b	27
      0  21b0					      dw	4
      1  21b0		       04 00		      .word.w	4
    522  21b2				   iRFound
      0  21b2					      Call	EXPR	; get the right side of the expression
      0  21b2					      db	28
      1  21b2		       1c		      .byte.b	28
      0  21b3					      dw	EXPR
      1  21b3		       3d 21		      .word.w	EXPR
      0  21b5					      CMPR		; Push the value of the true false onto the stack
      0  21b5					      db	10
      1  21b5		       0a		      .byte.b	10
      0  21b6					      RTN
      0  21b6					      db	25
      1  21b6		       19		      .byte.b	25
    526  21b7
    527  21b7				   iRDone
      0  21b7					      RTN
      0  21b7					      db	25
      1  21b7		       19		      .byte.b	25
    529  21b8
    530  21b8				   EXPR2
      0  21b8					      TST	E0,"-"	; Look for leading - to negate term
      0  21b8					      db	32
      1  21b8		       20		      .byte.b	32
      0  21b9					      db	(E0-*)-1
      1  21b9		       09		      .byte.b	(E0-*)-1
      0  21ba					      db	"-",0
      1  21ba		       2d 00		      .byte.b	"-",0
      0  21bc					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  21bc					      db	28
      1  21bc		       1c		      .byte.b	28
      0  21bd					      dw	TERM
      1  21bd		       e1 21		      .word.w	TERM
      0  21bf					      NEG		; Make value negated
      0  21bf					      db	16
      1  21bf		       10		      .byte.b	16
      0  21c0					      IJMP	E1	; We have Left term process operators next
      0  21c0					      db	29
      1  21c0		       1d		      .byte.b	29
      0  21c1					      dw	E1
      1  21c1		       ca 21		      .word.w	E1
    535  21c3				   E0
      0  21c3					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  21c3					      db	32
      1  21c3		       20		      .byte.b	32
      0  21c4					      db	(E1A-*)-1
      1  21c4		       02		      .byte.b	(E1A-*)-1
      0  21c5					      db	"+",0
      1  21c5		       2b 00		      .byte.b	"+",0
    537  21c7				   E1A
      0  21c7					      CALL	TERM	; Get the left term if it was not negated
      0  21c7					      db	28
      1  21c7		       1c		      .byte.b	28
      0  21c8					      dw	TERM
      1  21c8		       e1 21		      .word.w	TERM
    539  21ca				   E1
      0  21ca					      TST	E2,"+"	; Check if we are adding left term to something
      0  21ca					      db	32
      1  21ca		       20		      .byte.b	32
      0  21cb					      db	(E2-*)-1
      1  21cb		       09		      .byte.b	(E2-*)-1
      0  21cc					      db	"+",0
      1  21cc		       2b 00		      .byte.b	"+",0
      0  21ce					      CALL	TERM	; if adding then get the right side term
      0  21ce					      db	28
      1  21ce		       1c		      .byte.b	28
      0  21cf					      dw	TERM
      1  21cf		       e1 21		      .word.w	TERM
      0  21d1					      ADD		; Add it to left term
      0  21d1					      db	14
      1  21d1		       0e		      .byte.b	14
      0  21d2					      IJMP	E1	; look for next + or -
      0  21d2					      db	29
      1  21d2		       1d		      .byte.b	29
      0  21d3					      dw	E1
      1  21d3		       ca 21		      .word.w	E1
    544  21d5				   E2
      0  21d5					      TST	E3,"-"	; Check if we are subtractig something
      0  21d5					      db	32
      1  21d5		       20		      .byte.b	32
      0  21d6					      db	(E3-*)-1
      1  21d6		       09		      .byte.b	(E3-*)-1
      0  21d7					      db	"-",0
      1  21d7		       2d 00		      .byte.b	"-",0
      0  21d9					      CALL	TERM	; get right side to subtract Diffrence
      0  21d9					      db	28
      1  21d9		       1c		      .byte.b	28
      0  21da					      dw	TERM
      1  21da		       e1 21		      .word.w	TERM
      0  21dc					      SUB		; Subtract the value
      0  21dc					      db	15
      1  21dc		       0f		      .byte.b	15
      0  21dd					      IJMP	E1	; Look for next + or -
      0  21dd					      db	29
      1  21dd		       1d		      .byte.b	29
      0  21de					      dw	E1
      1  21de		       ca 21		      .word.w	E1
    549  21e0				   E3			; Finish processing the expression
      0  21e0					      RTN		; We are finished processing the Expression
      0  21e0					      db	25
      1  21e0		       19		      .byte.b	25
    551  21e1							;
    552  21e1							; Get one of the terms of an expression
    553  21e1							;
    554  21e1				   TERM
      0  21e1					      CALL	FACT	; Get a value
      0  21e1					      db	28
      1  21e1		       1c		      .byte.b	28
      0  21e2					      dw	FACT
      1  21e2		       09 22		      .word.w	FACT
    556  21e4				   T0			; Check for higher precidence operators
      0  21e4					      TST	T1,"*"	; Check for *
      0  21e4					      db	32
      1  21e4		       20		      .byte.b	32
      0  21e5					      db	(T1-*)-1
      1  21e5		       09		      .byte.b	(T1-*)-1
      0  21e6					      db	"*",0
      1  21e6		       2a 00		      .byte.b	"*",0
      0  21e8					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  21e8					      db	28
      1  21e8		       1c		      .byte.b	28
      0  21e9					      dw	FACT
      1  21e9		       09 22		      .word.w	FACT
      0  21eb					      MUL		; Multiply factors
      0  21eb					      db	17
      1  21eb		       11		      .byte.b	17
      0  21ec					      IJMP	T0	; Check for * or /
      0  21ec					      db	29
      1  21ec		       1d		      .byte.b	29
      0  21ed					      dw	T0
      1  21ed		       e4 21		      .word.w	T0
    561  21ef				   T1
      0  21ef					      TST	T2,"/"	; Check for a division
      0  21ef					      db	32
      1  21ef		       20		      .byte.b	32
      0  21f0					      db	(T2-*)-1
      1  21f0		       09		      .byte.b	(T2-*)-1
      0  21f1					      db	"/",0
      1  21f1		       2f 00		      .byte.b	"/",0
      0  21f3					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  21f3					      db	28
      1  21f3		       1c		      .byte.b	28
      0  21f4					      dw	FACT
      1  21f4		       09 22		      .word.w	FACT
      0  21f6					      DIV		; do division
      0  21f6					      db	18
      1  21f6		       12		      .byte.b	18
      0  21f7					      IJMP	T0	; check for more * or /
      0  21f7					      db	29
      1  21f7		       1d		      .byte.b	29
      0  21f8					      dw	T0
      1  21f8		       e4 21		      .word.w	T0
    566  21fa				   T2
      0  21fa					      TST	T3,"%"	; Check for a division
      0  21fa					      db	32
      1  21fa		       20		      .byte.b	32
      0  21fb					      db	(T3-*)-1
      1  21fb		       09		      .byte.b	(T3-*)-1
      0  21fc					      db	"%",0
      1  21fc		       25 00		      .byte.b	"%",0
      0  21fe					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  21fe					      db	28
      1  21fe		       1c		      .byte.b	28
      0  21ff					      dw	FACT
      1  21ff		       09 22		      .word.w	FACT
      0  2201					      MODULO		; do division for remainder
      0  2201					      db	60
      1  2201		       3c		      .byte.b	60
      0  2202					      IJMP	T0	; check for more * or / or %
      0  2202					      db	29
      1  2202		       1d		      .byte.b	29
      0  2203					      dw	T0
      1  2203		       e4 21		      .word.w	T0
    571  2205				   T3			; Finish processing the Term
      0  2205					      RTN
      0  2205					      db	25
      1  2205		       19		      .byte.b	25
    573  2206
    574  2206				   UNKNOWNVEC
      0  2206					      IJMP	UNKNOWN
      0  2206					      db	29
      1  2206		       1d		      .byte.b	29
      0  2207					      dw	UNKNOWN
      1  2207		       39 21		      .word.w	UNKNOWN
    576  2209
    577  2209							;=============================================================================================
    578  2209							; Factor an expression.  Always test for functions
    579  2209							; first or else they'll be confused for variables.
    580  2209							;
    581  2209				   FACT
      0  2209					      TST	F1AA,"TRUE"
      0  2209					      db	32
      1  2209		       20		      .byte.b	32
      0  220a					      db	(F1AA-*)-1
      1  220a		       09		      .byte.b	(F1AA-*)-1
      0  220b					      db	"TRUE",0
      1  220b		       54 52 55 45*	      .byte.b	"TRUE",0
      0  2210					      LIT	-1
      0  2210					      db	27
      1  2210		       1b		      .byte.b	27
      0  2211					      dw	-1
      1  2211		       ff ff		      .word.w	-1
      0  2213					      RTN
      0  2213					      db	25
      1  2213		       19		      .byte.b	25
    585  2214				   F1AA
      0  2214					      TST	F1AB,"FALSE"
      0  2214					      db	32
      1  2214		       20		      .byte.b	32
      0  2215					      db	(F1AB-*)-1
      1  2215		       0a		      .byte.b	(F1AB-*)-1
      0  2216					      db	"FALSE",0
      1  2216		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  221c					      LIT	0
      0  221c					      db	27
      1  221c		       1b		      .byte.b	27
      0  221d					      dw	0
      1  221d		       00 00		      .word.w	0
      0  221f					      RTN
      0  221f					      db	25
      1  221f		       19		      .byte.b	25
    589  2220							;==================================================================================
    590  2220							; Returns the amount of free SPACE
    591  2220							;
    592  2220				   F1AB
      0  2220					      TST	F1A,"FREE()"
      0  2220					      db	32
      1  2220		       20		      .byte.b	32
      0  2221					      db	(F1A-*)-1
      1  2221		       09		      .byte.b	(F1A-*)-1
      0  2222					      db	"FREE()",0
      1  2222		       46 52 45 45*	      .byte.b	"FREE()",0
      0  2229					      FREE
      0  2229					      db	36
      1  2229		       24		      .byte.b	36
      0  222a					      RTN
      0  222a					      db	25
      1  222a		       19		      .byte.b	25
    596  222b							;===================================================================================
    597  222b							; getch() read a character from the input device
    598  222b							;
    599  222b				   F1A
      0  222b					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  222b					      db	32
      1  222b		       20		      .byte.b	32
      0  222c					      db	(F1A2-*)-1
      1  222c		       0a		      .byte.b	(F1A2-*)-1
      0  222d					      db	"GETCH()",0
      1  222d		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  2235					      GETCHAR
      0  2235					      db	51
      1  2235		       33		      .byte.b	51
      0  2236					      RTN
      0  2236					      db	25
      1  2236		       19		      .byte.b	25
    603  2237							;====================================================================================
    604  2237							; peek(mem address) return the value of a byte in memory
    605  2237							; @[offset] return a word value from offset -- see tstv
    606  2237							;
    607  2237				   F1A2
      0  2237					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  2237					      db	32
      1  2237		       20		      .byte.b	32
      0  2238					      db	(F2AZ-*)-1
      1  2238		       0f		      .byte.b	(F2AZ-*)-1
      0  2239					      db	"PEEK(",0
      1  2239		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  223f					      CALL	EXPR	;Get the address to write to
      0  223f					      db	28
      1  223f		       1c		      .byte.b	28
      0  2240					      dw	EXPR
      1  2240		       3d 21		      .word.w	EXPR
      0  2242					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  2242					      db	32
      1  2242		       20		      .byte.b	32
      0  2243					      db	(UNKNOWNVEC-*)-1
      1  2243		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  2244					      db	")",0
      1  2244		       29 00		      .byte.b	")",0
      0  2246					      PEEKMEM
      0  2246					      db	48
      1  2246		       30		      .byte.b	48
      0  2247					      RTN
      0  2247					      db	25
      1  2247		       19		      .byte.b	25
    613  2248							;=======================================================================================
    614  2248							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    615  2248							;
    616  2248				   F2AZ
      0  2248					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  2248					      db	32
      1  2248		       20		      .byte.b	32
      0  2249					      db	(F2AZ1-*)-1
      1  2249		       22		      .byte.b	(F2AZ1-*)-1
      0  224a					      db	"TASK(",0
      1  224a		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  2250					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2250					      db	28
      1  2250		       1c		      .byte.b	28
      0  2251					      dw	EXPR
      1  2251		       3d 21		      .word.w	EXPR
      0  2253					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  2253					      db	61
      1  2253		       3d		      .byte.b	61
      0  2254					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  2254					      db	32
      1  2254		       20		      .byte.b	32
      0  2255					      db	(F2AZNoParms-*)-1
      1  2255		       10		      .byte.b	(F2AZNoParms-*)-1
      0  2256					      db	COMMA,0
      1  2256		       2c 00		      .byte.b	COMMA,0
      0  2258					      SAVEMATHSTACK		;Push The mathstack
      0  2258					      db	86
      1  2258		       56		      .byte.b	86
      0  2259					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  2259					      db	89
      1  2259		       59		      .byte.b	89
    623  225a				   F2AZLOOP
      0  225a					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  225a					      db	28
      1  225a		       1c		      .byte.b	28
      0  225b					      dw	EXPR
      1  225b		       3d 21		      .word.w	EXPR
      0  225d					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  225d					      db	32
      1  225d		       20		      .byte.b	32
      0  225e					      db	(F2AZEndParm-*)-1
      1  225e		       05		      .byte.b	(F2AZEndParm-*)-1
      0  225f					      db	COMMA,0
      1  225f		       2c 00		      .byte.b	COMMA,0
      0  2261					      IJMP	F2AZLOOP	;check for more
      0  2261					      db	29
      1  2261		       1d		      .byte.b	29
      0  2262					      dw	F2AZLOOP
      1  2262		       5a 22		      .word.w	F2AZLOOP
    627  2264				   F2AZEndParm
      0  2264					      RESTOREMATHSTACK		;Back to normal stack
      0  2264					      db	87
      1  2264		       57		      .byte.b	87
      0  2265					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  2265					      db	92
      1  2265		       5c		      .byte.b	92
    630  2266				   F2AZNoParms
      0  2266					      TST	UNKNOWNVEC,")"	;must be )
      0  2266					      db	32
      1  2266		       20		      .byte.b	32
      0  2267					      db	(UNKNOWNVEC-*)-1
      1  2267		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2268					      db	")",0
      1  2268		       29 00		      .byte.b	")",0
      0  226a					      TASKENABLE		;Enable the task to execute
      0  226a					      db	90
      1  226a		       5a		      .byte.b	90
      0  226b					      RTN		;Returns the Task number
      0  226b					      db	25
      1  226b		       19		      .byte.b	25
    634  226c							;=========================================================================================
    635  226c							; Check for IPC interproccess instructions
    636  226c							;   IPCS  - Send a message
    637  226c							;
    638  226c				   F2AZ1
      0  226c					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  226c					      db	32
      1  226c		       20		      .byte.b	32
      0  226d					      db	(F2A-*)-1
      1  226d		       3c		      .byte.b	(F2A-*)-1
      0  226e					      db	"IPC",0
      1  226e		       49 50 43 00	      .byte.b	"IPC",0
      0  2272					      TST	F2AZa,"S("	;IPCS - send a message
      0  2272					      db	32
      1  2272		       20		      .byte.b	32
      0  2273					      db	(F2AZa-*)-1
      1  2273		       13		      .byte.b	(F2AZa-*)-1
      0  2274					      db	"S(",0
      1  2274		       53 28 00 	      .byte.b	"S(",0
      0  2277					      CALL	EXPR	;Get the message value
      0  2277					      db	28
      1  2277		       1c		      .byte.b	28
      0  2278					      dw	EXPR
      1  2278		       3d 21		      .word.w	EXPR
      0  227a					      TST	UNKNOWNVEC,COMMA
      0  227a					      db	32
      1  227a		       20		      .byte.b	32
      0  227b					      db	(UNKNOWNVEC-*)-1
      1  227b		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  227c					      db	COMMA,0
      1  227c		       2c 00		      .byte.b	COMMA,0
      0  227e					      CALL	EXPR	;Get pid of task to send to
      0  227e					      db	28
      1  227e		       1c		      .byte.b	28
      0  227f					      dw	EXPR
      1  227f		       3d 21		      .word.w	EXPR
      0  2281					      TST	UNKNOWNVEC,")"
      0  2281					      db	32
      1  2281		       20		      .byte.b	32
      0  2282					      db	(UNKNOWNVEC-*)-1
      1  2282		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  2283					      db	")",0
      1  2283		       29 00		      .byte.b	")",0
      0  2285					      IPCSEND		;Send msg and clear pid msg pending
      0  2285					      db	80
      1  2285		       50		      .byte.b	80
      0  2286					      RTN
      0  2286					      db	25
      1  2286		       19		      .byte.b	25
    647  2287							;================================================================================
    648  2287							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    649  2287							;
    650  2287				   F2AZa
      0  2287					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  2287					      db	32
      1  2287		       20		      .byte.b	32
      0  2288					      db	(F2AZb-*)-1
      1  2288		       16		      .byte.b	(F2AZb-*)-1
      0  2289					      db	"R(",0
      1  2289		       52 28 00 	      .byte.b	"R(",0
      0  228c					      TST	F2AZa1,")"
      0  228c					      db	32
      1  228c		       20		      .byte.b	32
      0  228d					      db	(F2AZa1-*)-1
      1  228d		       08		      .byte.b	(F2AZa1-*)-1
      0  228e					      db	")",0
      1  228e		       29 00		      .byte.b	")",0
      0  2290					      LIT	0	;We dont want the pid returned to us
      0  2290					      db	27
      1  2290		       1b		      .byte.b	27
      0  2291					      dw	0
      1  2291		       00 00		      .word.w	0
      0  2293					      IPCIO		;Set the io bit and suspend the task till message
      0  2293					      db	83
      1  2293		       53		      .byte.b	83
      0  2294					      IPCRECEIVE		;Get the message
      0  2294					      db	81
      1  2294		       51		      .byte.b	81
      0  2295					      RTN
      0  2295					      db	25
      1  2295		       19		      .byte.b	25
    657  2296				   F2AZa1
      0  2296					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  2296					      db	33
      1  2296		       21		      .byte.b	33
      0  2297					      db	(UNKNOWNVEC-*)-1
      1  2297		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2298					      TST	UNKNOWNVEC,")"
      0  2298					      db	32
      1  2298		       20		      .byte.b	32
      0  2299					      db	(UNKNOWNVEC-*)-1
      1  2299		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  229a					      db	")",0
      1  229a		       29 00		      .byte.b	")",0
      0  229c					      IPCIO		;Set the io bit and exit task till message
      0  229c					      db	83
      1  229c		       53		      .byte.b	83
      0  229d					      IPCRECEIVE		;Get the message
      0  229d					      db	81
      1  229d		       51		      .byte.b	81
      0  229e					      RTN
      0  229e					      db	25
      1  229e		       19		      .byte.b	25
    663  229f							;===============================================================================
    664  229f							; IPCC ---- check if a message is available
    665  229f				   F2AZb
      0  229f					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  229f					      db	32
      1  229f		       20		      .byte.b	32
      0  22a0					      db	(UNKNOWNVEC-*)-1
      1  22a0		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  22a1					      db	"C()",0
      1  22a1		       43 28 29 00	      .byte.b	"C()",0
      0  22a5					      IPCCHECK
      0  22a5					      db	82
      1  22a5		       52		      .byte.b	82
      0  22a6					      RTN
      0  22a6					      db	25
      1  22a6		       19		      .byte.b	25
    669  22a7
    670  22a7				   UNKNOWNID
      0  22a7					      IJMP	UNKNOWN
      0  22a7					      db	29
      1  22a7		       1d		      .byte.b	29
      0  22a8					      dw	UNKNOWN
      1  22a8		       39 21		      .word.w	UNKNOWN
    672  22aa							;============================================================
    673  22aa							; RND() is supposed to have an argument but if none
    674  22aa							; was provided, just assume a large value.
    675  22aa							;
    676  22aa				   F2A
      0  22aa					      TST	F2B,"RND("
      0  22aa					      db	32
      1  22aa		       20		      .byte.b	32
      0  22ab					      db	(F2B-*)-1
      1  22ab		       17		      .byte.b	(F2B-*)-1
      0  22ac					      db	"RND(",0
      1  22ac		       52 4e 44 28*	      .byte.b	"RND(",0
      0  22b1					      TST	F2A1,")"
      0  22b1					      db	32
      1  22b1		       20		      .byte.b	32
      0  22b2					      db	(F2A1-*)-1
      1  22b2		       07		      .byte.b	(F2A1-*)-1
      0  22b3					      db	")",0
      1  22b3		       29 00		      .byte.b	")",0
      0  22b5					      LIT	32766
      0  22b5					      db	27
      1  22b5		       1b		      .byte.b	27
      0  22b6					      dw	32766
      1  22b6		       fe 7f		      .word.w	32766
      0  22b8					      RANDOM
      0  22b8					      db	37
      1  22b8		       25		      .byte.b	37
      0  22b9					      RTN
      0  22b9					      db	25
      1  22b9		       19		      .byte.b	25
    682  22ba
    683  22ba				   F2A1
      0  22ba					      CALL	FACT	;GET RANGE
      0  22ba					      db	28
      1  22ba		       1c		      .byte.b	28
      0  22bb					      dw	FACT
      1  22bb		       09 22		      .word.w	FACT
      0  22bd					      TST	UNKNOWNVEC,")"
      0  22bd					      db	32
      1  22bd		       20		      .byte.b	32
      0  22be					      db	(UNKNOWNVEC-*)-1
      1  22be		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  22bf					      db	")",0
      1  22bf		       29 00		      .byte.b	")",0
      0  22c1					      RANDOM
      0  22c1					      db	37
      1  22c1		       25		      .byte.b	37
      0  22c2					      RTN
      0  22c2					      db	25
      1  22c2		       19		      .byte.b	25
    688  22c3							;==========================================================
    689  22c3							;	Return absolute value of expresion
    690  22c3							;
    691  22c3				   F2B
      0  22c3					      TST	F2B2,"ABS("
      0  22c3					      db	32
      1  22c3		       20		      .byte.b	32
      0  22c4					      db	(F2B2-*)-1
      1  22c4		       0e		      .byte.b	(F2B2-*)-1
      0  22c5					      db	"ABS(",0
      1  22c5		       41 42 53 28*	      .byte.b	"ABS(",0
      0  22ca					      CALL	EXPR	;get value
      0  22ca					      db	28
      1  22ca		       1c		      .byte.b	28
      0  22cb					      dw	EXPR
      1  22cb		       3d 21		      .word.w	EXPR
      0  22cd					      TST	UNKNOWNVEC,")"
      0  22cd					      db	32
      1  22cd		       20		      .byte.b	32
      0  22ce					      db	(UNKNOWNVEC-*)-1
      1  22ce		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  22cf					      db	")",0
      1  22cf		       29 00		      .byte.b	")",0
      0  22d1					      ABS
      0  22d1					      db	38
      1  22d1		       26		      .byte.b	38
      0  22d2					      RTN
      0  22d2					      db	25
      1  22d2		       19		      .byte.b	25
    697  22d3							;============================================================
    698  22d3							;     Return the the status of a task, provide the PID
    699  22d3							;
    700  22d3				   F2B2
      0  22d3					      TST	F2Z,"STAT("
      0  22d3					      db	32
      1  22d3		       20		      .byte.b	32
      0  22d4					      db	(F2Z-*)-1
      1  22d4		       0f		      .byte.b	(F2Z-*)-1
      0  22d5					      db	"STAT(",0
      1  22d5		       53 54 41 54*	      .byte.b	"STAT(",0
      0  22db					      Call	EXPR
      0  22db					      db	28
      1  22db		       1c		      .byte.b	28
      0  22dc					      dw	EXPR
      1  22dc		       3d 21		      .word.w	EXPR
      0  22de					      TST	UNKNOWNVEC,")"
      0  22de					      db	32
      1  22de		       20		      .byte.b	32
      0  22df					      db	(UNKNOWNVEC-*)-1
      1  22df		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  22e0					      db	")",0
      1  22e0		       29 00		      .byte.b	")",0
      0  22e2					      TASKSTAT
      0  22e2					      db	66
      1  22e2		       42		      .byte.b	66
      0  22e3					      RTN
      0  22e3					      db	25
      1  22e3		       19		      .byte.b	25
    706  22e4				   F2Z
      0  22e4					      TST	F2ZA,"PID"
      0  22e4					      db	32
      1  22e4		       20		      .byte.b	32
      0  22e5					      db	(F2ZA-*)-1
      1  22e5		       06		      .byte.b	(F2ZA-*)-1
      0  22e6					      db	"PID",0
      1  22e6		       50 49 44 00	      .byte.b	"PID",0
      0  22ea					      TASKPID
      0  22ea					      db	77
      1  22ea		       4d		      .byte.b	77
      0  22eb					      RTN
      0  22eb					      db	25
      1  22eb		       19		      .byte.b	25
    710  22ec							;===========================================================================
    711  22ec							; Call a machine function, provide the address to call and optionally
    712  22ec							; the value to be passed in reg A
    713  22ec				   F2ZA
      0  22ec					      TST	F2FUNC,"CALL("	;call machine function
      0  22ec					      db	32
      1  22ec		       20		      .byte.b	32
      0  22ed					      db	(F2FUNC-*)-1
      1  22ed		       1f		      .byte.b	(F2FUNC-*)-1
      0  22ee					      db	"CALL(",0
      1  22ee		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  22f4					      CALL	EXPR
      0  22f4					      db	28
      1  22f4		       1c		      .byte.b	28
      0  22f5					      dw	EXPR
      1  22f5		       3d 21		      .word.w	EXPR
      0  22f7					      TST	F2B2A,COMMA
      0  22f7					      db	32
      1  22f7		       20		      .byte.b	32
      0  22f8					      db	(F2B2A-*)-1
      1  22f8		       0b		      .byte.b	(F2B2A-*)-1
      0  22f9					      db	COMMA,0
      1  22f9		       2c 00		      .byte.b	COMMA,0
      0  22fb					      CALL	EXPR
      0  22fb					      db	28
      1  22fb		       1c		      .byte.b	28
      0  22fc					      dw	EXPR
      1  22fc		       3d 21		      .word.w	EXPR
      0  22fe					      TST	UNKNOWNVEC,")"
      0  22fe					      db	32
      1  22fe		       20		      .byte.b	32
      0  22ff					      db	(UNKNOWNVEC-*)-1
      1  22ff		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  2300					      db	")",0
      1  2300		       29 00		      .byte.b	")",0
      0  2302					      CALLFUNC
      0  2302					      db	53
      1  2302		       35		      .byte.b	53
      0  2303					      RTN
      0  2303					      db	25
      1  2303		       19		      .byte.b	25
    721  2304							; Run the gosub within this function
    722  2304				   F2B2A
      0  2304					      TST	UNKNOWNID,")"
      0  2304					      db	32
      1  2304		       20		      .byte.b	32
      0  2305					      db	(UNKNOWNID-*)-1
      1  2305		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  2306					      db	")",0
      1  2306		       29 00		      .byte.b	")",0
      0  2308					      LIT	0	; No parameter passed so just load zero to A
      0  2308					      db	27
      1  2308		       1b		      .byte.b	27
      0  2309					      dw	0
      1  2309		       00 00		      .word.w	0
      0  230b					      CALLFUNC
      0  230b					      db	53
      1  230b		       35		      .byte.b	53
      0  230c					      RTN
      0  230c					      db	25
      1  230c		       19		      .byte.b	25
    727  230d							;===========================================================================
    728  230d							; Same as gosub but expects a return value
    729  230d							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    730  230d							;
      0  230d				   F2FUNC     TST	F2C,"GOFN"
      0  230d					      db	32
      1  230d		       20		      .byte.b	32
      0  230e					      db	(F2C-*)-1
      1  230e		       0c		      .byte.b	(F2C-*)-1
      0  230f					      db	"GOFN",0
      1  230f		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  2314					      Call	GOSUBSTATEMENT
      0  2314					      db	28
      1  2314		       1c		      .byte.b	28
      0  2315					      dw	GOSUBSTATEMENT
      1  2315		       44 23		      .word.w	GOSUBSTATEMENT
      0  2317					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  2317					      db	8
      1  2317		       08		      .byte.b	8
      0  2318					      db	GOSUB_RTN_VALUE
      1  2318		       81		      .byte.b	GOSUB_RTN_VALUE
      0  2319					      XFER
      0  2319					      db	7
      1  2319		       07		      .byte.b	7
    735  231a				   GOFNRet
      0  231a					      RTN
      0  231a					      db	25
      1  231a		       19		      .byte.b	25
    737  231b							;=============================================================================
    738  231b							; See if this is just a simple variable
    739  231b							;  Allow a subscript for any variable
    740  231b							;
    741  231b				   F2C
      0  231b					      TSTV	F0
      0  231b					      db	33
      1  231b		       21		      .byte.b	33
      0  231c					      db	(F0-*)-1
      1  231c		       15		      .byte.b	(F0-*)-1
      0  231d					      TST	F2CLocalTask,"!"
      0  231d					      db	32
      1  231d		       20		      .byte.b	32
      0  231e					      db	(F2CLocalTask-*)-1
      1  231e		       05		      .byte.b	(F2CLocalTask-*)-1
      0  231f					      db	"!",0
      1  231f		       21 00		      .byte.b	"!",0
      0  2321					      IND		; we just got a pid
      0  2321					      db	20
      1  2321		       14		      .byte.b	20
      0  2322					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  2322					      db	93
      1  2322		       5d		      .byte.b	93
      0  2323					      db	(UNKNOWNID-*)-1
      1  2323		       83		      .byte.b	(UNKNOWNID-*)-1
    746  2324
    747  2324				   F2CLocalTask
      0  2324					      TST	F2C1,"["
      0  2324					      db	32
      1  2324		       20		      .byte.b	32
      0  2325					      db	(F2C1-*)-1
      1  2325		       0a		      .byte.b	(F2C1-*)-1
      0  2326					      db	"[",0
      1  2326		       5b 00		      .byte.b	"[",0
      0  2328					      CALL	EXPR
      0  2328					      db	28
      1  2328		       1c		      .byte.b	28
      0  2329					      dw	EXPR
      1  2329		       3d 21		      .word.w	EXPR
      0  232b					      TST	UNKNOWNID,"]"
      0  232b					      db	32
      1  232b		       20		      .byte.b	32
      0  232c					      db	(UNKNOWNID-*)-1
      1  232c		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  232d					      db	"]",0
      1  232d		       5d 00		      .byte.b	"]",0
      0  232f					      SUBSCRIPT
      0  232f					      db	64
      1  232f		       40		      .byte.b	64
    752  2330				   F2C1
      0  2330					      IND		;YES, GET THE VALUE.
      0  2330					      db	20
      1  2330		       14		      .byte.b	20
      0  2331					      RTN
      0  2331					      db	25
      1  2331		       19		      .byte.b	25
    755  2332							;=================================================================================
    756  2332							;Finally check for a number !
    757  2332							;
    758  2332				   F0
      0  2332					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  2332					      db	35
      1  2332		       23		      .byte.b	35
      0  2333					      db	(F1-*)-1
      1  2333		       01		      .byte.b	(F1-*)-1
      0  2334					      RTN
      0  2334					      db	25
      1  2334		       19		      .byte.b	25
    761  2335				   F1
      0  2335					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  2335					      db	32
      1  2335		       20		      .byte.b	32
      0  2336					      db	(F2RTN-*)-1
      1  2336		       09		      .byte.b	(F2RTN-*)-1
      0  2337					      db	"(",0
      1  2337		       28 00		      .byte.b	"(",0
      0  2339					      CALL	EXPR
      0  2339					      db	28
      1  2339		       1c		      .byte.b	28
      0  233a					      dw	EXPR
      1  233a		       3d 21		      .word.w	EXPR
      0  233c					      TST	F2,")"
      0  233c					      db	32
      1  233c		       20		      .byte.b	32
      0  233d					      db	(F2-*)-1
      1  233d		       03		      .byte.b	(F2-*)-1
      0  233e					      db	")",0
      1  233e		       29 00		      .byte.b	")",0
    765  2340				   F2RTN
      0  2340					      RTN
      0  2340					      db	25
      1  2340		       19		      .byte.b	25
    767  2341
    768  2341				   F2
      0  2341					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  2341					      db	13
      1  2341		       0d		      .byte.b	13
      0  2342					      dw	ERR_SYNTAX
      1  2342		       05 00		      .word.w	ERR_SYNTAX
    770  2344							;
    771  2344							;=============================================================
    772  2344							; Gosub can be both a Function and a Subroutine
    773  2344				   GOSUBSTATEMENT
      0  2344					      CALL	EXPR	;GET DESTINATION
      0  2344					      db	28
      1  2344		       1c		      .byte.b	28
      0  2345					      dw	EXPR
      1  2345		       3d 21		      .word.w	EXPR
      0  2347					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  2347					      db	32
      1  2347		       20		      .byte.b	32
      0  2348					      db	(GOSUBDONE-*)-1
      1  2348		       14		      .byte.b	(GOSUBDONE-*)-1
      0  2349					      db	"(",0
      1  2349		       28 00		      .byte.b	"(",0
      0  234b					      STK2TMP		;Transfer stack top to temp
      0  234b					      db	95
      1  234b		       5f		      .byte.b	95
      0  234c					      PUSHMATHSTACK		;Record stack frame for return
      0  234c					      db	84
      1  234c		       54		      .byte.b	84
    778  234d				   GOSUBLOOP
      0  234d					      CALL	EXPR	; Allows what ever fits onto stack
      0  234d					      db	28
      1  234d		       1c		      .byte.b	28
      0  234e					      dw	EXPR
      1  234e		       3d 21		      .word.w	EXPR
      0  2350					      INCPARMCOUNT
      0  2350					      db	88
      1  2350		       58		      .byte.b	88
      0  2351					      TST	GOSUBParmDONE,COMMA
      0  2351					      db	32
      1  2351		       20		      .byte.b	32
      0  2352					      db	(GOSUBParmDONE-*)-1
      1  2352		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  2353					      db	COMMA,0
      1  2353		       2c 00		      .byte.b	COMMA,0
      0  2355					      IJMP	GOSUBLOOP
      0  2355					      db	29
      1  2355		       1d		      .byte.b	29
      0  2356					      dw	GOSUBLOOP
      1  2356		       4d 23		      .word.w	GOSUBLOOP
    783  2358				   GOSUBParmDONE
      0  2358					      TST	F2,")"
      0  2358					      db	32
      1  2358		       20		      .byte.b	32
      0  2359					      db	(F2-*)-1
      1  2359		       e7		      .byte.b	(F2-*)-1
      0  235a					      db	")",0
      1  235a		       29 00		      .byte.b	")",0
      0  235c					      TMP2STK		;Restore line to goto
      0  235c					      db	96
      1  235c		       60		      .byte.b	96
    786  235d				   GOSUBDONE
      0  235d					      RTN
      0  235d					      db	25
      1  235d		       19		      .byte.b	25
    788  235e
    789  235e		       23 5e	   ILEND      equ	*
------- FILE mytb.asm
   2225  235e		       23 5e	   PROGEND    equ	*
   2226  235e
   2227  235e
   2228  235e							;=====================================================
   2229  235e							; Define start of non page zero data
   2230 U236e					      seg.u	TBData
   2231 U236e
   2232 U236e							;=====================================================
   2233 U236e							; These are storage items not in page zero.
   2234 U236e							;
   2235 U236e							; IRQ BASIC Code Service RTN Support
      0 U236e				   SaveIrqReg db	0	; Store current setting
      1 U236e		       00		      .byte.b	0
      0 U236f				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U236f		       00		      .byte.b	0
      0 U2370				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U2370		       00		      .byte.b	0
      0 U2371				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U2371		       00 00		      .byte.b	0,0
   2240 U2373
   2241 U2373							;
   2242 U2373							;==================================================================================================
   2243 U2373							; Task Management information
   2244 U2373							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2245 U2373							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2246 U2373							; Task switchs happen at the beginning of the next Basic command line
   2247 U2373							; It will not happen during an input or output operations
   2248 U2373							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2249 U2373							; Task Zero is always the root task, main line program
   2250 U2373							;
   2251 U2373							; Layout is repeated for each configured task
   2252 U2373							; Task Table Byte   use masks follow
   2253 U2373		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2254 U2373		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2255 U2373		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2256 U2373		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2257 U2373		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2258 U2373
   2259 U2373		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2260 U2374		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2261 U2374		       24 6e	   TASKTABLEEND equ	*	; End of task table
   2262 U2374		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2263 U246e
   2264 U246e							;Task Cycle Counter and reset count
   2265 U246e		       00 00	   taskCurrentCycles ds	2
   2266 U2470		       00 00	   taskResetValue ds	2
   2267 U2472		       00	   taskCounter ds	1	; Count of active tasks
   2268 U2473
   2269 U2473							;
   2270 U2473							; Math stack and IL call and Gosub/For-next return stack definitions
   2271 U2473							;
   2272 U2473		       24 73	   STACKSTART equ	*
   2273 U2473		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2274 U2603		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2275 U2793		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2276 U2a13		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2277 U2a13		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2278 U2a13		       2c 2f	   STACKEND   equ	*
   2279 U2a13		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2280 U2c2f							;
   2281 U2c2f							;
   2282 U2c2f		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2283 U2cb3		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2284 U2cb4		       00	   printtx    ds	1	;temp X for print funcs
   2285 U2cb5		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2286 U2cb6		       00	   promptChar ds	1	;the character to use for a prompt
   2287 U2cb7		       00	   diddigit   ds	1	;for leading zero suppression
   2288 U2cb8		       00	   putsy      ds	1
   2289 U2cb9		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2290 U2cbb		       00	   sign       ds	1	;0 = positive, else negative
   2291 U2cbc		       00 00	   rtemp1     ds	2	;Temp for x and y
   2292 U2cbe		       00 00	   random     ds	2
   2293 U2cc0		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2294 U2cc2		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2295 U2cc4		       00	   tempy      ds	1	;temp y storage
   2296 U2cc5
   2297 U2cc5							; Moved from page zero as one clock cycle diff gives more space on page zero
   2298 U2cc5		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2299 U2cc7		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2300 U2cc8		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2301 U2cc9		       00	   lineLength ds	1	;Length of current line
   2302 U2cca
   2303 U2cca		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2304 U2ccb		       00	   taskRDPending ds	1	; 1 = background read is pending
   2305 U2ccc
   2306 U2ccc				  -	      if	XKIM
   2307 U2ccc				  -buffer     ds	BUFFER_SIZE
   2308 U2ccc					      endif
   2309 U2ccc							;
   2310 U2ccc							; PROGRAMEND is the end of the user's BASIC program.
   2311 U2ccc							; More precisely, it is one byte past the end.  Or,
   2312 U2ccc							; it's where the next line added to the end will be
   2313 U2ccc							; placed.
   2314 U2ccc							;
   2315 U2ccc		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2316 U2cce		       00 00	   ProgramEnd ds	2	; End of users basic program
   2317 U2cd0		       00 00	   HighMem    ds	2	; highest location
   2318 U2cd2		       00 00	   UsedMem    ds	2	; size of user program
   2319 U2cd4		       00 00	   FreeMem    ds	2	; amount of free memory
   2320 U2cd6							;
   2321 U2cd6							;=====================================================
   2322 U2cd6							; This is the start of the user's BASIC program space.
   2323 U2cd6							;
   2324 U2cd6							; PERSONAL GOAL: This should be no larger than $0DFF.
   2325 U2cd6							;		  0200-05FF = 1K
   2326 U2cd6							;		  0200-09FF = 2K
   2327 U2cd6							;		  0200-0DFF = 3K
   2328 U2cd6							;		  0200-11FF = 4K
   2329 U2cd6							;		  0200-13FF = 4.5K
   2330 U2cd6							;
   2331 U2cd6				  -	      if	FIXED
   2332 U2cd6				  -	      org	$2000
   2333 U2cd6					      endif
   2334 U2cd6
   2335 U2cd6		       2c d6	   FreeMemStart equ	*
   2336 U2cd6							;/*
   2337 U2cd6							;	if	CTMON65 || XKIM
   2338 U2cd6							;		SEG Code
   2339 U2cd6							;		org	AutoRun
   2340 U2cd6							;		dw	TBasicCold
   2341 U2cd6							;	endif
   2342 U2cd6							;*/
   2343 U2cd6					      end
