------- FILE mytb.asm LEVEL 1 PASS 3
      1 U1121				   input      processor	6502
      2 U1121 ????						;=====================================================
      3 U1121 ????						; Bob's Tiny BASIC
      4 U1121 ????						;
      5 U1121 ????						; While working on the Corsham Technologies KIM Clone
      6 U1121 ????						; project, I wanted to include a TINY BASIC since that
      7 U1121 ????						; was a highly desirable feature of early computers.
      8 U1121 ????						;
      9 U1121 ????						; Rather than negotiating copyright issues for
     10 U1121 ????						; existing BASICs, I decided to just write one from
     11 U1121 ????						; scratch.
     12 U1121 ????						;
     13 U1121 ????						; 10/07/2017
     14 U1121 ????						;
     15 U1121 ????						; This implements a stripped down Tiny BASIC
     16 U1121 ????						; interpreter using the Interpretive Language (IL)
     17 U1121 ????						; method as described in the first few issues of
     18 U1121 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1121 ????						; to write various languages simply by changing the
     20 U1121 ????						; IL code rather than the interpreter itself.
     21 U1121 ????						;
     22 U1121 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1121 ????						;		* Fxed major bug in findLine that
     24 U1121 ????						;		  caused corrupted lines, crashes, etc.
     25 U1121 ????						;		* If no parameter given to RND, assume
     26 U1121 ????						;		  32766.
     27 U1121 ????						;		* No more error 5 when a program
     28 U1121 ????						;		  reaches the end without an END.
     29 U1121 ????						;
     30 U1121 ????						; www.corshamtech.com
     31 U1121 ????						; bob@corshamtech.com
     32 U1121 ????						;
     33 U1121 ????						;=====================================================
     34 U1121 ????						;
     35 U1121 ????						; Create TRUE and FALSE values for conditionals.
     36 U1121 ????						;
     37 U1121 ????
     38 U1121 ????	       00 00	   FALSE      equ	0
     39 U1121 ????	       ff ff ff ff TRUE       equ	~FALSE
     40 U1121 ????						;
     41 U1121 ????						;---------------------------------------------------------
     42 U1121 ????						; One of these must be set to indicate which environment
     43 U1121 ????						; Tiny BASIC will be running in.  Here are the current
     44 U1121 ????						; environments:
     45 U1121 ????						;
     46 U1121 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     47 U1121 ????						; more K of RAM.
     48 U1121 ????						;
     49 U1121 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     50 U1121 ????						; which enhances, without replacing, the standard KIM
     51 U1121 ????						; monitor.  It gives access to routines to save/load files
     52 U1121 ????						; to a micro SD card.
     53 U1121 ????						;
     54 U1121 ????						; CTMON65 is a from-scratch monitor written for the
     55 U1121 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     56 U1121 ????						; easily be ported to other systems.  It has support for
     57 U1121 ????						; using a micro SD card for file storage/retrieval.
     58 U1121 ????						;
     59 U1121 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     60 U1121 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     61 U1121 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     62 U1121 ????						;
     63 U1121 ????						;   Need to define some macros for the dasm assembler
     64 U1121 ????						;
     65 U1121 ????				      MACRO	dw
     66 U1121 ????				      .word	{0}
     67 U1121 ????				      ENDM
     68 U1121 ????
     69 U1121 ????				      MACRO	db
     70 U1121 ????				      .byte	{0}
     71 U1121 ????				      ENDM
     72 U1121 ????
     73 U1121 ????						;
     74 U1121 ????						; If set, include disk functions.
     75 U1121 ????						;
     76 U1121 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     77 U1121 ????						;
     78 U1121 ????						; If ILTRACE is set then dump out the address of every
     79 U1121 ????						; IL opcode before executing it.
     80 U1121 ????						;
     81 U1121 ????	       00 00	   ILTRACE    equ	FALSE
     82 U1121 ????						;
     83 U1121 ????						; If FIXED is set, put the IL code and the user
     84 U1121 ????						; program space at fixed locations in memory.	This is
     85 U1121 ????						; meant only for debugging.
     86 U1121 ????						;
     87 U1121 ????	       00 00	   FIXED      equ	FALSE
     88 U1121 ????						;
     89 U1121 ????						; Sets the arithmetic stack depth.  This is *TINY*
     90 U1121 ????						; BASIC, so keep this small!
     91 U1121 ????						;
     92 U1121 ????	       00 14	   STACKSIZE  equ	20	;number of entries
     93 U1121 ????						;
     94 U1121 ????						; Common ASCII constants
     95 U1121 ????						;
     96 U1121 ????	       00 07	   BEL	      equ	$07
     97 U1121 ????	       00 08	   BS	      equ	$08
     98 U1121 ????	       00 09	   TAB	      equ	$09
     99 U1121 ????	       00 0a	   LF	      equ	$0A
    100 U1121 ????	       00 0d	   CR	      equ	$0D
    101 U1121 ????	       00 22	   QUOTE      equ	$22
    102 U1121 ????	       00 20	   SPACE      equ	$20
    103 U1121 ????	       00 2c	   COMMA      equ	',
    104 U1121 ????	       00 3b	   SEMICOLON  equ	';
    105 U1121 ????						;
    106 U1121 ????						; These are error codes
    107 U1121 ????						;
    108 U1121 ????	       00 00	   ERR_NONE   equ	0
    109 U1121 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    110 U1121 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    111 U1121 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    112 U1121 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    113 U1121 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    114 U1121 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    115 U1121 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    116 U1121 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    117 U1121 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    118 U1121 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    119 U1121 ????						;
    120 U1121 ????						;=====================================================
    121 U1121 ????						; Zero page storage.
    122 U1121 ????						;
    123 U1121 ????				      SEG.U	bss
    124 U0040					      org	$0040
    125 U0040
    126 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    127 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    128 U0041		       00 75	   variablesEnd equ	*
    129 U0075		       00 00	   ILPC       ds	2	;IL program counter
    130 U0077		       00 00	   dpl	      ds	2
    131 U0079		       00 00	   tempIL     ds	2
    132 U007b		       00	   tempIlY    ds	1
    133 U007c		       00	   offset     ds	1
    134 U007d		       00	   lineLength ds	1
    135 U007e		       00 00	   lastln     ds	2	; the line number of the last line in program space
    136 U0080
    137 U0080							;
    138 U0080							; CURPTR is a pointer to curent BASIC line being
    139 U0080							; executed.  Always points to start of line, CUROFF
    140 U0080							; is the offset to the current character.
    141 U0080							;
    142 U0080		       00 00	   CURPTR     ds	2
    143 U0082		       00	   CUROFF     ds	1
    144 U0083							;
    145 U0083							; THE ADDRESS USED BY THE PRINTER FUNCTION
    146 U0083							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    147 U0083							;
    148 U0083		       00 00	   PrtFrom    ds	2
    149 U0085							;
    150 U0085							; R0 and R1 are used for arithmetic operations and
    151 U0085							; general use.
    152 U0085							;
    153 U0085		       00 00	   R0	      ds	2	;arithmetic register 0
    154 U0087		       00 00	   R1	      ds	2	;arithmetic register 1
    155 U0089							;
    156 U0089							; This is zero if in immediate mode, or non-zero
    157 U0089							; if currently running a program.  Any input from
    158 U0089							; the main loop clears this, and the XFER IL
    159 U0089							; statement will set it.
    160 U0089							;
    161 U0089		       00	   RunMode    ds	1
    162 U008a							;
    163 U008a							; Used for line insertion/removal.
    164 U008a							;
    165 U008a		       00 00	   FROM       ds	2
    166 U008c							;
    167 U008c							;=====================================================
    168 U008c							;
    169  1040 ????				      SEG	code
    170  0200					      org	$0200
    171  0200							;
    172  0200							; Cold start is at $0200.  Warm start is at $0203.
    173  0200							;
    174  0200		       4c 15 02    TBasicCold jmp	cold2	;jump around vectors
    175  0203		       4c 86 02    warm       jmp	warm2
    176  0206							;
    177  0206							; These are the user-supplied vectors to I/O routines.
    178  0206							; If you want, you can just patch these in the binary
    179  0206							; file, but it would be better to change the source
    180  0206							; code.
    181  0206							;
    182  0206				  -	      if	KIM
    183  0206				  -OUTCH      jmp	$1ea0	;output char in A
    184  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    185  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    186  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    187  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    188  0206					      endif
    189  0206				  -	      if	XKIM
    190  0206				  -	      include	"xkim.inc"
    191  0206				  -	      SEG	code
    192  0206				  -OUTCH      jmp	$1ea0
    193  0206				  -GETCH      jmp	xkGETCH
    194  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    195  0206				  -OUTHEX     jmp	xkPRTBYT
    196  0206				  -MONITOR    jmp	extKIM
    197  0206				  -puts       equ	putsil
    198  0206				  -BUFFER_SIZE equ	132
    199  0206					      endif
    200  0206
    201  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 3
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 3
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							;
     11 Uf048 ????				      SEG.U	rom
     12 Uf000					      org	ROM_START
     13 Uf000							;
     14 Uf000							;=========================================================
     15 Uf000							; Jump table to common functions.  The entries in this
     16 Uf000							; table are used by external programs, so nothing can be
     17 Uf000							; moved or removed from this table.  New entries always
     18 Uf000							; go at the end.  Many of these are internal functions
     19 Uf000							; and I figured they might be handy for others.
     20 Uf000							;
     21 Uf000		       00 00 00    RESET      ds	3
     22 Uf003		       00 00 00    WARM       ds	3
     23 Uf006							;
     24 Uf006							; These are the major and minor revision numbers so that
     25 Uf006							; code can check to see which CTMON65 version is running.
     26 Uf006							;
     27 Uf006		       00	   CTMON65ver ds	1
     28 Uf007		       00	   CTMON65rev ds	1
     29 Uf008		       00		      ds	1	;unused
     30 Uf009							;
     31 Uf009							; Console related functions
     32 Uf009							;
     33 Uf009		       00 00 00    cin	      ds	3
     34 Uf00c		       00 00 00    cout       ds	3
     35 Uf00f		       00 00 00    cstatus    ds	3
     36 Uf012		       00 00 00    putsil     ds	3
     37 Uf015		       00 00 00    getline    ds	3
     38 Uf018		       00 00 00    crlf       ds	3
     39 Uf01b		       00 00 00    HexA       ds	3
     40 Uf01e							;
     41 Uf01e							; Low-level functions to access the SD card system
     42 Uf01e							;
     43 Uf01e					      if	SD_ENABLED	;SD ENABLED
     44 Uf01e		       00 00 00    xParInit   ds	3
     45 Uf021		       00 00 00    xParSetWrite ds	3
     46 Uf024		       00 00 00    xParSetRead ds	3
     47 Uf027		       00 00 00    xParWriteByte ds	3
     48 Uf02a		       00 00 00    xParReadByte ds	3
     49 Uf02d							;
     50 Uf02d							; Higher level SD card functions
     51 Uf02d							;
     52 Uf02d		       00 00 00    DiskPing   ds	3
     53 Uf030		       00 00 00    DiskDir    ds	3
     54 Uf033		       00 00 00    DiskDirNext ds	3
     55 Uf036		       00 00 00    DiskOpenRead ds	3
     56 Uf039		       00 00 00    DiskOpenWrite ds	3
     57 Uf03c		       00 00 00    DiskRead   ds	3
     58 Uf03f		       00 00 00    DiskWrite  ds	3
     59 Uf042		       00 00 00    DiskClose  ds	3
     60 Uf045		       00 00 00    DiskRmFile ds	3
     61 Uf048					      endif		;SD_ENABLED
     62 Uf048
     63 Uf048							;
     64 U008c					      SEG.U	bss
     65 Udf00					      org	RAM_START
     66 Udf00							;
     67 Udf00							; The use of memory starting from here will remain
     68 Udf00							; constant through different versions of CTMON65.
     69 Udf00							;
     70 Udf00		       00 00	   IRQvec     ds	2
     71 Udf02		       00 00	   NMIvec     ds	2
     72 Udf04							;
     73 Udf04							; Before a L(oad) command, these are set to $FF.
     74 Udf04							; After loading, if they are different, jump to
     75 Udf04							; that address.
     76 Udf04							;
     77 Udf04		       00 00	   AutoRun    ds	2
     78 Udf06							;
     79 Udf06							; Pointer to the subroutine that gets the next input
     80 Udf06							; character.  Used for doing disk/console input.
     81 Udf06							;
     82 Udf06		       00 00	   inputVector ds	2
     83 Udf08							;
     84 Udf08							; Same thing for output.
     85 Udf08							;
     86 Udf08		       00 00	   outputVector ds	2
     87 Udf0a							;
     88 Udf0a							; Buffer for GETLINE
     89 Udf0a							;
     90 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    203  0206					      SEG	code
    204  0206
    205  0206		       4c 0c f0    OUTCH      jmp	cout
    206  0209		       4c 09 f0    GETCH      jmp	cin
    207  020c		       4c 18 f0    CRLF       jmp	crlf
    208  020f		       4c 1b f0    OUTHEX     jmp	HexA
    209  0212		       4c 03 f0    MONITOR    jmp	WARM
    210  0212		       f0 12	   puts       equ	putsil
    211  0215					      endif
    212  0215							;
    213  0215		       20 12 f0    cold2      jsr	puts
      0  0218					      db	CR,LF
      1  0218		       0d 0a		      .byte.b	CR,LF
      0  021a					      db	"Bob's Tiny BASIC v1.0"
      1  021a		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0"
      0  022f					      db	CR,LF
      1  022f		       0d 0a		      .byte.b	CR,LF
      0  0231					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  0231		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  025f					      db	CR,LF,0
      1  025f		       0d 0a 00 	      .byte.b	CR,LF,0
    219  0262							;
    220  0262		       a9 e0		      lda	#IL&$ff
    221  0264		       85 75		      sta	ILPC
    222  0266		       a9 0d		      lda	#IL>>8
    223  0268		       85 76		      sta	ILPC+1
    224  026a							;
    225  026a		       a9 21		      lda	#ProgramStart&$ff	;user prog
    226  026c		       8d 19 11 	      sta	PROGRAMEND
    227  026f		       a9 11		      lda	#ProgramStart>>8
    228  0271		       8d 1a 11 	      sta	PROGRAMEND+1
    229  0274							;
    230  0274							; Initialize the pseudo-random number sequence...
    231  0274							;
    232  0274		       a9 5a		      lda	#$5a
    233  0276		       8d 14 11 	      sta	rtemp1
    234  0279		       a9 9d		      lda	#%10011101
    235  027b		       8d 15 11 	      sta	random
    236  027e		       a9 5b		      lda	#%01011011
    237  0280		       8d 16 11 	      sta	random+1
    238  0283							;
    239  0283		       4c 93 02 	      jmp	coldtwo
    240  0286							;
    241  0286							; This is the warm start entry point
    242  0286							;
    243  0286		       20 0c 02    warm2      jsr	CRLF
    244  0289		       ad 0f 11 	      lda	errGoto
    245  028c		       85 75		      sta	ILPC
    246  028e		       ad 10 11 	      lda	errGoto+1
    247  0291		       85 76		      sta	ILPC+1
    248  0293							;
    249  0293							; And continue with both starts here
    250  0293							;
    251  0293		       20 86 0c    coldtwo    jsr	SetOutConsole
    252  0296							;
    253  0296							; The ILTrace flag is now run-time settable.
    254  0296							;
    255  0296		       a9 00		      lda	#ILTRACE&$ff
    256  0298		       85 40		      sta	ILTrace
    257  029a							;
    258  029a		       a9 00		      lda	#0
    259  029c		       85 89		      sta	RunMode
    260  029e		       8d bb 10 	      sta	LINBUF
    261  02a1		       a9 bb		      lda	#LINBUF&$ff
    262  02a3		       85 80		      sta	CURPTR
    263  02a5		       a9 10		      lda	#LINBUF>>8
    264  02a7		       85 81		      sta	CURPTR+1	;fall through...
    265  02a9							;
    266  02a9							;=====================================================
    267  02a9							; This is the top of the IL interpreter.  This fetches
    268  02a9							; and executes the instruction currently pointed to
    269  02a9							; by ILPC and adjusts ILPC to point to the next
    270  02a9							; instruction to execute.
    271  02a9							;
    272  02a9		       a5 40	   NextIL     lda	ILTrace
    273  02ab		       f0 03		      beq	NextIL2
    274  02ad		       20 0e 0c 	      jsr	dbgLine
    275  02b0		       a4 82	   NextIL2    ldy	CUROFF
    276  02b2		       20 05 0c 	      jsr	SkipSpaces
    277  02b5		       84 82		      sty	CUROFF
    278  02b7							;
    279  02b7		       20 03 09 	      jsr	getILByte
    280  02ba							;
    281  02ba							; When the handler is called, these are the conditions
    282  02ba							; of several important items:
    283  02ba							;
    284  02ba							;    (ILPC) will point to the byte AFTER the IL
    285  02ba							;    opcode being executed.
    286  02ba							;
    287  02ba							;    (CURPTR),CUROFF will point to the start of the
    288  02ba							;    next word in the input buffer.  Ie, the next word
    289  02ba							;    in the user program.
    290  02ba							;
    291  02ba		       0a		      asl
    292  02bb		       c9 6c		      cmp	#ILTBLend-ILTBL+2
    293  02bd		       90 33		      bcc	ILgood
    294  02bf							;
    295  02bf							; This handles an illegal IL opcode.  This is serious
    296  02bf							; and there's no way to recover.
    297  02bf							;
    298  02bf		       20 12 f0    ILbad      jsr	puts
      0  02c2					      db	CR,LF
      1  02c2		       0d 0a		      .byte.b	CR,LF
      0  02c4					      db	"Illegal IL "
      1  02c4		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02cf					      db	0
      1  02cf		       00		      .byte.b	0
    302  02d0							;
    303  02d0							; Well this is awkward, we need to back up the IL
    304  02d0							; by one since it no longer points to the current
    305  02d0							; opcode.
    306  02d0							;
    307  02d0		       20 10 09 	      jsr	decIL
    308  02d3							;
    309  02d3		       a0 00		      ldy	#0
    310  02d5		       b1 75		      lda	(ILPC),y
    311  02d7		       20 0f 02 	      jsr	OUTHEX
    312  02da		       20 12 f0 	      jsr	puts
      0  02dd					      db	" at ",0
      1  02dd		       20 61 74 20*	      .byte.b	" at ",0
    314  02e2		       a5 76		      lda	ILPC+1
    315  02e4		       20 0f 02 	      jsr	OUTHEX
    316  02e7		       a5 75		      lda	ILPC
    317  02e9		       20 0f 02 	      jsr	OUTHEX
    318  02ec		       20 0c 02 	      jsr	CRLF
    319  02ef		       4c 12 02 	      jmp	MONITOR
    320  02f2							;
    321  02f2							; Just jump to the address (ILPC),y.  Have to do
    322  02f2							; some goofy stuff.
    323  02f2							;
    324  02f2		       a8	   ILgood     tay		;move index into Y
    325  02f3		       b9 00 03 	      lda	ILTBL,y
    326  02f6		       85 77		      sta	dpl
    327  02f8		       b9 01 03 	      lda	ILTBL+1,y
    328  02fb		       85 78		      sta	dpl+1
    329  02fd		       6c 77 00 	      jmp	(dpl)	;go to handler
    330  0300							;
    331  0300							;=====================================================
    332  0300							; This is the IL jump table.  The IL opcode is
    333  0300							; mulitplied by two, then looked-up in this table.
    334  0300							; There is absolutely nothing special about the order
    335  0300							; of entries here... they all decode at exactly the
    336  0300							; same speed.	However the entry number must match the
    337  0300							; values in IL.inc.
    338  0300							;
      0  0300				   ILTBL      dw	iXINIT	;0
      1  0300		       80 03		      .word.w	iXINIT
      0  0302					      dw	iDONE	;1
      1  0302		       88 03		      .word.w	iDONE
      0  0304					      dw	iPRS	;2
      1  0304		       9b 03		      .word.w	iPRS
      0  0306					      dw	iPRN	;3
      1  0306		       be 03		      .word.w	iPRN
      0  0308					      dw	iSPC	;4
      1  0308		       c7 03		      .word.w	iSPC
      0  030a					      dw	iNLINE	;5
      1  030a		       e6 06		      .word.w	iNLINE
      0  030c					      dw	iNXT	;6
      1  030c		       cf 03		      .word.w	iNXT
      0  030e					      dw	iXFER	;7
      1  030e		       e7 03		      .word.w	iXFER
      0  0310					      dw	iSAV	;8
      1  0310		       14 04		      .word.w	iSAV
      0  0312					      dw	iRSTR	;9
      1  0312		       1a 04		      .word.w	iRSTR
      0  0314					      dw	iCMPR	;10
      1  0314		       20 04		      .word.w	iCMPR
      0  0316					      dw	iINNUM	;11
      1  0316		       62 04		      .word.w	iINNUM
      0  0318					      dw	iFIN	;12
      1  0318		       82 04		      .word.w	iFIN
      0  031a					      dw	iERR	;13
      1  031a		       93 04		      .word.w	iERR
      0  031c					      dw	iADD	;14
      1  031c		       df 04		      .word.w	iADD
      0  031e					      dw	iSUB	;15
      1  031e		       f5 04		      .word.w	iSUB
      0  0320					      dw	iNEG	;16
      1  0320		       0b 05		      .word.w	iNEG
      0  0322					      dw	iMUL	;17
      1  0322		       23 05		      .word.w	iMUL
      0  0324					      dw	iDIV	;18
      1  0324		       5d 05		      .word.w	iDIV
      0  0326					      dw	iSTORE	;19
      1  0326		       a6 05		      .word.w	iSTORE
      0  0328					      dw	iIND	;20
      1  0328		       b9 05		      .word.w	iIND
      0  032a					      dw	iLST	;21
      1  032a		       c9 05		      .word.w	iLST
      0  032c					      dw	iINIT	;22
      1  032c		       6a 03		      .word.w	iINIT
      0  032e					      dw	iGETLINE
      1  032e		       28 06		      .word.w	iGETLINE
      0  0330					      dw	iINSRT	;24
      1  0330		       34 06		      .word.w	iINSRT
      0  0332					      dw	iRTN	;25
      1  0332		       e0 06		      .word.w	iRTN
      0  0334					      dw	MONITOR	;26
      1  0334		       12 02		      .word.w	MONITOR
      0  0336					      dw	iLIT	;27
      1  0336		       f9 06		      .word.w	iLIT
      0  0338					      dw	iCALL	;28
      1  0338		       ec 06		      .word.w	iCALL
      0  033a					      dw	iJMP	;29
      1  033a		       ef 06		      .word.w	iJMP
      0  033c					      dw	iVINIT	;30
      1  033c		       06 07		      .word.w	iVINIT
      0  033e					      dw	iERRGOTO
      1  033e		       14 07		      .word.w	iERRGOTO
      0  0340					      dw	iTST	;32
      1  0340		       20 07		      .word.w	iTST
      0  0342					      dw	iTSTV	;33
      1  0342		       89 07		      .word.w	iTSTV
      0  0344					      dw	iTSTL	;34
      1  0344		       b3 07		      .word.w	iTSTL
      0  0346					      dw	iTSTN	;35
      1  0346		       cd 07		      .word.w	iTSTN
      0  0348					      dw	iFREE	;36
      1  0348		       10 08		      .word.w	iFREE
      0  034a					      dw	iRANDOM	;37
      1  034a		       19 08		      .word.w	iRANDOM
      0  034c					      dw	iABS	;38
      1  034c		       e2 08		      .word.w	iABS
    378  034e							;
    379  034e							; Disk functions.  There must be pointers
    380  034e							; to functions even if no disk is supported.
    381  034e							; Makes things easier in IL.inc.
    382  034e							;
    383  034e					      if	DISK_ACCESS
      0  034e					      dw	iOPENREAD	;39
      1  034e		       bb 0c		      .word.w	iOPENREAD
      0  0350					      dw	iOPENWRITE	;40
      1  0350		       0f 0d		      .word.w	iOPENWRITE
      0  0352					      dw	iDCLOSE	;41
      1  0352		       93 0d		      .word.w	iDCLOSE
      0  0354					      dw	iDGETLINE	;Life, universe, everything
      1  0354		       2e 0d		      .word.w	iDGETLINE
      0  0356					      dw	iDLIST	;43
      1  0356		       8d 0d		      .word.w	iDLIST
      0  0358					      dw	iDDIR	;44
      1  0358		       68 0d		      .word.w	iDDIR
      0  035a					      dw	iRMFILE	;45
      1  035a		       e9 0c		      .word.w	iRMFILE
    391  035c				  -	      else
    392  035c				  -	      dw	NextIL	;39
    393  035c				  -	      dw	NextIL	;40
    394  035c				  -	      dw	NextIL	;41
    395  035c				  -	      dw	NextIL	;42
    396  035c				  -	      dw	NextIL	;43
    397  035c				  -	      dw	NextIL	;44
    398  035c				  -	      dw	NextIL	;45
    399  035c					      endif
    400  035c							;
      0  035c					      dw	iCLEARSCREEN	;46
      1  035c		       b0 0c		      .word.w	iCLEARSCREEN
      0  035e					      dw	iPOKEMEMORY	;47
      1  035e		       91 08		      .word.w	iPOKEMEMORY
      0  0360					      dw	iPEEKMEMORY	;48
      1  0360		       a8 08		      .word.w	iPEEKMEMORY
      0  0362					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0362		       4f 07		      .word.w	iTSTLET
      0  0364					      dw	iTSTDONE	;50	Test if we are at the end of a line
      1  0364		       6c 07		      .word.w	iTSTDONE
      0  0366					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0366		       c3 08		      .word.w	iGETCHAR
      0  0368					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0368		       d7 08		      .word.w	iPUTCHAR
    408  036a
    409  036a		       03 6a	   ILTBLend   equ	*
    410  036a							;
    411  036a							;=====================================================
    412  036a							;=====================================================
    413  036a							;=====================================================
    414  036a							; This marks the start of the handlers for IL opcodes.
    415  036a							;=====================================================
    416  036a							;=====================================================
    417  036a							;=====================================================
    418  036a							;
    419  036a							;
    420  036a		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    421  036c		       8d 91 10 	      sta	retStackPtr
    422  036f		       8d ba 10 	      sta	callStackPtr
    423  0372							;
    424  0372		       a9 21		      lda	#ProgramStart&$ff	;user prog
    425  0374		       85 80		      sta	CURPTR
    426  0376		       8d 19 11 	      sta	PROGRAMEND
    427  0379		       a9 11		      lda	#ProgramStart>>8
    428  037b		       85 81		      sta	CURPTR+1
    429  037d		       8d 1a 11 	      sta	PROGRAMEND+1
    430  0380							;
    431  0380							; fall into XINIT...
    432  0380							;
    433  0380							;=====================================================
    434  0380							; This initializes for the start of the next line of
    435  0380							; BASIC text.
    436  0380							;
    437  0380		       a9 00	   iXINIT     lda	#0
    438  0382		       8d 68 10 	      sta	mathStackPtr	;clear math stack
    439  0385		       4c a9 02    goodExit   jmp	NextIL
    440  0388							;
    441  0388							;=====================================================
    442  0388							; Verify there is nothing else on this input line.
    443  0388							; If there is, generate an error.
    444  0388							;
    445  0388		       a4 82	   iDONE      ldy	CUROFF
    446  038a		       20 05 0c 	      jsr	SkipSpaces
    447  038d		       b1 80		      lda	(CURPTR),y
    448  038f		       f0 07		      beq	doneadv
    449  0391		       a2 04		      ldx	#ERR_EXTRA_STUFF
    450  0393		       a9 00		      lda	#0
    451  0395		       4c 96 04 	      jmp	iErr2
    452  0398							;
    453  0398							; Advance to the next line
    454  0398							;
    455  0398				   doneadv
    456  0398							;		jsr	FindNext2
    457  0398		       4c a9 02 	      jmp	NextIL
    458  039b							;
    459  039b							;=====================================================
    460  039b							; Print the string until a closing quote
    461  039b							;
    462  039b		       a4 82	   iPRS       ldy	CUROFF
    463  039d							;
    464  039d							; Odd logic here.  The main loop skipped any leading
    465  039d							; whitespace inside the quoted text, so move back to
    466  039d							; the quote, then move forward again.
    467  039d							;
    468  039d		       a9 22		      lda	#'"	;pre-load with char to find
    469  039f		       88	   iPRS3      dey		;move back one
    470  03a0		       d1 80		      cmp	(CURPTR),y	;quote?
    471  03a2		       d0 fb		      bne	iPRS3
    472  03a4		       c8		      iny
    473  03a5		       84 82		      sty	CUROFF
    474  03a7							;
    475  03a7		       b1 80	   iPRS2      lda	(CURPTR),y
    476  03a9		       f0 10		      beq	PRSend2	;end of line!
    477  03ab		       c9 22		      cmp	#'"
    478  03ad		       f0 09		      beq	PRSend
    479  03af		       20 06 02 	      jsr	OUTCH
    480  03b2		       e6 82		      inc	CUROFF
    481  03b4		       a4 82		      ldy	CUROFF
    482  03b6		       d0 ef		      bne	iPRS2
    483  03b8		       c8	   PRSend     iny		;skip closing quote
    484  03b9		       84 82		      sty	CUROFF
    485  03bb		       4c a9 02    PRSend2    jmp	NextIL
    486  03be							;
    487  03be							;=====================================================
    488  03be							; Pop the top off the stack and print it as a signed
    489  03be							; decimal number.
    490  03be							;
    491  03be		       20 4d 0b    iPRN       jsr	popR0
    492  03c1		       20 ad 09 	      jsr	PrintDecimal
    493  03c4		       4c a9 02 	      jmp	NextIL
    494  03c7							;
    495  03c7							;=====================================================
    496  03c7							; Space to next zone.	Currently the code does not
    497  03c7							; keep track of which column the output is on, so
    498  03c7							; just print a tab.
    499  03c7							;
    500  03c7		       a9 09	   iSPC       lda	#TAB
    501  03c9		       20 06 02 	      jsr	OUTCH
    502  03cc		       4c a9 02 	      jmp	NextIL
    503  03cf							;
    504  03cf							;=====================================================
    505  03cf							; If in immediate mode, jump to the address following
    506  03cf							; the NXT instruction.  Else move to the next line of
    507  03cf							; user code and continue.
    508  03cf							;
    509  03cf		       a5 89	   iNXT       lda	RunMode
    510  03d1		       d0 03		      bne	iNxtRun	;in run mode
    511  03d3							;
    512  03d3							; Get address and jump to it.
    513  03d3							;
    514  03d3		       4c ef 06 	      jmp	iJMP
    515  03d6							;
    516  03d6		       20 89 09    iNxtRun    jsr	FindNextLine
    517  03d9		       20 a0 09 	      jsr	AtEnd
    518  03dc		       d0 03		      bne	iNxtRun2	;not at end
    519  03de							;
    520  03de							; At the end of the program.  Pretend an END statement
    521  03de							; was found.
    522  03de							;
    523  03de		       4c 82 04    iFINv      jmp	iFIN
    524  03e1							;
    525  03e1		       20 ff 08    iNxtRun2   jsr	getILWord	;ignore next word
    526  03e4		       4c a9 02 	      jmp	NextIL
    527  03e7							;
    528  03e7							;=====================================================
    529  03e7							; XFER takes the number on top of the stack and looks
    530  03e7							; for that line in the program, or the next line
    531  03e7							; higher.  Ie, if it's 1 but there is no line 1, then
    532  03e7							; find the next one after that.
    533  03e7							;
    534  03e7		       20 4d 0b    iXFER      jsr	popR0
    535  03ea		       20 46 09 	      jsr	findLine
    536  03ed		       20 a0 09    iXFER2     jsr	AtEnd	;at end of user program?
    537  03f0		       f0 ec		      beq	iFINv
    538  03f2		       a0 02		      ldy	#2	;point to start of text
    539  03f4		       84 82		      sty	CUROFF
    540  03f6		       a9 ff		      lda	#$ff
    541  03f8		       85 89		      sta	RunMode
    542  03fa							;
    543  03fa							; Transfer IL to STMT.  I don't like having this
    544  03fa							; hard-coded; fix it.
    545  03fa							;
    546  03fa		       a9 ee		      lda	#STMT&$ff
    547  03fc		       85 75		      sta	ILPC
    548  03fe		       a9 0d		      lda	#STMT>>8
    549  0400		       85 76		      sta	ILPC+1
    550  0402		       4c a9 02 	      jmp	NextIL
    551  0405							;
    552  0405							; Run
    553  0405							;
    554  0405				   iXferok
    555  0405		       a9 ff		      lda	#$ff
    556  0407		       85 89		      sta	RunMode	;we're running
    557  0409							;
    558  0409							; Need a more elegant way to do this
    559  0409							;
    560  0409		       a9 ee		      lda	#STMT&$ff
    561  040b		       85 75		      sta	ILPC
    562  040d		       a9 0d		      lda	#STMT>>8
    563  040f		       85 76		      sta	ILPC+1
    564  0411		       4c a9 02 	      jmp	NextIL
    565  0414							;
    566  0414							;=====================================================
    567  0414							; Save the pointer to the next line to the call stack.
    568  0414							;
    569  0414				   iSAV
    570  0414		       20 27 0b 	      jsr	pushLN
    571  0417		       4c a9 02 	      jmp	NextIL
    572  041a
    573  041a							;
    574  041a							;=====================================================
    575  041a							; Pop the next line from the call stack.
    576  041a							;
    577  041a				   iRSTR
    578  041a		       20 60 0b 	      jsr	popLN
    579  041d		       4c a9 02 	      jmp	NextIL
    580  0420							;jmp	ILbad
    581  0420							;
    582  0420							;=====================================================
    583  0420							; Compare items on stack.  Okay, so on input there are
    584  0420							; three things on the stack
    585  0420							;
    586  0420							;    EXPR2 <- Top of stack
    587  0420							;    OP    <- relational operator, next on stack
    588  0420							;    EXPR1 <- last item on stack
    589  0420							;
    590  0420							; Comparison is: EXPR1 <operator> EXPR2
    591  0420							;
    592  0420							; Operator is one of...
    593  0420							;
    594  0420							;    2 is =
    595  0420							;    1 is <
    596  0420							;    3 is <=
    597  0420							;    5 is <>
    598  0420							;    4 is >
    599  0420							;    6 is >=
    600  0420							;
    601  0420							; Those are bit-mapped:
    602  0420							;
    603  0420							;    xxxxxGEL
    604  0420							;
    605  0420							;    G = Greater than
    606  0420							;    E = Equal
    607  0420							;    L = Less than
    608  0420							;
    609  0420							; If the comparison is false, do a NXT, ie, move to the
    610  0420							; next line and continue.  If true, continue executing
    611  0420							; on this line.
    612  0420							;
    613  0420		       00 01	   REL_LT     equ	%001
    614  0420		       00 02	   REL_EQUAL  equ	%010
    615  0420		       00 04	   REL_GT     equ	%100
    616  0420							;
    617  0420		       20 73 0b    iCMPR      jsr	popR1
    618  0423		       20 86 0b 	      jsr	popMQ	;operator in MQ
    619  0426		       20 4d 0b 	      jsr	popR0
    620  0429							;
    621  0429							; See if they are equal or not
    622  0429							;
    623  0429		       a5 85		      lda	R0
    624  042b		       c5 87		      cmp	R1
    625  042d		       d0 0a		      bne	iCMPRnoteq	;try not equal
    626  042f		       a5 86		      lda	R0+1
    627  0431		       c5 88		      cmp	R1+1
    628  0433		       d0 04		      bne	iCMPRnoteq
    629  0435							;
    630  0435							; Equal, set the flag in MQ+1
    631  0435							;
    632  0435		       a9 02		      lda	#REL_EQUAL
    633  0437		       d0 14		      bne	iCMPcom
    634  0439							;
    635  0439							; See if EXPR1 (R0) < EXPR2 (R1)
    636  0439							; See www.6502.org/tutorials/compare_beyond.html
    637  0439							;
    638  0439		       a5 85	   iCMPRnoteq lda	R0
    639  043b		       c5 87		      cmp	R1
    640  043d		       a5 86		      lda	R0+1
    641  043f		       e5 88		      sbc	R1+1
    642  0441		       50 02		      bvc	iCMPR_2
    643  0443		       49 80		      eor	#$80
    644  0445		       30 04	   iCMPR_2    bmi	iCMPlt
    645  0447		       a9 04		      lda	#REL_GT
    646  0449		       d0 02		      bne	iCMPcom
    647  044b		       a9 01	   iCMPlt     lda	#REL_LT	;R0 < R1
    648  044d		       0d 12 11    iCMPcom    ora	MQ+1
    649  0450							;
    650  0450							; Now compare the end result with what the caller
    651  0450							; was looking for.
    652  0450							;
    653  0450		       2d 11 11 	      and	MQ
    654  0453		       f0 07		      beq	iCMPno	;no match
    655  0455		       4c a9 02 	      jmp	NextIL
    656  0458							;
    657  0458							; R0 > R1
    658  0458							;
    659  0458		       a9 04	   iCMPgt     lda	#REL_GT
    660  045a		       d0 f1		      bne	iCMPcom
    661  045c							;
    662  045c							; Not a match, so jump to the next line of code.
    663  045c							;
    664  045c		       20 89 09    iCMPno     jsr	FindNextLine
    665  045f		       4c ed 03 	      jmp	iXFER2
    666  0462							;
    667  0462							;=====================================================
    668  0462							; Get a line of text from the user, convert to a
    669  0462							; number, leave on top of stack.
    670  0462							;
    671  0462		       a5 82	   iINNUM     lda	CUROFF	;save state before GetLine
    672  0464		       48		      pha
    673  0465		       a5 81		      lda	CURPTR+1
    674  0467		       48		      pha
    675  0468		       a5 80		      lda	CURPTR
    676  046a		       48		      pha
    677  046b							;
    678  046b		       a9 3f		      lda	#'?
    679  046d		       20 90 0a 	      jsr	GetLine
    680  0470		       20 19 0a 	      jsr	getDecimal
    681  0473		       20 14 0b 	      jsr	pushR0	;put onto stack
    682  0476							;
    683  0476		       68		      pla
    684  0477		       85 80		      sta	CURPTR
    685  0479		       68		      pla
    686  047a		       85 81		      sta	CURPTR+1
    687  047c		       68		      pla
    688  047d		       85 82		      sta	CUROFF
    689  047f							;
    690  047f		       4c a9 02 	      jmp	NextIL
    691  0482							;
    692  0482
    693  0482							;
    694  0482							;=====================================================
    695  0482							; Stop the currently running program.	Actually very
    696  0482							; simple to do... clear the RunMode flag, then set the
    697  0482							; ILPC to the standard handler and continue running.
    698  0482							;
    699  0482		       a9 00	   iFIN       lda	#0
    700  0484		       85 89		      sta	RunMode
    701  0486							;
    702  0486		       ad 0f 11 	      lda	errGoto
    703  0489		       85 75		      sta	ILPC
    704  048b		       ad 10 11 	      lda	errGoto+1
    705  048e		       85 76		      sta	ILPC+1
    706  0490		       4c a9 02 	      jmp	NextIL
    707  0493							;
    708  0493							;=====================================================
    709  0493							; Handle the ERR opcode.  Following the instruction is
    710  0493							; a 16 bit error number.  Print an error message, and
    711  0493							; if we're in run mode, print the line number.  Stop
    712  0493							; program execution and return to the initial state.
    713  0493							;
    714  0493		       20 ff 08    iERR       jsr	getILWord	;get err code
    715  0496							;
    716  0496							; Enter here with the error code in X (LSB) and A (MSB).
    717  0496							;
    718  0496		       86 85	   iErr2      stx	R0
    719  0498		       85 86		      sta	R0+1
    720  049a							;
    721  049a		       20 12 f0 	      jsr	puts
      0  049d					      db	"Error ",0
      1  049d		       45 72 72 6f*	      .byte.b	"Error ",0
    723  04a4		       20 ad 09 	      jsr	PrintDecimal
    724  04a7							;
    725  04a7		       a5 89		      lda	RunMode	;running?
    726  04a9		       f0 1b		      beq	iERR2	;nope
    727  04ab		       20 12 f0 	      jsr	puts
      0  04ae					      db	" at line ",0
      1  04ae		       20 61 74 20*	      .byte.b	" at line ",0
    729  04b8		       a0 00		      ldy	#0
    730  04ba		       b1 80		      lda	(CURPTR),y
    731  04bc		       85 85		      sta	R0
    732  04be		       c8		      iny
    733  04bf		       b1 80		      lda	(CURPTR),y
    734  04c1		       85 86		      sta	R0+1
    735  04c3		       20 ad 09 	      jsr	PrintDecimal
    736  04c6							;
    737  04c6		       20 0c 02    iERR2      jsr	CRLF
    738  04c9		       a9 00		      lda	#0
    739  04cb		       85 89		      sta	RunMode	;fall through...
    740  04cd							;
    741  04cd							;=====================================================
    742  04cd							; Reset the IL to be back at the idle loop.  Does not
    743  04cd							; clear variables so the user can see what state
    744  04cd							; the program is in.
    745  04cd							;
    746  04cd		       a9 00	   ResetIL    lda	#0
    747  04cf		       8d 91 10 	      sta	retStackPtr
    748  04d2		       ad 0f 11 	      lda	errGoto
    749  04d5		       85 75		      sta	ILPC
    750  04d7		       ad 10 11 	      lda	errGoto+1
    751  04da		       85 76		      sta	ILPC+1
    752  04dc		       4c a9 02 	      jmp	NextIL
    753  04df							;
    754  04df							;=====================================================
    755  04df							; Pop two items off stack, add them, then place the
    756  04df							; result back onto the stack.
    757  04df							;
    758  04df		       20 4d 0b    iADD       jsr	popR0
    759  04e2		       20 73 0b 	      jsr	popR1
    760  04e5		       18		      clc
    761  04e6		       a5 85		      lda	R0
    762  04e8		       65 87		      adc	R1
    763  04ea		       85 85		      sta	R0
    764  04ec		       a5 86		      lda	R0+1
    765  04ee		       65 88		      adc	R1+1
    766  04f0		       85 86		      sta	R0+1
    767  04f2		       4c 57 05 	      jmp	pushR0nextIl
    768  04f5							;
    769  04f5							;=====================================================
    770  04f5							; Pop two items off the stack.  Subtract the top of
    771  04f5							; stack from the lower entry.
    772  04f5							;
    773  04f5		       20 73 0b    iSUB       jsr	popR1
    774  04f8		       20 4d 0b 	      jsr	popR0
    775  04fb		       38		      sec
    776  04fc		       a5 85		      lda	R0
    777  04fe		       e5 87		      sbc	R1
    778  0500		       85 85		      sta	R0
    779  0502		       a5 86		      lda	R0+1
    780  0504		       e5 88		      sbc	R1+1
    781  0506		       85 86		      sta	R0+1
    782  0508		       4c 57 05 	      jmp	pushR0nextIl
    783  050b							;
    784  050b							;=====================================================
    785  050b							; Negate the top of stack.
    786  050b							;
    787  050b		       20 4d 0b    iNEG       jsr	popR0
    788  050e		       a5 85		      lda	R0
    789  0510		       49 ff		      eor	#$ff
    790  0512		       85 85		      sta	R0
    791  0514		       a5 86		      lda	R0+1
    792  0516		       49 ff		      eor	#$ff
    793  0518		       85 86		      sta	R0+1
    794  051a		       e6 85		      inc	R0
    795  051c		       d0 02		      bne	iNEG2
    796  051e		       e6 86		      inc	R0+1
    797  0520		       4c 57 05    iNEG2      jmp	pushR0nextIl
    798  0523							;
    799  0523							;=====================================================
    800  0523							; Multiply top two items on the stack, put the results
    801  0523							; on top.  This uses the algorithm documented on page
    802  0523							; 115 of "Microprocessor Programming for Computer
    803  0523							; Hobbyists" by Neill Graham.
    804  0523							;
    805  0523		       20 4d 0b    iMUL       jsr	popR0	;AC
    806  0526		       20 73 0b 	      jsr	popR1	;OP
    807  0529							;
    808  0529		       a5 85		      lda	R0
    809  052b		       8d 11 11 	      sta	MQ
    810  052e		       a5 86		      lda	R0+1
    811  0530		       8d 12 11 	      sta	MQ+1
    812  0533		       a9 00		      lda	#0	;clear result
    813  0535		       85 85		      sta	R0
    814  0537		       85 86		      sta	R0+1
    815  0539							;
    816  0539		       a2 10		      ldx	#16	;number of bits in value
    817  053b		       06 85	   multloop   asl	R0
    818  053d		       26 86		      rol	R0+1
    819  053f		       0e 11 11 	      asl	MQ
    820  0542		       2e 12 11 	      rol	MQ+1
    821  0545		       90 0d		      bcc	multno	;skip add if no carry
    822  0547							;
    823  0547							; Add R1 back into R0
    824  0547							;
    825  0547		       18		      clc
    826  0548		       a5 85		      lda	R0
    827  054a		       65 87		      adc	R1
    828  054c		       85 85		      sta	R0
    829  054e		       a5 86		      lda	R0+1
    830  0550		       65 88		      adc	R1+1
    831  0552		       85 86		      sta	R0+1
    832  0554							;
    833  0554		       ca	   multno     dex		;did all bits yet?
    834  0555		       d0 e4		      bne	multloop
    835  0557							;
    836  0557				   pushR0nextIl
    837  0557		       20 14 0b 	      jsr	pushR0	;OP
    838  055a		       4c a9 02 	      jmp	NextIL
    839  055d							;
    840  055d							;=====================================================
    841  055d							; Divide the top of stack into the next to top item.
    842  055d							; Leave results on stack.  Taken from:
    843  055d							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
    844  055d							;
    845  055d							; MQ = R0 / R1
    846  055d							; Remainder is in R0
    847  055d							;
    848  055d		       20 73 0b    iDIV       jsr	popR1
    849  0560		       20 4d 0b 	      jsr	popR0
    850  0563							;
    851  0563							; Check for divide by zero
    852  0563							;
    853  0563		       a5 87		      lda	R1
    854  0565		       05 88		      ora	R1+1
    855  0567		       f0 36		      beq	divby0
    856  0569							;
    857  0569		       20 9b 0b 	      jsr	SaveSigns
    858  056c		       a9 00		      lda	#0	;preset remainder to 0
    859  056e		       8d 11 11 	      sta	MQ
    860  0571		       8d 12 11 	      sta	MQ+1
    861  0574		       a2 10		      ldx	#16	;repeat for each bit: ...
    862  0576
    863  0576		       06 85	   divloop    asl	R0	;dividend lb & hb*2, msb -> Carry
    864  0578		       26 86		      rol	R0+1
    865  057a		       2e 11 11 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
    866  057d		       2e 12 11 	      rol	MQ+1
    867  0580		       ad 11 11 	      lda	MQ
    868  0583		       38		      sec
    869  0584		       e5 87		      sbc	R1	;substract divisor to see if it fits in
    870  0586		       a8		      tay		;lb result -> Y, for we may need it later
    871  0587		       ad 12 11 	      lda	MQ+1
    872  058a		       e5 88		      sbc	R1+1
    873  058c		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
    874  058e
    875  058e		       8d 12 11 	      sta	MQ+1	;else save substraction result as new remainder,
    876  0591		       8c 11 11 	      sty	MQ
    877  0594		       e6 85		      inc	R0	;and INCrement result cause divisor fit in 1 times
    878  0596
    879  0596		       ca	   skip       dex
    880  0597		       d0 dd		      bne	divloop
    881  0599		       20 d6 0b 	      jsr	RestoreSigns
    882  059c		       4c 57 05 	      jmp	pushR0nextIl
    883  059f							;
    884  059f							; Indicate divide-by-zero error
    885  059f							;
    886  059f		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
    887  05a1		       a9 00		      lda	#0
    888  05a3		       4c 96 04 	      jmp	iErr2
    889  05a6							;
    890  05a6							;=====================================================
    891  05a6							; This pops the top two items off the stack.  The top
    892  05a6							; item is a data value and the other is an index into
    893  05a6							; the variable table.	Save the value into that entry.
    894  05a6							;
    895  05a6		       20 4d 0b    iSTORE     jsr	popR0	;data
    896  05a9		       20 73 0b 	      jsr	popR1	;index
    897  05ac		       a6 87		      ldx	R1	;get index
    898  05ae		       a5 85		      lda	R0
    899  05b0		       95 41		      sta	variables,x
    900  05b2		       a5 86		      lda	R0+1
    901  05b4		       95 42		      sta	variables+1,x
    902  05b6		       4c a9 02 	      jmp	NextIL
    903  05b9							;
    904  05b9							;=====================================================
    905  05b9							; Replaces the top of stack with the variable whose
    906  05b9							; index it represents.
    907  05b9							;
    908  05b9		       20 73 0b    iIND       jsr	popR1
    909  05bc		       a6 87		      ldx	R1	;get index
    910  05be		       b5 41		      lda	variables,x
    911  05c0		       85 85		      sta	R0
    912  05c2		       b5 42		      lda	variables+1,x
    913  05c4		       85 86		      sta	R0+1
    914  05c6		       4c 57 05 	      jmp	pushR0nextIl
    915  05c9							;
    916  05c9							;=====================================================
    917  05c9							; List the current BASIC program in memory.  Uses R0,
    918  05c9							; tempIly, and dpl.
    919  05c9							;
    920  05c9		       20 86 0c    iLST       jsr	SetOutConsole
    921  05cc		       a9 21	   iLST2      lda	#ProgramStart&$ff
    922  05ce		       85 77		      sta	dpl
    923  05d0		       a9 11		      lda	#ProgramStart>>8
    924  05d2		       85 78		      sta	dpl+1
    925  05d4							;
    926  05d4							; dpl/dph point to the current line.  See if we're at
    927  05d4							; the end of the program.
    928  05d4							;
    929  05d4		       a5 77	   iLSTloop   lda	dpl
    930  05d6		       cd 19 11 	      cmp	PROGRAMEND
    931  05d9		       d0 07		      bne	iLstNotEnd
    932  05db		       a5 78		      lda	dpl+1
    933  05dd		       cd 1a 11 	      cmp	PROGRAMEND+1
    934  05e0		       f0 40		      beq	iLstdone
    935  05e2							;
    936  05e2		       a0 00	   iLstNotEnd ldy	#0
    937  05e4		       b1 77		      lda	(dpl),y	;line number LSB
    938  05e6		       85 85		      sta	R0
    939  05e8		       c8		      iny
    940  05e9		       b1 77		      lda	(dpl),y	;line number MSB
    941  05eb		       85 86		      sta	R0+1
    942  05ed		       c8		      iny
    943  05ee		       84 7b		      sty	tempIlY
    944  05f0		       20 ad 09 	      jsr	PrintDecimal
    945  05f3		       a9 20		      lda	#SPACE
    946  05f5		       20 91 0c 	      jsr	VOUTCH
    947  05f8		       a4 7b		      ldy	tempIlY
    948  05fa		       b1 77	   iLSTl2     lda	(dpl),y
    949  05fc		       f0 0a		      beq	iLST3	;end of this line
    950  05fe		       84 7b		      sty	tempIlY
    951  0600		       20 91 0c 	      jsr	VOUTCH
    952  0603		       a4 7b		      ldy	tempIlY
    953  0605		       c8		      iny
    954  0606		       d0 f2		      bne	iLSTl2	;do next char
    955  0608							;
    956  0608							; End of this line.  Print CR/LF, then move to the
    957  0608							; next line.
    958  0608							;
    959  0608		       c8	   iLST3      iny
    960  0609		       18		      clc
    961  060a		       98		      tya
    962  060b		       65 77		      adc	dpl
    963  060d		       85 77		      sta	dpl
    964  060f		       a5 78		      lda	dpl+1
    965  0611		       69 00		      adc	#0
    966  0613		       85 78		      sta	dpl+1
    967  0615							;
    968  0615							; Have to manually do CR/LF so it uses the vectored
    969  0615							; output function.
    970  0615							;
    971  0615		       a9 0d		      lda	#CR
    972  0617		       20 91 0c 	      jsr	VOUTCH
    973  061a		       a9 0a		      lda	#LF
    974  061c		       20 91 0c 	      jsr	VOUTCH
    975  061f		       4c d4 05 	      jmp	iLSTloop	;do next line
    976  0622							;
    977  0622		       20 86 0c    iLstdone   jsr	SetOutConsole
    978  0625		       4c a9 02 	      jmp	NextIL
    979  0628							;
    980  0628							;=====================================================
    981  0628							; Get a line of text into LINBUF.  Terminate with a
    982  0628							; null byte.
    983  0628							;
    984  0628		       a9 3e	   iGETLINE   lda	#'>	;prompt character
    985  062a		       20 90 0a 	      jsr	GetLine
    986  062d							;
    987  062d		       a9 00		      lda	#0
    988  062f		       85 89		      sta	RunMode
    989  0631		       4c a9 02 	      jmp	NextIL
    990  0634							;
    991  0634							;=====================================================
    992  0634							; This is called when the input buffer contains a line
    993  0634							; typed in by the user that starts with a line number.
    994  0634							; Insert the line into the program or delete the line
    995  0634							; if there is nothing after the line number,
    996  0634							;
    997  0634		       a0 00	   iINSRT     ldy	#0
    998  0636		       20 19 0a 	      jsr	getDecimal	;convert line #
    999  0639		       20 05 0c 	      jsr	SkipSpaces
   1000  063c		       84 7c		      sty	offset	;save for now
   1001  063e							;
   1002  063e							; Now find the line OR the next higher line OR the
   1003  063e							; end of the program.
   1004  063e							;
   1005  063e		       20 46 09 	      jsr	findLine
   1006  0641							;
   1007  0641							; If the line exists, it needs to be removed.
   1008  0641							;
   1009  0641		       d0 3d		      bne	insert2	;jump if not found
   1010  0643							;
   1011  0643							; Get length of line to be removed
   1012  0643							;
   1013  0643		       20 f7 0a 	      jsr	getCURPTRLength	;results in Y
   1014  0646		       84 7d		      sty	lineLength
   1015  0648							;
   1016  0648							; Compute the new end of the program first.
   1017  0648							;
   1018  0648		       38		      sec
   1019  0649		       ad 19 11 	      lda	PROGRAMEND
   1020  064c		       e5 7d		      sbc	lineLength
   1021  064e		       8d 19 11 	      sta	PROGRAMEND
   1022  0651		       ad 1a 11 	      lda	PROGRAMEND+1
   1023  0654		       e9 00		      sbc	#0
   1024  0656		       8d 1a 11 	      sta	PROGRAMEND+1
   1025  0659							;
   1026  0659							; Copy CURPTR into R1 for working
   1027  0659							;
   1028  0659		       a5 80		      lda	CURPTR
   1029  065b		       85 87		      sta	R1
   1030  065d		       a5 81		      lda	CURPTR+1
   1031  065f		       85 88		      sta	R1+1
   1032  0661							;
   1033  0661							; See if we're at the end.
   1034  0661							;
   1035  0661		       a5 87	   InsDelChk  lda	R1
   1036  0663		       cd 19 11 	      cmp	PROGRAMEND
   1037  0666		       d0 07		      bne	InsDelLoop
   1038  0668		       a5 88		      lda	R1+1
   1039  066a		       cd 1a 11 	      cmp	PROGRAMEND+1
   1040  066d		       f0 11		      beq	insert2
   1041  066f							;
   1042  066f							; Move one byte, move to next location.
   1043  066f							;
   1044  066f		       a4 7d	   InsDelLoop ldy	lineLength
   1045  0671		       b1 87		      lda	(R1),y
   1046  0673		       a0 00		      ldy	#0
   1047  0675		       91 87		      sta	(R1),y
   1048  0677		       e6 87		      inc	R1
   1049  0679		       d0 e6		      bne	InsDelChk
   1050  067b		       e6 88		      inc	R1+1
   1051  067d		       4c 61 06 	      jmp	InsDelChk
   1052  0680							;
   1053  0680							; Deletion is done.
   1054  0680							; If the new line is empty we're done.
   1055  0680							;
   1056  0680		       a4 7c	   insert2    ldy	offset	;get back ptr
   1057  0682		       b9 bb 10 	      lda	LINBUF,y	;next byte
   1058  0685		       f0 56		      beq	mvUpFini	;empty line
   1059  0687							;
   1060  0687							; CURPTR points to where the line will be inserted.
   1061  0687							;
   1062  0687		       20 e6 0a 	      jsr	getLineLength	;get bytes needed
   1063  068a							;
   1064  068a		       ad 19 11 	      lda	PROGRAMEND
   1065  068d		       85 8a		      sta	FROM
   1066  068f		       ad 1a 11 	      lda	PROGRAMEND+1
   1067  0692		       85 8b		      sta	FROM+1
   1068  0694							;
   1069  0694		       a0 00	   mvup1      ldy	#0
   1070  0696		       b1 8a		      lda	(FROM),y
   1071  0698		       a4 7d		      ldy	lineLength
   1072  069a		       91 8a		      sta	(FROM),y
   1073  069c							;
   1074  069c		       a5 8a		      lda	FROM
   1075  069e		       c5 80		      cmp	CURPTR
   1076  06a0		       d0 06		      bne	mvUpMore
   1077  06a2		       a5 8b		      lda	FROM+1
   1078  06a4		       c5 81		      cmp	CURPTR+1
   1079  06a6		       f0 0b		      beq	mvUpDone
   1080  06a8							;
   1081  06a8							; Not done yet
   1082  06a8							;
   1083  06a8		       a5 8a	   mvUpMore   lda	FROM	;decrement FROM
   1084  06aa		       d0 02		      bne	mvUpMore2
   1085  06ac		       c6 8b		      dec	FROM+1
   1086  06ae		       c6 8a	   mvUpMore2  dec	FROM
   1087  06b0		       4c 94 06 	      jmp	mvup1
   1088  06b3							;
   1089  06b3							; All done with copy.
   1090  06b3							;
   1091  06b3		       18	   mvUpDone   clc
   1092  06b4		       a5 7d		      lda	lineLength
   1093  06b6		       6d 19 11 	      adc	PROGRAMEND
   1094  06b9		       8d 19 11 	      sta	PROGRAMEND
   1095  06bc		       ad 1a 11 	      lda	PROGRAMEND+1
   1096  06bf		       69 00		      adc	#0
   1097  06c1		       8d 1a 11 	      sta	PROGRAMEND+1
   1098  06c4							;
   1099  06c4		       a0 00		      ldy	#0	;copy line number first
   1100  06c6		       a5 85		      lda	R0
   1101  06c8		       91 80		      sta	(CURPTR),y
   1102  06ca		       c8		      iny
   1103  06cb		       a5 86		      lda	R0+1
   1104  06cd		       91 80		      sta	(CURPTR),y
   1105  06cf		       c8		      iny
   1106  06d0							;
   1107  06d0		       a6 7c		      ldx	offset
   1108  06d2		       bd bb 10    mvUpLoop2  lda	LINBUF,x
   1109  06d5		       91 80		      sta	(CURPTR),y
   1110  06d7		       f0 04		      beq	mvUpFini
   1111  06d9		       e8		      inx
   1112  06da		       c8		      iny
   1113  06db		       d0 f5		      bne	mvUpLoop2
   1114  06dd							;
   1115  06dd		       4c a9 02    mvUpFini   jmp	NextIL
   1116  06e0							;
   1117  06e0							;=====================================================
   1118  06e0							; Pops the top value of the ILPC stack and stores it
   1119  06e0							; in ILPC.  Ie, return from an IL subroutine.
   1120  06e0							;
   1121  06e0		       20 33 09    iRTN       jsr	popILPC
   1122  06e3		       4c a9 02 	      jmp	NextIL
   1123  06e6							;
   1124  06e6							;=====================================================
   1125  06e6							; NLINE print a newline
   1126  06e6							;
   1127  06e6		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1128  06e9		       4c a9 02 	      jmp	NextIL
   1129  06ec							;
   1130  06ec							;=====================================================
   1131  06ec							; This saves the current ILPC value on the stack, then
   1132  06ec							; jumps to the address specified by the next two bytes.
   1133  06ec							;
   1134  06ec		       20 19 09    iCALL      jsr	pushILPC	;save ILPC
   1135  06ef							;
   1136  06ef							; Jmp to a specific location in the IL code.  The new
   1137  06ef							; address immediately follows the opcode.
   1138  06ef							;
   1139  06ef		       20 ff 08    iJMP       jsr	getILWord
   1140  06f2		       86 75		      stx	ILPC
   1141  06f4		       85 76		      sta	ILPC+1
   1142  06f6		       4c a9 02 	      jmp	NextIL
   1143  06f9							;
   1144  06f9							;=====================================================
   1145  06f9							; Push the next two bytes onto the arithmetic stack.
   1146  06f9							;
   1147  06f9		       20 ff 08    iLIT       jsr	getILWord
   1148  06fc		       86 85		      stx	R0
   1149  06fe		       85 86		      sta	R0+1
   1150  0700		       20 14 0b 	      jsr	pushR0
   1151  0703		       4c a9 02 	      jmp	NextIL
   1152  0706							;
   1153  0706							;=====================================================
   1154  0706							; Initialize all variables.  Ie, set to zero.
   1155  0706							;
   1156  0706		       a9 00	   iVINIT     lda	#0
   1157  0708		       a2 00		      ldx	#0
   1158  070a		       95 41	   Vinit2     sta	variables,x
   1159  070c		       e8		      inx
   1160  070d		       e0 34		      cpx	#variablesEnd-variables
   1161  070f		       d0 f9		      bne	Vinit2
   1162  0711		       4c a9 02 	      jmp	NextIL
   1163  0714							;
   1164  0714							;=====================================================
   1165  0714							; Set the address of the error handler.  After any
   1166  0714							; error, set to the ILPC to the specified location.
   1167  0714							;
   1168  0714		       20 ff 08    iERRGOTO   jsr	getILWord
   1169  0717		       8e 0f 11 	      stx	errGoto
   1170  071a		       8d 10 11 	      sta	errGoto+1
   1171  071d		       4c a9 02 	      jmp	NextIL
   1172  0720							;
   1173  0720							;=====================================================
   1174  0720							; TST is followed by an 8 bit signed offset, then a
   1175  0720							; null terminated string.  Compare the string against
   1176  0720							; the string starting at (CURPTR),CUROFF.  If the
   1177  0720							; strings match, continue executing the next IL
   1178  0720							; opcode.  Else, add the offset to ILPC.
   1179  0720							;
   1180  0720		       20 03 09    iTST       jsr	getILByte
   1181  0723		       85 7c		      sta	offset
   1182  0725							;
   1183  0725		       20 02 0b 	      jsr	saveIL	;in case of failure
   1184  0728		       a4 82		      ldy	CUROFF
   1185  072a		       84 77		      sty	dpl	;save for later
   1186  072c							;
   1187  072c		       20 03 09    iTSTloop   jsr	getILByte	;get next char
   1188  072f		       f0 11		      beq	iTSTm	;match!
   1189  0731		       a4 77		      ldy	dpl
   1190  0733		       d1 80		      cmp	(CURPTR),y
   1191  0735		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1192  0737		       09 20		      ora	#$20	; lets allow lowercase as well
   1193  0739		       d1 80		      cmp	(CURPTR),y
   1194  073b		       d0 0c		      bne	iTSTfail	;mismatch
   1195  073d		       c8	   iTSTUpper  iny
   1196  073e		       84 77		      sty	dpl
   1197  0740		       d0 ea		      bne	iTSTloop
   1198  0742							;
   1199  0742							; It's a match!  Clean up a bit.
   1200  0742							;
   1201  0742		       a4 77	   iTSTm      ldy	dpl
   1202  0744		       84 82		      sty	CUROFF
   1203  0746		       4c a9 02 	      jmp	NextIL
   1204  0749							;
   1205  0749							; Not a match, reset ILPC and then move to the
   1206  0749							; offset.
   1207  0749							;
   1208  0749		       20 0b 0b    iTSTfail   jsr	restoreIL
   1209  074c		       4c f0 07 	      jmp	tstBranch
   1210  074f							;
   1211  074f							;=================================================JLIT=
   1212  074f							; Test if we have a let statement without the let keyword
   1213  074f		       20 03 09    iTSTLET    jsr	getILByte
   1214  0752		       85 7c		      sta	offset
   1215  0754		       20 02 0b 	      jsr	saveIL	; save to restore when done
   1216  0757
   1217  0757		       a4 82		      ldy	CUROFF
   1218  0759		       20 05 0c 	      jsr	SkipSpaces
   1219  075c		       c8		      iny		; skip the Variable name
   1220  075d		       20 05 0c 	      jsr	SkipSpaces	; skip any SkipSpaces
   1221  0760		       b1 80		      lda	(CURPTR),y	; Get what should be an equal sign
   1222  0762		       c9 3d		      cmp	#'=	; check if equals
   1223  0764		       d0 e3		      bne	iTSTfail	; return it failed
   1224  0766		       20 0b 0b 	      jsr	restoreIL	; restore the IL anyway
   1225  0769		       4c a9 02 	      jmp	NextIL	; Then next instruction
   1226  076c							;
   1227  076c							;================================================jLIT=
   1228  076c							;Test for end of line
   1229  076c							;
   1230  076c		       20 03 09    iTSTDONE   jsr	getILByte
   1231  076f		       85 7c		      sta	offset
   1232  0771		       20 02 0b 	      jsr	saveIL
   1233  0774
   1234  0774		       a4 82		      ldy	CUROFF
   1235  0776		       84 77		      sty	dpl
   1236  0778		       20 05 0c 	      jsr	SkipSpaces
   1237  077b		       b1 80		      lda	(CURPTR),y
   1238  077d		       f0 07		      beq	iTSTDONEtrue
   1239  077f		       a4 77		      ldy	dpl
   1240  0781		       84 82		      sty	CUROFF
   1241  0783		       4c 49 07 	      jmp	iTSTfail
   1242  0786							;
   1243  0786							; Advance to the next line
   1244  0786							;
   1245  0786		       4c a9 02    iTSTDONEtrue jmp	NextIL
   1246  0789							;
   1247  0789							;=====================================================
   1248  0789							; TSTV is followed by an 8 bit signed offset.	If the
   1249  0789							; value at (CURPTR),CUROFF appears to be a variable
   1250  0789							; name, move to the next IL statement.  Else, add the
   1251  0789							; offset to ILPC.
   1252  0789							;
   1253  0789		       20 03 09    iTSTV      jsr	getILByte	;offset
   1254  078c		       85 7c		      sta	offset
   1255  078e							;
   1256  078e		       a4 82		      ldy	CUROFF
   1257  0790		       20 05 0c 	      jsr	SkipSpaces
   1258  0793		       b1 80		      lda	(CURPTR),y
   1259  0795							;
   1260  0795		       09 20		      ora	#$20	;make lower then upper
   1261  0797		       49 20		      eor	#$20	;allow lower case here
   1262  0799		       c9 41		      cmp	#'A
   1263  079b		       90 53		      bcc	tstBranch
   1264  079d		       c9 5b		      cmp	#'Z+1
   1265  079f		       b0 4f		      bcs	tstBranch
   1266  07a1							;
   1267  07a1							; The condition is true, so convert to an index, push
   1268  07a1							; it onto the stack and continue running.
   1269  07a1							;
   1270  07a1		       38		      sec
   1271  07a2		       e9 41		      sbc	#'A	;index is zero based
   1272  07a4		       0a		      asl		;multiply by two
   1273  07a5		       85 85		      sta	R0
   1274  07a7		       a9 00		      lda	#0
   1275  07a9		       85 86		      sta	R0+1
   1276  07ab		       20 14 0b 	      jsr	pushR0	;put index onto stack
   1277  07ae		       e6 82		      inc	CUROFF	;move to next input char
   1278  07b0		       4c a9 02 	      jmp	NextIL
   1279  07b3							;
   1280  07b3							;=====================================================
   1281  07b3							; TSTL seems basically the same as TSTN, but leave the
   1282  07b3							; value in R0 instead of pushing onto stack.
   1283  07b3							;
   1284  07b3		       20 03 09    iTSTL      jsr	getILByte
   1285  07b6		       85 7c		      sta	offset
   1286  07b8							;
   1287  07b8		       a4 82		      ldy	CUROFF
   1288  07ba		       20 05 0c 	      jsr	SkipSpaces
   1289  07bd		       b1 80		      lda	(CURPTR),y
   1290  07bf							;
   1291  07bf		       c9 30		      cmp	#'0
   1292  07c1		       90 2d		      bcc	tstBranch
   1293  07c3		       c9 3a		      cmp	#'9+1
   1294  07c5		       b0 29		      bcs	tstBranch
   1295  07c7							;
   1296  07c7							; It's a digit, so convert to a number.
   1297  07c7							;
   1298  07c7		       20 19 0a 	      jsr	getDecimal
   1299  07ca		       4c a9 02 	      jmp	NextIL
   1300  07cd							;
   1301  07cd							;=====================================================
   1302  07cd							; TSTN checks for a number.  This is very simplistic;
   1303  07cd							; if the character is a digit, assume it's a number.
   1304  07cd							; Convert to a number and push it onto the stack.
   1305  07cd							;
   1306  07cd		       20 03 09    iTSTN      jsr	getILByte
   1307  07d0		       85 7c		      sta	offset
   1308  07d2							;
   1309  07d2		       a4 82		      ldy	CUROFF
   1310  07d4		       20 05 0c 	      jsr	SkipSpaces
   1311  07d7		       b1 80		      lda	(CURPTR),y
   1312  07d9		       c9 2d		      cmp	#'-	;negative?
   1313  07db		       f0 08		      beq	iTSTN_1
   1314  07dd		       c9 30		      cmp	#'0
   1315  07df		       90 0f		      bcc	tstBranch
   1316  07e1		       c9 3a		      cmp	#'9+1
   1317  07e3		       b0 0b		      bcs	tstBranch
   1318  07e5							;
   1319  07e5							; It's a digit, so convert to a number.
   1320  07e5							;
   1321  07e5		       20 19 0a    iTSTN_1    jsr	getDecimal
   1322  07e8		       84 82		      sty	CUROFF
   1323  07ea		       20 14 0b 	      jsr	pushR0	;save onto stack
   1324  07ed		       4c a9 02 	      jmp	NextIL
   1325  07f0
   1326  07f0							;
   1327  07f0							; Common jump point for all TSTx instructions that
   1328  07f0							; fail to meet the requirements.  This takes the
   1329  07f0							; offset and adds/subtracts to/from ILPC.
   1330  07f0							;
   1331  07f0		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1332  07f2		       10 0e		      bpl	tstPositive
   1333  07f4							;
   1334  07f4							; Do negative branch.	Do sign extension.
   1335  07f4							;
   1336  07f4		       18		      clc
   1337  07f5		       65 75		      adc	ILPC
   1338  07f7		       85 75		      sta	ILPC
   1339  07f9		       a5 76		      lda	ILPC+1
   1340  07fb		       69 ff		      adc	#$ff
   1341  07fd		       85 76		      sta	ILPC+1
   1342  07ff		       4c a9 02 	      jmp	NextIL	;keep going
   1343  0802							;
   1344  0802		       18	   tstPositive clc
   1345  0803		       65 75		      adc	ILPC
   1346  0805		       85 75		      sta	ILPC
   1347  0807		       a5 76		      lda	ILPC+1
   1348  0809		       69 00		      adc	#0
   1349  080b		       85 76		      sta	ILPC+1
   1350  080d		       4c a9 02 	      jmp	NextIL
   1351  0810							;
   1352  0810							;=====================================================
   1353  0810							; This places the number of free bytes on top of the
   1354  0810							; stack.
   1355  0810							;
   1356  0810		       20 53 0c    iFREE      jsr	GetSizes
   1357  0813		       20 14 0b 	      jsr	pushR0
   1358  0816		       4c a9 02 	      jmp	NextIL
   1359  0819							;
   1360  0819							;=====================================================
   1361  0819							; Generate a random number from 0-FFFF and then MOD
   1362  0819							; it with the value on top of stack.  Leaves number on
   1363  0819							; stack
   1364  0819							;
   1365  0819		       20 73 0b    iRANDOM    jsr	popR1	;mod value
   1366  081c							;
   1367  081c							; If the value is zero, just return a one.
   1368  081c							;
   1369  081c		       a5 85		      lda	R0
   1370  081e		       05 86		      ora	R0+1
   1371  0820		       f0 63		      beq	irandom1
   1372  0822							;
   1373  0822		       ad 16 11 	      lda	random+1
   1374  0825		       8d 14 11 	      sta	rtemp1
   1375  0828		       ad 15 11 	      lda	random
   1376  082b		       0a		      asl
   1377  082c		       2e 14 11 	      rol	rtemp1
   1378  082f		       0a		      asl
   1379  0830		       2e 14 11 	      rol	rtemp1
   1380  0833		       18		      clc
   1381  0834		       6d 15 11 	      adc	random
   1382  0837		       48		      pha
   1383  0838		       ad 14 11 	      lda	rtemp1
   1384  083b		       6d 16 11 	      adc	random+1
   1385  083e		       8d 16 11 	      sta	random+1
   1386  0841		       68		      pla
   1387  0842		       69 11		      adc	#$11
   1388  0844		       8d 15 11 	      sta	random
   1389  0847		       ad 16 11 	      lda	random+1
   1390  084a		       69 36		      adc	#$36
   1391  084c		       8d 16 11 	      sta	random+1
   1392  084f
   1393  084f		       ad 15 11 	      lda	random
   1394  0852		       85 85		      sta	R0
   1395  0854		       ad 16 11 	      lda	random+1
   1396  0857		       29 7f		      and	#$7f	;make positive
   1397  0859		       85 86		      sta	R0+1
   1398  085b							;
   1399  085b							; R0 contains the number and R1 contains the max value.
   1400  085b							;
   1401  085b		       a5 85	   iRANDOM_2  lda	R0
   1402  085d		       c5 87		      cmp	R1
   1403  085f		       d0 16		      bne	iRANDOM_1
   1404  0861		       a5 86		      lda	R0+1
   1405  0863		       c5 88		      cmp	R1+1
   1406  0865		       d0 10		      bne	iRANDOM_1	;need to subtract
   1407  0867							;
   1408  0867							; Subtract R1 from R0
   1409  0867							;
   1410  0867		       38	   iRANDOM_sub sec
   1411  0868		       a5 85		      lda	R0
   1412  086a		       e5 87		      sbc	R1
   1413  086c		       85 85		      sta	R0
   1414  086e		       a5 86		      lda	R0+1
   1415  0870		       e5 88		      sbc	R1+1
   1416  0872		       85 86		      sta	R0+1
   1417  0874		       4c 5b 08 	      jmp	iRANDOM_2
   1418  0877							;
   1419  0877							; See if R1 > R0.  If so, branch to subtract.
   1420  0877							;
   1421  0877		       a5 85	   iRANDOM_1  lda	R0
   1422  0879		       c5 87		      cmp	R1
   1423  087b		       a5 86		      lda	R0+1
   1424  087d		       e5 88		      sbc	R1+1
   1425  087f		       50 02		      bvc	iRANDOM_4
   1426  0881		       49 80		      eor	#$80
   1427  0883		       10 e2	   iRANDOM_4  bpl	iRANDOM_sub
   1428  0885							;
   1429  0885							; All done.  Almost.  Add one, then push the result.
   1430  0885							;
   1431  0885		       e6 85	   irandom1   inc	R0
   1432  0887		       d0 02		      bne	iRANDOM_3
   1433  0889		       e6 86		      inc	R0+1
   1434  088b		       20 14 0b    iRANDOM_3  jsr	pushR0	;return value
   1435  088e		       4c a9 02 	      jmp	NextIL
   1436  0891
   1437  0891		       20 4d 0b    iPOKEMEMORY jsr	popR0
   1438  0894		       20 73 0b 	      jsr	popR1
   1439  0897		       a5 87		      lda	R1
   1440  0899		       85 83		      sta	PrtFrom	; free pointer in zeropage lol
   1441  089b		       a5 88		      lda	R1+1
   1442  089d		       85 84		      sta	PrtFrom+1
   1443  089f		       a5 85		      lda	R0
   1444  08a1		       a0 00		      ldy	#0
   1445  08a3		       91 83		      sta	(PrtFrom),y
   1446  08a5		       4c a9 02 	      jmp	NextIL
   1447  08a8
   1448  08a8		       20 4d 0b    iPEEKMEMORY jsr	popR0
   1449  08ab		       a5 85		      lda	R0
   1450  08ad		       85 83		      sta	PrtFrom	; free pointer in zeropage lol
   1451  08af		       a5 86		      lda	R0+1
   1452  08b1		       85 84		      sta	PrtFrom+1
   1453  08b3		       a0 00		      ldy	#0
   1454  08b5		       b1 83		      lda	(PrtFrom),y
   1455  08b7		       85 85		      sta	R0
   1456  08b9		       a9 00		      lda	#0
   1457  08bb		       85 86		      sta	R0+1
   1458  08bd		       20 14 0b 	      jsr	pushR0
   1459  08c0		       4c a9 02 	      jmp	NextIL
   1460  08c3
   1461  08c3							;===========================================jlit======
   1462  08c3							;Get a character from the terminal convert to value
   1463  08c3							;leave the number on top f the stack
   1464  08c3							;
   1465  08c3		       20 09 02    iGETCHAR   jsr	GETCH
   1466  08c6					      if	CTMON65
   1467  08c6		       48		      pha
   1468  08c7		       20 0c f0 	      jsr	cout	;echo echo echo
   1469  08ca		       68		      pla
   1470  08cb					      endif
   1471  08cb		       85 85		      sta	R0
   1472  08cd		       a9 00		      lda	#0
   1473  08cf		       85 86		      sta	R0+1
   1474  08d1		       20 14 0b 	      jsr	pushR0
   1475  08d4		       4c a9 02 	      jmp	NextIL
   1476  08d7							;===========================================jlit======
   1477  08d7							;Put a character to the terminal convert to
   1478  08d7							;
   1479  08d7		       20 4d 0b    iPUTCHAR   jsr	popR0
   1480  08da		       a5 85		      lda	R0
   1481  08dc		       20 06 02 	      jsr	OUTCH
   1482  08df		       4c a9 02 	      jmp	NextIL
   1483  08e2							;
   1484  08e2							;
   1485  08e2							;=====================================================
   1486  08e2							; Replace TOS with its absolute value.
   1487  08e2							;
   1488  08e2		       20 4d 0b    iABS       jsr	popR0
   1489  08e5		       a5 86		      lda	R0+1
   1490  08e7		       10 10		      bpl	iABS_1	;already positive
   1491  08e9		       49 ff		      eor	#$ff
   1492  08eb		       85 86		      sta	R0+1
   1493  08ed		       a5 85		      lda	R0
   1494  08ef		       49 ff		      eor	#$ff
   1495  08f1		       85 85		      sta	R0
   1496  08f3		       e6 85		      inc	R0
   1497  08f5		       d0 02		      bne	iABS_1
   1498  08f7		       e6 86		      inc	R0+1
   1499  08f9		       20 14 0b    iABS_1     jsr	pushR0
   1500  08fc		       4c a9 02 	      jmp	NextIL
   1501  08ff							;
------- FILE support.asm LEVEL 2 PASS 3
      0  08ff					      include	"support.asm"
      1  08ff							;
      2  08ff							;=====================================================
      3  08ff							;=====================================================
      4  08ff							;=====================================================
      5  08ff							; This marks the start of support functions used by
      6  08ff							; the IL opcodes.  These are support functions, NOT
      7  08ff							; the IL code.
      8  08ff							;=====================================================
      9  08ff							;=====================================================
     10 Udf8e					      Seg.U	bss
     11 Udf8e		       00	   PrtTerm    ds	1
     12  08ff					      Seg	code
     13  08ff							;=====================================================
     14  08ff							; This gets the next two bytes pointed to by ILPC and
     15  08ff							; returns them; X contains LSB, A contains MSB.  ILPC
     16  08ff							; is advanced by two, and Y contains 0 on return.
     17  08ff
     18  08ff							;
     19  08ff		       20 03 09    getILWord  jsr	getILByte	;LSB
     20  0902		       aa		      tax
     21  0903							;
     22  0903							;=====================================================
     23  0903							; This gets the next byte pointed to by ILPC and
     24  0903							; returns it in A.  On return, X is unchanged but Y
     25  0903							; contains 0.
     26  0903							;
     27  0903		       a0 00	   getILByte  ldy	#0
     28  0905		       b1 75		      lda	(ILPC),y	;get byte
     29  0907		       08		      php		;save status
     30  0908		       e6 75		      inc	ILPC	;inc LSB
     31  090a		       d0 02		      bne	getILb2	;branch if no overflow
     32  090c		       e6 76		      inc	ILPC+1	;inc MSB
     33  090e		       28	   getILb2    plp		;restore status
     34  090f		       60		      rts
     35  0910							;
     36  0910							;=====================================================
     37  0910							; Decrement ILPC by one.
     38  0910							;
     39  0910		       a5 75	   decIL      lda	ILPC
     40  0912		       d0 02		      bne	decIL2
     41  0914		       c6 76		      dec	ILPC+1
     42  0916		       c6 75	   decIL2     dec	ILPC
     43  0918		       60		      rts
     44  0919							;
     45  0919							;=====================================================
     46  0919							; Push the ILPC onto the return stack.  Actually, this
     47  0919							; pushes the address of ILPC+2 since that's the next
     48  0919							; address to execute.
     49  0919							;
     50  0919		       ac 91 10    pushILPC   ldy	retStackPtr
     51  091c		       a5 75		      lda	ILPC
     52  091e		       18		      clc
     53  091f		       69 02		      adc	#2
     54  0921		       99 69 10 	      sta	retStack,y
     55  0924		       08		      php		;save C bit
     56  0925		       c8		      iny
     57  0926		       a5 76		      lda	ILPC+1
     58  0928		       28		      plp		;restore C
     59  0929		       69 00		      adc	#0
     60  092b		       99 69 10 	      sta	retStack,y
     61  092e		       c8		      iny
     62  092f		       8c 91 10 	      sty	retStackPtr
     63  0932		       60		      rts
     64  0933							;
     65  0933							;=====================================================
     66  0933							; Pull the top entry from return stack and put into
     67  0933							; ILPC.
     68  0933							;
     69  0933		       ac 91 10    popILPC    ldy	retStackPtr
     70  0936		       88		      dey
     71  0937		       b9 69 10 	      lda	retStack,y
     72  093a		       85 76		      sta	ILPC+1
     73  093c		       88		      dey
     74  093d		       b9 69 10 	      lda	retStack,y
     75  0940		       85 75		      sta	ILPC
     76  0942		       8c 91 10 	      sty	retStackPtr
     77  0945		       60		      rts
     78  0946							;
     79  0946							;=====================================================
     80  0946							; This searches for a specific line number that is in
     81  0946							; R0.	There are three possible return conditions:
     82  0946							;
     83  0946							; Exact match was found:
     84  0946							;    * Z set
     85  0946							;    * CURPTR points to two-byte line number for that
     86  0946							;	line.
     87  0946							;
     88  0946							; Next highest line found:
     89  0946							;    * Z cleared
     90  0946							;    * C set
     91  0946							;    * CURPTR points to two-byte line number for that
     92  0946							;	line.
     93  0946							;
     94  0946							; End of program reached:
     95  0946							;    * Z cleared
     96  0946							;    * C cleared
     97  0946							;    * CURPTR points to first free byte at end of
     98  0946							;	program.  Ie, it has save value as PROGRAMEND.
     99  0946							;
    100  0946							; A, X, and Y are all undefined on return.
    101  0946							;
    102  0946
    103  0946		       a9 21	   findLine   lda	#ProgramStart&$ff
    104  0948		       85 80		      sta	CURPTR
    105  094a		       a9 11		      lda	#ProgramStart>>8
    106  094c		       85 81		      sta	CURPTR+1
    107  094e							;
    108  094e							; At end of code?
    109  094e							;
    110  094e		       a5 80	   iXFER1     lda	CURPTR
    111  0950		       cd 19 11 	      cmp	PROGRAMEND
    112  0953		       d0 0b		      bne	xfer2	;not end
    113  0955		       a5 81		      lda	CURPTR+1
    114  0957		       cd 1a 11 	      cmp	PROGRAMEND+1
    115  095a		       d0 04		      bne	xfer2
    116  095c							;
    117  095c							; Line not found and the end of the program was
    118  095c							; reached.  Return Z and C both clear.
    119  095c							;
    120  095c		       a9 01		      lda	#1	;clear Z
    121  095e		       18		      clc		;clear C
    122  095f		       60		      rts
    123  0960							;
    124  0960							; Check for an exact match first
    125  0960							;
    126  0960		       a5 85	   xfer2      lda	R0
    127  0962		       a0 00		      ldy	#0
    128  0964		       d1 80		      cmp	(CURPTR),y
    129  0966		       d0 08		      bne	xfernotit
    130  0968		       c8		      iny
    131  0969		       a5 86		      lda	R0+1
    132  096b		       d1 80		      cmp	(CURPTR),y
    133  096d		       d0 01		      bne	xfernotit
    134  096f							;
    135  096f							; This is exactly the line we want.
    136  096f							;
    137  096f		       60		      rts
    138  0970							;
    139  0970							; See if this line is greater than the one we're
    140  0970							; searching for.
    141  0970							;
    142  0970		       a0 01	   xfernotit  ldy	#1
    143  0972		       b1 80		      lda	(CURPTR),y	;compare MSB first
    144  0974		       c5 86		      cmp	R0+1
    145  0976		       90 0b		      bcc	xfer3
    146  0978		       d0 07		      bne	xfer4
    147  097a		       88		      dey
    148  097b		       b1 80		      lda	(CURPTR),y	;compare LSB
    149  097d		       c5 85		      cmp	R0
    150  097f		       90 02		      bcc	xfer3
    151  0981							;
    152  0981							; This line is greater than the one we want, so
    153  0981							; return Z clear and C set.
    154  0981							;
    155  0981		       38	   xfer4      sec
    156  0982		       60		      rts		;both conditions set
    157  0983							;
    158  0983							; Not the line (or droid) we're looking for.  Move to
    159  0983							; the next line.
    160  0983							;
    161  0983		       20 89 09    xfer3      jsr	FindNextLine
    162  0986		       4c 4e 09 	      jmp	iXFER1
    163  0989							;
    164  0989							;=====================================================
    165  0989							; This advances CURPTR to the next line.  If there
    166  0989							; are no more lines, this leaves CURPTR equal to
    167  0989							; ProgramEnd.	Returns CUROFF set to 2.  This assumes
    168  0989							; CURPTR is pointing to a valid line on entry.  This
    169  0989							; pointer points to the two-byte line number.
    170  0989							;
    171  0989				   FindNextLine
    172  0989		       a0 02		      ldy	#2	;skip line number
    173  098b		       84 82		      sty	CUROFF	;this is the new offset
    174  098d							;
    175  098d		       b1 80	   FindNext2  lda	(CURPTR),y
    176  098f		       f0 03		      beq	FindNext3	;found end
    177  0991		       c8		      iny
    178  0992		       d0 f9		      bne	FindNext2
    179  0994		       c8	   FindNext3  iny		;skip null byte
    180  0995		       98		      tya
    181  0996		       18		      clc
    182  0997		       65 80		      adc	CURPTR
    183  0999		       85 80		      sta	CURPTR
    184  099b		       90 02		      bcc	FindNext4	;exit
    185  099d		       e6 81		      inc	CURPTR+1
    186  099f		       60	   FindNext4  rts
    187  09a0							;
    188  09a0							;=====================================================
    189  09a0							; This compares CURPTR to PROGRAMEND and returns Z set
    190  09a0							; if they are equal, Z clear if not.
    191  09a0							;
    192  09a0		       a5 80	   AtEnd      lda	CURPTR
    193  09a2		       cd 19 11 	      cmp	PROGRAMEND
    194  09a5		       d0 05		      bne	atendexit
    195  09a7		       a5 81		      lda	CURPTR+1
    196  09a9		       cd 1a 11 	      cmp	PROGRAMEND+1
    197  09ac		       60	   atendexit  rts
    198  09ad							;
    199  09ad							;=====================================================
    200  09ad							; Print the contents of R0 as a signed decimal number.
    201  09ad							; Does leading zero suppression.
    202  09ad							;
    203  09ad				   PrintDecimal
    204  09ad		       a5 86		      lda	R0+1	;MSB has sign
    205  09af		       10 17		      bpl	pplus	;it's a positive number
    206  09b1							;
    207  09b1							; Negative numbers need more work.  Invert all the bits,
    208  09b1							; then add one.
    209  09b1							;
    210  09b1		       a9 2d		      lda	#'-
    211  09b3		       20 91 0c 	      jsr	VOUTCH	;print the negative sign
    212  09b6							;
    213  09b6		       a5 85		      lda	R0	;invert bits
    214  09b8		       49 ff		      eor	#$ff
    215  09ba		       85 85		      sta	R0
    216  09bc		       a5 86		      lda	R0+1
    217  09be		       49 ff		      eor	#$ff
    218  09c0		       85 86		      sta	R0+1
    219  09c2		       e6 85		      inc	R0	;add one
    220  09c4		       d0 02		      bne	pplus
    221  09c6		       e6 86		      inc	R0+1
    222  09c8							;
    223  09c8							; Print the value in R0 as a positive number.
    224  09c8							;
    225  09c8		       a2 00	   pplus      ldx	#0	;start of subtraction table
    226  09ca		       8e 0d 11 	      stx	diddigit	;no digits yet
    227  09cd		       a0 00	   pploop     ldy	#0	;result of division
    228  09cf		       a5 85	   pploop2    lda	R0	;LSB
    229  09d1		       38		      sec
    230  09d2		       fd 11 0a 	      sbc	dectable,x
    231  09d5		       85 85		      sta	R0
    232  09d7		       a5 86		      lda	R0+1
    233  09d9		       fd 12 0a 	      sbc	dectable+1,x
    234  09dc		       10 2e		      bpl	pplusok	;no underflow
    235  09de							;
    236  09de							; Else, underflow.  Add back in the LSB of the
    237  09de							; table to R0.
    238  09de							;
    239  09de		       18		      clc
    240  09df		       a5 85		      lda	R0
    241  09e1		       7d 11 0a 	      adc	dectable,x
    242  09e4		       85 85		      sta	R0
    243  09e6							;
    244  09e6							; Print the value in Y.  Actually, see if Y is zero and
    245  09e6							; whether any digit has been printed yet.  If Y isn't
    246  09e6							; zero or we've printed a digit, go ahead and print.
    247  09e6							;
    248  09e6		       8e 0c 11 	      stx	printtx
    249  09e9		       98		      tya
    250  09ea		       09 00		      ora	#0	;set flags
    251  09ec		       d0 05		      bne	pprintit	;non-zero, print
    252  09ee							;
    253  09ee		       ad 0d 11 	      lda	diddigit
    254  09f1		       f0 09		      beq	pprintno	;don't print
    255  09f3							;
    256  09f3		       98	   pprintit   tya
    257  09f4		       09 30		      ora	#'0
    258  09f6		       8d 0d 11 	      sta	diddigit
    259  09f9		       20 91 0c 	      jsr	VOUTCH
    260  09fc		       ae 0c 11    pprintno   ldx	printtx
    261  09ff							;
    262  09ff							; Move to the next table entry
    263  09ff							;
    264  09ff		       e8		      inx
    265  0a00		       e8		      inx
    266  0a01		       e0 08		      cpx	#dectableend-dectable
    267  0a03		       d0 c8		      bne	pploop	;not at end
    268  0a05							;
    269  0a05							; At the end.	R0 contains the final value
    270  0a05							; to print.
    271  0a05							;
    272  0a05		       a5 85		      lda	R0
    273  0a07		       09 30		      ora	#'0
    274  0a09		       4c 91 0c 	      jmp	VOUTCH
    275  0a0c							;
    276  0a0c							; Finish doing the subtraction.
    277  0a0c							;
    278  0a0c		       85 86	   pplusok    sta	R0+1
    279  0a0e		       c8		      iny
    280  0a0f		       d0 be		      bne	pploop2
    281  0a11							;
    282  0a11							; Table of powers-of-ten
    283  0a11							;
      0  0a11				   dectable   dw	10000
      1  0a11		       10 27		      .word.w	10000
      0  0a13					      dw	1000
      1  0a13		       e8 03		      .word.w	1000
      0  0a15					      dw	100
      1  0a15		       64 00		      .word.w	100
      0  0a17					      dw	10
      1  0a17		       0a 00		      .word.w	10
    288  0a17		       0a 19	   dectableend equ	*
    289  0a19							;
    290  0a19							;=====================================================
    291  0a19							; Convert an ASCII string to a number.  On input,
    292  0a19							; (CURPTR),Y points to the first digit.  This gets
    293  0a19							; digit-by-digit until finding a non-number.  Returns
    294  0a19							; Y pointing to the non-digit, and R0 contains the
    295  0a19							; number.  This does NOT check for valid ranges, so
    296  0a19							; a value like "123456789" will produce something,
    297  0a19							; but not what you had expected.
    298  0a19							;
    299  0a19		       a9 00	   getDecimal lda	#0
    300  0a1b		       85 85		      sta	R0
    301  0a1d		       85 86		      sta	R0+1
    302  0a1f		       85 77		      sta	dpl	;temporary negative flag
    303  0a21							;
    304  0a21							; See if it's negative...
    305  0a21							;
    306  0a21		       84 13		      sty	$0013
    307  0a23		       b1 80		      lda	(CURPTR),y
    308  0a25		       c9 2d		      cmp	#'-
    309  0a27		       d0 02		      bne	getDecLoop
    310  0a29		       e6 77		      inc	dpl	;it's negative
    311  0a2b							;
    312  0a2b		       b1 80	   getDecLoop lda	(CURPTR),y
    313  0a2d		       c9 30		      cmp	#'0
    314  0a2f		       90 36		      bcc	getDdone
    315  0a31		       c9 3a		      cmp	#'9+1
    316  0a33		       b0 32		      bcs	getDdone
    317  0a35		       38		      sec
    318  0a36		       e9 30		      sbc	#'0	;convert to binary
    319  0a38		       48		      pha
    320  0a39							;
    321  0a39							; Now multiply R0 by 10.  Remember that
    322  0a39							; 2*N + 8*N = 10*N.
    323  0a39							;
    324  0a39		       06 85		      asl	R0
    325  0a3b		       26 86		      rol	R0+1	;*2
    326  0a3d		       a5 85		      lda	R0
    327  0a3f		       85 87		      sta	R1
    328  0a41		       a5 86		      lda	R0+1
    329  0a43		       85 88		      sta	R1+1
    330  0a45		       06 85		      asl	R0
    331  0a47		       26 86		      rol	R0+1	;*4
    332  0a49		       06 85		      asl	R0
    333  0a4b		       26 86		      rol	R0+1	;*8
    334  0a4d		       18		      clc		;now add the partial sums...
    335  0a4e		       a5 85		      lda	R0	;...to get *10
    336  0a50		       65 87		      adc	R1
    337  0a52		       85 85		      sta	R0
    338  0a54		       a5 86		      lda	R0+1
    339  0a56		       65 88		      adc	R1+1
    340  0a58		       85 86		      sta	R0+1
    341  0a5a							;
    342  0a5a							; Add in the new digit
    343  0a5a							;
    344  0a5a		       68		      pla
    345  0a5b		       18		      clc
    346  0a5c		       65 85		      adc	R0
    347  0a5e		       85 85		      sta	R0
    348  0a60		       90 02		      bcc	getD2
    349  0a62		       e6 86		      inc	R0+1
    350  0a64							;
    351  0a64							; Move to next character
    352  0a64							;
    353  0a64		       c8	   getD2      iny
    354  0a65		       d0 c4		      bne	getDecLoop
    355  0a67							;
    356  0a67							; All done with digits, so now deal with it being
    357  0a67							; negative.  If zero, then don't check for negative
    358  0a67							; flag.  Ie, -0 is stored as 0.
    359  0a67							;
    360  0a67		       a5 85	   getDdone   lda	R0
    361  0a69		       05 86		      ora	R0+1
    362  0a6b		       f0 16		      beq	getDone2	;zero
    363  0a6d		       a5 77		      lda	dpl
    364  0a6f		       f0 12		      beq	getDone2	;positive
    365  0a71							;
    366  0a71							; Invert all the bits, then add one.
    367  0a71							;
    368  0a71		       a5 85		      lda	R0
    369  0a73		       49 ff		      eor	#$ff
    370  0a75		       85 85		      sta	R0
    371  0a77		       a5 86		      lda	R0+1
    372  0a79		       49 ff		      eor	#$ff
    373  0a7b		       85 86		      sta	R0+1
    374  0a7d							;
    375  0a7d		       e6 85		      inc	R0
    376  0a7f		       d0 02		      bne	getDone2
    377  0a81		       e6 86		      inc	R0+1
    378  0a83				   getDone2
    379  0a83		       a5 85		      lda	R0
    380  0a85		       85 10		      sta	$0010
    381  0a87		       a5 86		      lda	R0+1
    382  0a89		       85 11		      sta	$0011
    383  0a8b		       a5 77		      lda	dpl
    384  0a8d		       85 12		      sta	$012
    385  0a8f
    386  0a8f		       60		      rts
    387  0a90							;
    388  0a90							;=====================================================
    389  0a90							; Print the string that immediately follows the JSR to
    390  0a90							; this function.  Stops when a null byte is found,
    391  0a90							; then returns to the instruction immediately
    392  0a90							; following the null.
    393  0a90							;
    394  0a90							; Thanks to Ross Archer for this code.
    395  0a90							; http://www.6502.org/source/io/primm.htm
    396  0a90							;
    397  0a90				  -	      if	KIM
    398  0a90				  -puts       sty	putsy
    399  0a90				  -	      pla		;low part of "return" address
    400  0a90				  -			;(data start address)
    401  0a90				  -	      sta	dpl
    402  0a90				  -	      pla
    403  0a90				  -	      sta	dpl+1	;high part of "return" address
    404  0a90				  -			;(data start address)
    405  0a90				  -			;Note: we're pointing one short
    406  0a90				  -psinb      ldy	#1
    407  0a90				  -	      lda	(dpl),y	;Get next string character
    408  0a90				  -	      inc	dpl	;update the pointer
    409  0a90				  -	      bne	psinc	;if not, we're pntng to next char
    410  0a90				  -	      inc	dpl+1	;account for page crossing
    411  0a90				  -psinc      ora	#0	;Set flags according to contents of
    412  0a90				  -			;   Accumulator
    413  0a90				  -	      beq	psix1	;don't print the final NULL
    414  0a90				  -	      jsr	OUTCH	;write it out
    415  0a90				  -	      jmp	psinb	;back around
    416  0a90				  -psix1      inc	dpl
    417  0a90				  -	      bne	psix2
    418  0a90				  -	      inc	dpl+1	;account for page crossing
    419  0a90				  -psix2      ldy	putsy
    420  0a90				  -	      jmp	(dpl)	;return to byte following NULL
    421  0a90					      endif
    422  0a90							;
    423  0a90							;=====================================================
    424  0a90							; Gets a line of input into LINBUF.
    425  0a90							;
    426  0a90							; On entry:
    427  0a90							;    A contains the prompt character, or 0 if none.
    428  0a90							;
    429  0a90							; On exit:
    430  0a90							;    CURPTR points to LINBUF
    431  0a90							;    LINBUF contains the line with 0 at the end.
    432  0a90							;    Y has offset to first non-space character
    433  0a90							;    CURROFF has the same as Y.
    434  0a90							;
    435  0a90		       a2 bb	   GetLine    ldx	#LINBUF&$ff
    436  0a92		       86 80		      stx	CURPTR
    437  0a94		       a2 10		      ldx	#LINBUF>>8
    438  0a96		       86 81		      stx	CURPTR+1
    439  0a98							;
    440  0a98							; Prompt
    441  0a98							;
    442  0a98		       48		      pha		;save for retries
    443  0a99		       68	   GetLinePr  pla		;restore
    444  0a9a		       48		      pha		;save again
    445  0a9b		       09 00		      ora	#0	;any prompt?
    446  0a9d		       f0 08		      beq	getlinenp
    447  0a9f		       20 06 02 	      jsr	OUTCH
    448  0aa2		       a9 20		      lda	#$20
    449  0aa4		       20 06 02 	      jsr	OUTCH	;space after prompt
    450  0aa7							;
    451  0aa7		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    452  0aa9		       8e 0b 11    getline1   stx	getlinx
    453  0aac		       20 09 02 	      jsr	GETCH
    454  0aaf					      if	CTMON65
    455  0aaf		       48		      pha
    456  0ab0		       20 0c f0 	      jsr	cout	;echo echo echo
    457  0ab3		       68		      pla
    458  0ab4					      endif
    459  0ab4		       c9 0d		      cmp	#CR
    460  0ab6		       f0 0d		      beq	getlind	;end of line
    461  0ab8		       c9 08		      cmp	#BS	;backspace?
    462  0aba		       f0 21		      beq	getlinebs
    463  0abc		       ae 0b 11 	      ldx	getlinx
    464  0abf		       9d bb 10 	      sta	LINBUF,x
    465  0ac2		       e8		      inx
    466  0ac3		       d0 e4		      bne	getline1
    467  0ac5							;
    468  0ac5							; CR was hit
    469  0ac5							;
    470  0ac5		       a9 00	   getlind    lda	#0
    471  0ac7		       ae 0b 11 	      ldx	getlinx
    472  0aca		       9d bb 10 	      sta	LINBUF,x
    473  0acd		       85 82		      sta	CUROFF
    474  0acf							;
    475  0acf							; Output a CR/LF
    476  0acf							;
    477  0acf		       20 0c 02 	      jsr	CRLF
    478  0ad2							;
    479  0ad2							; If a blank line, prompt again.
    480  0ad2							;
    481  0ad2		       a0 00		      ldy	#0
    482  0ad4		       20 05 0c 	      jsr	SkipSpaces
    483  0ad7		       b1 80		      lda	(CURPTR),y
    484  0ad9		       f0 be		      beq	GetLinePr	;empty line
    485  0adb		       68		      pla		;get rid of prompt char
    486  0adc		       60		      rts
    487  0add							;
    488  0add							; Backspace was hit
    489  0add							;
    490  0add		       ae 0b 11    getlinebs  ldx	getlinx
    491  0ae0		       f0 c7		      beq	getline1	;at start of line
    492  0ae2		       ca		      dex
    493  0ae3		       4c a9 0a 	      jmp	getline1
    494  0ae6							;
    495  0ae6							;=====================================================
    496  0ae6							; Count the length of the line currently in LINBUF
    497  0ae6							; starting at offset Y.  Returns the length in X.  The
    498  0ae6							; starting offset in Y should point past the ASCII
    499  0ae6							; line number.  Also counts the trailing NULL and two
    500  0ae6							; extra bytes for where the line number will be.
    501  0ae6							;
    502  0ae6				   getLineLength
    503  0ae6		       a2 00		      ldx	#0	;size
    504  0ae8		       b9 bb 10    getLineL2  lda	LINBUF,y
    505  0aeb		       f0 04		      beq	getLineL3
    506  0aed		       c8		      iny
    507  0aee		       e8		      inx
    508  0aef		       d0 f7		      bne	getLineL2
    509  0af1		       e8	   getLineL3  inx		;count null at end
    510  0af2		       e8		      inx		;line number LSB
    511  0af3		       e8		      inx		;MSB
    512  0af4		       86 7d		      stx	lineLength
    513  0af6		       60		      rts
    514  0af7							;
    515  0af7							;=====================================================
    516  0af7							; Count the length of the line pointed to by CURPTR.
    517  0af7							; This also counts the line number and the terminating
    518  0af7							; null.  Ie, this string returns 8:
    519  0af7							;
    520  0af7							; <lineLow><lineHi>Hello<null>
    521  0af7							;
    522  0af7							; Another way of looking at it: add the return value
    523  0af7							; to the CURPTR and it'll point to the next line's
    524  0af7							; line number.  Returns the value in Y.
    525  0af7							;
    526  0af7				   getCURPTRLength
    527  0af7		       a0 02		      ldy	#2	;skip line number
    528  0af9		       b1 80	   getCLineL2 lda	(CURPTR),y
    529  0afb		       f0 03		      beq	getCLineL3
    530  0afd		       c8		      iny
    531  0afe		       d0 f9		      bne	getCLineL2
    532  0b00		       c8	   getCLineL3 iny		;count null at end
    533  0b01		       60		      rts
    534  0b02							;
    535  0b02							;=====================================================
    536  0b02							; This saves ILPC.  This saves to a single save area,
    537  0b02							; so it can't be called more than once.
    538  0b02							;
    539  0b02		       a5 75	   saveIL     lda	ILPC
    540  0b04		       85 79		      sta	tempIL
    541  0b06		       a5 76		      lda	ILPC+1
    542  0b08		       85 7a		      sta	tempIL+1
    543  0b0a		       60		      rts
    544  0b0b							;
    545  0b0b							;=====================================================
    546  0b0b							; This restores ILPC.
    547  0b0b							;
    548  0b0b		       a5 79	   restoreIL  lda	tempIL
    549  0b0d		       85 75		      sta	ILPC
    550  0b0f		       a5 7a		      lda	tempIL+1
    551  0b11		       85 76		      sta	ILPC+1
    552  0b13		       60		      rts
    553  0b14							;
    554  0b14							;=====================================================
    555  0b14							; This pushes R0 onto the stack.
    556  0b14							;
    557  0b14		       ae 68 10    pushR0     ldx	mathStackPtr
    558  0b17		       a5 85		      lda	R0
    559  0b19		       9d 40 10 	      sta	mathStack,x
    560  0b1c		       e8		      inx
    561  0b1d		       a5 86		      lda	R0+1
    562  0b1f		       9d 40 10 	      sta	mathStack,x
    563  0b22		       e8		      inx
    564  0b23		       8e 68 10 	      stx	mathStackPtr
    565  0b26		       60		      rts
    566  0b27
    567  0b27							;=====================================================
    568  0b27							; This pushes line number onto the call stack.
    569  0b27							; The line number to return to is in R0
    570  0b27
    571  0b27		       ae ba 10    pushLN     ldx	callStackPtr
    572  0b2a		       a5 80		      lda	CURPTR
    573  0b2c		       9d 92 10 	      sta	callStack,x
    574  0b2f		       e8		      inx
    575  0b30		       a5 81		      lda	CURPTR+1
    576  0b32		       9d 92 10 	      sta	callStack,x
    577  0b35		       e8		      inx
    578  0b36		       8e ba 10 	      stx	callStackPtr
    579  0b39		       60		      rts
    580  0b3a							;
    581  0b3a							;=====================================================
    582  0b3a							; This pushes R1 onto the stack
    583  0b3a							;
    584  0b3a		       ae 68 10    pushR1     ldx	mathStackPtr
    585  0b3d		       a5 87		      lda	R1
    586  0b3f		       9d 40 10 	      sta	mathStack,x
    587  0b42		       e8		      inx
    588  0b43		       a5 88		      lda	R1+1
    589  0b45		       9d 40 10 	      sta	mathStack,x
    590  0b48		       e8		      inx
    591  0b49		       8e 68 10 	      stx	mathStackPtr
    592  0b4c		       60		      rts
    593  0b4d							;
    594  0b4d							;=====================================================
    595  0b4d							; This pops Top Of Stack and places it in R0.
    596  0b4d							;
    597  0b4d		       ae 68 10    popR0      ldx	mathStackPtr
    598  0b50		       ca		      dex
    599  0b51		       bd 40 10 	      lda	mathStack,x
    600  0b54		       85 86		      sta	R0+1
    601  0b56		       ca		      dex
    602  0b57		       bd 40 10 	      lda	mathStack,x
    603  0b5a		       85 85		      sta	R0
    604  0b5c		       8e 68 10 	      stx	mathStackPtr
    605  0b5f		       60		      rts
    606  0b60							;=====================================================
    607  0b60							; This pops Top Of line number call Stack and
    608  0b60							; laces it in R0.
    609  0b60							;
    610  0b60		       ae ba 10    popLN      ldx	callStackPtr
    611  0b63		       ca		      dex
    612  0b64		       bd 92 10 	      lda	callStack,x
    613  0b67		       85 81		      sta	CURPTR+1
    614  0b69		       ca		      dex
    615  0b6a		       bd 92 10 	      lda	callStack,x
    616  0b6d		       85 80		      sta	CURPTR
    617  0b6f		       8e ba 10 	      stx	callStackPtr
    618  0b72		       60		      rts
    619  0b73							;
    620  0b73							;=====================================================
    621  0b73							; This pops TOS and places it in R1.
    622  0b73							;
    623  0b73		       ae 68 10    popR1      ldx	mathStackPtr
    624  0b76		       ca		      dex
    625  0b77		       bd 40 10 	      lda	mathStack,x
    626  0b7a		       85 88		      sta	R1+1
    627  0b7c		       ca		      dex
    628  0b7d		       bd 40 10 	      lda	mathStack,x
    629  0b80		       85 87		      sta	R1
    630  0b82		       8e 68 10 	      stx	mathStackPtr
    631  0b85		       60		      rts
    632  0b86							;
    633  0b86							;=====================================================
    634  0b86							; This pops TOS and places it in MQ.
    635  0b86							;
    636  0b86		       ae 68 10    popMQ      ldx	mathStackPtr
    637  0b89		       ca		      dex
    638  0b8a		       bd 40 10 	      lda	mathStack,x
    639  0b8d		       8d 12 11 	      sta	MQ+1
    640  0b90		       ca		      dex
    641  0b91		       bd 40 10 	      lda	mathStack,x
    642  0b94		       8d 11 11 	      sta	MQ
    643  0b97		       8e 68 10 	      stx	mathStackPtr
    644  0b9a		       60		      rts
    645  0b9b							;
    646  0b9b							;=====================================================
    647  0b9b							; This assists with multiplication and division by
    648  0b9b							; looking at R0 and R1 and saving a flag as to what
    649  0b9b							; sign the result will be.  Math is always done on
    650  0b9b							; positive numbers, so this converts negative numbers
    651  0b9b							; into positives.  On exit, R0 and R1 are both
    652  0b9b							; positive.  If the signs were different then 'signs'
    653  0b9b							; will be non-zero.
    654  0b9b							;
    655  0b9b		       a9 00	   SaveSigns  lda	#0
    656  0b9d		       8d 13 11 	      sta	sign	;assume positive
    657  0ba0		       a5 86		      lda	R0+1	;MSB
    658  0ba2		       10 13		      bpl	SaveSigns1
    659  0ba4		       ee 13 11 	      inc	sign	;it's negative
    660  0ba7		       49 ff		      eor	#$ff	;flip bits
    661  0ba9		       85 86		      sta	R0+1
    662  0bab		       a5 85		      lda	R0
    663  0bad		       49 ff		      eor	#$ff
    664  0baf		       85 85		      sta	R0
    665  0bb1		       e6 85		      inc	R0
    666  0bb3		       d0 02		      bne	SaveSigns1
    667  0bb5		       e6 86		      inc	R0+1
    668  0bb7		       a5 88	   SaveSigns1 lda	R1+1
    669  0bb9		       10 1a		      bpl	SaveSigns2
    670  0bbb		       48		      pha
    671  0bbc		       ad 13 11 	      lda	sign
    672  0bbf		       49 01		      eor	#1
    673  0bc1		       8d 13 11 	      sta	sign
    674  0bc4		       68		      pla
    675  0bc5		       49 ff		      eor	#$ff	;flip bits
    676  0bc7		       85 88		      sta	R1+1
    677  0bc9		       a5 87		      lda	R1
    678  0bcb		       49 ff		      eor	#$ff
    679  0bcd		       85 87		      sta	R1
    680  0bcf		       e6 87		      inc	R1
    681  0bd1		       d0 02		      bne	SaveSigns2
    682  0bd3		       e6 88		      inc	R1+1
    683  0bd5		       60	   SaveSigns2 rts
    684  0bd6							;
    685  0bd6							;=====================================================
    686  0bd6							; This looks at the value of 'signs' and will convert
    687  0bd6							; both R0 and R1 to negative if set.
    688  0bd6							;
    689  0bd6				   RestoreSigns
    690  0bd6		       ad 13 11 	      lda	sign
    691  0bd9		       f0 28		      beq	restoresigns2
    692  0bdb							;
    693  0bdb		       a5 85		      lda	R0
    694  0bdd		       d0 02		      bne	restoresigns3
    695  0bdf		       c6 86		      dec	R0+1
    696  0be1				   restoresigns3
    697  0be1		       c6 85		      dec	R0
    698  0be3		       a5 85		      lda	R0
    699  0be5		       49 ff		      eor	#$ff
    700  0be7		       85 85		      sta	R0
    701  0be9		       a5 86		      lda	R0+1
    702  0beb		       49 ff		      eor	#$ff
    703  0bed		       85 86		      sta	R0+1
    704  0bef							;
    705  0bef		       a5 87		      lda	R1
    706  0bf1		       d0 02		      bne	restoresigns4
    707  0bf3		       c6 88		      dec	R1+1
    708  0bf5				   restoresigns4
    709  0bf5		       c6 87		      dec	R1
    710  0bf7		       a5 87		      lda	R1
    711  0bf9		       49 ff		      eor	#$ff
    712  0bfb		       85 87		      sta	R1
    713  0bfd		       a5 88		      lda	R1+1
    714  0bff		       49 ff		      eor	#$ff
    715  0c01		       85 88		      sta	R1+1
    716  0c03							;
    717  0c03				   restoresigns2
    718  0c03		       60		      rts
    719  0c04							;
    720  0c04							;=====================================================
    721  0c04							; Skip over spaces.  Returns Y with the offset to
    722  0c04							; either the last character in the line, or the first
    723  0c04							; non-space character.
    724  0c04							;
    725  0c04		       c8	   skipsp2    iny
    726  0c05		       b1 80	   SkipSpaces lda	(CURPTR),y
    727  0c07		       f0 04		      beq	Skip3	;end of line
    728  0c09		       c9 20		      cmp	#SPACE
    729  0c0b		       f0 f7		      beq	skipsp2
    730  0c0d		       60	   Skip3      rts
    731  0c0e							;
    732  0c0e							;=====================================================
    733  0c0e							; This is some debug logic which displays the current
    734  0c0e							; value of the ILPC and the line buffer.
    735  0c0e							;
    736  0c0e		       20 12 f0    dbgLine    jsr	puts
      0  0c11					      db	"ILPC: ",0
      1  0c11		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    738  0c18		       a5 76		      lda	ILPC+1
    739  0c1a		       20 0f 02 	      jsr	OUTHEX
    740  0c1d		       a5 75		      lda	ILPC
    741  0c1f		       20 0f 02 	      jsr	OUTHEX
    742  0c22		       a9 20		      lda	#SPACE
    743  0c24		       20 06 02 	      jsr	OUTCH
    744  0c27		       a0 00		      ldy	#0
    745  0c29		       b1 75		      lda	(ILPC),y
    746  0c2b		       20 0f 02 	      jsr	OUTHEX
    747  0c2e							;
    748  0c2e							; Display the CURPTR value and offset
    749  0c2e							;
    750  0c2e		       20 12 f0 	      jsr	puts
      0  0c31					      db	", CURPTR: ",0
      1  0c31		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    752  0c3c		       a5 81		      lda	CURPTR+1
    753  0c3e		       20 0f 02 	      jsr	OUTHEX
    754  0c41		       a5 80		      lda	CURPTR
    755  0c43		       20 0f 02 	      jsr	OUTHEX
    756  0c46		       a9 2b		      lda	#'+
    757  0c48		       20 06 02 	      jsr	OUTCH
    758  0c4b		       a5 82		      lda	CUROFF
    759  0c4d		       20 0f 02 	      jsr	OUTHEX
    760  0c50							;
    761  0c50		       4c 0c 02 	      jmp	CRLF
    762  0c53							;
    763  0c53							;=====================================================
    764  0c53							; This function might go away eventually, but was
    765  0c53							; added to provide data for other pieces of code.
    766  0c53							; It has some ties to the operating environment that
    767  0c53							; will need to be customized for the target system.
    768  0c53							;
    769  0c53				   GetSizes
    770  0c53							;
    771  0c53							; Here is machine specific code to get the highest
    772  0c53							; memory location that can be used by BASIC.
    773  0c53							;
    774  0c53					      if	ProgramStart < $2000
    775  0c53		       a9 ff		      lda	#$ff
    776  0c55		       8d 1b 11 	      sta	HighMem	;$13ff for KIM-1
    777  0c58		       a9 80		      lda	#$80	;#$13
    778  0c5a		       8d 1c 11 	      sta	HighMem+1
    779  0c5d				  -	      else
    780  0c5d				  -	      lda	#$ff
    781  0c5d				  -	      sta	HighMem	;$CFFF otherwise
    782  0c5d				  -	      lda	#$cf
    783  0c5d				  -	      sta	HighMem+1
    784  0c5d					      endif
    785  0c5d							;
    786  0c5d							; This computes the available memory remaining.
    787  0c5d							;
    788  0c5d		       38		      sec
    789  0c5e		       ad 1b 11 	      lda	HighMem
    790  0c61		       ed 19 11 	      sbc	PROGRAMEND
    791  0c64		       8d 1f 11 	      sta	FreeMem
    792  0c67		       85 85		      sta	R0
    793  0c69		       ad 1c 11 	      lda	HighMem+1
    794  0c6c		       ed 1a 11 	      sbc	PROGRAMEND+1
    795  0c6f		       8d 20 11 	      sta	FreeMem+1
    796  0c72		       85 86		      sta	R0+1
    797  0c74							;
    798  0c74							; This computes the size of the current user program.
    799  0c74							;
    800  0c74		       38		      sec
    801  0c75		       ad 19 11 	      lda	PROGRAMEND
    802  0c78		       e9 21		      sbc	#ProgramStart&$ff
    803  0c7a		       8d 1d 11 	      sta	UsedMem
    804  0c7d		       ad 1a 11 	      lda	PROGRAMEND+1
    805  0c80		       e9 11		      sbc	#ProgramStart>>8
    806  0c82		       8d 1e 11 	      sta	UsedMem+1
    807  0c85							;
    808  0c85		       60		      rts
    809  0c86							;
    810  0c86							;=====================================================
    811  0c86							; Set output vector to the console output function
    812  0c86							;
    813  0c86				   SetOutConsole
    814  0c86		       a9 06		      lda	#OUTCH&$ff
    815  0c88		       8d 17 11 	      sta	BOutVec
    816  0c8b		       a9 02		      lda	#OUTCH/256
    817  0c8d		       8d 18 11 	      sta	BOutVec+1
    818  0c90		       60		      rts
    819  0c91							;
    820  0c91							;=====================================================
    821  0c91							; Jump to the output function in BOutVec
    822  0c91							;
    823  0c91		       6c 17 11    VOUTCH     jmp	(BOutVec)
    824  0c94
    825  0c94							;====================================================
    826  0c94							; Print a string pointed to by x,y terminated by a
    827  0c94							; Return y as the offset
    828  0c94		       86 84	   PrtStr     stx	PrtFrom+1
    829  0c96		       84 83		      sty	PrtFrom
    830  0c98		       8d 8e df 	      sta	PrtTerm
    831  0c9b		       a0 00		      ldy	#0
    832  0c9d		       b1 83	   PrtLoop    lda	(PrtFrom),y
    833  0c9f		       cd 8e df 	      cmp	PrtTerm
    834  0ca2		       f0 0b		      beq	PrtEnd
    835  0ca4		       c9 00		      cmp	#0	; always end if 0 is found
    836  0ca6		       f0 07		      beq	PrtEnd
    837  0ca8		       20 06 02 	      jsr	OUTCH
    838  0cab		       c8		      iny
    839  0cac		       4c 9d 0c 	      jmp	PrtLoop
    840  0caf		       60	   PrtEnd     rts
    841  0cb0
    842  0cb0							;====================================================
    843  0cb0							;Clear the terminal assume it is ansii or vt100
    844  0cb0							;
    845  0cb0				   iCLEARSCREEN
    846  0cb0		       20 12 f0 	      jsr	puts
      0  0cb3					      db	$1b,'[,'3,'J,0
      1  0cb3		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    848  0cb8		       4c a9 02 	      jmp	NextIL
------- FILE mytb.asm
   1503  0cbb					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 3
      0  0cbb					      include	"storage.asm"
      1  0cbb							;
      2  0cbb							;=====================================================
      3  0cbb							;=====================================================
      4  0cbb							;=====================================================
      5  0cbb							; This file contains the functions for saving and
      6  0cbb							; restoring programs from some sort of mass storage
      7  0cbb							; device.  This particular version is for using the
      8  0cbb							; Corsham Tech SD Card System.
      9  0cbb							;=====================================================
     10  0cbb							;=====================================================
     11  0cbb							;=====================================================
     12  0cbb
     13 Udf8f					      SEG.U	bss
     14 Udf8f		       00	   diskBufLength ds	1
     15 Udf90		       00	   diskBufOffset ds	1
     16 Udf91		       00 00 00 00*DiskFileName ds	14
     17 Udf9f
     18  0cbb					      SEG	code
     19  0cbb
     20  0cbb							;
     21  0cbb							;=====================================================
     22  0cbb							; Open a file for reading as a program.  The next
     23  0cbb							; thing on the line should be the filename.
     24  0cbb							;
     25  0cbb				   iOPENREAD
     26  0cbb					      if	XKIM || CTMON65
     27  0cbb		       a4 82		      ldy	CUROFF
     28  0cbd		       b1 80		      lda	(CURPTR),y
     29  0cbf		       d0 07		      bne	iOPENfn	;might be filename
     30  0cc1							;
     31  0cc1							; No filename supplied.
     32  0cc1							;
     33  0cc1		       a9 00	   iOPENnofn  lda	#0
     34  0cc3		       a2 09		      ldx	#ERR_NO_FILENAME
     35  0cc5		       4c 96 04 	      jmp	iErr2
     36  0cc8							;
     37  0cc8							; Add the offset into the buffer start
     38  0cc8							;
     39  0cc8		       18	   iOPENfn    clc
     40  0cc9		       98		      tya
     41  0cca		       65 80		      adc	CURPTR
     42  0ccc		       a8		      tay		;LSB
     43  0ccd		       a5 81		      lda	CURPTR+1
     44  0ccf		       69 00		      adc	#0
     45  0cd1		       aa		      tax
     46  0cd2		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  0cd5		       90 07		      bcc	Ropenok	;branch if opened ok
     48  0cd7							;
     49  0cd7							; Open failed
     50  0cd7							;
     51  0cd7		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  0cd9		       a9 00	   Rdfail2    lda	#0
     53  0cdb		       4c 96 04 	      jmp	iErr2
     54  0cde							;
     55  0cde							; Clear counts and offsets so the next read will
     56  0cde							; cause the file to be read.
     57  0cde							;
     58  0cde		       a9 00	   Ropenok    lda	#0
     59  0ce0		       8d 90 df 	      sta	diskBufOffset
     60  0ce3		       8d 8f df 	      sta	diskBufLength
     61  0ce6		       4c a9 02 	      jmp	NextIL
     62  0ce9					      endif
     63  0ce9
     64  0ce9							;
     65  0ce9							;==============================jlit 08/02/2022========
     66  0ce9							;Remove a file from the disk
     67  0ce9				   iRMFILE
     68  0ce9					      if	XKIM || CTMON65
     69  0ce9		       a4 82		      ldy	CUROFF
     70  0ceb		       b1 80		      lda	(CURPTR),y
     71  0ced		       f0 19		      beq	iRMnofn
     72  0cef							;
     73  0cef		       18		      clc
     74  0cf0		       98		      tya
     75  0cf1		       65 80		      adc	CURPTR
     76  0cf3		       a8		      tay		;LSB
     77  0cf4		       a5 81		      lda	CURPTR+1
     78  0cf6		       69 00		      adc	#0
     79  0cf8		       aa		      tax
     80  0cf9		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  0cfc		       90 07		      bcc	wrmOk	;branch if removed ok
     82  0cfe		       a9 00		      lda	#0
     83  0d00		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  0d02		       4c 96 04 	      jmp	iErr2
     85  0d05		       4c a9 02    wrmOk      jmp	NextIL
     86  0d08
     87  0d08							; No filename supplied.
     88  0d08							;
     89  0d08		       a9 00	   iRMnofn    lda	#0
     90  0d0a		       a2 09		      ldx	#ERR_NO_FILENAME
     91  0d0c		       4c 96 04 	      jmp	iErr2
     92  0d0f					      endif
     93  0d0f							;
     94  0d0f							;=====================================================
     95  0d0f				   iOPENWRITE
     96  0d0f					      if	XKIM || CTMON65
     97  0d0f		       a4 82		      ldy	CUROFF
     98  0d11		       b1 80		      lda	(CURPTR),y
     99  0d13		       f0 f3		      beq	iRMnofn
    100  0d15							;
    101  0d15		       18		      clc
    102  0d16		       98		      tya
    103  0d17		       65 80		      adc	CURPTR
    104  0d19		       a8		      tay		;LSB
    105  0d1a		       a5 81		      lda	CURPTR+1
    106  0d1c		       69 00		      adc	#0
    107  0d1e		       aa		      tax
    108  0d1f		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  0d22		       90 07		      bcc	Wopenok	;branch if opened ok
    110  0d24							;
    111  0d24							; Open failed
    112  0d24							;
    113  0d24		       a9 00	   Wdfail     lda	#0
    114  0d26		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  0d28		       4c 96 04 	      jmp	iErr2
    116  0d2b							;
    117  0d2b		       4c a9 02    Wopenok    jmp	NextIL
    118  0d2e					      endif
    119  0d2e							;
    120  0d2e							;=====================================================
    121  0d2e							; Gets a line of input from the disk file and puts it
    122  0d2e							; into LINBUF.
    123  0d2e							;
    124  0d2e							; On exit:
    125  0d2e							;    CURPTR points to LINBUF
    126  0d2e							;    LINBUF contains the line with 0 at the end.
    127  0d2e							;    Y has offset to first non-space character
    128  0d2e							;    CURROFF has the same as Y.
    129  0d2e							;
    130  0d2e				   iDGETLINE
    131  0d2e					      if	XKIM || CTMON65
    132  0d2e		       a2 bb		      ldx	#LINBUF&$ff
    133  0d30		       86 80		      stx	CURPTR
    134  0d32		       a2 10		      ldx	#LINBUF>>8
    135  0d34		       86 81		      stx	CURPTR+1
    136  0d36							;
    137  0d36		       a2 00		      ldx	#0	;offset
    138  0d38		       8e 0b 11    iDgetLoop  stx	getlinx
    139  0d3b		       20 99 0d 	      jsr	getNextFileByte
    140  0d3e		       b0 16		      bcs	iGetEOF
    141  0d40		       c9 0d		      cmp	#CR
    142  0d42		       f0 0d		      beq	iGetEOL
    143  0d44		       c9 0a		      cmp	#LF
    144  0d46		       f0 09		      beq	iGetEOL
    145  0d48		       ae 0b 11 	      ldx	getlinx
    146  0d4b		       9d bb 10 	      sta	LINBUF,x
    147  0d4e		       e8		      inx
    148  0d4f		       d0 e7		      bne	iDgetLoop
    149  0d51							;
    150  0d51							; Handle end of line.	If the line has nothing, loop
    151  0d51							; back and get another line.
    152  0d51							;
    153  0d51		       ae 0b 11    iGetEOL    ldx	getlinx	;blank line?
    154  0d54		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  0d56							;
    156  0d56							; This can fall through when there is a line, or
    157  0d56							; called directly when EOF is encountered.
    158  0d56							;
    159  0d56		       ae 0b 11    iGetEOF    ldx	getlinx
    160  0d59		       a9 00		      lda	#0
    161  0d5b		       9d bb 10 	      sta	LINBUF,x
    162  0d5e		       85 82		      sta	CUROFF
    163  0d60		       a0 00		      ldy	#0
    164  0d62		       20 05 0c 	      jsr	SkipSpaces
    165  0d65		       4c a9 02 	      jmp	NextIL
    166  0d68					      endif
    167  0d68
    168  0d68							;
    169  0d68							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  0d68							; DISK
    171  0d68							;
    172  0d68				   iDDIR
    173  0d68					      if	XKIM || CTMON65
    174  0d68		       20 30 f0 	      jsr	DiskDir
    175  0d6b							;
    176  0d6b							; Get/Display each entry
    177  0d6b							;
    178  0d6b		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  0d6d		       a0 91		      ldy	#DiskFileName&$ff
    180  0d6f		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  0d72		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  0d74		       20 12 f0 	      jsr	puts
      0  0d77					      db	"   ",0
      1  0d77		       20 20 20 00	      .byte.b	"   ",0
    184  0d7b							; Print the line to the console
    185  0d7b		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  0d7d		       a0 91		      ldy	#DiskFileName&$ff
    187  0d7f		       a5 00		      lda	0
    188  0d81		       20 94 0c 	      jsr	PrtStr	;else print name
    189  0d84		       20 18 f0 	      jsr	crlf
    190  0d87
    191  0d87		       4c 6b 0d 	      jmp	DiskDirLoop	;do next entry
    192  0d8a		       4c a9 02    DiskDirEnd jmp	NextIL
    193  0d8d					      endif
    194  0d8d							;
    195  0d8d							;=====================================================
    196  0d8d							; Does a LIST to a file file.
    197  0d8d							;
    198  0d8d				   iDLIST
    199  0d8d					      if	XKIM || CTMON65
    200  0d8d		       20 c8 0d 	      jsr	SetOutDisk
    201  0d90		       4c cc 05 	      jmp	iLST2
    202  0d93					      endif
    203  0d93							;
    204  0d93							;=====================================================
    205  0d93							; Closes any pending disk file.  Okay to call if there
    206  0d93							; is no open file.
    207  0d93							;
    208  0d93				   iDCLOSE
    209  0d93					      if	XKIM || CTMON65
    210  0d93		       20 42 f0 	      jsr	DiskClose
    211  0d96		       4c a9 02 	      jmp	NextIL
    212  0d99					      endif
    213  0d99							;
    214  0d99							;=====================================================
    215  0d99							; This gets the next byte from an open disk file.  If
    216  0d99							; there are no more bytes left, this returns C set.
    217  0d99							; Else, C is clear and A contains the character.
    218  0d99							;
    219  0d99				   getNextFileByte
    220  0d99					      if	XKIM || CTMON65
    221  0d99		       ae 90 df 	      ldx	diskBufOffset
    222  0d9c		       ec 8f df 	      cpx	diskBufLength
    223  0d9f		       d0 14		      bne	hasdata	;branch if still data
    224  0da1							;
    225  0da1							; There is no data left in the buffer, so read a
    226  0da1							; block from the SD system.
    227  0da1							;
    228  0da1		       a9 84		      lda	#BUFFER_SIZE
    229  0da3		       a2 df		      ldx	#buffer>>8
    230  0da5		       a0 0a		      ldy	#buffer&$ff
    231  0da7		       20 3c f0 	      jsr	DiskRead
    232  0daa		       b0 12		      bcs	getNextEof
    233  0dac							;
    234  0dac							; A contains the number of bytes actually read.
    235  0dac							;
    236  0dac		       8d 8f df 	      sta	diskBufLength	;save length
    237  0daf		       c9 00		      cmp	#0	;shouldn't happen
    238  0db1		       f0 0b		      beq	getNextEof
    239  0db3							;
    240  0db3		       a2 00		      ldx	#0
    241  0db5		       bd 0a df    hasdata    lda	buffer,x
    242  0db8		       e8		      inx
    243  0db9		       8e 90 df 	      stx	diskBufOffset
    244  0dbc		       18		      clc
    245  0dbd		       60		      rts
    246  0dbe							;
    247  0dbe		       a9 00	   getNextEof lda	#0
    248  0dc0		       8d 90 df 	      sta	diskBufOffset
    249  0dc3		       8d 8f df 	      sta	diskBufLength
    250  0dc6		       38		      sec
    251  0dc7		       60		      rts
    252  0dc8							;
    253  0dc8							;=====================================================
    254  0dc8							; Set output vector to the disk output function
    255  0dc8							;
    256  0dc8		       a9 d3	   SetOutDisk lda	#DOUT&$ff
    257  0dca		       8d 17 11 	      sta	BOutVec
    258  0dcd		       a9 0d		      lda	#DOUT/256
    259  0dcf		       8d 18 11 	      sta	BOutVec+1
    260  0dd2		       60		      rts
    261  0dd3							;
    262  0dd3							;=====================================================
    263  0dd3
    264  0dd3		       8d 0a df    DOUT       sta	buffer
    265  0dd6		       a9 01		      lda	#1
    266  0dd8		       a0 0a		      ldy	#buffer&$ff
    267  0dda		       a2 df		      ldx	#buffer/256
    268  0ddc		       20 3f f0 	      jsr	DiskWrite
    269  0ddf							;
    270  0ddf							; need error checking here
    271  0ddf							;
    272  0ddf		       60		      rts
    273  0de0					      endif
    274  0de0
    275  0de0
------- FILE mytb.asm
   1505  0de0					      endif
------- FILE IL.inc LEVEL 2 PASS 3
      0  0de0					      include	"IL.inc"
      1  0de0
      2  0de0							;=====================================================
      3  0de0							; IL.inc
      4  0de0							; These are macros for IL instructions
      5  0de0							;
      6  0de0					      mac	dw
      7  0de0					      .word	{0}
      8  0de0					      endm
      9  0de0					      mac	db
     10  0de0					      .byte	{0}
     11  0de0					      endm
     12  0de0					      macro	xinit
     13  0de0					      db	0
     14  0de0					      endm		;reset the il to start clear all
     15  0de0							;
     16  0de0					      macro	done
     17  0de0					      db	1
     18  0de0					      endm		;print an error if not end of line
     19  0de0							;
     20  0de0					      macro	prs
     21  0de0					      db	2
     22  0de0					      endm		;print a quoted string
     23  0de0							;
     24  0de0					      macro	prn
     25  0de0					      db	3
     26  0de0					      endm		;print a number
     27  0de0							;
     28  0de0					      macro	spc
     29  0de0					      db	4
     30  0de0					      endm		;print space til new tabstop
     31  0de0							;
     32  0de0					      macro	nline
     33  0de0					      db	5
     34  0de0					      endm		;print a new line crlf
     35  0de0							;
     36  0de0							; My NXT is a bit different in that it takes one
     37  0de0							; parameter, which is an address.  If the BASIC
     38  0de0							; program is currently running then move to the
     39  0de0							; next line and continue execution.  However, if
     40  0de0							; in direct mode, jump to the specified IL label.
     41  0de0							;
     42  0de0					      macro	nxt
     43  0de0					      db	6
     44  0de0					      dw	{1}	; addr
     45  0de0					      endm		; addr
     46  0de0							;
     47  0de0					      macro	xfer
     48  0de0					      db	7
     49  0de0					      endm
     50  0de0							;
     51  0de0					      macro	sav
     52  0de0					      db	8
     53  0de0					      endm
     54  0de0							;
     55  0de0					      macro	rstr
     56  0de0					      db	9
     57  0de0					      endm
     58  0de0							;
     59  0de0					      macro	cmpr
     60  0de0					      db	10
     61  0de0					      endm
     62  0de0							;
     63  0de0					      macro	innum
     64  0de0					      db	11
     65  0de0					      endm
     66  0de0							;
     67  0de0					      macro	fin
     68  0de0					      db	12
     69  0de0					      endm
     70  0de0							;
     71  0de0							; ERR is followed by an error number.	The error
     72  0de0							; code is printed along with the line number.
     73  0de0							; Control is passed to the statement set with
     74  0de0							; the ERRGOTO statement.
     75  0de0							;
     76  0de0					      macro	errmsg
     77  0de0					      db	13
     78  0de0					      dw	{1}	;ecode
     79  0de0					      endm		;ecode
     80  0de0							;
     81  0de0					      macro	add
     82  0de0					      db	14
     83  0de0					      endm
     84  0de0							;
     85  0de0					      macro	sub
     86  0de0					      db	15
     87  0de0					      endm
     88  0de0							;
     89  0de0					      macro	neg
     90  0de0					      db	16
     91  0de0					      endm
     92  0de0							;
     93  0de0					      macro	mul
     94  0de0					      db	17
     95  0de0					      endm
     96  0de0							;
     97  0de0					      macro	div
     98  0de0					      db	18
     99  0de0					      endm
    100  0de0							;
    101  0de0					      macro	store
    102  0de0					      db	19
    103  0de0					      endm
    104  0de0							;
    105  0de0					      macro	ind
    106  0de0					      db	20
    107  0de0					      endm
    108  0de0							;
    109  0de0					      macro	lst
    110  0de0					      db	21
    111  0de0					      endm
    112  0de0							;
    113  0de0					      macro	init
    114  0de0					      db	22
    115  0de0					      endm
    116  0de0							;
    117  0de0					      macro	getline
    118  0de0					      db	23
    119  0de0					      endm
    120  0de0							;
    121  0de0					      macro	insert
    122  0de0					      db	24
    123  0de0					      endm
    124  0de0							;
    125  0de0					      macro	rtn
    126  0de0					      db	25
    127  0de0					      endm
    128  0de0							;
    129  0de0					      macro	exit
    130  0de0					      db	26
    131  0de0					      endm
    132  0de0							;
    133  0de0					      macro	lit
    134  0de0					      db	27
    135  0de0					      dw	{1}	;value
    136  0de0					      endm		; value LIT
    137  0de0							;
    138  0de0					      macro	call
    139  0de0					      db	28
    140  0de0					      dw	{1}	;addr
    141  0de0					      endm		;addr
    142  0de0							;
    143  0de0							; IJMP will set the IL PC to the specified value.
    144  0de0							;
    145  0de0					      macro	ijmp
    146  0de0					      db	29
    147  0de0					      dw	{1}	;addr
    148  0de0					      endm		;addr
    149  0de0							;
    150  0de0					      macro	vinit
    151  0de0					      db	30
    152  0de0					      endm
    153  0de0							;
    154  0de0							; ERRGOTO sets the point in the code where the IL
    155  0de0							; interpreter will go after any error.
    156  0de0							;
    157  0de0					      macro	errgoto
    158  0de0					      db	31
    159  0de0					      dw	{1}	;addr
    160  0de0					      endm		;addr
    161  0de0							;
    162  0de0					      macro	tst
    163  0de0					      db	32
    164  0de0					      db	({1}-*)-1	;(addr-*)-1
    165  0de0					      db	{2},0	;string,0
    166  0de0					      endm		;addr,string
    167  0de0							;
    168  0de0					      macro	tstv
    169  0de0					      db	33
    170  0de0					      db	({1}-*)-1	;(addr-*)-1
    171  0de0					      endm		;addr
    172  0de0							;
    173  0de0					      macro	tstl
    174  0de0					      db	34
    175  0de0					      db	({1}-*)-1	;(addr-*)-1
    176  0de0					      endm		;addr
    177  0de0							;
    178  0de0					      macro	tstn
    179  0de0					      db	35
    180  0de0					      db	({1}-*)-1	;(addr-*)-1
    181  0de0					      endm		;addr
    182  0de0							;
    183  0de0							; FREE returns the amount of free RAM on top of
    184  0de0							; the stack.  This is the amount of room the user
    185  0de0							; program has available.
    186  0de0							;
    187  0de0					      macro	free
    188  0de0					      db	36
    189  0de0					      endm
    190  0de0							;
    191  0de0							; RANDOM takes the top item off the stack and
    192  0de0							; replaces it with a random number that is
    193  0de0							; MOD the initial value.  Ie, if the TOS is
    194  0de0							; 42 then RANDOM returns a value from 0 to 41.
    195  0de0							;
    196  0de0					      macro	random
    197  0de0					      db	37
    198  0de0					      endm
    199  0de0							;
    200  0de0							; ABS will replace the top of stack with the
    201  0de0							; absolute value.
    202  0de0							;
    203  0de0					      macro	abs
    204  0de0					      db	38
    205  0de0					      endm
    206  0de0							;
    207  0de0							; OPENREAD opens a file for reading, as in getting
    208  0de0							; statements from it.
    209  0de0							;
    210  0de0					      macro	openread
    211  0de0					      db	39
    212  0de0					      endm
    213  0de0							;
    214  0de0							; OPENWRITE opens a file for writing, as in saving
    215  0de0							; the current program to it.
    216  0de0							;
    217  0de0					      macro	openwrite
    218  0de0					      db	40
    219  0de0					      endm
    220  0de0							;
    221  0de0							; DCLOSE closes any open disk file.
    222  0de0							;
    223  0de0					      macro	dclose
    224  0de0					      db	41
    225  0de0					      endm
    226  0de0							;
    227  0de0							; DGETLINE gets one line from the disk file and puts it
    228  0de0							; into LINBUFF.
    229  0de0							;
    230  0de0					      macro	dgetline
    231  0de0					      db	42
    232  0de0					      endm
    233  0de0							;
    234  0de0							; DLIST saves the program to an open disk file.
    235  0de0							;
    236  0de0					      macro	dlist
    237  0de0					      db	43
    238  0de0					      endm
    239  0de0							; DDIR list the current directory
    240  0de0							;
    241  0de0					      macro	ddir
    242  0de0					      db	44
    243  0de0					      endm
    244  0de0
    245  0de0							; RMFILE remove a fle from disk
    246  0de0					      macro	rmfile
    247  0de0					      db	45
    248  0de0					      endm
    249  0de0
    250  0de0							; CLEARSCREEN clear the screen
    251  0de0					      macro	clearscreen
    252  0de0					      db	46
    253  0de0					      endm
    254  0de0							; POKEMEM Poke value into memory
    255  0de0					      macro	pokemem
    256  0de0					      db	47
    257  0de0					      endm
    258  0de0							; PEEKMEM peek at value in memory
    259  0de0					      macro	peekmem
    260  0de0					      db	48
    261  0de0					      endm
    262  0de0							; TSTLET Test if the statement is a let without the keyword let
    263  0de0					      macro	tstlet
    264  0de0					      db	49
    265  0de0					      db	({1}-*)-1	;(addr-*)-1
    266  0de0					      endm		;addr
    267  0de0							; TSTDONE if we reach the end of a statement
    268  0de0					      macro	tstdone
    269  0de0					      db	50
    270  0de0					      db	({1}-*)-1	;(addr-*)-1
    271  0de0					      endm		;addr
    272  0de0							; GETCHAR	get a character from the input line leave it in RO
    273  0de0					      macro	getchar
    274  0de0					      db	51
    275  0de0					      endm
    276  0de0							; PUTCHAR	Put a character to the terminal
    277  0de0					      macro	putchar
    278  0de0					      db	52
    279  0de0					      endm
------- FILE mytb.asm
   1507  0de0							;
   1508  0de0				  -	      if	FIXED
   1509  0de0				  -	      org	$1000
   1510  0de0					      endif
------- FILE basic.il LEVEL 2 PASS 3
      0  0de0					      include	"basic.il"
      1  0de0				   LET			;
      2  0de0							;=====================================================
      3  0de0							;=====================================================
      4  0de0							;=====================================================
      5  0de0							; This is the IL of the BASIC (or whatever) language.
      6  0de0							; Because of the way macros are implemented by as65,
      7  0de0							; labels can't be on the same line as a macro
      8  0de0							; invocation, so that's why labels are on separate
      9  0de0							; lines.
     10  0de0							;
     11  0de0		       0d e0	   IL	      equ	*
     12  0de0
     13  0de0							;THE IL CONTROL SECTION
     14  0de0
     15  0de0				   START
      0  0de0					      INIT		;INITIALIZE
      0  0de0					      db	22
      1  0de0		       16		      .byte.b	22
      0  0de1					      NLINE		;WRITE CRLF
      0  0de1					      db	5
      1  0de1		       05		      .byte.b	5
      0  0de2					      ERRGOTO	CO	;where to go after an error
      0  0de2					      db	31
      1  0de2		       1f		      .byte.b	31
      0  0de3					      dw	CO
      1  0de3		       e6 0d		      .word.w	CO
      0  0de5					      VINIT		;clear all variables
      0  0de5					      db	30
      1  0de5		       1e		      .byte.b	30
     20  0de6							;
     21  0de6							; This is where we jump to get a line of commands or
     22  0de6							; a program from the user.
     23  0de6							;
     24  0de6				   CO
      0  0de6					      GETLINE		;WRITE PROMPT AND GET LINE
      0  0de6					      db	23
      1  0de6		       17		      .byte.b	23
      0  0de7					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  0de7					      db	34
      1  0de7		       22		      .byte.b	34
      0  0de8					      db	(XEC-*)-1
      1  0de8		       04		      .byte.b	(XEC-*)-1
      0  0de9					      INSERT		;INSERT IT (MAY BE DELETE)
      0  0de9					      db	24
      1  0de9		       18		      .byte.b	24
      0  0dea					      IJMP	CO
      0  0dea					      db	29
      1  0dea		       1d		      .byte.b	29
      0  0deb					      dw	CO
      1  0deb		       e6 0d		      .word.w	CO
     29  0ded				   XEC
      0  0ded					      XINIT		;INITIALIZE
      0  0ded					      db	0
      1  0ded		       00		      .byte.b	0
     31  0dee
     32  0dee							;STATEMENT EXECUTOR
     33  0dee
     34  0dee				   STMT
      0  0dee					      TST	S1a,"LET"	;IS STATEMENT A LET
      0  0dee					      db	32
      1  0dee		       20		      .byte.b	32
      0  0def					      db	(S1a-*)-1
      1  0def		       15		      .byte.b	(S1a-*)-1
      0  0df0					      db	"LET",0
      1  0df0		       4c 45 54 00	      .byte.b	"LET",0
      0  0df4				   DOLET      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  0df4					      db	33
      1  0df4		       21		      .byte.b	33
      0  0df5					      db	(ERRVEC-*)-1
      1  0df5		       84		      .byte.b	(ERRVEC-*)-1
      0  0df6					      TST	ERRVEC,"="	;(This line originally omitted)
      0  0df6					      db	32
      1  0df6		       20		      .byte.b	32
      0  0df7					      db	(ERRVEC-*)-1
      1  0df7		       82		      .byte.b	(ERRVEC-*)-1
      0  0df8					      db	"=",0
      1  0df8		       3d 00		      .byte.b	"=",0
      0  0dfa					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  0dfa					      db	28
      1  0dfa		       1c		      .byte.b	28
      0  0dfb					      dw	EXPR
      1  0dfb		       5c 0f		      .word.w	EXPR
      0  0dfd					      DONE		;REPORT ERROR IF NOT NEXT
      0  0dfd					      db	1
      1  0dfd		       01		      .byte.b	1
      0  0dfe					      STORE		;STORE RESULT
      0  0dfe					      db	19
      1  0dfe		       13		      .byte.b	19
      0  0dff					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0dff					      db	6
      1  0dff		       06		      .byte.b	6
      0  0e00					      dw	CO
      1  0e00		       e6 0d		      .word.w	CO
      0  0e02					      IJMP	STMT
      0  0e02					      db	29
      1  0e02		       1d		      .byte.b	29
      0  0e03					      dw	STMT
      1  0e03		       ee 0d		      .word.w	STMT
      0  0e05				   S1a	      TSTLET	S1	;Test if second field is =
      0  0e05					      db	49
      1  0e05		       31		      .byte.b	49
      0  0e06					      db	(S1-*)-1
      1  0e06		       03		      .byte.b	(S1-*)-1
      0  0e07					      IJMP	DOLET	;allow the default to be let
      0  0e07					      db	29
      1  0e07		       1d		      .byte.b	29
      0  0e08					      dw	DOLET
      1  0e08		       f4 0d		      .word.w	DOLET
     45  0e0a				   S1
      0  0e0a					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  0e0a					      db	32
      1  0e0a		       20		      .byte.b	32
      0  0e0b					      db	(S2b-*)-1
      1  0e0b		       19		      .byte.b	(S2b-*)-1
      0  0e0c					      db	"GO",0
      1  0e0c		       47 4f 00 	      .byte.b	"GO",0
      0  0e0f					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  0e0f					      db	32
      1  0e0f		       20		      .byte.b	32
      0  0e10					      db	(S2-*)-1
      1  0e10		       08		      .byte.b	(S2-*)-1
      0  0e11					      db	"TO",0
      1  0e11		       54 4f 00 	      .byte.b	"TO",0
      0  0e14					      CALL	EXPR	;GET LABEL
      0  0e14					      db	28
      1  0e14		       1c		      .byte.b	28
      0  0e15					      dw	EXPR
      1  0e15		       5c 0f		      .word.w	EXPR
      0  0e17					      DONE		;ERROR IF CR NOT NEXT
      0  0e17					      db	1
      1  0e17		       01		      .byte.b	1
      0  0e18					      XFER		;SET UP AND JUMP
      0  0e18					      db	7
      1  0e18		       07		      .byte.b	7
     51  0e19				   S2
      0  0e19					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  0e19					      db	32
      1  0e19		       20		      .byte.b	32
      0  0e1a					      db	(ERRVEC-*)-1
      1  0e1a		       5f		      .byte.b	(ERRVEC-*)-1
      0  0e1b					      db	"SUB",0
      1  0e1b		       53 55 42 00	      .byte.b	"SUB",0
      0  0e1f					      CALL	EXPR	;GET DESTINATION
      0  0e1f					      db	28
      1  0e1f		       1c		      .byte.b	28
      0  0e20					      dw	EXPR
      1  0e20		       5c 0f		      .word.w	EXPR
      0  0e22					      DONE		;ERROR IF CR NOT NEXT
      0  0e22					      db	1
      1  0e22		       01		      .byte.b	1
      0  0e23					      SAV		;SAVE RETURN LINE
      0  0e23					      db	8
      1  0e23		       08		      .byte.b	8
      0  0e24					      XFER		;AND JUMP
      0  0e24					      db	7
      1  0e24		       07		      .byte.b	7
     57  0e25				   S2b
      0  0e25					      TST	S3,"RE"
      0  0e25					      db	32
      1  0e25		       20		      .byte.b	32
      0  0e26					      db	(S3-*)-1
      1  0e26		       1c		      .byte.b	(S3-*)-1
      0  0e27					      db	"RE",0
      1  0e27		       52 45 00 	      .byte.b	"RE",0
      0  0e2a					      TST	S2a,"TURN"	;RETURN STATEMENT
      0  0e2a					      db	32
      1  0e2a		       20		      .byte.b	32
      0  0e2b					      db	(S2a-*)-1
      1  0e2b		       0d		      .byte.b	(S2a-*)-1
      0  0e2c					      db	"TURN",0
      1  0e2c		       54 55 52 4e*	      .byte.b	"TURN",0
      0  0e31					      DONE		;MUST BE CR
      0  0e31					      db	1
      1  0e31		       01		      .byte.b	1
      0  0e32					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  0e32					      db	9
      1  0e32		       09		      .byte.b	9
      0  0e33					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  0e33					      db	6
      1  0e33		       06		      .byte.b	6
      0  0e34					      dw	CO
      1  0e34		       e6 0d		      .word.w	CO
      0  0e36					      IJMP	STMT
      0  0e36					      db	29
      1  0e36		       1d		      .byte.b	29
      0  0e37					      dw	STMT
      1  0e37		       ee 0d		      .word.w	STMT
     64  0e39				   S2a
      0  0e39					      TST	S3,"M"	;REMark.  Skip rest of line
      0  0e39					      db	32
      1  0e39		       20		      .byte.b	32
      0  0e3a					      db	(S3-*)-1
      1  0e3a		       08		      .byte.b	(S3-*)-1
      0  0e3b					      db	"M",0
      1  0e3b		       4d 00		      .byte.b	"M",0
      0  0e3d					      NXT	CO
      0  0e3d					      db	6
      1  0e3d		       06		      .byte.b	6
      0  0e3e					      dw	CO
      1  0e3e		       e6 0d		      .word.w	CO
      0  0e40					      IJMP	STMT
      0  0e40					      db	29
      1  0e40		       1d		      .byte.b	29
      0  0e41					      dw	STMT
      1  0e41		       ee 0d		      .word.w	STMT
     68  0e43
     69  0e43				   S3
      0  0e43					      TST	S3a,"?"	; ? symonym for print
      0  0e43					      db	32
      1  0e43		       20		      .byte.b	32
      0  0e44					      db	(S3a-*)-1
      1  0e44		       05		      .byte.b	(S3a-*)-1
      0  0e45					      db	"?",0
      1  0e45		       3f 00		      .byte.b	"?",0
      0  0e47					      IJMP	S4
      0  0e47					      db	29
      1  0e47		       1d		      .byte.b	29
      0  0e48					      dw	S4
      1  0e48		       55 0e		      .word.w	S4
     72  0e4a				   S3a
      0  0e4a					      TST	S8,"PR"	;allow short form of print
      0  0e4a					      db	32
      1  0e4a		       20		      .byte.b	32
      0  0e4b					      db	(S8-*)-1
      1  0e4b		       38		      .byte.b	(S8-*)-1
      0  0e4c					      db	"PR",0
      1  0e4c		       50 52 00 	      .byte.b	"PR",0
      0  0e4f					      TST	S4,"INT"	;PRINT
      0  0e4f					      db	32
      1  0e4f		       20		      .byte.b	32
      0  0e50					      db	(S4-*)-1
      1  0e50		       04		      .byte.b	(S4-*)-1
      0  0e51					      db	"INT",0
      1  0e51		       49 4e 54 00	      .byte.b	"INT",0
     75  0e55				   S4
      0  0e55					      TSTDONE	S4a	;Test if we just want crlf printed
      0  0e55					      db	50
      1  0e55		       32		      .byte.b	50
      0  0e56					      db	(S4a-*)-1
      1  0e56		       03		      .byte.b	(S4a-*)-1
      0  0e57					      IJMP	S6
      0  0e57					      db	29
      1  0e57		       1d		      .byte.b	29
      0  0e58					      dw	S6
      1  0e58		       72 0e		      .word.w	S6
     78  0e5a
      0  0e5a				   S4a	      TST	S7,QUOTE	;TEST FOR QUOTE
      0  0e5a					      db	32
      1  0e5a		       20		      .byte.b	32
      0  0e5b					      db	(S7-*)-1
      1  0e5b		       21		      .byte.b	(S7-*)-1
      0  0e5c					      db	QUOTE,0
      1  0e5c		       22 00		      .byte.b	QUOTE,0
      0  0e5e					      PRS		;PRINT STRING
      0  0e5e					      db	2
      1  0e5e		       02		      .byte.b	2
     81  0e5f				   S5
      0  0e5f					      TST	S6A,COMMA	;IS THERE MORE?
      0  0e5f					      db	32
      1  0e5f		       20		      .byte.b	32
      0  0e60					      db	(S6A-*)-1
      1  0e60		       08		      .byte.b	(S6A-*)-1
      0  0e61					      db	COMMA,0
      1  0e61		       2c 00		      .byte.b	COMMA,0
      0  0e63					      SPC		;SPACE TO NEXT ZONE
      0  0e63					      db	4
      1  0e63		       04		      .byte.b	4
      0  0e64					      TSTDONE	S4	;Not end of line jump back
      0  0e64					      db	50
      1  0e64		       32		      .byte.b	50
      0  0e65					      db	(S4-*)-1
      1  0e65		       ef		      .byte.b	(S4-*)-1
      0  0e66					      IJMP	S6a	;YES JUMP BACK
      0  0e66					      db	29
      1  0e66		       1d		      .byte.b	29
      0  0e67					      dw	S6a
      1  0e67		       74 0e		      .word.w	S6a
     86  0e69							;
     87  0e69							; If a semicolon, don't do anything.
     88  0e69							;
     89  0e69				   S6A
      0  0e69					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  0e69					      db	32
      1  0e69		       20		      .byte.b	32
      0  0e6a					      db	(S6-*)-1
      1  0e6a		       07		      .byte.b	(S6-*)-1
      0  0e6b					      db	SEMICOLON,0
      1  0e6b		       3b 00		      .byte.b	SEMICOLON,0
      0  0e6d					      TSTDONE	S4	;Jump Back if not end of line
      0  0e6d					      db	50
      1  0e6d		       32		      .byte.b	50
      0  0e6e					      db	(S4-*)-1
      1  0e6e		       e6		      .byte.b	(S4-*)-1
      0  0e6f					      IJMP	S6a
      0  0e6f					      db	29
      1  0e6f		       1d		      .byte.b	29
      0  0e70					      dw	S6a
      1  0e70		       74 0e		      .word.w	S6a
     93  0e72				   S6
      0  0e72					      DONE		;ERROR IF CR NOT NEXT
      0  0e72					      db	1
      1  0e72		       01		      .byte.b	1
      0  0e73					      NLINE
      0  0e73					      db	5
      1  0e73		       05		      .byte.b	5
      0  0e74				   S6a	      NXT	CO	;exit here if , or ; at end of print
      0  0e74					      db	6
      1  0e74		       06		      .byte.b	6
      0  0e75					      dw	CO
      1  0e75		       e6 0d		      .word.w	CO
      0  0e77					      IJMP	STMT
      0  0e77					      db	29
      1  0e77		       1d		      .byte.b	29
      0  0e78					      dw	STMT
      1  0e78		       ee 0d		      .word.w	STMT
     98  0e7a							;
     99  0e7a							; A jump for code too far away for relative branch
    100  0e7a							;
    101  0e7a				   ERRVEC
      0  0e7a					      IJMP	UNKNOWN
      0  0e7a					      db	29
      1  0e7a		       1d		      .byte.b	29
      0  0e7b					      dw	UNKNOWN
      1  0e7b		       59 0f		      .word.w	UNKNOWN
    103  0e7d							;
    104  0e7d				   S7
      0  0e7d					      CALL	EXPR
      0  0e7d					      db	28
      1  0e7d		       1c		      .byte.b	28
      0  0e7e					      dw	EXPR
      1  0e7e		       5c 0f		      .word.w	EXPR
      0  0e80					      PRN		;PRINT IT
      0  0e80					      db	3
      1  0e80		       03		      .byte.b	3
      0  0e81					      IJMP	S5	;IS THERE MORE?
      0  0e81					      db	29
      1  0e81		       1d		      .byte.b	29
      0  0e82					      dw	S5
      1  0e82		       5f 0e		      .word.w	S5
    108  0e84				   S8
      0  0e84					      TST	S8a,"IF"	;IF STATEMENT
      0  0e84					      db	32
      1  0e84		       20		      .byte.b	32
      0  0e85					      db	(S8a-*)-1
      1  0e85		       17		      .byte.b	(S8a-*)-1
      0  0e86					      db	"IF",0
      1  0e86		       49 46 00 	      .byte.b	"IF",0
      0  0e89					      CALL	EXPR	;GET EXPRESSION
      0  0e89					      db	28
      1  0e89		       1c		      .byte.b	28
      0  0e8a					      dw	EXPR
      1  0e8a		       5c 0f		      .word.w	EXPR
      0  0e8c					      CALL	RELOP	;DETERMINE OPR AND PUT ON STK
      0  0e8c					      db	28
      1  0e8c		       1c		      .byte.b	28
      0  0e8d					      dw	RELOP
      1  0e8d		       08 10		      .word.w	RELOP
      0  0e8f					      CALL	EXPR	;GET EXPRESSION
      0  0e8f					      db	28
      1  0e8f		       1c		      .byte.b	28
      0  0e90					      dw	EXPR
      1  0e90		       5c 0f		      .word.w	EXPR
      0  0e92					      TST	S8a1,"THEN"	;(This line originally omitted) not required
      0  0e92					      db	32
      1  0e92		       20		      .byte.b	32
      0  0e93					      db	(S8a1-*)-1
      1  0e93		       05		      .byte.b	(S8a1-*)-1
      0  0e94					      db	"THEN",0
      1  0e94		       54 48 45 4e*	      .byte.b	"THEN",0
      0  0e99				   S8a1       CMPR		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE
      0  0e99					      db	10
      1  0e99		       0a		      .byte.b	10
      0  0e9a					      IJMP	STMT
      0  0e9a					      db	29
      1  0e9a		       1d		      .byte.b	29
      0  0e9b					      dw	STMT
      1  0e9b		       ee 0d		      .word.w	STMT
    116  0e9d
    117  0e9d				   S8a
      0  0e9d					      TST	S8b,"POKE("	;Poke a value into memory
      0  0e9d					      db	32
      1  0e9d		       20		      .byte.b	32
      0  0e9e					      db	(S8b-*)-1
      1  0e9e		       18		      .byte.b	(S8b-*)-1
      0  0e9f					      db	"POKE(",0
      1  0e9f		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  0ea5					      CALL	EXPR	;Get address to write to
      0  0ea5					      db	28
      1  0ea5		       1c		      .byte.b	28
      0  0ea6					      dw	EXPR
      1  0ea6		       5c 0f		      .word.w	EXPR
      0  0ea8					      TST	UNKNOWN,COMMA	;Must have a coma
      0  0ea8					      db	32
      1  0ea8		       20		      .byte.b	32
      0  0ea9					      db	(UNKNOWN-*)-1
      1  0ea9		       af		      .byte.b	(UNKNOWN-*)-1
      0  0eaa					      db	COMMA,0
      1  0eaa		       2c 00		      .byte.b	COMMA,0
      0  0eac					      CALL	EXPR	;Get the value to poke
      0  0eac					      db	28
      1  0eac		       1c		      .byte.b	28
      0  0ead					      dw	EXPR
      1  0ead		       5c 0f		      .word.w	EXPR
      0  0eaf					      TST	UNKNOWN,")"
      0  0eaf					      db	32
      1  0eaf		       20		      .byte.b	32
      0  0eb0					      db	(UNKNOWN-*)-1
      1  0eb0		       a8		      .byte.b	(UNKNOWN-*)-1
      0  0eb1					      db	")",0
      1  0eb1		       29 00		      .byte.b	")",0
      0  0eb3					      POKEMEM
      0  0eb3					      db	47
      1  0eb3		       2f		      .byte.b	47
      0  0eb4					      IJMP	CO
      0  0eb4					      db	29
      1  0eb4		       1d		      .byte.b	29
      0  0eb5					      dw	CO
      1  0eb5		       e6 0d		      .word.w	CO
    125  0eb7				   S8b
      0  0eb7					      TST	S8c,"PUTCH("	;Put a char to the terminal
      0  0eb7					      db	32
      1  0eb7		       20		      .byte.b	32
      0  0eb8					      db	(S8c-*)-1
      1  0eb8		       12		      .byte.b	(S8c-*)-1
      0  0eb9					      db	"PUTCH(",0
      1  0eb9		       50 55 54 43*	      .byte.b	"PUTCH(",0
      0  0ec0					      CALL	EXPR
      0  0ec0					      db	28
      1  0ec0		       1c		      .byte.b	28
      0  0ec1					      dw	EXPR
      1  0ec1		       5c 0f		      .word.w	EXPR
      0  0ec3					      TST	UNKNOWN,")"
      0  0ec3					      db	32
      1  0ec3		       20		      .byte.b	32
      0  0ec4					      db	(UNKNOWN-*)-1
      1  0ec4		       94		      .byte.b	(UNKNOWN-*)-1
      0  0ec5					      db	")",0
      1  0ec5		       29 00		      .byte.b	")",0
      0  0ec7					      PUTCHAR
      0  0ec7					      db	52
      1  0ec7		       34		      .byte.b	52
      0  0ec8					      IJMP	CO
      0  0ec8					      db	29
      1  0ec8		       1d		      .byte.b	29
      0  0ec9					      dw	CO
      1  0ec9		       e6 0d		      .word.w	CO
    131  0ecb				   S8c
      0  0ecb					      TST	S9,"CLS"	;Clear the screen
      0  0ecb					      db	32
      1  0ecb		       20		      .byte.b	32
      0  0ecc					      db	(S9-*)-1
      1  0ecc		       08		      .byte.b	(S9-*)-1
      0  0ecd					      db	"CLS",0
      1  0ecd		       43 4c 53 00	      .byte.b	"CLS",0
      0  0ed1					      CLEARSCREEN
      0  0ed1					      db	46
      1  0ed1		       2e		      .byte.b	46
      0  0ed2					      IJMP	CO
      0  0ed2					      db	29
      1  0ed2		       1d		      .byte.b	29
      0  0ed3					      dw	CO
      1  0ed3		       e6 0d		      .word.w	CO
    135  0ed5				   S9
      0  0ed5					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  0ed5					      db	32
      1  0ed5		       20		      .byte.b	32
      0  0ed6					      db	(S13-*)-1
      1  0ed6		       18		      .byte.b	(S13-*)-1
      0  0ed7					      db	"INPUT",0
      1  0ed7		       49 4e 50 55*	      .byte.b	"INPUT",0
    137  0edd				   S10
      0  0edd					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  0edd					      db	33
      1  0edd		       21		      .byte.b	33
      0  0ede					      db	(UNKNOWN-*)-1
      1  0ede		       7a		      .byte.b	(UNKNOWN-*)-1
      0  0edf					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  0edf					      db	11
      1  0edf		       0b		      .byte.b	11
      0  0ee0					      STORE		;STORE IT
      0  0ee0					      db	19
      1  0ee0		       13		      .byte.b	19
      0  0ee1					      TST	S11,COMMA	;IS THERE MORE?
      0  0ee1					      db	32
      1  0ee1		       20		      .byte.b	32
      0  0ee2					      db	(S11-*)-1
      1  0ee2		       05		      .byte.b	(S11-*)-1
      0  0ee3					      db	COMMA,0
      1  0ee3		       2c 00		      .byte.b	COMMA,0
      0  0ee5					      IJMP	S10	;YES
      0  0ee5					      db	29
      1  0ee5		       1d		      .byte.b	29
      0  0ee6					      dw	S10
      1  0ee6		       dd 0e		      .word.w	S10
    143  0ee8
    144  0ee8				   S11
      0  0ee8					      DONE		;MUST BE CR
      0  0ee8					      db	1
      1  0ee8		       01		      .byte.b	1
      0  0ee9					      NXT	CO	;SEQUENCE TO NEXT
      0  0ee9					      db	6
      1  0ee9		       06		      .byte.b	6
      0  0eea					      dw	CO
      1  0eea		       e6 0d		      .word.w	CO
      0  0eec					      IJMP	STMT
      0  0eec					      db	29
      1  0eec		       1d		      .byte.b	29
      0  0eed					      dw	STMT
      1  0eed		       ee 0d		      .word.w	STMT
    148  0eef				   S13
      0  0eef					      TST	S14,"END"
      0  0eef					      db	32
      1  0eef		       20		      .byte.b	32
      0  0ef0					      db	(S14-*)-1
      1  0ef0		       05		      .byte.b	(S14-*)-1
      0  0ef1					      db	"END",0
      1  0ef1		       45 4e 44 00	      .byte.b	"END",0
      0  0ef5					      FIN
      0  0ef5					      db	12
      1  0ef5		       0c		      .byte.b	12
    151  0ef6				   S14
      0  0ef6					      TST	S15,"LIST"	;LIST COMMAND
      0  0ef6					      db	32
      1  0ef6		       20		      .byte.b	32
      0  0ef7					      db	(S15-*)-1
      1  0ef7		       0a		      .byte.b	(S15-*)-1
      0  0ef8					      db	"LIST",0
      1  0ef8		       4c 49 53 54*	      .byte.b	"LIST",0
      0  0efd					      DONE
      0  0efd					      db	1
      1  0efd		       01		      .byte.b	1
      0  0efe					      LST
      0  0efe					      db	21
      1  0efe		       15		      .byte.b	21
      0  0eff					      IJMP	CO
      0  0eff					      db	29
      1  0eff		       1d		      .byte.b	29
      0  0f00					      dw	CO
      1  0f00		       e6 0d		      .word.w	CO
    156  0f02				   S15
      0  0f02					      TST	S16,"RUN"	;RUN COMMAND
      0  0f02					      db	32
      1  0f02		       20		      .byte.b	32
      0  0f03					      db	(S16-*)-1
      1  0f03		       0d		      .byte.b	(S16-*)-1
      0  0f04					      db	"RUN",0
      1  0f04		       52 55 4e 00	      .byte.b	"RUN",0
      0  0f08					      DONE
      0  0f08					      db	1
      1  0f08		       01		      .byte.b	1
      0  0f09					      VINIT		;clear variables
      0  0f09					      db	30
      1  0f09		       1e		      .byte.b	30
      0  0f0a					      LIT	1	;GOTO line 1
      0  0f0a					      db	27
      1  0f0a		       1b		      .byte.b	27
      0  0f0b					      dw	1
      1  0f0b		       01 00		      .word.w	1
      0  0f0d					      XFER		;Bob's addition
      0  0f0d					      db	7
      1  0f0d		       07		      .byte.b	7
    162  0f0e							; EXIT
      0  0f0e					      IJMP	STMT	;and run!
      0  0f0e					      db	29
      1  0f0e		       1d		      .byte.b	29
      0  0f0f					      dw	STMT
      1  0f0f		       ee 0d		      .word.w	STMT
    164  0f11				   S16
      0  0f11					      TST	S17A,"NEW"	;clear program
      0  0f11					      db	32
      1  0f11		       20		      .byte.b	32
      0  0f12					      db	(S17A-*)-1
      1  0f12		       08		      .byte.b	(S17A-*)-1
      0  0f13					      db	"NEW",0
      1  0f13		       4e 45 57 00	      .byte.b	"NEW",0
      0  0f17					      DONE
      0  0f17					      db	1
      1  0f17		       01		      .byte.b	1
      0  0f18					      IJMP	START
      0  0f18					      db	29
      1  0f18		       1d		      .byte.b	29
      0  0f19					      dw	START
      1  0f19		       e0 0d		      .word.w	START
    168  0f1b
    169  0f1b				   S17A
      0  0f1b					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  0f1b					      db	32
      1  0f1b		       20		      .byte.b	32
      0  0f1c					      db	(S17B-*)-1
      1  0f1c		       06		      .byte.b	(S17B-*)-1
      0  0f1d					      db	"EXIT",0
      1  0f1d		       45 58 49 54*	      .byte.b	"EXIT",0
      0  0f22					      EXIT
      0  0f22					      db	26
      1  0f22		       1a		      .byte.b	26
    172  0f23
    173  0f23							;
    174  0f23							; Commands related to saving/restoring programs
    175  0f23							; to/from mass storage.
    176  0f23							;
    177  0f23				   S17B
    178  0f23					      if	(XKIM || CTMON65) && DISK_ACCESS
    179  0f23
      0  0f23					      TST	S17C,"SAVE"
      0  0f23					      db	32
      1  0f23		       20		      .byte.b	32
      0  0f24					      db	(S17C-*)-1
      1  0f24		       0b		      .byte.b	(S17C-*)-1
      0  0f25					      db	"SAVE",0
      1  0f25		       53 41 56 45*	      .byte.b	"SAVE",0
      0  0f2a					      OPENWRITE
      0  0f2a					      db	40
      1  0f2a		       28		      .byte.b	40
      0  0f2b					      DLIST
      0  0f2b					      db	43
      1  0f2b		       2b		      .byte.b	43
      0  0f2c					      DCLOSE
      0  0f2c					      db	41
      1  0f2c		       29		      .byte.b	41
      0  0f2d					      IJMP	CO
      0  0f2d					      db	29
      1  0f2d		       1d		      .byte.b	29
      0  0f2e					      dw	CO
      1  0f2e		       e6 0d		      .word.w	CO
    185  0f30
    186  0f30				   S17C
      0  0f30					      TST	S18,"LOAD"
      0  0f30					      db	32
      1  0f30		       20		      .byte.b	32
      0  0f31					      db	(S18-*)-1
      1  0f31		       11		      .byte.b	(S18-*)-1
      0  0f32					      db	"LOAD",0
      1  0f32		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  0f37					      OPENREAD
      0  0f37					      db	39
      1  0f37		       27		      .byte.b	39
    189  0f38				   S17CLP
      0  0f38					      DGETLINE		;get line from file
      0  0f38					      db	42
      1  0f38		       2a		      .byte.b	42
      0  0f39					      TSTL	S17EOL	;no line num means EOL
      0  0f39					      db	34
      1  0f39		       22		      .byte.b	34
      0  0f3a					      db	(S17EOL-*)-1
      1  0f3a		       04		      .byte.b	(S17EOL-*)-1
      0  0f3b					      INSERT		;put it into the program
      0  0f3b					      db	24
      1  0f3b		       18		      .byte.b	24
      0  0f3c					      IJMP	S17CLP	;keep going
      0  0f3c					      db	29
      1  0f3c		       1d		      .byte.b	29
      0  0f3d					      dw	S17CLP
      1  0f3d		       38 0f		      .word.w	S17CLP
    194  0f3f				   S17EOL
      0  0f3f					      DCLOSE		;close disk file
      0  0f3f					      db	41
      1  0f3f		       29		      .byte.b	41
      0  0f40					      IJMP	CO	;back to start
      0  0f40					      db	29
      1  0f40		       1d		      .byte.b	29
      0  0f41					      dw	CO
      1  0f41		       e6 0d		      .word.w	CO
    197  0f43
      0  0f43				   S18	      TST	S19,"DIR"
      0  0f43					      db	32
      1  0f43		       20		      .byte.b	32
      0  0f44					      db	(S19-*)-1
      1  0f44		       08		      .byte.b	(S19-*)-1
      0  0f45					      db	"DIR",0
      1  0f45		       44 49 52 00	      .byte.b	"DIR",0
      0  0f49					      DDIR		;Display the directory content
      0  0f49					      db	44
      1  0f49		       2c		      .byte.b	44
      0  0f4a					      IJMP	CO
      0  0f4a					      db	29
      1  0f4a		       1d		      .byte.b	29
      0  0f4b					      dw	CO
      1  0f4b		       e6 0d		      .word.w	CO
    201  0f4d					      endif
    202  0f4d
      0  0f4d				   S19	      TST	UNKNOWN,"ERASE"
      0  0f4d					      db	32
      1  0f4d		       20		      .byte.b	32
      0  0f4e					      db	(UNKNOWN-*)-1
      1  0f4e		       0a		      .byte.b	(UNKNOWN-*)-1
      0  0f4f					      db	"ERASE",0
      1  0f4f		       45 52 41 53*	      .byte.b	"ERASE",0
      0  0f55					      RMFILE		;Display the directory content
      0  0f55					      db	45
      1  0f55		       2d		      .byte.b	45
      0  0f56					      IJMP	CO
      0  0f56					      db	29
      1  0f56		       1d		      .byte.b	29
      0  0f57					      dw	CO
      1  0f57		       e6 0d		      .word.w	CO
    206  0f57					      endif
    207  0f59
    208  0f59							;
    209  0f59							; Else, unknown command.
    210  0f59							;
    211  0f59				   UNKNOWN
      0  0f59					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  0f59					      db	13
      1  0f59		       0d		      .byte.b	13
      0  0f5a					      dw	ERR_SYNTAX
      1  0f5a		       05 00		      .word.w	ERR_SYNTAX
    213  0f5c
    214  0f5c							;-----------------------------------------------------
    215  0f5c				   EXPR
      0  0f5c					      TST	E0,"-"
      0  0f5c					      db	32
      1  0f5c		       20		      .byte.b	32
      0  0f5d					      db	(E0-*)-1
      1  0f5d		       09		      .byte.b	(E0-*)-1
      0  0f5e					      db	"-",0
      1  0f5e		       2d 00		      .byte.b	"-",0
      0  0f60					      CALL	TERM	;TEST FOR UNARY -.
      0  0f60					      db	28
      1  0f60		       1c		      .byte.b	28
      0  0f61					      dw	TERM
      1  0f61		       85 0f		      .word.w	TERM
      0  0f63					      NEG		;GET VALUE
      0  0f63					      db	16
      1  0f63		       10		      .byte.b	16
      0  0f64					      IJMP	E1	;NEGATE IT
      0  0f64					      db	29
      1  0f64		       1d		      .byte.b	29
      0  0f65					      dw	E1
      1  0f65		       6e 0f		      .word.w	E1
    220  0f67				   E0
      0  0f67					      TST	E1A,"+"	;LOOK FOR MORE
      0  0f67					      db	32
      1  0f67		       20		      .byte.b	32
      0  0f68					      db	(E1A-*)-1
      1  0f68		       02		      .byte.b	(E1A-*)-1
      0  0f69					      db	"+",0
      1  0f69		       2b 00		      .byte.b	"+",0
    222  0f6b				   E1A
      0  0f6b					      CALL	TERM	;TEST FOR UNARY +
      0  0f6b					      db	28
      1  0f6b		       1c		      .byte.b	28
      0  0f6c					      dw	TERM
      1  0f6c		       85 0f		      .word.w	TERM
    224  0f6e				   E1
      0  0f6e					      TST	E2,"+"	;LEADING TERM
      0  0f6e					      db	32
      1  0f6e		       20		      .byte.b	32
      0  0f6f					      db	(E2-*)-1
      1  0f6f		       09		      .byte.b	(E2-*)-1
      0  0f70					      db	"+",0
      1  0f70		       2b 00		      .byte.b	"+",0
      0  0f72					      CALL	TERM
      0  0f72					      db	28
      1  0f72		       1c		      .byte.b	28
      0  0f73					      dw	TERM
      1  0f73		       85 0f		      .word.w	TERM
      0  0f75					      ADD
      0  0f75					      db	14
      1  0f75		       0e		      .byte.b	14
      0  0f76					      IJMP	E1
      0  0f76					      db	29
      1  0f76		       1d		      .byte.b	29
      0  0f77					      dw	E1
      1  0f77		       6e 0f		      .word.w	E1
    229  0f79				   E2
      0  0f79					      TST	E3,"-"	;ANY MORE?
      0  0f79					      db	32
      1  0f79		       20		      .byte.b	32
      0  0f7a					      db	(E3-*)-1
      1  0f7a		       09		      .byte.b	(E3-*)-1
      0  0f7b					      db	"-",0
      1  0f7b		       2d 00		      .byte.b	"-",0
      0  0f7d					      CALL	TERM	;DIFFERENCE TERM
      0  0f7d					      db	28
      1  0f7d		       1c		      .byte.b	28
      0  0f7e					      dw	TERM
      1  0f7e		       85 0f		      .word.w	TERM
      0  0f80					      SUB
      0  0f80					      db	15
      1  0f80		       0f		      .byte.b	15
      0  0f81					      IJMP	E1
      0  0f81					      db	29
      1  0f81		       1d		      .byte.b	29
      0  0f82					      dw	E1
      1  0f82		       6e 0f		      .word.w	E1
    234  0f84				   E3
    235  0f84				   T2
      0  0f84					      RTN		;ANY MORE?
      0  0f84					      db	25
      1  0f84		       19		      .byte.b	25
    237  0f85				   TERM
      0  0f85					      CALL	FACT
      0  0f85					      db	28
      1  0f85		       1c		      .byte.b	28
      0  0f86					      dw	FACT
      1  0f86		       a1 0f		      .word.w	FACT
    239  0f88				   T0
      0  0f88					      TST	T1,"*"
      0  0f88					      db	32
      1  0f88		       20		      .byte.b	32
      0  0f89					      db	(T1-*)-1
      1  0f89		       09		      .byte.b	(T1-*)-1
      0  0f8a					      db	"*",0
      1  0f8a		       2a 00		      .byte.b	"*",0
      0  0f8c					      CALL	FACT	;PRODUCT FACTOR.
      0  0f8c					      db	28
      1  0f8c		       1c		      .byte.b	28
      0  0f8d					      dw	FACT
      1  0f8d		       a1 0f		      .word.w	FACT
      0  0f8f					      MUL
      0  0f8f					      db	17
      1  0f8f		       11		      .byte.b	17
      0  0f90					      IJMP	T0
      0  0f90					      db	29
      1  0f90		       1d		      .byte.b	29
      0  0f91					      dw	T0
      1  0f91		       88 0f		      .word.w	T0
    244  0f93				   T1
      0  0f93					      TST	T2,"/"
      0  0f93					      db	32
      1  0f93		       20		      .byte.b	32
      0  0f94					      db	(T2-*)-1
      1  0f94		       ef		      .byte.b	(T2-*)-1
      0  0f95					      db	"/",0
      1  0f95		       2f 00		      .byte.b	"/",0
      0  0f97					      CALL	FACT	;QUOTIENT FACTOR.
      0  0f97					      db	28
      1  0f97		       1c		      .byte.b	28
      0  0f98					      dw	FACT
      1  0f98		       a1 0f		      .word.w	FACT
      0  0f9a					      DIV
      0  0f9a					      db	18
      1  0f9a		       12		      .byte.b	18
      0  0f9b					      IJMP	T0
      0  0f9b					      db	29
      1  0f9b		       1d		      .byte.b	29
      0  0f9c					      dw	T0
      1  0f9c		       88 0f		      .word.w	T0
    249  0f9e
    250  0f9e				   UNKNOWNVEC
      0  0f9e					      IJMP	UNKNOWN
      0  0f9e					      db	29
      1  0f9e		       1d		      .byte.b	29
      0  0f9f					      dw	UNKNOWN
      1  0f9f		       59 0f		      .word.w	UNKNOWN
    252  0fa1
    253  0fa1							;
    254  0fa1							; Factor an expression.  Always test for functions
    255  0fa1							; first or else they'll be confused for variables.
    256  0fa1							;
    257  0fa1				   FACT
      0  0fa1					      TST	F1A,"FREE()"
      0  0fa1					      db	32
      1  0fa1		       20		      .byte.b	32
      0  0fa2					      db	(F1A-*)-1
      1  0fa2		       09		      .byte.b	(F1A-*)-1
      0  0fa3					      db	"FREE()",0
      1  0fa3		       46 52 45 45*	      .byte.b	"FREE()",0
      0  0faa					      FREE
      0  0faa					      db	36
      1  0faa		       24		      .byte.b	36
      0  0fab					      RTN
      0  0fab					      db	25
      1  0fab		       19		      .byte.b	25
    261  0fac				   F1A
      0  0fac					      TST	F2A,"GETCH()"	; read char from the terminal
      0  0fac					      db	32
      1  0fac		       20		      .byte.b	32
      0  0fad					      db	(F2A-*)-1
      1  0fad		       0a		      .byte.b	(F2A-*)-1
      0  0fae					      db	"GETCH()",0
      1  0fae		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  0fb6					      GETCHAR
      0  0fb6					      db	51
      1  0fb6		       33		      .byte.b	51
      0  0fb7					      RTN
      0  0fb7					      db	25
      1  0fb7		       19		      .byte.b	25
    265  0fb8							;
    266  0fb8							; RND() is supposed to have an argument but if none
    267  0fb8							; was provided, just assume a large value.
    268  0fb8							;
    269  0fb8				   F2A
      0  0fb8					      TST	F2B,"RND("
      0  0fb8					      db	32
      1  0fb8		       20		      .byte.b	32
      0  0fb9					      db	(F2B-*)-1
      1  0fb9		       17		      .byte.b	(F2B-*)-1
      0  0fba					      db	"RND(",0
      1  0fba		       52 4e 44 28*	      .byte.b	"RND(",0
      0  0fbf					      TST	F2A1,")"
      0  0fbf					      db	32
      1  0fbf		       20		      .byte.b	32
      0  0fc0					      db	(F2A1-*)-1
      1  0fc0		       07		      .byte.b	(F2A1-*)-1
      0  0fc1					      db	")",0
      1  0fc1		       29 00		      .byte.b	")",0
      0  0fc3					      LIT	32766
      0  0fc3					      db	27
      1  0fc3		       1b		      .byte.b	27
      0  0fc4					      dw	32766
      1  0fc4		       fe 7f		      .word.w	32766
      0  0fc6					      RANDOM
      0  0fc6					      db	37
      1  0fc6		       25		      .byte.b	37
      0  0fc7					      RTN
      0  0fc7					      db	25
      1  0fc7		       19		      .byte.b	25
    275  0fc8				   F2A1
      0  0fc8					      CALL	FACT	;GET RANGE
      0  0fc8					      db	28
      1  0fc8		       1c		      .byte.b	28
      0  0fc9					      dw	FACT
      1  0fc9		       a1 0f		      .word.w	FACT
      0  0fcb					      TST	UNKNOWN,")"
      0  0fcb					      db	32
      1  0fcb		       20		      .byte.b	32
      0  0fcc					      db	(UNKNOWN-*)-1
      1  0fcc		       8c		      .byte.b	(UNKNOWN-*)-1
      0  0fcd					      db	")",0
      1  0fcd		       29 00		      .byte.b	")",0
      0  0fcf					      RANDOM
      0  0fcf					      db	37
      1  0fcf		       25		      .byte.b	37
      0  0fd0					      RTN
      0  0fd0					      db	25
      1  0fd0		       19		      .byte.b	25
    280  0fd1
    281  0fd1				   F2B
      0  0fd1					      TST	F2B1,"ABS("
      0  0fd1					      db	32
      1  0fd1		       20		      .byte.b	32
      0  0fd2					      db	(F2B1-*)-1
      1  0fd2		       0e		      .byte.b	(F2B1-*)-1
      0  0fd3					      db	"ABS(",0
      1  0fd3		       41 42 53 28*	      .byte.b	"ABS(",0
      0  0fd8					      CALL	FACT	;get value
      0  0fd8					      db	28
      1  0fd8		       1c		      .byte.b	28
      0  0fd9					      dw	FACT
      1  0fd9		       a1 0f		      .word.w	FACT
      0  0fdb					      TST	UNKNOWN,")"
      0  0fdb					      db	32
      1  0fdb		       20		      .byte.b	32
      0  0fdc					      db	(UNKNOWN-*)-1
      1  0fdc		       7c		      .byte.b	(UNKNOWN-*)-1
      0  0fdd					      db	")",0
      1  0fdd		       29 00		      .byte.b	")",0
      0  0fdf					      ABS
      0  0fdf					      db	38
      1  0fdf		       26		      .byte.b	38
      0  0fe0					      RTN
      0  0fe0					      db	25
      1  0fe0		       19		      .byte.b	25
    287  0fe1
    288  0fe1				   F2B1
      0  0fe1					      TST	F2C,"PEEK("	;Return a value from memory
      0  0fe1					      db	32
      1  0fe1		       20		      .byte.b	32
      0  0fe2					      db	(F2C-*)-1
      1  0fe2		       0f		      .byte.b	(F2C-*)-1
      0  0fe3					      db	"PEEK(",0
      1  0fe3		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  0fe9					      CALL	EXPR	;Get the address to write to
      0  0fe9					      db	28
      1  0fe9		       1c		      .byte.b	28
      0  0fea					      dw	EXPR
      1  0fea		       5c 0f		      .word.w	EXPR
      0  0fec					      TST	UNKNOWN,")"	;Closing bracket
      0  0fec					      db	32
      1  0fec		       20		      .byte.b	32
      0  0fed					      db	(UNKNOWN-*)-1
      1  0fed		       6b		      .byte.b	(UNKNOWN-*)-1
      0  0fee					      db	")",0
      1  0fee		       29 00		      .byte.b	")",0
      0  0ff0					      PEEKMEM
      0  0ff0					      db	48
      1  0ff0		       30		      .byte.b	48
      0  0ff1					      RTN
      0  0ff1					      db	25
      1  0ff1		       19		      .byte.b	25
    294  0ff2
    295  0ff2				   F2C
      0  0ff2					      TSTV	F0
      0  0ff2					      db	33
      1  0ff2		       21		      .byte.b	33
      0  0ff3					      db	(F0-*)-1
      1  0ff3		       02		      .byte.b	(F0-*)-1
      0  0ff4					      IND		;YES, GET THE VALUE.
      0  0ff4					      db	20
      1  0ff4		       14		      .byte.b	20
      0  0ff5					      RTN
      0  0ff5					      db	25
      1  0ff5		       19		      .byte.b	25
    299  0ff6				   F0
      0  0ff6					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  0ff6					      db	35
      1  0ff6		       23		      .byte.b	35
      0  0ff7					      db	(F1-*)-1
      1  0ff7		       01		      .byte.b	(F1-*)-1
      0  0ff8					      RTN
      0  0ff8					      db	25
      1  0ff8		       19		      .byte.b	25
    302  0ff9				   F1
      0  0ff9					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  0ff9					      db	32
      1  0ff9		       20		      .byte.b	32
      0  0ffa					      db	(F2A-*)-1
      1  0ffa		       bd		      .byte.b	(F2A-*)-1
      0  0ffb					      db	"(",0
      1  0ffb		       28 00		      .byte.b	"(",0
      0  0ffd					      CALL	EXPR
      0  0ffd					      db	28
      1  0ffd		       1c		      .byte.b	28
      0  0ffe					      dw	EXPR
      1  0ffe		       5c 0f		      .word.w	EXPR
      0  1000					      TST	F2,")"
      0  1000					      db	32
      1  1000		       20		      .byte.b	32
      0  1001					      db	(F2-*)-1
      1  1001		       03		      .byte.b	(F2-*)-1
      0  1002					      db	")",0
      1  1002		       29 00		      .byte.b	")",0
      0  1004					      RTN
      0  1004					      db	25
      1  1004		       19		      .byte.b	25
    307  1005
    308  1005				   F2
      0  1005					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1005					      db	13
      1  1005		       0d		      .byte.b	13
      0  1006					      dw	ERR_SYNTAX
      1  1006		       05 00		      .word.w	ERR_SYNTAX
    310  1008
    311  1008				   RELOP
      0  1008					      TST	iR0,"="
      0  1008					      db	32
      1  1008		       20		      .byte.b	32
      0  1009					      db	(iR0-*)-1
      1  1009		       06		      .byte.b	(iR0-*)-1
      0  100a					      db	"=",0
      1  100a		       3d 00		      .byte.b	"=",0
      0  100c					      LIT	2	;=
      0  100c					      db	27
      1  100c		       1b		      .byte.b	27
      0  100d					      dw	2
      1  100d		       02 00		      .word.w	2
      0  100f					      RTN
      0  100f					      db	25
      1  100f		       19		      .byte.b	25
    315  1010				   iR0
      0  1010					      TST	R4,"<"
      0  1010					      db	32
      1  1010		       20		      .byte.b	32
      0  1011					      db	(R4-*)-1
      1  1011		       16		      .byte.b	(R4-*)-1
      0  1012					      db	"<",0
      1  1012		       3c 00		      .byte.b	"<",0
      0  1014					      TST	iR1,"="
      0  1014					      db	32
      1  1014		       20		      .byte.b	32
      0  1015					      db	(iR1-*)-1
      1  1015		       06		      .byte.b	(iR1-*)-1
      0  1016					      db	"=",0
      1  1016		       3d 00		      .byte.b	"=",0
      0  1018					      LIT	3	;<=
      0  1018					      db	27
      1  1018		       1b		      .byte.b	27
      0  1019					      dw	3
      1  1019		       03 00		      .word.w	3
      0  101b					      RTN
      0  101b					      db	25
      1  101b		       19		      .byte.b	25
    320  101c				   iR1
      0  101c					      TST	R3,">"
      0  101c					      db	32
      1  101c		       20		      .byte.b	32
      0  101d					      db	(R3-*)-1
      1  101d		       06		      .byte.b	(R3-*)-1
      0  101e					      db	">",0
      1  101e		       3e 00		      .byte.b	">",0
      0  1020					      LIT	5	;<>
      0  1020					      db	27
      1  1020		       1b		      .byte.b	27
      0  1021					      dw	5
      1  1021		       05 00		      .word.w	5
      0  1023					      RTN
      0  1023					      db	25
      1  1023		       19		      .byte.b	25
    324  1024				   R3
      0  1024					      LIT	1	;<
      0  1024					      db	27
      1  1024		       1b		      .byte.b	27
      0  1025					      dw	1
      1  1025		       01 00		      .word.w	1
      0  1027					      RTN
      0  1027					      db	25
      1  1027		       19		      .byte.b	25
    327  1028				   R4
      0  1028					      TST	UNKNOWNVEC,">"
      0  1028					      db	32
      1  1028		       20		      .byte.b	32
      0  1029					      db	(UNKNOWNVEC-*)-1
      1  1029		       74		      .byte.b	(UNKNOWNVEC-*)-1
      0  102a					      db	">",0
      1  102a		       3e 00		      .byte.b	">",0
      0  102c					      TST	R5,"="
      0  102c					      db	32
      1  102c		       20		      .byte.b	32
      0  102d					      db	(R5-*)-1
      1  102d		       06		      .byte.b	(R5-*)-1
      0  102e					      db	"=",0
      1  102e		       3d 00		      .byte.b	"=",0
      0  1030					      LIT	6	;>=
      0  1030					      db	27
      1  1030		       1b		      .byte.b	27
      0  1031					      dw	6
      1  1031		       06 00		      .word.w	6
      0  1033					      RTN
      0  1033					      db	25
      1  1033		       19		      .byte.b	25
    332  1034				   R5
      0  1034					      TST	R6,"<"
      0  1034					      db	32
      1  1034		       20		      .byte.b	32
      0  1035					      db	(R6-*)-1
      1  1035		       06		      .byte.b	(R6-*)-1
      0  1036					      db	"<",0
      1  1036		       3c 00		      .byte.b	"<",0
      0  1038					      LIT	1
      0  1038					      db	27
      1  1038		       1b		      .byte.b	27
      0  1039					      dw	1
      1  1039		       01 00		      .word.w	1
      0  103b					      RTN		;(This line originally omitted)
      0  103b					      db	25
      1  103b		       19		      .byte.b	25
    336  103c				   R6
      0  103c					      LIT	4	;>???
      0  103c					      db	27
      1  103c		       1b		      .byte.b	27
      0  103d					      dw	4
      1  103d		       04 00		      .word.w	4
      0  103f					      RTN
      0  103f					      db	25
      1  103f		       19		      .byte.b	25
    339  1040
    340  1040		       10 40	   ILEND      equ	*
------- FILE mytb.asm
   1512  1040		       10 40	   PROGEND    equ	*
   1513  1040
   1514  1040							;=====================================================
   1515  1040							;=====================================================
   1516  1040							;=====================================================
   1517  1040							; These are storage items not in page zero.
   1518  1040							;
   1519 Udf9f					      SEG.U	bss
   1520 U1040					      org	PROGEND
   1521 U1040
   1522 U1040		       00 00 00 00*mathStack  ds	STACKSIZE*2
   1523 U1068		       00	   mathStackPtr ds	1
   1524 U1069		       00 00 00 00*retStack   ds	STACKSIZE*2
   1525 U1091		       00	   retStackPtr ds	1
   1526 U1092		       00 00 00 00*callStack  ds	STACKSIZE*2
   1527 U10ba		       00	   callStackPtr ds	1
   1528 U10bb		       00 00 00 00*LINBUF     ds	80
   1529 U110b		       00	   getlinx    ds	1
   1530 U110c		       00	   printtx    ds	1	;temp X for print funcs
   1531 U110d		       00	   diddigit   ds	1	;for leading zero suppression
   1532 U110e		       00	   putsy      ds	1
   1533 U110f		       00 00	   errGoto    ds	2	;where to set ILPC on err
   1534 U1111		       00 00	   MQ	      ds	2	;used for some math
   1535 U1113		       00	   sign       ds	1	;0 = positive, else negative
   1536 U1114		       00	   rtemp1     ds	1
   1537 U1115		       00 00	   random     ds	2
   1538 U1117		       00 00	   BOutVec    ds	2
   1539 U1119				  -	      if	XKIM
   1540 U1119				  -buffer     ds	BUFFER_SIZE
   1541 U1119					      endif
   1542 U1119							;
   1543 U1119							; PROGRAMEND is the end of the user's BASIC program.
   1544 U1119							; More precisely, it is one byte past the end.  Or,
   1545 U1119							; it's where the next line added to the end will be
   1546 U1119							; placed.
   1547 U1119							;
   1548 U1119		       00 00	   PROGRAMEND ds	2
   1549 U111b		       00 00	   HighMem    ds	2	;highest location
   1550 U111d		       00 00	   UsedMem    ds	2	;size of user program
   1551 U111f		       00 00	   FreeMem    ds	2	;amount of free memory
   1552 U1121							;
   1553 U1121							;=====================================================
   1554 U1121							; This is the start of the user's BASIC program space.
   1555 U1121							;
   1556 U1121							; PERSONAL GOAL: This should be no larger than $0DFF.
   1557 U1121							;		  0200-05FF = 1K
   1558 U1121							;		  0200-09FF = 2K
   1559 U1121							;		  0200-0DFF = 3K
   1560 U1121							;		  0200-11FF = 4K
   1561 U1121							;		  0200-13FF = 4.5K
   1562 U1121							;
   1563 U1121				  -	      if	FIXED
   1564 U1121				  -	      org	$2000
   1565 U1121					      endif
   1566 U1121		       11 21	   ProgramStart equ	*
   1567 U1121							;/*
   1568 U1121							;	if	CTMON65 || XKIM
   1569 U1121							;		SEG code
   1570 U1121							;		org	AutoRun
   1571 U1121							;		dw	TBasicCold
   1572 U1121							;	endif
   1573 U1121							;*/
   1574 U1121					      end
