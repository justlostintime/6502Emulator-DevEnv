------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2759				   input      processor	6502
      2 U2759 ????						;=====================================================
      3 U2759 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2759 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2759 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2759 ????						;
      7 U2759 ????						; While working on the Corsham Technologies KIM Clone
      8 U2759 ????						; project, I wanted to include a TINY BASIC since that
      9 U2759 ????						; was a highly desirable feature of early computers.
     10 U2759 ????						;
     11 U2759 ????						; Rather than negotiating copyright issues for
     12 U2759 ????						; existing BASICs, I decided to just write one from
     13 U2759 ????						; scratch.
     14 U2759 ????						;
     15 U2759 ????						; 10/07/2017
     16 U2759 ????						;
     17 U2759 ????						; This implements a stripped down Tiny BASIC
     18 U2759 ????						; interpreter using the Interpretive Language (IL)
     19 U2759 ????						; method as described in the first few issues of
     20 U2759 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2759 ????						; to write various languages simply by changing the
     22 U2759 ????						; IL code rather than the interpreter itself.
     23 U2759 ????						;
     24 U2759 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2759 ????						;		* Fixed major bug in findLine that
     26 U2759 ????						;		  caused corrupted lines, crashes, etc.
     27 U2759 ????						;		* If no parameter given to RND, assume
     28 U2759 ????						;		  32766.
     29 U2759 ????						;		* No more error 5 when a program
     30 U2759 ????						;		  reaches the end without an END.
     31 U2759 ????						;
     32 U2759 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2759 ????						;		 * Unexpanded version to play with everything
     34 U2759 ????						;		 * Add some usefull system level functions
     35 U2759 ????						;		 * allow a larger number of tiny basic formats
     36 U2759 ????						;		 * Add byte at start of line holding length
     37 U2759 ????						;		   for faster execution of goto and gosub
     38 U2759 ????						;		 * Re-added gosub
     39 U2759 ????						;		 * allow ; or , at end if print stmt
     40 U2759 ????						;		   without CRLF being added.
     41 U2759 ????						;		 * Added extended function erase to
     42 U2759 ????						;		   use the extended ctmon65 rm file
     43 U2759 ????						;		 * Fix quoted text to not have to backtrack
     44 U2759 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2759 ????						;		 * Add concurrency features
     46 U2759 ????						;
     47 U2759 ????						; www.corshamtech.com
     48 U2759 ????						; bob@corshamtech.com
     49 U2759 ????						; JustLostInTime@gmail.com
     50 U2759 ????						;
     51 U2759 ????						;=====================================================
     52 U2759 ????						;
     53 U2759 ????						; Create TRUE and FALSE values for conditionals.
     54 U2759 ????						;
     55 U2759 ????
     56 U2759 ????	       00 00	   FALSE      equ	0
     57 U2759 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2759 ????						;
     59 U2759 ????						;---------------------------------------------------------
     60 U2759 ????						; One of these must be set to indicate which environment
     61 U2759 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2759 ????						; environments:
     63 U2759 ????						;
     64 U2759 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2759 ????						; more K of RAM.
     66 U2759 ????						;
     67 U2759 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2759 ????						; which enhances, without replacing, the standard KIM
     69 U2759 ????						; monitor.  It gives access to routines to save/load files
     70 U2759 ????						; to a micro SD card.
     71 U2759 ????						;
     72 U2759 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2759 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2759 ????						; easily be ported to other systems.  It has support for
     75 U2759 ????						; using a micro SD card for file storage/retrieval.
     76 U2759 ????						;
     77 U2759 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2759 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2759 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2759 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2759 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2759 ????						;
     83 U2759 ????						;   Need to define some macros for the dasm assembler
     84 U2759 ????						;
     85 U2759 ????				      MACRO	dw
     86 U2759 ????				      .word	{0}
     87 U2759 ????				      ENDM
     88 U2759 ????
     89 U2759 ????				      MACRO	db
     90 U2759 ????				      .byte	{0}
     91 U2759 ????				      ENDM
     92 U2759 ????
     93 U2759 ????						;
     94 U2759 ????						; If set, include disk functions.
     95 U2759 ????						;
     96 U2759 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2759 ????						;
     98 U2759 ????						; If ILTRACE is set then dump out the address of every
     99 U2759 ????						; IL opcode before executing it.
    100 U2759 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2759 ????						;
    102 U2759 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2759 ????						;
    104 U2759 ????						; If FIXED is set, put the IL code and the user
    105 U2759 ????						; program space at fixed locations in memory.	This is
    106 U2759 ????						; meant only for debugging.
    107 U2759 ????						;
    108 U2759 ????	       00 00	   FIXED      equ	FALSE
    109 U2759 ????						;
    110 U2759 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2759 ????						; BASIC, so keep this small!
    112 U2759 ????						;
    113 U2759 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2759 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2759 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2759 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2759 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2759 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2759 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2759 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2759 ????						;
    122 U2759 ????						; Gosub entry types
    123 U2759 ????
    124 U2759 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2759 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2759 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2759 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2759 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2759 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2759 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2759 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2759 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2759 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2759 ????						;
    135 U2759 ????						; Common ASCII constants
    136 U2759 ????						;
    137 U2759 ????	       00 07	   BEL	      equ	$07
    138 U2759 ????	       00 08	   BS	      equ	$08
    139 U2759 ????	       00 09	   TAB	      equ	$09
    140 U2759 ????	       00 0a	   LF	      equ	$0A
    141 U2759 ????	       00 0d	   CR	      equ	$0D
    142 U2759 ????	       00 22	   quote      equ	$22
    143 U2759 ????	       00 20	   SPACE      equ	$20
    144 U2759 ????	       00 2c	   COMMA      equ	',
    145 U2759 ????	       00 3b	   SEMICOLON  equ	';
    146 U2759 ????	       00 3a	   COLON      equ	':
    147 U2759 ????	       00 24	   DOLLAR     equ	'$
    148 U2759 ????						;
    149 U2759 ????						; These are error codes
    150 U2759 ????						;
    151 U2759 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2759 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2759 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2759 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2759 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2759 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2759 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2759 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2759 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2759 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2759 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2759 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2759 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2759 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2759 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2759 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2759 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2759 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2759 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2759 ????						;
    171 U2759 ????						;=====================================================
    172 U2759 ????						; Zero page storage.
    173 U2759 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  1de1 ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       15 bc	   CRLF       equ	tbcrlf
    307  0206		       0d aa	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       17 0b	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 eb 16    cold2      jsr	SetOutConsole
    314  0209		       20 f8 16 	      jsr	SetInConsole
    315  020c		       20 0b 17 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    319  023c							;
    320  023c		       20 c7 0d 	      jsr	MemInit	;setup the free space available
    321  023f
    322  023f		       a9 01	   calcstack  lda	#1
    323  0241		       8d f5 1e 	      sta	taskCounter	; Initialize number of tasks to 1
    324  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  0246		       8d f7 1d 	      sta	taskTable	; mark the main task as active
    326  0249		       20 b4 0e 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  024c		       a9 15		      lda	#IL&$ff
    328  024e		       85 43		      sta	ILPC
    329  0250		       a9 19		      lda	#IL>>8
    330  0252		       85 44		      sta	ILPC+1
    331  0254							;
    332  0254							;		  lda	  ProgramStart		     ; user prog
    333  0254							;		  sta	  ProgramEnd
    334  0254							;		  lda	  ProgramStart+1
    335  0254							;		  sta	  ProgramEnd+1
    336  0254							;
    337  0254							;  Init time slices defaults
    338  0254		       a9 02		      lda	#TASKCYCLESHIGH
    339  0256		       8d f4 1e 	      sta	taskResetValue+1
    340  0259		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  025b		       8d f3 1e 	      sta	taskResetValue
    342  025e							;
    343  025e							; Initialize the pseudo-random number sequence...
    344  025e							;
    345  025e		       a9 5a		      lda	#$5a
    346  0260		       8d 3f 27 	      sta	rtemp1
    347  0263		       a9 9d		      lda	#%10011101
    348  0265		       8d 41 27 	      sta	random
    349  0268		       a9 5b		      lda	#%01011011
    350  026a		       8d 42 27 	      sta	random+1
    351  026d							;
    352  026d							;   Insert a Basic irq handler for the basic Language
    353  026d		       a9 7a		      lda	#ServiceIrq&$ff
    354  026f		       8d 00 df 	      sta	IRQvec
    355  0272		       a9 02		      lda	#ServiceIrq>>8
    356  0274		       8d 01 df 	      sta	IRQvec+1
    357  0277		       4c 9f 02 	      jmp	coldtwo
    358  027a
    359  027a							;
    360  027a							; This is the Basic IRQ handler
    361  027a		       48	   ServiceIrq pha
    362  027b		       ad f2 1d 	      lda	IRQStatus
    363  027e		       f0 0a		      BEQ	RetIrq
    364  0280		       ad f3 1d 	      lda	IRQPending
    365  0283		       d0 05		      bne	RetIrq
    366  0285		       a9 01		      lda	#1
    367  0287		       8d f3 1d 	      sta	IRQPending
    368  028a		       68	   RetIrq     pla
    369  028b		       40		      rti
    370  028c							;
    371  028c							;
    372  028c							; This is the warm start entry point
    373  028c							;
    374  028c		       20 eb 16    warm2      jsr	SetOutConsole
    375  028f		       20 f8 16 	      jsr	SetInConsole
    376  0292		       20 bc 15 	      jsr	CRLF
    377  0295		       ad 3c 27 	      lda	errGoto
    378  0298		       85 43		      sta	ILPC
    379  029a		       ad 3d 27 	      lda	errGoto+1
    380  029d		       85 44		      sta	ILPC+1
    381  029f							;
    382  029f							; And continue with both starts here
    383  029f							;
    384  029f				   coldtwo
    385  029f							;
    386  029f							; The ILTrace flag is now run-time settable.
    387  029f							;
    388  029f		       a9 00		      lda	#ILTRACE&$ff
    389  02a1		       85 40		      sta	ILTrace
    390  02a3							;
    391  02a3
    392  02a3		       a9 00		      lda	#0
    393  02a5		       85 5b		      sta	RunMode
    394  02a7		       8d b2 26 	      sta	LINBUF
    395  02aa
    396  02aa							; Clear everything from the stacks
    397  02aa
    398  02aa		       8d 4d 27 	      sta	taskIOPending	; No one waiting for io
    399  02ad		       8d 4e 27 	      sta	taskRDPending	; No one waiting for bg io
    400  02b0
    401  02b0		       20 27 0f 	      jsr	taskReset
    402  02b3							;
    403  02b3		       a9 b2		      lda	#LINBUF&$ff
    404  02b5		       85 4f		      sta	CURPTR
    405  02b7		       a9 26		      lda	#LINBUF>>8
    406  02b9		       85 50		      sta	CURPTR+1	;fall through...
    407  02bb
    408  02bb							;=====================================================
    409  02bb							; This is the top of the IL interpreter.  This fetches
    410  02bb							; and executes the instruction currently pointed to
    411  02bb							; by ILPC and adjusts ILPC to point to the next
    412  02bb							; instruction to execute.
    413  02bb							;
    414  02bb		       ce f1 1e    NextIL     dec	taskCurrentCycles
    415  02be		       d0 03		      bne	NextIlNow
    416  02c0		       20 50 0f 	      jsr	iTaskSwitch	;check for a task switch
    417  02c3		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02c5		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02c7
    420  02c7		       20 48 16 	      jsr	dbgLine	;Print the IL trace information
    421  02ca
    422  02ca		       a4 51	   NextIL2    ldy	CUROFF
    423  02cc		       20 b3 15 	      jsr	SkipSpaces
    424  02cf		       84 51		      sty	CUROFF
    425  02d1							;Task IO Management
    426  02d1		       ad 4e 27 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d4		       f0 08		      beq	NextILStr
    428  02d6		       20 03 14 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02d9		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02db		       ce 4e 27 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02de							;
    432  02de		       20 86 12    NextILStr  jsr	getILByte
    433  02e1							;
    434  02e1							; When the handler is called, these are the conditions
    435  02e1							; of several important items:
    436  02e1							;
    437  02e1							;    (ILPC) will point to the byte AFTER the IL
    438  02e1							;    opcode being executed.
    439  02e1							;
    440  02e1							;    (CURPTR),CUROFF will point to the start of the
    441  02e1							;    next word in the input buffer.  Ie, the next word
    442  02e1							;    in the user program.
    443  02e1							;
    444  02e1		       0a		      asl
    445  02e2		       c9 cc		      cmp	#ILTBLend-ILTBL+2
    446  02e4		       90 33		      bcc	ILgood
    447  02e6							;
    448  02e6							; This handles an illegal IL opcode.  This is serious
    449  02e6							; and there's no way to recover.
    450  02e6							;
    451  02e6		       20 0b 17    ILbad      jsr	puts
      0  02e9					      db	CR,LF
      1  02e9		       0d 0a		      .byte.b	CR,LF
      0  02eb					      db	"Illegal IL "
      1  02eb		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f6					      db	0
      1  02f6		       00		      .byte.b	0
    455  02f7							;
    456  02f7							; Well this is awkward, we need to back up the IL
    457  02f7							; by one since it no longer points to the current
    458  02f7							; opcode.
    459  02f7							;
    460  02f7		       20 93 12 	      jsr	decIL
    461  02fa							;
    462  02fa		       a0 00		      ldy	#0
    463  02fc		       b1 43		      lda	(ILPC),y
    464  02fe		       20 aa 0d 	      jsr	OUTHEX
    465  0301		       20 0b 17 	      jsr	puts
      0  0304					      db	" at ",0
      1  0304		       20 61 74 20*	      .byte.b	" at ",0
    467  0309		       a5 44		      lda	ILPC+1
    468  030b		       20 aa 0d 	      jsr	OUTHEX
    469  030e		       a5 43		      lda	ILPC
    470  0310		       20 aa 0d 	      jsr	OUTHEX
    471  0313		       20 bc 15 	      jsr	CRLF
    472  0316		       4c 03 f0 	      jmp	MONITOR
    473  0319							;
    474  0319							; Just jump to the address (ILPC),y.  Have to do
    475  0319							; some goofy stuff.
    476  0319							;
    477  0319		       a8	   ILgood     tay		;move index into Y
    478  031a		       b9 27 03 	      lda	ILTBL,y
    479  031d		       85 59		      sta	dpl
    480  031f		       b9 28 03 	      lda	ILTBL+1,y
    481  0322		       85 5a		      sta	dpl+1
    482  0324		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0327							;
    484  0327							;=====================================================
    485  0327							; This is the IL jump table.  The IL opcode is
    486  0327							; mulitplied by two, then looked-up in this table.
    487  0327							; There is absolutely nothing special about the order
    488  0327							; of entries here... they all decode at exactly the
    489  0327							; same speed.	However the entry number must match the
    490  0327							; values in IL.inc.
    491  0327							;
    492  0327				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0327					      include	"ilvectortable.asm"
      1  0327					      seg	Code
      2  0327
      0  0327					      dw	iXINIT	;0
      1  0327		       29 04		      .word.w	iXINIT
      0  0329					      dw	iDONE	;1
      1  0329		       44 04		      .word.w	iDONE
      0  032b					      dw	iPRS	;2
      1  032b		       60 04		      .word.w	iPRS
      0  032d					      dw	iPRN	;3
      1  032d		       6a 04		      .word.w	iPRN
      0  032f					      dw	iSPC	;4
      1  032f		       73 04		      .word.w	iSPC
      0  0331					      dw	iNLINE	;5
      1  0331		       1c 09		      .word.w	iNLINE
      0  0333					      dw	iNXT	;6
      1  0333		       7b 04		      .word.w	iNXT
      0  0335					      dw	iXFER	;7
      1  0335		       a7 04		      .word.w	iXFER
      0  0337					      dw	iSAV	;8
      1  0337		       d4 04		      .word.w	iSAV
      0  0339					      dw	iRSTR	;9
      1  0339		       17 05		      .word.w	iRSTR
      0  033b					      dw	iCMPR	;10
      1  033b		       4c 05		      .word.w	iCMPR
      0  033d					      dw	iINNUM	;11
      1  033d		       cd 05		      .word.w	iINNUM
      0  033f					      dw	iFIN	;12
      1  033f		       01 06		      .word.w	iFIN
      0  0341					      dw	iERR	;13
      1  0341		       15 06		      .word.w	iERR
      0  0343					      dw	iADD	;14
      1  0343		       85 06		      .word.w	iADD
      0  0345					      dw	iSUB	;15
      1  0345		       9b 06		      .word.w	iSUB
      0  0347					      dw	iNEG	;16
      1  0347		       b1 06		      .word.w	iNEG
      0  0349					      dw	iMUL	;17
      1  0349		       c9 06		      .word.w	iMUL
      0  034b					      dw	iDIV	;18
      1  034b		       09 07		      .word.w	iDIV
      0  034d					      dw	iSTORE	;19
      1  034d		       5f 07		      .word.w	iSTORE
      0  034f					      dw	iIND	;20
      1  034f		       77 07		      .word.w	iIND
      0  0351					      dw	iLST	;21
      1  0351		       e5 07		      .word.w	iLST
      0  0353					      dw	iINIT	;22
      1  0353		       f1 03		      .word.w	iINIT
      0  0355					      dw	iGETLINE	;23
      1  0355		       4a 08		      .word.w	iGETLINE
      0  0357					      dw	iINSRT	;24
      1  0357		       58 08		      .word.w	iINSRT
      0  0359					      dw	iRTN	;25
      1  0359		       16 09		      .word.w	iRTN
      0  035b					      dw	MONITOR	;26
      1  035b		       03 f0		      .word.w	MONITOR
      0  035d					      dw	iLIT	;27
      1  035d		       3c 09		      .word.w	iLIT
      0  035f					      dw	iCALL	;28
      1  035f		       22 09		      .word.w	iCALL
      0  0361					      dw	iJMP	;29
      1  0361		       2a 09		      .word.w	iJMP
      0  0363					      dw	iVINIT	;30
      1  0363		       59 09		      .word.w	iVINIT
      0  0365					      dw	iERRGOTO	;31
      1  0365		       5f 09		      .word.w	iERRGOTO
      0  0367					      dw	iTST	;32
      1  0367		       6b 09		      .word.w	iTST
      0  0369					      dw	iTSTV	;33
      1  0369		       4c 0a		      .word.w	iTSTV
      0  036b					      dw	iTSTL	;34
      1  036b		       cb 0a		      .word.w	iTSTL
      0  036d					      dw	iTSTN	;35
      1  036d		       e6 0a		      .word.w	iTSTN
      0  036f					      dw	iFREE	;36
      1  036f		       63 0b		      .word.w	iFREE
      0  0371					      dw	iRANDOM	;37
      1  0371		       6c 0b		      .word.w	iRANDOM
      0  0373					      dw	iABS	;38
      1  0373		       3d 0c		      .word.w	iABS
     42  0375							;
     43  0375							; Disk functions.  There must be pointers
     44  0375							; to functions even if no disk is supported.
     45  0375							; Makes things easier in IL.inc.
     46  0375							;
     47  0375					      if	DISK_ACCESS
      0  0375					      dw	iOPENREAD	;39
      1  0375		       f0 17		      .word.w	iOPENREAD
      0  0377					      dw	iOPENWRITE	;40
      1  0377		       44 18		      .word.w	iOPENWRITE
      0  0379					      dw	iDCLOSE	;41
      1  0379		       c8 18		      .word.w	iDCLOSE
      0  037b					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037b		       63 18		      .word.w	iDGETLINE
      0  037d					      dw	iDLIST	;43 Did you remeber your towel?
      1  037d		       c2 18		      .word.w	iDLIST
      0  037f					      dw	iDDIR	;44
      1  037f		       9d 18		      .word.w	iDDIR
      0  0381					      dw	iRMFILE	;45
      1  0381		       1e 18		      .word.w	iRMFILE
     55  0383				  -	      else
     56  0383				  -	      dw	NextIL	;39
     57  0383				  -	      dw	NextIL	;40
     58  0383				  -	      dw	NextIL	;41
     59  0383				  -	      dw	NextIL	;42
     60  0383				  -	      dw	NextIL	;43
     61  0383				  -	      dw	NextIL	;44
     62  0383				  -	      dw	NextIL	;45
     63  0383					      endif
     64  0383							;
      0  0383					      dw	iCLEARSCREEN	;46
      1  0383		       64 17		      .word.w	iCLEARSCREEN
      0  0385					      dw	iPOKEMEMORY	;47
      1  0385		       ca 0b		      .word.w	iPOKEMEMORY
      0  0387					      dw	iPEEKMEMORY	;48
      1  0387		       df 0b		      .word.w	iPEEKMEMORY
      0  0389					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0389		       b2 09		      .word.w	iTSTLET
      0  038b					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038b		       f0 09		      .word.w	iTSTDONE
      0  038d					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038d		       0c 0c		      .word.w	iGETCHAR
      0  038f					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038f		       20 0c		      .word.w	iPUTCHAR
      0  0391					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0391		       f5 0b		      .word.w	iCallFunc
      0  0393					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0393		       9d 05		      .word.w	iBranch
      0  0395					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0395		       95 09		      .word.w	iTSTStr
      0  0397					      dw	iSetIrq	;56	   sets the irq handler
      1  0397		       ba 0c		      .word.w	iSetIrq
      0  0399					      dw	iTstIrq	;57	   test if irq is pending
      1  0399		       2b 0b		      .word.w	iTstIrq
      0  039b					      dw	iRET	;58	   return from interupt
      1  039b		       05 05		      .word.w	iRET
      0  039d					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039d		       e4 05		      .word.w	iINSTR
      0  039f					      dw	iMOD	;60	   returns remainder of division
      1  039f		       12 07		      .word.w	iMOD
      0  03a1					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a1		       a4 0f		      .word.w	iTaskSet
      0  03a3					      dw	iETask	;62	   Terminates a task
      1  03a3		       cf 10		      .word.w	iETask
      0  03a5					      dw	iNTask	;63	   goto next task
      1  03a5		       82 10		      .word.w	iNTask
      0  03a7					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a7		       8c 07		      .word.w	iArray
      0  03a9					      dw	iTaskKill	;65	   kill a running task
      1  03a9		       7a 10		      .word.w	iTaskKill
      0  03ab					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ab		       4e 10		      .word.w	iTaskStat
      0  03ad					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03ad		       2b 0c		      .word.w	iHexOut
      0  03af					      dw	iReadComplete	;68	   Called after a background read completes
      1  03af		       b9 05		      .word.w	iReadComplete
      0  03b1					      dw	iReadStart	;69	   Called to start a background read request
      1  03b1		       af 05		      .word.w	iReadStart
      0  03b3					      dw	iStartIO	;70	   Lock task until io complete
      1  03b3		       b2 10		      .word.w	iStartIO
      0  03b5					      dw	iEndIO	;71	   release task lock for io
      1  03b5		       b8 10		      .word.w	iEndIO
      0  03b7					      dw	iLogNot	;72	   Logical not
      1  03b7		       96 0c		      .word.w	iLogNot
      0  03b9					      dw	iLogOr	;73	   Logical Or
      1  03b9		       6c 0c		      .word.w	iLogOr
      0  03bb					      dw	iLogAnd	;74	   Logical And
      1  03bb		       57 0c		      .word.w	iLogAnd
      0  03bd					      dw	iLogXor	;75	   Logical Xor
      1  03bd		       81 0c		      .word.w	iLogXor
      0  03bf					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bf		       8d 10		      .word.w	iWTASK
      0  03c1					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c1		       c3 10		      .word.w	iTASKPID
      0  03c3					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c3		       f6 0c		      .word.w	iTRACEPROG
      0  03c5					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c5		       c9 15		      .word.w	idbgBasic
      0  03c7					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c7		       85 11		      .word.w	iIPCS
      0  03c9					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c9		       9c 11		      .word.w	iIPCR
      0  03cb					      dw	iIPCC	;82	   Check if any message available for task
      1  03cb		       b0 11		      .word.w	iIPCC
      0  03cd					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cd		       bd 11		      .word.w	iIPCIO
      0  03cf					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cf		       1c 0e		      .word.w	iPushMathStack
      0  03d1					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d1		       4c 0e		      .word.w	iPopMathStack
      0  03d3					      dw	iSaveMathStack	;86	   Save all math info
      1  03d3		       69 0e		      .word.w	iSaveMathStack
      0  03d5					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d5		       88 0e		      .word.w	iRestoreMathStack
      0  03d7					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d7		       39 0e		      .word.w	iIncParmCount
      0  03d9					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d9		       ef 10		      .word.w	iTaskGetMathStack
      0  03db					      dw	iTaskEnable	;90	   enable a suspended task
      1  03db		       1c 10		      .word.w	iTaskEnable
      0  03dd					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03dd		       36 10		      .word.w	iTaskSuspend
      0  03df					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03df		       09 11		      .word.w	iTaskPutMathPtr
      0  03e1					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e1		       43 0a		      .word.w	iTSTVT
      0  03e3					      dw	iSetR2	;94
      1  03e3		       34 09		      .word.w	iSetR2
      0  03e5					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e5		       e3 04		      .word.w	iStk2Tmp
      0  03e7					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e7		       f4 04		      .word.w	iTmp2Stk
      0  03e9					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e9		       d1 09		      .word.w	iTSTBYTE
      0  03eb					      dw	iINCVAR	;98	   Increment variable
      1  03eb		       15 0a		      .word.w	iINCVAR
      0  03ed					      dw	iDECVAR	;99	   Decrement variable
      1  03ed		       2d 0a		      .word.w	iDECVAR
      0  03ef					      dw	iSLICE	;100	   set the time slice for tasks
      1  03ef		       18 11		      .word.w	iSLICE
    120  03f1
------- FILE mytb.asm
    494  03f1		       03 f1	   ILTBLend   equ	*
    495  03f1							;
    496  03f1							;=====================================================
    497  03f1							;=====================================================
    498  03f1							;=====================================================
    499  03f1							; This marks the start of the handlers for IL opcodes.
    500  03f1							;=====================================================
    501  03f1							;=====================================================
    502  03f1							;=====================================================
    503  03f1							;
    504  03f1							;
    505  03f1		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03f3		       85 47		      sta	ILSTACKPTR
    507  03f5		       85 4a		      sta	MATHSTACKPTR
    508  03f7		       85 4d		      sta	GOSUBSTACKPTR
    509  03f9		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  03fb		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  03fd							;
    512  03fd		       ad 4f 27 	      lda	ProgramStart	;user prog
    513  0400		       85 4f		      sta	CURPTR
    514  0402		       8d f8 1d 	      sta	taskTable+1
    515  0405		       8d 51 27 	      sta	ProgramEnd
    516  0408		       ad 50 27 	      lda	ProgramStart+1
    517  040b		       85 50		      sta	CURPTR+1
    518  040d		       8d f9 1d 	      sta	taskTable+2
    519  0410		       8d 52 27 	      sta	ProgramEnd+1
    520  0413		       a9 80		      lda	#TASKACTIVE
    521  0415		       8d f7 1d 	      sta	taskTable	;Mark the first slot as active
    522  0418		       a9 01		      lda	#1
    523  041a		       8d f5 1e 	      sta	taskCounter	;there is always one task / Main task
    524  041d		       ad f3 1e 	      lda	taskResetValue
    525  0420		       8d f1 1e 	      sta	taskCurrentCycles	; set up the task switch counts
    526  0423		       ad f4 1e 	      lda	taskResetValue+1
    527  0426		       8d f2 1e 	      sta	taskCurrentCycles+1
    528  0429							;
    529  0429							; fall into XINIT...
    530  0429							;
    531  0429							;=====================================================
    532  0429							; This initializes for the start of the next line of
    533  0429							; BASIC text.
    534  0429							;
    535  0429		       78	   iXINIT     sei		;ensure interupts are off
    536  042a		       20 27 0f 	      jsr	taskReset	;Clear the task table
    537  042d		       8d f3 1d 	      sta	IRQPending	; reset the irq pending
    538  0430		       8d f2 1d 	      sta	IRQStatus	; Make sure irqs are off
    539  0433
    540  0433		       4c bb 02    goodExit   jmp	NextIL
    541  0436							;
    542  0436							;=====================================================
    543  0436							; This check if the escape key has been entered
    544  0436							; then changes out of run mode. z Set if esc found
    545  0436				   BreakSet
    546  0436		       20 0f f0 	      jsr	ISCHAR
    547  0439		       f0 06		      beq	BreakNo
    548  043b		       20 08 17 	      jsr	VGETCH
    549  043e		       c9 1b		      cmp	#$1B
    550  0440		       60		      rts
    551  0441				   BreakNo
    552  0441		       a9 01		      lda	#1
    553  0443		       60		      rts
    554  0444
    555  0444							;
    556  0444
    557  0444							;=====================================================
    558  0444							; Verify there is nothing else on this input line.
    559  0444							; If there is, generate an error.
    560  0444							;
    561  0444		       a4 51	   iDONE      ldy	CUROFF
    562  0446		       20 b3 15 	      jsr	SkipSpaces
    563  0449		       b1 4f		      lda	(CURPTR),y
    564  044b		       f0 10		      beq	doneadv
    565  044d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    566  044f		       d0 05		      bne	idoneErr
    567  0451		       84 51		      sty	CUROFF
    568  0453		       4c bb 02 	      jmp	NextIL	; continue on this line
    569  0456
    570  0456				   idoneErr
    571  0456		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  0458		       a9 00		      lda	#0
    573  045a		       4c 18 06 	      jmp	iErr2
    574  045d							;
    575  045d							; Advance to the next line
    576  045d							;
    577  045d				   doneadv
    578  045d							;		 jsr	 FindNext2
    579  045d		       4c bb 02 	      jmp	NextIL
    580  0460							;
    581  0460							;=====================================================
    582  0460							; Print the string until a closing quote
    583  0460							;
    584  0460		       a4 51	   iPRS       ldy	CUROFF
    585  0462							;
    586  0462							; Odd logic here.  The main loop skipped any leading
    587  0462							; whitespace inside the quoted text, so move back to
    588  0462							; the quote, then move forward again.
    589  0462							;
    590  0462		       20 35 17 	      jsr	PrtQuoted
    591  0465		       84 51		      sty	CUROFF
    592  0467		       4c bb 02 	      jmp	NextIL
    593  046a							;
    594  046a							;=====================================================
    595  046a							; Pop the top off the stack and print it as a signed
    596  046a							; decimal number.
    597  046a							;
    598  046a		       20 03 15    iPRN       jsr	popR0
    599  046d		       20 00 0d 	      jsr	PrintDecimal
    600  0470		       4c bb 02 	      jmp	NextIL
    601  0473							;
    602  0473							;=====================================================
    603  0473							; Space to next zone.	Currently the code does not
    604  0473							; keep track of which column the output is on, so
    605  0473							; just print a tab.
    606  0473							;
    607  0473		       a9 09	   iSPC       lda	#TAB
    608  0475		       20 05 17 	      jsr	VOUTCH
    609  0478		       4c bb 02 	      jmp	NextIL
    610  047b							;
    611  047b							;=====================================================
    612  047b							; If in immediate mode, jump to the address following
    613  047b							; the NXT instruction.  Else move to the next line of
    614  047b							; user code and continue.
    615  047b							;
    616  047b		       a5 5b	   iNXT       lda	RunMode
    617  047d		       d0 03		      bne	iNxtRun	;in run mode
    618  047f							;
    619  047f							; Get address and jump to it.
    620  047f							;
    621  047f		       4c 2a 09 	      jmp	iJMP
    622  0482							;
    623  0482				   iNxtRun
    624  0482		       a4 51		      ldy	CUROFF
    625  0484		       20 b3 15 	      jsr	SkipSpaces
    626  0487		       b1 4f		      lda	(CURPTR),y
    627  0489		       c9 3a		      cmp	#COLON
    628  048b		       d0 09		      bne	iNxtRunGo
    629  048d		       c8		      iny
    630  048e		       20 b3 15 	      jsr	SkipSpaces
    631  0491		       84 51		      sty	CUROFF
    632  0493		       4c a1 04 	      jmp	iNxtRun2
    633  0496
    634  0496				   iNxtRunGo
    635  0496		       20 10 13 	      jsr	FindNextLine
    636  0499		       20 24 13 	      jsr	AtEnd
    637  049c		       d0 03		      bne	iNxtRun2	;not at end
    638  049e							;
    639  049e							; At the end of the program.  Pretend an END statement
    640  049e							; was found.
    641  049e							;
    642  049e		       4c 01 06    iFINv      jmp	iFIN
    643  04a1							;
    644  04a1		       20 82 12    iNxtRun2   jsr	getILWord	;ignore next word
    645  04a4		       4c bb 02 	      jmp	NextIL
    646  04a7							;
    647  04a7							;=====================================================
    648  04a7							; XFER takes the number on top of the stack and looks
    649  04a7							; for that line in the program, or the next line
    650  04a7							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04a7							; find the next one after that.
    652  04a7							;
    653  04a7		       20 03 15    iXFER      jsr	popR0
    654  04aa		       20 cb 12 	      jsr	findLine
    655  04ad		       20 24 13    iXFER2     jsr	AtEnd	;at end of user program?
    656  04b0		       f0 ec		      beq	iFINv
    657  04b2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    658  04b4		       84 51		      sty	CUROFF
    659  04b6		       a9 ff		      lda	#$ff
    660  04b8		       85 5b		      sta	RunMode
    661  04ba							;
    662  04ba							; Transfer IL to STMT.  I don't like having this
    663  04ba							; hard-coded; fix it.
    664  04ba							;
    665  04ba		       a9 23		      lda	#STMT&$ff
    666  04bc		       85 43		      sta	ILPC
    667  04be		       a9 19		      lda	#STMT>>8
    668  04c0		       85 44		      sta	ILPC+1
    669  04c2		       4c bb 02 	      jmp	NextIL
    670  04c5							;
    671  04c5							; Run
    672  04c5							;
    673  04c5				   iXferok
    674  04c5		       a9 ff		      lda	#$ff
    675  04c7		       85 5b		      sta	RunMode	;we're running
    676  04c9							;
    677  04c9							; Need a more elegant way to do this
    678  04c9							;
    679  04c9		       a9 23		      lda	#STMT&$ff
    680  04cb		       85 43		      sta	ILPC
    681  04cd		       a9 19		      lda	#STMT>>8
    682  04cf		       85 44		      sta	ILPC+1
    683  04d1		       4c bb 02 	      jmp	NextIL
    684  04d4							;
    685  04d4							;=====================================================
    686  04d4							; Save the pointer to the next line to the call stack.
    687  04d4							;
    688  04d4		       20 99 14    iSAV       jsr	pushLN
    689  04d7		       b0 03		      bcs	iSAVErr
    690  04d9		       4c bb 02 	      jmp	NextIL
    691  04dc
    692  04dc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04de		       a9 00	   iSAVErr2   lda	#0
    694  04e0		       4c 18 06 	      jmp	iErr2
    695  04e3							;====================================================
    696  04e3							; Move stack top to and from temp area
    697  04e3				   iStk2Tmp
    698  04e3		       20 03 15 	      jsr	popR0
    699  04e6		       a5 52		      lda	R0
    700  04e8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04ea		       91 41		      sta	(VARIABLES),y
    702  04ec		       c8		      iny
    703  04ed		       a5 53		      lda	R0+1
    704  04ef		       91 41		      sta	(VARIABLES),y
    705  04f1		       4c bb 02 	      jmp	NextIL
    706  04f4
    707  04f4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  04f6		       b1 41		      lda	(VARIABLES),y
    709  04f8		       85 52		      sta	R0
    710  04fa		       c8		      iny
    711  04fb		       b1 41		      lda	(VARIABLES),y
    712  04fd		       85 53		      sta	R0+1
    713  04ff		       20 7f 14 	      jsr	pushR0
    714  0502		       4c bb 02 	      jmp	NextIL
    715  0505							;
    716  0505							;=====================================================
    717  0505							; Pop the next line from the call stack.
    718  0505							;
    719  0505		       20 be 14    iRET       jsr	popLN
    720  0508		       b0 d2		      bcs	iSAVErr
    721  050a		       a0 03		      ldy	#3
    722  050c		       84 51		      sty	CUROFF
    723  050e		       a9 00		      lda	#0
    724  0510		       8d f3 1d 	      sta	IRQPending
    725  0513		       58		      cli
    726  0514		       4c bb 02 	      jmp	NextIL
    727  0517							;
    728  0517							;=====================================================
    729  0517							; Return from GOSUB function
    730  0517							;
    731  0517		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    732  0519		       f0 0f		      beq	iRSTRNoValue
    733  051b		       a5 58		      lda	R2
    734  051d		       85 56		      sta	MQ
    735  051f		       88		      dey
    736  0520		       b1 4b		      lda	(GOSUBSTACK),y
    737  0522		       c9 81		      cmp	#GOSUB_RTN_VALUE
    738  0524		       d0 04		      bne	iRSTRNoValue
    739  0526		       a9 01		      lda	#1
    740  0528		       d0 02		      bne	iRSTRExit
    741  052a				   iRSTRNoValue
    742  052a		       a9 00		      lda	#0
    743  052c				   iRSTRExit
    744  052c		       85 58		      sta	R2
    745  052e		       20 be 14 	      jsr	popLN
    746  0531		       b0 06		      bcs	iRSTRErr
    747  0533		       20 52 0e 	      jsr	PopMathStackNow
    748  0536		       4c bb 02 	      jmp	NextIL
    749  0539
    750  0539		       ad f6 1d    iRSTRErr   lda	taskPtr	; Check if this is task zero
    751  053c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    752  053e		       a5 56		      lda	MQ
    753  0540		       d0 03		      bne	taskRet
    754  0542		       20 79 17 	      jsr	pushFalse	; the result code by default is 0
    755  0545				   taskRet
    756  0545		       4c cf 10 	      jmp	iETask	; not task zero then do a task end instead
    757  0548				   taskZeroEnd
    758  0548		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    759  054a		       d0 92		      bne	iSAVErr2
    760  054c							;
    761  054c							;=====================================================
    762  054c							; Compare items on stack.  Okay, so on input there are
    763  054c							; three things on the stack
    764  054c							;
    765  054c							;    EXPR2 <- Top of stack
    766  054c							;    OP    <- relational operator, next on stack
    767  054c							;    EXPR1 <- last item on stack
    768  054c							;
    769  054c							; Comparison is: EXPR1 <operator> EXPR2
    770  054c							;
    771  054c							; Operator is one of...
    772  054c							;
    773  054c							;    2 is =
    774  054c							;    1 is <
    775  054c							;    3 is <=
    776  054c							;    5 is <>
    777  054c							;    4 is >
    778  054c							;    6 is >=
    779  054c							;
    780  054c							; Those are bit-mapped:
    781  054c							;
    782  054c							;    xxxxxGEL
    783  054c							;
    784  054c							;    G = Greater than
    785  054c							;    E = Equal
    786  054c							;    L = Less than
    787  054c							;
    788  054c							; If the comparison is false, do a NXT, ie, move to the
    789  054c							; next line and continue.  If true, continue executing
    790  054c							; on this line.
    791  054c							;
    792  054c		       00 01	   REL_LT     equ	%001
    793  054c		       00 02	   REL_EQUAL  equ	%010
    794  054c		       00 04	   REL_GT     equ	%100
    795  054c							;
    796  054c		       20 1b 15    iCMPR      jsr	popR1
    797  054f		       20 32 15 	      jsr	popMQ	;operator in MQ
    798  0552		       20 03 15 	      jsr	popR0
    799  0555		       20 5e 05 	      jsr	iCMPRsub
    800  0558		       20 7f 14 	      jsr	pushR0
    801  055b		       4c bb 02 	      jmp	NextIL
    802  055e							;
    803  055e							; See if they are equal or not
    804  055e							;
    805  055e				   iCMPRsub		; Called by internal functions
    806  055e
    807  055e		       a5 52		      lda	R0
    808  0560		       c5 54		      cmp	R1
    809  0562		       d0 0a		      bne	iCMPRnoteq	;try not equal
    810  0564		       a5 53		      lda	R0+1
    811  0566		       c5 55		      cmp	R1+1
    812  0568		       d0 04		      bne	iCMPRnoteq
    813  056a							;
    814  056a							; Equal, set the flag in MQ+1
    815  056a							;
    816  056a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    817  056c		       d0 14		      bne	iCMPcom	;Exit it is equal
    818  056e							;
    819  056e							; See if EXPR1 (R0) < EXPR2 (R1)
    820  056e							; See www.6502.org/tutorials/compare_beyond.html
    821  056e							;
    822  056e				   iCMPRnoteq
    823  056e		       a5 52		      lda	R0
    824  0570		       c5 54		      cmp	R1
    825  0572		       a5 53		      lda	R0+1
    826  0574		       e5 55		      sbc	R1+1
    827  0576		       50 02		      bvc	iCMPR_2
    828  0578		       49 80		      eor	#$80
    829  057a		       30 04	   iCMPR_2    bmi	iCMPlt
    830  057c		       a9 04		      lda	#REL_GT
    831  057e		       d0 02		      bne	iCMPcom
    832  0580		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    833  0582
    834  0582		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    835  0584							;
    836  0584							; Now compare the end result with what the caller
    837  0584							; was looking for.
    838  0584							;
    839  0584		       25 56		      and	MQ
    840  0586		       f0 0c		      beq	iCMPno	; no match
    841  0588		       a9 ff		      lda	#$FF	; true is $ffff
    842  058a		       85 52		      sta	R0
    843  058c		       85 53		      sta	R0+1
    844  058e		       d0 0c		      bne	iCMPDone
    845  0590							;
    846  0590							; R0 > R1
    847  0590							;
    848  0590		       a9 04	   iCMPgt     lda	#REL_GT
    849  0592		       d0 ee		      bne	iCMPcom
    850  0594				   iCMPno
    851  0594		       a9 00		      lda	#0
    852  0596		       85 52		      sta	R0
    853  0598		       a9 00		      lda	#0
    854  059a		       85 53		      sta	R0+1
    855  059c
    856  059c				   iCMPDone
    857  059c		       60		      rts
    858  059d
    859  059d							;
    860  059d							; if Not a match, so jump to the next line of code.
    861  059d							; Branches based upon value on top of the stack
    862  059d				   iBranch
    863  059d		       20 03 15 	      jsr	popR0
    864  05a0		       a5 52		      lda	R0
    865  05a2		       05 53		      ora	R0+1
    866  05a4		       f0 03		      beq	iBranchFalse	; not true
    867  05a6		       4c bb 02 	      jmp	NextIL	; It is true if any value not zero
    868  05a9							;
    869  05a9				   iBranchFalse
    870  05a9		       20 10 13 	      jsr	FindNextLine
    871  05ac		       4c ad 04 	      jmp	iXFER2
    872  05af							;
    873  05af							;=====================================================
    874  05af							; Start a read of data in background
    875  05af				   iReadStart
    876  05af		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05b1		       a6 01		      ldx	1	; Indicate to start read in background
    878  05b3		       20 9c 13 	      jsr	GetLine	; Call the getline to start read
    879  05b6		       4c bb 02 	      jmp	NextIL	; next instruction
    880  05b9							;
    881  05b9							;=====================================================
    882  05b9							; Complete the read and return the curptr, curoff pointing to data
    883  05b9				   iReadComplete
    884  05b9		       20 99 14 	      jsr	pushLN
    885  05bc		       90 03		      bcc	iReadOk
    886  05be		       4c 5c 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    887  05c1				   iReadOk
    888  05c1		       20 bc 13 	      jsr	ReadComplete
    889  05c4		       4c bb 02 	      jmp	NextIL
    890  05c7		       20 be 14 	      jsr	popLN
    891  05ca		       4c bb 02 	      jmp	NextIL
    892  05cd							;=====================================================
    893  05cd							; Get a line of text from the user, convert to a
    894  05cd							; number, leave on top of stack.
    895  05cd							;
    896  05cd				   iINNUM
    897  05cd		       20 99 14 	      jsr	pushLN
    898  05d0		       b0 ec		      bcs	iReadErr	; Stack over flow error
    899  05d2							;
    900  05d2		       a9 3f		      lda	#'?
    901  05d4		       a2 00		      ldx	#0	;Wait for complete
    902  05d6		       20 9c 13 	      jsr	GetLine
    903  05d9		       20 31 13 	      jsr	getDecimal
    904  05dc		       20 7f 14 	      jsr	pushR0	;put onto stack
    905  05df		       b0 dd		      bcs	iReadErr	;StackOverflow error
    906  05e1							;
    907  05e1		       4c fb 05 	      jmp	ExitIn
    908  05e4							;
    909  05e4							;=====================================================
    910  05e4							; Get a line of text from the user, convert to a
    911  05e4							; character value , leave on top of stack. up to 2 characters
    912  05e4							;
    913  05e4				   iINSTR
    914  05e4		       20 99 14 	      jsr	pushLN
    915  05e7		       b0 d5		      bcs	iReadErr	; Stack overflow error
    916  05e9		       a9 3f		      lda	#'?
    917  05eb		       a2 00		      ldx	#0	;wait for read complete
    918  05ed		       20 9c 13 	      jsr	GetLine
    919  05f0		       b1 4f		      lda	(CURPTR),y
    920  05f2		       85 52		      sta	R0
    921  05f4		       a9 00		      lda	#0
    922  05f6		       85 53		      sta	R0+1
    923  05f8		       20 7f 14 	      jsr	pushR0	;put onto stack
    924  05fb				   ExitIn
    925  05fb		       20 be 14 	      jsr	popLN
    926  05fe		       4c bb 02 	      jmp	NextIL
    927  0601							;
    928  0601							;
    929  0601							;=====================================================
    930  0601							; Stop the currently running program.	Actually very
    931  0601							; simple to do... clear the RunMode flag, then set the
    932  0601							; ILPC to the standard handler and continue running.
    933  0601							;
    934  0601		       a9 00	   iFIN       lda	#0
    935  0603		       85 5b		      sta	RunMode
    936  0605		       20 27 0f 	      jsr	taskReset
    937  0608							;
    938  0608		       ad 3c 27 	      lda	errGoto
    939  060b		       85 43		      sta	ILPC
    940  060d		       ad 3d 27 	      lda	errGoto+1
    941  0610		       85 44		      sta	ILPC+1
    942  0612		       4c bb 02 	      jmp	NextIL
    943  0615							;
    944  0615							;=====================================================
    945  0615							; Handle the ERR opcode.  Following the instruction is
    946  0615							; a 16 bit error number.  Print an error message, and
    947  0615							; if we're in run mode, print the line number.  Stop
    948  0615							; program execution and return to the initial state.
    949  0615							;
    950  0615		       20 82 12    iERR       jsr	getILWord	;get err code
    951  0618							;
    952  0618							; Enter here with the error code in X (LSB) and A (MSB).
    953  0618							;
    954  0618		       86 52	   iErr2      stx	R0
    955  061a		       85 53		      sta	R0+1
    956  061c							;
    957  061c		       20 0b 17 	      jsr	puts
      0  061f					      db	CR,LF,"Error ",0
      1  061f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    959  0628		       20 00 0d 	      jsr	PrintDecimal
    960  062b							;
    961  062b		       a5 5b		      lda	RunMode	;running?
    962  062d		       f0 3b		      beq	iERR3	;nope
    963  062f		       20 0b 17 	      jsr	puts
      0  0632					      db	" at line ",0
      1  0632		       20 61 74 20*	      .byte.b	" at line ",0
    965  063c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    966  063e				   iErr2a
    967  063e		       b1 4f		      lda	(CURPTR),y
    968  0640		       85 52		      sta	R0
    969  0642		       c8		      iny
    970  0643		       b1 4f		      lda	(CURPTR),y
    971  0645		       85 53		      sta	R0+1
    972  0647		       20 00 0d 	      jsr	PrintDecimal
    973  064a		       20 0b 17 	      jsr	puts
      0  064d					      db	":",0
      1  064d		       3a 00		      .byte.b	":",0
    975  064f		       a9 00		      lda	#0
    976  0651		       85 53		      sta	R0+1
    977  0653		       a5 51		      lda	CUROFF
    978  0655		       18		      clc
    979  0656		       e9 03		      sbc	#3
    980  0658		       85 52		      sta	R0
    981  065a		       20 00 0d 	      jsr	PrintDecimal
    982  065d		       20 0b 17 	      jsr	puts
      0  0660					      db	":",0
      1  0660		       3a 00		      .byte.b	":",0
    984  0662		       ad f6 1d 	      lda	taskPtr
    985  0665		       85 52		      sta	R0
    986  0667		       20 00 0d 	      jsr	PrintDecimal
    987  066a							;
    988  066a		       20 bc 15    iERR3      jsr	CRLF
    989  066d		       20 1f 0f 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    990  0670		       a9 00		      lda	#0
    991  0672		       85 5b		      sta	RunMode	;fall through...
    992  0674							;
    993  0674							;=====================================================
    994  0674							; Reset the IL to be back at the idle loop.  Does not
    995  0674							; clear variables so the user can see what state
    996  0674							; the program is in.
    997  0674							;
    998  0674		       a9 00	   ResetIL    lda	#0
    999  0676		       85 47		      sta	ILSTACKPTR
   1000  0678		       ad 3c 27 	      lda	errGoto
   1001  067b		       85 43		      sta	ILPC
   1002  067d		       ad 3d 27 	      lda	errGoto+1
   1003  0680		       85 44		      sta	ILPC+1
   1004  0682		       4c bb 02 	      jmp	NextIL
   1005  0685
   1006  0685							;
   1007  0685							;=====================================================
   1008  0685							; Pop two items off stack, add them, then place the
   1009  0685							; result back onto the stack.
   1010  0685							;
   1011  0685		       20 03 15    iADD       jsr	popR0
   1012  0688		       20 1b 15 	      jsr	popR1
   1013  068b				   iADDfast
   1014  068b		       18		      clc
   1015  068c		       a5 52		      lda	R0
   1016  068e		       65 54		      adc	R1
   1017  0690		       85 52		      sta	R0
   1018  0692		       a5 53		      lda	R0+1
   1019  0694		       65 55		      adc	R1+1
   1020  0696		       85 53		      sta	R0+1
   1021  0698		       4c 03 07 	      jmp	pushR0nextIl
   1022  069b							;
   1023  069b							;=====================================================
   1024  069b							; Pop two items off the stack.  Subtract the top of
   1025  069b							; stack from the lower entry.
   1026  069b							;
   1027  069b		       20 1b 15    iSUB       jsr	popR1
   1028  069e		       20 03 15 	      jsr	popR0
   1029  06a1		       38		      sec
   1030  06a2		       a5 52		      lda	R0
   1031  06a4		       e5 54		      sbc	R1
   1032  06a6		       85 52		      sta	R0
   1033  06a8		       a5 53		      lda	R0+1
   1034  06aa		       e5 55		      sbc	R1+1
   1035  06ac		       85 53		      sta	R0+1
   1036  06ae		       4c 03 07 	      jmp	pushR0nextIl
   1037  06b1							;
   1038  06b1							;=====================================================
   1039  06b1							; Negate the top of stack.
   1040  06b1							;
   1041  06b1		       20 03 15    iNEG       jsr	popR0
   1042  06b4		       a5 52		      lda	R0
   1043  06b6		       49 ff		      eor	#$ff
   1044  06b8		       85 52		      sta	R0
   1045  06ba		       a5 53		      lda	R0+1
   1046  06bc		       49 ff		      eor	#$ff
   1047  06be		       85 53		      sta	R0+1
   1048  06c0		       e6 52		      inc	R0
   1049  06c2		       d0 02		      bne	iNEG2
   1050  06c4		       e6 53		      inc	R0+1
   1051  06c6		       4c 03 07    iNEG2      jmp	pushR0nextIl
   1052  06c9							;
   1053  06c9							;=====================================================
   1054  06c9							; Multiply top two items on the stack, put the results
   1055  06c9							; on top.  This uses the algorithm documented on page
   1056  06c9							; 115 of "Microprocessor Programming for Computer
   1057  06c9							; Hobbyists" by Neill Graham.
   1058  06c9							;
   1059  06c9		       20 cf 06    iMUL       jsr	iMultiply
   1060  06cc		       4c bb 02 	      jmp	NextIL
   1061  06cf
   1062  06cf				   iMultiply
   1063  06cf		       20 03 15 	      jsr	popR0	;AC
   1064  06d2		       20 1b 15 	      jsr	popR1	;OP
   1065  06d5							;
   1066  06d5		       a5 52		      lda	R0
   1067  06d7		       85 56		      sta	MQ
   1068  06d9		       a5 53		      lda	R0+1
   1069  06db		       85 57		      sta	MQ+1
   1070  06dd		       a9 00		      lda	#0	;clear result
   1071  06df		       85 52		      sta	R0
   1072  06e1		       85 53		      sta	R0+1
   1073  06e3							;
   1074  06e3		       a2 10		      ldx	#16	;number of bits in value
   1075  06e5		       06 52	   multloop   asl	R0
   1076  06e7		       26 53		      rol	R0+1
   1077  06e9		       06 56		      asl	MQ
   1078  06eb		       26 57		      rol	MQ+1
   1079  06ed		       90 0d		      bcc	multno	;skip add if no carry
   1080  06ef							;
   1081  06ef							; Add R1 back into R0
   1082  06ef							;
   1083  06ef		       18		      clc
   1084  06f0		       a5 52		      lda	R0
   1085  06f2		       65 54		      adc	R1
   1086  06f4		       85 52		      sta	R0
   1087  06f6		       a5 53		      lda	R0+1
   1088  06f8		       65 55		      adc	R1+1
   1089  06fa		       85 53		      sta	R0+1
   1090  06fc							;
   1091  06fc		       ca	   multno     dex		;did all bits yet?
   1092  06fd		       d0 e6		      bne	multloop
   1093  06ff		       20 7f 14 	      jsr	pushR0	;OP
   1094  0702		       60		      rts
   1095  0703							;
   1096  0703				   pushR0nextIl
   1097  0703		       20 7f 14 	      jsr	pushR0	;OP
   1098  0706		       4c bb 02 	      jmp	NextIL
   1099  0709							;
   1100  0709							;=====================================================
   1101  0709							; Divide the top of stack into the next to top item.
   1102  0709							; Leave results on stack.  Taken from:
   1103  0709							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1104  0709							;
   1105  0709							; R0 = R0 / R1
   1106  0709							; Remainder is in MQ
   1107  0709							;
   1108  0709		       20 23 07    iDIV       jsr	iDoDiv
   1109  070c		       20 84 15 	      jsr	RestoreSigns
   1110  070f		       4c 03 07 	      jmp	pushR0nextIl
   1111  0712
   1112  0712		       20 23 07    iMOD       jsr	iDoDiv
   1113  0715		       20 84 15 	      jsr	RestoreSigns
   1114  0718		       a5 56		      lda	MQ
   1115  071a		       85 52		      sta	R0
   1116  071c		       a5 57		      lda	MQ+1
   1117  071e		       85 53		      sta	R0+1
   1118  0720		       4c 03 07 	      jmp	pushR0nextIl
   1119  0723
   1120  0723				   iDoDiv
   1121  0723		       20 1b 15 	      jsr	popR1
   1122  0726		       20 03 15 	      jsr	popR0
   1123  0729							;
   1124  0729							; Check for divide by zero
   1125  0729							;
   1126  0729
   1127  0729				   iDivNoPop
   1128  0729		       a5 54		      lda	R1
   1129  072b		       05 55		      ora	R1+1
   1130  072d		       f0 29		      beq	divby0
   1131  072f							;
   1132  072f		       20 49 15 	      jsr	SaveSigns
   1133  0732		       a9 00		      lda	#0	;preset remainder to 0
   1134  0734		       85 56		      sta	MQ
   1135  0736		       85 57		      sta	MQ+1
   1136  0738		       a2 10		      ldx	#16	;repeat for each bit: ...
   1137  073a				   divloop
   1138  073a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1139  073c		       26 53		      rol	R0+1
   1140  073e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1141  0740		       26 57		      rol	MQ+1
   1142  0742		       a5 56		      lda	MQ
   1143  0744		       38		      sec
   1144  0745		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1145  0747		       a8		      tay		;lb result -> Y, for we may need it later
   1146  0748		       a5 57		      lda	MQ+1
   1147  074a		       e5 55		      sbc	R1+1
   1148  074c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1149  074e
   1150  074e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1151  0750		       84 56		      sty	MQ
   1152  0752		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1153  0754
   1154  0754		       ca	   skip       dex
   1155  0755		       d0 e3		      bne	divloop
   1156  0757		       60		      rts
   1157  0758							;
   1158  0758							; Indicate divide-by-zero error
   1159  0758							;
   1160  0758		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1161  075a		       a9 00		      lda	#0
   1162  075c		       4c 18 06 	      jmp	iErr2
   1163  075f							;
   1164  075f							;=====================================================
   1165  075f							; This pops the top two items off the stack.  The top
   1166  075f							; item is a data value and the other is an ABSOLUTE address.
   1167  075f							;Save the value into that address.
   1168  075f							;
   1169  075f		       98	   iSTORE     tya
   1170  0760		       48		      pha
   1171  0761		       20 03 15 	      jsr	popR0	;data
   1172  0764		       20 1b 15 	      jsr	popR1	;Storage location
   1173  0767		       a0 00		      ldy	#0
   1174  0769		       a5 52		      lda	R0
   1175  076b		       91 54		      sta	(R1),y
   1176  076d		       a5 53		      lda	R0+1
   1177  076f		       c8		      iny
   1178  0770		       91 54		      sta	(R1),y
   1179  0772		       68		      pla
   1180  0773		       a8		      tay
   1181  0774		       4c bb 02 	      jmp	NextIL
   1182  0777							;
   1183  0777							;=====================================================
   1184  0777							; Replaces the top of stack with the variable whose
   1185  0777							; absolute address it represents.
   1186  0777							;
   1187  0777		       98	   iIND       tya
   1188  0778		       48		      pha
   1189  0779		       20 1b 15 	      jsr	popR1
   1190  077c		       a0 00		      ldy	#0
   1191  077e		       b1 54		      lda	(R1),y
   1192  0780		       85 52		      sta	R0
   1193  0782		       c8		      iny
   1194  0783		       b1 54		      lda	(R1),y
   1195  0785		       85 53		      sta	R0+1
   1196  0787		       68		      pla
   1197  0788		       a8		      tay
   1198  0789		       4c 03 07 	      jmp	pushR0nextIl
   1199  078c							;
   1200  078c							;=====================================================
   1201  078c							; Get the array index from top of stack get Current variable
   1202  078c							; address from next on stack, add the offset
   1203  078c							; push the result back onto the stack
   1204  078c				   iArray
   1205  078c		       20 03 15 	      jsr	popR0	; Get the array index
   1206  078f		       20 1b 15 	      jsr	popR1	; Get the Variable address
   1207  0792
   1208  0792		       18		      clc		; Multiplythe value by 2
   1209  0793		       26 52		      rol	R0	; Do the multiply
   1210  0795		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1211  0797		       18		      clc
   1212  0798		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1213  079a		       65 52		      adc	R0
   1214  079c		       85 52		      sta	R0
   1215  079e		       a5 55		      lda	R1+1
   1216  07a0		       65 53		      adc	R0+1
   1217  07a2		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1218  07a4		       20 7f 14 	      jsr	pushR0	; Push R0 assume it is correct
   1219  07a7
   1220  07a7		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1221  07a9		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1222  07ab		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1223  07ad		       a5 55		      lda	R1+1
   1224  07af		       c5 42		      cmp	VARIABLES+1
   1225  07b1		       d0 1c		      bne	iArrayAtTest
   1226  07b3		       18		      clc
   1227  07b4		       a9 34		      lda	#52	; add the max offset that is valid
   1228  07b6		       65 54		      adc	R1	; update to be the largest offset that is valid
   1229  07b8		       85 54		      sta	R1
   1230  07ba		       a9 00		      lda	#0
   1231  07bc		       65 55		      adc	R1+1
   1232  07be		       85 55		      sta	R1+1
   1233  07c0				   iArrayVerify 		; try to enforce some sanity to using arrays
   1234  07c0		       a5 53		      lda	R0+1
   1235  07c2		       c5 55		      cmp	R1+1
   1236  07c4		       d0 04		      bne	iArrayDecide
   1237  07c6		       a5 52		      lda	R0
   1238  07c8		       c5 54		      cmp	R1
   1239  07ca				   iArrayDecide
   1240  07ca		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1241  07cc		       4c bb 02 	      jmp	NextIL
   1242  07cf
   1243  07cf				   iArrayAtTest
   1244  07cf		       ad 53 27 	      lda	HighMem
   1245  07d2		       85 54		      sta	R1
   1246  07d4		       ad 54 27 	      lda	HighMem+1
   1247  07d7		       85 55		      sta	R1+1
   1248  07d9		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1249  07db
   1250  07db							; Get here if array index is out of range
   1251  07db		       20 03 15    iArrayError jsr	popR0
   1252  07de		       a9 00		      lda	#0
   1253  07e0		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1254  07e2		       4c 18 06 	      jmp	iErr2
   1255  07e5							;
   1256  07e5							;=====================================================
   1257  07e5							; List the current BASIC program in memory.  Uses R0,
   1258  07e5							; tempIly, and dpl.
   1259  07e5							;
   1260  07e5		       20 eb 16    iLST       jsr	SetOutConsole
   1261  07e8		       ad 4f 27    iLST2      lda	ProgramStart
   1262  07eb		       85 59		      sta	dpl
   1263  07ed		       ad 50 27 	      lda	ProgramStart+1
   1264  07f0		       85 5a		      sta	dpl+1
   1265  07f2							;
   1266  07f2							; dpl/dph point to the current line.  See if we're at
   1267  07f2							; the end of the program.
   1268  07f2							;
   1269  07f2		       a5 59	   iLSTloop   lda	dpl
   1270  07f4		       cd 51 27 	      cmp	ProgramEnd
   1271  07f7		       d0 07		      bne	iLstNotEnd
   1272  07f9		       a5 5a		      lda	dpl+1
   1273  07fb		       cd 52 27 	      cmp	ProgramEnd+1
   1274  07fe		       f0 44		      beq	iLstdone
   1275  0800							;
   1276  0800		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1277  0802		       b1 59		      lda	(dpl),y	;line number LSB
   1278  0804		       85 52		      sta	R0
   1279  0806		       c8		      iny
   1280  0807		       b1 59		      lda	(dpl),y	;line number MSB
   1281  0809		       85 53		      sta	R0+1
   1282  080b		       c8		      iny
   1283  080c		       8c 4a 27 	      sty	tempIlY
   1284  080f		       20 00 0d 	      jsr	PrintDecimal
   1285  0812		       a9 20		      lda	#SPACE
   1286  0814		       20 05 17 	      jsr	VOUTCH
   1287  0817		       ac 4a 27 	      ldy	tempIlY
   1288  081a		       b1 59	   iLSTl2     lda	(dpl),y
   1289  081c		       f0 0c		      beq	iLST3	;end of this line 0 value
   1290  081e		       8c 4a 27 	      sty	tempIlY
   1291  0821		       20 05 17 	      jsr	VOUTCH
   1292  0824		       ac 4a 27 	      ldy	tempIlY
   1293  0827		       c8		      iny
   1294  0828		       d0 f0		      bne	iLSTl2	;do next char
   1295  082a							;
   1296  082a							; End of this line.  Print CR/LF, then move to the
   1297  082a							; next line.
   1298  082a							;
   1299  082a		       c8	   iLST3      iny		;Move to next line
   1300  082b		       18		      clc		;Clear the carry flag
   1301  082c		       98		      tya		;Current Offset
   1302  082d		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  082f		       85 59		      sta	dpl	;Save the new value
   1304  0831		       a5 5a		      lda	dpl+1	;Next byte
   1305  0833		       69 00		      adc	#0	;ad in the carry if any
   1306  0835		       85 5a		      sta	dpl+1	;Save it
   1307  0837							;
   1308  0837							; Have to manually do CR/LF so it uses the vectored
   1309  0837							; output function.
   1310  0837							;
   1311  0837		       a9 0d		      lda	#CR
   1312  0839		       20 05 17 	      jsr	VOUTCH
   1313  083c		       a9 0a		      lda	#LF
   1314  083e		       20 05 17 	      jsr	VOUTCH
   1315  0841		       4c f2 07 	      jmp	iLSTloop	;do next line
   1316  0844							;
   1317  0844		       20 eb 16    iLstdone   jsr	SetOutConsole
   1318  0847		       4c bb 02 	      jmp	NextIL
   1319  084a							;
   1320  084a							;=====================================================
   1321  084a							; Get a line of text into LINBUF.  Terminate with a
   1322  084a							; null byte.
   1323  084a							;
   1324  084a				   iGETLINE
   1325  084a		       a9 3e		      lda	#'>	;prompt character
   1326  084c		       a6 00		      ldx	0	;Wait for read to complete
   1327  084e		       20 9c 13 	      jsr	GetLine
   1328  0851							;
   1329  0851		       a9 00		      lda	#0
   1330  0853		       85 5b		      sta	RunMode
   1331  0855		       4c bb 02 	      jmp	NextIL
   1332  0858							;
   1333  0858							;=====================================================
   1334  0858							; This is called when the input buffer contains a line
   1335  0858							; typed in by the user that starts with a line number.
   1336  0858							; Insert the line into the program or delete the line
   1337  0858							; if there is nothing after the line number,
   1338  0858							;
   1339  0858		       a0 00	   iINSRT     ldy	#0
   1340  085a		       20 31 13 	      jsr	getDecimal	;convert line #
   1341  085d		       20 b3 15 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1342  0860		       8c 4b 27 	      sty	offset	;Save the start of the program line text
   1343  0863							;
   1344  0863							; Now find the line OR the next higher line OR the
   1345  0863							; end of the program.
   1346  0863							;
   1347  0863		       20 cb 12 	      jsr	findLine	; Look for the line number in the current program
   1348  0866							; Returns Z and curptr point to the line if found
   1349  0866							; Returns C and curptr at next higher line if not found and there is a higher line
   1350  0866							; Returns ZC clear and curptr to end of program if higher than all other lines
   1351  0866							;
   1352  0866							; If the line exists, it needs to be removed.
   1353  0866							;
   1354  0866		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1355  0868							;
   1356  0868							; Get length of line to be removed, we fall thru to here if we find a matching line
   1357  0868							;
   1358  0868							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1359  0868		       a0 00		      ldy	#0
   1360  086a		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1361  086c		       a8		      tay
   1362  086d							;If it is equal we delete the line and replace it, get length
   1363  086d							;then adjust all program line after up or down depending on len of line
   1364  086d							;If next higher then just move everythimg down by length bytes
   1365  086d							;This call will return how many bytes in the line we found
   1366  086d		       8c 4c 27 	      sty	lineLength	;Save the length of the line we found
   1367  0870							;
   1368  0870							; Compute the new end of the program first.
   1369  0870							;
   1370  0870		       38		      sec		;Set the carry bit
   1371  0871		       ad 51 27 	      lda	ProgramEnd	;Get low byte of program end
   1372  0874		       ed 4c 27 	      sbc	lineLength	;Subtract the length of the current line
   1373  0877		       8d 51 27 	      sta	ProgramEnd	;save it
   1374  087a		       ad 52 27 	      lda	ProgramEnd+1
   1375  087d		       e9 00		      sbc	#0	;Process the carry
   1376  087f		       8d 52 27 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1377  0882							;
   1378  0882							; Copy CURPTR into R1 for working
   1379  0882							;
   1380  0882		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1381  0884		       85 54		      sta	R1
   1382  0886		       a5 50		      lda	CURPTR+1
   1383  0888		       85 55		      sta	R1+1
   1384  088a							;
   1385  088a							; See if we're at the end.
   1386  088a							;
   1387  088a		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1388  088c		       cd 51 27 	      cmp	ProgramEnd
   1389  088f		       d0 07		      bne	InsDelLoop
   1390  0891		       a5 55		      lda	R1+1
   1391  0893		       cd 52 27 	      cmp	ProgramEnd+1
   1392  0896		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1393  0898							;
   1394  0898							; Move one byte, move to next location.
   1395  0898							;
   1396  0898		       ac 4c 27    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1397  089b		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1398  089d		       b1 54		      lda	(R1),y
   1399  089f		       a0 00		      ldy	#0
   1400  08a1		       91 54		      sta	(R1),y
   1401  08a3		       e6 54		      inc	R1
   1402  08a5		       d0 e3		      bne	InsDelChk
   1403  08a7		       e6 55		      inc	R1+1
   1404  08a9		       4c 8a 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1405  08ac							;
   1406  08ac							; Deletion is done.
   1407  08ac							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1408  08ac							;
   1409  08ac		       ac 4b 27    insert2    ldy	offset	; get back ptr  Get the current offset
   1410  08af		       b9 b2 26 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1411  08b2		       f0 5f		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1412  08b4							;
   1413  08b4							; CURPTR points to where the line will be inserted.
   1414  08b4							;
   1415  08b4		       20 56 14 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1416  08b7							;
   1417  08b7		       ad 51 27 	      lda	ProgramEnd	;Load the start address for the copy
   1418  08ba							;At this point curptr still contains the location we will insert data
   1419  08ba		       85 5c		      sta	FROM
   1420  08bc		       ad 52 27 	      lda	ProgramEnd+1
   1421  08bf		       85 5d		      sta	FROM+1
   1422  08c1							;
   1423  08c1		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1424  08c3		       b1 5c		      lda	(FROM),y
   1425  08c5		       ac 4c 27 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1426  08c8		       91 5c		      sta	(FROM),y	;Save the new byte
   1427  08ca							;
   1428  08ca		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1429  08cc		       c5 4f		      cmp	CURPTR
   1430  08ce		       d0 06		      bne	mvUpMore
   1431  08d0		       a5 5d		      lda	FROM+1
   1432  08d2		       c5 50		      cmp	CURPTR+1
   1433  08d4		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1434  08d6							;
   1435  08d6							; Not done yet
   1436  08d6							;
   1437  08d6		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1438  08d8		       d0 02		      bne	mvUpMore2
   1439  08da		       c6 5d		      dec	FROM+1
   1440  08dc		       c6 5c	   mvUpMore2  dec	FROM
   1441  08de		       4c c1 08 	      jmp	mvup1	;Loop until everything is moved
   1442  08e1							;
   1443  08e1							; All done with copy.
   1444  08e1							;
   1445  08e1				   mvUpDone
   1446  08e1		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1447  08e2		       ad 4c 27 	      lda	lineLength	;Number of bytes to copy from line buff
   1448  08e5		       6d 51 27 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1449  08e8		       8d 51 27 	      sta	ProgramEnd
   1450  08eb		       ad 52 27 	      lda	ProgramEnd+1
   1451  08ee		       69 00		      adc	#0
   1452  08f0		       8d 52 27 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1453  08f3							;
   1454  08f3							;===================jlit use length before line newline
   1455  08f3
   1456  08f3		       a0 00		      ldy	#0	;Set offset of copy
   1457  08f5		       ad 4c 27 	      lda	lineLength	;We will insert the actual length of the line first
   1458  08f8		       91 4f		      sta	(CURPTR),y	;Store the length
   1459  08fa		       c8		      iny
   1460  08fb		       a5 52		      lda	R0	;Store the line number next
   1461  08fd		       91 4f		      sta	(CURPTR),y
   1462  08ff		       c8		      iny
   1463  0900		       a5 53		      lda	R0+1
   1464  0902		       91 4f		      sta	(CURPTR),y
   1465  0904		       c8		      iny
   1466  0905							;
   1467  0905		       ae 4b 27 	      ldx	offset	;Load the offset into line buffer in page zero
   1468  0908		       bd b2 26    mvUpLoop2  lda	LINBUF,x	;get a byte
   1469  090b		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1470  090d		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1471  090f		       e8		      inx
   1472  0910		       c8		      iny
   1473  0911		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1474  0913							;
   1475  0913		       4c bb 02    mvUpFini   jmp	NextIL
   1476  0916							;
   1477  0916							;=====================================================
   1478  0916							; Pops the top value of the ILPC stack and stores it
   1479  0916							; in ILPC.  Ie, return from an IL subroutine.
   1480  0916							;
   1481  0916		       20 b9 12    iRTN       jsr	popILPC
   1482  0919		       4c bb 02 	      jmp	NextIL
   1483  091c							;
   1484  091c							;=====================================================
   1485  091c							; NLINE print a newline
   1486  091c							;
   1487  091c		       20 bc 15    iNLINE     jsr	CRLF	;user supplied sub
   1488  091f		       4c bb 02 	      jmp	NextIL
   1489  0922							;
   1490  0922							;=====================================================
   1491  0922							; This saves the current ILPC value on the stack, then
   1492  0922							; jumps to the address specified by the next two bytes.
   1493  0922							;
   1494  0922		       20 9c 12    iCALL      jsr	pushILPC	;save ILPC
   1495  0925		       90 03		      bcc	iJMP
   1496  0927		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   1497  092a							;
   1498  092a							; Jmp to a specific location in the IL code.  The new
   1499  092a							; address immediately follows the opcode.
   1500  092a							;
   1501  092a		       20 82 12    iJMP       jsr	getILWord
   1502  092d		       86 43		      stx	ILPC
   1503  092f		       85 44		      sta	ILPC+1
   1504  0931		       4c bb 02 	      jmp	NextIL
   1505  0934
   1506  0934
   1507  0934							;
   1508  0934							;=====================================================
   1509  0934							; Push the next two bytes onto the arithmetic stack.
   1510  0934							;
   1511  0934		       20 86 12    iSetR2     jsr	getILByte
   1512  0937		       85 58		      sta	R2
   1513  0939		       4c bb 02 	      jmp	NextIL
   1514  093c							;
   1515  093c							;=====================================================
   1516  093c							; Push the next two bytes onto the arithmetic stack.
   1517  093c							;
   1518  093c		       20 82 12    iLIT       jsr	getILWord
   1519  093f		       86 52		      stx	R0
   1520  0941		       85 53		      sta	R0+1
   1521  0943		       20 7f 14 	      jsr	pushR0
   1522  0946		       4c bb 02 	      jmp	NextIL
   1523  0949							;
   1524  0949							;=====================================================
   1525  0949							; Initialize all variables for a single task.	Ie, set to zero.
   1526  0949							;
   1527  0949		       98	   subVINIT   tya
   1528  094a		       48		      pha
   1529  094b
   1530  094b		       a9 00		      lda	#0
   1531  094d		       a0 00		      ldy	#0
   1532  094f		       91 41	   Vinit2     sta	(VARIABLES),y
   1533  0951		       c8		      iny
   1534  0952		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1535  0954		       90 f9		      bcc	Vinit2
   1536  0956
   1537  0956		       68		      pla
   1538  0957		       a8		      tay
   1539  0958		       60		      rts
   1540  0959
   1541  0959		       20 49 09    iVINIT     jsr	subVINIT
   1542  095c		       4c bb 02 	      jmp	NextIL
   1543  095f							;
   1544  095f							;=====================================================
   1545  095f							; Set the address of the error handler.  After any
   1546  095f							; error, set to the ILPC to the specified location.
   1547  095f							;
   1548  095f		       20 82 12    iERRGOTO   jsr	getILWord
   1549  0962		       8e 3c 27 	      stx	errGoto
   1550  0965		       8d 3d 27 	      sta	errGoto+1
   1551  0968		       4c bb 02 	      jmp	NextIL
   1552  096b							;
   1553  096b							;=====================================================
   1554  096b							; TST is followed by an 8 bit signed offset, then a
   1555  096b							; null terminated string.  Compare the string against
   1556  096b							; the string starting at (CURPTR),CUROFF.  If the
   1557  096b							; strings match, continue executing the next IL
   1558  096b							; opcode.  Else, add the offset to ILPC.
   1559  096b							;
   1560  096b		       20 86 12    iTST       jsr	getILByte	;Get the relative jump address
   1561  096e		       8d 4b 27 	      sta	offset	;save it to use if test faile
   1562  0971		       20 69 14 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1563  0974
   1564  0974		       a4 51		      ldy	CUROFF
   1565  0976		       84 59		      sty	dpl	;save for later
   1566  0978							;
   1567  0978		       20 86 12    iTSTloop   jsr	getILByte	;get next char
   1568  097b		       f0 11		      beq	iTSTm	;match!
   1569  097d		       a4 59		      ldy	dpl
   1570  097f		       d1 4f		      cmp	(CURPTR),y
   1571  0981		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1572  0983		       09 20		      ora	#$20	; lets allow lowercase as well
   1573  0985		       d1 4f		      cmp	(CURPTR),y
   1574  0987		       d0 23		      bne	iTSTfail	;mismatch
   1575  0989		       c8	   iTSTUpper  iny
   1576  098a		       84 59		      sty	dpl
   1577  098c		       d0 ea		      bne	iTSTloop
   1578  098e							;
   1579  098e							; It's a match!  Clean up a bit.
   1580  098e							;
   1581  098e		       a4 59	   iTSTm      ldy	dpl
   1582  0990		       84 51		      sty	CUROFF
   1583  0992		       4c bb 02 	      jmp	NextIL
   1584  0995
   1585  0995							; Test for a single quote string
   1586  0995		       20 86 12    iTSTStr    jsr	getILByte
   1587  0998		       8d 4b 27 	      sta	offset
   1588  099b		       20 69 14 	      jsr	saveIL
   1589  099e		       a4 51		      ldy	CUROFF
   1590  09a0		       a9 22		      lda	#'"
   1591  09a2		       d1 4f		      cmp	(CURPTR),y
   1592  09a4		       d0 06		      bne	iTSTfail
   1593  09a6		       c8		      iny
   1594  09a7		       84 51		      sty	CUROFF
   1595  09a9		       4c de 02 	      jmp	NextILStr
   1596  09ac							;
   1597  09ac							; Not a match, reset ILPC and then move to the
   1598  09ac							; offset.
   1599  09ac							;
   1600  09ac		       20 74 14    iTSTfail   jsr	restoreIL
   1601  09af		       4c 0c 0b 	      jmp	tstBranch
   1602  09b2							;
   1603  09b2							;=================================================JLIT=
   1604  09b2							; Test if we have a let statement without the let keyword
   1605  09b2		       20 86 12    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1606  09b5		       8d 4b 27 	      sta	offset	; Save the jump offset for fails
   1607  09b8		       20 69 14 	      jsr	saveIL	; save to restore when done if fail
   1608  09bb
   1609  09bb		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1610  09bd		       20 b3 15 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1611  09c0		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1612  09c1		       20 b3 15 	      jsr	SkipSpaces	; skip any SkipSpaces
   1613  09c4		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1614  09c6		       c9 3d		      cmp	#'=	; check if equals
   1615  09c8		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1616  09ca		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1617  09cc		       d0 de		      bne	iTSTfail	; return it failed
   1618  09ce
   1619  09ce				   iTSTLETGOOD
   1620  09ce		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1621  09d1
   1622  09d1							;=================================================JLIT=
   1623  09d1							;
   1624  09d1		       20 86 12    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1625  09d4		       8d 4b 27 	      sta	offset	; Save the jump offset for fails
   1626  09d7		       20 69 14 	      jsr	saveIL	; save to restore when done if fail
   1627  09da		       20 82 12 	      jsr	getILWord	; Get a word into RO
   1628  09dd		       86 52		      stx	R0
   1629  09df		       85 53		      sta	R0+1
   1630  09e1		       20 86 12 	      jsr	getILByte	; Get byte into A
   1631  09e4		       a0 00		      ldy	#0
   1632  09e6		       d1 52		      cmp	(R0),y
   1633  09e8		       d0 03		      bne	iTSTByteNotEqual
   1634  09ea		       4c ac 09 	      jmp	iTSTfail
   1635  09ed
   1636  09ed				   iTSTByteNotEqual
   1637  09ed		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1638  09f0
   1639  09f0
   1640  09f0							;================================================jLIT=
   1641  09f0							;Test for end of line
   1642  09f0							;
   1643  09f0		       20 86 12    iTSTDONE   jsr	getILByte
   1644  09f3		       8d 4b 27 	      sta	offset
   1645  09f6		       20 69 14 	      jsr	saveIL
   1646  09f9		       a4 51		      ldy	CUROFF
   1647  09fb		       84 59		      sty	dpl
   1648  09fd		       20 b3 15 	      jsr	SkipSpaces
   1649  0a00		       b1 4f		      lda	(CURPTR),y
   1650  0a02		       f0 0b		      beq	iTSTDONEtrue
   1651  0a04		       c9 3a		      cmp	#COLON
   1652  0a06		       f0 07		      beq	iTSTDONEtrue
   1653  0a08		       a4 59		      ldy	dpl
   1654  0a0a		       84 51		      sty	CUROFF
   1655  0a0c		       4c ac 09 	      jmp	iTSTfail
   1656  0a0f							;
   1657  0a0f							; Advance to the next line
   1658  0a0f							;
   1659  0a0f				   iTSTDONEtrue
   1660  0a0f		       4c bb 02 	      jmp	NextIL
   1661  0a12
   1662  0a12		       4c 0c 0b    tstBranchLink jmp	tstBranch
   1663  0a15							;
   1664  0a15							;=====================================================
   1665  0a15							; Inc and dec a variable , faster than a = a + 1
   1666  0a15				   iINCVAR
   1667  0a15		       20 03 15 	      jsr	popR0
   1668  0a18		       a0 00		      ldy	#0
   1669  0a1a		       18		      clc
   1670  0a1b		       a9 01		      lda	#1
   1671  0a1d		       71 52		      adc	(R0),y
   1672  0a1f		       91 52		      sta	(R0),y
   1673  0a21		       90 07		      bcc	iINCDONE
   1674  0a23		       c8		      iny
   1675  0a24		       a9 00		      lda	#0
   1676  0a26		       71 52		      adc	(R0),y
   1677  0a28		       91 52		      sta	(R0),y
   1678  0a2a				   iINCDONE
   1679  0a2a		       4c bb 02 	      jmp	NextIL
   1680  0a2d				   iDECVAR
   1681  0a2d		       20 03 15 	      jsr	popR0
   1682  0a30		       a0 00		      ldy	#0
   1683  0a32		       38		      sec
   1684  0a33		       b1 52		      lda	(R0),y
   1685  0a35		       e9 01		      sbc	#1
   1686  0a37		       91 52		      sta	(R0),y
   1687  0a39		       c8		      iny
   1688  0a3a		       b1 52		      lda	(R0),y
   1689  0a3c		       69 00		      adc	#0
   1690  0a3e		       91 52		      sta	(R0),y
   1691  0a40		       4c bb 02 	      jmp	NextIL
   1692  0a43
   1693  0a43
   1694  0a43							;
   1695  0a43							;=====================================================
   1696  0a43							; TSTV is followed by an 8 bit signed offset.	If the
   1697  0a43							; value at (CURPTR),CUROFF appears to be a variable
   1698  0a43							; name, move to the next IL statement.  Else, add the
   1699  0a43							; offset to ILPC. Converted to use actual absolute memory addresses
   1700  0a43							; TSTVT Looks for the task context
   1701  0a43							;
   1702  0a43		       20 1b 15    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1703  0a46		       a9 00		      lda	#0
   1704  0a48		       85 58		      sta	R2
   1705  0a4a		       f0 04		      beq	iTSTVV
   1706  0a4c
   1707  0a4c		       a9 01	   iTSTV      lda	#1
   1708  0a4e		       85 58		      sta	R2
   1709  0a50
   1710  0a50		       20 86 12    iTSTVV     jsr	getILByte	;offset
   1711  0a53		       8d 4b 27 	      sta	offset
   1712  0a56							;
   1713  0a56		       a4 51		      ldy	CUROFF
   1714  0a58		       20 b3 15 	      jsr	SkipSpaces
   1715  0a5b		       b1 4f		      lda	(CURPTR),y
   1716  0a5d		       d0 03		      bne	iTSTVnext
   1717  0a5f		       4c 12 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1718  0a62							;
   1719  0a62				   iTSTVnext
   1720  0a62		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1721  0a64		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1722  0a66
   1723  0a66		       c9 23		      cmp	#'#	; parameters passed to this task
   1724  0a68		       f0 53		      beq	iTSTVParm
   1725  0a6a
   1726  0a6a		       c9 5e		      cmp	#'^	; task exit code
   1727  0a6c		       d0 04		      bne	iTSTV_A2Z
   1728  0a6e		       a9 19		      lda	#TASKEXITCODE
   1729  0a70		       d0 10		      bne	iTSTVContinue
   1730  0a72
   1731  0a72				   iTSTV_A2Z
   1732  0a72		       09 20		      ora	#$20	;make lower then upper
   1733  0a74		       49 20		      eor	#$20	;allow lower case here
   1734  0a76		       c9 41		      cmp	#'A
   1735  0a78		       90 98		      bcc	tstBranchLink
   1736  0a7a		       c9 5b		      cmp	#'Z+1
   1737  0a7c		       b0 94		      bcs	tstBranchLink
   1738  0a7e
   1739  0a7e
   1740  0a7e							;
   1741  0a7e							; The condition is true, so convert to an index, push
   1742  0a7e							; it onto the stack and continue running.
   1743  0a7e							;
   1744  0a7e		       38		      sec
   1745  0a7f		       e9 41		      sbc	#'A	;index is zero based
   1746  0a81		       0a		      asl		;multiply by two
   1747  0a82
   1748  0a82				   iTSTVContinue
   1749  0a82		       c8		      iny
   1750  0a83		       84 51		      sty	CUROFF	;it is a valid variable
   1751  0a85		       48		      pha
   1752  0a86		       a5 58		      lda	R2
   1753  0a88		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1754  0a8a
   1755  0a8a		       20 69 12 	      jsr	ipc_getcontext	; Get the other tasks variables
   1756  0a8d		       a0 01		      ldy	#VARIABLEPOS
   1757  0a8f		       b1 56		      lda	(MQ),y
   1758  0a91		       85 52		      sta	R0
   1759  0a93		       c8		      iny
   1760  0a94		       b1 56		      lda	(MQ),y
   1761  0a96		       85 53		      sta	R0+1
   1762  0a98		       4c a3 0a 	      jmp	iTSTVAddOffset
   1763  0a9b
   1764  0a9b				   iTSTVLocalValue
   1765  0a9b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1766  0a9d		       85 52		      sta	R0
   1767  0a9f		       a5 42		      lda	VARIABLES+1
   1768  0aa1		       85 53		      sta	R0+1
   1769  0aa3
   1770  0aa3				   iTSTVAddOffset
   1771  0aa3		       68		      pla
   1772  0aa4		       85 54		      sta	R1
   1773  0aa6		       a9 00		      lda	#0
   1774  0aa8		       85 55		      sta	R1+1
   1775  0aaa
   1776  0aaa				   iTSTVcontinue
   1777  0aaa
   1778  0aaa		       4c 8b 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1779  0aad
   1780  0aad							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1781  0aad							; an array of integer values
   1782  0aad				   iTSTVat
   1783  0aad		       c8		      iny
   1784  0aae		       84 51		      sty	CUROFF	;it is a valid variable
   1785  0ab0		       ad 51 27 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1786  0ab3		       85 52		      sta	R0
   1787  0ab5		       ad 52 27 	      lda	ProgramEnd+1
   1788  0ab8		       85 53		      sta	R0+1
   1789  0aba		       4c 03 07 	      jmp	pushR0nextIl	;place this onto the stack
   1790  0abd
   1791  0abd							; When we get parameters passed we can access them using the # variable with[]
   1792  0abd							; example #[0] #[1] etc, we dont check yet if there is too many
   1793  0abd				   iTSTVParm
   1794  0abd		       c8		      iny
   1795  0abe		       84 51		      sty	CUROFF	;it is a valid variable
   1796  0ac0		       a5 48		      lda	MATHSTACK
   1797  0ac2		       85 52		      sta	R0
   1798  0ac4		       a5 49		      lda	MATHSTACK+1
   1799  0ac6		       85 53		      sta	R0+1
   1800  0ac8		       4c 03 07 	      jmp	pushR0nextIl
   1801  0acb
   1802  0acb							;
   1803  0acb							;=====================================================
   1804  0acb							; TSTL seems basically the same as TSTN, but leave the
   1805  0acb							; value in R0 instead of pushing onto stack.
   1806  0acb							; This tests for a valid line number
   1807  0acb							;
   1808  0acb		       20 86 12    iTSTL      jsr	getILByte
   1809  0ace		       8d 4b 27 	      sta	offset
   1810  0ad1							;
   1811  0ad1		       a4 51		      ldy	CUROFF
   1812  0ad3		       20 b3 15 	      jsr	SkipSpaces
   1813  0ad6		       b1 4f		      lda	(CURPTR),y
   1814  0ad8							;
   1815  0ad8		       c9 30		      cmp	#'0
   1816  0ada		       90 30		      bcc	tstBranch
   1817  0adc		       c9 3a		      cmp	#'9+1
   1818  0ade		       b0 2c		      bcs	tstBranch
   1819  0ae0							;
   1820  0ae0							; It's a digit, so convert to a number.
   1821  0ae0							;
   1822  0ae0		       20 31 13 	      jsr	getDecimal
   1823  0ae3		       4c bb 02 	      jmp	NextIL
   1824  0ae6							;
   1825  0ae6							;=====================================================
   1826  0ae6							; TSTN checks for a number.  This is very simplistic;
   1827  0ae6							; if the character is a digit, assume it's a number.
   1828  0ae6							; Convert to a number and push it onto the stack.
   1829  0ae6							;
   1830  0ae6		       20 86 12    iTSTN      jsr	getILByte
   1831  0ae9		       8d 4b 27 	      sta	offset
   1832  0aec							;
   1833  0aec		       a4 51		      ldy	CUROFF
   1834  0aee		       20 b3 15 	      jsr	SkipSpaces
   1835  0af1		       b1 4f		      lda	(CURPTR),y
   1836  0af3		       f0 17		      beq	tstBranch
   1837  0af5		       c9 2d		      cmp	#'-	;negative?
   1838  0af7		       f0 08		      beq	iTSTN_1
   1839  0af9		       c9 30		      cmp	#'0
   1840  0afb		       90 0f		      bcc	tstBranch
   1841  0afd		       c9 3a		      cmp	#'9+1
   1842  0aff		       b0 0b		      bcs	tstBranch
   1843  0b01							;
   1844  0b01							; It's a digit, so convert to a number.
   1845  0b01							;
   1846  0b01				   iTSTN_1
   1847  0b01		       20 31 13 	      jsr	getDecimal
   1848  0b04		       84 51		      sty	CUROFF
   1849  0b06		       20 7f 14 	      jsr	pushR0	;save onto stack
   1850  0b09		       4c bb 02 	      jmp	NextIL
   1851  0b0c
   1852  0b0c							;
   1853  0b0c							; Common jump point for all TSTx instructions that
   1854  0b0c							; fail to meet the requirements.  This takes the
   1855  0b0c							; offset and adds/subtracts to/from ILPC.
   1856  0b0c							;
   1857  0b0c		       ad 4b 27    tstBranch  lda	offset	;get signed offset
   1858  0b0f		       10 0e		      bpl	tstPositive
   1859  0b11							;
   1860  0b11							; Do negative branch.	Do sign extension.
   1861  0b11							;
   1862  0b11		       18	   tstNegative clc
   1863  0b12		       65 43		      adc	ILPC
   1864  0b14		       85 43		      sta	ILPC
   1865  0b16							;		  bcc	  tstBothDone
   1866  0b16							;		  dec	  ILPC+1
   1867  0b16							;		  jmp	  NextIL
   1868  0b16
   1869  0b16		       a5 44		      lda	ILPC+1
   1870  0b18		       69 ff		      adc	#$ff
   1871  0b1a		       85 44		      sta	ILPC+1
   1872  0b1c		       4c bb 02 	      jmp	NextIL	;keep going
   1873  0b1f							;
   1874  0b1f		       18	   tstPositive clc
   1875  0b20		       65 43		      adc	ILPC
   1876  0b22		       85 43		      sta	ILPC
   1877  0b24		       90 02		      bcc	tstBothDone
   1878  0b26		       e6 44		      inc	ILPC+1
   1879  0b28				   tstBothDone
   1880  0b28		       4c bb 02 	      jmp	NextIL
   1881  0b2b
   1882  0b2b							;
   1883  0b2b							;====================================================
   1884  0b2b							; Test for IRQ pending, and test if a break key pressed
   1885  0b2b							; Yes I know but this handles all sorts of irq/break issues
   1886  0b2b							;
   1887  0b2b		       20 86 12    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1888  0b2e		       8d 4b 27 	      sta	offset	; Store the not true jump address offset
   1889  0b31		       20 36 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1890  0b34		       d0 03		      bne	irqNo	; z not set of no break found
   1891  0b36		       4c 01 06 	      jmp	iFIN	; Exit out of run mode
   1892  0b39		       ad f3 1d    irqNo      lda	IRQPending
   1893  0b3c		       f0 ce		      beq	tstBranch
   1894  0b3e		       c9 01		      cmp	#1	; only do this if set to first time
   1895  0b40		       d0 ca		      bne	tstBranch
   1896  0b42		       78		      sei		; disable the interupt until ireturn resets it
   1897  0b43		       ee f3 1d    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1898  0b46		       20 99 14 	      jsr	pushLN	; Push the next line to be executed
   1899  0b49		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1900  0b4b		       ad f4 1d 	      lda	IRQEntry	; Get the line number to branch to
   1901  0b4e		       85 4f		      sta	CURPTR	; put line number into r0
   1902  0b50		       ad f5 1d 	      lda	IRQEntry+1
   1903  0b53		       85 50		      sta	CURPTR+1
   1904  0b55		       a9 03		      lda	#3	; Point to first byte of program text
   1905  0b57		       85 51		      sta	CUROFF
   1906  0b59		       4c bb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1907  0b5c
   1908  0b5c		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1909  0b5e		       a9 00		      lda	#0	; stop the execution
   1910  0b60		       4c 18 06 	      jmp	iErr2
   1911  0b63							;
   1912  0b63
   1913  0b63							;=====================================================
   1914  0b63							; This places the number of free bytes on top of the
   1915  0b63							; stack.
   1916  0b63							;
   1917  0b63		       20 ec 0d    iFREE      jsr	MemFree
   1918  0b66		       20 7f 14 	      jsr	pushR0
   1919  0b69		       4c bb 02 	      jmp	NextIL
   1920  0b6c							;
   1921  0b6c							;=====================================================
   1922  0b6c							; Generate a random number from 0-FFFF and then MOD
   1923  0b6c							; it with the value on top of stack.  Leaves number on
   1924  0b6c							; stack
   1925  0b6c							;
   1926  0b6c		       20 1b 15    iRANDOM    jsr	popR1	;mod value
   1927  0b6f							;
   1928  0b6f							; If the value is zero, just return a one.
   1929  0b6f							;
   1930  0b6f		       a5 54		      lda	R1
   1931  0b71		       05 55		      ora	R1+1
   1932  0b73		       f0 4a		      beq	irandom1
   1933  0b75							;
   1934  0b75		       ad 42 27 	      lda	random+1
   1935  0b78		       8d 3f 27 	      sta	rtemp1
   1936  0b7b		       ad 41 27 	      lda	random
   1937  0b7e		       0a		      asl
   1938  0b7f		       2e 3f 27 	      rol	rtemp1
   1939  0b82		       0a		      asl
   1940  0b83		       2e 3f 27 	      rol	rtemp1
   1941  0b86		       18		      clc
   1942  0b87		       6d 41 27 	      adc	random
   1943  0b8a
   1944  0b8a		       48		      pha
   1945  0b8b
   1946  0b8b		       ad 3f 27 	      lda	rtemp1
   1947  0b8e		       6d 42 27 	      adc	random+1
   1948  0b91		       8d 42 27 	      sta	random+1
   1949  0b94
   1950  0b94		       68		      pla
   1951  0b95
   1952  0b95		       69 11		      adc	#$11
   1953  0b97		       8d 41 27 	      sta	random
   1954  0b9a		       ad 42 27 	      lda	random+1
   1955  0b9d		       69 36		      adc	#$36
   1956  0b9f		       8d 42 27 	      sta	random+1
   1957  0ba2
   1958  0ba2		       ad 41 27 	      lda	random
   1959  0ba5		       85 52		      sta	R0
   1960  0ba7		       ad 42 27 	      lda	random+1
   1961  0baa		       29 7f		      and	#$7f	;make positive
   1962  0bac		       85 53		      sta	R0+1
   1963  0bae							;
   1964  0bae							; R0 contains the number and R1 contains the max value.
   1965  0bae							;
   1966  0bae		       20 29 07 	      jsr	iDivNoPop
   1967  0bb1		       20 84 15 	      jsr	RestoreSigns
   1968  0bb4		       a5 56		      lda	MQ
   1969  0bb6		       85 52		      sta	R0
   1970  0bb8		       a5 57		      lda	MQ+1
   1971  0bba		       85 53		      sta	R0+1
   1972  0bbc		       4c 03 07 	      jmp	pushR0nextIl
   1973  0bbf				   irandom1
   1974  0bbf		       a9 00		      lda	#0
   1975  0bc1		       85 53		      sta	R0+1
   1976  0bc3		       a9 01		      lda	#1
   1977  0bc5		       85 52		      sta	R0
   1978  0bc7		       4c 03 07 	      jmp	pushR0nextIl
   1979  0bca
   1980  0bca							; The following replaced by call to division/modulo
   1981  0bca							;iRANDOM_2	lda	R0
   1982  0bca							;		cmp	R1
   1983  0bca							;		bne	iRANDOM_1
   1984  0bca							;		lda	R0+1
   1985  0bca							;		cmp	R1+1
   1986  0bca							;		bne	iRANDOM_1	;need to subtract
   1987  0bca							;
   1988  0bca							; Subtract R1 from R0
   1989  0bca							;
   1990  0bca							;iRANDOM_sub	sec
   1991  0bca							;		lda	R0
   1992  0bca							;		sbc	R1
   1993  0bca							;		sta	R0
   1994  0bca							;		lda	R0+1
   1995  0bca							;		sbc	R1+1
   1996  0bca							;		sta	R0+1
   1997  0bca							;		jmp	iRANDOM_2
   1998  0bca							;
   1999  0bca							; See if R1 > R0.  If so, branch to subtract.
   2000  0bca							;
   2001  0bca							;iRANDOM_1	lda	R0
   2002  0bca							;		cmp	R1
   2003  0bca							;		lda	R0+1
   2004  0bca							;		sbc	R1+1
   2005  0bca							;		bvc	iRANDOM_4
   2006  0bca							;		eor	#$80
   2007  0bca							;iRANDOM_4	bpl	iRANDOM_sub
   2008  0bca							;
   2009  0bca							; All done.  Almost.  Add one, then push the result.
   2010  0bca							;
   2011  0bca							;irandom1	inc	R0
   2012  0bca							;		bne	iRANDOM_3
   2013  0bca							;		inc	R0+1
   2014  0bca							;iRANDOM_3
   2015  0bca							;		  jsr	pushR0	;return value
   2016  0bca							;		jmp	NextIL
   2017  0bca							;
   2018  0bca							; Poke a value into a memory location
   2019  0bca		       8c 47 27    iPOKEMEMORY sty	tempy
   2020  0bcd		       20 03 15 	      jsr	popR0
   2021  0bd0		       20 1b 15 	      jsr	popR1
   2022  0bd3		       a0 00		      ldy	#0
   2023  0bd5		       a5 52		      lda	R0
   2024  0bd7		       91 54		      sta	(R1),y
   2025  0bd9		       ac 47 27 	      ldy	tempy
   2026  0bdc		       4c bb 02 	      jmp	NextIL
   2027  0bdf							;
   2028  0bdf							; Get a value from a memory location
   2029  0bdf							;
   2030  0bdf		       8c 47 27    iPEEKMEMORY sty	tempy
   2031  0be2		       20 03 15 	      jsr	popR0
   2032  0be5		       a0 00		      ldy	#0
   2033  0be7		       b1 52		      lda	(R0),y
   2034  0be9		       ac 47 27 	      ldy	tempy
   2035  0bec		       85 52		      sta	R0
   2036  0bee		       a9 00		      lda	#0
   2037  0bf0		       85 53		      sta	R0+1
   2038  0bf2		       4c 03 07 	      jmp	pushR0nextIl
   2039  0bf5							;
   2040  0bf5							; Call to address return what ever is in a to the stack
   2041  0bf5							; func2 will load a value into a before the call
   2042  0bf5		       20 1b 15    iCallFunc  jsr	popR1
   2043  0bf8		       a5 54		      lda	R1
   2044  0bfa		       20 06 0c 	      jsr	iCallRtn
   2045  0bfd		       85 52		      sta	R0
   2046  0bff		       a9 00		      lda	#0
   2047  0c01		       85 53		      sta	R0+1
   2048  0c03		       20 03 07 	      jsr	pushR0nextIl
   2049  0c06				   iCallRtn
   2050  0c06		       20 03 15 	      jsr	popR0
   2051  0c09		       6c 52 00 	      jmp	(R0)
   2052  0c0c
   2053  0c0c
   2054  0c0c							;===========================================jlit======
   2055  0c0c							;Get a character from the terminal convert to value
   2056  0c0c							;leave the number on top of the stack
   2057  0c0c							;
   2058  0c0c				   iGETCHAR
   2059  0c0c		       20 08 17 	      jsr	VGETCH
   2060  0c0f					      if	CTMON65
   2061  0c0f		       48		      pha
   2062  0c10		       20 05 17 	      jsr	VOUTCH	;echo echo echo
   2063  0c13		       68		      pla
   2064  0c14					      endif
   2065  0c14		       85 52		      sta	R0
   2066  0c16		       a9 00		      lda	#0
   2067  0c18		       85 53		      sta	R0+1
   2068  0c1a		       20 7f 14 	      jsr	pushR0
   2069  0c1d							;
   2070  0c1d		       4c bb 02 	      jmp	NextIL
   2071  0c20							;===========================================jusilostintim======
   2072  0c20							;Put a character to the terminal convert to
   2073  0c20							;
   2074  0c20		       20 03 15    iPUTCHAR   jsr	popR0
   2075  0c23		       a5 52		      lda	R0
   2076  0c25		       20 05 17 	      jsr	VOUTCH
   2077  0c28		       4c bb 02 	      jmp	NextIL
   2078  0c2b							;=====================================================
   2079  0c2b							; Put the number on the stack out as hex, suppress leading 0
   2080  0c2b				   iHexOut
   2081  0c2b		       20 03 15 	      jsr	popR0
   2082  0c2e		       a5 53		      lda	R0+1
   2083  0c30		       f0 03		      beq	iHexSecondByte
   2084  0c32		       20 aa 0d 	      jsr	OUTHEX
   2085  0c35				   iHexSecondByte
   2086  0c35		       a5 52		      lda	R0
   2087  0c37		       20 aa 0d 	      jsr	OUTHEX
   2088  0c3a		       4c bb 02 	      jmp	NextIL
   2089  0c3d							;
   2090  0c3d							;=====================================================
   2091  0c3d							; Replace TOS with its absolute value.
   2092  0c3d							;
   2093  0c3d		       20 03 15    iABS       jsr	popR0
   2094  0c40		       a5 53		      lda	R0+1
   2095  0c42		       10 10		      bpl	iABS_1	;already positive
   2096  0c44		       49 ff		      eor	#$ff
   2097  0c46		       85 53		      sta	R0+1
   2098  0c48		       a5 52		      lda	R0
   2099  0c4a		       49 ff		      eor	#$ff
   2100  0c4c		       85 52		      sta	R0
   2101  0c4e		       e6 52		      inc	R0
   2102  0c50		       d0 02		      bne	iABS_1
   2103  0c52		       e6 53		      inc	R0+1
   2104  0c54		       4c 03 07    iABS_1     jmp	pushR0nextIl
   2105  0c57
   2106  0c57							;
   2107  0c57							;================================================================
   2108  0c57							; The set of logical operators
   2109  0c57				   iLogAnd
   2110  0c57		       20 03 15 	      jsr	popR0
   2111  0c5a		       20 1b 15 	      jsr	popR1
   2112  0c5d		       a5 52		      lda	R0
   2113  0c5f		       25 54		      and	R1
   2114  0c61		       85 52		      sta	R0
   2115  0c63		       a5 53		      lda	R0+1
   2116  0c65		       25 55		      and	R1+1
   2117  0c67		       85 53		      sta	R0+1
   2118  0c69		       4c 03 07 	      jmp	pushR0nextIl
   2119  0c6c				   iLogOr
   2120  0c6c		       20 03 15 	      jsr	popR0
   2121  0c6f		       20 1b 15 	      jsr	popR1
   2122  0c72		       a5 52		      lda	R0
   2123  0c74		       05 54		      ora	R1
   2124  0c76		       85 52		      sta	R0
   2125  0c78		       a5 53		      lda	R0+1
   2126  0c7a		       05 55		      ora	R1+1
   2127  0c7c		       85 53		      sta	R0+1
   2128  0c7e		       4c 03 07 	      jmp	pushR0nextIl
   2129  0c81				   iLogXor
   2130  0c81		       20 03 15 	      jsr	popR0
   2131  0c84		       20 1b 15 	      jsr	popR1
   2132  0c87		       a5 52		      lda	R0
   2133  0c89		       45 54		      eor	R1
   2134  0c8b		       85 52		      sta	R0
   2135  0c8d		       a5 53		      lda	R0+1
   2136  0c8f		       45 55		      eor	R1+1
   2137  0c91		       85 53		      sta	R0+1
   2138  0c93		       4c 03 07 	      jmp	pushR0nextIl
   2139  0c96				   iLogNot
   2140  0c96		       20 03 15 	      jsr	popR0
   2141  0c99		       a5 52		      lda	R0
   2142  0c9b		       49 ff		      eor	#$FF
   2143  0c9d		       85 52		      sta	R0
   2144  0c9f		       a5 53		      lda	R0+1
   2145  0ca1		       49 ff		      eor	#$FF
   2146  0ca3		       85 53		      sta	R0+1
   2147  0ca5		       4c 03 07 	      jmp	pushR0nextIl
   2148  0ca8
   2149  0ca8				   iTruth
   2150  0ca8		       a9 ff		      lda	#$FF
   2151  0caa		       85 52		      sta	R0
   2152  0cac		       85 53		      sta	R0+1
   2153  0cae		       4c 03 07 	      jmp	pushR0nextIl
   2154  0cb1				   iFalse
   2155  0cb1		       a9 00		      lda	#$00
   2156  0cb3		       85 52		      sta	R0
   2157  0cb5		       85 53		      sta	R0+1
   2158  0cb7		       4c 03 07 	      jmp	pushR0nextIl
   2159  0cba
   2160  0cba							;================================================================
   2161  0cba							;Set the IRQ service rtn line number
   2162  0cba							;
   2163  0cba		       78	   iSetIrq    sei		; disable the interupts
   2164  0cbb		       a9 00		      lda	#0	; Zero the Status flag
   2165  0cbd		       8d f2 1d 	      sta	IRQStatus
   2166  0cc0		       20 03 15 	      jsr	popR0	; get the line number
   2167  0cc3		       a5 52		      lda	R0
   2168  0cc5		       05 53		      ora	R0+1
   2169  0cc7		       f0 20		      beq	iSetExt	; if it is zero disable all
   2170  0cc9		       20 99 14 	      jsr	pushLN	; Save the current line pointer
   2171  0ccc		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2172  0cce		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   2173  0cd1				   iSetIrqOk
   2174  0cd1		       20 cb 12 	      jsr	findLine	; Find the IRQ func Line Pointer
   2175  0cd4		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2176  0cd6		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2177  0cd8		       8d f5 1d 	      sta	IRQEntry+1
   2178  0cdb		       a5 4f		      lda	CURPTR
   2179  0cdd		       8d f4 1d 	      sta	IRQEntry
   2180  0ce0		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2181  0ce2		       8d f2 1d 	      sta	IRQStatus
   2182  0ce5		       20 be 14 	      jsr	popLN	; Restore the old line number
   2183  0ce8		       58		      cli		; Enable the interupts
   2184  0ce9		       4c bb 02    iSetExt    jmp	NextIL
   2185  0cec
   2186  0cec		       20 be 14    iSetIrqErr jsr	popLN
   2187  0cef		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2188  0cf1		       a9 00		      lda	#0
   2189  0cf3		       4c 18 06 	      jmp	iErr2
   2190  0cf6							;
   2191  0cf6		       20 03 15    iTRACEPROG jsr	popR0
   2192  0cf9		       a5 52		      lda	R0
   2193  0cfb		       85 40		      sta	ILTrace
   2194  0cfd		       4c bb 02 	      jmp	NextIL
   2195  0d00
   2196  0d00							;=====================================================
   2197  0d00							; Define start of non page zero data
   2198 U2759 ????				      seg.u	TBData
   2199 U1de1					      org	PROGEND
   2200 U1de1							;=================================================================
   2201 U1de1							;
------- FILE print.asm LEVEL 2 PASS 6
      0 U1de1					      include	"print.asm"
      1  0d00					      Seg	Code
      2  0d00							;---------------------------
      3  0d00							; Print 24-bit decimal number or  16bit unsigned
      4  0d00							; ---------------------------
      5  0d00							; On entry, R0=number to print
      6  0d00							;	     Defaults to pad=0 , y=21 default
      7  0d00							;	     R2 = 1 unsigned 16 bit
      8  0d00							;	     R2 = 0 Signed   16 bit
      9  0d00
     10  0d00							; On entry at PrintDecPadded:
     11  0d00							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  0d00
     13  0d00							; On exit,  A,X,Y,num,pad corrupted
     14  0d00							; Size      129 bytes, Table 24 bytes	--- total 153
     15  0d00							; -----------------------------------------------------------------
     16  0d00
     17  0d00				   PrintDecimal
     18  0d00		       a9 00		      lda	#0
     19  0d02		       8d 91 0d 	      sta	pad
     20  0d05		       a0 15		      LDY	#21	; Offset to powers of ten
     21  0d07		       4c 0d 0d 	      JMP	PrintDo
     22  0d0a
     23  0d0a				   PrintDecPadded
     24  0d0a		       8e 91 0d 	      stx	pad
     25  0d0d
     26  0d0d				   PrintDo
     27  0d0d		       a9 00		      lda	#0
     28  0d0f		       85 54		      sta	R1
     29  0d11
     30  0d11		       a5 58		      lda	R2
     31  0d13		       d0 29		      bne	PrintPos
     32  0d15
     33  0d15		       a5 53		      lda	R0+1	;MSB has sign
     34  0d17		       10 25		      bpl	PrintPos	;it's a positive number;
     35  0d19
     36  0d19
     37  0d19							; Negative numbers need more work.  Invert all the bits,
     38  0d19							; then add one.
     39  0d19
     40  0d19		       a9 2d		      lda	#'-
     41  0d1b		       20 05 17 	      jsr	VOUTCH	;print the negative sign
     42  0d1e
     43  0d1e		       a9 ff		      lda	#$FF
     44  0d20		       85 54		      sta	R1
     45  0d22		       a5 52		      lda	R0	;invert bits
     46  0d24		       49 ff		      eor	#$ff
     47  0d26		       85 52		      sta	R0
     48  0d28		       a5 53		      lda	R0+1
     49  0d2a		       49 ff		      eor	#$ff
     50  0d2c		       85 53		      sta	R0+1
     51  0d2e		       a5 54		      lda	R1
     52  0d30		       49 ff		      eor	#$ff
     53  0d32		       85 54		      sta	R1
     54  0d34		       e6 52		      inc	R0	;add one
     55  0d36		       d0 06		      bne	PrintPos
     56  0d38		       e6 53		      inc	R0+1
     57  0d3a		       d0 02		      bne	PrintPos
     58  0d3c		       e6 54		      inc	R1
     59  0d3e				   PrintPos
     60  0d3e
     61  0d3e				   PrDec24Lp1
     62  0d3e		       a2 ff		      LDX	#$FF
     63  0d40		       38		      SEC		; Start with digit=-1
     64  0d41				   PrDec24Lp2
     65  0d41		       a5 52		      LDA	R0+0
     66  0d43		       f9 92 0d 	      SBC	PrDec24Tens+0,Y
     67  0d46		       85 52		      STA	R0+0	; Subtract current tens
     68  0d48		       a5 53		      LDA	R0+1
     69  0d4a		       f9 93 0d 	      SBC	PrDec24Tens+1,Y
     70  0d4d		       85 53		      STA	R0+1
     71  0d4f		       a5 54		      LDA	R0+2
     72  0d51		       f9 94 0d 	      SBC	PrDec24Tens+2,Y
     73  0d54		       85 54		      STA	R0+2
     74  0d56		       e8		      INX
     75  0d57		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     76  0d59		       a5 52		      LDA	R0+0
     77  0d5b		       79 92 0d 	      ADC	PrDec24Tens+0,Y
     78  0d5e		       85 52		      STA	R0+0	; Add current tens back in
     79  0d60		       a5 53		      LDA	R0+1
     80  0d62		       79 93 0d 	      ADC	PrDec24Tens+1,Y
     81  0d65		       85 53		      STA	R0+1
     82  0d67		       a5 54		      LDA	R0+2
     83  0d69		       79 94 0d 	      ADC	PrDec24Tens+2,Y
     84  0d6c		       85 54		      STA	R0+2
     85  0d6e		       8a		      TXA
     86  0d6f		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     87  0d71		       ad 91 0d 	      LDA	pad
     88  0d74		       d0 09		      BNE	PrDec24Print
     89  0d76		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     90  0d78				   PrDec24Digit
     91  0d78		       a2 30		      LDX	#'0
     92  0d7a		       8e 91 0d 	      STX	pad	; No more zero padding
     93  0d7d		       09 30		      ORA	#'0	; Print this digit
     94  0d7f				   PrDec24Print
     95  0d7f		       20 05 17 	      JSR	VOUTCH
     96  0d82				   PrDec24Next
     97  0d82		       88		      DEY
     98  0d83		       88		      DEY
     99  0d84		       88		      DEY
    100  0d85		       f0 03		      beq	PrDec24LastDigit
    101  0d87		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    102  0d89		       60		      RTS
    103  0d8a				   PrDec24LastDigit
    104  0d8a		       a2 30		      LDX	#'0
    105  0d8c		       8e 91 0d 	      STX	pad	; No more zero padding
    106  0d8f		       d0 ad		      BNE	PrDec24Lp1	; Loop for last digit
    107  0d91
      0  0d91				   pad	      db	0
      1  0d91		       00		      .byte.b	0
    109  0d92				   PrDec24Tens
      0  0d92					      dw	1
      1  0d92		       01 00		      .word.w	1
      0  0d94					      db	1 / 65536
      1  0d94		       00		      .byte.b	1 / 65536
      0  0d95					      dw	10
      1  0d95		       0a 00		      .word.w	10
      0  0d97					      db	10 / 65536
      1  0d97		       00		      .byte.b	10 / 65536
      0  0d98					      dw	100
      1  0d98		       64 00		      .word.w	100
      0  0d9a					      db	100 / 65536
      1  0d9a		       00		      .byte.b	100 / 65536
      0  0d9b					      dw	1000
      1  0d9b		       e8 03		      .word.w	1000
      0  0d9d					      db	1000 / 65536
      1  0d9d		       00		      .byte.b	1000 / 65536
      0  0d9e					      dw	10000
      1  0d9e		       10 27		      .word.w	10000
      0  0da0					      db	10000 / 65536
      1  0da0		       00		      .byte.b	10000 / 65536
      0  0da1					      dw	100000
      1  0da1		       a0 86		      .word.w	100000
      0  0da3					      db	100000 / 65536
      1  0da3		       01		      .byte.b	100000 / 65536
      0  0da4					      dw	1000000
      1  0da4		       40 42		      .word.w	1000000
      0  0da6					      db	1000000 / 65536
      1  0da6		       0f		      .byte.b	1000000 / 65536
      0  0da7					      dw	10000000
      1  0da7		       80 96		      .word.w	10000000
      0  0da9					      db	10000000 / 65536
      1  0da9		       98		      .byte.b	10000000 / 65536
    126  0daa							;=====================================================
    127  0daa							; Print character in A as two hex digits to the
    128  0daa
    129  0daa
    130  0daa		       48	   HexToOut   pha		;save return value
    131  0dab		       48		      pha
    132  0dac		       4a		      lsr		;a  ;move top nibble to bottom
    133  0dad		       4a		      lsr		;a
    134  0dae		       4a		      lsr		;a
    135  0daf		       4a		      lsr		;a
    136  0db0		       20 b9 0d 	      jsr	hexta	;output nibble
    137  0db3		       68		      pla
    138  0db4		       20 b9 0d 	      jsr	hexta
    139  0db7		       68		      pla		;restore
    140  0db8		       60		      rts
    141  0db9							;
    142  0db9		       29 0f	   hexta      and	#%0001111
    143  0dbb		       c9 0a		      cmp	#$0a
    144  0dbd		       18		      clc
    145  0dbe		       30 02		      bmi	hexta1
    146  0dc0		       69 07		      adc	#7
    147  0dc2		       69 30	   hexta1     adc	#'0	;then fall into...
    148  0dc4		       4c 05 17 	      jmp	VOUTCH
    149  0dc7							;
    150  0dc7							;==================================================================================================
    151  0dc7							; Size of print functions
    152  0dc7		       00 c7	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  0dc7					      include	"mem.asm"
      1  0dc7							;===================================================================
      2  0dc7							;This file contains the memory allocation and free functions
      3  0dc7							;in herant in this is the management of free memory in the system
      4  0dc7							; the interface to these functions
      5  0dc7							; a,x returns or provides the low hi bytes of the managed addresses
      6  0dc7							; This uses the programend, to memory end as the area to manage
      7  0dc7							;===================================================================
      8  0dc7					      Seg	Code
      9  0dc7							;=====================================================
     10  0dc7							;Pointers for memory Management
     11  0dc7							;Allocated block are not chained but can be followed for all memory by the associated length
     12  0dc7							; Mem block format is
     13  0dc7							;	 0-1   pointer to next block for free blocks
     14  0dc7							;	 0-1   for allocated blocks
     15  0dc7							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  0dc7							;	   1   refrence counter ... lol only up to 256 but it is something
     17  0dc7							;	 2-3   length constant for exevy type of memory block
     18  0dc7							; Memory is recombined as it is released
     19  0dc7							; The memory manager is not interupted durring allocation
     20  0dc7							; or freeing of memory
     21  0dc7							; Memory is allocated from the highest memory address towards
     22  0dc7							; the lowest memory address. meeting the Basic program end.
     23  0dc7							;====================================================
     24  0dc7							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  0dc7							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  0dc7							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  0dc7							;=====================================================
     28  0dc7				   MemInit
     29  0dc7		       a9 59		      lda	#FreeMemStart&$FF
     30  0dc9		       8d 4f 27 	      sta	ProgramStart
     31  0dcc		       8d 51 27 	      sta	ProgramEnd
     32  0dcf		       a9 27		      lda	#FreeMemStart>>8
     33  0dd1		       8d 50 27 	      sta	ProgramStart+1
     34  0dd4		       8d 52 27 	      sta	ProgramEnd+1
     35  0dd7
     36  0dd7		       20 e1 0d 	      jsr	GetSizes
     37  0dda		       20 ec 0d 	      jsr	MemFree
     38  0ddd		       20 04 0e 	      jsr	MemUsed
     39  0de0				   MemInitEnd
     40  0de0		       60		      rts
     41  0de1
     42  0de1
     43  0de1							;
     44  0de1							;=====================================================
     45  0de1							; This function might go away eventually, but was
     46  0de1							; added to provide data for other pieces of code.
     47  0de1							; It has some ties to the operating environment that
     48  0de1							; will need to be customized for the target system.
     49  0de1							;
     50  0de1				   GetSizes
     51  0de1							;
     52  0de1							; Here is machine specific code to get the highest
     53  0de1							; memory location that can be used by BASIC.
     54  0de1							;
     55  0de1				  -	      if	ProgramStart < $2000
     56  0de1				  -	      lda	#$ff
     57  0de1				  -	      sta	HighMem	;$13ff for KIM-1
     58  0de1				  -	      sta	MemFreeList
     59  0de1				  -	      lda	#$DE	;#$13
     60  0de1				  -	      sta	HighMem+1
     61  0de1				  -	      sta	MemFreeList+1
     62  0de1					      else
     63  0de1		       a9 ff		      lda	#$ff
     64  0de3		       8d 53 27 	      sta	HighMem	;$CFFF otherwise
     65  0de6		       a9 cf		      lda	#$cf
     66  0de8		       8d 54 27 	      sta	HighMem+1
     67  0deb					      endif
     68  0deb		       60		      rts
     69  0dec							;
     70  0dec							; This computes the available memory remaining.
     71  0dec							;
     72  0dec				   MemFree
     73  0dec		       38		      sec
     74  0ded		       ad 53 27 	      lda	HighMem
     75  0df0		       ed 51 27 	      sbc	ProgramEnd
     76  0df3		       8d 57 27 	      sta	FreeMem
     77  0df6		       85 52		      sta	R0
     78  0df8		       ad 54 27 	      lda	HighMem+1
     79  0dfb		       ed 52 27 	      sbc	ProgramEnd+1
     80  0dfe		       8d 58 27 	      sta	FreeMem+1
     81  0e01		       85 53		      sta	R0+1
     82  0e03		       60		      rts
     83  0e04							;
     84  0e04							; This computes the size of the current user program.
     85  0e04							;
     86  0e04				   MemUsed
     87  0e04		       38		      sec
     88  0e05		       ad 51 27 	      lda	ProgramEnd
     89  0e08		       ed 4f 27 	      sbc	ProgramStart
     90  0e0b		       8d 55 27 	      sta	UsedMem
     91  0e0e		       85 52		      sta	R0
     92  0e10		       ad 52 27 	      lda	ProgramEnd+1
     93  0e13		       ed 50 27 	      sbc	ProgramStart+1
     94  0e16		       8d 56 27 	      sta	UsedMem+1
     95  0e19		       85 53		      sta	R0+1
     96  0e1b							;
     97  0e1b		       60		      rts
     98  0e1c
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  0e1c					      include	"gosub.asm"
      1  0e1c					      seg	Code
      2  0e1c
      3  0e1c							; Gosub and return related functions
      4  0e1c							;==========================================================
      5  0e1c							; Push the current math stack frame onto the gosub stack
      6  0e1c				   iPushMathStack
      7  0e1c		       98		      tya
      8  0e1d		       48		      pha
      9  0e1e		       a4 4d		      ldy	GOSUBSTACKPTR
     10  0e20		       a5 4a		      lda	MATHSTACKPTR
     11  0e22		       91 4b		      sta	(GOSUBSTACK),y
     12  0e24		       a9 00		      lda	#0
     13  0e26		       c8		      iny
     14  0e27		       91 4b		      sta	(GOSUBSTACK),y
     15  0e29		       c8		      iny
     16  0e2a		       91 4b		      sta	(GOSUBSTACK),y
     17  0e2c		       c8		      iny
     18  0e2d		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  0e2f		       91 4b		      sta	(GOSUBSTACK),y
     20  0e31		       c8		      iny
     21  0e32		       84 4d		      sty	GOSUBSTACKPTR
     22  0e34		       68		      pla
     23  0e35		       a8		      tay
     24  0e36		       4c bb 02 	      jmp	NextIL
     25  0e39							;
     26  0e39							;==========================================================
     27  0e39							; Increment parameter count. Assume Stack frame is top of stack
     28  0e39				   iIncParmCount
     29  0e39		       98		      tya
     30  0e3a		       48		      pha
     31  0e3b		       a4 4d		      ldy	GOSUBSTACKPTR
     32  0e3d		       88		      dey
     33  0e3e		       88		      dey
     34  0e3f		       88		      dey
     35  0e40		       b1 4b		      lda	(GOSUBSTACK),y
     36  0e42		       aa		      tax
     37  0e43		       e8		      inx
     38  0e44		       8a		      txa
     39  0e45		       91 4b		      sta	(GOSUBSTACK),y
     40  0e47		       68		      pla
     41  0e48		       a8		      tay
     42  0e49		       4c bb 02 	      jmp	NextIL
     43  0e4c							;
     44  0e4c							;==========================================================
     45  0e4c							;Restore the math stack frame
     46  0e4c		       20 52 0e    iPopMathStack jsr	PopMathStackNow
     47  0e4f		       4c bb 02 	      jmp	NextIL
     48  0e52
     49  0e52				   PopMathStackNow
     50  0e52		       98		      tya
     51  0e53		       48		      pha
     52  0e54
     53  0e54		       a4 4d		      ldy	GOSUBSTACKPTR
     54  0e56		       88		      dey
     55  0e57		       b1 4b		      lda	(GOSUBSTACK),y
     56  0e59		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  0e5b		       d0 09		      bne	iPopMathStackNoFrame
     58  0e5d		       88		      dey
     59  0e5e		       88		      dey
     60  0e5f		       88		      dey
     61  0e60		       b1 4b		      lda	(GOSUBSTACK),y
     62  0e62		       85 4a		      sta	MATHSTACKPTR
     63  0e64		       84 4d		      sty	GOSUBSTACKPTR
     64  0e66
     65  0e66				   iPopMathStackNoFrame
     66  0e66
     67  0e66		       68		      pla
     68  0e67		       a8		      tay
     69  0e68		       60		      rts
     70  0e69
     71  0e69
     72  0e69							;==========================================================
     73  0e69							; Push the current math stack information onto the gosub stack
     74  0e69				   iSaveMathStack
     75  0e69		       98		      tya
     76  0e6a		       48		      pha
     77  0e6b		       a4 4d		      ldy	GOSUBSTACKPTR
     78  0e6d		       a5 4a		      lda	MATHSTACKPTR
     79  0e6f		       91 4b		      sta	(GOSUBSTACK),y
     80  0e71		       a5 48		      lda	MATHSTACK
     81  0e73		       c8		      iny
     82  0e74
     83  0e74		       91 4b		      sta	(GOSUBSTACK),y
     84  0e76		       c8		      iny
     85  0e77
     86  0e77		       a5 49		      lda	MATHSTACK+1
     87  0e79		       91 4b		      sta	(GOSUBSTACK),y
     88  0e7b		       c8		      iny
     89  0e7c
     90  0e7c		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  0e7e		       91 4b		      sta	(GOSUBSTACK),y
     92  0e80		       c8		      iny
     93  0e81
     94  0e81		       84 4d		      sty	GOSUBSTACKPTR
     95  0e83		       68		      pla
     96  0e84		       a8		      tay
     97  0e85		       4c bb 02 	      jmp	NextIL
     98  0e88							;
     99  0e88							;==========================================================
    100  0e88							;Restore the math stack information from the gosub stack
    101  0e88				   iRestoreMathStack
    102  0e88		       98		      tya
    103  0e89		       48		      pha
    104  0e8a
    105  0e8a		       a5 4a		      lda	MATHSTACKPTR
    106  0e8c		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  0e8e
    108  0e8e		       a4 4d		      ldy	GOSUBSTACKPTR
    109  0e90		       88		      dey
    110  0e91		       b1 4b		      lda	(GOSUBSTACK),y
    111  0e93		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  0e95		       d0 16		      bne	iPopMathStack_Err
    113  0e97		       88		      dey
    114  0e98		       b1 4b		      lda	(GOSUBSTACK),y
    115  0e9a		       85 49		      sta	MATHSTACK+1
    116  0e9c		       88		      dey
    117  0e9d		       b1 4b		      lda	(GOSUBSTACK),y
    118  0e9f		       85 48		      sta	MATHSTACK
    119  0ea1		       88		      dey
    120  0ea2		       b1 4b		      lda	(GOSUBSTACK),y
    121  0ea4		       85 4a		      sta	MATHSTACKPTR
    122  0ea6		       84 4d		      sty	GOSUBSTACKPTR
    123  0ea8		       68		      pla
    124  0ea9		       a8		      tay
    125  0eaa		       4c bb 02 	      jmp	NextIL
    126  0ead
    127  0ead				   iPopMathStack_Err
    128  0ead		       a9 00		      lda	#0
    129  0eaf		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  0eb1		       4c 18 06 	      jmp	iErr2
    131  0eb4							;=========================================
    132  0eb4							; For functions and tasks the variable address of # means
    133  0eb4							; a passed parameter so #[0] is the first parameter etc
    134  0eb4							; will try for a better way later
    135  0eb4
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  0eb4					      include	"tasks.asm"
      1  0eb4							;=====================================================
      2  0eb4							; Tiny Basic IL task management
      3  0eb4							; Data required by task management
      4  0eb4							; currently each context is about 30 bytes and is swapped
      5  0eb4							; into and out of page zero on each task switch....
      6  0eb4							; LOL yes it is slow, but works for this iteration.
      7  0eb4							;
      8  0eb4
      9  0eb4					      Seg	Code
     10  0eb4							;=====================================================
     11  0eb4							; Sets the pointers to the math,IL and gosub stacks
     12  0eb4							; Creates the initial Context for each task slot
     13  0eb4				   taskSetStacks
     14  0eb4		       a9 f6		      lda	#mathStack&$FF
     15  0eb6		       85 48		      sta	MATHSTACK
     16  0eb8		       a9 1e		      lda	#mathStack>>8
     17  0eba		       85 49		      sta	MATHSTACK+1
     18  0ebc
     19  0ebc		       a9 86		      lda	#ilStack&$ff
     20  0ebe		       85 45		      sta	ILSTACK
     21  0ec0		       a9 20		      lda	#ilStack>>8
     22  0ec2		       85 46		      sta	ILSTACK+1
     23  0ec4
     24  0ec4		       a9 16		      lda	#gosubStack&$FF
     25  0ec6		       85 4b		      sta	GOSUBSTACK
     26  0ec8		       a9 22		      lda	#gosubStack>>8
     27  0eca		       85 4c		      sta	GOSUBSTACK+1
     28  0ecc
     29  0ecc		       a9 96		      lda	#variableStack&$FF
     30  0ece		       85 41		      sta	VARIABLES
     31  0ed0		       a9 24		      lda	#variableStack>>8
     32  0ed2		       85 42		      sta	VARIABLES+1
     33  0ed4		       a2 0a		      ldx	#TASKCOUNT
     34  0ed6		       a0 00		      ldy	#0
     35  0ed8		       20 63 11 	      jsr	ContextSave
     36  0edb
     37  0edb		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  0edd		       b0 3a		      bcs	taskSetDone
     39  0edf
     40  0edf		       a5 4b		      lda	GOSUBSTACK
     41  0ee1		       18		      clc
     42  0ee2		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  0ee4		       85 4b		      sta	GOSUBSTACK
     44  0ee6		       a5 4c		      lda	GOSUBSTACK+1
     45  0ee8		       69 00		      adc	#0
     46  0eea		       85 4c		      sta	GOSUBSTACK+1
     47  0eec
     48  0eec		       a5 45		      lda	ILSTACK	; must be less than 256
     49  0eee		       18		      clc
     50  0eef		       69 28		      adc	#ILSTACKSIZE*2
     51  0ef1		       85 45		      sta	ILSTACK
     52  0ef3		       a5 46		      lda	ILSTACK+1
     53  0ef5		       69 00		      adc	#0
     54  0ef7		       85 46		      sta	ILSTACK+1
     55  0ef9
     56  0ef9		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  0efb		       18		      clc
     58  0efc		       69 28		      adc	#MATHSTACKSIZE*2
     59  0efe		       85 48		      sta	MATHSTACK
     60  0f00		       a5 49		      lda	MATHSTACK+1
     61  0f02		       69 00		      adc	#0
     62  0f04		       85 49		      sta	MATHSTACK+1
     63  0f06
     64  0f06		       a5 41		      lda	VARIABLES	; must be less than 256
     65  0f08		       18		      clc
     66  0f09		       69 36		      adc	#VARIABLESSIZE*2
     67  0f0b		       85 41		      sta	VARIABLES
     68  0f0d		       a5 42		      lda	VARIABLES+1
     69  0f0f		       69 00		      adc	#0
     70  0f11		       85 42		      sta	VARIABLES+1
     71  0f13
     72  0f13		       20 63 11 	      jsr	ContextSave
     73  0f16		       4c db 0e 	      jmp	taskSetLoop
     74  0f19
     75  0f19				   taskSetDone
     76  0f19		       a0 00		      ldy	#0	; reload the main loop context
     77  0f1b		       20 72 11 	      jsr	ContextLoad
     78  0f1e		       60		      rts
     79  0f1f							;
     80  0f1f							;=====================================================
     81  0f1f							; In some error cases the math stacks may be left pointing to the wrong stack
     82  0f1f							; This function will reset those stack addresses but not the actual pointer
     83  0f1f				   taskResetStacks
     84  0f1f		       a0 00		      ldy	#0
     85  0f21		       20 72 11 	      jsr	ContextLoad
     86  0f24		       4c b4 0e 	      jmp	taskSetStacks
     87  0f27							;
     88  0f27							;=====================================================
     89  0f27							; Clear all task entries and task stacks
     90  0f27		       98	   taskReset  tya		; Save Y
     91  0f28		       48		      pha
     92  0f29		       a9 01		      lda	#1
     93  0f2b		       8d f5 1e 	      sta	taskCounter	; Set number of active tasks to 1
     94  0f2e		       ac f6 1d 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  0f31		       c0 00		      cpy	#0	; check if we are the main context
     96  0f33		       f0 08		      beq	taskResetCont	; if we are just continue
     97  0f35
     98  0f35		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  0f37		       8c f6 1d 	      sty	taskPtr
    100  0f3a		       20 72 11 	      jsr	ContextLoad	; load the System Task context
    101  0f3d				   taskResetCont
    102  0f3d		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  0f3f
    104  0f3f				   taskResetLoop
    105  0f3f		       a9 00		      lda	#TASKINACTIVE
    106  0f41		       99 f7 1d 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  0f44		       18		      clc
    108  0f45		       98		      tya
    109  0f46		       69 19		      adc	#CONTEXTLEN+1
    110  0f48		       a8		      tay
    111  0f49		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  0f4b		       90 f2		      bcc	taskResetLoop	; Go for more
    113  0f4d
    114  0f4d				   taskResetComplete
    115  0f4d
    116  0f4d		       68		      pla		; Restore y
    117  0f4e		       a8		      tay
    118  0f4f		       60		      rts
    119  0f50
    120  0f50							;
    121  0f50							;======================================================
    122  0f50							; iTaskSwitch	 switch to new task if not interrupt and
    123  0f50							;		 count is exceded for task time slice gets here
    124  0f50							;		 when time slice has reached zero
    125  0f50							;
    126  0f50		       98	   iTaskSwitch tya
    127  0f51		       48		      pha
    128  0f52
    129  0f52		       ad f3 1e 	      lda	taskResetValue	; Always reset the counter value
    130  0f55		       8d f1 1e 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  0f58		       ce f2 1e 	      dec	taskCurrentCycles+1	; dec high order byte
    132  0f5b		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  0f5d
    134  0f5d		       ad f4 1e 	      lda	taskResetValue+1
    135  0f60		       8d f2 1e 	      sta	taskCurrentCycles+1
    136  0f63
    137  0f63		       ad f3 1d 	      lda	IRQPending	; Skip this if we are processing an irq
    138  0f66		       0d 4d 27 	      ora	taskIOPending	; If set then don't switch
    139  0f69		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  0f6b
    141  0f6b		       ad f5 1e    iTaskMain  lda	taskCounter	; Number of tasks
    142  0f6e		       c9 01		      cmp	#1	; if there is only one task must be main
    143  0f70		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  0f72
    145  0f72		       ac f6 1d 	      ldy	taskPtr	; check if we have not just ended some other task
    146  0f75		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  0f77		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  0f79							;
    149  0f79							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  0f79							;
    151  0f79				   itasknext
    152  0f79		       ac f6 1d 	      ldy	taskPtr
    153  0f7c		       20 63 11 	      jsr	ContextSave	; Save the current context, y points to next context
    154  0f7f				   itaskLoop
    155  0f7f		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  0f81		       90 04		      bcc	iTaskNextChk
    157  0f83
    158  0f83		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  0f85		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  0f87
    161  0f87				   iTaskNextChk
    162  0f87		       b9 f7 1d 	      lda	taskTable,y	; there is always at least one entry in table
    163  0f8a		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  0f8c		       18	   iTaskNext  clc
    165  0f8d		       98		      tya
    166  0f8e		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  0f90		       a8		      tay
    168  0f91		       4c 7f 0f 	      jmp	itaskLoop	; Check for busy entry
    169  0f94
    170  0f94		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  0f96		       59 f7 1d 	      eor	taskTable,y	; Check for anything waiting io
    172  0f99		       d0 f1		      bne	iTaskNext
    173  0f9b		       20 72 11 	      jsr	ContextLoad	; load the next context
    174  0f9e		       8c f6 1d 	      sty	taskPtr	; update the task pointer
    175  0fa1
    176  0fa1				   iTaskSwitchDone
    177  0fa1		       68		      pla
    178  0fa2		       a8		      tay
    179  0fa3		       60		      rts
    180  0fa4							;
    181  0fa4							;================================================================
    182  0fa4							; Task Set task number to line number to start
    183  0fa4							; Task Table structure:
    184  0fa4							;    byte 0	-   Active inactive
    185  0fa4							;    byte 1-2	-   Basic code line pointer
    186  0fa4							;    byte 3	-   Offset on current line
    187  0fa4		       98	   iTaskSet   tya		;preserve Y
    188  0fa5		       48		      pha		; push a
    189  0fa6
    190  0fa6		       20 03 15 	      jsr	popR0	; Get the line number to be saved
    191  0fa9
    192  0fa9		       ac f6 1d 	      ldy	taskPtr	; find out where we are
    193  0fac		       20 63 11 	      jsr	ContextSave	; Save the current context
    194  0faf
    195  0faf							;Find the pointer to the line we need to start at
    196  0faf		       20 cb 12 	      jsr	findLine	; Get the offset of the line to start task at
    197  0fb2		       f0 0b		      beq	iTaskCont
    198  0fb4
    199  0fb4		       ac f6 1d 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  0fb7		       20 72 11 	      jsr	ContextLoad
    201  0fba
    202  0fba		       68		      pla		; pop a - exit
    203  0fbb		       a8		      tay
    204  0fbc		       4c ec 0c 	      jmp	iSetIrqErr	; Bad line number provided
    205  0fbf
    206  0fbf				   iTaskCont
    207  0fbf		       20 35 11 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  0fc2		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  0fc4
    210  0fc4		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  0fc6		       99 f7 1d 	      sta	taskTable,y	; new task as active
    212  0fc9
    213  0fc9		       a5 4f		      lda	CURPTR
    214  0fcb		       48		      pha		; push a
    215  0fcc		       a5 50		      lda	CURPTR+1
    216  0fce		       48		      pha		; push a
    217  0fcf
    218  0fcf		       20 72 11 	      jsr	ContextLoad	; load the context of the new task
    219  0fd2
    220  0fd2		       68		      pla		; pop a
    221  0fd3		       85 50		      sta	CURPTR+1
    222  0fd5		       68		      pla		; pop a
    223  0fd6		       85 4f		      sta	CURPTR
    224  0fd8		       a9 03		      lda	#3	; Offset to first instruction
    225  0fda		       85 51		      sta	CUROFF
    226  0fdc
    227  0fdc		       a9 00		      lda	#0
    228  0fde		       85 47		      sta	ILSTACKPTR
    229  0fe0		       85 4a		      sta	MATHSTACKPTR
    230  0fe2		       85 4d		      sta	GOSUBSTACKPTR
    231  0fe4		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  0fe6		       85 4e		      sta	MESSAGEPTR
    233  0fe8
    234  0fe8		       20 49 09 	      jsr	subVINIT	; Clear the variables
    235  0feb
    236  0feb		       a9 23		      lda	#STMT&$FF
    237  0fed		       85 43		      sta	ILPC
    238  0fef		       a9 19		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  0ff1		       85 44		      sta	ILPC+1
    240  0ff3
    241  0ff3		       98		      tya		; Save the new context offset to return to user
    242  0ff4		       48		      pha		; push a
    243  0ff5
    244  0ff5		       20 63 11    itaskSetSave jsr	ContextSave	; save the updated context
    245  0ff8		       ee f5 1e 	      inc	taskCounter	; Update the number of Tasks running
    246  0ffb
    247  0ffb		       ac f6 1d 	      ldy	taskPtr
    248  0ffe		       20 72 11 	      jsr	ContextLoad	; restore the original context
    249  1001
    250  1001		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  1003		       85 53		      sta	R0+1
    252  1005		       68		      pla		; Get the task pid we stored				 ; pop a
    253  1006		       85 52		      sta	R0	; Get the table entry value
    254  1008
    255  1008		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  1009		       a8		      tay
    257  100a
    258  100a		       4c 03 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  100d				   iTaskNoEmpty
    260  100d		       ac f6 1d 	      ldy	taskPtr
    261  1010		       20 72 11 	      jsr	ContextLoad
    262  1013
    263  1013		       68		      pla		; pop a    -- exit
    264  1014		       a8		      tay
    265  1015
    266  1015		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  1017		       a9 00		      lda	#0
    268  1019		       4c 18 06 	      jmp	iErr2
    269  101c							;
    270  101c							;===============================================================
    271  101c							; Run the task whos PID is on the stack, preserve the stack
    272  101c							;
    273  101c				   iTaskEnable
    274  101c		       98		      tya
    275  101d		       48		      pha
    276  101e		       20 1b 15 	      jsr	popR1
    277  1021		       20 e9 14 	      jsr	pushR1
    278  1024		       20 69 12 	      jsr	ipc_getcontext	; get context pointer into mq
    279  1027		       a0 00		      ldy	#0
    280  1029		       b1 56		      lda	(MQ),y
    281  102b		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  102d		       09 80		      ora	#TASKACTIVE
    283  102f		       91 56		      sta	(MQ),y
    284  1031		       68		      pla
    285  1032		       a8		      tay
    286  1033		       4c bb 02 	      jmp	NextIL
    287  1036
    288  1036							;
    289  1036							;===============================================================
    290  1036							; Suspend the task whos PID  is on the stack, preserve the stack
    291  1036							;
    292  1036				   iTaskSuspend
    293  1036		       98		      tya
    294  1037		       48		      pha
    295  1038		       20 1b 15 	      jsr	popR1
    296  103b		       20 e9 14 	      jsr	pushR1
    297  103e		       20 69 12 	      jsr	ipc_getcontext	; get context pointer into mq
    298  1041		       a0 00		      ldy	#0
    299  1043		       b1 56		      lda	(MQ),y
    300  1045		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  1047		       09 80		      ora	#TASKACTIVE
    302  1049		       68		      pla
    303  104a		       a8		      tay
    304  104b		       4c bb 02 	      jmp	NextIL
    305  104e
    306  104e							;================================================================
    307  104e							; Returns task Status
    308  104e				   iTaskStat
    309  104e		       98		      tya
    310  104f		       48		      pha
    311  1050		       20 62 10 	      jsr	iTaskValid	; returns pointer to task entry
    312  1053		       b9 f7 1d 	      lda	taskTable,y
    313  1056		       f0 05		      beq	iTaskStatExit
    314  1058		       68		      pla
    315  1059		       a8		      tay
    316  105a		       4c a8 0c 	      jmp	iTruth
    317  105d				   iTaskStatExit
    318  105d		       68		      pla
    319  105e		       a8		      tay
    320  105f		       4c b1 0c 	      jmp	iFalse
    321  1062
    322  1062							;
    323  1062							;================================================================
    324  1062							; Validate the task number on top of the stack
    325  1062							; on exit y points to the requested task entry
    326  1062							;
    327  1062		       20 03 15    iTaskValid jsr	popR0	; get result of the multiply
    328  1065		       a5 53		      lda	R0+1
    329  1067		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  1069		       a5 52		      lda	R0
    331  106b		       c9 fa		      cmp	#TASKTABLELEN
    332  106d		       90 09		      bcc	iTaskIsValid
    333  106f
    334  106f		       68	   iTaskValidErr pla		;remove return address
    335  1070		       68		      pla
    336  1071		       a2 10		      ldx	#ERR_INVALID_PID
    337  1073		       a9 00		      lda	#0
    338  1075		       4c 18 06 	      jmp	iErr2
    339  1078
    340  1078		       a8	   iTaskIsValid tay
    341  1079		       60		      rts
    342  107a							;
    343  107a							;================================================================
    344  107a							; Kill a running task, do nothing if already stopped
    345  107a		       20 62 10    iTaskKill  jsr	iTaskValid
    346  107d		       a9 00		      lda	#0
    347  107f		       99 f7 1d 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  1082							;
    349  1082							;================================================================
    350  1082							;Skip to next task
    351  1082				   iNTask
    352  1082		       a9 01		      lda	#1
    353  1084		       8d f1 1e 	      sta	taskCurrentCycles
    354  1087		       8d f2 1e 	      sta	taskCurrentCycles+1
    355  108a		       4c bb 02 	      jmp	NextIL
    356  108d							;
    357  108d							;=======================================================
    358  108d							; Wait for a task to complete
    359  108d				   iWTASK
    360  108d		       20 86 12 	      jsr	getILByte
    361  1090		       8d 4b 27 	      sta	offset
    362  1093							;
    363  1093		       20 69 14 	      jsr	saveIL	;in case of failure
    364  1096
    365  1096		       20 62 10 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  1099		       b9 f7 1d 	      lda	taskTable,y
    367  109c		       d0 03		      bne	iWTASKWAIT
    368  109e				   iWTASKEXITED
    369  109e		       4c bb 02 	      jmp	NextIL
    370  10a1				   iWTASKWAIT
    371  10a1		       20 7f 14 	      jsr	pushR0	; Push R0 back onto the stack
    372  10a4		       a9 01		      lda	#1
    373  10a6		       8d f1 1e 	      sta	taskCurrentCycles	; Give up the cycles
    374  10a9		       8d f2 1e 	      sta	taskCurrentCycles+1
    375  10ac		       20 74 14 	      jsr	restoreIL
    376  10af		       4c 0c 0b 	      jmp	tstBranch
    377  10b2							;
    378  10b2							;=======================================================
    379  10b2							; Set task io lock
    380  10b2		       ee 4d 27    iStartIO   inc	taskIOPending
    381  10b5		       4c bb 02 	      jmp	NextIL
    382  10b8							;
    383  10b8							;=======================================================
    384  10b8							; Release the io lock
    385  10b8		       ad 4d 27    iEndIO     lda	taskIOPending
    386  10bb		       f0 03		      beq	iEndIOExit
    387  10bd		       ce 4d 27 	      dec	taskIOPending
    388  10c0		       4c bb 02    iEndIOExit jmp	NextIL
    389  10c3							;
    390  10c3							;===============================================================
    391  10c3							; Return the task PID
    392  10c3				   iTASKPID
    393  10c3		       a9 00		      lda	#0
    394  10c5		       85 53		      sta	R0+1
    395  10c7		       ad f6 1d 	      lda	taskPtr
    396  10ca		       85 52		      sta	R0
    397  10cc		       4c 03 07 	      jmp	pushR0nextIl
    398  10cf							;
    399  10cf							;================================================================
    400  10cf							; Terminate a task
    401  10cf		       ac f6 1d    iETask     ldy	taskPtr
    402  10d2		       c0 00		      cpy	#0
    403  10d4		       d0 03		      bne	iETaskCont
    404  10d6		       4c 01 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  10d9				   iETaskCont
    406  10d9		       a9 00		      lda	#TASKINACTIVE
    407  10db		       99 f7 1d 	      sta	taskTable,y	; mark entry as free
    408  10de		       ce f5 1e 	      dec	taskCounter	; reduce the number of active tasks
    409  10e1		       a9 01		      lda	#1
    410  10e3		       8d f1 1e 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  10e6		       8d f2 1e 	      sta	taskCurrentCycles+1
    412  10e9		       20 50 11 	      jsr	TaskSetExitCode
    413  10ec				   iETaskExit
    414  10ec		       4c bb 02 	      jmp	NextIL
    415  10ef							;================================================================
    416  10ef							; make the current tasks math stack equal another tasks stack
    417  10ef							; The task to get is stored on the math stack
    418  10ef
    419  10ef				   iTaskGetMathStack
    420  10ef		       20 7d 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  10f2		       20 69 12 	      jsr	ipc_getcontext	; MQ now has the context address
    422  10f5		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  10f7		       b1 56		      lda	(MQ),y
    424  10f9		       85 4a		      sta	MATHSTACKPTR
    425  10fb		       a0 08		      ldy	#MATHSTACKPOS
    426  10fd		       b1 56		      lda	(MQ),y
    427  10ff		       85 48		      sta	MATHSTACK
    428  1101		       c8		      iny
    429  1102		       b1 56		      lda	(MQ),y
    430  1104		       85 49		      sta	MATHSTACK+1
    431  1106		       4c bb 02 	      jmp	NextIL
    432  1109							;==================================================================
    433  1109							; Updates the tasks math stack pointer with contents of R2
    434  1109							; PID is on top of the stack
    435  1109				   iTaskPutMathPtr
    436  1109		       20 7d 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  110c		       20 69 12 	      jsr	ipc_getcontext	; MQ now has the context address
    438  110f		       a5 58		      lda	R2
    439  1111		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  1113		       91 56		      sta	(MQ),y
    441  1115		       4c bb 02 	      jmp	NextIL
    442  1118							;
    443  1118							;================================================================
    444  1118							; Set the time slice for each task
    445  1118				   iSLICE
    446  1118		       20 03 15 	      jsr	popR0
    447  111b		       a5 52		      lda	R0
    448  111d		       8d f3 1e 	      sta	taskResetValue
    449  1120		       a5 53		      lda	R0+1
    450  1122		       8d f4 1e 	      sta	taskResetValue+1
    451  1125		       d0 0b		      bne	iSliceSet
    452  1127		       ee f4 1e 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  112a		       a9 01		      lda	#1
    454  112c		       8d f1 1e 	      sta	taskCurrentCycles
    455  112f		       8d f2 1e 	      sta	taskCurrentCycles+1
    456  1132				   iSliceSet
    457  1132		       4c bb 02 	      jmp	NextIL
    458  1135							;================================================================
    459  1135							; Find an empty slot in the taskTable
    460  1135							; Return the index in y
    461  1135							; on exit   c set if an empty slot is found
    462  1135							;	     c clear if not found
    463  1135							;================================================================
    464  1135							;
    465  1135		       ad f5 1e    TaskEmpty  lda	taskCounter
    466  1138		       c9 0a		      cmp	#TASKCOUNT
    467  113a		       b0 10		      bcs	TaskNoSlot
    468  113c		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  113e				   TaskLoop
    470  113e		       b9 f7 1d 	      lda	taskTable,y
    471  1141		       f0 0b		      beq	TaskEmptyFnd
    472  1143		       98		      tya
    473  1144		       18		      clc
    474  1145		       69 19		      adc	#CONTEXTLEN+1
    475  1147		       a8		      tay
    476  1148		       c0 fa		      cpy	#TASKTABLELEN
    477  114a		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  114c				   TaskNoSlot
    479  114c		       18		      clc
    480  114d		       60		      rts
    481  114e				   TaskEmptyFnd
    482  114e		       38		      sec
    483  114f		       60		      rts
    484  1150							;====================================================
    485  1150							; Set the task exit code called from the return command
    486  1150							; on entry stack top hold exit value
    487  1150				   TaskSetExitCode
    488  1150		       98		      tya
    489  1151		       48		      pha
    490  1152		       20 03 15 	      jsr	popR0
    491  1155		       a0 19		      ldy	#TASKEXITCODE
    492  1157		       a5 52		      lda	R0
    493  1159		       91 41		      sta	(VARIABLES),y
    494  115b		       c8		      iny
    495  115c		       a5 53		      lda	R0+1
    496  115e		       91 41		      sta	(VARIABLES),y
    497  1160		       68		      pla
    498  1161		       98		      tya
    499  1162		       60		      rts
    500  1163
    501  1163							;
    502  1163							;=====================================================
    503  1163							; Save Context Store the context to the TASK Table
    504  1163							; on entry y contains the task table entry to save to
    505  1163							; on exit y points to next task table entry
    506  1163							;	   x contains the number of bytes copied
    507  1163		       a2 00	   ContextSave ldx	#0
    508  1165		       c8		      iny		;inc past the task flags
    509  1166		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  1168		       99 f7 1d 	      sta	taskTable,y
    511  116b		       c8		      iny
    512  116c		       e8		      inx
    513  116d		       e0 18		      cpx	#CONTEXTLEN
    514  116f		       90 f5		      bcc	ContextSvLoop
    515  1171		       60		      rts
    516  1172							;
    517  1172							; Load Context transfer context from task table to the Current Context
    518  1172							; on entry y contains the task table entry to transfer
    519  1172							; on exit y points to the original task table entry
    520  1172							;	   x contains the number of byts copied
    521  1172		       98	   ContextLoad tya
    522  1173		       48		      pha
    523  1174		       a2 00		      ldx	#0
    524  1176		       c8		      iny		;inc past the task flags
    525  1177		       b9 f7 1d    ContextLDLoop lda	taskTable,y
    526  117a		       95 41		      sta	CONTEXT,x
    527  117c		       c8		      iny
    528  117d		       e8		      inx
    529  117e		       e0 18		      cpx	#CONTEXTLEN
    530  1180		       90 f5		      bcc	ContextLDLoop
    531  1182		       68		      pla
    532  1183		       a8		      tay
    533  1184		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  1185					      include	"ipc.asm"
      1  1185							;======================================================
      2  1185							; Inter process communications.
      3  1185							; Tasks may write/read integer messages among
      4  1185							; them selves.
      5  1185							; This uses each tasks gosub stack as a message queue
      6  1185							; Gosub calls start at the highest address and the
      7  1185							; msg queue starts at the highest address.
      8  1185							;
      9  1185							;======================================================
     10  1185							; ipcs   - Send msg to another task or many tasks
     11  1185							; on entry  math stack contains the  top PID
     12  1185							;				      2ND Message value
     13  1185							; on exit   math stack contain top True-good or False-failed
     14  1185							;
     15  1185							; it may not be sent if queue is full
     16  1185							;
     17  1185							; a = ipcs(<message-expression>,<task PID-expression>)
     18  1185							;
     19  1185				   iIPCS
     20  1185		       98		      tya
     21  1186		       48		      pha
     22  1187		       20 ee 11 	      jsr	ipc_enqueue
     23  118a		       b0 08		      bcs	iIPC_BAD
     24  118c		       20 6f 17 	      jsr	pushTrue
     25  118f		       68		      pla
     26  1190		       a8		      tay
     27  1191		       4c bb 02 	      jmp	NextIL
     28  1194				   iIPC_BAD
     29  1194		       68		      pla
     30  1195		       a8		      tay
     31  1196		       20 79 17 	      jsr	pushFalse
     32  1199		       4c bb 02 	      jmp	NextIL
     33  119c
     34  119c							;======================================================
     35  119c							; ipcr   - Recieve msg from task
     36  119c							; on exit  the message value is returned from message queue
     37  119c							;	    message -1	is reserved meaning no entry found
     38  119c							; The provided variable contains the pid of the sending
     39  119c							; task. This is optional. This always waits for a message
     40  119c							; before returning.
     41  119c							;
     42  119c							; a = ipcr(<variable name>)
     43  119c							;
     44  119c				   iIPCR
     45  119c		       98		      tya
     46  119d		       48		      pha
     47  119e		       20 30 12 	      jsr	ipc_dequeue
     48  11a1		       b0 05		      bcs	iIPCR_Q_Empty
     49  11a3		       68		      pla
     50  11a4		       a8		      tay
     51  11a5		       4c bb 02 	      jmp	NextIL
     52  11a8				   iIPCR_Q_Empty
     53  11a8		       68		      pla
     54  11a9		       a8		      tay
     55  11aa		       20 6f 17 	      jsr	pushTrue	; puts -1 on the stack
     56  11ad		       4c bb 02 	      jmp	NextIL
     57  11b0
     58  11b0							;=======================================================
     59  11b0							; ipcc   - Check if message available
     60  11b0							; on exit  Stack contains number of messages
     61  11b0							;
     62  11b0							; a = ipcc()
     63  11b0							;
     64  11b0				   iIPCC
     65  11b0		       98		      tya
     66  11b1		       48		      pha
     67  11b2		       20 db 11 	      jsr	ipc_queue_count
     68  11b5		       20 7f 14 	      jsr	pushR0	; return the count
     69  11b8		       68		      pla
     70  11b9		       a8		      tay
     71  11ba		       4c bb 02 	      jmp	NextIL
     72  11bd
     73  11bd							;=======================================================
     74  11bd							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  11bd				   iIPCIO
     76  11bd		       98		      tya
     77  11be		       48		      pha
     78  11bf		       20 db 11 	      jsr	ipc_queue_count
     79  11c2		       a5 52		      lda	R0
     80  11c4		       d0 10		      bne	iIPCIO_No_Halt
     81  11c6		       a9 01		      lda	#1
     82  11c8		       8d f1 1e 	      sta	taskCurrentCycles	; force a task switch
     83  11cb		       a9 01		      lda	#TASKWAITIPC
     84  11cd		       ac f6 1d 	      ldy	taskPtr
     85  11d0		       19 f7 1d 	      ora	taskTable,y
     86  11d3		       99 f7 1d 	      sta	taskTable,y
     87  11d6
     88  11d6				   iIPCIO_No_Halt
     89  11d6		       68		      pla
     90  11d7		       a8		      tay
     91  11d8		       4c bb 02 	      jmp	NextIL
     92  11db							;======================================================
     93  11db							;ipc_queue_count
     94  11db				   ipc_queue_count
     95  11db		       a5 4e		      lda	MESSAGEPTR
     96  11dd		       18		      clc
     97  11de		       4a		      lsr		; divide by 4
     98  11df		       4a		      lsr
     99  11e0		       85 52		      sta	R0	; store into R0
    100  11e2		       a9 10		      lda	#GOSUBSTACKSIZE
    101  11e4		       38		      sec
    102  11e5		       e5 52		      sbc	R0	; Get how many entries on queue
    103  11e7		       85 52		      sta	R0
    104  11e9		       a9 00		      lda	#0
    105  11eb		       85 53		      sta	R0+1
    106  11ed		       60		      rts
    107  11ee							;=======================================================
    108  11ee							; Support functions for messaging
    109  11ee							;
    110  11ee							; Enqueue message -> onto PID's MSG Q
    111  11ee							; on entry top of stack contains the PID
    112  11ee							;	    second contains the Message of the task
    113  11ee							; on exit contains c set if failed
    114  11ee							;		    c cleared if success
    115  11ee							;		    PID's MSG Q PTR points to the message
    116  11ee							;
    117  11ee				   ipc_enqueue
    118  11ee		       20 1b 15 	      jsr	popR1	; Get the pid
    119  11f1		       20 69 12 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  11f4
    121  11f4		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  11f6		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  11f8		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  11fa		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  11fc		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  11fe
    127  11fe
    128  11fe							; Get the PID'S stack address into R0
    129  11fe		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1200		       b1 56		      lda	(MQ),y
    131  1202		       85 52		      sta	R0
    132  1204		       c8		      iny
    133  1205		       b1 56		      lda	(MQ),y
    134  1207		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1209
    136  1209							; Set y to point to the msg q entry
    137  1209		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  120b		       b1 56		      lda	(MQ),y	; Get the index
    139  120d		       a8		      tay		; Set y to queue offset
    140  120e
    141  120e							; enqueue the message
    142  120e		       88		      dey		; First byte to save to
    143  120f		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1211		       91 52		      sta	(R0),y	; Set the entry type
    145  1213
    146  1213		       88		      dey
    147  1214		       ad f6 1d 	      lda	taskPtr	; Store the PID into queue
    148  1217		       91 52		      sta	(R0),y
    149  1219		       20 1b 15 	      jsr	popR1	; Get the actual message value
    150  121c		       20 77 12 	      jsr	ipc_pushR1	; Store Message value into queue
    151  121f
    152  121f		       98		      tya		; Save the new q ptr
    153  1220		       a0 0e		      ldy	#MSGPTRPOS
    154  1222		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1224		       a0 00		      ldy	#0	; points to context root
    156  1226		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1228		       51 56		      eor	(MQ),y	; Turn off the bit
    158  122a		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  122c		       18		      clc
    160  122d		       60		      rts
    161  122e				   ipc_enq_full
    162  122e		       38		      sec
    163  122f		       60		      rts
    164  1230							;=============================================================
    165  1230							; De-queue for message stack -> local tasks msg q
    166  1230							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1230							;  message into
    168  1230							;  on exit   math stack contains value of message
    169  1230							;				  Variable if provided is pid
    170  1230				   ipc_dequeue
    171  1230		       20 32 15 	      jsr	popMQ	; Variable address to put PID into
    172  1233
    173  1233		       a4 4e		      ldy	MESSAGEPTR
    174  1235		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1237		       b0 2e		      bcs	ipc_deq_empty
    176  1239		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  123b		       85 52		      sta	R0
    178  123d		       c8		      iny
    179  123e		       b1 4b		      lda	(GOSUBSTACK),y
    180  1240		       85 53		      sta	R0+1
    181  1242		       c8		      iny
    182  1243		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1245		       85 54		      sta	R1
    184  1247		       c8		      iny
    185  1248		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  124a		       c8		      iny
    187  124b		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  124d
    189  124d		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  124f		       d0 16		      bne	ipc_deq_empty
    191  1251
    192  1251		       20 7f 14 	      jsr	pushR0	; place value on stack
    193  1254
    194  1254		       a5 56		      lda	MQ
    195  1256		       05 57		      ora	MQ+1
    196  1258		       f0 0b		      beq	ipc_deq_done
    197  125a		       a5 54		      lda	R1
    198  125c		       a0 00		      ldy	#0
    199  125e		       91 56		      sta	(MQ),y
    200  1260		       c8		      iny
    201  1261		       a9 00		      lda	#0
    202  1263		       91 56		      sta	(MQ),y
    203  1265				   ipc_deq_done
    204  1265		       18		      clc
    205  1266		       60		      rts
    206  1267
    207  1267				   ipc_deq_empty
    208  1267		       38		      sec
    209  1268		       60		      rts
    210  1269
    211  1269							;=============================================
    212  1269							;  Get the context address into MQ from R1 with
    213  1269							;  context/index/pid
    214  1269				   ipc_getcontext
    215  1269		       18		      clc		; Get pointer to Task context
    216  126a		       a9 f7		      lda	#taskTable&$FF	; change ptr to address
    217  126c		       65 54		      adc	R1
    218  126e		       85 56		      sta	MQ
    219  1270		       a9 1d		      lda	#taskTable>>8
    220  1272		       65 55		      adc	R1+1
    221  1274		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1276		       60		      rts
    223  1277							;
    224  1277							;==============================================
    225  1277							;Push R1 onto the stack
    226  1277							;on entry y = next entry
    227  1277							;R0 points to the stack space
    228  1277							;on exit y points to next free byte
    229  1277				   ipc_pushR1
    230  1277		       88		      dey
    231  1278		       a5 55		      lda	R1+1	; PID first
    232  127a		       91 52		      sta	(R0),y
    233  127c		       88		      dey
    234  127d		       a5 54		      lda	R1
    235  127f		       91 52		      sta	(R0),y
    236  1281		       60		      rts
    237  1282
    238  1282
    239  1282
    240  1282
    241  1282
    242  1282
    243  1282
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1282					      include	"support.asm"
      1  1282							;
      2  1282							;=====================================================
      3  1282							;=====================================================
      4  1282							;=====================================================
      5  1282							; This marks the start of support functions used by
      6  1282							; the IL opcodes.  These are support functions, NOT
      7  1282							; the IL code.
      8  1282							;=====================================================
      9  1282							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1282							;=====================================================
     11  1282					      Seg	Code
     12  1282							;=====================================================
     13  1282							; This gets the next two bytes pointed to by ILPC and
     14  1282							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1282							; is advanced by two, and Y contains 0 on return.
     16  1282
     17  1282							;
     18  1282		       20 86 12    getILWord  jsr	getILByte	;LSB
     19  1285		       aa		      tax
     20  1286							;
     21  1286							;=====================================================
     22  1286							; This gets the next byte pointed to by ILPC and
     23  1286							; returns it in A.  On return, X is unchanged but Y
     24  1286							; contains 0.
     25  1286							;
     26  1286		       a0 00	   getILByte  ldy	#0
     27  1288		       b1 43		      lda	(ILPC),y	;get byte
     28  128a		       08		      php		;save status
     29  128b		       e6 43		      inc	ILPC	;inc LSB
     30  128d		       d0 02		      bne	getILb2	;branch if no overflow
     31  128f		       e6 44		      inc	ILPC+1	;inc MSB
     32  1291		       28	   getILb2    plp		;restore status
     33  1292		       60		      rts
     34  1293							;
     35  1293							;=====================================================
     36  1293							; Decrement ILPC by one.
     37  1293							;
     38  1293		       a5 43	   decIL      lda	ILPC
     39  1295		       d0 02		      bne	decIL2
     40  1297		       c6 44		      dec	ILPC+1
     41  1299		       c6 43	   decIL2     dec	ILPC
     42  129b		       60		      rts
     43  129c							;
     44  129c							;=====================================================
     45  129c							; Push the ILPC onto the return stack.  Actually, this
     46  129c							; pushes the address of ILPC+2 since that's the next
     47  129c							; address to execute.
     48  129c							;
     49  129c		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  129e		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  12a0		       b0 15		      bcs	pushErr
     52  12a2		       a5 43		      lda	ILPC
     53  12a4		       18		      clc
     54  12a5		       69 02		      adc	#2
     55  12a7		       91 45		      sta	(ILSTACK),y
     56  12a9		       08		      php		;save C bit
     57  12aa		       c8		      iny
     58  12ab		       a5 44		      lda	ILPC+1
     59  12ad		       28		      plp		;restore C
     60  12ae		       69 00		      adc	#0
     61  12b0		       91 45		      sta	(ILSTACK),y
     62  12b2		       c8		      iny
     63  12b3		       84 47		      sty	ILSTACKPTR
     64  12b5		       18		      clc
     65  12b6		       60		      rts
     66  12b7				   pushErr
     67  12b7		       38		      sec
     68  12b8		       60		      rts
     69  12b9							;
     70  12b9							;=====================================================
     71  12b9							; Pull the top entry from return stack and put into
     72  12b9							; ILPC.
     73  12b9							;
     74  12b9		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  12bb		       f0 fa		      beq	pushErr
     76  12bd		       88		      dey
     77  12be		       b1 45		      lda	(ILSTACK),y
     78  12c0		       85 44		      sta	ILPC+1
     79  12c2		       88		      dey
     80  12c3		       b1 45		      lda	(ILSTACK),y
     81  12c5		       85 43		      sta	ILPC
     82  12c7		       84 47		      sty	ILSTACKPTR
     83  12c9		       18		      clc
     84  12ca		       60		      rts
     85  12cb							;
     86  12cb							;=====================================================
     87  12cb							; This searches for a specific line number that is in
     88  12cb							; R0.	There are three possible return conditions:
     89  12cb							; Line numbers are now the third byte, the first byte is now **************
     90  12cb							; a pointer to the next line, of course no longer that 53 byte
     91  12cb							; per line.
     92  12cb							;
     93  12cb							; Exact match was found:
     94  12cb							;    * Z set
     95  12cb							;    * CURPTR points to two-byte line number for that
     96  12cb							;	line.
     97  12cb							;
     98  12cb							; Next highest line found:
     99  12cb							;    * Z cleared
    100  12cb							;    * C set
    101  12cb							;    * CURPTR points to two-byte line number for that
    102  12cb							;	line.
    103  12cb							;
    104  12cb							; End of program reached:
    105  12cb							;    * Z cleared
    106  12cb							;    * C cleared
    107  12cb							;    * CURPTR points to first free byte at end of
    108  12cb							;	program.  Ie, it has save value as PROGRAMEND.
    109  12cb							;
    110  12cb							; A, X, and Y are all undefined on return.
    111  12cb							;
    112  12cb
    113  12cb				   findLine
    114  12cb		       ad 4f 27 	      lda	ProgramStart	;Start of program -> CURPTR
    115  12ce		       85 4f		      sta	CURPTR
    116  12d0		       ad 50 27 	      lda	ProgramStart+1
    117  12d3		       85 50		      sta	CURPTR+1
    118  12d5							;
    119  12d5							; At end of code?
    120  12d5							;
    121  12d5				   iXFER1
    122  12d5		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  12d7		       cd 51 27 	      cmp	ProgramEnd	; at end of program then stop run
    124  12da		       d0 0b		      bne	xfer2	; not end
    125  12dc		       a5 50		      lda	CURPTR+1
    126  12de		       cd 52 27 	      cmp	ProgramEnd+1
    127  12e1		       d0 04		      bne	xfer2	;Not at end
    128  12e3							;
    129  12e3							; Line not found and the end of the program was
    130  12e3							; reached.  Return Z and C both clear.
    131  12e3							;
    132  12e3		       a9 01		      lda	#1	;clear Z
    133  12e5		       18		      clc		;clear C
    134  12e6		       60		      rts
    135  12e7							;
    136  12e7							; Check for an exact line number match
    137  12e7							;
    138  12e7		       a5 52	   xfer2      lda	R0
    139  12e9		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  12eb		       d1 4f		      cmp	(CURPTR),y
    141  12ed		       d0 08		      bne	xfernotit
    142  12ef		       c8		      iny
    143  12f0		       a5 53		      lda	R0+1
    144  12f2		       d1 4f		      cmp	(CURPTR),y
    145  12f4		       d0 01		      bne	xfernotit	; not a matching line number
    146  12f6							;
    147  12f6							; This is exactly the line we want.
    148  12f6							;
    149  12f6		       60		      rts		;it matches exactly
    150  12f7							;
    151  12f7							; See if this line is greater than the one we're
    152  12f7							; searching for.
    153  12f7							;
    154  12f7		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  12f9		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  12fb		       c5 53		      cmp	R0+1
    157  12fd		       90 0b		      bcc	xfer3
    158  12ff		       d0 07		      bne	xfer4
    159  1301		       88		      dey
    160  1302		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1304		       c5 52		      cmp	R0
    162  1306		       90 02		      bcc	xfer3
    163  1308							;
    164  1308							; This line is greater than the one we want, so
    165  1308							; return Z clear and C set.
    166  1308							;
    167  1308		       38	   xfer4      sec		;We found a line number greater
    168  1309		       60		      rts		;both conditions set
    169  130a							;
    170  130a							; Not the line (or droid) we're looking for.  Move to
    171  130a							; the next line.
    172  130a							;
    173  130a		       20 10 13    xfer3      jsr	FindNextLine
    174  130d		       4c d5 12 	      jmp	iXFER1
    175  1310							;
    176  1310							;=====================================================
    177  1310							; This advances CURPTR to the next line.  If there
    178  1310							; are no more lines, this leaves CURPTR equal to
    179  1310							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1310							; CURPTR is pointing to a valid line on entry.  This
    181  1310							; pointer points to the two-byte line number.
    182  1310							; Update this points to the 1 byte line length  ****************
    183  1310							;
    184  1310				   FindNextLine
    185  1310		       a0 03		      ldy	#3	;skip line number and length byte
    186  1312		       84 51		      sty	CUROFF	;this is the new offset
    187  1314		       a0 00		      ldy	#0
    188  1316		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1318		       18		      clc
    190  1319		       65 4f		      adc	CURPTR
    191  131b		       85 4f		      sta	CURPTR
    192  131d		       a5 50		      lda	CURPTR+1
    193  131f		       69 00		      adc	#0
    194  1321		       85 50		      sta	CURPTR+1
    195  1323		       60	   FindNext4  rts
    196  1324							;
    197  1324							;=====================================================
    198  1324							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1324							; if they are equal, Z clear if not.
    200  1324							;
    201  1324		       a5 4f	   AtEnd      lda	CURPTR
    202  1326		       cd 51 27 	      cmp	ProgramEnd
    203  1329		       d0 05		      bne	atendexit
    204  132b		       a5 50		      lda	CURPTR+1
    205  132d		       cd 52 27 	      cmp	ProgramEnd+1
    206  1330		       60	   atendexit  rts
    207  1331							;
    208  1331
    209  1331							;
    210  1331							;=====================================================
    211  1331							; Convert an ASCII string to a number.  On input,
    212  1331							; (CURPTR),Y points to the first digit.  This gets
    213  1331							; digit-by-digit until finding a non-number.  Returns
    214  1331							; Y pointing to the non-digit, and R0 contains the
    215  1331							; number.  This does NOT check for valid ranges, so
    216  1331							; a value like "123456789" will produce something,
    217  1331							; but not what you had expected.
    218  1331							;
    219  1331		       a9 00	   getDecimal lda	#0
    220  1333		       85 52		      sta	R0
    221  1335		       85 53		      sta	R0+1
    222  1337		       85 59		      sta	dpl	;temporary negative flag
    223  1339							;
    224  1339							; See if it's negative...
    225  1339							;
    226  1339							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1339		       b1 4f		      lda	(CURPTR),y
    228  133b		       c9 2d		      cmp	#'-
    229  133d		       d0 02		      bne	getDecLoop
    230  133f		       e6 59		      inc	dpl	;it's negative
    231  1341							;
    232  1341		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1343		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1345		       c9 30		      cmp	#'0
    235  1347		       90 36		      bcc	getDdone
    236  1349		       c9 3a		      cmp	#'9+1
    237  134b		       b0 32		      bcs	getDdone
    238  134d		       38		      sec
    239  134e		       e9 30		      sbc	#'0	;convert to binary
    240  1350		       48		      pha
    241  1351							;
    242  1351							; Now multiply R0 by 10.  Remember that
    243  1351							; 2*N + 8*N = 10*N.
    244  1351							;
    245  1351		       06 52		      asl	R0
    246  1353		       26 53		      rol	R0+1	;*2
    247  1355		       a5 52		      lda	R0
    248  1357		       85 54		      sta	R1
    249  1359		       a5 53		      lda	R0+1
    250  135b		       85 55		      sta	R1+1
    251  135d		       06 52		      asl	R0
    252  135f		       26 53		      rol	R0+1	;*4
    253  1361		       06 52		      asl	R0
    254  1363		       26 53		      rol	R0+1	;*8
    255  1365		       18		      clc		;now add the partial sums...
    256  1366		       a5 52		      lda	R0	;...to get *10
    257  1368		       65 54		      adc	R1
    258  136a		       85 52		      sta	R0
    259  136c		       a5 53		      lda	R0+1
    260  136e		       65 55		      adc	R1+1
    261  1370		       85 53		      sta	R0+1
    262  1372							;
    263  1372							; Add in the new digit
    264  1372							;
    265  1372		       68		      pla
    266  1373		       18		      clc
    267  1374		       65 52		      adc	R0
    268  1376		       85 52		      sta	R0
    269  1378		       90 02		      bcc	getD2
    270  137a		       e6 53		      inc	R0+1
    271  137c							;
    272  137c							; Move to next character
    273  137c							;
    274  137c		       c8	   getD2      iny
    275  137d		       d0 c2		      bne	getDecLoop
    276  137f							;
    277  137f							; All done with digits, so now deal with it being
    278  137f							; negative.  If zero, then don't check for negative
    279  137f							; flag.  Ie, -0 is stored as 0.
    280  137f							;
    281  137f		       a5 52	   getDdone   lda	R0
    282  1381		       05 53		      ora	R0+1
    283  1383		       f0 16		      beq	getDone2	;zero
    284  1385		       a5 59		      lda	dpl
    285  1387		       f0 12		      beq	getDone2	;positive
    286  1389							;
    287  1389							; Invert all the bits, then add one.
    288  1389							;
    289  1389		       a5 52		      lda	R0
    290  138b		       49 ff		      eor	#$ff
    291  138d		       85 52		      sta	R0
    292  138f		       a5 53		      lda	R0+1
    293  1391		       49 ff		      eor	#$ff
    294  1393		       85 53		      sta	R0+1
    295  1395							;
    296  1395		       e6 52		      inc	R0
    297  1397		       d0 02		      bne	getDone2
    298  1399		       e6 53		      inc	R0+1
    299  139b				   getDone2
    300  139b							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  139b							;lda	  R0
    302  139b							;sta	  $0010
    303  139b							;lda	  R0+1
    304  139b							;sta	  $0011
    305  139b							;lda	  dpl
    306  139b							;sta	  $012
    307  139b
    308  139b		       60		      rts
    309  139c
    310  139c							;=====================================================
    311  139c							; Gets a line of input into LINBUF.
    312  139c							;
    313  139c							; On entry:
    314  139c							;    A contains the prompt character, or 0 if none.
    315  139c							;    X = 1 Background read
    316  139c							;    x = 0 Forground read with wait
    317  139c							;
    318  139c							; On exit:
    319  139c							;    CURPTR points to LINBUF
    320  139c							;    LINBUF contains the line with 0 at the end.
    321  139c							;    Y has offset to first non-space character
    322  139c							;    CURROFF has the same as Y.
    323  139c							;
    324  139c		       20 eb 13    GetLine    jsr	ReadPrompt
    325  139f		       e0 00		      cpx	#0
    326  13a1		       f0 14		      beq	GetLineRetry
    327  13a3		       ae f6 1d 	      ldx	taskPtr
    328  13a6		       bd f7 1d 	      lda	taskTable,x
    329  13a9		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  13ab		       d0 3d		      bne	taskWaitingIO
    331  13ad		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  13af		       9d f7 1d 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  13b2		       ce ea 13 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  13b5		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  13b7
    336  13b7							;
    337  13b7							; Now read a line and wait for the CR
    338  13b7							;
    339  13b7				   GetLineRetry
    340  13b7		       a9 00		      lda	#0	;Wait for input to complete
    341  13b9		       20 03 14 	      jsr	ReadLine
    342  13bc
    343  13bc							;
    344  13bc							; Point to the line we just read
    345  13bc							; Set the current pointer to point to the input line
    346  13bc							;
    347  13bc		       a0 00	   ReadComplete ldy	#0
    348  13be		       84 51		      sty	CUROFF
    349  13c0		       a2 b2		      ldx	#LINBUF&$ff
    350  13c2		       86 4f		      stx	CURPTR
    351  13c4		       a2 26		      ldx	#LINBUF>>8
    352  13c6		       86 50		      stx	CURPTR+1
    353  13c8							;
    354  13c8							; Output a CR/LF
    355  13c8							;
    356  13c8		       20 bc 15 	      jsr	CRLF
    357  13cb							;
    358  13cb							; If a blank line, prompt again.
    359  13cb							;
    360  13cb		       20 b3 15 	      jsr	SkipSpaces
    361  13ce		       b1 4f		      lda	(CURPTR),y
    362  13d0		       d0 10		      bne	GetLineDone	;We have data then exit
    363  13d2		       20 ee 13 	      jsr	ReadPromptRetry
    364  13d5		       ae f6 1d 	      ldx	taskPtr	;if this task is waiting for IO
    365  13d8		       bd f7 1d 	      lda	taskTable,x	;then get out, wait for line to
    366  13db		       29 40		      and	#TASKWAITIO	;Complete again
    367  13dd		       d0 0b		      bne	taskWaitingIO
    368  13df		       4c b7 13 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  13e2
    370  13e2				   GetLineDone
    371  13e2		       ae f6 1d 	      ldx	taskPtr
    372  13e5		       a9 80		      lda	#TASKACTIVE
    373  13e7		       9d f7 1d 	      sta	taskTable,x	;IO is complete
    374  13ea
    375  13ea				   taskWaitingIO
    376  13ea		       60		      rts
    377  13eb
    378  13eb							;
    379  13eb							;=======================================================================
    380  13eb							; Display the prompt character
    381  13eb							; On entry
    382  13eb							;	    A contains the prompt character
    383  13eb							; On exit
    384  13eb							;	    The readbuffer index is reset to 0
    385  13eb							;
    386  13eb		       8d 39 27    ReadPrompt sta	promptChar
    387  13ee
    388  13ee							;
    389  13ee							; Prompt
    390  13ee							;
    391  13ee
    392  13ee		       ad 39 27    ReadPromptRetry lda	promptChar
    393  13f1		       09 00		      ora	#0	;any prompt?
    394  13f3		       f0 08		      beq	getlinenp
    395  13f5		       20 05 17 	      jsr	VOUTCH
    396  13f8		       a9 20		      lda	#$20
    397  13fa		       20 05 17 	      jsr	VOUTCH	;Space after prompt
    398  13fd							;
    399  13fd		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  13ff		       8e 36 27 	      stx	getlinx
    401  1402		       60		      rts
    402  1403							;
    403  1403							;===============================================================
    404  1403							; This fuction is the driver for the line input
    405  1403							; on call if a = 0 then it waits for all input
    406  1403							;	      a = 1 then nowait for input
    407  1403							; On exit
    408  1403							;		       c clear if not complete line
    409  1403							;		       c set if it was a complete line
    410  1403
    411  1403				   ReadLine
    412  1403		       8d 38 27 	      sta	inputNoWait
    413  1406		       c9 00		      cmp	#0
    414  1408		       f0 05		      beq	getline1
    415  140a		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  140d		       f0 2b		      beq	GetLineNoWait
    417  140f		       20 08 17    getline1   jsr	VGETCH
    418  1412					      if	CTMON65
    419  1412		       48		      pha
    420  1413		       20 05 17 	      jsr	VOUTCH	;echo echo echo
    421  1416		       68		      pla
    422  1417					      endif
    423  1417		       c9 0d		      cmp	#CR
    424  1419		       f0 15		      beq	getlind	;end of line
    425  141b		       c9 08		      cmp	#BS	;backspace?
    426  141d		       f0 1d		      beq	getlinebs
    427  141f		       ae 36 27 	      ldx	getlinx
    428  1422		       9d b2 26 	      sta	LINBUF,x
    429  1425		       e8		      inx
    430  1426		       8e 36 27 	      stx	getlinx
    431  1429		       ad 38 27 	      lda	inputNoWait
    432  142c		       f0 e1		      beq	getline1
    433  142e		       d0 0a		      bne	GetLineNoWait
    434  1430							;
    435  1430							; CR was hit
    436  1430							;
    437  1430		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1432		       ae 36 27 	      ldx	getlinx
    439  1435		       9d b2 26 	      sta	LINBUF,x
    440  1438
    441  1438		       38		      sec		; Carry set then cr received
    442  1439		       60		      rts
    443  143a
    444  143a				   GetLineNoWait
    445  143a		       18		      clc		; Carry clear no end of line
    446  143b		       60		      rts
    447  143c							;
    448  143c							; Backspace was hit
    449  143c							;
    450  143c		       ae 36 27    getlinebs  ldx	getlinx
    451  143f		       f0 0e		      beq	getlineEOL	;at start of line
    452  1441		       ca		      dex
    453  1442		       8e 36 27 	      stx	getlinx
    454  1445		       20 0b 17    getlinepbs jsr	puts
      0  1448					      db	27,"[K",0
      1  1448		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  144c		       4c 0f 14 	      jmp	getline1
    457  144f		       a9 20	   getlineEOL lda	#SPACE
    458  1451		       20 05 17 	      jsr	VOUTCH
    459  1454		       d0 ef		      bne	getlinepbs
    460  1456							;
    461  1456							;=====================================================
    462  1456							; Count the length of the line currently in LINBUF
    463  1456							; starting at offset Y.  Returns the length in X.  The
    464  1456							; starting offset in Y should point past the ASCII
    465  1456							; line number.  Also counts the trailing NULL and two
    466  1456							; extra bytes for where the line number will be.
    467  1456							; Update must now include leading length byte not the null at end ****************
    468  1456							;
    469  1456				   getLineLength
    470  1456		       a2 00		      ldx	#0	;size
    471  1458		       b9 b2 26    getLineL2  lda	LINBUF,y
    472  145b		       f0 04		      beq	getLineL3
    473  145d		       c8		      iny
    474  145e		       e8		      inx
    475  145f		       d0 f7		      bne	getLineL2
    476  1461		       e8	   getLineL3  inx		;count null at end
    477  1462		       e8		      inx		;line number LSB
    478  1463		       e8		      inx		;MSB
    479  1464		       e8		      inx		;change: count new leading line length
    480  1465		       8e 4c 27 	      stx	lineLength
    481  1468		       60		      rts
    482  1469							;
    483  1469							;=====================================================
    484  1469							; Count the length of the line pointed to by CURPTR.
    485  1469							; This also counts the line number and the terminating
    486  1469							; null.  Ie, this string returns 8:
    487  1469							;
    488  1469							; <lineLow><lineHi>Hello<null>
    489  1469							;
    490  1469							; Another way of looking at it: add the return value
    491  1469							; to the CURPTR and it'll point to the next line's
    492  1469							; line number.  Returns the value in Y.
    493  1469							; Update to ject get the leading byte length ********************
    494  1469							;
    495  1469							;getCURPTRLength
    496  1469							;		ldy	CURPTR
    497  1469							;		ldy	#3	;change: skip line number and leading length byte
    498  1469							;getCLineL2	lda	(CURPTR),y
    499  1469							;		beq	getCLineL3
    500  1469							;		iny
    501  1469							;		bne	getCLineL2
    502  1469							;getCLineL3	iny		;count null at end
    503  1469							;		rts
    504  1469
    505  1469							;
    506  1469							;=====================================================
    507  1469							; This saves ILPC.  This saves to a single save area,
    508  1469							; so it can't be called more than once.
    509  1469							;
    510  1469		       a5 43	   saveIL     lda	ILPC
    511  146b		       8d 48 27 	      sta	tempIL
    512  146e		       a5 44		      lda	ILPC+1
    513  1470		       8d 49 27 	      sta	tempIL+1
    514  1473		       60		      rts
    515  1474							;
    516  1474							;=====================================================
    517  1474							; This restores ILPC.
    518  1474							;
    519  1474		       ad 48 27    restoreIL  lda	tempIL
    520  1477		       85 43		      sta	ILPC
    521  1479		       ad 49 27 	      lda	tempIL+1
    522  147c		       85 44		      sta	ILPC+1
    523  147e		       60		      rts
    524  147f							;
    525  147f							;=====================================================
    526  147f							; This pushes R0 onto the stack.
    527  147f							;
    528  147f		       8c 3f 27    pushR0     sty	rtemp1
    529  1482		       a4 4a		      ldy	MATHSTACKPTR
    530  1484		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1486		       b0 34		      bcs	pusherr
    532  1488		       a5 52		      lda	R0
    533  148a		       91 48		      sta	(MATHSTACK),y
    534  148c		       c8		      iny
    535  148d		       a5 53		      lda	R0+1
    536  148f		       91 48		      sta	(MATHSTACK),y
    537  1491		       c8		      iny
    538  1492		       84 4a		      sty	MATHSTACKPTR
    539  1494		       ac 3f 27 	      ldy	rtemp1
    540  1497		       18		      clc
    541  1498		       60		      rts
    542  1499
    543  1499							;=====================================================
    544  1499							; This pushes curptr basic current line onto the call stack.
    545  1499							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1499
    547  1499				   pushLN
    548  1499		       8c 3f 27 	      sty	rtemp1
    549  149c		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  149e		       c5 4d		      cmp	GOSUBSTACKPTR
    551  14a0		       90 1a		      bcc	pusherr	; No error
    552  14a2		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  14a4		       a2 00		      ldx	#0	; Start of bytes to copy
    554  14a6				   pushLoop
    555  14a6		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  14a8		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  14aa		       c8		      iny		; Next destination
    558  14ab		       e8		      inx		; Next Source byte
    559  14ac		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  14ae		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  14b0
    562  14b0		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  14b2		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  14b4		       c8		      iny		; Next entry
    565  14b5
    566  14b5		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  14b7		       ac 3f 27 	      ldy	rtemp1
    568  14ba		       18		      clc
    569  14bb		       60		      rts
    570  14bc				   pusherr
    571  14bc		       38		      sec
    572  14bd		       60		      rts
    573  14be							;=====================================================
    574  14be							; This pops Top Off gosub call Stack and
    575  14be							; places it in CURPTR/CUROFF.
    576  14be							; This checks if the type = 1 GOSUB
    577  14be							; if not it removes what ever is on the stack
    578  14be							; until it finds the next return. Allowing
    579  14be							; a return from within a for/next
    580  14be		       8c 3f 27    popLN      sty	rtemp1
    581  14c1		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  14c3		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  14c5
    584  14c5				   popContinue
    585  14c5		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  14c7		       90 18		      bcc	poperr	; Process an error
    587  14c9
    588  14c9		       88		      dey		; Position to read entry type
    589  14ca		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  14cc		       c9 01		      cmp	#1	; Type is a gosub entry
    591  14ce		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  14d0
    593  14d0				   popLoop
    594  14d0		       88		      dey
    595  14d1		       ca		      dex
    596  14d2		       b1 4b		      lda	(GOSUBSTACK),y
    597  14d4		       95 4f		      sta	CURPTR,x
    598  14d6		       e0 00		      cpx	#0
    599  14d8		       d0 f6		      bne	popLoop	; Loop until all moved
    600  14da
    601  14da
    602  14da		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  14dc		       ac 3f 27 	      ldy	rtemp1
    604  14df		       18		      clc
    605  14e0		       60		      rts
    606  14e1
    607  14e1		       38	   poperr     sec
    608  14e2		       60		      rts
    609  14e3
    610  14e3		       88	   popSkipEntry dey
    611  14e4		       88		      dey
    612  14e5		       88		      dey
    613  14e6		       4c c5 14 	      jmp	popContinue
    614  14e9
    615  14e9							;
    616  14e9							;=====================================================
    617  14e9							; This pushes R1 onto the stack
    618  14e9							;
    619  14e9		       8c 3f 27    pushR1     sty	rtemp1
    620  14ec		       a4 4a		      ldy	MATHSTACKPTR
    621  14ee		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  14f0		       b0 ef		      bcs	poperr
    623  14f2		       a5 54		      lda	R1
    624  14f4		       91 48		      sta	(MATHSTACK),y
    625  14f6		       c8		      iny
    626  14f7		       a5 55		      lda	R1+1
    627  14f9		       91 48		      sta	(MATHSTACK),y
    628  14fb		       c8		      iny
    629  14fc		       84 4a		      sty	MATHSTACKPTR
    630  14fe		       ac 3f 27 	      ldy	rtemp1
    631  1501		       18		      clc
    632  1502		       60		      rts
    633  1503							;
    634  1503							;=====================================================
    635  1503							; This pops Top Of Stack and places it in R0.
    636  1503							;
    637  1503		       8c 3f 27    popR0      sty	rtemp1
    638  1506		       a4 4a		      ldy	MATHSTACKPTR
    639  1508		       f0 d7		      beq	poperr
    640  150a		       88		      dey
    641  150b		       b1 48		      lda	(MATHSTACK),y
    642  150d		       85 53		      sta	R0+1
    643  150f		       88		      dey
    644  1510		       b1 48		      lda	(MATHSTACK),y
    645  1512		       85 52		      sta	R0
    646  1514		       84 4a		      sty	MATHSTACKPTR
    647  1516		       ac 3f 27 	      ldy	rtemp1
    648  1519		       18		      clc
    649  151a		       60		      rts
    650  151b
    651  151b							;
    652  151b							;=====================================================
    653  151b							; This pops TOS and places it in R1.
    654  151b							;
    655  151b		       8c 3f 27    popR1      sty	rtemp1
    656  151e		       a4 4a		      ldy	MATHSTACKPTR
    657  1520		       f0 bf		      beq	poperr
    658  1522		       88		      dey
    659  1523		       b1 48		      lda	(MATHSTACK),y
    660  1525		       85 55		      sta	R1+1
    661  1527		       88		      dey
    662  1528		       b1 48		      lda	(MATHSTACK),y
    663  152a		       85 54		      sta	R1
    664  152c		       84 4a		      sty	MATHSTACKPTR
    665  152e		       ac 3f 27 	      ldy	rtemp1
    666  1531		       60		      rts
    667  1532							;
    668  1532							;=====================================================
    669  1532							; This pops TOS and places it in MQ.
    670  1532							;
    671  1532		       8c 3f 27    popMQ      sty	rtemp1
    672  1535		       a4 4a		      ldy	MATHSTACKPTR
    673  1537		       f0 a8		      beq	poperr
    674  1539		       88		      dey
    675  153a		       b1 48		      lda	(MATHSTACK),y
    676  153c		       85 57		      sta	MQ+1
    677  153e		       88		      dey
    678  153f		       b1 48		      lda	(MATHSTACK),y
    679  1541		       85 56		      sta	MQ
    680  1543		       84 4a		      sty	MATHSTACKPTR
    681  1545		       ac 3f 27 	      ldy	rtemp1
    682  1548		       60		      rts
    683  1549							;
    684  1549							;=====================================================
    685  1549							; This assists with multiplication and division by
    686  1549							; looking at R0 and R1 and saving a flag as to what
    687  1549							; sign the result will be.  Math is always done on
    688  1549							; positive numbers, so this converts negative numbers
    689  1549							; into positives.  On exit, R0 and R1 are both
    690  1549							; positive.  If the signs were different then 'signs'
    691  1549							; will be non-zero.
    692  1549							;
    693  1549		       a9 00	   SaveSigns  lda	#0
    694  154b		       8d 3e 27 	      sta	sign	;assume positive
    695  154e		       a5 53		      lda	R0+1	;MSB
    696  1550		       10 13		      bpl	SaveSigns1
    697  1552		       ee 3e 27 	      inc	sign	;it's negative
    698  1555		       49 ff		      eor	#$ff	;flip bits
    699  1557		       85 53		      sta	R0+1
    700  1559		       a5 52		      lda	R0
    701  155b		       49 ff		      eor	#$ff
    702  155d		       85 52		      sta	R0
    703  155f		       e6 52		      inc	R0
    704  1561		       d0 02		      bne	SaveSigns1
    705  1563		       e6 53		      inc	R0+1
    706  1565		       a5 55	   SaveSigns1 lda	R1+1
    707  1567		       10 1a		      bpl	SaveSigns2
    708  1569		       48		      pha
    709  156a		       ad 3e 27 	      lda	sign
    710  156d		       49 01		      eor	#1
    711  156f		       8d 3e 27 	      sta	sign
    712  1572		       68		      pla
    713  1573		       49 ff		      eor	#$ff	;flip bits
    714  1575		       85 55		      sta	R1+1
    715  1577		       a5 54		      lda	R1
    716  1579		       49 ff		      eor	#$ff
    717  157b		       85 54		      sta	R1
    718  157d		       e6 54		      inc	R1
    719  157f		       d0 02		      bne	SaveSigns2
    720  1581		       e6 55		      inc	R1+1
    721  1583		       60	   SaveSigns2 rts
    722  1584							;
    723  1584							;=====================================================
    724  1584							; This looks at the value of 'signs' and will convert
    725  1584							; both R0 and R1 to negative if set.
    726  1584							;
    727  1584				   RestoreSigns
    728  1584		       ad 3e 27 	      lda	sign
    729  1587		       f0 28		      beq	restoresigns2
    730  1589							;
    731  1589		       a5 52		      lda	R0
    732  158b		       d0 02		      bne	restoresigns3
    733  158d		       c6 53		      dec	R0+1
    734  158f				   restoresigns3
    735  158f		       c6 52		      dec	R0
    736  1591		       a5 52		      lda	R0
    737  1593		       49 ff		      eor	#$ff
    738  1595		       85 52		      sta	R0
    739  1597		       a5 53		      lda	R0+1
    740  1599		       49 ff		      eor	#$ff
    741  159b		       85 53		      sta	R0+1
    742  159d							;
    743  159d		       a5 54		      lda	R1
    744  159f		       d0 02		      bne	restoresigns4
    745  15a1		       c6 55		      dec	R1+1
    746  15a3				   restoresigns4
    747  15a3		       c6 54		      dec	R1
    748  15a5		       a5 54		      lda	R1
    749  15a7		       49 ff		      eor	#$ff
    750  15a9		       85 54		      sta	R1
    751  15ab		       a5 55		      lda	R1+1
    752  15ad		       49 ff		      eor	#$ff
    753  15af		       85 55		      sta	R1+1
    754  15b1							;
    755  15b1				   restoresigns2
    756  15b1		       60		      rts
    757  15b2							;
    758  15b2							;=====================================================
    759  15b2							; Skip over spaces.  Returns Y with the offset to
    760  15b2							; either the last character in the line, or the first
    761  15b2							; non-space character.
    762  15b2							;
    763  15b2
    764  15b2		       c8	   skipsp2    iny
    765  15b3		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  15b5		       f0 04		      beq	Skip3	;end of line
    767  15b7		       c9 20		      cmp	#SPACE
    768  15b9		       f0 f7		      beq	skipsp2
    769  15bb		       60	   Skip3      rts
    770  15bc							;*********************************************************
    771  15bc							; Output a CR/LF combination to the console.  Preserves
    772  15bc							; all registers.
    773  15bc							;
    774  15bc		       48	   tbcrlf     pha
    775  15bd		       a9 0d		      lda	#CR
    776  15bf		       20 05 17 	      jsr	VOUTCH
    777  15c2		       a9 0a		      lda	#LF
    778  15c4		       20 05 17 	      jsr	VOUTCH
    779  15c7		       68		      pla
    780  15c8		       60		      rts
    781  15c9							;
    782  15c9							;=====================================================
    783  15c9							; Some logic to print the Line of basic code being executed
    784  15c9		       24 40	   idbgBasic  bit	ILTrace
    785  15cb		       50 70		      bvc	dbgBasicNone
    786  15cd		       98		      tya
    787  15ce		       48		      pha
    788  15cf		       20 8e 17 	      jsr	SetOutDebug
    789  15d2		       20 2e 17 	      jsr	PrtPrgLine
    790  15d5		       20 bc 15 	      jsr	CRLF
    791  15d8		       a5 40		      lda	ILTrace
    792  15da		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  15dc		       f0 5a		      beq	dbgBasicDone
    794  15de		       20 99 17 	      jsr	SetInDebug
    795  15e1		       20 0b 17 	      jsr	puts
      0  15e4					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  15e4		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1621				   dbgBasicLoop
    798  1621		       20 08 17 	      jsr	VGETCH
    799  1624		       20 bc 15 	      jsr	CRLF
    800  1627		       20 f8 16 	      jsr	SetInConsole
    801  162a
    802  162a		       c9 73		      cmp	#'s	; Quit program
    803  162c		       f0 12		      beq	dbgBasicStop
    804  162e
    805  162e		       c9 64		      cmp	#'d	; Display Variables
    806  1630		       d0 06		      bne	dbgBasicDone
    807  1632
    808  1632		       20 bd 17 	      jsr	PrintAllVars
    809  1635		       18		      clc
    810  1636		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1638
    812  1638		       20 eb 16    dbgBasicDone jsr	SetOutConsole
    813  163b		       68		      pla
    814  163c		       a8		      tay
    815  163d		       4c bb 02    dbgBasicNone jmp	NextIL
    816  1640
    817  1640				   dbgBasicStop
    818  1640		       20 eb 16 	      jsr	SetOutConsole
    819  1643		       68		      pla
    820  1644		       a8		      tay
    821  1645		       4c 01 06 	      jmp	iFIN
    822  1648							;
    823  1648							;=====================================================
    824  1648							; This is some debug logic which displays the current
    825  1648							; value of the ILPC and the line buffer.
    826  1648							;
    827  1648		       24 40	   dbgLine    bit	ILTrace
    828  164a		       30 01		      bmi	dbgPrt
    829  164c		       60		      rts
    830  164d				   dbgPrt
    831  164d		       20 8e 17 	      jsr	SetOutDebug
    832  1650		       20 0b 17 	      jsr	puts
      0  1653					      db	"ILPC: ",0
      1  1653		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  165a		       a5 44		      lda	ILPC+1
    835  165c		       20 aa 0d 	      jsr	OUTHEX
    836  165f		       a5 43		      lda	ILPC
    837  1661		       20 aa 0d 	      jsr	OUTHEX
    838  1664		       a9 20		      lda	#SPACE
    839  1666		       20 05 17 	      jsr	VOUTCH
    840  1669		       a0 00		      ldy	#0
    841  166b		       b1 43		      lda	(ILPC),y
    842  166d		       20 aa 0d 	      jsr	OUTHEX
    843  1670							;
    844  1670							; Display the CURPTR value and offset
    845  1670							;
    846  1670		       20 0b 17 	      jsr	puts
      0  1673					      db	", CURPTR: ",0
      1  1673		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  167e		       a5 50		      lda	CURPTR+1
    849  1680		       20 aa 0d 	      jsr	OUTHEX
    850  1683		       a5 4f		      lda	CURPTR
    851  1685		       20 aa 0d 	      jsr	OUTHEX
    852  1688		       a9 2b		      lda	#'+
    853  168a		       20 05 17 	      jsr	VOUTCH
    854  168d		       a5 51		      lda	CUROFF
    855  168f		       20 aa 0d 	      jsr	OUTHEX
    856  1692							;
    857  1692		       20 bc 15 	      jsr	CRLF
    858  1695		       20 eb 16 	      jsr	SetOutConsole
    859  1698		       20 cb 16 	      jsr	ILChkRange
    860  169b		       b0 02		      bcs	dbgLineErr
    861  169d		       18		      clc
    862  169e		       60		      rts
    863  169f
    864  169f				   dbgLineErr
    865  169f		       20 8e 17 	      jsr	SetOutDebug
    866  16a2		       20 0b 17 	      jsr	puts
      0  16a5					      db	"Outside Valid IL Address Range",CR,LF,0
      1  16a5		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  16c6		       20 eb 16 	      jsr	SetOutConsole
    869  16c9		       38		      sec
    870  16ca		       60		      rts
    871  16cb
    872  16cb		       a5 44	   ILChkRange lda	ILPC+1
    873  16cd		       c9 19		      cmp	#IL>>8
    874  16cf		       90 18		      bcc	ILBadRange
    875  16d1		       d0 06		      bne	ILChkHigh
    876  16d3
    877  16d3		       a5 43		      lda	ILPC
    878  16d5		       c9 15		      cmp	#IL&$ff
    879  16d7		       90 10		      bcc	ILBadRange
    880  16d9
    881  16d9		       a5 44	   ILChkHigh  lda	ILPC+1
    882  16db		       c9 1d		      cmp	#ILEND>>8
    883  16dd		       90 08		      bcc	ILGoodRange
    884  16df		       d0 08		      bne	ILBadRange
    885  16e1
    886  16e1		       a5 43		      lda	ILPC
    887  16e3		       c9 e1		      cmp	#ILEND&$ff
    888  16e5		       b0 02		      bcs	ILBadRange
    889  16e7
    890  16e7		       18	   ILGoodRange clc
    891  16e8		       60		      rts
    892  16e9				   ILBadRange
    893  16e9		       38		      sec
    894  16ea		       60		      rts
    895  16eb
    896  16eb
    897  16eb							;=====================================================
    898  16eb							; Set output vector to the console output function
    899  16eb							;
    900  16eb				   SetOutConsole
    901  16eb		       48		      pha
    902  16ec		       a9 0c		      lda	#OUTCH&$ff
    903  16ee		       8d 43 27 	      sta	BOutVec
    904  16f1		       a9 f0		      lda	#OUTCH>>8
    905  16f3		       8d 44 27 	      sta	BOutVec+1
    906  16f6		       68		      pla
    907  16f7		       60		      rts
    908  16f8
    909  16f8				   SetInConsole
    910  16f8		       48		      pha
    911  16f9		       a9 09		      lda	#GETCH&$ff
    912  16fb		       8d 45 27 	      sta	BInVec
    913  16fe		       a9 f0		      lda	#GETCH>>8
    914  1700		       8d 46 27 	      sta	BInVec+1
    915  1703		       68		      pla
    916  1704		       60		      rts
    917  1705
    918  1705							;=====================================================
    919  1705							; Jump to the output/input function in BOutVec/BInVec
    920  1705							;
    921  1705		       6c 43 27    VOUTCH     jmp	(BOutVec)
    922  1708		       6c 45 27    VGETCH     jmp	(BInVec)
    923  170b							;
    924  170b							;=====================================================
    925  170b							; Print the string that immediately follows the JSR to
    926  170b							; this function.  Stops when a null byte is found,
    927  170b							; then returns to the instruction immediately
    928  170b							; following the null.
    929  170b							;
    930  170b							; Thanks to Ross Archer for this code.
    931  170b							; http://www.6502.org/source/io/primm.htm
    932  170b							;
    933  170b
    934  170b		       68	   tbputs     pla		;Get the low part of "return" address
    935  170c							;(data start address)
    936  170c		       85 5e		      sta	PrtFrom
    937  170e		       68		      pla
    938  170f		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    939  1711							;(data start address)
    940  1711							;Note: actually we're pointing one short
    941  1711		       a0 01	   PSINB      ldy	#1
    942  1713		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    943  1715		       e6 5e		      inc	PrtFrom	;update the pointer
    944  1717		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    945  1719		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    946  171b		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    947  171d							;   Accumulator
    948  171d		       f0 06		      beq	PSIX1	;don't print the final NULL
    949  171f		       20 05 17 	      jsr	VOUTCH	;write it out
    950  1722		       4c 11 17 	      jmp	PSINB	;back around
    951  1725		       e6 5e	   PSIX1      inc	PrtFrom
    952  1727		       d0 02		      bne	PSIX2
    953  1729		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    954  172b		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    955  172e
    956  172e							;
    957  172e
    958  172e							;====================================================
    959  172e		       27 47	   PrtTerm    equ	tempy
    960  172e
    961  172e							; on exit Print Y has the offset to use
    962  172e							; input y =	 addr low
    963  172e							;	 x =	 addr high
    964  172e							;	 a =	 termination string
    965  172e
    966  172e				   PrtPrgLine
    967  172e		       a9 00		      lda	#0
    968  1730		       8d 47 27 	      sta	PrtTerm
    969  1733		       f0 05		      beq	PrtPrgText
    970  1735
    971  1735		       a9 22	   PrtQuoted  lda	#'"
    972  1737		       8d 47 27 	      sta	PrtTerm
    973  173a
    974  173a		       a4 51	   PrtPrgText ldy	CUROFF
    975  173c		       a5 4f		      lda	CURPTR
    976  173e		       85 5e		      sta	PrtFrom
    977  1740		       a5 50		      lda	CURPTR+1
    978  1742		       85 5f		      sta	PrtFrom+1
    979  1744		       4c 50 17 	      jmp	PrtLoop
    980  1747
    981  1747							; Print a string pointed to by x= h, y=l terminated by a
    982  1747							; Return y as the length
    983  1747
    984  1747		       86 5f	   PrtStr     stx	PrtFrom+1
    985  1749		       84 5e		      sty	PrtFrom
    986  174b		       8d 47 27 	      sta	PrtTerm
    987  174e		       a0 00		      ldy	#0
    988  1750							;
    989  1750							; On entry here ptrfrom and prtterm point to area to print
    990  1750							;
    991  1750		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    992  1752		       cd 47 27 	      cmp	PrtTerm
    993  1755		       f0 0b		      beq	PrtEnd
    994  1757		       c9 00		      cmp	#0	; always end if 0 is found
    995  1759		       f0 07		      beq	PrtEnd
    996  175b		       20 05 17 	      jsr	VOUTCH
    997  175e		       c8		      iny
    998  175f		       4c 50 17 	      jmp	PrtLoop
    999  1762		       c8	   PrtEnd     iny		;return byte after the copy
   1000  1763		       60		      rts
   1001  1764
   1002  1764							;====================================================
   1003  1764							;Clear the terminal assume it is ansii or vt100
   1004  1764							;
   1005  1764				   iCLEARSCREEN
   1006  1764		       20 0b 17 	      jsr	puts
      0  1767					      db	$1b,'[,'2,'J,0
      1  1767		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
   1008  176c		       4c bb 02 	      jmp	NextIL
   1009  176f
   1010  176f							;====================================================
   1011  176f							; Push true and false onto math stack
   1012  176f				   pushTrue
   1013  176f		       a9 ff		      lda	#$ff
   1014  1771		       85 52	   pushTF     sta	R0
   1015  1773		       85 53		      sta	R0+1
   1016  1775		       20 7f 14 	      jsr	pushR0
   1017  1778		       60		      rts
   1018  1779		       a9 00	   pushFalse  lda	#0
   1019  177b		       f0 f4		      beq	pushTF
   1020  177d
   1021  177d							;======================================================
   1022  177d							; Copy stack top to R1
   1023  177d				   CopyStackR1
   1024  177d		       98		      tya
   1025  177e		       48		      pha
   1026  177f		       a4 4a		      ldy	MATHSTACKPTR
   1027  1781		       88		      dey
   1028  1782		       b1 48		      lda	(MATHSTACK),y
   1029  1784		       85 55		      sta	R1+1
   1030  1786		       88		      dey
   1031  1787		       b1 48		      lda	(MATHSTACK),y
   1032  1789		       85 54		      sta	R1
   1033  178b		       68		      pla
   1034  178c		       a8		      tay
   1035  178d		       60		      rts
   1036  178e
   1037  178e
   1038  178e							;====================================================
   1039  178e							;Swap the out debug call for standard calls
   1040  178e
   1041  178e				   SetOutDebug
   1042  178e					      if	USEDEBUGPORT
   1043  178e		       a9 ae		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1044  1790		       8d 43 27 	      sta	BOutVec
   1045  1793		       a9 17		      lda	#OUTDEBUG>>8
   1046  1795		       8d 44 27 	      sta	BOutVec+1
   1047  1798					      endif
   1048  1798		       60		      rts
   1049  1799				   SetInDebug
   1050  1799					      if	USEDEBUGPORT
   1051  1799		       a9 b2		      lda	#INDEBUG&$ff
   1052  179b		       8d 45 27 	      sta	BInVec
   1053  179e		       a9 17		      lda	#INDEBUG>>8
   1054  17a0		       8d 46 27 	      sta	BInVec+1
   1055  17a3					      endif
   1056  17a3		       60		      rts
   1057  17a4							;
   1058  17a4							;====================================================
   1059  17a4							; Output to the debug console
   1060  17a4							;     x = high address byte
   1061  17a4							;     y = low address byte
   1062  17a4							;     a = Terminator for string
   1063  17a4				   DebugWrite
   1064  17a4		       20 8e 17 	      jsr	SetOutDebug
   1065  17a7		       20 47 17 	      jsr	PrtStr
   1066  17aa		       20 eb 16 	      jsr	SetOutConsole
   1067  17ad		       60		      rts
   1068  17ae
   1069  17ae				   OUTDEBUG
   1070  17ae		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1071  17b1		       60		      RTS
   1072  17b2
   1073  17b2		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1074  17b5		       29 01		      and	#$01
   1075  17b7		       f0 f9		      beq	INDEBUG
   1076  17b9		       ad 21 e0 	      lda	DEBUGPORT+1
   1077  17bc		       60		      rts
   1078  17bd							;
   1079  17bd							;=======================================================
   1080  17bd							; Print all Variables
   1081  17bd				   PrintAllVars
   1082  17bd		       a0 00		      ldy	#0
   1083  17bf		       a9 41		      lda	#'A
   1084  17c1				   PrintAllVarsLoop
   1085  17c1		       48		      pha
   1086  17c2		       b1 41		      lda	(VARIABLES),y
   1087  17c4		       85 52		      sta	R0
   1088  17c6		       c8		      iny
   1089  17c7		       b1 41		      lda	(VARIABLES),y
   1090  17c9		       85 53		      sta	R0+1
   1091  17cb
   1092  17cb		       68		      pla		;get the current letter
   1093  17cc		       48		      pha
   1094  17cd		       20 05 17 	      jsr	VOUTCH
   1095  17d0		       20 0b 17 	      jsr	puts
      0  17d3					      db	"=",0
      1  17d3		       3d 00		      .byte.b	"=",0
   1097  17d5		       68		      pla
   1098  17d6		       aa		      tax
   1099  17d7		       e8		      inx
   1100  17d8		       8a		      txa
   1101  17d9		       48		      pha		;
   1102  17da
   1103  17da		       98		      tya
   1104  17db		       48		      pha
   1105  17dc		       20 00 0d 	      jsr	PrintDecimal
   1106  17df		       20 0b 17 	      jsr	puts
      0  17e2					      db	" ",0
      1  17e2		       20 00		      .byte.b	" ",0
   1108  17e4		       68		      pla
   1109  17e5		       a8		      tay
   1110  17e6		       c8		      iny
   1111  17e7		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1112  17e9		       90 d6		      bcc	PrintAllVarsLoop
   1113  17eb		       20 bc 15 	      jsr	CRLF
   1114  17ee
   1115  17ee		       68		      pla
   1116  17ef		       60		      rts
   1117  17f0
   1118  17f0
   1119  17f0
   1120  17f0
   1121  17f0
   1122  17f0
   1123  17f0
   1124  17f0
   1125  17f0
   1126  17f0
   1127  17f0
   1128  17f0
   1129  17f0
   1130  17f0
   1131  17f0
   1132  17f0
   1133  17f0
   1134  17f0
   1135  17f0
------- FILE mytb.asm
   2208  17f0
   2209  17f0					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  17f0					      include	"storage.asm"
      1  17f0							;
      2  17f0							;=====================================================
      3  17f0							;=====================================================
      4  17f0							;=====================================================
      5  17f0							; This file contains the functions for saving and
      6  17f0							; restoring programs from some sort of mass storage
      7  17f0							; device.  This particular version is for using the
      8  17f0							; Corsham Tech SD Card System.
      9  17f0							;=====================================================
     10  17f0							;=====================================================
     11  17f0							;=====================================================
     12  17f0
     13 U1de1					      seg.u	TBData
     14 U1de1		       00	   diskBufLength ds	1
     15 U1de2		       00	   diskBufOffset ds	1
     16 U1de3		       00 00 00 00*DiskFileName ds	14
     17 U1df1
     18  17f0					      SEG	Code
     19  17f0
     20  17f0							;
     21  17f0							;=====================================================
     22  17f0							; Open a file for reading as a program.  The next
     23  17f0							; thing on the line should be the filename.
     24  17f0							;
     25  17f0				   iOPENREAD
     26  17f0					      if	XKIM || CTMON65
     27  17f0		       a4 51		      ldy	CUROFF
     28  17f2		       b1 4f		      lda	(CURPTR),y
     29  17f4		       d0 07		      bne	iOPENfn	;might be filename
     30  17f6							;
     31  17f6							; No filename supplied.
     32  17f6							;
     33  17f6		       a9 00	   iOPENnofn  lda	#0
     34  17f8		       a2 09		      ldx	#ERR_NO_FILENAME
     35  17fa		       4c 18 06 	      jmp	iErr2
     36  17fd							;
     37  17fd							; Add the offset into the buffer start
     38  17fd							;
     39  17fd		       18	   iOPENfn    clc
     40  17fe		       98		      tya
     41  17ff		       65 4f		      adc	CURPTR
     42  1801		       a8		      tay		;LSB
     43  1802		       a5 50		      lda	CURPTR+1
     44  1804		       69 00		      adc	#0
     45  1806		       aa		      tax
     46  1807		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  180a		       90 07		      bcc	Ropenok	;branch if opened ok
     48  180c							;
     49  180c							; Open failed
     50  180c							;
     51  180c		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  180e		       a9 00	   Rdfail2    lda	#0
     53  1810		       4c 18 06 	      jmp	iErr2
     54  1813							;
     55  1813							; Clear counts and offsets so the next read will
     56  1813							; cause the file to be read.
     57  1813							;
     58  1813		       a9 00	   Ropenok    lda	#0
     59  1815		       8d e2 1d 	      sta	diskBufOffset
     60  1818		       8d e1 1d 	      sta	diskBufLength
     61  181b		       4c bb 02 	      jmp	NextIL
     62  181e					      endif
     63  181e
     64  181e							;
     65  181e							;==============================JUSTLOSTINTIME 08/02/2022========
     66  181e							;Remove a file from the disk
     67  181e				   iRMFILE
     68  181e					      if	XKIM || CTMON65
     69  181e		       a4 51		      ldy	CUROFF
     70  1820		       b1 4f		      lda	(CURPTR),y
     71  1822		       f0 19		      beq	iRMnofn
     72  1824							;
     73  1824		       18		      clc
     74  1825		       98		      tya
     75  1826		       65 4f		      adc	CURPTR
     76  1828		       a8		      tay		;LSB
     77  1829		       a5 50		      lda	CURPTR+1
     78  182b		       69 00		      adc	#0
     79  182d		       aa		      tax
     80  182e		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1831		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1833		       a9 00		      lda	#0
     83  1835		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1837		       4c 18 06 	      jmp	iErr2
     85  183a		       4c bb 02    wrmOk      jmp	NextIL
     86  183d
     87  183d							; No filename supplied.
     88  183d							;
     89  183d		       a9 00	   iRMnofn    lda	#0
     90  183f		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1841		       4c 18 06 	      jmp	iErr2
     92  1844					      endif
     93  1844							;
     94  1844							;=====================================================
     95  1844				   iOPENWRITE
     96  1844					      if	XKIM || CTMON65
     97  1844		       a4 51		      ldy	CUROFF
     98  1846		       b1 4f		      lda	(CURPTR),y
     99  1848		       f0 f3		      beq	iRMnofn
    100  184a							;
    101  184a		       18		      clc
    102  184b		       98		      tya
    103  184c		       65 4f		      adc	CURPTR
    104  184e		       a8		      tay		;LSB
    105  184f		       a5 50		      lda	CURPTR+1
    106  1851		       69 00		      adc	#0
    107  1853		       aa		      tax
    108  1854		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1857		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1859							;
    111  1859							; Open failed
    112  1859							;
    113  1859		       a9 00	   Wdfail     lda	#0
    114  185b		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  185d		       4c 18 06 	      jmp	iErr2
    116  1860							;
    117  1860		       4c bb 02    Wopenok    jmp	NextIL
    118  1863					      endif
    119  1863							;
    120  1863							;=====================================================
    121  1863							; Gets a line of input from the disk file and puts it
    122  1863							; into LINBUF.
    123  1863							;
    124  1863							; On exit:
    125  1863							;    CURPTR points to LINBUF
    126  1863							;    LINBUF contains the line with 0 at the end.
    127  1863							;    Y has offset to first non-space character
    128  1863							;    CURROFF has the same as Y.
    129  1863							;
    130  1863				   iDGETLINE
    131  1863					      if	XKIM || CTMON65
    132  1863		       a2 b2		      ldx	#LINBUF&$ff
    133  1865		       86 4f		      stx	CURPTR
    134  1867		       a2 26		      ldx	#LINBUF>>8
    135  1869		       86 50		      stx	CURPTR+1
    136  186b							;
    137  186b		       a2 00		      ldx	#0	;offset
    138  186d		       8e 36 27    iDgetLoop  stx	getlinx
    139  1870		       20 ce 18 	      jsr	getNextFileByte
    140  1873		       b0 16		      bcs	iGetEOF
    141  1875		       c9 0d		      cmp	#CR
    142  1877		       f0 0d		      beq	iGetEOL
    143  1879		       c9 0a		      cmp	#LF
    144  187b		       f0 09		      beq	iGetEOL
    145  187d		       ae 36 27 	      ldx	getlinx
    146  1880		       9d b2 26 	      sta	LINBUF,x
    147  1883		       e8		      inx
    148  1884		       d0 e7		      bne	iDgetLoop
    149  1886							;
    150  1886							; Handle end of line.	If the line has nothing, loop
    151  1886							; back and get another line.
    152  1886							;
    153  1886		       ae 36 27    iGetEOL    ldx	getlinx	;blank line?
    154  1889		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  188b							;
    156  188b							; This can fall through when there is a line, or
    157  188b							; called directly when EOF is encountered.
    158  188b							;
    159  188b		       ae 36 27    iGetEOF    ldx	getlinx
    160  188e		       a9 00		      lda	#0
    161  1890		       9d b2 26 	      sta	LINBUF,x
    162  1893		       85 51		      sta	CUROFF
    163  1895		       a0 00		      ldy	#0
    164  1897		       20 b3 15 	      jsr	SkipSpaces
    165  189a		       4c bb 02 	      jmp	NextIL
    166  189d					      endif
    167  189d
    168  189d							;
    169  189d							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  189d							; DISK
    171  189d							;
    172  189d				   iDDIR
    173  189d					      if	XKIM || CTMON65
    174  189d		       20 30 f0 	      jsr	DiskDir
    175  18a0							;
    176  18a0							; Get/Display each entry
    177  18a0							;
    178  18a0		       a2 1d	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  18a2		       a0 e3		      ldy	#DiskFileName&$ff
    180  18a4		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  18a7		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  18a9		       20 0b 17 	      jsr	puts
      0  18ac					      db	"   ",0
      1  18ac		       20 20 20 00	      .byte.b	"   ",0
    184  18b0							; Print the line to the console
    185  18b0		       a2 1d		      ldx	#DiskFileName>>8	;pointer to buffer
    186  18b2		       a0 e3		      ldy	#DiskFileName&$ff
    187  18b4		       a5 00		      lda	0
    188  18b6		       20 47 17 	      jsr	PrtStr	;else print name
    189  18b9		       20 18 f0 	      jsr	crlf
    190  18bc
    191  18bc		       4c a0 18 	      jmp	DiskDirLoop	;do next entry
    192  18bf
    193  18bf		       4c bb 02    DiskDirEnd jmp	NextIL
    194  18c2					      endif
    195  18c2							;
    196  18c2							;=====================================================
    197  18c2							; Does a LIST to a Disk file.
    198  18c2							;
    199  18c2				   iDLIST
    200  18c2					      if	XKIM || CTMON65
    201  18c2		       20 fd 18 	      jsr	SetOutDisk
    202  18c5		       4c e8 07 	      jmp	iLST2
    203  18c8					      endif
    204  18c8							;
    205  18c8							;=====================================================
    206  18c8							; Closes any pending disk file.  Okay to call if there
    207  18c8							; is no open file.
    208  18c8							;
    209  18c8				   iDCLOSE
    210  18c8					      if	XKIM || CTMON65
    211  18c8		       20 42 f0 	      jsr	DiskClose
    212  18cb		       4c bb 02 	      jmp	NextIL
    213  18ce					      endif
    214  18ce							;
    215  18ce							;=====================================================
    216  18ce							; This gets the next byte from an open disk file.  If
    217  18ce							; there are no more bytes left, this returns C set.
    218  18ce							; Else, C is clear and A contains the character.
    219  18ce							;
    220  18ce				   getNextFileByte
    221  18ce					      if	XKIM || CTMON65
    222  18ce		       ae e2 1d 	      ldx	diskBufOffset
    223  18d1		       ec e1 1d 	      cpx	diskBufLength
    224  18d4		       d0 14		      bne	hasdata	;branch if still data
    225  18d6							;
    226  18d6							; There is no data left in the buffer, so read a
    227  18d6							; block from the SD system.
    228  18d6							;
    229  18d6		       a9 84		      lda	#BUFFER_SIZE
    230  18d8		       a2 df		      ldx	#buffer>>8
    231  18da		       a0 0a		      ldy	#buffer&$ff
    232  18dc		       20 3c f0 	      jsr	DiskRead
    233  18df		       b0 12		      bcs	getNextEof
    234  18e1							;
    235  18e1							; A contains the number of bytes actually read.
    236  18e1							;
    237  18e1		       8d e1 1d 	      sta	diskBufLength	;save length
    238  18e4		       c9 00		      cmp	#0	;shouldn't happen
    239  18e6		       f0 0b		      beq	getNextEof
    240  18e8							;
    241  18e8		       a2 00		      ldx	#0
    242  18ea		       bd 0a df    hasdata    lda	buffer,x
    243  18ed		       e8		      inx
    244  18ee		       8e e2 1d 	      stx	diskBufOffset
    245  18f1		       18		      clc
    246  18f2		       60		      rts
    247  18f3							;
    248  18f3		       a9 00	   getNextEof lda	#0
    249  18f5		       8d e2 1d 	      sta	diskBufOffset
    250  18f8		       8d e1 1d 	      sta	diskBufLength
    251  18fb		       38		      sec
    252  18fc		       60		      rts
    253  18fd							;
    254  18fd							;=====================================================
    255  18fd							; Set output vector to the disk output function
    256  18fd							;
    257  18fd		       a9 08	   SetOutDisk lda	#DOUT&$ff
    258  18ff		       8d 43 27 	      sta	BOutVec
    259  1902		       a9 19		      lda	#DOUT/256
    260  1904		       8d 44 27 	      sta	BOutVec+1
    261  1907		       60		      rts
    262  1908							;
    263  1908							;=====================================================
    264  1908
    265  1908		       8d 0a df    DOUT       sta	buffer
    266  190b		       a9 01		      lda	#1
    267  190d		       a0 0a		      ldy	#buffer&$ff
    268  190f		       a2 df		      ldx	#buffer>>8
    269  1911		       20 3f f0 	      jsr	DiskWrite
    270  1914							;
    271  1914							; need error checking here
    272  1914							;
    273  1914		       60		      rts
    274  1915					      endif
    275  1915
    276  1915
------- FILE mytb.asm
   2211  1915					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1915					      include	"IL.inc"
      1  1915
      2  1915							;=====================================================
      3  1915							; IL.inc
      4  1915							; These are macros for IL instructions
      5  1915							;
      6  1915					      mac	dw
      7  1915					      .word	{0}
      8  1915					      endm
      9  1915					      mac	db
     10  1915					      .byte	{0}
     11  1915					      endm
     12  1915					      macro	xinit
     13  1915					      db	0
     14  1915					      endm		;reset the il to start clear all
     15  1915							;
     16  1915					      macro	done
     17  1915					      db	1
     18  1915					      endm		;print an error if not end of line
     19  1915							;
     20  1915					      macro	prs
     21  1915					      db	2
     22  1915					      endm		;print a quoted string
     23  1915							;
     24  1915					      macro	prn
     25  1915					      db	3
     26  1915					      endm		;print a number
     27  1915							;
     28  1915					      macro	spc
     29  1915					      db	4
     30  1915					      endm		;print space til new tabstop
     31  1915							;
     32  1915					      macro	nline
     33  1915					      db	5
     34  1915					      endm		;print a new line crlf
     35  1915							;
     36  1915							; My NXT is a bit different in that it takes one
     37  1915							; parameter, which is an address.  If the BASIC
     38  1915							; program is currently running then move to the
     39  1915							; next line and continue execution.  However, if
     40  1915							; in direct mode, jump to the specified IL label.
     41  1915							;
     42  1915					      macro	nxt
     43  1915					      db	6
     44  1915					      dw	{1}	; addr
     45  1915					      endm		; addr
     46  1915							;
     47  1915					      macro	xfer
     48  1915					      db	7
     49  1915					      endm
     50  1915							;
     51  1915					      macro	sav
     52  1915					      db	8
     53  1915					      db	{1}
     54  1915					      endm
     55  1915							;
     56  1915					      macro	rstr
     57  1915					      db	9
     58  1915					      endm
     59  1915							;
     60  1915					      macro	cmpr
     61  1915					      db	10
     62  1915					      endm
     63  1915							;
     64  1915					      macro	innum
     65  1915					      db	11
     66  1915					      endm
     67  1915							;
     68  1915					      macro	fin
     69  1915					      db	12
     70  1915					      endm
     71  1915							;
     72  1915							; ERR is followed by an error number.	The error
     73  1915							; code is printed along with the line number.
     74  1915							; Control is passed to the statement set with
     75  1915							; the ERRGOTO statement.
     76  1915							;
     77  1915					      macro	errmsg
     78  1915					      db	13
     79  1915					      dw	{1}	;ecode
     80  1915					      endm		;ecode
     81  1915							;
     82  1915					      macro	add
     83  1915					      db	14
     84  1915					      endm
     85  1915							;
     86  1915					      macro	sub
     87  1915					      db	15
     88  1915					      endm
     89  1915							;
     90  1915					      macro	neg
     91  1915					      db	16
     92  1915					      endm
     93  1915							;
     94  1915					      macro	mul
     95  1915					      db	17
     96  1915					      endm
     97  1915							;
     98  1915					      macro	div
     99  1915					      db	18
    100  1915					      endm
    101  1915							;
    102  1915					      macro	store
    103  1915					      db	19
    104  1915					      endm
    105  1915							;
    106  1915					      macro	ind
    107  1915					      db	20
    108  1915					      endm
    109  1915							;
    110  1915					      macro	lst
    111  1915					      db	21
    112  1915					      endm
    113  1915							;
    114  1915					      macro	init
    115  1915					      db	22
    116  1915					      endm
    117  1915							;
    118  1915					      macro	getline
    119  1915					      db	23
    120  1915					      endm
    121  1915							;
    122  1915					      macro	insert
    123  1915					      db	24
    124  1915					      endm
    125  1915							;
    126  1915					      macro	rtn
    127  1915					      db	25
    128  1915					      endm
    129  1915							;
    130  1915					      macro	exit
    131  1915					      db	26
    132  1915					      endm
    133  1915							;
    134  1915					      macro	lit
    135  1915					      db	27
    136  1915					      dw	{1}	;value
    137  1915					      endm		; value LIT
    138  1915							;
    139  1915					      macro	call
    140  1915					      db	28
    141  1915					      dw	{1}	;addr
    142  1915					      endm		;addr
    143  1915							;
    144  1915							; IJMP will set the IL PC to the specified value.
    145  1915							;
    146  1915					      macro	ijmp
    147  1915					      db	29
    148  1915					      dw	{1}	;addr
    149  1915					      endm		;addr
    150  1915							;
    151  1915					      macro	vinit
    152  1915					      db	30
    153  1915					      endm
    154  1915							;
    155  1915							; ERRGOTO sets the point in the code where the IL
    156  1915							; interpreter will go after any error.
    157  1915							;
    158  1915					      macro	errgoto
    159  1915					      db	31
    160  1915					      dw	{1}	;addr
    161  1915					      endm		;addr
    162  1915							;
    163  1915					      macro	tst
    164  1915					      db	32
    165  1915					      db	({1}-*)-1	;(addr-*)-1
    166  1915					      db	{2},0	;string,0
    167  1915					      endm		;addr,string
    168  1915							;
    169  1915					      macro	tstv
    170  1915					      db	33
    171  1915					      db	({1}-*)-1	;(addr-*)-1
    172  1915					      endm		;addr
    173  1915							;
    174  1915					      macro	tstl
    175  1915					      db	34
    176  1915					      db	({1}-*)-1	;(addr-*)-1
    177  1915					      endm		;addr
    178  1915							;
    179  1915					      macro	tstn
    180  1915					      db	35
    181  1915					      db	({1}-*)-1	;(addr-*)-1
    182  1915					      endm		;addr
    183  1915							;
    184  1915							; FREE returns the amount of free RAM on top of
    185  1915							; the stack.  This is the amount of room the user
    186  1915							; program has available.
    187  1915							;
    188  1915					      macro	free
    189  1915					      db	36
    190  1915					      endm
    191  1915							;
    192  1915							; RANDOM takes the top item off the stack and
    193  1915							; replaces it with a random number that is
    194  1915							; MOD the initial value.  Ie, if the TOS is
    195  1915							; 42 then RANDOM returns a value from 0 to 41.
    196  1915							;
    197  1915					      macro	random
    198  1915					      db	37
    199  1915					      endm
    200  1915							;
    201  1915							; ABS will replace the top of stack with the
    202  1915							; absolute value.
    203  1915							;
    204  1915					      macro	abs
    205  1915					      db	38
    206  1915					      endm
    207  1915							;
    208  1915							; OPENREAD opens a file for reading, as in getting
    209  1915							; statements from it.
    210  1915							;
    211  1915					      macro	openread
    212  1915					      db	39
    213  1915					      endm
    214  1915							;
    215  1915							; OPENWRITE opens a file for writing, as in saving
    216  1915							; the current program to it.
    217  1915							;
    218  1915					      macro	openwrite
    219  1915					      db	40
    220  1915					      endm
    221  1915							;
    222  1915							; DCLOSE closes any open disk file.
    223  1915							;
    224  1915					      macro	dclose
    225  1915					      db	41
    226  1915					      endm
    227  1915							;
    228  1915							; DGETLINE gets one line from the disk file and puts it
    229  1915							; into LINBUFF.
    230  1915							;
    231  1915					      macro	dgetline
    232  1915					      db	42
    233  1915					      endm
    234  1915							;
    235  1915							; DLIST saves the program to an open disk file.
    236  1915							;
    237  1915					      macro	dlist
    238  1915					      db	43
    239  1915					      endm
    240  1915							; DDIR list the current directory
    241  1915							;
    242  1915					      macro	ddir
    243  1915					      db	44
    244  1915					      endm
    245  1915
    246  1915							; RMFILE remove a fle from disk
    247  1915					      macro	rmfile
    248  1915					      db	45
    249  1915					      endm
    250  1915
    251  1915							; CLEARSCREEN clear the screen
    252  1915					      macro	clearscreen
    253  1915					      db	46
    254  1915					      endm
    255  1915							; POKEMEM Poke value into memory
    256  1915					      macro	pokemem
    257  1915					      db	47
    258  1915					      endm
    259  1915							; PEEKMEM peek at value in memory
    260  1915					      macro	peekmem
    261  1915					      db	48
    262  1915					      endm
    263  1915							; TSTLET Test if the statement is a let without the keyword let
    264  1915					      macro	tstlet
    265  1915					      db	49
    266  1915					      db	({1}-*)-1	;(addr-*)-1
    267  1915					      endm		;addr
    268  1915							; TSTDONE if we reach the end of a statement
    269  1915					      macro	tstdone
    270  1915					      db	50
    271  1915					      db	({1}-*)-1	;(addr-*)-1
    272  1915					      endm		;addr
    273  1915							; GETCHAR	get a character from the input line leave it in RO
    274  1915					      macro	getchar
    275  1915					      db	51
    276  1915					      endm
    277  1915							; PUTCHAR	Put a character to the terminal
    278  1915					      macro	putchar
    279  1915					      db	52
    280  1915					      endm
    281  1915							; Call		Call a machine function return a to stack
    282  1915					      macro	callfunc
    283  1915					      db	53
    284  1915					      endm
    285  1915
    286  1915							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1915					      macro	ibranch
    288  1915					      db	54
    289  1915					      endm
    290  1915
    291  1915							; TSTSTR	 Tests for the open quote in a string
    292  1915					      macro	tststr
    293  1915					      db	55
    294  1915					      db	({1}-*)-1	;(addr-*)-1
    295  1915					      endm
    296  1915							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1915					      macro	setirq
    298  1915					      db	56
    299  1915					      endm
    300  1915
    301  1915							; TSTIRQ	Test for irq pending,
    302  1915							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1915					      macro	tstirq
    304  1915					      db	57
    305  1915					      db	({1}-*)-1	;(addr-*)-1
    306  1915					      endm
    307  1915
    308  1915							; IRET    return from interupt service
    309  1915					      macro	iret
    310  1915					      db	58
    311  1915					      endm
    312  1915
    313  1915							; INSTR   read a string from the input
    314  1915					      macro	instr
    315  1915					      db	59
    316  1915					      endm
    317  1915
    318  1915							; MODULO Returns the remainder of the division
    319  1915					      macro	modulo
    320  1915					      db	60
    321  1915					      endm
    322  1915							; Set a task line
    323  1915					      macro	taskcreate
    324  1915					      db	61
    325  1915					      endm
    326  1915							; End a task
    327  1915					      macro	etask
    328  1915					      db	62
    329  1915					      endm
    330  1915							; Skip to next task
    331  1915					      macro	ntask
    332  1915					      db	63
    333  1915					      endm
    334  1915							; Subscript
    335  1915					      macro	subscript
    336  1915					      db	64
    337  1915					      endm
    338  1915							; KILL Task
    339  1915					      macro	taskkill
    340  1915					      db	65
    341  1915					      endm
    342  1915							; STAT Task
    343  1915					      macro	taskstat
    344  1915					      db	66
    345  1915					      endm
    346  1915							;  output value as hex
    347  1915					      macro	hexprt
    348  1915					      db	67
    349  1915					      endm
    350  1915							;  Read in background has completed
    351  1915					      macro	readcomplete
    352  1915					      db	68
    353  1915					      endm
    354  1915							;  ReadInput line
    355  1915					      macro	readstart
    356  1915					      db	69
    357  1915					      endm
    358  1915							; Startio request
    359  1915					      macro	startio
    360  1915					      db	70
    361  1915					      endm
    362  1915							; Endio
    363  1915					      macro	endio
    364  1915					      db	71
    365  1915					      endm
    366  1915							; Logical not
    367  1915					      macro	lognot
    368  1915					      db	72
    369  1915					      endm
    370  1915							; Logical OR
    371  1915					      macro	logor
    372  1915					      db	73
    373  1915					      endm
    374  1915							;Logical and
    375  1915					      macro	logand
    376  1915					      db	74
    377  1915					      endm
    378  1915							;Logical XOR
    379  1915					      macro	logxor
    380  1915					      db	75
    381  1915					      endm
    382  1915							;Wait for task to complete, or list of tasks
    383  1915					      macro	wtask
    384  1915					      db	76
    385  1915					      db	({1}-*)-1	;(addr-*)-1
    386  1915					      endm
    387  1915							;Get the current task id
    388  1915					      MACRO	taskpid
    389  1915					      db	77
    390  1915					      endm
    391  1915							;Trace the basic execution
    392  1915					      Macro	traceprogram
    393  1915					      db	78
    394  1915					      endm
    395  1915							;Do a basic program Trace
    396  1915					      Macro	debugbasic
    397  1915					      db	79
    398  1915					      endm
    399  1915
    400  1915							; Inter Process communications instructions
    401  1915					      Macro	ipcsend
    402  1915					      db	80
    403  1915					      endm
    404  1915					      Macro	ipcreceive
    405  1915					      db	81
    406  1915					      endm
    407  1915					      Macro	ipccheck
    408  1915					      db	82
    409  1915					      endm
    410  1915					      Macro	ipcio
    411  1915					      db	83
    412  1915					      endm
    413  1915					      Macro	pushmathstack
    414  1915					      db	84
    415  1915					      endm
    416  1915					      Macro	popmathstack
    417  1915					      db	85
    418  1915					      endm
    419  1915					      Macro	savemathstack
    420  1915					      db	86
    421  1915					      endm
    422  1915					      Macro	restoremathstack
    423  1915					      db	87
    424  1915					      endm
    425  1915					      Macro	incparmcount
    426  1915					      db	88
    427  1915					      endm
    428  1915					      Macro	taskgetmathstack
    429  1915					      db	89
    430  1915					      endm
    431  1915					      Macro	taskenable
    432  1915					      db	90
    433  1915					      endm
    434  1915					      Macro	tasksuspend
    435  1915					      db	91
    436  1915					      endm
    437  1915					      Macro	taskputmathptr
    438  1915					      db	92
    439  1915					      endm
    440  1915							; Test for an extension type of variable that allows access to a tasks variables
    441  1915							; Using  PID!<Var name>
    442  1915					      Macro	tstvt
    443  1915					      db	93
    444  1915					      db	({1}-*)-1	;(addr-*)-1
    445  1915					      endm
    446  1915
    447  1915							; Provide access to R2 for the IL program
    448  1915					      Macro	setr2
    449  1915					      db	94
    450  1915					      db	{1}	; R2 is only one byte
    451  1915					      endm
    452  1915							;Move stack top to temp
    453  1915					      Macro	stk2tmp
    454  1915					      db	95
    455  1915					      endm
    456  1915
    457  1915					      Macro	tmp2stk
    458  1915					      db	96
    459  1915					      endm
    460  1915
    461  1915					      Macro	tstbyte
    462  1915					      db	97
    463  1915					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1915					      dw	{2}	; address to check
    465  1915					      db	{3}	; Value to compare
    466  1915					      endm
    467  1915
    468  1915					      Macro	incvar
    469  1915					      db	98
    470  1915					      endm
    471  1915					      Macro	decvar
    472  1915					      db	99
    473  1915					      endm
    474  1915
    475  1915					      Macro	slice
    476  1915					      db	100
    477  1915					      endm
    478  1915
    479  1915
    480  1915
------- FILE mytb.asm
   2213  1915							;
   2214  1915				  -	      if	FIXED
   2215  1915				  -	      org	$1000
   2216  1915					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1915					      include	"basic.il"
      1  1915							;LET
      2  1915							;=====================================================
      3  1915							;=====================================================
      4  1915					      seg	Code
      5  1915							;=====================================================
      6  1915							; This is the IL of the BASIC (or whatever) language.
      7  1915							; Because of the way macros are implemented by as65,
      8  1915							; labels can't be on the same line as a macro
      9  1915							; invocation, so that's why labels are on separate
     10  1915							; lines.
     11  1915							;
     12  1915		       19 15	   IL	      equ	*
     13  1915
     14  1915							;THE IL CONTROL SECTION
     15  1915
     16  1915				   START
      0  1915					      INIT		;INITIALIZE
      0  1915					      db	22
      1  1915		       16		      .byte.b	22
      0  1916					      NLINE		;WRITE CRLF
      0  1916					      db	5
      1  1916		       05		      .byte.b	5
      0  1917					      ERRGOTO	CO	;where to go after an error
      0  1917					      db	31
      1  1917		       1f		      .byte.b	31
      0  1918					      dw	CO
      1  1918		       1b 19		      .word.w	CO
      0  191a					      VINIT		;clear all variables
      0  191a					      db	30
      1  191a		       1e		      .byte.b	30
     21  191b							;
     22  191b							; This is where we jump to get a line of commands or
     23  191b							; a program from the user.
     24  191b							;
     25  191b				   CO
      0  191b					      GETLINE		;WRITE PROMPT AND GET LINE
      0  191b					      db	23
      1  191b		       17		      .byte.b	23
      0  191c					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  191c					      db	34
      1  191c		       22		      .byte.b	34
      0  191d					      db	(XEC-*)-1
      1  191d		       04		      .byte.b	(XEC-*)-1
      0  191e					      INSERT		;INSERT IT (MAY BE DELETE)
      0  191e					      db	24
      1  191e		       18		      .byte.b	24
      0  191f					      IJMP	CO
      0  191f					      db	29
      1  191f		       1d		      .byte.b	29
      0  1920					      dw	CO
      1  1920		       1b 19		      .word.w	CO
     30  1922				   XEC
      0  1922					      XINIT		;INITIALIZE
      0  1922					      db	0
      1  1922		       00		      .byte.b	0
     32  1923							;============================================================================
     33  1923							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1923							;
     35  1923				   STMT
      0  1923					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1923					      db	79
      1  1923		       4f		      .byte.b	79
      0  1924					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1924					      db	57
      1  1924		       39		      .byte.b	57
      0  1925					      db	(notirq-*)-1
      1  1925		       00		      .byte.b	(notirq-*)-1
     38  1926							;==========================================================================================
     39  1926							; Process a let statement implied or explicit.
     40  1926							;
     41  1926				   notirq
      0  1926					      TSTLET	LET	;Test if second field is = or []
      0  1926					      db	49
      1  1926		       31		      .byte.b	49
      0  1927					      db	(LET-*)-1
      1  1927		       03		      .byte.b	(LET-*)-1
      0  1928					      IJMP	DOLET	;allow the default to be let
      0  1928					      db	29
      1  1928		       1d		      .byte.b	29
      0  1929					      dw	DOLET
      1  1929		       31 19		      .word.w	DOLET
     44  192b				   LET
      0  192b					      TST	S1,"LET"	;IS STATEMENT A LET
      0  192b					      db	32
      1  192b		       20		      .byte.b	32
      0  192c					      db	(S1-*)-1
      1  192c		       21		      .byte.b	(S1-*)-1
      0  192d					      db	"LET",0
      1  192d		       4c 45 54 00	      .byte.b	"LET",0
     46  1931				   DOLET
      0  1931					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1931					      db	33
      1  1931		       21		      .byte.b	33
      0  1932					      db	(ERRVEC-*)-1
      1  1932		       ea		      .byte.b	(ERRVEC-*)-1
      0  1933					      TST	LETBE,"["
      0  1933					      db	32
      1  1933		       20		      .byte.b	32
      0  1934					      db	(LETBE-*)-1
      1  1934		       0a		      .byte.b	(LETBE-*)-1
      0  1935					      db	"[",0
      1  1935		       5b 00		      .byte.b	"[",0
      0  1937					      CALL	EXPR
      0  1937					      db	28
      1  1937		       1c		      .byte.b	28
      0  1938					      dw	EXPR
      1  1938		       c0 1b		      .word.w	EXPR
      0  193a					      TST	ERRVEC,"]"
      0  193a					      db	32
      1  193a		       20		      .byte.b	32
      0  193b					      db	(ERRVEC-*)-1
      1  193b		       e1		      .byte.b	(ERRVEC-*)-1
      0  193c					      db	"]",0
      1  193c		       5d 00		      .byte.b	"]",0
      0  193e					      SUBSCRIPT
      0  193e					      db	64
      1  193e		       40		      .byte.b	64
     52  193f				   LETBE
      0  193f					      TST	ERRVEC,"="	;(This line originally omitted)
      0  193f					      db	32
      1  193f		       20		      .byte.b	32
      0  1940					      db	(ERRVEC-*)-1
      1  1940		       dc		      .byte.b	(ERRVEC-*)-1
      0  1941					      db	"=",0
      1  1941		       3d 00		      .byte.b	"=",0
      0  1943					      CALL	EXPR	;PLACE EXPR VALUE ON MathSTK
      0  1943					      db	28
      1  1943		       1c		      .byte.b	28
      0  1944					      dw	EXPR
      1  1944		       c0 1b		      .word.w	EXPR
      0  1946					      DONE		;REPORT ERROR IF NOT NEXT
      0  1946					      db	1
      1  1946		       01		      .byte.b	1
      0  1947					      STORE		;STORE RESULT
      0  1947					      db	19
      1  1947		       13		      .byte.b	19
      0  1948					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1948					      db	6
      1  1948		       06		      .byte.b	6
      0  1949					      dw	CO
      1  1949		       1b 19		      .word.w	CO
      0  194b					      IJMP	STMT
      0  194b					      db	29
      1  194b		       1d		      .byte.b	29
      0  194c					      dw	STMT
      1  194c		       23 19		      .word.w	STMT
     59  194e							;=============================================================
     60  194e							; Inc or dec a variable
     61  194e				   S1
      0  194e					      TST	S1Dec,"INC"	;Increment variable
      0  194e					      db	32
      1  194e		       20		      .byte.b	32
      0  194f					      db	(S1Dec-*)-1
      1  194f		       0e		      .byte.b	(S1Dec-*)-1
      0  1950					      db	"INC",0
      1  1950		       49 4e 43 00	      .byte.b	"INC",0
      0  1954					      TSTV	ERRVEC
      0  1954					      db	33
      1  1954		       21		      .byte.b	33
      0  1955					      db	(ERRVEC-*)-1
      1  1955		       c7		      .byte.b	(ERRVEC-*)-1
      0  1956					      INCVAR
      0  1956					      db	98
      1  1956		       62		      .byte.b	98
      0  1957					      DONE
      0  1957					      db	1
      1  1957		       01		      .byte.b	1
      0  1958					      NXT	CO
      0  1958					      db	6
      1  1958		       06		      .byte.b	6
      0  1959					      dw	CO
      1  1959		       1b 19		      .word.w	CO
      0  195b					      IJMP	STMT
      0  195b					      db	29
      1  195b		       1d		      .byte.b	29
      0  195c					      dw	STMT
      1  195c		       23 19		      .word.w	STMT
     68  195e				   S1Dec
      0  195e					      TST	S1Iret,"DEC"	;Dec variable
      0  195e					      db	32
      1  195e		       20		      .byte.b	32
      0  195f					      db	(S1Iret-*)-1
      1  195f		       0e		      .byte.b	(S1Iret-*)-1
      0  1960					      db	"DEC",0
      1  1960		       44 45 43 00	      .byte.b	"DEC",0
      0  1964					      TSTV	ERRVEC
      0  1964					      db	33
      1  1964		       21		      .byte.b	33
      0  1965					      db	(ERRVEC-*)-1
      1  1965		       b7		      .byte.b	(ERRVEC-*)-1
      0  1966					      DECVAR
      0  1966					      db	99
      1  1966		       63		      .byte.b	99
      0  1967					      DONE
      0  1967					      db	1
      1  1967		       01		      .byte.b	1
      0  1968					      NXT	CO
      0  1968					      db	6
      1  1968		       06		      .byte.b	6
      0  1969					      dw	CO
      1  1969		       1b 19		      .word.w	CO
      0  196b					      IJMP	STMT
      0  196b					      db	29
      1  196b		       1d		      .byte.b	29
      0  196c					      dw	STMT
      1  196c		       23 19		      .word.w	STMT
     75  196e							;====================================================================
     76  196e							; iret or ireturn, Return from interupt process
     77  196e							;
     78  196e				   S1Iret
      0  196e					      TST	S1S1,"IRET"	;test return from interupt
      0  196e					      db	32
      1  196e		       20		      .byte.b	32
      0  196f					      db	(S1S1-*)-1
      1  196f		       10		      .byte.b	(S1S1-*)-1
      0  1970					      db	"IRET",0
      1  1970		       49 52 45 54*	      .byte.b	"IRET",0
      0  1975					      TST	S1Sa,"URN"
      0  1975					      db	32
      1  1975		       20		      .byte.b	32
      0  1976					      db	(S1Sa-*)-1
      1  1976		       04		      .byte.b	(S1Sa-*)-1
      0  1977					      db	"URN",0
      1  1977		       55 52 4e 00	      .byte.b	"URN",0
     81  197b				   S1Sa
      0  197b					      DONE		;Must be only thing on the line
      0  197b					      db	1
      1  197b		       01		      .byte.b	1
      0  197c					      IRET		;RESTORE LINE NUMBER OF CALL
      0  197c					      db	58
      1  197c		       3a		      .byte.b	58
      0  197d					      IJMP	STMT
      0  197d					      db	29
      1  197d		       1d		      .byte.b	29
      0  197e					      dw	STMT
      1  197e		       23 19		      .word.w	STMT
     85  1980							;=======================================================================
     86  1980							;Process if statement, if true then process all statements until end of line reached
     87  1980				   S1S1
      0  1980					      TST	S1Z,"IF"	;IF STATEMENT
      0  1980					      db	32
      1  1980		       20		      .byte.b	32
      0  1981					      db	(S1Z-*)-1
      1  1981		       11		      .byte.b	(S1Z-*)-1
      0  1982					      db	"IF",0
      1  1982		       49 46 00 	      .byte.b	"IF",0
      0  1985					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1985					      db	28
      1  1985		       1c		      .byte.b	28
      0  1986					      dw	EXPR
      1  1986		       c0 1b		      .word.w	EXPR
      0  1988					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  1988					      db	32
      1  1988		       20		      .byte.b	32
      0  1989					      db	(S1W-*)-1
      1  1989		       05		      .byte.b	(S1W-*)-1
      0  198a					      db	"THEN",0
      1  198a		       54 48 45 4e*	      .byte.b	"THEN",0
     91  198f				   S1W
      0  198f					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  198f					      db	54
      1  198f		       36		      .byte.b	54
      0  1990					      IJMP	STMT
      0  1990					      db	29
      1  1990		       1d		      .byte.b	29
      0  1991					      dw	STMT
      1  1991		       23 19		      .word.w	STMT
     94  1993							;===============================================================
     95  1993							; Test for GO
     96  1993				   S1Z
      0  1993					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1993					      db	32
      1  1993		       20		      .byte.b	32
      0  1994					      db	(S2b-*)-1
      1  1994		       19		      .byte.b	(S2b-*)-1
      0  1995					      db	"GO",0
      1  1995		       47 4f 00 	      .byte.b	"GO",0
     98  1998							;================================================================
     99  1998							; process a goto
      0  1998					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  1998					      db	32
      1  1998		       20		      .byte.b	32
      0  1999					      db	(S2-*)-1
      1  1999		       07		      .byte.b	(S2-*)-1
      0  199a					      db	"TO",0
      1  199a		       54 4f 00 	      .byte.b	"TO",0
      0  199d					      CALL	EXPR	;GET LABEL
      0  199d					      db	28
      1  199d		       1c		      .byte.b	28
      0  199e					      dw	EXPR
      1  199e		       c0 1b		      .word.w	EXPR
      0  19a0					      XFER		;SET UP AND JUMP
      0  19a0					      db	7
      1  19a0		       07		      .byte.b	7
    103  19a1				   S2
    104  19a1							;===========================================================================
    105  19a1							; Process gosub / function
    106  19a1							;
      0  19a1					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  19a1					      db	32
      1  19a1		       20		      .byte.b	32
      0  19a2					      db	(ERRVEC-*)-1
      1  19a2		       7a		      .byte.b	(ERRVEC-*)-1
      0  19a3					      db	"SUB",0
      1  19a3		       53 55 42 00	      .byte.b	"SUB",0
      0  19a7					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  19a7					      db	28
      1  19a7		       1c		      .byte.b	28
      0  19a8					      dw	GOSUBSTATEMENT
      1  19a8		       c7 1d		      .word.w	GOSUBSTATEMENT
      0  19aa					      DONE		;ERROR IF CR NOT NEXT
      0  19aa					      db	1
      1  19aa		       01		      .byte.b	1
      0  19ab					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  19ab					      db	8
      1  19ab		       08		      .byte.b	8
      0  19ac					      db	GOSUB_RTN
      1  19ac		       01		      .byte.b	GOSUB_RTN
      0  19ad					      XFER		;AND JUMP
      0  19ad					      db	7
      1  19ad		       07		      .byte.b	7
    112  19ae							;
    113  19ae							; End of gosub processing
    114  19ae							;==========================================================================
    115  19ae							; Return from a gosub
    116  19ae				   S2b
      0  19ae					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  19ae					      db	32
      1  19ae		       20		      .byte.b	32
      0  19af					      db	(S3-*)-1
      1  19af		       36		      .byte.b	(S3-*)-1
      0  19b0					      db	"RE",0
      1  19b0		       52 45 00 	      .byte.b	"RE",0
      0  19b3					      TST	S2a,"T"
      0  19b3					      db	32
      1  19b3		       20		      .byte.b	32
      0  19b4					      db	(S2a-*)-1
      1  19b4		       27		      .byte.b	(S2a-*)-1
      0  19b5					      db	"T",0
      1  19b5		       54 00		      .byte.b	"T",0
      0  19b7					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  19b7					      db	32
      1  19b7		       20		      .byte.b	32
      0  19b8					      db	(S2aa-*)-1
      1  19b8		       04		      .byte.b	(S2aa-*)-1
      0  19b9					      db	"URN",0
      1  19b9		       55 52 4e 00	      .byte.b	"URN",0
    120  19bd				   S2aa
      0  19bd					      SETR2	0	; Default no return value
      0  19bd					      db	94
      1  19bd		       5e		      .byte.b	94
      0  19be					      db	0
      1  19be		       00		      .byte.b	0
      0  19bf					      TST	S2RetDone,"("	; Check if we will return some value
      0  19bf					      db	32
      1  19bf		       20		      .byte.b	32
      0  19c0					      db	(S2RetDone-*)-1
      1  19c0		       0b		      .byte.b	(S2RetDone-*)-1
      0  19c1					      db	"(",0
      1  19c1		       28 00		      .byte.b	"(",0
      0  19c3					      SETR2	1	; Indicate a return value provided
      0  19c3					      db	94
      1  19c3		       5e		      .byte.b	94
      0  19c4					      db	1
      1  19c4		       01		      .byte.b	1
      0  19c5					      CALL	EXPR
      0  19c5					      db	28
      1  19c5		       1c		      .byte.b	28
      0  19c6					      dw	EXPR
      1  19c6		       c0 1b		      .word.w	EXPR
      0  19c8					      TST	ERRVEC,")"	; Now a value is on the stack
      0  19c8					      db	32
      1  19c8		       20		      .byte.b	32
      0  19c9					      db	(ERRVEC-*)-1
      1  19c9		       53		      .byte.b	(ERRVEC-*)-1
      0  19ca					      db	")",0
      1  19ca		       29 00		      .byte.b	")",0
    126  19cc
    127  19cc				   S2RetDone
      0  19cc					      DONE		; MUST BE CR or :
      0  19cc					      db	1
      1  19cc		       01		      .byte.b	1
      0  19cd					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  19cd					      db	9
      1  19cd		       09		      .byte.b	9
      0  19ce					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  19ce					      db	97
      1  19ce		       61		      .byte.b	97
      0  19cf					      db	(S2RetFunc-*)-1
      1  19cf		       09		      .byte.b	(S2RetFunc-*)-1
      0  19d0					      dw	R2
      1  19d0		       58 00		      .word.w	R2
      0  19d2					      db	1
      1  19d2		       01		      .byte.b	1
      0  19d3					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  19d3					      db	6
      1  19d3		       06		      .byte.b	6
      0  19d4					      dw	CO
      1  19d4		       1b 19		      .word.w	CO
      0  19d6					      IJMP	STMT
      0  19d6					      db	29
      1  19d6		       1d		      .byte.b	29
      0  19d7					      dw	STMT
      1  19d7		       23 19		      .word.w	STMT
    133  19d9				   S2RetFunc
      0  19d9					      IJMP	GOFNRet	; Back into the Function
      0  19d9					      db	29
      1  19d9		       1d		      .byte.b	29
      0  19da					      dw	GOFNRet
      1  19da		       9d 1d		      .word.w	GOFNRet
    135  19dc							;
    136  19dc							; End of return from gosub
    137  19dc							;============================================================================
    138  19dc							; Process REM statement
    139  19dc							;
    140  19dc				   S2a
      0  19dc					      TST	S3,"M"	;REMark.  Skip rest of line
      0  19dc					      db	32
      1  19dc		       20		      .byte.b	32
      0  19dd					      db	(S3-*)-1
      1  19dd		       08		      .byte.b	(S3-*)-1
      0  19de					      db	"M",0
      1  19de		       4d 00		      .byte.b	"M",0
      0  19e0					      NXT	CO
      0  19e0					      db	6
      1  19e0		       06		      .byte.b	6
      0  19e1					      dw	CO
      1  19e1		       1b 19		      .word.w	CO
      0  19e3					      IJMP	STMT
      0  19e3					      db	29
      1  19e3		       1d		      .byte.b	29
      0  19e4					      dw	STMT
      1  19e4		       23 19		      .word.w	STMT
    144  19e6							;============================================================================
    145  19e6							; Print statement
    146  19e6							;
    147  19e6				   S3
      0  19e6					      TST	S3a,"?"	; ? symonym for print
      0  19e6					      db	32
      1  19e6		       20		      .byte.b	32
      0  19e7					      db	(S3a-*)-1
      1  19e7		       05		      .byte.b	(S3a-*)-1
      0  19e8					      db	"?",0
      1  19e8		       3f 00		      .byte.b	"?",0
      0  19ea					      IJMP	S4S
      0  19ea					      db	29
      1  19ea		       1d		      .byte.b	29
      0  19eb					      dw	S4S
      1  19eb		       f8 19		      .word.w	S4S
    150  19ed				   S3a
      0  19ed					      TST	S8,"PR"	;allow short form of print
      0  19ed					      db	32
      1  19ed		       20		      .byte.b	32
      0  19ee					      db	(S8-*)-1
      1  19ee		       5b		      .byte.b	(S8-*)-1
      0  19ef					      db	"PR",0
      1  19ef		       50 52 00 	      .byte.b	"PR",0
      0  19f2					      TST	S4S,"INT"	;PRINT
      0  19f2					      db	32
      1  19f2		       20		      .byte.b	32
      0  19f3					      db	(S4S-*)-1
      1  19f3		       04		      .byte.b	(S4S-*)-1
      0  19f4					      db	"INT",0
      1  19f4		       49 4e 54 00	      .byte.b	"INT",0
    153  19f8				   S4S
      0  19f8					      STARTIO		;Lock task until io completes
      0  19f8					      db	70
      1  19f8		       46		      .byte.b	70
    155  19f9				   S4
      0  19f9					      TSTDONE	S4a	;Test if we just want crlf printed
      0  19f9					      db	50
      1  19f9		       32		      .byte.b	50
      0  19fa					      db	(S4a-*)-1
      1  19fa		       03		      .byte.b	(S4a-*)-1
      0  19fb					      IJMP	S6
      0  19fb					      db	29
      1  19fb		       1d		      .byte.b	29
      0  19fc					      dw	S6
      1  19fc		       14 1a		      .word.w	S6
    158  19fe
    159  19fe				   S4a
      0  19fe					      TSTSTR	S7	;TEST FOR QUOTED String
      0  19fe					      db	55
      1  19fe		       37		      .byte.b	55
      0  19ff					      db	(S7-*)-1
      1  19ff		       21		      .byte.b	(S7-*)-1
      0  1a00					      PRS		;PRINT STRING
      0  1a00					      db	2
      1  1a00		       02		      .byte.b	2
    162  1a01				   S5
      0  1a01					      TST	S6A,COMMA	;IS THERE MORE?
      0  1a01					      db	32
      1  1a01		       20		      .byte.b	32
      0  1a02					      db	(S6A-*)-1
      1  1a02		       08		      .byte.b	(S6A-*)-1
      0  1a03					      db	COMMA,0
      1  1a03		       2c 00		      .byte.b	COMMA,0
      0  1a05					      SPC		;SPACE TO NEXT ZONE
      0  1a05					      db	4
      1  1a05		       04		      .byte.b	4
      0  1a06					      TSTDONE	S4	;Not end of line jump back
      0  1a06					      db	50
      1  1a06		       32		      .byte.b	50
      0  1a07					      db	(S4-*)-1
      1  1a07		       f1		      .byte.b	(S4-*)-1
      0  1a08					      IJMP	S6Z	;YES JUMP BACK
      0  1a08					      db	29
      1  1a08		       1d		      .byte.b	29
      0  1a09					      dw	S6Z
      1  1a09		       16 1a		      .word.w	S6Z
    167  1a0b
    168  1a0b							;
    169  1a0b							; If a semicolon, don't do anything.
    170  1a0b							;
    171  1a0b				   S6A
      0  1a0b					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  1a0b					      db	32
      1  1a0b		       20		      .byte.b	32
      0  1a0c					      db	(S6-*)-1
      1  1a0c		       07		      .byte.b	(S6-*)-1
      0  1a0d					      db	SEMICOLON,0
      1  1a0d		       3b 00		      .byte.b	SEMICOLON,0
      0  1a0f					      TSTDONE	S4	;Jump Back if not end of line
      0  1a0f					      db	50
      1  1a0f		       32		      .byte.b	50
      0  1a10					      db	(S4-*)-1
      1  1a10		       e8		      .byte.b	(S4-*)-1
      0  1a11					      IJMP	S6Z
      0  1a11					      db	29
      1  1a11		       1d		      .byte.b	29
      0  1a12					      dw	S6Z
      1  1a12		       16 1a		      .word.w	S6Z
    175  1a14				   S6
      0  1a14					      DONE		;ERROR IF CR NOT NEXT
      0  1a14					      db	1
      1  1a14		       01		      .byte.b	1
      0  1a15					      NLINE
      0  1a15					      db	5
      1  1a15		       05		      .byte.b	5
    178  1a16				   S6Z
      0  1a16					      ENDIO		;release task io completed
      0  1a16					      db	71
      1  1a16		       47		      .byte.b	71
      0  1a17					      NXT	CO	;exit here if , or ; at end of print
      0  1a17					      db	6
      1  1a17		       06		      .byte.b	6
      0  1a18					      dw	CO
      1  1a18		       1b 19		      .word.w	CO
      0  1a1a					      IJMP	STMT
      0  1a1a					      db	29
      1  1a1a		       1d		      .byte.b	29
      0  1a1b					      dw	STMT
      1  1a1b		       23 19		      .word.w	STMT
    182  1a1d							;
    183  1a1d							; A jump for code too far away for relative branch
    184  1a1d							;
    185  1a1d				   ERRVEC
      0  1a1d					      ENDIO
      0  1a1d					      db	71
      1  1a1d		       47		      .byte.b	71
      0  1a1e					      IJMP	UNKNOWN
      0  1a1e					      db	29
      1  1a1e		       1d		      .byte.b	29
      0  1a1f					      dw	UNKNOWN
      1  1a1f		       bc 1b		      .word.w	UNKNOWN
    188  1a21							;
    189  1a21							; Get here if there is an expression to print
    190  1a21				   S7
      0  1a21					      TST	S7AUnsigned,"$"
      0  1a21					      db	32
      1  1a21		       20		      .byte.b	32
      0  1a22					      db	(S7AUnsigned-*)-1
      1  1a22		       09		      .byte.b	(S7AUnsigned-*)-1
      0  1a23					      db	"$",0
      1  1a23		       24 00		      .byte.b	"$",0
      0  1a25					      CALL	EXPR
      0  1a25					      db	28
      1  1a25		       1c		      .byte.b	28
      0  1a26					      dw	EXPR
      1  1a26		       c0 1b		      .word.w	EXPR
      0  1a28					      HEXPRT
      0  1a28					      db	67
      1  1a28		       43		      .byte.b	67
      0  1a29					      IJMP	S5
      0  1a29					      db	29
      1  1a29		       1d		      .byte.b	29
      0  1a2a					      dw	S5
      1  1a2a		       01 1a		      .word.w	S5
    195  1a2c
    196  1a2c				   S7AUnsigned
    197  1a2c
      0  1a2c					      TST	S7A,"%"
      0  1a2c					      db	32
      1  1a2c		       20		      .byte.b	32
      0  1a2d					      db	(S7A-*)-1
      1  1a2d		       0b		      .byte.b	(S7A-*)-1
      0  1a2e					      db	"%",0
      1  1a2e		       25 00		      .byte.b	"%",0
      0  1a30					      CALL	EXPR
      0  1a30					      db	28
      1  1a30		       1c		      .byte.b	28
      0  1a31					      dw	EXPR
      1  1a31		       c0 1b		      .word.w	EXPR
      0  1a33					      SETR2	1
      0  1a33					      db	94
      1  1a33		       5e		      .byte.b	94
      0  1a34					      db	1
      1  1a34		       01		      .byte.b	1
      0  1a35					      PRN
      0  1a35					      db	3
      1  1a35		       03		      .byte.b	3
      0  1a36					      IJMP	S5
      0  1a36					      db	29
      1  1a36		       1d		      .byte.b	29
      0  1a37					      dw	S5
      1  1a37		       01 1a		      .word.w	S5
    203  1a39
    204  1a39				   S7A
    205  1a39
      0  1a39					      CALL	EXPR
      0  1a39					      db	28
      1  1a39		       1c		      .byte.b	28
      0  1a3a					      dw	EXPR
      1  1a3a		       c0 1b		      .word.w	EXPR
      0  1a3c					      TST	S7B,"$"
      0  1a3c					      db	32
      1  1a3c		       20		      .byte.b	32
      0  1a3d					      db	(S7B-*)-1
      1  1a3d		       06		      .byte.b	(S7B-*)-1
      0  1a3e					      db	"$",0
      1  1a3e		       24 00		      .byte.b	"$",0
      0  1a40					      PUTCHAR
      0  1a40					      db	52
      1  1a40		       34		      .byte.b	52
      0  1a41					      IJMP	S5
      0  1a41					      db	29
      1  1a41		       1d		      .byte.b	29
      0  1a42					      dw	S5
      1  1a42		       01 1a		      .word.w	S5
    210  1a44
    211  1a44				   S7B
      0  1a44					      SETR2	0
      0  1a44					      db	94
      1  1a44		       5e		      .byte.b	94
      0  1a45					      db	0
      1  1a45		       00		      .byte.b	0
      0  1a46					      PRN		;PRINT IT
      0  1a46					      db	3
      1  1a46		       03		      .byte.b	3
      0  1a47					      IJMP	S5	;IS THERE MORE?
      0  1a47					      db	29
      1  1a47		       1d		      .byte.b	29
      0  1a48					      dw	S5
      1  1a48		       01 1a		      .word.w	S5
    215  1a4a							;
    216  1a4a							;===========================================================
    217  1a4a							; PROCESS ALL THE TAST STATEMENTS
    218  1a4a							;
    219  1a4a				   S8
      0  1a4a					      TST	S8a1,"TASK"	; Any Task Command
      0  1a4a					      db	32
      1  1a4a		       20		      .byte.b	32
      0  1a4b					      db	(S8a1-*)-1
      1  1a4b		       4b		      .byte.b	(S8a1-*)-1
      0  1a4c					      db	"TASK",0
      1  1a4c		       54 41 53 4b*	      .byte.b	"TASK",0
    221  1a51							;==========================================================
    222  1a51							; End of TASK process
    223  1a51							;
      0  1a51					      TST	S8G,"E"
      0  1a51					      db	32
      1  1a51		       20		      .byte.b	32
      0  1a52					      db	(S8G-*)-1
      1  1a52		       1a		      .byte.b	(S8G-*)-1
      0  1a53					      db	"E",0
      1  1a53		       45 00		      .byte.b	"E",0
      0  1a55					      TST	S8NoParm,"("
      0  1a55					      db	32
      1  1a55		       20		      .byte.b	32
      0  1a56					      db	(S8NoParm-*)-1
      1  1a56		       0e		      .byte.b	(S8NoParm-*)-1
      0  1a57					      db	"(",0
      1  1a57		       28 00		      .byte.b	"(",0
      0  1a59					      CALL	EXPR
      0  1a59					      db	28
      1  1a59		       1c		      .byte.b	28
      0  1a5a					      dw	EXPR
      1  1a5a		       c0 1b		      .word.w	EXPR
      0  1a5c					      TST	UNKNOWNLnk,")"
      0  1a5c					      db	32
      1  1a5c		       20		      .byte.b	32
      0  1a5d					      db	(UNKNOWNLnk-*)-1
      1  1a5d		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1a5e					      db	")",0
      1  1a5e		       29 00		      .byte.b	")",0
      0  1a60					      ETASK
      0  1a60					      db	62
      1  1a60		       3e		      .byte.b	62
      0  1a61					      DONE
      0  1a61					      db	1
      1  1a61		       01		      .byte.b	1
      0  1a62					      IJMP	STMT
      0  1a62					      db	29
      1  1a62		       1d		      .byte.b	29
      0  1a63					      dw	STMT
      1  1a63		       23 19		      .word.w	STMT
    231  1a65				   S8NoParm
      0  1a65					      LIT	0
      0  1a65					      db	27
      1  1a65		       1b		      .byte.b	27
      0  1a66					      dw	0
      1  1a66		       00 00		      .word.w	0
      0  1a68					      ETASK
      0  1a68					      db	62
      1  1a68		       3e		      .byte.b	62
      0  1a69					      DONE		; Must be last thing on a line
      0  1a69					      db	1
      1  1a69		       01		      .byte.b	1
      0  1a6a					      IJMP	STMT
      0  1a6a					      db	29
      1  1a6a		       1d		      .byte.b	29
      0  1a6b					      dw	STMT
      1  1a6b		       23 19		      .word.w	STMT
    236  1a6d							;
    237  1a6d							;===========================================================
    238  1a6d							; The task gives up the rest of the cycles
    239  1a6d				   S8G
      0  1a6d					      TST	S8a,"N"	;Next task
      0  1a6d					      db	32
      1  1a6d		       20		      .byte.b	32
      0  1a6e					      db	(S8a-*)-1
      1  1a6e		       09		      .byte.b	(S8a-*)-1
      0  1a6f					      db	"N",0
      1  1a6f		       4e 00		      .byte.b	"N",0
      0  1a71					      NTASK
      0  1a71					      db	63
      1  1a71		       3f		      .byte.b	63
      0  1a72					      NXT	CO	;Next statement to execute
      0  1a72					      db	6
      1  1a72		       06		      .byte.b	6
      0  1a73					      dw	CO
      1  1a73		       1b 19		      .word.w	CO
      0  1a75					      IJMP	STMT
      0  1a75					      db	29
      1  1a75		       1d		      .byte.b	29
      0  1a76					      dw	STMT
      1  1a76		       23 19		      .word.w	STMT
    244  1a78							;
    245  1a78							;===========================================================
    246  1a78							; Waits for a task or list of tasks to complete
    247  1a78				   S8a
      0  1a78					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1a78					      db	32
      1  1a78		       20		      .byte.b	32
      0  1a79					      db	(S8TASKNO-*)-1
      1  1a79		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1a7a					      db	"W(",0
      1  1a7a		       57 28 00 	      .byte.b	"W(",0
    249  1a7d				   S8TSK
      0  1a7d					      Call	EXPR	;Gets the PID of task to wait for
      0  1a7d					      db	28
      1  1a7d		       1c		      .byte.b	28
      0  1a7e					      dw	EXPR
      1  1a7e		       c0 1b		      .word.w	EXPR
    251  1a80				   S8LOOP
      0  1a80					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1a80					      db	76
      1  1a80		       4c		      .byte.b	76
      0  1a81					      db	(S8LOOP-*)-1
      1  1a81		       fe		      .byte.b	(S8LOOP-*)-1
      0  1a82					      TST	S8aa,COMMA	;Checks for more tasks
      0  1a82					      db	32
      1  1a82		       20		      .byte.b	32
      0  1a83					      db	(S8aa-*)-1
      1  1a83		       05		      .byte.b	(S8aa-*)-1
      0  1a84					      db	COMMA,0
      1  1a84		       2c 00		      .byte.b	COMMA,0
      0  1a86					      IJMP	S8TSK	;Go for the next task number
      0  1a86					      db	29
      1  1a86		       1d		      .byte.b	29
      0  1a87					      dw	S8TSK
      1  1a87		       7d 1a		      .word.w	S8TSK
    255  1a89				   S8aa
      0  1a89					      TST	S8TASKNO,")"	;end of list
      0  1a89					      db	32
      1  1a89		       20		      .byte.b	32
      0  1a8a					      db	(S8TASKNO-*)-1
      1  1a8a		       09		      .byte.b	(S8TASKNO-*)-1
      0  1a8b					      db	")",0
      1  1a8b		       29 00		      .byte.b	")",0
      0  1a8d					      DONE
      0  1a8d					      db	1
      1  1a8d		       01		      .byte.b	1
      0  1a8e					      NXT	CO
      0  1a8e					      db	6
      1  1a8e		       06		      .byte.b	6
      0  1a8f					      dw	CO
      1  1a8f		       1b 19		      .word.w	CO
      0  1a91					      IJMP	STMT	;Next Statement
      0  1a91					      db	29
      1  1a91		       1d		      .byte.b	29
      0  1a92					      dw	STMT
      1  1a92		       23 19		      .word.w	STMT
    260  1a94				   S8TASKNO
    261  1a94
    262  1a94				   UNKNOWNLnk
      0  1a94					      iJMP	UNKNOWN
      0  1a94					      db	29
      1  1a94		       1d		      .byte.b	29
      0  1a95					      dw	UNKNOWN
      1  1a95		       bc 1b		      .word.w	UNKNOWN
    264  1a97
    265  1a97							;
    266  1a97							;===========================================================
    267  1a97							; Update a memory location with a value
    268  1a97							;  Use @[offset] to write a word value to memory
    269  1a97							;
    270  1a97				   S8a1
      0  1a97					      TST	S8b,"POKE("	; Poke a value into memory
      0  1a97					      db	32
      1  1a97		       20		      .byte.b	32
      0  1a98					      db	(S8b-*)-1
      1  1a98		       1c		      .byte.b	(S8b-*)-1
      0  1a99					      db	"POKE(",0
      1  1a99		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1a9f					      CALL	EXPR	; Get address to write to
      0  1a9f					      db	28
      1  1a9f		       1c		      .byte.b	28
      0  1aa0					      dw	EXPR
      1  1aa0		       c0 1b		      .word.w	EXPR
      0  1aa2					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1aa2					      db	32
      1  1aa2		       20		      .byte.b	32
      0  1aa3					      db	(UNKNOWNV-*)-1
      1  1aa3		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1aa4					      db	COMMA,0
      1  1aa4		       2c 00		      .byte.b	COMMA,0
      0  1aa6					      CALL	EXPR	; Get the value to poke
      0  1aa6					      db	28
      1  1aa6		       1c		      .byte.b	28
      0  1aa7					      dw	EXPR
      1  1aa7		       c0 1b		      .word.w	EXPR
      0  1aa9					      TST	UNKNOWNV,")"	; closing bracket
      0  1aa9					      db	32
      1  1aa9		       20		      .byte.b	32
      0  1aaa					      db	(UNKNOWNV-*)-1
      1  1aaa		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1aab					      db	")",0
      1  1aab		       29 00		      .byte.b	")",0
      0  1aad					      POKEMEM
      0  1aad					      db	47
      1  1aad		       2f		      .byte.b	47
      0  1aae					      DONE
      0  1aae					      db	1
      1  1aae		       01		      .byte.b	1
      0  1aaf					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1aaf					      db	6
      1  1aaf		       06		      .byte.b	6
      0  1ab0					      dw	CO
      1  1ab0		       1b 19		      .word.w	CO
      0  1ab2					      IJMP	STMT
      0  1ab2					      db	29
      1  1ab2		       1d		      .byte.b	29
      0  1ab3					      dw	STMT
      1  1ab3		       23 19		      .word.w	STMT
    280  1ab5							;================================================================
    281  1ab5							; Write a single byte to the output device
    282  1ab5							;
    283  1ab5				   S8b
      0  1ab5					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1ab5					      db	32
      1  1ab5		       20		      .byte.b	32
      0  1ab6					      db	(S8c-*)-1
      1  1ab6		       11		      .byte.b	(S8c-*)-1
      0  1ab7					      db	"PUTCH",0
      1  1ab7		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1abd					      CALL	EXPR
      0  1abd					      db	28
      1  1abd		       1c		      .byte.b	28
      0  1abe					      dw	EXPR
      1  1abe		       c0 1b		      .word.w	EXPR
      0  1ac0					      PUTCHAR
      0  1ac0					      db	52
      1  1ac0		       34		      .byte.b	52
      0  1ac1					      DONE
      0  1ac1					      db	1
      1  1ac1		       01		      .byte.b	1
      0  1ac2					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1ac2					      db	6
      1  1ac2		       06		      .byte.b	6
      0  1ac3					      dw	CO
      1  1ac3		       1b 19		      .word.w	CO
      0  1ac5					      IJMP	STMT
      0  1ac5					      db	29
      1  1ac5		       1d		      .byte.b	29
      0  1ac6					      dw	STMT
      1  1ac6		       23 19		      .word.w	STMT
    290  1ac8							;================================================================
    291  1ac8							; Clear the screen lines
    292  1ac8							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    293  1ac8							;
    294  1ac8				   S8c
      0  1ac8					      TST	S9,"CLS"	;Clear the screen
      0  1ac8					      db	32
      1  1ac8		       20		      .byte.b	32
      0  1ac9					      db	(S9-*)-1
      1  1ac9		       0b		      .byte.b	(S9-*)-1
      0  1aca					      db	"CLS",0
      1  1aca		       43 4c 53 00	      .byte.b	"CLS",0
      0  1ace					      CLEARSCREEN
      0  1ace					      db	46
      1  1ace		       2e		      .byte.b	46
      0  1acf					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1acf					      db	6
      1  1acf		       06		      .byte.b	6
      0  1ad0					      dw	CO
      1  1ad0		       1b 19		      .word.w	CO
      0  1ad2					      IJMP	STMT
      0  1ad2					      db	29
      1  1ad2		       1d		      .byte.b	29
      0  1ad3					      dw	STMT
      1  1ad3		       23 19		      .word.w	STMT
    299  1ad5							;==================================================================
    300  1ad5							; Get input from the terminal
    301  1ad5							;   Reads from the currently active input device
    302  1ad5							;
    303  1ad5				   S9
      0  1ad5					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1ad5					      db	32
      1  1ad5		       20		      .byte.b	32
      0  1ad6					      db	(S13-*)-1
      1  1ad6		       2a		      .byte.b	(S13-*)-1
      0  1ad7					      db	"INPUT",0
      1  1ad7		       49 4e 50 55*	      .byte.b	"INPUT",0
    305  1add				   S10
      0  1add					      TSTSTR	S10A	;If there is a string print the prompt
      0  1add					      db	55
      1  1add		       37		      .byte.b	55
      0  1ade					      db	(S10A-*)-1
      1  1ade		       05		      .byte.b	(S10A-*)-1
      0  1adf					      PRS
      0  1adf					      db	2
      1  1adf		       02		      .byte.b	2
      0  1ae0					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1ae0					      db	32
      1  1ae0		       20		      .byte.b	32
      0  1ae1					      db	(S10Z-*)-1
      1  1ae1		       15		      .byte.b	(S10Z-*)-1
      0  1ae2					      db	SEMICOLON,0
      1  1ae2		       3b 00		      .byte.b	SEMICOLON,0
    309  1ae4				   S10A
      0  1ae4					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1ae4					      db	33
      1  1ae4		       21		      .byte.b	33
      0  1ae5					      db	(UNKNOWN-*)-1
      1  1ae5		       d6		      .byte.b	(UNKNOWN-*)-1
      0  1ae6					      TST	S10A1,DOLLAR
      0  1ae6					      db	32
      1  1ae6		       20		      .byte.b	32
      0  1ae7					      db	(S10A1-*)-1
      1  1ae7		       06		      .byte.b	(S10A1-*)-1
      0  1ae8					      db	DOLLAR,0
      1  1ae8		       24 00		      .byte.b	DOLLAR,0
      0  1aea					      INSTR		;Move character From tty to AESTK
      0  1aea					      db	59
      1  1aea		       3b		      .byte.b	59
      0  1aeb					      IJMP	S10A2
      0  1aeb					      db	29
      1  1aeb		       1d		      .byte.b	29
      0  1aec					      dw	S10A2
      1  1aec		       ef 1a		      .word.w	S10A2
    314  1aee				   S10A1
      0  1aee					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1aee					      db	11
      1  1aee		       0b		      .byte.b	11
    316  1aef				   S10A2
      0  1aef					      STORE		;STORE IT
      0  1aef					      db	19
      1  1aef		       13		      .byte.b	19
      0  1af0					      TST	S11,COMMA	;IS THERE MORE?
      0  1af0					      db	32
      1  1af0		       20		      .byte.b	32
      0  1af1					      db	(S11-*)-1
      1  1af1		       08		      .byte.b	(S11-*)-1
      0  1af2					      db	COMMA,0
      1  1af2		       2c 00		      .byte.b	COMMA,0
      0  1af4					      IJMP	S10	;YES
      0  1af4					      db	29
      1  1af4		       1d		      .byte.b	29
      0  1af5					      dw	S10
      1  1af5		       dd 1a		      .word.w	S10
    320  1af7				   S10Z
      0  1af7					      iJMP	UNKNOWN
      0  1af7					      db	29
      1  1af7		       1d		      .byte.b	29
      0  1af8					      dw	UNKNOWN
      1  1af8		       bc 1b		      .word.w	UNKNOWN
    322  1afa				   S11
      0  1afa					      DONE		;MUST BE CR
      0  1afa					      db	1
      1  1afa		       01		      .byte.b	1
      0  1afb					      NXT	CO	;SEQUENCE TO NEXT
      0  1afb					      db	6
      1  1afb		       06		      .byte.b	6
      0  1afc					      dw	CO
      1  1afc		       1b 19		      .word.w	CO
      0  1afe					      IJMP	STMT
      0  1afe					      db	29
      1  1afe		       1d		      .byte.b	29
      0  1aff					      dw	STMT
      1  1aff		       23 19		      .word.w	STMT
    326  1b01							;=====================================================================
    327  1b01							; End of program, return to command line process
    328  1b01							; Main Task may also use taske or return to stopped
    329  1b01							;
    330  1b01				   S13
      0  1b01					      TST	S14,"END"
      0  1b01					      db	32
      1  1b01		       20		      .byte.b	32
      0  1b02					      db	(S14-*)-1
      1  1b02		       08		      .byte.b	(S14-*)-1
      0  1b03					      db	"END",0
      1  1b03		       45 4e 44 00	      .byte.b	"END",0
      0  1b07					      FIN
      0  1b07					      db	12
      1  1b07		       0c		      .byte.b	12
    333  1b08
    334  1b08				   UNKNOWNV
      0  1b08					      IJMP	UNKNOWN
      0  1b08					      db	29
      1  1b08		       1d		      .byte.b	29
      0  1b09					      dw	UNKNOWN
      1  1b09		       bc 1b		      .word.w	UNKNOWN
    336  1b0b							;====================================================================
    337  1b0b							; IRQ <IRQ-HANDLER-Line expression>
    338  1b0b							;   Specify a line number subroutine to call when an interupt is processed
    339  1b0b							;   These subroutines must use iret to return.
    340  1b0b							;
    341  1b0b				   S14
      0  1b0b					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  1b0b					      db	32
      1  1b0b		       20		      .byte.b	32
      0  1b0c					      db	(S14Z-*)-1
      1  1b0c		       0f		      .byte.b	(S14Z-*)-1
      0  1b0d					      db	"IRQ",0
      1  1b0d		       49 52 51 00	      .byte.b	"IRQ",0
      0  1b11					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1b11					      db	28
      1  1b11		       1c		      .byte.b	28
      0  1b12					      dw	EXPR
      1  1b12		       c0 1b		      .word.w	EXPR
      0  1b14					      DONE		;must be CR
      0  1b14					      db	1
      1  1b14		       01		      .byte.b	1
      0  1b15					      SETIRQ		;Set the line number now
      0  1b15					      db	56
      1  1b15		       38		      .byte.b	56
      0  1b16					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1b16					      db	6
      1  1b16		       06		      .byte.b	6
      0  1b17					      dw	CO
      1  1b17		       1b 19		      .word.w	CO
      0  1b19					      IJMP	STMT
      0  1b19					      db	29
      1  1b19		       1d		      .byte.b	29
      0  1b1a					      dw	STMT
      1  1b1a		       23 19		      .word.w	STMT
    348  1b1c
    349  1b1c							;=========================================================================
    350  1b1c							; KILL PID-expression	 kill a running task
    351  1b1c							;  ignored of task has already stopped
    352  1b1c							;
    353  1b1c				   S14Z
      0  1b1c					      TST	S14S1,"KILL"	; Kill A running Task
      0  1b1c					      db	32
      1  1b1c		       20		      .byte.b	32
      0  1b1d					      db	(S14S1-*)-1
      1  1b1d		       10		      .byte.b	(S14S1-*)-1
      0  1b1e					      db	"KILL",0
      1  1b1e		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  1b23					      CALL	EXPR
      0  1b23					      db	28
      1  1b23		       1c		      .byte.b	28
      0  1b24					      dw	EXPR
      1  1b24		       c0 1b		      .word.w	EXPR
      0  1b26					      DONE
      0  1b26					      db	1
      1  1b26		       01		      .byte.b	1
      0  1b27					      TASKKILL
      0  1b27					      db	65
      1  1b27		       41		      .byte.b	65
      0  1b28					      NXT	CO
      0  1b28					      db	6
      1  1b28		       06		      .byte.b	6
      0  1b29					      dw	CO
      1  1b29		       1b 19		      .word.w	CO
      0  1b2b					      IJMP	STMT
      0  1b2b					      db	29
      1  1b2b		       1d		      .byte.b	29
      0  1b2c					      dw	STMT
      1  1b2c		       23 19		      .word.w	STMT
    360  1b2e
    361  1b2e							;============================================================================
    362  1b2e							; List all program lines
    363  1b2e							;
    364  1b2e				   S14S1
      0  1b2e					      TST	S15,"LIST"	;LIST COMMAND
      0  1b2e					      db	32
      1  1b2e		       20		      .byte.b	32
      0  1b2f					      db	(S15-*)-1
      1  1b2f		       0a		      .byte.b	(S15-*)-1
      0  1b30					      db	"LIST",0
      1  1b30		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1b35					      DONE
      0  1b35					      db	1
      1  1b35		       01		      .byte.b	1
      0  1b36					      LST
      0  1b36					      db	21
      1  1b36		       15		      .byte.b	21
      0  1b37					      IJMP	CO
      0  1b37					      db	29
      1  1b37		       1d		      .byte.b	29
      0  1b38					      dw	CO
      1  1b38		       1b 19		      .word.w	CO
    369  1b3a							;=======================================================================
    370  1b3a							;RUN begin to executed the program in memory
    371  1b3a							;
    372  1b3a				   S15
      0  1b3a					      TST	S16,"RUN"	;RUN COMMAND
      0  1b3a					      db	32
      1  1b3a		       20		      .byte.b	32
      0  1b3b					      db	(S16-*)-1
      1  1b3b		       0d		      .byte.b	(S16-*)-1
      0  1b3c					      db	"RUN",0
      1  1b3c		       52 55 4e 00	      .byte.b	"RUN",0
      0  1b40					      DONE
      0  1b40					      db	1
      1  1b40		       01		      .byte.b	1
      0  1b41					      VINIT		;clear variables
      0  1b41					      db	30
      1  1b41		       1e		      .byte.b	30
      0  1b42					      LIT	1	;GOTO line 1
      0  1b42					      db	27
      1  1b42		       1b		      .byte.b	27
      0  1b43					      dw	1
      1  1b43		       01 00		      .word.w	1
      0  1b45					      XFER		;Bob's addition
      0  1b45					      db	7
      1  1b45		       07		      .byte.b	7
    378  1b46							; EXIT
      0  1b46					      IJMP	STMT	;and run!
      0  1b46					      db	29
      1  1b46		       1d		      .byte.b	29
      0  1b47					      dw	STMT
      1  1b47		       23 19		      .word.w	STMT
    380  1b49							;=========================================================================
    381  1b49							;Clear the program memory, delete all proram lines
    382  1b49							;
    383  1b49				   S16
      0  1b49					      TST	S16A,"NEW"	;clear program
      0  1b49					      db	32
      1  1b49		       20		      .byte.b	32
      0  1b4a					      db	(S16A-*)-1
      1  1b4a		       08		      .byte.b	(S16A-*)-1
      0  1b4b					      db	"NEW",0
      1  1b4b		       4e 45 57 00	      .byte.b	"NEW",0
      0  1b4f					      DONE
      0  1b4f					      db	1
      1  1b4f		       01		      .byte.b	1
      0  1b50					      IJMP	START
      0  1b50					      db	29
      1  1b50		       1d		      .byte.b	29
      0  1b51					      dw	START
      1  1b51		       15 19		      .word.w	START
    387  1b53
    388  1b53							;========================================================================
    389  1b53							; Slice(slice legth expression)
    390  1b53							;   set the length of time between task switches
    391  1b53							;
    392  1b53				   S16A
      0  1b53					      TST	S16Trace,"SLICE"
      0  1b53					      db	32
      1  1b53		       20		      .byte.b	32
      0  1b54					      db	(S16Trace-*)-1
      1  1b54		       11		      .byte.b	(S16Trace-*)-1
      0  1b55					      db	"SLICE",0
      1  1b55		       53 4c 49 43*	      .byte.b	"SLICE",0
      0  1b5b					      CALL	EXPR
      0  1b5b					      db	28
      1  1b5b		       1c		      .byte.b	28
      0  1b5c					      dw	EXPR
      1  1b5c		       c0 1b		      .word.w	EXPR
      0  1b5e					      SLICE
      0  1b5e					      db	100
      1  1b5e		       64		      .byte.b	100
      0  1b5f					      DONE
      0  1b5f					      db	1
      1  1b5f		       01		      .byte.b	1
      0  1b60					      NXT	CO
      0  1b60					      db	6
      1  1b60		       06		      .byte.b	6
      0  1b61					      dw	CO
      1  1b61		       1b 19		      .word.w	CO
      0  1b63					      IJMP	STMT
      0  1b63					      db	29
      1  1b63		       1d		      .byte.b	29
      0  1b64					      dw	STMT
      1  1b64		       23 19		      .word.w	STMT
    399  1b66							;==========================================================================
    400  1b66							; Turn off and on the thrace functions
    401  1b66							; a debug terminal needs to be available
    402  1b66							; Trace( Trace flag expression)
    403  1b66							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    404  1b66							;	for individual lines of basic code. These can be combined
    405  1b66				   S16Trace
      0  1b66					      TST	S17A,"TRACE("	;Are we going to trace
      0  1b66					      db	32
      1  1b66		       20		      .byte.b	32
      0  1b67					      db	(S17A-*)-1
      1  1b67		       16		      .byte.b	(S17A-*)-1
      0  1b68					      db	"TRACE(",0
      1  1b68		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  1b6f					      CALL	EXPR
      0  1b6f					      db	28
      1  1b6f		       1c		      .byte.b	28
      0  1b70					      dw	EXPR
      1  1b70		       c0 1b		      .word.w	EXPR
      0  1b72					      TST	UNKNOWN,")"
      0  1b72					      db	32
      1  1b72		       20		      .byte.b	32
      0  1b73					      db	(UNKNOWN-*)-1
      1  1b73		       48		      .byte.b	(UNKNOWN-*)-1
      0  1b74					      db	")",0
      1  1b74		       29 00		      .byte.b	")",0
      0  1b76					      TRACEPROGRAM
      0  1b76					      db	78
      1  1b76		       4e		      .byte.b	78
      0  1b77					      DONE
      0  1b77					      db	1
      1  1b77		       01		      .byte.b	1
      0  1b78					      NXT	CO
      0  1b78					      db	6
      1  1b78		       06		      .byte.b	6
      0  1b79					      dw	CO
      1  1b79		       1b 19		      .word.w	CO
      0  1b7b					      IJMP	STMT
      0  1b7b					      db	29
      1  1b7b		       1d		      .byte.b	29
      0  1b7c					      dw	STMT
      1  1b7c		       23 19		      .word.w	STMT
    413  1b7e							;=====================================================================
    414  1b7e							; Exit basic to machine monitor
    415  1b7e							;
    416  1b7e				   S17A
      0  1b7e					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1b7e					      db	32
      1  1b7e		       20		      .byte.b	32
      0  1b7f					      db	(S17B-*)-1
      1  1b7f		       06		      .byte.b	(S17B-*)-1
      0  1b80					      db	"EXIT",0
      1  1b80		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1b85					      EXIT
      0  1b85					      db	26
      1  1b85		       1a		      .byte.b	26
    419  1b86
    420  1b86							;=======================================================================
    421  1b86							; Commands related to saving/restoring programs
    422  1b86							; to/from mass storage.
    423  1b86							;
    424  1b86				   S17B
    425  1b86					      if	(XKIM || CTMON65) && DISK_ACCESS
    426  1b86
      0  1b86					      TST	S17C,"SAVE"
      0  1b86					      db	32
      1  1b86		       20		      .byte.b	32
      0  1b87					      db	(S17C-*)-1
      1  1b87		       0b		      .byte.b	(S17C-*)-1
      0  1b88					      db	"SAVE",0
      1  1b88		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1b8d					      OPENWRITE
      0  1b8d					      db	40
      1  1b8d		       28		      .byte.b	40
      0  1b8e					      DLIST
      0  1b8e					      db	43
      1  1b8e		       2b		      .byte.b	43
      0  1b8f					      DCLOSE
      0  1b8f					      db	41
      1  1b8f		       29		      .byte.b	41
      0  1b90					      IJMP	CO
      0  1b90					      db	29
      1  1b90		       1d		      .byte.b	29
      0  1b91					      dw	CO
      1  1b91		       1b 19		      .word.w	CO
    432  1b93
    433  1b93				   S17C
      0  1b93					      TST	S18,"LOAD"
      0  1b93					      db	32
      1  1b93		       20		      .byte.b	32
      0  1b94					      db	(S18-*)-1
      1  1b94		       11		      .byte.b	(S18-*)-1
      0  1b95					      db	"LOAD",0
      1  1b95		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1b9a					      OPENREAD
      0  1b9a					      db	39
      1  1b9a		       27		      .byte.b	39
    436  1b9b				   S17CLP
      0  1b9b					      DGETLINE		;get line from file
      0  1b9b					      db	42
      1  1b9b		       2a		      .byte.b	42
      0  1b9c					      TSTL	S17EOL	;no line num means EOL
      0  1b9c					      db	34
      1  1b9c		       22		      .byte.b	34
      0  1b9d					      db	(S17EOL-*)-1
      1  1b9d		       04		      .byte.b	(S17EOL-*)-1
      0  1b9e					      INSERT		;put it into the program
      0  1b9e					      db	24
      1  1b9e		       18		      .byte.b	24
      0  1b9f					      IJMP	S17CLP	;keep going
      0  1b9f					      db	29
      1  1b9f		       1d		      .byte.b	29
      0  1ba0					      dw	S17CLP
      1  1ba0		       9b 1b		      .word.w	S17CLP
    441  1ba2				   S17EOL
      0  1ba2					      DCLOSE		;close disk file
      0  1ba2					      db	41
      1  1ba2		       29		      .byte.b	41
      0  1ba3					      IJMP	CO	;back to start
      0  1ba3					      db	29
      1  1ba3		       1d		      .byte.b	29
      0  1ba4					      dw	CO
      1  1ba4		       1b 19		      .word.w	CO
    444  1ba6
    445  1ba6				   S18
      0  1ba6					      TST	S19,"DIR"
      0  1ba6					      db	32
      1  1ba6		       20		      .byte.b	32
      0  1ba7					      db	(S19-*)-1
      1  1ba7		       08		      .byte.b	(S19-*)-1
      0  1ba8					      db	"DIR",0
      1  1ba8		       44 49 52 00	      .byte.b	"DIR",0
      0  1bac					      DDIR		;Display the directory content
      0  1bac					      db	44
      1  1bac		       2c		      .byte.b	44
      0  1bad					      IJMP	CO
      0  1bad					      db	29
      1  1bad		       1d		      .byte.b	29
      0  1bae					      dw	CO
      1  1bae		       1b 19		      .word.w	CO
    449  1bb0
      0  1bb0				   S19	      TST	UNKNOWN,"ERASE"
      0  1bb0					      db	32
      1  1bb0		       20		      .byte.b	32
      0  1bb1					      db	(UNKNOWN-*)-1
      1  1bb1		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1bb2					      db	"ERASE",0
      1  1bb2		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1bb8					      RMFILE		;Erase the file from the disk
      0  1bb8					      db	45
      1  1bb8		       2d		      .byte.b	45
      0  1bb9					      IJMP	CO
      0  1bb9					      db	29
      1  1bb9		       1d		      .byte.b	29
      0  1bba					      dw	CO
      1  1bba		       1b 19		      .word.w	CO
    453  1bbc
    454  1bbc					      endif
    455  1bbc
    456  1bbc							;
    457  1bbc							; Else, unknown command.
    458  1bbc							;
    459  1bbc				   UNKNOWN
      0  1bbc					      ENDIO
      0  1bbc					      db	71
      1  1bbc		       47		      .byte.b	71
      0  1bbd					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1bbd					      db	13
      1  1bbd		       0d		      .byte.b	13
      0  1bbe					      dw	ERR_SYNTAX
      1  1bbe		       05 00		      .word.w	ERR_SYNTAX
    462  1bc0
    463  1bc0							;=======================================================
    464  1bc0							; Process Expresions, precidence is represented by the
    465  1bc0							; various call levels
    466  1bc0							;
    467  1bc0				   EXPR
      0  1bc0					      TST	EXPRLOGS,"NOT"
      0  1bc0					      db	32
      1  1bc0		       20		      .byte.b	32
      0  1bc1					      db	(EXPRLOGS-*)-1
      1  1bc1		       09		      .byte.b	(EXPRLOGS-*)-1
      0  1bc2					      db	"NOT",0
      1  1bc2		       4e 4f 54 00	      .byte.b	"NOT",0
      0  1bc6					      Call	EXPR
      0  1bc6					      db	28
      1  1bc6		       1c		      .byte.b	28
      0  1bc7					      dw	EXPR
      1  1bc7		       c0 1b		      .word.w	EXPR
      0  1bc9					      LOGNOT
      0  1bc9					      db	72
      1  1bc9		       48		      .byte.b	72
      0  1bca					      RTN
      0  1bca					      db	25
      1  1bca		       19		      .byte.b	25
    472  1bcb
    473  1bcb							;=========================================================
    474  1bcb							;Look for logical operators
    475  1bcb				   EXPRLOGS
      0  1bcb					      Call	EXPRCMP
      0  1bcb					      db	28
      1  1bcb		       1c		      .byte.b	28
      0  1bcc					      dw	EXPRCMP
      1  1bcc		       ef 1b		      .word.w	EXPRCMP
      0  1bce					      TST	iLOG1,"AND"
      0  1bce					      db	32
      1  1bce		       20		      .byte.b	32
      0  1bcf					      db	(iLOG1-*)-1
      1  1bcf		       09		      .byte.b	(iLOG1-*)-1
      0  1bd0					      db	"AND",0
      1  1bd0		       41 4e 44 00	      .byte.b	"AND",0
      0  1bd4					      Call	EXPR
      0  1bd4					      db	28
      1  1bd4		       1c		      .byte.b	28
      0  1bd5					      dw	EXPR
      1  1bd5		       c0 1b		      .word.w	EXPR
      0  1bd7					      LOGAND
      0  1bd7					      db	74
      1  1bd7		       4a		      .byte.b	74
      0  1bd8					      RTN
      0  1bd8					      db	25
      1  1bd8		       19		      .byte.b	25
    481  1bd9				   iLOG1
      0  1bd9					      TST	iLOG2,"OR"
      0  1bd9					      db	32
      1  1bd9		       20		      .byte.b	32
      0  1bda					      db	(iLOG2-*)-1
      1  1bda		       08		      .byte.b	(iLOG2-*)-1
      0  1bdb					      db	"OR",0
      1  1bdb		       4f 52 00 	      .byte.b	"OR",0
      0  1bde					      Call	EXPR
      0  1bde					      db	28
      1  1bde		       1c		      .byte.b	28
      0  1bdf					      dw	EXPR
      1  1bdf		       c0 1b		      .word.w	EXPR
      0  1be1					      LOGOR
      0  1be1					      db	73
      1  1be1		       49		      .byte.b	73
      0  1be2					      RTN
      0  1be2					      db	25
      1  1be2		       19		      .byte.b	25
    486  1be3				   iLOG2
      0  1be3					      TST	iLOG3,"XOR"
      0  1be3					      db	32
      1  1be3		       20		      .byte.b	32
      0  1be4					      db	(iLOG3-*)-1
      1  1be4		       09		      .byte.b	(iLOG3-*)-1
      0  1be5					      db	"XOR",0
      1  1be5		       58 4f 52 00	      .byte.b	"XOR",0
      0  1be9					      Call	EXPR
      0  1be9					      db	28
      1  1be9		       1c		      .byte.b	28
      0  1bea					      dw	EXPR
      1  1bea		       c0 1b		      .word.w	EXPR
      0  1bec					      LOGXOR
      0  1bec					      db	75
      1  1bec		       4b		      .byte.b	75
      0  1bed					      RTN
      0  1bed					      db	25
      1  1bed		       19		      .byte.b	25
    491  1bee				   iLOG3
      0  1bee					      RTN
      0  1bee					      db	25
      1  1bee		       19		      .byte.b	25
    493  1bef
    494  1bef				   EXPRCMP
      0  1bef					      Call	EXPR2	; get the first expression
      0  1bef					      db	28
      1  1bef		       1c		      .byte.b	28
      0  1bf0					      dw	EXPR2
      1  1bf0		       3b 1c		      .word.w	EXPR2
      0  1bf2					      TST	iR0,"="
      0  1bf2					      db	32
      1  1bf2		       20		      .byte.b	32
      0  1bf3					      db	(iR0-*)-1
      1  1bf3		       08		      .byte.b	(iR0-*)-1
      0  1bf4					      db	"=",0
      1  1bf4		       3d 00		      .byte.b	"=",0
      0  1bf6					      LIT	2	;=
      0  1bf6					      db	27
      1  1bf6		       1b		      .byte.b	27
      0  1bf7					      dw	2
      1  1bf7		       02 00		      .word.w	2
      0  1bf9					      IJMP	iRFound
      0  1bf9					      db	29
      1  1bf9		       1d		      .byte.b	29
      0  1bfa					      dw	iRFound
      1  1bfa		       35 1c		      .word.w	iRFound
    499  1bfc				   iR0
      0  1bfc					      TST	iR4,"<"
      0  1bfc					      db	32
      1  1bfc		       20		      .byte.b	32
      0  1bfd					      db	(iR4-*)-1
      1  1bfd		       1c		      .byte.b	(iR4-*)-1
      0  1bfe					      db	"<",0
      1  1bfe		       3c 00		      .byte.b	"<",0
      0  1c00					      TST	iR1,"="
      0  1c00					      db	32
      1  1c00		       20		      .byte.b	32
      0  1c01					      db	(iR1-*)-1
      1  1c01		       08		      .byte.b	(iR1-*)-1
      0  1c02					      db	"=",0
      1  1c02		       3d 00		      .byte.b	"=",0
      0  1c04					      LIT	3	;<=
      0  1c04					      db	27
      1  1c04		       1b		      .byte.b	27
      0  1c05					      dw	3
      1  1c05		       03 00		      .word.w	3
      0  1c07					      IJMP	iRFound
      0  1c07					      db	29
      1  1c07		       1d		      .byte.b	29
      0  1c08					      dw	iRFound
      1  1c08		       35 1c		      .word.w	iRFound
    504  1c0a				   iR1
      0  1c0a					      TST	iR3,">"
      0  1c0a					      db	32
      1  1c0a		       20		      .byte.b	32
      0  1c0b					      db	(iR3-*)-1
      1  1c0b		       08		      .byte.b	(iR3-*)-1
      0  1c0c					      db	">",0
      1  1c0c		       3e 00		      .byte.b	">",0
      0  1c0e					      LIT	5	;<>
      0  1c0e					      db	27
      1  1c0e		       1b		      .byte.b	27
      0  1c0f					      dw	5
      1  1c0f		       05 00		      .word.w	5
      0  1c11					      IJMP	iRFound
      0  1c11					      db	29
      1  1c11		       1d		      .byte.b	29
      0  1c12					      dw	iRFound
      1  1c12		       35 1c		      .word.w	iRFound
    508  1c14				   iR3
      0  1c14					      LIT	1	;<
      0  1c14					      db	27
      1  1c14		       1b		      .byte.b	27
      0  1c15					      dw	1
      1  1c15		       01 00		      .word.w	1
      0  1c17					      IJMP	iRFound
      0  1c17					      db	29
      1  1c17		       1d		      .byte.b	29
      0  1c18					      dw	iRFound
      1  1c18		       35 1c		      .word.w	iRFound
    511  1c1a				   iR4
      0  1c1a					      TST	iRDone,">"
      0  1c1a					      db	32
      1  1c1a		       20		      .byte.b	32
      0  1c1b					      db	(iRDone-*)-1
      1  1c1b		       1e		      .byte.b	(iRDone-*)-1
      0  1c1c					      db	">",0
      1  1c1c		       3e 00		      .byte.b	">",0
      0  1c1e					      TST	iR5,"="
      0  1c1e					      db	32
      1  1c1e		       20		      .byte.b	32
      0  1c1f					      db	(iR5-*)-1
      1  1c1f		       08		      .byte.b	(iR5-*)-1
      0  1c20					      db	"=",0
      1  1c20		       3d 00		      .byte.b	"=",0
      0  1c22					      LIT	6	;>=
      0  1c22					      db	27
      1  1c22		       1b		      .byte.b	27
      0  1c23					      dw	6
      1  1c23		       06 00		      .word.w	6
      0  1c25					      IJMP	iRFound
      0  1c25					      db	29
      1  1c25		       1d		      .byte.b	29
      0  1c26					      dw	iRFound
      1  1c26		       35 1c		      .word.w	iRFound
    516  1c28				   iR5
      0  1c28					      TST	iR6,"<"
      0  1c28					      db	32
      1  1c28		       20		      .byte.b	32
      0  1c29					      db	(iR6-*)-1
      1  1c29		       08		      .byte.b	(iR6-*)-1
      0  1c2a					      db	"<",0
      1  1c2a		       3c 00		      .byte.b	"<",0
      0  1c2c					      LIT	1
      0  1c2c					      db	27
      1  1c2c		       1b		      .byte.b	27
      0  1c2d					      dw	1
      1  1c2d		       01 00		      .word.w	1
      0  1c2f					      IJMP	iRFound	;(This line originally omitted)
      0  1c2f					      db	29
      1  1c2f		       1d		      .byte.b	29
      0  1c30					      dw	iRFound
      1  1c30		       35 1c		      .word.w	iRFound
    520  1c32				   iR6
      0  1c32					      LIT	4	;>
      0  1c32					      db	27
      1  1c32		       1b		      .byte.b	27
      0  1c33					      dw	4
      1  1c33		       04 00		      .word.w	4
    522  1c35				   iRFound
      0  1c35					      Call	EXPR	; get the right side of the expression
      0  1c35					      db	28
      1  1c35		       1c		      .byte.b	28
      0  1c36					      dw	EXPR
      1  1c36		       c0 1b		      .word.w	EXPR
      0  1c38					      CMPR		; Push the value of the true false onto the stack
      0  1c38					      db	10
      1  1c38		       0a		      .byte.b	10
      0  1c39					      RTN
      0  1c39					      db	25
      1  1c39		       19		      .byte.b	25
    526  1c3a
    527  1c3a				   iRDone
      0  1c3a					      RTN
      0  1c3a					      db	25
      1  1c3a		       19		      .byte.b	25
    529  1c3b
    530  1c3b				   EXPR2
      0  1c3b					      TST	E0,"-"	; Look for leading - to negate term
      0  1c3b					      db	32
      1  1c3b		       20		      .byte.b	32
      0  1c3c					      db	(E0-*)-1
      1  1c3c		       09		      .byte.b	(E0-*)-1
      0  1c3d					      db	"-",0
      1  1c3d		       2d 00		      .byte.b	"-",0
      0  1c3f					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1c3f					      db	28
      1  1c3f		       1c		      .byte.b	28
      0  1c40					      dw	TERM
      1  1c40		       64 1c		      .word.w	TERM
      0  1c42					      NEG		; Make value negated
      0  1c42					      db	16
      1  1c42		       10		      .byte.b	16
      0  1c43					      IJMP	E1	; We have Left term process operators next
      0  1c43					      db	29
      1  1c43		       1d		      .byte.b	29
      0  1c44					      dw	E1
      1  1c44		       4d 1c		      .word.w	E1
    535  1c46				   E0
      0  1c46					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1c46					      db	32
      1  1c46		       20		      .byte.b	32
      0  1c47					      db	(E1A-*)-1
      1  1c47		       02		      .byte.b	(E1A-*)-1
      0  1c48					      db	"+",0
      1  1c48		       2b 00		      .byte.b	"+",0
    537  1c4a				   E1A
      0  1c4a					      CALL	TERM	; Get the left term if it was not negated
      0  1c4a					      db	28
      1  1c4a		       1c		      .byte.b	28
      0  1c4b					      dw	TERM
      1  1c4b		       64 1c		      .word.w	TERM
    539  1c4d				   E1
      0  1c4d					      TST	E2,"+"	; Check if we are adding left term to something
      0  1c4d					      db	32
      1  1c4d		       20		      .byte.b	32
      0  1c4e					      db	(E2-*)-1
      1  1c4e		       09		      .byte.b	(E2-*)-1
      0  1c4f					      db	"+",0
      1  1c4f		       2b 00		      .byte.b	"+",0
      0  1c51					      CALL	TERM	; if adding then get the right side term
      0  1c51					      db	28
      1  1c51		       1c		      .byte.b	28
      0  1c52					      dw	TERM
      1  1c52		       64 1c		      .word.w	TERM
      0  1c54					      ADD		; Add it to left term
      0  1c54					      db	14
      1  1c54		       0e		      .byte.b	14
      0  1c55					      IJMP	E1	; look for next + or -
      0  1c55					      db	29
      1  1c55		       1d		      .byte.b	29
      0  1c56					      dw	E1
      1  1c56		       4d 1c		      .word.w	E1
    544  1c58				   E2
      0  1c58					      TST	E3,"-"	; Check if we are subtractig something
      0  1c58					      db	32
      1  1c58		       20		      .byte.b	32
      0  1c59					      db	(E3-*)-1
      1  1c59		       09		      .byte.b	(E3-*)-1
      0  1c5a					      db	"-",0
      1  1c5a		       2d 00		      .byte.b	"-",0
      0  1c5c					      CALL	TERM	; get right side to subtract Diffrence
      0  1c5c					      db	28
      1  1c5c		       1c		      .byte.b	28
      0  1c5d					      dw	TERM
      1  1c5d		       64 1c		      .word.w	TERM
      0  1c5f					      SUB		; Subtract the value
      0  1c5f					      db	15
      1  1c5f		       0f		      .byte.b	15
      0  1c60					      IJMP	E1	; Look for next + or -
      0  1c60					      db	29
      1  1c60		       1d		      .byte.b	29
      0  1c61					      dw	E1
      1  1c61		       4d 1c		      .word.w	E1
    549  1c63				   E3			; Finish processing the expression
      0  1c63					      RTN		; We are finished processing the Expression
      0  1c63					      db	25
      1  1c63		       19		      .byte.b	25
    551  1c64							;
    552  1c64							; Get one of the terms of an expression
    553  1c64							;
    554  1c64				   TERM
      0  1c64					      CALL	FACT	; Get a value
      0  1c64					      db	28
      1  1c64		       1c		      .byte.b	28
      0  1c65					      dw	FACT
      1  1c65		       8c 1c		      .word.w	FACT
    556  1c67				   T0			; Check for higher precidence operators
      0  1c67					      TST	T1,"*"	; Check for *
      0  1c67					      db	32
      1  1c67		       20		      .byte.b	32
      0  1c68					      db	(T1-*)-1
      1  1c68		       09		      .byte.b	(T1-*)-1
      0  1c69					      db	"*",0
      1  1c69		       2a 00		      .byte.b	"*",0
      0  1c6b					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1c6b					      db	28
      1  1c6b		       1c		      .byte.b	28
      0  1c6c					      dw	FACT
      1  1c6c		       8c 1c		      .word.w	FACT
      0  1c6e					      MUL		; Multiply factors
      0  1c6e					      db	17
      1  1c6e		       11		      .byte.b	17
      0  1c6f					      IJMP	T0	; Check for * or /
      0  1c6f					      db	29
      1  1c6f		       1d		      .byte.b	29
      0  1c70					      dw	T0
      1  1c70		       67 1c		      .word.w	T0
    561  1c72				   T1
      0  1c72					      TST	T2,"/"	; Check for a division
      0  1c72					      db	32
      1  1c72		       20		      .byte.b	32
      0  1c73					      db	(T2-*)-1
      1  1c73		       09		      .byte.b	(T2-*)-1
      0  1c74					      db	"/",0
      1  1c74		       2f 00		      .byte.b	"/",0
      0  1c76					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c76					      db	28
      1  1c76		       1c		      .byte.b	28
      0  1c77					      dw	FACT
      1  1c77		       8c 1c		      .word.w	FACT
      0  1c79					      DIV		; do division
      0  1c79					      db	18
      1  1c79		       12		      .byte.b	18
      0  1c7a					      IJMP	T0	; check for more * or /
      0  1c7a					      db	29
      1  1c7a		       1d		      .byte.b	29
      0  1c7b					      dw	T0
      1  1c7b		       67 1c		      .word.w	T0
    566  1c7d				   T2
      0  1c7d					      TST	T3,"%"	; Check for a division
      0  1c7d					      db	32
      1  1c7d		       20		      .byte.b	32
      0  1c7e					      db	(T3-*)-1
      1  1c7e		       09		      .byte.b	(T3-*)-1
      0  1c7f					      db	"%",0
      1  1c7f		       25 00		      .byte.b	"%",0
      0  1c81					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c81					      db	28
      1  1c81		       1c		      .byte.b	28
      0  1c82					      dw	FACT
      1  1c82		       8c 1c		      .word.w	FACT
      0  1c84					      MODULO		; do division for remainder
      0  1c84					      db	60
      1  1c84		       3c		      .byte.b	60
      0  1c85					      IJMP	T0	; check for more * or / or %
      0  1c85					      db	29
      1  1c85		       1d		      .byte.b	29
      0  1c86					      dw	T0
      1  1c86		       67 1c		      .word.w	T0
    571  1c88				   T3			; Finish processing the Term
      0  1c88					      RTN
      0  1c88					      db	25
      1  1c88		       19		      .byte.b	25
    573  1c89
    574  1c89				   UNKNOWNVEC
      0  1c89					      IJMP	UNKNOWN
      0  1c89					      db	29
      1  1c89		       1d		      .byte.b	29
      0  1c8a					      dw	UNKNOWN
      1  1c8a		       bc 1b		      .word.w	UNKNOWN
    576  1c8c
    577  1c8c							;=============================================================================================
    578  1c8c							; Factor an expression.  Always test for functions
    579  1c8c							; first or else they'll be confused for variables.
    580  1c8c							;
    581  1c8c				   FACT
      0  1c8c					      TST	F1AA,"TRUE"
      0  1c8c					      db	32
      1  1c8c		       20		      .byte.b	32
      0  1c8d					      db	(F1AA-*)-1
      1  1c8d		       09		      .byte.b	(F1AA-*)-1
      0  1c8e					      db	"TRUE",0
      1  1c8e		       54 52 55 45*	      .byte.b	"TRUE",0
      0  1c93					      LIT	-1
      0  1c93					      db	27
      1  1c93		       1b		      .byte.b	27
      0  1c94					      dw	-1
      1  1c94		       ff ff		      .word.w	-1
      0  1c96					      RTN
      0  1c96					      db	25
      1  1c96		       19		      .byte.b	25
    585  1c97				   F1AA
      0  1c97					      TST	F1AB,"FALSE"
      0  1c97					      db	32
      1  1c97		       20		      .byte.b	32
      0  1c98					      db	(F1AB-*)-1
      1  1c98		       0a		      .byte.b	(F1AB-*)-1
      0  1c99					      db	"FALSE",0
      1  1c99		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1c9f					      LIT	0
      0  1c9f					      db	27
      1  1c9f		       1b		      .byte.b	27
      0  1ca0					      dw	0
      1  1ca0		       00 00		      .word.w	0
      0  1ca2					      RTN
      0  1ca2					      db	25
      1  1ca2		       19		      .byte.b	25
    589  1ca3							;==================================================================================
    590  1ca3							; Returns the amount of free SPACE
    591  1ca3							;
    592  1ca3				   F1AB
      0  1ca3					      TST	F1A,"FREE()"
      0  1ca3					      db	32
      1  1ca3		       20		      .byte.b	32
      0  1ca4					      db	(F1A-*)-1
      1  1ca4		       09		      .byte.b	(F1A-*)-1
      0  1ca5					      db	"FREE()",0
      1  1ca5		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1cac					      FREE
      0  1cac					      db	36
      1  1cac		       24		      .byte.b	36
      0  1cad					      RTN
      0  1cad					      db	25
      1  1cad		       19		      .byte.b	25
    596  1cae							;===================================================================================
    597  1cae							; getch() read a character from the input device
    598  1cae							;
    599  1cae				   F1A
      0  1cae					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1cae					      db	32
      1  1cae		       20		      .byte.b	32
      0  1caf					      db	(F1A2-*)-1
      1  1caf		       0a		      .byte.b	(F1A2-*)-1
      0  1cb0					      db	"GETCH()",0
      1  1cb0		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1cb8					      GETCHAR
      0  1cb8					      db	51
      1  1cb8		       33		      .byte.b	51
      0  1cb9					      RTN
      0  1cb9					      db	25
      1  1cb9		       19		      .byte.b	25
    603  1cba							;====================================================================================
    604  1cba							; peek(mem address) return the value of a byte in memory
    605  1cba							; @[offset] return a word value from offset -- see tstv
    606  1cba							;
    607  1cba				   F1A2
      0  1cba					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1cba					      db	32
      1  1cba		       20		      .byte.b	32
      0  1cbb					      db	(F2AZ-*)-1
      1  1cbb		       0f		      .byte.b	(F2AZ-*)-1
      0  1cbc					      db	"PEEK(",0
      1  1cbc		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1cc2					      CALL	EXPR	;Get the address to write to
      0  1cc2					      db	28
      1  1cc2		       1c		      .byte.b	28
      0  1cc3					      dw	EXPR
      1  1cc3		       c0 1b		      .word.w	EXPR
      0  1cc5					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  1cc5					      db	32
      1  1cc5		       20		      .byte.b	32
      0  1cc6					      db	(UNKNOWNVEC-*)-1
      1  1cc6		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cc7					      db	")",0
      1  1cc7		       29 00		      .byte.b	")",0
      0  1cc9					      PEEKMEM
      0  1cc9					      db	48
      1  1cc9		       30		      .byte.b	48
      0  1cca					      RTN
      0  1cca					      db	25
      1  1cca		       19		      .byte.b	25
    613  1ccb							;=======================================================================================
    614  1ccb							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    615  1ccb							;
    616  1ccb				   F2AZ
      0  1ccb					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  1ccb					      db	32
      1  1ccb		       20		      .byte.b	32
      0  1ccc					      db	(F2AZ1-*)-1
      1  1ccc		       22		      .byte.b	(F2AZ1-*)-1
      0  1ccd					      db	"TASK(",0
      1  1ccd		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1cd3					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1cd3					      db	28
      1  1cd3		       1c		      .byte.b	28
      0  1cd4					      dw	EXPR
      1  1cd4		       c0 1b		      .word.w	EXPR
      0  1cd6					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  1cd6					      db	61
      1  1cd6		       3d		      .byte.b	61
      0  1cd7					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  1cd7					      db	32
      1  1cd7		       20		      .byte.b	32
      0  1cd8					      db	(F2AZNoParms-*)-1
      1  1cd8		       10		      .byte.b	(F2AZNoParms-*)-1
      0  1cd9					      db	COMMA,0
      1  1cd9		       2c 00		      .byte.b	COMMA,0
      0  1cdb					      SAVEMATHSTACK		;Push The mathstack
      0  1cdb					      db	86
      1  1cdb		       56		      .byte.b	86
      0  1cdc					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  1cdc					      db	89
      1  1cdc		       59		      .byte.b	89
    623  1cdd				   F2AZLOOP
      0  1cdd					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  1cdd					      db	28
      1  1cdd		       1c		      .byte.b	28
      0  1cde					      dw	EXPR
      1  1cde		       c0 1b		      .word.w	EXPR
      0  1ce0					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  1ce0					      db	32
      1  1ce0		       20		      .byte.b	32
      0  1ce1					      db	(F2AZEndParm-*)-1
      1  1ce1		       05		      .byte.b	(F2AZEndParm-*)-1
      0  1ce2					      db	COMMA,0
      1  1ce2		       2c 00		      .byte.b	COMMA,0
      0  1ce4					      IJMP	F2AZLOOP	;check for more
      0  1ce4					      db	29
      1  1ce4		       1d		      .byte.b	29
      0  1ce5					      dw	F2AZLOOP
      1  1ce5		       dd 1c		      .word.w	F2AZLOOP
    627  1ce7				   F2AZEndParm
      0  1ce7					      RESTOREMATHSTACK		;Back to normal stack
      0  1ce7					      db	87
      1  1ce7		       57		      .byte.b	87
      0  1ce8					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  1ce8					      db	92
      1  1ce8		       5c		      .byte.b	92
    630  1ce9				   F2AZNoParms
      0  1ce9					      TST	UNKNOWNVEC,")"	;must be )
      0  1ce9					      db	32
      1  1ce9		       20		      .byte.b	32
      0  1cea					      db	(UNKNOWNVEC-*)-1
      1  1cea		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1ceb					      db	")",0
      1  1ceb		       29 00		      .byte.b	")",0
      0  1ced					      TASKENABLE		;Enable the task to execute
      0  1ced					      db	90
      1  1ced		       5a		      .byte.b	90
      0  1cee					      RTN		;Returns the Task number
      0  1cee					      db	25
      1  1cee		       19		      .byte.b	25
    634  1cef							;=========================================================================================
    635  1cef							; Check for IPC interproccess instructions
    636  1cef							;   IPCS  - Send a message
    637  1cef							;
    638  1cef				   F2AZ1
      0  1cef					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  1cef					      db	32
      1  1cef		       20		      .byte.b	32
      0  1cf0					      db	(F2A-*)-1
      1  1cf0		       3c		      .byte.b	(F2A-*)-1
      0  1cf1					      db	"IPC",0
      1  1cf1		       49 50 43 00	      .byte.b	"IPC",0
      0  1cf5					      TST	F2AZa,"S("	;IPCS - send a message
      0  1cf5					      db	32
      1  1cf5		       20		      .byte.b	32
      0  1cf6					      db	(F2AZa-*)-1
      1  1cf6		       13		      .byte.b	(F2AZa-*)-1
      0  1cf7					      db	"S(",0
      1  1cf7		       53 28 00 	      .byte.b	"S(",0
      0  1cfa					      CALL	EXPR	;Get the message value
      0  1cfa					      db	28
      1  1cfa		       1c		      .byte.b	28
      0  1cfb					      dw	EXPR
      1  1cfb		       c0 1b		      .word.w	EXPR
      0  1cfd					      TST	UNKNOWNVEC,COMMA
      0  1cfd					      db	32
      1  1cfd		       20		      .byte.b	32
      0  1cfe					      db	(UNKNOWNVEC-*)-1
      1  1cfe		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cff					      db	COMMA,0
      1  1cff		       2c 00		      .byte.b	COMMA,0
      0  1d01					      CALL	EXPR	;Get pid of task to send to
      0  1d01					      db	28
      1  1d01		       1c		      .byte.b	28
      0  1d02					      dw	EXPR
      1  1d02		       c0 1b		      .word.w	EXPR
      0  1d04					      TST	UNKNOWNVEC,")"
      0  1d04					      db	32
      1  1d04		       20		      .byte.b	32
      0  1d05					      db	(UNKNOWNVEC-*)-1
      1  1d05		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d06					      db	")",0
      1  1d06		       29 00		      .byte.b	")",0
      0  1d08					      IPCSEND		;Send msg and clear pid msg pending
      0  1d08					      db	80
      1  1d08		       50		      .byte.b	80
      0  1d09					      RTN
      0  1d09					      db	25
      1  1d09		       19		      .byte.b	25
    647  1d0a							;================================================================================
    648  1d0a							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    649  1d0a							;
    650  1d0a				   F2AZa
      0  1d0a					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  1d0a					      db	32
      1  1d0a		       20		      .byte.b	32
      0  1d0b					      db	(F2AZb-*)-1
      1  1d0b		       16		      .byte.b	(F2AZb-*)-1
      0  1d0c					      db	"R(",0
      1  1d0c		       52 28 00 	      .byte.b	"R(",0
      0  1d0f					      TST	F2AZa1,")"
      0  1d0f					      db	32
      1  1d0f		       20		      .byte.b	32
      0  1d10					      db	(F2AZa1-*)-1
      1  1d10		       08		      .byte.b	(F2AZa1-*)-1
      0  1d11					      db	")",0
      1  1d11		       29 00		      .byte.b	")",0
      0  1d13					      LIT	0	;We dont want the pid returned to us
      0  1d13					      db	27
      1  1d13		       1b		      .byte.b	27
      0  1d14					      dw	0
      1  1d14		       00 00		      .word.w	0
      0  1d16					      IPCIO		;Set the io bit and suspend the task till message
      0  1d16					      db	83
      1  1d16		       53		      .byte.b	83
      0  1d17					      IPCRECEIVE		;Get the message
      0  1d17					      db	81
      1  1d17		       51		      .byte.b	81
      0  1d18					      RTN
      0  1d18					      db	25
      1  1d18		       19		      .byte.b	25
    657  1d19				   F2AZa1
      0  1d19					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  1d19					      db	33
      1  1d19		       21		      .byte.b	33
      0  1d1a					      db	(UNKNOWNVEC-*)-1
      1  1d1a		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d1b					      TST	UNKNOWNVEC,")"
      0  1d1b					      db	32
      1  1d1b		       20		      .byte.b	32
      0  1d1c					      db	(UNKNOWNVEC-*)-1
      1  1d1c		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d1d					      db	")",0
      1  1d1d		       29 00		      .byte.b	")",0
      0  1d1f					      IPCIO		;Set the io bit and exit task till message
      0  1d1f					      db	83
      1  1d1f		       53		      .byte.b	83
      0  1d20					      IPCRECEIVE		;Get the message
      0  1d20					      db	81
      1  1d20		       51		      .byte.b	81
      0  1d21					      RTN
      0  1d21					      db	25
      1  1d21		       19		      .byte.b	25
    663  1d22							;===============================================================================
    664  1d22							; IPCC ---- check if a message is available
    665  1d22				   F2AZb
      0  1d22					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  1d22					      db	32
      1  1d22		       20		      .byte.b	32
      0  1d23					      db	(UNKNOWNVEC-*)-1
      1  1d23		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d24					      db	"C()",0
      1  1d24		       43 28 29 00	      .byte.b	"C()",0
      0  1d28					      IPCCHECK
      0  1d28					      db	82
      1  1d28		       52		      .byte.b	82
      0  1d29					      RTN
      0  1d29					      db	25
      1  1d29		       19		      .byte.b	25
    669  1d2a
    670  1d2a				   UNKNOWNID
      0  1d2a					      IJMP	UNKNOWN
      0  1d2a					      db	29
      1  1d2a		       1d		      .byte.b	29
      0  1d2b					      dw	UNKNOWN
      1  1d2b		       bc 1b		      .word.w	UNKNOWN
    672  1d2d							;============================================================
    673  1d2d							; RND() is supposed to have an argument but if none
    674  1d2d							; was provided, just assume a large value.
    675  1d2d							;
    676  1d2d				   F2A
      0  1d2d					      TST	F2B,"RND("
      0  1d2d					      db	32
      1  1d2d		       20		      .byte.b	32
      0  1d2e					      db	(F2B-*)-1
      1  1d2e		       17		      .byte.b	(F2B-*)-1
      0  1d2f					      db	"RND(",0
      1  1d2f		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1d34					      TST	F2A1,")"
      0  1d34					      db	32
      1  1d34		       20		      .byte.b	32
      0  1d35					      db	(F2A1-*)-1
      1  1d35		       07		      .byte.b	(F2A1-*)-1
      0  1d36					      db	")",0
      1  1d36		       29 00		      .byte.b	")",0
      0  1d38					      LIT	32766
      0  1d38					      db	27
      1  1d38		       1b		      .byte.b	27
      0  1d39					      dw	32766
      1  1d39		       fe 7f		      .word.w	32766
      0  1d3b					      RANDOM
      0  1d3b					      db	37
      1  1d3b		       25		      .byte.b	37
      0  1d3c					      RTN
      0  1d3c					      db	25
      1  1d3c		       19		      .byte.b	25
    682  1d3d
    683  1d3d				   F2A1
      0  1d3d					      CALL	FACT	;GET RANGE
      0  1d3d					      db	28
      1  1d3d		       1c		      .byte.b	28
      0  1d3e					      dw	FACT
      1  1d3e		       8c 1c		      .word.w	FACT
      0  1d40					      TST	UNKNOWNVEC,")"
      0  1d40					      db	32
      1  1d40		       20		      .byte.b	32
      0  1d41					      db	(UNKNOWNVEC-*)-1
      1  1d41		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d42					      db	")",0
      1  1d42		       29 00		      .byte.b	")",0
      0  1d44					      RANDOM
      0  1d44					      db	37
      1  1d44		       25		      .byte.b	37
      0  1d45					      RTN
      0  1d45					      db	25
      1  1d45		       19		      .byte.b	25
    688  1d46							;==========================================================
    689  1d46							;	Return absolute value of expresion
    690  1d46							;
    691  1d46				   F2B
      0  1d46					      TST	F2B2,"ABS("
      0  1d46					      db	32
      1  1d46		       20		      .byte.b	32
      0  1d47					      db	(F2B2-*)-1
      1  1d47		       0e		      .byte.b	(F2B2-*)-1
      0  1d48					      db	"ABS(",0
      1  1d48		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1d4d					      CALL	EXPR	;get value
      0  1d4d					      db	28
      1  1d4d		       1c		      .byte.b	28
      0  1d4e					      dw	EXPR
      1  1d4e		       c0 1b		      .word.w	EXPR
      0  1d50					      TST	UNKNOWNVEC,")"
      0  1d50					      db	32
      1  1d50		       20		      .byte.b	32
      0  1d51					      db	(UNKNOWNVEC-*)-1
      1  1d51		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d52					      db	")",0
      1  1d52		       29 00		      .byte.b	")",0
      0  1d54					      ABS
      0  1d54					      db	38
      1  1d54		       26		      .byte.b	38
      0  1d55					      RTN
      0  1d55					      db	25
      1  1d55		       19		      .byte.b	25
    697  1d56							;============================================================
    698  1d56							;     Return the the status of a task, provide the PID
    699  1d56							;
    700  1d56				   F2B2
      0  1d56					      TST	F2Z,"STAT("
      0  1d56					      db	32
      1  1d56		       20		      .byte.b	32
      0  1d57					      db	(F2Z-*)-1
      1  1d57		       0f		      .byte.b	(F2Z-*)-1
      0  1d58					      db	"STAT(",0
      1  1d58		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1d5e					      Call	EXPR
      0  1d5e					      db	28
      1  1d5e		       1c		      .byte.b	28
      0  1d5f					      dw	EXPR
      1  1d5f		       c0 1b		      .word.w	EXPR
      0  1d61					      TST	UNKNOWNVEC,")"
      0  1d61					      db	32
      1  1d61		       20		      .byte.b	32
      0  1d62					      db	(UNKNOWNVEC-*)-1
      1  1d62		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d63					      db	")",0
      1  1d63		       29 00		      .byte.b	")",0
      0  1d65					      TASKSTAT
      0  1d65					      db	66
      1  1d65		       42		      .byte.b	66
      0  1d66					      RTN
      0  1d66					      db	25
      1  1d66		       19		      .byte.b	25
    706  1d67				   F2Z
      0  1d67					      TST	F2ZA,"PID"
      0  1d67					      db	32
      1  1d67		       20		      .byte.b	32
      0  1d68					      db	(F2ZA-*)-1
      1  1d68		       06		      .byte.b	(F2ZA-*)-1
      0  1d69					      db	"PID",0
      1  1d69		       50 49 44 00	      .byte.b	"PID",0
      0  1d6d					      TASKPID
      0  1d6d					      db	77
      1  1d6d		       4d		      .byte.b	77
      0  1d6e					      RTN
      0  1d6e					      db	25
      1  1d6e		       19		      .byte.b	25
    710  1d6f							;===========================================================================
    711  1d6f							; Call a machine function, provide the address to call and optionally
    712  1d6f							; the value to be passed in reg A
    713  1d6f				   F2ZA
      0  1d6f					      TST	F2FUNC,"CALL("	;call machine function
      0  1d6f					      db	32
      1  1d6f		       20		      .byte.b	32
      0  1d70					      db	(F2FUNC-*)-1
      1  1d70		       1f		      .byte.b	(F2FUNC-*)-1
      0  1d71					      db	"CALL(",0
      1  1d71		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1d77					      CALL	EXPR
      0  1d77					      db	28
      1  1d77		       1c		      .byte.b	28
      0  1d78					      dw	EXPR
      1  1d78		       c0 1b		      .word.w	EXPR
      0  1d7a					      TST	F2B2A,COMMA
      0  1d7a					      db	32
      1  1d7a		       20		      .byte.b	32
      0  1d7b					      db	(F2B2A-*)-1
      1  1d7b		       0b		      .byte.b	(F2B2A-*)-1
      0  1d7c					      db	COMMA,0
      1  1d7c		       2c 00		      .byte.b	COMMA,0
      0  1d7e					      CALL	EXPR
      0  1d7e					      db	28
      1  1d7e		       1c		      .byte.b	28
      0  1d7f					      dw	EXPR
      1  1d7f		       c0 1b		      .word.w	EXPR
      0  1d81					      TST	UNKNOWNVEC,")"
      0  1d81					      db	32
      1  1d81		       20		      .byte.b	32
      0  1d82					      db	(UNKNOWNVEC-*)-1
      1  1d82		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d83					      db	")",0
      1  1d83		       29 00		      .byte.b	")",0
      0  1d85					      CALLFUNC
      0  1d85					      db	53
      1  1d85		       35		      .byte.b	53
      0  1d86					      RTN
      0  1d86					      db	25
      1  1d86		       19		      .byte.b	25
    721  1d87							; Run the gosub within this function
    722  1d87				   F2B2A
      0  1d87					      TST	UNKNOWNID,")"
      0  1d87					      db	32
      1  1d87		       20		      .byte.b	32
      0  1d88					      db	(UNKNOWNID-*)-1
      1  1d88		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  1d89					      db	")",0
      1  1d89		       29 00		      .byte.b	")",0
      0  1d8b					      LIT	0	; No parameter passed so just load zero to A
      0  1d8b					      db	27
      1  1d8b		       1b		      .byte.b	27
      0  1d8c					      dw	0
      1  1d8c		       00 00		      .word.w	0
      0  1d8e					      CALLFUNC
      0  1d8e					      db	53
      1  1d8e		       35		      .byte.b	53
      0  1d8f					      RTN
      0  1d8f					      db	25
      1  1d8f		       19		      .byte.b	25
    727  1d90							;===========================================================================
    728  1d90							; Same as gosub but expects a return value
    729  1d90							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    730  1d90							;
      0  1d90				   F2FUNC     TST	F2C,"GOFN"
      0  1d90					      db	32
      1  1d90		       20		      .byte.b	32
      0  1d91					      db	(F2C-*)-1
      1  1d91		       0c		      .byte.b	(F2C-*)-1
      0  1d92					      db	"GOFN",0
      1  1d92		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  1d97					      Call	GOSUBSTATEMENT
      0  1d97					      db	28
      1  1d97		       1c		      .byte.b	28
      0  1d98					      dw	GOSUBSTATEMENT
      1  1d98		       c7 1d		      .word.w	GOSUBSTATEMENT
      0  1d9a					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  1d9a					      db	8
      1  1d9a		       08		      .byte.b	8
      0  1d9b					      db	GOSUB_RTN_VALUE
      1  1d9b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  1d9c					      XFER
      0  1d9c					      db	7
      1  1d9c		       07		      .byte.b	7
    735  1d9d				   GOFNRet
      0  1d9d					      RTN
      0  1d9d					      db	25
      1  1d9d		       19		      .byte.b	25
    737  1d9e							;=============================================================================
    738  1d9e							; See if this is just a simple variable
    739  1d9e							;  Allow a subscript for any variable
    740  1d9e							;
    741  1d9e				   F2C
      0  1d9e					      TSTV	F0
      0  1d9e					      db	33
      1  1d9e		       21		      .byte.b	33
      0  1d9f					      db	(F0-*)-1
      1  1d9f		       15		      .byte.b	(F0-*)-1
      0  1da0					      TST	F2CLocalTask,"!"
      0  1da0					      db	32
      1  1da0		       20		      .byte.b	32
      0  1da1					      db	(F2CLocalTask-*)-1
      1  1da1		       05		      .byte.b	(F2CLocalTask-*)-1
      0  1da2					      db	"!",0
      1  1da2		       21 00		      .byte.b	"!",0
      0  1da4					      IND		; we just got a pid
      0  1da4					      db	20
      1  1da4		       14		      .byte.b	20
      0  1da5					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  1da5					      db	93
      1  1da5		       5d		      .byte.b	93
      0  1da6					      db	(UNKNOWNID-*)-1
      1  1da6		       83		      .byte.b	(UNKNOWNID-*)-1
    746  1da7
    747  1da7				   F2CLocalTask
      0  1da7					      TST	F2C1,"["
      0  1da7					      db	32
      1  1da7		       20		      .byte.b	32
      0  1da8					      db	(F2C1-*)-1
      1  1da8		       0a		      .byte.b	(F2C1-*)-1
      0  1da9					      db	"[",0
      1  1da9		       5b 00		      .byte.b	"[",0
      0  1dab					      CALL	EXPR
      0  1dab					      db	28
      1  1dab		       1c		      .byte.b	28
      0  1dac					      dw	EXPR
      1  1dac		       c0 1b		      .word.w	EXPR
      0  1dae					      TST	UNKNOWNID,"]"
      0  1dae					      db	32
      1  1dae		       20		      .byte.b	32
      0  1daf					      db	(UNKNOWNID-*)-1
      1  1daf		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  1db0					      db	"]",0
      1  1db0		       5d 00		      .byte.b	"]",0
      0  1db2					      SUBSCRIPT
      0  1db2					      db	64
      1  1db2		       40		      .byte.b	64
    752  1db3				   F2C1
      0  1db3					      IND		;YES, GET THE VALUE.
      0  1db3					      db	20
      1  1db3		       14		      .byte.b	20
      0  1db4					      RTN
      0  1db4					      db	25
      1  1db4		       19		      .byte.b	25
    755  1db5							;=================================================================================
    756  1db5							;Finally check for a number !
    757  1db5							;
    758  1db5				   F0
      0  1db5					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1db5					      db	35
      1  1db5		       23		      .byte.b	35
      0  1db6					      db	(F1-*)-1
      1  1db6		       01		      .byte.b	(F1-*)-1
      0  1db7					      RTN
      0  1db7					      db	25
      1  1db7		       19		      .byte.b	25
    761  1db8				   F1
      0  1db8					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  1db8					      db	32
      1  1db8		       20		      .byte.b	32
      0  1db9					      db	(F2RTN-*)-1
      1  1db9		       09		      .byte.b	(F2RTN-*)-1
      0  1dba					      db	"(",0
      1  1dba		       28 00		      .byte.b	"(",0
      0  1dbc					      CALL	EXPR
      0  1dbc					      db	28
      1  1dbc		       1c		      .byte.b	28
      0  1dbd					      dw	EXPR
      1  1dbd		       c0 1b		      .word.w	EXPR
      0  1dbf					      TST	F2,")"
      0  1dbf					      db	32
      1  1dbf		       20		      .byte.b	32
      0  1dc0					      db	(F2-*)-1
      1  1dc0		       03		      .byte.b	(F2-*)-1
      0  1dc1					      db	")",0
      1  1dc1		       29 00		      .byte.b	")",0
    765  1dc3				   F2RTN
      0  1dc3					      RTN
      0  1dc3					      db	25
      1  1dc3		       19		      .byte.b	25
    767  1dc4
    768  1dc4				   F2
      0  1dc4					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1dc4					      db	13
      1  1dc4		       0d		      .byte.b	13
      0  1dc5					      dw	ERR_SYNTAX
      1  1dc5		       05 00		      .word.w	ERR_SYNTAX
    770  1dc7							;
    771  1dc7							;=============================================================
    772  1dc7							; Gosub can be both a Function and a Subroutine
    773  1dc7				   GOSUBSTATEMENT
      0  1dc7					      CALL	EXPR	;GET DESTINATION
      0  1dc7					      db	28
      1  1dc7		       1c		      .byte.b	28
      0  1dc8					      dw	EXPR
      1  1dc8		       c0 1b		      .word.w	EXPR
      0  1dca					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  1dca					      db	32
      1  1dca		       20		      .byte.b	32
      0  1dcb					      db	(GOSUBDONE-*)-1
      1  1dcb		       14		      .byte.b	(GOSUBDONE-*)-1
      0  1dcc					      db	"(",0
      1  1dcc		       28 00		      .byte.b	"(",0
      0  1dce					      STK2TMP		;Transfer stack top to temp
      0  1dce					      db	95
      1  1dce		       5f		      .byte.b	95
      0  1dcf					      PUSHMATHSTACK		;Record stack frame for return
      0  1dcf					      db	84
      1  1dcf		       54		      .byte.b	84
    778  1dd0				   GOSUBLOOP
      0  1dd0					      CALL	EXPR	; Allows what ever fits onto stack
      0  1dd0					      db	28
      1  1dd0		       1c		      .byte.b	28
      0  1dd1					      dw	EXPR
      1  1dd1		       c0 1b		      .word.w	EXPR
      0  1dd3					      INCPARMCOUNT
      0  1dd3					      db	88
      1  1dd3		       58		      .byte.b	88
      0  1dd4					      TST	GOSUBParmDONE,COMMA
      0  1dd4					      db	32
      1  1dd4		       20		      .byte.b	32
      0  1dd5					      db	(GOSUBParmDONE-*)-1
      1  1dd5		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  1dd6					      db	COMMA,0
      1  1dd6		       2c 00		      .byte.b	COMMA,0
      0  1dd8					      IJMP	GOSUBLOOP
      0  1dd8					      db	29
      1  1dd8		       1d		      .byte.b	29
      0  1dd9					      dw	GOSUBLOOP
      1  1dd9		       d0 1d		      .word.w	GOSUBLOOP
    783  1ddb				   GOSUBParmDONE
      0  1ddb					      TST	F2,")"
      0  1ddb					      db	32
      1  1ddb		       20		      .byte.b	32
      0  1ddc					      db	(F2-*)-1
      1  1ddc		       e7		      .byte.b	(F2-*)-1
      0  1ddd					      db	")",0
      1  1ddd		       29 00		      .byte.b	")",0
      0  1ddf					      TMP2STK		;Restore line to goto
      0  1ddf					      db	96
      1  1ddf		       60		      .byte.b	96
    786  1de0				   GOSUBDONE
      0  1de0					      RTN
      0  1de0					      db	25
      1  1de0		       19		      .byte.b	25
    788  1de1
    789  1de1		       1d e1	   ILEND      equ	*
------- FILE mytb.asm
   2218  1de1		       1d e1	   PROGEND    equ	*
   2219  1de1
   2220  1de1
   2221  1de1							;=====================================================
   2222  1de1							; Define start of non page zero data
   2223 U1df1					      seg.u	TBData
   2224 U1df1
   2225 U1df1							;=====================================================
   2226 U1df1							; These are storage items not in page zero.
   2227 U1df1							;
   2228 U1df1							; IRQ BASIC Code Service RTN Support
      0 U1df1				   SaveIrqReg db	0	; Store current setting
      1 U1df1		       00		      .byte.b	0
      0 U1df2				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1df2		       00		      .byte.b	0
      0 U1df3				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1df3		       00		      .byte.b	0
      0 U1df4				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1df4		       00 00		      .byte.b	0,0
   2233 U1df6
   2234 U1df6							;
   2235 U1df6							;==================================================================================================
   2236 U1df6							; Task Management information
   2237 U1df6							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2238 U1df6							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2239 U1df6							; Task switchs happen at the beginning of the next Basic command line
   2240 U1df6							; It will not happen during an input or output operations
   2241 U1df6							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2242 U1df6							; Task Zero is always the root task, main line program
   2243 U1df6							;
   2244 U1df6							; Layout is repeated for each configured task
   2245 U1df6							; Task Table Byte   use masks follow
   2246 U1df6		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2247 U1df6		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2248 U1df6		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2249 U1df6		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2250 U1df6		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2251 U1df6
   2252 U1df6		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2253 U1df7		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2254 U1df7		       1e f1	   TASKTABLEEND equ	*	; End of task table
   2255 U1df7		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2256 U1ef1
   2257 U1ef1							;Task Cycle Counter and reset count
   2258 U1ef1		       00 00	   taskCurrentCycles ds	2
   2259 U1ef3		       00 00	   taskResetValue ds	2
   2260 U1ef5		       00	   taskCounter ds	1	; Count of active tasks
   2261 U1ef6
   2262 U1ef6							;
   2263 U1ef6							; Math stack and IL call and Gosub/For-next return stack definitions
   2264 U1ef6							;
   2265 U1ef6		       1e f6	   STACKSTART equ	*
   2266 U1ef6		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2267 U2086		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2268 U2216		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2269 U2496		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2270 U2496		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2271 U2496		       26 b2	   STACKEND   equ	*
   2272 U2496		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2273 U26b2							;
   2274 U26b2							;
   2275 U26b2		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2276 U2736		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2277 U2737		       00	   printtx    ds	1	;temp X for print funcs
   2278 U2738		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2279 U2739		       00	   promptChar ds	1	;the character to use for a prompt
   2280 U273a		       00	   diddigit   ds	1	;for leading zero suppression
   2281 U273b		       00	   putsy      ds	1
   2282 U273c		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2283 U273e		       00	   sign       ds	1	;0 = positive, else negative
   2284 U273f		       00 00	   rtemp1     ds	2	;Temp for x and y
   2285 U2741		       00 00	   random     ds	2
   2286 U2743		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2287 U2745		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2288 U2747		       00	   tempy      ds	1	;temp y storage
   2289 U2748
   2290 U2748							; Moved from page zero as one clock cycle diff gives more space on page zero
   2291 U2748		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2292 U274a		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2293 U274b		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2294 U274c		       00	   lineLength ds	1	;Length of current line
   2295 U274d
   2296 U274d		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2297 U274e		       00	   taskRDPending ds	1	; 1 = background read is pending
   2298 U274f
   2299 U274f				  -	      if	XKIM
   2300 U274f				  -buffer     ds	BUFFER_SIZE
   2301 U274f					      endif
   2302 U274f							;
   2303 U274f							; PROGRAMEND is the end of the user's BASIC program.
   2304 U274f							; More precisely, it is one byte past the end.  Or,
   2305 U274f							; it's where the next line added to the end will be
   2306 U274f							; placed.
   2307 U274f							;
   2308 U274f		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2309 U2751		       00 00	   ProgramEnd ds	2	; End of users basic program
   2310 U2753		       00 00	   HighMem    ds	2	; highest location
   2311 U2755		       00 00	   UsedMem    ds	2	; size of user program
   2312 U2757		       00 00	   FreeMem    ds	2	; amount of free memory
   2313 U2759							;
   2314 U2759							;=====================================================
   2315 U2759							; This is the start of the user's BASIC program space.
   2316 U2759							;
   2317 U2759							; PERSONAL GOAL: This should be no larger than $0DFF.
   2318 U2759							;		  0200-05FF = 1K
   2319 U2759							;		  0200-09FF = 2K
   2320 U2759							;		  0200-0DFF = 3K
   2321 U2759							;		  0200-11FF = 4K
   2322 U2759							;		  0200-13FF = 4.5K
   2323 U2759							;
   2324 U2759				  -	      if	FIXED
   2325 U2759				  -	      org	$2000
   2326 U2759					      endif
   2327 U2759
   2328 U2759		       27 59	   FreeMemStart equ	*
   2329 U2759							;/*
   2330 U2759							;	if	CTMON65 || XKIM
   2331 U2759							;		SEG Code
   2332 U2759							;		org	AutoRun
   2333 U2759							;		dw	TBasicCold
   2334 U2759							;	endif
   2335 U2759							;*/
   2336 U2759					      end
