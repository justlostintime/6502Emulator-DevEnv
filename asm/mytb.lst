------- FILE mytb.asm LEVEL 1 PASS 4
      1 U1139				   input      processor	6502
      2 U1139 ????						;=====================================================
      3 U1139 ????						; Bob's Tiny BASIC
      4 U1139 ????						;
      5 U1139 ????						; While working on the Corsham Technologies KIM Clone
      6 U1139 ????						; project, I wanted to include a TINY BASIC since that
      7 U1139 ????						; was a highly desirable feature of early computers.
      8 U1139 ????						;
      9 U1139 ????						; Rather than negotiating copyright issues for
     10 U1139 ????						; existing BASICs, I decided to just write one from
     11 U1139 ????						; scratch.
     12 U1139 ????						;
     13 U1139 ????						; 10/07/2017
     14 U1139 ????						;
     15 U1139 ????						; This implements a stripped down Tiny BASIC
     16 U1139 ????						; interpreter using the Interpretive Language (IL)
     17 U1139 ????						; method as described in the first few issues of
     18 U1139 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1139 ????						; to write various languages simply by changing the
     20 U1139 ????						; IL code rather than the interpreter itself.
     21 U1139 ????						;
     22 U1139 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1139 ????						;		* Fxed major bug in findLine that
     24 U1139 ????						;		  caused corrupted lines, crashes, etc.
     25 U1139 ????						;		* If no parameter given to RND, assume
     26 U1139 ????						;		  32766.
     27 U1139 ????						;		* No more error 5 when a program
     28 U1139 ????						;		  reaches the end without an END.
     29 U1139 ????						;
     30 U1139 ????						; www.corshamtech.com
     31 U1139 ????						; bob@corshamtech.com
     32 U1139 ????						;
     33 U1139 ????						;=====================================================
     34 U1139 ????						;
     35 U1139 ????						; Create TRUE and FALSE values for conditionals.
     36 U1139 ????						;
     37 U1139 ????
     38 U1139 ????	       00 00	   FALSE      equ	0
     39 U1139 ????	       ff ff ff ff TRUE       equ	~FALSE
     40 U1139 ????						;
     41 U1139 ????						;---------------------------------------------------------
     42 U1139 ????						; One of these must be set to indicate which environment
     43 U1139 ????						; Tiny BASIC will be running in.  Here are the current
     44 U1139 ????						; environments:
     45 U1139 ????						;
     46 U1139 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     47 U1139 ????						; more K of RAM.
     48 U1139 ????						;
     49 U1139 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     50 U1139 ????						; which enhances, without replacing, the standard KIM
     51 U1139 ????						; monitor.  It gives access to routines to save/load files
     52 U1139 ????						; to a micro SD card.
     53 U1139 ????						;
     54 U1139 ????						; CTMON65 is a from-scratch monitor written for the
     55 U1139 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     56 U1139 ????						; easily be ported to other systems.  It has support for
     57 U1139 ????						; using a micro SD card for file storage/retrieval.
     58 U1139 ????						;
     59 U1139 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     60 U1139 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     61 U1139 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     62 U1139 ????						;
     63 U1139 ????						;   Need to define some macros for the dasm assembler
     64 U1139 ????						;
     65 U1139 ????				      MACRO	dw
     66 U1139 ????				      .word	{0}
     67 U1139 ????				      ENDM
     68 U1139 ????
     69 U1139 ????				      MACRO	db
     70 U1139 ????				      .byte	{0}
     71 U1139 ????				      ENDM
     72 U1139 ????
     73 U1139 ????						;
     74 U1139 ????						; If set, include disk functions.
     75 U1139 ????						;
     76 U1139 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     77 U1139 ????						;
     78 U1139 ????						; If ILTRACE is set then dump out the address of every
     79 U1139 ????						; IL opcode before executing it.
     80 U1139 ????						;
     81 U1139 ????	       00 00	   ILTRACE    equ	FALSE
     82 U1139 ????						;
     83 U1139 ????						; If FIXED is set, put the IL code and the user
     84 U1139 ????						; program space at fixed locations in memory.	This is
     85 U1139 ????						; meant only for debugging.
     86 U1139 ????						;
     87 U1139 ????	       00 00	   FIXED      equ	FALSE
     88 U1139 ????						;
     89 U1139 ????						; Sets the arithmetic stack depth.  This is *TINY*
     90 U1139 ????						; BASIC, so keep this small!
     91 U1139 ????						;
     92 U1139 ????	       00 08	   STACKSIZE  equ	8	;number of entries
     93 U1139 ????	       00 0a	   GOSUBSTACKSIZE equ	10	;Depth of gosub nesting
     94 U1139 ????						;
     95 U1139 ????						; Common ASCII constants
     96 U1139 ????						;
     97 U1139 ????	       00 07	   BEL	      equ	$07
     98 U1139 ????	       00 08	   BS	      equ	$08
     99 U1139 ????	       00 09	   TAB	      equ	$09
    100 U1139 ????	       00 0a	   LF	      equ	$0A
    101 U1139 ????	       00 0d	   CR	      equ	$0D
    102 U1139 ????	       00 22	   QUOTE      equ	$22
    103 U1139 ????	       00 20	   SPACE      equ	$20
    104 U1139 ????	       00 2c	   COMMA      equ	',
    105 U1139 ????	       00 3b	   SEMICOLON  equ	';
    106 U1139 ????						;
    107 U1139 ????						; These are error codes
    108 U1139 ????						;
    109 U1139 ????	       00 00	   ERR_NONE   equ	0
    110 U1139 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    111 U1139 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    112 U1139 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    113 U1139 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    114 U1139 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    115 U1139 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    116 U1139 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    117 U1139 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    118 U1139 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    119 U1139 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    120 U1139 ????						;
    121 U1139 ????						;=====================================================
    122 U1139 ????						; Zero page storage.
    123 U1139 ????						;
    124 Udf9e ????				      SEG.U	bss
    125 U0040					      org	$0040
    126 U0040
    127 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    128 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    129 U0041		       00 75	   variablesEnd equ	*
    130 U0075		       00 00	   ILPC       ds	2	;IL program counter
    131 U0077		       00 00	   dpl	      ds	2
    132 U0079		       00 00	   tempIL     ds	2
    133 U007b		       00	   tempIlY    ds	1
    134 U007c		       00	   offset     ds	1
    135 U007d		       00	   lineLength ds	1
    136 U007e							;
    137 U007e							; CURPTR is a pointer to curent BASIC line being
    138 U007e							; executed.  Always points to start of line, CUROFF
    139 U007e							; is the offset to the current character.
    140 U007e							;
    141 U007e		       00 00	   CURPTR     ds	2
    142 U0080		       00	   CUROFF     ds	1
    143 U0081							;
    144 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    145 U0083							;
    146 U0083
    147 U0083							;
    148 U0083							; R0 and R1 are used for arithmetic operations and
    149 U0083							; general use.
    150 U0083							;
    151 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    152 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    153 U0087							;
    154 U0087							; This is zero if in immediate mode, or non-zero
    155 U0087							; if currently running a program.  Any input from
    156 U0087							; the main loop clears this, and the XFER IL
    157 U0087							; statement will set it.
    158 U0087							;
    159 U0087		       00	   RunMode    ds	1
    160 U0088							;
    161 U0088							; Used for line insertion/removal.
    162 U0088							;
    163 U0088		       00 00	   FROM       ds	2
    164 U008a
    165 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    166 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    167 U008a							;
    168 U008a		       00 88	   PrtFrom    EQU	FROM
    169 U008a							;
    170 U008a							;=====================================================
    171 U008a							;
    172  107c ????				      SEG	code
    173  0200					      org	$0200
    174  0200							;
    175  0200							; Cold start is at $0200.  Warm start is at $0203.
    176  0200							;
    177  0200		       4c 15 02    TBasicCold jmp	cold2	;jump around vectors
    178  0203		       4c 99 02    warm       jmp	warm2
    179  0206							;
    180  0206							; These are the user-supplied vectors to I/O routines.
    181  0206							; If you want, you can just patch these in the binary
    182  0206							; file, but it would be better to change the source
    183  0206							; code.
    184  0206							;
    185  0206				  -	      if	KIM
    186  0206				  -OUTCH      jmp	$1ea0	;output char in A
    187  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    188  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    189  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    190  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    191  0206					      endif
    192  0206				  -	      if	XKIM
    193  0206				  -	      include	"xkim.inc"
    194  0206				  -	      SEG	code
    195  0206				  -OUTCH      jmp	$1ea0
    196  0206				  -GETCH      jmp	xkGETCH
    197  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    198  0206				  -OUTHEX     jmp	xkPRTBYT
    199  0206				  -MONITOR    jmp	extKIM
    200  0206				  -puts       equ	putsil
    201  0206				  -BUFFER_SIZE equ	132
    202  0206					      endif
    203  0206
    204  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							;
     11 Uf048 ????				      SEG.U	rom
     12 Uf000					      org	ROM_START
     13 Uf000							;
     14 Uf000							;=========================================================
     15 Uf000							; Jump table to common functions.  The entries in this
     16 Uf000							; table are used by external programs, so nothing can be
     17 Uf000							; moved or removed from this table.  New entries always
     18 Uf000							; go at the end.  Many of these are internal functions
     19 Uf000							; and I figured they might be handy for others.
     20 Uf000							;
     21 Uf000		       00 00 00    RESET      ds	3
     22 Uf003		       00 00 00    WARM       ds	3
     23 Uf006							;
     24 Uf006							; These are the major and minor revision numbers so that
     25 Uf006							; code can check to see which CTMON65 version is running.
     26 Uf006							;
     27 Uf006		       00	   CTMON65ver ds	1
     28 Uf007		       00	   CTMON65rev ds	1
     29 Uf008		       00		      ds	1	;unused
     30 Uf009							;
     31 Uf009							; Console related functions
     32 Uf009							;
     33 Uf009		       00 00 00    cin	      ds	3
     34 Uf00c		       00 00 00    cout       ds	3
     35 Uf00f		       00 00 00    cstatus    ds	3
     36 Uf012		       00 00 00    putsil     ds	3
     37 Uf015		       00 00 00    getline    ds	3
     38 Uf018		       00 00 00    crlf       ds	3
     39 Uf01b		       00 00 00    HexA       ds	3
     40 Uf01e							;
     41 Uf01e							; Low-level functions to access the SD card system
     42 Uf01e							;
     43 Uf01e					      if	SD_ENABLED	;SD ENABLED
     44 Uf01e		       00 00 00    xParInit   ds	3
     45 Uf021		       00 00 00    xParSetWrite ds	3
     46 Uf024		       00 00 00    xParSetRead ds	3
     47 Uf027		       00 00 00    xParWriteByte ds	3
     48 Uf02a		       00 00 00    xParReadByte ds	3
     49 Uf02d							;
     50 Uf02d							; Higher level SD card functions
     51 Uf02d							;
     52 Uf02d		       00 00 00    DiskPing   ds	3
     53 Uf030		       00 00 00    DiskDir    ds	3
     54 Uf033		       00 00 00    DiskDirNext ds	3
     55 Uf036		       00 00 00    DiskOpenRead ds	3
     56 Uf039		       00 00 00    DiskOpenWrite ds	3
     57 Uf03c		       00 00 00    DiskRead   ds	3
     58 Uf03f		       00 00 00    DiskWrite  ds	3
     59 Uf042		       00 00 00    DiskClose  ds	3
     60 Uf045		       00 00 00    DiskRmFile ds	3
     61 Uf048					      endif		;SD_ENABLED
     62 Uf048
     63 Uf048							;
     64 U008a					      SEG.U	bss
     65 Udf00					      org	RAM_START
     66 Udf00							;
     67 Udf00							; The use of memory starting from here will remain
     68 Udf00							; constant through different versions of CTMON65.
     69 Udf00							;
     70 Udf00		       00 00	   IRQvec     ds	2
     71 Udf02		       00 00	   NMIvec     ds	2
     72 Udf04							;
     73 Udf04							; Before a L(oad) command, these are set to $FF.
     74 Udf04							; After loading, if they are different, jump to
     75 Udf04							; that address.
     76 Udf04							;
     77 Udf04		       00 00	   AutoRun    ds	2
     78 Udf06							;
     79 Udf06							; Pointer to the subroutine that gets the next input
     80 Udf06							; character.  Used for doing disk/console input.
     81 Udf06							;
     82 Udf06		       00 00	   inputVector ds	2
     83 Udf08							;
     84 Udf08							; Same thing for output.
     85 Udf08							;
     86 Udf08		       00 00	   outputVector ds	2
     87 Udf0a							;
     88 Udf0a							; Buffer for GETLINE
     89 Udf0a							;
     90 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    206  0206					      SEG	code
    207  0206
    208  0206		       4c 0c f0    OUTCH      jmp	cout
    209  0209		       4c 09 f0    GETCH      jmp	cin
    210  020c		       4c 18 f0    CRLF       jmp	crlf
    211  020f		       4c 1b f0    OUTHEX     jmp	HexA
    212  0212		       4c 03 f0    MONITOR    jmp	WARM
    213  0212		       f0 12	   puts       equ	putsil
    214  0215					      endif
    215  0215							;
    216  0215		       20 12 f0    cold2      jsr	puts
      0  0218					      db	CR,LF
      1  0218		       0d 0a		      .byte.b	CR,LF
      0  021a					      db	"Bob's Tiny BASIC v1.0.1"
      1  021a		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.1"
      0  0231					      db	CR,LF
      1  0231		       0d 0a		      .byte.b	CR,LF
      0  0233					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  0233		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0261					      db	CR,LF,0
      1  0261		       0d 0a 00 	      .byte.b	CR,LF,0
    222  0264							;
    223  0264		       20 5d 0c 	      jsr	GetSizes	;setup the free space available
    224  0267		       ad 33 11 	      lda	HighMem
    225  026a		       e9 14		      sbc	#GOSUBSTACKSIZE*2
    226  026c		       85 81		      sta	GOSUBSTACK
    227  026e		       ad 34 11 	      lda	HighMem+1
    228  0271		       e9 00		      sbc	#0
    229  0273		       85 82		      sta	GOSUBSTACK+1
    230  0275		       a9 fb		      lda	#IL&$ff
    231  0277		       85 75		      sta	ILPC
    232  0279		       a9 0d		      lda	#IL>>8
    233  027b		       85 76		      sta	ILPC+1
    234  027d							;
    235  027d		       a9 39		      lda	#ProgramStart&$ff	;user prog
    236  027f		       8d 31 11 	      sta	PROGRAMEND
    237  0282		       a9 11		      lda	#ProgramStart>>8
    238  0284		       8d 32 11 	      sta	PROGRAMEND+1
    239  0287							;
    240  0287							; Initialize the pseudo-random number sequence...
    241  0287							;
    242  0287		       a9 5a		      lda	#$5a
    243  0289		       8d 2c 11 	      sta	rtemp1
    244  028c		       a9 9d		      lda	#%10011101
    245  028e		       8d 2d 11 	      sta	random
    246  0291		       a9 5b		      lda	#%01011011
    247  0293		       8d 2e 11 	      sta	random+1
    248  0296							;
    249  0296		       4c a6 02 	      jmp	coldtwo
    250  0299							;
    251  0299							; This is the warm start entry point
    252  0299							;
    253  0299		       20 0c 02    warm2      jsr	CRLF
    254  029c		       ad 27 11 	      lda	errGoto
    255  029f		       85 75		      sta	ILPC
    256  02a1		       ad 28 11 	      lda	errGoto+1
    257  02a4		       85 76		      sta	ILPC+1
    258  02a6							;
    259  02a6							; And continue with both starts here
    260  02a6							;
    261  02a6		       20 90 0c    coldtwo    jsr	SetOutConsole
    262  02a9							;
    263  02a9							; The ILTrace flag is now run-time settable.
    264  02a9							;
    265  02a9		       a9 00		      lda	#ILTRACE&$ff
    266  02ab		       85 40		      sta	ILTrace
    267  02ad							;
    268  02ad		       a9 00		      lda	#0
    269  02af		       85 87		      sta	RunMode
    270  02b1		       8d 9f 10 	      sta	LINBUF
    271  02b4							; Clear everything from the stacks
    272  02b4		       8d 8c 10 	      sta	mathStackPtr
    273  02b7		       8d 9d 10 	      sta	retStackPtr
    274  02ba		       8d 9e 10 	      sta	GoSubStackPtr
    275  02bd							;
    276  02bd		       a9 9f		      lda	#LINBUF&$ff
    277  02bf		       85 7e		      sta	CURPTR
    278  02c1		       a9 10		      lda	#LINBUF>>8
    279  02c3		       85 7f		      sta	CURPTR+1	;fall through...
    280  02c5							;
    281  02c5							;=====================================================
    282  02c5							; This is the top of the IL interpreter.  This fetches
    283  02c5							; and executes the instruction currently pointed to
    284  02c5							; by ILPC and adjusts ILPC to point to the next
    285  02c5							; instruction to execute.
    286  02c5							;
    287  02c5		       a5 40	   NextIL     lda	ILTrace
    288  02c7		       f0 03		      beq	NextIL2
    289  02c9		       20 18 0c 	      jsr	dbgLine
    290  02cc		       a4 80	   NextIL2    ldy	CUROFF
    291  02ce		       20 0f 0c 	      jsr	SkipSpaces
    292  02d1		       84 80		      sty	CUROFF
    293  02d3							;
    294  02d3		       20 14 09 	      jsr	getILByte
    295  02d6							;
    296  02d6							; When the handler is called, these are the conditions
    297  02d6							; of several important items:
    298  02d6							;
    299  02d6							;    (ILPC) will point to the byte AFTER the IL
    300  02d6							;    opcode being executed.
    301  02d6							;
    302  02d6							;    (CURPTR),CUROFF will point to the start of the
    303  02d6							;    next word in the input buffer.  Ie, the next word
    304  02d6							;    in the user program.
    305  02d6							;
    306  02d6		       0a		      asl
    307  02d7		       c9 70		      cmp	#ILTBLend-ILTBL+2
    308  02d9		       90 33		      bcc	ILgood
    309  02db							;
    310  02db							; This handles an illegal IL opcode.  This is serious
    311  02db							; and there's no way to recover.
    312  02db							;
    313  02db		       20 12 f0    ILbad      jsr	puts
      0  02de					      db	CR,LF
      1  02de		       0d 0a		      .byte.b	CR,LF
      0  02e0					      db	"Illegal IL "
      1  02e0		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02eb					      db	0
      1  02eb		       00		      .byte.b	0
    317  02ec							;
    318  02ec							; Well this is awkward, we need to back up the IL
    319  02ec							; by one since it no longer points to the current
    320  02ec							; opcode.
    321  02ec							;
    322  02ec		       20 21 09 	      jsr	decIL
    323  02ef							;
    324  02ef		       a0 00		      ldy	#0
    325  02f1		       b1 75		      lda	(ILPC),y
    326  02f3		       20 0f 02 	      jsr	OUTHEX
    327  02f6		       20 12 f0 	      jsr	puts
      0  02f9					      db	" at ",0
      1  02f9		       20 61 74 20*	      .byte.b	" at ",0
    329  02fe		       a5 76		      lda	ILPC+1
    330  0300		       20 0f 02 	      jsr	OUTHEX
    331  0303		       a5 75		      lda	ILPC
    332  0305		       20 0f 02 	      jsr	OUTHEX
    333  0308		       20 0c 02 	      jsr	CRLF
    334  030b		       4c 12 02 	      jmp	MONITOR
    335  030e							;
    336  030e							; Just jump to the address (ILPC),y.  Have to do
    337  030e							; some goofy stuff.
    338  030e							;
    339  030e		       a8	   ILgood     tay		;move index into Y
    340  030f		       b9 1c 03 	      lda	ILTBL,y
    341  0312		       85 77		      sta	dpl
    342  0314		       b9 1d 03 	      lda	ILTBL+1,y
    343  0317		       85 78		      sta	dpl+1
    344  0319		       6c 77 00 	      jmp	(dpl)	;go to handler
    345  031c							;
    346  031c							;=====================================================
    347  031c							; This is the IL jump table.  The IL opcode is
    348  031c							; mulitplied by two, then looked-up in this table.
    349  031c							; There is absolutely nothing special about the order
    350  031c							; of entries here... they all decode at exactly the
    351  031c							; same speed.	However the entry number must match the
    352  031c							; values in IL.inc.
    353  031c							;
      0  031c				   ILTBL      dw	iXINIT	;0
      1  031c		       a0 03		      .word.w	iXINIT
      0  031e					      dw	iDONE	;1
      1  031e		       a8 03		      .word.w	iDONE
      0  0320					      dw	iPRS	;2
      1  0320		       bb 03		      .word.w	iPRS
      0  0322					      dw	iPRN	;3
      1  0322		       c5 03		      .word.w	iPRN
      0  0324					      dw	iSPC	;4
      1  0324		       ce 03		      .word.w	iSPC
      0  0326					      dw	iNLINE	;5
      1  0326		       f6 06		      .word.w	iNLINE
      0  0328					      dw	iNXT	;6
      1  0328		       d6 03		      .word.w	iNXT
      0  032a					      dw	iXFER	;7
      1  032a		       ee 03		      .word.w	iXFER
      0  032c					      dw	iSAV	;8
      1  032c		       1b 04		      .word.w	iSAV
      0  032e					      dw	iRSTR	;9
      1  032e		       21 04		      .word.w	iRSTR
      0  0330					      dw	iCMPR	;10
      1  0330		       27 04		      .word.w	iCMPR
      0  0332					      dw	iINNUM	;11
      1  0332		       69 04		      .word.w	iINNUM
      0  0334					      dw	iFIN	;12
      1  0334		       89 04		      .word.w	iFIN
      0  0336					      dw	iERR	;13
      1  0336		       9a 04		      .word.w	iERR
      0  0338					      dw	iADD	;14
      1  0338		       e6 04		      .word.w	iADD
      0  033a					      dw	iSUB	;15
      1  033a		       fc 04		      .word.w	iSUB
      0  033c					      dw	iNEG	;16
      1  033c		       12 05		      .word.w	iNEG
      0  033e					      dw	iMUL	;17
      1  033e		       2a 05		      .word.w	iMUL
      0  0340					      dw	iDIV	;18
      1  0340		       64 05		      .word.w	iDIV
      0  0342					      dw	iSTORE	;19
      1  0342		       ad 05		      .word.w	iSTORE
      0  0344					      dw	iIND	;20
      1  0344		       c0 05		      .word.w	iIND
      0  0346					      dw	iLST	;21
      1  0346		       d0 05		      .word.w	iLST
      0  0348					      dw	iINIT	;22
      1  0348		       8a 03		      .word.w	iINIT
      0  034a					      dw	iGETLINE	;23
      1  034a		       2f 06		      .word.w	iGETLINE
      0  034c					      dw	iINSRT	;24
      1  034c		       3b 06		      .word.w	iINSRT
      0  034e					      dw	iRTN	;25
      1  034e		       f0 06		      .word.w	iRTN
      0  0350					      dw	MONITOR	;26
      1  0350		       12 02		      .word.w	MONITOR
      0  0352					      dw	iLIT	;27
      1  0352		       09 07		      .word.w	iLIT
      0  0354					      dw	iCALL	;28
      1  0354		       fc 06		      .word.w	iCALL
      0  0356					      dw	iJMP	;29
      1  0356		       ff 06		      .word.w	iJMP
      0  0358					      dw	iVINIT	;30
      1  0358		       16 07		      .word.w	iVINIT
      0  035a					      dw	iERRGOTO	;31
      1  035a		       24 07		      .word.w	iERRGOTO
      0  035c					      dw	iTST	;32
      1  035c		       30 07		      .word.w	iTST
      0  035e					      dw	iTSTV	;33
      1  035e		       99 07		      .word.w	iTSTV
      0  0360					      dw	iTSTL	;34
      1  0360		       c3 07		      .word.w	iTSTL
      0  0362					      dw	iTSTN	;35
      1  0362		       dd 07		      .word.w	iTSTN
      0  0364					      dw	iFREE	;36
      1  0364		       20 08		      .word.w	iFREE
      0  0366					      dw	iRANDOM	;37
      1  0366		       29 08		      .word.w	iRANDOM
      0  0368					      dw	iABS	;38
      1  0368		       f3 08		      .word.w	iABS
    393  036a							;
    394  036a							; Disk functions.  There must be pointers
    395  036a							; to functions even if no disk is supported.
    396  036a							; Makes things easier in IL.inc.
    397  036a							;
    398  036a					      if	DISK_ACCESS
      0  036a					      dw	iOPENREAD	;39
      1  036a		       d6 0c		      .word.w	iOPENREAD
      0  036c					      dw	iOPENWRITE	;40
      1  036c		       2a 0d		      .word.w	iOPENWRITE
      0  036e					      dw	iDCLOSE	;41
      1  036e		       ae 0d		      .word.w	iDCLOSE
      0  0370					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0370		       49 0d		      .word.w	iDGETLINE
      0  0372					      dw	iDLIST	;43 Did you remeber your towel?
      1  0372		       a8 0d		      .word.w	iDLIST
      0  0374					      dw	iDDIR	;44
      1  0374		       83 0d		      .word.w	iDDIR
      0  0376					      dw	iRMFILE	;45
      1  0376		       04 0d		      .word.w	iRMFILE
    406  0378				  -	      else
    407  0378				  -	      dw	NextIL	;39
    408  0378				  -	      dw	NextIL	;40
    409  0378				  -	      dw	NextIL	;41
    410  0378				  -	      dw	NextIL	;42
    411  0378				  -	      dw	NextIL	;43
    412  0378				  -	      dw	NextIL	;44
    413  0378				  -	      dw	NextIL	;45
    414  0378					      endif
    415  0378							;
      0  0378					      dw	iCLEARSCREEN	;46
      1  0378		       cb 0c		      .word.w	iCLEARSCREEN
      0  037a					      dw	iPOKEMEMORY	;47
      1  037a		       a1 08		      .word.w	iPOKEMEMORY
      0  037c					      dw	iPEEKMEMORY	;48
      1  037c		       b0 08		      .word.w	iPEEKMEMORY
      0  037e					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  037e		       5f 07		      .word.w	iTSTLET
      0  0380					      dw	iTSTDONE	;50	Test if we are at the end of a line
      1  0380		       7c 07		      .word.w	iTSTDONE
      0  0382					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0382		       d4 08		      .word.w	iGETCHAR
      0  0384					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0384		       e8 08		      .word.w	iPUTCHAR
      0  0386					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0386		       bf 08		      .word.w	iCallFunc
      0  0388					      dw	iCallFunc2	;54	   call system rtn with value in a
      1  0388		       ba 08		      .word.w	iCallFunc2
    425  038a
    426  038a		       03 8a	   ILTBLend   equ	*
    427  038a							;
    428  038a							;=====================================================
    429  038a							;=====================================================
    430  038a							;=====================================================
    431  038a							; This marks the start of the handlers for IL opcodes.
    432  038a							;=====================================================
    433  038a							;=====================================================
    434  038a							;=====================================================
    435  038a							;
    436  038a							;
    437  038a		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    438  038c		       8d 9d 10 	      sta	retStackPtr
    439  038f		       8d 9e 10 	      sta	GoSubStackPtr
    440  0392							;
    441  0392		       a9 39		      lda	#ProgramStart&$ff	;user prog
    442  0394		       85 7e		      sta	CURPTR
    443  0396		       8d 31 11 	      sta	PROGRAMEND
    444  0399		       a9 11		      lda	#ProgramStart>>8
    445  039b		       85 7f		      sta	CURPTR+1
    446  039d		       8d 32 11 	      sta	PROGRAMEND+1
    447  03a0							;
    448  03a0							; fall into XINIT...
    449  03a0							;
    450  03a0							;=====================================================
    451  03a0							; This initializes for the start of the next line of
    452  03a0							; BASIC text.
    453  03a0							;
    454  03a0		       a9 00	   iXINIT     lda	#0
    455  03a2		       8d 8c 10 	      sta	mathStackPtr	;clear math stack
    456  03a5		       4c c5 02    goodExit   jmp	NextIL
    457  03a8							;
    458  03a8							;=====================================================
    459  03a8							; Verify there is nothing else on this input line.
    460  03a8							; If there is, generate an error.
    461  03a8							;
    462  03a8		       a4 80	   iDONE      ldy	CUROFF
    463  03aa		       20 0f 0c 	      jsr	SkipSpaces
    464  03ad		       b1 7e		      lda	(CURPTR),y
    465  03af		       f0 07		      beq	doneadv
    466  03b1		       a2 04		      ldx	#ERR_EXTRA_STUFF
    467  03b3		       a9 00		      lda	#0
    468  03b5		       4c 9d 04 	      jmp	iErr2
    469  03b8							;
    470  03b8							; Advance to the next line
    471  03b8							;
    472  03b8				   doneadv
    473  03b8							;		jsr	FindNext2
    474  03b8		       4c c5 02 	      jmp	NextIL
    475  03bb							;
    476  03bb							;=====================================================
    477  03bb							; Print the string until a closing quote
    478  03bb							;
    479  03bb		       a4 80	   iPRS       ldy	CUROFF
    480  03bd							;
    481  03bd							; Odd logic here.  The main loop skipped any leading
    482  03bd							; whitespace inside the quoted text, so move back to
    483  03bd							; the quote, then move forward again.
    484  03bd							;
    485  03bd		       20 9e 0c 	      jsr	PrtQuoted
    486  03c0		       84 80		      sty	CUROFF
    487  03c2		       4c c5 02 	      jmp	NextIL
    488  03c5							;
    489  03c5							;=====================================================
    490  03c5							; Pop the top off the stack and print it as a signed
    491  03c5							; decimal number.
    492  03c5							;
    493  03c5		       20 53 0b    iPRN       jsr	popR0
    494  03c8		       20 b9 09 	      jsr	PrintDecimal
    495  03cb		       4c c5 02 	      jmp	NextIL
    496  03ce							;
    497  03ce							;=====================================================
    498  03ce							; Space to next zone.	Currently the code does not
    499  03ce							; keep track of which column the output is on, so
    500  03ce							; just print a tab.
    501  03ce							;
    502  03ce		       a9 09	   iSPC       lda	#TAB
    503  03d0		       20 06 02 	      jsr	OUTCH
    504  03d3		       4c c5 02 	      jmp	NextIL
    505  03d6							;
    506  03d6							;=====================================================
    507  03d6							; If in immediate mode, jump to the address following
    508  03d6							; the NXT instruction.  Else move to the next line of
    509  03d6							; user code and continue.
    510  03d6							;
    511  03d6		       a5 87	   iNXT       lda	RunMode
    512  03d8		       d0 03		      bne	iNxtRun	;in run mode
    513  03da							;
    514  03da							; Get address and jump to it.
    515  03da							;
    516  03da		       4c ff 06 	      jmp	iJMP
    517  03dd							;
    518  03dd		       20 9a 09    iNxtRun    jsr	FindNextLine
    519  03e0		       20 ac 09 	      jsr	AtEnd
    520  03e3		       d0 03		      bne	iNxtRun2	;not at end
    521  03e5							;
    522  03e5							; At the end of the program.  Pretend an END statement
    523  03e5							; was found.
    524  03e5							;
    525  03e5		       4c 89 04    iFINv      jmp	iFIN
    526  03e8							;
    527  03e8		       20 10 09    iNxtRun2   jsr	getILWord	;ignore next word
    528  03eb		       4c c5 02 	      jmp	NextIL
    529  03ee							;
    530  03ee							;=====================================================
    531  03ee							; XFER takes the number on top of the stack and looks
    532  03ee							; for that line in the program, or the next line
    533  03ee							; higher.  Ie, if it's 1 but there is no line 1, then
    534  03ee							; find the next one after that.
    535  03ee							;
    536  03ee		       20 53 0b    iXFER      jsr	popR0
    537  03f1		       20 57 09 	      jsr	findLine
    538  03f4		       20 ac 09    iXFER2     jsr	AtEnd	;at end of user program?
    539  03f7		       f0 ec		      beq	iFINv
    540  03f9		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    541  03fb		       84 80		      sty	CUROFF
    542  03fd		       a9 ff		      lda	#$ff
    543  03ff		       85 87		      sta	RunMode
    544  0401							;
    545  0401							; Transfer IL to STMT.  I don't like having this
    546  0401							; hard-coded; fix it.
    547  0401							;
    548  0401		       a9 09		      lda	#STMT&$ff
    549  0403		       85 75		      sta	ILPC
    550  0405		       a9 0e		      lda	#STMT>>8
    551  0407		       85 76		      sta	ILPC+1
    552  0409		       4c c5 02 	      jmp	NextIL
    553  040c							;
    554  040c							; Run
    555  040c							;
    556  040c				   iXferok
    557  040c		       a9 ff		      lda	#$ff
    558  040e		       85 87		      sta	RunMode	;we're running
    559  0410							;
    560  0410							; Need a more elegant way to do this
    561  0410							;
    562  0410		       a9 09		      lda	#STMT&$ff
    563  0412		       85 75		      sta	ILPC
    564  0414		       a9 0e		      lda	#STMT>>8
    565  0416		       85 76		      sta	ILPC+1
    566  0418		       4c c5 02 	      jmp	NextIL
    567  041b							;
    568  041b							;=====================================================
    569  041b							; Save the pointer to the next line to the call stack.
    570  041b							;
    571  041b				   iSAV
    572  041b		       20 29 0b 	      jsr	pushLN
    573  041e		       4c c5 02 	      jmp	NextIL
    574  0421
    575  0421							;
    576  0421							;=====================================================
    577  0421							; Pop the next line from the call stack.
    578  0421							;
    579  0421				   iRSTR
    580  0421		       20 66 0b 	      jsr	popLN
    581  0424		       4c c5 02 	      jmp	NextIL
    582  0427							;jmp	ILbad
    583  0427							;
    584  0427							;=====================================================
    585  0427							; Compare items on stack.  Okay, so on input there are
    586  0427							; three things on the stack
    587  0427							;
    588  0427							;    EXPR2 <- Top of stack
    589  0427							;    OP    <- relational operator, next on stack
    590  0427							;    EXPR1 <- last item on stack
    591  0427							;
    592  0427							; Comparison is: EXPR1 <operator> EXPR2
    593  0427							;
    594  0427							; Operator is one of...
    595  0427							;
    596  0427							;    2 is =
    597  0427							;    1 is <
    598  0427							;    3 is <=
    599  0427							;    5 is <>
    600  0427							;    4 is >
    601  0427							;    6 is >=
    602  0427							;
    603  0427							; Those are bit-mapped:
    604  0427							;
    605  0427							;    xxxxxGEL
    606  0427							;
    607  0427							;    G = Greater than
    608  0427							;    E = Equal
    609  0427							;    L = Less than
    610  0427							;
    611  0427							; If the comparison is false, do a NXT, ie, move to the
    612  0427							; next line and continue.  If true, continue executing
    613  0427							; on this line.
    614  0427							;
    615  0427		       00 01	   REL_LT     equ	%001
    616  0427		       00 02	   REL_EQUAL  equ	%010
    617  0427		       00 04	   REL_GT     equ	%100
    618  0427							;
    619  0427		       20 7d 0b    iCMPR      jsr	popR1
    620  042a		       20 90 0b 	      jsr	popMQ	;operator in MQ
    621  042d		       20 53 0b 	      jsr	popR0
    622  0430							;
    623  0430							; See if they are equal or not
    624  0430							;
    625  0430		       a5 83		      lda	R0
    626  0432		       c5 85		      cmp	R1
    627  0434		       d0 0a		      bne	iCMPRnoteq	;try not equal
    628  0436		       a5 84		      lda	R0+1
    629  0438		       c5 86		      cmp	R1+1
    630  043a		       d0 04		      bne	iCMPRnoteq
    631  043c							;
    632  043c							; Equal, set the flag in MQ+1
    633  043c							;
    634  043c		       a9 02		      lda	#REL_EQUAL
    635  043e		       d0 14		      bne	iCMPcom
    636  0440							;
    637  0440							; See if EXPR1 (R0) < EXPR2 (R1)
    638  0440							; See www.6502.org/tutorials/compare_beyond.html
    639  0440							;
    640  0440		       a5 83	   iCMPRnoteq lda	R0
    641  0442		       c5 85		      cmp	R1
    642  0444		       a5 84		      lda	R0+1
    643  0446		       e5 86		      sbc	R1+1
    644  0448		       50 02		      bvc	iCMPR_2
    645  044a		       49 80		      eor	#$80
    646  044c		       30 04	   iCMPR_2    bmi	iCMPlt
    647  044e		       a9 04		      lda	#REL_GT
    648  0450		       d0 02		      bne	iCMPcom
    649  0452		       a9 01	   iCMPlt     lda	#REL_LT	;R0 < R1
    650  0454		       0d 2a 11    iCMPcom    ora	MQ+1
    651  0457							;
    652  0457							; Now compare the end result with what the caller
    653  0457							; was looking for.
    654  0457							;
    655  0457		       2d 29 11 	      and	MQ
    656  045a		       f0 07		      beq	iCMPno	;no match
    657  045c		       4c c5 02 	      jmp	NextIL
    658  045f							;
    659  045f							; R0 > R1
    660  045f							;
    661  045f		       a9 04	   iCMPgt     lda	#REL_GT
    662  0461		       d0 f1		      bne	iCMPcom
    663  0463							;
    664  0463							; Not a match, so jump to the next line of code.
    665  0463							;
    666  0463		       20 9a 09    iCMPno     jsr	FindNextLine
    667  0466		       4c f4 03 	      jmp	iXFER2
    668  0469							;
    669  0469							;=====================================================
    670  0469							; Get a line of text from the user, convert to a
    671  0469							; number, leave on top of stack.
    672  0469							;
    673  0469		       a5 80	   iINNUM     lda	CUROFF	;save state before GetLine
    674  046b		       48		      pha
    675  046c		       a5 7f		      lda	CURPTR+1
    676  046e		       48		      pha
    677  046f		       a5 7e		      lda	CURPTR
    678  0471		       48		      pha
    679  0472							;
    680  0472		       a9 3f		      lda	#'?
    681  0474		       20 9c 0a 	      jsr	GetLine
    682  0477		       20 25 0a 	      jsr	getDecimal
    683  047a		       20 16 0b 	      jsr	pushR0	;put onto stack
    684  047d							;
    685  047d		       68		      pla
    686  047e		       85 7e		      sta	CURPTR
    687  0480		       68		      pla
    688  0481		       85 7f		      sta	CURPTR+1
    689  0483		       68		      pla
    690  0484		       85 80		      sta	CUROFF
    691  0486							;
    692  0486		       4c c5 02 	      jmp	NextIL
    693  0489							;
    694  0489
    695  0489							;
    696  0489							;=====================================================
    697  0489							; Stop the currently running program.	Actually very
    698  0489							; simple to do... clear the RunMode flag, then set the
    699  0489							; ILPC to the standard handler and continue running.
    700  0489							;
    701  0489		       a9 00	   iFIN       lda	#0
    702  048b		       85 87		      sta	RunMode
    703  048d							;
    704  048d		       ad 27 11 	      lda	errGoto
    705  0490		       85 75		      sta	ILPC
    706  0492		       ad 28 11 	      lda	errGoto+1
    707  0495		       85 76		      sta	ILPC+1
    708  0497		       4c c5 02 	      jmp	NextIL
    709  049a							;
    710  049a							;=====================================================
    711  049a							; Handle the ERR opcode.  Following the instruction is
    712  049a							; a 16 bit error number.  Print an error message, and
    713  049a							; if we're in run mode, print the line number.  Stop
    714  049a							; program execution and return to the initial state.
    715  049a							;
    716  049a		       20 10 09    iERR       jsr	getILWord	;get err code
    717  049d							;
    718  049d							; Enter here with the error code in X (LSB) and A (MSB).
    719  049d							;
    720  049d		       86 83	   iErr2      stx	R0
    721  049f		       85 84		      sta	R0+1
    722  04a1							;
    723  04a1		       20 12 f0 	      jsr	puts
      0  04a4					      db	"Error ",0
      1  04a4		       45 72 72 6f*	      .byte.b	"Error ",0
    725  04ab		       20 b9 09 	      jsr	PrintDecimal
    726  04ae							;
    727  04ae		       a5 87		      lda	RunMode	;running?
    728  04b0		       f0 1b		      beq	iERR2	;nope
    729  04b2		       20 12 f0 	      jsr	puts
      0  04b5					      db	" at line ",0
      1  04b5		       20 61 74 20*	      .byte.b	" at line ",0
    731  04bf		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    732  04c1		       b1 7e		      lda	(CURPTR),y
    733  04c3		       85 83		      sta	R0
    734  04c5		       c8		      iny
    735  04c6		       b1 7e		      lda	(CURPTR),y
    736  04c8		       85 84		      sta	R0+1
    737  04ca		       20 b9 09 	      jsr	PrintDecimal
    738  04cd							;
    739  04cd		       20 0c 02    iERR2      jsr	CRLF
    740  04d0		       a9 00		      lda	#0
    741  04d2		       85 87		      sta	RunMode	;fall through...
    742  04d4							;
    743  04d4							;=====================================================
    744  04d4							; Reset the IL to be back at the idle loop.  Does not
    745  04d4							; clear variables so the user can see what state
    746  04d4							; the program is in.
    747  04d4							;
    748  04d4		       a9 00	   ResetIL    lda	#0
    749  04d6		       8d 9d 10 	      sta	retStackPtr
    750  04d9		       ad 27 11 	      lda	errGoto
    751  04dc		       85 75		      sta	ILPC
    752  04de		       ad 28 11 	      lda	errGoto+1
    753  04e1		       85 76		      sta	ILPC+1
    754  04e3		       4c c5 02 	      jmp	NextIL
    755  04e6							;
    756  04e6							;=====================================================
    757  04e6							; Pop two items off stack, add them, then place the
    758  04e6							; result back onto the stack.
    759  04e6							;
    760  04e6		       20 53 0b    iADD       jsr	popR0
    761  04e9		       20 7d 0b 	      jsr	popR1
    762  04ec		       18		      clc
    763  04ed		       a5 83		      lda	R0
    764  04ef		       65 85		      adc	R1
    765  04f1		       85 83		      sta	R0
    766  04f3		       a5 84		      lda	R0+1
    767  04f5		       65 86		      adc	R1+1
    768  04f7		       85 84		      sta	R0+1
    769  04f9		       4c 5e 05 	      jmp	pushR0nextIl
    770  04fc							;
    771  04fc							;=====================================================
    772  04fc							; Pop two items off the stack.  Subtract the top of
    773  04fc							; stack from the lower entry.
    774  04fc							;
    775  04fc		       20 7d 0b    iSUB       jsr	popR1
    776  04ff		       20 53 0b 	      jsr	popR0
    777  0502		       38		      sec
    778  0503		       a5 83		      lda	R0
    779  0505		       e5 85		      sbc	R1
    780  0507		       85 83		      sta	R0
    781  0509		       a5 84		      lda	R0+1
    782  050b		       e5 86		      sbc	R1+1
    783  050d		       85 84		      sta	R0+1
    784  050f		       4c 5e 05 	      jmp	pushR0nextIl
    785  0512							;
    786  0512							;=====================================================
    787  0512							; Negate the top of stack.
    788  0512							;
    789  0512		       20 53 0b    iNEG       jsr	popR0
    790  0515		       a5 83		      lda	R0
    791  0517		       49 ff		      eor	#$ff
    792  0519		       85 83		      sta	R0
    793  051b		       a5 84		      lda	R0+1
    794  051d		       49 ff		      eor	#$ff
    795  051f		       85 84		      sta	R0+1
    796  0521		       e6 83		      inc	R0
    797  0523		       d0 02		      bne	iNEG2
    798  0525		       e6 84		      inc	R0+1
    799  0527		       4c 5e 05    iNEG2      jmp	pushR0nextIl
    800  052a							;
    801  052a							;=====================================================
    802  052a							; Multiply top two items on the stack, put the results
    803  052a							; on top.  This uses the algorithm documented on page
    804  052a							; 115 of "Microprocessor Programming for Computer
    805  052a							; Hobbyists" by Neill Graham.
    806  052a							;
    807  052a		       20 53 0b    iMUL       jsr	popR0	;AC
    808  052d		       20 7d 0b 	      jsr	popR1	;OP
    809  0530							;
    810  0530		       a5 83		      lda	R0
    811  0532		       8d 29 11 	      sta	MQ
    812  0535		       a5 84		      lda	R0+1
    813  0537		       8d 2a 11 	      sta	MQ+1
    814  053a		       a9 00		      lda	#0	;clear result
    815  053c		       85 83		      sta	R0
    816  053e		       85 84		      sta	R0+1
    817  0540							;
    818  0540		       a2 10		      ldx	#16	;number of bits in value
    819  0542		       06 83	   multloop   asl	R0
    820  0544		       26 84		      rol	R0+1
    821  0546		       0e 29 11 	      asl	MQ
    822  0549		       2e 2a 11 	      rol	MQ+1
    823  054c		       90 0d		      bcc	multno	;skip add if no carry
    824  054e							;
    825  054e							; Add R1 back into R0
    826  054e							;
    827  054e		       18		      clc
    828  054f		       a5 83		      lda	R0
    829  0551		       65 85		      adc	R1
    830  0553		       85 83		      sta	R0
    831  0555		       a5 84		      lda	R0+1
    832  0557		       65 86		      adc	R1+1
    833  0559		       85 84		      sta	R0+1
    834  055b							;
    835  055b		       ca	   multno     dex		;did all bits yet?
    836  055c		       d0 e4		      bne	multloop
    837  055e							;
    838  055e				   pushR0nextIl
    839  055e		       20 16 0b 	      jsr	pushR0	;OP
    840  0561		       4c c5 02 	      jmp	NextIL
    841  0564							;
    842  0564							;=====================================================
    843  0564							; Divide the top of stack into the next to top item.
    844  0564							; Leave results on stack.  Taken from:
    845  0564							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
    846  0564							;
    847  0564							; MQ = R0 / R1
    848  0564							; Remainder is in R0
    849  0564							;
    850  0564		       20 7d 0b    iDIV       jsr	popR1
    851  0567		       20 53 0b 	      jsr	popR0
    852  056a							;
    853  056a							; Check for divide by zero
    854  056a							;
    855  056a		       a5 85		      lda	R1
    856  056c		       05 86		      ora	R1+1
    857  056e		       f0 36		      beq	divby0
    858  0570							;
    859  0570		       20 a5 0b 	      jsr	SaveSigns
    860  0573		       a9 00		      lda	#0	;preset remainder to 0
    861  0575		       8d 29 11 	      sta	MQ
    862  0578		       8d 2a 11 	      sta	MQ+1
    863  057b		       a2 10		      ldx	#16	;repeat for each bit: ...
    864  057d
    865  057d		       06 83	   divloop    asl	R0	;dividend lb & hb*2, msb -> Carry
    866  057f		       26 84		      rol	R0+1
    867  0581		       2e 29 11 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
    868  0584		       2e 2a 11 	      rol	MQ+1
    869  0587		       ad 29 11 	      lda	MQ
    870  058a		       38		      sec
    871  058b		       e5 85		      sbc	R1	;substract divisor to see if it fits in
    872  058d		       a8		      tay		;lb result -> Y, for we may need it later
    873  058e		       ad 2a 11 	      lda	MQ+1
    874  0591		       e5 86		      sbc	R1+1
    875  0593		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
    876  0595
    877  0595		       8d 2a 11 	      sta	MQ+1	;else save substraction result as new remainder,
    878  0598		       8c 29 11 	      sty	MQ
    879  059b		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
    880  059d
    881  059d		       ca	   skip       dex
    882  059e		       d0 dd		      bne	divloop
    883  05a0		       20 e0 0b 	      jsr	RestoreSigns
    884  05a3		       4c 5e 05 	      jmp	pushR0nextIl
    885  05a6							;
    886  05a6							; Indicate divide-by-zero error
    887  05a6							;
    888  05a6		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
    889  05a8		       a9 00		      lda	#0
    890  05aa		       4c 9d 04 	      jmp	iErr2
    891  05ad							;
    892  05ad							;=====================================================
    893  05ad							; This pops the top two items off the stack.  The top
    894  05ad							; item is a data value and the other is an index into
    895  05ad							; the variable table.	Save the value into that entry.
    896  05ad							;
    897  05ad		       20 53 0b    iSTORE     jsr	popR0	;data
    898  05b0		       20 7d 0b 	      jsr	popR1	;index
    899  05b3		       a6 85		      ldx	R1	;get index
    900  05b5		       a5 83		      lda	R0
    901  05b7		       95 41		      sta	variables,x
    902  05b9		       a5 84		      lda	R0+1
    903  05bb		       95 42		      sta	variables+1,x
    904  05bd		       4c c5 02 	      jmp	NextIL
    905  05c0							;
    906  05c0							;=====================================================
    907  05c0							; Replaces the top of stack with the variable whose
    908  05c0							; index it represents.
    909  05c0							;
    910  05c0		       20 7d 0b    iIND       jsr	popR1
    911  05c3		       a6 85		      ldx	R1	;get index
    912  05c5		       b5 41		      lda	variables,x
    913  05c7		       85 83		      sta	R0
    914  05c9		       b5 42		      lda	variables+1,x
    915  05cb		       85 84		      sta	R0+1
    916  05cd		       4c 5e 05 	      jmp	pushR0nextIl
    917  05d0							;
    918  05d0							;=====================================================
    919  05d0							; List the current BASIC program in memory.  Uses R0,
    920  05d0							; tempIly, and dpl.
    921  05d0							;
    922  05d0		       20 90 0c    iLST       jsr	SetOutConsole
    923  05d3		       a9 39	   iLST2      lda	#ProgramStart&$ff
    924  05d5		       85 77		      sta	dpl
    925  05d7		       a9 11		      lda	#ProgramStart>>8
    926  05d9		       85 78		      sta	dpl+1
    927  05db							;
    928  05db							; dpl/dph point to the current line.  See if we're at
    929  05db							; the end of the program.
    930  05db							;
    931  05db		       a5 77	   iLSTloop   lda	dpl
    932  05dd		       cd 31 11 	      cmp	PROGRAMEND
    933  05e0		       d0 07		      bne	iLstNotEnd
    934  05e2		       a5 78		      lda	dpl+1
    935  05e4		       cd 32 11 	      cmp	PROGRAMEND+1
    936  05e7		       f0 40		      beq	iLstdone
    937  05e9							;
    938  05e9		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
    939  05eb		       b1 77		      lda	(dpl),y	;line number LSB
    940  05ed		       85 83		      sta	R0
    941  05ef		       c8		      iny
    942  05f0		       b1 77		      lda	(dpl),y	;line number MSB
    943  05f2		       85 84		      sta	R0+1
    944  05f4		       c8		      iny
    945  05f5		       84 7b		      sty	tempIlY
    946  05f7		       20 b9 09 	      jsr	PrintDecimal
    947  05fa		       a9 20		      lda	#SPACE
    948  05fc		       20 9b 0c 	      jsr	VOUTCH
    949  05ff		       a4 7b		      ldy	tempIlY
    950  0601		       b1 77	   iLSTl2     lda	(dpl),y
    951  0603		       f0 0a		      beq	iLST3	;end of this line
    952  0605		       84 7b		      sty	tempIlY
    953  0607		       20 9b 0c 	      jsr	VOUTCH
    954  060a		       a4 7b		      ldy	tempIlY
    955  060c		       c8		      iny
    956  060d		       d0 f2		      bne	iLSTl2	;do next char
    957  060f							;
    958  060f							; End of this line.  Print CR/LF, then move to the
    959  060f							; next line.
    960  060f							;
    961  060f		       c8	   iLST3      iny
    962  0610		       18		      clc
    963  0611		       98		      tya
    964  0612		       65 77		      adc	dpl
    965  0614		       85 77		      sta	dpl
    966  0616		       a5 78		      lda	dpl+1
    967  0618		       69 00		      adc	#0
    968  061a		       85 78		      sta	dpl+1
    969  061c							;
    970  061c							; Have to manually do CR/LF so it uses the vectored
    971  061c							; output function.
    972  061c							;
    973  061c		       a9 0d		      lda	#CR
    974  061e		       20 9b 0c 	      jsr	VOUTCH
    975  0621		       a9 0a		      lda	#LF
    976  0623		       20 9b 0c 	      jsr	VOUTCH
    977  0626		       4c db 05 	      jmp	iLSTloop	;do next line
    978  0629							;
    979  0629		       20 90 0c    iLstdone   jsr	SetOutConsole
    980  062c		       4c c5 02 	      jmp	NextIL
    981  062f							;
    982  062f							;=====================================================
    983  062f							; Get a line of text into LINBUF.  Terminate with a
    984  062f							; null byte.
    985  062f							;
    986  062f		       a9 3e	   iGETLINE   lda	#'>	;prompt character
    987  0631		       20 9c 0a 	      jsr	GetLine
    988  0634							;
    989  0634		       a9 00		      lda	#0
    990  0636		       85 87		      sta	RunMode
    991  0638		       4c c5 02 	      jmp	NextIL
    992  063b							;
    993  063b							;=====================================================
    994  063b							; This is called when the input buffer contains a line
    995  063b							; typed in by the user that starts with a line number.
    996  063b							; Insert the line into the program or delete the line
    997  063b							; if there is nothing after the line number,
    998  063b							;
    999  063b		       a0 00	   iINSRT     ldy	#0
   1000  063d		       20 25 0a 	      jsr	getDecimal	;convert line #
   1001  0640		       20 0f 0c 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1002  0643		       84 7c		      sty	offset	;Save the start of the program line text
   1003  0645							;
   1004  0645							; Now find the line OR the next higher line OR the
   1005  0645							; end of the program.
   1006  0645							;
   1007  0645		       20 57 09 	      jsr	findLine	; Look for the line number in the current program
   1008  0648							; Returns Z and curptr point to the line if found
   1009  0648							; Returns C and curptr at next higher line if not found and there is a higher line
   1010  0648							; Returns ZC clear and curptr to end of program if higher than all other lines
   1011  0648							;
   1012  0648							; If the line exists, it needs to be removed.
   1013  0648							;
   1014  0648		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1015  064a							;
   1016  064a							; Get length of line to be removed, we fall thru to here if we find a matching line
   1017  064a							;
   1018  064a							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1019  064a		       a0 00		      ldy	#0
   1020  064c		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1021  064e		       a8		      tay
   1022  064f							;If it is equal we delete the line and replace it, get length
   1023  064f							;then adjust all program line after up or down depending on len of line
   1024  064f							;If next higher then just move everythimg down by length bytes
   1025  064f							;This call will return how many bytes in the line we found
   1026  064f		       84 7d		      sty	lineLength	;Save the length of the line we found
   1027  0651							;
   1028  0651							; Compute the new end of the program first.
   1029  0651							;
   1030  0651		       38		      sec		;Set the carry bit
   1031  0652		       ad 31 11 	      lda	PROGRAMEND	;Get low byte of program end
   1032  0655		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1033  0657		       8d 31 11 	      sta	PROGRAMEND	;save it
   1034  065a		       ad 32 11 	      lda	PROGRAMEND+1
   1035  065d		       e9 00		      sbc	#0	;Process the carry
   1036  065f		       8d 32 11 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1037  0662							;
   1038  0662							; Copy CURPTR into R1 for working
   1039  0662							;
   1040  0662		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1041  0664		       85 85		      sta	R1
   1042  0666		       a5 7f		      lda	CURPTR+1
   1043  0668		       85 86		      sta	R1+1
   1044  066a							;
   1045  066a							; See if we're at the end.
   1046  066a							;
   1047  066a		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1048  066c		       cd 31 11 	      cmp	PROGRAMEND
   1049  066f		       d0 07		      bne	InsDelLoop
   1050  0671		       a5 86		      lda	R1+1
   1051  0673		       cd 32 11 	      cmp	PROGRAMEND+1
   1052  0676		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1053  0678							;
   1054  0678							; Move one byte, move to next location.
   1055  0678							;
   1056  0678		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1057  067a		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1058  067c		       b1 85		      lda	(R1),y
   1059  067e		       a0 00		      ldy	#0
   1060  0680		       91 85		      sta	(R1),y
   1061  0682		       e6 85		      inc	R1
   1062  0684		       d0 e4		      bne	InsDelChk
   1063  0686		       e6 86		      inc	R1+1
   1064  0688		       4c 6a 06 	      jmp	InsDelChk	; Check if we have moved the last byte
   1065  068b							;
   1066  068b							; Deletion is done.
   1067  068b							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1068  068b							;
   1069  068b		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1070  068d		       b9 9f 10 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1071  0690		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1072  0692							;
   1073  0692							; CURPTR points to where the line will be inserted.
   1074  0692							;
   1075  0692		       20 f2 0a 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1076  0695							;
   1077  0695		       ad 31 11 	      lda	PROGRAMEND	;Load the start address for the copy
   1078  0698							;At this point curptr still contains the location we will insert data
   1079  0698		       85 88		      sta	FROM
   1080  069a		       ad 32 11 	      lda	PROGRAMEND+1
   1081  069d		       85 89		      sta	FROM+1
   1082  069f							;
   1083  069f		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1084  06a1		       b1 88		      lda	(FROM),y
   1085  06a3		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1086  06a5		       91 88		      sta	(FROM),y	;Save the new byte
   1087  06a7							;
   1088  06a7		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1089  06a9		       c5 7e		      cmp	CURPTR
   1090  06ab		       d0 06		      bne	mvUpMore
   1091  06ad		       a5 89		      lda	FROM+1
   1092  06af		       c5 7f		      cmp	CURPTR+1
   1093  06b1		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1094  06b3							;
   1095  06b3							; Not done yet
   1096  06b3							;
   1097  06b3		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1098  06b5		       d0 02		      bne	mvUpMore2
   1099  06b7		       c6 89		      dec	FROM+1
   1100  06b9		       c6 88	   mvUpMore2  dec	FROM
   1101  06bb		       4c 9f 06 	      jmp	mvup1	;Loop until everything is moved
   1102  06be							;
   1103  06be							; All done with copy.
   1104  06be							;
   1105  06be		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1106  06bf		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1107  06c1		       6d 31 11 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1108  06c4		       8d 31 11 	      sta	PROGRAMEND
   1109  06c7		       ad 32 11 	      lda	PROGRAMEND+1
   1110  06ca		       69 00		      adc	#0
   1111  06cc		       8d 32 11 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1112  06cf							;
   1113  06cf							;===================jlit use length before line newline
   1114  06cf
   1115  06cf		       a0 00		      ldy	#0	;Set offset of copy
   1116  06d1		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1117  06d3		       91 7e		      sta	(CURPTR),y	;Store the length
   1118  06d5		       c8		      iny
   1119  06d6		       a5 83		      lda	R0	;Store the line number next
   1120  06d8		       91 7e		      sta	(CURPTR),y
   1121  06da		       c8		      iny
   1122  06db		       a5 84		      lda	R0+1
   1123  06dd		       91 7e		      sta	(CURPTR),y
   1124  06df		       c8		      iny
   1125  06e0							;
   1126  06e0		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1127  06e2		       bd 9f 10    mvUpLoop2  lda	LINBUF,x	;get a byte
   1128  06e5		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1129  06e7		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1130  06e9		       e8		      inx
   1131  06ea		       c8		      iny
   1132  06eb		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1133  06ed							;
   1134  06ed		       4c c5 02    mvUpFini   jmp	NextIL
   1135  06f0							;
   1136  06f0							;=====================================================
   1137  06f0							; Pops the top value of the ILPC stack and stores it
   1138  06f0							; in ILPC.  Ie, return from an IL subroutine.
   1139  06f0							;
   1140  06f0		       20 44 09    iRTN       jsr	popILPC
   1141  06f3		       4c c5 02 	      jmp	NextIL
   1142  06f6							;
   1143  06f6							;=====================================================
   1144  06f6							; NLINE print a newline
   1145  06f6							;
   1146  06f6		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1147  06f9		       4c c5 02 	      jmp	NextIL
   1148  06fc							;
   1149  06fc							;=====================================================
   1150  06fc							; This saves the current ILPC value on the stack, then
   1151  06fc							; jumps to the address specified by the next two bytes.
   1152  06fc							;
   1153  06fc		       20 2a 09    iCALL      jsr	pushILPC	;save ILPC
   1154  06ff							;
   1155  06ff							; Jmp to a specific location in the IL code.  The new
   1156  06ff							; address immediately follows the opcode.
   1157  06ff							;
   1158  06ff		       20 10 09    iJMP       jsr	getILWord
   1159  0702		       86 75		      stx	ILPC
   1160  0704		       85 76		      sta	ILPC+1
   1161  0706		       4c c5 02 	      jmp	NextIL
   1162  0709							;
   1163  0709							;=====================================================
   1164  0709							; Push the next two bytes onto the arithmetic stack.
   1165  0709							;
   1166  0709		       20 10 09    iLIT       jsr	getILWord
   1167  070c		       86 83		      stx	R0
   1168  070e		       85 84		      sta	R0+1
   1169  0710		       20 16 0b 	      jsr	pushR0
   1170  0713		       4c c5 02 	      jmp	NextIL
   1171  0716							;
   1172  0716							;=====================================================
   1173  0716							; Initialize all variables.  Ie, set to zero.
   1174  0716							;
   1175  0716		       a9 00	   iVINIT     lda	#0
   1176  0718		       a2 00		      ldx	#0
   1177  071a		       95 41	   Vinit2     sta	variables,x
   1178  071c		       e8		      inx
   1179  071d		       e0 34		      cpx	#variablesEnd-variables
   1180  071f		       d0 f9		      bne	Vinit2
   1181  0721		       4c c5 02 	      jmp	NextIL
   1182  0724							;
   1183  0724							;=====================================================
   1184  0724							; Set the address of the error handler.  After any
   1185  0724							; error, set to the ILPC to the specified location.
   1186  0724							;
   1187  0724		       20 10 09    iERRGOTO   jsr	getILWord
   1188  0727		       8e 27 11 	      stx	errGoto
   1189  072a		       8d 28 11 	      sta	errGoto+1
   1190  072d		       4c c5 02 	      jmp	NextIL
   1191  0730							;
   1192  0730							;=====================================================
   1193  0730							; TST is followed by an 8 bit signed offset, then a
   1194  0730							; null terminated string.  Compare the string against
   1195  0730							; the string starting at (CURPTR),CUROFF.  If the
   1196  0730							; strings match, continue executing the next IL
   1197  0730							; opcode.  Else, add the offset to ILPC.
   1198  0730							;
   1199  0730		       20 14 09    iTST       jsr	getILByte
   1200  0733		       85 7c		      sta	offset
   1201  0735							;
   1202  0735		       20 04 0b 	      jsr	saveIL	;in case of failure
   1203  0738		       a4 80		      ldy	CUROFF
   1204  073a		       84 77		      sty	dpl	;save for later
   1205  073c							;
   1206  073c		       20 14 09    iTSTloop   jsr	getILByte	;get next char
   1207  073f		       f0 11		      beq	iTSTm	;match!
   1208  0741		       a4 77		      ldy	dpl
   1209  0743		       d1 7e		      cmp	(CURPTR),y
   1210  0745		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1211  0747		       09 20		      ora	#$20	; lets allow lowercase as well
   1212  0749		       d1 7e		      cmp	(CURPTR),y
   1213  074b		       d0 0c		      bne	iTSTfail	;mismatch
   1214  074d		       c8	   iTSTUpper  iny
   1215  074e		       84 77		      sty	dpl
   1216  0750		       d0 ea		      bne	iTSTloop
   1217  0752							;
   1218  0752							; It's a match!  Clean up a bit.
   1219  0752							;
   1220  0752		       a4 77	   iTSTm      ldy	dpl
   1221  0754		       84 80		      sty	CUROFF
   1222  0756		       4c c5 02 	      jmp	NextIL
   1223  0759							;
   1224  0759							; Not a match, reset ILPC and then move to the
   1225  0759							; offset.
   1226  0759							;
   1227  0759		       20 0d 0b    iTSTfail   jsr	restoreIL
   1228  075c		       4c 00 08 	      jmp	tstBranch
   1229  075f							;
   1230  075f							;=================================================JLIT=
   1231  075f							; Test if we have a let statement without the let keyword
   1232  075f		       20 14 09    iTSTLET    jsr	getILByte
   1233  0762		       85 7c		      sta	offset
   1234  0764		       20 04 0b 	      jsr	saveIL	; save to restore when done
   1235  0767
   1236  0767		       a4 80		      ldy	CUROFF
   1237  0769		       20 0f 0c 	      jsr	SkipSpaces
   1238  076c		       c8		      iny		; skip the Variable name
   1239  076d		       20 0f 0c 	      jsr	SkipSpaces	; skip any SkipSpaces
   1240  0770		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1241  0772		       c9 3d		      cmp	#'=	; check if equals
   1242  0774		       d0 e3		      bne	iTSTfail	; return it failed
   1243  0776		       20 0d 0b 	      jsr	restoreIL	; restore the IL anyway
   1244  0779		       4c c5 02 	      jmp	NextIL	; Then next instruction
   1245  077c							;
   1246  077c							;================================================jLIT=
   1247  077c							;Test for end of line
   1248  077c							;
   1249  077c		       20 14 09    iTSTDONE   jsr	getILByte
   1250  077f		       85 7c		      sta	offset
   1251  0781		       20 04 0b 	      jsr	saveIL
   1252  0784
   1253  0784		       a4 80		      ldy	CUROFF
   1254  0786		       84 77		      sty	dpl
   1255  0788		       20 0f 0c 	      jsr	SkipSpaces
   1256  078b		       b1 7e		      lda	(CURPTR),y
   1257  078d		       f0 07		      beq	iTSTDONEtrue
   1258  078f		       a4 77		      ldy	dpl
   1259  0791		       84 80		      sty	CUROFF
   1260  0793		       4c 59 07 	      jmp	iTSTfail
   1261  0796							;
   1262  0796							; Advance to the next line
   1263  0796							;
   1264  0796		       4c c5 02    iTSTDONEtrue jmp	NextIL
   1265  0799							;
   1266  0799							;=====================================================
   1267  0799							; TSTV is followed by an 8 bit signed offset.	If the
   1268  0799							; value at (CURPTR),CUROFF appears to be a variable
   1269  0799							; name, move to the next IL statement.  Else, add the
   1270  0799							; offset to ILPC.
   1271  0799							;
   1272  0799		       20 14 09    iTSTV      jsr	getILByte	;offset
   1273  079c		       85 7c		      sta	offset
   1274  079e							;
   1275  079e		       a4 80		      ldy	CUROFF
   1276  07a0		       20 0f 0c 	      jsr	SkipSpaces
   1277  07a3		       b1 7e		      lda	(CURPTR),y
   1278  07a5							;
   1279  07a5		       09 20		      ora	#$20	;make lower then upper
   1280  07a7		       49 20		      eor	#$20	;allow lower case here
   1281  07a9		       c9 41		      cmp	#'A
   1282  07ab		       90 53		      bcc	tstBranch
   1283  07ad		       c9 5b		      cmp	#'Z+1
   1284  07af		       b0 4f		      bcs	tstBranch
   1285  07b1							;
   1286  07b1							; The condition is true, so convert to an index, push
   1287  07b1							; it onto the stack and continue running.
   1288  07b1							;
   1289  07b1		       38		      sec
   1290  07b2		       e9 41		      sbc	#'A	;index is zero based
   1291  07b4		       0a		      asl		;multiply by two
   1292  07b5		       85 83		      sta	R0
   1293  07b7		       a9 00		      lda	#0
   1294  07b9		       85 84		      sta	R0+1
   1295  07bb		       20 16 0b 	      jsr	pushR0	;put index onto stack
   1296  07be		       e6 80		      inc	CUROFF	;move to next input char
   1297  07c0		       4c c5 02 	      jmp	NextIL
   1298  07c3							;
   1299  07c3							;=====================================================
   1300  07c3							; TSTL seems basically the same as TSTN, but leave the
   1301  07c3							; value in R0 instead of pushing onto stack.
   1302  07c3							; This tests for a valid line number
   1303  07c3							;
   1304  07c3		       20 14 09    iTSTL      jsr	getILByte
   1305  07c6		       85 7c		      sta	offset
   1306  07c8							;
   1307  07c8		       a4 80		      ldy	CUROFF
   1308  07ca		       20 0f 0c 	      jsr	SkipSpaces
   1309  07cd		       b1 7e		      lda	(CURPTR),y
   1310  07cf							;
   1311  07cf		       c9 30		      cmp	#'0
   1312  07d1		       90 2d		      bcc	tstBranch
   1313  07d3		       c9 3a		      cmp	#'9+1
   1314  07d5		       b0 29		      bcs	tstBranch
   1315  07d7							;
   1316  07d7							; It's a digit, so convert to a number.
   1317  07d7							;
   1318  07d7		       20 25 0a 	      jsr	getDecimal
   1319  07da		       4c c5 02 	      jmp	NextIL
   1320  07dd							;
   1321  07dd							;=====================================================
   1322  07dd							; TSTN checks for a number.  This is very simplistic;
   1323  07dd							; if the character is a digit, assume it's a number.
   1324  07dd							; Convert to a number and push it onto the stack.
   1325  07dd							;
   1326  07dd		       20 14 09    iTSTN      jsr	getILByte
   1327  07e0		       85 7c		      sta	offset
   1328  07e2							;
   1329  07e2		       a4 80		      ldy	CUROFF
   1330  07e4		       20 0f 0c 	      jsr	SkipSpaces
   1331  07e7		       b1 7e		      lda	(CURPTR),y
   1332  07e9		       c9 2d		      cmp	#'-	;negative?
   1333  07eb		       f0 08		      beq	iTSTN_1
   1334  07ed		       c9 30		      cmp	#'0
   1335  07ef		       90 0f		      bcc	tstBranch
   1336  07f1		       c9 3a		      cmp	#'9+1
   1337  07f3		       b0 0b		      bcs	tstBranch
   1338  07f5							;
   1339  07f5							; It's a digit, so convert to a number.
   1340  07f5							;
   1341  07f5		       20 25 0a    iTSTN_1    jsr	getDecimal
   1342  07f8		       84 80		      sty	CUROFF
   1343  07fa		       20 16 0b 	      jsr	pushR0	;save onto stack
   1344  07fd		       4c c5 02 	      jmp	NextIL
   1345  0800
   1346  0800							;
   1347  0800							; Common jump point for all TSTx instructions that
   1348  0800							; fail to meet the requirements.  This takes the
   1349  0800							; offset and adds/subtracts to/from ILPC.
   1350  0800							;
   1351  0800		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1352  0802		       10 0e		      bpl	tstPositive
   1353  0804							;
   1354  0804							; Do negative branch.	Do sign extension.
   1355  0804							;
   1356  0804		       18		      clc
   1357  0805		       65 75		      adc	ILPC
   1358  0807		       85 75		      sta	ILPC
   1359  0809		       a5 76		      lda	ILPC+1
   1360  080b		       69 ff		      adc	#$ff
   1361  080d		       85 76		      sta	ILPC+1
   1362  080f		       4c c5 02 	      jmp	NextIL	;keep going
   1363  0812							;
   1364  0812		       18	   tstPositive clc
   1365  0813		       65 75		      adc	ILPC
   1366  0815		       85 75		      sta	ILPC
   1367  0817		       a5 76		      lda	ILPC+1
   1368  0819		       69 00		      adc	#0
   1369  081b		       85 76		      sta	ILPC+1
   1370  081d		       4c c5 02 	      jmp	NextIL
   1371  0820							;
   1372  0820							;=====================================================
   1373  0820							; This places the number of free bytes on top of the
   1374  0820							; stack.
   1375  0820							;
   1376  0820		       20 5d 0c    iFREE      jsr	GetSizes
   1377  0823		       20 16 0b 	      jsr	pushR0
   1378  0826		       4c c5 02 	      jmp	NextIL
   1379  0829							;
   1380  0829							;=====================================================
   1381  0829							; Generate a random number from 0-FFFF and then MOD
   1382  0829							; it with the value on top of stack.  Leaves number on
   1383  0829							; stack
   1384  0829							;
   1385  0829		       20 7d 0b    iRANDOM    jsr	popR1	;mod value
   1386  082c							;
   1387  082c							; If the value is zero, just return a one.
   1388  082c							;
   1389  082c		       a5 83		      lda	R0
   1390  082e		       05 84		      ora	R0+1
   1391  0830		       f0 63		      beq	irandom1
   1392  0832							;
   1393  0832		       ad 2e 11 	      lda	random+1
   1394  0835		       8d 2c 11 	      sta	rtemp1
   1395  0838		       ad 2d 11 	      lda	random
   1396  083b		       0a		      asl
   1397  083c		       2e 2c 11 	      rol	rtemp1
   1398  083f		       0a		      asl
   1399  0840		       2e 2c 11 	      rol	rtemp1
   1400  0843		       18		      clc
   1401  0844		       6d 2d 11 	      adc	random
   1402  0847		       48		      pha
   1403  0848		       ad 2c 11 	      lda	rtemp1
   1404  084b		       6d 2e 11 	      adc	random+1
   1405  084e		       8d 2e 11 	      sta	random+1
   1406  0851		       68		      pla
   1407  0852		       69 11		      adc	#$11
   1408  0854		       8d 2d 11 	      sta	random
   1409  0857		       ad 2e 11 	      lda	random+1
   1410  085a		       69 36		      adc	#$36
   1411  085c		       8d 2e 11 	      sta	random+1
   1412  085f
   1413  085f		       ad 2d 11 	      lda	random
   1414  0862		       85 83		      sta	R0
   1415  0864		       ad 2e 11 	      lda	random+1
   1416  0867		       29 7f		      and	#$7f	;make positive
   1417  0869		       85 84		      sta	R0+1
   1418  086b							;
   1419  086b							; R0 contains the number and R1 contains the max value.
   1420  086b							;
   1421  086b		       a5 83	   iRANDOM_2  lda	R0
   1422  086d		       c5 85		      cmp	R1
   1423  086f		       d0 16		      bne	iRANDOM_1
   1424  0871		       a5 84		      lda	R0+1
   1425  0873		       c5 86		      cmp	R1+1
   1426  0875		       d0 10		      bne	iRANDOM_1	;need to subtract
   1427  0877							;
   1428  0877							; Subtract R1 from R0
   1429  0877							;
   1430  0877		       38	   iRANDOM_sub sec
   1431  0878		       a5 83		      lda	R0
   1432  087a		       e5 85		      sbc	R1
   1433  087c		       85 83		      sta	R0
   1434  087e		       a5 84		      lda	R0+1
   1435  0880		       e5 86		      sbc	R1+1
   1436  0882		       85 84		      sta	R0+1
   1437  0884		       4c 6b 08 	      jmp	iRANDOM_2
   1438  0887							;
   1439  0887							; See if R1 > R0.  If so, branch to subtract.
   1440  0887							;
   1441  0887		       a5 83	   iRANDOM_1  lda	R0
   1442  0889		       c5 85		      cmp	R1
   1443  088b		       a5 84		      lda	R0+1
   1444  088d		       e5 86		      sbc	R1+1
   1445  088f		       50 02		      bvc	iRANDOM_4
   1446  0891		       49 80		      eor	#$80
   1447  0893		       10 e2	   iRANDOM_4  bpl	iRANDOM_sub
   1448  0895							;
   1449  0895							; All done.  Almost.  Add one, then push the result.
   1450  0895							;
   1451  0895		       e6 83	   irandom1   inc	R0
   1452  0897		       d0 02		      bne	iRANDOM_3
   1453  0899		       e6 84		      inc	R0+1
   1454  089b		       20 16 0b    iRANDOM_3  jsr	pushR0	;return value
   1455  089e		       4c c5 02 	      jmp	NextIL
   1456  08a1							;
   1457  08a1							; Poke a value into a memory location
   1458  08a1		       20 53 0b    iPOKEMEMORY jsr	popR0
   1459  08a4		       20 7d 0b 	      jsr	popR1
   1460  08a7		       a0 00		      ldy	#0
   1461  08a9		       a5 83		      lda	R0
   1462  08ab		       91 85		      sta	(R1),y
   1463  08ad		       4c c5 02 	      jmp	NextIL
   1464  08b0							;
   1465  08b0							; Get a value from a memory location
   1466  08b0							;
   1467  08b0		       20 53 0b    iPEEKMEMORY jsr	popR0
   1468  08b3		       a0 00		      ldy	#0
   1469  08b5		       b1 83		      lda	(R0),y
   1470  08b7		       4c dc 08 	      jmp	iPutStack
   1471  08ba							;
   1472  08ba							; Call to address return what ever is in a to the stack
   1473  08ba							; func2 will load a value into a before the call
   1474  08ba		       20 7d 0b    iCallFunc2 jsr	popR1
   1475  08bd		       a5 85		      lda	R1
   1476  08bf		       20 ce 08    iCallFunc  jsr	iCallRtn
   1477  08c2		       85 83		      sta	R0
   1478  08c4		       a9 00		      lda	#0
   1479  08c6		       85 84		      sta	R0+1
   1480  08c8		       20 16 0b 	      jsr	pushR0
   1481  08cb		       4c c5 02 	      jmp	NextIL
   1482  08ce		       20 53 0b    iCallRtn   jsr	popR0
   1483  08d1		       6c 83 00 	      jmp	(R0)
   1484  08d4
   1485  08d4
   1486  08d4							;===========================================jlit======
   1487  08d4							;Get a character from the terminal convert to value
   1488  08d4							;leave the number on top f the stack
   1489  08d4							;
   1490  08d4		       20 09 02    iGETCHAR   jsr	GETCH
   1491  08d7					      if	CTMON65
   1492  08d7		       48		      pha
   1493  08d8		       20 0c f0 	      jsr	cout	;echo echo echo
   1494  08db		       68		      pla
   1495  08dc					      endif
   1496  08dc		       85 83	   iPutStack  sta	R0
   1497  08de		       a9 00		      lda	#0
   1498  08e0		       85 84		      sta	R0+1
   1499  08e2		       20 16 0b 	      jsr	pushR0
   1500  08e5		       4c c5 02 	      jmp	NextIL
   1501  08e8							;===========================================jlit======
   1502  08e8							;Put a character to the terminal convert to
   1503  08e8							;
   1504  08e8		       20 53 0b    iPUTCHAR   jsr	popR0
   1505  08eb		       a5 83		      lda	R0
   1506  08ed		       20 06 02 	      jsr	OUTCH
   1507  08f0		       4c c5 02 	      jmp	NextIL
   1508  08f3							;
   1509  08f3							;
   1510  08f3							;=====================================================
   1511  08f3							; Replace TOS with its absolute value.
   1512  08f3							;
   1513  08f3		       20 53 0b    iABS       jsr	popR0
   1514  08f6		       a5 84		      lda	R0+1
   1515  08f8		       10 10		      bpl	iABS_1	;already positive
   1516  08fa		       49 ff		      eor	#$ff
   1517  08fc		       85 84		      sta	R0+1
   1518  08fe		       a5 83		      lda	R0
   1519  0900		       49 ff		      eor	#$ff
   1520  0902		       85 83		      sta	R0
   1521  0904		       e6 83		      inc	R0
   1522  0906		       d0 02		      bne	iABS_1
   1523  0908		       e6 84		      inc	R0+1
   1524  090a		       20 16 0b    iABS_1     jsr	pushR0
   1525  090d		       4c c5 02 	      jmp	NextIL
   1526  0910							;================================================================
   1527  0910							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0910					      include	"support.asm"
      1  0910							;
      2  0910							;=====================================================
      3  0910							;=====================================================
      4  0910							;=====================================================
      5  0910							; This marks the start of support functions used by
      6  0910							; the IL opcodes.  These are support functions, NOT
      7  0910							; the IL code.
      8  0910							;=====================================================
      9  0910							;=====================================================
     10  0910					      Seg	code
     11  0910							;=====================================================
     12  0910							; This gets the next two bytes pointed to by ILPC and
     13  0910							; returns them; X contains LSB, A contains MSB.  ILPC
     14  0910							; is advanced by two, and Y contains 0 on return.
     15  0910
     16  0910							;
     17  0910		       20 14 09    getILWord  jsr	getILByte	;LSB
     18  0913		       aa		      tax
     19  0914							;
     20  0914							;=====================================================
     21  0914							; This gets the next byte pointed to by ILPC and
     22  0914							; returns it in A.  On return, X is unchanged but Y
     23  0914							; contains 0.
     24  0914							;
     25  0914		       a0 00	   getILByte  ldy	#0
     26  0916		       b1 75		      lda	(ILPC),y	;get byte
     27  0918		       08		      php		;save status
     28  0919		       e6 75		      inc	ILPC	;inc LSB
     29  091b		       d0 02		      bne	getILb2	;branch if no overflow
     30  091d		       e6 76		      inc	ILPC+1	;inc MSB
     31  091f		       28	   getILb2    plp		;restore status
     32  0920		       60		      rts
     33  0921							;
     34  0921							;=====================================================
     35  0921							; Decrement ILPC by one.
     36  0921							;
     37  0921		       a5 75	   decIL      lda	ILPC
     38  0923		       d0 02		      bne	decIL2
     39  0925		       c6 76		      dec	ILPC+1
     40  0927		       c6 75	   decIL2     dec	ILPC
     41  0929		       60		      rts
     42  092a							;
     43  092a							;=====================================================
     44  092a							; Push the ILPC onto the return stack.  Actually, this
     45  092a							; pushes the address of ILPC+2 since that's the next
     46  092a							; address to execute.
     47  092a							;
     48  092a		       ac 9d 10    pushILPC   ldy	retStackPtr
     49  092d		       a5 75		      lda	ILPC
     50  092f		       18		      clc
     51  0930		       69 02		      adc	#2
     52  0932		       99 8d 10 	      sta	retStack,y
     53  0935		       08		      php		;save C bit
     54  0936		       c8		      iny
     55  0937		       a5 76		      lda	ILPC+1
     56  0939		       28		      plp		;restore C
     57  093a		       69 00		      adc	#0
     58  093c		       99 8d 10 	      sta	retStack,y
     59  093f		       c8		      iny
     60  0940		       8c 9d 10 	      sty	retStackPtr
     61  0943		       60		      rts
     62  0944							;
     63  0944							;=====================================================
     64  0944							; Pull the top entry from return stack and put into
     65  0944							; ILPC.
     66  0944							;
     67  0944		       ac 9d 10    popILPC    ldy	retStackPtr
     68  0947		       88		      dey
     69  0948		       b9 8d 10 	      lda	retStack,y
     70  094b		       85 76		      sta	ILPC+1
     71  094d		       88		      dey
     72  094e		       b9 8d 10 	      lda	retStack,y
     73  0951		       85 75		      sta	ILPC
     74  0953		       8c 9d 10 	      sty	retStackPtr
     75  0956		       60		      rts
     76  0957							;
     77  0957							;=====================================================
     78  0957							; This searches for a specific line number that is in
     79  0957							; R0.	There are three possible return conditions:
     80  0957							; Line numbers are now the third byte, the first byte is now **************
     81  0957							; a pointer to the next line, of course no longer that 53 byte
     82  0957							; per line.
     83  0957							;
     84  0957							; Exact match was found:
     85  0957							;    * Z set
     86  0957							;    * CURPTR points to two-byte line number for that
     87  0957							;	line.
     88  0957							;
     89  0957							; Next highest line found:
     90  0957							;    * Z cleared
     91  0957							;    * C set
     92  0957							;    * CURPTR points to two-byte line number for that
     93  0957							;	line.
     94  0957							;
     95  0957							; End of program reached:
     96  0957							;    * Z cleared
     97  0957							;    * C cleared
     98  0957							;    * CURPTR points to first free byte at end of
     99  0957							;	program.  Ie, it has save value as PROGRAMEND.
    100  0957							;
    101  0957							; A, X, and Y are all undefined on return.
    102  0957							;
    103  0957
    104  0957		       a9 39	   findLine   lda	#ProgramStart&$ff	;Start of program -> CURPTR
    105  0959		       85 7e		      sta	CURPTR
    106  095b		       a9 11		      lda	#ProgramStart>>8
    107  095d		       85 7f		      sta	CURPTR+1
    108  095f							;
    109  095f							; At end of code?
    110  095f							;
    111  095f		       a5 7e	   iXFER1     lda	CURPTR	; chk CURPTR = END PROGRAM
    112  0961		       cd 31 11 	      cmp	PROGRAMEND
    113  0964		       d0 0b		      bne	xfer2	;not end
    114  0966		       a5 7f		      lda	CURPTR+1
    115  0968		       cd 32 11 	      cmp	PROGRAMEND+1
    116  096b		       d0 04		      bne	xfer2	;Not at end
    117  096d							;
    118  096d							; Line not found and the end of the program was
    119  096d							; reached.  Return Z and C both clear.
    120  096d							;
    121  096d		       a9 01		      lda	#1	;clear Z
    122  096f		       18		      clc		;clear C
    123  0970		       60		      rts
    124  0971							;
    125  0971							; Check for an exact line number match
    126  0971							;
    127  0971		       a5 83	   xfer2      lda	R0
    128  0973		       a0 01		      ldy	#1	; changed to skip extra length byte
    129  0975		       d1 7e		      cmp	(CURPTR),y
    130  0977		       d0 08		      bne	xfernotit
    131  0979		       c8		      iny
    132  097a		       a5 84		      lda	R0+1
    133  097c		       d1 7e		      cmp	(CURPTR),y
    134  097e		       d0 01		      bne	xfernotit	; not a matching line number
    135  0980							;
    136  0980							; This is exactly the line we want.
    137  0980							;
    138  0980		       60		      rts		;it matches exactly
    139  0981							;
    140  0981							; See if this line is greater than the one we're
    141  0981							; searching for.
    142  0981							;
    143  0981		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    144  0983		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    145  0985		       c5 84		      cmp	R0+1
    146  0987		       90 0b		      bcc	xfer3
    147  0989		       d0 07		      bne	xfer4
    148  098b		       88		      dey
    149  098c		       b1 7e		      lda	(CURPTR),y	;compare LSB
    150  098e		       c5 83		      cmp	R0
    151  0990		       90 02		      bcc	xfer3
    152  0992							;
    153  0992							; This line is greater than the one we want, so
    154  0992							; return Z clear and C set.
    155  0992							;
    156  0992		       38	   xfer4      sec		;We found a line number greater
    157  0993		       60		      rts		;both conditions set
    158  0994							;
    159  0994							; Not the line (or droid) we're looking for.  Move to
    160  0994							; the next line.
    161  0994							;
    162  0994		       20 9a 09    xfer3      jsr	FindNextLine
    163  0997		       4c 5f 09 	      jmp	iXFER1
    164  099a							;
    165  099a							;=====================================================
    166  099a							; This advances CURPTR to the next line.  If there
    167  099a							; are no more lines, this leaves CURPTR equal to
    168  099a							; ProgramEnd.	Returns CUROFF set to 2.  This assumes
    169  099a							; CURPTR is pointing to a valid line on entry.  This
    170  099a							; pointer points to the two-byte line number.
    171  099a							; Update this points to the 1 byte line length  ****************
    172  099a							;
    173  099a				   FindNextLine
    174  099a		       a0 03		      ldy	#3	;skip line number and length byte
    175  099c		       84 80		      sty	CUROFF	;this is the new offset
    176  099e		       a0 00		      ldy	#0
    177  09a0		       b1 7e		      lda	(CURPTR),y	;Get the length
    178  09a2		       18		      clc
    179  09a3		       65 7e		      adc	CURPTR
    180  09a5		       85 7e		      sta	CURPTR
    181  09a7		       90 02		      bcc	FindNext4	;exit
    182  09a9		       e6 7f		      inc	CURPTR+1
    183  09ab		       60	   FindNext4  rts
    184  09ac							;
    185  09ac							;=====================================================
    186  09ac							; This compares CURPTR to PROGRAMEND and returns Z set
    187  09ac							; if they are equal, Z clear if not.
    188  09ac							;
    189  09ac		       a5 7e	   AtEnd      lda	CURPTR
    190  09ae		       cd 31 11 	      cmp	PROGRAMEND
    191  09b1		       d0 05		      bne	atendexit
    192  09b3		       a5 7f		      lda	CURPTR+1
    193  09b5		       cd 32 11 	      cmp	PROGRAMEND+1
    194  09b8		       60	   atendexit  rts
    195  09b9							;
    196  09b9							;=====================================================
    197  09b9							; Print the contents of R0 as a signed decimal number.
    198  09b9							; Does leading zero suppression.
    199  09b9							;
    200  09b9				   PrintDecimal
    201  09b9		       a5 84		      lda	R0+1	;MSB has sign
    202  09bb		       10 17		      bpl	pplus	;it's a positive number
    203  09bd							;
    204  09bd							; Negative numbers need more work.  Invert all the bits,
    205  09bd							; then add one.
    206  09bd							;
    207  09bd		       a9 2d		      lda	#'-
    208  09bf		       20 9b 0c 	      jsr	VOUTCH	;print the negative sign
    209  09c2							;
    210  09c2		       a5 83		      lda	R0	;invert bits
    211  09c4		       49 ff		      eor	#$ff
    212  09c6		       85 83		      sta	R0
    213  09c8		       a5 84		      lda	R0+1
    214  09ca		       49 ff		      eor	#$ff
    215  09cc		       85 84		      sta	R0+1
    216  09ce		       e6 83		      inc	R0	;add one
    217  09d0		       d0 02		      bne	pplus
    218  09d2		       e6 84		      inc	R0+1
    219  09d4							;
    220  09d4							; Print the value in R0 as a positive number.
    221  09d4							;
    222  09d4		       a2 00	   pplus      ldx	#0	;start of subtraction table
    223  09d6		       8e 25 11 	      stx	diddigit	;no digits yet
    224  09d9		       a0 00	   pploop     ldy	#0	;result of division
    225  09db		       a5 83	   pploop2    lda	R0	;LSB
    226  09dd		       38		      sec
    227  09de		       fd 1d 0a 	      sbc	dectable,x
    228  09e1		       85 83		      sta	R0
    229  09e3		       a5 84		      lda	R0+1
    230  09e5		       fd 1e 0a 	      sbc	dectable+1,x
    231  09e8		       10 2e		      bpl	pplusok	;no underflow
    232  09ea							;
    233  09ea							; Else, underflow.  Add back in the LSB of the
    234  09ea							; table to R0.
    235  09ea							;
    236  09ea		       18		      clc
    237  09eb		       a5 83		      lda	R0
    238  09ed		       7d 1d 0a 	      adc	dectable,x
    239  09f0		       85 83		      sta	R0
    240  09f2							;
    241  09f2							; Print the value in Y.  Actually, see if Y is zero and
    242  09f2							; whether any digit has been printed yet.  If Y isn't
    243  09f2							; zero or we've printed a digit, go ahead and print.
    244  09f2							;
    245  09f2		       8e 24 11 	      stx	printtx
    246  09f5		       98		      tya
    247  09f6		       09 00		      ora	#0	;set flags
    248  09f8		       d0 05		      bne	pprintit	;non-zero, print
    249  09fa							;
    250  09fa		       ad 25 11 	      lda	diddigit
    251  09fd		       f0 09		      beq	pprintno	;don't print
    252  09ff							;
    253  09ff		       98	   pprintit   tya
    254  0a00		       09 30		      ora	#'0
    255  0a02		       8d 25 11 	      sta	diddigit
    256  0a05		       20 9b 0c 	      jsr	VOUTCH
    257  0a08		       ae 24 11    pprintno   ldx	printtx
    258  0a0b							;
    259  0a0b							; Move to the next table entry
    260  0a0b							;
    261  0a0b		       e8		      inx
    262  0a0c		       e8		      inx
    263  0a0d		       e0 08		      cpx	#dectableend-dectable
    264  0a0f		       d0 c8		      bne	pploop	;not at end
    265  0a11							;
    266  0a11							; At the end.	R0 contains the final value
    267  0a11							; to print.
    268  0a11							;
    269  0a11		       a5 83		      lda	R0
    270  0a13		       09 30		      ora	#'0
    271  0a15		       4c 9b 0c 	      jmp	VOUTCH
    272  0a18							;
    273  0a18							; Finish doing the subtraction.
    274  0a18							;
    275  0a18		       85 84	   pplusok    sta	R0+1
    276  0a1a		       c8		      iny
    277  0a1b		       d0 be		      bne	pploop2
    278  0a1d							;
    279  0a1d							; Table of powers-of-ten
    280  0a1d							;
      0  0a1d				   dectable   dw	10000
      1  0a1d		       10 27		      .word.w	10000
      0  0a1f					      dw	1000
      1  0a1f		       e8 03		      .word.w	1000
      0  0a21					      dw	100
      1  0a21		       64 00		      .word.w	100
      0  0a23					      dw	10
      1  0a23		       0a 00		      .word.w	10
    285  0a23		       0a 25	   dectableend equ	*
    286  0a25							;
    287  0a25							;=====================================================
    288  0a25							; Convert an ASCII string to a number.  On input,
    289  0a25							; (CURPTR),Y points to the first digit.  This gets
    290  0a25							; digit-by-digit until finding a non-number.  Returns
    291  0a25							; Y pointing to the non-digit, and R0 contains the
    292  0a25							; number.  This does NOT check for valid ranges, so
    293  0a25							; a value like "123456789" will produce something,
    294  0a25							; but not what you had expected.
    295  0a25							;
    296  0a25		       a9 00	   getDecimal lda	#0
    297  0a27		       85 83		      sta	R0
    298  0a29		       85 84		      sta	R0+1
    299  0a2b		       85 77		      sta	dpl	;temporary negative flag
    300  0a2d							;
    301  0a2d							; See if it's negative...
    302  0a2d							;
    303  0a2d		       84 13		      sty	$0013
    304  0a2f		       b1 7e		      lda	(CURPTR),y
    305  0a31		       c9 2d		      cmp	#'-
    306  0a33		       d0 02		      bne	getDecLoop
    307  0a35		       e6 77		      inc	dpl	;it's negative
    308  0a37							;
    309  0a37		       b1 7e	   getDecLoop lda	(CURPTR),y
    310  0a39		       c9 30		      cmp	#'0
    311  0a3b		       90 36		      bcc	getDdone
    312  0a3d		       c9 3a		      cmp	#'9+1
    313  0a3f		       b0 32		      bcs	getDdone
    314  0a41		       38		      sec
    315  0a42		       e9 30		      sbc	#'0	;convert to binary
    316  0a44		       48		      pha
    317  0a45							;
    318  0a45							; Now multiply R0 by 10.  Remember that
    319  0a45							; 2*N + 8*N = 10*N.
    320  0a45							;
    321  0a45		       06 83		      asl	R0
    322  0a47		       26 84		      rol	R0+1	;*2
    323  0a49		       a5 83		      lda	R0
    324  0a4b		       85 85		      sta	R1
    325  0a4d		       a5 84		      lda	R0+1
    326  0a4f		       85 86		      sta	R1+1
    327  0a51		       06 83		      asl	R0
    328  0a53		       26 84		      rol	R0+1	;*4
    329  0a55		       06 83		      asl	R0
    330  0a57		       26 84		      rol	R0+1	;*8
    331  0a59		       18		      clc		;now add the partial sums...
    332  0a5a		       a5 83		      lda	R0	;...to get *10
    333  0a5c		       65 85		      adc	R1
    334  0a5e		       85 83		      sta	R0
    335  0a60		       a5 84		      lda	R0+1
    336  0a62		       65 86		      adc	R1+1
    337  0a64		       85 84		      sta	R0+1
    338  0a66							;
    339  0a66							; Add in the new digit
    340  0a66							;
    341  0a66		       68		      pla
    342  0a67		       18		      clc
    343  0a68		       65 83		      adc	R0
    344  0a6a		       85 83		      sta	R0
    345  0a6c		       90 02		      bcc	getD2
    346  0a6e		       e6 84		      inc	R0+1
    347  0a70							;
    348  0a70							; Move to next character
    349  0a70							;
    350  0a70		       c8	   getD2      iny
    351  0a71		       d0 c4		      bne	getDecLoop
    352  0a73							;
    353  0a73							; All done with digits, so now deal with it being
    354  0a73							; negative.  If zero, then don't check for negative
    355  0a73							; flag.  Ie, -0 is stored as 0.
    356  0a73							;
    357  0a73		       a5 83	   getDdone   lda	R0
    358  0a75		       05 84		      ora	R0+1
    359  0a77		       f0 16		      beq	getDone2	;zero
    360  0a79		       a5 77		      lda	dpl
    361  0a7b		       f0 12		      beq	getDone2	;positive
    362  0a7d							;
    363  0a7d							; Invert all the bits, then add one.
    364  0a7d							;
    365  0a7d		       a5 83		      lda	R0
    366  0a7f		       49 ff		      eor	#$ff
    367  0a81		       85 83		      sta	R0
    368  0a83		       a5 84		      lda	R0+1
    369  0a85		       49 ff		      eor	#$ff
    370  0a87		       85 84		      sta	R0+1
    371  0a89							;
    372  0a89		       e6 83		      inc	R0
    373  0a8b		       d0 02		      bne	getDone2
    374  0a8d		       e6 84		      inc	R0+1
    375  0a8f				   getDone2
    376  0a8f		       a5 83		      lda	R0
    377  0a91		       85 10		      sta	$0010
    378  0a93		       a5 84		      lda	R0+1
    379  0a95		       85 11		      sta	$0011
    380  0a97		       a5 77		      lda	dpl
    381  0a99		       85 12		      sta	$012
    382  0a9b
    383  0a9b		       60		      rts
    384  0a9c							;
    385  0a9c							;=====================================================
    386  0a9c							; Print the string that immediately follows the JSR to
    387  0a9c							; this function.  Stops when a null byte is found,
    388  0a9c							; then returns to the instruction immediately
    389  0a9c							; following the null.
    390  0a9c							;
    391  0a9c							; Thanks to Ross Archer for this code.
    392  0a9c							; http://www.6502.org/source/io/primm.htm
    393  0a9c							;
    394  0a9c				  -	      if	KIM
    395  0a9c				  -puts       sty	putsy
    396  0a9c				  -	      pla		;low part of "return" address
    397  0a9c				  -			;(data start address)
    398  0a9c				  -	      sta	dpl
    399  0a9c				  -	      pla
    400  0a9c				  -	      sta	dpl+1	;high part of "return" address
    401  0a9c				  -			;(data start address)
    402  0a9c				  -			;Note: we're pointing one short
    403  0a9c				  -psinb      ldy	#1
    404  0a9c				  -	      lda	(dpl),y	;Get next string character
    405  0a9c				  -	      inc	dpl	;update the pointer
    406  0a9c				  -	      bne	psinc	;if not, we're pntng to next char
    407  0a9c				  -	      inc	dpl+1	;account for page crossing
    408  0a9c				  -psinc      ora	#0	;Set flags according to contents of
    409  0a9c				  -			;   Accumulator
    410  0a9c				  -	      beq	psix1	;don't print the final NULL
    411  0a9c				  -	      jsr	OUTCH	;write it out
    412  0a9c				  -	      jmp	psinb	;back around
    413  0a9c				  -psix1      inc	dpl
    414  0a9c				  -	      bne	psix2
    415  0a9c				  -	      inc	dpl+1	;account for page crossing
    416  0a9c				  -psix2      ldy	putsy
    417  0a9c				  -	      jmp	(dpl)	;return to byte following NULL
    418  0a9c					      endif
    419  0a9c							;
    420  0a9c							;=====================================================
    421  0a9c							; Gets a line of input into LINBUF.
    422  0a9c							;
    423  0a9c							; On entry:
    424  0a9c							;    A contains the prompt character, or 0 if none.
    425  0a9c							;
    426  0a9c							; On exit:
    427  0a9c							;    CURPTR points to LINBUF
    428  0a9c							;    LINBUF contains the line with 0 at the end.
    429  0a9c							;    Y has offset to first non-space character
    430  0a9c							;    CURROFF has the same as Y.
    431  0a9c							;
    432  0a9c		       a2 9f	   GetLine    ldx	#LINBUF&$ff
    433  0a9e		       86 7e		      stx	CURPTR
    434  0aa0		       a2 10		      ldx	#LINBUF>>8
    435  0aa2		       86 7f		      stx	CURPTR+1
    436  0aa4							;
    437  0aa4							; Prompt
    438  0aa4							;
    439  0aa4		       48		      pha		;save for retries
    440  0aa5		       68	   GetLinePr  pla		;restore
    441  0aa6		       48		      pha		;save again
    442  0aa7		       09 00		      ora	#0	;any prompt?
    443  0aa9		       f0 08		      beq	getlinenp
    444  0aab		       20 06 02 	      jsr	OUTCH
    445  0aae		       a9 20		      lda	#$20
    446  0ab0		       20 06 02 	      jsr	OUTCH	;space after prompt
    447  0ab3							;
    448  0ab3		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    449  0ab5		       8e 23 11    getline1   stx	getlinx
    450  0ab8		       20 09 02 	      jsr	GETCH
    451  0abb					      if	CTMON65
    452  0abb		       48		      pha
    453  0abc		       20 0c f0 	      jsr	cout	;echo echo echo
    454  0abf		       68		      pla
    455  0ac0					      endif
    456  0ac0		       c9 0d		      cmp	#CR
    457  0ac2		       f0 0d		      beq	getlind	;end of line
    458  0ac4		       c9 08		      cmp	#BS	;backspace?
    459  0ac6		       f0 21		      beq	getlinebs
    460  0ac8		       ae 23 11 	      ldx	getlinx
    461  0acb		       9d 9f 10 	      sta	LINBUF,x
    462  0ace		       e8		      inx
    463  0acf		       d0 e4		      bne	getline1
    464  0ad1							;
    465  0ad1							; CR was hit
    466  0ad1							;
    467  0ad1		       a9 00	   getlind    lda	#0
    468  0ad3		       ae 23 11 	      ldx	getlinx
    469  0ad6		       9d 9f 10 	      sta	LINBUF,x
    470  0ad9		       85 80		      sta	CUROFF
    471  0adb							;
    472  0adb							; Output a CR/LF
    473  0adb							;
    474  0adb		       20 0c 02 	      jsr	CRLF
    475  0ade							;
    476  0ade							; If a blank line, prompt again.
    477  0ade							;
    478  0ade		       a0 00		      ldy	#0
    479  0ae0		       20 0f 0c 	      jsr	SkipSpaces
    480  0ae3		       b1 7e		      lda	(CURPTR),y
    481  0ae5		       f0 be		      beq	GetLinePr	;empty line
    482  0ae7		       68		      pla		;get rid of prompt char
    483  0ae8		       60		      rts
    484  0ae9							;
    485  0ae9							; Backspace was hit
    486  0ae9							;
    487  0ae9		       ae 23 11    getlinebs  ldx	getlinx
    488  0aec		       f0 c7		      beq	getline1	;at start of line
    489  0aee		       ca		      dex
    490  0aef		       4c b5 0a 	      jmp	getline1
    491  0af2							;
    492  0af2							;=====================================================
    493  0af2							; Count the length of the line currently in LINBUF
    494  0af2							; starting at offset Y.  Returns the length in X.  The
    495  0af2							; starting offset in Y should point past the ASCII
    496  0af2							; line number.  Also counts the trailing NULL and two
    497  0af2							; extra bytes for where the line number will be.
    498  0af2							; Update must now include leading length byte not the null at end ****************
    499  0af2							;
    500  0af2				   getLineLength
    501  0af2		       a2 00		      ldx	#0	;size
    502  0af4		       b9 9f 10    getLineL2  lda	LINBUF,y
    503  0af7		       f0 04		      beq	getLineL3
    504  0af9		       c8		      iny
    505  0afa		       e8		      inx
    506  0afb		       d0 f7		      bne	getLineL2
    507  0afd		       e8	   getLineL3  inx		;count null at end
    508  0afe		       e8		      inx		;line number LSB
    509  0aff		       e8		      inx		;MSB
    510  0b00		       e8		      inx		;change: count new leading line length
    511  0b01		       86 7d		      stx	lineLength
    512  0b03		       60		      rts
    513  0b04							;
    514  0b04							;=====================================================
    515  0b04							; Count the length of the line pointed to by CURPTR.
    516  0b04							; This also counts the line number and the terminating
    517  0b04							; null.  Ie, this string returns 8:
    518  0b04							;
    519  0b04							; <lineLow><lineHi>Hello<null>
    520  0b04							;
    521  0b04							; Another way of looking at it: add the return value
    522  0b04							; to the CURPTR and it'll point to the next line's
    523  0b04							; line number.  Returns the value in Y.
    524  0b04							; Update to ject get the leading byte length ********************
    525  0b04							;
    526  0b04							;getCURPTRLength
    527  0b04							;		ldy	CURPTR
    528  0b04							;		ldy	#3	;change: skip line number and leading length byte
    529  0b04							;getCLineL2	lda	(CURPTR),y
    530  0b04							;		beq	getCLineL3
    531  0b04							;		iny
    532  0b04							;		bne	getCLineL2
    533  0b04							;getCLineL3	iny		;count null at end
    534  0b04							;		rts
    535  0b04							;
    536  0b04							;=====================================================
    537  0b04							; This saves ILPC.  This saves to a single save area,
    538  0b04							; so it can't be called more than once.
    539  0b04							;
    540  0b04		       a5 75	   saveIL     lda	ILPC
    541  0b06		       85 79		      sta	tempIL
    542  0b08		       a5 76		      lda	ILPC+1
    543  0b0a		       85 7a		      sta	tempIL+1
    544  0b0c		       60		      rts
    545  0b0d							;
    546  0b0d							;=====================================================
    547  0b0d							; This restores ILPC.
    548  0b0d							;
    549  0b0d		       a5 79	   restoreIL  lda	tempIL
    550  0b0f		       85 75		      sta	ILPC
    551  0b11		       a5 7a		      lda	tempIL+1
    552  0b13		       85 76		      sta	ILPC+1
    553  0b15		       60		      rts
    554  0b16							;
    555  0b16							;=====================================================
    556  0b16							; This pushes R0 onto the stack.
    557  0b16							;
    558  0b16		       ae 8c 10    pushR0     ldx	mathStackPtr
    559  0b19		       a5 83		      lda	R0
    560  0b1b		       9d 7c 10 	      sta	mathStack,x
    561  0b1e		       e8		      inx
    562  0b1f		       a5 84		      lda	R0+1
    563  0b21		       9d 7c 10 	      sta	mathStack,x
    564  0b24		       e8		      inx
    565  0b25		       8e 8c 10 	      stx	mathStackPtr
    566  0b28		       60		      rts
    567  0b29
    568  0b29							;=====================================================
    569  0b29							; This pushes curptr basic current line onto the call stack.
    570  0b29
    571  0b29		       8c 2c 11    pushLN     sty	rtemp1
    572  0b2c		       ac 9e 10 	      ldy	GoSubStackPtr
    573  0b2f		       a5 7e		      lda	CURPTR
    574  0b31		       91 81		      sta	(GOSUBSTACK),y
    575  0b33		       c8		      iny
    576  0b34		       a5 7f		      lda	CURPTR+1
    577  0b36		       91 81		      sta	(GOSUBSTACK),y
    578  0b38		       c8		      iny
    579  0b39		       8c 9e 10 	      sty	GoSubStackPtr
    580  0b3c		       ac 2c 11 	      ldy	rtemp1
    581  0b3f		       60		      rts
    582  0b40							;
    583  0b40							;=====================================================
    584  0b40							; This pushes R1 onto the stack
    585  0b40							;
    586  0b40		       ae 8c 10    pushR1     ldx	mathStackPtr
    587  0b43		       a5 85		      lda	R1
    588  0b45		       9d 7c 10 	      sta	mathStack,x
    589  0b48		       e8		      inx
    590  0b49		       a5 86		      lda	R1+1
    591  0b4b		       9d 7c 10 	      sta	mathStack,x
    592  0b4e		       e8		      inx
    593  0b4f		       8e 8c 10 	      stx	mathStackPtr
    594  0b52		       60		      rts
    595  0b53							;
    596  0b53							;=====================================================
    597  0b53							; This pops Top Of Stack and places it in R0.
    598  0b53							;
    599  0b53		       ae 8c 10    popR0      ldx	mathStackPtr
    600  0b56		       ca		      dex
    601  0b57		       bd 7c 10 	      lda	mathStack,x
    602  0b5a		       85 84		      sta	R0+1
    603  0b5c		       ca		      dex
    604  0b5d		       bd 7c 10 	      lda	mathStack,x
    605  0b60		       85 83		      sta	R0
    606  0b62		       8e 8c 10 	      stx	mathStackPtr
    607  0b65		       60		      rts
    608  0b66							;=====================================================
    609  0b66							; This pops Top Of gosub call Stack and
    610  0b66							; laces it in CURPTR.
    611  0b66							;
    612  0b66		       8c 2c 11    popLN      sty	rtemp1
    613  0b69		       ac 9e 10 	      ldy	GoSubStackPtr
    614  0b6c		       88		      dey
    615  0b6d		       b1 81		      lda	(GOSUBSTACK),y
    616  0b6f		       85 7f		      sta	CURPTR+1
    617  0b71		       88		      dey
    618  0b72		       b1 81		      lda	(GOSUBSTACK),y
    619  0b74		       85 7e		      sta	CURPTR
    620  0b76		       8c 9e 10 	      sty	GoSubStackPtr
    621  0b79		       ac 2c 11 	      ldy	rtemp1
    622  0b7c		       60		      rts
    623  0b7d							;
    624  0b7d							;=====================================================
    625  0b7d							; This pops TOS and places it in R1.
    626  0b7d							;
    627  0b7d		       ae 8c 10    popR1      ldx	mathStackPtr
    628  0b80		       ca		      dex
    629  0b81		       bd 7c 10 	      lda	mathStack,x
    630  0b84		       85 86		      sta	R1+1
    631  0b86		       ca		      dex
    632  0b87		       bd 7c 10 	      lda	mathStack,x
    633  0b8a		       85 85		      sta	R1
    634  0b8c		       8e 8c 10 	      stx	mathStackPtr
    635  0b8f		       60		      rts
    636  0b90							;
    637  0b90							;=====================================================
    638  0b90							; This pops TOS and places it in MQ.
    639  0b90							;
    640  0b90		       ae 8c 10    popMQ      ldx	mathStackPtr
    641  0b93		       ca		      dex
    642  0b94		       bd 7c 10 	      lda	mathStack,x
    643  0b97		       8d 2a 11 	      sta	MQ+1
    644  0b9a		       ca		      dex
    645  0b9b		       bd 7c 10 	      lda	mathStack,x
    646  0b9e		       8d 29 11 	      sta	MQ
    647  0ba1		       8e 8c 10 	      stx	mathStackPtr
    648  0ba4		       60		      rts
    649  0ba5							;
    650  0ba5							;=====================================================
    651  0ba5							; This assists with multiplication and division by
    652  0ba5							; looking at R0 and R1 and saving a flag as to what
    653  0ba5							; sign the result will be.  Math is always done on
    654  0ba5							; positive numbers, so this converts negative numbers
    655  0ba5							; into positives.  On exit, R0 and R1 are both
    656  0ba5							; positive.  If the signs were different then 'signs'
    657  0ba5							; will be non-zero.
    658  0ba5							;
    659  0ba5		       a9 00	   SaveSigns  lda	#0
    660  0ba7		       8d 2b 11 	      sta	sign	;assume positive
    661  0baa		       a5 84		      lda	R0+1	;MSB
    662  0bac		       10 13		      bpl	SaveSigns1
    663  0bae		       ee 2b 11 	      inc	sign	;it's negative
    664  0bb1		       49 ff		      eor	#$ff	;flip bits
    665  0bb3		       85 84		      sta	R0+1
    666  0bb5		       a5 83		      lda	R0
    667  0bb7		       49 ff		      eor	#$ff
    668  0bb9		       85 83		      sta	R0
    669  0bbb		       e6 83		      inc	R0
    670  0bbd		       d0 02		      bne	SaveSigns1
    671  0bbf		       e6 84		      inc	R0+1
    672  0bc1		       a5 86	   SaveSigns1 lda	R1+1
    673  0bc3		       10 1a		      bpl	SaveSigns2
    674  0bc5		       48		      pha
    675  0bc6		       ad 2b 11 	      lda	sign
    676  0bc9		       49 01		      eor	#1
    677  0bcb		       8d 2b 11 	      sta	sign
    678  0bce		       68		      pla
    679  0bcf		       49 ff		      eor	#$ff	;flip bits
    680  0bd1		       85 86		      sta	R1+1
    681  0bd3		       a5 85		      lda	R1
    682  0bd5		       49 ff		      eor	#$ff
    683  0bd7		       85 85		      sta	R1
    684  0bd9		       e6 85		      inc	R1
    685  0bdb		       d0 02		      bne	SaveSigns2
    686  0bdd		       e6 86		      inc	R1+1
    687  0bdf		       60	   SaveSigns2 rts
    688  0be0							;
    689  0be0							;=====================================================
    690  0be0							; This looks at the value of 'signs' and will convert
    691  0be0							; both R0 and R1 to negative if set.
    692  0be0							;
    693  0be0				   RestoreSigns
    694  0be0		       ad 2b 11 	      lda	sign
    695  0be3		       f0 28		      beq	restoresigns2
    696  0be5							;
    697  0be5		       a5 83		      lda	R0
    698  0be7		       d0 02		      bne	restoresigns3
    699  0be9		       c6 84		      dec	R0+1
    700  0beb				   restoresigns3
    701  0beb		       c6 83		      dec	R0
    702  0bed		       a5 83		      lda	R0
    703  0bef		       49 ff		      eor	#$ff
    704  0bf1		       85 83		      sta	R0
    705  0bf3		       a5 84		      lda	R0+1
    706  0bf5		       49 ff		      eor	#$ff
    707  0bf7		       85 84		      sta	R0+1
    708  0bf9							;
    709  0bf9		       a5 85		      lda	R1
    710  0bfb		       d0 02		      bne	restoresigns4
    711  0bfd		       c6 86		      dec	R1+1
    712  0bff				   restoresigns4
    713  0bff		       c6 85		      dec	R1
    714  0c01		       a5 85		      lda	R1
    715  0c03		       49 ff		      eor	#$ff
    716  0c05		       85 85		      sta	R1
    717  0c07		       a5 86		      lda	R1+1
    718  0c09		       49 ff		      eor	#$ff
    719  0c0b		       85 86		      sta	R1+1
    720  0c0d							;
    721  0c0d				   restoresigns2
    722  0c0d		       60		      rts
    723  0c0e							;
    724  0c0e							;=====================================================
    725  0c0e							; Skip over spaces.  Returns Y with the offset to
    726  0c0e							; either the last character in the line, or the first
    727  0c0e							; non-space character.
    728  0c0e							;
    729  0c0e		       c8	   skipsp2    iny
    730  0c0f		       b1 7e	   SkipSpaces lda	(CURPTR),y
    731  0c11		       f0 04		      beq	Skip3	;end of line
    732  0c13		       c9 20		      cmp	#SPACE
    733  0c15		       f0 f7		      beq	skipsp2
    734  0c17		       60	   Skip3      rts
    735  0c18							;
    736  0c18							;=====================================================
    737  0c18							; This is some debug logic which displays the current
    738  0c18							; value of the ILPC and the line buffer.
    739  0c18							;
    740  0c18		       20 12 f0    dbgLine    jsr	puts
      0  0c1b					      db	"ILPC: ",0
      1  0c1b		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    742  0c22		       a5 76		      lda	ILPC+1
    743  0c24		       20 0f 02 	      jsr	OUTHEX
    744  0c27		       a5 75		      lda	ILPC
    745  0c29		       20 0f 02 	      jsr	OUTHEX
    746  0c2c		       a9 20		      lda	#SPACE
    747  0c2e		       20 06 02 	      jsr	OUTCH
    748  0c31		       a0 00		      ldy	#0
    749  0c33		       b1 75		      lda	(ILPC),y
    750  0c35		       20 0f 02 	      jsr	OUTHEX
    751  0c38							;
    752  0c38							; Display the CURPTR value and offset
    753  0c38							;
    754  0c38		       20 12 f0 	      jsr	puts
      0  0c3b					      db	", CURPTR: ",0
      1  0c3b		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    756  0c46		       a5 7f		      lda	CURPTR+1
    757  0c48		       20 0f 02 	      jsr	OUTHEX
    758  0c4b		       a5 7e		      lda	CURPTR
    759  0c4d		       20 0f 02 	      jsr	OUTHEX
    760  0c50		       a9 2b		      lda	#'+
    761  0c52		       20 06 02 	      jsr	OUTCH
    762  0c55		       a5 80		      lda	CUROFF
    763  0c57		       20 0f 02 	      jsr	OUTHEX
    764  0c5a							;
    765  0c5a		       4c 0c 02 	      jmp	CRLF
    766  0c5d							;
    767  0c5d							;=====================================================
    768  0c5d							; This function might go away eventually, but was
    769  0c5d							; added to provide data for other pieces of code.
    770  0c5d							; It has some ties to the operating environment that
    771  0c5d							; will need to be customized for the target system.
    772  0c5d							;
    773  0c5d				   GetSizes
    774  0c5d							;
    775  0c5d							; Here is machine specific code to get the highest
    776  0c5d							; memory location that can be used by BASIC.
    777  0c5d							;
    778  0c5d					      if	ProgramStart < $2000
    779  0c5d		       a9 ff		      lda	#$ff
    780  0c5f		       8d 33 11 	      sta	HighMem	;$13ff for KIM-1
    781  0c62		       a9 df		      lda	#$DF	;#$13
    782  0c64		       8d 34 11 	      sta	HighMem+1
    783  0c67				  -	      else
    784  0c67				  -	      lda	#$ff
    785  0c67				  -	      sta	HighMem	;$CFFF otherwise
    786  0c67				  -	      lda	#$cf
    787  0c67				  -	      sta	HighMem+1
    788  0c67					      endif
    789  0c67							;
    790  0c67							; This computes the available memory remaining.
    791  0c67							;
    792  0c67		       38		      sec
    793  0c68		       ad 33 11 	      lda	HighMem
    794  0c6b		       ed 31 11 	      sbc	PROGRAMEND
    795  0c6e		       8d 37 11 	      sta	FreeMem
    796  0c71		       85 83		      sta	R0
    797  0c73		       ad 34 11 	      lda	HighMem+1
    798  0c76		       ed 32 11 	      sbc	PROGRAMEND+1
    799  0c79		       8d 38 11 	      sta	FreeMem+1
    800  0c7c		       85 84		      sta	R0+1
    801  0c7e							;
    802  0c7e							; This computes the size of the current user program.
    803  0c7e							;
    804  0c7e		       38		      sec
    805  0c7f		       ad 31 11 	      lda	PROGRAMEND
    806  0c82		       e9 39		      sbc	#ProgramStart&$ff
    807  0c84		       8d 35 11 	      sta	UsedMem
    808  0c87		       ad 32 11 	      lda	PROGRAMEND+1
    809  0c8a		       e9 11		      sbc	#ProgramStart>>8
    810  0c8c		       8d 36 11 	      sta	UsedMem+1
    811  0c8f							;
    812  0c8f		       60		      rts
    813  0c90							;
    814  0c90							;=====================================================
    815  0c90							; Set output vector to the console output function
    816  0c90							;
    817  0c90				   SetOutConsole
    818  0c90		       a9 06		      lda	#OUTCH&$ff
    819  0c92		       8d 2f 11 	      sta	BOutVec
    820  0c95		       a9 02		      lda	#OUTCH/256
    821  0c97		       8d 30 11 	      sta	BOutVec+1
    822  0c9a		       60		      rts
    823  0c9b							;
    824  0c9b							;=====================================================
    825  0c9b							; Jump to the output function in BOutVec
    826  0c9b							;
    827  0c9b		       6c 2f 11    VOUTCH     jmp	(BOutVec)
    828  0c9e
    829  0c9e							;====================================================
    830  0c9e		       11 2c	   PrtTerm    equ	rtemp1
    831  0c9e
    832  0c9e							; Print Y has the offset to use
    833  0c9e		       a5 7e	   PrtQuoted  lda	CURPTR
    834  0ca0		       85 88		      sta	PrtFrom
    835  0ca2		       a5 7f		      lda	CURPTR+1
    836  0ca4		       85 89		      sta	PrtFrom+1
    837  0ca6		       a9 22		      lda	#'"
    838  0ca8		       8d 2c 11 	      sta	PrtTerm
    839  0cab		       4c b7 0c 	      jmp	PrtLoop
    840  0cae							; Print a string pointed to by x= h, y=l terminated by a
    841  0cae							; Return y as the length
    842  0cae		       86 89	   PrtStr     stx	PrtFrom+1
    843  0cb0		       84 88		      sty	PrtFrom
    844  0cb2		       8d 2c 11 	      sta	PrtTerm
    845  0cb5		       a0 00		      ldy	#0
    846  0cb7
    847  0cb7		       b1 88	   PrtLoop    lda	(PrtFrom),y
    848  0cb9		       cd 2c 11 	      cmp	PrtTerm
    849  0cbc		       f0 0b		      beq	PrtEnd
    850  0cbe		       c9 00		      cmp	#0	; always end if 0 is found
    851  0cc0		       f0 07		      beq	PrtEnd
    852  0cc2		       20 06 02 	      jsr	OUTCH
    853  0cc5		       c8		      iny
    854  0cc6		       4c b7 0c 	      jmp	PrtLoop
    855  0cc9		       c8	   PrtEnd     iny		;return byte after the copy
    856  0cca		       60		      rts
    857  0ccb
    858  0ccb							;====================================================
    859  0ccb							;Clear the terminal assume it is ansii or vt100
    860  0ccb							;
    861  0ccb				   iCLEARSCREEN
    862  0ccb		       20 12 f0 	      jsr	puts
      0  0cce					      db	$1b,'[,'3,'J,0
      1  0cce		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    864  0cd3		       4c c5 02 	      jmp	NextIL
------- FILE mytb.asm
   1529  0cd6					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  0cd6					      include	"storage.asm"
      1  0cd6							;
      2  0cd6							;=====================================================
      3  0cd6							;=====================================================
      4  0cd6							;=====================================================
      5  0cd6							; This file contains the functions for saving and
      6  0cd6							; restoring programs from some sort of mass storage
      7  0cd6							; device.  This particular version is for using the
      8  0cd6							; Corsham Tech SD Card System.
      9  0cd6							;=====================================================
     10  0cd6							;=====================================================
     11  0cd6							;=====================================================
     12  0cd6
     13 Udf8e					      SEG.U	bss
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  0cd6					      SEG	code
     19  0cd6
     20  0cd6							;
     21  0cd6							;=====================================================
     22  0cd6							; Open a file for reading as a program.  The next
     23  0cd6							; thing on the line should be the filename.
     24  0cd6							;
     25  0cd6				   iOPENREAD
     26  0cd6					      if	XKIM || CTMON65
     27  0cd6		       a4 80		      ldy	CUROFF
     28  0cd8		       b1 7e		      lda	(CURPTR),y
     29  0cda		       d0 07		      bne	iOPENfn	;might be filename
     30  0cdc							;
     31  0cdc							; No filename supplied.
     32  0cdc							;
     33  0cdc		       a9 00	   iOPENnofn  lda	#0
     34  0cde		       a2 09		      ldx	#ERR_NO_FILENAME
     35  0ce0		       4c 9d 04 	      jmp	iErr2
     36  0ce3							;
     37  0ce3							; Add the offset into the buffer start
     38  0ce3							;
     39  0ce3		       18	   iOPENfn    clc
     40  0ce4		       98		      tya
     41  0ce5		       65 7e		      adc	CURPTR
     42  0ce7		       a8		      tay		;LSB
     43  0ce8		       a5 7f		      lda	CURPTR+1
     44  0cea		       69 00		      adc	#0
     45  0cec		       aa		      tax
     46  0ced		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  0cf0		       90 07		      bcc	Ropenok	;branch if opened ok
     48  0cf2							;
     49  0cf2							; Open failed
     50  0cf2							;
     51  0cf2		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  0cf4		       a9 00	   Rdfail2    lda	#0
     53  0cf6		       4c 9d 04 	      jmp	iErr2
     54  0cf9							;
     55  0cf9							; Clear counts and offsets so the next read will
     56  0cf9							; cause the file to be read.
     57  0cf9							;
     58  0cf9		       a9 00	   Ropenok    lda	#0
     59  0cfb		       8d 8f df 	      sta	diskBufOffset
     60  0cfe		       8d 8e df 	      sta	diskBufLength
     61  0d01		       4c c5 02 	      jmp	NextIL
     62  0d04					      endif
     63  0d04
     64  0d04							;
     65  0d04							;==============================jlit 08/02/2022========
     66  0d04							;Remove a file from the disk
     67  0d04				   iRMFILE
     68  0d04					      if	XKIM || CTMON65
     69  0d04		       a4 80		      ldy	CUROFF
     70  0d06		       b1 7e		      lda	(CURPTR),y
     71  0d08		       f0 19		      beq	iRMnofn
     72  0d0a							;
     73  0d0a		       18		      clc
     74  0d0b		       98		      tya
     75  0d0c		       65 7e		      adc	CURPTR
     76  0d0e		       a8		      tay		;LSB
     77  0d0f		       a5 7f		      lda	CURPTR+1
     78  0d11		       69 00		      adc	#0
     79  0d13		       aa		      tax
     80  0d14		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  0d17		       90 07		      bcc	wrmOk	;branch if removed ok
     82  0d19		       a9 00		      lda	#0
     83  0d1b		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  0d1d		       4c 9d 04 	      jmp	iErr2
     85  0d20		       4c c5 02    wrmOk      jmp	NextIL
     86  0d23
     87  0d23							; No filename supplied.
     88  0d23							;
     89  0d23		       a9 00	   iRMnofn    lda	#0
     90  0d25		       a2 09		      ldx	#ERR_NO_FILENAME
     91  0d27		       4c 9d 04 	      jmp	iErr2
     92  0d2a					      endif
     93  0d2a							;
     94  0d2a							;=====================================================
     95  0d2a				   iOPENWRITE
     96  0d2a					      if	XKIM || CTMON65
     97  0d2a		       a4 80		      ldy	CUROFF
     98  0d2c		       b1 7e		      lda	(CURPTR),y
     99  0d2e		       f0 f3		      beq	iRMnofn
    100  0d30							;
    101  0d30		       18		      clc
    102  0d31		       98		      tya
    103  0d32		       65 7e		      adc	CURPTR
    104  0d34		       a8		      tay		;LSB
    105  0d35		       a5 7f		      lda	CURPTR+1
    106  0d37		       69 00		      adc	#0
    107  0d39		       aa		      tax
    108  0d3a		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  0d3d		       90 07		      bcc	Wopenok	;branch if opened ok
    110  0d3f							;
    111  0d3f							; Open failed
    112  0d3f							;
    113  0d3f		       a9 00	   Wdfail     lda	#0
    114  0d41		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  0d43		       4c 9d 04 	      jmp	iErr2
    116  0d46							;
    117  0d46		       4c c5 02    Wopenok    jmp	NextIL
    118  0d49					      endif
    119  0d49							;
    120  0d49							;=====================================================
    121  0d49							; Gets a line of input from the disk file and puts it
    122  0d49							; into LINBUF.
    123  0d49							;
    124  0d49							; On exit:
    125  0d49							;    CURPTR points to LINBUF
    126  0d49							;    LINBUF contains the line with 0 at the end.
    127  0d49							;    Y has offset to first non-space character
    128  0d49							;    CURROFF has the same as Y.
    129  0d49							;
    130  0d49				   iDGETLINE
    131  0d49					      if	XKIM || CTMON65
    132  0d49		       a2 9f		      ldx	#LINBUF&$ff
    133  0d4b		       86 7e		      stx	CURPTR
    134  0d4d		       a2 10		      ldx	#LINBUF>>8
    135  0d4f		       86 7f		      stx	CURPTR+1
    136  0d51							;
    137  0d51		       a2 00		      ldx	#0	;offset
    138  0d53		       8e 23 11    iDgetLoop  stx	getlinx
    139  0d56		       20 b4 0d 	      jsr	getNextFileByte
    140  0d59		       b0 16		      bcs	iGetEOF
    141  0d5b		       c9 0d		      cmp	#CR
    142  0d5d		       f0 0d		      beq	iGetEOL
    143  0d5f		       c9 0a		      cmp	#LF
    144  0d61		       f0 09		      beq	iGetEOL
    145  0d63		       ae 23 11 	      ldx	getlinx
    146  0d66		       9d 9f 10 	      sta	LINBUF,x
    147  0d69		       e8		      inx
    148  0d6a		       d0 e7		      bne	iDgetLoop
    149  0d6c							;
    150  0d6c							; Handle end of line.	If the line has nothing, loop
    151  0d6c							; back and get another line.
    152  0d6c							;
    153  0d6c		       ae 23 11    iGetEOL    ldx	getlinx	;blank line?
    154  0d6f		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  0d71							;
    156  0d71							; This can fall through when there is a line, or
    157  0d71							; called directly when EOF is encountered.
    158  0d71							;
    159  0d71		       ae 23 11    iGetEOF    ldx	getlinx
    160  0d74		       a9 00		      lda	#0
    161  0d76		       9d 9f 10 	      sta	LINBUF,x
    162  0d79		       85 80		      sta	CUROFF
    163  0d7b		       a0 00		      ldy	#0
    164  0d7d		       20 0f 0c 	      jsr	SkipSpaces
    165  0d80		       4c c5 02 	      jmp	NextIL
    166  0d83					      endif
    167  0d83
    168  0d83							;
    169  0d83							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  0d83							; DISK
    171  0d83							;
    172  0d83				   iDDIR
    173  0d83					      if	XKIM || CTMON65
    174  0d83		       20 30 f0 	      jsr	DiskDir
    175  0d86							;
    176  0d86							; Get/Display each entry
    177  0d86							;
    178  0d86		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  0d88		       a0 90		      ldy	#DiskFileName&$ff
    180  0d8a		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  0d8d		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  0d8f		       20 12 f0 	      jsr	puts
      0  0d92					      db	"   ",0
      1  0d92		       20 20 20 00	      .byte.b	"   ",0
    184  0d96							; Print the line to the console
    185  0d96		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  0d98		       a0 90		      ldy	#DiskFileName&$ff
    187  0d9a		       a5 00		      lda	0
    188  0d9c		       20 ae 0c 	      jsr	PrtStr	;else print name
    189  0d9f		       20 18 f0 	      jsr	crlf
    190  0da2
    191  0da2		       4c 86 0d 	      jmp	DiskDirLoop	;do next entry
    192  0da5		       4c c5 02    DiskDirEnd jmp	NextIL
    193  0da8					      endif
    194  0da8							;
    195  0da8							;=====================================================
    196  0da8							; Does a LIST to a Disk file.
    197  0da8							;
    198  0da8				   iDLIST
    199  0da8					      if	XKIM || CTMON65
    200  0da8		       20 e3 0d 	      jsr	SetOutDisk
    201  0dab		       4c d3 05 	      jmp	iLST2
    202  0dae					      endif
    203  0dae							;
    204  0dae							;=====================================================
    205  0dae							; Closes any pending disk file.  Okay to call if there
    206  0dae							; is no open file.
    207  0dae							;
    208  0dae				   iDCLOSE
    209  0dae					      if	XKIM || CTMON65
    210  0dae		       20 42 f0 	      jsr	DiskClose
    211  0db1		       4c c5 02 	      jmp	NextIL
    212  0db4					      endif
    213  0db4							;
    214  0db4							;=====================================================
    215  0db4							; This gets the next byte from an open disk file.  If
    216  0db4							; there are no more bytes left, this returns C set.
    217  0db4							; Else, C is clear and A contains the character.
    218  0db4							;
    219  0db4				   getNextFileByte
    220  0db4					      if	XKIM || CTMON65
    221  0db4		       ae 8f df 	      ldx	diskBufOffset
    222  0db7		       ec 8e df 	      cpx	diskBufLength
    223  0dba		       d0 14		      bne	hasdata	;branch if still data
    224  0dbc							;
    225  0dbc							; There is no data left in the buffer, so read a
    226  0dbc							; block from the SD system.
    227  0dbc							;
    228  0dbc		       a9 84		      lda	#BUFFER_SIZE
    229  0dbe		       a2 df		      ldx	#buffer>>8
    230  0dc0		       a0 0a		      ldy	#buffer&$ff
    231  0dc2		       20 3c f0 	      jsr	DiskRead
    232  0dc5		       b0 12		      bcs	getNextEof
    233  0dc7							;
    234  0dc7							; A contains the number of bytes actually read.
    235  0dc7							;
    236  0dc7		       8d 8e df 	      sta	diskBufLength	;save length
    237  0dca		       c9 00		      cmp	#0	;shouldn't happen
    238  0dcc		       f0 0b		      beq	getNextEof
    239  0dce							;
    240  0dce		       a2 00		      ldx	#0
    241  0dd0		       bd 0a df    hasdata    lda	buffer,x
    242  0dd3		       e8		      inx
    243  0dd4		       8e 8f df 	      stx	diskBufOffset
    244  0dd7		       18		      clc
    245  0dd8		       60		      rts
    246  0dd9							;
    247  0dd9		       a9 00	   getNextEof lda	#0
    248  0ddb		       8d 8f df 	      sta	diskBufOffset
    249  0dde		       8d 8e df 	      sta	diskBufLength
    250  0de1		       38		      sec
    251  0de2		       60		      rts
    252  0de3							;
    253  0de3							;=====================================================
    254  0de3							; Set output vector to the disk output function
    255  0de3							;
    256  0de3		       a9 ee	   SetOutDisk lda	#DOUT&$ff
    257  0de5		       8d 2f 11 	      sta	BOutVec
    258  0de8		       a9 0d		      lda	#DOUT/256
    259  0dea		       8d 30 11 	      sta	BOutVec+1
    260  0ded		       60		      rts
    261  0dee							;
    262  0dee							;=====================================================
    263  0dee
    264  0dee		       8d 0a df    DOUT       sta	buffer
    265  0df1		       a9 01		      lda	#1
    266  0df3		       a0 0a		      ldy	#buffer&$ff
    267  0df5		       a2 df		      ldx	#buffer/256
    268  0df7		       20 3f f0 	      jsr	DiskWrite
    269  0dfa							;
    270  0dfa							; need error checking here
    271  0dfa							;
    272  0dfa		       60		      rts
    273  0dfb					      endif
    274  0dfb
    275  0dfb
------- FILE mytb.asm
   1531  0dfb					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  0dfb					      include	"IL.inc"
      1  0dfb
      2  0dfb							;=====================================================
      3  0dfb							; IL.inc
      4  0dfb							; These are macros for IL instructions
      5  0dfb							;
      6  0dfb					      mac	dw
      7  0dfb					      .word	{0}
      8  0dfb					      endm
      9  0dfb					      mac	db
     10  0dfb					      .byte	{0}
     11  0dfb					      endm
     12  0dfb					      macro	xinit
     13  0dfb					      db	0
     14  0dfb					      endm		;reset the il to start clear all
     15  0dfb							;
     16  0dfb					      macro	done
     17  0dfb					      db	1
     18  0dfb					      endm		;print an error if not end of line
     19  0dfb							;
     20  0dfb					      macro	prs
     21  0dfb					      db	2
     22  0dfb					      endm		;print a quoted string
     23  0dfb							;
     24  0dfb					      macro	prn
     25  0dfb					      db	3
     26  0dfb					      endm		;print a number
     27  0dfb							;
     28  0dfb					      macro	spc
     29  0dfb					      db	4
     30  0dfb					      endm		;print space til new tabstop
     31  0dfb							;
     32  0dfb					      macro	nline
     33  0dfb					      db	5
     34  0dfb					      endm		;print a new line crlf
     35  0dfb							;
     36  0dfb							; My NXT is a bit different in that it takes one
     37  0dfb							; parameter, which is an address.  If the BASIC
     38  0dfb							; program is currently running then move to the
     39  0dfb							; next line and continue execution.  However, if
     40  0dfb							; in direct mode, jump to the specified IL label.
     41  0dfb							;
     42  0dfb					      macro	nxt
     43  0dfb					      db	6
     44  0dfb					      dw	{1}	; addr
     45  0dfb					      endm		; addr
     46  0dfb							;
     47  0dfb					      macro	xfer
     48  0dfb					      db	7
     49  0dfb					      endm
     50  0dfb							;
     51  0dfb					      macro	sav
     52  0dfb					      db	8
     53  0dfb					      endm
     54  0dfb							;
     55  0dfb					      macro	rstr
     56  0dfb					      db	9
     57  0dfb					      endm
     58  0dfb							;
     59  0dfb					      macro	cmpr
     60  0dfb					      db	10
     61  0dfb					      endm
     62  0dfb							;
     63  0dfb					      macro	innum
     64  0dfb					      db	11
     65  0dfb					      endm
     66  0dfb							;
     67  0dfb					      macro	fin
     68  0dfb					      db	12
     69  0dfb					      endm
     70  0dfb							;
     71  0dfb							; ERR is followed by an error number.	The error
     72  0dfb							; code is printed along with the line number.
     73  0dfb							; Control is passed to the statement set with
     74  0dfb							; the ERRGOTO statement.
     75  0dfb							;
     76  0dfb					      macro	errmsg
     77  0dfb					      db	13
     78  0dfb					      dw	{1}	;ecode
     79  0dfb					      endm		;ecode
     80  0dfb							;
     81  0dfb					      macro	add
     82  0dfb					      db	14
     83  0dfb					      endm
     84  0dfb							;
     85  0dfb					      macro	sub
     86  0dfb					      db	15
     87  0dfb					      endm
     88  0dfb							;
     89  0dfb					      macro	neg
     90  0dfb					      db	16
     91  0dfb					      endm
     92  0dfb							;
     93  0dfb					      macro	mul
     94  0dfb					      db	17
     95  0dfb					      endm
     96  0dfb							;
     97  0dfb					      macro	div
     98  0dfb					      db	18
     99  0dfb					      endm
    100  0dfb							;
    101  0dfb					      macro	store
    102  0dfb					      db	19
    103  0dfb					      endm
    104  0dfb							;
    105  0dfb					      macro	ind
    106  0dfb					      db	20
    107  0dfb					      endm
    108  0dfb							;
    109  0dfb					      macro	lst
    110  0dfb					      db	21
    111  0dfb					      endm
    112  0dfb							;
    113  0dfb					      macro	init
    114  0dfb					      db	22
    115  0dfb					      endm
    116  0dfb							;
    117  0dfb					      macro	getline
    118  0dfb					      db	23
    119  0dfb					      endm
    120  0dfb							;
    121  0dfb					      macro	insert
    122  0dfb					      db	24
    123  0dfb					      endm
    124  0dfb							;
    125  0dfb					      macro	rtn
    126  0dfb					      db	25
    127  0dfb					      endm
    128  0dfb							;
    129  0dfb					      macro	exit
    130  0dfb					      db	26
    131  0dfb					      endm
    132  0dfb							;
    133  0dfb					      macro	lit
    134  0dfb					      db	27
    135  0dfb					      dw	{1}	;value
    136  0dfb					      endm		; value LIT
    137  0dfb							;
    138  0dfb					      macro	call
    139  0dfb					      db	28
    140  0dfb					      dw	{1}	;addr
    141  0dfb					      endm		;addr
    142  0dfb							;
    143  0dfb							; IJMP will set the IL PC to the specified value.
    144  0dfb							;
    145  0dfb					      macro	ijmp
    146  0dfb					      db	29
    147  0dfb					      dw	{1}	;addr
    148  0dfb					      endm		;addr
    149  0dfb							;
    150  0dfb					      macro	vinit
    151  0dfb					      db	30
    152  0dfb					      endm
    153  0dfb							;
    154  0dfb							; ERRGOTO sets the point in the code where the IL
    155  0dfb							; interpreter will go after any error.
    156  0dfb							;
    157  0dfb					      macro	errgoto
    158  0dfb					      db	31
    159  0dfb					      dw	{1}	;addr
    160  0dfb					      endm		;addr
    161  0dfb							;
    162  0dfb					      macro	tst
    163  0dfb					      db	32
    164  0dfb					      db	({1}-*)-1	;(addr-*)-1
    165  0dfb					      db	{2},0	;string,0
    166  0dfb					      endm		;addr,string
    167  0dfb							;
    168  0dfb					      macro	tstv
    169  0dfb					      db	33
    170  0dfb					      db	({1}-*)-1	;(addr-*)-1
    171  0dfb					      endm		;addr
    172  0dfb							;
    173  0dfb					      macro	tstl
    174  0dfb					      db	34
    175  0dfb					      db	({1}-*)-1	;(addr-*)-1
    176  0dfb					      endm		;addr
    177  0dfb							;
    178  0dfb					      macro	tstn
    179  0dfb					      db	35
    180  0dfb					      db	({1}-*)-1	;(addr-*)-1
    181  0dfb					      endm		;addr
    182  0dfb							;
    183  0dfb							; FREE returns the amount of free RAM on top of
    184  0dfb							; the stack.  This is the amount of room the user
    185  0dfb							; program has available.
    186  0dfb							;
    187  0dfb					      macro	free
    188  0dfb					      db	36
    189  0dfb					      endm
    190  0dfb							;
    191  0dfb							; RANDOM takes the top item off the stack and
    192  0dfb							; replaces it with a random number that is
    193  0dfb							; MOD the initial value.  Ie, if the TOS is
    194  0dfb							; 42 then RANDOM returns a value from 0 to 41.
    195  0dfb							;
    196  0dfb					      macro	random
    197  0dfb					      db	37
    198  0dfb					      endm
    199  0dfb							;
    200  0dfb							; ABS will replace the top of stack with the
    201  0dfb							; absolute value.
    202  0dfb							;
    203  0dfb					      macro	abs
    204  0dfb					      db	38
    205  0dfb					      endm
    206  0dfb							;
    207  0dfb							; OPENREAD opens a file for reading, as in getting
    208  0dfb							; statements from it.
    209  0dfb							;
    210  0dfb					      macro	openread
    211  0dfb					      db	39
    212  0dfb					      endm
    213  0dfb							;
    214  0dfb							; OPENWRITE opens a file for writing, as in saving
    215  0dfb							; the current program to it.
    216  0dfb							;
    217  0dfb					      macro	openwrite
    218  0dfb					      db	40
    219  0dfb					      endm
    220  0dfb							;
    221  0dfb							; DCLOSE closes any open disk file.
    222  0dfb							;
    223  0dfb					      macro	dclose
    224  0dfb					      db	41
    225  0dfb					      endm
    226  0dfb							;
    227  0dfb							; DGETLINE gets one line from the disk file and puts it
    228  0dfb							; into LINBUFF.
    229  0dfb							;
    230  0dfb					      macro	dgetline
    231  0dfb					      db	42
    232  0dfb					      endm
    233  0dfb							;
    234  0dfb							; DLIST saves the program to an open disk file.
    235  0dfb							;
    236  0dfb					      macro	dlist
    237  0dfb					      db	43
    238  0dfb					      endm
    239  0dfb							; DDIR list the current directory
    240  0dfb							;
    241  0dfb					      macro	ddir
    242  0dfb					      db	44
    243  0dfb					      endm
    244  0dfb
    245  0dfb							; RMFILE remove a fle from disk
    246  0dfb					      macro	rmfile
    247  0dfb					      db	45
    248  0dfb					      endm
    249  0dfb
    250  0dfb							; CLEARSCREEN clear the screen
    251  0dfb					      macro	clearscreen
    252  0dfb					      db	46
    253  0dfb					      endm
    254  0dfb							; POKEMEM Poke value into memory
    255  0dfb					      macro	pokemem
    256  0dfb					      db	47
    257  0dfb					      endm
    258  0dfb							; PEEKMEM peek at value in memory
    259  0dfb					      macro	peekmem
    260  0dfb					      db	48
    261  0dfb					      endm
    262  0dfb							; TSTLET Test if the statement is a let without the keyword let
    263  0dfb					      macro	tstlet
    264  0dfb					      db	49
    265  0dfb					      db	({1}-*)-1	;(addr-*)-1
    266  0dfb					      endm		;addr
    267  0dfb							; TSTDONE if we reach the end of a statement
    268  0dfb					      macro	tstdone
    269  0dfb					      db	50
    270  0dfb					      db	({1}-*)-1	;(addr-*)-1
    271  0dfb					      endm		;addr
    272  0dfb							; GETCHAR	get a character from the input line leave it in RO
    273  0dfb					      macro	getchar
    274  0dfb					      db	51
    275  0dfb					      endm
    276  0dfb							; PUTCHAR	Put a character to the terminal
    277  0dfb					      macro	putchar
    278  0dfb					      db	52
    279  0dfb					      endm
    280  0dfb							; Call		Call a machine function return a to stack
    281  0dfb					      macro	callfunc
    282  0dfb					      db	53
    283  0dfb					      endm
    284  0dfb							; Call		Call a machine function return a to stack
    285  0dfb					      macro	callfunc2
    286  0dfb					      db	54
    287  0dfb					      endm
------- FILE mytb.asm
   1533  0dfb							;
   1534  0dfb				  -	      if	FIXED
   1535  0dfb				  -	      org	$1000
   1536  0dfb					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  0dfb					      include	"basic.il"
      1  0dfb				   LET			;
      2  0dfb							;=====================================================
      3  0dfb							;=====================================================
      4  0dfb							;=====================================================
      5  0dfb							; This is the IL of the BASIC (or whatever) language.
      6  0dfb							; Because of the way macros are implemented by as65,
      7  0dfb							; labels can't be on the same line as a macro
      8  0dfb							; invocation, so that's why labels are on separate
      9  0dfb							; lines.
     10  0dfb							;
     11  0dfb		       0d fb	   IL	      equ	*
     12  0dfb
     13  0dfb							;THE IL CONTROL SECTION
     14  0dfb
     15  0dfb				   START
      0  0dfb					      INIT		;INITIALIZE
      0  0dfb					      db	22
      1  0dfb		       16		      .byte.b	22
      0  0dfc					      NLINE		;WRITE CRLF
      0  0dfc					      db	5
      1  0dfc		       05		      .byte.b	5
      0  0dfd					      ERRGOTO	CO	;where to go after an error
      0  0dfd					      db	31
      1  0dfd		       1f		      .byte.b	31
      0  0dfe					      dw	CO
      1  0dfe		       01 0e		      .word.w	CO
      0  0e00					      VINIT		;clear all variables
      0  0e00					      db	30
      1  0e00		       1e		      .byte.b	30
     20  0e01							;
     21  0e01							; This is where we jump to get a line of commands or
     22  0e01							; a program from the user.
     23  0e01							;
     24  0e01				   CO
      0  0e01					      GETLINE		;WRITE PROMPT AND GET LINE
      0  0e01					      db	23
      1  0e01		       17		      .byte.b	23
      0  0e02					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  0e02					      db	34
      1  0e02		       22		      .byte.b	34
      0  0e03					      db	(XEC-*)-1
      1  0e03		       04		      .byte.b	(XEC-*)-1
      0  0e04					      INSERT		;INSERT IT (MAY BE DELETE)
      0  0e04					      db	24
      1  0e04		       18		      .byte.b	24
      0  0e05					      IJMP	CO
      0  0e05					      db	29
      1  0e05		       1d		      .byte.b	29
      0  0e06					      dw	CO
      1  0e06		       01 0e		      .word.w	CO
     29  0e08				   XEC
      0  0e08					      XINIT		;INITIALIZE
      0  0e08					      db	0
      1  0e08		       00		      .byte.b	0
     31  0e09
     32  0e09							;STATEMENT EXECUTOR
     33  0e09
     34  0e09				   STMT
      0  0e09					      TST	S1a,"LET"	;IS STATEMENT A LET
      0  0e09					      db	32
      1  0e09		       20		      .byte.b	32
      0  0e0a					      db	(S1a-*)-1
      1  0e0a		       15		      .byte.b	(S1a-*)-1
      0  0e0b					      db	"LET",0
      1  0e0b		       4c 45 54 00	      .byte.b	"LET",0
      0  0e0f				   DOLET      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  0e0f					      db	33
      1  0e0f		       21		      .byte.b	33
      0  0e10					      db	(ERRVEC-*)-1
      1  0e10		       87		      .byte.b	(ERRVEC-*)-1
      0  0e11					      TST	ERRVEC,"="	;(This line originally omitted)
      0  0e11					      db	32
      1  0e11		       20		      .byte.b	32
      0  0e12					      db	(ERRVEC-*)-1
      1  0e12		       85		      .byte.b	(ERRVEC-*)-1
      0  0e13					      db	"=",0
      1  0e13		       3d 00		      .byte.b	"=",0
      0  0e15					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  0e15					      db	28
      1  0e15		       1c		      .byte.b	28
      0  0e16					      dw	EXPR
      1  0e16		       7a 0f		      .word.w	EXPR
      0  0e18					      DONE		;REPORT ERROR IF NOT NEXT
      0  0e18					      db	1
      1  0e18		       01		      .byte.b	1
      0  0e19					      STORE		;STORE RESULT
      0  0e19					      db	19
      1  0e19		       13		      .byte.b	19
      0  0e1a					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0e1a					      db	6
      1  0e1a		       06		      .byte.b	6
      0  0e1b					      dw	CO
      1  0e1b		       01 0e		      .word.w	CO
      0  0e1d					      IJMP	STMT
      0  0e1d					      db	29
      1  0e1d		       1d		      .byte.b	29
      0  0e1e					      dw	STMT
      1  0e1e		       09 0e		      .word.w	STMT
      0  0e20				   S1a	      TSTLET	S1	;Test if second field is =
      0  0e20					      db	49
      1  0e20		       31		      .byte.b	49
      0  0e21					      db	(S1-*)-1
      1  0e21		       03		      .byte.b	(S1-*)-1
      0  0e22					      IJMP	DOLET	;allow the default to be let
      0  0e22					      db	29
      1  0e22		       1d		      .byte.b	29
      0  0e23					      dw	DOLET
      1  0e23		       0f 0e		      .word.w	DOLET
     45  0e25				   S1
      0  0e25					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  0e25					      db	32
      1  0e25		       20		      .byte.b	32
      0  0e26					      db	(S2b-*)-1
      1  0e26		       19		      .byte.b	(S2b-*)-1
      0  0e27					      db	"GO",0
      1  0e27		       47 4f 00 	      .byte.b	"GO",0
      0  0e2a					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  0e2a					      db	32
      1  0e2a		       20		      .byte.b	32
      0  0e2b					      db	(S2-*)-1
      1  0e2b		       08		      .byte.b	(S2-*)-1
      0  0e2c					      db	"TO",0
      1  0e2c		       54 4f 00 	      .byte.b	"TO",0
      0  0e2f					      CALL	EXPR	;GET LABEL
      0  0e2f					      db	28
      1  0e2f		       1c		      .byte.b	28
      0  0e30					      dw	EXPR
      1  0e30		       7a 0f		      .word.w	EXPR
      0  0e32					      DONE		;ERROR IF CR NOT NEXT
      0  0e32					      db	1
      1  0e32		       01		      .byte.b	1
      0  0e33					      XFER		;SET UP AND JUMP
      0  0e33					      db	7
      1  0e33		       07		      .byte.b	7
     51  0e34				   S2
      0  0e34					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  0e34					      db	32
      1  0e34		       20		      .byte.b	32
      0  0e35					      db	(ERRVEC-*)-1
      1  0e35		       62		      .byte.b	(ERRVEC-*)-1
      0  0e36					      db	"SUB",0
      1  0e36		       53 55 42 00	      .byte.b	"SUB",0
      0  0e3a					      CALL	EXPR	;GET DESTINATION
      0  0e3a					      db	28
      1  0e3a		       1c		      .byte.b	28
      0  0e3b					      dw	EXPR
      1  0e3b		       7a 0f		      .word.w	EXPR
      0  0e3d					      DONE		;ERROR IF CR NOT NEXT
      0  0e3d					      db	1
      1  0e3d		       01		      .byte.b	1
      0  0e3e					      SAV		;SAVE RETURN LINE
      0  0e3e					      db	8
      1  0e3e		       08		      .byte.b	8
      0  0e3f					      XFER		;AND JUMP
      0  0e3f					      db	7
      1  0e3f		       07		      .byte.b	7
     57  0e40				   S2b
      0  0e40					      TST	S3,"RE"
      0  0e40					      db	32
      1  0e40		       20		      .byte.b	32
      0  0e41					      db	(S3-*)-1
      1  0e41		       1f		      .byte.b	(S3-*)-1
      0  0e42					      db	"RE",0
      1  0e42		       52 45 00 	      .byte.b	"RE",0
      0  0e45					      TST	S2a,"T"
      0  0e45					      db	32
      1  0e45		       20		      .byte.b	32
      0  0e46					      db	(S2a-*)-1
      1  0e46		       10		      .byte.b	(S2a-*)-1
      0  0e47					      db	"T",0
      1  0e47		       54 00		      .byte.b	"T",0
      0  0e49					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  0e49					      db	32
      1  0e49		       20		      .byte.b	32
      0  0e4a					      db	(S2aa-*)-1
      1  0e4a		       04		      .byte.b	(S2aa-*)-1
      0  0e4b					      db	"URN",0
      1  0e4b		       55 52 4e 00	      .byte.b	"URN",0
      0  0e4f				   S2aa       DONE		;MUST BE CR
      0  0e4f					      db	1
      1  0e4f		       01		      .byte.b	1
      0  0e50					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  0e50					      db	9
      1  0e50		       09		      .byte.b	9
      0  0e51					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  0e51					      db	6
      1  0e51		       06		      .byte.b	6
      0  0e52					      dw	CO
      1  0e52		       01 0e		      .word.w	CO
      0  0e54					      IJMP	STMT
      0  0e54					      db	29
      1  0e54		       1d		      .byte.b	29
      0  0e55					      dw	STMT
      1  0e55		       09 0e		      .word.w	STMT
     65  0e57				   S2a
      0  0e57					      TST	S3,"M"	;REMark.  Skip rest of line
      0  0e57					      db	32
      1  0e57		       20		      .byte.b	32
      0  0e58					      db	(S3-*)-1
      1  0e58		       08		      .byte.b	(S3-*)-1
      0  0e59					      db	"M",0
      1  0e59		       4d 00		      .byte.b	"M",0
      0  0e5b					      NXT	CO
      0  0e5b					      db	6
      1  0e5b		       06		      .byte.b	6
      0  0e5c					      dw	CO
      1  0e5c		       01 0e		      .word.w	CO
      0  0e5e					      IJMP	STMT
      0  0e5e					      db	29
      1  0e5e		       1d		      .byte.b	29
      0  0e5f					      dw	STMT
      1  0e5f		       09 0e		      .word.w	STMT
     69  0e61
     70  0e61				   S3
      0  0e61					      TST	S3a,"?"	; ? symonym for print
      0  0e61					      db	32
      1  0e61		       20		      .byte.b	32
      0  0e62					      db	(S3a-*)-1
      1  0e62		       05		      .byte.b	(S3a-*)-1
      0  0e63					      db	"?",0
      1  0e63		       3f 00		      .byte.b	"?",0
      0  0e65					      IJMP	S4
      0  0e65					      db	29
      1  0e65		       1d		      .byte.b	29
      0  0e66					      dw	S4
      1  0e66		       73 0e		      .word.w	S4
     73  0e68				   S3a
      0  0e68					      TST	S8,"PR"	;allow short form of print
      0  0e68					      db	32
      1  0e68		       20		      .byte.b	32
      0  0e69					      db	(S8-*)-1
      1  0e69		       38		      .byte.b	(S8-*)-1
      0  0e6a					      db	"PR",0
      1  0e6a		       50 52 00 	      .byte.b	"PR",0
      0  0e6d					      TST	S4,"INT"	;PRINT
      0  0e6d					      db	32
      1  0e6d		       20		      .byte.b	32
      0  0e6e					      db	(S4-*)-1
      1  0e6e		       04		      .byte.b	(S4-*)-1
      0  0e6f					      db	"INT",0
      1  0e6f		       49 4e 54 00	      .byte.b	"INT",0
     76  0e73				   S4
      0  0e73					      TSTDONE	S4a	;Test if we just want crlf printed
      0  0e73					      db	50
      1  0e73		       32		      .byte.b	50
      0  0e74					      db	(S4a-*)-1
      1  0e74		       03		      .byte.b	(S4a-*)-1
      0  0e75					      IJMP	S6
      0  0e75					      db	29
      1  0e75		       1d		      .byte.b	29
      0  0e76					      dw	S6
      1  0e76		       90 0e		      .word.w	S6
     79  0e78
      0  0e78				   S4a	      TST	S7,QUOTE	;TEST FOR QUOTE
      0  0e78					      db	32
      1  0e78		       20		      .byte.b	32
      0  0e79					      db	(S7-*)-1
      1  0e79		       21		      .byte.b	(S7-*)-1
      0  0e7a					      db	QUOTE,0
      1  0e7a		       22 00		      .byte.b	QUOTE,0
      0  0e7c					      PRS		;PRINT STRING
      0  0e7c					      db	2
      1  0e7c		       02		      .byte.b	2
     82  0e7d				   S5
      0  0e7d					      TST	S6A,COMMA	;IS THERE MORE?
      0  0e7d					      db	32
      1  0e7d		       20		      .byte.b	32
      0  0e7e					      db	(S6A-*)-1
      1  0e7e		       08		      .byte.b	(S6A-*)-1
      0  0e7f					      db	COMMA,0
      1  0e7f		       2c 00		      .byte.b	COMMA,0
      0  0e81					      SPC		;SPACE TO NEXT ZONE
      0  0e81					      db	4
      1  0e81		       04		      .byte.b	4
      0  0e82					      TSTDONE	S4	;Not end of line jump back
      0  0e82					      db	50
      1  0e82		       32		      .byte.b	50
      0  0e83					      db	(S4-*)-1
      1  0e83		       ef		      .byte.b	(S4-*)-1
      0  0e84					      IJMP	S6a	;YES JUMP BACK
      0  0e84					      db	29
      1  0e84		       1d		      .byte.b	29
      0  0e85					      dw	S6a
      1  0e85		       92 0e		      .word.w	S6a
     87  0e87							;
     88  0e87							; If a semicolon, don't do anything.
     89  0e87							;
     90  0e87				   S6A
      0  0e87					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  0e87					      db	32
      1  0e87		       20		      .byte.b	32
      0  0e88					      db	(S6-*)-1
      1  0e88		       07		      .byte.b	(S6-*)-1
      0  0e89					      db	SEMICOLON,0
      1  0e89		       3b 00		      .byte.b	SEMICOLON,0
      0  0e8b					      TSTDONE	S4	;Jump Back if not end of line
      0  0e8b					      db	50
      1  0e8b		       32		      .byte.b	50
      0  0e8c					      db	(S4-*)-1
      1  0e8c		       e6		      .byte.b	(S4-*)-1
      0  0e8d					      IJMP	S6a
      0  0e8d					      db	29
      1  0e8d		       1d		      .byte.b	29
      0  0e8e					      dw	S6a
      1  0e8e		       92 0e		      .word.w	S6a
     94  0e90				   S6
      0  0e90					      DONE		;ERROR IF CR NOT NEXT
      0  0e90					      db	1
      1  0e90		       01		      .byte.b	1
      0  0e91					      NLINE
      0  0e91					      db	5
      1  0e91		       05		      .byte.b	5
      0  0e92				   S6a	      NXT	CO	;exit here if , or ; at end of print
      0  0e92					      db	6
      1  0e92		       06		      .byte.b	6
      0  0e93					      dw	CO
      1  0e93		       01 0e		      .word.w	CO
      0  0e95					      IJMP	STMT
      0  0e95					      db	29
      1  0e95		       1d		      .byte.b	29
      0  0e96					      dw	STMT
      1  0e96		       09 0e		      .word.w	STMT
     99  0e98							;
    100  0e98							; A jump for code too far away for relative branch
    101  0e98							;
    102  0e98				   ERRVEC
      0  0e98					      IJMP	UNKNOWN
      0  0e98					      db	29
      1  0e98		       1d		      .byte.b	29
      0  0e99					      dw	UNKNOWN
      1  0e99		       77 0f		      .word.w	UNKNOWN
    104  0e9b							;
    105  0e9b				   S7
      0  0e9b					      CALL	EXPR
      0  0e9b					      db	28
      1  0e9b		       1c		      .byte.b	28
      0  0e9c					      dw	EXPR
      1  0e9c		       7a 0f		      .word.w	EXPR
      0  0e9e					      PRN		;PRINT IT
      0  0e9e					      db	3
      1  0e9e		       03		      .byte.b	3
      0  0e9f					      IJMP	S5	;IS THERE MORE?
      0  0e9f					      db	29
      1  0e9f		       1d		      .byte.b	29
      0  0ea0					      dw	S5
      1  0ea0		       7d 0e		      .word.w	S5
    109  0ea2				   S8
      0  0ea2					      TST	S8a,"IF"	;IF STATEMENT
      0  0ea2					      db	32
      1  0ea2		       20		      .byte.b	32
      0  0ea3					      db	(S8a-*)-1
      1  0ea3		       17		      .byte.b	(S8a-*)-1
      0  0ea4					      db	"IF",0
      1  0ea4		       49 46 00 	      .byte.b	"IF",0
      0  0ea7					      CALL	EXPR	;GET EXPRESSION
      0  0ea7					      db	28
      1  0ea7		       1c		      .byte.b	28
      0  0ea8					      dw	EXPR
      1  0ea8		       7a 0f		      .word.w	EXPR
      0  0eaa					      CALL	RELOP	;DETERMINE OPR AND PUT ON STK
      0  0eaa					      db	28
      1  0eaa		       1c		      .byte.b	28
      0  0eab					      dw	RELOP
      1  0eab		       44 10		      .word.w	RELOP
      0  0ead					      CALL	EXPR	;GET EXPRESSION
      0  0ead					      db	28
      1  0ead		       1c		      .byte.b	28
      0  0eae					      dw	EXPR
      1  0eae		       7a 0f		      .word.w	EXPR
      0  0eb0					      TST	S8a1,"THEN"	;(This line originally omitted) not required
      0  0eb0					      db	32
      1  0eb0		       20		      .byte.b	32
      0  0eb1					      db	(S8a1-*)-1
      1  0eb1		       05		      .byte.b	(S8a1-*)-1
      0  0eb2					      db	"THEN",0
      1  0eb2		       54 48 45 4e*	      .byte.b	"THEN",0
      0  0eb7				   S8a1       CMPR		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE
      0  0eb7					      db	10
      1  0eb7		       0a		      .byte.b	10
      0  0eb8					      IJMP	STMT
      0  0eb8					      db	29
      1  0eb8		       1d		      .byte.b	29
      0  0eb9					      dw	STMT
      1  0eb9		       09 0e		      .word.w	STMT
    117  0ebb
    118  0ebb				   S8a
      0  0ebb					      TST	S8b,"POKE("	;Poke a value into memory
      0  0ebb					      db	32
      1  0ebb		       20		      .byte.b	32
      0  0ebc					      db	(S8b-*)-1
      1  0ebc		       18		      .byte.b	(S8b-*)-1
      0  0ebd					      db	"POKE(",0
      1  0ebd		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  0ec3					      CALL	EXPR	;Get address to write to
      0  0ec3					      db	28
      1  0ec3		       1c		      .byte.b	28
      0  0ec4					      dw	EXPR
      1  0ec4		       7a 0f		      .word.w	EXPR
      0  0ec6					      TST	UNKNOWN,COMMA	;Must have a coma
      0  0ec6					      db	32
      1  0ec6		       20		      .byte.b	32
      0  0ec7					      db	(UNKNOWN-*)-1
      1  0ec7		       af		      .byte.b	(UNKNOWN-*)-1
      0  0ec8					      db	COMMA,0
      1  0ec8		       2c 00		      .byte.b	COMMA,0
      0  0eca					      CALL	EXPR	;Get the value to poke
      0  0eca					      db	28
      1  0eca		       1c		      .byte.b	28
      0  0ecb					      dw	EXPR
      1  0ecb		       7a 0f		      .word.w	EXPR
      0  0ecd					      TST	UNKNOWN,")"
      0  0ecd					      db	32
      1  0ecd		       20		      .byte.b	32
      0  0ece					      db	(UNKNOWN-*)-1
      1  0ece		       a8		      .byte.b	(UNKNOWN-*)-1
      0  0ecf					      db	")",0
      1  0ecf		       29 00		      .byte.b	")",0
      0  0ed1					      POKEMEM
      0  0ed1					      db	47
      1  0ed1		       2f		      .byte.b	47
      0  0ed2					      IJMP	CO
      0  0ed2					      db	29
      1  0ed2		       1d		      .byte.b	29
      0  0ed3					      dw	CO
      1  0ed3		       01 0e		      .word.w	CO
    126  0ed5				   S8b
      0  0ed5					      TST	S8c,"PUTCH("	;Put a char to the terminal
      0  0ed5					      db	32
      1  0ed5		       20		      .byte.b	32
      0  0ed6					      db	(S8c-*)-1
      1  0ed6		       12		      .byte.b	(S8c-*)-1
      0  0ed7					      db	"PUTCH(",0
      1  0ed7		       50 55 54 43*	      .byte.b	"PUTCH(",0
      0  0ede					      CALL	EXPR
      0  0ede					      db	28
      1  0ede		       1c		      .byte.b	28
      0  0edf					      dw	EXPR
      1  0edf		       7a 0f		      .word.w	EXPR
      0  0ee1					      TST	UNKNOWN,")"
      0  0ee1					      db	32
      1  0ee1		       20		      .byte.b	32
      0  0ee2					      db	(UNKNOWN-*)-1
      1  0ee2		       94		      .byte.b	(UNKNOWN-*)-1
      0  0ee3					      db	")",0
      1  0ee3		       29 00		      .byte.b	")",0
      0  0ee5					      PUTCHAR
      0  0ee5					      db	52
      1  0ee5		       34		      .byte.b	52
      0  0ee6					      IJMP	CO
      0  0ee6					      db	29
      1  0ee6		       1d		      .byte.b	29
      0  0ee7					      dw	CO
      1  0ee7		       01 0e		      .word.w	CO
    132  0ee9				   S8c
      0  0ee9					      TST	S9,"CLS"	;Clear the screen
      0  0ee9					      db	32
      1  0ee9		       20		      .byte.b	32
      0  0eea					      db	(S9-*)-1
      1  0eea		       08		      .byte.b	(S9-*)-1
      0  0eeb					      db	"CLS",0
      1  0eeb		       43 4c 53 00	      .byte.b	"CLS",0
      0  0eef					      CLEARSCREEN
      0  0eef					      db	46
      1  0eef		       2e		      .byte.b	46
      0  0ef0					      IJMP	CO
      0  0ef0					      db	29
      1  0ef0		       1d		      .byte.b	29
      0  0ef1					      dw	CO
      1  0ef1		       01 0e		      .word.w	CO
    136  0ef3				   S9
      0  0ef3					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  0ef3					      db	32
      1  0ef3		       20		      .byte.b	32
      0  0ef4					      db	(S13-*)-1
      1  0ef4		       18		      .byte.b	(S13-*)-1
      0  0ef5					      db	"INPUT",0
      1  0ef5		       49 4e 50 55*	      .byte.b	"INPUT",0
    138  0efb				   S10
      0  0efb					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  0efb					      db	33
      1  0efb		       21		      .byte.b	33
      0  0efc					      db	(UNKNOWN-*)-1
      1  0efc		       7a		      .byte.b	(UNKNOWN-*)-1
      0  0efd					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  0efd					      db	11
      1  0efd		       0b		      .byte.b	11
      0  0efe					      STORE		;STORE IT
      0  0efe					      db	19
      1  0efe		       13		      .byte.b	19
      0  0eff					      TST	S11,COMMA	;IS THERE MORE?
      0  0eff					      db	32
      1  0eff		       20		      .byte.b	32
      0  0f00					      db	(S11-*)-1
      1  0f00		       05		      .byte.b	(S11-*)-1
      0  0f01					      db	COMMA,0
      1  0f01		       2c 00		      .byte.b	COMMA,0
      0  0f03					      IJMP	S10	;YES
      0  0f03					      db	29
      1  0f03		       1d		      .byte.b	29
      0  0f04					      dw	S10
      1  0f04		       fb 0e		      .word.w	S10
    144  0f06
    145  0f06				   S11
      0  0f06					      DONE		;MUST BE CR
      0  0f06					      db	1
      1  0f06		       01		      .byte.b	1
      0  0f07					      NXT	CO	;SEQUENCE TO NEXT
      0  0f07					      db	6
      1  0f07		       06		      .byte.b	6
      0  0f08					      dw	CO
      1  0f08		       01 0e		      .word.w	CO
      0  0f0a					      IJMP	STMT
      0  0f0a					      db	29
      1  0f0a		       1d		      .byte.b	29
      0  0f0b					      dw	STMT
      1  0f0b		       09 0e		      .word.w	STMT
    149  0f0d				   S13
      0  0f0d					      TST	S14,"END"
      0  0f0d					      db	32
      1  0f0d		       20		      .byte.b	32
      0  0f0e					      db	(S14-*)-1
      1  0f0e		       05		      .byte.b	(S14-*)-1
      0  0f0f					      db	"END",0
      1  0f0f		       45 4e 44 00	      .byte.b	"END",0
      0  0f13					      FIN
      0  0f13					      db	12
      1  0f13		       0c		      .byte.b	12
    152  0f14				   S14
      0  0f14					      TST	S15,"LIST"	;LIST COMMAND
      0  0f14					      db	32
      1  0f14		       20		      .byte.b	32
      0  0f15					      db	(S15-*)-1
      1  0f15		       0a		      .byte.b	(S15-*)-1
      0  0f16					      db	"LIST",0
      1  0f16		       4c 49 53 54*	      .byte.b	"LIST",0
      0  0f1b					      DONE
      0  0f1b					      db	1
      1  0f1b		       01		      .byte.b	1
      0  0f1c					      LST
      0  0f1c					      db	21
      1  0f1c		       15		      .byte.b	21
      0  0f1d					      IJMP	CO
      0  0f1d					      db	29
      1  0f1d		       1d		      .byte.b	29
      0  0f1e					      dw	CO
      1  0f1e		       01 0e		      .word.w	CO
    157  0f20				   S15
      0  0f20					      TST	S16,"RUN"	;RUN COMMAND
      0  0f20					      db	32
      1  0f20		       20		      .byte.b	32
      0  0f21					      db	(S16-*)-1
      1  0f21		       0d		      .byte.b	(S16-*)-1
      0  0f22					      db	"RUN",0
      1  0f22		       52 55 4e 00	      .byte.b	"RUN",0
      0  0f26					      DONE
      0  0f26					      db	1
      1  0f26		       01		      .byte.b	1
      0  0f27					      VINIT		;clear variables
      0  0f27					      db	30
      1  0f27		       1e		      .byte.b	30
      0  0f28					      LIT	1	;GOTO line 1
      0  0f28					      db	27
      1  0f28		       1b		      .byte.b	27
      0  0f29					      dw	1
      1  0f29		       01 00		      .word.w	1
      0  0f2b					      XFER		;Bob's addition
      0  0f2b					      db	7
      1  0f2b		       07		      .byte.b	7
    163  0f2c							; EXIT
      0  0f2c					      IJMP	STMT	;and run!
      0  0f2c					      db	29
      1  0f2c		       1d		      .byte.b	29
      0  0f2d					      dw	STMT
      1  0f2d		       09 0e		      .word.w	STMT
    165  0f2f				   S16
      0  0f2f					      TST	S17A,"NEW"	;clear program
      0  0f2f					      db	32
      1  0f2f		       20		      .byte.b	32
      0  0f30					      db	(S17A-*)-1
      1  0f30		       08		      .byte.b	(S17A-*)-1
      0  0f31					      db	"NEW",0
      1  0f31		       4e 45 57 00	      .byte.b	"NEW",0
      0  0f35					      DONE
      0  0f35					      db	1
      1  0f35		       01		      .byte.b	1
      0  0f36					      IJMP	START
      0  0f36					      db	29
      1  0f36		       1d		      .byte.b	29
      0  0f37					      dw	START
      1  0f37		       fb 0d		      .word.w	START
    169  0f39
    170  0f39				   S17A
      0  0f39					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  0f39					      db	32
      1  0f39		       20		      .byte.b	32
      0  0f3a					      db	(S17B-*)-1
      1  0f3a		       06		      .byte.b	(S17B-*)-1
      0  0f3b					      db	"EXIT",0
      1  0f3b		       45 58 49 54*	      .byte.b	"EXIT",0
      0  0f40					      EXIT
      0  0f40					      db	26
      1  0f40		       1a		      .byte.b	26
    173  0f41
    174  0f41							;
    175  0f41							; Commands related to saving/restoring programs
    176  0f41							; to/from mass storage.
    177  0f41							;
    178  0f41				   S17B
    179  0f41					      if	(XKIM || CTMON65) && DISK_ACCESS
    180  0f41
      0  0f41					      TST	S17C,"SAVE"
      0  0f41					      db	32
      1  0f41		       20		      .byte.b	32
      0  0f42					      db	(S17C-*)-1
      1  0f42		       0b		      .byte.b	(S17C-*)-1
      0  0f43					      db	"SAVE",0
      1  0f43		       53 41 56 45*	      .byte.b	"SAVE",0
      0  0f48					      OPENWRITE
      0  0f48					      db	40
      1  0f48		       28		      .byte.b	40
      0  0f49					      DLIST
      0  0f49					      db	43
      1  0f49		       2b		      .byte.b	43
      0  0f4a					      DCLOSE
      0  0f4a					      db	41
      1  0f4a		       29		      .byte.b	41
      0  0f4b					      IJMP	CO
      0  0f4b					      db	29
      1  0f4b		       1d		      .byte.b	29
      0  0f4c					      dw	CO
      1  0f4c		       01 0e		      .word.w	CO
    186  0f4e
    187  0f4e				   S17C
      0  0f4e					      TST	S18,"LOAD"
      0  0f4e					      db	32
      1  0f4e		       20		      .byte.b	32
      0  0f4f					      db	(S18-*)-1
      1  0f4f		       11		      .byte.b	(S18-*)-1
      0  0f50					      db	"LOAD",0
      1  0f50		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  0f55					      OPENREAD
      0  0f55					      db	39
      1  0f55		       27		      .byte.b	39
    190  0f56				   S17CLP
      0  0f56					      DGETLINE		;get line from file
      0  0f56					      db	42
      1  0f56		       2a		      .byte.b	42
      0  0f57					      TSTL	S17EOL	;no line num means EOL
      0  0f57					      db	34
      1  0f57		       22		      .byte.b	34
      0  0f58					      db	(S17EOL-*)-1
      1  0f58		       04		      .byte.b	(S17EOL-*)-1
      0  0f59					      INSERT		;put it into the program
      0  0f59					      db	24
      1  0f59		       18		      .byte.b	24
      0  0f5a					      IJMP	S17CLP	;keep going
      0  0f5a					      db	29
      1  0f5a		       1d		      .byte.b	29
      0  0f5b					      dw	S17CLP
      1  0f5b		       56 0f		      .word.w	S17CLP
    195  0f5d				   S17EOL
      0  0f5d					      DCLOSE		;close disk file
      0  0f5d					      db	41
      1  0f5d		       29		      .byte.b	41
      0  0f5e					      IJMP	CO	;back to start
      0  0f5e					      db	29
      1  0f5e		       1d		      .byte.b	29
      0  0f5f					      dw	CO
      1  0f5f		       01 0e		      .word.w	CO
    198  0f61
      0  0f61				   S18	      TST	S19,"DIR"
      0  0f61					      db	32
      1  0f61		       20		      .byte.b	32
      0  0f62					      db	(S19-*)-1
      1  0f62		       08		      .byte.b	(S19-*)-1
      0  0f63					      db	"DIR",0
      1  0f63		       44 49 52 00	      .byte.b	"DIR",0
      0  0f67					      DDIR		;Display the directory content
      0  0f67					      db	44
      1  0f67		       2c		      .byte.b	44
      0  0f68					      IJMP	CO
      0  0f68					      db	29
      1  0f68		       1d		      .byte.b	29
      0  0f69					      dw	CO
      1  0f69		       01 0e		      .word.w	CO
    202  0f6b					      endif
    203  0f6b
      0  0f6b				   S19	      TST	UNKNOWN,"ERASE"
      0  0f6b					      db	32
      1  0f6b		       20		      .byte.b	32
      0  0f6c					      db	(UNKNOWN-*)-1
      1  0f6c		       0a		      .byte.b	(UNKNOWN-*)-1
      0  0f6d					      db	"ERASE",0
      1  0f6d		       45 52 41 53*	      .byte.b	"ERASE",0
      0  0f73					      RMFILE		;Display the directory content
      0  0f73					      db	45
      1  0f73		       2d		      .byte.b	45
      0  0f74					      IJMP	CO
      0  0f74					      db	29
      1  0f74		       1d		      .byte.b	29
      0  0f75					      dw	CO
      1  0f75		       01 0e		      .word.w	CO
    207  0f75					      endif
    208  0f77
    209  0f77							;
    210  0f77							; Else, unknown command.
    211  0f77							;
    212  0f77				   UNKNOWN
      0  0f77					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  0f77					      db	13
      1  0f77		       0d		      .byte.b	13
      0  0f78					      dw	ERR_SYNTAX
      1  0f78		       05 00		      .word.w	ERR_SYNTAX
    214  0f7a
    215  0f7a							;-----------------------------------------------------
    216  0f7a				   EXPR
      0  0f7a					      TST	E0,"-"
      0  0f7a					      db	32
      1  0f7a		       20		      .byte.b	32
      0  0f7b					      db	(E0-*)-1
      1  0f7b		       09		      .byte.b	(E0-*)-1
      0  0f7c					      db	"-",0
      1  0f7c		       2d 00		      .byte.b	"-",0
      0  0f7e					      CALL	TERM	;TEST FOR UNARY -.
      0  0f7e					      db	28
      1  0f7e		       1c		      .byte.b	28
      0  0f7f					      dw	TERM
      1  0f7f		       a3 0f		      .word.w	TERM
      0  0f81					      NEG		;GET VALUE
      0  0f81					      db	16
      1  0f81		       10		      .byte.b	16
      0  0f82					      IJMP	E1	;NEGATE IT
      0  0f82					      db	29
      1  0f82		       1d		      .byte.b	29
      0  0f83					      dw	E1
      1  0f83		       8c 0f		      .word.w	E1
    221  0f85				   E0
      0  0f85					      TST	E1A,"+"	;LOOK FOR MORE
      0  0f85					      db	32
      1  0f85		       20		      .byte.b	32
      0  0f86					      db	(E1A-*)-1
      1  0f86		       02		      .byte.b	(E1A-*)-1
      0  0f87					      db	"+",0
      1  0f87		       2b 00		      .byte.b	"+",0
    223  0f89				   E1A
      0  0f89					      CALL	TERM	;TEST FOR UNARY +
      0  0f89					      db	28
      1  0f89		       1c		      .byte.b	28
      0  0f8a					      dw	TERM
      1  0f8a		       a3 0f		      .word.w	TERM
    225  0f8c				   E1
      0  0f8c					      TST	E2,"+"	;LEADING TERM
      0  0f8c					      db	32
      1  0f8c		       20		      .byte.b	32
      0  0f8d					      db	(E2-*)-1
      1  0f8d		       09		      .byte.b	(E2-*)-1
      0  0f8e					      db	"+",0
      1  0f8e		       2b 00		      .byte.b	"+",0
      0  0f90					      CALL	TERM
      0  0f90					      db	28
      1  0f90		       1c		      .byte.b	28
      0  0f91					      dw	TERM
      1  0f91		       a3 0f		      .word.w	TERM
      0  0f93					      ADD
      0  0f93					      db	14
      1  0f93		       0e		      .byte.b	14
      0  0f94					      IJMP	E1
      0  0f94					      db	29
      1  0f94		       1d		      .byte.b	29
      0  0f95					      dw	E1
      1  0f95		       8c 0f		      .word.w	E1
    230  0f97				   E2
      0  0f97					      TST	E3,"-"	;ANY MORE?
      0  0f97					      db	32
      1  0f97		       20		      .byte.b	32
      0  0f98					      db	(E3-*)-1
      1  0f98		       09		      .byte.b	(E3-*)-1
      0  0f99					      db	"-",0
      1  0f99		       2d 00		      .byte.b	"-",0
      0  0f9b					      CALL	TERM	;DIFFERENCE TERM
      0  0f9b					      db	28
      1  0f9b		       1c		      .byte.b	28
      0  0f9c					      dw	TERM
      1  0f9c		       a3 0f		      .word.w	TERM
      0  0f9e					      SUB
      0  0f9e					      db	15
      1  0f9e		       0f		      .byte.b	15
      0  0f9f					      IJMP	E1
      0  0f9f					      db	29
      1  0f9f		       1d		      .byte.b	29
      0  0fa0					      dw	E1
      1  0fa0		       8c 0f		      .word.w	E1
    235  0fa2				   E3
    236  0fa2				   T2
      0  0fa2					      RTN		;ANY MORE?
      0  0fa2					      db	25
      1  0fa2		       19		      .byte.b	25
    238  0fa3				   TERM
      0  0fa3					      CALL	FACT
      0  0fa3					      db	28
      1  0fa3		       1c		      .byte.b	28
      0  0fa4					      dw	FACT
      1  0fa4		       bf 0f		      .word.w	FACT
    240  0fa6				   T0
      0  0fa6					      TST	T1,"*"
      0  0fa6					      db	32
      1  0fa6		       20		      .byte.b	32
      0  0fa7					      db	(T1-*)-1
      1  0fa7		       09		      .byte.b	(T1-*)-1
      0  0fa8					      db	"*",0
      1  0fa8		       2a 00		      .byte.b	"*",0
      0  0faa					      CALL	FACT	;PRODUCT FACTOR.
      0  0faa					      db	28
      1  0faa		       1c		      .byte.b	28
      0  0fab					      dw	FACT
      1  0fab		       bf 0f		      .word.w	FACT
      0  0fad					      MUL
      0  0fad					      db	17
      1  0fad		       11		      .byte.b	17
      0  0fae					      IJMP	T0
      0  0fae					      db	29
      1  0fae		       1d		      .byte.b	29
      0  0faf					      dw	T0
      1  0faf		       a6 0f		      .word.w	T0
    245  0fb1				   T1
      0  0fb1					      TST	T2,"/"
      0  0fb1					      db	32
      1  0fb1		       20		      .byte.b	32
      0  0fb2					      db	(T2-*)-1
      1  0fb2		       ef		      .byte.b	(T2-*)-1
      0  0fb3					      db	"/",0
      1  0fb3		       2f 00		      .byte.b	"/",0
      0  0fb5					      CALL	FACT	;QUOTIENT FACTOR.
      0  0fb5					      db	28
      1  0fb5		       1c		      .byte.b	28
      0  0fb6					      dw	FACT
      1  0fb6		       bf 0f		      .word.w	FACT
      0  0fb8					      DIV
      0  0fb8					      db	18
      1  0fb8		       12		      .byte.b	18
      0  0fb9					      IJMP	T0
      0  0fb9					      db	29
      1  0fb9		       1d		      .byte.b	29
      0  0fba					      dw	T0
      1  0fba		       a6 0f		      .word.w	T0
    250  0fbc
    251  0fbc				   UNKNOWNVEC
      0  0fbc					      IJMP	UNKNOWN
      0  0fbc					      db	29
      1  0fbc		       1d		      .byte.b	29
      0  0fbd					      dw	UNKNOWN
      1  0fbd		       77 0f		      .word.w	UNKNOWN
    253  0fbf
    254  0fbf							;
    255  0fbf							; Factor an expression.  Always test for functions
    256  0fbf							; first or else they'll be confused for variables.
    257  0fbf							;
    258  0fbf				   FACT
      0  0fbf					      TST	F1A,"FREE()"
      0  0fbf					      db	32
      1  0fbf		       20		      .byte.b	32
      0  0fc0					      db	(F1A-*)-1
      1  0fc0		       09		      .byte.b	(F1A-*)-1
      0  0fc1					      db	"FREE()",0
      1  0fc1		       46 52 45 45*	      .byte.b	"FREE()",0
      0  0fc8					      FREE
      0  0fc8					      db	36
      1  0fc8		       24		      .byte.b	36
      0  0fc9					      RTN
      0  0fc9					      db	25
      1  0fc9		       19		      .byte.b	25
    262  0fca				   F1A
      0  0fca					      TST	F2A,"GETCH()"	; read char from the terminal
      0  0fca					      db	32
      1  0fca		       20		      .byte.b	32
      0  0fcb					      db	(F2A-*)-1
      1  0fcb		       0a		      .byte.b	(F2A-*)-1
      0  0fcc					      db	"GETCH()",0
      1  0fcc		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  0fd4					      GETCHAR
      0  0fd4					      db	51
      1  0fd4		       33		      .byte.b	51
      0  0fd5					      RTN
      0  0fd5					      db	25
      1  0fd5		       19		      .byte.b	25
    266  0fd6							;
    267  0fd6							; RND() is supposed to have an argument but if none
    268  0fd6							; was provided, just assume a large value.
    269  0fd6							;
    270  0fd6				   F2A
      0  0fd6					      TST	F2B,"RND("
      0  0fd6					      db	32
      1  0fd6		       20		      .byte.b	32
      0  0fd7					      db	(F2B-*)-1
      1  0fd7		       17		      .byte.b	(F2B-*)-1
      0  0fd8					      db	"RND(",0
      1  0fd8		       52 4e 44 28*	      .byte.b	"RND(",0
      0  0fdd					      TST	F2A1,")"
      0  0fdd					      db	32
      1  0fdd		       20		      .byte.b	32
      0  0fde					      db	(F2A1-*)-1
      1  0fde		       07		      .byte.b	(F2A1-*)-1
      0  0fdf					      db	")",0
      1  0fdf		       29 00		      .byte.b	")",0
      0  0fe1					      LIT	32766
      0  0fe1					      db	27
      1  0fe1		       1b		      .byte.b	27
      0  0fe2					      dw	32766
      1  0fe2		       fe 7f		      .word.w	32766
      0  0fe4					      RANDOM
      0  0fe4					      db	37
      1  0fe4		       25		      .byte.b	37
      0  0fe5					      RTN
      0  0fe5					      db	25
      1  0fe5		       19		      .byte.b	25
    276  0fe6				   F2A1
      0  0fe6					      CALL	FACT	;GET RANGE
      0  0fe6					      db	28
      1  0fe6		       1c		      .byte.b	28
      0  0fe7					      dw	FACT
      1  0fe7		       bf 0f		      .word.w	FACT
      0  0fe9					      TST	UNKNOWN,")"
      0  0fe9					      db	32
      1  0fe9		       20		      .byte.b	32
      0  0fea					      db	(UNKNOWN-*)-1
      1  0fea		       8c		      .byte.b	(UNKNOWN-*)-1
      0  0feb					      db	")",0
      1  0feb		       29 00		      .byte.b	")",0
      0  0fed					      RANDOM
      0  0fed					      db	37
      1  0fed		       25		      .byte.b	37
      0  0fee					      RTN
      0  0fee					      db	25
      1  0fee		       19		      .byte.b	25
    281  0fef
    282  0fef				   F2B
      0  0fef					      TST	F2B1,"ABS("
      0  0fef					      db	32
      1  0fef		       20		      .byte.b	32
      0  0ff0					      db	(F2B1-*)-1
      1  0ff0		       0e		      .byte.b	(F2B1-*)-1
      0  0ff1					      db	"ABS(",0
      1  0ff1		       41 42 53 28*	      .byte.b	"ABS(",0
      0  0ff6					      CALL	FACT	;get value
      0  0ff6					      db	28
      1  0ff6		       1c		      .byte.b	28
      0  0ff7					      dw	FACT
      1  0ff7		       bf 0f		      .word.w	FACT
      0  0ff9					      TST	UNKNOWN,")"
      0  0ff9					      db	32
      1  0ff9		       20		      .byte.b	32
      0  0ffa					      db	(UNKNOWN-*)-1
      1  0ffa		       7c		      .byte.b	(UNKNOWN-*)-1
      0  0ffb					      db	")",0
      1  0ffb		       29 00		      .byte.b	")",0
      0  0ffd					      ABS
      0  0ffd					      db	38
      1  0ffd		       26		      .byte.b	38
      0  0ffe					      RTN
      0  0ffe					      db	25
      1  0ffe		       19		      .byte.b	25
    288  0fff
    289  0fff				   F2B1
      0  0fff					      TST	F2B2,"PEEK("	;Return a value from memory
      0  0fff					      db	32
      1  0fff		       20		      .byte.b	32
      0  1000					      db	(F2B2-*)-1
      1  1000		       0f		      .byte.b	(F2B2-*)-1
      0  1001					      db	"PEEK(",0
      1  1001		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1007					      CALL	EXPR	;Get the address to write to
      0  1007					      db	28
      1  1007		       1c		      .byte.b	28
      0  1008					      dw	EXPR
      1  1008		       7a 0f		      .word.w	EXPR
      0  100a					      TST	UNKNOWN,")"	;Closing bracket
      0  100a					      db	32
      1  100a		       20		      .byte.b	32
      0  100b					      db	(UNKNOWN-*)-1
      1  100b		       6b		      .byte.b	(UNKNOWN-*)-1
      0  100c					      db	")",0
      1  100c		       29 00		      .byte.b	")",0
      0  100e					      PEEKMEM
      0  100e					      db	48
      1  100e		       30		      .byte.b	48
      0  100f					      RTN
      0  100f					      db	25
      1  100f		       19		      .byte.b	25
    295  1010				   F2B2
      0  1010					      TST	F2C,"CALL("	;call machine function
      0  1010					      db	32
      1  1010		       20		      .byte.b	32
      0  1011					      db	(F2C-*)-1
      1  1011		       1c		      .byte.b	(F2C-*)-1
      0  1012					      db	"CALL(",0
      1  1012		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1018					      CALL	EXPR
      0  1018					      db	28
      1  1018		       1c		      .byte.b	28
      0  1019					      dw	EXPR
      1  1019		       7a 0f		      .word.w	EXPR
      0  101b					      TST	F2B2A,COMMA
      0  101b					      db	32
      1  101b		       20		      .byte.b	32
      0  101c					      db	(F2B2A-*)-1
      1  101c		       0b		      .byte.b	(F2B2A-*)-1
      0  101d					      db	COMMA,0
      1  101d		       2c 00		      .byte.b	COMMA,0
      0  101f					      CALL	EXPR
      0  101f					      db	28
      1  101f		       1c		      .byte.b	28
      0  1020					      dw	EXPR
      1  1020		       7a 0f		      .word.w	EXPR
      0  1022					      TST	UNKNOWN,")"
      0  1022					      db	32
      1  1022		       20		      .byte.b	32
      0  1023					      db	(UNKNOWN-*)-1
      1  1023		       53		      .byte.b	(UNKNOWN-*)-1
      0  1024					      db	")",0
      1  1024		       29 00		      .byte.b	")",0
      0  1026					      CALLFUNC2
      0  1026					      db	54
      1  1026		       36		      .byte.b	54
      0  1027					      RTN
      0  1027					      db	25
      1  1027		       19		      .byte.b	25
      0  1028				   F2B2A      TST	UNKNOWN,")"
      0  1028					      db	32
      1  1028		       20		      .byte.b	32
      0  1029					      db	(UNKNOWN-*)-1
      1  1029		       4d		      .byte.b	(UNKNOWN-*)-1
      0  102a					      db	")",0
      1  102a		       29 00		      .byte.b	")",0
      0  102c					      CALLFUNC
      0  102c					      db	53
      1  102c		       35		      .byte.b	53
      0  102d					      RTN
      0  102d					      db	25
      1  102d		       19		      .byte.b	25
    306  102e				   F2C
      0  102e					      TSTV	F0
      0  102e					      db	33
      1  102e		       21		      .byte.b	33
      0  102f					      db	(F0-*)-1
      1  102f		       02		      .byte.b	(F0-*)-1
      0  1030					      IND		;YES, GET THE VALUE.
      0  1030					      db	20
      1  1030		       14		      .byte.b	20
      0  1031					      RTN
      0  1031					      db	25
      1  1031		       19		      .byte.b	25
    310  1032				   F0
      0  1032					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1032					      db	35
      1  1032		       23		      .byte.b	35
      0  1033					      db	(F1-*)-1
      1  1033		       01		      .byte.b	(F1-*)-1
      0  1034					      RTN
      0  1034					      db	25
      1  1034		       19		      .byte.b	25
    313  1035				   F1
      0  1035					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  1035					      db	32
      1  1035		       20		      .byte.b	32
      0  1036					      db	(F2A-*)-1
      1  1036		       9f		      .byte.b	(F2A-*)-1
      0  1037					      db	"(",0
      1  1037		       28 00		      .byte.b	"(",0
      0  1039					      CALL	EXPR
      0  1039					      db	28
      1  1039		       1c		      .byte.b	28
      0  103a					      dw	EXPR
      1  103a		       7a 0f		      .word.w	EXPR
      0  103c					      TST	F2,")"
      0  103c					      db	32
      1  103c		       20		      .byte.b	32
      0  103d					      db	(F2-*)-1
      1  103d		       03		      .byte.b	(F2-*)-1
      0  103e					      db	")",0
      1  103e		       29 00		      .byte.b	")",0
      0  1040					      RTN
      0  1040					      db	25
      1  1040		       19		      .byte.b	25
    318  1041
    319  1041				   F2
      0  1041					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1041					      db	13
      1  1041		       0d		      .byte.b	13
      0  1042					      dw	ERR_SYNTAX
      1  1042		       05 00		      .word.w	ERR_SYNTAX
    321  1044
    322  1044				   RELOP
      0  1044					      TST	iR0,"="
      0  1044					      db	32
      1  1044		       20		      .byte.b	32
      0  1045					      db	(iR0-*)-1
      1  1045		       06		      .byte.b	(iR0-*)-1
      0  1046					      db	"=",0
      1  1046		       3d 00		      .byte.b	"=",0
      0  1048					      LIT	2	;=
      0  1048					      db	27
      1  1048		       1b		      .byte.b	27
      0  1049					      dw	2
      1  1049		       02 00		      .word.w	2
      0  104b					      RTN
      0  104b					      db	25
      1  104b		       19		      .byte.b	25
    326  104c				   iR0
      0  104c					      TST	R4,"<"
      0  104c					      db	32
      1  104c		       20		      .byte.b	32
      0  104d					      db	(R4-*)-1
      1  104d		       16		      .byte.b	(R4-*)-1
      0  104e					      db	"<",0
      1  104e		       3c 00		      .byte.b	"<",0
      0  1050					      TST	iR1,"="
      0  1050					      db	32
      1  1050		       20		      .byte.b	32
      0  1051					      db	(iR1-*)-1
      1  1051		       06		      .byte.b	(iR1-*)-1
      0  1052					      db	"=",0
      1  1052		       3d 00		      .byte.b	"=",0
      0  1054					      LIT	3	;<=
      0  1054					      db	27
      1  1054		       1b		      .byte.b	27
      0  1055					      dw	3
      1  1055		       03 00		      .word.w	3
      0  1057					      RTN
      0  1057					      db	25
      1  1057		       19		      .byte.b	25
    331  1058				   iR1
      0  1058					      TST	R3,">"
      0  1058					      db	32
      1  1058		       20		      .byte.b	32
      0  1059					      db	(R3-*)-1
      1  1059		       06		      .byte.b	(R3-*)-1
      0  105a					      db	">",0
      1  105a		       3e 00		      .byte.b	">",0
      0  105c					      LIT	5	;<>
      0  105c					      db	27
      1  105c		       1b		      .byte.b	27
      0  105d					      dw	5
      1  105d		       05 00		      .word.w	5
      0  105f					      RTN
      0  105f					      db	25
      1  105f		       19		      .byte.b	25
    335  1060				   R3
      0  1060					      LIT	1	;<
      0  1060					      db	27
      1  1060		       1b		      .byte.b	27
      0  1061					      dw	1
      1  1061		       01 00		      .word.w	1
      0  1063					      RTN
      0  1063					      db	25
      1  1063		       19		      .byte.b	25
    338  1064				   R4
      0  1064					      TST	UNKNOWNVEC,">"
      0  1064					      db	32
      1  1064		       20		      .byte.b	32
      0  1065					      db	(UNKNOWNVEC-*)-1
      1  1065		       56		      .byte.b	(UNKNOWNVEC-*)-1
      0  1066					      db	">",0
      1  1066		       3e 00		      .byte.b	">",0
      0  1068					      TST	R5,"="
      0  1068					      db	32
      1  1068		       20		      .byte.b	32
      0  1069					      db	(R5-*)-1
      1  1069		       06		      .byte.b	(R5-*)-1
      0  106a					      db	"=",0
      1  106a		       3d 00		      .byte.b	"=",0
      0  106c					      LIT	6	;>=
      0  106c					      db	27
      1  106c		       1b		      .byte.b	27
      0  106d					      dw	6
      1  106d		       06 00		      .word.w	6
      0  106f					      RTN
      0  106f					      db	25
      1  106f		       19		      .byte.b	25
    343  1070				   R5
      0  1070					      TST	R6,"<"
      0  1070					      db	32
      1  1070		       20		      .byte.b	32
      0  1071					      db	(R6-*)-1
      1  1071		       06		      .byte.b	(R6-*)-1
      0  1072					      db	"<",0
      1  1072		       3c 00		      .byte.b	"<",0
      0  1074					      LIT	1
      0  1074					      db	27
      1  1074		       1b		      .byte.b	27
      0  1075					      dw	1
      1  1075		       01 00		      .word.w	1
      0  1077					      RTN		;(This line originally omitted)
      0  1077					      db	25
      1  1077		       19		      .byte.b	25
    347  1078				   R6
      0  1078					      LIT	4	;>???
      0  1078					      db	27
      1  1078		       1b		      .byte.b	27
      0  1079					      dw	4
      1  1079		       04 00		      .word.w	4
      0  107b					      RTN
      0  107b					      db	25
      1  107b		       19		      .byte.b	25
    350  107c
    351  107c		       10 7c	   ILEND      equ	*
------- FILE mytb.asm
   1538  107c		       10 7c	   PROGEND    equ	*
   1539  107c
   1540  107c							;=====================================================
   1541  107c							;=====================================================
   1542  107c							;=====================================================
   1543  107c							; These are storage items not in page zero.
   1544  107c							;
   1545 U1139 ????				      SEG.U	NotZeroPG
   1546 U107c					      org	PROGEND
   1547 U107c
   1548 U107c		       00 00 00 00*mathStack  ds	STACKSIZE*2
   1549 U108c		       00	   mathStackPtr ds	1
   1550 U108d		       00 00 00 00*retStack   ds	STACKSIZE*2
   1551 U109d		       00	   retStackPtr ds	1
   1552 U109e							;callStack	ds	GOSUBSTACKSIZE*2
   1553 U109e		       00	   GoSubStackPtr ds	1
   1554 U109f		       00 00 00 00*LINBUF     ds	132
   1555 U1123		       00	   getlinx    ds	1
   1556 U1124		       00	   printtx    ds	1	;temp X for print funcs
   1557 U1125		       00	   diddigit   ds	1	;for leading zero suppression
   1558 U1126		       00	   putsy      ds	1
   1559 U1127		       00 00	   errGoto    ds	2	;where to set ILPC on err
   1560 U1129		       00 00	   MQ	      ds	2	;used for some math
   1561 U112b		       00	   sign       ds	1	;0 = positive, else negative
   1562 U112c		       00	   rtemp1     ds	1
   1563 U112d		       00 00	   random     ds	2
   1564 U112f		       00 00	   BOutVec    ds	2
   1565 U1131				  -	      if	XKIM
   1566 U1131				  -buffer     ds	BUFFER_SIZE
   1567 U1131					      endif
   1568 U1131							;
   1569 U1131							; PROGRAMEND is the end of the user's BASIC program.
   1570 U1131							; More precisely, it is one byte past the end.  Or,
   1571 U1131							; it's where the next line added to the end will be
   1572 U1131							; placed.
   1573 U1131							;
   1574 U1131		       00 00	   PROGRAMEND ds	2
   1575 U1133		       00 00	   HighMem    ds	2	;highest location
   1576 U1135		       00 00	   UsedMem    ds	2	;size of user program
   1577 U1137		       00 00	   FreeMem    ds	2	;amount of free memory
   1578 U1139							;
   1579 U1139							;=====================================================
   1580 U1139							; This is the start of the user's BASIC program space.
   1581 U1139							;
   1582 U1139							; PERSONAL GOAL: This should be no larger than $0DFF.
   1583 U1139							;		  0200-05FF = 1K
   1584 U1139							;		  0200-09FF = 2K
   1585 U1139							;		  0200-0DFF = 3K
   1586 U1139							;		  0200-11FF = 4K
   1587 U1139							;		  0200-13FF = 4.5K
   1588 U1139							;
   1589 U1139				  -	      if	FIXED
   1590 U1139				  -	      org	$2000
   1591 U1139					      endif
   1592 U1139		       11 39	   ProgramStart equ	*
   1593 U1139							;/*
   1594 U1139							;	if	CTMON65 || XKIM
   1595 U1139							;		SEG code
   1596 U1139							;		org	AutoRun
   1597 U1139							;		dw	TBasicCold
   1598 U1139							;	endif
   1599 U1139							;*/
   1600 U1139					      end
