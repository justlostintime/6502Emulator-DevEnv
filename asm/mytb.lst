------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2f72				   input      processor	6502
      2 U2f72 ????						;=====================================================
      3 U2f72 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2f72 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2f72 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2f72 ????						;
      7 U2f72 ????						; While working on the Corsham Technologies KIM Clone
      8 U2f72 ????						; project, I wanted to include a TINY BASIC since that
      9 U2f72 ????						; was a highly desirable feature of early computers.
     10 U2f72 ????						;
     11 U2f72 ????						; Rather than negotiating copyright issues for
     12 U2f72 ????						; existing BASICs, I decided to just write one from
     13 U2f72 ????						; scratch.
     14 U2f72 ????						;
     15 U2f72 ????						; 10/07/2017
     16 U2f72 ????						;
     17 U2f72 ????						; This implements a stripped down Tiny BASIC
     18 U2f72 ????						; interpreter using the Interpretive Language (IL)
     19 U2f72 ????						; method as described in the first few issues of
     20 U2f72 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2f72 ????						; to write various languages simply by changing the
     22 U2f72 ????						; IL code rather than the interpreter itself.
     23 U2f72 ????						;
     24 U2f72 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2f72 ????						;		* Fixed major bug in findLine that
     26 U2f72 ????						;		  caused corrupted lines, crashes, etc.
     27 U2f72 ????						;		* If no parameter given to RND, assume
     28 U2f72 ????						;		  32766.
     29 U2f72 ????						;		* No more error 5 when a program
     30 U2f72 ????						;		  reaches the end without an END.
     31 U2f72 ????						;
     32 U2f72 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2f72 ????						;		 * Unexpanded version to play with everything
     34 U2f72 ????						;		 * Add some usefull system level functions
     35 U2f72 ????						;		 * allow a larger number of tiny basic formats
     36 U2f72 ????						;		 * Add byte at start of line holding length
     37 U2f72 ????						;		   for faster execution of goto and gosub
     38 U2f72 ????						;		 * Re-added gosub
     39 U2f72 ????						;		 * allow ; or , at end if print stmt
     40 U2f72 ????						;		   without CRLF being added.
     41 U2f72 ????						;		 * Added extended function erase to
     42 U2f72 ????						;		   use the extended ctmon65 rm file
     43 U2f72 ????						;		 * Fix quoted text to not have to backtrack
     44 U2f72 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2f72 ????						;		 * Add concurrency features
     46 U2f72 ????						;
     47 U2f72 ????						; www.corshamtech.com
     48 U2f72 ????						; bob@corshamtech.com
     49 U2f72 ????						; JustLostInTime@gmail.com
     50 U2f72 ????						;
     51 U2f72 ????						;=====================================================
     52 U2f72 ????						;
     53 U2f72 ????						; Create TRUE and FALSE values for conditionals.
     54 U2f72 ????						;
     55 U2f72 ????
     56 U2f72 ????	       00 00	   FALSE      equ	0
     57 U2f72 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2f72 ????						;
     59 U2f72 ????						;---------------------------------------------------------
     60 U2f72 ????						; One of these must be set to indicate which environment
     61 U2f72 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2f72 ????						; environments:
     63 U2f72 ????						;
     64 U2f72 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2f72 ????						; more K of RAM.
     66 U2f72 ????						;
     67 U2f72 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2f72 ????						; which enhances, without replacing, the standard KIM
     69 U2f72 ????						; monitor.  It gives access to routines to save/load files
     70 U2f72 ????						; to a micro SD card.
     71 U2f72 ????						;
     72 U2f72 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2f72 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2f72 ????						; easily be ported to other systems.  It has support for
     75 U2f72 ????						; using a micro SD card for file storage/retrieval.
     76 U2f72 ????						;
     77 U2f72 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2f72 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2f72 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2f72 ????
     81 U2f72 ????						;
     82 U2f72 ????						;   Need to define some macros for the dasm assembler
     83 U2f72 ????						;
     84 U2f72 ????				      MACRO	dw
     85 U2f72 ????				      .word	{0}
     86 U2f72 ????				      ENDM
     87 U2f72 ????
     88 U2f72 ????				      MACRO	db
     89 U2f72 ????				      .byte	{0}
     90 U2f72 ????				      ENDM
     91 U2f72 ????
     92 U2f72 ????						;
     93 U2f72 ????						; If set, include disk functions.
     94 U2f72 ????						;
     95 U2f72 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     96 U2f72 ????						;
     97 U2f72 ????						; If ILTRACE is set then dump out the address of every
     98 U2f72 ????						; IL opcode before executing it.
     99 U2f72 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    100 U2f72 ????						;
    101 U2f72 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    102 U2f72 ????						;
    103 U2f72 ????						; If FIXED is set, put the IL code and the user
    104 U2f72 ????						; program space at fixed locations in memory.	This is
    105 U2f72 ????						; meant only for debugging.
    106 U2f72 ????						;
    107 U2f72 ????	       00 00	   FIXED      equ	FALSE
    108 U2f72 ????						;
    109 U2f72 ????						; Sets the arithmetic stack depth.  This is *TINY*
    110 U2f72 ????						; BASIC, so keep this small!
    111 U2f72 ????						;
    112 U2f72 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    113 U2f72 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    114 U2f72 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    115 U2f72 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    116 U2f72 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    117 U2f72 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    118 U2f72 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    119 U2f72 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    120 U2f72 ????						;
    121 U2f72 ????						; Gosub entry types
    122 U2f72 ????
    123 U2f72 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    124 U2f72 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    125 U2f72 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    126 U2f72 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    127 U2f72 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    128 U2f72 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    129 U2f72 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    130 U2f72 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    131 U2f72 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    132 U2f72 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    133 U2f72 ????						;
    134 U2f72 ????						; Common ASCII constants
    135 U2f72 ????						;
    136 U2f72 ????	       00 07	   BEL	      equ	$07
    137 U2f72 ????	       00 08	   BS	      equ	$08
    138 U2f72 ????	       00 09	   TAB	      equ	$09
    139 U2f72 ????	       00 0a	   LF	      equ	$0A
    140 U2f72 ????	       00 0d	   CR	      equ	$0D
    141 U2f72 ????	       00 22	   quote      equ	$22
    142 U2f72 ????	       00 20	   SPACE      equ	$20
    143 U2f72 ????	       00 2c	   COMMA      equ	',
    144 U2f72 ????	       00 3b	   SEMICOLON  equ	';
    145 U2f72 ????	       00 3a	   COLON      equ	':
    146 U2f72 ????	       00 24	   DOLLAR     equ	'$
    147 U2f72 ????						;
    148 U2f72 ????						; These are error codes
    149 U2f72 ????						;
    150 U2f72 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    151 U2f72 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    152 U2f72 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    153 U2f72 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    154 U2f72 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    155 U2f72 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    156 U2f72 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    157 U2f72 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    158 U2f72 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    159 U2f72 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    160 U2f72 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    161 U2f72 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    162 U2f72 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    163 U2f72 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    164 U2f72 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    165 U2f72 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    166 U2f72 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    167 U2f72 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    168 U2f72 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    169 U2f72 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    170 U2f72 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    171 U2f72 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    172 U2f72 ????						;
    173 U2f72 ????						;=====================================================
    174 U2f72 ????						; Zero page storage.
    175 U2f72 ????						;
    176 U00f6 ????				      SEG.U	ZEROPAGE
    177 U0040					      org	$0040
    178 U0040
    179 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    180 U0041
    181 U0041							; The context is used to locate a task switch
    182 U0041							; it copies from here till all task fields are saved/swapped
    183 U0041							; The max number of tasks is 256 / context length
    184 U0041							; All positions POS values are plus one task table incldues
    185 U0041							; a leading status byte .
    186 U0041							;
    187 U0041		       00 41	   CONTEXT    equ	*
    188 U0041
    189 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    190 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    191 U0043
    192 U0043		       00 00	   ILPC       ds	2	; IL program counter
    193 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    194 U0047		       00	   ILSTACKPTR ds	1
    195 U0048
    196 U0048
    197 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    198 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    199 U004a
    200 U004a
    201 U004a		       00	   MATHSTACKPTR ds	1
    202 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    203 U004b
    204 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    205 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT +1	; Get the offset to the gosub/msg stack
    206 U004d
    207 U004d
    208 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    209 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    210 U004e
    211 U004e
    212 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    213 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    214 U004f							;
    215 U004f							; CURPTR is a pointer to curent BASIC line being
    216 U004f							; executed.  Always points to start of line, CUROFF
    217 U004f							; is the offset to the current character.
    218 U004f							; The order of these fields is important
    219 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    220 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    221 U0052							;
    222 U0052							;The order of these fields in important
    223 U0052
    224 U0052							;
    225 U0052							; R0, R1 and MQ are used for arithmetic operations and
    226 U0052							; general use.
    227 U0052							;
    228 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    229 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    230 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    231 U0056		       00 00	   MQ	      ds	2	;used for some math
    232 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    233 U0058		       00 59	   REGISTERSEND equ	*
    234 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    235 U0059
    236 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    237 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    238 U0059
    239 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    240 U005b							;
    241 U005b							; This is zero if in immediate mode, or non-zero
    242 U005b							; if currently running a program.  Any input from
    243 U005b							; the main loop clears this, and the XFER IL
    244 U005b							; statement will set it.
    245 U005b							;
    246 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    247 U005c							;
    248 U005c							; Used for line insertion/removal.
    249 U005c							;
    250 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    251 U005e
    252 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    253 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    254 U005e							;
    255 U005e		       00 00	   PrtFrom    ds	2	; FROM
    256 U0060							;
    257 U0060							;=====================================================
    258 U0060							;Pointers for memory Management
    259 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    260 U0060							; Mem block format is
    261 U0060							;	 0-1   pointer to next block for free blocks
    262 U0060							;	 0-1   for allocated blocks
    263 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    264 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    265 U0060							;	 2-3   length constant for exevy type of memory block
    266 U0060							; Memory is recombined as it is released
    267 U0060							; The memory manager is not interupted durring allocation
    268 U0060							; or freeing of memory
    269 U0060							;====================================================
    270 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    271 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    272 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    273 U0066							;
    274 U0066							;=====================================================
    275 U0066							;
    276  25c8 ????				      SEG	Code
    277  0200					      org	$0200
    278  0200							;
    279  0200							; Cold start is at $0200.  Warm start is at $0203.
    280  0200							;
    281  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    282  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    283  0206							;
    284  0206							; These are the user-supplied vectors to I/O routines.
    285  0206							; If you want, you can just patch these in the binary
    286  0206							; file, but it would be better to change the source
    287  0206							; code.
    288  0206							;
    289  0206				  -	      if	KIM
    290  0206				  -OUTCH      jmp	$1ea0	;output char in A
    291  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    294  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    295  0206					      endif
    296  0206				  -	      if	XKIM
    297  0206				  -	      include	"xkim.inc"
    298  0206				  -	      SEG	Code
    299  0206				  -OUTCH      jmp	$1ea0
    300  0206				  -GETCH      jmp	xkGETCH
    301  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    302  0206				  -OUTHEX     jmp	xkPRTBYT
    303  0206				  -MONITOR    jmp	extKIM
    304  0206				  -puts       equ	putsil
    305  0206				  -BUFFER_SIZE equ	132
    306  0206					      endif
    307  0206
    308  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    310 Udf8e
    311  0206					      SEG	Code
    312  0206							;
    313  0206		       f0 0c	   OUTCH      equ	cout
    314  0206		       f0 09	   GETCH      equ	cin
    315  0206		       1e 61	   CRLF       equ	tbcrlf
    316  0206		       14 15	   OUTHEX     equ	HexToOut
    317  0206		       f0 03	   MONITOR    equ	WARM
    318  0206		       f0 0f	   ISCHAR     equ	cstatus
    319  0206		       14 32	   puts       equ	tbputs
    320  0206					      endif
    321  0206							;
    322  0206		       20 95 1f    cold2      jsr	SetOutConsole
    323  0209		       20 a2 1f 	      jsr	SetInConsole
    324  020c		       20 32 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    328  0243							;
    329  0243		       20 26 16 	      jsr	MemInit	;setup the free space available
    330  0246
    331  0246		       a9 01	   calcstack  lda	#1
    332  0248		       8d 0e 27 	      sta	taskCounter	; Initialize number of tasks to 1
    333  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    334  024d		       8d 10 26 	      sta	taskTable	; mark the main task as active
    335  0250		       20 13 17 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    336  0253		       a9 4c		      lda	#IL&$ff
    337  0255		       85 43		      sta	ILPC
    338  0257		       a9 22		      lda	#IL>>8
    339  0259		       85 44		      sta	ILPC+1
    340  025b							;
    341  025b							;		  lda	  ProgramStart		     ; user prog
    342  025b							;		  sta	  ProgramEnd
    343  025b							;		  lda	  ProgramStart+1
    344  025b							;		  sta	  ProgramEnd+1
    345  025b							;
    346  025b
    347  025b							;  Init time slices defaults
    348  025b		       a9 02		      lda	#TASKCYCLESHIGH
    349  025d		       8d 0d 27 	      sta	taskResetValue+1
    350  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    351  0262		       8d 0c 27 	      sta	taskResetValue
    352  0265							;
    353  0265							; Initialize the pseudo-random number sequence...
    354  0265							;
    355  0265		       a9 5a		      lda	#$5a
    356  0267		       8d 58 2f 	      sta	rtemp1
    357  026a		       a9 9d		      lda	#%10011101
    358  026c		       8d 5a 2f 	      sta	random
    359  026f		       a9 5b		      lda	#%01011011
    360  0271		       8d 5b 2f 	      sta	random+1
    361  0274							;
    362  0274							;   Insert a Basic irq handler for the basic Language
    363  0274		       a9 81		      lda	#ServiceIrq&$ff
    364  0276		       8d 00 df 	      sta	IRQvec
    365  0279		       a9 02		      lda	#ServiceIrq>>8
    366  027b		       8d 01 df 	      sta	IRQvec+1
    367  027e		       4c a6 02 	      jmp	coldtwo
    368  0281
    369  0281							;
    370  0281							; This is the Basic IRQ handler
    371  0281		       48	   ServiceIrq pha
    372  0282		       ad 0b 26 	      lda	IRQStatus
    373  0285		       f0 0a		      BEQ	RetIrq
    374  0287		       ad 0c 26 	      lda	IRQPending
    375  028a		       d0 05		      bne	RetIrq
    376  028c		       a9 01		      lda	#1
    377  028e		       8d 0c 26 	      sta	IRQPending
    378  0291		       68	   RetIrq     pla
    379  0292		       40		      rti
    380  0293							;
    381  0293							;
    382  0293							; This is the warm start entry point
    383  0293							;
    384  0293		       20 95 1f    warm2      jsr	SetOutConsole
    385  0296		       20 a2 1f 	      jsr	SetInConsole
    386  0299		       20 61 1e 	      jsr	CRLF
    387  029c		       ad 55 2f 	      lda	errGoto
    388  029f		       85 43		      sta	ILPC
    389  02a1		       ad 56 2f 	      lda	errGoto+1
    390  02a4		       85 44		      sta	ILPC+1
    391  02a6							;
    392  02a6							; And continue with both starts here
    393  02a6							;
    394  02a6				   coldtwo
    395  02a6							;
    396  02a6							; The ILTrace flag is now run-time settable.
    397  02a6							;
    398  02a6		       a9 00		      lda	#ILTRACE&$ff
    399  02a8		       85 40		      sta	ILTrace
    400  02aa							;
    401  02aa
    402  02aa		       a9 00		      lda	#0
    403  02ac		       85 5b		      sta	RunMode
    404  02ae		       8d cb 2e 	      sta	LINBUF
    405  02b1
    406  02b1							; Clear everything from the stacks
    407  02b1
    408  02b1		       8d 66 2f 	      sta	taskIOPending	; No one waiting for io
    409  02b4		       8d 67 2f 	      sta	taskRDPending	; No one waiting for bg io
    410  02b7
    411  02b7		       20 86 17 	      jsr	taskReset
    412  02ba							;
    413  02ba		       a9 cb		      lda	#LINBUF&$ff
    414  02bc		       85 4f		      sta	CURPTR
    415  02be		       a9 2e		      lda	#LINBUF>>8
    416  02c0		       85 50		      sta	CURPTR+1	;fall through...
    417  02c2
    418  02c2							;=====================================================
    419  02c2							; This is the top of the IL interpreter.  This fetches
    420  02c2							; and executes the instruction currently pointed to
    421  02c2							; by ILPC and adjusts ILPC to point to the next
    422  02c2							; instruction to execute.
    423  02c2							;
    424  02c2				   NextIL
    425  02c2		       ba		      tsx		; Get the stack pointer value
    426  02c3		       e0 ff		      cpx	#$FF	; Should be empty
    427  02c5		       d0 26		      bne	ILbad	; Halt and catch fire now!
    428  02c7
    429  02c7		       ce 0a 27 	      dec	taskCurrentCycles
    430  02ca		       d0 03		      bne	NextIlNow
    431  02cc		       20 af 17 	      jsr	iTaskSwitch	;check for a task switch
    432  02cf		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    433  02d1		       f0 03		      beq	NextIL2	;Skip if no bits set
    434  02d3
    435  02d3		       20 f2 1e 	      jsr	dbgLine	;Print the IL trace information
    436  02d6
    437  02d6		       a4 51	   NextIL2    ldy	CUROFF
    438  02d8							;		  jsr	  SkipSpaces
    439  02d8							;		  sty	  CUROFF
    440  02d8							;Task IO Management
    441  02d8		       ad 67 2f 	      lda	taskRDPending	; if it is zero then Nothing pending
    442  02db		       f0 08		      beq	NextILStr
    443  02dd		       20 9a 1c 	      jsr	ReadLine	; else Pending and poll keyboard
    444  02e0		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    445  02e2		       ce 67 2f 	      dec	taskRDPending	; Carry is set if CR has been recieved
    446  02e5							;
    447  02e5		       20 1d 1b    NextILStr  jsr	getILByte
    448  02e8							;
    449  02e8							; When the handler is called, these are the conditions
    450  02e8							; of several important items:
    451  02e8							;
    452  02e8							;    (ILPC) will point to the byte AFTER the IL
    453  02e8							;    opcode being executed.
    454  02e8							;
    455  02e8							;    (CURPTR),CUROFF will point to the start of the
    456  02e8							;    next word in the input buffer.  Ie, the next word
    457  02e8							;    in the user program.
    458  02e8							;
    459  02e8		       0a		      asl
    460  02e9		       c9 da		      cmp	#ILTBLend-ILTBL+2
    461  02eb		       90 33		      bcc	ILgood
    462  02ed							;
    463  02ed							; This handles an illegal IL opcode.  This is serious
    464  02ed							; and there's no way to recover.
    465  02ed							;
    466  02ed		       20 32 14    ILbad      jsr	puts
      0  02f0					      db	CR,LF
      1  02f0		       0d 0a		      .byte.b	CR,LF
      0  02f2					      db	"Illegal IL "
      1  02f2		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02fd					      db	0
      1  02fd		       00		      .byte.b	0
    470  02fe							;
    471  02fe							; Well this is awkward, we need to back up the IL
    472  02fe							; by one since it no longer points to the current
    473  02fe							; opcode.
    474  02fe							;
    475  02fe		       20 2a 1b 	      jsr	decIL
    476  0301							;
    477  0301		       a0 00		      ldy	#0
    478  0303		       b1 43		      lda	(ILPC),y
    479  0305		       20 15 14 	      jsr	OUTHEX
    480  0308		       20 32 14 	      jsr	puts
      0  030b					      db	" at ",0
      1  030b		       20 61 74 20*	      .byte.b	" at ",0
    482  0310		       a5 44		      lda	ILPC+1
    483  0312		       20 15 14 	      jsr	OUTHEX
    484  0315		       a5 43		      lda	ILPC
    485  0317		       20 15 14 	      jsr	OUTHEX
    486  031a		       20 61 1e 	      jsr	CRLF
    487  031d		       4c 03 f0 	      jmp	MONITOR
    488  0320							;
    489  0320							; Just jump to the address (ILPC),y.  Have to do
    490  0320							; some goofy stuff.
    491  0320							;
    492  0320		       a8	   ILgood     tay		;move index into Y
    493  0321		       b9 2e 03 	      lda	ILTBL,y
    494  0324		       85 59		      sta	dpl
    495  0326		       b9 2f 03 	      lda	ILTBL+1,y
    496  0329		       85 5a		      sta	dpl+1
    497  032b		       6c 59 00 	      jmp	(dpl)	;go to handler
    498  032e							;
    499  032e							;=====================================================
    500  032e							; This is the IL jump table.  The IL opcode is
    501  032e							; mulitplied by two, then looked-up in this table.
    502  032e							; There is absolutely nothing special about the order
    503  032e							; of entries here... they all decode at exactly the
    504  032e							; same speed.	However the entry number must match the
    505  032e							; values in IL.inc.
    506  032e							;
    507  032e				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  032e					      include	"ilvectortable.asm"
      1  032e					      seg	Code
      2  032e
      0  032e					      dw	iXINIT	;0
      1  032e		       3e 04		      .word.w	iXINIT
      0  0330					      dw	iDONE	;1
      1  0330		       59 04		      .word.w	iDONE
      0  0332					      dw	iPRS	;2
      1  0332		       70 04		      .word.w	iPRS
      0  0334					      dw	iPRN	;3
      1  0334		       78 04		      .word.w	iPRN
      0  0336					      dw	iSPC	;4
      1  0336		       81 04		      .word.w	iSPC
      0  0338					      dw	iNLINE	;5
      1  0338		       2c 09		      .word.w	iNLINE
      0  033a					      dw	iNXT	;6
      1  033a		       89 04		      .word.w	iNXT
      0  033c					      dw	iXFER	;7
      1  033c		       cb 04		      .word.w	iXFER
      0  033e					      dw	iSAV	;8
      1  033e		       e9 04		      .word.w	iSAV
      0  0340					      dw	iRSTR	;9
      1  0340		       2f 05		      .word.w	iRSTR
      0  0342					      dw	iCMPR	;10
      1  0342		       7d 05		      .word.w	iCMPR
      0  0344					      dw	iINNUM	;11
      1  0344		       fc 05		      .word.w	iINNUM
      0  0346					      dw	iFIN	;12
      1  0346		       34 06		      .word.w	iFIN
      0  0348					      dw	iERR	;13
      1  0348		       48 06		      .word.w	iERR
      0  034a					      dw	iADD	;14
      1  034a		       c2 06		      .word.w	iADD
      0  034c					      dw	iSUB	;15
      1  034c		       d8 06		      .word.w	iSUB
      0  034e					      dw	iNEG	;16
      1  034e		       ee 06		      .word.w	iNEG
      0  0350					      dw	iMUL	;17
      1  0350		       06 07		      .word.w	iMUL
      0  0352					      dw	iDIV	;18
      1  0352		       46 07		      .word.w	iDIV
      0  0354					      dw	iSTORE	;19
      1  0354		       9c 07		      .word.w	iSTORE
      0  0356					      dw	iIND	;20
      1  0356		       b4 07		      .word.w	iIND
      0  0358					      dw	iLST	;21
      1  0358		       22 08		      .word.w	iLST
      0  035a					      dw	iINIT	;22
      1  035a		       06 04		      .word.w	iINIT
      0  035c					      dw	iGETLINE	;23
      1  035c		       58 08		      .word.w	iGETLINE
      0  035e					      dw	iINSRT	;24
      1  035e		       75 08		      .word.w	iINSRT
      0  0360					      dw	iRTN	;25
      1  0360		       26 09		      .word.w	iRTN
      0  0362					      dw	MONITOR	;26
      1  0362		       03 f0		      .word.w	MONITOR
      0  0364					      dw	iLIT	;27
      1  0364		       4c 09		      .word.w	iLIT
      0  0366					      dw	iCALL	;28
      1  0366		       32 09		      .word.w	iCALL
      0  0368					      dw	iJMP	;29
      1  0368		       3a 09		      .word.w	iJMP
      0  036a					      dw	iVINIT	;30
      1  036a		       69 09		      .word.w	iVINIT
      0  036c					      dw	iERRGOTO	;31
      1  036c		       72 09		      .word.w	iERRGOTO
      0  036e					      dw	iTST	;32
      1  036e		       7e 09		      .word.w	iTST
      0  0370					      dw	iTSTV	;33
      1  0370		       a3 0a		      .word.w	iTSTV
      0  0372					      dw	iTSTL	;34
      1  0372		       27 0b		      .word.w	iTSTL
      0  0374					      dw	iTSTN	;35
      1  0374		       42 0b		      .word.w	iTSTN
      0  0376					      dw	iFREE	;36
      1  0376		       f3 0b		      .word.w	iFREE
      0  0378					      dw	iRANDOM	;37
      1  0378		       fc 0b		      .word.w	iRANDOM
      0  037a					      dw	iABS	;38
      1  037a		       cd 0c		      .word.w	iABS
     42  037c							;
     43  037c							; Disk functions.  There must be pointers
     44  037c							; to functions even if no disk is supported.
     45  037c							; Makes things easier in IL.inc.
     46  037c							;
     47  037c					      if	DISK_ACCESS
      0  037c					      dw	iOPENREAD	;39
      1  037c		       a6 20		      .word.w	iOPENREAD
      0  037e					      dw	iOPENWRITE	;40
      1  037e		       07 21		      .word.w	iOPENWRITE
      0  0380					      dw	iDCLOSE	;41
      1  0380		       8b 21		      .word.w	iDCLOSE
      0  0382					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0382		       19 21		      .word.w	iDGETLINE
      0  0384					      dw	iDLIST	;43 Did you remember your towel?
      1  0384		       85 21		      .word.w	iDLIST
      0  0386					      dw	iDDIR	;44
      1  0386		       60 21		      .word.w	iDDIR
      0  0388					      dw	iRMFILE	;45
      1  0388		       f5 20		      .word.w	iRMFILE
     55  038a				  -	      else
     56  038a				  -	      dw	NextIL	;39
     57  038a				  -	      dw	NextIL	;40
     58  038a				  -	      dw	NextIL	;41
     59  038a				  -	      dw	NextIL	;42
     60  038a				  -	      dw	NextIL	;43
     61  038a				  -	      dw	NextIL	;44
     62  038a				  -	      dw	NextIL	;45
     63  038a					      endif
     64  038a							;
      0  038a					      dw	iCLEARSCREEN	;46
      1  038a		       b5 1f		      .word.w	iCLEARSCREEN
      0  038c					      dw	iPOKEMEMORY	;47
      1  038c		       5a 0c		      .word.w	iPOKEMEMORY
      0  038e					      dw	iPEEKMEMORY	;48
      1  038e		       6f 0c		      .word.w	iPEEKMEMORY
      0  0390					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0390		       c5 09		      .word.w	iTSTLET
      0  0392					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0392		       4a 0a		      .word.w	iTSTDONE
      0  0394					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0394		       9c 0c		      .word.w	iGETCHAR
      0  0396					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0396		       b0 0c		      .word.w	iPUTCHAR
      0  0398					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0398		       85 0c		      .word.w	iCallFunc
      0  039a					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  039a		       ca 05		      .word.w	iBranch
      0  039c					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  039c		       a8 09		      .word.w	iTSTStr
      0  039e					      dw	iSetIrq	;56	   sets the irq handler
      1  039e		       4a 0d		      .word.w	iSetIrq
      0  03a0					      dw	iTstIrq	;57	   test if irq is pending
      1  03a0		       b9 0b		      .word.w	iTstIrq
      0  03a2					      dw	iRET	;58	   return from interupt
      1  03a2		       1d 05		      .word.w	iRET
      0  03a4					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03a4		       15 06		      .word.w	iINSTR
      0  03a6					      dw	iMOD	;60	   returns remainder of division
      1  03a6		       4f 07		      .word.w	iMOD
      0  03a8					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a8		       03 18		      .word.w	iTaskSet
      0  03aa					      dw	iETask	;62	   Terminates a task
      1  03aa		       40 19		      .word.w	iETask
      0  03ac					      dw	iNTask	;63	   goto next task
      1  03ac		       f3 18		      .word.w	iNTask
      0  03ae					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03ae		       c9 07		      .word.w	iArray
      0  03b0					      dw	iTaskKill	;65	   kill a running task
      1  03b0		       eb 18		      .word.w	iTaskKill
      0  03b2					      dw	iTaskStat	;66	   return the state of a task PID
      1  03b2		       bf 18		      .word.w	iTaskStat
      0  03b4					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03b4		       bb 0c		      .word.w	iHexOut
      0  03b6					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b6		       e6 05		      .word.w	iReadComplete
      0  03b8					      dw	iReadStart	;69	   Called to start a background read request
      1  03b8		       dc 05		      .word.w	iReadStart
      0  03ba					      dw	iStartIO	;70	   Lock task until io complete
      1  03ba		       23 19		      .word.w	iStartIO
      0  03bc					      dw	iEndIO	;71	   release task lock for io
      1  03bc		       29 19		      .word.w	iEndIO
      0  03be					      dw	iLogNot	;72	   Logical not
      1  03be		       26 0d		      .word.w	iLogNot
      0  03c0					      dw	iLogOr	;73	   Logical Or
      1  03c0		       fc 0c		      .word.w	iLogOr
      0  03c2					      dw	iLogAnd	;74	   Logical And
      1  03c2		       e7 0c		      .word.w	iLogAnd
      0  03c4					      dw	iLogXor	;75	   Logical Xor
      1  03c4		       11 0d		      .word.w	iLogXor
      0  03c6					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c6		       fe 18		      .word.w	iWTASK
      0  03c8					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c8		       34 19		      .word.w	iTASKPID
      0  03ca					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03ca		       88 0d		      .word.w	iTRACEPROG
      0  03cc					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03cc		       6e 1e		      .word.w	idbgBasic
      0  03ce					      dw	iIPCS	;80	   Sending a msg to a task
      1  03ce		       f6 19		      .word.w	iIPCS
      0  03d0					      dw	iIPCR	;81	   Recieve a message from a task
      1  03d0		       0d 1a		      .word.w	iIPCR
      0  03d2					      dw	iIPCC	;82	   Check if any message available for task
      1  03d2		       21 1a		      .word.w	iIPCC
      0  03d4					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03d4		       2e 1a		      .word.w	iIPCIO
      0  03d6					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d6		       7b 16		      .word.w	iPushMathStack
      0  03d8					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d8		       ab 16		      .word.w	iPopMathStack
      0  03da					      dw	iSaveMathStack	;86	   Save all math info
      1  03da		       c8 16		      .word.w	iSaveMathStack
      0  03dc					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03dc		       e7 16		      .word.w	iRestoreMathStack
      0  03de					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03de		       98 16		      .word.w	iIncParmCount
      0  03e0					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03e0		       60 19		      .word.w	iTaskGetMathStack
      0  03e2					      dw	iTaskEnable	;90	   enable a suspended task
      1  03e2		       8d 18		      .word.w	iTaskEnable
      0  03e4					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03e4		       a7 18		      .word.w	iTaskSuspend
      0  03e6					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e6		       7a 19		      .word.w	iTaskPutMathPtr
      0  03e8					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e8		       9a 0a		      .word.w	iTSTVT
      0  03ea					      dw	iSetR2	;94
      1  03ea		       44 09		      .word.w	iSetR2
      0  03ec					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03ec		       fb 04		      .word.w	iStk2Tmp
      0  03ee					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03ee		       0c 05		      .word.w	iTmp2Stk
      0  03f0					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03f0		       e6 09		      .word.w	iTSTBYTE
      0  03f2					      dw	iINCVAR	;98	   Increment variable
      1  03f2		       6c 0a		      .word.w	iINCVAR
      0  03f4					      dw	iDECVAR	;99	   Decrement variable
      1  03f4		       84 0a		      .word.w	iDECVAR
      0  03f6					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f6		       89 19		      .word.w	iSLICE
      0  03f8					      dw	iTSTB	;101	   Test if byte equals
      1  03f8		       05 0a		      .word.w	iTSTB
      0  03fa					      dw	iTSTW	;102	   Test If word equals
      1  03fa		       20 0a		      .word.w	iTSTW
      0  03fc					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03fc		       c9 12		      .word.w	iOnGoto
      0  03fe					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03fe		       fa 12		      .word.w	iTSTRELOP
      0  0400					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  0400		       af 04		      .word.w	iRepeatLine
      0  0402					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch is is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  0402		       21 13		      .word.w	iTSTBRANCH
      0  0404					      dw	iFastXfer	;107	   move top of stack to curptr
      1  0404		       b6 04		      .word.w	iFastXfer
    127  0406
------- FILE mytb.asm
    509  0406		       04 06	   ILTBLend   equ	*
    510  0406							;
    511  0406							;=====================================================
    512  0406							;=====================================================
    513  0406							;=====================================================
    514  0406							; This marks the start of the handlers for IL opcodes.
    515  0406							;=====================================================
    516  0406							;=====================================================
    517  0406							;=====================================================
    518  0406							;
    519  0406							;
    520  0406		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    521  0408		       85 47		      sta	ILSTACKPTR
    522  040a		       85 4a		      sta	MATHSTACKPTR
    523  040c		       85 4d		      sta	GOSUBSTACKPTR
    524  040e		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    525  0410		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    526  0412							;
    527  0412		       ad 68 2f 	      lda	ProgramStart	; user prog
    528  0415		       85 4f		      sta	CURPTR
    529  0417		       8d 11 26 	      sta	taskTable+1
    530  041a		       8d 6a 2f 	      sta	ProgramEnd
    531  041d		       ad 69 2f 	      lda	ProgramStart+1
    532  0420		       85 50		      sta	CURPTR+1
    533  0422		       8d 12 26 	      sta	taskTable+2
    534  0425		       8d 6b 2f 	      sta	ProgramEnd+1
    535  0428		       a9 80		      lda	#TASKACTIVE
    536  042a		       8d 10 26 	      sta	taskTable	;Mark the first slot as active
    537  042d		       a9 01		      lda	#1
    538  042f		       8d 0e 27 	      sta	taskCounter	;there is always one task / Main task
    539  0432		       ad 0c 27 	      lda	taskResetValue
    540  0435		       8d 0a 27 	      sta	taskCurrentCycles	; set up the task switch counts
    541  0438		       ad 0d 27 	      lda	taskResetValue+1
    542  043b		       8d 0b 27 	      sta	taskCurrentCycles+1
    543  043e							;
    544  043e							; fall into XINIT...
    545  043e							;
    546  043e							;=====================================================
    547  043e							; This initializes for the start of the next line of
    548  043e							; BASIC text.
    549  043e							;
    550  043e		       78	   iXINIT     sei		;ensure interupts are off
    551  043f		       20 86 17 	      jsr	taskReset	;Clear the task table
    552  0442		       8d 0c 26 	      sta	IRQPending	; reset the irq pending
    553  0445		       8d 0b 26 	      sta	IRQStatus	; Make sure irqs are off
    554  0448
    555  0448		       4c c2 02    goodExit   jmp	NextIL
    556  044b							;
    557  044b							;=====================================================
    558  044b							; This check if the escape key has been entered
    559  044b							; then changes out of run mode. z Set if esc found
    560  044b				   BreakSet
    561  044b		       20 0f f0 	      jsr	ISCHAR
    562  044e		       f0 06		      beq	BreakNo
    563  0450		       20 b2 1f 	      jsr	VGETCH
    564  0453		       c9 1b		      cmp	#$1B
    565  0455		       60		      rts
    566  0456				   BreakNo
    567  0456		       a9 01		      lda	#1
    568  0458		       60		      rts
    569  0459
    570  0459							;
    571  0459
    572  0459							;=====================================================
    573  0459							; Verify there is nothing else on this input line.
    574  0459							; If there is, generate an error.
    575  0459							;
    576  0459		       a4 51	   iDONE      ldy	CUROFF
    577  045b		       b1 4f		      lda	(CURPTR),y
    578  045d		       f0 0e		      beq	doneadv
    579  045f		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    580  0461		       d0 03		      bne	idoneErr
    581  0463							;		  sty	  CUROFF
    582  0463		       4c c2 02 	      jmp	NextIL	; continue on this line
    583  0466
    584  0466				   idoneErr
    585  0466		       a2 04		      ldx	#ERR_EXTRA_STUFF
    586  0468		       a9 00		      lda	#0
    587  046a		       4c a7 06 	      jmp	iErr2
    588  046d							;
    589  046d							; Advance to the next line
    590  046d							;
    591  046d				   doneadv
    592  046d		       4c c2 02 	      jmp	NextIL
    593  0470							;
    594  0470							;=====================================================
    595  0470							; Print the string until a closing quote
    596  0470							;
    597  0470				   iPRS
    598  0470		       20 55 14 	      jsr	PrtQuoted
    599  0473		       84 51		      sty	CUROFF
    600  0475		       4c c2 02 	      jmp	NextIL
    601  0478							;
    602  0478							;=====================================================
    603  0478							; Pop the top off the stack and print it as a signed
    604  0478							; decimal number.
    605  0478							;
    606  0478				   iPRN
    607  0478		       20 a8 1d 	      jsr	popR0
    608  047b		       20 63 13 	      jsr	PrintDecimal
    609  047e		       4c c2 02 	      jmp	NextIL
    610  0481							;
    611  0481							;=====================================================
    612  0481							; Space to next zone.	Currently the code does not
    613  0481							; keep track of which column the output is on, so
    614  0481							; just print a tab.
    615  0481							;
    616  0481				   iSPC
    617  0481		       a9 09		      lda	#TAB
    618  0483		       20 af 1f 	      jsr	VOUTCH
    619  0486		       4c c2 02 	      jmp	NextIL
    620  0489							;
    621  0489							;=====================================================
    622  0489							; If in immediate mode, jump to the address following
    623  0489							; the NXT instruction.  Else move to the next line of
    624  0489							; user code and continue.
    625  0489							;
    626  0489		       a5 5b	   iNXT       lda	RunMode
    627  048b		       d0 03		      bne	iNxtRun	;in run mode
    628  048d							;
    629  048d							; Get address and jump to it.
    630  048d							;
    631  048d		       4c 3a 09 	      jmp	iJMP
    632  0490							;
    633  0490				   iNxtRun
    634  0490		       a4 51		      ldy	CUROFF
    635  0492		       b1 4f		      lda	(CURPTR),y
    636  0494		       c9 e6		      cmp	#oColon
    637  0496		       d0 06		      bne	iNxtRunGo
    638  0498		       c8		      iny
    639  0499		       84 51		      sty	CUROFF
    640  049b		       4c a9 04 	      jmp	iNxtRun2
    641  049e
    642  049e				   iNxtRunGo
    643  049e		       20 a7 1b 	      jsr	FindNextLine
    644  04a1		       20 bb 1b 	      jsr	AtEnd
    645  04a4		       d0 03		      bne	iNxtRun2	;not at end
    646  04a6							;
    647  04a6							; At the end of the program.  Pretend an END statement
    648  04a6							; was found.
    649  04a6							;
    650  04a6		       4c 34 06    iFINv      jmp	iFIN
    651  04a9							;
    652  04a9		       20 19 1b    iNxtRun2   jsr	getILWord	;ignore next word
    653  04ac		       4c c2 02 	      jmp	NextIL
    654  04af							;=====================================================
    655  04af							;Repeat the same line against
    656  04af		       a0 03	   iRepeatLine ldy	#3
    657  04b1		       84 51		      sty	CUROFF
    658  04b3		       4c c2 02 	      jmp	NextIL
    659  04b6							;
    660  04b6							;=====================================================
    661  04b6							; XFER takes the number on top of the stack and looks
    662  04b6							; for that line in the program, or the next line
    663  04b6							; higher.  Ie, if it's 1 but there is no line 1, then
    664  04b6							; find the next one after that.
    665  04b6							;
    666  04b6				   iFastXfer
    667  04b6		       20 c0 1d 	      jsr	popR1	; get type of transfer
    668  04b9		       a5 54		      lda	R1
    669  04bb		       f0 0e		      beq	iXFER
    670  04bd
    671  04bd		       20 a8 1d 	      jsr	popR0	; get where to transfer
    672  04c0		       a5 52		      lda	R0
    673  04c2		       85 4f		      sta	CURPTR
    674  04c4		       a5 53		      lda	R0+1
    675  04c6		       85 50		      sta	CURPTR+1
    676  04c8		       4c d1 04 	      jmp	iXFER2
    677  04cb
    678  04cb				   iXFER
    679  04cb		       20 a8 1d 	      jsr	popR0
    680  04ce		       20 62 1b 	      jsr	findLine
    681  04d1
    682  04d1				   iXFER2
    683  04d1		       20 bb 1b 	      jsr	AtEnd	;at end of user program?
    684  04d4		       f0 d0		      beq	iFINv
    685  04d6
    686  04d6		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    687  04d8		       84 51		      sty	CUROFF
    688  04da
    689  04da							;		  lda	  #$ff
    690  04da							;		  sta	  RunMode
    691  04da							;
    692  04da							; Transfer IL to STMT.  I don't like having this
    693  04da							; hard-coded; fix it.
    694  04da							;
    695  04da							;		  lda	  #STMT&$ff
    696  04da							;		  sta	  ILPC
    697  04da							;		  lda	  #STMT>>8
    698  04da							;		  sta	  ILPC+1
    699  04da							;		  jmp	  NextIL
    700  04da							;
    701  04da							; Run
    702  04da							;
    703  04da				   iXferok
    704  04da		       a9 ff		      lda	#$ff
    705  04dc		       85 5b		      sta	RunMode	;we're running
    706  04de							;
    707  04de							; Need a more elegant way to do this
    708  04de							;
    709  04de		       a9 5a		      lda	#STMT&$ff
    710  04e0		       85 43		      sta	ILPC
    711  04e2		       a9 22		      lda	#STMT>>8
    712  04e4		       85 44		      sta	ILPC+1
    713  04e6		       4c c2 02 	      jmp	NextIL
    714  04e9							;
    715  04e9							;=====================================================
    716  04e9							; Save the pointer to the next line to the call stack.
    717  04e9							;
    718  04e9		       20 1d 1b    iSAV       jsr	getILByte	; load type of gosub
    719  04ec		       20 30 1d 	      jsr	pushLN	; Type passed in A
    720  04ef		       b0 03		      bcs	iSAVErr
    721  04f1		       4c c2 02 	      jmp	NextIL
    722  04f4
    723  04f4		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    724  04f6		       a9 00	   iSAVErr2   lda	#0
    725  04f8		       4c a7 06 	      jmp	iErr2
    726  04fb							;====================================================
    727  04fb							; Move stack top to and from temp area
    728  04fb				   iStk2Tmp
    729  04fb		       20 a8 1d 	      jsr	popR0
    730  04fe		       a5 52		      lda	R0
    731  0500		       a0 34		      ldy	#TASKEXITCODE	; can also be used as temp
    732  0502		       91 41		      sta	(VARIABLES),y
    733  0504		       c8		      iny
    734  0505		       a5 53		      lda	R0+1
    735  0507		       91 41		      sta	(VARIABLES),y
    736  0509		       4c c2 02 	      jmp	NextIL
    737  050c
    738  050c		       a0 34	   iTmp2Stk   ldy	#TASKEXITCODE
    739  050e		       b1 41		      lda	(VARIABLES),y
    740  0510		       85 52		      sta	R0
    741  0512		       c8		      iny
    742  0513		       b1 41		      lda	(VARIABLES),y
    743  0515		       85 53		      sta	R0+1
    744  0517		       20 16 1d 	      jsr	pushR0
    745  051a		       4c c2 02 	      jmp	NextIL
    746  051d							;
    747  051d							;=====================================================
    748  051d							; Pop the next line from the call stack.
    749  051d							;
    750  051d		       20 59 1d    iRET       jsr	popLN
    751  0520		       b0 d2		      bcs	iSAVErr
    752  0522		       a0 03		      ldy	#3
    753  0524		       84 51		      sty	CUROFF
    754  0526		       a9 00		      lda	#0
    755  0528		       8d 0c 26 	      sta	IRQPending
    756  052b		       58		      cli
    757  052c		       4c c2 02 	      jmp	NextIL
    758  052f							;
    759  052f							;=====================================================
    760  052f							; On entry il, branch to if function
    761  052f							;	    il+1, value to be returned or not true or false
    762  052f							;
    763  052f							; Return from GOSUB function
    764  052f							;
    765  052f		       20 1d 1b    iRSTR      jsr	getILByte	; get where to go if gosub is a fucntion
    766  0532		       8d 64 2f 	      sta	offset
    767  0535		       20 00 1d 	      jsr	saveIL	; for later jump if needed
    768  0538
    769  0538		       20 59 1d 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    770  053b		       85 54		      sta	R1	; keep the type of call returning from
    771  053d		       b0 2a		      bcs	iRSTRErr	; stack underflow error possible
    772  053f
    773  053f		       20 1d 1b 	      jsr	getILByte	; get if a value is being returned
    774  0542		       48		      pha		; save if a value was passed to be returned
    775  0543		       c9 00		      cmp	#0	; yes attemping to return a value
    776  0545		       f0 03		      beq	iRSTRPOP	; no value to return
    777  0547		       20 a8 1d 	      jsr	popR0	; Get the value from the stack save if needed
    778  054a				   iRSTRPOP
    779  054a		       20 b1 16 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    780  054d		       a5 54		      lda	R1	; called as a statement ?
    781  054f		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    782  0551		       f0 12		      beq	iRSTRExit
    783  0553		       68		      pla		; get back if value returned or not
    784  0554		       c9 01		      cmp	#1	; we have a value to return
    785  0556		       f0 04		      beq	iRSTRVALUE
    786  0558
    787  0558		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    788  055a		       d0 9a		      bne	iSAVErr2
    789  055c
    790  055c				   iRSTRVALUE
    791  055c		       20 16 1d 	      jsr	pushR0	; return value back to top of stack
    792  055f		       20 0b 1d 	      jsr	restoreIL	; get the correct il
    793  0562		       4c 9a 0b 	      jmp	tstBranch	; And called as a function
    794  0565
    795  0565				   iRSTRExit
    796  0565		       68		      pla		; throw away the return value if provided
    797  0566		       4c c2 02 	      jmp	NextIL
    798  0569
    799  0569				   iRSTRNORETURNVALUE
    800  0569
    801  0569
    802  0569		       ad 0f 26    iRSTRErr   lda	taskPtr	; Check if this is task zero
    803  056c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    804  056e		       a5 56		      lda	MQ
    805  0570		       d0 03		      bne	taskRet
    806  0572		       20 ca 1f 	      jsr	pushFalse	; the result code by default is 0
    807  0575				   taskRet
    808  0575		       4c 40 19 	      jmp	iETask	; not task zero then do a task end instead
    809  0578				   taskZeroEnd
    810  0578		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    811  057a		       4c f6 04 	      jmp	iSAVErr2
    812  057d							;
    813  057d							;=====================================================
    814  057d							; Compare items on stack.  Okay, so on input there are
    815  057d							; three things on the stack
    816  057d							;
    817  057d							;    EXPR2 <- Top of stack
    818  057d							;    OP    <- relational operator, next on stack
    819  057d							;    EXPR1 <- last item on stack
    820  057d							;
    821  057d							; Comparison is: EXPR1 <operator> EXPR2
    822  057d							;
    823  057d							; Operator is one of...
    824  057d							;
    825  057d							;    2 is =
    826  057d							;    1 is <
    827  057d							;    3 is <=
    828  057d							;    5 is <>
    829  057d							;    4 is >
    830  057d							;    6 is >=
    831  057d							;
    832  057d							; Those are bit-mapped:
    833  057d							;
    834  057d							;    xxxxxGEL
    835  057d							;
    836  057d							;    G = Greater than
    837  057d							;    E = Equal
    838  057d							;    L = Less than
    839  057d							;
    840  057d							; If the comparison is false, do a NXT, ie, move to the
    841  057d							; next line and continue.  If true, continue executing
    842  057d							; on this line.
    843  057d							;
    844  057d		       00 01	   REL_LT     equ	%001
    845  057d		       00 02	   REL_EQUAL  equ	%010
    846  057d		       00 04	   REL_GT     equ	%100
    847  057d							;
    848  057d		       20 c0 1d    iCMPR      jsr	popR1
    849  0580		       20 d7 1d 	      jsr	popMQ	;operator in MQ
    850  0583		       20 a8 1d 	      jsr	popR0
    851  0586		       20 8f 05 	      jsr	iCMPRsub
    852  0589		       20 16 1d 	      jsr	pushR0
    853  058c		       4c c2 02 	      jmp	NextIL
    854  058f							;
    855  058f							; See if they are equal or not
    856  058f							;
    857  058f				   iCMPRsub		; Called by internal functions
    858  058f
    859  058f		       a5 52		      lda	R0
    860  0591		       c5 54		      cmp	R1
    861  0593		       d0 0a		      bne	iCMPRnoteq	;try not equal
    862  0595		       a5 53		      lda	R0+1
    863  0597		       c5 55		      cmp	R1+1
    864  0599		       d0 04		      bne	iCMPRnoteq
    865  059b							;
    866  059b							; Equal, set the flag in MQ+1
    867  059b							;
    868  059b		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    869  059d		       d0 14		      bne	iCMPcom	;Exit it is equal
    870  059f							;
    871  059f							; See if EXPR1 (R0) < EXPR2 (R1)
    872  059f							; See www.6502.org/tutorials/compare_beyond.html
    873  059f							;
    874  059f				   iCMPRnoteq
    875  059f		       a5 52		      lda	R0
    876  05a1		       c5 54		      cmp	R1	; Sets the carry flag
    877  05a3		       a5 53		      lda	R0+1
    878  05a5		       e5 55		      sbc	R1+1
    879  05a7
    880  05a7		       50 02		      bvc	iCMPR_2	; branch if N eor V
    881  05a9		       49 80		      eor	#$80
    882  05ab
    883  05ab		       30 04	   iCMPR_2    bmi	iCMPlt
    884  05ad		       a9 04		      lda	#REL_GT
    885  05af		       d0 02		      bne	iCMPcom
    886  05b1
    887  05b1		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    888  05b3
    889  05b3				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    890  05b3							;
    891  05b3							; Now compare the end result with what the caller
    892  05b3							; was looking for.
    893  05b3							;
    894  05b3		       25 56		      and	MQ
    895  05b5		       f0 0c		      beq	iCMPno	; no match
    896  05b7		       a9 ff		      lda	#$FF	; true is $ffff
    897  05b9		       85 52		      sta	R0
    898  05bb		       85 53		      sta	R0+1
    899  05bd		       d0 0a		      bne	iCMPDone
    900  05bf							;
    901  05bf							; R0 > R1
    902  05bf							;
    903  05bf		       a9 04	   iCMPgt     lda	#REL_GT
    904  05c1		       d0 f0		      bne	iCMPcom
    905  05c3				   iCMPno
    906  05c3		       a9 00		      lda	#0
    907  05c5		       85 52		      sta	R0
    908  05c7		       85 53		      sta	R0+1
    909  05c9
    910  05c9				   iCMPDone
    911  05c9		       60		      rts
    912  05ca
    913  05ca							;
    914  05ca							; if Not a match, so jump to the next line of code.
    915  05ca							; Branches based upon value on top of the stack
    916  05ca				   iBranch
    917  05ca		       20 a8 1d 	      jsr	popR0
    918  05cd		       a5 52		      lda	R0
    919  05cf		       05 53		      ora	R0+1
    920  05d1		       f0 03		      beq	iBranchFalse	; not true
    921  05d3		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    922  05d6							;
    923  05d6				   iBranchFalse
    924  05d6		       20 a7 1b 	      jsr	FindNextLine
    925  05d9		       4c d1 04 	      jmp	iXFER2
    926  05dc							;
    927  05dc							;=====================================================
    928  05dc							; Start a read of data in background
    929  05dc				   iReadStart
    930  05dc		       a9 3f		      lda	#'?	; Prompt with question mark
    931  05de		       a6 01		      ldx	1	; Indicate to start read in background
    932  05e0		       20 33 1c 	      jsr	GetLine	; Call the getline to start read
    933  05e3		       4c c2 02 	      jmp	NextIL	; next instruction
    934  05e6							;
    935  05e6							;=====================================================
    936  05e6							; Complete the read and return the curptr, curoff pointing to data
    937  05e6				   iReadComplete
    938  05e6		       a9 01		      lda	#GOSUB_RTN
    939  05e8		       20 30 1d 	      jsr	pushLN
    940  05eb		       90 03		      bcc	iReadOk
    941  05ed		       4c ec 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    942  05f0				   iReadOk
    943  05f0		       20 53 1c 	      jsr	ReadComplete
    944  05f3		       4c c2 02 	      jmp	NextIL
    945  05f6		       20 59 1d 	      jsr	popLN
    946  05f9		       4c c2 02 	      jmp	NextIL
    947  05fc							;=====================================================
    948  05fc							; Get a line of text from the user, convert to a
    949  05fc							; number, leave on top of stack.
    950  05fc							;
    951  05fc				   iINNUM
    952  05fc		       a9 01		      lda	#GOSUB_RTN
    953  05fe		       20 30 1d 	      jsr	pushLN
    954  0601		       b0 ea		      bcs	iReadErr	; Stack over flow error
    955  0603							;
    956  0603		       a9 3f		      lda	#'?
    957  0605		       a2 00		      ldx	#0	;Wait for complete
    958  0607		       20 33 1c 	      jsr	GetLine
    959  060a		       20 c8 1b 	      jsr	getDecimal
    960  060d		       20 16 1d 	      jsr	pushR0	;put onto stack
    961  0610		       b0 db		      bcs	iReadErr	;StackOverflow error
    962  0612							;
    963  0612		       4c 2e 06 	      jmp	ExitIn
    964  0615							;
    965  0615							;=====================================================
    966  0615							; Get a line of text from the user, convert to a
    967  0615							; character value , leave on top of stack. up to 2 characters
    968  0615							;
    969  0615				   iINSTR
    970  0615		       a9 01		      lda	#GOSUB_RTN
    971  0617		       20 30 1d 	      jsr	pushLN
    972  061a		       b0 d1		      bcs	iReadErr	; Stack overflow error
    973  061c		       a9 3f		      lda	#'?
    974  061e		       a2 00		      ldx	#0	;wait for read complete
    975  0620		       20 33 1c 	      jsr	GetLine
    976  0623		       b1 4f		      lda	(CURPTR),y
    977  0625		       85 52		      sta	R0
    978  0627		       a9 00		      lda	#0
    979  0629		       85 53		      sta	R0+1
    980  062b		       20 16 1d 	      jsr	pushR0	;put onto stack
    981  062e				   ExitIn
    982  062e		       20 59 1d 	      jsr	popLN
    983  0631		       4c c2 02 	      jmp	NextIL
    984  0634							;
    985  0634							;
    986  0634							;=====================================================
    987  0634							; Stop the currently running program.	Actually very
    988  0634							; simple to do... clear the RunMode flag, then set the
    989  0634							; ILPC to the standard handler and continue running.
    990  0634							;
    991  0634		       a9 00	   iFIN       lda	#0
    992  0636		       85 5b		      sta	RunMode
    993  0638		       20 86 17 	      jsr	taskReset
    994  063b							;
    995  063b		       ad 55 2f 	      lda	errGoto
    996  063e		       85 43		      sta	ILPC
    997  0640		       ad 56 2f 	      lda	errGoto+1
    998  0643		       85 44		      sta	ILPC+1
    999  0645		       4c c2 02 	      jmp	NextIL
   1000  0648							;
   1001  0648							;=====================================================
   1002  0648							; Handle the ERR opcode.  Following the instruction is
   1003  0648							; a 16 bit error number.  Print an error message, and
   1004  0648							; if we're in run mode, print the line number.  Stop
   1005  0648							; program execution and return to the initial state.
   1006  0648							;
   1007  0648		       20 19 1b    iERR       jsr	getILWord	;get err code
   1008  064b		       20 51 06 	      jsr	DisplayError
   1009  064e		       4c aa 06 	      jmp	iErrComplete
   1010  0651							;
   1011  0651							; Enter here with the error code in X (LSB) and A (MSB).
   1012  0651							;
   1013  0651				   DisplayError
   1014  0651		       86 52		      stx	R0
   1015  0653		       85 53		      sta	R0+1
   1016  0655							;
   1017  0655		       20 32 14 	      jsr	puts
      0  0658					      db	CR,LF,"Error ",0
      1  0658		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
   1019  0661		       20 63 13 	      jsr	PrintDecimal
   1020  0664							;
   1021  0664		       a5 5b		      lda	RunMode	;running?
   1022  0666		       f0 3b		      beq	iERR3	;nope
   1023  0668		       20 32 14 	      jsr	puts
      0  066b					      db	" at line ",0
      1  066b		       20 61 74 20*	      .byte.b	" at line ",0
   1025  0675		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
   1026  0677				   iErr2a
   1027  0677		       b1 4f		      lda	(CURPTR),y
   1028  0679		       85 52		      sta	R0
   1029  067b		       c8		      iny
   1030  067c		       b1 4f		      lda	(CURPTR),y
   1031  067e		       85 53		      sta	R0+1
   1032  0680		       20 63 13 	      jsr	PrintDecimal
   1033  0683		       20 32 14 	      jsr	puts
      0  0686					      db	":",0
      1  0686		       3a 00		      .byte.b	":",0
   1035  0688		       a9 00		      lda	#0
   1036  068a		       85 53		      sta	R0+1
   1037  068c		       a5 51		      lda	CUROFF
   1038  068e		       18		      clc
   1039  068f		       e9 03		      sbc	#3
   1040  0691		       85 52		      sta	R0
   1041  0693		       20 63 13 	      jsr	PrintDecimal
   1042  0696		       20 32 14 	      jsr	puts
      0  0699					      db	":",0
      1  0699		       3a 00		      .byte.b	":",0
   1044  069b		       ad 0f 26 	      lda	taskPtr
   1045  069e		       85 52		      sta	R0
   1046  06a0		       20 63 13 	      jsr	PrintDecimal
   1047  06a3							;
   1048  06a3				   iERR3
   1049  06a3		       20 61 1e 	      jsr	CRLF
   1050  06a6		       60		      rts
   1051  06a7
   1052  06a7				   iErr2
   1053  06a7		       20 51 06 	      jsr	DisplayError
   1054  06aa
   1055  06aa				   iErrComplete
   1056  06aa		       20 7e 17 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1057  06ad		       a9 00		      lda	#0
   1058  06af		       85 5b		      sta	RunMode	; fall through...
   1059  06b1							;
   1060  06b1							;=====================================================
   1061  06b1							; Reset the IL to be back at the idle loop.  Does not
   1062  06b1							; clear variables so the user can see what state
   1063  06b1							; the program is in.
   1064  06b1							;
   1065  06b1		       a9 00	   ResetIL    lda	#0
   1066  06b3		       85 47		      sta	ILSTACKPTR
   1067  06b5		       ad 55 2f 	      lda	errGoto
   1068  06b8		       85 43		      sta	ILPC
   1069  06ba		       ad 56 2f 	      lda	errGoto+1
   1070  06bd		       85 44		      sta	ILPC+1
   1071  06bf		       4c c2 02 	      jmp	NextIL
   1072  06c2
   1073  06c2							;
   1074  06c2							;=====================================================
   1075  06c2							; Pop two items off stack, add them, then place the
   1076  06c2							; result back onto the stack.
   1077  06c2							;
   1078  06c2		       20 a8 1d    iADD       jsr	popR0
   1079  06c5		       20 c0 1d 	      jsr	popR1
   1080  06c8				   iADDfast
   1081  06c8		       18		      clc
   1082  06c9		       a5 52		      lda	R0
   1083  06cb		       65 54		      adc	R1
   1084  06cd		       85 52		      sta	R0
   1085  06cf		       a5 53		      lda	R0+1
   1086  06d1		       65 55		      adc	R1+1
   1087  06d3		       85 53		      sta	R0+1
   1088  06d5		       4c 40 07 	      jmp	pushR0nextIl
   1089  06d8							;
   1090  06d8							;=====================================================
   1091  06d8							; Pop two items off the stack.  Subtract the top of
   1092  06d8							; stack from the lower entry.
   1093  06d8							;
   1094  06d8		       20 c0 1d    iSUB       jsr	popR1
   1095  06db		       20 a8 1d 	      jsr	popR0
   1096  06de		       38		      sec
   1097  06df		       a5 52		      lda	R0
   1098  06e1		       e5 54		      sbc	R1
   1099  06e3		       85 52		      sta	R0
   1100  06e5		       a5 53		      lda	R0+1
   1101  06e7		       e5 55		      sbc	R1+1
   1102  06e9		       85 53		      sta	R0+1
   1103  06eb		       4c 40 07 	      jmp	pushR0nextIl
   1104  06ee							;
   1105  06ee							;=====================================================
   1106  06ee							; Negate the top of stack.
   1107  06ee							;
   1108  06ee		       20 a8 1d    iNEG       jsr	popR0
   1109  06f1		       a5 52		      lda	R0
   1110  06f3		       49 ff		      eor	#$ff
   1111  06f5		       85 52		      sta	R0
   1112  06f7		       a5 53		      lda	R0+1
   1113  06f9		       49 ff		      eor	#$ff
   1114  06fb		       85 53		      sta	R0+1
   1115  06fd		       e6 52		      inc	R0
   1116  06ff		       d0 02		      bne	iNEG2
   1117  0701		       e6 53		      inc	R0+1
   1118  0703		       4c 40 07    iNEG2      jmp	pushR0nextIl
   1119  0706							;
   1120  0706							;=====================================================
   1121  0706							; Multiply top two items on the stack, put the results
   1122  0706							; on top.  This uses the algorithm documented on page
   1123  0706							; 115 of "Microprocessor Programming for Computer
   1124  0706							; Hobbyists" by Neill Graham.
   1125  0706							;
   1126  0706		       20 0c 07    iMUL       jsr	iMultiply
   1127  0709		       4c c2 02 	      jmp	NextIL
   1128  070c
   1129  070c				   iMultiply
   1130  070c		       20 a8 1d 	      jsr	popR0	;AC
   1131  070f		       20 c0 1d 	      jsr	popR1	;OP
   1132  0712							;
   1133  0712		       a5 52		      lda	R0
   1134  0714		       85 56		      sta	MQ
   1135  0716		       a5 53		      lda	R0+1
   1136  0718		       85 57		      sta	MQ+1
   1137  071a		       a9 00		      lda	#0	;clear result
   1138  071c		       85 52		      sta	R0
   1139  071e		       85 53		      sta	R0+1
   1140  0720							;
   1141  0720		       a2 10		      ldx	#16	;number of bits in value
   1142  0722		       06 52	   multloop   asl	R0
   1143  0724		       26 53		      rol	R0+1
   1144  0726		       06 56		      asl	MQ
   1145  0728		       26 57		      rol	MQ+1
   1146  072a		       90 0d		      bcc	multno	;skip add if no carry
   1147  072c							;
   1148  072c							; Add R1 back into R0
   1149  072c							;
   1150  072c		       18		      clc
   1151  072d		       a5 52		      lda	R0
   1152  072f		       65 54		      adc	R1
   1153  0731		       85 52		      sta	R0
   1154  0733		       a5 53		      lda	R0+1
   1155  0735		       65 55		      adc	R1+1
   1156  0737		       85 53		      sta	R0+1
   1157  0739							;
   1158  0739		       ca	   multno     dex		;did all bits yet?
   1159  073a		       d0 e6		      bne	multloop
   1160  073c		       20 16 1d 	      jsr	pushR0	;OP
   1161  073f		       60		      rts
   1162  0740							;
   1163  0740				   pushR0nextIl
   1164  0740		       20 16 1d 	      jsr	pushR0	;OP
   1165  0743		       4c c2 02 	      jmp	NextIL
   1166  0746							;
   1167  0746							;=====================================================
   1168  0746							; Divide the top of stack into the next to top item.
   1169  0746							; Leave results on stack.  Taken from:
   1170  0746							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1171  0746							;
   1172  0746							; R0 = R0 / R1
   1173  0746							; Remainder is in MQ
   1174  0746							;
   1175  0746		       20 60 07    iDIV       jsr	iDoDiv
   1176  0749		       20 29 1e 	      jsr	RestoreSigns
   1177  074c		       4c 40 07 	      jmp	pushR0nextIl
   1178  074f
   1179  074f		       20 60 07    iMOD       jsr	iDoDiv
   1180  0752		       20 29 1e 	      jsr	RestoreSigns
   1181  0755		       a5 56		      lda	MQ
   1182  0757		       85 52		      sta	R0
   1183  0759		       a5 57		      lda	MQ+1
   1184  075b		       85 53		      sta	R0+1
   1185  075d		       4c 40 07 	      jmp	pushR0nextIl
   1186  0760
   1187  0760				   iDoDiv
   1188  0760		       20 c0 1d 	      jsr	popR1
   1189  0763		       20 a8 1d 	      jsr	popR0
   1190  0766							;
   1191  0766							; Check for divide by zero
   1192  0766							;
   1193  0766
   1194  0766				   iDivNoPop
   1195  0766		       a5 54		      lda	R1
   1196  0768		       05 55		      ora	R1+1
   1197  076a		       f0 29		      beq	divby0
   1198  076c							;
   1199  076c		       20 ee 1d 	      jsr	SaveSigns
   1200  076f		       a9 00		      lda	#0	;preset remainder to 0
   1201  0771		       85 56		      sta	MQ
   1202  0773		       85 57		      sta	MQ+1
   1203  0775		       a2 10		      ldx	#16	;repeat for each bit: ...
   1204  0777				   divloop
   1205  0777		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1206  0779		       26 53		      rol	R0+1
   1207  077b		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1208  077d		       26 57		      rol	MQ+1
   1209  077f		       a5 56		      lda	MQ
   1210  0781		       38		      sec
   1211  0782		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1212  0784		       a8		      tay		;lb result -> Y, for we may need it later
   1213  0785		       a5 57		      lda	MQ+1
   1214  0787		       e5 55		      sbc	R1+1
   1215  0789		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1216  078b
   1217  078b		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1218  078d		       84 56		      sty	MQ
   1219  078f		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1220  0791
   1221  0791		       ca	   skip       dex
   1222  0792		       d0 e3		      bne	divloop
   1223  0794		       60		      rts
   1224  0795							;
   1225  0795							; Indicate divide-by-zero error
   1226  0795							;
   1227  0795		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1228  0797		       a9 00		      lda	#0
   1229  0799		       4c a7 06 	      jmp	iErr2
   1230  079c							;
   1231  079c							;=====================================================
   1232  079c							; This pops the top two items off the stack.  The top
   1233  079c							; item is a data value and the other is an ABSOLUTE address.
   1234  079c							;Save the value into that address.
   1235  079c							;
   1236  079c		       98	   iSTORE     tya
   1237  079d		       48		      pha
   1238  079e		       20 a8 1d 	      jsr	popR0	;data
   1239  07a1		       20 c0 1d 	      jsr	popR1	;Storage location
   1240  07a4		       a0 00		      ldy	#0
   1241  07a6		       a5 52		      lda	R0
   1242  07a8		       91 54		      sta	(R1),y
   1243  07aa		       a5 53		      lda	R0+1
   1244  07ac		       c8		      iny
   1245  07ad		       91 54		      sta	(R1),y
   1246  07af		       68		      pla
   1247  07b0		       a8		      tay
   1248  07b1		       4c c2 02 	      jmp	NextIL
   1249  07b4							;
   1250  07b4							;=====================================================
   1251  07b4							; Replaces the top of stack with the Value
   1252  07b4							; of the variable  whose absolute address it represents.
   1253  07b4							;
   1254  07b4		       98	   iIND       tya
   1255  07b5		       48		      pha
   1256  07b6		       20 c0 1d 	      jsr	popR1
   1257  07b9		       a0 00		      ldy	#0
   1258  07bb		       b1 54		      lda	(R1),y
   1259  07bd		       85 52		      sta	R0
   1260  07bf		       c8		      iny
   1261  07c0		       b1 54		      lda	(R1),y
   1262  07c2		       85 53		      sta	R0+1
   1263  07c4		       68		      pla
   1264  07c5		       a8		      tay
   1265  07c6		       4c 40 07 	      jmp	pushR0nextIl
   1266  07c9							;
   1267  07c9							;=====================================================
   1268  07c9							; Get the array index from top of stack get Current variable
   1269  07c9							; address from next on stack, add the offset
   1270  07c9							; push the result back onto the stack
   1271  07c9				   iArray
   1272  07c9		       20 a8 1d 	      jsr	popR0	; Get the array index
   1273  07cc		       20 c0 1d 	      jsr	popR1	; Get the Variable address
   1274  07cf
   1275  07cf		       18		      clc		; Multiplythe value by 2
   1276  07d0		       26 52		      rol	R0	; Do the multiply
   1277  07d2		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1278  07d4		       18		      clc
   1279  07d5		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1280  07d7		       65 52		      adc	R0
   1281  07d9		       85 52		      sta	R0
   1282  07db		       a5 55		      lda	R1+1
   1283  07dd		       65 53		      adc	R0+1
   1284  07df		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1285  07e1		       20 16 1d 	      jsr	pushR0	; Push R0 assume it is correct
   1286  07e4
   1287  07e4		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1288  07e6		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1289  07e8		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1290  07ea		       a5 55		      lda	R1+1
   1291  07ec		       c5 42		      cmp	VARIABLES+1
   1292  07ee		       d0 1c		      bne	iArrayAtTest
   1293  07f0		       18		      clc
   1294  07f1		       a9 34		      lda	#52	; add the max offset that is valid
   1295  07f3		       65 54		      adc	R1	; update to be the largest offset that is valid
   1296  07f5		       85 54		      sta	R1
   1297  07f7		       a9 00		      lda	#0
   1298  07f9		       65 55		      adc	R1+1
   1299  07fb		       85 55		      sta	R1+1
   1300  07fd				   iArrayVerify 		; try to enforce some sanity to using arrays
   1301  07fd		       a5 53		      lda	R0+1
   1302  07ff		       c5 55		      cmp	R1+1
   1303  0801		       d0 04		      bne	iArrayDecide
   1304  0803		       a5 52		      lda	R0
   1305  0805		       c5 54		      cmp	R1
   1306  0807				   iArrayDecide
   1307  0807		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1308  0809		       4c c2 02 	      jmp	NextIL
   1309  080c
   1310  080c				   iArrayAtTest
   1311  080c		       ad 6c 2f 	      lda	HighMem
   1312  080f		       85 54		      sta	R1
   1313  0811		       ad 6d 2f 	      lda	HighMem+1
   1314  0814		       85 55		      sta	R1+1
   1315  0816		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1316  0818
   1317  0818							; Get here if array index is out of range
   1318  0818		       20 a8 1d    iArrayError jsr	popR0
   1319  081b		       a9 00		      lda	#0
   1320  081d		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1321  081f		       4c a7 06 	      jmp	iErr2
   1322  0822							;
   1323  0822							;=====================================================
   1324  0822							; List the current BASIC program in memory.  Uses R0,
   1325  0822							; tempIly, and dpl.
   1326  0822							;
   1327  0822		       20 95 1f    iLST       jsr	SetOutConsole
   1328  0825		       ad 68 2f    iLST2      lda	ProgramStart
   1329  0828		       85 59		      sta	dpl
   1330  082a		       ad 69 2f 	      lda	ProgramStart+1
   1331  082d		       85 5a		      sta	dpl+1
   1332  082f							;
   1333  082f							; dpl/dph point to the current line.  See if we're at
   1334  082f							; the end of the program.
   1335  082f							;
   1336  082f		       a5 59	   iLSTloop   lda	dpl
   1337  0831		       cd 6a 2f 	      cmp	ProgramEnd
   1338  0834		       d0 07		      bne	iLstNotEnd
   1339  0836		       a5 5a		      lda	dpl+1
   1340  0838		       cd 6b 2f 	      cmp	ProgramEnd+1
   1341  083b		       f0 15		      beq	iLstdone
   1342  083d							;
   1343  083d		       20 ca 14    iLstNotEnd jsr	PrintProgramLine
   1344  0840							;		  ldy	  #1		  ;Change:  Skip first byte length
   1345  0840							;		  lda	  (dpl),y	  ;line number LSB
   1346  0840							;		  sta	  R0
   1347  0840							;		  iny
   1348  0840							;		  lda	  (dpl),y		 ;line number MSB
   1349  0840							;		  sta	  R0+1
   1350  0840							;		  iny
   1351  0840							;		  sty	  tempIlY
   1352  0840							;		  jsr	  PrintDecimal
   1353  0840							;		  lda	  #SPACE
   1354  0840							;		  jsr	  VOUTCH
   1355  0840							;		  ldy	  tempIlY
   1356  0840							;iLSTl2	  lda	  (dpl),y
   1357  0840							;		  beq	  iLST3 	  ;end of this line 0 value
   1358  0840							;		  sty	  tempIlY
   1359  0840							;		  jsr	  VOUTCH
   1360  0840							;		  ldy	  tempIlY
   1361  0840							;		  iny
   1362  0840							;		  bne	  iLSTl2	  ;do next char
   1363  0840							;
   1364  0840							; End of this line.  Print CR/LF, then move to the
   1365  0840							; next line.
   1366  0840							;
   1367  0840		       a0 00	   iLST3      ldy	#0	;Move to next line
   1368  0842		       b1 59		      lda	(dpl),y	;Current line length
   1369  0844		       18		      clc		;Clear the carry flag
   1370  0845							;		  tya
   1371  0845		       65 59		      adc	dpl	;Add the offset to the pointer
   1372  0847		       85 59		      sta	dpl	;Save the new value
   1373  0849		       a5 5a		      lda	dpl+1	;Next byte
   1374  084b		       69 00		      adc	#0	;ad in the carry if any
   1375  084d		       85 5a		      sta	dpl+1	;Save it
   1376  084f							;
   1377  084f							; Have to manually do CR/LF so it uses the vectored
   1378  084f							; output function.
   1379  084f							;
   1380  084f							;		  lda	  #CR
   1381  084f							;		  jsr	  VOUTCH
   1382  084f							;		  lda	  #LF
   1383  084f							;		  jsr	  VOUTCH
   1384  084f		       4c 2f 08 	      jmp	iLSTloop	;do next line
   1385  0852							;
   1386  0852		       20 95 1f    iLstdone   jsr	SetOutConsole
   1387  0855		       4c c2 02 	      jmp	NextIL
   1388  0858							;
   1389  0858							;=====================================================
   1390  0858							; Get a line of text into LINBUF.  Terminate with a
   1391  0858							; null byte.
   1392  0858							;
   1393  0858				   iGETLINE
   1394  0858		       a9 3e		      lda	#'>	;prompt character
   1395  085a		       a6 00		      ldx	0	;Wait for read to complete
   1396  085c		       20 33 1c 	      jsr	GetLine
   1397  085f							;
   1398  085f		       a9 00		      lda	#0
   1399  0861		       85 5b		      sta	RunMode
   1400  0863				   iGetParseLine
   1401  0863							; lda	   CUROFF
   1402  0863							; pha
   1403  0863		       20 d3 10 	      jsr	ParseInputLine
   1404  0866							; pla
   1405  0866							;  sta     CUROFF
   1406  0866		       a9 d0		      lda	#TOKENBUFFER&$FF
   1407  0868		       85 4f		      sta	CURPTR
   1408  086a		       a9 0f		      lda	#TOKENBUFFER>>8
   1409  086c		       85 50		      sta	CURPTR+1
   1410  086e		       a9 01		      lda	#1
   1411  0870		       85 51		      sta	CUROFF
   1412  0872		       4c c2 02 	      jmp	NextIL
   1413  0875							;
   1414  0875							;=====================================================
   1415  0875							; This is called when the input buffer contains a line
   1416  0875							; typed in by the user that starts with a line number.
   1417  0875							; Insert the line into the program or delete the line
   1418  0875							; if there is nothing after the line number,
   1419  0875							;
   1420  0875				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1421  0875		       ad d1 0f 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1422  0878		       85 52		      sta	R0	; place the number into R0
   1423  087a		       ad d2 0f 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1424  087d		       85 53		      STA	R0+1	; Place it into
   1425  087f							;
   1426  087f							; Now find the line OR the next higher line OR the
   1427  087f							; end of the program.
   1428  087f							;
   1429  087f		       20 62 1b 	      jsr	findLine	; Look for the line number in the current program
   1430  0882							; Returns Z and curptr point to the line if found
   1431  0882							; Returns C and curptr at next higher line if not found and there is a higher line
   1432  0882							; Returns ZC clear and curptr to end of program if higher than all other lines
   1433  0882							;
   1434  0882							; If the line exists, it needs to be removed.
   1435  0882							;
   1436  0882		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1437  0884							;
   1438  0884							; Get length of line to be removed, we fall thru to here if we find a matching line
   1439  0884							;
   1440  0884							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1441  0884		       a0 00		      ldy	#0
   1442  0886		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1443  0888		       a8		      tay
   1444  0889							;If it is equal we delete the line and replace it, get length
   1445  0889							;then adjust all program line after up or down depending on len of line
   1446  0889							;If next higher then just move everythimg down by length bytes
   1447  0889							;This call will return how many bytes in the line we found
   1448  0889		       8c 65 2f 	      sty	lineLength	;Save the length of the line we found
   1449  088c							;
   1450  088c							; Compute the new end of the program first.
   1451  088c							;
   1452  088c		       38		      sec		;Set the carry bit
   1453  088d		       ad 6a 2f 	      lda	ProgramEnd	;Get low byte of program end
   1454  0890		       ed 65 2f 	      sbc	lineLength	;Subtract the length of the current line
   1455  0893		       8d 6a 2f 	      sta	ProgramEnd	;save it
   1456  0896		       ad 6b 2f 	      lda	ProgramEnd+1
   1457  0899		       e9 00		      sbc	#0	;Process the carry
   1458  089b		       8d 6b 2f 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1459  089e							;
   1460  089e							; Copy CURPTR into R1 for working
   1461  089e							;
   1462  089e		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1463  08a0		       85 54		      sta	R1
   1464  08a2		       a5 50		      lda	CURPTR+1
   1465  08a4		       85 55		      sta	R1+1
   1466  08a6							;
   1467  08a6							; See if we're at the end.
   1468  08a6							;
   1469  08a6		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1470  08a8		       cd 6a 2f 	      cmp	ProgramEnd
   1471  08ab		       d0 07		      bne	InsDelLoop
   1472  08ad		       a5 55		      lda	R1+1
   1473  08af		       cd 6b 2f 	      cmp	ProgramEnd+1
   1474  08b2		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1475  08b4							;
   1476  08b4							; Move one byte, move to next location.
   1477  08b4							;
   1478  08b4		       ac 65 2f    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1479  08b7		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1480  08b9		       b1 54		      lda	(R1),y
   1481  08bb		       a0 00		      ldy	#0
   1482  08bd		       91 54		      sta	(R1),y
   1483  08bf		       e6 54		      inc	R1
   1484  08c1		       d0 e3		      bne	InsDelChk
   1485  08c3		       e6 55		      inc	R1+1
   1486  08c5		       4c a6 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1487  08c8							;
   1488  08c8							; Deletion is done.
   1489  08c8							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1490  08c8							;
   1491  08c8				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1492  08c8		       ad d0 0f 	      lda	TOKENBUFFER	; Get the length
   1493  08cb		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1494  08cd							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1495  08cd		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1496  08cf							;
   1497  08cf							; CURPTR points to where the line will be inserted.
   1498  08cf							;
   1499  08cf							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1500  08cf		       ae d0 0f 	      ldx	TOKENBUFFER
   1501  08d2		       8e 65 2f 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1502  08d5							;
   1503  08d5		       ad 6a 2f 	      lda	ProgramEnd	;Load the start address for the copy
   1504  08d8							;At this point curptr still contains the location we will insert data
   1505  08d8		       85 5c		      sta	FROM
   1506  08da		       ad 6b 2f 	      lda	ProgramEnd+1
   1507  08dd		       85 5d		      sta	FROM+1
   1508  08df							;
   1509  08df		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1510  08e1		       b1 5c		      lda	(FROM),y
   1511  08e3		       ac 65 2f 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1512  08e6		       91 5c		      sta	(FROM),y	;Save the new byte
   1513  08e8							;
   1514  08e8		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1515  08ea		       c5 4f		      cmp	CURPTR
   1516  08ec		       d0 06		      bne	mvUpMore
   1517  08ee		       a5 5d		      lda	FROM+1
   1518  08f0		       c5 50		      cmp	CURPTR+1
   1519  08f2		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1520  08f4							;
   1521  08f4							; Not done yet
   1522  08f4							;
   1523  08f4		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1524  08f6		       d0 02		      bne	mvUpMore2
   1525  08f8		       c6 5d		      dec	FROM+1
   1526  08fa		       c6 5c	   mvUpMore2  dec	FROM
   1527  08fc		       4c df 08 	      jmp	mvup1	;Loop until everything is moved
   1528  08ff							;
   1529  08ff							; All done with copy.
   1530  08ff							;
   1531  08ff				   mvUpDone
   1532  08ff		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1533  0900		       ad 65 2f 	      lda	lineLength	;Number of bytes to copy from line buff
   1534  0903		       6d 6a 2f 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1535  0906		       8d 6a 2f 	      sta	ProgramEnd
   1536  0909		       ad 6b 2f 	      lda	ProgramEnd+1
   1537  090c		       69 00		      adc	#0
   1538  090e		       8d 6b 2f 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1539  0911							;
   1540  0911							;===================jlit use length before line newline
   1541  0911
   1542  0911		       a0 00		      ldy	#0	;Set offset of copy
   1543  0913							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1544  0913							;		  sta	  (CURPTR),y	  ;Store the length
   1545  0913							;		  iny
   1546  0913							;		  lda	  R0		  ;Store the line number next
   1547  0913							;		  sta	  (CURPTR),y
   1548  0913							;		  iny
   1549  0913							;		  lda	  R0+1
   1550  0913							;		  sta	  (CURPTR),y
   1551  0913							;		  iny
   1552  0913							;
   1553  0913							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1554  0913		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1555  0915				   mvUpLoop2
   1556  0915							;		  lda	  LINBUF,x	 ;get a byte
   1557  0915		       bd d0 0f 	      lda	TOKENBUFFER,x	;get a byte
   1558  0918		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1559  091a
   1560  091a		       e8		      inx
   1561  091b		       ec d0 0f 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1562  091e		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1563  0920		       c8		      iny
   1564  0921		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1565  0923							;
   1566  0923		       4c c2 02    mvUpFini   jmp	NextIL
   1567  0926							;
   1568  0926							;=====================================================
   1569  0926							; Pops the top value of the ILPC stack and stores it
   1570  0926							; in ILPC.  Ie, return from an IL subroutine.
   1571  0926							;
   1572  0926		       20 50 1b    iRTN       jsr	popILPC
   1573  0929		       4c c2 02 	      jmp	NextIL
   1574  092c							;
   1575  092c							;=====================================================
   1576  092c							; NLINE print a newline
   1577  092c							;
   1578  092c		       20 61 1e    iNLINE     jsr	CRLF	;user supplied sub
   1579  092f		       4c c2 02 	      jmp	NextIL
   1580  0932							;
   1581  0932							;=====================================================
   1582  0932							; This saves the current ILPC value on the stack, then
   1583  0932							; jumps to the address specified by the next two bytes.
   1584  0932							;
   1585  0932		       20 33 1b    iCALL      jsr	pushILPC	;save ILPC
   1586  0935		       90 03		      bcc	iJMP
   1587  0937		       4c ec 0b 	      jmp	ErrStkOver	; Check if there was an error
   1588  093a							;
   1589  093a							; Jmp to a specific location in the IL code.  The new
   1590  093a							; address immediately follows the opcode.
   1591  093a							;
   1592  093a		       20 19 1b    iJMP       jsr	getILWord
   1593  093d		       86 43		      stx	ILPC
   1594  093f		       85 44		      sta	ILPC+1
   1595  0941		       4c c2 02 	      jmp	NextIL
   1596  0944
   1597  0944
   1598  0944							;
   1599  0944							;=====================================================
   1600  0944							; Push the next two bytes onto the arithmetic stack.
   1601  0944							;
   1602  0944		       20 1d 1b    iSetR2     jsr	getILByte
   1603  0947		       85 58		      sta	R2
   1604  0949		       4c c2 02 	      jmp	NextIL
   1605  094c							;
   1606  094c							;=====================================================
   1607  094c							; Push the next two bytes onto the arithmetic stack.
   1608  094c							;
   1609  094c		       20 19 1b    iLIT       jsr	getILWord
   1610  094f		       86 52		      stx	R0
   1611  0951		       85 53		      sta	R0+1
   1612  0953		       20 16 1d 	      jsr	pushR0
   1613  0956		       4c c2 02 	      jmp	NextIL
   1614  0959							;
   1615  0959							;=====================================================
   1616  0959							; Initialize all variables for a single task.	Ie, set to zero.
   1617  0959							;
   1618  0959		       98	   subVINIT   tya
   1619  095a		       48		      pha
   1620  095b
   1621  095b		       a9 00		      lda	#0
   1622  095d		       a0 00		      ldy	#0
   1623  095f		       91 41	   Vinit2     sta	(VARIABLES),y
   1624  0961		       c8		      iny
   1625  0962		       c0 34		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1626  0964		       90 f9		      bcc	Vinit2
   1627  0966
   1628  0966		       68		      pla
   1629  0967		       a8		      tay
   1630  0968		       60		      rts
   1631  0969
   1632  0969		       20 92 0d    iVINIT     jsr	Compile	; compile line numbers to memory pointers
   1633  096c		       20 59 09 	      jsr	subVINIT
   1634  096f		       4c c2 02 	      jmp	NextIL
   1635  0972							;
   1636  0972							;=====================================================
   1637  0972							; Set the address of the error handler.  After any
   1638  0972							; error, set to the ILPC to the specified location.
   1639  0972							;
   1640  0972		       20 19 1b    iERRGOTO   jsr	getILWord
   1641  0975		       8e 55 2f 	      stx	errGoto
   1642  0978		       8d 56 2f 	      sta	errGoto+1
   1643  097b		       4c c2 02 	      jmp	NextIL
   1644  097e							;
   1645  097e							;=====================================================
   1646  097e							; TST is followed by an 8 bit signed offset, then a
   1647  097e							; null terminated string.  Compare the string against
   1648  097e							; the string starting at (CURPTR),CUROFF.  If the
   1649  097e							; strings match, continue executing the next IL
   1650  097e							; opcode.  Else, add the offset to ILPC.
   1651  097e							;
   1652  097e		       20 1d 1b    iTST       jsr	getILByte	;Get the relative jump address
   1653  0981		       8d 64 2f 	      sta	offset	;save it to use if test faile
   1654  0984		       20 00 1d 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1655  0987
   1656  0987		       a4 51		      ldy	CUROFF
   1657  0989		       84 59		      sty	dpl	;save for later
   1658  098b							;
   1659  098b		       20 1d 1b    iTSTloop   jsr	getILByte	;get next char
   1660  098e		       f0 11		      beq	iTSTm	;match!
   1661  0990		       a4 59		      ldy	dpl
   1662  0992		       d1 4f		      cmp	(CURPTR),y
   1663  0994		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1664  0996		       09 20		      ora	#$20	; lets allow lowercase as well
   1665  0998		       d1 4f		      cmp	(CURPTR),y
   1666  099a		       d0 23		      bne	iTSTfail	;mismatch
   1667  099c		       c8	   iTSTUpper  iny
   1668  099d		       84 59		      sty	dpl
   1669  099f		       d0 ea		      bne	iTSTloop
   1670  09a1							;
   1671  09a1							; It's a match!  Clean up a bit.
   1672  09a1							;
   1673  09a1		       a4 59	   iTSTm      ldy	dpl
   1674  09a3		       84 51		      sty	CUROFF
   1675  09a5		       4c c2 02 	      jmp	NextIL
   1676  09a8
   1677  09a8							; Test for a single quote string
   1678  09a8		       20 1d 1b    iTSTStr    jsr	getILByte
   1679  09ab		       8d 64 2f 	      sta	offset
   1680  09ae		       20 00 1d 	      jsr	saveIL
   1681  09b1		       a4 51		      ldy	CUROFF
   1682  09b3		       a9 22		      lda	#'"
   1683  09b5		       d1 4f		      cmp	(CURPTR),y
   1684  09b7		       d0 06		      bne	iTSTfail
   1685  09b9		       c8		      iny
   1686  09ba		       84 51		      sty	CUROFF
   1687  09bc		       4c e5 02 	      jmp	NextILStr
   1688  09bf							;
   1689  09bf							; Not a match, reset ILPC and then move to the
   1690  09bf							; offset.
   1691  09bf							;
   1692  09bf		       20 0b 1d    iTSTfail   jsr	restoreIL
   1693  09c2		       4c 9a 0b 	      jmp	tstBranch
   1694  09c5							;
   1695  09c5							;=================================================JLIT=
   1696  09c5							; Test if we have a let statement without the let keyword
   1697  09c5		       20 1d 1b    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1698  09c8		       8d 64 2f 	      sta	offset	; Save the jump offset for fails
   1699  09cb		       20 00 1d 	      jsr	saveIL	; save to restore when done if fail
   1700  09ce
   1701  09ce		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1702  09d0		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1703  09d2		       c9 01		      cmp	#kLet	; Is it a let keyword
   1704  09d4		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1705  09d6		       c9 80		      cmp	#tVa	; lets check for a variable
   1706  09d8		       90 e5		      bcc	iTSTfail	; Less than variable range
   1707  09da		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1708  09dc		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1709  09de		       b0 df		      bcs	iTSTfail	; return it failed
   1710  09e0
   1711  09e0				   iTSTLETGOOD
   1712  09e0		       c8		      iny
   1713  09e1		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1714  09e3				   iTSTGOODVAR
   1715  09e3		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1716  09e6
   1717  09e6							;=================================================JLIT=
   1718  09e6							; Test a byte at an indirect address
   1719  09e6							; fails if byte is not equal to the value at the address
   1720  09e6							; The tests an indirect byte and branches if true
   1721  09e6		       20 1d 1b    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1722  09e9		       8d 64 2f 	      sta	offset	; Save the jump offset for fails
   1723  09ec		       20 00 1d 	      jsr	saveIL	; save to restore when done if fail
   1724  09ef		       20 19 1b 	      jsr	getILWord	; Get a word into RO
   1725  09f2		       86 52		      stx	R0
   1726  09f4		       85 53		      sta	R0+1
   1727  09f6		       20 1d 1b 	      jsr	getILByte	; Get byte into A
   1728  09f9		       a0 00		      ldy	#0
   1729  09fb		       d1 52		      cmp	(R0),y
   1730  09fd		       d0 03		      bne	iTSTByteNotEqual
   1731  09ff		       4c bf 09 	      jmp	iTSTfail
   1732  0a02
   1733  0a02				   iTSTByteNotEqual
   1734  0a02		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1735  0a05
   1736  0a05							;=================================================JLIT=
   1737  0a05							; Test a byte	branch if it fails
   1738  0a05		       20 1d 1b    iTSTB      jsr	getILByte	; Get the relative offset byte
   1739  0a08		       8d 64 2f 	      sta	offset	; Save the jump offset for fails
   1740  0a0b		       20 00 1d 	      jsr	saveIL	; save to restore when done if fail
   1741  0a0e		       20 1d 1b 	      jsr	getILByte	; Get a word into RO
   1742  0a11		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1743  0a13		       d1 4f		      cmp	(CURPTR),y
   1744  0a15		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1745  0a17		       4c bf 09 	      jmp	iTSTfail	; REcover and move on to next test
   1746  0a1a
   1747  0a1a				   iTSTBMatch
   1748  0a1a		       c8		      iny
   1749  0a1b		       84 51		      sty	CUROFF	; Point to the next byte
   1750  0a1d		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1751  0a20
   1752  0a20							;=================================================JLIT=
   1753  0a20							; Test a byte	branch if it fails
   1754  0a20		       20 1d 1b    iTSTW      jsr	getILByte	; Get the relative offset byte
   1755  0a23		       8d 64 2f 	      sta	offset	; Save the jump offset for fails
   1756  0a26		       20 00 1d 	      jsr	saveIL	; save to restore when done if fail
   1757  0a29		       20 19 1b 	      jsr	getILWord	; Get a word into RO
   1758  0a2c		       86 52		      stx	R0
   1759  0a2e		       85 53		      sta	R0+1
   1760  0a30		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1761  0a32		       8a		      txa
   1762  0a33		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1763  0a35		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1764  0a37		       4c bf 09 	      jmp	iTSTfail	; REcover and move on to next test
   1765  0a3a		       c8	   iTSTWM1    iny
   1766  0a3b		       a5 53		      lda	R0+1
   1767  0a3d		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1768  0a3f		       f0 03		      beq	iTSTWMatch
   1769  0a41		       4c bf 09 	      jmp	iTSTfail
   1770  0a44
   1771  0a44				   iTSTWMatch
   1772  0a44		       c8		      iny
   1773  0a45		       84 51		      sty	CUROFF
   1774  0a47		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1775  0a4a
   1776  0a4a							;================================================jLIT=
   1777  0a4a							;Test for end of line
   1778  0a4a							;
   1779  0a4a				   iTSTDONE
   1780  0a4a		       20 1d 1b 	      jsr	getILByte
   1781  0a4d		       8d 64 2f 	      sta	offset
   1782  0a50		       20 00 1d 	      jsr	saveIL
   1783  0a53		       a4 51		      ldy	CUROFF
   1784  0a55		       84 59		      sty	dpl
   1785  0a57		       b1 4f		      lda	(CURPTR),y
   1786  0a59		       f0 0b		      beq	iTSTDONEtrue
   1787  0a5b		       c9 e6		      cmp	#oColon
   1788  0a5d		       f0 07		      beq	iTSTDONEtrue
   1789  0a5f		       a4 59		      ldy	dpl
   1790  0a61		       84 51		      sty	CUROFF
   1791  0a63		       4c bf 09 	      jmp	iTSTfail
   1792  0a66							;
   1793  0a66							; Advance to the next line
   1794  0a66							;
   1795  0a66				   iTSTDONEtrue
   1796  0a66		       4c c2 02 	      jmp	NextIL
   1797  0a69
   1798  0a69		       4c 9a 0b    tstBranchLink jmp	tstBranch
   1799  0a6c							;
   1800  0a6c							;=====================================================
   1801  0a6c							; Inc and dec a variable , faster than a = a + 1
   1802  0a6c				   iINCVAR
   1803  0a6c		       20 a8 1d 	      jsr	popR0
   1804  0a6f		       a0 00		      ldy	#0
   1805  0a71		       18		      clc
   1806  0a72		       a9 01		      lda	#1
   1807  0a74		       71 52		      adc	(R0),y
   1808  0a76		       91 52		      sta	(R0),y
   1809  0a78		       90 07		      bcc	iINCDONE
   1810  0a7a		       c8		      iny
   1811  0a7b		       a9 00		      lda	#0
   1812  0a7d		       71 52		      adc	(R0),y
   1813  0a7f		       91 52		      sta	(R0),y
   1814  0a81				   iINCDONE
   1815  0a81		       4c c2 02 	      jmp	NextIL
   1816  0a84
   1817  0a84				   iDECVAR
   1818  0a84		       20 a8 1d 	      jsr	popR0
   1819  0a87		       a0 00		      ldy	#0
   1820  0a89		       38		      sec
   1821  0a8a		       b1 52		      lda	(R0),y
   1822  0a8c		       e9 01		      sbc	#1
   1823  0a8e		       91 52		      sta	(R0),y
   1824  0a90		       c8		      iny
   1825  0a91		       b1 52		      lda	(R0),y
   1826  0a93		       e9 00		      sbc	#0
   1827  0a95		       91 52		      sta	(R0),y
   1828  0a97		       4c c2 02 	      jmp	NextIL
   1829  0a9a
   1830  0a9a
   1831  0a9a							;
   1832  0a9a							;=====================================================
   1833  0a9a							; TSTV is followed by an 8 bit signed offset.	If the
   1834  0a9a							; value at (CURPTR),CUROFF appears to be a variable
   1835  0a9a							; name, move to the next IL statement.  Else, add the
   1836  0a9a							; offset to ILPC. Converted to use actual absolute memory addresses
   1837  0a9a							; TSTVT Looks for the task context
   1838  0a9a							;
   1839  0a9a		       20 c0 1d    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1840  0a9d		       a9 00		      lda	#0
   1841  0a9f		       85 58		      sta	R2
   1842  0aa1		       f0 04		      beq	iTSTVV
   1843  0aa3
   1844  0aa3		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1845  0aa5		       85 58		      sta	R2
   1846  0aa7
   1847  0aa7		       20 1d 1b    iTSTVV     jsr	getILByte	;offset
   1848  0aaa		       8d 64 2f 	      sta	offset
   1849  0aad							;
   1850  0aad		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1851  0aaf		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1852  0ab1		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1853  0ab3		       4c 69 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1854  0ab6							;
   1855  0ab6				   iTSTVnext
   1856  0ab6		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1857  0ab8		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1858  0aba
   1859  0aba		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1860  0abc		       f0 5b		      beq	iTSTVParm
   1861  0abe
   1862  0abe		       c9 9b		      cmp	#tVhat	; task exit code
   1863  0ac0		       d0 04		      bne	iTSTV_A2Z
   1864  0ac2		       a9 34		      lda	#TASKEXITCODE
   1865  0ac4		       d0 0b		      bne	iTSTVContinue
   1866  0ac6
   1867  0ac6				   iTSTV_A2Z
   1868  0ac6
   1869  0ac6		       c9 80		      cmp	#tVa
   1870  0ac8		       90 9f		      bcc	tstBranchLink
   1871  0aca		       c9 9a		      cmp	#tVz+1
   1872  0acc		       b0 9b		      bcs	tstBranchLink
   1873  0ace
   1874  0ace
   1875  0ace							;
   1876  0ace							; The condition is true, so convert to an index, push
   1877  0ace							; it onto the stack and continue running.
   1878  0ace							;
   1879  0ace		       29 7f		      and	#%01111111	; Mask off the high bit
   1880  0ad0		       0a		      asl		; multiply by two
   1881  0ad1
   1882  0ad1				   iTSTVContinue
   1883  0ad1		       c8		      iny
   1884  0ad2		       84 51		      sty	CUROFF	; it is a valid variable
   1885  0ad4		       48		      pha		; save the last variable pointer value
   1886  0ad5		       a5 58		      lda	R2
   1887  0ad7		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1888  0ad9
   1889  0ad9		       20 f2 1a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1890  0adc		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1891  0ade
   1892  0ade		       68		      pla		; We have an invalid pid for getting variable value
   1893  0adf		       a2 10		      ldx	#ERR_INVALID_PID
   1894  0ae1		       a9 00		      lda	#0
   1895  0ae3		       4c a7 06 	      jmp	iErr2
   1896  0ae6
   1897  0ae6				   iTSTVGOODPID
   1898  0ae6		       20 da 1a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1899  0ae9		       a0 01		      ldy	#VARIABLEPOS
   1900  0aeb		       b1 56		      lda	(MQ),y
   1901  0aed		       85 52		      sta	R0
   1902  0aef		       c8		      iny
   1903  0af0		       b1 56		      lda	(MQ),y
   1904  0af2		       85 53		      sta	R0+1
   1905  0af4		       4c ff 0a 	      jmp	iTSTVAddOffset
   1906  0af7
   1907  0af7				   iTSTVLocalValue
   1908  0af7		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1909  0af9		       85 52		      sta	R0
   1910  0afb		       a5 42		      lda	VARIABLES+1
   1911  0afd		       85 53		      sta	R0+1
   1912  0aff
   1913  0aff				   iTSTVAddOffset
   1914  0aff		       68		      pla
   1915  0b00		       85 54		      sta	R1
   1916  0b02		       a9 00		      lda	#0
   1917  0b04		       85 55		      sta	R1+1
   1918  0b06
   1919  0b06				   iTSTVcontinue
   1920  0b06
   1921  0b06		       4c c8 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1922  0b09
   1923  0b09							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1924  0b09							; an array of integer values
   1925  0b09				   iTSTVat
   1926  0b09		       c8		      iny
   1927  0b0a		       84 51		      sty	CUROFF	;it is a valid variable
   1928  0b0c		       ad 6a 2f 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1929  0b0f		       85 52		      sta	R0
   1930  0b11		       ad 6b 2f 	      lda	ProgramEnd+1
   1931  0b14		       85 53		      sta	R0+1
   1932  0b16		       4c 40 07 	      jmp	pushR0nextIl	;place this onto the stack
   1933  0b19
   1934  0b19							; When we get parameters passed we can access them using the # variable with[]
   1935  0b19							; example #[0] #[1] etc, we dont check yet if there is too many
   1936  0b19				   iTSTVParm
   1937  0b19		       c8		      iny
   1938  0b1a		       84 51		      sty	CUROFF	;it is a valid variable
   1939  0b1c		       a5 48		      lda	MATHSTACK
   1940  0b1e		       85 52		      sta	R0
   1941  0b20		       a5 49		      lda	MATHSTACK+1
   1942  0b22		       85 53		      sta	R0+1
   1943  0b24		       4c 40 07 	      jmp	pushR0nextIl
   1944  0b27
   1945  0b27							;
   1946  0b27							;=====================================================
   1947  0b27							; TSTL seems basically the same as TSTN, but leave the
   1948  0b27							; value in R0 instead of pushing onto stack.
   1949  0b27							; This tests for a valid line number
   1950  0b27							;
   1951  0b27		       20 1d 1b    iTSTL      jsr	getILByte
   1952  0b2a		       8d 64 2f 	      sta	offset
   1953  0b2d							;
   1954  0b2d		       a4 51		      ldy	CUROFF
   1955  0b2f		       b1 4f		      lda	(CURPTR),y
   1956  0b31		       c8		      iny
   1957  0b32		       11 4f		      ora	(CURPTR),y
   1958  0b34		       f0 06		      beq	iTSTLNotLineNo
   1959  0b36
   1960  0b36
   1961  0b36							; In Both cases we need to point to the first usefull byte to process.
   1962  0b36		       c8		      iny
   1963  0b37		       84 51		      sty	CUROFF
   1964  0b39		       4c c2 02 	      jmp	NextIL
   1965  0b3c				   iTSTLNotLineNo
   1966  0b3c		       c8		      iny
   1967  0b3d		       84 51		      sty	CUROFF
   1968  0b3f		       4c 9a 0b 	      jmp	tstBranch
   1969  0b42
   1970  0b42							;
   1971  0b42							;=====================================================
   1972  0b42							; TSTN checks for a number.  This is very simplistic;
   1973  0b42							; if the character is a digit, assume it's a number.
   1974  0b42							; Convert to a number and push it onto the stack.
   1975  0b42							;
   1976  0b42		       20 1d 1b    iTSTN      jsr	getILByte
   1977  0b45		       8d 64 2f 	      sta	offset
   1978  0b48							;
   1979  0b48		       a9 00		      lda	#0
   1980  0b4a		       85 59		      sta	dpl
   1981  0b4c		       a4 51		      ldy	CUROFF
   1982  0b4e				   chkType
   1983  0b4e		       b1 4f		      lda	(CURPTR),y
   1984  0b50		       c9 a2		      cmp	#tByte
   1985  0b52		       f0 0e		      beq	chkByte
   1986  0b54		       c9 a1		      cmp	#tInteger
   1987  0b56		       f0 16		      beq	chkInteger
   1988  0b58		       c9 eb		      cmp	#oMinus
   1989  0b5a		       d0 3e		      bne	tstBranch
   1990  0b5c		       e6 59		      inc	dpl
   1991  0b5e		       c8		      iny
   1992  0b5f		       4c 4e 0b 	      jmp	chkType
   1993  0b62
   1994  0b62				   chkByte
   1995  0b62		       a9 00		      lda	#0
   1996  0b64		       85 53		      sta	R0+1
   1997  0b66		       c8		      iny
   1998  0b67		       b1 4f		      lda	(CURPTR),y
   1999  0b69		       85 52		      sta	R0
   2000  0b6b		       c8		      iny
   2001  0b6c		       d0 0b		      bne	iTSTN_1
   2002  0b6e
   2003  0b6e				   chkInteger
   2004  0b6e		       c8		      iny
   2005  0b6f		       b1 4f		      lda	(CURPTR),y
   2006  0b71		       85 52		      sta	R0
   2007  0b73		       c8		      iny
   2008  0b74		       b1 4f		      lda	(CURPTR),y
   2009  0b76		       85 53		      sta	R0+1
   2010  0b78		       c8		      iny
   2011  0b79							;
   2012  0b79							; Check if it is negative and make it so
   2013  0b79							;
   2014  0b79				   iTSTN_1
   2015  0b79		       84 51		      sty	CUROFF
   2016  0b7b
   2017  0b7b		       a5 59		      lda	dpl
   2018  0b7d		       f0 18		      beq	iTSTN_2	;positive
   2019  0b7f							;
   2020  0b7f		       a5 52		      lda	R0
   2021  0b81		       05 53		      ora	R0+1
   2022  0b83		       f0 12		      beq	iTSTN_2	;zero
   2023  0b85
   2024  0b85							; Invert all the bits, then add one.
   2025  0b85							;
   2026  0b85		       a5 52		      lda	R0
   2027  0b87		       49 ff		      eor	#$ff
   2028  0b89		       85 52		      sta	R0
   2029  0b8b		       a5 53		      lda	R0+1
   2030  0b8d		       49 ff		      eor	#$ff
   2031  0b8f		       85 53		      sta	R0+1
   2032  0b91							;
   2033  0b91		       e6 52		      inc	R0
   2034  0b93		       d0 02		      bne	iTSTN_2
   2035  0b95		       e6 53		      inc	R0+1
   2036  0b97				   iTSTN_2
   2037  0b97		       4c 40 07 	      jmp	pushR0nextIl	;save onto stack
   2038  0b9a
   2039  0b9a							;
   2040  0b9a							; Common jump point for all TSTx instructions that
   2041  0b9a							; fail to meet the requirements.  This takes the
   2042  0b9a							; offset and adds/subtracts to/from ILPC.
   2043  0b9a							;
   2044  0b9a		       ad 64 2f    tstBranch  lda	offset	;get signed offset
   2045  0b9d		       10 0e		      bpl	tstPositive
   2046  0b9f							;
   2047  0b9f							; Do negative branch.	Do sign extension.
   2048  0b9f							;
   2049  0b9f		       18	   tstNegative clc
   2050  0ba0		       65 43		      adc	ILPC
   2051  0ba2		       85 43		      sta	ILPC
   2052  0ba4							;		  bcc	  tstBothDone
   2053  0ba4							;		  dec	  ILPC+1
   2054  0ba4							;		  jmp	  NextIL
   2055  0ba4
   2056  0ba4		       a5 44		      lda	ILPC+1
   2057  0ba6		       69 ff		      adc	#$ff
   2058  0ba8		       85 44		      sta	ILPC+1
   2059  0baa		       4c c2 02 	      jmp	NextIL	;keep going
   2060  0bad							;
   2061  0bad		       18	   tstPositive clc
   2062  0bae		       65 43		      adc	ILPC
   2063  0bb0		       85 43		      sta	ILPC
   2064  0bb2		       90 02		      bcc	tstBothDone
   2065  0bb4		       e6 44		      inc	ILPC+1
   2066  0bb6				   tstBothDone
   2067  0bb6		       4c c2 02 	      jmp	NextIL
   2068  0bb9
   2069  0bb9							;
   2070  0bb9							;====================================================
   2071  0bb9							; Test for IRQ pending, and test if a break key pressed
   2072  0bb9							; Yes I know but this handles all sorts of irq/break issues
   2073  0bb9							;
   2074  0bb9		       20 1d 1b    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2075  0bbc		       8d 64 2f 	      sta	offset	; Store the not true jump address offset
   2076  0bbf		       20 4b 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2077  0bc2		       d0 03		      bne	irqNo	; z not set of no break found
   2078  0bc4		       4c 34 06 	      jmp	iFIN	; Exit out of run mode
   2079  0bc7		       ad 0c 26    irqNo      lda	IRQPending
   2080  0bca		       f0 ce		      beq	tstBranch
   2081  0bcc		       c9 01		      cmp	#1	; only do this if set to first time
   2082  0bce		       d0 ca		      bne	tstBranch
   2083  0bd0		       78		      sei		; disable the interupt until ireturn resets it
   2084  0bd1		       ee 0c 26    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2085  0bd4		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2086  0bd6		       20 30 1d 	      jsr	pushLN	; Push the next line to be executed
   2087  0bd9		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2088  0bdb		       ad 0d 26 	      lda	IRQEntry	; Get the line number to branch to
   2089  0bde		       85 4f		      sta	CURPTR	; put line number into r0
   2090  0be0		       ad 0e 26 	      lda	IRQEntry+1
   2091  0be3		       85 50		      sta	CURPTR+1
   2092  0be5		       a9 03		      lda	#3	; Point to first byte of program text
   2093  0be7		       85 51		      sta	CUROFF
   2094  0be9		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2095  0bec
   2096  0bec		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2097  0bee		       a9 00		      lda	#0	; stop the execution
   2098  0bf0		       4c a7 06 	      jmp	iErr2
   2099  0bf3							;
   2100  0bf3
   2101  0bf3							;=====================================================
   2102  0bf3							; This places the number of free bytes on top of the
   2103  0bf3							; stack.
   2104  0bf3							;
   2105  0bf3		       20 4b 16    iFREE      jsr	MemFree
   2106  0bf6		       20 16 1d 	      jsr	pushR0
   2107  0bf9		       4c c2 02 	      jmp	NextIL
   2108  0bfc							;
   2109  0bfc							;=====================================================
   2110  0bfc							; Generate a random number from 0-FFFF and then MOD
   2111  0bfc							; it with the value on top of stack.  Leaves number on
   2112  0bfc							; stack
   2113  0bfc							;
   2114  0bfc		       20 c0 1d    iRANDOM    jsr	popR1	;mod value
   2115  0bff							;
   2116  0bff							; If the value is zero, just return a one.
   2117  0bff							;
   2118  0bff		       a5 54		      lda	R1
   2119  0c01		       05 55		      ora	R1+1
   2120  0c03		       f0 4a		      beq	irandom1
   2121  0c05							;
   2122  0c05		       ad 5b 2f 	      lda	random+1
   2123  0c08		       8d 58 2f 	      sta	rtemp1
   2124  0c0b		       ad 5a 2f 	      lda	random
   2125  0c0e		       0a		      asl
   2126  0c0f		       2e 58 2f 	      rol	rtemp1
   2127  0c12		       0a		      asl
   2128  0c13		       2e 58 2f 	      rol	rtemp1
   2129  0c16		       18		      clc
   2130  0c17		       6d 5a 2f 	      adc	random
   2131  0c1a
   2132  0c1a		       48		      pha
   2133  0c1b
   2134  0c1b		       ad 58 2f 	      lda	rtemp1
   2135  0c1e		       6d 5b 2f 	      adc	random+1
   2136  0c21		       8d 5b 2f 	      sta	random+1
   2137  0c24
   2138  0c24		       68		      pla
   2139  0c25
   2140  0c25		       69 11		      adc	#$11
   2141  0c27		       8d 5a 2f 	      sta	random
   2142  0c2a		       ad 5b 2f 	      lda	random+1
   2143  0c2d		       69 36		      adc	#$36
   2144  0c2f		       8d 5b 2f 	      sta	random+1
   2145  0c32
   2146  0c32		       ad 5a 2f 	      lda	random
   2147  0c35		       85 52		      sta	R0
   2148  0c37		       ad 5b 2f 	      lda	random+1
   2149  0c3a		       29 7f		      and	#$7f	;make positive
   2150  0c3c		       85 53		      sta	R0+1
   2151  0c3e							;
   2152  0c3e							; R0 contains the number and R1 contains the max value.
   2153  0c3e							;
   2154  0c3e		       20 66 07 	      jsr	iDivNoPop
   2155  0c41		       20 29 1e 	      jsr	RestoreSigns
   2156  0c44		       a5 56		      lda	MQ
   2157  0c46		       85 52		      sta	R0
   2158  0c48		       a5 57		      lda	MQ+1
   2159  0c4a		       85 53		      sta	R0+1
   2160  0c4c		       4c 40 07 	      jmp	pushR0nextIl
   2161  0c4f				   irandom1
   2162  0c4f		       a9 00		      lda	#0
   2163  0c51		       85 53		      sta	R0+1
   2164  0c53		       a9 01		      lda	#1
   2165  0c55		       85 52		      sta	R0
   2166  0c57		       4c 40 07 	      jmp	pushR0nextIl
   2167  0c5a
   2168  0c5a							; The following replaced by call to division/modulo
   2169  0c5a							;iRANDOM_2	lda	R0
   2170  0c5a							;		cmp	R1
   2171  0c5a							;		bne	iRANDOM_1
   2172  0c5a							;		lda	R0+1
   2173  0c5a							;		cmp	R1+1
   2174  0c5a							;		bne	iRANDOM_1	;need to subtract
   2175  0c5a							;
   2176  0c5a							; Subtract R1 from R0
   2177  0c5a							;
   2178  0c5a							;iRANDOM_sub	sec
   2179  0c5a							;		lda	R0
   2180  0c5a							;		sbc	R1
   2181  0c5a							;		sta	R0
   2182  0c5a							;		lda	R0+1
   2183  0c5a							;		sbc	R1+1
   2184  0c5a							;		sta	R0+1
   2185  0c5a							;		jmp	iRANDOM_2
   2186  0c5a							;
   2187  0c5a							; See if R1 > R0.  If so, branch to subtract.
   2188  0c5a							;
   2189  0c5a							;iRANDOM_1	lda	R0
   2190  0c5a							;		cmp	R1
   2191  0c5a							;		lda	R0+1
   2192  0c5a							;		sbc	R1+1
   2193  0c5a							;		bvc	iRANDOM_4
   2194  0c5a							;		eor	#$80
   2195  0c5a							;iRANDOM_4	bpl	iRANDOM_sub
   2196  0c5a							;
   2197  0c5a							; All done.  Almost.  Add one, then push the result.
   2198  0c5a							;
   2199  0c5a							;irandom1	inc	R0
   2200  0c5a							;		bne	iRANDOM_3
   2201  0c5a							;		inc	R0+1
   2202  0c5a							;iRANDOM_3
   2203  0c5a							;		  jsr	pushR0	;return value
   2204  0c5a							;		jmp	NextIL
   2205  0c5a							;
   2206  0c5a							; Poke a value into a memory location
   2207  0c5a		       8c 60 2f    iPOKEMEMORY sty	tempy
   2208  0c5d		       20 a8 1d 	      jsr	popR0
   2209  0c60		       20 c0 1d 	      jsr	popR1
   2210  0c63		       a0 00		      ldy	#0
   2211  0c65		       a5 52		      lda	R0
   2212  0c67		       91 54		      sta	(R1),y
   2213  0c69		       ac 60 2f 	      ldy	tempy
   2214  0c6c		       4c c2 02 	      jmp	NextIL
   2215  0c6f							;
   2216  0c6f							; Get a value from a memory location
   2217  0c6f							;
   2218  0c6f		       8c 60 2f    iPEEKMEMORY sty	tempy
   2219  0c72		       20 a8 1d 	      jsr	popR0
   2220  0c75		       a0 00		      ldy	#0
   2221  0c77		       b1 52		      lda	(R0),y
   2222  0c79		       ac 60 2f 	      ldy	tempy
   2223  0c7c		       85 52		      sta	R0
   2224  0c7e		       a9 00		      lda	#0
   2225  0c80		       85 53		      sta	R0+1
   2226  0c82		       4c 40 07 	      jmp	pushR0nextIl
   2227  0c85							;
   2228  0c85							; Call to address return what ever is in a to the stack
   2229  0c85							; func2 will load a value into a before the call
   2230  0c85		       20 c0 1d    iCallFunc  jsr	popR1
   2231  0c88		       a5 54		      lda	R1
   2232  0c8a		       20 96 0c 	      jsr	iCallRtn
   2233  0c8d		       85 52		      sta	R0
   2234  0c8f		       a9 00		      lda	#0
   2235  0c91		       85 53		      sta	R0+1
   2236  0c93		       20 40 07 	      jsr	pushR0nextIl
   2237  0c96				   iCallRtn
   2238  0c96		       20 a8 1d 	      jsr	popR0
   2239  0c99		       6c 52 00 	      jmp	(R0)
   2240  0c9c
   2241  0c9c
   2242  0c9c							;===========================================jlit======
   2243  0c9c							;Get a character from the terminal convert to value
   2244  0c9c							;leave the number on top of the stack
   2245  0c9c							;
   2246  0c9c				   iGETCHAR
   2247  0c9c		       20 b2 1f 	      jsr	VGETCH
   2248  0c9f					      if	CTMON65
   2249  0c9f		       48		      pha
   2250  0ca0		       20 af 1f 	      jsr	VOUTCH	;echo echo echo
   2251  0ca3		       68		      pla
   2252  0ca4					      endif
   2253  0ca4		       85 52		      sta	R0
   2254  0ca6		       a9 00		      lda	#0
   2255  0ca8		       85 53		      sta	R0+1
   2256  0caa		       20 16 1d 	      jsr	pushR0
   2257  0cad							;
   2258  0cad		       4c c2 02 	      jmp	NextIL
   2259  0cb0							;===========================================jusilostintim======
   2260  0cb0							;Put a character to the terminal convert to
   2261  0cb0							;
   2262  0cb0		       20 a8 1d    iPUTCHAR   jsr	popR0
   2263  0cb3		       a5 52		      lda	R0
   2264  0cb5		       20 af 1f 	      jsr	VOUTCH
   2265  0cb8		       4c c2 02 	      jmp	NextIL
   2266  0cbb							;=====================================================
   2267  0cbb							; Put the number on the stack out as hex, suppress leading 0
   2268  0cbb				   iHexOut
   2269  0cbb		       20 a8 1d 	      jsr	popR0
   2270  0cbe		       a5 53		      lda	R0+1
   2271  0cc0		       f0 03		      beq	iHexSecondByte
   2272  0cc2		       20 15 14 	      jsr	OUTHEX
   2273  0cc5				   iHexSecondByte
   2274  0cc5		       a5 52		      lda	R0
   2275  0cc7		       20 15 14 	      jsr	OUTHEX
   2276  0cca		       4c c2 02 	      jmp	NextIL
   2277  0ccd							;
   2278  0ccd							;=====================================================
   2279  0ccd							; Replace TOS with its absolute value.
   2280  0ccd							;
   2281  0ccd		       20 a8 1d    iABS       jsr	popR0
   2282  0cd0		       a5 53		      lda	R0+1
   2283  0cd2		       10 10		      bpl	iABS_1	;already positive
   2284  0cd4		       49 ff		      eor	#$ff
   2285  0cd6		       85 53		      sta	R0+1
   2286  0cd8		       a5 52		      lda	R0
   2287  0cda		       49 ff		      eor	#$ff
   2288  0cdc		       85 52		      sta	R0
   2289  0cde		       e6 52		      inc	R0
   2290  0ce0		       d0 02		      bne	iABS_1
   2291  0ce2		       e6 53		      inc	R0+1
   2292  0ce4		       4c 40 07    iABS_1     jmp	pushR0nextIl
   2293  0ce7
   2294  0ce7							;
   2295  0ce7							;================================================================
   2296  0ce7							; The set of logical operators
   2297  0ce7				   iLogAnd
   2298  0ce7		       20 a8 1d 	      jsr	popR0
   2299  0cea		       20 c0 1d 	      jsr	popR1
   2300  0ced		       a5 52		      lda	R0
   2301  0cef		       25 54		      and	R1
   2302  0cf1		       85 52		      sta	R0
   2303  0cf3		       a5 53		      lda	R0+1
   2304  0cf5		       25 55		      and	R1+1
   2305  0cf7		       85 53		      sta	R0+1
   2306  0cf9		       4c 40 07 	      jmp	pushR0nextIl
   2307  0cfc				   iLogOr
   2308  0cfc		       20 a8 1d 	      jsr	popR0
   2309  0cff		       20 c0 1d 	      jsr	popR1
   2310  0d02		       a5 52		      lda	R0
   2311  0d04		       05 54		      ora	R1
   2312  0d06		       85 52		      sta	R0
   2313  0d08		       a5 53		      lda	R0+1
   2314  0d0a		       05 55		      ora	R1+1
   2315  0d0c		       85 53		      sta	R0+1
   2316  0d0e		       4c 40 07 	      jmp	pushR0nextIl
   2317  0d11				   iLogXor
   2318  0d11		       20 a8 1d 	      jsr	popR0
   2319  0d14		       20 c0 1d 	      jsr	popR1
   2320  0d17		       a5 52		      lda	R0
   2321  0d19		       45 54		      eor	R1
   2322  0d1b		       85 52		      sta	R0
   2323  0d1d		       a5 53		      lda	R0+1
   2324  0d1f		       45 55		      eor	R1+1
   2325  0d21		       85 53		      sta	R0+1
   2326  0d23		       4c 40 07 	      jmp	pushR0nextIl
   2327  0d26				   iLogNot
   2328  0d26		       20 a8 1d 	      jsr	popR0
   2329  0d29		       a5 52		      lda	R0
   2330  0d2b		       49 ff		      eor	#$FF
   2331  0d2d		       85 52		      sta	R0
   2332  0d2f		       a5 53		      lda	R0+1
   2333  0d31		       49 ff		      eor	#$FF
   2334  0d33		       85 53		      sta	R0+1
   2335  0d35		       4c 40 07 	      jmp	pushR0nextIl
   2336  0d38
   2337  0d38				   iTruth
   2338  0d38		       a9 ff		      lda	#$FF
   2339  0d3a		       85 52		      sta	R0
   2340  0d3c		       85 53		      sta	R0+1
   2341  0d3e		       4c 40 07 	      jmp	pushR0nextIl
   2342  0d41				   iFalse
   2343  0d41		       a9 00		      lda	#$00
   2344  0d43		       85 52		      sta	R0
   2345  0d45		       85 53		      sta	R0+1
   2346  0d47		       4c 40 07 	      jmp	pushR0nextIl
   2347  0d4a
   2348  0d4a							;================================================================
   2349  0d4a							;Set the IRQ service rtn line number
   2350  0d4a							;
   2351  0d4a		       78	   iSetIrq    sei		; disable the interupts
   2352  0d4b		       a9 00		      lda	#0	; Zero the Status flag
   2353  0d4d		       8d 0b 26 	      sta	IRQStatus
   2354  0d50		       20 a8 1d 	      jsr	popR0	; get the line number
   2355  0d53		       a5 52		      lda	R0
   2356  0d55		       05 53		      ora	R0+1
   2357  0d57		       f0 22		      beq	iSetExt	; if it is zero disable all
   2358  0d59		       a9 01		      lda	#GOSUB_RTN	; default push type
   2359  0d5b		       20 30 1d 	      jsr	pushLN	; Save the current line pointer
   2360  0d5e		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2361  0d60		       4c ec 0b 	      jmp	ErrStkOver	; Check if there was an error
   2362  0d63				   iSetIrqOk
   2363  0d63		       20 62 1b 	      jsr	findLine	; Find the IRQ func Line Pointer
   2364  0d66		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2365  0d68		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2366  0d6a		       8d 0e 26 	      sta	IRQEntry+1
   2367  0d6d		       a5 4f		      lda	CURPTR
   2368  0d6f		       8d 0d 26 	      sta	IRQEntry
   2369  0d72		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2370  0d74		       8d 0b 26 	      sta	IRQStatus
   2371  0d77		       20 59 1d 	      jsr	popLN	; Restore the old line number
   2372  0d7a		       58		      cli		; Enable the interupts
   2373  0d7b		       4c c2 02    iSetExt    jmp	NextIL
   2374  0d7e
   2375  0d7e		       20 59 1d    iSetIrqErr jsr	popLN
   2376  0d81		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2377  0d83		       a9 00		      lda	#0
   2378  0d85		       4c a7 06 	      jmp	iErr2
   2379  0d88							;
   2380  0d88		       20 a8 1d    iTRACEPROG jsr	popR0
   2381  0d8b		       a5 52		      lda	R0
   2382  0d8d		       85 40		      sta	ILTrace
   2383  0d8f		       4c c2 02 	      jmp	NextIL
   2384  0d92
   2385  0d92							;=====================================================
   2386  0d92							; Define start of non page zero data
   2387 U2f72 ????				      seg.u	TBData
   2388 U25c8					      org	PROGEND
   2389 U25c8							;=================================================================
   2390 U25c8							;
------- FILE compile.asm LEVEL 2 PASS 6
      0 U25c8					      include	"compile.asm"
      1  0d92					      Seg	Code
      2  0d92							;
      3  0d92							;=====================================================================
      4  0d92							; Scan the loaded program just before running and insert memory locations of each
      5  0d92							; line number branched to. goto gosub, gofn
      6  0d92							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  0d92				   Compile
      8  0d92		       a9 00		      lda	#0
      9  0d94		       85 52		      sta	R0	; keep track of how many errors we find
     10  0d96		       a5 5b		      lda	RunMode
     11  0d98		       48		      pha
     12  0d99		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  0d9b		       a5 4f		      lda	CURPTR
     14  0d9d		       48		      pha
     15  0d9e		       a5 50		      lda	CURPTR+1
     16  0da0		       48		      pha
     17  0da1		       a5 51		      lda	CUROFF
     18  0da3		       48		      pha
     19  0da4		       ad 68 2f 	      lda	ProgramStart
     20  0da7		       85 59		      sta	dpl
     21  0da9		       ad 69 2f 	      lda	ProgramStart+1
     22  0dac		       85 5a		      sta	dpl+1
     23  0dae
     24  0dae				   CompileLineStart
     25  0dae		       a5 59		      lda	dpl
     26  0db0		       cd 6a 2f 	      cmp	ProgramEnd
     27  0db3		       d0 07		      bne	CompileContinue
     28  0db5		       a5 5a		      lda	dpl+1
     29  0db7		       cd 6b 2f 	      cmp	ProgramEnd+1
     30  0dba		       f0 3f		      beq	CompileComplete
     31  0dbc
     32  0dbc				   CompileContinue
     33  0dbc		       a0 03		      ldy	#3	; first real character in the line
     34  0dbe
     35  0dbe				   CompileLoop
     36  0dbe		       b1 59		      lda	(dpl),y	; get the byte
     37  0dc0		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  0dc2		       c8		      iny		; Pass this byte
     39  0dc3		       c9 07		      cmp	#kGoto
     40  0dc5		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  0dc7		       c9 08		      cmp	#kGosub
     42  0dc9		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  0dcb		       c9 31		      cmp	#kGofn
     44  0dcd		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  0dcf		       c9 29		      cmp	#kTask
     46  0dd1		       f0 4c		      beq	CompileField
     47  0dd3		       c9 0a		      cmp	#kRem
     48  0dd5		       f0 12		      beq	CompileRem	; Skip until end of line
     49  0dd7		       c9 a0		      cmp	#tString
     50  0dd9		       f0 2f		      beq	CompileString
     51  0ddb		       c9 a1		      cmp	#tInteger
     52  0ddd		       f0 06		      beq	CompileInteger
     53  0ddf		       c9 a2		      cmp	#tByte
     54  0de1		       f0 03		      beq	CompileByte
     55  0de3		       d0 d9		      bne	CompileLoop	; Next character
     56  0de5
     57  0de5				   CompileInteger
     58  0de5		       c8		      iny
     59  0de6				   CompileByte
     60  0de6		       c8		      iny
     61  0de7		       d0 d5		      bne	CompileLoop
     62  0de9				   CompileRem
     63  0de9				   CompileEndOfLine
     64  0de9		       a0 00		      ldy	#0
     65  0deb		       b1 59		      lda	(dpl),y
     66  0ded		       18		      clc
     67  0dee		       65 59		      adc	dpl
     68  0df0		       85 59		      sta	dpl
     69  0df2		       a9 00		      lda	#0
     70  0df4		       65 5a		      adc	dpl+1
     71  0df6		       85 5a		      sta	dpl+1
     72  0df8
     73  0df8		       4c ae 0d 	      jmp	CompileLineStart
     74  0dfb
     75  0dfb				   CompileComplete
     76  0dfb		       68		      pla
     77  0dfc		       85 51		      sta	CUROFF
     78  0dfe		       68		      pla
     79  0dff		       85 50		      sta	CURPTR+1
     80  0e01		       68		      pla
     81  0e02		       85 4f		      sta	CURPTR
     82  0e04		       68		      pla
     83  0e05		       85 5b		      sta	RunMode
     84  0e07		       a5 52		      lda	R0	; returning the number of errors
     85  0e09		       60		      rts
     86  0e0a
     87  0e0a
     88  0e0a				   CompileString
     89  0e0a		       c8		      iny		; point past first "
     90  0e0b				   CompileStringLoop
     91  0e0b		       b1 59		      lda	(dpl),y
     92  0e0d		       f0 0d		      beq	CompileStrDone2
     93  0e0f		       c9 22		      cmp	#'"	; end of string
     94  0e11		       f0 08		      beq	CompileStrDone
     95  0e13		       c9 5c		      cmp	#'\	; escape character
     96  0e15		       d0 01		      bne	CompileStrNext
     97  0e17		       c8		      iny
     98  0e18				   CompileStrNext
     99  0e18		       c8		      iny		; Next character
    100  0e19		       d0 f0		      bne	CompileStringLoop	; test for end
    101  0e1b				   CompileStrDone
    102  0e1b		       c8		      iny
    103  0e1c				   CompileStrDone2
    104  0e1c		       4c be 0d 	      Jmp	CompileLoop
    105  0e1f							;
    106  0e1f							;===============================================================
    107  0e1f							; on entry y points to storage location y+2 points to line number
    108  0e1f							; on exit y points to line number type
    109  0e1f
    110  0e1f		       85 52	   CompileField sta	R0
    111  0e21		       98		      tya		; save the y pointer to store the memory value
    112  0e22		       48		      pha
    113  0e23		       c8		      iny		; Skip over the memory vector
    114  0e24		       c8		      iny
    115  0e25		       a5 52		      lda	R0
    116  0e27		       c9 29		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  0e29		       d0 07		      bne	CompNoBracket
    118  0e2b
    119  0e2b		       b1 59		      lda	(dpl),y	; Lets make sure it is a
    120  0e2d		       c9 e0		      cmp	#oLeftBracket
    121  0e2f		       d0 01		      bne	CompNoBracket	; in case of error
    122  0e31		       c8		      iny		; skip the bracket
    123  0e32
    124  0e32				   CompNoBracket
    125  0e32		       a9 00		      lda	#0	; In case the value is a byte
    126  0e34		       85 53		      sta	R0+1
    127  0e36
    128  0e36		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  0e38		       c9 a2		      cmp	#tByte
    130  0e3a		       f0 15		      beq	CompByteLoad
    131  0e3c		       c9 a1		      cmp	#tInteger
    132  0e3e		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  0e40		       68		      pla
    134  0e41		       4c be 0d 	      jmp	CompileLoop	; Ignore the saved stack
    135  0e44				   CompIntLoad
    136  0e44		       c8		      iny
    137  0e45		       b1 59		      lda	(dpl),y
    138  0e47		       85 52		      sta	R0
    139  0e49		       c8		      iny
    140  0e4a		       b1 59		      lda	(dpl),y
    141  0e4c		       85 53		      sta	R0+1
    142  0e4e		       4c 56 0e 	      jmp	CompFindLine
    143  0e51				   CompByteLoad
    144  0e51		       c8		      iny
    145  0e52		       b1 59		      lda	(dpl),y
    146  0e54		       85 52		      sta	R0
    147  0e56				   CompFindLine
    148  0e56		       20 62 1b 	      jsr	findLine
    149  0e59		       f0 1d		      beq	CompFoundLine
    150  0e5b		       e6 52		      inc	R0	; number of errors
    151  0e5d
    152  0e5d		       a5 59		      lda	dpl
    153  0e5f		       85 4f		      sta	CURPTR
    154  0e61		       a5 5a		      lda	dpl+1
    155  0e63		       85 50		      sta	CURPTR+1
    156  0e65		       84 51		      sty	CUROFF
    157  0e67
    158  0e67		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  0e69		       a9 00		      lda	#0
    160  0e6b
    161  0e6b		       20 51 06 	      jsr	DisplayError
    162  0e6e		       20 ca 14 	      jsr	PrintProgramLine
    163  0e71
    164  0e71		       68		      pla
    165  0e72		       a8		      tay
    166  0e73		       c8		      iny
    167  0e74		       c8		      iny
    168  0e75		       4c be 0d 	      jmp	CompileLoop
    169  0e78
    170  0e78				   CompFoundLine
    171  0e78		       68		      pla
    172  0e79		       a8		      tay
    173  0e7a		       a5 4f		      lda	CURPTR
    174  0e7c		       91 59		      sta	(dpl),y
    175  0e7e		       c8		      iny
    176  0e7f		       a5 50		      lda	CURPTR+1
    177  0e81		       91 59		      sta	(dpl),y
    178  0e83		       c8		      iny
    179  0e84		       4c be 0d 	      jmp	CompileLoop
    180  0e87
    181  0e87
    182  0e87
    183  0e87
    184  0e87
    185  0e87
    186  0e87
    187  0e87
    188  0e87
    189  0e87
    190  0e87
    191  0e87
    192  0e87
    193  0e87
    194  0e87
    195  0e87
    196  0e87
    197  0e87
    198  0e87
    199  0e87
    200  0e87
    201  0e87
    202  0e87
    203  0e87
    204  0e87
    205  0e87
    206  0e87
    207  0e87
    208  0e87
    209  0e87
    210  0e87
    211  0e87
    212  0e87
    213  0e87
    214  0e87
    215  0e87
    216  0e87
    217  0e87
    218  0e87
    219  0e87
    220  0e87
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  0e87					      include	"tokenizer.asm"
      1  0e87					      seg	Code
      2  0e87		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  0e87
      4  0e87							; Define the types of tokens found, and identifiers
      5  0e87		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0e87		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0e87		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0e87		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0e87
     10  0e87		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0e87		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0e87		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0e87
     14  0e87
     15  0e87		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0e87		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0e87		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0e87		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0e87							; Arrays of string are arrays of pointers 2 bytes
     20  0e87		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0e87		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0e87
     23  0e87		       3c 3e	   Operators  BYTE.b	"<>"
     24  0e89		       3c 3d		      BYTE.b	"<="
     25  0e8b		       3e 3d		      BYTE.b	">="
     26  0e8d		       3c 00		      BYTE.b	"<",0
     27  0e8f		       3d 00		      BYTE.b	"=",0
     28  0e91		       3e 00		      BYTE.b	">",0
     29  0e93		       2b 00		      BYTE.b	"+",0
     30  0e95		       2d 00		      BYTE.b	"-",0
     31  0e97		       2f 00		      BYTE.b	"/",0
     32  0e99		       25 00		      BYTE.b	"%",0
     33  0e9b		       2a 00		      BYTE.b	"*",0
     34  0e9d		       28 00		      BYTE.b	"(",0
     35  0e9f		       29 00		      BYTE.b	")",0
     36  0ea1		       2c 00		      BYTE.b	",",0
     37  0ea3		       3b 00		      BYTE.b	";",0
     38  0ea5		       5b 00		      BYTE.b	"[",0
     39  0ea7		       5d 00		      BYTE.b	"]",0
     40  0ea9		       3a 00		      BYTE.b	":",0
     41  0eab		       24 00		      BYTE.b	"$",0
     42  0ead		       21 00		      BYTE.b	"!",0
     43  0eaf		       3f 00		      BYTE.b	"?",0
     44  0eb1		       2e 00		      BYTE.b	".",0
     45  0eb3		       00 00		      BYTE.b	0,0
     46  0eb5
     47  0eb5		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     48  0ebb		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     49  0ec0		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     50  0ec6		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     51  0ecb
     52  0ecb		       00 0b	   oQuestion  equ	kPrint
     53  0ecb							;    2 is =
     54  0ecb							;    1 is <
     55  0ecb							;    3 is <=
     56  0ecb							;    5 is <>
     57  0ecb							;    4 is >
     58  0ecb							;    6 is >=
     59  0ecb		       00 f1	   oLess      equ	$F1
     60  0ecb		       00 f2	   oEqual     equ	$F2
     61  0ecb		       00 f3	   oLessEqual equ	$F3
     62  0ecb		       00 f4	   oGreater   equ	$F4
     63  0ecb		       00 f5	   oNotEqual  equ	$F5
     64  0ecb		       00 f6	   oGreaterEqual equ	$F6
     65  0ecb
     66  0ecb		       00 e0	   oLeftBracket equ	$E0
     67  0ecb		       00 e1	   oRightBracket equ	$E1
     68  0ecb		       00 e2	   oComma     equ	$E2
     69  0ecb		       00 e3	   oSemiColon equ	$E3
     70  0ecb		       00 e4	   oLeftSQBracket equ	$E4
     71  0ecb		       00 e5	   oRightSQBracket equ	$E5
     72  0ecb		       00 e6	   oColon     equ	$E6
     73  0ecb		       00 e7	   oDollar    equ	$E7
     74  0ecb		       00 e8	   oBang      equ	$E8
     75  0ecb		       00 e9	   oPeriod    equ	$E9
     76  0ecb
     77  0ecb
     78  0ecb		       00 ea	   oPlus      equ	$EA
     79  0ecb		       00 eb	   oMinus     equ	$EB
     80  0ecb		       00 ec	   oDivide    equ	$EC
     81  0ecb		       00 ed	   oModulo    equ	$ED
     82  0ecb		       00 ee	   oMultiply  equ	$EE
     83  0ecb
     84  0ecb		       00 ed	   oPercent   equ	oModulo
     85  0ecb
     86  0ecb		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     87  0ecb
     88  0ecb		       00 ff	   tError     equ	$FF	; Error should never happen
     89  0ecb							;============================================================================================
     90  0ecb							; Keyword and seperator values
     91  0ecb				   '
     92  0ecb		       00 01	   kBeginKey  equ	kLet
     93  0ecb							;
     94  0ecb		       00 01	   kLet       equ	1
     95  0ecb		       00 02	   kInc       equ	kLet+1
     96  0ecb		       00 03	   kDec       equ	kInc+1
     97  0ecb		       00 04	   kIreturn   equ	kDec+1
     98  0ecb		       00 05	   kIf	      equ	kIreturn+1
     99  0ecb		       00 06	   kThen      equ	kIf+1
    100  0ecb		       00 07	   kGoto      equ	kThen+1
    101  0ecb		       00 08	   kGosub     equ	kGoto+1
    102  0ecb		       00 09	   kReturn    equ	kGosub+1
    103  0ecb		       00 0a	   kRem       equ	kReturn+1
    104  0ecb		       00 0b	   kPrint     equ	kRem+1
    105  0ecb		       00 0c	   kTaske     equ	kPrint+1
    106  0ecb		       00 0d	   kTaskn     equ	kTaske+1
    107  0ecb		       00 0e	   kTaskw     equ	kTaskn+1
    108  0ecb		       00 0f	   kPoke      equ	kTaskw+1
    109  0ecb		       00 10	   kPutch     equ	kPoke+1
    110  0ecb		       00 11	   kCls       equ	kPutch+1
    111  0ecb		       00 12	   kInput     equ	kCls+1
    112  0ecb		       00 13	   kEnd       equ	kInput+1
    113  0ecb		       00 14	   kIrq       equ	kEnd+1
    114  0ecb		       00 15	   kKill      equ	kIrq+1
    115  0ecb		       00 16	   kList      equ	kKill+1
    116  0ecb		       00 17	   kRun       equ	kList+1
    117  0ecb		       00 18	   kNew       equ	kRun+1
    118  0ecb		       00 19	   kSlice     equ	kNew+1
    119  0ecb		       00 1a	   kTrace     equ	kSlice+1
    120  0ecb		       00 1b	   kExit      equ	kTrace+1
    121  0ecb		       00 1c	   kSave      equ	kExit+1
    122  0ecb		       00 1d	   kLoad      equ	kSave+1
    123  0ecb		       00 1e	   kErase     equ	kLoad+1
    124  0ecb		       00 1f	   kDir       equ	kErase+1
    125  0ecb							;
    126  0ecb							; End of actual key words
    127  0ecb							;
    128  0ecb		       00 1e	   kKeyCount  equ	kDir-kBeginKey
    129  0ecb							;
    130  0ecb							; Logical operators
    131  0ecb							;
    132  0ecb		       00 20	   kNot       equ	kDir+1
    133  0ecb		       00 21	   kOr	      equ	kNot+1
    134  0ecb		       00 22	   kXor       equ	kOr+1
    135  0ecb		       00 23	   kAnd       equ	kXor+1
    136  0ecb
    137  0ecb							; numeric functions
    138  0ecb							;
    139  0ecb		       00 24	   kBeginFunc equ	kTrue
    140  0ecb							;
    141  0ecb							; Truth operators
    142  0ecb							;
    143  0ecb		       00 24	   kTrue      equ	kAnd+1
    144  0ecb		       00 25	   kFalse     equ	kTrue+1
    145  0ecb							; Functions
    146  0ecb		       00 26	   kFree      equ	kFalse+1
    147  0ecb		       00 27	   kGetch     equ	kFree+1
    148  0ecb		       00 28	   kPeek      equ	kGetch+1
    149  0ecb		       00 29	   kTask      equ	kPeek+1
    150  0ecb		       00 2a	   kIpcc      equ	kTask+1
    151  0ecb		       00 2b	   kIpcs      equ	kIpcc+1
    152  0ecb		       00 2c	   kIpcr      equ	kIpcs+1
    153  0ecb		       00 2d	   kRnd       equ	kIpcr+1
    154  0ecb		       00 2e	   kStat      equ	kRnd+1
    155  0ecb		       00 2f	   kAbs       equ	kStat+1
    156  0ecb		       00 30	   kCall      equ	kAbs+1
    157  0ecb		       00 31	   kGofn      equ	kCall+1
    158  0ecb		       00 32	   kPid       equ	kGofn+1
    159  0ecb							;
    160  0ecb		       00 0f	   kFuncCount equ	((kPid - kBeginFunc) + 1)
    161  0ecb
    162  0ecb							;
    163  0ecb							; Keyword table contains 49 keywords
    164  0ecb				   KeyWordTable
      0  0ecb					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0ecb		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0ecf					      db	kInc,"inC"
      1  0ecf		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0ed3					      db	kDec,"deC"
      1  0ed3		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0ed7					      db	kIreturn,"ireturN"
      1  0ed7		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0edf					      db	kIf,"iF"
      1  0edf		       05 69 46 	      .byte.b	kIf,"iF"
      0  0ee2					      db	kThen,"theN"
      1  0ee2		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0ee7					      db	kGoto,"gotO"
      1  0ee7		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0eec					      db	kGosub,"gosuB"
      1  0eec		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0ef2					      db	kReturn,"returN"
      1  0ef2		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0ef9					      db	kRem,"reM"
      1  0ef9		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0efd					      db	kPrint,"prinT"
      1  0efd		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0f03					      db	kTaske,"taskE"
      1  0f03		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0f09					      db	kTaskn,"taskN"
      1  0f09		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0f0f					      db	kTaskw,"taskW"
      1  0f0f		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0f15					      db	kPoke,"pokE"
      1  0f15		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0f1a					      db	kPutch,"putcH"
      1  0f1a		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0f20					      db	kCls,"clS"
      1  0f20		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0f24					      db	kInput,"inpuT"
      1  0f24		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0f2a					      db	kEnd,"enD"
      1  0f2a		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0f2e					      db	kIrq,"irQ"
      1  0f2e		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0f32					      db	kKill,"kilL"
      1  0f32		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0f37					      db	kList,"lisT"
      1  0f37		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0f3c					      db	kRun,"ruN"
      1  0f3c		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0f40					      db	kNew,"neW"
      1  0f40		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0f44					      db	kSlice,"slicE"
      1  0f44		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0f4a					      db	kTrace,"tracE"
      1  0f4a		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0f50					      db	kExit,"exiT"
      1  0f50		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0f55					      db	kSave,"savE"
      1  0f55		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0f5a					      db	kLoad,"loaD"
      1  0f5a		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0f5f					      db	kErase,"erasE"
      1  0f5f		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0f65					      db	kDir,"diR"
      1  0f65		       1f 64 69 52	      .byte.b	kDir,"diR"
    196  0f69							;Short form for statements:
      0  0f69					      db	kIreturn,"ireT"
      1  0f69		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0f6e					      db	kReturn,"reT"
      1  0f6e		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  0f72					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  0f72		       0b 70 52 	      .byte.b	kPrint,"pR"
    200  0f75
    201  0f75							;Logical and truth operators
      0  0f75					      db	kNot,"noT"
      1  0f75		       20 6e 6f 54	      .byte.b	kNot,"noT"
      0  0f79					      db	kOr,"oR"
      1  0f79		       21 6f 52 	      .byte.b	kOr,"oR"
      0  0f7c					      db	kXor,"xoR"
      1  0f7c		       22 78 6f 52	      .byte.b	kXor,"xoR"
      0  0f80					      db	kAnd,"anD"
      1  0f80		       23 61 6e 44	      .byte.b	kAnd,"anD"
    206  0f84							; Truth values
      0  0f84					      db	kTrue,"truE"
      1  0f84		       24 74 72 75*	      .byte.b	kTrue,"truE"
      0  0f89					      db	kFalse,"falsE"
      1  0f89		       25 66 61 6c*	      .byte.b	kFalse,"falsE"
    209  0f8f
    210  0f8f							;functions returning values
    211  0f8f
      0  0f8f					      db	kFree,"freE"
      1  0f8f		       26 66 72 65*	      .byte.b	kFree,"freE"
      0  0f94					      db	kGetch,"getcH"
      1  0f94		       27 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0f9a					      db	kPeek,"peeK"
      1  0f9a		       28 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0f9f					      db	kTask,"tasK"
      1  0f9f		       29 74 61 73*	      .byte.b	kTask,"tasK"
      0  0fa4					      db	kIpcc,"ipcC"
      1  0fa4		       2a 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0fa9					      db	kIpcs,"ipcS"
      1  0fa9		       2b 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0fae					      db	kIpcr,"ipcR"
      1  0fae		       2c 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0fb3					      db	kRnd,"rnD"
      1  0fb3		       2d 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0fb7					      db	kStat,"staT"
      1  0fb7		       2e 73 74 61*	      .byte.b	kStat,"staT"
      0  0fbc					      db	kAbs,"abS"
      1  0fbc		       2f 61 62 53	      .byte.b	kAbs,"abS"
      0  0fc0					      db	kCall,"calL"
      1  0fc0		       30 63 61 6c*	      .byte.b	kCall,"calL"
      0  0fc5					      db	kGofn,"gofN"
      1  0fc5		       31 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0fca					      db	kPid,"piD"
      1  0fca		       32 70 69 44	      .byte.b	kPid,"piD"
      0  0fce					      db	0,0
      1  0fce		       00 00		      .byte.b	0,0
    226  0fd0
    227  0fd0		       0f d0	   KeyWordTableEnd equ	*
    228  0fd0		       01 05	   KeyWordTableLength equ	* - KeyWordTable
    229  0fd0		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    230  10d0		       00 00 00    printStorage ds	3
    231  10d3							;==================================================================================================================
    232  10d3							; Read accross the inputline and output to TOKENBUFFER
    233  10d3							; Format   byte      Description
    234  10d3							;	     0	      length of line 1-255
    235  10d3							;	    0-1       Line Number
    236  10d3							;	    Tokens and litteral values encoded into the line
    237  10d3							;
    238  10d3							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    239  10d3							;  if fails then test for keywords
    240  10d3							;  if fails then test for variables and arrays
    241  10d3							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    242  10d3
    243  10d3				   ParseInputLine
    244  10d3				  -	      if	DEBUGPARSER
    245  10d3				  -	      jsr	SetOutDebug
    246  10d3				  -	      jsr	DebugClearBuffer
    247  10d3					      endif
    248  10d3		       a5 51		      lda	CUROFF
    249  10d5		       48		      pha
    250  10d6		       8a		      txa
    251  10d7		       48		      pha
    252  10d8		       98		      tya
    253  10d9		       48		      pha
    254  10da		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    255  10dc		       20 c8 1b 	      jsr	getDecimal	; Check for a line number, none is ok too
    256  10df		       84 51		      sty	CUROFF
    257  10e1		       20 9f 12 	      jsr	R02TOKEN	; Move R0 to token buffer
    258  10e4
    259  10e4				   ParseInputLoop
    260  10e4		       a4 51		      ldy	CUROFF
    261  10e6		       20 58 1e 	      jsr	SkipSpaces	; Skip any spaces
    262  10e9		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    263  10eb		       b9 cb 2e 	      lda	LINBUF,y	; Check for end of line
    264  10ee		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    265  10f0
    266  10f0				   ParseForNumber
    267  10f0		       20 f3 11 	      jsr	ParseNumeric	; Check for a numeric value
    268  10f3		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    269  10f5
    270  10f5				   ParseForString
    271  10f5		       20 c9 11 	      jsr	ParseString	; Check for a string
    272  10f8		       90 ea		      bcc	ParseInputLoop	; It was a string
    273  10fa
    274  10fa				   ParseForOp
    275  10fa		       20 31 12 	      jsr	ParseForOperator	; Check for operator or punctuation
    276  10fd		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    277  10ff
    278  10ff				   ParseForKey
    279  10ff		       20 26 11 	      jsr	ParseLookupKey	; Check for a keyword value
    280  1102		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    281  1104
    282  1104				   ParseForVar
    283  1104		       20 68 12 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    284  1107		       90 db		      bcc	ParseInputLoop
    285  1109
    286  1109				   ParseKeepChar		; if it does not parse just keep it safe
    287  1109		       b9 cb 2e 	      lda	LINBUF,y
    288  110c		       9d d0 0f 	      sta	TOKENBUFFER,x
    289  110f		       e8		      inx
    290  1110		       c8		      iny
    291  1111		       84 51		      sty	CUROFF
    292  1113		       d0 cf		      bne	ParseInputLoop
    293  1115
    294  1115				   ParseComplete
    295  1115		       a9 00		      lda	#0
    296  1117		       9d d0 0f 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    297  111a		       e8		      inx
    298  111b		       8e d0 0f 	      stx	TOKENBUFFER	; Place size including null into buffer start
    299  111e
    300  111e		       68		      pla
    301  111f		       a8		      tay
    302  1120		       68		      pla
    303  1121		       aa		      tax
    304  1122		       68		      pla
    305  1123		       85 51		      sta	CUROFF
    306  1125
    307  1125				  -	      if	DEBUGPARSER
    308  1125				  -
    309  1125				  -	      jsr	printTokenBuffer
    310  1125				  -			;jsr	  DebugPrintProgramLine
    311  1125				  -	      jsr	SetOutDebugEnd
    312  1125				  -
    313  1125					      endif
    314  1125		       60		      rts
    315  1126
    316  1126							;==================================================================================================================
    317  1126							; Look at curptr, curpos and check for a valid KeyWord
    318  1126							; A contains the index value. c is clear
    319  1126							;		     not found c set  A undefined
    320  1126							; X is prerserved
    321  1126							;
    322  1126				   ParseLookupKey
    323  1126		       86 58		      stx	R2
    324  1128		       a0 00		      ldy	#0
    325  112a		       a9 cb		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    326  112c		       85 54		      sta	R1
    327  112e		       a9 0e		      lda	#KeyWordTable>>8
    328  1130		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    329  1132		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    330  1134		       85 52		      sta	R0	; Save until next keyword
    331  1136		       c8		      iny		; Point to first character of keyword
    332  1137		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    333  1139
    334  1139				  -	      if	DEBUGPARSER
    335  1139				  -			;    jsr DebugKeyword
    336  1139					      endif
    337  1139
    338  1139				   ParseLookupLoop
    339  1139		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    340  113b		       29 df		      and	#%11011111	; Force Keyword to upper case
    341  113d		       dd cb 2e 	      cmp	LINBUF,x	; Check the input buffer
    342  1140		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    343  1142		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    344  1144		       dd cb 2e 	      cmp	LINBUF,x	; Compare value to upercase
    345  1147		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    346  1149
    347  1149				   ParseNextLetter
    348  1149		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    349  114b		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    350  114d		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    351  114f		       e8		      inx		; Point to next char in the input buffer
    352  1150		       c8		      iny		; Point to the next character in the Keyword table
    353  1151		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    354  1153		       dd cb 2e 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    355  1156		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    356  1158		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    357  115a
    358  115a				   ParseKeyFound
    359  115a		       a5 52		      lda	R0	; get the keyword index
    360  115c
    361  115c				   ParseKeyDone
    362  115c		       e8		      inx		; point past the last character
    363  115d		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    364  115f		       a6 58		      ldx	R2	; Restore the original x pointer
    365  1161		       9d d0 0f 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    366  1164		       e8		      inx		; Point to next position in the output buffer
    367  1165		       86 58		      stx	R2	; Save next position in buffer
    368  1167		       c9 0a		      cmp	#kRem	; remark statement
    369  1169		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    370  116b		       c9 07		      cmp	#kGoto
    371  116d		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    372  116f		       c9 08		      cmp	#kGosub
    373  1171		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    374  1173		       c9 31		      cmp	#kGofn
    375  1175		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    376  1177		       c9 29		      cmp	#kTask
    377  1179		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    378  117b
    379  117b		       18		      clc		; C flag clear, we found it
    380  117c		       60		      rts
    381  117d
    382  117d							; Move forward to the next entry in table
    383  117d				   ParseNextEntry
    384  117d		       b1 54		      lda	(R1),y	; Get the next character in the token
    385  117f		       29 20		      and	#%00100000	; Is it the last character
    386  1181		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    387  1183		       c8		      iny		; Point to next char in the entry
    388  1184		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    389  1186
    390  1186				   ParseEndOfEntry
    391  1186		       c8		      iny		; Point to the byte after the last character
    392  1187		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    393  1188		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    394  1189		       65 54		      adc	R1
    395  118b		       85 54		      sta	R1
    396  118d		       a5 55		      lda	R1+1
    397  118f		       69 00		      adc	#0
    398  1191		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    399  1193		       a0 00		      ldy	#0	; Reset the index back to zero
    400  1195		       b1 54		      lda	(R1),y	; get keyword value
    401  1197		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    402  1199		       85 52		      sta	R0	; save the next token value
    403  119b		       c8		      iny		; Inc past token value
    404  119c
    405  119c				  -	      if	DEBUGPARSER
    406  119c				  -			;    jsr DebugKeyword
    407  119c					      endif
    408  119c		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    409  119e		       4c 39 11 	      jmp	ParseLookupLoop	; branch back for next key word
    410  11a1
    411  11a1				   ParseNoneFound
    412  11a1		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    413  11a3		       38		      sec		; c clear, not found
    414  11a4		       60		      rts
    415  11a5
    416  11a5							;===============================================================================
    417  11a5							; Move everything from current position until the end of line into the token buffer
    418  11a5							;
    419  11a5		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    420  11a7		       a6 58		      ldx	R2	; where to place in the buffer
    421  11a9				   ParseMoveLoop
    422  11a9		       b9 cb 2e 	      lda	LINBUF,y	; get the next byte
    423  11ac		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    424  11ae		       9d d0 0f 	      sta	TOKENBUFFER,x	; save the byte
    425  11b1		       c8		      iny
    426  11b2		       e8		      inx
    427  11b3		       d0 f4		      bne	ParseMoveLoop
    428  11b5				   ParseMoveDone
    429  11b5		       84 51		      sty	CUROFF
    430  11b7		       18		      clc
    431  11b8		       60		      rts
    432  11b9							;================================================================================================
    433  11b9							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    434  11b9							; transfer to a memory address
    435  11b9				   ParseHandleBranches
    436  11b9		       a6 58		      ldx	R2
    437  11bb		       a9 00		      lda	#0
    438  11bd		       9d d0 0f 	      sta	TOKENBUFFER,x
    439  11c0		       e8		      inx
    440  11c1		       9d d0 0f 	      sta	TOKENBUFFER,x
    441  11c4		       e8		      inx
    442  11c5		       86 58		      stx	R2
    443  11c7		       18		      clc
    444  11c8		       60		      rts
    445  11c9
    446  11c9							;=========================================================================================================
    447  11c9							;ParseString Parse a quotes string
    448  11c9							; on input X = outbuf position
    449  11c9							; y = inbuf position
    450  11c9							; Copies string to output buffer, updates x and y
    451  11c9				   ParseString
    452  11c9		       a4 51		      ldy	CUROFF
    453  11cb		       a9 a0		      lda	#tString
    454  11cd		       9d d0 0f 	      sta	TOKENBUFFER,X
    455  11d0		       b9 cb 2e 	      lda	LINBUF,y
    456  11d3		       c9 22		      cmp	#'"
    457  11d5		       d0 1a		      bne	ParseStringInvalid
    458  11d7		       e8		      inx
    459  11d8		       9d d0 0f 	      sta	TOKENBUFFER,x
    460  11db		       e8		      inx
    461  11dc		       c8		      iny
    462  11dd
    463  11dd				   ParseStringLoop
    464  11dd		       b9 cb 2e 	      lda	LINBUF,y
    465  11e0		       9d d0 0f 	      sta	TOKENBUFFER,x
    466  11e3		       c9 22		      cmp	#'"
    467  11e5		       f0 04		      beq	ParseStringDone
    468  11e7		       c8		      iny
    469  11e8		       e8		      inx
    470  11e9		       d0 f2		      bne	ParseStringLoop
    471  11eb
    472  11eb				   ParseStringDone
    473  11eb		       e8		      inx
    474  11ec		       c8		      iny
    475  11ed		       84 51		      sty	CUROFF
    476  11ef		       18		      clc
    477  11f0		       60		      rts
    478  11f1
    479  11f1				   ParseStringInvalid
    480  11f1		       38		      sec
    481  11f2		       60		      rts
    482  11f3
    483  11f3							;=========================================================================================================
    484  11f3							; Get numeric values and return value in RO and type in a
    485  11f3							;
    486  11f3				   ParseNumeric
    487  11f3		       a4 51		      ldy	CUROFF
    488  11f5		       b9 cb 2e 	      lda	LINBUF,y
    489  11f8		       c9 30		      cmp	#'0
    490  11fa		       90 33		      bcc	ParseNumInvalid
    491  11fc		       c9 3a		      cmp	#'9+1
    492  11fe		       b0 2f		      bcs	ParseNumInvalid
    493  1200		       86 58		      stx	R2
    494  1202		       20 c8 1b 	      jsr	getDecimal
    495  1205		       a6 58		      ldx	R2
    496  1207		       84 51		      sty	CUROFF
    497  1209		       a5 53		      lda	R0+1
    498  120b		       f0 14		      beq	ParseByteValue
    499  120d
    500  120d				   ParseIntegerValue
    501  120d		       a9 a1		      lda	#tInteger
    502  120f		       9d d0 0f 	      sta	TOKENBUFFER,x
    503  1212		       e8		      inx
    504  1213		       a5 52		      lda	R0
    505  1215		       9d d0 0f 	      sta	TOKENBUFFER,x
    506  1218		       e8		      inx
    507  1219		       a5 53		      lda	R0+1
    508  121b		       9d d0 0f 	      sta	TOKENBUFFER,X
    509  121e		       e8		      inx
    510  121f		       18		      clc
    511  1220		       60		      rts
    512  1221
    513  1221				   ParseByteValue
    514  1221		       a9 a2		      lda	#tByte
    515  1223		       9d d0 0f 	      sta	TOKENBUFFER,x
    516  1226		       e8		      inx
    517  1227		       a5 52		      lda	R0
    518  1229		       9d d0 0f 	      sta	TOKENBUFFER,x
    519  122c		       e8		      inx
    520  122d		       18		      clc
    521  122e		       60		      rts
    522  122f
    523  122f				   ParseNumInvalid		;Not a valid Numeric
    524  122f		       38		      sec
    525  1230		       60		      rts
    526  1231
    527  1231							;=========================================================================================================
    528  1231							;Parse for operators and seperators
    529  1231							; on exit the A has the oper code, c is clear
    530  1231							;		 not found then c is set
    531  1231							;	x is preserved
    532  1231							;
    533  1231				   ParseForOperator
    534  1231		       86 58		      stx	R2
    535  1233		       a4 51		      ldy	CUROFF
    536  1235		       a2 00		      ldx	#0
    537  1237				  -	      if	DEBUGPARSER
    538  1237				  -			;	jsr    DebugPrintOP
    539  1237					      endif
    540  1237
    541  1237				   ParseOpLoop
    542  1237		       bd 87 0e 	      lda	Operators,x	; First byte of operator
    543  123a		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    544  123c
    545  123c		       d9 cb 2e 	      cmp	LINBUF,y	; Check the first byte
    546  123f		       d0 1c		      bne	ParseOpNext
    547  1241
    548  1241		       c8		      iny
    549  1242
    550  1242		       bd 88 0e 	      lda	Operators+1,x
    551  1245		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    552  1247
    553  1247		       d9 cb 2e 	      cmp	LINBUF,y
    554  124a		       d0 11		      bne	ParseOpNext
    555  124c
    556  124c				   ParseOpFound
    557  124c		       c8		      iny
    558  124d
    559  124d				   ParseOpFoundSingle
    560  124d		       84 51		      sty	CUROFF
    561  124f
    562  124f		       8a		      txa
    563  1250		       4a		      lsr
    564  1251		       aa		      tax
    565  1252		       bd b5 0e 	      lda	OperValues,x
    566  1255		       a6 58		      ldx	R2
    567  1257		       9d d0 0f 	      sta	TOKENBUFFER,x
    568  125a		       e8		      inx
    569  125b		       18		      clc
    570  125c		       60		      rts
    571  125d
    572  125d				   ParseOpNext
    573  125d		       e8		      inx
    574  125e		       e8		      inx
    575  125f
    576  125f				  -	      if	DEBUGPARSER
    577  125f				  -			;	 jsr	DebugPrintOP
    578  125f					      endif
    579  125f		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    580  1261		       4c 37 12 	      jmp	ParseOpLoop
    581  1264
    582  1264				   ParseOpNotFound
    583  1264		       a6 58		      ldx	R2
    584  1266		       38		      sec
    585  1267		       60		      rts
    586  1268							;=========================================================================================================
    587  1268				  -	      if	DEBUGPARSER
    588  1268				  -			;Print the text of a keyword
    589  1268				  -			;Input R1    = offset into table
    590  1268				  -DebugKeyword
    591  1268				  -	      tya
    592  1268				  -	      pha
    593  1268				  -	      ldy	#1
    594  1268				  -DebugKeyLoop
    595  1268				  -	      lda	(R1),y
    596  1268				  -	      jsr	VOUTCH
    597  1268				  -	      and	#%00100000
    598  1268				  -	      beq	DebugKeyDone
    599  1268				  -	      iny
    600  1268				  -	      bne	DebugKeyLoop
    601  1268				  -
    602  1268				  -DebugKeyDone
    603  1268				  -	      jsr	CRLF
    604  1268				  -	      pla
    605  1268				  -	      tay
    606  1268				  -	      rts
    607  1268				  -			;========================================
    608  1268				  -DebugPrintOP
    609  1268				  -	      pha
    610  1268				  -	      lda	Operators,x
    611  1268				  -	      jsr	VOUTCH
    612  1268				  -	      lda	Operators+1,x
    613  1268				  -	      beq	DbgPrtOpDone
    614  1268				  -	      jsr	VOUTCH
    615  1268				  -
    616  1268				  -DbgPrtOpDone
    617  1268				  -	      jsr	CRLF
    618  1268				  -	      pla
    619  1268				  -	      rts
    620  1268				  -			;=======================================
    621  1268				  -DebugClearBuffer
    622  1268				  -	      txa
    623  1268				  -	      pha
    624  1268				  -	      ldx	#$FF
    625  1268				  -	      lda	#0
    626  1268				  -DebugClrLoop
    627  1268				  -	      sta	TOKENBUFFER,x
    628  1268				  -	      dex
    629  1268				  -	      bne	DebugClrLoop
    630  1268				  -	      sta	TOKENBUFFER,x
    631  1268				  -	      pla
    632  1268				  -	      tax
    633  1268				  -	      rts
    634  1268				  -
    635  1268				  -			;=====================================================
    636  1268				  -			; Print the parser buffer as hex values
    637  1268				  -printTokenBuffer
    638  1268				  -	      stx	printStorage
    639  1268				  -	      sty	printStorage+1
    640  1268				  -	      sta	printStorage+2
    641  1268				  -
    642  1268				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    643  1268				  -	      inx		; we want to show the last zero byte
    644  1268				  -	      ldy	#0
    645  1268				  -
    646  1268				  -printHexLoop
    647  1268				  -	      lda	TOKENBUFFER,y	; get the character
    648  1268				  -	      jsr	HexToOut	; print it
    649  1268				  -	      lda	#$20
    650  1268				  -	      jsr	VOUTCH
    651  1268				  -	      iny
    652  1268				  -	      dex
    653  1268				  -	      cpx	#0
    654  1268				  -	      bne	printHexLoop
    655  1268				  -	      jsr	CRLF
    656  1268				  -
    657  1268				  -	      ldy	printStorage+1
    658  1268				  -	      ldx	printStorage
    659  1268				  -	      lda	printStorage+2
    660  1268				  -printHexDone
    661  1268				  -	      clc
    662  1268				  -	      rts
    663  1268					      endif
    664  1268
    665  1268
    666  1268							;=========================================================================================================
    667  1268							; Parse for variables A-Z @, ^  x!x x[op]
    668  1268				   ParseForVariable
    669  1268		       a4 51		      ldy	CUROFF
    670  126a		       b9 cb 2e 	      lda	LINBUF,y
    671  126d		       c9 5e		      cmp	#'^	; is it an exit code
    672  126f		       d0 04		      bne	ParseVarMem
    673  1271		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    674  1273		       d0 1f		      bne	ParseVarSpecial
    675  1275
    676  1275				   ParseVarMem
    677  1275		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    678  1277		       d0 04		      bne	ParseVarStack
    679  1279		       a9 9d		      lda	#tVat
    680  127b		       d0 17		      bne	ParseVarSpecial
    681  127d
    682  127d				   ParseVarStack
    683  127d		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    684  127f		       d0 04		      bne	ParseVarLetters
    685  1281		       a9 9c		      lda	#tVhash
    686  1283		       d0 0f		      bne	ParseVarSpecial
    687  1285
    688  1285				   ParseVarLetters
    689  1285		       29 df		      and	#%11011111	; Force upper case
    690  1287		       c9 41		      cmp	#'A
    691  1289		       90 12		      bcc	ParseVarInvalid
    692  128b		       c9 5b		      cmp	#'Z+1
    693  128d		       b0 0e		      bcs	ParseVarInvalid
    694  128f							;
    695  128f							; The condition is true, so convert to an index, push
    696  128f							; it onto the stack and continue running.
    697  128f							;
    698  128f		       38		      sec
    699  1290		       e9 41		      sbc	#'A	;index is zero based
    700  1292		       09 80		      ora	#$80
    701  1294
    702  1294				   ParseVarSpecial
    703  1294		       9d d0 0f 	      sta	TOKENBUFFER,x
    704  1297		       e8		      inx
    705  1298		       c8		      iny
    706  1299		       84 51		      sty	CUROFF
    707  129b		       18		      clc
    708  129c		       60		      rts
    709  129d
    710  129d				   ParseVarInvalid
    711  129d		       38		      sec
    712  129e		       60		      rts
    713  129f
    714  129f
    715  129f							;=========================================================================================================
    716  129f							; Transfer R0 to the TOKENBUFFER
    717  129f							;
    718  129f				   R02TOKEN
    719  129f		       a5 52		      lda	R0
    720  12a1		       9d d0 0f 	      sta	TOKENBUFFER,x
    721  12a4		       e8		      inx
    722  12a5		       a5 53		      lda	R0+1
    723  12a7		       9d d0 0f 	      sta	TOKENBUFFER,x
    724  12aa		       e8		      inx
    725  12ab		       18		      clc
    726  12ac		       60		      rts
    727  12ad							;=========================================================================
    728  12ad							; Transfer word in Token Buffer to R0
    729  12ad				   TOKEN2R0
    730  12ad		       b9 d0 0f 	      lda	TOKENBUFFER,y
    731  12b0		       85 52		      sta	R0
    732  12b2		       c8		      iny
    733  12b3		       ca		      dex
    734  12b4		       b9 d0 0f 	      lda	TOKENBUFFER,y
    735  12b7		       c8		      iny
    736  12b8		       ca		      dex
    737  12b9		       85 53		      sta	R0+1
    738  12bb		       60		      rts
    739  12bc							;==========================================================================
    740  12bc							; Transfer	Display Buffer position to R0
    741  12bc							;
    742  12bc				   DPL2R0
    743  12bc		       b1 59		      lda	(dpl),y
    744  12be		       85 52		      sta	R0
    745  12c0		       c8		      iny
    746  12c1		       ca		      dex
    747  12c2		       b1 59		      lda	(dpl),y
    748  12c4		       c8		      iny
    749  12c5		       ca		      dex
    750  12c6		       85 53		      sta	R0+1
    751  12c8		       60		      rts
    752  12c9
    753  12c9
    754  12c9							;=========================================================================
    755  12c9							; Read an IL byte lookit up in the table, of words
    756  12c9							; set the next ilpc to point to that address
    757  12c9							; if not found then do ussual filter stuff
    758  12c9							; ongoto ilvectortable, not found address
    759  12c9		       20 19 1b    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    760  12cc		       86 52		      stx	R0
    761  12ce		       85 53		      sta	R0+1
    762  12d0
    763  12d0		       a4 51		      ldy	CUROFF
    764  12d2		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    765  12d4		       a0 00		      ldy	#0
    766  12d6		       38		      sec
    767  12d7		       f1 52		      sbc	(R0),y	; Subract the base value
    768  12d9		       c8		      iny
    769  12da		       d1 52		      cmp	(R0),y	; Check if we are in range
    770  12dc		       b0 12		      bcs	iOnGotoInvalid
    771  12de		       e6 51		      inc	CUROFF	; Save the offset
    772  12e0
    773  12e0		       0a		      asl
    774  12e1		       a8		      tay		; Turn into vector
    775  12e2		       c8		      iny		; Inc must include the table base and entry count
    776  12e3		       c8		      iny
    777  12e4
    778  12e4		       b1 52		      lda	(R0),y
    779  12e6		       85 43		      sta	ILPC
    780  12e8		       c8		      iny
    781  12e9		       b1 52		      lda	(R0),y
    782  12eb		       85 44		      sta	ILPC+1
    783  12ed		       4c c2 02 	      jmp	NextIL
    784  12f0
    785  12f0				   iOnGotoInvalid
    786  12f0		       20 19 1b 	      jsr	getILWord
    787  12f3		       86 43		      stx	ILPC
    788  12f5		       85 44		      sta	ILPC+1
    789  12f7		       4c c2 02 	      jmp	NextIL
    790  12fa							;
    791  12fa							;==========================================================================================
    792  12fa							; Test the token for relop and push the value onto the stack if true
    793  12fa							;
    794  12fa				   iTSTRELOP
    795  12fa		       20 1d 1b 	      jsr	getILByte
    796  12fd		       8d 64 2f 	      sta	offset
    797  1300
    798  1300		       a4 51		      ldy	CUROFF
    799  1302		       b1 4f		      lda	(CURPTR),y
    800  1304		       48		      pha
    801  1305		       29 f0		      and	#$F0
    802  1307		       c9 f0		      cmp	#$F0
    803  1309		       d0 12		      bne	iTSTRELOPNOT
    804  130b		       68		      pla
    805  130c		       29 0f		      and	#$0F	; get the actual value
    806  130e		       85 52		      sta	R0	; save it for later
    807  1310		       a9 00		      lda	#0
    808  1312		       85 53		      sta	R0+1
    809  1314		       20 16 1d 	      jsr	pushR0
    810  1317		       c8		      iny
    811  1318		       84 51		      sty	CUROFF	; save the y pointer
    812  131a		       4c c2 02 	      jmp	NextIL
    813  131d
    814  131d				   iTSTRELOPNOT
    815  131d		       68		      pla
    816  131e		       4c 9a 0b 	      jmp	tstBranch
    817  1321
    818  1321							;
    819  1321							;===================================================================================================
    820  1321							; Test the token and following info for precompiled address information
    821  1321							; skip it if zero, transfer and skip next integer value if not zero
    822  1321							; used by both gosub, goto and gofN
    823  1321							;
    824  1321				   iTSTBRANCH
    825  1321		       20 1d 1b 	      jsr	getILByte	; Get jump address if vector is valid
    826  1324		       8d 64 2f 	      sta	offset	; Mark offset for later if vector found
    827  1327		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    828  1329		       88		      dey		; point back to the type of branch
    829  132a		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    830  132c		       48		      pha		; Save till needed
    831  132d		       c8		      iny		; back to memory vectors
    832  132e				   ITSTBRANCHCont
    833  132e		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    834  1330		       85 52		      sta	R0	; R0 will contain mem pointer of present
    835  1332		       c8		      iny		; Point to next byte of mem vector
    836  1333		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    837  1335		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    838  1337		       c8		      iny		; Point to the byte past memory vector
    839  1338		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    840  133a
    841  133a		       05 52		      ora	R0	; Get the second byte of the mem
    842  133c		       f0 21		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    843  133e		       68		      pla
    844  133f		       c9 29		      cmp	#kTask	; Task defied with Task() so bypass the first bracket
    845  1341		       d0 07		      bne	iTSTBRANCHCont
    846  1343		       b1 4f		      lda	(CURPTR),y
    847  1345		       c9 e0		      cmp	#oLeftBracket
    848  1347		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    849  1349		       c8		      iny		; Increment past the bracket
    850  134a				   iTSTBRANCHCont
    851  134a		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    852  134c		       c9 a2		      cmp	#tByte	; A byte value is valid
    853  134e		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    854  1350		       c9 a1		      cmp	#tInteger	; An integer value is valid
    855  1352		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    856  1354		       c8		      iny		; skip type indicator for
    857  1355				   ITSTBRANCHBYTE
    858  1355		       c8		      iny		; skip first byte of value line number
    859  1356		       c8		      iny		; Skip second byte of line number
    860  1357
    861  1357				   iTSTBRANCHVALID
    862  1357		       84 51		      sty	CUROFF
    863  1359		       20 16 1d 	      jsr	pushR0	; place transfer address on top of stack
    864  135c		       4c 9a 0b 	      jmp	tstBranch
    865  135f
    866  135f				   iTSTBRANCHNoCompile
    867  135f		       68		      pla
    868  1360				   iTSTBRANCHErr
    869  1360		       4c c2 02 	      jmp	NextIL
    870  1363
    871  1363
    872  1363
    873  1363
    874  1363
    875  1363
    876  1363
    877  1363
    878  1363
    879  1363
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  1363					      include	"print.asm"
      1  1363					      Seg	Code
      2  1363							;---------------------------
      3  1363							; Print 24-bit decimal number or  16bit unsigned
      4  1363							; ---------------------------
      5  1363							; On entry, R0=number to print
      6  1363							;	     Defaults to pad=0 , y=21 default
      7  1363							;	     R2 = 1 unsigned 16 bit
      8  1363							;	     R2 = 0 Signed   16 bit
      9  1363
     10  1363							; On entry at PrintDecPadded:
     11  1363							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  1363
     13  1363							; On exit,  A,X,Y,num,pad corrupted
     14  1363							; Size      129 bytes, Table 24 bytes	--- total 153
     15  1363							; -----------------------------------------------------------------
     16  1363
     17  1363				   PrintDecimal
     18  1363		       8a		      TXA
     19  1364		       48		      pha
     20  1365		       98		      tya
     21  1366		       48		      pha
     22  1367		       a9 00		      lda	#0
     23  1369		       8d fc 13 	      sta	pad
     24  136c		       a0 15		      LDY	#21	; Offset to powers of ten
     25  136e		       4c 74 13 	      JMP	PrintDo
     26  1371
     27  1371				   PrintDecPadded
     28  1371		       8e fc 13 	      stx	pad
     29  1374
     30  1374				   PrintDo
     31  1374		       a9 00		      lda	#0
     32  1376		       85 54		      sta	R1
     33  1378
     34  1378		       a5 58		      lda	R2
     35  137a		       d0 29		      bne	PrintPos
     36  137c
     37  137c		       a5 53		      lda	R0+1	;MSB has sign
     38  137e		       10 25		      bpl	PrintPos	;it's a positive number;
     39  1380
     40  1380
     41  1380							; Negative numbers need more work.  Invert all the bits,
     42  1380							; then add one.
     43  1380
     44  1380		       a9 2d		      lda	#'-
     45  1382		       20 af 1f 	      jsr	VOUTCH	;print the negative sign
     46  1385
     47  1385		       a9 ff		      lda	#$FF
     48  1387		       85 54		      sta	R1
     49  1389		       a5 52		      lda	R0	;invert bits
     50  138b		       49 ff		      eor	#$ff
     51  138d		       85 52		      sta	R0
     52  138f		       a5 53		      lda	R0+1
     53  1391		       49 ff		      eor	#$ff
     54  1393		       85 53		      sta	R0+1
     55  1395		       a5 54		      lda	R1
     56  1397		       49 ff		      eor	#$ff
     57  1399		       85 54		      sta	R1
     58  139b		       e6 52		      inc	R0	;add one
     59  139d		       d0 06		      bne	PrintPos
     60  139f		       e6 53		      inc	R0+1
     61  13a1		       d0 02		      bne	PrintPos
     62  13a3		       e6 54		      inc	R1
     63  13a5				   PrintPos
     64  13a5
     65  13a5				   PrDec24Lp1
     66  13a5		       a2 ff		      LDX	#$FF
     67  13a7		       38		      SEC		; Start with digit=-1
     68  13a8				   PrDec24Lp2
     69  13a8		       a5 52		      LDA	R0+0
     70  13aa		       f9 fd 13 	      SBC	PrDec24Tens+0,Y
     71  13ad		       85 52		      STA	R0+0	; Subtract current tens
     72  13af		       a5 53		      LDA	R0+1
     73  13b1		       f9 fe 13 	      SBC	PrDec24Tens+1,Y
     74  13b4		       85 53		      STA	R0+1
     75  13b6		       a5 54		      LDA	R0+2
     76  13b8		       f9 ff 13 	      SBC	PrDec24Tens+2,Y
     77  13bb		       85 54		      STA	R0+2
     78  13bd		       e8		      INX
     79  13be		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  13c0		       a5 52		      LDA	R0+0
     81  13c2		       79 fd 13 	      ADC	PrDec24Tens+0,Y
     82  13c5		       85 52		      STA	R0+0	; Add current tens back in
     83  13c7		       a5 53		      LDA	R0+1
     84  13c9		       79 fe 13 	      ADC	PrDec24Tens+1,Y
     85  13cc		       85 53		      STA	R0+1
     86  13ce		       a5 54		      LDA	R0+2
     87  13d0		       79 ff 13 	      ADC	PrDec24Tens+2,Y
     88  13d3		       85 54		      STA	R0+2
     89  13d5		       8a		      TXA
     90  13d6		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  13d8		       ad fc 13 	      LDA	pad
     92  13db		       d0 09		      BNE	PrDec24Print
     93  13dd		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  13df				   PrDec24Digit
     95  13df		       a2 30		      LDX	#'0
     96  13e1		       8e fc 13 	      STX	pad	; No more zero padding
     97  13e4		       09 30		      ORA	#'0	; Print this digit
     98  13e6				   PrDec24Print
     99  13e6		       20 af 1f 	      JSR	VOUTCH
    100  13e9				   PrDec24Next
    101  13e9		       88		      DEY
    102  13ea		       88		      DEY
    103  13eb		       88		      DEY
    104  13ec		       f0 07		      beq	PrDec24LastDigit
    105  13ee		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  13f0		       68		      pla
    107  13f1		       a8		      tay
    108  13f2		       68		      pla
    109  13f3		       aa		      tax
    110  13f4		       60		      RTS
    111  13f5				   PrDec24LastDigit
    112  13f5		       a2 30		      LDX	#'0
    113  13f7		       8e fc 13 	      STX	pad	; No more zero padding
    114  13fa		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  13fc
      0  13fc				   pad	      db	0
      1  13fc		       00		      .byte.b	0
    117  13fd
    118  13fd				   PrDec24Tens
      0  13fd					      dw	1
      1  13fd		       01 00		      .word.w	1
      0  13ff					      db	(1 / 65536)
      1  13ff		       00		      .byte.b	(1 / 65536)
      0  1400					      dw	10
      1  1400		       0a 00		      .word.w	10
      0  1402					      db	(10 / 65536)
      1  1402		       00		      .byte.b	(10 / 65536)
      0  1403					      dw	100
      1  1403		       64 00		      .word.w	100
      0  1405					      db	(100 / 65536)
      1  1405		       00		      .byte.b	(100 / 65536)
      0  1406					      dw	1000
      1  1406		       e8 03		      .word.w	1000
      0  1408					      db	(1000 / 65536)
      1  1408		       00		      .byte.b	(1000 / 65536)
      0  1409					      dw	10000
      1  1409		       10 27		      .word.w	10000
      0  140b					      db	(10000 / 65536)
      1  140b		       00		      .byte.b	(10000 / 65536)
      0  140c					      dw	100000
      1  140c		       a0 86		      .word.w	100000
      0  140e					      db	(100000 / 65536)
      1  140e		       01		      .byte.b	(100000 / 65536)
      0  140f					      dw	1000000
      1  140f		       40 42		      .word.w	1000000
      0  1411					      db	(1000000 / 65536)
      1  1411		       0f		      .byte.b	(1000000 / 65536)
      0  1412					      dw	10000000
      1  1412		       80 96		      .word.w	10000000
      0  1414					      db	(10000000 / 65536)
      1  1414		       98		      .byte.b	(10000000 / 65536)
    135  1415							;=====================================================
    136  1415							; Print character in A as two hex digits to the Console
    137  1415
    138  1415		       48	   HexToOut   pha		;save return value
    139  1416		       48		      pha
    140  1417		       4a		      lsr		;a  ;move top nibble to bottom
    141  1418		       4a		      lsr		;a
    142  1419		       4a		      lsr		;a
    143  141a		       4a		      lsr		;a
    144  141b		       20 24 14 	      jsr	hexta	;output nibble
    145  141e		       68		      pla
    146  141f		       20 24 14 	      jsr	hexta
    147  1422		       68		      pla		;restore
    148  1423		       60		      rts
    149  1424							;
    150  1424		       29 0f	   hexta      and	#%0001111
    151  1426		       c9 0a		      cmp	#$0a
    152  1428		       18		      clc
    153  1429		       30 02		      bmi	hexta1
    154  142b		       69 07		      adc	#7
    155  142d		       69 30	   hexta1     adc	#'0	;then fall into...
    156  142f		       4c af 1f 	      jmp	VOUTCH
    157  1432							;
    158  1432							;=====================================================
    159  1432							; Print the string that immediately follows the JSR to
    160  1432							; this function.  Stops when a null byte is found,
    161  1432							; then returns to the instruction immediately
    162  1432							; following the null.
    163  1432							;
    164  1432							; Thanks to Ross Archer for this code.
    165  1432							; http://www.6502.org/source/io/primm.htm
    166  1432							;
    167  1432
    168  1432		       68	   tbputs     pla		;Get the low part of "return" address
    169  1433							;(data start address)
    170  1433		       85 5e		      sta	PrtFrom
    171  1435		       68		      pla
    172  1436		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    173  1438							;(data start address)
    174  1438							;Note: actually we're pointing one short
    175  1438		       a0 01	   PSINB      ldy	#1
    176  143a		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    177  143c		       e6 5e		      inc	PrtFrom	;update the pointer
    178  143e		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    179  1440		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    180  1442		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    181  1444							;   Accumulator
    182  1444		       f0 06		      beq	PSIX1	;don't print the final NULL
    183  1446		       20 af 1f 	      jsr	VOUTCH	;write it out
    184  1449		       4c 38 14 	      jmp	PSINB	;back around
    185  144c		       e6 5e	   PSIX1      inc	PrtFrom
    186  144e		       d0 02		      bne	PSIX2
    187  1450		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    188  1452		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    189  1455
    190  1455							;+
    191  1455							;====================================================
    192  1455		       2f 60	   PrtTerm    equ	tempy
    193  1455
    194  1455							; on exit Print Y has the offset to use
    195  1455							; input y =	 addr low
    196  1455							;	 x =	 addr high
    197  1455							;	 a =	 termination string
    198  1455
    199  1455
    200  1455				   PrtQuoted		; Print a quoted string from the current program space
    201  1455		       a9 22		      lda	#'"
    202  1457		       a4 51		      ldy	CUROFF
    203  1459		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    204  145b		       d0 03		      bne	PrtNoInc
    205  145d		       c8		      iny
    206  145e		       84 51		      sty	CUROFF
    207  1460				   PrtNoInc
    208  1460		       8d 60 2f 	      sta	PrtTerm
    209  1463
    210  1463				   PrtPrgString 		; Print a terminated string from the static program space
    211  1463		       a4 51		      ldy	CUROFF
    212  1465		       a5 4f		      lda	CURPTR
    213  1467		       85 5e		      sta	PrtFrom
    214  1469		       a5 50		      lda	CURPTR+1
    215  146b		       85 5f		      sta	PrtFrom+1
    216  146d		       4c 79 14 	      jmp	PrtLoop
    217  1470
    218  1470							; Print a string pointed to by x= h, y=l terminated by a
    219  1470							; Return y as the length
    220  1470
    221  1470		       86 5f	   PrtStr     stx	PrtFrom+1
    222  1472		       84 5e		      sty	PrtFrom
    223  1474		       8d 60 2f 	      sta	PrtTerm
    224  1477		       a0 00		      ldy	#0
    225  1479							;
    226  1479							; On entry here ptrfrom and prtterm point to area to print
    227  1479							;
    228  1479		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    229  147b		       cd 60 2f 	      cmp	PrtTerm
    230  147e		       f0 0b		      beq	PrtEnd
    231  1480		       c9 00		      cmp	#0	; always end if 0 is found
    232  1482		       f0 07		      beq	PrtEnd
    233  1484		       20 af 1f 	      jsr	VOUTCH
    234  1487		       c8		      iny
    235  1488		       4c 79 14 	      jmp	PrtLoop
    236  148b		       c8	   PrtEnd     iny		;return byte after the copy
    237  148c		       60		      rts
    238  148d
    239  148d							;
    240  148d							;=======================================================
    241  148d							; Print all Variables
    242  148d				   PrintAllVars
    243  148d		       a0 00		      ldy	#0
    244  148f		       a9 41		      lda	#'A
    245  1491				   PrintAllVarsLoop
    246  1491		       48		      pha
    247  1492		       b1 41		      lda	(VARIABLES),y
    248  1494		       85 52		      sta	R0
    249  1496		       c8		      iny
    250  1497		       b1 41		      lda	(VARIABLES),y
    251  1499		       85 53		      sta	R0+1
    252  149b
    253  149b		       68		      pla		;get the current letter
    254  149c		       48		      pha
    255  149d		       20 af 1f 	      jsr	VOUTCH
    256  14a0		       20 32 14 	      jsr	puts
      0  14a3					      db	"=",0
      1  14a3		       3d 00		      .byte.b	"=",0
    258  14a5		       68		      pla
    259  14a6		       aa		      tax
    260  14a7		       e8		      inx
    261  14a8		       8a		      txa
    262  14a9		       48		      pha		;
    263  14aa
    264  14aa		       98		      tya
    265  14ab		       48		      pha
    266  14ac		       20 63 13 	      jsr	PrintDecimal
    267  14af		       20 32 14 	      jsr	puts
      0  14b2					      db	" ",0
      1  14b2		       20 00		      .byte.b	" ",0
    269  14b4		       68		      pla
    270  14b5		       a8		      tay
    271  14b6		       c8		      iny
    272  14b7		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    273  14b9		       90 d6		      bcc	PrintAllVarsLoop
    274  14bb		       20 61 1e 	      jsr	CRLF
    275  14be
    276  14be		       68		      pla
    277  14bf		       60		      rts
    278  14c0							;==========================================================================================================
    279  14c0							;Debug   Print a Program Line from compile buffer
    280  14c0							;
    281  14c0				   DebugPrintProgramLine
    282  14c0		       48		      pha
    283  14c1		       a9 d0		      lda	#TOKENBUFFER&$FF
    284  14c3		       85 59		      sta	dpl
    285  14c5		       a9 0f		      lda	#TOKENBUFFER>>8
    286  14c7		       85 5a		      sta	dpl+1
    287  14c9		       68		      pla
    288  14ca
    289  14ca							; Decode and print a line of program text
    290  14ca							; on entry	 dpl points to line of code to print
    291  14ca							; on exit	 no change in reg or dpl
    292  14ca							;
    293  14ca				   PrintProgramLine
    294  14ca
    295  14ca		       8e d0 10 	      stx	printStorage
    296  14cd		       8c d1 10 	      sty	printStorage+1
    297  14d0		       48		      pha
    298  14d1
    299  14d1		       a0 01		      ldy	#1	; index into the token buffer
    300  14d3		       84 58		      sty	R2	; print unsigned decimal
    301  14d5		       a0 00		      ldy	#0
    302  14d7		       b1 59		      lda	(dpl),y	; get number of bytes
    303  14d9		       aa		      tax		; place pointer into x
    304  14da		       c8		      iny
    305  14db		       ca		      dex		; Deduct the length byte
    306  14dc		       20 bc 12 	      jsr	DPL2R0	; Print the line number
    307  14df		       20 63 13 	      jsr	PrintDecimal
    308  14e2		       a9 20		      lda	#$20
    309  14e4		       20 af 1f 	      jsr	VOUTCH
    310  14e7
    311  14e7				   PrintProgLoop
    312  14e7		       b1 59		      lda	(dpl),y	; Get a character
    313  14e9		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    314  14eb		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    315  14ed		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    316  14ef
    317  14ef				   PrintProgVars
    318  14ef		       b1 59		      lda	(dpl),y
    319  14f1		       29 e0		      and	#$E0	; Check for operators and punctuation
    320  14f3		       c9 e0		      cmp	#$E0
    321  14f5		       f0 6b		      beq	PrintProgOperatorVect
    322  14f7
    323  14f7		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    324  14f9		       c9 9e		      cmp	#$9D+1
    325  14fb		       90 62		      bcc	PrintProgVariableVec
    326  14fd		       29 a0		      and	#$A0	; Check for a valid datatype
    327  14ff		       c9 a0		      cmp	#$A0
    328  1501		       f0 06		      beq	PrintDataType	; if not just print the character
    329  1503		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    330  1505		       ca		      dex		; Ok we are processing it
    331  1506		       c8		      iny
    332  1507		       d0 25		      bne	PrintContinue	; Print and do the next character
    333  1509
    334  1509				   PrintDataType
    335  1509		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    336  150b		       c9 a0		      cmp	#tString
    337  150d		       f0 31		      beq	PrintStringVariable
    338  150f
    339  150f				   PrintProgNumber
    340  150f		       c8		      iny		; we have a numerical integer value
    341  1510		       ca		      dex
    342  1511		       48		      pha
    343  1512		       a9 00		      lda	#0
    344  1514		       85 53		      sta	R0+1
    345  1516		       85 58		      sta	R2	; Set to print signed number
    346  1518		       b1 59		      lda	(dpl),y
    347  151a		       85 52		      sta	R0
    348  151c		       68		      pla
    349  151d		       c9 a1		      cmp	#tInteger
    350  151f		       d0 06		      bne	PrintProgNumDone
    351  1521		       c8		      iny
    352  1522		       ca		      dex
    353  1523		       b1 59		      lda	(dpl),y
    354  1525		       85 53		      sta	R0+1
    355  1527
    356  1527				   PrintProgNumDone
    357  1527		       c8		      iny
    358  1528		       ca		      dex
    359  1529		       20 63 13 	      jsr	PrintDecimal
    360  152c
    361  152c				   PrintProgNext
    362  152c		       a9 20		      lda	#$20
    363  152e				   PrintContinue
    364  152e		       20 af 1f 	      jsr	VOUTCH
    365  1531				   PrintProgSkipSpace
    366  1531		       e0 00		      cpx	#0
    367  1533		       d0 b2		      bne	PrintProgLoop
    368  1535				   PrintProgramComplete
    369  1535		       20 61 1e 	      jsr	CRLF
    370  1538
    371  1538		       ae d0 10 	      ldx	printStorage
    372  153b		       ac d1 10 	      ldy	printStorage+1
    373  153e		       68		      pla
    374  153f
    375  153f		       60		      rts
    376  1540							;=================================================================================================================
    377  1540							; Print a string variable including the quotes
    378  1540							; On Input	 y is offset into buffer
    379  1540							; On Exit	 y is updated to new offset
    380  1540
    381  1540				   PrintStringVariable
    382  1540		       c8		      iny
    383  1541		       a9 22		      lda	#'"
    384  1543		       20 af 1f 	      jsr	VOUTCH
    385  1546		       c8		      iny
    386  1547		       a5 59		      lda	dpl
    387  1549		       85 5e		      sta	PrtFrom
    388  154b		       a5 5a		      lda	dpl+1
    389  154d		       85 5f		      sta	PrtFrom+1
    390  154f		       a9 22		      lda	#'"
    391  1551		       8d 60 2f 	      sta	PrtTerm
    392  1554		       20 79 14 	      jsr	PrtLoop
    393  1557		       a9 22		      lda	#'"
    394  1559		       20 af 1f 	      jsr	VOUTCH
    395  155c		       4c 2c 15 	      jmp	PrintProgNext
    396  155f
    397  155f				   PrintProgVariableVec
    398  155f		       4c ff 15 	      jmp	PrintProgVariable
    399  1562
    400  1562				   PrintProgOperatorVect
    401  1562		       4c d6 15 	      jmp	PrintProgOperator
    402  1565							;===============================================================================================================
    403  1565							; On entry dpl points to the buffer we are printing from
    404  1565							;	    y	current offset into the dpl buffer
    405  1565							; all registers preserved
    406  1565							;
    407  1565				   PrintKeyword
    408  1565
    409  1565		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    410  1567		       85 52		      sta	R0	; The value we are looking for
    411  1569		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    412  156b		       f0 0c		      beq	PrintKeyBranch
    413  156d		       c9 08		      cmp	#kGosub
    414  156f		       f0 08		      beq	PrintKeyBranch
    415  1571		       c9 29		      cmp	#kTask
    416  1573		       f0 04		      beq	PrintKeyBranch
    417  1575		       c9 31		      cmp	#kGofn
    418  1577		       d0 04		      bne	PrintKeySkipped
    419  1579				   PrintKeyBranch
    420  1579		       c8		      iny		; Skip the compiled memory address
    421  157a		       c8		      iny
    422  157b		       ca		      dex		; Change number of bytes to print
    423  157c		       ca		      dex		; Remove the bytes to print
    424  157d
    425  157d				   PrintKeySkipped
    426  157d		       c8		      iny		; Inc y to point to the next char to be printed
    427  157e		       ca		      dex		; Reduce number of bytes to print
    428  157f		       98		      tya		; Save y and x for the return
    429  1580		       48		      pha
    430  1581		       8a		      txa
    431  1582		       48		      pha
    432  1583
    433  1583		       a9 cb		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    434  1585		       85 54		      sta	R1
    435  1587		       a9 0e		      lda	#KeyWordTable>>8
    436  1589		       85 55		      sta	R1+1
    437  158b
    438  158b
    439  158b				   PrintKeyLoop
    440  158b		       a0 00		      ldy	#0	; Index into the keyword entry
    441  158d		       b1 54		      lda	(R1),y	; Get token value for this entry
    442  158f		       c8		      iny		; Point to first byte of key
    443  1590		       c5 52		      cmp	R0	; Compare to the token we are looking for
    444  1592		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    445  1594
    446  1594				   PrintKeyNext
    447  1594		       b1 54		      lda	(R1),y	; Get key letter
    448  1596		       c8		      iny		; Point to next byte always
    449  1597		       29 20		      and	#%00100000	; Check for last character in key work
    450  1599		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    451  159b
    452  159b		       98		      tya		; Trabsfer y to a for the addition
    453  159c		       18		      clc		; Table > 256 bytes
    454  159d		       65 54		      adc	R1
    455  159f		       85 54		      sta	R1
    456  15a1		       a9 00		      lda	#0
    457  15a3		       65 55		      adc	R1+1
    458  15a5		       85 55		      sta	R1+1
    459  15a7		       4c 8b 15 	      jmp	PrintKeyLoop
    460  15aa
    461  15aa				   PrintKeyFound
    462  15aa		       b1 54		      lda	(R1),y	; letter from key table
    463  15ac		       48		      pha		; Save it for later check
    464  15ad		       09 20		      ora	#%00100000	; Force it to lower case
    465  15af		       20 af 1f 	      jsr	VOUTCH	; Print it out
    466  15b2		       c8		      iny		; Point to next character
    467  15b3		       68		      pla		; Restore the value
    468  15b4		       29 20		      and	#%00100000	; Check if it was last char in keyword
    469  15b6		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    470  15b8
    471  15b8		       68		      pla		; Restore the x and y values
    472  15b9		       aa		      tax
    473  15ba		       68		      pla
    474  15bb		       a8		      tay
    475  15bc
    476  15bc				   PrintChkRem
    477  15bc		       a9 0a		      lda	#kRem
    478  15be		       c5 52		      cmp	R0
    479  15c0		       d0 11		      bne	PrintKeyDone
    480  15c2				   PrintKeyRem
    481  15c2		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    482  15c4		       85 5e		      sta	PrtFrom
    483  15c6		       a5 5a		      lda	dpl+1
    484  15c8		       85 5f		      sta	PrtFrom+1
    485  15ca		       a9 00		      lda	#0
    486  15cc		       8d 60 2f 	      sta	PrtTerm
    487  15cf		       20 79 14 	      jsr	PrtLoop
    488  15d2		       88		      dey		; point back to the terminating null value
    489  15d3				   PrintKeyDone
    490  15d3		       4c 2c 15 	      jmp	PrintProgNext
    491  15d6							;==================================================================================================================
    492  15d6							;Print Variable, number or operator
    493  15d6				   PrintProgOperator
    494  15d6		       b1 59		      lda	(dpl),y
    495  15d8		       c8		      iny
    496  15d9		       ca		      dex
    497  15da		       8e d2 10 	      stx	printStorage+2
    498  15dd		       a2 00		      ldx	#0
    499  15df				   PrintOprLoop
    500  15df		       dd b5 0e 	      cmp	OperValues,x
    501  15e2		       f0 03		      beq	PrintOprFound
    502  15e4		       e8		      inx
    503  15e5		       d0 f8		      bne	PrintOprLoop
    504  15e7				   PrintOprFound
    505  15e7		       8a		      txa
    506  15e8		       0a		      asl
    507  15e9		       aa		      tax
    508  15ea		       bd 87 0e 	      lda	Operators,x
    509  15ed		       20 af 1f 	      jsr	VOUTCH
    510  15f0		       e8		      inx
    511  15f1		       bd 87 0e 	      lda	Operators,x
    512  15f4		       f0 03		      beq	PrintOprDone
    513  15f6		       20 af 1f 	      jsr	VOUTCH
    514  15f9				   PrintOprDone
    515  15f9		       ae d2 10 	      ldx	printStorage+2
    516  15fc		       4c 2c 15 	      jmp	PrintProgNext
    517  15ff
    518  15ff							;=================================================================================================================
    519  15ff							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    520  15ff							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    521  15ff							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    522  15ff							;tVhat 	    equ     155 		   ; Variable ^
    523  15ff							;tVhash	    equ     156 		   ; Variable #
    524  15ff							;tVat		    equ     157 		   ; Variable @ = 0
    525  15ff				   PrintProgVariable
    526  15ff		       b1 59		      lda	(dpl),y
    527  1601		       c8		      iny
    528  1602		       ca		      dex
    529  1603		       c9 9b		      cmp	#tVhat
    530  1605		       d0 04		      bne	PrintProgChkHash
    531  1607		       a9 5e		      lda	#'^
    532  1609		       d0 15		      bne	PrintTheVar
    533  160b				   PrintProgChkHash
    534  160b		       c9 9c		      cmp	#tVhash
    535  160d		       d0 04		      bne	PrintProgChkAt
    536  160f		       a9 23		      lda	#'#
    537  1611		       d0 0d		      bne	PrintTheVar
    538  1613				   PrintProgChkAt
    539  1613		       c9 9d		      cmp	#tVat
    540  1615		       d0 04		      bne	PrintProgVarLetter
    541  1617		       a9 40		      lda	#'@
    542  1619		       d0 05		      bne	PrintTheVar
    543  161b				   PrintProgVarLetter
    544  161b		       29 7f		      and	#%01111111
    545  161d		       18		      clc
    546  161e		       69 41		      adc	#'A
    547  1620				   PrintTheVar
    548  1620		       20 af 1f 	      jsr	VOUTCH
    549  1623		       4c 2c 15 	      jmp	PrintProgNext
    550  1626
    551  1626
    552  1626							;==================================================================================================
    553  1626							; Size of print functions
    554  1626		       02 c3	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  1626					      include	"mem.asm"
      1  1626							;===================================================================
      2  1626							;This file contains the memory allocation and free functions
      3  1626							;in herant in this is the management of free memory in the system
      4  1626							; the interface to these functions
      5  1626							; a,x returns or provides the low hi bytes of the managed addresses
      6  1626							; This uses the programend, to memory end as the area to manage
      7  1626							;===================================================================
      8  1626					      Seg	Code
      9  1626							;=====================================================
     10  1626							;Pointers for memory Management
     11  1626							;Allocated block are not chained but can be followed for all memory by the associated length
     12  1626							; Mem block format is
     13  1626							;	 0-1   pointer to next block for free blocks
     14  1626							;	 0-1   for allocated blocks
     15  1626							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  1626							;	   1   refrence counter ... lol only up to 256 but it is something
     17  1626							;	 2-3   length constant for exevy type of memory block
     18  1626							; Memory is recombined as it is released
     19  1626							; The memory manager is not interupted durring allocation
     20  1626							; or freeing of memory
     21  1626							; Memory is allocated from the highest memory address towards
     22  1626							; the lowest memory address. meeting the Basic program end.
     23  1626							;====================================================
     24  1626							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  1626							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  1626							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  1626							;=====================================================
     28  1626				   MemInit
     29  1626		       a9 72		      lda	#FreeMemStart&$FF
     30  1628		       8d 68 2f 	      sta	ProgramStart
     31  162b		       8d 6a 2f 	      sta	ProgramEnd
     32  162e		       a9 2f		      lda	#FreeMemStart>>8
     33  1630		       8d 69 2f 	      sta	ProgramStart+1
     34  1633		       8d 6b 2f 	      sta	ProgramEnd+1
     35  1636
     36  1636		       20 40 16 	      jsr	GetSizes
     37  1639		       20 4b 16 	      jsr	MemFree
     38  163c		       20 63 16 	      jsr	MemUsed
     39  163f				   MemInitEnd
     40  163f		       60		      rts
     41  1640
     42  1640
     43  1640							;
     44  1640							;=====================================================
     45  1640							; This function might go away eventually, but was
     46  1640							; added to provide data for other pieces of code.
     47  1640							; It has some ties to the operating environment that
     48  1640							; will need to be customized for the target system.
     49  1640							;
     50  1640				   GetSizes
     51  1640							;
     52  1640							; Here is machine specific code to get the highest
     53  1640							; memory location that can be used by BASIC.
     54  1640							;
     55  1640				  -	      if	ProgramStart < $2000
     56  1640				  -	      lda	#$ff
     57  1640				  -	      sta	HighMem	;$13ff for KIM-1
     58  1640				  -	      sta	MemFreeList
     59  1640				  -	      lda	#$DE	;#$13
     60  1640				  -	      sta	HighMem+1
     61  1640				  -	      sta	MemFreeList+1
     62  1640					      else
     63  1640		       a9 ff		      lda	#$ff
     64  1642		       8d 6c 2f 	      sta	HighMem	;$CFFF otherwise
     65  1645		       a9 cf		      lda	#$cf
     66  1647		       8d 6d 2f 	      sta	HighMem+1
     67  164a					      endif
     68  164a		       60		      rts
     69  164b							;
     70  164b							; This computes the available memory remaining.
     71  164b							;
     72  164b				   MemFree
     73  164b		       38		      sec
     74  164c		       ad 6c 2f 	      lda	HighMem
     75  164f		       ed 6a 2f 	      sbc	ProgramEnd
     76  1652		       8d 70 2f 	      sta	FreeMem
     77  1655		       85 52		      sta	R0
     78  1657		       ad 6d 2f 	      lda	HighMem+1
     79  165a		       ed 6b 2f 	      sbc	ProgramEnd+1
     80  165d		       8d 71 2f 	      sta	FreeMem+1
     81  1660		       85 53		      sta	R0+1
     82  1662		       60		      rts
     83  1663							;
     84  1663							; This computes the size of the current user program.
     85  1663							;
     86  1663				   MemUsed
     87  1663		       38		      sec
     88  1664		       ad 6a 2f 	      lda	ProgramEnd
     89  1667		       ed 68 2f 	      sbc	ProgramStart
     90  166a		       8d 6e 2f 	      sta	UsedMem
     91  166d		       85 52		      sta	R0
     92  166f		       ad 6b 2f 	      lda	ProgramEnd+1
     93  1672		       ed 69 2f 	      sbc	ProgramStart+1
     94  1675		       8d 6f 2f 	      sta	UsedMem+1
     95  1678		       85 53		      sta	R0+1
     96  167a							;
     97  167a		       60		      rts
     98  167b
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  167b					      include	"gosub.asm"
      1  167b					      seg	Code
      2  167b
      3  167b							; Gosub and return related functions
      4  167b							;==========================================================
      5  167b							; Push the current math stack frame onto the gosub stack
      6  167b				   iPushMathStack
      7  167b		       98		      tya
      8  167c		       48		      pha
      9  167d		       a4 4d		      ldy	GOSUBSTACKPTR
     10  167f		       a5 4a		      lda	MATHSTACKPTR
     11  1681		       91 4b		      sta	(GOSUBSTACK),y
     12  1683		       a9 00		      lda	#0
     13  1685		       c8		      iny
     14  1686		       91 4b		      sta	(GOSUBSTACK),y
     15  1688		       c8		      iny
     16  1689		       91 4b		      sta	(GOSUBSTACK),y
     17  168b		       c8		      iny
     18  168c		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  168e		       91 4b		      sta	(GOSUBSTACK),y
     20  1690		       c8		      iny
     21  1691		       84 4d		      sty	GOSUBSTACKPTR
     22  1693		       68		      pla
     23  1694		       a8		      tay
     24  1695		       4c c2 02 	      jmp	NextIL
     25  1698							;
     26  1698							;==========================================================
     27  1698							; Increment parameter count. Assume Stack frame is top of stack
     28  1698				   iIncParmCount
     29  1698		       98		      tya
     30  1699		       48		      pha
     31  169a		       a4 4d		      ldy	GOSUBSTACKPTR
     32  169c		       88		      dey
     33  169d		       88		      dey
     34  169e		       88		      dey
     35  169f		       b1 4b		      lda	(GOSUBSTACK),y
     36  16a1		       aa		      tax
     37  16a2		       e8		      inx
     38  16a3		       8a		      txa
     39  16a4		       91 4b		      sta	(GOSUBSTACK),y
     40  16a6		       68		      pla
     41  16a7		       a8		      tay
     42  16a8		       4c c2 02 	      jmp	NextIL
     43  16ab							;
     44  16ab							;==========================================================
     45  16ab							;Restore the math stack frame
     46  16ab		       20 b1 16    iPopMathStack jsr	PopMathStackNow
     47  16ae		       4c c2 02 	      jmp	NextIL
     48  16b1
     49  16b1				   PopMathStackNow
     50  16b1		       98		      tya
     51  16b2		       48		      pha
     52  16b3
     53  16b3		       a4 4d		      ldy	GOSUBSTACKPTR
     54  16b5		       88		      dey
     55  16b6		       b1 4b		      lda	(GOSUBSTACK),y
     56  16b8		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  16ba		       d0 09		      bne	iPopMathStackNoFrame
     58  16bc		       88		      dey
     59  16bd		       88		      dey
     60  16be		       88		      dey
     61  16bf		       b1 4b		      lda	(GOSUBSTACK),y
     62  16c1		       85 4a		      sta	MATHSTACKPTR
     63  16c3		       84 4d		      sty	GOSUBSTACKPTR
     64  16c5
     65  16c5				   iPopMathStackNoFrame
     66  16c5
     67  16c5		       68		      pla
     68  16c6		       a8		      tay
     69  16c7		       60		      rts
     70  16c8
     71  16c8
     72  16c8							;==========================================================
     73  16c8							; Push the current math stack information onto the gosub stack
     74  16c8				   iSaveMathStack
     75  16c8		       98		      tya
     76  16c9		       48		      pha
     77  16ca		       a4 4d		      ldy	GOSUBSTACKPTR
     78  16cc		       a5 4a		      lda	MATHSTACKPTR
     79  16ce		       91 4b		      sta	(GOSUBSTACK),y
     80  16d0		       a5 48		      lda	MATHSTACK
     81  16d2		       c8		      iny
     82  16d3
     83  16d3		       91 4b		      sta	(GOSUBSTACK),y
     84  16d5		       c8		      iny
     85  16d6
     86  16d6		       a5 49		      lda	MATHSTACK+1
     87  16d8		       91 4b		      sta	(GOSUBSTACK),y
     88  16da		       c8		      iny
     89  16db
     90  16db		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  16dd		       91 4b		      sta	(GOSUBSTACK),y
     92  16df		       c8		      iny
     93  16e0
     94  16e0		       84 4d		      sty	GOSUBSTACKPTR
     95  16e2		       68		      pla
     96  16e3		       a8		      tay
     97  16e4		       4c c2 02 	      jmp	NextIL
     98  16e7							;
     99  16e7							;==========================================================
    100  16e7							;Restore the math stack information from the gosub stack
    101  16e7				   iRestoreMathStack
    102  16e7		       98		      tya
    103  16e8		       48		      pha
    104  16e9
    105  16e9		       a5 4a		      lda	MATHSTACKPTR
    106  16eb		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  16ed
    108  16ed		       a4 4d		      ldy	GOSUBSTACKPTR
    109  16ef		       88		      dey
    110  16f0		       b1 4b		      lda	(GOSUBSTACK),y
    111  16f2		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  16f4		       d0 16		      bne	iPopMathStack_Err
    113  16f6		       88		      dey
    114  16f7		       b1 4b		      lda	(GOSUBSTACK),y
    115  16f9		       85 49		      sta	MATHSTACK+1
    116  16fb		       88		      dey
    117  16fc		       b1 4b		      lda	(GOSUBSTACK),y
    118  16fe		       85 48		      sta	MATHSTACK
    119  1700		       88		      dey
    120  1701		       b1 4b		      lda	(GOSUBSTACK),y
    121  1703		       85 4a		      sta	MATHSTACKPTR
    122  1705		       84 4d		      sty	GOSUBSTACKPTR
    123  1707		       68		      pla
    124  1708		       a8		      tay
    125  1709		       4c c2 02 	      jmp	NextIL
    126  170c
    127  170c				   iPopMathStack_Err
    128  170c		       a9 00		      lda	#0
    129  170e		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  1710		       4c a7 06 	      jmp	iErr2
    131  1713							;=========================================
    132  1713							; For functions and tasks the variable address of # means
    133  1713							; a passed parameter so #[0] is the first parameter etc
    134  1713							; will try for a better way later
    135  1713
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  1713					      include	"tasks.asm"
      1  1713							;=====================================================
      2  1713							; Tiny Basic IL task management
      3  1713							; Data required by task management
      4  1713							; currently each context is about 30 bytes and is swapped
      5  1713							; into and out of page zero on each task switch....
      6  1713							; LOL yes it is slow, but works for this iteration.
      7  1713							;
      8  1713
      9  1713					      Seg	Code
     10  1713							;=====================================================
     11  1713							; Sets the pointers to the math,IL and gosub stacks
     12  1713							; Creates the initial Context for each task slot
     13  1713				   taskSetStacks
     14  1713		       a9 0f		      lda	#mathStack&$FF
     15  1715		       85 48		      sta	MATHSTACK
     16  1717		       a9 27		      lda	#mathStack>>8
     17  1719		       85 49		      sta	MATHSTACK+1
     18  171b
     19  171b		       a9 9f		      lda	#ilStack&$ff
     20  171d		       85 45		      sta	ILSTACK
     21  171f		       a9 28		      lda	#ilStack>>8
     22  1721		       85 46		      sta	ILSTACK+1
     23  1723
     24  1723		       a9 2f		      lda	#gosubStack&$FF
     25  1725		       85 4b		      sta	GOSUBSTACK
     26  1727		       a9 2a		      lda	#gosubStack>>8
     27  1729		       85 4c		      sta	GOSUBSTACK+1
     28  172b
     29  172b		       a9 af		      lda	#variableStack&$FF
     30  172d		       85 41		      sta	VARIABLES
     31  172f		       a9 2c		      lda	#variableStack>>8
     32  1731		       85 42		      sta	VARIABLES+1
     33  1733		       a2 0a		      ldx	#TASKCOUNT
     34  1735		       a0 00		      ldy	#0
     35  1737		       20 d4 19 	      jsr	ContextSave
     36  173a
     37  173a		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  173c		       b0 3a		      bcs	taskSetDone
     39  173e
     40  173e		       a5 4b		      lda	GOSUBSTACK
     41  1740		       18		      clc
     42  1741		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  1743		       85 4b		      sta	GOSUBSTACK
     44  1745		       a5 4c		      lda	GOSUBSTACK+1
     45  1747		       69 00		      adc	#0
     46  1749		       85 4c		      sta	GOSUBSTACK+1
     47  174b
     48  174b		       a5 45		      lda	ILSTACK	; must be less than 256
     49  174d		       18		      clc
     50  174e		       69 28		      adc	#ILSTACKSIZE*2
     51  1750		       85 45		      sta	ILSTACK
     52  1752		       a5 46		      lda	ILSTACK+1
     53  1754		       69 00		      adc	#0
     54  1756		       85 46		      sta	ILSTACK+1
     55  1758
     56  1758		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  175a		       18		      clc
     58  175b		       69 28		      adc	#MATHSTACKSIZE*2
     59  175d		       85 48		      sta	MATHSTACK
     60  175f		       a5 49		      lda	MATHSTACK+1
     61  1761		       69 00		      adc	#0
     62  1763		       85 49		      sta	MATHSTACK+1
     63  1765
     64  1765		       a5 41		      lda	VARIABLES	; must be less than 256
     65  1767		       18		      clc
     66  1768		       69 36		      adc	#VARIABLESSIZE*2
     67  176a		       85 41		      sta	VARIABLES
     68  176c		       a5 42		      lda	VARIABLES+1
     69  176e		       69 00		      adc	#0
     70  1770		       85 42		      sta	VARIABLES+1
     71  1772
     72  1772		       20 d4 19 	      jsr	ContextSave
     73  1775		       4c 3a 17 	      jmp	taskSetLoop
     74  1778
     75  1778				   taskSetDone
     76  1778		       a0 00		      ldy	#0	; reload the main loop context
     77  177a		       20 e3 19 	      jsr	ContextLoad
     78  177d		       60		      rts
     79  177e							;
     80  177e							;=====================================================
     81  177e							; In some error cases the math stacks may be left pointing to the wrong stack
     82  177e							; This function will reset those stack addresses but not the actual pointer
     83  177e				   taskResetStacks
     84  177e		       a0 00		      ldy	#0
     85  1780		       20 e3 19 	      jsr	ContextLoad
     86  1783		       4c 13 17 	      jmp	taskSetStacks
     87  1786							;
     88  1786							;=====================================================
     89  1786							; Clear all task entries and task stacks
     90  1786		       98	   taskReset  tya		; Save Y
     91  1787		       48		      pha
     92  1788		       a9 01		      lda	#1
     93  178a		       8d 0e 27 	      sta	taskCounter	; Set number of active tasks to 1
     94  178d		       ac 0f 26 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  1790		       c0 00		      cpy	#0	; check if we are the main context
     96  1792		       f0 08		      beq	taskResetCont	; if we are just continue
     97  1794
     98  1794		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  1796		       8c 0f 26 	      sty	taskPtr
    100  1799		       20 e3 19 	      jsr	ContextLoad	; load the System Task context
    101  179c				   taskResetCont
    102  179c		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    103  179e
    104  179e				   taskResetLoop
    105  179e		       a9 00		      lda	#TASKINACTIVE
    106  17a0		       99 10 26 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  17a3		       18		      clc
    108  17a4		       98		      tya
    109  17a5		       69 19		      adc	#CONTEXTLEN
    110  17a7		       a8		      tay
    111  17a8		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  17aa		       90 f2		      bcc	taskResetLoop	; Go for more
    113  17ac
    114  17ac				   taskResetComplete
    115  17ac
    116  17ac		       68		      pla		; Restore y
    117  17ad		       a8		      tay
    118  17ae		       60		      rts
    119  17af
    120  17af							;
    121  17af							;======================================================
    122  17af							; iTaskSwitch	 switch to new task if not interrupt and
    123  17af							;		 count is exceded for task time slice gets here
    124  17af							;		 when time slice has reached zero
    125  17af							;
    126  17af		       98	   iTaskSwitch tya
    127  17b0		       48		      pha
    128  17b1
    129  17b1		       ad 0c 27 	      lda	taskResetValue	; Always reset the counter value
    130  17b4		       8d 0a 27 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  17b7		       ce 0b 27 	      dec	taskCurrentCycles+1	; dec high order byte
    132  17ba		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  17bc
    134  17bc		       ad 0d 27 	      lda	taskResetValue+1
    135  17bf		       8d 0b 27 	      sta	taskCurrentCycles+1
    136  17c2
    137  17c2		       ad 0c 26 	      lda	IRQPending	; Skip this if we are processing an irq
    138  17c5		       0d 66 2f 	      ora	taskIOPending	; If set then don't switch
    139  17c8		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  17ca
    141  17ca		       ad 0e 27    iTaskMain  lda	taskCounter	; Number of tasks
    142  17cd		       c9 01		      cmp	#1	; if there is only one task must be main
    143  17cf		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  17d1
    145  17d1		       ac 0f 26 	      ldy	taskPtr	; check if we have not just ended some other task
    146  17d4		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  17d6		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  17d8							;
    149  17d8							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  17d8							;
    151  17d8				   itasknext
    152  17d8		       ac 0f 26 	      ldy	taskPtr
    153  17db		       20 d4 19 	      jsr	ContextSave	; Save the current context, y points to next context
    154  17de				   itaskLoop
    155  17de		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  17e0		       90 04		      bcc	iTaskNextChk
    157  17e2
    158  17e2		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  17e4		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  17e6
    161  17e6				   iTaskNextChk
    162  17e6		       b9 10 26 	      lda	taskTable,y	; there is always at least one entry in table
    163  17e9		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  17eb		       18	   iTaskNext  clc
    165  17ec		       98		      tya
    166  17ed		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    167  17ef		       a8		      tay
    168  17f0		       4c de 17 	      jmp	itaskLoop	; Check for busy entry
    169  17f3
    170  17f3		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  17f5		       59 10 26 	      eor	taskTable,y	; Check for anything waiting io
    172  17f8		       d0 f1		      bne	iTaskNext
    173  17fa		       20 e3 19 	      jsr	ContextLoad	; load the next context
    174  17fd		       8c 0f 26 	      sty	taskPtr	; update the task pointer
    175  1800
    176  1800				   iTaskSwitchDone
    177  1800		       68		      pla
    178  1801		       a8		      tay
    179  1802		       60		      rts
    180  1803							;
    181  1803							;================================================================
    182  1803							; Task Set task number to line number to start
    183  1803							; on entry stack contains, type of line description and  memvector or linenumber
    184  1803							; Task Table structure:
    185  1803							;    byte 0	-   Active inactive
    186  1803							;    byte 1-2	-   Basic code line pointer
    187  1803							;    byte 3	-   Offset on current line
    188  1803		       98	   iTaskSet   tya		;preserve Y
    189  1804		       48		      pha		; push a
    190  1805		       20 c0 1d 	      jsr	popR1	; Get if compiled or line number expression
    191  1808		       20 a8 1d 	      jsr	popR0	; Get the line number to be saved
    192  180b
    193  180b
    194  180b
    195  180b		       ac 0f 26 	      ldy	taskPtr	; find out where we are
    196  180e		       20 d4 19 	      jsr	ContextSave	; Save the current context
    197  1811
    198  1811							;Find the pointer to the line we need to start at
    199  1811		       a5 54		      lda	R1
    200  1813		       f0 0b		      beq	iTaskLineNum
    201  1815		       a5 52		      lda	R0
    202  1817		       85 4f		      sta	CURPTR
    203  1819		       a5 53		      lda	R0+1
    204  181b		       85 50		      sta	CURPTR+1
    205  181d		       4c 30 18 	      jmp	iTaskCont
    206  1820
    207  1820				   iTaskLineNum
    208  1820		       20 62 1b 	      jsr	findLine	; Get the offset of the line to start task at
    209  1823		       f0 0b		      beq	iTaskCont
    210  1825
    211  1825		       ac 0f 26 	      ldy	taskPtr	; Restore the original Context Error Exit
    212  1828		       20 e3 19 	      jsr	ContextLoad
    213  182b
    214  182b		       68		      pla		; pop a - exit
    215  182c		       a8		      tay
    216  182d		       4c 7e 0d 	      jmp	iSetIrqErr	; Bad line number provided
    217  1830
    218  1830				   iTaskCont
    219  1830		       20 a6 19 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    220  1833		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    221  1835
    222  1835		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    223  1837		       99 10 26 	      sta	taskTable,y	; new task as active
    224  183a
    225  183a		       a5 4f		      lda	CURPTR
    226  183c		       48		      pha		; push a
    227  183d		       a5 50		      lda	CURPTR+1
    228  183f		       48		      pha		; push a
    229  1840
    230  1840		       20 e3 19 	      jsr	ContextLoad	; load the context of the new task
    231  1843
    232  1843		       68		      pla		; pop a
    233  1844		       85 50		      sta	CURPTR+1
    234  1846		       68		      pla		; pop a
    235  1847		       85 4f		      sta	CURPTR
    236  1849		       a9 03		      lda	#3	; Offset to first instruction
    237  184b		       85 51		      sta	CUROFF
    238  184d
    239  184d		       a9 00		      lda	#0
    240  184f		       85 47		      sta	ILSTACKPTR
    241  1851		       85 4a		      sta	MATHSTACKPTR
    242  1853		       85 4d		      sta	GOSUBSTACKPTR
    243  1855		       a9 40		      lda	#GOSUBSTACKSIZE*4
    244  1857		       85 4e		      sta	MESSAGEPTR
    245  1859
    246  1859		       20 59 09 	      jsr	subVINIT	; Clear the variables
    247  185c
    248  185c		       a9 5a		      lda	#STMT&$FF
    249  185e		       85 43		      sta	ILPC
    250  1860		       a9 22		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    251  1862		       85 44		      sta	ILPC+1
    252  1864
    253  1864		       98		      tya		; Save the new context offset to return to user
    254  1865		       48		      pha		; push a
    255  1866
    256  1866		       20 d4 19    itaskSetSave jsr	ContextSave	; save the updated context
    257  1869		       ee 0e 27 	      inc	taskCounter	; Update the number of Tasks running
    258  186c
    259  186c		       ac 0f 26 	      ldy	taskPtr
    260  186f		       20 e3 19 	      jsr	ContextLoad	; restore the original context
    261  1872
    262  1872		       a9 00		      lda	#0	; Set the R0 upper to zero
    263  1874		       85 53		      sta	R0+1
    264  1876		       68		      pla		; Get the task pid we stored				 ; pop a
    265  1877		       85 52		      sta	R0	; Get the table entry value
    266  1879
    267  1879		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    268  187a		       a8		      tay
    269  187b
    270  187b		       4c 40 07 	      jmp	pushR0nextIl	; Push R0 and continue
    271  187e				   iTaskNoEmpty
    272  187e		       ac 0f 26 	      ldy	taskPtr
    273  1881		       20 e3 19 	      jsr	ContextLoad
    274  1884
    275  1884		       68		      pla		; pop a    -- exit
    276  1885		       a8		      tay
    277  1886
    278  1886		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    279  1888		       a9 00		      lda	#0
    280  188a		       4c a7 06 	      jmp	iErr2
    281  188d							;
    282  188d							;===============================================================
    283  188d							; Run the task whos PID is on the stack, preserve the stack
    284  188d							;
    285  188d				   iTaskEnable
    286  188d		       98		      tya
    287  188e		       48		      pha
    288  188f		       20 c0 1d 	      jsr	popR1
    289  1892		       20 8e 1d 	      jsr	pushR1
    290  1895		       20 da 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    291  1898		       a0 00		      ldy	#0
    292  189a		       b1 56		      lda	(MQ),y
    293  189c		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    294  189e		       09 80		      ora	#TASKACTIVE
    295  18a0		       91 56		      sta	(MQ),y
    296  18a2		       68		      pla
    297  18a3		       a8		      tay
    298  18a4		       4c c2 02 	      jmp	NextIL
    299  18a7
    300  18a7							;
    301  18a7							;===============================================================
    302  18a7							; Suspend the task whos PID  is on the stack, preserve the stack
    303  18a7							;
    304  18a7				   iTaskSuspend
    305  18a7		       98		      tya
    306  18a8		       48		      pha
    307  18a9		       20 c0 1d 	      jsr	popR1
    308  18ac		       20 8e 1d 	      jsr	pushR1
    309  18af		       20 da 1a 	      jsr	ipc_getcontext	; get context pointer into mq
    310  18b2		       a0 00		      ldy	#0
    311  18b4		       b1 56		      lda	(MQ),y
    312  18b6		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    313  18b8		       09 80		      ora	#TASKACTIVE
    314  18ba		       68		      pla
    315  18bb		       a8		      tay
    316  18bc		       4c c2 02 	      jmp	NextIL
    317  18bf
    318  18bf							;================================================================
    319  18bf							; Returns task Status
    320  18bf				   iTaskStat
    321  18bf		       98		      tya
    322  18c0		       48		      pha
    323  18c1		       20 d3 18 	      jsr	iTaskValid	; returns pointer to task entry
    324  18c4		       b9 10 26 	      lda	taskTable,y
    325  18c7		       f0 05		      beq	iTaskStatExit
    326  18c9		       68		      pla
    327  18ca		       a8		      tay
    328  18cb		       4c 38 0d 	      jmp	iTruth
    329  18ce				   iTaskStatExit
    330  18ce		       68		      pla
    331  18cf		       a8		      tay
    332  18d0		       4c 41 0d 	      jmp	iFalse
    333  18d3
    334  18d3							;
    335  18d3							;================================================================
    336  18d3							; Validate the task number on top of the stack
    337  18d3							; on exit y points to the requested task entry
    338  18d3							;
    339  18d3		       20 a8 1d    iTaskValid jsr	popR0	; get result of the multiply
    340  18d6		       a5 53		      lda	R0+1
    341  18d8		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    342  18da		       a5 52		      lda	R0
    343  18dc		       c9 fa		      cmp	#TASKTABLELEN
    344  18de		       90 09		      bcc	iTaskIsValid
    345  18e0
    346  18e0		       68	   iTaskValidErr pla		;remove return address
    347  18e1		       68		      pla
    348  18e2		       a2 10		      ldx	#ERR_INVALID_PID
    349  18e4		       a9 00		      lda	#0
    350  18e6		       4c a7 06 	      jmp	iErr2
    351  18e9
    352  18e9		       a8	   iTaskIsValid tay
    353  18ea		       60		      rts
    354  18eb							;
    355  18eb							;================================================================
    356  18eb							; Kill a running task, do nothing if already stopped
    357  18eb		       20 d3 18    iTaskKill  jsr	iTaskValid
    358  18ee		       a9 00		      lda	#0
    359  18f0		       99 10 26 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    360  18f3							;
    361  18f3							;================================================================
    362  18f3							;Skip to next task
    363  18f3				   iNTask
    364  18f3		       a9 01		      lda	#1
    365  18f5		       8d 0a 27 	      sta	taskCurrentCycles
    366  18f8		       8d 0b 27 	      sta	taskCurrentCycles+1
    367  18fb		       4c c2 02 	      jmp	NextIL
    368  18fe							;
    369  18fe							;=======================================================
    370  18fe							; Wait for a task to complete
    371  18fe				   iWTASK
    372  18fe		       20 1d 1b 	      jsr	getILByte
    373  1901		       8d 64 2f 	      sta	offset
    374  1904							;
    375  1904		       20 00 1d 	      jsr	saveIL	;in case of failure
    376  1907
    377  1907		       20 d3 18 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    378  190a		       b9 10 26 	      lda	taskTable,y
    379  190d		       d0 03		      bne	iWTASKWAIT
    380  190f				   iWTASKEXITED
    381  190f		       4c c2 02 	      jmp	NextIL
    382  1912				   iWTASKWAIT
    383  1912		       20 16 1d 	      jsr	pushR0	; Push R0 back onto the stack
    384  1915		       a9 01		      lda	#1
    385  1917		       8d 0a 27 	      sta	taskCurrentCycles	; Give up the cycles
    386  191a		       8d 0b 27 	      sta	taskCurrentCycles+1
    387  191d		       20 0b 1d 	      jsr	restoreIL
    388  1920		       4c 9a 0b 	      jmp	tstBranch
    389  1923							;
    390  1923							;=======================================================
    391  1923							; Set task io lock
    392  1923		       ee 66 2f    iStartIO   inc	taskIOPending
    393  1926		       4c c2 02 	      jmp	NextIL
    394  1929							;
    395  1929							;=======================================================
    396  1929							; Release the io lock
    397  1929		       ad 66 2f    iEndIO     lda	taskIOPending
    398  192c		       f0 03		      beq	iEndIOExit
    399  192e		       ce 66 2f 	      dec	taskIOPending
    400  1931		       4c c2 02    iEndIOExit jmp	NextIL
    401  1934							;
    402  1934							;===============================================================
    403  1934							; Return the task PID
    404  1934				   iTASKPID
    405  1934		       a9 00		      lda	#0
    406  1936		       85 53		      sta	R0+1
    407  1938		       ad 0f 26 	      lda	taskPtr
    408  193b		       85 52		      sta	R0
    409  193d		       4c 40 07 	      jmp	pushR0nextIl
    410  1940							;
    411  1940							;================================================================
    412  1940							; Terminate a task
    413  1940		       ac 0f 26    iETask     ldy	taskPtr
    414  1943		       c0 00		      cpy	#0
    415  1945		       d0 03		      bne	iETaskCont
    416  1947		       4c 34 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    417  194a				   iETaskCont
    418  194a		       a9 00		      lda	#TASKINACTIVE
    419  194c		       99 10 26 	      sta	taskTable,y	; mark entry as free
    420  194f		       ce 0e 27 	      dec	taskCounter	; reduce the number of active tasks
    421  1952		       a9 01		      lda	#1
    422  1954		       8d 0a 27 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    423  1957		       8d 0b 27 	      sta	taskCurrentCycles+1
    424  195a		       20 c1 19 	      jsr	TaskSetExitCode
    425  195d				   iETaskExit
    426  195d		       4c c2 02 	      jmp	NextIL
    427  1960							;================================================================
    428  1960							; make the current tasks math stack equal another tasks stack
    429  1960							; The task to get is stored on the math stack
    430  1960
    431  1960				   iTaskGetMathStack
    432  1960		       20 ce 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    433  1963		       20 da 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    434  1966		       a0 0a		      ldy	#MATHSTACKPTRPOS
    435  1968		       b1 56		      lda	(MQ),y
    436  196a		       85 4a		      sta	MATHSTACKPTR
    437  196c		       a0 08		      ldy	#MATHSTACKPOS
    438  196e		       b1 56		      lda	(MQ),y
    439  1970		       85 48		      sta	MATHSTACK
    440  1972		       c8		      iny
    441  1973		       b1 56		      lda	(MQ),y
    442  1975		       85 49		      sta	MATHSTACK+1
    443  1977		       4c c2 02 	      jmp	NextIL
    444  197a							;==================================================================
    445  197a							; Updates the tasks math stack pointer with contents of R2
    446  197a							; PID is on top of the stack
    447  197a				   iTaskPutMathPtr
    448  197a		       20 ce 1f 	      jsr	CopyStackR1	; Get the top of stack to R1
    449  197d		       20 da 1a 	      jsr	ipc_getcontext	; MQ now has the context address
    450  1980		       a5 58		      lda	R2
    451  1982		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  1984		       91 56		      sta	(MQ),y
    453  1986		       4c c2 02 	      jmp	NextIL
    454  1989							;
    455  1989							;================================================================
    456  1989							; Set the time slice for each task
    457  1989				   iSLICE
    458  1989		       20 a8 1d 	      jsr	popR0
    459  198c		       a5 52		      lda	R0
    460  198e		       8d 0c 27 	      sta	taskResetValue
    461  1991		       a5 53		      lda	R0+1
    462  1993		       8d 0d 27 	      sta	taskResetValue+1
    463  1996		       d0 0b		      bne	iSliceSet
    464  1998		       ee 0d 27 	      inc	taskResetValue+1	; must be at least 1 high counter
    465  199b		       a9 01		      lda	#1
    466  199d		       8d 0a 27 	      sta	taskCurrentCycles
    467  19a0		       8d 0b 27 	      sta	taskCurrentCycles+1
    468  19a3				   iSliceSet
    469  19a3		       4c c2 02 	      jmp	NextIL
    470  19a6							;================================================================
    471  19a6							; Find an empty slot in the taskTable
    472  19a6							; Return the index in y
    473  19a6							; on exit   c set if an empty slot is found
    474  19a6							;	     c clear if not found
    475  19a6							;================================================================
    476  19a6							;
    477  19a6		       ad 0e 27    TaskEmpty  lda	taskCounter
    478  19a9		       c9 0a		      cmp	#TASKCOUNT
    479  19ab		       b0 10		      bcs	TaskNoSlot
    480  19ad		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    481  19af				   TaskLoop
    482  19af		       b9 10 26 	      lda	taskTable,y
    483  19b2		       f0 0b		      beq	TaskEmptyFnd
    484  19b4		       98		      tya
    485  19b5		       18		      clc
    486  19b6		       69 19		      adc	#CONTEXTLEN
    487  19b8		       a8		      tay
    488  19b9		       c0 fa		      cpy	#TASKTABLELEN
    489  19bb		       90 f2		      bcc	TaskLoop	; Y is never zero
    490  19bd				   TaskNoSlot
    491  19bd		       18		      clc
    492  19be		       60		      rts
    493  19bf				   TaskEmptyFnd
    494  19bf		       38		      sec
    495  19c0		       60		      rts
    496  19c1							;====================================================
    497  19c1							; Set the task exit code called from the return command
    498  19c1							; on entry stack top hold exit value
    499  19c1				   TaskSetExitCode
    500  19c1		       98		      tya
    501  19c2		       48		      pha
    502  19c3		       20 a8 1d 	      jsr	popR0
    503  19c6		       a0 34		      ldy	#TASKEXITCODE
    504  19c8		       a5 52		      lda	R0
    505  19ca		       91 41		      sta	(VARIABLES),y
    506  19cc		       c8		      iny
    507  19cd		       a5 53		      lda	R0+1
    508  19cf		       91 41		      sta	(VARIABLES),y
    509  19d1		       68		      pla
    510  19d2		       98		      tya
    511  19d3		       60		      rts
    512  19d4
    513  19d4							;
    514  19d4							;=====================================================
    515  19d4							; Save Context Store the context to the TASK Table
    516  19d4							; on entry y contains the task table entry to save to
    517  19d4							; on exit y points to next task table entry
    518  19d4							;	   x contains the number of bytes copied
    519  19d4		       a2 00	   ContextSave ldx	#0
    520  19d6		       c8		      iny		;inc past the task flags
    521  19d7		       b5 41	   ContextSvLoop lda	CONTEXT,x
    522  19d9		       99 10 26 	      sta	taskTable,y
    523  19dc		       c8		      iny
    524  19dd		       e8		      inx
    525  19de		       e0 18		      cpx	#[CONTEXTLEN-1]
    526  19e0		       90 f5		      bcc	ContextSvLoop
    527  19e2		       60		      rts
    528  19e3							;
    529  19e3							; Load Context transfer context from task table to the Current Context
    530  19e3							; on entry y contains the task table entry to transfer
    531  19e3							; on exit y points to the original task table entry
    532  19e3							;	   x contains the number of byts copied
    533  19e3		       98	   ContextLoad tya
    534  19e4		       48		      pha
    535  19e5		       a2 00		      ldx	#0
    536  19e7		       c8		      iny		;inc past the task flags
    537  19e8		       b9 10 26    ContextLDLoop lda	taskTable,y
    538  19eb		       95 41		      sta	CONTEXT,x
    539  19ed		       c8		      iny
    540  19ee		       e8		      inx
    541  19ef		       e0 18		      cpx	#[CONTEXTLEN-1]
    542  19f1		       90 f5		      bcc	ContextLDLoop
    543  19f3		       68		      pla
    544  19f4		       a8		      tay
    545  19f5		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  19f6					      include	"ipc.asm"
      1  19f6							;======================================================
      2  19f6							; Inter process communications.
      3  19f6							; Tasks may write/read integer messages among
      4  19f6							; them selves.
      5  19f6							; This uses each tasks gosub stack as a message queue
      6  19f6							; Gosub calls start at the highest address and the
      7  19f6							; msg queue starts at the highest address.
      8  19f6							;
      9  19f6							;======================================================
     10  19f6							; ipcs   - Send msg to another task or many tasks
     11  19f6							; on entry  math stack contains the  top PID
     12  19f6							;				      2ND Message value
     13  19f6							; on exit   math stack contain top True-good or False-failed
     14  19f6							;
     15  19f6							; it may not be sent if queue is full
     16  19f6							;
     17  19f6							; a = ipcs(<message-expression>,<task PID-expression>)
     18  19f6							;
     19  19f6				   iIPCS
     20  19f6		       98		      tya
     21  19f7		       48		      pha
     22  19f8		       20 5f 1a 	      jsr	ipc_enqueue
     23  19fb		       b0 08		      bcs	iIPC_BAD
     24  19fd		       20 c0 1f 	      jsr	pushTrue
     25  1a00		       68		      pla
     26  1a01		       a8		      tay
     27  1a02		       4c c2 02 	      jmp	NextIL
     28  1a05				   iIPC_BAD
     29  1a05		       68		      pla
     30  1a06		       a8		      tay
     31  1a07		       20 ca 1f 	      jsr	pushFalse
     32  1a0a		       4c c2 02 	      jmp	NextIL
     33  1a0d
     34  1a0d							;======================================================
     35  1a0d							; ipcr   - Recieve msg from task
     36  1a0d							; on exit  the message value is returned from message queue
     37  1a0d							;	    message -1	is reserved meaning no entry found
     38  1a0d							; The provided variable contains the pid of the sending
     39  1a0d							; task. This is optional. This always waits for a message
     40  1a0d							; before returning.
     41  1a0d							;
     42  1a0d							; a = ipcr(<variable name>)
     43  1a0d							;
     44  1a0d				   iIPCR
     45  1a0d		       98		      tya
     46  1a0e		       48		      pha
     47  1a0f		       20 a1 1a 	      jsr	ipc_dequeue
     48  1a12		       b0 05		      bcs	iIPCR_Q_Empty
     49  1a14		       68		      pla
     50  1a15		       a8		      tay
     51  1a16		       4c c2 02 	      jmp	NextIL
     52  1a19				   iIPCR_Q_Empty
     53  1a19		       68		      pla
     54  1a1a		       a8		      tay
     55  1a1b		       20 c0 1f 	      jsr	pushTrue	; puts -1 on the stack
     56  1a1e		       4c c2 02 	      jmp	NextIL
     57  1a21
     58  1a21							;=======================================================
     59  1a21							; ipcc   - Check if message available
     60  1a21							; on exit  Stack contains number of messages
     61  1a21							;
     62  1a21							; a = ipcc()
     63  1a21							;
     64  1a21				   iIPCC
     65  1a21		       98		      tya
     66  1a22		       48		      pha
     67  1a23		       20 4c 1a 	      jsr	ipc_queue_count
     68  1a26		       20 16 1d 	      jsr	pushR0	; return the count
     69  1a29		       68		      pla
     70  1a2a		       a8		      tay
     71  1a2b		       4c c2 02 	      jmp	NextIL
     72  1a2e
     73  1a2e							;=======================================================
     74  1a2e							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  1a2e				   iIPCIO
     76  1a2e		       98		      tya
     77  1a2f		       48		      pha
     78  1a30		       20 4c 1a 	      jsr	ipc_queue_count
     79  1a33		       a5 52		      lda	R0
     80  1a35		       d0 10		      bne	iIPCIO_No_Halt
     81  1a37		       a9 01		      lda	#1
     82  1a39		       8d 0a 27 	      sta	taskCurrentCycles	; force a task switch
     83  1a3c		       a9 01		      lda	#TASKWAITIPC
     84  1a3e		       ac 0f 26 	      ldy	taskPtr
     85  1a41		       19 10 26 	      ora	taskTable,y
     86  1a44		       99 10 26 	      sta	taskTable,y
     87  1a47
     88  1a47				   iIPCIO_No_Halt
     89  1a47		       68		      pla
     90  1a48		       a8		      tay
     91  1a49		       4c c2 02 	      jmp	NextIL
     92  1a4c							;======================================================
     93  1a4c							;ipc_queue_count
     94  1a4c				   ipc_queue_count
     95  1a4c		       a5 4e		      lda	MESSAGEPTR
     96  1a4e		       18		      clc
     97  1a4f		       4a		      lsr		; divide by 4
     98  1a50		       4a		      lsr
     99  1a51		       85 52		      sta	R0	; store into R0
    100  1a53		       a9 10		      lda	#GOSUBSTACKSIZE
    101  1a55		       38		      sec
    102  1a56		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1a58		       85 52		      sta	R0
    104  1a5a		       a9 00		      lda	#0
    105  1a5c		       85 53		      sta	R0+1
    106  1a5e		       60		      rts
    107  1a5f							;=======================================================
    108  1a5f							; Support functions for messaging
    109  1a5f							;
    110  1a5f							; Enqueue message -> onto PID's MSG Q
    111  1a5f							; on entry top of stack contains the PID
    112  1a5f							;	    second contains the Message of the task
    113  1a5f							; on exit contains c set if failed
    114  1a5f							;		    c cleared if success
    115  1a5f							;		    PID's MSG Q PTR points to the message
    116  1a5f							;
    117  1a5f				   ipc_enqueue
    118  1a5f		       20 c0 1d 	      jsr	popR1	; Get the pid
    119  1a62		       20 da 1a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  1a65
    121  1a65		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  1a67		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1a69		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1a6b		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1a6d		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1a6f
    127  1a6f
    128  1a6f							; Get the PID'S stack address into R0
    129  1a6f		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1a71		       b1 56		      lda	(MQ),y
    131  1a73		       85 52		      sta	R0
    132  1a75		       c8		      iny
    133  1a76		       b1 56		      lda	(MQ),y
    134  1a78		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1a7a
    136  1a7a							; Set y to point to the msg q entry
    137  1a7a		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1a7c		       b1 56		      lda	(MQ),y	; Get the index
    139  1a7e		       a8		      tay		; Set y to queue offset
    140  1a7f
    141  1a7f							; enqueue the message
    142  1a7f		       88		      dey		; First byte to save to
    143  1a80		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1a82		       91 52		      sta	(R0),y	; Set the entry type
    145  1a84
    146  1a84		       88		      dey
    147  1a85		       ad 0f 26 	      lda	taskPtr	; Store the PID into queue
    148  1a88		       91 52		      sta	(R0),y
    149  1a8a		       20 c0 1d 	      jsr	popR1	; Get the actual message value
    150  1a8d		       20 0e 1b 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1a90
    152  1a90		       98		      tya		; Save the new q ptr
    153  1a91		       a0 0e		      ldy	#MSGPTRPOS
    154  1a93		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  1a95		       a0 00		      ldy	#0	; points to context root
    156  1a97		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1a99		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1a9b		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1a9d		       18		      clc
    160  1a9e		       60		      rts
    161  1a9f				   ipc_enq_full
    162  1a9f		       38		      sec
    163  1aa0		       60		      rts
    164  1aa1							;=============================================================
    165  1aa1							; De-queue for message stack -> local tasks msg q
    166  1aa1							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1aa1							;  message into
    168  1aa1							;  on exit   math stack contains value of message
    169  1aa1							;				  Variable if provided is pid
    170  1aa1				   ipc_dequeue
    171  1aa1		       20 d7 1d 	      jsr	popMQ	; Variable address to put PID into
    172  1aa4
    173  1aa4		       a4 4e		      ldy	MESSAGEPTR
    174  1aa6		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  1aa8		       b0 2e		      bcs	ipc_deq_empty
    176  1aaa		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1aac		       85 52		      sta	R0
    178  1aae		       c8		      iny
    179  1aaf		       b1 4b		      lda	(GOSUBSTACK),y
    180  1ab1		       85 53		      sta	R0+1
    181  1ab3		       c8		      iny
    182  1ab4		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  1ab6		       85 54		      sta	R1
    184  1ab8		       c8		      iny
    185  1ab9		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1abb		       c8		      iny
    187  1abc		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1abe
    189  1abe		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1ac0		       d0 16		      bne	ipc_deq_empty
    191  1ac2
    192  1ac2		       20 16 1d 	      jsr	pushR0	; place value on stack
    193  1ac5
    194  1ac5		       a5 56		      lda	MQ
    195  1ac7		       05 57		      ora	MQ+1
    196  1ac9		       f0 0b		      beq	ipc_deq_done
    197  1acb		       a5 54		      lda	R1
    198  1acd		       a0 00		      ldy	#0
    199  1acf		       91 56		      sta	(MQ),y
    200  1ad1		       c8		      iny
    201  1ad2		       a9 00		      lda	#0
    202  1ad4		       91 56		      sta	(MQ),y
    203  1ad6				   ipc_deq_done
    204  1ad6		       18		      clc
    205  1ad7		       60		      rts
    206  1ad8
    207  1ad8				   ipc_deq_empty
    208  1ad8		       38		      sec
    209  1ad9		       60		      rts
    210  1ada
    211  1ada							;=============================================
    212  1ada							;  Get the context address into MQ from R1 with
    213  1ada							;  context/index/pid
    214  1ada				   ipc_getcontext
    215  1ada		       18		      clc		; Get pointer to Task context
    216  1adb		       a9 10		      lda	#taskTable&$FF	; change ptr to address
    217  1add		       65 54		      adc	R1
    218  1adf		       85 56		      sta	MQ
    219  1ae1		       a9 26		      lda	#taskTable>>8
    220  1ae3		       65 55		      adc	R1+1
    221  1ae5		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  1ae7		       60		      rts
    223  1ae8							;
    224  1ae8							;==============================================
    225  1ae8							; on entry R1 has a context value,
    226  1ae8							; on exit c is set if fails
    227  1ae8							;
    228  1ae8				   ipc_CONTEXTVALUES
      0  1ae8					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  1ae8		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  1aec					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  1aec		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  1af0					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  1af0		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  1af2
    233  1af2				   ipc_ValidateContext
    234  1af2		       48		      pha
    235  1af3		       8a		      txa
    236  1af4		       48		      pha
    237  1af5		       a5 55		      lda	R1+1
    238  1af7		       d0 0e		      bne	ipc_Validate_Fail
    239  1af9		       a2 00		      ldx	#0
    240  1afb		       a5 54		      lda	R1
    241  1afd				   ipc_ValidateLoop
    242  1afd		       dd e8 1a 	      cmp	ipc_CONTEXTVALUES,x
    243  1b00		       f0 09		      beq	ipc_Valid_Context
    244  1b02		       e8		      inx
    245  1b03		       e0 0a		      cpx	#TASKCOUNT
    246  1b05		       90 f6		      bcc	ipc_ValidateLoop
    247  1b07
    248  1b07				   ipc_Validate_Fail
    249  1b07		       68		      pla
    250  1b08		       aa		      tax
    251  1b09		       68		      pla
      0  1b0a					      rtn
      0  1b0a					      db	25
      1  1b0a		       19		      .byte.b	25
    253  1b0b
    254  1b0b				   ipc_Valid_Context
    255  1b0b		       18		      clc
    256  1b0c		       90 f9		      bcc	ipc_Validate_Fail
    257  1b0e							;
    258  1b0e							;==============================================
    259  1b0e							;Push R1 onto the stack
    260  1b0e							;on entry y = next entry
    261  1b0e							;R0 points to the stack space
    262  1b0e							;on exit y points to next free byte
    263  1b0e				   ipc_pushR1
    264  1b0e		       88		      dey
    265  1b0f		       a5 55		      lda	R1+1	; PID first
    266  1b11		       91 52		      sta	(R0),y
    267  1b13		       88		      dey
    268  1b14		       a5 54		      lda	R1
    269  1b16		       91 52		      sta	(R0),y
    270  1b18		       60		      rts
    271  1b19
    272  1b19
    273  1b19
    274  1b19
    275  1b19
    276  1b19
    277  1b19
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  1b19					      include	"support.asm"
      1  1b19							;
      2  1b19							;=====================================================
      3  1b19							;=====================================================
      4  1b19							;=====================================================
      5  1b19							; This marks the start of support functions used by
      6  1b19							; the IL opcodes.  These are support functions, NOT
      7  1b19							; the IL code.
      8  1b19							;=====================================================
      9  1b19							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  1b19							;=====================================================
     11  1b19					      Seg	Code
     12  1b19							;=====================================================
     13  1b19							; This gets the next two bytes pointed to by ILPC and
     14  1b19							; returns them; X contains LSB, A contains MSB.  ILPC
     15  1b19							; is advanced by two, and Y contains 0 on return.
     16  1b19
     17  1b19							;
     18  1b19		       20 1d 1b    getILWord  jsr	getILByte	;LSB
     19  1b1c		       aa		      tax
     20  1b1d							;
     21  1b1d							;=====================================================
     22  1b1d							; This gets the next byte pointed to by ILPC and
     23  1b1d							; returns it in A.  On return, X is unchanged but Y
     24  1b1d							; contains 0.
     25  1b1d							;
     26  1b1d		       a0 00	   getILByte  ldy	#0
     27  1b1f		       b1 43		      lda	(ILPC),y	;get byte
     28  1b21		       08		      php		;save status
     29  1b22		       e6 43		      inc	ILPC	;inc LSB
     30  1b24		       d0 02		      bne	getILb2	;branch if no overflow
     31  1b26		       e6 44		      inc	ILPC+1	;inc MSB
     32  1b28		       28	   getILb2    plp		;restore status
     33  1b29		       60		      rts
     34  1b2a							;
     35  1b2a							;=====================================================
     36  1b2a							; Decrement ILPC by one.
     37  1b2a							;
     38  1b2a		       a5 43	   decIL      lda	ILPC
     39  1b2c		       d0 02		      bne	decIL2
     40  1b2e		       c6 44		      dec	ILPC+1
     41  1b30		       c6 43	   decIL2     dec	ILPC
     42  1b32		       60		      rts
     43  1b33							;
     44  1b33							;=====================================================
     45  1b33							; Push the ILPC onto the return stack.  Actually, this
     46  1b33							; pushes the address of ILPC+2 since that's the next
     47  1b33							; address to execute.
     48  1b33							;
     49  1b33		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  1b35		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  1b37		       b0 15		      bcs	pushErr
     52  1b39		       a5 43		      lda	ILPC
     53  1b3b		       18		      clc
     54  1b3c		       69 02		      adc	#2
     55  1b3e		       91 45		      sta	(ILSTACK),y
     56  1b40		       08		      php		;save C bit
     57  1b41		       c8		      iny
     58  1b42		       a5 44		      lda	ILPC+1
     59  1b44		       28		      plp		;restore C
     60  1b45		       69 00		      adc	#0
     61  1b47		       91 45		      sta	(ILSTACK),y
     62  1b49		       c8		      iny
     63  1b4a		       84 47		      sty	ILSTACKPTR
     64  1b4c		       18		      clc
     65  1b4d		       60		      rts
     66  1b4e				   pushErr
     67  1b4e		       38		      sec
     68  1b4f		       60		      rts
     69  1b50							;
     70  1b50							;=====================================================
     71  1b50							; Pull the top entry from return stack and put into
     72  1b50							; ILPC.
     73  1b50							;
     74  1b50		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  1b52		       f0 fa		      beq	pushErr
     76  1b54		       88		      dey
     77  1b55		       b1 45		      lda	(ILSTACK),y
     78  1b57		       85 44		      sta	ILPC+1
     79  1b59		       88		      dey
     80  1b5a		       b1 45		      lda	(ILSTACK),y
     81  1b5c		       85 43		      sta	ILPC
     82  1b5e		       84 47		      sty	ILSTACKPTR
     83  1b60		       18		      clc
     84  1b61		       60		      rts
     85  1b62							;
     86  1b62							;=====================================================
     87  1b62							; This searches for a specific line number that is in
     88  1b62							; R0.	There are three possible return conditions:
     89  1b62							; Line numbers are now the third byte, the first byte is now
     90  1b62							; a pointer to the next line, of course no longer than 255 byte
     91  1b62							; per line.
     92  1b62							;
     93  1b62							; Exact match was found:
     94  1b62							;    * Z set
     95  1b62							;    * CURPTR points to two-byte line number for that
     96  1b62							;	line.
     97  1b62							;
     98  1b62							; Next highest line found:
     99  1b62							;    * Z cleared
    100  1b62							;    * C set
    101  1b62							;    * CURPTR points to two-byte line number for that
    102  1b62							;	line.
    103  1b62							;
    104  1b62							; End of program reached:
    105  1b62							;    * Z cleared
    106  1b62							;    * C cleared
    107  1b62							;    * CURPTR points to first free byte at end of
    108  1b62							;	program.  Ie, it has save value as PROGRAMEND.
    109  1b62							;
    110  1b62							; A, X, and Y are all undefined on return.
    111  1b62							;
    112  1b62
    113  1b62				   findLine
    114  1b62		       ad 68 2f 	      lda	ProgramStart	;Start of program -> CURPTR
    115  1b65		       85 4f		      sta	CURPTR
    116  1b67		       ad 69 2f 	      lda	ProgramStart+1
    117  1b6a		       85 50		      sta	CURPTR+1
    118  1b6c							;
    119  1b6c							; At end of code?
    120  1b6c							;
    121  1b6c				   iXFER1
    122  1b6c		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1b6e		       cd 6a 2f 	      cmp	ProgramEnd	; at end of program then stop run
    124  1b71		       d0 0b		      bne	xfer2	; not end
    125  1b73		       a5 50		      lda	CURPTR+1
    126  1b75		       cd 6b 2f 	      cmp	ProgramEnd+1
    127  1b78		       d0 04		      bne	xfer2	;Not at end
    128  1b7a							;
    129  1b7a							; Line not found and the end of the program was
    130  1b7a							; reached.  Return Z and C both clear.
    131  1b7a							;
    132  1b7a		       a9 01		      lda	#1	;clear Z
    133  1b7c		       18		      clc		;clear C
    134  1b7d		       60		      rts
    135  1b7e							;
    136  1b7e							; Check for an exact line number match
    137  1b7e							;
    138  1b7e		       a5 52	   xfer2      lda	R0
    139  1b80		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1b82		       d1 4f		      cmp	(CURPTR),y
    141  1b84		       d0 08		      bne	xfernotit
    142  1b86		       c8		      iny
    143  1b87		       a5 53		      lda	R0+1
    144  1b89		       d1 4f		      cmp	(CURPTR),y
    145  1b8b		       d0 01		      bne	xfernotit	; not a matching line number
    146  1b8d							;
    147  1b8d							; This is exactly the line we want.
    148  1b8d							;
    149  1b8d		       60		      rts		;it matches exactly
    150  1b8e							;
    151  1b8e							; See if this line is greater than the one we're
    152  1b8e							; searching for.
    153  1b8e							;
    154  1b8e		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1b90		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1b92		       c5 53		      cmp	R0+1
    157  1b94		       90 0b		      bcc	xfer3
    158  1b96		       d0 07		      bne	xfer4
    159  1b98		       88		      dey
    160  1b99		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1b9b		       c5 52		      cmp	R0
    162  1b9d		       90 02		      bcc	xfer3
    163  1b9f							;
    164  1b9f							; This line is greater than the one we want, so
    165  1b9f							; return Z clear and C set.
    166  1b9f							;
    167  1b9f		       38	   xfer4      sec		;We found a line number greater
    168  1ba0		       60		      rts		;both conditions set
    169  1ba1							;
    170  1ba1							; Not the line (or droid) we're looking for.  Move to
    171  1ba1							; the next line.
    172  1ba1							;
    173  1ba1		       20 a7 1b    xfer3      jsr	FindNextLine
    174  1ba4		       4c 6c 1b 	      jmp	iXFER1
    175  1ba7							;
    176  1ba7							;=====================================================
    177  1ba7							; This advances CURPTR to the next line.  If there
    178  1ba7							; are no more lines, this leaves CURPTR equal to
    179  1ba7							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1ba7							; CURPTR is pointing to a valid line on entry.  This
    181  1ba7							; pointer points to the two-byte line number.
    182  1ba7							; Update this points to the 1 byte line length  ****************
    183  1ba7							;
    184  1ba7				   FindNextLine
    185  1ba7		       a0 03		      ldy	#3	;skip line number and length byte
    186  1ba9		       84 51		      sty	CUROFF	;this is the new offset
    187  1bab		       a0 00		      ldy	#0
    188  1bad		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1baf		       18		      clc
    190  1bb0		       65 4f		      adc	CURPTR
    191  1bb2		       85 4f		      sta	CURPTR
    192  1bb4		       a5 50		      lda	CURPTR+1
    193  1bb6		       69 00		      adc	#0
    194  1bb8		       85 50		      sta	CURPTR+1
    195  1bba		       60	   FindNext4  rts
    196  1bbb							;
    197  1bbb							;=====================================================
    198  1bbb							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1bbb							; if they are equal, Z clear if not.
    200  1bbb							;
    201  1bbb		       a5 4f	   AtEnd      lda	CURPTR
    202  1bbd		       cd 6a 2f 	      cmp	ProgramEnd
    203  1bc0		       d0 05		      bne	atendexit
    204  1bc2		       a5 50		      lda	CURPTR+1
    205  1bc4		       cd 6b 2f 	      cmp	ProgramEnd+1
    206  1bc7		       60	   atendexit  rts
    207  1bc8							;
    208  1bc8
    209  1bc8							;
    210  1bc8							;=====================================================
    211  1bc8							; Convert an ASCII string to a number.  On input,
    212  1bc8							; (CURPTR),Y points to the first digit.  This gets
    213  1bc8							; digit-by-digit until finding a non-number.  Returns
    214  1bc8							; Y pointing to the non-digit, and R0 contains the
    215  1bc8							; number.  This does NOT check for valid ranges, so
    216  1bc8							; a value like "123456789" will produce something,
    217  1bc8							; but not what you had expected.
    218  1bc8							;
    219  1bc8		       a9 00	   getDecimal lda	#0
    220  1bca		       85 52		      sta	R0
    221  1bcc		       85 53		      sta	R0+1
    222  1bce		       85 59		      sta	dpl	;temporary negative flag
    223  1bd0							;
    224  1bd0							; See if it's negative...
    225  1bd0							;
    226  1bd0							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1bd0		       b1 4f		      lda	(CURPTR),y
    228  1bd2		       c9 2d		      cmp	#'-
    229  1bd4		       d0 02		      bne	getDecLoop
    230  1bd6		       e6 59		      inc	dpl	;it's negative
    231  1bd8							;
    232  1bd8		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1bda		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1bdc		       c9 30		      cmp	#'0
    235  1bde		       90 36		      bcc	getDdone
    236  1be0		       c9 3a		      cmp	#'9+1
    237  1be2		       b0 32		      bcs	getDdone
    238  1be4		       38		      sec
    239  1be5		       e9 30		      sbc	#'0	;convert to binary
    240  1be7		       48		      pha
    241  1be8							;
    242  1be8							; Now multiply R0 by 10.  Remember that
    243  1be8							; 2*N + 8*N = 10*N.
    244  1be8							;
    245  1be8		       06 52		      asl	R0
    246  1bea		       26 53		      rol	R0+1	;*2
    247  1bec		       a5 52		      lda	R0
    248  1bee		       85 54		      sta	R1
    249  1bf0		       a5 53		      lda	R0+1
    250  1bf2		       85 55		      sta	R1+1
    251  1bf4		       06 52		      asl	R0
    252  1bf6		       26 53		      rol	R0+1	;*4
    253  1bf8		       06 52		      asl	R0
    254  1bfa		       26 53		      rol	R0+1	;*8
    255  1bfc		       18		      clc		;now add the partial sums...
    256  1bfd		       a5 52		      lda	R0	;...to get *10
    257  1bff		       65 54		      adc	R1
    258  1c01		       85 52		      sta	R0
    259  1c03		       a5 53		      lda	R0+1
    260  1c05		       65 55		      adc	R1+1
    261  1c07		       85 53		      sta	R0+1
    262  1c09							;
    263  1c09							; Add in the new digit
    264  1c09							;
    265  1c09		       68		      pla
    266  1c0a		       18		      clc
    267  1c0b		       65 52		      adc	R0
    268  1c0d		       85 52		      sta	R0
    269  1c0f		       90 02		      bcc	getD2
    270  1c11		       e6 53		      inc	R0+1
    271  1c13							;
    272  1c13							; Move to next character
    273  1c13							;
    274  1c13		       c8	   getD2      iny
    275  1c14		       d0 c2		      bne	getDecLoop
    276  1c16							;
    277  1c16							; All done with digits, so now deal with it being
    278  1c16							; negative.  If zero, then don't check for negative
    279  1c16							; flag.  Ie, -0 is stored as 0.
    280  1c16							;
    281  1c16		       a5 52	   getDdone   lda	R0
    282  1c18		       05 53		      ora	R0+1
    283  1c1a		       f0 16		      beq	getDone2	;zero
    284  1c1c		       a5 59		      lda	dpl
    285  1c1e		       f0 12		      beq	getDone2	;positive
    286  1c20							;
    287  1c20							; Invert all the bits, then add one.
    288  1c20							;
    289  1c20		       a5 52		      lda	R0
    290  1c22		       49 ff		      eor	#$ff
    291  1c24		       85 52		      sta	R0
    292  1c26		       a5 53		      lda	R0+1
    293  1c28		       49 ff		      eor	#$ff
    294  1c2a		       85 53		      sta	R0+1
    295  1c2c							;
    296  1c2c		       e6 52		      inc	R0
    297  1c2e		       d0 02		      bne	getDone2
    298  1c30		       e6 53		      inc	R0+1
    299  1c32				   getDone2
    300  1c32							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1c32							;lda	  R0
    302  1c32							;sta	  $0010
    303  1c32							;lda	  R0+1
    304  1c32							;sta	  $0011
    305  1c32							;lda	  dpl
    306  1c32							;sta	  $012
    307  1c32
    308  1c32		       60		      rts
    309  1c33
    310  1c33							;=====================================================
    311  1c33							; Gets a line of input into LINBUF.
    312  1c33							;
    313  1c33							; On entry:
    314  1c33							;    A contains the prompt character, or 0 if none.
    315  1c33							;    X = 1 Background read
    316  1c33							;    x = 0 Forground read with wait
    317  1c33							;
    318  1c33							; On exit:
    319  1c33							;    CURPTR points to LINBUF
    320  1c33							;    LINBUF contains the line with 0 at the end.
    321  1c33							;    Y has offset to first non-space character
    322  1c33							;    CURROFF has the same as Y.
    323  1c33							;
    324  1c33		       20 82 1c    GetLine    jsr	ReadPrompt
    325  1c36		       e0 00		      cpx	#0
    326  1c38		       f0 14		      beq	GetLineRetry
    327  1c3a		       ae 0f 26 	      ldx	taskPtr
    328  1c3d		       bd 10 26 	      lda	taskTable,x
    329  1c40		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1c42		       d0 3d		      bne	taskWaitingIO
    331  1c44		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1c46		       9d 10 26 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1c49		       ce 81 1c 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1c4c		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1c4e
    336  1c4e							;
    337  1c4e							; Now read a line and wait for the CR
    338  1c4e							;
    339  1c4e				   GetLineRetry
    340  1c4e		       a9 00		      lda	#0	;Wait for input to complete
    341  1c50		       20 9a 1c 	      jsr	ReadLine
    342  1c53
    343  1c53							;
    344  1c53							; Point to the line we just read
    345  1c53							; Set the current pointer to point to the input line
    346  1c53							;
    347  1c53		       a0 00	   ReadComplete ldy	#0
    348  1c55		       84 51		      sty	CUROFF
    349  1c57		       a2 cb		      ldx	#LINBUF&$ff
    350  1c59		       86 4f		      stx	CURPTR
    351  1c5b		       a2 2e		      ldx	#LINBUF>>8
    352  1c5d		       86 50		      stx	CURPTR+1
    353  1c5f							;
    354  1c5f							; Output a CR/LF
    355  1c5f							;
    356  1c5f		       20 61 1e 	      jsr	CRLF
    357  1c62							;
    358  1c62							; If a blank line, prompt again.
    359  1c62							;
    360  1c62		       20 58 1e 	      jsr	SkipSpaces
    361  1c65		       b1 4f		      lda	(CURPTR),y
    362  1c67		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1c69		       20 85 1c 	      jsr	ReadPromptRetry
    364  1c6c		       ae 0f 26 	      ldx	taskPtr	;if this task is waiting for IO
    365  1c6f		       bd 10 26 	      lda	taskTable,x	;then get out, wait for line to
    366  1c72		       29 40		      and	#TASKWAITIO	;Complete again
    367  1c74		       d0 0b		      bne	taskWaitingIO
    368  1c76		       4c 4e 1c 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1c79
    370  1c79				   GetLineDone
    371  1c79		       ae 0f 26 	      ldx	taskPtr
    372  1c7c		       a9 80		      lda	#TASKACTIVE
    373  1c7e		       9d 10 26 	      sta	taskTable,x	;IO is complete
    374  1c81
    375  1c81				   taskWaitingIO
    376  1c81		       60		      rts
    377  1c82
    378  1c82							;
    379  1c82							;=======================================================================
    380  1c82							; Display the prompt character
    381  1c82							; On entry
    382  1c82							;	    A contains the prompt character
    383  1c82							; On exit
    384  1c82							;	    The readbuffer index is reset to 0
    385  1c82							;
    386  1c82		       8d 52 2f    ReadPrompt sta	promptChar
    387  1c85
    388  1c85							;
    389  1c85							; Prompt
    390  1c85							;
    391  1c85
    392  1c85		       ad 52 2f    ReadPromptRetry lda	promptChar
    393  1c88		       09 00		      ora	#0	;any prompt?
    394  1c8a		       f0 08		      beq	getlinenp
    395  1c8c		       20 af 1f 	      jsr	VOUTCH
    396  1c8f		       a9 20		      lda	#$20
    397  1c91		       20 af 1f 	      jsr	VOUTCH	;Space after prompt
    398  1c94							;
    399  1c94		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1c96		       8e 4f 2f 	      stx	getlinx
    401  1c99		       60		      rts
    402  1c9a							;
    403  1c9a							;===============================================================
    404  1c9a							; This fuction is the driver for the line input
    405  1c9a							; on call if a = 0 then it waits for all input
    406  1c9a							;	      a = 1 then nowait for input
    407  1c9a							; On exit
    408  1c9a							;		       c clear if not complete line
    409  1c9a							;		       c set if it was a complete line
    410  1c9a
    411  1c9a				   ReadLine
    412  1c9a		       8d 51 2f 	      sta	inputNoWait
    413  1c9d		       c9 00		      cmp	#0
    414  1c9f		       f0 05		      beq	getline1
    415  1ca1		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1ca4		       f0 2b		      beq	GetLineNoWait
    417  1ca6		       20 b2 1f    getline1   jsr	VGETCH
    418  1ca9					      if	CTMON65
    419  1ca9		       48		      pha
    420  1caa		       20 af 1f 	      jsr	VOUTCH	;echo echo echo
    421  1cad		       68		      pla
    422  1cae					      endif
    423  1cae		       c9 0d		      cmp	#CR
    424  1cb0		       f0 15		      beq	getlind	;end of line
    425  1cb2		       c9 08		      cmp	#BS	;backspace?
    426  1cb4		       f0 1d		      beq	getlinebs
    427  1cb6		       ae 4f 2f 	      ldx	getlinx
    428  1cb9		       9d cb 2e 	      sta	LINBUF,x
    429  1cbc		       e8		      inx
    430  1cbd		       8e 4f 2f 	      stx	getlinx
    431  1cc0		       ad 51 2f 	      lda	inputNoWait
    432  1cc3		       f0 e1		      beq	getline1
    433  1cc5		       d0 0a		      bne	GetLineNoWait
    434  1cc7							;
    435  1cc7							; CR was hit
    436  1cc7							;
    437  1cc7		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1cc9		       ae 4f 2f 	      ldx	getlinx
    439  1ccc		       9d cb 2e 	      sta	LINBUF,x
    440  1ccf
    441  1ccf		       38		      sec		; Carry set then cr received
    442  1cd0		       60		      rts
    443  1cd1
    444  1cd1				   GetLineNoWait
    445  1cd1		       18		      clc		; Carry clear no end of line
    446  1cd2		       60		      rts
    447  1cd3							;
    448  1cd3							; Backspace was hit
    449  1cd3							;
    450  1cd3		       ae 4f 2f    getlinebs  ldx	getlinx
    451  1cd6		       f0 0e		      beq	getlineEOL	;at start of line
    452  1cd8		       ca		      dex
    453  1cd9		       8e 4f 2f 	      stx	getlinx
    454  1cdc		       20 32 14    getlinepbs jsr	puts
      0  1cdf					      db	27,"[K",0
      1  1cdf		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1ce3		       4c a6 1c 	      jmp	getline1
    457  1ce6		       a9 20	   getlineEOL lda	#SPACE
    458  1ce8		       20 af 1f 	      jsr	VOUTCH
    459  1ceb		       d0 ef		      bne	getlinepbs
    460  1ced							;
    461  1ced							;=====================================================
    462  1ced							; Count the length of the line currently in LINBUF
    463  1ced							; starting at offset Y.  Returns the length in X.  The
    464  1ced							; starting offset in Y should point past the ASCII
    465  1ced							; line number.  Also counts the trailing NULL and two
    466  1ced							; extra bytes for where the line number will be.
    467  1ced							; Update must now include leading length byte not the null at end ****************
    468  1ced							;
    469  1ced				   getLineLength
    470  1ced		       a2 00		      ldx	#0	;size
    471  1cef		       b9 cb 2e    getLineL2  lda	LINBUF,y
    472  1cf2		       f0 04		      beq	getLineL3
    473  1cf4		       c8		      iny
    474  1cf5		       e8		      inx
    475  1cf6		       d0 f7		      bne	getLineL2
    476  1cf8		       e8	   getLineL3  inx		;count null at end
    477  1cf9		       e8		      inx		;line number LSB
    478  1cfa		       e8		      inx		;MSB
    479  1cfb		       e8		      inx		;change: count new leading line length
    480  1cfc		       8e 65 2f 	      stx	lineLength
    481  1cff		       60		      rts
    482  1d00							;
    483  1d00							;=====================================================
    484  1d00							; Count the length of the line pointed to by CURPTR.
    485  1d00							; This also counts the line number and the terminating
    486  1d00							; null.  Ie, this string returns 8:
    487  1d00							;
    488  1d00							; <lineLow><lineHi>Hello<null>
    489  1d00							;
    490  1d00							; Another way of looking at it: add the return value
    491  1d00							; to the CURPTR and it'll point to the next line's
    492  1d00							; line number.  Returns the value in Y.
    493  1d00							; Update to ject get the leading byte length ********************
    494  1d00							;
    495  1d00							;getCURPTRLength
    496  1d00							;		ldy	CURPTR
    497  1d00							;		ldy	#3	;change: skip line number and leading length byte
    498  1d00							;getCLineL2	lda	(CURPTR),y
    499  1d00							;		beq	getCLineL3
    500  1d00							;		iny
    501  1d00							;		bne	getCLineL2
    502  1d00							;getCLineL3	iny		;count null at end
    503  1d00							;		rts
    504  1d00
    505  1d00							;
    506  1d00							;=====================================================
    507  1d00							; This saves ILPC.  This saves to a single save area,
    508  1d00							; so it can't be called more than once.
    509  1d00							;
    510  1d00		       a5 43	   saveIL     lda	ILPC
    511  1d02		       8d 61 2f 	      sta	tempIL
    512  1d05		       a5 44		      lda	ILPC+1
    513  1d07		       8d 62 2f 	      sta	tempIL+1
    514  1d0a		       60		      rts
    515  1d0b							;
    516  1d0b							;=====================================================
    517  1d0b							; This restores ILPC.
    518  1d0b							;
    519  1d0b		       ad 61 2f    restoreIL  lda	tempIL
    520  1d0e		       85 43		      sta	ILPC
    521  1d10		       ad 62 2f 	      lda	tempIL+1
    522  1d13		       85 44		      sta	ILPC+1
    523  1d15		       60		      rts
    524  1d16							;
    525  1d16							;=====================================================
    526  1d16							; This pushes R0 onto the stack.
    527  1d16							;
    528  1d16		       8c 58 2f    pushR0     sty	rtemp1
    529  1d19		       a4 4a		      ldy	MATHSTACKPTR
    530  1d1b		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1d1d		       b0 38		      bcs	pusherr
    532  1d1f		       a5 52		      lda	R0
    533  1d21		       91 48		      sta	(MATHSTACK),y
    534  1d23		       c8		      iny
    535  1d24		       a5 53		      lda	R0+1
    536  1d26		       91 48		      sta	(MATHSTACK),y
    537  1d28		       c8		      iny
    538  1d29		       84 4a		      sty	MATHSTACKPTR
    539  1d2b		       ac 58 2f 	      ldy	rtemp1
    540  1d2e		       18		      clc
    541  1d2f		       60		      rts
    542  1d30
    543  1d30							;=====================================================
    544  1d30							; This pushes curptr basic current line onto the call stack.
    545  1d30							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1d30
    547  1d30				   pushLN
    548  1d30		       8d 59 2f 	      STA	rtemp1+1	; Store type of push being done
    549  1d33		       8c 58 2f 	      sty	rtemp1
    550  1d36		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  1d38		       c5 4d		      cmp	GOSUBSTACKPTR
    552  1d3a		       90 1b		      bcc	pusherr	; No error
    553  1d3c		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  1d3e		       a2 00		      ldx	#0	; Start of bytes to copy
    555  1d40				   pushLoop
    556  1d40		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  1d42		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  1d44		       c8		      iny		; Next destination
    559  1d45		       e8		      inx		; Next Source byte
    560  1d46		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  1d48		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  1d4a
    563  1d4a		       ad 59 2f    pushDone   lda	rtemp1+1	; Type of stack entry
    564  1d4d		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  1d4f		       c8		      iny		; Next entry
    566  1d50
    567  1d50		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  1d52		       ac 58 2f 	      ldy	rtemp1
    569  1d55		       18		      clc
    570  1d56		       60		      rts
    571  1d57				   pusherr
    572  1d57		       38		      sec
    573  1d58		       60		      rts
    574  1d59							;=====================================================
    575  1d59							; This pops Top Off gosub call Stack and
    576  1d59							; places it in CURPTR/CUROFF.
    577  1d59							; This checks if the type = 1 GOSUB
    578  1d59							; if not it removes what ever is on the stack
    579  1d59							; until it finds the next return. Allowing
    580  1d59							; a return from within a for/next
    581  1d59							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  1d59		       8c 58 2f    popLN      sty	rtemp1
    583  1d5c		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  1d5e		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  1d60
    586  1d60				   popContinue
    587  1d60		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  1d62		       90 22		      bcc	poperr	; Process an error
    589  1d64
    590  1d64		       88		      dey		; Position to read entry type
    591  1d65		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  1d67		       8d 59 2f 	      sta	rtemp1+1	; Save to be returned
    593  1d6a		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  1d6c		       f0 04		      beq	popLoop	; Restore the line
    595  1d6e		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  1d70		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  1d72
    598  1d72				   popLoop
    599  1d72		       88		      dey
    600  1d73		       ca		      dex
    601  1d74		       b1 4b		      lda	(GOSUBSTACK),y
    602  1d76		       95 4f		      sta	CURPTR,x
    603  1d78		       e0 00		      cpx	#0
    604  1d7a		       d0 f6		      bne	popLoop	; Loop until all moved
    605  1d7c
    606  1d7c
    607  1d7c		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  1d7e		       ac 58 2f 	      ldy	rtemp1
    609  1d81		       ad 59 2f 	      lda	rtemp1+1	; get the type of return
    610  1d84		       18		      clc
    611  1d85		       60		      rts
    612  1d86
    613  1d86		       38	   poperr     sec
    614  1d87		       60		      rts
    615  1d88
    616  1d88		       88	   popSkipEntry dey
    617  1d89		       88		      dey
    618  1d8a		       88		      dey
    619  1d8b		       4c 60 1d 	      jmp	popContinue
    620  1d8e
    621  1d8e							;
    622  1d8e							;=====================================================
    623  1d8e							; This pushes R1 onto the stack
    624  1d8e							;
    625  1d8e		       8c 58 2f    pushR1     sty	rtemp1
    626  1d91		       a4 4a		      ldy	MATHSTACKPTR
    627  1d93		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  1d95		       b0 ef		      bcs	poperr
    629  1d97		       a5 54		      lda	R1
    630  1d99		       91 48		      sta	(MATHSTACK),y
    631  1d9b		       c8		      iny
    632  1d9c		       a5 55		      lda	R1+1
    633  1d9e		       91 48		      sta	(MATHSTACK),y
    634  1da0		       c8		      iny
    635  1da1		       84 4a		      sty	MATHSTACKPTR
    636  1da3		       ac 58 2f 	      ldy	rtemp1
    637  1da6		       18		      clc
    638  1da7		       60		      rts
    639  1da8							;
    640  1da8							;=====================================================
    641  1da8							; This pops Top Of Stack and places it in R0.
    642  1da8							;
    643  1da8		       8c 58 2f    popR0      sty	rtemp1
    644  1dab		       a4 4a		      ldy	MATHSTACKPTR
    645  1dad		       f0 d7		      beq	poperr
    646  1daf		       88		      dey
    647  1db0		       b1 48		      lda	(MATHSTACK),y
    648  1db2		       85 53		      sta	R0+1
    649  1db4		       88		      dey
    650  1db5		       b1 48		      lda	(MATHSTACK),y
    651  1db7		       85 52		      sta	R0
    652  1db9		       84 4a		      sty	MATHSTACKPTR
    653  1dbb		       ac 58 2f 	      ldy	rtemp1
    654  1dbe		       18		      clc
    655  1dbf		       60		      rts
    656  1dc0
    657  1dc0							;
    658  1dc0							;=====================================================
    659  1dc0							; This pops TOS and places it in R1.
    660  1dc0							;
    661  1dc0		       8c 58 2f    popR1      sty	rtemp1
    662  1dc3		       a4 4a		      ldy	MATHSTACKPTR
    663  1dc5		       f0 bf		      beq	poperr
    664  1dc7		       88		      dey
    665  1dc8		       b1 48		      lda	(MATHSTACK),y
    666  1dca		       85 55		      sta	R1+1
    667  1dcc		       88		      dey
    668  1dcd		       b1 48		      lda	(MATHSTACK),y
    669  1dcf		       85 54		      sta	R1
    670  1dd1		       84 4a		      sty	MATHSTACKPTR
    671  1dd3		       ac 58 2f 	      ldy	rtemp1
    672  1dd6		       60		      rts
    673  1dd7							;
    674  1dd7							;=====================================================
    675  1dd7							; This pops TOS and places it in MQ.
    676  1dd7							;
    677  1dd7		       8c 58 2f    popMQ      sty	rtemp1
    678  1dda		       a4 4a		      ldy	MATHSTACKPTR
    679  1ddc		       f0 a8		      beq	poperr
    680  1dde		       88		      dey
    681  1ddf		       b1 48		      lda	(MATHSTACK),y
    682  1de1		       85 57		      sta	MQ+1
    683  1de3		       88		      dey
    684  1de4		       b1 48		      lda	(MATHSTACK),y
    685  1de6		       85 56		      sta	MQ
    686  1de8		       84 4a		      sty	MATHSTACKPTR
    687  1dea		       ac 58 2f 	      ldy	rtemp1
    688  1ded		       60		      rts
    689  1dee							;
    690  1dee							;=====================================================
    691  1dee							; This assists with multiplication and division by
    692  1dee							; looking at R0 and R1 and saving a flag as to what
    693  1dee							; sign the result will be.  Math is always done on
    694  1dee							; positive numbers, so this converts negative numbers
    695  1dee							; into positives.  On exit, R0 and R1 are both
    696  1dee							; positive.  If the signs were different then 'signs'
    697  1dee							; will be non-zero.
    698  1dee							;
    699  1dee		       a9 00	   SaveSigns  lda	#0
    700  1df0		       8d 57 2f 	      sta	sign	;assume positive
    701  1df3		       a5 53		      lda	R0+1	;MSB
    702  1df5		       10 13		      bpl	SaveSigns1
    703  1df7		       ee 57 2f 	      inc	sign	;it's negative
    704  1dfa		       49 ff		      eor	#$ff	;flip bits
    705  1dfc		       85 53		      sta	R0+1
    706  1dfe		       a5 52		      lda	R0
    707  1e00		       49 ff		      eor	#$ff
    708  1e02		       85 52		      sta	R0
    709  1e04		       e6 52		      inc	R0
    710  1e06		       d0 02		      bne	SaveSigns1
    711  1e08		       e6 53		      inc	R0+1
    712  1e0a		       a5 55	   SaveSigns1 lda	R1+1
    713  1e0c		       10 1a		      bpl	SaveSigns2
    714  1e0e		       48		      pha
    715  1e0f		       ad 57 2f 	      lda	sign
    716  1e12		       49 01		      eor	#1
    717  1e14		       8d 57 2f 	      sta	sign
    718  1e17		       68		      pla
    719  1e18		       49 ff		      eor	#$ff	;flip bits
    720  1e1a		       85 55		      sta	R1+1
    721  1e1c		       a5 54		      lda	R1
    722  1e1e		       49 ff		      eor	#$ff
    723  1e20		       85 54		      sta	R1
    724  1e22		       e6 54		      inc	R1
    725  1e24		       d0 02		      bne	SaveSigns2
    726  1e26		       e6 55		      inc	R1+1
    727  1e28		       60	   SaveSigns2 rts
    728  1e29							;
    729  1e29							;=====================================================
    730  1e29							; This looks at the value of 'signs' and will convert
    731  1e29							; both R0 and R1 to negative if set.
    732  1e29							;
    733  1e29				   RestoreSigns
    734  1e29		       ad 57 2f 	      lda	sign
    735  1e2c		       f0 28		      beq	restoresigns2
    736  1e2e							;
    737  1e2e		       a5 52		      lda	R0
    738  1e30		       d0 02		      bne	restoresigns3
    739  1e32		       c6 53		      dec	R0+1
    740  1e34				   restoresigns3
    741  1e34		       c6 52		      dec	R0
    742  1e36		       a5 52		      lda	R0
    743  1e38		       49 ff		      eor	#$ff
    744  1e3a		       85 52		      sta	R0
    745  1e3c		       a5 53		      lda	R0+1
    746  1e3e		       49 ff		      eor	#$ff
    747  1e40		       85 53		      sta	R0+1
    748  1e42							;
    749  1e42		       a5 54		      lda	R1
    750  1e44		       d0 02		      bne	restoresigns4
    751  1e46		       c6 55		      dec	R1+1
    752  1e48				   restoresigns4
    753  1e48		       c6 54		      dec	R1
    754  1e4a		       a5 54		      lda	R1
    755  1e4c		       49 ff		      eor	#$ff
    756  1e4e		       85 54		      sta	R1
    757  1e50		       a5 55		      lda	R1+1
    758  1e52		       49 ff		      eor	#$ff
    759  1e54		       85 55		      sta	R1+1
    760  1e56							;
    761  1e56				   restoresigns2
    762  1e56		       60		      rts
    763  1e57							;
    764  1e57							;=====================================================
    765  1e57							; Skip over spaces.  Returns Y with the offset to
    766  1e57							; either the last character in the line, or the first
    767  1e57							; non-space character.
    768  1e57							;
    769  1e57
    770  1e57		       c8	   skipsp2    iny
    771  1e58		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  1e5a		       f0 04		      beq	Skip3	;end of line
    773  1e5c		       c9 20		      cmp	#SPACE
    774  1e5e		       f0 f7		      beq	skipsp2
    775  1e60		       60	   Skip3      rts
    776  1e61							;*********************************************************
    777  1e61							; Output a CR/LF combination to the console.  Preserves
    778  1e61							; all registers.
    779  1e61							;
    780  1e61		       48	   tbcrlf     pha
    781  1e62		       a9 0d		      lda	#CR
    782  1e64		       20 af 1f 	      jsr	VOUTCH
    783  1e67		       a9 0a		      lda	#LF
    784  1e69		       20 af 1f 	      jsr	VOUTCH
    785  1e6c		       68		      pla
    786  1e6d		       60		      rts
    787  1e6e							;
    788  1e6e							;=====================================================
    789  1e6e							; Some logic to print the Line of basic code being executed
    790  1e6e		       24 40	   idbgBasic  bit	ILTrace
    791  1e70		       50 75		      bvc	dbgBasicNone
    792  1e72		       98		      tya
    793  1e73		       48		      pha
    794  1e74		       20 e3 1f 	      jsr	SetOutDebug
    795  1e77
    796  1e77		       a5 4f		      lda	CURPTR
    797  1e79		       85 59		      sta	dpl
    798  1e7b		       a5 50		      lda	CURPTR+1
    799  1e7d		       85 5a		      sta	dpl+1
    800  1e7f
    801  1e7f		       20 ca 14 	      jsr	PrintProgramLine
    802  1e82
    803  1e82		       a5 40		      lda	ILTrace
    804  1e84		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  1e86		       f0 5a		      beq	dbgBasicDone
    806  1e88		       20 fa 1f 	      jsr	SetInDebug
    807  1e8b		       20 32 14 	      jsr	puts
      0  1e8e					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1e8e		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  1ecb				   dbgBasicLoop
    810  1ecb		       20 b2 1f 	      jsr	VGETCH
    811  1ece		       20 61 1e 	      jsr	CRLF
    812  1ed1		       20 1e 20 	      jsr	SetInDebugEnd
    813  1ed4
    814  1ed4		       c9 73		      cmp	#'s	; Quit program
    815  1ed6		       f0 12		      beq	dbgBasicStop
    816  1ed8
    817  1ed8		       c9 64		      cmp	#'d	; Display Variables
    818  1eda		       d0 06		      bne	dbgBasicDone
    819  1edc
    820  1edc		       20 8d 14 	      jsr	PrintAllVars
    821  1edf		       18		      clc
    822  1ee0		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  1ee2
    824  1ee2		       20 11 20    dbgBasicDone jsr	SetOutDebugEnd
    825  1ee5		       68		      pla
    826  1ee6		       a8		      tay
    827  1ee7		       4c c2 02    dbgBasicNone jmp	NextIL
    828  1eea
    829  1eea				   dbgBasicStop
    830  1eea		       20 11 20 	      jsr	SetOutDebugEnd
    831  1eed		       68		      pla
    832  1eee		       a8		      tay
    833  1eef		       4c 34 06 	      jmp	iFIN
    834  1ef2							;
    835  1ef2							;=====================================================
    836  1ef2							; This is some debug logic which displays the current
    837  1ef2							; value of the ILPC and the line buffer.
    838  1ef2							;
    839  1ef2		       24 40	   dbgLine    bit	ILTrace
    840  1ef4		       30 01		      bmi	dbgPrt
    841  1ef6		       60		      rts
    842  1ef7				   dbgPrt
    843  1ef7		       20 e3 1f 	      jsr	SetOutDebug
    844  1efa		       20 32 14 	      jsr	puts
      0  1efd					      db	"ILPC: ",0
      1  1efd		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    846  1f04		       a5 44		      lda	ILPC+1
    847  1f06		       20 15 14 	      jsr	OUTHEX
    848  1f09		       a5 43		      lda	ILPC
    849  1f0b		       20 15 14 	      jsr	OUTHEX
    850  1f0e		       a9 20		      lda	#SPACE
    851  1f10		       20 af 1f 	      jsr	VOUTCH
    852  1f13		       a0 00		      ldy	#0
    853  1f15		       b1 43		      lda	(ILPC),y
    854  1f17		       20 15 14 	      jsr	OUTHEX
    855  1f1a							;
    856  1f1a							; Display the CURPTR value and offset
    857  1f1a							;
    858  1f1a		       20 32 14 	      jsr	puts
      0  1f1d					      db	", CURPTR: ",0
      1  1f1d		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    860  1f28		       a5 50		      lda	CURPTR+1
    861  1f2a		       20 15 14 	      jsr	OUTHEX
    862  1f2d		       a5 4f		      lda	CURPTR
    863  1f2f		       20 15 14 	      jsr	OUTHEX
    864  1f32		       a9 2b		      lda	#'+
    865  1f34		       20 af 1f 	      jsr	VOUTCH
    866  1f37		       a5 51		      lda	CUROFF
    867  1f39		       20 15 14 	      jsr	OUTHEX
    868  1f3c							;
    869  1f3c		       20 61 1e 	      jsr	CRLF
    870  1f3f		       20 11 20 	      jsr	SetOutDebugEnd
    871  1f42		       20 75 1f 	      jsr	ILChkRange
    872  1f45		       b0 02		      bcs	dbgLineErr
    873  1f47		       18		      clc
    874  1f48		       60		      rts
    875  1f49
    876  1f49				   dbgLineErr
    877  1f49		       20 e3 1f 	      jsr	SetOutDebug
    878  1f4c		       20 32 14 	      jsr	puts
      0  1f4f					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1f4f		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    880  1f70		       20 11 20 	      jsr	SetOutDebugEnd
    881  1f73		       38		      sec
    882  1f74		       60		      rts
    883  1f75
    884  1f75		       a5 44	   ILChkRange lda	ILPC+1
    885  1f77		       c9 22		      cmp	#IL>>8
    886  1f79		       90 18		      bcc	ILBadRange
    887  1f7b		       d0 06		      bne	ILChkHigh
    888  1f7d
    889  1f7d		       a5 43		      lda	ILPC
    890  1f7f		       c9 4c		      cmp	#IL&$ff
    891  1f81		       90 10		      bcc	ILBadRange
    892  1f83
    893  1f83		       a5 44	   ILChkHigh  lda	ILPC+1
    894  1f85		       c9 25		      cmp	#ILEND>>8
    895  1f87		       90 08		      bcc	ILGoodRange
    896  1f89		       d0 08		      bne	ILBadRange
    897  1f8b
    898  1f8b		       a5 43		      lda	ILPC
    899  1f8d		       c9 c8		      cmp	#ILEND&$ff
    900  1f8f		       b0 02		      bcs	ILBadRange
    901  1f91
    902  1f91		       18	   ILGoodRange clc
    903  1f92		       60		      rts
    904  1f93				   ILBadRange
    905  1f93		       38		      sec
    906  1f94		       60		      rts
    907  1f95
    908  1f95
    909  1f95							;=====================================================
    910  1f95							; Set output vector to the console output function
    911  1f95							;
    912  1f95				   SetOutConsole
    913  1f95		       48		      pha
    914  1f96		       a9 0c		      lda	#OUTCH&$ff
    915  1f98		       8d 5c 2f 	      sta	BOutVec
    916  1f9b		       a9 f0		      lda	#OUTCH>>8
    917  1f9d		       8d 5d 2f 	      sta	BOutVec+1
    918  1fa0		       68		      pla
    919  1fa1		       60		      rts
    920  1fa2
    921  1fa2				   SetInConsole
    922  1fa2		       48		      pha
    923  1fa3		       a9 09		      lda	#GETCH&$ff
    924  1fa5		       8d 5e 2f 	      sta	BInVec
    925  1fa8		       a9 f0		      lda	#GETCH>>8
    926  1faa		       8d 5f 2f 	      sta	BInVec+1
    927  1fad		       68		      pla
    928  1fae		       60		      rts
    929  1faf
    930  1faf							;=====================================================
    931  1faf							; Jump to the output/input function in BOutVec/BInVec
    932  1faf							;
    933  1faf		       6c 5c 2f    VOUTCH     jmp	(BOutVec)
    934  1fb2		       6c 5e 2f    VGETCH     jmp	(BInVec)
    935  1fb5
    936  1fb5
    937  1fb5							;====================================================
    938  1fb5							;Clear the terminal assume it is ansii or vt100
    939  1fb5							;
    940  1fb5				   iCLEARSCREEN
    941  1fb5		       20 32 14 	      jsr	puts
      0  1fb8					      db	$1b,'[,'2,'J,0
      1  1fb8		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    943  1fbd		       4c c2 02 	      jmp	NextIL
    944  1fc0
    945  1fc0							;====================================================
    946  1fc0							; Push true and false onto math stack
    947  1fc0				   pushTrue
    948  1fc0		       a9 ff		      lda	#$ff
    949  1fc2		       85 52	   pushTF     sta	R0
    950  1fc4		       85 53		      sta	R0+1
    951  1fc6		       20 16 1d 	      jsr	pushR0
    952  1fc9		       60		      rts
    953  1fca		       a9 00	   pushFalse  lda	#0
    954  1fcc		       f0 f4		      beq	pushTF
    955  1fce
    956  1fce							;======================================================
    957  1fce							; Copy stack top to R1
    958  1fce				   CopyStackR1
    959  1fce		       98		      tya
    960  1fcf		       48		      pha
    961  1fd0		       a4 4a		      ldy	MATHSTACKPTR
    962  1fd2		       88		      dey
    963  1fd3		       b1 48		      lda	(MATHSTACK),y
    964  1fd5		       85 55		      sta	R1+1
    965  1fd7		       88		      dey
    966  1fd8		       b1 48		      lda	(MATHSTACK),y
    967  1fda		       85 54		      sta	R1
    968  1fdc		       68		      pla
    969  1fdd		       a8		      tay
    970  1fde		       60		      rts
    971  1fdf
    972  1fdf
    973  1fdf							;====================================================
    974  1fdf							;Swap the out debug call for standard calls
    975  1fdf		       00 00	   DebugIOSave ds	2
    976  1fe1		       00 00	   DebugInSave ds	2
    977  1fe3				   SetOutDebug
    978  1fe3		       ad 5c 2f 	      lda	BOutVec
    979  1fe6		       8d df 1f 	      sta	DebugIOSave
    980  1fe9		       ad 5d 2f 	      lda	BOutVec+1
    981  1fec		       8d e0 1f 	      sta	DebugIOSave+1
    982  1fef		       a9 35		      lda	#OUTDEBUG&$ff	; Put the Debug output
    983  1ff1		       8d 5c 2f 	      sta	BOutVec
    984  1ff4		       a9 20		      lda	#OUTDEBUG>>8
    985  1ff6		       8d 5d 2f 	      sta	BOutVec+1
    986  1ff9		       60		      rts
    987  1ffa				   SetInDebug
    988  1ffa		       ad 5e 2f 	      lda	BInVec
    989  1ffd		       8d e1 1f 	      sta	DebugInSave
    990  2000		       ad 5f 2f 	      lda	BInVec+1
    991  2003		       8d e2 1f 	      sta	DebugInSave+1
    992  2006		       a9 39		      lda	#INDEBUG&$ff
    993  2008		       8d 5e 2f 	      sta	BInVec
    994  200b		       a9 20		      lda	#INDEBUG>>8
    995  200d		       8d 5f 2f 	      sta	BInVec+1
    996  2010		       60		      rts
    997  2011				   SetOutDebugEnd
    998  2011		       ad df 1f 	      lda	DebugIOSave
    999  2014		       8d 5c 2f 	      sta	BOutVec
   1000  2017		       ad e0 1f 	      lda	DebugIOSave+1
   1001  201a		       8d 5d 2f 	      sta	BOutVec+1
   1002  201d		       60		      rts
   1003  201e				   SetInDebugEnd
   1004  201e		       ad e1 1f 	      lda	DebugInSave
   1005  2021		       8d 5e 2f 	      sta	BInVec
   1006  2024		       ad e0 1f 	      lda	DebugIOSave+1
   1007  2027		       8d 5f 2f 	      sta	BInVec+1
   1008  202a		       60		      rts
   1009  202b							;
   1010  202b							;====================================================
   1011  202b							; Output to the debug console
   1012  202b							;     x = high address byte
   1013  202b							;     y = low address byte
   1014  202b							;     a = Terminator for string
   1015  202b				   DebugWrite
   1016  202b		       20 e3 1f 	      jsr	SetOutDebug
   1017  202e		       20 70 14 	      jsr	PrtStr
   1018  2031		       20 11 20 	      jsr	SetOutDebugEnd
   1019  2034		       60		      rts
   1020  2035
   1021  2035				   OUTDEBUG
   1022  2035		       8d		      .byte.b	$8D	; STA
   1023  2036		       01 e0	   DEBUGPORT  .word.w	$E001	;Dont check anything just output the byte
   1024  2038		       60		      RTS
   1025  2039
   1026  2039				   INDEBUG
   1027  2039		       ad		      .byte.b	$AD	; LDA
   1028  203a		       00 e0	   DEBUGPORTSTATUS .word.w	$E000
   1029  203c
   1030  203c		       29 01		      and	#$01
   1031  203e		       f0 f9		      beq	INDEBUG
   1032  2040
   1033  2040		       ad		      .byte.b	$AD	; LDA
   1034  2041		       01 e0	   DEBUGPORTIN .word.w	$E001
   1035  2043		       60		      rts
   1036  2044
   1037  2044							;======================================================================
   1038  2044							;Copy Quoted string to buffer, terminate with 0 byte
   1039  2044							; R0  Source tring points to tString type
   1040  2044							; x is terminator
   1041  2044							; R1 points to destinition location
   1042  2044							; On exit R0 contains length of copy Plus Term and leading bytes
   1043  2044
   1044  2044				   qstrcpy
   1045  2044		       20 16 1d 	      jsr	pushR0
   1046  2047		       20 94 20 	      jsr	IncR0	; point past the tString
   1047  204a		       20 94 20 	      jsr	IncR0	; Point Past the opening "
   1048  204d		       a2 22		      ldx	#'"	; copy Termination
   1049  204f		       20 69 20 	      jsr	pstrcpy
   1050  2052		       20 94 20 	      jsr	IncR0	; point to "
   1051  2055		       20 94 20 	      jsr	IncR0	; Point to next free byte
   1052  2058		       20 c0 1d 	      jsr	popR1
   1053  205b		       38		      sec
   1054  205c		       a5 52		      lda	R0
   1055  205e		       e5 54		      sbc	R1
   1056  2060		       85 52		      sta	R0
   1057  2062		       a5 53		      lda	R0+1
   1058  2064		       e5 55		      sbc	R1+1
   1059  2066		       85 53		      sta	R0+1
   1060  2068		       60		      rts
   1061  2069
   1062  2069							;=========================================================================
   1063  2069							;Copy string from R0 to R1, terminator in x
   1064  2069							; On exit    R0 contains the length of the copy
   1065  2069				   pstrcpy
   1066  2069		       a0 00		      ldy	#0
   1067  206b		       86 58		      stx	R2
   1068  206d
   1069  206d				   strcpyLoop
   1070  206d		       b1 52		      lda	(R0),y
   1071  206f		       c5 58		      cmp	R2
   1072  2071		       f0 0a		      beq	strcpyDone
   1073  2073		       91 54		      sta	(R1),y
   1074  2075		       20 94 20 	      jsr	IncR0
   1075  2078		       20 82 20 	      jsr	IncR1
   1076  207b		       90 f0		      bcc	strcpyLoop
   1077  207d				   strcpyDone
   1078  207d		       a9 00		      lda	#0
   1079  207f		       91 54		      sta	(R1),y
   1080  2081
   1081  2081		       60		      rts
   1082  2082
   1083  2082							;=========================================================================
   1084  2082							; on exit c is set on overflow
   1085  2082				   IncR1
   1086  2082		       48		      pha
   1087  2083		       18		      clc
   1088  2084		       a9 01		      lda	#1
   1089  2086		       65 54		      adc	R1
   1090  2088		       85 54		      sta	R1
   1091  208a		       90 06		      bcc	IncR1Done
   1092  208c		       a9 00		      lda	#0
   1093  208e		       65 55		      adc	R1+1
   1094  2090		       85 55		      sta	R1+1
   1095  2092				   IncR1Done
   1096  2092		       68		      pla
   1097  2093		       60		      rts
   1098  2094							;=========================================================================
   1099  2094							; on exit c is set on overflow
   1100  2094				   IncR0
   1101  2094		       48		      pha
   1102  2095		       18		      clc
   1103  2096		       a9 01		      lda	#1
   1104  2098		       65 52		      adc	R0
   1105  209a		       85 52		      sta	R0
   1106  209c		       90 06		      bcc	IncR0Done
   1107  209e		       a9 00		      lda	#0
   1108  20a0		       65 53		      adc	R0+1
   1109  20a2		       85 53		      sta	R0+1
   1110  20a4				   IncR0Done
   1111  20a4		       68		      pla
   1112  20a5		       60		      rts
   1113  20a6
   1114  20a6
   1115  20a6
   1116  20a6
   1117  20a6
   1118  20a6
   1119  20a6
   1120  20a6
   1121  20a6
   1122  20a6
   1123  20a6
   1124  20a6
   1125  20a6
   1126  20a6
   1127  20a6
   1128  20a6
------- FILE mytb.asm
   2399  20a6
   2400  20a6					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  20a6					      include	"storage.asm"
      1  20a6							;
      2  20a6							;=====================================================
      3  20a6							;=====================================================
      4  20a6							;=====================================================
      5  20a6							; This file contains the functions for saving and
      6  20a6							; restoring programs from some sort of mass storage
      7  20a6							; device.  This particular version is for using the
      8  20a6							; Corsham Tech SD Card System.
      9  20a6							;=====================================================
     10  20a6							;=====================================================
     11  20a6							;=====================================================
     12  20a6
     13 U25c8					      seg.u	TBData
     14 U25c8		       00	   diskBufLength ds	1
     15 U25c9		       00	   diskBufOffset ds	1
     16 U25ca		       00 00 00 00*DiskFileName ds	64
     17 U260a
     18  20a6					      SEG	Code
     19  20a6
     20  20a6							;
     21  20a6							;=====================================================
     22  20a6							; Open a file for reading as a program.  The next
     23  20a6							; thing on the line should be the filename.
     24  20a6							;
     25  20a6				   iOPENREAD
     26  20a6					      if	XKIM || CTMON65
     27  20a6		       20 c0 20 	      jsr	setFileName	;Set the file name to open
     28  20a9		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  20ac		       90 07		      bcc	Ropenok	;branch if opened ok
     30  20ae							;
     31  20ae							; Open failed
     32  20ae							;
     33  20ae		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  20b0		       a9 00	   Rdfail2    lda	#0
     35  20b2		       4c a7 06 	      jmp	iErr2
     36  20b5							;
     37  20b5							; Clear counts and offsets so the next read will
     38  20b5							; cause the file to be read.
     39  20b5							;
     40  20b5		       a9 00	   Ropenok    lda	#0
     41  20b7		       8d c9 25 	      sta	diskBufOffset
     42  20ba		       8d c8 25 	      sta	diskBufLength
     43  20bd		       4c c2 02 	      jmp	NextIL
     44  20c0					      endif
     45  20c0
     46  20c0							;===============================================================
     47  20c0							; Set file name
     48  20c0				   setFileName
     49  20c0		       a4 51		      ldy	CUROFF
     50  20c2		       b1 4f		      lda	(CURPTR),y
     51  20c4		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  20c6		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  20c8
     54  20c8		       18		      clc
     55  20c9		       98		      tya
     56  20ca		       65 4f		      adc	CURPTR
     57  20cc		       85 52		      sta	R0	;LSB
     58  20ce		       a5 50		      lda	CURPTR+1
     59  20d0		       69 00		      adc	#0
     60  20d2		       85 53		      sta	R0+1
     61  20d4		       a9 ca		      lda	#DiskFileName&$ff
     62  20d6		       85 54		      sta	R1
     63  20d8		       a9 25		      lda	#DiskFileName>>8
     64  20da		       85 55		      sta	R1+1
     65  20dc		       20 44 20 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  20df		       a5 52		      lda	R0
     67  20e1		       18		      clc
     68  20e2		       65 51		      adc	CUROFF	; add the current offset
     69  20e4		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  20e6
     71  20e6		       a0 ca		      ldy	#DiskFileName&$ff
     72  20e8		       a2 25		      ldx	#DiskFileName>>8
     73  20ea		       18		      clc
     74  20eb		       60		      rts
     75  20ec
     76  20ec				   setFileNameNotFound
     77  20ec		       68		      pla
     78  20ed		       68		      pla		; remove the return address from the stack
     79  20ee		       a9 00		      lda	#0
     80  20f0		       a2 09		      ldx	#ERR_NO_FILENAME
     81  20f2		       4c a7 06 	      jmp	iErr2
     82  20f5
     83  20f5							;
     84  20f5							;==============================JUSTLOSTINTIME 08/02/2022========
     85  20f5							;Remove a file from the disk
     86  20f5				   iRMFILE
     87  20f5					      if	XKIM || CTMON65
     88  20f5		       20 c0 20 	      jsr	setFileName
     89  20f8		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  20fb		       90 07		      bcc	wrmOk	;branch if removed ok
     91  20fd		       a9 00		      lda	#0
     92  20ff		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  2101		       4c a7 06 	      jmp	iErr2
     94  2104				   wrmOk
     95  2104		       4c c2 02 	      jmp	NextIL
     96  2107
     97  2107					      endif
     98  2107							;
     99  2107							;=====================================================
    100  2107				   iOPENWRITE
    101  2107					      if	XKIM || CTMON65
    102  2107		       20 c0 20 	      jsr	setFileName
    103  210a		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  210d		       90 07		      bcc	Wopenok	;branch if opened ok
    105  210f							;
    106  210f							; Open failed
    107  210f							;
    108  210f		       a9 00	   Wdfail     lda	#0
    109  2111		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  2113		       4c a7 06 	      jmp	iErr2
    111  2116							;
    112  2116		       4c c2 02    Wopenok    jmp	NextIL
    113  2119					      endif
    114  2119							;
    115  2119							;=====================================================
    116  2119							; Gets a line of input from the disk file and puts it
    117  2119							; into LINBUF.
    118  2119							;
    119  2119							; On exit:
    120  2119							;    CURPTR points to LINBUF
    121  2119							;    LINBUF contains the line with 0 at the end.
    122  2119							;    Y has offset to first non-space character
    123  2119							;    CURROFF has the same as Y.
    124  2119							;
    125  2119				   iDGETLINE
    126  2119					      if	XKIM || CTMON65
    127  2119		       a2 cb		      ldx	#LINBUF&$ff
    128  211b		       86 4f		      stx	CURPTR
    129  211d		       a2 2e		      ldx	#LINBUF>>8
    130  211f		       86 50		      stx	CURPTR+1
    131  2121							;
    132  2121		       a2 00		      ldx	#0	;offset
    133  2123		       8e 4f 2f    iDgetLoop  stx	getlinx
    134  2126		       20 91 21 	      jsr	getNextFileByte
    135  2129		       b0 16		      bcs	iGetEOF
    136  212b		       c9 0d		      cmp	#CR
    137  212d		       f0 0d		      beq	iGetEOL
    138  212f		       c9 0a		      cmp	#LF
    139  2131		       f0 09		      beq	iGetEOL
    140  2133		       ae 4f 2f 	      ldx	getlinx
    141  2136		       9d cb 2e 	      sta	LINBUF,x
    142  2139		       e8		      inx
    143  213a		       d0 e7		      bne	iDgetLoop
    144  213c							;
    145  213c							; Handle end of line.	If the line has nothing, loop
    146  213c							; back and get another line.
    147  213c							;
    148  213c		       ae 4f 2f    iGetEOL    ldx	getlinx	;blank line?
    149  213f		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  2141							;
    151  2141							; This can fall through when there is a line, or
    152  2141							; called directly when EOF is encountered.
    153  2141							;
    154  2141		       ae 4f 2f    iGetEOF    ldx	getlinx
    155  2144		       a9 00		      lda	#0
    156  2146		       9d cb 2e 	      sta	LINBUF,x
    157  2149		       a0 00		      ldy	#0
    158  214b		       20 58 1e 	      jsr	SkipSpaces
    159  214e		       20 d3 10 	      jsr	ParseInputLine
    160  2151		       a9 d0		      lda	#TOKENBUFFER&$ff
    161  2153		       85 4f		      sta	CURPTR
    162  2155		       a9 0f		      lda	#TOKENBUFFER>>8
    163  2157		       85 50		      sta	CURPTR+1
    164  2159		       a9 01		      lda	#1
    165  215b		       85 51		      sta	CUROFF
    166  215d		       4c c2 02 	      jmp	NextIL
    167  2160					      endif
    168  2160
    169  2160							;
    170  2160							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  2160							; DISK
    172  2160							;
    173  2160				   iDDIR
    174  2160					      if	XKIM || CTMON65
    175  2160		       20 30 f0 	      jsr	DiskDir
    176  2163							;
    177  2163							; Get/Display each entry
    178  2163							;
    179  2163		       a2 25	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  2165		       a0 ca		      ldy	#DiskFileName&$ff
    181  2167		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  216a		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  216c		       20 32 14 	      jsr	puts
      0  216f					      db	"   ",0
      1  216f		       20 20 20 00	      .byte.b	"   ",0
    185  2173							; Print the line to the console
    186  2173		       a2 25		      ldx	#DiskFileName>>8	;pointer to buffer
    187  2175		       a0 ca		      ldy	#DiskFileName&$ff
    188  2177		       a5 00		      lda	0
    189  2179		       20 70 14 	      jsr	PrtStr	;else print name
    190  217c		       20 18 f0 	      jsr	crlf
    191  217f
    192  217f		       4c 63 21 	      jmp	DiskDirLoop	;do next entry
    193  2182
    194  2182		       4c c2 02    DiskDirEnd jmp	NextIL
    195  2185					      endif
    196  2185							;
    197  2185							;=====================================================
    198  2185							; Does a LIST to a Disk file.
    199  2185							;
    200  2185				   iDLIST
    201  2185					      if	XKIM || CTMON65
    202  2185		       20 c0 21 	      jsr	SetOutDisk
    203  2188		       4c 25 08 	      jmp	iLST2
    204  218b					      endif
    205  218b							;
    206  218b							;=====================================================
    207  218b							; Closes any pending disk file.  Okay to call if there
    208  218b							; is no open file.
    209  218b							;
    210  218b				   iDCLOSE
    211  218b					      if	XKIM || CTMON65
    212  218b		       20 42 f0 	      jsr	DiskClose
    213  218e		       4c c2 02 	      jmp	NextIL
    214  2191					      endif
    215  2191							;
    216  2191							;=====================================================
    217  2191							; This gets the next byte from an open disk file.  If
    218  2191							; there are no more bytes left, this returns C set.
    219  2191							; Else, C is clear and A contains the character.
    220  2191							;
    221  2191				   getNextFileByte
    222  2191					      if	XKIM || CTMON65
    223  2191		       ae c9 25 	      ldx	diskBufOffset
    224  2194		       ec c8 25 	      cpx	diskBufLength
    225  2197		       d0 14		      bne	hasdata	;branch if still data
    226  2199							;
    227  2199							; There is no data left in the buffer, so read a
    228  2199							; block from the SD system.
    229  2199							;
    230  2199		       a9 84		      lda	#BUFFER_SIZE
    231  219b		       a2 df		      ldx	#buffer>>8
    232  219d		       a0 0a		      ldy	#buffer&$ff
    233  219f		       20 3c f0 	      jsr	DiskRead
    234  21a2		       b0 12		      bcs	getNextEof
    235  21a4							;
    236  21a4							; A contains the number of bytes actually read.
    237  21a4							;
    238  21a4		       8d c8 25 	      sta	diskBufLength	;save length
    239  21a7		       c9 00		      cmp	#0	;shouldn't happen
    240  21a9		       f0 0b		      beq	getNextEof
    241  21ab							;
    242  21ab		       a2 00		      ldx	#0
    243  21ad		       bd 0a df    hasdata    lda	buffer,x
    244  21b0		       e8		      inx
    245  21b1		       8e c9 25 	      stx	diskBufOffset
    246  21b4		       18		      clc
    247  21b5		       60		      rts
    248  21b6							;
    249  21b6		       a9 00	   getNextEof lda	#0
    250  21b8		       8d c9 25 	      sta	diskBufOffset
    251  21bb		       8d c8 25 	      sta	diskBufLength
    252  21be		       38		      sec
    253  21bf		       60		      rts
    254  21c0							;
    255  21c0							;=====================================================
    256  21c0							; Set output vector to the disk output function
    257  21c0							;
    258  21c0		       a9 cb	   SetOutDisk lda	#DOUT&$ff
    259  21c2		       8d 5c 2f 	      sta	BOutVec
    260  21c5		       a9 21		      lda	#DOUT/256
    261  21c7		       8d 5d 2f 	      sta	BOutVec+1
    262  21ca		       60		      rts
    263  21cb							;
    264  21cb							;=====================================================
    265  21cb
    266  21cb		       8e ca 25    DOUT       stx	DiskFileName
    267  21ce		       8c cb 25 	      sty	DiskFileName+1
    268  21d1		       8d 0a df 	      sta	buffer
    269  21d4		       a9 01		      lda	#1
    270  21d6		       a0 0a		      ldy	#buffer&$ff
    271  21d8		       a2 df		      ldx	#buffer>>8
    272  21da		       20 3f f0 	      jsr	DiskWrite
    273  21dd		       ae ca 25 	      ldx	DiskFileName
    274  21e0		       ac cb 25 	      ldy	DiskFileName+1
    275  21e3
    276  21e3							;
    277  21e3							; need error checking here
    278  21e3							;
    279  21e3		       60		      rts
    280  21e4					      endif
    281  21e4
    282  21e4
------- FILE mytb.asm
   2402  21e4					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  21e4					      include	"IL.inc"
      1  21e4
      2  21e4							;=====================================================
      3  21e4							; IL.inc
      4  21e4							; These are macros for IL instructions
      5  21e4							;
      6  21e4					      mac	dw
      7  21e4					      .word	{0}
      8  21e4					      endm
      9  21e4					      mac	db
     10  21e4					      .byte	{0}
     11  21e4					      endm
     12  21e4					      macro	xinit
     13  21e4					      db	0
     14  21e4					      endm		;reset the il to start clear all
     15  21e4							;
     16  21e4					      macro	done
     17  21e4					      db	1
     18  21e4					      endm		;print an error if not end of line
     19  21e4							;
     20  21e4					      macro	prs
     21  21e4					      db	2
     22  21e4					      endm		;print a quoted string
     23  21e4							;
     24  21e4					      macro	prn
     25  21e4					      db	3
     26  21e4					      endm		;print a number
     27  21e4							;
     28  21e4					      macro	spc
     29  21e4					      db	4
     30  21e4					      endm		;print space til new tabstop
     31  21e4							;
     32  21e4					      macro	nline
     33  21e4					      db	5
     34  21e4					      endm		;print a new line crlf
     35  21e4							;
     36  21e4							; My NXT is a bit different in that it takes one
     37  21e4							; parameter, which is an address.  If the BASIC
     38  21e4							; program is currently running then move to the
     39  21e4							; next line and continue execution.  However, if
     40  21e4							; in direct mode, jump to the specified IL label.
     41  21e4							;
     42  21e4					      macro	nxt
     43  21e4					      db	6
     44  21e4					      dw	{1}	; addr
     45  21e4					      endm		; addr
     46  21e4							;
     47  21e4					      macro	xfer
     48  21e4					      db	7
     49  21e4					      endm
     50  21e4							;
     51  21e4					      macro	sav
     52  21e4					      db	8
     53  21e4					      db	{1}
     54  21e4					      endm
     55  21e4							;
     56  21e4							;  Passed jump if function called, and true false value returned
     57  21e4					      macro	rstr
     58  21e4					      db	9
     59  21e4					      db	({1}-*)-1	;(addr-*)-1
     60  21e4					      db	{2}
     61  21e4					      endm
     62  21e4							;
     63  21e4					      macro	cmpr
     64  21e4					      db	10
     65  21e4					      endm
     66  21e4							;
     67  21e4					      macro	innum
     68  21e4					      db	11
     69  21e4					      endm
     70  21e4							;
     71  21e4					      macro	fin
     72  21e4					      db	12
     73  21e4					      endm
     74  21e4							;
     75  21e4							; ERR is followed by an error number.	The error
     76  21e4							; code is printed along with the line number.
     77  21e4							; Control is passed to the statement set with
     78  21e4							; the ERRGOTO statement.
     79  21e4							;
     80  21e4					      macro	errmsg
     81  21e4					      db	13
     82  21e4					      dw	{1}	;ecode
     83  21e4					      endm		;ecode
     84  21e4							;
     85  21e4					      macro	add
     86  21e4					      db	14
     87  21e4					      endm
     88  21e4							;
     89  21e4					      macro	sub
     90  21e4					      db	15
     91  21e4					      endm
     92  21e4							;
     93  21e4					      macro	neg
     94  21e4					      db	16
     95  21e4					      endm
     96  21e4							;
     97  21e4					      macro	mul
     98  21e4					      db	17
     99  21e4					      endm
    100  21e4							;
    101  21e4					      macro	div
    102  21e4					      db	18
    103  21e4					      endm
    104  21e4							;
    105  21e4					      macro	store
    106  21e4					      db	19
    107  21e4					      endm
    108  21e4							;
    109  21e4					      macro	ind
    110  21e4					      db	20
    111  21e4					      endm
    112  21e4							;
    113  21e4					      macro	lst
    114  21e4					      db	21
    115  21e4					      endm
    116  21e4							;
    117  21e4					      macro	init
    118  21e4					      db	22
    119  21e4					      endm
    120  21e4							;
    121  21e4					      macro	getline
    122  21e4					      db	23
    123  21e4					      endm
    124  21e4							;
    125  21e4					      macro	insert
    126  21e4					      db	24
    127  21e4					      endm
    128  21e4							;
    129  21e4					      macro	rtn
    130  21e4					      db	25
    131  21e4					      endm
    132  21e4							;
    133  21e4					      macro	exit
    134  21e4					      db	26
    135  21e4					      endm
    136  21e4							;
    137  21e4					      macro	lit
    138  21e4					      db	27
    139  21e4					      dw	{1}	;value
    140  21e4					      endm		; value LIT
    141  21e4							;
    142  21e4					      macro	call
    143  21e4					      db	28
    144  21e4					      dw	{1}	;addr
    145  21e4					      endm		;addr
    146  21e4							;
    147  21e4							; IJMP will set the IL PC to the specified value.
    148  21e4							;
    149  21e4					      macro	ijmp
    150  21e4					      db	29
    151  21e4					      dw	{1}	;addr
    152  21e4					      endm		;addr
    153  21e4							;
    154  21e4					      macro	vinit
    155  21e4					      db	30
    156  21e4					      endm
    157  21e4							;
    158  21e4							; ERRGOTO sets the point in the code where the IL
    159  21e4							; interpreter will go after any error.
    160  21e4							;
    161  21e4					      macro	errgoto
    162  21e4					      db	31
    163  21e4					      dw	{1}	;addr
    164  21e4					      endm		;addr
    165  21e4							;
    166  21e4					      macro	tst
    167  21e4					      db	32
    168  21e4					      db	({1}-*)-1	;(addr-*)-1
    169  21e4					      db	{2},0	;string,0
    170  21e4					      endm		;addr,string
    171  21e4							;
    172  21e4					      macro	tstv
    173  21e4					      db	33
    174  21e4					      db	({1}-*)-1	;(addr-*)-1
    175  21e4					      endm		;addr
    176  21e4							;
    177  21e4					      macro	tstl
    178  21e4					      db	34
    179  21e4					      db	({1}-*)-1	;(addr-*)-1
    180  21e4					      endm		;addr
    181  21e4							;
    182  21e4					      macro	tstn
    183  21e4					      db	35
    184  21e4					      db	({1}-*)-1	;(addr-*)-1
    185  21e4					      endm		;addr
    186  21e4							;
    187  21e4							; FREE returns the amount of free RAM on top of
    188  21e4							; the stack.  This is the amount of room the user
    189  21e4							; program has available.
    190  21e4							;
    191  21e4					      macro	free
    192  21e4					      db	36
    193  21e4					      endm
    194  21e4							;
    195  21e4							; RANDOM takes the top item off the stack and
    196  21e4							; replaces it with a random number that is
    197  21e4							; MOD the initial value.  Ie, if the TOS is
    198  21e4							; 42 then RANDOM returns a value from 0 to 41.
    199  21e4							;
    200  21e4					      macro	random
    201  21e4					      db	37
    202  21e4					      endm
    203  21e4							;
    204  21e4							; ABS will replace the top of stack with the
    205  21e4							; absolute value.
    206  21e4							;
    207  21e4					      macro	abs
    208  21e4					      db	38
    209  21e4					      endm
    210  21e4							;
    211  21e4							; OPENREAD opens a file for reading, as in getting
    212  21e4							; statements from it.
    213  21e4							;
    214  21e4					      macro	openread
    215  21e4					      db	39
    216  21e4					      endm
    217  21e4							;
    218  21e4							; OPENWRITE opens a file for writing, as in saving
    219  21e4							; the current program to it.
    220  21e4							;
    221  21e4					      macro	openwrite
    222  21e4					      db	40
    223  21e4					      endm
    224  21e4							;
    225  21e4							; DCLOSE closes any open disk file.
    226  21e4							;
    227  21e4					      macro	dclose
    228  21e4					      db	41
    229  21e4					      endm
    230  21e4							;
    231  21e4							; DGETLINE gets one line from the disk file and puts it
    232  21e4							; into LINBUFF.
    233  21e4							;
    234  21e4					      macro	dgetline
    235  21e4					      db	42
    236  21e4					      endm
    237  21e4							;
    238  21e4							; DLIST saves the program to an open disk file.
    239  21e4							;
    240  21e4					      macro	dlist
    241  21e4					      db	43
    242  21e4					      endm
    243  21e4							; DDIR list the current directory
    244  21e4							;
    245  21e4					      macro	ddir
    246  21e4					      db	44
    247  21e4					      endm
    248  21e4
    249  21e4							; RMFILE remove a fle from disk
    250  21e4					      macro	rmfile
    251  21e4					      db	45
    252  21e4					      endm
    253  21e4
    254  21e4							; CLEARSCREEN clear the screen
    255  21e4					      macro	clearscreen
    256  21e4					      db	46
    257  21e4					      endm
    258  21e4							; POKEMEM Poke value into memory
    259  21e4					      macro	pokemem
    260  21e4					      db	47
    261  21e4					      endm
    262  21e4							; PEEKMEM peek at value in memory
    263  21e4					      macro	peekmem
    264  21e4					      db	48
    265  21e4					      endm
    266  21e4							; TSTLET Test if the statement is a let without the keyword let
    267  21e4					      macro	tstlet
    268  21e4					      db	49
    269  21e4					      db	({1}-*)-1	;(addr-*)-1
    270  21e4					      endm		;addr
    271  21e4							; TSTDONE if we reach the end of a statement
    272  21e4					      macro	tstdone
    273  21e4					      db	50
    274  21e4					      db	({1}-*)-1	;(addr-*)-1
    275  21e4					      endm		;addr
    276  21e4							; GETCHAR	get a character from the input line leave it in RO
    277  21e4					      macro	getchar
    278  21e4					      db	51
    279  21e4					      endm
    280  21e4							; PUTCHAR	Put a character to the terminal
    281  21e4					      macro	putchar
    282  21e4					      db	52
    283  21e4					      endm
    284  21e4							; Call		Call a machine function return a to stack
    285  21e4					      macro	callfunc
    286  21e4					      db	53
    287  21e4					      endm
    288  21e4
    289  21e4							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    290  21e4					      macro	ibranch
    291  21e4					      db	54
    292  21e4					      endm
    293  21e4
    294  21e4							; TSTSTR	 Tests for the open quote in a string
    295  21e4					      macro	tststr
    296  21e4					      db	55
    297  21e4					      db	({1}-*)-1	;(addr-*)-1
    298  21e4					      endm
    299  21e4							; SETIRQ	Sets the line number to run when an irq happens irq 550
    300  21e4					      macro	setirq
    301  21e4					      db	56
    302  21e4					      endm
    303  21e4
    304  21e4							; TSTIRQ	Test for irq pending,
    305  21e4							;		if so push the IRQ LINE NUMBER into RO, onto stack
    306  21e4					      macro	tstirq
    307  21e4					      db	57
    308  21e4					      db	({1}-*)-1	;(addr-*)-1
    309  21e4					      endm
    310  21e4
    311  21e4							; IRET    return from interupt service
    312  21e4					      macro	iret
    313  21e4					      db	58
    314  21e4					      endm
    315  21e4
    316  21e4							; INSTR   read a string from the input
    317  21e4					      macro	instr
    318  21e4					      db	59
    319  21e4					      endm
    320  21e4
    321  21e4							; MODULO Returns the remainder of the division
    322  21e4					      macro	modulo
    323  21e4					      db	60
    324  21e4					      endm
    325  21e4							; Set a task line
    326  21e4					      macro	taskcreate
    327  21e4					      db	61
    328  21e4					      endm
    329  21e4							; End a task
    330  21e4					      macro	etask
    331  21e4					      db	62
    332  21e4					      endm
    333  21e4							; Skip to next task
    334  21e4					      macro	ntask
    335  21e4					      db	63
    336  21e4					      endm
    337  21e4							; Subscript
    338  21e4					      macro	subscript
    339  21e4					      db	64
    340  21e4					      endm
    341  21e4							; KILL Task
    342  21e4					      macro	taskkill
    343  21e4					      db	65
    344  21e4					      endm
    345  21e4							; STAT Task
    346  21e4					      macro	taskstat
    347  21e4					      db	66
    348  21e4					      endm
    349  21e4							;  output value as hex
    350  21e4					      macro	hexprt
    351  21e4					      db	67
    352  21e4					      endm
    353  21e4							;  Read in background has completed
    354  21e4					      macro	readcomplete
    355  21e4					      db	68
    356  21e4					      endm
    357  21e4							;  ReadInput line
    358  21e4					      macro	readstart
    359  21e4					      db	69
    360  21e4					      endm
    361  21e4							; Startio request
    362  21e4					      macro	startio
    363  21e4					      db	70
    364  21e4					      endm
    365  21e4							; Endio
    366  21e4					      macro	endio
    367  21e4					      db	71
    368  21e4					      endm
    369  21e4							; Logical not
    370  21e4					      macro	lognot
    371  21e4					      db	72
    372  21e4					      endm
    373  21e4							; Logical OR
    374  21e4					      macro	logor
    375  21e4					      db	73
    376  21e4					      endm
    377  21e4							;Logical and
    378  21e4					      macro	logand
    379  21e4					      db	74
    380  21e4					      endm
    381  21e4							;Logical XOR
    382  21e4					      macro	logxor
    383  21e4					      db	75
    384  21e4					      endm
    385  21e4							;Wait for task to complete, or list of tasks
    386  21e4					      macro	wtask
    387  21e4					      db	76
    388  21e4					      db	({1}-*)-1	;(addr-*)-1
    389  21e4					      endm
    390  21e4							;Get the current task id
    391  21e4					      MACRO	taskpid
    392  21e4					      db	77
    393  21e4					      endm
    394  21e4							;Trace the basic execution
    395  21e4					      Macro	traceprogram
    396  21e4					      db	78
    397  21e4					      endm
    398  21e4							;Do a basic program Trace
    399  21e4					      Macro	debugbasic
    400  21e4					      db	79
    401  21e4					      endm
    402  21e4
    403  21e4							; Inter Process communications instructions
    404  21e4					      Macro	ipcsend
    405  21e4					      db	80
    406  21e4					      endm
    407  21e4					      Macro	ipcreceive
    408  21e4					      db	81
    409  21e4					      endm
    410  21e4					      Macro	ipccheck
    411  21e4					      db	82
    412  21e4					      endm
    413  21e4					      Macro	ipcio
    414  21e4					      db	83
    415  21e4					      endm
    416  21e4					      Macro	pushmathstack
    417  21e4					      db	84
    418  21e4					      endm
    419  21e4					      Macro	popmathstack
    420  21e4					      db	85
    421  21e4					      endm
    422  21e4					      Macro	savemathstack
    423  21e4					      db	86
    424  21e4					      endm
    425  21e4					      Macro	restoremathstack
    426  21e4					      db	87
    427  21e4					      endm
    428  21e4					      Macro	incparmcount
    429  21e4					      db	88
    430  21e4					      endm
    431  21e4					      Macro	taskgetmathstack
    432  21e4					      db	89
    433  21e4					      endm
    434  21e4					      Macro	taskenable
    435  21e4					      db	90
    436  21e4					      endm
    437  21e4					      Macro	tasksuspend
    438  21e4					      db	91
    439  21e4					      endm
    440  21e4					      Macro	taskputmathptr
    441  21e4					      db	92
    442  21e4					      endm
    443  21e4							; Test for an extension type of variable that allows access to a tasks variables
    444  21e4							; Using  PID!<Var name>
    445  21e4					      Macro	tstvt
    446  21e4					      db	93
    447  21e4					      db	({1}-*)-1	;(addr-*)-1
    448  21e4					      endm
    449  21e4
    450  21e4							; Provide access to R2 for the IL program
    451  21e4					      Macro	setr2
    452  21e4					      db	94
    453  21e4					      db	{1}	; R2 is only one byte
    454  21e4					      endm
    455  21e4							;Move stack top to temp
    456  21e4					      Macro	stk2tmp
    457  21e4					      db	95
    458  21e4					      endm
    459  21e4
    460  21e4					      Macro	tmp2stk
    461  21e4					      db	96
    462  21e4					      endm
    463  21e4
    464  21e4					      Macro	tstbyte
    465  21e4					      db	97
    466  21e4					      db	({1}-*)-1	; (addr-*)-1 goto if match
    467  21e4					      dw	{2}	; address to check
    468  21e4					      db	{3}	; Value to compare
    469  21e4					      endm
    470  21e4
    471  21e4					      Macro	incvar
    472  21e4					      db	98
    473  21e4					      endm
    474  21e4					      Macro	decvar
    475  21e4					      db	99
    476  21e4					      endm
    477  21e4
    478  21e4					      Macro	slice
    479  21e4					      db	100
    480  21e4					      endm
    481  21e4
    482  21e4					      Macro	tstb
    483  21e4					      db	101
    484  21e4					      db	({1}-*)-1
    485  21e4					      db	{2}
    486  21e4					      endm
    487  21e4
    488  21e4					      Macro	tstw
    489  21e4					      db	102
    490  21e4					      db	({1}-*)-1
    491  21e4					      dw	{2}
    492  21e4					      endm
    493  21e4
    494  21e4					      Macro	ongoto
    495  21e4					      db	103
    496  21e4					      dw	{1}
    497  21e4					      dw	{2}
    498  21e4					      endm
    499  21e4
    500  21e4					      Macro	tstrelop
    501  21e4					      db	104
    502  21e4					      db	({1}-*)-1
    503  21e4					      endm
    504  21e4
    505  21e4
    506  21e4					      Macro	repeatline
    507  21e4					      db	105
    508  21e4					      endm
    509  21e4
    510  21e4							; Check for a precompiled branch, will take branch if precompiled value present
    511  21e4					      Macro	tstbranch
    512  21e4					      db	106
    513  21e4					      db	({1}-*)-1
    514  21e4					      endm
    515  21e4
    516  21e4					      Macro	fastxfer
    517  21e4					      db	107
    518  21e4					      endm
------- FILE mytb.asm
   2404  21e4							;
   2405  21e4				  -	      if	FIXED
   2406  21e4				  -	      org	$1000
   2407  21e4					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  21e4					      include	"basic.il"
      1  21e4					      seg	Code
      2  21e4							; on goto table
      3  21e4							; format :   first byte is value Base, subtracted from value found
      4  21e4							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  21e4				   BasicStmts
      0  21e4					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  21e4		       01 1f		      .byte.b	kBeginKey,(kKeyCount+1)
      0  21e6					      dw	ekLet
      1  21e6		       5f 22		      .word.w	ekLet
      0  21e8					      dw	ekInc
      1  21e8		       8d 22		      .word.w	ekInc
      0  21ea					      dw	ekDec
      1  21ea		       9d 22		      .word.w	ekDec
      0  21ec					      dw	ekIreturn
      1  21ec		       ad 22		      .word.w	ekIreturn
      0  21ee					      dw	ekIf
      1  21ee		       b2 22		      .word.w	ekIf
      0  21f0					      dw	ekThen
      1  21f0		       b8 22		      .word.w	ekThen
      0  21f2					      dw	ekGoto
      1  21f2		       bc 22		      .word.w	ekGoto
      0  21f4					      dw	ekGosub
      1  21f4		       d0 22		      .word.w	ekGosub
      0  21f6					      dw	ekReturn
      1  21f6		       d7 22		      .word.w	ekReturn
      0  21f8					      dw	ekRem
      1  21f8		       f7 22		      .word.w	ekRem
      0  21fa					      dw	ekPrint	; should be entry for print
      1  21fa		       fd 22		      .word.w	ekPrint
      0  21fc					      dw	ekTaske
      1  21fc		       4a 23		      .word.w	ekTaske
      0  21fe					      dw	ekTaskn
      1  21fe		       60 23		      .word.w	ekTaskn
      0  2200					      dw	ekTaskw
      1  2200		       67 23		      .word.w	ekTaskw
      0  2202					      dw	ekPoke
      1  2202		       82 23		      .word.w	ekPoke
      0  2204					      dw	ekPutch
      1  2204		       99 23		      .word.w	ekPutch
      0  2206					      dw	ekCls
      1  2206		       a4 23		      .word.w	ekCls
      0  2208					      dw	ekInput
      1  2208		       ab 23		      .word.w	ekInput
      0  220a					      dw	ekEnd
      1  220a		       d3 23		      .word.w	ekEnd
      0  220c					      dw	ekIrq
      1  220c		       d7 23		      .word.w	ekIrq
      0  220e					      dw	ekKill
      1  220e		       e2 23		      .word.w	ekKill
      0  2210					      dw	ekList
      1  2210		       ed 23		      .word.w	ekList
      0  2212					      dw	ekRun
      1  2212		       f2 23		      .word.w	ekRun
      0  2214					      dw	ekNew
      1  2214		       fb 23		      .word.w	ekNew
      0  2216					      dw	ekSlice
      1  2216		       ff 23		      .word.w	ekSlice
      0  2218					      dw	ekTrace
      1  2218		       0a 24		      .word.w	ekTrace
      0  221a					      dw	ekExit
      1  221a		       1b 24		      .word.w	ekExit
      0  221c					      dw	ekSave
      1  221c		       1c 24		      .word.w	ekSave
      0  221e					      dw	ekLoad
      1  221e		       22 24		      .word.w	ekLoad
      0  2220					      dw	ekErase
      1  2220		       35 24		      .word.w	ekErase
      0  2222					      dw	ekDir
      1  2222		       2e 24		      .word.w	ekDir
     38  2224							;
     39  2224							; Logical operators
      0  2224				   BasicLogical db	kOr,3
      1  2224		       21 03		      .byte.b	kOr,3
      0  2226					      dw	ekOr
      1  2226		       52 24		      .word.w	ekOr
      0  2228					      dw	ekXor
      1  2228		       57 24		      .word.w	ekXor
      0  222a					      dw	ekAnd
      1  222a		       4d 24		      .word.w	ekAnd
     44  222c
     45  222c							;functions returning values
     46  222c
      0  222c				   BasicFuncs db	kBeginFunc,kFuncCount
      1  222c		       24 0f		      .byte.b	kBeginFunc,kFuncCount
      0  222e					      dw	ekTrue
      1  222e		       b7 24		      .word.w	ekTrue
      0  2230					      dw	ekFalse
      1  2230		       bb 24		      .word.w	ekFalse
      0  2232					      dw	ekFree
      1  2232		       bf 24		      .word.w	ekFree
      0  2234					      dw	ekGetch
      1  2234		       c7 24		      .word.w	ekGetch
      0  2236					      dw	ekPeek
      1  2236		       cf 24		      .word.w	ekPeek
      0  2238					      dw	ekTask
      1  2238		       da 24		      .word.w	ekTask
      0  223a					      dw	ekIpcc
      1  223a		       26 25		      .word.w	ekIpcc
      0  223c					      dw	ekIpcs
      1  223c		       01 25		      .word.w	ekIpcs
      0  223e					      dw	ekIpcr
      1  223e		       12 25		      .word.w	ekIpcr
      0  2240					      dw	ekRnd
      1  2240		       31 25		      .word.w	ekRnd
      0  2242					      dw	ekStat
      1  2242		       4f 25		      .word.w	ekStat
      0  2244					      dw	ekAbs
      1  2244		       44 25		      .word.w	ekAbs
      0  2246					      dw	ekCall
      1  2246		       5c 25		      .word.w	ekCall
      0  2248					      dw	ekGofn
      1  2248		       75 25		      .word.w	ekGofn
      0  224a					      dw	ekPid
      1  224a		       5a 25		      .word.w	ekPid
     63  224c
     64  224c
     65  224c							;=====================================================
     66  224c							; This is the IL of the BASIC (or whatever) language.
     67  224c							; Because of the way macros are implemented by as65,
     68  224c							; labels can't be on the same line as a macro
     69  224c							; invocation, so that's why labels are on separate
     70  224c							; lines.
     71  224c							;
     72  224c		       22 4c	   IL	      equ	*
     73  224c
     74  224c							;THE IL CONTROL SECTION
     75  224c
     76  224c				   START
      0  224c					      INIT		;INITIALIZE
      0  224c					      db	22
      1  224c		       16		      .byte.b	22
      0  224d					      NLINE		;WRITE CRLF
      0  224d					      db	5
      1  224d		       05		      .byte.b	5
      0  224e					      ERRGOTO	CO	;where to go after an error
      0  224e					      db	31
      1  224e		       1f		      .byte.b	31
      0  224f					      dw	CO
      1  224f		       52 22		      .word.w	CO
      0  2251					      VINIT		;clear all variables
      0  2251					      db	30
      1  2251		       1e		      .byte.b	30
     81  2252							;
     82  2252							; This is where we jump to get a line of commands or
     83  2252							; a program from the user.
     84  2252							;
     85  2252				   CO
      0  2252					      GETLINE		;WRITE PROMPT AND GET LINE
      0  2252					      db	23
      1  2252		       17		      .byte.b	23
      0  2253					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  2253					      db	34
      1  2253		       22		      .byte.b	34
      0  2254					      db	(XEC-*)-1
      1  2254		       04		      .byte.b	(XEC-*)-1
      0  2255					      INSERT		;INSERT IT (MAY BE DELETE)
      0  2255					      db	24
      1  2255		       18		      .byte.b	24
      0  2256					      IJMP	CO
      0  2256					      db	29
      1  2256		       1d		      .byte.b	29
      0  2257					      dw	CO
      1  2257		       52 22		      .word.w	CO
     90  2259				   XEC
      0  2259					      XINIT		;INITIALIZE
      0  2259					      db	0
      1  2259		       00		      .byte.b	0
     92  225a							;============================================================================
     93  225a							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     94  225a							;
     95  225a				   STMT
      0  225a					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  225a					      db	79
      1  225a		       4f		      .byte.b	79
      0  225b					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  225b					      db	57
      1  225b		       39		      .byte.b	57
      0  225c					      db	(notirq-*)-1
      1  225c		       00		      .byte.b	(notirq-*)-1
     98  225d							;==========================================================================================
     99  225d							; Process a let statement implied or explicit.
    100  225d							;
    101  225d				   notirq
      0  225d					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  225d					      db	49
      1  225d		       31		      .byte.b	49
      0  225e					      db	(DoVector-*)-1
      1  225e		       29		      .byte.b	(DoVector-*)-1
    103  225f				   ekLet
      0  225f					      TSTV	ERRVEC2	; YES, PLACE VAR ADDRESS ON AESTK
      0  225f					      db	33
      1  225f		       21		      .byte.b	33
      0  2260					      db	(ERRVEC2-*)-1
      1  2260		       24		      .byte.b	(ERRVEC2-*)-1
      0  2261					      TSTB	LETSCONT,oBang	; allow to assign to another Tasks Variable
      0  2261					      db	101
      1  2261		       65		      .byte.b	101
      0  2262					      db	(LETSCONT-*)-1
      1  2262		       04		      .byte.b	(LETSCONT-*)-1
      0  2263					      db	oBang
      1  2263		       e8		      .byte.b	oBang
      0  2264					      IND
      0  2264					      db	20
      1  2264		       14		      .byte.b	20
      0  2265					      TSTVT	ERRVEC2
      0  2265					      db	93
      1  2265		       5d		      .byte.b	93
      0  2266					      db	(ERRVEC2-*)-1
      1  2266		       1e		      .byte.b	(ERRVEC2-*)-1
    108  2267
    109  2267				   LETSCONT
      0  2267					      TSTB	LETSQBRACKET,oEqual	; (This line originally omitted)
      0  2267					      db	101
      1  2267		       65		      .byte.b	101
      0  2268					      db	(LETSQBRACKET-*)-1
      1  2268		       04		      .byte.b	(LETSQBRACKET-*)-1
      0  2269					      db	oEqual
      1  2269		       f2		      .byte.b	oEqual
      0  226a					      IJMP	LETBE
      0  226a					      db	29
      1  226a		       1d		      .byte.b	29
      0  226b					      dw	LETBE
      1  226b		       7a 22		      .word.w	LETBE
    112  226d
    113  226d				   LETSQBRACKET 		; is this an array access ?
    114  226d
      0  226d					      TSTB	ERRVEC2,oLeftSQBracket	; [
      0  226d					      db	101
      1  226d		       65		      .byte.b	101
      0  226e					      db	(ERRVEC2-*)-1
      1  226e		       16		      .byte.b	(ERRVEC2-*)-1
      0  226f					      db	oLeftSQBracket
      1  226f		       e4		      .byte.b	oLeftSQBracket
      0  2270					      CALL	EXPR
      0  2270					      db	28
      1  2270		       1c		      .byte.b	28
      0  2271					      dw	EXPR
      1  2271		       3d 24		      .word.w	EXPR
      0  2273					      TSTB	ERRVEC2,oRightSQBracket	; ]
      0  2273					      db	101
      1  2273		       65		      .byte.b	101
      0  2274					      db	(ERRVEC2-*)-1
      1  2274		       10		      .byte.b	(ERRVEC2-*)-1
      0  2275					      db	oRightSQBracket
      1  2275		       e5		      .byte.b	oRightSQBracket
      0  2276					      SUBSCRIPT
      0  2276					      db	64
      1  2276		       40		      .byte.b	64
      0  2277					      TSTB	ERRVEC2,oEqual	; (This line originally omitted)
      0  2277					      db	101
      1  2277		       65		      .byte.b	101
      0  2278					      db	(ERRVEC2-*)-1
      1  2278		       0c		      .byte.b	(ERRVEC2-*)-1
      0  2279					      db	oEqual
      1  2279		       f2		      .byte.b	oEqual
    120  227a				   LETBE
    121  227a
      0  227a					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  227a					      db	28
      1  227a		       1c		      .byte.b	28
      0  227b					      dw	EXPR
      1  227b		       3d 24		      .word.w	EXPR
      0  227d					      DONE		; REPORT ERROR IF NOT NEXT
      0  227d					      db	1
      1  227d		       01		      .byte.b	1
      0  227e					      STORE		; STORE RESULT
      0  227e					      db	19
      1  227e		       13		      .byte.b	19
      0  227f					      NXT	CO	; AND SEQUENCE TO NEXT
      0  227f					      db	6
      1  227f		       06		      .byte.b	6
      0  2280					      dw	CO
      1  2280		       52 22		      .word.w	CO
      0  2282					      IJMP	STMT
      0  2282					      db	29
      1  2282		       1d		      .byte.b	29
      0  2283					      dw	STMT
      1  2283		       5a 22		      .word.w	STMT
    127  2285				   ERRVEC2
      0  2285					      IJMP	UNKNOWN
      0  2285					      db	29
      1  2285		       1d		      .byte.b	29
      0  2286					      dw	UNKNOWN
      1  2286		       39 24		      .word.w	UNKNOWN
    129  2288							;=============================================================
    130  2288							;Branch on a valid statement start
    131  2288				   DoVector
      0  2288					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  2288					      db	103
      1  2288		       67		      .byte.b	103
      0  2289					      dw	BasicStmts
      1  2289		       e4 21		      .word.w	BasicStmts
      0  228b					      dw	UNKNOWN
      1  228b		       39 24		      .word.w	UNKNOWN
    133  228d							;This will never return here!
    134  228d							;=============================================================
    135  228d							; Inc or dec a variable
    136  228d							;S1:
    137  228d							;	  TSTB	     S1Dec,kInc 		    ; Increment variable
    138  228d				   ekInc
      0  228d					      TSTV	ERRVEC2	; Verify we have a variable
      0  228d					      db	33
      1  228d		       21		      .byte.b	33
      0  228e					      db	(ERRVEC2-*)-1
      1  228e		       f6		      .byte.b	(ERRVEC2-*)-1
      0  228f					      TSTB	eDoInc,oBang	; Allow to inc or dec other tasks variables
      0  228f					      db	101
      1  228f		       65		      .byte.b	101
      0  2290					      db	(eDoInc-*)-1
      1  2290		       04		      .byte.b	(eDoInc-*)-1
      0  2291					      db	oBang
      1  2291		       e8		      .byte.b	oBang
      0  2292					      IND		; we just got a pid
      0  2292					      db	20
      1  2292		       14		      .byte.b	20
      0  2293					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  2293					      db	93
      1  2293		       5d		      .byte.b	93
      0  2294					      db	(ERRVEC2-*)-1
      1  2294		       f0		      .byte.b	(ERRVEC2-*)-1
    143  2295				   eDoInc
      0  2295					      INCVAR		; Do the increment of the variable
      0  2295					      db	98
      1  2295		       62		      .byte.b	98
      0  2296					      DONE		; Test for end of line or end of statement ":"
      0  2296					      db	1
      1  2296		       01		      .byte.b	1
      0  2297					      NXT	CO	; Get the next statement, branch CO if end of program
      0  2297					      db	6
      1  2297		       06		      .byte.b	6
      0  2298					      dw	CO
      1  2298		       52 22		      .word.w	CO
      0  229a					      IJMP	STMT	; Process the next statement
      0  229a					      db	29
      1  229a		       1d		      .byte.b	29
      0  229b					      dw	STMT
      1  229b		       5a 22		      .word.w	STMT
    148  229d							;S1Dec:
    149  229d							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    150  229d				   ekDec
      0  229d					      TSTV	ERRVEC2	; Must be followed by a variable
      0  229d					      db	33
      1  229d		       21		      .byte.b	33
      0  229e					      db	(ERRVEC2-*)-1
      1  229e		       e6		      .byte.b	(ERRVEC2-*)-1
      0  229f					      TSTB	eDoDec,oBang	; Allow to inc or dec other tasks variables
      0  229f					      db	101
      1  229f		       65		      .byte.b	101
      0  22a0					      db	(eDoDec-*)-1
      1  22a0		       04		      .byte.b	(eDoDec-*)-1
      0  22a1					      db	oBang
      1  22a1		       e8		      .byte.b	oBang
      0  22a2					      IND		; we just got a pid
      0  22a2					      db	20
      1  22a2		       14		      .byte.b	20
      0  22a3					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  22a3					      db	93
      1  22a3		       5d		      .byte.b	93
      0  22a4					      db	(ERRVEC2-*)-1
      1  22a4		       e0		      .byte.b	(ERRVEC2-*)-1
    155  22a5				   eDoDec
      0  22a5					      DECVAR		; Decrement the actual variable
      0  22a5					      db	99
      1  22a5		       63		      .byte.b	99
      0  22a6					      DONE		; Test if end of line or : statement
      0  22a6					      db	1
      1  22a6		       01		      .byte.b	1
      0  22a7					      NXT	CO	; If at end of program then got the console
      0  22a7					      db	6
      1  22a7		       06		      .byte.b	6
      0  22a8					      dw	CO
      1  22a8		       52 22		      .word.w	CO
      0  22aa					      IJMP	STMT	; Process the next statement of command line
      0  22aa					      db	29
      1  22aa		       1d		      .byte.b	29
      0  22ab					      dw	STMT
      1  22ab		       5a 22		      .word.w	STMT
    160  22ad							;=============================================================================================================================
    161  22ad							; iret or ireturn, Return from interupt process
    162  22ad							;
    163  22ad							;S1Iret:
    164  22ad							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    165  22ad							;S1Sa:
    166  22ad				   ekIreturn
      0  22ad					      DONE		; Must be only thing on the line
      0  22ad					      db	1
      1  22ad		       01		      .byte.b	1
      0  22ae					      IRET		; RESTORE LINE NUMBER OF CALL
      0  22ae					      db	58
      1  22ae		       3a		      .byte.b	58
      0  22af					      IJMP	STMT
      0  22af					      db	29
      1  22af		       1d		      .byte.b	29
      0  22b0					      dw	STMT
      1  22b0		       5a 22		      .word.w	STMT
    170  22b2							;==============================================================================================================================
    171  22b2							;Process if statement, if true then process all statements until end of line reached
    172  22b2							;S1S1:
    173  22b2							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    174  22b2				   ekIf
      0  22b2					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  22b2					      db	28
      1  22b2		       1c		      .byte.b	28
      0  22b3					      dw	EXPR
      1  22b3		       3d 24		      .word.w	EXPR
      0  22b5					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  22b5					      db	101
      1  22b5		       65		      .byte.b	101
      0  22b6					      db	(S1W-*)-1
      1  22b6		       01		      .byte.b	(S1W-*)-1
      0  22b7					      db	kThen
      1  22b7		       06		      .byte.b	kThen
    177  22b8				   ekThen
    178  22b8				   S1W
      0  22b8					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  22b8					      db	54
      1  22b8		       36		      .byte.b	54
      0  22b9					      IJMP	STMT
      0  22b9					      db	29
      1  22b9		       1d		      .byte.b	29
      0  22ba					      dw	STMT
      1  22ba		       5a 22		      .word.w	STMT
    181  22bc							;===============================================================================================================================
    182  22bc							; Test for GOTO
    183  22bc							;S1Z:
    184  22bc							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    185  22bc							;
    186  22bc				   ekGoto
      0  22bc					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  22bc					      db	106
      1  22bc		       6a		      .byte.b	106
      0  22bd					      db	(ekGotoCompiled-*)-1
      1  22bd		       0e		      .byte.b	(ekGotoCompiled-*)-1
    188  22be							; Else we have the address ad just goto that address
      0  22be					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  22be					      db	101
      1  22be		       65		      .byte.b	101
      0  22bf					      db	(ekGotoLine-*)-1
      1  22bf		       05		      .byte.b	(ekGotoLine-*)-1
      0  22c0					      db	oPeriod
      1  22c0		       e9		      .byte.b	oPeriod
      0  22c1					      REPEATLINE		; Repeat the same line again
      0  22c1					      db	105
      1  22c1		       69		      .byte.b	105
      0  22c2					      IJMP	STMT	; Go do the statement
      0  22c2					      db	29
      1  22c2		       1d		      .byte.b	29
      0  22c3					      dw	STMT
      1  22c3		       5a 22		      .word.w	STMT
    192  22c5
    193  22c5				   ekGotoLine
      0  22c5					      CALL	EXPR	; GET LABEL
      0  22c5					      db	28
      1  22c5		       1c		      .byte.b	28
      0  22c6					      dw	EXPR
      1  22c6		       3d 24		      .word.w	EXPR
      0  22c8					      lit	0	; Place indicator for line num on stack
      0  22c8					      db	27
      1  22c8		       1b		      .byte.b	27
      0  22c9					      dw	0
      1  22c9		       00 00		      .word.w	0
      0  22cb					      FASTXFER
      0  22cb					      db	107
      1  22cb		       6b		      .byte.b	107
    197  22cc				   ekGotoCompiled
      0  22cc					      lit	1	; tell it that mempointer on the stack
      0  22cc					      db	27
      1  22cc		       1b		      .byte.b	27
      0  22cd					      dw	1
      1  22cd		       01 00		      .word.w	1
      0  22cf					      FASTXFER		; put top of stack into curptr
      0  22cf					      db	107
      1  22cf		       6b		      .byte.b	107
    200  22d0
    201  22d0							;===============================================================================================================================
    202  22d0							; Process gosub / function
    203  22d0							;
    204  22d0							;S2:
    205  22d0							;	  TSTB	     S2b,kGosub 		    ; ERROR IF NO MATCH
    206  22d0				   ekGosub
      0  22d0					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  22d0					      db	28
      1  22d0		       1c		      .byte.b	28
      0  22d1					      dw	GOSUBSTATEMENT
      1  22d1		       a1 25		      .word.w	GOSUBSTATEMENT
      0  22d3					      DONE		; ERROR IF CR NOT NEXT
      0  22d3					      db	1
      1  22d3		       01		      .byte.b	1
      0  22d4					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  22d4					      db	8
      1  22d4		       08		      .byte.b	8
      0  22d5					      db	GOSUB_RTN
      1  22d5		       01		      .byte.b	GOSUB_RTN
      0  22d6					      FASTXFER		; AND JUMP to sub rtn
      0  22d6					      db	107
      1  22d6		       6b		      .byte.b	107
    211  22d7							;
    212  22d7							; End of gosub processing
    213  22d7							;===============================================================================================================================
    214  22d7							; Return from a gosub
    215  22d7							;S2b:
    216  22d7							;	  TSTB	    S2a,kReturn 		   ; Speed up pocessing but more memory
    217  22d7				   ekReturn
      0  22d7					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  22d7					      db	101
      1  22d7		       65		      .byte.b	101
      0  22d8					      db	(S2NoReturnValue-*)-1
      1  22d8		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  22d9					      db	oLeftBracket
      1  22d9		       e0		      .byte.b	oLeftBracket
      0  22da					      CALL	EXPR
      0  22da					      db	28
      1  22da		       1c		      .byte.b	28
      0  22db					      dw	EXPR
      1  22db		       3d 24		      .word.w	EXPR
      0  22dd					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  22dd					      db	101
      1  22dd		       65		      .byte.b	101
      0  22de					      db	(ERRVEC2-*)-1
      1  22de		       a6		      .byte.b	(ERRVEC2-*)-1
      0  22df					      db	oRightBracket
      1  22df		       e1		      .byte.b	oRightBracket
      0  22e0					      DONE
      0  22e0					      db	1
      1  22e0		       01		      .byte.b	1
      0  22e1					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  22e1					      db	9
      1  22e1		       09		      .byte.b	9
      0  22e2					      db	(S2RetFunc-*)-1
      1  22e2		       11		      .byte.b	(S2RetFunc-*)-1
      0  22e3					      db	1
      1  22e3		       01		      .byte.b	1
      0  22e4					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  22e4					      db	6
      1  22e4		       06		      .byte.b	6
      0  22e5					      dw	CO
      1  22e5		       52 22		      .word.w	CO
      0  22e7					      IJMP	STMT	; Process the new statement
      0  22e7					      db	29
      1  22e7		       1d		      .byte.b	29
      0  22e8					      dw	STMT
      1  22e8		       5a 22		      .word.w	STMT
    225  22ea
    226  22ea				   S2NoReturnValue
      0  22ea					      DONE
      0  22ea					      db	1
      1  22ea		       01		      .byte.b	1
      0  22eb					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  22eb					      db	9
      1  22eb		       09		      .byte.b	9
      0  22ec					      db	(S2RetFunc-*)-1
      1  22ec		       07		      .byte.b	(S2RetFunc-*)-1
      0  22ed					      db	0
      1  22ed		       00		      .byte.b	0
      0  22ee					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  22ee					      db	6
      1  22ee		       06		      .byte.b	6
      0  22ef					      dw	CO
      1  22ef		       52 22		      .word.w	CO
      0  22f1					      IJMP	STMT	; Process the new statement
      0  22f1					      db	29
      1  22f1		       1d		      .byte.b	29
      0  22f2					      dw	STMT
      1  22f2		       5a 22		      .word.w	STMT
    231  22f4
    232  22f4				   S2RetFunc
      0  22f4					      IJMP	GOFNRet	; Back into the Function
      0  22f4					      db	29
      1  22f4		       1d		      .byte.b	29
      0  22f5					      dw	GOFNRet
      1  22f5		       7b 25		      .word.w	GOFNRet
    234  22f7							;
    235  22f7							; End of return from gosub
    236  22f7							;==================================================================================================================================
    237  22f7							; Process REM statement
    238  22f7							;
    239  22f7							;S2a:
    240  22f7							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    241  22f7				   ekRem
      0  22f7					      NXT	CO	; The rest of the line is ignored
      0  22f7					      db	6
      1  22f7		       06		      .byte.b	6
      0  22f8					      dw	CO
      1  22f8		       52 22		      .word.w	CO
      0  22fa					      IJMP	STMT	; Process the next statement
      0  22fa					      db	29
      1  22fa		       1d		      .byte.b	29
      0  22fb					      dw	STMT
      1  22fb		       5a 22		      .word.w	STMT
    244  22fd							;==================================================================================================================================
    245  22fd							; Print statement
    246  22fd							;
    247  22fd							;S3:
    248  22fd							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    249  22fd				   ekPrint
      0  22fd					      STARTIO		; Lock task until io completes
      0  22fd					      db	70
      1  22fd		       46		      .byte.b	70
    251  22fe				   S4
      0  22fe					      TSTDONE	S4a	; Test if we just want crlf printed
      0  22fe					      db	50
      1  22fe		       32		      .byte.b	50
      0  22ff					      db	(S4a-*)-1
      1  22ff		       03		      .byte.b	(S4a-*)-1
      0  2300					      IJMP	S6
      0  2300					      db	29
      1  2300		       1d		      .byte.b	29
      0  2301					      dw	S6
      1  2301		       18 23		      .word.w	S6
    254  2303
    255  2303				   S4a
      0  2303					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  2303					      db	101
      1  2303		       65		      .byte.b	101
      0  2304					      db	(S7-*)-1
      1  2304		       1f		      .byte.b	(S7-*)-1
      0  2305					      db	tString
      1  2305		       a0		      .byte.b	tString
      0  2306					      PRS		; PRINT STRING
      0  2306					      db	2
      1  2306		       02		      .byte.b	2
    258  2307				   S5
      0  2307					      TSTB	S6A,oComma	; IS THERE MORE?
      0  2307					      db	101
      1  2307		       65		      .byte.b	101
      0  2308					      db	(S6A-*)-1
      1  2308		       07		      .byte.b	(S6A-*)-1
      0  2309					      db	oComma
      1  2309		       e2		      .byte.b	oComma
      0  230a					      SPC		; SPACE TO NEXT ZONE
      0  230a					      db	4
      1  230a		       04		      .byte.b	4
      0  230b					      TSTDONE	S4	; Not end of line jump back
      0  230b					      db	50
      1  230b		       32		      .byte.b	50
      0  230c					      db	(S4-*)-1
      1  230c		       f1		      .byte.b	(S4-*)-1
      0  230d					      IJMP	S6Z	; YES JUMP BACK
      0  230d					      db	29
      1  230d		       1d		      .byte.b	29
      0  230e					      dw	S6Z
      1  230e		       1a 23		      .word.w	S6Z
    263  2310
    264  2310							;
    265  2310							; If a semicolon, don't do anything.
    266  2310							;
    267  2310				   S6A
      0  2310					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  2310					      db	101
      1  2310		       65		      .byte.b	101
      0  2311					      db	(S6-*)-1
      1  2311		       06		      .byte.b	(S6-*)-1
      0  2312					      db	oSemiColon
      1  2312		       e3		      .byte.b	oSemiColon
      0  2313					      TSTDONE	S4	; Jump Back if not end of line
      0  2313					      db	50
      1  2313		       32		      .byte.b	50
      0  2314					      db	(S4-*)-1
      1  2314		       e9		      .byte.b	(S4-*)-1
      0  2315					      IJMP	S6Z
      0  2315					      db	29
      1  2315		       1d		      .byte.b	29
      0  2316					      dw	S6Z
      1  2316		       1a 23		      .word.w	S6Z
    271  2318
    272  2318				   S6
    273  2318
      0  2318					      DONE		; ERROR IF CR NOT NEXT
      0  2318					      db	1
      1  2318		       01		      .byte.b	1
      0  2319					      NLINE
      0  2319					      db	5
      1  2319		       05		      .byte.b	5
    276  231a				   S6Z
      0  231a					      ENDIO		; release task io completed
      0  231a					      db	71
      1  231a		       47		      .byte.b	71
      0  231b					      NXT	CO	; exit here if , or ; at end of print
      0  231b					      db	6
      1  231b		       06		      .byte.b	6
      0  231c					      dw	CO
      1  231c		       52 22		      .word.w	CO
      0  231e					      IJMP	STMT
      0  231e					      db	29
      1  231e		       1d		      .byte.b	29
      0  231f					      dw	STMT
      1  231f		       5a 22		      .word.w	STMT
    280  2321							;
    281  2321							; A jump for code too far away for relative branch
    282  2321							;
    283  2321				   ERRVEC
      0  2321					      IJMP	UNKNOWN
      0  2321					      db	29
      1  2321		       1d		      .byte.b	29
      0  2322					      dw	UNKNOWN
      1  2322		       39 24		      .word.w	UNKNOWN
    285  2324							;
    286  2324							; Get here if there is an expression to print
    287  2324				   S7
      0  2324					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  2324					      db	101
      1  2324		       65		      .byte.b	101
      0  2325					      db	(S7AUnsigned-*)-1
      1  2325		       08		      .byte.b	(S7AUnsigned-*)-1
      0  2326					      db	oDollar
      1  2326		       e7		      .byte.b	oDollar
      0  2327					      CALL	EXPR
      0  2327					      db	28
      1  2327		       1c		      .byte.b	28
      0  2328					      dw	EXPR
      1  2328		       3d 24		      .word.w	EXPR
      0  232a					      HEXPRT
      0  232a					      db	67
      1  232a		       43		      .byte.b	67
      0  232b					      IJMP	S5
      0  232b					      db	29
      1  232b		       1d		      .byte.b	29
      0  232c					      dw	S5
      1  232c		       07 23		      .word.w	S5
    292  232e
    293  232e				   S7AUnsigned
    294  232e
      0  232e					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  232e					      db	101
      1  232e		       65		      .byte.b	101
      0  232f					      db	(S7A-*)-1
      1  232f		       0a		      .byte.b	(S7A-*)-1
      0  2330					      db	oPercent
      1  2330		       ed		      .byte.b	oPercent
      0  2331					      CALL	EXPR
      0  2331					      db	28
      1  2331		       1c		      .byte.b	28
      0  2332					      dw	EXPR
      1  2332		       3d 24		      .word.w	EXPR
      0  2334					      SETR2	1
      0  2334					      db	94
      1  2334		       5e		      .byte.b	94
      0  2335					      db	1
      1  2335		       01		      .byte.b	1
      0  2336					      PRN
      0  2336					      db	3
      1  2336		       03		      .byte.b	3
      0  2337					      IJMP	S5
      0  2337					      db	29
      1  2337		       1d		      .byte.b	29
      0  2338					      dw	S5
      1  2338		       07 23		      .word.w	S5
    300  233a
    301  233a				   S7A
    302  233a
      0  233a					      CALL	EXPR
      0  233a					      db	28
      1  233a		       1c		      .byte.b	28
      0  233b					      dw	EXPR
      1  233b		       3d 24		      .word.w	EXPR
      0  233d					      TSTB	S7B,oDollar	; Print the value as a single character
      0  233d					      db	101
      1  233d		       65		      .byte.b	101
      0  233e					      db	(S7B-*)-1
      1  233e		       05		      .byte.b	(S7B-*)-1
      0  233f					      db	oDollar
      1  233f		       e7		      .byte.b	oDollar
      0  2340					      PUTCHAR
      0  2340					      db	52
      1  2340		       34		      .byte.b	52
      0  2341					      IJMP	S5
      0  2341					      db	29
      1  2341		       1d		      .byte.b	29
      0  2342					      dw	S5
      1  2342		       07 23		      .word.w	S5
    307  2344
    308  2344				   S7B
      0  2344					      SETR2	0	; Print the value as a signed number
      0  2344					      db	94
      1  2344		       5e		      .byte.b	94
      0  2345					      db	0
      1  2345		       00		      .byte.b	0
      0  2346					      PRN		; PRINT IT
      0  2346					      db	3
      1  2346		       03		      .byte.b	3
      0  2347					      IJMP	S5	; IS THERE MORE?
      0  2347					      db	29
      1  2347		       1d		      .byte.b	29
      0  2348					      dw	S5
      1  2348		       07 23		      .word.w	S5
    312  234a							;
    313  234a							;===========================================================
    314  234a							; PROCESS ALL THE TASK STATEMENTS
    315  234a							;
    316  234a							;S8:
    317  234a							;	  TSTB	      S8G,kTaske		 ; End Task
    318  234a				   ekTaske
      0  234a					      TSTB	S8NoParm,oLeftBracket
      0  234a					      db	101
      1  234a		       65		      .byte.b	101
      0  234b					      db	(S8NoParm-*)-1
      1  234b		       0c		      .byte.b	(S8NoParm-*)-1
      0  234c					      db	oLeftBracket
      1  234c		       e0		      .byte.b	oLeftBracket
      0  234d					      CALL	EXPR
      0  234d					      db	28
      1  234d		       1c		      .byte.b	28
      0  234e					      dw	EXPR
      1  234e		       3d 24		      .word.w	EXPR
      0  2350					      TSTB	UNKNOWNLnk,oRightBracket
      0  2350					      db	101
      1  2350		       65		      .byte.b	101
      0  2351					      db	(UNKNOWNLnk-*)-1
      1  2351		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  2352					      db	oRightBracket
      1  2352		       e1		      .byte.b	oRightBracket
      0  2353					      ETASK
      0  2353					      db	62
      1  2353		       3e		      .byte.b	62
      0  2354					      DONE
      0  2354					      db	1
      1  2354		       01		      .byte.b	1
      0  2355					      IJMP	STMT
      0  2355					      db	29
      1  2355		       1d		      .byte.b	29
      0  2356					      dw	STMT
      1  2356		       5a 22		      .word.w	STMT
    325  2358				   S8NoParm
      0  2358					      LIT	0
      0  2358					      db	27
      1  2358		       1b		      .byte.b	27
      0  2359					      dw	0
      1  2359		       00 00		      .word.w	0
      0  235b					      ETASK
      0  235b					      db	62
      1  235b		       3e		      .byte.b	62
      0  235c					      DONE		; Must be last thing on a line
      0  235c					      db	1
      1  235c		       01		      .byte.b	1
      0  235d					      IJMP	STMT
      0  235d					      db	29
      1  235d		       1d		      .byte.b	29
      0  235e					      dw	STMT
      1  235e		       5a 22		      .word.w	STMT
    330  2360							;
    331  2360							;===========================================================
    332  2360							; The task gives up the rest of the cycles
    333  2360							;S8G:
    334  2360							;	  TSTB	      S8a,kTaskn	 ;Next task
    335  2360				   ekTaskn
      0  2360					      NTASK
      0  2360					      db	63
      1  2360		       3f		      .byte.b	63
      0  2361					      NXT	CO	;Next statement to execute
      0  2361					      db	6
      1  2361		       06		      .byte.b	6
      0  2362					      dw	CO
      1  2362		       52 22		      .word.w	CO
      0  2364					      IJMP	STMT
      0  2364					      db	29
      1  2364		       1d		      .byte.b	29
      0  2365					      dw	STMT
      1  2365		       5a 22		      .word.w	STMT
    339  2367							;
    340  2367							;===========================================================
    341  2367							; Waits for a task or list of tasks to complete
    342  2367							;S8a:
    343  2367							;	 TSTB	     S8a1,kTaskw		;Wait for tasks
    344  2367				   ekTaskw
      0  2367					      TSTB	UNKNOWNLnk,oLeftBracket
      0  2367					      db	101
      1  2367		       65		      .byte.b	101
      0  2368					      db	(UNKNOWNLnk-*)-1
      1  2368		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  2369					      db	oLeftBracket
      1  2369		       e0		      .byte.b	oLeftBracket
    346  236a				   S8TSK
      0  236a					      Call	EXPR	;Gets the PID of task to wait for
      0  236a					      db	28
      1  236a		       1c		      .byte.b	28
      0  236b					      dw	EXPR
      1  236b		       3d 24		      .word.w	EXPR
    348  236d				   S8LOOP
      0  236d					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  236d					      db	76
      1  236d		       4c		      .byte.b	76
      0  236e					      db	(S8LOOP-*)-1
      1  236e		       fe		      .byte.b	(S8LOOP-*)-1
      0  236f					      TSTB	S8aa,oComma	;Checks for more tasks
      0  236f					      db	101
      1  236f		       65		      .byte.b	101
      0  2370					      db	(S8aa-*)-1
      1  2370		       04		      .byte.b	(S8aa-*)-1
      0  2371					      db	oComma
      1  2371		       e2		      .byte.b	oComma
      0  2372					      IJMP	S8TSK	;Go for the next task number
      0  2372					      db	29
      1  2372		       1d		      .byte.b	29
      0  2373					      dw	S8TSK
      1  2373		       6a 23		      .word.w	S8TSK
    352  2375				   S8aa
      0  2375					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  2375					      db	101
      1  2375		       65		      .byte.b	101
      0  2376					      db	(UNKNOWNLnk-*)-1
      1  2376		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  2377					      db	oRightBracket
      1  2377		       e1		      .byte.b	oRightBracket
      0  2378					      DONE
      0  2378					      db	1
      1  2378		       01		      .byte.b	1
      0  2379					      NXT	CO
      0  2379					      db	6
      1  2379		       06		      .byte.b	6
      0  237a					      dw	CO
      1  237a		       52 22		      .word.w	CO
      0  237c					      IJMP	STMT	;Next Statement
      0  237c					      db	29
      1  237c		       1d		      .byte.b	29
      0  237d					      dw	STMT
      1  237d		       5a 22		      .word.w	STMT
    357  237f
    358  237f
    359  237f
    360  237f				   UNKNOWNLnk
      0  237f					      iJMP	UNKNOWN
      0  237f					      db	29
      1  237f		       1d		      .byte.b	29
      0  2380					      dw	UNKNOWN
      1  2380		       39 24		      .word.w	UNKNOWN
    362  2382
    363  2382							;
    364  2382							;===========================================================
    365  2382							; Update a memory location with a value
    366  2382							;  Use @[offset] to write a word value to memory
    367  2382							;
    368  2382							;S8a1:
    369  2382							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    370  2382				   ekPoke
      0  2382					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  2382					      db	101
      1  2382		       65		      .byte.b	101
      0  2383					      db	(UNKNOWNV-*)-1
      1  2383		       50		      .byte.b	(UNKNOWNV-*)-1
      0  2384					      db	oLeftBracket
      1  2384		       e0		      .byte.b	oLeftBracket
      0  2385					      CALL	EXPR	; Get address to write to
      0  2385					      db	28
      1  2385		       1c		      .byte.b	28
      0  2386					      dw	EXPR
      1  2386		       3d 24		      .word.w	EXPR
      0  2388					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  2388					      db	101
      1  2388		       65		      .byte.b	101
      0  2389					      db	(UNKNOWNV-*)-1
      1  2389		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  238a					      db	oComma
      1  238a		       e2		      .byte.b	oComma
      0  238b					      CALL	EXPR	; Get the value to poke
      0  238b					      db	28
      1  238b		       1c		      .byte.b	28
      0  238c					      dw	EXPR
      1  238c		       3d 24		      .word.w	EXPR
      0  238e					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  238e					      db	101
      1  238e		       65		      .byte.b	101
      0  238f					      db	(UNKNOWNV-*)-1
      1  238f		       44		      .byte.b	(UNKNOWNV-*)-1
      0  2390					      db	oRightBracket
      1  2390		       e1		      .byte.b	oRightBracket
      0  2391					      POKEMEM
      0  2391					      db	47
      1  2391		       2f		      .byte.b	47
      0  2392					      DONE
      0  2392					      db	1
      1  2392		       01		      .byte.b	1
      0  2393					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2393					      db	6
      1  2393		       06		      .byte.b	6
      0  2394					      dw	CO
      1  2394		       52 22		      .word.w	CO
      0  2396					      IJMP	STMT
      0  2396					      db	29
      1  2396		       1d		      .byte.b	29
      0  2397					      dw	STMT
      1  2397		       5a 22		      .word.w	STMT
    380  2399							;================================================================
    381  2399							; Write a single byte to the output device
    382  2399							;
    383  2399							;S8b:
    384  2399							;	  TSTB	      S8c,kPutch       ;Put a char to the terminal
    385  2399				   ekPutch
      0  2399					      CALL	EXPR
      0  2399					      db	28
      1  2399		       1c		      .byte.b	28
      0  239a					      dw	EXPR
      1  239a		       3d 24		      .word.w	EXPR
      0  239c					      PUTCHAR
      0  239c					      db	52
      1  239c		       34		      .byte.b	52
      0  239d					      DONE
      0  239d					      db	1
      1  239d		       01		      .byte.b	1
      0  239e					      NXT	CO	;AND SEQUENCE TO NEXT
      0  239e					      db	6
      1  239e		       06		      .byte.b	6
      0  239f					      dw	CO
      1  239f		       52 22		      .word.w	CO
      0  23a1					      IJMP	STMT
      0  23a1					      db	29
      1  23a1		       1d		      .byte.b	29
      0  23a2					      dw	STMT
      1  23a2		       5a 22		      .word.w	STMT
    391  23a4							;================================================================
    392  23a4							; Clear the screen lines
    393  23a4							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    394  23a4							;
    395  23a4							;S8c
    396  23a4							;	  TSTB	      S9,kCls	       ;Clear the screen
    397  23a4				   ekCls
      0  23a4					      CLEARSCREEN
      0  23a4					      db	46
      1  23a4		       2e		      .byte.b	46
      0  23a5					      NXT	CO	;AND SEQUENCE TO NEXT
      0  23a5					      db	6
      1  23a5		       06		      .byte.b	6
      0  23a6					      dw	CO
      1  23a6		       52 22		      .word.w	CO
      0  23a8					      IJMP	STMT
      0  23a8					      db	29
      1  23a8		       1d		      .byte.b	29
      0  23a9					      dw	STMT
      1  23a9		       5a 22		      .word.w	STMT
    401  23ab							;==================================================================
    402  23ab							; Get input from the terminal
    403  23ab							;   Reads from the currently active input device
    404  23ab							;
    405  23ab							;S9:
    406  23ab							;	  TSTB	     S13,kInput 	      ;INPUT STATEMENT
    407  23ab				   ekInput
    408  23ab				   S10
      0  23ab					      TSTB	S10A,tString	;If there is a string print the prompt
      0  23ab					      db	101
      1  23ab		       65		      .byte.b	101
      0  23ac					      db	(S10A-*)-1
      1  23ac		       05		      .byte.b	(S10A-*)-1
      0  23ad					      db	tString
      1  23ad		       a0		      .byte.b	tString
      0  23ae					      PRS
      0  23ae					      db	2
      1  23ae		       02		      .byte.b	2
      0  23af					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  23af					      db	101
      1  23af		       65		      .byte.b	101
      0  23b0					      db	(S10Z-*)-1
      1  23b0		       18		      .byte.b	(S10Z-*)-1
      0  23b1					      db	oSemiColon
      1  23b1		       e3		      .byte.b	oSemiColon
    412  23b2				   S10A
      0  23b2					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  23b2					      db	33
      1  23b2		       21		      .byte.b	33
      0  23b3					      db	(UNKNOWN-*)-1
      1  23b3		       85		      .byte.b	(UNKNOWN-*)-1
      0  23b4					      TSTB	S10ACONT,oBang	; Print from another task
      0  23b4					      db	101
      1  23b4		       65		      .byte.b	101
      0  23b5					      db	(S10ACONT-*)-1
      1  23b5		       04		      .byte.b	(S10ACONT-*)-1
      0  23b6					      db	oBang
      1  23b6		       e8		      .byte.b	oBang
      0  23b7					      IND
      0  23b7					      db	20
      1  23b7		       14		      .byte.b	20
      0  23b8					      TSTVT	UNKNOWN
      0  23b8					      db	93
      1  23b8		       5d		      .byte.b	93
      0  23b9					      db	(UNKNOWN-*)-1
      1  23b9		       7f		      .byte.b	(UNKNOWN-*)-1
    417  23ba
    418  23ba				   S10ACONT
      0  23ba					      TSTB	S10A1,oDollar
      0  23ba					      db	101
      1  23ba		       65		      .byte.b	101
      0  23bb					      db	(S10A1-*)-1
      1  23bb		       05		      .byte.b	(S10A1-*)-1
      0  23bc					      db	oDollar
      1  23bc		       e7		      .byte.b	oDollar
      0  23bd					      INSTR		;Move character From tty to AESTK
      0  23bd					      db	59
      1  23bd		       3b		      .byte.b	59
      0  23be					      IJMP	S10A2
      0  23be					      db	29
      1  23be		       1d		      .byte.b	29
      0  23bf					      dw	S10A2
      1  23bf		       c2 23		      .word.w	S10A2
    422  23c1				   S10A1
      0  23c1					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  23c1					      db	11
      1  23c1		       0b		      .byte.b	11
    424  23c2				   S10A2
      0  23c2					      STORE		;STORE IT
      0  23c2					      db	19
      1  23c2		       13		      .byte.b	19
      0  23c3					      TSTB	S11,oComma	;IS THERE MORE?
      0  23c3					      db	101
      1  23c3		       65		      .byte.b	101
      0  23c4					      db	(S11-*)-1
      1  23c4		       07		      .byte.b	(S11-*)-1
      0  23c5					      db	oComma
      1  23c5		       e2		      .byte.b	oComma
      0  23c6					      IJMP	S10	;YES
      0  23c6					      db	29
      1  23c6		       1d		      .byte.b	29
      0  23c7					      dw	S10
      1  23c7		       ab 23		      .word.w	S10
    428  23c9				   S10Z
      0  23c9					      iJMP	UNKNOWN
      0  23c9					      db	29
      1  23c9		       1d		      .byte.b	29
      0  23ca					      dw	UNKNOWN
      1  23ca		       39 24		      .word.w	UNKNOWN
    430  23cc				   S11
      0  23cc					      DONE		;MUST BE CR
      0  23cc					      db	1
      1  23cc		       01		      .byte.b	1
      0  23cd					      NXT	CO	;SEQUENCE TO NEXT
      0  23cd					      db	6
      1  23cd		       06		      .byte.b	6
      0  23ce					      dw	CO
      1  23ce		       52 22		      .word.w	CO
      0  23d0					      IJMP	STMT
      0  23d0					      db	29
      1  23d0		       1d		      .byte.b	29
      0  23d1					      dw	STMT
      1  23d1		       5a 22		      .word.w	STMT
    434  23d3							;=====================================================================
    435  23d3							; End of program, return to command line process
    436  23d3							; Main Task may also use taske or return to stopped
    437  23d3							;
    438  23d3							;S13:
    439  23d3							;	  TSTB	      S14,kEnd
    440  23d3				   ekEnd
      0  23d3					      FIN
      0  23d3					      db	12
      1  23d3		       0c		      .byte.b	12
    442  23d4
    443  23d4				   UNKNOWNV
      0  23d4					      IJMP	UNKNOWN
      0  23d4					      db	29
      1  23d4		       1d		      .byte.b	29
      0  23d5					      dw	UNKNOWN
      1  23d5		       39 24		      .word.w	UNKNOWN
    445  23d7							;====================================================================
    446  23d7							; IRQ <IRQ-HANDLER-Line expression>
    447  23d7							;   Specify a line number subroutine to call when an interupt is processed
    448  23d7							;   These subroutines must use iret to return.
    449  23d7							;
    450  23d7							;S14:
    451  23d7							;	  TSTB	      S14Z,kIrq      ;Check if we are setting IRQ HANDLER
    452  23d7				   ekIrq
      0  23d7					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  23d7					      db	28
      1  23d7		       1c		      .byte.b	28
      0  23d8					      dw	EXPR
      1  23d8		       3d 24		      .word.w	EXPR
      0  23da					      DONE		;must be CR
      0  23da					      db	1
      1  23da		       01		      .byte.b	1
      0  23db					      SETIRQ		;Set the line number now
      0  23db					      db	56
      1  23db		       38		      .byte.b	56
      0  23dc					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  23dc					      db	6
      1  23dc		       06		      .byte.b	6
      0  23dd					      dw	CO
      1  23dd		       52 22		      .word.w	CO
      0  23df					      IJMP	STMT
      0  23df					      db	29
      1  23df		       1d		      .byte.b	29
      0  23e0					      dw	STMT
      1  23e0		       5a 22		      .word.w	STMT
    458  23e2
    459  23e2							;=========================================================================
    460  23e2							; KILL PID-expression	 kill a running task
    461  23e2							;  ignored of task has already stopped
    462  23e2							;
    463  23e2							;S14Z:
    464  23e2							;	  TSTB	     S14S1,kKill     ; Kill A running Task
    465  23e2				   ekKill
      0  23e2					      CALL	EXPR
      0  23e2					      db	28
      1  23e2		       1c		      .byte.b	28
      0  23e3					      dw	EXPR
      1  23e3		       3d 24		      .word.w	EXPR
      0  23e5					      DONE
      0  23e5					      db	1
      1  23e5		       01		      .byte.b	1
      0  23e6					      TASKKILL
      0  23e6					      db	65
      1  23e6		       41		      .byte.b	65
      0  23e7					      NXT	CO
      0  23e7					      db	6
      1  23e7		       06		      .byte.b	6
      0  23e8					      dw	CO
      1  23e8		       52 22		      .word.w	CO
      0  23ea					      IJMP	STMT
      0  23ea					      db	29
      1  23ea		       1d		      .byte.b	29
      0  23eb					      dw	STMT
      1  23eb		       5a 22		      .word.w	STMT
    471  23ed
    472  23ed							;============================================================================
    473  23ed							; List all program lines
    474  23ed							;
    475  23ed							;S14S1:
    476  23ed							;	  TSTB	      S15,kList      ;LIST COMMAND
    477  23ed				   ekList
      0  23ed					      DONE
      0  23ed					      db	1
      1  23ed		       01		      .byte.b	1
      0  23ee					      LST
      0  23ee					      db	21
      1  23ee		       15		      .byte.b	21
      0  23ef					      IJMP	CO
      0  23ef					      db	29
      1  23ef		       1d		      .byte.b	29
      0  23f0					      dw	CO
      1  23f0		       52 22		      .word.w	CO
    481  23f2							;=======================================================================
    482  23f2							;RUN begin to executed the program in memory
    483  23f2							;
    484  23f2							;S15:
    485  23f2							;	  TSTB	      S16,kRun	     ;RUN COMMAND
    486  23f2				   ekRun
      0  23f2					      DONE
      0  23f2					      db	1
      1  23f2		       01		      .byte.b	1
      0  23f3					      VINIT		;clear variables compile the line numbers
      0  23f3					      db	30
      1  23f3		       1e		      .byte.b	30
      0  23f4					      LIT	1	;GOTO line 1
      0  23f4					      db	27
      1  23f4		       1b		      .byte.b	27
      0  23f5					      dw	1
      1  23f5		       01 00		      .word.w	1
      0  23f7					      XFER		;Bob's addition
      0  23f7					      db	7
      1  23f7		       07		      .byte.b	7
    491  23f8							; EXIT
      0  23f8					      IJMP	STMT	;and run!
      0  23f8					      db	29
      1  23f8		       1d		      .byte.b	29
      0  23f9					      dw	STMT
      1  23f9		       5a 22		      .word.w	STMT
    493  23fb							;=========================================================================
    494  23fb							;Clear the program memory, delete all proram lines
    495  23fb							;
    496  23fb							;S16:
    497  23fb							;	  TSTB	      S16A,kNew      ;clear program
    498  23fb				   ekNew
      0  23fb					      DONE
      0  23fb					      db	1
      1  23fb		       01		      .byte.b	1
      0  23fc					      IJMP	START
      0  23fc					      db	29
      1  23fc		       1d		      .byte.b	29
      0  23fd					      dw	START
      1  23fd		       4c 22		      .word.w	START
    501  23ff
    502  23ff							;========================================================================
    503  23ff							; Slice(slice legth expression)
    504  23ff							;   set the length of time between task switches
    505  23ff							;
    506  23ff							;S16A:
    507  23ff							;	  TSTB	      S16Trace,kSlice
    508  23ff				   ekSlice
      0  23ff					      CALL	EXPR
      0  23ff					      db	28
      1  23ff		       1c		      .byte.b	28
      0  2400					      dw	EXPR
      1  2400		       3d 24		      .word.w	EXPR
      0  2402					      SLICE
      0  2402					      db	100
      1  2402		       64		      .byte.b	100
      0  2403					      DONE
      0  2403					      db	1
      1  2403		       01		      .byte.b	1
      0  2404					      NXT	CO
      0  2404					      db	6
      1  2404		       06		      .byte.b	6
      0  2405					      dw	CO
      1  2405		       52 22		      .word.w	CO
      0  2407					      IJMP	STMT
      0  2407					      db	29
      1  2407		       1d		      .byte.b	29
      0  2408					      dw	STMT
      1  2408		       5a 22		      .word.w	STMT
    514  240a							;==========================================================================
    515  240a							; Turn off and on the thrace functions
    516  240a							; a debug terminal needs to be available
    517  240a							; Trace( Trace flag expression)
    518  240a							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    519  240a							;	for individual lines of basic code. These can be combined
    520  240a							;S16Trace:
    521  240a							;	  TSTB	      S17A,kTrace
    522  240a				   ekTrace
      0  240a					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  240a					      db	101
      1  240a		       65		      .byte.b	101
      0  240b					      db	(UNKNOWN-*)-1
      1  240b		       2d		      .byte.b	(UNKNOWN-*)-1
      0  240c					      db	oLeftBracket
      1  240c		       e0		      .byte.b	oLeftBracket
      0  240d					      CALL	EXPR
      0  240d					      db	28
      1  240d		       1c		      .byte.b	28
      0  240e					      dw	EXPR
      1  240e		       3d 24		      .word.w	EXPR
      0  2410					      TSTB	UNKNOWN,oRightBracket
      0  2410					      db	101
      1  2410		       65		      .byte.b	101
      0  2411					      db	(UNKNOWN-*)-1
      1  2411		       27		      .byte.b	(UNKNOWN-*)-1
      0  2412					      db	oRightBracket
      1  2412		       e1		      .byte.b	oRightBracket
      0  2413					      TRACEPROGRAM
      0  2413					      db	78
      1  2413		       4e		      .byte.b	78
      0  2414					      DONE
      0  2414					      db	1
      1  2414		       01		      .byte.b	1
      0  2415					      NXT	CO
      0  2415					      db	6
      1  2415		       06		      .byte.b	6
      0  2416					      dw	CO
      1  2416		       52 22		      .word.w	CO
      0  2418					      IJMP	STMT
      0  2418					      db	29
      1  2418		       1d		      .byte.b	29
      0  2419					      dw	STMT
      1  2419		       5a 22		      .word.w	STMT
    530  241b							;=====================================================================
    531  241b							; Exit basic to machine monitor
    532  241b							;
    533  241b							;S17A:
    534  241b							;	  TSTB	      S17B,kExit      ;allow them to exit BASIC
    535  241b				   ekExit
      0  241b					      EXIT
      0  241b					      db	26
      1  241b		       1a		      .byte.b	26
    537  241c
    538  241c							;=======================================================================
    539  241c							; Commands related to saving/restoring programs
    540  241c							; to/from mass storage.
    541  241c							;=======================================================================
    542  241c							; Save a program file
    543  241c							;
    544  241c							;S17B:
    545  241c					      if	(XKIM || CTMON65) && DISK_ACCESS
    546  241c
    547  241c							;	  TSTB	      S17C,kSave
    548  241c				   ekSave
      0  241c					      OPENWRITE
      0  241c					      db	40
      1  241c		       28		      .byte.b	40
      0  241d					      DLIST
      0  241d					      db	43
      1  241d		       2b		      .byte.b	43
      0  241e					      DCLOSE
      0  241e					      db	41
      1  241e		       29		      .byte.b	41
      0  241f					      IJMP	CO
      0  241f					      db	29
      1  241f		       1d		      .byte.b	29
      0  2420					      dw	CO
      1  2420		       52 22		      .word.w	CO
    553  2422							;=========================================================================
    554  2422							; Load a program file
    555  2422							;
    556  2422							;S17C:
    557  2422							;	  TSTB	      S18,kLoad
    558  2422				   ekLoad
      0  2422					      OPENREAD
      0  2422					      db	39
      1  2422		       27		      .byte.b	39
    560  2423				   S17CLP
      0  2423					      DGETLINE		;get line from file
      0  2423					      db	42
      1  2423		       2a		      .byte.b	42
      0  2424					      TSTL	S17EOL	;no line num means EOL
      0  2424					      db	34
      1  2424		       22		      .byte.b	34
      0  2425					      db	(S17EOL-*)-1
      1  2425		       04		      .byte.b	(S17EOL-*)-1
      0  2426					      INSERT		;put it into the program
      0  2426					      db	24
      1  2426		       18		      .byte.b	24
      0  2427					      IJMP	S17CLP	;keep going
      0  2427					      db	29
      1  2427		       1d		      .byte.b	29
      0  2428					      dw	S17CLP
      1  2428		       23 24		      .word.w	S17CLP
    565  242a				   S17EOL
      0  242a					      DCLOSE		;close disk file
      0  242a					      db	41
      1  242a		       29		      .byte.b	41
      0  242b					      IJMP	CO	;back to start
      0  242b					      db	29
      1  242b		       1d		      .byte.b	29
      0  242c					      dw	CO
      1  242c		       52 22		      .word.w	CO
    568  242e							;=========================================================================
    569  242e							; Display the directory content
    570  242e							;
    571  242e							;S18:
    572  242e							;	  TSTB	      S19,kDir
    573  242e				   ekDir
      0  242e					      DDIR		;Display the directory content
      0  242e					      db	44
      1  242e		       2c		      .byte.b	44
      0  242f					      IJMP	CO
      0  242f					      db	29
      1  242f		       1d		      .byte.b	29
      0  2430					      dw	CO
      1  2430		       52 22		      .word.w	CO
    576  2432							;=========================================================================
    577  2432							; Erase a file from disk
    578  2432							;
      0  2432				   S19	      TSTB	UNKNOWN,kErase
      0  2432					      db	101
      1  2432		       65		      .byte.b	101
      0  2433					      db	(UNKNOWN-*)-1
      1  2433		       05		      .byte.b	(UNKNOWN-*)-1
      0  2434					      db	kErase
      1  2434		       1e		      .byte.b	kErase
    580  2435				   ekErase
      0  2435					      RMFILE		;Erase the file from the disk
      0  2435					      db	45
      1  2435		       2d		      .byte.b	45
      0  2436					      IJMP	CO
      0  2436					      db	29
      1  2436		       1d		      .byte.b	29
      0  2437					      dw	CO
      1  2437		       52 22		      .word.w	CO
    583  2439
    584  2439					      endif
    585  2439
    586  2439							;===========================================================================
    587  2439							; Else, unknown command.
    588  2439							;
    589  2439				   UNKNOWN
      0  2439					      ENDIO
      0  2439					      db	71
      1  2439		       47		      .byte.b	71
    591  243a
    592  243a				   NotKnownStatement
    593  243a
      0  243a					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  243a					      db	13
      1  243a		       0d		      .byte.b	13
      0  243b					      dw	ERR_SYNTAX
      1  243b		       05 00		      .word.w	ERR_SYNTAX
    595  243d
    596  243d							;=======================================================
    597  243d							; Process Expresions, precidence is represented by the
    598  243d							; various call levels
    599  243d							;
    600  243d				   EXPR
      0  243d					      TSTB	EXPRLOGS,kNot
      0  243d					      db	101
      1  243d		       65		      .byte.b	101
      0  243e					      db	(EXPRLOGS-*)-1
      1  243e		       06		      .byte.b	(EXPRLOGS-*)-1
      0  243f					      db	kNot
      1  243f		       20		      .byte.b	kNot
    602  2440				   ekNot
      0  2440					      Call	EXPR
      0  2440					      db	28
      1  2440		       1c		      .byte.b	28
      0  2441					      dw	EXPR
      1  2441		       3d 24		      .word.w	EXPR
      0  2443					      LOGNOT
      0  2443					      db	72
      1  2443		       48		      .byte.b	72
      0  2444					      RTN
      0  2444					      db	25
      1  2444		       19		      .byte.b	25
    606  2445
    607  2445							;=========================================================
    608  2445							;Look for logical operators
    609  2445				   EXPRLOGS
      0  2445					      Call	EXPRCMP
      0  2445					      db	28
      1  2445		       1c		      .byte.b	28
      0  2446					      dw	EXPRCMP
      1  2446		       5c 24		      .word.w	EXPRCMP
      0  2448					      OnGoto	BasicLogical,iLOG3
      0  2448					      db	103
      1  2448		       67		      .byte.b	103
      0  2449					      dw	BasicLogical
      1  2449		       24 22		      .word.w	BasicLogical
      0  244b					      dw	iLOG3
      1  244b		       5b 24		      .word.w	iLOG3
    612  244d							;	  TSTB	     iLOG1,kAnd
    613  244d				   ekAnd
      0  244d					      Call	EXPR
      0  244d					      db	28
      1  244d		       1c		      .byte.b	28
      0  244e					      dw	EXPR
      1  244e		       3d 24		      .word.w	EXPR
      0  2450					      LOGAND
      0  2450					      db	74
      1  2450		       4a		      .byte.b	74
      0  2451					      RTN
      0  2451					      db	25
      1  2451		       19		      .byte.b	25
    617  2452							;iLOG1:
    618  2452							;	  TSTB	     iLOG2,kOr
    619  2452				   ekOr
      0  2452					      Call	EXPR
      0  2452					      db	28
      1  2452		       1c		      .byte.b	28
      0  2453					      dw	EXPR
      1  2453		       3d 24		      .word.w	EXPR
      0  2455					      LOGOR
      0  2455					      db	73
      1  2455		       49		      .byte.b	73
      0  2456					      RTN
      0  2456					      db	25
      1  2456		       19		      .byte.b	25
    623  2457							;iLOG2:
    624  2457							;	  TSTB	  iLOG3,kXor
    625  2457				   ekXor
      0  2457					      Call	EXPR
      0  2457					      db	28
      1  2457		       1c		      .byte.b	28
      0  2458					      dw	EXPR
      1  2458		       3d 24		      .word.w	EXPR
      0  245a					      LOGXOR
      0  245a					      db	75
      1  245a		       4b		      .byte.b	75
    628  245b				   iLOG3
      0  245b					      RTN
      0  245b					      db	25
      1  245b		       19		      .byte.b	25
    630  245c							;========================================================================
    631  245c							; Process relational operators
    632  245c							;
    633  245c				   EXPRCMP
      0  245c					      Call	EXPR2	; get the first expression
      0  245c					      db	28
      1  245c		       1c		      .byte.b	28
      0  245d					      dw	EXPR2
      1  245d		       67 24		      .word.w	EXPR2
      0  245f					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  245f					      db	104
      1  245f		       68		      .byte.b	104
      0  2460					      db	(iRDone-*)-1
      1  2460		       05		      .byte.b	(iRDone-*)-1
    636  2461							;	  TSTB	     iR0,oEqual
    637  2461							;	  LIT	     2		     ;=
    638  2461							;	  IJMP	     iRFound
    639  2461							;iR0:
    640  2461							;	  TSTB	      iR1,oLessEqual
    641  2461							;	  LIT	      3 	      ;<=
    642  2461							;	  IJMP	     iRFound
    643  2461							;iR1:
    644  2461							;	  TSTB	     iR3,oNotEqual
    645  2461							;	  LIT	     5		      ;<>
    646  2461							;	      IJMP	  iRFound
    647  2461							;iR3:
    648  2461							;	  TSTB	     iR4,oLess
    649  2461							;	  LIT	     1		     ;<
    650  2461							;	      IJMP	  iRFound
    651  2461							;iR4:
    652  2461							;	  TST	     iR5,oGreaterEqual
    653  2461							;	  LIT	     6		     ;>=
    654  2461							;	      IJMP	  iRFound
    655  2461							;iR5:
    656  2461							;	  TSTB	     iRDone,oGreater
    657  2461							;	  LIT	     4		     ;>
    658  2461				   iRFound
      0  2461					      Call	EXPR	; get the right side of the expression
      0  2461					      db	28
      1  2461		       1c		      .byte.b	28
      0  2462					      dw	EXPR
      1  2462		       3d 24		      .word.w	EXPR
      0  2464					      CMPR		; Push the value of the true false onto the stack
      0  2464					      db	10
      1  2464		       0a		      .byte.b	10
      0  2465					      RTN
      0  2465					      db	25
      1  2465		       19		      .byte.b	25
    662  2466
    663  2466				   iRDone
      0  2466					      RTN
      0  2466					      db	25
      1  2466		       19		      .byte.b	25
    665  2467
    666  2467				   EXPR2
      0  2467					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  2467					      db	101
      1  2467		       65		      .byte.b	101
      0  2468					      db	(E0-*)-1
      1  2468		       08		      .byte.b	(E0-*)-1
      0  2469					      db	oMinus
      1  2469		       eb		      .byte.b	oMinus
      0  246a					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  246a					      db	28
      1  246a		       1c		      .byte.b	28
      0  246b					      dw	TERM
      1  246b		       8d 24		      .word.w	TERM
      0  246d					      NEG		; Make value negated
      0  246d					      db	16
      1  246d		       10		      .byte.b	16
      0  246e					      IJMP	E1	; We have Left term process operators next
      0  246e					      db	29
      1  246e		       1d		      .byte.b	29
      0  246f					      dw	E1
      1  246f		       77 24		      .word.w	E1
    671  2471				   E0
      0  2471					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  2471					      db	101
      1  2471		       65		      .byte.b	101
      0  2472					      db	(E1A-*)-1
      1  2472		       01		      .byte.b	(E1A-*)-1
      0  2473					      db	oPlus
      1  2473		       ea		      .byte.b	oPlus
    673  2474				   E1A
      0  2474					      CALL	TERM	; Get the left term if it was not negated
      0  2474					      db	28
      1  2474		       1c		      .byte.b	28
      0  2475					      dw	TERM
      1  2475		       8d 24		      .word.w	TERM
    675  2477				   E1
      0  2477					      TST	E2,oPlus	; Check if we are adding left term to something
      0  2477					      db	32
      1  2477		       20		      .byte.b	32
      0  2478					      db	(E2-*)-1
      1  2478		       09		      .byte.b	(E2-*)-1
      0  2479					      db	oPlus,0
      1  2479		       ea 00		      .byte.b	oPlus,0
      0  247b					      CALL	TERM	; if adding then get the right side term
      0  247b					      db	28
      1  247b		       1c		      .byte.b	28
      0  247c					      dw	TERM
      1  247c		       8d 24		      .word.w	TERM
      0  247e					      ADD		; Add it to left term
      0  247e					      db	14
      1  247e		       0e		      .byte.b	14
      0  247f					      IJMP	E1	; look for next + or -
      0  247f					      db	29
      1  247f		       1d		      .byte.b	29
      0  2480					      dw	E1
      1  2480		       77 24		      .word.w	E1
    680  2482				   E2
      0  2482					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  2482					      db	101
      1  2482		       65		      .byte.b	101
      0  2483					      db	(E3-*)-1
      1  2483		       08		      .byte.b	(E3-*)-1
      0  2484					      db	oMinus
      1  2484		       eb		      .byte.b	oMinus
      0  2485					      CALL	TERM	; get right side to subtract Diffrence
      0  2485					      db	28
      1  2485		       1c		      .byte.b	28
      0  2486					      dw	TERM
      1  2486		       8d 24		      .word.w	TERM
      0  2488					      SUB		; Subtract the value
      0  2488					      db	15
      1  2488		       0f		      .byte.b	15
      0  2489					      IJMP	E1	; Look for next + or -
      0  2489					      db	29
      1  2489		       1d		      .byte.b	29
      0  248a					      dw	E1
      1  248a		       77 24		      .word.w	E1
    685  248c				   E3			; Finish processing the expression
      0  248c					      RTN		; We are finished processing the Expression
      0  248c					      db	25
      1  248c		       19		      .byte.b	25
    687  248d							;
    688  248d							; Get one of the terms of an expression
    689  248d							;
    690  248d				   TERM
      0  248d					      CALL	FACT	; Get a value
      0  248d					      db	28
      1  248d		       1c		      .byte.b	28
      0  248e					      dw	FACT
      1  248e		       b2 24		      .word.w	FACT
    692  2490				   T0			; Check for higher precidence operators
      0  2490					      TSTB	T1,oMultiply	; Check for *
      0  2490					      db	101
      1  2490		       65		      .byte.b	101
      0  2491					      db	(T1-*)-1
      1  2491		       08		      .byte.b	(T1-*)-1
      0  2492					      db	oMultiply
      1  2492		       ee		      .byte.b	oMultiply
      0  2493					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  2493					      db	28
      1  2493		       1c		      .byte.b	28
      0  2494					      dw	FACT
      1  2494		       b2 24		      .word.w	FACT
      0  2496					      MUL		; Multiply factors
      0  2496					      db	17
      1  2496		       11		      .byte.b	17
      0  2497					      IJMP	T0	; Check for * or /
      0  2497					      db	29
      1  2497		       1d		      .byte.b	29
      0  2498					      dw	T0
      1  2498		       90 24		      .word.w	T0
    697  249a				   T1
      0  249a					      TSTB	T2,oDivide	; Check for a division
      0  249a					      db	101
      1  249a		       65		      .byte.b	101
      0  249b					      db	(T2-*)-1
      1  249b		       08		      .byte.b	(T2-*)-1
      0  249c					      db	oDivide
      1  249c		       ec		      .byte.b	oDivide
      0  249d					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  249d					      db	28
      1  249d		       1c		      .byte.b	28
      0  249e					      dw	FACT
      1  249e		       b2 24		      .word.w	FACT
      0  24a0					      DIV		; do division
      0  24a0					      db	18
      1  24a0		       12		      .byte.b	18
      0  24a1					      IJMP	T0	; check for more * or /
      0  24a1					      db	29
      1  24a1		       1d		      .byte.b	29
      0  24a2					      dw	T0
      1  24a2		       90 24		      .word.w	T0
    702  24a4				   T2
      0  24a4					      TSTB	T3,oModulo	; Check for a division
      0  24a4					      db	101
      1  24a4		       65		      .byte.b	101
      0  24a5					      db	(T3-*)-1
      1  24a5		       08		      .byte.b	(T3-*)-1
      0  24a6					      db	oModulo
      1  24a6		       ed		      .byte.b	oModulo
      0  24a7					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  24a7					      db	28
      1  24a7		       1c		      .byte.b	28
      0  24a8					      dw	FACT
      1  24a8		       b2 24		      .word.w	FACT
      0  24aa					      MODULO		; do division for remainder
      0  24aa					      db	60
      1  24aa		       3c		      .byte.b	60
      0  24ab					      IJMP	T0	; check for more * or / or %
      0  24ab					      db	29
      1  24ab		       1d		      .byte.b	29
      0  24ac					      dw	T0
      1  24ac		       90 24		      .word.w	T0
    707  24ae				   T3			; Finish processing the Term
      0  24ae					      RTN
      0  24ae					      db	25
      1  24ae		       19		      .byte.b	25
    709  24af
    710  24af				   UNKNOWNVEC
      0  24af					      IJMP	UNKNOWN
      0  24af					      db	29
      1  24af		       1d		      .byte.b	29
      0  24b0					      dw	UNKNOWN
      1  24b0		       39 24		      .word.w	UNKNOWN
    712  24b2
    713  24b2							;=============================================================================================
    714  24b2							; Factor an expression.  Always test for functions
    715  24b2							; first or else they'll be confused for variables.
    716  24b2							;
    717  24b2				   FACT
      0  24b2					      OnGoto	BasicFuncs,FactNumber
      0  24b2					      db	103
      1  24b2		       67		      .byte.b	103
      0  24b3					      dw	BasicFuncs
      1  24b3		       2c 22		      .word.w	BasicFuncs
      0  24b5					      dw	FactNumber
      1  24b5		       7c 25		      .word.w	FactNumber
    719  24b7
    720  24b7							;FACTCONTINUE:
    721  24b7							;	  TSTB	     F1AA,kTrue
    722  24b7				   ekTrue
      0  24b7					      LIT	-1
      0  24b7					      db	27
      1  24b7		       1b		      .byte.b	27
      0  24b8					      dw	-1
      1  24b8		       ff ff		      .word.w	-1
      0  24ba					      RTN
      0  24ba					      db	25
      1  24ba		       19		      .byte.b	25
    725  24bb							;F1AA:
    726  24bb							;	  TSTB	     F1AB,kFalse
    727  24bb				   ekFalse
      0  24bb					      LIT	0
      0  24bb					      db	27
      1  24bb		       1b		      .byte.b	27
      0  24bc					      dw	0
      1  24bc		       00 00		      .word.w	0
      0  24be					      RTN
      0  24be					      db	25
      1  24be		       19		      .byte.b	25
    730  24bf							;==================================================================================
    731  24bf							; Returns the amount of free SPACE
    732  24bf							;
    733  24bf							;F1AB
    734  24bf							;	  TSTB	     F1A,kFree
    735  24bf				   ekFree
      0  24bf					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24bf					      db	101
      1  24bf		       65		      .byte.b	101
      0  24c0					      db	(UNKNOWNVEC-*)-1
      1  24c0		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  24c1					      db	oLeftBracket
      1  24c1		       e0		      .byte.b	oLeftBracket
      0  24c2					      TSTB	UNKNOWNVEC,oRightBracket
      0  24c2					      db	101
      1  24c2		       65		      .byte.b	101
      0  24c3					      db	(UNKNOWNVEC-*)-1
      1  24c3		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  24c4					      db	oRightBracket
      1  24c4		       e1		      .byte.b	oRightBracket
      0  24c5					      FREE
      0  24c5					      db	36
      1  24c5		       24		      .byte.b	36
      0  24c6					      RTN
      0  24c6					      db	25
      1  24c6		       19		      .byte.b	25
    740  24c7							;===================================================================================
    741  24c7							; getch() read a character from the input device
    742  24c7							;
    743  24c7							;F1A:
    744  24c7							;	  TSTB	     F1A2,kGetch		      ; read char from the terminal
    745  24c7				   ekGetch
      0  24c7					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24c7					      db	101
      1  24c7		       65		      .byte.b	101
      0  24c8					      db	(UNKNOWNVEC-*)-1
      1  24c8		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  24c9					      db	oLeftBracket
      1  24c9		       e0		      .byte.b	oLeftBracket
      0  24ca					      TSTB	UNKNOWNVEC,oRightBracket
      0  24ca					      db	101
      1  24ca		       65		      .byte.b	101
      0  24cb					      db	(UNKNOWNVEC-*)-1
      1  24cb		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  24cc					      db	oRightBracket
      1  24cc		       e1		      .byte.b	oRightBracket
      0  24cd					      GETCHAR
      0  24cd					      db	51
      1  24cd		       33		      .byte.b	51
      0  24ce					      RTN
      0  24ce					      db	25
      1  24ce		       19		      .byte.b	25
    750  24cf							;====================================================================================
    751  24cf							; peek(mem address) return the value of a byte in memory
    752  24cf							; @[offset] return a word value from offset -- see tstv
    753  24cf							;
    754  24cf							;F1A2:
    755  24cf							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    756  24cf				   ekPeek
      0  24cf					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24cf					      db	101
      1  24cf		       65		      .byte.b	101
      0  24d0					      db	(UNKNOWNVEC-*)-1
      1  24d0		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  24d1					      db	oLeftBracket
      1  24d1		       e0		      .byte.b	oLeftBracket
      0  24d2					      CALL	EXPR	;Get the address to write to
      0  24d2					      db	28
      1  24d2		       1c		      .byte.b	28
      0  24d3					      dw	EXPR
      1  24d3		       3d 24		      .word.w	EXPR
      0  24d5					      TSTB	UNKNOWNVEC,oRightBracket
      0  24d5					      db	101
      1  24d5		       65		      .byte.b	101
      0  24d6					      db	(UNKNOWNVEC-*)-1
      1  24d6		       d8		      .byte.b	(UNKNOWNVEC-*)-1
      0  24d7					      db	oRightBracket
      1  24d7		       e1		      .byte.b	oRightBracket
      0  24d8					      PEEKMEM
      0  24d8					      db	48
      1  24d8		       30		      .byte.b	48
      0  24d9					      RTN
      0  24d9					      db	25
      1  24d9		       19		      .byte.b	25
    762  24da							;=======================================================================================
    763  24da							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    764  24da							;
    765  24da							;F2AZ:
    766  24da							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    767  24da				   ekTask
      0  24da					      TSTBRANCH	ekTaskCompiled
      0  24da					      db	106
      1  24da		       6a		      .byte.b	106
      0  24db					      db	(ekTaskCompiled-*)-1
      1  24db		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  24dc					      TSTB	UNKNOWNVEC,oLeftBracket
      0  24dc					      db	101
      1  24dc		       65		      .byte.b	101
      0  24dd					      db	(UNKNOWNVEC-*)-1
      1  24dd		       d1		      .byte.b	(UNKNOWNVEC-*)-1
      0  24de					      db	oLeftBracket
      1  24de		       e0		      .byte.b	oLeftBracket
      0  24df					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  24df					      db	28
      1  24df		       1c		      .byte.b	28
      0  24e0					      dw	EXPR
      1  24e0		       3d 24		      .word.w	EXPR
      0  24e2					      lit	0
      0  24e2					      db	27
      1  24e2		       1b		      .byte.b	27
      0  24e3					      dw	0
      1  24e3		       00 00		      .word.w	0
      0  24e5					      iJMP	ekTaskLinenum
      0  24e5					      db	29
      1  24e5		       1d		      .byte.b	29
      0  24e6					      dw	ekTaskLinenum
      1  24e6		       eb 24		      .word.w	ekTaskLinenum
    773  24e8
    774  24e8				   ekTaskCompiled
      0  24e8					      lit	1
      0  24e8					      db	27
      1  24e8		       1b		      .byte.b	27
      0  24e9					      dw	1
      1  24e9		       01 00		      .word.w	1
    776  24eb
    777  24eb				   ekTaskLinenum
      0  24eb					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  24eb					      db	61
      1  24eb		       3d		      .byte.b	61
      0  24ec					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  24ec					      db	101
      1  24ec		       65		      .byte.b	101
      0  24ed					      db	(F2AZNoParms-*)-1
      1  24ed		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  24ee					      db	oComma
      1  24ee		       e2		      .byte.b	oComma
      0  24ef					      SAVEMATHSTACK		;Push The mathstack
      0  24ef					      db	86
      1  24ef		       56		      .byte.b	86
      0  24f0					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  24f0					      db	89
      1  24f0		       59		      .byte.b	89
    782  24f1				   F2AZLOOP
      0  24f1					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  24f1					      db	28
      1  24f1		       1c		      .byte.b	28
      0  24f2					      dw	EXPR
      1  24f2		       3d 24		      .word.w	EXPR
      0  24f4					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  24f4					      db	101
      1  24f4		       65		      .byte.b	101
      0  24f5					      db	(F2AZEndParm-*)-1
      1  24f5		       04		      .byte.b	(F2AZEndParm-*)-1
      0  24f6					      db	oComma
      1  24f6		       e2		      .byte.b	oComma
      0  24f7					      IJMP	F2AZLOOP	;check for more
      0  24f7					      db	29
      1  24f7		       1d		      .byte.b	29
      0  24f8					      dw	F2AZLOOP
      1  24f8		       f1 24		      .word.w	F2AZLOOP
    786  24fa
    787  24fa				   F2AZEndParm
      0  24fa					      RESTOREMATHSTACK		;Back to normal stack
      0  24fa					      db	87
      1  24fa		       57		      .byte.b	87
      0  24fb					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  24fb					      db	92
      1  24fb		       5c		      .byte.b	92
    790  24fc
    791  24fc				   F2AZNoParms
      0  24fc					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  24fc					      db	101
      1  24fc		       65		      .byte.b	101
      0  24fd					      db	(UNKNOWNVEC-*)-1
      1  24fd		       b1		      .byte.b	(UNKNOWNVEC-*)-1
      0  24fe					      db	oRightBracket
      1  24fe		       e1		      .byte.b	oRightBracket
    793  24ff
      0  24ff					      TASKENABLE		;Enable the task to execute
      0  24ff					      db	90
      1  24ff		       5a		      .byte.b	90
    795  2500
      0  2500					      RTN		;Returns the Task number
      0  2500					      db	25
      1  2500		       19		      .byte.b	25
    797  2501							;=========================================================================================
    798  2501							; Check for IPC interproccess instructions
    799  2501							;   IPCS  - Send a message
    800  2501							;
    801  2501							;F2AZ1:
    802  2501							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    803  2501				   ekIpcs
      0  2501					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2501					      db	101
      1  2501		       65		      .byte.b	101
      0  2502					      db	(UNKNOWNVEC-*)-1
      1  2502		       ac		      .byte.b	(UNKNOWNVEC-*)-1
      0  2503					      db	oLeftBracket
      1  2503		       e0		      .byte.b	oLeftBracket
      0  2504					      CALL	EXPR	;Get the message value
      0  2504					      db	28
      1  2504		       1c		      .byte.b	28
      0  2505					      dw	EXPR
      1  2505		       3d 24		      .word.w	EXPR
      0  2507					      TSTB	UNKNOWNVEC,oComma
      0  2507					      db	101
      1  2507		       65		      .byte.b	101
      0  2508					      db	(UNKNOWNVEC-*)-1
      1  2508		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  2509					      db	oComma
      1  2509		       e2		      .byte.b	oComma
      0  250a					      CALL	EXPR	;Get pid of task to send to
      0  250a					      db	28
      1  250a		       1c		      .byte.b	28
      0  250b					      dw	EXPR
      1  250b		       3d 24		      .word.w	EXPR
      0  250d					      TSTB	UNKNOWNVEC,oRightBracket
      0  250d					      db	101
      1  250d		       65		      .byte.b	101
      0  250e					      db	(UNKNOWNVEC-*)-1
      1  250e		       a0		      .byte.b	(UNKNOWNVEC-*)-1
      0  250f					      db	oRightBracket
      1  250f		       e1		      .byte.b	oRightBracket
      0  2510					      IPCSEND		;Send msg and clear pid msg pending
      0  2510					      db	80
      1  2510		       50		      .byte.b	80
      0  2511					      RTN
      0  2511					      db	25
      1  2511		       19		      .byte.b	25
    811  2512							;================================================================================
    812  2512							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    813  2512							;
    814  2512							;F2AZa:
    815  2512							;	  TSTB	      F2AZb,kIpcr		      ;IPCR recieve a message , wait if none
    816  2512				   ekIpcr
      0  2512					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  2512					      db	101
      1  2512		       65		      .byte.b	101
      0  2513					      db	(UNKNOWNVEC-*)-1
      1  2513		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  2514					      db	oLeftBracket
      1  2514		       e0		      .byte.b	oLeftBracket
      0  2515					      TSTB	F2AZa1,oRightBracket
      0  2515					      db	101
      1  2515		       65		      .byte.b	101
      0  2516					      db	(F2AZa1-*)-1
      1  2516		       07		      .byte.b	(F2AZa1-*)-1
      0  2517					      db	oRightBracket
      1  2517		       e1		      .byte.b	oRightBracket
      0  2518					      LIT	0	;We dont want the pid returned to us
      0  2518					      db	27
      1  2518		       1b		      .byte.b	27
      0  2519					      dw	0
      1  2519		       00 00		      .word.w	0
      0  251b					      IJMP	ekIpcrComplete
      0  251b					      db	29
      1  251b		       1d		      .byte.b	29
      0  251c					      dw	ekIpcrComplete
      1  251c		       23 25		      .word.w	ekIpcrComplete
    821  251e				   F2AZa1
      0  251e					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  251e					      db	33
      1  251e		       21		      .byte.b	33
      0  251f					      db	(UNKNOWNVEC-*)-1
      1  251f		       8f		      .byte.b	(UNKNOWNVEC-*)-1
      0  2520					      TSTB	UNKNOWNVEC,oRightBracket
      0  2520					      db	101
      1  2520		       65		      .byte.b	101
      0  2521					      db	(UNKNOWNVEC-*)-1
      1  2521		       8d		      .byte.b	(UNKNOWNVEC-*)-1
      0  2522					      db	oRightBracket
      1  2522		       e1		      .byte.b	oRightBracket
    824  2523
    825  2523				   ekIpcrComplete
      0  2523					      IPCIO		;Set the io bit and exit task till message
      0  2523					      db	83
      1  2523		       53		      .byte.b	83
      0  2524					      IPCRECEIVE		;Get the message
      0  2524					      db	81
      1  2524		       51		      .byte.b	81
      0  2525					      RTN
      0  2525					      db	25
      1  2525		       19		      .byte.b	25
    829  2526							;===============================================================================
    830  2526							; IPCC ---- check if a message is available
    831  2526							;F2AZb:
    832  2526							;	  TST	     F2A,kIpcc			      ;Returns number of messages on the message queue
    833  2526				   ekIpcc
      0  2526					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2526					      db	101
      1  2526		       65		      .byte.b	101
      0  2527					      db	(UNKNOWNVEC-*)-1
      1  2527		       87		      .byte.b	(UNKNOWNVEC-*)-1
      0  2528					      db	oLeftBracket
      1  2528		       e0		      .byte.b	oLeftBracket
      0  2529					      TSTB	UNKNOWNVEC,oRightBracket
      0  2529					      db	101
      1  2529		       65		      .byte.b	101
      0  252a					      db	(UNKNOWNVEC-*)-1
      1  252a		       84		      .byte.b	(UNKNOWNVEC-*)-1
      0  252b					      db	oRightBracket
      1  252b		       e1		      .byte.b	oRightBracket
      0  252c					      IPCCHECK
      0  252c					      db	82
      1  252c		       52		      .byte.b	82
      0  252d					      RTN
      0  252d					      db	25
      1  252d		       19		      .byte.b	25
    838  252e
    839  252e				   UNKNOWNID
      0  252e					      IJMP	UNKNOWN
      0  252e					      db	29
      1  252e		       1d		      .byte.b	29
      0  252f					      dw	UNKNOWN
      1  252f		       39 24		      .word.w	UNKNOWN
    841  2531							;============================================================
    842  2531							; RND() is supposed to have an argument but if none
    843  2531							; was provided, just assume a large value.
    844  2531							;
    845  2531							;F2A:
    846  2531							;	  TSTB	      F2B,kRnd
    847  2531				   ekRnd
      0  2531					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2531					      db	101
      1  2531		       65		      .byte.b	101
      0  2532					      db	(UNKNOWNVEC-*)-1
      1  2532		       7c		      .byte.b	(UNKNOWNVEC-*)-1
      0  2533					      db	oLeftBracket
      1  2533		       e0		      .byte.b	oLeftBracket
      0  2534					      TSTB	F2A1,oRightBracket
      0  2534					      db	101
      1  2534		       65		      .byte.b	101
      0  2535					      db	(F2A1-*)-1
      1  2535		       06		      .byte.b	(F2A1-*)-1
      0  2536					      db	oRightBracket
      1  2536		       e1		      .byte.b	oRightBracket
      0  2537					      LIT	32766
      0  2537					      db	27
      1  2537		       1b		      .byte.b	27
      0  2538					      dw	32766
      1  2538		       fe 7f		      .word.w	32766
      0  253a					      RANDOM
      0  253a					      db	37
      1  253a		       25		      .byte.b	37
      0  253b					      RTN
      0  253b					      db	25
      1  253b		       19		      .byte.b	25
    853  253c
    854  253c				   F2A1
      0  253c					      CALL	EXPR	;GET RANGE
      0  253c					      db	28
      1  253c		       1c		      .byte.b	28
      0  253d					      dw	EXPR
      1  253d		       3d 24		      .word.w	EXPR
      0  253f					      TSTB	UNKNOWNVEC,oRightBracket
      0  253f					      db	101
      1  253f		       65		      .byte.b	101
      0  2540					      db	(UNKNOWNVEC-*)-1
      1  2540		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2541					      db	oRightBracket
      1  2541		       e1		      .byte.b	oRightBracket
      0  2542					      RANDOM
      0  2542					      db	37
      1  2542		       25		      .byte.b	37
      0  2543					      RTN
      0  2543					      db	25
      1  2543		       19		      .byte.b	25
    859  2544							;==========================================================
    860  2544							;	Return absolute value of expresion
    861  2544							;
    862  2544							;F2B:
    863  2544							;	  TSTB	      F2B2,kAbs
    864  2544				   ekAbs
      0  2544					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2544					      db	101
      1  2544		       65		      .byte.b	101
      0  2545					      db	(UNKNOWNVEC-*)-1
      1  2545		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  2546					      db	oLeftBracket
      1  2546		       e0		      .byte.b	oLeftBracket
      0  2547					      CALL	EXPR	;get value
      0  2547					      db	28
      1  2547		       1c		      .byte.b	28
      0  2548					      dw	EXPR
      1  2548		       3d 24		      .word.w	EXPR
      0  254a					      TSTB	UNKNOWNVEC,oRightBracket
      0  254a					      db	101
      1  254a		       65		      .byte.b	101
      0  254b					      db	(UNKNOWNVEC-*)-1
      1  254b		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  254c					      db	oRightBracket
      1  254c		       e1		      .byte.b	oRightBracket
      0  254d					      ABS
      0  254d					      db	38
      1  254d		       26		      .byte.b	38
      0  254e					      RTN
      0  254e					      db	25
      1  254e		       19		      .byte.b	25
    870  254f							;============================================================
    871  254f							;     Return the the status of a task, provide the PID
    872  254f							;
    873  254f							;F2B2:
    874  254f							;	  TSTB	      F2Z,kStat
    875  254f				   ekStat
      0  254f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  254f					      db	101
      1  254f		       65		      .byte.b	101
      0  2550					      db	(UNKNOWNVEC-*)-1
      1  2550		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2551					      db	oLeftBracket
      1  2551		       e0		      .byte.b	oLeftBracket
      0  2552					      Call	EXPR
      0  2552					      db	28
      1  2552		       1c		      .byte.b	28
      0  2553					      dw	EXPR
      1  2553		       3d 24		      .word.w	EXPR
      0  2555					      TSTB	UNKNOWNVEC,oRightBracket
      0  2555					      db	101
      1  2555		       65		      .byte.b	101
      0  2556					      db	(UNKNOWNVEC-*)-1
      1  2556		       58		      .byte.b	(UNKNOWNVEC-*)-1
      0  2557					      db	oRightBracket
      1  2557		       e1		      .byte.b	oRightBracket
      0  2558					      TASKSTAT
      0  2558					      db	66
      1  2558		       42		      .byte.b	66
      0  2559					      RTN
      0  2559					      db	25
      1  2559		       19		      .byte.b	25
    881  255a							;==============================================================
    882  255a							; Return the current tasks pid
    883  255a							;
    884  255a							;F2Z:
    885  255a							;	  TSTB	      F2ZA,kPid
    886  255a				   ekPid
      0  255a					      TASKPID
      0  255a					      db	77
      1  255a		       4d		      .byte.b	77
      0  255b					      RTN
      0  255b					      db	25
      1  255b		       19		      .byte.b	25
    889  255c							;===========================================================================
    890  255c							; Call a machine function, provide the address to call and optionally
    891  255c							; the value to be passed in reg A
    892  255c							;F2ZA:
    893  255c							;	  TSTB	       F2FUNC,kCall		       ;call machine function
    894  255c				   ekCall
      0  255c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  255c					      db	101
      1  255c		       65		      .byte.b	101
      0  255d					      db	(UNKNOWNVEC-*)-1
      1  255d		       51		      .byte.b	(UNKNOWNVEC-*)-1
      0  255e					      db	oLeftBracket
      1  255e		       e0		      .byte.b	oLeftBracket
      0  255f					      CALL	EXPR
      0  255f					      db	28
      1  255f		       1c		      .byte.b	28
      0  2560					      dw	EXPR
      1  2560		       3d 24		      .word.w	EXPR
      0  2562					      TSTB	F2B2A,oComma
      0  2562					      db	101
      1  2562		       65		      .byte.b	101
      0  2563					      db	(F2B2A-*)-1
      1  2563		       09		      .byte.b	(F2B2A-*)-1
      0  2564					      db	oComma
      1  2564		       e2		      .byte.b	oComma
      0  2565					      CALL	EXPR
      0  2565					      db	28
      1  2565		       1c		      .byte.b	28
      0  2566					      dw	EXPR
      1  2566		       3d 24		      .word.w	EXPR
      0  2568					      TSTB	UNKNOWNVEC,oRightBracket
      0  2568					      db	101
      1  2568		       65		      .byte.b	101
      0  2569					      db	(UNKNOWNVEC-*)-1
      1  2569		       45		      .byte.b	(UNKNOWNVEC-*)-1
      0  256a					      db	oRightBracket
      1  256a		       e1		      .byte.b	oRightBracket
      0  256b					      CALLFUNC
      0  256b					      db	53
      1  256b		       35		      .byte.b	53
      0  256c					      RTN
      0  256c					      db	25
      1  256c		       19		      .byte.b	25
    902  256d							; Run the gosub within this function
    903  256d				   F2B2A
      0  256d					      TSTB	UNKNOWNID,oRightBracket
      0  256d					      db	101
      1  256d		       65		      .byte.b	101
      0  256e					      db	(UNKNOWNID-*)-1
      1  256e		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  256f					      db	oRightBracket
      1  256f		       e1		      .byte.b	oRightBracket
      0  2570					      LIT	0	; No parameter passed so just load zero to A
      0  2570					      db	27
      1  2570		       1b		      .byte.b	27
      0  2571					      dw	0
      1  2571		       00 00		      .word.w	0
      0  2573					      CALLFUNC
      0  2573					      db	53
      1  2573		       35		      .byte.b	53
      0  2574					      RTN
      0  2574					      db	25
      1  2574		       19		      .byte.b	25
    908  2575							;===========================================================================
    909  2575							; Same as gosub but expects a return value
    910  2575							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    911  2575							;
    912  2575							;F2FUNC  TSTB	      F2C,kGofn
    913  2575				   ekGofn
      0  2575					      Call	GOSUBSTATEMENT
      0  2575					      db	28
      1  2575		       1c		      .byte.b	28
      0  2576					      dw	GOSUBSTATEMENT
      1  2576		       a1 25		      .word.w	GOSUBSTATEMENT
      0  2578					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  2578					      db	8
      1  2578		       08		      .byte.b	8
      0  2579					      db	GOSUB_RTN_VALUE
      1  2579		       81		      .byte.b	GOSUB_RTN_VALUE
      0  257a					      FASTXFER
      0  257a					      db	107
      1  257a		       6b		      .byte.b	107
    917  257b
    918  257b				   GOFNRet
      0  257b					      RTN
      0  257b					      db	25
      1  257b		       19		      .byte.b	25
    920  257c
    921  257c							;=================================================================================
    922  257c							;Check for a number !
    923  257c							;
    924  257c							;F0:
    925  257c				   FactNumber
      0  257c					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  257c					      db	35
      1  257c		       23		      .byte.b	35
      0  257d					      db	(FactVariable-*)-1
      1  257d		       0f		      .byte.b	(FactVariable-*)-1
      0  257e					      RTN
      0  257e					      db	25
      1  257e		       19		      .byte.b	25
    928  257f				   F1
      0  257f					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  257f					      db	101
      1  257f		       65		      .byte.b	101
      0  2580					      db	(F2RTN-*)-1
      1  2580		       08		      .byte.b	(F2RTN-*)-1
      0  2581					      db	oLeftBracket
      1  2581		       e0		      .byte.b	oLeftBracket
      0  2582					      CALL	EXPR
      0  2582					      db	28
      1  2582		       1c		      .byte.b	28
      0  2583					      dw	EXPR
      1  2583		       3d 24		      .word.w	EXPR
      0  2585					      TST	F2,oRightBracket
      0  2585					      db	32
      1  2585		       20		      .byte.b	32
      0  2586					      db	(F2-*)-1
      1  2586		       03		      .byte.b	(F2-*)-1
      0  2587					      db	oRightBracket,0
      1  2587		       e1 00		      .byte.b	oRightBracket,0
    932  2589				   F2RTN
      0  2589					      RTN
      0  2589					      db	25
      1  2589		       19		      .byte.b	25
    934  258a
    935  258a				   F2
      0  258a					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  258a					      db	13
      1  258a		       0d		      .byte.b	13
      0  258b					      dw	ERR_SYNTAX
      1  258b		       05 00		      .word.w	ERR_SYNTAX
    937  258d							;
    938  258d							;=============================================================================
    939  258d							; See if this is just a simple variable
    940  258d							;  Allow a subscript for any variable
    941  258d							;
    942  258d							;F2C:
    943  258d							;
    944  258d				   FactVariable
      0  258d					      TSTV	F1
      0  258d					      db	33
      1  258d		       21		      .byte.b	33
      0  258e					      db	(F1-*)-1
      1  258e		       f0		      .byte.b	(F1-*)-1
      0  258f					      TSTB	F2CLocalTask,oBang
      0  258f					      db	101
      1  258f		       65		      .byte.b	101
      0  2590					      db	(F2CLocalTask-*)-1
      1  2590		       04		      .byte.b	(F2CLocalTask-*)-1
      0  2591					      db	oBang
      1  2591		       e8		      .byte.b	oBang
      0  2592					      IND		; we just got a pid
      0  2592					      db	20
      1  2592		       14		      .byte.b	20
      0  2593					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  2593					      db	93
      1  2593		       5d		      .byte.b	93
      0  2594					      db	(UNKNOWNID-*)-1
      1  2594		       99		      .byte.b	(UNKNOWNID-*)-1
    949  2595
    950  2595				   F2CLocalTask
      0  2595					      TSTB	F2C1,oLeftSQBracket
      0  2595					      db	101
      1  2595		       65		      .byte.b	101
      0  2596					      db	(F2C1-*)-1
      1  2596		       08		      .byte.b	(F2C1-*)-1
      0  2597					      db	oLeftSQBracket
      1  2597		       e4		      .byte.b	oLeftSQBracket
      0  2598					      CALL	EXPR
      0  2598					      db	28
      1  2598		       1c		      .byte.b	28
      0  2599					      dw	EXPR
      1  2599		       3d 24		      .word.w	EXPR
      0  259b					      TSTB	UNKNOWNID,oRightSQBracket
      0  259b					      db	101
      1  259b		       65		      .byte.b	101
      0  259c					      db	(UNKNOWNID-*)-1
      1  259c		       91		      .byte.b	(UNKNOWNID-*)-1
      0  259d					      db	oRightSQBracket
      1  259d		       e5		      .byte.b	oRightSQBracket
      0  259e					      SUBSCRIPT
      0  259e					      db	64
      1  259e		       40		      .byte.b	64
    955  259f				   F2C1
      0  259f					      IND		; YES, GET THE VALUE.
      0  259f					      db	20
      1  259f		       14		      .byte.b	20
      0  25a0					      RTN
      0  25a0					      db	25
      1  25a0		       19		      .byte.b	25
    958  25a1
    959  25a1							;=============================================================
    960  25a1							; Gosub can be both a Function and a Subroutine
    961  25a1				   GOSUBSTATEMENT
      0  25a1					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  25a1					      db	106
      1  25a1		       6a		      .byte.b	106
      0  25a2					      db	(GOSUBCOMPILED-*)-1
      1  25a2		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  25a3					      CALL	EXPR	; GET DESTINATION
      0  25a3					      db	28
      1  25a3		       1c		      .byte.b	28
      0  25a4					      dw	EXPR
      1  25a4		       3d 24		      .word.w	EXPR
      0  25a6					      CALL	GOSUBCONT
      0  25a6					      db	28
      1  25a6		       1c		      .byte.b	28
      0  25a7					      dw	GOSUBCONT
      1  25a7		       b4 25		      .word.w	GOSUBCONT
      0  25a9					      lit	0	; mark as lookup on stack
      0  25a9					      db	27
      1  25a9		       1b		      .byte.b	27
      0  25aa					      dw	0
      1  25aa		       00 00		      .word.w	0
      0  25ac					      RTN
      0  25ac					      db	25
      1  25ac		       19		      .byte.b	25
    967  25ad
    968  25ad				   GOSUBCOMPILED
      0  25ad					      CALL	GOSUBCONT
      0  25ad					      db	28
      1  25ad		       1c		      .byte.b	28
      0  25ae					      dw	GOSUBCONT
      1  25ae		       b4 25		      .word.w	GOSUBCONT
      0  25b0					      lit	1	;mark as compiled on stack
      0  25b0					      db	27
      1  25b0		       1b		      .byte.b	27
      0  25b1					      dw	1
      1  25b1		       01 00		      .word.w	1
      0  25b3					      RTN
      0  25b3					      db	25
      1  25b3		       19		      .byte.b	25
    972  25b4
    973  25b4				   GOSUBCONT
      0  25b4					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  25b4					      db	101
      1  25b4		       65		      .byte.b	101
      0  25b5					      db	(GOSUBDONE-*)-1
      1  25b5		       11		      .byte.b	(GOSUBDONE-*)-1
      0  25b6					      db	oLeftBracket
      1  25b6		       e0		      .byte.b	oLeftBracket
      0  25b7					      STK2TMP		;Transfer stack top to temp
      0  25b7					      db	95
      1  25b7		       5f		      .byte.b	95
      0  25b8					      PUSHMATHSTACK		;Record stack frame for return
      0  25b8					      db	84
      1  25b8		       54		      .byte.b	84
    977  25b9				   GOSUBLOOP
      0  25b9					      CALL	EXPR	; Allows what ever fits onto stack
      0  25b9					      db	28
      1  25b9		       1c		      .byte.b	28
      0  25ba					      dw	EXPR
      1  25ba		       3d 24		      .word.w	EXPR
      0  25bc					      INCPARMCOUNT
      0  25bc					      db	88
      1  25bc		       58		      .byte.b	88
      0  25bd					      TSTB	GOSUBParmDONE,oComma
      0  25bd					      db	101
      1  25bd		       65		      .byte.b	101
      0  25be					      db	(GOSUBParmDONE-*)-1
      1  25be		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  25bf					      db	oComma
      1  25bf		       e2		      .byte.b	oComma
      0  25c0					      IJMP	GOSUBLOOP
      0  25c0					      db	29
      1  25c0		       1d		      .byte.b	29
      0  25c1					      dw	GOSUBLOOP
      1  25c1		       b9 25		      .word.w	GOSUBLOOP
    982  25c3				   GOSUBParmDONE
      0  25c3					      TSTB	F2,oRightBracket
      0  25c3					      db	101
      1  25c3		       65		      .byte.b	101
      0  25c4					      db	(F2-*)-1
      1  25c4		       c5		      .byte.b	(F2-*)-1
      0  25c5					      db	oRightBracket
      1  25c5		       e1		      .byte.b	oRightBracket
      0  25c6					      TMP2STK		; Restore line to goto
      0  25c6					      db	96
      1  25c6		       60		      .byte.b	96
    985  25c7				   GOSUBDONE
      0  25c7					      RTN
      0  25c7					      db	25
      1  25c7		       19		      .byte.b	25
    987  25c8
    988  25c8		       25 c8	   ILEND      equ	*
------- FILE mytb.asm
   2409  25c8		       25 c8	   PROGEND    equ	*
   2410  25c8
   2411  25c8
   2412  25c8							;=====================================================
   2413  25c8							; Define start of non page zero data
   2414 U260a					      seg.u	TBData
   2415 U260a
   2416 U260a							;=====================================================
   2417 U260a							; These are storage items not in page zero.
   2418 U260a							;
   2419 U260a							; IRQ BASIC Code Service RTN Support
      0 U260a				   SaveIrqReg db	0	; Store current setting
      1 U260a		       00		      .byte.b	0
      0 U260b				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U260b		       00		      .byte.b	0
      0 U260c				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U260c		       00		      .byte.b	0
      0 U260d				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U260d		       00 00		      .byte.b	0,0
   2424 U260f
   2425 U260f							;
   2426 U260f							;==================================================================================================
   2427 U260f							; Task Management information
   2428 U260f							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2429 U260f							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2430 U260f							; Task switchs happen at the beginning of the next Basic command line
   2431 U260f							; It will not happen during an input or output operations
   2432 U260f							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2433 U260f							; Task Zero is always the root task, main line program
   2434 U260f							;
   2435 U260f							; Layout is repeated for each configured task
   2436 U260f							; Task Table Byte   use masks follow
   2437 U260f		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2438 U260f		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2439 U260f		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2440 U260f		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2441 U260f		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2442 U260f
   2443 U260f		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2444 U2610		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2445 U2610		       27 0a	   TASKTABLEEND equ	*	; End of task table
   2446 U2610		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2447 U270a
   2448 U270a							;Task Cycle Counter and reset count
   2449 U270a		       00 00	   taskCurrentCycles ds	2
   2450 U270c		       00 00	   taskResetValue ds	2
   2451 U270e		       00	   taskCounter ds	1	; Count of active tasks
   2452 U270f
   2453 U270f							;
   2454 U270f							; Math stack and IL call and Gosub/For-next return stack definitions
   2455 U270f							;
   2456 U270f		       27 0f	   STACKSTART equ	*
   2457 U270f		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2458 U289f		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2459 U2a2f		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2460 U2caf		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code
   2461 U2caf		       00 34	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2462 U2caf		       2e cb	   STACKEND   equ	*
   2463 U2caf		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2464 U2ecb							;
   2465 U2ecb							;
   2466 U2ecb		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2467 U2f4f		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2468 U2f50		       00	   printtx    ds	1	;temp X for print funcs
   2469 U2f51		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2470 U2f52		       00	   promptChar ds	1	;the character to use for a prompt
   2471 U2f53		       00	   diddigit   ds	1	;for leading zero suppression
   2472 U2f54		       00	   putsy      ds	1
   2473 U2f55		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2474 U2f57		       00	   sign       ds	1	;0 = positive, else negative
   2475 U2f58		       00 00	   rtemp1     ds	2	;Temp for x and y
   2476 U2f5a		       00 00	   random     ds	2
   2477 U2f5c		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2478 U2f5e		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2479 U2f60		       00	   tempy      ds	1	;temp y storage
   2480 U2f61
   2481 U2f61
   2482 U2f61							; Moved from page zero as one clock cycle diff gives more space on page zero
   2483 U2f61		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2484 U2f63		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2485 U2f64		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2486 U2f65		       00	   lineLength ds	1	;Length of current line
   2487 U2f66
   2488 U2f66		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2489 U2f67		       00	   taskRDPending ds	1	; 1 = background read is pending
   2490 U2f68
   2491 U2f68				  -	      if	XKIM
   2492 U2f68				  -buffer     ds	BUFFER_SIZE
   2493 U2f68					      endif
   2494 U2f68							;
   2495 U2f68							; PROGRAMEND is the end of the user's BASIC program.
   2496 U2f68							; More precisely, it is one byte past the end.  Or,
   2497 U2f68							; it's where the next line added to the end will be
   2498 U2f68							; placed.
   2499 U2f68							;
   2500 U2f68		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2501 U2f6a		       00 00	   ProgramEnd ds	2	; End of users basic program
   2502 U2f6c		       00 00	   HighMem    ds	2	; highest location
   2503 U2f6e		       00 00	   UsedMem    ds	2	; size of user program
   2504 U2f70		       00 00	   FreeMem    ds	2	; amount of free memory
   2505 U2f72							;
   2506 U2f72							;=====================================================
   2507 U2f72							; This is the start of the user's BASIC program space.
   2508 U2f72							;
   2509 U2f72							; PERSONAL GOAL: This should be no larger than $0DFF.
   2510 U2f72							;		  0200-05FF = 1K
   2511 U2f72							;		  0200-09FF = 2K
   2512 U2f72							;		  0200-0DFF = 3K
   2513 U2f72							;		  0200-11FF = 4K
   2514 U2f72							;		  0200-13FF = 4.5K
   2515 U2f72							;
   2516 U2f72				  -	      if	FIXED
   2517 U2f72				  -	      org	$2000
   2518 U2f72					      endif
   2519 U2f72
   2520 U2f72		       2f 72	   FreeMemStart equ	*
   2521 U2f72							;/*
   2522 U2f72							;	if	CTMON65 || XKIM
   2523 U2f72							;		SEG Code
   2524 U2f72							;		org	AutoRun
   2525 U2f72							;		dw	TBasicCold
   2526 U2f72							;	endif
   2527 U2f72							;*/
   2528 U2f72					      end
