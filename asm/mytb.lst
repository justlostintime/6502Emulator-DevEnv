------- FILE mytb.asm LEVEL 1 PASS 6
      1 U270b				   input      processor	6502
      2 U270b ????						;=====================================================
      3 U270b ????						; Concurrent Tiny Basic, no longer Tiny
      4 U270b ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U270b ????						; Free Time. Now abiut 6K Full OS features.
      6 U270b ????						;
      7 U270b ????						; While working on the Corsham Technologies KIM Clone
      8 U270b ????						; project, I wanted to include a TINY BASIC since that
      9 U270b ????						; was a highly desirable feature of early computers.
     10 U270b ????						;
     11 U270b ????						; Rather than negotiating copyright issues for
     12 U270b ????						; existing BASICs, I decided to just write one from
     13 U270b ????						; scratch.
     14 U270b ????						;
     15 U270b ????						; 10/07/2017
     16 U270b ????						;
     17 U270b ????						; This implements a stripped down Tiny BASIC
     18 U270b ????						; interpreter using the Interpretive Language (IL)
     19 U270b ????						; method as described in the first few issues of
     20 U270b ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U270b ????						; to write various languages simply by changing the
     22 U270b ????						; IL code rather than the interpreter itself.
     23 U270b ????						;
     24 U270b ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U270b ????						;		* Fixed major bug in findLine that
     26 U270b ????						;		  caused corrupted lines, crashes, etc.
     27 U270b ????						;		* If no parameter given to RND, assume
     28 U270b ????						;		  32766.
     29 U270b ????						;		* No more error 5 when a program
     30 U270b ????						;		  reaches the end without an END.
     31 U270b ????						;
     32 U270b ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U270b ????						;		 * Unexpanded version to play with everything
     34 U270b ????						;		 * Add some usefull system level functions
     35 U270b ????						;		 * allow a larger number of tiny basic formats
     36 U270b ????						;		 * Add byte at start of line holding length
     37 U270b ????						;		   for faster execution of goto and gosub
     38 U270b ????						;		 * Re-added gosub
     39 U270b ????						;		 * allow ; or , at end if print stmt
     40 U270b ????						;		   without CRLF being added.
     41 U270b ????						;		 * Added extended function erase to
     42 U270b ????						;		   use the extended ctmon65 rm file
     43 U270b ????						;		 * Fix quoted text to not have to backtrack
     44 U270b ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U270b ????						;		 * Add concurrency features
     46 U270b ????						;
     47 U270b ????						; www.corshamtech.com
     48 U270b ????						; bob@corshamtech.com
     49 U270b ????						; JustLostInTime@gmail.com
     50 U270b ????						;
     51 U270b ????						;=====================================================
     52 U270b ????						;
     53 U270b ????						; Create TRUE and FALSE values for conditionals.
     54 U270b ????						;
     55 U270b ????
     56 U270b ????	       00 00	   FALSE      equ	0
     57 U270b ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U270b ????						;
     59 U270b ????						;---------------------------------------------------------
     60 U270b ????						; One of these must be set to indicate which environment
     61 U270b ????						; Tiny BASIC will be running in.  Here are the current
     62 U270b ????						; environments:
     63 U270b ????						;
     64 U270b ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U270b ????						; more K of RAM.
     66 U270b ????						;
     67 U270b ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U270b ????						; which enhances, without replacing, the standard KIM
     69 U270b ????						; monitor.  It gives access to routines to save/load files
     70 U270b ????						; to a micro SD card.
     71 U270b ????						;
     72 U270b ????						; CTMON65 is a from-scratch monitor written for the
     73 U270b ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U270b ????						; easily be ported to other systems.  It has support for
     75 U270b ????						; using a micro SD card for file storage/retrieval.
     76 U270b ????						;
     77 U270b ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U270b ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U270b ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U270b ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U270b ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U270b ????						;
     83 U270b ????						;   Need to define some macros for the dasm assembler
     84 U270b ????						;
     85 U270b ????				      MACRO	dw
     86 U270b ????				      .word	{0}
     87 U270b ????				      ENDM
     88 U270b ????
     89 U270b ????				      MACRO	db
     90 U270b ????				      .byte	{0}
     91 U270b ????				      ENDM
     92 U270b ????
     93 U270b ????						;
     94 U270b ????						; If set, include disk functions.
     95 U270b ????						;
     96 U270b ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U270b ????						;
     98 U270b ????						; If ILTRACE is set then dump out the address of every
     99 U270b ????						; IL opcode before executing it.
    100 U270b ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U270b ????						;
    102 U270b ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U270b ????						;
    104 U270b ????						; If FIXED is set, put the IL code and the user
    105 U270b ????						; program space at fixed locations in memory.	This is
    106 U270b ????						; meant only for debugging.
    107 U270b ????						;
    108 U270b ????	       00 00	   FIXED      equ	FALSE
    109 U270b ????						;
    110 U270b ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U270b ????						; BASIC, so keep this small!
    112 U270b ????						;
    113 U270b ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U270b ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U270b ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U270b ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U270b ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U270b ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U270b ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U270b ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U270b ????						;
    122 U270b ????						; Gosub entry types
    123 U270b ????
    124 U270b ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U270b ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U270b ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U270b ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U270b ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U270b ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U270b ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U270b ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U270b ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U270b ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U270b ????						;
    135 U270b ????						; Common ASCII constants
    136 U270b ????						;
    137 U270b ????	       00 07	   BEL	      equ	$07
    138 U270b ????	       00 08	   BS	      equ	$08
    139 U270b ????	       00 09	   TAB	      equ	$09
    140 U270b ????	       00 0a	   LF	      equ	$0A
    141 U270b ????	       00 0d	   CR	      equ	$0D
    142 U270b ????	       00 22	   quote      equ	$22
    143 U270b ????	       00 20	   SPACE      equ	$20
    144 U270b ????	       00 2c	   COMMA      equ	',
    145 U270b ????	       00 3b	   SEMICOLON  equ	';
    146 U270b ????	       00 3a	   COLON      equ	':
    147 U270b ????	       00 24	   DOLLAR     equ	'$
    148 U270b ????						;
    149 U270b ????						; These are error codes
    150 U270b ????						;
    151 U270b ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U270b ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U270b ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U270b ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U270b ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U270b ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U270b ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U270b ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U270b ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U270b ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U270b ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U270b ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U270b ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U270b ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U270b ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U270b ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U270b ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U270b ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U270b ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U270b ????						;
    171 U270b ????						;=====================================================
    172 U270b ????						; Zero page storage.
    173 U270b ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  1d93 ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       15 61	   CRLF       equ	tbcrlf
    307  0206		       17 09	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       16 b0	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 90 16    cold2      jsr	SetOutConsole
    314  0209		       20 9d 16 	      jsr	SetInConsole
    315  020c		       20 b0 16 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    319  023c							;
    320  023c		       20 00 0d 	      jsr	MemInit	;setup the free space available
    321  023f
    322  023f		       a9 01	   calcstack  lda	#1
    323  0241		       8d a7 1e 	      sta	taskCounter	; Initialize number of tasks to 1
    324  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  0246		       8d a9 1d 	      sta	taskTable	; mark the main task as active
    326  0249		       20 ed 0d 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  024c		       a9 d7		      lda	#IL&$ff
    328  024e		       85 43		      sta	ILPC
    329  0250		       a9 18		      lda	#IL>>8
    330  0252		       85 44		      sta	ILPC+1
    331  0254							;
    332  0254							;		  lda	  ProgramStart		     ; user prog
    333  0254							;		  sta	  ProgramEnd
    334  0254							;		  lda	  ProgramStart+1
    335  0254							;		  sta	  ProgramEnd+1
    336  0254							;
    337  0254							;  Init time slices defaults
    338  0254		       a9 02		      lda	#TASKCYCLESHIGH
    339  0256		       8d a6 1e 	      sta	taskResetValue+1
    340  0259		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  025b		       8d a5 1e 	      sta	taskResetValue
    342  025e							;
    343  025e							; Initialize the pseudo-random number sequence...
    344  025e							;
    345  025e		       a9 5a		      lda	#$5a
    346  0260		       8d f1 26 	      sta	rtemp1
    347  0263		       a9 9d		      lda	#%10011101
    348  0265		       8d f3 26 	      sta	random
    349  0268		       a9 5b		      lda	#%01011011
    350  026a		       8d f4 26 	      sta	random+1
    351  026d							;
    352  026d							;   Insert a Basic irq handler for the basic Language
    353  026d		       a9 7a		      lda	#ServiceIrq&$ff
    354  026f		       8d 00 df 	      sta	IRQvec
    355  0272		       a9 02		      lda	#ServiceIrq>>8
    356  0274		       8d 01 df 	      sta	IRQvec+1
    357  0277		       4c 9f 02 	      jmp	coldtwo
    358  027a
    359  027a							;
    360  027a							; This is the Basic IRQ handler
    361  027a		       48	   ServiceIrq pha
    362  027b		       ad a4 1d 	      lda	IRQStatus
    363  027e		       f0 0a		      BEQ	RetIrq
    364  0280		       ad a5 1d 	      lda	IRQPending
    365  0283		       d0 05		      bne	RetIrq
    366  0285		       a9 01		      lda	#1
    367  0287		       8d a5 1d 	      sta	IRQPending
    368  028a		       68	   RetIrq     pla
    369  028b		       40		      rti
    370  028c							;
    371  028c							;
    372  028c							; This is the warm start entry point
    373  028c							;
    374  028c		       20 90 16    warm2      jsr	SetOutConsole
    375  028f		       20 9d 16 	      jsr	SetInConsole
    376  0292		       20 61 15 	      jsr	CRLF
    377  0295		       ad ee 26 	      lda	errGoto
    378  0298		       85 43		      sta	ILPC
    379  029a		       ad ef 26 	      lda	errGoto+1
    380  029d		       85 44		      sta	ILPC+1
    381  029f							;
    382  029f							; And continue with both starts here
    383  029f							;
    384  029f				   coldtwo
    385  029f							;
    386  029f							; The ILTrace flag is now run-time settable.
    387  029f							;
    388  029f		       a9 00		      lda	#ILTRACE&$ff
    389  02a1		       85 40		      sta	ILTrace
    390  02a3							;
    391  02a3
    392  02a3		       a9 00		      lda	#0
    393  02a5		       85 5b		      sta	RunMode
    394  02a7		       8d 64 26 	      sta	LINBUF
    395  02aa
    396  02aa							; Clear everything from the stacks
    397  02aa
    398  02aa		       8d ff 26 	      sta	taskIOPending	; No one waiting for io
    399  02ad		       8d 00 27 	      sta	taskRDPending	; No one waiting for bg io
    400  02b0
    401  02b0		       20 60 0e 	      jsr	taskReset
    402  02b3							;
    403  02b3		       a9 64		      lda	#LINBUF&$ff
    404  02b5		       85 4f		      sta	CURPTR
    405  02b7		       a9 26		      lda	#LINBUF>>8
    406  02b9		       85 50		      sta	CURPTR+1	;fall through...
    407  02bb
    408  02bb							;=====================================================
    409  02bb							; This is the top of the IL interpreter.  This fetches
    410  02bb							; and executes the instruction currently pointed to
    411  02bb							; by ILPC and adjusts ILPC to point to the next
    412  02bb							; instruction to execute.
    413  02bb							;
    414  02bb		       ce a3 1e    NextIL     dec	taskCurrentCycles
    415  02be		       d0 03		      bne	NextIlNow
    416  02c0		       20 89 0e 	      jsr	iTaskSwitch	;check for a task switch
    417  02c3		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02c5		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02c7
    420  02c7		       20 ed 15 	      jsr	dbgLine	;Print the IL trace information
    421  02ca
    422  02ca		       a4 51	   NextIL2    ldy	CUROFF
    423  02cc		       20 58 15 	      jsr	SkipSpaces
    424  02cf		       84 51		      sty	CUROFF
    425  02d1							;Task IO Management
    426  02d1		       ad 00 27 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d4		       f0 08		      beq	NextILStr
    428  02d6		       20 a8 13 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02d9		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02db		       ce 00 27 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02de							;
    432  02de		       20 bf 11    NextILStr  jsr	getILByte
    433  02e1							;
    434  02e1							; When the handler is called, these are the conditions
    435  02e1							; of several important items:
    436  02e1							;
    437  02e1							;    (ILPC) will point to the byte AFTER the IL
    438  02e1							;    opcode being executed.
    439  02e1							;
    440  02e1							;    (CURPTR),CUROFF will point to the start of the
    441  02e1							;    next word in the input buffer.  Ie, the next word
    442  02e1							;    in the user program.
    443  02e1							;
    444  02e1		       0a		      asl
    445  02e2		       c9 cc		      cmp	#ILTBLend-ILTBL+2
    446  02e4		       90 33		      bcc	ILgood
    447  02e6							;
    448  02e6							; This handles an illegal IL opcode.  This is serious
    449  02e6							; and there's no way to recover.
    450  02e6							;
    451  02e6		       20 b0 16    ILbad      jsr	puts
      0  02e9					      db	CR,LF
      1  02e9		       0d 0a		      .byte.b	CR,LF
      0  02eb					      db	"Illegal IL "
      1  02eb		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f6					      db	0
      1  02f6		       00		      .byte.b	0
    455  02f7							;
    456  02f7							; Well this is awkward, we need to back up the IL
    457  02f7							; by one since it no longer points to the current
    458  02f7							; opcode.
    459  02f7							;
    460  02f7		       20 cc 11 	      jsr	decIL
    461  02fa							;
    462  02fa		       a0 00		      ldy	#0
    463  02fc		       b1 43		      lda	(ILPC),y
    464  02fe		       20 09 17 	      jsr	OUTHEX
    465  0301		       20 b0 16 	      jsr	puts
      0  0304					      db	" at ",0
      1  0304		       20 61 74 20*	      .byte.b	" at ",0
    467  0309		       a5 44		      lda	ILPC+1
    468  030b		       20 09 17 	      jsr	OUTHEX
    469  030e		       a5 43		      lda	ILPC
    470  0310		       20 09 17 	      jsr	OUTHEX
    471  0313		       20 61 15 	      jsr	CRLF
    472  0316		       4c 03 f0 	      jmp	MONITOR
    473  0319							;
    474  0319							; Just jump to the address (ILPC),y.  Have to do
    475  0319							; some goofy stuff.
    476  0319							;
    477  0319		       a8	   ILgood     tay		;move index into Y
    478  031a		       b9 27 03 	      lda	ILTBL,y
    479  031d		       85 59		      sta	dpl
    480  031f		       b9 28 03 	      lda	ILTBL+1,y
    481  0322		       85 5a		      sta	dpl+1
    482  0324		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0327							;
    484  0327							;=====================================================
    485  0327							; This is the IL jump table.  The IL opcode is
    486  0327							; mulitplied by two, then looked-up in this table.
    487  0327							; There is absolutely nothing special about the order
    488  0327							; of entries here... they all decode at exactly the
    489  0327							; same speed.	However the entry number must match the
    490  0327							; values in IL.inc.
    491  0327							;
    492  0327				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0327					      include	"ilvectortable.asm"
      1  0327					      seg	Code
      2  0327
      0  0327					      dw	iXINIT	;0
      1  0327		       29 04		      .word.w	iXINIT
      0  0329					      dw	iDONE	;1
      1  0329		       44 04		      .word.w	iDONE
      0  032b					      dw	iPRS	;2
      1  032b		       60 04		      .word.w	iPRS
      0  032d					      dw	iPRN	;3
      1  032d		       6a 04		      .word.w	iPRN
      0  032f					      dw	iSPC	;4
      1  032f		       73 04		      .word.w	iSPC
      0  0331					      dw	iNLINE	;5
      1  0331		       1c 09		      .word.w	iNLINE
      0  0333					      dw	iNXT	;6
      1  0333		       7b 04		      .word.w	iNXT
      0  0335					      dw	iXFER	;7
      1  0335		       a7 04		      .word.w	iXFER
      0  0337					      dw	iSAV	;8
      1  0337		       d4 04		      .word.w	iSAV
      0  0339					      dw	iRSTR	;9
      1  0339		       17 05		      .word.w	iRSTR
      0  033b					      dw	iCMPR	;10
      1  033b		       4c 05		      .word.w	iCMPR
      0  033d					      dw	iINNUM	;11
      1  033d		       cd 05		      .word.w	iINNUM
      0  033f					      dw	iFIN	;12
      1  033f		       01 06		      .word.w	iFIN
      0  0341					      dw	iERR	;13
      1  0341		       15 06		      .word.w	iERR
      0  0343					      dw	iADD	;14
      1  0343		       85 06		      .word.w	iADD
      0  0345					      dw	iSUB	;15
      1  0345		       9b 06		      .word.w	iSUB
      0  0347					      dw	iNEG	;16
      1  0347		       b1 06		      .word.w	iNEG
      0  0349					      dw	iMUL	;17
      1  0349		       c9 06		      .word.w	iMUL
      0  034b					      dw	iDIV	;18
      1  034b		       09 07		      .word.w	iDIV
      0  034d					      dw	iSTORE	;19
      1  034d		       5f 07		      .word.w	iSTORE
      0  034f					      dw	iIND	;20
      1  034f		       77 07		      .word.w	iIND
      0  0351					      dw	iLST	;21
      1  0351		       e5 07		      .word.w	iLST
      0  0353					      dw	iINIT	;22
      1  0353		       f1 03		      .word.w	iINIT
      0  0355					      dw	iGETLINE	;23
      1  0355		       4a 08		      .word.w	iGETLINE
      0  0357					      dw	iINSRT	;24
      1  0357		       58 08		      .word.w	iINSRT
      0  0359					      dw	iRTN	;25
      1  0359		       16 09		      .word.w	iRTN
      0  035b					      dw	MONITOR	;26
      1  035b		       03 f0		      .word.w	MONITOR
      0  035d					      dw	iLIT	;27
      1  035d		       3c 09		      .word.w	iLIT
      0  035f					      dw	iCALL	;28
      1  035f		       22 09		      .word.w	iCALL
      0  0361					      dw	iJMP	;29
      1  0361		       2a 09		      .word.w	iJMP
      0  0363					      dw	iVINIT	;30
      1  0363		       59 09		      .word.w	iVINIT
      0  0365					      dw	iERRGOTO	;31
      1  0365		       5f 09		      .word.w	iERRGOTO
      0  0367					      dw	iTST	;32
      1  0367		       6b 09		      .word.w	iTST
      0  0369					      dw	iTSTV	;33
      1  0369		       4c 0a		      .word.w	iTSTV
      0  036b					      dw	iTSTL	;34
      1  036b		       cb 0a		      .word.w	iTSTL
      0  036d					      dw	iTSTN	;35
      1  036d		       e6 0a		      .word.w	iTSTN
      0  036f					      dw	iFREE	;36
      1  036f		       63 0b		      .word.w	iFREE
      0  0371					      dw	iRANDOM	;37
      1  0371		       6c 0b		      .word.w	iRANDOM
      0  0373					      dw	iABS	;38
      1  0373		       3d 0c		      .word.w	iABS
     42  0375							;
     43  0375							; Disk functions.  There must be pointers
     44  0375							; to functions even if no disk is supported.
     45  0375							; Makes things easier in IL.inc.
     46  0375							;
     47  0375					      if	DISK_ACCESS
      0  0375					      dw	iOPENREAD	;39
      1  0375		       b2 17		      .word.w	iOPENREAD
      0  0377					      dw	iOPENWRITE	;40
      1  0377		       06 18		      .word.w	iOPENWRITE
      0  0379					      dw	iDCLOSE	;41
      1  0379		       8a 18		      .word.w	iDCLOSE
      0  037b					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037b		       25 18		      .word.w	iDGETLINE
      0  037d					      dw	iDLIST	;43 Did you remeber your towel?
      1  037d		       84 18		      .word.w	iDLIST
      0  037f					      dw	iDDIR	;44
      1  037f		       5f 18		      .word.w	iDDIR
      0  0381					      dw	iRMFILE	;45
      1  0381		       e0 17		      .word.w	iRMFILE
     55  0383				  -	      else
     56  0383				  -	      dw	NextIL	;39
     57  0383				  -	      dw	NextIL	;40
     58  0383				  -	      dw	NextIL	;41
     59  0383				  -	      dw	NextIL	;42
     60  0383				  -	      dw	NextIL	;43
     61  0383				  -	      dw	NextIL	;44
     62  0383				  -	      dw	NextIL	;45
     63  0383					      endif
     64  0383							;
      0  0383					      dw	iCLEARSCREEN	;46
      1  0383		       26 17		      .word.w	iCLEARSCREEN
      0  0385					      dw	iPOKEMEMORY	;47
      1  0385		       ca 0b		      .word.w	iPOKEMEMORY
      0  0387					      dw	iPEEKMEMORY	;48
      1  0387		       df 0b		      .word.w	iPEEKMEMORY
      0  0389					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0389		       b2 09		      .word.w	iTSTLET
      0  038b					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038b		       f0 09		      .word.w	iTSTDONE
      0  038d					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038d		       0c 0c		      .word.w	iGETCHAR
      0  038f					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038f		       20 0c		      .word.w	iPUTCHAR
      0  0391					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0391		       f5 0b		      .word.w	iCallFunc
      0  0393					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0393		       9d 05		      .word.w	iBranch
      0  0395					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0395		       95 09		      .word.w	iTSTStr
      0  0397					      dw	iSetIrq	;56	   sets the irq handler
      1  0397		       ba 0c		      .word.w	iSetIrq
      0  0399					      dw	iTstIrq	;57	   test if irq is pending
      1  0399		       2b 0b		      .word.w	iTstIrq
      0  039b					      dw	iRET	;58	   return from interupt
      1  039b		       05 05		      .word.w	iRET
      0  039d					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039d		       e4 05		      .word.w	iINSTR
      0  039f					      dw	iMOD	;60	   returns remainder of division
      1  039f		       12 07		      .word.w	iMOD
      0  03a1					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a1		       dd 0e		      .word.w	iTaskSet
      0  03a3					      dw	iETask	;62	   Terminates a task
      1  03a3		       08 10		      .word.w	iETask
      0  03a5					      dw	iNTask	;63	   goto next task
      1  03a5		       bb 0f		      .word.w	iNTask
      0  03a7					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a7		       8c 07		      .word.w	iArray
      0  03a9					      dw	iTaskKill	;65	   kill a running task
      1  03a9		       b3 0f		      .word.w	iTaskKill
      0  03ab					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ab		       87 0f		      .word.w	iTaskStat
      0  03ad					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03ad		       2b 0c		      .word.w	iHexOut
      0  03af					      dw	iReadComplete	;68	   Called after a background read completes
      1  03af		       b9 05		      .word.w	iReadComplete
      0  03b1					      dw	iReadStart	;69	   Called to start a background read request
      1  03b1		       af 05		      .word.w	iReadStart
      0  03b3					      dw	iStartIO	;70	   Lock task until io complete
      1  03b3		       eb 0f		      .word.w	iStartIO
      0  03b5					      dw	iEndIO	;71	   release task lock for io
      1  03b5		       f1 0f		      .word.w	iEndIO
      0  03b7					      dw	iLogNot	;72	   Logical not
      1  03b7		       96 0c		      .word.w	iLogNot
      0  03b9					      dw	iLogOr	;73	   Logical Or
      1  03b9		       6c 0c		      .word.w	iLogOr
      0  03bb					      dw	iLogAnd	;74	   Logical And
      1  03bb		       57 0c		      .word.w	iLogAnd
      0  03bd					      dw	iLogXor	;75	   Logical Xor
      1  03bd		       81 0c		      .word.w	iLogXor
      0  03bf					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bf		       c6 0f		      .word.w	iWTASK
      0  03c1					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c1		       fc 0f		      .word.w	iTASKPID
      0  03c3					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c3		       f6 0c		      .word.w	iTRACEPROG
      0  03c5					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c5		       6e 15		      .word.w	idbgBasic
      0  03c7					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c7		       be 10		      .word.w	iIPCS
      0  03c9					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c9		       d5 10		      .word.w	iIPCR
      0  03cb					      dw	iIPCC	;82	   Check if any message available for task
      1  03cb		       e9 10		      .word.w	iIPCC
      0  03cd					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cd		       f6 10		      .word.w	iIPCIO
      0  03cf					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cf		       55 0d		      .word.w	iPushMathStack
      0  03d1					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d1		       85 0d		      .word.w	iPopMathStack
      0  03d3					      dw	iSaveMathStack	;86	   Save all math info
      1  03d3		       a2 0d		      .word.w	iSaveMathStack
      0  03d5					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d5		       c1 0d		      .word.w	iRestoreMathStack
      0  03d7					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d7		       72 0d		      .word.w	iIncParmCount
      0  03d9					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d9		       28 10		      .word.w	iTaskGetMathStack
      0  03db					      dw	iTaskEnable	;90	   enable a suspended task
      1  03db		       55 0f		      .word.w	iTaskEnable
      0  03dd					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03dd		       6f 0f		      .word.w	iTaskSuspend
      0  03df					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03df		       42 10		      .word.w	iTaskPutMathPtr
      0  03e1					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e1		       43 0a		      .word.w	iTSTVT
      0  03e3					      dw	iSetR2	;94
      1  03e3		       34 09		      .word.w	iSetR2
      0  03e5					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e5		       e3 04		      .word.w	iStk2Tmp
      0  03e7					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e7		       f4 04		      .word.w	iTmp2Stk
      0  03e9					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e9		       d1 09		      .word.w	iTSTBYTE
      0  03eb					      dw	iINCVAR	;98	   Increment variable
      1  03eb		       15 0a		      .word.w	iINCVAR
      0  03ed					      dw	iDECVAR	;99	   Decrement variable
      1  03ed		       2d 0a		      .word.w	iDECVAR
      0  03ef					      dw	iSLICE	;100	   set the time slice for tasks
      1  03ef		       51 10		      .word.w	iSLICE
    120  03f1
------- FILE mytb.asm
    494  03f1		       03 f1	   ILTBLend   equ	*
    495  03f1							;
    496  03f1							;=====================================================
    497  03f1							;=====================================================
    498  03f1							;=====================================================
    499  03f1							; This marks the start of the handlers for IL opcodes.
    500  03f1							;=====================================================
    501  03f1							;=====================================================
    502  03f1							;=====================================================
    503  03f1							;
    504  03f1							;
    505  03f1		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03f3		       85 47		      sta	ILSTACKPTR
    507  03f5		       85 4a		      sta	MATHSTACKPTR
    508  03f7		       85 4d		      sta	GOSUBSTACKPTR
    509  03f9		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  03fb		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  03fd							;
    512  03fd		       ad 01 27 	      lda	ProgramStart	;user prog
    513  0400		       85 4f		      sta	CURPTR
    514  0402		       8d aa 1d 	      sta	taskTable+1
    515  0405		       8d 03 27 	      sta	ProgramEnd
    516  0408		       ad 02 27 	      lda	ProgramStart+1
    517  040b		       85 50		      sta	CURPTR+1
    518  040d		       8d ab 1d 	      sta	taskTable+2
    519  0410		       8d 04 27 	      sta	ProgramEnd+1
    520  0413		       a9 80		      lda	#TASKACTIVE
    521  0415		       8d a9 1d 	      sta	taskTable	;Mark the first slot as active
    522  0418		       a9 01		      lda	#1
    523  041a		       8d a7 1e 	      sta	taskCounter	;there is always one task / Main task
    524  041d		       ad a5 1e 	      lda	taskResetValue
    525  0420		       8d a3 1e 	      sta	taskCurrentCycles	; set up the task switch counts
    526  0423		       ad a6 1e 	      lda	taskResetValue+1
    527  0426		       8d a4 1e 	      sta	taskCurrentCycles+1
    528  0429							;
    529  0429							; fall into XINIT...
    530  0429							;
    531  0429							;=====================================================
    532  0429							; This initializes for the start of the next line of
    533  0429							; BASIC text.
    534  0429							;
    535  0429		       78	   iXINIT     sei		;ensure interupts are off
    536  042a		       20 60 0e 	      jsr	taskReset	;Clear the task table
    537  042d		       8d a5 1d 	      sta	IRQPending	; reset the irq pending
    538  0430		       8d a4 1d 	      sta	IRQStatus	; Make sure irqs are off
    539  0433
    540  0433		       4c bb 02    goodExit   jmp	NextIL
    541  0436							;
    542  0436							;=====================================================
    543  0436							; This check if the escape key has been entered
    544  0436							; then changes out of run mode. z Set if esc found
    545  0436				   BreakSet
    546  0436		       20 0f f0 	      jsr	ISCHAR
    547  0439		       f0 06		      beq	BreakNo
    548  043b		       20 ad 16 	      jsr	VGETCH
    549  043e		       c9 1b		      cmp	#$1B
    550  0440		       60		      rts
    551  0441				   BreakNo
    552  0441		       a9 01		      lda	#1
    553  0443		       60		      rts
    554  0444
    555  0444							;
    556  0444
    557  0444							;=====================================================
    558  0444							; Verify there is nothing else on this input line.
    559  0444							; If there is, generate an error.
    560  0444							;
    561  0444		       a4 51	   iDONE      ldy	CUROFF
    562  0446		       20 58 15 	      jsr	SkipSpaces
    563  0449		       b1 4f		      lda	(CURPTR),y
    564  044b		       f0 10		      beq	doneadv
    565  044d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    566  044f		       d0 05		      bne	idoneErr
    567  0451		       84 51		      sty	CUROFF
    568  0453		       4c bb 02 	      jmp	NextIL	; continue on this line
    569  0456
    570  0456				   idoneErr
    571  0456		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  0458		       a9 00		      lda	#0
    573  045a		       4c 18 06 	      jmp	iErr2
    574  045d							;
    575  045d							; Advance to the next line
    576  045d							;
    577  045d				   doneadv
    578  045d							;		 jsr	 FindNext2
    579  045d		       4c bb 02 	      jmp	NextIL
    580  0460							;
    581  0460							;=====================================================
    582  0460							; Print the string until a closing quote
    583  0460							;
    584  0460		       a4 51	   iPRS       ldy	CUROFF
    585  0462							;
    586  0462							; Odd logic here.  The main loop skipped any leading
    587  0462							; whitespace inside the quoted text, so move back to
    588  0462							; the quote, then move forward again.
    589  0462							;
    590  0462		       20 da 16 	      jsr	PrtQuoted
    591  0465		       84 51		      sty	CUROFF
    592  0467		       4c bb 02 	      jmp	NextIL
    593  046a							;
    594  046a							;=====================================================
    595  046a							; Pop the top off the stack and print it as a signed
    596  046a							; decimal number.
    597  046a							;
    598  046a		       20 a8 14    iPRN       jsr	popR0
    599  046d		       20 6a 12 	      jsr	PrintDecimal
    600  0470		       4c bb 02 	      jmp	NextIL
    601  0473							;
    602  0473							;=====================================================
    603  0473							; Space to next zone.	Currently the code does not
    604  0473							; keep track of which column the output is on, so
    605  0473							; just print a tab.
    606  0473							;
    607  0473		       a9 09	   iSPC       lda	#TAB
    608  0475		       20 aa 16 	      jsr	VOUTCH
    609  0478		       4c bb 02 	      jmp	NextIL
    610  047b							;
    611  047b							;=====================================================
    612  047b							; If in immediate mode, jump to the address following
    613  047b							; the NXT instruction.  Else move to the next line of
    614  047b							; user code and continue.
    615  047b							;
    616  047b		       a5 5b	   iNXT       lda	RunMode
    617  047d		       d0 03		      bne	iNxtRun	;in run mode
    618  047f							;
    619  047f							; Get address and jump to it.
    620  047f							;
    621  047f		       4c 2a 09 	      jmp	iJMP
    622  0482							;
    623  0482				   iNxtRun
    624  0482		       a4 51		      ldy	CUROFF
    625  0484		       20 58 15 	      jsr	SkipSpaces
    626  0487		       b1 4f		      lda	(CURPTR),y
    627  0489		       c9 3a		      cmp	#COLON
    628  048b		       d0 09		      bne	iNxtRunGo
    629  048d		       c8		      iny
    630  048e		       20 58 15 	      jsr	SkipSpaces
    631  0491		       84 51		      sty	CUROFF
    632  0493		       4c a1 04 	      jmp	iNxtRun2
    633  0496
    634  0496				   iNxtRunGo
    635  0496		       20 49 12 	      jsr	FindNextLine
    636  0499		       20 5d 12 	      jsr	AtEnd
    637  049c		       d0 03		      bne	iNxtRun2	;not at end
    638  049e							;
    639  049e							; At the end of the program.  Pretend an END statement
    640  049e							; was found.
    641  049e							;
    642  049e		       4c 01 06    iFINv      jmp	iFIN
    643  04a1							;
    644  04a1		       20 bb 11    iNxtRun2   jsr	getILWord	;ignore next word
    645  04a4		       4c bb 02 	      jmp	NextIL
    646  04a7							;
    647  04a7							;=====================================================
    648  04a7							; XFER takes the number on top of the stack and looks
    649  04a7							; for that line in the program, or the next line
    650  04a7							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04a7							; find the next one after that.
    652  04a7							;
    653  04a7		       20 a8 14    iXFER      jsr	popR0
    654  04aa		       20 04 12 	      jsr	findLine
    655  04ad		       20 5d 12    iXFER2     jsr	AtEnd	;at end of user program?
    656  04b0		       f0 ec		      beq	iFINv
    657  04b2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    658  04b4		       84 51		      sty	CUROFF
    659  04b6		       a9 ff		      lda	#$ff
    660  04b8		       85 5b		      sta	RunMode
    661  04ba							;
    662  04ba							; Transfer IL to STMT.  I don't like having this
    663  04ba							; hard-coded; fix it.
    664  04ba							;
    665  04ba		       a9 e5		      lda	#STMT&$ff
    666  04bc		       85 43		      sta	ILPC
    667  04be		       a9 18		      lda	#STMT>>8
    668  04c0		       85 44		      sta	ILPC+1
    669  04c2		       4c bb 02 	      jmp	NextIL
    670  04c5							;
    671  04c5							; Run
    672  04c5							;
    673  04c5				   iXferok
    674  04c5		       a9 ff		      lda	#$ff
    675  04c7		       85 5b		      sta	RunMode	;we're running
    676  04c9							;
    677  04c9							; Need a more elegant way to do this
    678  04c9							;
    679  04c9		       a9 e5		      lda	#STMT&$ff
    680  04cb		       85 43		      sta	ILPC
    681  04cd		       a9 18		      lda	#STMT>>8
    682  04cf		       85 44		      sta	ILPC+1
    683  04d1		       4c bb 02 	      jmp	NextIL
    684  04d4							;
    685  04d4							;=====================================================
    686  04d4							; Save the pointer to the next line to the call stack.
    687  04d4							;
    688  04d4		       20 3e 14    iSAV       jsr	pushLN
    689  04d7		       b0 03		      bcs	iSAVErr
    690  04d9		       4c bb 02 	      jmp	NextIL
    691  04dc
    692  04dc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04de		       a9 00	   iSAVErr2   lda	#0
    694  04e0		       4c 18 06 	      jmp	iErr2
    695  04e3							;====================================================
    696  04e3							; Move stack top to and from temp area
    697  04e3				   iStk2Tmp
    698  04e3		       20 a8 14 	      jsr	popR0
    699  04e6		       a5 52		      lda	R0
    700  04e8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04ea		       91 41		      sta	(VARIABLES),y
    702  04ec		       c8		      iny
    703  04ed		       a5 53		      lda	R0+1
    704  04ef		       91 41		      sta	(VARIABLES),y
    705  04f1		       4c bb 02 	      jmp	NextIL
    706  04f4
    707  04f4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  04f6		       b1 41		      lda	(VARIABLES),y
    709  04f8		       85 52		      sta	R0
    710  04fa		       c8		      iny
    711  04fb		       b1 41		      lda	(VARIABLES),y
    712  04fd		       85 53		      sta	R0+1
    713  04ff		       20 24 14 	      jsr	pushR0
    714  0502		       4c bb 02 	      jmp	NextIL
    715  0505							;
    716  0505							;=====================================================
    717  0505							; Pop the next line from the call stack.
    718  0505							;
    719  0505		       20 63 14    iRET       jsr	popLN
    720  0508		       b0 d2		      bcs	iSAVErr
    721  050a		       a0 03		      ldy	#3
    722  050c		       84 51		      sty	CUROFF
    723  050e		       a9 00		      lda	#0
    724  0510		       8d a5 1d 	      sta	IRQPending
    725  0513		       58		      cli
    726  0514		       4c bb 02 	      jmp	NextIL
    727  0517							;
    728  0517							;=====================================================
    729  0517							; Return from GOSUB function
    730  0517							;
    731  0517		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    732  0519		       f0 0f		      beq	iRSTRNoValue
    733  051b		       a5 58		      lda	R2
    734  051d		       85 56		      sta	MQ
    735  051f		       88		      dey
    736  0520		       b1 4b		      lda	(GOSUBSTACK),y
    737  0522		       c9 81		      cmp	#GOSUB_RTN_VALUE
    738  0524		       d0 04		      bne	iRSTRNoValue
    739  0526		       a9 01		      lda	#1
    740  0528		       d0 02		      bne	iRSTRExit
    741  052a				   iRSTRNoValue
    742  052a		       a9 00		      lda	#0
    743  052c				   iRSTRExit
    744  052c		       85 58		      sta	R2
    745  052e		       20 63 14 	      jsr	popLN
    746  0531		       b0 06		      bcs	iRSTRErr
    747  0533		       20 8b 0d 	      jsr	PopMathStackNow
    748  0536		       4c bb 02 	      jmp	NextIL
    749  0539
    750  0539		       ad a8 1d    iRSTRErr   lda	taskPtr	; Check if this is task zero
    751  053c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    752  053e		       a5 56		      lda	MQ
    753  0540		       d0 03		      bne	taskRet
    754  0542		       20 3b 17 	      jsr	pushFalse	; the result code by default is 0
    755  0545				   taskRet
    756  0545		       4c 08 10 	      jmp	iETask	; not task zero then do a task end instead
    757  0548				   taskZeroEnd
    758  0548		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    759  054a		       d0 92		      bne	iSAVErr2
    760  054c							;
    761  054c							;=====================================================
    762  054c							; Compare items on stack.  Okay, so on input there are
    763  054c							; three things on the stack
    764  054c							;
    765  054c							;    EXPR2 <- Top of stack
    766  054c							;    OP    <- relational operator, next on stack
    767  054c							;    EXPR1 <- last item on stack
    768  054c							;
    769  054c							; Comparison is: EXPR1 <operator> EXPR2
    770  054c							;
    771  054c							; Operator is one of...
    772  054c							;
    773  054c							;    2 is =
    774  054c							;    1 is <
    775  054c							;    3 is <=
    776  054c							;    5 is <>
    777  054c							;    4 is >
    778  054c							;    6 is >=
    779  054c							;
    780  054c							; Those are bit-mapped:
    781  054c							;
    782  054c							;    xxxxxGEL
    783  054c							;
    784  054c							;    G = Greater than
    785  054c							;    E = Equal
    786  054c							;    L = Less than
    787  054c							;
    788  054c							; If the comparison is false, do a NXT, ie, move to the
    789  054c							; next line and continue.  If true, continue executing
    790  054c							; on this line.
    791  054c							;
    792  054c		       00 01	   REL_LT     equ	%001
    793  054c		       00 02	   REL_EQUAL  equ	%010
    794  054c		       00 04	   REL_GT     equ	%100
    795  054c							;
    796  054c		       20 c0 14    iCMPR      jsr	popR1
    797  054f		       20 d7 14 	      jsr	popMQ	;operator in MQ
    798  0552		       20 a8 14 	      jsr	popR0
    799  0555		       20 5e 05 	      jsr	iCMPRsub
    800  0558		       20 24 14 	      jsr	pushR0
    801  055b		       4c bb 02 	      jmp	NextIL
    802  055e							;
    803  055e							; See if they are equal or not
    804  055e							;
    805  055e				   iCMPRsub		; Called by internal functions
    806  055e
    807  055e		       a5 52		      lda	R0
    808  0560		       c5 54		      cmp	R1
    809  0562		       d0 0a		      bne	iCMPRnoteq	;try not equal
    810  0564		       a5 53		      lda	R0+1
    811  0566		       c5 55		      cmp	R1+1
    812  0568		       d0 04		      bne	iCMPRnoteq
    813  056a							;
    814  056a							; Equal, set the flag in MQ+1
    815  056a							;
    816  056a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    817  056c		       d0 14		      bne	iCMPcom	;Exit it is equal
    818  056e							;
    819  056e							; See if EXPR1 (R0) < EXPR2 (R1)
    820  056e							; See www.6502.org/tutorials/compare_beyond.html
    821  056e							;
    822  056e				   iCMPRnoteq
    823  056e		       a5 52		      lda	R0
    824  0570		       c5 54		      cmp	R1
    825  0572		       a5 53		      lda	R0+1
    826  0574		       e5 55		      sbc	R1+1
    827  0576		       50 02		      bvc	iCMPR_2
    828  0578		       49 80		      eor	#$80
    829  057a		       30 04	   iCMPR_2    bmi	iCMPlt
    830  057c		       a9 04		      lda	#REL_GT
    831  057e		       d0 02		      bne	iCMPcom
    832  0580		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    833  0582
    834  0582		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    835  0584							;
    836  0584							; Now compare the end result with what the caller
    837  0584							; was looking for.
    838  0584							;
    839  0584		       25 56		      and	MQ
    840  0586		       f0 0c		      beq	iCMPno	; no match
    841  0588		       a9 ff		      lda	#$FF	; true is $ffff
    842  058a		       85 52		      sta	R0
    843  058c		       85 53		      sta	R0+1
    844  058e		       d0 0c		      bne	iCMPDone
    845  0590							;
    846  0590							; R0 > R1
    847  0590							;
    848  0590		       a9 04	   iCMPgt     lda	#REL_GT
    849  0592		       d0 ee		      bne	iCMPcom
    850  0594				   iCMPno
    851  0594		       a9 00		      lda	#0
    852  0596		       85 52		      sta	R0
    853  0598		       a9 00		      lda	#0
    854  059a		       85 53		      sta	R0+1
    855  059c
    856  059c				   iCMPDone
    857  059c		       60		      rts
    858  059d
    859  059d							;
    860  059d							; if Not a match, so jump to the next line of code.
    861  059d							; Branches based upon value on top of the stack
    862  059d				   iBranch
    863  059d		       20 a8 14 	      jsr	popR0
    864  05a0		       a5 52		      lda	R0
    865  05a2		       05 53		      ora	R0+1
    866  05a4		       f0 03		      beq	iBranchFalse	; not true
    867  05a6		       4c bb 02 	      jmp	NextIL	; It is true if any value not zero
    868  05a9							;
    869  05a9				   iBranchFalse
    870  05a9		       20 49 12 	      jsr	FindNextLine
    871  05ac		       4c ad 04 	      jmp	iXFER2
    872  05af							;
    873  05af							;=====================================================
    874  05af							; Start a read of data in background
    875  05af				   iReadStart
    876  05af		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05b1		       a6 01		      ldx	1	; Indicate to start read in background
    878  05b3		       20 41 13 	      jsr	GetLine	; Call the getline to start read
    879  05b6		       4c bb 02 	      jmp	NextIL	; next instruction
    880  05b9							;
    881  05b9							;=====================================================
    882  05b9							; Complete the read and return the curptr, curoff pointing to data
    883  05b9				   iReadComplete
    884  05b9		       20 3e 14 	      jsr	pushLN
    885  05bc		       90 03		      bcc	iReadOk
    886  05be		       4c 5c 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    887  05c1				   iReadOk
    888  05c1		       20 61 13 	      jsr	ReadComplete
    889  05c4		       4c bb 02 	      jmp	NextIL
    890  05c7		       20 63 14 	      jsr	popLN
    891  05ca		       4c bb 02 	      jmp	NextIL
    892  05cd							;=====================================================
    893  05cd							; Get a line of text from the user, convert to a
    894  05cd							; number, leave on top of stack.
    895  05cd							;
    896  05cd				   iINNUM
    897  05cd		       20 3e 14 	      jsr	pushLN
    898  05d0		       b0 ec		      bcs	iReadErr	; Stack over flow error
    899  05d2							;
    900  05d2		       a9 3f		      lda	#'?
    901  05d4		       a2 00		      ldx	#0	;Wait for complete
    902  05d6		       20 41 13 	      jsr	GetLine
    903  05d9		       20 d6 12 	      jsr	getDecimal
    904  05dc		       20 24 14 	      jsr	pushR0	;put onto stack
    905  05df		       b0 dd		      bcs	iReadErr	;StackOverflow error
    906  05e1							;
    907  05e1		       4c fb 05 	      jmp	ExitIn
    908  05e4							;
    909  05e4							;=====================================================
    910  05e4							; Get a line of text from the user, convert to a
    911  05e4							; character value , leave on top of stack. up to 2 characters
    912  05e4							;
    913  05e4				   iINSTR
    914  05e4		       20 3e 14 	      jsr	pushLN
    915  05e7		       b0 d5		      bcs	iReadErr	; Stack overflow error
    916  05e9		       a9 3f		      lda	#'?
    917  05eb		       a2 00		      ldx	#0	;wait for read complete
    918  05ed		       20 41 13 	      jsr	GetLine
    919  05f0		       b1 4f		      lda	(CURPTR),y
    920  05f2		       85 52		      sta	R0
    921  05f4		       a9 00		      lda	#0
    922  05f6		       85 53		      sta	R0+1
    923  05f8		       20 24 14 	      jsr	pushR0	;put onto stack
    924  05fb				   ExitIn
    925  05fb		       20 63 14 	      jsr	popLN
    926  05fe		       4c bb 02 	      jmp	NextIL
    927  0601							;
    928  0601							;
    929  0601							;=====================================================
    930  0601							; Stop the currently running program.	Actually very
    931  0601							; simple to do... clear the RunMode flag, then set the
    932  0601							; ILPC to the standard handler and continue running.
    933  0601							;
    934  0601		       a9 00	   iFIN       lda	#0
    935  0603		       85 5b		      sta	RunMode
    936  0605		       20 60 0e 	      jsr	taskReset
    937  0608							;
    938  0608		       ad ee 26 	      lda	errGoto
    939  060b		       85 43		      sta	ILPC
    940  060d		       ad ef 26 	      lda	errGoto+1
    941  0610		       85 44		      sta	ILPC+1
    942  0612		       4c bb 02 	      jmp	NextIL
    943  0615							;
    944  0615							;=====================================================
    945  0615							; Handle the ERR opcode.  Following the instruction is
    946  0615							; a 16 bit error number.  Print an error message, and
    947  0615							; if we're in run mode, print the line number.  Stop
    948  0615							; program execution and return to the initial state.
    949  0615							;
    950  0615		       20 bb 11    iERR       jsr	getILWord	;get err code
    951  0618							;
    952  0618							; Enter here with the error code in X (LSB) and A (MSB).
    953  0618							;
    954  0618		       86 52	   iErr2      stx	R0
    955  061a		       85 53		      sta	R0+1
    956  061c							;
    957  061c		       20 b0 16 	      jsr	puts
      0  061f					      db	CR,LF,"Error ",0
      1  061f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    959  0628		       20 6a 12 	      jsr	PrintDecimal
    960  062b							;
    961  062b		       a5 5b		      lda	RunMode	;running?
    962  062d		       f0 3b		      beq	iERR3	;nope
    963  062f		       20 b0 16 	      jsr	puts
      0  0632					      db	" at line ",0
      1  0632		       20 61 74 20*	      .byte.b	" at line ",0
    965  063c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    966  063e				   iErr2a
    967  063e		       b1 4f		      lda	(CURPTR),y
    968  0640		       85 52		      sta	R0
    969  0642		       c8		      iny
    970  0643		       b1 4f		      lda	(CURPTR),y
    971  0645		       85 53		      sta	R0+1
    972  0647		       20 6a 12 	      jsr	PrintDecimal
    973  064a		       20 b0 16 	      jsr	puts
      0  064d					      db	":",0
      1  064d		       3a 00		      .byte.b	":",0
    975  064f		       a9 00		      lda	#0
    976  0651		       85 53		      sta	R0+1
    977  0653		       a5 51		      lda	CUROFF
    978  0655		       18		      clc
    979  0656		       e9 03		      sbc	#3
    980  0658		       85 52		      sta	R0
    981  065a		       20 6a 12 	      jsr	PrintDecimal
    982  065d		       20 b0 16 	      jsr	puts
      0  0660					      db	":",0
      1  0660		       3a 00		      .byte.b	":",0
    984  0662		       ad a8 1d 	      lda	taskPtr
    985  0665		       85 52		      sta	R0
    986  0667		       20 6a 12 	      jsr	PrintDecimal
    987  066a							;
    988  066a		       20 61 15    iERR3      jsr	CRLF
    989  066d		       20 58 0e 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    990  0670		       a9 00		      lda	#0
    991  0672		       85 5b		      sta	RunMode	;fall through...
    992  0674							;
    993  0674							;=====================================================
    994  0674							; Reset the IL to be back at the idle loop.  Does not
    995  0674							; clear variables so the user can see what state
    996  0674							; the program is in.
    997  0674							;
    998  0674		       a9 00	   ResetIL    lda	#0
    999  0676		       85 47		      sta	ILSTACKPTR
   1000  0678		       ad ee 26 	      lda	errGoto
   1001  067b		       85 43		      sta	ILPC
   1002  067d		       ad ef 26 	      lda	errGoto+1
   1003  0680		       85 44		      sta	ILPC+1
   1004  0682		       4c bb 02 	      jmp	NextIL
   1005  0685
   1006  0685							;
   1007  0685							;=====================================================
   1008  0685							; Pop two items off stack, add them, then place the
   1009  0685							; result back onto the stack.
   1010  0685							;
   1011  0685		       20 a8 14    iADD       jsr	popR0
   1012  0688		       20 c0 14 	      jsr	popR1
   1013  068b				   iADDfast
   1014  068b		       18		      clc
   1015  068c		       a5 52		      lda	R0
   1016  068e		       65 54		      adc	R1
   1017  0690		       85 52		      sta	R0
   1018  0692		       a5 53		      lda	R0+1
   1019  0694		       65 55		      adc	R1+1
   1020  0696		       85 53		      sta	R0+1
   1021  0698		       4c 03 07 	      jmp	pushR0nextIl
   1022  069b							;
   1023  069b							;=====================================================
   1024  069b							; Pop two items off the stack.  Subtract the top of
   1025  069b							; stack from the lower entry.
   1026  069b							;
   1027  069b		       20 c0 14    iSUB       jsr	popR1
   1028  069e		       20 a8 14 	      jsr	popR0
   1029  06a1		       38		      sec
   1030  06a2		       a5 52		      lda	R0
   1031  06a4		       e5 54		      sbc	R1
   1032  06a6		       85 52		      sta	R0
   1033  06a8		       a5 53		      lda	R0+1
   1034  06aa		       e5 55		      sbc	R1+1
   1035  06ac		       85 53		      sta	R0+1
   1036  06ae		       4c 03 07 	      jmp	pushR0nextIl
   1037  06b1							;
   1038  06b1							;=====================================================
   1039  06b1							; Negate the top of stack.
   1040  06b1							;
   1041  06b1		       20 a8 14    iNEG       jsr	popR0
   1042  06b4		       a5 52		      lda	R0
   1043  06b6		       49 ff		      eor	#$ff
   1044  06b8		       85 52		      sta	R0
   1045  06ba		       a5 53		      lda	R0+1
   1046  06bc		       49 ff		      eor	#$ff
   1047  06be		       85 53		      sta	R0+1
   1048  06c0		       e6 52		      inc	R0
   1049  06c2		       d0 02		      bne	iNEG2
   1050  06c4		       e6 53		      inc	R0+1
   1051  06c6		       4c 03 07    iNEG2      jmp	pushR0nextIl
   1052  06c9							;
   1053  06c9							;=====================================================
   1054  06c9							; Multiply top two items on the stack, put the results
   1055  06c9							; on top.  This uses the algorithm documented on page
   1056  06c9							; 115 of "Microprocessor Programming for Computer
   1057  06c9							; Hobbyists" by Neill Graham.
   1058  06c9							;
   1059  06c9		       20 cf 06    iMUL       jsr	iMultiply
   1060  06cc		       4c bb 02 	      jmp	NextIL
   1061  06cf
   1062  06cf				   iMultiply
   1063  06cf		       20 a8 14 	      jsr	popR0	;AC
   1064  06d2		       20 c0 14 	      jsr	popR1	;OP
   1065  06d5							;
   1066  06d5		       a5 52		      lda	R0
   1067  06d7		       85 56		      sta	MQ
   1068  06d9		       a5 53		      lda	R0+1
   1069  06db		       85 57		      sta	MQ+1
   1070  06dd		       a9 00		      lda	#0	;clear result
   1071  06df		       85 52		      sta	R0
   1072  06e1		       85 53		      sta	R0+1
   1073  06e3							;
   1074  06e3		       a2 10		      ldx	#16	;number of bits in value
   1075  06e5		       06 52	   multloop   asl	R0
   1076  06e7		       26 53		      rol	R0+1
   1077  06e9		       06 56		      asl	MQ
   1078  06eb		       26 57		      rol	MQ+1
   1079  06ed		       90 0d		      bcc	multno	;skip add if no carry
   1080  06ef							;
   1081  06ef							; Add R1 back into R0
   1082  06ef							;
   1083  06ef		       18		      clc
   1084  06f0		       a5 52		      lda	R0
   1085  06f2		       65 54		      adc	R1
   1086  06f4		       85 52		      sta	R0
   1087  06f6		       a5 53		      lda	R0+1
   1088  06f8		       65 55		      adc	R1+1
   1089  06fa		       85 53		      sta	R0+1
   1090  06fc							;
   1091  06fc		       ca	   multno     dex		;did all bits yet?
   1092  06fd		       d0 e6		      bne	multloop
   1093  06ff		       20 24 14 	      jsr	pushR0	;OP
   1094  0702		       60		      rts
   1095  0703							;
   1096  0703				   pushR0nextIl
   1097  0703		       20 24 14 	      jsr	pushR0	;OP
   1098  0706		       4c bb 02 	      jmp	NextIL
   1099  0709							;
   1100  0709							;=====================================================
   1101  0709							; Divide the top of stack into the next to top item.
   1102  0709							; Leave results on stack.  Taken from:
   1103  0709							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1104  0709							;
   1105  0709							; R0 = R0 / R1
   1106  0709							; Remainder is in MQ
   1107  0709							;
   1108  0709		       20 23 07    iDIV       jsr	iDoDiv
   1109  070c		       20 29 15 	      jsr	RestoreSigns
   1110  070f		       4c 03 07 	      jmp	pushR0nextIl
   1111  0712
   1112  0712		       20 23 07    iMOD       jsr	iDoDiv
   1113  0715		       20 29 15 	      jsr	RestoreSigns
   1114  0718		       a5 56		      lda	MQ
   1115  071a		       85 52		      sta	R0
   1116  071c		       a5 57		      lda	MQ+1
   1117  071e		       85 53		      sta	R0+1
   1118  0720		       4c 03 07 	      jmp	pushR0nextIl
   1119  0723
   1120  0723				   iDoDiv
   1121  0723		       20 c0 14 	      jsr	popR1
   1122  0726		       20 a8 14 	      jsr	popR0
   1123  0729							;
   1124  0729							; Check for divide by zero
   1125  0729							;
   1126  0729
   1127  0729				   iDivNoPop
   1128  0729		       a5 54		      lda	R1
   1129  072b		       05 55		      ora	R1+1
   1130  072d		       f0 29		      beq	divby0
   1131  072f							;
   1132  072f		       20 ee 14 	      jsr	SaveSigns
   1133  0732		       a9 00		      lda	#0	;preset remainder to 0
   1134  0734		       85 56		      sta	MQ
   1135  0736		       85 57		      sta	MQ+1
   1136  0738		       a2 10		      ldx	#16	;repeat for each bit: ...
   1137  073a				   divloop
   1138  073a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1139  073c		       26 53		      rol	R0+1
   1140  073e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1141  0740		       26 57		      rol	MQ+1
   1142  0742		       a5 56		      lda	MQ
   1143  0744		       38		      sec
   1144  0745		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1145  0747		       a8		      tay		;lb result -> Y, for we may need it later
   1146  0748		       a5 57		      lda	MQ+1
   1147  074a		       e5 55		      sbc	R1+1
   1148  074c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1149  074e
   1150  074e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1151  0750		       84 56		      sty	MQ
   1152  0752		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1153  0754
   1154  0754		       ca	   skip       dex
   1155  0755		       d0 e3		      bne	divloop
   1156  0757		       60		      rts
   1157  0758							;
   1158  0758							; Indicate divide-by-zero error
   1159  0758							;
   1160  0758		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1161  075a		       a9 00		      lda	#0
   1162  075c		       4c 18 06 	      jmp	iErr2
   1163  075f							;
   1164  075f							;=====================================================
   1165  075f							; This pops the top two items off the stack.  The top
   1166  075f							; item is a data value and the other is an ABSOLUTE address.
   1167  075f							;Save the value into that address.
   1168  075f							;
   1169  075f		       98	   iSTORE     tya
   1170  0760		       48		      pha
   1171  0761		       20 a8 14 	      jsr	popR0	;data
   1172  0764		       20 c0 14 	      jsr	popR1	;Storage location
   1173  0767		       a0 00		      ldy	#0
   1174  0769		       a5 52		      lda	R0
   1175  076b		       91 54		      sta	(R1),y
   1176  076d		       a5 53		      lda	R0+1
   1177  076f		       c8		      iny
   1178  0770		       91 54		      sta	(R1),y
   1179  0772		       68		      pla
   1180  0773		       a8		      tay
   1181  0774		       4c bb 02 	      jmp	NextIL
   1182  0777							;
   1183  0777							;=====================================================
   1184  0777							; Replaces the top of stack with the variable whose
   1185  0777							; absolute address it represents.
   1186  0777							;
   1187  0777		       98	   iIND       tya
   1188  0778		       48		      pha
   1189  0779		       20 c0 14 	      jsr	popR1
   1190  077c		       a0 00		      ldy	#0
   1191  077e		       b1 54		      lda	(R1),y
   1192  0780		       85 52		      sta	R0
   1193  0782		       c8		      iny
   1194  0783		       b1 54		      lda	(R1),y
   1195  0785		       85 53		      sta	R0+1
   1196  0787		       68		      pla
   1197  0788		       a8		      tay
   1198  0789		       4c 03 07 	      jmp	pushR0nextIl
   1199  078c							;
   1200  078c							;=====================================================
   1201  078c							; Get the array index from top of stack get Current variable
   1202  078c							; address from next on stack, add the offset
   1203  078c							; push the result back onto the stack
   1204  078c				   iArray
   1205  078c		       20 a8 14 	      jsr	popR0	; Get the array index
   1206  078f		       20 c0 14 	      jsr	popR1	; Get the Variable address
   1207  0792
   1208  0792		       18		      clc		; Multiplythe value by 2
   1209  0793		       26 52		      rol	R0	; Do the multiply
   1210  0795		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1211  0797		       18		      clc
   1212  0798		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1213  079a		       65 52		      adc	R0
   1214  079c		       85 52		      sta	R0
   1215  079e		       a5 55		      lda	R1+1
   1216  07a0		       65 53		      adc	R0+1
   1217  07a2		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1218  07a4		       20 24 14 	      jsr	pushR0	; Push R0 assume it is correct
   1219  07a7
   1220  07a7		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1221  07a9		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1222  07ab		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1223  07ad		       a5 55		      lda	R1+1
   1224  07af		       c5 42		      cmp	VARIABLES+1
   1225  07b1		       d0 1c		      bne	iArrayAtTest
   1226  07b3		       18		      clc
   1227  07b4		       a9 34		      lda	#52	; add the max offset that is valid
   1228  07b6		       65 54		      adc	R1	; update to be the largest offset that is valid
   1229  07b8		       85 54		      sta	R1
   1230  07ba		       a9 00		      lda	#0
   1231  07bc		       65 55		      adc	R1+1
   1232  07be		       85 55		      sta	R1+1
   1233  07c0				   iArrayVerify 		; try to enforce some sanity to using arrays
   1234  07c0		       a5 53		      lda	R0+1
   1235  07c2		       c5 55		      cmp	R1+1
   1236  07c4		       d0 04		      bne	iArrayDecide
   1237  07c6		       a5 52		      lda	R0
   1238  07c8		       c5 54		      cmp	R1
   1239  07ca				   iArrayDecide
   1240  07ca		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1241  07cc		       4c bb 02 	      jmp	NextIL
   1242  07cf
   1243  07cf				   iArrayAtTest
   1244  07cf		       ad 05 27 	      lda	HighMem
   1245  07d2		       85 54		      sta	R1
   1246  07d4		       ad 06 27 	      lda	HighMem+1
   1247  07d7		       85 55		      sta	R1+1
   1248  07d9		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1249  07db
   1250  07db							; Get here if array index is out of range
   1251  07db		       20 a8 14    iArrayError jsr	popR0
   1252  07de		       a9 00		      lda	#0
   1253  07e0		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1254  07e2		       4c 18 06 	      jmp	iErr2
   1255  07e5							;
   1256  07e5							;=====================================================
   1257  07e5							; List the current BASIC program in memory.  Uses R0,
   1258  07e5							; tempIly, and dpl.
   1259  07e5							;
   1260  07e5		       20 90 16    iLST       jsr	SetOutConsole
   1261  07e8		       ad 01 27    iLST2      lda	ProgramStart
   1262  07eb		       85 59		      sta	dpl
   1263  07ed		       ad 02 27 	      lda	ProgramStart+1
   1264  07f0		       85 5a		      sta	dpl+1
   1265  07f2							;
   1266  07f2							; dpl/dph point to the current line.  See if we're at
   1267  07f2							; the end of the program.
   1268  07f2							;
   1269  07f2		       a5 59	   iLSTloop   lda	dpl
   1270  07f4		       cd 03 27 	      cmp	ProgramEnd
   1271  07f7		       d0 07		      bne	iLstNotEnd
   1272  07f9		       a5 5a		      lda	dpl+1
   1273  07fb		       cd 04 27 	      cmp	ProgramEnd+1
   1274  07fe		       f0 44		      beq	iLstdone
   1275  0800							;
   1276  0800		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1277  0802		       b1 59		      lda	(dpl),y	;line number LSB
   1278  0804		       85 52		      sta	R0
   1279  0806		       c8		      iny
   1280  0807		       b1 59		      lda	(dpl),y	;line number MSB
   1281  0809		       85 53		      sta	R0+1
   1282  080b		       c8		      iny
   1283  080c		       8c fc 26 	      sty	tempIlY
   1284  080f		       20 6a 12 	      jsr	PrintDecimal
   1285  0812		       a9 20		      lda	#SPACE
   1286  0814		       20 aa 16 	      jsr	VOUTCH
   1287  0817		       ac fc 26 	      ldy	tempIlY
   1288  081a		       b1 59	   iLSTl2     lda	(dpl),y
   1289  081c		       f0 0c		      beq	iLST3	;end of this line 0 value
   1290  081e		       8c fc 26 	      sty	tempIlY
   1291  0821		       20 aa 16 	      jsr	VOUTCH
   1292  0824		       ac fc 26 	      ldy	tempIlY
   1293  0827		       c8		      iny
   1294  0828		       d0 f0		      bne	iLSTl2	;do next char
   1295  082a							;
   1296  082a							; End of this line.  Print CR/LF, then move to the
   1297  082a							; next line.
   1298  082a							;
   1299  082a		       c8	   iLST3      iny		;Move to next line
   1300  082b		       18		      clc		;Clear the carry flag
   1301  082c		       98		      tya		;Current Offset
   1302  082d		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  082f		       85 59		      sta	dpl	;Save the new value
   1304  0831		       a5 5a		      lda	dpl+1	;Next byte
   1305  0833		       69 00		      adc	#0	;ad in the carry if any
   1306  0835		       85 5a		      sta	dpl+1	;Save it
   1307  0837							;
   1308  0837							; Have to manually do CR/LF so it uses the vectored
   1309  0837							; output function.
   1310  0837							;
   1311  0837		       a9 0d		      lda	#CR
   1312  0839		       20 aa 16 	      jsr	VOUTCH
   1313  083c		       a9 0a		      lda	#LF
   1314  083e		       20 aa 16 	      jsr	VOUTCH
   1315  0841		       4c f2 07 	      jmp	iLSTloop	;do next line
   1316  0844							;
   1317  0844		       20 90 16    iLstdone   jsr	SetOutConsole
   1318  0847		       4c bb 02 	      jmp	NextIL
   1319  084a							;
   1320  084a							;=====================================================
   1321  084a							; Get a line of text into LINBUF.  Terminate with a
   1322  084a							; null byte.
   1323  084a							;
   1324  084a				   iGETLINE
   1325  084a		       a9 3e		      lda	#'>	;prompt character
   1326  084c		       a6 00		      ldx	0	;Wait for read to complete
   1327  084e		       20 41 13 	      jsr	GetLine
   1328  0851							;
   1329  0851		       a9 00		      lda	#0
   1330  0853		       85 5b		      sta	RunMode
   1331  0855		       4c bb 02 	      jmp	NextIL
   1332  0858							;
   1333  0858							;=====================================================
   1334  0858							; This is called when the input buffer contains a line
   1335  0858							; typed in by the user that starts with a line number.
   1336  0858							; Insert the line into the program or delete the line
   1337  0858							; if there is nothing after the line number,
   1338  0858							;
   1339  0858		       a0 00	   iINSRT     ldy	#0
   1340  085a		       20 d6 12 	      jsr	getDecimal	;convert line #
   1341  085d		       20 58 15 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1342  0860		       8c fd 26 	      sty	offset	;Save the start of the program line text
   1343  0863							;
   1344  0863							; Now find the line OR the next higher line OR the
   1345  0863							; end of the program.
   1346  0863							;
   1347  0863		       20 04 12 	      jsr	findLine	; Look for the line number in the current program
   1348  0866							; Returns Z and curptr point to the line if found
   1349  0866							; Returns C and curptr at next higher line if not found and there is a higher line
   1350  0866							; Returns ZC clear and curptr to end of program if higher than all other lines
   1351  0866							;
   1352  0866							; If the line exists, it needs to be removed.
   1353  0866							;
   1354  0866		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1355  0868							;
   1356  0868							; Get length of line to be removed, we fall thru to here if we find a matching line
   1357  0868							;
   1358  0868							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1359  0868		       a0 00		      ldy	#0
   1360  086a		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1361  086c		       a8		      tay
   1362  086d							;If it is equal we delete the line and replace it, get length
   1363  086d							;then adjust all program line after up or down depending on len of line
   1364  086d							;If next higher then just move everythimg down by length bytes
   1365  086d							;This call will return how many bytes in the line we found
   1366  086d		       8c fe 26 	      sty	lineLength	;Save the length of the line we found
   1367  0870							;
   1368  0870							; Compute the new end of the program first.
   1369  0870							;
   1370  0870		       38		      sec		;Set the carry bit
   1371  0871		       ad 03 27 	      lda	ProgramEnd	;Get low byte of program end
   1372  0874		       ed fe 26 	      sbc	lineLength	;Subtract the length of the current line
   1373  0877		       8d 03 27 	      sta	ProgramEnd	;save it
   1374  087a		       ad 04 27 	      lda	ProgramEnd+1
   1375  087d		       e9 00		      sbc	#0	;Process the carry
   1376  087f		       8d 04 27 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1377  0882							;
   1378  0882							; Copy CURPTR into R1 for working
   1379  0882							;
   1380  0882		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1381  0884		       85 54		      sta	R1
   1382  0886		       a5 50		      lda	CURPTR+1
   1383  0888		       85 55		      sta	R1+1
   1384  088a							;
   1385  088a							; See if we're at the end.
   1386  088a							;
   1387  088a		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1388  088c		       cd 03 27 	      cmp	ProgramEnd
   1389  088f		       d0 07		      bne	InsDelLoop
   1390  0891		       a5 55		      lda	R1+1
   1391  0893		       cd 04 27 	      cmp	ProgramEnd+1
   1392  0896		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1393  0898							;
   1394  0898							; Move one byte, move to next location.
   1395  0898							;
   1396  0898		       ac fe 26    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1397  089b		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1398  089d		       b1 54		      lda	(R1),y
   1399  089f		       a0 00		      ldy	#0
   1400  08a1		       91 54		      sta	(R1),y
   1401  08a3		       e6 54		      inc	R1
   1402  08a5		       d0 e3		      bne	InsDelChk
   1403  08a7		       e6 55		      inc	R1+1
   1404  08a9		       4c 8a 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1405  08ac							;
   1406  08ac							; Deletion is done.
   1407  08ac							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1408  08ac							;
   1409  08ac		       ac fd 26    insert2    ldy	offset	; get back ptr  Get the current offset
   1410  08af		       b9 64 26 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1411  08b2		       f0 5f		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1412  08b4							;
   1413  08b4							; CURPTR points to where the line will be inserted.
   1414  08b4							;
   1415  08b4		       20 fb 13 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1416  08b7							;
   1417  08b7		       ad 03 27 	      lda	ProgramEnd	;Load the start address for the copy
   1418  08ba							;At this point curptr still contains the location we will insert data
   1419  08ba		       85 5c		      sta	FROM
   1420  08bc		       ad 04 27 	      lda	ProgramEnd+1
   1421  08bf		       85 5d		      sta	FROM+1
   1422  08c1							;
   1423  08c1		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1424  08c3		       b1 5c		      lda	(FROM),y
   1425  08c5		       ac fe 26 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1426  08c8		       91 5c		      sta	(FROM),y	;Save the new byte
   1427  08ca							;
   1428  08ca		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1429  08cc		       c5 4f		      cmp	CURPTR
   1430  08ce		       d0 06		      bne	mvUpMore
   1431  08d0		       a5 5d		      lda	FROM+1
   1432  08d2		       c5 50		      cmp	CURPTR+1
   1433  08d4		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1434  08d6							;
   1435  08d6							; Not done yet
   1436  08d6							;
   1437  08d6		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1438  08d8		       d0 02		      bne	mvUpMore2
   1439  08da		       c6 5d		      dec	FROM+1
   1440  08dc		       c6 5c	   mvUpMore2  dec	FROM
   1441  08de		       4c c1 08 	      jmp	mvup1	;Loop until everything is moved
   1442  08e1							;
   1443  08e1							; All done with copy.
   1444  08e1							;
   1445  08e1				   mvUpDone
   1446  08e1		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1447  08e2		       ad fe 26 	      lda	lineLength	;Number of bytes to copy from line buff
   1448  08e5		       6d 03 27 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1449  08e8		       8d 03 27 	      sta	ProgramEnd
   1450  08eb		       ad 04 27 	      lda	ProgramEnd+1
   1451  08ee		       69 00		      adc	#0
   1452  08f0		       8d 04 27 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1453  08f3							;
   1454  08f3							;===================jlit use length before line newline
   1455  08f3
   1456  08f3		       a0 00		      ldy	#0	;Set offset of copy
   1457  08f5		       ad fe 26 	      lda	lineLength	;We will insert the actual length of the line first
   1458  08f8		       91 4f		      sta	(CURPTR),y	;Store the length
   1459  08fa		       c8		      iny
   1460  08fb		       a5 52		      lda	R0	;Store the line number next
   1461  08fd		       91 4f		      sta	(CURPTR),y
   1462  08ff		       c8		      iny
   1463  0900		       a5 53		      lda	R0+1
   1464  0902		       91 4f		      sta	(CURPTR),y
   1465  0904		       c8		      iny
   1466  0905							;
   1467  0905		       ae fd 26 	      ldx	offset	;Load the offset into line buffer in page zero
   1468  0908		       bd 64 26    mvUpLoop2  lda	LINBUF,x	;get a byte
   1469  090b		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1470  090d		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1471  090f		       e8		      inx
   1472  0910		       c8		      iny
   1473  0911		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1474  0913							;
   1475  0913		       4c bb 02    mvUpFini   jmp	NextIL
   1476  0916							;
   1477  0916							;=====================================================
   1478  0916							; Pops the top value of the ILPC stack and stores it
   1479  0916							; in ILPC.  Ie, return from an IL subroutine.
   1480  0916							;
   1481  0916		       20 f2 11    iRTN       jsr	popILPC
   1482  0919		       4c bb 02 	      jmp	NextIL
   1483  091c							;
   1484  091c							;=====================================================
   1485  091c							; NLINE print a newline
   1486  091c							;
   1487  091c		       20 61 15    iNLINE     jsr	CRLF	;user supplied sub
   1488  091f		       4c bb 02 	      jmp	NextIL
   1489  0922							;
   1490  0922							;=====================================================
   1491  0922							; This saves the current ILPC value on the stack, then
   1492  0922							; jumps to the address specified by the next two bytes.
   1493  0922							;
   1494  0922		       20 d5 11    iCALL      jsr	pushILPC	;save ILPC
   1495  0925		       90 03		      bcc	iJMP
   1496  0927		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   1497  092a							;
   1498  092a							; Jmp to a specific location in the IL code.  The new
   1499  092a							; address immediately follows the opcode.
   1500  092a							;
   1501  092a		       20 bb 11    iJMP       jsr	getILWord
   1502  092d		       86 43		      stx	ILPC
   1503  092f		       85 44		      sta	ILPC+1
   1504  0931		       4c bb 02 	      jmp	NextIL
   1505  0934
   1506  0934
   1507  0934							;
   1508  0934							;=====================================================
   1509  0934							; Push the next two bytes onto the arithmetic stack.
   1510  0934							;
   1511  0934		       20 bf 11    iSetR2     jsr	getILByte
   1512  0937		       86 58		      stx	R2
   1513  0939		       4c bb 02 	      jmp	NextIL
   1514  093c							;
   1515  093c							;=====================================================
   1516  093c							; Push the next two bytes onto the arithmetic stack.
   1517  093c							;
   1518  093c		       20 bb 11    iLIT       jsr	getILWord
   1519  093f		       86 52		      stx	R0
   1520  0941		       85 53		      sta	R0+1
   1521  0943		       20 24 14 	      jsr	pushR0
   1522  0946		       4c bb 02 	      jmp	NextIL
   1523  0949							;
   1524  0949							;=====================================================
   1525  0949							; Initialize all variables for a single task.	Ie, set to zero.
   1526  0949							;
   1527  0949		       98	   subVINIT   tya
   1528  094a		       48		      pha
   1529  094b
   1530  094b		       a9 00		      lda	#0
   1531  094d		       a0 00		      ldy	#0
   1532  094f		       91 41	   Vinit2     sta	(VARIABLES),y
   1533  0951		       c8		      iny
   1534  0952		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1535  0954		       90 f9		      bcc	Vinit2
   1536  0956
   1537  0956		       68		      pla
   1538  0957		       a8		      tay
   1539  0958		       60		      rts
   1540  0959
   1541  0959		       20 49 09    iVINIT     jsr	subVINIT
   1542  095c		       4c bb 02 	      jmp	NextIL
   1543  095f							;
   1544  095f							;=====================================================
   1545  095f							; Set the address of the error handler.  After any
   1546  095f							; error, set to the ILPC to the specified location.
   1547  095f							;
   1548  095f		       20 bb 11    iERRGOTO   jsr	getILWord
   1549  0962		       8e ee 26 	      stx	errGoto
   1550  0965		       8d ef 26 	      sta	errGoto+1
   1551  0968		       4c bb 02 	      jmp	NextIL
   1552  096b							;
   1553  096b							;=====================================================
   1554  096b							; TST is followed by an 8 bit signed offset, then a
   1555  096b							; null terminated string.  Compare the string against
   1556  096b							; the string starting at (CURPTR),CUROFF.  If the
   1557  096b							; strings match, continue executing the next IL
   1558  096b							; opcode.  Else, add the offset to ILPC.
   1559  096b							;
   1560  096b		       20 bf 11    iTST       jsr	getILByte	;Get the relative jump address
   1561  096e		       8d fd 26 	      sta	offset	;save it to use if test faile
   1562  0971		       20 0e 14 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1563  0974
   1564  0974		       a4 51		      ldy	CUROFF
   1565  0976		       84 59		      sty	dpl	;save for later
   1566  0978							;
   1567  0978		       20 bf 11    iTSTloop   jsr	getILByte	;get next char
   1568  097b		       f0 11		      beq	iTSTm	;match!
   1569  097d		       a4 59		      ldy	dpl
   1570  097f		       d1 4f		      cmp	(CURPTR),y
   1571  0981		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1572  0983		       09 20		      ora	#$20	; lets allow lowercase as well
   1573  0985		       d1 4f		      cmp	(CURPTR),y
   1574  0987		       d0 23		      bne	iTSTfail	;mismatch
   1575  0989		       c8	   iTSTUpper  iny
   1576  098a		       84 59		      sty	dpl
   1577  098c		       d0 ea		      bne	iTSTloop
   1578  098e							;
   1579  098e							; It's a match!  Clean up a bit.
   1580  098e							;
   1581  098e		       a4 59	   iTSTm      ldy	dpl
   1582  0990		       84 51		      sty	CUROFF
   1583  0992		       4c bb 02 	      jmp	NextIL
   1584  0995
   1585  0995							; Test for a single quote string
   1586  0995		       20 bf 11    iTSTStr    jsr	getILByte
   1587  0998		       8d fd 26 	      sta	offset
   1588  099b		       20 0e 14 	      jsr	saveIL
   1589  099e		       a4 51		      ldy	CUROFF
   1590  09a0		       a9 22		      lda	#'"
   1591  09a2		       d1 4f		      cmp	(CURPTR),y
   1592  09a4		       d0 06		      bne	iTSTfail
   1593  09a6		       c8		      iny
   1594  09a7		       84 51		      sty	CUROFF
   1595  09a9		       4c de 02 	      jmp	NextILStr
   1596  09ac							;
   1597  09ac							; Not a match, reset ILPC and then move to the
   1598  09ac							; offset.
   1599  09ac							;
   1600  09ac		       20 19 14    iTSTfail   jsr	restoreIL
   1601  09af		       4c 0c 0b 	      jmp	tstBranch
   1602  09b2							;
   1603  09b2							;=================================================JLIT=
   1604  09b2							; Test if we have a let statement without the let keyword
   1605  09b2		       20 bf 11    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1606  09b5		       8d fd 26 	      sta	offset	; Save the jump offset for fails
   1607  09b8		       20 0e 14 	      jsr	saveIL	; save to restore when done if fail
   1608  09bb
   1609  09bb		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1610  09bd		       20 58 15 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1611  09c0		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1612  09c1		       20 58 15 	      jsr	SkipSpaces	; skip any SkipSpaces
   1613  09c4		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1614  09c6		       c9 3d		      cmp	#'=	; check if equals
   1615  09c8		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1616  09ca		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1617  09cc		       d0 de		      bne	iTSTfail	; return it failed
   1618  09ce
   1619  09ce				   iTSTLETGOOD
   1620  09ce		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1621  09d1
   1622  09d1							;=================================================JLIT=
   1623  09d1							;
   1624  09d1		       20 bf 11    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1625  09d4		       8d fd 26 	      sta	offset	; Save the jump offset for fails
   1626  09d7		       20 0e 14 	      jsr	saveIL	; save to restore when done if fail
   1627  09da		       20 bb 11 	      jsr	getILWord	; Get a word into RO
   1628  09dd		       86 52		      stx	R0
   1629  09df		       85 53		      sta	R0+1
   1630  09e1		       20 bf 11 	      jsr	getILByte	; Get byte into A
   1631  09e4		       a0 00		      ldy	#0
   1632  09e6		       d1 52		      cmp	(R0),y
   1633  09e8		       d0 03		      bne	iTSTByteNotEqual
   1634  09ea		       4c ac 09 	      jmp	iTSTfail
   1635  09ed
   1636  09ed				   iTSTByteNotEqual
   1637  09ed		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1638  09f0
   1639  09f0
   1640  09f0							;================================================jLIT=
   1641  09f0							;Test for end of line
   1642  09f0							;
   1643  09f0		       20 bf 11    iTSTDONE   jsr	getILByte
   1644  09f3		       8d fd 26 	      sta	offset
   1645  09f6		       20 0e 14 	      jsr	saveIL
   1646  09f9		       a4 51		      ldy	CUROFF
   1647  09fb		       84 59		      sty	dpl
   1648  09fd		       20 58 15 	      jsr	SkipSpaces
   1649  0a00		       b1 4f		      lda	(CURPTR),y
   1650  0a02		       f0 0b		      beq	iTSTDONEtrue
   1651  0a04		       c9 3a		      cmp	#COLON
   1652  0a06		       f0 07		      beq	iTSTDONEtrue
   1653  0a08		       a4 59		      ldy	dpl
   1654  0a0a		       84 51		      sty	CUROFF
   1655  0a0c		       4c ac 09 	      jmp	iTSTfail
   1656  0a0f							;
   1657  0a0f							; Advance to the next line
   1658  0a0f							;
   1659  0a0f				   iTSTDONEtrue
   1660  0a0f		       4c bb 02 	      jmp	NextIL
   1661  0a12
   1662  0a12		       4c 0c 0b    tstBranchLink jmp	tstBranch
   1663  0a15							;
   1664  0a15							;=====================================================
   1665  0a15							; Inc and dec a variable , faster than a = a + 1
   1666  0a15				   iINCVAR
   1667  0a15		       20 a8 14 	      jsr	popR0
   1668  0a18		       a0 00		      ldy	#0
   1669  0a1a		       18		      clc
   1670  0a1b		       a9 01		      lda	#1
   1671  0a1d		       71 52		      adc	(R0),y
   1672  0a1f		       91 52		      sta	(R0),y
   1673  0a21		       90 07		      bcc	iINCDONE
   1674  0a23		       c8		      iny
   1675  0a24		       a9 00		      lda	#0
   1676  0a26		       71 52		      adc	(R0),y
   1677  0a28		       91 52		      sta	(R0),y
   1678  0a2a				   iINCDONE
   1679  0a2a		       4c bb 02 	      jmp	NextIL
   1680  0a2d				   iDECVAR
   1681  0a2d		       20 a8 14 	      jsr	popR0
   1682  0a30		       a0 00		      ldy	#0
   1683  0a32		       38		      sec
   1684  0a33		       b1 52		      lda	(R0),y
   1685  0a35		       e9 01		      sbc	#1
   1686  0a37		       91 52		      sta	(R0),y
   1687  0a39		       c8		      iny
   1688  0a3a		       b1 52		      lda	(R0),y
   1689  0a3c		       69 00		      adc	#0
   1690  0a3e		       91 52		      sta	(R0),y
   1691  0a40		       4c bb 02 	      jmp	NextIL
   1692  0a43
   1693  0a43
   1694  0a43							;
   1695  0a43							;=====================================================
   1696  0a43							; TSTV is followed by an 8 bit signed offset.	If the
   1697  0a43							; value at (CURPTR),CUROFF appears to be a variable
   1698  0a43							; name, move to the next IL statement.  Else, add the
   1699  0a43							; offset to ILPC. Converted to use actual absolute memory addresses
   1700  0a43							; TSTVT Looks for the task context
   1701  0a43							;
   1702  0a43		       20 c0 14    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1703  0a46		       a9 00		      lda	#0
   1704  0a48		       85 58		      sta	R2
   1705  0a4a		       f0 04		      beq	iTSTVV
   1706  0a4c
   1707  0a4c		       a9 01	   iTSTV      lda	#1
   1708  0a4e		       85 58		      sta	R2
   1709  0a50
   1710  0a50		       20 bf 11    iTSTVV     jsr	getILByte	;offset
   1711  0a53		       8d fd 26 	      sta	offset
   1712  0a56							;
   1713  0a56		       a4 51		      ldy	CUROFF
   1714  0a58		       20 58 15 	      jsr	SkipSpaces
   1715  0a5b		       b1 4f		      lda	(CURPTR),y
   1716  0a5d		       d0 03		      bne	iTSTVnext
   1717  0a5f		       4c 12 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1718  0a62							;
   1719  0a62				   iTSTVnext
   1720  0a62		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1721  0a64		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1722  0a66
   1723  0a66		       c9 23		      cmp	#'#	; parameters passed to this task
   1724  0a68		       f0 53		      beq	iTSTVParm
   1725  0a6a
   1726  0a6a		       c9 5e		      cmp	#'^	; task exit code
   1727  0a6c		       d0 04		      bne	iTSTV_A2Z
   1728  0a6e		       a9 19		      lda	#TASKEXITCODE
   1729  0a70		       d0 10		      bne	iTSTVContinue
   1730  0a72
   1731  0a72				   iTSTV_A2Z
   1732  0a72		       09 20		      ora	#$20	;make lower then upper
   1733  0a74		       49 20		      eor	#$20	;allow lower case here
   1734  0a76		       c9 41		      cmp	#'A
   1735  0a78		       90 98		      bcc	tstBranchLink
   1736  0a7a		       c9 5b		      cmp	#'Z+1
   1737  0a7c		       b0 94		      bcs	tstBranchLink
   1738  0a7e
   1739  0a7e
   1740  0a7e							;
   1741  0a7e							; The condition is true, so convert to an index, push
   1742  0a7e							; it onto the stack and continue running.
   1743  0a7e							;
   1744  0a7e		       38		      sec
   1745  0a7f		       e9 41		      sbc	#'A	;index is zero based
   1746  0a81		       0a		      asl		;multiply by two
   1747  0a82
   1748  0a82				   iTSTVContinue
   1749  0a82		       c8		      iny
   1750  0a83		       84 51		      sty	CUROFF	;it is a valid variable
   1751  0a85		       48		      pha
   1752  0a86		       a5 58		      lda	R2
   1753  0a88		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1754  0a8a
   1755  0a8a		       20 a2 11 	      jsr	ipc_getcontext	; Get the other tasks variables
   1756  0a8d		       a0 01		      ldy	#VARIABLEPOS
   1757  0a8f		       b1 56		      lda	(MQ),y
   1758  0a91		       85 52		      sta	R0
   1759  0a93		       c8		      iny
   1760  0a94		       b1 56		      lda	(MQ),y
   1761  0a96		       85 53		      sta	R0+1
   1762  0a98		       4c a3 0a 	      jmp	iTSTVAddOffset
   1763  0a9b
   1764  0a9b				   iTSTVLocalValue
   1765  0a9b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1766  0a9d		       85 52		      sta	R0
   1767  0a9f		       a5 42		      lda	VARIABLES+1
   1768  0aa1		       85 53		      sta	R0+1
   1769  0aa3
   1770  0aa3				   iTSTVAddOffset
   1771  0aa3		       68		      pla
   1772  0aa4		       85 54		      sta	R1
   1773  0aa6		       a9 00		      lda	#0
   1774  0aa8		       85 55		      sta	R1+1
   1775  0aaa
   1776  0aaa				   iTSTVcontinue
   1777  0aaa
   1778  0aaa		       4c 8b 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1779  0aad
   1780  0aad							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1781  0aad							; an array of integer values
   1782  0aad				   iTSTVat
   1783  0aad		       c8		      iny
   1784  0aae		       84 51		      sty	CUROFF	;it is a valid variable
   1785  0ab0		       ad 03 27 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1786  0ab3		       85 52		      sta	R0
   1787  0ab5		       ad 04 27 	      lda	ProgramEnd+1
   1788  0ab8		       85 53		      sta	R0+1
   1789  0aba		       4c 03 07 	      jmp	pushR0nextIl	;place this onto the stack
   1790  0abd
   1791  0abd							; When we get parameters passed we can access them using the # variable with[]
   1792  0abd							; example #[0] #[1] etc, we dont check yet if there is too many
   1793  0abd				   iTSTVParm
   1794  0abd		       c8		      iny
   1795  0abe		       84 51		      sty	CUROFF	;it is a valid variable
   1796  0ac0		       a5 48		      lda	MATHSTACK
   1797  0ac2		       85 52		      sta	R0
   1798  0ac4		       a5 49		      lda	MATHSTACK+1
   1799  0ac6		       85 53		      sta	R0+1
   1800  0ac8		       4c 03 07 	      jmp	pushR0nextIl
   1801  0acb
   1802  0acb							;
   1803  0acb							;=====================================================
   1804  0acb							; TSTL seems basically the same as TSTN, but leave the
   1805  0acb							; value in R0 instead of pushing onto stack.
   1806  0acb							; This tests for a valid line number
   1807  0acb							;
   1808  0acb		       20 bf 11    iTSTL      jsr	getILByte
   1809  0ace		       8d fd 26 	      sta	offset
   1810  0ad1							;
   1811  0ad1		       a4 51		      ldy	CUROFF
   1812  0ad3		       20 58 15 	      jsr	SkipSpaces
   1813  0ad6		       b1 4f		      lda	(CURPTR),y
   1814  0ad8							;
   1815  0ad8		       c9 30		      cmp	#'0
   1816  0ada		       90 30		      bcc	tstBranch
   1817  0adc		       c9 3a		      cmp	#'9+1
   1818  0ade		       b0 2c		      bcs	tstBranch
   1819  0ae0							;
   1820  0ae0							; It's a digit, so convert to a number.
   1821  0ae0							;
   1822  0ae0		       20 d6 12 	      jsr	getDecimal
   1823  0ae3		       4c bb 02 	      jmp	NextIL
   1824  0ae6							;
   1825  0ae6							;=====================================================
   1826  0ae6							; TSTN checks for a number.  This is very simplistic;
   1827  0ae6							; if the character is a digit, assume it's a number.
   1828  0ae6							; Convert to a number and push it onto the stack.
   1829  0ae6							;
   1830  0ae6		       20 bf 11    iTSTN      jsr	getILByte
   1831  0ae9		       8d fd 26 	      sta	offset
   1832  0aec							;
   1833  0aec		       a4 51		      ldy	CUROFF
   1834  0aee		       20 58 15 	      jsr	SkipSpaces
   1835  0af1		       b1 4f		      lda	(CURPTR),y
   1836  0af3		       f0 17		      beq	tstBranch
   1837  0af5		       c9 2d		      cmp	#'-	;negative?
   1838  0af7		       f0 08		      beq	iTSTN_1
   1839  0af9		       c9 30		      cmp	#'0
   1840  0afb		       90 0f		      bcc	tstBranch
   1841  0afd		       c9 3a		      cmp	#'9+1
   1842  0aff		       b0 0b		      bcs	tstBranch
   1843  0b01							;
   1844  0b01							; It's a digit, so convert to a number.
   1845  0b01							;
   1846  0b01				   iTSTN_1
   1847  0b01		       20 d6 12 	      jsr	getDecimal
   1848  0b04		       84 51		      sty	CUROFF
   1849  0b06		       20 24 14 	      jsr	pushR0	;save onto stack
   1850  0b09		       4c bb 02 	      jmp	NextIL
   1851  0b0c
   1852  0b0c							;
   1853  0b0c							; Common jump point for all TSTx instructions that
   1854  0b0c							; fail to meet the requirements.  This takes the
   1855  0b0c							; offset and adds/subtracts to/from ILPC.
   1856  0b0c							;
   1857  0b0c		       ad fd 26    tstBranch  lda	offset	;get signed offset
   1858  0b0f		       10 0e		      bpl	tstPositive
   1859  0b11							;
   1860  0b11							; Do negative branch.	Do sign extension.
   1861  0b11							;
   1862  0b11		       18	   tstNegative clc
   1863  0b12		       65 43		      adc	ILPC
   1864  0b14		       85 43		      sta	ILPC
   1865  0b16							;		  bcc	  tstBothDone
   1866  0b16							;		  dec	  ILPC+1
   1867  0b16							;		  jmp	  NextIL
   1868  0b16
   1869  0b16		       a5 44		      lda	ILPC+1
   1870  0b18		       69 ff		      adc	#$ff
   1871  0b1a		       85 44		      sta	ILPC+1
   1872  0b1c		       4c bb 02 	      jmp	NextIL	;keep going
   1873  0b1f							;
   1874  0b1f		       18	   tstPositive clc
   1875  0b20		       65 43		      adc	ILPC
   1876  0b22		       85 43		      sta	ILPC
   1877  0b24		       90 02		      bcc	tstBothDone
   1878  0b26		       e6 44		      inc	ILPC+1
   1879  0b28				   tstBothDone
   1880  0b28		       4c bb 02 	      jmp	NextIL
   1881  0b2b
   1882  0b2b							;
   1883  0b2b							;====================================================
   1884  0b2b							; Test for IRQ pending, and test if a break key pressed
   1885  0b2b							; Yes I know but this handles all sorts of irq/break issues
   1886  0b2b							;
   1887  0b2b		       20 bf 11    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1888  0b2e		       8d fd 26 	      sta	offset	; Store the not true jump address offset
   1889  0b31		       20 36 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1890  0b34		       d0 03		      bne	irqNo	; z not set of no break found
   1891  0b36		       4c 01 06 	      jmp	iFIN	; Exit out of run mode
   1892  0b39		       ad a5 1d    irqNo      lda	IRQPending
   1893  0b3c		       f0 ce		      beq	tstBranch
   1894  0b3e		       c9 01		      cmp	#1	; only do this if set to first time
   1895  0b40		       d0 ca		      bne	tstBranch
   1896  0b42		       78		      sei		; disable the interupt until ireturn resets it
   1897  0b43		       ee a5 1d    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1898  0b46		       20 3e 14 	      jsr	pushLN	; Push the next line to be executed
   1899  0b49		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1900  0b4b		       ad a6 1d 	      lda	IRQEntry	; Get the line number to branch to
   1901  0b4e		       85 4f		      sta	CURPTR	; put line number into r0
   1902  0b50		       ad a7 1d 	      lda	IRQEntry+1
   1903  0b53		       85 50		      sta	CURPTR+1
   1904  0b55		       a9 03		      lda	#3	; Point to first byte of program text
   1905  0b57		       85 51		      sta	CUROFF
   1906  0b59		       4c bb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1907  0b5c
   1908  0b5c		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1909  0b5e		       a9 00		      lda	#0	; stop the execution
   1910  0b60		       4c 18 06 	      jmp	iErr2
   1911  0b63							;
   1912  0b63
   1913  0b63							;=====================================================
   1914  0b63							; This places the number of free bytes on top of the
   1915  0b63							; stack.
   1916  0b63							;
   1917  0b63		       20 25 0d    iFREE      jsr	MemFree
   1918  0b66		       20 24 14 	      jsr	pushR0
   1919  0b69		       4c bb 02 	      jmp	NextIL
   1920  0b6c							;
   1921  0b6c							;=====================================================
   1922  0b6c							; Generate a random number from 0-FFFF and then MOD
   1923  0b6c							; it with the value on top of stack.  Leaves number on
   1924  0b6c							; stack
   1925  0b6c							;
   1926  0b6c		       20 c0 14    iRANDOM    jsr	popR1	;mod value
   1927  0b6f							;
   1928  0b6f							; If the value is zero, just return a one.
   1929  0b6f							;
   1930  0b6f		       a5 54		      lda	R1
   1931  0b71		       05 55		      ora	R1+1
   1932  0b73		       f0 4a		      beq	irandom1
   1933  0b75							;
   1934  0b75		       ad f4 26 	      lda	random+1
   1935  0b78		       8d f1 26 	      sta	rtemp1
   1936  0b7b		       ad f3 26 	      lda	random
   1937  0b7e		       0a		      asl
   1938  0b7f		       2e f1 26 	      rol	rtemp1
   1939  0b82		       0a		      asl
   1940  0b83		       2e f1 26 	      rol	rtemp1
   1941  0b86		       18		      clc
   1942  0b87		       6d f3 26 	      adc	random
   1943  0b8a
   1944  0b8a		       48		      pha
   1945  0b8b
   1946  0b8b		       ad f1 26 	      lda	rtemp1
   1947  0b8e		       6d f4 26 	      adc	random+1
   1948  0b91		       8d f4 26 	      sta	random+1
   1949  0b94
   1950  0b94		       68		      pla
   1951  0b95
   1952  0b95		       69 11		      adc	#$11
   1953  0b97		       8d f3 26 	      sta	random
   1954  0b9a		       ad f4 26 	      lda	random+1
   1955  0b9d		       69 36		      adc	#$36
   1956  0b9f		       8d f4 26 	      sta	random+1
   1957  0ba2
   1958  0ba2		       ad f3 26 	      lda	random
   1959  0ba5		       85 52		      sta	R0
   1960  0ba7		       ad f4 26 	      lda	random+1
   1961  0baa		       29 7f		      and	#$7f	;make positive
   1962  0bac		       85 53		      sta	R0+1
   1963  0bae							;
   1964  0bae							; R0 contains the number and R1 contains the max value.
   1965  0bae							;
   1966  0bae		       20 29 07 	      jsr	iDivNoPop
   1967  0bb1		       20 29 15 	      jsr	RestoreSigns
   1968  0bb4		       a5 56		      lda	MQ
   1969  0bb6		       85 52		      sta	R0
   1970  0bb8		       a5 57		      lda	MQ+1
   1971  0bba		       85 53		      sta	R0+1
   1972  0bbc		       4c 03 07 	      jmp	pushR0nextIl
   1973  0bbf				   irandom1
   1974  0bbf		       a9 00		      lda	#0
   1975  0bc1		       85 53		      sta	R0+1
   1976  0bc3		       a9 01		      lda	#1
   1977  0bc5		       85 52		      sta	R0
   1978  0bc7		       4c 03 07 	      jmp	pushR0nextIl
   1979  0bca
   1980  0bca							; The following replaced by call to division/modulo
   1981  0bca							;iRANDOM_2	lda	R0
   1982  0bca							;		cmp	R1
   1983  0bca							;		bne	iRANDOM_1
   1984  0bca							;		lda	R0+1
   1985  0bca							;		cmp	R1+1
   1986  0bca							;		bne	iRANDOM_1	;need to subtract
   1987  0bca							;
   1988  0bca							; Subtract R1 from R0
   1989  0bca							;
   1990  0bca							;iRANDOM_sub	sec
   1991  0bca							;		lda	R0
   1992  0bca							;		sbc	R1
   1993  0bca							;		sta	R0
   1994  0bca							;		lda	R0+1
   1995  0bca							;		sbc	R1+1
   1996  0bca							;		sta	R0+1
   1997  0bca							;		jmp	iRANDOM_2
   1998  0bca							;
   1999  0bca							; See if R1 > R0.  If so, branch to subtract.
   2000  0bca							;
   2001  0bca							;iRANDOM_1	lda	R0
   2002  0bca							;		cmp	R1
   2003  0bca							;		lda	R0+1
   2004  0bca							;		sbc	R1+1
   2005  0bca							;		bvc	iRANDOM_4
   2006  0bca							;		eor	#$80
   2007  0bca							;iRANDOM_4	bpl	iRANDOM_sub
   2008  0bca							;
   2009  0bca							; All done.  Almost.  Add one, then push the result.
   2010  0bca							;
   2011  0bca							;irandom1	inc	R0
   2012  0bca							;		bne	iRANDOM_3
   2013  0bca							;		inc	R0+1
   2014  0bca							;iRANDOM_3
   2015  0bca							;		  jsr	pushR0	;return value
   2016  0bca							;		jmp	NextIL
   2017  0bca							;
   2018  0bca							; Poke a value into a memory location
   2019  0bca		       8c f9 26    iPOKEMEMORY sty	tempy
   2020  0bcd		       20 a8 14 	      jsr	popR0
   2021  0bd0		       20 c0 14 	      jsr	popR1
   2022  0bd3		       a0 00		      ldy	#0
   2023  0bd5		       a5 52		      lda	R0
   2024  0bd7		       91 54		      sta	(R1),y
   2025  0bd9		       ac f9 26 	      ldy	tempy
   2026  0bdc		       4c bb 02 	      jmp	NextIL
   2027  0bdf							;
   2028  0bdf							; Get a value from a memory location
   2029  0bdf							;
   2030  0bdf		       8c f9 26    iPEEKMEMORY sty	tempy
   2031  0be2		       20 a8 14 	      jsr	popR0
   2032  0be5		       a0 00		      ldy	#0
   2033  0be7		       b1 52		      lda	(R0),y
   2034  0be9		       ac f9 26 	      ldy	tempy
   2035  0bec		       85 52		      sta	R0
   2036  0bee		       a9 00		      lda	#0
   2037  0bf0		       85 53		      sta	R0+1
   2038  0bf2		       4c 03 07 	      jmp	pushR0nextIl
   2039  0bf5							;
   2040  0bf5							; Call to address return what ever is in a to the stack
   2041  0bf5							; func2 will load a value into a before the call
   2042  0bf5		       20 c0 14    iCallFunc  jsr	popR1
   2043  0bf8		       a5 54		      lda	R1
   2044  0bfa		       20 06 0c 	      jsr	iCallRtn
   2045  0bfd		       85 52		      sta	R0
   2046  0bff		       a9 00		      lda	#0
   2047  0c01		       85 53		      sta	R0+1
   2048  0c03		       20 03 07 	      jsr	pushR0nextIl
   2049  0c06				   iCallRtn
   2050  0c06		       20 a8 14 	      jsr	popR0
   2051  0c09		       6c 52 00 	      jmp	(R0)
   2052  0c0c
   2053  0c0c
   2054  0c0c							;===========================================jlit======
   2055  0c0c							;Get a character from the terminal convert to value
   2056  0c0c							;leave the number on top of the stack
   2057  0c0c							;
   2058  0c0c				   iGETCHAR
   2059  0c0c		       20 ad 16 	      jsr	VGETCH
   2060  0c0f					      if	CTMON65
   2061  0c0f		       48		      pha
   2062  0c10		       20 aa 16 	      jsr	VOUTCH	;echo echo echo
   2063  0c13		       68		      pla
   2064  0c14					      endif
   2065  0c14		       85 52		      sta	R0
   2066  0c16		       a9 00		      lda	#0
   2067  0c18		       85 53		      sta	R0+1
   2068  0c1a		       20 24 14 	      jsr	pushR0
   2069  0c1d							;
   2070  0c1d		       4c bb 02 	      jmp	NextIL
   2071  0c20							;===========================================jusilostintim======
   2072  0c20							;Put a character to the terminal convert to
   2073  0c20							;
   2074  0c20		       20 a8 14    iPUTCHAR   jsr	popR0
   2075  0c23		       a5 52		      lda	R0
   2076  0c25		       20 aa 16 	      jsr	VOUTCH
   2077  0c28		       4c bb 02 	      jmp	NextIL
   2078  0c2b							;=====================================================
   2079  0c2b							; Put the number on the stack out as hex, suppress leading 0
   2080  0c2b				   iHexOut
   2081  0c2b		       20 a8 14 	      jsr	popR0
   2082  0c2e		       a5 53		      lda	R0+1
   2083  0c30		       f0 03		      beq	iHexSecondByte
   2084  0c32		       20 09 17 	      jsr	OUTHEX
   2085  0c35				   iHexSecondByte
   2086  0c35		       a5 52		      lda	R0
   2087  0c37		       20 09 17 	      jsr	OUTHEX
   2088  0c3a		       4c bb 02 	      jmp	NextIL
   2089  0c3d							;
   2090  0c3d							;=====================================================
   2091  0c3d							; Replace TOS with its absolute value.
   2092  0c3d							;
   2093  0c3d		       20 a8 14    iABS       jsr	popR0
   2094  0c40		       a5 53		      lda	R0+1
   2095  0c42		       10 10		      bpl	iABS_1	;already positive
   2096  0c44		       49 ff		      eor	#$ff
   2097  0c46		       85 53		      sta	R0+1
   2098  0c48		       a5 52		      lda	R0
   2099  0c4a		       49 ff		      eor	#$ff
   2100  0c4c		       85 52		      sta	R0
   2101  0c4e		       e6 52		      inc	R0
   2102  0c50		       d0 02		      bne	iABS_1
   2103  0c52		       e6 53		      inc	R0+1
   2104  0c54		       4c 03 07    iABS_1     jmp	pushR0nextIl
   2105  0c57
   2106  0c57							;
   2107  0c57							;================================================================
   2108  0c57							; The set of logical operators
   2109  0c57				   iLogAnd
   2110  0c57		       20 a8 14 	      jsr	popR0
   2111  0c5a		       20 c0 14 	      jsr	popR1
   2112  0c5d		       a5 52		      lda	R0
   2113  0c5f		       25 54		      and	R1
   2114  0c61		       85 52		      sta	R0
   2115  0c63		       a5 53		      lda	R0+1
   2116  0c65		       25 55		      and	R1+1
   2117  0c67		       85 53		      sta	R0+1
   2118  0c69		       4c 03 07 	      jmp	pushR0nextIl
   2119  0c6c				   iLogOr
   2120  0c6c		       20 a8 14 	      jsr	popR0
   2121  0c6f		       20 c0 14 	      jsr	popR1
   2122  0c72		       a5 52		      lda	R0
   2123  0c74		       05 54		      ora	R1
   2124  0c76		       85 52		      sta	R0
   2125  0c78		       a5 53		      lda	R0+1
   2126  0c7a		       05 55		      ora	R1+1
   2127  0c7c		       85 53		      sta	R0+1
   2128  0c7e		       4c 03 07 	      jmp	pushR0nextIl
   2129  0c81				   iLogXor
   2130  0c81		       20 a8 14 	      jsr	popR0
   2131  0c84		       20 c0 14 	      jsr	popR1
   2132  0c87		       a5 52		      lda	R0
   2133  0c89		       45 54		      eor	R1
   2134  0c8b		       85 52		      sta	R0
   2135  0c8d		       a5 53		      lda	R0+1
   2136  0c8f		       45 55		      eor	R1+1
   2137  0c91		       85 53		      sta	R0+1
   2138  0c93		       4c 03 07 	      jmp	pushR0nextIl
   2139  0c96				   iLogNot
   2140  0c96		       20 a8 14 	      jsr	popR0
   2141  0c99		       a5 52		      lda	R0
   2142  0c9b		       49 ff		      eor	#$FF
   2143  0c9d		       85 52		      sta	R0
   2144  0c9f		       a5 53		      lda	R0+1
   2145  0ca1		       49 ff		      eor	#$FF
   2146  0ca3		       85 53		      sta	R0+1
   2147  0ca5		       4c 03 07 	      jmp	pushR0nextIl
   2148  0ca8
   2149  0ca8				   iTruth
   2150  0ca8		       a9 ff		      lda	#$FF
   2151  0caa		       85 52		      sta	R0
   2152  0cac		       85 53		      sta	R0+1
   2153  0cae		       4c 03 07 	      jmp	pushR0nextIl
   2154  0cb1				   iFalse
   2155  0cb1		       a9 00		      lda	#$00
   2156  0cb3		       85 52		      sta	R0
   2157  0cb5		       85 53		      sta	R0+1
   2158  0cb7		       4c 03 07 	      jmp	pushR0nextIl
   2159  0cba
   2160  0cba							;================================================================
   2161  0cba							;Set the IRQ service rtn line number
   2162  0cba							;
   2163  0cba		       78	   iSetIrq    sei		; disable the interupts
   2164  0cbb		       a9 00		      lda	#0	; Zero the Status flag
   2165  0cbd		       8d a4 1d 	      sta	IRQStatus
   2166  0cc0		       20 a8 14 	      jsr	popR0	; get the line number
   2167  0cc3		       a5 52		      lda	R0
   2168  0cc5		       05 53		      ora	R0+1
   2169  0cc7		       f0 20		      beq	iSetExt	; if it is zero disable all
   2170  0cc9		       20 3e 14 	      jsr	pushLN	; Save the current line pointer
   2171  0ccc		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2172  0cce		       4c 5c 0b 	      jmp	ErrStkOver	; Check if there was an error
   2173  0cd1				   iSetIrqOk
   2174  0cd1		       20 04 12 	      jsr	findLine	; Find the IRQ func Line Pointer
   2175  0cd4		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2176  0cd6		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2177  0cd8		       8d a7 1d 	      sta	IRQEntry+1
   2178  0cdb		       a5 4f		      lda	CURPTR
   2179  0cdd		       8d a6 1d 	      sta	IRQEntry
   2180  0ce0		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2181  0ce2		       8d a4 1d 	      sta	IRQStatus
   2182  0ce5		       20 63 14 	      jsr	popLN	; Restore the old line number
   2183  0ce8		       58		      cli		; Enable the interupts
   2184  0ce9		       4c bb 02    iSetExt    jmp	NextIL
   2185  0cec
   2186  0cec		       20 63 14    iSetIrqErr jsr	popLN
   2187  0cef		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2188  0cf1		       a9 00		      lda	#0
   2189  0cf3		       4c 18 06 	      jmp	iErr2
   2190  0cf6							;
   2191  0cf6		       20 a8 14    iTRACEPROG jsr	popR0
   2192  0cf9		       a5 52		      lda	R0
   2193  0cfb		       85 40		      sta	ILTrace
   2194  0cfd		       4c bb 02 	      jmp	NextIL
   2195  0d00
   2196  0d00							;=====================================================
   2197  0d00							; Define start of non page zero data
   2198 U270b ????				      seg.u	TBData
   2199 U1d93					      org	PROGEND
   2200 U1d93							;=================================================================
   2201 U1d93							;
------- FILE mem.asm LEVEL 2 PASS 6
      0 U1d93					      include	"mem.asm"
      1 U1d93							;===================================================================
      2 U1d93							;This file contains the memory allocation and free functions
      3 U1d93							;in herant in this is the management of free memory in the system
      4 U1d93							; the interface to these functions
      5 U1d93							; a,x returns or provides the low hi bytes of the managed addresses
      6 U1d93							; This uses the programend, to memory end as the area to manage
      7 U1d93							;===================================================================
      8  0d00					      Seg	Code
      9  0d00							;=====================================================
     10  0d00							;Pointers for memory Management
     11  0d00							;Allocated block are not chained but can be followed for all memory by the associated length
     12  0d00							; Mem block format is
     13  0d00							;	 0-1   pointer to next block for free blocks
     14  0d00							;	 0-1   for allocated blocks
     15  0d00							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  0d00							;	   1   refrence counter ... lol only up to 256 but it is something
     17  0d00							;	 2-3   length constant for exevy type of memory block
     18  0d00							; Memory is recombined as it is released
     19  0d00							; The memory manager is not interupted durring allocation
     20  0d00							; or freeing of memory
     21  0d00							; Memory is allocated from the highest memory address towards
     22  0d00							; the lowest memory address. meeting the Basic program end.
     23  0d00							;====================================================
     24  0d00							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  0d00							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  0d00							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  0d00							;=====================================================
     28  0d00				   MemInit
     29  0d00		       a9 0b		      lda	#FreeMemStart&$FF
     30  0d02		       8d 01 27 	      sta	ProgramStart
     31  0d05		       8d 03 27 	      sta	ProgramEnd
     32  0d08		       a9 27		      lda	#FreeMemStart>>8
     33  0d0a		       8d 02 27 	      sta	ProgramStart+1
     34  0d0d		       8d 04 27 	      sta	ProgramEnd+1
     35  0d10
     36  0d10		       20 1a 0d 	      jsr	GetSizes
     37  0d13		       20 25 0d 	      jsr	MemFree
     38  0d16		       20 3d 0d 	      jsr	MemUsed
     39  0d19				   MemInitEnd
     40  0d19		       60		      rts
     41  0d1a
     42  0d1a
     43  0d1a							;
     44  0d1a							;=====================================================
     45  0d1a							; This function might go away eventually, but was
     46  0d1a							; added to provide data for other pieces of code.
     47  0d1a							; It has some ties to the operating environment that
     48  0d1a							; will need to be customized for the target system.
     49  0d1a							;
     50  0d1a				   GetSizes
     51  0d1a							;
     52  0d1a							; Here is machine specific code to get the highest
     53  0d1a							; memory location that can be used by BASIC.
     54  0d1a							;
     55  0d1a				  -	      if	ProgramStart < $2000
     56  0d1a				  -	      lda	#$ff
     57  0d1a				  -	      sta	HighMem	;$13ff for KIM-1
     58  0d1a				  -	      sta	MemFreeList
     59  0d1a				  -	      lda	#$DE	;#$13
     60  0d1a				  -	      sta	HighMem+1
     61  0d1a				  -	      sta	MemFreeList+1
     62  0d1a					      else
     63  0d1a		       a9 ff		      lda	#$ff
     64  0d1c		       8d 05 27 	      sta	HighMem	;$CFFF otherwise
     65  0d1f		       a9 cf		      lda	#$cf
     66  0d21		       8d 06 27 	      sta	HighMem+1
     67  0d24					      endif
     68  0d24		       60		      rts
     69  0d25							;
     70  0d25							; This computes the available memory remaining.
     71  0d25							;
     72  0d25				   MemFree
     73  0d25		       38		      sec
     74  0d26		       ad 05 27 	      lda	HighMem
     75  0d29		       ed 03 27 	      sbc	ProgramEnd
     76  0d2c		       8d 09 27 	      sta	FreeMem
     77  0d2f		       85 52		      sta	R0
     78  0d31		       ad 06 27 	      lda	HighMem+1
     79  0d34		       ed 04 27 	      sbc	ProgramEnd+1
     80  0d37		       8d 0a 27 	      sta	FreeMem+1
     81  0d3a		       85 53		      sta	R0+1
     82  0d3c		       60		      rts
     83  0d3d							;
     84  0d3d							; This computes the size of the current user program.
     85  0d3d							;
     86  0d3d				   MemUsed
     87  0d3d		       38		      sec
     88  0d3e		       ad 03 27 	      lda	ProgramEnd
     89  0d41		       ed 01 27 	      sbc	ProgramStart
     90  0d44		       8d 07 27 	      sta	UsedMem
     91  0d47		       85 52		      sta	R0
     92  0d49		       ad 04 27 	      lda	ProgramEnd+1
     93  0d4c		       ed 02 27 	      sbc	ProgramStart+1
     94  0d4f		       8d 08 27 	      sta	UsedMem+1
     95  0d52		       85 53		      sta	R0+1
     96  0d54							;
     97  0d54		       60		      rts
     98  0d55
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  0d55					      include	"gosub.asm"
      1  0d55					      seg	Code
      2  0d55
      3  0d55							; Gosub and return related functions
      4  0d55							;==========================================================
      5  0d55							; Push the current math stack frame onto the gosub stack
      6  0d55				   iPushMathStack
      7  0d55		       98		      tya
      8  0d56		       48		      pha
      9  0d57		       a4 4d		      ldy	GOSUBSTACKPTR
     10  0d59		       a5 4a		      lda	MATHSTACKPTR
     11  0d5b		       91 4b		      sta	(GOSUBSTACK),y
     12  0d5d		       a9 00		      lda	#0
     13  0d5f		       c8		      iny
     14  0d60		       91 4b		      sta	(GOSUBSTACK),y
     15  0d62		       c8		      iny
     16  0d63		       91 4b		      sta	(GOSUBSTACK),y
     17  0d65		       c8		      iny
     18  0d66		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  0d68		       91 4b		      sta	(GOSUBSTACK),y
     20  0d6a		       c8		      iny
     21  0d6b		       84 4d		      sty	GOSUBSTACKPTR
     22  0d6d		       68		      pla
     23  0d6e		       a8		      tay
     24  0d6f		       4c bb 02 	      jmp	NextIL
     25  0d72							;
     26  0d72							;==========================================================
     27  0d72							; Increment parameter count. Assume Stack frame is top of stack
     28  0d72				   iIncParmCount
     29  0d72		       98		      tya
     30  0d73		       48		      pha
     31  0d74		       a4 4d		      ldy	GOSUBSTACKPTR
     32  0d76		       88		      dey
     33  0d77		       88		      dey
     34  0d78		       88		      dey
     35  0d79		       b1 4b		      lda	(GOSUBSTACK),y
     36  0d7b		       aa		      tax
     37  0d7c		       e8		      inx
     38  0d7d		       8a		      txa
     39  0d7e		       91 4b		      sta	(GOSUBSTACK),y
     40  0d80		       68		      pla
     41  0d81		       a8		      tay
     42  0d82		       4c bb 02 	      jmp	NextIL
     43  0d85							;
     44  0d85							;==========================================================
     45  0d85							;Restore the math stack frame
     46  0d85		       20 8b 0d    iPopMathStack jsr	PopMathStackNow
     47  0d88		       4c bb 02 	      jmp	NextIL
     48  0d8b
     49  0d8b				   PopMathStackNow
     50  0d8b		       98		      tya
     51  0d8c		       48		      pha
     52  0d8d
     53  0d8d		       a4 4d		      ldy	GOSUBSTACKPTR
     54  0d8f		       88		      dey
     55  0d90		       b1 4b		      lda	(GOSUBSTACK),y
     56  0d92		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  0d94		       d0 09		      bne	iPopMathStackNoFrame
     58  0d96		       88		      dey
     59  0d97		       88		      dey
     60  0d98		       88		      dey
     61  0d99		       b1 4b		      lda	(GOSUBSTACK),y
     62  0d9b		       85 4a		      sta	MATHSTACKPTR
     63  0d9d		       84 4d		      sty	GOSUBSTACKPTR
     64  0d9f
     65  0d9f				   iPopMathStackNoFrame
     66  0d9f
     67  0d9f		       68		      pla
     68  0da0		       a8		      tay
     69  0da1		       60		      rts
     70  0da2
     71  0da2
     72  0da2							;==========================================================
     73  0da2							; Push the current math stack information onto the gosub stack
     74  0da2				   iSaveMathStack
     75  0da2		       98		      tya
     76  0da3		       48		      pha
     77  0da4		       a4 4d		      ldy	GOSUBSTACKPTR
     78  0da6		       a5 4a		      lda	MATHSTACKPTR
     79  0da8		       91 4b		      sta	(GOSUBSTACK),y
     80  0daa		       a5 48		      lda	MATHSTACK
     81  0dac		       c8		      iny
     82  0dad
     83  0dad		       91 4b		      sta	(GOSUBSTACK),y
     84  0daf		       c8		      iny
     85  0db0
     86  0db0		       a5 49		      lda	MATHSTACK+1
     87  0db2		       91 4b		      sta	(GOSUBSTACK),y
     88  0db4		       c8		      iny
     89  0db5
     90  0db5		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  0db7		       91 4b		      sta	(GOSUBSTACK),y
     92  0db9		       c8		      iny
     93  0dba
     94  0dba		       84 4d		      sty	GOSUBSTACKPTR
     95  0dbc		       68		      pla
     96  0dbd		       a8		      tay
     97  0dbe		       4c bb 02 	      jmp	NextIL
     98  0dc1							;
     99  0dc1							;==========================================================
    100  0dc1							;Restore the math stack information from the gosub stack
    101  0dc1				   iRestoreMathStack
    102  0dc1		       98		      tya
    103  0dc2		       48		      pha
    104  0dc3
    105  0dc3		       a5 4a		      lda	MATHSTACKPTR
    106  0dc5		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  0dc7
    108  0dc7		       a4 4d		      ldy	GOSUBSTACKPTR
    109  0dc9		       88		      dey
    110  0dca		       b1 4b		      lda	(GOSUBSTACK),y
    111  0dcc		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  0dce		       d0 16		      bne	iPopMathStack_Err
    113  0dd0		       88		      dey
    114  0dd1		       b1 4b		      lda	(GOSUBSTACK),y
    115  0dd3		       85 49		      sta	MATHSTACK+1
    116  0dd5		       88		      dey
    117  0dd6		       b1 4b		      lda	(GOSUBSTACK),y
    118  0dd8		       85 48		      sta	MATHSTACK
    119  0dda		       88		      dey
    120  0ddb		       b1 4b		      lda	(GOSUBSTACK),y
    121  0ddd		       85 4a		      sta	MATHSTACKPTR
    122  0ddf		       84 4d		      sty	GOSUBSTACKPTR
    123  0de1		       68		      pla
    124  0de2		       a8		      tay
    125  0de3		       4c bb 02 	      jmp	NextIL
    126  0de6
    127  0de6				   iPopMathStack_Err
    128  0de6		       a9 00		      lda	#0
    129  0de8		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  0dea		       4c 18 06 	      jmp	iErr2
    131  0ded							;=========================================
    132  0ded							; For functions and tasks the variable address of # means
    133  0ded							; a passed parameter so #[0] is the first parameter etc
    134  0ded							; will try for a better way later
    135  0ded
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  0ded					      include	"tasks.asm"
      1  0ded							;=====================================================
      2  0ded							; Tiny Basic IL task management
      3  0ded							; Data required by task management
      4  0ded							; currently each context is about 30 bytes and is swapped
      5  0ded							; into and out of page zero on each task switch....
      6  0ded							; LOL yes it is slow, but works for this iteration.
      7  0ded							;
      8  0ded
      9  0ded					      Seg	Code
     10  0ded							;=====================================================
     11  0ded							; Sets the pointers to the math,IL and gosub stacks
     12  0ded							; Creates the initial Context for each task slot
     13  0ded				   taskSetStacks
     14  0ded		       a9 a8		      lda	#mathStack&$FF
     15  0def		       85 48		      sta	MATHSTACK
     16  0df1		       a9 1e		      lda	#mathStack>>8
     17  0df3		       85 49		      sta	MATHSTACK+1
     18  0df5
     19  0df5		       a9 38		      lda	#ilStack&$ff
     20  0df7		       85 45		      sta	ILSTACK
     21  0df9		       a9 20		      lda	#ilStack>>8
     22  0dfb		       85 46		      sta	ILSTACK+1
     23  0dfd
     24  0dfd		       a9 c8		      lda	#gosubStack&$FF
     25  0dff		       85 4b		      sta	GOSUBSTACK
     26  0e01		       a9 21		      lda	#gosubStack>>8
     27  0e03		       85 4c		      sta	GOSUBSTACK+1
     28  0e05
     29  0e05		       a9 48		      lda	#variableStack&$FF
     30  0e07		       85 41		      sta	VARIABLES
     31  0e09		       a9 24		      lda	#variableStack>>8
     32  0e0b		       85 42		      sta	VARIABLES+1
     33  0e0d		       a2 0a		      ldx	#TASKCOUNT
     34  0e0f		       a0 00		      ldy	#0
     35  0e11		       20 9c 10 	      jsr	ContextSave
     36  0e14
     37  0e14		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  0e16		       b0 3a		      bcs	taskSetDone
     39  0e18
     40  0e18		       a5 4b		      lda	GOSUBSTACK
     41  0e1a		       18		      clc
     42  0e1b		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  0e1d		       85 4b		      sta	GOSUBSTACK
     44  0e1f		       a5 4c		      lda	GOSUBSTACK+1
     45  0e21		       69 00		      adc	#0
     46  0e23		       85 4c		      sta	GOSUBSTACK+1
     47  0e25
     48  0e25		       a5 45		      lda	ILSTACK	; must be less than 256
     49  0e27		       18		      clc
     50  0e28		       69 28		      adc	#ILSTACKSIZE*2
     51  0e2a		       85 45		      sta	ILSTACK
     52  0e2c		       a5 46		      lda	ILSTACK+1
     53  0e2e		       69 00		      adc	#0
     54  0e30		       85 46		      sta	ILSTACK+1
     55  0e32
     56  0e32		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  0e34		       18		      clc
     58  0e35		       69 28		      adc	#MATHSTACKSIZE*2
     59  0e37		       85 48		      sta	MATHSTACK
     60  0e39		       a5 49		      lda	MATHSTACK+1
     61  0e3b		       69 00		      adc	#0
     62  0e3d		       85 49		      sta	MATHSTACK+1
     63  0e3f
     64  0e3f		       a5 41		      lda	VARIABLES	; must be less than 256
     65  0e41		       18		      clc
     66  0e42		       69 36		      adc	#VARIABLESSIZE*2
     67  0e44		       85 41		      sta	VARIABLES
     68  0e46		       a5 42		      lda	VARIABLES+1
     69  0e48		       69 00		      adc	#0
     70  0e4a		       85 42		      sta	VARIABLES+1
     71  0e4c
     72  0e4c		       20 9c 10 	      jsr	ContextSave
     73  0e4f		       4c 14 0e 	      jmp	taskSetLoop
     74  0e52
     75  0e52				   taskSetDone
     76  0e52		       a0 00		      ldy	#0	; reload the main loop context
     77  0e54		       20 ab 10 	      jsr	ContextLoad
     78  0e57		       60		      rts
     79  0e58							;
     80  0e58							;=====================================================
     81  0e58							; In some error cases the math stacks may be left pointing to the wrong stack
     82  0e58							; This function will reset those stack addresses but not the actual pointer
     83  0e58				   taskResetStacks
     84  0e58		       a0 00		      ldy	#0
     85  0e5a		       20 ab 10 	      jsr	ContextLoad
     86  0e5d		       4c ed 0d 	      jmp	taskSetStacks
     87  0e60							;
     88  0e60							;=====================================================
     89  0e60							; Clear all task entries and task stacks
     90  0e60		       98	   taskReset  tya		; Save Y
     91  0e61		       48		      pha
     92  0e62		       a9 01		      lda	#1
     93  0e64		       8d a7 1e 	      sta	taskCounter	; Set number of active tasks to 1
     94  0e67		       ac a8 1d 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  0e6a		       c0 00		      cpy	#0	; check if we are the main context
     96  0e6c		       f0 08		      beq	taskResetCont	; if we are just continue
     97  0e6e
     98  0e6e		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  0e70		       8c a8 1d 	      sty	taskPtr
    100  0e73		       20 ab 10 	      jsr	ContextLoad	; load the System Task context
    101  0e76				   taskResetCont
    102  0e76		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  0e78
    104  0e78				   taskResetLoop
    105  0e78		       a9 00		      lda	#TASKINACTIVE
    106  0e7a		       99 a9 1d 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  0e7d		       18		      clc
    108  0e7e		       98		      tya
    109  0e7f		       69 19		      adc	#CONTEXTLEN+1
    110  0e81		       a8		      tay
    111  0e82		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  0e84		       90 f2		      bcc	taskResetLoop	; Go for more
    113  0e86
    114  0e86				   taskResetComplete
    115  0e86
    116  0e86		       68		      pla		; Restore y
    117  0e87		       a8		      tay
    118  0e88		       60		      rts
    119  0e89
    120  0e89							;
    121  0e89							;======================================================
    122  0e89							; iTaskSwitch	 switch to new task if not interrupt and
    123  0e89							;		 count is exceded for task time slice gets here
    124  0e89							;		 when time slice has reached zero
    125  0e89							;
    126  0e89		       98	   iTaskSwitch tya
    127  0e8a		       48		      pha
    128  0e8b
    129  0e8b		       ad a5 1e 	      lda	taskResetValue	; Always reset the counter value
    130  0e8e		       8d a3 1e 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  0e91		       ce a4 1e 	      dec	taskCurrentCycles+1	; dec high order byte
    132  0e94		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  0e96
    134  0e96		       ad a6 1e 	      lda	taskResetValue+1
    135  0e99		       8d a4 1e 	      sta	taskCurrentCycles+1
    136  0e9c
    137  0e9c		       ad a5 1d 	      lda	IRQPending	; Skip this if we are processing an irq
    138  0e9f		       0d ff 26 	      ora	taskIOPending	; If set then don't switch
    139  0ea2		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  0ea4
    141  0ea4		       ad a7 1e    iTaskMain  lda	taskCounter	; Number of tasks
    142  0ea7		       c9 01		      cmp	#1	; if there is only one task must be main
    143  0ea9		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  0eab
    145  0eab		       ac a8 1d 	      ldy	taskPtr	; check if we have not just ended some other task
    146  0eae		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  0eb0		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  0eb2							;
    149  0eb2							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  0eb2							;
    151  0eb2				   itasknext
    152  0eb2		       ac a8 1d 	      ldy	taskPtr
    153  0eb5		       20 9c 10 	      jsr	ContextSave	; Save the current context, y points to next context
    154  0eb8				   itaskLoop
    155  0eb8		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  0eba		       90 04		      bcc	iTaskNextChk
    157  0ebc
    158  0ebc		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  0ebe		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  0ec0
    161  0ec0				   iTaskNextChk
    162  0ec0		       b9 a9 1d 	      lda	taskTable,y	; there is always at least one entry in table
    163  0ec3		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  0ec5		       18	   iTaskNext  clc
    165  0ec6		       98		      tya
    166  0ec7		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  0ec9		       a8		      tay
    168  0eca		       4c b8 0e 	      jmp	itaskLoop	; Check for busy entry
    169  0ecd
    170  0ecd		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  0ecf		       59 a9 1d 	      eor	taskTable,y	; Check for anything waiting io
    172  0ed2		       d0 f1		      bne	iTaskNext
    173  0ed4		       20 ab 10 	      jsr	ContextLoad	; load the next context
    174  0ed7		       8c a8 1d 	      sty	taskPtr	; update the task pointer
    175  0eda
    176  0eda				   iTaskSwitchDone
    177  0eda		       68		      pla
    178  0edb		       a8		      tay
    179  0edc		       60		      rts
    180  0edd							;
    181  0edd							;================================================================
    182  0edd							; Task Set task number to line number to start
    183  0edd							; Task Table structure:
    184  0edd							;    byte 0	-   Active inactive
    185  0edd							;    byte 1-2	-   Basic code line pointer
    186  0edd							;    byte 3	-   Offset on current line
    187  0edd		       98	   iTaskSet   tya		;preserve Y
    188  0ede		       48		      pha		; push a
    189  0edf
    190  0edf		       20 a8 14 	      jsr	popR0	; Get the line number to be saved
    191  0ee2
    192  0ee2		       ac a8 1d 	      ldy	taskPtr	; find out where we are
    193  0ee5		       20 9c 10 	      jsr	ContextSave	; Save the current context
    194  0ee8
    195  0ee8							;Find the pointer to the line we need to start at
    196  0ee8		       20 04 12 	      jsr	findLine	; Get the offset of the line to start task at
    197  0eeb		       f0 0b		      beq	iTaskCont
    198  0eed
    199  0eed		       ac a8 1d 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  0ef0		       20 ab 10 	      jsr	ContextLoad
    201  0ef3
    202  0ef3		       68		      pla		; pop a - exit
    203  0ef4		       a8		      tay
    204  0ef5		       4c ec 0c 	      jmp	iSetIrqErr	; Bad line number provided
    205  0ef8
    206  0ef8				   iTaskCont
    207  0ef8		       20 6e 10 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  0efb		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  0efd
    210  0efd		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  0eff		       99 a9 1d 	      sta	taskTable,y	; new task as active
    212  0f02
    213  0f02		       a5 4f		      lda	CURPTR
    214  0f04		       48		      pha		; push a
    215  0f05		       a5 50		      lda	CURPTR+1
    216  0f07		       48		      pha		; push a
    217  0f08
    218  0f08		       20 ab 10 	      jsr	ContextLoad	; load the context of the new task
    219  0f0b
    220  0f0b		       68		      pla		; pop a
    221  0f0c		       85 50		      sta	CURPTR+1
    222  0f0e		       68		      pla		; pop a
    223  0f0f		       85 4f		      sta	CURPTR
    224  0f11		       a9 03		      lda	#3	; Offset to first instruction
    225  0f13		       85 51		      sta	CUROFF
    226  0f15
    227  0f15		       a9 00		      lda	#0
    228  0f17		       85 47		      sta	ILSTACKPTR
    229  0f19		       85 4a		      sta	MATHSTACKPTR
    230  0f1b		       85 4d		      sta	GOSUBSTACKPTR
    231  0f1d		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  0f1f		       85 4e		      sta	MESSAGEPTR
    233  0f21
    234  0f21		       20 49 09 	      jsr	subVINIT	; Clear the variables
    235  0f24
    236  0f24		       a9 e5		      lda	#STMT&$FF
    237  0f26		       85 43		      sta	ILPC
    238  0f28		       a9 18		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  0f2a		       85 44		      sta	ILPC+1
    240  0f2c
    241  0f2c		       98		      tya		; Save the new context offset to return to user
    242  0f2d		       48		      pha		; push a
    243  0f2e
    244  0f2e		       20 9c 10    itaskSetSave jsr	ContextSave	; save the updated context
    245  0f31		       ee a7 1e 	      inc	taskCounter	; Update the number of Tasks running
    246  0f34
    247  0f34		       ac a8 1d 	      ldy	taskPtr
    248  0f37		       20 ab 10 	      jsr	ContextLoad	; restore the original context
    249  0f3a
    250  0f3a		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  0f3c		       85 53		      sta	R0+1
    252  0f3e		       68		      pla		; Get the task pid we stored				 ; pop a
    253  0f3f		       85 52		      sta	R0	; Get the table entry value
    254  0f41
    255  0f41		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  0f42		       a8		      tay
    257  0f43
    258  0f43		       4c 03 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  0f46				   iTaskNoEmpty
    260  0f46		       ac a8 1d 	      ldy	taskPtr
    261  0f49		       20 ab 10 	      jsr	ContextLoad
    262  0f4c
    263  0f4c		       68		      pla		; pop a    -- exit
    264  0f4d		       a8		      tay
    265  0f4e
    266  0f4e		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  0f50		       a9 00		      lda	#0
    268  0f52		       4c 18 06 	      jmp	iErr2
    269  0f55							;
    270  0f55							;===============================================================
    271  0f55							; Run the task whos PID is on the stack, preserve the stack
    272  0f55							;
    273  0f55				   iTaskEnable
    274  0f55		       98		      tya
    275  0f56		       48		      pha
    276  0f57		       20 c0 14 	      jsr	popR1
    277  0f5a		       20 8e 14 	      jsr	pushR1
    278  0f5d		       20 a2 11 	      jsr	ipc_getcontext	; get context pointer into mq
    279  0f60		       a0 00		      ldy	#0
    280  0f62		       b1 56		      lda	(MQ),y
    281  0f64		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  0f66		       09 80		      ora	#TASKACTIVE
    283  0f68		       91 56		      sta	(MQ),y
    284  0f6a		       68		      pla
    285  0f6b		       a8		      tay
    286  0f6c		       4c bb 02 	      jmp	NextIL
    287  0f6f
    288  0f6f							;
    289  0f6f							;===============================================================
    290  0f6f							; Suspend the task whos PID  is on the stack, preserve the stack
    291  0f6f							;
    292  0f6f				   iTaskSuspend
    293  0f6f		       98		      tya
    294  0f70		       48		      pha
    295  0f71		       20 c0 14 	      jsr	popR1
    296  0f74		       20 8e 14 	      jsr	pushR1
    297  0f77		       20 a2 11 	      jsr	ipc_getcontext	; get context pointer into mq
    298  0f7a		       a0 00		      ldy	#0
    299  0f7c		       b1 56		      lda	(MQ),y
    300  0f7e		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  0f80		       09 80		      ora	#TASKACTIVE
    302  0f82		       68		      pla
    303  0f83		       a8		      tay
    304  0f84		       4c bb 02 	      jmp	NextIL
    305  0f87
    306  0f87							;================================================================
    307  0f87							; Returns task Status
    308  0f87				   iTaskStat
    309  0f87		       98		      tya
    310  0f88		       48		      pha
    311  0f89		       20 9b 0f 	      jsr	iTaskValid	; returns pointer to task entry
    312  0f8c		       b9 a9 1d 	      lda	taskTable,y
    313  0f8f		       f0 05		      beq	iTaskStatExit
    314  0f91		       68		      pla
    315  0f92		       a8		      tay
    316  0f93		       4c a8 0c 	      jmp	iTruth
    317  0f96				   iTaskStatExit
    318  0f96		       68		      pla
    319  0f97		       a8		      tay
    320  0f98		       4c b1 0c 	      jmp	iFalse
    321  0f9b
    322  0f9b							;
    323  0f9b							;================================================================
    324  0f9b							; Validate the task number on top of the stack
    325  0f9b							; on exit y points to the requested task entry
    326  0f9b							;
    327  0f9b		       20 a8 14    iTaskValid jsr	popR0	; get result of the multiply
    328  0f9e		       a5 53		      lda	R0+1
    329  0fa0		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  0fa2		       a5 52		      lda	R0
    331  0fa4		       c9 fa		      cmp	#TASKTABLELEN
    332  0fa6		       90 09		      bcc	iTaskIsValid
    333  0fa8
    334  0fa8		       68	   iTaskValidErr pla		;remove return address
    335  0fa9		       68		      pla
    336  0faa		       a2 10		      ldx	#ERR_INVALID_PID
    337  0fac		       a9 00		      lda	#0
    338  0fae		       4c 18 06 	      jmp	iErr2
    339  0fb1
    340  0fb1		       a8	   iTaskIsValid tay
    341  0fb2		       60		      rts
    342  0fb3							;
    343  0fb3							;================================================================
    344  0fb3							; Kill a running task, do nothing if already stopped
    345  0fb3		       20 9b 0f    iTaskKill  jsr	iTaskValid
    346  0fb6		       a9 00		      lda	#0
    347  0fb8		       99 a9 1d 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  0fbb							;
    349  0fbb							;================================================================
    350  0fbb							;Skip to next task
    351  0fbb				   iNTask
    352  0fbb		       a9 01		      lda	#1
    353  0fbd		       8d a3 1e 	      sta	taskCurrentCycles
    354  0fc0		       8d a4 1e 	      sta	taskCurrentCycles+1
    355  0fc3		       4c bb 02 	      jmp	NextIL
    356  0fc6							;
    357  0fc6							;=======================================================
    358  0fc6							; Wait for a task to complete
    359  0fc6				   iWTASK
    360  0fc6		       20 bf 11 	      jsr	getILByte
    361  0fc9		       8d fd 26 	      sta	offset
    362  0fcc							;
    363  0fcc		       20 0e 14 	      jsr	saveIL	;in case of failure
    364  0fcf
    365  0fcf		       20 9b 0f 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  0fd2		       b9 a9 1d 	      lda	taskTable,y
    367  0fd5		       d0 03		      bne	iWTASKWAIT
    368  0fd7				   iWTASKEXITED
    369  0fd7		       4c bb 02 	      jmp	NextIL
    370  0fda				   iWTASKWAIT
    371  0fda		       20 24 14 	      jsr	pushR0	; Push R0 back onto the stack
    372  0fdd		       a9 01		      lda	#1
    373  0fdf		       8d a3 1e 	      sta	taskCurrentCycles	; Give up the cycles
    374  0fe2		       8d a4 1e 	      sta	taskCurrentCycles+1
    375  0fe5		       20 19 14 	      jsr	restoreIL
    376  0fe8		       4c 0c 0b 	      jmp	tstBranch
    377  0feb							;
    378  0feb							;=======================================================
    379  0feb							; Set task io lock
    380  0feb		       ee ff 26    iStartIO   inc	taskIOPending
    381  0fee		       4c bb 02 	      jmp	NextIL
    382  0ff1							;
    383  0ff1							;=======================================================
    384  0ff1							; Release the io lock
    385  0ff1		       ad ff 26    iEndIO     lda	taskIOPending
    386  0ff4		       f0 03		      beq	iEndIOExit
    387  0ff6		       ce ff 26 	      dec	taskIOPending
    388  0ff9		       4c bb 02    iEndIOExit jmp	NextIL
    389  0ffc							;
    390  0ffc							;===============================================================
    391  0ffc							; Return the task PID
    392  0ffc				   iTASKPID
    393  0ffc		       a9 00		      lda	#0
    394  0ffe		       85 53		      sta	R0+1
    395  1000		       ad a8 1d 	      lda	taskPtr
    396  1003		       85 52		      sta	R0
    397  1005		       4c 03 07 	      jmp	pushR0nextIl
    398  1008							;
    399  1008							;================================================================
    400  1008							; Terminate a task
    401  1008		       ac a8 1d    iETask     ldy	taskPtr
    402  100b		       c0 00		      cpy	#0
    403  100d		       d0 03		      bne	iETaskCont
    404  100f		       4c 01 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  1012				   iETaskCont
    406  1012		       a9 00		      lda	#TASKINACTIVE
    407  1014		       99 a9 1d 	      sta	taskTable,y	; mark entry as free
    408  1017		       ce a7 1e 	      dec	taskCounter	; reduce the number of active tasks
    409  101a		       a9 01		      lda	#1
    410  101c		       8d a3 1e 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  101f		       8d a4 1e 	      sta	taskCurrentCycles+1
    412  1022		       20 89 10 	      jsr	TaskSetExitCode
    413  1025				   iETaskExit
    414  1025		       4c bb 02 	      jmp	NextIL
    415  1028							;================================================================
    416  1028							; make the current tasks math stack equal another tasks stack
    417  1028							; The task to get is stored on the math stack
    418  1028
    419  1028				   iTaskGetMathStack
    420  1028		       20 3f 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  102b		       20 a2 11 	      jsr	ipc_getcontext	; MQ now has the context address
    422  102e		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  1030		       b1 56		      lda	(MQ),y
    424  1032		       85 4a		      sta	MATHSTACKPTR
    425  1034		       a0 08		      ldy	#MATHSTACKPOS
    426  1036		       b1 56		      lda	(MQ),y
    427  1038		       85 48		      sta	MATHSTACK
    428  103a		       c8		      iny
    429  103b		       b1 56		      lda	(MQ),y
    430  103d		       85 49		      sta	MATHSTACK+1
    431  103f		       4c bb 02 	      jmp	NextIL
    432  1042							;==================================================================
    433  1042							; Updates the tasks math stack pointer with contents of R2
    434  1042							; PID is on top of the stack
    435  1042				   iTaskPutMathPtr
    436  1042		       20 3f 17 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  1045		       20 a2 11 	      jsr	ipc_getcontext	; MQ now has the context address
    438  1048		       a5 58		      lda	R2
    439  104a		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  104c		       91 56		      sta	(MQ),y
    441  104e		       4c bb 02 	      jmp	NextIL
    442  1051							;
    443  1051							;================================================================
    444  1051							; Set the time slice for each task
    445  1051				   iSLICE
    446  1051		       20 a8 14 	      jsr	popR0
    447  1054		       a5 52		      lda	R0
    448  1056		       8d a5 1e 	      sta	taskResetValue
    449  1059		       a5 53		      lda	R0+1
    450  105b		       8d a6 1e 	      sta	taskResetValue+1
    451  105e		       d0 0b		      bne	iSliceSet
    452  1060		       ee a6 1e 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  1063		       a9 01		      lda	#1
    454  1065		       8d a3 1e 	      sta	taskCurrentCycles
    455  1068		       8d a4 1e 	      sta	taskCurrentCycles+1
    456  106b				   iSliceSet
    457  106b		       4c bb 02 	      jmp	NextIL
    458  106e							;================================================================
    459  106e							; Find an empty slot in the taskTable
    460  106e							; Return the index in y
    461  106e							; on exit   c set if an empty slot is found
    462  106e							;	     c clear if not found
    463  106e							;================================================================
    464  106e							;
    465  106e		       ad a7 1e    TaskEmpty  lda	taskCounter
    466  1071		       c9 0a		      cmp	#TASKCOUNT
    467  1073		       b0 10		      bcs	TaskNoSlot
    468  1075		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  1077				   TaskLoop
    470  1077		       b9 a9 1d 	      lda	taskTable,y
    471  107a		       f0 0b		      beq	TaskEmptyFnd
    472  107c		       98		      tya
    473  107d		       18		      clc
    474  107e		       69 19		      adc	#CONTEXTLEN+1
    475  1080		       a8		      tay
    476  1081		       c0 fa		      cpy	#TASKTABLELEN
    477  1083		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  1085				   TaskNoSlot
    479  1085		       18		      clc
    480  1086		       60		      rts
    481  1087				   TaskEmptyFnd
    482  1087		       38		      sec
    483  1088		       60		      rts
    484  1089							;====================================================
    485  1089							; Set the task exit code called from the return command
    486  1089							; on entry stack top hold exit value
    487  1089				   TaskSetExitCode
    488  1089		       98		      tya
    489  108a		       48		      pha
    490  108b		       20 a8 14 	      jsr	popR0
    491  108e		       a0 19		      ldy	#TASKEXITCODE
    492  1090		       a5 52		      lda	R0
    493  1092		       91 41		      sta	(VARIABLES),y
    494  1094		       c8		      iny
    495  1095		       a5 53		      lda	R0+1
    496  1097		       91 41		      sta	(VARIABLES),y
    497  1099		       68		      pla
    498  109a		       98		      tya
    499  109b		       60		      rts
    500  109c
    501  109c							;
    502  109c							;=====================================================
    503  109c							; Save Context Store the context to the TASK Table
    504  109c							; on entry y contains the task table entry to save to
    505  109c							; on exit y points to next task table entry
    506  109c							;	   x contains the number of bytes copied
    507  109c		       a2 00	   ContextSave ldx	#0
    508  109e		       c8		      iny		;inc past the task flags
    509  109f		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  10a1		       99 a9 1d 	      sta	taskTable,y
    511  10a4		       c8		      iny
    512  10a5		       e8		      inx
    513  10a6		       e0 18		      cpx	#CONTEXTLEN
    514  10a8		       90 f5		      bcc	ContextSvLoop
    515  10aa		       60		      rts
    516  10ab							;
    517  10ab							; Load Context transfer context from task table to the Current Context
    518  10ab							; on entry y contains the task table entry to transfer
    519  10ab							; on exit y points to the original task table entry
    520  10ab							;	   x contains the number of byts copied
    521  10ab		       98	   ContextLoad tya
    522  10ac		       48		      pha
    523  10ad		       a2 00		      ldx	#0
    524  10af		       c8		      iny		;inc past the task flags
    525  10b0		       b9 a9 1d    ContextLDLoop lda	taskTable,y
    526  10b3		       95 41		      sta	CONTEXT,x
    527  10b5		       c8		      iny
    528  10b6		       e8		      inx
    529  10b7		       e0 18		      cpx	#CONTEXTLEN
    530  10b9		       90 f5		      bcc	ContextLDLoop
    531  10bb		       68		      pla
    532  10bc		       a8		      tay
    533  10bd		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  10be					      include	"ipc.asm"
      1  10be							;======================================================
      2  10be							; Inter process communications.
      3  10be							; Tasks may write/read integer messages among
      4  10be							; them selves.
      5  10be							; This uses each tasks gosub stack as a message queue
      6  10be							; Gosub calls start at the highest address and the
      7  10be							; msg queue starts at the highest address.
      8  10be							;
      9  10be							;======================================================
     10  10be							; ipcs   - Send msg to another task or many tasks
     11  10be							; on entry  math stack contains the  top PID
     12  10be							;				      2ND Message value
     13  10be							; on exit   math stack contain top True-good or False-failed
     14  10be							;
     15  10be							; it may not be sent if queue is full
     16  10be							;
     17  10be							; a = ipcs(<message-expression>,<task PID-expression>)
     18  10be							;
     19  10be				   iIPCS
     20  10be		       98		      tya
     21  10bf		       48		      pha
     22  10c0		       20 27 11 	      jsr	ipc_enqueue
     23  10c3		       b0 08		      bcs	iIPC_BAD
     24  10c5		       20 31 17 	      jsr	pushTrue
     25  10c8		       68		      pla
     26  10c9		       a8		      tay
     27  10ca		       4c bb 02 	      jmp	NextIL
     28  10cd				   iIPC_BAD
     29  10cd		       68		      pla
     30  10ce		       a8		      tay
     31  10cf		       20 3b 17 	      jsr	pushFalse
     32  10d2		       4c bb 02 	      jmp	NextIL
     33  10d5
     34  10d5							;======================================================
     35  10d5							; ipcr   - Recieve msg from task
     36  10d5							; on exit  the message value is returned from message queue
     37  10d5							;	    message -1	is reserved meaning no entry found
     38  10d5							; The provided variable contains the pid of the sending
     39  10d5							; task. This is optional. This always waits for a message
     40  10d5							; before returning.
     41  10d5							;
     42  10d5							; a = ipcr(<variable name>)
     43  10d5							;
     44  10d5				   iIPCR
     45  10d5		       98		      tya
     46  10d6		       48		      pha
     47  10d7		       20 69 11 	      jsr	ipc_dequeue
     48  10da		       b0 05		      bcs	iIPCR_Q_Empty
     49  10dc		       68		      pla
     50  10dd		       a8		      tay
     51  10de		       4c bb 02 	      jmp	NextIL
     52  10e1				   iIPCR_Q_Empty
     53  10e1		       68		      pla
     54  10e2		       a8		      tay
     55  10e3		       20 31 17 	      jsr	pushTrue	; puts -1 on the stack
     56  10e6		       4c bb 02 	      jmp	NextIL
     57  10e9
     58  10e9							;=======================================================
     59  10e9							; ipcc   - Check if message available
     60  10e9							; on exit  Stack contains number of messages
     61  10e9							;
     62  10e9							; a = ipcc()
     63  10e9							;
     64  10e9				   iIPCC
     65  10e9		       98		      tya
     66  10ea		       48		      pha
     67  10eb		       20 14 11 	      jsr	ipc_queue_count
     68  10ee		       20 24 14 	      jsr	pushR0	; return the count
     69  10f1		       68		      pla
     70  10f2		       a8		      tay
     71  10f3		       4c bb 02 	      jmp	NextIL
     72  10f6
     73  10f6							;=======================================================
     74  10f6							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  10f6				   iIPCIO
     76  10f6		       98		      tya
     77  10f7		       48		      pha
     78  10f8		       20 14 11 	      jsr	ipc_queue_count
     79  10fb		       a5 52		      lda	R0
     80  10fd		       d0 10		      bne	iIPCIO_No_Halt
     81  10ff		       a9 01		      lda	#1
     82  1101		       8d a3 1e 	      sta	taskCurrentCycles	; force a task switch
     83  1104		       a9 01		      lda	#TASKWAITIPC
     84  1106		       ac a8 1d 	      ldy	taskPtr
     85  1109		       19 a9 1d 	      ora	taskTable,y
     86  110c		       99 a9 1d 	      sta	taskTable,y
     87  110f
     88  110f				   iIPCIO_No_Halt
     89  110f		       68		      pla
     90  1110		       a8		      tay
     91  1111		       4c bb 02 	      jmp	NextIL
     92  1114							;======================================================
     93  1114							;ipc_queue_count
     94  1114				   ipc_queue_count
     95  1114		       a5 4e		      lda	MESSAGEPTR
     96  1116		       18		      clc
     97  1117		       4a		      lsr		; divide by 4
     98  1118		       4a		      lsr
     99  1119		       85 52		      sta	R0	; store into R0
    100  111b		       a9 10		      lda	#GOSUBSTACKSIZE
    101  111d		       38		      sec
    102  111e		       e5 52		      sbc	R0	; Get how many entries on queue
    103  1120		       85 52		      sta	R0
    104  1122		       a9 00		      lda	#0
    105  1124		       85 53		      sta	R0+1
    106  1126		       60		      rts
    107  1127							;=======================================================
    108  1127							; Support functions for messaging
    109  1127							;
    110  1127							; Enqueue message -> onto PID's MSG Q
    111  1127							; on entry top of stack contains the PID
    112  1127							;	    second contains the Message of the task
    113  1127							; on exit contains c set if failed
    114  1127							;		    c cleared if success
    115  1127							;		    PID's MSG Q PTR points to the message
    116  1127							;
    117  1127				   ipc_enqueue
    118  1127		       20 c0 14 	      jsr	popR1	; Get the pid
    119  112a		       20 a2 11 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  112d
    121  112d		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  112f		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  1131		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1133		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1135		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1137
    127  1137
    128  1137							; Get the PID'S stack address into R0
    129  1137		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1139		       b1 56		      lda	(MQ),y
    131  113b		       85 52		      sta	R0
    132  113d		       c8		      iny
    133  113e		       b1 56		      lda	(MQ),y
    134  1140		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1142
    136  1142							; Set y to point to the msg q entry
    137  1142		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1144		       b1 56		      lda	(MQ),y	; Get the index
    139  1146		       a8		      tay		; Set y to queue offset
    140  1147
    141  1147							; enqueue the message
    142  1147		       88		      dey		; First byte to save to
    143  1148		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  114a		       91 52		      sta	(R0),y	; Set the entry type
    145  114c
    146  114c		       88		      dey
    147  114d		       ad a8 1d 	      lda	taskPtr	; Store the PID into queue
    148  1150		       91 52		      sta	(R0),y
    149  1152		       20 c0 14 	      jsr	popR1	; Get the actual message value
    150  1155		       20 b0 11 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1158
    152  1158		       98		      tya		; Save the new q ptr
    153  1159		       a0 0e		      ldy	#MSGPTRPOS
    154  115b		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  115d		       a0 00		      ldy	#0	; points to context root
    156  115f		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1161		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1163		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1165		       18		      clc
    160  1166		       60		      rts
    161  1167				   ipc_enq_full
    162  1167		       38		      sec
    163  1168		       60		      rts
    164  1169							;=============================================================
    165  1169							; De-queue for message stack -> local tasks msg q
    166  1169							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1169							;  message into
    168  1169							;  on exit   math stack contains value of message
    169  1169							;				  Variable if provided is pid
    170  1169				   ipc_dequeue
    171  1169		       20 d7 14 	      jsr	popMQ	; Variable address to put PID into
    172  116c
    173  116c		       a4 4e		      ldy	MESSAGEPTR
    174  116e		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  1170		       b0 2e		      bcs	ipc_deq_empty
    176  1172		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1174		       85 52		      sta	R0
    178  1176		       c8		      iny
    179  1177		       b1 4b		      lda	(GOSUBSTACK),y
    180  1179		       85 53		      sta	R0+1
    181  117b		       c8		      iny
    182  117c		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  117e		       85 54		      sta	R1
    184  1180		       c8		      iny
    185  1181		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1183		       c8		      iny
    187  1184		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1186
    189  1186		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1188		       d0 16		      bne	ipc_deq_empty
    191  118a
    192  118a		       20 24 14 	      jsr	pushR0	; place value on stack
    193  118d
    194  118d		       a5 56		      lda	MQ
    195  118f		       05 57		      ora	MQ+1
    196  1191		       f0 0b		      beq	ipc_deq_done
    197  1193		       a5 54		      lda	R1
    198  1195		       a0 00		      ldy	#0
    199  1197		       91 56		      sta	(MQ),y
    200  1199		       c8		      iny
    201  119a		       a9 00		      lda	#0
    202  119c		       91 56		      sta	(MQ),y
    203  119e				   ipc_deq_done
    204  119e		       18		      clc
    205  119f		       60		      rts
    206  11a0
    207  11a0				   ipc_deq_empty
    208  11a0		       38		      sec
    209  11a1		       60		      rts
    210  11a2
    211  11a2							;=============================================
    212  11a2							;  Get the context address into MQ from R1 with
    213  11a2							;  context/index/pid
    214  11a2				   ipc_getcontext
    215  11a2		       18		      clc		; Get pointer to Task context
    216  11a3		       a9 a9		      lda	#taskTable&$FF	; change ptr to address
    217  11a5		       65 54		      adc	R1
    218  11a7		       85 56		      sta	MQ
    219  11a9		       a9 1d		      lda	#taskTable>>8
    220  11ab		       65 55		      adc	R1+1
    221  11ad		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  11af		       60		      rts
    223  11b0							;
    224  11b0							;==============================================
    225  11b0							;Push R1 onto the stack
    226  11b0							;on entry y = next entry
    227  11b0							;R0 points to the stack space
    228  11b0							;on exit y points to next free byte
    229  11b0				   ipc_pushR1
    230  11b0		       88		      dey
    231  11b1		       a5 55		      lda	R1+1	; PID first
    232  11b3		       91 52		      sta	(R0),y
    233  11b5		       88		      dey
    234  11b6		       a5 54		      lda	R1
    235  11b8		       91 52		      sta	(R0),y
    236  11ba		       60		      rts
    237  11bb
    238  11bb
    239  11bb
    240  11bb
    241  11bb
    242  11bb
    243  11bb
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  11bb					      include	"support.asm"
      1  11bb							;
      2  11bb							;=====================================================
      3  11bb							;=====================================================
      4  11bb							;=====================================================
      5  11bb							; This marks the start of support functions used by
      6  11bb							; the IL opcodes.  These are support functions, NOT
      7  11bb							; the IL code.
      8  11bb							;=====================================================
      9  11bb							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  11bb							;=====================================================
     11  11bb					      Seg	Code
     12  11bb							;=====================================================
     13  11bb							; This gets the next two bytes pointed to by ILPC and
     14  11bb							; returns them; X contains LSB, A contains MSB.  ILPC
     15  11bb							; is advanced by two, and Y contains 0 on return.
     16  11bb
     17  11bb							;
     18  11bb		       20 bf 11    getILWord  jsr	getILByte	;LSB
     19  11be		       aa		      tax
     20  11bf							;
     21  11bf							;=====================================================
     22  11bf							; This gets the next byte pointed to by ILPC and
     23  11bf							; returns it in A.  On return, X is unchanged but Y
     24  11bf							; contains 0.
     25  11bf							;
     26  11bf		       a0 00	   getILByte  ldy	#0
     27  11c1		       b1 43		      lda	(ILPC),y	;get byte
     28  11c3		       08		      php		;save status
     29  11c4		       e6 43		      inc	ILPC	;inc LSB
     30  11c6		       d0 02		      bne	getILb2	;branch if no overflow
     31  11c8		       e6 44		      inc	ILPC+1	;inc MSB
     32  11ca		       28	   getILb2    plp		;restore status
     33  11cb		       60		      rts
     34  11cc							;
     35  11cc							;=====================================================
     36  11cc							; Decrement ILPC by one.
     37  11cc							;
     38  11cc		       a5 43	   decIL      lda	ILPC
     39  11ce		       d0 02		      bne	decIL2
     40  11d0		       c6 44		      dec	ILPC+1
     41  11d2		       c6 43	   decIL2     dec	ILPC
     42  11d4		       60		      rts
     43  11d5							;
     44  11d5							;=====================================================
     45  11d5							; Push the ILPC onto the return stack.  Actually, this
     46  11d5							; pushes the address of ILPC+2 since that's the next
     47  11d5							; address to execute.
     48  11d5							;
     49  11d5		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  11d7		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  11d9		       b0 15		      bcs	pushErr
     52  11db		       a5 43		      lda	ILPC
     53  11dd		       18		      clc
     54  11de		       69 02		      adc	#2
     55  11e0		       91 45		      sta	(ILSTACK),y
     56  11e2		       08		      php		;save C bit
     57  11e3		       c8		      iny
     58  11e4		       a5 44		      lda	ILPC+1
     59  11e6		       28		      plp		;restore C
     60  11e7		       69 00		      adc	#0
     61  11e9		       91 45		      sta	(ILSTACK),y
     62  11eb		       c8		      iny
     63  11ec		       84 47		      sty	ILSTACKPTR
     64  11ee		       18		      clc
     65  11ef		       60		      rts
     66  11f0				   pushErr
     67  11f0		       38		      sec
     68  11f1		       60		      rts
     69  11f2							;
     70  11f2							;=====================================================
     71  11f2							; Pull the top entry from return stack and put into
     72  11f2							; ILPC.
     73  11f2							;
     74  11f2		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  11f4		       f0 fa		      beq	pushErr
     76  11f6		       88		      dey
     77  11f7		       b1 45		      lda	(ILSTACK),y
     78  11f9		       85 44		      sta	ILPC+1
     79  11fb		       88		      dey
     80  11fc		       b1 45		      lda	(ILSTACK),y
     81  11fe		       85 43		      sta	ILPC
     82  1200		       84 47		      sty	ILSTACKPTR
     83  1202		       18		      clc
     84  1203		       60		      rts
     85  1204							;
     86  1204							;=====================================================
     87  1204							; This searches for a specific line number that is in
     88  1204							; R0.	There are three possible return conditions:
     89  1204							; Line numbers are now the third byte, the first byte is now **************
     90  1204							; a pointer to the next line, of course no longer that 53 byte
     91  1204							; per line.
     92  1204							;
     93  1204							; Exact match was found:
     94  1204							;    * Z set
     95  1204							;    * CURPTR points to two-byte line number for that
     96  1204							;	line.
     97  1204							;
     98  1204							; Next highest line found:
     99  1204							;    * Z cleared
    100  1204							;    * C set
    101  1204							;    * CURPTR points to two-byte line number for that
    102  1204							;	line.
    103  1204							;
    104  1204							; End of program reached:
    105  1204							;    * Z cleared
    106  1204							;    * C cleared
    107  1204							;    * CURPTR points to first free byte at end of
    108  1204							;	program.  Ie, it has save value as PROGRAMEND.
    109  1204							;
    110  1204							; A, X, and Y are all undefined on return.
    111  1204							;
    112  1204
    113  1204				   findLine
    114  1204		       ad 01 27 	      lda	ProgramStart	;Start of program -> CURPTR
    115  1207		       85 4f		      sta	CURPTR
    116  1209		       ad 02 27 	      lda	ProgramStart+1
    117  120c		       85 50		      sta	CURPTR+1
    118  120e							;
    119  120e							; At end of code?
    120  120e							;
    121  120e				   iXFER1
    122  120e		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  1210		       cd 03 27 	      cmp	ProgramEnd	; at end of program then stop run
    124  1213		       d0 0b		      bne	xfer2	; not end
    125  1215		       a5 50		      lda	CURPTR+1
    126  1217		       cd 04 27 	      cmp	ProgramEnd+1
    127  121a		       d0 04		      bne	xfer2	;Not at end
    128  121c							;
    129  121c							; Line not found and the end of the program was
    130  121c							; reached.  Return Z and C both clear.
    131  121c							;
    132  121c		       a9 01		      lda	#1	;clear Z
    133  121e		       18		      clc		;clear C
    134  121f		       60		      rts
    135  1220							;
    136  1220							; Check for an exact line number match
    137  1220							;
    138  1220		       a5 52	   xfer2      lda	R0
    139  1222		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1224		       d1 4f		      cmp	(CURPTR),y
    141  1226		       d0 08		      bne	xfernotit
    142  1228		       c8		      iny
    143  1229		       a5 53		      lda	R0+1
    144  122b		       d1 4f		      cmp	(CURPTR),y
    145  122d		       d0 01		      bne	xfernotit	; not a matching line number
    146  122f							;
    147  122f							; This is exactly the line we want.
    148  122f							;
    149  122f		       60		      rts		;it matches exactly
    150  1230							;
    151  1230							; See if this line is greater than the one we're
    152  1230							; searching for.
    153  1230							;
    154  1230		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1232		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1234		       c5 53		      cmp	R0+1
    157  1236		       90 0b		      bcc	xfer3
    158  1238		       d0 07		      bne	xfer4
    159  123a		       88		      dey
    160  123b		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  123d		       c5 52		      cmp	R0
    162  123f		       90 02		      bcc	xfer3
    163  1241							;
    164  1241							; This line is greater than the one we want, so
    165  1241							; return Z clear and C set.
    166  1241							;
    167  1241		       38	   xfer4      sec		;We found a line number greater
    168  1242		       60		      rts		;both conditions set
    169  1243							;
    170  1243							; Not the line (or droid) we're looking for.  Move to
    171  1243							; the next line.
    172  1243							;
    173  1243		       20 49 12    xfer3      jsr	FindNextLine
    174  1246		       4c 0e 12 	      jmp	iXFER1
    175  1249							;
    176  1249							;=====================================================
    177  1249							; This advances CURPTR to the next line.  If there
    178  1249							; are no more lines, this leaves CURPTR equal to
    179  1249							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1249							; CURPTR is pointing to a valid line on entry.  This
    181  1249							; pointer points to the two-byte line number.
    182  1249							; Update this points to the 1 byte line length  ****************
    183  1249							;
    184  1249				   FindNextLine
    185  1249		       a0 03		      ldy	#3	;skip line number and length byte
    186  124b		       84 51		      sty	CUROFF	;this is the new offset
    187  124d		       a0 00		      ldy	#0
    188  124f		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1251		       18		      clc
    190  1252		       65 4f		      adc	CURPTR
    191  1254		       85 4f		      sta	CURPTR
    192  1256		       a5 50		      lda	CURPTR+1
    193  1258		       69 00		      adc	#0
    194  125a		       85 50		      sta	CURPTR+1
    195  125c		       60	   FindNext4  rts
    196  125d							;
    197  125d							;=====================================================
    198  125d							; This compares CURPTR to PROGRAMEND and returns Z set
    199  125d							; if they are equal, Z clear if not.
    200  125d							;
    201  125d		       a5 4f	   AtEnd      lda	CURPTR
    202  125f		       cd 03 27 	      cmp	ProgramEnd
    203  1262		       d0 05		      bne	atendexit
    204  1264		       a5 50		      lda	CURPTR+1
    205  1266		       cd 04 27 	      cmp	ProgramEnd+1
    206  1269		       60	   atendexit  rts
    207  126a							;
    208  126a							;=====================================================
    209  126a							; Print the contents of R0 as a signed decimal number.
    210  126a							; Does leading zero suppression.
    211  126a							;
    212  126a				   PrintDecimal
    213  126a		       a5 53		      lda	R0+1	;MSB has sign
    214  126c		       10 17		      bpl	pplus	;it's a positive number
    215  126e							;
    216  126e							; Negative numbers need more work.  Invert all the bits,
    217  126e							; then add one.
    218  126e							;
    219  126e		       a9 2d		      lda	#'-
    220  1270		       20 aa 16 	      jsr	VOUTCH	;print the negative sign
    221  1273							;
    222  1273		       a5 52		      lda	R0	;invert bits
    223  1275		       49 ff		      eor	#$ff
    224  1277		       85 52		      sta	R0
    225  1279		       a5 53		      lda	R0+1
    226  127b		       49 ff		      eor	#$ff
    227  127d		       85 53		      sta	R0+1
    228  127f		       e6 52		      inc	R0	;add one
    229  1281		       d0 02		      bne	pplus
    230  1283		       e6 53		      inc	R0+1
    231  1285							;
    232  1285							; Print the value in R0 as a positive number.
    233  1285							;
    234  1285		       a2 00	   pplus      ldx	#0	;start of subtraction table
    235  1287		       8e ec 26 	      stx	diddigit	;no digits yet
    236  128a		       a0 00	   pploop     ldy	#0	;result of division
    237  128c		       a5 52	   pploop2    lda	R0	;LSB
    238  128e		       38		      sec
    239  128f		       fd ce 12 	      sbc	dectable,x
    240  1292		       85 52		      sta	R0
    241  1294		       a5 53		      lda	R0+1
    242  1296		       fd cf 12 	      sbc	dectable+1,x
    243  1299		       10 2e		      bpl	pplusok	;no underflow
    244  129b							;
    245  129b							; Else, underflow.  Add back in the LSB of the
    246  129b							; table to R0.
    247  129b							;
    248  129b		       18		      clc
    249  129c		       a5 52		      lda	R0
    250  129e		       7d ce 12 	      adc	dectable,x
    251  12a1		       85 52		      sta	R0
    252  12a3							;
    253  12a3							; Print the value in Y.  Actually, see if Y is zero and
    254  12a3							; whether any digit has been printed yet.  If Y isn't
    255  12a3							; zero or we've printed a digit, go ahead and print.
    256  12a3							;
    257  12a3		       8e e9 26 	      stx	printtx
    258  12a6		       98		      tya
    259  12a7		       09 00		      ora	#0	;set flags
    260  12a9		       d0 05		      bne	pprintit	;non-zero, print
    261  12ab							;
    262  12ab		       ad ec 26 	      lda	diddigit
    263  12ae		       f0 09		      beq	pprintno	;don't print
    264  12b0							;
    265  12b0		       98	   pprintit   tya
    266  12b1		       09 30		      ora	#'0
    267  12b3		       8d ec 26 	      sta	diddigit
    268  12b6		       20 aa 16 	      jsr	VOUTCH
    269  12b9		       ae e9 26    pprintno   ldx	printtx
    270  12bc							;
    271  12bc							; Move to the next table entry
    272  12bc							;
    273  12bc		       e8		      inx
    274  12bd		       e8		      inx
    275  12be		       e0 08		      cpx	#dectableend-dectable
    276  12c0		       d0 c8		      bne	pploop	;not at end
    277  12c2							;
    278  12c2							; At the end.	R0 contains the final value
    279  12c2							; to print.
    280  12c2							;
    281  12c2		       a5 52		      lda	R0
    282  12c4		       09 30		      ora	#'0
    283  12c6		       4c aa 16 	      jmp	VOUTCH
    284  12c9							;
    285  12c9							; Finish doing the subtraction.
    286  12c9							;
    287  12c9		       85 53	   pplusok    sta	R0+1
    288  12cb		       c8		      iny
    289  12cc		       d0 be		      bne	pploop2
    290  12ce							;
    291  12ce							; Table of powers-of-ten
    292  12ce							;
      0  12ce				   dectable   dw	10000
      1  12ce		       10 27		      .word.w	10000
      0  12d0					      dw	1000
      1  12d0		       e8 03		      .word.w	1000
      0  12d2					      dw	100
      1  12d2		       64 00		      .word.w	100
      0  12d4					      dw	10
      1  12d4		       0a 00		      .word.w	10
    297  12d4		       12 d6	   dectableend equ	*
    298  12d6							;
    299  12d6							;=====================================================
    300  12d6							; Convert an ASCII string to a number.  On input,
    301  12d6							; (CURPTR),Y points to the first digit.  This gets
    302  12d6							; digit-by-digit until finding a non-number.  Returns
    303  12d6							; Y pointing to the non-digit, and R0 contains the
    304  12d6							; number.  This does NOT check for valid ranges, so
    305  12d6							; a value like "123456789" will produce something,
    306  12d6							; but not what you had expected.
    307  12d6							;
    308  12d6		       a9 00	   getDecimal lda	#0
    309  12d8		       85 52		      sta	R0
    310  12da		       85 53		      sta	R0+1
    311  12dc		       85 59		      sta	dpl	;temporary negative flag
    312  12de							;
    313  12de							; See if it's negative...
    314  12de							;
    315  12de							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    316  12de		       b1 4f		      lda	(CURPTR),y
    317  12e0		       c9 2d		      cmp	#'-
    318  12e2		       d0 02		      bne	getDecLoop
    319  12e4		       e6 59		      inc	dpl	;it's negative
    320  12e6							;
    321  12e6		       b1 4f	   getDecLoop lda	(CURPTR),y
    322  12e8		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    323  12ea		       c9 30		      cmp	#'0
    324  12ec		       90 36		      bcc	getDdone
    325  12ee		       c9 3a		      cmp	#'9+1
    326  12f0		       b0 32		      bcs	getDdone
    327  12f2		       38		      sec
    328  12f3		       e9 30		      sbc	#'0	;convert to binary
    329  12f5		       48		      pha
    330  12f6							;
    331  12f6							; Now multiply R0 by 10.  Remember that
    332  12f6							; 2*N + 8*N = 10*N.
    333  12f6							;
    334  12f6		       06 52		      asl	R0
    335  12f8		       26 53		      rol	R0+1	;*2
    336  12fa		       a5 52		      lda	R0
    337  12fc		       85 54		      sta	R1
    338  12fe		       a5 53		      lda	R0+1
    339  1300		       85 55		      sta	R1+1
    340  1302		       06 52		      asl	R0
    341  1304		       26 53		      rol	R0+1	;*4
    342  1306		       06 52		      asl	R0
    343  1308		       26 53		      rol	R0+1	;*8
    344  130a		       18		      clc		;now add the partial sums...
    345  130b		       a5 52		      lda	R0	;...to get *10
    346  130d		       65 54		      adc	R1
    347  130f		       85 52		      sta	R0
    348  1311		       a5 53		      lda	R0+1
    349  1313		       65 55		      adc	R1+1
    350  1315		       85 53		      sta	R0+1
    351  1317							;
    352  1317							; Add in the new digit
    353  1317							;
    354  1317		       68		      pla
    355  1318		       18		      clc
    356  1319		       65 52		      adc	R0
    357  131b		       85 52		      sta	R0
    358  131d		       90 02		      bcc	getD2
    359  131f		       e6 53		      inc	R0+1
    360  1321							;
    361  1321							; Move to next character
    362  1321							;
    363  1321		       c8	   getD2      iny
    364  1322		       d0 c2		      bne	getDecLoop
    365  1324							;
    366  1324							; All done with digits, so now deal with it being
    367  1324							; negative.  If zero, then don't check for negative
    368  1324							; flag.  Ie, -0 is stored as 0.
    369  1324							;
    370  1324		       a5 52	   getDdone   lda	R0
    371  1326		       05 53		      ora	R0+1
    372  1328		       f0 16		      beq	getDone2	;zero
    373  132a		       a5 59		      lda	dpl
    374  132c		       f0 12		      beq	getDone2	;positive
    375  132e							;
    376  132e							; Invert all the bits, then add one.
    377  132e							;
    378  132e		       a5 52		      lda	R0
    379  1330		       49 ff		      eor	#$ff
    380  1332		       85 52		      sta	R0
    381  1334		       a5 53		      lda	R0+1
    382  1336		       49 ff		      eor	#$ff
    383  1338		       85 53		      sta	R0+1
    384  133a							;
    385  133a		       e6 52		      inc	R0
    386  133c		       d0 02		      bne	getDone2
    387  133e		       e6 53		      inc	R0+1
    388  1340				   getDone2
    389  1340							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    390  1340							;lda	  R0
    391  1340							;sta	  $0010
    392  1340							;lda	  R0+1
    393  1340							;sta	  $0011
    394  1340							;lda	  dpl
    395  1340							;sta	  $012
    396  1340
    397  1340		       60		      rts
    398  1341
    399  1341							;=====================================================
    400  1341							; Gets a line of input into LINBUF.
    401  1341							;
    402  1341							; On entry:
    403  1341							;    A contains the prompt character, or 0 if none.
    404  1341							;    X = 1 Background read
    405  1341							;    x = 0 Forground read with wait
    406  1341							;
    407  1341							; On exit:
    408  1341							;    CURPTR points to LINBUF
    409  1341							;    LINBUF contains the line with 0 at the end.
    410  1341							;    Y has offset to first non-space character
    411  1341							;    CURROFF has the same as Y.
    412  1341							;
    413  1341		       20 90 13    GetLine    jsr	ReadPrompt
    414  1344		       e0 00		      cpx	#0
    415  1346		       f0 14		      beq	GetLineRetry
    416  1348		       ae a8 1d 	      ldx	taskPtr
    417  134b		       bd a9 1d 	      lda	taskTable,x
    418  134e		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    419  1350		       d0 3d		      bne	taskWaitingIO
    420  1352		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    421  1354		       9d a9 1d 	      sta	taskTable,x	;Mark the state for task as waiting io
    422  1357		       ce 8f 13 	      dec	taskWaitingIO	;Start polling the input and make task wait
    423  135a		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    424  135c
    425  135c							;
    426  135c							; Now read a line and wait for the CR
    427  135c							;
    428  135c				   GetLineRetry
    429  135c		       a9 00		      lda	#0	;Wait for input to complete
    430  135e		       20 a8 13 	      jsr	ReadLine
    431  1361
    432  1361							;
    433  1361							; Point to the line we just read
    434  1361							; Set the current pointer to point to the input line
    435  1361							;
    436  1361		       a0 00	   ReadComplete ldy	#0
    437  1363		       84 51		      sty	CUROFF
    438  1365		       a2 64		      ldx	#LINBUF&$ff
    439  1367		       86 4f		      stx	CURPTR
    440  1369		       a2 26		      ldx	#LINBUF>>8
    441  136b		       86 50		      stx	CURPTR+1
    442  136d							;
    443  136d							; Output a CR/LF
    444  136d							;
    445  136d		       20 61 15 	      jsr	CRLF
    446  1370							;
    447  1370							; If a blank line, prompt again.
    448  1370							;
    449  1370		       20 58 15 	      jsr	SkipSpaces
    450  1373		       b1 4f		      lda	(CURPTR),y
    451  1375		       d0 10		      bne	GetLineDone	;We have data then exit
    452  1377		       20 93 13 	      jsr	ReadPromptRetry
    453  137a		       ae a8 1d 	      ldx	taskPtr	;if this task is waiting for IO
    454  137d		       bd a9 1d 	      lda	taskTable,x	;then get out, wait for line to
    455  1380		       29 40		      and	#TASKWAITIO	;Complete again
    456  1382		       d0 0b		      bne	taskWaitingIO
    457  1384		       4c 5c 13 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    458  1387
    459  1387				   GetLineDone
    460  1387		       ae a8 1d 	      ldx	taskPtr
    461  138a		       a9 80		      lda	#TASKACTIVE
    462  138c		       9d a9 1d 	      sta	taskTable,x	;IO is complete
    463  138f
    464  138f				   taskWaitingIO
    465  138f		       60		      rts
    466  1390
    467  1390							;
    468  1390							;=======================================================================
    469  1390							; Display the prompt character
    470  1390							; On entry
    471  1390							;	    A contains the prompt character
    472  1390							; On exit
    473  1390							;	    The readbuffer index is reset to 0
    474  1390							;
    475  1390		       8d eb 26    ReadPrompt sta	promptChar
    476  1393
    477  1393							;
    478  1393							; Prompt
    479  1393							;
    480  1393
    481  1393		       ad eb 26    ReadPromptRetry lda	promptChar
    482  1396		       09 00		      ora	#0	;any prompt?
    483  1398		       f0 08		      beq	getlinenp
    484  139a		       20 aa 16 	      jsr	VOUTCH
    485  139d		       a9 20		      lda	#$20
    486  139f		       20 aa 16 	      jsr	VOUTCH	;Space after prompt
    487  13a2							;
    488  13a2		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    489  13a4		       8e e8 26 	      stx	getlinx
    490  13a7		       60		      rts
    491  13a8							;
    492  13a8							;===============================================================
    493  13a8							; This fuction is the driver for the line input
    494  13a8							; on call if a = 0 then it waits for all input
    495  13a8							;	      a = 1 then nowait for input
    496  13a8							; On exit
    497  13a8							;		       c clear if not complete line
    498  13a8							;		       c set if it was a complete line
    499  13a8
    500  13a8				   ReadLine
    501  13a8		       8d ea 26 	      sta	inputNoWait
    502  13ab		       c9 00		      cmp	#0
    503  13ad		       f0 05		      beq	getline1
    504  13af		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    505  13b2		       f0 2b		      beq	GetLineNoWait
    506  13b4		       20 ad 16    getline1   jsr	VGETCH
    507  13b7					      if	CTMON65
    508  13b7		       48		      pha
    509  13b8		       20 aa 16 	      jsr	VOUTCH	;echo echo echo
    510  13bb		       68		      pla
    511  13bc					      endif
    512  13bc		       c9 0d		      cmp	#CR
    513  13be		       f0 15		      beq	getlind	;end of line
    514  13c0		       c9 08		      cmp	#BS	;backspace?
    515  13c2		       f0 1d		      beq	getlinebs
    516  13c4		       ae e8 26 	      ldx	getlinx
    517  13c7		       9d 64 26 	      sta	LINBUF,x
    518  13ca		       e8		      inx
    519  13cb		       8e e8 26 	      stx	getlinx
    520  13ce		       ad ea 26 	      lda	inputNoWait
    521  13d1		       f0 e1		      beq	getline1
    522  13d3		       d0 0a		      bne	GetLineNoWait
    523  13d5							;
    524  13d5							; CR was hit
    525  13d5							;
    526  13d5		       a9 00	   getlind    lda	#0	; set the end pf buffer
    527  13d7		       ae e8 26 	      ldx	getlinx
    528  13da		       9d 64 26 	      sta	LINBUF,x
    529  13dd
    530  13dd		       38		      sec		; Carry set then cr received
    531  13de		       60		      rts
    532  13df
    533  13df				   GetLineNoWait
    534  13df		       18		      clc		; Carry clear no end of line
    535  13e0		       60		      rts
    536  13e1							;
    537  13e1							; Backspace was hit
    538  13e1							;
    539  13e1		       ae e8 26    getlinebs  ldx	getlinx
    540  13e4		       f0 0e		      beq	getlineEOL	;at start of line
    541  13e6		       ca		      dex
    542  13e7		       8e e8 26 	      stx	getlinx
    543  13ea		       20 b0 16    getlinepbs jsr	puts
      0  13ed					      db	27,"[K",0
      1  13ed		       1b 5b 4b 00	      .byte.b	27,"[K",0
    545  13f1		       4c b4 13 	      jmp	getline1
    546  13f4		       a9 20	   getlineEOL lda	#SPACE
    547  13f6		       20 aa 16 	      jsr	VOUTCH
    548  13f9		       d0 ef		      bne	getlinepbs
    549  13fb							;
    550  13fb							;=====================================================
    551  13fb							; Count the length of the line currently in LINBUF
    552  13fb							; starting at offset Y.  Returns the length in X.  The
    553  13fb							; starting offset in Y should point past the ASCII
    554  13fb							; line number.  Also counts the trailing NULL and two
    555  13fb							; extra bytes for where the line number will be.
    556  13fb							; Update must now include leading length byte not the null at end ****************
    557  13fb							;
    558  13fb				   getLineLength
    559  13fb		       a2 00		      ldx	#0	;size
    560  13fd		       b9 64 26    getLineL2  lda	LINBUF,y
    561  1400		       f0 04		      beq	getLineL3
    562  1402		       c8		      iny
    563  1403		       e8		      inx
    564  1404		       d0 f7		      bne	getLineL2
    565  1406		       e8	   getLineL3  inx		;count null at end
    566  1407		       e8		      inx		;line number LSB
    567  1408		       e8		      inx		;MSB
    568  1409		       e8		      inx		;change: count new leading line length
    569  140a		       8e fe 26 	      stx	lineLength
    570  140d		       60		      rts
    571  140e							;
    572  140e							;=====================================================
    573  140e							; Count the length of the line pointed to by CURPTR.
    574  140e							; This also counts the line number and the terminating
    575  140e							; null.  Ie, this string returns 8:
    576  140e							;
    577  140e							; <lineLow><lineHi>Hello<null>
    578  140e							;
    579  140e							; Another way of looking at it: add the return value
    580  140e							; to the CURPTR and it'll point to the next line's
    581  140e							; line number.  Returns the value in Y.
    582  140e							; Update to ject get the leading byte length ********************
    583  140e							;
    584  140e							;getCURPTRLength
    585  140e							;		ldy	CURPTR
    586  140e							;		ldy	#3	;change: skip line number and leading length byte
    587  140e							;getCLineL2	lda	(CURPTR),y
    588  140e							;		beq	getCLineL3
    589  140e							;		iny
    590  140e							;		bne	getCLineL2
    591  140e							;getCLineL3	iny		;count null at end
    592  140e							;		rts
    593  140e
    594  140e							;
    595  140e							;=====================================================
    596  140e							; This saves ILPC.  This saves to a single save area,
    597  140e							; so it can't be called more than once.
    598  140e							;
    599  140e		       a5 43	   saveIL     lda	ILPC
    600  1410		       8d fa 26 	      sta	tempIL
    601  1413		       a5 44		      lda	ILPC+1
    602  1415		       8d fb 26 	      sta	tempIL+1
    603  1418		       60		      rts
    604  1419							;
    605  1419							;=====================================================
    606  1419							; This restores ILPC.
    607  1419							;
    608  1419		       ad fa 26    restoreIL  lda	tempIL
    609  141c		       85 43		      sta	ILPC
    610  141e		       ad fb 26 	      lda	tempIL+1
    611  1421		       85 44		      sta	ILPC+1
    612  1423		       60		      rts
    613  1424							;
    614  1424							;=====================================================
    615  1424							; This pushes R0 onto the stack.
    616  1424							;
    617  1424		       8c f1 26    pushR0     sty	rtemp1
    618  1427		       a4 4a		      ldy	MATHSTACKPTR
    619  1429		       c0 28		      cpy	#MATHSTACKSIZE<<1
    620  142b		       b0 34		      bcs	pusherr
    621  142d		       a5 52		      lda	R0
    622  142f		       91 48		      sta	(MATHSTACK),y
    623  1431		       c8		      iny
    624  1432		       a5 53		      lda	R0+1
    625  1434		       91 48		      sta	(MATHSTACK),y
    626  1436		       c8		      iny
    627  1437		       84 4a		      sty	MATHSTACKPTR
    628  1439		       ac f1 26 	      ldy	rtemp1
    629  143c		       18		      clc
    630  143d		       60		      rts
    631  143e
    632  143e							;=====================================================
    633  143e							; This pushes curptr basic current line onto the call stack.
    634  143e							; and CUROFF. Also marks entry type as 1 = GOSUB
    635  143e
    636  143e				   pushLN
    637  143e		       8c f1 26 	      sty	rtemp1
    638  1441		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    639  1443		       c5 4d		      cmp	GOSUBSTACKPTR
    640  1445		       90 1a		      bcc	pusherr	; No error
    641  1447		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    642  1449		       a2 00		      ldx	#0	; Start of bytes to copy
    643  144b				   pushLoop
    644  144b		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    645  144d		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    646  144f		       c8		      iny		; Next destination
    647  1450		       e8		      inx		; Next Source byte
    648  1451		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    649  1453		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    650  1455
    651  1455		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    652  1457		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    653  1459		       c8		      iny		; Next entry
    654  145a
    655  145a		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    656  145c		       ac f1 26 	      ldy	rtemp1
    657  145f		       18		      clc
    658  1460		       60		      rts
    659  1461				   pusherr
    660  1461		       38		      sec
    661  1462		       60		      rts
    662  1463							;=====================================================
    663  1463							; This pops Top Off gosub call Stack and
    664  1463							; places it in CURPTR/CUROFF.
    665  1463							; This checks if the type = 1 GOSUB
    666  1463							; if not it removes what ever is on the stack
    667  1463							; until it finds the next return. Allowing
    668  1463							; a return from within a for/next
    669  1463		       8c f1 26    popLN      sty	rtemp1
    670  1466		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    671  1468		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    672  146a
    673  146a				   popContinue
    674  146a		       c0 04		      cpy	#4	; if less than 4 on stack then error
    675  146c		       90 18		      bcc	poperr	; Process an error
    676  146e
    677  146e		       88		      dey		; Position to read entry type
    678  146f		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    679  1471		       c9 01		      cmp	#1	; Type is a gosub entry
    680  1473		       d0 13		      bne	popSkipEntry	; No then just skip this
    681  1475
    682  1475				   popLoop
    683  1475		       88		      dey
    684  1476		       ca		      dex
    685  1477		       b1 4b		      lda	(GOSUBSTACK),y
    686  1479		       95 4f		      sta	CURPTR,x
    687  147b		       e0 00		      cpx	#0
    688  147d		       d0 f6		      bne	popLoop	; Loop until all moved
    689  147f
    690  147f
    691  147f		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    692  1481		       ac f1 26 	      ldy	rtemp1
    693  1484		       18		      clc
    694  1485		       60		      rts
    695  1486
    696  1486		       38	   poperr     sec
    697  1487		       60		      rts
    698  1488
    699  1488		       88	   popSkipEntry dey
    700  1489		       88		      dey
    701  148a		       88		      dey
    702  148b		       4c 6a 14 	      jmp	popContinue
    703  148e
    704  148e							;
    705  148e							;=====================================================
    706  148e							; This pushes R1 onto the stack
    707  148e							;
    708  148e		       8c f1 26    pushR1     sty	rtemp1
    709  1491		       a4 4a		      ldy	MATHSTACKPTR
    710  1493		       c0 28		      cpy	#MATHSTACKSIZE<<1
    711  1495		       b0 ef		      bcs	poperr
    712  1497		       a5 54		      lda	R1
    713  1499		       91 48		      sta	(MATHSTACK),y
    714  149b		       c8		      iny
    715  149c		       a5 55		      lda	R1+1
    716  149e		       91 48		      sta	(MATHSTACK),y
    717  14a0		       c8		      iny
    718  14a1		       84 4a		      sty	MATHSTACKPTR
    719  14a3		       ac f1 26 	      ldy	rtemp1
    720  14a6		       18		      clc
    721  14a7		       60		      rts
    722  14a8							;
    723  14a8							;=====================================================
    724  14a8							; This pops Top Of Stack and places it in R0.
    725  14a8							;
    726  14a8		       8c f1 26    popR0      sty	rtemp1
    727  14ab		       a4 4a		      ldy	MATHSTACKPTR
    728  14ad		       f0 d7		      beq	poperr
    729  14af		       88		      dey
    730  14b0		       b1 48		      lda	(MATHSTACK),y
    731  14b2		       85 53		      sta	R0+1
    732  14b4		       88		      dey
    733  14b5		       b1 48		      lda	(MATHSTACK),y
    734  14b7		       85 52		      sta	R0
    735  14b9		       84 4a		      sty	MATHSTACKPTR
    736  14bb		       ac f1 26 	      ldy	rtemp1
    737  14be		       18		      clc
    738  14bf		       60		      rts
    739  14c0
    740  14c0							;
    741  14c0							;=====================================================
    742  14c0							; This pops TOS and places it in R1.
    743  14c0							;
    744  14c0		       8c f1 26    popR1      sty	rtemp1
    745  14c3		       a4 4a		      ldy	MATHSTACKPTR
    746  14c5		       f0 bf		      beq	poperr
    747  14c7		       88		      dey
    748  14c8		       b1 48		      lda	(MATHSTACK),y
    749  14ca		       85 55		      sta	R1+1
    750  14cc		       88		      dey
    751  14cd		       b1 48		      lda	(MATHSTACK),y
    752  14cf		       85 54		      sta	R1
    753  14d1		       84 4a		      sty	MATHSTACKPTR
    754  14d3		       ac f1 26 	      ldy	rtemp1
    755  14d6		       60		      rts
    756  14d7							;
    757  14d7							;=====================================================
    758  14d7							; This pops TOS and places it in MQ.
    759  14d7							;
    760  14d7		       8c f1 26    popMQ      sty	rtemp1
    761  14da		       a4 4a		      ldy	MATHSTACKPTR
    762  14dc		       f0 a8		      beq	poperr
    763  14de		       88		      dey
    764  14df		       b1 48		      lda	(MATHSTACK),y
    765  14e1		       85 57		      sta	MQ+1
    766  14e3		       88		      dey
    767  14e4		       b1 48		      lda	(MATHSTACK),y
    768  14e6		       85 56		      sta	MQ
    769  14e8		       84 4a		      sty	MATHSTACKPTR
    770  14ea		       ac f1 26 	      ldy	rtemp1
    771  14ed		       60		      rts
    772  14ee							;
    773  14ee							;=====================================================
    774  14ee							; This assists with multiplication and division by
    775  14ee							; looking at R0 and R1 and saving a flag as to what
    776  14ee							; sign the result will be.  Math is always done on
    777  14ee							; positive numbers, so this converts negative numbers
    778  14ee							; into positives.  On exit, R0 and R1 are both
    779  14ee							; positive.  If the signs were different then 'signs'
    780  14ee							; will be non-zero.
    781  14ee							;
    782  14ee		       a9 00	   SaveSigns  lda	#0
    783  14f0		       8d f0 26 	      sta	sign	;assume positive
    784  14f3		       a5 53		      lda	R0+1	;MSB
    785  14f5		       10 13		      bpl	SaveSigns1
    786  14f7		       ee f0 26 	      inc	sign	;it's negative
    787  14fa		       49 ff		      eor	#$ff	;flip bits
    788  14fc		       85 53		      sta	R0+1
    789  14fe		       a5 52		      lda	R0
    790  1500		       49 ff		      eor	#$ff
    791  1502		       85 52		      sta	R0
    792  1504		       e6 52		      inc	R0
    793  1506		       d0 02		      bne	SaveSigns1
    794  1508		       e6 53		      inc	R0+1
    795  150a		       a5 55	   SaveSigns1 lda	R1+1
    796  150c		       10 1a		      bpl	SaveSigns2
    797  150e		       48		      pha
    798  150f		       ad f0 26 	      lda	sign
    799  1512		       49 01		      eor	#1
    800  1514		       8d f0 26 	      sta	sign
    801  1517		       68		      pla
    802  1518		       49 ff		      eor	#$ff	;flip bits
    803  151a		       85 55		      sta	R1+1
    804  151c		       a5 54		      lda	R1
    805  151e		       49 ff		      eor	#$ff
    806  1520		       85 54		      sta	R1
    807  1522		       e6 54		      inc	R1
    808  1524		       d0 02		      bne	SaveSigns2
    809  1526		       e6 55		      inc	R1+1
    810  1528		       60	   SaveSigns2 rts
    811  1529							;
    812  1529							;=====================================================
    813  1529							; This looks at the value of 'signs' and will convert
    814  1529							; both R0 and R1 to negative if set.
    815  1529							;
    816  1529				   RestoreSigns
    817  1529		       ad f0 26 	      lda	sign
    818  152c		       f0 28		      beq	restoresigns2
    819  152e							;
    820  152e		       a5 52		      lda	R0
    821  1530		       d0 02		      bne	restoresigns3
    822  1532		       c6 53		      dec	R0+1
    823  1534				   restoresigns3
    824  1534		       c6 52		      dec	R0
    825  1536		       a5 52		      lda	R0
    826  1538		       49 ff		      eor	#$ff
    827  153a		       85 52		      sta	R0
    828  153c		       a5 53		      lda	R0+1
    829  153e		       49 ff		      eor	#$ff
    830  1540		       85 53		      sta	R0+1
    831  1542							;
    832  1542		       a5 54		      lda	R1
    833  1544		       d0 02		      bne	restoresigns4
    834  1546		       c6 55		      dec	R1+1
    835  1548				   restoresigns4
    836  1548		       c6 54		      dec	R1
    837  154a		       a5 54		      lda	R1
    838  154c		       49 ff		      eor	#$ff
    839  154e		       85 54		      sta	R1
    840  1550		       a5 55		      lda	R1+1
    841  1552		       49 ff		      eor	#$ff
    842  1554		       85 55		      sta	R1+1
    843  1556							;
    844  1556				   restoresigns2
    845  1556		       60		      rts
    846  1557							;
    847  1557							;=====================================================
    848  1557							; Skip over spaces.  Returns Y with the offset to
    849  1557							; either the last character in the line, or the first
    850  1557							; non-space character.
    851  1557							;
    852  1557
    853  1557		       c8	   skipsp2    iny
    854  1558		       b1 4f	   SkipSpaces lda	(CURPTR),y
    855  155a		       f0 04		      beq	Skip3	;end of line
    856  155c		       c9 20		      cmp	#SPACE
    857  155e		       f0 f7		      beq	skipsp2
    858  1560		       60	   Skip3      rts
    859  1561							;*********************************************************
    860  1561							; Output a CR/LF combination to the console.  Preserves
    861  1561							; all registers.
    862  1561							;
    863  1561		       48	   tbcrlf     pha
    864  1562		       a9 0d		      lda	#CR
    865  1564		       20 aa 16 	      jsr	VOUTCH
    866  1567		       a9 0a		      lda	#LF
    867  1569		       20 aa 16 	      jsr	VOUTCH
    868  156c		       68		      pla
    869  156d		       60		      rts
    870  156e							;
    871  156e							;=====================================================
    872  156e							; Some logic to print the Line of basic code being executed
    873  156e		       24 40	   idbgBasic  bit	ILTrace
    874  1570		       50 70		      bvc	dbgBasicNone
    875  1572		       98		      tya
    876  1573		       48		      pha
    877  1574		       20 50 17 	      jsr	SetOutDebug
    878  1577		       20 d3 16 	      jsr	PrtPrgLine
    879  157a		       20 61 15 	      jsr	CRLF
    880  157d		       a5 40		      lda	ILTrace
    881  157f		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    882  1581		       f0 5a		      beq	dbgBasicDone
    883  1583		       20 5b 17 	      jsr	SetInDebug
    884  1586		       20 b0 16 	      jsr	puts
      0  1589					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1589		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    886  15c6				   dbgBasicLoop
    887  15c6		       20 ad 16 	      jsr	VGETCH
    888  15c9		       20 61 15 	      jsr	CRLF
    889  15cc		       20 9d 16 	      jsr	SetInConsole
    890  15cf
    891  15cf		       c9 73		      cmp	#'s	; Quit program
    892  15d1		       f0 12		      beq	dbgBasicStop
    893  15d3
    894  15d3		       c9 64		      cmp	#'d	; Display Variables
    895  15d5		       d0 06		      bne	dbgBasicDone
    896  15d7
    897  15d7		       20 7f 17 	      jsr	PrintAllVars
    898  15da		       18		      clc
    899  15db		       90 e9		      bcc	dbgBasicLoop	; Next char
    900  15dd
    901  15dd		       20 90 16    dbgBasicDone jsr	SetOutConsole
    902  15e0		       68		      pla
    903  15e1		       a8		      tay
    904  15e2		       4c bb 02    dbgBasicNone jmp	NextIL
    905  15e5
    906  15e5				   dbgBasicStop
    907  15e5		       20 90 16 	      jsr	SetOutConsole
    908  15e8		       68		      pla
    909  15e9		       a8		      tay
    910  15ea		       4c 01 06 	      jmp	iFIN
    911  15ed							;
    912  15ed							;=====================================================
    913  15ed							; This is some debug logic which displays the current
    914  15ed							; value of the ILPC and the line buffer.
    915  15ed							;
    916  15ed		       24 40	   dbgLine    bit	ILTrace
    917  15ef		       30 01		      bmi	dbgPrt
    918  15f1		       60		      rts
    919  15f2				   dbgPrt
    920  15f2		       20 50 17 	      jsr	SetOutDebug
    921  15f5		       20 b0 16 	      jsr	puts
      0  15f8					      db	"ILPC: ",0
      1  15f8		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    923  15ff		       a5 44		      lda	ILPC+1
    924  1601		       20 09 17 	      jsr	OUTHEX
    925  1604		       a5 43		      lda	ILPC
    926  1606		       20 09 17 	      jsr	OUTHEX
    927  1609		       a9 20		      lda	#SPACE
    928  160b		       20 aa 16 	      jsr	VOUTCH
    929  160e		       a0 00		      ldy	#0
    930  1610		       b1 43		      lda	(ILPC),y
    931  1612		       20 09 17 	      jsr	OUTHEX
    932  1615							;
    933  1615							; Display the CURPTR value and offset
    934  1615							;
    935  1615		       20 b0 16 	      jsr	puts
      0  1618					      db	", CURPTR: ",0
      1  1618		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    937  1623		       a5 50		      lda	CURPTR+1
    938  1625		       20 09 17 	      jsr	OUTHEX
    939  1628		       a5 4f		      lda	CURPTR
    940  162a		       20 09 17 	      jsr	OUTHEX
    941  162d		       a9 2b		      lda	#'+
    942  162f		       20 aa 16 	      jsr	VOUTCH
    943  1632		       a5 51		      lda	CUROFF
    944  1634		       20 09 17 	      jsr	OUTHEX
    945  1637							;
    946  1637		       20 61 15 	      jsr	CRLF
    947  163a		       20 90 16 	      jsr	SetOutConsole
    948  163d		       20 70 16 	      jsr	ILChkRange
    949  1640		       b0 02		      bcs	dbgLineErr
    950  1642		       18		      clc
    951  1643		       60		      rts
    952  1644
    953  1644				   dbgLineErr
    954  1644		       20 50 17 	      jsr	SetOutDebug
    955  1647		       20 b0 16 	      jsr	puts
      0  164a					      db	"Outside Valid IL Address Range",CR,LF,0
      1  164a		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    957  166b		       20 90 16 	      jsr	SetOutConsole
    958  166e		       38		      sec
    959  166f		       60		      rts
    960  1670
    961  1670		       a5 44	   ILChkRange lda	ILPC+1
    962  1672		       c9 18		      cmp	#IL>>8
    963  1674		       90 18		      bcc	ILBadRange
    964  1676		       d0 06		      bne	ILChkHigh
    965  1678
    966  1678		       a5 43		      lda	ILPC
    967  167a		       c9 d7		      cmp	#IL&$ff
    968  167c		       90 10		      bcc	ILBadRange
    969  167e
    970  167e		       a5 44	   ILChkHigh  lda	ILPC+1
    971  1680		       c9 1d		      cmp	#ILEND>>8
    972  1682		       90 08		      bcc	ILGoodRange
    973  1684		       d0 08		      bne	ILBadRange
    974  1686
    975  1686		       a5 43		      lda	ILPC
    976  1688		       c9 93		      cmp	#ILEND&$ff
    977  168a		       b0 02		      bcs	ILBadRange
    978  168c
    979  168c		       18	   ILGoodRange clc
    980  168d		       60		      rts
    981  168e				   ILBadRange
    982  168e		       38		      sec
    983  168f		       60		      rts
    984  1690
    985  1690
    986  1690							;=====================================================
    987  1690							; Set output vector to the console output function
    988  1690							;
    989  1690				   SetOutConsole
    990  1690		       48		      pha
    991  1691		       a9 0c		      lda	#OUTCH&$ff
    992  1693		       8d f5 26 	      sta	BOutVec
    993  1696		       a9 f0		      lda	#OUTCH>>8
    994  1698		       8d f6 26 	      sta	BOutVec+1
    995  169b		       68		      pla
    996  169c		       60		      rts
    997  169d
    998  169d				   SetInConsole
    999  169d		       48		      pha
   1000  169e		       a9 09		      lda	#GETCH&$ff
   1001  16a0		       8d f7 26 	      sta	BInVec
   1002  16a3		       a9 f0		      lda	#GETCH>>8
   1003  16a5		       8d f8 26 	      sta	BInVec+1
   1004  16a8		       68		      pla
   1005  16a9		       60		      rts
   1006  16aa
   1007  16aa							;=====================================================
   1008  16aa							; Jump to the output/input function in BOutVec/BInVec
   1009  16aa							;
   1010  16aa		       6c f5 26    VOUTCH     jmp	(BOutVec)
   1011  16ad		       6c f7 26    VGETCH     jmp	(BInVec)
   1012  16b0							;
   1013  16b0							;=====================================================
   1014  16b0							; Print the string that immediately follows the JSR to
   1015  16b0							; this function.  Stops when a null byte is found,
   1016  16b0							; then returns to the instruction immediately
   1017  16b0							; following the null.
   1018  16b0							;
   1019  16b0							; Thanks to Ross Archer for this code.
   1020  16b0							; http://www.6502.org/source/io/primm.htm
   1021  16b0							;
   1022  16b0
   1023  16b0		       68	   tbputs     pla		;Get the low part of "return" address
   1024  16b1							;(data start address)
   1025  16b1		       85 5e		      sta	PrtFrom
   1026  16b3		       68		      pla
   1027  16b4		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
   1028  16b6							;(data start address)
   1029  16b6							;Note: actually we're pointing one short
   1030  16b6		       a0 01	   PSINB      ldy	#1
   1031  16b8		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
   1032  16ba		       e6 5e		      inc	PrtFrom	;update the pointer
   1033  16bc		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
   1034  16be		       e6 5f		      inc	PrtFrom+1	;account for page crossing
   1035  16c0		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
   1036  16c2							;   Accumulator
   1037  16c2		       f0 06		      beq	PSIX1	;don't print the final NULL
   1038  16c4		       20 aa 16 	      jsr	VOUTCH	;write it out
   1039  16c7		       4c b6 16 	      jmp	PSINB	;back around
   1040  16ca		       e6 5e	   PSIX1      inc	PrtFrom
   1041  16cc		       d0 02		      bne	PSIX2
   1042  16ce		       e6 5f		      inc	PrtFrom+1	;account for page crossing
   1043  16d0		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
   1044  16d3
   1045  16d3							;
   1046  16d3
   1047  16d3							;====================================================
   1048  16d3		       26 f9	   PrtTerm    equ	tempy
   1049  16d3
   1050  16d3							; on exit Print Y has the offset to use
   1051  16d3							; input y =	 addr low
   1052  16d3							;	 x =	 addr high
   1053  16d3							;	 a =	 termination string
   1054  16d3
   1055  16d3				   PrtPrgLine
   1056  16d3		       a9 00		      lda	#0
   1057  16d5		       8d f9 26 	      sta	PrtTerm
   1058  16d8		       f0 05		      beq	PrtPrgText
   1059  16da
   1060  16da		       a9 22	   PrtQuoted  lda	#'"
   1061  16dc		       8d f9 26 	      sta	PrtTerm
   1062  16df
   1063  16df		       a4 51	   PrtPrgText ldy	CUROFF
   1064  16e1		       a5 4f		      lda	CURPTR
   1065  16e3		       85 5e		      sta	PrtFrom
   1066  16e5		       a5 50		      lda	CURPTR+1
   1067  16e7		       85 5f		      sta	PrtFrom+1
   1068  16e9		       4c f5 16 	      jmp	PrtLoop
   1069  16ec
   1070  16ec							; Print a string pointed to by x= h, y=l terminated by a
   1071  16ec							; Return y as the length
   1072  16ec
   1073  16ec		       86 5f	   PrtStr     stx	PrtFrom+1
   1074  16ee		       84 5e		      sty	PrtFrom
   1075  16f0		       8d f9 26 	      sta	PrtTerm
   1076  16f3		       a0 00		      ldy	#0
   1077  16f5							;
   1078  16f5							; On entry here ptrfrom and prtterm point to area to print
   1079  16f5							;
   1080  16f5		       b1 5e	   PrtLoop    lda	(PrtFrom),y
   1081  16f7		       cd f9 26 	      cmp	PrtTerm
   1082  16fa		       f0 0b		      beq	PrtEnd
   1083  16fc		       c9 00		      cmp	#0	; always end if 0 is found
   1084  16fe		       f0 07		      beq	PrtEnd
   1085  1700		       20 aa 16 	      jsr	VOUTCH
   1086  1703		       c8		      iny
   1087  1704		       4c f5 16 	      jmp	PrtLoop
   1088  1707		       c8	   PrtEnd     iny		;return byte after the copy
   1089  1708		       60		      rts
   1090  1709							;=====================================================
   1091  1709							; Print character in A as two hex digits to the
   1092  1709							; current output device (console or file).
   1093  1709							;
   1094  1709		       48	   HexToOut   pha		;save return value
   1095  170a		       48		      pha
   1096  170b		       4a		      lsr		;a  ;move top nibble to bottom
   1097  170c		       4a		      lsr		;a
   1098  170d		       4a		      lsr		;a
   1099  170e		       4a		      lsr		;a
   1100  170f		       20 18 17 	      jsr	hexta	;output nibble
   1101  1712		       68		      pla
   1102  1713		       20 18 17 	      jsr	hexta
   1103  1716		       68		      pla		;restore
   1104  1717		       60		      rts
   1105  1718							;
   1106  1718		       29 0f	   hexta      and	#%0001111
   1107  171a		       c9 0a		      cmp	#$0a
   1108  171c		       18		      clc
   1109  171d		       30 02		      bmi	hexta1
   1110  171f		       69 07		      adc	#7
   1111  1721		       69 30	   hexta1     adc	#'0	;then fall into...
   1112  1723		       4c aa 16 	      jmp	VOUTCH
   1113  1726							;====================================================
   1114  1726							;Clear the terminal assume it is ansii or vt100
   1115  1726							;
   1116  1726				   iCLEARSCREEN
   1117  1726		       20 b0 16 	      jsr	puts
      0  1729					      db	$1b,'[,'2,'J,0
      1  1729		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
   1119  172e		       4c bb 02 	      jmp	NextIL
   1120  1731
   1121  1731							;====================================================
   1122  1731							; Push true and false onto math stack
   1123  1731				   pushTrue
   1124  1731		       a9 ff		      lda	#$ff
   1125  1733		       85 52	   pushTF     sta	R0
   1126  1735		       85 53		      sta	R0+1
   1127  1737		       20 24 14 	      jsr	pushR0
   1128  173a		       60		      rts
   1129  173b		       a9 00	   pushFalse  lda	#0
   1130  173d		       f0 f4		      beq	pushTF
   1131  173f
   1132  173f							;======================================================
   1133  173f							; Copy stack top to R1
   1134  173f				   CopyStackR1
   1135  173f		       98		      tya
   1136  1740		       48		      pha
   1137  1741		       a4 4a		      ldy	MATHSTACKPTR
   1138  1743		       88		      dey
   1139  1744		       b1 48		      lda	(MATHSTACK),y
   1140  1746		       85 55		      sta	R1+1
   1141  1748		       88		      dey
   1142  1749		       b1 48		      lda	(MATHSTACK),y
   1143  174b		       85 54		      sta	R1
   1144  174d		       68		      pla
   1145  174e		       a8		      tay
   1146  174f		       60		      rts
   1147  1750
   1148  1750
   1149  1750							;====================================================
   1150  1750							;Swap the out debug call for standard calls
   1151  1750
   1152  1750				   SetOutDebug
   1153  1750					      if	USEDEBUGPORT
   1154  1750		       a9 70		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1155  1752		       8d f5 26 	      sta	BOutVec
   1156  1755		       a9 17		      lda	#OUTDEBUG>>8
   1157  1757		       8d f6 26 	      sta	BOutVec+1
   1158  175a					      endif
   1159  175a		       60		      rts
   1160  175b				   SetInDebug
   1161  175b					      if	USEDEBUGPORT
   1162  175b		       a9 74		      lda	#INDEBUG&$ff
   1163  175d		       8d f7 26 	      sta	BInVec
   1164  1760		       a9 17		      lda	#INDEBUG>>8
   1165  1762		       8d f8 26 	      sta	BInVec+1
   1166  1765					      endif
   1167  1765		       60		      rts
   1168  1766							;
   1169  1766							;====================================================
   1170  1766							; Output to the debug console
   1171  1766							;     x = high address byte
   1172  1766							;     y = low address byte
   1173  1766							;     a = Terminator for string
   1174  1766				   DebugWrite
   1175  1766		       20 50 17 	      jsr	SetOutDebug
   1176  1769		       20 ec 16 	      jsr	PrtStr
   1177  176c		       20 90 16 	      jsr	SetOutConsole
   1178  176f		       60		      rts
   1179  1770
   1180  1770				   OUTDEBUG
   1181  1770		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1182  1773		       60		      RTS
   1183  1774
   1184  1774		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1185  1777		       29 01		      and	#$01
   1186  1779		       f0 f9		      beq	INDEBUG
   1187  177b		       ad 21 e0 	      lda	DEBUGPORT+1
   1188  177e		       60		      rts
   1189  177f							;
   1190  177f							;=======================================================
   1191  177f							; Print all Variables
   1192  177f				   PrintAllVars
   1193  177f		       a0 00		      ldy	#0
   1194  1781		       a9 41		      lda	#'A
   1195  1783				   PrintAllVarsLoop
   1196  1783		       48		      pha
   1197  1784		       b1 41		      lda	(VARIABLES),y
   1198  1786		       85 52		      sta	R0
   1199  1788		       c8		      iny
   1200  1789		       b1 41		      lda	(VARIABLES),y
   1201  178b		       85 53		      sta	R0+1
   1202  178d
   1203  178d		       68		      pla		;get the current letter
   1204  178e		       48		      pha
   1205  178f		       20 aa 16 	      jsr	VOUTCH
   1206  1792		       20 b0 16 	      jsr	puts
      0  1795					      db	"=",0
      1  1795		       3d 00		      .byte.b	"=",0
   1208  1797		       68		      pla
   1209  1798		       aa		      tax
   1210  1799		       e8		      inx
   1211  179a		       8a		      txa
   1212  179b		       48		      pha		;
   1213  179c
   1214  179c		       98		      tya
   1215  179d		       48		      pha
   1216  179e		       20 6a 12 	      jsr	PrintDecimal
   1217  17a1		       20 b0 16 	      jsr	puts
      0  17a4					      db	" ",0
      1  17a4		       20 00		      .byte.b	" ",0
   1219  17a6		       68		      pla
   1220  17a7		       a8		      tay
   1221  17a8		       c8		      iny
   1222  17a9		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1223  17ab		       90 d6		      bcc	PrintAllVarsLoop
   1224  17ad		       20 61 15 	      jsr	CRLF
   1225  17b0
   1226  17b0		       68		      pla
   1227  17b1		       60		      rts
   1228  17b2
   1229  17b2
   1230  17b2
   1231  17b2
   1232  17b2
   1233  17b2
   1234  17b2
   1235  17b2
   1236  17b2
   1237  17b2
   1238  17b2
   1239  17b2
   1240  17b2
   1241  17b2
   1242  17b2
   1243  17b2
   1244  17b2
   1245  17b2
   1246  17b2
------- FILE mytb.asm
   2207  17b2
   2208  17b2					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  17b2					      include	"storage.asm"
      1  17b2							;
      2  17b2							;=====================================================
      3  17b2							;=====================================================
      4  17b2							;=====================================================
      5  17b2							; This file contains the functions for saving and
      6  17b2							; restoring programs from some sort of mass storage
      7  17b2							; device.  This particular version is for using the
      8  17b2							; Corsham Tech SD Card System.
      9  17b2							;=====================================================
     10  17b2							;=====================================================
     11  17b2							;=====================================================
     12  17b2
     13 U1d93					      seg.u	TBData
     14 U1d93		       00	   diskBufLength ds	1
     15 U1d94		       00	   diskBufOffset ds	1
     16 U1d95		       00 00 00 00*DiskFileName ds	14
     17 U1da3
     18  17b2					      SEG	Code
     19  17b2
     20  17b2							;
     21  17b2							;=====================================================
     22  17b2							; Open a file for reading as a program.  The next
     23  17b2							; thing on the line should be the filename.
     24  17b2							;
     25  17b2				   iOPENREAD
     26  17b2					      if	XKIM || CTMON65
     27  17b2		       a4 51		      ldy	CUROFF
     28  17b4		       b1 4f		      lda	(CURPTR),y
     29  17b6		       d0 07		      bne	iOPENfn	;might be filename
     30  17b8							;
     31  17b8							; No filename supplied.
     32  17b8							;
     33  17b8		       a9 00	   iOPENnofn  lda	#0
     34  17ba		       a2 09		      ldx	#ERR_NO_FILENAME
     35  17bc		       4c 18 06 	      jmp	iErr2
     36  17bf							;
     37  17bf							; Add the offset into the buffer start
     38  17bf							;
     39  17bf		       18	   iOPENfn    clc
     40  17c0		       98		      tya
     41  17c1		       65 4f		      adc	CURPTR
     42  17c3		       a8		      tay		;LSB
     43  17c4		       a5 50		      lda	CURPTR+1
     44  17c6		       69 00		      adc	#0
     45  17c8		       aa		      tax
     46  17c9		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  17cc		       90 07		      bcc	Ropenok	;branch if opened ok
     48  17ce							;
     49  17ce							; Open failed
     50  17ce							;
     51  17ce		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  17d0		       a9 00	   Rdfail2    lda	#0
     53  17d2		       4c 18 06 	      jmp	iErr2
     54  17d5							;
     55  17d5							; Clear counts and offsets so the next read will
     56  17d5							; cause the file to be read.
     57  17d5							;
     58  17d5		       a9 00	   Ropenok    lda	#0
     59  17d7		       8d 94 1d 	      sta	diskBufOffset
     60  17da		       8d 93 1d 	      sta	diskBufLength
     61  17dd		       4c bb 02 	      jmp	NextIL
     62  17e0					      endif
     63  17e0
     64  17e0							;
     65  17e0							;==============================JUSTLOSTINTIME 08/02/2022========
     66  17e0							;Remove a file from the disk
     67  17e0				   iRMFILE
     68  17e0					      if	XKIM || CTMON65
     69  17e0		       a4 51		      ldy	CUROFF
     70  17e2		       b1 4f		      lda	(CURPTR),y
     71  17e4		       f0 19		      beq	iRMnofn
     72  17e6							;
     73  17e6		       18		      clc
     74  17e7		       98		      tya
     75  17e8		       65 4f		      adc	CURPTR
     76  17ea		       a8		      tay		;LSB
     77  17eb		       a5 50		      lda	CURPTR+1
     78  17ed		       69 00		      adc	#0
     79  17ef		       aa		      tax
     80  17f0		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  17f3		       90 07		      bcc	wrmOk	;branch if removed ok
     82  17f5		       a9 00		      lda	#0
     83  17f7		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  17f9		       4c 18 06 	      jmp	iErr2
     85  17fc		       4c bb 02    wrmOk      jmp	NextIL
     86  17ff
     87  17ff							; No filename supplied.
     88  17ff							;
     89  17ff		       a9 00	   iRMnofn    lda	#0
     90  1801		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1803		       4c 18 06 	      jmp	iErr2
     92  1806					      endif
     93  1806							;
     94  1806							;=====================================================
     95  1806				   iOPENWRITE
     96  1806					      if	XKIM || CTMON65
     97  1806		       a4 51		      ldy	CUROFF
     98  1808		       b1 4f		      lda	(CURPTR),y
     99  180a		       f0 f3		      beq	iRMnofn
    100  180c							;
    101  180c		       18		      clc
    102  180d		       98		      tya
    103  180e		       65 4f		      adc	CURPTR
    104  1810		       a8		      tay		;LSB
    105  1811		       a5 50		      lda	CURPTR+1
    106  1813		       69 00		      adc	#0
    107  1815		       aa		      tax
    108  1816		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1819		       90 07		      bcc	Wopenok	;branch if opened ok
    110  181b							;
    111  181b							; Open failed
    112  181b							;
    113  181b		       a9 00	   Wdfail     lda	#0
    114  181d		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  181f		       4c 18 06 	      jmp	iErr2
    116  1822							;
    117  1822		       4c bb 02    Wopenok    jmp	NextIL
    118  1825					      endif
    119  1825							;
    120  1825							;=====================================================
    121  1825							; Gets a line of input from the disk file and puts it
    122  1825							; into LINBUF.
    123  1825							;
    124  1825							; On exit:
    125  1825							;    CURPTR points to LINBUF
    126  1825							;    LINBUF contains the line with 0 at the end.
    127  1825							;    Y has offset to first non-space character
    128  1825							;    CURROFF has the same as Y.
    129  1825							;
    130  1825				   iDGETLINE
    131  1825					      if	XKIM || CTMON65
    132  1825		       a2 64		      ldx	#LINBUF&$ff
    133  1827		       86 4f		      stx	CURPTR
    134  1829		       a2 26		      ldx	#LINBUF>>8
    135  182b		       86 50		      stx	CURPTR+1
    136  182d							;
    137  182d		       a2 00		      ldx	#0	;offset
    138  182f		       8e e8 26    iDgetLoop  stx	getlinx
    139  1832		       20 90 18 	      jsr	getNextFileByte
    140  1835		       b0 16		      bcs	iGetEOF
    141  1837		       c9 0d		      cmp	#CR
    142  1839		       f0 0d		      beq	iGetEOL
    143  183b		       c9 0a		      cmp	#LF
    144  183d		       f0 09		      beq	iGetEOL
    145  183f		       ae e8 26 	      ldx	getlinx
    146  1842		       9d 64 26 	      sta	LINBUF,x
    147  1845		       e8		      inx
    148  1846		       d0 e7		      bne	iDgetLoop
    149  1848							;
    150  1848							; Handle end of line.	If the line has nothing, loop
    151  1848							; back and get another line.
    152  1848							;
    153  1848		       ae e8 26    iGetEOL    ldx	getlinx	;blank line?
    154  184b		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  184d							;
    156  184d							; This can fall through when there is a line, or
    157  184d							; called directly when EOF is encountered.
    158  184d							;
    159  184d		       ae e8 26    iGetEOF    ldx	getlinx
    160  1850		       a9 00		      lda	#0
    161  1852		       9d 64 26 	      sta	LINBUF,x
    162  1855		       85 51		      sta	CUROFF
    163  1857		       a0 00		      ldy	#0
    164  1859		       20 58 15 	      jsr	SkipSpaces
    165  185c		       4c bb 02 	      jmp	NextIL
    166  185f					      endif
    167  185f
    168  185f							;
    169  185f							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  185f							; DISK
    171  185f							;
    172  185f				   iDDIR
    173  185f					      if	XKIM || CTMON65
    174  185f		       20 30 f0 	      jsr	DiskDir
    175  1862							;
    176  1862							; Get/Display each entry
    177  1862							;
    178  1862		       a2 1d	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  1864		       a0 95		      ldy	#DiskFileName&$ff
    180  1866		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  1869		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  186b		       20 b0 16 	      jsr	puts
      0  186e					      db	"   ",0
      1  186e		       20 20 20 00	      .byte.b	"   ",0
    184  1872							; Print the line to the console
    185  1872		       a2 1d		      ldx	#DiskFileName>>8	;pointer to buffer
    186  1874		       a0 95		      ldy	#DiskFileName&$ff
    187  1876		       a5 00		      lda	0
    188  1878		       20 ec 16 	      jsr	PrtStr	;else print name
    189  187b		       20 18 f0 	      jsr	crlf
    190  187e
    191  187e		       4c 62 18 	      jmp	DiskDirLoop	;do next entry
    192  1881
    193  1881		       4c bb 02    DiskDirEnd jmp	NextIL
    194  1884					      endif
    195  1884							;
    196  1884							;=====================================================
    197  1884							; Does a LIST to a Disk file.
    198  1884							;
    199  1884				   iDLIST
    200  1884					      if	XKIM || CTMON65
    201  1884		       20 bf 18 	      jsr	SetOutDisk
    202  1887		       4c e8 07 	      jmp	iLST2
    203  188a					      endif
    204  188a							;
    205  188a							;=====================================================
    206  188a							; Closes any pending disk file.  Okay to call if there
    207  188a							; is no open file.
    208  188a							;
    209  188a				   iDCLOSE
    210  188a					      if	XKIM || CTMON65
    211  188a		       20 42 f0 	      jsr	DiskClose
    212  188d		       4c bb 02 	      jmp	NextIL
    213  1890					      endif
    214  1890							;
    215  1890							;=====================================================
    216  1890							; This gets the next byte from an open disk file.  If
    217  1890							; there are no more bytes left, this returns C set.
    218  1890							; Else, C is clear and A contains the character.
    219  1890							;
    220  1890				   getNextFileByte
    221  1890					      if	XKIM || CTMON65
    222  1890		       ae 94 1d 	      ldx	diskBufOffset
    223  1893		       ec 93 1d 	      cpx	diskBufLength
    224  1896		       d0 14		      bne	hasdata	;branch if still data
    225  1898							;
    226  1898							; There is no data left in the buffer, so read a
    227  1898							; block from the SD system.
    228  1898							;
    229  1898		       a9 84		      lda	#BUFFER_SIZE
    230  189a		       a2 df		      ldx	#buffer>>8
    231  189c		       a0 0a		      ldy	#buffer&$ff
    232  189e		       20 3c f0 	      jsr	DiskRead
    233  18a1		       b0 12		      bcs	getNextEof
    234  18a3							;
    235  18a3							; A contains the number of bytes actually read.
    236  18a3							;
    237  18a3		       8d 93 1d 	      sta	diskBufLength	;save length
    238  18a6		       c9 00		      cmp	#0	;shouldn't happen
    239  18a8		       f0 0b		      beq	getNextEof
    240  18aa							;
    241  18aa		       a2 00		      ldx	#0
    242  18ac		       bd 0a df    hasdata    lda	buffer,x
    243  18af		       e8		      inx
    244  18b0		       8e 94 1d 	      stx	diskBufOffset
    245  18b3		       18		      clc
    246  18b4		       60		      rts
    247  18b5							;
    248  18b5		       a9 00	   getNextEof lda	#0
    249  18b7		       8d 94 1d 	      sta	diskBufOffset
    250  18ba		       8d 93 1d 	      sta	diskBufLength
    251  18bd		       38		      sec
    252  18be		       60		      rts
    253  18bf							;
    254  18bf							;=====================================================
    255  18bf							; Set output vector to the disk output function
    256  18bf							;
    257  18bf		       a9 ca	   SetOutDisk lda	#DOUT&$ff
    258  18c1		       8d f5 26 	      sta	BOutVec
    259  18c4		       a9 18		      lda	#DOUT/256
    260  18c6		       8d f6 26 	      sta	BOutVec+1
    261  18c9		       60		      rts
    262  18ca							;
    263  18ca							;=====================================================
    264  18ca
    265  18ca		       8d 0a df    DOUT       sta	buffer
    266  18cd		       a9 01		      lda	#1
    267  18cf		       a0 0a		      ldy	#buffer&$ff
    268  18d1		       a2 df		      ldx	#buffer>>8
    269  18d3		       20 3f f0 	      jsr	DiskWrite
    270  18d6							;
    271  18d6							; need error checking here
    272  18d6							;
    273  18d6		       60		      rts
    274  18d7					      endif
    275  18d7
    276  18d7
------- FILE mytb.asm
   2210  18d7					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  18d7					      include	"IL.inc"
      1  18d7
      2  18d7							;=====================================================
      3  18d7							; IL.inc
      4  18d7							; These are macros for IL instructions
      5  18d7							;
      6  18d7					      mac	dw
      7  18d7					      .word	{0}
      8  18d7					      endm
      9  18d7					      mac	db
     10  18d7					      .byte	{0}
     11  18d7					      endm
     12  18d7					      macro	xinit
     13  18d7					      db	0
     14  18d7					      endm		;reset the il to start clear all
     15  18d7							;
     16  18d7					      macro	done
     17  18d7					      db	1
     18  18d7					      endm		;print an error if not end of line
     19  18d7							;
     20  18d7					      macro	prs
     21  18d7					      db	2
     22  18d7					      endm		;print a quoted string
     23  18d7							;
     24  18d7					      macro	prn
     25  18d7					      db	3
     26  18d7					      endm		;print a number
     27  18d7							;
     28  18d7					      macro	spc
     29  18d7					      db	4
     30  18d7					      endm		;print space til new tabstop
     31  18d7							;
     32  18d7					      macro	nline
     33  18d7					      db	5
     34  18d7					      endm		;print a new line crlf
     35  18d7							;
     36  18d7							; My NXT is a bit different in that it takes one
     37  18d7							; parameter, which is an address.  If the BASIC
     38  18d7							; program is currently running then move to the
     39  18d7							; next line and continue execution.  However, if
     40  18d7							; in direct mode, jump to the specified IL label.
     41  18d7							;
     42  18d7					      macro	nxt
     43  18d7					      db	6
     44  18d7					      dw	{1}	; addr
     45  18d7					      endm		; addr
     46  18d7							;
     47  18d7					      macro	xfer
     48  18d7					      db	7
     49  18d7					      endm
     50  18d7							;
     51  18d7					      macro	sav
     52  18d7					      db	8
     53  18d7					      db	{1}
     54  18d7					      endm
     55  18d7							;
     56  18d7					      macro	rstr
     57  18d7					      db	9
     58  18d7					      endm
     59  18d7							;
     60  18d7					      macro	cmpr
     61  18d7					      db	10
     62  18d7					      endm
     63  18d7							;
     64  18d7					      macro	innum
     65  18d7					      db	11
     66  18d7					      endm
     67  18d7							;
     68  18d7					      macro	fin
     69  18d7					      db	12
     70  18d7					      endm
     71  18d7							;
     72  18d7							; ERR is followed by an error number.	The error
     73  18d7							; code is printed along with the line number.
     74  18d7							; Control is passed to the statement set with
     75  18d7							; the ERRGOTO statement.
     76  18d7							;
     77  18d7					      macro	errmsg
     78  18d7					      db	13
     79  18d7					      dw	{1}	;ecode
     80  18d7					      endm		;ecode
     81  18d7							;
     82  18d7					      macro	add
     83  18d7					      db	14
     84  18d7					      endm
     85  18d7							;
     86  18d7					      macro	sub
     87  18d7					      db	15
     88  18d7					      endm
     89  18d7							;
     90  18d7					      macro	neg
     91  18d7					      db	16
     92  18d7					      endm
     93  18d7							;
     94  18d7					      macro	mul
     95  18d7					      db	17
     96  18d7					      endm
     97  18d7							;
     98  18d7					      macro	div
     99  18d7					      db	18
    100  18d7					      endm
    101  18d7							;
    102  18d7					      macro	store
    103  18d7					      db	19
    104  18d7					      endm
    105  18d7							;
    106  18d7					      macro	ind
    107  18d7					      db	20
    108  18d7					      endm
    109  18d7							;
    110  18d7					      macro	lst
    111  18d7					      db	21
    112  18d7					      endm
    113  18d7							;
    114  18d7					      macro	init
    115  18d7					      db	22
    116  18d7					      endm
    117  18d7							;
    118  18d7					      macro	getline
    119  18d7					      db	23
    120  18d7					      endm
    121  18d7							;
    122  18d7					      macro	insert
    123  18d7					      db	24
    124  18d7					      endm
    125  18d7							;
    126  18d7					      macro	rtn
    127  18d7					      db	25
    128  18d7					      endm
    129  18d7							;
    130  18d7					      macro	exit
    131  18d7					      db	26
    132  18d7					      endm
    133  18d7							;
    134  18d7					      macro	lit
    135  18d7					      db	27
    136  18d7					      dw	{1}	;value
    137  18d7					      endm		; value LIT
    138  18d7							;
    139  18d7					      macro	call
    140  18d7					      db	28
    141  18d7					      dw	{1}	;addr
    142  18d7					      endm		;addr
    143  18d7							;
    144  18d7							; IJMP will set the IL PC to the specified value.
    145  18d7							;
    146  18d7					      macro	ijmp
    147  18d7					      db	29
    148  18d7					      dw	{1}	;addr
    149  18d7					      endm		;addr
    150  18d7							;
    151  18d7					      macro	vinit
    152  18d7					      db	30
    153  18d7					      endm
    154  18d7							;
    155  18d7							; ERRGOTO sets the point in the code where the IL
    156  18d7							; interpreter will go after any error.
    157  18d7							;
    158  18d7					      macro	errgoto
    159  18d7					      db	31
    160  18d7					      dw	{1}	;addr
    161  18d7					      endm		;addr
    162  18d7							;
    163  18d7					      macro	tst
    164  18d7					      db	32
    165  18d7					      db	({1}-*)-1	;(addr-*)-1
    166  18d7					      db	{2},0	;string,0
    167  18d7					      endm		;addr,string
    168  18d7							;
    169  18d7					      macro	tstv
    170  18d7					      db	33
    171  18d7					      db	({1}-*)-1	;(addr-*)-1
    172  18d7					      endm		;addr
    173  18d7							;
    174  18d7					      macro	tstl
    175  18d7					      db	34
    176  18d7					      db	({1}-*)-1	;(addr-*)-1
    177  18d7					      endm		;addr
    178  18d7							;
    179  18d7					      macro	tstn
    180  18d7					      db	35
    181  18d7					      db	({1}-*)-1	;(addr-*)-1
    182  18d7					      endm		;addr
    183  18d7							;
    184  18d7							; FREE returns the amount of free RAM on top of
    185  18d7							; the stack.  This is the amount of room the user
    186  18d7							; program has available.
    187  18d7							;
    188  18d7					      macro	free
    189  18d7					      db	36
    190  18d7					      endm
    191  18d7							;
    192  18d7							; RANDOM takes the top item off the stack and
    193  18d7							; replaces it with a random number that is
    194  18d7							; MOD the initial value.  Ie, if the TOS is
    195  18d7							; 42 then RANDOM returns a value from 0 to 41.
    196  18d7							;
    197  18d7					      macro	random
    198  18d7					      db	37
    199  18d7					      endm
    200  18d7							;
    201  18d7							; ABS will replace the top of stack with the
    202  18d7							; absolute value.
    203  18d7							;
    204  18d7					      macro	abs
    205  18d7					      db	38
    206  18d7					      endm
    207  18d7							;
    208  18d7							; OPENREAD opens a file for reading, as in getting
    209  18d7							; statements from it.
    210  18d7							;
    211  18d7					      macro	openread
    212  18d7					      db	39
    213  18d7					      endm
    214  18d7							;
    215  18d7							; OPENWRITE opens a file for writing, as in saving
    216  18d7							; the current program to it.
    217  18d7							;
    218  18d7					      macro	openwrite
    219  18d7					      db	40
    220  18d7					      endm
    221  18d7							;
    222  18d7							; DCLOSE closes any open disk file.
    223  18d7							;
    224  18d7					      macro	dclose
    225  18d7					      db	41
    226  18d7					      endm
    227  18d7							;
    228  18d7							; DGETLINE gets one line from the disk file and puts it
    229  18d7							; into LINBUFF.
    230  18d7							;
    231  18d7					      macro	dgetline
    232  18d7					      db	42
    233  18d7					      endm
    234  18d7							;
    235  18d7							; DLIST saves the program to an open disk file.
    236  18d7							;
    237  18d7					      macro	dlist
    238  18d7					      db	43
    239  18d7					      endm
    240  18d7							; DDIR list the current directory
    241  18d7							;
    242  18d7					      macro	ddir
    243  18d7					      db	44
    244  18d7					      endm
    245  18d7
    246  18d7							; RMFILE remove a fle from disk
    247  18d7					      macro	rmfile
    248  18d7					      db	45
    249  18d7					      endm
    250  18d7
    251  18d7							; CLEARSCREEN clear the screen
    252  18d7					      macro	clearscreen
    253  18d7					      db	46
    254  18d7					      endm
    255  18d7							; POKEMEM Poke value into memory
    256  18d7					      macro	pokemem
    257  18d7					      db	47
    258  18d7					      endm
    259  18d7							; PEEKMEM peek at value in memory
    260  18d7					      macro	peekmem
    261  18d7					      db	48
    262  18d7					      endm
    263  18d7							; TSTLET Test if the statement is a let without the keyword let
    264  18d7					      macro	tstlet
    265  18d7					      db	49
    266  18d7					      db	({1}-*)-1	;(addr-*)-1
    267  18d7					      endm		;addr
    268  18d7							; TSTDONE if we reach the end of a statement
    269  18d7					      macro	tstdone
    270  18d7					      db	50
    271  18d7					      db	({1}-*)-1	;(addr-*)-1
    272  18d7					      endm		;addr
    273  18d7							; GETCHAR	get a character from the input line leave it in RO
    274  18d7					      macro	getchar
    275  18d7					      db	51
    276  18d7					      endm
    277  18d7							; PUTCHAR	Put a character to the terminal
    278  18d7					      macro	putchar
    279  18d7					      db	52
    280  18d7					      endm
    281  18d7							; Call		Call a machine function return a to stack
    282  18d7					      macro	callfunc
    283  18d7					      db	53
    284  18d7					      endm
    285  18d7
    286  18d7							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  18d7					      macro	ibranch
    288  18d7					      db	54
    289  18d7					      endm
    290  18d7
    291  18d7							; TSTSTR	 Tests for the open quote in a string
    292  18d7					      macro	tststr
    293  18d7					      db	55
    294  18d7					      db	({1}-*)-1	;(addr-*)-1
    295  18d7					      endm
    296  18d7							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  18d7					      macro	setirq
    298  18d7					      db	56
    299  18d7					      endm
    300  18d7
    301  18d7							; TSTIRQ	Test for irq pending,
    302  18d7							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  18d7					      macro	tstirq
    304  18d7					      db	57
    305  18d7					      db	({1}-*)-1	;(addr-*)-1
    306  18d7					      endm
    307  18d7
    308  18d7							; IRET    return from interupt service
    309  18d7					      macro	iret
    310  18d7					      db	58
    311  18d7					      endm
    312  18d7
    313  18d7							; INSTR   read a string from the input
    314  18d7					      macro	instr
    315  18d7					      db	59
    316  18d7					      endm
    317  18d7
    318  18d7							; MODULO Returns the remainder of the division
    319  18d7					      macro	modulo
    320  18d7					      db	60
    321  18d7					      endm
    322  18d7							; Set a task line
    323  18d7					      macro	taskcreate
    324  18d7					      db	61
    325  18d7					      endm
    326  18d7							; End a task
    327  18d7					      macro	etask
    328  18d7					      db	62
    329  18d7					      endm
    330  18d7							; Skip to next task
    331  18d7					      macro	ntask
    332  18d7					      db	63
    333  18d7					      endm
    334  18d7							; Subscript
    335  18d7					      macro	subscript
    336  18d7					      db	64
    337  18d7					      endm
    338  18d7							; KILL Task
    339  18d7					      macro	taskkill
    340  18d7					      db	65
    341  18d7					      endm
    342  18d7							; STAT Task
    343  18d7					      macro	taskstat
    344  18d7					      db	66
    345  18d7					      endm
    346  18d7							;  output value as hex
    347  18d7					      macro	hexprt
    348  18d7					      db	67
    349  18d7					      endm
    350  18d7							;  Read in background has completed
    351  18d7					      macro	readcomplete
    352  18d7					      db	68
    353  18d7					      endm
    354  18d7							;  ReadInput line
    355  18d7					      macro	readstart
    356  18d7					      db	69
    357  18d7					      endm
    358  18d7							; Startio request
    359  18d7					      macro	startio
    360  18d7					      db	70
    361  18d7					      endm
    362  18d7							; Endio
    363  18d7					      macro	endio
    364  18d7					      db	71
    365  18d7					      endm
    366  18d7							; Logical not
    367  18d7					      macro	lognot
    368  18d7					      db	72
    369  18d7					      endm
    370  18d7							; Logical OR
    371  18d7					      macro	logor
    372  18d7					      db	73
    373  18d7					      endm
    374  18d7							;Logical and
    375  18d7					      macro	logand
    376  18d7					      db	74
    377  18d7					      endm
    378  18d7							;Logical XOR
    379  18d7					      macro	logxor
    380  18d7					      db	75
    381  18d7					      endm
    382  18d7							;Wait for task to complete, or list of tasks
    383  18d7					      macro	wtask
    384  18d7					      db	76
    385  18d7					      db	({1}-*)-1	;(addr-*)-1
    386  18d7					      endm
    387  18d7							;Get the current task id
    388  18d7					      MACRO	taskpid
    389  18d7					      db	77
    390  18d7					      endm
    391  18d7							;Trace the basic execution
    392  18d7					      Macro	traceprogram
    393  18d7					      db	78
    394  18d7					      endm
    395  18d7							;Do a basic program Trace
    396  18d7					      Macro	debugbasic
    397  18d7					      db	79
    398  18d7					      endm
    399  18d7
    400  18d7							; Inter Process communications instructions
    401  18d7					      Macro	ipcsend
    402  18d7					      db	80
    403  18d7					      endm
    404  18d7					      Macro	ipcreceive
    405  18d7					      db	81
    406  18d7					      endm
    407  18d7					      Macro	ipccheck
    408  18d7					      db	82
    409  18d7					      endm
    410  18d7					      Macro	ipcio
    411  18d7					      db	83
    412  18d7					      endm
    413  18d7					      Macro	pushmathstack
    414  18d7					      db	84
    415  18d7					      endm
    416  18d7					      Macro	popmathstack
    417  18d7					      db	85
    418  18d7					      endm
    419  18d7					      Macro	savemathstack
    420  18d7					      db	86
    421  18d7					      endm
    422  18d7					      Macro	restoremathstack
    423  18d7					      db	87
    424  18d7					      endm
    425  18d7					      Macro	incparmcount
    426  18d7					      db	88
    427  18d7					      endm
    428  18d7					      Macro	taskgetmathstack
    429  18d7					      db	89
    430  18d7					      endm
    431  18d7					      Macro	taskenable
    432  18d7					      db	90
    433  18d7					      endm
    434  18d7					      Macro	tasksuspend
    435  18d7					      db	91
    436  18d7					      endm
    437  18d7					      Macro	taskputmathptr
    438  18d7					      db	92
    439  18d7					      endm
    440  18d7							; Test for an extension type of variable that allows access to a tasks variables
    441  18d7							; Using  PID!<Var name>
    442  18d7					      Macro	tstvt
    443  18d7					      db	93
    444  18d7					      db	({1}-*)-1	;(addr-*)-1
    445  18d7					      endm
    446  18d7
    447  18d7							; Provide access to R2 for the IL program
    448  18d7					      Macro	setr2
    449  18d7					      db	94
    450  18d7					      db	{1}	; R2 is only one byte
    451  18d7					      endm
    452  18d7							;Move stack top to temp
    453  18d7					      Macro	stk2tmp
    454  18d7					      db	95
    455  18d7					      endm
    456  18d7
    457  18d7					      Macro	tmp2stk
    458  18d7					      db	96
    459  18d7					      endm
    460  18d7
    461  18d7					      Macro	tstbyte
    462  18d7					      db	97
    463  18d7					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  18d7					      dw	{2}	; address to check
    465  18d7					      db	{3}	; Value to compare
    466  18d7					      endm
    467  18d7
    468  18d7					      Macro	incvar
    469  18d7					      db	98
    470  18d7					      endm
    471  18d7					      Macro	decvar
    472  18d7					      db	99
    473  18d7					      endm
    474  18d7
    475  18d7					      Macro	slice
    476  18d7					      db	100
    477  18d7					      endm
    478  18d7
    479  18d7
    480  18d7
------- FILE mytb.asm
   2212  18d7							;
   2213  18d7				  -	      if	FIXED
   2214  18d7				  -	      org	$1000
   2215  18d7					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  18d7					      include	"basic.il"
      1  18d7							;LET
      2  18d7							;=====================================================
      3  18d7							;=====================================================
      4  18d7					      seg	Code
      5  18d7							;=====================================================
      6  18d7							; This is the IL of the BASIC (or whatever) language.
      7  18d7							; Because of the way macros are implemented by as65,
      8  18d7							; labels can't be on the same line as a macro
      9  18d7							; invocation, so that's why labels are on separate
     10  18d7							; lines.
     11  18d7							;
     12  18d7		       18 d7	   IL	      equ	*
     13  18d7
     14  18d7							;THE IL CONTROL SECTION
     15  18d7
     16  18d7				   START
      0  18d7					      INIT		;INITIALIZE
      0  18d7					      db	22
      1  18d7		       16		      .byte.b	22
      0  18d8					      NLINE		;WRITE CRLF
      0  18d8					      db	5
      1  18d8		       05		      .byte.b	5
      0  18d9					      ERRGOTO	CO	;where to go after an error
      0  18d9					      db	31
      1  18d9		       1f		      .byte.b	31
      0  18da					      dw	CO
      1  18da		       dd 18		      .word.w	CO
      0  18dc					      VINIT		;clear all variables
      0  18dc					      db	30
      1  18dc		       1e		      .byte.b	30
     21  18dd							;
     22  18dd							; This is where we jump to get a line of commands or
     23  18dd							; a program from the user.
     24  18dd							;
     25  18dd				   CO
      0  18dd					      GETLINE		;WRITE PROMPT AND GET LINE
      0  18dd					      db	23
      1  18dd		       17		      .byte.b	23
      0  18de					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  18de					      db	34
      1  18de		       22		      .byte.b	34
      0  18df					      db	(XEC-*)-1
      1  18df		       04		      .byte.b	(XEC-*)-1
      0  18e0					      INSERT		;INSERT IT (MAY BE DELETE)
      0  18e0					      db	24
      1  18e0		       18		      .byte.b	24
      0  18e1					      IJMP	CO
      0  18e1					      db	29
      1  18e1		       1d		      .byte.b	29
      0  18e2					      dw	CO
      1  18e2		       dd 18		      .word.w	CO
     30  18e4				   XEC
      0  18e4					      XINIT		;INITIALIZE
      0  18e4					      db	0
      1  18e4		       00		      .byte.b	0
     32  18e5
     33  18e5							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  18e5				   STMT
      0  18e5					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  18e5					      db	79
      1  18e5		       4f		      .byte.b	79
      0  18e6					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  18e6					      db	57
      1  18e6		       39		      .byte.b	57
      0  18e7					      db	(notirq-*)-1
      1  18e7		       00		      .byte.b	(notirq-*)-1
     37  18e8				   notirq
      0  18e8					      TSTLET	LET	;Test if second field is =
      0  18e8					      db	49
      1  18e8		       31		      .byte.b	49
      0  18e9					      db	(LET-*)-1
      1  18e9		       03		      .byte.b	(LET-*)-1
      0  18ea					      IJMP	DOLET	;allow the default to be let
      0  18ea					      db	29
      1  18ea		       1d		      .byte.b	29
      0  18eb					      dw	DOLET
      1  18eb		       f3 18		      .word.w	DOLET
     40  18ed				   LET
      0  18ed					      TST	S1,"LET"	;IS STATEMENT A LET
      0  18ed					      db	32
      1  18ed		       20		      .byte.b	32
      0  18ee					      db	(S1-*)-1
      1  18ee		       21		      .byte.b	(S1-*)-1
      0  18ef					      db	"LET",0
      1  18ef		       4c 45 54 00	      .byte.b	"LET",0
     42  18f3				   DOLET
      0  18f3					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  18f3					      db	33
      1  18f3		       21		      .byte.b	33
      0  18f4					      db	(ERRVEC-*)-1
      1  18f4		       ea		      .byte.b	(ERRVEC-*)-1
      0  18f5					      TST	LETBE,"["
      0  18f5					      db	32
      1  18f5		       20		      .byte.b	32
      0  18f6					      db	(LETBE-*)-1
      1  18f6		       0a		      .byte.b	(LETBE-*)-1
      0  18f7					      db	"[",0
      1  18f7		       5b 00		      .byte.b	"[",0
      0  18f9					      CALL	EXPR
      0  18f9					      db	28
      1  18f9		       1c		      .byte.b	28
      0  18fa					      dw	EXPR
      1  18fa		       73 1b		      .word.w	EXPR
      0  18fc					      TST	ERRVEC,"]"
      0  18fc					      db	32
      1  18fc		       20		      .byte.b	32
      0  18fd					      db	(ERRVEC-*)-1
      1  18fd		       e1		      .byte.b	(ERRVEC-*)-1
      0  18fe					      db	"]",0
      1  18fe		       5d 00		      .byte.b	"]",0
      0  1900					      SUBSCRIPT
      0  1900					      db	64
      1  1900		       40		      .byte.b	64
     48  1901				   LETBE
      0  1901					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1901					      db	32
      1  1901		       20		      .byte.b	32
      0  1902					      db	(ERRVEC-*)-1
      1  1902		       dc		      .byte.b	(ERRVEC-*)-1
      0  1903					      db	"=",0
      1  1903		       3d 00		      .byte.b	"=",0
      0  1905					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  1905					      db	28
      1  1905		       1c		      .byte.b	28
      0  1906					      dw	EXPR
      1  1906		       73 1b		      .word.w	EXPR
      0  1908					      DONE		;REPORT ERROR IF NOT NEXT
      0  1908					      db	1
      1  1908		       01		      .byte.b	1
      0  1909					      STORE		;STORE RESULT
      0  1909					      db	19
      1  1909		       13		      .byte.b	19
      0  190a					      NXT	CO	;AND SEQUENCE TO NEXT
      0  190a					      db	6
      1  190a		       06		      .byte.b	6
      0  190b					      dw	CO
      1  190b		       dd 18		      .word.w	CO
      0  190d					      IJMP	STMT
      0  190d					      db	29
      1  190d		       1d		      .byte.b	29
      0  190e					      dw	STMT
      1  190e		       e5 18		      .word.w	STMT
     55  1910				   S1
      0  1910					      TST	S1Dec,"INC"	;Increment variable
      0  1910					      db	32
      1  1910		       20		      .byte.b	32
      0  1911					      db	(S1Dec-*)-1
      1  1911		       0e		      .byte.b	(S1Dec-*)-1
      0  1912					      db	"INC",0
      1  1912		       49 4e 43 00	      .byte.b	"INC",0
      0  1916					      TSTV	ERRVEC
      0  1916					      db	33
      1  1916		       21		      .byte.b	33
      0  1917					      db	(ERRVEC-*)-1
      1  1917		       c7		      .byte.b	(ERRVEC-*)-1
      0  1918					      INCVAR
      0  1918					      db	98
      1  1918		       62		      .byte.b	98
      0  1919					      DONE
      0  1919					      db	1
      1  1919		       01		      .byte.b	1
      0  191a					      NXT	CO
      0  191a					      db	6
      1  191a		       06		      .byte.b	6
      0  191b					      dw	CO
      1  191b		       dd 18		      .word.w	CO
      0  191d					      IJMP	STMT
      0  191d					      db	29
      1  191d		       1d		      .byte.b	29
      0  191e					      dw	STMT
      1  191e		       e5 18		      .word.w	STMT
     62  1920				   S1Dec
      0  1920					      TST	S1Iret,"DEC"	;Increment variable
      0  1920					      db	32
      1  1920		       20		      .byte.b	32
      0  1921					      db	(S1Iret-*)-1
      1  1921		       0e		      .byte.b	(S1Iret-*)-1
      0  1922					      db	"DEC",0
      1  1922		       44 45 43 00	      .byte.b	"DEC",0
      0  1926					      TSTV	ERRVEC
      0  1926					      db	33
      1  1926		       21		      .byte.b	33
      0  1927					      db	(ERRVEC-*)-1
      1  1927		       b7		      .byte.b	(ERRVEC-*)-1
      0  1928					      DECVAR
      0  1928					      db	99
      1  1928		       63		      .byte.b	99
      0  1929					      DONE
      0  1929					      db	1
      1  1929		       01		      .byte.b	1
      0  192a					      NXT	CO
      0  192a					      db	6
      1  192a		       06		      .byte.b	6
      0  192b					      dw	CO
      1  192b		       dd 18		      .word.w	CO
      0  192d					      IJMP	STMT
      0  192d					      db	29
      1  192d		       1d		      .byte.b	29
      0  192e					      dw	STMT
      1  192e		       e5 18		      .word.w	STMT
     69  1930				   S1Iret
      0  1930					      TST	S1S1,"IRET"	;test return from interupt
      0  1930					      db	32
      1  1930		       20		      .byte.b	32
      0  1931					      db	(S1S1-*)-1
      1  1931		       10		      .byte.b	(S1S1-*)-1
      0  1932					      db	"IRET",0
      1  1932		       49 52 45 54*	      .byte.b	"IRET",0
      0  1937					      TST	S1Sa,"URN"
      0  1937					      db	32
      1  1937		       20		      .byte.b	32
      0  1938					      db	(S1Sa-*)-1
      1  1938		       04		      .byte.b	(S1Sa-*)-1
      0  1939					      db	"URN",0
      1  1939		       55 52 4e 00	      .byte.b	"URN",0
     72  193d				   S1Sa
      0  193d					      DONE		;Must be only thing on the line
      0  193d					      db	1
      1  193d		       01		      .byte.b	1
      0  193e					      IRET		;RESTORE LINE NUMBER OF CALL
      0  193e					      db	58
      1  193e		       3a		      .byte.b	58
      0  193f					      IJMP	STMT
      0  193f					      db	29
      1  193f		       1d		      .byte.b	29
      0  1940					      dw	STMT
      1  1940		       e5 18		      .word.w	STMT
     76  1942
     77  1942				   S1S1
      0  1942					      TST	S1Z,"IF"	;IF STATEMENT
      0  1942					      db	32
      1  1942		       20		      .byte.b	32
      0  1943					      db	(S1Z-*)-1
      1  1943		       11		      .byte.b	(S1Z-*)-1
      0  1944					      db	"IF",0
      1  1944		       49 46 00 	      .byte.b	"IF",0
      0  1947					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1947					      db	28
      1  1947		       1c		      .byte.b	28
      0  1948					      dw	EXPR
      1  1948		       73 1b		      .word.w	EXPR
      0  194a					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  194a					      db	32
      1  194a		       20		      .byte.b	32
      0  194b					      db	(S1W-*)-1
      1  194b		       05		      .byte.b	(S1W-*)-1
      0  194c					      db	"THEN",0
      1  194c		       54 48 45 4e*	      .byte.b	"THEN",0
     81  1951				   S1W
      0  1951					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1951					      db	54
      1  1951		       36		      .byte.b	54
      0  1952					      IJMP	STMT
      0  1952					      db	29
      1  1952		       1d		      .byte.b	29
      0  1953					      dw	STMT
      1  1953		       e5 18		      .word.w	STMT
     84  1955
     85  1955				   S1Z
      0  1955					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1955					      db	32
      1  1955		       20		      .byte.b	32
      0  1956					      db	(S2b-*)-1
      1  1956		       19		      .byte.b	(S2b-*)-1
      0  1957					      db	"GO",0
      1  1957		       47 4f 00 	      .byte.b	"GO",0
      0  195a					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  195a					      db	32
      1  195a		       20		      .byte.b	32
      0  195b					      db	(S2-*)-1
      1  195b		       07		      .byte.b	(S2-*)-1
      0  195c					      db	"TO",0
      1  195c		       54 4f 00 	      .byte.b	"TO",0
      0  195f					      CALL	EXPR	;GET LABEL
      0  195f					      db	28
      1  195f		       1c		      .byte.b	28
      0  1960					      dw	EXPR
      1  1960		       73 1b		      .word.w	EXPR
      0  1962					      XFER		;SET UP AND JUMP
      0  1962					      db	7
      1  1962		       07		      .byte.b	7
     90  1963				   S2
     91  1963							;===========================================================================
     92  1963							; Process gosub / function
     93  1963							;
      0  1963					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1963					      db	32
      1  1963		       20		      .byte.b	32
      0  1964					      db	(ERRVEC-*)-1
      1  1964		       7a		      .byte.b	(ERRVEC-*)-1
      0  1965					      db	"SUB",0
      1  1965		       53 55 42 00	      .byte.b	"SUB",0
      0  1969					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  1969					      db	28
      1  1969		       1c		      .byte.b	28
      0  196a					      dw	GOSUBSTATEMENT
      1  196a		       79 1d		      .word.w	GOSUBSTATEMENT
      0  196c					      DONE		;ERROR IF CR NOT NEXT
      0  196c					      db	1
      1  196c		       01		      .byte.b	1
      0  196d					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  196d					      db	8
      1  196d		       08		      .byte.b	8
      0  196e					      db	GOSUB_RTN
      1  196e		       01		      .byte.b	GOSUB_RTN
      0  196f					      XFER		;AND JUMP
      0  196f					      db	7
      1  196f		       07		      .byte.b	7
     99  1970							;
    100  1970							; End of gosub processing
    101  1970							;==========================================================================
    102  1970							; Return from a gosub
    103  1970				   S2b
      0  1970					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1970					      db	32
      1  1970		       20		      .byte.b	32
      0  1971					      db	(S3-*)-1
      1  1971		       36		      .byte.b	(S3-*)-1
      0  1972					      db	"RE",0
      1  1972		       52 45 00 	      .byte.b	"RE",0
      0  1975					      TST	S2a,"T"
      0  1975					      db	32
      1  1975		       20		      .byte.b	32
      0  1976					      db	(S2a-*)-1
      1  1976		       27		      .byte.b	(S2a-*)-1
      0  1977					      db	"T",0
      1  1977		       54 00		      .byte.b	"T",0
      0  1979					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  1979					      db	32
      1  1979		       20		      .byte.b	32
      0  197a					      db	(S2aa-*)-1
      1  197a		       04		      .byte.b	(S2aa-*)-1
      0  197b					      db	"URN",0
      1  197b		       55 52 4e 00	      .byte.b	"URN",0
    107  197f				   S2aa
      0  197f					      SETR2	0	; Default no return value
      0  197f					      db	94
      1  197f		       5e		      .byte.b	94
      0  1980					      db	0
      1  1980		       00		      .byte.b	0
      0  1981					      TST	S2RetDone,"("	; Check if we will return some value
      0  1981					      db	32
      1  1981		       20		      .byte.b	32
      0  1982					      db	(S2RetDone-*)-1
      1  1982		       0b		      .byte.b	(S2RetDone-*)-1
      0  1983					      db	"(",0
      1  1983		       28 00		      .byte.b	"(",0
      0  1985					      SETR2	1	; Indicate a return value provided
      0  1985					      db	94
      1  1985		       5e		      .byte.b	94
      0  1986					      db	1
      1  1986		       01		      .byte.b	1
      0  1987					      CALL	EXPR
      0  1987					      db	28
      1  1987		       1c		      .byte.b	28
      0  1988					      dw	EXPR
      1  1988		       73 1b		      .word.w	EXPR
      0  198a					      TST	ERRVEC,")"	; Now a value is on the stack
      0  198a					      db	32
      1  198a		       20		      .byte.b	32
      0  198b					      db	(ERRVEC-*)-1
      1  198b		       53		      .byte.b	(ERRVEC-*)-1
      0  198c					      db	")",0
      1  198c		       29 00		      .byte.b	")",0
    113  198e
    114  198e				   S2RetDone
      0  198e					      DONE		; MUST BE CR or :
      0  198e					      db	1
      1  198e		       01		      .byte.b	1
      0  198f					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  198f					      db	9
      1  198f		       09		      .byte.b	9
      0  1990					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  1990					      db	97
      1  1990		       61		      .byte.b	97
      0  1991					      db	(S2RetFunc-*)-1
      1  1991		       09		      .byte.b	(S2RetFunc-*)-1
      0  1992					      dw	R2
      1  1992		       58 00		      .word.w	R2
      0  1994					      db	1
      1  1994		       01		      .byte.b	1
      0  1995					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  1995					      db	6
      1  1995		       06		      .byte.b	6
      0  1996					      dw	CO
      1  1996		       dd 18		      .word.w	CO
      0  1998					      IJMP	STMT
      0  1998					      db	29
      1  1998		       1d		      .byte.b	29
      0  1999					      dw	STMT
      1  1999		       e5 18		      .word.w	STMT
    120  199b				   S2RetFunc
      0  199b					      IJMP	GOFNRet	; Back into the Function
      0  199b					      db	29
      1  199b		       1d		      .byte.b	29
      0  199c					      dw	GOFNRet
      1  199c		       4f 1d		      .word.w	GOFNRet
    122  199e							;
    123  199e							; End of return from gosub
    124  199e							;============================================================================
    125  199e							; Process REM statement
    126  199e				   S2a
      0  199e					      TST	S3,"M"	;REMark.  Skip rest of line
      0  199e					      db	32
      1  199e		       20		      .byte.b	32
      0  199f					      db	(S3-*)-1
      1  199f		       08		      .byte.b	(S3-*)-1
      0  19a0					      db	"M",0
      1  19a0		       4d 00		      .byte.b	"M",0
      0  19a2					      NXT	CO
      0  19a2					      db	6
      1  19a2		       06		      .byte.b	6
      0  19a3					      dw	CO
      1  19a3		       dd 18		      .word.w	CO
      0  19a5					      IJMP	STMT
      0  19a5					      db	29
      1  19a5		       1d		      .byte.b	29
      0  19a6					      dw	STMT
      1  19a6		       e5 18		      .word.w	STMT
    130  19a8
    131  19a8				   S3
      0  19a8					      TST	S3a,"?"	; ? symonym for print
      0  19a8					      db	32
      1  19a8		       20		      .byte.b	32
      0  19a9					      db	(S3a-*)-1
      1  19a9		       05		      .byte.b	(S3a-*)-1
      0  19aa					      db	"?",0
      1  19aa		       3f 00		      .byte.b	"?",0
      0  19ac					      IJMP	S4S
      0  19ac					      db	29
      1  19ac		       1d		      .byte.b	29
      0  19ad					      dw	S4S
      1  19ad		       ba 19		      .word.w	S4S
    134  19af				   S3a
      0  19af					      TST	S8,"PR"	;allow short form of print
      0  19af					      db	32
      1  19af		       20		      .byte.b	32
      0  19b0					      db	(S8-*)-1
      1  19b0		       4c		      .byte.b	(S8-*)-1
      0  19b1					      db	"PR",0
      1  19b1		       50 52 00 	      .byte.b	"PR",0
      0  19b4					      TST	S4S,"INT"	;PRINT
      0  19b4					      db	32
      1  19b4		       20		      .byte.b	32
      0  19b5					      db	(S4S-*)-1
      1  19b5		       04		      .byte.b	(S4S-*)-1
      0  19b6					      db	"INT",0
      1  19b6		       49 4e 54 00	      .byte.b	"INT",0
    137  19ba				   S4S
      0  19ba					      STARTIO		;Lock task until io completes
      0  19ba					      db	70
      1  19ba		       46		      .byte.b	70
    139  19bb				   S4
      0  19bb					      TSTDONE	S4a	;Test if we just want crlf printed
      0  19bb					      db	50
      1  19bb		       32		      .byte.b	50
      0  19bc					      db	(S4a-*)-1
      1  19bc		       03		      .byte.b	(S4a-*)-1
      0  19bd					      IJMP	S6
      0  19bd					      db	29
      1  19bd		       1d		      .byte.b	29
      0  19be					      dw	S6
      1  19be		       d6 19		      .word.w	S6
    142  19c0
    143  19c0				   S4a
      0  19c0					      TSTSTR	S7	;TEST FOR QUOTED String
      0  19c0					      db	55
      1  19c0		       37		      .byte.b	55
      0  19c1					      db	(S7-*)-1
      1  19c1		       21		      .byte.b	(S7-*)-1
      0  19c2					      PRS		;PRINT STRING
      0  19c2					      db	2
      1  19c2		       02		      .byte.b	2
    146  19c3				   S5
      0  19c3					      TST	S6A,COMMA	;IS THERE MORE?
      0  19c3					      db	32
      1  19c3		       20		      .byte.b	32
      0  19c4					      db	(S6A-*)-1
      1  19c4		       08		      .byte.b	(S6A-*)-1
      0  19c5					      db	COMMA,0
      1  19c5		       2c 00		      .byte.b	COMMA,0
      0  19c7					      SPC		;SPACE TO NEXT ZONE
      0  19c7					      db	4
      1  19c7		       04		      .byte.b	4
      0  19c8					      TSTDONE	S4	;Not end of line jump back
      0  19c8					      db	50
      1  19c8		       32		      .byte.b	50
      0  19c9					      db	(S4-*)-1
      1  19c9		       f1		      .byte.b	(S4-*)-1
      0  19ca					      IJMP	S6Z	;YES JUMP BACK
      0  19ca					      db	29
      1  19ca		       1d		      .byte.b	29
      0  19cb					      dw	S6Z
      1  19cb		       d8 19		      .word.w	S6Z
    151  19cd
    152  19cd							;
    153  19cd							; If a semicolon, don't do anything.
    154  19cd							;
    155  19cd				   S6A
      0  19cd					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  19cd					      db	32
      1  19cd		       20		      .byte.b	32
      0  19ce					      db	(S6-*)-1
      1  19ce		       07		      .byte.b	(S6-*)-1
      0  19cf					      db	SEMICOLON,0
      1  19cf		       3b 00		      .byte.b	SEMICOLON,0
      0  19d1					      TSTDONE	S4	;Jump Back if not end of line
      0  19d1					      db	50
      1  19d1		       32		      .byte.b	50
      0  19d2					      db	(S4-*)-1
      1  19d2		       e8		      .byte.b	(S4-*)-1
      0  19d3					      IJMP	S6Z
      0  19d3					      db	29
      1  19d3		       1d		      .byte.b	29
      0  19d4					      dw	S6Z
      1  19d4		       d8 19		      .word.w	S6Z
    159  19d6				   S6
      0  19d6					      DONE		;ERROR IF CR NOT NEXT
      0  19d6					      db	1
      1  19d6		       01		      .byte.b	1
      0  19d7					      NLINE
      0  19d7					      db	5
      1  19d7		       05		      .byte.b	5
    162  19d8				   S6Z
      0  19d8					      ENDIO		;release task io completed
      0  19d8					      db	71
      1  19d8		       47		      .byte.b	71
      0  19d9					      NXT	CO	;exit here if , or ; at end of print
      0  19d9					      db	6
      1  19d9		       06		      .byte.b	6
      0  19da					      dw	CO
      1  19da		       dd 18		      .word.w	CO
      0  19dc					      IJMP	STMT
      0  19dc					      db	29
      1  19dc		       1d		      .byte.b	29
      0  19dd					      dw	STMT
      1  19dd		       e5 18		      .word.w	STMT
    166  19df							;
    167  19df							; A jump for code too far away for relative branch
    168  19df							;
    169  19df				   ERRVEC
      0  19df					      ENDIO
      0  19df					      db	71
      1  19df		       47		      .byte.b	71
      0  19e0					      IJMP	UNKNOWN
      0  19e0					      db	29
      1  19e0		       1d		      .byte.b	29
      0  19e1					      dw	UNKNOWN
      1  19e1		       6f 1b		      .word.w	UNKNOWN
    172  19e3							;
    173  19e3							; Get here if there is an expression to print
    174  19e3				   S7
      0  19e3					      TST	S7A,"$"
      0  19e3					      db	32
      1  19e3		       20		      .byte.b	32
      0  19e4					      db	(S7A-*)-1
      1  19e4		       09		      .byte.b	(S7A-*)-1
      0  19e5					      db	"$",0
      1  19e5		       24 00		      .byte.b	"$",0
      0  19e7					      CALL	EXPR
      0  19e7					      db	28
      1  19e7		       1c		      .byte.b	28
      0  19e8					      dw	EXPR
      1  19e8		       73 1b		      .word.w	EXPR
      0  19ea					      HEXPRT
      0  19ea					      db	67
      1  19ea		       43		      .byte.b	67
      0  19eb					      IJMP	S5
      0  19eb					      db	29
      1  19eb		       1d		      .byte.b	29
      0  19ec					      dw	S5
      1  19ec		       c3 19		      .word.w	S5
    179  19ee				   S7A
      0  19ee					      CALL	EXPR
      0  19ee					      db	28
      1  19ee		       1c		      .byte.b	28
      0  19ef					      dw	EXPR
      1  19ef		       73 1b		      .word.w	EXPR
      0  19f1					      TST	S7B,"$"
      0  19f1					      db	32
      1  19f1		       20		      .byte.b	32
      0  19f2					      db	(S7B-*)-1
      1  19f2		       06		      .byte.b	(S7B-*)-1
      0  19f3					      db	"$",0
      1  19f3		       24 00		      .byte.b	"$",0
      0  19f5					      PUTCHAR
      0  19f5					      db	52
      1  19f5		       34		      .byte.b	52
      0  19f6					      IJMP	S5
      0  19f6					      db	29
      1  19f6		       1d		      .byte.b	29
      0  19f7					      dw	S5
      1  19f7		       c3 19		      .word.w	S5
    184  19f9				   S7B
      0  19f9					      PRN		;PRINT IT
      0  19f9					      db	3
      1  19f9		       03		      .byte.b	3
      0  19fa					      IJMP	S5	;IS THERE MORE?
      0  19fa					      db	29
      1  19fa		       1d		      .byte.b	29
      0  19fb					      dw	S5
      1  19fb		       c3 19		      .word.w	S5
    187  19fd							;
    188  19fd							;===========================================================
    189  19fd							; End of TASK process
    190  19fd				   S8
      0  19fd					      TST	S8a1,"TASK"	; Any Task COmmand
      0  19fd					      db	32
      1  19fd		       20		      .byte.b	32
      0  19fe					      db	(S8a1-*)-1
      1  19fe		       4b		      .byte.b	(S8a1-*)-1
      0  19ff					      db	"TASK",0
      1  19ff		       54 41 53 4b*	      .byte.b	"TASK",0
      0  1a04					      TST	S8G,"E"
      0  1a04					      db	32
      1  1a04		       20		      .byte.b	32
      0  1a05					      db	(S8G-*)-1
      1  1a05		       1a		      .byte.b	(S8G-*)-1
      0  1a06					      db	"E",0
      1  1a06		       45 00		      .byte.b	"E",0
      0  1a08					      TST	S8NoParm,"("
      0  1a08					      db	32
      1  1a08		       20		      .byte.b	32
      0  1a09					      db	(S8NoParm-*)-1
      1  1a09		       0e		      .byte.b	(S8NoParm-*)-1
      0  1a0a					      db	"(",0
      1  1a0a		       28 00		      .byte.b	"(",0
      0  1a0c					      CALL	EXPR
      0  1a0c					      db	28
      1  1a0c		       1c		      .byte.b	28
      0  1a0d					      dw	EXPR
      1  1a0d		       73 1b		      .word.w	EXPR
      0  1a0f					      TST	UNKNOWNLnk,")"
      0  1a0f					      db	32
      1  1a0f		       20		      .byte.b	32
      0  1a10					      db	(UNKNOWNLnk-*)-1
      1  1a10		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1a11					      db	")",0
      1  1a11		       29 00		      .byte.b	")",0
      0  1a13					      ETASK
      0  1a13					      db	62
      1  1a13		       3e		      .byte.b	62
      0  1a14					      DONE
      0  1a14					      db	1
      1  1a14		       01		      .byte.b	1
      0  1a15					      IJMP	STMT
      0  1a15					      db	29
      1  1a15		       1d		      .byte.b	29
      0  1a16					      dw	STMT
      1  1a16		       e5 18		      .word.w	STMT
    199  1a18				   S8NoParm
      0  1a18					      LIT	0
      0  1a18					      db	27
      1  1a18		       1b		      .byte.b	27
      0  1a19					      dw	0
      1  1a19		       00 00		      .word.w	0
      0  1a1b					      ETASK
      0  1a1b					      db	62
      1  1a1b		       3e		      .byte.b	62
      0  1a1c					      DONE		; Must be last thing on a line
      0  1a1c					      db	1
      1  1a1c		       01		      .byte.b	1
      0  1a1d					      IJMP	STMT
      0  1a1d					      db	29
      1  1a1d		       1d		      .byte.b	29
      0  1a1e					      dw	STMT
      1  1a1e		       e5 18		      .word.w	STMT
    204  1a20							;
    205  1a20							;===========================================================
    206  1a20							; The task gives up the rest of the cycles
    207  1a20				   S8G
      0  1a20					      TST	S8a,"N"	;Next task
      0  1a20					      db	32
      1  1a20		       20		      .byte.b	32
      0  1a21					      db	(S8a-*)-1
      1  1a21		       09		      .byte.b	(S8a-*)-1
      0  1a22					      db	"N",0
      1  1a22		       4e 00		      .byte.b	"N",0
      0  1a24					      NTASK
      0  1a24					      db	63
      1  1a24		       3f		      .byte.b	63
      0  1a25					      NXT	CO	;Next statement to execute
      0  1a25					      db	6
      1  1a25		       06		      .byte.b	6
      0  1a26					      dw	CO
      1  1a26		       dd 18		      .word.w	CO
      0  1a28					      IJMP	STMT
      0  1a28					      db	29
      1  1a28		       1d		      .byte.b	29
      0  1a29					      dw	STMT
      1  1a29		       e5 18		      .word.w	STMT
    212  1a2b							;
    213  1a2b							;===========================================================
    214  1a2b							; Waits for a task or list of tasks to complete
    215  1a2b				   S8a
      0  1a2b					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1a2b					      db	32
      1  1a2b		       20		      .byte.b	32
      0  1a2c					      db	(S8TASKNO-*)-1
      1  1a2c		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1a2d					      db	"W(",0
      1  1a2d		       57 28 00 	      .byte.b	"W(",0
    217  1a30				   S8TSK
      0  1a30					      Call	EXPR	;Gets the PID of task to wait for
      0  1a30					      db	28
      1  1a30		       1c		      .byte.b	28
      0  1a31					      dw	EXPR
      1  1a31		       73 1b		      .word.w	EXPR
    219  1a33				   S8LOOP
      0  1a33					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1a33					      db	76
      1  1a33		       4c		      .byte.b	76
      0  1a34					      db	(S8LOOP-*)-1
      1  1a34		       fe		      .byte.b	(S8LOOP-*)-1
      0  1a35					      TST	S8aa,COMMA	;Checks for more tasks
      0  1a35					      db	32
      1  1a35		       20		      .byte.b	32
      0  1a36					      db	(S8aa-*)-1
      1  1a36		       05		      .byte.b	(S8aa-*)-1
      0  1a37					      db	COMMA,0
      1  1a37		       2c 00		      .byte.b	COMMA,0
      0  1a39					      IJMP	S8TSK	;Go for the next task number
      0  1a39					      db	29
      1  1a39		       1d		      .byte.b	29
      0  1a3a					      dw	S8TSK
      1  1a3a		       30 1a		      .word.w	S8TSK
    223  1a3c				   S8aa
      0  1a3c					      TST	S8TASKNO,")"	;end of list
      0  1a3c					      db	32
      1  1a3c		       20		      .byte.b	32
      0  1a3d					      db	(S8TASKNO-*)-1
      1  1a3d		       09		      .byte.b	(S8TASKNO-*)-1
      0  1a3e					      db	")",0
      1  1a3e		       29 00		      .byte.b	")",0
      0  1a40					      DONE
      0  1a40					      db	1
      1  1a40		       01		      .byte.b	1
      0  1a41					      NXT	CO
      0  1a41					      db	6
      1  1a41		       06		      .byte.b	6
      0  1a42					      dw	CO
      1  1a42		       dd 18		      .word.w	CO
      0  1a44					      IJMP	STMT	;Next Statement
      0  1a44					      db	29
      1  1a44		       1d		      .byte.b	29
      0  1a45					      dw	STMT
      1  1a45		       e5 18		      .word.w	STMT
    228  1a47				   S8TASKNO
    229  1a47
    230  1a47				   UNKNOWNLnk
      0  1a47					      iJMP	UNKNOWN
      0  1a47					      db	29
      1  1a47		       1d		      .byte.b	29
      0  1a48					      dw	UNKNOWN
      1  1a48		       6f 1b		      .word.w	UNKNOWN
    232  1a4a
    233  1a4a							;
    234  1a4a							;===========================================================
    235  1a4a							; Update a memory location with a value
    236  1a4a				   S8a1
      0  1a4a					      TST	S8b,"POKE("	; Poke a value into memory
      0  1a4a					      db	32
      1  1a4a		       20		      .byte.b	32
      0  1a4b					      db	(S8b-*)-1
      1  1a4b		       1c		      .byte.b	(S8b-*)-1
      0  1a4c					      db	"POKE(",0
      1  1a4c		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1a52					      CALL	EXPR	; Get address to write to
      0  1a52					      db	28
      1  1a52		       1c		      .byte.b	28
      0  1a53					      dw	EXPR
      1  1a53		       73 1b		      .word.w	EXPR
      0  1a55					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1a55					      db	32
      1  1a55		       20		      .byte.b	32
      0  1a56					      db	(UNKNOWNV-*)-1
      1  1a56		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1a57					      db	COMMA,0
      1  1a57		       2c 00		      .byte.b	COMMA,0
      0  1a59					      CALL	EXPR	; Get the value to poke
      0  1a59					      db	28
      1  1a59		       1c		      .byte.b	28
      0  1a5a					      dw	EXPR
      1  1a5a		       73 1b		      .word.w	EXPR
      0  1a5c					      TST	UNKNOWNV,")"	; closing bracket
      0  1a5c					      db	32
      1  1a5c		       20		      .byte.b	32
      0  1a5d					      db	(UNKNOWNV-*)-1
      1  1a5d		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1a5e					      db	")",0
      1  1a5e		       29 00		      .byte.b	")",0
      0  1a60					      POKEMEM
      0  1a60					      db	47
      1  1a60		       2f		      .byte.b	47
      0  1a61					      DONE
      0  1a61					      db	1
      1  1a61		       01		      .byte.b	1
      0  1a62					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1a62					      db	6
      1  1a62		       06		      .byte.b	6
      0  1a63					      dw	CO
      1  1a63		       dd 18		      .word.w	CO
      0  1a65					      IJMP	STMT
      0  1a65					      db	29
      1  1a65		       1d		      .byte.b	29
      0  1a66					      dw	STMT
      1  1a66		       e5 18		      .word.w	STMT
    246  1a68
    247  1a68				   S8b
      0  1a68					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1a68					      db	32
      1  1a68		       20		      .byte.b	32
      0  1a69					      db	(S8c-*)-1
      1  1a69		       11		      .byte.b	(S8c-*)-1
      0  1a6a					      db	"PUTCH",0
      1  1a6a		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1a70					      CALL	EXPR
      0  1a70					      db	28
      1  1a70		       1c		      .byte.b	28
      0  1a71					      dw	EXPR
      1  1a71		       73 1b		      .word.w	EXPR
      0  1a73					      PUTCHAR
      0  1a73					      db	52
      1  1a73		       34		      .byte.b	52
      0  1a74					      DONE
      0  1a74					      db	1
      1  1a74		       01		      .byte.b	1
      0  1a75					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1a75					      db	6
      1  1a75		       06		      .byte.b	6
      0  1a76					      dw	CO
      1  1a76		       dd 18		      .word.w	CO
      0  1a78					      IJMP	STMT
      0  1a78					      db	29
      1  1a78		       1d		      .byte.b	29
      0  1a79					      dw	STMT
      1  1a79		       e5 18		      .word.w	STMT
    254  1a7b				   S8c
      0  1a7b					      TST	S9,"CLS"	;Clear the screen
      0  1a7b					      db	32
      1  1a7b		       20		      .byte.b	32
      0  1a7c					      db	(S9-*)-1
      1  1a7c		       0b		      .byte.b	(S9-*)-1
      0  1a7d					      db	"CLS",0
      1  1a7d		       43 4c 53 00	      .byte.b	"CLS",0
      0  1a81					      CLEARSCREEN
      0  1a81					      db	46
      1  1a81		       2e		      .byte.b	46
      0  1a82					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1a82					      db	6
      1  1a82		       06		      .byte.b	6
      0  1a83					      dw	CO
      1  1a83		       dd 18		      .word.w	CO
      0  1a85					      IJMP	STMT
      0  1a85					      db	29
      1  1a85		       1d		      .byte.b	29
      0  1a86					      dw	STMT
      1  1a86		       e5 18		      .word.w	STMT
    259  1a88				   S9
      0  1a88					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1a88					      db	32
      1  1a88		       20		      .byte.b	32
      0  1a89					      db	(S13-*)-1
      1  1a89		       2a		      .byte.b	(S13-*)-1
      0  1a8a					      db	"INPUT",0
      1  1a8a		       49 4e 50 55*	      .byte.b	"INPUT",0
    261  1a90				   S10
      0  1a90					      TSTSTR	S10A	;If there is a string print the prompt
      0  1a90					      db	55
      1  1a90		       37		      .byte.b	55
      0  1a91					      db	(S10A-*)-1
      1  1a91		       05		      .byte.b	(S10A-*)-1
      0  1a92					      PRS
      0  1a92					      db	2
      1  1a92		       02		      .byte.b	2
      0  1a93					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1a93					      db	32
      1  1a93		       20		      .byte.b	32
      0  1a94					      db	(S10Z-*)-1
      1  1a94		       15		      .byte.b	(S10Z-*)-1
      0  1a95					      db	SEMICOLON,0
      1  1a95		       3b 00		      .byte.b	SEMICOLON,0
    265  1a97				   S10A
      0  1a97					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1a97					      db	33
      1  1a97		       21		      .byte.b	33
      0  1a98					      db	(UNKNOWN-*)-1
      1  1a98		       d6		      .byte.b	(UNKNOWN-*)-1
      0  1a99					      TST	S10A1,DOLLAR
      0  1a99					      db	32
      1  1a99		       20		      .byte.b	32
      0  1a9a					      db	(S10A1-*)-1
      1  1a9a		       06		      .byte.b	(S10A1-*)-1
      0  1a9b					      db	DOLLAR,0
      1  1a9b		       24 00		      .byte.b	DOLLAR,0
      0  1a9d					      INSTR		;Move character From tty to AESTK
      0  1a9d					      db	59
      1  1a9d		       3b		      .byte.b	59
      0  1a9e					      IJMP	S10A2
      0  1a9e					      db	29
      1  1a9e		       1d		      .byte.b	29
      0  1a9f					      dw	S10A2
      1  1a9f		       a2 1a		      .word.w	S10A2
    270  1aa1				   S10A1
      0  1aa1					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1aa1					      db	11
      1  1aa1		       0b		      .byte.b	11
    272  1aa2				   S10A2
      0  1aa2					      STORE		;STORE IT
      0  1aa2					      db	19
      1  1aa2		       13		      .byte.b	19
      0  1aa3					      TST	S11,COMMA	;IS THERE MORE?
      0  1aa3					      db	32
      1  1aa3		       20		      .byte.b	32
      0  1aa4					      db	(S11-*)-1
      1  1aa4		       08		      .byte.b	(S11-*)-1
      0  1aa5					      db	COMMA,0
      1  1aa5		       2c 00		      .byte.b	COMMA,0
      0  1aa7					      IJMP	S10	;YES
      0  1aa7					      db	29
      1  1aa7		       1d		      .byte.b	29
      0  1aa8					      dw	S10
      1  1aa8		       90 1a		      .word.w	S10
    276  1aaa				   S10Z
      0  1aaa					      iJMP	UNKNOWN
      0  1aaa					      db	29
      1  1aaa		       1d		      .byte.b	29
      0  1aab					      dw	UNKNOWN
      1  1aab		       6f 1b		      .word.w	UNKNOWN
    278  1aad				   S11
      0  1aad					      DONE		;MUST BE CR
      0  1aad					      db	1
      1  1aad		       01		      .byte.b	1
      0  1aae					      NXT	CO	;SEQUENCE TO NEXT
      0  1aae					      db	6
      1  1aae		       06		      .byte.b	6
      0  1aaf					      dw	CO
      1  1aaf		       dd 18		      .word.w	CO
      0  1ab1					      IJMP	STMT
      0  1ab1					      db	29
      1  1ab1		       1d		      .byte.b	29
      0  1ab2					      dw	STMT
      1  1ab2		       e5 18		      .word.w	STMT
    282  1ab4				   S13
      0  1ab4					      TST	S14,"END"
      0  1ab4					      db	32
      1  1ab4		       20		      .byte.b	32
      0  1ab5					      db	(S14-*)-1
      1  1ab5		       08		      .byte.b	(S14-*)-1
      0  1ab6					      db	"END",0
      1  1ab6		       45 4e 44 00	      .byte.b	"END",0
      0  1aba					      FIN
      0  1aba					      db	12
      1  1aba		       0c		      .byte.b	12
    285  1abb
    286  1abb				   UNKNOWNV
      0  1abb					      IJMP	UNKNOWN
      0  1abb					      db	29
      1  1abb		       1d		      .byte.b	29
      0  1abc					      dw	UNKNOWN
      1  1abc		       6f 1b		      .word.w	UNKNOWN
    288  1abe
    289  1abe				   S14
      0  1abe					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  1abe					      db	32
      1  1abe		       20		      .byte.b	32
      0  1abf					      db	(S14Z-*)-1
      1  1abf		       0f		      .byte.b	(S14Z-*)-1
      0  1ac0					      db	"IRQ",0
      1  1ac0		       49 52 51 00	      .byte.b	"IRQ",0
      0  1ac4					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1ac4					      db	28
      1  1ac4		       1c		      .byte.b	28
      0  1ac5					      dw	EXPR
      1  1ac5		       73 1b		      .word.w	EXPR
      0  1ac7					      DONE		;must be CR
      0  1ac7					      db	1
      1  1ac7		       01		      .byte.b	1
      0  1ac8					      SETIRQ		;Set the line number now
      0  1ac8					      db	56
      1  1ac8		       38		      .byte.b	56
      0  1ac9					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1ac9					      db	6
      1  1ac9		       06		      .byte.b	6
      0  1aca					      dw	CO
      1  1aca		       dd 18		      .word.w	CO
      0  1acc					      IJMP	STMT
      0  1acc					      db	29
      1  1acc		       1d		      .byte.b	29
      0  1acd					      dw	STMT
      1  1acd		       e5 18		      .word.w	STMT
    296  1acf
    297  1acf				   S14Z
      0  1acf					      TST	S14S1,"KILL"	; Kill A running Task
      0  1acf					      db	32
      1  1acf		       20		      .byte.b	32
      0  1ad0					      db	(S14S1-*)-1
      1  1ad0		       10		      .byte.b	(S14S1-*)-1
      0  1ad1					      db	"KILL",0
      1  1ad1		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  1ad6					      CALL	EXPR
      0  1ad6					      db	28
      1  1ad6		       1c		      .byte.b	28
      0  1ad7					      dw	EXPR
      1  1ad7		       73 1b		      .word.w	EXPR
      0  1ad9					      DONE
      0  1ad9					      db	1
      1  1ad9		       01		      .byte.b	1
      0  1ada					      TASKKILL
      0  1ada					      db	65
      1  1ada		       41		      .byte.b	65
      0  1adb					      NXT	CO
      0  1adb					      db	6
      1  1adb		       06		      .byte.b	6
      0  1adc					      dw	CO
      1  1adc		       dd 18		      .word.w	CO
      0  1ade					      IJMP	STMT
      0  1ade					      db	29
      1  1ade		       1d		      .byte.b	29
      0  1adf					      dw	STMT
      1  1adf		       e5 18		      .word.w	STMT
    304  1ae1
    305  1ae1				   S14S1
      0  1ae1					      TST	S15,"LIST"	;LIST COMMAND
      0  1ae1					      db	32
      1  1ae1		       20		      .byte.b	32
      0  1ae2					      db	(S15-*)-1
      1  1ae2		       0a		      .byte.b	(S15-*)-1
      0  1ae3					      db	"LIST",0
      1  1ae3		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1ae8					      DONE
      0  1ae8					      db	1
      1  1ae8		       01		      .byte.b	1
      0  1ae9					      LST
      0  1ae9					      db	21
      1  1ae9		       15		      .byte.b	21
      0  1aea					      IJMP	CO
      0  1aea					      db	29
      1  1aea		       1d		      .byte.b	29
      0  1aeb					      dw	CO
      1  1aeb		       dd 18		      .word.w	CO
    310  1aed				   S15
      0  1aed					      TST	S16,"RUN"	;RUN COMMAND
      0  1aed					      db	32
      1  1aed		       20		      .byte.b	32
      0  1aee					      db	(S16-*)-1
      1  1aee		       0d		      .byte.b	(S16-*)-1
      0  1aef					      db	"RUN",0
      1  1aef		       52 55 4e 00	      .byte.b	"RUN",0
      0  1af3					      DONE
      0  1af3					      db	1
      1  1af3		       01		      .byte.b	1
      0  1af4					      VINIT		;clear variables
      0  1af4					      db	30
      1  1af4		       1e		      .byte.b	30
      0  1af5					      LIT	1	;GOTO line 1
      0  1af5					      db	27
      1  1af5		       1b		      .byte.b	27
      0  1af6					      dw	1
      1  1af6		       01 00		      .word.w	1
      0  1af8					      XFER		;Bob's addition
      0  1af8					      db	7
      1  1af8		       07		      .byte.b	7
    316  1af9							; EXIT
      0  1af9					      IJMP	STMT	;and run!
      0  1af9					      db	29
      1  1af9		       1d		      .byte.b	29
      0  1afa					      dw	STMT
      1  1afa		       e5 18		      .word.w	STMT
    318  1afc				   S16
      0  1afc					      TST	S16A,"NEW"	;clear program
      0  1afc					      db	32
      1  1afc		       20		      .byte.b	32
      0  1afd					      db	(S16A-*)-1
      1  1afd		       08		      .byte.b	(S16A-*)-1
      0  1afe					      db	"NEW",0
      1  1afe		       4e 45 57 00	      .byte.b	"NEW",0
      0  1b02					      DONE
      0  1b02					      db	1
      1  1b02		       01		      .byte.b	1
      0  1b03					      IJMP	START
      0  1b03					      db	29
      1  1b03		       1d		      .byte.b	29
      0  1b04					      dw	START
      1  1b04		       d7 18		      .word.w	START
    322  1b06
    323  1b06				   S16A
      0  1b06					      TST	S16Trace,"SLICE"
      0  1b06					      db	32
      1  1b06		       20		      .byte.b	32
      0  1b07					      db	(S16Trace-*)-1
      1  1b07		       11		      .byte.b	(S16Trace-*)-1
      0  1b08					      db	"SLICE",0
      1  1b08		       53 4c 49 43*	      .byte.b	"SLICE",0
      0  1b0e					      CALL	EXPR
      0  1b0e					      db	28
      1  1b0e		       1c		      .byte.b	28
      0  1b0f					      dw	EXPR
      1  1b0f		       73 1b		      .word.w	EXPR
      0  1b11					      SLICE
      0  1b11					      db	100
      1  1b11		       64		      .byte.b	100
      0  1b12					      DONE
      0  1b12					      db	1
      1  1b12		       01		      .byte.b	1
      0  1b13					      NXT	CO
      0  1b13					      db	6
      1  1b13		       06		      .byte.b	6
      0  1b14					      dw	CO
      1  1b14		       dd 18		      .word.w	CO
      0  1b16					      IJMP	STMT
      0  1b16					      db	29
      1  1b16		       1d		      .byte.b	29
      0  1b17					      dw	STMT
      1  1b17		       e5 18		      .word.w	STMT
    330  1b19
    331  1b19				   S16Trace
      0  1b19					      TST	S17A,"TRACE("	;Are we going to trace
      0  1b19					      db	32
      1  1b19		       20		      .byte.b	32
      0  1b1a					      db	(S17A-*)-1
      1  1b1a		       16		      .byte.b	(S17A-*)-1
      0  1b1b					      db	"TRACE(",0
      1  1b1b		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  1b22					      CALL	EXPR
      0  1b22					      db	28
      1  1b22		       1c		      .byte.b	28
      0  1b23					      dw	EXPR
      1  1b23		       73 1b		      .word.w	EXPR
      0  1b25					      TST	UNKNOWN,")"
      0  1b25					      db	32
      1  1b25		       20		      .byte.b	32
      0  1b26					      db	(UNKNOWN-*)-1
      1  1b26		       48		      .byte.b	(UNKNOWN-*)-1
      0  1b27					      db	")",0
      1  1b27		       29 00		      .byte.b	")",0
      0  1b29					      TRACEPROGRAM
      0  1b29					      db	78
      1  1b29		       4e		      .byte.b	78
      0  1b2a					      DONE
      0  1b2a					      db	1
      1  1b2a		       01		      .byte.b	1
      0  1b2b					      NXT	CO
      0  1b2b					      db	6
      1  1b2b		       06		      .byte.b	6
      0  1b2c					      dw	CO
      1  1b2c		       dd 18		      .word.w	CO
      0  1b2e					      IJMP	STMT
      0  1b2e					      db	29
      1  1b2e		       1d		      .byte.b	29
      0  1b2f					      dw	STMT
      1  1b2f		       e5 18		      .word.w	STMT
    339  1b31
    340  1b31				   S17A
      0  1b31					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  1b31					      db	32
      1  1b31		       20		      .byte.b	32
      0  1b32					      db	(S17B-*)-1
      1  1b32		       06		      .byte.b	(S17B-*)-1
      0  1b33					      db	"EXIT",0
      1  1b33		       45 58 49 54*	      .byte.b	"EXIT",0
      0  1b38					      EXIT
      0  1b38					      db	26
      1  1b38		       1a		      .byte.b	26
    343  1b39
    344  1b39							;
    345  1b39							; Commands related to saving/restoring programs
    346  1b39							; to/from mass storage.
    347  1b39							;
    348  1b39				   S17B
    349  1b39					      if	(XKIM || CTMON65) && DISK_ACCESS
    350  1b39
      0  1b39					      TST	S17C,"SAVE"
      0  1b39					      db	32
      1  1b39		       20		      .byte.b	32
      0  1b3a					      db	(S17C-*)-1
      1  1b3a		       0b		      .byte.b	(S17C-*)-1
      0  1b3b					      db	"SAVE",0
      1  1b3b		       53 41 56 45*	      .byte.b	"SAVE",0
      0  1b40					      OPENWRITE
      0  1b40					      db	40
      1  1b40		       28		      .byte.b	40
      0  1b41					      DLIST
      0  1b41					      db	43
      1  1b41		       2b		      .byte.b	43
      0  1b42					      DCLOSE
      0  1b42					      db	41
      1  1b42		       29		      .byte.b	41
      0  1b43					      IJMP	CO
      0  1b43					      db	29
      1  1b43		       1d		      .byte.b	29
      0  1b44					      dw	CO
      1  1b44		       dd 18		      .word.w	CO
    356  1b46
    357  1b46				   S17C
      0  1b46					      TST	S18,"LOAD"
      0  1b46					      db	32
      1  1b46		       20		      .byte.b	32
      0  1b47					      db	(S18-*)-1
      1  1b47		       11		      .byte.b	(S18-*)-1
      0  1b48					      db	"LOAD",0
      1  1b48		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  1b4d					      OPENREAD
      0  1b4d					      db	39
      1  1b4d		       27		      .byte.b	39
    360  1b4e				   S17CLP
      0  1b4e					      DGETLINE		;get line from file
      0  1b4e					      db	42
      1  1b4e		       2a		      .byte.b	42
      0  1b4f					      TSTL	S17EOL	;no line num means EOL
      0  1b4f					      db	34
      1  1b4f		       22		      .byte.b	34
      0  1b50					      db	(S17EOL-*)-1
      1  1b50		       04		      .byte.b	(S17EOL-*)-1
      0  1b51					      INSERT		;put it into the program
      0  1b51					      db	24
      1  1b51		       18		      .byte.b	24
      0  1b52					      IJMP	S17CLP	;keep going
      0  1b52					      db	29
      1  1b52		       1d		      .byte.b	29
      0  1b53					      dw	S17CLP
      1  1b53		       4e 1b		      .word.w	S17CLP
    365  1b55				   S17EOL
      0  1b55					      DCLOSE		;close disk file
      0  1b55					      db	41
      1  1b55		       29		      .byte.b	41
      0  1b56					      IJMP	CO	;back to start
      0  1b56					      db	29
      1  1b56		       1d		      .byte.b	29
      0  1b57					      dw	CO
      1  1b57		       dd 18		      .word.w	CO
    368  1b59
    369  1b59				   S18
      0  1b59					      TST	S19,"DIR"
      0  1b59					      db	32
      1  1b59		       20		      .byte.b	32
      0  1b5a					      db	(S19-*)-1
      1  1b5a		       08		      .byte.b	(S19-*)-1
      0  1b5b					      db	"DIR",0
      1  1b5b		       44 49 52 00	      .byte.b	"DIR",0
      0  1b5f					      DDIR		;Display the directory content
      0  1b5f					      db	44
      1  1b5f		       2c		      .byte.b	44
      0  1b60					      IJMP	CO
      0  1b60					      db	29
      1  1b60		       1d		      .byte.b	29
      0  1b61					      dw	CO
      1  1b61		       dd 18		      .word.w	CO
    373  1b63					      endif
    374  1b63
      0  1b63				   S19	      TST	UNKNOWN,"ERASE"
      0  1b63					      db	32
      1  1b63		       20		      .byte.b	32
      0  1b64					      db	(UNKNOWN-*)-1
      1  1b64		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1b65					      db	"ERASE",0
      1  1b65		       45 52 41 53*	      .byte.b	"ERASE",0
      0  1b6b					      RMFILE		;Erase the file from the disk
      0  1b6b					      db	45
      1  1b6b		       2d		      .byte.b	45
      0  1b6c					      IJMP	CO
      0  1b6c					      db	29
      1  1b6c		       1d		      .byte.b	29
      0  1b6d					      dw	CO
      1  1b6d		       dd 18		      .word.w	CO
    378  1b6d					      endif
    379  1b6f
    380  1b6f							;
    381  1b6f							; Else, unknown command.
    382  1b6f							;
    383  1b6f				   UNKNOWN
      0  1b6f					      ENDIO
      0  1b6f					      db	71
      1  1b6f		       47		      .byte.b	71
      0  1b70					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1b70					      db	13
      1  1b70		       0d		      .byte.b	13
      0  1b71					      dw	ERR_SYNTAX
      1  1b71		       05 00		      .word.w	ERR_SYNTAX
    386  1b73
    387  1b73							;-----------------------------------------------------
    388  1b73				   EXPR
      0  1b73					      TST	EXPRNOT,"NOT"
      0  1b73					      db	32
      1  1b73		       20		      .byte.b	32
      0  1b74					      db	(EXPRNOT-*)-1
      1  1b74		       09		      .byte.b	(EXPRNOT-*)-1
      0  1b75					      db	"NOT",0
      1  1b75		       4e 4f 54 00	      .byte.b	"NOT",0
      0  1b79					      Call	EXPR
      0  1b79					      db	28
      1  1b79		       1c		      .byte.b	28
      0  1b7a					      dw	EXPR
      1  1b7a		       73 1b		      .word.w	EXPR
      0  1b7c					      LOGNOT
      0  1b7c					      db	72
      1  1b7c		       48		      .byte.b	72
      0  1b7d					      RTN
      0  1b7d					      db	25
      1  1b7d		       19		      .byte.b	25
    393  1b7e				   EXPRNOT
    394  1b7e
    395  1b7e				   EXPRLOGS
      0  1b7e					      Call	EXPRCMP
      0  1b7e					      db	28
      1  1b7e		       1c		      .byte.b	28
      0  1b7f					      dw	EXPRCMP
      1  1b7f		       a2 1b		      .word.w	EXPRCMP
      0  1b81					      TST	iLOG1,"AND"
      0  1b81					      db	32
      1  1b81		       20		      .byte.b	32
      0  1b82					      db	(iLOG1-*)-1
      1  1b82		       09		      .byte.b	(iLOG1-*)-1
      0  1b83					      db	"AND",0
      1  1b83		       41 4e 44 00	      .byte.b	"AND",0
      0  1b87					      Call	EXPR
      0  1b87					      db	28
      1  1b87		       1c		      .byte.b	28
      0  1b88					      dw	EXPR
      1  1b88		       73 1b		      .word.w	EXPR
      0  1b8a					      LOGAND
      0  1b8a					      db	74
      1  1b8a		       4a		      .byte.b	74
      0  1b8b					      RTN
      0  1b8b					      db	25
      1  1b8b		       19		      .byte.b	25
    401  1b8c				   iLOG1
      0  1b8c					      TST	iLOG2,"OR"
      0  1b8c					      db	32
      1  1b8c		       20		      .byte.b	32
      0  1b8d					      db	(iLOG2-*)-1
      1  1b8d		       08		      .byte.b	(iLOG2-*)-1
      0  1b8e					      db	"OR",0
      1  1b8e		       4f 52 00 	      .byte.b	"OR",0
      0  1b91					      Call	EXPR
      0  1b91					      db	28
      1  1b91		       1c		      .byte.b	28
      0  1b92					      dw	EXPR
      1  1b92		       73 1b		      .word.w	EXPR
      0  1b94					      LOGOR
      0  1b94					      db	73
      1  1b94		       49		      .byte.b	73
      0  1b95					      RTN
      0  1b95					      db	25
      1  1b95		       19		      .byte.b	25
    406  1b96				   iLOG2
      0  1b96					      TST	iLOG3,"XOR"
      0  1b96					      db	32
      1  1b96		       20		      .byte.b	32
      0  1b97					      db	(iLOG3-*)-1
      1  1b97		       09		      .byte.b	(iLOG3-*)-1
      0  1b98					      db	"XOR",0
      1  1b98		       58 4f 52 00	      .byte.b	"XOR",0
      0  1b9c					      Call	EXPR
      0  1b9c					      db	28
      1  1b9c		       1c		      .byte.b	28
      0  1b9d					      dw	EXPR
      1  1b9d		       73 1b		      .word.w	EXPR
      0  1b9f					      LOGXOR
      0  1b9f					      db	75
      1  1b9f		       4b		      .byte.b	75
      0  1ba0					      RTN
      0  1ba0					      db	25
      1  1ba0		       19		      .byte.b	25
    411  1ba1				   iLOG3
      0  1ba1					      RTN
      0  1ba1					      db	25
      1  1ba1		       19		      .byte.b	25
    413  1ba2
    414  1ba2				   EXPRCMP
      0  1ba2					      Call	EXPR2	; get the first expression
      0  1ba2					      db	28
      1  1ba2		       1c		      .byte.b	28
      0  1ba3					      dw	EXPR2
      1  1ba3		       ed 1b		      .word.w	EXPR2
      0  1ba5					      TST	iR0,"="
      0  1ba5					      db	32
      1  1ba5		       20		      .byte.b	32
      0  1ba6					      db	(iR0-*)-1
      1  1ba6		       08		      .byte.b	(iR0-*)-1
      0  1ba7					      db	"=",0
      1  1ba7		       3d 00		      .byte.b	"=",0
      0  1ba9					      LIT	2	;=
      0  1ba9					      db	27
      1  1ba9		       1b		      .byte.b	27
      0  1baa					      dw	2
      1  1baa		       02 00		      .word.w	2
      0  1bac					      IJMP	iRFound
      0  1bac					      db	29
      1  1bac		       1d		      .byte.b	29
      0  1bad					      dw	iRFound
      1  1bad		       e8 1b		      .word.w	iRFound
    419  1baf				   iR0
      0  1baf					      TST	iR4,"<"
      0  1baf					      db	32
      1  1baf		       20		      .byte.b	32
      0  1bb0					      db	(iR4-*)-1
      1  1bb0		       1c		      .byte.b	(iR4-*)-1
      0  1bb1					      db	"<",0
      1  1bb1		       3c 00		      .byte.b	"<",0
      0  1bb3					      TST	iR1,"="
      0  1bb3					      db	32
      1  1bb3		       20		      .byte.b	32
      0  1bb4					      db	(iR1-*)-1
      1  1bb4		       08		      .byte.b	(iR1-*)-1
      0  1bb5					      db	"=",0
      1  1bb5		       3d 00		      .byte.b	"=",0
      0  1bb7					      LIT	3	;<=
      0  1bb7					      db	27
      1  1bb7		       1b		      .byte.b	27
      0  1bb8					      dw	3
      1  1bb8		       03 00		      .word.w	3
      0  1bba					      IJMP	iRFound
      0  1bba					      db	29
      1  1bba		       1d		      .byte.b	29
      0  1bbb					      dw	iRFound
      1  1bbb		       e8 1b		      .word.w	iRFound
    424  1bbd				   iR1
      0  1bbd					      TST	iR3,">"
      0  1bbd					      db	32
      1  1bbd		       20		      .byte.b	32
      0  1bbe					      db	(iR3-*)-1
      1  1bbe		       08		      .byte.b	(iR3-*)-1
      0  1bbf					      db	">",0
      1  1bbf		       3e 00		      .byte.b	">",0
      0  1bc1					      LIT	5	;<>
      0  1bc1					      db	27
      1  1bc1		       1b		      .byte.b	27
      0  1bc2					      dw	5
      1  1bc2		       05 00		      .word.w	5
      0  1bc4					      IJMP	iRFound
      0  1bc4					      db	29
      1  1bc4		       1d		      .byte.b	29
      0  1bc5					      dw	iRFound
      1  1bc5		       e8 1b		      .word.w	iRFound
    428  1bc7				   iR3
      0  1bc7					      LIT	1	;<
      0  1bc7					      db	27
      1  1bc7		       1b		      .byte.b	27
      0  1bc8					      dw	1
      1  1bc8		       01 00		      .word.w	1
      0  1bca					      IJMP	iRFound
      0  1bca					      db	29
      1  1bca		       1d		      .byte.b	29
      0  1bcb					      dw	iRFound
      1  1bcb		       e8 1b		      .word.w	iRFound
    431  1bcd				   iR4
      0  1bcd					      TST	iRDone,">"
      0  1bcd					      db	32
      1  1bcd		       20		      .byte.b	32
      0  1bce					      db	(iRDone-*)-1
      1  1bce		       1d		      .byte.b	(iRDone-*)-1
      0  1bcf					      db	">",0
      1  1bcf		       3e 00		      .byte.b	">",0
      0  1bd1					      TST	iR5,"="
      0  1bd1					      db	32
      1  1bd1		       20		      .byte.b	32
      0  1bd2					      db	(iR5-*)-1
      1  1bd2		       08		      .byte.b	(iR5-*)-1
      0  1bd3					      db	"=",0
      1  1bd3		       3d 00		      .byte.b	"=",0
      0  1bd5					      LIT	6	;>=
      0  1bd5					      db	27
      1  1bd5		       1b		      .byte.b	27
      0  1bd6					      dw	6
      1  1bd6		       06 00		      .word.w	6
      0  1bd8					      IJMP	iRFound
      0  1bd8					      db	29
      1  1bd8		       1d		      .byte.b	29
      0  1bd9					      dw	iRFound
      1  1bd9		       e8 1b		      .word.w	iRFound
    436  1bdb				   iR5
      0  1bdb					      TST	iR6,"<"
      0  1bdb					      db	32
      1  1bdb		       20		      .byte.b	32
      0  1bdc					      db	(iR6-*)-1
      1  1bdc		       08		      .byte.b	(iR6-*)-1
      0  1bdd					      db	"<",0
      1  1bdd		       3c 00		      .byte.b	"<",0
      0  1bdf					      LIT	1
      0  1bdf					      db	27
      1  1bdf		       1b		      .byte.b	27
      0  1be0					      dw	1
      1  1be0		       01 00		      .word.w	1
      0  1be2					      IJMP	iRFound	;(This line originally omitted)
      0  1be2					      db	29
      1  1be2		       1d		      .byte.b	29
      0  1be3					      dw	iRFound
      1  1be3		       e8 1b		      .word.w	iRFound
    440  1be5				   iR6
      0  1be5					      LIT	4	;>
      0  1be5					      db	27
      1  1be5		       1b		      .byte.b	27
      0  1be6					      dw	4
      1  1be6		       04 00		      .word.w	4
    442  1be8				   iRFound
      0  1be8					      Call	EXPR2	; get the right side of the expression
      0  1be8					      db	28
      1  1be8		       1c		      .byte.b	28
      0  1be9					      dw	EXPR2
      1  1be9		       ed 1b		      .word.w	EXPR2
      0  1beb					      CMPR		; Push the value of the true false onto the stack
      0  1beb					      db	10
      1  1beb		       0a		      .byte.b	10
    445  1bec
    446  1bec				   iRDone
      0  1bec					      RTN
      0  1bec					      db	25
      1  1bec		       19		      .byte.b	25
    448  1bed
    449  1bed				   EXPR2
      0  1bed					      TST	E0,"-"	; Look for leading - to negate term
      0  1bed					      db	32
      1  1bed		       20		      .byte.b	32
      0  1bee					      db	(E0-*)-1
      1  1bee		       09		      .byte.b	(E0-*)-1
      0  1bef					      db	"-",0
      1  1bef		       2d 00		      .byte.b	"-",0
      0  1bf1					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1bf1					      db	28
      1  1bf1		       1c		      .byte.b	28
      0  1bf2					      dw	TERM
      1  1bf2		       16 1c		      .word.w	TERM
      0  1bf4					      NEG		; Make value negated
      0  1bf4					      db	16
      1  1bf4		       10		      .byte.b	16
      0  1bf5					      IJMP	E1	; We have Left term process operators next
      0  1bf5					      db	29
      1  1bf5		       1d		      .byte.b	29
      0  1bf6					      dw	E1
      1  1bf6		       ff 1b		      .word.w	E1
    454  1bf8				   E0
      0  1bf8					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1bf8					      db	32
      1  1bf8		       20		      .byte.b	32
      0  1bf9					      db	(E1A-*)-1
      1  1bf9		       02		      .byte.b	(E1A-*)-1
      0  1bfa					      db	"+",0
      1  1bfa		       2b 00		      .byte.b	"+",0
    456  1bfc				   E1A
      0  1bfc					      CALL	TERM	; Get the left term if it was not negated
      0  1bfc					      db	28
      1  1bfc		       1c		      .byte.b	28
      0  1bfd					      dw	TERM
      1  1bfd		       16 1c		      .word.w	TERM
    458  1bff				   E1
      0  1bff					      TST	E2,"+"	; Check if we are adding left term to something
      0  1bff					      db	32
      1  1bff		       20		      .byte.b	32
      0  1c00					      db	(E2-*)-1
      1  1c00		       09		      .byte.b	(E2-*)-1
      0  1c01					      db	"+",0
      1  1c01		       2b 00		      .byte.b	"+",0
      0  1c03					      CALL	TERM	; if adding then get the right side term
      0  1c03					      db	28
      1  1c03		       1c		      .byte.b	28
      0  1c04					      dw	TERM
      1  1c04		       16 1c		      .word.w	TERM
      0  1c06					      ADD		; Add it to left term
      0  1c06					      db	14
      1  1c06		       0e		      .byte.b	14
      0  1c07					      IJMP	E1	; look for next + or -
      0  1c07					      db	29
      1  1c07		       1d		      .byte.b	29
      0  1c08					      dw	E1
      1  1c08		       ff 1b		      .word.w	E1
    463  1c0a				   E2
      0  1c0a					      TST	E3,"-"	; Check if we are subtractig something
      0  1c0a					      db	32
      1  1c0a		       20		      .byte.b	32
      0  1c0b					      db	(E3-*)-1
      1  1c0b		       09		      .byte.b	(E3-*)-1
      0  1c0c					      db	"-",0
      1  1c0c		       2d 00		      .byte.b	"-",0
      0  1c0e					      CALL	TERM	; get right side to subtract Diffrence
      0  1c0e					      db	28
      1  1c0e		       1c		      .byte.b	28
      0  1c0f					      dw	TERM
      1  1c0f		       16 1c		      .word.w	TERM
      0  1c11					      SUB		; Subtract the value
      0  1c11					      db	15
      1  1c11		       0f		      .byte.b	15
      0  1c12					      IJMP	E1	; Look for next + or -
      0  1c12					      db	29
      1  1c12		       1d		      .byte.b	29
      0  1c13					      dw	E1
      1  1c13		       ff 1b		      .word.w	E1
    468  1c15				   E3			; Finish processing the expression
      0  1c15					      RTN		; We are finished processing the Expression
      0  1c15					      db	25
      1  1c15		       19		      .byte.b	25
    470  1c16							;
    471  1c16							; Get one of the terms of an expression
    472  1c16							;
    473  1c16				   TERM
      0  1c16					      CALL	FACT	; Get a value
      0  1c16					      db	28
      1  1c16		       1c		      .byte.b	28
      0  1c17					      dw	FACT
      1  1c17		       3e 1c		      .word.w	FACT
    475  1c19				   T0			; Check for higher precidence operators
      0  1c19					      TST	T1,"*"	; Check for *
      0  1c19					      db	32
      1  1c19		       20		      .byte.b	32
      0  1c1a					      db	(T1-*)-1
      1  1c1a		       09		      .byte.b	(T1-*)-1
      0  1c1b					      db	"*",0
      1  1c1b		       2a 00		      .byte.b	"*",0
      0  1c1d					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  1c1d					      db	28
      1  1c1d		       1c		      .byte.b	28
      0  1c1e					      dw	FACT
      1  1c1e		       3e 1c		      .word.w	FACT
      0  1c20					      MUL		; Multiply factors
      0  1c20					      db	17
      1  1c20		       11		      .byte.b	17
      0  1c21					      IJMP	T0	; Check for * or /
      0  1c21					      db	29
      1  1c21		       1d		      .byte.b	29
      0  1c22					      dw	T0
      1  1c22		       19 1c		      .word.w	T0
    480  1c24				   T1
      0  1c24					      TST	T2,"/"	; Check for a division
      0  1c24					      db	32
      1  1c24		       20		      .byte.b	32
      0  1c25					      db	(T2-*)-1
      1  1c25		       09		      .byte.b	(T2-*)-1
      0  1c26					      db	"/",0
      1  1c26		       2f 00		      .byte.b	"/",0
      0  1c28					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c28					      db	28
      1  1c28		       1c		      .byte.b	28
      0  1c29					      dw	FACT
      1  1c29		       3e 1c		      .word.w	FACT
      0  1c2b					      DIV		; do division
      0  1c2b					      db	18
      1  1c2b		       12		      .byte.b	18
      0  1c2c					      IJMP	T0	; check for more * or /
      0  1c2c					      db	29
      1  1c2c		       1d		      .byte.b	29
      0  1c2d					      dw	T0
      1  1c2d		       19 1c		      .word.w	T0
    485  1c2f				   T2
      0  1c2f					      TST	T3,"%"	; Check for a division
      0  1c2f					      db	32
      1  1c2f		       20		      .byte.b	32
      0  1c30					      db	(T3-*)-1
      1  1c30		       09		      .byte.b	(T3-*)-1
      0  1c31					      db	"%",0
      1  1c31		       25 00		      .byte.b	"%",0
      0  1c33					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1c33					      db	28
      1  1c33		       1c		      .byte.b	28
      0  1c34					      dw	FACT
      1  1c34		       3e 1c		      .word.w	FACT
      0  1c36					      MODULO		; do division for remainder
      0  1c36					      db	60
      1  1c36		       3c		      .byte.b	60
      0  1c37					      IJMP	T0	; check for more * or / or %
      0  1c37					      db	29
      1  1c37		       1d		      .byte.b	29
      0  1c38					      dw	T0
      1  1c38		       19 1c		      .word.w	T0
    490  1c3a				   T3			; Finish processing the Term
      0  1c3a					      RTN
      0  1c3a					      db	25
      1  1c3a		       19		      .byte.b	25
    492  1c3b
    493  1c3b				   UNKNOWNVEC
      0  1c3b					      IJMP	UNKNOWN
      0  1c3b					      db	29
      1  1c3b		       1d		      .byte.b	29
      0  1c3c					      dw	UNKNOWN
      1  1c3c		       6f 1b		      .word.w	UNKNOWN
    495  1c3e
    496  1c3e							;
    497  1c3e							; Factor an expression.  Always test for functions
    498  1c3e							; first or else they'll be confused for variables.
    499  1c3e							;
    500  1c3e				   FACT
      0  1c3e					      TST	F1AA,"TRUE"
      0  1c3e					      db	32
      1  1c3e		       20		      .byte.b	32
      0  1c3f					      db	(F1AA-*)-1
      1  1c3f		       09		      .byte.b	(F1AA-*)-1
      0  1c40					      db	"TRUE",0
      1  1c40		       54 52 55 45*	      .byte.b	"TRUE",0
      0  1c45					      LIT	-1
      0  1c45					      db	27
      1  1c45		       1b		      .byte.b	27
      0  1c46					      dw	-1
      1  1c46		       ff ff		      .word.w	-1
      0  1c48					      RTN
      0  1c48					      db	25
      1  1c48		       19		      .byte.b	25
    504  1c49				   F1AA
      0  1c49					      TST	F1AB,"FALSE"
      0  1c49					      db	32
      1  1c49		       20		      .byte.b	32
      0  1c4a					      db	(F1AB-*)-1
      1  1c4a		       0a		      .byte.b	(F1AB-*)-1
      0  1c4b					      db	"FALSE",0
      1  1c4b		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  1c51					      LIT	0
      0  1c51					      db	27
      1  1c51		       1b		      .byte.b	27
      0  1c52					      dw	0
      1  1c52		       00 00		      .word.w	0
      0  1c54					      RTN
      0  1c54					      db	25
      1  1c54		       19		      .byte.b	25
    508  1c55				   F1AB
      0  1c55					      TST	F1A,"FREE()"
      0  1c55					      db	32
      1  1c55		       20		      .byte.b	32
      0  1c56					      db	(F1A-*)-1
      1  1c56		       09		      .byte.b	(F1A-*)-1
      0  1c57					      db	"FREE()",0
      1  1c57		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1c5e					      FREE
      0  1c5e					      db	36
      1  1c5e		       24		      .byte.b	36
      0  1c5f					      RTN
      0  1c5f					      db	25
      1  1c5f		       19		      .byte.b	25
    512  1c60				   F1A
      0  1c60					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1c60					      db	32
      1  1c60		       20		      .byte.b	32
      0  1c61					      db	(F1A2-*)-1
      1  1c61		       0a		      .byte.b	(F1A2-*)-1
      0  1c62					      db	"GETCH()",0
      1  1c62		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  1c6a					      GETCHAR
      0  1c6a					      db	51
      1  1c6a		       33		      .byte.b	51
      0  1c6b					      RTN
      0  1c6b					      db	25
      1  1c6b		       19		      .byte.b	25
    516  1c6c				   F1A2
      0  1c6c					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  1c6c					      db	32
      1  1c6c		       20		      .byte.b	32
      0  1c6d					      db	(F2AZ-*)-1
      1  1c6d		       0f		      .byte.b	(F2AZ-*)-1
      0  1c6e					      db	"PEEK(",0
      1  1c6e		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1c74					      CALL	EXPR	;Get the address to write to
      0  1c74					      db	28
      1  1c74		       1c		      .byte.b	28
      0  1c75					      dw	EXPR
      1  1c75		       73 1b		      .word.w	EXPR
      0  1c77					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  1c77					      db	32
      1  1c77		       20		      .byte.b	32
      0  1c78					      db	(UNKNOWNVEC-*)-1
      1  1c78		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c79					      db	")",0
      1  1c79		       29 00		      .byte.b	")",0
      0  1c7b					      PEEKMEM
      0  1c7b					      db	48
      1  1c7b		       30		      .byte.b	48
      0  1c7c					      RTN
      0  1c7c					      db	25
      1  1c7c		       19		      .byte.b	25
    522  1c7d				   F2AZ
      0  1c7d					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  1c7d					      db	32
      1  1c7d		       20		      .byte.b	32
      0  1c7e					      db	(F2AZ1-*)-1
      1  1c7e		       22		      .byte.b	(F2AZ1-*)-1
      0  1c7f					      db	"TASK(",0
      1  1c7f		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  1c85					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1c85					      db	28
      1  1c85		       1c		      .byte.b	28
      0  1c86					      dw	EXPR
      1  1c86		       73 1b		      .word.w	EXPR
      0  1c88					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  1c88					      db	61
      1  1c88		       3d		      .byte.b	61
      0  1c89					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  1c89					      db	32
      1  1c89		       20		      .byte.b	32
      0  1c8a					      db	(F2AZNoParms-*)-1
      1  1c8a		       10		      .byte.b	(F2AZNoParms-*)-1
      0  1c8b					      db	COMMA,0
      1  1c8b		       2c 00		      .byte.b	COMMA,0
      0  1c8d					      SAVEMATHSTACK		;Push The mathstack
      0  1c8d					      db	86
      1  1c8d		       56		      .byte.b	86
      0  1c8e					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  1c8e					      db	89
      1  1c8e		       59		      .byte.b	89
    529  1c8f				   F2AZLOOP
      0  1c8f					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  1c8f					      db	28
      1  1c8f		       1c		      .byte.b	28
      0  1c90					      dw	EXPR
      1  1c90		       73 1b		      .word.w	EXPR
      0  1c92					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  1c92					      db	32
      1  1c92		       20		      .byte.b	32
      0  1c93					      db	(F2AZEndParm-*)-1
      1  1c93		       05		      .byte.b	(F2AZEndParm-*)-1
      0  1c94					      db	COMMA,0
      1  1c94		       2c 00		      .byte.b	COMMA,0
      0  1c96					      IJMP	F2AZLOOP	;check for more
      0  1c96					      db	29
      1  1c96		       1d		      .byte.b	29
      0  1c97					      dw	F2AZLOOP
      1  1c97		       8f 1c		      .word.w	F2AZLOOP
    533  1c99				   F2AZEndParm
      0  1c99					      RESTOREMATHSTACK		;Back to normal stack
      0  1c99					      db	87
      1  1c99		       57		      .byte.b	87
      0  1c9a					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  1c9a					      db	92
      1  1c9a		       5c		      .byte.b	92
    536  1c9b				   F2AZNoParms
      0  1c9b					      TST	UNKNOWNVEC,")"	;must be )
      0  1c9b					      db	32
      1  1c9b		       20		      .byte.b	32
      0  1c9c					      db	(UNKNOWNVEC-*)-1
      1  1c9c		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1c9d					      db	")",0
      1  1c9d		       29 00		      .byte.b	")",0
      0  1c9f					      TASKENABLE		;Enable the task to execute
      0  1c9f					      db	90
      1  1c9f		       5a		      .byte.b	90
      0  1ca0					      RTN		;Returns the Task number
      0  1ca0					      db	25
      1  1ca0		       19		      .byte.b	25
    540  1ca1				   F2AZ1
      0  1ca1					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  1ca1					      db	32
      1  1ca1		       20		      .byte.b	32
      0  1ca2					      db	(F2A-*)-1
      1  1ca2		       3c		      .byte.b	(F2A-*)-1
      0  1ca3					      db	"IPC",0
      1  1ca3		       49 50 43 00	      .byte.b	"IPC",0
      0  1ca7					      TST	F2AZa,"S("	;IPCS - send a message
      0  1ca7					      db	32
      1  1ca7		       20		      .byte.b	32
      0  1ca8					      db	(F2AZa-*)-1
      1  1ca8		       13		      .byte.b	(F2AZa-*)-1
      0  1ca9					      db	"S(",0
      1  1ca9		       53 28 00 	      .byte.b	"S(",0
      0  1cac					      CALL	EXPR	;Get the message value
      0  1cac					      db	28
      1  1cac		       1c		      .byte.b	28
      0  1cad					      dw	EXPR
      1  1cad		       73 1b		      .word.w	EXPR
      0  1caf					      TST	UNKNOWNVEC,COMMA
      0  1caf					      db	32
      1  1caf		       20		      .byte.b	32
      0  1cb0					      db	(UNKNOWNVEC-*)-1
      1  1cb0		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cb1					      db	COMMA,0
      1  1cb1		       2c 00		      .byte.b	COMMA,0
      0  1cb3					      CALL	EXPR	;Get pid of task to send to
      0  1cb3					      db	28
      1  1cb3		       1c		      .byte.b	28
      0  1cb4					      dw	EXPR
      1  1cb4		       73 1b		      .word.w	EXPR
      0  1cb6					      TST	UNKNOWNVEC,")"
      0  1cb6					      db	32
      1  1cb6		       20		      .byte.b	32
      0  1cb7					      db	(UNKNOWNVEC-*)-1
      1  1cb7		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cb8					      db	")",0
      1  1cb8		       29 00		      .byte.b	")",0
      0  1cba					      IPCSEND		;Send msg and clear pid msg pending
      0  1cba					      db	80
      1  1cba		       50		      .byte.b	80
      0  1cbb					      RTN
      0  1cbb					      db	25
      1  1cbb		       19		      .byte.b	25
    549  1cbc				   F2AZa
      0  1cbc					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  1cbc					      db	32
      1  1cbc		       20		      .byte.b	32
      0  1cbd					      db	(F2AZb-*)-1
      1  1cbd		       16		      .byte.b	(F2AZb-*)-1
      0  1cbe					      db	"R(",0
      1  1cbe		       52 28 00 	      .byte.b	"R(",0
      0  1cc1					      TST	F2AZa1,")"
      0  1cc1					      db	32
      1  1cc1		       20		      .byte.b	32
      0  1cc2					      db	(F2AZa1-*)-1
      1  1cc2		       08		      .byte.b	(F2AZa1-*)-1
      0  1cc3					      db	")",0
      1  1cc3		       29 00		      .byte.b	")",0
      0  1cc5					      LIT	0	;We dont want the pid returned to us
      0  1cc5					      db	27
      1  1cc5		       1b		      .byte.b	27
      0  1cc6					      dw	0
      1  1cc6		       00 00		      .word.w	0
      0  1cc8					      IPCIO		;Set the io bit and suspend the task till message
      0  1cc8					      db	83
      1  1cc8		       53		      .byte.b	83
      0  1cc9					      IPCRECEIVE		;Get the message
      0  1cc9					      db	81
      1  1cc9		       51		      .byte.b	81
      0  1cca					      RTN
      0  1cca					      db	25
      1  1cca		       19		      .byte.b	25
    556  1ccb				   F2AZa1
      0  1ccb					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  1ccb					      db	33
      1  1ccb		       21		      .byte.b	33
      0  1ccc					      db	(UNKNOWNVEC-*)-1
      1  1ccc		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  1ccd					      TST	UNKNOWNVEC,")"
      0  1ccd					      db	32
      1  1ccd		       20		      .byte.b	32
      0  1cce					      db	(UNKNOWNVEC-*)-1
      1  1cce		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  1ccf					      db	")",0
      1  1ccf		       29 00		      .byte.b	")",0
      0  1cd1					      IPCIO		;Set the io bit and exit task till message
      0  1cd1					      db	83
      1  1cd1		       53		      .byte.b	83
      0  1cd2					      IPCRECEIVE		;Get the message
      0  1cd2					      db	81
      1  1cd2		       51		      .byte.b	81
      0  1cd3					      RTN
      0  1cd3					      db	25
      1  1cd3		       19		      .byte.b	25
    562  1cd4				   F2AZb
      0  1cd4					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  1cd4					      db	32
      1  1cd4		       20		      .byte.b	32
      0  1cd5					      db	(UNKNOWNVEC-*)-1
      1  1cd5		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cd6					      db	"C()",0
      1  1cd6		       43 28 29 00	      .byte.b	"C()",0
      0  1cda					      IPCCHECK
      0  1cda					      db	82
      1  1cda		       52		      .byte.b	82
      0  1cdb					      RTN
      0  1cdb					      db	25
      1  1cdb		       19		      .byte.b	25
    566  1cdc
    567  1cdc				   UNKNOWNID
      0  1cdc					      IJMP	UNKNOWN
      0  1cdc					      db	29
      1  1cdc		       1d		      .byte.b	29
      0  1cdd					      dw	UNKNOWN
      1  1cdd		       6f 1b		      .word.w	UNKNOWN
    569  1cdf							;
    570  1cdf							; RND() is supposed to have an argument but if none
    571  1cdf							; was provided, just assume a large value.
    572  1cdf							;
    573  1cdf				   F2A
      0  1cdf					      TST	F2B,"RND("
      0  1cdf					      db	32
      1  1cdf		       20		      .byte.b	32
      0  1ce0					      db	(F2B-*)-1
      1  1ce0		       17		      .byte.b	(F2B-*)-1
      0  1ce1					      db	"RND(",0
      1  1ce1		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1ce6					      TST	F2A1,")"
      0  1ce6					      db	32
      1  1ce6		       20		      .byte.b	32
      0  1ce7					      db	(F2A1-*)-1
      1  1ce7		       07		      .byte.b	(F2A1-*)-1
      0  1ce8					      db	")",0
      1  1ce8		       29 00		      .byte.b	")",0
      0  1cea					      LIT	32766
      0  1cea					      db	27
      1  1cea		       1b		      .byte.b	27
      0  1ceb					      dw	32766
      1  1ceb		       fe 7f		      .word.w	32766
      0  1ced					      RANDOM
      0  1ced					      db	37
      1  1ced		       25		      .byte.b	37
      0  1cee					      RTN
      0  1cee					      db	25
      1  1cee		       19		      .byte.b	25
    579  1cef
    580  1cef				   F2A1
      0  1cef					      CALL	FACT	;GET RANGE
      0  1cef					      db	28
      1  1cef		       1c		      .byte.b	28
      0  1cf0					      dw	FACT
      1  1cf0		       3e 1c		      .word.w	FACT
      0  1cf2					      TST	UNKNOWNVEC,")"
      0  1cf2					      db	32
      1  1cf2		       20		      .byte.b	32
      0  1cf3					      db	(UNKNOWNVEC-*)-1
      1  1cf3		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  1cf4					      db	")",0
      1  1cf4		       29 00		      .byte.b	")",0
      0  1cf6					      RANDOM
      0  1cf6					      db	37
      1  1cf6		       25		      .byte.b	37
      0  1cf7					      RTN
      0  1cf7					      db	25
      1  1cf7		       19		      .byte.b	25
    585  1cf8
    586  1cf8				   F2B
      0  1cf8					      TST	F2B2,"ABS("
      0  1cf8					      db	32
      1  1cf8		       20		      .byte.b	32
      0  1cf9					      db	(F2B2-*)-1
      1  1cf9		       0e		      .byte.b	(F2B2-*)-1
      0  1cfa					      db	"ABS(",0
      1  1cfa		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1cff					      CALL	EXPR	;get value
      0  1cff					      db	28
      1  1cff		       1c		      .byte.b	28
      0  1d00					      dw	EXPR
      1  1d00		       73 1b		      .word.w	EXPR
      0  1d02					      TST	UNKNOWNVEC,")"
      0  1d02					      db	32
      1  1d02		       20		      .byte.b	32
      0  1d03					      db	(UNKNOWNVEC-*)-1
      1  1d03		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d04					      db	")",0
      1  1d04		       29 00		      .byte.b	")",0
      0  1d06					      ABS
      0  1d06					      db	38
      1  1d06		       26		      .byte.b	38
      0  1d07					      RTN
      0  1d07					      db	25
      1  1d07		       19		      .byte.b	25
    592  1d08
    593  1d08				   F2B2
      0  1d08					      TST	F2Z,"STAT("
      0  1d08					      db	32
      1  1d08		       20		      .byte.b	32
      0  1d09					      db	(F2Z-*)-1
      1  1d09		       0f		      .byte.b	(F2Z-*)-1
      0  1d0a					      db	"STAT(",0
      1  1d0a		       53 54 41 54*	      .byte.b	"STAT(",0
      0  1d10					      Call	EXPR
      0  1d10					      db	28
      1  1d10		       1c		      .byte.b	28
      0  1d11					      dw	EXPR
      1  1d11		       73 1b		      .word.w	EXPR
      0  1d13					      TST	UNKNOWNVEC,")"
      0  1d13					      db	32
      1  1d13		       20		      .byte.b	32
      0  1d14					      db	(UNKNOWNVEC-*)-1
      1  1d14		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d15					      db	")",0
      1  1d15		       29 00		      .byte.b	")",0
      0  1d17					      TASKSTAT
      0  1d17					      db	66
      1  1d17		       42		      .byte.b	66
      0  1d18					      RTN
      0  1d18					      db	25
      1  1d18		       19		      .byte.b	25
    599  1d19				   F2Z
      0  1d19					      TST	F2ZA,"PID"
      0  1d19					      db	32
      1  1d19		       20		      .byte.b	32
      0  1d1a					      db	(F2ZA-*)-1
      1  1d1a		       06		      .byte.b	(F2ZA-*)-1
      0  1d1b					      db	"PID",0
      1  1d1b		       50 49 44 00	      .byte.b	"PID",0
      0  1d1f					      TASKPID
      0  1d1f					      db	77
      1  1d1f		       4d		      .byte.b	77
      0  1d20					      RTN
      0  1d20					      db	25
      1  1d20		       19		      .byte.b	25
    603  1d21				   F2ZA
      0  1d21					      TST	F2FUNC,"CALL("	;call machine function
      0  1d21					      db	32
      1  1d21		       20		      .byte.b	32
      0  1d22					      db	(F2FUNC-*)-1
      1  1d22		       1f		      .byte.b	(F2FUNC-*)-1
      0  1d23					      db	"CALL(",0
      1  1d23		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1d29					      CALL	EXPR
      0  1d29					      db	28
      1  1d29		       1c		      .byte.b	28
      0  1d2a					      dw	EXPR
      1  1d2a		       73 1b		      .word.w	EXPR
      0  1d2c					      TST	F2B2A,COMMA
      0  1d2c					      db	32
      1  1d2c		       20		      .byte.b	32
      0  1d2d					      db	(F2B2A-*)-1
      1  1d2d		       0b		      .byte.b	(F2B2A-*)-1
      0  1d2e					      db	COMMA,0
      1  1d2e		       2c 00		      .byte.b	COMMA,0
      0  1d30					      CALL	EXPR
      0  1d30					      db	28
      1  1d30		       1c		      .byte.b	28
      0  1d31					      dw	EXPR
      1  1d31		       73 1b		      .word.w	EXPR
      0  1d33					      TST	UNKNOWNVEC,")"
      0  1d33					      db	32
      1  1d33		       20		      .byte.b	32
      0  1d34					      db	(UNKNOWNVEC-*)-1
      1  1d34		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  1d35					      db	")",0
      1  1d35		       29 00		      .byte.b	")",0
      0  1d37					      CALLFUNC
      0  1d37					      db	53
      1  1d37		       35		      .byte.b	53
      0  1d38					      RTN
      0  1d38					      db	25
      1  1d38		       19		      .byte.b	25
    611  1d39							; Run the gosub within this function
    612  1d39				   F2B2A
      0  1d39					      TST	UNKNOWNID,")"
      0  1d39					      db	32
      1  1d39		       20		      .byte.b	32
      0  1d3a					      db	(UNKNOWNID-*)-1
      1  1d3a		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  1d3b					      db	")",0
      1  1d3b		       29 00		      .byte.b	")",0
      0  1d3d					      LIT	0
      0  1d3d					      db	27
      1  1d3d		       1b		      .byte.b	27
      0  1d3e					      dw	0
      1  1d3e		       00 00		      .word.w	0
      0  1d40					      CALLFUNC
      0  1d40					      db	53
      1  1d40		       35		      .byte.b	53
      0  1d41					      RTN
      0  1d41					      db	25
      1  1d41		       19		      .byte.b	25
    617  1d42
      0  1d42				   F2FUNC     TST	F2C,"GOFN"
      0  1d42					      db	32
      1  1d42		       20		      .byte.b	32
      0  1d43					      db	(F2C-*)-1
      1  1d43		       0c		      .byte.b	(F2C-*)-1
      0  1d44					      db	"GOFN",0
      1  1d44		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  1d49					      Call	GOSUBSTATEMENT
      0  1d49					      db	28
      1  1d49		       1c		      .byte.b	28
      0  1d4a					      dw	GOSUBSTATEMENT
      1  1d4a		       79 1d		      .word.w	GOSUBSTATEMENT
      0  1d4c					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  1d4c					      db	8
      1  1d4c		       08		      .byte.b	8
      0  1d4d					      db	GOSUB_RTN_VALUE
      1  1d4d		       81		      .byte.b	GOSUB_RTN_VALUE
      0  1d4e					      XFER
      0  1d4e					      db	7
      1  1d4e		       07		      .byte.b	7
    622  1d4f				   GOFNRet
      0  1d4f					      RTN
      0  1d4f					      db	25
      1  1d4f		       19		      .byte.b	25
    624  1d50				   F2C
      0  1d50					      TSTV	F0
      0  1d50					      db	33
      1  1d50		       21		      .byte.b	33
      0  1d51					      db	(F0-*)-1
      1  1d51		       15		      .byte.b	(F0-*)-1
      0  1d52					      TST	F2CLocalTask,"!"
      0  1d52					      db	32
      1  1d52		       20		      .byte.b	32
      0  1d53					      db	(F2CLocalTask-*)-1
      1  1d53		       05		      .byte.b	(F2CLocalTask-*)-1
      0  1d54					      db	"!",0
      1  1d54		       21 00		      .byte.b	"!",0
      0  1d56					      IND		; we just got a pid
      0  1d56					      db	20
      1  1d56		       14		      .byte.b	20
      0  1d57					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  1d57					      db	93
      1  1d57		       5d		      .byte.b	93
      0  1d58					      db	(UNKNOWNID-*)-1
      1  1d58		       83		      .byte.b	(UNKNOWNID-*)-1
    629  1d59
    630  1d59				   F2CLocalTask
      0  1d59					      TST	F2C1,"["
      0  1d59					      db	32
      1  1d59		       20		      .byte.b	32
      0  1d5a					      db	(F2C1-*)-1
      1  1d5a		       0a		      .byte.b	(F2C1-*)-1
      0  1d5b					      db	"[",0
      1  1d5b		       5b 00		      .byte.b	"[",0
      0  1d5d					      CALL	EXPR
      0  1d5d					      db	28
      1  1d5d		       1c		      .byte.b	28
      0  1d5e					      dw	EXPR
      1  1d5e		       73 1b		      .word.w	EXPR
      0  1d60					      TST	UNKNOWNID,"]"
      0  1d60					      db	32
      1  1d60		       20		      .byte.b	32
      0  1d61					      db	(UNKNOWNID-*)-1
      1  1d61		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  1d62					      db	"]",0
      1  1d62		       5d 00		      .byte.b	"]",0
      0  1d64					      SUBSCRIPT
      0  1d64					      db	64
      1  1d64		       40		      .byte.b	64
    635  1d65				   F2C1
      0  1d65					      IND		;YES, GET THE VALUE.
      0  1d65					      db	20
      1  1d65		       14		      .byte.b	20
      0  1d66					      RTN
      0  1d66					      db	25
      1  1d66		       19		      .byte.b	25
    638  1d67				   F0
      0  1d67					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1d67					      db	35
      1  1d67		       23		      .byte.b	35
      0  1d68					      db	(F1-*)-1
      1  1d68		       01		      .byte.b	(F1-*)-1
      0  1d69					      RTN
      0  1d69					      db	25
      1  1d69		       19		      .byte.b	25
    641  1d6a				   F1
      0  1d6a					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  1d6a					      db	32
      1  1d6a		       20		      .byte.b	32
      0  1d6b					      db	(F2RTN-*)-1
      1  1d6b		       09		      .byte.b	(F2RTN-*)-1
      0  1d6c					      db	"(",0
      1  1d6c		       28 00		      .byte.b	"(",0
      0  1d6e					      CALL	EXPR
      0  1d6e					      db	28
      1  1d6e		       1c		      .byte.b	28
      0  1d6f					      dw	EXPR
      1  1d6f		       73 1b		      .word.w	EXPR
      0  1d71					      TST	F2,")"
      0  1d71					      db	32
      1  1d71		       20		      .byte.b	32
      0  1d72					      db	(F2-*)-1
      1  1d72		       03		      .byte.b	(F2-*)-1
      0  1d73					      db	")",0
      1  1d73		       29 00		      .byte.b	")",0
    645  1d75				   F2RTN
      0  1d75					      RTN
      0  1d75					      db	25
      1  1d75		       19		      .byte.b	25
    647  1d76
    648  1d76				   F2
      0  1d76					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1d76					      db	13
      1  1d76		       0d		      .byte.b	13
      0  1d77					      dw	ERR_SYNTAX
      1  1d77		       05 00		      .word.w	ERR_SYNTAX
    650  1d79							;
    651  1d79							;=============================================================
    652  1d79							; Gosub can be both a Function and a Subroutine
    653  1d79				   GOSUBSTATEMENT
      0  1d79					      CALL	EXPR	;GET DESTINATION
      0  1d79					      db	28
      1  1d79		       1c		      .byte.b	28
      0  1d7a					      dw	EXPR
      1  1d7a		       73 1b		      .word.w	EXPR
      0  1d7c					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  1d7c					      db	32
      1  1d7c		       20		      .byte.b	32
      0  1d7d					      db	(GOSUBDONE-*)-1
      1  1d7d		       14		      .byte.b	(GOSUBDONE-*)-1
      0  1d7e					      db	"(",0
      1  1d7e		       28 00		      .byte.b	"(",0
      0  1d80					      STK2TMP		;Transfer stack top to temp
      0  1d80					      db	95
      1  1d80		       5f		      .byte.b	95
      0  1d81					      PUSHMATHSTACK		;Record stack frame for return
      0  1d81					      db	84
      1  1d81		       54		      .byte.b	84
    658  1d82				   GOSUBLOOP
      0  1d82					      CALL	EXPR	; Allows what ever fits onto stack
      0  1d82					      db	28
      1  1d82		       1c		      .byte.b	28
      0  1d83					      dw	EXPR
      1  1d83		       73 1b		      .word.w	EXPR
      0  1d85					      INCPARMCOUNT
      0  1d85					      db	88
      1  1d85		       58		      .byte.b	88
      0  1d86					      TST	GOSUBParmDONE,COMMA
      0  1d86					      db	32
      1  1d86		       20		      .byte.b	32
      0  1d87					      db	(GOSUBParmDONE-*)-1
      1  1d87		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  1d88					      db	COMMA,0
      1  1d88		       2c 00		      .byte.b	COMMA,0
      0  1d8a					      IJMP	GOSUBLOOP
      0  1d8a					      db	29
      1  1d8a		       1d		      .byte.b	29
      0  1d8b					      dw	GOSUBLOOP
      1  1d8b		       82 1d		      .word.w	GOSUBLOOP
    663  1d8d				   GOSUBParmDONE
      0  1d8d					      TST	F2,")"
      0  1d8d					      db	32
      1  1d8d		       20		      .byte.b	32
      0  1d8e					      db	(F2-*)-1
      1  1d8e		       e7		      .byte.b	(F2-*)-1
      0  1d8f					      db	")",0
      1  1d8f		       29 00		      .byte.b	")",0
      0  1d91					      TMP2STK		;Restore line to goto
      0  1d91					      db	96
      1  1d91		       60		      .byte.b	96
    666  1d92				   GOSUBDONE
      0  1d92					      RTN
      0  1d92					      db	25
      1  1d92		       19		      .byte.b	25
    668  1d93
    669  1d93		       1d 93	   ILEND      equ	*
------- FILE mytb.asm
   2217  1d93		       1d 93	   PROGEND    equ	*
   2218  1d93
   2219  1d93
   2220  1d93							;=====================================================
   2221  1d93							; Define start of non page zero data
   2222 U1da3					      seg.u	TBData
   2223 U1da3
   2224 U1da3							;=====================================================
   2225 U1da3							; These are storage items not in page zero.
   2226 U1da3							;
   2227 U1da3							; IRQ BASIC Code Service RTN Support
      0 U1da3				   SaveIrqReg db	0	; Store current setting
      1 U1da3		       00		      .byte.b	0
      0 U1da4				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1da4		       00		      .byte.b	0
      0 U1da5				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1da5		       00		      .byte.b	0
      0 U1da6				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1da6		       00 00		      .byte.b	0,0
   2232 U1da8
   2233 U1da8							;
   2234 U1da8							;==================================================================================================
   2235 U1da8							; Task Management information
   2236 U1da8							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2237 U1da8							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2238 U1da8							; Task switchs happen at the beginning of the next Basic command line
   2239 U1da8							; It will not happen during an input or output operations
   2240 U1da8							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2241 U1da8							; Task Zero is always the root task, main line program
   2242 U1da8							;
   2243 U1da8							; Layout is repeated for each configured task
   2244 U1da8							; Task Table Byte   use masks follow
   2245 U1da8		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2246 U1da8		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2247 U1da8		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2248 U1da8		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2249 U1da8		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2250 U1da8
   2251 U1da8		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2252 U1da9		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2253 U1da9		       1e a3	   TASKTABLEEND equ	*	; End of task table
   2254 U1da9		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2255 U1ea3
   2256 U1ea3							;Task Cycle Counter and reset count
   2257 U1ea3		       00 00	   taskCurrentCycles ds	2
   2258 U1ea5		       00 00	   taskResetValue ds	2
   2259 U1ea7		       00	   taskCounter ds	1	; Count of active tasks
   2260 U1ea8
   2261 U1ea8							;
   2262 U1ea8							; Math stack and IL call and Gosub/For-next return stack definitions
   2263 U1ea8							;
   2264 U1ea8		       1e a8	   STACKSTART equ	*
   2265 U1ea8		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2266 U2038		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2267 U21c8		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2268 U2448		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2269 U2448		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2270 U2448		       26 64	   STACKEND   equ	*
   2271 U2448		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2272 U2664							;
   2273 U2664							;
   2274 U2664		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2275 U26e8		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2276 U26e9		       00	   printtx    ds	1	;temp X for print funcs
   2277 U26ea		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2278 U26eb		       00	   promptChar ds	1	;the character to use for a prompt
   2279 U26ec		       00	   diddigit   ds	1	;for leading zero suppression
   2280 U26ed		       00	   putsy      ds	1
   2281 U26ee		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2282 U26f0		       00	   sign       ds	1	;0 = positive, else negative
   2283 U26f1		       00 00	   rtemp1     ds	2	;Temp for x and y
   2284 U26f3		       00 00	   random     ds	2
   2285 U26f5		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2286 U26f7		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2287 U26f9		       00	   tempy      ds	1	;temp y storage
   2288 U26fa
   2289 U26fa							; Moved from page zero as one clock cycle diff gives more space on page zero
   2290 U26fa		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2291 U26fc		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2292 U26fd		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2293 U26fe		       00	   lineLength ds	1	;Length of current line
   2294 U26ff
   2295 U26ff		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2296 U2700		       00	   taskRDPending ds	1	; 1 = background read is pending
   2297 U2701
   2298 U2701				  -	      if	XKIM
   2299 U2701				  -buffer     ds	BUFFER_SIZE
   2300 U2701					      endif
   2301 U2701							;
   2302 U2701							; PROGRAMEND is the end of the user's BASIC program.
   2303 U2701							; More precisely, it is one byte past the end.  Or,
   2304 U2701							; it's where the next line added to the end will be
   2305 U2701							; placed.
   2306 U2701							;
   2307 U2701		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2308 U2703		       00 00	   ProgramEnd ds	2	; End of users basic program
   2309 U2705		       00 00	   HighMem    ds	2	; highest location
   2310 U2707		       00 00	   UsedMem    ds	2	; size of user program
   2311 U2709		       00 00	   FreeMem    ds	2	; amount of free memory
   2312 U270b							;
   2313 U270b							;=====================================================
   2314 U270b							; This is the start of the user's BASIC program space.
   2315 U270b							;
   2316 U270b							; PERSONAL GOAL: This should be no larger than $0DFF.
   2317 U270b							;		  0200-05FF = 1K
   2318 U270b							;		  0200-09FF = 2K
   2319 U270b							;		  0200-0DFF = 3K
   2320 U270b							;		  0200-11FF = 4K
   2321 U270b							;		  0200-13FF = 4.5K
   2322 U270b							;
   2323 U270b				  -	      if	FIXED
   2324 U270b				  -	      org	$2000
   2325 U270b					      endif
   2326 U270b
   2327 U270b		       27 0b	   FreeMemStart equ	*
   2328 U270b							;/*
   2329 U270b							;	if	CTMON65 || XKIM
   2330 U270b							;		SEG Code
   2331 U270b							;		org	AutoRun
   2332 U270b							;		dw	TBasicCold
   2333 U270b							;	endif
   2334 U270b							;*/
   2335 U270b					      end
