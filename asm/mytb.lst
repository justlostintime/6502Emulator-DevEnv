------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2e44				   input      processor	6502
      2 U2e44 ????						;=====================================================
      3 U2e44 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2e44 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2e44 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2e44 ????						;
      7 U2e44 ????						; While working on the Corsham Technologies KIM Clone
      8 U2e44 ????						; project, I wanted to include a TINY BASIC since that
      9 U2e44 ????						; was a highly desirable feature of early computers.
     10 U2e44 ????						;
     11 U2e44 ????						; Rather than negotiating copyright issues for
     12 U2e44 ????						; existing BASICs, I decided to just write one from
     13 U2e44 ????						; scratch.
     14 U2e44 ????						;
     15 U2e44 ????						; 10/07/2017
     16 U2e44 ????						;
     17 U2e44 ????						; This implements a stripped down Tiny BASIC
     18 U2e44 ????						; interpreter using the Interpretive Language (IL)
     19 U2e44 ????						; method as described in the first few issues of
     20 U2e44 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2e44 ????						; to write various languages simply by changing the
     22 U2e44 ????						; IL code rather than the interpreter itself.
     23 U2e44 ????						;
     24 U2e44 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2e44 ????						;		* Fixed major bug in findLine that
     26 U2e44 ????						;		  caused corrupted lines, crashes, etc.
     27 U2e44 ????						;		* If no parameter given to RND, assume
     28 U2e44 ????						;		  32766.
     29 U2e44 ????						;		* No more error 5 when a program
     30 U2e44 ????						;		  reaches the end without an END.
     31 U2e44 ????						;
     32 U2e44 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2e44 ????						;		 * Unexpanded version to play with everything
     34 U2e44 ????						;		 * Add some usefull system level functions
     35 U2e44 ????						;		 * allow a larger number of tiny basic formats
     36 U2e44 ????						;		 * Add byte at start of line holding length
     37 U2e44 ????						;		   for faster execution of goto and gosub
     38 U2e44 ????						;		 * Re-added gosub
     39 U2e44 ????						;		 * allow ; or , at end if print stmt
     40 U2e44 ????						;		   without CRLF being added.
     41 U2e44 ????						;		 * Added extended function erase to
     42 U2e44 ????						;		   use the extended ctmon65 rm file
     43 U2e44 ????						;		 * Fix quoted text to not have to backtrack
     44 U2e44 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2e44 ????						;		 * Add concurrency features
     46 U2e44 ????						;
     47 U2e44 ????						; www.corshamtech.com
     48 U2e44 ????						; bob@corshamtech.com
     49 U2e44 ????						; JustLostInTime@gmail.com
     50 U2e44 ????						;
     51 U2e44 ????						;=====================================================
     52 U2e44 ????						;
     53 U2e44 ????						; Create TRUE and FALSE values for conditionals.
     54 U2e44 ????						;
     55 U2e44 ????
     56 U2e44 ????	       00 00	   FALSE      equ	0
     57 U2e44 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2e44 ????						;
     59 U2e44 ????						;---------------------------------------------------------
     60 U2e44 ????						; One of these must be set to indicate which environment
     61 U2e44 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2e44 ????						; environments:
     63 U2e44 ????						;
     64 U2e44 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2e44 ????						; more K of RAM.
     66 U2e44 ????						;
     67 U2e44 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2e44 ????						; which enhances, without replacing, the standard KIM
     69 U2e44 ????						; monitor.  It gives access to routines to save/load files
     70 U2e44 ????						; to a micro SD card.
     71 U2e44 ????						;
     72 U2e44 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2e44 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2e44 ????						; easily be ported to other systems.  It has support for
     75 U2e44 ????						; using a micro SD card for file storage/retrieval.
     76 U2e44 ????						;
     77 U2e44 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2e44 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2e44 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2e44 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2e44 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2e44 ????						;
     83 U2e44 ????						;   Need to define some macros for the dasm assembler
     84 U2e44 ????						;
     85 U2e44 ????				      MACRO	dw
     86 U2e44 ????				      .word	{0}
     87 U2e44 ????				      ENDM
     88 U2e44 ????
     89 U2e44 ????				      MACRO	db
     90 U2e44 ????				      .byte	{0}
     91 U2e44 ????				      ENDM
     92 U2e44 ????
     93 U2e44 ????						;
     94 U2e44 ????						; If set, include disk functions.
     95 U2e44 ????						;
     96 U2e44 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2e44 ????						;
     98 U2e44 ????						; If ILTRACE is set then dump out the address of every
     99 U2e44 ????						; IL opcode before executing it.
    100 U2e44 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2e44 ????						;
    102 U2e44 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2e44 ????						;
    104 U2e44 ????						; If FIXED is set, put the IL code and the user
    105 U2e44 ????						; program space at fixed locations in memory.	This is
    106 U2e44 ????						; meant only for debugging.
    107 U2e44 ????						;
    108 U2e44 ????	       00 00	   FIXED      equ	FALSE
    109 U2e44 ????						;
    110 U2e44 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2e44 ????						; BASIC, so keep this small!
    112 U2e44 ????						;
    113 U2e44 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2e44 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2e44 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2e44 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2e44 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2e44 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2e44 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2e44 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2e44 ????						;
    122 U2e44 ????						; Gosub entry types
    123 U2e44 ????
    124 U2e44 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2e44 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2e44 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2e44 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2e44 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2e44 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2e44 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2e44 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2e44 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2e44 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2e44 ????						;
    135 U2e44 ????						; Common ASCII constants
    136 U2e44 ????						;
    137 U2e44 ????	       00 07	   BEL	      equ	$07
    138 U2e44 ????	       00 08	   BS	      equ	$08
    139 U2e44 ????	       00 09	   TAB	      equ	$09
    140 U2e44 ????	       00 0a	   LF	      equ	$0A
    141 U2e44 ????	       00 0d	   CR	      equ	$0D
    142 U2e44 ????	       00 22	   quote      equ	$22
    143 U2e44 ????	       00 20	   SPACE      equ	$20
    144 U2e44 ????	       00 2c	   COMMA      equ	',
    145 U2e44 ????	       00 3b	   SEMICOLON  equ	';
    146 U2e44 ????	       00 3a	   COLON      equ	':
    147 U2e44 ????	       00 24	   DOLLAR     equ	'$
    148 U2e44 ????						;
    149 U2e44 ????						; These are error codes
    150 U2e44 ????						;
    151 U2e44 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2e44 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2e44 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2e44 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2e44 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2e44 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2e44 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2e44 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2e44 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2e44 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2e44 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2e44 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2e44 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2e44 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2e44 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2e44 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2e44 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2e44 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2e44 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2e44 ????						;
    171 U2e44 ????						;=====================================================
    172 U2e44 ????						; Zero page storage.
    173 U2e44 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  249a ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 93 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       1c e3	   CRLF       equ	tbcrlf
    307  0206		       14 3c	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       14 59	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 12 1e    cold2      jsr	SetOutConsole
    314  0209		       20 1f 1e 	      jsr	SetInConsole
    315  020c		       20 59 14 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.4	IRQs/Tasks/Tokens"
      0  0240					      db	CR,LF,0
      1  0240		       0d 0a 00 	      .byte.b	CR,LF,0
    319  0243							;
    320  0243		       20 ee 14 	      jsr	MemInit	;setup the free space available
    321  0246
    322  0246		       a9 01	   calcstack  lda	#1
    323  0248		       8d e0 25 	      sta	taskCounter	; Initialize number of tasks to 1
    324  024b		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  024d		       8d e2 24 	      sta	taskTable	; mark the main task as active
    326  0250		       20 db 15 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  0253		       a9 cb		      lda	#IL&$ff
    328  0255		       85 43		      sta	ILPC
    329  0257		       a9 20		      lda	#IL>>8
    330  0259		       85 44		      sta	ILPC+1
    331  025b							;
    332  025b							;		  lda	  ProgramStart		     ; user prog
    333  025b							;		  sta	  ProgramEnd
    334  025b							;		  lda	  ProgramStart+1
    335  025b							;		  sta	  ProgramEnd+1
    336  025b							;
    337  025b							;  Init time slices defaults
    338  025b		       a9 02		      lda	#TASKCYCLESHIGH
    339  025d		       8d df 25 	      sta	taskResetValue+1
    340  0260		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  0262		       8d de 25 	      sta	taskResetValue
    342  0265							;
    343  0265							; Initialize the pseudo-random number sequence...
    344  0265							;
    345  0265		       a9 5a		      lda	#$5a
    346  0267		       8d 2a 2e 	      sta	rtemp1
    347  026a		       a9 9d		      lda	#%10011101
    348  026c		       8d 2c 2e 	      sta	random
    349  026f		       a9 5b		      lda	#%01011011
    350  0271		       8d 2d 2e 	      sta	random+1
    351  0274							;
    352  0274							;   Insert a Basic irq handler for the basic Language
    353  0274		       a9 81		      lda	#ServiceIrq&$ff
    354  0276		       8d 00 df 	      sta	IRQvec
    355  0279		       a9 02		      lda	#ServiceIrq>>8
    356  027b		       8d 01 df 	      sta	IRQvec+1
    357  027e		       4c a6 02 	      jmp	coldtwo
    358  0281
    359  0281							;
    360  0281							; This is the Basic IRQ handler
    361  0281		       48	   ServiceIrq pha
    362  0282		       ad dd 24 	      lda	IRQStatus
    363  0285		       f0 0a		      BEQ	RetIrq
    364  0287		       ad de 24 	      lda	IRQPending
    365  028a		       d0 05		      bne	RetIrq
    366  028c		       a9 01		      lda	#1
    367  028e		       8d de 24 	      sta	IRQPending
    368  0291		       68	   RetIrq     pla
    369  0292		       40		      rti
    370  0293							;
    371  0293							;
    372  0293							; This is the warm start entry point
    373  0293							;
    374  0293		       20 12 1e    warm2      jsr	SetOutConsole
    375  0296		       20 1f 1e 	      jsr	SetInConsole
    376  0299		       20 e3 1c 	      jsr	CRLF
    377  029c		       ad 27 2e 	      lda	errGoto
    378  029f		       85 43		      sta	ILPC
    379  02a1		       ad 28 2e 	      lda	errGoto+1
    380  02a4		       85 44		      sta	ILPC+1
    381  02a6							;
    382  02a6							; And continue with both starts here
    383  02a6							;
    384  02a6				   coldtwo
    385  02a6							;
    386  02a6							; The ILTrace flag is now run-time settable.
    387  02a6							;
    388  02a6		       a9 00		      lda	#ILTRACE&$ff
    389  02a8		       85 40		      sta	ILTrace
    390  02aa							;
    391  02aa
    392  02aa		       a9 00		      lda	#0
    393  02ac		       85 5b		      sta	RunMode
    394  02ae		       8d 9d 2d 	      sta	LINBUF
    395  02b1
    396  02b1							; Clear everything from the stacks
    397  02b1
    398  02b1		       8d 38 2e 	      sta	taskIOPending	; No one waiting for io
    399  02b4		       8d 39 2e 	      sta	taskRDPending	; No one waiting for bg io
    400  02b7
    401  02b7		       20 4e 16 	      jsr	taskReset
    402  02ba							;
    403  02ba		       a9 9d		      lda	#LINBUF&$ff
    404  02bc		       85 4f		      sta	CURPTR
    405  02be		       a9 2d		      lda	#LINBUF>>8
    406  02c0		       85 50		      sta	CURPTR+1	;fall through...
    407  02c2
    408  02c2							;=====================================================
    409  02c2							; This is the top of the IL interpreter.  This fetches
    410  02c2							; and executes the instruction currently pointed to
    411  02c2							; by ILPC and adjusts ILPC to point to the next
    412  02c2							; instruction to execute.
    413  02c2							;
    414  02c2		       ce dc 25    NextIL     dec	taskCurrentCycles
    415  02c5		       d0 03		      bne	NextIlNow
    416  02c7		       20 77 16 	      jsr	iTaskSwitch	;check for a task switch
    417  02ca		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02cc		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02ce
    420  02ce		       20 6f 1d 	      jsr	dbgLine	;Print the IL trace information
    421  02d1
    422  02d1		       a4 51	   NextIL2    ldy	CUROFF
    423  02d3							;		  jsr	  SkipSpaces
    424  02d3							;		  sty	  CUROFF
    425  02d3							;Task IO Management
    426  02d3		       ad 39 2e 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d6		       f0 08		      beq	NextILStr
    428  02d8		       20 2a 1b 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02db		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02dd		       ce 39 2e 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02e0							;
    432  02e0		       20 ad 19    NextILStr  jsr	getILByte
    433  02e3							;
    434  02e3							; When the handler is called, these are the conditions
    435  02e3							; of several important items:
    436  02e3							;
    437  02e3							;    (ILPC) will point to the byte AFTER the IL
    438  02e3							;    opcode being executed.
    439  02e3							;
    440  02e3							;    (CURPTR),CUROFF will point to the start of the
    441  02e3							;    next word in the input buffer.  Ie, the next word
    442  02e3							;    in the user program.
    443  02e3							;
    444  02e3		       0a		      asl
    445  02e4		       c9 d6		      cmp	#ILTBLend-ILTBL+2
    446  02e6		       90 33		      bcc	ILgood
    447  02e8							;
    448  02e8							; This handles an illegal IL opcode.  This is serious
    449  02e8							; and there's no way to recover.
    450  02e8							;
    451  02e8		       20 59 14    ILbad      jsr	puts
      0  02eb					      db	CR,LF
      1  02eb		       0d 0a		      .byte.b	CR,LF
      0  02ed					      db	"Illegal IL "
      1  02ed		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f8					      db	0
      1  02f8		       00		      .byte.b	0
    455  02f9							;
    456  02f9							; Well this is awkward, we need to back up the IL
    457  02f9							; by one since it no longer points to the current
    458  02f9							; opcode.
    459  02f9							;
    460  02f9		       20 ba 19 	      jsr	decIL
    461  02fc							;
    462  02fc		       a0 00		      ldy	#0
    463  02fe		       b1 43		      lda	(ILPC),y
    464  0300		       20 3c 14 	      jsr	OUTHEX
    465  0303		       20 59 14 	      jsr	puts
      0  0306					      db	" at ",0
      1  0306		       20 61 74 20*	      .byte.b	" at ",0
    467  030b		       a5 44		      lda	ILPC+1
    468  030d		       20 3c 14 	      jsr	OUTHEX
    469  0310		       a5 43		      lda	ILPC
    470  0312		       20 3c 14 	      jsr	OUTHEX
    471  0315		       20 e3 1c 	      jsr	CRLF
    472  0318		       4c 03 f0 	      jmp	MONITOR
    473  031b							;
    474  031b							; Just jump to the address (ILPC),y.  Have to do
    475  031b							; some goofy stuff.
    476  031b							;
    477  031b		       a8	   ILgood     tay		;move index into Y
    478  031c		       b9 29 03 	      lda	ILTBL,y
    479  031f		       85 59		      sta	dpl
    480  0321		       b9 2a 03 	      lda	ILTBL+1,y
    481  0324		       85 5a		      sta	dpl+1
    482  0326		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0329							;
    484  0329							;=====================================================
    485  0329							; This is the IL jump table.  The IL opcode is
    486  0329							; mulitplied by two, then looked-up in this table.
    487  0329							; There is absolutely nothing special about the order
    488  0329							; of entries here... they all decode at exactly the
    489  0329							; same speed.	However the entry number must match the
    490  0329							; values in IL.inc.
    491  0329							;
    492  0329				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0329					      include	"ilvectortable.asm"
      1  0329					      seg	Code
      2  0329
      0  0329					      dw	iXINIT	;0
      1  0329		       35 04		      .word.w	iXINIT
      0  032b					      dw	iDONE	;1
      1  032b		       50 04		      .word.w	iDONE
      0  032d					      dw	iPRS	;2
      1  032d		       69 04		      .word.w	iPRS
      0  032f					      dw	iPRN	;3
      1  032f		       71 04		      .word.w	iPRN
      0  0331					      dw	iSPC	;4
      1  0331		       7a 04		      .word.w	iSPC
      0  0333					      dw	iNLINE	;5
      1  0333		       f7 08		      .word.w	iNLINE
      0  0335					      dw	iNXT	;6
      1  0335		       82 04		      .word.w	iNXT
      0  0337					      dw	iXFER	;7
      1  0337		       af 04		      .word.w	iXFER
      0  0339					      dw	iSAV	;8
      1  0339		       dc 04		      .word.w	iSAV
      0  033b					      dw	iRSTR	;9
      1  033b		       1f 05		      .word.w	iRSTR
      0  033d					      dw	iCMPR	;10
      1  033d		       54 05		      .word.w	iCMPR
      0  033f					      dw	iINNUM	;11
      1  033f		       d5 05		      .word.w	iINNUM
      0  0341					      dw	iFIN	;12
      1  0341		       09 06		      .word.w	iFIN
      0  0343					      dw	iERR	;13
      1  0343		       1d 06		      .word.w	iERR
      0  0345					      dw	iADD	;14
      1  0345		       8d 06		      .word.w	iADD
      0  0347					      dw	iSUB	;15
      1  0347		       a3 06		      .word.w	iSUB
      0  0349					      dw	iNEG	;16
      1  0349		       b9 06		      .word.w	iNEG
      0  034b					      dw	iMUL	;17
      1  034b		       d1 06		      .word.w	iMUL
      0  034d					      dw	iDIV	;18
      1  034d		       11 07		      .word.w	iDIV
      0  034f					      dw	iSTORE	;19
      1  034f		       67 07		      .word.w	iSTORE
      0  0351					      dw	iIND	;20
      1  0351		       7f 07		      .word.w	iIND
      0  0353					      dw	iLST	;21
      1  0353		       ed 07		      .word.w	iLST
      0  0355					      dw	iINIT	;22
      1  0355		       fd 03		      .word.w	iINIT
      0  0357					      dw	iGETLINE	;23
      1  0357		       23 08		      .word.w	iGETLINE
      0  0359					      dw	iINSRT	;24
      1  0359		       40 08		      .word.w	iINSRT
      0  035b					      dw	iRTN	;25
      1  035b		       f1 08		      .word.w	iRTN
      0  035d					      dw	MONITOR	;26
      1  035d		       03 f0		      .word.w	MONITOR
      0  035f					      dw	iLIT	;27
      1  035f		       17 09		      .word.w	iLIT
      0  0361					      dw	iCALL	;28
      1  0361		       fd 08		      .word.w	iCALL
      0  0363					      dw	iJMP	;29
      1  0363		       05 09		      .word.w	iJMP
      0  0365					      dw	iVINIT	;30
      1  0365		       34 09		      .word.w	iVINIT
      0  0367					      dw	iERRGOTO	;31
      1  0367		       3a 09		      .word.w	iERRGOTO
      0  0369					      dw	iTST	;32
      1  0369		       46 09		      .word.w	iTST
      0  036b					      dw	iTSTV	;33
      1  036b		       6b 0a		      .word.w	iTSTV
      0  036d					      dw	iTSTL	;34
      1  036d		       e2 0a		      .word.w	iTSTL
      0  036f					      dw	iTSTN	;35
      1  036f		       fd 0a		      .word.w	iTSTN
      0  0371					      dw	iFREE	;36
      1  0371		       ac 0b		      .word.w	iFREE
      0  0373					      dw	iRANDOM	;37
      1  0373		       b5 0b		      .word.w	iRANDOM
      0  0375					      dw	iABS	;38
      1  0375		       86 0c		      .word.w	iABS
     42  0377							;
     43  0377							; Disk functions.  There must be pointers
     44  0377							; to functions even if no disk is supported.
     45  0377							; Makes things easier in IL.inc.
     46  0377							;
     47  0377					      if	DISK_ACCESS
      0  0377					      dw	iOPENREAD	;39
      1  0377		       23 1f		      .word.w	iOPENREAD
      0  0379					      dw	iOPENWRITE	;40
      1  0379		       84 1f		      .word.w	iOPENWRITE
      0  037b					      dw	iDCLOSE	;41
      1  037b		       08 20		      .word.w	iDCLOSE
      0  037d					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037d		       96 1f		      .word.w	iDGETLINE
      0  037f					      dw	iDLIST	;43 Did you remember your towel?
      1  037f		       02 20		      .word.w	iDLIST
      0  0381					      dw	iDDIR	;44
      1  0381		       dd 1f		      .word.w	iDDIR
      0  0383					      dw	iRMFILE	;45
      1  0383		       72 1f		      .word.w	iRMFILE
     55  0385				  -	      else
     56  0385				  -	      dw	NextIL	;39
     57  0385				  -	      dw	NextIL	;40
     58  0385				  -	      dw	NextIL	;41
     59  0385				  -	      dw	NextIL	;42
     60  0385				  -	      dw	NextIL	;43
     61  0385				  -	      dw	NextIL	;44
     62  0385				  -	      dw	NextIL	;45
     63  0385					      endif
     64  0385							;
      0  0385					      dw	iCLEARSCREEN	;46
      1  0385		       32 1e		      .word.w	iCLEARSCREEN
      0  0387					      dw	iPOKEMEMORY	;47
      1  0387		       13 0c		      .word.w	iPOKEMEMORY
      0  0389					      dw	iPEEKMEMORY	;48
      1  0389		       28 0c		      .word.w	iPEEKMEMORY
      0  038b					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  038b		       8d 09		      .word.w	iTSTLET
      0  038d					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038d		       12 0a		      .word.w	iTSTDONE
      0  038f					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038f		       55 0c		      .word.w	iGETCHAR
      0  0391					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0391		       69 0c		      .word.w	iPUTCHAR
      0  0393					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0393		       3e 0c		      .word.w	iCallFunc
      0  0395					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0395		       a5 05		      .word.w	iBranch
      0  0397					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0397		       70 09		      .word.w	iTSTStr
      0  0399					      dw	iSetIrq	;56	   sets the irq handler
      1  0399		       03 0d		      .word.w	iSetIrq
      0  039b					      dw	iTstIrq	;57	   test if irq is pending
      1  039b		       74 0b		      .word.w	iTstIrq
      0  039d					      dw	iRET	;58	   return from interupt
      1  039d		       0d 05		      .word.w	iRET
      0  039f					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039f		       ec 05		      .word.w	iINSTR
      0  03a1					      dw	iMOD	;60	   returns remainder of division
      1  03a1		       1a 07		      .word.w	iMOD
      0  03a3					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a3		       cb 16		      .word.w	iTaskSet
      0  03a5					      dw	iETask	;62	   Terminates a task
      1  03a5		       f6 17		      .word.w	iETask
      0  03a7					      dw	iNTask	;63	   goto next task
      1  03a7		       a9 17		      .word.w	iNTask
      0  03a9					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a9		       94 07		      .word.w	iArray
      0  03ab					      dw	iTaskKill	;65	   kill a running task
      1  03ab		       a1 17		      .word.w	iTaskKill
      0  03ad					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ad		       75 17		      .word.w	iTaskStat
      0  03af					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03af		       74 0c		      .word.w	iHexOut
      0  03b1					      dw	iReadComplete	;68	   Called after a background read completes
      1  03b1		       c1 05		      .word.w	iReadComplete
      0  03b3					      dw	iReadStart	;69	   Called to start a background read request
      1  03b3		       b7 05		      .word.w	iReadStart
      0  03b5					      dw	iStartIO	;70	   Lock task until io complete
      1  03b5		       d9 17		      .word.w	iStartIO
      0  03b7					      dw	iEndIO	;71	   release task lock for io
      1  03b7		       df 17		      .word.w	iEndIO
      0  03b9					      dw	iLogNot	;72	   Logical not
      1  03b9		       df 0c		      .word.w	iLogNot
      0  03bb					      dw	iLogOr	;73	   Logical Or
      1  03bb		       b5 0c		      .word.w	iLogOr
      0  03bd					      dw	iLogAnd	;74	   Logical And
      1  03bd		       a0 0c		      .word.w	iLogAnd
      0  03bf					      dw	iLogXor	;75	   Logical Xor
      1  03bf		       ca 0c		      .word.w	iLogXor
      0  03c1					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03c1		       b4 17		      .word.w	iWTASK
      0  03c3					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c3		       ea 17		      .word.w	iTASKPID
      0  03c5					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c5		       3f 0d		      .word.w	iTRACEPROG
      0  03c7					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c7		       f0 1c		      .word.w	idbgBasic
      0  03c9					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c9		       ac 18		      .word.w	iIPCS
      0  03cb					      dw	iIPCR	;81	   Recieve a message from a task
      1  03cb		       c3 18		      .word.w	iIPCR
      0  03cd					      dw	iIPCC	;82	   Check if any message available for task
      1  03cd		       d7 18		      .word.w	iIPCC
      0  03cf					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cf		       e4 18		      .word.w	iIPCIO
      0  03d1					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03d1		       43 15		      .word.w	iPushMathStack
      0  03d3					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d3		       73 15		      .word.w	iPopMathStack
      0  03d5					      dw	iSaveMathStack	;86	   Save all math info
      1  03d5		       90 15		      .word.w	iSaveMathStack
      0  03d7					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d7		       af 15		      .word.w	iRestoreMathStack
      0  03d9					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d9		       60 15		      .word.w	iIncParmCount
      0  03db					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03db		       16 18		      .word.w	iTaskGetMathStack
      0  03dd					      dw	iTaskEnable	;90	   enable a suspended task
      1  03dd		       43 17		      .word.w	iTaskEnable
      0  03df					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03df		       5d 17		      .word.w	iTaskSuspend
      0  03e1					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03e1		       30 18		      .word.w	iTaskPutMathPtr
      0  03e3					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e3		       62 0a		      .word.w	iTSTVT
      0  03e5					      dw	iSetR2	;94
      1  03e5		       0f 09		      .word.w	iSetR2
      0  03e7					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e7		       eb 04		      .word.w	iStk2Tmp
      0  03e9					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e9		       fc 04		      .word.w	iTmp2Stk
      0  03eb					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03eb		       ae 09		      .word.w	iTSTBYTE
      0  03ed					      dw	iINCVAR	;98	   Increment variable
      1  03ed		       34 0a		      .word.w	iINCVAR
      0  03ef					      dw	iDECVAR	;99	   Decrement variable
      1  03ef		       4c 0a		      .word.w	iDECVAR
      0  03f1					      dw	iSLICE	;100	   set the time slice for tasks
      1  03f1		       3f 18		      .word.w	iSLICE
      0  03f3					      dw	iTSTB	;101	   Test if byte equals
      1  03f3		       cd 09		      .word.w	iTSTB
      0  03f5					      dw	iTSTW	;102	   Test If word equals
      1  03f5		       e8 09		      .word.w	iTSTW
      0  03f7					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03f7		       32 13		      .word.w	iOnGoto
      0  03f9					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f9		       63 13		      .word.w	iTSTRELOP
      0  03fb					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03fb		       a8 04		      .word.w	iRepeatLine
    125  03fd
------- FILE mytb.asm
    494  03fd		       03 fd	   ILTBLend   equ	*
    495  03fd							;
    496  03fd							;=====================================================
    497  03fd							;=====================================================
    498  03fd							;=====================================================
    499  03fd							; This marks the start of the handlers for IL opcodes.
    500  03fd							;=====================================================
    501  03fd							;=====================================================
    502  03fd							;=====================================================
    503  03fd							;
    504  03fd							;
    505  03fd		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03ff		       85 47		      sta	ILSTACKPTR
    507  0401		       85 4a		      sta	MATHSTACKPTR
    508  0403		       85 4d		      sta	GOSUBSTACKPTR
    509  0405		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  0407		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  0409							;
    512  0409		       ad 3a 2e 	      lda	ProgramStart	;user prog
    513  040c		       85 4f		      sta	CURPTR
    514  040e		       8d e3 24 	      sta	taskTable+1
    515  0411		       8d 3c 2e 	      sta	ProgramEnd
    516  0414		       ad 3b 2e 	      lda	ProgramStart+1
    517  0417		       85 50		      sta	CURPTR+1
    518  0419		       8d e4 24 	      sta	taskTable+2
    519  041c		       8d 3d 2e 	      sta	ProgramEnd+1
    520  041f		       a9 80		      lda	#TASKACTIVE
    521  0421		       8d e2 24 	      sta	taskTable	;Mark the first slot as active
    522  0424		       a9 01		      lda	#1
    523  0426		       8d e0 25 	      sta	taskCounter	;there is always one task / Main task
    524  0429		       ad de 25 	      lda	taskResetValue
    525  042c		       8d dc 25 	      sta	taskCurrentCycles	; set up the task switch counts
    526  042f		       ad df 25 	      lda	taskResetValue+1
    527  0432		       8d dd 25 	      sta	taskCurrentCycles+1
    528  0435							;
    529  0435							; fall into XINIT...
    530  0435							;
    531  0435							;=====================================================
    532  0435							; This initializes for the start of the next line of
    533  0435							; BASIC text.
    534  0435							;
    535  0435		       78	   iXINIT     sei		;ensure interupts are off
    536  0436		       20 4e 16 	      jsr	taskReset	;Clear the task table
    537  0439		       8d de 24 	      sta	IRQPending	; reset the irq pending
    538  043c		       8d dd 24 	      sta	IRQStatus	; Make sure irqs are off
    539  043f
    540  043f		       4c c2 02    goodExit   jmp	NextIL
    541  0442							;
    542  0442							;=====================================================
    543  0442							; This check if the escape key has been entered
    544  0442							; then changes out of run mode. z Set if esc found
    545  0442				   BreakSet
    546  0442		       20 0f f0 	      jsr	ISCHAR
    547  0445		       f0 06		      beq	BreakNo
    548  0447		       20 2f 1e 	      jsr	VGETCH
    549  044a		       c9 1b		      cmp	#$1B
    550  044c		       60		      rts
    551  044d				   BreakNo
    552  044d		       a9 01		      lda	#1
    553  044f		       60		      rts
    554  0450
    555  0450							;
    556  0450
    557  0450							;=====================================================
    558  0450							; Verify there is nothing else on this input line.
    559  0450							; If there is, generate an error.
    560  0450							;
    561  0450		       a4 51	   iDONE      ldy	CUROFF
    562  0452		       b1 4f		      lda	(CURPTR),y
    563  0454		       f0 10		      beq	doneadv
    564  0456		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    565  0458		       d0 05		      bne	idoneErr
    566  045a		       84 51		      sty	CUROFF
    567  045c		       4c c2 02 	      jmp	NextIL	; continue on this line
    568  045f
    569  045f				   idoneErr
    570  045f		       a2 04		      ldx	#ERR_EXTRA_STUFF
    571  0461		       a9 00		      lda	#0
    572  0463		       4c 20 06 	      jmp	iErr2
    573  0466							;
    574  0466							; Advance to the next line
    575  0466							;
    576  0466				   doneadv
    577  0466		       4c c2 02 	      jmp	NextIL
    578  0469							;
    579  0469							;=====================================================
    580  0469							; Print the string until a closing quote
    581  0469							;
    582  0469				   iPRS
    583  0469		       20 83 14 	      jsr	PrtQuoted
    584  046c		       84 51		      sty	CUROFF
    585  046e		       4c c2 02 	      jmp	NextIL
    586  0471							;
    587  0471							;=====================================================
    588  0471							; Pop the top off the stack and print it as a signed
    589  0471							; decimal number.
    590  0471							;
    591  0471				   iPRN
    592  0471		       20 2a 1c 	      jsr	popR0
    593  0474		       20 8a 13 	      jsr	PrintDecimal
    594  0477		       4c c2 02 	      jmp	NextIL
    595  047a							;
    596  047a							;=====================================================
    597  047a							; Space to next zone.	Currently the code does not
    598  047a							; keep track of which column the output is on, so
    599  047a							; just print a tab.
    600  047a							;
    601  047a				   iSPC
    602  047a		       a9 09		      lda	#TAB
    603  047c		       20 2c 1e 	      jsr	VOUTCH
    604  047f		       4c c2 02 	      jmp	NextIL
    605  0482							;
    606  0482							;=====================================================
    607  0482							; If in immediate mode, jump to the address following
    608  0482							; the NXT instruction.  Else move to the next line of
    609  0482							; user code and continue.
    610  0482							;
    611  0482		       a5 5b	   iNXT       lda	RunMode
    612  0484		       d0 03		      bne	iNxtRun	;in run mode
    613  0486							;
    614  0486							; Get address and jump to it.
    615  0486							;
    616  0486		       4c 05 09 	      jmp	iJMP
    617  0489							;
    618  0489				   iNxtRun
    619  0489		       a4 51		      ldy	CUROFF
    620  048b		       b1 4f		      lda	(CURPTR),y
    621  048d		       c9 e6		      cmp	#oColon
    622  048f		       d0 06		      bne	iNxtRunGo
    623  0491		       c8		      iny
    624  0492		       84 51		      sty	CUROFF
    625  0494		       4c a2 04 	      jmp	iNxtRun2
    626  0497
    627  0497				   iNxtRunGo
    628  0497		       20 37 1a 	      jsr	FindNextLine
    629  049a		       20 4b 1a 	      jsr	AtEnd
    630  049d		       d0 03		      bne	iNxtRun2	;not at end
    631  049f							;
    632  049f							; At the end of the program.  Pretend an END statement
    633  049f							; was found.
    634  049f							;
    635  049f		       4c 09 06    iFINv      jmp	iFIN
    636  04a2							;
    637  04a2		       20 a9 19    iNxtRun2   jsr	getILWord	;ignore next word
    638  04a5		       4c c2 02 	      jmp	NextIL
    639  04a8							;=====================================================
    640  04a8							;Repeat the same line against
    641  04a8		       a0 03	   iRepeatLine ldy	#3
    642  04aa		       84 51		      sty	CUROFF
    643  04ac		       4c c2 02 	      jmp	NextIL
    644  04af							;
    645  04af							;=====================================================
    646  04af							; XFER takes the number on top of the stack and looks
    647  04af							; for that line in the program, or the next line
    648  04af							; higher.  Ie, if it's 1 but there is no line 1, then
    649  04af							; find the next one after that.
    650  04af							;
    651  04af		       20 2a 1c    iXFER      jsr	popR0
    652  04b2		       20 f2 19 	      jsr	findLine
    653  04b5		       20 4b 1a    iXFER2     jsr	AtEnd	;at end of user program?
    654  04b8		       f0 e5		      beq	iFINv
    655  04ba		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    656  04bc		       84 51		      sty	CUROFF
    657  04be		       a9 ff		      lda	#$ff
    658  04c0		       85 5b		      sta	RunMode
    659  04c2							;
    660  04c2							; Transfer IL to STMT.  I don't like having this
    661  04c2							; hard-coded; fix it.
    662  04c2							;
    663  04c2		       a9 d9		      lda	#STMT&$ff
    664  04c4		       85 43		      sta	ILPC
    665  04c6		       a9 20		      lda	#STMT>>8
    666  04c8		       85 44		      sta	ILPC+1
    667  04ca		       4c c2 02 	      jmp	NextIL
    668  04cd							;
    669  04cd							; Run
    670  04cd							;
    671  04cd				   iXferok
    672  04cd		       a9 ff		      lda	#$ff
    673  04cf		       85 5b		      sta	RunMode	;we're running
    674  04d1							;
    675  04d1							; Need a more elegant way to do this
    676  04d1							;
    677  04d1		       a9 d9		      lda	#STMT&$ff
    678  04d3		       85 43		      sta	ILPC
    679  04d5		       a9 20		      lda	#STMT>>8
    680  04d7		       85 44		      sta	ILPC+1
    681  04d9		       4c c2 02 	      jmp	NextIL
    682  04dc							;
    683  04dc							;=====================================================
    684  04dc							; Save the pointer to the next line to the call stack.
    685  04dc							;
    686  04dc		       20 c0 1b    iSAV       jsr	pushLN
    687  04df		       b0 03		      bcs	iSAVErr
    688  04e1		       4c c2 02 	      jmp	NextIL
    689  04e4
    690  04e4		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    691  04e6		       a9 00	   iSAVErr2   lda	#0
    692  04e8		       4c 20 06 	      jmp	iErr2
    693  04eb							;====================================================
    694  04eb							; Move stack top to and from temp area
    695  04eb				   iStk2Tmp
    696  04eb		       20 2a 1c 	      jsr	popR0
    697  04ee		       a5 52		      lda	R0
    698  04f0		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    699  04f2		       91 41		      sta	(VARIABLES),y
    700  04f4		       c8		      iny
    701  04f5		       a5 53		      lda	R0+1
    702  04f7		       91 41		      sta	(VARIABLES),y
    703  04f9		       4c c2 02 	      jmp	NextIL
    704  04fc
    705  04fc		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    706  04fe		       b1 41		      lda	(VARIABLES),y
    707  0500		       85 52		      sta	R0
    708  0502		       c8		      iny
    709  0503		       b1 41		      lda	(VARIABLES),y
    710  0505		       85 53		      sta	R0+1
    711  0507		       20 a6 1b 	      jsr	pushR0
    712  050a		       4c c2 02 	      jmp	NextIL
    713  050d							;
    714  050d							;=====================================================
    715  050d							; Pop the next line from the call stack.
    716  050d							;
    717  050d		       20 e5 1b    iRET       jsr	popLN
    718  0510		       b0 d2		      bcs	iSAVErr
    719  0512		       a0 03		      ldy	#3
    720  0514		       84 51		      sty	CUROFF
    721  0516		       a9 00		      lda	#0
    722  0518		       8d de 24 	      sta	IRQPending
    723  051b		       58		      cli
    724  051c		       4c c2 02 	      jmp	NextIL
    725  051f							;
    726  051f							;=====================================================
    727  051f							; Return from GOSUB function
    728  051f							;
    729  051f		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    730  0521		       f0 0f		      beq	iRSTRNoValue
    731  0523		       a5 58		      lda	R2
    732  0525		       85 56		      sta	MQ
    733  0527		       88		      dey
    734  0528		       b1 4b		      lda	(GOSUBSTACK),y
    735  052a		       c9 81		      cmp	#GOSUB_RTN_VALUE
    736  052c		       d0 04		      bne	iRSTRNoValue
    737  052e		       a9 01		      lda	#1
    738  0530		       d0 02		      bne	iRSTRExit
    739  0532				   iRSTRNoValue
    740  0532		       a9 00		      lda	#0
    741  0534				   iRSTRExit
    742  0534		       85 58		      sta	R2
    743  0536		       20 e5 1b 	      jsr	popLN
    744  0539		       b0 06		      bcs	iRSTRErr
    745  053b		       20 79 15 	      jsr	PopMathStackNow
    746  053e		       4c c2 02 	      jmp	NextIL
    747  0541
    748  0541		       ad e1 24    iRSTRErr   lda	taskPtr	; Check if this is task zero
    749  0544		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    750  0546		       a5 56		      lda	MQ
    751  0548		       d0 03		      bne	taskRet
    752  054a		       20 47 1e 	      jsr	pushFalse	; the result code by default is 0
    753  054d				   taskRet
    754  054d		       4c f6 17 	      jmp	iETask	; not task zero then do a task end instead
    755  0550				   taskZeroEnd
    756  0550		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    757  0552		       d0 92		      bne	iSAVErr2
    758  0554							;
    759  0554							;=====================================================
    760  0554							; Compare items on stack.  Okay, so on input there are
    761  0554							; three things on the stack
    762  0554							;
    763  0554							;    EXPR2 <- Top of stack
    764  0554							;    OP    <- relational operator, next on stack
    765  0554							;    EXPR1 <- last item on stack
    766  0554							;
    767  0554							; Comparison is: EXPR1 <operator> EXPR2
    768  0554							;
    769  0554							; Operator is one of...
    770  0554							;
    771  0554							;    2 is =
    772  0554							;    1 is <
    773  0554							;    3 is <=
    774  0554							;    5 is <>
    775  0554							;    4 is >
    776  0554							;    6 is >=
    777  0554							;
    778  0554							; Those are bit-mapped:
    779  0554							;
    780  0554							;    xxxxxGEL
    781  0554							;
    782  0554							;    G = Greater than
    783  0554							;    E = Equal
    784  0554							;    L = Less than
    785  0554							;
    786  0554							; If the comparison is false, do a NXT, ie, move to the
    787  0554							; next line and continue.  If true, continue executing
    788  0554							; on this line.
    789  0554							;
    790  0554		       00 01	   REL_LT     equ	%001
    791  0554		       00 02	   REL_EQUAL  equ	%010
    792  0554		       00 04	   REL_GT     equ	%100
    793  0554							;
    794  0554		       20 42 1c    iCMPR      jsr	popR1
    795  0557		       20 59 1c 	      jsr	popMQ	;operator in MQ
    796  055a		       20 2a 1c 	      jsr	popR0
    797  055d		       20 66 05 	      jsr	iCMPRsub
    798  0560		       20 a6 1b 	      jsr	pushR0
    799  0563		       4c c2 02 	      jmp	NextIL
    800  0566							;
    801  0566							; See if they are equal or not
    802  0566							;
    803  0566				   iCMPRsub		; Called by internal functions
    804  0566
    805  0566		       a5 52		      lda	R0
    806  0568		       c5 54		      cmp	R1
    807  056a		       d0 0a		      bne	iCMPRnoteq	;try not equal
    808  056c		       a5 53		      lda	R0+1
    809  056e		       c5 55		      cmp	R1+1
    810  0570		       d0 04		      bne	iCMPRnoteq
    811  0572							;
    812  0572							; Equal, set the flag in MQ+1
    813  0572							;
    814  0572		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    815  0574		       d0 14		      bne	iCMPcom	;Exit it is equal
    816  0576							;
    817  0576							; See if EXPR1 (R0) < EXPR2 (R1)
    818  0576							; See www.6502.org/tutorials/compare_beyond.html
    819  0576							;
    820  0576				   iCMPRnoteq
    821  0576		       a5 52		      lda	R0
    822  0578		       c5 54		      cmp	R1
    823  057a		       a5 53		      lda	R0+1
    824  057c		       e5 55		      sbc	R1+1
    825  057e		       50 02		      bvc	iCMPR_2
    826  0580		       49 80		      eor	#$80
    827  0582		       30 04	   iCMPR_2    bmi	iCMPlt
    828  0584		       a9 04		      lda	#REL_GT
    829  0586		       d0 02		      bne	iCMPcom
    830  0588		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    831  058a
    832  058a		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    833  058c							;
    834  058c							; Now compare the end result with what the caller
    835  058c							; was looking for.
    836  058c							;
    837  058c		       25 56		      and	MQ
    838  058e		       f0 0c		      beq	iCMPno	; no match
    839  0590		       a9 ff		      lda	#$FF	; true is $ffff
    840  0592		       85 52		      sta	R0
    841  0594		       85 53		      sta	R0+1
    842  0596		       d0 0c		      bne	iCMPDone
    843  0598							;
    844  0598							; R0 > R1
    845  0598							;
    846  0598		       a9 04	   iCMPgt     lda	#REL_GT
    847  059a		       d0 ee		      bne	iCMPcom
    848  059c				   iCMPno
    849  059c		       a9 00		      lda	#0
    850  059e		       85 52		      sta	R0
    851  05a0		       a9 00		      lda	#0
    852  05a2		       85 53		      sta	R0+1
    853  05a4
    854  05a4				   iCMPDone
    855  05a4		       60		      rts
    856  05a5
    857  05a5							;
    858  05a5							; if Not a match, so jump to the next line of code.
    859  05a5							; Branches based upon value on top of the stack
    860  05a5				   iBranch
    861  05a5		       20 2a 1c 	      jsr	popR0
    862  05a8		       a5 52		      lda	R0
    863  05aa		       05 53		      ora	R0+1
    864  05ac		       f0 03		      beq	iBranchFalse	; not true
    865  05ae		       4c c2 02 	      jmp	NextIL	; It is true if any value not zero
    866  05b1							;
    867  05b1				   iBranchFalse
    868  05b1		       20 37 1a 	      jsr	FindNextLine
    869  05b4		       4c b5 04 	      jmp	iXFER2
    870  05b7							;
    871  05b7							;=====================================================
    872  05b7							; Start a read of data in background
    873  05b7				   iReadStart
    874  05b7		       a9 3f		      lda	#'?	; Prompt with question mark
    875  05b9		       a6 01		      ldx	1	; Indicate to start read in background
    876  05bb		       20 c3 1a 	      jsr	GetLine	; Call the getline to start read
    877  05be		       4c c2 02 	      jmp	NextIL	; next instruction
    878  05c1							;
    879  05c1							;=====================================================
    880  05c1							; Complete the read and return the curptr, curoff pointing to data
    881  05c1				   iReadComplete
    882  05c1		       20 c0 1b 	      jsr	pushLN
    883  05c4		       90 03		      bcc	iReadOk
    884  05c6		       4c a5 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    885  05c9				   iReadOk
    886  05c9		       20 e3 1a 	      jsr	ReadComplete
    887  05cc		       4c c2 02 	      jmp	NextIL
    888  05cf		       20 e5 1b 	      jsr	popLN
    889  05d2		       4c c2 02 	      jmp	NextIL
    890  05d5							;=====================================================
    891  05d5							; Get a line of text from the user, convert to a
    892  05d5							; number, leave on top of stack.
    893  05d5							;
    894  05d5				   iINNUM
    895  05d5		       20 c0 1b 	      jsr	pushLN
    896  05d8		       b0 ec		      bcs	iReadErr	; Stack over flow error
    897  05da							;
    898  05da		       a9 3f		      lda	#'?
    899  05dc		       a2 00		      ldx	#0	;Wait for complete
    900  05de		       20 c3 1a 	      jsr	GetLine
    901  05e1		       20 58 1a 	      jsr	getDecimal
    902  05e4		       20 a6 1b 	      jsr	pushR0	;put onto stack
    903  05e7		       b0 dd		      bcs	iReadErr	;StackOverflow error
    904  05e9							;
    905  05e9		       4c 03 06 	      jmp	ExitIn
    906  05ec							;
    907  05ec							;=====================================================
    908  05ec							; Get a line of text from the user, convert to a
    909  05ec							; character value , leave on top of stack. up to 2 characters
    910  05ec							;
    911  05ec				   iINSTR
    912  05ec		       20 c0 1b 	      jsr	pushLN
    913  05ef		       b0 d5		      bcs	iReadErr	; Stack overflow error
    914  05f1		       a9 3f		      lda	#'?
    915  05f3		       a2 00		      ldx	#0	;wait for read complete
    916  05f5		       20 c3 1a 	      jsr	GetLine
    917  05f8		       b1 4f		      lda	(CURPTR),y
    918  05fa		       85 52		      sta	R0
    919  05fc		       a9 00		      lda	#0
    920  05fe		       85 53		      sta	R0+1
    921  0600		       20 a6 1b 	      jsr	pushR0	;put onto stack
    922  0603				   ExitIn
    923  0603		       20 e5 1b 	      jsr	popLN
    924  0606		       4c c2 02 	      jmp	NextIL
    925  0609							;
    926  0609							;
    927  0609							;=====================================================
    928  0609							; Stop the currently running program.	Actually very
    929  0609							; simple to do... clear the RunMode flag, then set the
    930  0609							; ILPC to the standard handler and continue running.
    931  0609							;
    932  0609		       a9 00	   iFIN       lda	#0
    933  060b		       85 5b		      sta	RunMode
    934  060d		       20 4e 16 	      jsr	taskReset
    935  0610							;
    936  0610		       ad 27 2e 	      lda	errGoto
    937  0613		       85 43		      sta	ILPC
    938  0615		       ad 28 2e 	      lda	errGoto+1
    939  0618		       85 44		      sta	ILPC+1
    940  061a		       4c c2 02 	      jmp	NextIL
    941  061d							;
    942  061d							;=====================================================
    943  061d							; Handle the ERR opcode.  Following the instruction is
    944  061d							; a 16 bit error number.  Print an error message, and
    945  061d							; if we're in run mode, print the line number.  Stop
    946  061d							; program execution and return to the initial state.
    947  061d							;
    948  061d		       20 a9 19    iERR       jsr	getILWord	;get err code
    949  0620							;
    950  0620							; Enter here with the error code in X (LSB) and A (MSB).
    951  0620							;
    952  0620		       86 52	   iErr2      stx	R0
    953  0622		       85 53		      sta	R0+1
    954  0624							;
    955  0624		       20 59 14 	      jsr	puts
      0  0627					      db	CR,LF,"Error ",0
      1  0627		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    957  0630		       20 8a 13 	      jsr	PrintDecimal
    958  0633							;
    959  0633		       a5 5b		      lda	RunMode	;running?
    960  0635		       f0 3b		      beq	iERR3	;nope
    961  0637		       20 59 14 	      jsr	puts
      0  063a					      db	" at line ",0
      1  063a		       20 61 74 20*	      .byte.b	" at line ",0
    963  0644		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    964  0646				   iErr2a
    965  0646		       b1 4f		      lda	(CURPTR),y
    966  0648		       85 52		      sta	R0
    967  064a		       c8		      iny
    968  064b		       b1 4f		      lda	(CURPTR),y
    969  064d		       85 53		      sta	R0+1
    970  064f		       20 8a 13 	      jsr	PrintDecimal
    971  0652		       20 59 14 	      jsr	puts
      0  0655					      db	":",0
      1  0655		       3a 00		      .byte.b	":",0
    973  0657		       a9 00		      lda	#0
    974  0659		       85 53		      sta	R0+1
    975  065b		       a5 51		      lda	CUROFF
    976  065d		       18		      clc
    977  065e		       e9 03		      sbc	#3
    978  0660		       85 52		      sta	R0
    979  0662		       20 8a 13 	      jsr	PrintDecimal
    980  0665		       20 59 14 	      jsr	puts
      0  0668					      db	":",0
      1  0668		       3a 00		      .byte.b	":",0
    982  066a		       ad e1 24 	      lda	taskPtr
    983  066d		       85 52		      sta	R0
    984  066f		       20 8a 13 	      jsr	PrintDecimal
    985  0672							;
    986  0672		       20 e3 1c    iERR3      jsr	CRLF
    987  0675		       20 46 16 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    988  0678		       a9 00		      lda	#0
    989  067a		       85 5b		      sta	RunMode	;fall through...
    990  067c							;
    991  067c							;=====================================================
    992  067c							; Reset the IL to be back at the idle loop.  Does not
    993  067c							; clear variables so the user can see what state
    994  067c							; the program is in.
    995  067c							;
    996  067c		       a9 00	   ResetIL    lda	#0
    997  067e		       85 47		      sta	ILSTACKPTR
    998  0680		       ad 27 2e 	      lda	errGoto
    999  0683		       85 43		      sta	ILPC
   1000  0685		       ad 28 2e 	      lda	errGoto+1
   1001  0688		       85 44		      sta	ILPC+1
   1002  068a		       4c c2 02 	      jmp	NextIL
   1003  068d
   1004  068d							;
   1005  068d							;=====================================================
   1006  068d							; Pop two items off stack, add them, then place the
   1007  068d							; result back onto the stack.
   1008  068d							;
   1009  068d		       20 2a 1c    iADD       jsr	popR0
   1010  0690		       20 42 1c 	      jsr	popR1
   1011  0693				   iADDfast
   1012  0693		       18		      clc
   1013  0694		       a5 52		      lda	R0
   1014  0696		       65 54		      adc	R1
   1015  0698		       85 52		      sta	R0
   1016  069a		       a5 53		      lda	R0+1
   1017  069c		       65 55		      adc	R1+1
   1018  069e		       85 53		      sta	R0+1
   1019  06a0		       4c 0b 07 	      jmp	pushR0nextIl
   1020  06a3							;
   1021  06a3							;=====================================================
   1022  06a3							; Pop two items off the stack.  Subtract the top of
   1023  06a3							; stack from the lower entry.
   1024  06a3							;
   1025  06a3		       20 42 1c    iSUB       jsr	popR1
   1026  06a6		       20 2a 1c 	      jsr	popR0
   1027  06a9		       38		      sec
   1028  06aa		       a5 52		      lda	R0
   1029  06ac		       e5 54		      sbc	R1
   1030  06ae		       85 52		      sta	R0
   1031  06b0		       a5 53		      lda	R0+1
   1032  06b2		       e5 55		      sbc	R1+1
   1033  06b4		       85 53		      sta	R0+1
   1034  06b6		       4c 0b 07 	      jmp	pushR0nextIl
   1035  06b9							;
   1036  06b9							;=====================================================
   1037  06b9							; Negate the top of stack.
   1038  06b9							;
   1039  06b9		       20 2a 1c    iNEG       jsr	popR0
   1040  06bc		       a5 52		      lda	R0
   1041  06be		       49 ff		      eor	#$ff
   1042  06c0		       85 52		      sta	R0
   1043  06c2		       a5 53		      lda	R0+1
   1044  06c4		       49 ff		      eor	#$ff
   1045  06c6		       85 53		      sta	R0+1
   1046  06c8		       e6 52		      inc	R0
   1047  06ca		       d0 02		      bne	iNEG2
   1048  06cc		       e6 53		      inc	R0+1
   1049  06ce		       4c 0b 07    iNEG2      jmp	pushR0nextIl
   1050  06d1							;
   1051  06d1							;=====================================================
   1052  06d1							; Multiply top two items on the stack, put the results
   1053  06d1							; on top.  This uses the algorithm documented on page
   1054  06d1							; 115 of "Microprocessor Programming for Computer
   1055  06d1							; Hobbyists" by Neill Graham.
   1056  06d1							;
   1057  06d1		       20 d7 06    iMUL       jsr	iMultiply
   1058  06d4		       4c c2 02 	      jmp	NextIL
   1059  06d7
   1060  06d7				   iMultiply
   1061  06d7		       20 2a 1c 	      jsr	popR0	;AC
   1062  06da		       20 42 1c 	      jsr	popR1	;OP
   1063  06dd							;
   1064  06dd		       a5 52		      lda	R0
   1065  06df		       85 56		      sta	MQ
   1066  06e1		       a5 53		      lda	R0+1
   1067  06e3		       85 57		      sta	MQ+1
   1068  06e5		       a9 00		      lda	#0	;clear result
   1069  06e7		       85 52		      sta	R0
   1070  06e9		       85 53		      sta	R0+1
   1071  06eb							;
   1072  06eb		       a2 10		      ldx	#16	;number of bits in value
   1073  06ed		       06 52	   multloop   asl	R0
   1074  06ef		       26 53		      rol	R0+1
   1075  06f1		       06 56		      asl	MQ
   1076  06f3		       26 57		      rol	MQ+1
   1077  06f5		       90 0d		      bcc	multno	;skip add if no carry
   1078  06f7							;
   1079  06f7							; Add R1 back into R0
   1080  06f7							;
   1081  06f7		       18		      clc
   1082  06f8		       a5 52		      lda	R0
   1083  06fa		       65 54		      adc	R1
   1084  06fc		       85 52		      sta	R0
   1085  06fe		       a5 53		      lda	R0+1
   1086  0700		       65 55		      adc	R1+1
   1087  0702		       85 53		      sta	R0+1
   1088  0704							;
   1089  0704		       ca	   multno     dex		;did all bits yet?
   1090  0705		       d0 e6		      bne	multloop
   1091  0707		       20 a6 1b 	      jsr	pushR0	;OP
   1092  070a		       60		      rts
   1093  070b							;
   1094  070b				   pushR0nextIl
   1095  070b		       20 a6 1b 	      jsr	pushR0	;OP
   1096  070e		       4c c2 02 	      jmp	NextIL
   1097  0711							;
   1098  0711							;=====================================================
   1099  0711							; Divide the top of stack into the next to top item.
   1100  0711							; Leave results on stack.  Taken from:
   1101  0711							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1102  0711							;
   1103  0711							; R0 = R0 / R1
   1104  0711							; Remainder is in MQ
   1105  0711							;
   1106  0711		       20 2b 07    iDIV       jsr	iDoDiv
   1107  0714		       20 ab 1c 	      jsr	RestoreSigns
   1108  0717		       4c 0b 07 	      jmp	pushR0nextIl
   1109  071a
   1110  071a		       20 2b 07    iMOD       jsr	iDoDiv
   1111  071d		       20 ab 1c 	      jsr	RestoreSigns
   1112  0720		       a5 56		      lda	MQ
   1113  0722		       85 52		      sta	R0
   1114  0724		       a5 57		      lda	MQ+1
   1115  0726		       85 53		      sta	R0+1
   1116  0728		       4c 0b 07 	      jmp	pushR0nextIl
   1117  072b
   1118  072b				   iDoDiv
   1119  072b		       20 42 1c 	      jsr	popR1
   1120  072e		       20 2a 1c 	      jsr	popR0
   1121  0731							;
   1122  0731							; Check for divide by zero
   1123  0731							;
   1124  0731
   1125  0731				   iDivNoPop
   1126  0731		       a5 54		      lda	R1
   1127  0733		       05 55		      ora	R1+1
   1128  0735		       f0 29		      beq	divby0
   1129  0737							;
   1130  0737		       20 70 1c 	      jsr	SaveSigns
   1131  073a		       a9 00		      lda	#0	;preset remainder to 0
   1132  073c		       85 56		      sta	MQ
   1133  073e		       85 57		      sta	MQ+1
   1134  0740		       a2 10		      ldx	#16	;repeat for each bit: ...
   1135  0742				   divloop
   1136  0742		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1137  0744		       26 53		      rol	R0+1
   1138  0746		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1139  0748		       26 57		      rol	MQ+1
   1140  074a		       a5 56		      lda	MQ
   1141  074c		       38		      sec
   1142  074d		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1143  074f		       a8		      tay		;lb result -> Y, for we may need it later
   1144  0750		       a5 57		      lda	MQ+1
   1145  0752		       e5 55		      sbc	R1+1
   1146  0754		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1147  0756
   1148  0756		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1149  0758		       84 56		      sty	MQ
   1150  075a		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1151  075c
   1152  075c		       ca	   skip       dex
   1153  075d		       d0 e3		      bne	divloop
   1154  075f		       60		      rts
   1155  0760							;
   1156  0760							; Indicate divide-by-zero error
   1157  0760							;
   1158  0760		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1159  0762		       a9 00		      lda	#0
   1160  0764		       4c 20 06 	      jmp	iErr2
   1161  0767							;
   1162  0767							;=====================================================
   1163  0767							; This pops the top two items off the stack.  The top
   1164  0767							; item is a data value and the other is an ABSOLUTE address.
   1165  0767							;Save the value into that address.
   1166  0767							;
   1167  0767		       98	   iSTORE     tya
   1168  0768		       48		      pha
   1169  0769		       20 2a 1c 	      jsr	popR0	;data
   1170  076c		       20 42 1c 	      jsr	popR1	;Storage location
   1171  076f		       a0 00		      ldy	#0
   1172  0771		       a5 52		      lda	R0
   1173  0773		       91 54		      sta	(R1),y
   1174  0775		       a5 53		      lda	R0+1
   1175  0777		       c8		      iny
   1176  0778		       91 54		      sta	(R1),y
   1177  077a		       68		      pla
   1178  077b		       a8		      tay
   1179  077c		       4c c2 02 	      jmp	NextIL
   1180  077f							;
   1181  077f							;=====================================================
   1182  077f							; Replaces the top of stack with the variable whose
   1183  077f							; absolute address it represents.
   1184  077f							;
   1185  077f		       98	   iIND       tya
   1186  0780		       48		      pha
   1187  0781		       20 42 1c 	      jsr	popR1
   1188  0784		       a0 00		      ldy	#0
   1189  0786		       b1 54		      lda	(R1),y
   1190  0788		       85 52		      sta	R0
   1191  078a		       c8		      iny
   1192  078b		       b1 54		      lda	(R1),y
   1193  078d		       85 53		      sta	R0+1
   1194  078f		       68		      pla
   1195  0790		       a8		      tay
   1196  0791		       4c 0b 07 	      jmp	pushR0nextIl
   1197  0794							;
   1198  0794							;=====================================================
   1199  0794							; Get the array index from top of stack get Current variable
   1200  0794							; address from next on stack, add the offset
   1201  0794							; push the result back onto the stack
   1202  0794				   iArray
   1203  0794		       20 2a 1c 	      jsr	popR0	; Get the array index
   1204  0797		       20 42 1c 	      jsr	popR1	; Get the Variable address
   1205  079a
   1206  079a		       18		      clc		; Multiplythe value by 2
   1207  079b		       26 52		      rol	R0	; Do the multiply
   1208  079d		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1209  079f		       18		      clc
   1210  07a0		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1211  07a2		       65 52		      adc	R0
   1212  07a4		       85 52		      sta	R0
   1213  07a6		       a5 55		      lda	R1+1
   1214  07a8		       65 53		      adc	R0+1
   1215  07aa		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1216  07ac		       20 a6 1b 	      jsr	pushR0	; Push R0 assume it is correct
   1217  07af
   1218  07af		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1219  07b1		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1220  07b3		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1221  07b5		       a5 55		      lda	R1+1
   1222  07b7		       c5 42		      cmp	VARIABLES+1
   1223  07b9		       d0 1c		      bne	iArrayAtTest
   1224  07bb		       18		      clc
   1225  07bc		       a9 34		      lda	#52	; add the max offset that is valid
   1226  07be		       65 54		      adc	R1	; update to be the largest offset that is valid
   1227  07c0		       85 54		      sta	R1
   1228  07c2		       a9 00		      lda	#0
   1229  07c4		       65 55		      adc	R1+1
   1230  07c6		       85 55		      sta	R1+1
   1231  07c8				   iArrayVerify 		; try to enforce some sanity to using arrays
   1232  07c8		       a5 53		      lda	R0+1
   1233  07ca		       c5 55		      cmp	R1+1
   1234  07cc		       d0 04		      bne	iArrayDecide
   1235  07ce		       a5 52		      lda	R0
   1236  07d0		       c5 54		      cmp	R1
   1237  07d2				   iArrayDecide
   1238  07d2		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1239  07d4		       4c c2 02 	      jmp	NextIL
   1240  07d7
   1241  07d7				   iArrayAtTest
   1242  07d7		       ad 3e 2e 	      lda	HighMem
   1243  07da		       85 54		      sta	R1
   1244  07dc		       ad 3f 2e 	      lda	HighMem+1
   1245  07df		       85 55		      sta	R1+1
   1246  07e1		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1247  07e3
   1248  07e3							; Get here if array index is out of range
   1249  07e3		       20 2a 1c    iArrayError jsr	popR0
   1250  07e6		       a9 00		      lda	#0
   1251  07e8		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1252  07ea		       4c 20 06 	      jmp	iErr2
   1253  07ed							;
   1254  07ed							;=====================================================
   1255  07ed							; List the current BASIC program in memory.  Uses R0,
   1256  07ed							; tempIly, and dpl.
   1257  07ed							;
   1258  07ed		       20 12 1e    iLST       jsr	SetOutConsole
   1259  07f0		       ad 3a 2e    iLST2      lda	ProgramStart
   1260  07f3		       85 59		      sta	dpl
   1261  07f5		       ad 3b 2e 	      lda	ProgramStart+1
   1262  07f8		       85 5a		      sta	dpl+1
   1263  07fa							;
   1264  07fa							; dpl/dph point to the current line.  See if we're at
   1265  07fa							; the end of the program.
   1266  07fa							;
   1267  07fa		       a5 59	   iLSTloop   lda	dpl
   1268  07fc		       cd 3c 2e 	      cmp	ProgramEnd
   1269  07ff		       d0 07		      bne	iLstNotEnd
   1270  0801		       a5 5a		      lda	dpl+1
   1271  0803		       cd 3d 2e 	      cmp	ProgramEnd+1
   1272  0806		       f0 15		      beq	iLstdone
   1273  0808							;
   1274  0808		       20 eb 11    iLstNotEnd jsr	PrintProgramLine
   1275  080b							;		  ldy	  #1		  ;Change:  Skip first byte length
   1276  080b							;		  lda	  (dpl),y	  ;line number LSB
   1277  080b							;		  sta	  R0
   1278  080b							;		  iny
   1279  080b							;		  lda	  (dpl),y		 ;line number MSB
   1280  080b							;		  sta	  R0+1
   1281  080b							;		  iny
   1282  080b							;		  sty	  tempIlY
   1283  080b							;		  jsr	  PrintDecimal
   1284  080b							;		  lda	  #SPACE
   1285  080b							;		  jsr	  VOUTCH
   1286  080b							;		  ldy	  tempIlY
   1287  080b							;iLSTl2	  lda	  (dpl),y
   1288  080b							;		  beq	  iLST3 	  ;end of this line 0 value
   1289  080b							;		  sty	  tempIlY
   1290  080b							;		  jsr	  VOUTCH
   1291  080b							;		  ldy	  tempIlY
   1292  080b							;		  iny
   1293  080b							;		  bne	  iLSTl2	  ;do next char
   1294  080b							;
   1295  080b							; End of this line.  Print CR/LF, then move to the
   1296  080b							; next line.
   1297  080b							;
   1298  080b		       a0 00	   iLST3      ldy	#0	;Move to next line
   1299  080d		       b1 59		      lda	(dpl),y	;Current line length
   1300  080f		       18		      clc		;Clear the carry flag
   1301  0810							;		  tya
   1302  0810		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  0812		       85 59		      sta	dpl	;Save the new value
   1304  0814		       a5 5a		      lda	dpl+1	;Next byte
   1305  0816		       69 00		      adc	#0	;ad in the carry if any
   1306  0818		       85 5a		      sta	dpl+1	;Save it
   1307  081a							;
   1308  081a							; Have to manually do CR/LF so it uses the vectored
   1309  081a							; output function.
   1310  081a							;
   1311  081a							;		  lda	  #CR
   1312  081a							;		  jsr	  VOUTCH
   1313  081a							;		  lda	  #LF
   1314  081a							;		  jsr	  VOUTCH
   1315  081a		       4c fa 07 	      jmp	iLSTloop	;do next line
   1316  081d							;
   1317  081d		       20 12 1e    iLstdone   jsr	SetOutConsole
   1318  0820		       4c c2 02 	      jmp	NextIL
   1319  0823							;
   1320  0823							;=====================================================
   1321  0823							; Get a line of text into LINBUF.  Terminate with a
   1322  0823							; null byte.
   1323  0823							;
   1324  0823				   iGETLINE
   1325  0823		       a9 3e		      lda	#'>	;prompt character
   1326  0825		       a6 00		      ldx	0	;Wait for read to complete
   1327  0827		       20 c3 1a 	      jsr	GetLine
   1328  082a							;
   1329  082a		       a9 00		      lda	#0
   1330  082c		       85 5b		      sta	RunMode
   1331  082e				   iGetParseLine
   1332  082e							; lda	   CUROFF
   1333  082e							; pha
   1334  082e		       20 92 0f 	      jsr	ParseInputLine
   1335  0831							; pla
   1336  0831							;  sta     CUROFF
   1337  0831		       a9 8f		      lda	#TOKENBUFFER&$FF
   1338  0833		       85 4f		      sta	CURPTR
   1339  0835		       a9 0e		      lda	#TOKENBUFFER>>8
   1340  0837		       85 50		      sta	CURPTR+1
   1341  0839		       a9 01		      lda	#1
   1342  083b		       85 51		      sta	CUROFF
   1343  083d		       4c c2 02 	      jmp	NextIL
   1344  0840							;
   1345  0840							;=====================================================
   1346  0840							; This is called when the input buffer contains a line
   1347  0840							; typed in by the user that starts with a line number.
   1348  0840							; Insert the line into the program or delete the line
   1349  0840							; if there is nothing after the line number,
   1350  0840							;
   1351  0840				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1352  0840		       ad 90 0e 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1353  0843		       85 52		      sta	R0	; place the number into R0
   1354  0845		       ad 91 0e 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1355  0848		       85 53		      STA	R0+1	; Place it into
   1356  084a							;
   1357  084a							; Now find the line OR the next higher line OR the
   1358  084a							; end of the program.
   1359  084a							;
   1360  084a		       20 f2 19 	      jsr	findLine	; Look for the line number in the current program
   1361  084d							; Returns Z and curptr point to the line if found
   1362  084d							; Returns C and curptr at next higher line if not found and there is a higher line
   1363  084d							; Returns ZC clear and curptr to end of program if higher than all other lines
   1364  084d							;
   1365  084d							; If the line exists, it needs to be removed.
   1366  084d							;
   1367  084d		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1368  084f							;
   1369  084f							; Get length of line to be removed, we fall thru to here if we find a matching line
   1370  084f							;
   1371  084f							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1372  084f		       a0 00		      ldy	#0
   1373  0851		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1374  0853		       a8		      tay
   1375  0854							;If it is equal we delete the line and replace it, get length
   1376  0854							;then adjust all program line after up or down depending on len of line
   1377  0854							;If next higher then just move everythimg down by length bytes
   1378  0854							;This call will return how many bytes in the line we found
   1379  0854		       8c 37 2e 	      sty	lineLength	;Save the length of the line we found
   1380  0857							;
   1381  0857							; Compute the new end of the program first.
   1382  0857							;
   1383  0857		       38		      sec		;Set the carry bit
   1384  0858		       ad 3c 2e 	      lda	ProgramEnd	;Get low byte of program end
   1385  085b		       ed 37 2e 	      sbc	lineLength	;Subtract the length of the current line
   1386  085e		       8d 3c 2e 	      sta	ProgramEnd	;save it
   1387  0861		       ad 3d 2e 	      lda	ProgramEnd+1
   1388  0864		       e9 00		      sbc	#0	;Process the carry
   1389  0866		       8d 3d 2e 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1390  0869							;
   1391  0869							; Copy CURPTR into R1 for working
   1392  0869							;
   1393  0869		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1394  086b		       85 54		      sta	R1
   1395  086d		       a5 50		      lda	CURPTR+1
   1396  086f		       85 55		      sta	R1+1
   1397  0871							;
   1398  0871							; See if we're at the end.
   1399  0871							;
   1400  0871		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1401  0873		       cd 3c 2e 	      cmp	ProgramEnd
   1402  0876		       d0 07		      bne	InsDelLoop
   1403  0878		       a5 55		      lda	R1+1
   1404  087a		       cd 3d 2e 	      cmp	ProgramEnd+1
   1405  087d		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1406  087f							;
   1407  087f							; Move one byte, move to next location.
   1408  087f							;
   1409  087f		       ac 37 2e    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1410  0882		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1411  0884		       b1 54		      lda	(R1),y
   1412  0886		       a0 00		      ldy	#0
   1413  0888		       91 54		      sta	(R1),y
   1414  088a		       e6 54		      inc	R1
   1415  088c		       d0 e3		      bne	InsDelChk
   1416  088e		       e6 55		      inc	R1+1
   1417  0890		       4c 71 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1418  0893							;
   1419  0893							; Deletion is done.
   1420  0893							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1421  0893							;
   1422  0893				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1423  0893		       ad 8f 0e 	      lda	TOKENBUFFER	; Get the length
   1424  0896		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1425  0898							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1426  0898		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1427  089a							;
   1428  089a							; CURPTR points to where the line will be inserted.
   1429  089a							;
   1430  089a							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1431  089a		       ae 8f 0e 	      ldx	TOKENBUFFER
   1432  089d		       8e 37 2e 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1433  08a0							;
   1434  08a0		       ad 3c 2e 	      lda	ProgramEnd	;Load the start address for the copy
   1435  08a3							;At this point curptr still contains the location we will insert data
   1436  08a3		       85 5c		      sta	FROM
   1437  08a5		       ad 3d 2e 	      lda	ProgramEnd+1
   1438  08a8		       85 5d		      sta	FROM+1
   1439  08aa							;
   1440  08aa		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1441  08ac		       b1 5c		      lda	(FROM),y
   1442  08ae		       ac 37 2e 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1443  08b1		       91 5c		      sta	(FROM),y	;Save the new byte
   1444  08b3							;
   1445  08b3		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1446  08b5		       c5 4f		      cmp	CURPTR
   1447  08b7		       d0 06		      bne	mvUpMore
   1448  08b9		       a5 5d		      lda	FROM+1
   1449  08bb		       c5 50		      cmp	CURPTR+1
   1450  08bd		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1451  08bf							;
   1452  08bf							; Not done yet
   1453  08bf							;
   1454  08bf		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1455  08c1		       d0 02		      bne	mvUpMore2
   1456  08c3		       c6 5d		      dec	FROM+1
   1457  08c5		       c6 5c	   mvUpMore2  dec	FROM
   1458  08c7		       4c aa 08 	      jmp	mvup1	;Loop until everything is moved
   1459  08ca							;
   1460  08ca							; All done with copy.
   1461  08ca							;
   1462  08ca				   mvUpDone
   1463  08ca		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1464  08cb		       ad 37 2e 	      lda	lineLength	;Number of bytes to copy from line buff
   1465  08ce		       6d 3c 2e 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1466  08d1		       8d 3c 2e 	      sta	ProgramEnd
   1467  08d4		       ad 3d 2e 	      lda	ProgramEnd+1
   1468  08d7		       69 00		      adc	#0
   1469  08d9		       8d 3d 2e 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1470  08dc							;
   1471  08dc							;===================jlit use length before line newline
   1472  08dc
   1473  08dc		       a0 00		      ldy	#0	;Set offset of copy
   1474  08de							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1475  08de							;		  sta	  (CURPTR),y	  ;Store the length
   1476  08de							;		  iny
   1477  08de							;		  lda	  R0		  ;Store the line number next
   1478  08de							;		  sta	  (CURPTR),y
   1479  08de							;		  iny
   1480  08de							;		  lda	  R0+1
   1481  08de							;		  sta	  (CURPTR),y
   1482  08de							;		  iny
   1483  08de							;
   1484  08de							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1485  08de		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1486  08e0				   mvUpLoop2
   1487  08e0							;		  lda	  LINBUF,x	 ;get a byte
   1488  08e0		       bd 8f 0e 	      lda	TOKENBUFFER,x	;get a byte
   1489  08e3		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1490  08e5
   1491  08e5		       e8		      inx
   1492  08e6		       ec 8f 0e 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1493  08e9		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1494  08eb		       c8		      iny
   1495  08ec		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1496  08ee							;
   1497  08ee		       4c c2 02    mvUpFini   jmp	NextIL
   1498  08f1							;
   1499  08f1							;=====================================================
   1500  08f1							; Pops the top value of the ILPC stack and stores it
   1501  08f1							; in ILPC.  Ie, return from an IL subroutine.
   1502  08f1							;
   1503  08f1		       20 e0 19    iRTN       jsr	popILPC
   1504  08f4		       4c c2 02 	      jmp	NextIL
   1505  08f7							;
   1506  08f7							;=====================================================
   1507  08f7							; NLINE print a newline
   1508  08f7							;
   1509  08f7		       20 e3 1c    iNLINE     jsr	CRLF	;user supplied sub
   1510  08fa		       4c c2 02 	      jmp	NextIL
   1511  08fd							;
   1512  08fd							;=====================================================
   1513  08fd							; This saves the current ILPC value on the stack, then
   1514  08fd							; jumps to the address specified by the next two bytes.
   1515  08fd							;
   1516  08fd		       20 c3 19    iCALL      jsr	pushILPC	;save ILPC
   1517  0900		       90 03		      bcc	iJMP
   1518  0902		       4c a5 0b 	      jmp	ErrStkOver	; Check if there was an error
   1519  0905							;
   1520  0905							; Jmp to a specific location in the IL code.  The new
   1521  0905							; address immediately follows the opcode.
   1522  0905							;
   1523  0905		       20 a9 19    iJMP       jsr	getILWord
   1524  0908		       86 43		      stx	ILPC
   1525  090a		       85 44		      sta	ILPC+1
   1526  090c		       4c c2 02 	      jmp	NextIL
   1527  090f
   1528  090f
   1529  090f							;
   1530  090f							;=====================================================
   1531  090f							; Push the next two bytes onto the arithmetic stack.
   1532  090f							;
   1533  090f		       20 ad 19    iSetR2     jsr	getILByte
   1534  0912		       85 58		      sta	R2
   1535  0914		       4c c2 02 	      jmp	NextIL
   1536  0917							;
   1537  0917							;=====================================================
   1538  0917							; Push the next two bytes onto the arithmetic stack.
   1539  0917							;
   1540  0917		       20 a9 19    iLIT       jsr	getILWord
   1541  091a		       86 52		      stx	R0
   1542  091c		       85 53		      sta	R0+1
   1543  091e		       20 a6 1b 	      jsr	pushR0
   1544  0921		       4c c2 02 	      jmp	NextIL
   1545  0924							;
   1546  0924							;=====================================================
   1547  0924							; Initialize all variables for a single task.	Ie, set to zero.
   1548  0924							;
   1549  0924		       98	   subVINIT   tya
   1550  0925		       48		      pha
   1551  0926
   1552  0926		       a9 00		      lda	#0
   1553  0928		       a0 00		      ldy	#0
   1554  092a		       91 41	   Vinit2     sta	(VARIABLES),y
   1555  092c		       c8		      iny
   1556  092d		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1557  092f		       90 f9		      bcc	Vinit2
   1558  0931
   1559  0931		       68		      pla
   1560  0932		       a8		      tay
   1561  0933		       60		      rts
   1562  0934
   1563  0934		       20 24 09    iVINIT     jsr	subVINIT
   1564  0937		       4c c2 02 	      jmp	NextIL
   1565  093a							;
   1566  093a							;=====================================================
   1567  093a							; Set the address of the error handler.  After any
   1568  093a							; error, set to the ILPC to the specified location.
   1569  093a							;
   1570  093a		       20 a9 19    iERRGOTO   jsr	getILWord
   1571  093d		       8e 27 2e 	      stx	errGoto
   1572  0940		       8d 28 2e 	      sta	errGoto+1
   1573  0943		       4c c2 02 	      jmp	NextIL
   1574  0946							;
   1575  0946							;=====================================================
   1576  0946							; TST is followed by an 8 bit signed offset, then a
   1577  0946							; null terminated string.  Compare the string against
   1578  0946							; the string starting at (CURPTR),CUROFF.  If the
   1579  0946							; strings match, continue executing the next IL
   1580  0946							; opcode.  Else, add the offset to ILPC.
   1581  0946							;
   1582  0946		       20 ad 19    iTST       jsr	getILByte	;Get the relative jump address
   1583  0949		       8d 36 2e 	      sta	offset	;save it to use if test faile
   1584  094c		       20 90 1b 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1585  094f
   1586  094f		       a4 51		      ldy	CUROFF
   1587  0951		       84 59		      sty	dpl	;save for later
   1588  0953							;
   1589  0953		       20 ad 19    iTSTloop   jsr	getILByte	;get next char
   1590  0956		       f0 11		      beq	iTSTm	;match!
   1591  0958		       a4 59		      ldy	dpl
   1592  095a		       d1 4f		      cmp	(CURPTR),y
   1593  095c		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1594  095e		       09 20		      ora	#$20	; lets allow lowercase as well
   1595  0960		       d1 4f		      cmp	(CURPTR),y
   1596  0962		       d0 23		      bne	iTSTfail	;mismatch
   1597  0964		       c8	   iTSTUpper  iny
   1598  0965		       84 59		      sty	dpl
   1599  0967		       d0 ea		      bne	iTSTloop
   1600  0969							;
   1601  0969							; It's a match!  Clean up a bit.
   1602  0969							;
   1603  0969		       a4 59	   iTSTm      ldy	dpl
   1604  096b		       84 51		      sty	CUROFF
   1605  096d		       4c c2 02 	      jmp	NextIL
   1606  0970
   1607  0970							; Test for a single quote string
   1608  0970		       20 ad 19    iTSTStr    jsr	getILByte
   1609  0973		       8d 36 2e 	      sta	offset
   1610  0976		       20 90 1b 	      jsr	saveIL
   1611  0979		       a4 51		      ldy	CUROFF
   1612  097b		       a9 22		      lda	#'"
   1613  097d		       d1 4f		      cmp	(CURPTR),y
   1614  097f		       d0 06		      bne	iTSTfail
   1615  0981		       c8		      iny
   1616  0982		       84 51		      sty	CUROFF
   1617  0984		       4c e0 02 	      jmp	NextILStr
   1618  0987							;
   1619  0987							; Not a match, reset ILPC and then move to the
   1620  0987							; offset.
   1621  0987							;
   1622  0987		       20 9b 1b    iTSTfail   jsr	restoreIL
   1623  098a		       4c 55 0b 	      jmp	tstBranch
   1624  098d							;
   1625  098d							;=================================================JLIT=
   1626  098d							; Test if we have a let statement without the let keyword
   1627  098d		       20 ad 19    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1628  0990		       8d 36 2e 	      sta	offset	; Save the jump offset for fails
   1629  0993		       20 90 1b 	      jsr	saveIL	; save to restore when done if fail
   1630  0996
   1631  0996		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1632  0998		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1633  099a		       c9 01		      cmp	#kLet	; Is it a let keyword
   1634  099c		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1635  099e		       c9 80		      cmp	#tVa	; lets check for a variable
   1636  09a0		       90 e5		      bcc	iTSTfail	; Less than variable range
   1637  09a2		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1638  09a4		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1639  09a6		       b0 df		      bcs	iTSTfail	; return it failed
   1640  09a8
   1641  09a8				   iTSTLETGOOD
   1642  09a8		       c8		      iny
   1643  09a9		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1644  09ab				   iTSTGOODVAR
   1645  09ab		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1646  09ae
   1647  09ae							;=================================================JLIT=
   1648  09ae							; Test a byte at an indirect address
   1649  09ae							; fails if byte is not equal to the value at the address
   1650  09ae							; The tests an indirect byte and branches if true
   1651  09ae		       20 ad 19    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1652  09b1		       8d 36 2e 	      sta	offset	; Save the jump offset for fails
   1653  09b4		       20 90 1b 	      jsr	saveIL	; save to restore when done if fail
   1654  09b7		       20 a9 19 	      jsr	getILWord	; Get a word into RO
   1655  09ba		       86 52		      stx	R0
   1656  09bc		       85 53		      sta	R0+1
   1657  09be		       20 ad 19 	      jsr	getILByte	; Get byte into A
   1658  09c1		       a0 00		      ldy	#0
   1659  09c3		       d1 52		      cmp	(R0),y
   1660  09c5		       d0 03		      bne	iTSTByteNotEqual
   1661  09c7		       4c 87 09 	      jmp	iTSTfail
   1662  09ca
   1663  09ca				   iTSTByteNotEqual
   1664  09ca		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1665  09cd
   1666  09cd							;=================================================JLIT=
   1667  09cd							; Test a byte	branch if it fails
   1668  09cd		       20 ad 19    iTSTB      jsr	getILByte	; Get the relative offset byte
   1669  09d0		       8d 36 2e 	      sta	offset	; Save the jump offset for fails
   1670  09d3		       20 90 1b 	      jsr	saveIL	; save to restore when done if fail
   1671  09d6		       20 ad 19 	      jsr	getILByte	; Get a word into RO
   1672  09d9		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1673  09db		       d1 4f		      cmp	(CURPTR),y
   1674  09dd		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1675  09df		       4c 87 09 	      jmp	iTSTfail	; REcover and move on to next test
   1676  09e2
   1677  09e2				   iTSTBMatch
   1678  09e2		       c8		      iny
   1679  09e3		       84 51		      sty	CUROFF	; Point to the next byte
   1680  09e5		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1681  09e8
   1682  09e8							;=================================================JLIT=
   1683  09e8							; Test a byte	branch if it fails
   1684  09e8		       20 ad 19    iTSTW      jsr	getILByte	; Get the relative offset byte
   1685  09eb		       8d 36 2e 	      sta	offset	; Save the jump offset for fails
   1686  09ee		       20 90 1b 	      jsr	saveIL	; save to restore when done if fail
   1687  09f1		       20 a9 19 	      jsr	getILWord	; Get a word into RO
   1688  09f4		       86 52		      stx	R0
   1689  09f6		       85 53		      sta	R0+1
   1690  09f8		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1691  09fa		       8a		      txa
   1692  09fb		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1693  09fd		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1694  09ff		       4c 87 09 	      jmp	iTSTfail	; REcover and move on to next test
   1695  0a02		       c8	   iTSTWM1    iny
   1696  0a03		       a5 53		      lda	R0+1
   1697  0a05		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1698  0a07		       f0 03		      beq	iTSTWMatch
   1699  0a09		       4c 87 09 	      jmp	iTSTfail
   1700  0a0c
   1701  0a0c				   iTSTWMatch
   1702  0a0c		       c8		      iny
   1703  0a0d		       84 51		      sty	CUROFF
   1704  0a0f		       4c c2 02 	      jmp	NextIL	; Then next instruction
   1705  0a12
   1706  0a12							;================================================jLIT=
   1707  0a12							;Test for end of line
   1708  0a12							;
   1709  0a12				   iTSTDONE
   1710  0a12		       20 ad 19 	      jsr	getILByte
   1711  0a15		       8d 36 2e 	      sta	offset
   1712  0a18		       20 90 1b 	      jsr	saveIL
   1713  0a1b		       a4 51		      ldy	CUROFF
   1714  0a1d		       84 59		      sty	dpl
   1715  0a1f		       b1 4f		      lda	(CURPTR),y
   1716  0a21		       f0 0b		      beq	iTSTDONEtrue
   1717  0a23		       c9 e6		      cmp	#oColon
   1718  0a25		       f0 07		      beq	iTSTDONEtrue
   1719  0a27		       a4 59		      ldy	dpl
   1720  0a29		       84 51		      sty	CUROFF
   1721  0a2b		       4c 87 09 	      jmp	iTSTfail
   1722  0a2e							;
   1723  0a2e							; Advance to the next line
   1724  0a2e							;
   1725  0a2e				   iTSTDONEtrue
   1726  0a2e		       4c c2 02 	      jmp	NextIL
   1727  0a31
   1728  0a31		       4c 55 0b    tstBranchLink jmp	tstBranch
   1729  0a34							;
   1730  0a34							;=====================================================
   1731  0a34							; Inc and dec a variable , faster than a = a + 1
   1732  0a34				   iINCVAR
   1733  0a34		       20 2a 1c 	      jsr	popR0
   1734  0a37		       a0 00		      ldy	#0
   1735  0a39		       18		      clc
   1736  0a3a		       a9 01		      lda	#1
   1737  0a3c		       71 52		      adc	(R0),y
   1738  0a3e		       91 52		      sta	(R0),y
   1739  0a40		       90 07		      bcc	iINCDONE
   1740  0a42		       c8		      iny
   1741  0a43		       a9 00		      lda	#0
   1742  0a45		       71 52		      adc	(R0),y
   1743  0a47		       91 52		      sta	(R0),y
   1744  0a49				   iINCDONE
   1745  0a49		       4c c2 02 	      jmp	NextIL
   1746  0a4c
   1747  0a4c				   iDECVAR
   1748  0a4c		       20 2a 1c 	      jsr	popR0
   1749  0a4f		       a0 00		      ldy	#0
   1750  0a51		       38		      sec
   1751  0a52		       b1 52		      lda	(R0),y
   1752  0a54		       e9 01		      sbc	#1
   1753  0a56		       91 52		      sta	(R0),y
   1754  0a58		       c8		      iny
   1755  0a59		       b1 52		      lda	(R0),y
   1756  0a5b		       e9 00		      sbc	#0
   1757  0a5d		       91 52		      sta	(R0),y
   1758  0a5f		       4c c2 02 	      jmp	NextIL
   1759  0a62
   1760  0a62
   1761  0a62							;
   1762  0a62							;=====================================================
   1763  0a62							; TSTV is followed by an 8 bit signed offset.	If the
   1764  0a62							; value at (CURPTR),CUROFF appears to be a variable
   1765  0a62							; name, move to the next IL statement.  Else, add the
   1766  0a62							; offset to ILPC. Converted to use actual absolute memory addresses
   1767  0a62							; TSTVT Looks for the task context
   1768  0a62							;
   1769  0a62		       20 42 1c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1770  0a65		       a9 00		      lda	#0
   1771  0a67		       85 58		      sta	R2
   1772  0a69		       f0 04		      beq	iTSTVV
   1773  0a6b
   1774  0a6b		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1775  0a6d		       85 58		      sta	R2
   1776  0a6f
   1777  0a6f		       20 ad 19    iTSTVV     jsr	getILByte	;offset
   1778  0a72		       8d 36 2e 	      sta	offset
   1779  0a75							;
   1780  0a75		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1781  0a77		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1782  0a79		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1783  0a7b		       4c 31 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1784  0a7e							;
   1785  0a7e				   iTSTVnext
   1786  0a7e		       c9 9d		      cmp	#tVat	;allow access to all unused memory as an array or integers
   1787  0a80		       f0 42		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1788  0a82
   1789  0a82		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1790  0a84		       f0 4e		      beq	iTSTVParm
   1791  0a86
   1792  0a86		       c9 9b		      cmp	#tVhat	; task exit code
   1793  0a88		       d0 04		      bne	iTSTV_A2Z
   1794  0a8a		       a9 19		      lda	#TASKEXITCODE
   1795  0a8c		       d0 0b		      bne	iTSTVContinue
   1796  0a8e
   1797  0a8e				   iTSTV_A2Z
   1798  0a8e
   1799  0a8e		       c9 80		      cmp	#tVa
   1800  0a90		       90 9f		      bcc	tstBranchLink
   1801  0a92		       c9 9a		      cmp	#tVz+1
   1802  0a94		       b0 9b		      bcs	tstBranchLink
   1803  0a96
   1804  0a96
   1805  0a96							;
   1806  0a96							; The condition is true, so convert to an index, push
   1807  0a96							; it onto the stack and continue running.
   1808  0a96							;
   1809  0a96		       29 7f		      and	#%01111111	;Mask off the high bit
   1810  0a98		       0a		      asl		;multiply by two
   1811  0a99
   1812  0a99				   iTSTVContinue
   1813  0a99		       c8		      iny
   1814  0a9a		       84 51		      sty	CUROFF	;it is a valid variable
   1815  0a9c		       48		      pha
   1816  0a9d		       a5 58		      lda	R2
   1817  0a9f		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1818  0aa1
   1819  0aa1		       20 90 19 	      jsr	ipc_getcontext	; Get the other tasks variables
   1820  0aa4		       a0 01		      ldy	#VARIABLEPOS
   1821  0aa6		       b1 56		      lda	(MQ),y
   1822  0aa8		       85 52		      sta	R0
   1823  0aaa		       c8		      iny
   1824  0aab		       b1 56		      lda	(MQ),y
   1825  0aad		       85 53		      sta	R0+1
   1826  0aaf		       4c ba 0a 	      jmp	iTSTVAddOffset
   1827  0ab2
   1828  0ab2				   iTSTVLocalValue
   1829  0ab2		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1830  0ab4		       85 52		      sta	R0
   1831  0ab6		       a5 42		      lda	VARIABLES+1
   1832  0ab8		       85 53		      sta	R0+1
   1833  0aba
   1834  0aba				   iTSTVAddOffset
   1835  0aba		       68		      pla
   1836  0abb		       85 54		      sta	R1
   1837  0abd		       a9 00		      lda	#0
   1838  0abf		       85 55		      sta	R1+1
   1839  0ac1
   1840  0ac1				   iTSTVcontinue
   1841  0ac1
   1842  0ac1		       4c 93 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1843  0ac4
   1844  0ac4							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1845  0ac4							; an array of integer values
   1846  0ac4				   iTSTVat
   1847  0ac4		       c8		      iny
   1848  0ac5		       84 51		      sty	CUROFF	;it is a valid variable
   1849  0ac7		       ad 3c 2e 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1850  0aca		       85 52		      sta	R0
   1851  0acc		       ad 3d 2e 	      lda	ProgramEnd+1
   1852  0acf		       85 53		      sta	R0+1
   1853  0ad1		       4c 0b 07 	      jmp	pushR0nextIl	;place this onto the stack
   1854  0ad4
   1855  0ad4							; When we get parameters passed we can access them using the # variable with[]
   1856  0ad4							; example #[0] #[1] etc, we dont check yet if there is too many
   1857  0ad4				   iTSTVParm
   1858  0ad4		       c8		      iny
   1859  0ad5		       84 51		      sty	CUROFF	;it is a valid variable
   1860  0ad7		       a5 48		      lda	MATHSTACK
   1861  0ad9		       85 52		      sta	R0
   1862  0adb		       a5 49		      lda	MATHSTACK+1
   1863  0add		       85 53		      sta	R0+1
   1864  0adf		       4c 0b 07 	      jmp	pushR0nextIl
   1865  0ae2
   1866  0ae2							;
   1867  0ae2							;=====================================================
   1868  0ae2							; TSTL seems basically the same as TSTN, but leave the
   1869  0ae2							; value in R0 instead of pushing onto stack.
   1870  0ae2							; This tests for a valid line number
   1871  0ae2							;
   1872  0ae2		       20 ad 19    iTSTL      jsr	getILByte
   1873  0ae5		       8d 36 2e 	      sta	offset
   1874  0ae8							;
   1875  0ae8		       a4 51		      ldy	CUROFF
   1876  0aea		       b1 4f		      lda	(CURPTR),y
   1877  0aec		       c8		      iny
   1878  0aed		       11 4f		      ora	(CURPTR),y
   1879  0aef		       f0 06		      beq	iTSTLNotLineNo
   1880  0af1
   1881  0af1
   1882  0af1							; In Both cases we need to point to the first usefull byte to process.
   1883  0af1		       c8		      iny
   1884  0af2		       84 51		      sty	CUROFF
   1885  0af4		       4c c2 02 	      jmp	NextIL
   1886  0af7				   iTSTLNotLineNo
   1887  0af7		       c8		      iny
   1888  0af8		       84 51		      sty	CUROFF
   1889  0afa		       4c 55 0b 	      jmp	tstBranch
   1890  0afd
   1891  0afd							;
   1892  0afd							;=====================================================
   1893  0afd							; TSTN checks for a number.  This is very simplistic;
   1894  0afd							; if the character is a digit, assume it's a number.
   1895  0afd							; Convert to a number and push it onto the stack.
   1896  0afd							;
   1897  0afd		       20 ad 19    iTSTN      jsr	getILByte
   1898  0b00		       8d 36 2e 	      sta	offset
   1899  0b03							;
   1900  0b03		       a9 00		      lda	#0
   1901  0b05		       85 59		      sta	dpl
   1902  0b07		       a4 51		      ldy	CUROFF
   1903  0b09				   chkType
   1904  0b09		       b1 4f		      lda	(CURPTR),y
   1905  0b0b		       c9 a2		      cmp	#tByte
   1906  0b0d		       f0 0e		      beq	chkByte
   1907  0b0f		       c9 a1		      cmp	#tInteger
   1908  0b11		       f0 16		      beq	chkInteger
   1909  0b13		       c9 eb		      cmp	#oMinus
   1910  0b15		       d0 3e		      bne	tstBranch
   1911  0b17		       e6 59		      inc	dpl
   1912  0b19		       c8		      iny
   1913  0b1a		       4c 09 0b 	      jmp	chkType
   1914  0b1d
   1915  0b1d				   chkByte
   1916  0b1d		       a9 00		      lda	#0
   1917  0b1f		       85 53		      sta	R0+1
   1918  0b21		       c8		      iny
   1919  0b22		       b1 4f		      lda	(CURPTR),y
   1920  0b24		       85 52		      sta	R0
   1921  0b26		       c8		      iny
   1922  0b27		       d0 0b		      bne	iTSTN_1
   1923  0b29
   1924  0b29				   chkInteger
   1925  0b29		       c8		      iny
   1926  0b2a		       b1 4f		      lda	(CURPTR),y
   1927  0b2c		       85 52		      sta	R0
   1928  0b2e		       c8		      iny
   1929  0b2f		       b1 4f		      lda	(CURPTR),y
   1930  0b31		       85 53		      sta	R0+1
   1931  0b33		       c8		      iny
   1932  0b34							;
   1933  0b34							; Check if it is negative and make it so
   1934  0b34							;
   1935  0b34				   iTSTN_1
   1936  0b34		       84 51		      sty	CUROFF
   1937  0b36
   1938  0b36		       a5 59		      lda	dpl
   1939  0b38		       f0 18		      beq	iTSTN_2	;positive
   1940  0b3a							;
   1941  0b3a		       a5 52		      lda	R0
   1942  0b3c		       05 53		      ora	R0+1
   1943  0b3e		       f0 12		      beq	iTSTN_2	;zero
   1944  0b40
   1945  0b40							; Invert all the bits, then add one.
   1946  0b40							;
   1947  0b40		       a5 52		      lda	R0
   1948  0b42		       49 ff		      eor	#$ff
   1949  0b44		       85 52		      sta	R0
   1950  0b46		       a5 53		      lda	R0+1
   1951  0b48		       49 ff		      eor	#$ff
   1952  0b4a		       85 53		      sta	R0+1
   1953  0b4c							;
   1954  0b4c		       e6 52		      inc	R0
   1955  0b4e		       d0 02		      bne	iTSTN_2
   1956  0b50		       e6 53		      inc	R0+1
   1957  0b52				   iTSTN_2
   1958  0b52		       20 0b 07 	      jsr	pushR0nextIl	;save onto stack
   1959  0b55
   1960  0b55							;
   1961  0b55							; Common jump point for all TSTx instructions that
   1962  0b55							; fail to meet the requirements.  This takes the
   1963  0b55							; offset and adds/subtracts to/from ILPC.
   1964  0b55							;
   1965  0b55		       ad 36 2e    tstBranch  lda	offset	;get signed offset
   1966  0b58		       10 0e		      bpl	tstPositive
   1967  0b5a							;
   1968  0b5a							; Do negative branch.	Do sign extension.
   1969  0b5a							;
   1970  0b5a		       18	   tstNegative clc
   1971  0b5b		       65 43		      adc	ILPC
   1972  0b5d		       85 43		      sta	ILPC
   1973  0b5f							;		  bcc	  tstBothDone
   1974  0b5f							;		  dec	  ILPC+1
   1975  0b5f							;		  jmp	  NextIL
   1976  0b5f
   1977  0b5f		       a5 44		      lda	ILPC+1
   1978  0b61		       69 ff		      adc	#$ff
   1979  0b63		       85 44		      sta	ILPC+1
   1980  0b65		       4c c2 02 	      jmp	NextIL	;keep going
   1981  0b68							;
   1982  0b68		       18	   tstPositive clc
   1983  0b69		       65 43		      adc	ILPC
   1984  0b6b		       85 43		      sta	ILPC
   1985  0b6d		       90 02		      bcc	tstBothDone
   1986  0b6f		       e6 44		      inc	ILPC+1
   1987  0b71				   tstBothDone
   1988  0b71		       4c c2 02 	      jmp	NextIL
   1989  0b74
   1990  0b74							;
   1991  0b74							;====================================================
   1992  0b74							; Test for IRQ pending, and test if a break key pressed
   1993  0b74							; Yes I know but this handles all sorts of irq/break issues
   1994  0b74							;
   1995  0b74		       20 ad 19    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1996  0b77		       8d 36 2e 	      sta	offset	; Store the not true jump address offset
   1997  0b7a		       20 42 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1998  0b7d		       d0 03		      bne	irqNo	; z not set of no break found
   1999  0b7f		       4c 09 06 	      jmp	iFIN	; Exit out of run mode
   2000  0b82		       ad de 24    irqNo      lda	IRQPending
   2001  0b85		       f0 ce		      beq	tstBranch
   2002  0b87		       c9 01		      cmp	#1	; only do this if set to first time
   2003  0b89		       d0 ca		      bne	tstBranch
   2004  0b8b		       78		      sei		; disable the interupt until ireturn resets it
   2005  0b8c		       ee de 24    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2006  0b8f		       20 c0 1b 	      jsr	pushLN	; Push the next line to be executed
   2007  0b92		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   2008  0b94		       ad df 24 	      lda	IRQEntry	; Get the line number to branch to
   2009  0b97		       85 4f		      sta	CURPTR	; put line number into r0
   2010  0b99		       ad e0 24 	      lda	IRQEntry+1
   2011  0b9c		       85 50		      sta	CURPTR+1
   2012  0b9e		       a9 03		      lda	#3	; Point to first byte of program text
   2013  0ba0		       85 51		      sta	CUROFF
   2014  0ba2		       4c c2 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2015  0ba5
   2016  0ba5		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2017  0ba7		       a9 00		      lda	#0	; stop the execution
   2018  0ba9		       4c 20 06 	      jmp	iErr2
   2019  0bac							;
   2020  0bac
   2021  0bac							;=====================================================
   2022  0bac							; This places the number of free bytes on top of the
   2023  0bac							; stack.
   2024  0bac							;
   2025  0bac		       20 13 15    iFREE      jsr	MemFree
   2026  0baf		       20 a6 1b 	      jsr	pushR0
   2027  0bb2		       4c c2 02 	      jmp	NextIL
   2028  0bb5							;
   2029  0bb5							;=====================================================
   2030  0bb5							; Generate a random number from 0-FFFF and then MOD
   2031  0bb5							; it with the value on top of stack.  Leaves number on
   2032  0bb5							; stack
   2033  0bb5							;
   2034  0bb5		       20 42 1c    iRANDOM    jsr	popR1	;mod value
   2035  0bb8							;
   2036  0bb8							; If the value is zero, just return a one.
   2037  0bb8							;
   2038  0bb8		       a5 54		      lda	R1
   2039  0bba		       05 55		      ora	R1+1
   2040  0bbc		       f0 4a		      beq	irandom1
   2041  0bbe							;
   2042  0bbe		       ad 2d 2e 	      lda	random+1
   2043  0bc1		       8d 2a 2e 	      sta	rtemp1
   2044  0bc4		       ad 2c 2e 	      lda	random
   2045  0bc7		       0a		      asl
   2046  0bc8		       2e 2a 2e 	      rol	rtemp1
   2047  0bcb		       0a		      asl
   2048  0bcc		       2e 2a 2e 	      rol	rtemp1
   2049  0bcf		       18		      clc
   2050  0bd0		       6d 2c 2e 	      adc	random
   2051  0bd3
   2052  0bd3		       48		      pha
   2053  0bd4
   2054  0bd4		       ad 2a 2e 	      lda	rtemp1
   2055  0bd7		       6d 2d 2e 	      adc	random+1
   2056  0bda		       8d 2d 2e 	      sta	random+1
   2057  0bdd
   2058  0bdd		       68		      pla
   2059  0bde
   2060  0bde		       69 11		      adc	#$11
   2061  0be0		       8d 2c 2e 	      sta	random
   2062  0be3		       ad 2d 2e 	      lda	random+1
   2063  0be6		       69 36		      adc	#$36
   2064  0be8		       8d 2d 2e 	      sta	random+1
   2065  0beb
   2066  0beb		       ad 2c 2e 	      lda	random
   2067  0bee		       85 52		      sta	R0
   2068  0bf0		       ad 2d 2e 	      lda	random+1
   2069  0bf3		       29 7f		      and	#$7f	;make positive
   2070  0bf5		       85 53		      sta	R0+1
   2071  0bf7							;
   2072  0bf7							; R0 contains the number and R1 contains the max value.
   2073  0bf7							;
   2074  0bf7		       20 31 07 	      jsr	iDivNoPop
   2075  0bfa		       20 ab 1c 	      jsr	RestoreSigns
   2076  0bfd		       a5 56		      lda	MQ
   2077  0bff		       85 52		      sta	R0
   2078  0c01		       a5 57		      lda	MQ+1
   2079  0c03		       85 53		      sta	R0+1
   2080  0c05		       4c 0b 07 	      jmp	pushR0nextIl
   2081  0c08				   irandom1
   2082  0c08		       a9 00		      lda	#0
   2083  0c0a		       85 53		      sta	R0+1
   2084  0c0c		       a9 01		      lda	#1
   2085  0c0e		       85 52		      sta	R0
   2086  0c10		       4c 0b 07 	      jmp	pushR0nextIl
   2087  0c13
   2088  0c13							; The following replaced by call to division/modulo
   2089  0c13							;iRANDOM_2	lda	R0
   2090  0c13							;		cmp	R1
   2091  0c13							;		bne	iRANDOM_1
   2092  0c13							;		lda	R0+1
   2093  0c13							;		cmp	R1+1
   2094  0c13							;		bne	iRANDOM_1	;need to subtract
   2095  0c13							;
   2096  0c13							; Subtract R1 from R0
   2097  0c13							;
   2098  0c13							;iRANDOM_sub	sec
   2099  0c13							;		lda	R0
   2100  0c13							;		sbc	R1
   2101  0c13							;		sta	R0
   2102  0c13							;		lda	R0+1
   2103  0c13							;		sbc	R1+1
   2104  0c13							;		sta	R0+1
   2105  0c13							;		jmp	iRANDOM_2
   2106  0c13							;
   2107  0c13							; See if R1 > R0.  If so, branch to subtract.
   2108  0c13							;
   2109  0c13							;iRANDOM_1	lda	R0
   2110  0c13							;		cmp	R1
   2111  0c13							;		lda	R0+1
   2112  0c13							;		sbc	R1+1
   2113  0c13							;		bvc	iRANDOM_4
   2114  0c13							;		eor	#$80
   2115  0c13							;iRANDOM_4	bpl	iRANDOM_sub
   2116  0c13							;
   2117  0c13							; All done.  Almost.  Add one, then push the result.
   2118  0c13							;
   2119  0c13							;irandom1	inc	R0
   2120  0c13							;		bne	iRANDOM_3
   2121  0c13							;		inc	R0+1
   2122  0c13							;iRANDOM_3
   2123  0c13							;		  jsr	pushR0	;return value
   2124  0c13							;		jmp	NextIL
   2125  0c13							;
   2126  0c13							; Poke a value into a memory location
   2127  0c13		       8c 32 2e    iPOKEMEMORY sty	tempy
   2128  0c16		       20 2a 1c 	      jsr	popR0
   2129  0c19		       20 42 1c 	      jsr	popR1
   2130  0c1c		       a0 00		      ldy	#0
   2131  0c1e		       a5 52		      lda	R0
   2132  0c20		       91 54		      sta	(R1),y
   2133  0c22		       ac 32 2e 	      ldy	tempy
   2134  0c25		       4c c2 02 	      jmp	NextIL
   2135  0c28							;
   2136  0c28							; Get a value from a memory location
   2137  0c28							;
   2138  0c28		       8c 32 2e    iPEEKMEMORY sty	tempy
   2139  0c2b		       20 2a 1c 	      jsr	popR0
   2140  0c2e		       a0 00		      ldy	#0
   2141  0c30		       b1 52		      lda	(R0),y
   2142  0c32		       ac 32 2e 	      ldy	tempy
   2143  0c35		       85 52		      sta	R0
   2144  0c37		       a9 00		      lda	#0
   2145  0c39		       85 53		      sta	R0+1
   2146  0c3b		       4c 0b 07 	      jmp	pushR0nextIl
   2147  0c3e							;
   2148  0c3e							; Call to address return what ever is in a to the stack
   2149  0c3e							; func2 will load a value into a before the call
   2150  0c3e		       20 42 1c    iCallFunc  jsr	popR1
   2151  0c41		       a5 54		      lda	R1
   2152  0c43		       20 4f 0c 	      jsr	iCallRtn
   2153  0c46		       85 52		      sta	R0
   2154  0c48		       a9 00		      lda	#0
   2155  0c4a		       85 53		      sta	R0+1
   2156  0c4c		       20 0b 07 	      jsr	pushR0nextIl
   2157  0c4f				   iCallRtn
   2158  0c4f		       20 2a 1c 	      jsr	popR0
   2159  0c52		       6c 52 00 	      jmp	(R0)
   2160  0c55
   2161  0c55
   2162  0c55							;===========================================jlit======
   2163  0c55							;Get a character from the terminal convert to value
   2164  0c55							;leave the number on top of the stack
   2165  0c55							;
   2166  0c55				   iGETCHAR
   2167  0c55		       20 2f 1e 	      jsr	VGETCH
   2168  0c58					      if	CTMON65
   2169  0c58		       48		      pha
   2170  0c59		       20 2c 1e 	      jsr	VOUTCH	;echo echo echo
   2171  0c5c		       68		      pla
   2172  0c5d					      endif
   2173  0c5d		       85 52		      sta	R0
   2174  0c5f		       a9 00		      lda	#0
   2175  0c61		       85 53		      sta	R0+1
   2176  0c63		       20 a6 1b 	      jsr	pushR0
   2177  0c66							;
   2178  0c66		       4c c2 02 	      jmp	NextIL
   2179  0c69							;===========================================jusilostintim======
   2180  0c69							;Put a character to the terminal convert to
   2181  0c69							;
   2182  0c69		       20 2a 1c    iPUTCHAR   jsr	popR0
   2183  0c6c		       a5 52		      lda	R0
   2184  0c6e		       20 2c 1e 	      jsr	VOUTCH
   2185  0c71		       4c c2 02 	      jmp	NextIL
   2186  0c74							;=====================================================
   2187  0c74							; Put the number on the stack out as hex, suppress leading 0
   2188  0c74				   iHexOut
   2189  0c74		       20 2a 1c 	      jsr	popR0
   2190  0c77		       a5 53		      lda	R0+1
   2191  0c79		       f0 03		      beq	iHexSecondByte
   2192  0c7b		       20 3c 14 	      jsr	OUTHEX
   2193  0c7e				   iHexSecondByte
   2194  0c7e		       a5 52		      lda	R0
   2195  0c80		       20 3c 14 	      jsr	OUTHEX
   2196  0c83		       4c c2 02 	      jmp	NextIL
   2197  0c86							;
   2198  0c86							;=====================================================
   2199  0c86							; Replace TOS with its absolute value.
   2200  0c86							;
   2201  0c86		       20 2a 1c    iABS       jsr	popR0
   2202  0c89		       a5 53		      lda	R0+1
   2203  0c8b		       10 10		      bpl	iABS_1	;already positive
   2204  0c8d		       49 ff		      eor	#$ff
   2205  0c8f		       85 53		      sta	R0+1
   2206  0c91		       a5 52		      lda	R0
   2207  0c93		       49 ff		      eor	#$ff
   2208  0c95		       85 52		      sta	R0
   2209  0c97		       e6 52		      inc	R0
   2210  0c99		       d0 02		      bne	iABS_1
   2211  0c9b		       e6 53		      inc	R0+1
   2212  0c9d		       4c 0b 07    iABS_1     jmp	pushR0nextIl
   2213  0ca0
   2214  0ca0							;
   2215  0ca0							;================================================================
   2216  0ca0							; The set of logical operators
   2217  0ca0				   iLogAnd
   2218  0ca0		       20 2a 1c 	      jsr	popR0
   2219  0ca3		       20 42 1c 	      jsr	popR1
   2220  0ca6		       a5 52		      lda	R0
   2221  0ca8		       25 54		      and	R1
   2222  0caa		       85 52		      sta	R0
   2223  0cac		       a5 53		      lda	R0+1
   2224  0cae		       25 55		      and	R1+1
   2225  0cb0		       85 53		      sta	R0+1
   2226  0cb2		       4c 0b 07 	      jmp	pushR0nextIl
   2227  0cb5				   iLogOr
   2228  0cb5		       20 2a 1c 	      jsr	popR0
   2229  0cb8		       20 42 1c 	      jsr	popR1
   2230  0cbb		       a5 52		      lda	R0
   2231  0cbd		       05 54		      ora	R1
   2232  0cbf		       85 52		      sta	R0
   2233  0cc1		       a5 53		      lda	R0+1
   2234  0cc3		       05 55		      ora	R1+1
   2235  0cc5		       85 53		      sta	R0+1
   2236  0cc7		       4c 0b 07 	      jmp	pushR0nextIl
   2237  0cca				   iLogXor
   2238  0cca		       20 2a 1c 	      jsr	popR0
   2239  0ccd		       20 42 1c 	      jsr	popR1
   2240  0cd0		       a5 52		      lda	R0
   2241  0cd2		       45 54		      eor	R1
   2242  0cd4		       85 52		      sta	R0
   2243  0cd6		       a5 53		      lda	R0+1
   2244  0cd8		       45 55		      eor	R1+1
   2245  0cda		       85 53		      sta	R0+1
   2246  0cdc		       4c 0b 07 	      jmp	pushR0nextIl
   2247  0cdf				   iLogNot
   2248  0cdf		       20 2a 1c 	      jsr	popR0
   2249  0ce2		       a5 52		      lda	R0
   2250  0ce4		       49 ff		      eor	#$FF
   2251  0ce6		       85 52		      sta	R0
   2252  0ce8		       a5 53		      lda	R0+1
   2253  0cea		       49 ff		      eor	#$FF
   2254  0cec		       85 53		      sta	R0+1
   2255  0cee		       4c 0b 07 	      jmp	pushR0nextIl
   2256  0cf1
   2257  0cf1				   iTruth
   2258  0cf1		       a9 ff		      lda	#$FF
   2259  0cf3		       85 52		      sta	R0
   2260  0cf5		       85 53		      sta	R0+1
   2261  0cf7		       4c 0b 07 	      jmp	pushR0nextIl
   2262  0cfa				   iFalse
   2263  0cfa		       a9 00		      lda	#$00
   2264  0cfc		       85 52		      sta	R0
   2265  0cfe		       85 53		      sta	R0+1
   2266  0d00		       4c 0b 07 	      jmp	pushR0nextIl
   2267  0d03
   2268  0d03							;================================================================
   2269  0d03							;Set the IRQ service rtn line number
   2270  0d03							;
   2271  0d03		       78	   iSetIrq    sei		; disable the interupts
   2272  0d04		       a9 00		      lda	#0	; Zero the Status flag
   2273  0d06		       8d dd 24 	      sta	IRQStatus
   2274  0d09		       20 2a 1c 	      jsr	popR0	; get the line number
   2275  0d0c		       a5 52		      lda	R0
   2276  0d0e		       05 53		      ora	R0+1
   2277  0d10		       f0 20		      beq	iSetExt	; if it is zero disable all
   2278  0d12		       20 c0 1b 	      jsr	pushLN	; Save the current line pointer
   2279  0d15		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2280  0d17		       4c a5 0b 	      jmp	ErrStkOver	; Check if there was an error
   2281  0d1a				   iSetIrqOk
   2282  0d1a		       20 f2 19 	      jsr	findLine	; Find the IRQ func Line Pointer
   2283  0d1d		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2284  0d1f		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2285  0d21		       8d e0 24 	      sta	IRQEntry+1
   2286  0d24		       a5 4f		      lda	CURPTR
   2287  0d26		       8d df 24 	      sta	IRQEntry
   2288  0d29		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2289  0d2b		       8d dd 24 	      sta	IRQStatus
   2290  0d2e		       20 e5 1b 	      jsr	popLN	; Restore the old line number
   2291  0d31		       58		      cli		; Enable the interupts
   2292  0d32		       4c c2 02    iSetExt    jmp	NextIL
   2293  0d35
   2294  0d35		       20 e5 1b    iSetIrqErr jsr	popLN
   2295  0d38		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2296  0d3a		       a9 00		      lda	#0
   2297  0d3c		       4c 20 06 	      jmp	iErr2
   2298  0d3f							;
   2299  0d3f		       20 2a 1c    iTRACEPROG jsr	popR0
   2300  0d42		       a5 52		      lda	R0
   2301  0d44		       85 40		      sta	ILTrace
   2302  0d46		       4c c2 02 	      jmp	NextIL
   2303  0d49
   2304  0d49							;=====================================================
   2305  0d49							; Define start of non page zero data
   2306 U2e44 ????				      seg.u	TBData
   2307 U249a					      org	PROGEND
   2308 U249a							;=================================================================
   2309 U249a							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U249a					      include	"tokenizer.asm"
      1  0d49					      seg	Code
      2  0d49		       ff ff ff ff DEBUGPARSER equ	TRUE	; Print debugging information
      3  0d49
      4  0d49							; Define the types of tokens found, and identifiers
      5  0d49		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0d49		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0d49		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  0d49		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  0d49
     10  0d49		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  0d49		       00 9c	   tVhash     equ	$9C	; Variable #
     12  0d49		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  0d49
     14  0d49
     15  0d49		       00 a0	   tString    equ	$A0	; String all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     16  0d49		       00 a1	   tInteger   equ	$A1	; all tokenized integers start with 251 as first byte
     17  0d49		       00 a2	   tByte      equ	$A2	; Unsigned byte value
     18  0d49		       00 a3	   tArray     equ	$A3	; Identifies Array Type, the byte following defines the length of each element
     19  0d49							; Arrays of string are arrays of pointers 2 bytes
     20  0d49		       00 a4	   tPointer   equ	$A4	; Pointer to another variable
     21  0d49		       00 a6	   tIndirect  equ	$A6	; Points to an address that points to the data
     22  0d49
     23  0d49		       3c 3e	   Operators  BYTE.b	"<>"
     24  0d4b		       3c 3d		      BYTE.b	"<="
     25  0d4d		       3e 3d		      BYTE.b	">="
     26  0d4f		       3c 00		      BYTE.b	"<",0
     27  0d51		       3d 00		      BYTE.b	"=",0
     28  0d53		       3e 00		      BYTE.b	">",0
     29  0d55		       2b 00		      BYTE.b	"+",0
     30  0d57		       2d 00		      BYTE.b	"-",0
     31  0d59		       2f 00		      BYTE.b	"/",0
     32  0d5b		       25 00		      BYTE.b	"%",0
     33  0d5d		       2a 00		      BYTE.b	"*",0
     34  0d5f		       28 00		      BYTE.b	"(",0
     35  0d61		       29 00		      BYTE.b	")",0
     36  0d63		       2c 00		      BYTE.b	",",0
     37  0d65		       3b 00		      BYTE.b	";",0
     38  0d67		       5b 00		      BYTE.b	"[",0
     39  0d69		       5d 00		      BYTE.b	"]",0
     40  0d6b		       3a 00		      BYTE.b	":",0
     41  0d6d		       24 00		      BYTE.b	"$",0
     42  0d6f		       21 00		      BYTE.b	"!",0
     43  0d71		       3f 00		      BYTE.b	"?",0
     44  0d73		       2e 00		      BYTE.b	".",0
     45  0d75		       00 00		      BYTE.b	0,0
     46  0d77
     47  0d77		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     48  0d7d		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     49  0d82		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     50  0d88		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     51  0d8d
     52  0d8d		       00 0b	   oQuestion  equ	kPrint
     53  0d8d
     54  0d8d		       00 f1	   oLess      equ	$F1
     55  0d8d		       00 f2	   oEqual     equ	$F2
     56  0d8d		       00 f3	   oLessEqual equ	$F3
     57  0d8d		       00 f4	   oGreater   equ	$F4
     58  0d8d		       00 f5	   oNotEqual  equ	$F5
     59  0d8d		       00 f6	   oGreaterEqual equ	$F6
     60  0d8d
     61  0d8d		       00 e0	   oLeftBracket equ	$E0
     62  0d8d		       00 e1	   oRightBracket equ	$E1
     63  0d8d		       00 e2	   oComma     equ	$E2
     64  0d8d		       00 e3	   oSemiColon equ	$E3
     65  0d8d		       00 e4	   oLeftSQBracket equ	$E4
     66  0d8d		       00 e5	   oRightSQBracket equ	$E5
     67  0d8d		       00 e6	   oColon     equ	$E6
     68  0d8d		       00 e7	   oDollar    equ	$E7
     69  0d8d		       00 e8	   oBang      equ	$E8
     70  0d8d		       00 e9	   oPeriod    equ	$E9
     71  0d8d
     72  0d8d
     73  0d8d		       00 ea	   oPlus      equ	$EA
     74  0d8d		       00 eb	   oMinus     equ	$EB
     75  0d8d		       00 ec	   oDivide    equ	$EC
     76  0d8d		       00 ed	   oModulo    equ	$ED
     77  0d8d		       00 ee	   oMultiply  equ	$EE
     78  0d8d
     79  0d8d		       00 ed	   oPercent   equ	oModulo
     80  0d8d
     81  0d8d		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     82  0d8d
     83  0d8d		       00 ff	   tError     equ	$FF	; Error should never happen
     84  0d8d							;============================================================================================
     85  0d8d							; Keyword and seperator values
     86  0d8d				   '
     87  0d8d		       00 01	   kBeginKey  equ	kLet
     88  0d8d							;
     89  0d8d		       00 01	   kLet       equ	1
     90  0d8d		       00 02	   kInc       equ	kLet+1
     91  0d8d		       00 03	   kDec       equ	kInc+1
     92  0d8d		       00 04	   kIreturn   equ	kDec+1
     93  0d8d		       00 05	   kIf	      equ	kIreturn+1
     94  0d8d		       00 06	   kThen      equ	kIf+1
     95  0d8d		       00 07	   kGoto      equ	kThen+1
     96  0d8d		       00 08	   kGosub     equ	kGoto+1
     97  0d8d		       00 09	   kReturn    equ	kGosub+1
     98  0d8d		       00 0a	   kRem       equ	kReturn+1
     99  0d8d		       00 0b	   kPrint     equ	kRem+1
    100  0d8d		       00 0c	   kTaske     equ	kPrint+1
    101  0d8d		       00 0d	   kTaskn     equ	kTaske+1
    102  0d8d		       00 0e	   kTaskw     equ	kTaskn+1
    103  0d8d		       00 0f	   kPoke      equ	kTaskw+1
    104  0d8d		       00 10	   kPutch     equ	kPoke+1
    105  0d8d		       00 11	   kCls       equ	kPutch+1
    106  0d8d		       00 12	   kInput     equ	kCls+1
    107  0d8d		       00 13	   kEnd       equ	kInput+1
    108  0d8d		       00 14	   kIrq       equ	kEnd+1
    109  0d8d		       00 15	   kKill      equ	kIrq+1
    110  0d8d		       00 16	   kList      equ	kKill+1
    111  0d8d		       00 17	   kRun       equ	kList+1
    112  0d8d		       00 18	   kNew       equ	kRun+1
    113  0d8d		       00 19	   kSlice     equ	kNew+1
    114  0d8d		       00 1a	   kTrace     equ	kSlice+1
    115  0d8d		       00 1b	   kExit      equ	kTrace+1
    116  0d8d		       00 1c	   kSave      equ	kExit+1
    117  0d8d		       00 1d	   kLoad      equ	kSave+1
    118  0d8d		       00 1e	   kErase     equ	kLoad+1
    119  0d8d		       00 1f	   kDir       equ	kErase+1
    120  0d8d							;
    121  0d8d							; End of actual key words
    122  0d8d							;
    123  0d8d		       00 1e	   kKeyCount  equ	kDir-kBeginKey
    124  0d8d							;
    125  0d8d							; Logical operators
    126  0d8d							;
    127  0d8d		       00 20	   kNot       equ	kDir+1
    128  0d8d		       00 21	   kOr	      equ	kNot+1
    129  0d8d		       00 22	   kXor       equ	kOr+1
    130  0d8d		       00 23	   kAnd       equ	kXor+1
    131  0d8d
    132  0d8d							; numeric functions
    133  0d8d							;
    134  0d8d		       00 24	   kBeginFunc equ	kTrue
    135  0d8d							;
    136  0d8d							; Truth operators
    137  0d8d							;
    138  0d8d		       00 24	   kTrue      equ	kAnd+1
    139  0d8d		       00 25	   kFalse     equ	kTrue+1
    140  0d8d							; Functions
    141  0d8d		       00 26	   kFree      equ	kFalse+1
    142  0d8d		       00 27	   kGetch     equ	kFree+1
    143  0d8d		       00 28	   kPeek      equ	kGetch+1
    144  0d8d		       00 29	   kTask      equ	kPeek+1
    145  0d8d		       00 2a	   kIpcc      equ	kTask+1
    146  0d8d		       00 2b	   kIpcs      equ	kIpcc+1
    147  0d8d		       00 2c	   kIpcr      equ	kIpcs+1
    148  0d8d		       00 2d	   kRnd       equ	kIpcr+1
    149  0d8d		       00 2e	   kStat      equ	kRnd+1
    150  0d8d		       00 2f	   kAbs       equ	kStat+1
    151  0d8d		       00 30	   kCall      equ	kAbs+1
    152  0d8d		       00 31	   kGofn      equ	kCall+1
    153  0d8d		       00 32	   kPid       equ	kGofn+1
    154  0d8d							;
    155  0d8d		       00 0e	   kFuncCount equ	kPid - kBeginFunc
    156  0d8d
    157  0d8d							;
    158  0d8d							; Keyword table contains 49 keywords
    159  0d8d				   KeyWordTable
      0  0d8d					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  0d8d		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  0d91					      db	kInc,"inC"
      1  0d91		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  0d95					      db	kDec,"deC"
      1  0d95		       03 64 65 43	      .byte.b	kDec,"deC"
      0  0d99					      db	kIreturn,"ireturN"
      1  0d99		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  0da1					      db	kIf,"iF"
      1  0da1		       05 69 46 	      .byte.b	kIf,"iF"
      0  0da4					      db	kThen,"theN"
      1  0da4		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  0da9					      db	kGoto,"gotO"
      1  0da9		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  0dae					      db	kGosub,"gosuB"
      1  0dae		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  0db4					      db	kReturn,"returN"
      1  0db4		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  0dbb					      db	kRem,"reM"
      1  0dbb		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  0dbf					      db	kPrint,"prinT"
      1  0dbf		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  0dc5					      db	kTaske,"taskE"
      1  0dc5		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  0dcb					      db	kTaskn,"taskN"
      1  0dcb		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  0dd1					      db	kTaskw,"taskW"
      1  0dd1		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  0dd7					      db	kPoke,"pokE"
      1  0dd7		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  0ddc					      db	kPutch,"putcH"
      1  0ddc		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  0de2					      db	kCls,"clS"
      1  0de2		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  0de6					      db	kInput,"inpuT"
      1  0de6		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  0dec					      db	kEnd,"enD"
      1  0dec		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  0df0					      db	kIrq,"irQ"
      1  0df0		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  0df4					      db	kKill,"kilL"
      1  0df4		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  0df9					      db	kList,"lisT"
      1  0df9		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  0dfe					      db	kRun,"ruN"
      1  0dfe		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  0e02					      db	kNew,"neW"
      1  0e02		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  0e06					      db	kSlice,"slicE"
      1  0e06		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  0e0c					      db	kTrace,"tracE"
      1  0e0c		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  0e12					      db	kExit,"exiT"
      1  0e12		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  0e17					      db	kSave,"savE"
      1  0e17		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  0e1c					      db	kLoad,"loaD"
      1  0e1c		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  0e21					      db	kErase,"erasE"
      1  0e21		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  0e27					      db	kDir,"diR"
      1  0e27		       1f 64 69 52	      .byte.b	kDir,"diR"
    191  0e2b							;Short form for statements:
      0  0e2b					      db	kIreturn,"ireT"
      1  0e2b		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  0e30					      db	kReturn,"reT"
      1  0e30		       09 72 65 54	      .byte.b	kReturn,"reT"
    194  0e34
    195  0e34							;Logical and truth operators
      0  0e34					      db	kNot,"noT"
      1  0e34		       20 6e 6f 54	      .byte.b	kNot,"noT"
      0  0e38					      db	kOr,"oR"
      1  0e38		       21 6f 52 	      .byte.b	kOr,"oR"
      0  0e3b					      db	kXor,"xoR"
      1  0e3b		       22 78 6f 52	      .byte.b	kXor,"xoR"
      0  0e3f					      db	kAnd,"anD"
      1  0e3f		       23 61 6e 44	      .byte.b	kAnd,"anD"
    200  0e43							; Truth values
      0  0e43					      db	kTrue,"truE"
      1  0e43		       24 74 72 75*	      .byte.b	kTrue,"truE"
      0  0e48					      db	kFalse,"falsE"
      1  0e48		       25 66 61 6c*	      .byte.b	kFalse,"falsE"
    203  0e4e
    204  0e4e							;functions returning values
    205  0e4e
      0  0e4e					      db	kFree,"freE"
      1  0e4e		       26 66 72 65*	      .byte.b	kFree,"freE"
      0  0e53					      db	kGetch,"getcH"
      1  0e53		       27 67 65 74*	      .byte.b	kGetch,"getcH"
      0  0e59					      db	kPeek,"peeK"
      1  0e59		       28 70 65 65*	      .byte.b	kPeek,"peeK"
      0  0e5e					      db	kTask,"tasK"
      1  0e5e		       29 74 61 73*	      .byte.b	kTask,"tasK"
      0  0e63					      db	kIpcc,"ipcC"
      1  0e63		       2a 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  0e68					      db	kIpcs,"ipcS"
      1  0e68		       2b 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  0e6d					      db	kIpcr,"ipcR"
      1  0e6d		       2c 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  0e72					      db	kRnd,"rnD"
      1  0e72		       2d 72 6e 44	      .byte.b	kRnd,"rnD"
      0  0e76					      db	kStat,"staT"
      1  0e76		       2e 73 74 61*	      .byte.b	kStat,"staT"
      0  0e7b					      db	kAbs,"abS"
      1  0e7b		       2f 61 62 53	      .byte.b	kAbs,"abS"
      0  0e7f					      db	kCall,"calL"
      1  0e7f		       30 63 61 6c*	      .byte.b	kCall,"calL"
      0  0e84					      db	kGofn,"gofN"
      1  0e84		       31 67 6f 66*	      .byte.b	kGofn,"gofN"
      0  0e89					      db	kPid,"piD"
      1  0e89		       32 70 69 44	      .byte.b	kPid,"piD"
      0  0e8d					      db	0,0
      1  0e8d		       00 00		      .byte.b	0,0
    220  0e8f
    221  0e8f		       0e 8f	   KeyWordTableEnd equ	*
    222  0e8f		       01 02	   KeyWordTableLength equ	* - KeyWordTable
    223  0e8f		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    224  0f8f		       00 00 00    printStorage ds	3
    225  0f92							;==================================================================================================================
    226  0f92							; Read accross the inputline and output to TOKENBUFFER
    227  0f92							; Format   byte      Description
    228  0f92							;	     0	      length of line 1-255
    229  0f92							;	    0-1       Line Number
    230  0f92							;	    Tokens and litteral values encoded into the line
    231  0f92							;
    232  0f92							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    233  0f92							;  if fails then test for keywords
    234  0f92							;  if fails then test for variables and arrays
    235  0f92							;  if fails check for operators/seperators  + - < > = % / * () [] , ; :
    236  0f92
    237  0f92				   ParseInputLine
    238  0f92					      if	DEBUGPARSER
    239  0f92		       20 60 1e 	      jsr	SetOutDebug
    240  0f95		       20 40 11 	      jsr	DebugClearBuffer
    241  0f98					      endif
    242  0f98		       a5 51		      lda	CUROFF
    243  0f9a		       48		      pha
    244  0f9b		       8a		      txa
    245  0f9c		       48		      pha
    246  0f9d		       98		      tya
    247  0f9e		       48		      pha
    248  0f9f		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    249  0fa1		       20 58 1a 	      jsr	getDecimal	; Check for a line number, none is ok too
    250  0fa4		       84 51		      sty	CUROFF
    251  0fa6		       20 b7 11 	      jsr	R02TOKEN	; Move R0 to token buffer
    252  0fa9
    253  0fa9				   ParseInputLoop
    254  0fa9		       a4 51		      ldy	CUROFF
    255  0fab		       20 da 1c 	      jsr	SkipSpaces	; Skip any spaces
    256  0fae		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    257  0fb0		       b9 9d 2d 	      lda	LINBUF,y	; Check for end of line
    258  0fb3		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    259  0fb5
    260  0fb5				   ParseForNumber
    261  0fb5		       20 a1 10 	      jsr	ParseNumeric	; Check for a numeric value
    262  0fb8		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    263  0fba
    264  0fba				   ParseForString
    265  0fba		       20 77 10 	      jsr	ParseString	; Check for a string
    266  0fbd		       90 ea		      bcc	ParseInputLoop	; It was a string
    267  0fbf
    268  0fbf				   ParseForOp
    269  0fbf		       20 df 10 	      jsr	ParseForOperator	; Check for operator or punctuation
    270  0fc2		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    271  0fc4
    272  0fc4				   ParseForKey
    273  0fc4		       20 f1 0f 	      jsr	ParseLookupKey	; Check for a keyword value
    274  0fc7		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    275  0fc9
    276  0fc9				   ParseForVar
    277  0fc9		       20 80 11 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    278  0fcc		       90 db		      bcc	ParseInputLoop
    279  0fce
    280  0fce				   ParseKeepChar		; if it does not parse just keep it safe
    281  0fce		       b9 9d 2d 	      lda	LINBUF,y
    282  0fd1		       9d 8f 0e 	      sta	TOKENBUFFER,x
    283  0fd4		       e8		      inx
    284  0fd5		       c8		      iny
    285  0fd6		       84 51		      sty	CUROFF
    286  0fd8		       d0 cf		      bne	ParseInputLoop
    287  0fda
    288  0fda				   ParseComplete
    289  0fda		       a9 00		      lda	#0
    290  0fdc		       9d 8f 0e 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    291  0fdf		       e8		      inx
    292  0fe0		       8e 8f 0e 	      stx	TOKENBUFFER	; Place size including null into buffer start
    293  0fe3
    294  0fe3		       68		      pla
    295  0fe4		       a8		      tay
    296  0fe5		       68		      pla
    297  0fe6		       aa		      tax
    298  0fe7		       68		      pla
    299  0fe8		       85 51		      sta	CUROFF
    300  0fea
    301  0fea					      if	DEBUGPARSER
    302  0fea
    303  0fea		       20 52 11 	      jsr	printTokenBuffer
    304  0fed							;jsr	  DebugPrintProgramLine
    305  0fed		       20 8e 1e 	      jsr	SetOutDebugEnd
    306  0ff0
    307  0ff0					      endif
    308  0ff0		       60		      rts
    309  0ff1
    310  0ff1							;==================================================================================================================
    311  0ff1							; Look at curptr, curpos and check for a valid KeyWord
    312  0ff1							; A contains the index value. c is clear
    313  0ff1							;		     not found c set  A undefined
    314  0ff1							; X is prerserved
    315  0ff1							;
    316  0ff1				   ParseLookupKey
    317  0ff1		       86 58		      stx	R2
    318  0ff3		       a0 00		      ldy	#0
    319  0ff5		       a9 8d		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    320  0ff7		       85 54		      sta	R1
    321  0ff9		       a9 0d		      lda	#KeyWordTable>>8
    322  0ffb		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    323  0ffd		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    324  0fff		       85 52		      sta	R0	; Save until next keyword
    325  1001		       c8		      iny		; Point to first character of keyword
    326  1002		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    327  1004
    328  1004					      if	DEBUGPARSER
    329  1004							;    jsr DebugKeyword
    330  1004					      endif
    331  1004
    332  1004				   ParseLookupLoop
    333  1004		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    334  1006		       29 df		      and	#%11011111	; Force Keyword to upper case
    335  1008		       dd 9d 2d 	      cmp	LINBUF,x	; Check the input buffer
    336  100b		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    337  100d		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    338  100f		       dd 9d 2d 	      cmp	LINBUF,x	; Compare value to upercase
    339  1012		       d0 22		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    340  1014
    341  1014				   ParseNextLetter
    342  1014		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    343  1016		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    344  1018		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    345  101a		       e8		      inx		; Point to next char in the input buffer
    346  101b		       c8		      iny		; Point to the next character in the Keyword table
    347  101c		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    348  101e		       dd 9d 2d 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    349  1021		       f0 13		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    350  1023		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    351  1025
    352  1025				   ParseKeyFound
    353  1025		       a5 52		      lda	R0	; get the keyword index
    354  1027		       c9 0a		      cmp	#kRem	; remark statement
    355  1029		       f0 33		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    356  102b
    357  102b				   ParseKeyDone
    358  102b		       e8		      inx		; point past the last character
    359  102c		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    360  102e		       a6 58		      ldx	R2	; Restore the original x pointer
    361  1030		       9d 8f 0e 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    362  1033		       e8		      inx		; Point to next position in the output buffer
    363  1034		       18		      clc		; C flag clear, we found it
    364  1035		       60		      rts
    365  1036
    366  1036							; Move forward to the next entry in table
    367  1036				   ParseNextEntry
    368  1036		       b1 54		      lda	(R1),y	; Get the next character in the token
    369  1038		       29 20		      and	#%00100000	; Is it the last character
    370  103a		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    371  103c		       c8		      iny		; Point to next char in the entry
    372  103d		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    373  103f
    374  103f				   ParseEndOfEntry
    375  103f		       c8		      iny		; Point to the byte after the last character
    376  1040		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    377  1041		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    378  1042		       65 54		      adc	R1
    379  1044		       85 54		      sta	R1
    380  1046		       a5 55		      lda	R1+1
    381  1048		       69 00		      adc	#0
    382  104a		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    383  104c		       a0 00		      ldy	#0	; Reset the index back to zero
    384  104e		       b1 54		      lda	(R1),y	; get keyword value
    385  1050		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    386  1052		       85 52		      sta	R0	; save the next token value
    387  1054		       c8		      iny		; Inc past token value
    388  1055
    389  1055					      if	DEBUGPARSER
    390  1055							;    jsr DebugKeyword
    391  1055					      endif
    392  1055		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    393  1057		       4c 04 10 	      jmp	ParseLookupLoop	; branch back for next key word
    394  105a
    395  105a				   ParseNoneFound
    396  105a		       a6 58		      ldx	R2	; it did not faind one, restore x to position in output buffer
    397  105c		       38		      sec		; c clear, not found
    398  105d		       60		      rts
    399  105e
    400  105e							;===============================================================================
    401  105e							; Move everything from current position until the end of line into the token buffer
    402  105e							;
    403  105e		       c8	   ParseMoveLine iny		; next byte to parse
    404  105f		       a6 58		      ldx	R2	; where to place in the buffer
    405  1061		       a5 52		      lda	R0
    406  1063		       9d 8f 0e 	      sta	TOKENBUFFER,x	;Put the rem into the buffer
    407  1066		       e8		      inx		;Skip to next byte after the reM
    408  1067				   ParseMoveLoop
    409  1067		       b9 9d 2d 	      lda	LINBUF,y	; get the next byte
    410  106a		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    411  106c		       9d 8f 0e 	      sta	TOKENBUFFER,x	; save the byte
    412  106f		       c8		      iny
    413  1070		       e8		      inx
    414  1071		       d0 f4		      bne	ParseMoveLoop
    415  1073				   ParseMoveDone
    416  1073		       84 51		      sty	CUROFF
    417  1075		       18		      clc
    418  1076		       60		      rts
    419  1077
    420  1077							;=========================================================================================================
    421  1077							;ParseString Parse a quotes string
    422  1077							; on input X = outbuf position
    423  1077							; y = inbuf position
    424  1077							; Copies string to output buffer, updates x and y
    425  1077				   ParseString
    426  1077		       a4 51		      ldy	CUROFF
    427  1079		       a9 a0		      lda	#tString
    428  107b		       9d 8f 0e 	      sta	TOKENBUFFER,X
    429  107e		       b9 9d 2d 	      lda	LINBUF,y
    430  1081		       c9 22		      cmp	#'"
    431  1083		       d0 1a		      bne	ParseStringInvalid
    432  1085		       e8		      inx
    433  1086		       9d 8f 0e 	      sta	TOKENBUFFER,x
    434  1089		       e8		      inx
    435  108a		       c8		      iny
    436  108b
    437  108b				   ParseStringLoop
    438  108b		       b9 9d 2d 	      lda	LINBUF,y
    439  108e		       9d 8f 0e 	      sta	TOKENBUFFER,x
    440  1091		       c9 22		      cmp	#'"
    441  1093		       f0 04		      beq	ParseStringDone
    442  1095		       c8		      iny
    443  1096		       e8		      inx
    444  1097		       d0 f2		      bne	ParseStringLoop
    445  1099
    446  1099				   ParseStringDone
    447  1099		       e8		      inx
    448  109a		       c8		      iny
    449  109b		       84 51		      sty	CUROFF
    450  109d		       18		      clc
    451  109e		       60		      rts
    452  109f
    453  109f				   ParseStringInvalid
    454  109f		       38		      sec
    455  10a0		       60		      rts
    456  10a1
    457  10a1							;=========================================================================================================
    458  10a1							; Get numeric values and return value in RO and type in a
    459  10a1							;
    460  10a1				   ParseNumeric
    461  10a1		       a4 51		      ldy	CUROFF
    462  10a3		       b9 9d 2d 	      lda	LINBUF,y
    463  10a6		       c9 30		      cmp	#'0
    464  10a8		       90 33		      bcc	ParseNumInvalid
    465  10aa		       c9 3a		      cmp	#'9+1
    466  10ac		       b0 2f		      bcs	ParseNumInvalid
    467  10ae		       86 58		      stx	R2
    468  10b0		       20 58 1a 	      jsr	getDecimal
    469  10b3		       a6 58		      ldx	R2
    470  10b5		       84 51		      sty	CUROFF
    471  10b7		       a5 53		      lda	R0+1
    472  10b9		       f0 14		      beq	ParseByteValue
    473  10bb
    474  10bb				   ParseIntegerValue
    475  10bb		       a9 a1		      lda	#tInteger
    476  10bd		       9d 8f 0e 	      sta	TOKENBUFFER,x
    477  10c0		       e8		      inx
    478  10c1		       a5 52		      lda	R0
    479  10c3		       9d 8f 0e 	      sta	TOKENBUFFER,x
    480  10c6		       e8		      inx
    481  10c7		       a5 53		      lda	R0+1
    482  10c9		       9d 8f 0e 	      sta	TOKENBUFFER,X
    483  10cc		       e8		      inx
    484  10cd		       18		      clc
    485  10ce		       60		      rts
    486  10cf
    487  10cf				   ParseByteValue
    488  10cf		       a9 a2		      lda	#tByte
    489  10d1		       9d 8f 0e 	      sta	TOKENBUFFER,x
    490  10d4		       e8		      inx
    491  10d5		       a5 52		      lda	R0
    492  10d7		       9d 8f 0e 	      sta	TOKENBUFFER,x
    493  10da		       e8		      inx
    494  10db		       18		      clc
    495  10dc		       60		      rts
    496  10dd
    497  10dd				   ParseNumInvalid		;Not a valid Numeric
    498  10dd		       38		      sec
    499  10de		       60		      rts
    500  10df
    501  10df							;=========================================================================================================
    502  10df							;Parse for operators and seperators
    503  10df							; on exit the A has the oper code, c is clear
    504  10df							;		 not found then c is set
    505  10df							;	x is preserved
    506  10df							;
    507  10df				   ParseForOperator
    508  10df		       86 58		      stx	R2
    509  10e1		       a4 51		      ldy	CUROFF
    510  10e3		       a2 00		      ldx	#0
    511  10e5					      if	DEBUGPARSER
    512  10e5							;	jsr    DebugPrintOP
    513  10e5					      endif
    514  10e5
    515  10e5				   ParseOpLoop
    516  10e5		       bd 49 0d 	      lda	Operators,x	; First byte of operator
    517  10e8		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    518  10ea
    519  10ea		       d9 9d 2d 	      cmp	LINBUF,y	; Check the first byte
    520  10ed		       d0 1c		      bne	ParseOpNext
    521  10ef
    522  10ef		       c8		      iny
    523  10f0
    524  10f0		       bd 4a 0d 	      lda	Operators+1,x
    525  10f3		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    526  10f5
    527  10f5		       d9 9d 2d 	      cmp	LINBUF,y
    528  10f8		       d0 11		      bne	ParseOpNext
    529  10fa
    530  10fa				   ParseOpFound
    531  10fa		       c8		      iny
    532  10fb
    533  10fb				   ParseOpFoundSingle
    534  10fb		       84 51		      sty	CUROFF
    535  10fd
    536  10fd		       8a		      txa
    537  10fe		       4a		      lsr
    538  10ff		       aa		      tax
    539  1100		       bd 77 0d 	      lda	OperValues,x
    540  1103		       a6 58		      ldx	R2
    541  1105		       9d 8f 0e 	      sta	TOKENBUFFER,x
    542  1108		       e8		      inx
    543  1109		       18		      clc
    544  110a		       60		      rts
    545  110b
    546  110b				   ParseOpNext
    547  110b		       e8		      inx
    548  110c		       e8		      inx
    549  110d
    550  110d					      if	DEBUGPARSER
    551  110d							;	 jsr	DebugPrintOP
    552  110d					      endif
    553  110d		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    554  110f		       4c e5 10 	      jmp	ParseOpLoop
    555  1112
    556  1112				   ParseOpNotFound
    557  1112		       a6 58		      ldx	R2
    558  1114		       38		      sec
    559  1115		       60		      rts
    560  1116							;=========================================================================================================
    561  1116					      if	DEBUGPARSER
    562  1116							;Print the text of a keyword
    563  1116							;Input R1    = offset into table
    564  1116				   DebugKeyword
    565  1116		       98		      tya
    566  1117		       48		      pha
    567  1118		       a0 01		      ldy	#1
    568  111a				   DebugKeyLoop
    569  111a		       b1 54		      lda	(R1),y
    570  111c		       20 2c 1e 	      jsr	VOUTCH
    571  111f		       29 20		      and	#%00100000
    572  1121		       f0 03		      beq	DebugKeyDone
    573  1123		       c8		      iny
    574  1124		       d0 f4		      bne	DebugKeyLoop
    575  1126
    576  1126				   DebugKeyDone
    577  1126		       20 e3 1c 	      jsr	CRLF
    578  1129		       68		      pla
    579  112a		       a8		      tay
    580  112b		       60		      rts
    581  112c							;========================================
    582  112c				   DebugPrintOP
    583  112c		       48		      pha
    584  112d		       bd 49 0d 	      lda	Operators,x
    585  1130		       20 2c 1e 	      jsr	VOUTCH
    586  1133		       bd 4a 0d 	      lda	Operators+1,x
    587  1136		       f0 03		      beq	DbgPrtOpDone
    588  1138		       20 2c 1e 	      jsr	VOUTCH
    589  113b
    590  113b				   DbgPrtOpDone
    591  113b		       20 e3 1c 	      jsr	CRLF
    592  113e		       68		      pla
    593  113f		       60		      rts
    594  1140							;=======================================
    595  1140				   DebugClearBuffer
    596  1140		       8a		      txa
    597  1141		       48		      pha
    598  1142		       a2 ff		      ldx	#$FF
    599  1144		       a9 00		      lda	#0
    600  1146				   DebugClrLoop
    601  1146		       9d 8f 0e 	      sta	TOKENBUFFER,x
    602  1149		       ca		      dex
    603  114a		       d0 fa		      bne	DebugClrLoop
    604  114c		       9d 8f 0e 	      sta	TOKENBUFFER,x
    605  114f		       68		      pla
    606  1150		       aa		      tax
    607  1151		       60		      rts
    608  1152
    609  1152							;=====================================================
    610  1152							; Print the parser buffer as hex values
    611  1152				   printTokenBuffer
    612  1152		       8e 8f 0f 	      stx	printStorage
    613  1155		       8c 90 0f 	      sty	printStorage+1
    614  1158		       8d 91 0f 	      sta	printStorage+2
    615  115b
    616  115b		       ae 8f 0e 	      ldx	TOKENBUFFER	; get the length of the buffer
    617  115e		       e8		      inx		; we want to show the last zero byte
    618  115f		       a0 00		      ldy	#0
    619  1161
    620  1161				   printHexLoop
    621  1161		       b9 8f 0e 	      lda	TOKENBUFFER,y	; get the character
    622  1164		       20 3c 14 	      jsr	HexToOut	; print it
    623  1167		       a9 20		      lda	#$20
    624  1169		       20 2c 1e 	      jsr	VOUTCH
    625  116c		       c8		      iny
    626  116d		       ca		      dex
    627  116e		       e0 00		      cpx	#0
    628  1170		       d0 ef		      bne	printHexLoop
    629  1172		       20 e3 1c 	      jsr	CRLF
    630  1175
    631  1175		       ac 90 0f 	      ldy	printStorage+1
    632  1178		       ae 8f 0f 	      ldx	printStorage
    633  117b		       ad 91 0f 	      lda	printStorage+2
    634  117e				   printHexDone
    635  117e		       18		      clc
    636  117f		       60		      rts
    637  1180					      endif
    638  1180
    639  1180
    640  1180							;=========================================================================================================
    641  1180							; Parse for variables A-Z @, ^  x!x x[op]
    642  1180				   ParseForVariable
    643  1180		       a4 51		      ldy	CUROFF
    644  1182		       b9 9d 2d 	      lda	LINBUF,y
    645  1185		       c9 5e		      cmp	#'^	; is it an exit code
    646  1187		       d0 04		      bne	ParseVarMem
    647  1189		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    648  118b		       d0 1f		      bne	ParseVarSpecial
    649  118d
    650  118d				   ParseVarMem
    651  118d		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    652  118f		       d0 04		      bne	ParseVarStack
    653  1191		       a9 9d		      lda	#tVat
    654  1193		       d0 17		      bne	ParseVarSpecial
    655  1195
    656  1195				   ParseVarStack
    657  1195		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    658  1197		       d0 04		      bne	ParseVarLetters
    659  1199		       a9 9c		      lda	#tVhash
    660  119b		       d0 0f		      bne	ParseVarSpecial
    661  119d
    662  119d				   ParseVarLetters
    663  119d		       29 df		      and	#%11011111	; Force upper case
    664  119f		       c9 41		      cmp	#'A
    665  11a1		       90 12		      bcc	ParseVarInvalid
    666  11a3		       c9 5b		      cmp	#'Z+1
    667  11a5		       b0 0e		      bcs	ParseVarInvalid
    668  11a7							;
    669  11a7							; The condition is true, so convert to an index, push
    670  11a7							; it onto the stack and continue running.
    671  11a7							;
    672  11a7		       38		      sec
    673  11a8		       e9 41		      sbc	#'A	;index is zero based
    674  11aa		       09 80		      ora	#$80
    675  11ac
    676  11ac				   ParseVarSpecial
    677  11ac		       9d 8f 0e 	      sta	TOKENBUFFER,x
    678  11af		       e8		      inx
    679  11b0		       c8		      iny
    680  11b1		       84 51		      sty	CUROFF
    681  11b3		       18		      clc
    682  11b4		       60		      rts
    683  11b5
    684  11b5				   ParseVarInvalid
    685  11b5		       38		      sec
    686  11b6		       60		      rts
    687  11b7
    688  11b7
    689  11b7							;=========================================================================================================
    690  11b7							; Transfer R0 to the TOKENBUFFER
    691  11b7							;
    692  11b7				   R02TOKEN
    693  11b7		       a5 52		      lda	R0
    694  11b9		       9d 8f 0e 	      sta	TOKENBUFFER,x
    695  11bc		       e8		      inx
    696  11bd		       a5 53		      lda	R0+1
    697  11bf		       9d 8f 0e 	      sta	TOKENBUFFER,x
    698  11c2		       e8		      inx
    699  11c3		       18		      clc
    700  11c4		       60		      rts
    701  11c5							;=========================================================================
    702  11c5							; Transfer word in Token Buffer to R0
    703  11c5				   TOKEN2R0
    704  11c5		       b9 8f 0e 	      lda	TOKENBUFFER,y
    705  11c8		       85 52		      sta	R0
    706  11ca		       c8		      iny
    707  11cb		       ca		      dex
    708  11cc		       b9 8f 0e 	      lda	TOKENBUFFER,y
    709  11cf		       c8		      iny
    710  11d0		       ca		      dex
    711  11d1		       85 53		      sta	R0+1
    712  11d3		       60		      rts
    713  11d4							;==========================================================================
    714  11d4							; Transfer	Display Buffer position to R0
    715  11d4							;
    716  11d4				   DPL2R0
    717  11d4		       b1 59		      lda	(dpl),y
    718  11d6		       85 52		      sta	R0
    719  11d8		       c8		      iny
    720  11d9		       ca		      dex
    721  11da		       b1 59		      lda	(dpl),y
    722  11dc		       c8		      iny
    723  11dd		       ca		      dex
    724  11de		       85 53		      sta	R0+1
    725  11e0		       60		      rts
    726  11e1
    727  11e1							;==========================================================================================================
    728  11e1							;Debug   Print a Program Line from compile buffer
    729  11e1							;
    730  11e1				   DebugPrintProgramLine
    731  11e1		       48		      pha
    732  11e2		       a9 8f		      lda	#TOKENBUFFER&$FF
    733  11e4		       85 59		      sta	dpl
    734  11e6		       a9 0e		      lda	#TOKENBUFFER>>8
    735  11e8		       85 5a		      sta	dpl+1
    736  11ea		       68		      pla
    737  11eb
    738  11eb							; Decode and print a line of program text
    739  11eb							; on entry	 dpl points to line of code to print
    740  11eb							; on exit	 no change in reg of dpl
    741  11eb							;
    742  11eb				   PrintProgramLine
    743  11eb
    744  11eb		       8e 8f 0f 	      stx	printStorage
    745  11ee		       8c 90 0f 	      sty	printStorage+1
    746  11f1		       48		      pha
    747  11f2
    748  11f2		       a0 01		      ldy	#1	; index into the token buffer
    749  11f4		       84 58		      sty	R2	; print unsigned decimal
    750  11f6		       a0 00		      ldy	#0
    751  11f8		       b1 59		      lda	(dpl),y	; get number of bytes
    752  11fa		       aa		      tax		; place pointer into x
    753  11fb		       c8		      iny
    754  11fc		       ca		      dex		; Deduct the length byte
    755  11fd		       20 d4 11 	      jsr	DPL2R0	; Print the line number
    756  1200		       20 8a 13 	      jsr	PrintDecimal
    757  1203		       a9 20		      lda	#$20
    758  1205		       20 2c 1e 	      jsr	VOUTCH
    759  1208
    760  1208				   PrintProgLoop
    761  1208		       b1 59		      lda	(dpl),y	; Get a character
    762  120a		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    763  120c		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    764  120e		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    765  1210
    766  1210				   PrintProgVars
    767  1210		       b1 59		      lda	(dpl),y
    768  1212		       29 e0		      and	#$E0	; Check for operators and punctuation
    769  1214		       c9 e0		      cmp	#$E0
    770  1216		       f0 6b		      beq	PrintProgOperatorVect
    771  1218
    772  1218		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    773  121a		       c9 9e		      cmp	#$9D+1
    774  121c		       90 62		      bcc	PrintProgVariableVec
    775  121e		       29 a0		      and	#$A0	; Check for a valid datatype
    776  1220		       c9 a0		      cmp	#$A0
    777  1222		       f0 06		      beq	PrintDataType	; if not just print the character
    778  1224		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    779  1226		       ca		      dex		; Ok we are prcessing it
    780  1227		       c8		      iny
    781  1228		       d0 25		      bne	PrintContinue	; Print and do the next character
    782  122a
    783  122a				   PrintDataType
    784  122a		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    785  122c		       c9 a0		      cmp	#tString
    786  122e		       f0 31		      beq	PrintStringVariable
    787  1230
    788  1230				   PrintProgNumber
    789  1230		       c8		      iny		; we have a numerical integer value
    790  1231		       ca		      dex
    791  1232		       48		      pha
    792  1233		       a9 00		      lda	#0
    793  1235		       85 53		      sta	R0+1
    794  1237		       85 58		      sta	R2	; Set to print signed number
    795  1239		       b1 59		      lda	(dpl),y
    796  123b		       85 52		      sta	R0
    797  123d		       68		      pla
    798  123e		       c9 a1		      cmp	#tInteger
    799  1240		       d0 06		      bne	PrintProgNumDone
    800  1242		       c8		      iny
    801  1243		       ca		      dex
    802  1244		       b1 59		      lda	(dpl),y
    803  1246		       85 53		      sta	R0+1
    804  1248
    805  1248				   PrintProgNumDone
    806  1248		       c8		      iny
    807  1249		       ca		      dex
    808  124a		       20 8a 13 	      jsr	PrintDecimal
    809  124d
    810  124d				   PrintProgNext
    811  124d		       a9 20		      lda	#$20
    812  124f				   PrintContinue
    813  124f		       20 2c 1e 	      jsr	VOUTCH
    814  1252				   PrintProgSkipSpace
    815  1252		       e0 00		      cpx	#0
    816  1254		       d0 b2		      bne	PrintProgLoop
    817  1256				   PrintProgramComplete
    818  1256		       20 e3 1c 	      jsr	CRLF
    819  1259
    820  1259		       ae 8f 0f 	      ldx	printStorage
    821  125c		       ac 90 0f 	      ldy	printStorage+1
    822  125f		       68		      pla
    823  1260
    824  1260		       60		      rts
    825  1261							;=================================================================================================================
    826  1261							; Print a string variable including the quotes
    827  1261							; On Input	 y is offset into buffer
    828  1261							; On Exit	 y is updated to new offset
    829  1261
    830  1261				   PrintStringVariable
    831  1261		       c8		      iny
    832  1262		       a9 22		      lda	#'"
    833  1264		       20 2c 1e 	      jsr	VOUTCH
    834  1267		       c8		      iny
    835  1268		       a5 59		      lda	dpl
    836  126a		       85 5e		      sta	PrtFrom
    837  126c		       a5 5a		      lda	dpl+1
    838  126e		       85 5f		      sta	PrtFrom+1
    839  1270		       a9 22		      lda	#'"
    840  1272		       8d 32 2e 	      sta	PrtTerm
    841  1275		       20 a7 14 	      jsr	PrtLoop
    842  1278		       a9 22		      lda	#'"
    843  127a		       20 2c 1e 	      jsr	VOUTCH
    844  127d		       4c 4d 12 	      jmp	PrintProgNext
    845  1280
    846  1280				   PrintProgVariableVec
    847  1280		       4c 0b 13 	      jmp	PrintProgVariable
    848  1283
    849  1283				   PrintProgOperatorVect
    850  1283		       4c e2 12 	      jmp	PrintProgOperator
    851  1286							;===============================================================================================================
    852  1286							; On entry dpl points to the buffer we are printing from
    853  1286							;	    y	current offset into the dpl buffer
    854  1286							; all registers preserved
    855  1286							;
    856  1286				   PrintKeyword
    857  1286
    858  1286		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    859  1288		       85 52		      sta	R0	; The value we are looking for
    860  128a		       c8		      iny		; Inc i to point to the next char to be printed
    861  128b
    862  128b		       98		      tya		; Save y and x for the return
    863  128c		       48		      pha
    864  128d		       8a		      txa
    865  128e		       48		      pha
    866  128f
    867  128f		       a9 8d		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    868  1291		       85 54		      sta	R1
    869  1293		       a9 0d		      lda	#KeyWordTable>>8
    870  1295		       85 55		      sta	R1+1
    871  1297
    872  1297
    873  1297				   PrintKeyLoop
    874  1297		       a0 00		      ldy	#0	; Index into the keyword entry
    875  1299		       b1 54		      lda	(R1),y	; Get token value for this entry
    876  129b		       c8		      iny		; Point to first byte of key
    877  129c		       c5 52		      cmp	R0	; Compare to the token we are looking for
    878  129e		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    879  12a0
    880  12a0				   PrintKeyNext
    881  12a0		       b1 54		      lda	(R1),y	; Get key letter
    882  12a2		       c8		      iny		; Point to next byte always
    883  12a3		       29 20		      and	#%00100000	; Check for last character in key work
    884  12a5		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    885  12a7
    886  12a7		       98		      tya		; Trabsfer y to a for the addition
    887  12a8		       18		      clc		; Table > 256 bytes
    888  12a9		       65 54		      adc	R1
    889  12ab		       85 54		      sta	R1
    890  12ad		       a9 00		      lda	#0
    891  12af		       65 55		      adc	R1+1
    892  12b1		       85 55		      sta	R1+1
    893  12b3		       4c 97 12 	      jmp	PrintKeyLoop
    894  12b6
    895  12b6				   PrintKeyFound
    896  12b6		       b1 54		      lda	(R1),y	; letter from key table
    897  12b8		       48		      pha		; Save it for later check
    898  12b9		       09 20		      ora	#%00100000	; Force it to lower case
    899  12bb		       20 2c 1e 	      jsr	VOUTCH	; Print it out
    900  12be		       c8		      iny		; Point to next character
    901  12bf		       68		      pla		; Restore the value
    902  12c0		       29 20		      and	#%00100000	; Check if it was last char in keyword
    903  12c2		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    904  12c4
    905  12c4		       68		      pla		; Restore the x and y values
    906  12c5		       aa		      tax
    907  12c6		       68		      pla
    908  12c7		       a8		      tay
    909  12c8
    910  12c8				   PrintChkRem
    911  12c8		       a9 0a		      lda	#kRem
    912  12ca		       c5 52		      cmp	R0
    913  12cc		       d0 11		      bne	PrintKeyDone
    914  12ce				   PrintKeyRem
    915  12ce		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    916  12d0		       85 5e		      sta	PrtFrom
    917  12d2		       a5 5a		      lda	dpl+1
    918  12d4		       85 5f		      sta	PrtFrom+1
    919  12d6		       a9 00		      lda	#0
    920  12d8		       8d 32 2e 	      sta	PrtTerm
    921  12db		       20 a7 14 	      jsr	PrtLoop
    922  12de		       88		      dey		; point back to the terminating null value
    923  12df				   PrintKeyDone
    924  12df		       4c 4d 12 	      jmp	PrintProgNext
    925  12e2							;==================================================================================================================
    926  12e2							;Print Variable, number or operator
    927  12e2				   PrintProgOperator
    928  12e2		       b1 59		      lda	(dpl),y
    929  12e4		       c8		      iny
    930  12e5		       ca		      dex
    931  12e6		       8e 91 0f 	      stx	printStorage+2
    932  12e9		       a2 00		      ldx	#0
    933  12eb				   PrintOprLoop
    934  12eb		       dd 77 0d 	      cmp	OperValues,x
    935  12ee		       f0 03		      beq	PrintOprFound
    936  12f0		       e8		      inx
    937  12f1		       d0 f8		      bne	PrintOprLoop
    938  12f3				   PrintOprFound
    939  12f3		       8a		      txa
    940  12f4		       0a		      asl
    941  12f5		       aa		      tax
    942  12f6		       bd 49 0d 	      lda	Operators,x
    943  12f9		       20 2c 1e 	      jsr	VOUTCH
    944  12fc		       e8		      inx
    945  12fd		       bd 49 0d 	      lda	Operators,x
    946  1300		       f0 03		      beq	PrintOprDone
    947  1302		       20 2c 1e 	      jsr	VOUTCH
    948  1305				   PrintOprDone
    949  1305		       ae 91 0f 	      ldx	printStorage+2
    950  1308		       4c 4d 12 	      jmp	PrintProgNext
    951  130b
    952  130b							;=================================================================================================================
    953  130b							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    954  130b							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    955  130b							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    956  130b							;tVhat 	    equ     155 		   ; Variable ^
    957  130b							;tVhash	    equ     156 		   ; Variable #
    958  130b							;tVat		    equ     157 		   ; Variable @ = 0
    959  130b				   PrintProgVariable
    960  130b		       b1 59		      lda	(dpl),y
    961  130d		       c8		      iny
    962  130e		       ca		      dex
    963  130f		       c5 9b		      cmp	tVhat
    964  1311		       d0 04		      bne	PrintProgChkHash
    965  1313		       a9 5e		      lda	#'^
    966  1315		       d0 15		      bne	PrintTheVar
    967  1317				   PrintProgChkHash
    968  1317		       c5 9c		      cmp	tVhash
    969  1319		       d0 04		      bne	PrintProgChkAt
    970  131b		       a9 23		      lda	#'#
    971  131d		       d0 0d		      bne	PrintTheVar
    972  131f				   PrintProgChkAt
    973  131f		       c5 9d		      cmp	tVat
    974  1321		       d0 04		      bne	PrintProgVarLetter
    975  1323		       a9 40		      lda	#'@
    976  1325		       d0 05		      bne	PrintTheVar
    977  1327				   PrintProgVarLetter
    978  1327		       29 7f		      and	#%01111111
    979  1329		       18		      clc
    980  132a		       69 41		      adc	#'A
    981  132c				   PrintTheVar
    982  132c		       20 2c 1e 	      jsr	VOUTCH
    983  132f		       4c 4d 12 	      jmp	PrintProgNext
    984  1332
    985  1332							;=========================================================================
    986  1332							; Read an IL byte lookit up in the table, of words
    987  1332							; set the next ilpc to point to that address
    988  1332							; if not found then do ussual filter stuff
    989  1332							; ongoto ilvectortable, not found address
    990  1332		       20 a9 19    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    991  1335		       86 52		      stx	R0
    992  1337		       85 53		      sta	R0+1
    993  1339
    994  1339		       a4 51		      ldy	CUROFF
    995  133b		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    996  133d		       a0 00		      ldy	#0
    997  133f		       38		      sec
    998  1340		       f1 52		      sbc	(R0),y	; Subract the base value
    999  1342		       c8		      iny
   1000  1343		       d1 52		      cmp	(R0),y	; Check if we are in range
   1001  1345		       b0 12		      bcs	iOnGotoInvalid
   1002  1347		       e6 51		      inc	CUROFF	; Save the offset
   1003  1349
   1004  1349		       0a		      asl
   1005  134a		       a8		      tay		; Turn into vector
   1006  134b		       c8		      iny		; Inc must include the table base and entry count
   1007  134c		       c8		      iny
   1008  134d
   1009  134d		       b1 52		      lda	(R0),y
   1010  134f		       85 43		      sta	ILPC
   1011  1351		       c8		      iny
   1012  1352		       b1 52		      lda	(R0),y
   1013  1354		       85 44		      sta	ILPC+1
   1014  1356		       4c c2 02 	      jmp	NextIL
   1015  1359
   1016  1359				   iOnGotoInvalid
   1017  1359		       20 a9 19 	      jsr	getILWord
   1018  135c		       86 43		      stx	ILPC
   1019  135e		       85 44		      sta	ILPC+1
   1020  1360		       4c c2 02 	      jmp	NextIL
   1021  1363							;
   1022  1363							;==========================================================================================
   1023  1363							; Test the token for relop and push the value onto the stack if true
   1024  1363							;
   1025  1363				   iTSTRELOP
   1026  1363		       20 ad 19 	      jsr	getILByte
   1027  1366		       8d 36 2e 	      sta	offset
   1028  1369
   1029  1369		       a4 51		      ldy	CUROFF
   1030  136b		       b1 4f		      lda	(CURPTR),y
   1031  136d		       48		      pha
   1032  136e		       29 f0		      and	#$F0
   1033  1370		       c9 f0		      cmp	#$F0
   1034  1372		       d0 12		      bne	iTSTRELOPNOT
   1035  1374		       68		      pla
   1036  1375		       29 0f		      and	#$0F	; get the actual value
   1037  1377		       85 52		      sta	R0	; save it for later
   1038  1379		       a9 00		      lda	#0
   1039  137b		       85 53		      sta	R0+1
   1040  137d		       20 a6 1b 	      jsr	pushR0
   1041  1380		       c8		      iny
   1042  1381		       84 51		      sty	CUROFF	; save the y pointer
   1043  1383		       4c c2 02 	      jmp	NextIL
   1044  1386
   1045  1386				   iTSTRELOPNOT
   1046  1386		       68		      pla
   1047  1387		       4c 55 0b 	      jmp	tstBranch
   1048  138a
   1049  138a
   1050  138a
   1051  138a
   1052  138a
   1053  138a
   1054  138a
   1055  138a
   1056  138a
   1057  138a
   1058  138a
   1059  138a
   1060  138a
   1061  138a
   1062  138a
   1063  138a
   1064  138a
   1065  138a
   1066  138a
   1067  138a
   1068  138a
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  138a					      include	"print.asm"
      1  138a					      Seg	Code
      2  138a							;---------------------------
      3  138a							; Print 24-bit decimal number or  16bit unsigned
      4  138a							; ---------------------------
      5  138a							; On entry, R0=number to print
      6  138a							;	     Defaults to pad=0 , y=21 default
      7  138a							;	     R2 = 1 unsigned 16 bit
      8  138a							;	     R2 = 0 Signed   16 bit
      9  138a
     10  138a							; On entry at PrintDecPadded:
     11  138a							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  138a
     13  138a							; On exit,  A,X,Y,num,pad corrupted
     14  138a							; Size      129 bytes, Table 24 bytes	--- total 153
     15  138a							; -----------------------------------------------------------------
     16  138a
     17  138a				   PrintDecimal
     18  138a		       8a		      TXA
     19  138b		       48		      pha
     20  138c		       98		      tya
     21  138d		       48		      pha
     22  138e		       a9 00		      lda	#0
     23  1390		       8d 23 14 	      sta	pad
     24  1393		       a0 15		      LDY	#21	; Offset to powers of ten
     25  1395		       4c 9b 13 	      JMP	PrintDo
     26  1398
     27  1398				   PrintDecPadded
     28  1398		       8e 23 14 	      stx	pad
     29  139b
     30  139b				   PrintDo
     31  139b		       a9 00		      lda	#0
     32  139d		       85 54		      sta	R1
     33  139f
     34  139f		       a5 58		      lda	R2
     35  13a1		       d0 29		      bne	PrintPos
     36  13a3
     37  13a3		       a5 53		      lda	R0+1	;MSB has sign
     38  13a5		       10 25		      bpl	PrintPos	;it's a positive number;
     39  13a7
     40  13a7
     41  13a7							; Negative numbers need more work.  Invert all the bits,
     42  13a7							; then add one.
     43  13a7
     44  13a7		       a9 2d		      lda	#'-
     45  13a9		       20 2c 1e 	      jsr	VOUTCH	;print the negative sign
     46  13ac
     47  13ac		       a9 ff		      lda	#$FF
     48  13ae		       85 54		      sta	R1
     49  13b0		       a5 52		      lda	R0	;invert bits
     50  13b2		       49 ff		      eor	#$ff
     51  13b4		       85 52		      sta	R0
     52  13b6		       a5 53		      lda	R0+1
     53  13b8		       49 ff		      eor	#$ff
     54  13ba		       85 53		      sta	R0+1
     55  13bc		       a5 54		      lda	R1
     56  13be		       49 ff		      eor	#$ff
     57  13c0		       85 54		      sta	R1
     58  13c2		       e6 52		      inc	R0	;add one
     59  13c4		       d0 06		      bne	PrintPos
     60  13c6		       e6 53		      inc	R0+1
     61  13c8		       d0 02		      bne	PrintPos
     62  13ca		       e6 54		      inc	R1
     63  13cc				   PrintPos
     64  13cc
     65  13cc				   PrDec24Lp1
     66  13cc		       a2 ff		      LDX	#$FF
     67  13ce		       38		      SEC		; Start with digit=-1
     68  13cf				   PrDec24Lp2
     69  13cf		       a5 52		      LDA	R0+0
     70  13d1		       f9 24 14 	      SBC	PrDec24Tens+0,Y
     71  13d4		       85 52		      STA	R0+0	; Subtract current tens
     72  13d6		       a5 53		      LDA	R0+1
     73  13d8		       f9 25 14 	      SBC	PrDec24Tens+1,Y
     74  13db		       85 53		      STA	R0+1
     75  13dd		       a5 54		      LDA	R0+2
     76  13df		       f9 26 14 	      SBC	PrDec24Tens+2,Y
     77  13e2		       85 54		      STA	R0+2
     78  13e4		       e8		      INX
     79  13e5		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  13e7		       a5 52		      LDA	R0+0
     81  13e9		       79 24 14 	      ADC	PrDec24Tens+0,Y
     82  13ec		       85 52		      STA	R0+0	; Add current tens back in
     83  13ee		       a5 53		      LDA	R0+1
     84  13f0		       79 25 14 	      ADC	PrDec24Tens+1,Y
     85  13f3		       85 53		      STA	R0+1
     86  13f5		       a5 54		      LDA	R0+2
     87  13f7		       79 26 14 	      ADC	PrDec24Tens+2,Y
     88  13fa		       85 54		      STA	R0+2
     89  13fc		       8a		      TXA
     90  13fd		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  13ff		       ad 23 14 	      LDA	pad
     92  1402		       d0 09		      BNE	PrDec24Print
     93  1404		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  1406				   PrDec24Digit
     95  1406		       a2 30		      LDX	#'0
     96  1408		       8e 23 14 	      STX	pad	; No more zero padding
     97  140b		       09 30		      ORA	#'0	; Print this digit
     98  140d				   PrDec24Print
     99  140d		       20 2c 1e 	      JSR	VOUTCH
    100  1410				   PrDec24Next
    101  1410		       88		      DEY
    102  1411		       88		      DEY
    103  1412		       88		      DEY
    104  1413		       f0 07		      beq	PrDec24LastDigit
    105  1415		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  1417		       68		      pla
    107  1418		       a8		      tay
    108  1419		       68		      pla
    109  141a		       aa		      tax
    110  141b		       60		      RTS
    111  141c				   PrDec24LastDigit
    112  141c		       a2 30		      LDX	#'0
    113  141e		       8e 23 14 	      STX	pad	; No more zero padding
    114  1421		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  1423
      0  1423				   pad	      db	0
      1  1423		       00		      .byte.b	0
    117  1424				   PrDec24Tens
      0  1424					      dw	1
      1  1424		       01 00		      .word.w	1
      0  1426					      db	1 / 65536
      1  1426		       00		      .byte.b	1 / 65536
      0  1427					      dw	10
      1  1427		       0a 00		      .word.w	10
      0  1429					      db	10 / 65536
      1  1429		       00		      .byte.b	10 / 65536
      0  142a					      dw	100
      1  142a		       64 00		      .word.w	100
      0  142c					      db	100 / 65536
      1  142c		       00		      .byte.b	100 / 65536
      0  142d					      dw	1000
      1  142d		       e8 03		      .word.w	1000
      0  142f					      db	1000 / 65536
      1  142f		       00		      .byte.b	1000 / 65536
      0  1430					      dw	10000
      1  1430		       10 27		      .word.w	10000
      0  1432					      db	10000 / 65536
      1  1432		       00		      .byte.b	10000 / 65536
      0  1433					      dw	100000
      1  1433		       a0 86		      .word.w	100000
      0  1435					      db	100000 / 65536
      1  1435		       01		      .byte.b	100000 / 65536
      0  1436					      dw	1000000
      1  1436		       40 42		      .word.w	1000000
      0  1438					      db	1000000 / 65536
      1  1438		       0f		      .byte.b	1000000 / 65536
      0  1439					      dw	10000000
      1  1439		       80 96		      .word.w	10000000
      0  143b					      db	10000000 / 65536
      1  143b		       98		      .byte.b	10000000 / 65536
    134  143c							;=====================================================
    135  143c							; Print character in A as two hex digits to the
    136  143c
    137  143c		       48	   HexToOut   pha		;save return value
    138  143d		       48		      pha
    139  143e		       4a		      lsr		;a  ;move top nibble to bottom
    140  143f		       4a		      lsr		;a
    141  1440		       4a		      lsr		;a
    142  1441		       4a		      lsr		;a
    143  1442		       20 4b 14 	      jsr	hexta	;output nibble
    144  1445		       68		      pla
    145  1446		       20 4b 14 	      jsr	hexta
    146  1449		       68		      pla		;restore
    147  144a		       60		      rts
    148  144b							;
    149  144b		       29 0f	   hexta      and	#%0001111
    150  144d		       c9 0a		      cmp	#$0a
    151  144f		       18		      clc
    152  1450		       30 02		      bmi	hexta1
    153  1452		       69 07		      adc	#7
    154  1454		       69 30	   hexta1     adc	#'0	;then fall into...
    155  1456		       4c 2c 1e 	      jmp	VOUTCH
    156  1459							;
    157  1459							;=====================================================
    158  1459							; Print the string that immediately follows the JSR to
    159  1459							; this function.  Stops when a null byte is found,
    160  1459							; then returns to the instruction immediately
    161  1459							; following the null.
    162  1459							;
    163  1459							; Thanks to Ross Archer for this code.
    164  1459							; http://www.6502.org/source/io/primm.htm
    165  1459							;
    166  1459
    167  1459		       68	   tbputs     pla		;Get the low part of "return" address
    168  145a							;(data start address)
    169  145a		       85 5e		      sta	PrtFrom
    170  145c		       68		      pla
    171  145d		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    172  145f							;(data start address)
    173  145f							;Note: actually we're pointing one short
    174  145f		       a0 01	   PSINB      ldy	#1
    175  1461		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    176  1463		       e6 5e		      inc	PrtFrom	;update the pointer
    177  1465		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    178  1467		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    179  1469		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    180  146b							;   Accumulator
    181  146b		       f0 06		      beq	PSIX1	;don't print the final NULL
    182  146d		       20 2c 1e 	      jsr	VOUTCH	;write it out
    183  1470		       4c 5f 14 	      jmp	PSINB	;back around
    184  1473		       e6 5e	   PSIX1      inc	PrtFrom
    185  1475		       d0 02		      bne	PSIX2
    186  1477		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    187  1479		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    188  147c
    189  147c							;+
    190  147c							;====================================================
    191  147c		       2e 32	   PrtTerm    equ	tempy
    192  147c
    193  147c							; on exit Print Y has the offset to use
    194  147c							; input y =	 addr low
    195  147c							;	 x =	 addr high
    196  147c							;	 a =	 termination string
    197  147c
    198  147c				   PrtPrgLine
    199  147c		       a9 00		      lda	#0
    200  147e		       8d 32 2e 	      sta	PrtTerm
    201  1481		       f0 0e		      beq	PrtPrgText
    202  1483
    203  1483				   PrtQuoted
    204  1483		       a9 22		      lda	#'"
    205  1485		       a4 51		      ldy	CUROFF
    206  1487		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    207  1489		       d0 03		      bne	PrtNoInc
    208  148b		       c8		      iny
    209  148c		       84 51		      sty	CUROFF
    210  148e				   PrtNoInc
    211  148e		       8d 32 2e 	      sta	PrtTerm
    212  1491
    213  1491		       a4 51	   PrtPrgText ldy	CUROFF
    214  1493		       a5 4f		      lda	CURPTR
    215  1495		       85 5e		      sta	PrtFrom
    216  1497		       a5 50		      lda	CURPTR+1
    217  1499		       85 5f		      sta	PrtFrom+1
    218  149b		       4c a7 14 	      jmp	PrtLoop
    219  149e
    220  149e							; Print a string pointed to by x= h, y=l terminated by a
    221  149e							; Return y as the length
    222  149e
    223  149e		       86 5f	   PrtStr     stx	PrtFrom+1
    224  14a0		       84 5e		      sty	PrtFrom
    225  14a2		       8d 32 2e 	      sta	PrtTerm
    226  14a5		       a0 00		      ldy	#0
    227  14a7							;
    228  14a7							; On entry here ptrfrom and prtterm point to area to print
    229  14a7							;
    230  14a7		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    231  14a9		       cd 32 2e 	      cmp	PrtTerm
    232  14ac		       f0 0b		      beq	PrtEnd
    233  14ae		       c9 00		      cmp	#0	; always end if 0 is found
    234  14b0		       f0 07		      beq	PrtEnd
    235  14b2		       20 2c 1e 	      jsr	VOUTCH
    236  14b5		       c8		      iny
    237  14b6		       4c a7 14 	      jmp	PrtLoop
    238  14b9		       c8	   PrtEnd     iny		;return byte after the copy
    239  14ba		       60		      rts
    240  14bb
    241  14bb							;
    242  14bb							;=======================================================
    243  14bb							; Print all Variables
    244  14bb				   PrintAllVars
    245  14bb		       a0 00		      ldy	#0
    246  14bd		       a9 41		      lda	#'A
    247  14bf				   PrintAllVarsLoop
    248  14bf		       48		      pha
    249  14c0		       b1 41		      lda	(VARIABLES),y
    250  14c2		       85 52		      sta	R0
    251  14c4		       c8		      iny
    252  14c5		       b1 41		      lda	(VARIABLES),y
    253  14c7		       85 53		      sta	R0+1
    254  14c9
    255  14c9		       68		      pla		;get the current letter
    256  14ca		       48		      pha
    257  14cb		       20 2c 1e 	      jsr	VOUTCH
    258  14ce		       20 59 14 	      jsr	puts
      0  14d1					      db	"=",0
      1  14d1		       3d 00		      .byte.b	"=",0
    260  14d3		       68		      pla
    261  14d4		       aa		      tax
    262  14d5		       e8		      inx
    263  14d6		       8a		      txa
    264  14d7		       48		      pha		;
    265  14d8
    266  14d8		       98		      tya
    267  14d9		       48		      pha
    268  14da		       20 8a 13 	      jsr	PrintDecimal
    269  14dd		       20 59 14 	      jsr	puts
      0  14e0					      db	" ",0
      1  14e0		       20 00		      .byte.b	" ",0
    271  14e2		       68		      pla
    272  14e3		       a8		      tay
    273  14e4		       c8		      iny
    274  14e5		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    275  14e7		       90 d6		      bcc	PrintAllVarsLoop
    276  14e9		       20 e3 1c 	      jsr	CRLF
    277  14ec
    278  14ec		       68		      pla
    279  14ed		       60		      rts
    280  14ee
    281  14ee							;==================================================================================================
    282  14ee							; Size of print functions
    283  14ee		       01 64	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  14ee					      include	"mem.asm"
      1  14ee							;===================================================================
      2  14ee							;This file contains the memory allocation and free functions
      3  14ee							;in herant in this is the management of free memory in the system
      4  14ee							; the interface to these functions
      5  14ee							; a,x returns or provides the low hi bytes of the managed addresses
      6  14ee							; This uses the programend, to memory end as the area to manage
      7  14ee							;===================================================================
      8  14ee					      Seg	Code
      9  14ee							;=====================================================
     10  14ee							;Pointers for memory Management
     11  14ee							;Allocated block are not chained but can be followed for all memory by the associated length
     12  14ee							; Mem block format is
     13  14ee							;	 0-1   pointer to next block for free blocks
     14  14ee							;	 0-1   for allocated blocks
     15  14ee							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  14ee							;	   1   refrence counter ... lol only up to 256 but it is something
     17  14ee							;	 2-3   length constant for exevy type of memory block
     18  14ee							; Memory is recombined as it is released
     19  14ee							; The memory manager is not interupted durring allocation
     20  14ee							; or freeing of memory
     21  14ee							; Memory is allocated from the highest memory address towards
     22  14ee							; the lowest memory address. meeting the Basic program end.
     23  14ee							;====================================================
     24  14ee							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  14ee							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  14ee							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  14ee							;=====================================================
     28  14ee				   MemInit
     29  14ee		       a9 44		      lda	#FreeMemStart&$FF
     30  14f0		       8d 3a 2e 	      sta	ProgramStart
     31  14f3		       8d 3c 2e 	      sta	ProgramEnd
     32  14f6		       a9 2e		      lda	#FreeMemStart>>8
     33  14f8		       8d 3b 2e 	      sta	ProgramStart+1
     34  14fb		       8d 3d 2e 	      sta	ProgramEnd+1
     35  14fe
     36  14fe		       20 08 15 	      jsr	GetSizes
     37  1501		       20 13 15 	      jsr	MemFree
     38  1504		       20 2b 15 	      jsr	MemUsed
     39  1507				   MemInitEnd
     40  1507		       60		      rts
     41  1508
     42  1508
     43  1508							;
     44  1508							;=====================================================
     45  1508							; This function might go away eventually, but was
     46  1508							; added to provide data for other pieces of code.
     47  1508							; It has some ties to the operating environment that
     48  1508							; will need to be customized for the target system.
     49  1508							;
     50  1508				   GetSizes
     51  1508							;
     52  1508							; Here is machine specific code to get the highest
     53  1508							; memory location that can be used by BASIC.
     54  1508							;
     55  1508				  -	      if	ProgramStart < $2000
     56  1508				  -	      lda	#$ff
     57  1508				  -	      sta	HighMem	;$13ff for KIM-1
     58  1508				  -	      sta	MemFreeList
     59  1508				  -	      lda	#$DE	;#$13
     60  1508				  -	      sta	HighMem+1
     61  1508				  -	      sta	MemFreeList+1
     62  1508					      else
     63  1508		       a9 ff		      lda	#$ff
     64  150a		       8d 3e 2e 	      sta	HighMem	;$CFFF otherwise
     65  150d		       a9 cf		      lda	#$cf
     66  150f		       8d 3f 2e 	      sta	HighMem+1
     67  1512					      endif
     68  1512		       60		      rts
     69  1513							;
     70  1513							; This computes the available memory remaining.
     71  1513							;
     72  1513				   MemFree
     73  1513		       38		      sec
     74  1514		       ad 3e 2e 	      lda	HighMem
     75  1517		       ed 3c 2e 	      sbc	ProgramEnd
     76  151a		       8d 42 2e 	      sta	FreeMem
     77  151d		       85 52		      sta	R0
     78  151f		       ad 3f 2e 	      lda	HighMem+1
     79  1522		       ed 3d 2e 	      sbc	ProgramEnd+1
     80  1525		       8d 43 2e 	      sta	FreeMem+1
     81  1528		       85 53		      sta	R0+1
     82  152a		       60		      rts
     83  152b							;
     84  152b							; This computes the size of the current user program.
     85  152b							;
     86  152b				   MemUsed
     87  152b		       38		      sec
     88  152c		       ad 3c 2e 	      lda	ProgramEnd
     89  152f		       ed 3a 2e 	      sbc	ProgramStart
     90  1532		       8d 40 2e 	      sta	UsedMem
     91  1535		       85 52		      sta	R0
     92  1537		       ad 3d 2e 	      lda	ProgramEnd+1
     93  153a		       ed 3b 2e 	      sbc	ProgramStart+1
     94  153d		       8d 41 2e 	      sta	UsedMem+1
     95  1540		       85 53		      sta	R0+1
     96  1542							;
     97  1542		       60		      rts
     98  1543
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  1543					      include	"gosub.asm"
      1  1543					      seg	Code
      2  1543
      3  1543							; Gosub and return related functions
      4  1543							;==========================================================
      5  1543							; Push the current math stack frame onto the gosub stack
      6  1543				   iPushMathStack
      7  1543		       98		      tya
      8  1544		       48		      pha
      9  1545		       a4 4d		      ldy	GOSUBSTACKPTR
     10  1547		       a5 4a		      lda	MATHSTACKPTR
     11  1549		       91 4b		      sta	(GOSUBSTACK),y
     12  154b		       a9 00		      lda	#0
     13  154d		       c8		      iny
     14  154e		       91 4b		      sta	(GOSUBSTACK),y
     15  1550		       c8		      iny
     16  1551		       91 4b		      sta	(GOSUBSTACK),y
     17  1553		       c8		      iny
     18  1554		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  1556		       91 4b		      sta	(GOSUBSTACK),y
     20  1558		       c8		      iny
     21  1559		       84 4d		      sty	GOSUBSTACKPTR
     22  155b		       68		      pla
     23  155c		       a8		      tay
     24  155d		       4c c2 02 	      jmp	NextIL
     25  1560							;
     26  1560							;==========================================================
     27  1560							; Increment parameter count. Assume Stack frame is top of stack
     28  1560				   iIncParmCount
     29  1560		       98		      tya
     30  1561		       48		      pha
     31  1562		       a4 4d		      ldy	GOSUBSTACKPTR
     32  1564		       88		      dey
     33  1565		       88		      dey
     34  1566		       88		      dey
     35  1567		       b1 4b		      lda	(GOSUBSTACK),y
     36  1569		       aa		      tax
     37  156a		       e8		      inx
     38  156b		       8a		      txa
     39  156c		       91 4b		      sta	(GOSUBSTACK),y
     40  156e		       68		      pla
     41  156f		       a8		      tay
     42  1570		       4c c2 02 	      jmp	NextIL
     43  1573							;
     44  1573							;==========================================================
     45  1573							;Restore the math stack frame
     46  1573		       20 79 15    iPopMathStack jsr	PopMathStackNow
     47  1576		       4c c2 02 	      jmp	NextIL
     48  1579
     49  1579				   PopMathStackNow
     50  1579		       98		      tya
     51  157a		       48		      pha
     52  157b
     53  157b		       a4 4d		      ldy	GOSUBSTACKPTR
     54  157d		       88		      dey
     55  157e		       b1 4b		      lda	(GOSUBSTACK),y
     56  1580		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  1582		       d0 09		      bne	iPopMathStackNoFrame
     58  1584		       88		      dey
     59  1585		       88		      dey
     60  1586		       88		      dey
     61  1587		       b1 4b		      lda	(GOSUBSTACK),y
     62  1589		       85 4a		      sta	MATHSTACKPTR
     63  158b		       84 4d		      sty	GOSUBSTACKPTR
     64  158d
     65  158d				   iPopMathStackNoFrame
     66  158d
     67  158d		       68		      pla
     68  158e		       a8		      tay
     69  158f		       60		      rts
     70  1590
     71  1590
     72  1590							;==========================================================
     73  1590							; Push the current math stack information onto the gosub stack
     74  1590				   iSaveMathStack
     75  1590		       98		      tya
     76  1591		       48		      pha
     77  1592		       a4 4d		      ldy	GOSUBSTACKPTR
     78  1594		       a5 4a		      lda	MATHSTACKPTR
     79  1596		       91 4b		      sta	(GOSUBSTACK),y
     80  1598		       a5 48		      lda	MATHSTACK
     81  159a		       c8		      iny
     82  159b
     83  159b		       91 4b		      sta	(GOSUBSTACK),y
     84  159d		       c8		      iny
     85  159e
     86  159e		       a5 49		      lda	MATHSTACK+1
     87  15a0		       91 4b		      sta	(GOSUBSTACK),y
     88  15a2		       c8		      iny
     89  15a3
     90  15a3		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  15a5		       91 4b		      sta	(GOSUBSTACK),y
     92  15a7		       c8		      iny
     93  15a8
     94  15a8		       84 4d		      sty	GOSUBSTACKPTR
     95  15aa		       68		      pla
     96  15ab		       a8		      tay
     97  15ac		       4c c2 02 	      jmp	NextIL
     98  15af							;
     99  15af							;==========================================================
    100  15af							;Restore the math stack information from the gosub stack
    101  15af				   iRestoreMathStack
    102  15af		       98		      tya
    103  15b0		       48		      pha
    104  15b1
    105  15b1		       a5 4a		      lda	MATHSTACKPTR
    106  15b3		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  15b5
    108  15b5		       a4 4d		      ldy	GOSUBSTACKPTR
    109  15b7		       88		      dey
    110  15b8		       b1 4b		      lda	(GOSUBSTACK),y
    111  15ba		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  15bc		       d0 16		      bne	iPopMathStack_Err
    113  15be		       88		      dey
    114  15bf		       b1 4b		      lda	(GOSUBSTACK),y
    115  15c1		       85 49		      sta	MATHSTACK+1
    116  15c3		       88		      dey
    117  15c4		       b1 4b		      lda	(GOSUBSTACK),y
    118  15c6		       85 48		      sta	MATHSTACK
    119  15c8		       88		      dey
    120  15c9		       b1 4b		      lda	(GOSUBSTACK),y
    121  15cb		       85 4a		      sta	MATHSTACKPTR
    122  15cd		       84 4d		      sty	GOSUBSTACKPTR
    123  15cf		       68		      pla
    124  15d0		       a8		      tay
    125  15d1		       4c c2 02 	      jmp	NextIL
    126  15d4
    127  15d4				   iPopMathStack_Err
    128  15d4		       a9 00		      lda	#0
    129  15d6		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  15d8		       4c 20 06 	      jmp	iErr2
    131  15db							;=========================================
    132  15db							; For functions and tasks the variable address of # means
    133  15db							; a passed parameter so #[0] is the first parameter etc
    134  15db							; will try for a better way later
    135  15db
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  15db					      include	"tasks.asm"
      1  15db							;=====================================================
      2  15db							; Tiny Basic IL task management
      3  15db							; Data required by task management
      4  15db							; currently each context is about 30 bytes and is swapped
      5  15db							; into and out of page zero on each task switch....
      6  15db							; LOL yes it is slow, but works for this iteration.
      7  15db							;
      8  15db
      9  15db					      Seg	Code
     10  15db							;=====================================================
     11  15db							; Sets the pointers to the math,IL and gosub stacks
     12  15db							; Creates the initial Context for each task slot
     13  15db				   taskSetStacks
     14  15db		       a9 e1		      lda	#mathStack&$FF
     15  15dd		       85 48		      sta	MATHSTACK
     16  15df		       a9 25		      lda	#mathStack>>8
     17  15e1		       85 49		      sta	MATHSTACK+1
     18  15e3
     19  15e3		       a9 71		      lda	#ilStack&$ff
     20  15e5		       85 45		      sta	ILSTACK
     21  15e7		       a9 27		      lda	#ilStack>>8
     22  15e9		       85 46		      sta	ILSTACK+1
     23  15eb
     24  15eb		       a9 01		      lda	#gosubStack&$FF
     25  15ed		       85 4b		      sta	GOSUBSTACK
     26  15ef		       a9 29		      lda	#gosubStack>>8
     27  15f1		       85 4c		      sta	GOSUBSTACK+1
     28  15f3
     29  15f3		       a9 81		      lda	#variableStack&$FF
     30  15f5		       85 41		      sta	VARIABLES
     31  15f7		       a9 2b		      lda	#variableStack>>8
     32  15f9		       85 42		      sta	VARIABLES+1
     33  15fb		       a2 0a		      ldx	#TASKCOUNT
     34  15fd		       a0 00		      ldy	#0
     35  15ff		       20 8a 18 	      jsr	ContextSave
     36  1602
     37  1602		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  1604		       b0 3a		      bcs	taskSetDone
     39  1606
     40  1606		       a5 4b		      lda	GOSUBSTACK
     41  1608		       18		      clc
     42  1609		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  160b		       85 4b		      sta	GOSUBSTACK
     44  160d		       a5 4c		      lda	GOSUBSTACK+1
     45  160f		       69 00		      adc	#0
     46  1611		       85 4c		      sta	GOSUBSTACK+1
     47  1613
     48  1613		       a5 45		      lda	ILSTACK	; must be less than 256
     49  1615		       18		      clc
     50  1616		       69 28		      adc	#ILSTACKSIZE*2
     51  1618		       85 45		      sta	ILSTACK
     52  161a		       a5 46		      lda	ILSTACK+1
     53  161c		       69 00		      adc	#0
     54  161e		       85 46		      sta	ILSTACK+1
     55  1620
     56  1620		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  1622		       18		      clc
     58  1623		       69 28		      adc	#MATHSTACKSIZE*2
     59  1625		       85 48		      sta	MATHSTACK
     60  1627		       a5 49		      lda	MATHSTACK+1
     61  1629		       69 00		      adc	#0
     62  162b		       85 49		      sta	MATHSTACK+1
     63  162d
     64  162d		       a5 41		      lda	VARIABLES	; must be less than 256
     65  162f		       18		      clc
     66  1630		       69 36		      adc	#VARIABLESSIZE*2
     67  1632		       85 41		      sta	VARIABLES
     68  1634		       a5 42		      lda	VARIABLES+1
     69  1636		       69 00		      adc	#0
     70  1638		       85 42		      sta	VARIABLES+1
     71  163a
     72  163a		       20 8a 18 	      jsr	ContextSave
     73  163d		       4c 02 16 	      jmp	taskSetLoop
     74  1640
     75  1640				   taskSetDone
     76  1640		       a0 00		      ldy	#0	; reload the main loop context
     77  1642		       20 99 18 	      jsr	ContextLoad
     78  1645		       60		      rts
     79  1646							;
     80  1646							;=====================================================
     81  1646							; In some error cases the math stacks may be left pointing to the wrong stack
     82  1646							; This function will reset those stack addresses but not the actual pointer
     83  1646				   taskResetStacks
     84  1646		       a0 00		      ldy	#0
     85  1648		       20 99 18 	      jsr	ContextLoad
     86  164b		       4c db 15 	      jmp	taskSetStacks
     87  164e							;
     88  164e							;=====================================================
     89  164e							; Clear all task entries and task stacks
     90  164e		       98	   taskReset  tya		; Save Y
     91  164f		       48		      pha
     92  1650		       a9 01		      lda	#1
     93  1652		       8d e0 25 	      sta	taskCounter	; Set number of active tasks to 1
     94  1655		       ac e1 24 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  1658		       c0 00		      cpy	#0	; check if we are the main context
     96  165a		       f0 08		      beq	taskResetCont	; if we are just continue
     97  165c
     98  165c		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  165e		       8c e1 24 	      sty	taskPtr
    100  1661		       20 99 18 	      jsr	ContextLoad	; load the System Task context
    101  1664				   taskResetCont
    102  1664		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  1666
    104  1666				   taskResetLoop
    105  1666		       a9 00		      lda	#TASKINACTIVE
    106  1668		       99 e2 24 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  166b		       18		      clc
    108  166c		       98		      tya
    109  166d		       69 19		      adc	#CONTEXTLEN+1
    110  166f		       a8		      tay
    111  1670		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  1672		       90 f2		      bcc	taskResetLoop	; Go for more
    113  1674
    114  1674				   taskResetComplete
    115  1674
    116  1674		       68		      pla		; Restore y
    117  1675		       a8		      tay
    118  1676		       60		      rts
    119  1677
    120  1677							;
    121  1677							;======================================================
    122  1677							; iTaskSwitch	 switch to new task if not interrupt and
    123  1677							;		 count is exceded for task time slice gets here
    124  1677							;		 when time slice has reached zero
    125  1677							;
    126  1677		       98	   iTaskSwitch tya
    127  1678		       48		      pha
    128  1679
    129  1679		       ad de 25 	      lda	taskResetValue	; Always reset the counter value
    130  167c		       8d dc 25 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  167f		       ce dd 25 	      dec	taskCurrentCycles+1	; dec high order byte
    132  1682		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  1684
    134  1684		       ad df 25 	      lda	taskResetValue+1
    135  1687		       8d dd 25 	      sta	taskCurrentCycles+1
    136  168a
    137  168a		       ad de 24 	      lda	IRQPending	; Skip this if we are processing an irq
    138  168d		       0d 38 2e 	      ora	taskIOPending	; If set then don't switch
    139  1690		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  1692
    141  1692		       ad e0 25    iTaskMain  lda	taskCounter	; Number of tasks
    142  1695		       c9 01		      cmp	#1	; if there is only one task must be main
    143  1697		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  1699
    145  1699		       ac e1 24 	      ldy	taskPtr	; check if we have not just ended some other task
    146  169c		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  169e		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  16a0							;
    149  16a0							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  16a0							;
    151  16a0				   itasknext
    152  16a0		       ac e1 24 	      ldy	taskPtr
    153  16a3		       20 8a 18 	      jsr	ContextSave	; Save the current context, y points to next context
    154  16a6				   itaskLoop
    155  16a6		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  16a8		       90 04		      bcc	iTaskNextChk
    157  16aa
    158  16aa		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  16ac		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  16ae
    161  16ae				   iTaskNextChk
    162  16ae		       b9 e2 24 	      lda	taskTable,y	; there is always at least one entry in table
    163  16b1		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  16b3		       18	   iTaskNext  clc
    165  16b4		       98		      tya
    166  16b5		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  16b7		       a8		      tay
    168  16b8		       4c a6 16 	      jmp	itaskLoop	; Check for busy entry
    169  16bb
    170  16bb		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  16bd		       59 e2 24 	      eor	taskTable,y	; Check for anything waiting io
    172  16c0		       d0 f1		      bne	iTaskNext
    173  16c2		       20 99 18 	      jsr	ContextLoad	; load the next context
    174  16c5		       8c e1 24 	      sty	taskPtr	; update the task pointer
    175  16c8
    176  16c8				   iTaskSwitchDone
    177  16c8		       68		      pla
    178  16c9		       a8		      tay
    179  16ca		       60		      rts
    180  16cb							;
    181  16cb							;================================================================
    182  16cb							; Task Set task number to line number to start
    183  16cb							; Task Table structure:
    184  16cb							;    byte 0	-   Active inactive
    185  16cb							;    byte 1-2	-   Basic code line pointer
    186  16cb							;    byte 3	-   Offset on current line
    187  16cb		       98	   iTaskSet   tya		;preserve Y
    188  16cc		       48		      pha		; push a
    189  16cd
    190  16cd		       20 2a 1c 	      jsr	popR0	; Get the line number to be saved
    191  16d0
    192  16d0		       ac e1 24 	      ldy	taskPtr	; find out where we are
    193  16d3		       20 8a 18 	      jsr	ContextSave	; Save the current context
    194  16d6
    195  16d6							;Find the pointer to the line we need to start at
    196  16d6		       20 f2 19 	      jsr	findLine	; Get the offset of the line to start task at
    197  16d9		       f0 0b		      beq	iTaskCont
    198  16db
    199  16db		       ac e1 24 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  16de		       20 99 18 	      jsr	ContextLoad
    201  16e1
    202  16e1		       68		      pla		; pop a - exit
    203  16e2		       a8		      tay
    204  16e3		       4c 35 0d 	      jmp	iSetIrqErr	; Bad line number provided
    205  16e6
    206  16e6				   iTaskCont
    207  16e6		       20 5c 18 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  16e9		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  16eb
    210  16eb		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  16ed		       99 e2 24 	      sta	taskTable,y	; new task as active
    212  16f0
    213  16f0		       a5 4f		      lda	CURPTR
    214  16f2		       48		      pha		; push a
    215  16f3		       a5 50		      lda	CURPTR+1
    216  16f5		       48		      pha		; push a
    217  16f6
    218  16f6		       20 99 18 	      jsr	ContextLoad	; load the context of the new task
    219  16f9
    220  16f9		       68		      pla		; pop a
    221  16fa		       85 50		      sta	CURPTR+1
    222  16fc		       68		      pla		; pop a
    223  16fd		       85 4f		      sta	CURPTR
    224  16ff		       a9 03		      lda	#3	; Offset to first instruction
    225  1701		       85 51		      sta	CUROFF
    226  1703
    227  1703		       a9 00		      lda	#0
    228  1705		       85 47		      sta	ILSTACKPTR
    229  1707		       85 4a		      sta	MATHSTACKPTR
    230  1709		       85 4d		      sta	GOSUBSTACKPTR
    231  170b		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  170d		       85 4e		      sta	MESSAGEPTR
    233  170f
    234  170f		       20 24 09 	      jsr	subVINIT	; Clear the variables
    235  1712
    236  1712		       a9 d9		      lda	#STMT&$FF
    237  1714		       85 43		      sta	ILPC
    238  1716		       a9 20		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  1718		       85 44		      sta	ILPC+1
    240  171a
    241  171a		       98		      tya		; Save the new context offset to return to user
    242  171b		       48		      pha		; push a
    243  171c
    244  171c		       20 8a 18    itaskSetSave jsr	ContextSave	; save the updated context
    245  171f		       ee e0 25 	      inc	taskCounter	; Update the number of Tasks running
    246  1722
    247  1722		       ac e1 24 	      ldy	taskPtr
    248  1725		       20 99 18 	      jsr	ContextLoad	; restore the original context
    249  1728
    250  1728		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  172a		       85 53		      sta	R0+1
    252  172c		       68		      pla		; Get the task pid we stored				 ; pop a
    253  172d		       85 52		      sta	R0	; Get the table entry value
    254  172f
    255  172f		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  1730		       a8		      tay
    257  1731
    258  1731		       4c 0b 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  1734				   iTaskNoEmpty
    260  1734		       ac e1 24 	      ldy	taskPtr
    261  1737		       20 99 18 	      jsr	ContextLoad
    262  173a
    263  173a		       68		      pla		; pop a    -- exit
    264  173b		       a8		      tay
    265  173c
    266  173c		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  173e		       a9 00		      lda	#0
    268  1740		       4c 20 06 	      jmp	iErr2
    269  1743							;
    270  1743							;===============================================================
    271  1743							; Run the task whos PID is on the stack, preserve the stack
    272  1743							;
    273  1743				   iTaskEnable
    274  1743		       98		      tya
    275  1744		       48		      pha
    276  1745		       20 42 1c 	      jsr	popR1
    277  1748		       20 10 1c 	      jsr	pushR1
    278  174b		       20 90 19 	      jsr	ipc_getcontext	; get context pointer into mq
    279  174e		       a0 00		      ldy	#0
    280  1750		       b1 56		      lda	(MQ),y
    281  1752		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  1754		       09 80		      ora	#TASKACTIVE
    283  1756		       91 56		      sta	(MQ),y
    284  1758		       68		      pla
    285  1759		       a8		      tay
    286  175a		       4c c2 02 	      jmp	NextIL
    287  175d
    288  175d							;
    289  175d							;===============================================================
    290  175d							; Suspend the task whos PID  is on the stack, preserve the stack
    291  175d							;
    292  175d				   iTaskSuspend
    293  175d		       98		      tya
    294  175e		       48		      pha
    295  175f		       20 42 1c 	      jsr	popR1
    296  1762		       20 10 1c 	      jsr	pushR1
    297  1765		       20 90 19 	      jsr	ipc_getcontext	; get context pointer into mq
    298  1768		       a0 00		      ldy	#0
    299  176a		       b1 56		      lda	(MQ),y
    300  176c		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  176e		       09 80		      ora	#TASKACTIVE
    302  1770		       68		      pla
    303  1771		       a8		      tay
    304  1772		       4c c2 02 	      jmp	NextIL
    305  1775
    306  1775							;================================================================
    307  1775							; Returns task Status
    308  1775				   iTaskStat
    309  1775		       98		      tya
    310  1776		       48		      pha
    311  1777		       20 89 17 	      jsr	iTaskValid	; returns pointer to task entry
    312  177a		       b9 e2 24 	      lda	taskTable,y
    313  177d		       f0 05		      beq	iTaskStatExit
    314  177f		       68		      pla
    315  1780		       a8		      tay
    316  1781		       4c f1 0c 	      jmp	iTruth
    317  1784				   iTaskStatExit
    318  1784		       68		      pla
    319  1785		       a8		      tay
    320  1786		       4c fa 0c 	      jmp	iFalse
    321  1789
    322  1789							;
    323  1789							;================================================================
    324  1789							; Validate the task number on top of the stack
    325  1789							; on exit y points to the requested task entry
    326  1789							;
    327  1789		       20 2a 1c    iTaskValid jsr	popR0	; get result of the multiply
    328  178c		       a5 53		      lda	R0+1
    329  178e		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  1790		       a5 52		      lda	R0
    331  1792		       c9 fa		      cmp	#TASKTABLELEN
    332  1794		       90 09		      bcc	iTaskIsValid
    333  1796
    334  1796		       68	   iTaskValidErr pla		;remove return address
    335  1797		       68		      pla
    336  1798		       a2 10		      ldx	#ERR_INVALID_PID
    337  179a		       a9 00		      lda	#0
    338  179c		       4c 20 06 	      jmp	iErr2
    339  179f
    340  179f		       a8	   iTaskIsValid tay
    341  17a0		       60		      rts
    342  17a1							;
    343  17a1							;================================================================
    344  17a1							; Kill a running task, do nothing if already stopped
    345  17a1		       20 89 17    iTaskKill  jsr	iTaskValid
    346  17a4		       a9 00		      lda	#0
    347  17a6		       99 e2 24 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  17a9							;
    349  17a9							;================================================================
    350  17a9							;Skip to next task
    351  17a9				   iNTask
    352  17a9		       a9 01		      lda	#1
    353  17ab		       8d dc 25 	      sta	taskCurrentCycles
    354  17ae		       8d dd 25 	      sta	taskCurrentCycles+1
    355  17b1		       4c c2 02 	      jmp	NextIL
    356  17b4							;
    357  17b4							;=======================================================
    358  17b4							; Wait for a task to complete
    359  17b4				   iWTASK
    360  17b4		       20 ad 19 	      jsr	getILByte
    361  17b7		       8d 36 2e 	      sta	offset
    362  17ba							;
    363  17ba		       20 90 1b 	      jsr	saveIL	;in case of failure
    364  17bd
    365  17bd		       20 89 17 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  17c0		       b9 e2 24 	      lda	taskTable,y
    367  17c3		       d0 03		      bne	iWTASKWAIT
    368  17c5				   iWTASKEXITED
    369  17c5		       4c c2 02 	      jmp	NextIL
    370  17c8				   iWTASKWAIT
    371  17c8		       20 a6 1b 	      jsr	pushR0	; Push R0 back onto the stack
    372  17cb		       a9 01		      lda	#1
    373  17cd		       8d dc 25 	      sta	taskCurrentCycles	; Give up the cycles
    374  17d0		       8d dd 25 	      sta	taskCurrentCycles+1
    375  17d3		       20 9b 1b 	      jsr	restoreIL
    376  17d6		       4c 55 0b 	      jmp	tstBranch
    377  17d9							;
    378  17d9							;=======================================================
    379  17d9							; Set task io lock
    380  17d9		       ee 38 2e    iStartIO   inc	taskIOPending
    381  17dc		       4c c2 02 	      jmp	NextIL
    382  17df							;
    383  17df							;=======================================================
    384  17df							; Release the io lock
    385  17df		       ad 38 2e    iEndIO     lda	taskIOPending
    386  17e2		       f0 03		      beq	iEndIOExit
    387  17e4		       ce 38 2e 	      dec	taskIOPending
    388  17e7		       4c c2 02    iEndIOExit jmp	NextIL
    389  17ea							;
    390  17ea							;===============================================================
    391  17ea							; Return the task PID
    392  17ea				   iTASKPID
    393  17ea		       a9 00		      lda	#0
    394  17ec		       85 53		      sta	R0+1
    395  17ee		       ad e1 24 	      lda	taskPtr
    396  17f1		       85 52		      sta	R0
    397  17f3		       4c 0b 07 	      jmp	pushR0nextIl
    398  17f6							;
    399  17f6							;================================================================
    400  17f6							; Terminate a task
    401  17f6		       ac e1 24    iETask     ldy	taskPtr
    402  17f9		       c0 00		      cpy	#0
    403  17fb		       d0 03		      bne	iETaskCont
    404  17fd		       4c 09 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  1800				   iETaskCont
    406  1800		       a9 00		      lda	#TASKINACTIVE
    407  1802		       99 e2 24 	      sta	taskTable,y	; mark entry as free
    408  1805		       ce e0 25 	      dec	taskCounter	; reduce the number of active tasks
    409  1808		       a9 01		      lda	#1
    410  180a		       8d dc 25 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  180d		       8d dd 25 	      sta	taskCurrentCycles+1
    412  1810		       20 77 18 	      jsr	TaskSetExitCode
    413  1813				   iETaskExit
    414  1813		       4c c2 02 	      jmp	NextIL
    415  1816							;================================================================
    416  1816							; make the current tasks math stack equal another tasks stack
    417  1816							; The task to get is stored on the math stack
    418  1816
    419  1816				   iTaskGetMathStack
    420  1816		       20 4b 1e 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  1819		       20 90 19 	      jsr	ipc_getcontext	; MQ now has the context address
    422  181c		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  181e		       b1 56		      lda	(MQ),y
    424  1820		       85 4a		      sta	MATHSTACKPTR
    425  1822		       a0 08		      ldy	#MATHSTACKPOS
    426  1824		       b1 56		      lda	(MQ),y
    427  1826		       85 48		      sta	MATHSTACK
    428  1828		       c8		      iny
    429  1829		       b1 56		      lda	(MQ),y
    430  182b		       85 49		      sta	MATHSTACK+1
    431  182d		       4c c2 02 	      jmp	NextIL
    432  1830							;==================================================================
    433  1830							; Updates the tasks math stack pointer with contents of R2
    434  1830							; PID is on top of the stack
    435  1830				   iTaskPutMathPtr
    436  1830		       20 4b 1e 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  1833		       20 90 19 	      jsr	ipc_getcontext	; MQ now has the context address
    438  1836		       a5 58		      lda	R2
    439  1838		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  183a		       91 56		      sta	(MQ),y
    441  183c		       4c c2 02 	      jmp	NextIL
    442  183f							;
    443  183f							;================================================================
    444  183f							; Set the time slice for each task
    445  183f				   iSLICE
    446  183f		       20 2a 1c 	      jsr	popR0
    447  1842		       a5 52		      lda	R0
    448  1844		       8d de 25 	      sta	taskResetValue
    449  1847		       a5 53		      lda	R0+1
    450  1849		       8d df 25 	      sta	taskResetValue+1
    451  184c		       d0 0b		      bne	iSliceSet
    452  184e		       ee df 25 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  1851		       a9 01		      lda	#1
    454  1853		       8d dc 25 	      sta	taskCurrentCycles
    455  1856		       8d dd 25 	      sta	taskCurrentCycles+1
    456  1859				   iSliceSet
    457  1859		       4c c2 02 	      jmp	NextIL
    458  185c							;================================================================
    459  185c							; Find an empty slot in the taskTable
    460  185c							; Return the index in y
    461  185c							; on exit   c set if an empty slot is found
    462  185c							;	     c clear if not found
    463  185c							;================================================================
    464  185c							;
    465  185c		       ad e0 25    TaskEmpty  lda	taskCounter
    466  185f		       c9 0a		      cmp	#TASKCOUNT
    467  1861		       b0 10		      bcs	TaskNoSlot
    468  1863		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  1865				   TaskLoop
    470  1865		       b9 e2 24 	      lda	taskTable,y
    471  1868		       f0 0b		      beq	TaskEmptyFnd
    472  186a		       98		      tya
    473  186b		       18		      clc
    474  186c		       69 19		      adc	#CONTEXTLEN+1
    475  186e		       a8		      tay
    476  186f		       c0 fa		      cpy	#TASKTABLELEN
    477  1871		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  1873				   TaskNoSlot
    479  1873		       18		      clc
    480  1874		       60		      rts
    481  1875				   TaskEmptyFnd
    482  1875		       38		      sec
    483  1876		       60		      rts
    484  1877							;====================================================
    485  1877							; Set the task exit code called from the return command
    486  1877							; on entry stack top hold exit value
    487  1877				   TaskSetExitCode
    488  1877		       98		      tya
    489  1878		       48		      pha
    490  1879		       20 2a 1c 	      jsr	popR0
    491  187c		       a0 19		      ldy	#TASKEXITCODE
    492  187e		       a5 52		      lda	R0
    493  1880		       91 41		      sta	(VARIABLES),y
    494  1882		       c8		      iny
    495  1883		       a5 53		      lda	R0+1
    496  1885		       91 41		      sta	(VARIABLES),y
    497  1887		       68		      pla
    498  1888		       98		      tya
    499  1889		       60		      rts
    500  188a
    501  188a							;
    502  188a							;=====================================================
    503  188a							; Save Context Store the context to the TASK Table
    504  188a							; on entry y contains the task table entry to save to
    505  188a							; on exit y points to next task table entry
    506  188a							;	   x contains the number of bytes copied
    507  188a		       a2 00	   ContextSave ldx	#0
    508  188c		       c8		      iny		;inc past the task flags
    509  188d		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  188f		       99 e2 24 	      sta	taskTable,y
    511  1892		       c8		      iny
    512  1893		       e8		      inx
    513  1894		       e0 18		      cpx	#CONTEXTLEN
    514  1896		       90 f5		      bcc	ContextSvLoop
    515  1898		       60		      rts
    516  1899							;
    517  1899							; Load Context transfer context from task table to the Current Context
    518  1899							; on entry y contains the task table entry to transfer
    519  1899							; on exit y points to the original task table entry
    520  1899							;	   x contains the number of byts copied
    521  1899		       98	   ContextLoad tya
    522  189a		       48		      pha
    523  189b		       a2 00		      ldx	#0
    524  189d		       c8		      iny		;inc past the task flags
    525  189e		       b9 e2 24    ContextLDLoop lda	taskTable,y
    526  18a1		       95 41		      sta	CONTEXT,x
    527  18a3		       c8		      iny
    528  18a4		       e8		      inx
    529  18a5		       e0 18		      cpx	#CONTEXTLEN
    530  18a7		       90 f5		      bcc	ContextLDLoop
    531  18a9		       68		      pla
    532  18aa		       a8		      tay
    533  18ab		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  18ac					      include	"ipc.asm"
      1  18ac							;======================================================
      2  18ac							; Inter process communications.
      3  18ac							; Tasks may write/read integer messages among
      4  18ac							; them selves.
      5  18ac							; This uses each tasks gosub stack as a message queue
      6  18ac							; Gosub calls start at the highest address and the
      7  18ac							; msg queue starts at the highest address.
      8  18ac							;
      9  18ac							;======================================================
     10  18ac							; ipcs   - Send msg to another task or many tasks
     11  18ac							; on entry  math stack contains the  top PID
     12  18ac							;				      2ND Message value
     13  18ac							; on exit   math stack contain top True-good or False-failed
     14  18ac							;
     15  18ac							; it may not be sent if queue is full
     16  18ac							;
     17  18ac							; a = ipcs(<message-expression>,<task PID-expression>)
     18  18ac							;
     19  18ac				   iIPCS
     20  18ac		       98		      tya
     21  18ad		       48		      pha
     22  18ae		       20 15 19 	      jsr	ipc_enqueue
     23  18b1		       b0 08		      bcs	iIPC_BAD
     24  18b3		       20 3d 1e 	      jsr	pushTrue
     25  18b6		       68		      pla
     26  18b7		       a8		      tay
     27  18b8		       4c c2 02 	      jmp	NextIL
     28  18bb				   iIPC_BAD
     29  18bb		       68		      pla
     30  18bc		       a8		      tay
     31  18bd		       20 47 1e 	      jsr	pushFalse
     32  18c0		       4c c2 02 	      jmp	NextIL
     33  18c3
     34  18c3							;======================================================
     35  18c3							; ipcr   - Recieve msg from task
     36  18c3							; on exit  the message value is returned from message queue
     37  18c3							;	    message -1	is reserved meaning no entry found
     38  18c3							; The provided variable contains the pid of the sending
     39  18c3							; task. This is optional. This always waits for a message
     40  18c3							; before returning.
     41  18c3							;
     42  18c3							; a = ipcr(<variable name>)
     43  18c3							;
     44  18c3				   iIPCR
     45  18c3		       98		      tya
     46  18c4		       48		      pha
     47  18c5		       20 57 19 	      jsr	ipc_dequeue
     48  18c8		       b0 05		      bcs	iIPCR_Q_Empty
     49  18ca		       68		      pla
     50  18cb		       a8		      tay
     51  18cc		       4c c2 02 	      jmp	NextIL
     52  18cf				   iIPCR_Q_Empty
     53  18cf		       68		      pla
     54  18d0		       a8		      tay
     55  18d1		       20 3d 1e 	      jsr	pushTrue	; puts -1 on the stack
     56  18d4		       4c c2 02 	      jmp	NextIL
     57  18d7
     58  18d7							;=======================================================
     59  18d7							; ipcc   - Check if message available
     60  18d7							; on exit  Stack contains number of messages
     61  18d7							;
     62  18d7							; a = ipcc()
     63  18d7							;
     64  18d7				   iIPCC
     65  18d7		       98		      tya
     66  18d8		       48		      pha
     67  18d9		       20 02 19 	      jsr	ipc_queue_count
     68  18dc		       20 a6 1b 	      jsr	pushR0	; return the count
     69  18df		       68		      pla
     70  18e0		       a8		      tay
     71  18e1		       4c c2 02 	      jmp	NextIL
     72  18e4
     73  18e4							;=======================================================
     74  18e4							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  18e4				   iIPCIO
     76  18e4		       98		      tya
     77  18e5		       48		      pha
     78  18e6		       20 02 19 	      jsr	ipc_queue_count
     79  18e9		       a5 52		      lda	R0
     80  18eb		       d0 10		      bne	iIPCIO_No_Halt
     81  18ed		       a9 01		      lda	#1
     82  18ef		       8d dc 25 	      sta	taskCurrentCycles	; force a task switch
     83  18f2		       a9 01		      lda	#TASKWAITIPC
     84  18f4		       ac e1 24 	      ldy	taskPtr
     85  18f7		       19 e2 24 	      ora	taskTable,y
     86  18fa		       99 e2 24 	      sta	taskTable,y
     87  18fd
     88  18fd				   iIPCIO_No_Halt
     89  18fd		       68		      pla
     90  18fe		       a8		      tay
     91  18ff		       4c c2 02 	      jmp	NextIL
     92  1902							;======================================================
     93  1902							;ipc_queue_count
     94  1902				   ipc_queue_count
     95  1902		       a5 4e		      lda	MESSAGEPTR
     96  1904		       18		      clc
     97  1905		       4a		      lsr		; divide by 4
     98  1906		       4a		      lsr
     99  1907		       85 52		      sta	R0	; store into R0
    100  1909		       a9 10		      lda	#GOSUBSTACKSIZE
    101  190b		       38		      sec
    102  190c		       e5 52		      sbc	R0	; Get how many entries on queue
    103  190e		       85 52		      sta	R0
    104  1910		       a9 00		      lda	#0
    105  1912		       85 53		      sta	R0+1
    106  1914		       60		      rts
    107  1915							;=======================================================
    108  1915							; Support functions for messaging
    109  1915							;
    110  1915							; Enqueue message -> onto PID's MSG Q
    111  1915							; on entry top of stack contains the PID
    112  1915							;	    second contains the Message of the task
    113  1915							; on exit contains c set if failed
    114  1915							;		    c cleared if success
    115  1915							;		    PID's MSG Q PTR points to the message
    116  1915							;
    117  1915				   ipc_enqueue
    118  1915		       20 42 1c 	      jsr	popR1	; Get the pid
    119  1918		       20 90 19 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  191b
    121  191b		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  191d		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  191f		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  1921		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  1923		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  1925
    127  1925
    128  1925							; Get the PID'S stack address into R0
    129  1925		       a0 0b		      ldy	#GOSUBSTKPOS
    130  1927		       b1 56		      lda	(MQ),y
    131  1929		       85 52		      sta	R0
    132  192b		       c8		      iny
    133  192c		       b1 56		      lda	(MQ),y
    134  192e		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  1930
    136  1930							; Set y to point to the msg q entry
    137  1930		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  1932		       b1 56		      lda	(MQ),y	; Get the index
    139  1934		       a8		      tay		; Set y to queue offset
    140  1935
    141  1935							; enqueue the message
    142  1935		       88		      dey		; First byte to save to
    143  1936		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  1938		       91 52		      sta	(R0),y	; Set the entry type
    145  193a
    146  193a		       88		      dey
    147  193b		       ad e1 24 	      lda	taskPtr	; Store the PID into queue
    148  193e		       91 52		      sta	(R0),y
    149  1940		       20 42 1c 	      jsr	popR1	; Get the actual message value
    150  1943		       20 9e 19 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1946
    152  1946		       98		      tya		; Save the new q ptr
    153  1947		       a0 0e		      ldy	#MSGPTRPOS
    154  1949		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  194b		       a0 00		      ldy	#0	; points to context root
    156  194d		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  194f		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1951		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1953		       18		      clc
    160  1954		       60		      rts
    161  1955				   ipc_enq_full
    162  1955		       38		      sec
    163  1956		       60		      rts
    164  1957							;=============================================================
    165  1957							; De-queue for message stack -> local tasks msg q
    166  1957							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1957							;  message into
    168  1957							;  on exit   math stack contains value of message
    169  1957							;				  Variable if provided is pid
    170  1957				   ipc_dequeue
    171  1957		       20 59 1c 	      jsr	popMQ	; Variable address to put PID into
    172  195a
    173  195a		       a4 4e		      ldy	MESSAGEPTR
    174  195c		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  195e		       b0 2e		      bcs	ipc_deq_empty
    176  1960		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1962		       85 52		      sta	R0
    178  1964		       c8		      iny
    179  1965		       b1 4b		      lda	(GOSUBSTACK),y
    180  1967		       85 53		      sta	R0+1
    181  1969		       c8		      iny
    182  196a		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  196c		       85 54		      sta	R1
    184  196e		       c8		      iny
    185  196f		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1971		       c8		      iny
    187  1972		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1974
    189  1974		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1976		       d0 16		      bne	ipc_deq_empty
    191  1978
    192  1978		       20 a6 1b 	      jsr	pushR0	; place value on stack
    193  197b
    194  197b		       a5 56		      lda	MQ
    195  197d		       05 57		      ora	MQ+1
    196  197f		       f0 0b		      beq	ipc_deq_done
    197  1981		       a5 54		      lda	R1
    198  1983		       a0 00		      ldy	#0
    199  1985		       91 56		      sta	(MQ),y
    200  1987		       c8		      iny
    201  1988		       a9 00		      lda	#0
    202  198a		       91 56		      sta	(MQ),y
    203  198c				   ipc_deq_done
    204  198c		       18		      clc
    205  198d		       60		      rts
    206  198e
    207  198e				   ipc_deq_empty
    208  198e		       38		      sec
    209  198f		       60		      rts
    210  1990
    211  1990							;=============================================
    212  1990							;  Get the context address into MQ from R1 with
    213  1990							;  context/index/pid
    214  1990				   ipc_getcontext
    215  1990		       18		      clc		; Get pointer to Task context
    216  1991		       a9 e2		      lda	#taskTable&$FF	; change ptr to address
    217  1993		       65 54		      adc	R1
    218  1995		       85 56		      sta	MQ
    219  1997		       a9 24		      lda	#taskTable>>8
    220  1999		       65 55		      adc	R1+1
    221  199b		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  199d		       60		      rts
    223  199e							;
    224  199e							;==============================================
    225  199e							;Push R1 onto the stack
    226  199e							;on entry y = next entry
    227  199e							;R0 points to the stack space
    228  199e							;on exit y points to next free byte
    229  199e				   ipc_pushR1
    230  199e		       88		      dey
    231  199f		       a5 55		      lda	R1+1	; PID first
    232  19a1		       91 52		      sta	(R0),y
    233  19a3		       88		      dey
    234  19a4		       a5 54		      lda	R1
    235  19a6		       91 52		      sta	(R0),y
    236  19a8		       60		      rts
    237  19a9
    238  19a9
    239  19a9
    240  19a9
    241  19a9
    242  19a9
    243  19a9
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  19a9					      include	"support.asm"
      1  19a9							;
      2  19a9							;=====================================================
      3  19a9							;=====================================================
      4  19a9							;=====================================================
      5  19a9							; This marks the start of support functions used by
      6  19a9							; the IL opcodes.  These are support functions, NOT
      7  19a9							; the IL code.
      8  19a9							;=====================================================
      9  19a9							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  19a9							;=====================================================
     11  19a9					      Seg	Code
     12  19a9							;=====================================================
     13  19a9							; This gets the next two bytes pointed to by ILPC and
     14  19a9							; returns them; X contains LSB, A contains MSB.  ILPC
     15  19a9							; is advanced by two, and Y contains 0 on return.
     16  19a9
     17  19a9							;
     18  19a9		       20 ad 19    getILWord  jsr	getILByte	;LSB
     19  19ac		       aa		      tax
     20  19ad							;
     21  19ad							;=====================================================
     22  19ad							; This gets the next byte pointed to by ILPC and
     23  19ad							; returns it in A.  On return, X is unchanged but Y
     24  19ad							; contains 0.
     25  19ad							;
     26  19ad		       a0 00	   getILByte  ldy	#0
     27  19af		       b1 43		      lda	(ILPC),y	;get byte
     28  19b1		       08		      php		;save status
     29  19b2		       e6 43		      inc	ILPC	;inc LSB
     30  19b4		       d0 02		      bne	getILb2	;branch if no overflow
     31  19b6		       e6 44		      inc	ILPC+1	;inc MSB
     32  19b8		       28	   getILb2    plp		;restore status
     33  19b9		       60		      rts
     34  19ba							;
     35  19ba							;=====================================================
     36  19ba							; Decrement ILPC by one.
     37  19ba							;
     38  19ba		       a5 43	   decIL      lda	ILPC
     39  19bc		       d0 02		      bne	decIL2
     40  19be		       c6 44		      dec	ILPC+1
     41  19c0		       c6 43	   decIL2     dec	ILPC
     42  19c2		       60		      rts
     43  19c3							;
     44  19c3							;=====================================================
     45  19c3							; Push the ILPC onto the return stack.  Actually, this
     46  19c3							; pushes the address of ILPC+2 since that's the next
     47  19c3							; address to execute.
     48  19c3							;
     49  19c3		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  19c5		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  19c7		       b0 15		      bcs	pushErr
     52  19c9		       a5 43		      lda	ILPC
     53  19cb		       18		      clc
     54  19cc		       69 02		      adc	#2
     55  19ce		       91 45		      sta	(ILSTACK),y
     56  19d0		       08		      php		;save C bit
     57  19d1		       c8		      iny
     58  19d2		       a5 44		      lda	ILPC+1
     59  19d4		       28		      plp		;restore C
     60  19d5		       69 00		      adc	#0
     61  19d7		       91 45		      sta	(ILSTACK),y
     62  19d9		       c8		      iny
     63  19da		       84 47		      sty	ILSTACKPTR
     64  19dc		       18		      clc
     65  19dd		       60		      rts
     66  19de				   pushErr
     67  19de		       38		      sec
     68  19df		       60		      rts
     69  19e0							;
     70  19e0							;=====================================================
     71  19e0							; Pull the top entry from return stack and put into
     72  19e0							; ILPC.
     73  19e0							;
     74  19e0		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  19e2		       f0 fa		      beq	pushErr
     76  19e4		       88		      dey
     77  19e5		       b1 45		      lda	(ILSTACK),y
     78  19e7		       85 44		      sta	ILPC+1
     79  19e9		       88		      dey
     80  19ea		       b1 45		      lda	(ILSTACK),y
     81  19ec		       85 43		      sta	ILPC
     82  19ee		       84 47		      sty	ILSTACKPTR
     83  19f0		       18		      clc
     84  19f1		       60		      rts
     85  19f2							;
     86  19f2							;=====================================================
     87  19f2							; This searches for a specific line number that is in
     88  19f2							; R0.	There are three possible return conditions:
     89  19f2							; Line numbers are now the third byte, the first byte is now **************
     90  19f2							; a pointer to the next line, of course no longer that 53 byte
     91  19f2							; per line.
     92  19f2							;
     93  19f2							; Exact match was found:
     94  19f2							;    * Z set
     95  19f2							;    * CURPTR points to two-byte line number for that
     96  19f2							;	line.
     97  19f2							;
     98  19f2							; Next highest line found:
     99  19f2							;    * Z cleared
    100  19f2							;    * C set
    101  19f2							;    * CURPTR points to two-byte line number for that
    102  19f2							;	line.
    103  19f2							;
    104  19f2							; End of program reached:
    105  19f2							;    * Z cleared
    106  19f2							;    * C cleared
    107  19f2							;    * CURPTR points to first free byte at end of
    108  19f2							;	program.  Ie, it has save value as PROGRAMEND.
    109  19f2							;
    110  19f2							; A, X, and Y are all undefined on return.
    111  19f2							;
    112  19f2
    113  19f2				   findLine
    114  19f2		       ad 3a 2e 	      lda	ProgramStart	;Start of program -> CURPTR
    115  19f5		       85 4f		      sta	CURPTR
    116  19f7		       ad 3b 2e 	      lda	ProgramStart+1
    117  19fa		       85 50		      sta	CURPTR+1
    118  19fc							;
    119  19fc							; At end of code?
    120  19fc							;
    121  19fc				   iXFER1
    122  19fc		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  19fe		       cd 3c 2e 	      cmp	ProgramEnd	; at end of program then stop run
    124  1a01		       d0 0b		      bne	xfer2	; not end
    125  1a03		       a5 50		      lda	CURPTR+1
    126  1a05		       cd 3d 2e 	      cmp	ProgramEnd+1
    127  1a08		       d0 04		      bne	xfer2	;Not at end
    128  1a0a							;
    129  1a0a							; Line not found and the end of the program was
    130  1a0a							; reached.  Return Z and C both clear.
    131  1a0a							;
    132  1a0a		       a9 01		      lda	#1	;clear Z
    133  1a0c		       18		      clc		;clear C
    134  1a0d		       60		      rts
    135  1a0e							;
    136  1a0e							; Check for an exact line number match
    137  1a0e							;
    138  1a0e		       a5 52	   xfer2      lda	R0
    139  1a10		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  1a12		       d1 4f		      cmp	(CURPTR),y
    141  1a14		       d0 08		      bne	xfernotit
    142  1a16		       c8		      iny
    143  1a17		       a5 53		      lda	R0+1
    144  1a19		       d1 4f		      cmp	(CURPTR),y
    145  1a1b		       d0 01		      bne	xfernotit	; not a matching line number
    146  1a1d							;
    147  1a1d							; This is exactly the line we want.
    148  1a1d							;
    149  1a1d		       60		      rts		;it matches exactly
    150  1a1e							;
    151  1a1e							; See if this line is greater than the one we're
    152  1a1e							; searching for.
    153  1a1e							;
    154  1a1e		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  1a20		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  1a22		       c5 53		      cmp	R0+1
    157  1a24		       90 0b		      bcc	xfer3
    158  1a26		       d0 07		      bne	xfer4
    159  1a28		       88		      dey
    160  1a29		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  1a2b		       c5 52		      cmp	R0
    162  1a2d		       90 02		      bcc	xfer3
    163  1a2f							;
    164  1a2f							; This line is greater than the one we want, so
    165  1a2f							; return Z clear and C set.
    166  1a2f							;
    167  1a2f		       38	   xfer4      sec		;We found a line number greater
    168  1a30		       60		      rts		;both conditions set
    169  1a31							;
    170  1a31							; Not the line (or droid) we're looking for.  Move to
    171  1a31							; the next line.
    172  1a31							;
    173  1a31		       20 37 1a    xfer3      jsr	FindNextLine
    174  1a34		       4c fc 19 	      jmp	iXFER1
    175  1a37							;
    176  1a37							;=====================================================
    177  1a37							; This advances CURPTR to the next line.  If there
    178  1a37							; are no more lines, this leaves CURPTR equal to
    179  1a37							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  1a37							; CURPTR is pointing to a valid line on entry.  This
    181  1a37							; pointer points to the two-byte line number.
    182  1a37							; Update this points to the 1 byte line length  ****************
    183  1a37							;
    184  1a37				   FindNextLine
    185  1a37		       a0 03		      ldy	#3	;skip line number and length byte
    186  1a39		       84 51		      sty	CUROFF	;this is the new offset
    187  1a3b		       a0 00		      ldy	#0
    188  1a3d		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1a3f		       18		      clc
    190  1a40		       65 4f		      adc	CURPTR
    191  1a42		       85 4f		      sta	CURPTR
    192  1a44		       a5 50		      lda	CURPTR+1
    193  1a46		       69 00		      adc	#0
    194  1a48		       85 50		      sta	CURPTR+1
    195  1a4a		       60	   FindNext4  rts
    196  1a4b							;
    197  1a4b							;=====================================================
    198  1a4b							; This compares CURPTR to PROGRAMEND and returns Z set
    199  1a4b							; if they are equal, Z clear if not.
    200  1a4b							;
    201  1a4b		       a5 4f	   AtEnd      lda	CURPTR
    202  1a4d		       cd 3c 2e 	      cmp	ProgramEnd
    203  1a50		       d0 05		      bne	atendexit
    204  1a52		       a5 50		      lda	CURPTR+1
    205  1a54		       cd 3d 2e 	      cmp	ProgramEnd+1
    206  1a57		       60	   atendexit  rts
    207  1a58							;
    208  1a58
    209  1a58							;
    210  1a58							;=====================================================
    211  1a58							; Convert an ASCII string to a number.  On input,
    212  1a58							; (CURPTR),Y points to the first digit.  This gets
    213  1a58							; digit-by-digit until finding a non-number.  Returns
    214  1a58							; Y pointing to the non-digit, and R0 contains the
    215  1a58							; number.  This does NOT check for valid ranges, so
    216  1a58							; a value like "123456789" will produce something,
    217  1a58							; but not what you had expected.
    218  1a58							;
    219  1a58		       a9 00	   getDecimal lda	#0
    220  1a5a		       85 52		      sta	R0
    221  1a5c		       85 53		      sta	R0+1
    222  1a5e		       85 59		      sta	dpl	;temporary negative flag
    223  1a60							;
    224  1a60							; See if it's negative...
    225  1a60							;
    226  1a60							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1a60		       b1 4f		      lda	(CURPTR),y
    228  1a62		       c9 2d		      cmp	#'-
    229  1a64		       d0 02		      bne	getDecLoop
    230  1a66		       e6 59		      inc	dpl	;it's negative
    231  1a68							;
    232  1a68		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  1a6a		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  1a6c		       c9 30		      cmp	#'0
    235  1a6e		       90 36		      bcc	getDdone
    236  1a70		       c9 3a		      cmp	#'9+1
    237  1a72		       b0 32		      bcs	getDdone
    238  1a74		       38		      sec
    239  1a75		       e9 30		      sbc	#'0	;convert to binary
    240  1a77		       48		      pha
    241  1a78							;
    242  1a78							; Now multiply R0 by 10.  Remember that
    243  1a78							; 2*N + 8*N = 10*N.
    244  1a78							;
    245  1a78		       06 52		      asl	R0
    246  1a7a		       26 53		      rol	R0+1	;*2
    247  1a7c		       a5 52		      lda	R0
    248  1a7e		       85 54		      sta	R1
    249  1a80		       a5 53		      lda	R0+1
    250  1a82		       85 55		      sta	R1+1
    251  1a84		       06 52		      asl	R0
    252  1a86		       26 53		      rol	R0+1	;*4
    253  1a88		       06 52		      asl	R0
    254  1a8a		       26 53		      rol	R0+1	;*8
    255  1a8c		       18		      clc		;now add the partial sums...
    256  1a8d		       a5 52		      lda	R0	;...to get *10
    257  1a8f		       65 54		      adc	R1
    258  1a91		       85 52		      sta	R0
    259  1a93		       a5 53		      lda	R0+1
    260  1a95		       65 55		      adc	R1+1
    261  1a97		       85 53		      sta	R0+1
    262  1a99							;
    263  1a99							; Add in the new digit
    264  1a99							;
    265  1a99		       68		      pla
    266  1a9a		       18		      clc
    267  1a9b		       65 52		      adc	R0
    268  1a9d		       85 52		      sta	R0
    269  1a9f		       90 02		      bcc	getD2
    270  1aa1		       e6 53		      inc	R0+1
    271  1aa3							;
    272  1aa3							; Move to next character
    273  1aa3							;
    274  1aa3		       c8	   getD2      iny
    275  1aa4		       d0 c2		      bne	getDecLoop
    276  1aa6							;
    277  1aa6							; All done with digits, so now deal with it being
    278  1aa6							; negative.  If zero, then don't check for negative
    279  1aa6							; flag.  Ie, -0 is stored as 0.
    280  1aa6							;
    281  1aa6		       a5 52	   getDdone   lda	R0
    282  1aa8		       05 53		      ora	R0+1
    283  1aaa		       f0 16		      beq	getDone2	;zero
    284  1aac		       a5 59		      lda	dpl
    285  1aae		       f0 12		      beq	getDone2	;positive
    286  1ab0							;
    287  1ab0							; Invert all the bits, then add one.
    288  1ab0							;
    289  1ab0		       a5 52		      lda	R0
    290  1ab2		       49 ff		      eor	#$ff
    291  1ab4		       85 52		      sta	R0
    292  1ab6		       a5 53		      lda	R0+1
    293  1ab8		       49 ff		      eor	#$ff
    294  1aba		       85 53		      sta	R0+1
    295  1abc							;
    296  1abc		       e6 52		      inc	R0
    297  1abe		       d0 02		      bne	getDone2
    298  1ac0		       e6 53		      inc	R0+1
    299  1ac2				   getDone2
    300  1ac2							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1ac2							;lda	  R0
    302  1ac2							;sta	  $0010
    303  1ac2							;lda	  R0+1
    304  1ac2							;sta	  $0011
    305  1ac2							;lda	  dpl
    306  1ac2							;sta	  $012
    307  1ac2
    308  1ac2		       60		      rts
    309  1ac3
    310  1ac3							;=====================================================
    311  1ac3							; Gets a line of input into LINBUF.
    312  1ac3							;
    313  1ac3							; On entry:
    314  1ac3							;    A contains the prompt character, or 0 if none.
    315  1ac3							;    X = 1 Background read
    316  1ac3							;    x = 0 Forground read with wait
    317  1ac3							;
    318  1ac3							; On exit:
    319  1ac3							;    CURPTR points to LINBUF
    320  1ac3							;    LINBUF contains the line with 0 at the end.
    321  1ac3							;    Y has offset to first non-space character
    322  1ac3							;    CURROFF has the same as Y.
    323  1ac3							;
    324  1ac3		       20 12 1b    GetLine    jsr	ReadPrompt
    325  1ac6		       e0 00		      cpx	#0
    326  1ac8		       f0 14		      beq	GetLineRetry
    327  1aca		       ae e1 24 	      ldx	taskPtr
    328  1acd		       bd e2 24 	      lda	taskTable,x
    329  1ad0		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1ad2		       d0 3d		      bne	taskWaitingIO
    331  1ad4		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1ad6		       9d e2 24 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  1ad9		       ce 11 1b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  1adc		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  1ade
    336  1ade							;
    337  1ade							; Now read a line and wait for the CR
    338  1ade							;
    339  1ade				   GetLineRetry
    340  1ade		       a9 00		      lda	#0	;Wait for input to complete
    341  1ae0		       20 2a 1b 	      jsr	ReadLine
    342  1ae3
    343  1ae3							;
    344  1ae3							; Point to the line we just read
    345  1ae3							; Set the current pointer to point to the input line
    346  1ae3							;
    347  1ae3		       a0 00	   ReadComplete ldy	#0
    348  1ae5		       84 51		      sty	CUROFF
    349  1ae7		       a2 9d		      ldx	#LINBUF&$ff
    350  1ae9		       86 4f		      stx	CURPTR
    351  1aeb		       a2 2d		      ldx	#LINBUF>>8
    352  1aed		       86 50		      stx	CURPTR+1
    353  1aef							;
    354  1aef							; Output a CR/LF
    355  1aef							;
    356  1aef		       20 e3 1c 	      jsr	CRLF
    357  1af2							;
    358  1af2							; If a blank line, prompt again.
    359  1af2							;
    360  1af2		       20 da 1c 	      jsr	SkipSpaces
    361  1af5		       b1 4f		      lda	(CURPTR),y
    362  1af7		       d0 10		      bne	GetLineDone	;We have data then exit
    363  1af9		       20 15 1b 	      jsr	ReadPromptRetry
    364  1afc		       ae e1 24 	      ldx	taskPtr	;if this task is waiting for IO
    365  1aff		       bd e2 24 	      lda	taskTable,x	;then get out, wait for line to
    366  1b02		       29 40		      and	#TASKWAITIO	;Complete again
    367  1b04		       d0 0b		      bne	taskWaitingIO
    368  1b06		       4c de 1a 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  1b09
    370  1b09				   GetLineDone
    371  1b09		       ae e1 24 	      ldx	taskPtr
    372  1b0c		       a9 80		      lda	#TASKACTIVE
    373  1b0e		       9d e2 24 	      sta	taskTable,x	;IO is complete
    374  1b11
    375  1b11				   taskWaitingIO
    376  1b11		       60		      rts
    377  1b12
    378  1b12							;
    379  1b12							;=======================================================================
    380  1b12							; Display the prompt character
    381  1b12							; On entry
    382  1b12							;	    A contains the prompt character
    383  1b12							; On exit
    384  1b12							;	    The readbuffer index is reset to 0
    385  1b12							;
    386  1b12		       8d 24 2e    ReadPrompt sta	promptChar
    387  1b15
    388  1b15							;
    389  1b15							; Prompt
    390  1b15							;
    391  1b15
    392  1b15		       ad 24 2e    ReadPromptRetry lda	promptChar
    393  1b18		       09 00		      ora	#0	;any prompt?
    394  1b1a		       f0 08		      beq	getlinenp
    395  1b1c		       20 2c 1e 	      jsr	VOUTCH
    396  1b1f		       a9 20		      lda	#$20
    397  1b21		       20 2c 1e 	      jsr	VOUTCH	;Space after prompt
    398  1b24							;
    399  1b24		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  1b26		       8e 21 2e 	      stx	getlinx
    401  1b29		       60		      rts
    402  1b2a							;
    403  1b2a							;===============================================================
    404  1b2a							; This fuction is the driver for the line input
    405  1b2a							; on call if a = 0 then it waits for all input
    406  1b2a							;	      a = 1 then nowait for input
    407  1b2a							; On exit
    408  1b2a							;		       c clear if not complete line
    409  1b2a							;		       c set if it was a complete line
    410  1b2a
    411  1b2a				   ReadLine
    412  1b2a		       8d 23 2e 	      sta	inputNoWait
    413  1b2d		       c9 00		      cmp	#0
    414  1b2f		       f0 05		      beq	getline1
    415  1b31		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  1b34		       f0 2b		      beq	GetLineNoWait
    417  1b36		       20 2f 1e    getline1   jsr	VGETCH
    418  1b39					      if	CTMON65
    419  1b39		       48		      pha
    420  1b3a		       20 2c 1e 	      jsr	VOUTCH	;echo echo echo
    421  1b3d		       68		      pla
    422  1b3e					      endif
    423  1b3e		       c9 0d		      cmp	#CR
    424  1b40		       f0 15		      beq	getlind	;end of line
    425  1b42		       c9 08		      cmp	#BS	;backspace?
    426  1b44		       f0 1d		      beq	getlinebs
    427  1b46		       ae 21 2e 	      ldx	getlinx
    428  1b49		       9d 9d 2d 	      sta	LINBUF,x
    429  1b4c		       e8		      inx
    430  1b4d		       8e 21 2e 	      stx	getlinx
    431  1b50		       ad 23 2e 	      lda	inputNoWait
    432  1b53		       f0 e1		      beq	getline1
    433  1b55		       d0 0a		      bne	GetLineNoWait
    434  1b57							;
    435  1b57							; CR was hit
    436  1b57							;
    437  1b57		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  1b59		       ae 21 2e 	      ldx	getlinx
    439  1b5c		       9d 9d 2d 	      sta	LINBUF,x
    440  1b5f
    441  1b5f		       38		      sec		; Carry set then cr received
    442  1b60		       60		      rts
    443  1b61
    444  1b61				   GetLineNoWait
    445  1b61		       18		      clc		; Carry clear no end of line
    446  1b62		       60		      rts
    447  1b63							;
    448  1b63							; Backspace was hit
    449  1b63							;
    450  1b63		       ae 21 2e    getlinebs  ldx	getlinx
    451  1b66		       f0 0e		      beq	getlineEOL	;at start of line
    452  1b68		       ca		      dex
    453  1b69		       8e 21 2e 	      stx	getlinx
    454  1b6c		       20 59 14    getlinepbs jsr	puts
      0  1b6f					      db	27,"[K",0
      1  1b6f		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1b73		       4c 36 1b 	      jmp	getline1
    457  1b76		       a9 20	   getlineEOL lda	#SPACE
    458  1b78		       20 2c 1e 	      jsr	VOUTCH
    459  1b7b		       d0 ef		      bne	getlinepbs
    460  1b7d							;
    461  1b7d							;=====================================================
    462  1b7d							; Count the length of the line currently in LINBUF
    463  1b7d							; starting at offset Y.  Returns the length in X.  The
    464  1b7d							; starting offset in Y should point past the ASCII
    465  1b7d							; line number.  Also counts the trailing NULL and two
    466  1b7d							; extra bytes for where the line number will be.
    467  1b7d							; Update must now include leading length byte not the null at end ****************
    468  1b7d							;
    469  1b7d				   getLineLength
    470  1b7d		       a2 00		      ldx	#0	;size
    471  1b7f		       b9 9d 2d    getLineL2  lda	LINBUF,y
    472  1b82		       f0 04		      beq	getLineL3
    473  1b84		       c8		      iny
    474  1b85		       e8		      inx
    475  1b86		       d0 f7		      bne	getLineL2
    476  1b88		       e8	   getLineL3  inx		;count null at end
    477  1b89		       e8		      inx		;line number LSB
    478  1b8a		       e8		      inx		;MSB
    479  1b8b		       e8		      inx		;change: count new leading line length
    480  1b8c		       8e 37 2e 	      stx	lineLength
    481  1b8f		       60		      rts
    482  1b90							;
    483  1b90							;=====================================================
    484  1b90							; Count the length of the line pointed to by CURPTR.
    485  1b90							; This also counts the line number and the terminating
    486  1b90							; null.  Ie, this string returns 8:
    487  1b90							;
    488  1b90							; <lineLow><lineHi>Hello<null>
    489  1b90							;
    490  1b90							; Another way of looking at it: add the return value
    491  1b90							; to the CURPTR and it'll point to the next line's
    492  1b90							; line number.  Returns the value in Y.
    493  1b90							; Update to ject get the leading byte length ********************
    494  1b90							;
    495  1b90							;getCURPTRLength
    496  1b90							;		ldy	CURPTR
    497  1b90							;		ldy	#3	;change: skip line number and leading length byte
    498  1b90							;getCLineL2	lda	(CURPTR),y
    499  1b90							;		beq	getCLineL3
    500  1b90							;		iny
    501  1b90							;		bne	getCLineL2
    502  1b90							;getCLineL3	iny		;count null at end
    503  1b90							;		rts
    504  1b90
    505  1b90							;
    506  1b90							;=====================================================
    507  1b90							; This saves ILPC.  This saves to a single save area,
    508  1b90							; so it can't be called more than once.
    509  1b90							;
    510  1b90		       a5 43	   saveIL     lda	ILPC
    511  1b92		       8d 33 2e 	      sta	tempIL
    512  1b95		       a5 44		      lda	ILPC+1
    513  1b97		       8d 34 2e 	      sta	tempIL+1
    514  1b9a		       60		      rts
    515  1b9b							;
    516  1b9b							;=====================================================
    517  1b9b							; This restores ILPC.
    518  1b9b							;
    519  1b9b		       ad 33 2e    restoreIL  lda	tempIL
    520  1b9e		       85 43		      sta	ILPC
    521  1ba0		       ad 34 2e 	      lda	tempIL+1
    522  1ba3		       85 44		      sta	ILPC+1
    523  1ba5		       60		      rts
    524  1ba6							;
    525  1ba6							;=====================================================
    526  1ba6							; This pushes R0 onto the stack.
    527  1ba6							;
    528  1ba6		       8c 2a 2e    pushR0     sty	rtemp1
    529  1ba9		       a4 4a		      ldy	MATHSTACKPTR
    530  1bab		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  1bad		       b0 34		      bcs	pusherr
    532  1baf		       a5 52		      lda	R0
    533  1bb1		       91 48		      sta	(MATHSTACK),y
    534  1bb3		       c8		      iny
    535  1bb4		       a5 53		      lda	R0+1
    536  1bb6		       91 48		      sta	(MATHSTACK),y
    537  1bb8		       c8		      iny
    538  1bb9		       84 4a		      sty	MATHSTACKPTR
    539  1bbb		       ac 2a 2e 	      ldy	rtemp1
    540  1bbe		       18		      clc
    541  1bbf		       60		      rts
    542  1bc0
    543  1bc0							;=====================================================
    544  1bc0							; This pushes curptr basic current line onto the call stack.
    545  1bc0							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1bc0
    547  1bc0				   pushLN
    548  1bc0		       8c 2a 2e 	      sty	rtemp1
    549  1bc3		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  1bc5		       c5 4d		      cmp	GOSUBSTACKPTR
    551  1bc7		       90 1a		      bcc	pusherr	; No error
    552  1bc9		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  1bcb		       a2 00		      ldx	#0	; Start of bytes to copy
    554  1bcd				   pushLoop
    555  1bcd		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  1bcf		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  1bd1		       c8		      iny		; Next destination
    558  1bd2		       e8		      inx		; Next Source byte
    559  1bd3		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  1bd5		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  1bd7
    562  1bd7		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  1bd9		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  1bdb		       c8		      iny		; Next entry
    565  1bdc
    566  1bdc		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  1bde		       ac 2a 2e 	      ldy	rtemp1
    568  1be1		       18		      clc
    569  1be2		       60		      rts
    570  1be3				   pusherr
    571  1be3		       38		      sec
    572  1be4		       60		      rts
    573  1be5							;=====================================================
    574  1be5							; This pops Top Off gosub call Stack and
    575  1be5							; places it in CURPTR/CUROFF.
    576  1be5							; This checks if the type = 1 GOSUB
    577  1be5							; if not it removes what ever is on the stack
    578  1be5							; until it finds the next return. Allowing
    579  1be5							; a return from within a for/next
    580  1be5		       8c 2a 2e    popLN      sty	rtemp1
    581  1be8		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  1bea		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  1bec
    584  1bec				   popContinue
    585  1bec		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  1bee		       90 18		      bcc	poperr	; Process an error
    587  1bf0
    588  1bf0		       88		      dey		; Position to read entry type
    589  1bf1		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  1bf3		       c9 01		      cmp	#1	; Type is a gosub entry
    591  1bf5		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  1bf7
    593  1bf7				   popLoop
    594  1bf7		       88		      dey
    595  1bf8		       ca		      dex
    596  1bf9		       b1 4b		      lda	(GOSUBSTACK),y
    597  1bfb		       95 4f		      sta	CURPTR,x
    598  1bfd		       e0 00		      cpx	#0
    599  1bff		       d0 f6		      bne	popLoop	; Loop until all moved
    600  1c01
    601  1c01
    602  1c01		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  1c03		       ac 2a 2e 	      ldy	rtemp1
    604  1c06		       18		      clc
    605  1c07		       60		      rts
    606  1c08
    607  1c08		       38	   poperr     sec
    608  1c09		       60		      rts
    609  1c0a
    610  1c0a		       88	   popSkipEntry dey
    611  1c0b		       88		      dey
    612  1c0c		       88		      dey
    613  1c0d		       4c ec 1b 	      jmp	popContinue
    614  1c10
    615  1c10							;
    616  1c10							;=====================================================
    617  1c10							; This pushes R1 onto the stack
    618  1c10							;
    619  1c10		       8c 2a 2e    pushR1     sty	rtemp1
    620  1c13		       a4 4a		      ldy	MATHSTACKPTR
    621  1c15		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  1c17		       b0 ef		      bcs	poperr
    623  1c19		       a5 54		      lda	R1
    624  1c1b		       91 48		      sta	(MATHSTACK),y
    625  1c1d		       c8		      iny
    626  1c1e		       a5 55		      lda	R1+1
    627  1c20		       91 48		      sta	(MATHSTACK),y
    628  1c22		       c8		      iny
    629  1c23		       84 4a		      sty	MATHSTACKPTR
    630  1c25		       ac 2a 2e 	      ldy	rtemp1
    631  1c28		       18		      clc
    632  1c29		       60		      rts
    633  1c2a							;
    634  1c2a							;=====================================================
    635  1c2a							; This pops Top Of Stack and places it in R0.
    636  1c2a							;
    637  1c2a		       8c 2a 2e    popR0      sty	rtemp1
    638  1c2d		       a4 4a		      ldy	MATHSTACKPTR
    639  1c2f		       f0 d7		      beq	poperr
    640  1c31		       88		      dey
    641  1c32		       b1 48		      lda	(MATHSTACK),y
    642  1c34		       85 53		      sta	R0+1
    643  1c36		       88		      dey
    644  1c37		       b1 48		      lda	(MATHSTACK),y
    645  1c39		       85 52		      sta	R0
    646  1c3b		       84 4a		      sty	MATHSTACKPTR
    647  1c3d		       ac 2a 2e 	      ldy	rtemp1
    648  1c40		       18		      clc
    649  1c41		       60		      rts
    650  1c42
    651  1c42							;
    652  1c42							;=====================================================
    653  1c42							; This pops TOS and places it in R1.
    654  1c42							;
    655  1c42		       8c 2a 2e    popR1      sty	rtemp1
    656  1c45		       a4 4a		      ldy	MATHSTACKPTR
    657  1c47		       f0 bf		      beq	poperr
    658  1c49		       88		      dey
    659  1c4a		       b1 48		      lda	(MATHSTACK),y
    660  1c4c		       85 55		      sta	R1+1
    661  1c4e		       88		      dey
    662  1c4f		       b1 48		      lda	(MATHSTACK),y
    663  1c51		       85 54		      sta	R1
    664  1c53		       84 4a		      sty	MATHSTACKPTR
    665  1c55		       ac 2a 2e 	      ldy	rtemp1
    666  1c58		       60		      rts
    667  1c59							;
    668  1c59							;=====================================================
    669  1c59							; This pops TOS and places it in MQ.
    670  1c59							;
    671  1c59		       8c 2a 2e    popMQ      sty	rtemp1
    672  1c5c		       a4 4a		      ldy	MATHSTACKPTR
    673  1c5e		       f0 a8		      beq	poperr
    674  1c60		       88		      dey
    675  1c61		       b1 48		      lda	(MATHSTACK),y
    676  1c63		       85 57		      sta	MQ+1
    677  1c65		       88		      dey
    678  1c66		       b1 48		      lda	(MATHSTACK),y
    679  1c68		       85 56		      sta	MQ
    680  1c6a		       84 4a		      sty	MATHSTACKPTR
    681  1c6c		       ac 2a 2e 	      ldy	rtemp1
    682  1c6f		       60		      rts
    683  1c70							;
    684  1c70							;=====================================================
    685  1c70							; This assists with multiplication and division by
    686  1c70							; looking at R0 and R1 and saving a flag as to what
    687  1c70							; sign the result will be.  Math is always done on
    688  1c70							; positive numbers, so this converts negative numbers
    689  1c70							; into positives.  On exit, R0 and R1 are both
    690  1c70							; positive.  If the signs were different then 'signs'
    691  1c70							; will be non-zero.
    692  1c70							;
    693  1c70		       a9 00	   SaveSigns  lda	#0
    694  1c72		       8d 29 2e 	      sta	sign	;assume positive
    695  1c75		       a5 53		      lda	R0+1	;MSB
    696  1c77		       10 13		      bpl	SaveSigns1
    697  1c79		       ee 29 2e 	      inc	sign	;it's negative
    698  1c7c		       49 ff		      eor	#$ff	;flip bits
    699  1c7e		       85 53		      sta	R0+1
    700  1c80		       a5 52		      lda	R0
    701  1c82		       49 ff		      eor	#$ff
    702  1c84		       85 52		      sta	R0
    703  1c86		       e6 52		      inc	R0
    704  1c88		       d0 02		      bne	SaveSigns1
    705  1c8a		       e6 53		      inc	R0+1
    706  1c8c		       a5 55	   SaveSigns1 lda	R1+1
    707  1c8e		       10 1a		      bpl	SaveSigns2
    708  1c90		       48		      pha
    709  1c91		       ad 29 2e 	      lda	sign
    710  1c94		       49 01		      eor	#1
    711  1c96		       8d 29 2e 	      sta	sign
    712  1c99		       68		      pla
    713  1c9a		       49 ff		      eor	#$ff	;flip bits
    714  1c9c		       85 55		      sta	R1+1
    715  1c9e		       a5 54		      lda	R1
    716  1ca0		       49 ff		      eor	#$ff
    717  1ca2		       85 54		      sta	R1
    718  1ca4		       e6 54		      inc	R1
    719  1ca6		       d0 02		      bne	SaveSigns2
    720  1ca8		       e6 55		      inc	R1+1
    721  1caa		       60	   SaveSigns2 rts
    722  1cab							;
    723  1cab							;=====================================================
    724  1cab							; This looks at the value of 'signs' and will convert
    725  1cab							; both R0 and R1 to negative if set.
    726  1cab							;
    727  1cab				   RestoreSigns
    728  1cab		       ad 29 2e 	      lda	sign
    729  1cae		       f0 28		      beq	restoresigns2
    730  1cb0							;
    731  1cb0		       a5 52		      lda	R0
    732  1cb2		       d0 02		      bne	restoresigns3
    733  1cb4		       c6 53		      dec	R0+1
    734  1cb6				   restoresigns3
    735  1cb6		       c6 52		      dec	R0
    736  1cb8		       a5 52		      lda	R0
    737  1cba		       49 ff		      eor	#$ff
    738  1cbc		       85 52		      sta	R0
    739  1cbe		       a5 53		      lda	R0+1
    740  1cc0		       49 ff		      eor	#$ff
    741  1cc2		       85 53		      sta	R0+1
    742  1cc4							;
    743  1cc4		       a5 54		      lda	R1
    744  1cc6		       d0 02		      bne	restoresigns4
    745  1cc8		       c6 55		      dec	R1+1
    746  1cca				   restoresigns4
    747  1cca		       c6 54		      dec	R1
    748  1ccc		       a5 54		      lda	R1
    749  1cce		       49 ff		      eor	#$ff
    750  1cd0		       85 54		      sta	R1
    751  1cd2		       a5 55		      lda	R1+1
    752  1cd4		       49 ff		      eor	#$ff
    753  1cd6		       85 55		      sta	R1+1
    754  1cd8							;
    755  1cd8				   restoresigns2
    756  1cd8		       60		      rts
    757  1cd9							;
    758  1cd9							;=====================================================
    759  1cd9							; Skip over spaces.  Returns Y with the offset to
    760  1cd9							; either the last character in the line, or the first
    761  1cd9							; non-space character.
    762  1cd9							;
    763  1cd9
    764  1cd9		       c8	   skipsp2    iny
    765  1cda		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  1cdc		       f0 04		      beq	Skip3	;end of line
    767  1cde		       c9 20		      cmp	#SPACE
    768  1ce0		       f0 f7		      beq	skipsp2
    769  1ce2		       60	   Skip3      rts
    770  1ce3							;*********************************************************
    771  1ce3							; Output a CR/LF combination to the console.  Preserves
    772  1ce3							; all registers.
    773  1ce3							;
    774  1ce3		       48	   tbcrlf     pha
    775  1ce4		       a9 0d		      lda	#CR
    776  1ce6		       20 2c 1e 	      jsr	VOUTCH
    777  1ce9		       a9 0a		      lda	#LF
    778  1ceb		       20 2c 1e 	      jsr	VOUTCH
    779  1cee		       68		      pla
    780  1cef		       60		      rts
    781  1cf0							;
    782  1cf0							;=====================================================
    783  1cf0							; Some logic to print the Line of basic code being executed
    784  1cf0		       24 40	   idbgBasic  bit	ILTrace
    785  1cf2		       50 70		      bvc	dbgBasicNone
    786  1cf4		       98		      tya
    787  1cf5		       48		      pha
    788  1cf6		       20 60 1e 	      jsr	SetOutDebug
    789  1cf9		       20 7c 14 	      jsr	PrtPrgLine
    790  1cfc		       20 e3 1c 	      jsr	CRLF
    791  1cff		       a5 40		      lda	ILTrace
    792  1d01		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  1d03		       f0 5a		      beq	dbgBasicDone
    794  1d05		       20 77 1e 	      jsr	SetInDebug
    795  1d08		       20 59 14 	      jsr	puts
      0  1d0b					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1d0b		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1d48				   dbgBasicLoop
    798  1d48		       20 2f 1e 	      jsr	VGETCH
    799  1d4b		       20 e3 1c 	      jsr	CRLF
    800  1d4e		       20 9b 1e 	      jsr	SetInDebugEnd
    801  1d51
    802  1d51		       c9 73		      cmp	#'s	; Quit program
    803  1d53		       f0 12		      beq	dbgBasicStop
    804  1d55
    805  1d55		       c9 64		      cmp	#'d	; Display Variables
    806  1d57		       d0 06		      bne	dbgBasicDone
    807  1d59
    808  1d59		       20 bb 14 	      jsr	PrintAllVars
    809  1d5c		       18		      clc
    810  1d5d		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1d5f
    812  1d5f		       20 8e 1e    dbgBasicDone jsr	SetOutDebugEnd
    813  1d62		       68		      pla
    814  1d63		       a8		      tay
    815  1d64		       4c c2 02    dbgBasicNone jmp	NextIL
    816  1d67
    817  1d67				   dbgBasicStop
    818  1d67		       20 8e 1e 	      jsr	SetOutDebugEnd
    819  1d6a		       68		      pla
    820  1d6b		       a8		      tay
    821  1d6c		       4c 09 06 	      jmp	iFIN
    822  1d6f							;
    823  1d6f							;=====================================================
    824  1d6f							; This is some debug logic which displays the current
    825  1d6f							; value of the ILPC and the line buffer.
    826  1d6f							;
    827  1d6f		       24 40	   dbgLine    bit	ILTrace
    828  1d71		       30 01		      bmi	dbgPrt
    829  1d73		       60		      rts
    830  1d74				   dbgPrt
    831  1d74		       20 60 1e 	      jsr	SetOutDebug
    832  1d77		       20 59 14 	      jsr	puts
      0  1d7a					      db	"ILPC: ",0
      1  1d7a		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  1d81		       a5 44		      lda	ILPC+1
    835  1d83		       20 3c 14 	      jsr	OUTHEX
    836  1d86		       a5 43		      lda	ILPC
    837  1d88		       20 3c 14 	      jsr	OUTHEX
    838  1d8b		       a9 20		      lda	#SPACE
    839  1d8d		       20 2c 1e 	      jsr	VOUTCH
    840  1d90		       a0 00		      ldy	#0
    841  1d92		       b1 43		      lda	(ILPC),y
    842  1d94		       20 3c 14 	      jsr	OUTHEX
    843  1d97							;
    844  1d97							; Display the CURPTR value and offset
    845  1d97							;
    846  1d97		       20 59 14 	      jsr	puts
      0  1d9a					      db	", CURPTR: ",0
      1  1d9a		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  1da5		       a5 50		      lda	CURPTR+1
    849  1da7		       20 3c 14 	      jsr	OUTHEX
    850  1daa		       a5 4f		      lda	CURPTR
    851  1dac		       20 3c 14 	      jsr	OUTHEX
    852  1daf		       a9 2b		      lda	#'+
    853  1db1		       20 2c 1e 	      jsr	VOUTCH
    854  1db4		       a5 51		      lda	CUROFF
    855  1db6		       20 3c 14 	      jsr	OUTHEX
    856  1db9							;
    857  1db9		       20 e3 1c 	      jsr	CRLF
    858  1dbc		       20 8e 1e 	      jsr	SetOutDebugEnd
    859  1dbf		       20 f2 1d 	      jsr	ILChkRange
    860  1dc2		       b0 02		      bcs	dbgLineErr
    861  1dc4		       18		      clc
    862  1dc5		       60		      rts
    863  1dc6
    864  1dc6				   dbgLineErr
    865  1dc6		       20 60 1e 	      jsr	SetOutDebug
    866  1dc9		       20 59 14 	      jsr	puts
      0  1dcc					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1dcc		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  1ded		       20 8e 1e 	      jsr	SetOutDebugEnd
    869  1df0		       38		      sec
    870  1df1		       60		      rts
    871  1df2
    872  1df2		       a5 44	   ILChkRange lda	ILPC+1
    873  1df4		       c9 20		      cmp	#IL>>8
    874  1df6		       90 18		      bcc	ILBadRange
    875  1df8		       d0 06		      bne	ILChkHigh
    876  1dfa
    877  1dfa		       a5 43		      lda	ILPC
    878  1dfc		       c9 cb		      cmp	#IL&$ff
    879  1dfe		       90 10		      bcc	ILBadRange
    880  1e00
    881  1e00		       a5 44	   ILChkHigh  lda	ILPC+1
    882  1e02		       c9 24		      cmp	#ILEND>>8
    883  1e04		       90 08		      bcc	ILGoodRange
    884  1e06		       d0 08		      bne	ILBadRange
    885  1e08
    886  1e08		       a5 43		      lda	ILPC
    887  1e0a		       c9 9a		      cmp	#ILEND&$ff
    888  1e0c		       b0 02		      bcs	ILBadRange
    889  1e0e
    890  1e0e		       18	   ILGoodRange clc
    891  1e0f		       60		      rts
    892  1e10				   ILBadRange
    893  1e10		       38		      sec
    894  1e11		       60		      rts
    895  1e12
    896  1e12
    897  1e12							;=====================================================
    898  1e12							; Set output vector to the console output function
    899  1e12							;
    900  1e12				   SetOutConsole
    901  1e12		       48		      pha
    902  1e13		       a9 0c		      lda	#OUTCH&$ff
    903  1e15		       8d 2e 2e 	      sta	BOutVec
    904  1e18		       a9 f0		      lda	#OUTCH>>8
    905  1e1a		       8d 2f 2e 	      sta	BOutVec+1
    906  1e1d		       68		      pla
    907  1e1e		       60		      rts
    908  1e1f
    909  1e1f				   SetInConsole
    910  1e1f		       48		      pha
    911  1e20		       a9 09		      lda	#GETCH&$ff
    912  1e22		       8d 30 2e 	      sta	BInVec
    913  1e25		       a9 f0		      lda	#GETCH>>8
    914  1e27		       8d 31 2e 	      sta	BInVec+1
    915  1e2a		       68		      pla
    916  1e2b		       60		      rts
    917  1e2c
    918  1e2c							;=====================================================
    919  1e2c							; Jump to the output/input function in BOutVec/BInVec
    920  1e2c							;
    921  1e2c		       6c 2e 2e    VOUTCH     jmp	(BOutVec)
    922  1e2f		       6c 30 2e    VGETCH     jmp	(BInVec)
    923  1e32
    924  1e32
    925  1e32							;====================================================
    926  1e32							;Clear the terminal assume it is ansii or vt100
    927  1e32							;
    928  1e32				   iCLEARSCREEN
    929  1e32		       20 59 14 	      jsr	puts
      0  1e35					      db	$1b,'[,'2,'J,0
      1  1e35		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    931  1e3a		       4c c2 02 	      jmp	NextIL
    932  1e3d
    933  1e3d							;====================================================
    934  1e3d							; Push true and false onto math stack
    935  1e3d				   pushTrue
    936  1e3d		       a9 ff		      lda	#$ff
    937  1e3f		       85 52	   pushTF     sta	R0
    938  1e41		       85 53		      sta	R0+1
    939  1e43		       20 a6 1b 	      jsr	pushR0
    940  1e46		       60		      rts
    941  1e47		       a9 00	   pushFalse  lda	#0
    942  1e49		       f0 f4		      beq	pushTF
    943  1e4b
    944  1e4b							;======================================================
    945  1e4b							; Copy stack top to R1
    946  1e4b				   CopyStackR1
    947  1e4b		       98		      tya
    948  1e4c		       48		      pha
    949  1e4d		       a4 4a		      ldy	MATHSTACKPTR
    950  1e4f		       88		      dey
    951  1e50		       b1 48		      lda	(MATHSTACK),y
    952  1e52		       85 55		      sta	R1+1
    953  1e54		       88		      dey
    954  1e55		       b1 48		      lda	(MATHSTACK),y
    955  1e57		       85 54		      sta	R1
    956  1e59		       68		      pla
    957  1e5a		       a8		      tay
    958  1e5b		       60		      rts
    959  1e5c
    960  1e5c
    961  1e5c							;====================================================
    962  1e5c							;Swap the out debug call for standard calls
    963  1e5c					      if	USEDEBUGPORT
    964  1e5c		       00 00	   DebugIOSave ds	2
    965  1e5e		       00 00	   DebugInSave ds	2
    966  1e60					      endif
    967  1e60				   SetOutDebug
    968  1e60					      if	USEDEBUGPORT
    969  1e60		       ad 2e 2e 	      lda	BOutVec
    970  1e63		       8d 5c 1e 	      sta	DebugIOSave
    971  1e66		       ad 2f 2e 	      lda	BOutVec+1
    972  1e69		       8d 5d 1e 	      sta	DebugIOSave+1
    973  1e6c		       a9 b2		      lda	#OUTDEBUG&$ff	; Put the Debug output
    974  1e6e		       8d 2e 2e 	      sta	BOutVec
    975  1e71		       a9 1e		      lda	#OUTDEBUG>>8
    976  1e73		       8d 2f 2e 	      sta	BOutVec+1
    977  1e76					      endif
    978  1e76		       60		      rts
    979  1e77				   SetInDebug
    980  1e77					      if	USEDEBUGPORT
    981  1e77		       ad 30 2e 	      lda	BInVec
    982  1e7a		       8d 5e 1e 	      sta	DebugInSave
    983  1e7d		       ad 31 2e 	      lda	BInVec+1
    984  1e80		       8d 5f 1e 	      sta	DebugInSave+1
    985  1e83		       a9 b6		      lda	#INDEBUG&$ff
    986  1e85		       8d 30 2e 	      sta	BInVec
    987  1e88		       a9 1e		      lda	#INDEBUG>>8
    988  1e8a		       8d 31 2e 	      sta	BInVec+1
    989  1e8d					      endif
    990  1e8d		       60		      rts
    991  1e8e				   SetOutDebugEnd
    992  1e8e					      if	USEDEBUGPORT
    993  1e8e		       ad 5c 1e 	      lda	DebugIOSave
    994  1e91		       8d 2e 2e 	      sta	BOutVec
    995  1e94		       ad 5d 1e 	      lda	DebugIOSave+1
    996  1e97		       8d 2f 2e 	      sta	BOutVec+1
    997  1e9a					      endif
    998  1e9a		       60		      rts
    999  1e9b				   SetInDebugEnd
   1000  1e9b					      if	USEDEBUGPORT
   1001  1e9b		       ad 5e 1e 	      lda	DebugInSave
   1002  1e9e		       8d 30 2e 	      sta	BInVec
   1003  1ea1		       ad 5d 1e 	      lda	DebugIOSave+1
   1004  1ea4		       8d 31 2e 	      sta	BInVec+1
   1005  1ea7					      endif
   1006  1ea7		       60		      rts
   1007  1ea8							;
   1008  1ea8							;====================================================
   1009  1ea8							; Output to the debug console
   1010  1ea8							;     x = high address byte
   1011  1ea8							;     y = low address byte
   1012  1ea8							;     a = Terminator for string
   1013  1ea8				   DebugWrite
   1014  1ea8		       20 60 1e 	      jsr	SetOutDebug
   1015  1eab		       20 9e 14 	      jsr	PrtStr
   1016  1eae		       20 8e 1e 	      jsr	SetOutDebugEnd
   1017  1eb1		       60		      rts
   1018  1eb2
   1019  1eb2				   OUTDEBUG
   1020  1eb2		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1021  1eb5		       60		      RTS
   1022  1eb6
   1023  1eb6		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1024  1eb9		       29 01		      and	#$01
   1025  1ebb		       f0 f9		      beq	INDEBUG
   1026  1ebd		       ad 21 e0 	      lda	DEBUGPORT+1
   1027  1ec0		       60		      rts
   1028  1ec1
   1029  1ec1							;======================================================================
   1030  1ec1							;Copy Quoted string to buffer, terminate with 0 byte
   1031  1ec1							; R0  Source tring points to tString type
   1032  1ec1							; x is terminator
   1033  1ec1							; R1 points to destinition location
   1034  1ec1							; On exit R0 contains length of copy Plus Term and leading bytes
   1035  1ec1
   1036  1ec1				   qstrcpy
   1037  1ec1		       20 a6 1b 	      jsr	pushR0
   1038  1ec4		       20 11 1f 	      jsr	IncR0	; point past the tString
   1039  1ec7		       20 11 1f 	      jsr	IncR0	; Point Past the opening "
   1040  1eca		       a2 22		      ldx	#'"	; copy Termination
   1041  1ecc		       20 e6 1e 	      jsr	pstrcpy
   1042  1ecf		       20 11 1f 	      jsr	IncR0	; point to "
   1043  1ed2		       20 11 1f 	      jsr	IncR0	; Point to next free byte
   1044  1ed5		       20 42 1c 	      jsr	popR1
   1045  1ed8		       38		      sec
   1046  1ed9		       a5 52		      lda	R0
   1047  1edb		       e5 54		      sbc	R1
   1048  1edd		       85 52		      sta	R0
   1049  1edf		       a5 53		      lda	R0+1
   1050  1ee1		       e5 55		      sbc	R1+1
   1051  1ee3		       85 53		      sta	R0+1
   1052  1ee5		       60		      rts
   1053  1ee6
   1054  1ee6							;=========================================================================
   1055  1ee6							;Copy string from R0 to R1, terminator in x
   1056  1ee6							; On exit    R0 contains the length of the copy
   1057  1ee6				   pstrcpy
   1058  1ee6		       a0 00		      ldy	#0
   1059  1ee8		       86 58		      stx	R2
   1060  1eea
   1061  1eea				   strcpyLoop
   1062  1eea		       b1 52		      lda	(R0),y
   1063  1eec		       c5 58		      cmp	R2
   1064  1eee		       f0 0a		      beq	strcpyDone
   1065  1ef0		       91 54		      sta	(R1),y
   1066  1ef2		       20 11 1f 	      jsr	IncR0
   1067  1ef5		       20 ff 1e 	      jsr	IncR1
   1068  1ef8		       90 f0		      bcc	strcpyLoop
   1069  1efa				   strcpyDone
   1070  1efa		       a9 00		      lda	#0
   1071  1efc		       91 54		      sta	(R1),y
   1072  1efe
   1073  1efe		       60		      rts
   1074  1eff
   1075  1eff							;=========================================================================
   1076  1eff							; on exit c is set on overflow
   1077  1eff				   IncR1
   1078  1eff		       48		      pha
   1079  1f00		       18		      clc
   1080  1f01		       a9 01		      lda	#1
   1081  1f03		       65 54		      adc	R1
   1082  1f05		       85 54		      sta	R1
   1083  1f07		       90 06		      bcc	IncR1Done
   1084  1f09		       a9 00		      lda	#0
   1085  1f0b		       65 55		      adc	R1+1
   1086  1f0d		       85 55		      sta	R1+1
   1087  1f0f				   IncR1Done
   1088  1f0f		       68		      pla
   1089  1f10		       60		      rts
   1090  1f11							;=========================================================================
   1091  1f11							; on exit c is set on overflow
   1092  1f11				   IncR0
   1093  1f11		       48		      pha
   1094  1f12		       18		      clc
   1095  1f13		       a9 01		      lda	#1
   1096  1f15		       65 52		      adc	R0
   1097  1f17		       85 52		      sta	R0
   1098  1f19		       90 06		      bcc	IncR0Done
   1099  1f1b		       a9 00		      lda	#0
   1100  1f1d		       65 53		      adc	R0+1
   1101  1f1f		       85 53		      sta	R0+1
   1102  1f21				   IncR0Done
   1103  1f21		       68		      pla
   1104  1f22		       60		      rts
   1105  1f23
   1106  1f23
   1107  1f23
   1108  1f23
   1109  1f23
   1110  1f23
   1111  1f23
   1112  1f23
   1113  1f23
   1114  1f23
   1115  1f23
   1116  1f23
   1117  1f23
   1118  1f23
   1119  1f23
   1120  1f23
------- FILE mytb.asm
   2317  1f23
   2318  1f23					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  1f23					      include	"storage.asm"
      1  1f23							;
      2  1f23							;=====================================================
      3  1f23							;=====================================================
      4  1f23							;=====================================================
      5  1f23							; This file contains the functions for saving and
      6  1f23							; restoring programs from some sort of mass storage
      7  1f23							; device.  This particular version is for using the
      8  1f23							; Corsham Tech SD Card System.
      9  1f23							;=====================================================
     10  1f23							;=====================================================
     11  1f23							;=====================================================
     12  1f23
     13 U249a					      seg.u	TBData
     14 U249a		       00	   diskBufLength ds	1
     15 U249b		       00	   diskBufOffset ds	1
     16 U249c		       00 00 00 00*DiskFileName ds	64
     17 U24dc
     18  1f23					      SEG	Code
     19  1f23
     20  1f23							;
     21  1f23							;=====================================================
     22  1f23							; Open a file for reading as a program.  The next
     23  1f23							; thing on the line should be the filename.
     24  1f23							;
     25  1f23				   iOPENREAD
     26  1f23					      if	XKIM || CTMON65
     27  1f23		       20 3d 1f 	      jsr	setFileName	;Set the file name to open
     28  1f26		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  1f29		       90 07		      bcc	Ropenok	;branch if opened ok
     30  1f2b							;
     31  1f2b							; Open failed
     32  1f2b							;
     33  1f2b		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  1f2d		       a9 00	   Rdfail2    lda	#0
     35  1f2f		       4c 20 06 	      jmp	iErr2
     36  1f32							;
     37  1f32							; Clear counts and offsets so the next read will
     38  1f32							; cause the file to be read.
     39  1f32							;
     40  1f32		       a9 00	   Ropenok    lda	#0
     41  1f34		       8d 9b 24 	      sta	diskBufOffset
     42  1f37		       8d 9a 24 	      sta	diskBufLength
     43  1f3a		       4c c2 02 	      jmp	NextIL
     44  1f3d					      endif
     45  1f3d
     46  1f3d							;===============================================================
     47  1f3d							; Set file name
     48  1f3d				   setFileName
     49  1f3d		       a4 51		      ldy	CUROFF
     50  1f3f		       b1 4f		      lda	(CURPTR),y
     51  1f41		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  1f43		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  1f45
     54  1f45		       18		      clc
     55  1f46		       98		      tya
     56  1f47		       65 4f		      adc	CURPTR
     57  1f49		       85 52		      sta	R0	;LSB
     58  1f4b		       a5 50		      lda	CURPTR+1
     59  1f4d		       69 00		      adc	#0
     60  1f4f		       85 53		      sta	R0+1
     61  1f51		       a9 9c		      lda	#DiskFileName&$ff
     62  1f53		       85 54		      sta	R1
     63  1f55		       a9 24		      lda	#DiskFileName>>8
     64  1f57		       85 55		      sta	R1+1
     65  1f59		       20 c1 1e 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  1f5c		       a5 52		      lda	R0
     67  1f5e		       18		      clc
     68  1f5f		       65 51		      adc	CUROFF	; add the current offset
     69  1f61		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  1f63
     71  1f63		       a0 9c		      ldy	#DiskFileName&$ff
     72  1f65		       a2 24		      ldx	#DiskFileName>>8
     73  1f67		       18		      clc
     74  1f68		       60		      rts
     75  1f69
     76  1f69				   setFileNameNotFound
     77  1f69		       68		      pla
     78  1f6a		       68		      pla		; remove the return address from the stack
     79  1f6b		       a9 00		      lda	#0
     80  1f6d		       a2 09		      ldx	#ERR_NO_FILENAME
     81  1f6f		       4c 20 06 	      jmp	iErr2
     82  1f72
     83  1f72							;
     84  1f72							;==============================JUSTLOSTINTIME 08/02/2022========
     85  1f72							;Remove a file from the disk
     86  1f72				   iRMFILE
     87  1f72					      if	XKIM || CTMON65
     88  1f72		       20 3d 1f 	      jsr	setFileName
     89  1f75		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  1f78		       90 07		      bcc	wrmOk	;branch if removed ok
     91  1f7a		       a9 00		      lda	#0
     92  1f7c		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  1f7e		       4c 20 06 	      jmp	iErr2
     94  1f81				   wrmOk
     95  1f81		       4c c2 02 	      jmp	NextIL
     96  1f84
     97  1f84					      endif
     98  1f84							;
     99  1f84							;=====================================================
    100  1f84				   iOPENWRITE
    101  1f84					      if	XKIM || CTMON65
    102  1f84		       20 3d 1f 	      jsr	setFileName
    103  1f87		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    104  1f8a		       90 07		      bcc	Wopenok	;branch if opened ok
    105  1f8c							;
    106  1f8c							; Open failed
    107  1f8c							;
    108  1f8c		       a9 00	   Wdfail     lda	#0
    109  1f8e		       a2 08		      ldx	#ERR_WRITE_FAIL
    110  1f90		       4c 20 06 	      jmp	iErr2
    111  1f93							;
    112  1f93		       4c c2 02    Wopenok    jmp	NextIL
    113  1f96					      endif
    114  1f96							;
    115  1f96							;=====================================================
    116  1f96							; Gets a line of input from the disk file and puts it
    117  1f96							; into LINBUF.
    118  1f96							;
    119  1f96							; On exit:
    120  1f96							;    CURPTR points to LINBUF
    121  1f96							;    LINBUF contains the line with 0 at the end.
    122  1f96							;    Y has offset to first non-space character
    123  1f96							;    CURROFF has the same as Y.
    124  1f96							;
    125  1f96				   iDGETLINE
    126  1f96					      if	XKIM || CTMON65
    127  1f96		       a2 9d		      ldx	#LINBUF&$ff
    128  1f98		       86 4f		      stx	CURPTR
    129  1f9a		       a2 2d		      ldx	#LINBUF>>8
    130  1f9c		       86 50		      stx	CURPTR+1
    131  1f9e							;
    132  1f9e		       a2 00		      ldx	#0	;offset
    133  1fa0		       8e 21 2e    iDgetLoop  stx	getlinx
    134  1fa3		       20 0e 20 	      jsr	getNextFileByte
    135  1fa6		       b0 16		      bcs	iGetEOF
    136  1fa8		       c9 0d		      cmp	#CR
    137  1faa		       f0 0d		      beq	iGetEOL
    138  1fac		       c9 0a		      cmp	#LF
    139  1fae		       f0 09		      beq	iGetEOL
    140  1fb0		       ae 21 2e 	      ldx	getlinx
    141  1fb3		       9d 9d 2d 	      sta	LINBUF,x
    142  1fb6		       e8		      inx
    143  1fb7		       d0 e7		      bne	iDgetLoop
    144  1fb9							;
    145  1fb9							; Handle end of line.	If the line has nothing, loop
    146  1fb9							; back and get another line.
    147  1fb9							;
    148  1fb9		       ae 21 2e    iGetEOL    ldx	getlinx	;blank line?
    149  1fbc		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    150  1fbe							;
    151  1fbe							; This can fall through when there is a line, or
    152  1fbe							; called directly when EOF is encountered.
    153  1fbe							;
    154  1fbe		       ae 21 2e    iGetEOF    ldx	getlinx
    155  1fc1		       a9 00		      lda	#0
    156  1fc3		       9d 9d 2d 	      sta	LINBUF,x
    157  1fc6		       a0 00		      ldy	#0
    158  1fc8		       20 da 1c 	      jsr	SkipSpaces
    159  1fcb		       20 92 0f 	      jsr	ParseInputLine
    160  1fce		       a9 8f		      lda	#TOKENBUFFER&$ff
    161  1fd0		       85 4f		      sta	CURPTR
    162  1fd2		       a9 0e		      lda	#TOKENBUFFER>>8
    163  1fd4		       85 50		      sta	CURPTR+1
    164  1fd6		       a9 01		      lda	#1
    165  1fd8		       85 51		      sta	CUROFF
    166  1fda		       4c c2 02 	      jmp	NextIL
    167  1fdd					      endif
    168  1fdd
    169  1fdd							;
    170  1fdd							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    171  1fdd							; DISK
    172  1fdd							;
    173  1fdd				   iDDIR
    174  1fdd					      if	XKIM || CTMON65
    175  1fdd		       20 30 f0 	      jsr	DiskDir
    176  1fe0							;
    177  1fe0							; Get/Display each entry
    178  1fe0							;
    179  1fe0		       a2 24	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    180  1fe2		       a0 9c		      ldy	#DiskFileName&$ff
    181  1fe4		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    182  1fe7		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    183  1fe9		       20 59 14 	      jsr	puts
      0  1fec					      db	"   ",0
      1  1fec		       20 20 20 00	      .byte.b	"   ",0
    185  1ff0							; Print the line to the console
    186  1ff0		       a2 24		      ldx	#DiskFileName>>8	;pointer to buffer
    187  1ff2		       a0 9c		      ldy	#DiskFileName&$ff
    188  1ff4		       a5 00		      lda	0
    189  1ff6		       20 9e 14 	      jsr	PrtStr	;else print name
    190  1ff9		       20 18 f0 	      jsr	crlf
    191  1ffc
    192  1ffc		       4c e0 1f 	      jmp	DiskDirLoop	;do next entry
    193  1fff
    194  1fff		       4c c2 02    DiskDirEnd jmp	NextIL
    195  2002					      endif
    196  2002							;
    197  2002							;=====================================================
    198  2002							; Does a LIST to a Disk file.
    199  2002							;
    200  2002				   iDLIST
    201  2002					      if	XKIM || CTMON65
    202  2002		       20 3d 20 	      jsr	SetOutDisk
    203  2005		       4c f0 07 	      jmp	iLST2
    204  2008					      endif
    205  2008							;
    206  2008							;=====================================================
    207  2008							; Closes any pending disk file.  Okay to call if there
    208  2008							; is no open file.
    209  2008							;
    210  2008				   iDCLOSE
    211  2008					      if	XKIM || CTMON65
    212  2008		       20 42 f0 	      jsr	DiskClose
    213  200b		       4c c2 02 	      jmp	NextIL
    214  200e					      endif
    215  200e							;
    216  200e							;=====================================================
    217  200e							; This gets the next byte from an open disk file.  If
    218  200e							; there are no more bytes left, this returns C set.
    219  200e							; Else, C is clear and A contains the character.
    220  200e							;
    221  200e				   getNextFileByte
    222  200e					      if	XKIM || CTMON65
    223  200e		       ae 9b 24 	      ldx	diskBufOffset
    224  2011		       ec 9a 24 	      cpx	diskBufLength
    225  2014		       d0 14		      bne	hasdata	;branch if still data
    226  2016							;
    227  2016							; There is no data left in the buffer, so read a
    228  2016							; block from the SD system.
    229  2016							;
    230  2016		       a9 84		      lda	#BUFFER_SIZE
    231  2018		       a2 df		      ldx	#buffer>>8
    232  201a		       a0 0a		      ldy	#buffer&$ff
    233  201c		       20 3c f0 	      jsr	DiskRead
    234  201f		       b0 12		      bcs	getNextEof
    235  2021							;
    236  2021							; A contains the number of bytes actually read.
    237  2021							;
    238  2021		       8d 9a 24 	      sta	diskBufLength	;save length
    239  2024		       c9 00		      cmp	#0	;shouldn't happen
    240  2026		       f0 0b		      beq	getNextEof
    241  2028							;
    242  2028		       a2 00		      ldx	#0
    243  202a		       bd 0a df    hasdata    lda	buffer,x
    244  202d		       e8		      inx
    245  202e		       8e 9b 24 	      stx	diskBufOffset
    246  2031		       18		      clc
    247  2032		       60		      rts
    248  2033							;
    249  2033		       a9 00	   getNextEof lda	#0
    250  2035		       8d 9b 24 	      sta	diskBufOffset
    251  2038		       8d 9a 24 	      sta	diskBufLength
    252  203b		       38		      sec
    253  203c		       60		      rts
    254  203d							;
    255  203d							;=====================================================
    256  203d							; Set output vector to the disk output function
    257  203d							;
    258  203d		       a9 48	   SetOutDisk lda	#DOUT&$ff
    259  203f		       8d 2e 2e 	      sta	BOutVec
    260  2042		       a9 20		      lda	#DOUT/256
    261  2044		       8d 2f 2e 	      sta	BOutVec+1
    262  2047		       60		      rts
    263  2048							;
    264  2048							;=====================================================
    265  2048
    266  2048		       8e 9c 24    DOUT       stx	DiskFileName
    267  204b		       8c 9d 24 	      sty	DiskFileName+1
    268  204e		       8d 0a df 	      sta	buffer
    269  2051		       a9 01		      lda	#1
    270  2053		       a0 0a		      ldy	#buffer&$ff
    271  2055		       a2 df		      ldx	#buffer>>8
    272  2057		       20 3f f0 	      jsr	DiskWrite
    273  205a		       ae 9c 24 	      ldx	DiskFileName
    274  205d		       ac 9d 24 	      ldy	DiskFileName+1
    275  2060
    276  2060							;
    277  2060							; need error checking here
    278  2060							;
    279  2060		       60		      rts
    280  2061					      endif
    281  2061
    282  2061
------- FILE mytb.asm
   2320  2061					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  2061					      include	"IL.inc"
      1  2061
      2  2061							;=====================================================
      3  2061							; IL.inc
      4  2061							; These are macros for IL instructions
      5  2061							;
      6  2061					      mac	dw
      7  2061					      .word	{0}
      8  2061					      endm
      9  2061					      mac	db
     10  2061					      .byte	{0}
     11  2061					      endm
     12  2061					      macro	xinit
     13  2061					      db	0
     14  2061					      endm		;reset the il to start clear all
     15  2061							;
     16  2061					      macro	done
     17  2061					      db	1
     18  2061					      endm		;print an error if not end of line
     19  2061							;
     20  2061					      macro	prs
     21  2061					      db	2
     22  2061					      endm		;print a quoted string
     23  2061							;
     24  2061					      macro	prn
     25  2061					      db	3
     26  2061					      endm		;print a number
     27  2061							;
     28  2061					      macro	spc
     29  2061					      db	4
     30  2061					      endm		;print space til new tabstop
     31  2061							;
     32  2061					      macro	nline
     33  2061					      db	5
     34  2061					      endm		;print a new line crlf
     35  2061							;
     36  2061							; My NXT is a bit different in that it takes one
     37  2061							; parameter, which is an address.  If the BASIC
     38  2061							; program is currently running then move to the
     39  2061							; next line and continue execution.  However, if
     40  2061							; in direct mode, jump to the specified IL label.
     41  2061							;
     42  2061					      macro	nxt
     43  2061					      db	6
     44  2061					      dw	{1}	; addr
     45  2061					      endm		; addr
     46  2061							;
     47  2061					      macro	xfer
     48  2061					      db	7
     49  2061					      endm
     50  2061							;
     51  2061					      macro	sav
     52  2061					      db	8
     53  2061					      db	{1}
     54  2061					      endm
     55  2061							;
     56  2061					      macro	rstr
     57  2061					      db	9
     58  2061					      endm
     59  2061							;
     60  2061					      macro	cmpr
     61  2061					      db	10
     62  2061					      endm
     63  2061							;
     64  2061					      macro	innum
     65  2061					      db	11
     66  2061					      endm
     67  2061							;
     68  2061					      macro	fin
     69  2061					      db	12
     70  2061					      endm
     71  2061							;
     72  2061							; ERR is followed by an error number.	The error
     73  2061							; code is printed along with the line number.
     74  2061							; Control is passed to the statement set with
     75  2061							; the ERRGOTO statement.
     76  2061							;
     77  2061					      macro	errmsg
     78  2061					      db	13
     79  2061					      dw	{1}	;ecode
     80  2061					      endm		;ecode
     81  2061							;
     82  2061					      macro	add
     83  2061					      db	14
     84  2061					      endm
     85  2061							;
     86  2061					      macro	sub
     87  2061					      db	15
     88  2061					      endm
     89  2061							;
     90  2061					      macro	neg
     91  2061					      db	16
     92  2061					      endm
     93  2061							;
     94  2061					      macro	mul
     95  2061					      db	17
     96  2061					      endm
     97  2061							;
     98  2061					      macro	div
     99  2061					      db	18
    100  2061					      endm
    101  2061							;
    102  2061					      macro	store
    103  2061					      db	19
    104  2061					      endm
    105  2061							;
    106  2061					      macro	ind
    107  2061					      db	20
    108  2061					      endm
    109  2061							;
    110  2061					      macro	lst
    111  2061					      db	21
    112  2061					      endm
    113  2061							;
    114  2061					      macro	init
    115  2061					      db	22
    116  2061					      endm
    117  2061							;
    118  2061					      macro	getline
    119  2061					      db	23
    120  2061					      endm
    121  2061							;
    122  2061					      macro	insert
    123  2061					      db	24
    124  2061					      endm
    125  2061							;
    126  2061					      macro	rtn
    127  2061					      db	25
    128  2061					      endm
    129  2061							;
    130  2061					      macro	exit
    131  2061					      db	26
    132  2061					      endm
    133  2061							;
    134  2061					      macro	lit
    135  2061					      db	27
    136  2061					      dw	{1}	;value
    137  2061					      endm		; value LIT
    138  2061							;
    139  2061					      macro	call
    140  2061					      db	28
    141  2061					      dw	{1}	;addr
    142  2061					      endm		;addr
    143  2061							;
    144  2061							; IJMP will set the IL PC to the specified value.
    145  2061							;
    146  2061					      macro	ijmp
    147  2061					      db	29
    148  2061					      dw	{1}	;addr
    149  2061					      endm		;addr
    150  2061							;
    151  2061					      macro	vinit
    152  2061					      db	30
    153  2061					      endm
    154  2061							;
    155  2061							; ERRGOTO sets the point in the code where the IL
    156  2061							; interpreter will go after any error.
    157  2061							;
    158  2061					      macro	errgoto
    159  2061					      db	31
    160  2061					      dw	{1}	;addr
    161  2061					      endm		;addr
    162  2061							;
    163  2061					      macro	tst
    164  2061					      db	32
    165  2061					      db	({1}-*)-1	;(addr-*)-1
    166  2061					      db	{2},0	;string,0
    167  2061					      endm		;addr,string
    168  2061							;
    169  2061					      macro	tstv
    170  2061					      db	33
    171  2061					      db	({1}-*)-1	;(addr-*)-1
    172  2061					      endm		;addr
    173  2061							;
    174  2061					      macro	tstl
    175  2061					      db	34
    176  2061					      db	({1}-*)-1	;(addr-*)-1
    177  2061					      endm		;addr
    178  2061							;
    179  2061					      macro	tstn
    180  2061					      db	35
    181  2061					      db	({1}-*)-1	;(addr-*)-1
    182  2061					      endm		;addr
    183  2061							;
    184  2061							; FREE returns the amount of free RAM on top of
    185  2061							; the stack.  This is the amount of room the user
    186  2061							; program has available.
    187  2061							;
    188  2061					      macro	free
    189  2061					      db	36
    190  2061					      endm
    191  2061							;
    192  2061							; RANDOM takes the top item off the stack and
    193  2061							; replaces it with a random number that is
    194  2061							; MOD the initial value.  Ie, if the TOS is
    195  2061							; 42 then RANDOM returns a value from 0 to 41.
    196  2061							;
    197  2061					      macro	random
    198  2061					      db	37
    199  2061					      endm
    200  2061							;
    201  2061							; ABS will replace the top of stack with the
    202  2061							; absolute value.
    203  2061							;
    204  2061					      macro	abs
    205  2061					      db	38
    206  2061					      endm
    207  2061							;
    208  2061							; OPENREAD opens a file for reading, as in getting
    209  2061							; statements from it.
    210  2061							;
    211  2061					      macro	openread
    212  2061					      db	39
    213  2061					      endm
    214  2061							;
    215  2061							; OPENWRITE opens a file for writing, as in saving
    216  2061							; the current program to it.
    217  2061							;
    218  2061					      macro	openwrite
    219  2061					      db	40
    220  2061					      endm
    221  2061							;
    222  2061							; DCLOSE closes any open disk file.
    223  2061							;
    224  2061					      macro	dclose
    225  2061					      db	41
    226  2061					      endm
    227  2061							;
    228  2061							; DGETLINE gets one line from the disk file and puts it
    229  2061							; into LINBUFF.
    230  2061							;
    231  2061					      macro	dgetline
    232  2061					      db	42
    233  2061					      endm
    234  2061							;
    235  2061							; DLIST saves the program to an open disk file.
    236  2061							;
    237  2061					      macro	dlist
    238  2061					      db	43
    239  2061					      endm
    240  2061							; DDIR list the current directory
    241  2061							;
    242  2061					      macro	ddir
    243  2061					      db	44
    244  2061					      endm
    245  2061
    246  2061							; RMFILE remove a fle from disk
    247  2061					      macro	rmfile
    248  2061					      db	45
    249  2061					      endm
    250  2061
    251  2061							; CLEARSCREEN clear the screen
    252  2061					      macro	clearscreen
    253  2061					      db	46
    254  2061					      endm
    255  2061							; POKEMEM Poke value into memory
    256  2061					      macro	pokemem
    257  2061					      db	47
    258  2061					      endm
    259  2061							; PEEKMEM peek at value in memory
    260  2061					      macro	peekmem
    261  2061					      db	48
    262  2061					      endm
    263  2061							; TSTLET Test if the statement is a let without the keyword let
    264  2061					      macro	tstlet
    265  2061					      db	49
    266  2061					      db	({1}-*)-1	;(addr-*)-1
    267  2061					      endm		;addr
    268  2061							; TSTDONE if we reach the end of a statement
    269  2061					      macro	tstdone
    270  2061					      db	50
    271  2061					      db	({1}-*)-1	;(addr-*)-1
    272  2061					      endm		;addr
    273  2061							; GETCHAR	get a character from the input line leave it in RO
    274  2061					      macro	getchar
    275  2061					      db	51
    276  2061					      endm
    277  2061							; PUTCHAR	Put a character to the terminal
    278  2061					      macro	putchar
    279  2061					      db	52
    280  2061					      endm
    281  2061							; Call		Call a machine function return a to stack
    282  2061					      macro	callfunc
    283  2061					      db	53
    284  2061					      endm
    285  2061
    286  2061							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  2061					      macro	ibranch
    288  2061					      db	54
    289  2061					      endm
    290  2061
    291  2061							; TSTSTR	 Tests for the open quote in a string
    292  2061					      macro	tststr
    293  2061					      db	55
    294  2061					      db	({1}-*)-1	;(addr-*)-1
    295  2061					      endm
    296  2061							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  2061					      macro	setirq
    298  2061					      db	56
    299  2061					      endm
    300  2061
    301  2061							; TSTIRQ	Test for irq pending,
    302  2061							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  2061					      macro	tstirq
    304  2061					      db	57
    305  2061					      db	({1}-*)-1	;(addr-*)-1
    306  2061					      endm
    307  2061
    308  2061							; IRET    return from interupt service
    309  2061					      macro	iret
    310  2061					      db	58
    311  2061					      endm
    312  2061
    313  2061							; INSTR   read a string from the input
    314  2061					      macro	instr
    315  2061					      db	59
    316  2061					      endm
    317  2061
    318  2061							; MODULO Returns the remainder of the division
    319  2061					      macro	modulo
    320  2061					      db	60
    321  2061					      endm
    322  2061							; Set a task line
    323  2061					      macro	taskcreate
    324  2061					      db	61
    325  2061					      endm
    326  2061							; End a task
    327  2061					      macro	etask
    328  2061					      db	62
    329  2061					      endm
    330  2061							; Skip to next task
    331  2061					      macro	ntask
    332  2061					      db	63
    333  2061					      endm
    334  2061							; Subscript
    335  2061					      macro	subscript
    336  2061					      db	64
    337  2061					      endm
    338  2061							; KILL Task
    339  2061					      macro	taskkill
    340  2061					      db	65
    341  2061					      endm
    342  2061							; STAT Task
    343  2061					      macro	taskstat
    344  2061					      db	66
    345  2061					      endm
    346  2061							;  output value as hex
    347  2061					      macro	hexprt
    348  2061					      db	67
    349  2061					      endm
    350  2061							;  Read in background has completed
    351  2061					      macro	readcomplete
    352  2061					      db	68
    353  2061					      endm
    354  2061							;  ReadInput line
    355  2061					      macro	readstart
    356  2061					      db	69
    357  2061					      endm
    358  2061							; Startio request
    359  2061					      macro	startio
    360  2061					      db	70
    361  2061					      endm
    362  2061							; Endio
    363  2061					      macro	endio
    364  2061					      db	71
    365  2061					      endm
    366  2061							; Logical not
    367  2061					      macro	lognot
    368  2061					      db	72
    369  2061					      endm
    370  2061							; Logical OR
    371  2061					      macro	logor
    372  2061					      db	73
    373  2061					      endm
    374  2061							;Logical and
    375  2061					      macro	logand
    376  2061					      db	74
    377  2061					      endm
    378  2061							;Logical XOR
    379  2061					      macro	logxor
    380  2061					      db	75
    381  2061					      endm
    382  2061							;Wait for task to complete, or list of tasks
    383  2061					      macro	wtask
    384  2061					      db	76
    385  2061					      db	({1}-*)-1	;(addr-*)-1
    386  2061					      endm
    387  2061							;Get the current task id
    388  2061					      MACRO	taskpid
    389  2061					      db	77
    390  2061					      endm
    391  2061							;Trace the basic execution
    392  2061					      Macro	traceprogram
    393  2061					      db	78
    394  2061					      endm
    395  2061							;Do a basic program Trace
    396  2061					      Macro	debugbasic
    397  2061					      db	79
    398  2061					      endm
    399  2061
    400  2061							; Inter Process communications instructions
    401  2061					      Macro	ipcsend
    402  2061					      db	80
    403  2061					      endm
    404  2061					      Macro	ipcreceive
    405  2061					      db	81
    406  2061					      endm
    407  2061					      Macro	ipccheck
    408  2061					      db	82
    409  2061					      endm
    410  2061					      Macro	ipcio
    411  2061					      db	83
    412  2061					      endm
    413  2061					      Macro	pushmathstack
    414  2061					      db	84
    415  2061					      endm
    416  2061					      Macro	popmathstack
    417  2061					      db	85
    418  2061					      endm
    419  2061					      Macro	savemathstack
    420  2061					      db	86
    421  2061					      endm
    422  2061					      Macro	restoremathstack
    423  2061					      db	87
    424  2061					      endm
    425  2061					      Macro	incparmcount
    426  2061					      db	88
    427  2061					      endm
    428  2061					      Macro	taskgetmathstack
    429  2061					      db	89
    430  2061					      endm
    431  2061					      Macro	taskenable
    432  2061					      db	90
    433  2061					      endm
    434  2061					      Macro	tasksuspend
    435  2061					      db	91
    436  2061					      endm
    437  2061					      Macro	taskputmathptr
    438  2061					      db	92
    439  2061					      endm
    440  2061							; Test for an extension type of variable that allows access to a tasks variables
    441  2061							; Using  PID!<Var name>
    442  2061					      Macro	tstvt
    443  2061					      db	93
    444  2061					      db	({1}-*)-1	;(addr-*)-1
    445  2061					      endm
    446  2061
    447  2061							; Provide access to R2 for the IL program
    448  2061					      Macro	setr2
    449  2061					      db	94
    450  2061					      db	{1}	; R2 is only one byte
    451  2061					      endm
    452  2061							;Move stack top to temp
    453  2061					      Macro	stk2tmp
    454  2061					      db	95
    455  2061					      endm
    456  2061
    457  2061					      Macro	tmp2stk
    458  2061					      db	96
    459  2061					      endm
    460  2061
    461  2061					      Macro	tstbyte
    462  2061					      db	97
    463  2061					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  2061					      dw	{2}	; address to check
    465  2061					      db	{3}	; Value to compare
    466  2061					      endm
    467  2061
    468  2061					      Macro	incvar
    469  2061					      db	98
    470  2061					      endm
    471  2061					      Macro	decvar
    472  2061					      db	99
    473  2061					      endm
    474  2061
    475  2061					      Macro	slice
    476  2061					      db	100
    477  2061					      endm
    478  2061
    479  2061					      Macro	tstb
    480  2061					      db	101
    481  2061					      db	({1}-*)-1
    482  2061					      db	{2}
    483  2061					      endm
    484  2061
    485  2061					      Macro	tstw
    486  2061					      db	102
    487  2061					      db	({1}-*)-1
    488  2061					      dw	{2}
    489  2061					      endm
    490  2061
    491  2061					      Macro	ongoto
    492  2061					      db	103
    493  2061					      dw	{1}
    494  2061					      dw	{2}
    495  2061					      endm
    496  2061
    497  2061					      Macro	tstrelop
    498  2061					      db	104
    499  2061					      db	({1}-*)-1
    500  2061					      endm
    501  2061
    502  2061
    503  2061					      Macro	repeatline
    504  2061					      db	105
    505  2061					      endm
    506  2061
------- FILE mytb.asm
   2322  2061							;
   2323  2061				  -	      if	FIXED
   2324  2061				  -	      org	$1000
   2325  2061					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  2061					      include	"basic.il"
      1  2061					      seg	Code
      2  2061							; on goto table
      3  2061							; format :   first byte is value Base, subtracted from value found
      4  2061							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  2061				   BasicStmts
      0  2061					      db	kBeginKey,kKeyCount+1	; Base address of table, length of table
      1  2061		       01 1f		      .byte.b	kBeginKey,kKeyCount+1
      0  2063					      dw	ekLet
      1  2063		       de 20		      .word.w	ekLet
      0  2065					      dw	ekInc
      1  2065		       09 21		      .word.w	ekInc
      0  2067					      dw	ekDec
      1  2067		       1c 21		      .word.w	ekDec
      0  2069					      dw	ekIreturn
      1  2069		       2f 21		      .word.w	ekIreturn
      0  206b					      dw	ekIf
      1  206b		       37 21		      .word.w	ekIf
      0  206d					      dw	ekThen
      1  206d		       3d 21		      .word.w	ekThen
      0  206f					      dw	ekGoto
      1  206f		       44 21		      .word.w	ekGoto
      0  2071					      dw	ekGosub
      1  2071		       52 21		      .word.w	ekGosub
      0  2073					      dw	ekReturn
      1  2073		       5c 21		      .word.w	ekReturn
      0  2075					      dw	ekRem
      1  2075		       7c 21		      .word.w	ekRem
      0  2077					      dw	ekPrint	; should be entry for print
      1  2077		       85 21		      .word.w	ekPrint
      0  2079					      dw	ekTaske
      1  2079		       d5 21		      .word.w	ekTaske
      0  207b					      dw	ekTaskn
      1  207b		       ee 21		      .word.w	ekTaskn
      0  207d					      dw	ekTaskw
      1  207d		       f8 21		      .word.w	ekTaskw
      0  207f					      dw	ekPoke
      1  207f		       16 22		      .word.w	ekPoke
      0  2081					      dw	ekPutch
      1  2081		       30 22		      .word.w	ekPutch
      0  2083					      dw	ekCls
      1  2083		       3e 22		      .word.w	ekCls
      0  2085					      dw	ekInput
      1  2085		       48 22		      .word.w	ekInput
      0  2087					      dw	ekEnd
      1  2087		       6d 22		      .word.w	ekEnd
      0  2089					      dw	ekIrq
      1  2089		       74 22		      .word.w	ekIrq
      0  208b					      dw	ekKill
      1  208b		       82 22		      .word.w	ekKill
      0  208d					      dw	ekList
      1  208d		       90 22		      .word.w	ekList
      0  208f					      dw	ekRun
      1  208f		       98 22		      .word.w	ekRun
      0  2091					      dw	ekNew
      1  2091		       a4 22		      .word.w	ekNew
      0  2093					      dw	ekSlice
      1  2093		       ab 22		      .word.w	ekSlice
      0  2095					      dw	ekTrace
      1  2095		       b9 22		      .word.w	ekTrace
      0  2097					      dw	ekExit
      1  2097		       cd 22		      .word.w	ekExit
      0  2099					      dw	ekSave
      1  2099		       d1 22		      .word.w	ekSave
      0  209b					      dw	ekLoad
      1  209b		       da 22		      .word.w	ekLoad
      0  209d					      dw	ekErase
      1  209d		       f0 22		      .word.w	ekErase
      0  209f					      dw	ekDir
      1  209f		       e9 22		      .word.w	ekDir
     38  20a1							;
     39  20a1							; Logical operators
      0  20a1				   BasicLogical db	kNot,4
      1  20a1		       20 04		      .byte.b	kNot,4
      0  20a3					      dw	ekNot
      1  20a3		       fb 22		      .word.w	ekNot
     42  20a5
      0  20a5					      dw	ekOr
      1  20a5		       0e 23		      .word.w	ekOr
      0  20a7					      dw	ekXor
      1  20a7		       16 23		      .word.w	ekXor
      0  20a9					      dw	ekAnd
      1  20a9		       06 23		      .word.w	ekAnd
     46  20ab
     47  20ab							;functions returning values
     48  20ab
      0  20ab				   BasicFuncs db	kBeginFunc,kFuncCount
      1  20ab		       24 0e		      .byte.b	kBeginFunc,kFuncCount
      0  20ad					      dw	ekTrue
      1  20ad		       79 23		      .word.w	ekTrue
      0  20af					      dw	ekFalse
      1  20af		       80 23		      .word.w	ekFalse
      0  20b1					      dw	ekFree
      1  20b1		       87 23		      .word.w	ekFree
      0  20b3					      dw	ekGetch
      1  20b3		       92 23		      .word.w	ekGetch
      0  20b5					      dw	ekPeek
      1  20b5		       9d 23		      .word.w	ekPeek
      0  20b7					      dw	ekTask
      1  20b7		       ab 23		      .word.w	ekTask
      0  20b9					      dw	ekIpcc
      1  20b9		       f6 23		      .word.w	ekIpcc
      0  20bb					      dw	ekIpcs
      1  20bb		       ca 23		      .word.w	ekIpcs
      0  20bd					      dw	ekIpcr
      1  20bd		       de 23		      .word.w	ekIpcr
      0  20bf					      dw	ekRnd
      1  20bf		       04 24		      .word.w	ekRnd
      0  20c1					      dw	ekStat
      1  20c1		       28 24		      .word.w	ekStat
      0  20c3					      dw	ekAbs
      1  20c3		       1a 24		      .word.w	ekAbs
      0  20c5					      dw	ekCall
      1  20c5		       3b 24		      .word.w	ekCall
      0  20c7					      dw	ekGofn
      1  20c7		       57 24		      .word.w	ekGofn
      0  20c9					      dw	ekPid
      1  20c9		       36 24		      .word.w	ekPid
     65  20cb
     66  20cb
     67  20cb							;=====================================================
     68  20cb							; This is the IL of the BASIC (or whatever) language.
     69  20cb							; Because of the way macros are implemented by as65,
     70  20cb							; labels can't be on the same line as a macro
     71  20cb							; invocation, so that's why labels are on separate
     72  20cb							; lines.
     73  20cb							;
     74  20cb		       20 cb	   IL	      equ	*
     75  20cb
     76  20cb							;THE IL CONTROL SECTION
     77  20cb
     78  20cb				   START
      0  20cb					      INIT		;INITIALIZE
      0  20cb					      db	22
      1  20cb		       16		      .byte.b	22
      0  20cc					      NLINE		;WRITE CRLF
      0  20cc					      db	5
      1  20cc		       05		      .byte.b	5
      0  20cd					      ERRGOTO	CO	;where to go after an error
      0  20cd					      db	31
      1  20cd		       1f		      .byte.b	31
      0  20ce					      dw	CO
      1  20ce		       d1 20		      .word.w	CO
      0  20d0					      VINIT		;clear all variables
      0  20d0					      db	30
      1  20d0		       1e		      .byte.b	30
     83  20d1							;
     84  20d1							; This is where we jump to get a line of commands or
     85  20d1							; a program from the user.
     86  20d1							;
     87  20d1				   CO
      0  20d1					      GETLINE		;WRITE PROMPT AND GET LINE
      0  20d1					      db	23
      1  20d1		       17		      .byte.b	23
      0  20d2					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  20d2					      db	34
      1  20d2		       22		      .byte.b	34
      0  20d3					      db	(XEC-*)-1
      1  20d3		       04		      .byte.b	(XEC-*)-1
      0  20d4					      INSERT		;INSERT IT (MAY BE DELETE)
      0  20d4					      db	24
      1  20d4		       18		      .byte.b	24
      0  20d5					      IJMP	CO
      0  20d5					      db	29
      1  20d5		       1d		      .byte.b	29
      0  20d6					      dw	CO
      1  20d6		       d1 20		      .word.w	CO
     92  20d8				   XEC
      0  20d8					      XINIT		;INITIALIZE
      0  20d8					      db	0
      1  20d8		       00		      .byte.b	0
     94  20d9							;============================================================================
     95  20d9							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     96  20d9							;
     97  20d9				   STMT
      0  20d9					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  20d9					      db	79
      1  20d9		       4f		      .byte.b	79
      0  20da					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  20da					      db	57
      1  20da		       39		      .byte.b	57
      0  20db					      db	(notirq-*)-1
      1  20db		       00		      .byte.b	(notirq-*)-1
    100  20dc							;==========================================================================================
    101  20dc							; Process a let statement implied or explicit.
    102  20dc							;
    103  20dc				   notirq
      0  20dc					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  20dc					      db	49
      1  20dc		       31		      .byte.b	49
      0  20dd					      db	(DoVector-*)-1
      1  20dd		       23		      .byte.b	(DoVector-*)-1
    105  20de				   ekLet
      0  20de					      TSTV	ERRVEC2	; YES, PLACE VAR ADDRESS ON AESTK
      0  20de					      db	33
      1  20de		       21		      .byte.b	33
      0  20df					      db	(ERRVEC2-*)-1
      1  20df		       1e		      .byte.b	(ERRVEC2-*)-1
      0  20e0					      TSTB	LETSQBRACKET,oEqual	; (This line originally omitted)
      0  20e0					      db	101
      1  20e0		       65		      .byte.b	101
      0  20e1					      db	(LETSQBRACKET-*)-1
      1  20e1		       04		      .byte.b	(LETSQBRACKET-*)-1
      0  20e2					      db	oEqual
      1  20e2		       f2		      .byte.b	oEqual
      0  20e3					      IJMP	LETBE
      0  20e3					      db	29
      1  20e3		       1d		      .byte.b	29
      0  20e4					      dw	LETBE
      1  20e4		       f3 20		      .word.w	LETBE
    109  20e6
    110  20e6				   LETSQBRACKET 		; is this an array access ?
    111  20e6
      0  20e6					      TSTB	ERRVEC2,oLeftSQBracket	; [
      0  20e6					      db	101
      1  20e6		       65		      .byte.b	101
      0  20e7					      db	(ERRVEC2-*)-1
      1  20e7		       16		      .byte.b	(ERRVEC2-*)-1
      0  20e8					      db	oLeftSQBracket
      1  20e8		       e4		      .byte.b	oLeftSQBracket
      0  20e9					      CALL	EXPR
      0  20e9					      db	28
      1  20e9		       1c		      .byte.b	28
      0  20ea					      dw	EXPR
      1  20ea		       f8 22		      .word.w	EXPR
      0  20ec					      TSTB	ERRVEC2,oRightSQBracket	; ]
      0  20ec					      db	101
      1  20ec		       65		      .byte.b	101
      0  20ed					      db	(ERRVEC2-*)-1
      1  20ed		       10		      .byte.b	(ERRVEC2-*)-1
      0  20ee					      db	oRightSQBracket
      1  20ee		       e5		      .byte.b	oRightSQBracket
      0  20ef					      SUBSCRIPT
      0  20ef					      db	64
      1  20ef		       40		      .byte.b	64
      0  20f0					      TSTB	ERRVEC2,oEqual	; (This line originally omitted)
      0  20f0					      db	101
      1  20f0		       65		      .byte.b	101
      0  20f1					      db	(ERRVEC2-*)-1
      1  20f1		       0c		      .byte.b	(ERRVEC2-*)-1
      0  20f2					      db	oEqual
      1  20f2		       f2		      .byte.b	oEqual
    117  20f3				   LETBE
    118  20f3
      0  20f3					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  20f3					      db	28
      1  20f3		       1c		      .byte.b	28
      0  20f4					      dw	EXPR
      1  20f4		       f8 22		      .word.w	EXPR
      0  20f6					      DONE		; REPORT ERROR IF NOT NEXT
      0  20f6					      db	1
      1  20f6		       01		      .byte.b	1
      0  20f7					      STORE		; STORE RESULT
      0  20f7					      db	19
      1  20f7		       13		      .byte.b	19
      0  20f8					      NXT	CO	; AND SEQUENCE TO NEXT
      0  20f8					      db	6
      1  20f8		       06		      .byte.b	6
      0  20f9					      dw	CO
      1  20f9		       d1 20		      .word.w	CO
      0  20fb					      IJMP	STMT
      0  20fb					      db	29
      1  20fb		       1d		      .byte.b	29
      0  20fc					      dw	STMT
      1  20fc		       d9 20		      .word.w	STMT
    124  20fe				   ERRVEC2
      0  20fe					      IJMP	UNKNOWN
      0  20fe					      db	29
      1  20fe		       1d		      .byte.b	29
      0  20ff					      dw	UNKNOWN
      1  20ff		       f4 22		      .word.w	UNKNOWN
    126  2101							;=============================================================
    127  2101							;Branch on a valid statement start
    128  2101				   DoVector
      0  2101					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  2101					      db	103
      1  2101		       67		      .byte.b	103
      0  2102					      dw	BasicStmts
      1  2102		       61 20		      .word.w	BasicStmts
      0  2104					      dw	UNKNOWN
      1  2104		       f4 22		      .word.w	UNKNOWN
    130  2106							;This will never return here!
    131  2106							;=============================================================
    132  2106							; Inc or dec a variable
    133  2106				   S1
      0  2106					      TSTB	S1Dec,kInc	; Increment variable
      0  2106					      db	101
      1  2106		       65		      .byte.b	101
      0  2107					      db	(S1Dec-*)-1
      1  2107		       11		      .byte.b	(S1Dec-*)-1
      0  2108					      db	kInc
      1  2108		       02		      .byte.b	kInc
    135  2109				   ekInc
      0  2109					      TSTV	ERRVEC2	; Verify we have a variable
      0  2109					      db	33
      1  2109		       21		      .byte.b	33
      0  210a					      db	(ERRVEC2-*)-1
      1  210a		       f3		      .byte.b	(ERRVEC2-*)-1
      0  210b					      TSTB	eDoInc,oBang	; Allow to inc or dec other tasks variables
      0  210b					      db	101
      1  210b		       65		      .byte.b	101
      0  210c					      db	(eDoInc-*)-1
      1  210c		       04		      .byte.b	(eDoInc-*)-1
      0  210d					      db	oBang
      1  210d		       e8		      .byte.b	oBang
      0  210e					      IND		; we just got a pid
      0  210e					      db	20
      1  210e		       14		      .byte.b	20
      0  210f					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  210f					      db	93
      1  210f		       5d		      .byte.b	93
      0  2110					      db	(ERRVEC2-*)-1
      1  2110		       ed		      .byte.b	(ERRVEC2-*)-1
    140  2111				   eDoInc
      0  2111					      INCVAR		; Do the increment of the variable
      0  2111					      db	98
      1  2111		       62		      .byte.b	98
      0  2112					      DONE		; Test for end of line or end of statement ":"
      0  2112					      db	1
      1  2112		       01		      .byte.b	1
      0  2113					      NXT	CO	; Get the next statement, branch CO if end of program
      0  2113					      db	6
      1  2113		       06		      .byte.b	6
      0  2114					      dw	CO
      1  2114		       d1 20		      .word.w	CO
      0  2116					      IJMP	STMT	; Process the next statement
      0  2116					      db	29
      1  2116		       1d		      .byte.b	29
      0  2117					      dw	STMT
      1  2117		       d9 20		      .word.w	STMT
    145  2119				   S1Dec
      0  2119					      TSTB	S1Iret,kDec	; Dec variable
      0  2119					      db	101
      1  2119		       65		      .byte.b	101
      0  211a					      db	(S1Iret-*)-1
      1  211a		       11		      .byte.b	(S1Iret-*)-1
      0  211b					      db	kDec
      1  211b		       03		      .byte.b	kDec
    147  211c				   ekDec
      0  211c					      TSTV	ERRVEC2	; Must be followed by a variable
      0  211c					      db	33
      1  211c		       21		      .byte.b	33
      0  211d					      db	(ERRVEC2-*)-1
      1  211d		       e0		      .byte.b	(ERRVEC2-*)-1
      0  211e					      TSTB	eDoDec,oBang	; Allow to inc or dec other tasks variables
      0  211e					      db	101
      1  211e		       65		      .byte.b	101
      0  211f					      db	(eDoDec-*)-1
      1  211f		       04		      .byte.b	(eDoDec-*)-1
      0  2120					      db	oBang
      1  2120		       e8		      .byte.b	oBang
      0  2121					      IND		; we just got a pid
      0  2121					      db	20
      1  2121		       14		      .byte.b	20
      0  2122					      TSTVT	ERRVEC2	; if it is not another variabe then error, Call test var. task
      0  2122					      db	93
      1  2122		       5d		      .byte.b	93
      0  2123					      db	(ERRVEC2-*)-1
      1  2123		       da		      .byte.b	(ERRVEC2-*)-1
    152  2124				   eDoDec
      0  2124					      DECVAR		; Decrement the actual variable
      0  2124					      db	99
      1  2124		       63		      .byte.b	99
      0  2125					      DONE		; Test if end of line or : statement
      0  2125					      db	1
      1  2125		       01		      .byte.b	1
      0  2126					      NXT	CO	; If at end of program then got the console
      0  2126					      db	6
      1  2126		       06		      .byte.b	6
      0  2127					      dw	CO
      1  2127		       d1 20		      .word.w	CO
      0  2129					      IJMP	STMT	; Process the next statement of command line
      0  2129					      db	29
      1  2129		       1d		      .byte.b	29
      0  212a					      dw	STMT
      1  212a		       d9 20		      .word.w	STMT
    157  212c							;=============================================================================================================================
    158  212c							; iret or ireturn, Return from interupt process
    159  212c							;
    160  212c				   S1Iret
      0  212c					      TSTB	S1S1,kIreturn	; test return from interupt
      0  212c					      db	101
      1  212c		       65		      .byte.b	101
      0  212d					      db	(S1S1-*)-1
      1  212d		       06		      .byte.b	(S1S1-*)-1
      0  212e					      db	kIreturn
      1  212e		       04		      .byte.b	kIreturn
    162  212f				   S1Sa
    163  212f				   ekIreturn
      0  212f					      DONE		; Must be only thing on the line
      0  212f					      db	1
      1  212f		       01		      .byte.b	1
      0  2130					      IRET		; RESTORE LINE NUMBER OF CALL
      0  2130					      db	58
      1  2130		       3a		      .byte.b	58
      0  2131					      IJMP	STMT
      0  2131					      db	29
      1  2131		       1d		      .byte.b	29
      0  2132					      dw	STMT
      1  2132		       d9 20		      .word.w	STMT
    167  2134							;==============================================================================================================================
    168  2134							;Process if statement, if true then process all statements until end of line reached
    169  2134				   S1S1
      0  2134					      TSTB	S1Z,kIf	; IF STATEMENT
      0  2134					      db	101
      1  2134		       65		      .byte.b	101
      0  2135					      db	(S1Z-*)-1
      1  2135		       0b		      .byte.b	(S1Z-*)-1
      0  2136					      db	kIf
      1  2136		       05		      .byte.b	kIf
    171  2137				   ekIf
      0  2137					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  2137					      db	28
      1  2137		       1c		      .byte.b	28
      0  2138					      dw	EXPR
      1  2138		       f8 22		      .word.w	EXPR
      0  213a					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  213a					      db	101
      1  213a		       65		      .byte.b	101
      0  213b					      db	(S1W-*)-1
      1  213b		       01		      .byte.b	(S1W-*)-1
      0  213c					      db	kThen
      1  213c		       06		      .byte.b	kThen
    174  213d				   ekThen
    175  213d				   S1W
      0  213d					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  213d					      db	54
      1  213d		       36		      .byte.b	54
      0  213e					      IJMP	STMT
      0  213e					      db	29
      1  213e		       1d		      .byte.b	29
      0  213f					      dw	STMT
      1  213f		       d9 20		      .word.w	STMT
    178  2141							;===============================================================================================================================
    179  2141							; Test for GOTO
    180  2141				   S1Z
      0  2141					      TSTB	S2,kGoto	; YES...TO, OR...SUB
      0  2141					      db	101
      1  2141		       65		      .byte.b	101
      0  2142					      db	(S2-*)-1
      1  2142		       0c		      .byte.b	(S2-*)-1
      0  2143					      db	kGoto
      1  2143		       07		      .byte.b	kGoto
    182  2144				   ekGoto
      0  2144					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  2144					      db	101
      1  2144		       65		      .byte.b	101
      0  2145					      db	(ekGotoLine-*)-1
      1  2145		       05		      .byte.b	(ekGotoLine-*)-1
      0  2146					      db	oPeriod
      1  2146		       e9		      .byte.b	oPeriod
      0  2147					      REPEATLINE		; Repeat the same line again
      0  2147					      db	105
      1  2147		       69		      .byte.b	105
      0  2148					      IJMP	STMT	; Go do the statement
      0  2148					      db	29
      1  2148		       1d		      .byte.b	29
      0  2149					      dw	STMT
      1  2149		       d9 20		      .word.w	STMT
    186  214b
    187  214b				   ekGotoLine
      0  214b					      CALL	EXPR	; GET LABEL
      0  214b					      db	28
      1  214b		       1c		      .byte.b	28
      0  214c					      dw	EXPR
      1  214c		       f8 22		      .word.w	EXPR
      0  214e					      XFER		; SET UP AND JUMP
      0  214e					      db	7
      1  214e		       07		      .byte.b	7
    190  214f
    191  214f							;===============================================================================================================================
    192  214f							; Process gosub / function
    193  214f							;
    194  214f				   S2
      0  214f					      TSTB	S2b,kGosub	; ERROR IF NO MATCH
      0  214f					      db	101
      1  214f		       65		      .byte.b	101
      0  2150					      db	(S2b-*)-1
      1  2150		       08		      .byte.b	(S2b-*)-1
      0  2151					      db	kGosub
      1  2151		       08		      .byte.b	kGosub
    196  2152				   ekGosub
      0  2152					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  2152					      db	28
      1  2152		       1c		      .byte.b	28
      0  2153					      dw	GOSUBSTATEMENT
      1  2153		       83 24		      .word.w	GOSUBSTATEMENT
      0  2155					      DONE		; ERROR IF CR NOT NEXT
      0  2155					      db	1
      1  2155		       01		      .byte.b	1
      0  2156					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  2156					      db	8
      1  2156		       08		      .byte.b	8
      0  2157					      db	GOSUB_RTN
      1  2157		       01		      .byte.b	GOSUB_RTN
      0  2158					      XFER		; AND JUMP to sub rtn
      0  2158					      db	7
      1  2158		       07		      .byte.b	7
    201  2159							;
    202  2159							; End of gosub processing
    203  2159							;===============================================================================================================================
    204  2159							; Return from a gosub
    205  2159				   S2b
      0  2159					      TSTB	S2a,kReturn	; Speed up pocessing but more memory
      0  2159					      db	101
      1  2159		       65		      .byte.b	101
      0  215a					      db	(S2a-*)-1
      1  215a		       1e		      .byte.b	(S2a-*)-1
      0  215b					      db	kReturn
      1  215b		       09		      .byte.b	kReturn
    207  215c				   ekReturn
      0  215c					      SETR2	0	; Default no return value
      0  215c					      db	94
      1  215c		       5e		      .byte.b	94
      0  215d					      db	0
      1  215d		       00		      .byte.b	0
      0  215e					      TSTB	S2RetDone,oLeftBracket	; Check if we will return some value
      0  215e					      db	101
      1  215e		       65		      .byte.b	101
      0  215f					      db	(S2RetDone-*)-1
      1  215f		       09		      .byte.b	(S2RetDone-*)-1
      0  2160					      db	oLeftBracket
      1  2160		       e0		      .byte.b	oLeftBracket
      0  2161					      SETR2	1	; Indicate a return value provided
      0  2161					      db	94
      1  2161		       5e		      .byte.b	94
      0  2162					      db	1
      1  2162		       01		      .byte.b	1
      0  2163					      CALL	EXPR
      0  2163					      db	28
      1  2163		       1c		      .byte.b	28
      0  2164					      dw	EXPR
      1  2164		       f8 22		      .word.w	EXPR
      0  2166					      TSTB	ERRVEC2,oRightBracket	; Now a value is on the stack
      0  2166					      db	101
      1  2166		       65		      .byte.b	101
      0  2167					      db	(ERRVEC2-*)-1
      1  2167		       96		      .byte.b	(ERRVEC2-*)-1
      0  2168					      db	oRightBracket
      1  2168		       e1		      .byte.b	oRightBracket
    213  2169
    214  2169				   S2RetDone
      0  2169					      DONE		; MUST BE CR or :
      0  2169					      db	1
      1  2169		       01		      .byte.b	1
      0  216a					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  216a					      db	9
      1  216a		       09		      .byte.b	9
      0  216b					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  216b					      db	97
      1  216b		       61		      .byte.b	97
      0  216c					      db	(S2RetFunc-*)-1
      1  216c		       09		      .byte.b	(S2RetFunc-*)-1
      0  216d					      dw	R2
      1  216d		       58 00		      .word.w	R2
      0  216f					      db	1
      1  216f		       01		      .byte.b	1
      0  2170					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  2170					      db	6
      1  2170		       06		      .byte.b	6
      0  2171					      dw	CO
      1  2171		       d1 20		      .word.w	CO
      0  2173					      IJMP	STMT	; Process the new statement
      0  2173					      db	29
      1  2173		       1d		      .byte.b	29
      0  2174					      dw	STMT
      1  2174		       d9 20		      .word.w	STMT
    220  2176				   S2RetFunc
      0  2176					      IJMP	GOFNRet	; Back into the Function
      0  2176					      db	29
      1  2176		       1d		      .byte.b	29
      0  2177					      dw	GOFNRet
      1  2177		       5d 24		      .word.w	GOFNRet
    222  2179							;
    223  2179							; End of return from gosub
    224  2179							;==================================================================================================================================
    225  2179							; Process REM statement
    226  2179							;
    227  2179				   S2a
      0  2179					      TSTB	S3,kRem	; REMark.  Skip rest of line
      0  2179					      db	101
      1  2179		       65		      .byte.b	101
      0  217a					      db	(S3-*)-1
      1  217a		       07		      .byte.b	(S3-*)-1
      0  217b					      db	kRem
      1  217b		       0a		      .byte.b	kRem
    229  217c				   ekRem
      0  217c					      NXT	CO	; The rest of the line is ignored
      0  217c					      db	6
      1  217c		       06		      .byte.b	6
      0  217d					      dw	CO
      1  217d		       d1 20		      .word.w	CO
      0  217f					      IJMP	STMT	; Process the next statement
      0  217f					      db	29
      1  217f		       1d		      .byte.b	29
      0  2180					      dw	STMT
      1  2180		       d9 20		      .word.w	STMT
    232  2182							;==================================================================================================================================
    233  2182							; Print statement
    234  2182							;
    235  2182				   S3
      0  2182					      TSTB	S8,kPrint	; ? or Print symonym for print
      0  2182					      db	101
      1  2182		       65		      .byte.b	101
      0  2183					      db	(S8-*)-1
      1  2183		       4e		      .byte.b	(S8-*)-1
      0  2184					      db	kPrint
      1  2184		       0b		      .byte.b	kPrint
    237  2185				   ekPrint
      0  2185					      STARTIO		; Lock task until io completes
      0  2185					      db	70
      1  2185		       46		      .byte.b	70
    239  2186				   S4
      0  2186					      TSTDONE	S4a	; Test if we just want crlf printed
      0  2186					      db	50
      1  2186		       32		      .byte.b	50
      0  2187					      db	(S4a-*)-1
      1  2187		       03		      .byte.b	(S4a-*)-1
      0  2188					      IJMP	S6
      0  2188					      db	29
      1  2188		       1d		      .byte.b	29
      0  2189					      dw	S6
      1  2189		       a0 21		      .word.w	S6
    242  218b
    243  218b				   S4a
      0  218b					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  218b					      db	101
      1  218b		       65		      .byte.b	101
      0  218c					      db	(S7-*)-1
      1  218c		       1f		      .byte.b	(S7-*)-1
      0  218d					      db	tString
      1  218d		       a0		      .byte.b	tString
      0  218e					      PRS		; PRINT STRING
      0  218e					      db	2
      1  218e		       02		      .byte.b	2
    246  218f				   S5
      0  218f					      TSTB	S6A,oComma	; IS THERE MORE?
      0  218f					      db	101
      1  218f		       65		      .byte.b	101
      0  2190					      db	(S6A-*)-1
      1  2190		       07		      .byte.b	(S6A-*)-1
      0  2191					      db	oComma
      1  2191		       e2		      .byte.b	oComma
      0  2192					      SPC		; SPACE TO NEXT ZONE
      0  2192					      db	4
      1  2192		       04		      .byte.b	4
      0  2193					      TSTDONE	S4	; Not end of line jump back
      0  2193					      db	50
      1  2193		       32		      .byte.b	50
      0  2194					      db	(S4-*)-1
      1  2194		       f1		      .byte.b	(S4-*)-1
      0  2195					      IJMP	S6Z	; YES JUMP BACK
      0  2195					      db	29
      1  2195		       1d		      .byte.b	29
      0  2196					      dw	S6Z
      1  2196		       a2 21		      .word.w	S6Z
    251  2198
    252  2198							;
    253  2198							; If a semicolon, don't do anything.
    254  2198							;
    255  2198				   S6A
      0  2198					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  2198					      db	101
      1  2198		       65		      .byte.b	101
      0  2199					      db	(S6-*)-1
      1  2199		       06		      .byte.b	(S6-*)-1
      0  219a					      db	oSemiColon
      1  219a		       e3		      .byte.b	oSemiColon
      0  219b					      TSTDONE	S4	; Jump Back if not end of line
      0  219b					      db	50
      1  219b		       32		      .byte.b	50
      0  219c					      db	(S4-*)-1
      1  219c		       e9		      .byte.b	(S4-*)-1
      0  219d					      IJMP	S6Z
      0  219d					      db	29
      1  219d		       1d		      .byte.b	29
      0  219e					      dw	S6Z
      1  219e		       a2 21		      .word.w	S6Z
    259  21a0
    260  21a0				   S6
    261  21a0
      0  21a0					      DONE		; ERROR IF CR NOT NEXT
      0  21a0					      db	1
      1  21a0		       01		      .byte.b	1
      0  21a1					      NLINE
      0  21a1					      db	5
      1  21a1		       05		      .byte.b	5
    264  21a2				   S6Z
      0  21a2					      ENDIO		; release task io completed
      0  21a2					      db	71
      1  21a2		       47		      .byte.b	71
      0  21a3					      NXT	CO	; exit here if , or ; at end of print
      0  21a3					      db	6
      1  21a3		       06		      .byte.b	6
      0  21a4					      dw	CO
      1  21a4		       d1 20		      .word.w	CO
      0  21a6					      IJMP	STMT
      0  21a6					      db	29
      1  21a6		       1d		      .byte.b	29
      0  21a7					      dw	STMT
      1  21a7		       d9 20		      .word.w	STMT
    268  21a9							;
    269  21a9							; A jump for code too far away for relative branch
    270  21a9							;
    271  21a9				   ERRVEC
      0  21a9					      IJMP	UNKNOWN
      0  21a9					      db	29
      1  21a9		       1d		      .byte.b	29
      0  21aa					      dw	UNKNOWN
      1  21aa		       f4 22		      .word.w	UNKNOWN
    273  21ac							;
    274  21ac							; Get here if there is an expression to print
    275  21ac				   S7
      0  21ac					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  21ac					      db	101
      1  21ac		       65		      .byte.b	101
      0  21ad					      db	(S7AUnsigned-*)-1
      1  21ad		       08		      .byte.b	(S7AUnsigned-*)-1
      0  21ae					      db	oDollar
      1  21ae		       e7		      .byte.b	oDollar
      0  21af					      CALL	EXPR
      0  21af					      db	28
      1  21af		       1c		      .byte.b	28
      0  21b0					      dw	EXPR
      1  21b0		       f8 22		      .word.w	EXPR
      0  21b2					      HEXPRT
      0  21b2					      db	67
      1  21b2		       43		      .byte.b	67
      0  21b3					      IJMP	S5
      0  21b3					      db	29
      1  21b3		       1d		      .byte.b	29
      0  21b4					      dw	S5
      1  21b4		       8f 21		      .word.w	S5
    280  21b6
    281  21b6				   S7AUnsigned
    282  21b6
      0  21b6					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  21b6					      db	101
      1  21b6		       65		      .byte.b	101
      0  21b7					      db	(S7A-*)-1
      1  21b7		       0a		      .byte.b	(S7A-*)-1
      0  21b8					      db	oPercent
      1  21b8		       ed		      .byte.b	oPercent
      0  21b9					      CALL	EXPR
      0  21b9					      db	28
      1  21b9		       1c		      .byte.b	28
      0  21ba					      dw	EXPR
      1  21ba		       f8 22		      .word.w	EXPR
      0  21bc					      SETR2	1
      0  21bc					      db	94
      1  21bc		       5e		      .byte.b	94
      0  21bd					      db	1
      1  21bd		       01		      .byte.b	1
      0  21be					      PRN
      0  21be					      db	3
      1  21be		       03		      .byte.b	3
      0  21bf					      IJMP	S5
      0  21bf					      db	29
      1  21bf		       1d		      .byte.b	29
      0  21c0					      dw	S5
      1  21c0		       8f 21		      .word.w	S5
    288  21c2
    289  21c2				   S7A
    290  21c2
      0  21c2					      CALL	EXPR
      0  21c2					      db	28
      1  21c2		       1c		      .byte.b	28
      0  21c3					      dw	EXPR
      1  21c3		       f8 22		      .word.w	EXPR
      0  21c5					      TSTB	S7B,oDollar	; Print the value as a single character
      0  21c5					      db	101
      1  21c5		       65		      .byte.b	101
      0  21c6					      db	(S7B-*)-1
      1  21c6		       05		      .byte.b	(S7B-*)-1
      0  21c7					      db	oDollar
      1  21c7		       e7		      .byte.b	oDollar
      0  21c8					      PUTCHAR
      0  21c8					      db	52
      1  21c8		       34		      .byte.b	52
      0  21c9					      IJMP	S5
      0  21c9					      db	29
      1  21c9		       1d		      .byte.b	29
      0  21ca					      dw	S5
      1  21ca		       8f 21		      .word.w	S5
    295  21cc
    296  21cc				   S7B
      0  21cc					      SETR2	0	; Print the value as a signed number
      0  21cc					      db	94
      1  21cc		       5e		      .byte.b	94
      0  21cd					      db	0
      1  21cd		       00		      .byte.b	0
      0  21ce					      PRN		; PRINT IT
      0  21ce					      db	3
      1  21ce		       03		      .byte.b	3
      0  21cf					      IJMP	S5	; IS THERE MORE?
      0  21cf					      db	29
      1  21cf		       1d		      .byte.b	29
      0  21d0					      dw	S5
      1  21d0		       8f 21		      .word.w	S5
    300  21d2							;
    301  21d2							;===========================================================
    302  21d2							; PROCESS ALL THE TAST STATEMENTS
    303  21d2							;
    304  21d2				   S8
      0  21d2					      TSTB	S8G,kTaske	; End Task
      0  21d2					      db	101
      1  21d2		       65		      .byte.b	101
      0  21d3					      db	(S8G-*)-1
      1  21d3		       17		      .byte.b	(S8G-*)-1
      0  21d4					      db	kTaske
      1  21d4		       0c		      .byte.b	kTaske
    306  21d5				   ekTaske
      0  21d5					      TSTB	S8NoParm,oLeftBracket
      0  21d5					      db	101
      1  21d5		       65		      .byte.b	101
      0  21d6					      db	(S8NoParm-*)-1
      1  21d6		       0c		      .byte.b	(S8NoParm-*)-1
      0  21d7					      db	oLeftBracket
      1  21d7		       e0		      .byte.b	oLeftBracket
      0  21d8					      CALL	EXPR
      0  21d8					      db	28
      1  21d8		       1c		      .byte.b	28
      0  21d9					      dw	EXPR
      1  21d9		       f8 22		      .word.w	EXPR
      0  21db					      TSTB	UNKNOWNLnk,oRightBracket
      0  21db					      db	101
      1  21db		       65		      .byte.b	101
      0  21dc					      db	(UNKNOWNLnk-*)-1
      1  21dc		       33		      .byte.b	(UNKNOWNLnk-*)-1
      0  21dd					      db	oRightBracket
      1  21dd		       e1		      .byte.b	oRightBracket
      0  21de					      ETASK
      0  21de					      db	62
      1  21de		       3e		      .byte.b	62
      0  21df					      DONE
      0  21df					      db	1
      1  21df		       01		      .byte.b	1
      0  21e0					      IJMP	STMT
      0  21e0					      db	29
      1  21e0		       1d		      .byte.b	29
      0  21e1					      dw	STMT
      1  21e1		       d9 20		      .word.w	STMT
    313  21e3				   S8NoParm
      0  21e3					      LIT	0
      0  21e3					      db	27
      1  21e3		       1b		      .byte.b	27
      0  21e4					      dw	0
      1  21e4		       00 00		      .word.w	0
      0  21e6					      ETASK
      0  21e6					      db	62
      1  21e6		       3e		      .byte.b	62
      0  21e7					      DONE		; Must be last thing on a line
      0  21e7					      db	1
      1  21e7		       01		      .byte.b	1
      0  21e8					      IJMP	STMT
      0  21e8					      db	29
      1  21e8		       1d		      .byte.b	29
      0  21e9					      dw	STMT
      1  21e9		       d9 20		      .word.w	STMT
    318  21eb							;
    319  21eb							;===========================================================
    320  21eb							; The task gives up the rest of the cycles
    321  21eb				   S8G
      0  21eb					      TSTB	S8a,kTaskn	;Next task
      0  21eb					      db	101
      1  21eb		       65		      .byte.b	101
      0  21ec					      db	(S8a-*)-1
      1  21ec		       08		      .byte.b	(S8a-*)-1
      0  21ed					      db	kTaskn
      1  21ed		       0d		      .byte.b	kTaskn
    323  21ee				   ekTaskn
      0  21ee					      NTASK
      0  21ee					      db	63
      1  21ee		       3f		      .byte.b	63
      0  21ef					      NXT	CO	;Next statement to execute
      0  21ef					      db	6
      1  21ef		       06		      .byte.b	6
      0  21f0					      dw	CO
      1  21f0		       d1 20		      .word.w	CO
      0  21f2					      IJMP	STMT
      0  21f2					      db	29
      1  21f2		       1d		      .byte.b	29
      0  21f3					      dw	STMT
      1  21f3		       d9 20		      .word.w	STMT
    327  21f5							;
    328  21f5							;===========================================================
    329  21f5							; Waits for a task or list of tasks to complete
    330  21f5				   S8a
      0  21f5					      TSTB	S8a1,kTaskw	;Wait for tasks
      0  21f5					      db	101
      1  21f5		       65		      .byte.b	101
      0  21f6					      db	(S8a1-*)-1
      1  21f6		       1c		      .byte.b	(S8a1-*)-1
      0  21f7					      db	kTaskw
      1  21f7		       0e		      .byte.b	kTaskw
    332  21f8				   ekTaskw
      0  21f8					      TSTB	UNKNOWNLnk,oLeftBracket
      0  21f8					      db	101
      1  21f8		       65		      .byte.b	101
      0  21f9					      db	(UNKNOWNLnk-*)-1
      1  21f9		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  21fa					      db	oLeftBracket
      1  21fa		       e0		      .byte.b	oLeftBracket
    334  21fb				   S8TSK
      0  21fb					      Call	EXPR	;Gets the PID of task to wait for
      0  21fb					      db	28
      1  21fb		       1c		      .byte.b	28
      0  21fc					      dw	EXPR
      1  21fc		       f8 22		      .word.w	EXPR
    336  21fe				   S8LOOP
      0  21fe					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  21fe					      db	76
      1  21fe		       4c		      .byte.b	76
      0  21ff					      db	(S8LOOP-*)-1
      1  21ff		       fe		      .byte.b	(S8LOOP-*)-1
      0  2200					      TSTB	S8aa,oComma	;Checks for more tasks
      0  2200					      db	101
      1  2200		       65		      .byte.b	101
      0  2201					      db	(S8aa-*)-1
      1  2201		       04		      .byte.b	(S8aa-*)-1
      0  2202					      db	oComma
      1  2202		       e2		      .byte.b	oComma
      0  2203					      IJMP	S8TSK	;Go for the next task number
      0  2203					      db	29
      1  2203		       1d		      .byte.b	29
      0  2204					      dw	S8TSK
      1  2204		       fb 21		      .word.w	S8TSK
    340  2206				   S8aa
      0  2206					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  2206					      db	101
      1  2206		       65		      .byte.b	101
      0  2207					      db	(UNKNOWNLnk-*)-1
      1  2207		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  2208					      db	oRightBracket
      1  2208		       e1		      .byte.b	oRightBracket
      0  2209					      DONE
      0  2209					      db	1
      1  2209		       01		      .byte.b	1
      0  220a					      NXT	CO
      0  220a					      db	6
      1  220a		       06		      .byte.b	6
      0  220b					      dw	CO
      1  220b		       d1 20		      .word.w	CO
      0  220d					      IJMP	STMT	;Next Statement
      0  220d					      db	29
      1  220d		       1d		      .byte.b	29
      0  220e					      dw	STMT
      1  220e		       d9 20		      .word.w	STMT
    345  2210
    346  2210
    347  2210
    348  2210				   UNKNOWNLnk
      0  2210					      iJMP	UNKNOWN
      0  2210					      db	29
      1  2210		       1d		      .byte.b	29
      0  2211					      dw	UNKNOWN
      1  2211		       f4 22		      .word.w	UNKNOWN
    350  2213
    351  2213							;
    352  2213							;===========================================================
    353  2213							; Update a memory location with a value
    354  2213							;  Use @[offset] to write a word value to memory
    355  2213							;
    356  2213				   S8a1
      0  2213					      TSTB	S8b,kPoke	; Poke a value into memory
      0  2213					      db	101
      1  2213		       65		      .byte.b	101
      0  2214					      db	(S8b-*)-1
      1  2214		       18		      .byte.b	(S8b-*)-1
      0  2215					      db	kPoke
      1  2215		       0f		      .byte.b	kPoke
    358  2216				   ekPoke
      0  2216					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  2216					      db	101
      1  2216		       65		      .byte.b	101
      0  2217					      db	(UNKNOWNV-*)-1
      1  2217		       56		      .byte.b	(UNKNOWNV-*)-1
      0  2218					      db	oLeftBracket
      1  2218		       e0		      .byte.b	oLeftBracket
      0  2219					      CALL	EXPR	; Get address to write to
      0  2219					      db	28
      1  2219		       1c		      .byte.b	28
      0  221a					      dw	EXPR
      1  221a		       f8 22		      .word.w	EXPR
      0  221c					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  221c					      db	101
      1  221c		       65		      .byte.b	101
      0  221d					      db	(UNKNOWNV-*)-1
      1  221d		       50		      .byte.b	(UNKNOWNV-*)-1
      0  221e					      db	oComma
      1  221e		       e2		      .byte.b	oComma
      0  221f					      CALL	EXPR	; Get the value to poke
      0  221f					      db	28
      1  221f		       1c		      .byte.b	28
      0  2220					      dw	EXPR
      1  2220		       f8 22		      .word.w	EXPR
      0  2222					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  2222					      db	101
      1  2222		       65		      .byte.b	101
      0  2223					      db	(UNKNOWNV-*)-1
      1  2223		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  2224					      db	oRightBracket
      1  2224		       e1		      .byte.b	oRightBracket
      0  2225					      POKEMEM
      0  2225					      db	47
      1  2225		       2f		      .byte.b	47
      0  2226					      DONE
      0  2226					      db	1
      1  2226		       01		      .byte.b	1
      0  2227					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2227					      db	6
      1  2227		       06		      .byte.b	6
      0  2228					      dw	CO
      1  2228		       d1 20		      .word.w	CO
      0  222a					      IJMP	STMT
      0  222a					      db	29
      1  222a		       1d		      .byte.b	29
      0  222b					      dw	STMT
      1  222b		       d9 20		      .word.w	STMT
    368  222d							;================================================================
    369  222d							; Write a single byte to the output device
    370  222d							;
    371  222d				   S8b
      0  222d					      TSTB	S8c,kPutch	;Put a char to the terminal
      0  222d					      db	101
      1  222d		       65		      .byte.b	101
      0  222e					      db	(S8c-*)-1
      1  222e		       0c		      .byte.b	(S8c-*)-1
      0  222f					      db	kPutch
      1  222f		       10		      .byte.b	kPutch
    373  2230				   ekPutch
      0  2230					      CALL	EXPR
      0  2230					      db	28
      1  2230		       1c		      .byte.b	28
      0  2231					      dw	EXPR
      1  2231		       f8 22		      .word.w	EXPR
      0  2233					      PUTCHAR
      0  2233					      db	52
      1  2233		       34		      .byte.b	52
      0  2234					      DONE
      0  2234					      db	1
      1  2234		       01		      .byte.b	1
      0  2235					      NXT	CO	;AND SEQUENCE TO NEXT
      0  2235					      db	6
      1  2235		       06		      .byte.b	6
      0  2236					      dw	CO
      1  2236		       d1 20		      .word.w	CO
      0  2238					      IJMP	STMT
      0  2238					      db	29
      1  2238		       1d		      .byte.b	29
      0  2239					      dw	STMT
      1  2239		       d9 20		      .word.w	STMT
    379  223b							;================================================================
    380  223b							; Clear the screen lines
    381  223b							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    382  223b							;
    383  223b				   S8c
      0  223b					      TSTB	S9,kCls	;Clear the screen
      0  223b					      db	101
      1  223b		       65		      .byte.b	101
      0  223c					      db	(S9-*)-1
      1  223c		       08		      .byte.b	(S9-*)-1
      0  223d					      db	kCls
      1  223d		       11		      .byte.b	kCls
    385  223e				   ekCls
      0  223e					      CLEARSCREEN
      0  223e					      db	46
      1  223e		       2e		      .byte.b	46
      0  223f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  223f					      db	6
      1  223f		       06		      .byte.b	6
      0  2240					      dw	CO
      1  2240		       d1 20		      .word.w	CO
      0  2242					      IJMP	STMT
      0  2242					      db	29
      1  2242		       1d		      .byte.b	29
      0  2243					      dw	STMT
      1  2243		       d9 20		      .word.w	STMT
    389  2245							;==================================================================
    390  2245							; Get input from the terminal
    391  2245							;   Reads from the currently active input device
    392  2245							;
    393  2245				   S9
      0  2245					      TSTB	S13,kInput	;INPUT STATEMENT
      0  2245					      db	101
      1  2245		       65		      .byte.b	101
      0  2246					      db	(S13-*)-1
      1  2246		       23		      .byte.b	(S13-*)-1
      0  2247					      db	kInput
      1  2247		       12		      .byte.b	kInput
    395  2248				   ekInput
    396  2248				   S10
      0  2248					      TSTB	S10A,tString	;If there is a string print the prompt
      0  2248					      db	101
      1  2248		       65		      .byte.b	101
      0  2249					      db	(S10A-*)-1
      1  2249		       05		      .byte.b	(S10A-*)-1
      0  224a					      db	tString
      1  224a		       a0		      .byte.b	tString
      0  224b					      PRS
      0  224b					      db	2
      1  224b		       02		      .byte.b	2
      0  224c					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  224c					      db	101
      1  224c		       65		      .byte.b	101
      0  224d					      db	(S10Z-*)-1
      1  224d		       12		      .byte.b	(S10Z-*)-1
      0  224e					      db	oSemiColon
      1  224e		       e3		      .byte.b	oSemiColon
    400  224f				   S10A
      0  224f					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  224f					      db	33
      1  224f		       21		      .byte.b	33
      0  2250					      db	(UNKNOWN-*)-1
      1  2250		       a3		      .byte.b	(UNKNOWN-*)-1
      0  2251					      TSTB	S10A1,oDollar
      0  2251					      db	101
      1  2251		       65		      .byte.b	101
      0  2252					      db	(S10A1-*)-1
      1  2252		       05		      .byte.b	(S10A1-*)-1
      0  2253					      db	oDollar
      1  2253		       e7		      .byte.b	oDollar
      0  2254					      INSTR		;Move character From tty to AESTK
      0  2254					      db	59
      1  2254		       3b		      .byte.b	59
      0  2255					      IJMP	S10A2
      0  2255					      db	29
      1  2255		       1d		      .byte.b	29
      0  2256					      dw	S10A2
      1  2256		       59 22		      .word.w	S10A2
    405  2258				   S10A1
      0  2258					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  2258					      db	11
      1  2258		       0b		      .byte.b	11
    407  2259				   S10A2
      0  2259					      STORE		;STORE IT
      0  2259					      db	19
      1  2259		       13		      .byte.b	19
      0  225a					      TSTB	S11,oComma	;IS THERE MORE?
      0  225a					      db	101
      1  225a		       65		      .byte.b	101
      0  225b					      db	(S11-*)-1
      1  225b		       07		      .byte.b	(S11-*)-1
      0  225c					      db	oComma
      1  225c		       e2		      .byte.b	oComma
      0  225d					      IJMP	S10	;YES
      0  225d					      db	29
      1  225d		       1d		      .byte.b	29
      0  225e					      dw	S10
      1  225e		       48 22		      .word.w	S10
    411  2260				   S10Z
      0  2260					      iJMP	UNKNOWN
      0  2260					      db	29
      1  2260		       1d		      .byte.b	29
      0  2261					      dw	UNKNOWN
      1  2261		       f4 22		      .word.w	UNKNOWN
    413  2263				   S11
      0  2263					      DONE		;MUST BE CR
      0  2263					      db	1
      1  2263		       01		      .byte.b	1
      0  2264					      NXT	CO	;SEQUENCE TO NEXT
      0  2264					      db	6
      1  2264		       06		      .byte.b	6
      0  2265					      dw	CO
      1  2265		       d1 20		      .word.w	CO
      0  2267					      IJMP	STMT
      0  2267					      db	29
      1  2267		       1d		      .byte.b	29
      0  2268					      dw	STMT
      1  2268		       d9 20		      .word.w	STMT
    417  226a							;=====================================================================
    418  226a							; End of program, return to command line process
    419  226a							; Main Task may also use taske or return to stopped
    420  226a							;
    421  226a				   S13
      0  226a					      TSTB	S14,kEnd
      0  226a					      db	101
      1  226a		       65		      .byte.b	101
      0  226b					      db	(S14-*)-1
      1  226b		       05		      .byte.b	(S14-*)-1
      0  226c					      db	kEnd
      1  226c		       13		      .byte.b	kEnd
    423  226d				   ekEnd
      0  226d					      FIN
      0  226d					      db	12
      1  226d		       0c		      .byte.b	12
    425  226e
    426  226e				   UNKNOWNV
      0  226e					      IJMP	UNKNOWN
      0  226e					      db	29
      1  226e		       1d		      .byte.b	29
      0  226f					      dw	UNKNOWN
      1  226f		       f4 22		      .word.w	UNKNOWN
    428  2271							;====================================================================
    429  2271							; IRQ <IRQ-HANDLER-Line expression>
    430  2271							;   Specify a line number subroutine to call when an interupt is processed
    431  2271							;   These subroutines must use iret to return.
    432  2271							;
    433  2271				   S14
      0  2271					      TSTB	S14Z,kIrq	;Check if we are setting IRQ HANDLER
      0  2271					      db	101
      1  2271		       65		      .byte.b	101
      0  2272					      db	(S14Z-*)-1
      1  2272		       0c		      .byte.b	(S14Z-*)-1
      0  2273					      db	kIrq
      1  2273		       14		      .byte.b	kIrq
    435  2274				   ekIrq
      0  2274					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  2274					      db	28
      1  2274		       1c		      .byte.b	28
      0  2275					      dw	EXPR
      1  2275		       f8 22		      .word.w	EXPR
      0  2277					      DONE		;must be CR
      0  2277					      db	1
      1  2277		       01		      .byte.b	1
      0  2278					      SETIRQ		;Set the line number now
      0  2278					      db	56
      1  2278		       38		      .byte.b	56
      0  2279					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  2279					      db	6
      1  2279		       06		      .byte.b	6
      0  227a					      dw	CO
      1  227a		       d1 20		      .word.w	CO
      0  227c					      IJMP	STMT
      0  227c					      db	29
      1  227c		       1d		      .byte.b	29
      0  227d					      dw	STMT
      1  227d		       d9 20		      .word.w	STMT
    441  227f
    442  227f							;=========================================================================
    443  227f							; KILL PID-expression	 kill a running task
    444  227f							;  ignored of task has already stopped
    445  227f							;
    446  227f				   S14Z
      0  227f					      TSTB	S14S1,kKill	; Kill A running Task
      0  227f					      db	101
      1  227f		       65		      .byte.b	101
      0  2280					      db	(S14S1-*)-1
      1  2280		       0c		      .byte.b	(S14S1-*)-1
      0  2281					      db	kKill
      1  2281		       15		      .byte.b	kKill
    448  2282				   ekKill
      0  2282					      CALL	EXPR
      0  2282					      db	28
      1  2282		       1c		      .byte.b	28
      0  2283					      dw	EXPR
      1  2283		       f8 22		      .word.w	EXPR
      0  2285					      DONE
      0  2285					      db	1
      1  2285		       01		      .byte.b	1
      0  2286					      TASKKILL
      0  2286					      db	65
      1  2286		       41		      .byte.b	65
      0  2287					      NXT	CO
      0  2287					      db	6
      1  2287		       06		      .byte.b	6
      0  2288					      dw	CO
      1  2288		       d1 20		      .word.w	CO
      0  228a					      IJMP	STMT
      0  228a					      db	29
      1  228a		       1d		      .byte.b	29
      0  228b					      dw	STMT
      1  228b		       d9 20		      .word.w	STMT
    454  228d
    455  228d							;============================================================================
    456  228d							; List all program lines
    457  228d							;
    458  228d				   S14S1
      0  228d					      TSTB	S15,kList	;LIST COMMAND
      0  228d					      db	101
      1  228d		       65		      .byte.b	101
      0  228e					      db	(S15-*)-1
      1  228e		       06		      .byte.b	(S15-*)-1
      0  228f					      db	kList
      1  228f		       16		      .byte.b	kList
    460  2290				   ekList
      0  2290					      DONE
      0  2290					      db	1
      1  2290		       01		      .byte.b	1
      0  2291					      LST
      0  2291					      db	21
      1  2291		       15		      .byte.b	21
      0  2292					      IJMP	CO
      0  2292					      db	29
      1  2292		       1d		      .byte.b	29
      0  2293					      dw	CO
      1  2293		       d1 20		      .word.w	CO
    464  2295							;=======================================================================
    465  2295							;RUN begin to executed the program in memory
    466  2295							;
    467  2295				   S15
      0  2295					      TSTB	S16,kRun	;RUN COMMAND
      0  2295					      db	101
      1  2295		       65		      .byte.b	101
      0  2296					      db	(S16-*)-1
      1  2296		       0a		      .byte.b	(S16-*)-1
      0  2297					      db	kRun
      1  2297		       17		      .byte.b	kRun
    469  2298				   ekRun
      0  2298					      DONE
      0  2298					      db	1
      1  2298		       01		      .byte.b	1
      0  2299					      VINIT		;clear variables
      0  2299					      db	30
      1  2299		       1e		      .byte.b	30
      0  229a					      LIT	1	;GOTO line 1
      0  229a					      db	27
      1  229a		       1b		      .byte.b	27
      0  229b					      dw	1
      1  229b		       01 00		      .word.w	1
      0  229d					      XFER		;Bob's addition
      0  229d					      db	7
      1  229d		       07		      .byte.b	7
    474  229e							; EXIT
      0  229e					      IJMP	STMT	;and run!
      0  229e					      db	29
      1  229e		       1d		      .byte.b	29
      0  229f					      dw	STMT
      1  229f		       d9 20		      .word.w	STMT
    476  22a1							;=========================================================================
    477  22a1							;Clear the program memory, delete all proram lines
    478  22a1							;
    479  22a1				   S16
      0  22a1					      TSTB	S16A,kNew	;clear program
      0  22a1					      db	101
      1  22a1		       65		      .byte.b	101
      0  22a2					      db	(S16A-*)-1
      1  22a2		       05		      .byte.b	(S16A-*)-1
      0  22a3					      db	kNew
      1  22a3		       18		      .byte.b	kNew
    481  22a4				   ekNew
      0  22a4					      DONE
      0  22a4					      db	1
      1  22a4		       01		      .byte.b	1
      0  22a5					      IJMP	START
      0  22a5					      db	29
      1  22a5		       1d		      .byte.b	29
      0  22a6					      dw	START
      1  22a6		       cb 20		      .word.w	START
    484  22a8
    485  22a8							;========================================================================
    486  22a8							; Slice(slice legth expression)
    487  22a8							;   set the length of time between task switches
    488  22a8							;
    489  22a8				   S16A
      0  22a8					      TSTB	S16Trace,kSlice
      0  22a8					      db	101
      1  22a8		       65		      .byte.b	101
      0  22a9					      db	(S16Trace-*)-1
      1  22a9		       0c		      .byte.b	(S16Trace-*)-1
      0  22aa					      db	kSlice
      1  22aa		       19		      .byte.b	kSlice
    491  22ab				   ekSlice
      0  22ab					      CALL	EXPR
      0  22ab					      db	28
      1  22ab		       1c		      .byte.b	28
      0  22ac					      dw	EXPR
      1  22ac		       f8 22		      .word.w	EXPR
      0  22ae					      SLICE
      0  22ae					      db	100
      1  22ae		       64		      .byte.b	100
      0  22af					      DONE
      0  22af					      db	1
      1  22af		       01		      .byte.b	1
      0  22b0					      NXT	CO
      0  22b0					      db	6
      1  22b0		       06		      .byte.b	6
      0  22b1					      dw	CO
      1  22b1		       d1 20		      .word.w	CO
      0  22b3					      IJMP	STMT
      0  22b3					      db	29
      1  22b3		       1d		      .byte.b	29
      0  22b4					      dw	STMT
      1  22b4		       d9 20		      .word.w	STMT
    497  22b6							;==========================================================================
    498  22b6							; Turn off and on the thrace functions
    499  22b6							; a debug terminal needs to be available
    500  22b6							; Trace( Trace flag expression)
    501  22b6							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    502  22b6							;	for individual lines of basic code. These can be combined
    503  22b6				   S16Trace
      0  22b6					      TSTB	S17A,kTrace
      0  22b6					      db	101
      1  22b6		       65		      .byte.b	101
      0  22b7					      db	(S17A-*)-1
      1  22b7		       12		      .byte.b	(S17A-*)-1
      0  22b8					      db	kTrace
      1  22b8		       1a		      .byte.b	kTrace
    505  22b9				   ekTrace
      0  22b9					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  22b9					      db	101
      1  22b9		       65		      .byte.b	101
      0  22ba					      db	(UNKNOWN-*)-1
      1  22ba		       39		      .byte.b	(UNKNOWN-*)-1
      0  22bb					      db	oLeftBracket
      1  22bb		       e0		      .byte.b	oLeftBracket
      0  22bc					      CALL	EXPR
      0  22bc					      db	28
      1  22bc		       1c		      .byte.b	28
      0  22bd					      dw	EXPR
      1  22bd		       f8 22		      .word.w	EXPR
      0  22bf					      TSTB	UNKNOWN,oRightBracket
      0  22bf					      db	101
      1  22bf		       65		      .byte.b	101
      0  22c0					      db	(UNKNOWN-*)-1
      1  22c0		       33		      .byte.b	(UNKNOWN-*)-1
      0  22c1					      db	oRightBracket
      1  22c1		       e1		      .byte.b	oRightBracket
      0  22c2					      TRACEPROGRAM
      0  22c2					      db	78
      1  22c2		       4e		      .byte.b	78
      0  22c3					      DONE
      0  22c3					      db	1
      1  22c3		       01		      .byte.b	1
      0  22c4					      NXT	CO
      0  22c4					      db	6
      1  22c4		       06		      .byte.b	6
      0  22c5					      dw	CO
      1  22c5		       d1 20		      .word.w	CO
      0  22c7					      IJMP	STMT
      0  22c7					      db	29
      1  22c7		       1d		      .byte.b	29
      0  22c8					      dw	STMT
      1  22c8		       d9 20		      .word.w	STMT
    513  22ca							;=====================================================================
    514  22ca							; Exit basic to machine monitor
    515  22ca							;
    516  22ca				   S17A
      0  22ca					      TSTB	S17B,kExit	;allow them to exit BASIC
      0  22ca					      db	101
      1  22ca		       65		      .byte.b	101
      0  22cb					      db	(S17B-*)-1
      1  22cb		       02		      .byte.b	(S17B-*)-1
      0  22cc					      db	kExit
      1  22cc		       1b		      .byte.b	kExit
    518  22cd				   ekExit
      0  22cd					      EXIT
      0  22cd					      db	26
      1  22cd		       1a		      .byte.b	26
    520  22ce
    521  22ce							;=======================================================================
    522  22ce							; Commands related to saving/restoring programs
    523  22ce							; to/from mass storage.
    524  22ce							;
    525  22ce				   S17B
    526  22ce					      if	(XKIM || CTMON65) && DISK_ACCESS
    527  22ce
      0  22ce					      TSTB	S17C,kSave
      0  22ce					      db	101
      1  22ce		       65		      .byte.b	101
      0  22cf					      db	(S17C-*)-1
      1  22cf		       07		      .byte.b	(S17C-*)-1
      0  22d0					      db	kSave
      1  22d0		       1c		      .byte.b	kSave
    529  22d1				   ekSave
      0  22d1					      OPENWRITE
      0  22d1					      db	40
      1  22d1		       28		      .byte.b	40
      0  22d2					      DLIST
      0  22d2					      db	43
      1  22d2		       2b		      .byte.b	43
      0  22d3					      DCLOSE
      0  22d3					      db	41
      1  22d3		       29		      .byte.b	41
      0  22d4					      IJMP	CO
      0  22d4					      db	29
      1  22d4		       1d		      .byte.b	29
      0  22d5					      dw	CO
      1  22d5		       d1 20		      .word.w	CO
    534  22d7
    535  22d7				   S17C
      0  22d7					      TSTB	S18,kLoad
      0  22d7					      db	101
      1  22d7		       65		      .byte.b	101
      0  22d8					      db	(S18-*)-1
      1  22d8		       0d		      .byte.b	(S18-*)-1
      0  22d9					      db	kLoad
      1  22d9		       1d		      .byte.b	kLoad
    537  22da				   ekLoad
      0  22da					      OPENREAD
      0  22da					      db	39
      1  22da		       27		      .byte.b	39
    539  22db				   S17CLP
      0  22db					      DGETLINE		;get line from file
      0  22db					      db	42
      1  22db		       2a		      .byte.b	42
      0  22dc					      TSTL	S17EOL	;no line num means EOL
      0  22dc					      db	34
      1  22dc		       22		      .byte.b	34
      0  22dd					      db	(S17EOL-*)-1
      1  22dd		       04		      .byte.b	(S17EOL-*)-1
      0  22de					      INSERT		;put it into the program
      0  22de					      db	24
      1  22de		       18		      .byte.b	24
      0  22df					      IJMP	S17CLP	;keep going
      0  22df					      db	29
      1  22df		       1d		      .byte.b	29
      0  22e0					      dw	S17CLP
      1  22e0		       db 22		      .word.w	S17CLP
    544  22e2				   S17EOL
      0  22e2					      DCLOSE		;close disk file
      0  22e2					      db	41
      1  22e2		       29		      .byte.b	41
      0  22e3					      IJMP	CO	;back to start
      0  22e3					      db	29
      1  22e3		       1d		      .byte.b	29
      0  22e4					      dw	CO
      1  22e4		       d1 20		      .word.w	CO
    547  22e6
    548  22e6				   S18
      0  22e6					      TSTB	S19,kDir
      0  22e6					      db	101
      1  22e6		       65		      .byte.b	101
      0  22e7					      db	(S19-*)-1
      1  22e7		       05		      .byte.b	(S19-*)-1
      0  22e8					      db	kDir
      1  22e8		       1f		      .byte.b	kDir
    550  22e9				   ekDir
      0  22e9					      DDIR		;Display the directory content
      0  22e9					      db	44
      1  22e9		       2c		      .byte.b	44
      0  22ea					      IJMP	CO
      0  22ea					      db	29
      1  22ea		       1d		      .byte.b	29
      0  22eb					      dw	CO
      1  22eb		       d1 20		      .word.w	CO
    553  22ed							;=========================================================================
    554  22ed							; Erase a file from disk
    555  22ed							;
      0  22ed				   S19	      TSTB	UNKNOWN,kErase
      0  22ed					      db	101
      1  22ed		       65		      .byte.b	101
      0  22ee					      db	(UNKNOWN-*)-1
      1  22ee		       05		      .byte.b	(UNKNOWN-*)-1
      0  22ef					      db	kErase
      1  22ef		       1e		      .byte.b	kErase
    557  22f0				   ekErase
      0  22f0					      RMFILE		;Erase the file from the disk
      0  22f0					      db	45
      1  22f0		       2d		      .byte.b	45
      0  22f1					      IJMP	CO
      0  22f1					      db	29
      1  22f1		       1d		      .byte.b	29
      0  22f2					      dw	CO
      1  22f2		       d1 20		      .word.w	CO
    560  22f4
    561  22f4					      endif
    562  22f4
    563  22f4							;
    564  22f4							; Else, unknown command.
    565  22f4							;
    566  22f4				   UNKNOWN
      0  22f4					      ENDIO
      0  22f4					      db	71
      1  22f4		       47		      .byte.b	71
    568  22f5
    569  22f5				   NotKnownStatement
    570  22f5
      0  22f5					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  22f5					      db	13
      1  22f5		       0d		      .byte.b	13
      0  22f6					      dw	ERR_SYNTAX
      1  22f6		       05 00		      .word.w	ERR_SYNTAX
    572  22f8
    573  22f8							;=======================================================
    574  22f8							; Process Expresions, precidence is represented by the
    575  22f8							; various call levels
    576  22f8							;
    577  22f8				   EXPR
      0  22f8					      TSTB	EXPRLOGS,kNot
      0  22f8					      db	101
      1  22f8		       65		      .byte.b	101
      0  22f9					      db	(EXPRLOGS-*)-1
      1  22f9		       06		      .byte.b	(EXPRLOGS-*)-1
      0  22fa					      db	kNot
      1  22fa		       20		      .byte.b	kNot
    579  22fb				   ekNot
      0  22fb					      Call	EXPR
      0  22fb					      db	28
      1  22fb		       1c		      .byte.b	28
      0  22fc					      dw	EXPR
      1  22fc		       f8 22		      .word.w	EXPR
      0  22fe					      LOGNOT
      0  22fe					      db	72
      1  22fe		       48		      .byte.b	72
      0  22ff					      RTN
      0  22ff					      db	25
      1  22ff		       19		      .byte.b	25
    583  2300
    584  2300							;=========================================================
    585  2300							;Look for logical operators
    586  2300				   EXPRLOGS
      0  2300					      Call	EXPRCMP
      0  2300					      db	28
      1  2300		       1c		      .byte.b	28
      0  2301					      dw	EXPRCMP
      1  2301		       1b 23		      .word.w	EXPRCMP
      0  2303					      TSTB	iLOG1,kAnd
      0  2303					      db	101
      1  2303		       65		      .byte.b	101
      0  2304					      db	(iLOG1-*)-1
      1  2304		       06		      .byte.b	(iLOG1-*)-1
      0  2305					      db	kAnd
      1  2305		       23		      .byte.b	kAnd
    589  2306				   ekAnd
      0  2306					      Call	EXPR
      0  2306					      db	28
      1  2306		       1c		      .byte.b	28
      0  2307					      dw	EXPR
      1  2307		       f8 22		      .word.w	EXPR
      0  2309					      LOGAND
      0  2309					      db	74
      1  2309		       4a		      .byte.b	74
      0  230a					      RTN
      0  230a					      db	25
      1  230a		       19		      .byte.b	25
    593  230b				   iLOG1
      0  230b					      TSTB	iLOG2,kOr
      0  230b					      db	101
      1  230b		       65		      .byte.b	101
      0  230c					      db	(iLOG2-*)-1
      1  230c		       06		      .byte.b	(iLOG2-*)-1
      0  230d					      db	kOr
      1  230d		       21		      .byte.b	kOr
    595  230e				   ekOr
      0  230e					      Call	EXPR
      0  230e					      db	28
      1  230e		       1c		      .byte.b	28
      0  230f					      dw	EXPR
      1  230f		       f8 22		      .word.w	EXPR
      0  2311					      LOGOR
      0  2311					      db	73
      1  2311		       49		      .byte.b	73
      0  2312					      RTN
      0  2312					      db	25
      1  2312		       19		      .byte.b	25
    599  2313				   iLOG2
      0  2313					      TSTB	iLOG3,kXor
      0  2313					      db	101
      1  2313		       65		      .byte.b	101
      0  2314					      db	(iLOG3-*)-1
      1  2314		       05		      .byte.b	(iLOG3-*)-1
      0  2315					      db	kXor
      1  2315		       22		      .byte.b	kXor
    601  2316				   ekXor
      0  2316					      Call	EXPR
      0  2316					      db	28
      1  2316		       1c		      .byte.b	28
      0  2317					      dw	EXPR
      1  2317		       f8 22		      .word.w	EXPR
      0  2319					      LOGXOR
      0  2319					      db	75
      1  2319		       4b		      .byte.b	75
    604  231a				   iLOG3
      0  231a					      RTN
      0  231a					      db	25
      1  231a		       19		      .byte.b	25
    606  231b
    607  231b				   EXPRCMP
      0  231b					      Call	EXPR2	; get the first expression
      0  231b					      db	28
      1  231b		       1c		      .byte.b	28
      0  231c					      dw	EXPR2
      1  231c		       26 23		      .word.w	EXPR2
      0  231e					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  231e					      db	104
      1  231e		       68		      .byte.b	104
      0  231f					      db	(iRDone-*)-1
      1  231f		       05		      .byte.b	(iRDone-*)-1
    610  2320							;	  TSTB	     iR0,oEqual
    611  2320							;	  LIT	     2		     ;=
    612  2320							;	  IJMP	     iRFound
    613  2320							;iR0:
    614  2320							;	  TSTB	      iR1,oLessEqual
    615  2320							;	  LIT	      3 	      ;<=
    616  2320							;	  IJMP	     iRFound
    617  2320							;iR1:
    618  2320							;	  TSTB	     iR3,oNotEqual
    619  2320							;	  LIT	     5		      ;<>
    620  2320							;	      IJMP	  iRFound
    621  2320							;iR3:
    622  2320							;	  TSTB	     iR4,oLess
    623  2320							;	  LIT	     1		     ;<
    624  2320							;	      IJMP	  iRFound
    625  2320							;iR4:
    626  2320							;	  TST	     iR5,oGreaterEqual
    627  2320							;	  LIT	     6		     ;>=
    628  2320							;	      IJMP	  iRFound
    629  2320							;iR5:
    630  2320							;	  TSTB	     iRDone,oGreater
    631  2320							;	  LIT	     4		     ;>
    632  2320				   iRFound
      0  2320					      Call	EXPR	; get the right side of the expression
      0  2320					      db	28
      1  2320		       1c		      .byte.b	28
      0  2321					      dw	EXPR
      1  2321		       f8 22		      .word.w	EXPR
      0  2323					      CMPR		; Push the value of the true false onto the stack
      0  2323					      db	10
      1  2323		       0a		      .byte.b	10
      0  2324					      RTN
      0  2324					      db	25
      1  2324		       19		      .byte.b	25
    636  2325
    637  2325				   iRDone
      0  2325					      RTN
      0  2325					      db	25
      1  2325		       19		      .byte.b	25
    639  2326
    640  2326				   EXPR2
      0  2326					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  2326					      db	101
      1  2326		       65		      .byte.b	101
      0  2327					      db	(E0-*)-1
      1  2327		       08		      .byte.b	(E0-*)-1
      0  2328					      db	oMinus
      1  2328		       eb		      .byte.b	oMinus
      0  2329					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  2329					      db	28
      1  2329		       1c		      .byte.b	28
      0  232a					      dw	TERM
      1  232a		       4c 23		      .word.w	TERM
      0  232c					      NEG		; Make value negated
      0  232c					      db	16
      1  232c		       10		      .byte.b	16
      0  232d					      IJMP	E1	; We have Left term process operators next
      0  232d					      db	29
      1  232d		       1d		      .byte.b	29
      0  232e					      dw	E1
      1  232e		       36 23		      .word.w	E1
    645  2330				   E0
      0  2330					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  2330					      db	101
      1  2330		       65		      .byte.b	101
      0  2331					      db	(E1A-*)-1
      1  2331		       01		      .byte.b	(E1A-*)-1
      0  2332					      db	oPlus
      1  2332		       ea		      .byte.b	oPlus
    647  2333				   E1A
      0  2333					      CALL	TERM	; Get the left term if it was not negated
      0  2333					      db	28
      1  2333		       1c		      .byte.b	28
      0  2334					      dw	TERM
      1  2334		       4c 23		      .word.w	TERM
    649  2336				   E1
      0  2336					      TST	E2,oPlus	; Check if we are adding left term to something
      0  2336					      db	32
      1  2336		       20		      .byte.b	32
      0  2337					      db	(E2-*)-1
      1  2337		       09		      .byte.b	(E2-*)-1
      0  2338					      db	oPlus,0
      1  2338		       ea 00		      .byte.b	oPlus,0
      0  233a					      CALL	TERM	; if adding then get the right side term
      0  233a					      db	28
      1  233a		       1c		      .byte.b	28
      0  233b					      dw	TERM
      1  233b		       4c 23		      .word.w	TERM
      0  233d					      ADD		; Add it to left term
      0  233d					      db	14
      1  233d		       0e		      .byte.b	14
      0  233e					      IJMP	E1	; look for next + or -
      0  233e					      db	29
      1  233e		       1d		      .byte.b	29
      0  233f					      dw	E1
      1  233f		       36 23		      .word.w	E1
    654  2341				   E2
      0  2341					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  2341					      db	101
      1  2341		       65		      .byte.b	101
      0  2342					      db	(E3-*)-1
      1  2342		       08		      .byte.b	(E3-*)-1
      0  2343					      db	oMinus
      1  2343		       eb		      .byte.b	oMinus
      0  2344					      CALL	TERM	; get right side to subtract Diffrence
      0  2344					      db	28
      1  2344		       1c		      .byte.b	28
      0  2345					      dw	TERM
      1  2345		       4c 23		      .word.w	TERM
      0  2347					      SUB		; Subtract the value
      0  2347					      db	15
      1  2347		       0f		      .byte.b	15
      0  2348					      IJMP	E1	; Look for next + or -
      0  2348					      db	29
      1  2348		       1d		      .byte.b	29
      0  2349					      dw	E1
      1  2349		       36 23		      .word.w	E1
    659  234b				   E3			; Finish processing the expression
      0  234b					      RTN		; We are finished processing the Expression
      0  234b					      db	25
      1  234b		       19		      .byte.b	25
    661  234c							;
    662  234c							; Get one of the terms of an expression
    663  234c							;
    664  234c				   TERM
      0  234c					      CALL	FACT	; Get a value
      0  234c					      db	28
      1  234c		       1c		      .byte.b	28
      0  234d					      dw	FACT
      1  234d		       71 23		      .word.w	FACT
    666  234f				   T0			; Check for higher precidence operators
      0  234f					      TSTB	T1,oMultiply	; Check for *
      0  234f					      db	101
      1  234f		       65		      .byte.b	101
      0  2350					      db	(T1-*)-1
      1  2350		       08		      .byte.b	(T1-*)-1
      0  2351					      db	oMultiply
      1  2351		       ee		      .byte.b	oMultiply
      0  2352					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  2352					      db	28
      1  2352		       1c		      .byte.b	28
      0  2353					      dw	FACT
      1  2353		       71 23		      .word.w	FACT
      0  2355					      MUL		; Multiply factors
      0  2355					      db	17
      1  2355		       11		      .byte.b	17
      0  2356					      IJMP	T0	; Check for * or /
      0  2356					      db	29
      1  2356		       1d		      .byte.b	29
      0  2357					      dw	T0
      1  2357		       4f 23		      .word.w	T0
    671  2359				   T1
      0  2359					      TSTB	T2,oDivide	; Check for a division
      0  2359					      db	101
      1  2359		       65		      .byte.b	101
      0  235a					      db	(T2-*)-1
      1  235a		       08		      .byte.b	(T2-*)-1
      0  235b					      db	oDivide
      1  235b		       ec		      .byte.b	oDivide
      0  235c					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  235c					      db	28
      1  235c		       1c		      .byte.b	28
      0  235d					      dw	FACT
      1  235d		       71 23		      .word.w	FACT
      0  235f					      DIV		; do division
      0  235f					      db	18
      1  235f		       12		      .byte.b	18
      0  2360					      IJMP	T0	; check for more * or /
      0  2360					      db	29
      1  2360		       1d		      .byte.b	29
      0  2361					      dw	T0
      1  2361		       4f 23		      .word.w	T0
    676  2363				   T2
      0  2363					      TSTB	T3,oModulo	; Check for a division
      0  2363					      db	101
      1  2363		       65		      .byte.b	101
      0  2364					      db	(T3-*)-1
      1  2364		       08		      .byte.b	(T3-*)-1
      0  2365					      db	oModulo
      1  2365		       ed		      .byte.b	oModulo
      0  2366					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2366					      db	28
      1  2366		       1c		      .byte.b	28
      0  2367					      dw	FACT
      1  2367		       71 23		      .word.w	FACT
      0  2369					      MODULO		; do division for remainder
      0  2369					      db	60
      1  2369		       3c		      .byte.b	60
      0  236a					      IJMP	T0	; check for more * or / or %
      0  236a					      db	29
      1  236a		       1d		      .byte.b	29
      0  236b					      dw	T0
      1  236b		       4f 23		      .word.w	T0
    681  236d				   T3			; Finish processing the Term
      0  236d					      RTN
      0  236d					      db	25
      1  236d		       19		      .byte.b	25
    683  236e
    684  236e				   UNKNOWNVEC
      0  236e					      IJMP	UNKNOWN
      0  236e					      db	29
      1  236e		       1d		      .byte.b	29
      0  236f					      dw	UNKNOWN
      1  236f		       f4 22		      .word.w	UNKNOWN
    686  2371
    687  2371							;=============================================================================================
    688  2371							; Factor an expression.  Always test for functions
    689  2371							; first or else they'll be confused for variables.
    690  2371							;
    691  2371				   FACT
      0  2371					      OnGoto	BasicFuncs,FactNumber
      0  2371					      db	103
      1  2371		       67		      .byte.b	103
      0  2372					      dw	BasicFuncs
      1  2372		       ab 20		      .word.w	BasicFuncs
      0  2374					      dw	FactNumber
      1  2374		       5e 24		      .word.w	FactNumber
    693  2376
    694  2376				   FACTCONTINUE
      0  2376					      TSTB	F1AA,kTrue
      0  2376					      db	101
      1  2376		       65		      .byte.b	101
      0  2377					      db	(F1AA-*)-1
      1  2377		       05		      .byte.b	(F1AA-*)-1
      0  2378					      db	kTrue
      1  2378		       24		      .byte.b	kTrue
    696  2379				   ekTrue
      0  2379					      LIT	-1
      0  2379					      db	27
      1  2379		       1b		      .byte.b	27
      0  237a					      dw	-1
      1  237a		       ff ff		      .word.w	-1
      0  237c					      RTN
      0  237c					      db	25
      1  237c		       19		      .byte.b	25
    699  237d				   F1AA
      0  237d					      TSTB	F1AB,kFalse
      0  237d					      db	101
      1  237d		       65		      .byte.b	101
      0  237e					      db	(F1AB-*)-1
      1  237e		       05		      .byte.b	(F1AB-*)-1
      0  237f					      db	kFalse
      1  237f		       25		      .byte.b	kFalse
    701  2380				   ekFalse
      0  2380					      LIT	0
      0  2380					      db	27
      1  2380		       1b		      .byte.b	27
      0  2381					      dw	0
      1  2381		       00 00		      .word.w	0
      0  2383					      RTN
      0  2383					      db	25
      1  2383		       19		      .byte.b	25
    704  2384							;==================================================================================
    705  2384							; Returns the amount of free SPACE
    706  2384							;
    707  2384				   F1AB
      0  2384					      TSTB	F1A,kFree
      0  2384					      db	101
      1  2384		       65		      .byte.b	101
      0  2385					      db	(F1A-*)-1
      1  2385		       09		      .byte.b	(F1A-*)-1
      0  2386					      db	kFree
      1  2386		       26		      .byte.b	kFree
    709  2387				   ekFree
      0  2387					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2387					      db	101
      1  2387		       65		      .byte.b	101
      0  2388					      db	(UNKNOWNVEC-*)-1
      1  2388		       e5		      .byte.b	(UNKNOWNVEC-*)-1
      0  2389					      db	oLeftBracket
      1  2389		       e0		      .byte.b	oLeftBracket
      0  238a					      TSTB	UNKNOWNVEC,oRightBracket
      0  238a					      db	101
      1  238a		       65		      .byte.b	101
      0  238b					      db	(UNKNOWNVEC-*)-1
      1  238b		       e2		      .byte.b	(UNKNOWNVEC-*)-1
      0  238c					      db	oRightBracket
      1  238c		       e1		      .byte.b	oRightBracket
      0  238d					      FREE
      0  238d					      db	36
      1  238d		       24		      .byte.b	36
      0  238e					      RTN
      0  238e					      db	25
      1  238e		       19		      .byte.b	25
    714  238f							;===================================================================================
    715  238f							; getch() read a character from the input device
    716  238f							;
    717  238f				   F1A
      0  238f					      TSTB	F1A2,kGetch	; read char from the terminal
      0  238f					      db	101
      1  238f		       65		      .byte.b	101
      0  2390					      db	(F1A2-*)-1
      1  2390		       09		      .byte.b	(F1A2-*)-1
      0  2391					      db	kGetch
      1  2391		       27		      .byte.b	kGetch
    719  2392				   ekGetch
      0  2392					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2392					      db	101
      1  2392		       65		      .byte.b	101
      0  2393					      db	(UNKNOWNVEC-*)-1
      1  2393		       da		      .byte.b	(UNKNOWNVEC-*)-1
      0  2394					      db	oLeftBracket
      1  2394		       e0		      .byte.b	oLeftBracket
      0  2395					      TSTB	UNKNOWNVEC,oRightBracket
      0  2395					      db	101
      1  2395		       65		      .byte.b	101
      0  2396					      db	(UNKNOWNVEC-*)-1
      1  2396		       d7		      .byte.b	(UNKNOWNVEC-*)-1
      0  2397					      db	oRightBracket
      1  2397		       e1		      .byte.b	oRightBracket
      0  2398					      GETCHAR
      0  2398					      db	51
      1  2398		       33		      .byte.b	51
      0  2399					      RTN
      0  2399					      db	25
      1  2399		       19		      .byte.b	25
    724  239a							;====================================================================================
    725  239a							; peek(mem address) return the value of a byte in memory
    726  239a							; @[offset] return a word value from offset -- see tstv
    727  239a							;
    728  239a				   F1A2
      0  239a					      TSTB	F2AZ,kPeek	;Return a value from memory
      0  239a					      db	101
      1  239a		       65		      .byte.b	101
      0  239b					      db	(F2AZ-*)-1
      1  239b		       0c		      .byte.b	(F2AZ-*)-1
      0  239c					      db	kPeek
      1  239c		       28		      .byte.b	kPeek
    730  239d				   ekPeek
      0  239d					      TSTB	UNKNOWNVEC,oLeftBracket
      0  239d					      db	101
      1  239d		       65		      .byte.b	101
      0  239e					      db	(UNKNOWNVEC-*)-1
      1  239e		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  239f					      db	oLeftBracket
      1  239f		       e0		      .byte.b	oLeftBracket
      0  23a0					      CALL	EXPR	;Get the address to write to
      0  23a0					      db	28
      1  23a0		       1c		      .byte.b	28
      0  23a1					      dw	EXPR
      1  23a1		       f8 22		      .word.w	EXPR
      0  23a3					      TSTB	UNKNOWNVEC,oRightBracket
      0  23a3					      db	101
      1  23a3		       65		      .byte.b	101
      0  23a4					      db	(UNKNOWNVEC-*)-1
      1  23a4		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  23a5					      db	oRightBracket
      1  23a5		       e1		      .byte.b	oRightBracket
      0  23a6					      PEEKMEM
      0  23a6					      db	48
      1  23a6		       30		      .byte.b	48
      0  23a7					      RTN
      0  23a7					      db	25
      1  23a7		       19		      .byte.b	25
    736  23a8							;=======================================================================================
    737  23a8							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    738  23a8							;
    739  23a8				   F2AZ
      0  23a8					      TSTB	F2AZ1,kTask	;Check if we are setting a task start
      0  23a8					      db	101
      1  23a8		       65		      .byte.b	101
      0  23a9					      db	(F2AZ1-*)-1
      1  23a9		       1d		      .byte.b	(F2AZ1-*)-1
      0  23aa					      db	kTask
      1  23aa		       29		      .byte.b	kTask
    741  23ab				   ekTask
      0  23ab					      TSTB	UNKNOWNVEC,oLeftBracket
      0  23ab					      db	101
      1  23ab		       65		      .byte.b	101
      0  23ac					      db	(UNKNOWNVEC-*)-1
      1  23ac		       c1		      .byte.b	(UNKNOWNVEC-*)-1
      0  23ad					      db	oLeftBracket
      1  23ad		       e0		      .byte.b	oLeftBracket
      0  23ae					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  23ae					      db	28
      1  23ae		       1c		      .byte.b	28
      0  23af					      dw	EXPR
      1  23af		       f8 22		      .word.w	EXPR
      0  23b1					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  23b1					      db	61
      1  23b1		       3d		      .byte.b	61
      0  23b2					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  23b2					      db	101
      1  23b2		       65		      .byte.b	101
      0  23b3					      db	(F2AZNoParms-*)-1
      1  23b3		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  23b4					      db	oComma
      1  23b4		       e2		      .byte.b	oComma
      0  23b5					      SAVEMATHSTACK		;Push The mathstack
      0  23b5					      db	86
      1  23b5		       56		      .byte.b	86
      0  23b6					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  23b6					      db	89
      1  23b6		       59		      .byte.b	89
    748  23b7				   F2AZLOOP
      0  23b7					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  23b7					      db	28
      1  23b7		       1c		      .byte.b	28
      0  23b8					      dw	EXPR
      1  23b8		       f8 22		      .word.w	EXPR
      0  23ba					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  23ba					      db	101
      1  23ba		       65		      .byte.b	101
      0  23bb					      db	(F2AZEndParm-*)-1
      1  23bb		       04		      .byte.b	(F2AZEndParm-*)-1
      0  23bc					      db	oComma
      1  23bc		       e2		      .byte.b	oComma
      0  23bd					      IJMP	F2AZLOOP	;check for more
      0  23bd					      db	29
      1  23bd		       1d		      .byte.b	29
      0  23be					      dw	F2AZLOOP
      1  23be		       b7 23		      .word.w	F2AZLOOP
    752  23c0				   F2AZEndParm
      0  23c0					      RESTOREMATHSTACK		;Back to normal stack
      0  23c0					      db	87
      1  23c0		       57		      .byte.b	87
      0  23c1					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  23c1					      db	92
      1  23c1		       5c		      .byte.b	92
    755  23c2				   F2AZNoParms
      0  23c2					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  23c2					      db	101
      1  23c2		       65		      .byte.b	101
      0  23c3					      db	(UNKNOWNVEC-*)-1
      1  23c3		       aa		      .byte.b	(UNKNOWNVEC-*)-1
      0  23c4					      db	oRightBracket
      1  23c4		       e1		      .byte.b	oRightBracket
      0  23c5					      TASKENABLE		;Enable the task to execute
      0  23c5					      db	90
      1  23c5		       5a		      .byte.b	90
      0  23c6					      RTN		;Returns the Task number
      0  23c6					      db	25
      1  23c6		       19		      .byte.b	25
    759  23c7							;=========================================================================================
    760  23c7							; Check for IPC interproccess instructions
    761  23c7							;   IPCS  - Send a message
    762  23c7							;
    763  23c7				   F2AZ1
      0  23c7					      TSTB	F2AZa,kIpcs	;Test if one of the IPC functions
      0  23c7					      db	101
      1  23c7		       65		      .byte.b	101
      0  23c8					      db	(F2AZa-*)-1
      1  23c8		       12		      .byte.b	(F2AZa-*)-1
      0  23c9					      db	kIpcs
      1  23c9		       2b		      .byte.b	kIpcs
    765  23ca				   ekIpcs
      0  23ca					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  23ca					      db	101
      1  23ca		       65		      .byte.b	101
      0  23cb					      db	(UNKNOWNVEC-*)-1
      1  23cb		       a2		      .byte.b	(UNKNOWNVEC-*)-1
      0  23cc					      db	oLeftBracket
      1  23cc		       e0		      .byte.b	oLeftBracket
      0  23cd					      CALL	EXPR	;Get the message value
      0  23cd					      db	28
      1  23cd		       1c		      .byte.b	28
      0  23ce					      dw	EXPR
      1  23ce		       f8 22		      .word.w	EXPR
      0  23d0					      TSTB	UNKNOWNVEC,oComma
      0  23d0					      db	101
      1  23d0		       65		      .byte.b	101
      0  23d1					      db	(UNKNOWNVEC-*)-1
      1  23d1		       9c		      .byte.b	(UNKNOWNVEC-*)-1
      0  23d2					      db	oComma
      1  23d2		       e2		      .byte.b	oComma
      0  23d3					      CALL	EXPR	;Get pid of task to send to
      0  23d3					      db	28
      1  23d3		       1c		      .byte.b	28
      0  23d4					      dw	EXPR
      1  23d4		       f8 22		      .word.w	EXPR
      0  23d6					      TSTB	UNKNOWNVEC,oRightBracket
      0  23d6					      db	101
      1  23d6		       65		      .byte.b	101
      0  23d7					      db	(UNKNOWNVEC-*)-1
      1  23d7		       96		      .byte.b	(UNKNOWNVEC-*)-1
      0  23d8					      db	oRightBracket
      1  23d8		       e1		      .byte.b	oRightBracket
      0  23d9					      IPCSEND		;Send msg and clear pid msg pending
      0  23d9					      db	80
      1  23d9		       50		      .byte.b	80
      0  23da					      RTN
      0  23da					      db	25
      1  23da		       19		      .byte.b	25
    773  23db							;================================================================================
    774  23db							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    775  23db							;
    776  23db				   F2AZa
      0  23db					      TSTB	F2AZb,kIpcr	;IPCR recieve a message , wait if none
      0  23db					      db	101
      1  23db		       65		      .byte.b	101
      0  23dc					      db	(F2AZb-*)-1
      1  23dc		       15		      .byte.b	(F2AZb-*)-1
      0  23dd					      db	kIpcr
      1  23dd		       2c		      .byte.b	kIpcr
    778  23de				   ekIpcr
      0  23de					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  23de					      db	101
      1  23de		       65		      .byte.b	101
      0  23df					      db	(UNKNOWNVEC-*)-1
      1  23df		       8e		      .byte.b	(UNKNOWNVEC-*)-1
      0  23e0					      db	oLeftBracket
      1  23e0		       e0		      .byte.b	oLeftBracket
      0  23e1					      TSTB	F2AZa1,oRightBracket
      0  23e1					      db	101
      1  23e1		       65		      .byte.b	101
      0  23e2					      db	(F2AZa1-*)-1
      1  23e2		       07		      .byte.b	(F2AZa1-*)-1
      0  23e3					      db	oRightBracket
      1  23e3		       e1		      .byte.b	oRightBracket
      0  23e4					      LIT	0	;We dont want the pid returned to us
      0  23e4					      db	27
      1  23e4		       1b		      .byte.b	27
      0  23e5					      dw	0
      1  23e5		       00 00		      .word.w	0
      0  23e7					      IPCIO		;Set the io bit and suspend the task till message
      0  23e7					      db	83
      1  23e7		       53		      .byte.b	83
      0  23e8					      IPCRECEIVE		;Get the message
      0  23e8					      db	81
      1  23e8		       51		      .byte.b	81
      0  23e9					      RTN
      0  23e9					      db	25
      1  23e9		       19		      .byte.b	25
    785  23ea				   F2AZa1
      0  23ea					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  23ea					      db	33
      1  23ea		       21		      .byte.b	33
      0  23eb					      db	(UNKNOWNVEC-*)-1
      1  23eb		       82		      .byte.b	(UNKNOWNVEC-*)-1
      0  23ec					      TSTB	UNKNOWNVEC,oRightBracket
      0  23ec					      db	101
      1  23ec		       65		      .byte.b	101
      0  23ed					      db	(UNKNOWNVEC-*)-1
      1  23ed		       80		      .byte.b	(UNKNOWNVEC-*)-1
      0  23ee					      db	oRightBracket
      1  23ee		       e1		      .byte.b	oRightBracket
      0  23ef					      IPCIO		;Set the io bit and exit task till message
      0  23ef					      db	83
      1  23ef		       53		      .byte.b	83
      0  23f0					      IPCRECEIVE		;Get the message
      0  23f0					      db	81
      1  23f0		       51		      .byte.b	81
      0  23f1					      RTN
      0  23f1					      db	25
      1  23f1		       19		      .byte.b	25
    791  23f2							;===============================================================================
    792  23f2							; IPCC ---- check if a message is available
    793  23f2				   F2AZb
      0  23f2					      TST	F2A,kIpcc	;Returns number of messages on the message queue
      0  23f2					      db	32
      1  23f2		       20		      .byte.b	32
      0  23f3					      db	(F2A-*)-1
      1  23f3		       0d		      .byte.b	(F2A-*)-1
      0  23f4					      db	kIpcc,0
      1  23f4		       2a 00		      .byte.b	kIpcc,0
    795  23f6				   ekIpcc
      0  23f6					      TSTB	UNKNOWNVEC,oLeftBracket
      0  23f6					      db	101
      1  23f6		       65		      .byte.b	101
      0  23f7					      db	(UNKNOWNVEC-*)-1
      1  23f7		       76		      .byte.b	(UNKNOWNVEC-*)-1
      0  23f8					      db	oLeftBracket
      1  23f8		       e0		      .byte.b	oLeftBracket
      0  23f9					      TSTB	UNKNOWNVEC,oRightBracket
      0  23f9					      db	101
      1  23f9		       65		      .byte.b	101
      0  23fa					      db	(UNKNOWNVEC-*)-1
      1  23fa		       73		      .byte.b	(UNKNOWNVEC-*)-1
      0  23fb					      db	oRightBracket
      1  23fb		       e1		      .byte.b	oRightBracket
      0  23fc					      IPCCHECK
      0  23fc					      db	82
      1  23fc		       52		      .byte.b	82
      0  23fd					      RTN
      0  23fd					      db	25
      1  23fd		       19		      .byte.b	25
    800  23fe
    801  23fe				   UNKNOWNID
      0  23fe					      IJMP	UNKNOWN
      0  23fe					      db	29
      1  23fe		       1d		      .byte.b	29
      0  23ff					      dw	UNKNOWN
      1  23ff		       f4 22		      .word.w	UNKNOWN
    803  2401							;============================================================
    804  2401							; RND() is supposed to have an argument but if none
    805  2401							; was provided, just assume a large value.
    806  2401							;
    807  2401				   F2A
      0  2401					      TSTB	F2B,kRnd
      0  2401					      db	101
      1  2401		       65		      .byte.b	101
      0  2402					      db	(F2B-*)-1
      1  2402		       14		      .byte.b	(F2B-*)-1
      0  2403					      db	kRnd
      1  2403		       2d		      .byte.b	kRnd
    809  2404				   ekRnd
      0  2404					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2404					      db	101
      1  2404		       65		      .byte.b	101
      0  2405					      db	(UNKNOWNVEC-*)-1
      1  2405		       68		      .byte.b	(UNKNOWNVEC-*)-1
      0  2406					      db	oLeftBracket
      1  2406		       e0		      .byte.b	oLeftBracket
      0  2407					      TSTB	F2A1,oRightBracket
      0  2407					      db	101
      1  2407		       65		      .byte.b	101
      0  2408					      db	(F2A1-*)-1
      1  2408		       06		      .byte.b	(F2A1-*)-1
      0  2409					      db	oRightBracket
      1  2409		       e1		      .byte.b	oRightBracket
      0  240a					      LIT	32766
      0  240a					      db	27
      1  240a		       1b		      .byte.b	27
      0  240b					      dw	32766
      1  240b		       fe 7f		      .word.w	32766
      0  240d					      RANDOM
      0  240d					      db	37
      1  240d		       25		      .byte.b	37
      0  240e					      RTN
      0  240e					      db	25
      1  240e		       19		      .byte.b	25
    815  240f
    816  240f				   F2A1
      0  240f					      CALL	FACT	;GET RANGE
      0  240f					      db	28
      1  240f		       1c		      .byte.b	28
      0  2410					      dw	FACT
      1  2410		       71 23		      .word.w	FACT
      0  2412					      TSTB	UNKNOWNVEC,oRightBracket
      0  2412					      db	101
      1  2412		       65		      .byte.b	101
      0  2413					      db	(UNKNOWNVEC-*)-1
      1  2413		       5a		      .byte.b	(UNKNOWNVEC-*)-1
      0  2414					      db	oRightBracket
      1  2414		       e1		      .byte.b	oRightBracket
      0  2415					      RANDOM
      0  2415					      db	37
      1  2415		       25		      .byte.b	37
      0  2416					      RTN
      0  2416					      db	25
      1  2416		       19		      .byte.b	25
    821  2417							;==========================================================
    822  2417							;	Return absolute value of expresion
    823  2417							;
    824  2417				   F2B
      0  2417					      TSTB	F2B2,kAbs
      0  2417					      db	101
      1  2417		       65		      .byte.b	101
      0  2418					      db	(F2B2-*)-1
      1  2418		       0c		      .byte.b	(F2B2-*)-1
      0  2419					      db	kAbs
      1  2419		       2f		      .byte.b	kAbs
    826  241a				   ekAbs
      0  241a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  241a					      db	101
      1  241a		       65		      .byte.b	101
      0  241b					      db	(UNKNOWNVEC-*)-1
      1  241b		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  241c					      db	oLeftBracket
      1  241c		       e0		      .byte.b	oLeftBracket
      0  241d					      CALL	EXPR	;get value
      0  241d					      db	28
      1  241d		       1c		      .byte.b	28
      0  241e					      dw	EXPR
      1  241e		       f8 22		      .word.w	EXPR
      0  2420					      TSTB	UNKNOWNVEC,oRightBracket
      0  2420					      db	101
      1  2420		       65		      .byte.b	101
      0  2421					      db	(UNKNOWNVEC-*)-1
      1  2421		       4c		      .byte.b	(UNKNOWNVEC-*)-1
      0  2422					      db	oRightBracket
      1  2422		       e1		      .byte.b	oRightBracket
      0  2423					      ABS
      0  2423					      db	38
      1  2423		       26		      .byte.b	38
      0  2424					      RTN
      0  2424					      db	25
      1  2424		       19		      .byte.b	25
    832  2425							;============================================================
    833  2425							;     Return the the status of a task, provide the PID
    834  2425							;
    835  2425				   F2B2
      0  2425					      TSTB	F2Z,kStat
      0  2425					      db	101
      1  2425		       65		      .byte.b	101
      0  2426					      db	(F2Z-*)-1
      1  2426		       0c		      .byte.b	(F2Z-*)-1
      0  2427					      db	kStat
      1  2427		       2e		      .byte.b	kStat
    837  2428				   ekStat
      0  2428					      TSTB	UNKNOWNVEC,oLeftBracket
      0  2428					      db	101
      1  2428		       65		      .byte.b	101
      0  2429					      db	(UNKNOWNVEC-*)-1
      1  2429		       44		      .byte.b	(UNKNOWNVEC-*)-1
      0  242a					      db	oLeftBracket
      1  242a		       e0		      .byte.b	oLeftBracket
      0  242b					      Call	EXPR
      0  242b					      db	28
      1  242b		       1c		      .byte.b	28
      0  242c					      dw	EXPR
      1  242c		       f8 22		      .word.w	EXPR
      0  242e					      TSTB	UNKNOWNVEC,oRightBracket
      0  242e					      db	101
      1  242e		       65		      .byte.b	101
      0  242f					      db	(UNKNOWNVEC-*)-1
      1  242f		       3e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2430					      db	oRightBracket
      1  2430		       e1		      .byte.b	oRightBracket
      0  2431					      TASKSTAT
      0  2431					      db	66
      1  2431		       42		      .byte.b	66
      0  2432					      RTN
      0  2432					      db	25
      1  2432		       19		      .byte.b	25
    843  2433				   F2Z
      0  2433					      TSTB	F2ZA,kPid
      0  2433					      db	101
      1  2433		       65		      .byte.b	101
      0  2434					      db	(F2ZA-*)-1
      1  2434		       03		      .byte.b	(F2ZA-*)-1
      0  2435					      db	kPid
      1  2435		       32		      .byte.b	kPid
    845  2436				   ekPid
      0  2436					      TASKPID
      0  2436					      db	77
      1  2436		       4d		      .byte.b	77
      0  2437					      RTN
      0  2437					      db	25
      1  2437		       19		      .byte.b	25
    848  2438							;===========================================================================
    849  2438							; Call a machine function, provide the address to call and optionally
    850  2438							; the value to be passed in reg A
    851  2438				   F2ZA
      0  2438					      TSTB	F2FUNC,kCall	;call machine function
      0  2438					      db	101
      1  2438		       65		      .byte.b	101
      0  2439					      db	(F2FUNC-*)-1
      1  2439		       1a		      .byte.b	(F2FUNC-*)-1
      0  243a					      db	kCall
      1  243a		       30		      .byte.b	kCall
    853  243b				   ekCall
      0  243b					      TSTB	UNKNOWNVEC,oLeftBracket
      0  243b					      db	101
      1  243b		       65		      .byte.b	101
      0  243c					      db	(UNKNOWNVEC-*)-1
      1  243c		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  243d					      db	oLeftBracket
      1  243d		       e0		      .byte.b	oLeftBracket
      0  243e					      CALL	EXPR
      0  243e					      db	28
      1  243e		       1c		      .byte.b	28
      0  243f					      dw	EXPR
      1  243f		       f8 22		      .word.w	EXPR
      0  2441					      TSTB	F2B2A,oComma
      0  2441					      db	101
      1  2441		       65		      .byte.b	101
      0  2442					      db	(F2B2A-*)-1
      1  2442		       09		      .byte.b	(F2B2A-*)-1
      0  2443					      db	oComma
      1  2443		       e2		      .byte.b	oComma
      0  2444					      CALL	EXPR
      0  2444					      db	28
      1  2444		       1c		      .byte.b	28
      0  2445					      dw	EXPR
      1  2445		       f8 22		      .word.w	EXPR
      0  2447					      TSTB	UNKNOWNVEC,oRightBracket
      0  2447					      db	101
      1  2447		       65		      .byte.b	101
      0  2448					      db	(UNKNOWNVEC-*)-1
      1  2448		       25		      .byte.b	(UNKNOWNVEC-*)-1
      0  2449					      db	oRightBracket
      1  2449		       e1		      .byte.b	oRightBracket
      0  244a					      CALLFUNC
      0  244a					      db	53
      1  244a		       35		      .byte.b	53
      0  244b					      RTN
      0  244b					      db	25
      1  244b		       19		      .byte.b	25
    861  244c							; Run the gosub within this function
    862  244c				   F2B2A
      0  244c					      TSTB	UNKNOWNID,oRightBracket
      0  244c					      db	101
      1  244c		       65		      .byte.b	101
      0  244d					      db	(UNKNOWNID-*)-1
      1  244d		       b0		      .byte.b	(UNKNOWNID-*)-1
      0  244e					      db	oRightBracket
      1  244e		       e1		      .byte.b	oRightBracket
      0  244f					      LIT	0	; No parameter passed so just load zero to A
      0  244f					      db	27
      1  244f		       1b		      .byte.b	27
      0  2450					      dw	0
      1  2450		       00 00		      .word.w	0
      0  2452					      CALLFUNC
      0  2452					      db	53
      1  2452		       35		      .byte.b	53
      0  2453					      RTN
      0  2453					      db	25
      1  2453		       19		      .byte.b	25
    867  2454							;===========================================================================
    868  2454							; Same as gosub but expects a return value
    869  2454							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    870  2454							;
      0  2454				   F2FUNC     TSTB	F2C,kGofn
      0  2454					      db	101
      1  2454		       65		      .byte.b	101
      0  2455					      db	(F2C-*)-1
      1  2455		       19		      .byte.b	(F2C-*)-1
      0  2456					      db	kGofn
      1  2456		       31		      .byte.b	kGofn
    872  2457				   ekGofn
      0  2457					      Call	GOSUBSTATEMENT
      0  2457					      db	28
      1  2457		       1c		      .byte.b	28
      0  2458					      dw	GOSUBSTATEMENT
      1  2458		       83 24		      .word.w	GOSUBSTATEMENT
      0  245a					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  245a					      db	8
      1  245a		       08		      .byte.b	8
      0  245b					      db	GOSUB_RTN_VALUE
      1  245b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  245c					      XFER
      0  245c					      db	7
      1  245c		       07		      .byte.b	7
    876  245d				   GOFNRet
      0  245d					      RTN
      0  245d					      db	25
      1  245d		       19		      .byte.b	25
    878  245e
    879  245e							;=================================================================================
    880  245e							;Check for a number !
    881  245e							;
    882  245e				   F0
    883  245e				   FactNumber
      0  245e					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  245e					      db	35
      1  245e		       23		      .byte.b	35
      0  245f					      db	(FactVariable-*)-1
      1  245f		       0f		      .byte.b	(FactVariable-*)-1
      0  2460					      RTN
      0  2460					      db	25
      1  2460		       19		      .byte.b	25
    886  2461				   F1
      0  2461					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  2461					      db	101
      1  2461		       65		      .byte.b	101
      0  2462					      db	(F2RTN-*)-1
      1  2462		       08		      .byte.b	(F2RTN-*)-1
      0  2463					      db	oLeftBracket
      1  2463		       e0		      .byte.b	oLeftBracket
      0  2464					      CALL	EXPR
      0  2464					      db	28
      1  2464		       1c		      .byte.b	28
      0  2465					      dw	EXPR
      1  2465		       f8 22		      .word.w	EXPR
      0  2467					      TST	F2,oRightBracket
      0  2467					      db	32
      1  2467		       20		      .byte.b	32
      0  2468					      db	(F2-*)-1
      1  2468		       03		      .byte.b	(F2-*)-1
      0  2469					      db	oRightBracket,0
      1  2469		       e1 00		      .byte.b	oRightBracket,0
    890  246b				   F2RTN
      0  246b					      RTN
      0  246b					      db	25
      1  246b		       19		      .byte.b	25
    892  246c
    893  246c				   F2
      0  246c					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  246c					      db	13
      1  246c		       0d		      .byte.b	13
      0  246d					      dw	ERR_SYNTAX
      1  246d		       05 00		      .word.w	ERR_SYNTAX
    895  246f							;
    896  246f							;=============================================================================
    897  246f							; See if this is just a simple variable
    898  246f							;  Allow a subscript for any variable
    899  246f							;
    900  246f				   F2C
    901  246f
    902  246f				   FactVariable
      0  246f					      TSTV	F1
      0  246f					      db	33
      1  246f		       21		      .byte.b	33
      0  2470					      db	(F1-*)-1
      1  2470		       f0		      .byte.b	(F1-*)-1
      0  2471					      TSTB	F2CLocalTask,oBang
      0  2471					      db	101
      1  2471		       65		      .byte.b	101
      0  2472					      db	(F2CLocalTask-*)-1
      1  2472		       04		      .byte.b	(F2CLocalTask-*)-1
      0  2473					      db	oBang
      1  2473		       e8		      .byte.b	oBang
      0  2474					      IND		; we just got a pid
      0  2474					      db	20
      1  2474		       14		      .byte.b	20
      0  2475					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  2475					      db	93
      1  2475		       5d		      .byte.b	93
      0  2476					      db	(UNKNOWNID-*)-1
      1  2476		       87		      .byte.b	(UNKNOWNID-*)-1
    907  2477
    908  2477				   F2CLocalTask
      0  2477					      TSTB	F2C1,oLeftSQBracket
      0  2477					      db	101
      1  2477		       65		      .byte.b	101
      0  2478					      db	(F2C1-*)-1
      1  2478		       08		      .byte.b	(F2C1-*)-1
      0  2479					      db	oLeftSQBracket
      1  2479		       e4		      .byte.b	oLeftSQBracket
      0  247a					      CALL	EXPR
      0  247a					      db	28
      1  247a		       1c		      .byte.b	28
      0  247b					      dw	EXPR
      1  247b		       f8 22		      .word.w	EXPR
      0  247d					      TSTB	UNKNOWNID,oRightSQBracket
      0  247d					      db	101
      1  247d		       65		      .byte.b	101
      0  247e					      db	(UNKNOWNID-*)-1
      1  247e		       7f		      .byte.b	(UNKNOWNID-*)-1
      0  247f					      db	oRightSQBracket
      1  247f		       e5		      .byte.b	oRightSQBracket
      0  2480					      SUBSCRIPT
      0  2480					      db	64
      1  2480		       40		      .byte.b	64
    913  2481				   F2C1
      0  2481					      IND		; YES, GET THE VALUE.
      0  2481					      db	20
      1  2481		       14		      .byte.b	20
      0  2482					      RTN
      0  2482					      db	25
      1  2482		       19		      .byte.b	25
    916  2483
    917  2483							;=============================================================
    918  2483							; Gosub can be both a Function and a Subroutine
    919  2483				   GOSUBSTATEMENT
      0  2483					      CALL	EXPR	;GET DESTINATION
      0  2483					      db	28
      1  2483		       1c		      .byte.b	28
      0  2484					      dw	EXPR
      1  2484		       f8 22		      .word.w	EXPR
      0  2486					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  2486					      db	101
      1  2486		       65		      .byte.b	101
      0  2487					      db	(GOSUBDONE-*)-1
      1  2487		       11		      .byte.b	(GOSUBDONE-*)-1
      0  2488					      db	oLeftBracket
      1  2488		       e0		      .byte.b	oLeftBracket
      0  2489					      STK2TMP		;Transfer stack top to temp
      0  2489					      db	95
      1  2489		       5f		      .byte.b	95
      0  248a					      PUSHMATHSTACK		;Record stack frame for return
      0  248a					      db	84
      1  248a		       54		      .byte.b	84
    924  248b				   GOSUBLOOP
      0  248b					      CALL	EXPR	; Allows what ever fits onto stack
      0  248b					      db	28
      1  248b		       1c		      .byte.b	28
      0  248c					      dw	EXPR
      1  248c		       f8 22		      .word.w	EXPR
      0  248e					      INCPARMCOUNT
      0  248e					      db	88
      1  248e		       58		      .byte.b	88
      0  248f					      TSTB	GOSUBParmDONE,oComma
      0  248f					      db	101
      1  248f		       65		      .byte.b	101
      0  2490					      db	(GOSUBParmDONE-*)-1
      1  2490		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  2491					      db	oComma
      1  2491		       e2		      .byte.b	oComma
      0  2492					      IJMP	GOSUBLOOP
      0  2492					      db	29
      1  2492		       1d		      .byte.b	29
      0  2493					      dw	GOSUBLOOP
      1  2493		       8b 24		      .word.w	GOSUBLOOP
    929  2495				   GOSUBParmDONE
      0  2495					      TSTB	F2,oRightBracket
      0  2495					      db	101
      1  2495		       65		      .byte.b	101
      0  2496					      db	(F2-*)-1
      1  2496		       d5		      .byte.b	(F2-*)-1
      0  2497					      db	oRightBracket
      1  2497		       e1		      .byte.b	oRightBracket
      0  2498					      TMP2STK		;Restore line to goto
      0  2498					      db	96
      1  2498		       60		      .byte.b	96
    932  2499				   GOSUBDONE
      0  2499					      RTN
      0  2499					      db	25
      1  2499		       19		      .byte.b	25
    934  249a
    935  249a		       24 9a	   ILEND      equ	*
------- FILE mytb.asm
   2327  249a		       24 9a	   PROGEND    equ	*
   2328  249a
   2329  249a
   2330  249a							;=====================================================
   2331  249a							; Define start of non page zero data
   2332 U24dc					      seg.u	TBData
   2333 U24dc
   2334 U24dc							;=====================================================
   2335 U24dc							; These are storage items not in page zero.
   2336 U24dc							;
   2337 U24dc							; IRQ BASIC Code Service RTN Support
      0 U24dc				   SaveIrqReg db	0	; Store current setting
      1 U24dc		       00		      .byte.b	0
      0 U24dd				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U24dd		       00		      .byte.b	0
      0 U24de				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U24de		       00		      .byte.b	0
      0 U24df				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U24df		       00 00		      .byte.b	0,0
   2342 U24e1
   2343 U24e1							;
   2344 U24e1							;==================================================================================================
   2345 U24e1							; Task Management information
   2346 U24e1							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2347 U24e1							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2348 U24e1							; Task switchs happen at the beginning of the next Basic command line
   2349 U24e1							; It will not happen during an input or output operations
   2350 U24e1							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2351 U24e1							; Task Zero is always the root task, main line program
   2352 U24e1							;
   2353 U24e1							; Layout is repeated for each configured task
   2354 U24e1							; Task Table Byte   use masks follow
   2355 U24e1		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2356 U24e1		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2357 U24e1		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2358 U24e1		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2359 U24e1		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2360 U24e1
   2361 U24e1		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2362 U24e2		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2363 U24e2		       25 dc	   TASKTABLEEND equ	*	; End of task table
   2364 U24e2		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2365 U25dc
   2366 U25dc							;Task Cycle Counter and reset count
   2367 U25dc		       00 00	   taskCurrentCycles ds	2
   2368 U25de		       00 00	   taskResetValue ds	2
   2369 U25e0		       00	   taskCounter ds	1	; Count of active tasks
   2370 U25e1
   2371 U25e1							;
   2372 U25e1							; Math stack and IL call and Gosub/For-next return stack definitions
   2373 U25e1							;
   2374 U25e1		       25 e1	   STACKSTART equ	*
   2375 U25e1		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2376 U2771		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2377 U2901		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2378 U2b81		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2379 U2b81		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2380 U2b81		       2d 9d	   STACKEND   equ	*
   2381 U2b81		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2382 U2d9d							;
   2383 U2d9d							;
   2384 U2d9d		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2385 U2e21		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2386 U2e22		       00	   printtx    ds	1	;temp X for print funcs
   2387 U2e23		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2388 U2e24		       00	   promptChar ds	1	;the character to use for a prompt
   2389 U2e25		       00	   diddigit   ds	1	;for leading zero suppression
   2390 U2e26		       00	   putsy      ds	1
   2391 U2e27		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2392 U2e29		       00	   sign       ds	1	;0 = positive, else negative
   2393 U2e2a		       00 00	   rtemp1     ds	2	;Temp for x and y
   2394 U2e2c		       00 00	   random     ds	2
   2395 U2e2e		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2396 U2e30		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2397 U2e32		       00	   tempy      ds	1	;temp y storage
   2398 U2e33
   2399 U2e33							; Moved from page zero as one clock cycle diff gives more space on page zero
   2400 U2e33		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2401 U2e35		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2402 U2e36		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2403 U2e37		       00	   lineLength ds	1	;Length of current line
   2404 U2e38
   2405 U2e38		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2406 U2e39		       00	   taskRDPending ds	1	; 1 = background read is pending
   2407 U2e3a
   2408 U2e3a				  -	      if	XKIM
   2409 U2e3a				  -buffer     ds	BUFFER_SIZE
   2410 U2e3a					      endif
   2411 U2e3a							;
   2412 U2e3a							; PROGRAMEND is the end of the user's BASIC program.
   2413 U2e3a							; More precisely, it is one byte past the end.  Or,
   2414 U2e3a							; it's where the next line added to the end will be
   2415 U2e3a							; placed.
   2416 U2e3a							;
   2417 U2e3a		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2418 U2e3c		       00 00	   ProgramEnd ds	2	; End of users basic program
   2419 U2e3e		       00 00	   HighMem    ds	2	; highest location
   2420 U2e40		       00 00	   UsedMem    ds	2	; size of user program
   2421 U2e42		       00 00	   FreeMem    ds	2	; amount of free memory
   2422 U2e44							;
   2423 U2e44							;=====================================================
   2424 U2e44							; This is the start of the user's BASIC program space.
   2425 U2e44							;
   2426 U2e44							; PERSONAL GOAL: This should be no larger than $0DFF.
   2427 U2e44							;		  0200-05FF = 1K
   2428 U2e44							;		  0200-09FF = 2K
   2429 U2e44							;		  0200-0DFF = 3K
   2430 U2e44							;		  0200-11FF = 4K
   2431 U2e44							;		  0200-13FF = 4.5K
   2432 U2e44							;
   2433 U2e44				  -	      if	FIXED
   2434 U2e44				  -	      org	$2000
   2435 U2e44					      endif
   2436 U2e44
   2437 U2e44		       2e 44	   FreeMemStart equ	*
   2438 U2e44							;/*
   2439 U2e44							;	if	CTMON65 || XKIM
   2440 U2e44							;		SEG Code
   2441 U2e44							;		org	AutoRun
   2442 U2e44							;		dw	TBasicCold
   2443 U2e44							;	endif
   2444 U2e44							;*/
   2445 U2e44					      end
